[
  {
    "cve_id": "CVE-2013-7250",
    "code_before_change": "{\n  final private StringBuilder sb = new StringBuilder();\n\n  /**\n   * Creates Json result string from the given list.<br/>\n   * [[\"Horst\"], [\"Klaus\"], ...]] // For single property<br/>\n   * [[\"Klein\", \"Horst\"],[\"Schmidt\", \"Klaus\"], ...] // For two Properties (e. g. name, first name) [[\"id:37\", \"Klein\", \"Horst\"],[\"id:42\",\n   * \"Schmidt\", \"Klaus\"], ...] // For two Properties (e. g. name, first name) with id. <br/>\n   * Uses ObjectUtils.toString(Object) for formatting each value.\n   * @param col The array representation: List<Object> or List<Object[]>. If null then \"[]\" is returned.\n   * @return\n   */\n  public static String buildToStringRows(final Collection< ? > col)\n  {\n    if (col == null) {\n      return \"[]\";\n    }\n    final JsonBuilder builder = new JsonBuilder();\n    return builder.append(col).getAsString();\n  }\n\n  public String getAsString()\n  {\n    return sb.toString();\n  }\n\n  /**\n   * Appends objects to buffer, e. g.: [\"Horst\"], [\"Klaus\"], ... Uses formatValue(Object) to render the values.\n   * @param oArray\n   * @return This (fluent)\n   */\n  public JsonBuilder append(final Object[] oArray)\n  {\n    sb.append(\" [\"); // begin array\n    String separator = \"\";\n    for (final Object obj : oArray) {\n      sb.append(separator);\n      separator = \",\";\n      sb.append(escapeString(formatValue(obj)));\n    }\n    sb.append(\"]\"); // end array\n    return this;\n  }\n\n  private String escapeString(final String string)\n  {\n    if (string == null || string.length() == 0) {\n      return \"\\\"\\\"\";\n    }\n    char c = 0;\n    int i;\n    final int len = string.length();\n    final StringBuilder sb = new StringBuilder(len + 4);\n    String t;\n    sb.append('\"');\n    for (i = 0; i < len; i += 1) {\n      c = string.charAt(i);\n      switch (c) {\n        case '\\\\':\n        case '\"':\n          sb.append('\\\\');\n          sb.append(c);\n          break;\n        case '/':\n          // if (b == '<') {\n          sb.append('\\\\');\n          // }\n          sb.append(c);\n          break;\n        case '\\b':\n          sb.append(\"\\\\b\");\n          break;\n        case '\\t':\n          sb.append(\"\\\\t\");\n          break;\n        case '\\n':\n          sb.append(\"\\\\n\");\n          break;\n        case '\\f':\n          sb.append(\"\\\\f\");\n          break;\n        case '\\r':\n          sb.append(\"\\\\r\");\n          break;\n        default:\n          if (c < ' ') {\n            t = \"000\" + Integer.toHexString(c);\n            sb.append(\"\\\\u\" + t.substring(t.length() - 4));\n          } else {\n            sb.append(c);\n          }\n      }\n    }\n    sb.append('\"');\n    return sb.toString();\n  }\n\n  /**\n   * Creates Json result string from the given list.<br/>\n   * [[\"Horst\"], [\"Klaus\"], ...]] // For single property<br/>\n   * [[\"Klein\", \"Horst\"],[\"Schmidt\", \"Klaus\"], ...] // For two Properties (e. g. name, first name) [[\"id:37\", \"Klein\", \"Horst\"],[\"id:42\",\n   * \"Schmidt\", \"Klaus\"], ...] // For two Properties (e. g. name, first name) with id. <br/>\n   * Uses formatValue(Object) for formatting each value.\n   * @param col The array representation: List<Object> or List<Object[]>. If null then \"[]\" is returned.\n   * @return\n   */\n  public JsonBuilder append(final Collection< ? > col)\n  {\n    if (col == null) {\n      sb.append(\"[]\");\n      return this;\n    }\n    // Format: [[\"1.1\", \"1.2\", ...],[\"2.1\", \"2.2\", ...]]\n    sb.append(\"[\\n\");\n    String separator = \"\\n\";\n    for (final Object os : col) {\n      sb.append(separator);\n      separator = \",\\n\";\n      if (os instanceof Object[]) { // Multiple properties\n        append((Object[]) os);\n      } else { // Only one property\n        append(transform(os));\n      }\n    }\n    sb.append(\"]\"); // end data\n    return this;\n  }\n\n  /**\n   * @param obj\n   * @return\n   * @see ObjectUtils#toString(Object)\n   */\n  protected String formatValue(final Object obj)\n  {\n    return ObjectUtils.toString(obj);\n  }\n\n  protected JsonBuilder append(final Object obj)\n  {\n    if (obj instanceof Object[]) {\n      return append((Object[]) obj);\n    }\n    sb.append(\" [\"); // begin row\n    // \" must be quoted as \\\":\n    sb.append(escapeString(formatValue(obj)));\n    sb.append(\"]\"); // end row\n    return this;\n  }\n\n  /**\n   * Before rendering a obj of e. g. a collection the obj can be transformed e. g. in an Object array of dimension 2 containing label and\n   * value.\n   * @param obj\n   * @return obj (identity function) if not overload.\n   */\n  protected Object transform(final Object obj)\n  {\n    return obj;\n  }\n}",
    "code_after_change": "{\n  final private StringBuilder sb = new StringBuilder();\n\n  private boolean escapeHtml;\n\n  /**\n   * Creates Json result string from the given list.<br/>\n   * [[\"Horst\"], [\"Klaus\"], ...]] // For single property<br/>\n   * [[\"Klein\", \"Horst\"],[\"Schmidt\", \"Klaus\"], ...] // For two Properties (e. g. name, first name) [[\"id:37\", \"Klein\", \"Horst\"],[\"id:42\",\n   * \"Schmidt\", \"Klaus\"], ...] // For two Properties (e. g. name, first name) with id. <br/>\n   * Uses ObjectUtils.toString(Object) for formatting each value.\n   * @param col The array representation: List<Object> or List<Object[]>. If null then \"[]\" is returned.\n   * @return\n   */\n  public static String buildToStringRows(final Collection< ? > col)\n  {\n    if (col == null) {\n      return \"[]\";\n    }\n    final JsonBuilder builder = new JsonBuilder();\n    return builder.append(col).getAsString();\n  }\n\n  /**\n   * @param escapeHtml the escapeHtml to set (default is false).\n   * @return this for chaining.\n   */\n  public JsonBuilder setEscapeHtml(final boolean escapeHtml)\n  {\n    this.escapeHtml = escapeHtml;\n    return this;\n  }\n\n  public String getAsString()\n  {\n    return sb.toString();\n  }\n\n  /**\n   * Appends objects to buffer, e. g.: [\"Horst\"], [\"Klaus\"], ... Uses formatValue(Object) to render the values.\n   * @param oArray\n   * @return This (fluent)\n   */\n  public JsonBuilder append(final Object[] oArray)\n  {\n    sb.append(\" [\"); // begin array\n    String separator = \"\";\n    for (final Object obj : oArray) {\n      sb.append(separator);\n      separator = \",\";\n      sb.append(escapeString(formatValue(obj)));\n    }\n    sb.append(\"]\"); // end array\n    return this;\n  }\n\n  private String escapeString(final String string)\n  {\n    if (string == null || string.length() == 0) {\n      return \"\\\"\\\"\";\n    }\n    char c = 0;\n    int i;\n    final int len = string.length();\n    final StringBuilder sb = new StringBuilder(len + 4);\n    String t;\n    sb.append('\"');\n    for (i = 0; i < len; i += 1) {\n      c = string.charAt(i);\n      switch (c) {\n        case '\\\\':\n        case '\"':\n          sb.append('\\\\');\n          sb.append(c);\n          break;\n        case '/':\n          // if (b == '<') {\n          sb.append('\\\\');\n          // }\n          sb.append(c);\n          break;\n        case '\\b':\n          sb.append(\"\\\\b\");\n          break;\n        case '\\t':\n          sb.append(\"\\\\t\");\n          break;\n        case '\\n':\n          sb.append(\"\\\\n\");\n          break;\n        case '\\f':\n          sb.append(\"\\\\f\");\n          break;\n        case '\\r':\n          sb.append(\"\\\\r\");\n          break;\n        default:\n          if (c < ' ') {\n            t = \"000\" + Integer.toHexString(c);\n            sb.append(\"\\\\u\" + t.substring(t.length() - 4));\n          } else {\n            if (escapeHtml == true) {\n              switch (c) {\n                case '<':\n                  sb.append(\"&lt;\");\n                  break;\n                case '>':\n                  sb.append(\"&gt;\");\n                  break;\n                case '&':\n                  sb.append(\"&amp;\");\n                  break;\n                case '\"':\n                  sb.append(\"&quot;\");\n                  break;\n                case '\\'':\n                  sb.append(\"&#x27;\");\n                  break;\n                case '/':\n                  sb.append(\"&#x2F;\");\n                  break;\n                default:\n                  sb.append(c);\n              }\n            } else {\n              sb.append(c);\n            }\n          }\n      }\n    }\n    sb.append('\"');\n    return sb.toString();\n  }\n\n  /**\n   * Creates Json result string from the given list.<br/>\n   * [[\"Horst\"], [\"Klaus\"], ...]] // For single property<br/>\n   * [[\"Klein\", \"Horst\"],[\"Schmidt\", \"Klaus\"], ...] // For two Properties (e. g. name, first name) [[\"id:37\", \"Klein\", \"Horst\"],[\"id:42\",\n   * \"Schmidt\", \"Klaus\"], ...] // For two Properties (e. g. name, first name) with id. <br/>\n   * Uses formatValue(Object) for formatting each value.\n   * @param col The array representation: List<Object> or List<Object[]>. If null then \"[]\" is returned.\n   * @return\n   */\n  public JsonBuilder append(final Collection< ? > col)\n  {\n    if (col == null) {\n      sb.append(\"[]\");\n      return this;\n    }\n    // Format: [[\"1.1\", \"1.2\", ...],[\"2.1\", \"2.2\", ...]]\n    sb.append(\"[\\n\");\n    String separator = \"\\n\";\n    for (final Object os : col) {\n      sb.append(separator);\n      separator = \",\\n\";\n      if (os instanceof Object[]) { // Multiple properties\n        append((Object[]) os);\n      } else { // Only one property\n        append(transform(os));\n      }\n    }\n    sb.append(\"]\"); // end data\n    return this;\n  }\n\n  /**\n   * @param obj\n   * @return\n   * @see ObjectUtils#toString(Object)\n   */\n  protected String formatValue(final Object obj)\n  {\n    return ObjectUtils.toString(obj);\n  }\n\n  protected JsonBuilder append(final Object obj)\n  {\n    if (obj instanceof Object[]) {\n      return append((Object[]) obj);\n    }\n    sb.append(\" [\"); // begin row\n    // \" must be quoted as \\\":\n    sb.append(escapeString(formatValue(obj)));\n    sb.append(\"]\"); // end row\n    return this;\n  }\n\n  /**\n   * Before rendering a obj of e. g. a collection the obj can be transformed e. g. in an Object array of dimension 2 containing label and\n   * value.\n   * @param obj\n   * @return obj (identity function) if not overload.\n   */\n  protected Object transform(final Object obj)\n  {\n    return obj;\n  }\n}",
    "patch": "@@ -31,6 +31,8 @@ public class JsonBuilder\n {\n   final private StringBuilder sb = new StringBuilder();\n \n+  private boolean escapeHtml;\n+\n   /**\n    * Creates Json result string from the given list.<br/>\n    * [[\"Horst\"], [\"Klaus\"], ...]] // For single property<br/>\n@@ -49,6 +51,16 @@ public static String buildToStringRows(final Collection< ? > col)\n     return builder.append(col).getAsString();\n   }\n \n+  /**\n+   * @param escapeHtml the escapeHtml to set (default is false).\n+   * @return this for chaining.\n+   */\n+  public JsonBuilder setEscapeHtml(final boolean escapeHtml)\n+  {\n+    this.escapeHtml = escapeHtml;\n+    return this;\n+  }\n+\n   public String getAsString()\n   {\n     return sb.toString();\n@@ -117,7 +129,32 @@ private String escapeString(final String string)\n             t = \"000\" + Integer.toHexString(c);\n             sb.append(\"\\\\u\" + t.substring(t.length() - 4));\n           } else {\n-            sb.append(c);\n+            if (escapeHtml == true) {\n+              switch (c) {\n+                case '<':\n+                  sb.append(\"&lt;\");\n+                  break;\n+                case '>':\n+                  sb.append(\"&gt;\");\n+                  break;\n+                case '&':\n+                  sb.append(\"&amp;\");\n+                  break;\n+                case '\"':\n+                  sb.append(\"&quot;\");\n+                  break;\n+                case '\\'':\n+                  sb.append(\"&#x27;\");\n+                  break;\n+                case '/':\n+                  sb.append(\"&#x2F;\");\n+                  break;\n+                default:\n+                  sb.append(c);\n+              }\n+            } else {\n+              sb.append(c);\n+            }\n           }\n       }\n     }",
    "function_modified_lines": {
      "added": [
        "  private boolean escapeHtml;\n",
        "\n",
        "  /**\n",
        "   * @param escapeHtml the escapeHtml to set (default is false).\n",
        "   * @return this for chaining.\n",
        "   */\n",
        "  public JsonBuilder setEscapeHtml(final boolean escapeHtml)\n",
        "  {\n",
        "    this.escapeHtml = escapeHtml;\n",
        "    return this;\n",
        "  }\n",
        "\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-79"
    ],
    "cve_description": "Cross-site scripting (XSS) vulnerability in the JsonBuilder implementation in ProjectForge before 5.3 allows remote authenticated users to inject arbitrary web script or HTML via an autocompletion string, related to web/core/JsonBuilder.java and web/wicket/autocompletion/PFAutoCompleteBehavior.java.",
    "id": 11976
  },
  {
    "cve_id": "CVE-2018-1000129",
    "code_before_change": "{\n            // Check access policy\n            InetSocketAddress address = pExchange.getRemoteAddress();\n            requestHandler.checkAccess(getHostName(address),\n                                       address.getAddress().getHostAddress(),\n                                       extractOriginOrReferer(pExchange));\n            String method = pExchange.getRequestMethod();\n\n            // Dispatch for the proper HTTP request method\n            if (\"GET\".equalsIgnoreCase(method)) {\n                setHeaders(pExchange);\n                json = executeGetRequest(parsedUri);\n            } else if (\"POST\".equalsIgnoreCase(method)) {\n                setHeaders(pExchange);\n                json = executePostRequest(pExchange, parsedUri);\n            } else if (\"OPTIONS\".equalsIgnoreCase(method)) {\n                performCorsPreflightCheck(pExchange);\n            } else {\n                throw new IllegalArgumentException(\"HTTP Method \" + method + \" is not supported.\");\n            }\n        }",
    "code_after_change": "{\n            // Check access policy\n            InetSocketAddress address = pExchange.getRemoteAddress();\n            requestHandler.checkAccess(getHostName(address),\n                                       address.getAddress().getHostAddress(),\n                                       extractOriginOrReferer(pExchange));\n            String method = pExchange.getRequestMethod();\n\n            // If a callback is given, check this is a valid javascript function name\n            validateCallbackIfGiven(parsedUri);\n\n            // Dispatch for the proper HTTP request method\n            if (\"GET\".equalsIgnoreCase(method)) {\n                setHeaders(pExchange);\n                json = executeGetRequest(parsedUri);\n            } else if (\"POST\".equalsIgnoreCase(method)) {\n                setHeaders(pExchange);\n                json = executePostRequest(pExchange, parsedUri);\n            } else if (\"OPTIONS\".equalsIgnoreCase(method)) {\n                performCorsPreflightCheck(pExchange);\n            } else {\n                throw new IllegalArgumentException(\"HTTP Method \" + method + \" is not supported.\");\n            }\n        }",
    "patch": "@@ -224,6 +224,9 @@ public void doHandle(HttpExchange pExchange) throws IOException {\n                                        extractOriginOrReferer(pExchange));\n             String method = pExchange.getRequestMethod();\n \n+            // If a callback is given, check this is a valid javascript function name\n+            validateCallbackIfGiven(parsedUri);\n+\n             // Dispatch for the proper HTTP request method\n             if (\"GET\".equalsIgnoreCase(method)) {\n                 setHeaders(pExchange);\n@@ -244,6 +247,14 @@ public void doHandle(HttpExchange pExchange) throws IOException {\n         }\n     }\n \n+\n+    private void validateCallbackIfGiven(ParsedUri pUri) {\n+        String callback = pUri.getParameter(ConfigKey.CALLBACK.getKeyValue());\n+        if (callback != null && !MimeTypeUtil.isValidCallback(callback)) {\n+            throw new IllegalArgumentException(\"Invalid callback name given, which must be a valid javascript function name\");\n+        }\n+    }\n+\n     // ========================================================================\n \n     // Used for checking origin or referer is an origin policy is enabled\n@@ -342,10 +353,11 @@ private void sendStreamingResponse(HttpExchange pExchange, ParsedUri pParsedUri,\n         Headers headers = pExchange.getResponseHeaders();\n         if (pJson != null) {\n             headers.set(\"Content-Type\", getMimeType(pParsedUri) + \"; charset=utf-8\");\n-            String callback = pParsedUri.getParameter(ConfigKey.CALLBACK.getKeyValue());\n             pExchange.sendResponseHeaders(200, 0);\n             Writer writer = new OutputStreamWriter(pExchange.getResponseBody(), \"UTF-8\");\n-            IoUtil.streamResponseAndClose(writer, pJson, callback);\n+\n+            String callback = pParsedUri.getParameter(ConfigKey.CALLBACK.getKeyValue());\n+            IoUtil.streamResponseAndClose(writer, pJson, callback != null && MimeTypeUtil.isValidCallback(callback) ? callback : null);\n         } else {\n             headers.set(\"Content-Type\", \"text/plain\");\n             pExchange.sendResponseHeaders(200,-1);\n@@ -360,7 +372,7 @@ private void sendAllJSON(HttpExchange pExchange, ParsedUri pParsedUri, JSONAware\n                 headers.set(\"Content-Type\", getMimeType(pParsedUri) + \"; charset=utf-8\");\n                 String json = pJson.toJSONString();\n                 String callback = pParsedUri.getParameter(ConfigKey.CALLBACK.getKeyValue());\n-                String content = callback == null ? json : callback + \"(\" + json + \");\";\n+                String content = callback != null && MimeTypeUtil.isValidCallback(callback) ? callback + \"(\" + json + \");\" : json;\n                 byte[] response = content.getBytes(\"UTF8\");\n                 pExchange.sendResponseHeaders(200,response.length);\n                 out = pExchange.getResponseBody();\n@@ -380,16 +392,10 @@ private void sendAllJSON(HttpExchange pExchange, ParsedUri pParsedUri, JSONAware\n \n     // Get the proper mime type according to configuration\n     private String getMimeType(ParsedUri pParsedUri) {\n-        if (pParsedUri.getParameter(ConfigKey.CALLBACK.getKeyValue()) != null) {\n-            return \"text/javascript\";\n-        } else {\n-            String mimeType = pParsedUri.getParameter(ConfigKey.MIME_TYPE.getKeyValue());\n-            if (mimeType != null) {\n-                return mimeType;\n-            }\n-            mimeType = configuration.get(ConfigKey.MIME_TYPE);\n-            return mimeType != null ? mimeType : ConfigKey.MIME_TYPE.getDefaultValue();\n-        }\n+        return MimeTypeUtil.getResponseMimeType(\n+            pParsedUri.getParameter(ConfigKey.MIME_TYPE.getKeyValue()),\n+            configuration.get(ConfigKey.MIME_TYPE),\n+            pParsedUri.getParameter(ConfigKey.CALLBACK.getKeyValue()));\n     }\n \n     // Creat a log handler from either the given class or by creating a default log handler printing",
    "function_modified_lines": {
      "added": [
        "            // If a callback is given, check this is a valid javascript function name\n",
        "            validateCallbackIfGiven(parsedUri);\n",
        "\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-79"
    ],
    "cve_description": "An XSS vulnerability exists in the Jolokia agent version 1.3.7 in the HTTP servlet that allows an attacker to execute malicious javascript in the victim's browser.",
    "id": 11978
  },
  {
    "cve_id": "CVE-2018-1000129",
    "code_before_change": "    public void doHandle(HttpExchange pExchange) throws IOException {\n        if (requestHandler == null) {\n            throw new IllegalStateException(\"Handler not yet started\");\n        }\n\n        JSONAware json = null;\n        URI uri = pExchange.getRequestURI();\n        ParsedUri parsedUri = new ParsedUri(uri, context);\n        try {\n            // Check access policy\n            InetSocketAddress address = pExchange.getRemoteAddress();\n            requestHandler.checkAccess(getHostName(address),\n                                       address.getAddress().getHostAddress(),\n                                       extractOriginOrReferer(pExchange));\n            String method = pExchange.getRequestMethod();\n\n            // Dispatch for the proper HTTP request method\n            if (\"GET\".equalsIgnoreCase(method)) {\n                setHeaders(pExchange);\n                json = executeGetRequest(parsedUri);\n            } else if (\"POST\".equalsIgnoreCase(method)) {\n                setHeaders(pExchange);\n                json = executePostRequest(pExchange, parsedUri);\n            } else if (\"OPTIONS\".equalsIgnoreCase(method)) {\n                performCorsPreflightCheck(pExchange);\n            } else {\n                throw new IllegalArgumentException(\"HTTP Method \" + method + \" is not supported.\");\n            }\n        } catch (Throwable exp) {\n            json = requestHandler.handleThrowable(\n                    exp instanceof RuntimeMBeanException ? ((RuntimeMBeanException) exp).getTargetException() : exp);\n        } finally {\n            sendResponse(pExchange, parsedUri, json);\n        }\n    }\n\n    // ========================================================================\n\n    // Used for checking origin or referer is an origin policy is enabled\n    private String extractOriginOrReferer(HttpExchange pExchange) {\n        Headers headers = pExchange.getRequestHeaders();\n        String origin = headers.getFirst(\"Origin\");\n        if (origin == null) {\n            origin = headers.getFirst(\"Referer\");\n        }\n        return origin != null ? origin.replaceAll(\"[\\\\n\\\\r]*\",\"\") : null;\n    }\n\n    // Return hostnmae of given address, but only when reverse DNS lookups are allowed\n    private String getHostName(InetSocketAddress address) {\n        return configuration.getAsBoolean(ConfigKey.ALLOW_DNS_REVERSE_LOOKUP) ? address.getHostName() : null;\n    }\n\n    private JSONAware executeGetRequest(ParsedUri parsedUri) {\n        return requestHandler.handleGetRequest(parsedUri.getUri().toString(),parsedUri.getPathInfo(), parsedUri.getParameterMap());\n    }\n\n    private JSONAware executePostRequest(HttpExchange pExchange, ParsedUri pUri) throws MalformedObjectNameException, IOException {\n        String encoding = null;\n        Headers headers = pExchange.getRequestHeaders();\n        String cType =  headers.getFirst(\"Content-Type\");\n        if (cType != null) {\n            Matcher matcher = contentTypePattern.matcher(cType);\n            if (matcher.matches()) {\n                encoding = matcher.group(1);\n            }\n        }\n        InputStream is = pExchange.getRequestBody();\n        return requestHandler.handlePostRequest(pUri.toString(),is, encoding, pUri.getParameterMap());\n    }\n\n    private void performCorsPreflightCheck(HttpExchange pExchange) {\n        Headers requestHeaders = pExchange.getRequestHeaders();\n        Map<String,String> respHeaders =",
    "code_after_change": "        JSONAware json = null;\n        URI uri = pExchange.getRequestURI();\n        ParsedUri parsedUri = new ParsedUri(uri, context);\n        try {\n            // Check access policy\n            InetSocketAddress address = pExchange.getRemoteAddress();\n            requestHandler.checkAccess(getHostName(address),\n                                       address.getAddress().getHostAddress(),\n                                       extractOriginOrReferer(pExchange));\n            String method = pExchange.getRequestMethod();\n\n            // If a callback is given, check this is a valid javascript function name\n            validateCallbackIfGiven(parsedUri);\n\n            // Dispatch for the proper HTTP request method\n            if (\"GET\".equalsIgnoreCase(method)) {\n                setHeaders(pExchange);\n                json = executeGetRequest(parsedUri);\n            } else if (\"POST\".equalsIgnoreCase(method)) {\n                setHeaders(pExchange);\n                json = executePostRequest(pExchange, parsedUri);\n            } else if (\"OPTIONS\".equalsIgnoreCase(method)) {\n                performCorsPreflightCheck(pExchange);\n            } else {\n                throw new IllegalArgumentException(\"HTTP Method \" + method + \" is not supported.\");\n            }\n        } catch (Throwable exp) {\n            json = requestHandler.handleThrowable(\n                    exp instanceof RuntimeMBeanException ? ((RuntimeMBeanException) exp).getTargetException() : exp);\n        } finally {\n            sendResponse(pExchange, parsedUri, json);\n        }\n    }\n\n\n    private void validateCallbackIfGiven(ParsedUri pUri) {\n        String callback = pUri.getParameter(ConfigKey.CALLBACK.getKeyValue());\n        if (callback != null && !MimeTypeUtil.isValidCallback(callback)) {\n            throw new IllegalArgumentException(\"Invalid callback name given, which must be a valid javascript function name\");\n        }\n    }\n\n    // ========================================================================\n\n    // Used for checking origin or referer is an origin policy is enabled\n    private String extractOriginOrReferer(HttpExchange pExchange) {\n        Headers headers = pExchange.getRequestHeaders();\n        String origin = headers.getFirst(\"Origin\");\n        if (origin == null) {\n            origin = headers.getFirst(\"Referer\");\n        }\n        return origin != null ? origin.replaceAll(\"[\\\\n\\\\r]*\",\"\") : null;\n    }\n\n    // Return hostnmae of given address, but only when reverse DNS lookups are allowed\n    private String getHostName(InetSocketAddress address) {\n        return configuration.getAsBoolean(ConfigKey.ALLOW_DNS_REVERSE_LOOKUP) ? address.getHostName() : null;\n    }\n\n    private JSONAware executeGetRequest(ParsedUri parsedUri) {\n        return requestHandler.handleGetRequest(parsedUri.getUri().toString(),parsedUri.getPathInfo(), parsedUri.getParameterMap());\n    }\n\n    private JSONAware executePostRequest(HttpExchange pExchange, ParsedUri pUri) throws MalformedObjectNameException, IOException {\n        String encoding = null;\n        Headers headers = pExchange.getRequestHeaders();\n        String cType =  headers.getFirst(\"Content-Type\");\n        if (cType != null) {\n            Matcher matcher = contentTypePattern.matcher(cType);\n            if (matcher.matches()) {\n                encoding = matcher.group(1);\n            }\n        }\n        InputStream is = pExchange.getRequestBody();\n        return requestHandler.handlePostRequest(pUri.toString(),is, encoding, pUri.getParameterMap());\n    }\n\n    private void performCorsPreflightCheck(HttpExchange pExchange) {",
    "patch": "@@ -224,6 +224,9 @@ public void doHandle(HttpExchange pExchange) throws IOException {\n                                        extractOriginOrReferer(pExchange));\n             String method = pExchange.getRequestMethod();\n \n+            // If a callback is given, check this is a valid javascript function name\n+            validateCallbackIfGiven(parsedUri);\n+\n             // Dispatch for the proper HTTP request method\n             if (\"GET\".equalsIgnoreCase(method)) {\n                 setHeaders(pExchange);\n@@ -244,6 +247,14 @@ public void doHandle(HttpExchange pExchange) throws IOException {\n         }\n     }\n \n+\n+    private void validateCallbackIfGiven(ParsedUri pUri) {\n+        String callback = pUri.getParameter(ConfigKey.CALLBACK.getKeyValue());\n+        if (callback != null && !MimeTypeUtil.isValidCallback(callback)) {\n+            throw new IllegalArgumentException(\"Invalid callback name given, which must be a valid javascript function name\");\n+        }\n+    }\n+\n     // ========================================================================\n \n     // Used for checking origin or referer is an origin policy is enabled\n@@ -342,10 +353,11 @@ private void sendStreamingResponse(HttpExchange pExchange, ParsedUri pParsedUri,\n         Headers headers = pExchange.getResponseHeaders();\n         if (pJson != null) {\n             headers.set(\"Content-Type\", getMimeType(pParsedUri) + \"; charset=utf-8\");\n-            String callback = pParsedUri.getParameter(ConfigKey.CALLBACK.getKeyValue());\n             pExchange.sendResponseHeaders(200, 0);\n             Writer writer = new OutputStreamWriter(pExchange.getResponseBody(), \"UTF-8\");\n-            IoUtil.streamResponseAndClose(writer, pJson, callback);\n+\n+            String callback = pParsedUri.getParameter(ConfigKey.CALLBACK.getKeyValue());\n+            IoUtil.streamResponseAndClose(writer, pJson, callback != null && MimeTypeUtil.isValidCallback(callback) ? callback : null);\n         } else {\n             headers.set(\"Content-Type\", \"text/plain\");\n             pExchange.sendResponseHeaders(200,-1);\n@@ -360,7 +372,7 @@ private void sendAllJSON(HttpExchange pExchange, ParsedUri pParsedUri, JSONAware\n                 headers.set(\"Content-Type\", getMimeType(pParsedUri) + \"; charset=utf-8\");\n                 String json = pJson.toJSONString();\n                 String callback = pParsedUri.getParameter(ConfigKey.CALLBACK.getKeyValue());\n-                String content = callback == null ? json : callback + \"(\" + json + \");\";\n+                String content = callback != null && MimeTypeUtil.isValidCallback(callback) ? callback + \"(\" + json + \");\" : json;\n                 byte[] response = content.getBytes(\"UTF8\");\n                 pExchange.sendResponseHeaders(200,response.length);\n                 out = pExchange.getResponseBody();\n@@ -380,16 +392,10 @@ private void sendAllJSON(HttpExchange pExchange, ParsedUri pParsedUri, JSONAware\n \n     // Get the proper mime type according to configuration\n     private String getMimeType(ParsedUri pParsedUri) {\n-        if (pParsedUri.getParameter(ConfigKey.CALLBACK.getKeyValue()) != null) {\n-            return \"text/javascript\";\n-        } else {\n-            String mimeType = pParsedUri.getParameter(ConfigKey.MIME_TYPE.getKeyValue());\n-            if (mimeType != null) {\n-                return mimeType;\n-            }\n-            mimeType = configuration.get(ConfigKey.MIME_TYPE);\n-            return mimeType != null ? mimeType : ConfigKey.MIME_TYPE.getDefaultValue();\n-        }\n+        return MimeTypeUtil.getResponseMimeType(\n+            pParsedUri.getParameter(ConfigKey.MIME_TYPE.getKeyValue()),\n+            configuration.get(ConfigKey.MIME_TYPE),\n+            pParsedUri.getParameter(ConfigKey.CALLBACK.getKeyValue()));\n     }\n \n     // Creat a log handler from either the given class or by creating a default log handler printing",
    "function_modified_lines": {
      "added": [
        "\n",
        "    private void validateCallbackIfGiven(ParsedUri pUri) {\n",
        "        String callback = pUri.getParameter(ConfigKey.CALLBACK.getKeyValue());\n",
        "        if (callback != null && !MimeTypeUtil.isValidCallback(callback)) {\n",
        "            throw new IllegalArgumentException(\"Invalid callback name given, which must be a valid javascript function name\");\n",
        "        }\n",
        "    }\n",
        "\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-79"
    ],
    "cve_description": "An XSS vulnerability exists in the Jolokia agent version 1.3.7 in the HTTP servlet that allows an attacker to execute malicious javascript in the victim's browser.",
    "id": 11979
  },
  {
    "cve_id": "CVE-2021-25929",
    "code_before_change": "/*******************************************************************************\n * This file is part of OpenNMS(R).\n *\n * Copyright (C) 2011-2014 The OpenNMS Group, Inc.\n * OpenNMS(R) is Copyright (C) 1999-2014 The OpenNMS Group, Inc.\n *\n * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n *\n * OpenNMS(R) is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published\n * by the Free Software Foundation, either version 3 of the License,\n * or (at your option) any later version.\n *\n * OpenNMS(R) is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with OpenNMS(R).  If not, see:\n *      http://www.gnu.org/licenses/\n *\n * For more information contact:\n *     OpenNMS(R) Licensing <license@opennms.org>\n *     http://www.opennms.org/\n *     http://www.opennms.com/\n *******************************************************************************/\n\npackage org.opennms.smoketest;\n\nimport static org.junit.Assert.assertEquals;\n\nimport org.junit.Before;\nimport org.junit.FixMethodOrder;\nimport org.junit.Test;\nimport org.junit.runners.MethodSorters;\nimport org.openqa.selenium.By;\n\n@FixMethodOrder(MethodSorters.NAME_ASCENDING)\npublic class NotificationsPageIT extends OpenNMSSeleniumIT {\n    @Before\n    public void setUp() throws Exception {\n        notificationsPage();\n    }\n\n    @Test\n    public void testAllTextIsPresent() throws Exception {\n        assertEquals(3, countElementsMatchingCss(\"div.card-header\"));\n        findElementByXpath(\"//span[text()='Notification queries']\");\n        findElementByXpath(\"//span[text()='Outstanding and Acknowledged Notices']\");\n        findElementByXpath(\"//span[text()='Notification Escalation']\");\n    }\n\n    @Test\n    public void testAllLinksArePresent() {\n        findElementByLink(\"Your outstanding notices\");\n        findElementByLink(\"All outstanding notices\");\n        findElementByLink(\"All acknowledged notices\");\n    }\n\n    @Test\n    public void testAllFormsArePresent() {\n        findElementByXpath(\"//button[@id='btn_search_by_notice' and @type='submit']\");\n        findElementByXpath(\"//button[@id='btn_search_by_user' and @type='submit']\");\n    }\n\n    @Test\n    public void testAllLinks() {\n        findElementByLink(\"Your outstanding notices\").click();\n        findElementByXpath(\"//span[@class='label label-default' and contains(text(), 'admin was notified')]\");\n        findElementByLink(\"[Remove all]\");\n        findElementByLink(\"Sent Time\");\n        findElementByXpath(\"//button[@type='button' and text()='Acknowledge Notices']\");\n\n        notificationsPage();\n        findElementByLink(\"All outstanding notices\").click();\n        findElementByXpath(\"//p//strong[text()='outstanding']\");\n        findElementByLink(\"[Show acknowledged]\");\n        findElementByLink(\"Respond Time\");\n        assertElementDoesNotHaveText(By.xpath(\"//span[@class='label label-default']\"), \"admin was notified [-]\");\n\n        notificationsPage();\n        findElementByLink(\"All acknowledged notices\").click();\n        findElementByXpath(\"//p//strong[text()='acknowledged']\");\n        findElementByLink(\"[Show outstanding]\");\n        findElementByLink(\"Respond Time\");\n        assertElementDoesNotHaveText(By.xpath(\"//span[@class='label label-default']\"), \"admin was notified [-]\");\n    }\n\n}\n",
    "code_after_change": "/*******************************************************************************\n * This file is part of OpenNMS(R).\n *\n * Copyright (C) 2011-2014 The OpenNMS Group, Inc.\n * OpenNMS(R) is Copyright (C) 1999-2014 The OpenNMS Group, Inc.\n *\n * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n *\n * OpenNMS(R) is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published\n * by the Free Software Foundation, either version 3 of the License,\n * or (at your option) any later version.\n *\n * OpenNMS(R) is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with OpenNMS(R).  If not, see:\n *      http://www.gnu.org/licenses/\n *\n * For more information contact:\n *     OpenNMS(R) Licensing <license@opennms.org>\n *     http://www.opennms.org/\n *     http://www.opennms.com/\n *******************************************************************************/\n\npackage org.opennms.smoketest;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.openqa.selenium.support.ui.ExpectedConditions.visibilityOfElementLocated;\n\nimport java.time.Duration;\nimport java.time.temporal.ChronoUnit;\n\nimport org.junit.Before;\nimport org.junit.FixMethodOrder;\nimport org.junit.Test;\nimport org.junit.runners.MethodSorters;\nimport org.openqa.selenium.Alert;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.support.ui.ExpectedConditions;\nimport org.openqa.selenium.support.ui.Select;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n@FixMethodOrder(MethodSorters.NAME_ASCENDING)\npublic class NotificationsPageIT extends OpenNMSSeleniumIT {\n    private static final Logger LOG = LoggerFactory.getLogger(NotificationsPageIT.class);\n\n    @Before\n    public void setUp() throws Exception {\n        notificationsPage();\n    }\n\n    @Test\n    public void testAllTextIsPresent() throws Exception {\n        assertEquals(3, countElementsMatchingCss(\"div.card-header\"));\n        findElementByXpath(\"//span[text()='Notification queries']\");\n        findElementByXpath(\"//span[text()='Outstanding and Acknowledged Notices']\");\n        findElementByXpath(\"//span[text()='Notification Escalation']\");\n    }\n\n    @Test\n    public void testAllLinksArePresent() {\n        findElementByLink(\"Your outstanding notices\");\n        findElementByLink(\"All outstanding notices\");\n        findElementByLink(\"All acknowledged notices\");\n    }\n\n    @Test\n    public void testAllFormsArePresent() {\n        findElementByXpath(\"//button[@id='btn_search_by_notice' and @type='submit']\");\n        findElementByXpath(\"//button[@id='btn_search_by_user' and @type='submit']\");\n    }\n\n    @Test\n    public void testAllLinks() {\n        findElementByLink(\"Your outstanding notices\").click();\n        findElementByXpath(\"//span[@class='label label-default' and contains(text(), 'admin was notified')]\");\n        findElementByLink(\"[Remove all]\");\n        findElementByLink(\"Sent Time\");\n        findElementByXpath(\"//button[@type='button' and text()='Acknowledge Notices']\");\n\n        notificationsPage();\n        findElementByLink(\"All outstanding notices\").click();\n        findElementByXpath(\"//p//strong[text()='outstanding']\");\n        findElementByLink(\"[Show acknowledged]\");\n        findElementByLink(\"Respond Time\");\n        assertElementDoesNotHaveText(By.xpath(\"//span[@class='label label-default']\"), \"admin was notified [-]\");\n\n        notificationsPage();\n        findElementByLink(\"All acknowledged notices\").click();\n        findElementByXpath(\"//p//strong[text()='acknowledged']\");\n        findElementByLink(\"[Show outstanding]\");\n        findElementByLink(\"Respond Time\");\n        assertElementDoesNotHaveText(By.xpath(\"//span[@class='label label-default']\"), \"admin was notified [-]\");\n    }\n}\n",
    "patch": "@@ -29,15 +29,26 @@\n package org.opennms.smoketest;\n \n import static org.junit.Assert.assertEquals;\n+import static org.openqa.selenium.support.ui.ExpectedConditions.visibilityOfElementLocated;\n+\n+import java.time.Duration;\n+import java.time.temporal.ChronoUnit;\n \n import org.junit.Before;\n import org.junit.FixMethodOrder;\n import org.junit.Test;\n import org.junit.runners.MethodSorters;\n+import org.openqa.selenium.Alert;\n import org.openqa.selenium.By;\n+import org.openqa.selenium.support.ui.ExpectedConditions;\n+import org.openqa.selenium.support.ui.Select;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n @FixMethodOrder(MethodSorters.NAME_ASCENDING)\n public class NotificationsPageIT extends OpenNMSSeleniumIT {\n+    private static final Logger LOG = LoggerFactory.getLogger(NotificationsPageIT.class);\n+\n     @Before\n     public void setUp() throws Exception {\n         notificationsPage();\n@@ -86,5 +97,4 @@ public void testAllLinks() {\n         findElementByLink(\"Respond Time\");\n         assertElementDoesNotHaveText(By.xpath(\"//span[@class='label label-default']\"), \"admin was notified [-]\");\n     }\n-\n }",
    "function_modified_lines": {
      "added": [
        "import static org.openqa.selenium.support.ui.ExpectedConditions.visibilityOfElementLocated;\n",
        "\n",
        "import java.time.Duration;\n",
        "import java.time.temporal.ChronoUnit;\n",
        "import org.openqa.selenium.Alert;\n",
        "import org.openqa.selenium.support.ui.ExpectedConditions;\n",
        "import org.openqa.selenium.support.ui.Select;\n",
        "import org.slf4j.Logger;\n",
        "import org.slf4j.LoggerFactory;\n",
        "    private static final Logger LOG = LoggerFactory.getLogger(NotificationsPageIT.class);\n",
        "\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-79"
    ],
    "cve_description": "In OpenNMS Horizon, versions opennms-1-0-stable through opennms-27.1.0-1; OpenNMS Meridian, versions meridian-foundation-2015.1.0-1 through meridian-foundation-2019.1.18-1; meridian-foundation-2020.1.0-1 through meridian-foundation-2020.1.6-1 are vulnerable to Stored Cross-Site Scripting since there is no validation on the input being sent to the `name` parameter in `noticeWizard` endpoint. Due to this flaw an authenticated attacker could inject arbitrary script and trick other admin users into downloading malicious files.",
    "id": 12042
  },
  {
    "cve_id": "CVE-2021-25932",
    "code_before_change": "{\n        try {\n            UserFactory.init();\n        } catch (Throwable e) {\n            throw new ServletException(\"AddNewUserServlet: Error initialising user factory.\" + e);\n        }\n        UserManager userFactory = UserFactory.getInstance();\n\n        String userID = request.getParameter(\"userID\");\n        String password = request.getParameter(\"pass1\");\n\n        boolean hasUser = false;\n        try {\n            hasUser = userFactory.hasUser(userID);\n        } catch (Throwable e) {\n            throw new ServletException(\"can't determine if user \" + userID + \" already exists in users.xml.\", e);\n        }\n\n        if (hasUser) {\n            RequestDispatcher dispatcher = this.getServletContext().getRequestDispatcher(\"/admin/userGroupView/users/newUser.jsp?action=redo\");\n            dispatcher.forward(request, response);\n        } else {\n            final Password pass = new Password();\n            pass.setEncryptedPassword(UserFactory.getInstance().encryptedPassword(password, true));\n            pass.setSalt(true);\n\n            final User newUser = new User();\n            newUser.setUserId(userID);\n            newUser.setPassword(pass);\n\n            final HttpSession userSession = request.getSession(false);\n            userSession.setAttribute(\"user.modifyUser.jsp\", newUser);\n\n            // forward the request for proper display\n            RequestDispatcher dispatcher = this.getServletContext().getRequestDispatcher(\"/admin/userGroupView/users/modifyUser.jsp\");\n            dispatcher.forward(request, response);\n        }\n    }",
    "code_after_change": "{\n        try {\n            UserFactory.init();\n        } catch (Throwable e) {\n            throw new ServletException(\"AddNewUserServlet: Error initialising user factory.\" + e);\n        }\n        UserManager userFactory = UserFactory.getInstance();\n\n        String userID = request.getParameter(\"userID\");\n\n        if (userID != null && userID.matches(\".*[&<>\\\"`']+.*\")) {\n            throw new ServletException(\"User ID must not contain any HTML markup.\");\n        }\n\n        String password = request.getParameter(\"pass1\");\n\n        boolean hasUser = false;\n        try {\n            hasUser = userFactory.hasUser(userID);\n        } catch (Throwable e) {\n            throw new ServletException(\"can't determine if user \" + userID + \" already exists in users.xml.\", e);\n        }\n\n        if (hasUser) {\n            RequestDispatcher dispatcher = this.getServletContext().getRequestDispatcher(\"/admin/userGroupView/users/newUser.jsp?action=redo\");\n            dispatcher.forward(request, response);\n        } else {\n            final Password pass = new Password();\n            pass.setEncryptedPassword(UserFactory.getInstance().encryptedPassword(password, true));\n            pass.setSalt(true);\n\n            final User newUser = new User();\n            newUser.setUserId(userID);\n            newUser.setPassword(pass);\n\n            final HttpSession userSession = request.getSession(false);\n            userSession.setAttribute(\"user.modifyUser.jsp\", newUser);\n\n            // forward the request for proper display\n            RequestDispatcher dispatcher = this.getServletContext().getRequestDispatcher(\"/admin/userGroupView/users/modifyUser.jsp\");\n            dispatcher.forward(request, response);\n        }\n    }",
    "patch": "@@ -69,6 +69,11 @@ public void doPost(HttpServletRequest request, HttpServletResponse response) thr\n         UserManager userFactory = UserFactory.getInstance();\n \n         String userID = request.getParameter(\"userID\");\n+\n+        if (userID != null && userID.matches(\".*[&<>\\\"`']+.*\")) {\n+            throw new ServletException(\"User ID must not contain any HTML markup.\");\n+        }\n+\n         String password = request.getParameter(\"pass1\");\n \n         boolean hasUser = false;",
    "function_modified_lines": {
      "added": [
        "\n",
        "        if (userID != null && userID.matches(\".*[&<>\\\"`']+.*\")) {\n",
        "            throw new ServletException(\"User ID must not contain any HTML markup.\");\n",
        "        }\n",
        "\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-79"
    ],
    "cve_description": "In OpenNMS Horizon, versions opennms-1-0-stable through opennms-27.1.0-1; OpenNMS Meridian, versions meridian-foundation-2015.1.0-1 through meridian-foundation-2019.1.18-1; meridian-foundation-2020.1.0-1 through meridian-foundation-2020.1.6-1 are vulnerable to Stored Cross-Site Scripting, since the function `validateFormInput()` performs improper validation checks on the input sent to the `userID` parameter. Due to this flaw an attacker could inject an arbitrary script which will be stored in the database.",
    "id": 12043
  },
  {
    "cve_id": "CVE-2021-25932",
    "code_before_change": "{\n        String userID = request.getParameter(\"userID\");\n        String newID = request.getParameter(\"newID\");\n\n        // now save to the xml file\n        try {\n            UserManager userFactory = UserFactory.getInstance();\n            userFactory.renameUser(userID, newID);\n        } catch (Throwable e) {\n            throw new ServletException(\"Error renaming user \" + userID + \" to \" + newID, e);\n        }\n\n        response.sendRedirect(\"list.jsp\");\n    }",
    "code_after_change": "{\n        String userID = request.getParameter(\"userID\");\n        String newID = request.getParameter(\"newID\");\n\n        if (newID != null && newID.matches(\".*[&<>\\\"`']+.*\")) {\n            throw new ServletException(\"User ID must not contain any HTML markup.\");\n        }\n\n        // now save to the xml file\n        try {\n            UserManager userFactory = UserFactory.getInstance();\n            userFactory.renameUser(userID, newID);\n        } catch (Throwable e) {\n            throw new ServletException(\"Error renaming user \" + userID + \" to \" + newID, e);\n        }\n\n        response.sendRedirect(\"list.jsp\");\n    }",
    "patch": "@@ -60,6 +60,10 @@ public void doPost(HttpServletRequest request, HttpServletResponse response) thr\n         String userID = request.getParameter(\"userID\");\n         String newID = request.getParameter(\"newID\");\n \n+        if (newID != null && newID.matches(\".*[&<>\\\"`']+.*\")) {\n+            throw new ServletException(\"User ID must not contain any HTML markup.\");\n+        }\n+\n         // now save to the xml file\n         try {\n             UserManager userFactory = UserFactory.getInstance();",
    "function_modified_lines": {
      "added": [
        "        if (newID != null && newID.matches(\".*[&<>\\\"`']+.*\")) {\n",
        "            throw new ServletException(\"User ID must not contain any HTML markup.\");\n",
        "        }\n",
        "\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-79"
    ],
    "cve_description": "In OpenNMS Horizon, versions opennms-1-0-stable through opennms-27.1.0-1; OpenNMS Meridian, versions meridian-foundation-2015.1.0-1 through meridian-foundation-2019.1.18-1; meridian-foundation-2020.1.0-1 through meridian-foundation-2020.1.6-1 are vulnerable to Stored Cross-Site Scripting, since the function `validateFormInput()` performs improper validation checks on the input sent to the `userID` parameter. Due to this flaw an attacker could inject an arbitrary script which will be stored in the database.",
    "id": 12044
  },
  {
    "cve_id": "CVE-2021-25932",
    "code_before_change": "{    \n                \n        String groupName = request.getParameter(\"groupName\");\n        String groupComment = request.getParameter(\"groupComment\");\n        if (groupComment == null) {\n            groupComment = \"\";\n        }\n\n        boolean hasGroup = false;\n        try {\n            hasGroup = m_groupRepository.groupExists(groupName);\n        } catch (Throwable e) {\n            throw new ServletException(\"Can't determine if group \" + groupName + \" already exists in groups.xml.\", e);\n        }\n        \n        if (hasGroup) {\n            return new ModelAndView(\"admin/userGroupView/groups/newGroup\", \"action\", \"redo\");            \n        } else {\n            WebGroup newGroup = new WebGroup();\n            newGroup.setName(groupName);\n            newGroup.setComments(groupComment);\n            \n            return editGroup(request, newGroup);\n        }\n    }",
    "code_after_change": "{    \n                \n        String groupName = request.getParameter(\"groupName\");\n        String groupComment = request.getParameter(\"groupComment\");\n        if (groupComment == null) {\n            groupComment = \"\";\n        }\n\n        if (groupName != null && groupName.matches(\".*[&<>\\\"`']+.*\")) {\n            throw new ServletException(\"Group ID must not contain any HTML markup.\");\n        }\n\n        if (groupComment != null && groupComment.matches(\".*[&<>\\\"`']+.*\")) {\n            throw new ServletException(\"Group comment must not contain any HTML markup.\");\n        }\n\n        boolean hasGroup = false;\n        try {\n            hasGroup = m_groupRepository.groupExists(groupName);\n        } catch (Throwable e) {\n            throw new ServletException(\"Can't determine if group \" + groupName + \" already exists in groups.xml.\", e);\n        }\n        \n        if (hasGroup) {\n            return new ModelAndView(\"admin/userGroupView/groups/newGroup\", \"action\", \"redo\");            \n        } else {\n            WebGroup newGroup = new WebGroup();\n            newGroup.setName(groupName);\n            newGroup.setComments(groupComment);\n            \n            return editGroup(request, newGroup);\n        }\n    }",
    "patch": "@@ -151,7 +151,11 @@ private ModelAndView renameGroup(HttpServletRequest request, HttpServletResponse\n         \n         String oldName = request.getParameter(\"groupName\");\n         String newName = request.getParameter(\"newName\");\n-        \n+\n+        if (newName != null && newName.matches(\".*[&<>\\\"`']+.*\")) {\n+            throw new ServletException(\"Group ID must not contain any HTML markup.\");\n+        }\n+\n         if (StringUtils.hasText(oldName) && StringUtils.hasText(newName)) {\n             m_groupRepository.renameGroup(oldName, newName);\n         }\n@@ -312,6 +316,14 @@ private ModelAndView addGroup(HttpServletRequest request, HttpServletResponse re\n             groupComment = \"\";\n         }\n \n+        if (groupName != null && groupName.matches(\".*[&<>\\\"`']+.*\")) {\n+            throw new ServletException(\"Group ID must not contain any HTML markup.\");\n+        }\n+\n+        if (groupComment != null && groupComment.matches(\".*[&<>\\\"`']+.*\")) {\n+            throw new ServletException(\"Group comment must not contain any HTML markup.\");\n+        }\n+\n         boolean hasGroup = false;\n         try {\n             hasGroup = m_groupRepository.groupExists(groupName);",
    "function_modified_lines": {
      "added": [
        "        if (groupName != null && groupName.matches(\".*[&<>\\\"`']+.*\")) {\n",
        "            throw new ServletException(\"Group ID must not contain any HTML markup.\");\n",
        "        }\n",
        "\n",
        "        if (groupComment != null && groupComment.matches(\".*[&<>\\\"`']+.*\")) {\n",
        "            throw new ServletException(\"Group comment must not contain any HTML markup.\");\n",
        "        }\n",
        "\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-79"
    ],
    "cve_description": "In OpenNMS Horizon, versions opennms-1-0-stable through opennms-27.1.0-1; OpenNMS Meridian, versions meridian-foundation-2015.1.0-1 through meridian-foundation-2019.1.18-1; meridian-foundation-2020.1.0-1 through meridian-foundation-2020.1.6-1 are vulnerable to Stored Cross-Site Scripting, since the function `validateFormInput()` performs improper validation checks on the input sent to the `userID` parameter. Due to this flaw an attacker could inject an arbitrary script which will be stored in the database.",
    "id": 12045
  },
  {
    "cve_id": "CVE-2021-25933",
    "code_before_change": "{\n        try {\n            UserFactory.init();\n        } catch (Throwable e) {\n            throw new ServletException(\"AddNewUserServlet: Error initialising user factory.\" + e);\n        }\n        UserManager userFactory = UserFactory.getInstance();\n\n        String userID = request.getParameter(\"userID\");\n        String password = request.getParameter(\"pass1\");\n\n        boolean hasUser = false;\n        try {\n            hasUser = userFactory.hasUser(userID);\n        } catch (Throwable e) {\n            throw new ServletException(\"can't determine if user \" + userID + \" already exists in users.xml.\", e);\n        }\n\n        if (hasUser) {\n            RequestDispatcher dispatcher = this.getServletContext().getRequestDispatcher(\"/admin/userGroupView/users/newUser.jsp?action=redo\");\n            dispatcher.forward(request, response);\n        } else {\n            final Password pass = new Password();\n            pass.setEncryptedPassword(UserFactory.getInstance().encryptedPassword(password, true));\n            pass.setSalt(true);\n\n            final User newUser = new User();\n            newUser.setUserId(userID);\n            newUser.setPassword(pass);\n\n            final HttpSession userSession = request.getSession(false);\n            userSession.setAttribute(\"user.modifyUser.jsp\", newUser);\n\n            // forward the request for proper display\n            RequestDispatcher dispatcher = this.getServletContext().getRequestDispatcher(\"/admin/userGroupView/users/modifyUser.jsp\");\n            dispatcher.forward(request, response);\n        }\n    }",
    "code_after_change": "{\n        try {\n            UserFactory.init();\n        } catch (Throwable e) {\n            throw new ServletException(\"AddNewUserServlet: Error initialising user factory.\" + e);\n        }\n        UserManager userFactory = UserFactory.getInstance();\n\n        String userID = request.getParameter(\"userID\");\n\n        if (userID != null && userID.matches(\".*[&<>\\\"`']+.*\")) {\n            throw new ServletException(\"User ID must not contain any HTML markup.\");\n        }\n\n        String password = request.getParameter(\"pass1\");\n\n        boolean hasUser = false;\n        try {\n            hasUser = userFactory.hasUser(userID);\n        } catch (Throwable e) {\n            throw new ServletException(\"can't determine if user \" + userID + \" already exists in users.xml.\", e);\n        }\n\n        if (hasUser) {\n            RequestDispatcher dispatcher = this.getServletContext().getRequestDispatcher(\"/admin/userGroupView/users/newUser.jsp?action=redo\");\n            dispatcher.forward(request, response);\n        } else {\n            final Password pass = new Password();\n            pass.setEncryptedPassword(UserFactory.getInstance().encryptedPassword(password, true));\n            pass.setSalt(true);\n\n            final User newUser = new User();\n            newUser.setUserId(userID);\n            newUser.setPassword(pass);\n\n            final HttpSession userSession = request.getSession(false);\n            userSession.setAttribute(\"user.modifyUser.jsp\", newUser);\n\n            // forward the request for proper display\n            RequestDispatcher dispatcher = this.getServletContext().getRequestDispatcher(\"/admin/userGroupView/users/modifyUser.jsp\");\n            dispatcher.forward(request, response);\n        }\n    }",
    "patch": "@@ -69,6 +69,11 @@ public void doPost(HttpServletRequest request, HttpServletResponse response) thr\n         UserManager userFactory = UserFactory.getInstance();\n \n         String userID = request.getParameter(\"userID\");\n+\n+        if (userID != null && userID.matches(\".*[&<>\\\"`']+.*\")) {\n+            throw new ServletException(\"User ID must not contain any HTML markup.\");\n+        }\n+\n         String password = request.getParameter(\"pass1\");\n \n         boolean hasUser = false;",
    "function_modified_lines": {
      "added": [
        "\n",
        "        if (userID != null && userID.matches(\".*[&<>\\\"`']+.*\")) {\n",
        "            throw new ServletException(\"User ID must not contain any HTML markup.\");\n",
        "        }\n",
        "\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-79"
    ],
    "cve_description": "In OpenNMS Horizon, versions opennms-1-0-stable through opennms-27.1.0-1; OpenNMS Meridian, versions meridian-foundation-2015.1.0-1 through meridian-foundation-2019.1.18-1; meridian-foundation-2020.1.0-1 through meridian-foundation-2020.1.6-1 are vulnerable to Stored Cross-Site Scripting, since the function `validateFormInput()` performs improper validation checks on the input sent to the `groupName` and `groupComment` parameters. Due to this flaw, an authenticated attacker could inject arbitrary script and trick other admin users into downloading malicious files which can cause severe damage to the organization using opennms.",
    "id": 12046
  },
  {
    "cve_id": "CVE-2021-25933",
    "code_before_change": "{\n        String userID = request.getParameter(\"userID\");\n        String newID = request.getParameter(\"newID\");\n\n        // now save to the xml file\n        try {\n            UserManager userFactory = UserFactory.getInstance();\n            userFactory.renameUser(userID, newID);\n        } catch (Throwable e) {\n            throw new ServletException(\"Error renaming user \" + userID + \" to \" + newID, e);\n        }\n\n        response.sendRedirect(\"list.jsp\");\n    }",
    "code_after_change": "{\n        String userID = request.getParameter(\"userID\");\n        String newID = request.getParameter(\"newID\");\n\n        if (newID != null && newID.matches(\".*[&<>\\\"`']+.*\")) {\n            throw new ServletException(\"User ID must not contain any HTML markup.\");\n        }\n\n        // now save to the xml file\n        try {\n            UserManager userFactory = UserFactory.getInstance();\n            userFactory.renameUser(userID, newID);\n        } catch (Throwable e) {\n            throw new ServletException(\"Error renaming user \" + userID + \" to \" + newID, e);\n        }\n\n        response.sendRedirect(\"list.jsp\");\n    }",
    "patch": "@@ -60,6 +60,10 @@ public void doPost(HttpServletRequest request, HttpServletResponse response) thr\n         String userID = request.getParameter(\"userID\");\n         String newID = request.getParameter(\"newID\");\n \n+        if (newID != null && newID.matches(\".*[&<>\\\"`']+.*\")) {\n+            throw new ServletException(\"User ID must not contain any HTML markup.\");\n+        }\n+\n         // now save to the xml file\n         try {\n             UserManager userFactory = UserFactory.getInstance();",
    "function_modified_lines": {
      "added": [
        "        if (newID != null && newID.matches(\".*[&<>\\\"`']+.*\")) {\n",
        "            throw new ServletException(\"User ID must not contain any HTML markup.\");\n",
        "        }\n",
        "\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-79"
    ],
    "cve_description": "In OpenNMS Horizon, versions opennms-1-0-stable through opennms-27.1.0-1; OpenNMS Meridian, versions meridian-foundation-2015.1.0-1 through meridian-foundation-2019.1.18-1; meridian-foundation-2020.1.0-1 through meridian-foundation-2020.1.6-1 are vulnerable to Stored Cross-Site Scripting, since the function `validateFormInput()` performs improper validation checks on the input sent to the `groupName` and `groupComment` parameters. Due to this flaw, an authenticated attacker could inject arbitrary script and trick other admin users into downloading malicious files which can cause severe damage to the organization using opennms.",
    "id": 12047
  },
  {
    "cve_id": "CVE-2021-25933",
    "code_before_change": "{    \n                \n        String groupName = request.getParameter(\"groupName\");\n        String groupComment = request.getParameter(\"groupComment\");\n        if (groupComment == null) {\n            groupComment = \"\";\n        }\n\n        boolean hasGroup = false;\n        try {\n            hasGroup = m_groupRepository.groupExists(groupName);\n        } catch (Throwable e) {\n            throw new ServletException(\"Can't determine if group \" + groupName + \" already exists in groups.xml.\", e);\n        }\n        \n        if (hasGroup) {\n            return new ModelAndView(\"admin/userGroupView/groups/newGroup\", \"action\", \"redo\");            \n        } else {\n            WebGroup newGroup = new WebGroup();\n            newGroup.setName(groupName);\n            newGroup.setComments(groupComment);\n            \n            return editGroup(request, newGroup);\n        }\n    }",
    "code_after_change": "{    \n                \n        String groupName = request.getParameter(\"groupName\");\n        String groupComment = request.getParameter(\"groupComment\");\n        if (groupComment == null) {\n            groupComment = \"\";\n        }\n\n        if (groupName != null && groupName.matches(\".*[&<>\\\"`']+.*\")) {\n            throw new ServletException(\"Group ID must not contain any HTML markup.\");\n        }\n\n        if (groupComment != null && groupComment.matches(\".*[&<>\\\"`']+.*\")) {\n            throw new ServletException(\"Group comment must not contain any HTML markup.\");\n        }\n\n        boolean hasGroup = false;\n        try {\n            hasGroup = m_groupRepository.groupExists(groupName);\n        } catch (Throwable e) {\n            throw new ServletException(\"Can't determine if group \" + groupName + \" already exists in groups.xml.\", e);\n        }\n        \n        if (hasGroup) {\n            return new ModelAndView(\"admin/userGroupView/groups/newGroup\", \"action\", \"redo\");            \n        } else {\n            WebGroup newGroup = new WebGroup();\n            newGroup.setName(groupName);\n            newGroup.setComments(groupComment);\n            \n            return editGroup(request, newGroup);\n        }\n    }",
    "patch": "@@ -151,7 +151,11 @@ private ModelAndView renameGroup(HttpServletRequest request, HttpServletResponse\n         \n         String oldName = request.getParameter(\"groupName\");\n         String newName = request.getParameter(\"newName\");\n-        \n+\n+        if (newName != null && newName.matches(\".*[&<>\\\"`']+.*\")) {\n+            throw new ServletException(\"Group ID must not contain any HTML markup.\");\n+        }\n+\n         if (StringUtils.hasText(oldName) && StringUtils.hasText(newName)) {\n             m_groupRepository.renameGroup(oldName, newName);\n         }\n@@ -312,6 +316,14 @@ private ModelAndView addGroup(HttpServletRequest request, HttpServletResponse re\n             groupComment = \"\";\n         }\n \n+        if (groupName != null && groupName.matches(\".*[&<>\\\"`']+.*\")) {\n+            throw new ServletException(\"Group ID must not contain any HTML markup.\");\n+        }\n+\n+        if (groupComment != null && groupComment.matches(\".*[&<>\\\"`']+.*\")) {\n+            throw new ServletException(\"Group comment must not contain any HTML markup.\");\n+        }\n+\n         boolean hasGroup = false;\n         try {\n             hasGroup = m_groupRepository.groupExists(groupName);",
    "function_modified_lines": {
      "added": [
        "        if (groupName != null && groupName.matches(\".*[&<>\\\"`']+.*\")) {\n",
        "            throw new ServletException(\"Group ID must not contain any HTML markup.\");\n",
        "        }\n",
        "\n",
        "        if (groupComment != null && groupComment.matches(\".*[&<>\\\"`']+.*\")) {\n",
        "            throw new ServletException(\"Group comment must not contain any HTML markup.\");\n",
        "        }\n",
        "\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-79"
    ],
    "cve_description": "In OpenNMS Horizon, versions opennms-1-0-stable through opennms-27.1.0-1; OpenNMS Meridian, versions meridian-foundation-2015.1.0-1 through meridian-foundation-2019.1.18-1; meridian-foundation-2020.1.0-1 through meridian-foundation-2020.1.6-1 are vulnerable to Stored Cross-Site Scripting, since the function `validateFormInput()` performs improper validation checks on the input sent to the `groupName` and `groupComment` parameters. Due to this flaw, an authenticated attacker could inject arbitrary script and trick other admin users into downloading malicious files which can cause severe damage to the organization using opennms.",
    "id": 12048
  },
  {
    "cve_id": "CVE-2021-25929",
    "code_before_change": "{\n        try {\n            UserFactory.init();\n        } catch (Throwable e) {\n            throw new ServletException(\"AddNewUserServlet: Error initialising user factory.\" + e);\n        }\n        UserManager userFactory = UserFactory.getInstance();\n\n        String userID = request.getParameter(\"userID\");\n        String password = request.getParameter(\"pass1\");\n\n        boolean hasUser = false;\n        try {\n            hasUser = userFactory.hasUser(userID);\n        } catch (Throwable e) {\n            throw new ServletException(\"can't determine if user \" + userID + \" already exists in users.xml.\", e);\n        }\n\n        if (hasUser) {\n            RequestDispatcher dispatcher = this.getServletContext().getRequestDispatcher(\"/admin/userGroupView/users/newUser.jsp?action=redo\");\n            dispatcher.forward(request, response);\n        } else {\n            final Password pass = new Password();\n            pass.setEncryptedPassword(UserFactory.getInstance().encryptedPassword(password, true));\n            pass.setSalt(true);\n\n            final User newUser = new User();\n            newUser.setUserId(userID);\n            newUser.setPassword(pass);\n\n            final HttpSession userSession = request.getSession(false);\n            userSession.setAttribute(\"user.modifyUser.jsp\", newUser);\n\n            // forward the request for proper display\n            RequestDispatcher dispatcher = this.getServletContext().getRequestDispatcher(\"/admin/userGroupView/users/modifyUser.jsp\");\n            dispatcher.forward(request, response);\n        }\n    }",
    "code_after_change": "{\n        try {\n            UserFactory.init();\n        } catch (Throwable e) {\n            throw new ServletException(\"AddNewUserServlet: Error initialising user factory.\" + e);\n        }\n        UserManager userFactory = UserFactory.getInstance();\n\n        String userID = request.getParameter(\"userID\");\n\n        if (userID != null && userID.matches(\".*[&<>\\\"`']+.*\")) {\n            throw new ServletException(\"User ID must not contain any HTML markup.\");\n        }\n\n        String password = request.getParameter(\"pass1\");\n\n        boolean hasUser = false;\n        try {\n            hasUser = userFactory.hasUser(userID);\n        } catch (Throwable e) {\n            throw new ServletException(\"can't determine if user \" + userID + \" already exists in users.xml.\", e);\n        }\n\n        if (hasUser) {\n            RequestDispatcher dispatcher = this.getServletContext().getRequestDispatcher(\"/admin/userGroupView/users/newUser.jsp?action=redo\");\n            dispatcher.forward(request, response);\n        } else {\n            final Password pass = new Password();\n            pass.setEncryptedPassword(UserFactory.getInstance().encryptedPassword(password, true));\n            pass.setSalt(true);\n\n            final User newUser = new User();\n            newUser.setUserId(userID);\n            newUser.setPassword(pass);\n\n            final HttpSession userSession = request.getSession(false);\n            userSession.setAttribute(\"user.modifyUser.jsp\", newUser);\n\n            // forward the request for proper display\n            RequestDispatcher dispatcher = this.getServletContext().getRequestDispatcher(\"/admin/userGroupView/users/modifyUser.jsp\");\n            dispatcher.forward(request, response);\n        }\n    }",
    "patch": "@@ -69,6 +69,11 @@ public void doPost(HttpServletRequest request, HttpServletResponse response) thr\n         UserManager userFactory = UserFactory.getInstance();\n \n         String userID = request.getParameter(\"userID\");\n+\n+        if (userID != null && userID.matches(\".*[&<>\\\"`']+.*\")) {\n+            throw new ServletException(\"User ID must not contain any HTML markup.\");\n+        }\n+\n         String password = request.getParameter(\"pass1\");\n \n         boolean hasUser = false;",
    "function_modified_lines": {
      "added": [
        "\n",
        "        if (userID != null && userID.matches(\".*[&<>\\\"`']+.*\")) {\n",
        "            throw new ServletException(\"User ID must not contain any HTML markup.\");\n",
        "        }\n",
        "\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-79"
    ],
    "cve_description": "In OpenNMS Horizon, versions opennms-1-0-stable through opennms-27.1.0-1; OpenNMS Meridian, versions meridian-foundation-2015.1.0-1 through meridian-foundation-2019.1.18-1; meridian-foundation-2020.1.0-1 through meridian-foundation-2020.1.6-1 are vulnerable to Stored Cross-Site Scripting since there is no validation on the input being sent to the `name` parameter in `noticeWizard` endpoint. Due to this flaw an authenticated attacker could inject arbitrary script and trick other admin users into downloading malicious files.",
    "id": 12049
  },
  {
    "cve_id": "CVE-2021-25929",
    "code_before_change": "{\n        String userID = request.getParameter(\"userID\");\n        String newID = request.getParameter(\"newID\");\n\n        // now save to the xml file\n        try {\n            UserManager userFactory = UserFactory.getInstance();\n            userFactory.renameUser(userID, newID);\n        } catch (Throwable e) {\n            throw new ServletException(\"Error renaming user \" + userID + \" to \" + newID, e);\n        }\n\n        response.sendRedirect(\"list.jsp\");\n    }",
    "code_after_change": "{\n        String userID = request.getParameter(\"userID\");\n        String newID = request.getParameter(\"newID\");\n\n        if (newID != null && newID.matches(\".*[&<>\\\"`']+.*\")) {\n            throw new ServletException(\"User ID must not contain any HTML markup.\");\n        }\n\n        // now save to the xml file\n        try {\n            UserManager userFactory = UserFactory.getInstance();\n            userFactory.renameUser(userID, newID);\n        } catch (Throwable e) {\n            throw new ServletException(\"Error renaming user \" + userID + \" to \" + newID, e);\n        }\n\n        response.sendRedirect(\"list.jsp\");\n    }",
    "patch": "@@ -60,6 +60,10 @@ public void doPost(HttpServletRequest request, HttpServletResponse response) thr\n         String userID = request.getParameter(\"userID\");\n         String newID = request.getParameter(\"newID\");\n \n+        if (newID != null && newID.matches(\".*[&<>\\\"`']+.*\")) {\n+            throw new ServletException(\"User ID must not contain any HTML markup.\");\n+        }\n+\n         // now save to the xml file\n         try {\n             UserManager userFactory = UserFactory.getInstance();",
    "function_modified_lines": {
      "added": [
        "        if (newID != null && newID.matches(\".*[&<>\\\"`']+.*\")) {\n",
        "            throw new ServletException(\"User ID must not contain any HTML markup.\");\n",
        "        }\n",
        "\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-79"
    ],
    "cve_description": "In OpenNMS Horizon, versions opennms-1-0-stable through opennms-27.1.0-1; OpenNMS Meridian, versions meridian-foundation-2015.1.0-1 through meridian-foundation-2019.1.18-1; meridian-foundation-2020.1.0-1 through meridian-foundation-2020.1.6-1 are vulnerable to Stored Cross-Site Scripting since there is no validation on the input being sent to the `name` parameter in `noticeWizard` endpoint. Due to this flaw an authenticated attacker could inject arbitrary script and trick other admin users into downloading malicious files.",
    "id": 12050
  },
  {
    "cve_id": "CVE-2021-25929",
    "code_before_change": "{    \n                \n        String groupName = request.getParameter(\"groupName\");\n        String groupComment = request.getParameter(\"groupComment\");\n        if (groupComment == null) {\n            groupComment = \"\";\n        }\n\n        boolean hasGroup = false;\n        try {\n            hasGroup = m_groupRepository.groupExists(groupName);\n        } catch (Throwable e) {\n            throw new ServletException(\"Can't determine if group \" + groupName + \" already exists in groups.xml.\", e);\n        }\n        \n        if (hasGroup) {\n            return new ModelAndView(\"admin/userGroupView/groups/newGroup\", \"action\", \"redo\");            \n        } else {\n            WebGroup newGroup = new WebGroup();\n            newGroup.setName(groupName);\n            newGroup.setComments(groupComment);\n            \n            return editGroup(request, newGroup);\n        }\n    }",
    "code_after_change": "{    \n                \n        String groupName = request.getParameter(\"groupName\");\n        String groupComment = request.getParameter(\"groupComment\");\n        if (groupComment == null) {\n            groupComment = \"\";\n        }\n\n        if (groupName != null && groupName.matches(\".*[&<>\\\"`']+.*\")) {\n            throw new ServletException(\"Group ID must not contain any HTML markup.\");\n        }\n\n        if (groupComment != null && groupComment.matches(\".*[&<>\\\"`']+.*\")) {\n            throw new ServletException(\"Group comment must not contain any HTML markup.\");\n        }\n\n        boolean hasGroup = false;\n        try {\n            hasGroup = m_groupRepository.groupExists(groupName);\n        } catch (Throwable e) {\n            throw new ServletException(\"Can't determine if group \" + groupName + \" already exists in groups.xml.\", e);\n        }\n        \n        if (hasGroup) {\n            return new ModelAndView(\"admin/userGroupView/groups/newGroup\", \"action\", \"redo\");            \n        } else {\n            WebGroup newGroup = new WebGroup();\n            newGroup.setName(groupName);\n            newGroup.setComments(groupComment);\n            \n            return editGroup(request, newGroup);\n        }\n    }",
    "patch": "@@ -151,7 +151,11 @@ private ModelAndView renameGroup(HttpServletRequest request, HttpServletResponse\n         \n         String oldName = request.getParameter(\"groupName\");\n         String newName = request.getParameter(\"newName\");\n-        \n+\n+        if (newName != null && newName.matches(\".*[&<>\\\"`']+.*\")) {\n+            throw new ServletException(\"Group ID must not contain any HTML markup.\");\n+        }\n+\n         if (StringUtils.hasText(oldName) && StringUtils.hasText(newName)) {\n             m_groupRepository.renameGroup(oldName, newName);\n         }\n@@ -312,6 +316,14 @@ private ModelAndView addGroup(HttpServletRequest request, HttpServletResponse re\n             groupComment = \"\";\n         }\n \n+        if (groupName != null && groupName.matches(\".*[&<>\\\"`']+.*\")) {\n+            throw new ServletException(\"Group ID must not contain any HTML markup.\");\n+        }\n+\n+        if (groupComment != null && groupComment.matches(\".*[&<>\\\"`']+.*\")) {\n+            throw new ServletException(\"Group comment must not contain any HTML markup.\");\n+        }\n+\n         boolean hasGroup = false;\n         try {\n             hasGroup = m_groupRepository.groupExists(groupName);",
    "function_modified_lines": {
      "added": [
        "        if (groupName != null && groupName.matches(\".*[&<>\\\"`']+.*\")) {\n",
        "            throw new ServletException(\"Group ID must not contain any HTML markup.\");\n",
        "        }\n",
        "\n",
        "        if (groupComment != null && groupComment.matches(\".*[&<>\\\"`']+.*\")) {\n",
        "            throw new ServletException(\"Group comment must not contain any HTML markup.\");\n",
        "        }\n",
        "\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-79"
    ],
    "cve_description": "In OpenNMS Horizon, versions opennms-1-0-stable through opennms-27.1.0-1; OpenNMS Meridian, versions meridian-foundation-2015.1.0-1 through meridian-foundation-2019.1.18-1; meridian-foundation-2020.1.0-1 through meridian-foundation-2020.1.6-1 are vulnerable to Stored Cross-Site Scripting since there is no validation on the input being sent to the `name` parameter in `noticeWizard` endpoint. Due to this flaw an authenticated attacker could inject arbitrary script and trick other admin users into downloading malicious files.",
    "id": 12051
  },
  {
    "cve_id": "CVE-2021-25929",
    "code_before_change": "/*******************************************************************************\n * This file is part of OpenNMS(R).\n *\n * Copyright (C) 2011-2014 The OpenNMS Group, Inc.\n * OpenNMS(R) is Copyright (C) 1999-2014 The OpenNMS Group, Inc.\n *\n * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n *\n * OpenNMS(R) is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published\n * by the Free Software Foundation, either version 3 of the License,\n * or (at your option) any later version.\n *\n * OpenNMS(R) is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with OpenNMS(R).  If not, see:\n *      http://www.gnu.org/licenses/\n *\n * For more information contact:\n *     OpenNMS(R) Licensing <license@opennms.org>\n *     http://www.opennms.org/\n *     http://www.opennms.com/\n *******************************************************************************/\n\npackage org.opennms.smoketest;\n\nimport static org.junit.Assert.assertEquals;\n\nimport java.util.List;\n\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.openqa.selenium.Alert;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebElement;\nimport org.openqa.selenium.support.ui.ExpectedConditions;\nimport org.openqa.selenium.support.ui.Select;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class UserIT extends OpenNMSSeleniumIT {\n    private static final Logger LOG = LoggerFactory.getLogger(UserIT.class);\n\n    @Before\n    public void setUp() throws Exception {\n        driver.get(getBaseUrlInternal() + \"opennms/account/selfService/index.jsp\");\n    }\n\n    @Test\n    public void testExpectedTextAndLinksArePresent() throws Exception {\n        final List<WebElement> headers = driver.findElements(By.xpath(\"//div[@class='card-header']/span\"));\n        assertEquals(\"Account page should have 2 panels\", 2, headers.size());\n        assertEquals(\"Account page should have \\\"User Account Self-Service\\\" panel\", \"User Account Self-Service\", headers.get(0).getText());\n        assertEquals(\"Account page should have \\\"User Account Self-Service Options\\\" panel\", \"Account Self-Service Options\", headers.get(1).getText());\n    }\n\n    @Test\n    public void testSubmitWithWrongPassword() throws InterruptedException {\n        driver.findElement(By.linkText(\"Change Password\")).click();\n        enterText(By.cssSelector(\"input[type=password][name=oldpass]\"), \"12345\");\n        enterText(By.cssSelector(\"input[type=password][name=pass1]\"), \"23456\");\n        enterText(By.cssSelector(\"input[type=password][name=pass2]\"), \"34567\");\n        driver.findElement(By.cssSelector(\"button[type=submit]\")).click();\n\n        try {\n            final Alert alert = wait.until(ExpectedConditions.alertIsPresent());\n            alert.dismiss();\n        } catch (final Exception e) {\n            LOG.debug(\"Got an exception waiting for a 'wrong password' alert.\", e);\n            throw e;\n        }\n    }\n\n    @Test\n    public void testUsersAndGroups() throws Exception {\n        adminPage();\n        findElementByLink(\"Configure Users, Groups and On-Call Roles\").click();\n        findElementByLink(\"Configure Users\").click();\n        findElementByLink(\"Add new user\").click();\n\n        enterText(By.id(\"userID\"), USER_NAME);\n        enterText(By.id(\"pass1\"), \"SmokeTestPassword\");\n        enterText(By.id(\"pass2\"), \"SmokeTestPassword\");\n        findElementByXpath(\"//button[@type='submit' and text()='OK']\").click();\n\n        findElementById(\"saveUserButton\").click();\n        findElementById(\"users(\" + USER_NAME + \").doDetails\");\n\n        adminPage();\n        findElementByLink(\"Configure Users, Groups and On-Call Roles\").click();\n        findElementByLink(\"Configure Groups\").click();\n        findElementByLink(\"Add new group\").click();\n\n        enterText(By.id(\"groupName\"), GROUP_NAME);\n        enterText(By.id(\"groupComment\"), \"Test\");\n        findElementByXpath(\"//button[@type='submit' and text()='OK']\").click();\n\n        final Select select = new Select(findElementByName(\"availableUsers\"));\n        select.selectByVisibleText(USER_NAME);\n        findElementById(\"users.doAdd\").click();\n\n        findElementByName(\"finish\").click();\n\n        findElementByLink(GROUP_NAME).click();\n        driver.findElement(By.xpath(\"//div[@class='card-header']/span[text()='Details for Group: \" + GROUP_NAME + \"']\"));\n\n        findElementByLink(\"Group List\").click();\n        findElementById(GROUP_NAME + \".doDelete\").click();\n        handleAlert(\"Are you sure you want to delete the group \" + GROUP_NAME + \"?\");\n        assertElementDoesNotExist(By.id(GROUP_NAME));\n\n        findElementByLink(\"Users and Groups\").click();\n        findElementByLink(\"Configure Users\").click();\n        findElementById(\"user-\" + USER_NAME);\n        findElementById(\"users(\" + USER_NAME + \").doDelete\").click();\n        handleAlert(\"Are you sure you want to delete the user \" + USER_NAME + \"?\");\n        assertElementDoesNotExist(By.id(USER_NAME));\n    }\n\n}\n",
    "code_after_change": "/*******************************************************************************\n * This file is part of OpenNMS(R).\n *\n * Copyright (C) 2011-2014 The OpenNMS Group, Inc.\n * OpenNMS(R) is Copyright (C) 1999-2014 The OpenNMS Group, Inc.\n *\n * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n *\n * OpenNMS(R) is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published\n * by the Free Software Foundation, either version 3 of the License,\n * or (at your option) any later version.\n *\n * OpenNMS(R) is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with OpenNMS(R).  If not, see:\n *      http://www.gnu.org/licenses/\n *\n * For more information contact:\n *     OpenNMS(R) Licensing <license@opennms.org>\n *     http://www.opennms.org/\n *     http://www.opennms.com/\n *******************************************************************************/\n\npackage org.opennms.smoketest;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n\nimport java.time.Duration;\nimport java.time.temporal.ChronoUnit;\nimport java.util.List;\n\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.openqa.selenium.Alert;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebElement;\nimport org.openqa.selenium.support.ui.ExpectedConditions;\nimport org.openqa.selenium.support.ui.Select;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class UserIT extends OpenNMSSeleniumIT {\n    private static final Logger LOG = LoggerFactory.getLogger(UserIT.class);\n\n    @Before\n    public void setUp() throws Exception {\n        driver.get(getBaseUrlInternal() + \"opennms/account/selfService/index.jsp\");\n    }\n\n    @Test\n    public void testExpectedTextAndLinksArePresent() throws Exception {\n        final List<WebElement> headers = driver.findElements(By.xpath(\"//div[@class='card-header']/span\"));\n        assertEquals(\"Account page should have 2 panels\", 2, headers.size());\n        assertEquals(\"Account page should have \\\"User Account Self-Service\\\" panel\", \"User Account Self-Service\", headers.get(0).getText());\n        assertEquals(\"Account page should have \\\"User Account Self-Service Options\\\" panel\", \"Account Self-Service Options\", headers.get(1).getText());\n    }\n\n    @Test\n    public void testSubmitWithWrongPassword() throws InterruptedException {\n        driver.findElement(By.linkText(\"Change Password\")).click();\n        enterText(By.cssSelector(\"input[type=password][name=oldpass]\"), \"12345\");\n        enterText(By.cssSelector(\"input[type=password][name=pass1]\"), \"23456\");\n        enterText(By.cssSelector(\"input[type=password][name=pass2]\"), \"34567\");\n        driver.findElement(By.cssSelector(\"button[type=submit]\")).click();\n\n        try {\n            final Alert alert = wait.until(ExpectedConditions.alertIsPresent());\n            alert.dismiss();\n        } catch (final Exception e) {\n            LOG.debug(\"Got an exception waiting for a 'wrong password' alert.\", e);\n            throw e;\n        }\n    }\n\n    @Test\n    public void testUsersAndGroups() throws Exception {\n        adminPage();\n        findElementByLink(\"Configure Users, Groups and On-Call Roles\").click();\n        findElementByLink(\"Configure Users\").click();\n        findElementByLink(\"Add new user\").click();\n\n        enterText(By.id(\"userID\"), USER_NAME);\n        enterText(By.id(\"pass1\"), \"SmokeTestPassword\");\n        enterText(By.id(\"pass2\"), \"SmokeTestPassword\");\n        findElementByXpath(\"//button[@type='submit' and text()='OK']\").click();\n\n        findElementById(\"saveUserButton\").click();\n        findElementById(\"users(\" + USER_NAME + \").doDetails\");\n\n        adminPage();\n        findElementByLink(\"Configure Users, Groups and On-Call Roles\").click();\n        findElementByLink(\"Configure Groups\").click();\n        findElementByLink(\"Add new group\").click();\n\n        enterText(By.id(\"groupName\"), GROUP_NAME);\n        enterText(By.id(\"groupComment\"), \"Test\");\n        findElementByXpath(\"//button[@type='submit' and text()='OK']\").click();\n\n        final Select select = new Select(findElementByName(\"availableUsers\"));\n        select.selectByVisibleText(USER_NAME);\n        findElementById(\"users.doAdd\").click();\n\n        findElementByName(\"finish\").click();\n\n        findElementByLink(GROUP_NAME).click();\n        driver.findElement(By.xpath(\"//div[@class='card-header']/span[text()='Details for Group: \" + GROUP_NAME + \"']\"));\n\n        findElementByLink(\"Group List\").click();\n        findElementById(GROUP_NAME + \".doDelete\").click();\n        handleAlert(\"Are you sure you want to delete the group \" + GROUP_NAME + \"?\");\n        assertElementDoesNotExist(By.id(GROUP_NAME));\n\n        findElementByLink(\"Users and Groups\").click();\n        findElementByLink(\"Configure Users\").click();\n        findElementById(\"user-\" + USER_NAME);\n        findElementById(\"users(\" + USER_NAME + \").doDelete\").click();\n        handleAlert(\"Are you sure you want to delete the user \" + USER_NAME + \"?\");\n        assertElementDoesNotExist(By.id(USER_NAME));\n    }\n\n    @Test\n    public void testInvalidUserIds() {\n        testInvalidUserId(\"John<b>Doe</b>\",true);\n        testInvalidUserId(\"Jane'Doe'\",true);\n        testInvalidUserId(\"John&Doe\",true);\n        testInvalidUserId(\"Jane\\\"\\\"Doe\",true);\n    }\n\n    @Test\n    public void testValidUserIds() {\n        testInvalidUserId(\"John-Doe\",false);\n        testInvalidUserId(\"Jane/Doe\",false);\n        testInvalidUserId(\"John.Doe\",false);\n        testInvalidUserId(\"Jane#Doe\", false);\n        testInvalidUserId(\"John@D\u00f6e.com\", false);\n        testInvalidUserId(\"JohnDo\u00e9\", false);\n    }\n\n    @Test\n    public void testInvalidGroupIds() {\n        testInvalidGroupId(\"John<b>Doe</b>\",true);\n        testInvalidGroupId(\"Jane'Doe'\",true);\n        testInvalidGroupId(\"John&Doe\",true);\n        testInvalidGroupId(\"Jane\\\"\\\"Doe\",true);\n    }\n\n    @Test\n    public void testValidGroupIds() {\n        testInvalidGroupId(\"John-Doe\",false);\n        testInvalidGroupId(\"Jane/Doe\",false);\n        testInvalidGroupId(\"John.Doe\",false);\n        testInvalidGroupId(\"Jane#Doe\", false);\n        testInvalidGroupId(\"John@D\u00f6e.com\", false);\n        testInvalidGroupId(\"JohnDo\u00e9\", false);\n    }\n\n    public void testInvalidUserId(final String userId, final boolean mustFail) {\n        adminPage();\n        findElementByLink(\"Configure Users, Groups and On-Call Roles\").click();\n        findElementByLink(\"Configure Users\").click();\n        findElementByLink(\"Add new user\").click();\n\n        enterText(By.id(\"userID\"), userId);\n        enterText(By.id(\"pass1\"), \"SmokeTestPassword\");\n        enterText(By.id(\"pass2\"), \"SmokeTestPassword\");\n        findElementByXpath(\"//button[@type='submit' and text()='OK']\").click();\n\n        if (mustFail) {\n            try {\n                final Alert alert = wait.withTimeout(Duration.of(5, ChronoUnit.SECONDS)).until(ExpectedConditions.alertIsPresent());\n                alert.dismiss();\n            } catch (final Exception e) {\n                LOG.debug(\"Got an exception waiting for a 'invalid user ID' alert.\", e);\n                throw e;\n            }\n        } else {\n            wait.until(ExpectedConditions.elementToBeClickable(By.name(\"finish\")));\n        }\n    }\n\n    public void testInvalidGroupId(final String groupId, final boolean mustFail) {\n        adminPage();\n        findElementByLink(\"Configure Users, Groups and On-Call Roles\").click();\n        findElementByLink(\"Configure Groups\").click();\n        findElementByLink(\"Add new group\").click();\n\n        enterText(By.id(\"groupName\"), groupId);\n        enterText(By.id(\"groupComment\"), \"SmokeTestComment\");\n        findElementByXpath(\"//button[@type='submit' and text()='OK']\").click();\n\n        if (mustFail) {\n            try {\n                final Alert alert = wait.withTimeout(Duration.of(5, ChronoUnit.SECONDS)).until(ExpectedConditions.alertIsPresent());\n                alert.dismiss();\n            } catch (final Exception e) {\n                LOG.debug(\"Got an exception waiting for a 'invalid group ID' alert.\", e);\n                throw e;\n            }\n        } else {\n            wait.until(ExpectedConditions.elementToBeClickable(By.name(\"finish\")));\n        }\n    }\n}\n",
    "patch": "@@ -29,7 +29,10 @@\n package org.opennms.smoketest;\n \n import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n \n+import java.time.Duration;\n+import java.time.temporal.ChronoUnit;\n import java.util.List;\n \n import org.junit.Before;\n@@ -121,4 +124,86 @@ public void testUsersAndGroups() throws Exception {\n         assertElementDoesNotExist(By.id(USER_NAME));\n     }\n \n+    @Test\n+    public void testInvalidUserIds() {\n+        testInvalidUserId(\"John<b>Doe</b>\",true);\n+        testInvalidUserId(\"Jane'Doe'\",true);\n+        testInvalidUserId(\"John&Doe\",true);\n+        testInvalidUserId(\"Jane\\\"\\\"Doe\",true);\n+    }\n+\n+    @Test\n+    public void testValidUserIds() {\n+        testInvalidUserId(\"John-Doe\",false);\n+        testInvalidUserId(\"Jane/Doe\",false);\n+        testInvalidUserId(\"John.Doe\",false);\n+        testInvalidUserId(\"Jane#Doe\", false);\n+        testInvalidUserId(\"John@D\u00f6e.com\", false);\n+        testInvalidUserId(\"JohnDo\u00e9\", false);\n+    }\n+\n+    @Test\n+    public void testInvalidGroupIds() {\n+        testInvalidGroupId(\"John<b>Doe</b>\",true);\n+        testInvalidGroupId(\"Jane'Doe'\",true);\n+        testInvalidGroupId(\"John&Doe\",true);\n+        testInvalidGroupId(\"Jane\\\"\\\"Doe\",true);\n+    }\n+\n+    @Test\n+    public void testValidGroupIds() {\n+        testInvalidGroupId(\"John-Doe\",false);\n+        testInvalidGroupId(\"Jane/Doe\",false);\n+        testInvalidGroupId(\"John.Doe\",false);\n+        testInvalidGroupId(\"Jane#Doe\", false);\n+        testInvalidGroupId(\"John@D\u00f6e.com\", false);\n+        testInvalidGroupId(\"JohnDo\u00e9\", false);\n+    }\n+\n+    public void testInvalidUserId(final String userId, final boolean mustFail) {\n+        adminPage();\n+        findElementByLink(\"Configure Users, Groups and On-Call Roles\").click();\n+        findElementByLink(\"Configure Users\").click();\n+        findElementByLink(\"Add new user\").click();\n+\n+        enterText(By.id(\"userID\"), userId);\n+        enterText(By.id(\"pass1\"), \"SmokeTestPassword\");\n+        enterText(By.id(\"pass2\"), \"SmokeTestPassword\");\n+        findElementByXpath(\"//button[@type='submit' and text()='OK']\").click();\n+\n+        if (mustFail) {\n+            try {\n+                final Alert alert = wait.withTimeout(Duration.of(5, ChronoUnit.SECONDS)).until(ExpectedConditions.alertIsPresent());\n+                alert.dismiss();\n+            } catch (final Exception e) {\n+                LOG.debug(\"Got an exception waiting for a 'invalid user ID' alert.\", e);\n+                throw e;\n+            }\n+        } else {\n+            wait.until(ExpectedConditions.elementToBeClickable(By.name(\"finish\")));\n+        }\n+    }\n+\n+    public void testInvalidGroupId(final String groupId, final boolean mustFail) {\n+        adminPage();\n+        findElementByLink(\"Configure Users, Groups and On-Call Roles\").click();\n+        findElementByLink(\"Configure Groups\").click();\n+        findElementByLink(\"Add new group\").click();\n+\n+        enterText(By.id(\"groupName\"), groupId);\n+        enterText(By.id(\"groupComment\"), \"SmokeTestComment\");\n+        findElementByXpath(\"//button[@type='submit' and text()='OK']\").click();\n+\n+        if (mustFail) {\n+            try {\n+                final Alert alert = wait.withTimeout(Duration.of(5, ChronoUnit.SECONDS)).until(ExpectedConditions.alertIsPresent());\n+                alert.dismiss();\n+            } catch (final Exception e) {\n+                LOG.debug(\"Got an exception waiting for a 'invalid group ID' alert.\", e);\n+                throw e;\n+            }\n+        } else {\n+            wait.until(ExpectedConditions.elementToBeClickable(By.name(\"finish\")));\n+        }\n+    }\n }",
    "function_modified_lines": {
      "added": [
        "import static org.junit.Assert.assertTrue;\n",
        "import java.time.Duration;\n",
        "import java.time.temporal.ChronoUnit;\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-79"
    ],
    "cve_description": "In OpenNMS Horizon, versions opennms-1-0-stable through opennms-27.1.0-1; OpenNMS Meridian, versions meridian-foundation-2015.1.0-1 through meridian-foundation-2019.1.18-1; meridian-foundation-2020.1.0-1 through meridian-foundation-2020.1.6-1 are vulnerable to Stored Cross-Site Scripting since there is no validation on the input being sent to the `name` parameter in `noticeWizard` endpoint. Due to this flaw an authenticated attacker could inject arbitrary script and trick other admin users into downloading malicious files.",
    "id": 12052
  },
  {
    "cve_id": "CVE-2021-25932",
    "code_before_change": "{\n        try {\n            UserFactory.init();\n        } catch (Throwable e) {\n            throw new ServletException(\"AddNewUserServlet: Error initialising user factory.\" + e);\n        }\n        UserManager userFactory = UserFactory.getInstance();\n\n        String userID = request.getParameter(\"userID\");\n        String password = request.getParameter(\"pass1\");\n\n        boolean hasUser = false;\n        try {\n            hasUser = userFactory.hasUser(userID);\n        } catch (Throwable e) {\n            throw new ServletException(\"can't determine if user \" + userID + \" already exists in users.xml.\", e);\n        }\n\n        if (hasUser) {\n            RequestDispatcher dispatcher = this.getServletContext().getRequestDispatcher(\"/admin/userGroupView/users/newUser.jsp?action=redo\");\n            dispatcher.forward(request, response);\n        } else {\n            final Password pass = new Password();\n            pass.setEncryptedPassword(UserFactory.getInstance().encryptedPassword(password, true));\n            pass.setSalt(true);\n\n            final User newUser = new User();\n            newUser.setUserId(userID);\n            newUser.setPassword(pass);\n\n            final HttpSession userSession = request.getSession(false);\n            userSession.setAttribute(\"user.modifyUser.jsp\", newUser);\n\n            // forward the request for proper display\n            RequestDispatcher dispatcher = this.getServletContext().getRequestDispatcher(\"/admin/userGroupView/users/modifyUser.jsp\");\n            dispatcher.forward(request, response);\n        }\n    }",
    "code_after_change": "{\n        try {\n            UserFactory.init();\n        } catch (Throwable e) {\n            throw new ServletException(\"AddNewUserServlet: Error initialising user factory.\" + e);\n        }\n        UserManager userFactory = UserFactory.getInstance();\n\n        String userID = request.getParameter(\"userID\");\n\n        if (userID != null && userID.matches(\".*[&<>\\\"`']+.*\")) {\n            throw new ServletException(\"User ID must not contain any HTML markup.\");\n        }\n\n        String password = request.getParameter(\"pass1\");\n\n        boolean hasUser = false;\n        try {\n            hasUser = userFactory.hasUser(userID);\n        } catch (Throwable e) {\n            throw new ServletException(\"can't determine if user \" + userID + \" already exists in users.xml.\", e);\n        }\n\n        if (hasUser) {\n            RequestDispatcher dispatcher = this.getServletContext().getRequestDispatcher(\"/admin/userGroupView/users/newUser.jsp?action=redo\");\n            dispatcher.forward(request, response);\n        } else {\n            final Password pass = new Password();\n            pass.setEncryptedPassword(UserFactory.getInstance().encryptedPassword(password, true));\n            pass.setSalt(true);\n\n            final User newUser = new User();\n            newUser.setUserId(userID);\n            newUser.setPassword(pass);\n\n            final HttpSession userSession = request.getSession(false);\n            userSession.setAttribute(\"user.modifyUser.jsp\", newUser);\n\n            // forward the request for proper display\n            RequestDispatcher dispatcher = this.getServletContext().getRequestDispatcher(\"/admin/userGroupView/users/modifyUser.jsp\");\n            dispatcher.forward(request, response);\n        }\n    }",
    "patch": "@@ -69,6 +69,11 @@ public void doPost(HttpServletRequest request, HttpServletResponse response) thr\n         UserManager userFactory = UserFactory.getInstance();\n \n         String userID = request.getParameter(\"userID\");\n+\n+        if (userID != null && userID.matches(\".*[&<>\\\"`']+.*\")) {\n+            throw new ServletException(\"User ID must not contain any HTML markup.\");\n+        }\n+\n         String password = request.getParameter(\"pass1\");\n \n         boolean hasUser = false;",
    "function_modified_lines": {
      "added": [
        "\n",
        "        if (userID != null && userID.matches(\".*[&<>\\\"`']+.*\")) {\n",
        "            throw new ServletException(\"User ID must not contain any HTML markup.\");\n",
        "        }\n",
        "\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-79"
    ],
    "cve_description": "In OpenNMS Horizon, versions opennms-1-0-stable through opennms-27.1.0-1; OpenNMS Meridian, versions meridian-foundation-2015.1.0-1 through meridian-foundation-2019.1.18-1; meridian-foundation-2020.1.0-1 through meridian-foundation-2020.1.6-1 are vulnerable to Stored Cross-Site Scripting, since the function `validateFormInput()` performs improper validation checks on the input sent to the `userID` parameter. Due to this flaw an attacker could inject an arbitrary script which will be stored in the database.",
    "id": 12061
  },
  {
    "cve_id": "CVE-2021-25932",
    "code_before_change": "{\n        String userID = request.getParameter(\"userID\");\n        String newID = request.getParameter(\"newID\");\n\n        // now save to the xml file\n        try {\n            UserManager userFactory = UserFactory.getInstance();\n            userFactory.renameUser(userID, newID);\n        } catch (Throwable e) {\n            throw new ServletException(\"Error renaming user \" + userID + \" to \" + newID, e);\n        }\n\n        response.sendRedirect(\"list.jsp\");\n    }",
    "code_after_change": "{\n        String userID = request.getParameter(\"userID\");\n        String newID = request.getParameter(\"newID\");\n\n        if (newID != null && newID.matches(\".*[&<>\\\"`']+.*\")) {\n            throw new ServletException(\"User ID must not contain any HTML markup.\");\n        }\n\n        // now save to the xml file\n        try {\n            UserManager userFactory = UserFactory.getInstance();\n            userFactory.renameUser(userID, newID);\n        } catch (Throwable e) {\n            throw new ServletException(\"Error renaming user \" + userID + \" to \" + newID, e);\n        }\n\n        response.sendRedirect(\"list.jsp\");\n    }",
    "patch": "@@ -60,6 +60,10 @@ public void doPost(HttpServletRequest request, HttpServletResponse response) thr\n         String userID = request.getParameter(\"userID\");\n         String newID = request.getParameter(\"newID\");\n \n+        if (newID != null && newID.matches(\".*[&<>\\\"`']+.*\")) {\n+            throw new ServletException(\"User ID must not contain any HTML markup.\");\n+        }\n+\n         // now save to the xml file\n         try {\n             UserManager userFactory = UserFactory.getInstance();",
    "function_modified_lines": {
      "added": [
        "        if (newID != null && newID.matches(\".*[&<>\\\"`']+.*\")) {\n",
        "            throw new ServletException(\"User ID must not contain any HTML markup.\");\n",
        "        }\n",
        "\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-79"
    ],
    "cve_description": "In OpenNMS Horizon, versions opennms-1-0-stable through opennms-27.1.0-1; OpenNMS Meridian, versions meridian-foundation-2015.1.0-1 through meridian-foundation-2019.1.18-1; meridian-foundation-2020.1.0-1 through meridian-foundation-2020.1.6-1 are vulnerable to Stored Cross-Site Scripting, since the function `validateFormInput()` performs improper validation checks on the input sent to the `userID` parameter. Due to this flaw an attacker could inject an arbitrary script which will be stored in the database.",
    "id": 12062
  },
  {
    "cve_id": "CVE-2021-25932",
    "code_before_change": "{    \n                \n        String groupName = request.getParameter(\"groupName\");\n        String groupComment = request.getParameter(\"groupComment\");\n        if (groupComment == null) {\n            groupComment = \"\";\n        }\n\n        boolean hasGroup = false;\n        try {\n            hasGroup = m_groupRepository.groupExists(groupName);\n        } catch (Throwable e) {\n            throw new ServletException(\"Can't determine if group \" + groupName + \" already exists in groups.xml.\", e);\n        }\n        \n        if (hasGroup) {\n            return new ModelAndView(\"admin/userGroupView/groups/newGroup\", \"action\", \"redo\");            \n        } else {\n            WebGroup newGroup = new WebGroup();\n            newGroup.setName(groupName);\n            newGroup.setComments(groupComment);\n            \n            return editGroup(request, newGroup);\n        }\n    }",
    "code_after_change": "{    \n                \n        String groupName = request.getParameter(\"groupName\");\n        String groupComment = request.getParameter(\"groupComment\");\n        if (groupComment == null) {\n            groupComment = \"\";\n        }\n\n        if (groupName != null && groupName.matches(\".*[&<>\\\"`']+.*\")) {\n            throw new ServletException(\"Group ID must not contain any HTML markup.\");\n        }\n\n        if (groupComment != null && groupComment.matches(\".*[&<>\\\"`']+.*\")) {\n            throw new ServletException(\"Group comment must not contain any HTML markup.\");\n        }\n\n        boolean hasGroup = false;\n        try {\n            hasGroup = m_groupRepository.groupExists(groupName);\n        } catch (Throwable e) {\n            throw new ServletException(\"Can't determine if group \" + groupName + \" already exists in groups.xml.\", e);\n        }\n        \n        if (hasGroup) {\n            return new ModelAndView(\"admin/userGroupView/groups/newGroup\", \"action\", \"redo\");            \n        } else {\n            WebGroup newGroup = new WebGroup();\n            newGroup.setName(groupName);\n            newGroup.setComments(groupComment);\n            \n            return editGroup(request, newGroup);\n        }\n    }",
    "patch": "@@ -151,7 +151,11 @@ private ModelAndView renameGroup(HttpServletRequest request, HttpServletResponse\n         \n         String oldName = request.getParameter(\"groupName\");\n         String newName = request.getParameter(\"newName\");\n-        \n+\n+        if (newName != null && newName.matches(\".*[&<>\\\"`']+.*\")) {\n+            throw new ServletException(\"Group ID must not contain any HTML markup.\");\n+        }\n+\n         if (StringUtils.hasText(oldName) && StringUtils.hasText(newName)) {\n             m_groupRepository.renameGroup(oldName, newName);\n         }\n@@ -312,6 +316,14 @@ private ModelAndView addGroup(HttpServletRequest request, HttpServletResponse re\n             groupComment = \"\";\n         }\n \n+        if (groupName != null && groupName.matches(\".*[&<>\\\"`']+.*\")) {\n+            throw new ServletException(\"Group ID must not contain any HTML markup.\");\n+        }\n+\n+        if (groupComment != null && groupComment.matches(\".*[&<>\\\"`']+.*\")) {\n+            throw new ServletException(\"Group comment must not contain any HTML markup.\");\n+        }\n+\n         boolean hasGroup = false;\n         try {\n             hasGroup = m_groupRepository.groupExists(groupName);",
    "function_modified_lines": {
      "added": [
        "        if (groupName != null && groupName.matches(\".*[&<>\\\"`']+.*\")) {\n",
        "            throw new ServletException(\"Group ID must not contain any HTML markup.\");\n",
        "        }\n",
        "\n",
        "        if (groupComment != null && groupComment.matches(\".*[&<>\\\"`']+.*\")) {\n",
        "            throw new ServletException(\"Group comment must not contain any HTML markup.\");\n",
        "        }\n",
        "\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-79"
    ],
    "cve_description": "In OpenNMS Horizon, versions opennms-1-0-stable through opennms-27.1.0-1; OpenNMS Meridian, versions meridian-foundation-2015.1.0-1 through meridian-foundation-2019.1.18-1; meridian-foundation-2020.1.0-1 through meridian-foundation-2020.1.6-1 are vulnerable to Stored Cross-Site Scripting, since the function `validateFormInput()` performs improper validation checks on the input sent to the `userID` parameter. Due to this flaw an attacker could inject an arbitrary script which will be stored in the database.",
    "id": 12063
  },
  {
    "cve_id": "CVE-2021-25933",
    "code_before_change": "{\n        try {\n            UserFactory.init();\n        } catch (Throwable e) {\n            throw new ServletException(\"AddNewUserServlet: Error initialising user factory.\" + e);\n        }\n        UserManager userFactory = UserFactory.getInstance();\n\n        String userID = request.getParameter(\"userID\");\n        String password = request.getParameter(\"pass1\");\n\n        boolean hasUser = false;\n        try {\n            hasUser = userFactory.hasUser(userID);\n        } catch (Throwable e) {\n            throw new ServletException(\"can't determine if user \" + userID + \" already exists in users.xml.\", e);\n        }\n\n        if (hasUser) {\n            RequestDispatcher dispatcher = this.getServletContext().getRequestDispatcher(\"/admin/userGroupView/users/newUser.jsp?action=redo\");\n            dispatcher.forward(request, response);\n        } else {\n            final Password pass = new Password();\n            pass.setEncryptedPassword(UserFactory.getInstance().encryptedPassword(password, true));\n            pass.setSalt(true);\n\n            final User newUser = new User();\n            newUser.setUserId(userID);\n            newUser.setPassword(pass);\n\n            final HttpSession userSession = request.getSession(false);\n            userSession.setAttribute(\"user.modifyUser.jsp\", newUser);\n\n            // forward the request for proper display\n            RequestDispatcher dispatcher = this.getServletContext().getRequestDispatcher(\"/admin/userGroupView/users/modifyUser.jsp\");\n            dispatcher.forward(request, response);\n        }\n    }",
    "code_after_change": "{\n        try {\n            UserFactory.init();\n        } catch (Throwable e) {\n            throw new ServletException(\"AddNewUserServlet: Error initialising user factory.\" + e);\n        }\n        UserManager userFactory = UserFactory.getInstance();\n\n        String userID = request.getParameter(\"userID\");\n\n        if (userID != null && userID.matches(\".*[&<>\\\"`']+.*\")) {\n            throw new ServletException(\"User ID must not contain any HTML markup.\");\n        }\n\n        String password = request.getParameter(\"pass1\");\n\n        boolean hasUser = false;\n        try {\n            hasUser = userFactory.hasUser(userID);\n        } catch (Throwable e) {\n            throw new ServletException(\"can't determine if user \" + userID + \" already exists in users.xml.\", e);\n        }\n\n        if (hasUser) {\n            RequestDispatcher dispatcher = this.getServletContext().getRequestDispatcher(\"/admin/userGroupView/users/newUser.jsp?action=redo\");\n            dispatcher.forward(request, response);\n        } else {\n            final Password pass = new Password();\n            pass.setEncryptedPassword(UserFactory.getInstance().encryptedPassword(password, true));\n            pass.setSalt(true);\n\n            final User newUser = new User();\n            newUser.setUserId(userID);\n            newUser.setPassword(pass);\n\n            final HttpSession userSession = request.getSession(false);\n            userSession.setAttribute(\"user.modifyUser.jsp\", newUser);\n\n            // forward the request for proper display\n            RequestDispatcher dispatcher = this.getServletContext().getRequestDispatcher(\"/admin/userGroupView/users/modifyUser.jsp\");\n            dispatcher.forward(request, response);\n        }\n    }",
    "patch": "@@ -69,6 +69,11 @@ public void doPost(HttpServletRequest request, HttpServletResponse response) thr\n         UserManager userFactory = UserFactory.getInstance();\n \n         String userID = request.getParameter(\"userID\");\n+\n+        if (userID != null && userID.matches(\".*[&<>\\\"`']+.*\")) {\n+            throw new ServletException(\"User ID must not contain any HTML markup.\");\n+        }\n+\n         String password = request.getParameter(\"pass1\");\n \n         boolean hasUser = false;",
    "function_modified_lines": {
      "added": [
        "\n",
        "        if (userID != null && userID.matches(\".*[&<>\\\"`']+.*\")) {\n",
        "            throw new ServletException(\"User ID must not contain any HTML markup.\");\n",
        "        }\n",
        "\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-79"
    ],
    "cve_description": "In OpenNMS Horizon, versions opennms-1-0-stable through opennms-27.1.0-1; OpenNMS Meridian, versions meridian-foundation-2015.1.0-1 through meridian-foundation-2019.1.18-1; meridian-foundation-2020.1.0-1 through meridian-foundation-2020.1.6-1 are vulnerable to Stored Cross-Site Scripting, since the function `validateFormInput()` performs improper validation checks on the input sent to the `groupName` and `groupComment` parameters. Due to this flaw, an authenticated attacker could inject arbitrary script and trick other admin users into downloading malicious files which can cause severe damage to the organization using opennms.",
    "id": 12065
  },
  {
    "cve_id": "CVE-2021-25933",
    "code_before_change": "{\n        String userID = request.getParameter(\"userID\");\n        String newID = request.getParameter(\"newID\");\n\n        // now save to the xml file\n        try {\n            UserManager userFactory = UserFactory.getInstance();\n            userFactory.renameUser(userID, newID);\n        } catch (Throwable e) {\n            throw new ServletException(\"Error renaming user \" + userID + \" to \" + newID, e);\n        }\n\n        response.sendRedirect(\"list.jsp\");\n    }",
    "code_after_change": "{\n        String userID = request.getParameter(\"userID\");\n        String newID = request.getParameter(\"newID\");\n\n        if (newID != null && newID.matches(\".*[&<>\\\"`']+.*\")) {\n            throw new ServletException(\"User ID must not contain any HTML markup.\");\n        }\n\n        // now save to the xml file\n        try {\n            UserManager userFactory = UserFactory.getInstance();\n            userFactory.renameUser(userID, newID);\n        } catch (Throwable e) {\n            throw new ServletException(\"Error renaming user \" + userID + \" to \" + newID, e);\n        }\n\n        response.sendRedirect(\"list.jsp\");\n    }",
    "patch": "@@ -60,6 +60,10 @@ public void doPost(HttpServletRequest request, HttpServletResponse response) thr\n         String userID = request.getParameter(\"userID\");\n         String newID = request.getParameter(\"newID\");\n \n+        if (newID != null && newID.matches(\".*[&<>\\\"`']+.*\")) {\n+            throw new ServletException(\"User ID must not contain any HTML markup.\");\n+        }\n+\n         // now save to the xml file\n         try {\n             UserManager userFactory = UserFactory.getInstance();",
    "function_modified_lines": {
      "added": [
        "        if (newID != null && newID.matches(\".*[&<>\\\"`']+.*\")) {\n",
        "            throw new ServletException(\"User ID must not contain any HTML markup.\");\n",
        "        }\n",
        "\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-79"
    ],
    "cve_description": "In OpenNMS Horizon, versions opennms-1-0-stable through opennms-27.1.0-1; OpenNMS Meridian, versions meridian-foundation-2015.1.0-1 through meridian-foundation-2019.1.18-1; meridian-foundation-2020.1.0-1 through meridian-foundation-2020.1.6-1 are vulnerable to Stored Cross-Site Scripting, since the function `validateFormInput()` performs improper validation checks on the input sent to the `groupName` and `groupComment` parameters. Due to this flaw, an authenticated attacker could inject arbitrary script and trick other admin users into downloading malicious files which can cause severe damage to the organization using opennms.",
    "id": 12066
  },
  {
    "cve_id": "CVE-2021-25933",
    "code_before_change": "{    \n                \n        String groupName = request.getParameter(\"groupName\");\n        String groupComment = request.getParameter(\"groupComment\");\n        if (groupComment == null) {\n            groupComment = \"\";\n        }\n\n        boolean hasGroup = false;\n        try {\n            hasGroup = m_groupRepository.groupExists(groupName);\n        } catch (Throwable e) {\n            throw new ServletException(\"Can't determine if group \" + groupName + \" already exists in groups.xml.\", e);\n        }\n        \n        if (hasGroup) {\n            return new ModelAndView(\"admin/userGroupView/groups/newGroup\", \"action\", \"redo\");            \n        } else {\n            WebGroup newGroup = new WebGroup();\n            newGroup.setName(groupName);\n            newGroup.setComments(groupComment);\n            \n            return editGroup(request, newGroup);\n        }\n    }",
    "code_after_change": "{    \n                \n        String groupName = request.getParameter(\"groupName\");\n        String groupComment = request.getParameter(\"groupComment\");\n        if (groupComment == null) {\n            groupComment = \"\";\n        }\n\n        if (groupName != null && groupName.matches(\".*[&<>\\\"`']+.*\")) {\n            throw new ServletException(\"Group ID must not contain any HTML markup.\");\n        }\n\n        if (groupComment != null && groupComment.matches(\".*[&<>\\\"`']+.*\")) {\n            throw new ServletException(\"Group comment must not contain any HTML markup.\");\n        }\n\n        boolean hasGroup = false;\n        try {\n            hasGroup = m_groupRepository.groupExists(groupName);\n        } catch (Throwable e) {\n            throw new ServletException(\"Can't determine if group \" + groupName + \" already exists in groups.xml.\", e);\n        }\n        \n        if (hasGroup) {\n            return new ModelAndView(\"admin/userGroupView/groups/newGroup\", \"action\", \"redo\");            \n        } else {\n            WebGroup newGroup = new WebGroup();\n            newGroup.setName(groupName);\n            newGroup.setComments(groupComment);\n            \n            return editGroup(request, newGroup);\n        }\n    }",
    "patch": "@@ -151,7 +151,11 @@ private ModelAndView renameGroup(HttpServletRequest request, HttpServletResponse\n         \n         String oldName = request.getParameter(\"groupName\");\n         String newName = request.getParameter(\"newName\");\n-        \n+\n+        if (newName != null && newName.matches(\".*[&<>\\\"`']+.*\")) {\n+            throw new ServletException(\"Group ID must not contain any HTML markup.\");\n+        }\n+\n         if (StringUtils.hasText(oldName) && StringUtils.hasText(newName)) {\n             m_groupRepository.renameGroup(oldName, newName);\n         }\n@@ -312,6 +316,14 @@ private ModelAndView addGroup(HttpServletRequest request, HttpServletResponse re\n             groupComment = \"\";\n         }\n \n+        if (groupName != null && groupName.matches(\".*[&<>\\\"`']+.*\")) {\n+            throw new ServletException(\"Group ID must not contain any HTML markup.\");\n+        }\n+\n+        if (groupComment != null && groupComment.matches(\".*[&<>\\\"`']+.*\")) {\n+            throw new ServletException(\"Group comment must not contain any HTML markup.\");\n+        }\n+\n         boolean hasGroup = false;\n         try {\n             hasGroup = m_groupRepository.groupExists(groupName);",
    "function_modified_lines": {
      "added": [
        "        if (groupName != null && groupName.matches(\".*[&<>\\\"`']+.*\")) {\n",
        "            throw new ServletException(\"Group ID must not contain any HTML markup.\");\n",
        "        }\n",
        "\n",
        "        if (groupComment != null && groupComment.matches(\".*[&<>\\\"`']+.*\")) {\n",
        "            throw new ServletException(\"Group comment must not contain any HTML markup.\");\n",
        "        }\n",
        "\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-79"
    ],
    "cve_description": "In OpenNMS Horizon, versions opennms-1-0-stable through opennms-27.1.0-1; OpenNMS Meridian, versions meridian-foundation-2015.1.0-1 through meridian-foundation-2019.1.18-1; meridian-foundation-2020.1.0-1 through meridian-foundation-2020.1.6-1 are vulnerable to Stored Cross-Site Scripting, since the function `validateFormInput()` performs improper validation checks on the input sent to the `groupName` and `groupComment` parameters. Due to this flaw, an authenticated attacker could inject arbitrary script and trick other admin users into downloading malicious files which can cause severe damage to the organization using opennms.",
    "id": 12067
  },
  {
    "cve_id": "CVE-2021-25934",
    "code_before_change": "{\n        try {\n            UserFactory.init();\n        } catch (Throwable e) {\n            throw new ServletException(\"AddNewUserServlet: Error initialising user factory.\" + e);\n        }\n        UserManager userFactory = UserFactory.getInstance();\n\n        String userID = request.getParameter(\"userID\");\n        String password = request.getParameter(\"pass1\");\n\n        boolean hasUser = false;\n        try {\n            hasUser = userFactory.hasUser(userID);\n        } catch (Throwable e) {\n            throw new ServletException(\"can't determine if user \" + userID + \" already exists in users.xml.\", e);\n        }\n\n        if (hasUser) {\n            RequestDispatcher dispatcher = this.getServletContext().getRequestDispatcher(\"/admin/userGroupView/users/newUser.jsp?action=redo\");\n            dispatcher.forward(request, response);\n        } else {\n            final Password pass = new Password();\n            pass.setEncryptedPassword(UserFactory.getInstance().encryptedPassword(password, true));\n            pass.setSalt(true);\n\n            final User newUser = new User();\n            newUser.setUserId(userID);\n            newUser.setPassword(pass);\n\n            final HttpSession userSession = request.getSession(false);\n            userSession.setAttribute(\"user.modifyUser.jsp\", newUser);\n\n            // forward the request for proper display\n            RequestDispatcher dispatcher = this.getServletContext().getRequestDispatcher(\"/admin/userGroupView/users/modifyUser.jsp\");\n            dispatcher.forward(request, response);\n        }\n    }",
    "code_after_change": "{\n        try {\n            UserFactory.init();\n        } catch (Throwable e) {\n            throw new ServletException(\"AddNewUserServlet: Error initialising user factory.\" + e);\n        }\n        UserManager userFactory = UserFactory.getInstance();\n\n        String userID = request.getParameter(\"userID\");\n\n        if (userID != null && userID.matches(\".*[&<>\\\"`']+.*\")) {\n            throw new ServletException(\"User ID must not contain any HTML markup.\");\n        }\n\n        String password = request.getParameter(\"pass1\");\n\n        boolean hasUser = false;\n        try {\n            hasUser = userFactory.hasUser(userID);\n        } catch (Throwable e) {\n            throw new ServletException(\"can't determine if user \" + userID + \" already exists in users.xml.\", e);\n        }\n\n        if (hasUser) {\n            RequestDispatcher dispatcher = this.getServletContext().getRequestDispatcher(\"/admin/userGroupView/users/newUser.jsp?action=redo\");\n            dispatcher.forward(request, response);\n        } else {\n            final Password pass = new Password();\n            pass.setEncryptedPassword(UserFactory.getInstance().encryptedPassword(password, true));\n            pass.setSalt(true);\n\n            final User newUser = new User();\n            newUser.setUserId(userID);\n            newUser.setPassword(pass);\n\n            final HttpSession userSession = request.getSession(false);\n            userSession.setAttribute(\"user.modifyUser.jsp\", newUser);\n\n            // forward the request for proper display\n            RequestDispatcher dispatcher = this.getServletContext().getRequestDispatcher(\"/admin/userGroupView/users/modifyUser.jsp\");\n            dispatcher.forward(request, response);\n        }\n    }",
    "patch": "@@ -69,6 +69,11 @@ public void doPost(HttpServletRequest request, HttpServletResponse response) thr\n         UserManager userFactory = UserFactory.getInstance();\n \n         String userID = request.getParameter(\"userID\");\n+\n+        if (userID != null && userID.matches(\".*[&<>\\\"`']+.*\")) {\n+            throw new ServletException(\"User ID must not contain any HTML markup.\");\n+        }\n+\n         String password = request.getParameter(\"pass1\");\n \n         boolean hasUser = false;",
    "function_modified_lines": {
      "added": [
        "\n",
        "        if (userID != null && userID.matches(\".*[&<>\\\"`']+.*\")) {\n",
        "            throw new ServletException(\"User ID must not contain any HTML markup.\");\n",
        "        }\n",
        "\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-79"
    ],
    "cve_description": "In OpenNMS Horizon, versions opennms-18.0.0-1 through opennms-27.1.0-1; OpenNMS Meridian, versions meridian-foundation-2015.1.0-1 through meridian-foundation-2019.1.18-1; meridian-foundation-2020.1.0-1 through meridian-foundation-2020.1.7-1 are vulnerable to Stored Cross-Site Scripting, since the function `createRequisitionedNode()` does not perform any validation checks on the input sent to the `node-label` parameter. Due to this flaw an attacker could inject an arbitrary script which will be stored in the database.",
    "id": 12069
  },
  {
    "cve_id": "CVE-2021-25934",
    "code_before_change": "{\n        String userID = request.getParameter(\"userID\");\n        String newID = request.getParameter(\"newID\");\n\n        // now save to the xml file\n        try {\n            UserManager userFactory = UserFactory.getInstance();\n            userFactory.renameUser(userID, newID);\n        } catch (Throwable e) {\n            throw new ServletException(\"Error renaming user \" + userID + \" to \" + newID, e);\n        }\n\n        response.sendRedirect(\"list.jsp\");\n    }",
    "code_after_change": "{\n        String userID = request.getParameter(\"userID\");\n        String newID = request.getParameter(\"newID\");\n\n        if (newID != null && newID.matches(\".*[&<>\\\"`']+.*\")) {\n            throw new ServletException(\"User ID must not contain any HTML markup.\");\n        }\n\n        // now save to the xml file\n        try {\n            UserManager userFactory = UserFactory.getInstance();\n            userFactory.renameUser(userID, newID);\n        } catch (Throwable e) {\n            throw new ServletException(\"Error renaming user \" + userID + \" to \" + newID, e);\n        }\n\n        response.sendRedirect(\"list.jsp\");\n    }",
    "patch": "@@ -60,6 +60,10 @@ public void doPost(HttpServletRequest request, HttpServletResponse response) thr\n         String userID = request.getParameter(\"userID\");\n         String newID = request.getParameter(\"newID\");\n \n+        if (newID != null && newID.matches(\".*[&<>\\\"`']+.*\")) {\n+            throw new ServletException(\"User ID must not contain any HTML markup.\");\n+        }\n+\n         // now save to the xml file\n         try {\n             UserManager userFactory = UserFactory.getInstance();",
    "function_modified_lines": {
      "added": [
        "        if (newID != null && newID.matches(\".*[&<>\\\"`']+.*\")) {\n",
        "            throw new ServletException(\"User ID must not contain any HTML markup.\");\n",
        "        }\n",
        "\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-79"
    ],
    "cve_description": "In OpenNMS Horizon, versions opennms-18.0.0-1 through opennms-27.1.0-1; OpenNMS Meridian, versions meridian-foundation-2015.1.0-1 through meridian-foundation-2019.1.18-1; meridian-foundation-2020.1.0-1 through meridian-foundation-2020.1.7-1 are vulnerable to Stored Cross-Site Scripting, since the function `createRequisitionedNode()` does not perform any validation checks on the input sent to the `node-label` parameter. Due to this flaw an attacker could inject an arbitrary script which will be stored in the database.",
    "id": 12070
  },
  {
    "cve_id": "CVE-2021-25934",
    "code_before_change": "{    \n                \n        String groupName = request.getParameter(\"groupName\");\n        String groupComment = request.getParameter(\"groupComment\");\n        if (groupComment == null) {\n            groupComment = \"\";\n        }\n\n        boolean hasGroup = false;\n        try {\n            hasGroup = m_groupRepository.groupExists(groupName);\n        } catch (Throwable e) {\n            throw new ServletException(\"Can't determine if group \" + groupName + \" already exists in groups.xml.\", e);\n        }\n        \n        if (hasGroup) {\n            return new ModelAndView(\"admin/userGroupView/groups/newGroup\", \"action\", \"redo\");            \n        } else {\n            WebGroup newGroup = new WebGroup();\n            newGroup.setName(groupName);\n            newGroup.setComments(groupComment);\n            \n            return editGroup(request, newGroup);\n        }\n    }",
    "code_after_change": "{    \n                \n        String groupName = request.getParameter(\"groupName\");\n        String groupComment = request.getParameter(\"groupComment\");\n        if (groupComment == null) {\n            groupComment = \"\";\n        }\n\n        if (groupName != null && groupName.matches(\".*[&<>\\\"`']+.*\")) {\n            throw new ServletException(\"Group ID must not contain any HTML markup.\");\n        }\n\n        if (groupComment != null && groupComment.matches(\".*[&<>\\\"`']+.*\")) {\n            throw new ServletException(\"Group comment must not contain any HTML markup.\");\n        }\n\n        boolean hasGroup = false;\n        try {\n            hasGroup = m_groupRepository.groupExists(groupName);\n        } catch (Throwable e) {\n            throw new ServletException(\"Can't determine if group \" + groupName + \" already exists in groups.xml.\", e);\n        }\n        \n        if (hasGroup) {\n            return new ModelAndView(\"admin/userGroupView/groups/newGroup\", \"action\", \"redo\");            \n        } else {\n            WebGroup newGroup = new WebGroup();\n            newGroup.setName(groupName);\n            newGroup.setComments(groupComment);\n            \n            return editGroup(request, newGroup);\n        }\n    }",
    "patch": "@@ -151,7 +151,11 @@ private ModelAndView renameGroup(HttpServletRequest request, HttpServletResponse\n         \n         String oldName = request.getParameter(\"groupName\");\n         String newName = request.getParameter(\"newName\");\n-        \n+\n+        if (newName != null && newName.matches(\".*[&<>\\\"`']+.*\")) {\n+            throw new ServletException(\"Group ID must not contain any HTML markup.\");\n+        }\n+\n         if (StringUtils.hasText(oldName) && StringUtils.hasText(newName)) {\n             m_groupRepository.renameGroup(oldName, newName);\n         }\n@@ -312,6 +316,14 @@ private ModelAndView addGroup(HttpServletRequest request, HttpServletResponse re\n             groupComment = \"\";\n         }\n \n+        if (groupName != null && groupName.matches(\".*[&<>\\\"`']+.*\")) {\n+            throw new ServletException(\"Group ID must not contain any HTML markup.\");\n+        }\n+\n+        if (groupComment != null && groupComment.matches(\".*[&<>\\\"`']+.*\")) {\n+            throw new ServletException(\"Group comment must not contain any HTML markup.\");\n+        }\n+\n         boolean hasGroup = false;\n         try {\n             hasGroup = m_groupRepository.groupExists(groupName);",
    "function_modified_lines": {
      "added": [
        "        if (groupName != null && groupName.matches(\".*[&<>\\\"`']+.*\")) {\n",
        "            throw new ServletException(\"Group ID must not contain any HTML markup.\");\n",
        "        }\n",
        "\n",
        "        if (groupComment != null && groupComment.matches(\".*[&<>\\\"`']+.*\")) {\n",
        "            throw new ServletException(\"Group comment must not contain any HTML markup.\");\n",
        "        }\n",
        "\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-79"
    ],
    "cve_description": "In OpenNMS Horizon, versions opennms-18.0.0-1 through opennms-27.1.0-1; OpenNMS Meridian, versions meridian-foundation-2015.1.0-1 through meridian-foundation-2019.1.18-1; meridian-foundation-2020.1.0-1 through meridian-foundation-2020.1.7-1 are vulnerable to Stored Cross-Site Scripting, since the function `createRequisitionedNode()` does not perform any validation checks on the input sent to the `node-label` parameter. Due to this flaw an attacker could inject an arbitrary script which will be stored in the database.",
    "id": 12071
  },
  {
    "cve_id": "CVE-2021-25935",
    "code_before_change": "{\n        try {\n            UserFactory.init();\n        } catch (Throwable e) {\n            throw new ServletException(\"AddNewUserServlet: Error initialising user factory.\" + e);\n        }\n        UserManager userFactory = UserFactory.getInstance();\n\n        String userID = request.getParameter(\"userID\");\n        String password = request.getParameter(\"pass1\");\n\n        boolean hasUser = false;\n        try {\n            hasUser = userFactory.hasUser(userID);\n        } catch (Throwable e) {\n            throw new ServletException(\"can't determine if user \" + userID + \" already exists in users.xml.\", e);\n        }\n\n        if (hasUser) {\n            RequestDispatcher dispatcher = this.getServletContext().getRequestDispatcher(\"/admin/userGroupView/users/newUser.jsp?action=redo\");\n            dispatcher.forward(request, response);\n        } else {\n            final Password pass = new Password();\n            pass.setEncryptedPassword(UserFactory.getInstance().encryptedPassword(password, true));\n            pass.setSalt(true);\n\n            final User newUser = new User();\n            newUser.setUserId(userID);\n            newUser.setPassword(pass);\n\n            final HttpSession userSession = request.getSession(false);\n            userSession.setAttribute(\"user.modifyUser.jsp\", newUser);\n\n            // forward the request for proper display\n            RequestDispatcher dispatcher = this.getServletContext().getRequestDispatcher(\"/admin/userGroupView/users/modifyUser.jsp\");\n            dispatcher.forward(request, response);\n        }\n    }",
    "code_after_change": "{\n        try {\n            UserFactory.init();\n        } catch (Throwable e) {\n            throw new ServletException(\"AddNewUserServlet: Error initialising user factory.\" + e);\n        }\n        UserManager userFactory = UserFactory.getInstance();\n\n        String userID = request.getParameter(\"userID\");\n\n        if (userID != null && userID.matches(\".*[&<>\\\"`']+.*\")) {\n            throw new ServletException(\"User ID must not contain any HTML markup.\");\n        }\n\n        String password = request.getParameter(\"pass1\");\n\n        boolean hasUser = false;\n        try {\n            hasUser = userFactory.hasUser(userID);\n        } catch (Throwable e) {\n            throw new ServletException(\"can't determine if user \" + userID + \" already exists in users.xml.\", e);\n        }\n\n        if (hasUser) {\n            RequestDispatcher dispatcher = this.getServletContext().getRequestDispatcher(\"/admin/userGroupView/users/newUser.jsp?action=redo\");\n            dispatcher.forward(request, response);\n        } else {\n            final Password pass = new Password();\n            pass.setEncryptedPassword(UserFactory.getInstance().encryptedPassword(password, true));\n            pass.setSalt(true);\n\n            final User newUser = new User();\n            newUser.setUserId(userID);\n            newUser.setPassword(pass);\n\n            final HttpSession userSession = request.getSession(false);\n            userSession.setAttribute(\"user.modifyUser.jsp\", newUser);\n\n            // forward the request for proper display\n            RequestDispatcher dispatcher = this.getServletContext().getRequestDispatcher(\"/admin/userGroupView/users/modifyUser.jsp\");\n            dispatcher.forward(request, response);\n        }\n    }",
    "patch": "@@ -69,6 +69,11 @@ public void doPost(HttpServletRequest request, HttpServletResponse response) thr\n         UserManager userFactory = UserFactory.getInstance();\n \n         String userID = request.getParameter(\"userID\");\n+\n+        if (userID != null && userID.matches(\".*[&<>\\\"`']+.*\")) {\n+            throw new ServletException(\"User ID must not contain any HTML markup.\");\n+        }\n+\n         String password = request.getParameter(\"pass1\");\n \n         boolean hasUser = false;",
    "function_modified_lines": {
      "added": [
        "\n",
        "        if (userID != null && userID.matches(\".*[&<>\\\"`']+.*\")) {\n",
        "            throw new ServletException(\"User ID must not contain any HTML markup.\");\n",
        "        }\n",
        "\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-79"
    ],
    "cve_description": "In OpenNMS Horizon, versions opennms-17.0.0-1 through opennms-27.1.0-1; OpenNMS Meridian, versions meridian-foundation-2015.1.0-1 through meridian-foundation-2019.1.18-1; meridian-foundation-2020.1.0-1 through meridian-foundation-2020.1.7-1 are vulnerable to Stored Cross-Site Scripting, since the function `add()` performs improper validation checks on the input sent to the `foreign-source` parameter. Due to this flaw an attacker could bypass the existing regex validation and inject an arbitrary script which will be stored in the database.",
    "id": 12073
  },
  {
    "cve_id": "CVE-2021-25935",
    "code_before_change": "{\n        String userID = request.getParameter(\"userID\");\n        String newID = request.getParameter(\"newID\");\n\n        // now save to the xml file\n        try {\n            UserManager userFactory = UserFactory.getInstance();\n            userFactory.renameUser(userID, newID);\n        } catch (Throwable e) {\n            throw new ServletException(\"Error renaming user \" + userID + \" to \" + newID, e);\n        }\n\n        response.sendRedirect(\"list.jsp\");\n    }",
    "code_after_change": "{\n        String userID = request.getParameter(\"userID\");\n        String newID = request.getParameter(\"newID\");\n\n        if (newID != null && newID.matches(\".*[&<>\\\"`']+.*\")) {\n            throw new ServletException(\"User ID must not contain any HTML markup.\");\n        }\n\n        // now save to the xml file\n        try {\n            UserManager userFactory = UserFactory.getInstance();\n            userFactory.renameUser(userID, newID);\n        } catch (Throwable e) {\n            throw new ServletException(\"Error renaming user \" + userID + \" to \" + newID, e);\n        }\n\n        response.sendRedirect(\"list.jsp\");\n    }",
    "patch": "@@ -60,6 +60,10 @@ public void doPost(HttpServletRequest request, HttpServletResponse response) thr\n         String userID = request.getParameter(\"userID\");\n         String newID = request.getParameter(\"newID\");\n \n+        if (newID != null && newID.matches(\".*[&<>\\\"`']+.*\")) {\n+            throw new ServletException(\"User ID must not contain any HTML markup.\");\n+        }\n+\n         // now save to the xml file\n         try {\n             UserManager userFactory = UserFactory.getInstance();",
    "function_modified_lines": {
      "added": [
        "        if (newID != null && newID.matches(\".*[&<>\\\"`']+.*\")) {\n",
        "            throw new ServletException(\"User ID must not contain any HTML markup.\");\n",
        "        }\n",
        "\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-79"
    ],
    "cve_description": "In OpenNMS Horizon, versions opennms-17.0.0-1 through opennms-27.1.0-1; OpenNMS Meridian, versions meridian-foundation-2015.1.0-1 through meridian-foundation-2019.1.18-1; meridian-foundation-2020.1.0-1 through meridian-foundation-2020.1.7-1 are vulnerable to Stored Cross-Site Scripting, since the function `add()` performs improper validation checks on the input sent to the `foreign-source` parameter. Due to this flaw an attacker could bypass the existing regex validation and inject an arbitrary script which will be stored in the database.",
    "id": 12074
  },
  {
    "cve_id": "CVE-2021-25935",
    "code_before_change": "{    \n                \n        String groupName = request.getParameter(\"groupName\");\n        String groupComment = request.getParameter(\"groupComment\");\n        if (groupComment == null) {\n            groupComment = \"\";\n        }\n\n        boolean hasGroup = false;\n        try {\n            hasGroup = m_groupRepository.groupExists(groupName);\n        } catch (Throwable e) {\n            throw new ServletException(\"Can't determine if group \" + groupName + \" already exists in groups.xml.\", e);\n        }\n        \n        if (hasGroup) {\n            return new ModelAndView(\"admin/userGroupView/groups/newGroup\", \"action\", \"redo\");            \n        } else {\n            WebGroup newGroup = new WebGroup();\n            newGroup.setName(groupName);\n            newGroup.setComments(groupComment);\n            \n            return editGroup(request, newGroup);\n        }\n    }",
    "code_after_change": "{    \n                \n        String groupName = request.getParameter(\"groupName\");\n        String groupComment = request.getParameter(\"groupComment\");\n        if (groupComment == null) {\n            groupComment = \"\";\n        }\n\n        if (groupName != null && groupName.matches(\".*[&<>\\\"`']+.*\")) {\n            throw new ServletException(\"Group ID must not contain any HTML markup.\");\n        }\n\n        if (groupComment != null && groupComment.matches(\".*[&<>\\\"`']+.*\")) {\n            throw new ServletException(\"Group comment must not contain any HTML markup.\");\n        }\n\n        boolean hasGroup = false;\n        try {\n            hasGroup = m_groupRepository.groupExists(groupName);\n        } catch (Throwable e) {\n            throw new ServletException(\"Can't determine if group \" + groupName + \" already exists in groups.xml.\", e);\n        }\n        \n        if (hasGroup) {\n            return new ModelAndView(\"admin/userGroupView/groups/newGroup\", \"action\", \"redo\");            \n        } else {\n            WebGroup newGroup = new WebGroup();\n            newGroup.setName(groupName);\n            newGroup.setComments(groupComment);\n            \n            return editGroup(request, newGroup);\n        }\n    }",
    "patch": "@@ -151,7 +151,11 @@ private ModelAndView renameGroup(HttpServletRequest request, HttpServletResponse\n         \n         String oldName = request.getParameter(\"groupName\");\n         String newName = request.getParameter(\"newName\");\n-        \n+\n+        if (newName != null && newName.matches(\".*[&<>\\\"`']+.*\")) {\n+            throw new ServletException(\"Group ID must not contain any HTML markup.\");\n+        }\n+\n         if (StringUtils.hasText(oldName) && StringUtils.hasText(newName)) {\n             m_groupRepository.renameGroup(oldName, newName);\n         }\n@@ -312,6 +316,14 @@ private ModelAndView addGroup(HttpServletRequest request, HttpServletResponse re\n             groupComment = \"\";\n         }\n \n+        if (groupName != null && groupName.matches(\".*[&<>\\\"`']+.*\")) {\n+            throw new ServletException(\"Group ID must not contain any HTML markup.\");\n+        }\n+\n+        if (groupComment != null && groupComment.matches(\".*[&<>\\\"`']+.*\")) {\n+            throw new ServletException(\"Group comment must not contain any HTML markup.\");\n+        }\n+\n         boolean hasGroup = false;\n         try {\n             hasGroup = m_groupRepository.groupExists(groupName);",
    "function_modified_lines": {
      "added": [
        "        if (groupName != null && groupName.matches(\".*[&<>\\\"`']+.*\")) {\n",
        "            throw new ServletException(\"Group ID must not contain any HTML markup.\");\n",
        "        }\n",
        "\n",
        "        if (groupComment != null && groupComment.matches(\".*[&<>\\\"`']+.*\")) {\n",
        "            throw new ServletException(\"Group comment must not contain any HTML markup.\");\n",
        "        }\n",
        "\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-79"
    ],
    "cve_description": "In OpenNMS Horizon, versions opennms-17.0.0-1 through opennms-27.1.0-1; OpenNMS Meridian, versions meridian-foundation-2015.1.0-1 through meridian-foundation-2019.1.18-1; meridian-foundation-2020.1.0-1 through meridian-foundation-2020.1.7-1 are vulnerable to Stored Cross-Site Scripting, since the function `add()` performs improper validation checks on the input sent to the `foreign-source` parameter. Due to this flaw an attacker could bypass the existing regex validation and inject an arbitrary script which will be stored in the database.",
    "id": 12075
  },
  {
    "cve_id": "CVE-2023-31544",
    "code_before_change": "{\n\n    /**\n     * Widget containing the image(s) for a result list item..<p>\n     */\n    public class ImageTile extends HTML implements I_CmsDragHandle {\n\n        /** The draggable result list item. */\n        private I_CmsDraggable m_draggable;\n\n        /**\n         * Creates a new instance with the given content.<p>\n         *\n         * @param content the HTML content\n         */\n        public ImageTile(String content) {\n\n            super(content);\n        }\n\n        /**\n         * @see org.opencms.gwt.client.dnd.I_CmsDragHandle#getDraggable()\n         */\n        public I_CmsDraggable getDraggable() {\n\n            return m_draggable;\n        }\n\n        /**\n         * Sets the draggable widget.<p>\n         *\n         * @param draggable the draggable widget\n         */\n        public void setDraggable(I_CmsDraggable draggable) {\n\n            m_draggable = draggable;\n        }\n\n    }\n\n    /** Standard image tile scale parameter. */\n    private static final String IMAGE_SCALE_PARAM = \"?__scale=t:1,c:ffffff,r:0\";\n\n    /** Tile view flag. */\n    private boolean m_hasTileView;\n\n    /** The image tile. */\n    private ImageTile m_imageTile;\n\n    /** The tool tip handler. */\n    private CmsToolTipHandler m_tooltipHandler;\n\n    /**\n     * Constructor.<p>\n     *\n     * @param infoBean the resource info bean\n     * @param showPath <code>true</code> to show the resource path in sub title\n     */\n    public CmsResultItemWidget(CmsResultItemBean infoBean, boolean showPath) {\n\n        super(infoBean);\n        if (showPath) {\n            setSubtitleLabel(infoBean.getPath());\n            setSubtitleTitle(infoBean.getSubTitle());\n        } else {\n            setSubtitleTitle(infoBean.getPath());\n        }\n\n        // if resourceType==\"image\" prepare for tile view\n        if (CmsResultsTab.isImagelikeType(infoBean.getType())) {\n            m_hasTileView = true;\n            // add tile view marker css classes\n            String src = infoBean.getViewLink();\n            if (src == null) {\n                src = CmsCoreProvider.get().link(infoBean.getPath());\n            }\n            String timeParam = \"&time=\" + System.currentTimeMillis();\n            // insert tile view image div\n            ImageTile imageTile = new ImageTile(\"<img src=\\\"\" + src + getBigImageScaleParam()\n            // add time stamp to override browser image caching\n                + timeParam\n                + \"\\\" class=\\\"\"\n                + I_CmsLayoutBundle.INSTANCE.galleryResultItemCss().bigImage()\n                + \"\\\" />\"\n                // using a second image tag for the small thumbnail variant\n                + \"<img src=\\\"\"\n                + src\n                + getSmallImageScaleParam(infoBean)\n                // add time stamp to override browser image caching\n                + timeParam\n                + \"\\\" class=\\\"\"\n                + I_CmsLayoutBundle.INSTANCE.galleryResultItemCss().smallImage()\n                + \"\\\" />\"\n                + \"<div class='\"\n                + I_CmsLayoutBundle.INSTANCE.galleryResultItemCss().expiredImageOverlay()\n                + \"' />\");\n            imageTile.setStyleName(I_CmsLayoutBundle.INSTANCE.galleryResultItemCss().imageTile());\n            if (CmsClientStringUtil.checkIsPathOrLinkToSvg(infoBean.getPath())) {\n                imageTile.addStyleName(I_CmsLayoutBundle.INSTANCE.galleryResultItemCss().svg());\n            }\n            m_imageTile = imageTile;\n            m_tooltipHandler = new CmsToolTipHandler(imageTile, generateTooltipHtml(infoBean));\n            m_contentPanel.insert(imageTile, 0);\n        }\n\n    }\n\n    /**\n     * Gets the image tile.<p>\n     *\n     * @return the image tile\n     */\n    public ImageTile getImageTile() {\n\n        return m_imageTile;\n    }\n\n    /**\n     * Indicates wther there is a tile view available for this widget.<p>\n     *\n     * @return <code>true</code> if a tiled view is available\n     */\n    public boolean hasTileView() {\n\n        return m_hasTileView;\n    }\n\n    /**\n     * Initializes the title attribute of the subtitle line.<p>\n     *\n     * @param subtitleTitle the value to set\n     */\n    public void setSubtitleTitle(final String subtitleTitle) {\n\n        m_subtitle.setTitle(subtitleTitle);\n        m_subtitle.setTitleGenerator(new I_TitleGenerator() {\n\n            public String getTitle(String originalText) {\n\n                return subtitleTitle;\n            }\n        });\n    }\n\n    /**\n     * @see com.google.gwt.user.client.ui.Composite#onDetach()\n     */\n    @Override\n    protected void onDetach() {\n\n        if (m_tooltipHandler != null) {\n            m_tooltipHandler.clearShowing();\n        }\n        super.onDetach();\n    }\n\n    /**\n     * Generates the HTML for the item tool-tip.<p>\n     *\n     * @param infoBean the item info\n     *\n     * @return the generated HTML\n     */\n    private String generateTooltipHtml(CmsListInfoBean infoBean) {\n\n        StringBuffer result = new StringBuffer();\n        result.append(\"<p><b>\").append(CmsClientStringUtil.shortenString(infoBean.getTitle(), 70)).append(\"</b></p>\");\n        if (infoBean.hasAdditionalInfo()) {\n            for (CmsAdditionalInfoBean additionalInfo : infoBean.getAdditionalInfo()) {\n                result.append(\"<p>\").append(additionalInfo.getName()).append(\":&nbsp;\");\n                // shorten the value to max 45 characters\n                result.append(CmsClientStringUtil.shortenString(additionalInfo.getValue(), 45)).append(\"</p>\");\n            }\n        }\n        return result.toString();\n    }\n\n    /**\n     * Returns the scale parameter for big thumbnail images.<p>\n     *\n     * @return the scale parameter\n     */\n    private String getBigImageScaleParam() {\n\n        return IMAGE_SCALE_PARAM\n            + \",w:\"\n            + I_CmsLayoutBundle.INSTANCE.galleryResultItemCss().bigImageWidth()\n            + \",h:\"\n            + I_CmsLayoutBundle.INSTANCE.galleryResultItemCss().bigImageHeight();\n    }\n\n    /**\n     * Returns the scale parameter for small thumbnail images.<p>\n     *\n     * @param infoBean the resource info\n     *\n     * @return the scale parameter\n     */\n    private String getSmallImageScaleParam(CmsResultItemBean infoBean) {\n\n        String result = null;\n        if (infoBean.getDimension() != null) {\n            String[] sizes = infoBean.getDimension().split(\"x\");\n            try {\n                int width = Integer.parseInt(sizes[0].trim());\n                int height = Integer.parseInt(sizes[1].trim());\n                // only use the small image dimensions in case of dimensions smaller than the big thumbnail\n                if ((I_CmsLayoutBundle.INSTANCE.galleryResultItemCss().bigImageWidth() > width)\n                    || (I_CmsLayoutBundle.INSTANCE.galleryResultItemCss().bigImageHeight() > height)) {\n                    result = IMAGE_SCALE_PARAM\n                        + \",w:\"\n                        + I_CmsLayoutBundle.INSTANCE.galleryResultItemCss().smallImageWidth()\n                        + \",h:\"\n                        + I_CmsLayoutBundle.INSTANCE.galleryResultItemCss().smallImageHeight();\n                }\n            } catch (Exception e) {\n                // failed parsing the dimensions, will use big image\n            }\n        }\n        if (result == null) {\n            result = getBigImageScaleParam();\n        }\n        return result;\n    }\n}",
    "code_after_change": "{\n\n    /**\n     * Widget containing the image(s) for a result list item..<p>\n     */\n    public class ImageTile extends HTML implements I_CmsDragHandle {\n\n        /** The draggable result list item. */\n        private I_CmsDraggable m_draggable;\n\n        /**\n         * Creates a new instance with the given content.<p>\n         *\n         * @param content the HTML content\n         */\n        public ImageTile(String content) {\n\n            super(content);\n        }\n\n        /**\n         * @see org.opencms.gwt.client.dnd.I_CmsDragHandle#getDraggable()\n         */\n        public I_CmsDraggable getDraggable() {\n\n            return m_draggable;\n        }\n\n        /**\n         * Sets the draggable widget.<p>\n         *\n         * @param draggable the draggable widget\n         */\n        public void setDraggable(I_CmsDraggable draggable) {\n\n            m_draggable = draggable;\n        }\n\n    }\n\n    /** Standard image tile scale parameter. */\n    private static final String IMAGE_SCALE_PARAM = \"?__scale=t:1,c:ffffff,r:0\";\n\n    /** Tile view flag. */\n    private boolean m_hasTileView;\n\n    /** The image tile. */\n    private ImageTile m_imageTile;\n\n    /** The tool tip handler. */\n    private CmsToolTipHandler m_tooltipHandler;\n\n    /**\n     * Constructor.<p>\n     *\n     * @param infoBean the resource info bean\n     * @param showPath <code>true</code> to show the resource path in sub title\n     */\n    public CmsResultItemWidget(CmsResultItemBean infoBean, boolean showPath) {\n\n        super(infoBean);\n        if (showPath) {\n            setSubtitleLabel(infoBean.getPath());\n            setSubtitleTitle(infoBean.getSubTitle());\n        } else {\n            setSubtitleTitle(infoBean.getPath());\n        }\n\n        // if resourceType==\"image\" prepare for tile view\n        if (CmsResultsTab.isImagelikeType(infoBean.getType())) {\n            m_hasTileView = true;\n            // add tile view marker css classes\n            String src = infoBean.getViewLink();\n            if (src == null) {\n                src = CmsCoreProvider.get().link(infoBean.getPath());\n            }\n            String timeParam = \"&time=\" + System.currentTimeMillis();\n            // insert tile view image div\n            ImageTile imageTile = new ImageTile(\"<img src=\\\"\" + src + getBigImageScaleParam()\n            // add time stamp to override browser image caching\n                + timeParam\n                + \"\\\" class=\\\"\"\n                + I_CmsLayoutBundle.INSTANCE.galleryResultItemCss().bigImage()\n                + \"\\\" />\"\n                // using a second image tag for the small thumbnail variant\n                + \"<img src=\\\"\"\n                + src\n                + getSmallImageScaleParam(infoBean)\n                // add time stamp to override browser image caching\n                + timeParam\n                + \"\\\" class=\\\"\"\n                + I_CmsLayoutBundle.INSTANCE.galleryResultItemCss().smallImage()\n                + \"\\\" />\"\n                + \"<div class='\"\n                + I_CmsLayoutBundle.INSTANCE.galleryResultItemCss().expiredImageOverlay()\n                + \"' />\");\n            imageTile.setStyleName(I_CmsLayoutBundle.INSTANCE.galleryResultItemCss().imageTile());\n            if (CmsClientStringUtil.checkIsPathOrLinkToSvg(infoBean.getPath())) {\n                imageTile.addStyleName(I_CmsLayoutBundle.INSTANCE.galleryResultItemCss().svg());\n            }\n            m_imageTile = imageTile;\n            m_tooltipHandler = new CmsToolTipHandler(imageTile, generateTooltipHtml(infoBean));\n            m_contentPanel.insert(imageTile, 0);\n        }\n\n    }\n\n    private static Element appendDom(Element parent, String name) {\n\n        Element child = DOM.createElement(name);\n        parent.appendChild(child);\n        return child;\n    }\n\n    /**\n     * Gets the image tile.<p>\n     *\n     * @return the image tile\n     */\n    public ImageTile getImageTile() {\n\n        return m_imageTile;\n    }\n\n    /**\n     * Indicates wther there is a tile view available for this widget.<p>\n     *\n     * @return <code>true</code> if a tiled view is available\n     */\n    public boolean hasTileView() {\n\n        return m_hasTileView;\n    }\n\n    /**\n     * Initializes the title attribute of the subtitle line.<p>\n     *\n     * @param subtitleTitle the value to set\n     */\n    public void setSubtitleTitle(final String subtitleTitle) {\n\n        m_subtitle.setTitle(subtitleTitle);\n        m_subtitle.setTitleGenerator(new I_TitleGenerator() {\n\n            public String getTitle(String originalText) {\n\n                return subtitleTitle;\n            }\n        });\n    }\n\n    /**\n     * @see com.google.gwt.user.client.ui.Composite#onDetach()\n     */\n    @Override\n    protected void onDetach() {\n\n        if (m_tooltipHandler != null) {\n            m_tooltipHandler.clearShowing();\n        }\n        super.onDetach();\n    }\n\n    /**\n     * Generates the HTML for the item tool-tip.<p>\n     *\n     * @param infoBean the item info\n     *\n     * @return the generated HTML\n     */\n    private String generateTooltipHtml(CmsListInfoBean infoBean) {\n\n        Element root = DOM.createElement(\"div\");\n        appendDom(appendDom(root, \"p\"), \"b\").setInnerText(CmsClientStringUtil.shortenString(infoBean.getTitle(), 70));\n        if (infoBean.hasAdditionalInfo()) {\n            for (CmsAdditionalInfoBean additionalInfo : infoBean.getAdditionalInfo()) {\n                appendDom(root, \"p\").setInnerText(\n                    additionalInfo.getName()\n                        + \":\\u00a0\"\n                        + CmsClientStringUtil.shortenString(additionalInfo.getValue(), 45));\n            }\n        }\n        return root.getInnerHTML();\n    }\n\n    /**\n     * Returns the scale parameter for big thumbnail images.<p>\n     *\n     * @return the scale parameter\n     */\n    private String getBigImageScaleParam() {\n\n        return IMAGE_SCALE_PARAM\n            + \",w:\"\n            + I_CmsLayoutBundle.INSTANCE.galleryResultItemCss().bigImageWidth()\n            + \",h:\"\n            + I_CmsLayoutBundle.INSTANCE.galleryResultItemCss().bigImageHeight();\n    }\n\n    /**\n     * Returns the scale parameter for small thumbnail images.<p>\n     *\n     * @param infoBean the resource info\n     *\n     * @return the scale parameter\n     */\n    private String getSmallImageScaleParam(CmsResultItemBean infoBean) {\n\n        String result = null;\n        if (infoBean.getDimension() != null) {\n            String[] sizes = infoBean.getDimension().split(\"x\");\n            try {\n                int width = Integer.parseInt(sizes[0].trim());\n                int height = Integer.parseInt(sizes[1].trim());\n                // only use the small image dimensions in case of dimensions smaller than the big thumbnail\n                if ((I_CmsLayoutBundle.INSTANCE.galleryResultItemCss().bigImageWidth() > width)\n                    || (I_CmsLayoutBundle.INSTANCE.galleryResultItemCss().bigImageHeight() > height)) {\n                    result = IMAGE_SCALE_PARAM\n                        + \",w:\"\n                        + I_CmsLayoutBundle.INSTANCE.galleryResultItemCss().smallImageWidth()\n                        + \",h:\"\n                        + I_CmsLayoutBundle.INSTANCE.galleryResultItemCss().smallImageHeight();\n                }\n            } catch (Exception e) {\n                // failed parsing the dimensions, will use big image\n            }\n        }\n        if (result == null) {\n            result = getBigImageScaleParam();\n        }\n        return result;\n    }\n}",
    "patch": "@@ -39,6 +39,8 @@\n import org.opencms.gwt.shared.CmsAdditionalInfoBean;\n import org.opencms.gwt.shared.CmsListInfoBean;\n \n+import com.google.gwt.dom.client.Element;\n+import com.google.gwt.user.client.DOM;\n import com.google.gwt.user.client.ui.HTML;\n \n /**\n@@ -155,6 +157,13 @@ public CmsResultItemWidget(CmsResultItemBean infoBean, boolean showPath) {\n \n     }\n \n+    private static Element appendDom(Element parent, String name) {\n+\n+        Element child = DOM.createElement(name);\n+        parent.appendChild(child);\n+        return child;\n+    }\n+\n     /**\n      * Gets the image tile.<p>\n      *\n@@ -213,16 +222,17 @@ protected void onDetach() {\n      */\n     private String generateTooltipHtml(CmsListInfoBean infoBean) {\n \n-        StringBuffer result = new StringBuffer();\n-        result.append(\"<p><b>\").append(CmsClientStringUtil.shortenString(infoBean.getTitle(), 70)).append(\"</b></p>\");\n+        Element root = DOM.createElement(\"div\");\n+        appendDom(appendDom(root, \"p\"), \"b\").setInnerText(CmsClientStringUtil.shortenString(infoBean.getTitle(), 70));\n         if (infoBean.hasAdditionalInfo()) {\n             for (CmsAdditionalInfoBean additionalInfo : infoBean.getAdditionalInfo()) {\n-                result.append(\"<p>\").append(additionalInfo.getName()).append(\":&nbsp;\");\n-                // shorten the value to max 45 characters\n-                result.append(CmsClientStringUtil.shortenString(additionalInfo.getValue(), 45)).append(\"</p>\");\n+                appendDom(root, \"p\").setInnerText(\n+                    additionalInfo.getName()\n+                        + \":\\u00a0\"\n+                        + CmsClientStringUtil.shortenString(additionalInfo.getValue(), 45));\n             }\n         }\n-        return result.toString();\n+        return root.getInnerHTML();\n     }\n \n     /**",
    "function_modified_lines": {
      "added": [
        "    private static Element appendDom(Element parent, String name) {\n",
        "\n",
        "        Element child = DOM.createElement(name);\n",
        "        parent.appendChild(child);\n",
        "        return child;\n",
        "    }\n",
        "\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-79"
    ],
    "cve_description": "A stored cross-site scripting (XSS) vulnerability in alkacon-OpenCMS v11.0.0.0 allows attackers to execute arbitrary web scripts or HTML via a crafted payload injected into the Title field under the Upload Image module.",
    "id": 12111
  },
  {
    "cve_id": "CVE-2023-31544",
    "code_before_change": "{\n\n        StringBuffer result = new StringBuffer();\n        result.append(\"<p><b>\").append(CmsClientStringUtil.shortenString(infoBean.getTitle(), 70)).append(\"</b></p>\");\n        if (infoBean.hasAdditionalInfo()) {\n            for (CmsAdditionalInfoBean additionalInfo : infoBean.getAdditionalInfo()) {\n                result.append(\"<p>\").append(additionalInfo.getName()).append(\":&nbsp;\");\n                // shorten the value to max 45 characters\n                result.append(CmsClientStringUtil.shortenString(additionalInfo.getValue(), 45)).append(\"</p>\");\n            }\n        }\n        return result.toString();\n    }",
    "code_after_change": "{\n\n        Element root = DOM.createElement(\"div\");\n        appendDom(appendDom(root, \"p\"), \"b\").setInnerText(CmsClientStringUtil.shortenString(infoBean.getTitle(), 70));\n        if (infoBean.hasAdditionalInfo()) {\n            for (CmsAdditionalInfoBean additionalInfo : infoBean.getAdditionalInfo()) {\n                appendDom(root, \"p\").setInnerText(\n                    additionalInfo.getName()\n                        + \":\\u00a0\"\n                        + CmsClientStringUtil.shortenString(additionalInfo.getValue(), 45));\n            }\n        }\n        return root.getInnerHTML();\n    }",
    "patch": "@@ -39,6 +39,8 @@\n import org.opencms.gwt.shared.CmsAdditionalInfoBean;\n import org.opencms.gwt.shared.CmsListInfoBean;\n \n+import com.google.gwt.dom.client.Element;\n+import com.google.gwt.user.client.DOM;\n import com.google.gwt.user.client.ui.HTML;\n \n /**\n@@ -155,6 +157,13 @@ public CmsResultItemWidget(CmsResultItemBean infoBean, boolean showPath) {\n \n     }\n \n+    private static Element appendDom(Element parent, String name) {\n+\n+        Element child = DOM.createElement(name);\n+        parent.appendChild(child);\n+        return child;\n+    }\n+\n     /**\n      * Gets the image tile.<p>\n      *\n@@ -213,16 +222,17 @@ protected void onDetach() {\n      */\n     private String generateTooltipHtml(CmsListInfoBean infoBean) {\n \n-        StringBuffer result = new StringBuffer();\n-        result.append(\"<p><b>\").append(CmsClientStringUtil.shortenString(infoBean.getTitle(), 70)).append(\"</b></p>\");\n+        Element root = DOM.createElement(\"div\");\n+        appendDom(appendDom(root, \"p\"), \"b\").setInnerText(CmsClientStringUtil.shortenString(infoBean.getTitle(), 70));\n         if (infoBean.hasAdditionalInfo()) {\n             for (CmsAdditionalInfoBean additionalInfo : infoBean.getAdditionalInfo()) {\n-                result.append(\"<p>\").append(additionalInfo.getName()).append(\":&nbsp;\");\n-                // shorten the value to max 45 characters\n-                result.append(CmsClientStringUtil.shortenString(additionalInfo.getValue(), 45)).append(\"</p>\");\n+                appendDom(root, \"p\").setInnerText(\n+                    additionalInfo.getName()\n+                        + \":\\u00a0\"\n+                        + CmsClientStringUtil.shortenString(additionalInfo.getValue(), 45));\n             }\n         }\n-        return result.toString();\n+        return root.getInnerHTML();\n     }\n \n     /**",
    "function_modified_lines": {
      "added": [
        "        Element root = DOM.createElement(\"div\");\n",
        "        appendDom(appendDom(root, \"p\"), \"b\").setInnerText(CmsClientStringUtil.shortenString(infoBean.getTitle(), 70));\n",
        "                appendDom(root, \"p\").setInnerText(\n",
        "                    additionalInfo.getName()\n",
        "                        + \":\\u00a0\"\n",
        "                        + CmsClientStringUtil.shortenString(additionalInfo.getValue(), 45));\n",
        "        return root.getInnerHTML();\n"
      ],
      "deleted": [
        "        StringBuffer result = new StringBuffer();\n",
        "        result.append(\"<p><b>\").append(CmsClientStringUtil.shortenString(infoBean.getTitle(), 70)).append(\"</b></p>\");\n",
        "                result.append(\"<p>\").append(additionalInfo.getName()).append(\":&nbsp;\");\n",
        "                // shorten the value to max 45 characters\n",
        "                result.append(CmsClientStringUtil.shortenString(additionalInfo.getValue(), 45)).append(\"</p>\");\n",
        "        return result.toString();\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-79"
    ],
    "cve_description": "A stored cross-site scripting (XSS) vulnerability in alkacon-OpenCMS v11.0.0.0 allows attackers to execute arbitrary web scripts or HTML via a crafted payload injected into the Title field under the Upload Image module.",
    "id": 12112
  },
  {
    "cve_id": "CVE-2020-36635",
    "code_before_change": "{\r\n\t\r\n\t/** Log for this class and subclasses */\r\n\tprotected final Log log = LogFactory.getLog(getClass());\r\n\t\r\n\t@Autowired\r\n\t@Qualifier(\"appointmentService\")\r\n\tprivate AppointmentService appointmentService;\r\n\t\r\n\t/**\r\n\t * Determines if the command object being submitted is a valid type\r\n\t * \r\n\t * @see org.springframework.validation.Validator#supports(java.lang.Class)\r\n\t */\r\n\t@SuppressWarnings(\"unchecked\")\r\n\tpublic boolean supports(Class c) {\r\n\t\treturn c.equals(AppointmentType.class);\r\n\t}\r\n\t\r\n\tpublic void setAppointmentService(AppointmentService appointmentService) {\r\n\t\tthis.appointmentService = appointmentService;\r\n\t}\r\n\t\r\n\tpublic AppointmentService getAppointmentService() {\r\n\t\treturn appointmentService;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Checks the form object for any inconsistencies/errors\r\n\t * \r\n\t * @see org.springframework.validation.Validator#validate(java.lang.Object,\r\n\t *      org.springframework.validation.Errors)\r\n\t * <strong>Should</strong> fail validation if name is null or empty or whitespace\r\n\t * <strong>Should</strong> pass validation if all required fields have proper values\r\n\t */\r\n\tpublic void validate(Object obj, Errors errors) {\r\n\t\tAppointmentType appointmentType = (AppointmentType) obj;\r\n\t\tif (appointmentType == null) {\r\n\t\t\terrors.rejectValue(\"appointmentType\", \"error.general\");\r\n\t\t} else {\r\n\t\t\tvalidateDurationField(errors, appointmentType);\r\n\t\t\tvalidateFieldName(errors, appointmentType);\r\n\t\t\tvalidateDescriptionField(errors, appointmentType.getDescription());\r\n\t\t}\r\n\t}\r\n\t\r\n\tprivate void validateFieldName(Errors errors, AppointmentType appointmentType) {\r\n\t\tValidationUtils.rejectIfEmptyOrWhitespace(errors, \"name\", \"error.name\");\r\n\t\tif (appointmentService.verifyDuplicatedAppointmentTypeName(appointmentType)) {\r\n\t\t\terrors.rejectValue(\"name\", \"appointmentscheduling.AppointmentType.nameDuplicated\");\r\n\t\t}\r\n\t\tif (verifyIfNameHasMoreThan100Characters(appointmentType.getName())) {\r\n\t\t\terrors.rejectValue(\"name\", \"appointmentscheduling.AppointmentType.longName.errorMessage\");\r\n\t\t}\r\n\t}\r\n\t\r\n\tprivate boolean verifyIfNameHasMoreThan100Characters(String appointmentName) {\r\n\t\tif (appointmentName != null) {\r\n\t\t\treturn (appointmentName.length() > 100) ? true : false;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\t\r\n\tprivate void validateDurationField(Errors errors, AppointmentType appointmentType) {\r\n\t\tValidationUtils.rejectIfEmpty(errors, \"duration\", \"appointmentscheduling.AppointmentType.durationEmpty\");\r\n\t\tif (appointmentType.getDuration() == null || appointmentType.getDuration() <= 0) {\r\n\t\t\terrors.rejectValue(\"duration\", \"appointmentscheduling.AppointmentType.duration.errorMessage\");\r\n\t\t}\r\n\t}\r\n\t\r\n\tprivate void validateDescriptionField(Errors errors, String description) {\r\n\t\tif (verifyIfDescriptionHasMoreThan1024Characters(description)) {\r\n\t\t\terrors.rejectValue(\"description\", \"appointmentscheduling.AppointmentType.description.errorMessage\");\r\n\t\t}\r\n\t}\r\n\t\r\n\tprivate boolean verifyIfDescriptionHasMoreThan1024Characters(String description) {\r\n\t\tif (description != null) {\r\n\t\t\treturn (description.length() > 1024) ? true : false;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\t\r\n}",
    "code_after_change": "{\r\n\t\tValidationUtils.rejectIfEmptyOrWhitespace(errors, \"name\", \"error.name\");\r\n\t\tif (appointmentService.verifyDuplicatedAppointmentTypeName(appointmentType)) {\r\n\t\t\terrors.rejectValue(\"name\", \"appointmentscheduling.AppointmentType.nameDuplicated\");\r\n\t\t}\r\n\t\tif (verifyIfNameHasMoreThan100Characters(appointmentType.getName())) {\r\n\t\t\terrors.rejectValue(\"name\", \"appointmentscheduling.AppointmentType.longName.errorMessage\");\r\n\t\t}\r\n\t\tif(verifyIfNameHasHtmlEncodableChars(appointmentType.getName())){\r\n\t\t\terrors.rejectValue(\"name\", \"appointmentscheduling.AppointmentType.unsafeName.errorMessage\");\r\n\t\t}\r\n\t}",
    "patch": "@@ -18,6 +18,7 @@\n import org.openmrs.annotation.Handler;\r\n import org.openmrs.module.appointmentscheduling.AppointmentType;\r\n import org.openmrs.module.appointmentscheduling.api.AppointmentService;\r\n+import org.openmrs.web.WebUtil;\r\n import org.springframework.beans.factory.annotation.Autowired;\r\n import org.springframework.beans.factory.annotation.Qualifier;\r\n import org.springframework.validation.Errors;\r\n@@ -82,6 +83,9 @@ private void validateFieldName(Errors errors, AppointmentType appointmentType) {\n \t\tif (verifyIfNameHasMoreThan100Characters(appointmentType.getName())) {\r\n \t\t\terrors.rejectValue(\"name\", \"appointmentscheduling.AppointmentType.longName.errorMessage\");\r\n \t\t}\r\n+\t\tif(verifyIfNameHasHtmlEncodableChars(appointmentType.getName())){\r\n+\t\t\terrors.rejectValue(\"name\", \"appointmentscheduling.AppointmentType.unsafeName.errorMessage\");\r\n+\t\t}\r\n \t}\r\n \t\r\n \tprivate boolean verifyIfNameHasMoreThan100Characters(String appointmentName) {\r\n@@ -110,5 +114,12 @@ private boolean verifyIfDescriptionHasMoreThan1024Characters(String description)\n \t\t}\r\n \t\treturn false;\r\n \t}\r\n+\r\n+\tprivate boolean verifyIfNameHasHtmlEncodableChars(String appointmentName) {\r\n+\t\tif(appointmentName != null){\r\n+\t\t\treturn !WebUtil.escapeHTML(appointmentName).equals(appointmentName);\r\n+\t\t}\r\n+\t\treturn false;\r\n+\t}\r\n \t\r\n }\r",
    "function_modified_lines": {
      "added": [
        "\t\tif(verifyIfNameHasHtmlEncodableChars(appointmentType.getName())){\r\n",
        "\t\t\terrors.rejectValue(\"name\", \"appointmentscheduling.AppointmentType.unsafeName.errorMessage\");\r\n",
        "\t\t}\r\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-79"
    ],
    "cve_description": "A vulnerability was found in OpenMRS Appointment Scheduling Module up to 1.12.x. It has been classified as problematic. This affects the function validateFieldName of the file api/src/main/java/org/openmrs/module/appointmentscheduling/validator/AppointmentTypeValidator.java. The manipulation leads to cross site scripting. It is possible to initiate the attack remotely. Upgrading to version 1.13.0 is able to address this issue. The name of the patch is 34213c3f6ea22df427573076fb62744694f601d8. It is recommended to upgrade the affected component. The associated identifier of this vulnerability is VDB-216915.",
    "id": 12183
  },
  {
    "cve_id": "CVE-2020-36635",
    "code_before_change": "/**\r\n * The contents of this file are subject to the OpenMRS Public License\r\n * Version 1.0 (the \"License\"); you may not use this file except in\r\n * compliance with the License. You may obtain a copy of the License at\r\n * http://license.openmrs.org\r\n *\r\n * Software distributed under the License is distributed on an \"AS IS\"\r\n * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing rights and limitations\r\n * under the License.\r\n *\r\n * Copyright (C) OpenMRS, LLC.  All Rights Reserved.\r\n */\r\npackage org.openmrs.module.appointmentscheduling.validator;\r\n\r\nimport org.apache.commons.logging.Log;\r\nimport org.apache.commons.logging.LogFactory;\r\nimport org.openmrs.annotation.Handler;\r\nimport org.openmrs.module.appointmentscheduling.AppointmentType;\r\nimport org.openmrs.module.appointmentscheduling.api.AppointmentService;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.beans.factory.annotation.Qualifier;\r\nimport org.springframework.validation.Errors;\r\nimport org.springframework.validation.ValidationUtils;\r\nimport org.springframework.validation.Validator;\r\n\r\n/**\r\n * Validates attributes on the {@link AppointmentType} object.\r\n */\r\n@Handler(supports = { AppointmentType.class }, order = 50)\r\npublic class AppointmentTypeValidator implements Validator {\r\n\t\r\n\t/** Log for this class and subclasses */\r\n\tprotected final Log log = LogFactory.getLog(getClass());\r\n\t\r\n\t@Autowired\r\n\t@Qualifier(\"appointmentService\")\r\n\tprivate AppointmentService appointmentService;\r\n\t\r\n\t/**\r\n\t * Determines if the command object being submitted is a valid type\r\n\t * \r\n\t * @see org.springframework.validation.Validator#supports(java.lang.Class)\r\n\t */\r\n\t@SuppressWarnings(\"unchecked\")\r\n\tpublic boolean supports(Class c) {\r\n\t\treturn c.equals(AppointmentType.class);\r\n\t}\r\n\t\r\n\tpublic void setAppointmentService(AppointmentService appointmentService) {\r\n\t\tthis.appointmentService = appointmentService;\r\n\t}\r\n\t\r\n\tpublic AppointmentService getAppointmentService() {\r\n\t\treturn appointmentService;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Checks the form object for any inconsistencies/errors\r\n\t * \r\n\t * @see org.springframework.validation.Validator#validate(java.lang.Object,\r\n\t *      org.springframework.validation.Errors)\r\n\t * <strong>Should</strong> fail validation if name is null or empty or whitespace\r\n\t * <strong>Should</strong> pass validation if all required fields have proper values\r\n\t */\r\n\tpublic void validate(Object obj, Errors errors) {\r\n\t\tAppointmentType appointmentType = (AppointmentType) obj;\r\n\t\tif (appointmentType == null) {\r\n\t\t\terrors.rejectValue(\"appointmentType\", \"error.general\");\r\n\t\t} else {\r\n\t\t\tvalidateDurationField(errors, appointmentType);\r\n\t\t\tvalidateFieldName(errors, appointmentType);\r\n\t\t\tvalidateDescriptionField(errors, appointmentType.getDescription());\r\n\t\t}\r\n\t}\r\n\t\r\n\tprivate void validateFieldName(Errors errors, AppointmentType appointmentType) {\r\n\t\tValidationUtils.rejectIfEmptyOrWhitespace(errors, \"name\", \"error.name\");\r\n\t\tif (appointmentService.verifyDuplicatedAppointmentTypeName(appointmentType)) {\r\n\t\t\terrors.rejectValue(\"name\", \"appointmentscheduling.AppointmentType.nameDuplicated\");\r\n\t\t}\r\n\t\tif (verifyIfNameHasMoreThan100Characters(appointmentType.getName())) {\r\n\t\t\terrors.rejectValue(\"name\", \"appointmentscheduling.AppointmentType.longName.errorMessage\");\r\n\t\t}\r\n\t}\r\n\t\r\n\tprivate boolean verifyIfNameHasMoreThan100Characters(String appointmentName) {\r\n\t\tif (appointmentName != null) {\r\n\t\t\treturn (appointmentName.length() > 100) ? true : false;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\t\r\n\tprivate void validateDurationField(Errors errors, AppointmentType appointmentType) {\r\n\t\tValidationUtils.rejectIfEmpty(errors, \"duration\", \"appointmentscheduling.AppointmentType.durationEmpty\");\r\n\t\tif (appointmentType.getDuration() == null || appointmentType.getDuration() <= 0) {\r\n\t\t\terrors.rejectValue(\"duration\", \"appointmentscheduling.AppointmentType.duration.errorMessage\");\r\n\t\t}\r\n\t}\r\n\t\r\n\tprivate void validateDescriptionField(Errors errors, String description) {\r\n\t\tif (verifyIfDescriptionHasMoreThan1024Characters(description)) {\r\n\t\t\terrors.rejectValue(\"description\", \"appointmentscheduling.AppointmentType.description.errorMessage\");\r\n\t\t}\r\n\t}\r\n\t\r\n\tprivate boolean verifyIfDescriptionHasMoreThan1024Characters(String description) {\r\n\t\tif (description != null) {\r\n\t\t\treturn (description.length() > 1024) ? true : false;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\t\r\n}\r\n",
    "code_after_change": "{\r\n\t\r\n\t/** Log for this class and subclasses */\r\n\tprotected final Log log = LogFactory.getLog(getClass());\r\n\t\r\n\t@Autowired\r\n\t@Qualifier(\"appointmentService\")\r\n\tprivate AppointmentService appointmentService;\r\n\t\r\n\t/**\r\n\t * Determines if the command object being submitted is a valid type\r\n\t * \r\n\t * @see org.springframework.validation.Validator#supports(java.lang.Class)\r\n\t */\r\n\t@SuppressWarnings(\"unchecked\")\r\n\tpublic boolean supports(Class c) {\r\n\t\treturn c.equals(AppointmentType.class);\r\n\t}\r\n\t\r\n\tpublic void setAppointmentService(AppointmentService appointmentService) {\r\n\t\tthis.appointmentService = appointmentService;\r\n\t}\r\n\t\r\n\tpublic AppointmentService getAppointmentService() {\r\n\t\treturn appointmentService;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Checks the form object for any inconsistencies/errors\r\n\t * \r\n\t * @see org.springframework.validation.Validator#validate(java.lang.Object,\r\n\t *      org.springframework.validation.Errors)\r\n\t * <strong>Should</strong> fail validation if name is null or empty or whitespace\r\n\t * <strong>Should</strong> pass validation if all required fields have proper values\r\n\t */\r\n\tpublic void validate(Object obj, Errors errors) {\r\n\t\tAppointmentType appointmentType = (AppointmentType) obj;\r\n\t\tif (appointmentType == null) {\r\n\t\t\terrors.rejectValue(\"appointmentType\", \"error.general\");\r\n\t\t} else {\r\n\t\t\tvalidateDurationField(errors, appointmentType);\r\n\t\t\tvalidateFieldName(errors, appointmentType);\r\n\t\t\tvalidateDescriptionField(errors, appointmentType.getDescription());\r\n\t\t}\r\n\t}\r\n\t\r\n\tprivate void validateFieldName(Errors errors, AppointmentType appointmentType) {\r\n\t\tValidationUtils.rejectIfEmptyOrWhitespace(errors, \"name\", \"error.name\");\r\n\t\tif (appointmentService.verifyDuplicatedAppointmentTypeName(appointmentType)) {\r\n\t\t\terrors.rejectValue(\"name\", \"appointmentscheduling.AppointmentType.nameDuplicated\");\r\n\t\t}\r\n\t\tif (verifyIfNameHasMoreThan100Characters(appointmentType.getName())) {\r\n\t\t\terrors.rejectValue(\"name\", \"appointmentscheduling.AppointmentType.longName.errorMessage\");\r\n\t\t}\r\n\t\tif(verifyIfNameHasHtmlEncodableChars(appointmentType.getName())){\r\n\t\t\terrors.rejectValue(\"name\", \"appointmentscheduling.AppointmentType.unsafeName.errorMessage\");\r\n\t\t}\r\n\t}\r\n\t\r\n\tprivate boolean verifyIfNameHasMoreThan100Characters(String appointmentName) {\r\n\t\tif (appointmentName != null) {\r\n\t\t\treturn (appointmentName.length() > 100) ? true : false;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\t\r\n\tprivate void validateDurationField(Errors errors, AppointmentType appointmentType) {\r\n\t\tValidationUtils.rejectIfEmpty(errors, \"duration\", \"appointmentscheduling.AppointmentType.durationEmpty\");\r\n\t\tif (appointmentType.getDuration() == null || appointmentType.getDuration() <= 0) {\r\n\t\t\terrors.rejectValue(\"duration\", \"appointmentscheduling.AppointmentType.duration.errorMessage\");\r\n\t\t}\r\n\t}\r\n\t\r\n\tprivate void validateDescriptionField(Errors errors, String description) {\r\n\t\tif (verifyIfDescriptionHasMoreThan1024Characters(description)) {\r\n\t\t\terrors.rejectValue(\"description\", \"appointmentscheduling.AppointmentType.description.errorMessage\");\r\n\t\t}\r\n\t}\r\n\t\r\n\tprivate boolean verifyIfDescriptionHasMoreThan1024Characters(String description) {\r\n\t\tif (description != null) {\r\n\t\t\treturn (description.length() > 1024) ? true : false;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\tprivate boolean verifyIfNameHasHtmlEncodableChars(String appointmentName) {\r\n\t\tif(appointmentName != null){\r\n\t\t\treturn !WebUtil.escapeHTML(appointmentName).equals(appointmentName);\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\t\r\n}",
    "patch": "@@ -18,6 +18,7 @@\n import org.openmrs.annotation.Handler;\r\n import org.openmrs.module.appointmentscheduling.AppointmentType;\r\n import org.openmrs.module.appointmentscheduling.api.AppointmentService;\r\n+import org.openmrs.web.WebUtil;\r\n import org.springframework.beans.factory.annotation.Autowired;\r\n import org.springframework.beans.factory.annotation.Qualifier;\r\n import org.springframework.validation.Errors;\r\n@@ -82,6 +83,9 @@ private void validateFieldName(Errors errors, AppointmentType appointmentType) {\n \t\tif (verifyIfNameHasMoreThan100Characters(appointmentType.getName())) {\r\n \t\t\terrors.rejectValue(\"name\", \"appointmentscheduling.AppointmentType.longName.errorMessage\");\r\n \t\t}\r\n+\t\tif(verifyIfNameHasHtmlEncodableChars(appointmentType.getName())){\r\n+\t\t\terrors.rejectValue(\"name\", \"appointmentscheduling.AppointmentType.unsafeName.errorMessage\");\r\n+\t\t}\r\n \t}\r\n \t\r\n \tprivate boolean verifyIfNameHasMoreThan100Characters(String appointmentName) {\r\n@@ -110,5 +114,12 @@ private boolean verifyIfDescriptionHasMoreThan1024Characters(String description)\n \t\t}\r\n \t\treturn false;\r\n \t}\r\n+\r\n+\tprivate boolean verifyIfNameHasHtmlEncodableChars(String appointmentName) {\r\n+\t\tif(appointmentName != null){\r\n+\t\t\treturn !WebUtil.escapeHTML(appointmentName).equals(appointmentName);\r\n+\t\t}\r\n+\t\treturn false;\r\n+\t}\r\n \t\r\n }\r",
    "function_modified_lines": {
      "added": [
        "\r\n",
        "\tprivate boolean verifyIfNameHasHtmlEncodableChars(String appointmentName) {\r\n",
        "\t\tif(appointmentName != null){\r\n",
        "\t\t\treturn !WebUtil.escapeHTML(appointmentName).equals(appointmentName);\r\n",
        "\t\t}\r\n",
        "\t\treturn false;\r\n",
        "\t}\r\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-79"
    ],
    "cve_description": "A vulnerability was found in OpenMRS Appointment Scheduling Module up to 1.12.x. It has been classified as problematic. This affects the function validateFieldName of the file api/src/main/java/org/openmrs/module/appointmentscheduling/validator/AppointmentTypeValidator.java. The manipulation leads to cross site scripting. It is possible to initiate the attack remotely. Upgrading to version 1.13.0 is able to address this issue. The name of the patch is 34213c3f6ea22df427573076fb62744694f601d8. It is recommended to upgrade the affected component. The associated identifier of this vulnerability is VDB-216915.",
    "id": 12184
  },
  {
    "cve_id": "CVE-2022-4727",
    "code_before_change": "package org.openmrs.module.appointmentscheduling.api;\n\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.openmrs.Patient;\nimport org.openmrs.Provider;\nimport org.openmrs.api.APIException;\nimport org.openmrs.api.LocationService;\nimport org.openmrs.api.PatientService;\nimport org.openmrs.api.ProviderService;\nimport org.openmrs.module.appointmentscheduling.AppointmentRequest;\nimport org.openmrs.module.appointmentscheduling.AppointmentType;\nimport org.openmrs.module.appointmentscheduling.TimeFrameUnits;\nimport org.openmrs.test.BaseModuleContextSensitiveTest;\nimport org.openmrs.test.Verifies;\nimport org.springframework.beans.factory.annotation.Autowired;\n\nimport java.util.Date;\nimport java.util.List;\n\nimport static junit.framework.Assert.assertEquals;\nimport static junit.framework.Assert.assertNotNull;\nimport static junit.framework.Assert.assertNull;\nimport static junit.framework.Assert.assertTrue;\nimport static org.junit.Assert.assertFalse;\n\npublic class AppointmentRequestServiceTest extends BaseModuleContextSensitiveTest {\n\n    private static final int TOTAL_APPOINTMENT_REQUESTS = 3;\n\n    private static final int TOTAL_NON_VOIDED_APPOINTMENT_REQUESTS = 2;\n\n    @Autowired\n    private AppointmentService service;\n\n    @Autowired\n    LocationService locationService;\n\n    @Autowired\n    ProviderService providerService;\n\n    @Autowired\n    PatientService patientService;\n\n    @Before\n    public void before() throws Exception {\n        executeDataSet(\"standardAppointmentTestDataset.xml\");\n    }\n\n    @Test\n    @Verifies(value = \"should get all appointment requests\", method = \"getAllAppointmentRequests()\")\n    public void getAllAppointmentRequests_shouldGetAllAppointmentRequests() throws Exception {\n        List<AppointmentRequest> appointmentRequests = service.getAllAppointmentRequests();\n        assertEquals(TOTAL_APPOINTMENT_REQUESTS, appointmentRequests.size());\n    }\n\n    @Test\n    @Verifies(value = \"should get correct appointment request\", method = \"getAppointmentRequest(Integer)\")\n    public void getAppointmentRequest_shouldGetCorrectAppointmentRequest() throws Exception {\n\n        AppointmentRequest appointmentRequest = service.getAppointmentRequest(1);\n        assertNotNull(appointmentRequest);\n        assertEquals(\"862c94f0-3dae-11e4-916c-0800200c9a66\", appointmentRequest.getUuid());\n        assertEquals(providerService.getProvider(1), appointmentRequest.getProvider());\n        assertEquals(patientService.getPatient(2), appointmentRequest.getPatient());\n        assertEquals(service.getAppointmentType(1), appointmentRequest.getAppointmentType());\n        assertEquals(AppointmentRequest.AppointmentRequestStatus.PENDING, appointmentRequest.getStatus());\n        assertEquals(providerService.getProvider(1), appointmentRequest.getRequestedBy());\n        assertEquals(\"ASAP\", appointmentRequest.getNotes());\n        assertEquals(new Integer(0), appointmentRequest.getMinTimeFrameValue());\n        assertEquals(TimeFrameUnits.DAYS, appointmentRequest.getMinTimeFrameUnits());\n        assertEquals(new Integer(7), appointmentRequest.getMaxTimeFrameValue());\n        assertEquals(TimeFrameUnits.DAYS, appointmentRequest.getMaxTimeFrameUnits());\n\n        appointmentRequest = service.getAppointmentRequest(2);\n        assertNotNull(appointmentRequest);\n        assertEquals(\"862c94f1-3dae-11e4-916c-0800200c9a66\", appointmentRequest.getUuid());\n        assertEquals(providerService.getProvider(1), appointmentRequest.getProvider());\n        assertEquals(patientService.getPatient(6), appointmentRequest.getPatient());\n        assertEquals(service.getAppointmentType(2), appointmentRequest.getAppointmentType());\n        assertEquals(AppointmentRequest.AppointmentRequestStatus.FULFILLED, appointmentRequest.getStatus());\n        assertEquals(providerService.getProvider(2), appointmentRequest.getRequestedBy());\n        assertEquals(new Integer(6), appointmentRequest.getMinTimeFrameValue());\n        assertEquals(TimeFrameUnits.WEEKS, appointmentRequest.getMinTimeFrameUnits());\n        assertEquals(new Integer(2), appointmentRequest.getMaxTimeFrameValue());\n        assertEquals(TimeFrameUnits.MONTHS, appointmentRequest.getMaxTimeFrameUnits());\n        assertNull(appointmentRequest.getNotes());\n\n    }\n\n    @Test\n    @Verifies(value = \"should get correct appointment request\", method = \"getAppointmentRequestByUuid(String)\")\n    public void getAppointmentRequestByUuid_shouldGetCorrectAppointmentRequest() throws Exception {\n\n        AppointmentRequest appointmentRequest = service.getAppointmentRequestByUuid(\"862c94f2-3dae-11e4-916c-0800200c9a66\");\n        assertNotNull(appointmentRequest);\n        assertEquals(new Integer(3), appointmentRequest.getId());\n    }\n\n    @Test\n    @Verifies(value = \"should save new appointment request\", method = \"saveAppointmentRequest(AppointmentRequest)\")\n    public void saveAppointmentRequest_shouldSaveNewAppointmentRequest() throws Exception {\n\n        List<AppointmentRequest> appointmentRequests = service.getAllAppointmentRequests(true);\n        assertEquals(TOTAL_APPOINTMENT_REQUESTS, appointmentRequests.size());\n\n        AppointmentRequest appointmentRequest = new AppointmentRequest();\n        appointmentRequest.setPatient(patientService.getPatient(2));\n        appointmentRequest.setAppointmentType(service.getAppointmentType(1));\n        appointmentRequest.setProvider(providerService.getProvider(1));\n        appointmentRequest.setRequestedBy(providerService.getProvider(1));\n        appointmentRequest.setRequestedOn(new Date());\n        appointmentRequest.setMinTimeFrameValue(1);\n        appointmentRequest.setMinTimeFrameUnits(TimeFrameUnits.MONTHS);\n        appointmentRequest.setMaxTimeFrameValue(6);\n        appointmentRequest.setMaxTimeFrameUnits(TimeFrameUnits.MONTHS);\n\n        appointmentRequest.setNotes(\"test\");\n        appointmentRequest.setStatus(AppointmentRequest.AppointmentRequestStatus.PENDING);\n        service.saveAppointmentRequest(appointmentRequest);\n\n        //Should create a new appointment request row\n        assertEquals(TOTAL_APPOINTMENT_REQUESTS + 1, service.getAllAppointmentRequests().size());\n    }\n\n    @Test\n    @Verifies(value = \"should save new appointment request\", method = \"saveAppointmentRequest(AppointmentRequest)\")\n    public void saveAppointmentRequest_shouldSaveNewAppointmentRequestWithMinimalParameters() throws Exception {\n\n        List<AppointmentRequest> appointmentRequests = service.getAllAppointmentRequests(true);\n        assertEquals(TOTAL_APPOINTMENT_REQUESTS, appointmentRequests.size());\n\n        AppointmentRequest appointmentRequest = new AppointmentRequest();\n        appointmentRequest.setPatient(patientService.getPatient(2));\n        appointmentRequest.setAppointmentType(service.getAppointmentType(1));\n        appointmentRequest.setRequestedOn(new Date());\n        appointmentRequest.setStatus(AppointmentRequest.AppointmentRequestStatus.PENDING);\n        service.saveAppointmentRequest(appointmentRequest);\n\n        appointmentRequest = service.getAppointmentRequest(4);\n        assertEquals(AppointmentRequest.AppointmentRequestStatus.PENDING, appointmentRequest.getStatus());\n        assertNotNull(appointmentRequest);\n\n        //Should create a new appointment request row\n        assertEquals(TOTAL_APPOINTMENT_REQUESTS + 1, service.getAllAppointmentRequests().size());\n    }\n\n    @Test(expected = APIException.class)\n    @Verifies(value = \"should fail with validation exception\", method = \"saveAppointmentRequest(AppointmentRequest)\")\n    public void saveAppointmentRequest_shouldFailWithValidationException() throws Exception {\n\n        List<AppointmentRequest> appointmentRequests = service.getAllAppointmentRequests(true);\n        assertEquals(TOTAL_APPOINTMENT_REQUESTS, appointmentRequests.size());\n\n        AppointmentRequest appointmentRequest = new AppointmentRequest();\n        appointmentRequest.setPatient(patientService.getPatient(2));\n        service.saveAppointmentRequest(appointmentRequest);\n\n    }\n\n    @Test\n    @Verifies(value = \"should save edited appointment request\", method = \"saveAppointmentRequest(AppointmentRequest)\")\n    public void saveAppointmentRequest_shouldSaveEditedAppointmentRequest() throws Exception {\n\n        AppointmentRequest appointmentRequest = service.getAppointmentRequest(1);\n        appointmentRequest.setPatient(patientService.getPatient(6));\n\n        service.saveAppointmentRequest(appointmentRequest);\n\n        appointmentRequest = service.getAppointmentRequest(1);\n        assertEquals(patientService.getPatient(6), appointmentRequest.getPatient());\n\n        //Should not change the number of appointment types\n        assertEquals(TOTAL_APPOINTMENT_REQUESTS, service.getAllAppointmentRequests().size());\n    }\n\n    @Test\n    @Verifies(value = \"should void given appointment request\", method = \"voidAppointmentRequest(AppointmentRequest, String)\")\n    public void voidAppointmentRequest_shouldVoidGivenAppointmentRequest() throws Exception {\n\n        // sanity check\n        assertEquals(TOTAL_NON_VOIDED_APPOINTMENT_REQUESTS, service.getAllAppointmentRequests(false).size());\n\n        AppointmentRequest appointmentRequest = service.getAppointmentRequest(1);\n        service.voidAppointmentRequest(appointmentRequest, \"test\");\n\n        // one less on non-voided appointment request\n        assertEquals(TOTAL_NON_VOIDED_APPOINTMENT_REQUESTS - 1, service.getAllAppointmentRequests(false).size());\n\n        // still same total count, however,\n        assertEquals(TOTAL_APPOINTMENT_REQUESTS, service.getAllAppointmentRequests().size());\n\n        appointmentRequest = service.getAppointmentRequest(1);\n        assertTrue(appointmentRequest.isVoided());\n\n    }\n\n    @Test\n    @Verifies(value = \"should unvoid given appointment request\", method = \"unvoidAppointmentRequest(AppointmentRequest)\")\n    public void unvoidAppointmentRequest_shouldUnvoidGivenAppointmentRequest() throws Exception {\n\n        // sanity check\n        assertEquals(TOTAL_NON_VOIDED_APPOINTMENT_REQUESTS, service.getAllAppointmentRequests(false).size());\n\n        AppointmentRequest appointmentRequest = service.getAppointmentRequest(3);\n        service.unvoidAppointmentRequest(appointmentRequest);\n\n        // one more non-voided appointment request\n        assertEquals(TOTAL_NON_VOIDED_APPOINTMENT_REQUESTS + 1, service.getAllAppointmentRequests(false).size());\n\n        // still same total count, however,\n        assertEquals(TOTAL_APPOINTMENT_REQUESTS, service.getAllAppointmentRequests().size());\n\n        appointmentRequest = service.getAppointmentRequest(3);\n        assertFalse(appointmentRequest.isVoided());\n\n    }\n\n    @Test\n    @Verifies(value = \"should delete given appointment request\", method = \"purgeAppointmentRequest(AppointmentRequest)\")\n    public void purgeAppointmentRequest_shouldDeleteGivenAppointmentRequest() throws Exception {\n\n        AppointmentRequest appointmentRequest = service.getAppointmentRequest(3);\n        assertNotNull(appointmentRequest);\n\n        service.purgeAppointmentRequest(appointmentRequest);\n\n        appointmentRequest = service.getAppointmentRequest(3);\n        assertNull(appointmentRequest);\n\n        //Should decrease the number of appointment requestss by one.\n        assertEquals(TOTAL_APPOINTMENT_REQUESTS - 1, service.getAllAppointmentRequests().size());\n    }\n\n    @Test\n    public void getAppointmentRequestsByConstraints_shouldFetchAppointmentsByPatient() throws Exception {\n\n        // this patient has two requests, but one is voided, should be skipped\n        Patient patient = patientService.getPatient(6);\n\n        List<AppointmentRequest> requests = service.getAppointmentRequestsByConstraints(patient, null, null, null);\n\n        assertEquals(1, requests.size());\n        assertEquals(new Integer(2), requests.get(0).getId());\n\n    }\n\n    @Test\n    public void getAppointmentRequestsByConstraints_shouldFetchAppointmentsByType() throws Exception {\n\n        AppointmentType type = service.getAppointmentType(1);\n\n        List<AppointmentRequest> requests = service.getAppointmentRequestsByConstraints(null, type, null, null);\n\n        assertEquals(1, requests.size());\n        assertEquals(new Integer(1), requests.get(0).getId());\n\n    }\n\n    @Test\n    public void getAppointmentRequestsByConstraints_shouldFetchAppointmentsByProvider() throws Exception {\n\n        Provider provider = providerService.getProvider(1);\n\n        List<AppointmentRequest> requests = service.getAppointmentRequestsByConstraints(null, null, provider, null);\n\n        assertEquals(2, requests.size());\n        assertTrue((requests.get(0).getId() == 1 && requests.get(1).getId() == 2)\n                || (requests.get(0).getId() == 2 && requests.get(1).getId() == 1));\n\n    }\n\n    @Test\n    public void getAppointmentRequestsByConstraints_shouldFetchAppointmentsByStatus() throws Exception {\n\n        List<AppointmentRequest> requests = service.getAppointmentRequestsByConstraints(null, null, null, AppointmentRequest.AppointmentRequestStatus.PENDING);\n\n        assertEquals(1, requests.size());\n        assertEquals(new Integer(1), requests.get(0).getId());\n\n    }\n\n    @Test\n    public void getAppointmentRequestsByConstraints_shouldFetchAppointmentsByMultipleConstraints() throws Exception {\n\n        Patient patient = patientService.getPatient(2);\n        Provider provider = providerService.getProvider(1);\n        AppointmentType appointmentType = service.getAppointmentType(1);\n\n        List<AppointmentRequest> requests = service.getAppointmentRequestsByConstraints(patient, appointmentType, provider,\n                AppointmentRequest.AppointmentRequestStatus.PENDING);\n\n        assertEquals(1, requests.size());\n        assertEquals(new Integer(1), requests.get(0).getId());\n\n    }\n\n}\n",
    "code_after_change": "{\n\n    private static final int TOTAL_APPOINTMENT_REQUESTS = 3;\n\n    private static final int TOTAL_NON_VOIDED_APPOINTMENT_REQUESTS = 2;\n\n    @Autowired\n    private AppointmentService service;\n\n    @Autowired\n    LocationService locationService;\n\n    @Autowired\n    ProviderService providerService;\n\n    @Autowired\n    PatientService patientService;\n\n    @Before\n    public void before() throws Exception {\n        executeDataSet(\"standardAppointmentTestDataset.xml\");\n    }\n\n    @Test\n    @Verifies(value = \"should get all appointment requests\", method = \"getAllAppointmentRequests()\")\n    public void getAllAppointmentRequests_shouldGetAllAppointmentRequests() throws Exception {\n        List<AppointmentRequest> appointmentRequests = service.getAllAppointmentRequests();\n        assertEquals(TOTAL_APPOINTMENT_REQUESTS, appointmentRequests.size());\n    }\n\n    @Test\n    @Verifies(value = \"should get correct appointment request\", method = \"getAppointmentRequest(Integer)\")\n    public void getAppointmentRequest_shouldGetCorrectAppointmentRequest() throws Exception {\n\n        AppointmentRequest appointmentRequest = service.getAppointmentRequest(1);\n        assertNotNull(appointmentRequest);\n        assertEquals(\"862c94f0-3dae-11e4-916c-0800200c9a66\", appointmentRequest.getUuid());\n        assertEquals(providerService.getProvider(1), appointmentRequest.getProvider());\n        assertEquals(patientService.getPatient(2), appointmentRequest.getPatient());\n        assertEquals(service.getAppointmentType(1), appointmentRequest.getAppointmentType());\n        assertEquals(AppointmentRequest.AppointmentRequestStatus.PENDING, appointmentRequest.getStatus());\n        assertEquals(providerService.getProvider(1), appointmentRequest.getRequestedBy());\n        assertEquals(\"ASAP\", appointmentRequest.getNotes());\n        assertEquals(new Integer(0), appointmentRequest.getMinTimeFrameValue());\n        assertEquals(TimeFrameUnits.DAYS, appointmentRequest.getMinTimeFrameUnits());\n        assertEquals(new Integer(7), appointmentRequest.getMaxTimeFrameValue());\n        assertEquals(TimeFrameUnits.DAYS, appointmentRequest.getMaxTimeFrameUnits());\n\n        appointmentRequest = service.getAppointmentRequest(2);\n        assertNotNull(appointmentRequest);\n        assertEquals(\"862c94f1-3dae-11e4-916c-0800200c9a66\", appointmentRequest.getUuid());\n        assertEquals(providerService.getProvider(1), appointmentRequest.getProvider());\n        assertEquals(patientService.getPatient(6), appointmentRequest.getPatient());\n        assertEquals(service.getAppointmentType(2), appointmentRequest.getAppointmentType());\n        assertEquals(AppointmentRequest.AppointmentRequestStatus.FULFILLED, appointmentRequest.getStatus());\n        assertEquals(providerService.getProvider(2), appointmentRequest.getRequestedBy());\n        assertEquals(new Integer(6), appointmentRequest.getMinTimeFrameValue());\n        assertEquals(TimeFrameUnits.WEEKS, appointmentRequest.getMinTimeFrameUnits());\n        assertEquals(new Integer(2), appointmentRequest.getMaxTimeFrameValue());\n        assertEquals(TimeFrameUnits.MONTHS, appointmentRequest.getMaxTimeFrameUnits());\n    }\n\n    @Test\n    @Verifies(value = \"should get correct appointment request\", method = \"getAppointmentRequestByUuid(String)\")\n    public void getAppointmentRequestByUuid_shouldGetCorrectAppointmentRequest() throws Exception {\n\n        AppointmentRequest appointmentRequest = service.getAppointmentRequestByUuid(\"862c94f2-3dae-11e4-916c-0800200c9a66\");\n        assertNotNull(appointmentRequest);\n        assertEquals(new Integer(3), appointmentRequest.getId());\n    }\n\n    @Test\n    @Verifies(value = \"should save new appointment request\", method = \"saveAppointmentRequest(AppointmentRequest)\")\n    public void saveAppointmentRequest_shouldSaveNewAppointmentRequest() throws Exception {\n\n        List<AppointmentRequest> appointmentRequests = service.getAllAppointmentRequests(true);\n        assertEquals(TOTAL_APPOINTMENT_REQUESTS, appointmentRequests.size());\n\n        AppointmentRequest appointmentRequest = new AppointmentRequest();\n        appointmentRequest.setPatient(patientService.getPatient(2));\n        appointmentRequest.setAppointmentType(service.getAppointmentType(1));\n        appointmentRequest.setProvider(providerService.getProvider(1));\n        appointmentRequest.setRequestedBy(providerService.getProvider(1));\n        appointmentRequest.setRequestedOn(new Date());\n        appointmentRequest.setMinTimeFrameValue(1);\n        appointmentRequest.setMinTimeFrameUnits(TimeFrameUnits.MONTHS);\n        appointmentRequest.setMaxTimeFrameValue(6);\n        appointmentRequest.setMaxTimeFrameUnits(TimeFrameUnits.MONTHS);\n\n        appointmentRequest.setNotes(\"test\");\n        appointmentRequest.setStatus(AppointmentRequest.AppointmentRequestStatus.PENDING);\n        service.saveAppointmentRequest(appointmentRequest);\n\n        //Should create a new appointment request row\n        assertEquals(TOTAL_APPOINTMENT_REQUESTS + 1, service.getAllAppointmentRequests().size());\n    }\n\n    @Test\n    @Verifies(value = \"should save new appointment request\", method = \"saveAppointmentRequest(AppointmentRequest)\")\n    public void saveAppointmentRequest_shouldSaveNewAppointmentRequestWithMinimalParameters() throws Exception {\n\n        List<AppointmentRequest> appointmentRequests = service.getAllAppointmentRequests(true);\n        assertEquals(TOTAL_APPOINTMENT_REQUESTS, appointmentRequests.size());\n\n        AppointmentRequest appointmentRequest = new AppointmentRequest();\n        appointmentRequest.setPatient(patientService.getPatient(2));\n        appointmentRequest.setAppointmentType(service.getAppointmentType(1));\n        appointmentRequest.setRequestedOn(new Date());\n        appointmentRequest.setStatus(AppointmentRequest.AppointmentRequestStatus.PENDING);\n        service.saveAppointmentRequest(appointmentRequest);\n\n        appointmentRequest = service.getAppointmentRequest(4);\n        assertEquals(AppointmentRequest.AppointmentRequestStatus.PENDING, appointmentRequest.getStatus());\n        assertNotNull(appointmentRequest);\n\n        //Should create a new appointment request row\n        assertEquals(TOTAL_APPOINTMENT_REQUESTS + 1, service.getAllAppointmentRequests().size());\n    }\n\n    @Test(expected = APIException.class)\n    @Verifies(value = \"should fail with validation exception\", method = \"saveAppointmentRequest(AppointmentRequest)\")\n    public void saveAppointmentRequest_shouldFailWithValidationException() throws Exception {\n\n        List<AppointmentRequest> appointmentRequests = service.getAllAppointmentRequests(true);\n        assertEquals(TOTAL_APPOINTMENT_REQUESTS, appointmentRequests.size());\n\n        AppointmentRequest appointmentRequest = new AppointmentRequest();\n        appointmentRequest.setPatient(patientService.getPatient(2));\n        service.saveAppointmentRequest(appointmentRequest);\n\n    }\n\n    @Test\n    @Verifies(value = \"should save edited appointment request\", method = \"saveAppointmentRequest(AppointmentRequest)\")\n    public void saveAppointmentRequest_shouldSaveEditedAppointmentRequest() throws Exception {\n\n        AppointmentRequest appointmentRequest = service.getAppointmentRequest(1);\n        appointmentRequest.setPatient(patientService.getPatient(6));\n\n        service.saveAppointmentRequest(appointmentRequest);\n\n        appointmentRequest = service.getAppointmentRequest(1);\n        assertEquals(patientService.getPatient(6), appointmentRequest.getPatient());\n\n        //Should not change the number of appointment types\n        assertEquals(TOTAL_APPOINTMENT_REQUESTS, service.getAllAppointmentRequests().size());\n    }\n\n    @Test\n    @Verifies(value = \"should void given appointment request\", method = \"voidAppointmentRequest(AppointmentRequest, String)\")\n    public void voidAppointmentRequest_shouldVoidGivenAppointmentRequest() throws Exception {\n\n        // sanity check\n        assertEquals(TOTAL_NON_VOIDED_APPOINTMENT_REQUESTS, service.getAllAppointmentRequests(false).size());\n\n        AppointmentRequest appointmentRequest = service.getAppointmentRequest(1);\n        service.voidAppointmentRequest(appointmentRequest, \"test\");\n\n        // one less on non-voided appointment request\n        assertEquals(TOTAL_NON_VOIDED_APPOINTMENT_REQUESTS - 1, service.getAllAppointmentRequests(false).size());\n\n        // still same total count, however,\n        assertEquals(TOTAL_APPOINTMENT_REQUESTS, service.getAllAppointmentRequests().size());\n\n        appointmentRequest = service.getAppointmentRequest(1);\n        assertTrue(appointmentRequest.isVoided());\n\n    }\n\n    @Test\n    @Verifies(value = \"should unvoid given appointment request\", method = \"unvoidAppointmentRequest(AppointmentRequest)\")\n    public void unvoidAppointmentRequest_shouldUnvoidGivenAppointmentRequest() throws Exception {\n\n        // sanity check\n        assertEquals(TOTAL_NON_VOIDED_APPOINTMENT_REQUESTS, service.getAllAppointmentRequests(false).size());\n\n        AppointmentRequest appointmentRequest = service.getAppointmentRequest(3);\n        service.unvoidAppointmentRequest(appointmentRequest);\n\n        // one more non-voided appointment request\n        assertEquals(TOTAL_NON_VOIDED_APPOINTMENT_REQUESTS + 1, service.getAllAppointmentRequests(false).size());\n\n        // still same total count, however,\n        assertEquals(TOTAL_APPOINTMENT_REQUESTS, service.getAllAppointmentRequests().size());\n\n        appointmentRequest = service.getAppointmentRequest(3);\n        assertFalse(appointmentRequest.isVoided());\n\n    }\n\n    @Test\n    @Verifies(value = \"should delete given appointment request\", method = \"purgeAppointmentRequest(AppointmentRequest)\")\n    public void purgeAppointmentRequest_shouldDeleteGivenAppointmentRequest() throws Exception {\n\n        AppointmentRequest appointmentRequest = service.getAppointmentRequest(3);\n        assertNotNull(appointmentRequest);\n\n        service.purgeAppointmentRequest(appointmentRequest);\n\n        appointmentRequest = service.getAppointmentRequest(3);\n        assertNull(appointmentRequest);\n\n        //Should decrease the number of appointment requestss by one.\n        assertEquals(TOTAL_APPOINTMENT_REQUESTS - 1, service.getAllAppointmentRequests().size());\n    }\n\n    @Test\n    public void getAppointmentRequestsByConstraints_shouldFetchAppointmentsByPatient() throws Exception {\n\n        // this patient has two requests, but one is voided, should be skipped\n        Patient patient = patientService.getPatient(6);\n\n        List<AppointmentRequest> requests = service.getAppointmentRequestsByConstraints(patient, null, null, null);\n\n        assertEquals(1, requests.size());\n        assertEquals(new Integer(2), requests.get(0).getId());\n\n    }\n\n    @Test\n    public void getAppointmentRequestsByConstraints_shouldFetchAppointmentsByType() throws Exception {\n\n        AppointmentType type = service.getAppointmentType(1);\n\n        List<AppointmentRequest> requests = service.getAppointmentRequestsByConstraints(null, type, null, null);\n\n        assertEquals(1, requests.size());\n        assertEquals(new Integer(1), requests.get(0).getId());\n\n    }\n\n    @Test\n    public void getAppointmentRequestsByConstraints_shouldFetchAppointmentsByProvider() throws Exception {\n\n        Provider provider = providerService.getProvider(1);\n\n        List<AppointmentRequest> requests = service.getAppointmentRequestsByConstraints(null, null, provider, null);\n\n        assertEquals(2, requests.size());\n        assertTrue((requests.get(0).getId() == 1 && requests.get(1).getId() == 2)\n                || (requests.get(0).getId() == 2 && requests.get(1).getId() == 1));\n\n    }\n\n    @Test\n    public void getAppointmentRequestsByConstraints_shouldFetchAppointmentsByStatus() throws Exception {\n\n        List<AppointmentRequest> requests = service.getAppointmentRequestsByConstraints(null, null, null, AppointmentRequest.AppointmentRequestStatus.PENDING);\n\n        assertEquals(1, requests.size());\n        assertEquals(new Integer(1), requests.get(0).getId());\n\n    }\n\n    @Test\n    public void getAppointmentRequestsByConstraints_shouldFetchAppointmentsByMultipleConstraints() throws Exception {\n\n        Patient patient = patientService.getPatient(2);\n        Provider provider = providerService.getProvider(1);\n        AppointmentType appointmentType = service.getAppointmentType(1);\n\n        List<AppointmentRequest> requests = service.getAppointmentRequestsByConstraints(patient, appointmentType, provider,\n                AppointmentRequest.AppointmentRequestStatus.PENDING);\n\n        assertEquals(1, requests.size());\n        assertEquals(new Integer(1), requests.get(0).getId());\n\n    }\n\n    @Test\n    @Verifies(value=\"The text for notes should be sanitized\", method=\"sanitizeNotes(String)\")\n    public void sanitizeAppointmentRequest_shouldSanitizeTheTextInputForAppointmentNotes() throws Exception {\n        final String note = \"<iframe>\";\n        final String sanitizedNote = \"&lt;iframe&gt;\";\n        AppointmentRequest appointmentRequest = new AppointmentRequest();\n        appointmentRequest.setNotes(note);\n        assertEquals(appointmentRequest.getNotes(), sanitizedNote);\n    }\n\n}",
    "patch": "@@ -84,8 +84,6 @@ public void getAppointmentRequest_shouldGetCorrectAppointmentRequest() throws Ex\n         assertEquals(TimeFrameUnits.WEEKS, appointmentRequest.getMinTimeFrameUnits());\n         assertEquals(new Integer(2), appointmentRequest.getMaxTimeFrameValue());\n         assertEquals(TimeFrameUnits.MONTHS, appointmentRequest.getMaxTimeFrameUnits());\n-        assertNull(appointmentRequest.getNotes());\n-\n     }\n \n     @Test\n@@ -295,4 +293,14 @@ public void getAppointmentRequestsByConstraints_shouldFetchAppointmentsByMultipl\n \n     }\n \n+    @Test\n+    @Verifies(value=\"The text for notes should be sanitized\", method=\"sanitizeNotes(String)\")\n+    public void sanitizeAppointmentRequest_shouldSanitizeTheTextInputForAppointmentNotes() throws Exception {\n+        final String note = \"<iframe>\";\n+        final String sanitizedNote = \"&lt;iframe&gt;\";\n+        AppointmentRequest appointmentRequest = new AppointmentRequest();\n+        appointmentRequest.setNotes(note);\n+        assertEquals(appointmentRequest.getNotes(), sanitizedNote);\n+    }\n+\n }",
    "function_modified_lines": {
      "added": [
        "    @Test\n",
        "    @Verifies(value=\"The text for notes should be sanitized\", method=\"sanitizeNotes(String)\")\n",
        "    public void sanitizeAppointmentRequest_shouldSanitizeTheTextInputForAppointmentNotes() throws Exception {\n",
        "        final String note = \"<iframe>\";\n",
        "        final String sanitizedNote = \"&lt;iframe&gt;\";\n",
        "        AppointmentRequest appointmentRequest = new AppointmentRequest();\n",
        "        appointmentRequest.setNotes(note);\n",
        "        assertEquals(appointmentRequest.getNotes(), sanitizedNote);\n",
        "    }\n",
        "\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-79"
    ],
    "cve_description": "A vulnerability, which was classified as problematic, was found in OpenMRS Appointment Scheduling Module up to 1.16.x. This affects the function getNotes of the file api/src/main/java/org/openmrs/module/appointmentscheduling/AppointmentRequest.java of the component Notes Handler. The manipulation of the argument notes leads to cross site scripting. It is possible to initiate the attack remotely. Upgrading to version 1.17.0 is able to address this issue. The name of the patch is 2ccbe39c020809765de41eeb8ee4c70b5ec49cc8. It is recommended to upgrade the affected component. The identifier VDB-216741 was assigned to this vulnerability.",
    "id": 12185
  },
  {
    "cve_id": "CVE-2020-36636",
    "code_before_change": "\t\t\tObject personAttributeTypeUuid = ext.getExtensionParams().get(\"uuid\");\n\t\t\tPerson person = account.getPerson();\n\t\t\tif (person != null && type != null && personAttributeTypeUuid != null &&\n\t\t\t\t\ttype.toString().equals(\"personAttribute\")) {\n\t\t\t\tString formFieldName = ext.getExtensionParams().get(\"formFieldName\").toString();\n\t\t\t\tPersonAttribute personAttribute = person.getAttribute(Context.getPersonService()\n\t\t\t\t\t\t.getPersonAttributeTypeByUuid(personAttributeTypeUuid.toString()));\n\t\t\t\tif(personAttribute != null) {\n\t\t\t\t\tString personAttributeUuid = personAttribute.getUuid();\n\t\t\t\t\tSimpleObject personAttributeInfo = new SimpleObject();\n\t\t\t\t\tpersonAttributeInfo.put(\"formFieldName\", formFieldName);\n\t\t\t\t\tpersonAttributeInfo.put(\"personAttributeUuid\", personAttributeUuid);\n\t\t\t\t\tso.put(\"personAttributeInfo\", personAttributeInfo);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmodel.addAttribute(\"customPersonAttributeJson\", mapper.writeValueAsString(so));\n\n\t\tmodel.addAttribute(\"messages\", mapper.writeValueAsString(so));\n\t}\n\t\n\tprivate void sendErrorMessage(Errors errors, PageModel model, MessageSourceService mss, HttpServletRequest request) {\n\t\tmodel.addAttribute(\"errors\", errors);\n\t\tStringBuffer errorMessage = new StringBuffer(mss.getMessage(\"error.failed.validation\"));\n\t\terrorMessage.append(\"<ul>\");\n\t\tfor (ObjectError error : errors.getAllErrors()) {\n\t\t\terrorMessage.append(\"<li>\");\n\t\t\terrorMessage.append(mss.getMessage(error.getCode(), error.getArguments(), error.getDefaultMessage(), null));\n\t\t\terrorMessage.append(\"</li>\");\n\t\t}\n\t\terrorMessage.append(\"</ul>\");\n\t\trequest.getSession().setAttribute(UiCommonsConstants.SESSION_ATTRIBUTE_ERROR_MESSAGE, errorMessage.toString());\n\t}\n\t\n\tprivate void setJsonFormData(PageModel model, Account account, OtherAccountData otherAccountData) throws IOException {\n\t\t\n\t\tObjectMapper mapper = new ObjectMapper();\n\t\tSimpleObject simplePerson = new SimpleObject();\n\t\tsimplePerson.put(\"familyName\", account.getFamilyName());\n\t\tsimplePerson.put(\"givenName\", account.getGivenName());\n\t\tsimplePerson.put(\"gender\", account.getGender() != null ? account.getGender() : \"\");\n\t\tmodel.addAttribute(\"personJson\", mapper.writeValueAsString(simplePerson));\n\t\t\n\t\tSimpleObject simpleUser = new SimpleObject();\n\t\tSimpleObject simpleProvider = new SimpleObject();\n\t\tif (otherAccountData != null) {\n\t\t\tif (otherAccountData.getAddUserAccount()) {\n\t\t\t\tUser u = account.getUserAccounts().get(0);\n\t\t\t\tsimpleUser.put(\"username\", u.getUsername());\n\t\t\t\tsimpleUser.put(\"privilegeLevel\", account.getPrivilegeLevel(u).getUuid());\n\t\t\t\tSimpleObject userProperties = new SimpleObject();\n\t\t\t\tuserProperties\n\t\t\t\t        .put(OpenmrsConstants.USER_PROPERTY_CHANGE_PASSWORD, otherAccountData.getForceChangePassword());\n\t\t\t\tsimpleUser.put(\"userProperties\", userProperties);\n\t\t\t\tSimpleObject simpleUserCapabilities = new SimpleObject();\n\t\t\t\tfor (Role cap : account.getCapabilities(u)) {\n\t\t\t\t\tsimpleUserCapabilities.put(cap.getUuid(), true);\n\t\t\t\t}\n\t\t\t\tsimpleUser.put(\"capabilities\", simpleUserCapabilities);\n\t\t\t}\n\t\t\t\n\t\t\tif (otherAccountData.getAddProviderAccount()) {\n\t\t\t\tProvider prov = (Provider) account.getProviderAccounts().get(0);\n\t\t\t\tsimpleProvider.put(\"identifier\", prov.getIdentifier());\n\t\t\t\tsimpleProvider.put(\"providerRole\", prov.getProviderRole().getUuid());\n\t\t\t}\n\t\t}\n\t\t\n\t\tmodel.addAttribute(\"userJson\", mapper.writeValueAsString(simpleUser));\n\t\tmodel.addAttribute(\"providerJson\", mapper.writeValueAsString(simpleProvider));\n\t}\n\t\n}",
    "code_after_change": "\t\t\tObject personAttributeTypeUuid = ext.getExtensionParams().get(\"uuid\");\n\t\t\tPerson person = account.getPerson();\n\t\t\tif (person != null && type != null && personAttributeTypeUuid != null &&\n\t\t\t\t\ttype.toString().equals(\"personAttribute\")) {\n\t\t\t\tString formFieldName = ext.getExtensionParams().get(\"formFieldName\").toString();\n\t\t\t\tPersonAttribute personAttribute = person.getAttribute(Context.getPersonService()\n\t\t\t\t\t\t.getPersonAttributeTypeByUuid(personAttributeTypeUuid.toString()));\n\t\t\t\tif(personAttribute != null) {\n\t\t\t\t\tString personAttributeUuid = personAttribute.getUuid();\n\t\t\t\t\tSimpleObject personAttributeInfo = new SimpleObject();\n\t\t\t\t\tpersonAttributeInfo.put(\"formFieldName\", formFieldName);\n\t\t\t\t\tpersonAttributeInfo.put(\"personAttributeUuid\", personAttributeUuid);\n\t\t\t\t\tso.put(\"personAttributeInfo\", personAttributeInfo);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmodel.addAttribute(\"customPersonAttributeJson\", mapper.writeValueAsString(so));\n\n\t\tmodel.addAttribute(\"messages\", mapper.writeValueAsString(so));\n\t}\n\t\n\tprivate void sendErrorMessage(Errors errors, PageModel model, MessageSourceService mss, HttpServletRequest request) {\n\t\tmodel.addAttribute(\"errors\", errors);\n\t\tStringBuffer errorMessage = new StringBuffer(mss.getMessage(\"error.failed.validation\"));\n\t\terrorMessage.append(\"<ul>\");\n\t\tfor (ObjectError error : errors.getAllErrors()) {\n\t\t\terrorMessage.append(\"<li>\");\n\t\t\terrorMessage.append(mss.getMessage(error.getCode(), error.getArguments(), error.getDefaultMessage(), null));\n\t\t\terrorMessage.append(\"</li>\");\n\t\t}\n\t\terrorMessage.append(\"</ul>\");\n\t\trequest.getSession().setAttribute(UiCommonsConstants.SESSION_ATTRIBUTE_ERROR_MESSAGE, errorMessage.toString());\n\t}\n\t\n\tprivate void setJsonFormData(PageModel model, Account account, OtherAccountData otherAccountData, UiUtils uu) throws IOException {\n\t\t\n\t\tObjectMapper mapper = new ObjectMapper();\n\t\tSimpleObject simplePerson = new SimpleObject();\n\t\tsimplePerson.put(\"familyName\", uu.encodeHtml(account.getFamilyName()));\n\t\tsimplePerson.put(\"givenName\", uu.encodeHtml(account.getGivenName()));\n\t\tsimplePerson.put(\"gender\", uu.encodeHtml(account.getGender()) != null ? uu.encodeHtml(account.getGender()) : \"\");\n\t\tmodel.addAttribute(\"personJson\", mapper.writeValueAsString(simplePerson));\n\t\t\n\t\tSimpleObject simpleUser = new SimpleObject();\n\t\tSimpleObject simpleProvider = new SimpleObject();\n\t\tif (otherAccountData != null) {\n\t\t\tif (otherAccountData.getAddUserAccount()) {\n\t\t\t\tUser u = account.getUserAccounts().get(0);\n\t\t\t\tsimpleUser.put(\"username\", uu.encodeHtml(u.getUsername()));\n\t\t\t\tsimpleUser.put(\"privilegeLevel\", account.getPrivilegeLevel(u).getUuid());\n\t\t\t\tSimpleObject userProperties = new SimpleObject();\n\t\t\t\tuserProperties\n\t\t\t\t        .put(OpenmrsConstants.USER_PROPERTY_CHANGE_PASSWORD, otherAccountData.getForceChangePassword());\n\t\t\t\tsimpleUser.put(\"userProperties\", userProperties);\n\t\t\t\tSimpleObject simpleUserCapabilities = new SimpleObject();\n\t\t\t\tfor (Role cap : account.getCapabilities(u)) {\n\t\t\t\t\tsimpleUserCapabilities.put(cap.getUuid(), true);\n\t\t\t\t}\n\t\t\t\tsimpleUser.put(\"capabilities\", simpleUserCapabilities);\n\t\t\t}\n\t\t\t\n\t\t\tif (otherAccountData.getAddProviderAccount()) {\n\t\t\t\tProvider prov = (Provider) account.getProviderAccounts().get(0);\n\t\t\t\tsimpleProvider.put(\"identifier\", prov.getIdentifier());\n\t\t\t\tsimpleProvider.put(\"providerRole\", prov.getProviderRole().getUuid());\n\t\t\t}\n\t\t}\n\t\t\n\t\tmodel.addAttribute(\"userJson\", mapper.writeValueAsString(simpleUser));\n\t\tmodel.addAttribute(\"providerJson\", mapper.writeValueAsString(simpleProvider));\n\t}\n\t\n}",
    "patch": "@@ -95,7 +95,7 @@ public void get(PageModel model, @MethodParam(\"getAccount\") Account account,\n \t\t\n \t\tsetModelAttributes(model, account, null, accountService, administrationService, providerManagementService, uu, appFrameworkService);\n \t\tif (account.getPerson().getPersonId() == null) {\n-\t\t\tsetJsonFormData(model, account, null);\n+\t\t\tsetJsonFormData(model, account, null, uu);\n \t\t}\n \t}\n \t\n@@ -222,7 +222,7 @@ public String post(PageModel model, @MethodParam(\"getAccount\") @BindParams Accou\n \t\tsendErrorMessage(errors, model, messageSourceService, request);\n \t\t\n \t\tif (account.getPerson().getPersonId() == null) {\n-\t\t\tsetJsonFormData(model, account, otherAccountData);\n+\t\t\tsetJsonFormData(model, account, otherAccountData, uu);\n \t\t}\n \t\t\n \t\treturn \"systemadmin/accounts/account\";\n@@ -410,21 +410,21 @@ private void sendErrorMessage(Errors errors, PageModel model, MessageSourceServi\n \t\trequest.getSession().setAttribute(UiCommonsConstants.SESSION_ATTRIBUTE_ERROR_MESSAGE, errorMessage.toString());\n \t}\n \t\n-\tprivate void setJsonFormData(PageModel model, Account account, OtherAccountData otherAccountData) throws IOException {\n+\tprivate void setJsonFormData(PageModel model, Account account, OtherAccountData otherAccountData, UiUtils uu) throws IOException {\n \t\t\n \t\tObjectMapper mapper = new ObjectMapper();\n \t\tSimpleObject simplePerson = new SimpleObject();\n-\t\tsimplePerson.put(\"familyName\", account.getFamilyName());\n-\t\tsimplePerson.put(\"givenName\", account.getGivenName());\n-\t\tsimplePerson.put(\"gender\", account.getGender() != null ? account.getGender() : \"\");\n+\t\tsimplePerson.put(\"familyName\", uu.encodeHtml(account.getFamilyName()));\n+\t\tsimplePerson.put(\"givenName\", uu.encodeHtml(account.getGivenName()));\n+\t\tsimplePerson.put(\"gender\", uu.encodeHtml(account.getGender()) != null ? uu.encodeHtml(account.getGender()) : \"\");\n \t\tmodel.addAttribute(\"personJson\", mapper.writeValueAsString(simplePerson));\n \t\t\n \t\tSimpleObject simpleUser = new SimpleObject();\n \t\tSimpleObject simpleProvider = new SimpleObject();\n \t\tif (otherAccountData != null) {\n \t\t\tif (otherAccountData.getAddUserAccount()) {\n \t\t\t\tUser u = account.getUserAccounts().get(0);\n-\t\t\t\tsimpleUser.put(\"username\", u.getUsername());\n+\t\t\t\tsimpleUser.put(\"username\", uu.encodeHtml(u.getUsername()));\n \t\t\t\tsimpleUser.put(\"privilegeLevel\", account.getPrivilegeLevel(u).getUuid());\n \t\t\t\tSimpleObject userProperties = new SimpleObject();\n \t\t\t\tuserProperties",
    "function_modified_lines": {
      "added": [
        "\tprivate void setJsonFormData(PageModel model, Account account, OtherAccountData otherAccountData, UiUtils uu) throws IOException {\n",
        "\t\tsimplePerson.put(\"familyName\", uu.encodeHtml(account.getFamilyName()));\n",
        "\t\tsimplePerson.put(\"givenName\", uu.encodeHtml(account.getGivenName()));\n",
        "\t\tsimplePerson.put(\"gender\", uu.encodeHtml(account.getGender()) != null ? uu.encodeHtml(account.getGender()) : \"\");\n",
        "\t\t\t\tsimpleUser.put(\"username\", uu.encodeHtml(u.getUsername()));\n"
      ],
      "deleted": [
        "\tprivate void setJsonFormData(PageModel model, Account account, OtherAccountData otherAccountData) throws IOException {\n",
        "\t\tsimplePerson.put(\"familyName\", account.getFamilyName());\n",
        "\t\tsimplePerson.put(\"givenName\", account.getGivenName());\n",
        "\t\tsimplePerson.put(\"gender\", account.getGender() != null ? account.getGender() : \"\");\n",
        "\t\t\t\tsimpleUser.put(\"username\", u.getUsername());\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-79"
    ],
    "cve_description": "A vulnerability classified as problematic has been found in OpenMRS Admin UI Module up to 1.4.x. Affected is the function sendErrorMessage of the file omod/src/main/java/org/openmrs/module/adminui/page/controller/systemadmin/accounts/AccountPageController.java of the component Account Setup Handler. The manipulation leads to cross site scripting. It is possible to launch the attack remotely. Upgrading to version 1.5.0 is able to address this issue. The name of the patch is 702fbfdac7c4418f23bb5f6452482b4a88020061. It is recommended to upgrade the affected component. VDB-216918 is the identifier assigned to this vulnerability.",
    "id": 12186
  },
  {
    "cve_id": "CVE-2023-29206",
    "code_before_change": "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.plugin.skinx;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.xwiki.bridge.event.DocumentCreatedEvent;\nimport org.xwiki.bridge.event.DocumentDeletedEvent;\nimport org.xwiki.bridge.event.DocumentUpdatedEvent;\nimport org.xwiki.bridge.event.WikiDeletedEvent;\nimport org.xwiki.model.EntityType;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.EntityReferenceResolver;\nimport org.xwiki.model.reference.EntityReferenceSerializer;\nimport org.xwiki.observation.EventListener;\nimport org.xwiki.observation.ObservationManager;\nimport org.xwiki.observation.event.Event;\nimport org.xwiki.security.authorization.AuthorizationManager;\nimport org.xwiki.security.authorization.ContextualAuthorizationManager;\nimport org.xwiki.security.authorization.Right;\n\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.objects.BaseObject;\nimport com.xpn.xwiki.objects.classes.BaseClass;\nimport com.xpn.xwiki.web.Utils;\n\n/**\n * Abstract SX plugin for wiki-document-based extensions (Extensions written as object of a XWiki Extension class).\n * Provides a generic method to initialize the XWiki class upon plugin initialization if needed. Provide a notification\n * mechanism for extensions marked as \"use-always\".\n * \n * @version $Id$\n * @since 1.4\n * @see JsSkinExtensionPlugin\n * @see CssSkinExtensionPlugin\n */\npublic abstract class AbstractDocumentSkinExtensionPlugin extends AbstractSkinExtensionPlugin implements EventListener\n{\n    /**\n     * Log helper for logging messages in this class.\n     */\n    protected static final Logger LOGGER = LoggerFactory.getLogger(AbstractDocumentSkinExtensionPlugin.class);\n\n    /**\n     * The name of the field that indicates whether an extension should always be used, or only when explicitly pulled.\n     */\n    private static final String USE_FIELDNAME = \"use\";\n",
    "code_after_change": "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.plugin.skinx;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.exception.ExceptionUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.xwiki.bridge.event.DocumentCreatedEvent;\nimport org.xwiki.bridge.event.DocumentDeletedEvent;\nimport org.xwiki.bridge.event.DocumentUpdatedEvent;\nimport org.xwiki.bridge.event.WikiDeletedEvent;\nimport org.xwiki.model.EntityType;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.model.reference.EntityReferenceResolver;\nimport org.xwiki.model.reference.EntityReferenceSerializer;\nimport org.xwiki.observation.EventListener;\nimport org.xwiki.observation.ObservationManager;\nimport org.xwiki.observation.event.Event;\nimport org.xwiki.security.authorization.AuthorizationManager;\nimport org.xwiki.security.authorization.ContextualAuthorizationManager;\nimport org.xwiki.security.authorization.Right;\n\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.objects.BaseObject;\nimport com.xpn.xwiki.objects.classes.BaseClass;\nimport com.xpn.xwiki.web.Utils;\n\n/**\n * Abstract SX plugin for wiki-document-based extensions (Extensions written as object of a XWiki Extension class).\n * Provides a generic method to initialize the XWiki class upon plugin initialization if needed. Provide a notification\n * mechanism for extensions marked as \"use-always\".\n * \n * @version $Id$\n * @since 1.4\n * @see JsSkinExtensionPlugin\n * @see CssSkinExtensionPlugin\n */\npublic abstract class AbstractDocumentSkinExtensionPlugin extends AbstractSkinExtensionPlugin implements EventListener\n{\n    /**\n     * Log helper for logging messages in this class.\n     */\n    protected static final Logger LOGGER = LoggerFactory.getLogger(AbstractDocumentSkinExtensionPlugin.class);\n\n    /**\n     * The name of the field that indicates whether an extension should always be used, or only when explicitly pulled.\n     */",
    "patch": "@@ -29,6 +29,7 @@\n import java.util.Set;\n \n import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.exception.ExceptionUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.xwiki.bridge.event.DocumentCreatedEvent;\n@@ -37,6 +38,7 @@\n import org.xwiki.bridge.event.WikiDeletedEvent;\n import org.xwiki.model.EntityType;\n import org.xwiki.model.reference.DocumentReference;\n+import org.xwiki.model.reference.DocumentReferenceResolver;\n import org.xwiki.model.reference.EntityReferenceResolver;\n import org.xwiki.model.reference.EntityReferenceSerializer;\n import org.xwiki.observation.EventListener;\n@@ -85,6 +87,10 @@ public abstract class AbstractDocumentSkinExtensionPlugin extends AbstractSkinEx\n      */\n     private final List<Event> events = new ArrayList<>(3);\n \n+    private AuthorizationManager authorizationManager;\n+    private DocumentReferenceResolver<String> stringDocumentReferenceResolver;\n+    private EntityReferenceResolver<String> currentEntityReferenceResolver;\n+\n     /**\n      * XWiki plugin constructor.\n      * \n@@ -174,7 +180,7 @@ public void virtualInit(XWikiContext context)\n     @Override\n     public Set<String> getAlwaysUsedExtensions(XWikiContext context)\n     {\n-        EntityReferenceSerializer<String> serializer = Utils.getComponent(EntityReferenceSerializer.TYPE_STRING);\n+        EntityReferenceSerializer<String> serializer = getDefaultEntityReferenceSerializer();\n         Set<DocumentReference> references = getAlwaysUsedExtensions();\n         Set<String> names = new HashSet<>(references.size());\n         for (DocumentReference reference : references) {\n@@ -214,7 +220,7 @@ public Set<DocumentReference> getAlwaysUsedExtensions()\n                         XWikiDocument doc = context.getWiki().getDocument(extension, context);\n                         // Only add the extension as being \"always used\" if the page holding it has been saved with\n                         // programming rights.\n-                        if (Utils.getComponent(AuthorizationManager.class).hasAccess(Right.PROGRAM,\n+                        if (getAuthorizationManager().hasAccess(Right.PROGRAM,\n                             doc.getAuthorReference(), doc.getDocumentReference())) {\n                             extensions.add(extension);\n                         }\n@@ -236,36 +242,83 @@ public Set<DocumentReference> getAlwaysUsedExtensions()\n     public boolean hasPageExtensions(XWikiContext context)\n     {\n         XWikiDocument doc = context.getDoc();\n-        if (doc != null) {\n-            List<BaseObject> objects = doc.getObjects(getExtensionClassName());\n-            if (objects != null) {\n-                for (BaseObject obj : objects) {\n-                    if (obj == null) {\n-                        continue;\n-                    }\n-                    if (obj.getStringValue(USE_FIELDNAME).equals(\"currentPage\")) {\n-                        return true;\n-                    }\n+        boolean result = false;\n+        if (doc != null && this.hasCurrentPageExtensionObjects(doc)) {\n+            if (getAuthorizationManager().hasAccess(Right.SCRIPT, doc.getAuthorReference(),\n+                doc.getDocumentReference())) {\n+                result = true;\n+            } else {\n+                displayScriptRightLog(doc.getDocumentReference());\n+            }\n+        }\n+        return result;\n+    }\n+\n+    private void displayScriptRightLog(Object documentReference)\n+    {\n+        LOGGER.warn(\"Extensions present in [{}] ignored because of lack of script right from the author.\",\n+            documentReference);\n+    }\n+\n+    private boolean hasCurrentPageExtensionObjects(XWikiDocument doc)\n+    {\n+        List<BaseObject> objects = doc.getObjects(getExtensionClassName());\n+        if (objects != null) {\n+            for (BaseObject obj : objects) {\n+                if (obj == null) {\n+                    continue;\n+                }\n+                if (StringUtils.equals(obj.getStringValue(USE_FIELDNAME), \"currentPage\")) {\n+                    return true;\n                 }\n             }\n         }\n         return false;\n     }\n \n     @Override\n-    public void use(String resource, XWikiContext context)\n+    public void use(String resource, Map<String, Object> parameters, XWikiContext context)\n     {\n         String canonicalResource = getCanonicalDocumentName(resource);\n \n-        super.use(canonicalResource, context);\n+        if (this.canResourceBeUsed(canonicalResource, context)) {\n+            super.use(canonicalResource, parameters, context);\n+        } else {\n+            displayScriptRightLog(canonicalResource);\n+        }\n     }\n \n-    @Override\n-    public void use(String resource, Map<String, Object> parameters, XWikiContext context)\n+    private DocumentReferenceResolver<String> getDocumentReferenceResolver()\n     {\n-        String canonicalResource = getCanonicalDocumentName(resource);\n+        if (this.stringDocumentReferenceResolver == null) {\n+            this.stringDocumentReferenceResolver = Utils.getComponent(DocumentReferenceResolver.TYPE_STRING);\n+        }\n+        return this.stringDocumentReferenceResolver;\n+    }\n \n-        super.use(canonicalResource, parameters, context);\n+    private AuthorizationManager getAuthorizationManager()\n+    {\n+        if (this.authorizationManager == null) {\n+            this.authorizationManager = Utils.getComponent(AuthorizationManager.class);\n+        }\n+        return this.authorizationManager;\n+    }\n+\n+    private boolean canResourceBeUsed(String resource, XWikiContext context)\n+    {\n+        DocumentReferenceResolver<String> documentReferenceResolver = getDocumentReferenceResolver();\n+        DocumentReference documentReference = documentReferenceResolver.resolve(resource);\n+\n+        try {\n+            XWikiDocument document = context.getWiki().getDocument(documentReference, context);\n+            DocumentReference authorReference = document.getAuthorReference();\n+            return getAuthorizationManager().hasAccess(Right.SCRIPT, authorReference, documentReference);\n+        } catch (XWikiException e) {\n+            LOGGER.error(\"Error while loading [{}] for checking script right: [{}]\", documentReference,\n+                ExceptionUtils.getRootCauseMessage(e));\n+            LOGGER.debug(\"Original error stack trace: \", e);\n+            return false;\n+        }\n     }\n \n     /**\n@@ -332,7 +385,7 @@ private void onDocumentEvent(XWikiDocument document)\n         if (document.getObject(getExtensionClassName()) != null) {\n             // new or already existing object\n             if (document.getObject(getExtensionClassName(), USE_FIELDNAME, \"always\", false) != null) {\n-                if (Utils.getComponent(AuthorizationManager.class).hasAccess(Right.PROGRAM,\n+                if (getAuthorizationManager().hasAccess(Right.PROGRAM,\n                     document.getAuthorReference(), document.getDocumentReference())) {\n                     getAlwaysUsedExtensions().add(document.getDocumentReference());\n \n@@ -355,6 +408,14 @@ private void onDocumentEvent(XWikiDocument document)\n         }\n     }\n \n+    private EntityReferenceResolver<String> getCurrentEntityReferenceResolver()\n+    {\n+        if (this.currentEntityReferenceResolver == null) {\n+            this.currentEntityReferenceResolver = Utils.getComponent(EntityReferenceResolver.TYPE_STRING, \"current\");\n+        }\n+        return this.currentEntityReferenceResolver;\n+    }\n+\n     /**\n      * Get the canonical serialization of a document name, in the {@code wiki:Space.Document} format.\n      *\n@@ -363,10 +424,8 @@ private void onDocumentEvent(XWikiDocument document)\n      */\n     private String getCanonicalDocumentName(String documentName)\n     {\n-        @SuppressWarnings(\"unchecked\")\n-        EntityReferenceResolver<String> resolver = Utils.getComponent(EntityReferenceResolver.TYPE_STRING, \"current\");\n-        @SuppressWarnings(\"unchecked\")\n-        EntityReferenceSerializer<String> serializer = Utils.getComponent(EntityReferenceSerializer.TYPE_STRING);\n+        EntityReferenceResolver<String> resolver = getCurrentEntityReferenceResolver();\n+        EntityReferenceSerializer<String> serializer = getDefaultEntityReferenceSerializer();\n         return serializer.serialize(resolver.resolve(documentName, EntityType.DOCUMENT));\n     }\n ",
    "function_modified_lines": {
      "added": [
        "import org.apache.commons.lang3.exception.ExceptionUtils;\n",
        "import org.xwiki.model.reference.DocumentReferenceResolver;\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-79"
    ],
    "cve_description": "XWiki Commons are technical libraries common to several other top level XWiki projects. There was no check in the author of a JavaScript xobject or StyleSheet xobject added in a XWiki document, so until now it was possible for a user having only Edit Right to create such object and to craft a script allowing to perform some operations when executing by a user with appropriate rights. This has been patched in XWiki 14.9-rc-1 by only executing the script if the author of it has Script rights.",
    "id": 12315
  },
  {
    "cve_id": "CVE-2023-29206",
    "code_before_change": "    }\n\n    /**\n     * A document related event has been received.\n     * \n     * @param document the modified document\n     */\n    private void onDocumentEvent(XWikiDocument document)\n    {\n        boolean remove = false;\n        if (document.getObject(getExtensionClassName()) != null) {\n            // new or already existing object\n            if (document.getObject(getExtensionClassName(), USE_FIELDNAME, \"always\", false) != null) {\n                if (Utils.getComponent(AuthorizationManager.class).hasAccess(Right.PROGRAM,\n                    document.getAuthorReference(), document.getDocumentReference())) {\n                    getAlwaysUsedExtensions().add(document.getDocumentReference());\n\n                    return;\n                } else {\n                    // in case the extension lost its programming rights upon this save.\n                    remove = true;\n                }\n            } else {\n                // remove if exists but use onDemand\n                remove = true;\n            }\n        } else if (document.getOriginalDocument().getObject(getExtensionClassName()) != null) {\n            // object removed\n            remove = true;\n        }\n\n        if (remove) {\n            getAlwaysUsedExtensions().remove(document.getDocumentReference());\n        }\n    }\n\n    /**\n     * Get the canonical serialization of a document name, in the {@code wiki:Space.Document} format.\n     *\n     * @param documentName the original document name to fix\n     * @return fixed document name\n     */\n    private String getCanonicalDocumentName(String documentName)\n    {\n        @SuppressWarnings(\"unchecked\")\n        EntityReferenceResolver<String> resolver = Utils.getComponent(EntityReferenceResolver.TYPE_STRING, \"current\");\n        @SuppressWarnings(\"unchecked\")\n        EntityReferenceSerializer<String> serializer = Utils.getComponent(EntityReferenceSerializer.TYPE_STRING);\n        return serializer.serialize(resolver.resolve(documentName, EntityType.DOCUMENT));\n    }\n\n    /**\n     * @param documentName the Skin Extension's document name\n     * @param context the XWiki Context\n     * @return true if the specified document is accessible (i.e. has view rights) by the current user; false otherwise\n     */\n    protected boolean isAccessible(String documentName, XWikiContext context)\n    {\n        return isAccessible(getCurrentDocumentReferenceResolver().resolve(documentName), context);\n    }\n\n    /**\n     * @param documentReference the Skin Extension's document reference\n     * @param context the XWiki Context\n     * @return true if the specified document is accessible (i.e. has view rights) by the current user; false otherwise\n     * @since 7.4.1\n     */\n    protected boolean isAccessible(DocumentReference documentReference, XWikiContext context)\n    {\n        if (!Utils.getComponent(ContextualAuthorizationManager.class).hasAccess(Right.VIEW, documentReference)) {\n            LOGGER.debug(\"[{}] The current user [{}] does not have 'view' rights on the Skin Extension document [{}]\",\n                getName(), context.getUserReference(), documentReference);\n\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * @param documentReference the Skin Extension's document reference\n     * @param context the XWiki Context\n     * @return the version of the document\n     */",
    "code_after_change": "    /**\n     * A document related event has been received.\n     * \n     * @param document the modified document\n     */\n    private void onDocumentEvent(XWikiDocument document)\n    {\n        boolean remove = false;\n        if (document.getObject(getExtensionClassName()) != null) {\n            // new or already existing object\n            if (document.getObject(getExtensionClassName(), USE_FIELDNAME, \"always\", false) != null) {\n                if (getAuthorizationManager().hasAccess(Right.PROGRAM,\n                    document.getAuthorReference(), document.getDocumentReference())) {\n                    getAlwaysUsedExtensions().add(document.getDocumentReference());\n\n                    return;\n                } else {\n                    // in case the extension lost its programming rights upon this save.\n                    remove = true;\n                }\n            } else {\n                // remove if exists but use onDemand\n                remove = true;\n            }\n        } else if (document.getOriginalDocument().getObject(getExtensionClassName()) != null) {\n            // object removed\n            remove = true;\n        }\n\n        if (remove) {\n            getAlwaysUsedExtensions().remove(document.getDocumentReference());\n        }\n    }\n\n    private EntityReferenceResolver<String> getCurrentEntityReferenceResolver()\n    {\n        if (this.currentEntityReferenceResolver == null) {\n            this.currentEntityReferenceResolver = Utils.getComponent(EntityReferenceResolver.TYPE_STRING, \"current\");\n        }\n        return this.currentEntityReferenceResolver;\n    }\n\n    /**\n     * Get the canonical serialization of a document name, in the {@code wiki:Space.Document} format.\n     *\n     * @param documentName the original document name to fix\n     * @return fixed document name\n     */\n    private String getCanonicalDocumentName(String documentName)\n    {\n        EntityReferenceResolver<String> resolver = getCurrentEntityReferenceResolver();\n        EntityReferenceSerializer<String> serializer = getDefaultEntityReferenceSerializer();\n        return serializer.serialize(resolver.resolve(documentName, EntityType.DOCUMENT));\n    }\n\n    /**\n     * @param documentName the Skin Extension's document name\n     * @param context the XWiki Context\n     * @return true if the specified document is accessible (i.e. has view rights) by the current user; false otherwise\n     */\n    protected boolean isAccessible(String documentName, XWikiContext context)\n    {\n        return isAccessible(getCurrentDocumentReferenceResolver().resolve(documentName), context);\n    }\n\n    /**\n     * @param documentReference the Skin Extension's document reference\n     * @param context the XWiki Context\n     * @return true if the specified document is accessible (i.e. has view rights) by the current user; false otherwise\n     * @since 7.4.1\n     */\n    protected boolean isAccessible(DocumentReference documentReference, XWikiContext context)\n    {\n        if (!Utils.getComponent(ContextualAuthorizationManager.class).hasAccess(Right.VIEW, documentReference)) {\n            LOGGER.debug(\"[{}] The current user [{}] does not have 'view' rights on the Skin Extension document [{}]\",\n                getName(), context.getUserReference(), documentReference);\n\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * @param documentReference the Skin Extension's document reference\n     * @param context the XWiki Context\n     * @return the version of the document\n     */",
    "patch": "@@ -29,6 +29,7 @@\n import java.util.Set;\n \n import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.exception.ExceptionUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.xwiki.bridge.event.DocumentCreatedEvent;\n@@ -37,6 +38,7 @@\n import org.xwiki.bridge.event.WikiDeletedEvent;\n import org.xwiki.model.EntityType;\n import org.xwiki.model.reference.DocumentReference;\n+import org.xwiki.model.reference.DocumentReferenceResolver;\n import org.xwiki.model.reference.EntityReferenceResolver;\n import org.xwiki.model.reference.EntityReferenceSerializer;\n import org.xwiki.observation.EventListener;\n@@ -85,6 +87,10 @@ public abstract class AbstractDocumentSkinExtensionPlugin extends AbstractSkinEx\n      */\n     private final List<Event> events = new ArrayList<>(3);\n \n+    private AuthorizationManager authorizationManager;\n+    private DocumentReferenceResolver<String> stringDocumentReferenceResolver;\n+    private EntityReferenceResolver<String> currentEntityReferenceResolver;\n+\n     /**\n      * XWiki plugin constructor.\n      * \n@@ -174,7 +180,7 @@ public void virtualInit(XWikiContext context)\n     @Override\n     public Set<String> getAlwaysUsedExtensions(XWikiContext context)\n     {\n-        EntityReferenceSerializer<String> serializer = Utils.getComponent(EntityReferenceSerializer.TYPE_STRING);\n+        EntityReferenceSerializer<String> serializer = getDefaultEntityReferenceSerializer();\n         Set<DocumentReference> references = getAlwaysUsedExtensions();\n         Set<String> names = new HashSet<>(references.size());\n         for (DocumentReference reference : references) {\n@@ -214,7 +220,7 @@ public Set<DocumentReference> getAlwaysUsedExtensions()\n                         XWikiDocument doc = context.getWiki().getDocument(extension, context);\n                         // Only add the extension as being \"always used\" if the page holding it has been saved with\n                         // programming rights.\n-                        if (Utils.getComponent(AuthorizationManager.class).hasAccess(Right.PROGRAM,\n+                        if (getAuthorizationManager().hasAccess(Right.PROGRAM,\n                             doc.getAuthorReference(), doc.getDocumentReference())) {\n                             extensions.add(extension);\n                         }\n@@ -236,36 +242,83 @@ public Set<DocumentReference> getAlwaysUsedExtensions()\n     public boolean hasPageExtensions(XWikiContext context)\n     {\n         XWikiDocument doc = context.getDoc();\n-        if (doc != null) {\n-            List<BaseObject> objects = doc.getObjects(getExtensionClassName());\n-            if (objects != null) {\n-                for (BaseObject obj : objects) {\n-                    if (obj == null) {\n-                        continue;\n-                    }\n-                    if (obj.getStringValue(USE_FIELDNAME).equals(\"currentPage\")) {\n-                        return true;\n-                    }\n+        boolean result = false;\n+        if (doc != null && this.hasCurrentPageExtensionObjects(doc)) {\n+            if (getAuthorizationManager().hasAccess(Right.SCRIPT, doc.getAuthorReference(),\n+                doc.getDocumentReference())) {\n+                result = true;\n+            } else {\n+                displayScriptRightLog(doc.getDocumentReference());\n+            }\n+        }\n+        return result;\n+    }\n+\n+    private void displayScriptRightLog(Object documentReference)\n+    {\n+        LOGGER.warn(\"Extensions present in [{}] ignored because of lack of script right from the author.\",\n+            documentReference);\n+    }\n+\n+    private boolean hasCurrentPageExtensionObjects(XWikiDocument doc)\n+    {\n+        List<BaseObject> objects = doc.getObjects(getExtensionClassName());\n+        if (objects != null) {\n+            for (BaseObject obj : objects) {\n+                if (obj == null) {\n+                    continue;\n+                }\n+                if (StringUtils.equals(obj.getStringValue(USE_FIELDNAME), \"currentPage\")) {\n+                    return true;\n                 }\n             }\n         }\n         return false;\n     }\n \n     @Override\n-    public void use(String resource, XWikiContext context)\n+    public void use(String resource, Map<String, Object> parameters, XWikiContext context)\n     {\n         String canonicalResource = getCanonicalDocumentName(resource);\n \n-        super.use(canonicalResource, context);\n+        if (this.canResourceBeUsed(canonicalResource, context)) {\n+            super.use(canonicalResource, parameters, context);\n+        } else {\n+            displayScriptRightLog(canonicalResource);\n+        }\n     }\n \n-    @Override\n-    public void use(String resource, Map<String, Object> parameters, XWikiContext context)\n+    private DocumentReferenceResolver<String> getDocumentReferenceResolver()\n     {\n-        String canonicalResource = getCanonicalDocumentName(resource);\n+        if (this.stringDocumentReferenceResolver == null) {\n+            this.stringDocumentReferenceResolver = Utils.getComponent(DocumentReferenceResolver.TYPE_STRING);\n+        }\n+        return this.stringDocumentReferenceResolver;\n+    }\n \n-        super.use(canonicalResource, parameters, context);\n+    private AuthorizationManager getAuthorizationManager()\n+    {\n+        if (this.authorizationManager == null) {\n+            this.authorizationManager = Utils.getComponent(AuthorizationManager.class);\n+        }\n+        return this.authorizationManager;\n+    }\n+\n+    private boolean canResourceBeUsed(String resource, XWikiContext context)\n+    {\n+        DocumentReferenceResolver<String> documentReferenceResolver = getDocumentReferenceResolver();\n+        DocumentReference documentReference = documentReferenceResolver.resolve(resource);\n+\n+        try {\n+            XWikiDocument document = context.getWiki().getDocument(documentReference, context);\n+            DocumentReference authorReference = document.getAuthorReference();\n+            return getAuthorizationManager().hasAccess(Right.SCRIPT, authorReference, documentReference);\n+        } catch (XWikiException e) {\n+            LOGGER.error(\"Error while loading [{}] for checking script right: [{}]\", documentReference,\n+                ExceptionUtils.getRootCauseMessage(e));\n+            LOGGER.debug(\"Original error stack trace: \", e);\n+            return false;\n+        }\n     }\n \n     /**\n@@ -332,7 +385,7 @@ private void onDocumentEvent(XWikiDocument document)\n         if (document.getObject(getExtensionClassName()) != null) {\n             // new or already existing object\n             if (document.getObject(getExtensionClassName(), USE_FIELDNAME, \"always\", false) != null) {\n-                if (Utils.getComponent(AuthorizationManager.class).hasAccess(Right.PROGRAM,\n+                if (getAuthorizationManager().hasAccess(Right.PROGRAM,\n                     document.getAuthorReference(), document.getDocumentReference())) {\n                     getAlwaysUsedExtensions().add(document.getDocumentReference());\n \n@@ -355,6 +408,14 @@ private void onDocumentEvent(XWikiDocument document)\n         }\n     }\n \n+    private EntityReferenceResolver<String> getCurrentEntityReferenceResolver()\n+    {\n+        if (this.currentEntityReferenceResolver == null) {\n+            this.currentEntityReferenceResolver = Utils.getComponent(EntityReferenceResolver.TYPE_STRING, \"current\");\n+        }\n+        return this.currentEntityReferenceResolver;\n+    }\n+\n     /**\n      * Get the canonical serialization of a document name, in the {@code wiki:Space.Document} format.\n      *\n@@ -363,10 +424,8 @@ private void onDocumentEvent(XWikiDocument document)\n      */\n     private String getCanonicalDocumentName(String documentName)\n     {\n-        @SuppressWarnings(\"unchecked\")\n-        EntityReferenceResolver<String> resolver = Utils.getComponent(EntityReferenceResolver.TYPE_STRING, \"current\");\n-        @SuppressWarnings(\"unchecked\")\n-        EntityReferenceSerializer<String> serializer = Utils.getComponent(EntityReferenceSerializer.TYPE_STRING);\n+        EntityReferenceResolver<String> resolver = getCurrentEntityReferenceResolver();\n+        EntityReferenceSerializer<String> serializer = getDefaultEntityReferenceSerializer();\n         return serializer.serialize(resolver.resolve(documentName, EntityType.DOCUMENT));\n     }\n ",
    "function_modified_lines": {
      "added": [
        "    private EntityReferenceResolver<String> getCurrentEntityReferenceResolver()\n",
        "    {\n",
        "        if (this.currentEntityReferenceResolver == null) {\n",
        "            this.currentEntityReferenceResolver = Utils.getComponent(EntityReferenceResolver.TYPE_STRING, \"current\");\n",
        "        }\n",
        "        return this.currentEntityReferenceResolver;\n",
        "    }\n",
        "\n",
        "        EntityReferenceResolver<String> resolver = getCurrentEntityReferenceResolver();\n",
        "        EntityReferenceSerializer<String> serializer = getDefaultEntityReferenceSerializer();\n"
      ],
      "deleted": [
        "        @SuppressWarnings(\"unchecked\")\n",
        "        EntityReferenceResolver<String> resolver = Utils.getComponent(EntityReferenceResolver.TYPE_STRING, \"current\");\n",
        "        @SuppressWarnings(\"unchecked\")\n",
        "        EntityReferenceSerializer<String> serializer = Utils.getComponent(EntityReferenceSerializer.TYPE_STRING);\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-79"
    ],
    "cve_description": "XWiki Commons are technical libraries common to several other top level XWiki projects. There was no check in the author of a JavaScript xobject or StyleSheet xobject added in a XWiki document, so until now it was possible for a user having only Edit Right to create such object and to craft a script allowing to perform some operations when executing by a user with appropriate rights. This has been patched in XWiki 14.9-rc-1 by only executing the script if the author of it has Script rights.",
    "id": 12316
  },
  {
    "cve_id": "CVE-2023-29506",
    "code_before_change": "{\n    @Inject\n    private XWikiContextInitializer xWikiContextInitializer;\n\n    @Inject\n    private Execution execution;\n\n    @Override\n    public List<ResourceType> getSupportedResourceReferences()\n    {\n        return Collections.singletonList(AuthenticationResourceReference.TYPE);\n    }\n\n    @Override\n    public void handle(ResourceReference reference, ResourceReferenceHandlerChain chain)\n        throws ResourceReferenceHandlerException\n    {\n        AuthenticationResourceReference authenticationResourceReference = (AuthenticationResourceReference) reference;\n\n        switch (authenticationResourceReference.getAction()) {\n            case RETRIEVE_USERNAME:\n                this.handleAction(\"forgotusername\", authenticationResourceReference.getWikiReference());\n                break;\n\n            case RESET_PASSWORD:\n                this.handleAction(\"resetpassword\", authenticationResourceReference.getWikiReference());\n                break;\n\n            default:\n                // nothing to do here.\n        }\n\n        // Be a good citizen, continue the chain, in case some lower-priority Handler has something to do for this\n        // Resource Reference.\n        chain.handleNext(reference);\n    }\n\n    private void handleAction(String templateName, WikiReference wikiReference) throws ResourceReferenceHandlerException\n    {\n        ExecutionContext executionContext = this.execution.getContext();\n        if (executionContext == null) {\n            executionContext = new ExecutionContext();\n        }\n        WikiReference currentWiki = null;\n        XWikiContext context = null;\n        try {\n            context = this.xWikiContextInitializer.initialize(executionContext);\n            currentWiki = context.getWikiReference();\n            context.setWikiReference(wikiReference);\n            // We are directly relying on Utils#parseTemplate because we want the plugin manager to properly\n            // handle the javascript placeholders and it avoids duplicating code.\n            Utils.parseTemplate(templateName, true, context);\n        } catch (Exception e) {\n            throw new ResourceReferenceHandlerException(\n                String.format(\"Error while rendering template [%s]: [%s].\",\n                templateName, ExceptionUtils.getRootCauseMessage(e)), e);\n        } finally {\n            if (currentWiki != null) {\n                context.setWikiReference(currentWiki);\n            }\n        }\n    }\n}",
    "code_after_change": "{\n    @Inject\n    private XWikiContextInitializer xWikiContextInitializer;\n\n    @Inject\n    private Execution execution;\n\n    @Inject\n    private WikiDescriptorManager wikiDescriptorManager;\n\n    @Override\n    public List<ResourceType> getSupportedResourceReferences()\n    {\n        return Collections.singletonList(AuthenticationResourceReference.TYPE);\n    }\n\n    @Override\n    public void handle(ResourceReference reference, ResourceReferenceHandlerChain chain)\n        throws ResourceReferenceHandlerException\n    {\n        AuthenticationResourceReference authenticationResourceReference = (AuthenticationResourceReference) reference;\n\n        WikiReference wikiReference = authenticationResourceReference.getWikiReference();\n        try {\n            if (!this.wikiDescriptorManager.exists(wikiReference.getName())) {\n                throw new ResourceReferenceHandlerException(\n                    String.format(\"The wiki [%s] does not exist.\", wikiReference.getName()));\n            }\n        } catch (WikiManagerException e) {\n            throw new ResourceReferenceHandlerException(\n                String.format(\"Error when checking if wiki [%s] exists.\", wikiReference.getName()), e);\n        }\n\n        switch (authenticationResourceReference.getAction()) {\n            case RETRIEVE_USERNAME:\n                this.handleAction(\"forgotusername\", authenticationResourceReference.getWikiReference());\n                break;\n\n            case RESET_PASSWORD:\n                this.handleAction(\"resetpassword\", authenticationResourceReference.getWikiReference());\n                break;\n\n            default:\n                // nothing to do here.\n        }\n\n        // Be a good citizen, continue the chain, in case some lower-priority Handler has something to do for this\n        // Resource Reference.\n        chain.handleNext(reference);\n    }\n\n    private void handleAction(String templateName, WikiReference wikiReference) throws ResourceReferenceHandlerException\n    {\n        ExecutionContext executionContext = this.execution.getContext();\n        if (executionContext == null) {\n            executionContext = new ExecutionContext();\n        }\n        WikiReference currentWiki = null;\n        XWikiContext context = null;\n        try {\n            context = this.xWikiContextInitializer.initialize(executionContext);\n            currentWiki = context.getWikiReference();\n            context.setWikiReference(wikiReference);\n            // We are directly relying on Utils#parseTemplate because we want the plugin manager to properly\n            // handle the javascript placeholders and it avoids duplicating code.\n            Utils.parseTemplate(templateName, true, context);\n        } catch (Exception e) {\n            throw new ResourceReferenceHandlerException(\n                String.format(\"Error while rendering template [%s]: [%s].\",\n                templateName, ExceptionUtils.getRootCauseMessage(e)), e);\n        } finally {\n            if (currentWiki != null) {\n                context.setWikiReference(currentWiki);\n            }\n        }\n    }\n}",
    "patch": "@@ -37,6 +37,8 @@\n import org.xwiki.resource.ResourceReferenceHandlerException;\n import org.xwiki.resource.ResourceType;\n import org.xwiki.security.authentication.AuthenticationResourceReference;\n+import org.xwiki.wiki.descriptor.WikiDescriptorManager;\n+import org.xwiki.wiki.manager.WikiManagerException;\n \n import com.xpn.xwiki.XWikiContext;\n import com.xpn.xwiki.XWikiContextInitializer;\n@@ -59,6 +61,9 @@ public class AuthenticationResourceReferenceHandler extends AbstractResourceRefe\n     @Inject\n     private Execution execution;\n \n+    @Inject\n+    private WikiDescriptorManager wikiDescriptorManager;\n+\n     @Override\n     public List<ResourceType> getSupportedResourceReferences()\n     {\n@@ -71,6 +76,17 @@ public void handle(ResourceReference reference, ResourceReferenceHandlerChain ch\n     {\n         AuthenticationResourceReference authenticationResourceReference = (AuthenticationResourceReference) reference;\n \n+        WikiReference wikiReference = authenticationResourceReference.getWikiReference();\n+        try {\n+            if (!this.wikiDescriptorManager.exists(wikiReference.getName())) {\n+                throw new ResourceReferenceHandlerException(\n+                    String.format(\"The wiki [%s] does not exist.\", wikiReference.getName()));\n+            }\n+        } catch (WikiManagerException e) {\n+            throw new ResourceReferenceHandlerException(\n+                String.format(\"Error when checking if wiki [%s] exists.\", wikiReference.getName()), e);\n+        }\n+\n         switch (authenticationResourceReference.getAction()) {\n             case RETRIEVE_USERNAME:\n                 this.handleAction(\"forgotusername\", authenticationResourceReference.getWikiReference());",
    "function_modified_lines": {
      "added": [
        "    @Inject\n",
        "    private WikiDescriptorManager wikiDescriptorManager;\n",
        "\n",
        "        WikiReference wikiReference = authenticationResourceReference.getWikiReference();\n",
        "        try {\n",
        "            if (!this.wikiDescriptorManager.exists(wikiReference.getName())) {\n",
        "                throw new ResourceReferenceHandlerException(\n",
        "                    String.format(\"The wiki [%s] does not exist.\", wikiReference.getName()));\n",
        "            }\n",
        "        } catch (WikiManagerException e) {\n",
        "            throw new ResourceReferenceHandlerException(\n",
        "                String.format(\"Error when checking if wiki [%s] exists.\", wikiReference.getName()), e);\n",
        "        }\n",
        "\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-79"
    ],
    "cve_description": "XWiki Commons are technical libraries common to several other top level XWiki projects. It was possible to inject some code using the URL of authenticated endpoints. This problem has been patched on XWiki 13.10.11, 14.4.7 and 14.10.",
    "id": 12333
  },
  {
    "cve_id": "CVE-2023-29506",
    "code_before_change": "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.security.authentication.internal.resource;\n\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Collections;\n\nimport javax.servlet.ServletOutputStream;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.xwiki.context.Execution;\nimport org.xwiki.context.ExecutionContext;\nimport org.xwiki.model.reference.WikiReference;\nimport org.xwiki.resource.ResourceReferenceHandlerChain;\nimport org.xwiki.security.authentication.AuthenticationAction;\nimport org.xwiki.security.authentication.AuthenticationResourceReference;\nimport org.xwiki.test.junit5.mockito.ComponentTest;\nimport org.xwiki.test.junit5.mockito.InjectMockComponents;\nimport org.xwiki.test.junit5.mockito.MockComponent;\n\nimport com.xpn.xwiki.XWiki;\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.XWikiContextInitializer;\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.plugin.XWikiPluginManager;\nimport com.xpn.xwiki.web.XWikiResponse;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.ArgumentMatchers.eq;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\n/**\n * Tests for {@link AuthenticationResourceReferenceHandler}.\n *\n * @version $Id$\n * @since 13.0RC1\n */\n@ComponentTest\nclass AuthenticationResourceReferenceHandlerTest\n{\n    @InjectMockComponents\n    private AuthenticationResourceReferenceHandler resourceReferenceHandler;\n\n    @MockComponent\n    private XWikiContextInitializer xWikiContextInitializer;\n\n    @MockComponent\n    private Execution execution;\n\n    private XWikiResponse response;\n\n    private XWiki xwiki;\n\n    private XWikiContext context;\n\n    private ServletOutputStream servletOutputStream;\n\n    private WikiReference currentWiki;\n\n    @BeforeEach\n    void setup() throws XWikiException, IOException\n    {\n        ExecutionContext executionContext = mock(ExecutionContext.class);\n        when(this.execution.getContext()).thenReturn(executionContext);\n        this.context = mock(XWikiContext.class);\n        when(this.xWikiContextInitializer.initialize(executionContext)).thenReturn(context);\n        this.response = mock(XWikiResponse.class);\n        when(context.getResponse()).thenReturn(response);\n        this.xwiki = mock(XWiki.class);\n        when(context.getWiki()).thenReturn(xwiki);\n        when(this.xwiki.getEncoding()).thenReturn(\"UTF-8\");\n        XWikiPluginManager pluginManager = mock(XWikiPluginManager.class);\n        when(this.xwiki.getPluginManager()).thenReturn(pluginManager);\n        when(pluginManager.endParsing(any(), eq(context)))\n            .then(invocationOnMock -> invocationOnMock.getArgument(0));\n        this.servletOutputStream = mock(ServletOutputStream.class);\n        when(this.response.getOutputStream()).thenReturn(servletOutputStream);\n        currentWiki = new WikiReference(\"currentWiki\");\n        when(context.getWikiReference()).thenReturn(currentWiki);\n    }\n\n    @Test\n    void getSupportedResourceReferences()\n    {\n        assertEquals(Collections.singletonList(AuthenticationResourceReference.TYPE),\n            this.resourceReferenceHandler.getSupportedResourceReferences());\n    }\n\n    @Test\n    void handleResetPassword() throws Exception\n    {\n        WikiReference wikiReference = new WikiReference(\"foo\");\n        AuthenticationResourceReference resourceReference = new AuthenticationResourceReference(\n            wikiReference,\n            AuthenticationAction.RESET_PASSWORD);\n\n        when(this.xwiki.evaluateTemplate(\"resetpassword.vm\", context)).thenReturn(\"Reset password content\");\n\n        ResourceReferenceHandlerChain chain = mock(ResourceReferenceHandlerChain.class);\n        this.resourceReferenceHandler.handle(resourceReference, chain);\n\n        verify(response).setContentType(\"text/html; charset=UTF-8\");\n        verify(this.xWikiContextInitializer).initialize(any(ExecutionContext.class));\n        verify(servletOutputStream).write(\"Reset password content\".getBytes(StandardCharsets.UTF_8));\n        verify(chain).handleNext(resourceReference);\n        verify(context).setWikiReference(wikiReference);\n        verify(context).setWikiReference(currentWiki);\n    }\n\n    @Test\n    void handleForgotUsername() throws Exception\n    {\n        WikiReference wikiReference = new WikiReference(\"bar\");\n        AuthenticationResourceReference resourceReference = new AuthenticationResourceReference(\n            wikiReference,\n            AuthenticationAction.RETRIEVE_USERNAME);\n\n        when(this.xwiki.evaluateTemplate(\"forgotusername.vm\", context)).thenReturn(\"Forgot user name content\");\n\n        ResourceReferenceHandlerChain chain = mock(ResourceReferenceHandlerChain.class);\n        this.resourceReferenceHandler.handle(resourceReference, chain);\n\n        verify(response).setContentType(\"text/html; charset=UTF-8\");\n        verify(this.xWikiContextInitializer).initialize(any(ExecutionContext.class));\n        verify(servletOutputStream).write(\"Forgot user name content\".getBytes(StandardCharsets.UTF_8));\n        verify(chain).handleNext(resourceReference);\n        verify(context).setWikiReference(wikiReference);\n        verify(context).setWikiReference(currentWiki);\n    }\n}\n",
    "code_after_change": "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.security.authentication.internal.resource;\n\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Collections;\n\nimport javax.servlet.ServletOutputStream;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.xwiki.context.Execution;\nimport org.xwiki.context.ExecutionContext;\nimport org.xwiki.model.reference.WikiReference;\nimport org.xwiki.resource.ResourceReferenceHandlerChain;\nimport org.xwiki.resource.ResourceReferenceHandlerException;\nimport org.xwiki.security.authentication.AuthenticationAction;\nimport org.xwiki.security.authentication.AuthenticationResourceReference;\nimport org.xwiki.test.junit5.mockito.ComponentTest;\nimport org.xwiki.test.junit5.mockito.InjectMockComponents;\nimport org.xwiki.test.junit5.mockito.MockComponent;\nimport org.xwiki.wiki.descriptor.WikiDescriptorManager;\nimport org.xwiki.wiki.manager.WikiManagerException;\n\nimport com.xpn.xwiki.XWiki;\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.XWikiContextInitializer;\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.plugin.XWikiPluginManager;\nimport com.xpn.xwiki.web.XWikiResponse;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.ArgumentMatchers.eq;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\n/**\n * Tests for {@link AuthenticationResourceReferenceHandler}.\n *\n * @version $Id$\n * @since 13.0RC1\n */\n@ComponentTest\nclass AuthenticationResourceReferenceHandlerTest\n{\n    @InjectMockComponents\n    private AuthenticationResourceReferenceHandler resourceReferenceHandler;\n\n    @MockComponent\n    private XWikiContextInitializer xWikiContextInitializer;\n\n    @MockComponent\n    private Execution execution;\n\n    @MockComponent\n    private WikiDescriptorManager wikiDescriptorManager;\n\n    private XWikiResponse response;\n\n    private XWiki xwiki;\n\n    private XWikiContext context;\n\n    private ServletOutputStream servletOutputStream;\n\n    private WikiReference currentWiki;\n\n    @BeforeEach\n    void setup() throws XWikiException, IOException\n    {\n        ExecutionContext executionContext = mock(ExecutionContext.class);\n        when(this.execution.getContext()).thenReturn(executionContext);\n        this.context = mock(XWikiContext.class);\n        when(this.xWikiContextInitializer.initialize(executionContext)).thenReturn(context);\n        this.response = mock(XWikiResponse.class);\n        when(context.getResponse()).thenReturn(response);\n        this.xwiki = mock(XWiki.class);\n        when(context.getWiki()).thenReturn(xwiki);\n        when(this.xwiki.getEncoding()).thenReturn(\"UTF-8\");\n        XWikiPluginManager pluginManager = mock(XWikiPluginManager.class);\n        when(this.xwiki.getPluginManager()).thenReturn(pluginManager);\n        when(pluginManager.endParsing(any(), eq(context)))\n            .then(invocationOnMock -> invocationOnMock.getArgument(0));\n        this.servletOutputStream = mock(ServletOutputStream.class);\n        when(this.response.getOutputStream()).thenReturn(servletOutputStream);\n        currentWiki = new WikiReference(\"currentWiki\");\n        when(context.getWikiReference()).thenReturn(currentWiki);\n    }\n\n    @Test\n    void getSupportedResourceReferences()\n    {\n        assertEquals(Collections.singletonList(AuthenticationResourceReference.TYPE),\n            this.resourceReferenceHandler.getSupportedResourceReferences());\n    }\n\n    @Test\n    void handleResetPassword() throws Exception\n    {\n        WikiReference wikiReference = new WikiReference(\"foo\");\n        when(this.wikiDescriptorManager.exists(\"foo\")).thenReturn(false);\n        AuthenticationResourceReference resourceReference = new AuthenticationResourceReference(\n            wikiReference,\n            AuthenticationAction.RESET_PASSWORD);\n\n        ResourceReferenceHandlerChain chain = mock(ResourceReferenceHandlerChain.class);\n        ResourceReferenceHandlerException exception =\n            assertThrows(ResourceReferenceHandlerException.class,\n                () -> this.resourceReferenceHandler.handle(resourceReference, chain));\n        assertEquals(\"The wiki [foo] does not exist.\", exception.getMessage());\n\n        when(this.wikiDescriptorManager.exists(\"foo\")).thenReturn(true);\n        when(this.xwiki.evaluateTemplate(\"resetpassword.vm\", context)).thenReturn(\"Reset password content\");\n        this.resourceReferenceHandler.handle(resourceReference, chain);\n\n        verify(response).setContentType(\"text/html; charset=UTF-8\");\n        verify(this.xWikiContextInitializer).initialize(any(ExecutionContext.class));\n        verify(servletOutputStream).write(\"Reset password content\".getBytes(StandardCharsets.UTF_8));\n        verify(chain).handleNext(resourceReference);\n        verify(context).setWikiReference(wikiReference);\n        verify(context).setWikiReference(currentWiki);\n    }\n\n    @Test\n    void handleForgotUsername() throws Exception\n    {\n        WikiReference wikiReference = new WikiReference(\"bar\");\n        when(this.wikiDescriptorManager.exists(\"bar\")).thenReturn(false);\n        AuthenticationResourceReference resourceReference = new AuthenticationResourceReference(\n            wikiReference,\n            AuthenticationAction.RETRIEVE_USERNAME);\n\n        ResourceReferenceHandlerChain chain = mock(ResourceReferenceHandlerChain.class);\n        ResourceReferenceHandlerException exception =\n            assertThrows(ResourceReferenceHandlerException.class,\n                () -> this.resourceReferenceHandler.handle(resourceReference, chain));\n        assertEquals(\"The wiki [bar] does not exist.\", exception.getMessage());\n\n        when(this.wikiDescriptorManager.exists(\"bar\")).thenReturn(true);\n        when(this.xwiki.evaluateTemplate(\"forgotusername.vm\", context)).thenReturn(\"Forgot user name content\");\n\n        this.resourceReferenceHandler.handle(resourceReference, chain);\n        verify(response).setContentType(\"text/html; charset=UTF-8\");\n        verify(this.xWikiContextInitializer).initialize(any(ExecutionContext.class));\n        verify(servletOutputStream).write(\"Forgot user name content\".getBytes(StandardCharsets.UTF_8));\n        verify(chain).handleNext(resourceReference);\n        verify(context).setWikiReference(wikiReference);\n        verify(context).setWikiReference(currentWiki);\n    }\n\n    @Test\n    void handleForgotUsernameWikiDescriptorError() throws Exception\n    {\n        WikiReference wikiReference = new WikiReference(\"bar\");\n        when(this.wikiDescriptorManager.exists(\"bar\")).thenThrow(new WikiManagerException(\"Cannot access wiki\"));\n        AuthenticationResourceReference resourceReference = new AuthenticationResourceReference(\n            wikiReference,\n            AuthenticationAction.RETRIEVE_USERNAME);\n\n        ResourceReferenceHandlerChain chain = mock(ResourceReferenceHandlerChain.class);\n        ResourceReferenceHandlerException exception =\n            assertThrows(ResourceReferenceHandlerException.class,\n                () -> this.resourceReferenceHandler.handle(resourceReference, chain));\n        assertEquals(\"Error when checking if wiki [bar] exists.\", exception.getMessage());\n    }\n}\n",
    "patch": "@@ -31,11 +31,14 @@\n import org.xwiki.context.ExecutionContext;\n import org.xwiki.model.reference.WikiReference;\n import org.xwiki.resource.ResourceReferenceHandlerChain;\n+import org.xwiki.resource.ResourceReferenceHandlerException;\n import org.xwiki.security.authentication.AuthenticationAction;\n import org.xwiki.security.authentication.AuthenticationResourceReference;\n import org.xwiki.test.junit5.mockito.ComponentTest;\n import org.xwiki.test.junit5.mockito.InjectMockComponents;\n import org.xwiki.test.junit5.mockito.MockComponent;\n+import org.xwiki.wiki.descriptor.WikiDescriptorManager;\n+import org.xwiki.wiki.manager.WikiManagerException;\n \n import com.xpn.xwiki.XWiki;\n import com.xpn.xwiki.XWikiContext;\n@@ -45,6 +48,7 @@\n import com.xpn.xwiki.web.XWikiResponse;\n \n import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.ArgumentMatchers.eq;\n import static org.mockito.Mockito.mock;\n@@ -69,6 +73,9 @@ class AuthenticationResourceReferenceHandlerTest\n     @MockComponent\n     private Execution execution;\n \n+    @MockComponent\n+    private WikiDescriptorManager wikiDescriptorManager;\n+\n     private XWikiResponse response;\n \n     private XWiki xwiki;\n@@ -112,13 +119,19 @@ void getSupportedResourceReferences()\n     void handleResetPassword() throws Exception\n     {\n         WikiReference wikiReference = new WikiReference(\"foo\");\n+        when(this.wikiDescriptorManager.exists(\"foo\")).thenReturn(false);\n         AuthenticationResourceReference resourceReference = new AuthenticationResourceReference(\n             wikiReference,\n             AuthenticationAction.RESET_PASSWORD);\n \n-        when(this.xwiki.evaluateTemplate(\"resetpassword.vm\", context)).thenReturn(\"Reset password content\");\n-\n         ResourceReferenceHandlerChain chain = mock(ResourceReferenceHandlerChain.class);\n+        ResourceReferenceHandlerException exception =\n+            assertThrows(ResourceReferenceHandlerException.class,\n+                () -> this.resourceReferenceHandler.handle(resourceReference, chain));\n+        assertEquals(\"The wiki [foo] does not exist.\", exception.getMessage());\n+\n+        when(this.wikiDescriptorManager.exists(\"foo\")).thenReturn(true);\n+        when(this.xwiki.evaluateTemplate(\"resetpassword.vm\", context)).thenReturn(\"Reset password content\");\n         this.resourceReferenceHandler.handle(resourceReference, chain);\n \n         verify(response).setContentType(\"text/html; charset=UTF-8\");\n@@ -133,20 +146,42 @@ void handleResetPassword() throws Exception\n     void handleForgotUsername() throws Exception\n     {\n         WikiReference wikiReference = new WikiReference(\"bar\");\n+        when(this.wikiDescriptorManager.exists(\"bar\")).thenReturn(false);\n         AuthenticationResourceReference resourceReference = new AuthenticationResourceReference(\n             wikiReference,\n             AuthenticationAction.RETRIEVE_USERNAME);\n \n+        ResourceReferenceHandlerChain chain = mock(ResourceReferenceHandlerChain.class);\n+        ResourceReferenceHandlerException exception =\n+            assertThrows(ResourceReferenceHandlerException.class,\n+                () -> this.resourceReferenceHandler.handle(resourceReference, chain));\n+        assertEquals(\"The wiki [bar] does not exist.\", exception.getMessage());\n+\n+        when(this.wikiDescriptorManager.exists(\"bar\")).thenReturn(true);\n         when(this.xwiki.evaluateTemplate(\"forgotusername.vm\", context)).thenReturn(\"Forgot user name content\");\n \n-        ResourceReferenceHandlerChain chain = mock(ResourceReferenceHandlerChain.class);\n         this.resourceReferenceHandler.handle(resourceReference, chain);\n-\n         verify(response).setContentType(\"text/html; charset=UTF-8\");\n         verify(this.xWikiContextInitializer).initialize(any(ExecutionContext.class));\n         verify(servletOutputStream).write(\"Forgot user name content\".getBytes(StandardCharsets.UTF_8));\n         verify(chain).handleNext(resourceReference);\n         verify(context).setWikiReference(wikiReference);\n         verify(context).setWikiReference(currentWiki);\n     }\n+\n+    @Test\n+    void handleForgotUsernameWikiDescriptorError() throws Exception\n+    {\n+        WikiReference wikiReference = new WikiReference(\"bar\");\n+        when(this.wikiDescriptorManager.exists(\"bar\")).thenThrow(new WikiManagerException(\"Cannot access wiki\"));\n+        AuthenticationResourceReference resourceReference = new AuthenticationResourceReference(\n+            wikiReference,\n+            AuthenticationAction.RETRIEVE_USERNAME);\n+\n+        ResourceReferenceHandlerChain chain = mock(ResourceReferenceHandlerChain.class);\n+        ResourceReferenceHandlerException exception =\n+            assertThrows(ResourceReferenceHandlerException.class,\n+                () -> this.resourceReferenceHandler.handle(resourceReference, chain));\n+        assertEquals(\"Error when checking if wiki [bar] exists.\", exception.getMessage());\n+    }\n }",
    "function_modified_lines": {
      "added": [
        "import org.xwiki.resource.ResourceReferenceHandlerException;\n",
        "import org.xwiki.wiki.descriptor.WikiDescriptorManager;\n",
        "import org.xwiki.wiki.manager.WikiManagerException;\n",
        "import static org.junit.jupiter.api.Assertions.assertThrows;\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-79"
    ],
    "cve_description": "XWiki Commons are technical libraries common to several other top level XWiki projects. It was possible to inject some code using the URL of authenticated endpoints. This problem has been patched on XWiki 13.10.11, 14.4.7 and 14.10.",
    "id": 12334
  },
  {
    "cve_id": "CVE-2023-29506",
    "code_before_change": "{\n    @InjectMockComponents\n    private AuthenticationResourceReferenceHandler resourceReferenceHandler;\n\n    @MockComponent\n    private XWikiContextInitializer xWikiContextInitializer;\n\n    @MockComponent\n    private Execution execution;\n\n    private XWikiResponse response;\n\n    private XWiki xwiki;\n\n    private XWikiContext context;\n\n    private ServletOutputStream servletOutputStream;\n\n    private WikiReference currentWiki;\n\n    @BeforeEach\n    void setup() throws XWikiException, IOException\n    {\n        ExecutionContext executionContext = mock(ExecutionContext.class);\n        when(this.execution.getContext()).thenReturn(executionContext);\n        this.context = mock(XWikiContext.class);\n        when(this.xWikiContextInitializer.initialize(executionContext)).thenReturn(context);\n        this.response = mock(XWikiResponse.class);\n        when(context.getResponse()).thenReturn(response);\n        this.xwiki = mock(XWiki.class);\n        when(context.getWiki()).thenReturn(xwiki);\n        when(this.xwiki.getEncoding()).thenReturn(\"UTF-8\");\n        XWikiPluginManager pluginManager = mock(XWikiPluginManager.class);\n        when(this.xwiki.getPluginManager()).thenReturn(pluginManager);\n        when(pluginManager.endParsing(any(), eq(context)))\n            .then(invocationOnMock -> invocationOnMock.getArgument(0));\n        this.servletOutputStream = mock(ServletOutputStream.class);\n        when(this.response.getOutputStream()).thenReturn(servletOutputStream);\n        currentWiki = new WikiReference(\"currentWiki\");\n        when(context.getWikiReference()).thenReturn(currentWiki);\n    }\n\n    @Test\n    void getSupportedResourceReferences()\n    {\n        assertEquals(Collections.singletonList(AuthenticationResourceReference.TYPE),\n            this.resourceReferenceHandler.getSupportedResourceReferences());\n    }\n\n    @Test\n    void handleResetPassword() throws Exception\n    {\n        WikiReference wikiReference = new WikiReference(\"foo\");\n        AuthenticationResourceReference resourceReference = new AuthenticationResourceReference(\n            wikiReference,\n            AuthenticationAction.RESET_PASSWORD);\n\n        when(this.xwiki.evaluateTemplate(\"resetpassword.vm\", context)).thenReturn(\"Reset password content\");\n\n        ResourceReferenceHandlerChain chain = mock(ResourceReferenceHandlerChain.class);\n        this.resourceReferenceHandler.handle(resourceReference, chain);\n\n        verify(response).setContentType(\"text/html; charset=UTF-8\");\n        verify(this.xWikiContextInitializer).initialize(any(ExecutionContext.class));\n        verify(servletOutputStream).write(\"Reset password content\".getBytes(StandardCharsets.UTF_8));\n        verify(chain).handleNext(resourceReference);\n        verify(context).setWikiReference(wikiReference);\n        verify(context).setWikiReference(currentWiki);\n    }\n\n    @Test\n    void handleForgotUsername() throws Exception\n    {\n        WikiReference wikiReference = new WikiReference(\"bar\");\n        AuthenticationResourceReference resourceReference = new AuthenticationResourceReference(\n            wikiReference,\n            AuthenticationAction.RETRIEVE_USERNAME);\n\n        when(this.xwiki.evaluateTemplate(\"forgotusername.vm\", context)).thenReturn(\"Forgot user name content\");\n\n        ResourceReferenceHandlerChain chain = mock(ResourceReferenceHandlerChain.class);\n        this.resourceReferenceHandler.handle(resourceReference, chain);\n\n        verify(response).setContentType(\"text/html; charset=UTF-8\");\n        verify(this.xWikiContextInitializer).initialize(any(ExecutionContext.class));\n        verify(servletOutputStream).write(\"Forgot user name content\".getBytes(StandardCharsets.UTF_8));\n        verify(chain).handleNext(resourceReference);\n        verify(context).setWikiReference(wikiReference);\n        verify(context).setWikiReference(currentWiki);\n    }\n}",
    "code_after_change": "{\n    @InjectMockComponents\n    private AuthenticationResourceReferenceHandler resourceReferenceHandler;\n\n    @MockComponent\n    private XWikiContextInitializer xWikiContextInitializer;\n\n    @MockComponent\n    private Execution execution;\n\n    @MockComponent\n    private WikiDescriptorManager wikiDescriptorManager;\n\n    private XWikiResponse response;\n\n    private XWiki xwiki;\n\n    private XWikiContext context;\n\n    private ServletOutputStream servletOutputStream;\n\n    private WikiReference currentWiki;\n\n    @BeforeEach\n    void setup() throws XWikiException, IOException\n    {\n        ExecutionContext executionContext = mock(ExecutionContext.class);\n        when(this.execution.getContext()).thenReturn(executionContext);\n        this.context = mock(XWikiContext.class);\n        when(this.xWikiContextInitializer.initialize(executionContext)).thenReturn(context);\n        this.response = mock(XWikiResponse.class);\n        when(context.getResponse()).thenReturn(response);\n        this.xwiki = mock(XWiki.class);\n        when(context.getWiki()).thenReturn(xwiki);\n        when(this.xwiki.getEncoding()).thenReturn(\"UTF-8\");\n        XWikiPluginManager pluginManager = mock(XWikiPluginManager.class);\n        when(this.xwiki.getPluginManager()).thenReturn(pluginManager);\n        when(pluginManager.endParsing(any(), eq(context)))\n            .then(invocationOnMock -> invocationOnMock.getArgument(0));\n        this.servletOutputStream = mock(ServletOutputStream.class);\n        when(this.response.getOutputStream()).thenReturn(servletOutputStream);\n        currentWiki = new WikiReference(\"currentWiki\");\n        when(context.getWikiReference()).thenReturn(currentWiki);\n    }\n\n    @Test\n    void getSupportedResourceReferences()\n    {\n        assertEquals(Collections.singletonList(AuthenticationResourceReference.TYPE),\n            this.resourceReferenceHandler.getSupportedResourceReferences());\n    }\n\n    @Test\n    void handleResetPassword() throws Exception\n    {\n        WikiReference wikiReference = new WikiReference(\"foo\");\n        when(this.wikiDescriptorManager.exists(\"foo\")).thenReturn(false);\n        AuthenticationResourceReference resourceReference = new AuthenticationResourceReference(\n            wikiReference,\n            AuthenticationAction.RESET_PASSWORD);\n\n        ResourceReferenceHandlerChain chain = mock(ResourceReferenceHandlerChain.class);\n        ResourceReferenceHandlerException exception =\n            assertThrows(ResourceReferenceHandlerException.class,\n                () -> this.resourceReferenceHandler.handle(resourceReference, chain));\n        assertEquals(\"The wiki [foo] does not exist.\", exception.getMessage());\n\n        when(this.wikiDescriptorManager.exists(\"foo\")).thenReturn(true);\n        when(this.xwiki.evaluateTemplate(\"resetpassword.vm\", context)).thenReturn(\"Reset password content\");\n        this.resourceReferenceHandler.handle(resourceReference, chain);\n\n        verify(response).setContentType(\"text/html; charset=UTF-8\");\n        verify(this.xWikiContextInitializer).initialize(any(ExecutionContext.class));\n        verify(servletOutputStream).write(\"Reset password content\".getBytes(StandardCharsets.UTF_8));\n        verify(chain).handleNext(resourceReference);\n        verify(context).setWikiReference(wikiReference);\n        verify(context).setWikiReference(currentWiki);\n    }\n\n    @Test\n    void handleForgotUsername() throws Exception\n    {\n        WikiReference wikiReference = new WikiReference(\"bar\");\n        when(this.wikiDescriptorManager.exists(\"bar\")).thenReturn(false);\n        AuthenticationResourceReference resourceReference = new AuthenticationResourceReference(\n            wikiReference,\n            AuthenticationAction.RETRIEVE_USERNAME);\n\n        ResourceReferenceHandlerChain chain = mock(ResourceReferenceHandlerChain.class);\n        ResourceReferenceHandlerException exception =\n            assertThrows(ResourceReferenceHandlerException.class,\n                () -> this.resourceReferenceHandler.handle(resourceReference, chain));\n        assertEquals(\"The wiki [bar] does not exist.\", exception.getMessage());\n\n        when(this.wikiDescriptorManager.exists(\"bar\")).thenReturn(true);\n        when(this.xwiki.evaluateTemplate(\"forgotusername.vm\", context)).thenReturn(\"Forgot user name content\");\n\n        this.resourceReferenceHandler.handle(resourceReference, chain);\n        verify(response).setContentType(\"text/html; charset=UTF-8\");\n        verify(this.xWikiContextInitializer).initialize(any(ExecutionContext.class));\n        verify(servletOutputStream).write(\"Forgot user name content\".getBytes(StandardCharsets.UTF_8));\n        verify(chain).handleNext(resourceReference);\n        verify(context).setWikiReference(wikiReference);\n        verify(context).setWikiReference(currentWiki);\n    }\n\n    @Test\n    void handleForgotUsernameWikiDescriptorError() throws Exception\n    {\n        WikiReference wikiReference = new WikiReference(\"bar\");\n        when(this.wikiDescriptorManager.exists(\"bar\")).thenThrow(new WikiManagerException(\"Cannot access wiki\"));\n        AuthenticationResourceReference resourceReference = new AuthenticationResourceReference(\n            wikiReference,\n            AuthenticationAction.RETRIEVE_USERNAME);\n\n        ResourceReferenceHandlerChain chain = mock(ResourceReferenceHandlerChain.class);\n        ResourceReferenceHandlerException exception =\n            assertThrows(ResourceReferenceHandlerException.class,\n                () -> this.resourceReferenceHandler.handle(resourceReference, chain));\n        assertEquals(\"Error when checking if wiki [bar] exists.\", exception.getMessage());\n    }\n}",
    "patch": "@@ -31,11 +31,14 @@\n import org.xwiki.context.ExecutionContext;\n import org.xwiki.model.reference.WikiReference;\n import org.xwiki.resource.ResourceReferenceHandlerChain;\n+import org.xwiki.resource.ResourceReferenceHandlerException;\n import org.xwiki.security.authentication.AuthenticationAction;\n import org.xwiki.security.authentication.AuthenticationResourceReference;\n import org.xwiki.test.junit5.mockito.ComponentTest;\n import org.xwiki.test.junit5.mockito.InjectMockComponents;\n import org.xwiki.test.junit5.mockito.MockComponent;\n+import org.xwiki.wiki.descriptor.WikiDescriptorManager;\n+import org.xwiki.wiki.manager.WikiManagerException;\n \n import com.xpn.xwiki.XWiki;\n import com.xpn.xwiki.XWikiContext;\n@@ -45,6 +48,7 @@\n import com.xpn.xwiki.web.XWikiResponse;\n \n import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.ArgumentMatchers.eq;\n import static org.mockito.Mockito.mock;\n@@ -69,6 +73,9 @@ class AuthenticationResourceReferenceHandlerTest\n     @MockComponent\n     private Execution execution;\n \n+    @MockComponent\n+    private WikiDescriptorManager wikiDescriptorManager;\n+\n     private XWikiResponse response;\n \n     private XWiki xwiki;\n@@ -112,13 +119,19 @@ void getSupportedResourceReferences()\n     void handleResetPassword() throws Exception\n     {\n         WikiReference wikiReference = new WikiReference(\"foo\");\n+        when(this.wikiDescriptorManager.exists(\"foo\")).thenReturn(false);\n         AuthenticationResourceReference resourceReference = new AuthenticationResourceReference(\n             wikiReference,\n             AuthenticationAction.RESET_PASSWORD);\n \n-        when(this.xwiki.evaluateTemplate(\"resetpassword.vm\", context)).thenReturn(\"Reset password content\");\n-\n         ResourceReferenceHandlerChain chain = mock(ResourceReferenceHandlerChain.class);\n+        ResourceReferenceHandlerException exception =\n+            assertThrows(ResourceReferenceHandlerException.class,\n+                () -> this.resourceReferenceHandler.handle(resourceReference, chain));\n+        assertEquals(\"The wiki [foo] does not exist.\", exception.getMessage());\n+\n+        when(this.wikiDescriptorManager.exists(\"foo\")).thenReturn(true);\n+        when(this.xwiki.evaluateTemplate(\"resetpassword.vm\", context)).thenReturn(\"Reset password content\");\n         this.resourceReferenceHandler.handle(resourceReference, chain);\n \n         verify(response).setContentType(\"text/html; charset=UTF-8\");\n@@ -133,20 +146,42 @@ void handleResetPassword() throws Exception\n     void handleForgotUsername() throws Exception\n     {\n         WikiReference wikiReference = new WikiReference(\"bar\");\n+        when(this.wikiDescriptorManager.exists(\"bar\")).thenReturn(false);\n         AuthenticationResourceReference resourceReference = new AuthenticationResourceReference(\n             wikiReference,\n             AuthenticationAction.RETRIEVE_USERNAME);\n \n+        ResourceReferenceHandlerChain chain = mock(ResourceReferenceHandlerChain.class);\n+        ResourceReferenceHandlerException exception =\n+            assertThrows(ResourceReferenceHandlerException.class,\n+                () -> this.resourceReferenceHandler.handle(resourceReference, chain));\n+        assertEquals(\"The wiki [bar] does not exist.\", exception.getMessage());\n+\n+        when(this.wikiDescriptorManager.exists(\"bar\")).thenReturn(true);\n         when(this.xwiki.evaluateTemplate(\"forgotusername.vm\", context)).thenReturn(\"Forgot user name content\");\n \n-        ResourceReferenceHandlerChain chain = mock(ResourceReferenceHandlerChain.class);\n         this.resourceReferenceHandler.handle(resourceReference, chain);\n-\n         verify(response).setContentType(\"text/html; charset=UTF-8\");\n         verify(this.xWikiContextInitializer).initialize(any(ExecutionContext.class));\n         verify(servletOutputStream).write(\"Forgot user name content\".getBytes(StandardCharsets.UTF_8));\n         verify(chain).handleNext(resourceReference);\n         verify(context).setWikiReference(wikiReference);\n         verify(context).setWikiReference(currentWiki);\n     }\n+\n+    @Test\n+    void handleForgotUsernameWikiDescriptorError() throws Exception\n+    {\n+        WikiReference wikiReference = new WikiReference(\"bar\");\n+        when(this.wikiDescriptorManager.exists(\"bar\")).thenThrow(new WikiManagerException(\"Cannot access wiki\"));\n+        AuthenticationResourceReference resourceReference = new AuthenticationResourceReference(\n+            wikiReference,\n+            AuthenticationAction.RETRIEVE_USERNAME);\n+\n+        ResourceReferenceHandlerChain chain = mock(ResourceReferenceHandlerChain.class);\n+        ResourceReferenceHandlerException exception =\n+            assertThrows(ResourceReferenceHandlerException.class,\n+                () -> this.resourceReferenceHandler.handle(resourceReference, chain));\n+        assertEquals(\"Error when checking if wiki [bar] exists.\", exception.getMessage());\n+    }\n }",
    "function_modified_lines": {
      "added": [
        "    @MockComponent\n",
        "    private WikiDescriptorManager wikiDescriptorManager;\n",
        "\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-79"
    ],
    "cve_description": "XWiki Commons are technical libraries common to several other top level XWiki projects. It was possible to inject some code using the URL of authenticated endpoints. This problem has been patched on XWiki 13.10.11, 14.4.7 and 14.10.",
    "id": 12335
  },
  {
    "cve_id": "CVE-2023-29515",
    "code_before_change": "{\n    private static final String USERNAME = AppsLiveTableIT.class.getSimpleName();\n    private static final String PASSWORD = \"simplepassword\";\n\n    private AppWithinMinutesHomePage appWithinMinutesHomePage;\n    private String appName;\n\n    @BeforeAll\n    public void setupClass(TestUtils testUtils)\n    {\n        testUtils.createUserAndLogin(USERNAME, PASSWORD);\n    }\n\n    @BeforeEach\n    public void setUp(TestReference testReference, TestUtils testUtils, LogCaptureConfiguration logCaptureConfiguration)\n    {\n        logCaptureConfiguration.registerExpected(\"WikiComponentException: Registering UI \"\n            + \"extensions at wiki level requires wiki administration rights\");\n\n        testUtils.login(USERNAME, PASSWORD);\n        this.appName = testReference.getLastSpaceReference().getName();\n        appWithinMinutesHomePage = createApplication(appName);\n    }\n\n    /**\n     * Creates an application with the specified name. The application class will have just one field.\n     *\n     * @param appName the name of the application to create\n     */\n    private AppWithinMinutesHomePage createApplication(String appName)\n    {\n        ApplicationCreatePage appCreatePage = AppWithinMinutesHomePage.gotoPage().clickCreateApplication();\n        appCreatePage.setApplicationName(appName);\n        ApplicationClassEditPage classEditPage = appCreatePage.clickNextStep();\n        classEditPage.addField(\"Short Text\");\n        classEditPage.clickNextStep().clickNextStep().clickFinish();\n        return AppWithinMinutesHomePage.gotoPage();\n    }\n\n    @Order(1)\n    @Test\n    void deleteApplication()\n    {\n        // Check the the applications live table lists the created application.\n        ApplicationsLiveTableElement appsLiveTable = appWithinMinutesHomePage.getAppsLiveTable();\n        assertTrue(appsLiveTable.hasColumn(\"Actions\"));\n        appsLiveTable.filterApplicationName(appName.substring(0, 3));\n        assertTrue(appsLiveTable.isApplicationListed(appName));\n\n        // Click the delete icon then cancel the confirmation.\n        appsLiveTable.clickDeleteApplication(appName).clickNo();\n        // We should be taken back to the AppWithinMinutes home page.\n        appWithinMinutesHomePage = new AppWithinMinutesHomePage();\n        appsLiveTable = appWithinMinutesHomePage.getAppsLiveTable();\n        // The application name filter should've been preserved.\n        assertEquals(appName.substring(0, 3), appsLiveTable.getApplicationNameFilter());\n\n        // Click the delete icon again and this confirm the action.\n        appsLiveTable.clickDeleteApplication(appName).clickYes();\n        // We should be taken back to the AppWithinMinutes home page.\n        appWithinMinutesHomePage = new AppWithinMinutesHomePage();\n        appsLiveTable = appWithinMinutesHomePage.getAppsLiveTable();\n        // The application name filter should've been preserved.\n        assertEquals(appName.substring(0, 3), appsLiveTable.getApplicationNameFilter());\n        // And the deleted application shouldn't be listed anymore.\n        assertFalse(appsLiveTable.isApplicationListed(appName));\n    }\n\n    @Order(2)\n    @Test\n    void testEditApplication()\n    {\n        // Edit the application.\n        ApplicationsLiveTableElement appsLiveTable = appWithinMinutesHomePage.getAppsLiveTable();\n        ApplicationClassEditPage classEditor = appsLiveTable.clickEditApplication(appName);\n\n        // Edit the existing class field.\n        ClassFieldEditPane fieldEditPane = new ClassFieldEditPane(\"shortText1\");\n        fieldEditPane.setPrettyName(\"City Name\");\n        fieldEditPane.openConfigPanel();\n        fieldEditPane.setName(\"cityName\");\n\n        // Move to the next step.\n        ApplicationHomeEditPage homeEditPage = classEditor.clickNextStep().clickNextStep();\n        homeEditPage.setDescription(\"demo\");\n\n        // Finish editing.\n        ApplicationHomePage homePage = homeEditPage.clickFinish();\n        assertTrue(homePage.getContent().contains(\"demo\"));\n    }\n\n    @Order(3)\n    @Test\n    void testActionRights(TestUtils testUtils, TestReference testReference)\n    {\n        // set some rights before the test\n        DocumentReference xwikiPreferences = new DocumentReference(\"xwiki\", \"XWiki\", \"XWikiPreferences\");\n\n        testUtils.loginAsSuperAdmin();\n        String anotherUserName = \"someOtherUser\";\n        testUtils.createPage(xwikiPreferences, \"\");\n        testUtils.addObject(xwikiPreferences, \"XWiki.XWikiGlobalRights\",\n            \"levels\", \"edit,script\",\n            \"allow\", \"1\",\n            \"users\", String.format(\"XWiki.%s,XWiki.%s\", USERNAME, anotherUserName));\n\n        testUtils.login(USERNAME, PASSWORD);\n        appWithinMinutesHomePage = AppWithinMinutesHomePage.gotoPage();\n        try {\n            // The application author should be able to edit and delete the application.\n            ApplicationsLiveTableElement appsLiveTable = appWithinMinutesHomePage.getAppsLiveTable();\n            appsLiveTable.filterApplicationName(appName);\n            assertTrue(appsLiveTable.canEditApplication(appName));\n            assertTrue(appsLiveTable.canDeleteApplication(appName));\n\n            // Logout. Guests shouldn't be able to edit nor delete the application.\n            appWithinMinutesHomePage.logout();\n            testUtils.recacheSecretToken();\n            appWithinMinutesHomePage = new AppWithinMinutesHomePage();\n            appsLiveTable = appWithinMinutesHomePage.getAppsLiveTable();\n            appsLiveTable.filterApplicationName(appName);\n            assertFalse(appsLiveTable.canEditApplication(appName));\n            assertFalse(appsLiveTable.canDeleteApplication(appName));\n\n            // Login with a different user. The new user shouldn't be able to delete the application.\n            testUtils.createUserAndLogin(anotherUserName, \"somePassword\");\n            appsLiveTable = AppWithinMinutesHomePage.gotoPage().getAppsLiveTable();\n            appsLiveTable.filterApplicationName(appName);\n            assertTrue(appsLiveTable.canEditApplication(appName));\n            assertFalse(appsLiveTable.canDeleteApplication(appName));\n        } finally {\n            // We don't want to keep the rights\n            testUtils.deletePage(xwikiPreferences);\n        }\n    }\n}",
    "code_after_change": "{\n        testUtils.loginAsSuperAdmin();\n        // The application creator needs script rights in order to execute the scripts generated by the wizard.\n        testUtils.setGlobalRights(\"\", \"XWiki.\" + USERNAME, \"script\", true);\n        testUtils.createUserAndLogin(USERNAME, PASSWORD);\n    }",
    "patch": "@@ -58,6 +58,9 @@ class AppsLiveTableIT\n     @BeforeAll\n     public void setupClass(TestUtils testUtils)\n     {\n+        testUtils.loginAsSuperAdmin();\n+        // The application creator needs script rights in order to execute the scripts generated by the wizard.\n+        testUtils.setGlobalRights(\"\", \"XWiki.\" + USERNAME, \"script\", true);\n         testUtils.createUserAndLogin(USERNAME, PASSWORD);\n     }\n \n@@ -179,6 +182,7 @@ void testActionRights(TestUtils testUtils, TestReference testReference)\n             assertTrue(appsLiveTable.canEditApplication(appName));\n             assertFalse(appsLiveTable.canDeleteApplication(appName));\n         } finally {\n+            testUtils.loginAsSuperAdmin();\n             // We don't want to keep the rights\n             testUtils.deletePage(xwikiPreferences);\n         }",
    "function_modified_lines": {
      "added": [
        "        testUtils.loginAsSuperAdmin();\n",
        "        // The application creator needs script rights in order to execute the scripts generated by the wizard.\n",
        "        testUtils.setGlobalRights(\"\", \"XWiki.\" + USERNAME, \"script\", true);\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-79"
    ],
    "cve_description": "XWiki Platform is a generic wiki platform offering runtime services for applications built on top of it. Any user who can create a space can become admin of that space through App Within Minutes. The admin right implies the script right and thus allows JavaScript injection. The vulnerability can be exploited by creating an app in App Within Minutes. If the button should be disabled because the user doesn't have global edit right, the app can also be created by directly opening `/xwiki/bin/view/AppWithinMinutes/CreateApplication?wizard=true` on the XWiki installation. This has been patched in XWiki 13.10.11, 14.4.8, 14.10.1 and 15.0 RC1 by not granting the space admin right if the user doesn't have script right on the space where the app is created. Error message are displayed to warn the user that the app will be broken in this case. Users who became space admin through this vulnerability won't loose the space admin right due to the fix, so it is advised to check if all users who created AWM apps should keep their space admin rights. Users are advised to upgrade. There are no known workarounds for this vulnerability.",
    "id": 12339
  },
  {
    "cve_id": "CVE-2023-35157",
    "code_before_change": "        assertEquals(1, macroAttachmentsPane.getNumberOfAttachmentsDisplayed());\n        assertEquals(1, pageAttachmentsPane.getNumberOfAttachmentsDisplayed());\n        macroAttachmentsPane.filterColumn(2, \" \");\n\n        pageAttachmentsPane.filterColumn(2, SECOND_ATTACHMENT);\n        assertEquals(2, macroAttachmentsPane.getNumberOfAttachmentsDisplayed());\n        assertEquals(1, pageAttachmentsPane.getNumberOfAttachmentsDisplayed());\n        pageAttachmentsPane.filterColumn(2, \" \");\n\n        macroAttachmentsPane.filterColumn(1, \"Image\");\n        assertEquals(1, macroAttachmentsPane.getNumberOfAttachmentsDisplayed());\n        assertEquals(1, pageAttachmentsPane.getNumberOfAttachmentsDisplayed());\n        macroAttachmentsPane.filterColumn(1, CHOICE_EMPTY);\n    }\n\n    @Test\n    @Order(7)\n    void addSeveralAttachmentsAtOnce(TestUtils setup, TestReference testReference, TestConfiguration testConfiguration)\n    {\n        setup.loginAsSuperAdmin();\n        setup.createPage(testReference, \"\");\n\n        // Upload 4 files at once.\n        AttachmentsPane attachmentsPane = new AttachmentsViewPage().openAttachmentsDocExtraPane();\n        attachmentsPane.setFilesToUpload(List.of(\n            getFileToUpload(testConfiguration, FIRST_ATTACHMENT).getAbsolutePath(),\n            getFileToUpload(testConfiguration, SECOND_ATTACHMENT).getAbsolutePath(),\n            getFileToUpload(testConfiguration, IMAGE_ATTACHMENT).getAbsolutePath(),\n            getFileToUpload(testConfiguration, SMALL_SIZE_ATTACHMENT).getAbsolutePath()\n        ));\n        // Wait for the last file to be uploaded.\n        attachmentsPane.waitForUploadToFinish(SMALL_SIZE_ATTACHMENT);\n\n        assertEquals(4, attachmentsPane.getNumberOfAttachments());\n    }\n\n    private String getAttachmentsMacroContent(DocumentReference docRef)\n    {\n        StringBuilder sb = new StringBuilder();\n\n        sb.append(\"{{velocity}}\\n\");\n        sb.append(\"#template('attachment_macros.vm')\\n\");\n        sb.append(\"#set($attachmentsDoc = $xwiki.getDocument(\\\"\" + docRef + \"\\\"))\\n\");\n        sb.append(\"#showAttachmentsLiveData($attachmentsDoc 'testAttachments')\\n\");\n        sb.append(\"{{/velocity}}\");\n\n        return sb.toString();\n    }\n}",
    "code_after_change": "        macroAttachmentsPane.filterColumn(2, \" \");\n\n        pageAttachmentsPane.filterColumn(2, SECOND_ATTACHMENT);\n        assertEquals(2, macroAttachmentsPane.getNumberOfAttachmentsDisplayed());\n        assertEquals(1, pageAttachmentsPane.getNumberOfAttachmentsDisplayed());\n        pageAttachmentsPane.filterColumn(2, \" \");\n\n        macroAttachmentsPane.filterColumn(1, \"Image\");\n        assertEquals(1, macroAttachmentsPane.getNumberOfAttachmentsDisplayed());\n        assertEquals(1, pageAttachmentsPane.getNumberOfAttachmentsDisplayed());\n        macroAttachmentsPane.filterColumn(1, CHOICE_EMPTY);\n    }\n\n    @Test\n    @Order(7)\n    void addSeveralAttachmentsAtOnce(TestUtils setup, TestReference testReference, TestConfiguration testConfiguration)\n    {\n        setup.loginAsSuperAdmin();\n        setup.createPage(testReference, \"\");\n\n        // Upload 4 files at once.\n        AttachmentsPane attachmentsPane = new AttachmentsViewPage().openAttachmentsDocExtraPane();\n        attachmentsPane.setFilesToUpload(List.of(\n            getFileToUpload(testConfiguration, FIRST_ATTACHMENT).getAbsolutePath(),\n            getFileToUpload(testConfiguration, SECOND_ATTACHMENT).getAbsolutePath(),\n            getFileToUpload(testConfiguration, IMAGE_ATTACHMENT).getAbsolutePath(),\n            getFileToUpload(testConfiguration, SMALL_SIZE_ATTACHMENT).getAbsolutePath()\n        ));\n        // Wait for the last file to be uploaded.\n        attachmentsPane.waitForUploadToFinish(SMALL_SIZE_ATTACHMENT);\n\n        assertEquals(4, attachmentsPane.getNumberOfAttachments());\n    }\n\n    /**\n     * Check the display of delete attachment message when it contains special characters.\n     */\n    @Test\n    @Order(8)\n    void deleteAttachmentWithSpecialChar(TestUtils setup, TestReference testReference)\n    {\n        setup.loginAsSuperAdmin();\n        setup.createPage(testReference, \"Empty content\");\n        String attachmentName = \"<img src=x>\";\n        AttachmentReference attachmentReference = new AttachmentReference(attachmentName, testReference);\n        setup.gotoPage(attachmentReference, \"delattachment\");\n        BasePage basePage = new BasePage();\n        assertEquals(String.format(\"Error\\n\"\n                + \"Failed to delete attachment %s\\n\"\n                + \"This attachment does not exist.\", attachmentName),\n                basePage.getXWikiMessageContent());\n    }\n\n    private String getAttachmentsMacroContent(DocumentReference docRef)\n    {\n        StringBuilder sb = new StringBuilder();\n\n        sb.append(\"{{velocity}}\\n\");\n        sb.append(\"#template('attachment_macros.vm')\\n\");\n        sb.append(\"#set($attachmentsDoc = $xwiki.getDocument(\\\"\" + docRef + \"\\\"))\\n\");\n        sb.append(\"#showAttachmentsLiveData($attachmentsDoc 'testAttachments')\\n\");\n        sb.append(\"{{/velocity}}\");\n\n        return sb.toString();\n    }\n}",
    "patch": "@@ -30,12 +30,14 @@\n import org.openqa.selenium.By;\n import org.xwiki.flamingo.skin.test.po.AttachmentsPane;\n import org.xwiki.flamingo.skin.test.po.AttachmentsViewPage;\n+import org.xwiki.model.reference.AttachmentReference;\n import org.xwiki.model.reference.DocumentReference;\n import org.xwiki.rest.model.jaxb.Page;\n import org.xwiki.test.docker.junit5.TestConfiguration;\n import org.xwiki.test.docker.junit5.TestReference;\n import org.xwiki.test.docker.junit5.UITest;\n import org.xwiki.test.ui.TestUtils;\n+import org.xwiki.test.ui.po.BasePage;\n import org.xwiki.test.ui.po.ChangesPane;\n import org.xwiki.test.ui.po.ComparePage;\n import org.xwiki.test.ui.po.DeletePageOutcomePage;\n@@ -425,6 +427,25 @@ void addSeveralAttachmentsAtOnce(TestUtils setup, TestReference testReference, T\n         assertEquals(4, attachmentsPane.getNumberOfAttachments());\n     }\n \n+    /**\n+     * Check the display of delete attachment message when it contains special characters.\n+     */\n+    @Test\n+    @Order(8)\n+    void deleteAttachmentWithSpecialChar(TestUtils setup, TestReference testReference)\n+    {\n+        setup.loginAsSuperAdmin();\n+        setup.createPage(testReference, \"Empty content\");\n+        String attachmentName = \"<img src=x>\";\n+        AttachmentReference attachmentReference = new AttachmentReference(attachmentName, testReference);\n+        setup.gotoPage(attachmentReference, \"delattachment\");\n+        BasePage basePage = new BasePage();\n+        assertEquals(String.format(\"Error\\n\"\n+                + \"Failed to delete attachment %s\\n\"\n+                + \"This attachment does not exist.\", attachmentName),\n+                basePage.getXWikiMessageContent());\n+    }\n+\n     private String getAttachmentsMacroContent(DocumentReference docRef)\n     {\n         StringBuilder sb = new StringBuilder();",
    "function_modified_lines": {
      "added": [
        "    /**\n",
        "     * Check the display of delete attachment message when it contains special characters.\n",
        "     */\n",
        "    @Test\n",
        "    @Order(8)\n",
        "    void deleteAttachmentWithSpecialChar(TestUtils setup, TestReference testReference)\n",
        "    {\n",
        "        setup.loginAsSuperAdmin();\n",
        "        setup.createPage(testReference, \"Empty content\");\n",
        "        String attachmentName = \"<img src=x>\";\n",
        "        AttachmentReference attachmentReference = new AttachmentReference(attachmentName, testReference);\n",
        "        setup.gotoPage(attachmentReference, \"delattachment\");\n",
        "        BasePage basePage = new BasePage();\n",
        "        assertEquals(String.format(\"Error\\n\"\n",
        "                + \"Failed to delete attachment %s\\n\"\n",
        "                + \"This attachment does not exist.\", attachmentName),\n",
        "                basePage.getXWikiMessageContent());\n",
        "    }\n",
        "\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-79"
    ],
    "cve_description": "XWiki Platform is a generic wiki platform offering runtime services for applications built on top of it. It's possible to perform an XSS by forging a request to a delete attachment action with a specific attachment name. Now this XSS can be exploited only if the attacker knows the CSRF token of the user, or if the user ignores the warning about the missing CSRF token. The vulnerability has been patched in XWiki 15.1-rc-1 and XWiki 14.10.6.",
    "id": 12355
  },
  {
    "cve_id": "CVE-2023-45137",
    "code_before_change": "{\n    /**\n     * The name of the template to test.\n     */\n    private static final String CREATE_INLINE_VM = \"createinline.vm\";\n\n    private VelocityManager velocityManager;\n\n    @Inject\n    private TemplateManager templateManager;\n\n    @BeforeEach\n    void setup() throws Exception\n    {\n        this.velocityManager = this.oldcore.getMocker().getInstance(VelocityManager.class);\n        // Set an empty list of recommended template providers to avoid a Velocity error.\n        this.velocityManager.getVelocityContext().put(\"recommendedTemplateProviders\", List.of());\n    }\n\n    /**\n     * Test that when there is a name validation error, the name is correctly escaped.\n     */\n    @Test\n    void testNameValidationError() throws Exception\n    {\n        // Set \"createException\" to an XWikiException to simulate a validation error.\n        String documentReference = \"xwiki:space.</div>page\";\n        Object[] args = { documentReference };\n        XWikiException invalidNameException = new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n            XWikiException.ERROR_XWIKI_APP_DOCUMENT_NAME_INVALID,\n            \"Cannot create document {0} because its name does not respect the name strategy of the wiki.\", null,\n            args);\n        this.velocityManager.getVelocityContext().put(\"createException\", invalidNameException);\n        this.velocityManager.getVelocityContext().put(\"invalidNameReference\", documentReference);\n\n        // Render the template.\n        Document document = Jsoup.parse(this.templateManager.render(CREATE_INLINE_VM));\n        Element errormessage = document.getElementsByClass(\"errormessage\").first();\n        assertNotNull(errormessage);\n        String expectedMessage = String.format(\"entitynamevalidation.create.invalidname [%s]\", documentReference);\n        assertEquals(expectedMessage, errormessage.text());\n    }\n}",
    "code_after_change": "{\n    /**\n     * The name of the template to test.\n     */\n    private static final String CREATE_INLINE_VM = \"createinline.vm\";\n\n    private static final String DOCUMENT_REFERENCE = \"xwiki:space.</div>page\";\n\n    private static final String CREATE_EXCEPTION_VELOCITY_KEY = \"createException\";\n\n    private static final String ERROR_MESSAGE_CLASS = \"errormessage\";\n\n    private VelocityManager velocityManager;\n\n    @Inject\n    private TemplateManager templateManager;\n\n    @BeforeEach\n    void setup() throws Exception\n    {\n        this.velocityManager = this.oldcore.getMocker().getInstance(VelocityManager.class);\n        // Set an empty list of recommended template providers to avoid a Velocity error.\n        this.velocityManager.getVelocityContext().put(\"recommendedTemplateProviders\", List.of());\n    }\n\n    /**\n     * Test that when there is a name validation error, the name is correctly escaped.\n     */\n    @Test\n    void testNameValidationError() throws Exception\n    {\n        // Set \"createException\" to an XWikiException to simulate a validation error.\n        Object[] args = { DOCUMENT_REFERENCE };\n        XWikiException invalidNameException = new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n            XWikiException.ERROR_XWIKI_APP_DOCUMENT_NAME_INVALID,\n            \"Cannot create document {0} because its name does not respect the name strategy of the wiki.\", null,\n            args);\n        this.velocityManager.getVelocityContext().put(CREATE_EXCEPTION_VELOCITY_KEY, invalidNameException);\n        this.velocityManager.getVelocityContext().put(\"invalidNameReference\", DOCUMENT_REFERENCE);\n\n        // Render the template.\n        Document document = Jsoup.parse(this.templateManager.render(CREATE_INLINE_VM));\n        Element errormessage = document.getElementsByClass(ERROR_MESSAGE_CLASS).first();\n        assertNotNull(errormessage);\n        String expectedMessage = String.format(\"entitynamevalidation.create.invalidname [%s]\", DOCUMENT_REFERENCE);\n        assertEquals(expectedMessage, errormessage.text());\n    }\n\n    /**\n     * Test that when there is an exception about the document already existing, the name is correctly escaped.\n     */\n    @Test\n    void testDocumentAlreadyExistsError() throws Exception\n    {\n        // Set \"createException\" to an XWikiException to simulate a document exists already error.\n        String urlToDocument = \"space/%3C%2Fdiv%3Epage\";\n        Object[] args = { DOCUMENT_REFERENCE };\n        XWikiException documentAlreadyExistsException = new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n            XWikiException.ERROR_XWIKI_APP_DOCUMENT_NOT_EMPTY,\n            \"Cannot create document {0} because it already has content\", null, args);\n        this.velocityManager.getVelocityContext().put(CREATE_EXCEPTION_VELOCITY_KEY, documentAlreadyExistsException);\n        this.velocityManager.getVelocityContext().put(\"existingDocumentReference\", DOCUMENT_REFERENCE);\n\n        // Render the template.\n        Document document = Jsoup.parse(this.templateManager.render(CREATE_INLINE_VM));\n        Element errormessage = document.getElementsByClass(ERROR_MESSAGE_CLASS).first();\n        assertNotNull(errormessage);\n        String viewURL = String.format(\"/xwiki/bin/view/%s\", urlToDocument);\n        String editURL = String.format(\"/xwiki/bin/edit/%s\", urlToDocument);\n        String expectedMessage = String.format(\"core.create.page.error.docalreadyexists [%s, %s, %s]\",\n            DOCUMENT_REFERENCE, viewURL, editURL);\n        assertEquals(expectedMessage, errormessage.text());\n    }\n}",
    "patch": "@@ -51,6 +51,12 @@ class CreateInlinePageTest extends PageTest\n      */\n     private static final String CREATE_INLINE_VM = \"createinline.vm\";\n \n+    private static final String DOCUMENT_REFERENCE = \"xwiki:space.</div>page\";\n+\n+    private static final String CREATE_EXCEPTION_VELOCITY_KEY = \"createException\";\n+\n+    private static final String ERROR_MESSAGE_CLASS = \"errormessage\";\n+\n     private VelocityManager velocityManager;\n \n     @Inject\n@@ -71,20 +77,45 @@ void setup() throws Exception\n     void testNameValidationError() throws Exception\n     {\n         // Set \"createException\" to an XWikiException to simulate a validation error.\n-        String documentReference = \"xwiki:space.</div>page\";\n-        Object[] args = { documentReference };\n+        Object[] args = { DOCUMENT_REFERENCE };\n         XWikiException invalidNameException = new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n             XWikiException.ERROR_XWIKI_APP_DOCUMENT_NAME_INVALID,\n             \"Cannot create document {0} because its name does not respect the name strategy of the wiki.\", null,\n             args);\n-        this.velocityManager.getVelocityContext().put(\"createException\", invalidNameException);\n-        this.velocityManager.getVelocityContext().put(\"invalidNameReference\", documentReference);\n+        this.velocityManager.getVelocityContext().put(CREATE_EXCEPTION_VELOCITY_KEY, invalidNameException);\n+        this.velocityManager.getVelocityContext().put(\"invalidNameReference\", DOCUMENT_REFERENCE);\n+\n+        // Render the template.\n+        Document document = Jsoup.parse(this.templateManager.render(CREATE_INLINE_VM));\n+        Element errormessage = document.getElementsByClass(ERROR_MESSAGE_CLASS).first();\n+        assertNotNull(errormessage);\n+        String expectedMessage = String.format(\"entitynamevalidation.create.invalidname [%s]\", DOCUMENT_REFERENCE);\n+        assertEquals(expectedMessage, errormessage.text());\n+    }\n+\n+    /**\n+     * Test that when there is an exception about the document already existing, the name is correctly escaped.\n+     */\n+    @Test\n+    void testDocumentAlreadyExistsError() throws Exception\n+    {\n+        // Set \"createException\" to an XWikiException to simulate a document exists already error.\n+        String urlToDocument = \"space/%3C%2Fdiv%3Epage\";\n+        Object[] args = { DOCUMENT_REFERENCE };\n+        XWikiException documentAlreadyExistsException = new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n+            XWikiException.ERROR_XWIKI_APP_DOCUMENT_NOT_EMPTY,\n+            \"Cannot create document {0} because it already has content\", null, args);\n+        this.velocityManager.getVelocityContext().put(CREATE_EXCEPTION_VELOCITY_KEY, documentAlreadyExistsException);\n+        this.velocityManager.getVelocityContext().put(\"existingDocumentReference\", DOCUMENT_REFERENCE);\n \n         // Render the template.\n         Document document = Jsoup.parse(this.templateManager.render(CREATE_INLINE_VM));\n-        Element errormessage = document.getElementsByClass(\"errormessage\").first();\n+        Element errormessage = document.getElementsByClass(ERROR_MESSAGE_CLASS).first();\n         assertNotNull(errormessage);\n-        String expectedMessage = String.format(\"entitynamevalidation.create.invalidname [%s]\", documentReference);\n+        String viewURL = String.format(\"/xwiki/bin/view/%s\", urlToDocument);\n+        String editURL = String.format(\"/xwiki/bin/edit/%s\", urlToDocument);\n+        String expectedMessage = String.format(\"core.create.page.error.docalreadyexists [%s, %s, %s]\",\n+            DOCUMENT_REFERENCE, viewURL, editURL);\n         assertEquals(expectedMessage, errormessage.text());\n     }\n }",
    "function_modified_lines": {
      "added": [
        "    private static final String DOCUMENT_REFERENCE = \"xwiki:space.</div>page\";\n",
        "\n",
        "    private static final String CREATE_EXCEPTION_VELOCITY_KEY = \"createException\";\n",
        "\n",
        "    private static final String ERROR_MESSAGE_CLASS = \"errormessage\";\n",
        "\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-79"
    ],
    "cve_description": "XWiki Platform is a generic wiki platform offering runtime services for applications built on top of it. `org.xwiki.platform:xwiki-platform-web` starting in version 3.1-milestone-2 and prior to version 13.4-rc-1, as well as `org.xwiki.platform:xwiki-platform-web-templates` prior to versions 14.10.12 and 15.5-rc-1, are vulnerable to cross-site scripting. When trying to create a document that already exists, XWiki displays an error message in the form for creating it. Due to missing escaping, this error message is vulnerable to raw HTML injection and thus XSS. The injected code is the document reference of the existing document so this requires that the attacker first creates a non-empty document whose name contains the attack code. This has been patched in `org.xwiki.platform:xwiki-platform-web` version 13.4-rc-1 and `org.xwiki.platform:xwiki-platform-web-templates` versions 14.10.12 and 15.5-rc-1 by adding the appropriate escaping. The vulnerable template file `createinline.vm` is part of XWiki's WAR and can be patched by manually applying the changes from the fix.",
    "id": 12455
  },
  {
    "cve_id": "CVE-2021-4266",
    "code_before_change": "{\n      case CSS:\n        return new StringFilter() {\n          public String filter( String input ) {\n            return filter( input, \"\" );\n          }\n\n          public String filter( String input, String baseUrl ) {\n            return String.format(\n              \"\\t\\t<link href=\\\"%s%s\\\" rel=\\\"stylesheet\\\" type=\\\"text/css\\\" />\\n\",\n              baseUrl, baseUrl.endsWith( \"/\" ) && input.startsWith( \"/\" ) ? input.replaceFirst( \"/\", \"\" ) : input );\n          }\n        };\n      case JS:\n        return new StringFilter() {\n          public String filter( String input ) {\n            return filter( input, \"\" );\n          }\n\n          public String filter( String input, String baseUrl ) {\n            return String.format(\n              \"\\t\\t<script language=\\\"javascript\\\" type=\\\"text/javascript\\\" src=\\\"%s%s\\\"></script>\\n\",\n              baseUrl, baseUrl.endsWith( \"/\" ) && input.startsWith( \"/\" ) ? input.replaceFirst( \"/\", \"\" ) : input );\n          }\n        };\n      case MAP:\n        return new StringFilter() {\n          @Override\n          public String filter( String input ) {\n            return \"\";\n          }\n\n          @Override\n          public String filter( String input, String absRoot ) {\n            return \"\";\n          }\n        };\n      default:\n        return new StringFilter() {\n          public String filter( String input ) {\n            return filter( input, \"\" );\n          }\n\n          public String filter( String input, String baseUrl ) {\n            return baseUrl + input + \"\\n\";\n          }\n        };\n    }",
    "code_after_change": "{\n      case CSS:\n        return new StringFilter() {\n          public String filter( String input ) {\n            return filter( input, \"\" );\n          }\n\n          public String filter( String input, String baseUrl ) {\n            baseUrl = Encode.forHtmlAttribute( baseUrl );\n            return String.format(\n              \"\\t\\t<link href=\\\"%s%s\\\" rel=\\\"stylesheet\\\" type=\\\"text/css\\\" />\\n\",\n              baseUrl, baseUrl.endsWith( \"/\" ) && input.startsWith( \"/\" ) ? input.replaceFirst( \"/\", \"\" ) : input );\n          }\n        };\n      case JS:\n        return new StringFilter() {\n          public String filter( String input ) {\n            return filter( input, \"\" );\n          }\n\n          public String filter( String input, String baseUrl ) {\n            baseUrl = Encode.forHtmlAttribute( baseUrl );\n            return String.format(\n              \"\\t\\t<script language=\\\"javascript\\\" type=\\\"text/javascript\\\" src=\\\"%s%s\\\"></script>\\n\",\n              baseUrl, baseUrl.endsWith( \"/\" ) && input.startsWith( \"/\" ) ? input.replaceFirst( \"/\", \"\" ) : input );\n          }\n        };\n      case MAP:\n        return new StringFilter() {\n          @Override\n          public String filter( String input ) {\n            return \"\";\n          }\n\n          @Override\n          public String filter( String input, String absRoot ) {\n            return \"\";\n          }\n        };\n      default:\n        return new StringFilter() {\n          public String filter( String input ) {\n            return filter( input, \"\" );\n          }\n\n          public String filter( String input, String baseUrl ) {\n            return Encode.forHtmlAttribute( baseUrl ) + input + \"\\n\";\n          }\n        };\n    }",
    "patch": "@@ -1,5 +1,5 @@\n /*!\n- * Copyright 2002 - 2019 Webdetails, a Hitachi Vantara company.  All rights reserved.\n+ * Copyright 2002 - 2021 Webdetails, a Hitachi Vantara company.  All rights reserved.\n  *\n  * This software was developed by Webdetails and is provided under the terms\n  * of the Mozilla Public License, Version 2.0, or any later version. You may not use\n@@ -12,6 +12,7 @@\n  */\n package pt.webdetails.cpf.packager;\n \n+import org.owasp.encoder.Encode;\n import pt.webdetails.cpf.context.api.IUrlProvider;\n import pt.webdetails.cpf.packager.dependencies.CssMinifiedDependency;\n import pt.webdetails.cpf.packager.dependencies.Dependency;\n@@ -276,6 +277,7 @@ public String filter( String input ) {\n           }\n \n           public String filter( String input, String baseUrl ) {\n+            baseUrl = Encode.forHtmlAttribute( baseUrl );\n             return String.format(\n               \"\\t\\t<link href=\\\"%s%s\\\" rel=\\\"stylesheet\\\" type=\\\"text/css\\\" />\\n\",\n               baseUrl, baseUrl.endsWith( \"/\" ) && input.startsWith( \"/\" ) ? input.replaceFirst( \"/\", \"\" ) : input );\n@@ -288,6 +290,7 @@ public String filter( String input ) {\n           }\n \n           public String filter( String input, String baseUrl ) {\n+            baseUrl = Encode.forHtmlAttribute( baseUrl );\n             return String.format(\n               \"\\t\\t<script language=\\\"javascript\\\" type=\\\"text/javascript\\\" src=\\\"%s%s\\\"></script>\\n\",\n               baseUrl, baseUrl.endsWith( \"/\" ) && input.startsWith( \"/\" ) ? input.replaceFirst( \"/\", \"\" ) : input );\n@@ -312,7 +315,7 @@ public String filter( String input ) {\n           }\n \n           public String filter( String input, String baseUrl ) {\n-            return baseUrl + input + \"\\n\";\n+            return Encode.forHtmlAttribute( baseUrl ) + input + \"\\n\";\n           }\n         };\n     }",
    "function_modified_lines": {
      "added": [
        "            baseUrl = Encode.forHtmlAttribute( baseUrl );\n",
        "            baseUrl = Encode.forHtmlAttribute( baseUrl );\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-79"
    ],
    "cve_description": "A vulnerability classified as problematic has been found in Webdetails cpf up to 9.5.0.0-80. Affected is an unknown function of the file core/src/main/java/pt/webdetails/cpf/packager/DependenciesPackage.java. The manipulation of the argument baseUrl leads to cross site scripting. It is possible to launch the attack remotely. Upgrading to version 9.5.0.0-81 is able to address this issue. The name of the patch is 3bff900d228e8cae3af256b447c5d15bdb03c174. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-216468.",
    "id": 12553
  },
  {
    "cve_id": "CVE-2021-4266",
    "code_before_change": "{\n\n  private static DependenciesPackage jsDepPackage;\n  private static DependenciesPackage cssDepPackage;\n  private static DependenciesPackage mapDepPackage;\n\n  private static final String JS_PACKAGE_NAME = \"js-package\";\n  private static final String CSS_PACKAGE_NAME = \"css-package\";\n  private static final String MAP_FILE_NAME = \"map-file.css.map\";\n\n  private static IContentAccessFactory mockFactory;\n  private static IUrlProvider mockUrlProvider;\n  private static PathOrigin mockPathOrigin;\n\n  @Before\n  protected void setUp() throws Exception {\n    mockFactory = mock( IContentAccessFactory.class );\n    mockUrlProvider = mock( IUrlProvider.class );\n    mockPathOrigin = mock( PathOrigin.class );\n    when( mockPathOrigin.getUrl( anyString(), any( IUrlProvider.class ) ) ).thenAnswer( new Answer<String>() {\n      @Override\n      public String answer( InvocationOnMock invocation ) throws Throwable {\n        return (String) invocation.getArguments()[0];\n      }\n    } );\n\n    jsDepPackage =\n      new DependenciesPackage( JS_PACKAGE_NAME, DependenciesPackage.PackageType.JS, mockFactory, mockUrlProvider );\n\n    cssDepPackage =\n      new DependenciesPackage( CSS_PACKAGE_NAME, DependenciesPackage.PackageType.CSS, mockFactory, mockUrlProvider );\n\n    mapDepPackage =\n      new DependenciesPackage( MAP_FILE_NAME, DependenciesPackage.PackageType.MAP, mockFactory, mockUrlProvider );\n\n\n  }\n\n  @Test\n  public void testRegisterFileDependency() {\n    String[] fileNames = new String[]{\"file1\", \"file2\"};\n    String[] fileVersions = new String[]{\"v1\", \"v2\"};\n    String[] filePaths = new String[]{\"path1\", \"path2\"};\n\n    for ( int i = 0; i < fileNames.length; i++ ) {\n      assertTrue( jsDepPackage.registerFileDependency(\n          fileNames[ i ] + \".js\", fileVersions[ i ], mockPathOrigin, filePaths[ i ] ) );\n      assertTrue( cssDepPackage.registerFileDependency(\n          fileNames[ i ] + \".css\", fileVersions[ i ], mockPathOrigin, filePaths[ i ] ) );\n      assertTrue( mapDepPackage.registerFileDependency(\n          fileNames[ i ] + \".css.map\", fileVersions[ i ], mockPathOrigin, filePaths[ i ] ) );\n    }\n\n  }\n\n  @Test\n  public void testRegisterRawDependency() {\n    String[] fileNames = new String[]{\"file1\", \"file2\"};\n    String[] fileVersions = new String[]{\"v1\", \"v2\"};\n    String[] fileContents = new String[]{\"content1\", \"content2\"};\n\n    for ( int i = 0; i < fileNames.length; i++ ) {\n      assertTrue( jsDepPackage.registerRawDependency(\n          fileNames[ i ] + \".js\", fileVersions[ i ], fileContents[ i ] ) );\n      assertTrue( cssDepPackage.registerRawDependency(\n          fileNames[ i ] + \".css\", fileVersions[ i ], fileContents[ i ] ) );\n      assertTrue( mapDepPackage.registerRawDependency(\n          fileNames[ i ] + \".css.map\", fileVersions[ i ], fileContents[ i ] ) );\n    }\n\n  }\n\n  @Test\n  public void testRegisterDependency() {\n    String[] fileNames = new String[]{\"file1\", \"file2\"};\n    Map<String, Dependency> registry = new HashMap<String, Dependency>();\n\n    for ( int i = 0; i < fileNames.length; i++ ) {\n      assertTrue( jsDepPackage.registerDependency(\n          fileNames[ i ] + \".js\", mock( JsMinifiedDependency.class ), registry ) );\n      assertTrue( cssDepPackage.registerDependency(\n          fileNames[ i ] + \".css\", mock( CssMinifiedDependency.class ), registry ) );\n      assertTrue( mapDepPackage.registerDependency(\n          fileNames[ i ] + \".css.map\", mock( MapDependency.class ), registry ) );\n    }\n    assertEquals( fileNames.length * 3, registry.size() );\n  }\n\n\n  @Test\n  public void testGetDependencies() {\n\n\n    String jsPackagedDeps = jsDepPackage.getDependencies( true ).trim();\n    assertEquals( \"<script language=\\\"javascript\\\" type=\\\"text/javascript\\\" src=\\\"/js/\"\n        + JS_PACKAGE_NAME + \".js\\\"></script>\", jsPackagedDeps );\n\n    String cssPackagedDeps = cssDepPackage.getDependencies( true ).trim();\n    assertEquals( \"<link href=\\\"/css/\"\n        + CSS_PACKAGE_NAME + \".css\\\" rel=\\\"stylesheet\\\" type=\\\"text/css\\\" />\", cssPackagedDeps );\n\n    String mapPackagedDeps = mapDepPackage.getDependencies( true ).trim();\n    assertEquals( \"\", mapPackagedDeps );\n\n    String[] filePaths = new String[]{\"path1\", \"path2\"};\n    addFileDependencies( filePaths );\n\n    String jsUnpackagedDeps = jsDepPackage.getDependencies( false ).replaceAll( \"\\n\", \"\" ).replaceAll( \"\\t\", \"\" );\n    String jsUnpackedExpected = \"\";\n    for ( int i = 0; i < filePaths.length; i++ ) {\n      jsUnpackedExpected +=\n        \"<script language=\\\"javascript\\\" type=\\\"text/javascript\\\" src=\\\"\" + filePaths[i] + \"\\\"></script>\";\n    }\n    assertEquals( jsUnpackedExpected, jsUnpackagedDeps );\n\n    String cssUnpackagedDeps = cssDepPackage.getDependencies( false ).replaceAll( \"\\n\", \"\" ).replaceAll( \"\\t\", \"\" );\n    String cssUnpackedExpected = \"\";\n    for ( int i = 0; i < filePaths.length; i++ ) {\n      cssUnpackedExpected +=\n        \"<link href=\\\"\" + filePaths[i] + \"\\\" rel=\\\"stylesheet\\\" type=\\\"text/css\\\" />\";\n    }\n    assertEquals( cssUnpackedExpected, cssUnpackagedDeps );\n\n    String mapUnpackagedDeps = mapDepPackage.getDependencies( false ).trim();\n    assertEquals( \"\", mapUnpackagedDeps );\n\n  }\n\n  @Test\n  public void testGetDefaultFilter() {\n    StringFilter jsFilter = jsDepPackage.getDefaultFilter();\n    StringFilter cssFilter = cssDepPackage.getDefaultFilter();\n    StringFilter mapFilter = mapDepPackage.getDefaultFilter();\n\n    assertEquals( \"<script language=\\\"javascript\\\" type=\\\"text/javascript\\\" src=\\\"JS-FILTER\\\"></script>\",\n        jsFilter.filter( \"JS-FILTER\" ).trim() );\n    assertEquals( \"<link href=\\\"CSS-FILTER\\\" rel=\\\"stylesheet\\\" type=\\\"text/css\\\" />\",\n        cssFilter.filter( \"CSS-FILTER\" ).trim() );\n    assertEquals( \"\", mapFilter.filter( \"MAP-FILTER\" ) );\n  }\n\n  private static void addFileDependencies( String[] filePaths ) {\n    String[] fileNames = new String[]{\"file1\", \"file2\"};\n    String[] fileVersions = new String[]{\"v1\", \"v2\"};\n    for ( int i = 0; i < fileNames.length; i++ ) {\n      jsDepPackage.registerFileDependency( fileNames[ i ] + \".js\", fileVersions[ i ], mockPathOrigin, filePaths[ i ] );\n      cssDepPackage.registerFileDependency(\n          fileNames[ i ] + \".css\", fileVersions[ i ], mockPathOrigin, filePaths[ i ] );\n      mapDepPackage.registerFileDependency(\n          fileNames[ i ] + \".css.map\", fileVersions[ i ], mockPathOrigin, filePaths[ i ] );\n    }\n  }\n\n\n\n\n}",
    "code_after_change": "{\n\n  private static DependenciesPackage jsDepPackage;\n  private static DependenciesPackage cssDepPackage;\n  private static DependenciesPackage mapDepPackage;\n\n  private static final String JS_PACKAGE_NAME = \"js-package\";\n  private static final String CSS_PACKAGE_NAME = \"css-package\";\n  private static final String MAP_FILE_NAME = \"map-file.css.map\";\n\n  private static IContentAccessFactory mockFactory;\n  private static IUrlProvider mockUrlProvider;\n  private static PathOrigin mockPathOrigin;\n\n  @Before\n  protected void setUp() throws Exception {\n    mockFactory = mock( IContentAccessFactory.class );\n    mockUrlProvider = mock( IUrlProvider.class );\n    mockPathOrigin = mock( PathOrigin.class );\n    when( mockPathOrigin.getUrl( anyString(), any( IUrlProvider.class ) ) ).thenAnswer( new Answer<String>() {\n      @Override\n      public String answer( InvocationOnMock invocation ) throws Throwable {\n        return (String) invocation.getArguments()[0];\n      }\n    } );\n\n    jsDepPackage =\n      new DependenciesPackage( JS_PACKAGE_NAME, DependenciesPackage.PackageType.JS, mockFactory, mockUrlProvider );\n\n    cssDepPackage =\n      new DependenciesPackage( CSS_PACKAGE_NAME, DependenciesPackage.PackageType.CSS, mockFactory, mockUrlProvider );\n\n    mapDepPackage =\n      new DependenciesPackage( MAP_FILE_NAME, DependenciesPackage.PackageType.MAP, mockFactory, mockUrlProvider );\n\n\n  }\n\n  @Test\n  public void testRegisterFileDependency() {\n    String[] fileNames = new String[]{\"file1\", \"file2\"};\n    String[] fileVersions = new String[]{\"v1\", \"v2\"};\n    String[] filePaths = new String[]{\"path1\", \"path2\"};\n\n    for ( int i = 0; i < fileNames.length; i++ ) {\n      assertTrue( jsDepPackage.registerFileDependency(\n          fileNames[ i ] + \".js\", fileVersions[ i ], mockPathOrigin, filePaths[ i ] ) );\n      assertTrue( cssDepPackage.registerFileDependency(\n          fileNames[ i ] + \".css\", fileVersions[ i ], mockPathOrigin, filePaths[ i ] ) );\n      assertTrue( mapDepPackage.registerFileDependency(\n          fileNames[ i ] + \".css.map\", fileVersions[ i ], mockPathOrigin, filePaths[ i ] ) );\n    }\n\n  }\n\n  @Test\n  public void testRegisterRawDependency() {\n    String[] fileNames = new String[]{\"file1\", \"file2\"};\n    String[] fileVersions = new String[]{\"v1\", \"v2\"};\n    String[] fileContents = new String[]{\"content1\", \"content2\"};\n\n    for ( int i = 0; i < fileNames.length; i++ ) {\n      assertTrue( jsDepPackage.registerRawDependency(\n          fileNames[ i ] + \".js\", fileVersions[ i ], fileContents[ i ] ) );\n      assertTrue( cssDepPackage.registerRawDependency(\n          fileNames[ i ] + \".css\", fileVersions[ i ], fileContents[ i ] ) );\n      assertTrue( mapDepPackage.registerRawDependency(\n          fileNames[ i ] + \".css.map\", fileVersions[ i ], fileContents[ i ] ) );\n    }\n\n  }\n\n  @Test\n  public void testRegisterDependency() {\n    String[] fileNames = new String[]{\"file1\", \"file2\"};\n    Map<String, Dependency> registry = new HashMap<String, Dependency>();\n\n    for ( int i = 0; i < fileNames.length; i++ ) {\n      assertTrue( jsDepPackage.registerDependency(\n          fileNames[ i ] + \".js\", mock( JsMinifiedDependency.class ), registry ) );\n      assertTrue( cssDepPackage.registerDependency(\n          fileNames[ i ] + \".css\", mock( CssMinifiedDependency.class ), registry ) );\n      assertTrue( mapDepPackage.registerDependency(\n          fileNames[ i ] + \".css.map\", mock( MapDependency.class ), registry ) );\n    }\n    assertEquals( fileNames.length * 3, registry.size() );\n  }\n\n\n  @Test\n  public void testGetDependencies() {\n\n\n    String jsPackagedDeps = jsDepPackage.getDependencies( true ).trim();\n    assertEquals( \"<script language=\\\"javascript\\\" type=\\\"text/javascript\\\" src=\\\"/js/\"\n        + JS_PACKAGE_NAME + \".js\\\"></script>\", jsPackagedDeps );\n\n    String cssPackagedDeps = cssDepPackage.getDependencies( true ).trim();\n    assertEquals( \"<link href=\\\"/css/\"\n        + CSS_PACKAGE_NAME + \".css\\\" rel=\\\"stylesheet\\\" type=\\\"text/css\\\" />\", cssPackagedDeps );\n\n    String mapPackagedDeps = mapDepPackage.getDependencies( true ).trim();\n    assertEquals( \"\", mapPackagedDeps );\n\n    String[] filePaths = new String[]{\"path1\", \"path2\"};\n    addFileDependencies( filePaths );\n\n    String jsUnpackagedDeps = jsDepPackage.getDependencies( false ).replaceAll( \"\\n\", \"\" ).replaceAll( \"\\t\", \"\" );\n    String jsUnpackedExpected = \"\";\n    for ( int i = 0; i < filePaths.length; i++ ) {\n      jsUnpackedExpected +=\n        \"<script language=\\\"javascript\\\" type=\\\"text/javascript\\\" src=\\\"\" + filePaths[i] + \"\\\"></script>\";\n    }\n    assertEquals( jsUnpackedExpected, jsUnpackagedDeps );\n\n    String cssUnpackagedDeps = cssDepPackage.getDependencies( false ).replaceAll( \"\\n\", \"\" ).replaceAll( \"\\t\", \"\" );\n    String cssUnpackedExpected = \"\";\n    for ( int i = 0; i < filePaths.length; i++ ) {\n      cssUnpackedExpected +=\n        \"<link href=\\\"\" + filePaths[i] + \"\\\" rel=\\\"stylesheet\\\" type=\\\"text/css\\\" />\";\n    }\n    assertEquals( cssUnpackedExpected, cssUnpackagedDeps );\n\n    String mapUnpackagedDeps = mapDepPackage.getDependencies( false ).trim();\n    assertEquals( \"\", mapUnpackagedDeps );\n\n  }\n\n  @Test\n  public void testGetDefaultFilter() {\n    StringFilter jsFilter = jsDepPackage.getDefaultFilter();\n    StringFilter cssFilter = cssDepPackage.getDefaultFilter();\n    StringFilter mapFilter = mapDepPackage.getDefaultFilter();\n\n    assertEquals( \"<script language=\\\"javascript\\\" type=\\\"text/javascript\\\" src=\\\"JS-FILTER\\\"></script>\",\n        jsFilter.filter( \"JS-FILTER\" ).trim() );\n    assertEquals( \"<link href=\\\"CSS-FILTER\\\" rel=\\\"stylesheet\\\" type=\\\"text/css\\\" />\",\n        cssFilter.filter( \"CSS-FILTER\" ).trim() );\n    assertEquals( \"\", mapFilter.filter( \"MAP-FILTER\" ) );\n  }\n\n  @Test\n  public void testGetDefaultFilterEscapesUntrustedBaseUrl() {\n    StringFilter jsFilter = jsDepPackage.getDefaultFilter();\n    StringFilter cssFilter = cssDepPackage.getDefaultFilter();\n    StringFilter mapFilter = mapDepPackage.getDefaultFilter();\n\n    String untrustedBaseUrl = \"http://foo\\\"/\";\n\n    assertEquals( \"<script language=\\\"javascript\\\" type=\\\"text/javascript\\\" src=\\\"http://foo&#34;/JS-FILTER\\\"></script>\",\n            jsFilter.filter( \"JS-FILTER\", untrustedBaseUrl ).trim() );\n\n    assertEquals( \"<link href=\\\"http://foo&#34;/CSS-FILTER\\\" rel=\\\"stylesheet\\\" type=\\\"text/css\\\" />\",\n            cssFilter.filter( \"CSS-FILTER\", untrustedBaseUrl ).trim() );\n\n    assertEquals( \"\", mapFilter.filter( \"MAP-FILTER\", untrustedBaseUrl ) );\n  }\n\n  private static void addFileDependencies( String[] filePaths ) {\n    String[] fileNames = new String[]{\"file1\", \"file2\"};\n    String[] fileVersions = new String[]{\"v1\", \"v2\"};\n    for ( int i = 0; i < fileNames.length; i++ ) {\n      jsDepPackage.registerFileDependency( fileNames[ i ] + \".js\", fileVersions[ i ], mockPathOrigin, filePaths[ i ] );\n      cssDepPackage.registerFileDependency(\n          fileNames[ i ] + \".css\", fileVersions[ i ], mockPathOrigin, filePaths[ i ] );\n      mapDepPackage.registerFileDependency(\n          fileNames[ i ] + \".css.map\", fileVersions[ i ], mockPathOrigin, filePaths[ i ] );\n    }\n  }\n\n\n\n\n}",
    "patch": "@@ -1,5 +1,5 @@\n /*!\n- * Copyright 2002 - 2017 Webdetails, a Hitachi Vantara company.  All rights reserved.\n+ * Copyright 2002 - 2021 Webdetails, a Hitachi Vantara company.  All rights reserved.\n  *\n  * This software was developed by Webdetails and is provided under the terms\n  * of the Mozilla Public License, Version 2.0, or any later version. You may not use\n@@ -172,6 +172,23 @@ public void testGetDefaultFilter() {\n     assertEquals( \"\", mapFilter.filter( \"MAP-FILTER\" ) );\n   }\n \n+  @Test\n+  public void testGetDefaultFilterEscapesUntrustedBaseUrl() {\n+    StringFilter jsFilter = jsDepPackage.getDefaultFilter();\n+    StringFilter cssFilter = cssDepPackage.getDefaultFilter();\n+    StringFilter mapFilter = mapDepPackage.getDefaultFilter();\n+\n+    String untrustedBaseUrl = \"http://foo\\\"/\";\n+\n+    assertEquals( \"<script language=\\\"javascript\\\" type=\\\"text/javascript\\\" src=\\\"http://foo&#34;/JS-FILTER\\\"></script>\",\n+            jsFilter.filter( \"JS-FILTER\", untrustedBaseUrl ).trim() );\n+\n+    assertEquals( \"<link href=\\\"http://foo&#34;/CSS-FILTER\\\" rel=\\\"stylesheet\\\" type=\\\"text/css\\\" />\",\n+            cssFilter.filter( \"CSS-FILTER\", untrustedBaseUrl ).trim() );\n+\n+    assertEquals( \"\", mapFilter.filter( \"MAP-FILTER\", untrustedBaseUrl ) );\n+  }\n+\n   private static void addFileDependencies( String[] filePaths ) {\n     String[] fileNames = new String[]{\"file1\", \"file2\"};\n     String[] fileVersions = new String[]{\"v1\", \"v2\"};",
    "function_modified_lines": {
      "added": [
        "  @Test\n",
        "  public void testGetDefaultFilterEscapesUntrustedBaseUrl() {\n",
        "    StringFilter jsFilter = jsDepPackage.getDefaultFilter();\n",
        "    StringFilter cssFilter = cssDepPackage.getDefaultFilter();\n",
        "    StringFilter mapFilter = mapDepPackage.getDefaultFilter();\n",
        "\n",
        "    String untrustedBaseUrl = \"http://foo\\\"/\";\n",
        "\n",
        "    assertEquals( \"<script language=\\\"javascript\\\" type=\\\"text/javascript\\\" src=\\\"http://foo&#34;/JS-FILTER\\\"></script>\",\n",
        "            jsFilter.filter( \"JS-FILTER\", untrustedBaseUrl ).trim() );\n",
        "\n",
        "    assertEquals( \"<link href=\\\"http://foo&#34;/CSS-FILTER\\\" rel=\\\"stylesheet\\\" type=\\\"text/css\\\" />\",\n",
        "            cssFilter.filter( \"CSS-FILTER\", untrustedBaseUrl ).trim() );\n",
        "\n",
        "    assertEquals( \"\", mapFilter.filter( \"MAP-FILTER\", untrustedBaseUrl ) );\n",
        "  }\n",
        "\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-79"
    ],
    "cve_description": "A vulnerability classified as problematic has been found in Webdetails cpf up to 9.5.0.0-80. Affected is an unknown function of the file core/src/main/java/pt/webdetails/cpf/packager/DependenciesPackage.java. The manipulation of the argument baseUrl leads to cross site scripting. It is possible to launch the attack remotely. Upgrading to version 9.5.0.0-81 is able to address this issue. The name of the patch is 3bff900d228e8cae3af256b447c5d15bdb03c174. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-216468.",
    "id": 12554
  },
  {
    "cve_id": "CVE-2021-4289",
    "code_before_change": "{\n\t\t\n\t\ttry {\n\t\t\tAppDescriptor descriptor = mapper.readValue(userApp.getJson(), AppDescriptor.class);\n\t\t\tif (!userApp.getAppId().equals(descriptor.getId())) {\n\t\t\t\tsession.setAttribute(UiCommonsConstants.SESSION_ATTRIBUTE_ERROR_MESSAGE,\n\t\t\t\t    ui.message(\"referenceapplication.app.errors.IdsShouldMatch\"));\n\t\t\t} else if (\"add\".equals(action) && service.getUserApp(userApp.getAppId()) != null) {\n\t\t\t\tsession.setAttribute(UiCommonsConstants.SESSION_ATTRIBUTE_ERROR_MESSAGE,\n\t\t\t\t    ui.message(\"referenceapplication.app.errors.duplicateAppId\"));\n\t\t\t} else {\n\t\t\t\tservice.saveUserApp(userApp);\n\t\t\t\t\n\t\t\t\tInfoErrorMessageUtil.flashInfoMessage(session,\n\t\t\t\t    ui.message(\"referenceapplication.app.userApp.save.success\", userApp.getAppId()));\n\t\t\t\t\n\t\t\t\treturn \"redirect:/referenceapplication/manageApps.page\";\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tsession.setAttribute(UiCommonsConstants.SESSION_ATTRIBUTE_ERROR_MESSAGE,\n\t\t\t    ui.message(\"referenceapplication.app.userApp.save.fail\", userApp.getAppId()));\n\t\t}\n\t\t\n\t\tmodel.addAttribute(\"userApp\", userApp);\n\t\t\n\t\treturn null;\n\t}",
    "code_after_change": "{\n\n\t\ttry {\n\t\t\tAppDescriptor descriptor = mapper.readValue(userApp.getJson(), AppDescriptor.class);\n\t\t\tif (!userApp.getAppId().equals(descriptor.getId())) {\n\t\t\t\tsession.setAttribute(UiCommonsConstants.SESSION_ATTRIBUTE_ERROR_MESSAGE,\n\t\t\t\t    ui.message(\"referenceapplication.app.errors.IdsShouldMatch\"));\n\t\t\t} else if (\"add\".equals(action) && service.getUserApp(userApp.getAppId()) != null) {\n\t\t\t\tsession.setAttribute(UiCommonsConstants.SESSION_ATTRIBUTE_ERROR_MESSAGE,\n\t\t\t\t    ui.message(\"referenceapplication.app.errors.duplicateAppId\"));\n\t\t\t} else {\n\t\t\t\tservice.saveUserApp(userApp);\n\t\t\t\t\n\t\t\t\tInfoErrorMessageUtil.flashInfoMessage(session,\n\t\t\t\t    ui.message(\"referenceapplication.app.userApp.save.success\", StringEscapeUtils.escapeHtml(userApp.getAppId())));\n\t\t\t\t\n\t\t\t\treturn \"redirect:/referenceapplication/manageApps.page\";\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tsession.setAttribute(UiCommonsConstants.SESSION_ATTRIBUTE_ERROR_MESSAGE,\n\t\t\t    ui.message(\"referenceapplication.app.userApp.save.fail\", StringEscapeUtils.escapeHtml(userApp.getAppId())));\n\t\t}\n\t\t\n\t\tmodel.addAttribute(\"userApp\", userApp);\n\t\t\n\t\treturn null;\n\t}",
    "patch": "@@ -15,6 +15,7 @@\n \n import javax.servlet.http.HttpSession;\n \n+import org.apache.commons.lang.StringEscapeUtils;\n import org.apache.commons.logging.Log;\n import org.apache.commons.logging.LogFactory;\n import org.codehaus.jackson.map.ObjectMapper;\n@@ -52,7 +53,7 @@ public void get(PageModel model, @RequestParam(value = \"appId\", required = false\n \tpublic String post(PageModel model, @ModelAttribute(value = \"appId\") @BindParams UserApp userApp,\n \t                   @RequestParam(\"action\") String action,\n \t                   @SpringBean(\"appFrameworkService\") AppFrameworkService service, HttpSession session, UiUtils ui) {\n-\t\t\n+\n \t\ttry {\n \t\t\tAppDescriptor descriptor = mapper.readValue(userApp.getJson(), AppDescriptor.class);\n \t\t\tif (!userApp.getAppId().equals(descriptor.getId())) {\n@@ -65,14 +66,14 @@ public String post(PageModel model, @ModelAttribute(value = \"appId\") @BindParams\n \t\t\t\tservice.saveUserApp(userApp);\n \t\t\t\t\n \t\t\t\tInfoErrorMessageUtil.flashInfoMessage(session,\n-\t\t\t\t    ui.message(\"referenceapplication.app.userApp.save.success\", userApp.getAppId()));\n+\t\t\t\t    ui.message(\"referenceapplication.app.userApp.save.success\", StringEscapeUtils.escapeHtml(userApp.getAppId())));\n \t\t\t\t\n \t\t\t\treturn \"redirect:/referenceapplication/manageApps.page\";\n \t\t\t}\n \t\t}\n \t\tcatch (Exception e) {\n \t\t\tsession.setAttribute(UiCommonsConstants.SESSION_ATTRIBUTE_ERROR_MESSAGE,\n-\t\t\t    ui.message(\"referenceapplication.app.userApp.save.fail\", userApp.getAppId()));\n+\t\t\t    ui.message(\"referenceapplication.app.userApp.save.fail\", StringEscapeUtils.escapeHtml(userApp.getAppId())));\n \t\t}\n \t\t\n \t\tmodel.addAttribute(\"userApp\", userApp);",
    "function_modified_lines": {
      "added": [
        "\n",
        "\t\t\t\t    ui.message(\"referenceapplication.app.userApp.save.success\", StringEscapeUtils.escapeHtml(userApp.getAppId())));\n",
        "\t\t\t    ui.message(\"referenceapplication.app.userApp.save.fail\", StringEscapeUtils.escapeHtml(userApp.getAppId())));\n"
      ],
      "deleted": [
        "\t\t\n",
        "\t\t\t\t    ui.message(\"referenceapplication.app.userApp.save.success\", userApp.getAppId()));\n",
        "\t\t\t    ui.message(\"referenceapplication.app.userApp.save.fail\", userApp.getAppId()));\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-79"
    ],
    "cve_description": "A vulnerability classified as problematic was found in OpenMRS openmrs-module-referenceapplication up to 2.11.x. Affected by this vulnerability is the function post of the file omod/src/main/java/org/openmrs/module/referenceapplication/page/controller/UserAppPageController.java of the component User App Page. The manipulation of the argument AppId leads to cross site scripting. The attack can be launched remotely. Upgrading to version 2.12.0 is able to address this issue. The name of the patch is 0410c091d46eed3c132fe0fcafe5964182659f74. It is recommended to upgrade the affected component. The associated identifier of this vulnerability is VDB-216883.",
    "id": 12555
  },
  {
    "cve_id": "CVE-2022-1782",
    "code_before_change": "\n\t/**\n\t * Converts Markdown to HTML.\n\t * @param markdownString Markdown\n\t * @return HTML\n\t */\n\tpublic static String markdownToHtml(String markdownString) {\n\t\treturn markdownToHtml(markdownString, false);\n\t}\n\n\t/**\n\t * Converts Markdown to HTML.\n\t * @param markdownString Markdown\n\t * @param htmlTagsRenderingEnabled if true, basic HTML tags will be rendered instead of escaped\n\t * @return HTML\n\t */\n\tpublic static String markdownToHtml(String markdownString, boolean htmlTagsRenderingEnabled) {\n\t\tif (StringUtils.isBlank(markdownString)) {\n\t\t\treturn \"\";\n\t\t}\n\t\tDocument parsed = MD_PARSER.parse(markdownString);\n\t\tif (htmlTagsRenderingEnabled) {\n\t\t\treturn Jsoup.clean(HTML_RENDERER_LOOSE.render(parsed), SAFE_HTML_TAGS);\n\t\t} else {\n\t\t\treturn HTML_RENDERER_STRICT.render(parsed);\n\t\t}\n\t}\n\n\t/**\n\t * Compiles a mustache template with a given scope (map of fields and values).\n\t * @param context a map of fields and values\n\t * @param template a Mustache template\n\t * @return the compiled template string\n\t */\n\tpublic static String compileMustache(Map<String, Object> context, String template) {\n\t\tif (context == null || StringUtils.isBlank(template)) {\n\t\t\treturn \"\";\n\t\t}\n\t\tWriter writer = new StringWriter();\n\t\ttry {\n\t\t\tMustache.compiler().escapeHTML(false).emptyStringIsFalse(true).compile(template).execute(context, writer);\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\twriter.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\tlogger.error(null, e);\n\t\t\t}\n\t\t}\n\t\treturn writer.toString();\n\t}\n\n\t/**\n\t * Abbreviates a string.\n\t * @param str a string\n\t * @param max max length\n\t * @return a substring of that string\n\t */\n\tpublic static String abbreviate(String str, int max) {\n\t\treturn StringUtils.isBlank(str) ? \"\" : StringUtils.abbreviate(str, max);\n\t}\n\n\t/**\n\t * Joins a list of strings to String using a separator.\n\t * @param arr a list of strings\n\t * @param separator a separator string\n\t * @return a string\n\t */\n\tpublic static String arrayJoin(List<String> arr, String separator) {\n\t\treturn (arr == null || separator == null) ? \"\" : StringUtils.join(arr, separator);\n\t}\n\n\t/**\n\t * Strips all symbols, punctuation, whitespace and control chars from a string.\n\t * @param str a dirty string\n\t * @return a clean string\n\t */\n\tpublic static String stripAndTrim(String str) {\n\t\treturn stripAndTrim(str, \"\");\n\t}\n\n\t/**\n\t * Strips all symbols, punctuation, whitespace and control chars from a string.\n\t * @param str a dirty string\n\t * @param replaceWith a string to replace spaces with\n\t * @return a clean string\n\t */\n\tpublic static String stripAndTrim(String str, String replaceWith) {\n\t\treturn stripAndTrim(str, replaceWith, false);\n\t}",
    "code_after_change": "\n\t/**\n\t * Converts Markdown to HTML.\n\t * @param markdownString Markdown\n\t * @return HTML\n\t */\n\tpublic static String markdownToHtml(String markdownString) {\n\t\treturn markdownToHtml(markdownString, false);\n\t}\n\n\t/**\n\t * Converts Markdown to HTML.\n\t * @param markdownString Markdown\n\t * @param htmlTagsRenderingEnabled if true, basic HTML tags will be rendered instead of escaped\n\t * @return HTML\n\t */\n\tpublic static String markdownToHtml(String markdownString, boolean htmlTagsRenderingEnabled) {\n\t\tif (StringUtils.isBlank(markdownString)) {\n\t\t\treturn \"\";\n\t\t}\n\t\tDocument parsed = MD_PARSER.parse(markdownString);\n\t\tif (htmlTagsRenderingEnabled) {\n\t\t\treturn Jsoup.clean(HTML_RENDERER_LOOSE.render(parsed), SAFE_HTML_TAGS);\n\t\t} else {\n\t\t\treturn HTML_RENDERER_STRICT.render(parsed);\n\t\t}\n\t}\n\n\t/**\n\t * Compiles a mustache template with a given scope (map of fields and values).\n\t * @param context a map of fields and values\n\t * @param template a Mustache template\n\t * @return the compiled template string\n\t */\n\tpublic static String compileMustache(Map<String, Object> context, String template, boolean escapeHtml) {\n\t\tif (context == null || StringUtils.isBlank(template)) {\n\t\t\treturn \"\";\n\t\t}\n\t\tWriter writer = new StringWriter();\n\t\ttry {\n\t\t\tMustache.compiler().escapeHTML(escapeHtml).emptyStringIsFalse(true).compile(template).execute(context, writer);\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\twriter.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\tlogger.error(null, e);\n\t\t\t}\n\t\t}\n\t\treturn writer.toString();\n\t}\n\n\t/**\n\t * @see #compileMustache(java.util.Map, java.lang.String, boolean)\n\t * @param context a map of fields and values\n\t * @param template a Mustache template\n\t * @return the compiled template string\n\t */\n\tpublic static String compileMustache(Map<String, Object> context, String template) {\n\t\treturn compileMustache(context, template, false);\n\t}\n\n\t/**\n\t * Abbreviates a string.\n\t * @param str a string\n\t * @param max max length\n\t * @return a substring of that string\n\t */\n\tpublic static String abbreviate(String str, int max) {\n\t\treturn StringUtils.isBlank(str) ? \"\" : StringUtils.abbreviate(str, max);\n\t}\n\n\t/**\n\t * Joins a list of strings to String using a separator.\n\t * @param arr a list of strings\n\t * @param separator a separator string\n\t * @return a string\n\t */\n\tpublic static String arrayJoin(List<String> arr, String separator) {\n\t\treturn (arr == null || separator == null) ? \"\" : StringUtils.join(arr, separator);\n\t}\n\n\t/**\n\t * Strips all symbols, punctuation, whitespace and control chars from a string.\n\t * @param str a dirty string\n\t * @return a clean string\n\t */\n\tpublic static String stripAndTrim(String str) {\n\t\treturn stripAndTrim(str, \"\");\n\t}\n\n\t/**\n\t * Strips all symbols, punctuation, whitespace and control chars from a string.\n\t * @param str a dirty string\n\t * @param replaceWith a string to replace spaces with\n\t * @return a clean string\n\t */\n\tpublic static String stripAndTrim(String str, String replaceWith) {",
    "patch": "@@ -330,13 +330,13 @@ public static String markdownToHtml(String markdownString, boolean htmlTagsRende\n \t * @param template a Mustache template\n \t * @return the compiled template string\n \t */\n-\tpublic static String compileMustache(Map<String, Object> context, String template) {\n+\tpublic static String compileMustache(Map<String, Object> context, String template, boolean escapeHtml) {\n \t\tif (context == null || StringUtils.isBlank(template)) {\n \t\t\treturn \"\";\n \t\t}\n \t\tWriter writer = new StringWriter();\n \t\ttry {\n-\t\t\tMustache.compiler().escapeHTML(false).emptyStringIsFalse(true).compile(template).execute(context, writer);\n+\t\t\tMustache.compiler().escapeHTML(escapeHtml).emptyStringIsFalse(true).compile(template).execute(context, writer);\n \t\t} finally {\n \t\t\ttry {\n \t\t\t\twriter.close();\n@@ -347,6 +347,16 @@ public static String compileMustache(Map<String, Object> context, String templat\n \t\treturn writer.toString();\n \t}\n \n+\t/**\n+\t * @see #compileMustache(java.util.Map, java.lang.String, boolean)\n+\t * @param context a map of fields and values\n+\t * @param template a Mustache template\n+\t * @return the compiled template string\n+\t */\n+\tpublic static String compileMustache(Map<String, Object> context, String template) {\n+\t\treturn compileMustache(context, template, false);\n+\t}\n+\n \t/**\n \t * Abbreviates a string.\n \t * @param str a string",
    "function_modified_lines": {
      "added": [
        "\tpublic static String compileMustache(Map<String, Object> context, String template, boolean escapeHtml) {\n",
        "\t\t\tMustache.compiler().escapeHTML(escapeHtml).emptyStringIsFalse(true).compile(template).execute(context, writer);\n",
        "\t/**\n",
        "\t * @see #compileMustache(java.util.Map, java.lang.String, boolean)\n",
        "\t * @param context a map of fields and values\n",
        "\t * @param template a Mustache template\n",
        "\t * @return the compiled template string\n",
        "\t */\n",
        "\tpublic static String compileMustache(Map<String, Object> context, String template) {\n",
        "\t\treturn compileMustache(context, template, false);\n",
        "\t}\n",
        "\n"
      ],
      "deleted": [
        "\tpublic static String compileMustache(Map<String, Object> context, String template) {\n",
        "\t\t\tMustache.compiler().escapeHTML(false).emptyStringIsFalse(true).compile(template).execute(context, writer);\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-79"
    ],
    "cve_description": "Cross-site Scripting (XSS) - Generic in GitHub repository erudika/para prior to v1.45.11.",
    "id": 12570
  },
  {
    "cve_id": "CVE-2022-1782",
    "code_before_change": "/*\n * Copyright 2013-2022 Erudika. https://erudika.com\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * For issues and patches go to: https://github.com/erudika\n */\npackage com.erudika.para.core.utils;\n\nimport com.erudika.para.core.utils.Config;\nimport com.erudika.para.core.utils.Utils;\nimport com.erudika.para.core.annotations.Locked;\nimport com.erudika.para.core.App;\nimport com.erudika.para.core.ParaObject;\nimport com.erudika.para.core.Sysprop;\nimport com.erudika.para.core.Tag;\nimport com.erudika.para.core.User;\nimport com.erudika.para.core.Votable;\nimport static com.erudika.para.core.utils.Utils.*;\nimport static com.erudika.para.core.utils.ParaObjectUtils.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\nimport org.apache.commons.lang3.StringUtils;\nimport static org.junit.Assert.*;\nimport org.junit.Test;\n\n/**\n *\n * @author Alex Bogdanovski [alex@erudika.com]\n */\npublic class UtilsTest {\n\n\tpublic UtilsTest() {\n\t}\n\n\t@Test\n\tpublic void testMD5() {\n\t\tassertEquals(\"098f6bcd4621d373cade4e832627b4f6\", md5(\"test\"));\n\t\tassertEquals(\"47ec2dd791e31e2ef2076caf64ed9b3d\", md5(\"test123456\"));\n\t\tassertEquals(\"d41d8cd98f00b204e9800998ecf8427e\", md5(\"\"));\n\t\tassertEquals(\"\", md5(null));\n\t}\n\n\t@Test\n\tpublic void testBcrypt() {\n\t\tassertNull(bcrypt(null));\n\t\tassertFalse(bcrypt(\"\").isEmpty());\n\t\tassertFalse(bcrypt(\"test\").isEmpty());",
    "code_after_change": "/*\n * Copyright 2013-2022 Erudika. https://erudika.com\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * For issues and patches go to: https://github.com/erudika\n */\npackage com.erudika.para.core.utils;\n\nimport com.erudika.para.core.App;\nimport com.erudika.para.core.ParaObject;\nimport com.erudika.para.core.Sysprop;\nimport com.erudika.para.core.Tag;\nimport com.erudika.para.core.User;\nimport com.erudika.para.core.Votable;\nimport com.erudika.para.core.annotations.Locked;\nimport static com.erudika.para.core.utils.ParaObjectUtils.*;\nimport static com.erudika.para.core.utils.Utils.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\nimport org.apache.commons.lang3.StringUtils;\nimport static org.junit.Assert.*;\nimport org.junit.Test;\n\n/**\n *\n * @author Alex Bogdanovski [alex@erudika.com]\n */\npublic class UtilsTest {\n\n\tpublic UtilsTest() {\n\t}\n\n\t@Test\n\tpublic void testMD5() {\n\t\tassertEquals(\"098f6bcd4621d373cade4e832627b4f6\", md5(\"test\"));\n\t\tassertEquals(\"47ec2dd791e31e2ef2076caf64ed9b3d\", md5(\"test123456\"));\n\t\tassertEquals(\"d41d8cd98f00b204e9800998ecf8427e\", md5(\"\"));\n\t\tassertEquals(\"\", md5(null));\n\t}\n\n\t@Test\n\tpublic void testBcrypt() {\n\t\tassertNull(bcrypt(null));\n\t\tassertFalse(bcrypt(\"\").isEmpty());\n\t\tassertFalse(bcrypt(\"test\").isEmpty());\n\t\tassertNotEquals(bcrypt(\"testpass\"), bcrypt(\"testpass\")); // bcrypt hashes are salted i.e. !=",
    "patch": "@@ -17,17 +17,15 @@\n  */\n package com.erudika.para.core.utils;\n \n-import com.erudika.para.core.utils.Config;\n-import com.erudika.para.core.utils.Utils;\n-import com.erudika.para.core.annotations.Locked;\n import com.erudika.para.core.App;\n import com.erudika.para.core.ParaObject;\n import com.erudika.para.core.Sysprop;\n import com.erudika.para.core.Tag;\n import com.erudika.para.core.User;\n import com.erudika.para.core.Votable;\n-import static com.erudika.para.core.utils.Utils.*;\n+import com.erudika.para.core.annotations.Locked;\n import static com.erudika.para.core.utils.ParaObjectUtils.*;\n+import static com.erudika.para.core.utils.Utils.*;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collections;\n@@ -114,6 +112,8 @@ public void testCompileMustache() {\n \t\tMap<String, Object> map = new HashMap<>();\n \t\tmap.put(\"test\", \"string\");\n \t\tassertEquals(\"<html>string</html>\", compileMustache(map, \"<html>{{test}}</html>\"));\n+\t\tmap.put(\"test\", \"<b>string</b>\");\n+\t\tassertEquals(\"<html>&lt;b&gt;string&lt;/b&gt;</html>\", compileMustache(map, \"<html>{{test}}</html>\", true));\n \t}\n \n \t@Test",
    "function_modified_lines": {
      "added": [
        "import com.erudika.para.core.annotations.Locked;\n",
        "import static com.erudika.para.core.utils.Utils.*;\n"
      ],
      "deleted": [
        "import com.erudika.para.core.utils.Config;\n",
        "import com.erudika.para.core.utils.Utils;\n",
        "import com.erudika.para.core.annotations.Locked;\n",
        "import static com.erudika.para.core.utils.Utils.*;\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-79"
    ],
    "cve_description": "Cross-site Scripting (XSS) - Generic in GitHub repository erudika/para prior to v1.45.11.",
    "id": 12571
  },
  {
    "cve_id": "CVE-2023-29201",
    "code_before_change": "    {\n        this.cleanerConfiguration.setFilters(Collections.emptyList());\n        String result = HTMLUtils.toString(clean(\"something\"));\n        // Note that if the default Body filter had been executed the result would have been:\n        // <p>something</p>.\n        assertEquals(getHeaderFull() + \"something\" + FOOTER, result);\n    }\n\n    /**\n     * Verify that the restricted parameter works.\n     */\n    @Test\n    void restrictedHtml()\n    {\n        Map<String, String> parameters = new HashMap<>(this.cleanerConfiguration.getParameters());\n        parameters.put(\"restricted\", \"true\");\n        this.cleanerConfiguration.setParameters(parameters);\n        Document document = clean(\"<script>alert(\\\"foo\\\")</script>\");\n\n        String textContent =\n            document.getElementsByTagName(\"pre\").item(0).getTextContent();\n        assertEquals(\"alert(\\\"foo\\\")\", textContent);\n\n        String result = HTMLUtils.toString(document);\n        assertEquals(getHeaderFull() + \"<pre>alert(\\\"foo\\\")</pre>\" + FOOTER, result);\n\n        document = clean(\"<style>p {color:white;}</style>\");\n\n        textContent =\n            document.getElementsByTagName(\"pre\").item(0).getTextContent();\n        assertEquals(\"p {color:white;}\", textContent);\n\n        result = HTMLUtils.toString(document);\n        assertEquals(getHeaderFull() + \"<pre>p {color:white;}</pre>\" + FOOTER, result);\n    }\n\n    /**\n     * Verify that passing a fully-formed XHTML header works fine.\n     */\n    @Test\n    void fullXHTMLHeader()\n    {\n        assertHTML(\"<p>test</p>\", getHeaderFull() + \"<p>test</p>\" + FOOTER);\n    }\n\n    /**\n     * Test {@link UniqueIdFilter}.\n     */\n    @Test\n    public void duplicateIds(ComponentManager componentManager) throws Exception\n    {\n        String actual = \"<p id=\\\"x\\\">1</p><p id=\\\"xy\\\">2</p><p id=\\\"x\\\">3</p>\";\n        String expected = \"<p id=\\\"x\\\">1</p><p id=\\\"xy\\\">2</p><p id=\\\"x0\\\">3</p>\";\n        List<HTMLFilter> filters = new ArrayList<>(this.cleanerConfiguration.getFilters());\n        filters.add(componentManager.getInstance(HTMLFilter.class, \"uniqueId\"));\n        this.cleanerConfiguration.setFilters(filters);\n        assertEquals(getHeaderFull() + expected + FOOTER,\n            HTMLUtils.toString(clean(actual)));\n    }\n\n    /**\n     * Test that tags with a namespace are not considered as unknown tags by HTMLCleaner (see also <a\n     * href=\"https://jira.xwiki.org/browse/XWIKI-9753\">XWIKI-9753</a>).\n     */\n    @Test\n    void cleanSVGTags() throws Exception\n    {\n        String input =\n            \"<p>before</p>\\n\" + \"<p><svg xmlns=\\\"http://www.w3.org/2000/svg\\\" version=\\\"1.1\\\">\\n\"\n                + \"<circle cx=\\\"100\\\" cy=\\\"50\\\" fill=\\\"red\\\" r=\\\"40\\\" stroke=\\\"black\\\" stroke-width=\\\"2\\\"></circle>\\n\"\n                + \"</svg></p>\\n\" + \"<p>after</p>\\n\";\n        assertHTML(input, getHeaderFull() + input + FOOTER);\n    }\n",
    "code_after_change": "        String result = HTMLUtils.toString(clean(\"something\"));\n        // Note that if the default Body filter had been executed the result would have been:\n        // <p>something</p>.\n        assertEquals(getHeaderFull() + \"something\" + FOOTER, result);\n    }\n\n    /**\n     * Verify that the restricted parameter works.\n     */\n    @Test\n    void restrictedHtml()\n    {\n        Map<String, String> parameters = new HashMap<>(this.cleanerConfiguration.getParameters());\n        parameters.put(\"restricted\", \"true\");\n        this.cleanerConfiguration.setParameters(parameters);\n        Document document = clean(\"<script>alert(\\\"foo\\\")</script>\");\n\n        String textContent =\n            document.getElementsByTagName(\"pre\").item(0).getTextContent();\n        assertEquals(\"alert(\\\"foo\\\")\", textContent);\n\n        String result = HTMLUtils.toString(document);\n        assertEquals(getHeaderFull() + \"<pre>alert(\\\"foo\\\")</pre>\" + FOOTER, result);\n\n        document = clean(\"<style>p {color:white;}</style>\");\n\n        textContent =\n            document.getElementsByTagName(\"pre\").item(0).getTextContent();\n        assertEquals(\"p {color:white;}\", textContent);\n\n        result = HTMLUtils.toString(document);\n        assertEquals(getHeaderFull() + \"<pre>p {color:white;}</pre>\" + FOOTER, result);\n    }\n\n    /**\n     * Verify that the restricted parameter forbids dangerous attributes and tags.\n     */\n    @Test\n    void restrictedAttributesAndTags() throws Exception\n    {\n        Map<String, String> parameters = new HashMap<>(this.cleanerConfiguration.getParameters());\n        parameters.put(\"restricted\", \"true\");\n        this.cleanerConfiguration.setParameters(parameters);\n\n        assertHTML(\"<p><img src=\\\"img.png\\\" /></p>\", \"<img onerror=\\\"alert(1)\\\" src=img.png />\");\n        assertHTML(\"<p><a>Hello!</a></p>\", \"<a href=\\\"javascript:alert(1)\\\">Hello!</a>\");\n        assertHTML(\"<p></p>\", \"<iframe src=\\\"whatever\\\"/>\");\n\n        // Check that SVG is still working in restricted mode.\n        cleanSVGTags();\n        cleanTitleWithNamespace();\n\n        // Check that MathML is still working in restricted mode.\n        assertHTML(\"<p><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><mtext>X</mtext><mi><span>foo</span>\"\n                + \"</mi></math></p>\",\n            \"<math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><span></span><mtext>X</mtext><mi><span>foo</span>\"\n                + \"</mi></math>\");\n    }\n\n    /**\n     * Verify that passing a fully-formed XHTML header works fine.\n     */\n    @Test\n    void fullXHTMLHeader()\n    {\n        assertHTML(\"<p>test</p>\", getHeaderFull() + \"<p>test</p>\" + FOOTER);\n    }\n\n    /**\n     * Test {@link UniqueIdFilter}.\n     */\n    @Test\n    public void duplicateIds(ComponentManager componentManager) throws Exception\n    {\n        String actual = \"<p id=\\\"x\\\">1</p><p id=\\\"xy\\\">2</p><p id=\\\"x\\\">3</p>\";\n        String expected = \"<p id=\\\"x\\\">1</p><p id=\\\"xy\\\">2</p><p id=\\\"x0\\\">3</p>\";\n        List<HTMLFilter> filters = new ArrayList<>(this.cleanerConfiguration.getFilters());\n        filters.add(componentManager.getInstance(HTMLFilter.class, \"uniqueId\"));\n        this.cleanerConfiguration.setFilters(filters);\n        assertEquals(getHeaderFull() + expected + FOOTER,\n            HTMLUtils.toString(clean(actual)));\n    }\n\n    /**\n     * Test that tags with a namespace are not considered as unknown tags by HTMLCleaner (see also <a\n     * href=\"https://jira.xwiki.org/browse/XWIKI-9753\">XWIKI-9753</a>).\n     */\n    @Test\n    void cleanSVGTags() throws Exception\n    {\n        String input =\n            \"<p>before</p>\\n\" + \"<p><svg xmlns=\\\"http://www.w3.org/2000/svg\\\" version=\\\"1.1\\\">\\n\"\n                + \"<circle cx=\\\"100\\\" cy=\\\"50\\\" fill=\\\"red\\\" r=\\\"40\\\" stroke=\\\"black\\\" stroke-width=\\\"2\\\"></circle>\\n\"\n                + \"</svg></p>\\n\" + \"<p>after</p>\\n\";\n        assertHTML(input, getHeaderFull() + input + FOOTER);",
    "patch": "@@ -36,6 +36,7 @@\n import org.w3c.dom.Document;\n import org.w3c.dom.NodeList;\n import org.xwiki.component.manager.ComponentManager;\n+import org.xwiki.configuration.internal.RestrictedConfigurationSourceProvider;\n import org.xwiki.test.annotation.ComponentList;\n import org.xwiki.test.junit5.mockito.ComponentTest;\n import org.xwiki.test.junit5.mockito.InjectMockComponents;\n@@ -49,6 +50,7 @@\n import org.xwiki.xml.internal.html.filter.LinkFilter;\n import org.xwiki.xml.internal.html.filter.ListFilter;\n import org.xwiki.xml.internal.html.filter.ListItemFilter;\n+import org.xwiki.xml.internal.html.filter.SanitizerFilter;\n import org.xwiki.xml.internal.html.filter.UniqueIdFilter;\n \n import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -71,6 +73,14 @@\n     DefaultHTMLCleaner.class,\n     LinkFilter.class,\n     ControlCharactersFilter.class,\n+    SanitizerFilter.class,\n+    DefaultHTMLElementSanitizer.class,\n+    SecureHTMLElementSanitizer.class,\n+    HTMLElementSanitizerConfiguration.class,\n+    RestrictedConfigurationSourceProvider.class,\n+    HTMLDefinitions.class,\n+    MathMLDefinitions.class,\n+    SVGDefinitions.class,\n     XWikiHTML5TagProvider.class\n })\n // @formatter:on\n@@ -107,7 +117,7 @@ public String getHeaderFull()\n \n     /**\n      * Cleans using the cleaner configuration {@link DefaultHTMLCleanerTest#cleanerConfiguration}.\n-     *\n+     * <p>\n      * Ensures that always the correct configuration is used and allows executing the same tests for HTML 4 and HTML 5.\n      *\n      * @param originalHtmlContent The content to clean as string.\n@@ -322,6 +332,31 @@ void restrictedHtml()\n         assertEquals(getHeaderFull() + \"<pre>p {color:white;}</pre>\" + FOOTER, result);\n     }\n \n+    /**\n+     * Verify that the restricted parameter forbids dangerous attributes and tags.\n+     */\n+    @Test\n+    void restrictedAttributesAndTags() throws Exception\n+    {\n+        Map<String, String> parameters = new HashMap<>(this.cleanerConfiguration.getParameters());\n+        parameters.put(\"restricted\", \"true\");\n+        this.cleanerConfiguration.setParameters(parameters);\n+\n+        assertHTML(\"<p><img src=\\\"img.png\\\" /></p>\", \"<img onerror=\\\"alert(1)\\\" src=img.png />\");\n+        assertHTML(\"<p><a>Hello!</a></p>\", \"<a href=\\\"javascript:alert(1)\\\">Hello!</a>\");\n+        assertHTML(\"<p></p>\", \"<iframe src=\\\"whatever\\\"/>\");\n+\n+        // Check that SVG is still working in restricted mode.\n+        cleanSVGTags();\n+        cleanTitleWithNamespace();\n+\n+        // Check that MathML is still working in restricted mode.\n+        assertHTML(\"<p><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><mtext>X</mtext><mi><span>foo</span>\"\n+                + \"</mi></math></p>\",\n+            \"<math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><span></span><mtext>X</mtext><mi><span>foo</span>\"\n+                + \"</mi></math>\");\n+    }\n+\n     /**\n      * Verify that passing a fully-formed XHTML header works fine.\n      */\n@@ -366,30 +401,29 @@ void cleanSVGTags() throws Exception\n      * also\n      * <a href=\"https://jira.xwiki.org/browse/XWIKI-9753\">XWIKI-9753</a>).\n      */\n-    @Disabled(\"See https://jira.xwiki.org/browse/XWIKI-9753\")\n     @Test\n     void cleanTitleWithNamespace()\n     {\n         // Test with TITLE in HEAD\n         String input =\n-            \"<html xmlns=\\\"http://www.w3.org/1999/xhtml\\\" lang=\\\"en\\\" xml:lang=\\\"en\\\">\\n\"\n-                + \"  <head>\\n\"\n+            \"<html xmlns=\\\"http://www.w3.org/1999/xhtml\\\" lang=\\\"en\\\">\"\n+                + \"<head>\\n\"\n                 + \"    <title>Title test</title>\\n\"\n-                + \"  </head>\\n\"\n-                + \"  <body>\\n\"\n+                + \"  </head>\"\n+                + \"<body>\\n\"\n                 + \"    <p>before</p>\\n\"\n-                + \"    <svg xmlns=\\\"http://www.w3.org/2000/svg\\\" height=\\\"300\\\" width=\\\"500\\\">\\n\"\n+                + \"    <p><svg xmlns=\\\"http://www.w3.org/2000/svg\\\" height=\\\"300\\\" width=\\\"500\\\">\\n\"\n                 + \"      <g>\\n\"\n                 + \"        <title>SVG Title Demo example</title>\\n\"\n                 + \"        <rect height=\\\"50\\\" style=\\\"fill:none; stroke:blue; stroke-width:1px\\\" width=\\\"200\\\" x=\\\"10\\\" \"\n-                + \"y=\\\"10\\\"></rect>\\n\" + \"      </g>\\n\" + \"    </svg>\\n\" + \"    <p>after</p>\\n\";\n+                + \"y=\\\"10\\\"></rect>\\n\" + \"      </g>\\n\" + \"    </svg></p>\\n\" + \"    <p>after</p>\\n\";\n         assertEquals(getHeader() + input + FOOTER,\n             HTMLUtils.toString(clean(input)));\n     }\n \n     /**\n-     * Verify that a xmlns namespace set on the HTML element is not removed by default and it's removed if {@link\n-     * HTMLCleanerConfiguration#NAMESPACES_AWARE} is set to false.\n+     * Verify that a xmlns namespace set on the HTML element is not removed by default and it's removed if\n+     * {@link HTMLCleanerConfiguration#NAMESPACES_AWARE} is set to false.\n      */\n     @Test\n     void cleanHTMLTagWithNamespace()\n@@ -409,7 +443,19 @@ void cleanHTMLTagWithNamespace()\n     }\n \n     /**\n-     * Test that cleaning an empty DIV works (it used to fail, see <a href=\"https://jira.xwiki.org/browse/XWIKI-4007\">XWIKI-4007</a>).\n+     * Check that template tags inside select don't survive, might be security-relevant, DOMPurify contains a similar\n+     * check, see <a href=\"https://github.com/cure53/DOMPurify/commit/e32ca248c0e9450fb182e52e978631cbd78f1123\">commit\n+     * e32ca248c0 in DOMPurify</a>.\n+     */\n+    @Test\n+    void cleanTemplateInsideSelect()\n+    {\n+        assertHTML(\"<p><select></select></p>\", \"<select><template></template></select>\");\n+    }\n+\n+    /**\n+     * Test that cleaning an empty DIV works (it used to fail, see <a\n+     * href=\"https://jira.xwiki.org/browse/XWIKI-4007\">XWIKI-4007</a>).\n      */\n     @Test\n     void cleanEmptyDIV()\n@@ -607,7 +653,7 @@ void divInsideDl()\n \n     /**\n      * Check what happens when the dt-tag is inside div.\n-     *\n+     * <p>\n      * This should add a wrapping dl but doesn't for HTML 4, but it works in HTML5, see\n      * {@link HTML5HTMLCleanerTest#divWithDt()}.\n      *",
    "function_modified_lines": {
      "added": [
        "    /**\n",
        "     * Verify that the restricted parameter forbids dangerous attributes and tags.\n",
        "     */\n",
        "    @Test\n",
        "    void restrictedAttributesAndTags() throws Exception\n",
        "    {\n",
        "        Map<String, String> parameters = new HashMap<>(this.cleanerConfiguration.getParameters());\n",
        "        parameters.put(\"restricted\", \"true\");\n",
        "        this.cleanerConfiguration.setParameters(parameters);\n",
        "\n",
        "        assertHTML(\"<p><img src=\\\"img.png\\\" /></p>\", \"<img onerror=\\\"alert(1)\\\" src=img.png />\");\n",
        "        assertHTML(\"<p><a>Hello!</a></p>\", \"<a href=\\\"javascript:alert(1)\\\">Hello!</a>\");\n",
        "        assertHTML(\"<p></p>\", \"<iframe src=\\\"whatever\\\"/>\");\n",
        "\n",
        "        // Check that SVG is still working in restricted mode.\n",
        "        cleanSVGTags();\n",
        "        cleanTitleWithNamespace();\n",
        "\n",
        "        // Check that MathML is still working in restricted mode.\n",
        "        assertHTML(\"<p><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><mtext>X</mtext><mi><span>foo</span>\"\n",
        "                + \"</mi></math></p>\",\n",
        "            \"<math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><span></span><mtext>X</mtext><mi><span>foo</span>\"\n",
        "                + \"</mi></math>\");\n",
        "    }\n",
        "\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-79"
    ],
    "cve_description": "XWiki Commons are technical libraries common to several other top level XWiki projects. The \"restricted\" mode of the HTML cleaner in XWiki, introduced in version 4.2-milestone-1, only escaped `<script>` and `<style>`-tags but neither attributes that can be used to inject scripts nor other dangerous HTML tags like `<iframe>`. As a consequence, any code relying on this \"restricted\" mode for security is vulnerable to JavaScript injection (\"cross-site scripting\"/XSS). When a privileged user with programming rights visits such a comment in XWiki, the malicious JavaScript code is executed in the context of the user session. This allows server-side code execution with programming rights, impacting the confidentiality, integrity and availability of the XWiki instance. This problem has been patched in XWiki 14.6 RC1 with the introduction of a filter with allowed HTML elements and attributes that is enabled in restricted mode. There are no known workarounds apart from upgrading to a version including the fix.",
    "id": 12604
  },
  {
    "cve_id": "CVE-2023-29201",
    "code_before_change": "     * Test {@link UniqueIdFilter}.\n     */\n    @Test\n    public void duplicateIds(ComponentManager componentManager) throws Exception\n    {\n        String actual = \"<p id=\\\"x\\\">1</p><p id=\\\"xy\\\">2</p><p id=\\\"x\\\">3</p>\";\n        String expected = \"<p id=\\\"x\\\">1</p><p id=\\\"xy\\\">2</p><p id=\\\"x0\\\">3</p>\";\n        List<HTMLFilter> filters = new ArrayList<>(this.cleanerConfiguration.getFilters());\n        filters.add(componentManager.getInstance(HTMLFilter.class, \"uniqueId\"));\n        this.cleanerConfiguration.setFilters(filters);\n        assertEquals(getHeaderFull() + expected + FOOTER,\n            HTMLUtils.toString(clean(actual)));\n    }\n\n    /**\n     * Test that tags with a namespace are not considered as unknown tags by HTMLCleaner (see also <a\n     * href=\"https://jira.xwiki.org/browse/XWIKI-9753\">XWIKI-9753</a>).\n     */\n    @Test\n    void cleanSVGTags() throws Exception\n    {\n        String input =\n            \"<p>before</p>\\n\" + \"<p><svg xmlns=\\\"http://www.w3.org/2000/svg\\\" version=\\\"1.1\\\">\\n\"\n                + \"<circle cx=\\\"100\\\" cy=\\\"50\\\" fill=\\\"red\\\" r=\\\"40\\\" stroke=\\\"black\\\" stroke-width=\\\"2\\\"></circle>\\n\"\n                + \"</svg></p>\\n\" + \"<p>after</p>\\n\";\n        assertHTML(input, getHeaderFull() + input + FOOTER);\n    }\n\n    /**\n     * Test that cleaning works when there's a TITLE element in the body (but with a namespace). The issue was that\n     * HTMLCleaner would consider it a duplicate of the TITLE element in the HEAD even though it's namespaced. (see\n     * also\n     * <a href=\"https://jira.xwiki.org/browse/XWIKI-9753\">XWIKI-9753</a>).\n     */\n    @Disabled(\"See https://jira.xwiki.org/browse/XWIKI-9753\")\n    @Test\n    void cleanTitleWithNamespace()\n    {\n        // Test with TITLE in HEAD\n        String input =\n            \"<html xmlns=\\\"http://www.w3.org/1999/xhtml\\\" lang=\\\"en\\\" xml:lang=\\\"en\\\">\\n\"\n                + \"  <head>\\n\"\n                + \"    <title>Title test</title>\\n\"\n                + \"  </head>\\n\"\n                + \"  <body>\\n\"\n                + \"    <p>before</p>\\n\"\n                + \"    <svg xmlns=\\\"http://www.w3.org/2000/svg\\\" height=\\\"300\\\" width=\\\"500\\\">\\n\"\n                + \"      <g>\\n\"\n                + \"        <title>SVG Title Demo example</title>\\n\"\n                + \"        <rect height=\\\"50\\\" style=\\\"fill:none; stroke:blue; stroke-width:1px\\\" width=\\\"200\\\" x=\\\"10\\\" \"\n                + \"y=\\\"10\\\"></rect>\\n\" + \"      </g>\\n\" + \"    </svg>\\n\" + \"    <p>after</p>\\n\";\n        assertEquals(getHeader() + input + FOOTER,\n            HTMLUtils.toString(clean(input)));\n    }\n\n    /**\n     * Verify that a xmlns namespace set on the HTML element is not removed by default and it's removed if {@link\n     * HTMLCleanerConfiguration#NAMESPACES_AWARE} is set to false.\n     */\n    @Test\n    void cleanHTMLTagWithNamespace()\n    {\n        String input = \"<html xmlns=\\\"http://www.w3.org/1999/xhtml\\\"><head></head><body>\";\n\n        // Default\n        assertEquals(getHeader() + input + FOOTER,\n            HTMLUtils.toString(clean(input)));\n\n        // Configured for namespace awareness being false\n        Map<String, String> parameters = new HashMap<>(this.cleanerConfiguration.getParameters());\n        parameters.put(HTMLCleanerConfiguration.NAMESPACES_AWARE, \"false\");\n        this.cleanerConfiguration.setParameters(parameters);\n        assertEquals(getHeader() + \"<html><head></head><body>\" + FOOTER,\n            HTMLUtils.toString(clean(input)));\n    }\n\n    /**\n     * Test that cleaning an empty DIV works (it used to fail, see <a href=\"https://jira.xwiki.org/browse/XWIKI-4007\">XWIKI-4007</a>).\n     */\n    @Test\n    void cleanEmptyDIV()\n    {\n        String input = \"<div id=\\\"y\\\"></div><div id=\\\"z\\\">something</div>\";\n        assertHTML(input, getHeaderFull() + input + FOOTER);\n    }\n\n    @Test\n    void verifyLegendTagNotStripped()\n    {\n        String input = \"<fieldset><legend>test</legend><div>content</div></fieldset>\";\n        assertHTML(input, getHeaderFull() + input + FOOTER);\n    }\n\n    @Test",
    "code_after_change": "        String actual = \"<p id=\\\"x\\\">1</p><p id=\\\"xy\\\">2</p><p id=\\\"x\\\">3</p>\";\n        String expected = \"<p id=\\\"x\\\">1</p><p id=\\\"xy\\\">2</p><p id=\\\"x0\\\">3</p>\";\n        List<HTMLFilter> filters = new ArrayList<>(this.cleanerConfiguration.getFilters());\n        filters.add(componentManager.getInstance(HTMLFilter.class, \"uniqueId\"));\n        this.cleanerConfiguration.setFilters(filters);\n        assertEquals(getHeaderFull() + expected + FOOTER,\n            HTMLUtils.toString(clean(actual)));\n    }\n\n    /**\n     * Test that tags with a namespace are not considered as unknown tags by HTMLCleaner (see also <a\n     * href=\"https://jira.xwiki.org/browse/XWIKI-9753\">XWIKI-9753</a>).\n     */\n    @Test\n    void cleanSVGTags() throws Exception\n    {\n        String input =\n            \"<p>before</p>\\n\" + \"<p><svg xmlns=\\\"http://www.w3.org/2000/svg\\\" version=\\\"1.1\\\">\\n\"\n                + \"<circle cx=\\\"100\\\" cy=\\\"50\\\" fill=\\\"red\\\" r=\\\"40\\\" stroke=\\\"black\\\" stroke-width=\\\"2\\\"></circle>\\n\"\n                + \"</svg></p>\\n\" + \"<p>after</p>\\n\";\n        assertHTML(input, getHeaderFull() + input + FOOTER);\n    }\n\n    /**\n     * Test that cleaning works when there's a TITLE element in the body (but with a namespace). The issue was that\n     * HTMLCleaner would consider it a duplicate of the TITLE element in the HEAD even though it's namespaced. (see\n     * also\n     * <a href=\"https://jira.xwiki.org/browse/XWIKI-9753\">XWIKI-9753</a>).\n     */\n    @Test\n    void cleanTitleWithNamespace()\n    {\n        // Test with TITLE in HEAD\n        String input =\n            \"<html xmlns=\\\"http://www.w3.org/1999/xhtml\\\" lang=\\\"en\\\">\"\n                + \"<head>\\n\"\n                + \"    <title>Title test</title>\\n\"\n                + \"  </head>\"\n                + \"<body>\\n\"\n                + \"    <p>before</p>\\n\"\n                + \"    <p><svg xmlns=\\\"http://www.w3.org/2000/svg\\\" height=\\\"300\\\" width=\\\"500\\\">\\n\"\n                + \"      <g>\\n\"\n                + \"        <title>SVG Title Demo example</title>\\n\"\n                + \"        <rect height=\\\"50\\\" style=\\\"fill:none; stroke:blue; stroke-width:1px\\\" width=\\\"200\\\" x=\\\"10\\\" \"\n                + \"y=\\\"10\\\"></rect>\\n\" + \"      </g>\\n\" + \"    </svg></p>\\n\" + \"    <p>after</p>\\n\";\n        assertEquals(getHeader() + input + FOOTER,\n            HTMLUtils.toString(clean(input)));\n    }\n\n    /**\n     * Verify that a xmlns namespace set on the HTML element is not removed by default and it's removed if\n     * {@link HTMLCleanerConfiguration#NAMESPACES_AWARE} is set to false.\n     */\n    @Test\n    void cleanHTMLTagWithNamespace()\n    {\n        String input = \"<html xmlns=\\\"http://www.w3.org/1999/xhtml\\\"><head></head><body>\";\n\n        // Default\n        assertEquals(getHeader() + input + FOOTER,\n            HTMLUtils.toString(clean(input)));\n\n        // Configured for namespace awareness being false\n        Map<String, String> parameters = new HashMap<>(this.cleanerConfiguration.getParameters());\n        parameters.put(HTMLCleanerConfiguration.NAMESPACES_AWARE, \"false\");\n        this.cleanerConfiguration.setParameters(parameters);\n        assertEquals(getHeader() + \"<html><head></head><body>\" + FOOTER,\n            HTMLUtils.toString(clean(input)));\n    }\n\n    /**\n     * Check that template tags inside select don't survive, might be security-relevant, DOMPurify contains a similar\n     * check, see <a href=\"https://github.com/cure53/DOMPurify/commit/e32ca248c0e9450fb182e52e978631cbd78f1123\">commit\n     * e32ca248c0 in DOMPurify</a>.\n     */\n    @Test\n    void cleanTemplateInsideSelect()\n    {\n        assertHTML(\"<p><select></select></p>\", \"<select><template></template></select>\");\n    }\n\n    /**\n     * Test that cleaning an empty DIV works (it used to fail, see <a\n     * href=\"https://jira.xwiki.org/browse/XWIKI-4007\">XWIKI-4007</a>).\n     */\n    @Test\n    void cleanEmptyDIV()\n    {",
    "patch": "@@ -36,6 +36,7 @@\n import org.w3c.dom.Document;\n import org.w3c.dom.NodeList;\n import org.xwiki.component.manager.ComponentManager;\n+import org.xwiki.configuration.internal.RestrictedConfigurationSourceProvider;\n import org.xwiki.test.annotation.ComponentList;\n import org.xwiki.test.junit5.mockito.ComponentTest;\n import org.xwiki.test.junit5.mockito.InjectMockComponents;\n@@ -49,6 +50,7 @@\n import org.xwiki.xml.internal.html.filter.LinkFilter;\n import org.xwiki.xml.internal.html.filter.ListFilter;\n import org.xwiki.xml.internal.html.filter.ListItemFilter;\n+import org.xwiki.xml.internal.html.filter.SanitizerFilter;\n import org.xwiki.xml.internal.html.filter.UniqueIdFilter;\n \n import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -71,6 +73,14 @@\n     DefaultHTMLCleaner.class,\n     LinkFilter.class,\n     ControlCharactersFilter.class,\n+    SanitizerFilter.class,\n+    DefaultHTMLElementSanitizer.class,\n+    SecureHTMLElementSanitizer.class,\n+    HTMLElementSanitizerConfiguration.class,\n+    RestrictedConfigurationSourceProvider.class,\n+    HTMLDefinitions.class,\n+    MathMLDefinitions.class,\n+    SVGDefinitions.class,\n     XWikiHTML5TagProvider.class\n })\n // @formatter:on\n@@ -107,7 +117,7 @@ public String getHeaderFull()\n \n     /**\n      * Cleans using the cleaner configuration {@link DefaultHTMLCleanerTest#cleanerConfiguration}.\n-     *\n+     * <p>\n      * Ensures that always the correct configuration is used and allows executing the same tests for HTML 4 and HTML 5.\n      *\n      * @param originalHtmlContent The content to clean as string.\n@@ -322,6 +332,31 @@ void restrictedHtml()\n         assertEquals(getHeaderFull() + \"<pre>p {color:white;}</pre>\" + FOOTER, result);\n     }\n \n+    /**\n+     * Verify that the restricted parameter forbids dangerous attributes and tags.\n+     */\n+    @Test\n+    void restrictedAttributesAndTags() throws Exception\n+    {\n+        Map<String, String> parameters = new HashMap<>(this.cleanerConfiguration.getParameters());\n+        parameters.put(\"restricted\", \"true\");\n+        this.cleanerConfiguration.setParameters(parameters);\n+\n+        assertHTML(\"<p><img src=\\\"img.png\\\" /></p>\", \"<img onerror=\\\"alert(1)\\\" src=img.png />\");\n+        assertHTML(\"<p><a>Hello!</a></p>\", \"<a href=\\\"javascript:alert(1)\\\">Hello!</a>\");\n+        assertHTML(\"<p></p>\", \"<iframe src=\\\"whatever\\\"/>\");\n+\n+        // Check that SVG is still working in restricted mode.\n+        cleanSVGTags();\n+        cleanTitleWithNamespace();\n+\n+        // Check that MathML is still working in restricted mode.\n+        assertHTML(\"<p><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><mtext>X</mtext><mi><span>foo</span>\"\n+                + \"</mi></math></p>\",\n+            \"<math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><span></span><mtext>X</mtext><mi><span>foo</span>\"\n+                + \"</mi></math>\");\n+    }\n+\n     /**\n      * Verify that passing a fully-formed XHTML header works fine.\n      */\n@@ -366,30 +401,29 @@ void cleanSVGTags() throws Exception\n      * also\n      * <a href=\"https://jira.xwiki.org/browse/XWIKI-9753\">XWIKI-9753</a>).\n      */\n-    @Disabled(\"See https://jira.xwiki.org/browse/XWIKI-9753\")\n     @Test\n     void cleanTitleWithNamespace()\n     {\n         // Test with TITLE in HEAD\n         String input =\n-            \"<html xmlns=\\\"http://www.w3.org/1999/xhtml\\\" lang=\\\"en\\\" xml:lang=\\\"en\\\">\\n\"\n-                + \"  <head>\\n\"\n+            \"<html xmlns=\\\"http://www.w3.org/1999/xhtml\\\" lang=\\\"en\\\">\"\n+                + \"<head>\\n\"\n                 + \"    <title>Title test</title>\\n\"\n-                + \"  </head>\\n\"\n-                + \"  <body>\\n\"\n+                + \"  </head>\"\n+                + \"<body>\\n\"\n                 + \"    <p>before</p>\\n\"\n-                + \"    <svg xmlns=\\\"http://www.w3.org/2000/svg\\\" height=\\\"300\\\" width=\\\"500\\\">\\n\"\n+                + \"    <p><svg xmlns=\\\"http://www.w3.org/2000/svg\\\" height=\\\"300\\\" width=\\\"500\\\">\\n\"\n                 + \"      <g>\\n\"\n                 + \"        <title>SVG Title Demo example</title>\\n\"\n                 + \"        <rect height=\\\"50\\\" style=\\\"fill:none; stroke:blue; stroke-width:1px\\\" width=\\\"200\\\" x=\\\"10\\\" \"\n-                + \"y=\\\"10\\\"></rect>\\n\" + \"      </g>\\n\" + \"    </svg>\\n\" + \"    <p>after</p>\\n\";\n+                + \"y=\\\"10\\\"></rect>\\n\" + \"      </g>\\n\" + \"    </svg></p>\\n\" + \"    <p>after</p>\\n\";\n         assertEquals(getHeader() + input + FOOTER,\n             HTMLUtils.toString(clean(input)));\n     }\n \n     /**\n-     * Verify that a xmlns namespace set on the HTML element is not removed by default and it's removed if {@link\n-     * HTMLCleanerConfiguration#NAMESPACES_AWARE} is set to false.\n+     * Verify that a xmlns namespace set on the HTML element is not removed by default and it's removed if\n+     * {@link HTMLCleanerConfiguration#NAMESPACES_AWARE} is set to false.\n      */\n     @Test\n     void cleanHTMLTagWithNamespace()\n@@ -409,7 +443,19 @@ void cleanHTMLTagWithNamespace()\n     }\n \n     /**\n-     * Test that cleaning an empty DIV works (it used to fail, see <a href=\"https://jira.xwiki.org/browse/XWIKI-4007\">XWIKI-4007</a>).\n+     * Check that template tags inside select don't survive, might be security-relevant, DOMPurify contains a similar\n+     * check, see <a href=\"https://github.com/cure53/DOMPurify/commit/e32ca248c0e9450fb182e52e978631cbd78f1123\">commit\n+     * e32ca248c0 in DOMPurify</a>.\n+     */\n+    @Test\n+    void cleanTemplateInsideSelect()\n+    {\n+        assertHTML(\"<p><select></select></p>\", \"<select><template></template></select>\");\n+    }\n+\n+    /**\n+     * Test that cleaning an empty DIV works (it used to fail, see <a\n+     * href=\"https://jira.xwiki.org/browse/XWIKI-4007\">XWIKI-4007</a>).\n      */\n     @Test\n     void cleanEmptyDIV()\n@@ -607,7 +653,7 @@ void divInsideDl()\n \n     /**\n      * Check what happens when the dt-tag is inside div.\n-     *\n+     * <p>\n      * This should add a wrapping dl but doesn't for HTML 4, but it works in HTML5, see\n      * {@link HTML5HTMLCleanerTest#divWithDt()}.\n      *",
    "function_modified_lines": {
      "added": [
        "            \"<html xmlns=\\\"http://www.w3.org/1999/xhtml\\\" lang=\\\"en\\\">\"\n",
        "                + \"<head>\\n\"\n",
        "                + \"  </head>\"\n",
        "                + \"<body>\\n\"\n",
        "                + \"    <p><svg xmlns=\\\"http://www.w3.org/2000/svg\\\" height=\\\"300\\\" width=\\\"500\\\">\\n\"\n",
        "                + \"y=\\\"10\\\"></rect>\\n\" + \"      </g>\\n\" + \"    </svg></p>\\n\" + \"    <p>after</p>\\n\";\n",
        "     * Verify that a xmlns namespace set on the HTML element is not removed by default and it's removed if\n",
        "     * {@link HTMLCleanerConfiguration#NAMESPACES_AWARE} is set to false.\n"
      ],
      "deleted": [
        "    @Disabled(\"See https://jira.xwiki.org/browse/XWIKI-9753\")\n",
        "            \"<html xmlns=\\\"http://www.w3.org/1999/xhtml\\\" lang=\\\"en\\\" xml:lang=\\\"en\\\">\\n\"\n",
        "                + \"  <head>\\n\"\n",
        "                + \"  </head>\\n\"\n",
        "                + \"  <body>\\n\"\n",
        "                + \"    <svg xmlns=\\\"http://www.w3.org/2000/svg\\\" height=\\\"300\\\" width=\\\"500\\\">\\n\"\n",
        "                + \"y=\\\"10\\\"></rect>\\n\" + \"      </g>\\n\" + \"    </svg>\\n\" + \"    <p>after</p>\\n\";\n",
        "     * Verify that a xmlns namespace set on the HTML element is not removed by default and it's removed if {@link\n",
        "     * HTMLCleanerConfiguration#NAMESPACES_AWARE} is set to false.\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-79"
    ],
    "cve_description": "XWiki Commons are technical libraries common to several other top level XWiki projects. The \"restricted\" mode of the HTML cleaner in XWiki, introduced in version 4.2-milestone-1, only escaped `<script>` and `<style>`-tags but neither attributes that can be used to inject scripts nor other dangerous HTML tags like `<iframe>`. As a consequence, any code relying on this \"restricted\" mode for security is vulnerable to JavaScript injection (\"cross-site scripting\"/XSS). When a privileged user with programming rights visits such a comment in XWiki, the malicious JavaScript code is executed in the context of the user session. This allows server-side code execution with programming rights, impacting the confidentiality, integrity and availability of the XWiki instance. This problem has been patched in XWiki 14.6 RC1 with the introduction of a filter with allowed HTML elements and attributes that is enabled in restricted mode. There are no known workarounds apart from upgrading to a version including the fix.",
    "id": 12605
  },
  {
    "cve_id": "CVE-2023-31126",
    "code_before_change": "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.xml.internal.html;\n\nimport java.util.Arrays;\nimport java.util.Collections;\n\nimport org.junit.jupiter.api.Test;\nimport org.xwiki.test.annotation.BeforeComponent;\nimport org.xwiki.test.annotation.ComponentList;\nimport org.xwiki.test.junit5.mockito.ComponentTest;\nimport org.xwiki.test.junit5.mockito.InjectMockComponents;\nimport org.xwiki.test.junit5.mockito.MockComponent;\nimport org.xwiki.xml.html.HTMLConstants;\n\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.mockito.Mockito.when;\n\n/**\n * Unit tests for the {@link SecureHTMLElementSanitizer}.\n *\n * @version $Id$\n * @since 14.6RC1\n */\n@ComponentTest\n@ComponentList({\n    HTMLDefinitions.class,\n    MathMLDefinitions.class,\n    SVGDefinitions.class\n})\nclass SecureHTMLElementSanitizerTest\n{\n    private static final String ALLOWED_ATTRIBUTE = \"allowed_attribute\";\n\n    private static final String ONERROR = \"onerror\";\n\n    @MockComponent\n    private HTMLElementSanitizerConfiguration htmlElementSanitizerConfiguration;\n\n    @InjectMockComponents\n    private SecureHTMLElementSanitizer secureHTMLElementSanitizer;\n\n    @BeforeComponent\n    void setupMocks()\n    {\n        when(this.htmlElementSanitizerConfiguration.getForbidTags())\n            .thenReturn(Collections.singletonList(HTMLConstants.TAG_A));\n        when(this.htmlElementSanitizerConfiguration.getForbidAttributes())\n            .thenReturn(Collections.singletonList(HTMLConstants.ATTRIBUTE_ALT));\n        when(this.htmlElementSanitizerConfiguration.getExtraAllowedTags())\n            .thenReturn(Collections.singletonList(HTMLConstants.TAG_SCRIPT));\n        when(this.htmlElementSanitizerConfiguration.getExtraAllowedAttributes())\n            .thenReturn(Arrays.asList(ALLOWED_ATTRIBUTE, ONERROR));\n        when(this.htmlElementSanitizerConfiguration.getExtraUriSafeAttributes())\n            .thenReturn(Collections.singletonList(HTMLConstants.ATTRIBUTE_SRC));\n        when(this.htmlElementSanitizerConfiguration.getExtraDataUriTags())\n            .thenReturn(Arrays.asList(HTMLConstants.TAG_SCRIPT, HTMLConstants.TAG_NAV));\n        when(this.htmlElementSanitizerConfiguration.isAllowUnknownProtocols())\n            .thenReturn(false);\n        when(this.htmlElementSanitizerConfiguration.getAllowedUriRegexp())\n            .thenReturn(\"^(xwiki|https):\");\n    }\n\n    @Test\n    void forbiddenTags()\n    {\n        assertFalse(this.secureHTMLElementSanitizer.isElementAllowed(HTMLConstants.TAG_A));\n    }\n\n    @Test\n    void forbiddenAttributes()\n    {\n        assertFalse(this.secureHTMLElementSanitizer.isAttributeAllowed(HTMLConstants.TAG_IMG,\n            HTMLConstants.ATTRIBUTE_ALT, \"XWiki\"));\n    }\n\n    @Test\n    void extraAllowedTags()\n    {\n        assertTrue(this.secureHTMLElementSanitizer.isElementAllowed(HTMLConstants.TAG_SCRIPT));\n    }\n\n    @Test\n    void extraAllowedAttributes()\n    {\n        assertTrue(this.secureHTMLElementSanitizer.isAttributeAllowed(HTMLConstants.TAG_IMG, ALLOWED_ATTRIBUTE,\n            \"value\"));\n        assertTrue(this.secureHTMLElementSanitizer.isAttributeAllowed(HTMLConstants.TAG_IMG, ONERROR, \"alert(1)\"));\n    }\n\n    @Test\n    void extraUriSafeAttributes()\n    {\n        assertTrue(this.secureHTMLElementSanitizer.isAttributeAllowed(HTMLConstants.TAG_IMG,\n            HTMLConstants.ATTRIBUTE_SRC, \"javascript:alert(1)\"));\n    }\n\n    @Test\n    void extraDataUriTags()\n    {\n        assertTrue(this.secureHTMLElementSanitizer.isAttributeAllowed(HTMLConstants.TAG_NAV,\n            HTMLConstants.ATTRIBUTE_HREF, \"data:test\"));\n        // Script cannot be enabled for data-attributes.\n        assertFalse(this.secureHTMLElementSanitizer.isAttributeAllowed(HTMLConstants.TAG_SCRIPT,\n            HTMLConstants.ATTRIBUTE_HREF, \"data:script\"));\n    }\n\n    @Test\n    void restrictedURIs()\n    {\n        assertTrue(this.secureHTMLElementSanitizer.isAttributeAllowed(HTMLConstants.TAG_A,\n            HTMLConstants.ATTRIBUTE_HREF, \"https://www.xwiki.org\"));\n        assertTrue(this.secureHTMLElementSanitizer.isAttributeAllowed(HTMLConstants.TAG_A,\n            HTMLConstants.ATTRIBUTE_HREF, \"xwiki:test\"));\n        assertFalse(this.secureHTMLElementSanitizer.isAttributeAllowed(HTMLConstants.TAG_A,\n            HTMLConstants.ATTRIBUTE_HREF, \"http://example.com\"));\n    }\n}\n",
    "code_after_change": "{\n    private static final String ALLOWED_ATTRIBUTE = \"allowed_attribute\";\n\n    private static final String ONERROR = \"onerror\";\n\n    @MockComponent\n    private HTMLElementSanitizerConfiguration htmlElementSanitizerConfiguration;\n\n    @InjectMockComponents\n    private SecureHTMLElementSanitizer secureHTMLElementSanitizer;\n\n    @BeforeComponent\n    void setupMocks()\n    {\n        when(this.htmlElementSanitizerConfiguration.getForbidTags())\n            .thenReturn(Collections.singletonList(HTMLConstants.TAG_A));\n        when(this.htmlElementSanitizerConfiguration.getForbidAttributes())\n            .thenReturn(Collections.singletonList(HTMLConstants.ATTRIBUTE_ALT));\n        when(this.htmlElementSanitizerConfiguration.getExtraAllowedTags())\n            .thenReturn(Collections.singletonList(HTMLConstants.TAG_SCRIPT));\n        when(this.htmlElementSanitizerConfiguration.getExtraAllowedAttributes())\n            .thenReturn(Arrays.asList(ALLOWED_ATTRIBUTE, ONERROR));\n        when(this.htmlElementSanitizerConfiguration.getExtraUriSafeAttributes())\n            .thenReturn(Collections.singletonList(HTMLConstants.ATTRIBUTE_SRC));\n        when(this.htmlElementSanitizerConfiguration.getExtraDataUriTags())\n            .thenReturn(Arrays.asList(HTMLConstants.TAG_SCRIPT, HTMLConstants.TAG_NAV));\n        when(this.htmlElementSanitizerConfiguration.isAllowUnknownProtocols())\n            .thenReturn(false);\n        when(this.htmlElementSanitizerConfiguration.getAllowedUriRegexp())\n            .thenReturn(\"^(xwiki|https):\");\n    }\n\n    @Test\n    void forbiddenTags()\n    {\n        assertFalse(this.secureHTMLElementSanitizer.isElementAllowed(HTMLConstants.TAG_A));\n    }\n\n    @Test\n    void forbiddenAttributes()\n    {\n        assertFalse(this.secureHTMLElementSanitizer.isAttributeAllowed(HTMLConstants.TAG_IMG,\n            HTMLConstants.ATTRIBUTE_ALT, \"XWiki\"));\n    }\n\n    @Test\n    void extraAllowedTags()\n    {\n        assertTrue(this.secureHTMLElementSanitizer.isElementAllowed(HTMLConstants.TAG_SCRIPT));\n    }\n\n    @Test\n    void extraAllowedAttributes()\n    {\n        assertTrue(this.secureHTMLElementSanitizer.isAttributeAllowed(HTMLConstants.TAG_IMG, ALLOWED_ATTRIBUTE,\n            \"value\"));\n        assertTrue(this.secureHTMLElementSanitizer.isAttributeAllowed(HTMLConstants.TAG_IMG, ONERROR, \"alert(1)\"));\n    }\n\n    @Test\n    void extraUriSafeAttributes()\n    {\n        assertTrue(this.secureHTMLElementSanitizer.isAttributeAllowed(HTMLConstants.TAG_IMG,\n            HTMLConstants.ATTRIBUTE_SRC, \"javascript:alert(1)\"));\n    }\n\n    @Test\n    void extraDataUriTags()\n    {\n        assertTrue(this.secureHTMLElementSanitizer.isAttributeAllowed(HTMLConstants.TAG_NAV,\n            HTMLConstants.ATTRIBUTE_HREF, \"data:test\"));\n        // Script cannot be enabled for data-attributes.\n        assertFalse(this.secureHTMLElementSanitizer.isAttributeAllowed(HTMLConstants.TAG_SCRIPT,\n            HTMLConstants.ATTRIBUTE_HREF, \"data:script\"));\n    }\n\n    @Test\n    void restrictedURIs()\n    {\n        assertTrue(this.secureHTMLElementSanitizer.isAttributeAllowed(HTMLConstants.TAG_A,\n            HTMLConstants.ATTRIBUTE_HREF, \"https://www.xwiki.org\"));\n        assertTrue(this.secureHTMLElementSanitizer.isAttributeAllowed(HTMLConstants.TAG_A,\n            HTMLConstants.ATTRIBUTE_HREF, \"xwiki:test\"));\n        assertFalse(this.secureHTMLElementSanitizer.isAttributeAllowed(HTMLConstants.TAG_A,\n            HTMLConstants.ATTRIBUTE_HREF, \"http://example.com\"));\n    }\n\n    @ParameterizedTest\n    @CsvSource({\n        \"data-, false\",\n        \"data-a, true\",\n        \"data-x-wiki.test_\\u0192, true\",\n        \"data-x\\u2713, false\",\n        \"data-x/test, false\",\n        \"data-x>test, false\",\n        \"data-x:y, false\"\n    })\n    void dataAttributes(String attribute, boolean accepted)\n    {\n        assertEquals(accepted, this.secureHTMLElementSanitizer.isAttributeAllowed(HTMLConstants.TAG_DIV, attribute,\n            \"hello\"));\n    }\n}",
    "patch": "@@ -23,13 +23,16 @@\n import java.util.Collections;\n \n import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.CsvSource;\n import org.xwiki.test.annotation.BeforeComponent;\n import org.xwiki.test.annotation.ComponentList;\n import org.xwiki.test.junit5.mockito.ComponentTest;\n import org.xwiki.test.junit5.mockito.InjectMockComponents;\n import org.xwiki.test.junit5.mockito.MockComponent;\n import org.xwiki.xml.html.HTMLConstants;\n \n+import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.assertFalse;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n import static org.mockito.Mockito.when;\n@@ -133,4 +136,20 @@ void restrictedURIs()\n         assertFalse(this.secureHTMLElementSanitizer.isAttributeAllowed(HTMLConstants.TAG_A,\n             HTMLConstants.ATTRIBUTE_HREF, \"http://example.com\"));\n     }\n+\n+    @ParameterizedTest\n+    @CsvSource({\n+        \"data-, false\",\n+        \"data-a, true\",\n+        \"data-x-wiki.test_\\u0192, true\",\n+        \"data-x\\u2713, false\",\n+        \"data-x/test, false\",\n+        \"data-x>test, false\",\n+        \"data-x:y, false\"\n+    })\n+    void dataAttributes(String attribute, boolean accepted)\n+    {\n+        assertEquals(accepted, this.secureHTMLElementSanitizer.isAttributeAllowed(HTMLConstants.TAG_DIV, attribute,\n+            \"hello\"));\n+    }\n }",
    "function_modified_lines": {
      "added": [
        "\n",
        "    @ParameterizedTest\n",
        "    @CsvSource({\n",
        "        \"data-, false\",\n",
        "        \"data-a, true\",\n",
        "        \"data-x-wiki.test_\\u0192, true\",\n",
        "        \"data-x\\u2713, false\",\n",
        "        \"data-x/test, false\",\n",
        "        \"data-x>test, false\",\n",
        "        \"data-x:y, false\"\n",
        "    })\n",
        "    void dataAttributes(String attribute, boolean accepted)\n",
        "    {\n",
        "        assertEquals(accepted, this.secureHTMLElementSanitizer.isAttributeAllowed(HTMLConstants.TAG_DIV, attribute,\n",
        "            \"hello\"));\n",
        "    }\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-79"
    ],
    "cve_description": "`org.xwiki.commons:xwiki-commons-xml` is an XML library used by the open-source wiki platform XWiki. The HTML sanitizer, introduced in version 14.6-rc-1, allows the injection of arbitrary HTML code and thus cross-site scripting via invalid data attributes. This vulnerability does not affect restricted cleaning in HTMLCleaner as there attributes are cleaned and thus characters like `/` and `>` are removed in all attribute names. This problem has been patched in XWiki 14.10.4 and 15.0 RC1 by making sure that data attributes only contain allowed characters. There are no known workarounds apart from upgrading to a version including the fix.",
    "id": 12608
  },
  {
    "cve_id": "CVE-2023-36471",
    "code_before_change": "(\"a\", \"abbr\", \"acronym\", \"address\", \"area\", \"article\", \"aside\", \"audio\", \"b\", \"bdi\", \"bdo\",\n                \"big\", \"blink\", \"blockquote\", \"body\", \"br\", \"button\", \"canvas\", \"caption\", \"center\", \"cite\", \"code\",\n                \"col\", \"colgroup\", \"content\", \"data\", \"datalist\", \"dd\", \"decorator\", \"del\", \"details\", \"dfn\", \"dialog\",\n                \"dir\", \"div\", \"dl\", \"dt\", \"element\", \"em\", \"fieldset\", \"figcaption\", \"figure\", \"font\", \"footer\", \"form\",\n                \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"head\", \"header\", \"hgroup\", \"hr\", \"html\", \"i\", \"img\", \"input\",\n                \"ins\", \"kbd\", \"label\", \"legend\", \"li\", \"main\", \"map\", \"mark\", \"marquee\", \"menu\", \"menuitem\", \"meter\",\n                \"nav\", \"nobr\", \"ol\", \"optgroup\", \"option\", \"output\", \"p\", \"picture\", \"pre\", \"progress\", \"q\", \"rp\", \"rt\",\n                \"ruby\", \"s\", \"samp\", \"section\", \"select\", \"shadow\", \"small\", \"source\", \"spacer\", \"span\", \"strike\",\n                \"strong\", \"style\", \"sub\", \"summary\", \"sup\", \"table\", \"tbody\", \"td\", \"template\", \"textarea\", \"tfoot\",\n                \"th\", \"thead\", \"time\", \"tr\", \"track\", \"tt\", \"u\", \"ul\", \"var\", \"video\", \"wbr\")",
    "code_after_change": "{\n        // Compared to DOMPurify, this disallows form-related tags as they can be dangerous in the context of XWiki.\n        this.htmlTags = new HashSet<>(\n            Arrays.asList(\"a\", \"abbr\", \"acronym\", \"address\", \"area\", \"article\", \"aside\", \"audio\", \"b\", \"bdi\", \"bdo\",\n                \"big\", \"blink\", \"blockquote\", \"body\", \"br\", \"canvas\", \"caption\", \"center\", \"cite\", \"code\",\n                \"col\", \"colgroup\", \"content\", \"data\", \"datalist\", \"dd\", \"decorator\", \"del\", \"details\", \"dfn\", \"dialog\",\n                \"dir\", \"div\", \"dl\", \"dt\", \"element\", \"em\", \"fieldset\", \"figcaption\", \"figure\", \"font\", \"footer\",\n                \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"head\", \"header\", \"hgroup\", \"hr\", \"html\", \"i\", \"img\",\n                \"ins\", \"kbd\", \"label\", \"legend\", \"li\", \"main\", \"map\", \"mark\", \"marquee\", \"menu\", \"menuitem\", \"meter\",\n                \"nav\", \"nobr\", \"ol\", \"optgroup\", \"option\", \"output\", \"p\", \"picture\", \"pre\", \"progress\", \"q\", \"rp\", \"rt\",\n                \"ruby\", \"s\", \"samp\", \"section\", \"shadow\", \"small\", \"source\", \"spacer\", \"span\", \"strike\",\n                \"strong\", \"style\", \"sub\", \"summary\", \"sup\", \"table\", \"tbody\", \"td\", \"template\", \"tfoot\",\n                \"th\", \"thead\", \"time\", \"tr\", \"track\", \"tt\", \"u\", \"ul\", \"var\", \"video\", \"wbr\"));\n\n        // Attributes that are in general allowed. Note that \"target\" is not generally safe, but XWiki contains code\n        // that already adds the necessary attributes to make it safe both in HTMLCleaner and in XHTML rendering.\n        this.htmlAttributes = new HashSet<>(\n            Arrays.asList(\"accept\", \"action\", \"align\", \"alt\", \"autocapitalize\", \"autocomplete\", \"autopictureinpicture\",\n                \"autoplay\", \"background\", \"bgcolor\", \"border\", \"capture\", \"cellpadding\", \"cellspacing\", \"checked\",\n                \"cite\", \"class\", \"clear\", \"color\", \"cols\", \"colspan\", \"controls\", \"controlslist\", \"coords\",\n                \"crossorigin\", \"datetime\", \"decoding\", \"default\", \"dir\", \"disabled\", \"disablepictureinpicture\",\n                \"disableremoteplayback\", \"download\", \"draggable\", \"enctype\", \"enterkeyhint\", \"face\", \"for\", \"headers\",\n                \"height\", \"hidden\", \"high\", \"href\", \"hreflang\", \"id\", \"inputmode\", \"integrity\", \"ismap\", \"kind\",\n                \"label\", \"lang\", \"list\", \"loading\", \"loop\", \"low\", \"max\", \"maxlength\", \"media\", \"method\", \"min\",\n                \"minlength\", \"multiple\", \"muted\", \"name\", \"nonce\", \"noshade\", \"novalidate\", \"nowrap\", \"open\", \"optimum\",\n                \"pattern\", \"placeholder\", \"playsinline\", \"poster\", \"preload\", \"pubdate\", \"radiogroup\", \"readonly\",\n                \"rel\", \"required\", \"rev\", \"reversed\", \"role\", \"rows\", \"rowspan\", \"spellcheck\", \"scope\", \"selected\",\n                \"shape\", \"size\", \"sizes\", \"span\", \"srclang\", \"start\", \"src\", \"srcset\", \"step\", \"style\", \"summary\",\n                \"tabindex\", \"title\", \"translate\", \"type\", \"usemap\", \"valign\", \"value\", \"width\", \"xmlns\", \"slot\",\n                \"target\"));\n    }",
    "patch": "@@ -60,16 +60,17 @@ public class HTMLDefinitions\n      */\n     public HTMLDefinitions()\n     {\n+        // Compared to DOMPurify, this disallows form-related tags as they can be dangerous in the context of XWiki.\n         this.htmlTags = new HashSet<>(\n             Arrays.asList(\"a\", \"abbr\", \"acronym\", \"address\", \"area\", \"article\", \"aside\", \"audio\", \"b\", \"bdi\", \"bdo\",\n-                \"big\", \"blink\", \"blockquote\", \"body\", \"br\", \"button\", \"canvas\", \"caption\", \"center\", \"cite\", \"code\",\n+                \"big\", \"blink\", \"blockquote\", \"body\", \"br\", \"canvas\", \"caption\", \"center\", \"cite\", \"code\",\n                 \"col\", \"colgroup\", \"content\", \"data\", \"datalist\", \"dd\", \"decorator\", \"del\", \"details\", \"dfn\", \"dialog\",\n-                \"dir\", \"div\", \"dl\", \"dt\", \"element\", \"em\", \"fieldset\", \"figcaption\", \"figure\", \"font\", \"footer\", \"form\",\n-                \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"head\", \"header\", \"hgroup\", \"hr\", \"html\", \"i\", \"img\", \"input\",\n+                \"dir\", \"div\", \"dl\", \"dt\", \"element\", \"em\", \"fieldset\", \"figcaption\", \"figure\", \"font\", \"footer\",\n+                \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"head\", \"header\", \"hgroup\", \"hr\", \"html\", \"i\", \"img\",\n                 \"ins\", \"kbd\", \"label\", \"legend\", \"li\", \"main\", \"map\", \"mark\", \"marquee\", \"menu\", \"menuitem\", \"meter\",\n                 \"nav\", \"nobr\", \"ol\", \"optgroup\", \"option\", \"output\", \"p\", \"picture\", \"pre\", \"progress\", \"q\", \"rp\", \"rt\",\n-                \"ruby\", \"s\", \"samp\", \"section\", \"select\", \"shadow\", \"small\", \"source\", \"spacer\", \"span\", \"strike\",\n-                \"strong\", \"style\", \"sub\", \"summary\", \"sup\", \"table\", \"tbody\", \"td\", \"template\", \"textarea\", \"tfoot\",\n+                \"ruby\", \"s\", \"samp\", \"section\", \"shadow\", \"small\", \"source\", \"spacer\", \"span\", \"strike\",\n+                \"strong\", \"style\", \"sub\", \"summary\", \"sup\", \"table\", \"tbody\", \"td\", \"template\", \"tfoot\",\n                 \"th\", \"thead\", \"time\", \"tr\", \"track\", \"tt\", \"u\", \"ul\", \"var\", \"video\", \"wbr\"));\n \n         // Attributes that are in general allowed. Note that \"target\" is not generally safe, but XWiki contains code",
    "function_modified_lines": {
      "added": [
        "        // Compared to DOMPurify, this disallows form-related tags as they can be dangerous in the context of XWiki.\n",
        "                \"big\", \"blink\", \"blockquote\", \"body\", \"br\", \"canvas\", \"caption\", \"center\", \"cite\", \"code\",\n",
        "                \"dir\", \"div\", \"dl\", \"dt\", \"element\", \"em\", \"fieldset\", \"figcaption\", \"figure\", \"font\", \"footer\",\n",
        "                \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"head\", \"header\", \"hgroup\", \"hr\", \"html\", \"i\", \"img\",\n",
        "                \"ruby\", \"s\", \"samp\", \"section\", \"shadow\", \"small\", \"source\", \"spacer\", \"span\", \"strike\",\n",
        "                \"strong\", \"style\", \"sub\", \"summary\", \"sup\", \"table\", \"tbody\", \"td\", \"template\", \"tfoot\",\n"
      ],
      "deleted": [
        "                \"big\", \"blink\", \"blockquote\", \"body\", \"br\", \"button\", \"canvas\", \"caption\", \"center\", \"cite\", \"code\",\n",
        "                \"dir\", \"div\", \"dl\", \"dt\", \"element\", \"em\", \"fieldset\", \"figcaption\", \"figure\", \"font\", \"footer\", \"form\",\n",
        "                \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"head\", \"header\", \"hgroup\", \"hr\", \"html\", \"i\", \"img\", \"input\",\n",
        "                \"ruby\", \"s\", \"samp\", \"section\", \"select\", \"shadow\", \"small\", \"source\", \"spacer\", \"span\", \"strike\",\n",
        "                \"strong\", \"style\", \"sub\", \"summary\", \"sup\", \"table\", \"tbody\", \"td\", \"template\", \"textarea\", \"tfoot\",\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-79"
    ],
    "cve_description": "Xwiki commons is the common modules used by other XWiki top level projects. The HTML sanitizer that is included in XWiki since version 14.6RC1 allowed form and input HTML tags. In the context of XWiki, this allows an attacker without script right to either create forms that can be used for phishing attacks or also in the context of a sheet, the attacker could add an input like `{{html}}<input type=\"hidden\" name=\"content\" value=\"{{groovy}}println(&quot;Hello from Groovy!&quot;)\" />{{/html}}` that would allow remote code execution when it is submitted by an admin (the sheet is rendered as part of the edit form). The attacker would need to ensure that the edit form looks plausible, though, which can be non-trivial as without script right the attacker cannot display the regular content of the document. This has been patched in XWiki 14.10.6 and 15.2RC1 by removing the central form-related tags from the list of allowed tags. Users are advised to upgrade. As a workaround an admin can manually disallow the tags by adding `form, input, select, textarea, button` to the configuration option `xml.htmlElementSanitizer.forbidTags` in the `xwiki.properties` configuration file.",
    "id": 12609
  },
  {
    "cve_id": "CVE-2023-36471",
    "code_before_change": "{\n    private static final String ALLOWED_ATTRIBUTE = \"allowed_attribute\";\n\n    private static final String ONERROR = \"onerror\";\n\n    @MockComponent\n    private HTMLElementSanitizerConfiguration htmlElementSanitizerConfiguration;\n\n    @InjectMockComponents\n    private SecureHTMLElementSanitizer secureHTMLElementSanitizer;\n\n    @BeforeComponent\n    void setupMocks()\n    {\n        when(this.htmlElementSanitizerConfiguration.getForbidTags())\n            .thenReturn(Collections.singletonList(HTMLConstants.TAG_A));\n        when(this.htmlElementSanitizerConfiguration.getForbidAttributes())\n            .thenReturn(Collections.singletonList(HTMLConstants.ATTRIBUTE_ALT));\n        when(this.htmlElementSanitizerConfiguration.getExtraAllowedTags())\n            .thenReturn(Collections.singletonList(HTMLConstants.TAG_SCRIPT));\n        when(this.htmlElementSanitizerConfiguration.getExtraAllowedAttributes())\n            .thenReturn(Arrays.asList(ALLOWED_ATTRIBUTE, ONERROR));\n        when(this.htmlElementSanitizerConfiguration.getExtraUriSafeAttributes())\n            .thenReturn(Collections.singletonList(HTMLConstants.ATTRIBUTE_SRC));\n        when(this.htmlElementSanitizerConfiguration.getExtraDataUriTags())\n            .thenReturn(Arrays.asList(HTMLConstants.TAG_SCRIPT, HTMLConstants.TAG_NAV));\n        when(this.htmlElementSanitizerConfiguration.isAllowUnknownProtocols())\n            .thenReturn(false);\n        when(this.htmlElementSanitizerConfiguration.getAllowedUriRegexp())\n            .thenReturn(\"^(xwiki|https):\");\n    }\n\n    @Test\n    void forbiddenTags()\n    {\n        assertFalse(this.secureHTMLElementSanitizer.isElementAllowed(HTMLConstants.TAG_A));\n    }\n\n    @Test\n    void forbiddenAttributes()\n    {\n        assertFalse(this.secureHTMLElementSanitizer.isAttributeAllowed(HTMLConstants.TAG_IMG,\n            HTMLConstants.ATTRIBUTE_ALT, \"XWiki\"));\n    }\n\n    @Test\n    void extraAllowedTags()\n    {\n        assertTrue(this.secureHTMLElementSanitizer.isElementAllowed(HTMLConstants.TAG_SCRIPT));\n    }\n\n    @Test\n    void extraAllowedAttributes()\n    {\n        assertTrue(this.secureHTMLElementSanitizer.isAttributeAllowed(HTMLConstants.TAG_IMG, ALLOWED_ATTRIBUTE,\n            \"value\"));\n        assertTrue(this.secureHTMLElementSanitizer.isAttributeAllowed(HTMLConstants.TAG_IMG, ONERROR, \"alert(1)\"));\n    }\n\n    @Test\n    void extraUriSafeAttributes()\n    {\n        assertTrue(this.secureHTMLElementSanitizer.isAttributeAllowed(HTMLConstants.TAG_IMG,\n            HTMLConstants.ATTRIBUTE_SRC, \"javascript:alert(1)\"));\n    }\n\n    @Test\n    void extraDataUriTags()\n    {\n        assertTrue(this.secureHTMLElementSanitizer.isAttributeAllowed(HTMLConstants.TAG_NAV,\n            HTMLConstants.ATTRIBUTE_HREF, \"data:test\"));\n        // Script cannot be enabled for data-attributes.\n        assertFalse(this.secureHTMLElementSanitizer.isAttributeAllowed(HTMLConstants.TAG_SCRIPT,\n            HTMLConstants.ATTRIBUTE_HREF, \"data:script\"));\n    }\n\n    @Test\n    void restrictedURIs()\n    {\n        assertTrue(this.secureHTMLElementSanitizer.isAttributeAllowed(HTMLConstants.TAG_A,\n            HTMLConstants.ATTRIBUTE_HREF, \"https://www.xwiki.org\"));\n        assertTrue(this.secureHTMLElementSanitizer.isAttributeAllowed(HTMLConstants.TAG_A,\n            HTMLConstants.ATTRIBUTE_HREF, \"xwiki:test\"));\n        assertFalse(this.secureHTMLElementSanitizer.isAttributeAllowed(HTMLConstants.TAG_A,\n            HTMLConstants.ATTRIBUTE_HREF, \"http://example.com\"));\n    }\n\n    @ParameterizedTest\n    @CsvSource({\n        \"data-, false\",\n        \"data-a, true\",\n        \"data-x-wiki.test_\\u0192, true\",\n        \"data-x\\u2713, false\",\n        \"data-x/test, false\",\n        \"data-x>test, false\",\n        \"data-x:y, false\"\n    })\n    void dataAttributes(String attribute, boolean accepted)\n    {\n        assertEquals(accepted, this.secureHTMLElementSanitizer.isAttributeAllowed(HTMLConstants.TAG_DIV, attribute,\n            \"hello\"));\n    }\n}",
    "code_after_change": "{\n    private static final String ALLOWED_ATTRIBUTE = \"allowed_attribute\";\n\n    private static final String ONERROR = \"onerror\";\n\n    @MockComponent\n    private HTMLElementSanitizerConfiguration htmlElementSanitizerConfiguration;\n\n    @InjectMockComponents\n    private SecureHTMLElementSanitizer secureHTMLElementSanitizer;\n\n    @BeforeComponent\n    void setupMocks()\n    {\n        when(this.htmlElementSanitizerConfiguration.getForbidTags())\n            .thenReturn(Collections.singletonList(HTMLConstants.TAG_A));\n        when(this.htmlElementSanitizerConfiguration.getForbidAttributes())\n            .thenReturn(Collections.singletonList(HTMLConstants.ATTRIBUTE_ALT));\n        when(this.htmlElementSanitizerConfiguration.getExtraAllowedTags())\n            .thenReturn(Collections.singletonList(HTMLConstants.TAG_SCRIPT));\n        when(this.htmlElementSanitizerConfiguration.getExtraAllowedAttributes())\n            .thenReturn(Arrays.asList(ALLOWED_ATTRIBUTE, ONERROR));\n        when(this.htmlElementSanitizerConfiguration.getExtraUriSafeAttributes())\n            .thenReturn(Collections.singletonList(HTMLConstants.ATTRIBUTE_SRC));\n        when(this.htmlElementSanitizerConfiguration.getExtraDataUriTags())\n            .thenReturn(Arrays.asList(HTMLConstants.TAG_SCRIPT, HTMLConstants.TAG_NAV));\n        when(this.htmlElementSanitizerConfiguration.isAllowUnknownProtocols())\n            .thenReturn(false);\n        when(this.htmlElementSanitizerConfiguration.getAllowedUriRegexp())\n            .thenReturn(\"^(xwiki|https):\");\n    }\n\n    @Test\n    void forbiddenTags()\n    {\n        assertFalse(this.secureHTMLElementSanitizer.isElementAllowed(HTMLConstants.TAG_A));\n    }\n\n    @ParameterizedTest\n    @ValueSource(strings = { \"form\", \"input\", \"select\", \"textarea\", \"button\" })\n    void formTags(String tagName)\n    {\n        assertFalse(this.secureHTMLElementSanitizer.isElementAllowed(tagName));\n    }\n\n    @Test\n    void forbiddenAttributes()\n    {\n        assertFalse(this.secureHTMLElementSanitizer.isAttributeAllowed(HTMLConstants.TAG_IMG,\n            HTMLConstants.ATTRIBUTE_ALT, \"XWiki\"));\n    }\n\n    @Test\n    void extraAllowedTags()\n    {\n        assertTrue(this.secureHTMLElementSanitizer.isElementAllowed(HTMLConstants.TAG_SCRIPT));\n    }\n\n    @Test\n    void extraAllowedAttributes()\n    {\n        assertTrue(this.secureHTMLElementSanitizer.isAttributeAllowed(HTMLConstants.TAG_IMG, ALLOWED_ATTRIBUTE,\n            \"value\"));\n        assertTrue(this.secureHTMLElementSanitizer.isAttributeAllowed(HTMLConstants.TAG_IMG, ONERROR, \"alert(1)\"));\n    }\n\n    @Test\n    void extraUriSafeAttributes()\n    {\n        assertTrue(this.secureHTMLElementSanitizer.isAttributeAllowed(HTMLConstants.TAG_IMG,\n            HTMLConstants.ATTRIBUTE_SRC, \"javascript:alert(1)\"));\n    }\n\n    @Test\n    void extraDataUriTags()\n    {\n        assertTrue(this.secureHTMLElementSanitizer.isAttributeAllowed(HTMLConstants.TAG_NAV,\n            HTMLConstants.ATTRIBUTE_HREF, \"data:test\"));\n        // Script cannot be enabled for data-attributes.\n        assertFalse(this.secureHTMLElementSanitizer.isAttributeAllowed(HTMLConstants.TAG_SCRIPT,\n            HTMLConstants.ATTRIBUTE_HREF, \"data:script\"));\n    }\n\n    @Test\n    void restrictedURIs()\n    {\n        assertTrue(this.secureHTMLElementSanitizer.isAttributeAllowed(HTMLConstants.TAG_A,\n            HTMLConstants.ATTRIBUTE_HREF, \"https://www.xwiki.org\"));\n        assertTrue(this.secureHTMLElementSanitizer.isAttributeAllowed(HTMLConstants.TAG_A,\n            HTMLConstants.ATTRIBUTE_HREF, \"xwiki:test\"));\n        assertFalse(this.secureHTMLElementSanitizer.isAttributeAllowed(HTMLConstants.TAG_A,\n            HTMLConstants.ATTRIBUTE_HREF, \"http://example.com\"));\n    }\n\n    @ParameterizedTest\n    @CsvSource({\n        \"data-, false\",\n        \"data-a, true\",\n        \"data-x-wiki.test_\\u0192, true\",\n        \"data-x\\u2713, false\",\n        \"data-x/test, false\",\n        \"data-x>test, false\",\n        \"data-x:y, false\"\n    })\n    void dataAttributes(String attribute, boolean accepted)\n    {\n        assertEquals(accepted, this.secureHTMLElementSanitizer.isAttributeAllowed(HTMLConstants.TAG_DIV, attribute,\n            \"hello\"));\n    }\n}",
    "patch": "@@ -25,6 +25,7 @@\n import org.junit.jupiter.api.Test;\n import org.junit.jupiter.params.ParameterizedTest;\n import org.junit.jupiter.params.provider.CsvSource;\n+import org.junit.jupiter.params.provider.ValueSource;\n import org.xwiki.test.annotation.BeforeComponent;\n import org.xwiki.test.annotation.ComponentList;\n import org.xwiki.test.junit5.mockito.ComponentTest;\n@@ -88,6 +89,13 @@ void forbiddenTags()\n         assertFalse(this.secureHTMLElementSanitizer.isElementAllowed(HTMLConstants.TAG_A));\n     }\n \n+    @ParameterizedTest\n+    @ValueSource(strings = { \"form\", \"input\", \"select\", \"textarea\", \"button\" })\n+    void formTags(String tagName)\n+    {\n+        assertFalse(this.secureHTMLElementSanitizer.isElementAllowed(tagName));\n+    }\n+\n     @Test\n     void forbiddenAttributes()\n     {",
    "function_modified_lines": {
      "added": [
        "    @ParameterizedTest\n",
        "    @ValueSource(strings = { \"form\", \"input\", \"select\", \"textarea\", \"button\" })\n",
        "    void formTags(String tagName)\n",
        "    {\n",
        "        assertFalse(this.secureHTMLElementSanitizer.isElementAllowed(tagName));\n",
        "    }\n",
        "\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-79"
    ],
    "cve_description": "Xwiki commons is the common modules used by other XWiki top level projects. The HTML sanitizer that is included in XWiki since version 14.6RC1 allowed form and input HTML tags. In the context of XWiki, this allows an attacker without script right to either create forms that can be used for phishing attacks or also in the context of a sheet, the attacker could add an input like `{{html}}<input type=\"hidden\" name=\"content\" value=\"{{groovy}}println(&quot;Hello from Groovy!&quot;)\" />{{/html}}` that would allow remote code execution when it is submitted by an admin (the sheet is rendered as part of the edit form). The attacker would need to ensure that the edit form looks plausible, though, which can be non-trivial as without script right the attacker cannot display the regular content of the document. This has been patched in XWiki 14.10.6 and 15.2RC1 by removing the central form-related tags from the list of allowed tags. Users are advised to upgrade. As a workaround an admin can manually disallow the tags by adding `form, input, select, textarea, button` to the configuration option `xml.htmlElementSanitizer.forbidTags` in the `xwiki.properties` configuration file.",
    "id": 12610
  },
  {
    "cve_id": "CVE-2022-4859",
    "code_before_change": "{\n        ApplicationContext ac = AppUtil.getApplicationContext();\n        WorkflowUserManager workflowUserManager = (WorkflowUserManager) ac.getBean(\"workflowUserManager\");\n        UserDao userDao = (UserDao) ac.getBean(\"userDao\");\n        User userObject = userDao.getUser(workflowUserManager.getCurrentUsername());\n        User currentUser = null;\n        if (userObject != null) {\n            currentUser = new User();\n            BeanUtils.copyProperties(userObject, currentUser);\n        }\n        ExtDirectoryManager directoryManager = (ExtDirectoryManager) AppUtil.getApplicationContext().getBean(\"directoryManager\");\n           \n        Collection<String> errors = new ArrayList<String>();\n        Collection<String> passwordErrors = new ArrayList<String>();\n        \n        boolean authenticated = false;\n        if (currentUser != null) {\n            if (!currentUser.getUsername().equals(getRequestParameterString(\"username\"))) {\n                HttpServletRequest request = WorkflowUtil.getHttpServletRequest();\n                if (request != null) {\n                    HttpSession session = request.getSession(false);\n                    if (session != null) {\n                        session.invalidate();\n                        authenticated = false;\n                    }\n                }\n            } else {\n                try {\n                    if (directoryManager.authenticate(currentUser.getUsername(), getRequestParameterString(\"oldPassword\"))) {\n                        authenticated = true;\n                    }\n                } catch (Exception e) { }\n            }\n        }\n        UserSecurity us = DirectoryUtil.getUserSecurity();\n        \n        if (\"\".equals(getPropertyString(\"f_firstName\"))) {\n            currentUser.setFirstName(getRequestParameterString(\"firstName\"));\n        }\n\n        if (\"\".equals(getPropertyString(\"f_lastName\"))) {\n            currentUser.setLastName(getRequestParameterString(\"lastName\"));\n        }\n\n        if (\"\".equals(getPropertyString(\"f_email\"))) {\n            currentUser.setEmail(getRequestParameterString(\"email\"));\n        }\n\n        if (\"\".equals(getPropertyString(\"f_timeZone\"))) {\n            currentUser.setTimeZone(getRequestParameterString(\"timeZone\"));\n        }\n\n        if (\"\".equals(getPropertyString(\"f_locale\"))) {\n            currentUser.setLocale(getRequestParameterString(\"locale\"));\n        }\n\n        if (!authenticated) {\n            if (errors == null) {\n                errors = new ArrayList<String>();\n            }\n            errors.add(ResourceBundleUtil.getMessage(\"console.directory.user.error.label.authenticationFailed\"));\n        } else {\n            if (us != null) {\n                errors = us.validateUserOnProfileUpdate(currentUser);\n            }\n\n            if (getRequestParameterString(\"password\") != null && !getRequestParameterString(\"password\").isEmpty() && us != null) {\n                passwordErrors = us.validatePassword(getRequestParameterString(\"username\"),  getRequestParameterString(\"oldPassword\"), getRequestParameterString(\"password\"), getRequestParameterString(\"confirmPassword\")); \n            }\n        }\n\n        setProperty(\"errors\", errors);\n        if (passwordErrors != null && !passwordErrors.isEmpty()) {\n            setProperty(\"passwordErrors\", passwordErrors);\n        }\n        \n        if (authenticated && (passwordErrors != null && passwordErrors.isEmpty()) && (errors != null && errors.isEmpty())) {\n            if (\"\".equals(getPropertyString(\"f_password\"))) {\n                if (getRequestParameterString(\"password\") != null && getRequestParameterString(\"confirmPassword\") != null && getRequestParameterString(\"password\").length() > 0 && getRequestParameterString(\"password\").equals(getRequestParameterString(\"confirmPassword\"))) {\n                    if (us != null) {\n                        currentUser.setPassword(us.encryptPassword(getRequestParameterString(\"username\"), getRequestParameterString(\"password\")));\n                    } else {\n                        currentUser.setPassword(StringUtil.md5Base16(getRequestParameterString(\"password\")));\n                    }\n                    currentUser.setConfirmPassword(getRequestParameterString(\"password\"));\n                }\n            }\n\n            if (currentUser.getUsername().equals(getRequestParameterString(\"username\"))) {\n                userDao.updateUser(currentUser);\n                if (us != null) {\n                    us.updateUserProfilePostProcessing(currentUser);\n                }\n                \n                setAlertMessage(getPropertyString(\"message\"));\n                setProperty(\"headerTitle\", getPropertyString(\"label\"));\n                if (getPropertyString(\"redirectURL\") != null && !getPropertyString(\"redirectURL\").isEmpty()) {\n                    setProperty(\"view\", \"redirect\");\n                    boolean redirectToParent = \"Yes\".equals(getPropertyString(\"showInPopupDialog\"));\n                    setRedirectUrl(getPropertyString(\"redirectURL\"), redirectToParent);\n                } else {\n                    setProperty(\"saved\", \"true\");\n                    viewForm(null);\n                }\n            }\n        } else {\n            viewForm(currentUser);\n        }\n    }",
    "code_after_change": "{\n        ApplicationContext ac = AppUtil.getApplicationContext();\n        WorkflowUserManager workflowUserManager = (WorkflowUserManager) ac.getBean(\"workflowUserManager\");\n        UserDao userDao = (UserDao) ac.getBean(\"userDao\");\n        User userObject = userDao.getUser(workflowUserManager.getCurrentUsername());\n        User currentUser = null;\n        if (userObject != null) {\n            currentUser = new User();\n            BeanUtils.copyProperties(userObject, currentUser);\n        }\n        ExtDirectoryManager directoryManager = (ExtDirectoryManager) AppUtil.getApplicationContext().getBean(\"directoryManager\");\n           \n        Collection<String> errors = new ArrayList<String>();\n        Collection<String> passwordErrors = new ArrayList<String>();\n        \n        boolean authenticated = false;\n        if (currentUser != null) {\n            if (!currentUser.getUsername().equals(getRequestParameterString(\"username\"))) {\n                HttpServletRequest request = WorkflowUtil.getHttpServletRequest();\n                if (request != null) {\n                    HttpSession session = request.getSession(false);\n                    if (session != null) {\n                        session.invalidate();\n                        authenticated = false;\n                    }\n                }\n            } else {\n                try {\n                    if (directoryManager.authenticate(currentUser.getUsername(), getRequestParameterString(\"oldPassword\"))) {\n                        authenticated = true;\n                    }\n                } catch (Exception e) { }\n            }\n        }\n        UserSecurity us = DirectoryUtil.getUserSecurity();\n        \n        if (\"\".equals(getPropertyString(\"f_firstName\")) && !StringUtil.stripAllHtmlTag(getRequestParameterString(\"firstName\")).isEmpty()) {\n            currentUser.setFirstName(StringUtil.stripAllHtmlTag(getRequestParameterString(\"firstName\")));\n        }\n\n        if (\"\".equals(getPropertyString(\"f_lastName\"))) {\n            currentUser.setLastName(StringUtil.stripAllHtmlTag(getRequestParameterString(\"lastName\")));\n        }\n\n        if (\"\".equals(getPropertyString(\"f_email\"))) {\n            currentUser.setEmail(getRequestParameterString(\"email\"));\n        }\n\n        if (\"\".equals(getPropertyString(\"f_timeZone\"))) {\n            currentUser.setTimeZone(getRequestParameterString(\"timeZone\"));\n        }\n\n        if (\"\".equals(getPropertyString(\"f_locale\"))) {\n            currentUser.setLocale(getRequestParameterString(\"locale\"));\n        }\n\n        if (!authenticated) {\n            if (errors == null) {\n                errors = new ArrayList<String>();\n            }\n            errors.add(ResourceBundleUtil.getMessage(\"console.directory.user.error.label.authenticationFailed\"));\n        } else {\n            if (us != null) {\n                errors = us.validateUserOnProfileUpdate(currentUser);\n            }\n\n            if (getRequestParameterString(\"password\") != null && !getRequestParameterString(\"password\").isEmpty() && us != null) {\n                passwordErrors = us.validatePassword(getRequestParameterString(\"username\"),  getRequestParameterString(\"oldPassword\"), getRequestParameterString(\"password\"), getRequestParameterString(\"confirmPassword\")); \n            }\n        }\n\n        setProperty(\"errors\", errors);\n        if (passwordErrors != null && !passwordErrors.isEmpty()) {\n            setProperty(\"passwordErrors\", passwordErrors);\n        }\n        \n        if (authenticated && (passwordErrors != null && passwordErrors.isEmpty()) && (errors != null && errors.isEmpty())) {\n            if (\"\".equals(getPropertyString(\"f_password\"))) {\n                if (getRequestParameterString(\"password\") != null && getRequestParameterString(\"confirmPassword\") != null && getRequestParameterString(\"password\").length() > 0 && getRequestParameterString(\"password\").equals(getRequestParameterString(\"confirmPassword\"))) {\n                    if (us != null) {\n                        currentUser.setPassword(us.encryptPassword(getRequestParameterString(\"username\"), getRequestParameterString(\"password\")));\n                    } else {\n                        currentUser.setPassword(StringUtil.md5Base16(getRequestParameterString(\"password\")));\n                    }\n                    currentUser.setConfirmPassword(getRequestParameterString(\"password\"));\n                }\n            }\n\n            if (currentUser.getUsername().equals(getRequestParameterString(\"username\"))) {\n                userDao.updateUser(currentUser);\n                if (us != null) {\n                    us.updateUserProfilePostProcessing(currentUser);\n                }\n                \n                setAlertMessage(getPropertyString(\"message\"));\n                setProperty(\"headerTitle\", getPropertyString(\"label\"));\n                if (getPropertyString(\"redirectURL\") != null && !getPropertyString(\"redirectURL\").isEmpty()) {\n                    setProperty(\"view\", \"redirect\");\n                    boolean redirectToParent = \"Yes\".equals(getPropertyString(\"showInPopupDialog\"));\n                    setRedirectUrl(getPropertyString(\"redirectURL\"), redirectToParent);\n                } else {\n                    setProperty(\"saved\", \"true\");\n                    viewForm(null);\n                }\n            }\n        } else {\n            viewForm(currentUser);\n        }\n    }",
    "patch": "@@ -14,6 +14,7 @@\n import org.joget.apps.userview.model.UserviewBuilderPalette;\n import org.joget.apps.userview.model.UserviewMenu;\n import org.joget.commons.util.ResourceBundleUtil;\n+import org.joget.commons.util.SecurityUtil;\n import org.joget.commons.util.SetupManager;\n import org.joget.commons.util.StringUtil;\n import org.joget.commons.util.TimeZoneUtil;\n@@ -205,12 +206,12 @@ private void submitForm() {\n         }\n         UserSecurity us = DirectoryUtil.getUserSecurity();\n         \n-        if (\"\".equals(getPropertyString(\"f_firstName\"))) {\n-            currentUser.setFirstName(getRequestParameterString(\"firstName\"));\n+        if (\"\".equals(getPropertyString(\"f_firstName\")) && !StringUtil.stripAllHtmlTag(getRequestParameterString(\"firstName\")).isEmpty()) {\n+            currentUser.setFirstName(StringUtil.stripAllHtmlTag(getRequestParameterString(\"firstName\")));\n         }\n \n         if (\"\".equals(getPropertyString(\"f_lastName\"))) {\n-            currentUser.setLastName(getRequestParameterString(\"lastName\"));\n+            currentUser.setLastName(StringUtil.stripAllHtmlTag(getRequestParameterString(\"lastName\")));\n         }\n \n         if (\"\".equals(getPropertyString(\"f_email\"))) {",
    "function_modified_lines": {
      "added": [
        "        if (\"\".equals(getPropertyString(\"f_firstName\")) && !StringUtil.stripAllHtmlTag(getRequestParameterString(\"firstName\")).isEmpty()) {\n",
        "            currentUser.setFirstName(StringUtil.stripAllHtmlTag(getRequestParameterString(\"firstName\")));\n",
        "            currentUser.setLastName(StringUtil.stripAllHtmlTag(getRequestParameterString(\"lastName\")));\n"
      ],
      "deleted": [
        "        if (\"\".equals(getPropertyString(\"f_firstName\"))) {\n",
        "            currentUser.setFirstName(getRequestParameterString(\"firstName\"));\n",
        "            currentUser.setLastName(getRequestParameterString(\"lastName\"));\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-79"
    ],
    "cve_description": "A vulnerability, which was classified as problematic, has been found in Joget up to 7.0.33. This issue affects the function submitForm of the file wflow-core/src/main/java/org/joget/plugin/enterprise/UserProfileMenu.java of the component User Profile Menu. The manipulation of the argument firstName/lastName leads to cross site scripting. The attack may be initiated remotely. Upgrading to version 7.0.34 is able to address this issue. The patch is named 9a77f508a2bf8cf661d588f37a4cc29ecaea4fc8. It is recommended to upgrade the affected component. The associated identifier of this vulnerability is VDB-217055.",
    "id": 12686
  },
  {
    "cve_id": "CVE-2023-0301",
    "code_before_change": "{\n\n    private MustacheCustomTag() {}\n\n    private static final Pattern ARG_PATTERN = Pattern.compile(\"\\\\[(.*?)]\");\n    private static final String LOCALE_LABEL = \"locale:\";\n\n    static final Mustache.Lambda FORMAT_DATE = (frag, out) -> {\n        String execution = frag.execute().trim();\n        ZonedDateTime d = ZonedDateTime.parse(substring(execution, 0, execution.indexOf(' ')));\n        Pair<String, Optional<Locale>> p = parseParams(execution);\n        if (p.getRight().isPresent()) {\n            out.write(DateTimeFormatter.ofPattern(p.getLeft(), p.getRight().get()).format(d));\n        } else {\n            out.write(DateTimeFormatter.ofPattern(p.getLeft()).format(d));\n        }\n    };\n\n    /**\n     * {{#render-markdown}}[markdown][.html|.text]{{/render-markdown}}\n     * The string must end with either .html or .text, otherwise Markdown won't be parsed\n     * e.g.\n     * {{#render-markdown}}(link)[description].html{{/render-markdown}} will produce HTML output\n     * {{#render-markdown}}(link)[description].text{{/render-markdown}} will produce text/plain output\n     */\n    static final Mustache.Lambda RENDER_MARKDOWN = (frag, out) -> {\n        String execution = frag.execute().strip();\n        if(execution.endsWith(\".html\")) {\n            out.write(renderToHtmlCommonmarkEscaped(StringUtils.removeEnd(execution, \".html\")));\n        } else if(execution.endsWith(\".text\")) {\n            out.write(renderToTextCommonmark(StringUtils.removeEnd(execution, \".text\")));\n        } else {\n            out.write(execution);\n        }\n    };\n\n    static final Mustache.Lambda COUNTRY_NAME = (frag, out) -> {\n        String execution = frag.execute().trim();\n        String code = substring(execution, 0, 2);\n        Pair<String, Optional<Locale>> p = parseParams(execution);\n        out.write(translateCountryCode(code, p.getRight().orElse(null)));\n    };\n\n    static String translateCountryCode(String code, Locale locale) {\n        Locale lang = locale != null ? locale : Locale.ENGLISH;\n        return Stream.concat(TicketHelper.getLocalizedCountries(lang).stream(), TicketHelper.getLocalizedCountriesForVat(lang).stream())\n            .filter(p -> p.getKey().equalsIgnoreCase(code))\n            .map(Pair::getValue)\n            .findFirst()\n            .orElse(code);\n    }\n\n    /**\n     * {{#additional-field-value}}[Prefix][name][suffix]{{/additional-field-value}}\n     * prefix is optional, unless a suffix is needed.\n     */\n    static final Function<Object, Mustache.Lambda> ADDITIONAL_FIELD_VALUE = obj -> (frag, out) -> {\n        if( !(obj instanceof Map) || ((Map<?,?>)obj).isEmpty()) {\n            log.warn(\"map not found or empty. Skipping additionalFieldValue tag\");\n            return;\n        }\n        Map<?, ?> fieldNamesAndValues = (Map<?, ?>) obj;\n        String execution = frag.execute().trim();\n        Matcher matcher = ARG_PATTERN.matcher(execution);\n        List<String> args = new ArrayList<>();\n        while(matcher.find()) {\n            args.add(matcher.group(1));\n        }\n        if(args.isEmpty()) {\n            return;\n        }\n        String name = args.get(args.size() > 1 ? 1 : 0);\n        String prefix = args.size() > 1 ? args.get(0) + \" \" : \"\";\n        String suffix = args.size() > 2 ? \" \"+args.get(2) : \"\";\n\n        if(fieldNamesAndValues.containsKey(name)) {\n            out.write(prefix + fieldNamesAndValues.get(name) + suffix);\n        }\n    };\n\n    private static Pair<String, Optional<Locale>> parseParams(String r) {\n\n        int indexLocale = r.indexOf(LOCALE_LABEL);\n        int end = Math.min(r.length(), indexLocale != -1 ? indexLocale : r.length());\n        String format = substring(r, r.indexOf(' '), end);\n\n        //\n        String[] res = r.split(\"\\\\s+\");\n        Optional<Locale> locale = Arrays.stream(res).filter(s -> s.startsWith(LOCALE_LABEL)).findFirst()\n                .map(l -> LocaleUtil.forLanguageTag(substring(l, LOCALE_LABEL.length())));\n        //\n\n        return Pair.of(format, locale);\n    }\n\n\n    private static final List<Extension> COMMONMARK_EXTENSIONS = List.of(TablesExtension.create());\n    private static final Parser COMMONMARK_PARSER = Parser.builder().extensions(COMMONMARK_EXTENSIONS).build();\n    private static final HtmlRenderer COMMONMARK_RENDERER = HtmlRenderer.builder().extensions(COMMONMARK_EXTENSIONS).attributeProviderFactory((ctx) -> new TargetBlankProvider()).build();\n    private static final TextContentRenderer COMMONMARK_TEXT_RENDERER = TextContentRenderer.builder().extensions(COMMONMARK_EXTENSIONS).build();\n    private static final ThreadLocal<String> A11Y_NEW_TAB_LABEL = new ThreadLocal<>();\n\n    //Open in a new window if the link contains an absolute url\n    private static class TargetBlankProvider implements AttributeProvider {\n        @Override\n        public void setAttributes(Node node, String tagName, Map<String, String> attributes) {\n            if (node instanceof Link) {\n                Link l = (Link) node;\n                String destination = StringUtils.trimToEmpty(l.getDestination());\n                if (UrlUtils.isAbsoluteUrl(destination)) {\n                    attributes.put(\"target\", \"_blank\");\n                    attributes.put(\"rel\", \"nofollow noopener noreferrer\");\n                    var newTabLabel = A11Y_NEW_TAB_LABEL.get();\n                    if (newTabLabel != null) {\n                        attributes.put(\"aria-label\", ((Text)node.getFirstChild()).getLiteral() + \" \" + newTabLabel);\n                    }\n                }\n            }\n        }\n    }\n    public static String renderToHtmlCommonmarkEscaped(String input) {\n        return renderToHtmlCommonmarkEscaped(input, null);\n    }\n\n    public static String renderToHtmlCommonmarkEscaped(String input, String localizedNewWindowLabel) {\n        try {\n            A11Y_NEW_TAB_LABEL.set(localizedNewWindowLabel);\n            Node document = COMMONMARK_PARSER.parse(StringEscapeUtils.escapeHtml4(input));\n            return COMMONMARK_RENDERER.render(document);\n        } finally {\n            A11Y_NEW_TAB_LABEL.remove();\n        }\n    }\n\n    public static String renderToTextCommonmark(String input) {\n        Node document = COMMONMARK_PARSER.parse(input);\n        return COMMONMARK_TEXT_RENDERER.render(document);\n    }\n}",
    "code_after_change": "{\n\n    private MustacheCustomTag() {}\n\n    private static final Pattern ARG_PATTERN = Pattern.compile(\"\\\\[(.*?)]\");\n    private static final String LOCALE_LABEL = \"locale:\";\n\n    static final Mustache.Lambda FORMAT_DATE = (frag, out) -> {\n        String execution = frag.execute().trim();\n        ZonedDateTime d = ZonedDateTime.parse(substring(execution, 0, execution.indexOf(' ')));\n        Pair<String, Optional<Locale>> p = parseParams(execution);\n        if (p.getRight().isPresent()) {\n            out.write(DateTimeFormatter.ofPattern(p.getLeft(), p.getRight().get()).format(d));\n        } else {\n            out.write(DateTimeFormatter.ofPattern(p.getLeft()).format(d));\n        }\n    };\n\n    /**\n     * {{#render-markdown}}[markdown][.html|.text]{{/render-markdown}}\n     * The string must end with either .html or .text, otherwise Markdown won't be parsed\n     * e.g.\n     * {{#render-markdown}}(link)[description].html{{/render-markdown}} will produce HTML output\n     * {{#render-markdown}}(link)[description].text{{/render-markdown}} will produce text/plain output\n     */\n    static final Mustache.Lambda RENDER_MARKDOWN = (frag, out) -> {\n        String execution = frag.execute().strip();\n        if(execution.endsWith(\".html\")) {\n            out.write(renderToHtmlCommonmarkEscaped(StringUtils.removeEnd(execution, \".html\")));\n        } else if(execution.endsWith(\".text\")) {\n            out.write(renderToTextCommonmark(StringUtils.removeEnd(execution, \".text\")));\n        } else {\n            out.write(execution);\n        }\n    };\n\n    static final Mustache.Lambda COUNTRY_NAME = (frag, out) -> {\n        String execution = frag.execute().trim();\n        String code = substring(execution, 0, 2);\n        Pair<String, Optional<Locale>> p = parseParams(execution);\n        out.write(translateCountryCode(code, p.getRight().orElse(null)));\n    };\n\n    static String translateCountryCode(String code, Locale locale) {\n        Locale lang = locale != null ? locale : Locale.ENGLISH;\n        return Stream.concat(TicketHelper.getLocalizedCountries(lang).stream(), TicketHelper.getLocalizedCountriesForVat(lang).stream())\n            .filter(p -> p.getKey().equalsIgnoreCase(code))\n            .map(Pair::getValue)\n            .findFirst()\n            .orElse(code);\n    }\n\n    /**\n     * {{#additional-field-value}}[Prefix][name][suffix]{{/additional-field-value}}\n     * prefix is optional, unless a suffix is needed.\n     */\n    static final Function<Object, Mustache.Lambda> ADDITIONAL_FIELD_VALUE = obj -> (frag, out) -> {\n        if( !(obj instanceof Map) || ((Map<?,?>)obj).isEmpty()) {\n            log.warn(\"map not found or empty. Skipping additionalFieldValue tag\");\n            return;\n        }\n        Map<?, ?> fieldNamesAndValues = (Map<?, ?>) obj;\n        String execution = frag.execute().trim();\n        Matcher matcher = ARG_PATTERN.matcher(execution);\n        List<String> args = new ArrayList<>();\n        while(matcher.find()) {\n            args.add(matcher.group(1));\n        }\n        if(args.isEmpty()) {\n            return;\n        }\n        String name = args.get(args.size() > 1 ? 1 : 0);\n        String prefix = args.size() > 1 ? args.get(0) + \" \" : \"\";\n        String suffix = args.size() > 2 ? \" \"+args.get(2) : \"\";\n\n        if(fieldNamesAndValues.containsKey(name)) {\n            out.write(prefix + fieldNamesAndValues.get(name) + suffix);\n        }\n    };\n\n    private static Pair<String, Optional<Locale>> parseParams(String r) {\n\n        int indexLocale = r.indexOf(LOCALE_LABEL);\n        int end = Math.min(r.length(), indexLocale != -1 ? indexLocale : r.length());\n        String format = substring(r, r.indexOf(' '), end);\n\n        //\n        String[] res = r.split(\"\\\\s+\");\n        Optional<Locale> locale = Arrays.stream(res).filter(s -> s.startsWith(LOCALE_LABEL)).findFirst()\n                .map(l -> LocaleUtil.forLanguageTag(substring(l, LOCALE_LABEL.length())));\n        //\n\n        return Pair.of(format, locale);\n    }\n\n\n    private static final List<Extension> COMMONMARK_EXTENSIONS = List.of(TablesExtension.create());\n    private static final Parser COMMONMARK_PARSER = Parser.builder().extensions(COMMONMARK_EXTENSIONS).build();\n    private static final HtmlRenderer COMMONMARK_RENDERER = HtmlRenderer.builder().extensions(COMMONMARK_EXTENSIONS).attributeProviderFactory((ctx) -> new TargetBlankProvider()).build();\n    private static final TextContentRenderer COMMONMARK_TEXT_RENDERER = TextContentRenderer.builder().extensions(COMMONMARK_EXTENSIONS).build();\n    private static final ThreadLocal<String> A11Y_NEW_TAB_LABEL = new ThreadLocal<>();\n\n    //Open in a new window if the link contains an absolute url\n    private static class TargetBlankProvider implements AttributeProvider {\n        @Override\n        public void setAttributes(Node node, String tagName, Map<String, String> attributes) {\n            if (node instanceof Link) {\n                Link l = (Link) node;\n                String destination = StringUtils.trimToEmpty(l.getDestination());\n                var scheme = getScheme(destination);\n                scheme.ifPresent(resolvedScheme -> {\n                    if (!Set.of(\"http\", \"https\").contains(resolvedScheme)) {\n                        log.info(\"User tried to set an url with scheme {}, only http/https are accepted, href has been removed\", resolvedScheme);\n                        attributes.remove(\"href\");\n                    }\n                });\n                if (UrlUtils.isAbsoluteUrl(destination)) {\n                    // accept only http or https protocols if we have an absolute link, else we override with an empty string\n                    attributes.put(\"target\", \"_blank\");\n                    attributes.put(\"rel\", \"nofollow noopener noreferrer\");\n                    var newTabLabel = A11Y_NEW_TAB_LABEL.get();\n                    if (newTabLabel != null) {\n                        attributes.put(\"aria-label\", ((Text)node.getFirstChild()).getLiteral() + \" \" + newTabLabel);\n                    }\n                }\n            }\n        }\n    }\n    public static String renderToHtmlCommonmarkEscaped(String input) {\n        return renderToHtmlCommonmarkEscaped(input, null);\n    }\n\n    /**\n     * return lowercase scheme if present\n     */\n    private static Optional<String> getScheme(String uri) {\n        var s = StringUtils.trimToEmpty(uri).toLowerCase(Locale.ROOT);\n        return s.indexOf(':') >= 0 ? Optional.of(StringUtils.substringBefore(s, ':')) : Optional.empty();\n    }\n\n    public static String renderToHtmlCommonmarkEscaped(String input, String localizedNewWindowLabel) {\n        try {\n            A11Y_NEW_TAB_LABEL.set(localizedNewWindowLabel);\n            Node document = COMMONMARK_PARSER.parse(StringEscapeUtils.escapeHtml4(input));\n            return COMMONMARK_RENDERER.render(document);\n        } finally {\n            A11Y_NEW_TAB_LABEL.remove();\n        }\n    }\n\n    public static String renderToTextCommonmark(String input) {\n        Node document = COMMONMARK_PARSER.parse(input);\n        return COMMONMARK_TEXT_RENDERER.render(document);\n    }\n}",
    "patch": "@@ -168,7 +168,15 @@ public void setAttributes(Node node, String tagName, Map<String, String> attribu\n             if (node instanceof Link) {\n                 Link l = (Link) node;\n                 String destination = StringUtils.trimToEmpty(l.getDestination());\n+                var scheme = getScheme(destination);\n+                scheme.ifPresent(resolvedScheme -> {\n+                    if (!Set.of(\"http\", \"https\").contains(resolvedScheme)) {\n+                        log.info(\"User tried to set an url with scheme {}, only http/https are accepted, href has been removed\", resolvedScheme);\n+                        attributes.remove(\"href\");\n+                    }\n+                });\n                 if (UrlUtils.isAbsoluteUrl(destination)) {\n+                    // accept only http or https protocols if we have an absolute link, else we override with an empty string\n                     attributes.put(\"target\", \"_blank\");\n                     attributes.put(\"rel\", \"nofollow noopener noreferrer\");\n                     var newTabLabel = A11Y_NEW_TAB_LABEL.get();\n@@ -183,6 +191,14 @@ public static String renderToHtmlCommonmarkEscaped(String input) {\n         return renderToHtmlCommonmarkEscaped(input, null);\n     }\n \n+    /**\n+     * return lowercase scheme if present\n+     */\n+    private static Optional<String> getScheme(String uri) {\n+        var s = StringUtils.trimToEmpty(uri).toLowerCase(Locale.ROOT);\n+        return s.indexOf(':') >= 0 ? Optional.of(StringUtils.substringBefore(s, ':')) : Optional.empty();\n+    }\n+\n     public static String renderToHtmlCommonmarkEscaped(String input, String localizedNewWindowLabel) {\n         try {\n             A11Y_NEW_TAB_LABEL.set(localizedNewWindowLabel);",
    "function_modified_lines": {
      "added": [
        "                var scheme = getScheme(destination);\n",
        "                scheme.ifPresent(resolvedScheme -> {\n",
        "                    if (!Set.of(\"http\", \"https\").contains(resolvedScheme)) {\n",
        "                        log.info(\"User tried to set an url with scheme {}, only http/https are accepted, href has been removed\", resolvedScheme);\n",
        "                        attributes.remove(\"href\");\n",
        "                    }\n",
        "                });\n",
        "                    // accept only http or https protocols if we have an absolute link, else we override with an empty string\n",
        "    /**\n",
        "     * return lowercase scheme if present\n",
        "     */\n",
        "    private static Optional<String> getScheme(String uri) {\n",
        "        var s = StringUtils.trimToEmpty(uri).toLowerCase(Locale.ROOT);\n",
        "        return s.indexOf(':') >= 0 ? Optional.of(StringUtils.substringBefore(s, ':')) : Optional.empty();\n",
        "    }\n",
        "\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-79"
    ],
    "cve_description": "Cross-site Scripting (XSS) - Stored in GitHub repository alfio-event/alf.io prior to Alf.io 2.0-M4-2301.",
    "id": 12697
  },
  {
    "cve_id": "CVE-2023-0301",
    "code_before_change": "/**\n * This file is part of alf.io.\n *\n * alf.io is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * alf.io is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with alf.io.  If not, see <http://www.gnu.org/licenses/>.\n */\npackage alfio.util;\n\nimport com.samskivert.mustache.Template;\nimport org.junit.jupiter.api.Test;\nimport org.mockito.Mockito;\n\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.util.Collections;\nimport java.util.Locale;\n\nimport static alfio.util.MustacheCustomTag.ADDITIONAL_FIELD_VALUE;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.mockito.Mockito.*;\n\npublic class MustacheCustomTagTest {\n\n    private Template.Fragment fragment = Mockito.mock(Template.Fragment.class);\n    private Writer out = Mockito.mock(Writer.class);\n\n    @Test\n    public void translateCountryCode() {\n        assertEquals(\"Greece\", MustacheCustomTag.translateCountryCode(\"GR\", null));\n        assertEquals(\"Greece\", MustacheCustomTag.translateCountryCode(\"EL\", null));\n        assertEquals(\"Grecia\", MustacheCustomTag.translateCountryCode(\"EL\", Locale.ITALIAN));\n    }\n\n    @Test\n    public void additionalFieldValueMapIsEmptyOrNull() throws IOException {\n        ADDITIONAL_FIELD_VALUE.apply(Collections.emptyMap()).execute(fragment, out);\n        ADDITIONAL_FIELD_VALUE.apply(null).execute(fragment, out);\n        verifyNoMoreInteractions(fragment, out);\n    }\n\n    @Test\n    public void additionalFieldValueMapDoesNotContainValue() throws IOException {\n        when(fragment.execute()).thenReturn(\"[not-existing]\");\n        ADDITIONAL_FIELD_VALUE.apply(Collections.singletonMap(\"test\", \"test\")).execute(fragment, out);\n        verifyNoMoreInteractions(out);\n    }\n\n    @Test\n    public void additionalFieldValue() throws IOException {\n        when(fragment.execute()).thenReturn(\"[existing]\");\n        ADDITIONAL_FIELD_VALUE.apply(Collections.singletonMap(\"existing\", \"existing value\")).execute(fragment, out);\n        verify(out).write(\"existing value\");\n    }\n\n    @Test\n    public void additionalFieldValuePrefix() throws IOException {\n        when(fragment.execute()).thenReturn(\"[prefix!][existing]\");\n        ADDITIONAL_FIELD_VALUE.apply(Collections.singletonMap(\"existing\", \"existing value\")).execute(fragment, out);\n        verify(out).write(\"prefix! existing value\");\n    }\n\n    @Test\n    public void additionalFieldValueSuffix() throws IOException {\n        when(fragment.execute()).thenReturn(\"[prefix!][existing][suffix-]\");\n        ADDITIONAL_FIELD_VALUE.apply(Collections.singletonMap(\"existing\", \"existing value\")).execute(fragment, out);\n        verify(out).write(\"prefix! existing value suffix-\");\n    }\n\n    @Test\n    public void testHtmlMarkDown() {\n        //by default we escape all html\n        assertEquals(\"<p>escape &lt;a href=&quot;http://test&quot;&gt;bla&lt;/a&gt; escape</p>\\n\", MustacheCustomTag.renderToHtmlCommonmarkEscaped(\"escape <a href=\\\"http://test\\\">bla</a> escape\"));\n\n        //for relative link we don't add target=\"_blank\"\n        assertEquals(\"<p>link <a href=\\\"/test\\\">bla</a> link</p>\\n\", MustacheCustomTag.renderToHtmlCommonmarkEscaped(\"link [bla](/test) link\"));\n\n        //for absolute link we add target=\"_blank\"\n        assertEquals(\"<p>link <a href=\\\"http://test\\\" target=\\\"_blank\\\" rel=\\\"nofollow noopener noreferrer\\\">bla</a> link</p>\\n\", MustacheCustomTag.renderToHtmlCommonmarkEscaped(\"link [bla](http://test) link\"));\n    }\n}",
    "code_after_change": "{\n\n    private Template.Fragment fragment = Mockito.mock(Template.Fragment.class);\n    private Writer out = Mockito.mock(Writer.class);\n\n    @Test\n    public void translateCountryCode() {\n        assertEquals(\"Greece\", MustacheCustomTag.translateCountryCode(\"GR\", null));\n        assertEquals(\"Greece\", MustacheCustomTag.translateCountryCode(\"EL\", null));\n        assertEquals(\"Grecia\", MustacheCustomTag.translateCountryCode(\"EL\", Locale.ITALIAN));\n    }\n\n    @Test\n    public void additionalFieldValueMapIsEmptyOrNull() throws IOException {\n        ADDITIONAL_FIELD_VALUE.apply(Collections.emptyMap()).execute(fragment, out);\n        ADDITIONAL_FIELD_VALUE.apply(null).execute(fragment, out);\n        verifyNoMoreInteractions(fragment, out);\n    }\n\n    @Test\n    public void additionalFieldValueMapDoesNotContainValue() throws IOException {\n        when(fragment.execute()).thenReturn(\"[not-existing]\");\n        ADDITIONAL_FIELD_VALUE.apply(Collections.singletonMap(\"test\", \"test\")).execute(fragment, out);\n        verifyNoMoreInteractions(out);\n    }\n\n    @Test\n    public void additionalFieldValue() throws IOException {\n        when(fragment.execute()).thenReturn(\"[existing]\");\n        ADDITIONAL_FIELD_VALUE.apply(Collections.singletonMap(\"existing\", \"existing value\")).execute(fragment, out);\n        verify(out).write(\"existing value\");\n    }\n\n    @Test\n    public void additionalFieldValuePrefix() throws IOException {\n        when(fragment.execute()).thenReturn(\"[prefix!][existing]\");\n        ADDITIONAL_FIELD_VALUE.apply(Collections.singletonMap(\"existing\", \"existing value\")).execute(fragment, out);\n        verify(out).write(\"prefix! existing value\");\n    }\n\n    @Test\n    public void additionalFieldValueSuffix() throws IOException {\n        when(fragment.execute()).thenReturn(\"[prefix!][existing][suffix-]\");\n        ADDITIONAL_FIELD_VALUE.apply(Collections.singletonMap(\"existing\", \"existing value\")).execute(fragment, out);\n        verify(out).write(\"prefix! existing value suffix-\");\n    }\n\n    @Test\n    public void testHtmlMarkDown() {\n        //by default we escape all html\n        assertEquals(\"<p>escape &lt;a href=&quot;http://test&quot;&gt;bla&lt;/a&gt; escape</p>\\n\", MustacheCustomTag.renderToHtmlCommonmarkEscaped(\"escape <a href=\\\"http://test\\\">bla</a> escape\"));\n\n        //for relative link we don't add target=\"_blank\"\n        assertEquals(\"<p>link <a href=\\\"/test\\\">bla</a> link</p>\\n\", MustacheCustomTag.renderToHtmlCommonmarkEscaped(\"link [bla](/test) link\"));\n\n        //for absolute link we add target=\"_blank\"\n        assertEquals(\"<p>link <a href=\\\"http://test\\\" target=\\\"_blank\\\" rel=\\\"nofollow noopener noreferrer\\\">bla</a> link</p>\\n\", MustacheCustomTag.renderToHtmlCommonmarkEscaped(\"link [bla](http://test) link\"));\n    }\n\n    @Test\n    public void acceptOnlyHttpOrHttpsProtocols() {\n        assertEquals(\"<p><a href=\\\"http://google.com\\\" target=\\\"_blank\\\" rel=\\\"nofollow noopener noreferrer\\\">google</a></p>\\n\", MustacheCustomTag.renderToHtmlCommonmarkEscaped(\"[google](http://google.com)\"));\n        assertEquals(\"<p><a href=\\\"https://google.com\\\" target=\\\"_blank\\\" rel=\\\"nofollow noopener noreferrer\\\">google</a></p>\\n\", MustacheCustomTag.renderToHtmlCommonmarkEscaped(\"[google](https://google.com)\"));\n        assertEquals(\"<p><a>google</a></p>\\n\", MustacheCustomTag.renderToHtmlCommonmarkEscaped(\"[google](any:google.com)\"));\n        assertEquals(\"<p><a>google</a></p>\\n\", MustacheCustomTag.renderToHtmlCommonmarkEscaped(\"[google](other:google.com)\"));\n        assertEquals(\"<p><a>google</a></p>\\n\", MustacheCustomTag.renderToHtmlCommonmarkEscaped(\"[google](protocols:/google.com)\"));\n    }\n}",
    "patch": "@@ -87,4 +87,13 @@ public void testHtmlMarkDown() {\n         //for absolute link we add target=\"_blank\"\n         assertEquals(\"<p>link <a href=\\\"http://test\\\" target=\\\"_blank\\\" rel=\\\"nofollow noopener noreferrer\\\">bla</a> link</p>\\n\", MustacheCustomTag.renderToHtmlCommonmarkEscaped(\"link [bla](http://test) link\"));\n     }\n+\n+    @Test\n+    public void acceptOnlyHttpOrHttpsProtocols() {\n+        assertEquals(\"<p><a href=\\\"http://google.com\\\" target=\\\"_blank\\\" rel=\\\"nofollow noopener noreferrer\\\">google</a></p>\\n\", MustacheCustomTag.renderToHtmlCommonmarkEscaped(\"[google](http://google.com)\"));\n+        assertEquals(\"<p><a href=\\\"https://google.com\\\" target=\\\"_blank\\\" rel=\\\"nofollow noopener noreferrer\\\">google</a></p>\\n\", MustacheCustomTag.renderToHtmlCommonmarkEscaped(\"[google](https://google.com)\"));\n+        assertEquals(\"<p><a>google</a></p>\\n\", MustacheCustomTag.renderToHtmlCommonmarkEscaped(\"[google](any:google.com)\"));\n+        assertEquals(\"<p><a>google</a></p>\\n\", MustacheCustomTag.renderToHtmlCommonmarkEscaped(\"[google](other:google.com)\"));\n+        assertEquals(\"<p><a>google</a></p>\\n\", MustacheCustomTag.renderToHtmlCommonmarkEscaped(\"[google](protocols:/google.com)\"));\n+    }\n }\n\\ No newline at end of file",
    "function_modified_lines": {
      "added": [
        "\n",
        "    @Test\n",
        "    public void acceptOnlyHttpOrHttpsProtocols() {\n",
        "        assertEquals(\"<p><a href=\\\"http://google.com\\\" target=\\\"_blank\\\" rel=\\\"nofollow noopener noreferrer\\\">google</a></p>\\n\", MustacheCustomTag.renderToHtmlCommonmarkEscaped(\"[google](http://google.com)\"));\n",
        "        assertEquals(\"<p><a href=\\\"https://google.com\\\" target=\\\"_blank\\\" rel=\\\"nofollow noopener noreferrer\\\">google</a></p>\\n\", MustacheCustomTag.renderToHtmlCommonmarkEscaped(\"[google](https://google.com)\"));\n",
        "        assertEquals(\"<p><a>google</a></p>\\n\", MustacheCustomTag.renderToHtmlCommonmarkEscaped(\"[google](any:google.com)\"));\n",
        "        assertEquals(\"<p><a>google</a></p>\\n\", MustacheCustomTag.renderToHtmlCommonmarkEscaped(\"[google](other:google.com)\"));\n",
        "        assertEquals(\"<p><a>google</a></p>\\n\", MustacheCustomTag.renderToHtmlCommonmarkEscaped(\"[google](protocols:/google.com)\"));\n",
        "    }\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-79"
    ],
    "cve_description": "Cross-site Scripting (XSS) - Stored in GitHub repository alfio-event/alf.io prior to Alf.io 2.0-M4-2301.",
    "id": 12698
  },
  {
    "cve_id": "CVE-2023-32070",
    "code_before_change": "{\n    private static final String ELEM_SPAN = \"span\";\n\n    private static final String ELEM_PRE = \"pre\";\n\n    private static final String PROP_CLASS = \"class\";\n\n    private static final String FIGURE_TAG = \"figure\";\n\n    private static final String FIGURE_CAPTION_TAG = \"figcaption\";\n\n    /**\n     * @param linkRenderer the object to render link events into XHTML. This is done so that it's pluggable because link\n     * rendering depends on how the underlying system wants to handle it. For example for XWiki we check if the document\n     * exists, we get the document URL, etc.\n     * @param imageRenderer the object to render image events into XHTML. This is done so that it's pluggable because\n     * image rendering depends on how the underlying system wants to handle it. For example for XWiki we check if the\n     * image exists as a document attachments, we get its URL, etc.\n     * @param listenerChain the chain of listener filters used to compute various states\n     */\n    public HTML5ChainingRenderer(XHTMLLinkRenderer linkRenderer,\n            XHTMLImageRenderer imageRenderer,\n            ListenerChain listenerChain)\n    {\n        super(linkRenderer, imageRenderer, listenerChain);\n    }\n\n    @Override\n    public void beginFormat(Format format, Map<String, String> parameters)\n    {\n        // Right now, the only difference with the super class is about the \"monospace\" format\n        if (format == Format.MONOSPACE) {\n            Map<String, String> attributes = new HashMap<>();\n            attributes.putAll(parameters);\n            String cssClass = \"monospace\";\n            // The element may already have a class\n            if (attributes.containsKey(PROP_CLASS)) {\n                cssClass = String.format(\"%s %s\", cssClass, attributes.get(PROP_CLASS));\n            }\n            attributes.put(PROP_CLASS, cssClass);\n            getXHTMLWikiPrinter().printXMLStartElement(ELEM_SPAN, attributes);\n        } else {\n            // Call the super class\n            super.beginFormat(format, parameters);\n        }\n\n    }\n\n    @Override\n    public void endFormat(Format format, Map<String, String> parameters)\n    {\n        if (!parameters.isEmpty()) {\n            getXHTMLWikiPrinter().printXMLEndElement(ELEM_SPAN);\n        }\n        // Right now, the only difference with the super class is about the \"monospace\" format\n        if (format == Format.MONOSPACE) {\n            if (parameters.isEmpty()) {\n                // if the parameters are not empty, the span element has already been closed\n                getXHTMLWikiPrinter().printXMLEndElement(ELEM_SPAN);\n            }\n        } else {\n            // Call the super class, with an empty parameters map to avoid closing the span element twice\n            super.endFormat(format, new HashMap<String, String>());\n        }\n    }\n\n    @Override\n    public void onVerbatim(String content, boolean inline, Map<String, String> parameters)\n    {\n        if (inline) {\n            // Note: We generate a span element rather than a pre element since pre elements cannot be located inside\n            // paragraphs for example.\n            // The class is what is expected by wikimodel to understand the span as meaning a verbatim and not a\n            // Monospace element.\n            getXHTMLWikiPrinter().printXMLStartElement(ELEM_SPAN,\n                new String[][] { { PROP_CLASS, \"wikimodel-verbatim\" } });\n            getXHTMLWikiPrinter().printXML(content);\n            getXHTMLWikiPrinter().printXMLEndElement(ELEM_SPAN);\n        } else {\n            getXHTMLWikiPrinter().printXMLStartElement(ELEM_PRE, parameters);\n            getXHTMLWikiPrinter().printXML(content);\n            getXHTMLWikiPrinter().printXMLEndElement(ELEM_PRE);\n        }\n    }\n\n    @Override\n    public void beginFigure(Map<String, String> parameters)\n    {\n        getXHTMLWikiPrinter().printXMLStartElement(FIGURE_TAG, parameters);\n    }\n\n    @Override\n    public void beginFigureCaption(Map<String, String> parameters)\n    {\n        getXHTMLWikiPrinter().printXMLStartElement(FIGURE_CAPTION_TAG, parameters);\n    }\n\n    @Override\n    public void endFigure(Map<String, String> parameters)\n    {\n        getXHTMLWikiPrinter().printXMLEndElement(FIGURE_TAG);\n    }\n\n    @Override\n    public void endFigureCaption(Map<String, String> parameters)\n    {\n        getXHTMLWikiPrinter().printXMLEndElement(FIGURE_CAPTION_TAG);\n    }\n}",
    "code_after_change": "{\n    private static final String ELEM_SPAN = \"span\";\n\n    private static final String ELEM_PRE = \"pre\";\n\n    private static final String PROP_CLASS = \"class\";\n\n    private static final String FIGURE_TAG = \"figure\";\n\n    private static final String FIGURE_CAPTION_TAG = \"figcaption\";\n\n    /**\n     * @param linkRenderer the object to render link events into XHTML. This is done so that it's pluggable because link\n     * rendering depends on how the underlying system wants to handle it. For example for XWiki we check if the document\n     * exists, we get the document URL, etc.\n     * @param imageRenderer the object to render image events into XHTML. This is done so that it's pluggable because\n     * image rendering depends on how the underlying system wants to handle it. For example for XWiki we check if the\n     * image exists as a document attachments, we get its URL, etc.\n     * @param htmlElementSanitizer the sanitizer to use for sanitizing HTML elements and attributes\n     * @param listenerChain the chain of listener filters used to compute various states\n     */\n    public HTML5ChainingRenderer(XHTMLLinkRenderer linkRenderer,\n            XHTMLImageRenderer imageRenderer, HTMLElementSanitizer htmlElementSanitizer,\n            ListenerChain listenerChain)\n    {\n        super(linkRenderer, imageRenderer, htmlElementSanitizer, listenerChain);\n    }\n\n    @Override\n    public void beginFormat(Format format, Map<String, String> parameters)\n    {\n        // Right now, the only difference with the super class is about the \"monospace\" format\n        if (format == Format.MONOSPACE) {\n            Map<String, String> attributes = new LinkedHashMap<>(parameters);\n            String cssClass = \"monospace\";\n            // The element may already have a class\n            if (attributes.containsKey(PROP_CLASS)) {\n                cssClass = String.format(\"%s %s\", cssClass, attributes.get(PROP_CLASS));\n            }\n            attributes.put(PROP_CLASS, cssClass);\n            getXHTMLWikiPrinter().printXMLStartElement(ELEM_SPAN, attributes);\n        } else {\n            // Call the super class\n            super.beginFormat(format, parameters);\n        }\n\n    }\n\n    @Override\n    public void endFormat(Format format, Map<String, String> parameters)\n    {\n        if (!parameters.isEmpty()) {\n            getXHTMLWikiPrinter().printXMLEndElement(ELEM_SPAN);\n        }\n        // Right now, the only difference with the super class is about the \"monospace\" format\n        if (format == Format.MONOSPACE) {\n            if (parameters.isEmpty()) {\n                // if the parameters are not empty, the span element has already been closed\n                getXHTMLWikiPrinter().printXMLEndElement(ELEM_SPAN);\n            }\n        } else {\n            // Call the super class, with an empty parameters map to avoid closing the span element twice\n            super.endFormat(format, new HashMap<String, String>());\n        }\n    }\n\n    @Override\n    public void onVerbatim(String content, boolean inline, Map<String, String> parameters)\n    {\n        if (inline) {\n            // Note: We generate a span element rather than a pre element since pre elements cannot be located inside\n            // paragraphs for example.\n            // The class is what is expected by wikimodel to understand the span as meaning a verbatim and not a\n            // Monospace element.\n            getXHTMLWikiPrinter().printXMLStartElement(ELEM_SPAN,\n                new String[][] { { PROP_CLASS, \"wikimodel-verbatim\" } });\n            getXHTMLWikiPrinter().printXML(content);\n            getXHTMLWikiPrinter().printXMLEndElement(ELEM_SPAN);\n        } else {\n            getXHTMLWikiPrinter().printXMLStartElement(ELEM_PRE, parameters);\n            getXHTMLWikiPrinter().printXML(content);\n            getXHTMLWikiPrinter().printXMLEndElement(ELEM_PRE);\n        }\n    }\n\n    @Override\n    public void beginFigure(Map<String, String> parameters)\n    {\n        getXHTMLWikiPrinter().printXMLStartElement(FIGURE_TAG, parameters);\n    }\n\n    @Override\n    public void beginFigureCaption(Map<String, String> parameters)\n    {\n        getXHTMLWikiPrinter().printXMLStartElement(FIGURE_CAPTION_TAG, parameters);\n    }\n\n    @Override\n    public void endFigure(Map<String, String> parameters)\n    {\n        getXHTMLWikiPrinter().printXMLEndElement(FIGURE_TAG);\n    }\n\n    @Override\n    public void endFigureCaption(Map<String, String> parameters)\n    {\n        getXHTMLWikiPrinter().printXMLEndElement(FIGURE_CAPTION_TAG);\n    }\n}",
    "patch": "@@ -20,13 +20,15 @@\n package org.xwiki.rendering.internal.renderer.html5;\n \n import java.util.HashMap;\n+import java.util.LinkedHashMap;\n import java.util.Map;\n \n import org.xwiki.rendering.internal.renderer.xhtml.XHTMLChainingRenderer;\n import org.xwiki.rendering.internal.renderer.xhtml.image.XHTMLImageRenderer;\n import org.xwiki.rendering.internal.renderer.xhtml.link.XHTMLLinkRenderer;\n import org.xwiki.rendering.listener.Format;\n import org.xwiki.rendering.listener.chaining.ListenerChain;\n+import org.xwiki.xml.html.HTMLElementSanitizer;\n \n /**\n  * Convert listener events to HTML5.\n@@ -53,22 +55,22 @@ public class HTML5ChainingRenderer extends XHTMLChainingRenderer\n      * @param imageRenderer the object to render image events into XHTML. This is done so that it's pluggable because\n      * image rendering depends on how the underlying system wants to handle it. For example for XWiki we check if the\n      * image exists as a document attachments, we get its URL, etc.\n+     * @param htmlElementSanitizer the sanitizer to use for sanitizing HTML elements and attributes\n      * @param listenerChain the chain of listener filters used to compute various states\n      */\n     public HTML5ChainingRenderer(XHTMLLinkRenderer linkRenderer,\n-            XHTMLImageRenderer imageRenderer,\n+            XHTMLImageRenderer imageRenderer, HTMLElementSanitizer htmlElementSanitizer,\n             ListenerChain listenerChain)\n     {\n-        super(linkRenderer, imageRenderer, listenerChain);\n+        super(linkRenderer, imageRenderer, htmlElementSanitizer, listenerChain);\n     }\n \n     @Override\n     public void beginFormat(Format format, Map<String, String> parameters)\n     {\n         // Right now, the only difference with the super class is about the \"monospace\" format\n         if (format == Format.MONOSPACE) {\n-            Map<String, String> attributes = new HashMap<>();\n-            attributes.putAll(parameters);\n+            Map<String, String> attributes = new LinkedHashMap<>(parameters);\n             String cssClass = \"monospace\";\n             // The element may already have a class\n             if (attributes.containsKey(PROP_CLASS)) {",
    "function_modified_lines": {
      "added": [
        "     * @param htmlElementSanitizer the sanitizer to use for sanitizing HTML elements and attributes\n",
        "            XHTMLImageRenderer imageRenderer, HTMLElementSanitizer htmlElementSanitizer,\n",
        "        super(linkRenderer, imageRenderer, htmlElementSanitizer, listenerChain);\n",
        "            Map<String, String> attributes = new LinkedHashMap<>(parameters);\n"
      ],
      "deleted": [
        "            XHTMLImageRenderer imageRenderer,\n",
        "        super(linkRenderer, imageRenderer, listenerChain);\n",
        "            Map<String, String> attributes = new HashMap<>();\n",
        "            attributes.putAll(parameters);\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-79"
    ],
    "cve_description": "XWiki Platform is a generic wiki platform. Prior to version 14.6-rc-1, HTML rendering didn't check for dangerous attributes/attribute values. This allowed cross-site scripting (XSS) attacks via attributes and link URLs, e.g., supported in XWiki syntax. This has been patched in XWiki 14.6-rc-1. There are no known workarounds apart from upgrading to a fixed version.",
    "id": 12703
  },
  {
    "cve_id": "CVE-2023-32070",
    "code_before_change": "{\n    /**\n     * To render link events into XHTML. This is done so that it's pluggable because link rendering depends on how the\n     * underlying system wants to handle it. For example for XWiki we check if the document exists, we get the document\n     * URL, etc.\n     */\n    @Inject\n    private XHTMLLinkRenderer linkRenderer;\n\n    /**\n     * To render image events into XHTML. This is done so that it's pluggable because image rendering depends on how the\n     * underlying system wants to handle it. For example for XWiki we check if the image exists as a document\n     * attachments, we get its URL, etc.\n     */\n    @Inject\n    private XHTMLImageRenderer imageRenderer;\n\n    @Override\n    public void initialize() throws InitializationException\n    {\n        ListenerChain chain = new ListenerChain();\n        setListenerChain(chain);\n\n        // Construct the listener chain in the right order. Listeners early in the chain are called before listeners\n        // placed later in the chain.\n        chain.addListener(this);\n        chain.addListener(new BlockStateChainingListener(chain));\n        chain.addListener(new EmptyBlockChainingListener(chain));\n        chain.addListener(new MetaDataStateChainingListener(chain));\n        chain.addListener(new HTML5ChainingRenderer(this.linkRenderer, this.imageRenderer, chain));\n    }\n}",
    "code_after_change": "{\n    /**\n     * To render link events into XHTML. This is done so that it's pluggable because link rendering depends on how the\n     * underlying system wants to handle it. For example for XWiki we check if the document exists, we get the document\n     * URL, etc.\n     */\n    @Inject\n    private XHTMLLinkRenderer linkRenderer;\n\n    /**\n     * To render image events into XHTML. This is done so that it's pluggable because image rendering depends on how the\n     * underlying system wants to handle it. For example for XWiki we check if the image exists as a document\n     * attachments, we get its URL, etc.\n     */\n    @Inject\n    private XHTMLImageRenderer imageRenderer;\n\n    @Inject\n    private HTMLElementSanitizer htmlElementSanitizer;\n\n    @Override\n    public void initialize() throws InitializationException\n    {\n        ListenerChain chain = new ListenerChain();\n        setListenerChain(chain);\n\n        // Construct the listener chain in the right order. Listeners early in the chain are called before listeners\n        // placed later in the chain.\n        chain.addListener(this);\n        chain.addListener(new BlockStateChainingListener(chain));\n        chain.addListener(new EmptyBlockChainingListener(chain));\n        chain.addListener(new MetaDataStateChainingListener(chain));\n        chain.addListener(new HTML5ChainingRenderer(this.linkRenderer, this.imageRenderer, this.htmlElementSanitizer,\n            chain));\n    }\n}",
    "patch": "@@ -34,6 +34,7 @@\n import org.xwiki.rendering.listener.chaining.ListenerChain;\n import org.xwiki.rendering.listener.chaining.MetaDataStateChainingListener;\n import org.xwiki.rendering.renderer.AbstractChainingPrintRenderer;\n+import org.xwiki.xml.html.HTMLElementSanitizer;\n \n /**\n  * Generates HTML5 from a {@link org.xwiki.rendering.block.XDOM} object being traversed.\n@@ -62,6 +63,9 @@ public class HTML5Renderer extends AbstractChainingPrintRenderer implements Init\n     @Inject\n     private XHTMLImageRenderer imageRenderer;\n \n+    @Inject\n+    private HTMLElementSanitizer htmlElementSanitizer;\n+\n     @Override\n     public void initialize() throws InitializationException\n     {\n@@ -74,7 +78,8 @@ public void initialize() throws InitializationException\n         chain.addListener(new BlockStateChainingListener(chain));\n         chain.addListener(new EmptyBlockChainingListener(chain));\n         chain.addListener(new MetaDataStateChainingListener(chain));\n-        chain.addListener(new HTML5ChainingRenderer(this.linkRenderer, this.imageRenderer, chain));\n+        chain.addListener(new HTML5ChainingRenderer(this.linkRenderer, this.imageRenderer, this.htmlElementSanitizer,\n+            chain));\n     }\n }\n ",
    "function_modified_lines": {
      "added": [
        "    @Inject\n",
        "    private HTMLElementSanitizer htmlElementSanitizer;\n",
        "\n",
        "        chain.addListener(new HTML5ChainingRenderer(this.linkRenderer, this.imageRenderer, this.htmlElementSanitizer,\n",
        "            chain));\n"
      ],
      "deleted": [
        "        chain.addListener(new HTML5ChainingRenderer(this.linkRenderer, this.imageRenderer, chain));\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-79"
    ],
    "cve_description": "XWiki Platform is a generic wiki platform. Prior to version 14.6-rc-1, HTML rendering didn't check for dangerous attributes/attribute values. This allowed cross-site scripting (XSS) attacks via attributes and link URLs, e.g., supported in XWiki syntax. This has been patched in XWiki 14.6-rc-1. There are no known workarounds apart from upgrading to a fixed version.",
    "id": 12704
  },
  {
    "cve_id": "CVE-2023-32070",
    "code_before_change": "import org.xwiki.rendering.listener.reference.ResourceReference;\nimport org.xwiki.rendering.renderer.AbstractChainingPrintRenderer;\nimport org.xwiki.rendering.renderer.printer.WikiPrinter;\nimport org.xwiki.rendering.renderer.printer.XHTMLWikiPrinter;\nimport org.xwiki.rendering.syntax.Syntax;\nimport org.xwiki.rendering.syntax.SyntaxType;\nimport org.xwiki.xml.html.HTMLConstants;\n\n/**\n * Convert listener events to XHTML.\n *\n * @version $Id$\n * @since 1.8RC1\n */\npublic class XHTMLChainingRenderer extends AbstractChainingPrintRenderer\n{\n    /**\n     * Class attribute value that indicates if the header was generated by a macro.\n     */\n    public static final String GENERATEDHEADERCLASS = \"wikigeneratedheader\";\n\n    /**\n     * Class attribute value that indicates if the header id attribute was generated automatically or if it was the user\n     * who specified an id.\n     */\n    public static final String GENERATEDIDCLASS = \"wikigeneratedid\";\n\n    private XHTMLLinkRenderer linkRenderer;\n\n    private XHTMLImageRenderer imageRenderer;\n\n    private XHTMLWikiPrinter xhtmlWikiPrinter;\n\n    /**\n     * @param linkRenderer the object to render link events into XHTML. This is done so that it's pluggable because link\n     *            rendering depends on how the underlying system wants to handle it. For example for XWiki we check if\n     *            the document exists, we get the document URL, etc.\n     * @param imageRenderer the object to render image events into XHTML. This is done so that it's pluggable because\n     *            image rendering depends on how the underlying system wants to handle it. For example for XWiki we\n     *            check if the image exists as a document attachments, we get its URL, etc.\n     * @param listenerChain the chain of listener filters used to compute various states\n     */\n    public XHTMLChainingRenderer(XHTMLLinkRenderer linkRenderer, XHTMLImageRenderer imageRenderer,\n        ListenerChain listenerChain)\n    {\n        setListenerChain(listenerChain);\n\n        this.linkRenderer = linkRenderer;\n        this.imageRenderer = imageRenderer;\n    }\n\n    // State\n\n    protected BlockStateChainingListener getBlockState()\n    {\n        return (BlockStateChainingListener) getListenerChain().getListener(BlockStateChainingListener.class);\n    }\n\n    protected EmptyBlockChainingListener getEmptyBlockState()\n    {\n        return (EmptyBlockChainingListener) getListenerChain().getListener(EmptyBlockChainingListener.class);\n    }\n\n    protected MetaDataStateChainingListener getMetaDataState()\n    {\n        return (MetaDataStateChainingListener) getListenerChain().getListener(MetaDataStateChainingListener.class);\n    }\n\n    // Printer\n\n    @Override\n    protected void pushPrinter(WikiPrinter wikiPrinter)\n    {\n        super.pushPrinter(wikiPrinter);\n        getXHTMLWikiPrinter().setWikiPrinter(getPrinter());\n    }\n\n    @Override\n    protected void popPrinter()\n    {",
    "code_after_change": "import org.xwiki.rendering.listener.chaining.ListenerChain;\nimport org.xwiki.rendering.listener.chaining.MetaDataStateChainingListener;\nimport org.xwiki.rendering.listener.reference.ResourceReference;\nimport org.xwiki.rendering.renderer.AbstractChainingPrintRenderer;\nimport org.xwiki.rendering.renderer.printer.WikiPrinter;\nimport org.xwiki.rendering.renderer.printer.XHTMLWikiPrinter;\nimport org.xwiki.rendering.syntax.Syntax;\nimport org.xwiki.rendering.syntax.SyntaxType;\nimport org.xwiki.xml.html.HTMLConstants;\nimport org.xwiki.xml.html.HTMLElementSanitizer;\n\n/**\n * Convert listener events to XHTML.\n *\n * @version $Id$\n * @since 1.8RC1\n */\npublic class XHTMLChainingRenderer extends AbstractChainingPrintRenderer\n{\n    /**\n     * Class attribute value that indicates if the header was generated by a macro.\n     */\n    public static final String GENERATEDHEADERCLASS = \"wikigeneratedheader\";\n\n    /**\n     * Class attribute value that indicates if the header id attribute was generated automatically or if it was the user\n     * who specified an id.\n     */\n    public static final String GENERATEDIDCLASS = \"wikigeneratedid\";\n\n    private XHTMLLinkRenderer linkRenderer;\n\n    private XHTMLImageRenderer imageRenderer;\n\n    private final HTMLElementSanitizer htmlElementSanitizer;\n\n    private XHTMLWikiPrinter xhtmlWikiPrinter;\n\n    /**\n     * @param linkRenderer the object to render link events into XHTML. This is done so that it's pluggable because\n     *     link rendering depends on how the underlying system wants to handle it. For example for XWiki we check if the\n     *     document exists, we get the document URL, etc.\n     * @param imageRenderer the object to render image events into XHTML. This is done so that it's pluggable\n     *     because image rendering depends on how the underlying system wants to handle it. For example for XWiki we\n     *     check if the image exists as a document attachments, we get its URL, etc.\n     * @param htmlElementSanitizer the sanitizer for XHTML elements\n     * @param listenerChain the chain of listener filters used to compute various states\n     */\n    public XHTMLChainingRenderer(XHTMLLinkRenderer linkRenderer, XHTMLImageRenderer imageRenderer,\n        HTMLElementSanitizer htmlElementSanitizer, ListenerChain listenerChain)\n    {\n        setListenerChain(listenerChain);\n\n        this.linkRenderer = linkRenderer;\n        this.imageRenderer = imageRenderer;\n        this.htmlElementSanitizer = htmlElementSanitizer;\n    }\n\n    // State\n\n    protected BlockStateChainingListener getBlockState()\n    {\n        return (BlockStateChainingListener) getListenerChain().getListener(BlockStateChainingListener.class);\n    }\n\n    protected EmptyBlockChainingListener getEmptyBlockState()\n    {\n        return (EmptyBlockChainingListener) getListenerChain().getListener(EmptyBlockChainingListener.class);\n    }\n\n    protected MetaDataStateChainingListener getMetaDataState()\n    {\n        return (MetaDataStateChainingListener) getListenerChain().getListener(MetaDataStateChainingListener.class);\n    }\n\n    // Printer\n\n    @Override\n    protected void pushPrinter(WikiPrinter wikiPrinter)\n    {\n        super.pushPrinter(wikiPrinter);\n        getXHTMLWikiPrinter().setWikiPrinter(getPrinter());\n    }\n\n    @Override\n    protected void popPrinter()\n    {\n        super.popPrinter();\n        getXHTMLWikiPrinter().setWikiPrinter(getPrinter());\n    }\n\n    protected XHTMLWikiPrinter getXHTMLWikiPrinter()",
    "patch": "@@ -41,6 +41,7 @@\n import org.xwiki.rendering.syntax.Syntax;\n import org.xwiki.rendering.syntax.SyntaxType;\n import org.xwiki.xml.html.HTMLConstants;\n+import org.xwiki.xml.html.HTMLElementSanitizer;\n \n /**\n  * Convert listener events to XHTML.\n@@ -65,24 +66,28 @@ public class XHTMLChainingRenderer extends AbstractChainingPrintRenderer\n \n     private XHTMLImageRenderer imageRenderer;\n \n+    private final HTMLElementSanitizer htmlElementSanitizer;\n+\n     private XHTMLWikiPrinter xhtmlWikiPrinter;\n \n     /**\n-     * @param linkRenderer the object to render link events into XHTML. This is done so that it's pluggable because link\n-     *            rendering depends on how the underlying system wants to handle it. For example for XWiki we check if\n-     *            the document exists, we get the document URL, etc.\n-     * @param imageRenderer the object to render image events into XHTML. This is done so that it's pluggable because\n-     *            image rendering depends on how the underlying system wants to handle it. For example for XWiki we\n-     *            check if the image exists as a document attachments, we get its URL, etc.\n+     * @param linkRenderer the object to render link events into XHTML. This is done so that it's pluggable because\n+     *     link rendering depends on how the underlying system wants to handle it. For example for XWiki we check if the\n+     *     document exists, we get the document URL, etc.\n+     * @param imageRenderer the object to render image events into XHTML. This is done so that it's pluggable\n+     *     because image rendering depends on how the underlying system wants to handle it. For example for XWiki we\n+     *     check if the image exists as a document attachments, we get its URL, etc.\n+     * @param htmlElementSanitizer the sanitizer for XHTML elements\n      * @param listenerChain the chain of listener filters used to compute various states\n      */\n     public XHTMLChainingRenderer(XHTMLLinkRenderer linkRenderer, XHTMLImageRenderer imageRenderer,\n-        ListenerChain listenerChain)\n+        HTMLElementSanitizer htmlElementSanitizer, ListenerChain listenerChain)\n     {\n         setListenerChain(listenerChain);\n \n         this.linkRenderer = linkRenderer;\n         this.imageRenderer = imageRenderer;\n+        this.htmlElementSanitizer = htmlElementSanitizer;\n     }\n \n     // State\n@@ -121,11 +126,16 @@ protected void popPrinter()\n     protected XHTMLWikiPrinter getXHTMLWikiPrinter()\n     {\n         if (this.xhtmlWikiPrinter == null) {\n-            this.xhtmlWikiPrinter = new XHTMLWikiPrinter(getPrinter());\n+            this.xhtmlWikiPrinter = new XHTMLWikiPrinter(getPrinter(), getHtmlElementSanitizer());\n         }\n         return this.xhtmlWikiPrinter;\n     }\n \n+    protected HTMLElementSanitizer getHtmlElementSanitizer()\n+    {\n+        return this.htmlElementSanitizer;\n+    }\n+\n     // Events\n \n     @Override",
    "function_modified_lines": {
      "added": [
        "    private final HTMLElementSanitizer htmlElementSanitizer;\n",
        "\n",
        "     * @param linkRenderer the object to render link events into XHTML. This is done so that it's pluggable because\n",
        "     *     link rendering depends on how the underlying system wants to handle it. For example for XWiki we check if the\n",
        "     *     document exists, we get the document URL, etc.\n",
        "     * @param imageRenderer the object to render image events into XHTML. This is done so that it's pluggable\n",
        "     *     because image rendering depends on how the underlying system wants to handle it. For example for XWiki we\n",
        "     *     check if the image exists as a document attachments, we get its URL, etc.\n",
        "     * @param htmlElementSanitizer the sanitizer for XHTML elements\n",
        "        HTMLElementSanitizer htmlElementSanitizer, ListenerChain listenerChain)\n",
        "        this.htmlElementSanitizer = htmlElementSanitizer;\n"
      ],
      "deleted": [
        "     * @param linkRenderer the object to render link events into XHTML. This is done so that it's pluggable because link\n",
        "     *            rendering depends on how the underlying system wants to handle it. For example for XWiki we check if\n",
        "     *            the document exists, we get the document URL, etc.\n",
        "     * @param imageRenderer the object to render image events into XHTML. This is done so that it's pluggable because\n",
        "     *            image rendering depends on how the underlying system wants to handle it. For example for XWiki we\n",
        "     *            check if the image exists as a document attachments, we get its URL, etc.\n",
        "        ListenerChain listenerChain)\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-79"
    ],
    "cve_description": "XWiki Platform is a generic wiki platform. Prior to version 14.6-rc-1, HTML rendering didn't check for dangerous attributes/attribute values. This allowed cross-site scripting (XSS) attacks via attributes and link URLs, e.g., supported in XWiki syntax. This has been patched in XWiki 14.6-rc-1. There are no known workarounds apart from upgrading to a fixed version.",
    "id": 12705
  },
  {
    "cve_id": "CVE-2023-32070",
    "code_before_change": "{\n    /**\n     * To render link events into XHTML. This is done so that it's pluggable because link rendering depends on how the\n     * underlying system wants to handle it. For example for XWiki we check if the document exists, we get the document\n     * URL, etc.\n     */\n    @Inject\n    private XHTMLLinkRenderer linkRenderer;\n\n    /**\n     * To render image events into XHTML. This is done so that it's pluggable because image rendering depends on how the\n     * underlying system wants to handle it. For example for XWiki we check if the image exists as a document\n     * attachments, we get its URL, etc.\n     */\n    @Inject\n    private XHTMLImageRenderer imageRenderer;\n\n    @Override\n    public void initialize() throws InitializationException\n    {\n        ListenerChain chain = new ListenerChain();\n        setListenerChain(chain);\n\n        // Construct the listener chain in the right order. Listeners early in the chain are called before listeners\n        // placed later in the chain.\n        chain.addListener(this);\n        chain.addListener(new BlockStateChainingListener(chain));\n        chain.addListener(new EmptyBlockChainingListener(chain));\n        chain.addListener(new MetaDataStateChainingListener(chain));\n        chain.addListener(new XHTMLChainingRenderer(this.linkRenderer, this.imageRenderer, chain));\n    }\n}",
    "code_after_change": "{\n    /**\n     * To render link events into XHTML. This is done so that it's pluggable because link rendering depends on how the\n     * underlying system wants to handle it. For example for XWiki we check if the document exists, we get the document\n     * URL, etc.\n     */\n    @Inject\n    private XHTMLLinkRenderer linkRenderer;\n\n    /**\n     * To render image events into XHTML. This is done so that it's pluggable because image rendering depends on how the\n     * underlying system wants to handle it. For example for XWiki we check if the image exists as a document\n     * attachments, we get its URL, etc.\n     */\n    @Inject\n    private XHTMLImageRenderer imageRenderer;\n\n    @Inject\n    private HTMLElementSanitizer htmlElementSanitizer;\n\n    @Override\n    public void initialize() throws InitializationException\n    {\n        ListenerChain chain = new ListenerChain();\n        setListenerChain(chain);\n\n        // Construct the listener chain in the right order. Listeners early in the chain are called before listeners\n        // placed later in the chain.\n        chain.addListener(this);\n        chain.addListener(new BlockStateChainingListener(chain));\n        chain.addListener(new EmptyBlockChainingListener(chain));\n        chain.addListener(new MetaDataStateChainingListener(chain));\n        chain.addListener(new XHTMLChainingRenderer(this.linkRenderer, this.imageRenderer, this.htmlElementSanitizer,\n            chain));\n    }\n}",
    "patch": "@@ -34,6 +34,7 @@\n import org.xwiki.rendering.listener.chaining.ListenerChain;\n import org.xwiki.rendering.listener.chaining.MetaDataStateChainingListener;\n import org.xwiki.rendering.renderer.AbstractChainingPrintRenderer;\n+import org.xwiki.xml.html.HTMLElementSanitizer;\n \n /**\n  * Generates XHTML from a {@link org.xwiki.rendering.block.XDOM} object being traversed.\n@@ -62,6 +63,9 @@ public class XHTMLRenderer extends AbstractChainingPrintRenderer implements Init\n     @Inject\n     private XHTMLImageRenderer imageRenderer;\n \n+    @Inject\n+    private HTMLElementSanitizer htmlElementSanitizer;\n+\n     @Override\n     public void initialize() throws InitializationException\n     {\n@@ -74,6 +78,7 @@ public void initialize() throws InitializationException\n         chain.addListener(new BlockStateChainingListener(chain));\n         chain.addListener(new EmptyBlockChainingListener(chain));\n         chain.addListener(new MetaDataStateChainingListener(chain));\n-        chain.addListener(new XHTMLChainingRenderer(this.linkRenderer, this.imageRenderer, chain));\n+        chain.addListener(new XHTMLChainingRenderer(this.linkRenderer, this.imageRenderer, this.htmlElementSanitizer,\n+            chain));\n     }\n }",
    "function_modified_lines": {
      "added": [
        "    @Inject\n",
        "    private HTMLElementSanitizer htmlElementSanitizer;\n",
        "\n",
        "        chain.addListener(new XHTMLChainingRenderer(this.linkRenderer, this.imageRenderer, this.htmlElementSanitizer,\n",
        "            chain));\n"
      ],
      "deleted": [
        "        chain.addListener(new XHTMLChainingRenderer(this.linkRenderer, this.imageRenderer, chain));\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-79"
    ],
    "cve_description": "XWiki Platform is a generic wiki platform. Prior to version 14.6-rc-1, HTML rendering didn't check for dangerous attributes/attribute values. This allowed cross-site scripting (XSS) attacks via attributes and link URLs, e.g., supported in XWiki syntax. This has been patched in XWiki 14.6-rc-1. There are no known workarounds apart from upgrading to a fixed version.",
    "id": 12706
  },
  {
    "cve_id": "CVE-2023-32070",
    "code_before_change": "{\n    /**\n     * Those events are hard to test since there's no easy syntax to input them (requires XWiki 2.0+ Syntax with a\n     * Macro transformation applied).\n     */\n    @Test\n    void outputFigureCaptionEvents()\n    {\n        XHTMLChainingRenderer renderer = new XHTMLChainingRenderer(null, null, new ListenerChain());\n        WikiPrinter wikiPrinter = new DefaultWikiPrinter();\n        renderer.setPrinter(wikiPrinter);\n        renderer.beginFigureCaption(Collections.emptyMap());\n        renderer.onWord(\"caption\");\n        renderer.endFigureCaption(Collections.emptyMap());\n\n        assertEquals(\"<div class=\\\"figcaption\\\">caption</div>\", wikiPrinter.toString());\n    }\n\n    @Test\n    void onRawText()\n    {\n        XHTMLChainingRenderer renderer = new XHTMLChainingRenderer(null, null, new ListenerChain());\n        WikiPrinter wikiPrinter = new DefaultWikiPrinter();\n        renderer.setPrinter(wikiPrinter);\n        renderer.onRawText(\"xhtml/1.0\", Syntax.XHTML_1_0);\n        renderer.onRawText(\"html/4.01\", Syntax.HTML_4_01);\n        renderer.onRawText(\"html/5.0\", Syntax.HTML_5_0);\n        renderer.onRawText(\"annotatedxhtml/1.0\", Syntax.ANNOTATED_XHTML_1_0);\n        renderer.onRawText(\"annotatedhtml/5.0\", Syntax.ANNOTATED_HTML_5_0);\n        renderer.onRawText(\"plain/1.0\", Syntax.PLAIN_1_0);\n\n        assertEquals(\"xhtml/1.0html/4.01html/5.0annotatedxhtml/1.0annotatedhtml/5.0\", wikiPrinter.toString());\n    }\n}",
    "code_after_change": "{\n    /**\n     * Those events are hard to test since there's no easy syntax to input them (requires XWiki 2.0+ Syntax with a\n     * Macro transformation applied).\n     */\n    @Test\n    void outputFigureCaptionEvents()\n    {\n        XHTMLChainingRenderer renderer = new XHTMLChainingRenderer(null, null, null, new ListenerChain());\n        WikiPrinter wikiPrinter = new DefaultWikiPrinter();\n        renderer.setPrinter(wikiPrinter);\n        renderer.beginFigureCaption(Collections.emptyMap());\n        renderer.onWord(\"caption\");\n        renderer.endFigureCaption(Collections.emptyMap());\n\n        assertEquals(\"<div class=\\\"figcaption\\\">caption</div>\", wikiPrinter.toString());\n    }\n\n    @Test\n    void onRawText()\n    {\n        XHTMLChainingRenderer renderer = new XHTMLChainingRenderer(null, null, null, new ListenerChain());\n        WikiPrinter wikiPrinter = new DefaultWikiPrinter();\n        renderer.setPrinter(wikiPrinter);\n        renderer.onRawText(\"xhtml/1.0\", Syntax.XHTML_1_0);\n        renderer.onRawText(\"html/4.01\", Syntax.HTML_4_01);\n        renderer.onRawText(\"html/5.0\", Syntax.HTML_5_0);\n        renderer.onRawText(\"annotatedxhtml/1.0\", Syntax.ANNOTATED_XHTML_1_0);\n        renderer.onRawText(\"annotatedhtml/5.0\", Syntax.ANNOTATED_HTML_5_0);\n        renderer.onRawText(\"plain/1.0\", Syntax.PLAIN_1_0);\n\n        assertEquals(\"xhtml/1.0html/4.01html/5.0annotatedxhtml/1.0annotatedhtml/5.0\", wikiPrinter.toString());\n    }\n}",
    "patch": "@@ -44,7 +44,7 @@ class XHTMLChainingRendererTest\n     @Test\n     void outputFigureCaptionEvents()\n     {\n-        XHTMLChainingRenderer renderer = new XHTMLChainingRenderer(null, null, new ListenerChain());\n+        XHTMLChainingRenderer renderer = new XHTMLChainingRenderer(null, null, null, new ListenerChain());\n         WikiPrinter wikiPrinter = new DefaultWikiPrinter();\n         renderer.setPrinter(wikiPrinter);\n         renderer.beginFigureCaption(Collections.emptyMap());\n@@ -57,7 +57,7 @@ void outputFigureCaptionEvents()\n     @Test\n     void onRawText()\n     {\n-        XHTMLChainingRenderer renderer = new XHTMLChainingRenderer(null, null, new ListenerChain());\n+        XHTMLChainingRenderer renderer = new XHTMLChainingRenderer(null, null, null, new ListenerChain());\n         WikiPrinter wikiPrinter = new DefaultWikiPrinter();\n         renderer.setPrinter(wikiPrinter);\n         renderer.onRawText(\"xhtml/1.0\", Syntax.XHTML_1_0);",
    "function_modified_lines": {
      "added": [
        "        XHTMLChainingRenderer renderer = new XHTMLChainingRenderer(null, null, null, new ListenerChain());\n",
        "        XHTMLChainingRenderer renderer = new XHTMLChainingRenderer(null, null, null, new ListenerChain());\n"
      ],
      "deleted": [
        "        XHTMLChainingRenderer renderer = new XHTMLChainingRenderer(null, null, new ListenerChain());\n",
        "        XHTMLChainingRenderer renderer = new XHTMLChainingRenderer(null, null, new ListenerChain());\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-79"
    ],
    "cve_description": "XWiki Platform is a generic wiki platform. Prior to version 14.6-rc-1, HTML rendering didn't check for dangerous attributes/attribute values. This allowed cross-site scripting (XSS) attacks via attributes and link URLs, e.g., supported in XWiki syntax. This has been patched in XWiki 14.6-rc-1. There are no known workarounds apart from upgrading to a fixed version.",
    "id": 12707
  },
  {
    "cve_id": "CVE-2023-32070",
    "code_before_change": "/**\n     * Use it to specify that the current element to print is standalone.\n     * This value might be used to know if the first space should be printed with a simple space or a {@code &nbsp;}\n     * entity. Note that the standalone value is automatically reset after first printing of a space, or when a text\n     * is printed.\n     * @since 12.2\n     */",
    "code_after_change": "{\n    /**\n     * Prefix that is used for invalid/disallowed attributes.\n     *\n     * @since 14.6RC1\n     */\n    @Unstable\n    public static final String TRANSLATED_ATTRIBUTE_PREFIX = \"data-xwiki-translated-attribute-\";\n\n    /**\n     * The sanitizer used to restrict allowed elements and attributes, can be null (no restrictions).\n     *\n     * @since 14.6RC1\n     */\n    protected final HTMLElementSanitizer htmlElementSanitizer;\n\n    private int spaceCount;\n\n    private boolean isInCData;\n\n    private boolean isInPreserveElement;\n\n    private boolean elementEnded;\n\n    private boolean hasTextBeenPrinted;\n\n    private boolean isStandalone;\n\n    /**\n     * @param printer the object to which to write the XHTML output to\n     */\n    public XHTMLWikiPrinter(WikiPrinter printer)\n    {\n        this(printer, null);\n    }\n\n    /**\n     * @param printer the object to which to write the XHTML output to\n     * @param htmlElementSanitizer the sanitizer to use for sanitizing elements and attributes\n     */\n    public XHTMLWikiPrinter(WikiPrinter printer, HTMLElementSanitizer htmlElementSanitizer)\n    {\n        super(printer);\n        this.htmlElementSanitizer = htmlElementSanitizer;\n    }\n\n    /**\n     * Use it to specify that the current element to print is standalone. This value might be used to know if the first\n     * space should be printed with a simple space or a {@code &nbsp;} entity. Note that the standalone value is\n     * automatically reset after first printing of a space, or when a text is printed.\n     *\n     * @since 12.2\n     */\n    public void setStandalone()\n    {\n        this.isStandalone = true;\n    }\n\n    @Override\n    public void printXML(String str)\n    {\n        handleSpaceWhenInText();\n        super.printXML(str);\n        this.hasTextBeenPrinted = true;\n        this.isStandalone = false;\n    }\n\n    @Override\n    public void printXMLElement(String name)\n    {\n        if (this.htmlElementSanitizer == null || this.htmlElementSanitizer.isElementAllowed(name)) {\n            handleSpaceWhenStartElement();\n            super.printXMLElement(name);\n        }\n    }\n\n    @Override\n    public void printXMLElement(String name, String[][] attributes)\n    {\n        if (this.htmlElementSanitizer == null || this.htmlElementSanitizer.isElementAllowed(name)) {\n            handleSpaceWhenStartElement();\n            super.printXMLElement(name, cleanAttributes(name, attributes));\n        }\n    }\n\n    @Override\n    public void printXMLElement(String name, Map<String, String> attributes)\n    {\n        if (this.htmlElementSanitizer == null || this.htmlElementSanitizer.isElementAllowed(name)) {\n            handleSpaceWhenStartElement();\n            super.printXMLElement(name, cleanAttributes(name, attributes));\n        }\n    }\n\n    @Override\n    public void printXMLStartElement(String name)\n    {\n        if (this.htmlElementSanitizer == null || this.htmlElementSanitizer.isElementAllowed(name)) {\n            handleSpaceWhenStartElement();\n            super.printXMLStartElement(name);\n        }\n    }\n\n    @Override\n    public void printXMLStartElement(String name, String[][] attributes)\n    {\n        if (this.htmlElementSanitizer == null || this.htmlElementSanitizer.isElementAllowed(name)) {\n            handleSpaceWhenStartElement();\n            super.printXMLStartElement(name, cleanAttributes(name, attributes));\n        }\n    }\n\n    @Override\n    public void printXMLStartElement(String name, Map<String, String> attributes)\n    {\n        if (this.htmlElementSanitizer == null || this.htmlElementSanitizer.isElementAllowed(name)) {\n            handleSpaceWhenStartElement();\n            super.printXMLStartElement(name, cleanAttributes(name, attributes));\n        }\n    }\n\n    @Override\n    public void printXMLStartElement(String name, Attributes attributes)\n    {\n        if (this.htmlElementSanitizer == null || this.htmlElementSanitizer.isElementAllowed(name)) {\n            handleSpaceWhenStartElement();\n            super.printXMLStartElement(name, cleanAttributes(name, attributes));\n        }\n    }\n\n    @Override\n    public void printXMLEndElement(String name)\n    {\n        if (this.htmlElementSanitizer == null || this.htmlElementSanitizer.isElementAllowed(name)) {\n            handleSpaceWhenEndlement();\n            super.printXMLEndElement(name);\n            this.elementEnded = true;\n        }\n    }\n\n    @Override\n    public void printXMLComment(String content)\n    {\n        printXMLComment(content, false);\n    }\n\n    @Override\n    public void printXMLComment(String content, boolean escape)\n    {\n        handleSpaceWhenStartElement();\n        super.printXMLComment(content, escape);\n        this.elementEnded = true;\n    }\n\n    @Override\n    public void printXMLStartCData()\n    {\n        handleSpaceWhenStartElement();\n        super.printXMLStartCData();\n    }\n\n    @Override\n    public void printXMLEndCData()\n    {\n        handleSpaceWhenEndlement();\n        super.printXMLEndCData();\n    }\n\n    /**\n     * This method should be used to print a space rather than calling <code>printXML(\" \")</code>.\n     */\n    public void printSpace()\n    {\n        this.spaceCount++;\n    }\n\n    @Override\n    public void printRaw(String raw)\n    {\n        handleSpaceWhenStartElement();\n        super.printRaw(raw);\n        this.elementEnded = true;\n    }\n\n    private void handleSpaceWhenInText()\n    {\n        if (this.elementEnded || this.hasTextBeenPrinted) {\n            handleSpaceWhenStartElement();\n        } else {\n            handleSpaceWhenEndlement();\n        }\n    }\n\n    private Map<String, String> cleanAttributes(String elementName, Map<String, String> attributes)\n    {\n        Map<String, String> cleanAttributes;\n\n        if (this.htmlElementSanitizer == null || attributes == null) {\n            cleanAttributes = attributes;\n        } else {\n            cleanAttributes = new LinkedHashMap<>();\n            for (Map.Entry<String, String> e : attributes.entrySet()) {\n                if (this.htmlElementSanitizer.isAttributeAllowed(elementName, e.getKey(), e.getValue())) {\n                    cleanAttributes.put(e.getKey(), e.getValue());\n                } else {\n                    cleanAttributes.put(TRANSLATED_ATTRIBUTE_PREFIX + e.getKey(), e.getValue());\n                }\n            }\n        }\n\n        return cleanAttributes;\n    }\n\n    private String[][] cleanAttributes(String elementName, String[][] attributes)\n    {\n        String[][] allowedAttributes;\n        if (this.htmlElementSanitizer == null || attributes == null) {\n            allowedAttributes = attributes;\n        } else {\n            allowedAttributes = Arrays.stream(attributes)\n                .map(entry -> {\n                    if (this.htmlElementSanitizer.isAttributeAllowed(elementName, entry[0], entry[1])) {\n                        return entry;\n                    } else {\n                        return new String[] { TRANSLATED_ATTRIBUTE_PREFIX + entry[0], entry[1] };\n                    }\n                })\n                .toArray(String[][]::new);\n        }\n\n        return allowedAttributes;\n    }\n\n    private Attributes cleanAttributes(String elementName, Attributes attributes)\n    {\n        Attributes allowedAttribute;\n\n        if (this.htmlElementSanitizer == null || attributes == null) {\n            allowedAttribute = attributes;\n        } else {\n            allowedAttribute = new AttributesImpl();\n\n            for (int i = 0; i < attributes.getLength(); ++i) {\n                if (this.htmlElementSanitizer.isAttributeAllowed(elementName, attributes.getQName(i),\n                    attributes.getValue(i)))\n                {\n                    ((AttributesImpl) allowedAttribute).addAttribute(null, null, attributes.getQName(i),\n                        null, attributes.getValue(i));\n                } else {\n                    ((AttributesImpl) allowedAttribute).addAttribute(null, null,\n                        TRANSLATED_ATTRIBUTE_PREFIX + attributes.getQName(i), null, attributes.getValue(i));\n                }\n            }\n        }\n\n        return allowedAttribute;\n    }\n\n    private void handleSpaceWhenStartElement()\n    {\n        // Use case: <tag1>something <tag2>...\n        // Use case: <tag1>something <!--...\n        if (this.spaceCount > 0) {\n            if (!this.isInCData && !this.isInPreserveElement) {\n                // We print a single space as a normal space, except if we are at the beginning of a standalone element\n                // in that case we want a non-breaking space so it won't be stripped.\n                // Any supplementary space will be printed as non-breaking spaces so we keep them too.\n                if (this.isStandalone && !this.hasTextBeenPrinted) {\n                    printEntity(\"&nbsp;\");\n                } else {\n                    super.printXML(\" \");\n                }\n                for (int i = 0; i < this.spaceCount - 1; i++) {\n                    printEntity(\"&nbsp;\");\n                }\n            } else {\n                super.printXML(StringUtils.repeat(' ', this.spaceCount));\n            }\n            this.isStandalone = false;\n        }\n        this.spaceCount = 0;\n        this.elementEnded = false;\n        this.hasTextBeenPrinted = false;\n    }\n\n    private void handleSpaceWhenEndlement()\n    {\n        // Use case: <tag1>something </tag1>...\n        // All spaces are &nbsp; spaces since otherwise they'll be all stripped by browsers\n        if (!this.isInCData && !this.isInPreserveElement) {\n            for (int i = 0; i < this.spaceCount; i++) {\n                printEntity(\"&nbsp;\");\n            }\n        } else {\n            super.printXML(StringUtils.repeat(' ', this.spaceCount));\n        }\n        this.spaceCount = 0;\n        this.elementEnded = false;\n        this.hasTextBeenPrinted = false;\n    }\n}",
    "patch": "@@ -19,10 +19,15 @@\n  */\n package org.xwiki.rendering.renderer.printer;\n \n+import java.util.Arrays;\n+import java.util.LinkedHashMap;\n import java.util.Map;\n \n import org.apache.commons.lang3.StringUtils;\n import org.xml.sax.Attributes;\n+import org.xml.sax.helpers.AttributesImpl;\n+import org.xwiki.stability.Unstable;\n+import org.xwiki.xml.html.HTMLElementSanitizer;\n \n /**\n  * Base toolkit class for all XHTML-based renderers. This printer handles whitespaces so that it prints \"&nbsp;\" when\n@@ -34,6 +39,21 @@\n  */\n public class XHTMLWikiPrinter extends XMLWikiPrinter\n {\n+    /**\n+     * Prefix that is used for invalid/disallowed attributes.\n+     *\n+     * @since 14.6RC1\n+     */\n+    @Unstable\n+    public static final String TRANSLATED_ATTRIBUTE_PREFIX = \"data-xwiki-translated-attribute-\";\n+\n+    /**\n+     * The sanitizer used to restrict allowed elements and attributes, can be null (no restrictions).\n+     *\n+     * @since 14.6RC1\n+     */\n+    protected final HTMLElementSanitizer htmlElementSanitizer;\n+\n     private int spaceCount;\n \n     private boolean isInCData;\n@@ -50,15 +70,25 @@ public class XHTMLWikiPrinter extends XMLWikiPrinter\n      * @param printer the object to which to write the XHTML output to\n      */\n     public XHTMLWikiPrinter(WikiPrinter printer)\n+    {\n+        this(printer, null);\n+    }\n+\n+    /**\n+     * @param printer the object to which to write the XHTML output to\n+     * @param htmlElementSanitizer the sanitizer to use for sanitizing elements and attributes\n+     */\n+    public XHTMLWikiPrinter(WikiPrinter printer, HTMLElementSanitizer htmlElementSanitizer)\n     {\n         super(printer);\n+        this.htmlElementSanitizer = htmlElementSanitizer;\n     }\n \n     /**\n-     * Use it to specify that the current element to print is standalone.\n-     * This value might be used to know if the first space should be printed with a simple space or a {@code &nbsp;}\n-     * entity. Note that the standalone value is automatically reset after first printing of a space, or when a text\n-     * is printed.\n+     * Use it to specify that the current element to print is standalone. This value might be used to know if the first\n+     * space should be printed with a simple space or a {@code &nbsp;} entity. Note that the standalone value is\n+     * automatically reset after first printing of a space, or when a text is printed.\n+     *\n      * @since 12.2\n      */\n     public void setStandalone()\n@@ -78,58 +108,74 @@ public void printXML(String str)\n     @Override\n     public void printXMLElement(String name)\n     {\n-        handleSpaceWhenStartElement();\n-        super.printXMLElement(name);\n+        if (this.htmlElementSanitizer == null || this.htmlElementSanitizer.isElementAllowed(name)) {\n+            handleSpaceWhenStartElement();\n+            super.printXMLElement(name);\n+        }\n     }\n \n     @Override\n     public void printXMLElement(String name, String[][] attributes)\n     {\n-        handleSpaceWhenStartElement();\n-        super.printXMLElement(name, attributes);\n+        if (this.htmlElementSanitizer == null || this.htmlElementSanitizer.isElementAllowed(name)) {\n+            handleSpaceWhenStartElement();\n+            super.printXMLElement(name, cleanAttributes(name, attributes));\n+        }\n     }\n \n     @Override\n     public void printXMLElement(String name, Map<String, String> attributes)\n     {\n-        handleSpaceWhenStartElement();\n-        super.printXMLElement(name, attributes);\n+        if (this.htmlElementSanitizer == null || this.htmlElementSanitizer.isElementAllowed(name)) {\n+            handleSpaceWhenStartElement();\n+            super.printXMLElement(name, cleanAttributes(name, attributes));\n+        }\n     }\n \n     @Override\n     public void printXMLStartElement(String name)\n     {\n-        handleSpaceWhenStartElement();\n-        super.printXMLStartElement(name);\n+        if (this.htmlElementSanitizer == null || this.htmlElementSanitizer.isElementAllowed(name)) {\n+            handleSpaceWhenStartElement();\n+            super.printXMLStartElement(name);\n+        }\n     }\n \n     @Override\n     public void printXMLStartElement(String name, String[][] attributes)\n     {\n-        handleSpaceWhenStartElement();\n-        super.printXMLStartElement(name, attributes);\n+        if (this.htmlElementSanitizer == null || this.htmlElementSanitizer.isElementAllowed(name)) {\n+            handleSpaceWhenStartElement();\n+            super.printXMLStartElement(name, cleanAttributes(name, attributes));\n+        }\n     }\n \n     @Override\n     public void printXMLStartElement(String name, Map<String, String> attributes)\n     {\n-        handleSpaceWhenStartElement();\n-        super.printXMLStartElement(name, attributes);\n+        if (this.htmlElementSanitizer == null || this.htmlElementSanitizer.isElementAllowed(name)) {\n+            handleSpaceWhenStartElement();\n+            super.printXMLStartElement(name, cleanAttributes(name, attributes));\n+        }\n     }\n \n     @Override\n     public void printXMLStartElement(String name, Attributes attributes)\n     {\n-        handleSpaceWhenStartElement();\n-        super.printXMLStartElement(name, attributes);\n+        if (this.htmlElementSanitizer == null || this.htmlElementSanitizer.isElementAllowed(name)) {\n+            handleSpaceWhenStartElement();\n+            super.printXMLStartElement(name, cleanAttributes(name, attributes));\n+        }\n     }\n \n     @Override\n     public void printXMLEndElement(String name)\n     {\n-        handleSpaceWhenEndlement();\n-        super.printXMLEndElement(name);\n-        this.elementEnded = true;\n+        if (this.htmlElementSanitizer == null || this.htmlElementSanitizer.isElementAllowed(name)) {\n+            handleSpaceWhenEndlement();\n+            super.printXMLEndElement(name);\n+            this.elementEnded = true;\n+        }\n     }\n \n     @Override\n@@ -185,6 +231,71 @@ private void handleSpaceWhenInText()\n         }\n     }\n \n+    private Map<String, String> cleanAttributes(String elementName, Map<String, String> attributes)\n+    {\n+        Map<String, String> cleanAttributes;\n+\n+        if (this.htmlElementSanitizer == null || attributes == null) {\n+            cleanAttributes = attributes;\n+        } else {\n+            cleanAttributes = new LinkedHashMap<>();\n+            for (Map.Entry<String, String> e : attributes.entrySet()) {\n+                if (this.htmlElementSanitizer.isAttributeAllowed(elementName, e.getKey(), e.getValue())) {\n+                    cleanAttributes.put(e.getKey(), e.getValue());\n+                } else {\n+                    cleanAttributes.put(TRANSLATED_ATTRIBUTE_PREFIX + e.getKey(), e.getValue());\n+                }\n+            }\n+        }\n+\n+        return cleanAttributes;\n+    }\n+\n+    private String[][] cleanAttributes(String elementName, String[][] attributes)\n+    {\n+        String[][] allowedAttributes;\n+        if (this.htmlElementSanitizer == null || attributes == null) {\n+            allowedAttributes = attributes;\n+        } else {\n+            allowedAttributes = Arrays.stream(attributes)\n+                .map(entry -> {\n+                    if (this.htmlElementSanitizer.isAttributeAllowed(elementName, entry[0], entry[1])) {\n+                        return entry;\n+                    } else {\n+                        return new String[] { TRANSLATED_ATTRIBUTE_PREFIX + entry[0], entry[1] };\n+                    }\n+                })\n+                .toArray(String[][]::new);\n+        }\n+\n+        return allowedAttributes;\n+    }\n+\n+    private Attributes cleanAttributes(String elementName, Attributes attributes)\n+    {\n+        Attributes allowedAttribute;\n+\n+        if (this.htmlElementSanitizer == null || attributes == null) {\n+            allowedAttribute = attributes;\n+        } else {\n+            allowedAttribute = new AttributesImpl();\n+\n+            for (int i = 0; i < attributes.getLength(); ++i) {\n+                if (this.htmlElementSanitizer.isAttributeAllowed(elementName, attributes.getQName(i),\n+                    attributes.getValue(i)))\n+                {\n+                    ((AttributesImpl) allowedAttribute).addAttribute(null, null, attributes.getQName(i),\n+                        null, attributes.getValue(i));\n+                } else {\n+                    ((AttributesImpl) allowedAttribute).addAttribute(null, null,\n+                        TRANSLATED_ATTRIBUTE_PREFIX + attributes.getQName(i), null, attributes.getValue(i));\n+                }\n+            }\n+        }\n+\n+        return allowedAttribute;\n+    }\n+\n     private void handleSpaceWhenStartElement()\n     {\n         // Use case: <tag1>something <tag2>...",
    "function_modified_lines": {
      "added": [
        "    {\n",
        "        this(printer, null);\n",
        "    }\n",
        "\n",
        "    /**\n",
        "     * @param printer the object to which to write the XHTML output to\n",
        "     * @param htmlElementSanitizer the sanitizer to use for sanitizing elements and attributes\n",
        "     */\n",
        "    public XHTMLWikiPrinter(WikiPrinter printer, HTMLElementSanitizer htmlElementSanitizer)\n",
        "        this.htmlElementSanitizer = htmlElementSanitizer;\n",
        "     * Use it to specify that the current element to print is standalone. This value might be used to know if the first\n",
        "     * space should be printed with a simple space or a {@code &nbsp;} entity. Note that the standalone value is\n",
        "     * automatically reset after first printing of a space, or when a text is printed.\n",
        "     *\n"
      ],
      "deleted": [
        "     * Use it to specify that the current element to print is standalone.\n",
        "     * This value might be used to know if the first space should be printed with a simple space or a {@code &nbsp;}\n",
        "     * entity. Note that the standalone value is automatically reset after first printing of a space, or when a text\n",
        "     * is printed.\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-79"
    ],
    "cve_description": "XWiki Platform is a generic wiki platform. Prior to version 14.6-rc-1, HTML rendering didn't check for dangerous attributes/attribute values. This allowed cross-site scripting (XSS) attacks via attributes and link URLs, e.g., supported in XWiki syntax. This has been patched in XWiki 14.6-rc-1. There are no known workarounds apart from upgrading to a fixed version.",
    "id": 12708
  },
  {
    "cve_id": "CVE-2023-32070",
    "code_before_change": "{\n    private int spaceCount;\n\n    private boolean isInCData;\n\n    private boolean isInPreserveElement;\n\n    private boolean elementEnded;\n\n    private boolean hasTextBeenPrinted;\n\n    private boolean isStandalone;\n\n    /**\n     * @param printer the object to which to write the XHTML output to\n     */\n    public XHTMLWikiPrinter(WikiPrinter printer)\n    {\n        super(printer);\n    }\n\n    /**\n     * Use it to specify that the current element to print is standalone.\n     * This value might be used to know if the first space should be printed with a simple space or a {@code &nbsp;}\n     * entity. Note that the standalone value is automatically reset after first printing of a space, or when a text\n     * is printed.\n     * @since 12.2\n     */\n    public void setStandalone()\n    {\n        this.isStandalone = true;\n    }\n\n    @Override\n    public void printXML(String str)\n    {\n        handleSpaceWhenInText();\n        super.printXML(str);\n        this.hasTextBeenPrinted = true;\n        this.isStandalone = false;\n    }\n\n    @Override\n    public void printXMLElement(String name)\n    {\n        handleSpaceWhenStartElement();\n        super.printXMLElement(name);\n    }\n\n    @Override\n    public void printXMLElement(String name, String[][] attributes)\n    {\n        handleSpaceWhenStartElement();\n        super.printXMLElement(name, attributes);\n    }\n\n    @Override\n    public void printXMLElement(String name, Map<String, String> attributes)\n    {\n        handleSpaceWhenStartElement();\n        super.printXMLElement(name, attributes);\n    }\n\n    @Override\n    public void printXMLStartElement(String name)\n    {\n        handleSpaceWhenStartElement();\n        super.printXMLStartElement(name);\n    }\n\n    @Override\n    public void printXMLStartElement(String name, String[][] attributes)\n    {\n        handleSpaceWhenStartElement();\n        super.printXMLStartElement(name, attributes);\n    }\n\n    @Override\n    public void printXMLStartElement(String name, Map<String, String> attributes)\n    {\n        handleSpaceWhenStartElement();\n        super.printXMLStartElement(name, attributes);\n    }\n\n    @Override\n    public void printXMLStartElement(String name, Attributes attributes)\n    {\n        handleSpaceWhenStartElement();\n        super.printXMLStartElement(name, attributes);\n    }\n\n    @Override\n    public void printXMLEndElement(String name)\n    {\n        handleSpaceWhenEndlement();\n        super.printXMLEndElement(name);\n        this.elementEnded = true;\n    }\n\n    @Override\n    public void printXMLComment(String content)\n    {\n        printXMLComment(content, false);\n    }\n\n    @Override\n    public void printXMLComment(String content, boolean escape)\n    {\n        handleSpaceWhenStartElement();\n        super.printXMLComment(content, escape);\n        this.elementEnded = true;\n    }\n\n    @Override\n    public void printXMLStartCData()\n    {\n        handleSpaceWhenStartElement();\n        super.printXMLStartCData();\n    }\n\n    @Override\n    public void printXMLEndCData()\n    {\n        handleSpaceWhenEndlement();\n        super.printXMLEndCData();\n    }\n\n    /**\n     * This method should be used to print a space rather than calling <code>printXML(\" \")</code>.\n     */\n    public void printSpace()\n    {\n        this.spaceCount++;\n    }\n\n    @Override\n    public void printRaw(String raw)\n    {\n        handleSpaceWhenStartElement();\n        super.printRaw(raw);\n        this.elementEnded = true;\n    }\n\n    private void handleSpaceWhenInText()\n    {\n        if (this.elementEnded || this.hasTextBeenPrinted) {\n            handleSpaceWhenStartElement();\n        } else {\n            handleSpaceWhenEndlement();\n        }\n    }\n\n    private void handleSpaceWhenStartElement()\n    {\n        // Use case: <tag1>something <tag2>...\n        // Use case: <tag1>something <!--...\n        if (this.spaceCount > 0) {\n            if (!this.isInCData && !this.isInPreserveElement) {\n                // We print a single space as a normal space, except if we are at the beginning of a standalone element\n                // in that case we want a non-breaking space so it won't be stripped.\n                // Any supplementary space will be printed as non-breaking spaces so we keep them too.\n                if (this.isStandalone && !this.hasTextBeenPrinted) {\n                    printEntity(\"&nbsp;\");\n                } else {\n                    super.printXML(\" \");\n                }\n                for (int i = 0; i < this.spaceCount - 1; i++) {\n                    printEntity(\"&nbsp;\");\n                }\n            } else {\n                super.printXML(StringUtils.repeat(' ', this.spaceCount));\n            }\n            this.isStandalone = false;\n        }\n        this.spaceCount = 0;\n        this.elementEnded = false;\n        this.hasTextBeenPrinted = false;\n    }\n\n    private void handleSpaceWhenEndlement()\n    {\n        // Use case: <tag1>something </tag1>...\n        // All spaces are &nbsp; spaces since otherwise they'll be all stripped by browsers\n        if (!this.isInCData && !this.isInPreserveElement) {\n            for (int i = 0; i < this.spaceCount; i++) {\n                printEntity(\"&nbsp;\");\n            }\n        } else {\n            super.printXML(StringUtils.repeat(' ', this.spaceCount));\n        }\n        this.spaceCount = 0;\n        this.elementEnded = false;\n        this.hasTextBeenPrinted = false;\n    }\n}",
    "code_after_change": "{\n    /**\n     * Prefix that is used for invalid/disallowed attributes.\n     *\n     * @since 14.6RC1\n     */\n    @Unstable\n    public static final String TRANSLATED_ATTRIBUTE_PREFIX = \"data-xwiki-translated-attribute-\";\n\n    /**\n     * The sanitizer used to restrict allowed elements and attributes, can be null (no restrictions).\n     *\n     * @since 14.6RC1\n     */\n    protected final HTMLElementSanitizer htmlElementSanitizer;\n\n    private int spaceCount;\n\n    private boolean isInCData;\n\n    private boolean isInPreserveElement;\n\n    private boolean elementEnded;\n\n    private boolean hasTextBeenPrinted;\n\n    private boolean isStandalone;\n\n    /**\n     * @param printer the object to which to write the XHTML output to\n     */\n    public XHTMLWikiPrinter(WikiPrinter printer)\n    {\n        this(printer, null);\n    }\n\n    /**\n     * @param printer the object to which to write the XHTML output to\n     * @param htmlElementSanitizer the sanitizer to use for sanitizing elements and attributes\n     */\n    public XHTMLWikiPrinter(WikiPrinter printer, HTMLElementSanitizer htmlElementSanitizer)\n    {\n        super(printer);\n        this.htmlElementSanitizer = htmlElementSanitizer;\n    }\n\n    /**\n     * Use it to specify that the current element to print is standalone. This value might be used to know if the first\n     * space should be printed with a simple space or a {@code &nbsp;} entity. Note that the standalone value is\n     * automatically reset after first printing of a space, or when a text is printed.\n     *\n     * @since 12.2\n     */\n    public void setStandalone()\n    {\n        this.isStandalone = true;\n    }\n\n    @Override\n    public void printXML(String str)\n    {\n        handleSpaceWhenInText();\n        super.printXML(str);\n        this.hasTextBeenPrinted = true;\n        this.isStandalone = false;\n    }\n\n    @Override\n    public void printXMLElement(String name)\n    {\n        if (this.htmlElementSanitizer == null || this.htmlElementSanitizer.isElementAllowed(name)) {\n            handleSpaceWhenStartElement();\n            super.printXMLElement(name);\n        }\n    }\n\n    @Override\n    public void printXMLElement(String name, String[][] attributes)\n    {\n        if (this.htmlElementSanitizer == null || this.htmlElementSanitizer.isElementAllowed(name)) {\n            handleSpaceWhenStartElement();\n            super.printXMLElement(name, cleanAttributes(name, attributes));\n        }\n    }\n\n    @Override\n    public void printXMLElement(String name, Map<String, String> attributes)\n    {\n        if (this.htmlElementSanitizer == null || this.htmlElementSanitizer.isElementAllowed(name)) {\n            handleSpaceWhenStartElement();\n            super.printXMLElement(name, cleanAttributes(name, attributes));\n        }\n    }\n\n    @Override\n    public void printXMLStartElement(String name)\n    {\n        if (this.htmlElementSanitizer == null || this.htmlElementSanitizer.isElementAllowed(name)) {\n            handleSpaceWhenStartElement();\n            super.printXMLStartElement(name);\n        }\n    }\n\n    @Override\n    public void printXMLStartElement(String name, String[][] attributes)\n    {\n        if (this.htmlElementSanitizer == null || this.htmlElementSanitizer.isElementAllowed(name)) {\n            handleSpaceWhenStartElement();\n            super.printXMLStartElement(name, cleanAttributes(name, attributes));\n        }\n    }\n\n    @Override\n    public void printXMLStartElement(String name, Map<String, String> attributes)\n    {\n        if (this.htmlElementSanitizer == null || this.htmlElementSanitizer.isElementAllowed(name)) {\n            handleSpaceWhenStartElement();\n            super.printXMLStartElement(name, cleanAttributes(name, attributes));\n        }\n    }\n\n    @Override\n    public void printXMLStartElement(String name, Attributes attributes)\n    {\n        if (this.htmlElementSanitizer == null || this.htmlElementSanitizer.isElementAllowed(name)) {\n            handleSpaceWhenStartElement();\n            super.printXMLStartElement(name, cleanAttributes(name, attributes));\n        }\n    }\n\n    @Override\n    public void printXMLEndElement(String name)\n    {\n        if (this.htmlElementSanitizer == null || this.htmlElementSanitizer.isElementAllowed(name)) {\n            handleSpaceWhenEndlement();\n            super.printXMLEndElement(name);\n            this.elementEnded = true;\n        }\n    }\n\n    @Override\n    public void printXMLComment(String content)\n    {\n        printXMLComment(content, false);\n    }\n\n    @Override\n    public void printXMLComment(String content, boolean escape)\n    {\n        handleSpaceWhenStartElement();\n        super.printXMLComment(content, escape);\n        this.elementEnded = true;\n    }\n\n    @Override\n    public void printXMLStartCData()\n    {\n        handleSpaceWhenStartElement();\n        super.printXMLStartCData();\n    }\n\n    @Override\n    public void printXMLEndCData()\n    {\n        handleSpaceWhenEndlement();\n        super.printXMLEndCData();\n    }\n\n    /**\n     * This method should be used to print a space rather than calling <code>printXML(\" \")</code>.\n     */\n    public void printSpace()\n    {\n        this.spaceCount++;\n    }\n\n    @Override\n    public void printRaw(String raw)\n    {\n        handleSpaceWhenStartElement();\n        super.printRaw(raw);\n        this.elementEnded = true;\n    }\n\n    private void handleSpaceWhenInText()\n    {\n        if (this.elementEnded || this.hasTextBeenPrinted) {\n            handleSpaceWhenStartElement();\n        } else {\n            handleSpaceWhenEndlement();\n        }\n    }\n\n    private Map<String, String> cleanAttributes(String elementName, Map<String, String> attributes)\n    {\n        Map<String, String> cleanAttributes;\n\n        if (this.htmlElementSanitizer == null || attributes == null) {\n            cleanAttributes = attributes;\n        } else {\n            cleanAttributes = new LinkedHashMap<>();\n            for (Map.Entry<String, String> e : attributes.entrySet()) {\n                if (this.htmlElementSanitizer.isAttributeAllowed(elementName, e.getKey(), e.getValue())) {\n                    cleanAttributes.put(e.getKey(), e.getValue());\n                } else {\n                    cleanAttributes.put(TRANSLATED_ATTRIBUTE_PREFIX + e.getKey(), e.getValue());\n                }\n            }\n        }\n\n        return cleanAttributes;\n    }\n\n    private String[][] cleanAttributes(String elementName, String[][] attributes)\n    {\n        String[][] allowedAttributes;\n        if (this.htmlElementSanitizer == null || attributes == null) {\n            allowedAttributes = attributes;\n        } else {\n            allowedAttributes = Arrays.stream(attributes)\n                .map(entry -> {\n                    if (this.htmlElementSanitizer.isAttributeAllowed(elementName, entry[0], entry[1])) {\n                        return entry;\n                    } else {\n                        return new String[] { TRANSLATED_ATTRIBUTE_PREFIX + entry[0], entry[1] };\n                    }\n                })\n                .toArray(String[][]::new);\n        }\n\n        return allowedAttributes;\n    }\n\n    private Attributes cleanAttributes(String elementName, Attributes attributes)\n    {\n        Attributes allowedAttribute;\n\n        if (this.htmlElementSanitizer == null || attributes == null) {\n            allowedAttribute = attributes;\n        } else {\n            allowedAttribute = new AttributesImpl();\n\n            for (int i = 0; i < attributes.getLength(); ++i) {\n                if (this.htmlElementSanitizer.isAttributeAllowed(elementName, attributes.getQName(i),\n                    attributes.getValue(i)))\n                {\n                    ((AttributesImpl) allowedAttribute).addAttribute(null, null, attributes.getQName(i),\n                        null, attributes.getValue(i));\n                } else {\n                    ((AttributesImpl) allowedAttribute).addAttribute(null, null,\n                        TRANSLATED_ATTRIBUTE_PREFIX + attributes.getQName(i), null, attributes.getValue(i));\n                }\n            }\n        }\n\n        return allowedAttribute;\n    }\n\n    private void handleSpaceWhenStartElement()\n    {\n        // Use case: <tag1>something <tag2>...\n        // Use case: <tag1>something <!--...\n        if (this.spaceCount > 0) {\n            if (!this.isInCData && !this.isInPreserveElement) {\n                // We print a single space as a normal space, except if we are at the beginning of a standalone element\n                // in that case we want a non-breaking space so it won't be stripped.\n                // Any supplementary space will be printed as non-breaking spaces so we keep them too.\n                if (this.isStandalone && !this.hasTextBeenPrinted) {\n                    printEntity(\"&nbsp;\");\n                } else {\n                    super.printXML(\" \");\n                }\n                for (int i = 0; i < this.spaceCount - 1; i++) {\n                    printEntity(\"&nbsp;\");\n                }\n            } else {\n                super.printXML(StringUtils.repeat(' ', this.spaceCount));\n            }\n            this.isStandalone = false;\n        }\n        this.spaceCount = 0;\n        this.elementEnded = false;\n        this.hasTextBeenPrinted = false;\n    }\n\n    private void handleSpaceWhenEndlement()\n    {\n        // Use case: <tag1>something </tag1>...\n        // All spaces are &nbsp; spaces since otherwise they'll be all stripped by browsers\n        if (!this.isInCData && !this.isInPreserveElement) {\n            for (int i = 0; i < this.spaceCount; i++) {\n                printEntity(\"&nbsp;\");\n            }\n        } else {\n            super.printXML(StringUtils.repeat(' ', this.spaceCount));\n        }\n        this.spaceCount = 0;\n        this.elementEnded = false;\n        this.hasTextBeenPrinted = false;\n    }\n}",
    "patch": "@@ -19,10 +19,15 @@\n  */\n package org.xwiki.rendering.renderer.printer;\n \n+import java.util.Arrays;\n+import java.util.LinkedHashMap;\n import java.util.Map;\n \n import org.apache.commons.lang3.StringUtils;\n import org.xml.sax.Attributes;\n+import org.xml.sax.helpers.AttributesImpl;\n+import org.xwiki.stability.Unstable;\n+import org.xwiki.xml.html.HTMLElementSanitizer;\n \n /**\n  * Base toolkit class for all XHTML-based renderers. This printer handles whitespaces so that it prints \"&nbsp;\" when\n@@ -34,6 +39,21 @@\n  */\n public class XHTMLWikiPrinter extends XMLWikiPrinter\n {\n+    /**\n+     * Prefix that is used for invalid/disallowed attributes.\n+     *\n+     * @since 14.6RC1\n+     */\n+    @Unstable\n+    public static final String TRANSLATED_ATTRIBUTE_PREFIX = \"data-xwiki-translated-attribute-\";\n+\n+    /**\n+     * The sanitizer used to restrict allowed elements and attributes, can be null (no restrictions).\n+     *\n+     * @since 14.6RC1\n+     */\n+    protected final HTMLElementSanitizer htmlElementSanitizer;\n+\n     private int spaceCount;\n \n     private boolean isInCData;\n@@ -50,15 +70,25 @@ public class XHTMLWikiPrinter extends XMLWikiPrinter\n      * @param printer the object to which to write the XHTML output to\n      */\n     public XHTMLWikiPrinter(WikiPrinter printer)\n+    {\n+        this(printer, null);\n+    }\n+\n+    /**\n+     * @param printer the object to which to write the XHTML output to\n+     * @param htmlElementSanitizer the sanitizer to use for sanitizing elements and attributes\n+     */\n+    public XHTMLWikiPrinter(WikiPrinter printer, HTMLElementSanitizer htmlElementSanitizer)\n     {\n         super(printer);\n+        this.htmlElementSanitizer = htmlElementSanitizer;\n     }\n \n     /**\n-     * Use it to specify that the current element to print is standalone.\n-     * This value might be used to know if the first space should be printed with a simple space or a {@code &nbsp;}\n-     * entity. Note that the standalone value is automatically reset after first printing of a space, or when a text\n-     * is printed.\n+     * Use it to specify that the current element to print is standalone. This value might be used to know if the first\n+     * space should be printed with a simple space or a {@code &nbsp;} entity. Note that the standalone value is\n+     * automatically reset after first printing of a space, or when a text is printed.\n+     *\n      * @since 12.2\n      */\n     public void setStandalone()\n@@ -78,58 +108,74 @@ public void printXML(String str)\n     @Override\n     public void printXMLElement(String name)\n     {\n-        handleSpaceWhenStartElement();\n-        super.printXMLElement(name);\n+        if (this.htmlElementSanitizer == null || this.htmlElementSanitizer.isElementAllowed(name)) {\n+            handleSpaceWhenStartElement();\n+            super.printXMLElement(name);\n+        }\n     }\n \n     @Override\n     public void printXMLElement(String name, String[][] attributes)\n     {\n-        handleSpaceWhenStartElement();\n-        super.printXMLElement(name, attributes);\n+        if (this.htmlElementSanitizer == null || this.htmlElementSanitizer.isElementAllowed(name)) {\n+            handleSpaceWhenStartElement();\n+            super.printXMLElement(name, cleanAttributes(name, attributes));\n+        }\n     }\n \n     @Override\n     public void printXMLElement(String name, Map<String, String> attributes)\n     {\n-        handleSpaceWhenStartElement();\n-        super.printXMLElement(name, attributes);\n+        if (this.htmlElementSanitizer == null || this.htmlElementSanitizer.isElementAllowed(name)) {\n+            handleSpaceWhenStartElement();\n+            super.printXMLElement(name, cleanAttributes(name, attributes));\n+        }\n     }\n \n     @Override\n     public void printXMLStartElement(String name)\n     {\n-        handleSpaceWhenStartElement();\n-        super.printXMLStartElement(name);\n+        if (this.htmlElementSanitizer == null || this.htmlElementSanitizer.isElementAllowed(name)) {\n+            handleSpaceWhenStartElement();\n+            super.printXMLStartElement(name);\n+        }\n     }\n \n     @Override\n     public void printXMLStartElement(String name, String[][] attributes)\n     {\n-        handleSpaceWhenStartElement();\n-        super.printXMLStartElement(name, attributes);\n+        if (this.htmlElementSanitizer == null || this.htmlElementSanitizer.isElementAllowed(name)) {\n+            handleSpaceWhenStartElement();\n+            super.printXMLStartElement(name, cleanAttributes(name, attributes));\n+        }\n     }\n \n     @Override\n     public void printXMLStartElement(String name, Map<String, String> attributes)\n     {\n-        handleSpaceWhenStartElement();\n-        super.printXMLStartElement(name, attributes);\n+        if (this.htmlElementSanitizer == null || this.htmlElementSanitizer.isElementAllowed(name)) {\n+            handleSpaceWhenStartElement();\n+            super.printXMLStartElement(name, cleanAttributes(name, attributes));\n+        }\n     }\n \n     @Override\n     public void printXMLStartElement(String name, Attributes attributes)\n     {\n-        handleSpaceWhenStartElement();\n-        super.printXMLStartElement(name, attributes);\n+        if (this.htmlElementSanitizer == null || this.htmlElementSanitizer.isElementAllowed(name)) {\n+            handleSpaceWhenStartElement();\n+            super.printXMLStartElement(name, cleanAttributes(name, attributes));\n+        }\n     }\n \n     @Override\n     public void printXMLEndElement(String name)\n     {\n-        handleSpaceWhenEndlement();\n-        super.printXMLEndElement(name);\n-        this.elementEnded = true;\n+        if (this.htmlElementSanitizer == null || this.htmlElementSanitizer.isElementAllowed(name)) {\n+            handleSpaceWhenEndlement();\n+            super.printXMLEndElement(name);\n+            this.elementEnded = true;\n+        }\n     }\n \n     @Override\n@@ -185,6 +231,71 @@ private void handleSpaceWhenInText()\n         }\n     }\n \n+    private Map<String, String> cleanAttributes(String elementName, Map<String, String> attributes)\n+    {\n+        Map<String, String> cleanAttributes;\n+\n+        if (this.htmlElementSanitizer == null || attributes == null) {\n+            cleanAttributes = attributes;\n+        } else {\n+            cleanAttributes = new LinkedHashMap<>();\n+            for (Map.Entry<String, String> e : attributes.entrySet()) {\n+                if (this.htmlElementSanitizer.isAttributeAllowed(elementName, e.getKey(), e.getValue())) {\n+                    cleanAttributes.put(e.getKey(), e.getValue());\n+                } else {\n+                    cleanAttributes.put(TRANSLATED_ATTRIBUTE_PREFIX + e.getKey(), e.getValue());\n+                }\n+            }\n+        }\n+\n+        return cleanAttributes;\n+    }\n+\n+    private String[][] cleanAttributes(String elementName, String[][] attributes)\n+    {\n+        String[][] allowedAttributes;\n+        if (this.htmlElementSanitizer == null || attributes == null) {\n+            allowedAttributes = attributes;\n+        } else {\n+            allowedAttributes = Arrays.stream(attributes)\n+                .map(entry -> {\n+                    if (this.htmlElementSanitizer.isAttributeAllowed(elementName, entry[0], entry[1])) {\n+                        return entry;\n+                    } else {\n+                        return new String[] { TRANSLATED_ATTRIBUTE_PREFIX + entry[0], entry[1] };\n+                    }\n+                })\n+                .toArray(String[][]::new);\n+        }\n+\n+        return allowedAttributes;\n+    }\n+\n+    private Attributes cleanAttributes(String elementName, Attributes attributes)\n+    {\n+        Attributes allowedAttribute;\n+\n+        if (this.htmlElementSanitizer == null || attributes == null) {\n+            allowedAttribute = attributes;\n+        } else {\n+            allowedAttribute = new AttributesImpl();\n+\n+            for (int i = 0; i < attributes.getLength(); ++i) {\n+                if (this.htmlElementSanitizer.isAttributeAllowed(elementName, attributes.getQName(i),\n+                    attributes.getValue(i)))\n+                {\n+                    ((AttributesImpl) allowedAttribute).addAttribute(null, null, attributes.getQName(i),\n+                        null, attributes.getValue(i));\n+                } else {\n+                    ((AttributesImpl) allowedAttribute).addAttribute(null, null,\n+                        TRANSLATED_ATTRIBUTE_PREFIX + attributes.getQName(i), null, attributes.getValue(i));\n+                }\n+            }\n+        }\n+\n+        return allowedAttribute;\n+    }\n+\n     private void handleSpaceWhenStartElement()\n     {\n         // Use case: <tag1>something <tag2>...",
    "function_modified_lines": {
      "added": [
        "        if (this.htmlElementSanitizer == null || this.htmlElementSanitizer.isElementAllowed(name)) {\n",
        "            handleSpaceWhenStartElement();\n",
        "            super.printXMLElement(name);\n",
        "        }\n",
        "        if (this.htmlElementSanitizer == null || this.htmlElementSanitizer.isElementAllowed(name)) {\n",
        "            handleSpaceWhenStartElement();\n",
        "            super.printXMLElement(name, cleanAttributes(name, attributes));\n",
        "        }\n",
        "        if (this.htmlElementSanitizer == null || this.htmlElementSanitizer.isElementAllowed(name)) {\n",
        "            handleSpaceWhenStartElement();\n",
        "            super.printXMLElement(name, cleanAttributes(name, attributes));\n",
        "        }\n",
        "        if (this.htmlElementSanitizer == null || this.htmlElementSanitizer.isElementAllowed(name)) {\n",
        "            handleSpaceWhenStartElement();\n",
        "            super.printXMLStartElement(name);\n",
        "        }\n",
        "        if (this.htmlElementSanitizer == null || this.htmlElementSanitizer.isElementAllowed(name)) {\n",
        "            handleSpaceWhenStartElement();\n",
        "            super.printXMLStartElement(name, cleanAttributes(name, attributes));\n",
        "        }\n",
        "        if (this.htmlElementSanitizer == null || this.htmlElementSanitizer.isElementAllowed(name)) {\n",
        "            handleSpaceWhenStartElement();\n",
        "            super.printXMLStartElement(name, cleanAttributes(name, attributes));\n",
        "        }\n",
        "        if (this.htmlElementSanitizer == null || this.htmlElementSanitizer.isElementAllowed(name)) {\n",
        "            handleSpaceWhenStartElement();\n",
        "            super.printXMLStartElement(name, cleanAttributes(name, attributes));\n",
        "        }\n",
        "        if (this.htmlElementSanitizer == null || this.htmlElementSanitizer.isElementAllowed(name)) {\n",
        "            handleSpaceWhenEndlement();\n",
        "            super.printXMLEndElement(name);\n",
        "            this.elementEnded = true;\n",
        "        }\n"
      ],
      "deleted": [
        "        handleSpaceWhenStartElement();\n",
        "        super.printXMLElement(name);\n",
        "        handleSpaceWhenStartElement();\n",
        "        super.printXMLElement(name, attributes);\n",
        "        handleSpaceWhenStartElement();\n",
        "        super.printXMLElement(name, attributes);\n",
        "        handleSpaceWhenStartElement();\n",
        "        super.printXMLStartElement(name);\n",
        "        handleSpaceWhenStartElement();\n",
        "        super.printXMLStartElement(name, attributes);\n",
        "        handleSpaceWhenStartElement();\n",
        "        super.printXMLStartElement(name, attributes);\n",
        "        handleSpaceWhenStartElement();\n",
        "        super.printXMLStartElement(name, attributes);\n",
        "        handleSpaceWhenEndlement();\n",
        "        super.printXMLEndElement(name);\n",
        "        this.elementEnded = true;\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-79"
    ],
    "cve_description": "XWiki Platform is a generic wiki platform. Prior to version 14.6-rc-1, HTML rendering didn't check for dangerous attributes/attribute values. This allowed cross-site scripting (XSS) attacks via attributes and link URLs, e.g., supported in XWiki syntax. This has been patched in XWiki 14.6-rc-1. There are no known workarounds apart from upgrading to a fixed version.",
    "id": 12709
  },
  {
    "cve_id": "CVE-2023-37908",
    "code_before_change": "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.rendering.renderer.printer;\n\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.CsvSource;\n\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.verify;\n\n/**\n * Unit tests for {@link XHTMLWikiPrinter}.\n *\n * @version $Id$\n */\nclass XHTMLWikiPrinterTest\n{\n    @ParameterizedTest\n    @CsvSource({\n        \"Closing the {{/html}} macro., Closing the &#123;&#123;/html}} macro.\",\n        \"Starting a macro {, Starting a macro &#123;\",\n        \"Partial: {{/h, Partial: {&#123;/h\",\n        \"{{html}}, {{html}}\"\n    })\n    void testRawEscaping(String input, String expected)\n    {\n        WikiPrinter mockPrinter = mock(WikiPrinter.class);\n        XHTMLWikiPrinter xhtmlWikiPrinter = new XHTMLWikiPrinter(mockPrinter);\n        xhtmlWikiPrinter.printRaw(input);\n        verify(mockPrinter).print(expected);\n    }\n}\n",
    "code_after_change": "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.rendering.renderer.printer;\n\nimport java.util.Map;\n\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.CsvSource;\nimport org.mockito.InOrder;\nimport org.mockito.Mockito;\nimport org.xml.sax.helpers.AttributesImpl;\nimport org.xwiki.xml.html.HTMLElementSanitizer;\n\nimport static org.mockito.ArgumentMatchers.anyString;\nimport static org.mockito.Mockito.atLeast;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.verifyNoMoreInteractions;\nimport static org.mockito.Mockito.when;\n\n/**\n * Unit tests for {@link XHTMLWikiPrinter}.\n *\n * @version $Id$\n */\nclass XHTMLWikiPrinterTest\n{\n    @ParameterizedTest\n    @CsvSource({\n        \"Closing the {{/html}} macro., Closing the &#123;&#123;/html}} macro.\",\n        \"Starting a macro {, Starting a macro &#123;\",\n        \"Partial: {{/h, Partial: {&#123;/h\",\n        \"{{html}}, {{html}}\"\n    })\n    void testRawEscaping(String input, String expected)\n    {\n        WikiPrinter mockPrinter = mock(WikiPrinter.class);\n        XHTMLWikiPrinter xhtmlWikiPrinter = new XHTMLWikiPrinter(mockPrinter);\n        xhtmlWikiPrinter.printRaw(input);\n        verify(mockPrinter).print(expected);\n    }\n\n    @ParameterizedTest\n    @CsvSource({\n        \"invalid, value, data-xwiki-translated-attribute-invalid, value\",\n        \"valid, test&, valid, test&amp;\",\n        \"in/valid, value, data-xwiki-translated-attribute-invalid, value\"\n    })\n    void testParameterCleaning(String parameterName, String parameterValue, String expectedName, String expectedValue)\n    {\n        HTMLElementSanitizer mockSanitizer = mock(HTMLElementSanitizer.class);\n        when(mockSanitizer.isElementAllowed(anyString())).thenReturn(true);\n        when(mockSanitizer.isAttributeAllowed(anyString(), anyString(), anyString())).then(invocation ->\n        {\n            String attributeName = invocation.getArgument(1, String.class);\n            return \"valid\".equals(attributeName) || attributeName.startsWith(\"data-\");\n        });\n\n        // Test all possibilities of invoking the printer (with different kinds of arguments).\n        WikiPrinter mockPrinter = mock(WikiPrinter.class);\n        XHTMLWikiPrinter xhtmlWikiPrinter = new XHTMLWikiPrinter(mockPrinter, mockSanitizer);\n        Map<String, String> mapParameters = Map.of(parameterName, parameterValue);\n        xhtmlWikiPrinter.printXMLStartElement(\"div\", mapParameters);\n        verify(mockSanitizer, atLeast(1)).isElementAllowed(\"div\");\n        verify(mockSanitizer, atLeast(1)).isAttributeAllowed(\"div\", parameterName, parameterValue);\n        verify(mockSanitizer, atLeast(1)).isAttributeAllowed(\"div\", expectedName, parameterValue);\n        verifyPrinting(mockPrinter, expectedName, expectedValue, true);\n\n        mockPrinter = mock(WikiPrinter.class);\n        xhtmlWikiPrinter = new XHTMLWikiPrinter(mockPrinter, mockSanitizer);\n        xhtmlWikiPrinter.printXMLElement(\"div\", mapParameters);\n        verifyPrinting(mockPrinter, expectedName, expectedValue, false);\n\n        mockPrinter = mock(WikiPrinter.class);\n        xhtmlWikiPrinter = new XHTMLWikiPrinter(mockPrinter, mockSanitizer);\n        String[][] arrayParameters = { { parameterName, parameterValue } };\n        xhtmlWikiPrinter.printXMLStartElement(\"div\", arrayParameters);\n        verifyPrinting(mockPrinter, expectedName, expectedValue, true);\n\n        mockPrinter = mock(WikiPrinter.class);\n        xhtmlWikiPrinter = new XHTMLWikiPrinter(mockPrinter, mockSanitizer);\n        xhtmlWikiPrinter.printXMLElement(\"div\", arrayParameters);\n        verifyPrinting(mockPrinter, expectedName, expectedValue, false);\n\n        mockPrinter = mock(WikiPrinter.class);\n        xhtmlWikiPrinter = new XHTMLWikiPrinter(mockPrinter, mockSanitizer);\n        AttributesImpl attributes = new AttributesImpl();\n        attributes.addAttribute(null, null, parameterName, null, parameterValue);\n        xhtmlWikiPrinter.printXMLStartElement(\"div\", attributes);\n        verifyPrinting(mockPrinter, expectedName, expectedValue, true);\n    }\n\n    private void verifyPrinting(WikiPrinter mockPrinter, String attributeName,\n        String attributeValue, boolean isStart)\n    {\n        InOrder inOrder = Mockito.inOrder(mockPrinter);\n        inOrder.verify(mockPrinter).print(\"<\");\n        inOrder.verify(mockPrinter).print(\"div\");\n        inOrder.verify(mockPrinter).print(\" \");\n        inOrder.verify(mockPrinter).print(attributeName);\n        inOrder.verify(mockPrinter).print(\"=\");\n        inOrder.verify(mockPrinter).print(\"\\\"\");\n        inOrder.verify(mockPrinter).print(attributeValue);\n        inOrder.verify(mockPrinter).print(\"\\\"\");\n        if (isStart) {\n            inOrder.verify(mockPrinter).print(\">\");\n        } else {\n            inOrder.verify(mockPrinter).print(\"/>\");\n        }\n        verifyNoMoreInteractions(mockPrinter);\n\n    }\n}\n",
    "patch": "@@ -19,11 +19,21 @@\n  */\n package org.xwiki.rendering.renderer.printer;\n \n+import java.util.Map;\n+\n import org.junit.jupiter.params.ParameterizedTest;\n import org.junit.jupiter.params.provider.CsvSource;\n+import org.mockito.InOrder;\n+import org.mockito.Mockito;\n+import org.xml.sax.helpers.AttributesImpl;\n+import org.xwiki.xml.html.HTMLElementSanitizer;\n \n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.atLeast;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.when;\n \n /**\n  * Unit tests for {@link XHTMLWikiPrinter}.\n@@ -46,4 +56,75 @@ void testRawEscaping(String input, String expected)\n         xhtmlWikiPrinter.printRaw(input);\n         verify(mockPrinter).print(expected);\n     }\n+\n+    @ParameterizedTest\n+    @CsvSource({\n+        \"invalid, value, data-xwiki-translated-attribute-invalid, value\",\n+        \"valid, test&, valid, test&amp;\",\n+        \"in/valid, value, data-xwiki-translated-attribute-invalid, value\"\n+    })\n+    void testParameterCleaning(String parameterName, String parameterValue, String expectedName, String expectedValue)\n+    {\n+        HTMLElementSanitizer mockSanitizer = mock(HTMLElementSanitizer.class);\n+        when(mockSanitizer.isElementAllowed(anyString())).thenReturn(true);\n+        when(mockSanitizer.isAttributeAllowed(anyString(), anyString(), anyString())).then(invocation ->\n+        {\n+            String attributeName = invocation.getArgument(1, String.class);\n+            return \"valid\".equals(attributeName) || attributeName.startsWith(\"data-\");\n+        });\n+\n+        // Test all possibilities of invoking the printer (with different kinds of arguments).\n+        WikiPrinter mockPrinter = mock(WikiPrinter.class);\n+        XHTMLWikiPrinter xhtmlWikiPrinter = new XHTMLWikiPrinter(mockPrinter, mockSanitizer);\n+        Map<String, String> mapParameters = Map.of(parameterName, parameterValue);\n+        xhtmlWikiPrinter.printXMLStartElement(\"div\", mapParameters);\n+        verify(mockSanitizer, atLeast(1)).isElementAllowed(\"div\");\n+        verify(mockSanitizer, atLeast(1)).isAttributeAllowed(\"div\", parameterName, parameterValue);\n+        verify(mockSanitizer, atLeast(1)).isAttributeAllowed(\"div\", expectedName, parameterValue);\n+        verifyPrinting(mockPrinter, expectedName, expectedValue, true);\n+\n+        mockPrinter = mock(WikiPrinter.class);\n+        xhtmlWikiPrinter = new XHTMLWikiPrinter(mockPrinter, mockSanitizer);\n+        xhtmlWikiPrinter.printXMLElement(\"div\", mapParameters);\n+        verifyPrinting(mockPrinter, expectedName, expectedValue, false);\n+\n+        mockPrinter = mock(WikiPrinter.class);\n+        xhtmlWikiPrinter = new XHTMLWikiPrinter(mockPrinter, mockSanitizer);\n+        String[][] arrayParameters = { { parameterName, parameterValue } };\n+        xhtmlWikiPrinter.printXMLStartElement(\"div\", arrayParameters);\n+        verifyPrinting(mockPrinter, expectedName, expectedValue, true);\n+\n+        mockPrinter = mock(WikiPrinter.class);\n+        xhtmlWikiPrinter = new XHTMLWikiPrinter(mockPrinter, mockSanitizer);\n+        xhtmlWikiPrinter.printXMLElement(\"div\", arrayParameters);\n+        verifyPrinting(mockPrinter, expectedName, expectedValue, false);\n+\n+        mockPrinter = mock(WikiPrinter.class);\n+        xhtmlWikiPrinter = new XHTMLWikiPrinter(mockPrinter, mockSanitizer);\n+        AttributesImpl attributes = new AttributesImpl();\n+        attributes.addAttribute(null, null, parameterName, null, parameterValue);\n+        xhtmlWikiPrinter.printXMLStartElement(\"div\", attributes);\n+        verifyPrinting(mockPrinter, expectedName, expectedValue, true);\n+    }\n+\n+    private void verifyPrinting(WikiPrinter mockPrinter, String attributeName,\n+        String attributeValue, boolean isStart)\n+    {\n+        InOrder inOrder = Mockito.inOrder(mockPrinter);\n+        inOrder.verify(mockPrinter).print(\"<\");\n+        inOrder.verify(mockPrinter).print(\"div\");\n+        inOrder.verify(mockPrinter).print(\" \");\n+        inOrder.verify(mockPrinter).print(attributeName);\n+        inOrder.verify(mockPrinter).print(\"=\");\n+        inOrder.verify(mockPrinter).print(\"\\\"\");\n+        inOrder.verify(mockPrinter).print(attributeValue);\n+        inOrder.verify(mockPrinter).print(\"\\\"\");\n+        if (isStart) {\n+            inOrder.verify(mockPrinter).print(\">\");\n+        } else {\n+            inOrder.verify(mockPrinter).print(\"/>\");\n+        }\n+        verifyNoMoreInteractions(mockPrinter);\n+\n+    }\n }",
    "function_modified_lines": {
      "added": [
        "import java.util.Map;\n",
        "\n",
        "import org.mockito.InOrder;\n",
        "import org.mockito.Mockito;\n",
        "import org.xml.sax.helpers.AttributesImpl;\n",
        "import org.xwiki.xml.html.HTMLElementSanitizer;\n",
        "import static org.mockito.ArgumentMatchers.anyString;\n",
        "import static org.mockito.Mockito.atLeast;\n",
        "import static org.mockito.Mockito.verifyNoMoreInteractions;\n",
        "import static org.mockito.Mockito.when;\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-79"
    ],
    "cve_description": "XWiki Rendering is a generic Rendering system that converts textual input in a given syntax into another syntax. The cleaning of attributes during XHTML rendering, introduced in version 14.6-rc-1, allowed the injection of arbitrary HTML code and thus cross-site scripting via invalid attribute names. This can be exploited, e.g., via the link syntax in any content that supports XWiki syntax like comments in XWiki. When a user moves the mouse over a malicious link, the malicious JavaScript code is executed in the context of the user session. When this user is a privileged user who has programming rights, this allows server-side code execution with programming rights, impacting the confidentiality, integrity and availability of the XWiki instance. While this attribute was correctly recognized as not allowed, the attribute was still printed with a prefix `data-xwiki-translated-attribute-` without further cleaning or validation. This problem has been patched in XWiki 14.10.4 and 15.0 RC1 by removing characters not allowed in data attributes and then validating the cleaned attribute again. There are no known workarounds apart from upgrading to a version including the fix.",
    "id": 12712
  },
  {
    "cve_id": "CVE-2023-37908",
    "code_before_change": "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.rendering.renderer.printer;\n\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.CsvSource;\n\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.verify;\n\n/**\n * Unit tests for {@link XHTMLWikiPrinter}.\n *\n * @version $Id$\n */\nclass XHTMLWikiPrinterTest\n{\n    @ParameterizedTest\n    @CsvSource({\n        \"Closing the {{/html}} macro., Closing the &#123;&#123;/html}} macro.\",\n        \"Starting a macro {, Starting a macro &#123;\",\n        \"Partial: {{/h, Partial: {&#123;/h\",\n        \"{{html}}, {{html}}\"\n    })\n    void testRawEscaping(String input, String expected)\n    {\n        WikiPrinter mockPrinter = mock(WikiPrinter.class);\n        XHTMLWikiPrinter xhtmlWikiPrinter = new XHTMLWikiPrinter(mockPrinter);\n        xhtmlWikiPrinter.printRaw(input);\n        verify(mockPrinter).print(expected);\n    }\n}\n",
    "code_after_change": "{\n    @ParameterizedTest\n    @CsvSource({\n        \"Closing the {{/html}} macro., Closing the &#123;&#123;/html}} macro.\",\n        \"Starting a macro {, Starting a macro &#123;\",\n        \"Partial: {{/h, Partial: {&#123;/h\",\n        \"{{html}}, {{html}}\"\n    })\n    void testRawEscaping(String input, String expected)\n    {\n        WikiPrinter mockPrinter = mock(WikiPrinter.class);\n        XHTMLWikiPrinter xhtmlWikiPrinter = new XHTMLWikiPrinter(mockPrinter);\n        xhtmlWikiPrinter.printRaw(input);\n        verify(mockPrinter).print(expected);\n    }\n\n    @ParameterizedTest\n    @CsvSource({\n        \"invalid, value, data-xwiki-translated-attribute-invalid, value\",\n        \"valid, test&, valid, test&amp;\",\n        \"in/valid, value, data-xwiki-translated-attribute-invalid, value\"\n    })\n    void testParameterCleaning(String parameterName, String parameterValue, String expectedName, String expectedValue)\n    {\n        HTMLElementSanitizer mockSanitizer = mock(HTMLElementSanitizer.class);\n        when(mockSanitizer.isElementAllowed(anyString())).thenReturn(true);\n        when(mockSanitizer.isAttributeAllowed(anyString(), anyString(), anyString())).then(invocation ->\n        {\n            String attributeName = invocation.getArgument(1, String.class);\n            return \"valid\".equals(attributeName) || attributeName.startsWith(\"data-\");\n        });\n\n        // Test all possibilities of invoking the printer (with different kinds of arguments).\n        WikiPrinter mockPrinter = mock(WikiPrinter.class);\n        XHTMLWikiPrinter xhtmlWikiPrinter = new XHTMLWikiPrinter(mockPrinter, mockSanitizer);\n        Map<String, String> mapParameters = Map.of(parameterName, parameterValue);\n        xhtmlWikiPrinter.printXMLStartElement(\"div\", mapParameters);\n        verify(mockSanitizer, atLeast(1)).isElementAllowed(\"div\");\n        verify(mockSanitizer, atLeast(1)).isAttributeAllowed(\"div\", parameterName, parameterValue);\n        verify(mockSanitizer, atLeast(1)).isAttributeAllowed(\"div\", expectedName, parameterValue);\n        verifyPrinting(mockPrinter, expectedName, expectedValue, true);\n\n        mockPrinter = mock(WikiPrinter.class);\n        xhtmlWikiPrinter = new XHTMLWikiPrinter(mockPrinter, mockSanitizer);\n        xhtmlWikiPrinter.printXMLElement(\"div\", mapParameters);\n        verifyPrinting(mockPrinter, expectedName, expectedValue, false);\n\n        mockPrinter = mock(WikiPrinter.class);\n        xhtmlWikiPrinter = new XHTMLWikiPrinter(mockPrinter, mockSanitizer);\n        String[][] arrayParameters = { { parameterName, parameterValue } };\n        xhtmlWikiPrinter.printXMLStartElement(\"div\", arrayParameters);\n        verifyPrinting(mockPrinter, expectedName, expectedValue, true);\n\n        mockPrinter = mock(WikiPrinter.class);\n        xhtmlWikiPrinter = new XHTMLWikiPrinter(mockPrinter, mockSanitizer);\n        xhtmlWikiPrinter.printXMLElement(\"div\", arrayParameters);\n        verifyPrinting(mockPrinter, expectedName, expectedValue, false);\n\n        mockPrinter = mock(WikiPrinter.class);\n        xhtmlWikiPrinter = new XHTMLWikiPrinter(mockPrinter, mockSanitizer);\n        AttributesImpl attributes = new AttributesImpl();\n        attributes.addAttribute(null, null, parameterName, null, parameterValue);\n        xhtmlWikiPrinter.printXMLStartElement(\"div\", attributes);\n        verifyPrinting(mockPrinter, expectedName, expectedValue, true);\n    }\n\n    private void verifyPrinting(WikiPrinter mockPrinter, String attributeName,\n        String attributeValue, boolean isStart)\n    {\n        InOrder inOrder = Mockito.inOrder(mockPrinter);\n        inOrder.verify(mockPrinter).print(\"<\");\n        inOrder.verify(mockPrinter).print(\"div\");\n        inOrder.verify(mockPrinter).print(\" \");\n        inOrder.verify(mockPrinter).print(attributeName);\n        inOrder.verify(mockPrinter).print(\"=\");\n        inOrder.verify(mockPrinter).print(\"\\\"\");\n        inOrder.verify(mockPrinter).print(attributeValue);\n        inOrder.verify(mockPrinter).print(\"\\\"\");\n        if (isStart) {\n            inOrder.verify(mockPrinter).print(\">\");\n        } else {\n            inOrder.verify(mockPrinter).print(\"/>\");\n        }\n        verifyNoMoreInteractions(mockPrinter);\n\n    }\n}",
    "patch": "@@ -19,11 +19,21 @@\n  */\n package org.xwiki.rendering.renderer.printer;\n \n+import java.util.Map;\n+\n import org.junit.jupiter.params.ParameterizedTest;\n import org.junit.jupiter.params.provider.CsvSource;\n+import org.mockito.InOrder;\n+import org.mockito.Mockito;\n+import org.xml.sax.helpers.AttributesImpl;\n+import org.xwiki.xml.html.HTMLElementSanitizer;\n \n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.atLeast;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.when;\n \n /**\n  * Unit tests for {@link XHTMLWikiPrinter}.\n@@ -46,4 +56,75 @@ void testRawEscaping(String input, String expected)\n         xhtmlWikiPrinter.printRaw(input);\n         verify(mockPrinter).print(expected);\n     }\n+\n+    @ParameterizedTest\n+    @CsvSource({\n+        \"invalid, value, data-xwiki-translated-attribute-invalid, value\",\n+        \"valid, test&, valid, test&amp;\",\n+        \"in/valid, value, data-xwiki-translated-attribute-invalid, value\"\n+    })\n+    void testParameterCleaning(String parameterName, String parameterValue, String expectedName, String expectedValue)\n+    {\n+        HTMLElementSanitizer mockSanitizer = mock(HTMLElementSanitizer.class);\n+        when(mockSanitizer.isElementAllowed(anyString())).thenReturn(true);\n+        when(mockSanitizer.isAttributeAllowed(anyString(), anyString(), anyString())).then(invocation ->\n+        {\n+            String attributeName = invocation.getArgument(1, String.class);\n+            return \"valid\".equals(attributeName) || attributeName.startsWith(\"data-\");\n+        });\n+\n+        // Test all possibilities of invoking the printer (with different kinds of arguments).\n+        WikiPrinter mockPrinter = mock(WikiPrinter.class);\n+        XHTMLWikiPrinter xhtmlWikiPrinter = new XHTMLWikiPrinter(mockPrinter, mockSanitizer);\n+        Map<String, String> mapParameters = Map.of(parameterName, parameterValue);\n+        xhtmlWikiPrinter.printXMLStartElement(\"div\", mapParameters);\n+        verify(mockSanitizer, atLeast(1)).isElementAllowed(\"div\");\n+        verify(mockSanitizer, atLeast(1)).isAttributeAllowed(\"div\", parameterName, parameterValue);\n+        verify(mockSanitizer, atLeast(1)).isAttributeAllowed(\"div\", expectedName, parameterValue);\n+        verifyPrinting(mockPrinter, expectedName, expectedValue, true);\n+\n+        mockPrinter = mock(WikiPrinter.class);\n+        xhtmlWikiPrinter = new XHTMLWikiPrinter(mockPrinter, mockSanitizer);\n+        xhtmlWikiPrinter.printXMLElement(\"div\", mapParameters);\n+        verifyPrinting(mockPrinter, expectedName, expectedValue, false);\n+\n+        mockPrinter = mock(WikiPrinter.class);\n+        xhtmlWikiPrinter = new XHTMLWikiPrinter(mockPrinter, mockSanitizer);\n+        String[][] arrayParameters = { { parameterName, parameterValue } };\n+        xhtmlWikiPrinter.printXMLStartElement(\"div\", arrayParameters);\n+        verifyPrinting(mockPrinter, expectedName, expectedValue, true);\n+\n+        mockPrinter = mock(WikiPrinter.class);\n+        xhtmlWikiPrinter = new XHTMLWikiPrinter(mockPrinter, mockSanitizer);\n+        xhtmlWikiPrinter.printXMLElement(\"div\", arrayParameters);\n+        verifyPrinting(mockPrinter, expectedName, expectedValue, false);\n+\n+        mockPrinter = mock(WikiPrinter.class);\n+        xhtmlWikiPrinter = new XHTMLWikiPrinter(mockPrinter, mockSanitizer);\n+        AttributesImpl attributes = new AttributesImpl();\n+        attributes.addAttribute(null, null, parameterName, null, parameterValue);\n+        xhtmlWikiPrinter.printXMLStartElement(\"div\", attributes);\n+        verifyPrinting(mockPrinter, expectedName, expectedValue, true);\n+    }\n+\n+    private void verifyPrinting(WikiPrinter mockPrinter, String attributeName,\n+        String attributeValue, boolean isStart)\n+    {\n+        InOrder inOrder = Mockito.inOrder(mockPrinter);\n+        inOrder.verify(mockPrinter).print(\"<\");\n+        inOrder.verify(mockPrinter).print(\"div\");\n+        inOrder.verify(mockPrinter).print(\" \");\n+        inOrder.verify(mockPrinter).print(attributeName);\n+        inOrder.verify(mockPrinter).print(\"=\");\n+        inOrder.verify(mockPrinter).print(\"\\\"\");\n+        inOrder.verify(mockPrinter).print(attributeValue);\n+        inOrder.verify(mockPrinter).print(\"\\\"\");\n+        if (isStart) {\n+            inOrder.verify(mockPrinter).print(\">\");\n+        } else {\n+            inOrder.verify(mockPrinter).print(\"/>\");\n+        }\n+        verifyNoMoreInteractions(mockPrinter);\n+\n+    }\n }",
    "function_modified_lines": {
      "added": [
        "\n",
        "    @ParameterizedTest\n",
        "    @CsvSource({\n",
        "        \"invalid, value, data-xwiki-translated-attribute-invalid, value\",\n",
        "        \"valid, test&, valid, test&amp;\",\n",
        "        \"in/valid, value, data-xwiki-translated-attribute-invalid, value\"\n",
        "    })\n",
        "    void testParameterCleaning(String parameterName, String parameterValue, String expectedName, String expectedValue)\n",
        "    {\n",
        "        HTMLElementSanitizer mockSanitizer = mock(HTMLElementSanitizer.class);\n",
        "        when(mockSanitizer.isElementAllowed(anyString())).thenReturn(true);\n",
        "        when(mockSanitizer.isAttributeAllowed(anyString(), anyString(), anyString())).then(invocation ->\n",
        "        {\n",
        "            String attributeName = invocation.getArgument(1, String.class);\n",
        "            return \"valid\".equals(attributeName) || attributeName.startsWith(\"data-\");\n",
        "        });\n",
        "\n",
        "        // Test all possibilities of invoking the printer (with different kinds of arguments).\n",
        "        WikiPrinter mockPrinter = mock(WikiPrinter.class);\n",
        "        XHTMLWikiPrinter xhtmlWikiPrinter = new XHTMLWikiPrinter(mockPrinter, mockSanitizer);\n",
        "        Map<String, String> mapParameters = Map.of(parameterName, parameterValue);\n",
        "        xhtmlWikiPrinter.printXMLStartElement(\"div\", mapParameters);\n",
        "        verify(mockSanitizer, atLeast(1)).isElementAllowed(\"div\");\n",
        "        verify(mockSanitizer, atLeast(1)).isAttributeAllowed(\"div\", parameterName, parameterValue);\n",
        "        verify(mockSanitizer, atLeast(1)).isAttributeAllowed(\"div\", expectedName, parameterValue);\n",
        "        verifyPrinting(mockPrinter, expectedName, expectedValue, true);\n",
        "\n",
        "        mockPrinter = mock(WikiPrinter.class);\n",
        "        xhtmlWikiPrinter = new XHTMLWikiPrinter(mockPrinter, mockSanitizer);\n",
        "        xhtmlWikiPrinter.printXMLElement(\"div\", mapParameters);\n",
        "        verifyPrinting(mockPrinter, expectedName, expectedValue, false);\n",
        "\n",
        "        mockPrinter = mock(WikiPrinter.class);\n",
        "        xhtmlWikiPrinter = new XHTMLWikiPrinter(mockPrinter, mockSanitizer);\n",
        "        String[][] arrayParameters = { { parameterName, parameterValue } };\n",
        "        xhtmlWikiPrinter.printXMLStartElement(\"div\", arrayParameters);\n",
        "        verifyPrinting(mockPrinter, expectedName, expectedValue, true);\n",
        "\n",
        "        mockPrinter = mock(WikiPrinter.class);\n",
        "        xhtmlWikiPrinter = new XHTMLWikiPrinter(mockPrinter, mockSanitizer);\n",
        "        xhtmlWikiPrinter.printXMLElement(\"div\", arrayParameters);\n",
        "        verifyPrinting(mockPrinter, expectedName, expectedValue, false);\n",
        "\n",
        "        mockPrinter = mock(WikiPrinter.class);\n",
        "        xhtmlWikiPrinter = new XHTMLWikiPrinter(mockPrinter, mockSanitizer);\n",
        "        AttributesImpl attributes = new AttributesImpl();\n",
        "        attributes.addAttribute(null, null, parameterName, null, parameterValue);\n",
        "        xhtmlWikiPrinter.printXMLStartElement(\"div\", attributes);\n",
        "        verifyPrinting(mockPrinter, expectedName, expectedValue, true);\n",
        "    }\n",
        "\n",
        "    private void verifyPrinting(WikiPrinter mockPrinter, String attributeName,\n",
        "        String attributeValue, boolean isStart)\n",
        "    {\n",
        "        InOrder inOrder = Mockito.inOrder(mockPrinter);\n",
        "        inOrder.verify(mockPrinter).print(\"<\");\n",
        "        inOrder.verify(mockPrinter).print(\"div\");\n",
        "        inOrder.verify(mockPrinter).print(\" \");\n",
        "        inOrder.verify(mockPrinter).print(attributeName);\n",
        "        inOrder.verify(mockPrinter).print(\"=\");\n",
        "        inOrder.verify(mockPrinter).print(\"\\\"\");\n",
        "        inOrder.verify(mockPrinter).print(attributeValue);\n",
        "        inOrder.verify(mockPrinter).print(\"\\\"\");\n",
        "        if (isStart) {\n",
        "            inOrder.verify(mockPrinter).print(\">\");\n",
        "        } else {\n",
        "            inOrder.verify(mockPrinter).print(\"/>\");\n",
        "        }\n",
        "        verifyNoMoreInteractions(mockPrinter);\n",
        "\n",
        "    }\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-79"
    ],
    "cve_description": "XWiki Rendering is a generic Rendering system that converts textual input in a given syntax into another syntax. The cleaning of attributes during XHTML rendering, introduced in version 14.6-rc-1, allowed the injection of arbitrary HTML code and thus cross-site scripting via invalid attribute names. This can be exploited, e.g., via the link syntax in any content that supports XWiki syntax like comments in XWiki. When a user moves the mouse over a malicious link, the malicious JavaScript code is executed in the context of the user session. When this user is a privileged user who has programming rights, this allows server-side code execution with programming rights, impacting the confidentiality, integrity and availability of the XWiki instance. While this attribute was correctly recognized as not allowed, the attribute was still printed with a prefix `data-xwiki-translated-attribute-` without further cleaning or validation. This problem has been patched in XWiki 14.10.4 and 15.0 RC1 by removing characters not allowed in data attributes and then validating the cleaned attribute again. There are no known workarounds apart from upgrading to a version including the fix.",
    "id": 12713
  },
  {
    "cve_id": "CVE-2023-33962",
    "code_before_change": "/**\n * Provides a mustache spec based HTML escaper which is the default in normal mustache.\n * <p>\n * The escaper simply escapes:\n * <ul>\n * <li>'&quot;'</li>\n * <li>'&gt;'</li>\n * <li>'&lt;'</li>\n * <li>'&amp;'</li>\n * </ul>\n *\n * <em>N.B. Unlike many XML escapers this escaper does not differentiate attribute and\n * element content. Furthermore Mustache unlike many other templating languages is content\n * agnostic. If more flexibile attribute escaping is needed a custom lambda could be used\n * to preserve the whitespace in attributes. </em>\n * <p>\n * <strong>This escaper assumes UTF-8 which is the predominate encoding of HTML these days\n * and thus will not encode characters other then the ones mentioned above. </strong> Thus\n * if you intend escape for example {@link StandardCharsets#US_ASCII} a different HTML\n * escaper should be used to properly escape non ascii characters as HTML entities.\n *\n * @author agentgt\n * @author Victor Nazarov\n * @see JStacheConfig#contentType()\n */",
    "code_after_change": "/**\n * Provides a mustache spec based HTML escaper which is the default in normal mustache.\n * <p>\n * The escaper simply escapes:\n * <table border=\"1\">\n * <caption><strong>Escape table</strong></caption>\n * <tr>\n * <th>Character</th>\n * <th>Escaped String</th>\n * </tr>\n * <tr>\n * <td>'<code>&quot;</code>'</td>\n * <td>{@value HtmlEscaper#QUOT}</td>\n * </tr>\n * <tr>\n * <td>'<code>&amp;</code>'</td>\n * <td>{@value HtmlEscaper#AMP}</td>\n * </tr>\n * <tr>\n * <td>'<code>&#x27;</code>'</td>\n * <td>{@value HtmlEscaper#APOS}</td>\n * </tr>\n * <tr>\n * <td>'<code>&lt;</code>'</td>\n * <td>{@value HtmlEscaper#LT}</td>\n * </tr>\n * <tr>\n * <td>'<code>=</code>'</td>\n * <td>{@value HtmlEscaper#EQUAL}</td>\n * </tr>\n * <tr>\n * <td>'<code>&gt;</code>'</td>\n * <td>{@value HtmlEscaper#GT}</td>\n * </tr>\n * <tr>\n * <td>'<code>&#x60;</code>'</td>\n * <td>{@value HtmlEscaper#BACK_TICK}</td>\n * </tr>\n * </table>\n * <br />\n * <em>N.B. Unlike many XML escapers this escaper does not differentiate attribute and\n * element content. Furthermore Mustache unlike many other templating languages is content\n * agnostic. If more flexibile attribute escaping is needed a custom lambda could be used\n * to preserve the whitespace in attributes. </em>\n * <p>\n * <strong>This escaper assumes UTF-8 which is the predominate encoding of HTML these days\n * and thus will not encode characters other then the ones mentioned above. </strong> Thus\n * if you intend escape for example {@link StandardCharsets#US_ASCII} a different HTML\n * escaper should be used to properly escape non ascii characters as HTML entities.\n *\n * @author agentgt\n * @author Victor Nazarov\n * @see JStacheConfig#contentType()\n */",
    "patch": "@@ -10,13 +10,42 @@\n  * Provides a mustache spec based HTML escaper which is the default in normal mustache.\n  * <p>\n  * The escaper simply escapes:\n- * <ul>\n- * <li>'&quot;'</li>\n- * <li>'&gt;'</li>\n- * <li>'&lt;'</li>\n- * <li>'&amp;'</li>\n- * </ul>\n- *\n+ * <table border=\"1\">\n+ * <caption><strong>Escape table</strong></caption>\n+ * <tr>\n+ * <th>Character</th>\n+ * <th>Escaped String</th>\n+ * </tr>\n+ * <tr>\n+ * <td>'<code>&quot;</code>'</td>\n+ * <td>{@value HtmlEscaper#QUOT}</td>\n+ * </tr>\n+ * <tr>\n+ * <td>'<code>&amp;</code>'</td>\n+ * <td>{@value HtmlEscaper#AMP}</td>\n+ * </tr>\n+ * <tr>\n+ * <td>'<code>&#x27;</code>'</td>\n+ * <td>{@value HtmlEscaper#APOS}</td>\n+ * </tr>\n+ * <tr>\n+ * <td>'<code>&lt;</code>'</td>\n+ * <td>{@value HtmlEscaper#LT}</td>\n+ * </tr>\n+ * <tr>\n+ * <td>'<code>=</code>'</td>\n+ * <td>{@value HtmlEscaper#EQUAL}</td>\n+ * </tr>\n+ * <tr>\n+ * <td>'<code>&gt;</code>'</td>\n+ * <td>{@value HtmlEscaper#GT}</td>\n+ * </tr>\n+ * <tr>\n+ * <td>'<code>&#x60;</code>'</td>\n+ * <td>{@value HtmlEscaper#BACK_TICK}</td>\n+ * </tr>\n+ * </table>\n+ * <br />\n  * <em>N.B. Unlike many XML escapers this escaper does not differentiate attribute and\n  * element content. Furthermore Mustache unlike many other templating languages is content\n  * agnostic. If more flexibile attribute escaping is needed a custom lambda could be used",
    "function_modified_lines": {
      "added": [
        " * <table border=\"1\">\n",
        " * <caption><strong>Escape table</strong></caption>\n",
        " * <tr>\n",
        " * <th>Character</th>\n",
        " * <th>Escaped String</th>\n",
        " * </tr>\n",
        " * <tr>\n",
        " * <td>'<code>&quot;</code>'</td>\n",
        " * <td>{@value HtmlEscaper#QUOT}</td>\n",
        " * </tr>\n",
        " * <tr>\n",
        " * <td>'<code>&amp;</code>'</td>\n",
        " * <td>{@value HtmlEscaper#AMP}</td>\n",
        " * </tr>\n",
        " * <tr>\n",
        " * <td>'<code>&#x27;</code>'</td>\n",
        " * <td>{@value HtmlEscaper#APOS}</td>\n",
        " * </tr>\n",
        " * <tr>\n",
        " * <td>'<code>&lt;</code>'</td>\n",
        " * <td>{@value HtmlEscaper#LT}</td>\n",
        " * </tr>\n",
        " * <tr>\n",
        " * <td>'<code>=</code>'</td>\n",
        " * <td>{@value HtmlEscaper#EQUAL}</td>\n",
        " * </tr>\n",
        " * <tr>\n",
        " * <td>'<code>&gt;</code>'</td>\n",
        " * <td>{@value HtmlEscaper#GT}</td>\n",
        " * </tr>\n",
        " * <tr>\n",
        " * <td>'<code>&#x60;</code>'</td>\n",
        " * <td>{@value HtmlEscaper#BACK_TICK}</td>\n",
        " * </tr>\n",
        " * </table>\n",
        " * <br />\n"
      ],
      "deleted": [
        " * <ul>\n",
        " * <li>'&quot;'</li>\n",
        " * <li>'&gt;'</li>\n",
        " * <li>'&lt;'</li>\n",
        " * <li>'&amp;'</li>\n",
        " * </ul>\n",
        " *\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-79"
    ],
    "cve_description": "JStachio is a  type-safe Java Mustache templating engine. Prior to version 1.0.1, JStachio fails to escape single quotes `'` in HTML, allowing an attacker to inject malicious code. This vulnerability can be exploited by an attacker to execute arbitrary JavaScript code in the context of other users visiting pages that use this template engine. This can lead to various consequences, including session hijacking, defacement of web pages, theft of sensitive information, or even the propagation of malware.\n\nVersion 1.0.1 contains a patch for this issue. To mitigate this vulnerability, the template engine should properly escape special characters, including single quotes. Common practice is to escape `'` as `&#39`. As a workaround, users can avoid this issue by using only double quotes `\"` for HTML attributes.",
    "id": 12722
  }
]