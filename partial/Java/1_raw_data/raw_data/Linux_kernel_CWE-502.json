[
  {
    "cve_id": "CVE-2013-4521",
    "code_before_change": "package org.richfaces.demo.media;\r\n\r\nimport java.awt.Color;\r\nimport java.io.Serializable;\r\n\r\npublic class MediaData implements Serializable{\r\n\r\n\tprivate static final long serialVersionUID = 1L;\r\n\tInteger Width=110;\r\n\tInteger Height=50;\r\n\tColor Background=new Color(0,0,0);\r\n\tColor DrawColor=new Color(255,255,255);\r\n\tpublic MediaData() {\r\n\t}\r\n\tpublic Color getBackground() {\r\n\t\treturn Background;\r\n\t}\r\n\tpublic void setBackground(Color background) {\r\n\t\tBackground = background;\r\n\t}\r\n\tpublic Color getDrawColor() {\r\n\t\treturn DrawColor;\r\n\t}\r\n\tpublic void setDrawColor(Color drawColor) {\r\n\t\tDrawColor = drawColor;\r\n\t}\r\n\tpublic Integer getHeight() {\r\n\t\treturn Height;\r\n\t}\r\n\tpublic void setHeight(Integer height) {\r\n\t\tHeight = height;\r\n\t}\r\n\tpublic Integer getWidth() {\r\n\t\treturn Width;\r\n\t}\r\n\tpublic void setWidth(Integer width) {\r\n\t\tWidth = width;\r\n\t}\r\n}",
    "code_after_change": "package org.richfaces.demo.media;\r\n\r\nimport java.awt.Color;\r\n\r\nimport org.ajax4jsf.resource.SerializableResource;\r\n\r\npublic class MediaData implements SerializableResource {\r\n\r\n\tprivate static final long serialVersionUID = 1L;\r\n\tInteger Width=110;\r\n\tInteger Height=50;\r\n\tColor Background=new Color(0,0,0);\r\n\tColor DrawColor=new Color(255,255,255);\r\n\tpublic MediaData() {\r\n\t}\r\n\tpublic Color getBackground() {\r\n\t\treturn Background;\r\n\t}\r\n\tpublic void setBackground(Color background) {\r\n\t\tBackground = background;\r\n\t}\r\n\tpublic Color getDrawColor() {\r\n\t\treturn DrawColor;\r\n\t}\r\n\tpublic void setDrawColor(Color drawColor) {\r\n\t\tDrawColor = drawColor;\r\n\t}\r\n\tpublic Integer getHeight() {\r\n\t\treturn Height;\r\n\t}\r\n\tpublic void setHeight(Integer height) {\r\n\t\tHeight = height;\r\n\t}\r\n\tpublic Integer getWidth() {\r\n\t\treturn Width;\r\n\t}\r\n\tpublic void setWidth(Integer width) {\r\n\t\tWidth = width;\r\n\t}\r\n}",
    "patch": "@@ -1,9 +1,10 @@\n package org.richfaces.demo.media;\r\n \r\n import java.awt.Color;\r\n-import java.io.Serializable;\r\n \r\n-public class MediaData implements Serializable{\r\n+import org.ajax4jsf.resource.SerializableResource;\r\n+\r\n+public class MediaData implements SerializableResource {\r\n \r\n \tprivate static final long serialVersionUID = 1L;\r\n \tInteger Width=110;\r",
    "function_modified_lines": {
      "added": [
        "import org.ajax4jsf.resource.SerializableResource;\r\n",
        "\r\n",
        "public class MediaData implements SerializableResource {\r\n"
      ],
      "deleted": [
        "import java.io.Serializable;\r\n",
        "public class MediaData implements Serializable{\r\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "RichFaces implementation in Nuxeo Platform 5.6.0 before HF27 and 5.8.0 before HF-01 does not restrict the classes for which deserialization methods can be called, which allows remote attackers to execute arbitrary code via crafted serialized data. NOTE: this vulnerability may overlap CVE-2013-2165.",
    "id": 11954
  },
  {
    "cve_id": "CVE-2013-4521",
    "code_before_change": "package org.richfaces.demo.paint2d;\r\n\r\nimport java.io.Serializable;\r\n\r\npublic class PaintData implements Serializable{\r\n\t/**\r\n\t * \r\n\t */\r\n\tprivate static final long serialVersionUID = 1L;\r\n\tString text;\r\n\tInteger color;\r\n\tfloat scale;\r\n\r\n\r\n\tpublic Integer getColor() {\r\n\t\treturn color;\r\n\t}\r\n\tpublic void setColor(Integer color) {\r\n\t\tthis.color = color;\r\n\t}\r\n\tpublic float getScale() {\r\n\t\treturn scale;\r\n\t}\r\n\tpublic void setScale(float scale) {\r\n\t\tthis.scale = scale;\r\n\t}\r\n\r\n\tpublic String getText() {\r\n\t\treturn text;\r\n\t}\r\n\tpublic void setText(String text) {\r\n\t\tthis.text = text;\r\n\t}\r\n}\r\n",
    "code_after_change": "package org.richfaces.demo.paint2d;\r\n\r\nimport org.ajax4jsf.resource.SerializableResource;\r\n\r\npublic class PaintData implements SerializableResource {\r\n\t/**\r\n\t * \r\n\t */\r\n\tprivate static final long serialVersionUID = 1L;\r\n\tString text;\r\n\tInteger color;\r\n\tfloat scale;\r\n\r\n\r\n\tpublic Integer getColor() {\r\n\t\treturn color;\r\n\t}\r\n\tpublic void setColor(Integer color) {\r\n\t\tthis.color = color;\r\n\t}\r\n\tpublic float getScale() {\r\n\t\treturn scale;\r\n\t}\r\n\tpublic void setScale(float scale) {\r\n\t\tthis.scale = scale;\r\n\t}\r\n\r\n\tpublic String getText() {\r\n\t\treturn text;\r\n\t}\r\n\tpublic void setText(String text) {\r\n\t\tthis.text = text;\r\n\t}\r\n}\r\n",
    "patch": "@@ -1,8 +1,8 @@\n package org.richfaces.demo.paint2d;\r\n \r\n-import java.io.Serializable;\r\n+import org.ajax4jsf.resource.SerializableResource;\r\n \r\n-public class PaintData implements Serializable{\r\n+public class PaintData implements SerializableResource {\r\n \t/**\r\n \t * \r\n \t */\r",
    "function_modified_lines": {
      "added": [
        "import org.ajax4jsf.resource.SerializableResource;\r\n",
        "public class PaintData implements SerializableResource {\r\n"
      ],
      "deleted": [
        "import java.io.Serializable;\r\n",
        "public class PaintData implements Serializable{\r\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "RichFaces implementation in Nuxeo Platform 5.6.0 before HF27 and 5.8.0 before HF-01 does not restrict the classes for which deserialization methods can be called, which allows remote attackers to execute arbitrary code via crafted serialized data. NOTE: this vulnerability may overlap CVE-2013-2165.",
    "id": 11955
  },
  {
    "cve_id": "CVE-2021-21242",
    "code_before_change": "import org.apache.wicket.request.IRequestParameters;\nimport org.apache.wicket.request.cycle.RequestCycle;\nimport org.apache.wicket.request.http.WebRequest;\nimport org.apache.wicket.request.mapper.parameter.PageParameters;\nimport org.apache.wicket.request.resource.PackageResourceReference;\nimport org.apache.wicket.util.crypt.Base64;\nimport org.unbescape.javascript.JavaScriptEscape;\n\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.google.common.base.Preconditions;\n\nimport io.onedev.commons.launcher.loader.AppLoader;\nimport io.onedev.server.OneDev;\nimport io.onedev.server.entitymanager.ProjectManager;\nimport io.onedev.server.model.Build;\nimport io.onedev.server.model.Issue;\nimport io.onedev.server.model.Project;\nimport io.onedev.server.model.PullRequest;\nimport io.onedev.server.model.User;\nimport io.onedev.server.util.markdown.MarkdownManager;\nimport io.onedev.server.util.validation.ProjectNameValidator;\nimport io.onedev.server.web.avatar.AvatarManager;\nimport io.onedev.server.web.behavior.AbstractPostAjaxBehavior;\nimport io.onedev.server.web.component.floating.FloatingPanel;\nimport io.onedev.server.web.component.link.DropdownLink;\nimport io.onedev.server.web.component.markdown.emoji.EmojiOnes;\nimport io.onedev.server.web.component.modal.ModalPanel;\nimport io.onedev.server.web.page.project.ProjectPage;\nimport io.onedev.server.web.page.project.blob.render.BlobRenderContext;\n\n@SuppressWarnings(\"serial\")\npublic class MarkdownEditor extends FormComponentPanel<String> {\n\n\tprotected static final int ATWHO_LIMIT = 10;\n\t\n\tprivate final boolean compactMode;\n\t\n\tprivate final boolean initialSplit;\n\t\n\tprivate final BlobRenderContext blobRenderContext;\n\t\n\tprivate WebMarkupContainer container;\n\t\n\tprivate TextArea<String> input;\n\n\tprivate AbstractPostAjaxBehavior ajaxBehavior;\n\t\n\t/**\n\t * @param id \n\t * \t\t\tcomponent id of the editor\n\t * @param model\n\t * \t\t\tmarkdown model of the editor\n\t * @param compactMode\n\t * \t\t\teditor in compact mode occupies horizontal space and is suitable \n\t * \t\t\tto be used in places such as comment aside the code\n\t */\n\tpublic MarkdownEditor(String id, IModel<String> model, boolean compactMode, \n\t\t\t@Nullable BlobRenderContext blobRenderContext) {\n\t\tsuper(id, model);\n\t\tthis.compactMode = compactMode;\n\t\t\n\t\tString cookieKey;\n\t\tif (compactMode)\n\t\t\tcookieKey = \"markdownEditor.compactMode.split\";\n\t\telse\n\t\t\tcookieKey = \"markdownEditor.normalMode.split\";\n\t\t\n\t\tWebRequest request = (WebRequest) RequestCycle.get().getRequest();\n\t\tCookie cookie = request.getCookie(cookieKey);\n\t\tinitialSplit = cookie!=null && \"true\".equals(cookie.getValue());\n\t\t\n\t\tthis.blobRenderContext = blobRenderContext;\n\t}\n\t\n\t@Override\n\tprotected void onModelChanged() {\n\t\tsuper.onModelChanged();\n\t\tinput.setModelObject(getModelObject());\n\t}\n\t\n\tpublic void clearMarkdown() {\n\t\tsetModelObject(\"\");",
    "code_after_change": "import org.apache.wicket.request.mapper.parameter.PageParameters;\nimport org.apache.wicket.request.resource.PackageResourceReference;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.unbescape.javascript.JavaScriptEscape;\n\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.google.common.base.Preconditions;\n\nimport io.onedev.commons.launcher.loader.AppLoader;\nimport io.onedev.server.OneDev;\nimport io.onedev.server.entitymanager.ProjectManager;\nimport io.onedev.server.model.Build;\nimport io.onedev.server.model.Issue;\nimport io.onedev.server.model.Project;\nimport io.onedev.server.model.PullRequest;\nimport io.onedev.server.model.User;\nimport io.onedev.server.util.markdown.MarkdownManager;\nimport io.onedev.server.util.validation.ProjectNameValidator;\nimport io.onedev.server.web.avatar.AvatarManager;\nimport io.onedev.server.web.behavior.AbstractPostAjaxBehavior;\nimport io.onedev.server.web.component.floating.FloatingPanel;\nimport io.onedev.server.web.component.link.DropdownLink;\nimport io.onedev.server.web.component.markdown.emoji.EmojiOnes;\nimport io.onedev.server.web.component.modal.ModalPanel;\nimport io.onedev.server.web.page.project.ProjectPage;\nimport io.onedev.server.web.page.project.blob.render.BlobRenderContext;\n\n@SuppressWarnings(\"serial\")\npublic class MarkdownEditor extends FormComponentPanel<String> {\n\n\tprotected static final int ATWHO_LIMIT = 10;\n\t\n\tprivate static final Logger logger = LoggerFactory.getLogger(MarkdownEditor.class);\n\t\n\tprivate final boolean compactMode;\n\t\n\tprivate final boolean initialSplit;\n\t\n\tprivate final BlobRenderContext blobRenderContext;\n\t\n\tprivate WebMarkupContainer container;\n\t\n\tprivate TextArea<String> input;\n\n\tprivate AbstractPostAjaxBehavior actionBehavior;\n\t\n\tprivate AbstractPostAjaxBehavior attachmentUploadBehavior;\n\t\n\t/**\n\t * @param id \n\t * \t\t\tcomponent id of the editor\n\t * @param model\n\t * \t\t\tmarkdown model of the editor\n\t * @param compactMode\n\t * \t\t\teditor in compact mode occupies horizontal space and is suitable \n\t * \t\t\tto be used in places such as comment aside the code\n\t */\n\tpublic MarkdownEditor(String id, IModel<String> model, boolean compactMode, \n\t\t\t@Nullable BlobRenderContext blobRenderContext) {\n\t\tsuper(id, model);\n\t\tthis.compactMode = compactMode;\n\t\t\n\t\tString cookieKey;\n\t\tif (compactMode)\n\t\t\tcookieKey = \"markdownEditor.compactMode.split\";\n\t\telse\n\t\t\tcookieKey = \"markdownEditor.normalMode.split\";\n\t\t\n\t\tWebRequest request = (WebRequest) RequestCycle.get().getRequest();\n\t\tCookie cookie = request.getCookie(cookieKey);\n\t\tinitialSplit = cookie!=null && \"true\".equals(cookie.getValue());\n\t\t\n\t\tthis.blobRenderContext = blobRenderContext;\n\t}\n\t\n\t@Override\n\tprotected void onModelChanged() {\n\t\tsuper.onModelChanged();\n\t\tinput.setModelObject(getModelObject());\n\t}\n\t\n\tpublic void clearMarkdown() {\n\t\tsetModelObject(\"\");",
    "patch": "@@ -2,9 +2,11 @@\n \n import static org.apache.wicket.ajax.attributes.CallbackParameter.explicit;\n \n+import java.io.IOException;\n import java.io.Serializable;\n import java.io.UnsupportedEncodingException;\n import java.net.URLDecoder;\n+import java.net.URLEncoder;\n import java.nio.charset.StandardCharsets;\n import java.util.ArrayList;\n import java.util.HashMap;\n@@ -13,8 +15,9 @@\n \n import javax.annotation.Nullable;\n import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n \n-import org.apache.commons.lang3.SerializationUtils;\n import org.apache.commons.lang3.StringUtils;\n import org.apache.commons.text.StringEscapeUtils;\n import org.apache.wicket.AttributeModifier;\n@@ -41,7 +44,8 @@\n import org.apache.wicket.request.http.WebRequest;\n import org.apache.wicket.request.mapper.parameter.PageParameters;\n import org.apache.wicket.request.resource.PackageResourceReference;\n-import org.apache.wicket.util.crypt.Base64;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n import org.unbescape.javascript.JavaScriptEscape;\n \n import com.fasterxml.jackson.core.JsonProcessingException;\n@@ -72,6 +76,8 @@ public class MarkdownEditor extends FormComponentPanel<String> {\n \n \tprotected static final int ATWHO_LIMIT = 10;\n \t\n+\tprivate static final Logger logger = LoggerFactory.getLogger(MarkdownEditor.class);\n+\t\n \tprivate final boolean compactMode;\n \t\n \tprivate final boolean initialSplit;\n@@ -82,7 +88,9 @@ public class MarkdownEditor extends FormComponentPanel<String> {\n \t\n \tprivate TextArea<String> input;\n \n-\tprivate AbstractPostAjaxBehavior ajaxBehavior;\n+\tprivate AbstractPostAjaxBehavior actionBehavior;\n+\t\n+\tprivate AbstractPostAjaxBehavior attachmentUploadBehavior;\n \t\n \t/**\n \t * @param id \n@@ -251,7 +259,7 @@ public void renderHead(IHeaderResponse response) {\n \t\t\n \t\tcontainer.add(new WebMarkupContainer(\"canAttachFile\").setVisible(getAttachmentSupport()!=null));\n \t\t\n-\t\tcontainer.add(ajaxBehavior = new AbstractPostAjaxBehavior() {\n+\t\tcontainer.add(actionBehavior = new AbstractPostAjaxBehavior() {\n \n \t\t\t@Override\n \t\t\tprotected void updateAjaxAttributes(AjaxRequestAttributes attributes) {\n@@ -452,13 +460,42 @@ protected void onClosed() {\n \t\t\t\t\tString replaceMessage = params.getParameterValue(\"param2\").toString();\n \t\t\t\t\tString url = getAttachmentSupport().getAttachmentUrl(name);\n \t\t\t\t\tinsertUrl(target, isWebSafeImage(name), url, name, replaceMessage);\n+\t\t\t\t\t\n \t\t\t\t\tbreak;\n \t\t\t\tdefault:\n \t\t\t\t\tthrow new IllegalStateException(\"Unknown action: \" + action);\n \t\t\t\t}\t\t\n \t\t\t}\n \t\t\t\n \t\t});\n+\t\t\n+\t\tcontainer.add(attachmentUploadBehavior = new AbstractPostAjaxBehavior() {\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tprotected void respond(AjaxRequestTarget target) {\n+\t\t\t\tPreconditions.checkNotNull(getAttachmentSupport(), \"Unexpected attachment upload request\");\n+\t\t\t\tHttpServletRequest request = (HttpServletRequest) RequestCycle.get().getRequest().getContainerRequest();\n+\t\t\t\tHttpServletResponse response = (HttpServletResponse) RequestCycle.get().getResponse().getContainerResponse();\n+\t\t\t\ttry {\n+\t\t\t\t\tString fileName = URLDecoder.decode(request.getHeader(\"File-Name\"), StandardCharsets.UTF_8.name());\n+\t\t\t\t\tString attachmentName = getAttachmentSupport().saveAttachment(fileName, request.getInputStream());\n+\t\t\t\t\tresponse.getWriter().print(URLEncoder.encode(attachmentName, StandardCharsets.UTF_8.name()));\n+\t\t\t\t\tresponse.setStatus(HttpServletResponse.SC_OK);\n+\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\tlogger.error(\"Error uploading attachment.\", e);\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\tif (e.getMessage() != null)\n+\t\t\t\t\t\t\tresponse.getWriter().print(e.getMessage());\n+\t\t\t\t\t\telse\n+\t\t\t\t\t\t\tresponse.getWriter().print(\"Internal server error\");\n+\t\t\t\t\t} catch (IOException e2) {\n+\t\t\t\t\t\tthrow new RuntimeException(e2);\n+\t\t\t\t\t}\n+\t\t\t\t\tresponse.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\t\n+\t\t});\n \t}\n \t\n \t@Override\n@@ -476,18 +513,9 @@ public void renderHead(IHeaderResponse response) {\n \t\tsuper.renderHead(response);\n \t\tresponse.render(JavaScriptHeaderItem.forReference(new MarkdownResourceReference()));\n \t\t\n-\t\tString encodedAttachmentSupport;\n-\t\tif (getAttachmentSupport() != null) {\n-\t\t\tencodedAttachmentSupport = Base64.encodeBase64String(SerializationUtils.serialize(getAttachmentSupport()));\n-\t\t\tencodedAttachmentSupport = StringUtils.deleteWhitespace(encodedAttachmentSupport);\n-\t\t\tencodedAttachmentSupport = StringEscapeUtils.escapeEcmaScript(encodedAttachmentSupport);\n-\t\t\tencodedAttachmentSupport = \"'\" + encodedAttachmentSupport + \"'\";\n-\t\t} else {\n-\t\t\tencodedAttachmentSupport = \"undefined\";\n-\t\t}\n-\t\t\n-\t\tString callback = ajaxBehavior.getCallbackFunction(explicit(\"action\"), explicit(\"param1\"), explicit(\"param2\"), \n+\t\tString actionCallback = actionBehavior.getCallbackFunction(explicit(\"action\"), explicit(\"param1\"), explicit(\"param2\"), \n \t\t\t\texplicit(\"param3\")).toString();\n+\t\tString attachmentUploadUrl = attachmentUploadBehavior.getCallbackUrl().toString();\n \t\t\n \t\tString autosaveKey = getAutosaveKey();\n \t\tif (autosaveKey != null)\n@@ -497,10 +525,10 @@ public void renderHead(IHeaderResponse response) {\n \t\t\n \t\tString script = String.format(\"onedev.server.markdown.onDomReady('%s', %s, %d, %s, %d, %b, %b, '%s', %s);\", \n \t\t\t\tcontainer.getMarkupId(), \n-\t\t\t\tcallback, \n+\t\t\t\tactionCallback, \n \t\t\t\tATWHO_LIMIT, \n-\t\t\t\tencodedAttachmentSupport, \n-\t\t\t\tgetAttachmentSupport()!=null?getAttachmentSupport().getAttachmentMaxSize():0,\n+\t\t\t\tgetAttachmentSupport()!=null? \"'\" + attachmentUploadUrl + \"'\": \"undefined\", \n+\t\t\t\tgetAttachmentSupport()!=null? getAttachmentSupport().getAttachmentMaxSize(): 0,\n \t\t\t\tgetUserMentionSupport() != null,\n \t\t\t\tgetReferenceSupport() != null, \n \t\t\t\tJavaScriptEscape.escapeJavaScript(ProjectNameValidator.PATTERN.pattern()),",
    "function_modified_lines": {
      "added": [
        "\tprivate static final Logger logger = LoggerFactory.getLogger(MarkdownEditor.class);\n",
        "\t\n",
        "\tprivate AbstractPostAjaxBehavior actionBehavior;\n",
        "\t\n",
        "\tprivate AbstractPostAjaxBehavior attachmentUploadBehavior;\n"
      ],
      "deleted": [
        "\tprivate AbstractPostAjaxBehavior ajaxBehavior;\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "OneDev is an all-in-one devops platform. In OneDev before version 4.0.3, there is a critical vulnerability which can lead to pre-auth remote code execution. AttachmentUploadServlet deserializes untrusted data from the `Attachment-Support` header. This Servlet does not enforce any authentication or authorization checks. This issue may lead to pre-auth remote code execution. This issue was fixed in 4.0.3 by removing AttachmentUploadServlet and not using deserialization",
    "id": 12192
  },
  {
    "cve_id": "CVE-2021-32634",
    "code_before_change": "package emissary.pickup;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.UUID;\n\nimport emissary.util.xml.JDOMUtil;\nimport org.jdom2.Document;\nimport org.jdom2.Element;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Used to communicate between the TreePickUpPlace and TreeSpace about a set of files to process.\n * \n * Two times are tracked for the files in each work bundle - the \"youngest\" modification time and the \"oldest\"\n * modification time, both initially entered as time from the epoch. However, the concept of \"youngest\" and \"oldest\" is\n * relative to the construction time, so that:\n * <p>\n * getOldestFileModificationTime() &lt;= getYoungestFileModificationTime()\n */\npublic class WorkBundle implements Serializable, Comparable<WorkBundle> {\n\n    // Serializable\n    static final long serialVersionUID = 6339812801001572532L;\n\n    private static final Logger logger = LoggerFactory.getLogger(WorkBundle.class);\n\n    // Unique ID for this work bundle\n    String bundleId;\n\n    // Configured output root for finding data on remote side\n    String outputRoot;\n\n    // Configuration passed to remote side for producing output name\n    String eatPrefix;\n\n    // Database case id for the work in this bundle\n    String caseId = null;\n\n    // Priority of this work bundle\n    int priority = Priority.DEFAULT;\n\n    // Flag to note if the bundle is in simple mode\n    boolean simpleMode = false;\n\n    List<WorkUnit> workUnitList = new ArrayList<>();\n\n    // Where being processed\n    String sentTo;\n\n    // Cumulative errors in processing tries\n    int errorCount = 0;\n\n    /**\n     * The oldest file in the bundle in millis since epoch\n     */\n    long oldestFileModificationTime = Long.MAX_VALUE;\n\n    /**\n     * The youngest file in the bundle in millis since epoch",
    "code_after_change": "package emissary.pickup;\n\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.UUID;\n\nimport emissary.util.xml.JDOMUtil;\nimport org.jdom2.Document;\nimport org.jdom2.Element;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Used to communicate between the TreePickUpPlace and TreeSpace about a set of files to process.\n * \n * Two times are tracked for the files in each work bundle - the \"youngest\" modification time and the \"oldest\"\n * modification time, both initially entered as time from the epoch. However, the concept of \"youngest\" and \"oldest\" is\n * relative to the construction time, so that:\n * <p>\n * getOldestFileModificationTime() &lt;= getYoungestFileModificationTime()\n */\npublic final class WorkBundle implements Comparable<WorkBundle> {\n\n    private static final Logger logger = LoggerFactory.getLogger(WorkBundle.class);\n\n    static final int MAX_UNITS = 1024;\n\n    // Unique ID for this work bundle\n    String bundleId;\n\n    // Configured output root for finding data on remote side\n    String outputRoot;\n\n    // Configuration passed to remote side for producing output name\n    String eatPrefix;\n\n    // Database case id for the work in this bundle\n    String caseId = null;\n\n    // Priority of this work bundle\n    int priority = Priority.DEFAULT;\n\n    // Flag to note if the bundle is in simple mode\n    boolean simpleMode = false;\n\n    List<WorkUnit> workUnitList = new ArrayList<>();\n\n    // Where being processed\n    String sentTo;\n\n    // Cumulative errors in processing tries\n    int errorCount = 0;\n\n    /**\n     * The oldest file in the bundle in millis since epoch\n     */\n    long oldestFileModificationTime = Long.MAX_VALUE;\n\n    /**\n     * The youngest file in the bundle in millis since epoch\n     */\n    long youngestFileModificationTime = Long.MIN_VALUE;\n",
    "patch": "@@ -1,6 +1,8 @@\n package emissary.pickup;\n \n-import java.io.Serializable;\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n import java.util.ArrayList;\n import java.util.Iterator;\n import java.util.List;\n@@ -21,13 +23,12 @@\n  * <p>\n  * getOldestFileModificationTime() &lt;= getYoungestFileModificationTime()\n  */\n-public class WorkBundle implements Serializable, Comparable<WorkBundle> {\n-\n-    // Serializable\n-    static final long serialVersionUID = 6339812801001572532L;\n+public final class WorkBundle implements Comparable<WorkBundle> {\n \n     private static final Logger logger = LoggerFactory.getLogger(WorkBundle.class);\n \n+    static final int MAX_UNITS = 1024;\n+\n     // Unique ID for this work bundle\n     String bundleId;\n \n@@ -110,6 +111,80 @@ public WorkBundle(WorkBundle that) {\n         resetBundleId();\n     }\n \n+    /**\n+     * Deserialize a WorkBundle from a DataInputStream\n+     *\n+     * @param in the stream to read from\n+     * @return the deserialized WorkBundle\n+     * @throws IOException if there is a problem reading the stream or it contains more than <code>MAX_UNITS</code> work\n+     *         units.\n+     */\n+    public static WorkBundle readFromStream(DataInputStream in) throws IOException {\n+        WorkBundle wb = new WorkBundle();\n+        wb.bundleId = readUTFOrNull(in);\n+        wb.outputRoot = readUTFOrNull(in);\n+        wb.eatPrefix = readUTFOrNull(in);\n+        wb.caseId = readUTFOrNull(in);\n+        wb.sentTo = readUTFOrNull(in);\n+        wb.errorCount = in.readInt();\n+        wb.priority = in.readInt();\n+        wb.simpleMode = in.readBoolean();\n+        wb.oldestFileModificationTime = in.readLong();\n+        wb.youngestFileModificationTime = in.readLong();\n+        wb.totalFileSize = in.readLong();\n+        int workUnitSize = in.readInt();\n+        if (workUnitSize > MAX_UNITS) {\n+            throw new IOException(\n+                    \"Exception when reading: WorkBundle may not contain more then \" + MAX_UNITS + \" WorkUnits (saw: \" + workUnitSize + \").\");\n+        }\n+        for (int i = 0; i < workUnitSize; i++) {\n+            wb.addWorkUnit(WorkUnit.readFromStream(in));\n+        }\n+        return wb;\n+    }\n+\n+    /**\n+     * Serialize this WorkBundle to a DataOutputStream\n+     *\n+     * @param out the stream to write to.\n+     * @throws IOException if there is a problem writing to the stream.\n+     */\n+    public void writeToStream(DataOutputStream out) throws IOException {\n+        writeUTFOrNull(bundleId, out);\n+        writeUTFOrNull(outputRoot, out);\n+        writeUTFOrNull(eatPrefix, out);\n+        writeUTFOrNull(caseId, out);\n+        writeUTFOrNull(sentTo, out);\n+        out.writeInt(errorCount);\n+        out.writeInt(priority);\n+        out.writeBoolean(simpleMode);\n+        out.writeLong(oldestFileModificationTime);\n+        out.writeLong(youngestFileModificationTime);\n+        out.writeLong(totalFileSize);\n+        out.writeInt(workUnitList.size());\n+        if (workUnitList.size() > MAX_UNITS) {\n+            throw new IOException(\n+                    \"Exception when writing: WorkBundle may not contain more then \" + MAX_UNITS + \" WorkUnits (saw: \" + workUnitList.size() + \").\");\n+        }\n+        for (WorkUnit u : workUnitList) {\n+            u.writeToStream(out);\n+        }\n+    }\n+\n+    static String readUTFOrNull(DataInputStream in) throws IOException {\n+        if (in.readBoolean()) {\n+            return in.readUTF();\n+        }\n+        return null;\n+    }\n+\n+    static void writeUTFOrNull(String s, DataOutputStream out) throws IOException {\n+        out.writeBoolean(s != null);\n+        if (s != null) {\n+            out.writeUTF(s);\n+        }\n+    }\n+\n     /**\n      * Set the work bundle id\n      * \n@@ -204,8 +279,13 @@ public Iterator<WorkUnit> getWorkUnitIterator() {\n      *\n      * @param workUnit the workUnit to add\n      * @return number of WorkUnits in list after add\n+     * @throws IllegalStateException if adding the unit would cause the bundle to contain more than <code>MAX_UNITS</code>\n+     *         work units\n      */\n     public int addWorkUnit(WorkUnit workUnit) {\n+        if (workUnitList.size() >= MAX_UNITS) {\n+            throw new IllegalStateException(\"WorkBundle may not contain more than \" + MAX_UNITS + \" WorkUnits.\");\n+        }\n         workUnitList.add(workUnit);\n         return size();\n     }\n@@ -215,10 +295,14 @@ public int addWorkUnit(WorkUnit workUnit) {\n      * \n      * @param workUnit the workUnit to add\n      * @param fileModificationTimeInMillis the file modification time in milliseconds since epoch\n+     * @param fileSize the size of the file added.\n+     * @throws IllegalStateException if adding the unit would cause the bundle to contain more than <code>MAX_UNITS</code>\n+     *         work units\n      * @return number of files in this set after update\n      */\n     public int addWorkUnit(WorkUnit workUnit, long fileModificationTimeInMillis, long fileSize) {\n-        workUnitList.add(workUnit);\n+        addWorkUnit(workUnit);\n+\n         if (fileModificationTimeInMillis < oldestFileModificationTime) {\n             oldestFileModificationTime = fileModificationTimeInMillis;\n         }\n@@ -231,8 +315,16 @@ public int addWorkUnit(WorkUnit workUnit, long fileModificationTimeInMillis, lon\n \n     /**\n      * Add from a list, without adjusting file modification time tracking.\n+     * \n+     * @param list a list of WorkUnits to add to this bundle\n+     * @return the total size of WorkUnits in this bundle\n+     * @throws IllegalStateException if adding the units would cause the bundle to contain more than <code>MAX_UNITS</code>\n+     *         work units\n      */\n     protected int addWorkUnits(List<WorkUnit> list) { // This appears to only be used by unit tests and the copy constructor\n+        if (workUnitList.size() + list.size() > MAX_UNITS) {\n+            throw new IllegalStateException(\"WorkBundle may not contain more than \" + MAX_UNITS + \" WorkUnits.\");\n+        }\n         workUnitList.addAll(list);\n         return workUnitList.size();\n     }\n@@ -265,18 +357,22 @@ public Iterator<String> getFileNameIterator() {\n      * \n      * @param file string file name consistent with outputRoot\n      * @return number of files in this set after update\n+     * @throws IllegalStateException if adding the file would cause the bundle to contain more than <code>MAX_UNITS</code>\n+     *         work units\n      */\n     public int addFileName(String file) {\n-        workUnitList.add(new WorkUnit(file));\n-        return size();\n+        return addWorkUnit(new WorkUnit(file));\n     }\n \n     /**\n      * Add a file to the list\n      * \n      * @param file string file name consistent with outputRoot\n      * @param fileModificationTimeInMillis the file modification time in milliseconds since epoch\n+     * @param fileSize the size of the file being added\n      * @return number of files in this set after update\n+     * @throws IllegalStateException if adding the file would cause the bundle to contain more than <code>MAX_UNITS</code>\n+     *         work units\n      */\n     public int addFileName(String file, long fileModificationTimeInMillis, long fileSize) {\n         return addWorkUnit(new WorkUnit(file), fileModificationTimeInMillis, fileSize);\n@@ -287,21 +383,27 @@ public int addFileName(String file, long fileModificationTimeInMillis, long file\n      * \n      * @param file string file names consistent with outputRoot\n      * @return number of files in this set after update\n+     * @throws IllegalStateException if adding the files would cause the bundle to contain more than <code>MAX_UNITS</code>\n+     *         work units\n      */\n     protected int addFileNames(String[] file) { // This appears to only be used by unit tests\n-        for (int i = 0; file != null && i < file.length; i++) {\n-            workUnitList.add(new WorkUnit(file[i]));\n+        for (String f : file) {\n+            addWorkUnit(new WorkUnit(f));\n         }\n         return size();\n     }\n \n     /**\n      * Add from a list, without adjusting file modification time tracking.\n+     * \n+     * @param list the list of files to add\n+     * @throws IllegalStateException if adding the files would cause the bundle to contain more than <code>MAX_UNITS</code>\n+     *         work units\n      */\n     protected int addFileNames(List<String> list) { // This appears to only be used by unit tests and the copy\n                                                     // constructor\n         for (String file : list) {\n-            workUnitList.add(new WorkUnit(file));\n+            addWorkUnit(new WorkUnit(file));\n         }\n         return size();\n     }",
    "function_modified_lines": {
      "added": [
        "public final class WorkBundle implements Comparable<WorkBundle> {\n",
        "    static final int MAX_UNITS = 1024;\n",
        "\n"
      ],
      "deleted": [
        "public class WorkBundle implements Serializable, Comparable<WorkBundle> {\n",
        "\n",
        "    // Serializable\n",
        "    static final long serialVersionUID = 6339812801001572532L;\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Emissary is a distributed, peer-to-peer, data-driven workflow framework. Emissary 6.4.0 is vulnerable to Unsafe Deserialization of post-authenticated requests to the [`WorkSpaceClientEnqueue.action`](https://github.com/NationalSecurityAgency/emissary/blob/30c54ef16c6eb6ed09604a929939fb9f66868382/src/main/java/emissary/server/mvc/internal/WorkSpaceClientEnqueueAction.java) REST endpoint. This issue may lead to post-auth Remote Code Execution. This issue has been patched in version 6.5.0. As a workaround, one can disable network access to Emissary from untrusted sources.",
    "id": 12494
  },
  {
    "cve_id": "CVE-2022-41958",
    "code_before_change": "package com.chaitin.xray.form;\n\nimport com.chaitin.xray.Application;\nimport com.chaitin.xray.model.Const;\nimport com.chaitin.xray.model.DB;\nimport com.chaitin.xray.model.Poc;\nimport com.chaitin.xray.model.XrayCmd;\nimport com.chaitin.xray.utils.*;\nimport com.formdev.flatlaf.FlatLightLaf;\nimport com.intellij.uiDesigner.core.GridConstraints;\nimport com.intellij.uiDesigner.core.GridLayoutManager;\nimport com.intellij.uiDesigner.core.Spacer;\nimport org.apache.log4j.LogManager;\nimport org.apache.log4j.Logger;\nimport org.yaml.snakeyaml.Yaml;\n\nimport javax.swing.*;\nimport javax.swing.border.TitledBorder;\nimport java.awt.*;\nimport java.awt.event.MouseAdapter;\nimport java.awt.event.MouseEvent;\nimport java.io.*;\nimport java.net.URI;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.*;\nimport java.util.List;\n\npublic class MainForm {\n    private static final Logger logger = LogManager.getLogger(MainForm.class);\n\n    public static MainForm instance;\n    private XrayCmd xrayCmd;\n    public static String configStr;\n    public static String configTemplate;\n    public static String configPath;\n    public static Map<String, Object> configObj;\n    private static ArrayList<JCheckBox> checkBoxList;\n    private static boolean pluginAll = false;\n    private static String outputFilePath;\n    private static final List<String> existOutputList = new ArrayList<>();\n    private static DB db;\n\n    private JButton choseDirButton;\n    private JPanel SuperXray;\n    private JPanel pathButtonPanel;\n    private JLabel xrayPathLabel;\n    private JTextField xrayPathTextField;\n    private JLabel noteLabel;\n    private JPanel configPanel;\n    private JPanel bottomPanel;",
    "code_after_change": "package com.chaitin.xray.form;\n\nimport com.chaitin.xray.Application;\nimport com.chaitin.xray.model.Const;\nimport com.chaitin.xray.model.DB;\nimport com.chaitin.xray.model.Poc;\nimport com.chaitin.xray.model.XrayCmd;\nimport com.chaitin.xray.utils.*;\nimport com.formdev.flatlaf.FlatLightLaf;\nimport com.intellij.uiDesigner.core.GridConstraints;\nimport com.intellij.uiDesigner.core.GridLayoutManager;\nimport com.intellij.uiDesigner.core.Spacer;\nimport org.apache.log4j.LogManager;\nimport org.apache.log4j.Logger;\nimport org.yaml.snakeyaml.LoaderOptions;\nimport org.yaml.snakeyaml.Yaml;\nimport org.yaml.snakeyaml.constructor.SafeConstructor;\n\nimport javax.swing.*;\nimport javax.swing.border.TitledBorder;\nimport java.awt.*;\nimport java.awt.event.MouseAdapter;\nimport java.awt.event.MouseEvent;\nimport java.io.*;\nimport java.net.URI;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.*;\nimport java.util.List;\n\npublic class MainForm {\n    private static final Logger logger = LogManager.getLogger(MainForm.class);\n\n    public static MainForm instance;\n    private XrayCmd xrayCmd;\n    public static String configStr;\n    public static String configTemplate;\n    public static String configPath;\n    public static Map<String, Object> configObj;\n    private static ArrayList<JCheckBox> checkBoxList;\n    private static boolean pluginAll = false;\n    private static String outputFilePath;\n    private static final List<String> existOutputList = new ArrayList<>();\n    private static DB db;\n\n    private JButton choseDirButton;\n    private JPanel SuperXray;\n    private JPanel pathButtonPanel;\n    private JLabel xrayPathLabel;\n    private JTextField xrayPathTextField;\n    private JLabel noteLabel;",
    "patch": "@@ -12,7 +12,9 @@\n import com.intellij.uiDesigner.core.Spacer;\n import org.apache.log4j.LogManager;\n import org.apache.log4j.Logger;\n+import org.yaml.snakeyaml.LoaderOptions;\n import org.yaml.snakeyaml.Yaml;\n+import org.yaml.snakeyaml.constructor.SafeConstructor;\n \n import javax.swing.*;\n import javax.swing.border.TitledBorder;\n@@ -224,7 +226,7 @@ public void reloadConfig(boolean init, boolean reset) {\n         }\n         configTemplate = configStr;\n \n-        Yaml yaml = new Yaml();\n+        Yaml yaml = new Yaml(new SafeConstructor(new LoaderOptions()));\n         configObj = yaml.load(configStr);\n \n         try {\n@@ -684,7 +686,7 @@ public void initPluginSave() {\n     }\n \n     public void refreshConfig() {\n-        Yaml yaml = new Yaml();\n+        Yaml yaml = new Yaml(new SafeConstructor(new LoaderOptions()));\n         StringWriter writer = new StringWriter();\n         yaml.dump(configObj, writer);\n         configStr = writer.toString();",
    "function_modified_lines": {
      "added": [
        "import org.yaml.snakeyaml.LoaderOptions;\n",
        "import org.yaml.snakeyaml.constructor.SafeConstructor;\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "super-xray is a web vulnerability scanning tool. Versions prior to 0.7 assumed trusted input for the program config which is stored in a yaml file. An attacker with local access to the file could exploit this and compromise the program. This issue has been addressed in commit `4d0d5966` and will be included in future releases. Users are advised to upgrade. There are no known workarounds for this issue.",
    "id": 12667
  },
  {
    "cve_id": "CVE-2023-36480",
    "code_before_change": "{\n\t/**\n\t * Bin name. Current limit is 15 characters.\n\t */\n\tpublic final String name;\n\n\t/**\n\t * Bin value.\n\t */\n\tpublic final Value value;\n\n\t/**\n\t * Constructor, specifying bin name and string value.\n\t *\n\t * @param name\t\tbin name, current limit is 15 characters\n\t * @param value\t\tbin value\n\t */\n\tpublic Bin(String name, String value) {\n\t\tthis.name = name;\n\t\tthis.value = Value.get(value);\n\t}\n\n\t/**\n\t * Constructor, specifying bin name and byte array value.\n\t *\n\t * @param name\t\tbin name, current limit is 15 characters\n\t * @param value\t\tbin value\n\t */\n\tpublic Bin(String name, byte[] value) {\n\t\tthis.name = name;\n\t\tthis.value = Value.get(value);\n\t}\n\n\t/**\n\t * Constructor, specifying bin name, byte array value and particle type.\n\t * For internal use only.\n\t *\n\t * @param name\t\tbin name, current limit is 15 characters\n\t * @param value\t\tbin value\n\t * @param type\t\tbin type, see {@link com.aerospike.client.command.ParticleType}\n\t */\n\tpublic Bin(String name, byte[] value, int type) {\n\t\tthis.name = name;\n\t\tthis.value = Value.get(value, type);\n\t}\n\n\t/**\n\t * Constructor, specifying bin name and byte array segment value.\n\t *\n\t * @param name\t\tbin name, current limit is 15 characters\n\t * @param value\t\tbyte array value\n\t * @param offset\tbyte array segment offset\n\t * @param length\tbyte array segment length\n\t */\n\tpublic Bin(String name, byte[] value, int offset, int length) {\n\t\tthis.name = name;\n\t\tthis.value = Value.get(value, offset, length);\n\t}\n\n\t/**\n\t * Constructor, specifying bin name and byte value.\n\t *\n\t * @param name\t\tbin name, current limit is 15 characters\n\t * @param value\t\tbin value\n\t */\n\tpublic Bin(String name, byte value) {\n\t\tthis.name = name;\n\t\tthis.value = Value.get(value);\n\t}\n\n\t/**\n\t * Constructor, specifying bin name and short value.\n\t * The server will convert all shorts to longs.\n\t *\n\t * @param name\t\tbin name, current limit is 15 characters\n\t * @param value\t\tbin value\n\t */\n\tpublic Bin(String name, short value) {\n\t\tthis.name = name;\n\t\tthis.value = Value.get(value);\n\t}\n\n\t/**\n\t * Constructor, specifying bin name and integer value.\n\t * The server will convert all integers to longs.\n\t *\n\t * @param name\t\tbin name, current limit is 15 characters\n\t * @param value\t\tbin value\n\t */\n\tpublic Bin(String name, int value) {\n\t\tthis.name = name;\n\t\tthis.value = Value.get(value);\n\t}\n\n\t/**\n\t * Constructor, specifying bin name and long value.\n\t *\n\t * @param name\t\tbin name, current limit is 15 characters\n\t * @param value\t\tbin value\n\t */\n\tpublic Bin(String name, long value) {\n\t\tthis.name = name;\n\t\tthis.value = Value.get(value);\n\t}\n\n\t/**\n\t * Constructor, specifying bin name and double value.\n\t *\n\t * @param name\t\tbin name, current limit is 15 characters\n\t * @param value\t\tbin value\n\t */\n\tpublic Bin(String name, double value) {\n\t\tthis.name = name;\n\t\tthis.value = Value.get(value);\n\t}\n\n\t/**\n\t * Constructor, specifying bin name and float value.\n\t *\n\t * @param name\t\tbin name, current limit is 15 characters\n\t * @param value\t\tbin value\n\t */\n\tpublic Bin(String name, float value) {\n\t\tthis.name = name;\n\t\tthis.value = Value.get(value);\n\t}\n\n\t/**\n\t * Constructor, specifying bin name and boolean value.\n\t * Either a boolean or integer bin is sent to the server, depending\n\t * on configuration {@link com.aerospike.client.Value#UseBoolBin}.\n\t *\n\t * @param name\t\tbin name, current limit is 15 characters\n\t * @param value\t\tbin value\n\t */\n\tpublic Bin(String name, boolean value) {\n\t\tthis.name = name;\n\t\tthis.value = Value.get(value);\n\t}\n\n\t/**\n\t * Create bin with a list value.  The list value will be serialized as a server list type.\n\t *\n\t * @param name\t\tbin name, current limit is 15 characters\n\t * @param value\t\tbin value\n\t */\n\tpublic Bin(String name, List<?> value) {\n\t\tthis.name = name;\n\t\tthis.value = Value.get(value);\n\t}\n\n\t/**\n\t * Create bin with a map value.  The map value will be serialized as a server map type.\n\t *\n\t * @param name\t\tbin name, current limit is 15 characters\n\t * @param value\t\tbin value\n\t */\n\tpublic Bin(String name, Map<?,?> value) {\n\t\tthis.name = name;\n\t\tthis.value = Value.get(value);\n\t}\n\n\t/**\n\t * Create bin with a sorted map value.  The map value will be serialized as a server ordered map type.\n\t *\n\t * @param name\t\tbin name, current limit is 15 characters\n\t * @param value\t\tbin value\n\t */\n\tpublic Bin(String name, SortedMap<?,?> value) {\n\t\tthis.name = name;\n\t\tthis.value = Value.get(value);\n\t}\n\n\t/**\n\t * This constructor is deprecated.\n\t * Use {@link Bin#Bin(String, Map)} if the map is unsorted (like HashMap).\n\t * Use {@link Bin#Bin(String, SortedMap)} if the map is sorted (like TreeMap).\n\t * <p>\n\t * Create bin with a map value and order.  The map value will be serialized as a server map type.\n\t *\n\t * @param name\t\tbin name, current limit is 15 characters\n\t * @param value\t\tbin value, pass in a {@link java.util.SortedMap} instance if map order is sorted.\n\t * @param mapOrder\tmap sorted order.\n\t */\n\t@Deprecated\n\tpublic Bin(String name, Map<?,?> value, MapOrder mapOrder) {\n\t\tthis.name = name;\n\t\tthis.value = Value.get(value, mapOrder);\n\t}\n\n\t/**\n\t * Create a map bin from a list of key/value entries.  The value will be serialized as a\n\t * server map type with specified mapOrder.\n\t *\n\t * @param name\t\tbin name, current limit is 15 characters\n\t * @param value\t\tlist of key/value entries already in desired sorted order\n\t * @param mapOrder\tmap sorted order\n\t */\n\tpublic Bin(String name, List<? extends Entry<?,?>> value, MapOrder mapOrder) {\n\t\tthis.name = name;\n\t\tthis.value = Value.get(value, mapOrder);\n\t}\n\n\t/**\n\t * Constructor, specifying bin name and value.\n\t *\n\t * @param name\t\tbin name, current limit is 15 characters\n\t * @param value\t\tbin value\n\t */\n\tpublic Bin(String name, Value value) {\n\t\tthis.name = name;\n\t\tthis.value = value;\n\t}\n\n\t/**\n\t * Create bin with an object value. This is the slowest of the Bin constructors because the type\n\t * must be determined using multiple \"instanceof\" checks. If the object type is unrecognized,\n\t * the default java serializer is used.\n\t * <p>\n\t * To disable this constructor, set {@link com.aerospike.client.Value#DisableSerializer} to true.\n\t *\n\t * @param name\t\tbin name, current limit is 15 characters.\n\t * @param value\t\tbin value\n\t */\n\tpublic Bin(String name, Object value) {\n\t\tthis.name = name;\n\t\tthis.value = Value.get(value);\n\t}\n\n\t/**\n\t * Create bin with a blob value.  The value will be java serialized.\n\t * This method is faster than the bin object constructor because the blob is converted\n\t * directly instead of using multiple \"instanceof\" type checks with a blob default.\n\t * <p>\n\t * To disable this method, set {@link com.aerospike.client.Value#DisableSerializer} to true.\n\t *\n\t * @param name\t\tbin name, current limit is 15 characters.\n\t * @param value\t\tbin value\n\t */\n\tpublic static Bin asBlob(String name, Object value) {\n\t\treturn new Bin(name, Value.getAsBlob(value));\n\t}\n\n\t/**\n\t * Create bin with a null value. This is useful for bin deletions within a record.\n\t *\n\t * @param name\t\tbin name, current limit is 15 characters\n\t */\n\tpublic static Bin asNull(String name) {\n\t\treturn new Bin(name, Value.getAsNull());\n\t}\n\n\t/**\n\t * Create bin with a GeoJSON value.\n\t *\n\t * @param name\t\tbin name, current limit is 15 characters\n\t * @param value\t\tbin value\n\t */\n\tpublic static Bin asGeoJSON(String name, String value) {\n\t\treturn new Bin(name, Value.getAsGeoJSON(value));\n\t}\n\n\t/**\n\t * Return string representation of bin.\n\t */\n\t@Override\n\tpublic String toString() {\n\t\treturn name + ':' + value;\n\t}\n\n\t/**\n\t * Compare Bin for equality.\n\t */\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (this == obj)\n\t\t\treturn true;\n\t\tif (obj == null)\n\t\t\treturn false;\n\t\tif (getClass() != obj.getClass())\n\t\t\treturn false;\n\t\tBin other = (Bin) obj;\n\t\tif (name == null) {\n\t\t\tif (other.name != null)\n\t\t\t\treturn false;\n\t\t} else if (!name.equals(other.name))\n\t\t\treturn false;\n\t\tif (value == null) {\n\t\t\tif (other.value != null)\n\t\t\t\treturn false;\n\t\t} else if (!value.equals(other.value))\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\t/**\n\t * Return hash code for Bin.\n\t */\n\t@Override\n\tpublic int hashCode() {\n\t\tfinal int prime = 31;\n\t\tint result = 1;\n\t\tresult = prime * result + ((name == null) ? 0 : name.hashCode());\n\t\tresult = prime * result + ((value == null) ? 0 : value.hashCode());\n\t\treturn result;\n\t}\n}",
    "code_after_change": "{\n\t/**\n\t * Bin name. Current limit is 15 characters.\n\t */\n\tpublic final String name;\n\n\t/**\n\t * Bin value.\n\t */\n\tpublic final Value value;\n\n\t/**\n\t * Constructor, specifying bin name and string value.\n\t *\n\t * @param name\t\tbin name, current limit is 15 characters\n\t * @param value\t\tbin value\n\t */\n\tpublic Bin(String name, String value) {\n\t\tthis.name = name;\n\t\tthis.value = Value.get(value);\n\t}\n\n\t/**\n\t * Constructor, specifying bin name and byte array value.\n\t *\n\t * @param name\t\tbin name, current limit is 15 characters\n\t * @param value\t\tbin value\n\t */\n\tpublic Bin(String name, byte[] value) {\n\t\tthis.name = name;\n\t\tthis.value = Value.get(value);\n\t}\n\n\t/**\n\t * Constructor, specifying bin name, byte array value and particle type.\n\t * For internal use only.\n\t *\n\t * @param name\t\tbin name, current limit is 15 characters\n\t * @param value\t\tbin value\n\t * @param type\t\tbin type, see {@link com.aerospike.client.command.ParticleType}\n\t */\n\tpublic Bin(String name, byte[] value, int type) {\n\t\tthis.name = name;\n\t\tthis.value = Value.get(value, type);\n\t}\n\n\t/**\n\t * Constructor, specifying bin name and byte array segment value.\n\t *\n\t * @param name\t\tbin name, current limit is 15 characters\n\t * @param value\t\tbyte array value\n\t * @param offset\tbyte array segment offset\n\t * @param length\tbyte array segment length\n\t */\n\tpublic Bin(String name, byte[] value, int offset, int length) {\n\t\tthis.name = name;\n\t\tthis.value = Value.get(value, offset, length);\n\t}\n\n\t/**\n\t * Constructor, specifying bin name and byte value.\n\t *\n\t * @param name\t\tbin name, current limit is 15 characters\n\t * @param value\t\tbin value\n\t */\n\tpublic Bin(String name, byte value) {\n\t\tthis.name = name;\n\t\tthis.value = Value.get(value);\n\t}\n\n\t/**\n\t * Constructor, specifying bin name and short value.\n\t * The server will convert all shorts to longs.\n\t *\n\t * @param name\t\tbin name, current limit is 15 characters\n\t * @param value\t\tbin value\n\t */\n\tpublic Bin(String name, short value) {\n\t\tthis.name = name;\n\t\tthis.value = Value.get(value);\n\t}\n\n\t/**\n\t * Constructor, specifying bin name and integer value.\n\t * The server will convert all integers to longs.\n\t *\n\t * @param name\t\tbin name, current limit is 15 characters\n\t * @param value\t\tbin value\n\t */\n\tpublic Bin(String name, int value) {\n\t\tthis.name = name;\n\t\tthis.value = Value.get(value);\n\t}\n\n\t/**\n\t * Constructor, specifying bin name and long value.\n\t *\n\t * @param name\t\tbin name, current limit is 15 characters\n\t * @param value\t\tbin value\n\t */\n\tpublic Bin(String name, long value) {\n\t\tthis.name = name;\n\t\tthis.value = Value.get(value);\n\t}\n\n\t/**\n\t * Constructor, specifying bin name and double value.\n\t *\n\t * @param name\t\tbin name, current limit is 15 characters\n\t * @param value\t\tbin value\n\t */\n\tpublic Bin(String name, double value) {\n\t\tthis.name = name;\n\t\tthis.value = Value.get(value);\n\t}\n\n\t/**\n\t * Constructor, specifying bin name and float value.\n\t *\n\t * @param name\t\tbin name, current limit is 15 characters\n\t * @param value\t\tbin value\n\t */\n\tpublic Bin(String name, float value) {\n\t\tthis.name = name;\n\t\tthis.value = Value.get(value);\n\t}\n\n\t/**\n\t * Constructor, specifying bin name and boolean value.\n\t * Either a boolean or integer bin is sent to the server, depending\n\t * on configuration {@link com.aerospike.client.Value#UseBoolBin}.\n\t *\n\t * @param name\t\tbin name, current limit is 15 characters\n\t * @param value\t\tbin value\n\t */\n\tpublic Bin(String name, boolean value) {\n\t\tthis.name = name;\n\t\tthis.value = Value.get(value);\n\t}\n\n\t/**\n\t * Create bin with a list value.  The list value will be serialized as a server list type.\n\t *\n\t * @param name\t\tbin name, current limit is 15 characters\n\t * @param value\t\tbin value\n\t */\n\tpublic Bin(String name, List<?> value) {\n\t\tthis.name = name;\n\t\tthis.value = Value.get(value);\n\t}\n\n\t/**\n\t * Create bin with a map value.  The map value will be serialized as a server map type.\n\t *\n\t * @param name\t\tbin name, current limit is 15 characters\n\t * @param value\t\tbin value\n\t */\n\tpublic Bin(String name, Map<?,?> value) {\n\t\tthis.name = name;\n\t\tthis.value = Value.get(value);\n\t}\n\n\t/**\n\t * Create bin with a sorted map value.  The map value will be serialized as a server ordered map type.\n\t *\n\t * @param name\t\tbin name, current limit is 15 characters\n\t * @param value\t\tbin value\n\t */\n\tpublic Bin(String name, SortedMap<?,?> value) {\n\t\tthis.name = name;\n\t\tthis.value = Value.get(value);\n\t}\n\n\t/**\n\t * This constructor is deprecated.\n\t * Use {@link Bin#Bin(String, Map)} if the map is unsorted (like HashMap).\n\t * Use {@link Bin#Bin(String, SortedMap)} if the map is sorted (like TreeMap).\n\t * <p>\n\t * Create bin with a map value and order.  The map value will be serialized as a server map type.\n\t *\n\t * @param name\t\tbin name, current limit is 15 characters\n\t * @param value\t\tbin value, pass in a {@link java.util.SortedMap} instance if map order is sorted.\n\t * @param mapOrder\tmap sorted order.\n\t */\n\t@Deprecated\n\tpublic Bin(String name, Map<?,?> value, MapOrder mapOrder) {\n\t\tthis.name = name;\n\t\tthis.value = Value.get(value, mapOrder);\n\t}\n\n\t/**\n\t * Create a map bin from a list of key/value entries.  The value will be serialized as a\n\t * server map type with specified mapOrder.\n\t *\n\t * @param name\t\tbin name, current limit is 15 characters\n\t * @param value\t\tlist of key/value entries already in desired sorted order\n\t * @param mapOrder\tmap sorted order\n\t */\n\tpublic Bin(String name, List<? extends Entry<?,?>> value, MapOrder mapOrder) {\n\t\tthis.name = name;\n\t\tthis.value = Value.get(value, mapOrder);\n\t}\n\n\t/**\n\t * Constructor, specifying bin name and value.\n\t *\n\t * @param name\t\tbin name, current limit is 15 characters\n\t * @param value\t\tbin value\n\t */\n\tpublic Bin(String name, Value value) {\n\t\tthis.name = name;\n\t\tthis.value = value;\n\t}\n\n\t/**\n\t * Create bin with a null value. This is useful for bin deletions within a record.\n\t *\n\t * @param name\t\tbin name, current limit is 15 characters\n\t */\n\tpublic static Bin asNull(String name) {\n\t\treturn new Bin(name, Value.getAsNull());\n\t}\n\n\t/**\n\t * Create bin with a GeoJSON value.\n\t *\n\t * @param name\t\tbin name, current limit is 15 characters\n\t * @param value\t\tbin value\n\t */\n\tpublic static Bin asGeoJSON(String name, String value) {\n\t\treturn new Bin(name, Value.getAsGeoJSON(value));\n\t}\n\n\t/**\n\t * Return string representation of bin.\n\t */\n\t@Override\n\tpublic String toString() {\n\t\treturn name + ':' + value;\n\t}\n\n\t/**\n\t * Compare Bin for equality.\n\t */\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (this == obj)\n\t\t\treturn true;\n\t\tif (obj == null)\n\t\t\treturn false;\n\t\tif (getClass() != obj.getClass())\n\t\t\treturn false;\n\t\tBin other = (Bin) obj;\n\t\tif (name == null) {\n\t\t\tif (other.name != null)\n\t\t\t\treturn false;\n\t\t} else if (!name.equals(other.name))\n\t\t\treturn false;\n\t\tif (value == null) {\n\t\t\tif (other.value != null)\n\t\t\t\treturn false;\n\t\t} else if (!value.equals(other.value))\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\t/**\n\t * Return hash code for Bin.\n\t */\n\t@Override\n\tpublic int hashCode() {\n\t\tfinal int prime = 31;\n\t\tint result = 1;\n\t\tresult = prime * result + ((name == null) ? 0 : name.hashCode());\n\t\tresult = prime * result + ((value == null) ? 0 : value.hashCode());\n\t\treturn result;\n\t}\n}",
    "patch": "@@ -240,35 +240,6 @@ public Bin(String name, Value value) {\n \t\tthis.value = value;\n \t}\n \n-\t/**\n-\t * Create bin with an object value. This is the slowest of the Bin constructors because the type\n-\t * must be determined using multiple \"instanceof\" checks. If the object type is unrecognized,\n-\t * the default java serializer is used.\n-\t * <p>\n-\t * To disable this constructor, set {@link com.aerospike.client.Value#DisableSerializer} to true.\n-\t *\n-\t * @param name\t\tbin name, current limit is 15 characters.\n-\t * @param value\t\tbin value\n-\t */\n-\tpublic Bin(String name, Object value) {\n-\t\tthis.name = name;\n-\t\tthis.value = Value.get(value);\n-\t}\n-\n-\t/**\n-\t * Create bin with a blob value.  The value will be java serialized.\n-\t * This method is faster than the bin object constructor because the blob is converted\n-\t * directly instead of using multiple \"instanceof\" type checks with a blob default.\n-\t * <p>\n-\t * To disable this method, set {@link com.aerospike.client.Value#DisableSerializer} to true.\n-\t *\n-\t * @param name\t\tbin name, current limit is 15 characters.\n-\t * @param value\t\tbin value\n-\t */\n-\tpublic static Bin asBlob(String name, Object value) {\n-\t\treturn new Bin(name, Value.getAsBlob(value));\n-\t}\n-\n \t/**\n \t * Create bin with a null value. This is useful for bin deletions within a record.\n \t *",
    "function_modified_lines": {
      "added": [],
      "deleted": [
        "\t/**\n",
        "\t * Create bin with an object value. This is the slowest of the Bin constructors because the type\n",
        "\t * must be determined using multiple \"instanceof\" checks. If the object type is unrecognized,\n",
        "\t * the default java serializer is used.\n",
        "\t * <p>\n",
        "\t * To disable this constructor, set {@link com.aerospike.client.Value#DisableSerializer} to true.\n",
        "\t *\n",
        "\t * @param name\t\tbin name, current limit is 15 characters.\n",
        "\t * @param value\t\tbin value\n",
        "\t */\n",
        "\tpublic Bin(String name, Object value) {\n",
        "\t\tthis.name = name;\n",
        "\t\tthis.value = Value.get(value);\n",
        "\t}\n",
        "\n",
        "\t/**\n",
        "\t * Create bin with a blob value.  The value will be java serialized.\n",
        "\t * This method is faster than the bin object constructor because the blob is converted\n",
        "\t * directly instead of using multiple \"instanceof\" type checks with a blob default.\n",
        "\t * <p>\n",
        "\t * To disable this method, set {@link com.aerospike.client.Value#DisableSerializer} to true.\n",
        "\t *\n",
        "\t * @param name\t\tbin name, current limit is 15 characters.\n",
        "\t * @param value\t\tbin value\n",
        "\t */\n",
        "\tpublic static Bin asBlob(String name, Object value) {\n",
        "\t\treturn new Bin(name, Value.getAsBlob(value));\n",
        "\t}\n",
        "\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "The Aerospike Java client is a Java application that implements a network protocol to communicate with an Aerospike server. Prior to versions 7.0.0, 6.2.0, 5.2.0, and 4.5.0 some of the messages received from the server contain Java objects that the client deserializes when it encounters them without further validation. Attackers that manage to trick clients into communicating with a malicious server can include especially crafted objects in its responses that, once deserialized by the client, force it to execute arbitrary code. This can be abused to take control of the machine the client is running on. Versions 7.0.0, 6.2.0, 5.2.0, and 4.5.0 contain a patch for this issue.",
    "id": 12730
  },
  {
    "cve_id": "CVE-2023-36480",
    "code_before_change": "import java.nio.ByteBuffer;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.SortedMap;\nimport java.util.UUID;\n\nimport org.luaj.vm2.LuaBoolean;\nimport org.luaj.vm2.LuaDouble;\nimport org.luaj.vm2.LuaInteger;\nimport org.luaj.vm2.LuaNil;\nimport org.luaj.vm2.LuaString;\nimport org.luaj.vm2.LuaValue;\n\nimport com.aerospike.client.cdt.MapOrder;\nimport com.aerospike.client.command.Buffer;\nimport com.aerospike.client.command.ParticleType;\nimport com.aerospike.client.lua.LuaBytes;\nimport com.aerospike.client.lua.LuaInstance;\nimport com.aerospike.client.util.Packer;\n\n/**\n * Polymorphic value classes used to efficiently serialize objects into the wire protocol.\n */\npublic abstract class Value {\n\t/**\n\t * Should client send boolean particle type for a boolean bin.  If false,\n\t * an integer particle type (1 or 0) is sent instead. Must be false for server\n\t * versions less than 5.6 which do not support boolean bins. Can set to true for\n\t * server 5.6+.\n\t */\n\tpublic static boolean UseBoolBin = true;\n\n\t/**\n\t * Should default object serializer be disabled. If true, an exception will be thrown when\n\t * a default object serialization is attempted. Default object serialization is triggered\n\t * when a bin constructed by {@link com.aerospike.client.Bin#Bin(String, Object)} or\n\t * {@link com.aerospike.client.Bin#asBlob(String, Object)} is used in a write command\n\t * with an unrecognized object type.\n\t */\n\tpublic static boolean DisableSerializer = false;\n\n\t/**\n\t * Should default object deserializer be disabled. If true, an exception will be thrown when\n\t * a default object deserialization is attempted. Default object serialization is triggered\n\t * when serialized data is read/parsed from the server. DisableDeserializer is separate from\n\t * DisableSerializer because there may be cases when no new serialization is allowed, but\n\t * existing serialized objects need to be supported.\n\t */\n\tpublic static boolean DisableDeserializer = false;\n\n\t/**\n\t * Should the client return a map when {@link com.aerospike.client.cdt.MapReturnType#KEY_VALUE}\n\t * is specified in a map read operation and the server returns a list of key/value pairs.\n\t */\n\tpublic static boolean ReturnMapForKeyValue = false;\n\n\t/**\n\t * Null value.\n\t */\n\tpublic static final Value NULL = NullValue.INSTANCE;\n\n\t/**\n\t * Infinity value to be used in CDT range comparisons only.\n\t */\n\tpublic static final Value INFINITY = new InfinityValue();\n\n\t/**\n\t * Wildcard value to be used in CDT range comparisons only.\n\t */\n\tpublic static final Value WILDCARD = new WildcardValue();\n\n\t/**\n\t * Get string or null value instance.\n\t */\n\tpublic static Value get(String value) {\n\t\treturn (value == null)? NullValue.INSTANCE : new StringValue(value);\n\t}\n\n\t/**\n\t * Get byte array or null value instance.\n\t */\n\tpublic static Value get(byte[] value) {\n\t\treturn (value == null)? NullValue.INSTANCE : new BytesValue(value);\n\t}\n\n\t/**",
    "code_after_change": "package com.aerospike.client;\n\nimport java.nio.ByteBuffer;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.SortedMap;\nimport java.util.UUID;\n\nimport org.luaj.vm2.LuaBoolean;\nimport org.luaj.vm2.LuaDouble;\nimport org.luaj.vm2.LuaInteger;\nimport org.luaj.vm2.LuaNil;\nimport org.luaj.vm2.LuaString;\nimport org.luaj.vm2.LuaValue;\n\nimport com.aerospike.client.cdt.MapOrder;\nimport com.aerospike.client.command.Buffer;\nimport com.aerospike.client.command.ParticleType;\nimport com.aerospike.client.lua.LuaBytes;\nimport com.aerospike.client.lua.LuaInstance;\nimport com.aerospike.client.util.Packer;\n\n/**\n * Polymorphic value classes used to efficiently serialize objects into the wire protocol.\n */\npublic abstract class Value {\n\t/**\n\t * Should client send boolean particle type for a boolean bin.  If false,\n\t * an integer particle type (1 or 0) is sent instead. Must be false for server\n\t * versions less than 5.6 which do not support boolean bins. Can set to true for\n\t * server 5.6+.\n\t */\n\tpublic static boolean UseBoolBin = true;\n\n\t/**\n\t * Should the client return a map when {@link com.aerospike.client.cdt.MapReturnType#KEY_VALUE}\n\t * is specified in a map read operation and the server returns a list of key/value pairs.\n\t */\n\tpublic static boolean ReturnMapForKeyValue = false;\n\n\t/**\n\t * Null value.\n\t */\n\tpublic static final Value NULL = NullValue.INSTANCE;\n\n\t/**\n\t * Infinity value to be used in CDT range comparisons only.\n\t */\n\tpublic static final Value INFINITY = new InfinityValue();\n\n\t/**\n\t * Wildcard value to be used in CDT range comparisons only.\n\t */\n\tpublic static final Value WILDCARD = new WildcardValue();\n\n\t/**\n\t * Get string or null value instance.\n\t */\n\tpublic static Value get(String value) {\n\t\treturn (value == null)? NullValue.INSTANCE : new StringValue(value);\n\t}\n\n\t/**\n\t * Get byte array or null value instance.\n\t */\n\tpublic static Value get(byte[] value) {\n\t\treturn (value == null)? NullValue.INSTANCE : new BytesValue(value);\n\t}\n\n\t/**\n\t * Get byte array with type or null value instance.\n\t */",
    "patch": "@@ -16,8 +16,6 @@\n  */\n package com.aerospike.client;\n \n-import java.io.ByteArrayOutputStream;\n-import java.io.ObjectOutputStream;\n import java.nio.ByteBuffer;\n import java.util.Arrays;\n import java.util.List;\n@@ -52,24 +50,6 @@ public abstract class Value {\n \t */\n \tpublic static boolean UseBoolBin = true;\n \n-\t/**\n-\t * Should default object serializer be disabled. If true, an exception will be thrown when\n-\t * a default object serialization is attempted. Default object serialization is triggered\n-\t * when a bin constructed by {@link com.aerospike.client.Bin#Bin(String, Object)} or\n-\t * {@link com.aerospike.client.Bin#asBlob(String, Object)} is used in a write command\n-\t * with an unrecognized object type.\n-\t */\n-\tpublic static boolean DisableSerializer = false;\n-\n-\t/**\n-\t * Should default object deserializer be disabled. If true, an exception will be thrown when\n-\t * a default object deserialization is attempted. Default object serialization is triggered\n-\t * when serialized data is read/parsed from the server. DisableDeserializer is separate from\n-\t * DisableSerializer because there may be cases when no new serialization is allowed, but\n-\t * existing serialized objects need to be supported.\n-\t */\n-\tpublic static boolean DisableDeserializer = false;\n-\n \t/**\n \t * Should the client return a map when {@link com.aerospike.client.cdt.MapReturnType#KEY_VALUE}\n \t * is specified in a map read operation and the server returns a list of key/value pairs.\n@@ -241,13 +221,6 @@ public static Value get(Value[] value) {\n \t\treturn (value == null)? NullValue.INSTANCE : new ValueArray(value);\n \t}\n \n-\t/**\n-\t * Get blob or null value instance.\n-\t */\n-\tpublic static Value getAsBlob(Object value) {\n-\t\treturn (value == null)? NullValue.INSTANCE : new BlobValue(value);\n-\t}\n-\n \t/**\n \t * Get GeoJSON or null value instance.\n \t */\n@@ -349,7 +322,7 @@ public static Value get(Object value) {\n \t\t\treturn new BytesValue(bb.array());\n \t\t}\n \n-\t\treturn new BlobValue(value);\n+\t\tthrow new AerospikeException(\"Unsupported type: \" + value.getClass().getName());\n \t}\n \n \t/**\n@@ -1260,88 +1233,6 @@ public long toLong() {\n \t\t}\n \t}\n \n-\t/**\n-\t * Blob value.\n-\t */\n-\tpublic static final class BlobValue extends Value {\n-\t\tprivate final Object object;\n-\t\tprivate byte[] bytes;\n-\n-\t\tpublic BlobValue(Object object) {\n-\t\t\tthis.object = object;\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic int estimateSize() throws AerospikeException.Serialize {\n-\t\t\tbytes = serialize(object);\n-\t\t\treturn bytes.length;\n-\t\t}\n-\n-\t\tpublic static byte[] serialize(Object val) {\n-\t\t\tif (DisableSerializer) {\n-\t\t\t\tthrow new AerospikeException(\"Object serializer has been disabled\");\n-\t\t\t}\n-\n-\t\t\ttry (ByteArrayOutputStream bstream = new ByteArrayOutputStream()) {\n-\t\t\t\ttry (ObjectOutputStream ostream = new ObjectOutputStream(bstream)) {\n-\t\t\t\t\tostream.writeObject(val);\n-\t\t\t\t}\n-\t\t\t\treturn bstream.toByteArray();\n-\t\t\t}\n-\t\t\tcatch (Throwable e) {\n-\t\t\t\tthrow new AerospikeException.Serialize(e);\n-\t\t\t}\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic int write(byte[] buffer, int offset) {\n-\t\t\tSystem.arraycopy(bytes, 0, buffer, offset, bytes.length);\n-\t\t\treturn bytes.length;\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void pack(Packer packer) {\n-\t\t\tpacker.packBlob(object);\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void validateKeyType() {\n-\t\t\tthrow new AerospikeException(ResultCode.PARAMETER_ERROR, \"Invalid key type: jblob\");\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic int getType() {\n-\t\t\treturn ParticleType.JBLOB;\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic Object getObject() {\n-\t\t\treturn object;\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic LuaValue getLuaValue(LuaInstance instance) {\n-\t\t\treturn LuaString.valueOf(bytes);\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic String toString() {\n-\t\t\treturn Buffer.bytesToHexString(bytes);\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic boolean equals(Object other) {\n-\t\t\treturn (other != null &&\n-\t\t\t\tthis.getClass().equals(other.getClass()) &&\n-\t\t\t\tthis.object.equals(((BlobValue)other).object));\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic int hashCode() {\n-\t\t\treturn object.hashCode();\n-\t\t}\n-\t}\n-\n \t/**\n \t * GeoJSON value.\n \t */",
    "function_modified_lines": {
      "added": [],
      "deleted": [
        "\t/**\n",
        "\t * Should default object serializer be disabled. If true, an exception will be thrown when\n",
        "\t * a default object serialization is attempted. Default object serialization is triggered\n",
        "\t * when a bin constructed by {@link com.aerospike.client.Bin#Bin(String, Object)} or\n",
        "\t * {@link com.aerospike.client.Bin#asBlob(String, Object)} is used in a write command\n",
        "\t * with an unrecognized object type.\n",
        "\t */\n",
        "\tpublic static boolean DisableSerializer = false;\n",
        "\n",
        "\t/**\n",
        "\t * Should default object deserializer be disabled. If true, an exception will be thrown when\n",
        "\t * a default object deserialization is attempted. Default object serialization is triggered\n",
        "\t * when serialized data is read/parsed from the server. DisableDeserializer is separate from\n",
        "\t * DisableSerializer because there may be cases when no new serialization is allowed, but\n",
        "\t * existing serialized objects need to be supported.\n",
        "\t */\n",
        "\tpublic static boolean DisableDeserializer = false;\n",
        "\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "The Aerospike Java client is a Java application that implements a network protocol to communicate with an Aerospike server. Prior to versions 7.0.0, 6.2.0, 5.2.0, and 4.5.0 some of the messages received from the server contain Java objects that the client deserializes when it encounters them without further validation. Attackers that manage to trick clients into communicating with a malicious server can include especially crafted objects in its responses that, once deserialized by the client, force it to execute arbitrary code. This can be abused to take control of the machine the client is running on. Versions 7.0.0, 6.2.0, 5.2.0, and 4.5.0 contain a patch for this issue.",
    "id": 12731
  },
  {
    "cve_id": "CVE-2023-36480",
    "code_before_change": "\n\t/**\n\t * Get sorted map or null value instance.\n\t */\n\tpublic static Value get(SortedMap<?,?> value) {\n\t\treturn (value == null)? NullValue.INSTANCE : new MapValue(value, MapOrder.KEY_ORDERED);\n\t}\n\n\t/**\n\t * This method is deprecated.\n\t * Use {@link #get(Map)} if the map is unsorted (like HashMap).\n\t * Use {@link #get(SortedMap)} if the map is sorted (like TreeMap).\n\t * <p>\n\t * Get map or null value instance.\n\t */\n\t@Deprecated\n\tpublic static Value get(Map<?,?> value, MapOrder order) {\n\t\treturn (value == null)? NullValue.INSTANCE : new MapValue(value, order);\n\t}\n\n\t/**\n\t * Get sorted map or null value instance.\n\t */\n\tpublic static Value get(List<? extends Entry<?,?>> value, MapOrder mapOrder) {\n\t\treturn (value == null)? NullValue.INSTANCE : new SortedMapValue(value, mapOrder);\n\t}\n\n\t/**\n\t * Get value array instance.\n\t */\n\tpublic static Value get(Value[] value) {\n\t\treturn (value == null)? NullValue.INSTANCE : new ValueArray(value);\n\t}\n\n\t/**\n\t * Get blob or null value instance.\n\t */\n\tpublic static Value getAsBlob(Object value) {\n\t\treturn (value == null)? NullValue.INSTANCE : new BlobValue(value);\n\t}\n\n\t/**\n\t * Get GeoJSON or null value instance.\n\t */\n\tpublic static Value getAsGeoJSON(String value) {\n\t\treturn (value == null)? NullValue.INSTANCE : new GeoJSONValue(value);\n\t}\n\n\t/**\n\t * Get HyperLogLog or null value instance.\n\t */\n\tpublic static Value getAsHLL(byte[] value) {\n\t\treturn (value == null)? NullValue.INSTANCE : new HLLValue(value);\n\t}\n\n\t/**\n\t * Get null value instance.\n\t */\n\tpublic static Value getAsNull() {\n\t\treturn NullValue.INSTANCE;\n\t}\n\n\t/**\n\t * Determine value given generic object.\n\t * This is the slowest of the Value get() methods.\n\t * Useful when copying records from one cluster to another.\n\t */\n\tpublic static Value get(Object value) {\n\t\tif (value == null) {\n\t\t\treturn NullValue.INSTANCE;\n\t\t}\n\n\t\tif (value instanceof Value) {\n\t\t\treturn (Value)value;\n\t\t}\n\n\t\tif (value instanceof byte[]) {",
    "code_after_change": "\t\treturn (value == null)? NullValue.INSTANCE : new MapValue(value);\n\t}\n\n\t/**\n\t * Get sorted map or null value instance.\n\t */\n\tpublic static Value get(SortedMap<?,?> value) {\n\t\treturn (value == null)? NullValue.INSTANCE : new MapValue(value, MapOrder.KEY_ORDERED);\n\t}\n\n\t/**\n\t * This method is deprecated.\n\t * Use {@link #get(Map)} if the map is unsorted (like HashMap).\n\t * Use {@link #get(SortedMap)} if the map is sorted (like TreeMap).\n\t * <p>\n\t * Get map or null value instance.\n\t */\n\t@Deprecated\n\tpublic static Value get(Map<?,?> value, MapOrder order) {\n\t\treturn (value == null)? NullValue.INSTANCE : new MapValue(value, order);\n\t}\n\n\t/**\n\t * Get sorted map or null value instance.\n\t */\n\tpublic static Value get(List<? extends Entry<?,?>> value, MapOrder mapOrder) {\n\t\treturn (value == null)? NullValue.INSTANCE : new SortedMapValue(value, mapOrder);\n\t}\n\n\t/**\n\t * Get value array instance.\n\t */\n\tpublic static Value get(Value[] value) {\n\t\treturn (value == null)? NullValue.INSTANCE : new ValueArray(value);\n\t}\n\n\t/**\n\t * Get GeoJSON or null value instance.\n\t */\n\tpublic static Value getAsGeoJSON(String value) {\n\t\treturn (value == null)? NullValue.INSTANCE : new GeoJSONValue(value);\n\t}\n\n\t/**\n\t * Get HyperLogLog or null value instance.\n\t */\n\tpublic static Value getAsHLL(byte[] value) {\n\t\treturn (value == null)? NullValue.INSTANCE : new HLLValue(value);\n\t}\n\n\t/**\n\t * Get null value instance.\n\t */\n\tpublic static Value getAsNull() {\n\t\treturn NullValue.INSTANCE;\n\t}\n\n\t/**\n\t * Determine value given generic object.\n\t * This is the slowest of the Value get() methods.\n\t * Useful when copying records from one cluster to another.\n\t */\n\tpublic static Value get(Object value) {\n\t\tif (value == null) {\n\t\t\treturn NullValue.INSTANCE;\n\t\t}\n\n\t\tif (value instanceof Value) {\n\t\t\treturn (Value)value;\n\t\t}\n\n\t\tif (value instanceof byte[]) {\n\t\t\treturn new BytesValue((byte[])value);\n\t\t}",
    "patch": "@@ -16,8 +16,6 @@\n  */\n package com.aerospike.client;\n \n-import java.io.ByteArrayOutputStream;\n-import java.io.ObjectOutputStream;\n import java.nio.ByteBuffer;\n import java.util.Arrays;\n import java.util.List;\n@@ -52,24 +50,6 @@ public abstract class Value {\n \t */\n \tpublic static boolean UseBoolBin = true;\n \n-\t/**\n-\t * Should default object serializer be disabled. If true, an exception will be thrown when\n-\t * a default object serialization is attempted. Default object serialization is triggered\n-\t * when a bin constructed by {@link com.aerospike.client.Bin#Bin(String, Object)} or\n-\t * {@link com.aerospike.client.Bin#asBlob(String, Object)} is used in a write command\n-\t * with an unrecognized object type.\n-\t */\n-\tpublic static boolean DisableSerializer = false;\n-\n-\t/**\n-\t * Should default object deserializer be disabled. If true, an exception will be thrown when\n-\t * a default object deserialization is attempted. Default object serialization is triggered\n-\t * when serialized data is read/parsed from the server. DisableDeserializer is separate from\n-\t * DisableSerializer because there may be cases when no new serialization is allowed, but\n-\t * existing serialized objects need to be supported.\n-\t */\n-\tpublic static boolean DisableDeserializer = false;\n-\n \t/**\n \t * Should the client return a map when {@link com.aerospike.client.cdt.MapReturnType#KEY_VALUE}\n \t * is specified in a map read operation and the server returns a list of key/value pairs.\n@@ -241,13 +221,6 @@ public static Value get(Value[] value) {\n \t\treturn (value == null)? NullValue.INSTANCE : new ValueArray(value);\n \t}\n \n-\t/**\n-\t * Get blob or null value instance.\n-\t */\n-\tpublic static Value getAsBlob(Object value) {\n-\t\treturn (value == null)? NullValue.INSTANCE : new BlobValue(value);\n-\t}\n-\n \t/**\n \t * Get GeoJSON or null value instance.\n \t */\n@@ -349,7 +322,7 @@ public static Value get(Object value) {\n \t\t\treturn new BytesValue(bb.array());\n \t\t}\n \n-\t\treturn new BlobValue(value);\n+\t\tthrow new AerospikeException(\"Unsupported type: \" + value.getClass().getName());\n \t}\n \n \t/**\n@@ -1260,88 +1233,6 @@ public long toLong() {\n \t\t}\n \t}\n \n-\t/**\n-\t * Blob value.\n-\t */\n-\tpublic static final class BlobValue extends Value {\n-\t\tprivate final Object object;\n-\t\tprivate byte[] bytes;\n-\n-\t\tpublic BlobValue(Object object) {\n-\t\t\tthis.object = object;\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic int estimateSize() throws AerospikeException.Serialize {\n-\t\t\tbytes = serialize(object);\n-\t\t\treturn bytes.length;\n-\t\t}\n-\n-\t\tpublic static byte[] serialize(Object val) {\n-\t\t\tif (DisableSerializer) {\n-\t\t\t\tthrow new AerospikeException(\"Object serializer has been disabled\");\n-\t\t\t}\n-\n-\t\t\ttry (ByteArrayOutputStream bstream = new ByteArrayOutputStream()) {\n-\t\t\t\ttry (ObjectOutputStream ostream = new ObjectOutputStream(bstream)) {\n-\t\t\t\t\tostream.writeObject(val);\n-\t\t\t\t}\n-\t\t\t\treturn bstream.toByteArray();\n-\t\t\t}\n-\t\t\tcatch (Throwable e) {\n-\t\t\t\tthrow new AerospikeException.Serialize(e);\n-\t\t\t}\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic int write(byte[] buffer, int offset) {\n-\t\t\tSystem.arraycopy(bytes, 0, buffer, offset, bytes.length);\n-\t\t\treturn bytes.length;\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void pack(Packer packer) {\n-\t\t\tpacker.packBlob(object);\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void validateKeyType() {\n-\t\t\tthrow new AerospikeException(ResultCode.PARAMETER_ERROR, \"Invalid key type: jblob\");\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic int getType() {\n-\t\t\treturn ParticleType.JBLOB;\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic Object getObject() {\n-\t\t\treturn object;\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic LuaValue getLuaValue(LuaInstance instance) {\n-\t\t\treturn LuaString.valueOf(bytes);\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic String toString() {\n-\t\t\treturn Buffer.bytesToHexString(bytes);\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic boolean equals(Object other) {\n-\t\t\treturn (other != null &&\n-\t\t\t\tthis.getClass().equals(other.getClass()) &&\n-\t\t\t\tthis.object.equals(((BlobValue)other).object));\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic int hashCode() {\n-\t\t\treturn object.hashCode();\n-\t\t}\n-\t}\n-\n \t/**\n \t * GeoJSON value.\n \t */",
    "function_modified_lines": {
      "added": [],
      "deleted": [
        "\t/**\n",
        "\t * Get blob or null value instance.\n",
        "\t */\n",
        "\tpublic static Value getAsBlob(Object value) {\n",
        "\t\treturn (value == null)? NullValue.INSTANCE : new BlobValue(value);\n",
        "\t}\n",
        "\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "The Aerospike Java client is a Java application that implements a network protocol to communicate with an Aerospike server. Prior to versions 7.0.0, 6.2.0, 5.2.0, and 4.5.0 some of the messages received from the server contain Java objects that the client deserializes when it encounters them without further validation. Attackers that manage to trick clients into communicating with a malicious server can include especially crafted objects in its responses that, once deserialized by the client, force it to execute arbitrary code. This can be abused to take control of the machine the client is running on. Versions 7.0.0, 6.2.0, 5.2.0, and 4.5.0 contain a patch for this issue.",
    "id": 12732
  },
  {
    "cve_id": "CVE-2023-36480",
    "code_before_change": "\n\t\t@Override\n\t\tpublic LuaValue getLuaValue(LuaInstance instance) {\n\t\t\treturn LuaBoolean.valueOf(value);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn Boolean.toString(value);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object other) {\n\t\t\treturn (other != null &&\n\t\t\t\tthis.getClass().equals(other.getClass()) &&\n\t\t\t\tthis.value == ((BoolIntValue)other).value);\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn value ? 1231 : 1237;\n\t\t}\n\n\t\t@Override\n\t\tpublic int toInteger() {\n\t\t\treturn value? 1 : 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic long toLong() {\n\t\t\treturn value? 1L : 0L;\n\t\t}\n\t}\n\n\t/**\n\t * Blob value.\n\t */\n\tpublic static final class BlobValue extends Value {\n\t\tprivate final Object object;\n\t\tprivate byte[] bytes;\n\n\t\tpublic BlobValue(Object object) {\n\t\t\tthis.object = object;\n\t\t}\n\n\t\t@Override\n\t\tpublic int estimateSize() throws AerospikeException.Serialize {\n\t\t\tbytes = serialize(object);\n\t\t\treturn bytes.length;\n\t\t}\n\n\t\tpublic static byte[] serialize(Object val) {\n\t\t\tif (DisableSerializer) {\n\t\t\t\tthrow new AerospikeException(\"Object serializer has been disabled\");\n\t\t\t}\n\n\t\t\ttry (ByteArrayOutputStream bstream = new ByteArrayOutputStream()) {\n\t\t\t\ttry (ObjectOutputStream ostream = new ObjectOutputStream(bstream)) {\n\t\t\t\t\tostream.writeObject(val);\n\t\t\t\t}\n\t\t\t\treturn bstream.toByteArray();\n\t\t\t}\n\t\t\tcatch (Throwable e) {\n\t\t\t\tthrow new AerospikeException.Serialize(e);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic int write(byte[] buffer, int offset) {\n\t\t\tSystem.arraycopy(bytes, 0, buffer, offset, bytes.length);\n\t\t\treturn bytes.length;\n\t\t}\n\n\t\t@Override\n\t\tpublic void pack(Packer packer) {\n\t\t\tpacker.packBlob(object);\n\t\t}\n\n\t\t@Override\n\t\tpublic void validateKeyType() {\n\t\t\tthrow new AerospikeException(ResultCode.PARAMETER_ERROR, \"Invalid key type: jblob\");\n\t\t}\n\n\t\t@Override\n\t\tpublic int getType() {\n\t\t\treturn ParticleType.JBLOB;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object getObject() {\n\t\t\treturn object;\n\t\t}\n\n\t\t@Override\n\t\tpublic LuaValue getLuaValue(LuaInstance instance) {\n\t\t\treturn LuaString.valueOf(bytes);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn Buffer.bytesToHexString(bytes);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object other) {\n\t\t\treturn (other != null &&\n\t\t\t\tthis.getClass().equals(other.getClass()) &&\n\t\t\t\tthis.object.equals(((BlobValue)other).object));\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn object.hashCode();\n\t\t}\n\t}\n\n\t/**\n\t * GeoJSON value.\n\t */\n\tpublic static final class GeoJSONValue extends Value {\n\t\tprivate final String value;\n\n\t\tpublic GeoJSONValue(String value) {\n\t\t\tthis.value = value;\n\t\t}\n\n\t\t@Override\n\t\tpublic int estimateSize() {\n\t\t\t// flags + ncells + jsonstr\n\t\t\treturn 1 + 2 + Buffer.estimateSizeUtf8(value);\n\t\t}\n\n\t\t@Override\n\t\tpublic int write(byte[] buffer, int offset) {\n\t\t\tbuffer[offset] = 0; // flags\n\t\t\tBuffer.shortToBytes(0, buffer, offset + 1); // ncells\n\t\t\treturn 1 + 2 + Buffer.stringToUtf8(value, buffer, offset + 3); // jsonstr\n\t\t}\n\n\t\t@Override\n\t\tpublic void pack(Packer packer) {\n\t\t\tpacker.packGeoJSON(value);\n\t\t}\n\n\t\t@Override\n\t\tpublic void validateKeyType() {\n\t\t\tthrow new AerospikeException(ResultCode.PARAMETER_ERROR, \"Invalid key type: GeoJson\");\n\t\t}\n\n\t\t@Override\n\t\tpublic int getType() {\n\t\t\treturn ParticleType.GEOJSON;",
    "code_after_change": "\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tpublic LuaValue getLuaValue(LuaInstance instance) {\n\t\t\treturn LuaBoolean.valueOf(value);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn Boolean.toString(value);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object other) {\n\t\t\treturn (other != null &&\n\t\t\t\tthis.getClass().equals(other.getClass()) &&\n\t\t\t\tthis.value == ((BoolIntValue)other).value);\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn value ? 1231 : 1237;\n\t\t}\n\n\t\t@Override\n\t\tpublic int toInteger() {\n\t\t\treturn value? 1 : 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic long toLong() {\n\t\t\treturn value? 1L : 0L;\n\t\t}\n\t}\n\n\t/**\n\t * GeoJSON value.\n\t */\n\tpublic static final class GeoJSONValue extends Value {\n\t\tprivate final String value;\n\n\t\tpublic GeoJSONValue(String value) {\n\t\t\tthis.value = value;\n\t\t}\n\n\t\t@Override\n\t\tpublic int estimateSize() {\n\t\t\t// flags + ncells + jsonstr\n\t\t\treturn 1 + 2 + Buffer.estimateSizeUtf8(value);\n\t\t}\n\n\t\t@Override\n\t\tpublic int write(byte[] buffer, int offset) {\n\t\t\tbuffer[offset] = 0; // flags\n\t\t\tBuffer.shortToBytes(0, buffer, offset + 1); // ncells\n\t\t\treturn 1 + 2 + Buffer.stringToUtf8(value, buffer, offset + 3); // jsonstr\n\t\t}\n\n\t\t@Override\n\t\tpublic void pack(Packer packer) {\n\t\t\tpacker.packGeoJSON(value);\n\t\t}\n\n\t\t@Override\n\t\tpublic void validateKeyType() {\n\t\t\tthrow new AerospikeException(ResultCode.PARAMETER_ERROR, \"Invalid key type: GeoJson\");\n\t\t}\n\n\t\t@Override\n\t\tpublic int getType() {\n\t\t\treturn ParticleType.GEOJSON;\n\t\t}\n",
    "patch": "@@ -16,8 +16,6 @@\n  */\n package com.aerospike.client;\n \n-import java.io.ByteArrayOutputStream;\n-import java.io.ObjectOutputStream;\n import java.nio.ByteBuffer;\n import java.util.Arrays;\n import java.util.List;\n@@ -52,24 +50,6 @@ public abstract class Value {\n \t */\n \tpublic static boolean UseBoolBin = true;\n \n-\t/**\n-\t * Should default object serializer be disabled. If true, an exception will be thrown when\n-\t * a default object serialization is attempted. Default object serialization is triggered\n-\t * when a bin constructed by {@link com.aerospike.client.Bin#Bin(String, Object)} or\n-\t * {@link com.aerospike.client.Bin#asBlob(String, Object)} is used in a write command\n-\t * with an unrecognized object type.\n-\t */\n-\tpublic static boolean DisableSerializer = false;\n-\n-\t/**\n-\t * Should default object deserializer be disabled. If true, an exception will be thrown when\n-\t * a default object deserialization is attempted. Default object serialization is triggered\n-\t * when serialized data is read/parsed from the server. DisableDeserializer is separate from\n-\t * DisableSerializer because there may be cases when no new serialization is allowed, but\n-\t * existing serialized objects need to be supported.\n-\t */\n-\tpublic static boolean DisableDeserializer = false;\n-\n \t/**\n \t * Should the client return a map when {@link com.aerospike.client.cdt.MapReturnType#KEY_VALUE}\n \t * is specified in a map read operation and the server returns a list of key/value pairs.\n@@ -241,13 +221,6 @@ public static Value get(Value[] value) {\n \t\treturn (value == null)? NullValue.INSTANCE : new ValueArray(value);\n \t}\n \n-\t/**\n-\t * Get blob or null value instance.\n-\t */\n-\tpublic static Value getAsBlob(Object value) {\n-\t\treturn (value == null)? NullValue.INSTANCE : new BlobValue(value);\n-\t}\n-\n \t/**\n \t * Get GeoJSON or null value instance.\n \t */\n@@ -349,7 +322,7 @@ public static Value get(Object value) {\n \t\t\treturn new BytesValue(bb.array());\n \t\t}\n \n-\t\treturn new BlobValue(value);\n+\t\tthrow new AerospikeException(\"Unsupported type: \" + value.getClass().getName());\n \t}\n \n \t/**\n@@ -1260,88 +1233,6 @@ public long toLong() {\n \t\t}\n \t}\n \n-\t/**\n-\t * Blob value.\n-\t */\n-\tpublic static final class BlobValue extends Value {\n-\t\tprivate final Object object;\n-\t\tprivate byte[] bytes;\n-\n-\t\tpublic BlobValue(Object object) {\n-\t\t\tthis.object = object;\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic int estimateSize() throws AerospikeException.Serialize {\n-\t\t\tbytes = serialize(object);\n-\t\t\treturn bytes.length;\n-\t\t}\n-\n-\t\tpublic static byte[] serialize(Object val) {\n-\t\t\tif (DisableSerializer) {\n-\t\t\t\tthrow new AerospikeException(\"Object serializer has been disabled\");\n-\t\t\t}\n-\n-\t\t\ttry (ByteArrayOutputStream bstream = new ByteArrayOutputStream()) {\n-\t\t\t\ttry (ObjectOutputStream ostream = new ObjectOutputStream(bstream)) {\n-\t\t\t\t\tostream.writeObject(val);\n-\t\t\t\t}\n-\t\t\t\treturn bstream.toByteArray();\n-\t\t\t}\n-\t\t\tcatch (Throwable e) {\n-\t\t\t\tthrow new AerospikeException.Serialize(e);\n-\t\t\t}\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic int write(byte[] buffer, int offset) {\n-\t\t\tSystem.arraycopy(bytes, 0, buffer, offset, bytes.length);\n-\t\t\treturn bytes.length;\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void pack(Packer packer) {\n-\t\t\tpacker.packBlob(object);\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void validateKeyType() {\n-\t\t\tthrow new AerospikeException(ResultCode.PARAMETER_ERROR, \"Invalid key type: jblob\");\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic int getType() {\n-\t\t\treturn ParticleType.JBLOB;\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic Object getObject() {\n-\t\t\treturn object;\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic LuaValue getLuaValue(LuaInstance instance) {\n-\t\t\treturn LuaString.valueOf(bytes);\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic String toString() {\n-\t\t\treturn Buffer.bytesToHexString(bytes);\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic boolean equals(Object other) {\n-\t\t\treturn (other != null &&\n-\t\t\t\tthis.getClass().equals(other.getClass()) &&\n-\t\t\t\tthis.object.equals(((BlobValue)other).object));\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic int hashCode() {\n-\t\t\treturn object.hashCode();\n-\t\t}\n-\t}\n-\n \t/**\n \t * GeoJSON value.\n \t */",
    "function_modified_lines": {
      "added": [],
      "deleted": [
        "\t/**\n",
        "\t * Blob value.\n",
        "\t */\n",
        "\tpublic static final class BlobValue extends Value {\n",
        "\t\tprivate final Object object;\n",
        "\t\tprivate byte[] bytes;\n",
        "\n",
        "\t\tpublic BlobValue(Object object) {\n",
        "\t\t\tthis.object = object;\n",
        "\t\t}\n",
        "\n",
        "\t\t@Override\n",
        "\t\tpublic int estimateSize() throws AerospikeException.Serialize {\n",
        "\t\t\tbytes = serialize(object);\n",
        "\t\t\treturn bytes.length;\n",
        "\t\t}\n",
        "\n",
        "\t\tpublic static byte[] serialize(Object val) {\n",
        "\t\t\tif (DisableSerializer) {\n",
        "\t\t\t\tthrow new AerospikeException(\"Object serializer has been disabled\");\n",
        "\t\t\t}\n",
        "\n",
        "\t\t\ttry (ByteArrayOutputStream bstream = new ByteArrayOutputStream()) {\n",
        "\t\t\t\ttry (ObjectOutputStream ostream = new ObjectOutputStream(bstream)) {\n",
        "\t\t\t\t\tostream.writeObject(val);\n",
        "\t\t\t\t}\n",
        "\t\t\t\treturn bstream.toByteArray();\n",
        "\t\t\t}\n",
        "\t\t\tcatch (Throwable e) {\n",
        "\t\t\t\tthrow new AerospikeException.Serialize(e);\n",
        "\t\t\t}\n",
        "\t\t}\n",
        "\n",
        "\t\t@Override\n",
        "\t\tpublic int write(byte[] buffer, int offset) {\n",
        "\t\t\tSystem.arraycopy(bytes, 0, buffer, offset, bytes.length);\n",
        "\t\t\treturn bytes.length;\n",
        "\t\t}\n",
        "\n",
        "\t\t@Override\n",
        "\t\tpublic void pack(Packer packer) {\n",
        "\t\t\tpacker.packBlob(object);\n",
        "\t\t}\n",
        "\n",
        "\t\t@Override\n",
        "\t\tpublic void validateKeyType() {\n",
        "\t\t\tthrow new AerospikeException(ResultCode.PARAMETER_ERROR, \"Invalid key type: jblob\");\n",
        "\t\t}\n",
        "\n",
        "\t\t@Override\n",
        "\t\tpublic int getType() {\n",
        "\t\t\treturn ParticleType.JBLOB;\n",
        "\t\t}\n",
        "\n",
        "\t\t@Override\n",
        "\t\tpublic Object getObject() {\n",
        "\t\t\treturn object;\n",
        "\t\t}\n",
        "\n",
        "\t\t@Override\n",
        "\t\tpublic LuaValue getLuaValue(LuaInstance instance) {\n",
        "\t\t\treturn LuaString.valueOf(bytes);\n",
        "\t\t}\n",
        "\n",
        "\t\t@Override\n",
        "\t\tpublic String toString() {\n",
        "\t\t\treturn Buffer.bytesToHexString(bytes);\n",
        "\t\t}\n",
        "\n",
        "\t\t@Override\n",
        "\t\tpublic boolean equals(Object other) {\n",
        "\t\t\treturn (other != null &&\n",
        "\t\t\t\tthis.getClass().equals(other.getClass()) &&\n",
        "\t\t\t\tthis.object.equals(((BlobValue)other).object));\n",
        "\t\t}\n",
        "\n",
        "\t\t@Override\n",
        "\t\tpublic int hashCode() {\n",
        "\t\t\treturn object.hashCode();\n",
        "\t\t}\n",
        "\t}\n",
        "\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "The Aerospike Java client is a Java application that implements a network protocol to communicate with an Aerospike server. Prior to versions 7.0.0, 6.2.0, 5.2.0, and 4.5.0 some of the messages received from the server contain Java objects that the client deserializes when it encounters them without further validation. Attackers that manage to trick clients into communicating with a malicious server can include especially crafted objects in its responses that, once deserialized by the client, force it to execute arbitrary code. This can be abused to take control of the machine the client is running on. Versions 7.0.0, 6.2.0, 5.2.0, and 4.5.0 contain a patch for this issue.",
    "id": 12733
  },
  {
    "cve_id": "CVE-2023-36480",
    "code_before_change": "{\n\t\tcase ParticleType.STRING:\n\t\t\treturn Buffer.utf8ToString(buf, offset, len);\n\n\t\tcase ParticleType.INTEGER:\n\t\t\treturn Buffer.bytesToNumber(buf, offset, len);\n\n\t\tcase ParticleType.BOOL:\n\t\t\treturn Buffer.bytesToBool(buf, offset, len);\n\n\t\tcase ParticleType.DOUBLE:\n\t\t\treturn Buffer.bytesToDouble(buf, offset);\n\n\t\tcase ParticleType.BLOB:\n\t\t\treturn Arrays.copyOfRange(buf, offset, offset+len);\n\n\t\tcase ParticleType.JBLOB:\n\t\t\treturn Buffer.bytesToObject(buf, offset, len);\n\n\t\tcase ParticleType.GEOJSON:\n\t\t\treturn Buffer.bytesToGeoJSON(buf, offset, len);\n\n\t\tcase ParticleType.HLL:\n\t\t\treturn Buffer.bytesToHLL(buf, offset, len);\n\n\t\tcase ParticleType.LIST:\n\t\t\treturn Unpacker.unpackObjectList(buf, offset, len);\n\n\t\tcase ParticleType.MAP:\n\t\t\treturn Unpacker.unpackObjectMap(buf, offset, len);\n\n\t\tdefault:\n\t\t\treturn null;\n\t\t}",
    "code_after_change": "{\n\t\tcase ParticleType.STRING:\n\t\t\treturn Buffer.utf8ToString(buf, offset, len);\n\n\t\tcase ParticleType.INTEGER:\n\t\t\treturn Buffer.bytesToNumber(buf, offset, len);\n\n\t\tcase ParticleType.BOOL:\n\t\t\treturn Buffer.bytesToBool(buf, offset, len);\n\n\t\tcase ParticleType.DOUBLE:\n\t\t\treturn Buffer.bytesToDouble(buf, offset);\n\n\t\tcase ParticleType.BLOB:\n\t\t\treturn Arrays.copyOfRange(buf, offset, offset+len);\n\n\t\tcase ParticleType.GEOJSON:\n\t\t\treturn Buffer.bytesToGeoJSON(buf, offset, len);\n\n\t\tcase ParticleType.HLL:\n\t\t\treturn Buffer.bytesToHLL(buf, offset, len);\n\n\t\tcase ParticleType.LIST:\n\t\t\treturn Unpacker.unpackObjectList(buf, offset, len);\n\n\t\tcase ParticleType.MAP:\n\t\t\treturn Unpacker.unpackObjectMap(buf, offset, len);\n\n\t\tdefault:\n\t\t\treturn null;\n\t\t}",
    "patch": "@@ -16,8 +16,6 @@\n  */\n package com.aerospike.client.command;\n \n-import java.io.ByteArrayInputStream;\n-import java.io.ObjectInputStream;\n import java.math.BigInteger;\n import java.nio.charset.StandardCharsets;\n import java.util.Arrays;\n@@ -69,9 +67,6 @@ public static Object bytesToParticle(int type, byte[] buf, int offset, int len)\n \t\tcase ParticleType.BLOB:\n \t\t\treturn Arrays.copyOfRange(buf, offset, offset+len);\n \n-\t\tcase ParticleType.JBLOB:\n-\t\t\treturn Buffer.bytesToObject(buf, offset, len);\n-\n \t\tcase ParticleType.GEOJSON:\n \t\t\treturn Buffer.bytesToGeoJSON(buf, offset, len);\n \n@@ -297,25 +292,6 @@ public static String bytesToHexString(byte[] buf, int offset, int length) {\n \t\treturn sb.toString();\n \t}\n \n-\tpublic static Object bytesToObject(byte[] buf, int offset, int length) {\n-\t\tif (length <= 0) {\n-\t\t\treturn null;\n-\t\t}\n-\n-\t\tif (Value.DisableDeserializer) {\n-\t\t\tthrow new AerospikeException.Serialize(\"Object deserializer has been disabled\");\n-\t\t}\n-\n-\t\ttry (ByteArrayInputStream bastream = new ByteArrayInputStream(buf, offset, length)) {\n-\t\t\ttry (ObjectInputStream oistream = new ObjectInputStream(bastream)) {\n-\t\t\t\treturn oistream.readObject();\n-\t\t\t}\n-\t\t}\n-\t\tcatch (Throwable e) {\n-\t\t\tthrow new AerospikeException.Serialize(e);\n-\t\t}\n-\t}\n-\n \tpublic static Value bytesToLongValue(byte[] buf, int offset, int len) {\n \t\tlong val = 0;\n ",
    "function_modified_lines": {
      "added": [],
      "deleted": [
        "\t\tcase ParticleType.JBLOB:\n",
        "\t\t\treturn Buffer.bytesToObject(buf, offset, len);\n",
        "\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "The Aerospike Java client is a Java application that implements a network protocol to communicate with an Aerospike server. Prior to versions 7.0.0, 6.2.0, 5.2.0, and 4.5.0 some of the messages received from the server contain Java objects that the client deserializes when it encounters them without further validation. Attackers that manage to trick clients into communicating with a malicious server can include especially crafted objects in its responses that, once deserialized by the client, force it to execute arbitrary code. This can be abused to take control of the machine the client is running on. Versions 7.0.0, 6.2.0, 5.2.0, and 4.5.0 contain a patch for this issue.",
    "id": 12734
  },
  {
    "cve_id": "CVE-2023-36480",
    "code_before_change": "\t * Input format: 1234\n\t */\n\tpublic static int utf8DigitsToInt(byte[] buf, int begin, int end) {\n\t\tint val = 0;\n\t\tint mult = 1;\n\n\t\tfor (int i = end - 1; i >= begin; i--) {\n\t\t\tval += ((int)buf[i] - 48) * mult;\n\t\t\tmult *= 10;\n\t\t}\n\t\treturn val;\n\t}\n\n\tpublic static String bytesToHexString(byte[] buf) {\n\t\tif (buf == null || buf.length == 0) {\n\t\t\treturn \"\";\n\t\t}\n\t\tStringBuilder sb = new StringBuilder(buf.length * 2);\n\n\t\tfor (int i = 0; i < buf.length; i++) {\n\t\t\tsb.append(String.format(\"%02x\", buf[i]));\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic static String bytesToHexString(byte[] buf, int offset, int length) {\n\t\tStringBuilder sb = new StringBuilder(length * 2);\n\n\t\tfor (int i = offset; i < length; i++) {\n\t\t\tsb.append(String.format(\"%02x\", buf[i]));\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic static Object bytesToObject(byte[] buf, int offset, int length) {\n\t\tif (length <= 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (Value.DisableDeserializer) {\n\t\t\tthrow new AerospikeException.Serialize(\"Object deserializer has been disabled\");\n\t\t}\n\n\t\ttry (ByteArrayInputStream bastream = new ByteArrayInputStream(buf, offset, length)) {\n\t\t\ttry (ObjectInputStream oistream = new ObjectInputStream(bastream)) {\n\t\t\t\treturn oistream.readObject();\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable e) {\n\t\t\tthrow new AerospikeException.Serialize(e);\n\t\t}\n\t}\n\n\tpublic static Value bytesToLongValue(byte[] buf, int offset, int len) {\n\t\tlong val = 0;\n\n\t\tfor (int i = 0; i < len; i++) {\n\t\t\tval <<= 8;\n\t\t\tval |= buf[offset+i] & 0xFF;\n\t\t}\n\n\t\treturn new Value.LongValue(val);\n\t}\n\n\tpublic static Object bytesToGeoJSON(byte[] buf, int offset, int len) {\n\t\t// Ignore the flags for now\n\t\tint ncells = bytesToShort(buf, offset + 1);\n\t\tint hdrsz = 1 + 2 + (ncells * 8);\n\t\treturn Value.getAsGeoJSON(Buffer.utf8ToString(buf, offset + hdrsz, len - hdrsz));\n\t}\n\n\tpublic static Object bytesToHLL(byte[] buf, int offset, int len) {\n\t\tbyte[] bytes = Arrays.copyOfRange(buf, offset, offset+len);\n\t\treturn Value.getAsHLL(bytes);\n\t}\n\n\tpublic static Object bytesToNumber(byte[] buf, int offset, int len) {\n\t\t// Server always returns 8 for integer length.\n\t\tif (len == 8) {\n\t\t\treturn bytesToLong(buf, offset);\n\t\t}\n\n\t\t// Handle other lengths just in case server changes.\n\t\tif (len < 8) {\n\t\t\t// Handle variable length long.\n\t\t\tlong val = 0;\n\n\t\t\tfor (int i = 0; i < len; i++) {\n\t\t\t\tval <<= 8;",
    "code_after_change": "\t * Convert UTF8 numeric digits to an integer.  Negative integers are not supported.\n\t *\n\t * Input format: 1234\n\t */\n\tpublic static int utf8DigitsToInt(byte[] buf, int begin, int end) {\n\t\tint val = 0;\n\t\tint mult = 1;\n\n\t\tfor (int i = end - 1; i >= begin; i--) {\n\t\t\tval += ((int)buf[i] - 48) * mult;\n\t\t\tmult *= 10;\n\t\t}\n\t\treturn val;\n\t}\n\n\tpublic static String bytesToHexString(byte[] buf) {\n\t\tif (buf == null || buf.length == 0) {\n\t\t\treturn \"\";\n\t\t}\n\t\tStringBuilder sb = new StringBuilder(buf.length * 2);\n\n\t\tfor (int i = 0; i < buf.length; i++) {\n\t\t\tsb.append(String.format(\"%02x\", buf[i]));\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic static String bytesToHexString(byte[] buf, int offset, int length) {\n\t\tStringBuilder sb = new StringBuilder(length * 2);\n\n\t\tfor (int i = offset; i < length; i++) {\n\t\t\tsb.append(String.format(\"%02x\", buf[i]));\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic static Value bytesToLongValue(byte[] buf, int offset, int len) {\n\t\tlong val = 0;\n\n\t\tfor (int i = 0; i < len; i++) {\n\t\t\tval <<= 8;\n\t\t\tval |= buf[offset+i] & 0xFF;\n\t\t}\n\n\t\treturn new Value.LongValue(val);\n\t}\n\n\tpublic static Object bytesToGeoJSON(byte[] buf, int offset, int len) {\n\t\t// Ignore the flags for now\n\t\tint ncells = bytesToShort(buf, offset + 1);\n\t\tint hdrsz = 1 + 2 + (ncells * 8);\n\t\treturn Value.getAsGeoJSON(Buffer.utf8ToString(buf, offset + hdrsz, len - hdrsz));\n\t}\n\n\tpublic static Object bytesToHLL(byte[] buf, int offset, int len) {\n\t\tbyte[] bytes = Arrays.copyOfRange(buf, offset, offset+len);\n\t\treturn Value.getAsHLL(bytes);\n\t}\n\n\tpublic static Object bytesToNumber(byte[] buf, int offset, int len) {\n\t\t// Server always returns 8 for integer length.\n\t\tif (len == 8) {\n\t\t\treturn bytesToLong(buf, offset);\n\t\t}\n\n\t\t// Handle other lengths just in case server changes.\n\t\tif (len < 8) {\n\t\t\t// Handle variable length long.\n\t\t\tlong val = 0;\n\n\t\t\tfor (int i = 0; i < len; i++) {\n\t\t\t\tval <<= 8;\n\t\t\t\tval |= buf[offset+i] & 0xFF;\n\t\t\t}",
    "patch": "@@ -16,8 +16,6 @@\n  */\n package com.aerospike.client.command;\n \n-import java.io.ByteArrayInputStream;\n-import java.io.ObjectInputStream;\n import java.math.BigInteger;\n import java.nio.charset.StandardCharsets;\n import java.util.Arrays;\n@@ -69,9 +67,6 @@ public static Object bytesToParticle(int type, byte[] buf, int offset, int len)\n \t\tcase ParticleType.BLOB:\n \t\t\treturn Arrays.copyOfRange(buf, offset, offset+len);\n \n-\t\tcase ParticleType.JBLOB:\n-\t\t\treturn Buffer.bytesToObject(buf, offset, len);\n-\n \t\tcase ParticleType.GEOJSON:\n \t\t\treturn Buffer.bytesToGeoJSON(buf, offset, len);\n \n@@ -297,25 +292,6 @@ public static String bytesToHexString(byte[] buf, int offset, int length) {\n \t\treturn sb.toString();\n \t}\n \n-\tpublic static Object bytesToObject(byte[] buf, int offset, int length) {\n-\t\tif (length <= 0) {\n-\t\t\treturn null;\n-\t\t}\n-\n-\t\tif (Value.DisableDeserializer) {\n-\t\t\tthrow new AerospikeException.Serialize(\"Object deserializer has been disabled\");\n-\t\t}\n-\n-\t\ttry (ByteArrayInputStream bastream = new ByteArrayInputStream(buf, offset, length)) {\n-\t\t\ttry (ObjectInputStream oistream = new ObjectInputStream(bastream)) {\n-\t\t\t\treturn oistream.readObject();\n-\t\t\t}\n-\t\t}\n-\t\tcatch (Throwable e) {\n-\t\t\tthrow new AerospikeException.Serialize(e);\n-\t\t}\n-\t}\n-\n \tpublic static Value bytesToLongValue(byte[] buf, int offset, int len) {\n \t\tlong val = 0;\n ",
    "function_modified_lines": {
      "added": [],
      "deleted": [
        "\tpublic static Object bytesToObject(byte[] buf, int offset, int length) {\n",
        "\t\tif (length <= 0) {\n",
        "\t\t\treturn null;\n",
        "\t\t}\n",
        "\n",
        "\t\tif (Value.DisableDeserializer) {\n",
        "\t\t\tthrow new AerospikeException.Serialize(\"Object deserializer has been disabled\");\n",
        "\t\t}\n",
        "\n",
        "\t\ttry (ByteArrayInputStream bastream = new ByteArrayInputStream(buf, offset, length)) {\n",
        "\t\t\ttry (ObjectInputStream oistream = new ObjectInputStream(bastream)) {\n",
        "\t\t\t\treturn oistream.readObject();\n",
        "\t\t\t}\n",
        "\t\t}\n",
        "\t\tcatch (Throwable e) {\n",
        "\t\t\tthrow new AerospikeException.Serialize(e);\n",
        "\t\t}\n",
        "\t}\n",
        "\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "The Aerospike Java client is a Java application that implements a network protocol to communicate with an Aerospike server. Prior to versions 7.0.0, 6.2.0, 5.2.0, and 4.5.0 some of the messages received from the server contain Java objects that the client deserializes when it encounters them without further validation. Attackers that manage to trick clients into communicating with a malicious server can include especially crafted objects in its responses that, once deserialized by the client, force it to execute arbitrary code. This can be abused to take control of the machine the client is running on. Versions 7.0.0, 6.2.0, 5.2.0, and 4.5.0 contain a patch for this issue.",
    "id": 12735
  },
  {
    "cve_id": "CVE-2023-36480",
    "code_before_change": "{\n\tprivate LuaInstance instance;\n\n\tpublic LuaUnpacker(LuaInstance instance, byte[] buffer, int offset, int length) {\n\t\tsuper(buffer, offset, length);\n\t\tthis.instance = instance;\n\t}\n\n\t@Override\n\tprotected LuaMap getMap(Map<LuaValue,LuaValue> value) {\n\t\treturn new LuaMap(instance, value);\n\t}\n\n\t@Override\n\tprotected LuaList getList(List<LuaValue> value) {\n\t\treturn new LuaList(instance, value);\n\t}\n\n\t@Override\n\tprotected LuaValue getJavaBlob(Object value) {\n\t\treturn new LuaJavaBlob(value);\n\t}\n\n\t@Override\n\tprotected LuaBytes getBlob(byte[] value) {\n\t\treturn new LuaBytes(instance, value);\n\t}\n\n\t@Override\n\tprotected LuaString getString(String value) {\n\t\treturn LuaString.valueOf(value);\n\t}\n\n\t@Override\n\tprotected LuaNumber getLong(long value) {\n\t\treturn LuaInteger.valueOf(value);\n\t}\n\n\t@Override\n\tprotected LuaNumber getDouble(double value) {\n\t\treturn LuaDouble.valueOf(value);\n\t}\n\n\t@Override\n\tprotected LuaBoolean getBoolean(boolean value) {\n\t\treturn LuaBoolean.valueOf(value);\n\t}\n\n\t@Override\n\tprotected LuaGeoJSON getGeoJSON(String value) {\n\t\treturn new LuaGeoJSON(value);\n\t}\n}",
    "code_after_change": "{\n\tprivate LuaInstance instance;\n\n\tpublic LuaUnpacker(LuaInstance instance, byte[] buffer, int offset, int length) {\n\t\tsuper(buffer, offset, length);\n\t\tthis.instance = instance;\n\t}\n\n\t@Override\n\tprotected LuaMap getMap(Map<LuaValue,LuaValue> value) {\n\t\treturn new LuaMap(instance, value);\n\t}\n\n\t@Override\n\tprotected LuaList getList(List<LuaValue> value) {\n\t\treturn new LuaList(instance, value);\n\t}\n\n\t@Override\n\tprotected LuaBytes getBlob(byte[] value) {\n\t\treturn new LuaBytes(instance, value);\n\t}\n\n\t@Override\n\tprotected LuaString getString(String value) {\n\t\treturn LuaString.valueOf(value);\n\t}\n\n\t@Override\n\tprotected LuaNumber getLong(long value) {\n\t\treturn LuaInteger.valueOf(value);\n\t}\n\n\t@Override\n\tprotected LuaNumber getDouble(double value) {\n\t\treturn LuaDouble.valueOf(value);\n\t}\n\n\t@Override\n\tprotected LuaBoolean getBoolean(boolean value) {\n\t\treturn LuaBoolean.valueOf(value);\n\t}\n\n\t@Override\n\tprotected LuaGeoJSON getGeoJSON(String value) {\n\t\treturn new LuaGeoJSON(value);\n\t}\n}",
    "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2012-2021 Aerospike, Inc.\n+ * Copyright 2012-2023 Aerospike, Inc.\n  *\n  * Portions may be licensed to Aerospike, Inc. under one or more contributor\n  * license agreements WHICH ARE COMPATIBLE WITH THE APACHE LICENSE, VERSION 2.0.\n@@ -46,11 +46,6 @@ protected LuaList getList(List<LuaValue> value) {\n \t\treturn new LuaList(instance, value);\n \t}\n \n-\t@Override\n-\tprotected LuaValue getJavaBlob(Object value) {\n-\t\treturn new LuaJavaBlob(value);\n-\t}\n-\n \t@Override\n \tprotected LuaBytes getBlob(byte[] value) {\n \t\treturn new LuaBytes(instance, value);",
    "function_modified_lines": {
      "added": [],
      "deleted": [
        "\t@Override\n",
        "\tprotected LuaValue getJavaBlob(Object value) {\n",
        "\t\treturn new LuaJavaBlob(value);\n",
        "\t}\n",
        "\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "The Aerospike Java client is a Java application that implements a network protocol to communicate with an Aerospike server. Prior to versions 7.0.0, 6.2.0, 5.2.0, and 4.5.0 some of the messages received from the server contain Java objects that the client deserializes when it encounters them without further validation. Attackers that manage to trick clients into communicating with a malicious server can include especially crafted objects in its responses that, once deserialized by the client, force it to execute arbitrary code. This can be abused to take control of the machine the client is running on. Versions 7.0.0, 6.2.0, 5.2.0, and 4.5.0 contain a patch for this issue.",
    "id": 12736
  },
  {
    "cve_id": "CVE-2023-36480",
    "code_before_change": "\t\tif (size < 16) {\n\t\t\tpackByte(0x80 | size);\n\t\t}\n\t\telse if (size < 65536) {\n\t\t\tpackShort(0xde, size);\n\t\t}\n\t\telse {\n\t\t\tpackInt(0xdf, size);\n\t\t}\n\t}\n\n\tpublic void packBytes(byte[] b) {\n\t\tpackByteArrayBegin(b.length);\n\t\tpackByteArray(b, 0, b.length);\n\t}\n\n\tpublic void packParticleBytes(byte[] b) {\n\t\tpackByteArrayBegin(b.length + 1);\n\t\tpackByte(ParticleType.BLOB);\n\t\tpackByteArray(b, 0, b.length);\n\t}\n\n\tpublic void packParticleBytes(byte[] b, int type) {\n\t\tpackByteArrayBegin(b.length + 1);\n\t\tpackByte(type);\n\t\tpackByteArray(b, 0, b.length);\n\t}\n\n\tpublic void packParticleBytes(byte[] b, int offset, int length) {\n\t\tpackByteArrayBegin(length + 1);\n\t\tpackByte(ParticleType.BLOB);\n\t\tpackByteArray(b, offset, length);\n\t}\n\n\tpublic void packBlob(Object val) {\n\t\tbyte[] bytes = BlobValue.serialize(val);\n\t\tpackByteArrayBegin(bytes.length + 1);\n\t\tpackByte(ParticleType.JBLOB);\n\t\tpackByteArray(bytes, 0, bytes.length);\n\t}\n\n\tpublic void packGeoJSON(String val) {\n\t\tbyte[] buffer = Buffer.stringToUtf8(val);\n\t\tpackByteArrayBegin(buffer.length + 1);\n\t\tpackByte(ParticleType.GEOJSON);\n\t\tpackByteArray(buffer, 0, buffer.length);\n\t}\n\n\tprivate void packByteArrayBegin(int size) {\n\t\t// Use string header codes for byte arrays.\n\t\tpackStringBegin(size);\n\t\t/*\n\t\tif (size < 256) {\n\t\t\tpackByte(0xc4, size);\n\t\t}\n\t\telse if (size < 65536) {\n\t\t\tpackShort(0xc5, size);\n\t\t}\n\t\telse {\n\t\t\tpackInt(0xc6, size);\n\t\t}\n\t\t*/\n\t}\n\n\tpublic void packObject(Object obj) {\n\t\tif (obj == null) {\n\t\t\tpackNil();\n\t\t\treturn;\n\t\t}\n\n\t\tif (obj instanceof Value) {\n\t\t\tValue value = (Value)obj;\n\t\t\tvalue.pack(this);\n\t\t\treturn;\n\t\t}\n\n\t\tif (obj instanceof byte[]) {",
    "code_after_change": "\n\tpublic void packMapBegin(int size) {\n\t\tif (size < 16) {\n\t\t\tpackByte(0x80 | size);\n\t\t}\n\t\telse if (size < 65536) {\n\t\t\tpackShort(0xde, size);\n\t\t}\n\t\telse {\n\t\t\tpackInt(0xdf, size);\n\t\t}\n\t}\n\n\tpublic void packBytes(byte[] b) {\n\t\tpackByteArrayBegin(b.length);\n\t\tpackByteArray(b, 0, b.length);\n\t}\n\n\tpublic void packParticleBytes(byte[] b) {\n\t\tpackByteArrayBegin(b.length + 1);\n\t\tpackByte(ParticleType.BLOB);\n\t\tpackByteArray(b, 0, b.length);\n\t}\n\n\tpublic void packParticleBytes(byte[] b, int type) {\n\t\tpackByteArrayBegin(b.length + 1);\n\t\tpackByte(type);\n\t\tpackByteArray(b, 0, b.length);\n\t}\n\n\tpublic void packParticleBytes(byte[] b, int offset, int length) {\n\t\tpackByteArrayBegin(length + 1);\n\t\tpackByte(ParticleType.BLOB);\n\t\tpackByteArray(b, offset, length);\n\t}\n\n\tpublic void packGeoJSON(String val) {\n\t\tbyte[] buffer = Buffer.stringToUtf8(val);\n\t\tpackByteArrayBegin(buffer.length + 1);\n\t\tpackByte(ParticleType.GEOJSON);\n\t\tpackByteArray(buffer, 0, buffer.length);\n\t}\n\n\tprivate void packByteArrayBegin(int size) {\n\t\t// Use string header codes for byte arrays.\n\t\tpackStringBegin(size);\n\t\t/*\n\t\tif (size < 256) {\n\t\t\tpackByte(0xc4, size);\n\t\t}\n\t\telse if (size < 65536) {\n\t\t\tpackShort(0xc5, size);\n\t\t}\n\t\telse {\n\t\t\tpackInt(0xc6, size);\n\t\t}\n\t\t*/\n\t}\n\n\tpublic void packObject(Object obj) {\n\t\tif (obj == null) {\n\t\t\tpackNil();\n\t\t\treturn;\n\t\t}\n\n\t\tif (obj instanceof Value) {\n\t\t\tValue value = (Value)obj;\n\t\t\tvalue.pack(this);\n\t\t\treturn;\n\t\t}\n\n\t\tif (obj instanceof byte[]) {\n\t\t\tpackParticleBytes((byte[])obj);\n\t\t\treturn;",
    "patch": "@@ -27,7 +27,6 @@\n \n import com.aerospike.client.AerospikeException;\n import com.aerospike.client.Value;\n-import com.aerospike.client.Value.BlobValue;\n import com.aerospike.client.cdt.MapOrder;\n import com.aerospike.client.command.Buffer;\n import com.aerospike.client.command.ParticleType;\n@@ -206,13 +205,6 @@ public void packParticleBytes(byte[] b, int offset, int length) {\n \t\tpackByteArray(b, offset, length);\n \t}\n \n-\tpublic void packBlob(Object val) {\n-\t\tbyte[] bytes = BlobValue.serialize(val);\n-\t\tpackByteArrayBegin(bytes.length + 1);\n-\t\tpackByte(ParticleType.JBLOB);\n-\t\tpackByteArray(bytes, 0, bytes.length);\n-\t}\n-\n \tpublic void packGeoJSON(String val) {\n \t\tbyte[] buffer = Buffer.stringToUtf8(val);\n \t\tpackByteArrayBegin(buffer.length + 1);\n@@ -323,7 +315,7 @@ public void packObject(Object obj) {\n \t\t\treturn;\n \t\t}\n \n-\t\tpackBlob(obj);\n+\t\tthrow new AerospikeException(\"Unsupported type: \" + obj.getClass().getName());\n \t}\n \n \tpublic void packByteBuffer(ByteBuffer bb) {",
    "function_modified_lines": {
      "added": [],
      "deleted": [
        "\tpublic void packBlob(Object val) {\n",
        "\t\tbyte[] bytes = BlobValue.serialize(val);\n",
        "\t\tpackByteArrayBegin(bytes.length + 1);\n",
        "\t\tpackByte(ParticleType.JBLOB);\n",
        "\t\tpackByteArray(bytes, 0, bytes.length);\n",
        "\t}\n",
        "\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "The Aerospike Java client is a Java application that implements a network protocol to communicate with an Aerospike server. Prior to versions 7.0.0, 6.2.0, 5.2.0, and 4.5.0 some of the messages received from the server contain Java objects that the client deserializes when it encounters them without further validation. Attackers that manage to trick clients into communicating with a malicious server can include especially crafted objects in its responses that, once deserialized by the client, force it to execute arbitrary code. This can be abused to take control of the machine the client is running on. Versions 7.0.0, 6.2.0, 5.2.0, and 4.5.0 contain a patch for this issue.",
    "id": 12737
  },
  {
    "cve_id": "CVE-2023-36480",
    "code_before_change": "/*\n * Copyright 2012-2023 Aerospike, Inc.\n *\n * Portions may be licensed to Aerospike, Inc. under one or more contributor\n * license agreements WHICH ARE COMPATIBLE WITH THE APACHE LICENSE, VERSION 2.0.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\npackage com.aerospike.client.util;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.nio.ByteBuffer;\nimport java.util.AbstractMap;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.TreeMap;\n\nimport com.aerospike.client.AerospikeException;\nimport com.aerospike.client.Value;\nimport com.aerospike.client.command.Buffer;\nimport com.aerospike.client.command.ParticleType;\n\n/**\n * De-serialize collection objects using MessagePack format specification:\n *\n * https://github.com/msgpack/msgpack/blob/master/spec.md\n */\npublic abstract class Unpacker<T> {\n\n\tprivate final byte[] buffer;\n\tprivate int offset;\n\tprivate final int length;\n\n\tpublic Unpacker(byte[] buffer, int offset, int length) {\n\t\tthis.buffer = buffer;\n\t\tthis.offset = offset;\n\t\tthis.length = length;\n\t}\n\n\tpublic final T unpackList() throws AerospikeException {\n\t\tif (length <= 0) {\n\t\t\treturn getList(new ArrayList<T>(0));\n\t\t}",
    "code_after_change": "/*\n * Copyright 2012-2023 Aerospike, Inc.\n *\n * Portions may be licensed to Aerospike, Inc. under one or more contributor\n * license agreements WHICH ARE COMPATIBLE WITH THE APACHE LICENSE, VERSION 2.0.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\npackage com.aerospike.client.util;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.util.AbstractMap;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.TreeMap;\n\nimport com.aerospike.client.AerospikeException;\nimport com.aerospike.client.Value;\nimport com.aerospike.client.command.Buffer;\nimport com.aerospike.client.command.ParticleType;\n\n/**\n * De-serialize collection objects using MessagePack format specification:\n *\n * https://github.com/msgpack/msgpack/blob/master/spec.md\n */\npublic abstract class Unpacker<T> {\n\n\tprivate final byte[] buffer;\n\tprivate int offset;\n\tprivate final int length;\n\n\tpublic Unpacker(byte[] buffer, int offset, int length) {\n\t\tthis.buffer = buffer;\n\t\tthis.offset = offset;\n\t\tthis.length = length;\n\t}\n\n\tpublic final T unpackList() throws AerospikeException {\n\t\tif (length <= 0) {\n\t\t\treturn getList(new ArrayList<T>(0));\n\t\t}\n\n\t\ttry {",
    "patch": "@@ -16,9 +16,7 @@\n  */\n package com.aerospike.client.util;\n \n-import java.io.ByteArrayInputStream;\n import java.io.IOException;\n-import java.io.ObjectInputStream;\n import java.nio.ByteBuffer;\n import java.util.AbstractMap;\n import java.util.ArrayList;\n@@ -234,21 +232,6 @@ private T unpackBlob(int count) throws IOException, ClassNotFoundException {\n \t\t\tval = getString(Buffer.utf8ToString(buffer, offset, count));\n \t\t\tbreak;\n \n-\t\tcase ParticleType.JBLOB:\n-\t\t\tif (Value.DisableDeserializer) {\n-\t\t\t\tthrow new AerospikeException.Serialize(\"Object deserializer has been disabled\");\n-\t\t\t}\n-\n-\t\t\ttry (ByteArrayInputStream bastream = new ByteArrayInputStream(buffer, offset, count)) {\n-\t\t\t\ttry (ObjectInputStream oistream = new ObjectInputStream(bastream)) {\n-\t\t\t\t\tval = getJavaBlob(oistream.readObject());\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tcatch (Throwable e) {\n-\t\t\t\tthrow new AerospikeException.Serialize(e);\n-\t\t\t}\n-\t\t\tbreak;\n-\n \t\tcase ParticleType.GEOJSON:\n \t\t\tval = getGeoJSON(Buffer.utf8ToString(buffer, offset, count));\n \t\t\tbreak;\n@@ -451,7 +434,6 @@ public T unpackObject() throws IOException, ClassNotFoundException {\n \n \tprotected abstract T getMap(Map<T,T> value);\n \tprotected abstract T getList(List<T> value);\n-\tprotected abstract T getJavaBlob(Object value);\n \tprotected abstract T getBlob(byte[] value);\n \tprotected abstract T getString(String value);\n \tprotected abstract T getLong(long value);\n@@ -498,11 +480,6 @@ protected Object getList(List<Object> value) {\n \t\t\treturn value;\n \t\t}\n \n-\t\t@Override\n-\t\tprotected Object getJavaBlob(Object value) {\n-\t\t\treturn value;\n-\t\t}\n-\n \t\t@Override\n \t\tprotected Object getBlob(byte[] value) {\n \t\t\treturn value;",
    "function_modified_lines": {
      "added": [],
      "deleted": [
        "import java.io.ByteArrayInputStream;\n",
        "import java.io.ObjectInputStream;\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "The Aerospike Java client is a Java application that implements a network protocol to communicate with an Aerospike server. Prior to versions 7.0.0, 6.2.0, 5.2.0, and 4.5.0 some of the messages received from the server contain Java objects that the client deserializes when it encounters them without further validation. Attackers that manage to trick clients into communicating with a malicious server can include especially crafted objects in its responses that, once deserialized by the client, force it to execute arbitrary code. This can be abused to take control of the machine the client is running on. Versions 7.0.0, 6.2.0, 5.2.0, and 4.5.0 contain a patch for this issue.",
    "id": 12738
  },
  {
    "cve_id": "CVE-2023-36480",
    "code_before_change": "{\n\t\tcase ParticleType.STRING:\n\t\t\tval = getString(Buffer.utf8ToString(buffer, offset, count));\n\t\t\tbreak;\n\n\t\tcase ParticleType.JBLOB:\n\t\t\tif (Value.DisableDeserializer) {\n\t\t\t\tthrow new AerospikeException.Serialize(\"Object deserializer has been disabled\");\n\t\t\t}\n\n\t\t\ttry (ByteArrayInputStream bastream = new ByteArrayInputStream(buffer, offset, count)) {\n\t\t\t\ttry (ObjectInputStream oistream = new ObjectInputStream(bastream)) {\n\t\t\t\t\tval = getJavaBlob(oistream.readObject());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Throwable e) {\n\t\t\t\tthrow new AerospikeException.Serialize(e);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase ParticleType.GEOJSON:\n\t\t\tval = getGeoJSON(Buffer.utf8ToString(buffer, offset, count));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tval = getBlob(Arrays.copyOfRange(buffer, offset, offset + count));\n\t\t\tbreak;\n\t\t}",
    "code_after_change": "{\n\t\tcase ParticleType.STRING:\n\t\t\tval = getString(Buffer.utf8ToString(buffer, offset, count));\n\t\t\tbreak;\n\n\t\tcase ParticleType.GEOJSON:\n\t\t\tval = getGeoJSON(Buffer.utf8ToString(buffer, offset, count));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tval = getBlob(Arrays.copyOfRange(buffer, offset, offset + count));\n\t\t\tbreak;\n\t\t}",
    "patch": "@@ -16,9 +16,7 @@\n  */\n package com.aerospike.client.util;\n \n-import java.io.ByteArrayInputStream;\n import java.io.IOException;\n-import java.io.ObjectInputStream;\n import java.nio.ByteBuffer;\n import java.util.AbstractMap;\n import java.util.ArrayList;\n@@ -234,21 +232,6 @@ private T unpackBlob(int count) throws IOException, ClassNotFoundException {\n \t\t\tval = getString(Buffer.utf8ToString(buffer, offset, count));\n \t\t\tbreak;\n \n-\t\tcase ParticleType.JBLOB:\n-\t\t\tif (Value.DisableDeserializer) {\n-\t\t\t\tthrow new AerospikeException.Serialize(\"Object deserializer has been disabled\");\n-\t\t\t}\n-\n-\t\t\ttry (ByteArrayInputStream bastream = new ByteArrayInputStream(buffer, offset, count)) {\n-\t\t\t\ttry (ObjectInputStream oistream = new ObjectInputStream(bastream)) {\n-\t\t\t\t\tval = getJavaBlob(oistream.readObject());\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tcatch (Throwable e) {\n-\t\t\t\tthrow new AerospikeException.Serialize(e);\n-\t\t\t}\n-\t\t\tbreak;\n-\n \t\tcase ParticleType.GEOJSON:\n \t\t\tval = getGeoJSON(Buffer.utf8ToString(buffer, offset, count));\n \t\t\tbreak;\n@@ -451,7 +434,6 @@ public T unpackObject() throws IOException, ClassNotFoundException {\n \n \tprotected abstract T getMap(Map<T,T> value);\n \tprotected abstract T getList(List<T> value);\n-\tprotected abstract T getJavaBlob(Object value);\n \tprotected abstract T getBlob(byte[] value);\n \tprotected abstract T getString(String value);\n \tprotected abstract T getLong(long value);\n@@ -498,11 +480,6 @@ protected Object getList(List<Object> value) {\n \t\t\treturn value;\n \t\t}\n \n-\t\t@Override\n-\t\tprotected Object getJavaBlob(Object value) {\n-\t\t\treturn value;\n-\t\t}\n-\n \t\t@Override\n \t\tprotected Object getBlob(byte[] value) {\n \t\t\treturn value;",
    "function_modified_lines": {
      "added": [],
      "deleted": [
        "\t\tcase ParticleType.JBLOB:\n",
        "\t\t\tif (Value.DisableDeserializer) {\n",
        "\t\t\t\tthrow new AerospikeException.Serialize(\"Object deserializer has been disabled\");\n",
        "\t\t\t}\n",
        "\n",
        "\t\t\ttry (ByteArrayInputStream bastream = new ByteArrayInputStream(buffer, offset, count)) {\n",
        "\t\t\t\ttry (ObjectInputStream oistream = new ObjectInputStream(bastream)) {\n",
        "\t\t\t\t\tval = getJavaBlob(oistream.readObject());\n",
        "\t\t\t\t}\n",
        "\t\t\t}\n",
        "\t\t\tcatch (Throwable e) {\n",
        "\t\t\t\tthrow new AerospikeException.Serialize(e);\n",
        "\t\t\t}\n",
        "\t\t\tbreak;\n",
        "\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "The Aerospike Java client is a Java application that implements a network protocol to communicate with an Aerospike server. Prior to versions 7.0.0, 6.2.0, 5.2.0, and 4.5.0 some of the messages received from the server contain Java objects that the client deserializes when it encounters them without further validation. Attackers that manage to trick clients into communicating with a malicious server can include especially crafted objects in its responses that, once deserialized by the client, force it to execute arbitrary code. This can be abused to take control of the machine the client is running on. Versions 7.0.0, 6.2.0, 5.2.0, and 4.5.0 contain a patch for this issue.",
    "id": 12739
  },
  {
    "cve_id": "CVE-2023-36480",
    "code_before_change": "{\n\n\t\tpublic ObjectUnpacker(byte[] buffer, int offset, int length) {\n\t\t\tsuper(buffer, offset, length);\n\t\t}\n\n\t\t@Override\n\t\tprotected Object getMap(Map<Object,Object> value) {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tprotected Object getList(List<Object> value) {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tprotected Object getJavaBlob(Object value) {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tprotected Object getBlob(byte[] value) {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tprotected Object getString(String value) {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tprotected Object getLong(long value) {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tprotected Object getDouble(double value) {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tprotected Object getBoolean(boolean value) {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tprotected Object getGeoJSON(String value) {\n\t\t\treturn Value.getAsGeoJSON(value);\n\t\t}\n\t}",
    "code_after_change": "{\n\n\t\tpublic ObjectUnpacker(byte[] buffer, int offset, int length) {\n\t\t\tsuper(buffer, offset, length);\n\t\t}\n\n\t\t@Override\n\t\tprotected Object getMap(Map<Object,Object> value) {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tprotected Object getList(List<Object> value) {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tprotected Object getBlob(byte[] value) {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tprotected Object getString(String value) {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tprotected Object getLong(long value) {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tprotected Object getDouble(double value) {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tprotected Object getBoolean(boolean value) {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tprotected Object getGeoJSON(String value) {\n\t\t\treturn Value.getAsGeoJSON(value);\n\t\t}\n\t}",
    "patch": "@@ -16,9 +16,7 @@\n  */\n package com.aerospike.client.util;\n \n-import java.io.ByteArrayInputStream;\n import java.io.IOException;\n-import java.io.ObjectInputStream;\n import java.nio.ByteBuffer;\n import java.util.AbstractMap;\n import java.util.ArrayList;\n@@ -234,21 +232,6 @@ private T unpackBlob(int count) throws IOException, ClassNotFoundException {\n \t\t\tval = getString(Buffer.utf8ToString(buffer, offset, count));\n \t\t\tbreak;\n \n-\t\tcase ParticleType.JBLOB:\n-\t\t\tif (Value.DisableDeserializer) {\n-\t\t\t\tthrow new AerospikeException.Serialize(\"Object deserializer has been disabled\");\n-\t\t\t}\n-\n-\t\t\ttry (ByteArrayInputStream bastream = new ByteArrayInputStream(buffer, offset, count)) {\n-\t\t\t\ttry (ObjectInputStream oistream = new ObjectInputStream(bastream)) {\n-\t\t\t\t\tval = getJavaBlob(oistream.readObject());\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tcatch (Throwable e) {\n-\t\t\t\tthrow new AerospikeException.Serialize(e);\n-\t\t\t}\n-\t\t\tbreak;\n-\n \t\tcase ParticleType.GEOJSON:\n \t\t\tval = getGeoJSON(Buffer.utf8ToString(buffer, offset, count));\n \t\t\tbreak;\n@@ -451,7 +434,6 @@ public T unpackObject() throws IOException, ClassNotFoundException {\n \n \tprotected abstract T getMap(Map<T,T> value);\n \tprotected abstract T getList(List<T> value);\n-\tprotected abstract T getJavaBlob(Object value);\n \tprotected abstract T getBlob(byte[] value);\n \tprotected abstract T getString(String value);\n \tprotected abstract T getLong(long value);\n@@ -498,11 +480,6 @@ protected Object getList(List<Object> value) {\n \t\t\treturn value;\n \t\t}\n \n-\t\t@Override\n-\t\tprotected Object getJavaBlob(Object value) {\n-\t\t\treturn value;\n-\t\t}\n-\n \t\t@Override\n \t\tprotected Object getBlob(byte[] value) {\n \t\t\treturn value;",
    "function_modified_lines": {
      "added": [],
      "deleted": [
        "\t\t@Override\n",
        "\t\tprotected Object getJavaBlob(Object value) {\n",
        "\t\t\treturn value;\n",
        "\t\t}\n",
        "\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "The Aerospike Java client is a Java application that implements a network protocol to communicate with an Aerospike server. Prior to versions 7.0.0, 6.2.0, 5.2.0, and 4.5.0 some of the messages received from the server contain Java objects that the client deserializes when it encounters them without further validation. Attackers that manage to trick clients into communicating with a malicious server can include especially crafted objects in its responses that, once deserialized by the client, force it to execute arbitrary code. This can be abused to take control of the machine the client is running on. Versions 7.0.0, 6.2.0, 5.2.0, and 4.5.0 contain a patch for this issue.",
    "id": 12740
  },
  {
    "cve_id": "CVE-2023-36480",
    "code_before_change": "{\n\t\tKey key = new Key(params.namespace, params.set, \"mapkey\");\n\t\tString binName = \"mapbin\";\n\n\t\t// Delete record if it already exists.\n\t\tclient.delete(params.writePolicy, key);\n\n\t\tList<Value> l1 = new ArrayList<Value>();\n\t\tl1.add(Value.get(new GregorianCalendar(2018, 1, 1).getTime()));\n\t\tl1.add(Value.get(1));\n\n\t\tList<Value> l2 = new ArrayList<Value>();\n\t\tl2.add(Value.get(new GregorianCalendar(2018, 1, 2).getTime()));\n\t\tl2.add(Value.get(2));\n\n\t\tList<Value> l3 = new ArrayList<Value>();\n\t\tl3.add(Value.get(new GregorianCalendar(2018, 2, 1).getTime()));\n\t\tl3.add(Value.get(3));\n\n\t\tList<Value> l4 = new ArrayList<Value>();\n\t\tl4.add(Value.get(new GregorianCalendar(2018, 2, 2).getTime()));\n\t\tl4.add(Value.get(4));\n\n\t\tList<Value> l5 = new ArrayList<Value>();\n\t\tl5.add(Value.get(new GregorianCalendar(2018, 2, 5).getTime()));\n\t\tl5.add(Value.get(5));\n\n\t\tMap<Value,Value> inputMap = new HashMap<Value,Value>();\n\t\tinputMap.put(Value.get(\"Charlie\"), Value.get(l1));\n\t\tinputMap.put(Value.get(\"Jim\"), Value.get(l2));\n\t\tinputMap.put(Value.get(\"John\"), Value.get(l3));\n\t\tinputMap.put(Value.get(\"Harry\"), Value.get(l4));\n\t\tinputMap.put(Value.get(\"Bill\"), Value.get(l5));\n\n\t\t// Write values to empty map.\n\t\tRecord record = client.operate(params.writePolicy, key,\n\t\t\t\tMapOperation.putItems(MapPolicy.Default, binName, inputMap)\n\t\t\t\t);\n\n\t\tconsole.info(\"Record: \" + record);\n\n\t\tList<Value> end = new ArrayList<Value>();\n\t\tend.add(Value.get(new GregorianCalendar(2018, 2, 2).getTime()));\n\t\tend.add(Value.getAsNull());\n\n\t\t// Delete values < end.\n\t\trecord = client.operate(params.writePolicy, key,\n\t\t\t\tMapOperation.removeByValueRange(binName, null, Value.get(end), MapReturnType.COUNT)\n\t\t\t\t);\n\n\t\tconsole.info(\"Record: \" + record);\n\t}",
    "code_after_change": "{\n\t\tKey key = new Key(params.namespace, params.set, \"mapkey\");\n\t\tString binName = \"mapbin\";\n\n\t\t// Delete record if it already exists.\n\t\tclient.delete(params.writePolicy, key);\n\n\t\tList<Value> l1 = new ArrayList<Value>();\n\t\tl1.add(Value.get(new GregorianCalendar(2018, 1, 1).getTimeInMillis()));\n\t\tl1.add(Value.get(1));\n\n\t\tList<Value> l2 = new ArrayList<Value>();\n\t\tl2.add(Value.get(new GregorianCalendar(2018, 1, 2).getTimeInMillis()));\n\t\tl2.add(Value.get(2));\n\n\t\tList<Value> l3 = new ArrayList<Value>();\n\t\tl3.add(Value.get(new GregorianCalendar(2018, 2, 1).getTimeInMillis()));\n\t\tl3.add(Value.get(3));\n\n\t\tList<Value> l4 = new ArrayList<Value>();\n\t\tl4.add(Value.get(new GregorianCalendar(2018, 2, 2).getTimeInMillis()));\n\t\tl4.add(Value.get(4));\n\n\t\tList<Value> l5 = new ArrayList<Value>();\n\t\tl5.add(Value.get(new GregorianCalendar(2018, 2, 5).getTimeInMillis()));\n\t\tl5.add(Value.get(5));\n\n\t\tMap<Value,Value> inputMap = new HashMap<Value,Value>();\n\t\tinputMap.put(Value.get(\"Charlie\"), Value.get(l1));\n\t\tinputMap.put(Value.get(\"Jim\"), Value.get(l2));\n\t\tinputMap.put(Value.get(\"John\"), Value.get(l3));\n\t\tinputMap.put(Value.get(\"Harry\"), Value.get(l4));\n\t\tinputMap.put(Value.get(\"Bill\"), Value.get(l5));\n\n\t\t// Write values to empty map.\n\t\tRecord record = client.operate(params.writePolicy, key,\n\t\t\t\tMapOperation.putItems(MapPolicy.Default, binName, inputMap)\n\t\t\t\t);\n\n\t\tconsole.info(\"Record: \" + record);\n\n\t\tList<Value> end = new ArrayList<Value>();\n\t\tend.add(Value.get(new GregorianCalendar(2018, 2, 2).getTimeInMillis()));\n\t\tend.add(Value.getAsNull());\n\n\t\t// Delete values < end.\n\t\trecord = client.operate(params.writePolicy, key,\n\t\t\t\tMapOperation.removeByValueRange(binName, null, Value.get(end), MapReturnType.COUNT)\n\t\t\t\t);\n\n\t\tconsole.info(\"Record: \" + record);\n\t}",
    "patch": "@@ -151,23 +151,23 @@ public void runListRangeExample(AerospikeClient client, Parameters params) {\n \t\tclient.delete(params.writePolicy, key);\n \n \t\tList<Value> l1 = new ArrayList<Value>();\n-\t\tl1.add(Value.get(new GregorianCalendar(2018, 1, 1).getTime()));\n+\t\tl1.add(Value.get(new GregorianCalendar(2018, 1, 1).getTimeInMillis()));\n \t\tl1.add(Value.get(1));\n \n \t\tList<Value> l2 = new ArrayList<Value>();\n-\t\tl2.add(Value.get(new GregorianCalendar(2018, 1, 2).getTime()));\n+\t\tl2.add(Value.get(new GregorianCalendar(2018, 1, 2).getTimeInMillis()));\n \t\tl2.add(Value.get(2));\n \n \t\tList<Value> l3 = new ArrayList<Value>();\n-\t\tl3.add(Value.get(new GregorianCalendar(2018, 2, 1).getTime()));\n+\t\tl3.add(Value.get(new GregorianCalendar(2018, 2, 1).getTimeInMillis()));\n \t\tl3.add(Value.get(3));\n \n \t\tList<Value> l4 = new ArrayList<Value>();\n-\t\tl4.add(Value.get(new GregorianCalendar(2018, 2, 2).getTime()));\n+\t\tl4.add(Value.get(new GregorianCalendar(2018, 2, 2).getTimeInMillis()));\n \t\tl4.add(Value.get(4));\n \n \t\tList<Value> l5 = new ArrayList<Value>();\n-\t\tl5.add(Value.get(new GregorianCalendar(2018, 2, 5).getTime()));\n+\t\tl5.add(Value.get(new GregorianCalendar(2018, 2, 5).getTimeInMillis()));\n \t\tl5.add(Value.get(5));\n \n \t\tMap<Value,Value> inputMap = new HashMap<Value,Value>();\n@@ -185,7 +185,7 @@ public void runListRangeExample(AerospikeClient client, Parameters params) {\n \t\tconsole.info(\"Record: \" + record);\n \n \t\tList<Value> end = new ArrayList<Value>();\n-\t\tend.add(Value.get(new GregorianCalendar(2018, 2, 2).getTime()));\n+\t\tend.add(Value.get(new GregorianCalendar(2018, 2, 2).getTimeInMillis()));\n \t\tend.add(Value.getAsNull());\n \n \t\t// Delete values < end.",
    "function_modified_lines": {
      "added": [
        "\t\tl1.add(Value.get(new GregorianCalendar(2018, 1, 1).getTimeInMillis()));\n",
        "\t\tl2.add(Value.get(new GregorianCalendar(2018, 1, 2).getTimeInMillis()));\n",
        "\t\tl3.add(Value.get(new GregorianCalendar(2018, 2, 1).getTimeInMillis()));\n",
        "\t\tl4.add(Value.get(new GregorianCalendar(2018, 2, 2).getTimeInMillis()));\n",
        "\t\tl5.add(Value.get(new GregorianCalendar(2018, 2, 5).getTimeInMillis()));\n"
      ],
      "deleted": [
        "\t\tl1.add(Value.get(new GregorianCalendar(2018, 1, 1).getTime()));\n",
        "\t\tl2.add(Value.get(new GregorianCalendar(2018, 1, 2).getTime()));\n",
        "\t\tl3.add(Value.get(new GregorianCalendar(2018, 2, 1).getTime()));\n",
        "\t\tl4.add(Value.get(new GregorianCalendar(2018, 2, 2).getTime()));\n",
        "\t\tl5.add(Value.get(new GregorianCalendar(2018, 2, 5).getTime()));\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "The Aerospike Java client is a Java application that implements a network protocol to communicate with an Aerospike server. Prior to versions 7.0.0, 6.2.0, 5.2.0, and 4.5.0 some of the messages received from the server contain Java objects that the client deserializes when it encounters them without further validation. Attackers that manage to trick clients into communicating with a malicious server can include especially crafted objects in its responses that, once deserialized by the client, force it to execute arbitrary code. This can be abused to take control of the machine the client is running on. Versions 7.0.0, 6.2.0, 5.2.0, and 4.5.0 contain a patch for this issue.",
    "id": 12741
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "{\n\n\tpublic int everyNthTick = 20 * 60;\n\tpublic ItemIdentifier item;\n\tpublic int arrayPos = 0;\n\tpublic long[] amountRecorded = new long[1440]; //24h with 20ticks and 60sec\n\n\tpublic void tick(int tickCount, CoreRoutedPipe pipe) {\n\t\tif (tickCount % everyNthTick != 0) {\n\t\t\treturn;\n\t\t}\n\t\tIRouter router = pipe.getRouter();\n\t\tif (router == null) {\n\t\t\treturn;\n\t\t}\n\t\tamountRecorded[arrayPos++] = SimpleServiceLocator.logisticsManager.getAmountFor(item, router.getIRoutersByCost());\n\t\tif (arrayPos >= amountRecorded.length) {\n\t\t\tarrayPos = 0;\n\t\t}\n\t}\n\n\tpublic void readFromNBT(NBTTagCompound nbt) {\n\t\tint[] amountRecorded_A = nbt.getIntArray(\"amountRecorded_A\");\n\t\tint[] amountRecorded_B = nbt.getIntArray(\"amountRecorded_B\");\n\t\tfor (int i = 0; i < amountRecorded.length; i++) {\n\t\t\tif (i >= amountRecorded_A.length || i >= amountRecorded_B.length) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tamountRecorded[i] = (((long) amountRecorded_B[i]) << 32) | amountRecorded_A[i];\n\t\t}\n\t\tarrayPos = nbt.getInteger(\"arrayPos\");\n\t\titem = ItemIdentifier.get(ItemStack.loadItemStackFromNBT(nbt));\n\t}\n\n\tpublic void writeToNBT(NBTTagCompound nbt) {\n\t\tint[] amountRecorded_A = new int[amountRecorded.length];\n\t\tint[] amountRecorded_B = new int[amountRecorded.length];\n\t\tfor (int i = 0; i < amountRecorded.length; i++) {\n\t\t\tamountRecorded_A[i] = (int) amountRecorded[i];\n\t\t\tamountRecorded_B[i] = (int) (amountRecorded[i] >> 32);\n\t\t}\n\t\tnbt.setIntArray(\"amountRecorded_A\", amountRecorded_A);\n\t\tnbt.setIntArray(\"amountRecorded_B\", amountRecorded_B);\n\t\tnbt.setInteger(\"arrayPos\", arrayPos);\n\t\titem.makeNormalStack(1).writeToNBT(nbt);\n\t}\n\n\tpublic void writeToLPData(LPDataOutput output) throws IOException {\n\t\toutput.writeLongArray(amountRecorded);\n\t\toutput.writeInt(arrayPos);\n\t\toutput.writeItemIdentifier(item);\n\t}\n\n\tpublic void readFromLPData(LPDataInput input) throws IOException {\n\t\tamountRecorded = input.readLongArray();\n\t\tarrayPos = input.readInt();\n\t\titem = input.readItemIdentifier();\n\t}\n}",
    "code_after_change": "{\n\n\tpublic int everyNthTick = 20 * 60;\n\tpublic ItemIdentifier item;\n\tpublic int arrayPos = 0;\n\tpublic long[] amountRecorded = new long[1440]; //24h with 20ticks and 60sec\n\n\tpublic void tick(int tickCount, CoreRoutedPipe pipe) {\n\t\tif (tickCount % everyNthTick != 0) {\n\t\t\treturn;\n\t\t}\n\t\tIRouter router = pipe.getRouter();\n\t\tif (router == null) {\n\t\t\treturn;\n\t\t}\n\t\tamountRecorded[arrayPos++] = SimpleServiceLocator.logisticsManager.getAmountFor(item, router.getIRoutersByCost());\n\t\tif (arrayPos >= amountRecorded.length) {\n\t\t\tarrayPos = 0;\n\t\t}\n\t}\n\n\tpublic void readFromNBT(NBTTagCompound nbt) {\n\t\tint[] amountRecorded_A = nbt.getIntArray(\"amountRecorded_A\");\n\t\tint[] amountRecorded_B = nbt.getIntArray(\"amountRecorded_B\");\n\t\tfor (int i = 0; i < amountRecorded.length; i++) {\n\t\t\tif (i >= amountRecorded_A.length || i >= amountRecorded_B.length) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tamountRecorded[i] = (((long) amountRecorded_B[i]) << 32) | amountRecorded_A[i];\n\t\t}\n\t\tarrayPos = nbt.getInteger(\"arrayPos\");\n\t\titem = ItemIdentifier.get(ItemStack.loadItemStackFromNBT(nbt));\n\t}\n\n\tpublic void writeToNBT(NBTTagCompound nbt) {\n\t\tint[] amountRecorded_A = new int[amountRecorded.length];\n\t\tint[] amountRecorded_B = new int[amountRecorded.length];\n\t\tfor (int i = 0; i < amountRecorded.length; i++) {\n\t\t\tamountRecorded_A[i] = (int) amountRecorded[i];\n\t\t\tamountRecorded_B[i] = (int) (amountRecorded[i] >> 32);\n\t\t}\n\t\tnbt.setIntArray(\"amountRecorded_A\", amountRecorded_A);\n\t\tnbt.setIntArray(\"amountRecorded_B\", amountRecorded_B);\n\t\tnbt.setInteger(\"arrayPos\", arrayPos);\n\t\titem.makeNormalStack(1).writeToNBT(nbt);\n\t}\n\n\tpublic void writeToLPData(LPDataOutput output) {\n\t\toutput.writeLongArray(amountRecorded);\n\t\toutput.writeInt(arrayPos);\n\t\toutput.writeItemIdentifier(item);\n\t}\n\n\tpublic void readFromLPData(LPDataInput input) {\n\t\tamountRecorded = input.readLongArray();\n\t\tarrayPos = input.readInt();\n\t\titem = input.readItemIdentifier();\n\t}\n}",
    "patch": "@@ -1,7 +1,5 @@\n package logisticspipes.blocks.stats;\n \n-import java.io.IOException;\n-\n import net.minecraft.item.ItemStack;\n import net.minecraft.nbt.NBTTagCompound;\n \n@@ -59,13 +57,13 @@ public void writeToNBT(NBTTagCompound nbt) {\n \t\titem.makeNormalStack(1).writeToNBT(nbt);\n \t}\n \n-\tpublic void writeToLPData(LPDataOutput output) throws IOException {\n+\tpublic void writeToLPData(LPDataOutput output) {\n \t\toutput.writeLongArray(amountRecorded);\n \t\toutput.writeInt(arrayPos);\n \t\toutput.writeItemIdentifier(item);\n \t}\n \n-\tpublic void readFromLPData(LPDataInput input) throws IOException {\n+\tpublic void readFromLPData(LPDataInput input) {\n \t\tamountRecorded = input.readLongArray();\n \t\tarrayPos = input.readInt();\n \t\titem = input.readItemIdentifier();",
    "function_modified_lines": {
      "added": [
        "\tpublic void writeToLPData(LPDataOutput output) {\n",
        "\tpublic void readFromLPData(LPDataInput input) {\n"
      ],
      "deleted": [
        "\tpublic void writeToLPData(LPDataOutput output) throws IOException {\n",
        "\tpublic void readFromLPData(LPDataInput input) throws IOException {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12758
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "package logisticspipes.interfaces;\n\nimport java.io.IOException;\n\nimport network.rs485.logisticspipes.util.LPDataInput;\nimport network.rs485.logisticspipes.util.LPDataOutput;\n\npublic interface IClientState {\n\n\tvoid writeData(LPDataOutput output) throws IOException;\n\n\tvoid readData(LPDataInput input) throws IOException;\n}\n",
    "code_after_change": "{\n\n\tvoid writeData(LPDataOutput output);\n\n\tvoid readData(LPDataInput input);\n}",
    "patch": "@@ -1,13 +1,11 @@\n package logisticspipes.interfaces;\n \n-import java.io.IOException;\n-\n import network.rs485.logisticspipes.util.LPDataInput;\n import network.rs485.logisticspipes.util.LPDataOutput;\n \n public interface IClientState {\n \n-\tvoid writeData(LPDataOutput output) throws IOException;\n+\tvoid writeData(LPDataOutput output);\n \n-\tvoid readData(LPDataInput input) throws IOException;\n+\tvoid readData(LPDataInput input);\n }",
    "function_modified_lines": {
      "added": [
        "\tvoid writeData(LPDataOutput output);\n",
        "\tvoid readData(LPDataInput input);\n"
      ],
      "deleted": [
        "import java.io.IOException;\n",
        "\n",
        "\tvoid writeData(LPDataOutput output) throws IOException;\n",
        "\tvoid readData(LPDataInput input) throws IOException;\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12759
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "{\n\n\tpublic static List<ModernPacket> packetlist;\n\tpublic static Map<Class<? extends ModernPacket>, ModernPacket> packetmap;\n\n\tprivate static int packetDebugID = 1;\n\tpublic static final Map<Integer, StackTraceElement[]> debugMap = new HashMap<>();\n\n\t@SuppressWarnings(\"unchecked\")\n\t// Suppressed because this cast should never fail.\n\tpublic static <T extends ModernPacket> T getPacket(Class<T> clazz) {\n\t\tT packet = (T) PacketHandler.packetmap.get(clazz).template();\n\t\tif (LPConstants.DEBUG && MainProxy.proxy.getSide().equals(\"Client\")) {\n\t\t\tStackTraceElement[] trace = Thread.currentThread().getStackTrace();\n\t\t\tsynchronized (PacketHandler.debugMap) { //Unique id\n\t\t\t\tint id = PacketHandler.packetDebugID++;\n\t\t\t\tPacketHandler.debugMap.put(id, trace);\n\t\t\t\tpacket.setDebugId(id);\n\t\t\t}\n\t\t}\n\t\treturn packet;\n\t}\n\n\t//horrible hack to carry the proper player for the side along...\n\tstatic class InboundModernPacketWrapper {\n\n\t\tfinal ModernPacket packet;\n\t\tfinal EntityPlayer player;\n\n\t\tInboundModernPacketWrapper(ModernPacket p, EntityPlayer e) {\n\t\t\tpacket = p;\n\t\t\tplayer = e;\n\t\t}\n\t}\n\n\t/*\n\t * enumerates all ModernPackets, sets their IDs and populate packetlist/packetmap\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\t@SneakyThrows({ IOException.class, InvocationTargetException.class, IllegalAccessException.class, InstantiationException.class, IllegalArgumentException.class, NoSuchMethodException.class, SecurityException.class })\n\t// Suppression+sneakiness because these shouldn't ever fail, and if they do, it needs to fail.\n\tpublic static final void initialize() {\n\t\tfinal List<ClassInfo> classes = new ArrayList<>(ClassPath.from(PacketHandler.class.getClassLoader())\n\t\t\t\t.getTopLevelClassesRecursive(\"logisticspipes.network.packets\"));\n\t\tCollections.sort(classes, (o1, o2) -> o1.getSimpleName().compareTo(o2.getSimpleName()));\n\n\t\tPacketHandler.packetlist = new ArrayList<>(classes.size());\n\t\tPacketHandler.packetmap = new HashMap<>(classes.size());\n\n\t\tint currentid = 0;\n\n\t\tfor (ClassInfo c : classes) {\n\t\t\tfinal Class<?> cls = c.load();\n\t\t\tfinal ModernPacket instance = (ModernPacket) cls.getConstructor(int.class).newInstance(currentid);\n\t\t\tPacketHandler.packetlist.add(instance);\n\t\t\tPacketHandler.packetmap.put((Class<? extends ModernPacket>) cls, instance);\n\t\t\tcurrentid++;\n\t\t}\n\t}\n\n\t//TODO correct to work with WeakReference (See FML original)\n\tprotected static final AttributeKey<ThreadLocal<FMLProxyPacket>> INBOUNDPACKETTRACKER = new AttributeKey<>(\"lp:inboundpacket\");\n\n\t@Override\n\tpublic void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n\t\tsuper.handlerAdded(ctx);\n\t\tctx.attr(PacketHandler.INBOUNDPACKETTRACKER).set(new ThreadLocal<>());\n\t}\n\n\t//Used to provide the Description packet\n\tpublic static FMLProxyPacket toFMLPacket(ModernPacket msg) throws Exception {\n\t\treturn PacketHandler.toFMLPacket(msg, MainProxy.networkChannelName);\n\t}\n\n\tprivate static FMLProxyPacket toFMLPacket(ModernPacket msg, String channel) throws Exception {\n\t\tByteBuf buffer = Unpooled.buffer();\n\t\tbuffer.writeShort(msg.getId());\n\t\tbuffer.writeInt(msg.getDebugId());\n\n\t\tLPDataIOWrapper.writeData(buffer, msg::writeData);\n\n\t\treturn new FMLProxyPacket(buffer, channel);\n\t}\n\n\t@Override\n\tprotected final void encode(ChannelHandlerContext ctx, ModernPacket msg, List<Object> out) throws Exception {\n\t\tFMLProxyPacket proxy = PacketHandler.toFMLPacket(msg, ctx.channel().attr(NetworkRegistry.FML_CHANNEL).get());\n\t\tFMLProxyPacket old = ctx.attr(PacketHandler.INBOUNDPACKETTRACKER).get().get();\n\t\tif (old != null) {\n\t\t\tproxy.setDispatcher(old.getDispatcher());\n\t\t}\n\t\tout.add(proxy);\n\t}\n\n\t@Override\n\tprotected final void decode(ChannelHandlerContext ctx, FMLProxyPacket msg, List<Object> out) throws Exception {\n\t\tByteBuf payload = msg.payload();\n\t\tint packetID = payload.readShort();\n\t\tfinal ModernPacket packet = PacketHandler.packetlist.get(packetID).template();\n\t\tpacket.setDebugId(payload.readInt());\n\t\tctx.attr(PacketHandler.INBOUNDPACKETTRACKER).get().set(msg);\n\n\t\tLPDataIOWrapper.provideData(payload.slice(), packet::readData);\n\n\t\tout.add(new InboundModernPacketWrapper(packet, MainProxy.proxy.getEntityPlayerFromNetHandler(msg.handler())));\n\t}\n\n\t@Override\n\tpublic void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n\t\tFMLLog.log(Level.ERROR, cause, \"LogisticsPipes PacketHandler exception caught\");\n\t\tsuper.exceptionCaught(ctx, cause);\n\t}\n\n\t//hacky callback to process packets coming from by the packetbufferhandler decompressors\n\t//TODO replace with proper netty implementation\n\tpublic static void onPacketData(final LPDataInput data, final EntityPlayer player) throws IOException {\n\t\tif (player == null) {\n\t\t\treturn;\n\t\t}\n\t\tfinal int packetID = data.readShort();\n\t\tfinal ModernPacket packet = PacketHandler.packetlist.get(packetID).template();\n\t\tpacket.setDebugId(data.readInt());\n\t\tpacket.readData(data);\n\t\tPacketHandler.onPacketData(packet, player);\n\t}\n\n\tprivate static void onPacketData(ModernPacket packet, final EntityPlayer player) {\n\t\ttry {\n\t\t\tpacket.processPacket(player);\n\t\t\tif (LPConstants.DEBUG) {\n\t\t\t\tPacketHandler.debugMap.remove(packet.getDebugId());\n\t\t\t}\n\t\t} catch (DelayPacketException e) {\n\t\t\tif (packet.retry() && MainProxy.isClient(player.getEntityWorld())) {\n\t\t\t\tSimpleServiceLocator.clientBufferHandler.queueFailedPacket(packet, player);\n\t\t\t} else if (LPConstants.DEBUG) {\n\t\t\t\tLogisticsPipes.log.error(packet.getClass().getName());\n\t\t\t\tLogisticsPipes.log.error(packet.toString());\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n}",
    "code_after_change": "{\n\n\tpublic static final Map<Integer, StackTraceElement[]> debugMap = new HashMap<>();\n\t//TODO correct to work with WeakReference (See FML original)\n\tprotected static final AttributeKey<ThreadLocal<FMLProxyPacket>> INBOUNDPACKETTRACKER = new AttributeKey<>(\"lp:inboundpacket\");\n\tpublic static List<ModernPacket> packetlist;\n\tpublic static Map<Class<? extends ModernPacket>, ModernPacket> packetmap;\n\tprivate static int packetDebugID = 1;\n\n\t@SuppressWarnings(\"unchecked\")\n\t// Suppressed because this cast should never fail.\n\tpublic static <T extends ModernPacket> T getPacket(Class<T> clazz) {\n\t\tT packet = (T) PacketHandler.packetmap.get(clazz).template();\n\t\tif (LPConstants.DEBUG && MainProxy.proxy.getSide().equals(\"Client\")) {\n\t\t\tStackTraceElement[] trace = Thread.currentThread().getStackTrace();\n\t\t\tsynchronized (PacketHandler.debugMap) { //Unique id\n\t\t\t\tint id = PacketHandler.packetDebugID++;\n\t\t\t\tPacketHandler.debugMap.put(id, trace);\n\t\t\t\tpacket.setDebugId(id);\n\t\t\t}\n\t\t}\n\t\treturn packet;\n\t}\n\n\t/*\n\t * enumerates all ModernPackets, sets their IDs and populate packetlist/packetmap\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\t@SneakyThrows({ IOException.class, InvocationTargetException.class, IllegalAccessException.class, InstantiationException.class, IllegalArgumentException.class, NoSuchMethodException.class, SecurityException.class })\n\t// Suppression+sneakiness because these shouldn't ever fail, and if they do, it needs to fail.\n\tpublic static final void initialize() {\n\t\tfinal List<ClassInfo> classes = new ArrayList<>(ClassPath.from(PacketHandler.class.getClassLoader())\n\t\t\t\t.getTopLevelClassesRecursive(\"logisticspipes.network.packets\"));\n\t\tCollections.sort(classes, (o1, o2) -> o1.getSimpleName().compareTo(o2.getSimpleName()));\n\n\t\tPacketHandler.packetlist = new ArrayList<>(classes.size());\n\t\tPacketHandler.packetmap = new HashMap<>(classes.size());\n\n\t\tint currentid = 0;\n\n\t\tfor (ClassInfo c : classes) {\n\t\t\tfinal Class<?> cls = c.load();\n\t\t\tfinal ModernPacket instance = (ModernPacket) cls.getConstructor(int.class).newInstance(currentid);\n\t\t\tPacketHandler.packetlist.add(instance);\n\t\t\tPacketHandler.packetmap.put((Class<? extends ModernPacket>) cls, instance);\n\t\t\tcurrentid++;\n\t\t}\n\t}\n\n\t//Used to provide the Description packet\n\tpublic static FMLProxyPacket toFMLPacket(ModernPacket msg) throws Exception {\n\t\treturn PacketHandler.toFMLPacket(msg, MainProxy.networkChannelName);\n\t}\n\n\tprivate static FMLProxyPacket toFMLPacket(ModernPacket msg, String channel) throws Exception {\n\t\tByteBuf buffer = Unpooled.buffer();\n\t\tbuffer.writeShort(msg.getId());\n\t\tbuffer.writeInt(msg.getDebugId());\n\n\t\tLPDataIOWrapper.writeData(buffer, msg::writeData);\n\n\t\treturn new FMLProxyPacket(buffer, channel);\n\t}\n\n\t//hacky callback to process packets coming from by the packetbufferhandler decompressors\n\t//TODO replace with proper netty implementation\n\tpublic static void onPacketData(final LPDataInput data, final EntityPlayer player) {\n\t\tif (player == null) {\n\t\t\treturn;\n\t\t}\n\t\tfinal int packetID = data.readShort();\n\t\tfinal ModernPacket packet = PacketHandler.packetlist.get(packetID).template();\n\t\tpacket.setDebugId(data.readInt());\n\t\tpacket.readData(data);\n\t\tPacketHandler.onPacketData(packet, player);\n\t}\n\n\tprivate static void onPacketData(ModernPacket packet, final EntityPlayer player) {\n\t\ttry {\n\t\t\tpacket.processPacket(player);\n\t\t\tif (LPConstants.DEBUG) {\n\t\t\t\tPacketHandler.debugMap.remove(packet.getDebugId());\n\t\t\t}\n\t\t} catch (DelayPacketException e) {\n\t\t\tif (packet.retry() && MainProxy.isClient(player.getEntityWorld())) {\n\t\t\t\tSimpleServiceLocator.clientBufferHandler.queueFailedPacket(packet, player);\n\t\t\t} else if (LPConstants.DEBUG) {\n\t\t\t\tLogisticsPipes.log.error(packet.getClass().getName());\n\t\t\t\tLogisticsPipes.log.error(packet.toString());\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n\t\tsuper.handlerAdded(ctx);\n\t\tctx.attr(PacketHandler.INBOUNDPACKETTRACKER).set(new ThreadLocal<>());\n\t}\n\n\t@Override\n\tprotected final void encode(ChannelHandlerContext ctx, ModernPacket msg, List<Object> out) throws Exception {\n\t\tFMLProxyPacket proxy = PacketHandler.toFMLPacket(msg, ctx.channel().attr(NetworkRegistry.FML_CHANNEL).get());\n\t\tFMLProxyPacket old = ctx.attr(PacketHandler.INBOUNDPACKETTRACKER).get().get();\n\t\tif (old != null) {\n\t\t\tproxy.setDispatcher(old.getDispatcher());\n\t\t}\n\t\tout.add(proxy);\n\t}\n\n\t@Override\n\tprotected final void decode(ChannelHandlerContext ctx, FMLProxyPacket msg, List<Object> out) throws Exception {\n\t\tByteBuf payload = msg.payload();\n\t\tint packetID = payload.readShort();\n\t\tfinal ModernPacket packet = PacketHandler.packetlist.get(packetID).template();\n\t\tpacket.setDebugId(payload.readInt());\n\t\tctx.attr(PacketHandler.INBOUNDPACKETTRACKER).get().set(msg);\n\n\t\tLPDataIOWrapper.provideData(payload.slice(), packet::readData);\n\n\t\tout.add(new InboundModernPacketWrapper(packet, MainProxy.proxy.getEntityPlayerFromNetHandler(msg.handler())));\n\t}\n\n\t@Override\n\tpublic void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n\t\tFMLLog.log(Level.ERROR, cause, \"LogisticsPipes PacketHandler exception caught\");\n\t\tsuper.exceptionCaught(ctx, cause);\n\t}\n\n\t//horrible hack to carry the proper player for the side along...\n\tstatic class InboundModernPacketWrapper {\n\n\t\tfinal ModernPacket packet;\n\t\tfinal EntityPlayer player;\n\n\t\tInboundModernPacketWrapper(ModernPacket p, EntityPlayer e) {\n\t\t\tpacket = p;\n\t\t\tplayer = e;\n\t\t}\n\t}\n}",
    "patch": "@@ -39,11 +39,12 @@\n @Sharable\n public class PacketHandler extends MessageToMessageCodec<FMLProxyPacket, ModernPacket> {\n \n+\tpublic static final Map<Integer, StackTraceElement[]> debugMap = new HashMap<>();\n+\t//TODO correct to work with WeakReference (See FML original)\n+\tprotected static final AttributeKey<ThreadLocal<FMLProxyPacket>> INBOUNDPACKETTRACKER = new AttributeKey<>(\"lp:inboundpacket\");\n \tpublic static List<ModernPacket> packetlist;\n \tpublic static Map<Class<? extends ModernPacket>, ModernPacket> packetmap;\n-\n \tprivate static int packetDebugID = 1;\n-\tpublic static final Map<Integer, StackTraceElement[]> debugMap = new HashMap<>();\n \n \t@SuppressWarnings(\"unchecked\")\n \t// Suppressed because this cast should never fail.\n@@ -60,18 +61,6 @@ public static <T extends ModernPacket> T getPacket(Class<T> clazz) {\n \t\treturn packet;\n \t}\n \n-\t//horrible hack to carry the proper player for the side along...\n-\tstatic class InboundModernPacketWrapper {\n-\n-\t\tfinal ModernPacket packet;\n-\t\tfinal EntityPlayer player;\n-\n-\t\tInboundModernPacketWrapper(ModernPacket p, EntityPlayer e) {\n-\t\t\tpacket = p;\n-\t\t\tplayer = e;\n-\t\t}\n-\t}\n-\n \t/*\n \t * enumerates all ModernPackets, sets their IDs and populate packetlist/packetmap\n \t */\n@@ -97,15 +86,6 @@ public static final void initialize() {\n \t\t}\n \t}\n \n-\t//TODO correct to work with WeakReference (See FML original)\n-\tprotected static final AttributeKey<ThreadLocal<FMLProxyPacket>> INBOUNDPACKETTRACKER = new AttributeKey<>(\"lp:inboundpacket\");\n-\n-\t@Override\n-\tpublic void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n-\t\tsuper.handlerAdded(ctx);\n-\t\tctx.attr(PacketHandler.INBOUNDPACKETTRACKER).set(new ThreadLocal<>());\n-\t}\n-\n \t//Used to provide the Description packet\n \tpublic static FMLProxyPacket toFMLPacket(ModernPacket msg) throws Exception {\n \t\treturn PacketHandler.toFMLPacket(msg, MainProxy.networkChannelName);\n@@ -121,6 +101,44 @@ private static FMLProxyPacket toFMLPacket(ModernPacket msg, String channel) thro\n \t\treturn new FMLProxyPacket(buffer, channel);\n \t}\n \n+\t//hacky callback to process packets coming from by the packetbufferhandler decompressors\n+\t//TODO replace with proper netty implementation\n+\tpublic static void onPacketData(final LPDataInput data, final EntityPlayer player) {\n+\t\tif (player == null) {\n+\t\t\treturn;\n+\t\t}\n+\t\tfinal int packetID = data.readShort();\n+\t\tfinal ModernPacket packet = PacketHandler.packetlist.get(packetID).template();\n+\t\tpacket.setDebugId(data.readInt());\n+\t\tpacket.readData(data);\n+\t\tPacketHandler.onPacketData(packet, player);\n+\t}\n+\n+\tprivate static void onPacketData(ModernPacket packet, final EntityPlayer player) {\n+\t\ttry {\n+\t\t\tpacket.processPacket(player);\n+\t\t\tif (LPConstants.DEBUG) {\n+\t\t\t\tPacketHandler.debugMap.remove(packet.getDebugId());\n+\t\t\t}\n+\t\t} catch (DelayPacketException e) {\n+\t\t\tif (packet.retry() && MainProxy.isClient(player.getEntityWorld())) {\n+\t\t\t\tSimpleServiceLocator.clientBufferHandler.queueFailedPacket(packet, player);\n+\t\t\t} else if (LPConstants.DEBUG) {\n+\t\t\t\tLogisticsPipes.log.error(packet.getClass().getName());\n+\t\t\t\tLogisticsPipes.log.error(packet.toString());\n+\t\t\t\te.printStackTrace();\n+\t\t\t}\n+\t\t} catch (Exception e) {\n+\t\t\tthrow new RuntimeException(e);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n+\t\tsuper.handlerAdded(ctx);\n+\t\tctx.attr(PacketHandler.INBOUNDPACKETTRACKER).set(new ThreadLocal<>());\n+\t}\n+\n \t@Override\n \tprotected final void encode(ChannelHandlerContext ctx, ModernPacket msg, List<Object> out) throws Exception {\n \t\tFMLProxyPacket proxy = PacketHandler.toFMLPacket(msg, ctx.channel().attr(NetworkRegistry.FML_CHANNEL).get());\n@@ -150,35 +168,15 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws E\n \t\tsuper.exceptionCaught(ctx, cause);\n \t}\n \n-\t//hacky callback to process packets coming from by the packetbufferhandler decompressors\n-\t//TODO replace with proper netty implementation\n-\tpublic static void onPacketData(final LPDataInput data, final EntityPlayer player) throws IOException {\n-\t\tif (player == null) {\n-\t\t\treturn;\n-\t\t}\n-\t\tfinal int packetID = data.readShort();\n-\t\tfinal ModernPacket packet = PacketHandler.packetlist.get(packetID).template();\n-\t\tpacket.setDebugId(data.readInt());\n-\t\tpacket.readData(data);\n-\t\tPacketHandler.onPacketData(packet, player);\n-\t}\n+\t//horrible hack to carry the proper player for the side along...\n+\tstatic class InboundModernPacketWrapper {\n \n-\tprivate static void onPacketData(ModernPacket packet, final EntityPlayer player) {\n-\t\ttry {\n-\t\t\tpacket.processPacket(player);\n-\t\t\tif (LPConstants.DEBUG) {\n-\t\t\t\tPacketHandler.debugMap.remove(packet.getDebugId());\n-\t\t\t}\n-\t\t} catch (DelayPacketException e) {\n-\t\t\tif (packet.retry() && MainProxy.isClient(player.getEntityWorld())) {\n-\t\t\t\tSimpleServiceLocator.clientBufferHandler.queueFailedPacket(packet, player);\n-\t\t\t} else if (LPConstants.DEBUG) {\n-\t\t\t\tLogisticsPipes.log.error(packet.getClass().getName());\n-\t\t\t\tLogisticsPipes.log.error(packet.toString());\n-\t\t\t\te.printStackTrace();\n-\t\t\t}\n-\t\t} catch (Exception e) {\n-\t\t\tthrow new RuntimeException(e);\n+\t\tfinal ModernPacket packet;\n+\t\tfinal EntityPlayer player;\n+\n+\t\tInboundModernPacketWrapper(ModernPacket p, EntityPlayer e) {\n+\t\t\tpacket = p;\n+\t\t\tplayer = e;\n \t\t}\n \t}\n }",
    "function_modified_lines": {
      "added": [],
      "deleted": [
        "\t//horrible hack to carry the proper player for the side along...\n",
        "\tstatic class InboundModernPacketWrapper {\n",
        "\n",
        "\t\tfinal ModernPacket packet;\n",
        "\t\tfinal EntityPlayer player;\n",
        "\n",
        "\t\tInboundModernPacketWrapper(ModernPacket p, EntityPlayer e) {\n",
        "\t\t\tpacket = p;\n",
        "\t\t\tplayer = e;\n",
        "\t\t}\n",
        "\t}\n",
        "\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12760
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "package logisticspipes.network.abstractguis;\n\nimport java.io.IOException;\n\nimport lombok.Getter;\nimport lombok.Setter;\n\nimport network.rs485.logisticspipes.util.LPDataInput;\nimport network.rs485.logisticspipes.util.LPDataOutput;\n\npublic abstract class BooleanModuleCoordinatesGuiProvider extends ModuleCoordinatesGuiProvider {\n\n\tpublic BooleanModuleCoordinatesGuiProvider(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Getter\n\t@Setter\n\tprivate boolean flag;\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\tsuper.writeData(output);\n\t\toutput.writeBoolean(flag);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tsuper.readData(input);\n\t\tflag = input.readBoolean();\n\t}\n}\n",
    "code_after_change": "package logisticspipes.network.abstractguis;\n\nimport lombok.Getter;\nimport lombok.Setter;\n\nimport network.rs485.logisticspipes.util.LPDataInput;\nimport network.rs485.logisticspipes.util.LPDataOutput;\n\npublic abstract class BooleanModuleCoordinatesGuiProvider extends ModuleCoordinatesGuiProvider {\n\n\t@Getter\n\t@Setter\n\tprivate boolean flag;\n\n\tpublic BooleanModuleCoordinatesGuiProvider(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\tsuper.writeData(output);\n\t\toutput.writeBoolean(flag);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tsuper.readData(input);\n\t\tflag = input.readBoolean();\n\t}\n}\n",
    "patch": "@@ -1,7 +1,5 @@\n package logisticspipes.network.abstractguis;\n \n-import java.io.IOException;\n-\n import lombok.Getter;\n import lombok.Setter;\n \n@@ -10,22 +8,22 @@\n \n public abstract class BooleanModuleCoordinatesGuiProvider extends ModuleCoordinatesGuiProvider {\n \n-\tpublic BooleanModuleCoordinatesGuiProvider(int id) {\n-\t\tsuper(id);\n-\t}\n-\n \t@Getter\n \t@Setter\n \tprivate boolean flag;\n \n+\tpublic BooleanModuleCoordinatesGuiProvider(int id) {\n+\t\tsuper(id);\n+\t}\n+\n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\tsuper.writeData(output);\n \t\toutput.writeBoolean(flag);\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tsuper.readData(input);\n \t\tflag = input.readBoolean();\n \t}",
    "function_modified_lines": {
      "added": [
        "\tpublic BooleanModuleCoordinatesGuiProvider(int id) {\n",
        "\t\tsuper(id);\n",
        "\t}\n",
        "\n",
        "\tpublic void writeData(LPDataOutput output) {\n",
        "\tpublic void readData(LPDataInput input) {\n"
      ],
      "deleted": [
        "import java.io.IOException;\n",
        "\n",
        "\tpublic BooleanModuleCoordinatesGuiProvider(int id) {\n",
        "\t\tsuper(id);\n",
        "\t}\n",
        "\n",
        "\tpublic void writeData(LPDataOutput output) throws IOException {\n",
        "\tpublic void readData(LPDataInput input) throws IOException {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12762
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "{\n\n\tpublic CoordinatesGuiProvider(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Getter\n\t@Setter\n\tprivate int posX;\n\t@Getter\n\t@Setter\n\tprivate int posY;\n\t@Getter\n\t@Setter\n\tprivate int posZ;\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\n\t\toutput.writeInt(posX);\n\t\toutput.writeInt(posY);\n\t\toutput.writeInt(posZ);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\n\t\tposX = input.readInt();\n\t\tposY = input.readInt();\n\t\tposZ = input.readInt();\n\n\t}\n\n\tpublic CoordinatesGuiProvider setTilePos(TileEntity tile) {\n\t\tsetPosX(tile.xCoord);\n\t\tsetPosY(tile.yCoord);\n\t\tsetPosZ(tile.zCoord);\n\t\treturn this;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t/**\n\t * Retrieves tileEntity at packet coordinates if any.\n\t *\n\t * @param world\n\t * @param clazz\n\t * @return TileEntity\n\t */\n\tpublic <T> T getTile(World world, Class<T> clazz) {\n\t\tif (world == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (!world.blockExists(getPosX(), getPosY(), getPosZ())) {\n\t\t\tif (LPConstants.DEBUG) {\n\t\t\t\tLogisticsPipes.log.fatal(toString());\n\t\t\t\tnew RuntimeException(\"Couldn't find \" + clazz.getName()).printStackTrace();\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tfinal TileEntity tile = world.getTileEntity(getPosX(), getPosY(), getPosZ());\n\t\tif (tile != null) {\n\t\t\tif (!(clazz.isAssignableFrom(tile.getClass()))) {\n\t\t\t\tif (LPConstants.DEBUG) {\n\t\t\t\t\tLogisticsPipes.log.fatal(toString());\n\t\t\t\t\tnew RuntimeException(\"Couldn't find \" + clazz.getName() + \", found \" + tile.getClass()).printStackTrace();\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t} else {\n\t\t\tif (LPConstants.DEBUG) {\n\t\t\t\tLogisticsPipes.log.fatal(toString());\n\t\t\t\tnew RuntimeException(\"Couldn't find \" + clazz.getName()).printStackTrace();\n\t\t\t}\n\t\t}\n\t\treturn (T) tile;\n\t}\n\n\t/**\n\t * Retrieves pipe at packet coordinates if any.\n\t *\n\t * @param world\n\t * @return\n\t */\n\tpublic LogisticsTileGenericPipe getPipe(World world) {\n\t\treturn getTile(world, LogisticsTileGenericPipe.class);\n\t}\n}",
    "code_after_change": "@ToString\npublic abstract class CoordinatesGuiProvider extends GuiProvider {\n\n\t@Getter\n\t@Setter\n\tprivate int posX;\n\t@Getter\n\t@Setter\n\tprivate int posY;\n\t@Getter\n\t@Setter\n\tprivate int posZ;\n\n\tpublic CoordinatesGuiProvider(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\n\t\toutput.writeInt(posX);\n\t\toutput.writeInt(posY);\n\t\toutput.writeInt(posZ);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\n\t\tposX = input.readInt();\n\t\tposY = input.readInt();\n\t\tposZ = input.readInt();\n\n\t}\n\n\tpublic CoordinatesGuiProvider setTilePos(TileEntity tile) {\n\t\tsetPosX(tile.xCoord);\n\t\tsetPosY(tile.yCoord);\n\t\tsetPosZ(tile.zCoord);\n\t\treturn this;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t/**\n\t * Retrieves tileEntity at packet coordinates if any.\n\t *\n\t * @param world\n\t * @param clazz\n\t * @return TileEntity\n\t */\n\tpublic <T> T getTile(World world, Class<T> clazz) {\n\t\tif (world == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (!world.blockExists(getPosX(), getPosY(), getPosZ())) {\n\t\t\tif (LPConstants.DEBUG) {\n\t\t\t\tLogisticsPipes.log.fatal(toString());\n\t\t\t\tnew RuntimeException(\"Couldn't find \" + clazz.getName()).printStackTrace();\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tfinal TileEntity tile = world.getTileEntity(getPosX(), getPosY(), getPosZ());\n\t\tif (tile != null) {\n\t\t\tif (!(clazz.isAssignableFrom(tile.getClass()))) {\n\t\t\t\tif (LPConstants.DEBUG) {\n\t\t\t\t\tLogisticsPipes.log.fatal(toString());\n\t\t\t\t\tnew RuntimeException(\"Couldn't find \" + clazz.getName() + \", found \" + tile.getClass()).printStackTrace();\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t} else {\n\t\t\tif (LPConstants.DEBUG) {\n\t\t\t\tLogisticsPipes.log.fatal(toString());\n\t\t\t\tnew RuntimeException(\"Couldn't find \" + clazz.getName()).printStackTrace();\n\t\t\t}\n\t\t}\n\t\treturn (T) tile;\n\t}\n\n\t/**\n\t * Retrieves pipe at packet coordinates if any.\n\t *\n\t * @param world\n\t * @return\n\t */\n\tpublic LogisticsTileGenericPipe getPipe(World world) {\n\t\treturn getTile(world, LogisticsTileGenericPipe.class);\n\t}\n}",
    "patch": "@@ -1,7 +1,5 @@\n package logisticspipes.network.abstractguis;\n \n-import java.io.IOException;\n-\n import net.minecraft.tileentity.TileEntity;\n import net.minecraft.world.World;\n \n@@ -18,10 +16,6 @@\n @ToString\n public abstract class CoordinatesGuiProvider extends GuiProvider {\n \n-\tpublic CoordinatesGuiProvider(int id) {\n-\t\tsuper(id);\n-\t}\n-\n \t@Getter\n \t@Setter\n \tprivate int posX;\n@@ -32,16 +26,20 @@ public CoordinatesGuiProvider(int id) {\n \t@Setter\n \tprivate int posZ;\n \n+\tpublic CoordinatesGuiProvider(int id) {\n+\t\tsuper(id);\n+\t}\n+\n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \n \t\toutput.writeInt(posX);\n \t\toutput.writeInt(posY);\n \t\toutput.writeInt(posZ);\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \n \t\tposX = input.readInt();\n \t\tposY = input.readInt();",
    "function_modified_lines": {
      "added": [
        "\tpublic CoordinatesGuiProvider(int id) {\n",
        "\t\tsuper(id);\n",
        "\t}\n",
        "\n",
        "\tpublic void writeData(LPDataOutput output) {\n",
        "\tpublic void readData(LPDataInput input) {\n"
      ],
      "deleted": [
        "\tpublic CoordinatesGuiProvider(int id) {\n",
        "\t\tsuper(id);\n",
        "\t}\n",
        "\n",
        "\tpublic void writeData(LPDataOutput output) throws IOException {\n",
        "\tpublic void readData(LPDataInput input) throws IOException {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12763
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "{\n\n\tpublic CoordinatesPopupGuiProvider(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Getter\n\t@Setter\n\tprivate int posX;\n\t@Getter\n\t@Setter\n\tprivate int posY;\n\t@Getter\n\t@Setter\n\tprivate int posZ;\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\n\t\toutput.writeInt(posX);\n\t\toutput.writeInt(posY);\n\t\toutput.writeInt(posZ);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\n\t\tposX = input.readInt();\n\t\tposY = input.readInt();\n\t\tposZ = input.readInt();\n\n\t}\n\n\tpublic CoordinatesPopupGuiProvider setTilePos(TileEntity tile) {\n\t\tsetPosX(tile.xCoord);\n\t\tsetPosY(tile.yCoord);\n\t\tsetPosZ(tile.zCoord);\n\t\treturn this;\n\t}\n\n\tpublic CoordinatesPopupGuiProvider setLPPos(DoubleCoordinates pos) {\n\t\tsetPosX(pos.getXInt());\n\t\tsetPosY(pos.getYInt());\n\t\tsetPosZ(pos.getZInt());\n\t\treturn this;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t/**\n\t * Retrieves tileEntity at packet coordinates if any.\n\t *\n\t * @param world\n\t * @param clazz\n\t * @return TileEntity\n\t */\n\tpublic <T> T getTile(World world, Class<T> clazz) {\n\t\tif (world == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (!world.blockExists(getPosX(), getPosY(), getPosZ())) {\n\t\t\tif (LPConstants.DEBUG) {\n\t\t\t\tLogisticsPipes.log.fatal(toString());\n\t\t\t\tnew RuntimeException(\"Couldn't find \" + clazz.getName()).printStackTrace();\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tfinal TileEntity tile = world.getTileEntity(getPosX(), getPosY(), getPosZ());\n\t\tif (tile != null) {\n\t\t\tif (!(clazz.isAssignableFrom(tile.getClass()))) {\n\t\t\t\tif (LPConstants.DEBUG) {\n\t\t\t\t\tLogisticsPipes.log.fatal(toString());\n\t\t\t\t\tnew RuntimeException(\"Couldn't find \" + clazz.getName() + \", found \" + tile.getClass()).printStackTrace();\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t} else {\n\t\t\tif (LPConstants.DEBUG) {\n\t\t\t\tLogisticsPipes.log.fatal(toString());\n\t\t\t\tnew RuntimeException(\"Couldn't find \" + clazz.getName()).printStackTrace();\n\t\t\t}\n\t\t}\n\t\treturn (T) tile;\n\t}\n\n\t/**\n\t * Retrieves pipe at packet coordinates if any.\n\t *\n\t * @param world\n\t * @return\n\t */\n\tpublic LogisticsTileGenericPipe getPipe(World world) {\n\t\treturn getTile(world, LogisticsTileGenericPipe.class);\n\t}\n}",
    "code_after_change": "@ToString\npublic abstract class CoordinatesPopupGuiProvider extends PopupGuiProvider {\n\n\t@Getter\n\t@Setter\n\tprivate int posX;\n\t@Getter\n\t@Setter\n\tprivate int posY;\n\t@Getter\n\t@Setter\n\tprivate int posZ;\n\n\tpublic CoordinatesPopupGuiProvider(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\n\t\toutput.writeInt(posX);\n\t\toutput.writeInt(posY);\n\t\toutput.writeInt(posZ);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\n\t\tposX = input.readInt();\n\t\tposY = input.readInt();\n\t\tposZ = input.readInt();\n\n\t}\n\n\tpublic CoordinatesPopupGuiProvider setTilePos(TileEntity tile) {\n\t\tsetPosX(tile.xCoord);\n\t\tsetPosY(tile.yCoord);\n\t\tsetPosZ(tile.zCoord);\n\t\treturn this;\n\t}\n\n\tpublic CoordinatesPopupGuiProvider setLPPos(DoubleCoordinates pos) {\n\t\tsetPosX(pos.getXInt());\n\t\tsetPosY(pos.getYInt());\n\t\tsetPosZ(pos.getZInt());\n\t\treturn this;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t/**\n\t * Retrieves tileEntity at packet coordinates if any.\n\t *\n\t * @param world\n\t * @param clazz\n\t * @return TileEntity\n\t */\n\tpublic <T> T getTile(World world, Class<T> clazz) {\n\t\tif (world == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (!world.blockExists(getPosX(), getPosY(), getPosZ())) {\n\t\t\tif (LPConstants.DEBUG) {\n\t\t\t\tLogisticsPipes.log.fatal(toString());\n\t\t\t\tnew RuntimeException(\"Couldn't find \" + clazz.getName()).printStackTrace();\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tfinal TileEntity tile = world.getTileEntity(getPosX(), getPosY(), getPosZ());\n\t\tif (tile != null) {\n\t\t\tif (!(clazz.isAssignableFrom(tile.getClass()))) {\n\t\t\t\tif (LPConstants.DEBUG) {\n\t\t\t\t\tLogisticsPipes.log.fatal(toString());\n\t\t\t\t\tnew RuntimeException(\"Couldn't find \" + clazz.getName() + \", found \" + tile.getClass()).printStackTrace();\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t} else {\n\t\t\tif (LPConstants.DEBUG) {\n\t\t\t\tLogisticsPipes.log.fatal(toString());\n\t\t\t\tnew RuntimeException(\"Couldn't find \" + clazz.getName()).printStackTrace();\n\t\t\t}\n\t\t}\n\t\treturn (T) tile;\n\t}\n\n\t/**\n\t * Retrieves pipe at packet coordinates if any.\n\t *\n\t * @param world\n\t * @return\n\t */\n\tpublic LogisticsTileGenericPipe getPipe(World world) {\n\t\treturn getTile(world, LogisticsTileGenericPipe.class);\n\t}\n}",
    "patch": "@@ -1,7 +1,5 @@\n package logisticspipes.network.abstractguis;\n \n-import java.io.IOException;\n-\n import net.minecraft.tileentity.TileEntity;\n import net.minecraft.world.World;\n \n@@ -19,10 +17,6 @@\n @ToString\n public abstract class CoordinatesPopupGuiProvider extends PopupGuiProvider {\n \n-\tpublic CoordinatesPopupGuiProvider(int id) {\n-\t\tsuper(id);\n-\t}\n-\n \t@Getter\n \t@Setter\n \tprivate int posX;\n@@ -33,16 +27,20 @@ public CoordinatesPopupGuiProvider(int id) {\n \t@Setter\n \tprivate int posZ;\n \n+\tpublic CoordinatesPopupGuiProvider(int id) {\n+\t\tsuper(id);\n+\t}\n+\n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \n \t\toutput.writeInt(posX);\n \t\toutput.writeInt(posY);\n \t\toutput.writeInt(posZ);\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \n \t\tposX = input.readInt();\n \t\tposY = input.readInt();",
    "function_modified_lines": {
      "added": [
        "\tpublic CoordinatesPopupGuiProvider(int id) {\n",
        "\t\tsuper(id);\n",
        "\t}\n",
        "\n",
        "\tpublic void writeData(LPDataOutput output) {\n",
        "\tpublic void readData(LPDataInput input) {\n"
      ],
      "deleted": [
        "\tpublic CoordinatesPopupGuiProvider(int id) {\n",
        "\t\tsuper(id);\n",
        "\t}\n",
        "\n",
        "\tpublic void writeData(LPDataOutput output) throws IOException {\n",
        "\tpublic void readData(LPDataInput input) throws IOException {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12764
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "{\n\n\t@Getter\n\tprivate final int id;\n\n\tpublic GuiProvider(int id) {\n\t\tthis.id = id;\n\t}\n\n\tpublic void writeData(LPDataOutput output) throws IOException {}\n\n\tpublic void readData(LPDataInput input) throws IOException {}\n\n\t/**\n\t * @return LogisticsBaseGuiScreen\n\t */\n\tpublic abstract Object getClientGui(EntityPlayer player);\n\n\tpublic abstract Container getContainer(EntityPlayer player);\n\n\tpublic abstract GuiProvider template();\n\n\tpublic final void open(EntityPlayer player) {\n\t\tif (player instanceof FakePlayer) return;\n\t\tNewGuiHandler.openGui(this, player);\n\t}\n}",
    "code_after_change": "{\n\n\t@Getter\n\tprivate final int id;\n\n\tpublic GuiProvider(int id) {\n\t\tthis.id = id;\n\t}\n\n\tpublic void writeData(LPDataOutput output) {}\n\n\tpublic void readData(LPDataInput input) {}\n\n\t/**\n\t * @return LogisticsBaseGuiScreen\n\t */\n\tpublic abstract Object getClientGui(EntityPlayer player);\n\n\tpublic abstract Container getContainer(EntityPlayer player);\n\n\tpublic abstract GuiProvider template();\n\n\tpublic final void open(EntityPlayer player) {\n\t\tif (player instanceof FakePlayer) return;\n\t\tNewGuiHandler.openGui(this, player);\n\t}\n}",
    "patch": "@@ -1,7 +1,5 @@\n package logisticspipes.network.abstractguis;\n \n-import java.io.IOException;\n-\n import net.minecraft.entity.player.EntityPlayer;\n import net.minecraft.inventory.Container;\n import net.minecraftforge.common.util.FakePlayer;\n@@ -21,9 +19,9 @@ public GuiProvider(int id) {\n \t\tthis.id = id;\n \t}\n \n-\tpublic void writeData(LPDataOutput output) throws IOException {}\n+\tpublic void writeData(LPDataOutput output) {}\n \n-\tpublic void readData(LPDataInput input) throws IOException {}\n+\tpublic void readData(LPDataInput input) {}\n \n \t/**\n \t * @return LogisticsBaseGuiScreen",
    "function_modified_lines": {
      "added": [
        "\tpublic void writeData(LPDataOutput output) {}\n",
        "\tpublic void readData(LPDataInput input) {}\n"
      ],
      "deleted": [
        "\tpublic void writeData(LPDataOutput output) throws IOException {}\n",
        "\tpublic void readData(LPDataInput input) throws IOException {}\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12765
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "{\n\n\tpublic ModuleCoordinatesGuiProvider(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Getter\n\t@Setter\n\tprivate ModulePositionType slot;\n\n\t@Getter\n\t@Setter\n\tprivate int positionInt;\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\tsuper.writeData(output);\n\t\toutput.writeEnum(slot);\n\t\toutput.writeInt(positionInt);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tsuper.readData(input);\n\t\tslot = input.readEnum(ModulePositionType.class);\n\t\tpositionInt = input.readInt();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T> T getLogisticsModule(World world, Class<T> clazz) {\n\t\tLogisticsTileGenericPipe pipe = getPipe(world);\n\t\tif (pipe == null || !(pipe.pipe instanceof CoreRoutedPipe)) {\n\t\t\tif (LPConstants.DEBUG && (pipe == null || pipe.isInitialized())) {\n\t\t\t\tLogisticsPipes.log.fatal(toString());\n\t\t\t\tnew RuntimeException(\"Couldn't find \" + clazz.getName() + \", pipe didn't exsist\").printStackTrace();\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\tLogisticsModule module = null;\n\t\tif (slot == ModulePositionType.IN_PIPE) {\n\t\t\tmodule = ((CoreRoutedPipe) pipe.pipe).getLogisticsModule();\n\t\t} else if (slot == ModulePositionType.IN_HAND) {\n\t\t\tthrow new UnsupportedOperationException(\"NO IN_HAND FOR THIS PACKET TYPE\");\n\t\t} else {\n\t\t\tif (!(pipe.pipe instanceof PipeLogisticsChassi)) {\n\t\t\t\tif (LPConstants.DEBUG) {\n\t\t\t\t\tLogisticsPipes.log.fatal(toString());\n\t\t\t\t\tnew RuntimeException(\"Couldn't find \" + clazz.getName() + \", pipe wasn't a chassi pipe\").printStackTrace();\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tmodule = ((PipeLogisticsChassi) pipe.pipe).getLogisticsModule().getSubModule(positionInt);\n\t\t}\n\t\tif (module != null) {\n\t\t\tif (!(clazz.isAssignableFrom(module.getClass()))) {\n\t\t\t\tif (LPConstants.DEBUG) {\n\t\t\t\t\tLogisticsPipes.log.fatal(toString());\n\t\t\t\t\tnew RuntimeException(\"Couldn't find \" + clazz.getName() + \", found \" + module.getClass()).printStackTrace();\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t} else {\n\t\t\tif (LPConstants.DEBUG) {\n\t\t\t\tLogisticsPipes.log.fatal(toString());\n\t\t\t\tnew RuntimeException(\"Couldn't find \" + clazz.getName()).printStackTrace();\n\t\t\t}\n\t\t}\n\t\treturn (T) module;\n\t}\n}",
    "code_after_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate ModulePositionType slot;\n\t@Getter\n\t@Setter\n\tprivate int positionInt;\n\n\tpublic ModuleCoordinatesGuiProvider(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\tsuper.writeData(output);\n\t\toutput.writeEnum(slot);\n\t\toutput.writeInt(positionInt);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tsuper.readData(input);\n\t\tslot = input.readEnum(ModulePositionType.class);\n\t\tpositionInt = input.readInt();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T> T getLogisticsModule(World world, Class<T> clazz) {\n\t\tLogisticsTileGenericPipe pipe = getPipe(world);\n\t\tif (pipe == null || !(pipe.pipe instanceof CoreRoutedPipe)) {\n\t\t\tif (LPConstants.DEBUG && (pipe == null || pipe.isInitialized())) {\n\t\t\t\tLogisticsPipes.log.fatal(toString());\n\t\t\t\tnew RuntimeException(\"Couldn't find \" + clazz.getName() + \", pipe didn't exsist\").printStackTrace();\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\tLogisticsModule module = null;\n\t\tif (slot == ModulePositionType.IN_PIPE) {\n\t\t\tmodule = ((CoreRoutedPipe) pipe.pipe).getLogisticsModule();\n\t\t} else if (slot == ModulePositionType.IN_HAND) {\n\t\t\tthrow new UnsupportedOperationException(\"NO IN_HAND FOR THIS PACKET TYPE\");\n\t\t} else {\n\t\t\tif (!(pipe.pipe instanceof PipeLogisticsChassi)) {\n\t\t\t\tif (LPConstants.DEBUG) {\n\t\t\t\t\tLogisticsPipes.log.fatal(toString());\n\t\t\t\t\tnew RuntimeException(\"Couldn't find \" + clazz.getName() + \", pipe wasn't a chassi pipe\").printStackTrace();\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tmodule = ((PipeLogisticsChassi) pipe.pipe).getLogisticsModule().getSubModule(positionInt);\n\t\t}\n\t\tif (module != null) {\n\t\t\tif (!(clazz.isAssignableFrom(module.getClass()))) {\n\t\t\t\tif (LPConstants.DEBUG) {\n\t\t\t\t\tLogisticsPipes.log.fatal(toString());\n\t\t\t\t\tnew RuntimeException(\"Couldn't find \" + clazz.getName() + \", found \" + module.getClass()).printStackTrace();\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t} else {\n\t\t\tif (LPConstants.DEBUG) {\n\t\t\t\tLogisticsPipes.log.fatal(toString());\n\t\t\t\tnew RuntimeException(\"Couldn't find \" + clazz.getName()).printStackTrace();\n\t\t\t}\n\t\t}\n\t\treturn (T) module;\n\t}\n}",
    "patch": "@@ -1,7 +1,5 @@\n package logisticspipes.network.abstractguis;\n \n-import java.io.IOException;\n-\n import net.minecraft.world.World;\n \n import lombok.Getter;\n@@ -19,27 +17,26 @@\n \n public abstract class ModuleCoordinatesGuiProvider extends CoordinatesGuiProvider {\n \n-\tpublic ModuleCoordinatesGuiProvider(int id) {\n-\t\tsuper(id);\n-\t}\n-\n \t@Getter\n \t@Setter\n \tprivate ModulePositionType slot;\n-\n \t@Getter\n \t@Setter\n \tprivate int positionInt;\n \n+\tpublic ModuleCoordinatesGuiProvider(int id) {\n+\t\tsuper(id);\n+\t}\n+\n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\tsuper.writeData(output);\n \t\toutput.writeEnum(slot);\n \t\toutput.writeInt(positionInt);\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tsuper.readData(input);\n \t\tslot = input.readEnum(ModulePositionType.class);\n \t\tpositionInt = input.readInt();",
    "function_modified_lines": {
      "added": [
        "\tpublic ModuleCoordinatesGuiProvider(int id) {\n",
        "\t\tsuper(id);\n",
        "\t}\n",
        "\n",
        "\tpublic void writeData(LPDataOutput output) {\n",
        "\tpublic void readData(LPDataInput input) {\n"
      ],
      "deleted": [
        "\tpublic ModuleCoordinatesGuiProvider(int id) {\n",
        "\t\tsuper(id);\n",
        "\t}\n",
        "\n",
        "\n",
        "\tpublic void writeData(LPDataOutput output) throws IOException {\n",
        "\tpublic void readData(LPDataInput input) throws IOException {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12766
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "{\n\n\tpublic ModuleInHandGuiProvider(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Getter\n\t@Setter\n\tprivate int invSlot;\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\tsuper.writeData(output);\n\t\toutput.writeInt(invSlot);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tsuper.readData(input);\n\t\tinvSlot = input.readInt();\n\t}\n\n\tpublic final LogisticsModule getLogisticsModule(EntityPlayer player) {\n\t\tItemStack item = player.inventory.mainInventory[invSlot];\n\t\tif (item == null) {\n\t\t\treturn null;\n\t\t}\n\t\tLogisticsModule module = LogisticsPipes.ModuleItem.getModuleForItem(item, null, new DummyWorldProvider(player.getEntityWorld()), null);\n\t\tmodule.registerPosition(ModulePositionType.IN_HAND, invSlot);\n\t\tItemModuleInformationManager.readInformation(item, module);\n\t\treturn module;\n\t}\n}",
    "code_after_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate int invSlot;\n\n\tpublic ModuleInHandGuiProvider(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\tsuper.writeData(output);\n\t\toutput.writeInt(invSlot);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tsuper.readData(input);\n\t\tinvSlot = input.readInt();\n\t}\n\n\tpublic final LogisticsModule getLogisticsModule(EntityPlayer player) {\n\t\tItemStack item = player.inventory.mainInventory[invSlot];\n\t\tif (item == null) {\n\t\t\treturn null;\n\t\t}\n\t\tLogisticsModule module = LogisticsPipes.ModuleItem.getModuleForItem(item, null, new DummyWorldProvider(player.getEntityWorld()), null);\n\t\tmodule.registerPosition(ModulePositionType.IN_HAND, invSlot);\n\t\tItemModuleInformationManager.readInformation(item, module);\n\t\treturn module;\n\t}\n}",
    "patch": "@@ -1,7 +1,5 @@\n package logisticspipes.network.abstractguis;\n \n-import java.io.IOException;\n-\n import net.minecraft.entity.player.EntityPlayer;\n import net.minecraft.item.ItemStack;\n \n@@ -18,22 +16,22 @@\n \n public abstract class ModuleInHandGuiProvider extends GuiProvider {\n \n-\tpublic ModuleInHandGuiProvider(int id) {\n-\t\tsuper(id);\n-\t}\n-\n \t@Getter\n \t@Setter\n \tprivate int invSlot;\n \n+\tpublic ModuleInHandGuiProvider(int id) {\n+\t\tsuper(id);\n+\t}\n+\n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\tsuper.writeData(output);\n \t\toutput.writeInt(invSlot);\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tsuper.readData(input);\n \t\tinvSlot = input.readInt();\n \t}",
    "function_modified_lines": {
      "added": [
        "\tpublic ModuleInHandGuiProvider(int id) {\n",
        "\t\tsuper(id);\n",
        "\t}\n",
        "\n",
        "\tpublic void writeData(LPDataOutput output) {\n",
        "\tpublic void readData(LPDataInput input) {\n"
      ],
      "deleted": [
        "\tpublic ModuleInHandGuiProvider(int id) {\n",
        "\t\tsuper(id);\n",
        "\t}\n",
        "\n",
        "\tpublic void writeData(LPDataOutput output) throws IOException {\n",
        "\tpublic void readData(LPDataInput input) throws IOException {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12767
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate NBTTagCompound nbt;\n\n\tpublic NBTModuleCoordinatesGuiProvider(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\tsuper.writeData(output);\n\t\toutput.writeNBTTagCompound(nbt);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tsuper.readData(input);\n\t\tnbt = input.readNBTTagCompound();\n\t}\n}",
    "code_after_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate NBTTagCompound nbt;\n\n\tpublic NBTModuleCoordinatesGuiProvider(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\tsuper.writeData(output);\n\t\toutput.writeNBTTagCompound(nbt);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tsuper.readData(input);\n\t\tnbt = input.readNBTTagCompound();\n\t}\n}",
    "patch": "@@ -1,7 +1,5 @@\n package logisticspipes.network.abstractguis;\n \n-import java.io.IOException;\n-\n import net.minecraft.nbt.NBTTagCompound;\n \n import lombok.Getter;\n@@ -21,13 +19,13 @@ public NBTModuleCoordinatesGuiProvider(int id) {\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\tsuper.writeData(output);\n \t\toutput.writeNBTTagCompound(nbt);\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tsuper.readData(input);\n \t\tnbt = input.readNBTTagCompound();\n \t}",
    "function_modified_lines": {
      "added": [
        "\tpublic void writeData(LPDataOutput output) {\n",
        "\tpublic void readData(LPDataInput input) {\n"
      ],
      "deleted": [
        "\tpublic void writeData(LPDataOutput output) throws IOException {\n",
        "\tpublic void readData(LPDataInput input) throws IOException {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12768
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "package logisticspipes.network.abstractguis;\n\nimport java.io.IOException;\n\nimport net.minecraft.entity.player.EntityPlayer;\nimport net.minecraft.inventory.Slot;\n\nimport lombok.AccessLevel;\nimport lombok.Getter;\nimport lombok.Setter;\n\nimport logisticspipes.network.exception.TargetNotFoundException;\nimport logisticspipes.utils.gui.DummyContainer;\nimport network.rs485.logisticspipes.util.LPDataInput;\nimport network.rs485.logisticspipes.util.LPDataOutput;\n\npublic abstract class UpgradeCoordinatesGuiProvider extends CoordinatesPopupGuiProvider {\n\n\tpublic UpgradeCoordinatesGuiProvider(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Getter(AccessLevel.PROTECTED)\n\t@Setter(AccessLevel.PRIVATE)\n\tprivate int positionInt;\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\tsuper.writeData(output);\n\t\toutput.writeInt(positionInt);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tsuper.readData(input);\n\t\tpositionInt = input.readInt();\n\t}\n\n\tpublic UpgradeCoordinatesGuiProvider setSlot(Slot slot) {\n\t\tthis.setPositionInt(slot.slotNumber);\n\t\treturn this;\n\t}\n\n\tpublic <T extends Slot> T getSlot(EntityPlayer player, Class<T> clazz) {\n\t\tif (player.openContainer instanceof DummyContainer) {\n\t\t\tif (positionInt >= player.openContainer.inventorySlots.size()) {\n\t\t\t\ttargetNotFound(\"The requested Slot was out of range\");\n\t\t\t} else {\n\t\t\t\tSlot slot = player.openContainer.getSlot(positionInt);\n\t\t\t\tif (slot == null) {\n\t\t\t\t\ttargetNotFound(\"The requested Slot was null\");\n\t\t\t\t} else if (!clazz.isAssignableFrom(slot.getClass())) {\n\t\t\t\t\ttargetNotFound(\"Couldn't find \" + clazz.getName() + \", found slot with \" + slot.getClass());\n\t\t\t\t} else {\n\t\t\t\t\treturn (T) slot;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprotected void targetNotFound(String message) {\n\t\tthrow new TargetNotFoundException(message, this);\n\t}\n}\n",
    "code_after_change": "package logisticspipes.network.abstractguis;\n\nimport net.minecraft.entity.player.EntityPlayer;\nimport net.minecraft.inventory.Slot;\n\nimport lombok.AccessLevel;\nimport lombok.Getter;\nimport lombok.Setter;\n\nimport logisticspipes.network.exception.TargetNotFoundException;\nimport logisticspipes.utils.gui.DummyContainer;\nimport network.rs485.logisticspipes.util.LPDataInput;\nimport network.rs485.logisticspipes.util.LPDataOutput;\n\npublic abstract class UpgradeCoordinatesGuiProvider extends CoordinatesPopupGuiProvider {\n\n\t@Getter(AccessLevel.PROTECTED)\n\t@Setter(AccessLevel.PRIVATE)\n\tprivate int positionInt;\n\n\tpublic UpgradeCoordinatesGuiProvider(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\tsuper.writeData(output);\n\t\toutput.writeInt(positionInt);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tsuper.readData(input);\n\t\tpositionInt = input.readInt();\n\t}\n\n\tpublic UpgradeCoordinatesGuiProvider setSlot(Slot slot) {\n\t\tthis.setPositionInt(slot.slotNumber);\n\t\treturn this;\n\t}\n\n\tpublic <T extends Slot> T getSlot(EntityPlayer player, Class<T> clazz) {\n\t\tif (player.openContainer instanceof DummyContainer) {\n\t\t\tif (positionInt >= player.openContainer.inventorySlots.size()) {\n\t\t\t\ttargetNotFound(\"The requested Slot was out of range\");\n\t\t\t} else {\n\t\t\t\tSlot slot = player.openContainer.getSlot(positionInt);\n\t\t\t\tif (slot == null) {\n\t\t\t\t\ttargetNotFound(\"The requested Slot was null\");\n\t\t\t\t} else if (!clazz.isAssignableFrom(slot.getClass())) {\n\t\t\t\t\ttargetNotFound(\"Couldn't find \" + clazz.getName() + \", found slot with \" + slot.getClass());\n\t\t\t\t} else {\n\t\t\t\t\treturn (T) slot;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprotected void targetNotFound(String message) {\n\t\tthrow new TargetNotFoundException(message, this);\n\t}\n}\n",
    "patch": "@@ -1,7 +1,5 @@\n package logisticspipes.network.abstractguis;\n \n-import java.io.IOException;\n-\n import net.minecraft.entity.player.EntityPlayer;\n import net.minecraft.inventory.Slot;\n \n@@ -16,22 +14,22 @@\n \n public abstract class UpgradeCoordinatesGuiProvider extends CoordinatesPopupGuiProvider {\n \n-\tpublic UpgradeCoordinatesGuiProvider(int id) {\n-\t\tsuper(id);\n-\t}\n-\n \t@Getter(AccessLevel.PROTECTED)\n \t@Setter(AccessLevel.PRIVATE)\n \tprivate int positionInt;\n \n+\tpublic UpgradeCoordinatesGuiProvider(int id) {\n+\t\tsuper(id);\n+\t}\n+\n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\tsuper.writeData(output);\n \t\toutput.writeInt(positionInt);\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tsuper.readData(input);\n \t\tpositionInt = input.readInt();\n \t}",
    "function_modified_lines": {
      "added": [
        "\tpublic UpgradeCoordinatesGuiProvider(int id) {\n",
        "\t\tsuper(id);\n",
        "\t}\n",
        "\n",
        "\tpublic void writeData(LPDataOutput output) {\n",
        "\tpublic void readData(LPDataInput input) {\n"
      ],
      "deleted": [
        "import java.io.IOException;\n",
        "\n",
        "\tpublic UpgradeCoordinatesGuiProvider(int id) {\n",
        "\t\tsuper(id);\n",
        "\t}\n",
        "\n",
        "\tpublic void writeData(LPDataOutput output) throws IOException {\n",
        "\tpublic void readData(LPDataInput input) throws IOException {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12769
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate BitSet flags;\n\n\tpublic BitSetCoordinatesPacket(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\tsuper.writeData(output);\n\t\toutput.writeBitSet(getFlags());\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tsuper.readData(input);\n\t\tsetFlags(input.readBitSet());\n\t}\n}",
    "code_after_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate BitSet flags;\n\n\tpublic BitSetCoordinatesPacket(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\tsuper.writeData(output);\n\t\toutput.writeBitSet(getFlags());\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tsuper.readData(input);\n\t\tsetFlags(input.readBitSet());\n\t}\n}",
    "patch": "@@ -1,6 +1,5 @@\n package logisticspipes.network.abstractpackets;\n \n-import java.io.IOException;\n import java.util.BitSet;\n \n import lombok.Getter;\n@@ -20,13 +19,13 @@ public BitSetCoordinatesPacket(int id) {\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\tsuper.writeData(output);\n \t\toutput.writeBitSet(getFlags());\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tsuper.readData(input);\n \t\tsetFlags(input.readBitSet());\n \t}",
    "function_modified_lines": {
      "added": [
        "\tpublic void writeData(LPDataOutput output) {\n",
        "\tpublic void readData(LPDataInput input) {\n"
      ],
      "deleted": [
        "\tpublic void writeData(LPDataOutput output) throws IOException {\n",
        "\tpublic void readData(LPDataInput input) throws IOException {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12770
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "{\n\n\t@Getter\n\t@Setter\n\tboolean flag;\n\n\tpublic BooleanModuleCoordinatesPacket(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\tsuper.writeData(output);\n\t\toutput.writeBoolean(flag);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tsuper.readData(input);\n\t\tflag = input.readBoolean();\n\t}\n}",
    "code_after_change": "{\n\n\t@Getter\n\t@Setter\n\tboolean flag;\n\n\tpublic BooleanModuleCoordinatesPacket(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\tsuper.writeData(output);\n\t\toutput.writeBoolean(flag);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tsuper.readData(input);\n\t\tflag = input.readBoolean();\n\t}\n}",
    "patch": "@@ -1,7 +1,5 @@\n package logisticspipes.network.abstractpackets;\n \n-import java.io.IOException;\n-\n import lombok.Getter;\n import lombok.Setter;\n \n@@ -19,13 +17,13 @@ public BooleanModuleCoordinatesPacket(int id) {\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\tsuper.writeData(output);\n \t\toutput.writeBoolean(flag);\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tsuper.readData(input);\n \t\tflag = input.readBoolean();\n \t}",
    "function_modified_lines": {
      "added": [
        "\tpublic void writeData(LPDataOutput output) {\n",
        "\tpublic void readData(LPDataInput input) {\n"
      ],
      "deleted": [
        "\tpublic void writeData(LPDataOutput output) throws IOException {\n",
        "\tpublic void readData(LPDataInput input) throws IOException {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12771
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "package logisticspipes.network.abstractpackets;\n\nimport java.io.IOException;\n\nimport net.minecraft.tileentity.TileEntity;\nimport net.minecraft.world.World;\n\nimport lombok.Getter;\nimport lombok.Setter;\nimport lombok.ToString;\n\nimport logisticspipes.network.exception.TargetNotFoundException;\nimport logisticspipes.pipes.basic.LogisticsTileGenericPipe;\nimport network.rs485.logisticspipes.util.LPDataInput;\nimport network.rs485.logisticspipes.util.LPDataOutput;\nimport network.rs485.logisticspipes.world.DoubleCoordinates;\n\n@ToString\npublic abstract class CoordinatesPacket extends ModernPacket {\n\n\tpublic enum LTGPCompletionCheck {\n\t\tNONE,\n\t\tPIPE,\n\t\tTRANSPORT\n\t}\n\n\tpublic CoordinatesPacket(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Getter\n\t@Setter\n\tprivate int posX;\n\t@Getter\n\t@Setter\n\tprivate int posY;\n\t@Getter\n\t@Setter\n\tprivate int posZ;\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\n\t\toutput.writeInt(posX);\n\t\toutput.writeInt(posY);\n\t\toutput.writeInt(posZ);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\n\t\tposX = input.readInt();\n\t\tposY = input.readInt();\n\t\tposZ = input.readInt();\n\n\t}\n\n\tpublic CoordinatesPacket setTilePos(TileEntity tile) {\n\t\tsetPosX(tile.xCoord);\n\t\tsetPosY(tile.yCoord);\n\t\tsetPosZ(tile.zCoord);\n\t\treturn this;\n\t}\n\n\tpublic CoordinatesPacket setLPPos(DoubleCoordinates pos) {\n\t\tsetPosX(pos.getXInt());\n\t\tsetPosY(pos.getYInt());\n\t\tsetPosZ(pos.getZInt());\n\t\treturn this;\n\t}\n\n\tpublic CoordinatesPacket setPacketPos(CoordinatesPacket packet) {\n\t\tposX = packet.posX;\n\t\tposY = packet.posY;\n\t\tposZ = packet.posZ;\n\t\treturn this;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t/**\n\t * Retrieves tileEntity at packet coordinates if any.\n\t *\n\t * @param world\n\t * @param clazz\n\t * @return TileEntity\n\t */\n\tpublic <T> T getTile(World world, Class<T> clazz) {\n\t\tif (world == null) {\n\t\t\ttargetNotFound(\"World was null\");\n\t\t\treturn null;\n\t\t}\n\t\tif (!world.blockExists(getPosX(), getPosY(), getPosZ())) {\n\t\t\ttargetNotFound(\"Couldn't find \" + clazz.getName());\n\t\t\treturn null;\n\t\t}\n\n\t\tfinal TileEntity tile = world.getTileEntity(getPosX(), getPosY(), getPosZ());\n\t\tif (tile != null) {\n\t\t\tif (!(clazz.isAssignableFrom(tile.getClass()))) {\n\t\t\t\ttargetNotFound(\"Couldn't find \" + clazz.getName() + \", found \" + tile.getClass());\n\t\t\t\treturn null;\n\t\t\t}\n\t\t} else {\n\t\t\ttargetNotFound(\"Couldn't find \" + clazz.getName());\n\t\t}\n\t\treturn (T) tile;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t/**\n\t * Retrieves tileEntity or CoreUnroutedPipe at packet coordinates if any.\n\t *\n\t * @param world\n\t * @param clazz\n\t * @return TileEntity\n\t */\n\tpublic <T> T getTileOrPipe(World world, Class<T> clazz) {\n\t\tif (world == null) {\n\t\t\ttargetNotFound(\"World was null\");\n\t\t\treturn null;\n\t\t}\n\t\tif (!world.blockExists(getPosX(), getPosY(), getPosZ())) {\n\t\t\ttargetNotFound(\"Couldn't find \" + clazz.getName());\n\t\t\treturn null;\n\t\t}\n\n\t\tfinal TileEntity tile = world.getTileEntity(getPosX(), getPosY(), getPosZ());\n\t\tif (tile != null) {\n\t\t\tif (clazz.isAssignableFrom(tile.getClass())) {\n\t\t\t\treturn (T) tile;\n\t\t\t}\n\t\t\tif (tile instanceof LogisticsTileGenericPipe) {\n\t\t\t\tif (((LogisticsTileGenericPipe) tile).pipe != null && clazz.isAssignableFrom(((LogisticsTileGenericPipe) tile).pipe.getClass())) {\n\t\t\t\t\treturn (T) ((LogisticsTileGenericPipe) tile).pipe;\n\t\t\t\t}\n\t\t\t\ttargetNotFound(\"Couldn't find \" + clazz.getName() + \", found pipe with \" + tile.getClass());\n\t\t\t\treturn null;\n\t\t\t}\n\t\t} else {\n\t\t\ttargetNotFound(\"Couldn't find \" + clazz.getName());\n\t\t\treturn null;\n\t\t}\n\t\ttargetNotFound(\"Couldn't find \" + clazz.getName() + \", found \" + tile.getClass());\n\t\treturn null;\n\t}\n\n\t/**\n\t * Retrieves pipe at packet coordinates if any.\n\t *\n\t * @param world\n\t * @return\n\t */\n\t@Deprecated\n\tpublic LogisticsTileGenericPipe getPipe(World world) {\n\t\treturn getPipe(world, LTGPCompletionCheck.NONE);\n\t}\n\n\tpublic LogisticsTileGenericPipe getPipe(World world, LTGPCompletionCheck check) {\n\t\tLogisticsTileGenericPipe pipe = getTile(world, LogisticsTileGenericPipe.class);\n\t\tif (check == LTGPCompletionCheck.PIPE || check == LTGPCompletionCheck.TRANSPORT) {\n\t\t\tif (pipe.pipe == null) {\n\t\t\t\ttargetNotFound(\"The found pipe didn't have a loaded pipe field\");\n\t\t\t}\n\t\t}\n\t\tif (check == LTGPCompletionCheck.TRANSPORT) {\n\t\t\tif (pipe.pipe.transport == null) {\n\t\t\t\ttargetNotFound(\"The found pipe didn't have a loaded transport field\");\n\t\t\t}\n\t\t}\n\t\treturn pipe;\n\t}\n\n\tprotected void targetNotFound(String message) {\n\t\tthrow new TargetNotFoundException(message, this);\n\t}\n}\n",
    "code_after_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate int posX;\n\t@Getter\n\t@Setter\n\tprivate int posY;\n\t@Getter\n\t@Setter\n\tprivate int posZ;\n\n\tpublic CoordinatesPacket(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\n\t\toutput.writeInt(posX);\n\t\toutput.writeInt(posY);\n\t\toutput.writeInt(posZ);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\n\t\tposX = input.readInt();\n\t\tposY = input.readInt();\n\t\tposZ = input.readInt();\n\n\t}\n\n\tpublic CoordinatesPacket setTilePos(TileEntity tile) {\n\t\tsetPosX(tile.xCoord);\n\t\tsetPosY(tile.yCoord);\n\t\tsetPosZ(tile.zCoord);\n\t\treturn this;\n\t}\n\n\tpublic CoordinatesPacket setLPPos(DoubleCoordinates pos) {\n\t\tsetPosX(pos.getXInt());\n\t\tsetPosY(pos.getYInt());\n\t\tsetPosZ(pos.getZInt());\n\t\treturn this;\n\t}\n\n\tpublic CoordinatesPacket setPacketPos(CoordinatesPacket packet) {\n\t\tposX = packet.posX;\n\t\tposY = packet.posY;\n\t\tposZ = packet.posZ;\n\t\treturn this;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t/**\n\t * Retrieves tileEntity at packet coordinates if any.\n\t *\n\t * @param world\n\t * @param clazz\n\t * @return TileEntity\n\t */\n\tpublic <T> T getTile(World world, Class<T> clazz) {\n\t\tif (world == null) {\n\t\t\ttargetNotFound(\"World was null\");\n\t\t\treturn null;\n\t\t}\n\t\tif (!world.blockExists(getPosX(), getPosY(), getPosZ())) {\n\t\t\ttargetNotFound(\"Couldn't find \" + clazz.getName());\n\t\t\treturn null;\n\t\t}\n\n\t\tfinal TileEntity tile = world.getTileEntity(getPosX(), getPosY(), getPosZ());\n\t\tif (tile != null) {\n\t\t\tif (!(clazz.isAssignableFrom(tile.getClass()))) {\n\t\t\t\ttargetNotFound(\"Couldn't find \" + clazz.getName() + \", found \" + tile.getClass());\n\t\t\t\treturn null;\n\t\t\t}\n\t\t} else {\n\t\t\ttargetNotFound(\"Couldn't find \" + clazz.getName());\n\t\t}\n\t\treturn (T) tile;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t/**\n\t * Retrieves tileEntity or CoreUnroutedPipe at packet coordinates if any.\n\t *\n\t * @param world\n\t * @param clazz\n\t * @return TileEntity\n\t */\n\tpublic <T> T getTileOrPipe(World world, Class<T> clazz) {\n\t\tif (world == null) {\n\t\t\ttargetNotFound(\"World was null\");\n\t\t\treturn null;\n\t\t}\n\t\tif (!world.blockExists(getPosX(), getPosY(), getPosZ())) {\n\t\t\ttargetNotFound(\"Couldn't find \" + clazz.getName());\n\t\t\treturn null;\n\t\t}\n\n\t\tfinal TileEntity tile = world.getTileEntity(getPosX(), getPosY(), getPosZ());\n\t\tif (tile != null) {\n\t\t\tif (clazz.isAssignableFrom(tile.getClass())) {\n\t\t\t\treturn (T) tile;\n\t\t\t}\n\t\t\tif (tile instanceof LogisticsTileGenericPipe) {\n\t\t\t\tif (((LogisticsTileGenericPipe) tile).pipe != null && clazz.isAssignableFrom(((LogisticsTileGenericPipe) tile).pipe.getClass())) {\n\t\t\t\t\treturn (T) ((LogisticsTileGenericPipe) tile).pipe;\n\t\t\t\t}\n\t\t\t\ttargetNotFound(\"Couldn't find \" + clazz.getName() + \", found pipe with \" + tile.getClass());\n\t\t\t\treturn null;\n\t\t\t}\n\t\t} else {\n\t\t\ttargetNotFound(\"Couldn't find \" + clazz.getName());\n\t\t\treturn null;\n\t\t}\n\t\ttargetNotFound(\"Couldn't find \" + clazz.getName() + \", found \" + tile.getClass());\n\t\treturn null;\n\t}\n\n\t/**\n\t * Retrieves pipe at packet coordinates if any.\n\t *\n\t * @param world\n\t * @return\n\t */\n\t@Deprecated\n\tpublic LogisticsTileGenericPipe getPipe(World world) {\n\t\treturn getPipe(world, LTGPCompletionCheck.NONE);\n\t}\n\n\tpublic LogisticsTileGenericPipe getPipe(World world, LTGPCompletionCheck check) {\n\t\tLogisticsTileGenericPipe pipe = getTile(world, LogisticsTileGenericPipe.class);\n\t\tif (check == LTGPCompletionCheck.PIPE || check == LTGPCompletionCheck.TRANSPORT) {\n\t\t\tif (pipe.pipe == null) {\n\t\t\t\ttargetNotFound(\"The found pipe didn't have a loaded pipe field\");\n\t\t\t}\n\t\t}\n\t\tif (check == LTGPCompletionCheck.TRANSPORT) {\n\t\t\tif (pipe.pipe.transport == null) {\n\t\t\t\ttargetNotFound(\"The found pipe didn't have a loaded transport field\");\n\t\t\t}\n\t\t}\n\t\treturn pipe;\n\t}\n\n\tprotected void targetNotFound(String message) {\n\t\tthrow new TargetNotFoundException(message, this);\n\t}\n\n\tpublic enum LTGPCompletionCheck {\n\t\tNONE,\n\t\tPIPE,\n\t\tTRANSPORT\n\t}\n}",
    "patch": "@@ -1,7 +1,5 @@\n package logisticspipes.network.abstractpackets;\n \n-import java.io.IOException;\n-\n import net.minecraft.tileentity.TileEntity;\n import net.minecraft.world.World;\n \n@@ -18,16 +16,6 @@\n @ToString\n public abstract class CoordinatesPacket extends ModernPacket {\n \n-\tpublic enum LTGPCompletionCheck {\n-\t\tNONE,\n-\t\tPIPE,\n-\t\tTRANSPORT\n-\t}\n-\n-\tpublic CoordinatesPacket(int id) {\n-\t\tsuper(id);\n-\t}\n-\n \t@Getter\n \t@Setter\n \tprivate int posX;\n@@ -38,16 +26,20 @@ public CoordinatesPacket(int id) {\n \t@Setter\n \tprivate int posZ;\n \n+\tpublic CoordinatesPacket(int id) {\n+\t\tsuper(id);\n+\t}\n+\n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \n \t\toutput.writeInt(posX);\n \t\toutput.writeInt(posY);\n \t\toutput.writeInt(posZ);\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \n \t\tposX = input.readInt();\n \t\tposY = input.readInt();\n@@ -173,4 +165,10 @@ public LogisticsTileGenericPipe getPipe(World world, LTGPCompletionCheck check)\n \tprotected void targetNotFound(String message) {\n \t\tthrow new TargetNotFoundException(message, this);\n \t}\n+\n+\tpublic enum LTGPCompletionCheck {\n+\t\tNONE,\n+\t\tPIPE,\n+\t\tTRANSPORT\n+\t}\n }",
    "function_modified_lines": {
      "added": [
        "\n",
        "\tpublic enum LTGPCompletionCheck {\n",
        "\t\tNONE,\n",
        "\t\tPIPE,\n",
        "\t\tTRANSPORT\n",
        "\t}\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12772
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate int integer2;\n\n\tpublic Integer2CoordinatesPacket(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tsuper.readData(input);\n\t\tsetInteger2(input.readInt());\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\tsuper.writeData(output);\n\t\toutput.writeInt(getInteger2());\n\t}\n}",
    "code_after_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate int integer2;\n\n\tpublic Integer2CoordinatesPacket(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tsuper.readData(input);\n\t\tsetInteger2(input.readInt());\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\tsuper.writeData(output);\n\t\toutput.writeInt(getInteger2());\n\t}\n}",
    "patch": "@@ -1,7 +1,5 @@\n package logisticspipes.network.abstractpackets;\n \n-import java.io.IOException;\n-\n import lombok.Getter;\n import lombok.Setter;\n \n@@ -19,13 +17,13 @@ public Integer2CoordinatesPacket(int id) {\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tsuper.readData(input);\n \t\tsetInteger2(input.readInt());\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\tsuper.writeData(output);\n \t\toutput.writeInt(getInteger2());\n \t}",
    "function_modified_lines": {
      "added": [
        "\tpublic void readData(LPDataInput input) {\n",
        "\tpublic void writeData(LPDataOutput output) {\n"
      ],
      "deleted": [
        "\tpublic void readData(LPDataInput input) throws IOException {\n",
        "\tpublic void writeData(LPDataOutput output) throws IOException {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12773
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate int integer2;\n\n\tpublic Integer2ModuleCoordinatesPacket(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tsuper.readData(input);\n\t\tsetInteger2(input.readInt());\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\tsuper.writeData(output);\n\t\toutput.writeInt(getInteger2());\n\t}\n}",
    "code_after_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate int integer2;\n\n\tpublic Integer2ModuleCoordinatesPacket(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tsuper.readData(input);\n\t\tsetInteger2(input.readInt());\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\tsuper.writeData(output);\n\t\toutput.writeInt(getInteger2());\n\t}\n}",
    "patch": "@@ -1,7 +1,5 @@\n package logisticspipes.network.abstractpackets;\n \n-import java.io.IOException;\n-\n import lombok.Getter;\n import lombok.Setter;\n \n@@ -19,13 +17,13 @@ public Integer2ModuleCoordinatesPacket(int id) {\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tsuper.readData(input);\n \t\tsetInteger2(input.readInt());\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\tsuper.writeData(output);\n \t\toutput.writeInt(getInteger2());\n \t}",
    "function_modified_lines": {
      "added": [
        "\tpublic void readData(LPDataInput input) {\n",
        "\tpublic void writeData(LPDataOutput output) {\n"
      ],
      "deleted": [
        "\tpublic void readData(LPDataInput input) throws IOException {\n",
        "\tpublic void writeData(LPDataOutput output) throws IOException {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12774
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate int integer;\n\n\tpublic IntegerCoordinatesPacket(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tsuper.readData(input);\n\t\tsetInteger(input.readInt());\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\tsuper.writeData(output);\n\t\toutput.writeInt(getInteger());\n\t}\n}",
    "code_after_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate int integer;\n\n\tpublic IntegerCoordinatesPacket(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tsuper.readData(input);\n\t\tsetInteger(input.readInt());\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\tsuper.writeData(output);\n\t\toutput.writeInt(getInteger());\n\t}\n}",
    "patch": "@@ -1,7 +1,5 @@\n package logisticspipes.network.abstractpackets;\n \n-import java.io.IOException;\n-\n import lombok.Getter;\n import lombok.Setter;\n \n@@ -19,13 +17,13 @@ public IntegerCoordinatesPacket(int id) {\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tsuper.readData(input);\n \t\tsetInteger(input.readInt());\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\tsuper.writeData(output);\n \t\toutput.writeInt(getInteger());\n \t}",
    "function_modified_lines": {
      "added": [
        "\tpublic void readData(LPDataInput input) {\n",
        "\tpublic void writeData(LPDataOutput output) {\n"
      ],
      "deleted": [
        "\tpublic void readData(LPDataInput input) throws IOException {\n",
        "\tpublic void writeData(LPDataOutput output) throws IOException {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12775
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate int integer;\n\n\tpublic IntegerModuleCoordinatesPacket(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tsuper.readData(input);\n\t\tsetInteger(input.readInt());\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\tsuper.writeData(output);\n\t\toutput.writeInt(getInteger());\n\t}\n}",
    "code_after_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate int integer;\n\n\tpublic IntegerModuleCoordinatesPacket(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tsuper.readData(input);\n\t\tsetInteger(input.readInt());\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\tsuper.writeData(output);\n\t\toutput.writeInt(getInteger());\n\t}\n}",
    "patch": "@@ -1,7 +1,5 @@\n package logisticspipes.network.abstractpackets;\n \n-import java.io.IOException;\n-\n import lombok.Getter;\n import lombok.Setter;\n \n@@ -19,13 +17,13 @@ public IntegerModuleCoordinatesPacket(int id) {\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tsuper.readData(input);\n \t\tsetInteger(input.readInt());\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\tsuper.writeData(output);\n \t\toutput.writeInt(getInteger());\n \t}",
    "function_modified_lines": {
      "added": [
        "\tpublic void readData(LPDataInput input) {\n",
        "\tpublic void writeData(LPDataOutput output) {\n"
      ],
      "deleted": [
        "\tpublic void readData(LPDataInput input) throws IOException {\n",
        "\tpublic void writeData(LPDataOutput output) throws IOException {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12776
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "{\n\n\t@Setter\n\t@Getter(value = AccessLevel.PROTECTED)\n\tprivate List<E> list;\n\n\tpublic ListSyncPacket(int id, int x, int y, int z) {\n\t\tsuper(id);\n\t\tsetPosX(x);\n\t\tsetPosY(y);\n\t\tsetPosZ(z);\n\t}\n\n\tpublic ListSyncPacket(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\tsuper.writeData(output);\n\t\toutput.writeCollection(list, this);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tsuper.readData(input);\n\t\tlist = input.readArrayList(this);\n\t}\n\n\t@Override\n\tpublic abstract ListSyncPacket<E> template();\n}",
    "code_after_change": "{\n\n\t@Setter\n\t@Getter(value = AccessLevel.PROTECTED)\n\tprivate List<E> list;\n\n\tpublic ListSyncPacket(int id, int x, int y, int z) {\n\t\tsuper(id);\n\t\tsetPosX(x);\n\t\tsetPosY(y);\n\t\tsetPosZ(z);\n\t}\n\n\tpublic ListSyncPacket(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\tsuper.writeData(output);\n\t\toutput.writeCollection(list, this);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tsuper.readData(input);\n\t\tlist = input.readArrayList(this);\n\t}\n\n\t@Override\n\tpublic abstract ListSyncPacket<E> template();\n}",
    "patch": "@@ -1,6 +1,5 @@\n package logisticspipes.network.abstractpackets;\n \n-import java.io.IOException;\n import java.util.List;\n \n import lombok.AccessLevel;\n@@ -30,13 +29,13 @@ public ListSyncPacket(int id) {\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\tsuper.writeData(output);\n \t\toutput.writeCollection(list, this);\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tsuper.readData(input);\n \t\tlist = input.readArrayList(this);\n \t}",
    "function_modified_lines": {
      "added": [
        "\tpublic void writeData(LPDataOutput output) {\n",
        "\tpublic void readData(LPDataInput input) {\n"
      ],
      "deleted": [
        "\tpublic void writeData(LPDataOutput output) throws IOException {\n",
        "\tpublic void readData(LPDataInput input) throws IOException {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12777
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate ModulePositionType type;\n\n\t@Getter\n\t@Setter\n\tprivate int positionInt;\n\n\tpublic ModuleCoordinatesPacket(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\tsuper.writeData(output);\n\t\toutput.writeBoolean(type != null);\n\t\tif (type != null) {\n\t\t\toutput.writeEnum(type);\n\t\t\toutput.writeInt(positionInt);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tsuper.readData(input);\n\t\tif (input.readBoolean()) {\n\t\t\ttype = input.readEnum(ModulePositionType.class);\n\t\t\tpositionInt = input.readInt();\n\t\t}\n\t}\n\n\tpublic ModuleCoordinatesPacket setModulePos(LogisticsModule module) {\n\t\ttype = module.getSlot();\n\t\tpositionInt = module.getPositionInt();\n\t\tsetPosX(module.getX());\n\t\tsetPosY(module.getY());\n\t\tsetPosZ(module.getZ());\n\t\treturn this;\n\t}\n\n\tpublic ModuleCoordinatesPacket setPacketPos(ModuleCoordinatesPacket packet) {\n\t\ttype = packet.type;\n\t\tpositionInt = packet.positionInt;\n\t\tsuper.setPacketPos(packet);\n\t\treturn this;\n\t}\n\n\tprivate boolean moduleBased = false;\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T> T getLogisticsModule(EntityPlayer player, Class<T> clazz) {\n\t\tLogisticsModule module = null;\n\t\tif (type == ModulePositionType.IN_PIPE) {\n\t\t\tmoduleBased = true;\n\t\t\tLogisticsTileGenericPipe pipe = this.getPipe(player.getEntityWorld());\n\t\t\tmoduleBased = false;\n\t\t\tif (pipe == null || !(pipe.pipe instanceof CoreRoutedPipe)) {\n\t\t\t\ttargetNotFound(\"Couldn't find \" + clazz.getName() + \", pipe didn't exsist\");\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tmodule = ((CoreRoutedPipe) pipe.pipe).getLogisticsModule();\n\t\t} else if (type == ModulePositionType.IN_HAND) {\n\t\t\tif (MainProxy.isServer(player.getEntityWorld())) {\n\t\t\t\tif (player.openContainer instanceof DummyModuleContainer) {\n\t\t\t\t\tDummyModuleContainer dummy = (DummyModuleContainer) player.openContainer;\n\t\t\t\t\tmodule = dummy.getModule();\n\t\t\t\t} else {\n\t\t\t\t\ttargetNotFound(\"Couldn't find \" + clazz.getName() + \", container wasn't a DummyModule Container\");\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmodule = MainProxy.proxy.getModuleFromGui();\n\t\t\t\tif (module == null) {\n\t\t\t\t\ttargetNotFound(\"Couldn't find \" + clazz.getName() + \", GUI didn't provide the module\");\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tmoduleBased = true;\n\t\t\tLogisticsTileGenericPipe pipe = this.getPipe(player.getEntityWorld());\n\t\t\tmoduleBased = false;\n\t\t\tif (pipe == null || !(pipe.pipe instanceof CoreRoutedPipe)) {\n\t\t\t\ttargetNotFound(\"Couldn't find \" + clazz.getName() + \", pipe didn't exsist\");\n\t\t\t\treturn null;\n\t\t\t} else if (!pipe.isInitialized()) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (!(pipe.pipe instanceof PipeLogisticsChassi)) {\n\t\t\t\ttargetNotFound(\"Couldn't find \" + clazz.getName() + \", pipe wasn't a chassi pipe\");\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tmodule = ((PipeLogisticsChassi) pipe.pipe).getLogisticsModule().getSubModule(positionInt);\n\t\t}\n\t\tif (module != null) {\n\t\t\tif (!(clazz.isAssignableFrom(module.getClass()))) {\n\t\t\t\ttargetNotFound(\"Couldn't find \" + clazz.getName() + \", found \" + module.getClass());\n\t\t\t\treturn null;\n\t\t\t}\n\t\t} else {\n\t\t\ttargetNotFound(\"Couldn't find \" + clazz.getName());\n\t\t}\n\t\treturn (T) module;\n\t}\n\n\t@Override\n\tpublic <T> T getTile(World world, Class<T> clazz) {\n\t\tif (LPConstants.DEBUG && !moduleBased && type != null) {\n\t\t\tnew Exception(\"ModulePacket was asked for a pipe\").printStackTrace();\n\t\t}\n\t\treturn super.getTile(world, clazz);\n\t}\n}",
    "code_after_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate ModulePositionType type;\n\n\t@Getter\n\t@Setter\n\tprivate int positionInt;\n\tprivate boolean moduleBased = false;\n\n\tpublic ModuleCoordinatesPacket(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\tsuper.writeData(output);\n\t\toutput.writeBoolean(type != null);\n\t\tif (type != null) {\n\t\t\toutput.writeEnum(type);\n\t\t\toutput.writeInt(positionInt);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tsuper.readData(input);\n\t\tif (input.readBoolean()) {\n\t\t\ttype = input.readEnum(ModulePositionType.class);\n\t\t\tpositionInt = input.readInt();\n\t\t}\n\t}\n\n\tpublic ModuleCoordinatesPacket setModulePos(LogisticsModule module) {\n\t\ttype = module.getSlot();\n\t\tpositionInt = module.getPositionInt();\n\t\tsetPosX(module.getX());\n\t\tsetPosY(module.getY());\n\t\tsetPosZ(module.getZ());\n\t\treturn this;\n\t}\n\n\tpublic ModuleCoordinatesPacket setPacketPos(ModuleCoordinatesPacket packet) {\n\t\ttype = packet.type;\n\t\tpositionInt = packet.positionInt;\n\t\tsuper.setPacketPos(packet);\n\t\treturn this;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T> T getLogisticsModule(EntityPlayer player, Class<T> clazz) {\n\t\tLogisticsModule module = null;\n\t\tif (type == ModulePositionType.IN_PIPE) {\n\t\t\tmoduleBased = true;\n\t\t\tLogisticsTileGenericPipe pipe = this.getPipe(player.getEntityWorld());\n\t\t\tmoduleBased = false;\n\t\t\tif (pipe == null || !(pipe.pipe instanceof CoreRoutedPipe)) {\n\t\t\t\ttargetNotFound(\"Couldn't find \" + clazz.getName() + \", pipe didn't exsist\");\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tmodule = ((CoreRoutedPipe) pipe.pipe).getLogisticsModule();\n\t\t} else if (type == ModulePositionType.IN_HAND) {\n\t\t\tif (MainProxy.isServer(player.getEntityWorld())) {\n\t\t\t\tif (player.openContainer instanceof DummyModuleContainer) {\n\t\t\t\t\tDummyModuleContainer dummy = (DummyModuleContainer) player.openContainer;\n\t\t\t\t\tmodule = dummy.getModule();\n\t\t\t\t} else {\n\t\t\t\t\ttargetNotFound(\"Couldn't find \" + clazz.getName() + \", container wasn't a DummyModule Container\");\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmodule = MainProxy.proxy.getModuleFromGui();\n\t\t\t\tif (module == null) {\n\t\t\t\t\ttargetNotFound(\"Couldn't find \" + clazz.getName() + \", GUI didn't provide the module\");\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tmoduleBased = true;\n\t\t\tLogisticsTileGenericPipe pipe = this.getPipe(player.getEntityWorld());\n\t\t\tmoduleBased = false;\n\t\t\tif (pipe == null || !(pipe.pipe instanceof CoreRoutedPipe)) {\n\t\t\t\ttargetNotFound(\"Couldn't find \" + clazz.getName() + \", pipe didn't exsist\");\n\t\t\t\treturn null;\n\t\t\t} else if (!pipe.isInitialized()) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (!(pipe.pipe instanceof PipeLogisticsChassi)) {\n\t\t\t\ttargetNotFound(\"Couldn't find \" + clazz.getName() + \", pipe wasn't a chassi pipe\");\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tmodule = ((PipeLogisticsChassi) pipe.pipe).getLogisticsModule().getSubModule(positionInt);\n\t\t}\n\t\tif (module != null) {\n\t\t\tif (!(clazz.isAssignableFrom(module.getClass()))) {\n\t\t\t\ttargetNotFound(\"Couldn't find \" + clazz.getName() + \", found \" + module.getClass());\n\t\t\t\treturn null;\n\t\t\t}\n\t\t} else {\n\t\t\ttargetNotFound(\"Couldn't find \" + clazz.getName());\n\t\t}\n\t\treturn (T) module;\n\t}\n\n\t@Override\n\tpublic <T> T getTile(World world, Class<T> clazz) {\n\t\tif (LPConstants.DEBUG && !moduleBased && type != null) {\n\t\t\tnew Exception(\"ModulePacket was asked for a pipe\").printStackTrace();\n\t\t}\n\t\treturn super.getTile(world, clazz);\n\t}\n}",
    "patch": "@@ -1,7 +1,5 @@\n package logisticspipes.network.abstractpackets;\n \n-import java.io.IOException;\n-\n import net.minecraft.entity.player.EntityPlayer;\n import net.minecraft.world.World;\n \n@@ -28,13 +26,14 @@ public abstract class ModuleCoordinatesPacket extends CoordinatesPacket {\n \t@Getter\n \t@Setter\n \tprivate int positionInt;\n+\tprivate boolean moduleBased = false;\n \n \tpublic ModuleCoordinatesPacket(int id) {\n \t\tsuper(id);\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\tsuper.writeData(output);\n \t\toutput.writeBoolean(type != null);\n \t\tif (type != null) {\n@@ -44,7 +43,7 @@ public void writeData(LPDataOutput output) throws IOException {\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tsuper.readData(input);\n \t\tif (input.readBoolean()) {\n \t\t\ttype = input.readEnum(ModulePositionType.class);\n@@ -68,8 +67,6 @@ public ModuleCoordinatesPacket setPacketPos(ModuleCoordinatesPacket packet) {\n \t\treturn this;\n \t}\n \n-\tprivate boolean moduleBased = false;\n-\n \t@SuppressWarnings(\"unchecked\")\n \tpublic <T> T getLogisticsModule(EntityPlayer player, Class<T> clazz) {\n \t\tLogisticsModule module = null;",
    "function_modified_lines": {
      "added": [
        "\tprivate boolean moduleBased = false;\n",
        "\tpublic void writeData(LPDataOutput output) {\n",
        "\tpublic void readData(LPDataInput input) {\n"
      ],
      "deleted": [
        "\tpublic void writeData(LPDataOutput output) throws IOException {\n",
        "\tpublic void readData(LPDataInput input) throws IOException {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12778
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate NBTTagCompound tag;\n\n\tpublic NBTCoordinatesPacket(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\tsuper.writeData(output);\n\t\toutput.writeNBTTagCompound(tag);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tsuper.readData(input);\n\t\ttag = input.readNBTTagCompound();\n\t}\n}",
    "code_after_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate NBTTagCompound tag;\n\n\tpublic NBTCoordinatesPacket(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\tsuper.writeData(output);\n\t\toutput.writeNBTTagCompound(tag);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tsuper.readData(input);\n\t\ttag = input.readNBTTagCompound();\n\t}\n}",
    "patch": "@@ -1,7 +1,5 @@\n package logisticspipes.network.abstractpackets;\n \n-import java.io.IOException;\n-\n import net.minecraft.nbt.NBTTagCompound;\n \n import lombok.Getter;\n@@ -21,13 +19,13 @@ public NBTCoordinatesPacket(int id) {\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\tsuper.writeData(output);\n \t\toutput.writeNBTTagCompound(tag);\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tsuper.readData(input);\n \t\ttag = input.readNBTTagCompound();\n \t}",
    "function_modified_lines": {
      "added": [
        "\tpublic void writeData(LPDataOutput output) {\n",
        "\tpublic void readData(LPDataInput input) {\n"
      ],
      "deleted": [
        "\tpublic void writeData(LPDataOutput output) throws IOException {\n",
        "\tpublic void readData(LPDataInput input) throws IOException {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12779
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate NBTTagCompound tag;\n\n\tpublic NBTModuleCoordinatesPacket(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\tsuper.writeData(output);\n\t\toutput.writeNBTTagCompound(tag);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tsuper.readData(input);\n\t\ttag = input.readNBTTagCompound();\n\t}\n}",
    "code_after_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate NBTTagCompound tag;\n\n\tpublic NBTModuleCoordinatesPacket(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\tsuper.writeData(output);\n\t\toutput.writeNBTTagCompound(tag);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tsuper.readData(input);\n\t\ttag = input.readNBTTagCompound();\n\t}\n}",
    "patch": "@@ -1,7 +1,5 @@\n package logisticspipes.network.abstractpackets;\n \n-import java.io.IOException;\n-\n import net.minecraft.nbt.NBTTagCompound;\n \n import lombok.Getter;\n@@ -21,13 +19,13 @@ public NBTModuleCoordinatesPacket(int id) {\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\tsuper.writeData(output);\n \t\toutput.writeNBTTagCompound(tag);\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tsuper.readData(input);\n \t\ttag = input.readNBTTagCompound();\n \t}",
    "function_modified_lines": {
      "added": [
        "\tpublic void writeData(LPDataOutput output) {\n",
        "\tpublic void readData(LPDataInput input) {\n"
      ],
      "deleted": [
        "\tpublic void writeData(LPDataOutput output) throws IOException {\n",
        "\tpublic void readData(LPDataInput input) throws IOException {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12780
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate String string;\n\n\tpublic StringCoordinatesPacket(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\tsuper.writeData(output);\n\t\toutput.writeUTF(getString());\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tsuper.readData(input);\n\t\tsetString(input.readUTF());\n\t}\n}",
    "code_after_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate String string;\n\n\tpublic StringCoordinatesPacket(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\tsuper.writeData(output);\n\t\toutput.writeUTF(getString());\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tsuper.readData(input);\n\t\tsetString(input.readUTF());\n\t}\n}",
    "patch": "@@ -1,7 +1,5 @@\n package logisticspipes.network.abstractpackets;\n \n-import java.io.IOException;\n-\n import lombok.Getter;\n import lombok.Setter;\n \n@@ -19,13 +17,13 @@ public StringCoordinatesPacket(int id) {\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\tsuper.writeData(output);\n \t\toutput.writeUTF(getString());\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tsuper.readData(input);\n \t\tsetString(input.readUTF());\n \t}",
    "function_modified_lines": {
      "added": [
        "\tpublic void writeData(LPDataOutput output) {\n",
        "\tpublic void readData(LPDataInput input) {\n"
      ],
      "deleted": [
        "\tpublic void writeData(LPDataOutput output) throws IOException {\n",
        "\tpublic void readData(LPDataInput input) throws IOException {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12781
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate List<TrackingTask> trackingList;\n\n\tpublic StatisticsGui(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic Object getClientGui(EntityPlayer player) {\n\t\tLogisticsStatisticsTileEntity tile = this.getTile(player.getEntityWorld(), LogisticsStatisticsTileEntity.class);\n\t\tif (tile == null) {\n\t\t\treturn null;\n\t\t}\n\t\ttile.tasks = trackingList;\n\t\tGuiStatistics gui = new GuiStatistics(tile);\n\n\t\tgui.inventorySlots = new DummyContainer(player.inventory, null);\n\n\t\treturn gui;\n\t}\n\n\t@Override\n\tpublic Container getContainer(EntityPlayer player) {\n\t\tLogisticsStatisticsTileEntity tile = this.getTile(player.getEntityWorld(), LogisticsStatisticsTileEntity.class);\n\t\tif (tile == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn new DummyContainer(player, null);\n\t}\n\n\t@Override\n\tpublic GuiProvider template() {\n\t\treturn new StatisticsGui(getId());\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\tsuper.writeData(output);\n\t\toutput.writeCollection(trackingList, (output1, object) -> object.writeToLPData(output1));\n\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tsuper.readData(input);\n\t\ttrackingList = input.readArrayList(data1 -> {\n\t\t\tTrackingTask object = new TrackingTask();\n\t\t\tobject.readFromLPData(data1);\n\t\t\treturn object;\n\t\t});\n\t}\n}",
    "code_after_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate List<TrackingTask> trackingList;\n\n\tpublic StatisticsGui(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic Object getClientGui(EntityPlayer player) {\n\t\tLogisticsStatisticsTileEntity tile = this.getTile(player.getEntityWorld(), LogisticsStatisticsTileEntity.class);\n\t\tif (tile == null) {\n\t\t\treturn null;\n\t\t}\n\t\ttile.tasks = trackingList;\n\t\tGuiStatistics gui = new GuiStatistics(tile);\n\n\t\tgui.inventorySlots = new DummyContainer(player.inventory, null);\n\n\t\treturn gui;\n\t}\n\n\t@Override\n\tpublic Container getContainer(EntityPlayer player) {\n\t\tLogisticsStatisticsTileEntity tile = this.getTile(player.getEntityWorld(), LogisticsStatisticsTileEntity.class);\n\t\tif (tile == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn new DummyContainer(player, null);\n\t}\n\n\t@Override\n\tpublic GuiProvider template() {\n\t\treturn new StatisticsGui(getId());\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\tsuper.writeData(output);\n\t\toutput.writeCollection(trackingList, (output1, object) -> object.writeToLPData(output1));\n\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tsuper.readData(input);\n\t\ttrackingList = input.readArrayList(data1 -> {\n\t\t\tTrackingTask object = new TrackingTask();\n\t\t\tobject.readFromLPData(data1);\n\t\t\treturn object;\n\t\t});\n\t}\n}",
    "patch": "@@ -1,6 +1,5 @@\n package logisticspipes.network.guis.block;\n \n-import java.io.IOException;\n import java.util.List;\n \n import net.minecraft.entity.player.EntityPlayer;\n@@ -58,14 +57,14 @@ public GuiProvider template() {\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\tsuper.writeData(output);\n \t\toutput.writeCollection(trackingList, (output1, object) -> object.writeToLPData(output1));\n \n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tsuper.readData(input);\n \t\ttrackingList = input.readArrayList(data1 -> {\n \t\t\tTrackingTask object = new TrackingTask();",
    "function_modified_lines": {
      "added": [
        "\tpublic void writeData(LPDataOutput output) {\n",
        "\tpublic void readData(LPDataInput input) {\n"
      ],
      "deleted": [
        "\tpublic void writeData(LPDataOutput output) throws IOException {\n",
        "\tpublic void readData(LPDataInput input) throws IOException {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12782
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate int[] amount;\n\n\t@Getter\n\t@Setter\n\tprivate boolean cleanupExclude;\n\n\tpublic CraftingModuleInHand(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic Object getClientGui(EntityPlayer player) {\n\t\tLogisticsModule module = getLogisticsModule(player);\n\t\tif (!(module instanceof ModuleCrafter)) {\n\t\t\treturn null;\n\t\t}\n\t\treturn new GuiCraftingPipe(player, ((ModuleCrafter) module).getDummyInventory(), ((ModuleCrafter) module), false, 0, amount, false, false, 0,\n\t\t\t\tcleanupExclude);\n\t}\n\n\t@Override\n\tpublic DummyContainer getContainer(EntityPlayer player) {\n\t\tDummyModuleContainer dummy = new DummyModuleContainer(player, getInvSlot());\n\t\tif (!(dummy.getModule() instanceof ModuleCrafter)) {\n\t\t\treturn null;\n\t\t}\n\t\tMainProxy.sendPacketToPlayer(((ModuleCrafter) dummy.getModule()).getCPipePacket(), player);\n\t\tdummy.setInventory(((ModuleCrafter) dummy.getModule()).getDummyInventory());\n\t\tdummy.addNormalSlotsForPlayerInventory(18, 97);\n\t\t//Input slots\n\t\tfor (int l = 0; l < 9; l++) {\n\t\t\tdummy.addFuzzyDummySlot(l, 18 + l * 18, 18, ((ModuleCrafter) dummy.getModule()).fuzzyCraftingFlagArray[l]);\n\t\t}\n\n\t\t//Output slot\n\t\tdummy.addFuzzyDummySlot(9, 90, 64, ((ModuleCrafter) dummy.getModule()).outputFuzzyFlags);\n\t\treturn dummy;\n\t}\n\n\t@Override\n\tpublic GuiProvider template() {\n\t\treturn new CraftingModuleInHand(getId());\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\tsuper.writeData(output);\n\t\toutput.writeIntArray(amount);\n\t\toutput.writeBoolean(cleanupExclude);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tsuper.readData(input);\n\t\tamount = input.readIntArray();\n\t\tcleanupExclude = input.readBoolean();\n\t}\n}",
    "code_after_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate int[] amount;\n\n\t@Getter\n\t@Setter\n\tprivate boolean cleanupExclude;\n\n\tpublic CraftingModuleInHand(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic Object getClientGui(EntityPlayer player) {\n\t\tLogisticsModule module = getLogisticsModule(player);\n\t\tif (!(module instanceof ModuleCrafter)) {\n\t\t\treturn null;\n\t\t}\n\t\treturn new GuiCraftingPipe(player, ((ModuleCrafter) module).getDummyInventory(), ((ModuleCrafter) module), false, 0, amount, false, false, 0,\n\t\t\t\tcleanupExclude);\n\t}\n\n\t@Override\n\tpublic DummyContainer getContainer(EntityPlayer player) {\n\t\tDummyModuleContainer dummy = new DummyModuleContainer(player, getInvSlot());\n\t\tif (!(dummy.getModule() instanceof ModuleCrafter)) {\n\t\t\treturn null;\n\t\t}\n\t\tMainProxy.sendPacketToPlayer(((ModuleCrafter) dummy.getModule()).getCPipePacket(), player);\n\t\tdummy.setInventory(((ModuleCrafter) dummy.getModule()).getDummyInventory());\n\t\tdummy.addNormalSlotsForPlayerInventory(18, 97);\n\t\t//Input slots\n\t\tfor (int l = 0; l < 9; l++) {\n\t\t\tdummy.addFuzzyDummySlot(l, 18 + l * 18, 18, ((ModuleCrafter) dummy.getModule()).fuzzyCraftingFlagArray[l]);\n\t\t}\n\n\t\t//Output slot\n\t\tdummy.addFuzzyDummySlot(9, 90, 64, ((ModuleCrafter) dummy.getModule()).outputFuzzyFlags);\n\t\treturn dummy;\n\t}\n\n\t@Override\n\tpublic GuiProvider template() {\n\t\treturn new CraftingModuleInHand(getId());\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\tsuper.writeData(output);\n\t\toutput.writeIntArray(amount);\n\t\toutput.writeBoolean(cleanupExclude);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tsuper.readData(input);\n\t\tamount = input.readIntArray();\n\t\tcleanupExclude = input.readBoolean();\n\t}\n}",
    "patch": "@@ -1,7 +1,5 @@\n package logisticspipes.network.guis.module.inhand;\n \n-import java.io.IOException;\n-\n import net.minecraft.entity.player.EntityPlayer;\n \n import lombok.Getter;\n@@ -67,14 +65,14 @@ public GuiProvider template() {\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\tsuper.writeData(output);\n \t\toutput.writeIntArray(amount);\n \t\toutput.writeBoolean(cleanupExclude);\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tsuper.readData(input);\n \t\tamount = input.readIntArray();\n \t\tcleanupExclude = input.readBoolean();",
    "function_modified_lines": {
      "added": [
        "\tpublic void writeData(LPDataOutput output) {\n",
        "\tpublic void readData(LPDataInput input) {\n"
      ],
      "deleted": [
        "\tpublic void writeData(LPDataOutput output) throws IOException {\n",
        "\tpublic void readData(LPDataInput input) throws IOException {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12783
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate boolean patternUpgarde;\n\n\t@Getter\n\t@Setter\n\tprivate int[] slotArray;\n\n\t@Getter\n\t@Setter\n\tprivate boolean isLimit;\n\n\t@Getter\n\t@Setter\n\tprivate int mode;\n\n\tpublic ActiveSupplierSlot(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\tsuper.writeData(output);\n\t\toutput.writeBoolean(patternUpgarde);\n\t\toutput.writeIntArray(slotArray);\n\t\toutput.writeBoolean(isLimit);\n\t\toutput.writeInt(mode);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tsuper.readData(input);\n\t\tpatternUpgarde = input.readBoolean();\n\t\tslotArray = input.readIntArray();\n\t\tisLimit = input.readBoolean();\n\t\tmode = input.readInt();\n\t}\n\n\t@Override\n\tpublic Object getClientGui(EntityPlayer player) {\n\t\tModuleActiveSupplier module = this.getLogisticsModule(player.getEntityWorld(), ModuleActiveSupplier.class);\n\t\tif (module == null) {\n\t\t\treturn null;\n\t\t}\n\t\tmodule.setLimited(isLimit);\n\t\tif (patternUpgarde) {\n\t\t\tmodule.setPatternMode(PatternMode.values()[mode]);\n\t\t} else {\n\t\t\tmodule.setSupplyMode(SupplyMode.values()[mode]);\n\t\t}\n\t\treturn new GuiSupplierPipe(player.inventory, module.getDummyInventory(), module, patternUpgarde, slotArray);\n\t}\n\n\t@Override\n\tpublic DummyContainer getContainer(EntityPlayer player) {\n\t\tModuleActiveSupplier module = this.getLogisticsModule(player.getEntityWorld(), ModuleActiveSupplier.class);\n\t\tif (module == null) {\n\t\t\treturn null;\n\t\t}\n\t\tDummyContainer dummy = new DummyContainer(player.inventory, module.getDummyInventory());\n\t\tdummy.addNormalSlotsForPlayerInventory(18, 97);\n\n\t\tfor (int row = 0; row < 3; row++) {\n\t\t\tfor (int column = 0; column < 3; column++) {\n\t\t\t\tdummy.addDummySlot(column + row * 3, 72 + column * 18, 18 + row * 18);\n\t\t\t}\n\t\t}\n\t\treturn dummy;\n\t}\n\n\t@Override\n\tpublic GuiProvider template() {\n\t\treturn new ActiveSupplierSlot(getId());\n\t}\n}",
    "code_after_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate boolean patternUpgarde;\n\n\t@Getter\n\t@Setter\n\tprivate int[] slotArray;\n\n\t@Getter\n\t@Setter\n\tprivate boolean isLimit;\n\n\t@Getter\n\t@Setter\n\tprivate int mode;\n\n\tpublic ActiveSupplierSlot(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\tsuper.writeData(output);\n\t\toutput.writeBoolean(patternUpgarde);\n\t\toutput.writeIntArray(slotArray);\n\t\toutput.writeBoolean(isLimit);\n\t\toutput.writeInt(mode);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tsuper.readData(input);\n\t\tpatternUpgarde = input.readBoolean();\n\t\tslotArray = input.readIntArray();\n\t\tisLimit = input.readBoolean();\n\t\tmode = input.readInt();\n\t}\n\n\t@Override\n\tpublic Object getClientGui(EntityPlayer player) {\n\t\tModuleActiveSupplier module = this.getLogisticsModule(player.getEntityWorld(), ModuleActiveSupplier.class);\n\t\tif (module == null) {\n\t\t\treturn null;\n\t\t}\n\t\tmodule.setLimited(isLimit);\n\t\tif (patternUpgarde) {\n\t\t\tmodule.setPatternMode(PatternMode.values()[mode]);\n\t\t} else {\n\t\t\tmodule.setSupplyMode(SupplyMode.values()[mode]);\n\t\t}\n\t\treturn new GuiSupplierPipe(player.inventory, module.getDummyInventory(), module, patternUpgarde, slotArray);\n\t}\n\n\t@Override\n\tpublic DummyContainer getContainer(EntityPlayer player) {\n\t\tModuleActiveSupplier module = this.getLogisticsModule(player.getEntityWorld(), ModuleActiveSupplier.class);\n\t\tif (module == null) {\n\t\t\treturn null;\n\t\t}\n\t\tDummyContainer dummy = new DummyContainer(player.inventory, module.getDummyInventory());\n\t\tdummy.addNormalSlotsForPlayerInventory(18, 97);\n\n\t\tfor (int row = 0; row < 3; row++) {\n\t\t\tfor (int column = 0; column < 3; column++) {\n\t\t\t\tdummy.addDummySlot(column + row * 3, 72 + column * 18, 18 + row * 18);\n\t\t\t}\n\t\t}\n\t\treturn dummy;\n\t}\n\n\t@Override\n\tpublic GuiProvider template() {\n\t\treturn new ActiveSupplierSlot(getId());\n\t}\n}",
    "patch": "@@ -1,7 +1,5 @@\n package logisticspipes.network.guis.module.inpipe;\n \n-import java.io.IOException;\n-\n import net.minecraft.entity.player.EntityPlayer;\n \n import lombok.Getter;\n@@ -40,7 +38,7 @@ public ActiveSupplierSlot(int id) {\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\tsuper.writeData(output);\n \t\toutput.writeBoolean(patternUpgarde);\n \t\toutput.writeIntArray(slotArray);\n@@ -49,7 +47,7 @@ public void writeData(LPDataOutput output) throws IOException {\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tsuper.readData(input);\n \t\tpatternUpgarde = input.readBoolean();\n \t\tslotArray = input.readIntArray();",
    "function_modified_lines": {
      "added": [
        "\tpublic void writeData(LPDataOutput output) {\n",
        "\tpublic void readData(LPDataInput input) {\n"
      ],
      "deleted": [
        "\tpublic void writeData(LPDataOutput output) throws IOException {\n",
        "\tpublic void readData(LPDataInput input) throws IOException {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12784
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate boolean areItemsIncluded;\n\n\tpublic AdvancedExtractorModuleSlot(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic Object getClientGui(EntityPlayer player) {\n\t\tModuleAdvancedExtractor module = this.getLogisticsModule(player.getEntityWorld(), ModuleAdvancedExtractor.class);\n\t\tif (module == null) {\n\t\t\treturn null;\n\t\t}\n\t\tmodule.setItemsIncluded(areItemsIncluded);\n\t\treturn new GuiAdvancedExtractor(player.inventory, module);\n\t}\n\n\t@Override\n\tpublic DummyContainer getContainer(EntityPlayer player) {\n\t\tModuleAdvancedExtractor module = this.getLogisticsModule(player.getEntityWorld(), ModuleAdvancedExtractor.class);\n\t\tif (module == null) {\n\t\t\treturn null;\n\t\t}\n\t\tDummyContainer dummy = new DummyContainer(player.inventory, module.getFilterInventory());\n\t\tdummy.addNormalSlotsForPlayerInventory(8, 60);\n\t\t//Pipe slots\n\t\tfor (int pipeSlot = 0; pipeSlot < 9; pipeSlot++) {\n\t\t\tdummy.addDummySlot(pipeSlot, 8 + pipeSlot * 18, 18);\n\t\t}\n\t\treturn dummy;\n\t}\n\n\t@Override\n\tpublic GuiProvider template() {\n\t\treturn new AdvancedExtractorModuleSlot(getId());\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\tsuper.writeData(output);\n\t\toutput.writeBoolean(areItemsIncluded);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tsuper.readData(input);\n\t\tareItemsIncluded = input.readBoolean();\n\t}\n}",
    "code_after_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate boolean areItemsIncluded;\n\n\tpublic AdvancedExtractorModuleSlot(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic Object getClientGui(EntityPlayer player) {\n\t\tModuleAdvancedExtractor module = this.getLogisticsModule(player.getEntityWorld(), ModuleAdvancedExtractor.class);\n\t\tif (module == null) {\n\t\t\treturn null;\n\t\t}\n\t\tmodule.setItemsIncluded(areItemsIncluded);\n\t\treturn new GuiAdvancedExtractor(player.inventory, module);\n\t}\n\n\t@Override\n\tpublic DummyContainer getContainer(EntityPlayer player) {\n\t\tModuleAdvancedExtractor module = this.getLogisticsModule(player.getEntityWorld(), ModuleAdvancedExtractor.class);\n\t\tif (module == null) {\n\t\t\treturn null;\n\t\t}\n\t\tDummyContainer dummy = new DummyContainer(player.inventory, module.getFilterInventory());\n\t\tdummy.addNormalSlotsForPlayerInventory(8, 60);\n\t\t//Pipe slots\n\t\tfor (int pipeSlot = 0; pipeSlot < 9; pipeSlot++) {\n\t\t\tdummy.addDummySlot(pipeSlot, 8 + pipeSlot * 18, 18);\n\t\t}\n\t\treturn dummy;\n\t}\n\n\t@Override\n\tpublic GuiProvider template() {\n\t\treturn new AdvancedExtractorModuleSlot(getId());\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\tsuper.writeData(output);\n\t\toutput.writeBoolean(areItemsIncluded);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tsuper.readData(input);\n\t\tareItemsIncluded = input.readBoolean();\n\t}\n}",
    "patch": "@@ -1,7 +1,5 @@\n package logisticspipes.network.guis.module.inpipe;\n \n-import java.io.IOException;\n-\n import net.minecraft.entity.player.EntityPlayer;\n \n import lombok.Getter;\n@@ -56,13 +54,13 @@ public GuiProvider template() {\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\tsuper.writeData(output);\n \t\toutput.writeBoolean(areItemsIncluded);\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tsuper.readData(input);\n \t\tareItemsIncluded = input.readBoolean();\n \t}",
    "function_modified_lines": {
      "added": [
        "\tpublic void writeData(LPDataOutput output) {\n",
        "\tpublic void readData(LPDataInput input) {\n"
      ],
      "deleted": [
        "\tpublic void writeData(LPDataOutput output) throws IOException {\n",
        "\tpublic void readData(LPDataInput input) throws IOException {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12785
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate boolean isAdvancedSat;\n\n\t@Getter\n\t@Setter\n\tprivate int liquidCrafter;\n\n\t@Getter\n\t@Setter\n\tprivate int[] amount;\n\n\t@Getter\n\t@Setter\n\tprivate boolean hasByproductExtractor;\n\n\t@Getter\n\t@Setter\n\tprivate boolean isFuzzy;\n\n\t@Getter\n\t@Setter\n\tprivate int cleanupSize;\n\n\t@Getter\n\t@Setter\n\tprivate boolean cleanupExclude;\n\n\tpublic CraftingModuleSlot(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic Object getClientGui(EntityPlayer player) {\n\t\tModuleCrafter module = this.getLogisticsModule(player.getEntityWorld(), ModuleCrafter.class);\n\t\tif (module == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn new GuiCraftingPipe(player, module.getDummyInventory(), module, isAdvancedSat, liquidCrafter, amount, hasByproductExtractor, isFuzzy,\n\t\t\t\tcleanupSize, cleanupExclude);\n\t}\n\n\t@Override\n\tpublic DummyContainer getContainer(EntityPlayer player) {\n\t\tModuleCrafter module = this.getLogisticsModule(player.getEntityWorld(), ModuleCrafter.class);\n\t\tif (module == null) {\n\t\t\treturn null;\n\t\t}\n\t\tMainProxy.sendPacketToPlayer(module.getCPipePacket(), player);\n\t\tDummyContainer dummy = new DummyContainer(player.inventory, module.getDummyInventory());\n\t\tdummy.addNormalSlotsForPlayerInventory(18, 97);\n\t\t//Input slots\n\t\tfor (int l = 0; l < 9; l++) {\n\t\t\tdummy.addFuzzyDummySlot(l, 18 + l * 18, 18, module.fuzzyCraftingFlagArray[l]);\n\t\t}\n\n\t\t//Output slot\n\t\tdummy.addFuzzyDummySlot(9, 90, 64, module.outputFuzzyFlags);\n\n\t\tfor (int i = 0; i < liquidCrafter; i++) {\n\t\t\tint liquidLeft = -(i * 40) - 40;\n\t\t\tdummy.addFluidSlot(i, module.getFluidInventory(), liquidLeft + 13, 42);\n\t\t}\n\n\t\tif (hasByproductExtractor) {\n\t\t\tdummy.addDummySlot(10, 197, 104);\n\t\t}\n\n\t\tfor (int Y = 0; Y < cleanupSize; Y++) {\n\t\t\tfor (int X = 0; X < 3; X++) {\n\t\t\t\tdummy.addDummySlot(Y * 3 + X, module.getCleanupInventory(), X * 18 - 57, Y * 18 + 13);\n\t\t\t}\n\t\t}\n\n\t\treturn dummy;\n\t}\n\n\t@Override\n\tpublic GuiProvider template() {\n\t\treturn new CraftingModuleSlot(getId());\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\tsuper.writeData(output);\n\t\toutput.writeBoolean(isAdvancedSat);\n\t\toutput.writeInt(liquidCrafter);\n\t\toutput.writeIntArray(amount);\n\t\toutput.writeBoolean(hasByproductExtractor);\n\t\toutput.writeBoolean(isFuzzy);\n\t\toutput.writeInt(cleanupSize);\n\t\toutput.writeBoolean(cleanupExclude);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tsuper.readData(input);\n\t\tisAdvancedSat = input.readBoolean();\n\t\tliquidCrafter = input.readInt();\n\t\tamount = input.readIntArray();\n\t\thasByproductExtractor = input.readBoolean();\n\t\tisFuzzy = input.readBoolean();\n\t\tcleanupSize = input.readInt();\n\t\tcleanupExclude = input.readBoolean();\n\t}\n}",
    "code_after_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate boolean isAdvancedSat;\n\n\t@Getter\n\t@Setter\n\tprivate int liquidCrafter;\n\n\t@Getter\n\t@Setter\n\tprivate int[] amount;\n\n\t@Getter\n\t@Setter\n\tprivate boolean hasByproductExtractor;\n\n\t@Getter\n\t@Setter\n\tprivate boolean isFuzzy;\n\n\t@Getter\n\t@Setter\n\tprivate int cleanupSize;\n\n\t@Getter\n\t@Setter\n\tprivate boolean cleanupExclude;\n\n\tpublic CraftingModuleSlot(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic Object getClientGui(EntityPlayer player) {\n\t\tModuleCrafter module = this.getLogisticsModule(player.getEntityWorld(), ModuleCrafter.class);\n\t\tif (module == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn new GuiCraftingPipe(player, module.getDummyInventory(), module, isAdvancedSat, liquidCrafter, amount, hasByproductExtractor, isFuzzy,\n\t\t\t\tcleanupSize, cleanupExclude);\n\t}\n\n\t@Override\n\tpublic DummyContainer getContainer(EntityPlayer player) {\n\t\tModuleCrafter module = this.getLogisticsModule(player.getEntityWorld(), ModuleCrafter.class);\n\t\tif (module == null) {\n\t\t\treturn null;\n\t\t}\n\t\tMainProxy.sendPacketToPlayer(module.getCPipePacket(), player);\n\t\tDummyContainer dummy = new DummyContainer(player.inventory, module.getDummyInventory());\n\t\tdummy.addNormalSlotsForPlayerInventory(18, 97);\n\t\t//Input slots\n\t\tfor (int l = 0; l < 9; l++) {\n\t\t\tdummy.addFuzzyDummySlot(l, 18 + l * 18, 18, module.fuzzyCraftingFlagArray[l]);\n\t\t}\n\n\t\t//Output slot\n\t\tdummy.addFuzzyDummySlot(9, 90, 64, module.outputFuzzyFlags);\n\n\t\tfor (int i = 0; i < liquidCrafter; i++) {\n\t\t\tint liquidLeft = -(i * 40) - 40;\n\t\t\tdummy.addFluidSlot(i, module.getFluidInventory(), liquidLeft + 13, 42);\n\t\t}\n\n\t\tif (hasByproductExtractor) {\n\t\t\tdummy.addDummySlot(10, 197, 104);\n\t\t}\n\n\t\tfor (int Y = 0; Y < cleanupSize; Y++) {\n\t\t\tfor (int X = 0; X < 3; X++) {\n\t\t\t\tdummy.addDummySlot(Y * 3 + X, module.getCleanupInventory(), X * 18 - 57, Y * 18 + 13);\n\t\t\t}\n\t\t}\n\n\t\treturn dummy;\n\t}\n\n\t@Override\n\tpublic GuiProvider template() {\n\t\treturn new CraftingModuleSlot(getId());\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\tsuper.writeData(output);\n\t\toutput.writeBoolean(isAdvancedSat);\n\t\toutput.writeInt(liquidCrafter);\n\t\toutput.writeIntArray(amount);\n\t\toutput.writeBoolean(hasByproductExtractor);\n\t\toutput.writeBoolean(isFuzzy);\n\t\toutput.writeInt(cleanupSize);\n\t\toutput.writeBoolean(cleanupExclude);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tsuper.readData(input);\n\t\tisAdvancedSat = input.readBoolean();\n\t\tliquidCrafter = input.readInt();\n\t\tamount = input.readIntArray();\n\t\thasByproductExtractor = input.readBoolean();\n\t\tisFuzzy = input.readBoolean();\n\t\tcleanupSize = input.readInt();\n\t\tcleanupExclude = input.readBoolean();\n\t}\n}",
    "patch": "@@ -1,7 +1,5 @@\n package logisticspipes.network.guis.module.inpipe;\n \n-import java.io.IOException;\n-\n import net.minecraft.entity.player.EntityPlayer;\n \n import lombok.Getter;\n@@ -101,7 +99,7 @@ public GuiProvider template() {\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\tsuper.writeData(output);\n \t\toutput.writeBoolean(isAdvancedSat);\n \t\toutput.writeInt(liquidCrafter);\n@@ -113,7 +111,7 @@ public void writeData(LPDataOutput output) throws IOException {\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tsuper.readData(input);\n \t\tisAdvancedSat = input.readBoolean();\n \t\tliquidCrafter = input.readInt();",
    "function_modified_lines": {
      "added": [
        "\tpublic void writeData(LPDataOutput output) {\n",
        "\tpublic void readData(LPDataInput input) {\n"
      ],
      "deleted": [
        "\tpublic void writeData(LPDataOutput output) throws IOException {\n",
        "\tpublic void readData(LPDataInput input) throws IOException {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12786
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate byte[] content;\n\n\tpublic BufferTransfer(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new BufferTransfer(getId());\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tif (MainProxy.isClient(player.worldObj)) {\n\t\t\tSimpleServiceLocator.clientBufferHandler.handlePacket(content);\n\t\t} else {\n\t\t\tSimpleServiceLocator.serverBufferHandler.handlePacket(content, player);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tcontent = input.readByteArray();\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\toutput.writeByteArray(content);\n\t}\n}",
    "code_after_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate byte[] content;\n\n\tpublic BufferTransfer(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new BufferTransfer(getId());\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tif (MainProxy.isClient(player.worldObj)) {\n\t\t\tSimpleServiceLocator.clientBufferHandler.handlePacket(content);\n\t\t} else {\n\t\t\tSimpleServiceLocator.serverBufferHandler.handlePacket(content, player);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tcontent = input.readByteArray();\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\toutput.writeByteArray(content);\n\t}\n}",
    "patch": "@@ -1,7 +1,5 @@\n package logisticspipes.network.packets;\n \n-import java.io.IOException;\n-\n import net.minecraft.entity.player.EntityPlayer;\n \n import lombok.Getter;\n@@ -38,12 +36,12 @@ public void processPacket(EntityPlayer player) {\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tcontent = input.readByteArray();\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\toutput.writeByteArray(content);\n \t}\n }",
    "function_modified_lines": {
      "added": [
        "\tpublic void readData(LPDataInput input) {\n",
        "\tpublic void writeData(LPDataOutput output) {\n"
      ],
      "deleted": [
        "\tpublic void readData(LPDataInput input) throws IOException {\n",
        "\tpublic void writeData(LPDataOutput output) throws IOException {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12787
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "{\n\n\tpublic PlayerListRequest(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new PlayerListRequest(getId());\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tStream<?> allPlayers = Arrays.stream(DimensionManager.getWorlds()).map(worldServer -> worldServer.playerEntities).flatMap(Collection::stream);\n\t\tStream<EntityPlayer> allPlayerEntities = allPlayers.filter(o -> o instanceof EntityPlayer).map(o -> (EntityPlayer) o);\n\t\tMainProxy.sendPacketToPlayer(PacketHandler.getPacket(PlayerList.class)\n\t\t\t\t.setStringList(allPlayerEntities.map(entityPlayer -> entityPlayer.getGameProfile().getName()).collect(Collectors.toList())), player);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {}\n}",
    "code_after_change": "{\n\n\tpublic PlayerListRequest(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new PlayerListRequest(getId());\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tStream<?> allPlayers = Arrays.stream(DimensionManager.getWorlds()).map(worldServer -> worldServer.playerEntities).flatMap(Collection::stream);\n\t\tStream<EntityPlayer> allPlayerEntities = allPlayers.filter(o -> o instanceof EntityPlayer).map(o -> (EntityPlayer) o);\n\t\tMainProxy.sendPacketToPlayer(PacketHandler.getPacket(PlayerList.class)\n\t\t\t\t.setStringList(allPlayerEntities.map(entityPlayer -> entityPlayer.getGameProfile().getName()).collect(Collectors.toList())), player);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {}\n}",
    "patch": "@@ -1,6 +1,5 @@\n package logisticspipes.network.packets;\n \n-import java.io.IOException;\n import java.util.Arrays;\n import java.util.Collection;\n import java.util.stream.Collectors;\n@@ -35,8 +34,8 @@ public void processPacket(EntityPlayer player) {\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {}\n+\tpublic void readData(LPDataInput input) {}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {}\n+\tpublic void writeData(LPDataOutput output) {}\n }",
    "function_modified_lines": {
      "added": [
        "\tpublic void readData(LPDataInput input) {}\n",
        "\tpublic void writeData(LPDataOutput output) {}\n"
      ],
      "deleted": [
        "\tpublic void readData(LPDataInput input) throws IOException {}\n",
        "\tpublic void writeData(LPDataOutput output) throws IOException {}\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12788
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate ItemIdentifier ident;\n\n\t@Getter\n\t@Setter\n\tprivate String name;\n\n\tpublic UpdateName(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new UpdateName(getId());\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tif (MainProxy.isClient(player.worldObj)) {\n\t\t\tMainProxy.sendPacketToServer(PacketHandler.getPacket(UpdateName.class).setIdent(getIdent()).setName(getIdent().getFriendlyName()));\n\t\t} else {\n\t\t\tMainProxy.proxy.updateNames(getIdent(), getName());\n\t\t}\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tident = input.readItemIdentifierStack().getItem();\n\t\tname = input.readUTF();\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\toutput.writeItemIdentifierStack(ident.makeStack(0));\n\t\toutput.writeUTF(name);\n\t}\n\n\t@Override\n\tpublic boolean isCompressable() {\n\t\treturn true;\n\t}\n}",
    "code_after_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate ItemIdentifier ident;\n\n\t@Getter\n\t@Setter\n\tprivate String name;\n\n\tpublic UpdateName(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new UpdateName(getId());\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tif (MainProxy.isClient(player.worldObj)) {\n\t\t\tMainProxy.sendPacketToServer(PacketHandler.getPacket(UpdateName.class).setIdent(getIdent()).setName(getIdent().getFriendlyName()));\n\t\t} else {\n\t\t\tMainProxy.proxy.updateNames(getIdent(), getName());\n\t\t}\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tident = input.readItemIdentifierStack().getItem();\n\t\tname = input.readUTF();\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\toutput.writeItemIdentifierStack(ident.makeStack(0));\n\t\toutput.writeUTF(name);\n\t}\n\n\t@Override\n\tpublic boolean isCompressable() {\n\t\treturn true;\n\t}\n}",
    "patch": "@@ -1,7 +1,5 @@\n package logisticspipes.network.packets;\n \n-import java.io.IOException;\n-\n import net.minecraft.entity.player.EntityPlayer;\n \n import lombok.Getter;\n@@ -43,13 +41,13 @@ public void processPacket(EntityPlayer player) {\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tident = input.readItemIdentifierStack().getItem();\n \t\tname = input.readUTF();\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\toutput.writeItemIdentifierStack(ident.makeStack(0));\n \t\toutput.writeUTF(name);\n \t}",
    "function_modified_lines": {
      "added": [
        "\tpublic void readData(LPDataInput input) {\n",
        "\tpublic void writeData(LPDataOutput output) {\n"
      ],
      "deleted": [
        "\tpublic void readData(LPDataInput input) throws IOException {\n",
        "\tpublic void writeData(LPDataOutput output) throws IOException {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12789
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate ItemIdentifier item;\n\n\tpublic AddItemToTrackPacket(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tLogisticsStatisticsTileEntity tile = this.getTile(player.getEntityWorld(), LogisticsStatisticsTileEntity.class);\n\t\tboolean found = false;\n\t\tfor (TrackingTask task : tile.tasks) {\n\t\t\tif (task.item.equals(item)) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found) {\n\t\t\tTrackingTask task = new TrackingTask();\n\t\t\ttask.item = item;\n\t\t\ttile.tasks.add(task);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\tsuper.writeData(output);\n\t\toutput.writeItemIdentifier(item);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tsuper.readData(input);\n\t\titem = input.readItemIdentifier();\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new AddItemToTrackPacket(getId());\n\t}\n}",
    "code_after_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate ItemIdentifier item;\n\n\tpublic AddItemToTrackPacket(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tLogisticsStatisticsTileEntity tile = this.getTile(player.getEntityWorld(), LogisticsStatisticsTileEntity.class);\n\t\tboolean found = false;\n\t\tfor (TrackingTask task : tile.tasks) {\n\t\t\tif (task.item.equals(item)) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found) {\n\t\t\tTrackingTask task = new TrackingTask();\n\t\t\ttask.item = item;\n\t\t\ttile.tasks.add(task);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\tsuper.writeData(output);\n\t\toutput.writeItemIdentifier(item);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tsuper.readData(input);\n\t\titem = input.readItemIdentifier();\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new AddItemToTrackPacket(getId());\n\t}\n}",
    "patch": "@@ -1,7 +1,5 @@\n package logisticspipes.network.packets.block;\n \n-import java.io.IOException;\n-\n import net.minecraft.entity.player.EntityPlayer;\n \n import lombok.Getter;\n@@ -43,13 +41,13 @@ public void processPacket(EntityPlayer player) {\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\tsuper.writeData(output);\n \t\toutput.writeItemIdentifier(item);\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tsuper.readData(input);\n \t\titem = input.readItemIdentifier();\n \t}",
    "function_modified_lines": {
      "added": [
        "\tpublic void writeData(LPDataOutput output) {\n",
        "\tpublic void readData(LPDataInput input) {\n"
      ],
      "deleted": [
        "\tpublic void writeData(LPDataOutput output) throws IOException {\n",
        "\tpublic void readData(LPDataInput input) throws IOException {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12790
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "{\n\n\tpublic CraftingCycleRecipe(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Getter\n\t@Setter\n\tprivate boolean down;\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tTileEntity table = this.getTile(player.getEntityWorld(), TileEntity.class);\n\t\tif (table instanceof LogisticsCraftingTableTileEntity) {\n\t\t\t((LogisticsCraftingTableTileEntity) table).cycleRecipe(down);\n\t\t} else if (table instanceof LogisticsTileGenericPipe && ((LogisticsTileGenericPipe) table).pipe instanceof PipeBlockRequestTable) {\n\t\t\t((PipeBlockRequestTable) ((LogisticsTileGenericPipe) table).pipe).cycleRecipe(down);\n\t\t}\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new CraftingCycleRecipe(getId());\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\tsuper.writeData(output);\n\t\toutput.writeBoolean(down);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tsuper.readData(input);\n\t\tdown = input.readBoolean();\n\t}\n}",
    "code_after_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate boolean down;\n\n\tpublic CraftingCycleRecipe(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tTileEntity table = this.getTile(player.getEntityWorld(), TileEntity.class);\n\t\tif (table instanceof LogisticsCraftingTableTileEntity) {\n\t\t\t((LogisticsCraftingTableTileEntity) table).cycleRecipe(down);\n\t\t} else if (table instanceof LogisticsTileGenericPipe && ((LogisticsTileGenericPipe) table).pipe instanceof PipeBlockRequestTable) {\n\t\t\t((PipeBlockRequestTable) ((LogisticsTileGenericPipe) table).pipe).cycleRecipe(down);\n\t\t}\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new CraftingCycleRecipe(getId());\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\tsuper.writeData(output);\n\t\toutput.writeBoolean(down);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tsuper.readData(input);\n\t\tdown = input.readBoolean();\n\t}\n}",
    "patch": "@@ -1,7 +1,5 @@\n package logisticspipes.network.packets.block;\n \n-import java.io.IOException;\n-\n import net.minecraft.entity.player.EntityPlayer;\n import net.minecraft.tileentity.TileEntity;\n \n@@ -18,14 +16,14 @@\n \n public class CraftingCycleRecipe extends CoordinatesPacket {\n \n-\tpublic CraftingCycleRecipe(int id) {\n-\t\tsuper(id);\n-\t}\n-\n \t@Getter\n \t@Setter\n \tprivate boolean down;\n \n+\tpublic CraftingCycleRecipe(int id) {\n+\t\tsuper(id);\n+\t}\n+\n \t@Override\n \tpublic void processPacket(EntityPlayer player) {\n \t\tTileEntity table = this.getTile(player.getEntityWorld(), TileEntity.class);\n@@ -42,13 +40,13 @@ public ModernPacket template() {\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\tsuper.writeData(output);\n \t\toutput.writeBoolean(down);\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tsuper.readData(input);\n \t\tdown = input.readBoolean();\n \t}",
    "function_modified_lines": {
      "added": [
        "\tpublic CraftingCycleRecipe(int id) {\n",
        "\t\tsuper(id);\n",
        "\t}\n",
        "\n"
      ],
      "deleted": [
        "\tpublic CraftingCycleRecipe(int id) {\n",
        "\t\tsuper(id);\n",
        "\t}\n",
        "\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12791
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "{\n\n\tpublic CraftingCycleRecipe(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Getter\n\t@Setter\n\tprivate boolean down;\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tTileEntity table = this.getTile(player.getEntityWorld(), TileEntity.class);\n\t\tif (table instanceof LogisticsCraftingTableTileEntity) {\n\t\t\t((LogisticsCraftingTableTileEntity) table).cycleRecipe(down);\n\t\t} else if (table instanceof LogisticsTileGenericPipe && ((LogisticsTileGenericPipe) table).pipe instanceof PipeBlockRequestTable) {\n\t\t\t((PipeBlockRequestTable) ((LogisticsTileGenericPipe) table).pipe).cycleRecipe(down);\n\t\t}\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new CraftingCycleRecipe(getId());\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\tsuper.writeData(output);\n\t\toutput.writeBoolean(down);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tsuper.readData(input);\n\t\tdown = input.readBoolean();\n\t}\n}",
    "code_after_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate boolean down;\n\n\tpublic CraftingCycleRecipe(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tTileEntity table = this.getTile(player.getEntityWorld(), TileEntity.class);\n\t\tif (table instanceof LogisticsCraftingTableTileEntity) {\n\t\t\t((LogisticsCraftingTableTileEntity) table).cycleRecipe(down);\n\t\t} else if (table instanceof LogisticsTileGenericPipe && ((LogisticsTileGenericPipe) table).pipe instanceof PipeBlockRequestTable) {\n\t\t\t((PipeBlockRequestTable) ((LogisticsTileGenericPipe) table).pipe).cycleRecipe(down);\n\t\t}\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new CraftingCycleRecipe(getId());\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\tsuper.writeData(output);\n\t\toutput.writeBoolean(down);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tsuper.readData(input);\n\t\tdown = input.readBoolean();\n\t}\n}",
    "patch": "@@ -1,7 +1,5 @@\n package logisticspipes.network.packets.block;\n \n-import java.io.IOException;\n-\n import net.minecraft.entity.player.EntityPlayer;\n import net.minecraft.tileentity.TileEntity;\n \n@@ -18,14 +16,14 @@\n \n public class CraftingCycleRecipe extends CoordinatesPacket {\n \n-\tpublic CraftingCycleRecipe(int id) {\n-\t\tsuper(id);\n-\t}\n-\n \t@Getter\n \t@Setter\n \tprivate boolean down;\n \n+\tpublic CraftingCycleRecipe(int id) {\n+\t\tsuper(id);\n+\t}\n+\n \t@Override\n \tpublic void processPacket(EntityPlayer player) {\n \t\tTileEntity table = this.getTile(player.getEntityWorld(), TileEntity.class);\n@@ -42,13 +40,13 @@ public ModernPacket template() {\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\tsuper.writeData(output);\n \t\toutput.writeBoolean(down);\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tsuper.readData(input);\n \t\tdown = input.readBoolean();\n \t}",
    "function_modified_lines": {
      "added": [
        "\tpublic void writeData(LPDataOutput output) {\n",
        "\tpublic void readData(LPDataInput input) {\n"
      ],
      "deleted": [
        "\tpublic void writeData(LPDataOutput output) throws IOException {\n",
        "\tpublic void readData(LPDataInput input) throws IOException {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12792
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "{\n\n\tpublic CraftingSetType(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Getter\n\t@Setter\n\tprivate ItemIdentifier targetType;\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tTileEntity table = this.getTile(player.getEntityWorld(), TileEntity.class);\n\t\tif (table instanceof LogisticsCraftingTableTileEntity) {\n\t\t\t((LogisticsCraftingTableTileEntity) table).targetType = targetType;\n\t\t\t((LogisticsCraftingTableTileEntity) table).cacheRecipe();\n\t\t} else if (table instanceof LogisticsTileGenericPipe && ((LogisticsTileGenericPipe) table).pipe instanceof PipeBlockRequestTable) {\n\t\t\t((PipeBlockRequestTable) ((LogisticsTileGenericPipe) table).pipe).targetType = targetType;\n\t\t\t((PipeBlockRequestTable) ((LogisticsTileGenericPipe) table).pipe).cacheRecipe();\n\t\t}\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new CraftingSetType(getId());\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\tsuper.writeData(output);\n\t\toutput.writeItemIdentifier(targetType);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tsuper.readData(input);\n\t\ttargetType = input.readItemIdentifier();\n\t}\n}",
    "code_after_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate ItemIdentifier targetType;\n\n\tpublic CraftingSetType(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tTileEntity table = this.getTile(player.getEntityWorld(), TileEntity.class);\n\t\tif (table instanceof LogisticsCraftingTableTileEntity) {\n\t\t\t((LogisticsCraftingTableTileEntity) table).targetType = targetType;\n\t\t\t((LogisticsCraftingTableTileEntity) table).cacheRecipe();\n\t\t} else if (table instanceof LogisticsTileGenericPipe && ((LogisticsTileGenericPipe) table).pipe instanceof PipeBlockRequestTable) {\n\t\t\t((PipeBlockRequestTable) ((LogisticsTileGenericPipe) table).pipe).targetType = targetType;\n\t\t\t((PipeBlockRequestTable) ((LogisticsTileGenericPipe) table).pipe).cacheRecipe();\n\t\t}\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new CraftingSetType(getId());\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\tsuper.writeData(output);\n\t\toutput.writeItemIdentifier(targetType);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tsuper.readData(input);\n\t\ttargetType = input.readItemIdentifier();\n\t}\n}",
    "patch": "@@ -1,7 +1,5 @@\n package logisticspipes.network.packets.block;\n \n-import java.io.IOException;\n-\n import net.minecraft.entity.player.EntityPlayer;\n import net.minecraft.tileentity.TileEntity;\n \n@@ -19,14 +17,14 @@\n \n public class CraftingSetType extends CoordinatesPacket {\n \n-\tpublic CraftingSetType(int id) {\n-\t\tsuper(id);\n-\t}\n-\n \t@Getter\n \t@Setter\n \tprivate ItemIdentifier targetType;\n \n+\tpublic CraftingSetType(int id) {\n+\t\tsuper(id);\n+\t}\n+\n \t@Override\n \tpublic void processPacket(EntityPlayer player) {\n \t\tTileEntity table = this.getTile(player.getEntityWorld(), TileEntity.class);\n@@ -45,13 +43,13 @@ public ModernPacket template() {\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\tsuper.writeData(output);\n \t\toutput.writeItemIdentifier(targetType);\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tsuper.readData(input);\n \t\ttargetType = input.readItemIdentifier();\n \t}",
    "function_modified_lines": {
      "added": [
        "\tpublic CraftingSetType(int id) {\n",
        "\t\tsuper(id);\n",
        "\t}\n",
        "\n"
      ],
      "deleted": [
        "\tpublic CraftingSetType(int id) {\n",
        "\t\tsuper(id);\n",
        "\t}\n",
        "\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12793
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "{\n\n\tpublic CraftingSetType(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Getter\n\t@Setter\n\tprivate ItemIdentifier targetType;\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tTileEntity table = this.getTile(player.getEntityWorld(), TileEntity.class);\n\t\tif (table instanceof LogisticsCraftingTableTileEntity) {\n\t\t\t((LogisticsCraftingTableTileEntity) table).targetType = targetType;\n\t\t\t((LogisticsCraftingTableTileEntity) table).cacheRecipe();\n\t\t} else if (table instanceof LogisticsTileGenericPipe && ((LogisticsTileGenericPipe) table).pipe instanceof PipeBlockRequestTable) {\n\t\t\t((PipeBlockRequestTable) ((LogisticsTileGenericPipe) table).pipe).targetType = targetType;\n\t\t\t((PipeBlockRequestTable) ((LogisticsTileGenericPipe) table).pipe).cacheRecipe();\n\t\t}\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new CraftingSetType(getId());\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\tsuper.writeData(output);\n\t\toutput.writeItemIdentifier(targetType);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tsuper.readData(input);\n\t\ttargetType = input.readItemIdentifier();\n\t}\n}",
    "code_after_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate ItemIdentifier targetType;\n\n\tpublic CraftingSetType(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tTileEntity table = this.getTile(player.getEntityWorld(), TileEntity.class);\n\t\tif (table instanceof LogisticsCraftingTableTileEntity) {\n\t\t\t((LogisticsCraftingTableTileEntity) table).targetType = targetType;\n\t\t\t((LogisticsCraftingTableTileEntity) table).cacheRecipe();\n\t\t} else if (table instanceof LogisticsTileGenericPipe && ((LogisticsTileGenericPipe) table).pipe instanceof PipeBlockRequestTable) {\n\t\t\t((PipeBlockRequestTable) ((LogisticsTileGenericPipe) table).pipe).targetType = targetType;\n\t\t\t((PipeBlockRequestTable) ((LogisticsTileGenericPipe) table).pipe).cacheRecipe();\n\t\t}\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new CraftingSetType(getId());\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\tsuper.writeData(output);\n\t\toutput.writeItemIdentifier(targetType);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tsuper.readData(input);\n\t\ttargetType = input.readItemIdentifier();\n\t}\n}",
    "patch": "@@ -1,7 +1,5 @@\n package logisticspipes.network.packets.block;\n \n-import java.io.IOException;\n-\n import net.minecraft.entity.player.EntityPlayer;\n import net.minecraft.tileentity.TileEntity;\n \n@@ -19,14 +17,14 @@\n \n public class CraftingSetType extends CoordinatesPacket {\n \n-\tpublic CraftingSetType(int id) {\n-\t\tsuper(id);\n-\t}\n-\n \t@Getter\n \t@Setter\n \tprivate ItemIdentifier targetType;\n \n+\tpublic CraftingSetType(int id) {\n+\t\tsuper(id);\n+\t}\n+\n \t@Override\n \tpublic void processPacket(EntityPlayer player) {\n \t\tTileEntity table = this.getTile(player.getEntityWorld(), TileEntity.class);\n@@ -45,13 +43,13 @@ public ModernPacket template() {\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\tsuper.writeData(output);\n \t\toutput.writeItemIdentifier(targetType);\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tsuper.readData(input);\n \t\ttargetType = input.readItemIdentifier();\n \t}",
    "function_modified_lines": {
      "added": [
        "\tpublic void writeData(LPDataOutput output) {\n",
        "\tpublic void readData(LPDataInput input) {\n"
      ],
      "deleted": [
        "\tpublic void writeData(LPDataOutput output) throws IOException {\n",
        "\tpublic void readData(LPDataInput input) throws IOException {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12794
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "{\n\n\tprivate Double aDouble;\n\n\tpublic PowerProviderLevel(int id) {\n\t\tsuper(id);\n\t}\n\n\tpublic double getDouble() {\n\t\treturn aDouble;\n\t}\n\n\tpublic PowerProviderLevel setDouble(double d) {\n\t\taDouble = d;\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tsuper.readData(input);\n\t\tsetDouble(input.readDouble());\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\tsuper.writeData(output);\n\t\toutput.writeDouble(getDouble());\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new PowerProviderLevel(getId());\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tLogisticsPowerProviderTileEntity tile = this.getTile(player.worldObj, LogisticsPowerProviderTileEntity.class);\n\t\tif (tile != null) {\n\t\t\ttile.handlePowerPacket(getDouble());\n\t\t}\n\t}\n}",
    "code_after_change": "{\n\n\tprivate Double aDouble;\n\n\tpublic PowerProviderLevel(int id) {\n\t\tsuper(id);\n\t}\n\n\tpublic double getDouble() {\n\t\treturn aDouble;\n\t}\n\n\tpublic PowerProviderLevel setDouble(double d) {\n\t\taDouble = d;\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tsuper.readData(input);\n\t\tsetDouble(input.readDouble());\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\tsuper.writeData(output);\n\t\toutput.writeDouble(getDouble());\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new PowerProviderLevel(getId());\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tLogisticsPowerProviderTileEntity tile = this.getTile(player.worldObj, LogisticsPowerProviderTileEntity.class);\n\t\tif (tile != null) {\n\t\t\ttile.handlePowerPacket(getDouble());\n\t\t}\n\t}\n}",
    "patch": "@@ -1,7 +1,5 @@\n package logisticspipes.network.packets.block;\n \n-import java.io.IOException;\n-\n import net.minecraft.entity.player.EntityPlayer;\n \n import logisticspipes.blocks.powertile.LogisticsPowerProviderTileEntity;\n@@ -28,13 +26,13 @@ public PowerProviderLevel setDouble(double d) {\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tsuper.readData(input);\n \t\tsetDouble(input.readDouble());\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\tsuper.writeData(output);\n \t\toutput.writeDouble(getDouble());\n \t}",
    "function_modified_lines": {
      "added": [
        "\tpublic void readData(LPDataInput input) {\n",
        "\tpublic void writeData(LPDataOutput output) {\n"
      ],
      "deleted": [
        "\tpublic void readData(LPDataInput input) throws IOException {\n",
        "\tpublic void writeData(LPDataOutput output) throws IOException {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12795
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "{\n\n\t@Setter\n\t@Getter\n\tprivate ItemIdentifier item;\n\n\tpublic RemoveAmoundTask(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tLogisticsStatisticsTileEntity tile = this.getTile(player.getEntityWorld(), LogisticsStatisticsTileEntity.class);\n\t\tIterator<TrackingTask> iter = tile.tasks.iterator();\n\t\twhile (iter.hasNext()) {\n\t\t\tTrackingTask task = iter.next();\n\t\t\tif (task.item == item) {\n\t\t\t\titer.remove();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\tsuper.writeData(output);\n\t\toutput.writeItemIdentifier(item);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tsuper.readData(input);\n\t\titem = input.readItemIdentifier();\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new RemoveAmoundTask(getId());\n\t}\n}",
    "code_after_change": "{\n\n\t@Setter\n\t@Getter\n\tprivate ItemIdentifier item;\n\n\tpublic RemoveAmoundTask(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tLogisticsStatisticsTileEntity tile = this.getTile(player.getEntityWorld(), LogisticsStatisticsTileEntity.class);\n\t\tIterator<TrackingTask> iter = tile.tasks.iterator();\n\t\twhile (iter.hasNext()) {\n\t\t\tTrackingTask task = iter.next();\n\t\t\tif (task.item == item) {\n\t\t\t\titer.remove();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\tsuper.writeData(output);\n\t\toutput.writeItemIdentifier(item);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tsuper.readData(input);\n\t\titem = input.readItemIdentifier();\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new RemoveAmoundTask(getId());\n\t}\n}",
    "patch": "@@ -1,6 +1,5 @@\n package logisticspipes.network.packets.block;\n \n-import java.io.IOException;\n import java.util.Iterator;\n \n import net.minecraft.entity.player.EntityPlayer;\n@@ -40,13 +39,13 @@ public void processPacket(EntityPlayer player) {\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\tsuper.writeData(output);\n \t\toutput.writeItemIdentifier(item);\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tsuper.readData(input);\n \t\titem = input.readItemIdentifier();\n \t}",
    "function_modified_lines": {
      "added": [
        "\tpublic void writeData(LPDataOutput output) {\n",
        "\tpublic void readData(LPDataInput input) {\n"
      ],
      "deleted": [
        "\tpublic void writeData(LPDataOutput output) throws IOException {\n",
        "\tpublic void readData(LPDataInput input) throws IOException {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12796
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate List<ItemIdentifierStack> identList;\n\n\tpublic RunningCraftingTasks(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tif (FMLClientHandler.instance().getClient().currentScreen instanceof GuiStatistics) {\n\t\t\t((GuiStatistics) FMLClientHandler.instance().getClient().currentScreen).handlePacket_2(getIdentList());\n\t\t}\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\toutput.writeCollection(identList, LPDataOutput::writeItemIdentifierStack);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tidentList = input.readArrayList(LPDataInput::readItemIdentifierStack);\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new RunningCraftingTasks(getId());\n\t}\n}",
    "code_after_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate List<ItemIdentifierStack> identList;\n\n\tpublic RunningCraftingTasks(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tif (FMLClientHandler.instance().getClient().currentScreen instanceof GuiStatistics) {\n\t\t\t((GuiStatistics) FMLClientHandler.instance().getClient().currentScreen).handlePacket_2(getIdentList());\n\t\t}\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\toutput.writeCollection(identList, LPDataOutput::writeItemIdentifierStack);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tidentList = input.readArrayList(LPDataInput::readItemIdentifierStack);\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new RunningCraftingTasks(getId());\n\t}\n}",
    "patch": "@@ -1,6 +1,5 @@\n package logisticspipes.network.packets.block;\n \n-import java.io.IOException;\n import java.util.List;\n \n import net.minecraft.entity.player.EntityPlayer;\n@@ -33,12 +32,12 @@ public void processPacket(EntityPlayer player) {\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\toutput.writeCollection(identList, LPDataOutput::writeItemIdentifierStack);\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tidentList = input.readArrayList(LPDataInput::readItemIdentifierStack);\n \t}\n ",
    "function_modified_lines": {
      "added": [
        "\tpublic void writeData(LPDataOutput output) {\n",
        "\tpublic void readData(LPDataInput input) {\n"
      ],
      "deleted": [
        "\tpublic void writeData(LPDataOutput output) throws IOException {\n",
        "\tpublic void readData(LPDataInput input) throws IOException {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12797
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate UUID uuid;\n\n\tpublic SecurityStationId(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new SecurityStationId(getId());\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tLogisticsSecurityTileEntity tile = this.getTile(player.worldObj, LogisticsSecurityTileEntity.class);\n\t\tif (tile != null) {\n\t\t\ttile.setClientUUID(getUuid());\n\t\t}\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\tsuper.writeData(output);\n\t\toutput.writeLong(uuid.getMostSignificantBits());\n\t\toutput.writeLong(uuid.getLeastSignificantBits());\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tsuper.readData(input);\n\t\tuuid = new UUID(input.readLong(), input.readLong());\n\t}\n}",
    "code_after_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate UUID uuid;\n\n\tpublic SecurityStationId(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new SecurityStationId(getId());\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tLogisticsSecurityTileEntity tile = this.getTile(player.worldObj, LogisticsSecurityTileEntity.class);\n\t\tif (tile != null) {\n\t\t\ttile.setClientUUID(getUuid());\n\t\t}\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\tsuper.writeData(output);\n\t\toutput.writeLong(uuid.getMostSignificantBits());\n\t\toutput.writeLong(uuid.getLeastSignificantBits());\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tsuper.readData(input);\n\t\tuuid = new UUID(input.readLong(), input.readLong());\n\t}\n}",
    "patch": "@@ -1,6 +1,5 @@\n package logisticspipes.network.packets.block;\n \n-import java.io.IOException;\n import java.util.UUID;\n \n import net.minecraft.entity.player.EntityPlayer;\n@@ -38,14 +37,14 @@ public void processPacket(EntityPlayer player) {\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\tsuper.writeData(output);\n \t\toutput.writeLong(uuid.getMostSignificantBits());\n \t\toutput.writeLong(uuid.getLeastSignificantBits());\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tsuper.readData(input);\n \t\tuuid = new UUID(input.readLong(), input.readLong());\n \t}",
    "function_modified_lines": {
      "added": [
        "\tpublic void writeData(LPDataOutput output) {\n",
        "\tpublic void readData(LPDataInput input) {\n"
      ],
      "deleted": [
        "\tpublic void writeData(LPDataOutput output) throws IOException {\n",
        "\tpublic void readData(LPDataInput input) throws IOException {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12798
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate int buttonID;\n\n\tpublic ChassisGUI(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\toutput.writeInt(buttonID);\n\t\tsuper.writeData(output);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tbuttonID = input.readInt();\n\t\tsuper.readData(input);\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tfinal LogisticsTileGenericPipe pipe = getPipe(player.worldObj);\n\t\tif (pipe == null || !(pipe.pipe instanceof PipeLogisticsChassi)) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal PipeLogisticsChassi chassisPipe = (PipeLogisticsChassi) pipe.pipe;\n\n\t\tif (!(chassisPipe.getLogisticsModule().getSubModule(getButtonID()) instanceof LogisticsGuiModule)) {\n\t\t\treturn;\n\t\t}\n\n\t\t((LogisticsGuiModule) chassisPipe.getLogisticsModule().getSubModule(getButtonID())).getPipeGuiProviderForModule().setPosX(getPosX()).setPosY(getPosY())\n\t\t\t\t.setPosZ(getPosZ()).open(player);\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new ChassisGUI(getId());\n\t}\n\n}",
    "code_after_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate int buttonID;\n\n\tpublic ChassisGUI(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\toutput.writeInt(buttonID);\n\t\tsuper.writeData(output);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tbuttonID = input.readInt();\n\t\tsuper.readData(input);\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tfinal LogisticsTileGenericPipe pipe = getPipe(player.worldObj);\n\t\tif (pipe == null || !(pipe.pipe instanceof PipeLogisticsChassi)) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal PipeLogisticsChassi chassisPipe = (PipeLogisticsChassi) pipe.pipe;\n\n\t\tif (!(chassisPipe.getLogisticsModule().getSubModule(getButtonID()) instanceof LogisticsGuiModule)) {\n\t\t\treturn;\n\t\t}\n\n\t\t((LogisticsGuiModule) chassisPipe.getLogisticsModule().getSubModule(getButtonID())).getPipeGuiProviderForModule().setPosX(getPosX()).setPosY(getPosY())\n\t\t\t\t.setPosZ(getPosZ()).open(player);\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new ChassisGUI(getId());\n\t}\n\n}",
    "patch": "@@ -1,7 +1,5 @@\n package logisticspipes.network.packets.chassis;\n \n-import java.io.IOException;\n-\n import net.minecraft.entity.player.EntityPlayer;\n \n import lombok.Getter;\n@@ -26,13 +24,13 @@ public ChassisGUI(int id) {\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\toutput.writeInt(buttonID);\n \t\tsuper.writeData(output);\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tbuttonID = input.readInt();\n \t\tsuper.readData(input);\n \t}",
    "function_modified_lines": {
      "added": [
        "\tpublic void writeData(LPDataOutput output) {\n",
        "\tpublic void readData(LPDataInput input) {\n"
      ],
      "deleted": [
        "\tpublic void writeData(LPDataOutput output) throws IOException {\n",
        "\tpublic void readData(LPDataInput input) throws IOException {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12799
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate int windowID;\n\n\t@Getter\n\t@Setter\n\tprivate String line;\n\n\tpublic SendNewLogLine(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\twindowID = input.readInt();\n\t\tline = input.readUTF();\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tLogWindow.getWindow(windowID).newLine(line);\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\toutput.writeInt(windowID);\n\t\toutput.writeUTF(line);\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new SendNewLogLine(getId());\n\t}\n\n\t@Override\n\tpublic boolean isCompressable() {\n\t\treturn true;\n\t}\n}",
    "code_after_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate int windowID;\n\n\t@Getter\n\t@Setter\n\tprivate String line;\n\n\tpublic SendNewLogLine(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\twindowID = input.readInt();\n\t\tline = input.readUTF();\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tLogWindow.getWindow(windowID).newLine(line);\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\toutput.writeInt(windowID);\n\t\toutput.writeUTF(line);\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new SendNewLogLine(getId());\n\t}\n\n\t@Override\n\tpublic boolean isCompressable() {\n\t\treturn true;\n\t}\n}",
    "patch": "@@ -1,7 +1,5 @@\n package logisticspipes.network.packets.debug;\n \n-import java.io.IOException;\n-\n import net.minecraft.entity.player.EntityPlayer;\n \n import lombok.Getter;\n@@ -27,7 +25,7 @@ public SendNewLogLine(int id) {\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\twindowID = input.readInt();\n \t\tline = input.readUTF();\n \t}\n@@ -38,7 +36,7 @@ public void processPacket(EntityPlayer player) {\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\toutput.writeInt(windowID);\n \t\toutput.writeUTF(line);\n \t}",
    "function_modified_lines": {
      "added": [
        "\tpublic void readData(LPDataInput input) {\n",
        "\tpublic void writeData(LPDataOutput output) {\n"
      ],
      "deleted": [
        "\tpublic void readData(LPDataInput input) throws IOException {\n",
        "\tpublic void writeData(LPDataOutput output) throws IOException {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12800
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate int windowID;\n\n\t@Getter\n\t@Setter\n\tprivate String title;\n\n\tpublic SendNewLogWindow(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\twindowID = input.readInt();\n\t\ttitle = input.readUTF();\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tLogWindow.getWindow(windowID).setTitle(title);\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\toutput.writeInt(windowID);\n\t\toutput.writeUTF(title);\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new SendNewLogWindow(getId());\n\t}\n\n\t@Override\n\tpublic boolean isCompressable() {\n\t\treturn true;\n\t}\n}",
    "code_after_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate int windowID;\n\n\t@Getter\n\t@Setter\n\tprivate String title;\n\n\tpublic SendNewLogWindow(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\twindowID = input.readInt();\n\t\ttitle = input.readUTF();\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tLogWindow.getWindow(windowID).setTitle(title);\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\toutput.writeInt(windowID);\n\t\toutput.writeUTF(title);\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new SendNewLogWindow(getId());\n\t}\n\n\t@Override\n\tpublic boolean isCompressable() {\n\t\treturn true;\n\t}\n}",
    "patch": "@@ -1,7 +1,5 @@\n package logisticspipes.network.packets.debug;\n \n-import java.io.IOException;\n-\n import net.minecraft.entity.player.EntityPlayer;\n \n import lombok.Getter;\n@@ -27,7 +25,7 @@ public SendNewLogWindow(int id) {\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\twindowID = input.readInt();\n \t\ttitle = input.readUTF();\n \t}\n@@ -38,7 +36,7 @@ public void processPacket(EntityPlayer player) {\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\toutput.writeInt(windowID);\n \t\toutput.writeUTF(title);\n \t}",
    "function_modified_lines": {
      "added": [
        "\tpublic void readData(LPDataInput input) {\n",
        "\tpublic void writeData(LPDataOutput output) {\n"
      ],
      "deleted": [
        "\tpublic void readData(LPDataInput input) throws IOException {\n",
        "\tpublic void writeData(LPDataOutput output) throws IOException {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12801
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\twindowID = input.readInt();\n\t\tstatus = input.readArrayList(new IReadListObject<StatusEntry>() {\n\n\t\t\t@Override\n\t\t\tpublic StatusEntry readObject(LPDataInput input) throws IOException {\n\t\t\t\tStatusEntry status = new StatusEntry();\n\t\t\t\tstatus.name = input.readUTF();\n\t\t\t\tif (input.readBoolean()) {\n\t\t\t\t\tstatus.subEntry = input.readArrayList(this);\n\t\t\t\t}\n\t\t\t\treturn status;\n\t\t\t}\n\t\t});\n\t}",
    "code_after_change": "@Override\n\tpublic void readData(LPDataInput input) {\n\t\twindowID = input.readInt();\n\t\tstatus = input.readArrayList(new IReadListObject<StatusEntry>() {\n\n\t\t\t@Override\n\t\t\tpublic StatusEntry readObject(LPDataInput input) {\n\t\t\t\tStatusEntry status = new StatusEntry();\n\t\t\t\tstatus.name = input.readUTF();\n\t\t\t\tif (input.readBoolean()) {\n\t\t\t\t\tstatus.subEntry = input.readArrayList(this);\n\t\t\t\t}\n\t\t\t\treturn status;\n\t\t\t}\n\t\t});\n\t}",
    "patch": "@@ -1,6 +1,5 @@\n package logisticspipes.network.packets.debug;\n \n-import java.io.IOException;\n import java.util.List;\n \n import net.minecraft.entity.player.EntityPlayer;\n@@ -31,12 +30,12 @@ public UpdateStatusEntries(int id) {\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\twindowID = input.readInt();\n \t\tstatus = input.readArrayList(new IReadListObject<StatusEntry>() {\n \n \t\t\t@Override\n-\t\t\tpublic StatusEntry readObject(LPDataInput input) throws IOException {\n+\t\t\tpublic StatusEntry readObject(LPDataInput input) {\n \t\t\t\tStatusEntry status = new StatusEntry();\n \t\t\t\tstatus.name = input.readUTF();\n \t\t\t\tif (input.readBoolean()) {\n@@ -53,12 +52,12 @@ public void processPacket(EntityPlayer player) {\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\toutput.writeInt(windowID);\n \t\toutput.writeCollection(status, new IWriteListObject<StatusEntry>() {\n \n \t\t\t@Override\n-\t\t\tpublic void writeObject(LPDataOutput output, StatusEntry entry) throws IOException {\n+\t\t\tpublic void writeObject(LPDataOutput output, StatusEntry entry) {\n \t\t\t\toutput.writeUTF(entry.name);\n \t\t\t\toutput.writeBoolean(entry.subEntry != null);\n \t\t\t\tif (entry.subEntry != null) {",
    "function_modified_lines": {
      "added": [
        "\tpublic void readData(LPDataInput input) {\n",
        "\t\t\tpublic StatusEntry readObject(LPDataInput input) {\n"
      ],
      "deleted": [
        "\tpublic void readData(LPDataInput input) throws IOException {\n",
        "\t\t\tpublic StatusEntry readObject(LPDataInput input) throws IOException {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12802
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\toutput.writeInt(windowID);\n\t\toutput.writeCollection(status, new IWriteListObject<StatusEntry>() {\n\n\t\t\t@Override\n\t\t\tpublic void writeObject(LPDataOutput output, StatusEntry entry) throws IOException {\n\t\t\t\toutput.writeUTF(entry.name);\n\t\t\t\toutput.writeBoolean(entry.subEntry != null);\n\t\t\t\tif (entry.subEntry != null) {\n\t\t\t\t\toutput.writeCollection(entry.subEntry, this);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}",
    "code_after_change": "@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\toutput.writeInt(windowID);\n\t\toutput.writeCollection(status, new IWriteListObject<StatusEntry>() {\n\n\t\t\t@Override\n\t\t\tpublic void writeObject(LPDataOutput output, StatusEntry entry) {\n\t\t\t\toutput.writeUTF(entry.name);\n\t\t\t\toutput.writeBoolean(entry.subEntry != null);\n\t\t\t\tif (entry.subEntry != null) {\n\t\t\t\t\toutput.writeCollection(entry.subEntry, this);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}",
    "patch": "@@ -1,6 +1,5 @@\n package logisticspipes.network.packets.debug;\n \n-import java.io.IOException;\n import java.util.List;\n \n import net.minecraft.entity.player.EntityPlayer;\n@@ -31,12 +30,12 @@ public UpdateStatusEntries(int id) {\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\twindowID = input.readInt();\n \t\tstatus = input.readArrayList(new IReadListObject<StatusEntry>() {\n \n \t\t\t@Override\n-\t\t\tpublic StatusEntry readObject(LPDataInput input) throws IOException {\n+\t\t\tpublic StatusEntry readObject(LPDataInput input) {\n \t\t\t\tStatusEntry status = new StatusEntry();\n \t\t\t\tstatus.name = input.readUTF();\n \t\t\t\tif (input.readBoolean()) {\n@@ -53,12 +52,12 @@ public void processPacket(EntityPlayer player) {\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\toutput.writeInt(windowID);\n \t\toutput.writeCollection(status, new IWriteListObject<StatusEntry>() {\n \n \t\t\t@Override\n-\t\t\tpublic void writeObject(LPDataOutput output, StatusEntry entry) throws IOException {\n+\t\t\tpublic void writeObject(LPDataOutput output, StatusEntry entry) {\n \t\t\t\toutput.writeUTF(entry.name);\n \t\t\t\toutput.writeBoolean(entry.subEntry != null);\n \t\t\t\tif (entry.subEntry != null) {",
    "function_modified_lines": {
      "added": [
        "\tpublic void writeData(LPDataOutput output) {\n",
        "\t\t\tpublic void writeObject(LPDataOutput output, StatusEntry entry) {\n"
      ],
      "deleted": [
        "\tpublic void writeData(LPDataOutput output) throws IOException {\n",
        "\t\t\tpublic void writeObject(LPDataOutput output, StatusEntry entry) throws IOException {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12803
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate byte[] payload;\n\n\t@Getter\n\t@Setter\n\tprivate int identifier;\n\n\tpublic DebugDataPacket(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tpayload = input.readByteArray();\n\t\tidentifier = input.readInt();\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tDebugGuiController.instance().handleDataPacket(payload, identifier, player);\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\toutput.writeByteArray(payload);\n\t\toutput.writeInt(identifier);\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new DebugDataPacket(getId());\n\t}\n}",
    "code_after_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate byte[] payload;\n\n\t@Getter\n\t@Setter\n\tprivate int identifier;\n\n\tpublic DebugDataPacket(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tpayload = input.readByteArray();\n\t\tidentifier = input.readInt();\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tDebugGuiController.instance().handleDataPacket(payload, identifier, player);\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\toutput.writeByteArray(payload);\n\t\toutput.writeInt(identifier);\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new DebugDataPacket(getId());\n\t}\n}",
    "patch": "@@ -1,7 +1,5 @@\n package logisticspipes.network.packets.debuggui;\n \n-import java.io.IOException;\n-\n import net.minecraft.entity.player.EntityPlayer;\n \n import lombok.Getter;\n@@ -27,7 +25,7 @@ public DebugDataPacket(int id) {\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tpayload = input.readByteArray();\n \t\tidentifier = input.readInt();\n \t}\n@@ -38,7 +36,7 @@ public void processPacket(EntityPlayer player) {\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\toutput.writeByteArray(payload);\n \t\toutput.writeInt(identifier);\n \t}",
    "function_modified_lines": {
      "added": [
        "\tpublic void readData(LPDataInput input) {\n",
        "\tpublic void writeData(LPDataOutput output) {\n"
      ],
      "deleted": [
        "\tpublic void readData(LPDataInput input) throws IOException {\n",
        "\tpublic void writeData(LPDataOutput output) throws IOException {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12804
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "{\n\n\t@Setter\n\t@Getter\n\tprivate String name;\n\n\t@Getter\n\t@Setter\n\tprivate int identification;\n\n\tpublic DebugPanelOpen(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new DebugPanelOpen(getId());\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tsetName(input.readUTF());\n\t\tsetIdentification(input.readInt());\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\toutput.writeUTF(getName());\n\t\toutput.writeInt(getIdentification());\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\ttry {\n\t\t\tDebugGuiController.instance().createNewDebugGui(getName(), getIdentification());\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isCompressable() {\n\t\treturn true;\n\t}\n}",
    "code_after_change": "{\n\n\t@Setter\n\t@Getter\n\tprivate String name;\n\n\t@Getter\n\t@Setter\n\tprivate int identification;\n\n\tpublic DebugPanelOpen(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new DebugPanelOpen(getId());\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tsetName(input.readUTF());\n\t\tsetIdentification(input.readInt());\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\toutput.writeUTF(getName());\n\t\toutput.writeInt(getIdentification());\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\ttry {\n\t\t\tDebugGuiController.instance().createNewDebugGui(getName(), getIdentification());\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isCompressable() {\n\t\treturn true;\n\t}\n}",
    "patch": "@@ -1,7 +1,5 @@\n package logisticspipes.network.packets.debuggui;\n \n-import java.io.IOException;\n-\n import net.minecraft.entity.player.EntityPlayer;\n \n import lombok.Getter;\n@@ -32,13 +30,13 @@ public ModernPacket template() {\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tsetName(input.readUTF());\n \t\tsetIdentification(input.readInt());\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\toutput.writeUTF(getName());\n \t\toutput.writeInt(getIdentification());\n \t}",
    "function_modified_lines": {
      "added": [
        "\tpublic void readData(LPDataInput input) {\n",
        "\tpublic void writeData(LPDataOutput output) {\n"
      ],
      "deleted": [
        "\tpublic void readData(LPDataInput input) throws IOException {\n",
        "\tpublic void writeData(LPDataOutput output) throws IOException {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12805
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "package logisticspipes.network.packets.debuggui;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInput;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutput;\nimport java.io.ObjectOutputStream;\n\nimport net.minecraft.block.Block;\nimport net.minecraft.entity.Entity;\nimport net.minecraft.entity.player.EntityPlayer;\nimport net.minecraft.tileentity.TileEntity;\nimport net.minecraft.util.ChatComponentText;\n\nimport lombok.Getter;\nimport lombok.Setter;\n\nimport logisticspipes.commands.chathelper.LPChatListener;\nimport logisticspipes.commands.commands.debug.DebugGuiController;\nimport logisticspipes.network.PacketHandler;\nimport logisticspipes.network.abstractpackets.ModernPacket;\nimport logisticspipes.network.packets.gui.OpenChatGui;\nimport logisticspipes.proxy.MainProxy;\nimport logisticspipes.utils.string.ChatColor;\nimport network.rs485.logisticspipes.util.LPDataInput;\nimport network.rs485.logisticspipes.util.LPDataOutput;\n\npublic class DebugTargetResponse extends ModernPacket {\n\n\tpublic DebugTargetResponse(int id) {\n\t\tsuper(id);\n\t}\n\n\tpublic enum TargetMode {\n\t\tBlock,\n\t\tEntity,\n\t\tNone\n\t}\n\n\t@Getter\n\t@Setter\n\tprivate TargetMode mode;\n\n\t@Getter\n\t@Setter\n\tprivate Object[] additions = new Object[0];\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tmode = TargetMode.values()[input.readByte()];\n\t\tint size = input.readInt();\n\t\tadditions = new Object[size];\n\t\tfor (int i = 0; i < size; i++) {\n\t\t\tbyte[] bytes = input.readByteArray();\n\t\t\tByteArrayInputStream bis = new ByteArrayInputStream(bytes);\n\t\t\tObjectInput in = new ObjectInputStream(bis);\n\t\t\ttry {\n\t\t\t\tObject o = in.readObject();\n\t\t\t\tadditions[i] = o;\n\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\tthrow new UnsupportedOperationException(e);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void processPacket(final EntityPlayer player) {\n\t\tif (mode == TargetMode.None) {\n\t\t\tplayer.addChatComponentMessage(new ChatComponentText(ChatColor.RED + \"No Target Found\"));\n\t\t} else if (mode == TargetMode.Block) {\n\t\t\tint x = (Integer) additions[0];\n\t\t\tint y = (Integer) additions[1];\n\t\t\tint z = (Integer) additions[2];\n\t\t\tplayer.addChatComponentMessage(new ChatComponentText(\"Checking Block at: x:\" + x + \" y:\" + y + \" z:\" + z));\n\t\t\tBlock id = player.worldObj.getBlock(x, y, z);\n\t\t\tplayer.addChatComponentMessage(new ChatComponentText(\"Found Block with Id: \" + id.getClass()));\n\t\t\tfinal TileEntity tile = player.worldObj.getTileEntity(x, y, z);\n\t\t\tif (tile == null) {\n\t\t\t\tplayer.addChatComponentMessage(new ChatComponentText(ChatColor.RED + \"No TileEntity found\"));\n\t\t\t} else {\n\t\t\t\tLPChatListener.addTask(() -> {\n\t\t\t\t\tplayer.addChatComponentMessage(new ChatComponentText(\n\t\t\t\t\t\t\tChatColor.GREEN + \"Starting debuging of TileEntity: \" + ChatColor.BLUE + ChatColor.UNDERLINE + tile.getClass().getSimpleName()));\n\t\t\t\t\tDebugGuiController.instance().startWatchingOf(tile, player);\n\t\t\t\t\tMainProxy.sendPacketToPlayer(PacketHandler.getPacket(OpenChatGui.class), player);\n\t\t\t\t\treturn true;\n\t\t\t\t}, player);\n\t\t\t\tplayer.addChatComponentMessage(new ChatComponentText(\n\t\t\t\t\t\tChatColor.AQUA + \"Start debuging of TileEntity: \" + ChatColor.BLUE + ChatColor.UNDERLINE + tile.getClass().getSimpleName()\n\t\t\t\t\t\t\t\t+ ChatColor.AQUA + \"? \" + ChatColor.RESET + \"<\" + ChatColor.GREEN + \"yes\" + ChatColor.RESET + \"/\" + ChatColor.RED + \"no\"\n\t\t\t\t\t\t\t\t+ ChatColor.RESET + \">\"));\n\t\t\t\tMainProxy.sendPacketToPlayer(PacketHandler.getPacket(OpenChatGui.class), player);\n\t\t\t}\n\t\t} else if (mode == TargetMode.Entity) {\n\t\t\tint entityId = (Integer) additions[0];\n\t\t\tfinal Entity entity = player.worldObj.getEntityByID(entityId);\n\t\t\tif (entity == null) {\n\t\t\t\tplayer.addChatComponentMessage(new ChatComponentText(ChatColor.RED + \"No Entity found\"));\n\t\t\t} else {\n\t\t\t\tLPChatListener.addTask(() -> {\n\t\t\t\t\tplayer.addChatComponentMessage(new ChatComponentText(\n\t\t\t\t\t\t\tChatColor.GREEN + \"Starting debuging of Entity: \" + ChatColor.BLUE + ChatColor.UNDERLINE + entity.getClass().getSimpleName()));\n\t\t\t\t\tDebugGuiController.instance().startWatchingOf(entity, player);\n\t\t\t\t\tMainProxy.sendPacketToPlayer(PacketHandler.getPacket(OpenChatGui.class), player);\n\t\t\t\t\treturn true;\n\t\t\t\t}, player);\n\t\t\t\tplayer.addChatComponentMessage(new ChatComponentText(\n\t\t\t\t\t\tChatColor.AQUA + \"Start debuging of Entity: \" + ChatColor.BLUE + ChatColor.UNDERLINE + entity.getClass().getSimpleName()\n\t\t\t\t\t\t\t\t+ ChatColor.AQUA + \"? \" + ChatColor.RESET + \"<\" + ChatColor.GREEN + \"yes\" + ChatColor.RESET + \"/\" + ChatColor.RED + \"no\"\n\t\t\t\t\t\t\t\t+ ChatColor.RESET + \">\"));\n\t\t\t\tMainProxy.sendPacketToPlayer(PacketHandler.getPacket(OpenChatGui.class), player);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\toutput.writeByte(mode.ordinal());\n\t\toutput.writeInt(additions.length);\n\t\tfor (Object addition : additions) {\n\t\t\tByteArrayOutputStream bos = new ByteArrayOutputStream();\n\t\t\tObjectOutput out = null;\n\t\t\tout = new ObjectOutputStream(bos);\n\t\t\tout.writeObject(addition);\n\t\t\toutput.writeByteArray(bos.toByteArray());\n\t\t}\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new DebugTargetResponse(getId());\n\t}\n\n\t@Override\n\tpublic boolean isCompressable() {\n\t\treturn true;\n\t}\n}\n",
    "code_after_change": "package logisticspipes.network.packets.debuggui;\n\nimport net.minecraft.block.Block;\nimport net.minecraft.entity.Entity;\nimport net.minecraft.entity.player.EntityPlayer;\nimport net.minecraft.tileentity.TileEntity;\nimport net.minecraft.util.ChatComponentText;\n\nimport lombok.Getter;\nimport lombok.Setter;\n\nimport logisticspipes.commands.chathelper.LPChatListener;\nimport logisticspipes.commands.commands.debug.DebugGuiController;\nimport logisticspipes.network.PacketHandler;\nimport logisticspipes.network.abstractpackets.ModernPacket;\nimport logisticspipes.network.packets.gui.OpenChatGui;\nimport logisticspipes.proxy.MainProxy;\nimport logisticspipes.utils.string.ChatColor;\nimport network.rs485.logisticspipes.util.LPDataInput;\nimport network.rs485.logisticspipes.util.LPDataOutput;\n\npublic class DebugTargetResponse extends ModernPacket {\n\n\t@Getter\n\t@Setter\n\tprivate TargetMode mode;\n\t@Getter\n\t@Setter\n\tprivate int[] additions = new int[0];\n\n\tpublic DebugTargetResponse(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tmode = TargetMode.values()[input.readByte()];\n\t\tadditions = input.readIntArray();\n\t}\n\n\t@Override\n\tpublic void processPacket(final EntityPlayer player) {\n\t\tif (mode == TargetMode.None) {\n\t\t\tplayer.addChatComponentMessage(new ChatComponentText(ChatColor.RED + \"No Target Found\"));\n\t\t} else if (mode == TargetMode.Block) {\n\t\t\tint x = additions[0];\n\t\t\tint y = additions[1];\n\t\t\tint z = additions[2];\n\t\t\tplayer.addChatComponentMessage(new ChatComponentText(\"Checking Block at: x:\" + x + \" y:\" + y + \" z:\" + z));\n\t\t\tBlock id = player.worldObj.getBlock(x, y, z);\n\t\t\tplayer.addChatComponentMessage(new ChatComponentText(\"Found Block with Id: \" + id.getClass()));\n\t\t\tfinal TileEntity tile = player.worldObj.getTileEntity(x, y, z);\n\t\t\tif (tile == null) {\n\t\t\t\tplayer.addChatComponentMessage(new ChatComponentText(ChatColor.RED + \"No TileEntity found\"));\n\t\t\t} else {\n\t\t\t\tLPChatListener.addTask(() -> {\n\t\t\t\t\tplayer.addChatComponentMessage(new ChatComponentText(\n\t\t\t\t\t\t\tChatColor.GREEN + \"Starting debuging of TileEntity: \" + ChatColor.BLUE + ChatColor.UNDERLINE + tile.getClass().getSimpleName()));\n\t\t\t\t\tDebugGuiController.instance().startWatchingOf(tile, player);\n\t\t\t\t\tMainProxy.sendPacketToPlayer(PacketHandler.getPacket(OpenChatGui.class), player);\n\t\t\t\t\treturn true;\n\t\t\t\t}, player);\n\t\t\t\tplayer.addChatComponentMessage(new ChatComponentText(\n\t\t\t\t\t\tChatColor.AQUA + \"Start debuging of TileEntity: \" + ChatColor.BLUE + ChatColor.UNDERLINE + tile.getClass().getSimpleName()\n\t\t\t\t\t\t\t\t+ ChatColor.AQUA + \"? \" + ChatColor.RESET + \"<\" + ChatColor.GREEN + \"yes\" + ChatColor.RESET + \"/\" + ChatColor.RED + \"no\"\n\t\t\t\t\t\t\t\t+ ChatColor.RESET + \">\"));\n\t\t\t\tMainProxy.sendPacketToPlayer(PacketHandler.getPacket(OpenChatGui.class), player);\n\t\t\t}\n\t\t} else if (mode == TargetMode.Entity) {\n\t\t\tint entityId = additions[0];\n\t\t\tfinal Entity entity = player.worldObj.getEntityByID(entityId);\n\t\t\tif (entity == null) {\n\t\t\t\tplayer.addChatComponentMessage(new ChatComponentText(ChatColor.RED + \"No Entity found\"));\n\t\t\t} else {\n\t\t\t\tLPChatListener.addTask(() -> {\n\t\t\t\t\tplayer.addChatComponentMessage(new ChatComponentText(\n\t\t\t\t\t\t\tChatColor.GREEN + \"Starting debuging of Entity: \" + ChatColor.BLUE + ChatColor.UNDERLINE + entity.getClass().getSimpleName()));\n\t\t\t\t\tDebugGuiController.instance().startWatchingOf(entity, player);\n\t\t\t\t\tMainProxy.sendPacketToPlayer(PacketHandler.getPacket(OpenChatGui.class), player);\n\t\t\t\t\treturn true;\n\t\t\t\t}, player);\n\t\t\t\tplayer.addChatComponentMessage(new ChatComponentText(\n\t\t\t\t\t\tChatColor.AQUA + \"Start debuging of Entity: \" + ChatColor.BLUE + ChatColor.UNDERLINE + entity.getClass().getSimpleName()\n\t\t\t\t\t\t\t\t+ ChatColor.AQUA + \"? \" + ChatColor.RESET + \"<\" + ChatColor.GREEN + \"yes\" + ChatColor.RESET + \"/\" + ChatColor.RED + \"no\"\n\t\t\t\t\t\t\t\t+ ChatColor.RESET + \">\"));\n\t\t\t\tMainProxy.sendPacketToPlayer(PacketHandler.getPacket(OpenChatGui.class), player);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\toutput.writeByte(mode.ordinal());\n\t\toutput.writeIntArray(additions);\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new DebugTargetResponse(getId());\n\t}\n\n\t@Override\n\tpublic boolean isCompressable() {\n\t\treturn true;\n\t}\n\n\tpublic enum TargetMode {\n\t\tBlock,\n\t\tEntity,\n\t\tNone\n\t}\n}\n",
    "patch": "@@ -1,13 +1,5 @@\n package logisticspipes.network.packets.debuggui;\n \n-import java.io.ByteArrayInputStream;\n-import java.io.ByteArrayOutputStream;\n-import java.io.IOException;\n-import java.io.ObjectInput;\n-import java.io.ObjectInputStream;\n-import java.io.ObjectOutput;\n-import java.io.ObjectOutputStream;\n-\n import net.minecraft.block.Block;\n import net.minecraft.entity.Entity;\n import net.minecraft.entity.player.EntityPlayer;\n@@ -29,50 +21,31 @@\n \n public class DebugTargetResponse extends ModernPacket {\n \n-\tpublic DebugTargetResponse(int id) {\n-\t\tsuper(id);\n-\t}\n-\n-\tpublic enum TargetMode {\n-\t\tBlock,\n-\t\tEntity,\n-\t\tNone\n-\t}\n-\n \t@Getter\n \t@Setter\n \tprivate TargetMode mode;\n-\n \t@Getter\n \t@Setter\n-\tprivate Object[] additions = new Object[0];\n+\tprivate int[] additions = new int[0];\n+\n+\tpublic DebugTargetResponse(int id) {\n+\t\tsuper(id);\n+\t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tmode = TargetMode.values()[input.readByte()];\n-\t\tint size = input.readInt();\n-\t\tadditions = new Object[size];\n-\t\tfor (int i = 0; i < size; i++) {\n-\t\t\tbyte[] bytes = input.readByteArray();\n-\t\t\tByteArrayInputStream bis = new ByteArrayInputStream(bytes);\n-\t\t\tObjectInput in = new ObjectInputStream(bis);\n-\t\t\ttry {\n-\t\t\t\tObject o = in.readObject();\n-\t\t\t\tadditions[i] = o;\n-\t\t\t} catch (ClassNotFoundException e) {\n-\t\t\t\tthrow new UnsupportedOperationException(e);\n-\t\t\t}\n-\t\t}\n+\t\tadditions = input.readIntArray();\n \t}\n \n \t@Override\n \tpublic void processPacket(final EntityPlayer player) {\n \t\tif (mode == TargetMode.None) {\n \t\t\tplayer.addChatComponentMessage(new ChatComponentText(ChatColor.RED + \"No Target Found\"));\n \t\t} else if (mode == TargetMode.Block) {\n-\t\t\tint x = (Integer) additions[0];\n-\t\t\tint y = (Integer) additions[1];\n-\t\t\tint z = (Integer) additions[2];\n+\t\t\tint x = additions[0];\n+\t\t\tint y = additions[1];\n+\t\t\tint z = additions[2];\n \t\t\tplayer.addChatComponentMessage(new ChatComponentText(\"Checking Block at: x:\" + x + \" y:\" + y + \" z:\" + z));\n \t\t\tBlock id = player.worldObj.getBlock(x, y, z);\n \t\t\tplayer.addChatComponentMessage(new ChatComponentText(\"Found Block with Id: \" + id.getClass()));\n@@ -94,7 +67,7 @@ public void processPacket(final EntityPlayer player) {\n \t\t\t\tMainProxy.sendPacketToPlayer(PacketHandler.getPacket(OpenChatGui.class), player);\n \t\t\t}\n \t\t} else if (mode == TargetMode.Entity) {\n-\t\t\tint entityId = (Integer) additions[0];\n+\t\t\tint entityId = additions[0];\n \t\t\tfinal Entity entity = player.worldObj.getEntityByID(entityId);\n \t\t\tif (entity == null) {\n \t\t\t\tplayer.addChatComponentMessage(new ChatComponentText(ChatColor.RED + \"No Entity found\"));\n@@ -116,16 +89,9 @@ public void processPacket(final EntityPlayer player) {\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\toutput.writeByte(mode.ordinal());\n-\t\toutput.writeInt(additions.length);\n-\t\tfor (Object addition : additions) {\n-\t\t\tByteArrayOutputStream bos = new ByteArrayOutputStream();\n-\t\t\tObjectOutput out = null;\n-\t\t\tout = new ObjectOutputStream(bos);\n-\t\t\tout.writeObject(addition);\n-\t\t\toutput.writeByteArray(bos.toByteArray());\n-\t\t}\n+\t\toutput.writeIntArray(additions);\n \t}\n \n \t@Override\n@@ -137,4 +103,10 @@ public ModernPacket template() {\n \tpublic boolean isCompressable() {\n \t\treturn true;\n \t}\n+\n+\tpublic enum TargetMode {\n+\t\tBlock,\n+\t\tEntity,\n+\t\tNone\n+\t}\n }",
    "function_modified_lines": {
      "added": [],
      "deleted": [
        "import java.io.ByteArrayInputStream;\n",
        "import java.io.ByteArrayOutputStream;\n",
        "import java.io.IOException;\n",
        "import java.io.ObjectInput;\n",
        "import java.io.ObjectInputStream;\n",
        "import java.io.ObjectOutput;\n",
        "import java.io.ObjectOutputStream;\n",
        "\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12806
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate int guiID;\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\tsuper.writeData(output);\n\t\toutput.writeInt(getGuiID());\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tsuper.readData(input);\n\t\tguiID = input.readInt();\n\t}\n\n\tpublic GuiReopenPacket(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tplayer.openGui(LogisticsPipes.instance, getGuiID(), player.worldObj, getPosX(), getPosY(), getPosZ());\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new GuiReopenPacket(getId());\n\t}\n\n}",
    "code_after_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate int guiID;\n\n\tpublic GuiReopenPacket(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\tsuper.writeData(output);\n\t\toutput.writeInt(getGuiID());\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tsuper.readData(input);\n\t\tguiID = input.readInt();\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tplayer.openGui(LogisticsPipes.instance, getGuiID(), player.worldObj, getPosX(), getPosY(), getPosZ());\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new GuiReopenPacket(getId());\n\t}\n\n}",
    "patch": "@@ -1,7 +1,5 @@\n package logisticspipes.network.packets.gui;\n \n-import java.io.IOException;\n-\n import net.minecraft.entity.player.EntityPlayer;\n \n import lombok.Getter;\n@@ -19,22 +17,22 @@ public class GuiReopenPacket extends CoordinatesPacket {\n \t@Setter\n \tprivate int guiID;\n \n+\tpublic GuiReopenPacket(int id) {\n+\t\tsuper(id);\n+\t}\n+\n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\tsuper.writeData(output);\n \t\toutput.writeInt(getGuiID());\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tsuper.readData(input);\n \t\tguiID = input.readInt();\n \t}\n \n-\tpublic GuiReopenPacket(int id) {\n-\t\tsuper(id);\n-\t}\n-\n \t@Override\n \tpublic void processPacket(EntityPlayer player) {\n \t\tplayer.openGui(LogisticsPipes.instance, getGuiID(), player.worldObj, getPosX(), getPosY(), getPosZ());",
    "function_modified_lines": {
      "added": [
        "\tpublic GuiReopenPacket(int id) {\n",
        "\t\tsuper(id);\n",
        "\t}\n",
        "\n",
        "\tpublic void writeData(LPDataOutput output) {\n",
        "\tpublic void readData(LPDataInput input) {\n"
      ],
      "deleted": [
        "\tpublic void writeData(LPDataOutput output) throws IOException {\n",
        "\tpublic void readData(LPDataInput input) throws IOException {\n",
        "\tpublic GuiReopenPacket(int id) {\n",
        "\t\tsuper(id);\n",
        "\t}\n",
        "\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12808
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "{\n\n\tpublic OpenChatGui(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {}\n\n\t@Override\n\t@ClientSideOnlyMethodContent\n\tpublic void processPacket(EntityPlayer player) {\n\t\tFMLClientHandler.instance().getClient().displayGuiScreen(new GuiChat());\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new OpenChatGui(getId());\n\t}\n}",
    "code_after_change": "{\n\n\tpublic OpenChatGui(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {}\n\n\t@Override\n\t@ClientSideOnlyMethodContent\n\tpublic void processPacket(EntityPlayer player) {\n\t\tFMLClientHandler.instance().getClient().displayGuiScreen(new GuiChat());\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new OpenChatGui(getId());\n\t}\n}",
    "patch": "@@ -1,7 +1,5 @@\n package logisticspipes.network.packets.gui;\n \n-import java.io.IOException;\n-\n import net.minecraft.client.gui.GuiChat;\n import net.minecraft.entity.player.EntityPlayer;\n import cpw.mods.fml.client.FMLClientHandler;\n@@ -18,7 +16,7 @@ public OpenChatGui(int id) {\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {}\n+\tpublic void readData(LPDataInput input) {}\n \n \t@Override\n \t@ClientSideOnlyMethodContent\n@@ -27,7 +25,7 @@ public void processPacket(EntityPlayer player) {\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {}\n+\tpublic void writeData(LPDataOutput output) {}\n \n \t@Override\n \tpublic ModernPacket template() {",
    "function_modified_lines": {
      "added": [
        "\tpublic void readData(LPDataInput input) {}\n",
        "\tpublic void writeData(LPDataOutput output) {}\n"
      ],
      "deleted": [
        "\tpublic void readData(LPDataInput input) throws IOException {}\n",
        "\tpublic void writeData(LPDataOutput output) throws IOException {}\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12809
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate int buttonId;\n\n\t@Getter\n\t@Setter\n\tprivate boolean state;\n\n\t@Getter\n\t@Setter\n\tprivate int slot;\n\n\tpublic HUDSettingsPacket(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new HUDSettingsPacket(getId());\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tif (player.inventory.getStackInSlot(slot) == null) {\n\t\t\treturn;\n\t\t}\n\t\tIHUDConfig config = new HUDConfig(player.inventory.getStackInSlot(slot));\n\t\tswitch (buttonId) {\n\t\t\tcase 0:\n\t\t\t\tconfig.setHUDChassie(state);\n\t\t\t\tif (config.isHUDChassie()) {\n\t\t\t\t\tplayer.addChatComponentMessage(new ChatComponentTranslation(\"lp.hud.config.chassie.enabled\"));\n\t\t\t\t} else {\n\t\t\t\t\tplayer.addChatComponentMessage(new ChatComponentTranslation(\"lp.hud.config.chassie.disabled\"));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tconfig.setHUDCrafting(state);\n\t\t\t\tif (config.isHUDCrafting()) {\n\t\t\t\t\tplayer.addChatComponentMessage(new ChatComponentTranslation(\"lp.hud.config.crafting.enabled\"));\n\t\t\t\t} else {\n\t\t\t\t\tplayer.addChatComponentMessage(new ChatComponentTranslation(\"lp.hud.config.crafting.disabled\"));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tconfig.setHUDInvSysCon(state);\n\t\t\t\tif (config.isHUDInvSysCon()) {\n\t\t\t\t\tplayer.addChatComponentMessage(new ChatComponentTranslation(\"lp.hud.config.invsyscon.enabled\"));\n\t\t\t\t} else {\n\t\t\t\t\tplayer.addChatComponentMessage(new ChatComponentTranslation(\"lp.hud.config.invsyscon.disabled\"));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tconfig.setHUDPowerJunction(state);\n\t\t\t\tif (config.isHUDPowerLevel()) {\n\t\t\t\t\tplayer.addChatComponentMessage(new ChatComponentTranslation(\"lp.hud.config.powerjunction.enabled\"));\n\t\t\t\t} else {\n\t\t\t\t\tplayer.addChatComponentMessage(new ChatComponentTranslation(\"lp.hud.config.powerjunction.disabled\"));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tconfig.setHUDProvider(state);\n\t\t\t\tif (config.isHUDProvider()) {\n\t\t\t\t\tplayer.addChatComponentMessage(new ChatComponentTranslation(\"lp.hud.config.provider.enabled\"));\n\t\t\t\t} else {\n\t\t\t\t\tplayer.addChatComponentMessage(new ChatComponentTranslation(\"lp.hud.config.provider.disabled\"));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tconfig.setHUDSatellite(state);\n\t\t\t\tif (config.isHUDSatellite()) {\n\t\t\t\t\tplayer.addChatComponentMessage(new ChatComponentTranslation(\"lp.hud.config.satellite.enabled\"));\n\t\t\t\t} else {\n\t\t\t\t\tplayer.addChatComponentMessage(new ChatComponentTranslation(\"lp.hud.config.satellite.disabled\"));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t\tif (player.inventoryContainer != null) {\n\t\t\tplayer.inventoryContainer.detectAndSendChanges();\n\t\t}\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tbuttonId = input.readInt();\n\t\tstate = input.readBoolean();\n\t\tslot = input.readInt();\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\toutput.writeInt(buttonId);\n\t\toutput.writeBoolean(state);\n\t\toutput.writeInt(slot);\n\t}\n}",
    "code_after_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate int buttonId;\n\n\t@Getter\n\t@Setter\n\tprivate boolean state;\n\n\t@Getter\n\t@Setter\n\tprivate int slot;\n\n\tpublic HUDSettingsPacket(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new HUDSettingsPacket(getId());\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tif (player.inventory.getStackInSlot(slot) == null) {\n\t\t\treturn;\n\t\t}\n\t\tIHUDConfig config = new HUDConfig(player.inventory.getStackInSlot(slot));\n\t\tswitch (buttonId) {\n\t\t\tcase 0:\n\t\t\t\tconfig.setHUDChassie(state);\n\t\t\t\tif (config.isHUDChassie()) {\n\t\t\t\t\tplayer.addChatComponentMessage(new ChatComponentTranslation(\"lp.hud.config.chassie.enabled\"));\n\t\t\t\t} else {\n\t\t\t\t\tplayer.addChatComponentMessage(new ChatComponentTranslation(\"lp.hud.config.chassie.disabled\"));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tconfig.setHUDCrafting(state);\n\t\t\t\tif (config.isHUDCrafting()) {\n\t\t\t\t\tplayer.addChatComponentMessage(new ChatComponentTranslation(\"lp.hud.config.crafting.enabled\"));\n\t\t\t\t} else {\n\t\t\t\t\tplayer.addChatComponentMessage(new ChatComponentTranslation(\"lp.hud.config.crafting.disabled\"));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tconfig.setHUDInvSysCon(state);\n\t\t\t\tif (config.isHUDInvSysCon()) {\n\t\t\t\t\tplayer.addChatComponentMessage(new ChatComponentTranslation(\"lp.hud.config.invsyscon.enabled\"));\n\t\t\t\t} else {\n\t\t\t\t\tplayer.addChatComponentMessage(new ChatComponentTranslation(\"lp.hud.config.invsyscon.disabled\"));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tconfig.setHUDPowerJunction(state);\n\t\t\t\tif (config.isHUDPowerLevel()) {\n\t\t\t\t\tplayer.addChatComponentMessage(new ChatComponentTranslation(\"lp.hud.config.powerjunction.enabled\"));\n\t\t\t\t} else {\n\t\t\t\t\tplayer.addChatComponentMessage(new ChatComponentTranslation(\"lp.hud.config.powerjunction.disabled\"));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tconfig.setHUDProvider(state);\n\t\t\t\tif (config.isHUDProvider()) {\n\t\t\t\t\tplayer.addChatComponentMessage(new ChatComponentTranslation(\"lp.hud.config.provider.enabled\"));\n\t\t\t\t} else {\n\t\t\t\t\tplayer.addChatComponentMessage(new ChatComponentTranslation(\"lp.hud.config.provider.disabled\"));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tconfig.setHUDSatellite(state);\n\t\t\t\tif (config.isHUDSatellite()) {\n\t\t\t\t\tplayer.addChatComponentMessage(new ChatComponentTranslation(\"lp.hud.config.satellite.enabled\"));\n\t\t\t\t} else {\n\t\t\t\t\tplayer.addChatComponentMessage(new ChatComponentTranslation(\"lp.hud.config.satellite.disabled\"));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t\tif (player.inventoryContainer != null) {\n\t\t\tplayer.inventoryContainer.detectAndSendChanges();\n\t\t}\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tbuttonId = input.readInt();\n\t\tstate = input.readBoolean();\n\t\tslot = input.readInt();\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\toutput.writeInt(buttonId);\n\t\toutput.writeBoolean(state);\n\t\toutput.writeInt(slot);\n\t}\n}",
    "patch": "@@ -1,7 +1,5 @@\n package logisticspipes.network.packets.hud;\n \n-import java.io.IOException;\n-\n import net.minecraft.entity.player.EntityPlayer;\n import net.minecraft.util.ChatComponentTranslation;\n \n@@ -99,14 +97,14 @@ public void processPacket(EntityPlayer player) {\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tbuttonId = input.readInt();\n \t\tstate = input.readBoolean();\n \t\tslot = input.readInt();\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\toutput.writeInt(buttonId);\n \t\toutput.writeBoolean(state);\n \t\toutput.writeInt(slot);",
    "function_modified_lines": {
      "added": [
        "\tpublic void readData(LPDataInput input) {\n",
        "\tpublic void writeData(LPDataOutput output) {\n"
      ],
      "deleted": [
        "\tpublic void readData(LPDataInput input) throws IOException {\n",
        "\tpublic void writeData(LPDataOutput output) throws IOException {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12810
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate NBTTagCompound nbt;\n\n\tpublic ModuleBasedItemSinkList(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new ModuleBasedItemSinkList(getId());\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tIStringBasedModule module = this.getLogisticsModule(player, IStringBasedModule.class);\n\t\tif (module == null) {\n\t\t\treturn;\n\t\t}\n\t\tmodule.readFromNBT(nbt);\n\t\tif (MainProxy.isServer(player.getEntityWorld()) && getType().isInWorld()) {\n\t\t\tmodule.listChanged();\n\t\t}\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\tsuper.writeData(output);\n\t\toutput.writeNBTTagCompound(nbt);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tsuper.readData(input);\n\t\tnbt = input.readNBTTagCompound();\n\t}\n}",
    "code_after_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate NBTTagCompound nbt;\n\n\tpublic ModuleBasedItemSinkList(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new ModuleBasedItemSinkList(getId());\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tIStringBasedModule module = this.getLogisticsModule(player, IStringBasedModule.class);\n\t\tif (module == null) {\n\t\t\treturn;\n\t\t}\n\t\tmodule.readFromNBT(nbt);\n\t\tif (MainProxy.isServer(player.getEntityWorld()) && getType().isInWorld()) {\n\t\t\tmodule.listChanged();\n\t\t}\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\tsuper.writeData(output);\n\t\toutput.writeNBTTagCompound(nbt);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tsuper.readData(input);\n\t\tnbt = input.readNBTTagCompound();\n\t}\n}",
    "patch": "@@ -1,7 +1,5 @@\n package logisticspipes.network.packets.module;\n \n-import java.io.IOException;\n-\n import net.minecraft.entity.player.EntityPlayer;\n import net.minecraft.nbt.NBTTagCompound;\n \n@@ -43,13 +41,13 @@ public void processPacket(EntityPlayer player) {\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\tsuper.writeData(output);\n \t\toutput.writeNBTTagCompound(nbt);\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tsuper.readData(input);\n \t\tnbt = input.readNBTTagCompound();\n \t}",
    "function_modified_lines": {
      "added": [
        "\tpublic void writeData(LPDataOutput output) {\n",
        "\tpublic void readData(LPDataInput input) {\n"
      ],
      "deleted": [
        "\tpublic void writeData(LPDataOutput output) throws IOException {\n",
        "\tpublic void readData(LPDataInput input) throws IOException {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12811
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate int mode;\n\n\tpublic ProviderModuleMode(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new ProviderModuleMode(getId());\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tfinal ModuleProvider module = this.getLogisticsModule(player, ModuleProvider.class);\n\t\tif (module == null) {\n\t\t\treturn;\n\t\t}\n\t\tmodule.setExtractionMode(mode);\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\tsuper.writeData(output);\n\t\toutput.writeInt(mode);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tsuper.readData(input);\n\t\tmode = input.readInt();\n\t}\n}",
    "code_after_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate int mode;\n\n\tpublic ProviderModuleMode(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new ProviderModuleMode(getId());\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tfinal ModuleProvider module = this.getLogisticsModule(player, ModuleProvider.class);\n\t\tif (module == null) {\n\t\t\treturn;\n\t\t}\n\t\tmodule.setExtractionMode(mode);\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\tsuper.writeData(output);\n\t\toutput.writeInt(mode);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tsuper.readData(input);\n\t\tmode = input.readInt();\n\t}\n}",
    "patch": "@@ -1,7 +1,5 @@\n package logisticspipes.network.packets.modules;\n \n-import java.io.IOException;\n-\n import net.minecraft.entity.player.EntityPlayer;\n \n import lombok.Getter;\n@@ -38,13 +36,13 @@ public void processPacket(EntityPlayer player) {\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\tsuper.writeData(output);\n \t\toutput.writeInt(mode);\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tsuper.readData(input);\n \t\tmode = input.readInt();\n \t}",
    "function_modified_lines": {
      "added": [
        "\tpublic void writeData(LPDataOutput output) {\n",
        "\tpublic void readData(LPDataInput input) {\n"
      ],
      "deleted": [
        "\tpublic void writeData(LPDataOutput output) throws IOException {\n",
        "\tpublic void readData(LPDataInput input) throws IOException {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12812
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate boolean hasPatternUpgrade;\n\n\tpublic SupplierPipeMode(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new SupplierPipeMode(getId());\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tModuleActiveSupplier module = this.getLogisticsModule(player, ModuleActiveSupplier.class);\n\t\tif (module == null) {\n\t\t\treturn;\n\t\t}\n\t\tif (hasPatternUpgrade) {\n\t\t\tmodule.setPatternMode(PatternMode.values()[getInteger()]);\n\t\t} else {\n\t\t\tmodule.setSupplyMode(SupplyMode.values()[getInteger()]);\n\t\t}\n\t\tif (FMLClientHandler.instance().getClient().currentScreen instanceof GuiSupplierPipe) {\n\t\t\t((GuiSupplierPipe) FMLClientHandler.instance().getClient().currentScreen).refreshMode();\n\t\t}\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tsuper.readData(input);\n\t\thasPatternUpgrade = input.readBoolean();\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\tsuper.writeData(output);\n\t\toutput.writeBoolean(hasPatternUpgrade);\n\t}\n\n}",
    "code_after_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate boolean hasPatternUpgrade;\n\n\tpublic SupplierPipeMode(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new SupplierPipeMode(getId());\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tModuleActiveSupplier module = this.getLogisticsModule(player, ModuleActiveSupplier.class);\n\t\tif (module == null) {\n\t\t\treturn;\n\t\t}\n\t\tif (hasPatternUpgrade) {\n\t\t\tmodule.setPatternMode(PatternMode.values()[getInteger()]);\n\t\t} else {\n\t\t\tmodule.setSupplyMode(SupplyMode.values()[getInteger()]);\n\t\t}\n\t\tif (FMLClientHandler.instance().getClient().currentScreen instanceof GuiSupplierPipe) {\n\t\t\t((GuiSupplierPipe) FMLClientHandler.instance().getClient().currentScreen).refreshMode();\n\t\t}\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tsuper.readData(input);\n\t\thasPatternUpgrade = input.readBoolean();\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\tsuper.writeData(output);\n\t\toutput.writeBoolean(hasPatternUpgrade);\n\t}\n\n}",
    "patch": "@@ -1,7 +1,5 @@\n package logisticspipes.network.packets.modules;\n \n-import java.io.IOException;\n-\n import net.minecraft.entity.player.EntityPlayer;\n import cpw.mods.fml.client.FMLClientHandler;\n \n@@ -49,13 +47,13 @@ public void processPacket(EntityPlayer player) {\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tsuper.readData(input);\n \t\thasPatternUpgrade = input.readBoolean();\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\tsuper.writeData(output);\n \t\toutput.writeBoolean(hasPatternUpgrade);\n \t}",
    "function_modified_lines": {
      "added": [
        "\tpublic void readData(LPDataInput input) {\n",
        "\tpublic void writeData(LPDataOutput output) {\n"
      ],
      "deleted": [
        "\tpublic void readData(LPDataInput input) throws IOException {\n",
        "\tpublic void writeData(LPDataOutput output) throws IOException {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12813
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate ItemIdentifierStack stack = null;\n\n\tpublic ItemAmountSignUpdatePacket(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tLogisticsTileGenericPipe pipe = this.getPipe(player.getEntityWorld());\n\t\tif (pipe == null || !pipe.isInitialized()) {\n\t\t\treturn;\n\t\t}\n\n\t\tIPipeSign sign = ((CoreRoutedPipe) pipe.pipe).getPipeSign(ForgeDirection.getOrientation(getInteger()));\n\t\tif (sign == null) {\n\t\t\treturn;\n\t\t}\n\t\t((ItemAmountPipeSign) sign).amount = getInteger2();\n\t\t((ItemAmountPipeSign) sign).itemTypeInv.setInventorySlotContents(0, stack);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tsuper.readData(input);\n\t\tif (input.readBoolean()) {\n\t\t\tstack = input.readItemIdentifierStack();\n\t\t}\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\tsuper.writeData(output);\n\t\tif (stack == null) {\n\t\t\toutput.writeBoolean(false);\n\t\t} else {\n\t\t\toutput.writeBoolean(true);\n\t\t\toutput.writeItemIdentifierStack(stack);\n\t\t}\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new ItemAmountSignUpdatePacket(getId());\n\t}\n}",
    "code_after_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate ItemIdentifierStack stack = null;\n\n\tpublic ItemAmountSignUpdatePacket(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tLogisticsTileGenericPipe pipe = this.getPipe(player.getEntityWorld());\n\t\tif (pipe == null || !pipe.isInitialized()) {\n\t\t\treturn;\n\t\t}\n\n\t\tIPipeSign sign = ((CoreRoutedPipe) pipe.pipe).getPipeSign(ForgeDirection.getOrientation(getInteger()));\n\t\tif (sign == null) {\n\t\t\treturn;\n\t\t}\n\t\t((ItemAmountPipeSign) sign).amount = getInteger2();\n\t\t((ItemAmountPipeSign) sign).itemTypeInv.setInventorySlotContents(0, stack);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tsuper.readData(input);\n\t\tif (input.readBoolean()) {\n\t\t\tstack = input.readItemIdentifierStack();\n\t\t}\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\tsuper.writeData(output);\n\t\tif (stack == null) {\n\t\t\toutput.writeBoolean(false);\n\t\t} else {\n\t\t\toutput.writeBoolean(true);\n\t\t\toutput.writeItemIdentifierStack(stack);\n\t\t}\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new ItemAmountSignUpdatePacket(getId());\n\t}\n}",
    "patch": "@@ -1,7 +1,5 @@\n package logisticspipes.network.packets.pipe;\n \n-import java.io.IOException;\n-\n import net.minecraft.entity.player.EntityPlayer;\n import net.minecraftforge.common.util.ForgeDirection;\n \n@@ -44,15 +42,15 @@ public void processPacket(EntityPlayer player) {\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tsuper.readData(input);\n \t\tif (input.readBoolean()) {\n \t\t\tstack = input.readItemIdentifierStack();\n \t\t}\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\tsuper.writeData(output);\n \t\tif (stack == null) {\n \t\t\toutput.writeBoolean(false);",
    "function_modified_lines": {
      "added": [
        "\tpublic void readData(LPDataInput input) {\n",
        "\tpublic void writeData(LPDataOutput output) {\n"
      ],
      "deleted": [
        "\tpublic void readData(LPDataInput input) throws IOException {\n",
        "\tpublic void writeData(LPDataOutput output) throws IOException {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12814
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "{\n\n\tpublic ItemBufferSyncPacket(int id, int x, int y, int z) {\n\t\tsuper(id, x, y, z);\n\t}\n\n\tpublic ItemBufferSyncPacket(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void writeObject(LPDataOutput output,\n\t\t\tTriplet<ItemIdentifierStack, Pair<Integer /* Time */, Integer /* BufferCounter */>, LPTravelingItemServer> object) throws IOException {\n\t\toutput.writeItemIdentifierStack(object.getValue1());\n\t}\n\n\t@Override\n\tpublic Triplet<ItemIdentifierStack, Pair<Integer /* Time */, Integer /* BufferCounter */>, LPTravelingItemServer> readObject(LPDataInput input)\n\t\t\tthrows IOException {\n\t\treturn new Triplet<>(input.readItemIdentifierStack(), null, null);\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tLogisticsTileGenericPipe pipe = this.getPipe(player.getEntityWorld());\n\t\tif (pipe == null || pipe.pipe == null || pipe.pipe.transport == null) {\n\t\t\treturn;\n\t\t}\n\t\tpipe.pipe.transport._itemBuffer.clear();\n\t\tpipe.pipe.transport._itemBuffer.addAll(getList());\n\t}\n\n\t@Override\n\tpublic ItemBufferSyncPacket template() {\n\t\treturn new ItemBufferSyncPacket(getId(), getPosX(), getPosY(), getPosZ());\n\t}\n}",
    "code_after_change": "{\n\n\tpublic ItemBufferSyncPacket(int id, int x, int y, int z) {\n\t\tsuper(id, x, y, z);\n\t}\n\n\tpublic ItemBufferSyncPacket(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void writeObject(LPDataOutput output,\n\t\t\tTriplet<ItemIdentifierStack, Pair<Integer /* Time */, Integer /* BufferCounter */>, LPTravelingItemServer> object) {\n\t\toutput.writeItemIdentifierStack(object.getValue1());\n\t}\n\n\t@Override\n\tpublic Triplet<ItemIdentifierStack, Pair<Integer /* Time */, Integer /* BufferCounter */>, LPTravelingItemServer> readObject(LPDataInput input) {\n\t\treturn new Triplet<>(input.readItemIdentifierStack(), null, null);\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tLogisticsTileGenericPipe pipe = this.getPipe(player.getEntityWorld());\n\t\tif (pipe == null || pipe.pipe == null || pipe.pipe.transport == null) {\n\t\t\treturn;\n\t\t}\n\t\tpipe.pipe.transport._itemBuffer.clear();\n\t\tpipe.pipe.transport._itemBuffer.addAll(getList());\n\t}\n\n\t@Override\n\tpublic ItemBufferSyncPacket template() {\n\t\treturn new ItemBufferSyncPacket(getId(), getPosX(), getPosY(), getPosZ());\n\t}\n}",
    "patch": "@@ -1,7 +1,5 @@\n package logisticspipes.network.packets.pipe;\n \n-import java.io.IOException;\n-\n import net.minecraft.entity.player.EntityPlayer;\n \n import logisticspipes.network.abstractpackets.ListSyncPacket;\n@@ -26,13 +24,12 @@ public ItemBufferSyncPacket(int id) {\n \n \t@Override\n \tpublic void writeObject(LPDataOutput output,\n-\t\t\tTriplet<ItemIdentifierStack, Pair<Integer /* Time */, Integer /* BufferCounter */>, LPTravelingItemServer> object) throws IOException {\n+\t\t\tTriplet<ItemIdentifierStack, Pair<Integer /* Time */, Integer /* BufferCounter */>, LPTravelingItemServer> object) {\n \t\toutput.writeItemIdentifierStack(object.getValue1());\n \t}\n \n \t@Override\n-\tpublic Triplet<ItemIdentifierStack, Pair<Integer /* Time */, Integer /* BufferCounter */>, LPTravelingItemServer> readObject(LPDataInput input)\n-\t\t\tthrows IOException {\n+\tpublic Triplet<ItemIdentifierStack, Pair<Integer /* Time */, Integer /* BufferCounter */>, LPTravelingItemServer> readObject(LPDataInput input) {\n \t\treturn new Triplet<>(input.readItemIdentifierStack(), null, null);\n \t}\n ",
    "function_modified_lines": {
      "added": [
        "\t\t\tTriplet<ItemIdentifierStack, Pair<Integer /* Time */, Integer /* BufferCounter */>, LPTravelingItemServer> object) {\n",
        "\tpublic Triplet<ItemIdentifierStack, Pair<Integer /* Time */, Integer /* BufferCounter */>, LPTravelingItemServer> readObject(LPDataInput input) {\n"
      ],
      "deleted": [
        "\t\t\tTriplet<ItemIdentifierStack, Pair<Integer /* Time */, Integer /* BufferCounter */>, LPTravelingItemServer> object) throws IOException {\n",
        "\tpublic Triplet<ItemIdentifierStack, Pair<Integer /* Time */, Integer /* BufferCounter */>, LPTravelingItemServer> readObject(LPDataInput input)\n",
        "\t\t\tthrows IOException {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12815
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "{\n\n\tpublic ParticleFX(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Getter\n\t@Setter\n\t@NonNull\n\tprivate Collection<ParticleCount> particles;\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new ParticleFX(getId());\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tsuper.readData(input);\n\t\tint nparticles = input.readInt();\n\t\tparticles = new ArrayList<>(nparticles);\n\t\tfor (int i = 0; i < nparticles; i++) {\n\t\t\tint particle = input.readByte();\n\t\t\tint amount = input.readInt();\n\t\t\tparticles.add(new ParticleCount(Particles.values()[particle], amount));\n\t\t}\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\tsuper.writeData(output);\n\t\toutput.writeInt(particles.size());\n\t\tfor (ParticleCount pc : particles) {\n\t\t\toutput.writeByte(pc.getParticle().ordinal());\n\t\t\toutput.writeInt(pc.getAmount());\n\t\t}\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tif (!Minecraft.isFancyGraphicsEnabled()) {\n\t\t\treturn;\n\t\t}\n\t\tfor (ParticleCount pc : particles) {\n\t\t\tPipeFXRenderHandler.spawnGenericParticle(pc.getParticle(), getPosX(), getPosY(), getPosZ(), pc.getAmount());\n\t\t}\n\t}\n}",
    "code_after_change": "{\n\n\t@Getter\n\t@Setter\n\t@NonNull\n\tprivate Collection<ParticleCount> particles;\n\n\tpublic ParticleFX(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new ParticleFX(getId());\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tsuper.readData(input);\n\t\tint nparticles = input.readInt();\n\t\tparticles = new ArrayList<>(nparticles);\n\t\tfor (int i = 0; i < nparticles; i++) {\n\t\t\tint particle = input.readByte();\n\t\t\tint amount = input.readInt();\n\t\t\tparticles.add(new ParticleCount(Particles.values()[particle], amount));\n\t\t}\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\tsuper.writeData(output);\n\t\toutput.writeInt(particles.size());\n\t\tfor (ParticleCount pc : particles) {\n\t\t\toutput.writeByte(pc.getParticle().ordinal());\n\t\t\toutput.writeInt(pc.getAmount());\n\t\t}\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tif (!Minecraft.isFancyGraphicsEnabled()) {\n\t\t\treturn;\n\t\t}\n\t\tfor (ParticleCount pc : particles) {\n\t\t\tPipeFXRenderHandler.spawnGenericParticle(pc.getParticle(), getPosX(), getPosY(), getPosZ(), pc.getAmount());\n\t\t}\n\t}\n}",
    "patch": "@@ -1,6 +1,5 @@\n package logisticspipes.network.packets.pipe;\n \n-import java.io.IOException;\n import java.util.ArrayList;\n import java.util.Collection;\n \n@@ -21,22 +20,22 @@\n \n public class ParticleFX extends CoordinatesPacket {\n \n-\tpublic ParticleFX(int id) {\n-\t\tsuper(id);\n-\t}\n-\n \t@Getter\n \t@Setter\n \t@NonNull\n \tprivate Collection<ParticleCount> particles;\n \n+\tpublic ParticleFX(int id) {\n+\t\tsuper(id);\n+\t}\n+\n \t@Override\n \tpublic ModernPacket template() {\n \t\treturn new ParticleFX(getId());\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tsuper.readData(input);\n \t\tint nparticles = input.readInt();\n \t\tparticles = new ArrayList<>(nparticles);\n@@ -48,7 +47,7 @@ public void readData(LPDataInput input) throws IOException {\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\tsuper.writeData(output);\n \t\toutput.writeInt(particles.size());\n \t\tfor (ParticleCount pc : particles) {",
    "function_modified_lines": {
      "added": [
        "\tpublic ParticleFX(int id) {\n",
        "\t\tsuper(id);\n",
        "\t}\n",
        "\n",
        "\tpublic void readData(LPDataInput input) {\n",
        "\tpublic void writeData(LPDataOutput output) {\n"
      ],
      "deleted": [
        "\tpublic ParticleFX(int id) {\n",
        "\t\tsuper(id);\n",
        "\t}\n",
        "\n",
        "\tpublic void readData(LPDataInput input) throws IOException {\n",
        "\tpublic void writeData(LPDataOutput output) throws IOException {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12816
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "{\n\n\tpublic PipeContentPacket(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Getter\n\t@Setter\n\tprivate ItemIdentifierStack item;\n\t@Getter\n\t@Setter\n\tprivate int travelId;\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\titem = input.readItemIdentifierStack();\n\t\ttravelId = input.readInt();\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tWeakReference<LPTravelingItemClient> ref = LPTravelingItem.clientList.get(travelId);\n\t\tLPTravelingItemClient content = null;\n\t\tif (ref != null) {\n\t\t\tcontent = ref.get();\n\t\t}\n\t\tif (content == null) {\n\t\t\tcontent = new LPTravelingItemClient(travelId, item);\n\t\t\tLPTravelingItem.clientList.put(travelId, new WeakReference<>(content));\n\t\t\tsynchronized (LPTravelingItem.forceKeep) {\n\t\t\t\tLPTravelingItem.forceKeep.add(new Pair<>(10, content)); //Keep in memory for min 10 ticks\n\t\t\t}\n\t\t} else {\n\t\t\tcontent.setItem(item);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\toutput.writeItemIdentifierStack(item);\n\t\toutput.writeInt(travelId);\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new PipeContentPacket(getId());\n\t}\n}",
    "code_after_change": "public class PipeContentPacket extends ModernPacket {\n\n\t@Getter\n\t@Setter\n\tprivate ItemIdentifierStack item;\n\t@Getter\n\t@Setter\n\tprivate int travelId;\n\n\tpublic PipeContentPacket(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\titem = input.readItemIdentifierStack();\n\t\ttravelId = input.readInt();\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tWeakReference<LPTravelingItemClient> ref = LPTravelingItem.clientList.get(travelId);\n\t\tLPTravelingItemClient content = null;\n\t\tif (ref != null) {\n\t\t\tcontent = ref.get();\n\t\t}\n\t\tif (content == null) {\n\t\t\tcontent = new LPTravelingItemClient(travelId, item);\n\t\t\tLPTravelingItem.clientList.put(travelId, new WeakReference<>(content));\n\t\t\tsynchronized (LPTravelingItem.forceKeep) {\n\t\t\t\tLPTravelingItem.forceKeep.add(new Pair<>(10, content)); //Keep in memory for min 10 ticks\n\t\t\t}\n\t\t} else {\n\t\t\tcontent.setItem(item);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\toutput.writeItemIdentifierStack(item);\n\t\toutput.writeInt(travelId);\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new PipeContentPacket(getId());\n\t}\n}",
    "patch": "@@ -1,6 +1,5 @@\n package logisticspipes.network.packets.pipe;\n \n-import java.io.IOException;\n import java.lang.ref.WeakReference;\n \n import net.minecraft.entity.player.EntityPlayer;\n@@ -18,19 +17,19 @@\n \n public class PipeContentPacket extends ModernPacket {\n \n-\tpublic PipeContentPacket(int id) {\n-\t\tsuper(id);\n-\t}\n-\n \t@Getter\n \t@Setter\n \tprivate ItemIdentifierStack item;\n \t@Getter\n \t@Setter\n \tprivate int travelId;\n \n+\tpublic PipeContentPacket(int id) {\n+\t\tsuper(id);\n+\t}\n+\n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\titem = input.readItemIdentifierStack();\n \t\ttravelId = input.readInt();\n \t}\n@@ -54,7 +53,7 @@ public void processPacket(EntityPlayer player) {\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\toutput.writeItemIdentifierStack(item);\n \t\toutput.writeInt(travelId);\n \t}",
    "function_modified_lines": {
      "added": [
        "\tpublic PipeContentPacket(int id) {\n",
        "\t\tsuper(id);\n",
        "\t}\n",
        "\n",
        "\tpublic void readData(LPDataInput input) {\n"
      ],
      "deleted": [
        "\tpublic PipeContentPacket(int id) {\n",
        "\t\tsuper(id);\n",
        "\t}\n",
        "\n",
        "\tpublic void readData(LPDataInput input) throws IOException {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12817
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate boolean start;\n\n\tpublic PipeManagerWatchingPacket(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tLogisticsTileGenericPipe pipe = this.getPipe(player.getEntityWorld());\n\t\tif (pipe == null || !(pipe.pipe instanceof CoreRoutedPipe)) {\n\t\t\treturn;\n\t\t}\n\t\tCoreRoutedPipe cPipe = (CoreRoutedPipe) pipe.pipe;\n\t\tif (start) {\n\t\t\tcPipe.getOrderManager().startWatching(player);\n\t\t} else {\n\t\t\tcPipe.getOrderManager().stopWatching(player);\n\t\t}\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new PipeManagerWatchingPacket(getId());\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\tsuper.writeData(output);\n\t\toutput.writeBoolean(start);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tsuper.readData(input);\n\t\tstart = input.readBoolean();\n\t}\n}",
    "code_after_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate boolean start;\n\n\tpublic PipeManagerWatchingPacket(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tLogisticsTileGenericPipe pipe = this.getPipe(player.getEntityWorld());\n\t\tif (pipe == null || !(pipe.pipe instanceof CoreRoutedPipe)) {\n\t\t\treturn;\n\t\t}\n\t\tCoreRoutedPipe cPipe = (CoreRoutedPipe) pipe.pipe;\n\t\tif (start) {\n\t\t\tcPipe.getOrderManager().startWatching(player);\n\t\t} else {\n\t\t\tcPipe.getOrderManager().stopWatching(player);\n\t\t}\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new PipeManagerWatchingPacket(getId());\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\tsuper.writeData(output);\n\t\toutput.writeBoolean(start);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tsuper.readData(input);\n\t\tstart = input.readBoolean();\n\t}\n}",
    "patch": "@@ -1,7 +1,5 @@\n package logisticspipes.network.packets.pipe;\n \n-import java.io.IOException;\n-\n import net.minecraft.entity.player.EntityPlayer;\n \n import lombok.Getter;\n@@ -44,13 +42,13 @@ public ModernPacket template() {\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\tsuper.writeData(output);\n \t\toutput.writeBoolean(start);\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tsuper.readData(input);\n \t\tstart = input.readBoolean();\n \t}",
    "function_modified_lines": {
      "added": [
        "\tpublic void writeData(LPDataOutput output) {\n",
        "\tpublic void readData(LPDataInput input) {\n"
      ],
      "deleted": [
        "\tpublic void writeData(LPDataOutput output) throws IOException {\n",
        "\tpublic void readData(LPDataInput input) throws IOException {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12818
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "{\n\n\tpublic PipeSignTypes(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Getter\n\t@Setter\n\tprivate List<Integer> types;\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tLogisticsTileGenericPipe pipe = this.getPipe(player.getEntityWorld(), LTGPCompletionCheck.PIPE);\n\t\tif (pipe == null || !pipe.isInitialized()) {\n\t\t\treturn;\n\t\t}\n\t\t((CoreRoutedPipe) pipe.pipe).handleSignPacket(types);\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\tsuper.writeData(output);\n\t\toutput.writeCollection(types, LPDataOutput::writeInt);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tsuper.readData(input);\n\t\ttypes = input.readArrayList(LPDataInput::readInt);\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new PipeSignTypes(getId());\n\t}\n}",
    "code_after_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate List<Integer> types;\n\n\tpublic PipeSignTypes(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tLogisticsTileGenericPipe pipe = this.getPipe(player.getEntityWorld(), LTGPCompletionCheck.PIPE);\n\t\tif (pipe == null || !pipe.isInitialized()) {\n\t\t\treturn;\n\t\t}\n\t\t((CoreRoutedPipe) pipe.pipe).handleSignPacket(types);\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\tsuper.writeData(output);\n\t\toutput.writeCollection(types, LPDataOutput::writeInt);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tsuper.readData(input);\n\t\ttypes = input.readArrayList(LPDataInput::readInt);\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new PipeSignTypes(getId());\n\t}\n}",
    "patch": "@@ -1,6 +1,5 @@\n package logisticspipes.network.packets.pipe;\n \n-import java.io.IOException;\n import java.util.List;\n \n import net.minecraft.entity.player.EntityPlayer;\n@@ -17,14 +16,14 @@\n \n public class PipeSignTypes extends CoordinatesPacket {\n \n-\tpublic PipeSignTypes(int id) {\n-\t\tsuper(id);\n-\t}\n-\n \t@Getter\n \t@Setter\n \tprivate List<Integer> types;\n \n+\tpublic PipeSignTypes(int id) {\n+\t\tsuper(id);\n+\t}\n+\n \t@Override\n \tpublic void processPacket(EntityPlayer player) {\n \t\tLogisticsTileGenericPipe pipe = this.getPipe(player.getEntityWorld(), LTGPCompletionCheck.PIPE);\n@@ -35,13 +34,13 @@ public void processPacket(EntityPlayer player) {\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\tsuper.writeData(output);\n \t\toutput.writeCollection(types, LPDataOutput::writeInt);\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tsuper.readData(input);\n \t\ttypes = input.readArrayList(LPDataInput::readInt);\n \t}",
    "function_modified_lines": {
      "added": [
        "\tpublic PipeSignTypes(int id) {\n",
        "\t\tsuper(id);\n",
        "\t}\n",
        "\n",
        "\tpublic void writeData(LPDataOutput output) {\n",
        "\tpublic void readData(LPDataInput input) {\n"
      ],
      "deleted": [
        "\tpublic PipeSignTypes(int id) {\n",
        "\t\tsuper(id);\n",
        "\t}\n",
        "\n",
        "\tpublic void writeData(LPDataOutput output) throws IOException {\n",
        "\tpublic void readData(LPDataInput input) throws IOException {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12819
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate int pipePosX;\n\t@Getter\n\t@Setter\n\tprivate int pipePosY;\n\t@Getter\n\t@Setter\n\tprivate int pipePosZ;\n\t@Setter\n\tprivate int inventorySlot;\n\t@Getter\n\t@Setter\n\tprivate int slot;\n\n\tpublic SlotFinderNumberPacket(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new SlotFinderNumberPacket(getId());\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic void processPacket(EntityPlayer player) {\n\t\tIInventory inv = this.getTile(player.worldObj, IInventory.class);\n\t\tif (inv instanceof ISidedInventory) {\n\t\t\tinv = new SidedInventoryMinecraftAdapter((ISidedInventory) inv, ForgeDirection.UNKNOWN, false);\n\t\t}\n\t\tIInventoryUtil util = SimpleServiceLocator.inventoryUtilFactory.getInventoryUtil(inv);\n\t\tSlot result = null;\n\t\tif (((List<Slot>) player.openContainer.inventorySlots).get(inventorySlot).slotNumber == inventorySlot) {\n\t\t\tresult = ((List<Slot>) player.openContainer.inventorySlots).get(inventorySlot);\n\t\t}\n\t\tif (result == null) {\n\t\t\tfor (Slot slotObject : (List<Slot>) player.openContainer.inventorySlots) {\n\t\t\t\tif (slotObject.slotNumber == inventorySlot) {\n\t\t\t\t\tresult = slotObject;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (result == null) {\n\t\t\tplayer.addChatComponentMessage(new ChatComponentTranslation(\"lp.chat.slotnotfound\"));\n\t\t}\n\t\tint resultIndex = -1;\n\t\tif (resultIndex == -1) {\n\t\t\tItemStack content = result.getStack();\n\t\t\tif (content != null) {\n\t\t\t\tfor (int i = 0; i < util.getSizeInventory(); i++) {\n\t\t\t\t\tif (content == util.getStackInSlot(i)) {\n\t\t\t\t\t\tresultIndex = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tItemStack dummyStack = new ItemStack(Blocks.stone, 0, 0);\n\t\t\t\tNBTTagCompound nbt = new NBTTagCompound();\n\t\t\t\tnbt.setBoolean(\"LPStackFinderBoolean\", true); //Make it unique\n\t\t\t\tdummyStack.setTagCompound(nbt);\n\t\t\t\tresult.putStack(dummyStack);\n\t\t\t\tfor (int i = 0; i < util.getSizeInventory(); i++) {\n\t\t\t\t\tif (dummyStack == util.getStackInSlot(i)) {\n\t\t\t\t\t\tresultIndex = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (resultIndex == -1) {\n\t\t\t\t\tfor (int i = 0; i < util.getSizeInventory(); i++) {\n\t\t\t\t\t\tItemStack stack = util.getStackInSlot(i);\n\t\t\t\t\t\tif (stack == null) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ItemIdentifier.get(stack).equals(ItemIdentifier.get(dummyStack)) && stack.stackSize == dummyStack.stackSize) {\n\t\t\t\t\t\t\tresultIndex = i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresult.putStack(null);\n\t\t\t}\n\t\t}\n\t\tif (resultIndex == -1) {\n\t\t\tplayer.addChatComponentMessage(new ChatComponentTranslation(\"lp.chat.slotnotfound\"));\n\t\t} else {\n\t\t\t//Copy pipe to coordinates to use the getPipe method\n\t\t\tsetPosX(getPipePosX());\n\t\t\tsetPosY(getPipePosY());\n\t\t\tsetPosZ(getPipePosZ());\n\t\t\tModuleActiveSupplier module = this.getLogisticsModule(player, ModuleActiveSupplier.class);\n\t\t\tif (module != null) {\n\t\t\t\tmodule.slotArray[slot] = resultIndex;\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\tsuper.writeData(output);\n\t\toutput.writeInt(inventorySlot);\n\t\toutput.writeInt(slot);\n\t\toutput.writeInt(pipePosX);\n\t\toutput.writeInt(pipePosY);\n\t\toutput.writeInt(pipePosZ);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tsuper.readData(input);\n\t\tinventorySlot = input.readInt();\n\t\tslot = input.readInt();\n\t\tpipePosX = input.readInt();\n\t\tpipePosY = input.readInt();\n\t\tpipePosZ = input.readInt();\n\t}\n}",
    "code_after_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate int pipePosX;\n\t@Getter\n\t@Setter\n\tprivate int pipePosY;\n\t@Getter\n\t@Setter\n\tprivate int pipePosZ;\n\t@Setter\n\tprivate int inventorySlot;\n\t@Getter\n\t@Setter\n\tprivate int slot;\n\n\tpublic SlotFinderNumberPacket(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new SlotFinderNumberPacket(getId());\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic void processPacket(EntityPlayer player) {\n\t\tIInventory inv = this.getTile(player.worldObj, IInventory.class);\n\t\tif (inv instanceof ISidedInventory) {\n\t\t\tinv = new SidedInventoryMinecraftAdapter((ISidedInventory) inv, ForgeDirection.UNKNOWN, false);\n\t\t}\n\t\tIInventoryUtil util = SimpleServiceLocator.inventoryUtilFactory.getInventoryUtil(inv);\n\t\tSlot result = null;\n\t\tif (((List<Slot>) player.openContainer.inventorySlots).get(inventorySlot).slotNumber == inventorySlot) {\n\t\t\tresult = ((List<Slot>) player.openContainer.inventorySlots).get(inventorySlot);\n\t\t}\n\t\tif (result == null) {\n\t\t\tfor (Slot slotObject : (List<Slot>) player.openContainer.inventorySlots) {\n\t\t\t\tif (slotObject.slotNumber == inventorySlot) {\n\t\t\t\t\tresult = slotObject;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (result == null) {\n\t\t\tplayer.addChatComponentMessage(new ChatComponentTranslation(\"lp.chat.slotnotfound\"));\n\t\t}\n\t\tint resultIndex = -1;\n\t\tif (resultIndex == -1) {\n\t\t\tItemStack content = result.getStack();\n\t\t\tif (content != null) {\n\t\t\t\tfor (int i = 0; i < util.getSizeInventory(); i++) {\n\t\t\t\t\tif (content == util.getStackInSlot(i)) {\n\t\t\t\t\t\tresultIndex = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tItemStack dummyStack = new ItemStack(Blocks.stone, 0, 0);\n\t\t\t\tNBTTagCompound nbt = new NBTTagCompound();\n\t\t\t\tnbt.setBoolean(\"LPStackFinderBoolean\", true); //Make it unique\n\t\t\t\tdummyStack.setTagCompound(nbt);\n\t\t\t\tresult.putStack(dummyStack);\n\t\t\t\tfor (int i = 0; i < util.getSizeInventory(); i++) {\n\t\t\t\t\tif (dummyStack == util.getStackInSlot(i)) {\n\t\t\t\t\t\tresultIndex = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (resultIndex == -1) {\n\t\t\t\t\tfor (int i = 0; i < util.getSizeInventory(); i++) {\n\t\t\t\t\t\tItemStack stack = util.getStackInSlot(i);\n\t\t\t\t\t\tif (stack == null) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ItemIdentifier.get(stack).equals(ItemIdentifier.get(dummyStack)) && stack.stackSize == dummyStack.stackSize) {\n\t\t\t\t\t\t\tresultIndex = i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresult.putStack(null);\n\t\t\t}\n\t\t}\n\t\tif (resultIndex == -1) {\n\t\t\tplayer.addChatComponentMessage(new ChatComponentTranslation(\"lp.chat.slotnotfound\"));\n\t\t} else {\n\t\t\t//Copy pipe to coordinates to use the getPipe method\n\t\t\tsetPosX(getPipePosX());\n\t\t\tsetPosY(getPipePosY());\n\t\t\tsetPosZ(getPipePosZ());\n\t\t\tModuleActiveSupplier module = this.getLogisticsModule(player, ModuleActiveSupplier.class);\n\t\t\tif (module != null) {\n\t\t\t\tmodule.slotArray[slot] = resultIndex;\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\tsuper.writeData(output);\n\t\toutput.writeInt(inventorySlot);\n\t\toutput.writeInt(slot);\n\t\toutput.writeInt(pipePosX);\n\t\toutput.writeInt(pipePosY);\n\t\toutput.writeInt(pipePosZ);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tsuper.readData(input);\n\t\tinventorySlot = input.readInt();\n\t\tslot = input.readInt();\n\t\tpipePosX = input.readInt();\n\t\tpipePosY = input.readInt();\n\t\tpipePosZ = input.readInt();\n\t}\n}",
    "patch": "@@ -1,6 +1,5 @@\n package logisticspipes.network.packets.pipe;\n \n-import java.io.IOException;\n import java.util.List;\n \n import net.minecraft.entity.player.EntityPlayer;\n@@ -127,7 +126,7 @@ public void processPacket(EntityPlayer player) {\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\tsuper.writeData(output);\n \t\toutput.writeInt(inventorySlot);\n \t\toutput.writeInt(slot);\n@@ -137,7 +136,7 @@ public void writeData(LPDataOutput output) throws IOException {\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tsuper.readData(input);\n \t\tinventorySlot = input.readInt();\n \t\tslot = input.readInt();",
    "function_modified_lines": {
      "added": [
        "\tpublic void writeData(LPDataOutput output) {\n",
        "\tpublic void readData(LPDataInput input) {\n"
      ],
      "deleted": [
        "\tpublic void writeData(LPDataOutput output) throws IOException {\n",
        "\tpublic void readData(LPDataInput input) throws IOException {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12820
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate int slot;\n\n\tpublic SlotFinderOpenGuiPacket(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\t//hack to avoid wrenching blocks\n\t\tint savedEquipped = player.inventory.currentItem;\n\t\tboolean foundSlot = false;\n\t\t//try to find a empty slot\n\t\tfor (int i = 0; i < 9; i++) {\n\t\t\tif (player.inventory.getStackInSlot(i) == null) {\n\t\t\t\tfoundSlot = true;\n\t\t\t\tplayer.inventory.currentItem = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t//okay, anything that's a block?\n\t\tif (!foundSlot) {\n\t\t\tfor (int i = 0; i < 9; i++) {\n\t\t\t\tItemStack is = player.inventory.getStackInSlot(i);\n\t\t\t\tif (is.getItem() instanceof ItemBlock) {\n\t\t\t\t\tfoundSlot = true;\n\t\t\t\t\tplayer.inventory.currentItem = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//give up and select whatever is right of the current slot\n\t\tif (!foundSlot) {\n\t\t\tplayer.inventory.currentItem = (player.inventory.currentItem + 1) % 9;\n\t\t}\n\n\t\tWorldCoordinatesWrapper worldCoordinates = new WorldCoordinatesWrapper(player.worldObj, getPosX(), getPosY(), getPosZ());\n\t\tIterator<AdjacentTileEntity> adjacentIt = worldCoordinates.getConnectedAdjacentTileEntities(ConnectionPipeType.ITEM).iterator();\n\n\t\tboolean found = false;\n\t\twhile (adjacentIt.hasNext()) {\n\t\t\tAdjacentTileEntity adjacent = adjacentIt.next();\n\n\t\t\tif (adjacent.tileEntity instanceof IInventory) {\n\t\t\t\tif (!(SimpleServiceLocator.inventoryUtilFactory.getInventoryUtil((IInventory) adjacent.tileEntity) instanceof ISpecialInsertion)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (ICraftingRecipeProvider provider : SimpleServiceLocator.craftingRecipeProviders) {\n\t\t\t\tif (provider.canOpenGui(adjacent.tileEntity)) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!found) {\n\t\t\t\tfound = (adjacent.tileEntity instanceof IInventory);\n\t\t\t}\n\n\t\t\tif (found) {\n\t\t\t\tBlock block = adjacent.tileEntity.getBlockType();\n\t\t\t\tint xCoord = adjacent.tileEntity.xCoord;\n\t\t\t\tint yCoord = adjacent.tileEntity.yCoord;\n\t\t\t\tint zCoord = adjacent.tileEntity.zCoord;\n\n\t\t\t\tif (SimpleServiceLocator.enderStorageProxy.isEnderChestBlock(block)) {\n\t\t\t\t\tSimpleServiceLocator.enderStorageProxy.openEnderChest(player.worldObj, xCoord, yCoord, zCoord, player);\n\t\t\t\t\t//@formatter:off\n\t\t\t\t\tMainProxy.sendPacketToPlayer(PacketHandler.getPacket(SlotFinderActivatePacket.class)\n\t\t\t\t\t\t\t.setTagetPosX(xCoord).setTagetPosY(yCoord).setTagetPosZ(zCoord).setSlot(getSlot()).setPacketPos(this), player);\n\t\t\t\t\t//@formatter:on\n\t\t\t\t}\n\n\t\t\t\tif (block != null) {\n\t\t\t\t\tif (block.onBlockActivated(player.worldObj, xCoord, yCoord, zCoord, player, 0, 0, 0, 0)) {\n\t\t\t\t\t\t//@formatter:off\n\t\t\t\t\t\tMainProxy.sendPacketToPlayer(PacketHandler.getPacket(SlotFinderActivatePacket.class)\n\t\t\t\t\t\t\t\t.setTagetPosX(xCoord).setTagetPosY(yCoord).setTagetPosZ(zCoord).setSlot(getSlot()).setPacketPos(this), player);\n\t\t\t\t\t\t//@formatter:on\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tplayer.inventory.currentItem = savedEquipped;\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new SlotFinderOpenGuiPacket(getId());\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\tsuper.writeData(output);\n\t\toutput.writeInt(slot);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tsuper.readData(input);\n\t\tslot = input.readInt();\n\t}\n}",
    "code_after_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate int slot;\n\n\tpublic SlotFinderOpenGuiPacket(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\t//hack to avoid wrenching blocks\n\t\tint savedEquipped = player.inventory.currentItem;\n\t\tboolean foundSlot = false;\n\t\t//try to find a empty slot\n\t\tfor (int i = 0; i < 9; i++) {\n\t\t\tif (player.inventory.getStackInSlot(i) == null) {\n\t\t\t\tfoundSlot = true;\n\t\t\t\tplayer.inventory.currentItem = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t//okay, anything that's a block?\n\t\tif (!foundSlot) {\n\t\t\tfor (int i = 0; i < 9; i++) {\n\t\t\t\tItemStack is = player.inventory.getStackInSlot(i);\n\t\t\t\tif (is.getItem() instanceof ItemBlock) {\n\t\t\t\t\tfoundSlot = true;\n\t\t\t\t\tplayer.inventory.currentItem = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//give up and select whatever is right of the current slot\n\t\tif (!foundSlot) {\n\t\t\tplayer.inventory.currentItem = (player.inventory.currentItem + 1) % 9;\n\t\t}\n\n\t\tWorldCoordinatesWrapper worldCoordinates = new WorldCoordinatesWrapper(player.worldObj, getPosX(), getPosY(), getPosZ());\n\t\tIterator<AdjacentTileEntity> adjacentIt = worldCoordinates.getConnectedAdjacentTileEntities(ConnectionPipeType.ITEM).iterator();\n\n\t\tboolean found = false;\n\t\twhile (adjacentIt.hasNext()) {\n\t\t\tAdjacentTileEntity adjacent = adjacentIt.next();\n\n\t\t\tif (adjacent.tileEntity instanceof IInventory) {\n\t\t\t\tif (!(SimpleServiceLocator.inventoryUtilFactory.getInventoryUtil((IInventory) adjacent.tileEntity) instanceof ISpecialInsertion)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (ICraftingRecipeProvider provider : SimpleServiceLocator.craftingRecipeProviders) {\n\t\t\t\tif (provider.canOpenGui(adjacent.tileEntity)) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!found) {\n\t\t\t\tfound = (adjacent.tileEntity instanceof IInventory);\n\t\t\t}\n\n\t\t\tif (found) {\n\t\t\t\tBlock block = adjacent.tileEntity.getBlockType();\n\t\t\t\tint xCoord = adjacent.tileEntity.xCoord;\n\t\t\t\tint yCoord = adjacent.tileEntity.yCoord;\n\t\t\t\tint zCoord = adjacent.tileEntity.zCoord;\n\n\t\t\t\tif (SimpleServiceLocator.enderStorageProxy.isEnderChestBlock(block)) {\n\t\t\t\t\tSimpleServiceLocator.enderStorageProxy.openEnderChest(player.worldObj, xCoord, yCoord, zCoord, player);\n\t\t\t\t\t//@formatter:off\n\t\t\t\t\tMainProxy.sendPacketToPlayer(PacketHandler.getPacket(SlotFinderActivatePacket.class)\n\t\t\t\t\t\t\t.setTagetPosX(xCoord).setTagetPosY(yCoord).setTagetPosZ(zCoord).setSlot(getSlot()).setPacketPos(this), player);\n\t\t\t\t\t//@formatter:on\n\t\t\t\t}\n\n\t\t\t\tif (block != null) {\n\t\t\t\t\tif (block.onBlockActivated(player.worldObj, xCoord, yCoord, zCoord, player, 0, 0, 0, 0)) {\n\t\t\t\t\t\t//@formatter:off\n\t\t\t\t\t\tMainProxy.sendPacketToPlayer(PacketHandler.getPacket(SlotFinderActivatePacket.class)\n\t\t\t\t\t\t\t\t.setTagetPosX(xCoord).setTagetPosY(yCoord).setTagetPosZ(zCoord).setSlot(getSlot()).setPacketPos(this), player);\n\t\t\t\t\t\t//@formatter:on\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tplayer.inventory.currentItem = savedEquipped;\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new SlotFinderOpenGuiPacket(getId());\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\tsuper.writeData(output);\n\t\toutput.writeInt(slot);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tsuper.readData(input);\n\t\tslot = input.readInt();\n\t}\n}",
    "patch": "@@ -1,6 +1,5 @@\n package logisticspipes.network.packets.pipe;\n \n-import java.io.IOException;\n import java.util.Iterator;\n \n import net.minecraft.block.Block;\n@@ -122,13 +121,13 @@ public ModernPacket template() {\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\tsuper.writeData(output);\n \t\toutput.writeInt(slot);\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tsuper.readData(input);\n \t\tslot = input.readInt();\n \t}",
    "function_modified_lines": {
      "added": [
        "\tpublic void writeData(LPDataOutput output) {\n",
        "\tpublic void readData(LPDataInput input) {\n"
      ],
      "deleted": [
        "\tpublic void writeData(LPDataOutput output) throws IOException {\n",
        "\tpublic void readData(LPDataInput input) throws IOException {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12821
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "{\n\n\t@Setter\n\tprivate CoreRoutedPipe pipe;\n\tprivate int stat_session_sent;\n\tprivate int stat_session_recieved;\n\tprivate int stat_session_relayed;\n\tprivate long stat_lifetime_sent;\n\tprivate long stat_lifetime_recieved;\n\tprivate long stat_lifetime_relayed;\n\tprivate int server_routing_table_size;\n\n\tpublic StatUpdate(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new StatUpdate(getId());\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tfinal LogisticsTileGenericPipe pipe = this.getPipe(player.worldObj);\n\t\tif (pipe == null) {\n\t\t\treturn;\n\t\t}\n\t\tif (!(pipe.pipe instanceof CoreRoutedPipe)) {\n\t\t\treturn;\n\t\t}\n\t\tCoreRoutedPipe cPipe = (CoreRoutedPipe) pipe.pipe;\n\t\tcPipe.stat_session_sent = stat_session_sent;\n\t\tcPipe.stat_session_recieved = stat_session_recieved;\n\t\tcPipe.stat_session_relayed = stat_session_relayed;\n\t\tcPipe.stat_lifetime_sent = stat_lifetime_sent;\n\t\tcPipe.stat_lifetime_recieved = stat_lifetime_recieved;\n\t\tcPipe.stat_lifetime_relayed = stat_lifetime_relayed;\n\t\tcPipe.server_routing_table_size = server_routing_table_size;\n\t}\n\n\tprivate void initData() {\n\t\tsetPosX(pipe.getX());\n\t\tsetPosY(pipe.getY());\n\t\tsetPosZ(pipe.getZ());\n\t\tstat_session_sent = pipe.stat_session_sent;\n\t\tstat_session_recieved = pipe.stat_session_recieved;\n\t\tstat_session_relayed = pipe.stat_session_relayed;\n\t\tstat_lifetime_sent = pipe.stat_lifetime_sent;\n\t\tstat_lifetime_recieved = pipe.stat_lifetime_recieved;\n\t\tstat_lifetime_relayed = pipe.stat_lifetime_relayed;\n\t\tint numentries = 0;\n\t\tfor (List<ExitRoute> route : pipe.getRouter().getRouteTable()) {\n\t\t\tif (route != null && !route.isEmpty()) {\n\t\t\t\t++numentries;\n\t\t\t}\n\t\t}\n\t\tserver_routing_table_size = numentries;\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\tinitData();\n\t\tsuper.writeData(output);\n\t\toutput.writeInt(stat_session_sent);\n\t\toutput.writeInt(stat_session_recieved);\n\t\toutput.writeInt(stat_session_relayed);\n\t\toutput.writeLong(stat_lifetime_sent);\n\t\toutput.writeLong(stat_lifetime_recieved);\n\t\toutput.writeLong(stat_lifetime_relayed);\n\t\toutput.writeInt(server_routing_table_size);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tsuper.readData(input);\n\t\tstat_session_sent = input.readInt();\n\t\tstat_session_recieved = input.readInt();\n\t\tstat_session_relayed = input.readInt();\n\t\tstat_lifetime_sent = input.readLong();\n\t\tstat_lifetime_recieved = input.readLong();\n\t\tstat_lifetime_relayed = input.readLong();\n\t\tserver_routing_table_size = input.readInt();\n\t}\n}",
    "code_after_change": "{\n\n\t@Setter\n\tprivate CoreRoutedPipe pipe;\n\tprivate int stat_session_sent;\n\tprivate int stat_session_recieved;\n\tprivate int stat_session_relayed;\n\tprivate long stat_lifetime_sent;\n\tprivate long stat_lifetime_recieved;\n\tprivate long stat_lifetime_relayed;\n\tprivate int server_routing_table_size;\n\n\tpublic StatUpdate(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new StatUpdate(getId());\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tfinal LogisticsTileGenericPipe pipe = this.getPipe(player.worldObj);\n\t\tif (pipe == null) {\n\t\t\treturn;\n\t\t}\n\t\tif (!(pipe.pipe instanceof CoreRoutedPipe)) {\n\t\t\treturn;\n\t\t}\n\t\tCoreRoutedPipe cPipe = (CoreRoutedPipe) pipe.pipe;\n\t\tcPipe.stat_session_sent = stat_session_sent;\n\t\tcPipe.stat_session_recieved = stat_session_recieved;\n\t\tcPipe.stat_session_relayed = stat_session_relayed;\n\t\tcPipe.stat_lifetime_sent = stat_lifetime_sent;\n\t\tcPipe.stat_lifetime_recieved = stat_lifetime_recieved;\n\t\tcPipe.stat_lifetime_relayed = stat_lifetime_relayed;\n\t\tcPipe.server_routing_table_size = server_routing_table_size;\n\t}\n\n\tprivate void initData() {\n\t\tsetPosX(pipe.getX());\n\t\tsetPosY(pipe.getY());\n\t\tsetPosZ(pipe.getZ());\n\t\tstat_session_sent = pipe.stat_session_sent;\n\t\tstat_session_recieved = pipe.stat_session_recieved;\n\t\tstat_session_relayed = pipe.stat_session_relayed;\n\t\tstat_lifetime_sent = pipe.stat_lifetime_sent;\n\t\tstat_lifetime_recieved = pipe.stat_lifetime_recieved;\n\t\tstat_lifetime_relayed = pipe.stat_lifetime_relayed;\n\t\tint numentries = 0;\n\t\tfor (List<ExitRoute> route : pipe.getRouter().getRouteTable()) {\n\t\t\tif (route != null && !route.isEmpty()) {\n\t\t\t\t++numentries;\n\t\t\t}\n\t\t}\n\t\tserver_routing_table_size = numentries;\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\tinitData();\n\t\tsuper.writeData(output);\n\t\toutput.writeInt(stat_session_sent);\n\t\toutput.writeInt(stat_session_recieved);\n\t\toutput.writeInt(stat_session_relayed);\n\t\toutput.writeLong(stat_lifetime_sent);\n\t\toutput.writeLong(stat_lifetime_recieved);\n\t\toutput.writeLong(stat_lifetime_relayed);\n\t\toutput.writeInt(server_routing_table_size);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tsuper.readData(input);\n\t\tstat_session_sent = input.readInt();\n\t\tstat_session_recieved = input.readInt();\n\t\tstat_session_relayed = input.readInt();\n\t\tstat_lifetime_sent = input.readLong();\n\t\tstat_lifetime_recieved = input.readLong();\n\t\tstat_lifetime_relayed = input.readLong();\n\t\tserver_routing_table_size = input.readInt();\n\t}\n}",
    "patch": "@@ -1,6 +1,5 @@\n package logisticspipes.network.packets.pipe;\n \n-import java.io.IOException;\n import java.util.List;\n \n import net.minecraft.entity.player.EntityPlayer;\n@@ -75,7 +74,7 @@ private void initData() {\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\tinitData();\n \t\tsuper.writeData(output);\n \t\toutput.writeInt(stat_session_sent);\n@@ -88,7 +87,7 @@ public void writeData(LPDataOutput output) throws IOException {\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tsuper.readData(input);\n \t\tstat_session_sent = input.readInt();\n \t\tstat_session_recieved = input.readInt();",
    "function_modified_lines": {
      "added": [
        "\tpublic void writeData(LPDataOutput output) {\n",
        "\tpublic void readData(LPDataInput input) {\n"
      ],
      "deleted": [
        "\tpublic void writeData(LPDataOutput output) throws IOException {\n",
        "\tpublic void readData(LPDataInput input) throws IOException {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12822
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "package logisticspipes.network.packets.routingdebug;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInput;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutput;\nimport java.io.ObjectOutputStream;\n\nimport net.minecraft.block.Block;\nimport net.minecraft.entity.player.EntityPlayer;\nimport net.minecraft.tileentity.TileEntity;\nimport net.minecraft.util.ChatComponentText;\n\nimport lombok.Getter;\nimport lombok.Setter;\n\nimport logisticspipes.commands.chathelper.LPChatListener;\nimport logisticspipes.network.PacketHandler;\nimport logisticspipes.network.abstractpackets.ModernPacket;\nimport logisticspipes.network.packets.gui.OpenChatGui;\nimport logisticspipes.pipes.basic.CoreRoutedPipe;\nimport logisticspipes.pipes.basic.LogisticsTileGenericPipe;\nimport logisticspipes.proxy.MainProxy;\nimport logisticspipes.routing.ServerRouter;\nimport logisticspipes.routing.debug.DebugController;\nimport logisticspipes.utils.string.ChatColor;\nimport network.rs485.logisticspipes.util.LPDataInput;\nimport network.rs485.logisticspipes.util.LPDataOutput;\n\npublic class RoutingUpdateTargetResponse extends ModernPacket {\n\n\tpublic RoutingUpdateTargetResponse(int id) {\n\t\tsuper(id);\n\t}\n\n\tpublic enum TargetMode {\n\t\tBlock,\n\t\tEntity,\n\t\tNone\n\t}\n\n\t@Getter\n\t@Setter\n\tprivate TargetMode mode;\n\n\t@Getter\n\t@Setter\n\tprivate Object[] additions = new Object[0];\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tmode = TargetMode.values()[input.readByte()];\n\t\tint size = input.readInt();\n\t\tadditions = new Object[size];\n\t\tfor (int i = 0; i < size; i++) {\n\t\t\tbyte[] bytes = input.readByteArray();\n\t\t\tByteArrayInputStream bis = new ByteArrayInputStream(bytes);\n\t\t\tObjectInput in = new ObjectInputStream(bis);\n\t\t\ttry {\n\t\t\t\tObject o = in.readObject();\n\t\t\t\tadditions[i] = o;\n\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\tthrow new UnsupportedOperationException(e);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void processPacket(final EntityPlayer player) {\n\t\tif (mode == TargetMode.None) {\n\t\t\tplayer.addChatMessage(new ChatComponentText(ChatColor.RED + \"No Target Found\"));\n\t\t} else if (mode == TargetMode.Block) {\n\t\t\tint x = (Integer) additions[0];\n\t\t\tint y = (Integer) additions[1];\n\t\t\tint z = (Integer) additions[2];\n\t\t\tplayer.addChatMessage(new ChatComponentText(\"Checking Block at: x:\" + x + \" y:\" + y + \" z:\" + z));\n\t\t\tBlock id = player.worldObj.getBlock(x, y, z);\n\t\t\tplayer.addChatMessage(new ChatComponentText(\"Found Block with Id: \" + Block.getIdFromBlock(id)));\n\t\t\tfinal TileEntity tile = player.worldObj.getTileEntity(x, y, z);\n\t\t\tif (tile == null) {\n\t\t\t\tplayer.addChatMessage(new ChatComponentText(ChatColor.RED + \"No TileEntity found\"));\n\t\t\t} else if (!(tile instanceof LogisticsTileGenericPipe)) {\n\t\t\t\tplayer.addChatMessage(new ChatComponentText(ChatColor.RED + \"No LogisticsTileGenericPipe found\"));\n\t\t\t} else if (!(((LogisticsTileGenericPipe) tile).pipe instanceof CoreRoutedPipe)) {\n\t\t\t\tplayer.addChatMessage(new ChatComponentText(ChatColor.RED + \"No CoreRoutedPipe found\"));\n\t\t\t} else {\n\t\t\t\tLPChatListener.addTask(() -> {\n\t\t\t\t\tplayer.addChatMessage(new ChatComponentText(ChatColor.GREEN + \"Starting RoutingTable debug update.\"));\n\t\t\t\t\tDebugController.instance(player).debug(((ServerRouter) ((CoreRoutedPipe) ((LogisticsTileGenericPipe) tile).pipe).getRouter()));\n\t\t\t\t\tMainProxy.sendPacketToPlayer(PacketHandler.getPacket(OpenChatGui.class), player);\n\t\t\t\t\treturn true;\n\t\t\t\t}, player);\n\t\t\t\tplayer.addChatMessage(new ChatComponentText(\n\t\t\t\t\t\tChatColor.AQUA + \"Start RoutingTable debug update ? \" + ChatColor.RESET + \"<\" + ChatColor.GREEN + \"yes\" + ChatColor.RESET + \"/\"\n\t\t\t\t\t\t\t\t+ ChatColor.RED + \"no\" + ChatColor.RESET + \">\"));\n\t\t\t\tMainProxy.sendPacketToPlayer(PacketHandler.getPacket(OpenChatGui.class), player);\n\t\t\t}\n\t\t} else if (mode == TargetMode.Entity) {\n\t\t\tplayer.addChatMessage(new ChatComponentText(ChatColor.RED + \"Entity not allowed\"));\n\t\t}\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\toutput.writeByte(mode.ordinal());\n\t\toutput.writeInt(additions.length);\n\t\tfor (Object addition : additions) {\n\t\t\tByteArrayOutputStream bos = new ByteArrayOutputStream();\n\t\t\tObjectOutput out = new ObjectOutputStream(bos);\n\t\t\tout.writeObject(addition);\n\t\t\toutput.writeByteArray(bos.toByteArray());\n\t\t}\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new RoutingUpdateTargetResponse(getId());\n\t}\n\n\t@Override\n\tpublic boolean isCompressable() {\n\t\treturn true;\n\t}\n}\n",
    "code_after_change": "package logisticspipes.network.packets.routingdebug;\n\nimport net.minecraft.block.Block;\nimport net.minecraft.entity.player.EntityPlayer;\nimport net.minecraft.tileentity.TileEntity;\nimport net.minecraft.util.ChatComponentText;\n\nimport lombok.Getter;\nimport lombok.Setter;\n\nimport logisticspipes.commands.chathelper.LPChatListener;\nimport logisticspipes.network.PacketHandler;\nimport logisticspipes.network.abstractpackets.ModernPacket;\nimport logisticspipes.network.packets.gui.OpenChatGui;\nimport logisticspipes.pipes.basic.CoreRoutedPipe;\nimport logisticspipes.pipes.basic.LogisticsTileGenericPipe;\nimport logisticspipes.proxy.MainProxy;\nimport logisticspipes.routing.ServerRouter;\nimport logisticspipes.routing.debug.DebugController;\nimport logisticspipes.utils.string.ChatColor;\nimport network.rs485.logisticspipes.util.LPDataInput;\nimport network.rs485.logisticspipes.util.LPDataOutput;\n\npublic class RoutingUpdateTargetResponse extends ModernPacket {\n\n\t@Getter\n\t@Setter\n\tprivate TargetMode mode;\n\t@Getter\n\t@Setter\n\tprivate int[] additions = new int[0];\n\n\tpublic RoutingUpdateTargetResponse(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tmode = TargetMode.values()[input.readByte()];\n\t\tadditions = input.readIntArray();\n\t}\n\n\t@Override\n\tpublic void processPacket(final EntityPlayer player) {\n\t\tif (mode == TargetMode.None) {\n\t\t\tplayer.addChatMessage(new ChatComponentText(ChatColor.RED + \"No Target Found\"));\n\t\t} else if (mode == TargetMode.Block) {\n\t\t\tint x = additions[0];\n\t\t\tint y = additions[1];\n\t\t\tint z = additions[2];\n\t\t\tplayer.addChatMessage(new ChatComponentText(\"Checking Block at: x:\" + x + \" y:\" + y + \" z:\" + z));\n\t\t\tBlock id = player.worldObj.getBlock(x, y, z);\n\t\t\tplayer.addChatMessage(new ChatComponentText(\"Found Block with Id: \" + Block.getIdFromBlock(id)));\n\t\t\tfinal TileEntity tile = player.worldObj.getTileEntity(x, y, z);\n\t\t\tif (tile == null) {\n\t\t\t\tplayer.addChatMessage(new ChatComponentText(ChatColor.RED + \"No TileEntity found\"));\n\t\t\t} else if (!(tile instanceof LogisticsTileGenericPipe)) {\n\t\t\t\tplayer.addChatMessage(new ChatComponentText(ChatColor.RED + \"No LogisticsTileGenericPipe found\"));\n\t\t\t} else if (!(((LogisticsTileGenericPipe) tile).pipe instanceof CoreRoutedPipe)) {\n\t\t\t\tplayer.addChatMessage(new ChatComponentText(ChatColor.RED + \"No CoreRoutedPipe found\"));\n\t\t\t} else {\n\t\t\t\tLPChatListener.addTask(() -> {\n\t\t\t\t\tplayer.addChatMessage(new ChatComponentText(ChatColor.GREEN + \"Starting RoutingTable debug update.\"));\n\t\t\t\t\tDebugController.instance(player).debug(((ServerRouter) ((CoreRoutedPipe) ((LogisticsTileGenericPipe) tile).pipe).getRouter()));\n\t\t\t\t\tMainProxy.sendPacketToPlayer(PacketHandler.getPacket(OpenChatGui.class), player);\n\t\t\t\t\treturn true;\n\t\t\t\t}, player);\n\t\t\t\tplayer.addChatMessage(new ChatComponentText(\n\t\t\t\t\t\tChatColor.AQUA + \"Start RoutingTable debug update ? \" + ChatColor.RESET + \"<\" + ChatColor.GREEN + \"yes\" + ChatColor.RESET + \"/\"\n\t\t\t\t\t\t\t\t+ ChatColor.RED + \"no\" + ChatColor.RESET + \">\"));\n\t\t\t\tMainProxy.sendPacketToPlayer(PacketHandler.getPacket(OpenChatGui.class), player);\n\t\t\t}\n\t\t} else if (mode == TargetMode.Entity) {\n\t\t\tplayer.addChatMessage(new ChatComponentText(ChatColor.RED + \"Entity not allowed\"));\n\t\t}\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\toutput.writeByte(mode.ordinal());\n\t\toutput.writeIntArray(additions);\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new RoutingUpdateTargetResponse(getId());\n\t}\n\n\t@Override\n\tpublic boolean isCompressable() {\n\t\treturn true;\n\t}\n\n\tpublic enum TargetMode {\n\t\tBlock,\n\t\tEntity,\n\t\tNone\n\t}\n}\n",
    "patch": "@@ -1,13 +1,5 @@\n package logisticspipes.network.packets.routingdebug;\n \n-import java.io.ByteArrayInputStream;\n-import java.io.ByteArrayOutputStream;\n-import java.io.IOException;\n-import java.io.ObjectInput;\n-import java.io.ObjectInputStream;\n-import java.io.ObjectOutput;\n-import java.io.ObjectOutputStream;\n-\n import net.minecraft.block.Block;\n import net.minecraft.entity.player.EntityPlayer;\n import net.minecraft.tileentity.TileEntity;\n@@ -31,50 +23,31 @@\n \n public class RoutingUpdateTargetResponse extends ModernPacket {\n \n-\tpublic RoutingUpdateTargetResponse(int id) {\n-\t\tsuper(id);\n-\t}\n-\n-\tpublic enum TargetMode {\n-\t\tBlock,\n-\t\tEntity,\n-\t\tNone\n-\t}\n-\n \t@Getter\n \t@Setter\n \tprivate TargetMode mode;\n-\n \t@Getter\n \t@Setter\n-\tprivate Object[] additions = new Object[0];\n+\tprivate int[] additions = new int[0];\n+\n+\tpublic RoutingUpdateTargetResponse(int id) {\n+\t\tsuper(id);\n+\t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tmode = TargetMode.values()[input.readByte()];\n-\t\tint size = input.readInt();\n-\t\tadditions = new Object[size];\n-\t\tfor (int i = 0; i < size; i++) {\n-\t\t\tbyte[] bytes = input.readByteArray();\n-\t\t\tByteArrayInputStream bis = new ByteArrayInputStream(bytes);\n-\t\t\tObjectInput in = new ObjectInputStream(bis);\n-\t\t\ttry {\n-\t\t\t\tObject o = in.readObject();\n-\t\t\t\tadditions[i] = o;\n-\t\t\t} catch (ClassNotFoundException e) {\n-\t\t\t\tthrow new UnsupportedOperationException(e);\n-\t\t\t}\n-\t\t}\n+\t\tadditions = input.readIntArray();\n \t}\n \n \t@Override\n \tpublic void processPacket(final EntityPlayer player) {\n \t\tif (mode == TargetMode.None) {\n \t\t\tplayer.addChatMessage(new ChatComponentText(ChatColor.RED + \"No Target Found\"));\n \t\t} else if (mode == TargetMode.Block) {\n-\t\t\tint x = (Integer) additions[0];\n-\t\t\tint y = (Integer) additions[1];\n-\t\t\tint z = (Integer) additions[2];\n+\t\t\tint x = additions[0];\n+\t\t\tint y = additions[1];\n+\t\t\tint z = additions[2];\n \t\t\tplayer.addChatMessage(new ChatComponentText(\"Checking Block at: x:\" + x + \" y:\" + y + \" z:\" + z));\n \t\t\tBlock id = player.worldObj.getBlock(x, y, z);\n \t\t\tplayer.addChatMessage(new ChatComponentText(\"Found Block with Id: \" + Block.getIdFromBlock(id)));\n@@ -103,15 +76,9 @@ public void processPacket(final EntityPlayer player) {\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\toutput.writeByte(mode.ordinal());\n-\t\toutput.writeInt(additions.length);\n-\t\tfor (Object addition : additions) {\n-\t\t\tByteArrayOutputStream bos = new ByteArrayOutputStream();\n-\t\t\tObjectOutput out = new ObjectOutputStream(bos);\n-\t\t\tout.writeObject(addition);\n-\t\t\toutput.writeByteArray(bos.toByteArray());\n-\t\t}\n+\t\toutput.writeIntArray(additions);\n \t}\n \n \t@Override\n@@ -123,4 +90,10 @@ public ModernPacket template() {\n \tpublic boolean isCompressable() {\n \t\treturn true;\n \t}\n+\n+\tpublic enum TargetMode {\n+\t\tBlock,\n+\t\tEntity,\n+\t\tNone\n+\t}\n }",
    "function_modified_lines": {
      "added": [],
      "deleted": [
        "import java.io.ByteArrayInputStream;\n",
        "import java.io.ByteArrayOutputStream;\n",
        "import java.io.IOException;\n",
        "import java.io.ObjectInput;\n",
        "import java.io.ObjectInputStream;\n",
        "import java.io.ObjectOutput;\n",
        "import java.io.ObjectOutputStream;\n",
        "\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12823
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "\t\treturn (super.canPipeConnect(tile, dir) || logisitcsIsPipeConnected(tile, dir)) && !disconnectPipe(tile, dir);\n\t}\n\n\t@Override\n\tpublic final boolean isSideBlocked(ForgeDirection side, boolean ignoreSystemDisconnection) {\n\t\tif (getUpgradeManager().isSideDisconnected(side)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (container != null && side != ForgeDirection.UNKNOWN && container.tilePart.hasBlockingPluggable(side)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!stillNeedReplace) {\n\t\t\tif (getRouter().isSideDisconneceted(side) && !ignoreSystemDisconnection && !globalIgnoreConnectionDisconnection) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic void connectionUpdate() {\n\t\tif (container != null && !stillNeedReplace) {\n\t\t\tcontainer.scheduleNeighborChange();\n\t\t\tgetWorld().notifyBlockChange(getX(), getY(), getZ(), getWorld().getBlock(getX(), getY(), getZ()));\n\t\t}\n\t}\n\n\tpublic UUID getSecurityID() {\n\t\treturn getOriginalUpgradeManager().getSecurityID();\n\t}\n\n\tpublic void insetSecurityID(UUID id) {\n\t\tgetOriginalUpgradeManager().insetSecurityID(id);\n\t}\n\n\t/* Power System */\n\n\tpublic List<Pair<ILogisticsPowerProvider, List<IFilter>>> getRoutedPowerProviders() {\n\t\tif (MainProxy.isClient(getWorld())) {\n\t\t\treturn null;\n\t\t}\n\t\tif (stillNeedReplace) {\n\t\t\treturn null;\n\t\t}\n\t\treturn getRouter().getPowerProvider();\n\t}\n\n\t@Override\n\tpublic boolean useEnergy(int amount) {\n\t\treturn useEnergy(amount, null, true);\n\t}\n\n\tpublic boolean useEnergy(int amount, boolean sparkles) {\n\t\treturn useEnergy(amount, null, sparkles);\n\t}\n\n\t@Override\n\tpublic boolean canUseEnergy(int amount) {\n\t\treturn canUseEnergy(amount, null);\n\t}\n\n\t@Override\n\tpublic boolean canUseEnergy(int amount, List<Object> providersToIgnore) {\n\t\tif (MainProxy.isClient(getWorld())) {\n\t\t\treturn false;\n\t\t}\n\t\tif (Configs.LOGISTICS_POWER_USAGE_DISABLED) {\n\t\t\treturn true;\n\t\t}\n\t\tif (amount == 0) {\n\t\t\treturn true;\n\t\t}\n\t\tif (providersToIgnore != null && providersToIgnore.contains(this)) {\n\t\t\treturn false;\n\t\t}\n\t\tList<Pair<ILogisticsPowerProvider, List<IFilter>>> list = getRoutedPowerProviders();\n\t\tif (list == null) {\n\t\t\treturn false;\n\t\t}\n\t\touter:\n\t\tfor (Pair<ILogisticsPowerProvider, List<IFilter>> provider : list) {\n\t\t\tfor (IFilter filter : provider.getValue2()) {\n\t\t\t\tif (filter.blockPower()) {\n\t\t\t\t\tcontinue outer;\n\t\t\t\t}",
    "code_after_change": "\t\t\treturn false;\n\t\t}\n\t\treturn (super.canPipeConnect(tile, dir) || logisitcsIsPipeConnected(tile, dir)) && !disconnectPipe(tile, dir);\n\t}\n\n\t@Override\n\tpublic final boolean isSideBlocked(ForgeDirection side, boolean ignoreSystemDisconnection) {\n\t\tif (getUpgradeManager().isSideDisconnected(side)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (container != null && side != ForgeDirection.UNKNOWN && container.tilePart.hasBlockingPluggable(side)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!stillNeedReplace) {\n\t\t\tif (getRouter().isSideDisconneceted(side) && !ignoreSystemDisconnection && !globalIgnoreConnectionDisconnection) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic void connectionUpdate() {\n\t\tif (container != null && !stillNeedReplace) {\n\t\t\tcontainer.scheduleNeighborChange();\n\t\t\tgetWorld().notifyBlockChange(getX(), getY(), getZ(), getWorld().getBlock(getX(), getY(), getZ()));\n\t\t}\n\t}\n\n\tpublic UUID getSecurityID() {\n\t\treturn getOriginalUpgradeManager().getSecurityID();\n\t}\n\n\tpublic void insetSecurityID(UUID id) {\n\t\tgetOriginalUpgradeManager().insetSecurityID(id);\n\t}\n\n\tpublic List<Pair<ILogisticsPowerProvider, List<IFilter>>> getRoutedPowerProviders() {\n\t\tif (MainProxy.isClient(getWorld())) {\n\t\t\treturn null;\n\t\t}\n\t\tif (stillNeedReplace) {\n\t\t\treturn null;\n\t\t}\n\t\treturn getRouter().getPowerProvider();\n\t}\n\n\t/* Power System */\n\n\t@Override\n\tpublic boolean useEnergy(int amount) {\n\t\treturn useEnergy(amount, null, true);\n\t}\n\n\tpublic boolean useEnergy(int amount, boolean sparkles) {\n\t\treturn useEnergy(amount, null, sparkles);\n\t}\n\n\t@Override\n\tpublic boolean canUseEnergy(int amount) {\n\t\treturn canUseEnergy(amount, null);\n\t}\n\n\t@Override\n\tpublic boolean canUseEnergy(int amount, List<Object> providersToIgnore) {\n\t\tif (MainProxy.isClient(getWorld())) {\n\t\t\treturn false;\n\t\t}\n\t\tif (Configs.LOGISTICS_POWER_USAGE_DISABLED) {\n\t\t\treturn true;\n\t\t}\n\t\tif (amount == 0) {\n\t\t\treturn true;\n\t\t}\n\t\tif (providersToIgnore != null && providersToIgnore.contains(this)) {\n\t\t\treturn false;\n\t\t}\n\t\tList<Pair<ILogisticsPowerProvider, List<IFilter>>> list = getRoutedPowerProviders();\n\t\tif (list == null) {\n\t\t\treturn false;\n\t\t}\n\t\touter:\n\t\tfor (Pair<ILogisticsPowerProvider, List<IFilter>> provider : list) {\n\t\t\tfor (IFilter filter : provider.getValue2()) {\n\t\t\t\tif (filter.blockPower()) {",
    "patch": "@@ -7,7 +7,6 @@\n \n package logisticspipes.pipes.basic;\n \n-import java.io.IOException;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.BitSet;\n@@ -132,71 +131,49 @@\n public abstract class CoreRoutedPipe extends CoreUnroutedPipe\n \t\timplements IClientState, IRequestItems, ITrackStatistics, IWorldProvider, IWatchingHandler, IPipeServiceProvider, IQueueCCEvent, ILPPositionProvider {\n \n-\tpublic enum ItemSendMode {\n-\t\tNormal,\n-\t\tFast\n-\t}\n-\n-\tprotected boolean stillNeedReplace = true;\n-\tprivate boolean recheckConnections = false;\n-\n-\tprotected IRouter router;\n-\tprotected String routerId;\n-\tprotected Object routerIdLock = new Object();\n \tprivate static int pipecount = 0;\n-\tprotected int _delayOffset = 0;\n-\n+\tpublic final PlayerCollectionList watchers = new PlayerCollectionList();\n+\tprotected final PriorityBlockingQueue<ItemRoutingInformation> _inTransitToMe = new PriorityBlockingQueue<>(10,\n+\t\t\tnew ItemRoutingInformation.DelayComparator());\n+\tprotected final LinkedList<Triplet<IRoutedItem, ForgeDirection, ItemSendMode>> _sendQueue = new LinkedList<>();\n+\tprotected final Map<ItemIdentifier, Queue<Pair<Integer, ItemRoutingInformation>>> queuedDataForUnroutedItems = Collections.synchronizedMap(new TreeMap<>());\n \tpublic boolean _textureBufferPowered;\n-\n-\tprotected boolean _initialInit = true;\n-\n-\tprivate boolean enabled = true;\n-\tprivate boolean preventRemove = false;\n-\tprivate boolean destroyByPlayer = false;\n-\tprivate PowerSupplierHandler powerHandler = new PowerSupplierHandler(this);\n-\n \tpublic long delayTo = 0;\n \tpublic int repeatFor = 0;\n-\n-\tprotected RouteLayer _routeLayer;\n-\tprotected TransportLayer _transportLayer;\n-\tprotected final PriorityBlockingQueue<ItemRoutingInformation> _inTransitToMe = new PriorityBlockingQueue<>(10,\n-\t\t\tnew ItemRoutingInformation.DelayComparator());\n-\n-\tprotected UpgradeManager upgradeManager = new UpgradeManager(this);\n-\tprotected LogisticsItemOrderManager _orderItemManager = null;\n-\n-\t@Getter\n-\tprivate List<IOrderInfoProvider> clientSideOrderManager = new ArrayList<>();\n-\n \tpublic int stat_session_sent;\n \tpublic int stat_session_recieved;\n \tpublic int stat_session_relayed;\n-\n \tpublic long stat_lifetime_sent;\n \tpublic long stat_lifetime_recieved;\n \tpublic long stat_lifetime_relayed;\n-\n \tpublic int server_routing_table_size = 0;\n-\n-\tprotected final LinkedList<Triplet<IRoutedItem, ForgeDirection, ItemSendMode>> _sendQueue = new LinkedList<>();\n-\n-\tprotected final Map<ItemIdentifier, Queue<Pair<Integer, ItemRoutingInformation>>> queuedDataForUnroutedItems = Collections.synchronizedMap(new TreeMap<>());\n-\n-\tpublic final PlayerCollectionList watchers = new PlayerCollectionList();\n-\n+\tpublic boolean globalIgnoreConnectionDisconnection = false;\n+\tprotected boolean stillNeedReplace = true;\n+\tprotected IRouter router;\n+\tprotected String routerId;\n+\tprotected Object routerIdLock = new Object();\n+\tprotected int _delayOffset = 0;\n+\tprotected boolean _initialInit = true;\n+\tprotected RouteLayer _routeLayer;\n+\tprotected TransportLayer _transportLayer;\n+\tprotected UpgradeManager upgradeManager = new UpgradeManager(this);\n+\tprotected LogisticsItemOrderManager _orderItemManager = null;\n \tprotected List<IInventory> _cachedAdjacentInventories;\n-\n \tprotected ForgeDirection pointedDirection = ForgeDirection.UNKNOWN;\n \t//public BaseRoutingLogic logic;\n \t// from BaseRoutingLogic\n \tprotected int throttleTime = 20;\n+\tprotected IPipeSign[] signItem = new IPipeSign[6];\n+\tprivate boolean recheckConnections = false;\n+\tprivate boolean enabled = true;\n+\tprivate boolean preventRemove = false;\n+\tprivate boolean destroyByPlayer = false;\n+\tprivate PowerSupplierHandler powerHandler = new PowerSupplierHandler(this);\n+\t@Getter\n+\tprivate List<IOrderInfoProvider> clientSideOrderManager = new ArrayList<>();\n \tprivate int throttleTimeLeft = 20 + new Random().nextInt(Configs.LOGISTICS_DETECTION_FREQUENCY);\n-\n \tprivate int[] queuedParticles = new int[Particles.values().length];\n \tprivate boolean hasQueuedParticles = false;\n-\n-\tprotected IPipeSign[] signItem = new IPipeSign[6];\n \tprivate boolean isOpaqueClientSide = false;\n \n \tprivate CacheHolder cacheHolder;\n@@ -1030,8 +1007,6 @@ public final boolean canPipeConnect(TileEntity tile, ForgeDirection dir) {\n \t\treturn canPipeConnect(tile, dir, false);\n \t}\n \n-\tpublic boolean globalIgnoreConnectionDisconnection = false;\n-\n \t@Override\n \tpublic final boolean canPipeConnect(TileEntity tile, ForgeDirection dir, boolean ignoreSystemDisconnection) {\n \t\tForgeDirection side = OrientationsUtil.getOrientationOfTilewithTile(container, tile);\n@@ -1072,8 +1047,6 @@ public void insetSecurityID(UUID id) {\n \t\tgetOriginalUpgradeManager().insetSecurityID(id);\n \t}\n \n-\t/* Power System */\n-\n \tpublic List<Pair<ILogisticsPowerProvider, List<IFilter>>> getRoutedPowerProviders() {\n \t\tif (MainProxy.isClient(getWorld())) {\n \t\t\treturn null;\n@@ -1084,6 +1057,8 @@ public List<Pair<ILogisticsPowerProvider, List<IFilter>>> getRoutedPowerProvider\n \t\treturn getRouter().getPowerProvider();\n \t}\n \n+\t/* Power System */\n+\n \t@Override\n \tpublic boolean useEnergy(int amount) {\n \t\treturn useEnergy(amount, null, true);\n@@ -1378,21 +1353,21 @@ public String getRouterUUID(Double id) {\n \t\treturn router.getId().toString();\n \t}\n \n-\t@CCCommand(description = \"Sets the TurtleConnect flag for this Turtle on this LogisticsPipe\")\n+\t@CCCommand(description = \"Returns the TurtleConnect flag for this Turtle on this LogisticsPipe\")\n \t@CCDirectCall\n-\tpublic void setTurtleConnect(Boolean flag) {\n+\tpublic boolean getTurtleConnect() {\n \t\tif (container instanceof LogisticsTileGenericPipe) {\n-\t\t\tcontainer.setTurtleConnect(flag);\n+\t\t\treturn container.getTurtleConnect();\n \t\t}\n+\t\treturn false;\n \t}\n \n-\t@CCCommand(description = \"Returns the TurtleConnect flag for this Turtle on this LogisticsPipe\")\n+\t@CCCommand(description = \"Sets the TurtleConnect flag for this Turtle on this LogisticsPipe\")\n \t@CCDirectCall\n-\tpublic boolean getTurtleConnect() {\n+\tpublic void setTurtleConnect(Boolean flag) {\n \t\tif (container instanceof LogisticsTileGenericPipe) {\n-\t\t\treturn container.getTurtleConnect();\n+\t\t\tcontainer.setTurtleConnect(flag);\n \t\t}\n-\t\treturn false;\n \t}\n \n \t@CCCommand(description = \"Returns true if the computer is allowed to interact with the connected pipe.\", needPermission = false)\n@@ -1743,12 +1718,12 @@ public IPipeSign getPipeSign(ForgeDirection dir) {\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\toutput.writeBoolean(isOpaque());\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tisOpaqueClientSide = input.readBoolean();\n \t}\n \n@@ -1841,4 +1816,9 @@ public CacheHolder getCacheHolder() {\n \tpublic IHighlightPlacementRenderer getHighlightRenderer() {\n \t\treturn LogisticsRenderPipe.secondRenderer;\n \t}\n+\n+\tpublic enum ItemSendMode {\n+\t\tNormal,\n+\t\tFast\n+\t}\n }",
    "function_modified_lines": {
      "added": [
        "\t/* Power System */\n",
        "\n"
      ],
      "deleted": [
        "\t/* Power System */\n",
        "\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12825
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "\t\t}\n\t\treturn list;\n\t}\n\n\tpublic void handleSignPacket(List<Integer> types) {\n\t\tif (!MainProxy.isClient(getWorld())) {\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = 0; i < 6; i++) {\n\t\t\tint integer = types.get(i);\n\t\t\tif (integer >= 0) {\n\t\t\t\tClass<? extends IPipeSign> type = ItemPipeSignCreator.signTypes.get(integer);\n\t\t\t\tif (signItem[i] == null || signItem[i].getClass() != type) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tsignItem[i] = type.newInstance();\n\t\t\t\t\t\tsignItem[i].init(this, ForgeDirection.getOrientation(i));\n\t\t\t\t\t} catch (InstantiationException | IllegalAccessException e) {\n\t\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsignItem[i] = null;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic IPipeSign getPipeSign(ForgeDirection dir) {\n\t\tif (dir.ordinal() < 6) {\n\t\t\treturn signItem[dir.ordinal()];\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\toutput.writeBoolean(isOpaque());\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tisOpaqueClientSide = input.readBoolean();\n\t}\n\n\t@Override\n\tpublic boolean isOpaque() {\n\t\tif (MainProxy.isClient(getWorld())) {\n\t\t\treturn Configs.OPAQUE || isOpaqueClientSide;\n\t\t} else {\n\t\t\treturn Configs.OPAQUE || this.getUpgradeManager().isOpaque();\n\t\t}\n\t}\n\n\t@Override\n\tpublic void addStatusInformation(List<StatusEntry> status) {\n\t\tStatusEntry entry = new StatusEntry();\n\t\tentry.name = \"Send Queue\";\n\t\tentry.subEntry = new ArrayList<>();\n\t\tfor (Triplet<IRoutedItem, ForgeDirection, ItemSendMode> part : _sendQueue) {\n\t\t\tStatusEntry subEntry = new StatusEntry();\n\t\t\tsubEntry.name = part.toString();\n\t\t\tentry.subEntry.add(subEntry);\n\t\t}\n\t\tstatus.add(entry);\n\t\tentry = new StatusEntry();\n\t\tentry.name = \"In Transit To Me\";\n\t\tentry.subEntry = new ArrayList<>();\n\t\tfor (ItemRoutingInformation part : _inTransitToMe) {\n\t\t\tStatusEntry subEntry = new StatusEntry();\n\t\t\tsubEntry.name = part.toString();\n\t\t\tentry.subEntry.add(subEntry);\n\t\t}\n\t\tstatus.add(entry);\n\t}\n\n\t@Override\n\tpublic int getSourceID() {",
    "code_after_change": "\t\t}\n\t\treturn list;\n\t}\n\n\tpublic void handleSignPacket(List<Integer> types) {\n\t\tif (!MainProxy.isClient(getWorld())) {\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = 0; i < 6; i++) {\n\t\t\tint integer = types.get(i);\n\t\t\tif (integer >= 0) {\n\t\t\t\tClass<? extends IPipeSign> type = ItemPipeSignCreator.signTypes.get(integer);\n\t\t\t\tif (signItem[i] == null || signItem[i].getClass() != type) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tsignItem[i] = type.newInstance();\n\t\t\t\t\t\tsignItem[i].init(this, ForgeDirection.getOrientation(i));\n\t\t\t\t\t} catch (InstantiationException | IllegalAccessException e) {\n\t\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsignItem[i] = null;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic IPipeSign getPipeSign(ForgeDirection dir) {\n\t\tif (dir.ordinal() < 6) {\n\t\t\treturn signItem[dir.ordinal()];\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\toutput.writeBoolean(isOpaque());\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tisOpaqueClientSide = input.readBoolean();\n\t}\n\n\t@Override\n\tpublic boolean isOpaque() {\n\t\tif (MainProxy.isClient(getWorld())) {\n\t\t\treturn Configs.OPAQUE || isOpaqueClientSide;\n\t\t} else {\n\t\t\treturn Configs.OPAQUE || this.getUpgradeManager().isOpaque();\n\t\t}\n\t}\n\n\t@Override\n\tpublic void addStatusInformation(List<StatusEntry> status) {\n\t\tStatusEntry entry = new StatusEntry();\n\t\tentry.name = \"Send Queue\";\n\t\tentry.subEntry = new ArrayList<>();\n\t\tfor (Triplet<IRoutedItem, ForgeDirection, ItemSendMode> part : _sendQueue) {\n\t\t\tStatusEntry subEntry = new StatusEntry();\n\t\t\tsubEntry.name = part.toString();\n\t\t\tentry.subEntry.add(subEntry);\n\t\t}\n\t\tstatus.add(entry);\n\t\tentry = new StatusEntry();\n\t\tentry.name = \"In Transit To Me\";\n\t\tentry.subEntry = new ArrayList<>();\n\t\tfor (ItemRoutingInformation part : _inTransitToMe) {\n\t\t\tStatusEntry subEntry = new StatusEntry();\n\t\t\tsubEntry.name = part.toString();\n\t\t\tentry.subEntry.add(subEntry);\n\t\t}\n\t\tstatus.add(entry);\n\t}\n\n\t@Override\n\tpublic int getSourceID() {",
    "patch": "@@ -7,7 +7,6 @@\n \n package logisticspipes.pipes.basic;\n \n-import java.io.IOException;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.BitSet;\n@@ -132,71 +131,49 @@\n public abstract class CoreRoutedPipe extends CoreUnroutedPipe\n \t\timplements IClientState, IRequestItems, ITrackStatistics, IWorldProvider, IWatchingHandler, IPipeServiceProvider, IQueueCCEvent, ILPPositionProvider {\n \n-\tpublic enum ItemSendMode {\n-\t\tNormal,\n-\t\tFast\n-\t}\n-\n-\tprotected boolean stillNeedReplace = true;\n-\tprivate boolean recheckConnections = false;\n-\n-\tprotected IRouter router;\n-\tprotected String routerId;\n-\tprotected Object routerIdLock = new Object();\n \tprivate static int pipecount = 0;\n-\tprotected int _delayOffset = 0;\n-\n+\tpublic final PlayerCollectionList watchers = new PlayerCollectionList();\n+\tprotected final PriorityBlockingQueue<ItemRoutingInformation> _inTransitToMe = new PriorityBlockingQueue<>(10,\n+\t\t\tnew ItemRoutingInformation.DelayComparator());\n+\tprotected final LinkedList<Triplet<IRoutedItem, ForgeDirection, ItemSendMode>> _sendQueue = new LinkedList<>();\n+\tprotected final Map<ItemIdentifier, Queue<Pair<Integer, ItemRoutingInformation>>> queuedDataForUnroutedItems = Collections.synchronizedMap(new TreeMap<>());\n \tpublic boolean _textureBufferPowered;\n-\n-\tprotected boolean _initialInit = true;\n-\n-\tprivate boolean enabled = true;\n-\tprivate boolean preventRemove = false;\n-\tprivate boolean destroyByPlayer = false;\n-\tprivate PowerSupplierHandler powerHandler = new PowerSupplierHandler(this);\n-\n \tpublic long delayTo = 0;\n \tpublic int repeatFor = 0;\n-\n-\tprotected RouteLayer _routeLayer;\n-\tprotected TransportLayer _transportLayer;\n-\tprotected final PriorityBlockingQueue<ItemRoutingInformation> _inTransitToMe = new PriorityBlockingQueue<>(10,\n-\t\t\tnew ItemRoutingInformation.DelayComparator());\n-\n-\tprotected UpgradeManager upgradeManager = new UpgradeManager(this);\n-\tprotected LogisticsItemOrderManager _orderItemManager = null;\n-\n-\t@Getter\n-\tprivate List<IOrderInfoProvider> clientSideOrderManager = new ArrayList<>();\n-\n \tpublic int stat_session_sent;\n \tpublic int stat_session_recieved;\n \tpublic int stat_session_relayed;\n-\n \tpublic long stat_lifetime_sent;\n \tpublic long stat_lifetime_recieved;\n \tpublic long stat_lifetime_relayed;\n-\n \tpublic int server_routing_table_size = 0;\n-\n-\tprotected final LinkedList<Triplet<IRoutedItem, ForgeDirection, ItemSendMode>> _sendQueue = new LinkedList<>();\n-\n-\tprotected final Map<ItemIdentifier, Queue<Pair<Integer, ItemRoutingInformation>>> queuedDataForUnroutedItems = Collections.synchronizedMap(new TreeMap<>());\n-\n-\tpublic final PlayerCollectionList watchers = new PlayerCollectionList();\n-\n+\tpublic boolean globalIgnoreConnectionDisconnection = false;\n+\tprotected boolean stillNeedReplace = true;\n+\tprotected IRouter router;\n+\tprotected String routerId;\n+\tprotected Object routerIdLock = new Object();\n+\tprotected int _delayOffset = 0;\n+\tprotected boolean _initialInit = true;\n+\tprotected RouteLayer _routeLayer;\n+\tprotected TransportLayer _transportLayer;\n+\tprotected UpgradeManager upgradeManager = new UpgradeManager(this);\n+\tprotected LogisticsItemOrderManager _orderItemManager = null;\n \tprotected List<IInventory> _cachedAdjacentInventories;\n-\n \tprotected ForgeDirection pointedDirection = ForgeDirection.UNKNOWN;\n \t//public BaseRoutingLogic logic;\n \t// from BaseRoutingLogic\n \tprotected int throttleTime = 20;\n+\tprotected IPipeSign[] signItem = new IPipeSign[6];\n+\tprivate boolean recheckConnections = false;\n+\tprivate boolean enabled = true;\n+\tprivate boolean preventRemove = false;\n+\tprivate boolean destroyByPlayer = false;\n+\tprivate PowerSupplierHandler powerHandler = new PowerSupplierHandler(this);\n+\t@Getter\n+\tprivate List<IOrderInfoProvider> clientSideOrderManager = new ArrayList<>();\n \tprivate int throttleTimeLeft = 20 + new Random().nextInt(Configs.LOGISTICS_DETECTION_FREQUENCY);\n-\n \tprivate int[] queuedParticles = new int[Particles.values().length];\n \tprivate boolean hasQueuedParticles = false;\n-\n-\tprotected IPipeSign[] signItem = new IPipeSign[6];\n \tprivate boolean isOpaqueClientSide = false;\n \n \tprivate CacheHolder cacheHolder;\n@@ -1030,8 +1007,6 @@ public final boolean canPipeConnect(TileEntity tile, ForgeDirection dir) {\n \t\treturn canPipeConnect(tile, dir, false);\n \t}\n \n-\tpublic boolean globalIgnoreConnectionDisconnection = false;\n-\n \t@Override\n \tpublic final boolean canPipeConnect(TileEntity tile, ForgeDirection dir, boolean ignoreSystemDisconnection) {\n \t\tForgeDirection side = OrientationsUtil.getOrientationOfTilewithTile(container, tile);\n@@ -1072,8 +1047,6 @@ public void insetSecurityID(UUID id) {\n \t\tgetOriginalUpgradeManager().insetSecurityID(id);\n \t}\n \n-\t/* Power System */\n-\n \tpublic List<Pair<ILogisticsPowerProvider, List<IFilter>>> getRoutedPowerProviders() {\n \t\tif (MainProxy.isClient(getWorld())) {\n \t\t\treturn null;\n@@ -1084,6 +1057,8 @@ public List<Pair<ILogisticsPowerProvider, List<IFilter>>> getRoutedPowerProvider\n \t\treturn getRouter().getPowerProvider();\n \t}\n \n+\t/* Power System */\n+\n \t@Override\n \tpublic boolean useEnergy(int amount) {\n \t\treturn useEnergy(amount, null, true);\n@@ -1378,21 +1353,21 @@ public String getRouterUUID(Double id) {\n \t\treturn router.getId().toString();\n \t}\n \n-\t@CCCommand(description = \"Sets the TurtleConnect flag for this Turtle on this LogisticsPipe\")\n+\t@CCCommand(description = \"Returns the TurtleConnect flag for this Turtle on this LogisticsPipe\")\n \t@CCDirectCall\n-\tpublic void setTurtleConnect(Boolean flag) {\n+\tpublic boolean getTurtleConnect() {\n \t\tif (container instanceof LogisticsTileGenericPipe) {\n-\t\t\tcontainer.setTurtleConnect(flag);\n+\t\t\treturn container.getTurtleConnect();\n \t\t}\n+\t\treturn false;\n \t}\n \n-\t@CCCommand(description = \"Returns the TurtleConnect flag for this Turtle on this LogisticsPipe\")\n+\t@CCCommand(description = \"Sets the TurtleConnect flag for this Turtle on this LogisticsPipe\")\n \t@CCDirectCall\n-\tpublic boolean getTurtleConnect() {\n+\tpublic void setTurtleConnect(Boolean flag) {\n \t\tif (container instanceof LogisticsTileGenericPipe) {\n-\t\t\treturn container.getTurtleConnect();\n+\t\t\tcontainer.setTurtleConnect(flag);\n \t\t}\n-\t\treturn false;\n \t}\n \n \t@CCCommand(description = \"Returns true if the computer is allowed to interact with the connected pipe.\", needPermission = false)\n@@ -1743,12 +1718,12 @@ public IPipeSign getPipeSign(ForgeDirection dir) {\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\toutput.writeBoolean(isOpaque());\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tisOpaqueClientSide = input.readBoolean();\n \t}\n \n@@ -1841,4 +1816,9 @@ public CacheHolder getCacheHolder() {\n \tpublic IHighlightPlacementRenderer getHighlightRenderer() {\n \t\treturn LogisticsRenderPipe.secondRenderer;\n \t}\n+\n+\tpublic enum ItemSendMode {\n+\t\tNormal,\n+\t\tFast\n+\t}\n }",
    "function_modified_lines": {
      "added": [
        "\tpublic void writeData(LPDataOutput output) {\n",
        "\tpublic void readData(LPDataInput input) {\n"
      ],
      "deleted": [
        "\tpublic void writeData(LPDataOutput output) throws IOException {\n",
        "\tpublic void readData(LPDataInput input) throws IOException {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12826
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "\t\t\tList<DoubleCoordinates> visited) {\n\t\tif (!stillNeedReplace) {\n\t\t\tif (getRouterId() == destinationint) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tExitRoute route = getRouter().getExitFor(destinationint, isActive, ident);\n\t\t\tif (route != null && route.exitOrientation != ignore) {\n\t\t\t\tif (route.distanceToDestination + traveled >= max) {\n\t\t\t\t\treturn Integer.MAX_VALUE;\n\t\t\t\t}\n\t\t\t\treturn route.distanceToDestination;\n\t\t\t}\n\t\t}\n\t\treturn Integer.MAX_VALUE;\n\t}\n\n\tpublic void triggerConnectionCheck() {\n\t\trecheckConnections = true;\n\t}\n\n\t@Override\n\tpublic CacheHolder getCacheHolder() {\n\t\tif (cacheHolder == null) {\n\t\t\tif (container instanceof ILPTEInformation && ((ILPTEInformation) container).getObject() != null) {\n\t\t\t\tcacheHolder = ((ILPTEInformation) container).getObject().getCacheHolder();\n\t\t\t} else {\n\t\t\t\tcacheHolder = new CacheHolder();\n\t\t\t}\n\t\t}\n\t\treturn cacheHolder;\n\t}\n\n\t@Override\n\tpublic IHighlightPlacementRenderer getHighlightRenderer() {\n\t\treturn LogisticsRenderPipe.secondRenderer;\n\t}\n}",
    "code_after_change": "\t\t\tif (getRouterId() == destinationint) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tExitRoute route = getRouter().getExitFor(destinationint, isActive, ident);\n\t\t\tif (route != null && route.exitOrientation != ignore) {\n\t\t\t\tif (route.distanceToDestination + traveled >= max) {\n\t\t\t\t\treturn Integer.MAX_VALUE;\n\t\t\t\t}\n\t\t\t\treturn route.distanceToDestination;\n\t\t\t}\n\t\t}\n\t\treturn Integer.MAX_VALUE;\n\t}\n\n\tpublic void triggerConnectionCheck() {\n\t\trecheckConnections = true;\n\t}\n\n\t@Override\n\tpublic CacheHolder getCacheHolder() {\n\t\tif (cacheHolder == null) {\n\t\t\tif (container instanceof ILPTEInformation && ((ILPTEInformation) container).getObject() != null) {\n\t\t\t\tcacheHolder = ((ILPTEInformation) container).getObject().getCacheHolder();\n\t\t\t} else {\n\t\t\t\tcacheHolder = new CacheHolder();\n\t\t\t}\n\t\t}\n\t\treturn cacheHolder;\n\t}\n\n\t@Override\n\tpublic IHighlightPlacementRenderer getHighlightRenderer() {\n\t\treturn LogisticsRenderPipe.secondRenderer;\n\t}\n\n\tpublic enum ItemSendMode {\n\t\tNormal,\n\t\tFast\n\t}\n}",
    "patch": "@@ -7,7 +7,6 @@\n \n package logisticspipes.pipes.basic;\n \n-import java.io.IOException;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.BitSet;\n@@ -132,71 +131,49 @@\n public abstract class CoreRoutedPipe extends CoreUnroutedPipe\n \t\timplements IClientState, IRequestItems, ITrackStatistics, IWorldProvider, IWatchingHandler, IPipeServiceProvider, IQueueCCEvent, ILPPositionProvider {\n \n-\tpublic enum ItemSendMode {\n-\t\tNormal,\n-\t\tFast\n-\t}\n-\n-\tprotected boolean stillNeedReplace = true;\n-\tprivate boolean recheckConnections = false;\n-\n-\tprotected IRouter router;\n-\tprotected String routerId;\n-\tprotected Object routerIdLock = new Object();\n \tprivate static int pipecount = 0;\n-\tprotected int _delayOffset = 0;\n-\n+\tpublic final PlayerCollectionList watchers = new PlayerCollectionList();\n+\tprotected final PriorityBlockingQueue<ItemRoutingInformation> _inTransitToMe = new PriorityBlockingQueue<>(10,\n+\t\t\tnew ItemRoutingInformation.DelayComparator());\n+\tprotected final LinkedList<Triplet<IRoutedItem, ForgeDirection, ItemSendMode>> _sendQueue = new LinkedList<>();\n+\tprotected final Map<ItemIdentifier, Queue<Pair<Integer, ItemRoutingInformation>>> queuedDataForUnroutedItems = Collections.synchronizedMap(new TreeMap<>());\n \tpublic boolean _textureBufferPowered;\n-\n-\tprotected boolean _initialInit = true;\n-\n-\tprivate boolean enabled = true;\n-\tprivate boolean preventRemove = false;\n-\tprivate boolean destroyByPlayer = false;\n-\tprivate PowerSupplierHandler powerHandler = new PowerSupplierHandler(this);\n-\n \tpublic long delayTo = 0;\n \tpublic int repeatFor = 0;\n-\n-\tprotected RouteLayer _routeLayer;\n-\tprotected TransportLayer _transportLayer;\n-\tprotected final PriorityBlockingQueue<ItemRoutingInformation> _inTransitToMe = new PriorityBlockingQueue<>(10,\n-\t\t\tnew ItemRoutingInformation.DelayComparator());\n-\n-\tprotected UpgradeManager upgradeManager = new UpgradeManager(this);\n-\tprotected LogisticsItemOrderManager _orderItemManager = null;\n-\n-\t@Getter\n-\tprivate List<IOrderInfoProvider> clientSideOrderManager = new ArrayList<>();\n-\n \tpublic int stat_session_sent;\n \tpublic int stat_session_recieved;\n \tpublic int stat_session_relayed;\n-\n \tpublic long stat_lifetime_sent;\n \tpublic long stat_lifetime_recieved;\n \tpublic long stat_lifetime_relayed;\n-\n \tpublic int server_routing_table_size = 0;\n-\n-\tprotected final LinkedList<Triplet<IRoutedItem, ForgeDirection, ItemSendMode>> _sendQueue = new LinkedList<>();\n-\n-\tprotected final Map<ItemIdentifier, Queue<Pair<Integer, ItemRoutingInformation>>> queuedDataForUnroutedItems = Collections.synchronizedMap(new TreeMap<>());\n-\n-\tpublic final PlayerCollectionList watchers = new PlayerCollectionList();\n-\n+\tpublic boolean globalIgnoreConnectionDisconnection = false;\n+\tprotected boolean stillNeedReplace = true;\n+\tprotected IRouter router;\n+\tprotected String routerId;\n+\tprotected Object routerIdLock = new Object();\n+\tprotected int _delayOffset = 0;\n+\tprotected boolean _initialInit = true;\n+\tprotected RouteLayer _routeLayer;\n+\tprotected TransportLayer _transportLayer;\n+\tprotected UpgradeManager upgradeManager = new UpgradeManager(this);\n+\tprotected LogisticsItemOrderManager _orderItemManager = null;\n \tprotected List<IInventory> _cachedAdjacentInventories;\n-\n \tprotected ForgeDirection pointedDirection = ForgeDirection.UNKNOWN;\n \t//public BaseRoutingLogic logic;\n \t// from BaseRoutingLogic\n \tprotected int throttleTime = 20;\n+\tprotected IPipeSign[] signItem = new IPipeSign[6];\n+\tprivate boolean recheckConnections = false;\n+\tprivate boolean enabled = true;\n+\tprivate boolean preventRemove = false;\n+\tprivate boolean destroyByPlayer = false;\n+\tprivate PowerSupplierHandler powerHandler = new PowerSupplierHandler(this);\n+\t@Getter\n+\tprivate List<IOrderInfoProvider> clientSideOrderManager = new ArrayList<>();\n \tprivate int throttleTimeLeft = 20 + new Random().nextInt(Configs.LOGISTICS_DETECTION_FREQUENCY);\n-\n \tprivate int[] queuedParticles = new int[Particles.values().length];\n \tprivate boolean hasQueuedParticles = false;\n-\n-\tprotected IPipeSign[] signItem = new IPipeSign[6];\n \tprivate boolean isOpaqueClientSide = false;\n \n \tprivate CacheHolder cacheHolder;\n@@ -1030,8 +1007,6 @@ public final boolean canPipeConnect(TileEntity tile, ForgeDirection dir) {\n \t\treturn canPipeConnect(tile, dir, false);\n \t}\n \n-\tpublic boolean globalIgnoreConnectionDisconnection = false;\n-\n \t@Override\n \tpublic final boolean canPipeConnect(TileEntity tile, ForgeDirection dir, boolean ignoreSystemDisconnection) {\n \t\tForgeDirection side = OrientationsUtil.getOrientationOfTilewithTile(container, tile);\n@@ -1072,8 +1047,6 @@ public void insetSecurityID(UUID id) {\n \t\tgetOriginalUpgradeManager().insetSecurityID(id);\n \t}\n \n-\t/* Power System */\n-\n \tpublic List<Pair<ILogisticsPowerProvider, List<IFilter>>> getRoutedPowerProviders() {\n \t\tif (MainProxy.isClient(getWorld())) {\n \t\t\treturn null;\n@@ -1084,6 +1057,8 @@ public List<Pair<ILogisticsPowerProvider, List<IFilter>>> getRoutedPowerProvider\n \t\treturn getRouter().getPowerProvider();\n \t}\n \n+\t/* Power System */\n+\n \t@Override\n \tpublic boolean useEnergy(int amount) {\n \t\treturn useEnergy(amount, null, true);\n@@ -1378,21 +1353,21 @@ public String getRouterUUID(Double id) {\n \t\treturn router.getId().toString();\n \t}\n \n-\t@CCCommand(description = \"Sets the TurtleConnect flag for this Turtle on this LogisticsPipe\")\n+\t@CCCommand(description = \"Returns the TurtleConnect flag for this Turtle on this LogisticsPipe\")\n \t@CCDirectCall\n-\tpublic void setTurtleConnect(Boolean flag) {\n+\tpublic boolean getTurtleConnect() {\n \t\tif (container instanceof LogisticsTileGenericPipe) {\n-\t\t\tcontainer.setTurtleConnect(flag);\n+\t\t\treturn container.getTurtleConnect();\n \t\t}\n+\t\treturn false;\n \t}\n \n-\t@CCCommand(description = \"Returns the TurtleConnect flag for this Turtle on this LogisticsPipe\")\n+\t@CCCommand(description = \"Sets the TurtleConnect flag for this Turtle on this LogisticsPipe\")\n \t@CCDirectCall\n-\tpublic boolean getTurtleConnect() {\n+\tpublic void setTurtleConnect(Boolean flag) {\n \t\tif (container instanceof LogisticsTileGenericPipe) {\n-\t\t\treturn container.getTurtleConnect();\n+\t\t\tcontainer.setTurtleConnect(flag);\n \t\t}\n-\t\treturn false;\n \t}\n \n \t@CCCommand(description = \"Returns true if the computer is allowed to interact with the connected pipe.\", needPermission = false)\n@@ -1743,12 +1718,12 @@ public IPipeSign getPipeSign(ForgeDirection dir) {\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\toutput.writeBoolean(isOpaque());\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tisOpaqueClientSide = input.readBoolean();\n \t}\n \n@@ -1841,4 +1816,9 @@ public CacheHolder getCacheHolder() {\n \tpublic IHighlightPlacementRenderer getHighlightRenderer() {\n \t\treturn LogisticsRenderPipe.secondRenderer;\n \t}\n+\n+\tpublic enum ItemSendMode {\n+\t\tNormal,\n+\t\tFast\n+\t}\n }",
    "function_modified_lines": {
      "added": [
        "\n",
        "\tpublic enum ItemSendMode {\n",
        "\t\tNormal,\n",
        "\t\tFast\n",
        "\t}\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12827
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "\t\t\treturn true;\n\t\t}\n\n\t\tif (!SimpleServiceLocator.buildCraftProxy.checkForPipeConnection(with, side, this)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (SimpleServiceLocator.thermalDynamicsProxy.isBlockedSide(with, side.getOpposite())) {\n\t\t\treturn false;\n\t\t}\n\t\tif (with instanceof LogisticsTileGenericPipe) {\n\t\t\tif (((LogisticsTileGenericPipe) with).tilePart.hasBlockingPluggable(side.getOpposite())) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tCoreUnroutedPipe otherPipe = ((LogisticsTileGenericPipe) with).pipe;\n\n\t\t\tif (!(LogisticsBlockGenericPipe.isValid(otherPipe))) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (!(otherPipe.canPipeConnect(this, side.getOpposite()))) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn pipe.canPipeConnect(with, side);\n\t}\n\n\tpublic void queueEvent(String event, Object[] arguments) {\n\t\tSimpleServiceLocator.ccProxy.queueEvent(event, arguments, this);\n\t}\n\n\tpublic void handleMesssage(int computerId, Object message, int sourceId) {\n\t\tSimpleServiceLocator.ccProxy.handleMesssage(computerId, message, this, sourceId);\n\t}\n\n\tpublic void setTurtleConnect(boolean flag) {\n\t\tSimpleServiceLocator.ccProxy.setTurtleConnect(flag, this);\n\t}\n\n\tpublic boolean getTurtleConnect() {\n\t\treturn SimpleServiceLocator.ccProxy.getTurtleConnect(this);\n\t}\n\n\tpublic int getLastCCID() {\n\t\treturn SimpleServiceLocator.ccProxy.getLastCCID(this);\n\t}\n\n\t@Override\n\tpublic ItemStack insertItem(ForgeDirection dir, ItemStack stack) {\n\t\tint used = injectItem(stack, true, dir);\n\t\tif (used == stack.stackSize) {\n\t\t\treturn null;\n\t\t} else {\n\t\t\tstack = stack.copy();\n\t\t\tstack.stackSize -= used;\n\t\t\treturn stack;\n\t\t}\n\t}\n\n\tpublic void addLaser(ForgeDirection dir, float length, int color, boolean reverse, boolean renderBall) {\n\t\tgetRenderController().addLaser(dir, length, color, reverse, renderBall);\n\t}\n\n\tpublic void removeLaser(ForgeDirection dir, int color, boolean isBall) {\n\t\tgetRenderController().removeLaser(dir, color, isBall);\n\t}\n\n\tpublic LogisticsTileRenderController getRenderController() {\n\t\tif (renderController == null) {\n\t\t\trenderController = new LogisticsTileRenderController(this);\n\t\t}\n\t\treturn renderController;\n\t}\n\n\t/* IPipeInformationProvider */",
    "code_after_change": "\t\t\treturn false;\n\t\t}\n\t\tif (SimpleServiceLocator.thermalDynamicsProxy.isBlockedSide(with, side.getOpposite())) {\n\t\t\treturn false;\n\t\t}\n\t\tif (with instanceof LogisticsTileGenericPipe) {\n\t\t\tif (((LogisticsTileGenericPipe) with).tilePart.hasBlockingPluggable(side.getOpposite())) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tCoreUnroutedPipe otherPipe = ((LogisticsTileGenericPipe) with).pipe;\n\n\t\t\tif (!(LogisticsBlockGenericPipe.isValid(otherPipe))) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (!(otherPipe.canPipeConnect(this, side.getOpposite()))) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn pipe.canPipeConnect(with, side);\n\t}\n\n\tpublic void queueEvent(String event, Object[] arguments) {\n\t\tSimpleServiceLocator.ccProxy.queueEvent(event, arguments, this);\n\t}\n\n\tpublic void handleMesssage(int computerId, Object message, int sourceId) {\n\t\tSimpleServiceLocator.ccProxy.handleMesssage(computerId, message, this, sourceId);\n\t}\n\n\tpublic boolean getTurtleConnect() {\n\t\treturn SimpleServiceLocator.ccProxy.getTurtleConnect(this);\n\t}\n\n\tpublic void setTurtleConnect(boolean flag) {\n\t\tSimpleServiceLocator.ccProxy.setTurtleConnect(flag, this);\n\t}\n\n\tpublic int getLastCCID() {\n\t\treturn SimpleServiceLocator.ccProxy.getLastCCID(this);\n\t}\n\n\t@Override\n\tpublic ItemStack insertItem(ForgeDirection dir, ItemStack stack) {\n\t\tint used = injectItem(stack, true, dir);\n\t\tif (used == stack.stackSize) {\n\t\t\treturn null;\n\t\t} else {\n\t\t\tstack = stack.copy();\n\t\t\tstack.stackSize -= used;\n\t\t\treturn stack;\n\t\t}\n\t}\n\n\tpublic void addLaser(ForgeDirection dir, float length, int color, boolean reverse, boolean renderBall) {\n\t\tgetRenderController().addLaser(dir, length, color, reverse, renderBall);\n\t}\n\n\tpublic void removeLaser(ForgeDirection dir, int color, boolean isBall) {\n\t\tgetRenderController().removeLaser(dir, color, isBall);\n\t}\n\n\tpublic LogisticsTileRenderController getRenderController() {\n\t\tif (renderController == null) {\n\t\t\trenderController = new LogisticsTileRenderController(this);\n\t\t}\n\t\treturn renderController;\n\t}\n\n\t@Override\n\tpublic boolean isCorrect(ConnectionPipeType type) {\n\t\treturn true;\n\t}\n",
    "patch": "@@ -1,6 +1,5 @@\n package logisticspipes.pipes.basic;\n \n-import java.io.IOException;\n import java.util.Arrays;\n import java.util.HashMap;\n import java.util.HashSet;\n@@ -94,33 +93,38 @@ public class LogisticsTileGenericPipe extends TileEntity\n \t\timplements IOCTile, ILPPipeTile, IPipeInformationProvider, IItemDuct, ManagedPeripheral, Environment, SidedEnvironment, IFluidHandler, IPipeTile,\n \t\tILogicControllerTile, IPipeConnection {\n \n+\tpublic final PipeRenderState renderState;\n+\tpublic final CoreState coreState = new CoreState();\n+\tpublic final IBCTilePart tilePart;\n+\tpublic final IBCPluggableState bcPlugableState;\n+\tpublic final ITDPart tdPart;\n \tpublic Object OPENPERIPHERAL_IGNORE; //Tell OpenPeripheral to ignore this class\n-\n \tpublic Set<DoubleCoordinates> subMultiBlock = new HashSet<>();\n-\n \tpublic boolean[] turtleConnect = new boolean[7];\n-\n-\tprivate LogisticsTileRenderController renderController;\n-\n \t@ModDependentField(modId = LPConstants.computerCraftModID)\n \tpublic HashMap<IComputerAccess, ForgeDirection> connections;\n-\n \t@ModDependentField(modId = LPConstants.computerCraftModID)\n \tpublic IComputerAccess currentPC;\n-\n \t@ModDependentField(modId = LPConstants.openComputersModID)\n \tpublic Node node;\n+\tpublic LogicController logicController = new LogicController();\n+\tpublic boolean[] pipeConnectionsBuffer = new boolean[6];\n+\tpublic boolean[] pipeBCConnectionsBuffer = new boolean[6];\n+\tpublic boolean[] pipeTDConnectionsBuffer = new boolean[6];\n+\tpublic CoreUnroutedPipe pipe;\n+\tprivate LogisticsTileRenderController renderController;\n \tprivate boolean addedToNetwork = false;\n-\n \tprivate boolean sendInitPacket = true;\n-\n-\tpublic LogicController logicController = new LogicController();\n-\n-\tpublic final PipeRenderState renderState;\n-\tpublic final CoreState coreState = new CoreState();\n-\tpublic final IBCTilePart tilePart;\n-\tpublic final IBCPluggableState bcPlugableState;\n-\tpublic final ITDPart tdPart;\n+\t@Getter\n+\tprivate boolean initialized = false;\n+\tprivate boolean deletePipe = false;\n+\tprivate TileBuffer[] tileBuffer;\n+\tprivate boolean sendClientUpdate = false;\n+\tprivate boolean blockNeighborChange = false;\n+\tprivate boolean refreshRenderState = false;\n+\tprivate boolean pipeBound = false;\n+\t@SideOnly(Side.CLIENT)\n+\tprivate AxisAlignedBB renderBox;\n \n \tpublic LogisticsTileGenericPipe() {\n \t\tif (SimpleServiceLocator.ccProxy.isCC()) {\n@@ -314,6 +318,8 @@ public void scheduleNeighborChange() {\n \t\t}\n \t}\n \n+\t/* IPipeInformationProvider */\n+\n \t@Override\n \tpublic void writeToNBT(NBTTagCompound nbt) {\n \t\tsuper.writeToNBT(nbt);\n@@ -439,14 +445,14 @@ public void handleMesssage(int computerId, Object message, int sourceId) {\n \t\tSimpleServiceLocator.ccProxy.handleMesssage(computerId, message, this, sourceId);\n \t}\n \n-\tpublic void setTurtleConnect(boolean flag) {\n-\t\tSimpleServiceLocator.ccProxy.setTurtleConnect(flag, this);\n-\t}\n-\n \tpublic boolean getTurtleConnect() {\n \t\treturn SimpleServiceLocator.ccProxy.getTurtleConnect(this);\n \t}\n \n+\tpublic void setTurtleConnect(boolean flag) {\n+\t\tSimpleServiceLocator.ccProxy.setTurtleConnect(flag, this);\n+\t}\n+\n \tpublic int getLastCCID() {\n \t\treturn SimpleServiceLocator.ccProxy.getLastCCID(this);\n \t}\n@@ -478,8 +484,6 @@ public LogisticsTileRenderController getRenderController() {\n \t\treturn renderController;\n \t}\n \n-\t/* IPipeInformationProvider */\n-\n \t@Override\n \tpublic boolean isCorrect(ConnectionPipeType type) {\n \t\treturn true;\n@@ -632,6 +636,8 @@ public Node node() {\n \t@Override\n \t@ModDependentMethod(modId = LPConstants.openComputersModID)\n \tpublic void onConnect(Node node1) {}\n+\t//public int redstoneInput = 0;\n+\t//public int[] redstoneInputSide = new int[ForgeDirection.VALID_DIRECTIONS.length];\n \n \t@Override\n \t@ModDependentMethod(modId = LPConstants.openComputersModID)\n@@ -677,41 +683,6 @@ public Object getOCNode() {\n \t\treturn node();\n \t}\n \n-\t@Getter\n-\tprivate boolean initialized = false;\n-\n-\tpublic boolean[] pipeConnectionsBuffer = new boolean[6];\n-\tpublic boolean[] pipeBCConnectionsBuffer = new boolean[6];\n-\tpublic boolean[] pipeTDConnectionsBuffer = new boolean[6];\n-\n-\tpublic CoreUnroutedPipe pipe;\n-\t//public int redstoneInput = 0;\n-\t//public int[] redstoneInputSide = new int[ForgeDirection.VALID_DIRECTIONS.length];\n-\n-\tprivate boolean deletePipe = false;\n-\tprivate TileBuffer[] tileBuffer;\n-\tprivate boolean sendClientUpdate = false;\n-\tprivate boolean blockNeighborChange = false;\n-\tprivate boolean refreshRenderState = false;\n-\tprivate boolean pipeBound = false;\n-\n-\tpublic class CoreState implements IClientState {\n-\n-\t\tpublic int pipeId = -1;\n-\n-\t\t@Override\n-\t\tpublic void writeData(LPDataOutput output) throws IOException {\n-\t\t\toutput.writeInt(pipeId);\n-\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void readData(LPDataInput input) throws IOException {\n-\t\t\tpipeId = input.readInt();\n-\n-\t\t}\n-\t}\n-\n \tpublic void initialize(CoreUnroutedPipe pipe) {\n \t\tblockType = getBlockType();\n \n@@ -1091,9 +1062,6 @@ public void setWorldObj(World world) {\n \t\ttdPart.setWorldObj_LP(world);\n \t}\n \n-\t@SideOnly(Side.CLIENT)\n-\tprivate AxisAlignedBB renderBox;\n-\n \t@SideOnly(Side.CLIENT)\n \t@Override\n \tpublic AxisAlignedBB getRenderBoundingBox() {\n@@ -1155,4 +1123,21 @@ public boolean isMultiBlock() {\n \tpublic Stream<TileEntity> getPartsOfPipe() {\n \t\treturn this.subMultiBlock.stream().map(pos -> pos.getTileEntity(worldObj));\n \t}\n+\n+\tpublic class CoreState implements IClientState {\n+\n+\t\tpublic int pipeId = -1;\n+\n+\t\t@Override\n+\t\tpublic void writeData(LPDataOutput output) {\n+\t\t\toutput.writeInt(pipeId);\n+\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void readData(LPDataInput input) {\n+\t\t\tpipeId = input.readInt();\n+\n+\t\t}\n+\t}\n }",
    "function_modified_lines": {
      "added": [
        "\tpublic void setTurtleConnect(boolean flag) {\n",
        "\t\tSimpleServiceLocator.ccProxy.setTurtleConnect(flag, this);\n",
        "\t}\n",
        "\n"
      ],
      "deleted": [
        "\tpublic void setTurtleConnect(boolean flag) {\n",
        "\t\tSimpleServiceLocator.ccProxy.setTurtleConnect(flag, this);\n",
        "\t}\n",
        "\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12828
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "\tpublic Object[] invoke(String s, Context context, Arguments arguments) throws Exception {\n\t\tBaseWrapperClass object = (BaseWrapperClass) CCObjectWrapper.getWrappedObject(pipe, BaseWrapperClass.WRAPPER);\n\t\tobject.isDirectCall = true;\n\t\treturn CCObjectWrapper.createArray(object);\n\t}\n\n\t@Override\n\t@ModDependentMethod(modId = LPConstants.openComputersModID)\n\tpublic String[] methods() {\n\t\treturn new String[] { \"getPipe\" };\n\t}\n\n\t@Override\n\t@SideOnly(Side.CLIENT)\n\t@ModDependentMethod(modId = LPConstants.openComputersModID)\n\tpublic boolean canConnect(ForgeDirection dir) {\n\t\treturn !(this.getTile(dir) instanceof LogisticsTileGenericPipe) && !(this.getTile(dir) instanceof LogisticsSolidTileEntity);\n\t}\n\n\t@Override\n\t@ModDependentMethod(modId = LPConstants.openComputersModID)\n\tpublic Node sidedNode(ForgeDirection dir) {\n\t\tif (this.getTile(dir) instanceof LogisticsTileGenericPipe || this.getTile(dir) instanceof LogisticsSolidTileEntity) {\n\t\t\treturn null;\n\t\t} else {\n\t\t\treturn node();\n\t\t}\n\t}\n\n\t@Override\n\tpublic Object getOCNode() {\n\t\treturn node();\n\t}\n\n\t@Getter\n\tprivate boolean initialized = false;\n\n\tpublic boolean[] pipeConnectionsBuffer = new boolean[6];\n\tpublic boolean[] pipeBCConnectionsBuffer = new boolean[6];\n\tpublic boolean[] pipeTDConnectionsBuffer = new boolean[6];\n\n\tpublic CoreUnroutedPipe pipe;\n\t//public int redstoneInput = 0;\n\t//public int[] redstoneInputSide = new int[ForgeDirection.VALID_DIRECTIONS.length];\n\n\tprivate boolean deletePipe = false;\n\tprivate TileBuffer[] tileBuffer;\n\tprivate boolean sendClientUpdate = false;\n\tprivate boolean blockNeighborChange = false;\n\tprivate boolean refreshRenderState = false;\n\tprivate boolean pipeBound = false;\n\n\tpublic class CoreState implements IClientState {\n\n\t\tpublic int pipeId = -1;\n\n\t\t@Override\n\t\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\t\toutput.writeInt(pipeId);\n\n\t\t}\n\n\t\t@Override\n\t\tpublic void readData(LPDataInput input) throws IOException {\n\t\t\tpipeId = input.readInt();\n\n\t\t}\n\t}\n\n\tpublic void initialize(CoreUnroutedPipe pipe) {\n\t\tblockType = getBlockType();\n\n\t\tif (pipe == null) {\n\t\t\tLogisticsPipes.log.log(Level.WARN, \"Pipe failed to initialize at {0},{1},{2}, deleting\", xCoord, yCoord, zCoord);\n\t\t\tworldObj.setBlockToAir(xCoord, yCoord, zCoord);\n\t\t\treturn;\n\t\t}\n\n\t\tthis.pipe = pipe;\n\n\t\tfor (ForgeDirection o : ForgeDirection.VALID_DIRECTIONS) {\n\t\t\tTileEntity tile = getTile(o);\n\n\t\t\tif (tile instanceof LogisticsTileGenericPipe) {\n\t\t\t\t((LogisticsTileGenericPipe) tile).scheduleNeighborChange();\n\t\t\t}\n\n\t\t\tSimpleServiceLocator.buildCraftProxy.notifyOfChange(this, tile, o);\n\t\t}\n\n\t\tbindPipe();\n\n\t\tcomputeConnections();\n\t\tscheduleRenderUpdate();\n\n\t\tif (pipe.needsInit()) {\n\t\t\tpipe.initialize();\n\t\t}\n\n\t\tinitialized = true;\n\t}\n\n\tprivate void bindPipe() {\n\t\tif (!pipeBound && pipe != null) {\n\t\t\tpipe.setTile(this);",
    "code_after_change": "\t@Override\n\t@ModDependentMethod(modId = LPConstants.openComputersModID)\n\tpublic Object[] invoke(String s, Context context, Arguments arguments) throws Exception {\n\t\tBaseWrapperClass object = (BaseWrapperClass) CCObjectWrapper.getWrappedObject(pipe, BaseWrapperClass.WRAPPER);\n\t\tobject.isDirectCall = true;\n\t\treturn CCObjectWrapper.createArray(object);\n\t}\n\n\t@Override\n\t@ModDependentMethod(modId = LPConstants.openComputersModID)\n\tpublic String[] methods() {\n\t\treturn new String[] { \"getPipe\" };\n\t}\n\n\t@Override\n\t@SideOnly(Side.CLIENT)\n\t@ModDependentMethod(modId = LPConstants.openComputersModID)\n\tpublic boolean canConnect(ForgeDirection dir) {\n\t\treturn !(this.getTile(dir) instanceof LogisticsTileGenericPipe) && !(this.getTile(dir) instanceof LogisticsSolidTileEntity);\n\t}\n\n\t@Override\n\t@ModDependentMethod(modId = LPConstants.openComputersModID)\n\tpublic Node sidedNode(ForgeDirection dir) {\n\t\tif (this.getTile(dir) instanceof LogisticsTileGenericPipe || this.getTile(dir) instanceof LogisticsSolidTileEntity) {\n\t\t\treturn null;\n\t\t} else {\n\t\t\treturn node();\n\t\t}\n\t}\n\n\t@Override\n\tpublic Object getOCNode() {\n\t\treturn node();\n\t}\n\n\tpublic void initialize(CoreUnroutedPipe pipe) {\n\t\tblockType = getBlockType();\n\n\t\tif (pipe == null) {\n\t\t\tLogisticsPipes.log.log(Level.WARN, \"Pipe failed to initialize at {0},{1},{2}, deleting\", xCoord, yCoord, zCoord);\n\t\t\tworldObj.setBlockToAir(xCoord, yCoord, zCoord);\n\t\t\treturn;\n\t\t}\n\n\t\tthis.pipe = pipe;\n\n\t\tfor (ForgeDirection o : ForgeDirection.VALID_DIRECTIONS) {\n\t\t\tTileEntity tile = getTile(o);\n\n\t\t\tif (tile instanceof LogisticsTileGenericPipe) {\n\t\t\t\t((LogisticsTileGenericPipe) tile).scheduleNeighborChange();\n\t\t\t}\n\n\t\t\tSimpleServiceLocator.buildCraftProxy.notifyOfChange(this, tile, o);\n\t\t}\n\n\t\tbindPipe();\n\n\t\tcomputeConnections();\n\t\tscheduleRenderUpdate();\n\n\t\tif (pipe.needsInit()) {\n\t\t\tpipe.initialize();\n\t\t}\n\n\t\tinitialized = true;\n\t}\n\n\tprivate void bindPipe() {\n\t\tif (!pipeBound && pipe != null) {\n\t\t\tpipe.setTile(this);\n\t\t\tcoreState.pipeId = Item.getIdFromItem(pipe.item);\n\t\t\tpipeBound = true;",
    "patch": "@@ -1,6 +1,5 @@\n package logisticspipes.pipes.basic;\n \n-import java.io.IOException;\n import java.util.Arrays;\n import java.util.HashMap;\n import java.util.HashSet;\n@@ -94,33 +93,38 @@ public class LogisticsTileGenericPipe extends TileEntity\n \t\timplements IOCTile, ILPPipeTile, IPipeInformationProvider, IItemDuct, ManagedPeripheral, Environment, SidedEnvironment, IFluidHandler, IPipeTile,\n \t\tILogicControllerTile, IPipeConnection {\n \n+\tpublic final PipeRenderState renderState;\n+\tpublic final CoreState coreState = new CoreState();\n+\tpublic final IBCTilePart tilePart;\n+\tpublic final IBCPluggableState bcPlugableState;\n+\tpublic final ITDPart tdPart;\n \tpublic Object OPENPERIPHERAL_IGNORE; //Tell OpenPeripheral to ignore this class\n-\n \tpublic Set<DoubleCoordinates> subMultiBlock = new HashSet<>();\n-\n \tpublic boolean[] turtleConnect = new boolean[7];\n-\n-\tprivate LogisticsTileRenderController renderController;\n-\n \t@ModDependentField(modId = LPConstants.computerCraftModID)\n \tpublic HashMap<IComputerAccess, ForgeDirection> connections;\n-\n \t@ModDependentField(modId = LPConstants.computerCraftModID)\n \tpublic IComputerAccess currentPC;\n-\n \t@ModDependentField(modId = LPConstants.openComputersModID)\n \tpublic Node node;\n+\tpublic LogicController logicController = new LogicController();\n+\tpublic boolean[] pipeConnectionsBuffer = new boolean[6];\n+\tpublic boolean[] pipeBCConnectionsBuffer = new boolean[6];\n+\tpublic boolean[] pipeTDConnectionsBuffer = new boolean[6];\n+\tpublic CoreUnroutedPipe pipe;\n+\tprivate LogisticsTileRenderController renderController;\n \tprivate boolean addedToNetwork = false;\n-\n \tprivate boolean sendInitPacket = true;\n-\n-\tpublic LogicController logicController = new LogicController();\n-\n-\tpublic final PipeRenderState renderState;\n-\tpublic final CoreState coreState = new CoreState();\n-\tpublic final IBCTilePart tilePart;\n-\tpublic final IBCPluggableState bcPlugableState;\n-\tpublic final ITDPart tdPart;\n+\t@Getter\n+\tprivate boolean initialized = false;\n+\tprivate boolean deletePipe = false;\n+\tprivate TileBuffer[] tileBuffer;\n+\tprivate boolean sendClientUpdate = false;\n+\tprivate boolean blockNeighborChange = false;\n+\tprivate boolean refreshRenderState = false;\n+\tprivate boolean pipeBound = false;\n+\t@SideOnly(Side.CLIENT)\n+\tprivate AxisAlignedBB renderBox;\n \n \tpublic LogisticsTileGenericPipe() {\n \t\tif (SimpleServiceLocator.ccProxy.isCC()) {\n@@ -314,6 +318,8 @@ public void scheduleNeighborChange() {\n \t\t}\n \t}\n \n+\t/* IPipeInformationProvider */\n+\n \t@Override\n \tpublic void writeToNBT(NBTTagCompound nbt) {\n \t\tsuper.writeToNBT(nbt);\n@@ -439,14 +445,14 @@ public void handleMesssage(int computerId, Object message, int sourceId) {\n \t\tSimpleServiceLocator.ccProxy.handleMesssage(computerId, message, this, sourceId);\n \t}\n \n-\tpublic void setTurtleConnect(boolean flag) {\n-\t\tSimpleServiceLocator.ccProxy.setTurtleConnect(flag, this);\n-\t}\n-\n \tpublic boolean getTurtleConnect() {\n \t\treturn SimpleServiceLocator.ccProxy.getTurtleConnect(this);\n \t}\n \n+\tpublic void setTurtleConnect(boolean flag) {\n+\t\tSimpleServiceLocator.ccProxy.setTurtleConnect(flag, this);\n+\t}\n+\n \tpublic int getLastCCID() {\n \t\treturn SimpleServiceLocator.ccProxy.getLastCCID(this);\n \t}\n@@ -478,8 +484,6 @@ public LogisticsTileRenderController getRenderController() {\n \t\treturn renderController;\n \t}\n \n-\t/* IPipeInformationProvider */\n-\n \t@Override\n \tpublic boolean isCorrect(ConnectionPipeType type) {\n \t\treturn true;\n@@ -632,6 +636,8 @@ public Node node() {\n \t@Override\n \t@ModDependentMethod(modId = LPConstants.openComputersModID)\n \tpublic void onConnect(Node node1) {}\n+\t//public int redstoneInput = 0;\n+\t//public int[] redstoneInputSide = new int[ForgeDirection.VALID_DIRECTIONS.length];\n \n \t@Override\n \t@ModDependentMethod(modId = LPConstants.openComputersModID)\n@@ -677,41 +683,6 @@ public Object getOCNode() {\n \t\treturn node();\n \t}\n \n-\t@Getter\n-\tprivate boolean initialized = false;\n-\n-\tpublic boolean[] pipeConnectionsBuffer = new boolean[6];\n-\tpublic boolean[] pipeBCConnectionsBuffer = new boolean[6];\n-\tpublic boolean[] pipeTDConnectionsBuffer = new boolean[6];\n-\n-\tpublic CoreUnroutedPipe pipe;\n-\t//public int redstoneInput = 0;\n-\t//public int[] redstoneInputSide = new int[ForgeDirection.VALID_DIRECTIONS.length];\n-\n-\tprivate boolean deletePipe = false;\n-\tprivate TileBuffer[] tileBuffer;\n-\tprivate boolean sendClientUpdate = false;\n-\tprivate boolean blockNeighborChange = false;\n-\tprivate boolean refreshRenderState = false;\n-\tprivate boolean pipeBound = false;\n-\n-\tpublic class CoreState implements IClientState {\n-\n-\t\tpublic int pipeId = -1;\n-\n-\t\t@Override\n-\t\tpublic void writeData(LPDataOutput output) throws IOException {\n-\t\t\toutput.writeInt(pipeId);\n-\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void readData(LPDataInput input) throws IOException {\n-\t\t\tpipeId = input.readInt();\n-\n-\t\t}\n-\t}\n-\n \tpublic void initialize(CoreUnroutedPipe pipe) {\n \t\tblockType = getBlockType();\n \n@@ -1091,9 +1062,6 @@ public void setWorldObj(World world) {\n \t\ttdPart.setWorldObj_LP(world);\n \t}\n \n-\t@SideOnly(Side.CLIENT)\n-\tprivate AxisAlignedBB renderBox;\n-\n \t@SideOnly(Side.CLIENT)\n \t@Override\n \tpublic AxisAlignedBB getRenderBoundingBox() {\n@@ -1155,4 +1123,21 @@ public boolean isMultiBlock() {\n \tpublic Stream<TileEntity> getPartsOfPipe() {\n \t\treturn this.subMultiBlock.stream().map(pos -> pos.getTileEntity(worldObj));\n \t}\n+\n+\tpublic class CoreState implements IClientState {\n+\n+\t\tpublic int pipeId = -1;\n+\n+\t\t@Override\n+\t\tpublic void writeData(LPDataOutput output) {\n+\t\t\toutput.writeInt(pipeId);\n+\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void readData(LPDataInput input) {\n+\t\t\tpipeId = input.readInt();\n+\n+\t\t}\n+\t}\n }",
    "function_modified_lines": {
      "added": [],
      "deleted": [
        "\t@Getter\n",
        "\tprivate boolean initialized = false;\n",
        "\n",
        "\tpublic boolean[] pipeConnectionsBuffer = new boolean[6];\n",
        "\tpublic boolean[] pipeBCConnectionsBuffer = new boolean[6];\n",
        "\tpublic boolean[] pipeTDConnectionsBuffer = new boolean[6];\n",
        "\n",
        "\tpublic CoreUnroutedPipe pipe;\n",
        "\t//public int redstoneInput = 0;\n",
        "\t//public int[] redstoneInputSide = new int[ForgeDirection.VALID_DIRECTIONS.length];\n",
        "\n",
        "\tprivate boolean deletePipe = false;\n",
        "\tprivate TileBuffer[] tileBuffer;\n",
        "\tprivate boolean sendClientUpdate = false;\n",
        "\tprivate boolean blockNeighborChange = false;\n",
        "\tprivate boolean refreshRenderState = false;\n",
        "\tprivate boolean pipeBound = false;\n",
        "\n",
        "\tpublic class CoreState implements IClientState {\n",
        "\n",
        "\t\tpublic int pipeId = -1;\n",
        "\n",
        "\t\t@Override\n",
        "\t\tpublic void writeData(LPDataOutput output) throws IOException {\n",
        "\t\t\toutput.writeInt(pipeId);\n",
        "\n",
        "\t\t}\n",
        "\n",
        "\t\t@Override\n",
        "\t\tpublic void readData(LPDataInput input) throws IOException {\n",
        "\t\t\tpipeId = input.readInt();\n",
        "\n",
        "\t\t}\n",
        "\t}\n",
        "\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12829
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "import java.io.IOException;\nimport java.util.List;\n\nimport net.minecraft.entity.player.EntityPlayer;\nimport net.minecraft.item.Item;\nimport net.minecraft.nbt.NBTTagCompound;\nimport net.minecraft.tileentity.TileEntity;\nimport net.minecraft.util.AxisAlignedBB;\nimport net.minecraftforge.common.util.ForgeDirection;\nimport cpw.mods.fml.relauncher.Side;\nimport cpw.mods.fml.relauncher.SideOnly;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Getter;\n\nimport logisticspipes.LPConstants;\nimport logisticspipes.interfaces.ITubeOrientation;\nimport logisticspipes.interfaces.ITubeRenderOrientation;\nimport logisticspipes.pipes.basic.CoreMultiBlockPipe;\nimport logisticspipes.pipes.basic.LogisticsTileGenericSubMultiBlock;\nimport logisticspipes.renderer.newpipe.IHighlightPlacementRenderer;\nimport logisticspipes.renderer.newpipe.ISpecialPipeRenderer;\nimport logisticspipes.renderer.newpipe.tube.CurveTubeRenderer;\nimport logisticspipes.transport.LPTravelingItem;\nimport logisticspipes.transport.PipeMultiBlockTransportLogistics;\nimport logisticspipes.utils.IPositionRotateble;\nimport logisticspipes.utils.LPPositionSet;\nimport network.rs485.logisticspipes.util.LPDataInput;\nimport network.rs485.logisticspipes.util.LPDataOutput;\nimport network.rs485.logisticspipes.world.DoubleCoordinates;\nimport network.rs485.logisticspipes.world.DoubleCoordinatesType;\n\npublic class HSTubeCurve extends CoreMultiBlockPipe {\n\n\t@AllArgsConstructor\n\tpublic enum CurveOrientation implements ITubeOrientation {\n\t\t//@formatter:off\n\t\t// Name: Placement from  _ TurnDirection\n\t\tNORTH_NORTH_EAST(TurnDirection.NORTH_EAST, new DoubleCoordinates(2, 0, 2), ForgeDirection.NORTH, ForgeDirection.EAST),\n\t\tNORTH_WEST_NORTH(TurnDirection.WEST_NORTH, new DoubleCoordinates(0, 0, 0), ForgeDirection.NORTH, ForgeDirection.WEST),\n\t\tWEST_WEST_NORTH(TurnDirection.WEST_NORTH, new DoubleCoordinates(2, 0, -2), ForgeDirection.WEST, ForgeDirection.NORTH),\n\t\tWEST_SOUTH_WEST(TurnDirection.SOUTH_WEST, new DoubleCoordinates(0, 0, 0), ForgeDirection.WEST, ForgeDirection.SOUTH),\n\t\tSOUTH_SOUTH_WEST(TurnDirection.SOUTH_WEST, new DoubleCoordinates(-2, 0, -2), ForgeDirection.SOUTH, ForgeDirection.WEST),\n\t\tSOUTH_EAST_SOUTH(TurnDirection.EAST_SOUTH, new DoubleCoordinates(0, 0, 0), ForgeDirection.SOUTH, ForgeDirection.EAST),\n\t\tEAST_EAST_SOUTH(TurnDirection.EAST_SOUTH, new DoubleCoordinates(-2, 0, 2), ForgeDirection.EAST, ForgeDirection.SOUTH),\n\t\tEAST_NORTH_EAST(TurnDirection.NORTH_EAST, new DoubleCoordinates(0, 0, 0), ForgeDirection.EAST, ForgeDirection.NORTH);\n\t\t//@formatter:on\n\t\t@Getter\n\t\tTurnDirection renderOrientation;\n\t\t@Getter\n\t\tDoubleCoordinates offset;\n\t\t@Getter\n\t\tForgeDirection from;\n\t\t@Getter\n\t\tForgeDirection looking;\n\n\t\t@Override\n\t\tpublic void rotatePositions(IPositionRotateble set) {\n\t\t\trenderOrientation.rotatePositions(set);\n\t\t}\n\n\t\t@Override\n\t\tpublic void setOnPipe(CoreMultiBlockPipe pipe) {\n\t\t\t((HSTubeCurve) pipe).orientation = this;\n\t\t}\n\t}\n\n\t@AllArgsConstructor\n\tpublic enum TurnDirection implements ITubeRenderOrientation {\n\t\t//@formatter:off\n\t\tNORTH_EAST(ForgeDirection.NORTH, ForgeDirection.EAST),\n\t\tEAST_SOUTH(ForgeDirection.EAST, ForgeDirection.SOUTH),\n\t\tSOUTH_WEST(ForgeDirection.SOUTH, ForgeDirection.WEST),\n\t\tWEST_NORTH(ForgeDirection.WEST, ForgeDirection.NORTH);\n\t\t//@formatter:on\n\t\t@Getter\n\t\tForgeDirection dir1;\n\t\tForgeDirection dir2;\n\n\t\tpublic void rotatePositions(IPositionRotateble set) {\n\t\t\tif (this == WEST_NORTH) {\n\t\t\t\treturn;\n\t\t\t} else if (this == NORTH_EAST) {\n\t\t\t\tset.rotateRight();\n\t\t\t} else if (this == EAST_SOUTH) {\n\t\t\t\tset.rotateLeft();\n\t\t\t\tset.rotateLeft();\n\t\t\t} else if (this == SOUTH_WEST) {\n\t\t\t\tset.rotateLeft();\n\t\t\t}\n\t\t}\n\t}\n\n\t@Getter\n\tprivate CurveOrientation orientation;\n\n\tpublic HSTubeCurve(Item item) {\n\t\tsuper(new PipeMultiBlockTransportLogistics(), item);\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\tif (orientation == null) {\n\t\t\toutput.writeBoolean(false);\n\t\t} else {\n\t\t\toutput.writeBoolean(true);\n\t\t\toutput.writeEnum(orientation);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tif (input.readBoolean()) {\n\t\t\torientation = input.readEnum(CurveOrientation.class);\n\t\t}\n\t}\n\n\t@Override\n\tpublic int getIconIndex(ForgeDirection direction) {\n\t\t// TODO Auto-generated method stub\n\t\treturn 0;\n\t}\n\n\t@Override\n\tpublic int getTextureIndex() {\n\t\t// TODO Auto-generated method stub\n\t\treturn 0;\n\t}\n\n\t@Override\n\tpublic LPPositionSet<DoubleCoordinatesType<SubBlockTypeForShare>> getSubBlocks() {\n\t\tLPPositionSet<DoubleCoordinatesType<SubBlockTypeForShare>> list = new LPPositionSet<>(DoubleCoordinatesType.class);\n\t\tlist.add(new DoubleCoordinatesType<>(-1, 0, 0, SubBlockTypeForShare.CURVE_INNER_A));\n\t\tlist.add(new DoubleCoordinatesType<>(0, 0, 1, SubBlockTypeForShare.CURVE_OUT_A));\n\t\tlist.add(new DoubleCoordinatesType<>(-1, 0, 1, SubBlockTypeForShare.NON_SHARE));\n\t\tlist.add(new DoubleCoordinatesType<>(-2, 0, 1, SubBlockTypeForShare.CURVE_INNER_B));\n\t\tlist.add(new DoubleCoordinatesType<>(-1, 0, 2, SubBlockTypeForShare.CURVE_OUT_B));\n\t\tlist.add(new DoubleCoordinatesType<>(-2, 0, 2, SubBlockTypeForShare.NON_SHARE));\n\t\treturn list;\n\t}\n\n\t@Override\n\tpublic LPPositionSet<DoubleCoordinatesType<SubBlockTypeForShare>> getRotatedSubBlocks() {\n\t\tLPPositionSet<DoubleCoordinatesType<SubBlockTypeForShare>> set = getSubBlocks();\n\t\torientation.rotatePositions(set);\n\t\treturn set;\n\t}\n",
    "code_after_change": "package logisticspipes.pipes.tubes;\n\nimport java.util.List;\n\nimport net.minecraft.entity.player.EntityPlayer;\nimport net.minecraft.item.Item;\nimport net.minecraft.nbt.NBTTagCompound;\nimport net.minecraft.tileentity.TileEntity;\nimport net.minecraft.util.AxisAlignedBB;\nimport net.minecraftforge.common.util.ForgeDirection;\nimport cpw.mods.fml.relauncher.Side;\nimport cpw.mods.fml.relauncher.SideOnly;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Getter;\n\nimport logisticspipes.LPConstants;\nimport logisticspipes.interfaces.ITubeOrientation;\nimport logisticspipes.interfaces.ITubeRenderOrientation;\nimport logisticspipes.pipes.basic.CoreMultiBlockPipe;\nimport logisticspipes.pipes.basic.LogisticsTileGenericSubMultiBlock;\nimport logisticspipes.renderer.newpipe.IHighlightPlacementRenderer;\nimport logisticspipes.renderer.newpipe.ISpecialPipeRenderer;\nimport logisticspipes.renderer.newpipe.tube.CurveTubeRenderer;\nimport logisticspipes.transport.LPTravelingItem;\nimport logisticspipes.transport.PipeMultiBlockTransportLogistics;\nimport logisticspipes.utils.IPositionRotateble;\nimport logisticspipes.utils.LPPositionSet;\nimport network.rs485.logisticspipes.util.LPDataInput;\nimport network.rs485.logisticspipes.util.LPDataOutput;\nimport network.rs485.logisticspipes.world.DoubleCoordinates;\nimport network.rs485.logisticspipes.world.DoubleCoordinatesType;\n\npublic class HSTubeCurve extends CoreMultiBlockPipe {\n\n\t@Getter\n\tprivate CurveOrientation orientation;\n\n\tpublic HSTubeCurve(Item item) {\n\t\tsuper(new PipeMultiBlockTransportLogistics(), item);\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\tif (orientation == null) {\n\t\t\toutput.writeBoolean(false);\n\t\t} else {\n\t\t\toutput.writeBoolean(true);\n\t\t\toutput.writeEnum(orientation);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tif (input.readBoolean()) {\n\t\t\torientation = input.readEnum(CurveOrientation.class);\n\t\t}\n\t}\n\n\t@Override\n\tpublic int getIconIndex(ForgeDirection direction) {\n\t\t// TODO Auto-generated method stub\n\t\treturn 0;\n\t}\n\n\t@Override\n\tpublic int getTextureIndex() {\n\t\t// TODO Auto-generated method stub\n\t\treturn 0;\n\t}\n\n\t@Override\n\tpublic LPPositionSet<DoubleCoordinatesType<SubBlockTypeForShare>> getSubBlocks() {\n\t\tLPPositionSet<DoubleCoordinatesType<SubBlockTypeForShare>> list = new LPPositionSet<>(DoubleCoordinatesType.class);\n\t\tlist.add(new DoubleCoordinatesType<>(-1, 0, 0, SubBlockTypeForShare.CURVE_INNER_A));\n\t\tlist.add(new DoubleCoordinatesType<>(0, 0, 1, SubBlockTypeForShare.CURVE_OUT_A));\n\t\tlist.add(new DoubleCoordinatesType<>(-1, 0, 1, SubBlockTypeForShare.NON_SHARE));\n\t\tlist.add(new DoubleCoordinatesType<>(-2, 0, 1, SubBlockTypeForShare.CURVE_INNER_B));\n\t\tlist.add(new DoubleCoordinatesType<>(-1, 0, 2, SubBlockTypeForShare.CURVE_OUT_B));\n\t\tlist.add(new DoubleCoordinatesType<>(-2, 0, 2, SubBlockTypeForShare.NON_SHARE));\n\t\treturn list;\n\t}\n\n\t@Override\n\tpublic LPPositionSet<DoubleCoordinatesType<SubBlockTypeForShare>> getRotatedSubBlocks() {\n\t\tLPPositionSet<DoubleCoordinatesType<SubBlockTypeForShare>> set = getSubBlocks();\n\t\torientation.rotatePositions(set);\n\t\treturn set;\n\t}\n",
    "patch": "@@ -1,6 +1,5 @@\n package logisticspipes.pipes.tubes;\n \n-import java.io.IOException;\n import java.util.List;\n \n import net.minecraft.entity.player.EntityPlayer;\n@@ -34,65 +33,6 @@\n \n public class HSTubeCurve extends CoreMultiBlockPipe {\n \n-\t@AllArgsConstructor\n-\tpublic enum CurveOrientation implements ITubeOrientation {\n-\t\t//@formatter:off\n-\t\t// Name: Placement from  _ TurnDirection\n-\t\tNORTH_NORTH_EAST(TurnDirection.NORTH_EAST, new DoubleCoordinates(2, 0, 2), ForgeDirection.NORTH, ForgeDirection.EAST),\n-\t\tNORTH_WEST_NORTH(TurnDirection.WEST_NORTH, new DoubleCoordinates(0, 0, 0), ForgeDirection.NORTH, ForgeDirection.WEST),\n-\t\tWEST_WEST_NORTH(TurnDirection.WEST_NORTH, new DoubleCoordinates(2, 0, -2), ForgeDirection.WEST, ForgeDirection.NORTH),\n-\t\tWEST_SOUTH_WEST(TurnDirection.SOUTH_WEST, new DoubleCoordinates(0, 0, 0), ForgeDirection.WEST, ForgeDirection.SOUTH),\n-\t\tSOUTH_SOUTH_WEST(TurnDirection.SOUTH_WEST, new DoubleCoordinates(-2, 0, -2), ForgeDirection.SOUTH, ForgeDirection.WEST),\n-\t\tSOUTH_EAST_SOUTH(TurnDirection.EAST_SOUTH, new DoubleCoordinates(0, 0, 0), ForgeDirection.SOUTH, ForgeDirection.EAST),\n-\t\tEAST_EAST_SOUTH(TurnDirection.EAST_SOUTH, new DoubleCoordinates(-2, 0, 2), ForgeDirection.EAST, ForgeDirection.SOUTH),\n-\t\tEAST_NORTH_EAST(TurnDirection.NORTH_EAST, new DoubleCoordinates(0, 0, 0), ForgeDirection.EAST, ForgeDirection.NORTH);\n-\t\t//@formatter:on\n-\t\t@Getter\n-\t\tTurnDirection renderOrientation;\n-\t\t@Getter\n-\t\tDoubleCoordinates offset;\n-\t\t@Getter\n-\t\tForgeDirection from;\n-\t\t@Getter\n-\t\tForgeDirection looking;\n-\n-\t\t@Override\n-\t\tpublic void rotatePositions(IPositionRotateble set) {\n-\t\t\trenderOrientation.rotatePositions(set);\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void setOnPipe(CoreMultiBlockPipe pipe) {\n-\t\t\t((HSTubeCurve) pipe).orientation = this;\n-\t\t}\n-\t}\n-\n-\t@AllArgsConstructor\n-\tpublic enum TurnDirection implements ITubeRenderOrientation {\n-\t\t//@formatter:off\n-\t\tNORTH_EAST(ForgeDirection.NORTH, ForgeDirection.EAST),\n-\t\tEAST_SOUTH(ForgeDirection.EAST, ForgeDirection.SOUTH),\n-\t\tSOUTH_WEST(ForgeDirection.SOUTH, ForgeDirection.WEST),\n-\t\tWEST_NORTH(ForgeDirection.WEST, ForgeDirection.NORTH);\n-\t\t//@formatter:on\n-\t\t@Getter\n-\t\tForgeDirection dir1;\n-\t\tForgeDirection dir2;\n-\n-\t\tpublic void rotatePositions(IPositionRotateble set) {\n-\t\t\tif (this == WEST_NORTH) {\n-\t\t\t\treturn;\n-\t\t\t} else if (this == NORTH_EAST) {\n-\t\t\t\tset.rotateRight();\n-\t\t\t} else if (this == EAST_SOUTH) {\n-\t\t\t\tset.rotateLeft();\n-\t\t\t\tset.rotateLeft();\n-\t\t\t} else if (this == SOUTH_WEST) {\n-\t\t\t\tset.rotateLeft();\n-\t\t\t}\n-\t\t}\n-\t}\n-\n \t@Getter\n \tprivate CurveOrientation orientation;\n \n@@ -101,7 +41,7 @@ public HSTubeCurve(Item item) {\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\tif (orientation == null) {\n \t\t\toutput.writeBoolean(false);\n \t\t} else {\n@@ -111,7 +51,7 @@ public void writeData(LPDataOutput output) throws IOException {\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tif (input.readBoolean()) {\n \t\t\torientation = input.readEnum(CurveOrientation.class);\n \t\t}\n@@ -399,4 +339,63 @@ public double getBoxRenderScale(float fPos, LPTravelingItem travelItem) {\n \tpublic boolean isHSTube() {\n \t\treturn true;\n \t}\n+\n+\t@AllArgsConstructor\n+\tpublic enum CurveOrientation implements ITubeOrientation {\n+\t\t//@formatter:off\n+\t\t// Name: Placement from  _ TurnDirection\n+\t\tNORTH_NORTH_EAST(TurnDirection.NORTH_EAST, new DoubleCoordinates(2, 0, 2), ForgeDirection.NORTH, ForgeDirection.EAST),\n+\t\tNORTH_WEST_NORTH(TurnDirection.WEST_NORTH, new DoubleCoordinates(0, 0, 0), ForgeDirection.NORTH, ForgeDirection.WEST),\n+\t\tWEST_WEST_NORTH(TurnDirection.WEST_NORTH, new DoubleCoordinates(2, 0, -2), ForgeDirection.WEST, ForgeDirection.NORTH),\n+\t\tWEST_SOUTH_WEST(TurnDirection.SOUTH_WEST, new DoubleCoordinates(0, 0, 0), ForgeDirection.WEST, ForgeDirection.SOUTH),\n+\t\tSOUTH_SOUTH_WEST(TurnDirection.SOUTH_WEST, new DoubleCoordinates(-2, 0, -2), ForgeDirection.SOUTH, ForgeDirection.WEST),\n+\t\tSOUTH_EAST_SOUTH(TurnDirection.EAST_SOUTH, new DoubleCoordinates(0, 0, 0), ForgeDirection.SOUTH, ForgeDirection.EAST),\n+\t\tEAST_EAST_SOUTH(TurnDirection.EAST_SOUTH, new DoubleCoordinates(-2, 0, 2), ForgeDirection.EAST, ForgeDirection.SOUTH),\n+\t\tEAST_NORTH_EAST(TurnDirection.NORTH_EAST, new DoubleCoordinates(0, 0, 0), ForgeDirection.EAST, ForgeDirection.NORTH);\n+\t\t//@formatter:on\n+\t\t@Getter\n+\t\tTurnDirection renderOrientation;\n+\t\t@Getter\n+\t\tDoubleCoordinates offset;\n+\t\t@Getter\n+\t\tForgeDirection from;\n+\t\t@Getter\n+\t\tForgeDirection looking;\n+\n+\t\t@Override\n+\t\tpublic void rotatePositions(IPositionRotateble set) {\n+\t\t\trenderOrientation.rotatePositions(set);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void setOnPipe(CoreMultiBlockPipe pipe) {\n+\t\t\t((HSTubeCurve) pipe).orientation = this;\n+\t\t}\n+\t}\n+\n+\t@AllArgsConstructor\n+\tpublic enum TurnDirection implements ITubeRenderOrientation {\n+\t\t//@formatter:off\n+\t\tNORTH_EAST(ForgeDirection.NORTH, ForgeDirection.EAST),\n+\t\tEAST_SOUTH(ForgeDirection.EAST, ForgeDirection.SOUTH),\n+\t\tSOUTH_WEST(ForgeDirection.SOUTH, ForgeDirection.WEST),\n+\t\tWEST_NORTH(ForgeDirection.WEST, ForgeDirection.NORTH);\n+\t\t//@formatter:on\n+\t\t@Getter\n+\t\tForgeDirection dir1;\n+\t\tForgeDirection dir2;\n+\n+\t\tpublic void rotatePositions(IPositionRotateble set) {\n+\t\t\tif (this == WEST_NORTH) {\n+\t\t\t\treturn;\n+\t\t\t} else if (this == NORTH_EAST) {\n+\t\t\t\tset.rotateRight();\n+\t\t\t} else if (this == EAST_SOUTH) {\n+\t\t\t\tset.rotateLeft();\n+\t\t\t\tset.rotateLeft();\n+\t\t\t} else if (this == SOUTH_WEST) {\n+\t\t\t\tset.rotateLeft();\n+\t\t\t}\n+\t\t}\n+\t}\n }",
    "function_modified_lines": {
      "added": [
        "\tpublic void writeData(LPDataOutput output) {\n",
        "\tpublic void readData(LPDataInput input) {\n"
      ],
      "deleted": [
        "\t@AllArgsConstructor\n",
        "\tpublic enum CurveOrientation implements ITubeOrientation {\n",
        "\t\t//@formatter:off\n",
        "\t\t// Name: Placement from  _ TurnDirection\n",
        "\t\tNORTH_NORTH_EAST(TurnDirection.NORTH_EAST, new DoubleCoordinates(2, 0, 2), ForgeDirection.NORTH, ForgeDirection.EAST),\n",
        "\t\tNORTH_WEST_NORTH(TurnDirection.WEST_NORTH, new DoubleCoordinates(0, 0, 0), ForgeDirection.NORTH, ForgeDirection.WEST),\n",
        "\t\tWEST_WEST_NORTH(TurnDirection.WEST_NORTH, new DoubleCoordinates(2, 0, -2), ForgeDirection.WEST, ForgeDirection.NORTH),\n",
        "\t\tWEST_SOUTH_WEST(TurnDirection.SOUTH_WEST, new DoubleCoordinates(0, 0, 0), ForgeDirection.WEST, ForgeDirection.SOUTH),\n",
        "\t\tSOUTH_SOUTH_WEST(TurnDirection.SOUTH_WEST, new DoubleCoordinates(-2, 0, -2), ForgeDirection.SOUTH, ForgeDirection.WEST),\n",
        "\t\tSOUTH_EAST_SOUTH(TurnDirection.EAST_SOUTH, new DoubleCoordinates(0, 0, 0), ForgeDirection.SOUTH, ForgeDirection.EAST),\n",
        "\t\tEAST_EAST_SOUTH(TurnDirection.EAST_SOUTH, new DoubleCoordinates(-2, 0, 2), ForgeDirection.EAST, ForgeDirection.SOUTH),\n",
        "\t\tEAST_NORTH_EAST(TurnDirection.NORTH_EAST, new DoubleCoordinates(0, 0, 0), ForgeDirection.EAST, ForgeDirection.NORTH);\n",
        "\t\t//@formatter:on\n",
        "\t\t@Getter\n",
        "\t\tTurnDirection renderOrientation;\n",
        "\t\t@Getter\n",
        "\t\tDoubleCoordinates offset;\n",
        "\t\t@Getter\n",
        "\t\tForgeDirection from;\n",
        "\t\t@Getter\n",
        "\t\tForgeDirection looking;\n",
        "\n",
        "\t\t@Override\n",
        "\t\tpublic void rotatePositions(IPositionRotateble set) {\n",
        "\t\t\trenderOrientation.rotatePositions(set);\n",
        "\t\t}\n",
        "\n",
        "\t\t@Override\n",
        "\t\tpublic void setOnPipe(CoreMultiBlockPipe pipe) {\n",
        "\t\t\t((HSTubeCurve) pipe).orientation = this;\n",
        "\t\t}\n",
        "\t}\n",
        "\n",
        "\t@AllArgsConstructor\n",
        "\tpublic enum TurnDirection implements ITubeRenderOrientation {\n",
        "\t\t//@formatter:off\n",
        "\t\tNORTH_EAST(ForgeDirection.NORTH, ForgeDirection.EAST),\n",
        "\t\tEAST_SOUTH(ForgeDirection.EAST, ForgeDirection.SOUTH),\n",
        "\t\tSOUTH_WEST(ForgeDirection.SOUTH, ForgeDirection.WEST),\n",
        "\t\tWEST_NORTH(ForgeDirection.WEST, ForgeDirection.NORTH);\n",
        "\t\t//@formatter:on\n",
        "\t\t@Getter\n",
        "\t\tForgeDirection dir1;\n",
        "\t\tForgeDirection dir2;\n",
        "\n",
        "\t\tpublic void rotatePositions(IPositionRotateble set) {\n",
        "\t\t\tif (this == WEST_NORTH) {\n",
        "\t\t\t\treturn;\n",
        "\t\t\t} else if (this == NORTH_EAST) {\n",
        "\t\t\t\tset.rotateRight();\n",
        "\t\t\t} else if (this == EAST_SOUTH) {\n",
        "\t\t\t\tset.rotateLeft();\n",
        "\t\t\t\tset.rotateLeft();\n",
        "\t\t\t} else if (this == SOUTH_WEST) {\n",
        "\t\t\t\tset.rotateLeft();\n",
        "\t\t\t}\n",
        "\t\t}\n",
        "\t}\n",
        "\n",
        "\tpublic void writeData(LPDataOutput output) throws IOException {\n",
        "\tpublic void readData(LPDataInput input) throws IOException {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12830
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "package logisticspipes.pipes.tubes;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\nimport net.minecraft.entity.player.EntityPlayer;\nimport net.minecraft.item.Item;\nimport net.minecraft.nbt.NBTTagCompound;\nimport net.minecraft.tileentity.TileEntity;\nimport net.minecraft.util.AxisAlignedBB;\nimport net.minecraftforge.common.util.ForgeDirection;\n\nimport lombok.Getter;\n\nimport logisticspipes.interfaces.ITubeOrientation;\nimport logisticspipes.interfaces.ITubeRenderOrientation;\nimport logisticspipes.pipes.basic.CoreMultiBlockPipe;\nimport logisticspipes.pipes.basic.LogisticsTileGenericSubMultiBlock;\nimport logisticspipes.renderer.newpipe.IHighlightPlacementRenderer;\nimport logisticspipes.renderer.newpipe.ISpecialPipeRenderer;\nimport logisticspipes.renderer.newpipe.tube.GainTubeRenderer;\nimport logisticspipes.transport.LPTravelingItem;\nimport logisticspipes.transport.PipeMultiBlockTransportLogistics;\nimport logisticspipes.utils.IPositionRotateble;\nimport logisticspipes.utils.LPPositionSet;\nimport network.rs485.logisticspipes.util.LPDataInput;\nimport network.rs485.logisticspipes.util.LPDataOutput;\nimport network.rs485.logisticspipes.world.DoubleCoordinates;\nimport network.rs485.logisticspipes.world.DoubleCoordinatesType;\n\npublic class HSTubeGain extends CoreMultiBlockPipe {\n\n\tpublic enum TubeGainOrientation implements ITubeOrientation {\n\t\tNORTH(TubeGainRenderOrientation.NORTH, new DoubleCoordinates(0, 0, 0), ForgeDirection.NORTH),\n\t\tSOUTH(TubeGainRenderOrientation.SOUTH, new DoubleCoordinates(0, 0, 0), ForgeDirection.SOUTH),\n\t\tEAST(TubeGainRenderOrientation.EAST, new DoubleCoordinates(0, 0, 0), ForgeDirection.EAST),\n\t\tWEST(TubeGainRenderOrientation.WEST, new DoubleCoordinates(0, 0, 0), ForgeDirection.WEST);\n\n\t\t@Getter\n\t\tTubeGainRenderOrientation renderOrientation;\n\t\t@Getter\n\t\tDoubleCoordinates offset;\n\t\t@Getter\n\t\tForgeDirection dir;\n\n\t\tTubeGainOrientation(TubeGainRenderOrientation render, DoubleCoordinates off, ForgeDirection dir) {\n\t\t\trenderOrientation = render;\n\t\t\toffset = off;\n\t\t\tthis.dir = dir;\n\t\t}\n\n\t\t@Override\n\t\tpublic void rotatePositions(IPositionRotateble set) {\n\t\t\trenderOrientation.rotateOrientation(set);\n\t\t}\n\n\t\t@Override\n\t\tpublic void setOnPipe(CoreMultiBlockPipe pipe) {\n\t\t\t((HSTubeGain) pipe).orientation = this;\n\t\t}\n\t}\n\n\tpublic enum TubeGainRenderOrientation implements ITubeRenderOrientation {\n\t\tNORTH(ForgeDirection.NORTH),\n\t\tSOUTH(ForgeDirection.SOUTH),\n\t\tWEST(ForgeDirection.WEST),\n\t\tEAST(ForgeDirection.EAST);\n\n\t\t@Getter\n\t\tprivate ForgeDirection dir;\n\n\t\tTubeGainRenderOrientation(ForgeDirection dir) {\n\t\t\tthis.dir = dir;\n\t\t}\n\n\t\tpublic void rotateOrientation(IPositionRotateble set) {\n\t\t\tif (this == EAST) {\n\t\t\t\tset.rotateRight();\n\t\t\t} else if (this == WEST) {\n\t\t\t\tset.rotateLeft();\n\t\t\t} else if (this == SOUTH) {\n\t\t\t\tset.rotateLeft();\n\t\t\t\tset.rotateLeft();\n\t\t\t}\n\t\t}\n\t}\n\n\t@Getter\n\tprivate TubeGainOrientation orientation;\n\n\tprivate List<AxisAlignedBB> boxes = null;\n\n\tpublic HSTubeGain(Item item) {\n\t\tsuper(new PipeMultiBlockTransportLogistics(), item);\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\tif (orientation == null) {\n\t\t\toutput.writeBoolean(false);\n\t\t} else {\n\t\t\toutput.writeBoolean(true);\n\t\t\toutput.writeEnum(orientation);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tif (input.readBoolean()) {\n\t\t\torientation = input.readEnum(TubeGainOrientation.class);\n\t\t}\n\t}\n\n\t@Override\n\tpublic LPPositionSet<DoubleCoordinatesType<SubBlockTypeForShare>> getSubBlocks() {\n\t\tLPPositionSet<DoubleCoordinatesType<SubBlockTypeForShare>> list = new LPPositionSet<>(DoubleCoordinatesType.class);\n\t\tlist.add(new DoubleCoordinatesType<>(0, 0, -1, SubBlockTypeForShare.GAIN_B));\n\t\tlist.add(new DoubleCoordinatesType<>(0, 0, -2, SubBlockTypeForShare.GAIN_A));\n\t\tlist.add(new DoubleCoordinatesType<>(0, 1, -1, SubBlockTypeForShare.GAIN_A));\n\t\tlist.add(new DoubleCoordinatesType<>(0, 1, -2, SubBlockTypeForShare.GAIN_B));\n\t\tlist.add(new DoubleCoordinatesType<>(0, 1, -3, SubBlockTypeForShare.NON_SHARE));\n\t\treturn list;\n\t}\n\n\t@Override\n\tpublic LPPositionSet<DoubleCoordinatesType<SubBlockTypeForShare>> getRotatedSubBlocks() {\n\t\tLPPositionSet<DoubleCoordinatesType<SubBlockTypeForShare>> set = getSubBlocks();\n\t\torientation.rotatePositions(set);\n\t\treturn set;\n\t}\n\n\t@Override\n\tpublic void writeToNBT(NBTTagCompound data) {\n\t\tsuper.writeToNBT(data);\n\t\tdata.setString(\"orientation\", orientation.name());\n\t}\n\n\t@Override\n\tpublic void readFromNBT(NBTTagCompound data) {\n\t\tsuper.readFromNBT(data);\n\t\torientation = TubeGainOrientation.valueOf(data.getString(\"orientation\"));\n\t}\n\n\t@Override",
    "code_after_change": "package logisticspipes.pipes.tubes;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\nimport net.minecraft.entity.player.EntityPlayer;\nimport net.minecraft.item.Item;\nimport net.minecraft.nbt.NBTTagCompound;\nimport net.minecraft.tileentity.TileEntity;\nimport net.minecraft.util.AxisAlignedBB;\nimport net.minecraftforge.common.util.ForgeDirection;\n\nimport lombok.Getter;\n\nimport logisticspipes.interfaces.ITubeOrientation;\nimport logisticspipes.interfaces.ITubeRenderOrientation;\nimport logisticspipes.pipes.basic.CoreMultiBlockPipe;\nimport logisticspipes.pipes.basic.LogisticsTileGenericSubMultiBlock;\nimport logisticspipes.renderer.newpipe.IHighlightPlacementRenderer;\nimport logisticspipes.renderer.newpipe.ISpecialPipeRenderer;\nimport logisticspipes.renderer.newpipe.tube.GainTubeRenderer;\nimport logisticspipes.transport.LPTravelingItem;\nimport logisticspipes.transport.PipeMultiBlockTransportLogistics;\nimport logisticspipes.utils.IPositionRotateble;\nimport logisticspipes.utils.LPPositionSet;\nimport network.rs485.logisticspipes.util.LPDataInput;\nimport network.rs485.logisticspipes.util.LPDataOutput;\nimport network.rs485.logisticspipes.world.DoubleCoordinates;\nimport network.rs485.logisticspipes.world.DoubleCoordinatesType;\n\npublic class HSTubeGain extends CoreMultiBlockPipe {\n\n\t@Getter\n\tprivate TubeGainOrientation orientation;\n\tprivate List<AxisAlignedBB> boxes = null;\n\n\tpublic HSTubeGain(Item item) {\n\t\tsuper(new PipeMultiBlockTransportLogistics(), item);\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\tif (orientation == null) {\n\t\t\toutput.writeBoolean(false);\n\t\t} else {\n\t\t\toutput.writeBoolean(true);\n\t\t\toutput.writeEnum(orientation);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tif (input.readBoolean()) {\n\t\t\torientation = input.readEnum(TubeGainOrientation.class);\n\t\t}\n\t}\n\n\t@Override\n\tpublic LPPositionSet<DoubleCoordinatesType<SubBlockTypeForShare>> getSubBlocks() {\n\t\tLPPositionSet<DoubleCoordinatesType<SubBlockTypeForShare>> list = new LPPositionSet<>(DoubleCoordinatesType.class);\n\t\tlist.add(new DoubleCoordinatesType<>(0, 0, -1, SubBlockTypeForShare.GAIN_B));\n\t\tlist.add(new DoubleCoordinatesType<>(0, 0, -2, SubBlockTypeForShare.GAIN_A));\n\t\tlist.add(new DoubleCoordinatesType<>(0, 1, -1, SubBlockTypeForShare.GAIN_A));\n\t\tlist.add(new DoubleCoordinatesType<>(0, 1, -2, SubBlockTypeForShare.GAIN_B));\n\t\tlist.add(new DoubleCoordinatesType<>(0, 1, -3, SubBlockTypeForShare.NON_SHARE));\n\t\treturn list;\n\t}\n\n\t@Override\n\tpublic LPPositionSet<DoubleCoordinatesType<SubBlockTypeForShare>> getRotatedSubBlocks() {\n\t\tLPPositionSet<DoubleCoordinatesType<SubBlockTypeForShare>> set = getSubBlocks();\n\t\torientation.rotatePositions(set);\n\t\treturn set;\n\t}\n\n\t@Override\n\tpublic void writeToNBT(NBTTagCompound data) {\n\t\tsuper.writeToNBT(data);\n\t\tdata.setString(\"orientation\", orientation.name());\n\t}\n\n\t@Override\n\tpublic void readFromNBT(NBTTagCompound data) {\n\t\tsuper.readFromNBT(data);\n\t\torientation = TubeGainOrientation.valueOf(data.getString(\"orientation\"));\n\t}\n\n\t@Override",
    "patch": "@@ -1,6 +1,5 @@\n package logisticspipes.pipes.tubes;\n \n-import java.io.IOException;\n import java.util.ArrayList;\n import java.util.List;\n import java.util.stream.Collectors;\n@@ -32,72 +31,16 @@\n \n public class HSTubeGain extends CoreMultiBlockPipe {\n \n-\tpublic enum TubeGainOrientation implements ITubeOrientation {\n-\t\tNORTH(TubeGainRenderOrientation.NORTH, new DoubleCoordinates(0, 0, 0), ForgeDirection.NORTH),\n-\t\tSOUTH(TubeGainRenderOrientation.SOUTH, new DoubleCoordinates(0, 0, 0), ForgeDirection.SOUTH),\n-\t\tEAST(TubeGainRenderOrientation.EAST, new DoubleCoordinates(0, 0, 0), ForgeDirection.EAST),\n-\t\tWEST(TubeGainRenderOrientation.WEST, new DoubleCoordinates(0, 0, 0), ForgeDirection.WEST);\n-\n-\t\t@Getter\n-\t\tTubeGainRenderOrientation renderOrientation;\n-\t\t@Getter\n-\t\tDoubleCoordinates offset;\n-\t\t@Getter\n-\t\tForgeDirection dir;\n-\n-\t\tTubeGainOrientation(TubeGainRenderOrientation render, DoubleCoordinates off, ForgeDirection dir) {\n-\t\t\trenderOrientation = render;\n-\t\t\toffset = off;\n-\t\t\tthis.dir = dir;\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void rotatePositions(IPositionRotateble set) {\n-\t\t\trenderOrientation.rotateOrientation(set);\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void setOnPipe(CoreMultiBlockPipe pipe) {\n-\t\t\t((HSTubeGain) pipe).orientation = this;\n-\t\t}\n-\t}\n-\n-\tpublic enum TubeGainRenderOrientation implements ITubeRenderOrientation {\n-\t\tNORTH(ForgeDirection.NORTH),\n-\t\tSOUTH(ForgeDirection.SOUTH),\n-\t\tWEST(ForgeDirection.WEST),\n-\t\tEAST(ForgeDirection.EAST);\n-\n-\t\t@Getter\n-\t\tprivate ForgeDirection dir;\n-\n-\t\tTubeGainRenderOrientation(ForgeDirection dir) {\n-\t\t\tthis.dir = dir;\n-\t\t}\n-\n-\t\tpublic void rotateOrientation(IPositionRotateble set) {\n-\t\t\tif (this == EAST) {\n-\t\t\t\tset.rotateRight();\n-\t\t\t} else if (this == WEST) {\n-\t\t\t\tset.rotateLeft();\n-\t\t\t} else if (this == SOUTH) {\n-\t\t\t\tset.rotateLeft();\n-\t\t\t\tset.rotateLeft();\n-\t\t\t}\n-\t\t}\n-\t}\n-\n \t@Getter\n \tprivate TubeGainOrientation orientation;\n-\n \tprivate List<AxisAlignedBB> boxes = null;\n \n \tpublic HSTubeGain(Item item) {\n \t\tsuper(new PipeMultiBlockTransportLogistics(), item);\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\tif (orientation == null) {\n \t\t\toutput.writeBoolean(false);\n \t\t} else {\n@@ -107,7 +50,7 @@ public void writeData(LPDataOutput output) throws IOException {\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tif (input.readBoolean()) {\n \t\t\torientation = input.readEnum(TubeGainOrientation.class);\n \t\t}\n@@ -414,4 +357,59 @@ public double getBoxRenderScale(float fPos, LPTravelingItem travelItem) {\n \tpublic boolean isHSTube() {\n \t\treturn true;\n \t}\n+\n+\tpublic enum TubeGainOrientation implements ITubeOrientation {\n+\t\tNORTH(TubeGainRenderOrientation.NORTH, new DoubleCoordinates(0, 0, 0), ForgeDirection.NORTH),\n+\t\tSOUTH(TubeGainRenderOrientation.SOUTH, new DoubleCoordinates(0, 0, 0), ForgeDirection.SOUTH),\n+\t\tEAST(TubeGainRenderOrientation.EAST, new DoubleCoordinates(0, 0, 0), ForgeDirection.EAST),\n+\t\tWEST(TubeGainRenderOrientation.WEST, new DoubleCoordinates(0, 0, 0), ForgeDirection.WEST);\n+\n+\t\t@Getter\n+\t\tTubeGainRenderOrientation renderOrientation;\n+\t\t@Getter\n+\t\tDoubleCoordinates offset;\n+\t\t@Getter\n+\t\tForgeDirection dir;\n+\n+\t\tTubeGainOrientation(TubeGainRenderOrientation render, DoubleCoordinates off, ForgeDirection dir) {\n+\t\t\trenderOrientation = render;\n+\t\t\toffset = off;\n+\t\t\tthis.dir = dir;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void rotatePositions(IPositionRotateble set) {\n+\t\t\trenderOrientation.rotateOrientation(set);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void setOnPipe(CoreMultiBlockPipe pipe) {\n+\t\t\t((HSTubeGain) pipe).orientation = this;\n+\t\t}\n+\t}\n+\n+\tpublic enum TubeGainRenderOrientation implements ITubeRenderOrientation {\n+\t\tNORTH(ForgeDirection.NORTH),\n+\t\tSOUTH(ForgeDirection.SOUTH),\n+\t\tWEST(ForgeDirection.WEST),\n+\t\tEAST(ForgeDirection.EAST);\n+\n+\t\t@Getter\n+\t\tprivate ForgeDirection dir;\n+\n+\t\tTubeGainRenderOrientation(ForgeDirection dir) {\n+\t\t\tthis.dir = dir;\n+\t\t}\n+\n+\t\tpublic void rotateOrientation(IPositionRotateble set) {\n+\t\t\tif (this == EAST) {\n+\t\t\t\tset.rotateRight();\n+\t\t\t} else if (this == WEST) {\n+\t\t\t\tset.rotateLeft();\n+\t\t\t} else if (this == SOUTH) {\n+\t\t\t\tset.rotateLeft();\n+\t\t\t\tset.rotateLeft();\n+\t\t\t}\n+\t\t}\n+\t}\n }",
    "function_modified_lines": {
      "added": [
        "\tpublic void writeData(LPDataOutput output) {\n",
        "\tpublic void readData(LPDataInput input) {\n"
      ],
      "deleted": [
        "\tpublic enum TubeGainOrientation implements ITubeOrientation {\n",
        "\t\tNORTH(TubeGainRenderOrientation.NORTH, new DoubleCoordinates(0, 0, 0), ForgeDirection.NORTH),\n",
        "\t\tSOUTH(TubeGainRenderOrientation.SOUTH, new DoubleCoordinates(0, 0, 0), ForgeDirection.SOUTH),\n",
        "\t\tEAST(TubeGainRenderOrientation.EAST, new DoubleCoordinates(0, 0, 0), ForgeDirection.EAST),\n",
        "\t\tWEST(TubeGainRenderOrientation.WEST, new DoubleCoordinates(0, 0, 0), ForgeDirection.WEST);\n",
        "\n",
        "\t\t@Getter\n",
        "\t\tTubeGainRenderOrientation renderOrientation;\n",
        "\t\t@Getter\n",
        "\t\tDoubleCoordinates offset;\n",
        "\t\t@Getter\n",
        "\t\tForgeDirection dir;\n",
        "\n",
        "\t\tTubeGainOrientation(TubeGainRenderOrientation render, DoubleCoordinates off, ForgeDirection dir) {\n",
        "\t\t\trenderOrientation = render;\n",
        "\t\t\toffset = off;\n",
        "\t\t\tthis.dir = dir;\n",
        "\t\t}\n",
        "\n",
        "\t\t@Override\n",
        "\t\tpublic void rotatePositions(IPositionRotateble set) {\n",
        "\t\t\trenderOrientation.rotateOrientation(set);\n",
        "\t\t}\n",
        "\n",
        "\t\t@Override\n",
        "\t\tpublic void setOnPipe(CoreMultiBlockPipe pipe) {\n",
        "\t\t\t((HSTubeGain) pipe).orientation = this;\n",
        "\t\t}\n",
        "\t}\n",
        "\n",
        "\tpublic enum TubeGainRenderOrientation implements ITubeRenderOrientation {\n",
        "\t\tNORTH(ForgeDirection.NORTH),\n",
        "\t\tSOUTH(ForgeDirection.SOUTH),\n",
        "\t\tWEST(ForgeDirection.WEST),\n",
        "\t\tEAST(ForgeDirection.EAST);\n",
        "\n",
        "\t\t@Getter\n",
        "\t\tprivate ForgeDirection dir;\n",
        "\n",
        "\t\tTubeGainRenderOrientation(ForgeDirection dir) {\n",
        "\t\t\tthis.dir = dir;\n",
        "\t\t}\n",
        "\n",
        "\t\tpublic void rotateOrientation(IPositionRotateble set) {\n",
        "\t\t\tif (this == EAST) {\n",
        "\t\t\t\tset.rotateRight();\n",
        "\t\t\t} else if (this == WEST) {\n",
        "\t\t\t\tset.rotateLeft();\n",
        "\t\t\t} else if (this == SOUTH) {\n",
        "\t\t\t\tset.rotateLeft();\n",
        "\t\t\t\tset.rotateLeft();\n",
        "\t\t\t}\n",
        "\t\t}\n",
        "\t}\n",
        "\n",
        "\n",
        "\tpublic void writeData(LPDataOutput output) throws IOException {\n",
        "\tpublic void readData(LPDataInput input) throws IOException {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12831
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "{\n\n\tpublic enum TubeLineOrientation implements ITubeOrientation {\n\t\tNORTH(TubeLineRenderOrientation.NORTH_SOUTH, new DoubleCoordinates(0, 0, 0), ForgeDirection.NORTH),\n\t\tSOUTH(TubeLineRenderOrientation.NORTH_SOUTH, new DoubleCoordinates(0, 0, 0), ForgeDirection.SOUTH),\n\t\tEAST(TubeLineRenderOrientation.EAST_WEST, new DoubleCoordinates(0, 0, 0), ForgeDirection.EAST),\n\t\tWEST(TubeLineRenderOrientation.EAST_WEST, new DoubleCoordinates(0, 0, 0), ForgeDirection.WEST);\n\n\t\t@Getter\n\t\tTubeLineRenderOrientation renderOrientation;\n\t\t@Getter\n\t\tDoubleCoordinates offset;\n\t\t@Getter\n\t\tForgeDirection dir;\n\n\t\tTubeLineOrientation(TubeLineRenderOrientation render, DoubleCoordinates off, ForgeDirection dir) {\n\t\t\trenderOrientation = render;\n\t\t\toffset = off;\n\t\t\tthis.dir = dir;\n\t\t}\n\n\t\t@Override\n\t\tpublic void rotatePositions(IPositionRotateble set) {\n\t\t\trenderOrientation.rotateOrientation(set);\n\t\t}\n\n\t\t@Override\n\t\tpublic void setOnPipe(CoreMultiBlockPipe pipe) {\n\t\t\t((HSTubeLine) pipe).orientation = this;\n\t\t}\n\t}\n\n\tpublic enum TubeLineRenderOrientation implements ITubeRenderOrientation {\n\t\tNORTH_SOUTH(ForgeDirection.NORTH),\n\t\tEAST_WEST(ForgeDirection.EAST);\n\n\t\t@Getter\n\t\tprivate ForgeDirection dir;\n\n\t\tTubeLineRenderOrientation(ForgeDirection dir) {\n\t\t\tthis.dir = dir;\n\t\t}\n\n\t\tpublic void rotateOrientation(IPositionRotateble set) {\n\t\t\tif (this == EAST_WEST) {\n\t\t\t\tset.rotateLeft();\n\t\t\t}\n\t\t}\n\t}\n\n\t@Getter\n\tprivate TubeLineOrientation orientation;\n\n\tpublic HSTubeLine(Item item) {\n\t\tsuper(new PipeMultiBlockTransportLogistics(), item);\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\tif (orientation == null) {\n\t\t\toutput.writeBoolean(false);\n\t\t} else {\n\t\t\toutput.writeBoolean(true);\n\t\t\toutput.writeEnum(orientation);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tif (input.readBoolean()) {\n\t\t\torientation = input.readEnum(TubeLineOrientation.class);\n\t\t}\n\t}\n\n\t@Override\n\tpublic LPPositionSet<DoubleCoordinatesType<SubBlockTypeForShare>> getSubBlocks() {\n\t\treturn new LPPositionSet<>(DoubleCoordinatesType.class);\n\t}\n\n\t@Override\n\tpublic LPPositionSet<DoubleCoordinatesType<SubBlockTypeForShare>> getRotatedSubBlocks() {\n\t\tLPPositionSet<DoubleCoordinatesType<SubBlockTypeForShare>> set = getSubBlocks();\n\t\torientation.rotatePositions(set);\n\t\treturn set;\n\t}\n\n\t@Override\n\tpublic void writeToNBT(NBTTagCompound data) {\n\t\tsuper.writeToNBT(data);\n\t\tdata.setString(\"orientation\", orientation.name());\n\t}\n\n\t@Override\n\tpublic void readFromNBT(NBTTagCompound data) {\n\t\tsuper.readFromNBT(data);\n\t\torientation = TubeLineOrientation.valueOf(data.getString(\"orientation\"));\n\t}\n\n\t@Override\n\tpublic void addCollisionBoxesToList(List arraylist, AxisAlignedBB axisalignedbb) {\n\t\tDoubleCoordinates pos = getLPPosition();\n\t\tLPPositionSet<DoubleCoordinates> set = new LPPositionSet<>(DoubleCoordinates.class);\n\t\tset.addFrom(LineTubeRenderer.tubeLine.get(orientation.getRenderOrientation()).bounds().toAABB());\n\t\tset.stream().forEach(o -> o.add(pos));\n\t\tAxisAlignedBB box = set.toABB();\n\t\tif (box != null && (axisalignedbb == null || axisalignedbb.intersectsWith(box))) {\n\t\t\tarraylist.add(box);\n\t\t}\n\t}\n\n\t@Override\n\tpublic AxisAlignedBB getCompleteBox() {\n\t\treturn LineTubeRenderer.tubeLine.get(orientation.getRenderOrientation()).bounds().toAABB();\n\t}\n\n\t@Override\n\tpublic ITubeOrientation getTubeOrientation(EntityPlayer player, int xPos, int zPos) {\n\t\tdouble x = xPos + 0.5 - player.posX;\n\t\tdouble z = zPos + 0.5 - player.posZ;\n\t\tdouble w = Math.atan2(x, z);\n\t\tdouble halfPI = Math.PI / 2;\n\t\tdouble halfhalfPI = halfPI / 2;\n\t\tw -= halfhalfPI;\n\t\tif (w < 0) {\n\t\t\tw += 2 * Math.PI;\n\t\t}\n\t\tForgeDirection dir = ForgeDirection.UNKNOWN;\n\t\tif (0 < w && w <= halfPI) {\n\t\t\tdir = ForgeDirection.WEST;\n\t\t} else if (halfPI < w && w <= 2 * halfPI) {\n\t\t\tdir = ForgeDirection.SOUTH;\n\t\t} else if (2 * halfPI < w && w <= 3 * halfPI) {\n\t\t\tdir = ForgeDirection.EAST;\n\t\t} else if (3 * halfPI < w && w <= 4 * halfPI) {\n\t\t\tdir = ForgeDirection.NORTH;\n\t\t}\n\t\tfor (TubeLineOrientation ori : TubeLineOrientation.values()) {\n\t\t\tif (ori.dir.equals(dir)) {\n\t\t\t\treturn ori;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic float getPipeLength() {\n\t\treturn 1;\n\t}\n\n\t@Override\n\tpublic ForgeDirection getExitForInput(ForgeDirection commingFrom) {\n\t\treturn commingFrom.getOpposite();\n\t}\n\n\t@Override\n\tpublic TileEntity getConnectedEndTile(ForgeDirection output) {\n\t\tif (output == this.orientation.dir || output.getOpposite() == this.orientation.dir) {\n\t\t\treturn container.getTile(output);\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic int getIconIndex(ForgeDirection direction) {\n\t\treturn 0;\n\t}\n\n\t@Override\n\tpublic int getTextureIndex() {\n\t\treturn 0;\n\t}\n\n\t@Override\n\tpublic boolean actAsNormalPipe() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic ISpecialPipeRenderer getSpecialRenderer() {\n\t\treturn LineTubeRenderer.instance;\n\t}\n\n\t@Override\n\tpublic IHighlightPlacementRenderer getHighlightRenderer() {\n\t\treturn LineTubeRenderer.instance;\n\t}\n\n\t@Override\n\tpublic boolean isHSTube() {\n\t\treturn true;\n\t}\n}",
    "code_after_change": "public class HSTubeLine extends CoreMultiBlockPipe {\n\n\t@Getter\n\tprivate TubeLineOrientation orientation;\n\n\tpublic HSTubeLine(Item item) {\n\t\tsuper(new PipeMultiBlockTransportLogistics(), item);\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\tif (orientation == null) {\n\t\t\toutput.writeBoolean(false);\n\t\t} else {\n\t\t\toutput.writeBoolean(true);\n\t\t\toutput.writeEnum(orientation);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tif (input.readBoolean()) {\n\t\t\torientation = input.readEnum(TubeLineOrientation.class);\n\t\t}\n\t}\n\n\t@Override\n\tpublic LPPositionSet<DoubleCoordinatesType<SubBlockTypeForShare>> getSubBlocks() {\n\t\treturn new LPPositionSet<>(DoubleCoordinatesType.class);\n\t}\n\n\t@Override\n\tpublic LPPositionSet<DoubleCoordinatesType<SubBlockTypeForShare>> getRotatedSubBlocks() {\n\t\tLPPositionSet<DoubleCoordinatesType<SubBlockTypeForShare>> set = getSubBlocks();\n\t\torientation.rotatePositions(set);\n\t\treturn set;\n\t}\n\n\t@Override\n\tpublic void writeToNBT(NBTTagCompound data) {\n\t\tsuper.writeToNBT(data);\n\t\tdata.setString(\"orientation\", orientation.name());\n\t}\n\n\t@Override\n\tpublic void readFromNBT(NBTTagCompound data) {\n\t\tsuper.readFromNBT(data);\n\t\torientation = TubeLineOrientation.valueOf(data.getString(\"orientation\"));\n\t}\n\n\t@Override\n\tpublic void addCollisionBoxesToList(List arraylist, AxisAlignedBB axisalignedbb) {\n\t\tDoubleCoordinates pos = getLPPosition();\n\t\tLPPositionSet<DoubleCoordinates> set = new LPPositionSet<>(DoubleCoordinates.class);\n\t\tset.addFrom(LineTubeRenderer.tubeLine.get(orientation.getRenderOrientation()).bounds().toAABB());\n\t\tset.stream().forEach(o -> o.add(pos));\n\t\tAxisAlignedBB box = set.toABB();\n\t\tif (box != null && (axisalignedbb == null || axisalignedbb.intersectsWith(box))) {\n\t\t\tarraylist.add(box);\n\t\t}\n\t}\n\n\t@Override\n\tpublic AxisAlignedBB getCompleteBox() {\n\t\treturn LineTubeRenderer.tubeLine.get(orientation.getRenderOrientation()).bounds().toAABB();\n\t}\n\n\t@Override\n\tpublic ITubeOrientation getTubeOrientation(EntityPlayer player, int xPos, int zPos) {\n\t\tdouble x = xPos + 0.5 - player.posX;\n\t\tdouble z = zPos + 0.5 - player.posZ;\n\t\tdouble w = Math.atan2(x, z);\n\t\tdouble halfPI = Math.PI / 2;\n\t\tdouble halfhalfPI = halfPI / 2;\n\t\tw -= halfhalfPI;\n\t\tif (w < 0) {\n\t\t\tw += 2 * Math.PI;\n\t\t}\n\t\tForgeDirection dir = ForgeDirection.UNKNOWN;\n\t\tif (0 < w && w <= halfPI) {\n\t\t\tdir = ForgeDirection.WEST;\n\t\t} else if (halfPI < w && w <= 2 * halfPI) {\n\t\t\tdir = ForgeDirection.SOUTH;\n\t\t} else if (2 * halfPI < w && w <= 3 * halfPI) {\n\t\t\tdir = ForgeDirection.EAST;\n\t\t} else if (3 * halfPI < w && w <= 4 * halfPI) {\n\t\t\tdir = ForgeDirection.NORTH;\n\t\t}\n\t\tfor (TubeLineOrientation ori : TubeLineOrientation.values()) {\n\t\t\tif (ori.dir.equals(dir)) {\n\t\t\t\treturn ori;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic float getPipeLength() {\n\t\treturn 1;\n\t}\n\n\t@Override\n\tpublic ForgeDirection getExitForInput(ForgeDirection commingFrom) {\n\t\treturn commingFrom.getOpposite();\n\t}\n\n\t@Override\n\tpublic TileEntity getConnectedEndTile(ForgeDirection output) {\n\t\tif (output == this.orientation.dir || output.getOpposite() == this.orientation.dir) {\n\t\t\treturn container.getTile(output);\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic int getIconIndex(ForgeDirection direction) {\n\t\treturn 0;\n\t}\n\n\t@Override\n\tpublic int getTextureIndex() {\n\t\treturn 0;\n\t}\n\n\t@Override\n\tpublic boolean actAsNormalPipe() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic ISpecialPipeRenderer getSpecialRenderer() {\n\t\treturn LineTubeRenderer.instance;\n\t}\n\n\t@Override\n\tpublic IHighlightPlacementRenderer getHighlightRenderer() {\n\t\treturn LineTubeRenderer.instance;\n\t}\n\n\t@Override\n\tpublic boolean isHSTube() {\n\t\treturn true;\n\t}\n\n\tpublic enum TubeLineOrientation implements ITubeOrientation {\n\t\tNORTH(TubeLineRenderOrientation.NORTH_SOUTH, new DoubleCoordinates(0, 0, 0), ForgeDirection.NORTH),\n\t\tSOUTH(TubeLineRenderOrientation.NORTH_SOUTH, new DoubleCoordinates(0, 0, 0), ForgeDirection.SOUTH),\n\t\tEAST(TubeLineRenderOrientation.EAST_WEST, new DoubleCoordinates(0, 0, 0), ForgeDirection.EAST),\n\t\tWEST(TubeLineRenderOrientation.EAST_WEST, new DoubleCoordinates(0, 0, 0), ForgeDirection.WEST);\n\n\t\t@Getter\n\t\tTubeLineRenderOrientation renderOrientation;\n\t\t@Getter\n\t\tDoubleCoordinates offset;\n\t\t@Getter\n\t\tForgeDirection dir;\n\n\t\tTubeLineOrientation(TubeLineRenderOrientation render, DoubleCoordinates off, ForgeDirection dir) {\n\t\t\trenderOrientation = render;\n\t\t\toffset = off;\n\t\t\tthis.dir = dir;\n\t\t}\n\n\t\t@Override\n\t\tpublic void rotatePositions(IPositionRotateble set) {\n\t\t\trenderOrientation.rotateOrientation(set);\n\t\t}\n\n\t\t@Override\n\t\tpublic void setOnPipe(CoreMultiBlockPipe pipe) {\n\t\t\t((HSTubeLine) pipe).orientation = this;\n\t\t}\n\t}\n\n\tpublic enum TubeLineRenderOrientation implements ITubeRenderOrientation {\n\t\tNORTH_SOUTH(ForgeDirection.NORTH),\n\t\tEAST_WEST(ForgeDirection.EAST);\n\n\t\t@Getter\n\t\tprivate ForgeDirection dir;\n\n\t\tTubeLineRenderOrientation(ForgeDirection dir) {\n\t\t\tthis.dir = dir;\n\t\t}\n\n\t\tpublic void rotateOrientation(IPositionRotateble set) {\n\t\t\tif (this == EAST_WEST) {\n\t\t\t\tset.rotateLeft();\n\t\t\t}\n\t\t}\n\t}\n}",
    "patch": "@@ -1,6 +1,5 @@\n package logisticspipes.pipes.tubes;\n \n-import java.io.IOException;\n import java.util.List;\n \n import net.minecraft.entity.player.EntityPlayer;\n@@ -28,54 +27,6 @@\n \n public class HSTubeLine extends CoreMultiBlockPipe {\n \n-\tpublic enum TubeLineOrientation implements ITubeOrientation {\n-\t\tNORTH(TubeLineRenderOrientation.NORTH_SOUTH, new DoubleCoordinates(0, 0, 0), ForgeDirection.NORTH),\n-\t\tSOUTH(TubeLineRenderOrientation.NORTH_SOUTH, new DoubleCoordinates(0, 0, 0), ForgeDirection.SOUTH),\n-\t\tEAST(TubeLineRenderOrientation.EAST_WEST, new DoubleCoordinates(0, 0, 0), ForgeDirection.EAST),\n-\t\tWEST(TubeLineRenderOrientation.EAST_WEST, new DoubleCoordinates(0, 0, 0), ForgeDirection.WEST);\n-\n-\t\t@Getter\n-\t\tTubeLineRenderOrientation renderOrientation;\n-\t\t@Getter\n-\t\tDoubleCoordinates offset;\n-\t\t@Getter\n-\t\tForgeDirection dir;\n-\n-\t\tTubeLineOrientation(TubeLineRenderOrientation render, DoubleCoordinates off, ForgeDirection dir) {\n-\t\t\trenderOrientation = render;\n-\t\t\toffset = off;\n-\t\t\tthis.dir = dir;\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void rotatePositions(IPositionRotateble set) {\n-\t\t\trenderOrientation.rotateOrientation(set);\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void setOnPipe(CoreMultiBlockPipe pipe) {\n-\t\t\t((HSTubeLine) pipe).orientation = this;\n-\t\t}\n-\t}\n-\n-\tpublic enum TubeLineRenderOrientation implements ITubeRenderOrientation {\n-\t\tNORTH_SOUTH(ForgeDirection.NORTH),\n-\t\tEAST_WEST(ForgeDirection.EAST);\n-\n-\t\t@Getter\n-\t\tprivate ForgeDirection dir;\n-\n-\t\tTubeLineRenderOrientation(ForgeDirection dir) {\n-\t\t\tthis.dir = dir;\n-\t\t}\n-\n-\t\tpublic void rotateOrientation(IPositionRotateble set) {\n-\t\t\tif (this == EAST_WEST) {\n-\t\t\t\tset.rotateLeft();\n-\t\t\t}\n-\t\t}\n-\t}\n-\n \t@Getter\n \tprivate TubeLineOrientation orientation;\n \n@@ -84,7 +35,7 @@ public HSTubeLine(Item item) {\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\tif (orientation == null) {\n \t\t\toutput.writeBoolean(false);\n \t\t} else {\n@@ -94,7 +45,7 @@ public void writeData(LPDataOutput output) throws IOException {\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tif (input.readBoolean()) {\n \t\t\torientation = input.readEnum(TubeLineOrientation.class);\n \t\t}\n@@ -217,4 +168,52 @@ public IHighlightPlacementRenderer getHighlightRenderer() {\n \tpublic boolean isHSTube() {\n \t\treturn true;\n \t}\n+\n+\tpublic enum TubeLineOrientation implements ITubeOrientation {\n+\t\tNORTH(TubeLineRenderOrientation.NORTH_SOUTH, new DoubleCoordinates(0, 0, 0), ForgeDirection.NORTH),\n+\t\tSOUTH(TubeLineRenderOrientation.NORTH_SOUTH, new DoubleCoordinates(0, 0, 0), ForgeDirection.SOUTH),\n+\t\tEAST(TubeLineRenderOrientation.EAST_WEST, new DoubleCoordinates(0, 0, 0), ForgeDirection.EAST),\n+\t\tWEST(TubeLineRenderOrientation.EAST_WEST, new DoubleCoordinates(0, 0, 0), ForgeDirection.WEST);\n+\n+\t\t@Getter\n+\t\tTubeLineRenderOrientation renderOrientation;\n+\t\t@Getter\n+\t\tDoubleCoordinates offset;\n+\t\t@Getter\n+\t\tForgeDirection dir;\n+\n+\t\tTubeLineOrientation(TubeLineRenderOrientation render, DoubleCoordinates off, ForgeDirection dir) {\n+\t\t\trenderOrientation = render;\n+\t\t\toffset = off;\n+\t\t\tthis.dir = dir;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void rotatePositions(IPositionRotateble set) {\n+\t\t\trenderOrientation.rotateOrientation(set);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void setOnPipe(CoreMultiBlockPipe pipe) {\n+\t\t\t((HSTubeLine) pipe).orientation = this;\n+\t\t}\n+\t}\n+\n+\tpublic enum TubeLineRenderOrientation implements ITubeRenderOrientation {\n+\t\tNORTH_SOUTH(ForgeDirection.NORTH),\n+\t\tEAST_WEST(ForgeDirection.EAST);\n+\n+\t\t@Getter\n+\t\tprivate ForgeDirection dir;\n+\n+\t\tTubeLineRenderOrientation(ForgeDirection dir) {\n+\t\t\tthis.dir = dir;\n+\t\t}\n+\n+\t\tpublic void rotateOrientation(IPositionRotateble set) {\n+\t\t\tif (this == EAST_WEST) {\n+\t\t\t\tset.rotateLeft();\n+\t\t\t}\n+\t\t}\n+\t}\n }",
    "function_modified_lines": {
      "added": [
        "\tpublic void writeData(LPDataOutput output) {\n",
        "\tpublic void readData(LPDataInput input) {\n"
      ],
      "deleted": [
        "\tpublic enum TubeLineOrientation implements ITubeOrientation {\n",
        "\t\tNORTH(TubeLineRenderOrientation.NORTH_SOUTH, new DoubleCoordinates(0, 0, 0), ForgeDirection.NORTH),\n",
        "\t\tSOUTH(TubeLineRenderOrientation.NORTH_SOUTH, new DoubleCoordinates(0, 0, 0), ForgeDirection.SOUTH),\n",
        "\t\tEAST(TubeLineRenderOrientation.EAST_WEST, new DoubleCoordinates(0, 0, 0), ForgeDirection.EAST),\n",
        "\t\tWEST(TubeLineRenderOrientation.EAST_WEST, new DoubleCoordinates(0, 0, 0), ForgeDirection.WEST);\n",
        "\n",
        "\t\t@Getter\n",
        "\t\tTubeLineRenderOrientation renderOrientation;\n",
        "\t\t@Getter\n",
        "\t\tDoubleCoordinates offset;\n",
        "\t\t@Getter\n",
        "\t\tForgeDirection dir;\n",
        "\n",
        "\t\tTubeLineOrientation(TubeLineRenderOrientation render, DoubleCoordinates off, ForgeDirection dir) {\n",
        "\t\t\trenderOrientation = render;\n",
        "\t\t\toffset = off;\n",
        "\t\t\tthis.dir = dir;\n",
        "\t\t}\n",
        "\n",
        "\t\t@Override\n",
        "\t\tpublic void rotatePositions(IPositionRotateble set) {\n",
        "\t\t\trenderOrientation.rotateOrientation(set);\n",
        "\t\t}\n",
        "\n",
        "\t\t@Override\n",
        "\t\tpublic void setOnPipe(CoreMultiBlockPipe pipe) {\n",
        "\t\t\t((HSTubeLine) pipe).orientation = this;\n",
        "\t\t}\n",
        "\t}\n",
        "\n",
        "\tpublic enum TubeLineRenderOrientation implements ITubeRenderOrientation {\n",
        "\t\tNORTH_SOUTH(ForgeDirection.NORTH),\n",
        "\t\tEAST_WEST(ForgeDirection.EAST);\n",
        "\n",
        "\t\t@Getter\n",
        "\t\tprivate ForgeDirection dir;\n",
        "\n",
        "\t\tTubeLineRenderOrientation(ForgeDirection dir) {\n",
        "\t\t\tthis.dir = dir;\n",
        "\t\t}\n",
        "\n",
        "\t\tpublic void rotateOrientation(IPositionRotateble set) {\n",
        "\t\t\tif (this == EAST_WEST) {\n",
        "\t\t\t\tset.rotateLeft();\n",
        "\t\t\t}\n",
        "\t\t}\n",
        "\t}\n",
        "\n",
        "\tpublic void writeData(LPDataOutput output) throws IOException {\n",
        "\tpublic void readData(LPDataInput input) throws IOException {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12832
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\nimport net.minecraft.entity.player.EntityPlayer;\nimport net.minecraft.item.Item;\nimport net.minecraft.nbt.NBTTagCompound;\nimport net.minecraft.tileentity.TileEntity;\nimport net.minecraft.util.AxisAlignedBB;\nimport net.minecraftforge.common.util.ForgeDirection;\nimport cpw.mods.fml.relauncher.Side;\nimport cpw.mods.fml.relauncher.SideOnly;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Getter;\n\nimport logisticspipes.interfaces.ITubeOrientation;\nimport logisticspipes.interfaces.ITubeRenderOrientation;\nimport logisticspipes.pipes.basic.CoreMultiBlockPipe;\nimport logisticspipes.pipes.basic.LogisticsTileGenericSubMultiBlock;\nimport logisticspipes.renderer.newpipe.IHighlightPlacementRenderer;\nimport logisticspipes.renderer.newpipe.ISpecialPipeRenderer;\nimport logisticspipes.renderer.newpipe.tube.SCurveTubeRenderer;\nimport logisticspipes.transport.LPTravelingItem;\nimport logisticspipes.transport.PipeMultiBlockTransportLogistics;\nimport logisticspipes.utils.IPositionRotateble;\nimport logisticspipes.utils.LPPositionSet;\nimport network.rs485.logisticspipes.util.LPDataInput;\nimport network.rs485.logisticspipes.util.LPDataOutput;\nimport network.rs485.logisticspipes.world.DoubleCoordinates;\nimport network.rs485.logisticspipes.world.DoubleCoordinatesType;\n\npublic class HSTubeSCurve extends CoreMultiBlockPipe {\n\n\t@AllArgsConstructor\n\tpublic enum CurveSOrientation implements ITubeOrientation {\n\t\t//@formatter:off\n\t\t// Name: Placement from  _ TurnDirection\n\t\tNORTH_EAST(TurnSDirection.NORTH_INV, new DoubleCoordinates(0, 0, 0), ForgeDirection.NORTH, ForgeDirection.EAST),\n\t\tNORTH_WEST(TurnSDirection.NORTH, new DoubleCoordinates(0, 0, 0), ForgeDirection.NORTH, ForgeDirection.WEST),\n\t\tEAST_SOUTH(TurnSDirection.EAST_INV, new DoubleCoordinates(0, 0, 0), ForgeDirection.EAST, ForgeDirection.SOUTH),\n\t\tEAST_NORTH(TurnSDirection.EAST, new DoubleCoordinates(0, 0, 0), ForgeDirection.EAST, ForgeDirection.NORTH),\n\t\tSOUTH_WEST(TurnSDirection.NORTH_INV, new DoubleCoordinates(-1, 0, 3), ForgeDirection.SOUTH, ForgeDirection.WEST),\n\t\tSOUTH_EAST(TurnSDirection.NORTH, new DoubleCoordinates(1, 0, 3), ForgeDirection.SOUTH, ForgeDirection.EAST),\n\t\tWEST_NORTH(TurnSDirection.EAST_INV, new DoubleCoordinates(-3, 0, -1), ForgeDirection.WEST, ForgeDirection.NORTH),\n\t\tWEST_SOUTH(TurnSDirection.EAST, new DoubleCoordinates(-3, 0, 1), ForgeDirection.WEST, ForgeDirection.SOUTH);\n\t\t//@formatter:on\n\n\t\t@Getter\n\t\tTurnSDirection renderOrientation;\n\t\t@Getter\n\t\tDoubleCoordinates offset;\n\t\t@Getter\n\t\tForgeDirection dir;\n\t\t@Getter\n\t\tForgeDirection looking;\n\n\t\t@Override\n\t\tpublic void rotatePositions(IPositionRotateble set) {\n\t\t\trenderOrientation.rotatePositions(set);\n\t\t}\n\n\t\t@Override\n\t\tpublic void setOnPipe(CoreMultiBlockPipe pipe) {\n\t\t\t((HSTubeSCurve) pipe).orientation = this;\n\t\t}\n\t}\n\n\t@AllArgsConstructor\n\tpublic enum TurnSDirection implements ITubeRenderOrientation {\n\t\t//@formatter:off\n\t\tNORTH(ForgeDirection.NORTH),\n\t\tEAST(ForgeDirection.EAST),\n\t\tNORTH_INV(ForgeDirection.SOUTH),\n\t\tEAST_INV(ForgeDirection.WEST);\n\t\t//@formatter:on\n\n\t\t@Getter\n\t\tprivate ForgeDirection dir1;\n\n\t\tpublic void rotatePositions(IPositionRotateble set) {\n\t\t\tif (this == NORTH) {\n\t\t\t\tset.mirrorX();\n\t\t\t} else if (this == EAST) {\n\t\t\t\tset.mirrorX();\n\t\t\t\tset.rotateRight();\n\t\t\t} else if (this == EAST_INV) {\n\t\t\t\tset.rotateRight();\n\t\t\t}\n\t\t}\n\t}\n\n\t@Getter\n\tprivate CurveSOrientation orientation;\n\n\tprivate List<AxisAlignedBB> boxes = null;\n\n\tpublic HSTubeSCurve(Item item) {\n\t\tsuper(new PipeMultiBlockTransportLogistics(), item);\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\tif (orientation == null) {\n\t\t\toutput.writeBoolean(false);\n\t\t} else {\n\t\t\toutput.writeBoolean(true);\n\t\t\toutput.writeEnum(orientation);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tif (input.readBoolean()) {\n\t\t\torientation = input.readEnum(CurveSOrientation.class);\n\t\t}\n\t}\n\n\t@Override\n\tpublic int getIconIndex(ForgeDirection direction) {\n\t\t// TODO Auto-generated method stub\n\t\treturn 0;\n\t}\n\n\t@Override\n\tpublic int getTextureIndex() {\n\t\t// TODO Auto-generated method stub\n\t\treturn 0;\n\t}\n\n\t@Override\n\tpublic LPPositionSet<DoubleCoordinatesType<SubBlockTypeForShare>> getSubBlocks() {\n\t\tLPPositionSet<DoubleCoordinatesType<SubBlockTypeForShare>> list = new LPPositionSet<>(DoubleCoordinatesType.class);\n\t\tlist.add(new DoubleCoordinatesType<>(0, 0, -1, SubBlockTypeForShare.S_CURVE_B));\n\t\tlist.add(new DoubleCoordinatesType<>(0, 0, -2, SubBlockTypeForShare.S_CURVE_A));\n\t\tlist.add(new DoubleCoordinatesType<>(1, 0, -1, SubBlockTypeForShare.S_CURVE_A));\n\t\tlist.add(new DoubleCoordinatesType<>(1, 0, -2, SubBlockTypeForShare.S_CURVE_B));\n\t\tlist.add(new DoubleCoordinatesType<>(1, 0, -3, SubBlockTypeForShare.NON_SHARE));\n\t\treturn list;\n\t}\n\n\t@Override\n\tpublic LPPositionSet<DoubleCoordinatesType<SubBlockTypeForShare>> getRotatedSubBlocks() {\n\t\tLPPositionSet<DoubleCoordinatesType<SubBlockTypeForShare>> set = getSubBlocks();\n\t\torientation.rotatePositions(set);\n\t\treturn set;\n\t}\n\n\t@Override",
    "code_after_change": "package logisticspipes.pipes.tubes;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\nimport net.minecraft.entity.player.EntityPlayer;\nimport net.minecraft.item.Item;\nimport net.minecraft.nbt.NBTTagCompound;\nimport net.minecraft.tileentity.TileEntity;\nimport net.minecraft.util.AxisAlignedBB;\nimport net.minecraftforge.common.util.ForgeDirection;\nimport cpw.mods.fml.relauncher.Side;\nimport cpw.mods.fml.relauncher.SideOnly;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Getter;\n\nimport logisticspipes.interfaces.ITubeOrientation;\nimport logisticspipes.interfaces.ITubeRenderOrientation;\nimport logisticspipes.pipes.basic.CoreMultiBlockPipe;\nimport logisticspipes.pipes.basic.LogisticsTileGenericSubMultiBlock;\nimport logisticspipes.renderer.newpipe.IHighlightPlacementRenderer;\nimport logisticspipes.renderer.newpipe.ISpecialPipeRenderer;\nimport logisticspipes.renderer.newpipe.tube.SCurveTubeRenderer;\nimport logisticspipes.transport.LPTravelingItem;\nimport logisticspipes.transport.PipeMultiBlockTransportLogistics;\nimport logisticspipes.utils.IPositionRotateble;\nimport logisticspipes.utils.LPPositionSet;\nimport network.rs485.logisticspipes.util.LPDataInput;\nimport network.rs485.logisticspipes.util.LPDataOutput;\nimport network.rs485.logisticspipes.world.DoubleCoordinates;\nimport network.rs485.logisticspipes.world.DoubleCoordinatesType;\n\npublic class HSTubeSCurve extends CoreMultiBlockPipe {\n\n\t@Getter\n\tprivate CurveSOrientation orientation;\n\tprivate List<AxisAlignedBB> boxes = null;\n\n\tpublic HSTubeSCurve(Item item) {\n\t\tsuper(new PipeMultiBlockTransportLogistics(), item);\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\tif (orientation == null) {\n\t\t\toutput.writeBoolean(false);\n\t\t} else {\n\t\t\toutput.writeBoolean(true);\n\t\t\toutput.writeEnum(orientation);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tif (input.readBoolean()) {\n\t\t\torientation = input.readEnum(CurveSOrientation.class);\n\t\t}\n\t}\n\n\t@Override\n\tpublic int getIconIndex(ForgeDirection direction) {\n\t\t// TODO Auto-generated method stub\n\t\treturn 0;\n\t}\n\n\t@Override\n\tpublic int getTextureIndex() {\n\t\t// TODO Auto-generated method stub\n\t\treturn 0;\n\t}\n\n\t@Override\n\tpublic LPPositionSet<DoubleCoordinatesType<SubBlockTypeForShare>> getSubBlocks() {\n\t\tLPPositionSet<DoubleCoordinatesType<SubBlockTypeForShare>> list = new LPPositionSet<>(DoubleCoordinatesType.class);\n\t\tlist.add(new DoubleCoordinatesType<>(0, 0, -1, SubBlockTypeForShare.S_CURVE_B));\n\t\tlist.add(new DoubleCoordinatesType<>(0, 0, -2, SubBlockTypeForShare.S_CURVE_A));\n\t\tlist.add(new DoubleCoordinatesType<>(1, 0, -1, SubBlockTypeForShare.S_CURVE_A));\n\t\tlist.add(new DoubleCoordinatesType<>(1, 0, -2, SubBlockTypeForShare.S_CURVE_B));\n\t\tlist.add(new DoubleCoordinatesType<>(1, 0, -3, SubBlockTypeForShare.NON_SHARE));\n\t\treturn list;\n\t}\n\n\t@Override\n\tpublic LPPositionSet<DoubleCoordinatesType<SubBlockTypeForShare>> getRotatedSubBlocks() {\n\t\tLPPositionSet<DoubleCoordinatesType<SubBlockTypeForShare>> set = getSubBlocks();\n\t\torientation.rotatePositions(set);\n\t\treturn set;\n\t}\n\n\t@Override",
    "patch": "@@ -1,6 +1,5 @@\n package logisticspipes.pipes.tubes;\n \n-import java.io.IOException;\n import java.util.ArrayList;\n import java.util.List;\n import java.util.stream.Collectors;\n@@ -35,75 +34,16 @@\n \n public class HSTubeSCurve extends CoreMultiBlockPipe {\n \n-\t@AllArgsConstructor\n-\tpublic enum CurveSOrientation implements ITubeOrientation {\n-\t\t//@formatter:off\n-\t\t// Name: Placement from  _ TurnDirection\n-\t\tNORTH_EAST(TurnSDirection.NORTH_INV, new DoubleCoordinates(0, 0, 0), ForgeDirection.NORTH, ForgeDirection.EAST),\n-\t\tNORTH_WEST(TurnSDirection.NORTH, new DoubleCoordinates(0, 0, 0), ForgeDirection.NORTH, ForgeDirection.WEST),\n-\t\tEAST_SOUTH(TurnSDirection.EAST_INV, new DoubleCoordinates(0, 0, 0), ForgeDirection.EAST, ForgeDirection.SOUTH),\n-\t\tEAST_NORTH(TurnSDirection.EAST, new DoubleCoordinates(0, 0, 0), ForgeDirection.EAST, ForgeDirection.NORTH),\n-\t\tSOUTH_WEST(TurnSDirection.NORTH_INV, new DoubleCoordinates(-1, 0, 3), ForgeDirection.SOUTH, ForgeDirection.WEST),\n-\t\tSOUTH_EAST(TurnSDirection.NORTH, new DoubleCoordinates(1, 0, 3), ForgeDirection.SOUTH, ForgeDirection.EAST),\n-\t\tWEST_NORTH(TurnSDirection.EAST_INV, new DoubleCoordinates(-3, 0, -1), ForgeDirection.WEST, ForgeDirection.NORTH),\n-\t\tWEST_SOUTH(TurnSDirection.EAST, new DoubleCoordinates(-3, 0, 1), ForgeDirection.WEST, ForgeDirection.SOUTH);\n-\t\t//@formatter:on\n-\n-\t\t@Getter\n-\t\tTurnSDirection renderOrientation;\n-\t\t@Getter\n-\t\tDoubleCoordinates offset;\n-\t\t@Getter\n-\t\tForgeDirection dir;\n-\t\t@Getter\n-\t\tForgeDirection looking;\n-\n-\t\t@Override\n-\t\tpublic void rotatePositions(IPositionRotateble set) {\n-\t\t\trenderOrientation.rotatePositions(set);\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void setOnPipe(CoreMultiBlockPipe pipe) {\n-\t\t\t((HSTubeSCurve) pipe).orientation = this;\n-\t\t}\n-\t}\n-\n-\t@AllArgsConstructor\n-\tpublic enum TurnSDirection implements ITubeRenderOrientation {\n-\t\t//@formatter:off\n-\t\tNORTH(ForgeDirection.NORTH),\n-\t\tEAST(ForgeDirection.EAST),\n-\t\tNORTH_INV(ForgeDirection.SOUTH),\n-\t\tEAST_INV(ForgeDirection.WEST);\n-\t\t//@formatter:on\n-\n-\t\t@Getter\n-\t\tprivate ForgeDirection dir1;\n-\n-\t\tpublic void rotatePositions(IPositionRotateble set) {\n-\t\t\tif (this == NORTH) {\n-\t\t\t\tset.mirrorX();\n-\t\t\t} else if (this == EAST) {\n-\t\t\t\tset.mirrorX();\n-\t\t\t\tset.rotateRight();\n-\t\t\t} else if (this == EAST_INV) {\n-\t\t\t\tset.rotateRight();\n-\t\t\t}\n-\t\t}\n-\t}\n-\n \t@Getter\n \tprivate CurveSOrientation orientation;\n-\n \tprivate List<AxisAlignedBB> boxes = null;\n \n \tpublic HSTubeSCurve(Item item) {\n \t\tsuper(new PipeMultiBlockTransportLogistics(), item);\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\tif (orientation == null) {\n \t\t\toutput.writeBoolean(false);\n \t\t} else {\n@@ -113,7 +53,7 @@ public void writeData(LPDataOutput output) throws IOException {\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tif (input.readBoolean()) {\n \t\t\torientation = input.readEnum(CurveSOrientation.class);\n \t\t}\n@@ -456,4 +396,62 @@ public double getBoxRenderScale(float fPos, LPTravelingItem travelItem) {\n \tpublic boolean isHSTube() {\n \t\treturn true;\n \t}\n+\n+\t@AllArgsConstructor\n+\tpublic enum CurveSOrientation implements ITubeOrientation {\n+\t\t//@formatter:off\n+\t\t// Name: Placement from  _ TurnDirection\n+\t\tNORTH_EAST(TurnSDirection.NORTH_INV, new DoubleCoordinates(0, 0, 0), ForgeDirection.NORTH, ForgeDirection.EAST),\n+\t\tNORTH_WEST(TurnSDirection.NORTH, new DoubleCoordinates(0, 0, 0), ForgeDirection.NORTH, ForgeDirection.WEST),\n+\t\tEAST_SOUTH(TurnSDirection.EAST_INV, new DoubleCoordinates(0, 0, 0), ForgeDirection.EAST, ForgeDirection.SOUTH),\n+\t\tEAST_NORTH(TurnSDirection.EAST, new DoubleCoordinates(0, 0, 0), ForgeDirection.EAST, ForgeDirection.NORTH),\n+\t\tSOUTH_WEST(TurnSDirection.NORTH_INV, new DoubleCoordinates(-1, 0, 3), ForgeDirection.SOUTH, ForgeDirection.WEST),\n+\t\tSOUTH_EAST(TurnSDirection.NORTH, new DoubleCoordinates(1, 0, 3), ForgeDirection.SOUTH, ForgeDirection.EAST),\n+\t\tWEST_NORTH(TurnSDirection.EAST_INV, new DoubleCoordinates(-3, 0, -1), ForgeDirection.WEST, ForgeDirection.NORTH),\n+\t\tWEST_SOUTH(TurnSDirection.EAST, new DoubleCoordinates(-3, 0, 1), ForgeDirection.WEST, ForgeDirection.SOUTH);\n+\t\t//@formatter:on\n+\n+\t\t@Getter\n+\t\tTurnSDirection renderOrientation;\n+\t\t@Getter\n+\t\tDoubleCoordinates offset;\n+\t\t@Getter\n+\t\tForgeDirection dir;\n+\t\t@Getter\n+\t\tForgeDirection looking;\n+\n+\t\t@Override\n+\t\tpublic void rotatePositions(IPositionRotateble set) {\n+\t\t\trenderOrientation.rotatePositions(set);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void setOnPipe(CoreMultiBlockPipe pipe) {\n+\t\t\t((HSTubeSCurve) pipe).orientation = this;\n+\t\t}\n+\t}\n+\n+\t@AllArgsConstructor\n+\tpublic enum TurnSDirection implements ITubeRenderOrientation {\n+\t\t//@formatter:off\n+\t\tNORTH(ForgeDirection.NORTH),\n+\t\tEAST(ForgeDirection.EAST),\n+\t\tNORTH_INV(ForgeDirection.SOUTH),\n+\t\tEAST_INV(ForgeDirection.WEST);\n+\t\t//@formatter:on\n+\n+\t\t@Getter\n+\t\tprivate ForgeDirection dir1;\n+\n+\t\tpublic void rotatePositions(IPositionRotateble set) {\n+\t\t\tif (this == NORTH) {\n+\t\t\t\tset.mirrorX();\n+\t\t\t} else if (this == EAST) {\n+\t\t\t\tset.mirrorX();\n+\t\t\t\tset.rotateRight();\n+\t\t\t} else if (this == EAST_INV) {\n+\t\t\t\tset.rotateRight();\n+\t\t\t}\n+\t\t}\n+\t}\n }",
    "function_modified_lines": {
      "added": [
        "\tpublic void writeData(LPDataOutput output) {\n",
        "\tpublic void readData(LPDataInput input) {\n"
      ],
      "deleted": [
        "\t@AllArgsConstructor\n",
        "\tpublic enum CurveSOrientation implements ITubeOrientation {\n",
        "\t\t//@formatter:off\n",
        "\t\t// Name: Placement from  _ TurnDirection\n",
        "\t\tNORTH_EAST(TurnSDirection.NORTH_INV, new DoubleCoordinates(0, 0, 0), ForgeDirection.NORTH, ForgeDirection.EAST),\n",
        "\t\tNORTH_WEST(TurnSDirection.NORTH, new DoubleCoordinates(0, 0, 0), ForgeDirection.NORTH, ForgeDirection.WEST),\n",
        "\t\tEAST_SOUTH(TurnSDirection.EAST_INV, new DoubleCoordinates(0, 0, 0), ForgeDirection.EAST, ForgeDirection.SOUTH),\n",
        "\t\tEAST_NORTH(TurnSDirection.EAST, new DoubleCoordinates(0, 0, 0), ForgeDirection.EAST, ForgeDirection.NORTH),\n",
        "\t\tSOUTH_WEST(TurnSDirection.NORTH_INV, new DoubleCoordinates(-1, 0, 3), ForgeDirection.SOUTH, ForgeDirection.WEST),\n",
        "\t\tSOUTH_EAST(TurnSDirection.NORTH, new DoubleCoordinates(1, 0, 3), ForgeDirection.SOUTH, ForgeDirection.EAST),\n",
        "\t\tWEST_NORTH(TurnSDirection.EAST_INV, new DoubleCoordinates(-3, 0, -1), ForgeDirection.WEST, ForgeDirection.NORTH),\n",
        "\t\tWEST_SOUTH(TurnSDirection.EAST, new DoubleCoordinates(-3, 0, 1), ForgeDirection.WEST, ForgeDirection.SOUTH);\n",
        "\t\t//@formatter:on\n",
        "\n",
        "\t\t@Getter\n",
        "\t\tTurnSDirection renderOrientation;\n",
        "\t\t@Getter\n",
        "\t\tDoubleCoordinates offset;\n",
        "\t\t@Getter\n",
        "\t\tForgeDirection dir;\n",
        "\t\t@Getter\n",
        "\t\tForgeDirection looking;\n",
        "\n",
        "\t\t@Override\n",
        "\t\tpublic void rotatePositions(IPositionRotateble set) {\n",
        "\t\t\trenderOrientation.rotatePositions(set);\n",
        "\t\t}\n",
        "\n",
        "\t\t@Override\n",
        "\t\tpublic void setOnPipe(CoreMultiBlockPipe pipe) {\n",
        "\t\t\t((HSTubeSCurve) pipe).orientation = this;\n",
        "\t\t}\n",
        "\t}\n",
        "\n",
        "\t@AllArgsConstructor\n",
        "\tpublic enum TurnSDirection implements ITubeRenderOrientation {\n",
        "\t\t//@formatter:off\n",
        "\t\tNORTH(ForgeDirection.NORTH),\n",
        "\t\tEAST(ForgeDirection.EAST),\n",
        "\t\tNORTH_INV(ForgeDirection.SOUTH),\n",
        "\t\tEAST_INV(ForgeDirection.WEST);\n",
        "\t\t//@formatter:on\n",
        "\n",
        "\t\t@Getter\n",
        "\t\tprivate ForgeDirection dir1;\n",
        "\n",
        "\t\tpublic void rotatePositions(IPositionRotateble set) {\n",
        "\t\t\tif (this == NORTH) {\n",
        "\t\t\t\tset.mirrorX();\n",
        "\t\t\t} else if (this == EAST) {\n",
        "\t\t\t\tset.mirrorX();\n",
        "\t\t\t\tset.rotateRight();\n",
        "\t\t\t} else if (this == EAST_INV) {\n",
        "\t\t\t\tset.rotateRight();\n",
        "\t\t\t}\n",
        "\t\t}\n",
        "\t}\n",
        "\n",
        "\n",
        "\tpublic void writeData(LPDataOutput output) throws IOException {\n",
        "\tpublic void readData(LPDataInput input) throws IOException {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12833
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "{\n\n\t@AllArgsConstructor\n\tpublic enum SpeedupDirection implements ITubeRenderOrientation, ITubeOrientation {\n\t\t//@formatter:off\n\t\tNORTH(ForgeDirection.NORTH),\n\t\tSOUTH(ForgeDirection.SOUTH),\n\t\tEAST(ForgeDirection.EAST),\n\t\tWEST(ForgeDirection.WEST);\n\t\t//@formatter:on\n\t\t@Getter\n\t\tForgeDirection dir1;\n\n\t\t@Override\n\t\tpublic void rotatePositions(IPositionRotateble set) {\n\t\t\tif (this == SOUTH) {\n\t\t\t\tset.rotateLeft();\n\t\t\t\tset.rotateLeft();\n\t\t\t} else if (this == EAST) {\n\t\t\t\tset.rotateRight();\n\t\t\t} else if (this == WEST) {\n\t\t\t\tset.rotateLeft();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic ITubeRenderOrientation getRenderOrientation() {\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic DoubleCoordinates getOffset() {\n\t\t\treturn new DoubleCoordinates(0, 0, 0);\n\t\t}\n\n\t\t@Override\n\t\tpublic void setOnPipe(CoreMultiBlockPipe pipe) {\n\t\t\t((HSTubeSpeedup) pipe).orientation = this;\n\t\t}\n\t}\n\n\t@Getter\n\tprivate SpeedupDirection orientation;\n\n\tpublic HSTubeSpeedup(Item item) {\n\t\tsuper(new PipeMultiBlockTransportLogistics() {\n\n\t\t\t@Override\n\t\t\tpublic boolean canPipeConnect(TileEntity tile, ForgeDirection side) {\n\t\t\t\tif (side.getOpposite() == ((HSTubeSpeedup) getMultiPipe()).orientation.dir1) {\n\t\t\t\t\treturn super.canPipeConnect_internal(tile, side);\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected void handleTileReachedServer(LPTravelingItemServer arrivingItem, TileEntity tile, ForgeDirection dir) {\n\t\t\t\tif (dir.getOpposite() == ((HSTubeSpeedup) getMultiPipe()).orientation.dir1) {\n\t\t\t\t\tarrivingItem.setSpeed(LPConstants.PIPE_NORMAL_SPEED * 20);\n\t\t\t\t\thandleTileReachedServer_internal(arrivingItem, tile, dir);\n\t\t\t\t} else {\n\t\t\t\t\tsuper.handleTileReachedServer(arrivingItem, tile, dir);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected void handleTileReachedClient(LPTravelingItemClient arrivingItem, TileEntity tile, ForgeDirection dir) {\n\t\t\t\tif (dir.getOpposite() == ((HSTubeSpeedup) getMultiPipe()).orientation.dir1) {\n\t\t\t\t\tif (SimpleServiceLocator.pipeInformationManager.isItemPipe(tile)) {\n\t\t\t\t\t\tarrivingItem.setSpeed(LPConstants.PIPE_NORMAL_SPEED * 20);\n\t\t\t\t\t\tpassToNextPipe(arrivingItem, tile);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tsuper.handleTileReachedClient(arrivingItem, tile, dir);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}, item);\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\toutput.writeEnum(orientation);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\torientation = input.readEnum(SpeedupDirection.class);\n\t}\n\n\t@Override\n\tpublic LPPositionSet<DoubleCoordinatesType<SubBlockTypeForShare>> getSubBlocks() {\n\t\tLPPositionSet<DoubleCoordinatesType<SubBlockTypeForShare>> set = new LPPositionSet<>(DoubleCoordinatesType.class);\n\t\tset.add(new DoubleCoordinatesType<>(0, 0, -1, SubBlockTypeForShare.NON_SHARE));\n\t\tset.add(new DoubleCoordinatesType<>(0, 0, -2, SubBlockTypeForShare.NON_SHARE));\n\t\tset.add(new DoubleCoordinatesType<>(0, 0, -3, SubBlockTypeForShare.NON_SHARE));\n\t\treturn set;\n\t}\n\n\t@Override\n\tpublic LPPositionSet<DoubleCoordinatesType<SubBlockTypeForShare>> getRotatedSubBlocks() {\n\t\tLPPositionSet<DoubleCoordinatesType<SubBlockTypeForShare>> set = getSubBlocks();\n\t\torientation.rotatePositions(set);\n\t\treturn set;\n\t}\n\n\t@Override\n\tpublic void addCollisionBoxesToList(List arraylist, AxisAlignedBB axisalignedbb) {\n\t\tDoubleCoordinates pos = getLPPosition();\n\t\tDoubleCoordinates posMin = new DoubleCoordinates(LPConstants.PIPE_MIN_POS, LPConstants.PIPE_MIN_POS, LPConstants.PIPE_MIN_POS);\n\t\tDoubleCoordinates posMax = new DoubleCoordinates(LPConstants.PIPE_MAX_POS, LPConstants.PIPE_MAX_POS, -3);\n\t\torientation.rotatePositions(posMin);\n\t\torientation.rotatePositions(posMax);\n\t\tif (orientation == SpeedupDirection.EAST) {\n\t\t\tpos.add(new DoubleCoordinates(1, 0, 0));\n\t\t} else if (orientation == SpeedupDirection.SOUTH) {\n\t\t\tpos.add(new DoubleCoordinates(1, 0, 1));\n\t\t} else if (orientation == SpeedupDirection.WEST) {\n\t\t\tpos.add(new DoubleCoordinates(0, 0, 1));\n\t\t}\n\t\tposMin.add(pos);\n\t\tposMax.add(pos);\n\t\tLPPositionSet<DoubleCoordinates> set = new LPPositionSet<>(DoubleCoordinates.class);\n\t\tset.add(posMin);\n\t\tset.add(posMax);\n\t\tAxisAlignedBB box = set.toABB();\n\t\tif (box != null && (axisalignedbb == null || axisalignedbb.intersectsWith(box))) {\n\t\t\tarraylist.add(box);\n\t\t}\n\t}\n\n\t@Override\n\tpublic AxisAlignedBB getCompleteBox() {\n\t\treturn SpeedupTubeRenderer.tubeSpeedup.get(orientation).bounds().toAABB();\n\t}\n\n\t@Override\n\tpublic ITubeOrientation getTubeOrientation(EntityPlayer player, int xPos, int zPos) {\n\t\tdouble x = xPos + 0.5 - player.posX;\n\t\tdouble z = zPos + 0.5 - player.posZ;\n\t\tdouble w = Math.atan2(x, z);\n\t\tdouble halfPI = Math.PI / 2;\n\t\tdouble halfhalfPI = halfPI / 2;\n\t\tw -= halfhalfPI;\n\t\tif (w < 0) {\n\t\t\tw += 2 * Math.PI;\n\t\t}\n\t\tForgeDirection dir = ForgeDirection.UNKNOWN;\n\t\tif (0 < w && w <= halfPI) {\n\t\t\tdir = ForgeDirection.WEST;\n\t\t} else if (halfPI < w && w <= 2 * halfPI) {\n\t\t\tdir = ForgeDirection.SOUTH;\n\t\t} else if (2 * halfPI < w && w <= 3 * halfPI) {\n\t\t\tdir = ForgeDirection.EAST;\n\t\t} else if (3 * halfPI < w && w <= 4 * halfPI) {\n\t\t\tdir = ForgeDirection.NORTH;\n\t\t}\n\t\tfor (SpeedupDirection ori : SpeedupDirection.values()) {\n\t\t\tif (ori.dir1.getOpposite().equals(dir)) {\n\t\t\t\treturn ori;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic void writeToNBT(NBTTagCompound data) {\n\t\tsuper.writeToNBT(data);\n\t\tdata.setString(\"orientation\", orientation.name());\n\t}\n\n\t@Override\n\tpublic void readFromNBT(NBTTagCompound data) {\n\t\tsuper.readFromNBT(data);\n\t\torientation = SpeedupDirection.valueOf(data.getString(\"orientation\"));\n\t}\n\n\t@Override\n\tpublic float getPipeLength() {\n\t\treturn 4;\n\t}\n\n\t@Override\n\tpublic ForgeDirection getExitForInput(ForgeDirection commingFrom) {\n\t\treturn commingFrom.getOpposite();\n\t}\n\n\t@Override\n\tpublic TileEntity getConnectedEndTile(ForgeDirection output) {\n\t\tif (orientation.dir1 == output) {\n\t\t\tDoubleCoordinates pos = new DoubleCoordinates(0, 0, -3);\n\t\t\tLPPositionSet<DoubleCoordinates> set = new LPPositionSet<>(DoubleCoordinates.class);\n\t\t\tset.add(pos);\n\t\t\torientation.rotatePositions(set);\n\t\t\tTileEntity subTile = pos.add(getLPPosition()).getTileEntity(getWorld());\n\t\t\tif (subTile instanceof LogisticsTileGenericSubMultiBlock) {\n\t\t\t\treturn ((LogisticsTileGenericSubMultiBlock) subTile).getTile(output);\n\t\t\t}\n\t\t} else if (orientation.dir1.getOpposite() == output) {\n\t\t\treturn container.getTile(output);\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic boolean actAsNormalPipe() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic ISpecialPipeRenderer getSpecialRenderer() {\n\t\treturn SpeedupTubeRenderer.instance;\n\t}\n\n\t@Override\n\tpublic IHighlightPlacementRenderer getHighlightRenderer() {\n\t\treturn SpeedupTubeRenderer.instance;\n\t}\n\n\t@Override\n\tpublic int getIconIndex(ForgeDirection direction) {\n\t\t// TODO Auto-generated method stub\n\t\treturn 0;\n\t}\n\n\t@Override\n\tpublic int getTextureIndex() {\n\t\t// TODO Auto-generated method stub\n\t\treturn 0;\n\t}\n\n\t@Override\n\tpublic boolean hasSpecialPipeEndAt(ForgeDirection dir) {\n\t\treturn dir == orientation.dir1;\n\t}\n\n\t@Override\n\tpublic DoubleCoordinates getItemRenderPos(float fPos, LPTravelingItem travelItem) {\n\t\tDoubleCoordinates pos = new DoubleCoordinates(0.5D, 0.5D, 0.5D);\n\t\tfloat pPos = fPos;\n\t\tif (travelItem.input.getOpposite() == orientation.dir1) {\n\t\t\tCoordinateUtils.add(pos, orientation.dir1, 3);\n\t\t\tpPos = this.getPipeLength() - fPos;\n\t\t}\n\t\tif (pPos < 0.5) {\n\t\t\tif (travelItem.input == ForgeDirection.UNKNOWN) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (!container.renderState.pipeConnectionMatrix.isConnected(travelItem.input.getOpposite())) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tCoordinateUtils.add(pos, travelItem.input.getOpposite(), 0.5 - fPos);\n\t\t} else {\n\t\t\tif (travelItem.output == ForgeDirection.UNKNOWN) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tCoordinateUtils.add(pos, travelItem.output, fPos - 0.5);\n\t\t}\n\t\treturn pos;\n\t}\n\n\t@Override\n\tpublic boolean canPipeConnect(TileEntity tile, ForgeDirection side) {\n\t\tif (tile instanceof LogisticsTileGenericSubMultiBlock) {\n\t\t\tif (this.getOrientation().getDir1() != side) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn super.canPipeConnect(tile, side);\n\t}\n\n\t@Override\n\tpublic boolean isHSTube() {\n\t\treturn true;\n\t}\n}",
    "code_after_change": "public class HSTubeSpeedup extends CoreMultiBlockPipe {\n\n\t@Getter\n\tprivate SpeedupDirection orientation;\n\n\tpublic HSTubeSpeedup(Item item) {\n\t\tsuper(new PipeMultiBlockTransportLogistics() {\n\n\t\t\t@Override\n\t\t\tpublic boolean canPipeConnect(TileEntity tile, ForgeDirection side) {\n\t\t\t\tif (side.getOpposite() == ((HSTubeSpeedup) getMultiPipe()).orientation.dir1) {\n\t\t\t\t\treturn super.canPipeConnect_internal(tile, side);\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected void handleTileReachedServer(LPTravelingItemServer arrivingItem, TileEntity tile, ForgeDirection dir) {\n\t\t\t\tif (dir.getOpposite() == ((HSTubeSpeedup) getMultiPipe()).orientation.dir1) {\n\t\t\t\t\tarrivingItem.setSpeed(LPConstants.PIPE_NORMAL_SPEED * 20);\n\t\t\t\t\thandleTileReachedServer_internal(arrivingItem, tile, dir);\n\t\t\t\t} else {\n\t\t\t\t\tsuper.handleTileReachedServer(arrivingItem, tile, dir);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected void handleTileReachedClient(LPTravelingItemClient arrivingItem, TileEntity tile, ForgeDirection dir) {\n\t\t\t\tif (dir.getOpposite() == ((HSTubeSpeedup) getMultiPipe()).orientation.dir1) {\n\t\t\t\t\tif (SimpleServiceLocator.pipeInformationManager.isItemPipe(tile)) {\n\t\t\t\t\t\tarrivingItem.setSpeed(LPConstants.PIPE_NORMAL_SPEED * 20);\n\t\t\t\t\t\tpassToNextPipe(arrivingItem, tile);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tsuper.handleTileReachedClient(arrivingItem, tile, dir);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}, item);\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\toutput.writeEnum(orientation);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\torientation = input.readEnum(SpeedupDirection.class);\n\t}\n\n\t@Override\n\tpublic LPPositionSet<DoubleCoordinatesType<SubBlockTypeForShare>> getSubBlocks() {\n\t\tLPPositionSet<DoubleCoordinatesType<SubBlockTypeForShare>> set = new LPPositionSet<>(DoubleCoordinatesType.class);\n\t\tset.add(new DoubleCoordinatesType<>(0, 0, -1, SubBlockTypeForShare.NON_SHARE));\n\t\tset.add(new DoubleCoordinatesType<>(0, 0, -2, SubBlockTypeForShare.NON_SHARE));\n\t\tset.add(new DoubleCoordinatesType<>(0, 0, -3, SubBlockTypeForShare.NON_SHARE));\n\t\treturn set;\n\t}\n\n\t@Override\n\tpublic LPPositionSet<DoubleCoordinatesType<SubBlockTypeForShare>> getRotatedSubBlocks() {\n\t\tLPPositionSet<DoubleCoordinatesType<SubBlockTypeForShare>> set = getSubBlocks();\n\t\torientation.rotatePositions(set);\n\t\treturn set;\n\t}\n\n\t@Override\n\tpublic void addCollisionBoxesToList(List arraylist, AxisAlignedBB axisalignedbb) {\n\t\tDoubleCoordinates pos = getLPPosition();\n\t\tDoubleCoordinates posMin = new DoubleCoordinates(LPConstants.PIPE_MIN_POS, LPConstants.PIPE_MIN_POS, LPConstants.PIPE_MIN_POS);\n\t\tDoubleCoordinates posMax = new DoubleCoordinates(LPConstants.PIPE_MAX_POS, LPConstants.PIPE_MAX_POS, -3);\n\t\torientation.rotatePositions(posMin);\n\t\torientation.rotatePositions(posMax);\n\t\tif (orientation == SpeedupDirection.EAST) {\n\t\t\tpos.add(new DoubleCoordinates(1, 0, 0));\n\t\t} else if (orientation == SpeedupDirection.SOUTH) {\n\t\t\tpos.add(new DoubleCoordinates(1, 0, 1));\n\t\t} else if (orientation == SpeedupDirection.WEST) {\n\t\t\tpos.add(new DoubleCoordinates(0, 0, 1));\n\t\t}\n\t\tposMin.add(pos);\n\t\tposMax.add(pos);\n\t\tLPPositionSet<DoubleCoordinates> set = new LPPositionSet<>(DoubleCoordinates.class);\n\t\tset.add(posMin);\n\t\tset.add(posMax);\n\t\tAxisAlignedBB box = set.toABB();\n\t\tif (box != null && (axisalignedbb == null || axisalignedbb.intersectsWith(box))) {\n\t\t\tarraylist.add(box);\n\t\t}\n\t}\n\n\t@Override\n\tpublic AxisAlignedBB getCompleteBox() {\n\t\treturn SpeedupTubeRenderer.tubeSpeedup.get(orientation).bounds().toAABB();\n\t}\n\n\t@Override\n\tpublic ITubeOrientation getTubeOrientation(EntityPlayer player, int xPos, int zPos) {\n\t\tdouble x = xPos + 0.5 - player.posX;\n\t\tdouble z = zPos + 0.5 - player.posZ;\n\t\tdouble w = Math.atan2(x, z);\n\t\tdouble halfPI = Math.PI / 2;\n\t\tdouble halfhalfPI = halfPI / 2;\n\t\tw -= halfhalfPI;\n\t\tif (w < 0) {\n\t\t\tw += 2 * Math.PI;\n\t\t}\n\t\tForgeDirection dir = ForgeDirection.UNKNOWN;\n\t\tif (0 < w && w <= halfPI) {\n\t\t\tdir = ForgeDirection.WEST;\n\t\t} else if (halfPI < w && w <= 2 * halfPI) {\n\t\t\tdir = ForgeDirection.SOUTH;\n\t\t} else if (2 * halfPI < w && w <= 3 * halfPI) {\n\t\t\tdir = ForgeDirection.EAST;\n\t\t} else if (3 * halfPI < w && w <= 4 * halfPI) {\n\t\t\tdir = ForgeDirection.NORTH;\n\t\t}\n\t\tfor (SpeedupDirection ori : SpeedupDirection.values()) {\n\t\t\tif (ori.dir1.getOpposite().equals(dir)) {\n\t\t\t\treturn ori;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic void writeToNBT(NBTTagCompound data) {\n\t\tsuper.writeToNBT(data);\n\t\tdata.setString(\"orientation\", orientation.name());\n\t}\n\n\t@Override\n\tpublic void readFromNBT(NBTTagCompound data) {\n\t\tsuper.readFromNBT(data);\n\t\torientation = SpeedupDirection.valueOf(data.getString(\"orientation\"));\n\t}\n\n\t@Override\n\tpublic float getPipeLength() {\n\t\treturn 4;\n\t}\n\n\t@Override\n\tpublic ForgeDirection getExitForInput(ForgeDirection commingFrom) {\n\t\treturn commingFrom.getOpposite();\n\t}\n\n\t@Override\n\tpublic TileEntity getConnectedEndTile(ForgeDirection output) {\n\t\tif (orientation.dir1 == output) {\n\t\t\tDoubleCoordinates pos = new DoubleCoordinates(0, 0, -3);\n\t\t\tLPPositionSet<DoubleCoordinates> set = new LPPositionSet<>(DoubleCoordinates.class);\n\t\t\tset.add(pos);\n\t\t\torientation.rotatePositions(set);\n\t\t\tTileEntity subTile = pos.add(getLPPosition()).getTileEntity(getWorld());\n\t\t\tif (subTile instanceof LogisticsTileGenericSubMultiBlock) {\n\t\t\t\treturn ((LogisticsTileGenericSubMultiBlock) subTile).getTile(output);\n\t\t\t}\n\t\t} else if (orientation.dir1.getOpposite() == output) {\n\t\t\treturn container.getTile(output);\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic boolean actAsNormalPipe() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic ISpecialPipeRenderer getSpecialRenderer() {\n\t\treturn SpeedupTubeRenderer.instance;\n\t}\n\n\t@Override\n\tpublic IHighlightPlacementRenderer getHighlightRenderer() {\n\t\treturn SpeedupTubeRenderer.instance;\n\t}\n\n\t@Override\n\tpublic int getIconIndex(ForgeDirection direction) {\n\t\t// TODO Auto-generated method stub\n\t\treturn 0;\n\t}\n\n\t@Override\n\tpublic int getTextureIndex() {\n\t\t// TODO Auto-generated method stub\n\t\treturn 0;\n\t}\n\n\t@Override\n\tpublic boolean hasSpecialPipeEndAt(ForgeDirection dir) {\n\t\treturn dir == orientation.dir1;\n\t}\n\n\t@Override\n\tpublic DoubleCoordinates getItemRenderPos(float fPos, LPTravelingItem travelItem) {\n\t\tDoubleCoordinates pos = new DoubleCoordinates(0.5D, 0.5D, 0.5D);\n\t\tfloat pPos = fPos;\n\t\tif (travelItem.input.getOpposite() == orientation.dir1) {\n\t\t\tCoordinateUtils.add(pos, orientation.dir1, 3);\n\t\t\tpPos = this.getPipeLength() - fPos;\n\t\t}\n\t\tif (pPos < 0.5) {\n\t\t\tif (travelItem.input == ForgeDirection.UNKNOWN) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (!container.renderState.pipeConnectionMatrix.isConnected(travelItem.input.getOpposite())) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tCoordinateUtils.add(pos, travelItem.input.getOpposite(), 0.5 - fPos);\n\t\t} else {\n\t\t\tif (travelItem.output == ForgeDirection.UNKNOWN) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tCoordinateUtils.add(pos, travelItem.output, fPos - 0.5);\n\t\t}\n\t\treturn pos;\n\t}\n\n\t@Override\n\tpublic boolean canPipeConnect(TileEntity tile, ForgeDirection side) {\n\t\tif (tile instanceof LogisticsTileGenericSubMultiBlock) {\n\t\t\tif (this.getOrientation().getDir1() != side) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn super.canPipeConnect(tile, side);\n\t}\n\n\t@Override\n\tpublic boolean isHSTube() {\n\t\treturn true;\n\t}\n\n\t@AllArgsConstructor\n\tpublic enum SpeedupDirection implements ITubeRenderOrientation, ITubeOrientation {\n\t\t//@formatter:off\n\t\tNORTH(ForgeDirection.NORTH),\n\t\tSOUTH(ForgeDirection.SOUTH),\n\t\tEAST(ForgeDirection.EAST),\n\t\tWEST(ForgeDirection.WEST);\n\t\t//@formatter:on\n\t\t@Getter\n\t\tForgeDirection dir1;\n\n\t\t@Override\n\t\tpublic void rotatePositions(IPositionRotateble set) {\n\t\t\tif (this == SOUTH) {\n\t\t\t\tset.rotateLeft();\n\t\t\t\tset.rotateLeft();\n\t\t\t} else if (this == EAST) {\n\t\t\t\tset.rotateRight();\n\t\t\t} else if (this == WEST) {\n\t\t\t\tset.rotateLeft();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic ITubeRenderOrientation getRenderOrientation() {\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic DoubleCoordinates getOffset() {\n\t\t\treturn new DoubleCoordinates(0, 0, 0);\n\t\t}\n\n\t\t@Override\n\t\tpublic void setOnPipe(CoreMultiBlockPipe pipe) {\n\t\t\t((HSTubeSpeedup) pipe).orientation = this;\n\t\t}\n\t}\n}",
    "patch": "@@ -1,6 +1,5 @@\n package logisticspipes.pipes.tubes;\n \n-import java.io.IOException;\n import java.util.List;\n \n import net.minecraft.entity.player.EntityPlayer;\n@@ -36,45 +35,6 @@\n \n public class HSTubeSpeedup extends CoreMultiBlockPipe {\n \n-\t@AllArgsConstructor\n-\tpublic enum SpeedupDirection implements ITubeRenderOrientation, ITubeOrientation {\n-\t\t//@formatter:off\n-\t\tNORTH(ForgeDirection.NORTH),\n-\t\tSOUTH(ForgeDirection.SOUTH),\n-\t\tEAST(ForgeDirection.EAST),\n-\t\tWEST(ForgeDirection.WEST);\n-\t\t//@formatter:on\n-\t\t@Getter\n-\t\tForgeDirection dir1;\n-\n-\t\t@Override\n-\t\tpublic void rotatePositions(IPositionRotateble set) {\n-\t\t\tif (this == SOUTH) {\n-\t\t\t\tset.rotateLeft();\n-\t\t\t\tset.rotateLeft();\n-\t\t\t} else if (this == EAST) {\n-\t\t\t\tset.rotateRight();\n-\t\t\t} else if (this == WEST) {\n-\t\t\t\tset.rotateLeft();\n-\t\t\t}\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic ITubeRenderOrientation getRenderOrientation() {\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic DoubleCoordinates getOffset() {\n-\t\t\treturn new DoubleCoordinates(0, 0, 0);\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void setOnPipe(CoreMultiBlockPipe pipe) {\n-\t\t\t((HSTubeSpeedup) pipe).orientation = this;\n-\t\t}\n-\t}\n-\n \t@Getter\n \tprivate SpeedupDirection orientation;\n \n@@ -115,12 +75,12 @@ protected void handleTileReachedClient(LPTravelingItemClient arrivingItem, TileE\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\toutput.writeEnum(orientation);\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\torientation = input.readEnum(SpeedupDirection.class);\n \t}\n \n@@ -309,4 +269,43 @@ public boolean canPipeConnect(TileEntity tile, ForgeDirection side) {\n \tpublic boolean isHSTube() {\n \t\treturn true;\n \t}\n+\n+\t@AllArgsConstructor\n+\tpublic enum SpeedupDirection implements ITubeRenderOrientation, ITubeOrientation {\n+\t\t//@formatter:off\n+\t\tNORTH(ForgeDirection.NORTH),\n+\t\tSOUTH(ForgeDirection.SOUTH),\n+\t\tEAST(ForgeDirection.EAST),\n+\t\tWEST(ForgeDirection.WEST);\n+\t\t//@formatter:on\n+\t\t@Getter\n+\t\tForgeDirection dir1;\n+\n+\t\t@Override\n+\t\tpublic void rotatePositions(IPositionRotateble set) {\n+\t\t\tif (this == SOUTH) {\n+\t\t\t\tset.rotateLeft();\n+\t\t\t\tset.rotateLeft();\n+\t\t\t} else if (this == EAST) {\n+\t\t\t\tset.rotateRight();\n+\t\t\t} else if (this == WEST) {\n+\t\t\t\tset.rotateLeft();\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic ITubeRenderOrientation getRenderOrientation() {\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic DoubleCoordinates getOffset() {\n+\t\t\treturn new DoubleCoordinates(0, 0, 0);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void setOnPipe(CoreMultiBlockPipe pipe) {\n+\t\t\t((HSTubeSpeedup) pipe).orientation = this;\n+\t\t}\n+\t}\n }",
    "function_modified_lines": {
      "added": [],
      "deleted": [
        "\t@AllArgsConstructor\n",
        "\tpublic enum SpeedupDirection implements ITubeRenderOrientation, ITubeOrientation {\n",
        "\t\t//@formatter:off\n",
        "\t\tNORTH(ForgeDirection.NORTH),\n",
        "\t\tSOUTH(ForgeDirection.SOUTH),\n",
        "\t\tEAST(ForgeDirection.EAST),\n",
        "\t\tWEST(ForgeDirection.WEST);\n",
        "\t\t//@formatter:on\n",
        "\t\t@Getter\n",
        "\t\tForgeDirection dir1;\n",
        "\n",
        "\t\t@Override\n",
        "\t\tpublic void rotatePositions(IPositionRotateble set) {\n",
        "\t\t\tif (this == SOUTH) {\n",
        "\t\t\t\tset.rotateLeft();\n",
        "\t\t\t\tset.rotateLeft();\n",
        "\t\t\t} else if (this == EAST) {\n",
        "\t\t\t\tset.rotateRight();\n",
        "\t\t\t} else if (this == WEST) {\n",
        "\t\t\t\tset.rotateLeft();\n",
        "\t\t\t}\n",
        "\t\t}\n",
        "\n",
        "\t\t@Override\n",
        "\t\tpublic ITubeRenderOrientation getRenderOrientation() {\n",
        "\t\t\treturn this;\n",
        "\t\t}\n",
        "\n",
        "\t\t@Override\n",
        "\t\tpublic DoubleCoordinates getOffset() {\n",
        "\t\t\treturn new DoubleCoordinates(0, 0, 0);\n",
        "\t\t}\n",
        "\n",
        "\t\t@Override\n",
        "\t\tpublic void setOnPipe(CoreMultiBlockPipe pipe) {\n",
        "\t\t\t((HSTubeSpeedup) pipe).orientation = this;\n",
        "\t\t}\n",
        "\t}\n",
        "\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12834
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "{\n\n\tpublic PipeItemsBasicTransport(Item item) {\n\t\tsuper(new PipeTransportLogistics(false), item);\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {}\n\n\t@Override\n\tpublic int getIconIndex(ForgeDirection direction) {\n\t\treturn Textures.LOGISTICSPIPE_BASIC_TRANSPORT_TEXTURE.normal;\n\t}\n\n\t@Override\n\tpublic int getTextureIndex() {\n\t\treturn Textures.LOGISTICSPIPE_BASIC_TRANSPORT_TEXTURE.newTexture;\n\t}\n\n\t@Override\n\tpublic IHighlightPlacementRenderer getHighlightRenderer() {\n\t\treturn LogisticsRenderPipe.secondRenderer;\n\t}\n}",
    "code_after_change": "{\n\n\tpublic PipeItemsBasicTransport(Item item) {\n\t\tsuper(new PipeTransportLogistics(false), item);\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {}\n\n\t@Override\n\tpublic int getIconIndex(ForgeDirection direction) {\n\t\treturn Textures.LOGISTICSPIPE_BASIC_TRANSPORT_TEXTURE.normal;\n\t}\n\n\t@Override\n\tpublic int getTextureIndex() {\n\t\treturn Textures.LOGISTICSPIPE_BASIC_TRANSPORT_TEXTURE.newTexture;\n\t}\n\n\t@Override\n\tpublic IHighlightPlacementRenderer getHighlightRenderer() {\n\t\treturn LogisticsRenderPipe.secondRenderer;\n\t}\n}",
    "patch": "@@ -1,7 +1,5 @@\n package logisticspipes.pipes.unrouted;\n \n-import java.io.IOException;\n-\n import net.minecraft.item.Item;\n import net.minecraftforge.common.util.ForgeDirection;\n \n@@ -20,10 +18,10 @@ public PipeItemsBasicTransport(Item item) {\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {}\n+\tpublic void writeData(LPDataOutput output) {}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {}\n+\tpublic void readData(LPDataInput input) {}\n \n \t@Override\n \tpublic int getIconIndex(ForgeDirection direction) {",
    "function_modified_lines": {
      "added": [
        "\tpublic void writeData(LPDataOutput output) {}\n",
        "\tpublic void readData(LPDataInput input) {}\n"
      ],
      "deleted": [
        "\tpublic void writeData(LPDataOutput output) throws IOException {}\n",
        "\tpublic void readData(LPDataInput input) throws IOException {}\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12836
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "{\n\n\tprivate int mask = 0;\n\tprivate int isBCPipeMask = 0;\n\tprivate int isTDPipeMask = 0;\n\tprivate boolean dirty = false;\n\n\tpublic boolean isConnected(ForgeDirection direction) {\n\t\t// test if the direction.ordinal()'th bit of mask is set\n\t\treturn (mask & (1 << direction.ordinal())) != 0;\n\t}\n\n\tpublic void setConnected(ForgeDirection direction, boolean value) {\n\t\tif (isConnected(direction) != value) {\n\t\t\t// invert the direction.ordinal()'th bit of mask\n\t\t\tmask ^= 1 << direction.ordinal();\n\t\t\tdirty = true;\n\t\t}\n\t\tif (!value) {\n\t\t\tsetBCConnected(direction, false);\n\t\t\tsetTDConnected(direction, false);\n\t\t}\n\t}\n\n\tpublic boolean isBCConnected(ForgeDirection direction) {\n\t\t// test if the direction.ordinal()'th bit of mask is set\n\t\treturn (isBCPipeMask & (1 << direction.ordinal())) != 0;\n\t}\n\n\tpublic void setBCConnected(ForgeDirection direction, boolean value) {\n\t\tif (isBCConnected(direction) != value) {\n\t\t\t// invert the direction.ordinal()'th bit of mask\n\t\t\tisBCPipeMask ^= 1 << direction.ordinal();\n\t\t\tdirty = true;\n\t\t}\n\t}\n\n\tpublic boolean isTDConnected(ForgeDirection direction) {\n\t\t// test if the direction.ordinal()'th bit of mask is set\n\t\treturn (isTDPipeMask & (1 << direction.ordinal())) != 0;\n\t}\n\n\tpublic void setTDConnected(ForgeDirection direction, boolean value) {\n\t\tif (isTDConnected(direction) != value) {\n\t\t\t// invert the direction.ordinal()'th bit of mask\n\t\t\tisTDPipeMask ^= 1 << direction.ordinal();\n\t\t\tdirty = true;\n\t\t}\n\t}\n\n\t/**\n\t * Return a mask representing the connectivity for all sides.\n\t *\n\t * @return mask in ForgeDirection order, least significant bit = first entry\n\t */\n\tpublic int getMask() {\n\t\treturn mask;\n\t}\n\n\tpublic boolean isDirty() {\n\t\treturn dirty;\n\t}\n\n\tpublic void clean() {\n\t\tdirty = false;\n\t}\n\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\toutput.writeByte(mask);\n\t\toutput.writeByte(isBCPipeMask);\n\t\toutput.writeByte(isTDPipeMask);\n\t}\n\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tbyte newMask = input.readByte();\n\n\t\tif (newMask != mask) {\n\t\t\tmask = newMask;\n\t\t\tdirty = true;\n\t\t}\n\n\t\tnewMask = input.readByte();\n\t\tif (newMask != isBCPipeMask) {\n\t\t\tisBCPipeMask = newMask;\n\t\t\tdirty = true;\n\t\t}\n\n\t\tnewMask = input.readByte();\n\t\tif (newMask != isTDPipeMask) {\n\t\t\tisTDPipeMask = newMask;\n\t\t\tdirty = true;\n\t\t}\n\t}\n}",
    "code_after_change": "{\n\n\tprivate int mask = 0;\n\tprivate int isBCPipeMask = 0;\n\tprivate int isTDPipeMask = 0;\n\tprivate boolean dirty = false;\n\n\tpublic boolean isConnected(ForgeDirection direction) {\n\t\t// test if the direction.ordinal()'th bit of mask is set\n\t\treturn (mask & (1 << direction.ordinal())) != 0;\n\t}\n\n\tpublic void setConnected(ForgeDirection direction, boolean value) {\n\t\tif (isConnected(direction) != value) {\n\t\t\t// invert the direction.ordinal()'th bit of mask\n\t\t\tmask ^= 1 << direction.ordinal();\n\t\t\tdirty = true;\n\t\t}\n\t\tif (!value) {\n\t\t\tsetBCConnected(direction, false);\n\t\t\tsetTDConnected(direction, false);\n\t\t}\n\t}\n\n\tpublic boolean isBCConnected(ForgeDirection direction) {\n\t\t// test if the direction.ordinal()'th bit of mask is set\n\t\treturn (isBCPipeMask & (1 << direction.ordinal())) != 0;\n\t}\n\n\tpublic void setBCConnected(ForgeDirection direction, boolean value) {\n\t\tif (isBCConnected(direction) != value) {\n\t\t\t// invert the direction.ordinal()'th bit of mask\n\t\t\tisBCPipeMask ^= 1 << direction.ordinal();\n\t\t\tdirty = true;\n\t\t}\n\t}\n\n\tpublic boolean isTDConnected(ForgeDirection direction) {\n\t\t// test if the direction.ordinal()'th bit of mask is set\n\t\treturn (isTDPipeMask & (1 << direction.ordinal())) != 0;\n\t}\n\n\tpublic void setTDConnected(ForgeDirection direction, boolean value) {\n\t\tif (isTDConnected(direction) != value) {\n\t\t\t// invert the direction.ordinal()'th bit of mask\n\t\t\tisTDPipeMask ^= 1 << direction.ordinal();\n\t\t\tdirty = true;\n\t\t}\n\t}\n\n\t/**\n\t * Return a mask representing the connectivity for all sides.\n\t *\n\t * @return mask in ForgeDirection order, least significant bit = first entry\n\t */\n\tpublic int getMask() {\n\t\treturn mask;\n\t}\n\n\tpublic boolean isDirty() {\n\t\treturn dirty;\n\t}\n\n\tpublic void clean() {\n\t\tdirty = false;\n\t}\n\n\tpublic void writeData(LPDataOutput output) {\n\t\toutput.writeByte(mask);\n\t\toutput.writeByte(isBCPipeMask);\n\t\toutput.writeByte(isTDPipeMask);\n\t}\n\n\tpublic void readData(LPDataInput input) {\n\t\tbyte newMask = input.readByte();\n\n\t\tif (newMask != mask) {\n\t\t\tmask = newMask;\n\t\t\tdirty = true;\n\t\t}\n\n\t\tnewMask = input.readByte();\n\t\tif (newMask != isBCPipeMask) {\n\t\t\tisBCPipeMask = newMask;\n\t\t\tdirty = true;\n\t\t}\n\n\t\tnewMask = input.readByte();\n\t\tif (newMask != isTDPipeMask) {\n\t\t\tisTDPipeMask = newMask;\n\t\t\tdirty = true;\n\t\t}\n\t}\n}",
    "patch": "@@ -1,7 +1,5 @@\n package logisticspipes.renderer.state;\n \n-import java.io.IOException;\n-\n import net.minecraftforge.common.util.ForgeDirection;\n \n import network.rs485.logisticspipes.util.LPDataInput;\n@@ -74,13 +72,13 @@ public void clean() {\n \t\tdirty = false;\n \t}\n \n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\toutput.writeByte(mask);\n \t\toutput.writeByte(isBCPipeMask);\n \t\toutput.writeByte(isTDPipeMask);\n \t}\n \n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tbyte newMask = input.readByte();\n \n \t\tif (newMask != mask) {",
    "function_modified_lines": {
      "added": [
        "\tpublic void writeData(LPDataOutput output) {\n",
        "\tpublic void readData(LPDataInput input) {\n"
      ],
      "deleted": [
        "\tpublic void writeData(LPDataOutput output) throws IOException {\n",
        "\tpublic void readData(LPDataInput input) throws IOException {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12837
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "package logisticspipes.request.resources;\n\nimport java.io.IOException;\n\nimport network.rs485.logisticspipes.util.LPDataInput;\nimport network.rs485.logisticspipes.util.LPDataOutput;\n\npublic enum ResourceNetwork {\n\tDictResource(DictResource.class) {\n\t\t@Override\n\t\tprotected IResource readData(LPDataInput input) throws IOException {\n\t\t\treturn new DictResource(input);\n\t\t}\n\t},\n\tItemResource(ItemResource.class) {\n\t\t@Override\n\t\tprotected IResource readData(LPDataInput input) throws IOException {\n\t\t\treturn new ItemResource(input);\n\t\t}\n\t},\n\tFluidResource(FluidResource.class) {\n\t\t@Override\n\t\tprotected IResource readData(LPDataInput input) throws IOException {\n\t\t\treturn new FluidResource(input);\n\t\t}\n\t};\n\n\tprivate final Class<? extends IResource> clazz;\n\n\tResourceNetwork(Class<? extends IResource> clazz) {\n\t\tthis.clazz = clazz;\n\t}\n\n\tpublic static void writeResource(LPDataOutput output, IResource resource) throws IOException {\n\t\tif (resource == null) {\n\t\t\toutput.writeInt(-1);\n\t\t\treturn;\n\t\t}\n\t\tResourceNetwork[] values = ResourceNetwork.values();\n\t\tfor (ResourceNetwork value : values) {\n\t\t\tif (value.clazz.isAssignableFrom(resource.getClass())) {\n\t\t\t\toutput.writeInt(value.ordinal());\n\t\t\t\tresource.writeData(output);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tthrow new UnsupportedOperationException(resource.getClass().toString());\n\t}\n\n\tpublic static IResource readResource(LPDataInput input) throws IOException {\n\t\tint id = input.readInt();\n\t\tif (id == -1) {\n\t\t\treturn null;\n\t\t}\n\t\treturn ResourceNetwork.values()[id].readData(input);\n\t}\n\n\tprotected abstract IResource readData(LPDataInput input) throws IOException;\n}\n",
    "code_after_change": "{\n\tDictResource(DictResource.class) {\n\t\t@Override\n\t\tprotected IResource readData(LPDataInput input) {\n\t\t\treturn new DictResource(input);\n\t\t}\n\t},\n\tItemResource(ItemResource.class) {\n\t\t@Override\n\t\tprotected IResource readData(LPDataInput input) {\n\t\t\treturn new ItemResource(input);\n\t\t}\n\t},\n\tFluidResource(FluidResource.class) {\n\t\t@Override\n\t\tprotected IResource readData(LPDataInput input) {\n\t\t\treturn new FluidResource(input);\n\t\t}\n\t};\n\n\tprivate final Class<? extends IResource> clazz;\n\n\tResourceNetwork(Class<? extends IResource> clazz) {\n\t\tthis.clazz = clazz;\n\t}\n\n\tpublic static void writeResource(LPDataOutput output, IResource resource) {\n\t\tif (resource == null) {\n\t\t\toutput.writeInt(-1);\n\t\t\treturn;\n\t\t}\n\t\tResourceNetwork[] values = ResourceNetwork.values();\n\t\tfor (ResourceNetwork value : values) {\n\t\t\tif (value.clazz.isAssignableFrom(resource.getClass())) {\n\t\t\t\toutput.writeInt(value.ordinal());\n\t\t\t\tresource.writeData(output);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tthrow new UnsupportedOperationException(resource.getClass().toString());\n\t}\n\n\tpublic static IResource readResource(LPDataInput input) {\n\t\tint id = input.readInt();\n\t\tif (id == -1) {\n\t\t\treturn null;\n\t\t}\n\t\treturn ResourceNetwork.values()[id].readData(input);\n\t}\n\n\tprotected abstract IResource readData(LPDataInput input);\n}",
    "patch": "@@ -1,26 +1,24 @@\n package logisticspipes.request.resources;\n \n-import java.io.IOException;\n-\n import network.rs485.logisticspipes.util.LPDataInput;\n import network.rs485.logisticspipes.util.LPDataOutput;\n \n public enum ResourceNetwork {\n \tDictResource(DictResource.class) {\n \t\t@Override\n-\t\tprotected IResource readData(LPDataInput input) throws IOException {\n+\t\tprotected IResource readData(LPDataInput input) {\n \t\t\treturn new DictResource(input);\n \t\t}\n \t},\n \tItemResource(ItemResource.class) {\n \t\t@Override\n-\t\tprotected IResource readData(LPDataInput input) throws IOException {\n+\t\tprotected IResource readData(LPDataInput input) {\n \t\t\treturn new ItemResource(input);\n \t\t}\n \t},\n \tFluidResource(FluidResource.class) {\n \t\t@Override\n-\t\tprotected IResource readData(LPDataInput input) throws IOException {\n+\t\tprotected IResource readData(LPDataInput input) {\n \t\t\treturn new FluidResource(input);\n \t\t}\n \t};\n@@ -31,7 +29,7 @@ protected IResource readData(LPDataInput input) throws IOException {\n \t\tthis.clazz = clazz;\n \t}\n \n-\tpublic static void writeResource(LPDataOutput output, IResource resource) throws IOException {\n+\tpublic static void writeResource(LPDataOutput output, IResource resource) {\n \t\tif (resource == null) {\n \t\t\toutput.writeInt(-1);\n \t\t\treturn;\n@@ -47,13 +45,13 @@ public static void writeResource(LPDataOutput output, IResource resource) throws\n \t\tthrow new UnsupportedOperationException(resource.getClass().toString());\n \t}\n \n-\tpublic static IResource readResource(LPDataInput input) throws IOException {\n+\tpublic static IResource readResource(LPDataInput input) {\n \t\tint id = input.readInt();\n \t\tif (id == -1) {\n \t\t\treturn null;\n \t\t}\n \t\treturn ResourceNetwork.values()[id].readData(input);\n \t}\n \n-\tprotected abstract IResource readData(LPDataInput input) throws IOException;\n+\tprotected abstract IResource readData(LPDataInput input);\n }",
    "function_modified_lines": {
      "added": [
        "\t\tprotected IResource readData(LPDataInput input) {\n",
        "\t\tprotected IResource readData(LPDataInput input) {\n",
        "\t\tprotected IResource readData(LPDataInput input) {\n",
        "\tpublic static void writeResource(LPDataOutput output, IResource resource) {\n"
      ],
      "deleted": [
        "import java.io.IOException;\n",
        "\n",
        "\t\tprotected IResource readData(LPDataInput input) throws IOException {\n",
        "\t\tprotected IResource readData(LPDataInput input) throws IOException {\n",
        "\t\tprotected IResource readData(LPDataInput input) throws IOException {\n",
        "\tpublic static void writeResource(LPDataOutput output, IResource resource) throws IOException {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12838
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "{\n\tDictResource(DictResource.class) {\n\t\t@Override\n\t\tprotected IResource readData(LPDataInput input) throws IOException {\n\t\t\treturn new DictResource(input);\n\t\t}\n\t},\n\tItemResource(ItemResource.class) {\n\t\t@Override\n\t\tprotected IResource readData(LPDataInput input) throws IOException {\n\t\t\treturn new ItemResource(input);\n\t\t}\n\t},\n\tFluidResource(FluidResource.class) {\n\t\t@Override\n\t\tprotected IResource readData(LPDataInput input) throws IOException {\n\t\t\treturn new FluidResource(input);\n\t\t}\n\t};\n\n\tprivate final Class<? extends IResource> clazz;\n\n\tResourceNetwork(Class<? extends IResource> clazz) {\n\t\tthis.clazz = clazz;\n\t}\n\n\tpublic static void writeResource(LPDataOutput output, IResource resource) throws IOException {\n\t\tif (resource == null) {\n\t\t\toutput.writeInt(-1);\n\t\t\treturn;\n\t\t}\n\t\tResourceNetwork[] values = ResourceNetwork.values();\n\t\tfor (ResourceNetwork value : values) {\n\t\t\tif (value.clazz.isAssignableFrom(resource.getClass())) {\n\t\t\t\toutput.writeInt(value.ordinal());\n\t\t\t\tresource.writeData(output);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tthrow new UnsupportedOperationException(resource.getClass().toString());\n\t}\n\n\tpublic static IResource readResource(LPDataInput input) throws IOException {\n\t\tint id = input.readInt();\n\t\tif (id == -1) {\n\t\t\treturn null;\n\t\t}\n\t\treturn ResourceNetwork.values()[id].readData(input);\n\t}\n\n\tprotected abstract IResource readData(LPDataInput input) throws IOException;\n}",
    "code_after_change": "{\n\tDictResource(DictResource.class) {\n\t\t@Override\n\t\tprotected IResource readData(LPDataInput input) {\n\t\t\treturn new DictResource(input);\n\t\t}\n\t},\n\tItemResource(ItemResource.class) {\n\t\t@Override\n\t\tprotected IResource readData(LPDataInput input) {\n\t\t\treturn new ItemResource(input);\n\t\t}\n\t},\n\tFluidResource(FluidResource.class) {\n\t\t@Override\n\t\tprotected IResource readData(LPDataInput input) {\n\t\t\treturn new FluidResource(input);\n\t\t}\n\t};\n\n\tprivate final Class<? extends IResource> clazz;\n\n\tResourceNetwork(Class<? extends IResource> clazz) {\n\t\tthis.clazz = clazz;\n\t}\n\n\tpublic static void writeResource(LPDataOutput output, IResource resource) {\n\t\tif (resource == null) {\n\t\t\toutput.writeInt(-1);\n\t\t\treturn;\n\t\t}\n\t\tResourceNetwork[] values = ResourceNetwork.values();\n\t\tfor (ResourceNetwork value : values) {\n\t\t\tif (value.clazz.isAssignableFrom(resource.getClass())) {\n\t\t\t\toutput.writeInt(value.ordinal());\n\t\t\t\tresource.writeData(output);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tthrow new UnsupportedOperationException(resource.getClass().toString());\n\t}\n\n\tpublic static IResource readResource(LPDataInput input) {\n\t\tint id = input.readInt();\n\t\tif (id == -1) {\n\t\t\treturn null;\n\t\t}\n\t\treturn ResourceNetwork.values()[id].readData(input);\n\t}\n\n\tprotected abstract IResource readData(LPDataInput input);\n}",
    "patch": "@@ -1,26 +1,24 @@\n package logisticspipes.request.resources;\n \n-import java.io.IOException;\n-\n import network.rs485.logisticspipes.util.LPDataInput;\n import network.rs485.logisticspipes.util.LPDataOutput;\n \n public enum ResourceNetwork {\n \tDictResource(DictResource.class) {\n \t\t@Override\n-\t\tprotected IResource readData(LPDataInput input) throws IOException {\n+\t\tprotected IResource readData(LPDataInput input) {\n \t\t\treturn new DictResource(input);\n \t\t}\n \t},\n \tItemResource(ItemResource.class) {\n \t\t@Override\n-\t\tprotected IResource readData(LPDataInput input) throws IOException {\n+\t\tprotected IResource readData(LPDataInput input) {\n \t\t\treturn new ItemResource(input);\n \t\t}\n \t},\n \tFluidResource(FluidResource.class) {\n \t\t@Override\n-\t\tprotected IResource readData(LPDataInput input) throws IOException {\n+\t\tprotected IResource readData(LPDataInput input) {\n \t\t\treturn new FluidResource(input);\n \t\t}\n \t};\n@@ -31,7 +29,7 @@ protected IResource readData(LPDataInput input) throws IOException {\n \t\tthis.clazz = clazz;\n \t}\n \n-\tpublic static void writeResource(LPDataOutput output, IResource resource) throws IOException {\n+\tpublic static void writeResource(LPDataOutput output, IResource resource) {\n \t\tif (resource == null) {\n \t\t\toutput.writeInt(-1);\n \t\t\treturn;\n@@ -47,13 +45,13 @@ public static void writeResource(LPDataOutput output, IResource resource) throws\n \t\tthrow new UnsupportedOperationException(resource.getClass().toString());\n \t}\n \n-\tpublic static IResource readResource(LPDataInput input) throws IOException {\n+\tpublic static IResource readResource(LPDataInput input) {\n \t\tint id = input.readInt();\n \t\tif (id == -1) {\n \t\t\treturn null;\n \t\t}\n \t\treturn ResourceNetwork.values()[id].readData(input);\n \t}\n \n-\tprotected abstract IResource readData(LPDataInput input) throws IOException;\n+\tprotected abstract IResource readData(LPDataInput input);\n }",
    "function_modified_lines": {
      "added": [
        "\tpublic static IResource readResource(LPDataInput input) {\n",
        "\tprotected abstract IResource readData(LPDataInput input);\n"
      ],
      "deleted": [
        "\tpublic static IResource readResource(LPDataInput input) throws IOException {\n",
        "\tprotected abstract IResource readData(LPDataInput input) throws IOException;\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12839
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "{\n\n\tprivate class ClientCompressorThread extends Thread {\n\n\t\t//list of C->S packets to be serialized and compressed\n\t\tprivate final LinkedList<ModernPacket> clientList = new LinkedList<>();\n\t\t//serialized but still uncompressed C->S data\n\t\tprivate byte[] clientBuffer = new byte[] {};\n\t\t//used to cork the compressor so we can queue up a whole bunch of packets at once\n\t\tprivate boolean pause = false;\n\t\t//Clear content on next tick\n\t\tprivate boolean clear = false;\n\n\t\tprivate Lock clearLock = new ReentrantLock();\n\n\t\tpublic ClientCompressorThread() {\n\t\t\tsuper(\"LogisticsPipes Packet Compressor Client\");\n\t\t\tsetDaemon(true);\n\t\t\tstart();\n\t\t}\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\twhile (true) {\n\t\t\t\ttry {\n\t\t\t\t\tsynchronized (clientList) {\n\t\t\t\t\t\tif (!pause && clientList.size() > 0) {\n\t\t\t\t\t\t\tclientBuffer = LPDataIOWrapper.collectData(output -> {\n\t\t\t\t\t\t\t\toutput.writeBytes(clientBuffer);\n\t\t\t\t\t\t\t\tclearLock.lock();\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tfor (ModernPacket packet : clientList) {\n\t\t\t\t\t\t\t\t\t\toutput.writeShort(packet.getId());\n\t\t\t\t\t\t\t\t\t\toutput.writeInt(packet.getDebugId());\n\t\t\t\t\t\t\t\t\t\tpacket.writeData(output);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\t\tclientList.clear();\n\t\t\t\t\t\t\t\t\tclearLock.unlock();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//Send Content\n\t\t\t\t\tif (clientBuffer.length > 0) {\n\t\t\t\t\t\twhile (clientBuffer.length > 1024 * 32) {\n\t\t\t\t\t\t\tbyte[] sendbuffer = Arrays.copyOf(clientBuffer, 1024 * 32);\n\t\t\t\t\t\t\tclientBuffer = Arrays.copyOfRange(clientBuffer, 1024 * 32, clientBuffer.length);\n\t\t\t\t\t\t\tbyte[] compressed = ClientPacketBufferHandlerThread.compress(sendbuffer);\n\t\t\t\t\t\t\tMainProxy.sendPacketToServer(PacketHandler.getPacket(BufferTransfer.class).setContent(compressed));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbyte[] sendbuffer = clientBuffer;\n\t\t\t\t\t\tclientBuffer = new byte[] {};\n\t\t\t\t\t\tbyte[] compressed = ClientPacketBufferHandlerThread.compress(sendbuffer);\n\t\t\t\t\t\tMainProxy.sendPacketToServer(PacketHandler.getPacket(BufferTransfer.class).setContent(compressed));\n\t\t\t\t\t}\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tsynchronized (clientList) {\n\t\t\t\t\twhile (pause || clientList.size() == 0) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tclientList.wait();\n\t\t\t\t\t\t} catch (InterruptedException e) {}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (clear) {\n\t\t\t\t\tclear = false;\n\t\t\t\t\tclientBuffer = new byte[] {};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic void addPacketToCompressor(ModernPacket packet) {\n\t\t\tsynchronized (clientList) {\n\t\t\t\tclientList.add(packet);\n\t\t\t\tif (!pause) {\n\t\t\t\t\tclientList.notify();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic void setPause(boolean flag) {\n\t\t\tsynchronized (clientList) {\n\t\t\t\tpause = flag;\n\t\t\t\tif (!pause) {\n\t\t\t\t\tclientList.notify();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic void clear() {\n\t\t\tclear = true;\n\t\t\tnew Thread() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\tclearLock.lock();\n\t\t\t\t\tclientList.clear();\n\t\t\t\t\tclearLock.unlock();\n\t\t\t\t}\n\t\t\t}.start();\n\t\t}\n\t}\n\n\tprivate final ClientCompressorThread clientCompressorThread = new ClientCompressorThread();\n\n\tprivate class ClientDecompressorThread extends Thread {\n\n\t\t//Received compressed S->C data\n\t\tprivate final LinkedList<byte[]> queue = new LinkedList<>();\n\t\t//decompressed serialized S->C data\n\t\tprivate byte[] ByteBuffer = new byte[] {};\n\t\t//FIFO for deserialized S->C packets, decompressor adds, tickEnd removes\n\t\tprivate final LinkedList<Pair<EntityPlayer, byte[]>> PacketBuffer = new LinkedList<>();\n\t\tprivate final ReentrantLock packetBufferLock = new ReentrantLock();\n\t\t//List of packets that that should be reattempted to apply in the next tick\n\t\tprivate final LinkedList<Pair<EntityPlayer, ModernPacket>> retryPackets = new LinkedList<>();\n\t\t//Clear content on next tick\n\t\tprivate boolean clear = false;\n\n\t\tpublic ClientDecompressorThread() {\n\t\t\tsuper(\"LogisticsPipes Packet Decompressor Client\");\n\t\t\tsetDaemon(true);\n\t\t\tstart();\n\t\t}\n\n\t\tprivate void handlePacketData(final Pair<EntityPlayer, byte[]> playerDataPair) {\n\t\t\ttry {\n\t\t\t\tLPDataIOWrapper.provideData(playerDataPair.getValue2(), input -> {\n\t\t\t\t\tPacketHandler.onPacketData(input, playerDataPair.getValue1());\n\t\t\t\t});\n\t\t\t} catch (IOException e) {\n\t\t\t\tSystem.err.println(\"IO Error in handlePacketData for player \" + playerDataPair.getValue1().getCommandSenderName());\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic void clientTickEnd() {\n\t\t\tPair<EntityPlayer, byte[]> part = null;\n\t\t\twhile (true) {\n\t\t\t\tpacketBufferLock.lock();\n\t\t\t\ttry {\n\t\t\t\t\tif (PacketBuffer.size() > 0) {\n\t\t\t\t\t\tpart = PacketBuffer.pop();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tpacketBufferLock.unlock();\n\t\t\t\t}\n\n\t\t\t\tif (part == null) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\thandlePacketData(part);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\twhile (true) {\n\t\t\t\tboolean flag;\n\t\t\t\tdo {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbyte[] buffer = null;\n\t\t\t\t\tsynchronized (queue) {\n\t\t\t\t\t\tif (queue.size() > 0) {\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\tbuffer = queue.getFirst();\n\t\t\t\t\t\t\tqueue.removeFirst();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (flag && buffer != null) {\n\t\t\t\t\t\tbyte[] packetbytes = ClientPacketBufferHandlerThread.decompress(buffer);\n\t\t\t\t\t\tbyte[] newBuffer = new byte[packetbytes.length + ByteBuffer.length];\n\t\t\t\t\t\tSystem.arraycopy(ByteBuffer, 0, newBuffer, 0, ByteBuffer.length);\n\t\t\t\t\t\tSystem.arraycopy(packetbytes, 0, newBuffer, ByteBuffer.length, packetbytes.length);\n\t\t\t\t\t\tByteBuffer = newBuffer;\n\t\t\t\t\t}\n\t\t\t\t} while (flag);\n\n\t\t\t\twhile (ByteBuffer.length >= 4) {\n\t\t\t\t\tint size = ((ByteBuffer[0] & 255) << 24) + ((ByteBuffer[1] & 255) << 16) + ((ByteBuffer[2] & 255) << 8) + ((ByteBuffer[3] & 255) << 0);\n\t\t\t\t\tif (size + 4 > ByteBuffer.length) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbyte[] packet = Arrays.copyOfRange(ByteBuffer, 4, size + 4);\n\t\t\t\t\tByteBuffer = Arrays.copyOfRange(ByteBuffer, size + 4, ByteBuffer.length);\n\t\t\t\t\tpacketBufferLock.lock();\n\t\t\t\t\ttry {\n\t\t\t\t\t\tPacketBuffer.add(new Pair<>(MainProxy.proxy.getClientPlayer(), packet));\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tpacketBufferLock.unlock();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsynchronized (queue) {\n\t\t\t\t\twhile (queue.size() == 0) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tqueue.wait();\n\t\t\t\t\t\t} catch (InterruptedException e) { }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (clear) {\n\t\t\t\t\tclear = false;\n\t\t\t\t\tByteBuffer = new byte[] {};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic void handlePacket(byte[] content) {\n\t\t\tsynchronized (queue) {\n\t\t\t\tqueue.addLast(content);\n\t\t\t\tqueue.notify();\n\t\t\t}\n\t\t}\n\n\t\tpublic void clear() {\n\t\t\tclear = true;\n\t\t\tqueue.clear();\n\t\t\tretryPackets.clear();\n\t\t}\n\n\t\tpublic void queueFailedPacket(ModernPacket packet, EntityPlayer player) {\n\t\t\tretryPackets.add(new Pair<>(player, packet));\n\t\t}\n\t}\n\n\tprivate final ClientDecompressorThread clientDecompressorThread = new ClientDecompressorThread();\n\n\tpublic ClientPacketBufferHandlerThread() {}\n\n\tpublic void clientTick(ClientTickEvent event) {\n\t\tif (event.phase != Phase.END) {\n\t\t\treturn;\n\t\t}\n\t\tclientDecompressorThread.clientTickEnd();\n\t}\n\n\tpublic void setPause(boolean flag) {\n\t\tclientCompressorThread.setPause(flag);\n\t}\n\n\tpublic void addPacketToCompressor(ModernPacket packet) {\n\t\tclientCompressorThread.addPacketToCompressor(packet);\n\t}\n\n\tpublic void handlePacket(byte[] content) {\n\t\tclientDecompressorThread.handlePacket(content);\n\t}\n\n\tprivate static byte[] compress(byte[] content) {\n\t\tByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n\t\ttry {\n\t\t\tGZIPOutputStream gzipOutputStream = new GZIPOutputStream(byteArrayOutputStream);\n\t\t\tgzipOutputStream.write(content);\n\t\t\tgzipOutputStream.close();\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t\treturn byteArrayOutputStream.toByteArray();\n\t}\n\n\tprivate static byte[] decompress(byte[] contentBytes) {\n\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n\t\ttry {\n\t\t\tGZIPInputStream gzip = new GZIPInputStream(new ByteArrayInputStream(contentBytes));\n\t\t\tint buffer = 0;\n\t\t\twhile ((buffer = gzip.read()) != -1) {\n\t\t\t\tout.write(buffer);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t\treturn out.toByteArray();\n\t}\n\n\tpublic void clear() {\n\t\tclientCompressorThread.clear();\n\t\tclientDecompressorThread.clear();\n\t}\n\n\tpublic void queueFailedPacket(ModernPacket packet, EntityPlayer player) {\n\t\tclientDecompressorThread.queueFailedPacket(packet, player);\n\t}\n}",
    "code_after_change": "package logisticspipes.ticks;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\nimport java.util.zip.GZIPInputStream;\nimport java.util.zip.GZIPOutputStream;\n\nimport net.minecraft.entity.player.EntityPlayer;\nimport cpw.mods.fml.common.gameevent.TickEvent.ClientTickEvent;\nimport cpw.mods.fml.common.gameevent.TickEvent.Phase;\n\nimport logisticspipes.network.PacketHandler;\nimport logisticspipes.network.abstractpackets.ModernPacket;\nimport logisticspipes.network.packets.BufferTransfer;\nimport logisticspipes.proxy.MainProxy;\nimport logisticspipes.utils.tuples.Pair;\nimport network.rs485.logisticspipes.util.LPDataIOWrapper;\n\npublic class ClientPacketBufferHandlerThread {\n\n\tprivate final ClientCompressorThread clientCompressorThread = new ClientCompressorThread();\n\tprivate final ClientDecompressorThread clientDecompressorThread = new ClientDecompressorThread();\n\n\tpublic ClientPacketBufferHandlerThread() {}\n\n\tprivate static byte[] compress(byte[] content) {\n\t\tByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n\t\ttry {\n\t\t\tGZIPOutputStream gzipOutputStream = new GZIPOutputStream(byteArrayOutputStream);\n\t\t\tgzipOutputStream.write(content);\n\t\t\tgzipOutputStream.close();\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t\treturn byteArrayOutputStream.toByteArray();\n\t}\n\n\tprivate static byte[] decompress(byte[] contentBytes) {\n\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n\t\ttry {\n\t\t\tGZIPInputStream gzip = new GZIPInputStream(new ByteArrayInputStream(contentBytes));\n\t\t\tint buffer = 0;\n\t\t\twhile ((buffer = gzip.read()) != -1) {\n\t\t\t\tout.write(buffer);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t\treturn out.toByteArray();\n\t}\n\n\tpublic void clientTick(ClientTickEvent event) {\n\t\tif (event.phase != Phase.END) {\n\t\t\treturn;\n\t\t}\n\t\tclientDecompressorThread.clientTickEnd();\n\t}\n\n\tpublic void setPause(boolean flag) {\n\t\tclientCompressorThread.setPause(flag);\n\t}\n\n\tpublic void addPacketToCompressor(ModernPacket packet) {\n\t\tclientCompressorThread.addPacketToCompressor(packet);\n\t}\n\n\tpublic void handlePacket(byte[] content) {\n\t\tclientDecompressorThread.handlePacket(content);\n\t}\n\n\tpublic void clear() {\n\t\tclientCompressorThread.clear();\n\t\tclientDecompressorThread.clear();\n\t}\n\n\tpublic void queueFailedPacket(ModernPacket packet, EntityPlayer player) {\n\t\tclientDecompressorThread.queueFailedPacket(packet, player);\n\t}\n\n\tprivate class ClientCompressorThread extends Thread {\n\n\t\t//list of C->S packets to be serialized and compressed\n\t\tprivate final LinkedList<ModernPacket> clientList = new LinkedList<>();\n\t\t//serialized but still uncompressed C->S data\n\t\tprivate byte[] clientBuffer = new byte[] {};\n\t\t//used to cork the compressor so we can queue up a whole bunch of packets at once\n\t\tprivate boolean pause = false;\n\t\t//Clear content on next tick\n\t\tprivate boolean clear = false;\n\n\t\tprivate Lock clearLock = new ReentrantLock();\n\n\t\tpublic ClientCompressorThread() {\n\t\t\tsuper(\"LogisticsPipes Packet Compressor Client\");\n\t\t\tsetDaemon(true);\n\t\t\tstart();\n\t\t}\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\twhile (true) {\n\t\t\t\tsynchronized (clientList) {\n\t\t\t\t\tif (!pause && clientList.size() > 0) {\n\t\t\t\t\t\tclientBuffer = LPDataIOWrapper.collectData(output -> {\n\t\t\t\t\t\t\toutput.writeBytes(clientBuffer);\n\t\t\t\t\t\t\tclearLock.lock();\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tfor (ModernPacket packet : clientList) {\n\t\t\t\t\t\t\t\t\toutput.writeShort(packet.getId());\n\t\t\t\t\t\t\t\t\toutput.writeInt(packet.getDebugId());\n\t\t\t\t\t\t\t\t\tpacket.writeData(output);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\tclientList.clear();\n\t\t\t\t\t\t\t\tclearLock.unlock();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//Send Content\n\t\t\t\tif (clientBuffer.length > 0) {\n\t\t\t\t\twhile (clientBuffer.length > 1024 * 32) {\n\t\t\t\t\t\tbyte[] sendbuffer = Arrays.copyOf(clientBuffer, 1024 * 32);\n\t\t\t\t\t\tclientBuffer = Arrays.copyOfRange(clientBuffer, 1024 * 32, clientBuffer.length);\n\t\t\t\t\t\tbyte[] compressed = ClientPacketBufferHandlerThread.compress(sendbuffer);\n\t\t\t\t\t\tMainProxy.sendPacketToServer(PacketHandler.getPacket(BufferTransfer.class).setContent(compressed));\n\t\t\t\t\t}\n\t\t\t\t\tbyte[] sendbuffer = clientBuffer;\n\t\t\t\t\tclientBuffer = new byte[] {};\n\t\t\t\t\tbyte[] compressed = ClientPacketBufferHandlerThread.compress(sendbuffer);\n\t\t\t\t\tMainProxy.sendPacketToServer(PacketHandler.getPacket(BufferTransfer.class).setContent(compressed));\n\t\t\t\t}\n\t\t\t\tsynchronized (clientList) {\n\t\t\t\t\twhile (pause || clientList.size() == 0) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tclientList.wait();\n\t\t\t\t\t\t} catch (InterruptedException ignored) { }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (clear) {\n\t\t\t\t\tclear = false;\n\t\t\t\t\tclientBuffer = new byte[] {};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic void addPacketToCompressor(ModernPacket packet) {\n\t\t\tsynchronized (clientList) {\n\t\t\t\tclientList.add(packet);\n\t\t\t\tif (!pause) {\n\t\t\t\t\tclientList.notify();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic void setPause(boolean flag) {\n\t\t\tsynchronized (clientList) {\n\t\t\t\tpause = flag;\n\t\t\t\tif (!pause) {\n\t\t\t\t\tclientList.notify();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic void clear() {\n\t\t\tclear = true;\n\t\t\tnew Thread() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\tclearLock.lock();\n\t\t\t\t\tclientList.clear();\n\t\t\t\t\tclearLock.unlock();\n\t\t\t\t}\n\t\t\t}.start();\n\t\t}\n\t}\n\n\tprivate class ClientDecompressorThread extends Thread {\n\n\t\t//Received compressed S->C data\n\t\tprivate final LinkedList<byte[]> queue = new LinkedList<>();\n\t\t//FIFO for deserialized S->C packets, decompressor adds, tickEnd removes\n\t\tprivate final LinkedList<Pair<EntityPlayer, byte[]>> PacketBuffer = new LinkedList<>();\n\t\tprivate final ReentrantLock packetBufferLock = new ReentrantLock();\n\t\t//List of packets that that should be reattempted to apply in the next tick\n\t\tprivate final LinkedList<Pair<EntityPlayer, ModernPacket>> retryPackets = new LinkedList<>();\n\t\t//decompressed serialized S->C data\n\t\tprivate byte[] ByteBuffer = new byte[] {};\n\t\t//Clear content on next tick\n\t\tprivate boolean clear = false;\n\n\t\tpublic ClientDecompressorThread() {\n\t\t\tsuper(\"LogisticsPipes Packet Decompressor Client\");\n\t\t\tsetDaemon(true);\n\t\t\tstart();\n\t\t}\n\n\t\tprivate void handlePacketData(final Pair<EntityPlayer, byte[]> playerDataPair) {\n\t\t\tLPDataIOWrapper.provideData(playerDataPair.getValue2(), input -> {\n\t\t\t\tPacketHandler.onPacketData(input, playerDataPair.getValue1());\n\t\t\t});\n\t\t}\n\n\t\tpublic void clientTickEnd() {\n\t\t\tPair<EntityPlayer, byte[]> part = null;\n\t\t\twhile (true) {\n\t\t\t\tpacketBufferLock.lock();\n\t\t\t\ttry {\n\t\t\t\t\tif (PacketBuffer.size() > 0) {\n\t\t\t\t\t\tpart = PacketBuffer.pop();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tpacketBufferLock.unlock();\n\t\t\t\t}\n\n\t\t\t\tif (part == null) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\thandlePacketData(part);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\twhile (true) {\n\t\t\t\tboolean flag;\n\t\t\t\tdo {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbyte[] buffer = null;\n\t\t\t\t\tsynchronized (queue) {\n\t\t\t\t\t\tif (queue.size() > 0) {\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\tbuffer = queue.getFirst();\n\t\t\t\t\t\t\tqueue.removeFirst();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (flag && buffer != null) {\n\t\t\t\t\t\tbyte[] packetbytes = ClientPacketBufferHandlerThread.decompress(buffer);\n\t\t\t\t\t\tbyte[] newBuffer = new byte[packetbytes.length + ByteBuffer.length];\n\t\t\t\t\t\tSystem.arraycopy(ByteBuffer, 0, newBuffer, 0, ByteBuffer.length);\n\t\t\t\t\t\tSystem.arraycopy(packetbytes, 0, newBuffer, ByteBuffer.length, packetbytes.length);\n\t\t\t\t\t\tByteBuffer = newBuffer;\n\t\t\t\t\t}\n\t\t\t\t} while (flag);\n\n\t\t\t\twhile (ByteBuffer.length >= 4) {\n\t\t\t\t\tint size = ((ByteBuffer[0] & 255) << 24) + ((ByteBuffer[1] & 255) << 16) + ((ByteBuffer[2] & 255) << 8) + ((ByteBuffer[3] & 255) << 0);\n\t\t\t\t\tif (size + 4 > ByteBuffer.length) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbyte[] packet = Arrays.copyOfRange(ByteBuffer, 4, size + 4);\n\t\t\t\t\tByteBuffer = Arrays.copyOfRange(ByteBuffer, size + 4, ByteBuffer.length);\n\t\t\t\t\tpacketBufferLock.lock();\n\t\t\t\t\ttry {\n\t\t\t\t\t\tPacketBuffer.add(new Pair<>(MainProxy.proxy.getClientPlayer(), packet));\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tpacketBufferLock.unlock();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsynchronized (queue) {\n\t\t\t\t\twhile (queue.size() == 0) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tqueue.wait();\n\t\t\t\t\t\t} catch (InterruptedException ignored) { }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (clear) {\n\t\t\t\t\tclear = false;\n\t\t\t\t\tByteBuffer = new byte[] {};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic void handlePacket(byte[] content) {\n\t\t\tsynchronized (queue) {\n\t\t\t\tqueue.addLast(content);\n\t\t\t\tqueue.notify();\n\t\t\t}\n\t\t}\n\n\t\tpublic void clear() {\n\t\t\tclear = true;\n\t\t\tqueue.clear();\n\t\t\tretryPackets.clear();\n\t\t}\n\n\t\tpublic void queueFailedPacket(ModernPacket packet, EntityPlayer player) {\n\t\t\tretryPackets.add(new Pair<>(player, packet));\n\t\t}\n\t}\n}\n",
    "patch": "@@ -23,6 +23,65 @@\n \n public class ClientPacketBufferHandlerThread {\n \n+\tprivate final ClientCompressorThread clientCompressorThread = new ClientCompressorThread();\n+\tprivate final ClientDecompressorThread clientDecompressorThread = new ClientDecompressorThread();\n+\n+\tpublic ClientPacketBufferHandlerThread() {}\n+\n+\tprivate static byte[] compress(byte[] content) {\n+\t\tByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n+\t\ttry {\n+\t\t\tGZIPOutputStream gzipOutputStream = new GZIPOutputStream(byteArrayOutputStream);\n+\t\t\tgzipOutputStream.write(content);\n+\t\t\tgzipOutputStream.close();\n+\t\t} catch (IOException e) {\n+\t\t\tthrow new RuntimeException(e);\n+\t\t}\n+\t\treturn byteArrayOutputStream.toByteArray();\n+\t}\n+\n+\tprivate static byte[] decompress(byte[] contentBytes) {\n+\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n+\t\ttry {\n+\t\t\tGZIPInputStream gzip = new GZIPInputStream(new ByteArrayInputStream(contentBytes));\n+\t\t\tint buffer = 0;\n+\t\t\twhile ((buffer = gzip.read()) != -1) {\n+\t\t\t\tout.write(buffer);\n+\t\t\t}\n+\t\t} catch (IOException e) {\n+\t\t\tthrow new RuntimeException(e);\n+\t\t}\n+\t\treturn out.toByteArray();\n+\t}\n+\n+\tpublic void clientTick(ClientTickEvent event) {\n+\t\tif (event.phase != Phase.END) {\n+\t\t\treturn;\n+\t\t}\n+\t\tclientDecompressorThread.clientTickEnd();\n+\t}\n+\n+\tpublic void setPause(boolean flag) {\n+\t\tclientCompressorThread.setPause(flag);\n+\t}\n+\n+\tpublic void addPacketToCompressor(ModernPacket packet) {\n+\t\tclientCompressorThread.addPacketToCompressor(packet);\n+\t}\n+\n+\tpublic void handlePacket(byte[] content) {\n+\t\tclientDecompressorThread.handlePacket(content);\n+\t}\n+\n+\tpublic void clear() {\n+\t\tclientCompressorThread.clear();\n+\t\tclientDecompressorThread.clear();\n+\t}\n+\n+\tpublic void queueFailedPacket(ModernPacket packet, EntityPlayer player) {\n+\t\tclientDecompressorThread.queueFailedPacket(packet, player);\n+\t}\n+\n \tprivate class ClientCompressorThread extends Thread {\n \n \t\t//list of C->S packets to be serialized and compressed\n@@ -45,46 +104,42 @@ public ClientCompressorThread() {\n \t\t@Override\n \t\tpublic void run() {\n \t\t\twhile (true) {\n-\t\t\t\ttry {\n-\t\t\t\t\tsynchronized (clientList) {\n-\t\t\t\t\t\tif (!pause && clientList.size() > 0) {\n-\t\t\t\t\t\t\tclientBuffer = LPDataIOWrapper.collectData(output -> {\n-\t\t\t\t\t\t\t\toutput.writeBytes(clientBuffer);\n-\t\t\t\t\t\t\t\tclearLock.lock();\n-\t\t\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\t\t\tfor (ModernPacket packet : clientList) {\n-\t\t\t\t\t\t\t\t\t\toutput.writeShort(packet.getId());\n-\t\t\t\t\t\t\t\t\t\toutput.writeInt(packet.getDebugId());\n-\t\t\t\t\t\t\t\t\t\tpacket.writeData(output);\n-\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t} finally {\n-\t\t\t\t\t\t\t\t\tclientList.clear();\n-\t\t\t\t\t\t\t\t\tclearLock.unlock();\n+\t\t\t\tsynchronized (clientList) {\n+\t\t\t\t\tif (!pause && clientList.size() > 0) {\n+\t\t\t\t\t\tclientBuffer = LPDataIOWrapper.collectData(output -> {\n+\t\t\t\t\t\t\toutput.writeBytes(clientBuffer);\n+\t\t\t\t\t\t\tclearLock.lock();\n+\t\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\t\tfor (ModernPacket packet : clientList) {\n+\t\t\t\t\t\t\t\t\toutput.writeShort(packet.getId());\n+\t\t\t\t\t\t\t\t\toutput.writeInt(packet.getDebugId());\n+\t\t\t\t\t\t\t\t\tpacket.writeData(output);\n \t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t});\n-\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t} finally {\n+\t\t\t\t\t\t\t\tclientList.clear();\n+\t\t\t\t\t\t\t\tclearLock.unlock();\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t});\n \t\t\t\t\t}\n-\t\t\t\t\t//Send Content\n-\t\t\t\t\tif (clientBuffer.length > 0) {\n-\t\t\t\t\t\twhile (clientBuffer.length > 1024 * 32) {\n-\t\t\t\t\t\t\tbyte[] sendbuffer = Arrays.copyOf(clientBuffer, 1024 * 32);\n-\t\t\t\t\t\t\tclientBuffer = Arrays.copyOfRange(clientBuffer, 1024 * 32, clientBuffer.length);\n-\t\t\t\t\t\t\tbyte[] compressed = ClientPacketBufferHandlerThread.compress(sendbuffer);\n-\t\t\t\t\t\t\tMainProxy.sendPacketToServer(PacketHandler.getPacket(BufferTransfer.class).setContent(compressed));\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tbyte[] sendbuffer = clientBuffer;\n-\t\t\t\t\t\tclientBuffer = new byte[] {};\n+\t\t\t\t}\n+\t\t\t\t//Send Content\n+\t\t\t\tif (clientBuffer.length > 0) {\n+\t\t\t\t\twhile (clientBuffer.length > 1024 * 32) {\n+\t\t\t\t\t\tbyte[] sendbuffer = Arrays.copyOf(clientBuffer, 1024 * 32);\n+\t\t\t\t\t\tclientBuffer = Arrays.copyOfRange(clientBuffer, 1024 * 32, clientBuffer.length);\n \t\t\t\t\t\tbyte[] compressed = ClientPacketBufferHandlerThread.compress(sendbuffer);\n \t\t\t\t\t\tMainProxy.sendPacketToServer(PacketHandler.getPacket(BufferTransfer.class).setContent(compressed));\n \t\t\t\t\t}\n-\t\t\t\t} catch (IOException e) {\n-\t\t\t\t\te.printStackTrace();\n+\t\t\t\t\tbyte[] sendbuffer = clientBuffer;\n+\t\t\t\t\tclientBuffer = new byte[] {};\n+\t\t\t\t\tbyte[] compressed = ClientPacketBufferHandlerThread.compress(sendbuffer);\n+\t\t\t\t\tMainProxy.sendPacketToServer(PacketHandler.getPacket(BufferTransfer.class).setContent(compressed));\n \t\t\t\t}\n \t\t\t\tsynchronized (clientList) {\n \t\t\t\t\twhile (pause || clientList.size() == 0) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tclientList.wait();\n-\t\t\t\t\t\t} catch (InterruptedException e) {}\n+\t\t\t\t\t\t} catch (InterruptedException ignored) { }\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tif (clear) {\n@@ -126,19 +181,17 @@ public void run() {\n \t\t}\n \t}\n \n-\tprivate final ClientCompressorThread clientCompressorThread = new ClientCompressorThread();\n-\n \tprivate class ClientDecompressorThread extends Thread {\n \n \t\t//Received compressed S->C data\n \t\tprivate final LinkedList<byte[]> queue = new LinkedList<>();\n-\t\t//decompressed serialized S->C data\n-\t\tprivate byte[] ByteBuffer = new byte[] {};\n \t\t//FIFO for deserialized S->C packets, decompressor adds, tickEnd removes\n \t\tprivate final LinkedList<Pair<EntityPlayer, byte[]>> PacketBuffer = new LinkedList<>();\n \t\tprivate final ReentrantLock packetBufferLock = new ReentrantLock();\n \t\t//List of packets that that should be reattempted to apply in the next tick\n \t\tprivate final LinkedList<Pair<EntityPlayer, ModernPacket>> retryPackets = new LinkedList<>();\n+\t\t//decompressed serialized S->C data\n+\t\tprivate byte[] ByteBuffer = new byte[] {};\n \t\t//Clear content on next tick\n \t\tprivate boolean clear = false;\n \n@@ -149,14 +202,9 @@ public ClientDecompressorThread() {\n \t\t}\n \n \t\tprivate void handlePacketData(final Pair<EntityPlayer, byte[]> playerDataPair) {\n-\t\t\ttry {\n-\t\t\t\tLPDataIOWrapper.provideData(playerDataPair.getValue2(), input -> {\n-\t\t\t\t\tPacketHandler.onPacketData(input, playerDataPair.getValue1());\n-\t\t\t\t});\n-\t\t\t} catch (IOException e) {\n-\t\t\t\tSystem.err.println(\"IO Error in handlePacketData for player \" + playerDataPair.getValue1().getCommandSenderName());\n-\t\t\t\te.printStackTrace();\n-\t\t\t}\n+\t\t\tLPDataIOWrapper.provideData(playerDataPair.getValue2(), input -> {\n+\t\t\t\tPacketHandler.onPacketData(input, playerDataPair.getValue1());\n+\t\t\t});\n \t\t}\n \n \t\tpublic void clientTickEnd() {\n@@ -220,7 +268,7 @@ public void run() {\n \t\t\t\t\twhile (queue.size() == 0) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tqueue.wait();\n-\t\t\t\t\t\t} catch (InterruptedException e) { }\n+\t\t\t\t\t\t} catch (InterruptedException ignored) { }\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tif (clear) {\n@@ -247,62 +295,4 @@ public void queueFailedPacket(ModernPacket packet, EntityPlayer player) {\n \t\t\tretryPackets.add(new Pair<>(player, packet));\n \t\t}\n \t}\n-\n-\tprivate final ClientDecompressorThread clientDecompressorThread = new ClientDecompressorThread();\n-\n-\tpublic ClientPacketBufferHandlerThread() {}\n-\n-\tpublic void clientTick(ClientTickEvent event) {\n-\t\tif (event.phase != Phase.END) {\n-\t\t\treturn;\n-\t\t}\n-\t\tclientDecompressorThread.clientTickEnd();\n-\t}\n-\n-\tpublic void setPause(boolean flag) {\n-\t\tclientCompressorThread.setPause(flag);\n-\t}\n-\n-\tpublic void addPacketToCompressor(ModernPacket packet) {\n-\t\tclientCompressorThread.addPacketToCompressor(packet);\n-\t}\n-\n-\tpublic void handlePacket(byte[] content) {\n-\t\tclientDecompressorThread.handlePacket(content);\n-\t}\n-\n-\tprivate static byte[] compress(byte[] content) {\n-\t\tByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n-\t\ttry {\n-\t\t\tGZIPOutputStream gzipOutputStream = new GZIPOutputStream(byteArrayOutputStream);\n-\t\t\tgzipOutputStream.write(content);\n-\t\t\tgzipOutputStream.close();\n-\t\t} catch (IOException e) {\n-\t\t\tthrow new RuntimeException(e);\n-\t\t}\n-\t\treturn byteArrayOutputStream.toByteArray();\n-\t}\n-\n-\tprivate static byte[] decompress(byte[] contentBytes) {\n-\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n-\t\ttry {\n-\t\t\tGZIPInputStream gzip = new GZIPInputStream(new ByteArrayInputStream(contentBytes));\n-\t\t\tint buffer = 0;\n-\t\t\twhile ((buffer = gzip.read()) != -1) {\n-\t\t\t\tout.write(buffer);\n-\t\t\t}\n-\t\t} catch (IOException e) {\n-\t\t\tthrow new RuntimeException(e);\n-\t\t}\n-\t\treturn out.toByteArray();\n-\t}\n-\n-\tpublic void clear() {\n-\t\tclientCompressorThread.clear();\n-\t\tclientDecompressorThread.clear();\n-\t}\n-\n-\tpublic void queueFailedPacket(ModernPacket packet, EntityPlayer player) {\n-\t\tclientDecompressorThread.queueFailedPacket(packet, player);\n-\t}\n }",
    "function_modified_lines": {
      "added": [],
      "deleted": [
        "\n",
        "\tprivate final ClientDecompressorThread clientDecompressorThread = new ClientDecompressorThread();\n",
        "\n",
        "\tpublic ClientPacketBufferHandlerThread() {}\n",
        "\n",
        "\tpublic void clientTick(ClientTickEvent event) {\n",
        "\t\tif (event.phase != Phase.END) {\n",
        "\t\t\treturn;\n",
        "\t\t}\n",
        "\t\tclientDecompressorThread.clientTickEnd();\n",
        "\t}\n",
        "\n",
        "\tpublic void setPause(boolean flag) {\n",
        "\t\tclientCompressorThread.setPause(flag);\n",
        "\t}\n",
        "\n",
        "\tpublic void addPacketToCompressor(ModernPacket packet) {\n",
        "\t\tclientCompressorThread.addPacketToCompressor(packet);\n",
        "\t}\n",
        "\n",
        "\tpublic void handlePacket(byte[] content) {\n",
        "\t\tclientDecompressorThread.handlePacket(content);\n",
        "\t}\n",
        "\n",
        "\tprivate static byte[] compress(byte[] content) {\n",
        "\t\tByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n",
        "\t\ttry {\n",
        "\t\t\tGZIPOutputStream gzipOutputStream = new GZIPOutputStream(byteArrayOutputStream);\n",
        "\t\t\tgzipOutputStream.write(content);\n",
        "\t\t\tgzipOutputStream.close();\n",
        "\t\t} catch (IOException e) {\n",
        "\t\t\tthrow new RuntimeException(e);\n",
        "\t\t}\n",
        "\t\treturn byteArrayOutputStream.toByteArray();\n",
        "\t}\n",
        "\n",
        "\tprivate static byte[] decompress(byte[] contentBytes) {\n",
        "\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n",
        "\t\ttry {\n",
        "\t\t\tGZIPInputStream gzip = new GZIPInputStream(new ByteArrayInputStream(contentBytes));\n",
        "\t\t\tint buffer = 0;\n",
        "\t\t\twhile ((buffer = gzip.read()) != -1) {\n",
        "\t\t\t\tout.write(buffer);\n",
        "\t\t\t}\n",
        "\t\t} catch (IOException e) {\n",
        "\t\t\tthrow new RuntimeException(e);\n",
        "\t\t}\n",
        "\t\treturn out.toByteArray();\n",
        "\t}\n",
        "\n",
        "\tpublic void clear() {\n",
        "\t\tclientCompressorThread.clear();\n",
        "\t\tclientDecompressorThread.clear();\n",
        "\t}\n",
        "\n",
        "\tpublic void queueFailedPacket(ModernPacket packet, EntityPlayer player) {\n",
        "\t\tclientDecompressorThread.queueFailedPacket(packet, player);\n",
        "\t}\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12840
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "{\n\t\t\ttry {\n\t\t\t\tLPDataIOWrapper.provideData(playerDataPair.getValue2(), input -> {\n\t\t\t\t\tPacketHandler.onPacketData(input, playerDataPair.getValue1());\n\t\t\t\t});\n\t\t\t} catch (IOException e) {\n\t\t\t\tSystem.err.println(\"IO Error in handlePacketData for player \" + playerDataPair.getValue1().getCommandSenderName());\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}",
    "code_after_change": "{\n\t\t\tLPDataIOWrapper.provideData(playerDataPair.getValue2(), input -> {\n\t\t\t\tPacketHandler.onPacketData(input, playerDataPair.getValue1());\n\t\t\t});\n\t\t}",
    "patch": "@@ -26,6 +26,67 @@\n \n public class ServerPacketBufferHandlerThread {\n \n+\tprivate final ServerCompressorThread serverCompressorThread = new ServerCompressorThread();\n+\tprivate final ServerDecompressorThread serverDecompressorThread = new ServerDecompressorThread();\n+\n+\tpublic ServerPacketBufferHandlerThread() {}\n+\n+\tprivate static byte[] compress(byte[] content) {\n+\t\tByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n+\t\ttry {\n+\t\t\tGZIPOutputStream gzipOutputStream = new GZIPOutputStream(byteArrayOutputStream);\n+\t\t\tgzipOutputStream.write(content);\n+\t\t\tgzipOutputStream.close();\n+\t\t} catch (IOException e) {\n+\t\t\tthrow new RuntimeException(e);\n+\t\t}\n+\t\treturn byteArrayOutputStream.toByteArray();\n+\t}\n+\n+\tprivate static byte[] decompress(byte[] contentBytes) {\n+\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n+\t\ttry {\n+\t\t\tGZIPInputStream gzip = new GZIPInputStream(new ByteArrayInputStream(contentBytes));\n+\t\t\tint buffer = 0;\n+\t\t\twhile ((buffer = gzip.read()) != -1) {\n+\t\t\t\tout.write(buffer);\n+\t\t\t}\n+\t\t} catch (IOException e) {\n+\t\t\tthrow new RuntimeException(e);\n+\t\t}\n+\t\treturn out.toByteArray();\n+\t}\n+\n+\tpublic void serverTick(ServerTickEvent event) {\n+\t\tif (event.phase != Phase.END) {\n+\t\t\treturn;\n+\t\t}\n+\t\tserverDecompressorThread.serverTickEnd();\n+\t}\n+\n+\tpublic void setPause(boolean flag) {\n+\t\tserverCompressorThread.setPause(flag);\n+\t}\n+\n+\tpublic void addPacketToCompressor(ModernPacket packet, EntityPlayer player) {\n+\t\tserverCompressorThread.addPacketToCompressor(packet, player);\n+\t}\n+\n+\tpublic void handlePacket(byte[] content, EntityPlayer player) {\n+\t\tserverDecompressorThread.handlePacket(content, player);\n+\t}\n+\n+\tpublic void clear(final EntityPlayer player) {\n+\t\tnew Thread() {\n+\n+\t\t\t@Override\n+\t\t\tpublic void run() {\n+\t\t\t\tserverCompressorThread.clear(player);\n+\t\t\t\tserverDecompressorThread.clear(player);\n+\t\t\t}\n+\t\t}.start();\n+\t}\n+\n \tprivate class ServerCompressorThread extends Thread {\n \n \t\t//Map of Players to lists of S->C packets to be serialized and compressed\n@@ -46,53 +107,49 @@ public ServerCompressorThread() {\n \t\t@Override\n \t\tpublic void run() {\n \t\t\twhile (true) {\n-\t\t\t\ttry {\n-\t\t\t\t\tsynchronized (serverList) {\n-\t\t\t\t\t\tif (!pause) {\n-\t\t\t\t\t\t\tfor (Entry<EntityPlayer, LinkedList<ModernPacket>> playerPacketEntry : serverList.entrySet()) {\n-\t\t\t\t\t\t\t\tEntityPlayer player = playerPacketEntry.getKey();\n-\t\t\t\t\t\t\t\tserverBuffer.put(player, LPDataIOWrapper.collectData(output -> {\n-\t\t\t\t\t\t\t\t\tif (serverBuffer.containsKey(player)) {\n-\t\t\t\t\t\t\t\t\t\toutput.writeBytes(serverBuffer.get(player));\n-\t\t\t\t\t\t\t\t\t}\n+\t\t\t\tsynchronized (serverList) {\n+\t\t\t\t\tif (!pause) {\n+\t\t\t\t\t\tfor (Entry<EntityPlayer, LinkedList<ModernPacket>> playerPacketEntry : serverList.entrySet()) {\n+\t\t\t\t\t\t\tEntityPlayer player = playerPacketEntry.getKey();\n+\t\t\t\t\t\t\tserverBuffer.put(player, LPDataIOWrapper.collectData(output -> {\n+\t\t\t\t\t\t\t\tif (serverBuffer.containsKey(player)) {\n+\t\t\t\t\t\t\t\t\toutput.writeBytes(serverBuffer.get(player));\n+\t\t\t\t\t\t\t\t}\n \n-\t\t\t\t\t\t\t\t\tLinkedList<ModernPacket> packets = playerPacketEntry.getValue();\n-\t\t\t\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\t\t\t\tfor (ModernPacket packet : packets) {\n-\t\t\t\t\t\t\t\t\t\t\toutput.writeShort(packet.getId());\n-\t\t\t\t\t\t\t\t\t\t\toutput.writeInt(packet.getDebugId());\n-\t\t\t\t\t\t\t\t\t\t\tpacket.writeData(output);\n-\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t} finally {\n-\t\t\t\t\t\t\t\t\t\tpackets.clear();\n+\t\t\t\t\t\t\t\tLinkedList<ModernPacket> packets = playerPacketEntry.getValue();\n+\t\t\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\t\t\tfor (ModernPacket packet : packets) {\n+\t\t\t\t\t\t\t\t\t\toutput.writeShort(packet.getId());\n+\t\t\t\t\t\t\t\t\t\toutput.writeInt(packet.getDebugId());\n+\t\t\t\t\t\t\t\t\t\tpacket.writeData(output);\n \t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t}));\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tserverList.clear();\n+\t\t\t\t\t\t\t\t} finally {\n+\t\t\t\t\t\t\t\t\tpackets.clear();\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}));\n \t\t\t\t\t\t}\n+\t\t\t\t\t\tserverList.clear();\n \t\t\t\t\t}\n-\t\t\t\t\t//Send Content\n-\t\t\t\t\tfor (Entry<EntityPlayer, byte[]> player : serverBuffer.entrySet()) {\n-\t\t\t\t\t\twhile (player.getValue().length > 32 * 1024) {\n-\t\t\t\t\t\t\tbyte[] sendbuffer = Arrays.copyOf(player.getValue(), 1024 * 32);\n-\t\t\t\t\t\t\tbyte[] newbuffer = Arrays.copyOfRange(player.getValue(), 1024 * 32, player.getValue().length);\n-\t\t\t\t\t\t\tplayer.setValue(newbuffer);\n-\t\t\t\t\t\t\tbyte[] compressed = ServerPacketBufferHandlerThread.compress(sendbuffer);\n-\t\t\t\t\t\t\tMainProxy.sendPacketToPlayer(PacketHandler.getPacket(BufferTransfer.class).setContent(compressed), player.getKey());\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tbyte[] sendbuffer = player.getValue();\n+\t\t\t\t}\n+\t\t\t\t//Send Content\n+\t\t\t\tfor (Entry<EntityPlayer, byte[]> player : serverBuffer.entrySet()) {\n+\t\t\t\t\twhile (player.getValue().length > 32 * 1024) {\n+\t\t\t\t\t\tbyte[] sendbuffer = Arrays.copyOf(player.getValue(), 1024 * 32);\n+\t\t\t\t\t\tbyte[] newbuffer = Arrays.copyOfRange(player.getValue(), 1024 * 32, player.getValue().length);\n+\t\t\t\t\t\tplayer.setValue(newbuffer);\n \t\t\t\t\t\tbyte[] compressed = ServerPacketBufferHandlerThread.compress(sendbuffer);\n \t\t\t\t\t\tMainProxy.sendPacketToPlayer(PacketHandler.getPacket(BufferTransfer.class).setContent(compressed), player.getKey());\n \t\t\t\t\t}\n-\t\t\t\t} catch (IOException e) {\n-\t\t\t\t\te.printStackTrace();\n+\t\t\t\t\tbyte[] sendbuffer = player.getValue();\n+\t\t\t\t\tbyte[] compressed = ServerPacketBufferHandlerThread.compress(sendbuffer);\n+\t\t\t\t\tMainProxy.sendPacketToPlayer(PacketHandler.getPacket(BufferTransfer.class).setContent(compressed), player.getKey());\n \t\t\t\t}\n \t\t\t\tserverBuffer.clear();\n \t\t\t\tsynchronized (serverList) {\n \t\t\t\t\twhile (pause || serverList.size() == 0) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tserverList.wait();\n-\t\t\t\t\t\t} catch (InterruptedException e) {}\n+\t\t\t\t\t\t} catch (InterruptedException ignored) { }\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tsynchronized (playersToClear) {\n@@ -140,8 +197,6 @@ public void clear(EntityPlayer player) {\n \t\t}\n \t}\n \n-\tprivate final ServerCompressorThread serverCompressorThread = new ServerCompressorThread();\n-\n \tprivate class ServerDecompressorThread extends Thread {\n \n \t\t//Map of Player to received compressed C->S data\n@@ -161,14 +216,9 @@ public ServerDecompressorThread() {\n \t\t}\n \n \t\tprivate void handlePacketData(final Pair<EntityPlayer, byte[]> playerDataPair) {\n-\t\t\ttry {\n-\t\t\t\tLPDataIOWrapper.provideData(playerDataPair.getValue2(), input -> {\n-\t\t\t\t\tPacketHandler.onPacketData(input, playerDataPair.getValue1());\n-\t\t\t\t});\n-\t\t\t} catch (IOException e) {\n-\t\t\t\tSystem.err.println(\"IO Error in handlePacketData for player \" + playerDataPair.getValue1().getCommandSenderName());\n-\t\t\t\te.printStackTrace();\n-\t\t\t}\n+\t\t\tLPDataIOWrapper.provideData(playerDataPair.getValue2(), input -> {\n+\t\t\t\tPacketHandler.onPacketData(input, playerDataPair.getValue1());\n+\t\t\t});\n \t\t}\n \n \t\tpublic void serverTickEnd() {\n@@ -262,7 +312,7 @@ public void run() {\n \t\t\t\t\twhile (queue.size() == 0) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tqueue.wait();\n-\t\t\t\t\t\t} catch (InterruptedException e) {}\n+\t\t\t\t\t\t} catch (InterruptedException ignored) { }\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tsynchronized (playersToClear) {\n@@ -298,64 +348,4 @@ public void clear(EntityPlayer player) {\n \t\t\t}\n \t\t}\n \t}\n-\n-\tprivate final ServerDecompressorThread serverDecompressorThread = new ServerDecompressorThread();\n-\n-\tpublic ServerPacketBufferHandlerThread() {}\n-\n-\tpublic void serverTick(ServerTickEvent event) {\n-\t\tif (event.phase != Phase.END) {\n-\t\t\treturn;\n-\t\t}\n-\t\tserverDecompressorThread.serverTickEnd();\n-\t}\n-\n-\tpublic void setPause(boolean flag) {\n-\t\tserverCompressorThread.setPause(flag);\n-\t}\n-\n-\tpublic void addPacketToCompressor(ModernPacket packet, EntityPlayer player) {\n-\t\tserverCompressorThread.addPacketToCompressor(packet, player);\n-\t}\n-\n-\tpublic void handlePacket(byte[] content, EntityPlayer player) {\n-\t\tserverDecompressorThread.handlePacket(content, player);\n-\t}\n-\n-\tprivate static byte[] compress(byte[] content) {\n-\t\tByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n-\t\ttry {\n-\t\t\tGZIPOutputStream gzipOutputStream = new GZIPOutputStream(byteArrayOutputStream);\n-\t\t\tgzipOutputStream.write(content);\n-\t\t\tgzipOutputStream.close();\n-\t\t} catch (IOException e) {\n-\t\t\tthrow new RuntimeException(e);\n-\t\t}\n-\t\treturn byteArrayOutputStream.toByteArray();\n-\t}\n-\n-\tprivate static byte[] decompress(byte[] contentBytes) {\n-\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n-\t\ttry {\n-\t\t\tGZIPInputStream gzip = new GZIPInputStream(new ByteArrayInputStream(contentBytes));\n-\t\t\tint buffer = 0;\n-\t\t\twhile ((buffer = gzip.read()) != -1) {\n-\t\t\t\tout.write(buffer);\n-\t\t\t}\n-\t\t} catch (IOException e) {\n-\t\t\tthrow new RuntimeException(e);\n-\t\t}\n-\t\treturn out.toByteArray();\n-\t}\n-\n-\tpublic void clear(final EntityPlayer player) {\n-\t\tnew Thread() {\n-\n-\t\t\t@Override\n-\t\t\tpublic void run() {\n-\t\t\t\tserverCompressorThread.clear(player);\n-\t\t\t\tserverDecompressorThread.clear(player);\n-\t\t\t}\n-\t\t}.start();\n-\t}\n }",
    "function_modified_lines": {
      "added": [
        "\t\t\tLPDataIOWrapper.provideData(playerDataPair.getValue2(), input -> {\n",
        "\t\t\t\tPacketHandler.onPacketData(input, playerDataPair.getValue1());\n",
        "\t\t\t});\n"
      ],
      "deleted": [
        "\t\t\ttry {\n",
        "\t\t\t\tLPDataIOWrapper.provideData(playerDataPair.getValue2(), input -> {\n",
        "\t\t\t\t\tPacketHandler.onPacketData(input, playerDataPair.getValue1());\n",
        "\t\t\t\t});\n",
        "\t\t\t} catch (IOException e) {\n",
        "\t\t\t\tSystem.err.println(\"IO Error in handlePacketData for player \" + playerDataPair.getValue1().getCommandSenderName());\n",
        "\t\t\t\te.printStackTrace();\n",
        "\t\t\t}\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12841
  },
  {
    "cve_id": "CVE-2023-38689",
    "code_before_change": "{\n\n\tprivate class ServerCompressorThread extends Thread {\n\n\t\t//Map of Players to lists of S->C packets to be serialized and compressed\n\t\tprivate final HashMap<EntityPlayer, LinkedList<ModernPacket>> serverList = new HashMap<>();\n\t\t//Map of Players to serialized but still uncompressed S->C data\n\t\tprivate final HashMap<EntityPlayer, byte[]> serverBuffer = new HashMap<>();\n\t\t//used to cork the compressor so we can queue up a whole bunch of packets at once\n\t\tprivate boolean pause = false;\n\t\t//Clear content on next tick\n\t\tprivate Queue<EntityPlayer> playersToClear = new LinkedList<>();\n\n\t\tpublic ServerCompressorThread() {\n\t\t\tsuper(\"LogisticsPipes Packet Compressor Server\");\n\t\t\tsetDaemon(true);\n\t\t\tstart();\n\t\t}\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\twhile (true) {\n\t\t\t\ttry {\n\t\t\t\t\tsynchronized (serverList) {\n\t\t\t\t\t\tif (!pause) {\n\t\t\t\t\t\t\tfor (Entry<EntityPlayer, LinkedList<ModernPacket>> playerPacketEntry : serverList.entrySet()) {\n\t\t\t\t\t\t\t\tEntityPlayer player = playerPacketEntry.getKey();\n\t\t\t\t\t\t\t\tserverBuffer.put(player, LPDataIOWrapper.collectData(output -> {\n\t\t\t\t\t\t\t\t\tif (serverBuffer.containsKey(player)) {\n\t\t\t\t\t\t\t\t\t\toutput.writeBytes(serverBuffer.get(player));\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tLinkedList<ModernPacket> packets = playerPacketEntry.getValue();\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tfor (ModernPacket packet : packets) {\n\t\t\t\t\t\t\t\t\t\t\toutput.writeShort(packet.getId());\n\t\t\t\t\t\t\t\t\t\t\toutput.writeInt(packet.getDebugId());\n\t\t\t\t\t\t\t\t\t\t\tpacket.writeData(output);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\t\t\tpackets.clear();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tserverList.clear();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//Send Content\n\t\t\t\t\tfor (Entry<EntityPlayer, byte[]> player : serverBuffer.entrySet()) {\n\t\t\t\t\t\twhile (player.getValue().length > 32 * 1024) {\n\t\t\t\t\t\t\tbyte[] sendbuffer = Arrays.copyOf(player.getValue(), 1024 * 32);\n\t\t\t\t\t\t\tbyte[] newbuffer = Arrays.copyOfRange(player.getValue(), 1024 * 32, player.getValue().length);\n\t\t\t\t\t\t\tplayer.setValue(newbuffer);\n\t\t\t\t\t\t\tbyte[] compressed = ServerPacketBufferHandlerThread.compress(sendbuffer);\n\t\t\t\t\t\t\tMainProxy.sendPacketToPlayer(PacketHandler.getPacket(BufferTransfer.class).setContent(compressed), player.getKey());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbyte[] sendbuffer = player.getValue();\n\t\t\t\t\t\tbyte[] compressed = ServerPacketBufferHandlerThread.compress(sendbuffer);\n\t\t\t\t\t\tMainProxy.sendPacketToPlayer(PacketHandler.getPacket(BufferTransfer.class).setContent(compressed), player.getKey());\n\t\t\t\t\t}\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tserverBuffer.clear();\n\t\t\t\tsynchronized (serverList) {\n\t\t\t\t\twhile (pause || serverList.size() == 0) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tserverList.wait();\n\t\t\t\t\t\t} catch (InterruptedException e) {}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsynchronized (playersToClear) {\n\t\t\t\t\tEntityPlayer player = null;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tplayer = playersToClear.poll();\n\t\t\t\t\t\tif (player != null) {\n\t\t\t\t\t\t\tserverBuffer.remove(player);\n\t\t\t\t\t\t}\n\t\t\t\t\t} while (player != null);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic void addPacketToCompressor(ModernPacket packet, EntityPlayer player) {\n\t\t\tsynchronized (serverList) {\n\t\t\t\tLinkedList<ModernPacket> packetList = serverList.get(player);\n\t\t\t\tif (packetList == null) {\n\t\t\t\t\tpacketList = new LinkedList<>();\n\t\t\t\t\tserverList.put(player, packetList);\n\t\t\t\t}\n\t\t\t\tpacketList.add(packet);\n\t\t\t\tif (!pause) {\n\t\t\t\t\tserverList.notify();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic void setPause(boolean flag) {\n\t\t\tsynchronized (serverList) {\n\t\t\t\tpause = flag;\n\t\t\t\tif (!pause) {\n\t\t\t\t\tserverList.notify();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic void clear(EntityPlayer player) {\n\t\t\tsynchronized (serverList) {\n\t\t\t\tserverList.remove(player);\n\t\t\t}\n\t\t\tsynchronized (playersToClear) {\n\t\t\t\tplayersToClear.add(player);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate final ServerCompressorThread serverCompressorThread = new ServerCompressorThread();\n\n\tprivate class ServerDecompressorThread extends Thread {\n\n\t\t//Map of Player to received compressed C->S data\n\t\tprivate final HashMap<EntityPlayer, LinkedList<byte[]>> queue = new HashMap<>();\n\t\t//Map of Player to decompressed serialized C->S data\n\t\tprivate final HashMap<EntityPlayer, byte[]> ByteBuffer = new HashMap<>();\n\t\t//FIFO for deserialized C->S packets, decompressor adds, tickEnd removes\n\t\tprivate final LinkedList<Pair<EntityPlayer, byte[]>> PacketBuffer = new LinkedList<>();\n\t\tprivate final ReentrantLock packetBufferLock = new ReentrantLock();\n\t\t//Clear content on next tick\n\t\tprivate Queue<EntityPlayer> playersToClear = new LinkedList<>();\n\n\t\tpublic ServerDecompressorThread() {\n\t\t\tsuper(\"LogisticsPipes Packet Decompressor Server\");\n\t\t\tsetDaemon(true);\n\t\t\tstart();\n\t\t}\n\n\t\tprivate void handlePacketData(final Pair<EntityPlayer, byte[]> playerDataPair) {\n\t\t\ttry {\n\t\t\t\tLPDataIOWrapper.provideData(playerDataPair.getValue2(), input -> {\n\t\t\t\t\tPacketHandler.onPacketData(input, playerDataPair.getValue1());\n\t\t\t\t});\n\t\t\t} catch (IOException e) {\n\t\t\t\tSystem.err.println(\"IO Error in handlePacketData for player \" + playerDataPair.getValue1().getCommandSenderName());\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic void serverTickEnd() {\n\t\t\tPair<EntityPlayer, byte[]> part = null;\n\t\t\twhile (true) {\n\t\t\t\tpacketBufferLock.lock();\n\t\t\t\ttry {\n\t\t\t\t\tif (PacketBuffer.size() > 0) {\n\t\t\t\t\t\tpart = PacketBuffer.pop();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tpacketBufferLock.unlock();\n\t\t\t\t}\n\n\t\t\t\tif (part == null) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\thandlePacketData(part);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\twhile (true) {\n\t\t\t\tboolean flag = false;\n\t\t\t\tdo {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbyte[] buffer = null;\n\t\t\t\t\tEntityPlayer player = null;\n\t\t\t\t\tsynchronized (queue) {\n\t\t\t\t\t\tif (queue.size() > 0) {\n\t\t\t\t\t\t\tfor (Iterator<Entry<EntityPlayer, LinkedList<byte[]>>> it = queue.entrySet().iterator(); it.hasNext();) {\n\t\t\t\t\t\t\t\tEntry<EntityPlayer, LinkedList<byte[]>> lPlayer = it.next();\n\t\t\t\t\t\t\t\tif (lPlayer.getValue().size() > 0) {\n\t\t\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\t\t\tbuffer = lPlayer.getValue().getFirst();\n\t\t\t\t\t\t\t\t\tplayer = lPlayer.getKey();\n\t\t\t\t\t\t\t\t\tif (lPlayer.getValue().size() > 1) {\n\t\t\t\t\t\t\t\t\t\tlPlayer.getValue().removeFirst();\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tit.remove();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tit.remove();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (flag && buffer != null && player != null) {\n\t\t\t\t\t\tbyte[] ByteBufferForPlayer = ByteBuffer.get(player);\n\t\t\t\t\t\tif (ByteBufferForPlayer == null) {\n\t\t\t\t\t\t\tByteBufferForPlayer = new byte[] {};\n\t\t\t\t\t\t\tByteBuffer.put(player, ByteBufferForPlayer);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbyte[] packetbytes = ServerPacketBufferHandlerThread.decompress(buffer);\n\t\t\t\t\t\tbyte[] newBuffer = new byte[packetbytes.length + ByteBufferForPlayer.length];\n\t\t\t\t\t\tSystem.arraycopy(ByteBufferForPlayer, 0, newBuffer, 0, ByteBufferForPlayer.length);\n\t\t\t\t\t\tSystem.arraycopy(packetbytes, 0, newBuffer, ByteBufferForPlayer.length, packetbytes.length);\n\t\t\t\t\t\tByteBuffer.put(player, newBuffer);\n\t\t\t\t\t}\n\t\t\t\t} while (flag);\n\n\t\t\t\tfor (Entry<EntityPlayer, byte[]> player : ByteBuffer.entrySet()) {\n\t\t\t\t\twhile (player.getValue().length >= 4) {\n\t\t\t\t\t\tbyte[] ByteBufferForPlayer = player.getValue();\n\t\t\t\t\t\tint size = ((ByteBufferForPlayer[0] & 255) << 24) + ((ByteBufferForPlayer[1] & 255) << 16) + ((ByteBufferForPlayer[2] & 255) << 8) + ((ByteBufferForPlayer[3] & 255) << 0);\n\t\t\t\t\t\tif (size + 4 > ByteBufferForPlayer.length) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbyte[] packet = Arrays.copyOfRange(ByteBufferForPlayer, 4, size + 4);\n\t\t\t\t\t\tByteBufferForPlayer = Arrays.copyOfRange(ByteBufferForPlayer, size + 4, ByteBufferForPlayer.length);\n\t\t\t\t\t\tplayer.setValue(ByteBufferForPlayer);\n\t\t\t\t\t\tpacketBufferLock.lock();\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tPacketBuffer.add(new Pair<>(player.getKey(), packet));\n\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\tpacketBufferLock.unlock();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (Iterator<byte[]> it = ByteBuffer.values().iterator(); it.hasNext();) {\n\t\t\t\t\tbyte[] ByteBufferForPlayer = it.next();\n\t\t\t\t\tif (ByteBufferForPlayer.length == 0) {\n\t\t\t\t\t\tit.remove();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tsynchronized (queue) {\n\t\t\t\t\twhile (queue.size() == 0) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tqueue.wait();\n\t\t\t\t\t\t} catch (InterruptedException e) {}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsynchronized (playersToClear) {\n\t\t\t\t\tEntityPlayer player = null;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tplayer = playersToClear.poll();\n\t\t\t\t\t\tif (player != null) {\n\t\t\t\t\t\t\tByteBuffer.remove(player);\n\t\t\t\t\t\t}\n\t\t\t\t\t} while (player != null);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic void handlePacket(byte[] content, EntityPlayer player) {\n\t\t\tsynchronized (queue) {\n\t\t\t\tLinkedList<byte[]> list = queue.get(player);\n\t\t\t\tif (list == null) {\n\t\t\t\t\tlist = new LinkedList<>();\n\t\t\t\t\tqueue.put(player, list);\n\t\t\t\t}\n\t\t\t\tlist.addLast(content);\n\t\t\t\tqueue.notify();\n\t\t\t}\n\t\t}\n\n\t\tpublic void clear(EntityPlayer player) {\n\t\t\tsynchronized (queue) {\n\t\t\t\tqueue.remove(player);\n\t\t\t}\n\t\t\tsynchronized (playersToClear) {\n\t\t\t\tplayersToClear.add(player);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate final ServerDecompressorThread serverDecompressorThread = new ServerDecompressorThread();\n\n\tpublic ServerPacketBufferHandlerThread() {}\n\n\tpublic void serverTick(ServerTickEvent event) {\n\t\tif (event.phase != Phase.END) {\n\t\t\treturn;\n\t\t}\n\t\tserverDecompressorThread.serverTickEnd();\n\t}\n\n\tpublic void setPause(boolean flag) {\n\t\tserverCompressorThread.setPause(flag);\n\t}\n\n\tpublic void addPacketToCompressor(ModernPacket packet, EntityPlayer player) {\n\t\tserverCompressorThread.addPacketToCompressor(packet, player);\n\t}\n\n\tpublic void handlePacket(byte[] content, EntityPlayer player) {\n\t\tserverDecompressorThread.handlePacket(content, player);\n\t}\n\n\tprivate static byte[] compress(byte[] content) {\n\t\tByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n\t\ttry {\n\t\t\tGZIPOutputStream gzipOutputStream = new GZIPOutputStream(byteArrayOutputStream);\n\t\t\tgzipOutputStream.write(content);\n\t\t\tgzipOutputStream.close();\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t\treturn byteArrayOutputStream.toByteArray();\n\t}\n\n\tprivate static byte[] decompress(byte[] contentBytes) {\n\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n\t\ttry {\n\t\t\tGZIPInputStream gzip = new GZIPInputStream(new ByteArrayInputStream(contentBytes));\n\t\t\tint buffer = 0;\n\t\t\twhile ((buffer = gzip.read()) != -1) {\n\t\t\t\tout.write(buffer);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t\treturn out.toByteArray();\n\t}\n\n\tpublic void clear(final EntityPlayer player) {\n\t\tnew Thread() {\n\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tserverCompressorThread.clear(player);\n\t\t\t\tserverDecompressorThread.clear(player);\n\t\t\t}\n\t\t}.start();\n\t}\n}",
    "code_after_change": "package logisticspipes.ticks;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.Map.Entry;\nimport java.util.Queue;\nimport java.util.concurrent.locks.ReentrantLock;\nimport java.util.zip.GZIPInputStream;\nimport java.util.zip.GZIPOutputStream;\n\nimport net.minecraft.entity.player.EntityPlayer;\nimport cpw.mods.fml.common.gameevent.TickEvent.Phase;\nimport cpw.mods.fml.common.gameevent.TickEvent.ServerTickEvent;\n\nimport logisticspipes.network.PacketHandler;\nimport logisticspipes.network.abstractpackets.ModernPacket;\nimport logisticspipes.network.packets.BufferTransfer;\nimport logisticspipes.proxy.MainProxy;\nimport logisticspipes.utils.tuples.Pair;\nimport network.rs485.logisticspipes.util.LPDataIOWrapper;\n\npublic class ServerPacketBufferHandlerThread {\n\n\tprivate final ServerCompressorThread serverCompressorThread = new ServerCompressorThread();\n\tprivate final ServerDecompressorThread serverDecompressorThread = new ServerDecompressorThread();\n\n\tpublic ServerPacketBufferHandlerThread() {}\n\n\tprivate static byte[] compress(byte[] content) {\n\t\tByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n\t\ttry {\n\t\t\tGZIPOutputStream gzipOutputStream = new GZIPOutputStream(byteArrayOutputStream);\n\t\t\tgzipOutputStream.write(content);\n\t\t\tgzipOutputStream.close();\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t\treturn byteArrayOutputStream.toByteArray();\n\t}\n\n\tprivate static byte[] decompress(byte[] contentBytes) {\n\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n\t\ttry {\n\t\t\tGZIPInputStream gzip = new GZIPInputStream(new ByteArrayInputStream(contentBytes));\n\t\t\tint buffer = 0;\n\t\t\twhile ((buffer = gzip.read()) != -1) {\n\t\t\t\tout.write(buffer);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t\treturn out.toByteArray();\n\t}\n\n\tpublic void serverTick(ServerTickEvent event) {\n\t\tif (event.phase != Phase.END) {\n\t\t\treturn;\n\t\t}\n\t\tserverDecompressorThread.serverTickEnd();\n\t}\n\n\tpublic void setPause(boolean flag) {\n\t\tserverCompressorThread.setPause(flag);\n\t}\n\n\tpublic void addPacketToCompressor(ModernPacket packet, EntityPlayer player) {\n\t\tserverCompressorThread.addPacketToCompressor(packet, player);\n\t}\n\n\tpublic void handlePacket(byte[] content, EntityPlayer player) {\n\t\tserverDecompressorThread.handlePacket(content, player);\n\t}\n\n\tpublic void clear(final EntityPlayer player) {\n\t\tnew Thread() {\n\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tserverCompressorThread.clear(player);\n\t\t\t\tserverDecompressorThread.clear(player);\n\t\t\t}\n\t\t}.start();\n\t}\n\n\tprivate class ServerCompressorThread extends Thread {\n\n\t\t//Map of Players to lists of S->C packets to be serialized and compressed\n\t\tprivate final HashMap<EntityPlayer, LinkedList<ModernPacket>> serverList = new HashMap<>();\n\t\t//Map of Players to serialized but still uncompressed S->C data\n\t\tprivate final HashMap<EntityPlayer, byte[]> serverBuffer = new HashMap<>();\n\t\t//used to cork the compressor so we can queue up a whole bunch of packets at once\n\t\tprivate boolean pause = false;\n\t\t//Clear content on next tick\n\t\tprivate Queue<EntityPlayer> playersToClear = new LinkedList<>();\n\n\t\tpublic ServerCompressorThread() {\n\t\t\tsuper(\"LogisticsPipes Packet Compressor Server\");\n\t\t\tsetDaemon(true);\n\t\t\tstart();\n\t\t}\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\twhile (true) {\n\t\t\t\tsynchronized (serverList) {\n\t\t\t\t\tif (!pause) {\n\t\t\t\t\t\tfor (Entry<EntityPlayer, LinkedList<ModernPacket>> playerPacketEntry : serverList.entrySet()) {\n\t\t\t\t\t\t\tEntityPlayer player = playerPacketEntry.getKey();\n\t\t\t\t\t\t\tserverBuffer.put(player, LPDataIOWrapper.collectData(output -> {\n\t\t\t\t\t\t\t\tif (serverBuffer.containsKey(player)) {\n\t\t\t\t\t\t\t\t\toutput.writeBytes(serverBuffer.get(player));\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tLinkedList<ModernPacket> packets = playerPacketEntry.getValue();\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tfor (ModernPacket packet : packets) {\n\t\t\t\t\t\t\t\t\t\toutput.writeShort(packet.getId());\n\t\t\t\t\t\t\t\t\t\toutput.writeInt(packet.getDebugId());\n\t\t\t\t\t\t\t\t\t\tpacket.writeData(output);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\t\tpackets.clear();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tserverList.clear();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//Send Content\n\t\t\t\tfor (Entry<EntityPlayer, byte[]> player : serverBuffer.entrySet()) {\n\t\t\t\t\twhile (player.getValue().length > 32 * 1024) {\n\t\t\t\t\t\tbyte[] sendbuffer = Arrays.copyOf(player.getValue(), 1024 * 32);\n\t\t\t\t\t\tbyte[] newbuffer = Arrays.copyOfRange(player.getValue(), 1024 * 32, player.getValue().length);\n\t\t\t\t\t\tplayer.setValue(newbuffer);\n\t\t\t\t\t\tbyte[] compressed = ServerPacketBufferHandlerThread.compress(sendbuffer);\n\t\t\t\t\t\tMainProxy.sendPacketToPlayer(PacketHandler.getPacket(BufferTransfer.class).setContent(compressed), player.getKey());\n\t\t\t\t\t}\n\t\t\t\t\tbyte[] sendbuffer = player.getValue();\n\t\t\t\t\tbyte[] compressed = ServerPacketBufferHandlerThread.compress(sendbuffer);\n\t\t\t\t\tMainProxy.sendPacketToPlayer(PacketHandler.getPacket(BufferTransfer.class).setContent(compressed), player.getKey());\n\t\t\t\t}\n\t\t\t\tserverBuffer.clear();\n\t\t\t\tsynchronized (serverList) {\n\t\t\t\t\twhile (pause || serverList.size() == 0) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tserverList.wait();\n\t\t\t\t\t\t} catch (InterruptedException ignored) { }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsynchronized (playersToClear) {\n\t\t\t\t\tEntityPlayer player = null;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tplayer = playersToClear.poll();\n\t\t\t\t\t\tif (player != null) {\n\t\t\t\t\t\t\tserverBuffer.remove(player);\n\t\t\t\t\t\t}\n\t\t\t\t\t} while (player != null);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic void addPacketToCompressor(ModernPacket packet, EntityPlayer player) {\n\t\t\tsynchronized (serverList) {\n\t\t\t\tLinkedList<ModernPacket> packetList = serverList.get(player);\n\t\t\t\tif (packetList == null) {\n\t\t\t\t\tpacketList = new LinkedList<>();\n\t\t\t\t\tserverList.put(player, packetList);\n\t\t\t\t}\n\t\t\t\tpacketList.add(packet);\n\t\t\t\tif (!pause) {\n\t\t\t\t\tserverList.notify();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic void setPause(boolean flag) {\n\t\t\tsynchronized (serverList) {\n\t\t\t\tpause = flag;\n\t\t\t\tif (!pause) {\n\t\t\t\t\tserverList.notify();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic void clear(EntityPlayer player) {\n\t\t\tsynchronized (serverList) {\n\t\t\t\tserverList.remove(player);\n\t\t\t}\n\t\t\tsynchronized (playersToClear) {\n\t\t\t\tplayersToClear.add(player);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate class ServerDecompressorThread extends Thread {\n\n\t\t//Map of Player to received compressed C->S data\n\t\tprivate final HashMap<EntityPlayer, LinkedList<byte[]>> queue = new HashMap<>();\n\t\t//Map of Player to decompressed serialized C->S data\n\t\tprivate final HashMap<EntityPlayer, byte[]> ByteBuffer = new HashMap<>();\n\t\t//FIFO for deserialized C->S packets, decompressor adds, tickEnd removes\n\t\tprivate final LinkedList<Pair<EntityPlayer, byte[]>> PacketBuffer = new LinkedList<>();\n\t\tprivate final ReentrantLock packetBufferLock = new ReentrantLock();\n\t\t//Clear content on next tick\n\t\tprivate Queue<EntityPlayer> playersToClear = new LinkedList<>();\n\n\t\tpublic ServerDecompressorThread() {\n\t\t\tsuper(\"LogisticsPipes Packet Decompressor Server\");\n\t\t\tsetDaemon(true);\n\t\t\tstart();\n\t\t}\n\n\t\tprivate void handlePacketData(final Pair<EntityPlayer, byte[]> playerDataPair) {\n\t\t\tLPDataIOWrapper.provideData(playerDataPair.getValue2(), input -> {\n\t\t\t\tPacketHandler.onPacketData(input, playerDataPair.getValue1());\n\t\t\t});\n\t\t}\n\n\t\tpublic void serverTickEnd() {\n\t\t\tPair<EntityPlayer, byte[]> part = null;\n\t\t\twhile (true) {\n\t\t\t\tpacketBufferLock.lock();\n\t\t\t\ttry {\n\t\t\t\t\tif (PacketBuffer.size() > 0) {\n\t\t\t\t\t\tpart = PacketBuffer.pop();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tpacketBufferLock.unlock();\n\t\t\t\t}\n\n\t\t\t\tif (part == null) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\thandlePacketData(part);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\twhile (true) {\n\t\t\t\tboolean flag = false;\n\t\t\t\tdo {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbyte[] buffer = null;\n\t\t\t\t\tEntityPlayer player = null;\n\t\t\t\t\tsynchronized (queue) {\n\t\t\t\t\t\tif (queue.size() > 0) {\n\t\t\t\t\t\t\tfor (Iterator<Entry<EntityPlayer, LinkedList<byte[]>>> it = queue.entrySet().iterator(); it.hasNext();) {\n\t\t\t\t\t\t\t\tEntry<EntityPlayer, LinkedList<byte[]>> lPlayer = it.next();\n\t\t\t\t\t\t\t\tif (lPlayer.getValue().size() > 0) {\n\t\t\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\t\t\tbuffer = lPlayer.getValue().getFirst();\n\t\t\t\t\t\t\t\t\tplayer = lPlayer.getKey();\n\t\t\t\t\t\t\t\t\tif (lPlayer.getValue().size() > 1) {\n\t\t\t\t\t\t\t\t\t\tlPlayer.getValue().removeFirst();\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tit.remove();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tit.remove();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (flag && buffer != null && player != null) {\n\t\t\t\t\t\tbyte[] ByteBufferForPlayer = ByteBuffer.get(player);\n\t\t\t\t\t\tif (ByteBufferForPlayer == null) {\n\t\t\t\t\t\t\tByteBufferForPlayer = new byte[] {};\n\t\t\t\t\t\t\tByteBuffer.put(player, ByteBufferForPlayer);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbyte[] packetbytes = ServerPacketBufferHandlerThread.decompress(buffer);\n\t\t\t\t\t\tbyte[] newBuffer = new byte[packetbytes.length + ByteBufferForPlayer.length];\n\t\t\t\t\t\tSystem.arraycopy(ByteBufferForPlayer, 0, newBuffer, 0, ByteBufferForPlayer.length);\n\t\t\t\t\t\tSystem.arraycopy(packetbytes, 0, newBuffer, ByteBufferForPlayer.length, packetbytes.length);\n\t\t\t\t\t\tByteBuffer.put(player, newBuffer);\n\t\t\t\t\t}\n\t\t\t\t} while (flag);\n\n\t\t\t\tfor (Entry<EntityPlayer, byte[]> player : ByteBuffer.entrySet()) {\n\t\t\t\t\twhile (player.getValue().length >= 4) {\n\t\t\t\t\t\tbyte[] ByteBufferForPlayer = player.getValue();\n\t\t\t\t\t\tint size = ((ByteBufferForPlayer[0] & 255) << 24) + ((ByteBufferForPlayer[1] & 255) << 16) + ((ByteBufferForPlayer[2] & 255) << 8) + ((ByteBufferForPlayer[3] & 255) << 0);\n\t\t\t\t\t\tif (size + 4 > ByteBufferForPlayer.length) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbyte[] packet = Arrays.copyOfRange(ByteBufferForPlayer, 4, size + 4);\n\t\t\t\t\t\tByteBufferForPlayer = Arrays.copyOfRange(ByteBufferForPlayer, size + 4, ByteBufferForPlayer.length);\n\t\t\t\t\t\tplayer.setValue(ByteBufferForPlayer);\n\t\t\t\t\t\tpacketBufferLock.lock();\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tPacketBuffer.add(new Pair<>(player.getKey(), packet));\n\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\tpacketBufferLock.unlock();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (Iterator<byte[]> it = ByteBuffer.values().iterator(); it.hasNext();) {\n\t\t\t\t\tbyte[] ByteBufferForPlayer = it.next();\n\t\t\t\t\tif (ByteBufferForPlayer.length == 0) {\n\t\t\t\t\t\tit.remove();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tsynchronized (queue) {\n\t\t\t\t\twhile (queue.size() == 0) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tqueue.wait();\n\t\t\t\t\t\t} catch (InterruptedException ignored) { }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsynchronized (playersToClear) {\n\t\t\t\t\tEntityPlayer player = null;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tplayer = playersToClear.poll();\n\t\t\t\t\t\tif (player != null) {\n\t\t\t\t\t\t\tByteBuffer.remove(player);\n\t\t\t\t\t\t}\n\t\t\t\t\t} while (player != null);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic void handlePacket(byte[] content, EntityPlayer player) {\n\t\t\tsynchronized (queue) {\n\t\t\t\tLinkedList<byte[]> list = queue.get(player);\n\t\t\t\tif (list == null) {\n\t\t\t\t\tlist = new LinkedList<>();\n\t\t\t\t\tqueue.put(player, list);\n\t\t\t\t}\n\t\t\t\tlist.addLast(content);\n\t\t\t\tqueue.notify();\n\t\t\t}\n\t\t}\n\n\t\tpublic void clear(EntityPlayer player) {\n\t\t\tsynchronized (queue) {\n\t\t\t\tqueue.remove(player);\n\t\t\t}\n\t\t\tsynchronized (playersToClear) {\n\t\t\t\tplayersToClear.add(player);\n\t\t\t}\n\t\t}\n\t}\n}\n",
    "patch": "@@ -26,6 +26,67 @@\n \n public class ServerPacketBufferHandlerThread {\n \n+\tprivate final ServerCompressorThread serverCompressorThread = new ServerCompressorThread();\n+\tprivate final ServerDecompressorThread serverDecompressorThread = new ServerDecompressorThread();\n+\n+\tpublic ServerPacketBufferHandlerThread() {}\n+\n+\tprivate static byte[] compress(byte[] content) {\n+\t\tByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n+\t\ttry {\n+\t\t\tGZIPOutputStream gzipOutputStream = new GZIPOutputStream(byteArrayOutputStream);\n+\t\t\tgzipOutputStream.write(content);\n+\t\t\tgzipOutputStream.close();\n+\t\t} catch (IOException e) {\n+\t\t\tthrow new RuntimeException(e);\n+\t\t}\n+\t\treturn byteArrayOutputStream.toByteArray();\n+\t}\n+\n+\tprivate static byte[] decompress(byte[] contentBytes) {\n+\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n+\t\ttry {\n+\t\t\tGZIPInputStream gzip = new GZIPInputStream(new ByteArrayInputStream(contentBytes));\n+\t\t\tint buffer = 0;\n+\t\t\twhile ((buffer = gzip.read()) != -1) {\n+\t\t\t\tout.write(buffer);\n+\t\t\t}\n+\t\t} catch (IOException e) {\n+\t\t\tthrow new RuntimeException(e);\n+\t\t}\n+\t\treturn out.toByteArray();\n+\t}\n+\n+\tpublic void serverTick(ServerTickEvent event) {\n+\t\tif (event.phase != Phase.END) {\n+\t\t\treturn;\n+\t\t}\n+\t\tserverDecompressorThread.serverTickEnd();\n+\t}\n+\n+\tpublic void setPause(boolean flag) {\n+\t\tserverCompressorThread.setPause(flag);\n+\t}\n+\n+\tpublic void addPacketToCompressor(ModernPacket packet, EntityPlayer player) {\n+\t\tserverCompressorThread.addPacketToCompressor(packet, player);\n+\t}\n+\n+\tpublic void handlePacket(byte[] content, EntityPlayer player) {\n+\t\tserverDecompressorThread.handlePacket(content, player);\n+\t}\n+\n+\tpublic void clear(final EntityPlayer player) {\n+\t\tnew Thread() {\n+\n+\t\t\t@Override\n+\t\t\tpublic void run() {\n+\t\t\t\tserverCompressorThread.clear(player);\n+\t\t\t\tserverDecompressorThread.clear(player);\n+\t\t\t}\n+\t\t}.start();\n+\t}\n+\n \tprivate class ServerCompressorThread extends Thread {\n \n \t\t//Map of Players to lists of S->C packets to be serialized and compressed\n@@ -46,53 +107,49 @@ public ServerCompressorThread() {\n \t\t@Override\n \t\tpublic void run() {\n \t\t\twhile (true) {\n-\t\t\t\ttry {\n-\t\t\t\t\tsynchronized (serverList) {\n-\t\t\t\t\t\tif (!pause) {\n-\t\t\t\t\t\t\tfor (Entry<EntityPlayer, LinkedList<ModernPacket>> playerPacketEntry : serverList.entrySet()) {\n-\t\t\t\t\t\t\t\tEntityPlayer player = playerPacketEntry.getKey();\n-\t\t\t\t\t\t\t\tserverBuffer.put(player, LPDataIOWrapper.collectData(output -> {\n-\t\t\t\t\t\t\t\t\tif (serverBuffer.containsKey(player)) {\n-\t\t\t\t\t\t\t\t\t\toutput.writeBytes(serverBuffer.get(player));\n-\t\t\t\t\t\t\t\t\t}\n+\t\t\t\tsynchronized (serverList) {\n+\t\t\t\t\tif (!pause) {\n+\t\t\t\t\t\tfor (Entry<EntityPlayer, LinkedList<ModernPacket>> playerPacketEntry : serverList.entrySet()) {\n+\t\t\t\t\t\t\tEntityPlayer player = playerPacketEntry.getKey();\n+\t\t\t\t\t\t\tserverBuffer.put(player, LPDataIOWrapper.collectData(output -> {\n+\t\t\t\t\t\t\t\tif (serverBuffer.containsKey(player)) {\n+\t\t\t\t\t\t\t\t\toutput.writeBytes(serverBuffer.get(player));\n+\t\t\t\t\t\t\t\t}\n \n-\t\t\t\t\t\t\t\t\tLinkedList<ModernPacket> packets = playerPacketEntry.getValue();\n-\t\t\t\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\t\t\t\tfor (ModernPacket packet : packets) {\n-\t\t\t\t\t\t\t\t\t\t\toutput.writeShort(packet.getId());\n-\t\t\t\t\t\t\t\t\t\t\toutput.writeInt(packet.getDebugId());\n-\t\t\t\t\t\t\t\t\t\t\tpacket.writeData(output);\n-\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t} finally {\n-\t\t\t\t\t\t\t\t\t\tpackets.clear();\n+\t\t\t\t\t\t\t\tLinkedList<ModernPacket> packets = playerPacketEntry.getValue();\n+\t\t\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\t\t\tfor (ModernPacket packet : packets) {\n+\t\t\t\t\t\t\t\t\t\toutput.writeShort(packet.getId());\n+\t\t\t\t\t\t\t\t\t\toutput.writeInt(packet.getDebugId());\n+\t\t\t\t\t\t\t\t\t\tpacket.writeData(output);\n \t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t}));\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tserverList.clear();\n+\t\t\t\t\t\t\t\t} finally {\n+\t\t\t\t\t\t\t\t\tpackets.clear();\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}));\n \t\t\t\t\t\t}\n+\t\t\t\t\t\tserverList.clear();\n \t\t\t\t\t}\n-\t\t\t\t\t//Send Content\n-\t\t\t\t\tfor (Entry<EntityPlayer, byte[]> player : serverBuffer.entrySet()) {\n-\t\t\t\t\t\twhile (player.getValue().length > 32 * 1024) {\n-\t\t\t\t\t\t\tbyte[] sendbuffer = Arrays.copyOf(player.getValue(), 1024 * 32);\n-\t\t\t\t\t\t\tbyte[] newbuffer = Arrays.copyOfRange(player.getValue(), 1024 * 32, player.getValue().length);\n-\t\t\t\t\t\t\tplayer.setValue(newbuffer);\n-\t\t\t\t\t\t\tbyte[] compressed = ServerPacketBufferHandlerThread.compress(sendbuffer);\n-\t\t\t\t\t\t\tMainProxy.sendPacketToPlayer(PacketHandler.getPacket(BufferTransfer.class).setContent(compressed), player.getKey());\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tbyte[] sendbuffer = player.getValue();\n+\t\t\t\t}\n+\t\t\t\t//Send Content\n+\t\t\t\tfor (Entry<EntityPlayer, byte[]> player : serverBuffer.entrySet()) {\n+\t\t\t\t\twhile (player.getValue().length > 32 * 1024) {\n+\t\t\t\t\t\tbyte[] sendbuffer = Arrays.copyOf(player.getValue(), 1024 * 32);\n+\t\t\t\t\t\tbyte[] newbuffer = Arrays.copyOfRange(player.getValue(), 1024 * 32, player.getValue().length);\n+\t\t\t\t\t\tplayer.setValue(newbuffer);\n \t\t\t\t\t\tbyte[] compressed = ServerPacketBufferHandlerThread.compress(sendbuffer);\n \t\t\t\t\t\tMainProxy.sendPacketToPlayer(PacketHandler.getPacket(BufferTransfer.class).setContent(compressed), player.getKey());\n \t\t\t\t\t}\n-\t\t\t\t} catch (IOException e) {\n-\t\t\t\t\te.printStackTrace();\n+\t\t\t\t\tbyte[] sendbuffer = player.getValue();\n+\t\t\t\t\tbyte[] compressed = ServerPacketBufferHandlerThread.compress(sendbuffer);\n+\t\t\t\t\tMainProxy.sendPacketToPlayer(PacketHandler.getPacket(BufferTransfer.class).setContent(compressed), player.getKey());\n \t\t\t\t}\n \t\t\t\tserverBuffer.clear();\n \t\t\t\tsynchronized (serverList) {\n \t\t\t\t\twhile (pause || serverList.size() == 0) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tserverList.wait();\n-\t\t\t\t\t\t} catch (InterruptedException e) {}\n+\t\t\t\t\t\t} catch (InterruptedException ignored) { }\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tsynchronized (playersToClear) {\n@@ -140,8 +197,6 @@ public void clear(EntityPlayer player) {\n \t\t}\n \t}\n \n-\tprivate final ServerCompressorThread serverCompressorThread = new ServerCompressorThread();\n-\n \tprivate class ServerDecompressorThread extends Thread {\n \n \t\t//Map of Player to received compressed C->S data\n@@ -161,14 +216,9 @@ public ServerDecompressorThread() {\n \t\t}\n \n \t\tprivate void handlePacketData(final Pair<EntityPlayer, byte[]> playerDataPair) {\n-\t\t\ttry {\n-\t\t\t\tLPDataIOWrapper.provideData(playerDataPair.getValue2(), input -> {\n-\t\t\t\t\tPacketHandler.onPacketData(input, playerDataPair.getValue1());\n-\t\t\t\t});\n-\t\t\t} catch (IOException e) {\n-\t\t\t\tSystem.err.println(\"IO Error in handlePacketData for player \" + playerDataPair.getValue1().getCommandSenderName());\n-\t\t\t\te.printStackTrace();\n-\t\t\t}\n+\t\t\tLPDataIOWrapper.provideData(playerDataPair.getValue2(), input -> {\n+\t\t\t\tPacketHandler.onPacketData(input, playerDataPair.getValue1());\n+\t\t\t});\n \t\t}\n \n \t\tpublic void serverTickEnd() {\n@@ -262,7 +312,7 @@ public void run() {\n \t\t\t\t\twhile (queue.size() == 0) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tqueue.wait();\n-\t\t\t\t\t\t} catch (InterruptedException e) {}\n+\t\t\t\t\t\t} catch (InterruptedException ignored) { }\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tsynchronized (playersToClear) {\n@@ -298,64 +348,4 @@ public void clear(EntityPlayer player) {\n \t\t\t}\n \t\t}\n \t}\n-\n-\tprivate final ServerDecompressorThread serverDecompressorThread = new ServerDecompressorThread();\n-\n-\tpublic ServerPacketBufferHandlerThread() {}\n-\n-\tpublic void serverTick(ServerTickEvent event) {\n-\t\tif (event.phase != Phase.END) {\n-\t\t\treturn;\n-\t\t}\n-\t\tserverDecompressorThread.serverTickEnd();\n-\t}\n-\n-\tpublic void setPause(boolean flag) {\n-\t\tserverCompressorThread.setPause(flag);\n-\t}\n-\n-\tpublic void addPacketToCompressor(ModernPacket packet, EntityPlayer player) {\n-\t\tserverCompressorThread.addPacketToCompressor(packet, player);\n-\t}\n-\n-\tpublic void handlePacket(byte[] content, EntityPlayer player) {\n-\t\tserverDecompressorThread.handlePacket(content, player);\n-\t}\n-\n-\tprivate static byte[] compress(byte[] content) {\n-\t\tByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n-\t\ttry {\n-\t\t\tGZIPOutputStream gzipOutputStream = new GZIPOutputStream(byteArrayOutputStream);\n-\t\t\tgzipOutputStream.write(content);\n-\t\t\tgzipOutputStream.close();\n-\t\t} catch (IOException e) {\n-\t\t\tthrow new RuntimeException(e);\n-\t\t}\n-\t\treturn byteArrayOutputStream.toByteArray();\n-\t}\n-\n-\tprivate static byte[] decompress(byte[] contentBytes) {\n-\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n-\t\ttry {\n-\t\t\tGZIPInputStream gzip = new GZIPInputStream(new ByteArrayInputStream(contentBytes));\n-\t\t\tint buffer = 0;\n-\t\t\twhile ((buffer = gzip.read()) != -1) {\n-\t\t\t\tout.write(buffer);\n-\t\t\t}\n-\t\t} catch (IOException e) {\n-\t\t\tthrow new RuntimeException(e);\n-\t\t}\n-\t\treturn out.toByteArray();\n-\t}\n-\n-\tpublic void clear(final EntityPlayer player) {\n-\t\tnew Thread() {\n-\n-\t\t\t@Override\n-\t\t\tpublic void run() {\n-\t\t\t\tserverCompressorThread.clear(player);\n-\t\t\t\tserverDecompressorThread.clear(player);\n-\t\t\t}\n-\t\t}.start();\n-\t}\n }",
    "function_modified_lines": {
      "added": [],
      "deleted": [
        "\n",
        "\tprivate final ServerDecompressorThread serverDecompressorThread = new ServerDecompressorThread();\n",
        "\n",
        "\tpublic ServerPacketBufferHandlerThread() {}\n",
        "\n",
        "\tpublic void serverTick(ServerTickEvent event) {\n",
        "\t\tif (event.phase != Phase.END) {\n",
        "\t\t\treturn;\n",
        "\t\t}\n",
        "\t\tserverDecompressorThread.serverTickEnd();\n",
        "\t}\n",
        "\n",
        "\tpublic void setPause(boolean flag) {\n",
        "\t\tserverCompressorThread.setPause(flag);\n",
        "\t}\n",
        "\n",
        "\tpublic void addPacketToCompressor(ModernPacket packet, EntityPlayer player) {\n",
        "\t\tserverCompressorThread.addPacketToCompressor(packet, player);\n",
        "\t}\n",
        "\n",
        "\tpublic void handlePacket(byte[] content, EntityPlayer player) {\n",
        "\t\tserverDecompressorThread.handlePacket(content, player);\n",
        "\t}\n",
        "\n",
        "\tprivate static byte[] compress(byte[] content) {\n",
        "\t\tByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n",
        "\t\ttry {\n",
        "\t\t\tGZIPOutputStream gzipOutputStream = new GZIPOutputStream(byteArrayOutputStream);\n",
        "\t\t\tgzipOutputStream.write(content);\n",
        "\t\t\tgzipOutputStream.close();\n",
        "\t\t} catch (IOException e) {\n",
        "\t\t\tthrow new RuntimeException(e);\n",
        "\t\t}\n",
        "\t\treturn byteArrayOutputStream.toByteArray();\n",
        "\t}\n",
        "\n",
        "\tprivate static byte[] decompress(byte[] contentBytes) {\n",
        "\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n",
        "\t\ttry {\n",
        "\t\t\tGZIPInputStream gzip = new GZIPInputStream(new ByteArrayInputStream(contentBytes));\n",
        "\t\t\tint buffer = 0;\n",
        "\t\t\twhile ((buffer = gzip.read()) != -1) {\n",
        "\t\t\t\tout.write(buffer);\n",
        "\t\t\t}\n",
        "\t\t} catch (IOException e) {\n",
        "\t\t\tthrow new RuntimeException(e);\n",
        "\t\t}\n",
        "\t\treturn out.toByteArray();\n",
        "\t}\n",
        "\n",
        "\tpublic void clear(final EntityPlayer player) {\n",
        "\t\tnew Thread() {\n",
        "\n",
        "\t\t\t@Override\n",
        "\t\t\tpublic void run() {\n",
        "\t\t\t\tserverCompressorThread.clear(player);\n",
        "\t\t\t\tserverDecompressorThread.clear(player);\n",
        "\t\t\t}\n",
        "\t\t}.start();\n",
        "\t}\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
    "id": 12842
  },
  {
    "cve_id": "CVE-2023-42809",
    "code_before_change": "/**\n * Copyright (c) 2013-2022 Nikita Koksharov\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.redisson.codec;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\n\nimport org.redisson.client.codec.BaseCodec;\nimport org.redisson.client.handler.State;\nimport org.redisson.client.protocol.Decoder;\nimport org.redisson.client.protocol.Encoder;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.ByteBufAllocator;\nimport io.netty.buffer.ByteBufInputStream;\nimport io.netty.buffer.ByteBufOutputStream;\n\n/**\n * JDK's serialization codec.\n * <p>\n * Fully thread-safe.*\n *\n * @author Nikita Koksharov\n *\n */\npublic class SerializationCodec extends BaseCodec {\n\n    private final Decoder<Object> decoder = new Decoder<Object>() {\n        @Override\n        public Object decode(ByteBuf buf, State state) throws IOException {\n            try {\n                //set thread context class loader to be the classLoader variable as there could be reflection\n                //done while reading from input stream which reflection will use thread class loader to load classes on demand\n                ClassLoader currentThreadClassLoader = Thread.currentThread().getContextClassLoader();\n                try {\n                    ByteBufInputStream in = new ByteBufInputStream(buf);\n                    ObjectInputStream inputStream;\n                    if (classLoader != null) {\n                        Thread.currentThread().setContextClassLoader(classLoader);\n                        inputStream = new CustomObjectInputStream(classLoader, in);\n                    } else {\n                        inputStream = new ObjectInputStream(in);\n                    }\n                    return inputStream.readObject();\n                } finally {\n                    Thread.currentThread().setContextClassLoader(currentThreadClassLoader);\n                }\n            } catch (IOException e) {\n                throw e;\n            } catch (Exception e) {\n                throw new IOException(e);\n            }\n        }\n    };\n\n    private final Encoder encoder = new Encoder() {\n\n        @Override\n        public ByteBuf encode(Object in) throws IOException {\n            ByteBuf out = ByteBufAllocator.DEFAULT.buffer();\n            try {\n                ByteBufOutputStream result = new ByteBufOutputStream(out);\n                ObjectOutputStream outputStream = new ObjectOutputStream(result);\n                outputStream.writeObject(in);\n                outputStream.close();\n                return result.buffer();\n            } catch (IOException e) {\n                out.release();\n                throw e;\n            }\n        }\n    };\n    \n    private final ClassLoader classLoader;\n\n    public SerializationCodec() {\n        this(null);\n    }\n    \n    public SerializationCodec(ClassLoader classLoader) {\n        this.classLoader = classLoader;\n    }\n\n    public SerializationCodec(ClassLoader classLoader, SerializationCodec codec) {\n        this.classLoader = classLoader;\n    }\n    \n    @Override\n    public Decoder<Object> getValueDecoder() {\n        return decoder;\n    }\n\n    @Override\n    public Encoder getValueEncoder() {\n        return encoder;\n    }\n    \n    @Override\n    public ClassLoader getClassLoader() {\n        if (classLoader != null) {\n            return classLoader;\n        }\n        return getClass().getClassLoader();\n    }\n\n}\n",
    "code_after_change": "/**\n * Copyright (c) 2013-2022 Nikita Koksharov\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.redisson.codec;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.ByteBufAllocator;\nimport io.netty.buffer.ByteBufInputStream;\nimport io.netty.buffer.ByteBufOutputStream;\nimport org.redisson.client.codec.BaseCodec;\nimport org.redisson.client.handler.State;\nimport org.redisson.client.protocol.Decoder;\nimport org.redisson.client.protocol.Encoder;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.util.Set;\n\n/**\n * JDK's serialization codec.\n * <p>\n * Fully thread-safe.*\n *\n * @author Nikita Koksharov\n *\n */\npublic class SerializationCodec extends BaseCodec {\n\n    private final Decoder<Object> decoder = new Decoder<Object>() {\n        @Override\n        public Object decode(ByteBuf buf, State state) throws IOException {\n            try {\n                //set thread context class loader to be the classLoader variable as there could be reflection\n                //done while reading from input stream which reflection will use thread class loader to load classes on demand\n                ClassLoader currentThreadClassLoader = Thread.currentThread().getContextClassLoader();\n                try {\n                    ByteBufInputStream in = new ByteBufInputStream(buf);\n                    ObjectInputStream inputStream;\n                    if (classLoader != null) {\n                        Thread.currentThread().setContextClassLoader(classLoader);\n                        inputStream = new CustomObjectInputStream(classLoader, in, allowedClasses);\n                    } else {\n                        inputStream = new ObjectInputStream(in);\n                    }\n                    return inputStream.readObject();\n                } finally {\n                    Thread.currentThread().setContextClassLoader(currentThreadClassLoader);\n                }\n            } catch (IOException e) {\n                throw e;\n            } catch (Exception e) {\n                throw new IOException(e);\n            }\n        }\n    };\n\n    private final Encoder encoder = new Encoder() {\n\n        @Override\n        public ByteBuf encode(Object in) throws IOException {\n            ByteBuf out = ByteBufAllocator.DEFAULT.buffer();\n            try {\n                ByteBufOutputStream result = new ByteBufOutputStream(out);\n                ObjectOutputStream outputStream = new ObjectOutputStream(result);\n                outputStream.writeObject(in);\n                outputStream.close();\n                return result.buffer();\n            } catch (IOException e) {\n                out.release();\n                throw e;\n            }\n        }\n    };\n\n    private Set<String> allowedClasses;\n    private final ClassLoader classLoader;\n\n    public SerializationCodec() {\n        this(null);\n    }\n    \n    public SerializationCodec(ClassLoader classLoader) {\n        this.classLoader = classLoader;\n    }\n\n    public SerializationCodec(ClassLoader classLoader, SerializationCodec codec) {\n        this.classLoader = classLoader;\n        this.allowedClasses = codec.allowedClasses;\n    }\n\n    public SerializationCodec(ClassLoader classLoader, Set<String> allowedClasses) {\n        this.classLoader = classLoader;\n        this.allowedClasses = allowedClasses;\n    }\n    \n    @Override\n    public Decoder<Object> getValueDecoder() {\n        return decoder;\n    }\n\n    @Override\n    public Encoder getValueEncoder() {\n        return encoder;\n    }\n    \n    @Override\n    public ClassLoader getClassLoader() {\n        if (classLoader != null) {\n            return classLoader;\n        }\n        return getClass().getClassLoader();\n    }\n\n}\n",
    "patch": "@@ -15,19 +15,19 @@\n  */\n package org.redisson.codec;\n \n-import java.io.IOException;\n-import java.io.ObjectInputStream;\n-import java.io.ObjectOutputStream;\n-\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.buffer.ByteBufInputStream;\n+import io.netty.buffer.ByteBufOutputStream;\n import org.redisson.client.codec.BaseCodec;\n import org.redisson.client.handler.State;\n import org.redisson.client.protocol.Decoder;\n import org.redisson.client.protocol.Encoder;\n \n-import io.netty.buffer.ByteBuf;\n-import io.netty.buffer.ByteBufAllocator;\n-import io.netty.buffer.ByteBufInputStream;\n-import io.netty.buffer.ByteBufOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.util.Set;\n \n /**\n  * JDK's serialization codec.\n@@ -51,7 +51,7 @@ public Object decode(ByteBuf buf, State state) throws IOException {\n                     ObjectInputStream inputStream;\n                     if (classLoader != null) {\n                         Thread.currentThread().setContextClassLoader(classLoader);\n-                        inputStream = new CustomObjectInputStream(classLoader, in);\n+                        inputStream = new CustomObjectInputStream(classLoader, in, allowedClasses);\n                     } else {\n                         inputStream = new ObjectInputStream(in);\n                     }\n@@ -84,7 +84,8 @@ public ByteBuf encode(Object in) throws IOException {\n             }\n         }\n     };\n-    \n+\n+    private Set<String> allowedClasses;\n     private final ClassLoader classLoader;\n \n     public SerializationCodec() {\n@@ -97,6 +98,12 @@ public SerializationCodec(ClassLoader classLoader) {\n \n     public SerializationCodec(ClassLoader classLoader, SerializationCodec codec) {\n         this.classLoader = classLoader;\n+        this.allowedClasses = codec.allowedClasses;\n+    }\n+\n+    public SerializationCodec(ClassLoader classLoader, Set<String> allowedClasses) {\n+        this.classLoader = classLoader;\n+        this.allowedClasses = allowedClasses;\n     }\n     \n     @Override",
    "function_modified_lines": {
      "added": [
        "import io.netty.buffer.ByteBuf;\n",
        "import io.netty.buffer.ByteBufAllocator;\n",
        "import io.netty.buffer.ByteBufInputStream;\n",
        "import io.netty.buffer.ByteBufOutputStream;\n",
        "import java.io.IOException;\n",
        "import java.io.ObjectInputStream;\n",
        "import java.io.ObjectOutputStream;\n",
        "import java.util.Set;\n"
      ],
      "deleted": [
        "import java.io.IOException;\n",
        "import java.io.ObjectInputStream;\n",
        "import java.io.ObjectOutputStream;\n",
        "\n",
        "import io.netty.buffer.ByteBuf;\n",
        "import io.netty.buffer.ByteBufAllocator;\n",
        "import io.netty.buffer.ByteBufInputStream;\n",
        "import io.netty.buffer.ByteBufOutputStream;\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Redisson is a Java Redis client that uses the Netty framework. Prior to version 3.22.0, some of the messages received from the Redis server contain Java objects that the client deserializes without further validation. Attackers that manage to trick clients into communicating with a malicious server can include especially crafted objects in its responses that, once deserialized by the client, force it to execute arbitrary code. This can be abused to take control of the machine the client is running in. Version 3.22.0 contains a patch for this issue.\n\nSome post-fix advice is available. Do NOT use `Kryo5Codec` as deserialization codec, as it is still vulnerable to arbitrary object deserialization due to the `setRegistrationRequired(false)` call. On the contrary, `KryoCodec` is safe to use. The fix applied to `SerializationCodec` only consists of adding an optional allowlist of class names, even though making this behavior the default is recommended. When instantiating `SerializationCodec` please use the `SerializationCodec(ClassLoader classLoader, Set<String> allowedClasses)` constructor to restrict the allowed classes for deserialization.",
    "id": 12899
  },
  {
    "cve_id": "CVE-2023-42809",
    "code_before_change": "{\n\n    private final Decoder<Object> decoder = new Decoder<Object>() {\n        @Override\n        public Object decode(ByteBuf buf, State state) throws IOException {\n            try {\n                //set thread context class loader to be the classLoader variable as there could be reflection\n                //done while reading from input stream which reflection will use thread class loader to load classes on demand\n                ClassLoader currentThreadClassLoader = Thread.currentThread().getContextClassLoader();\n                try {\n                    ByteBufInputStream in = new ByteBufInputStream(buf);\n                    ObjectInputStream inputStream;\n                    if (classLoader != null) {\n                        Thread.currentThread().setContextClassLoader(classLoader);\n                        inputStream = new CustomObjectInputStream(classLoader, in);\n                    } else {\n                        inputStream = new ObjectInputStream(in);\n                    }\n                    return inputStream.readObject();\n                } finally {\n                    Thread.currentThread().setContextClassLoader(currentThreadClassLoader);\n                }\n            } catch (IOException e) {\n                throw e;\n            } catch (Exception e) {\n                throw new IOException(e);\n            }\n        }\n    };\n\n    private final Encoder encoder = new Encoder() {\n\n        @Override\n        public ByteBuf encode(Object in) throws IOException {\n            ByteBuf out = ByteBufAllocator.DEFAULT.buffer();\n            try {\n                ByteBufOutputStream result = new ByteBufOutputStream(out);\n                ObjectOutputStream outputStream = new ObjectOutputStream(result);\n                outputStream.writeObject(in);\n                outputStream.close();\n                return result.buffer();\n            } catch (IOException e) {\n                out.release();\n                throw e;\n            }\n        }\n    };\n    \n    private final ClassLoader classLoader;\n\n    public SerializationCodec() {\n        this(null);\n    }\n    \n    public SerializationCodec(ClassLoader classLoader) {\n        this.classLoader = classLoader;\n    }\n\n    public SerializationCodec(ClassLoader classLoader, SerializationCodec codec) {\n        this.classLoader = classLoader;\n    }\n    \n    @Override\n    public Decoder<Object> getValueDecoder() {\n        return decoder;\n    }\n\n    @Override\n    public Encoder getValueEncoder() {\n        return encoder;\n    }\n    \n    @Override\n    public ClassLoader getClassLoader() {\n        if (classLoader != null) {\n            return classLoader;\n        }\n        return getClass().getClassLoader();\n    }\n\n}",
    "code_after_change": "{\n\n    private final Decoder<Object> decoder = new Decoder<Object>() {\n        @Override\n        public Object decode(ByteBuf buf, State state) throws IOException {\n            try {\n                //set thread context class loader to be the classLoader variable as there could be reflection\n                //done while reading from input stream which reflection will use thread class loader to load classes on demand\n                ClassLoader currentThreadClassLoader = Thread.currentThread().getContextClassLoader();\n                try {\n                    ByteBufInputStream in = new ByteBufInputStream(buf);\n                    ObjectInputStream inputStream;\n                    if (classLoader != null) {\n                        Thread.currentThread().setContextClassLoader(classLoader);\n                        inputStream = new CustomObjectInputStream(classLoader, in, allowedClasses);\n                    } else {\n                        inputStream = new ObjectInputStream(in);\n                    }\n                    return inputStream.readObject();\n                } finally {\n                    Thread.currentThread().setContextClassLoader(currentThreadClassLoader);\n                }\n            } catch (IOException e) {\n                throw e;\n            } catch (Exception e) {\n                throw new IOException(e);\n            }\n        }\n    };\n\n    private final Encoder encoder = new Encoder() {\n\n        @Override\n        public ByteBuf encode(Object in) throws IOException {\n            ByteBuf out = ByteBufAllocator.DEFAULT.buffer();\n            try {\n                ByteBufOutputStream result = new ByteBufOutputStream(out);\n                ObjectOutputStream outputStream = new ObjectOutputStream(result);\n                outputStream.writeObject(in);\n                outputStream.close();\n                return result.buffer();\n            } catch (IOException e) {\n                out.release();\n                throw e;\n            }\n        }\n    };\n\n    private Set<String> allowedClasses;\n    private final ClassLoader classLoader;\n\n    public SerializationCodec() {\n        this(null);\n    }\n    \n    public SerializationCodec(ClassLoader classLoader) {\n        this.classLoader = classLoader;\n    }\n\n    public SerializationCodec(ClassLoader classLoader, SerializationCodec codec) {\n        this.classLoader = classLoader;\n        this.allowedClasses = codec.allowedClasses;\n    }\n\n    public SerializationCodec(ClassLoader classLoader, Set<String> allowedClasses) {\n        this.classLoader = classLoader;\n        this.allowedClasses = allowedClasses;\n    }\n    \n    @Override\n    public Decoder<Object> getValueDecoder() {\n        return decoder;\n    }\n\n    @Override\n    public Encoder getValueEncoder() {\n        return encoder;\n    }\n    \n    @Override\n    public ClassLoader getClassLoader() {\n        if (classLoader != null) {\n            return classLoader;\n        }\n        return getClass().getClassLoader();\n    }\n\n}",
    "patch": "@@ -15,19 +15,19 @@\n  */\n package org.redisson.codec;\n \n-import java.io.IOException;\n-import java.io.ObjectInputStream;\n-import java.io.ObjectOutputStream;\n-\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.buffer.ByteBufInputStream;\n+import io.netty.buffer.ByteBufOutputStream;\n import org.redisson.client.codec.BaseCodec;\n import org.redisson.client.handler.State;\n import org.redisson.client.protocol.Decoder;\n import org.redisson.client.protocol.Encoder;\n \n-import io.netty.buffer.ByteBuf;\n-import io.netty.buffer.ByteBufAllocator;\n-import io.netty.buffer.ByteBufInputStream;\n-import io.netty.buffer.ByteBufOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.util.Set;\n \n /**\n  * JDK's serialization codec.\n@@ -51,7 +51,7 @@ public Object decode(ByteBuf buf, State state) throws IOException {\n                     ObjectInputStream inputStream;\n                     if (classLoader != null) {\n                         Thread.currentThread().setContextClassLoader(classLoader);\n-                        inputStream = new CustomObjectInputStream(classLoader, in);\n+                        inputStream = new CustomObjectInputStream(classLoader, in, allowedClasses);\n                     } else {\n                         inputStream = new ObjectInputStream(in);\n                     }\n@@ -84,7 +84,8 @@ public ByteBuf encode(Object in) throws IOException {\n             }\n         }\n     };\n-    \n+\n+    private Set<String> allowedClasses;\n     private final ClassLoader classLoader;\n \n     public SerializationCodec() {\n@@ -97,6 +98,12 @@ public SerializationCodec(ClassLoader classLoader) {\n \n     public SerializationCodec(ClassLoader classLoader, SerializationCodec codec) {\n         this.classLoader = classLoader;\n+        this.allowedClasses = codec.allowedClasses;\n+    }\n+\n+    public SerializationCodec(ClassLoader classLoader, Set<String> allowedClasses) {\n+        this.classLoader = classLoader;\n+        this.allowedClasses = allowedClasses;\n     }\n     \n     @Override",
    "function_modified_lines": {
      "added": [
        "\n",
        "    private Set<String> allowedClasses;\n",
        "        this.allowedClasses = codec.allowedClasses;\n",
        "    }\n",
        "\n",
        "    public SerializationCodec(ClassLoader classLoader, Set<String> allowedClasses) {\n",
        "        this.classLoader = classLoader;\n",
        "        this.allowedClasses = allowedClasses;\n"
      ],
      "deleted": [
        "    \n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-502"
    ],
    "cve_description": "Redisson is a Java Redis client that uses the Netty framework. Prior to version 3.22.0, some of the messages received from the Redis server contain Java objects that the client deserializes without further validation. Attackers that manage to trick clients into communicating with a malicious server can include especially crafted objects in its responses that, once deserialized by the client, force it to execute arbitrary code. This can be abused to take control of the machine the client is running in. Version 3.22.0 contains a patch for this issue.\n\nSome post-fix advice is available. Do NOT use `Kryo5Codec` as deserialization codec, as it is still vulnerable to arbitrary object deserialization due to the `setRegistrationRequired(false)` call. On the contrary, `KryoCodec` is safe to use. The fix applied to `SerializationCodec` only consists of adding an optional allowlist of class names, even though making this behavior the default is recommended. When instantiating `SerializationCodec` please use the `SerializationCodec(ClassLoader classLoader, Set<String> allowedClasses)` constructor to restrict the allowed classes for deserialization.",
    "id": 12900
  }
]