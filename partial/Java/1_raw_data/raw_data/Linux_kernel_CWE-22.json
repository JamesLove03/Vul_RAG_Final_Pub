[
  {
    "cve_id": "CVE-2023-37460",
    "code_before_change": "{\n        if (fileMappers != null) {\n            for (final FileMapper fileMapper : fileMappers) {\n                entryName = fileMapper.getMappedFileName(entryName);\n            }\n        }\n\n        // Hmm. Symlinks re-evaluate back to the original file here. Unsure if this is a good thing...\n        final File targetFileName = FileUtils.resolveFile(dir, entryName);\n\n        // Make sure that the resolved path of the extracted file doesn't escape the destination directory\n        // getCanonicalFile().toPath() is used instead of getCanonicalPath() (returns String),\n        // because \"/opt/directory\".startsWith(\"/opt/dir\") would return false negative.\n        Path canonicalDirPath = dir.getCanonicalFile().toPath();\n        Path canonicalDestPath = targetFileName.getCanonicalFile().toPath();\n\n        if (!canonicalDestPath.startsWith(canonicalDirPath)) {\n            throw new ArchiverException(\"Entry is outside of the target directory (\" + entryName + \")\");\n        }\n\n        try {\n            if (!shouldExtractEntry(dir, targetFileName, entryName, entryDate)) {\n                return;\n            }\n\n            // create intermediary directories - sometimes zip don't add them\n            final File dirF = targetFileName.getParentFile();\n            if (dirF != null) {\n                dirF.mkdirs();\n            }\n\n            if (!StringUtils.isEmpty(symlinkDestination)) {\n                SymlinkUtils.createSymbolicLink(targetFileName, new File(symlinkDestination));\n            } else if (isDirectory) {\n                targetFileName.mkdirs();\n            } else {\n                try (OutputStream out = Files.newOutputStream(targetFileName.toPath())) {\n                    IOUtil.copy(compressedInputStream, out);\n                }\n            }\n\n            targetFileName.setLastModified(entryDate.getTime());\n\n            if (!isIgnorePermissions() && mode != null && !isDirectory) {\n                ArchiveEntryUtils.chmod(targetFileName, mode);\n            }\n        } catch (final FileNotFoundException ex) {\n            getLogger().warn(\"Unable to expand to file \" + targetFileName.getPath());\n        }\n    }",
    "code_after_change": "{\n        if (fileMappers != null) {\n            for (final FileMapper fileMapper : fileMappers) {\n                entryName = fileMapper.getMappedFileName(entryName);\n            }\n        }\n\n        // Hmm. Symlinks re-evaluate back to the original file here. Unsure if this is a good thing...\n        final File targetFileName = FileUtils.resolveFile(dir, entryName);\n\n        // Make sure that the resolved path of the extracted file doesn't escape the destination directory\n        // getCanonicalFile().toPath() is used instead of getCanonicalPath() (returns String),\n        // because \"/opt/directory\".startsWith(\"/opt/dir\") would return false negative.\n        Path canonicalDirPath = dir.getCanonicalFile().toPath();\n        Path canonicalDestPath = targetFileName.getCanonicalFile().toPath();\n\n        if (!canonicalDestPath.startsWith(canonicalDirPath)) {\n            throw new ArchiverException(\"Entry is outside of the target directory (\" + entryName + \")\");\n        }\n\n        // don't allow override target symlink by standard file\n        if (StringUtils.isEmpty(symlinkDestination) && Files.isSymbolicLink(canonicalDestPath)) {\n            throw new ArchiverException(\"Entry is outside of the target directory (\" + entryName + \")\");\n        }\n\n        try {\n            if (!shouldExtractEntry(dir, targetFileName, entryName, entryDate)) {\n                return;\n            }\n\n            // create intermediary directories - sometimes zip don't add them\n            final File dirF = targetFileName.getParentFile();\n            if (dirF != null) {\n                dirF.mkdirs();\n            }\n\n            if (!StringUtils.isEmpty(symlinkDestination)) {\n                SymlinkUtils.createSymbolicLink(targetFileName, new File(symlinkDestination));\n            } else if (isDirectory) {\n                targetFileName.mkdirs();\n            } else {\n                Files.copy(compressedInputStream, targetFileName.toPath(), REPLACE_EXISTING);\n            }\n\n            targetFileName.setLastModified(entryDate.getTime());\n\n            if (!isIgnorePermissions() && mode != null && !isDirectory) {\n                ArchiveEntryUtils.chmod(targetFileName, mode);\n            }\n        } catch (final FileNotFoundException ex) {\n            getLogger().warn(\"Unable to expand to file \" + targetFileName.getPath());\n        }\n    }",
    "patch": "@@ -20,7 +20,6 @@\n import java.io.FileNotFoundException;\n import java.io.IOException;\n import java.io.InputStream;\n-import java.io.OutputStream;\n import java.nio.file.Files;\n import java.nio.file.Path;\n import java.util.ArrayList;\n@@ -35,11 +34,12 @@\n import org.codehaus.plexus.components.io.fileselectors.FileSelector;\n import org.codehaus.plexus.components.io.resources.PlexusIoResource;\n import org.codehaus.plexus.util.FileUtils;\n-import org.codehaus.plexus.util.IOUtil;\n import org.codehaus.plexus.util.StringUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n+\n // TODO there should really be constructors which take the source file.\n \n /**\n@@ -301,6 +301,11 @@ protected void extractFile(\n             throw new ArchiverException(\"Entry is outside of the target directory (\" + entryName + \")\");\n         }\n \n+        // don't allow override target symlink by standard file\n+        if (StringUtils.isEmpty(symlinkDestination) && Files.isSymbolicLink(canonicalDestPath)) {\n+            throw new ArchiverException(\"Entry is outside of the target directory (\" + entryName + \")\");\n+        }\n+\n         try {\n             if (!shouldExtractEntry(dir, targetFileName, entryName, entryDate)) {\n                 return;\n@@ -317,9 +322,7 @@ protected void extractFile(\n             } else if (isDirectory) {\n                 targetFileName.mkdirs();\n             } else {\n-                try (OutputStream out = Files.newOutputStream(targetFileName.toPath())) {\n-                    IOUtil.copy(compressedInputStream, out);\n-                }\n+                Files.copy(compressedInputStream, targetFileName.toPath(), REPLACE_EXISTING);\n             }\n \n             targetFileName.setLastModified(entryDate.getTime());",
    "function_modified_lines": {
      "added": [
        "        // don't allow override target symlink by standard file\n",
        "        if (StringUtils.isEmpty(symlinkDestination) && Files.isSymbolicLink(canonicalDestPath)) {\n",
        "            throw new ArchiverException(\"Entry is outside of the target directory (\" + entryName + \")\");\n",
        "        }\n",
        "\n",
        "                Files.copy(compressedInputStream, targetFileName.toPath(), REPLACE_EXISTING);\n"
      ],
      "deleted": [
        "                try (OutputStream out = Files.newOutputStream(targetFileName.toPath())) {\n",
        "                    IOUtil.copy(compressedInputStream, out);\n",
        "                }\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-22",
      "CWE-61"
    ],
    "cve_description": "Plexis Archiver is a collection of Plexus components to create archives or extract archives to a directory with a unified `Archiver`/`UnArchiver` API. Prior to version 4.8.0, using AbstractUnArchiver for extracting an archive might lead to an arbitrary file creation and possibly remote code execution. When extracting an archive with an entry that already exists in the destination directory as a symbolic link whose target does not exist - the `resolveFile()` function will return the symlink's source instead of its target, which will pass the verification that ensures the file will not be extracted outside of the destination directory. Later `Files.newOutputStream()`, that follows symlinks by default,  will actually write the entry's content to the symlink's target. Whoever uses plexus archiver to extract an untrusted archive is vulnerable to an arbitrary file creation and possibly remote code execution. Version 4.8.0 contains a patch for this issue.",
    "id": 12091
  },
  {
    "cve_id": "CVE-2018-14371",
    "code_before_change": "                if (clazz == null) {\n                    clazz = loadClass(className, this);\n                }\n                if (clazz != ComponentResourceClassNotFound.class) {\n                    if (!associate.isDevModeEnabled()) {\n                        componentMap.put(className, clazz);\n                    }\n                    result = (UIComponent) clazz.newInstance();\n                }\n            } catch (ClassNotFoundException ex) {\n                if (!associate.isDevModeEnabled()) {\n                    componentMap.put(className, ComponentResourceClassNotFound.class);\n                }\n            } catch (InstantiationException | IllegalAccessException | ClassCastException ie) {\n                throw new FacesException(ie);\n            }\n        }\n\n        // Step 4. Use javax.faces.NamingContainer as the component type\n        if (result == null) {\n            result = app.createComponent(\"javax.faces.NamingContainer\");\n        }\n\n        result.setRendererType(\"javax.faces.Composite\");\n\n        Map<String, Object> attrs = result.getAttributes();\n        attrs.put(COMPONENT_RESOURCE_KEY, componentResource);\n        attrs.put(BEANINFO_KEY, componentMetadata);\n\n        associate.getAnnotationManager().applyComponentAnnotations(context, result);\n        pushDeclaredDefaultValuesToAttributesMap(context, componentMetadata, attrs, result, expressionFactory);\n\n        return result;\n    }\n    \n    public UIComponent createComponent(FacesContext context, String componentType, String rendererType) {\n        return createComponentApplyAnnotations(context, componentType, rendererType, true);\n    }\n    \n    public UIComponent createComponent(ValueExpression componentExpression, FacesContext context, String componentType, String rendererType) {\n\n        notNull(COMPONENT_EXPRESSION, componentExpression);\n        notNull(CONTEXT, context);\n        notNull(COMPONENT_TYPE, componentType);\n\n        return createComponentApplyAnnotations(context, componentExpression, componentType, rendererType, true);\n    }\n    \n    public UIComponent createComponent(ValueBinding componentBinding, FacesContext context, String componentType) throws FacesException {\n\n        notNull(\"componentBinding\", componentBinding);\n        notNull(CONTEXT, context);\n        notNull(COMPONENT_TYPE, componentType);\n\n        Object result;\n        boolean createOne = false;\n        try {\n            result = componentBinding.getValue(context);\n            if (result != null) {\n                createOne = !(result instanceof UIComponent);\n            }\n\n            if (result == null || createOne) {\n                result = createComponentApplyAnnotations(context, componentType, null, false);\n                componentBinding.setValue(context, result);\n            }\n        } catch (Exception ex) {\n            throw new FacesException(ex);\n        }\n\n        return (UIComponent) result;\n    }\n    \n    /**",
    "code_after_change": "{\n        \n        notNull(CONTEXT, context);\n        notNull(COMPONENT_TYPE, componentType);\n        \n        return createComponentApplyAnnotations(context, componentType, rendererType, true);\n    }",
    "patch": "@@ -288,6 +288,10 @@ public UIComponent createComponent(FacesContext context, Resource componentResou\n     }\n     \n     public UIComponent createComponent(FacesContext context, String componentType, String rendererType) {\n+        \n+        notNull(CONTEXT, context);\n+        notNull(COMPONENT_TYPE, componentType);\n+        \n         return createComponentApplyAnnotations(context, componentType, rendererType, true);\n     }\n     ",
    "function_modified_lines": {
      "added": [
        "        \n",
        "        notNull(CONTEXT, context);\n",
        "        notNull(COMPONENT_TYPE, componentType);\n",
        "        \n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "The getLocalePrefix function in ResourceManager.java in Eclipse Mojarra before 2.3.7 is affected by Directory Traversal via the loc parameter. A remote attacker can download configuration files or Java bytecodes from applications.",
    "id": 12092
  },
  {
    "cve_id": "CVE-2018-9159",
    "code_before_change": "{\n\n    private final String path;\n\n    private ClassLoader classLoader;\n\n    private Class<?> clazz;\n\n\n    /**\n     * Create a new ClassPathResource for ClassLoader usage.\n     * A leading slash will be removed, as the ClassLoader\n     * resource access methods will not accept it.\n     * <p>The thread context class loader will be used for\n     * loading the resource.\n     *\n     * @param path the absolute path within the class path\n     * @see java.lang.ClassLoader#getResourceAsStream(String)\n     * @see spark.utils.ClassUtils#getDefaultClassLoader()\n     */\n    public ClassPathResource(String path) {\n        this(path, null);\n    }\n\n    /**\n     * Create a new ClassPathResource for ClassLoader usage.\n     * A leading slash will be removed, as the ClassLoader\n     * resource access methods will not accept it.\n     *\n     * @param path        the absolute path within the classpath\n     * @param classLoader the class loader to load the resource with,\n     *                    or {@code null} for the thread context class loader\n     * @see ClassLoader#getResourceAsStream(String)\n     */\n    public ClassPathResource(String path, ClassLoader classLoader) {\n        Assert.notNull(path, \"Path must not be null\");\n        Assert.state(doesNotContainFileColon(path), \"Path must not contain 'file:'\");\n\n        String pathToUse = StringUtils.cleanPath(path);\n\n        if (pathToUse.startsWith(\"/\")) {\n            pathToUse = pathToUse.substring(1);\n        }\n\n        this.path = pathToUse;\n        this.classLoader = (classLoader != null ? classLoader : ClassUtils.getDefaultClassLoader());\n    }\n\n    private static boolean doesNotContainFileColon(String path) {\n        return !path.contains(\"file:\");\n    }\n\n    /**\n     * Create a new ClassPathResource with optional ClassLoader and Class.\n     * Only for internal usage.\n     *\n     * @param path        relative or absolute path within the classpath\n     * @param classLoader the class loader to load the resource with, if any\n     * @param clazz       the class to load resources with, if any\n     */\n    protected ClassPathResource(String path, ClassLoader classLoader, Class<?> clazz) {\n        this.path = StringUtils.cleanPath(path);\n        this.classLoader = classLoader;\n        this.clazz = clazz;\n    }\n\n    /**\n     * Return the path for this resource (as resource path within the class path).\n     *\n     * @return the path\n     */\n    public final String getPath() {\n        return this.path;\n    }\n\n    /**\n     * This implementation checks for the resolution of a resource URL.\n     *\n     * @return if exists.\n     * @see java.lang.ClassLoader#getResource(String)\n     * @see java.lang.Class#getResource(String)\n     */\n    @Override\n    public boolean exists() {\n        URL url;\n        if (this.clazz != null) {\n            url = this.clazz.getResource(this.path);\n        } else {\n            url = this.classLoader.getResource(this.path);\n        }\n        return (url != null);\n    }\n\n    /**\n     * This implementation opens an InputStream for the given class path resource.\n     *\n     * @return the input stream.\n     * @see java.lang.ClassLoader#getResourceAsStream(String)\n     * @see java.lang.Class#getResourceAsStream(String)\n     */\n    @Override\n    public InputStream getInputStream() throws IOException {\n        InputStream is;\n        if (this.clazz != null) {\n            is = this.clazz.getResourceAsStream(this.path);\n        } else {\n            is = this.classLoader.getResourceAsStream(this.path);\n        }\n        if (is == null) {\n            throw new FileNotFoundException(getDescription() + \" cannot be opened because it does not exist\");\n        }\n        return is;\n    }\n\n    /**\n     * This implementation returns a URL for the underlying class path resource.\n     *\n     * @return the url.\n     * @see java.lang.ClassLoader#getResource(String)\n     * @see java.lang.Class#getResource(String)\n     */\n    @Override\n    public URL getURL() throws IOException {\n        URL url;\n        if (this.clazz != null) {\n            url = this.clazz.getResource(this.path);\n        } else {\n            url = this.classLoader.getResource(this.path);\n        }\n        if (url == null) {\n            throw new FileNotFoundException(getDescription() + \" cannot be resolved to URL because it does not exist\");\n        }\n        return url;\n    }\n\n    /**\n     * This implementation creates a ClassPathResource, applying the given path\n     * relative to the path of the underlying resource of this descriptor.\n     *\n     * @return the resource.\n     * @see spark.utils.StringUtils#applyRelativePath(String, String)\n     */\n    @Override\n    public Resource createRelative(String relativePath) {\n        String pathToUse = StringUtils.applyRelativePath(this.path, relativePath);\n        return new ClassPathResource(pathToUse, this.classLoader, this.clazz);\n    }\n\n    /**\n     * This implementation returns the name of the file that this class path\n     * resource refers to.\n     *\n     * @return the file name.\n     * @see spark.utils.StringUtils#getFilename(String)\n     */\n    @Override\n    public String getFilename() {\n        return StringUtils.getFilename(this.path);\n    }\n\n    /**\n     * This implementation returns a description that includes the class path location.\n     *\n     * @return the description.\n     */\n    @Override\n    public String getDescription() {\n        StringBuilder builder = new StringBuilder(\"class path resource [\");\n        String pathToUse = path;\n        if (this.clazz != null && !pathToUse.startsWith(\"/\")) {\n            builder.append(ClassUtils.classPackageAsResourcePath(this.clazz));\n            builder.append('/');\n        }\n        if (pathToUse.startsWith(\"/\")) {\n            pathToUse = pathToUse.substring(1);\n        }\n        builder.append(pathToUse);\n        builder.append(']');\n        return builder.toString();\n    }\n\n    /**\n     * This implementation compares the underlying class path locations.\n     *\n     * @return if equals.\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (obj instanceof ClassPathResource) {\n            ClassPathResource otherRes = (ClassPathResource) obj;\n\n            ClassLoader thisLoader = this.classLoader;\n            ClassLoader otherLoader = otherRes.classLoader;\n\n            return (this.path.equals(otherRes.path) &&\n                thisLoader.equals(otherLoader) &&\n                this.clazz.equals(otherRes.clazz));\n        }\n        return false;\n    }\n\n    /**\n     * This implementation returns the hash code of the underlying\n     * class path location.\n     *\n     * @return the hash code.\n     */\n    @Override\n    public int hashCode() {\n        return this.path.hashCode();\n    }\n\n}",
    "code_after_change": "{\n\n    private final String path;\n\n    private ClassLoader classLoader;\n\n    private Class<?> clazz;\n\n\n    /**\n     * Create a new ClassPathResource for ClassLoader usage.\n     * A leading slash will be removed, as the ClassLoader\n     * resource access methods will not accept it.\n     * <p>The thread context class loader will be used for\n     * loading the resource.\n     *\n     * @param path the absolute path within the class path\n     * @see java.lang.ClassLoader#getResourceAsStream(String)\n     * @see spark.utils.ClassUtils#getDefaultClassLoader()\n     */\n    public ClassPathResource(String path) {\n        this(path, null);\n    }\n\n    /**\n     * Create a new ClassPathResource for ClassLoader usage.\n     * A leading slash will be removed, as the ClassLoader\n     * resource access methods will not accept it.\n     *\n     * @param path        the absolute path within the classpath\n     * @param classLoader the class loader to load the resource with,\n     *                    or {@code null} for the thread context class loader\n     * @see ClassLoader#getResourceAsStream(String)\n     */\n    public ClassPathResource(String path, ClassLoader classLoader) {\n        Assert.notNull(path, \"Path must not be null\");\n        Assert.isTrue(isValid(path), \"Path is not valid\");\n\n        String pathToUse = StringUtils.cleanPath(path);\n\n        if (pathToUse.startsWith(\"/\")) {\n            pathToUse = pathToUse.substring(1);\n        }\n\n        this.path = pathToUse;\n        this.classLoader = (classLoader != null ? classLoader : ClassUtils.getDefaultClassLoader());\n    }\n\n    private static boolean isValid(final String path) {\n        return !isInvalidPath(path);\n    }\n\n    private static boolean isInvalidPath(String path) {\n        if (path.contains(\"WEB-INF\") || path.contains(\"META-INF\")) {\n            return true;\n        }\n        if (path.contains(\":/\")) {\n            String relativePath = (path.charAt(0) == '/' ? path.substring(1) : path);\n            if (ResourceUtils.isUrl(relativePath) || relativePath.startsWith(\"url:\")) {\n                return true;\n            }\n        }\n        if (path.contains(\"\")) {\n            path = StringUtils.cleanPath(path);\n            if (path.contains(\"../\")) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Create a new ClassPathResource with optional ClassLoader and Class.\n     * Only for internal usage.\n     *\n     * @param path        relative or absolute path within the classpath\n     * @param classLoader the class loader to load the resource with, if any\n     * @param clazz       the class to load resources with, if any\n     */\n    protected ClassPathResource(String path, ClassLoader classLoader, Class<?> clazz) {\n        this.path = StringUtils.cleanPath(path);\n        this.classLoader = classLoader;\n        this.clazz = clazz;\n    }\n\n    /**\n     * Return the path for this resource (as resource path within the class path).\n     *\n     * @return the path\n     */\n    public final String getPath() {\n        return this.path;\n    }\n\n    /**\n     * This implementation checks for the resolution of a resource URL.\n     *\n     * @return if exists.\n     * @see java.lang.ClassLoader#getResource(String)\n     * @see java.lang.Class#getResource(String)\n     */\n    @Override\n    public boolean exists() {\n        URL url;\n        if (this.clazz != null) {\n            url = this.clazz.getResource(this.path);\n        } else {\n            url = this.classLoader.getResource(this.path);\n        }\n        return (url != null);\n    }\n\n    /**\n     * This implementation opens an InputStream for the given class path resource.\n     *\n     * @return the input stream.\n     * @see java.lang.ClassLoader#getResourceAsStream(String)\n     * @see java.lang.Class#getResourceAsStream(String)\n     */\n    @Override\n    public InputStream getInputStream() throws IOException {\n        InputStream is;\n        if (this.clazz != null) {\n            is = this.clazz.getResourceAsStream(this.path);\n        } else {\n            is = this.classLoader.getResourceAsStream(this.path);\n        }\n        if (is == null) {\n            throw new FileNotFoundException(getDescription() + \" cannot be opened because it does not exist\");\n        }\n        return is;\n    }\n\n    /**\n     * This implementation returns a URL for the underlying class path resource.\n     *\n     * @return the url.\n     * @see java.lang.ClassLoader#getResource(String)\n     * @see java.lang.Class#getResource(String)\n     */\n    @Override\n    public URL getURL() throws IOException {\n        URL url;\n        if (this.clazz != null) {\n            url = this.clazz.getResource(this.path);\n        } else {\n            url = this.classLoader.getResource(this.path);\n        }\n        if (url == null) {\n            throw new FileNotFoundException(getDescription() + \" cannot be resolved to URL because it does not exist\");\n        }\n        return url;\n    }\n\n    /**\n     * This implementation creates a ClassPathResource, applying the given path\n     * relative to the path of the underlying resource of this descriptor.\n     *\n     * @return the resource.\n     * @see spark.utils.StringUtils#applyRelativePath(String, String)\n     */\n    @Override\n    public Resource createRelative(String relativePath) {\n        String pathToUse = StringUtils.applyRelativePath(this.path, relativePath);\n        return new ClassPathResource(pathToUse, this.classLoader, this.clazz);\n    }\n\n    /**\n     * This implementation returns the name of the file that this class path\n     * resource refers to.\n     *\n     * @return the file name.\n     * @see spark.utils.StringUtils#getFilename(String)\n     */\n    @Override\n    public String getFilename() {\n        return StringUtils.getFilename(this.path);\n    }\n\n    /**\n     * This implementation returns a description that includes the class path location.\n     *\n     * @return the description.\n     */\n    @Override\n    public String getDescription() {\n        StringBuilder builder = new StringBuilder(\"class path resource [\");\n        String pathToUse = path;\n        if (this.clazz != null && !pathToUse.startsWith(\"/\")) {\n            builder.append(ClassUtils.classPackageAsResourcePath(this.clazz));\n            builder.append('/');\n        }\n        if (pathToUse.startsWith(\"/\")) {\n            pathToUse = pathToUse.substring(1);\n        }\n        builder.append(pathToUse);\n        builder.append(']');\n        return builder.toString();\n    }\n\n    /**\n     * This implementation compares the underlying class path locations.\n     *\n     * @return if equals.\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (obj instanceof ClassPathResource) {\n            ClassPathResource otherRes = (ClassPathResource) obj;\n\n            ClassLoader thisLoader = this.classLoader;\n            ClassLoader otherLoader = otherRes.classLoader;\n\n            return (this.path.equals(otherRes.path) &&\n                    thisLoader.equals(otherLoader) &&\n                    this.clazz.equals(otherRes.clazz));\n        }\n        return false;\n    }\n\n    /**\n     * This implementation returns the hash code of the underlying\n     * class path location.\n     *\n     * @return the hash code.\n     */\n    @Override\n    public int hashCode() {\n        return this.path.hashCode();\n    }\n\n}",
    "patch": "@@ -23,6 +23,7 @@\n \n import spark.utils.Assert;\n import spark.utils.ClassUtils;\n+import spark.utils.ResourceUtils;\n import spark.utils.StringUtils;\n \n /**\n@@ -74,7 +75,7 @@ public ClassPathResource(String path) {\n      */\n     public ClassPathResource(String path, ClassLoader classLoader) {\n         Assert.notNull(path, \"Path must not be null\");\n-        Assert.state(doesNotContainFileColon(path), \"Path must not contain 'file:'\");\n+        Assert.isTrue(isValid(path), \"Path is not valid\");\n \n         String pathToUse = StringUtils.cleanPath(path);\n \n@@ -86,8 +87,27 @@ public ClassPathResource(String path, ClassLoader classLoader) {\n         this.classLoader = (classLoader != null ? classLoader : ClassUtils.getDefaultClassLoader());\n     }\n \n-    private static boolean doesNotContainFileColon(String path) {\n-        return !path.contains(\"file:\");\n+    private static boolean isValid(final String path) {\n+        return !isInvalidPath(path);\n+    }\n+\n+    private static boolean isInvalidPath(String path) {\n+        if (path.contains(\"WEB-INF\") || path.contains(\"META-INF\")) {\n+            return true;\n+        }\n+        if (path.contains(\":/\")) {\n+            String relativePath = (path.charAt(0) == '/' ? path.substring(1) : path);\n+            if (ResourceUtils.isUrl(relativePath) || relativePath.startsWith(\"url:\")) {\n+                return true;\n+            }\n+        }\n+        if (path.contains(\"\")) {\n+            path = StringUtils.cleanPath(path);\n+            if (path.contains(\"../\")) {\n+                return true;\n+            }\n+        }\n+        return false;\n     }\n \n     /**\n@@ -236,8 +256,8 @@ public boolean equals(Object obj) {\n             ClassLoader otherLoader = otherRes.classLoader;\n \n             return (this.path.equals(otherRes.path) &&\n-                thisLoader.equals(otherLoader) &&\n-                this.clazz.equals(otherRes.clazz));\n+                    thisLoader.equals(otherLoader) &&\n+                    this.clazz.equals(otherRes.clazz));\n         }\n         return false;\n     }",
    "function_modified_lines": {
      "added": [
        "        Assert.isTrue(isValid(path), \"Path is not valid\");\n",
        "    private static boolean isValid(final String path) {\n",
        "        return !isInvalidPath(path);\n",
        "    }\n",
        "\n",
        "    private static boolean isInvalidPath(String path) {\n",
        "        if (path.contains(\"WEB-INF\") || path.contains(\"META-INF\")) {\n",
        "            return true;\n",
        "        }\n",
        "        if (path.contains(\":/\")) {\n",
        "            String relativePath = (path.charAt(0) == '/' ? path.substring(1) : path);\n",
        "            if (ResourceUtils.isUrl(relativePath) || relativePath.startsWith(\"url:\")) {\n",
        "                return true;\n",
        "            }\n",
        "        }\n",
        "        if (path.contains(\"\")) {\n",
        "            path = StringUtils.cleanPath(path);\n",
        "            if (path.contains(\"../\")) {\n",
        "                return true;\n",
        "            }\n",
        "        }\n",
        "        return false;\n"
      ],
      "deleted": [
        "        Assert.state(doesNotContainFileColon(path), \"Path must not contain 'file:'\");\n",
        "    private static boolean doesNotContainFileColon(String path) {\n",
        "        return !path.contains(\"file:\");\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "In Spark before 2.7.2, a remote attacker can read unintended static files via various representations of absolute or relative pathnames, as demonstrated by file: URLs and directory traversal sequences. NOTE: this product is unrelated to Ignite Realtime Spark.",
    "id": 12102
  },
  {
    "cve_id": "CVE-2018-9159",
    "code_before_change": "/*\n * Copyright 2011- Per Wendel\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage spark.examples.staticresources;\n\nimport static spark.Spark.get;\nimport static spark.Spark.staticFileLocation;\n\n/**\n * Example showing how serve static resources.\n */\npublic class StaticResources {\n\n    public static void main(String[] args) {\n\n        // Will serve all static file are under \"/public\" in classpath if the route isn't consumed by others routes.\n        staticFileLocation(\"/public\");\n\n        get(\"/hello\", (request, response) -> {\n            return \"Hello World!\";\n        });\n    }\n}\n",
    "code_after_change": "/*\n * Copyright 2011- Per Wendel\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage spark.examples.staticresources;\n\nimport static spark.Spark.get;\nimport static spark.Spark.staticFiles;\n\n/**\n * Example showing how serve static resources.\n */\npublic class StaticResources {\n\n    public static void main(String[] args) {\n\n        // Will serve all static file are under \"/public\" in classpath if the route isn't consumed by others routes.\n        staticFiles.location(\"/public\");\n\n        get(\"/hello\", (request, response) -> {\n            return \"Hello World!\";\n        });\n    }\n}\n",
    "patch": "@@ -17,7 +17,7 @@\n package spark.examples.staticresources;\n \n import static spark.Spark.get;\n-import static spark.Spark.staticFileLocation;\n+import static spark.Spark.staticFiles;\n \n /**\n  * Example showing how serve static resources.\n@@ -27,7 +27,7 @@ public class StaticResources {\n     public static void main(String[] args) {\n \n         // Will serve all static file are under \"/public\" in classpath if the route isn't consumed by others routes.\n-        staticFileLocation(\"/public\");\n+        staticFiles.location(\"/public\");\n \n         get(\"/hello\", (request, response) -> {\n             return \"Hello World!\";",
    "function_modified_lines": {
      "added": [
        "import static spark.Spark.staticFiles;\n",
        "        staticFiles.location(\"/public\");\n"
      ],
      "deleted": [
        "import static spark.Spark.staticFileLocation;\n",
        "        staticFileLocation(\"/public\");\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "In Spark before 2.7.2, a remote attacker can read unintended static files via various representations of absolute or relative pathnames, as demonstrated by file: URLs and directory traversal sequences. NOTE: this product is unrelated to Ignite Realtime Spark.",
    "id": 12103
  },
  {
    "cve_id": "CVE-2021-3856",
    "code_before_change": "{\n\n    @Override\n    public void configureTestRealm(RealmRepresentation testRealm) {\n\n    }\n\n    @Test\n    public void getTheme() {\n        testingClient.server().run(session -> {\n            try {\n                Theme theme = session.theme().getTheme(\"base\", Theme.Type.LOGIN);\n                Assert.assertNotNull(theme.getTemplate(\"test.ftl\"));\n            } catch (IOException e) {\n                Assert.fail(e.getMessage());\n            }\n        });\n    }\n\n    @Test\n    public void getResourceAsStream() {\n        testingClient.server().run(session -> {\n            try {\n                Theme theme = session.theme().getTheme(\"base\", Theme.Type.LOGIN);\n                Assert.assertNotNull(theme.getResourceAsStream(\"test.js\"));\n            } catch (IOException e) {\n                Assert.fail(e.getMessage());\n            }\n        });\n    }\n\n    @Test\n    public void getMessages() {\n        testingClient.server().run(session -> {\n            try {\n                Theme theme = session.theme().getTheme(\"base\", Theme.Type.LOGIN);\n                Assert.assertNotNull(theme.getMessages(\"messages\", Locale.ENGLISH).get(\"test.keycloak-8818\"));\n                Assert.assertNotEquals(\"Full name (Theme-resources)\", theme.getMessages(\"messages\", Locale.ENGLISH).get(\"fullName\"));\n            } catch (IOException e) {\n                Assert.fail(e.getMessage());\n            }\n        });\n    }\n\n    @Test\n    public void gzipEncoding() throws IOException {\n        final String resourcesVersion = testingClient.server().fetch(session -> Version.RESOURCES_VERSION, String.class);\n\n        // This will return true if files did not exists before the test OR they did exists, but were successfully deleted.\n        // False will be returned just in case that files were exists, but were NOT successfully deleted.\n        // This can happen in rare case when the file were created before in \"tmp\" directory by different system user and current user can't delete them\n        boolean filesNotExistsInTmp = testingClient.server().fetch(session -> {\n            boolean deleted = true;\n            File file1 = Paths.get(System.getProperty(\"java.io.tmpdir\"), \"kc-gzip-cache\", resourcesVersion, \"welcome\", \"keycloak\", \"css\", \"welcome.css.gz\").toFile();\n            if (file1.isFile()) {\n                deleted = file1.delete();\n            }\n\n            File file2 = Paths.get(System.getProperty(\"java.io.tmpdir\"), \"kc-gzip-cache\", resourcesVersion, \"js\", \"keycloak.js.gz\").toFile();\n            if (file2.isFile()) {\n                deleted = deleted && file2.delete();\n            }\n\n            return deleted;\n        }, Boolean.class);\n\n        assertEncoded(suiteContext.getAuthServerInfo().getContextRoot().toString() + \"/auth/resources/\" + resourcesVersion + \"/welcome/keycloak/css/welcome.css\", \"body {\");\n        assertEncoded(suiteContext.getAuthServerInfo().getContextRoot().toString() + \"/auth/js/keycloak.js\", \"function(root, factory)\");\n\n        // Check no files exists inside \"/tmp\" directory. We need to skip this test in the rare case when there are thombstone files created by different user\n        if (filesNotExistsInTmp) {\n            testingClient.server().run(session -> {\n                assertFalse(Paths.get(System.getProperty(\"java.io.tmpdir\"), \"kc-gzip-cache\", resourcesVersion, \"welcome\", \"keycloak\", \"css\", \"welcome.css.gz\").toFile().isFile());\n                assertFalse(Paths.get(System.getProperty(\"java.io.tmpdir\"), \"kc-gzip-cache\", resourcesVersion, \"js\", \"keycloak.js.gz\").toFile().isFile());\n            });\n        }\n\n        testingClient.server().run(session -> {\n            String serverTmpDir = Platform.getPlatform().getTmpDirectory().toString();\n            assertTrue(Paths.get(serverTmpDir, \"kc-gzip-cache\", resourcesVersion, \"welcome\", \"keycloak\", \"css\", \"welcome.css.gz\").toFile().isFile());\n            assertTrue(Paths.get(serverTmpDir, \"kc-gzip-cache\", resourcesVersion, \"js\", \"keycloak.js.gz\").toFile().isFile());\n        });\n    }\n\n    private void assertEncoded(String url, String expectedContent) throws IOException {\n        try (CloseableHttpClient httpClient = HttpClientBuilder.create().disableContentCompression().build()) {\n            HttpGet get = new HttpGet(url);\n            CloseableHttpResponse response = httpClient.execute(get);\n\n            InputStream is = response.getEntity().getContent();\n            assertNull(response.getFirstHeader(\"Content-Encoding\"));\n\n            String plain = IOUtils.toString(is, StandardCharsets.UTF_8);\n\n            response.close();\n\n            get = new HttpGet(url);\n            get.addHeader(\"Accept-Encoding\", \"gzip\");\n            response = httpClient.execute(get);\n\n\n            is = response.getEntity().getContent();\n            assertEquals(\"gzip\", response.getFirstHeader(\"Content-Encoding\").getValue());\n\n            String gzip = IOUtils.toString(new GZIPInputStream(is), StandardCharsets.UTF_8);\n\n            response.close();\n\n            assertEquals(plain, gzip);\n            assertTrue(plain.contains(expectedContent));\n        }\n    }\n\n    /**\n     * See KEYCLOAK-12926\n     */\n    @Test\n    public void getMessagesLocaleResolving() {\n        testingClient.server().run(session -> {\n            try {\n                Theme theme = session.theme().getTheme(\"base\", Theme.Type.LOGIN);\n                assertEquals(\"Test en_US_variant\", theme.getMessages(\"messages\", new Locale(\"en\", \"US\", \"variant\")).get(\"test.keycloak-12926\"));\n                assertEquals(\"Test en_US\", theme.getMessages(\"messages\", new Locale(\"en\", \"US\")).get(\"test.keycloak-12926\"));\n                assertEquals(\"Test en\", theme.getMessages(\"messages\", Locale.ENGLISH).get(\"test.keycloak-12926\"));\n                assertEquals(\"Test en_US\", theme.getMessages(\"messages\", new Locale(\"en\", \"US\")).get(\"test.keycloak-12926\"));\n                assertEquals(\"Test en\", theme.getMessages(\"messages\", Locale.ENGLISH).get(\"test.keycloak-12926\"));\n\n                assertEquals(\"only de_AT_variant\", theme.getMessages(\"messages\", new Locale(\"de\", \"AT\", \"variant\")).get(\"test.keycloak-12926-resolving1\"));\n                assertNull(theme.getMessages(\"messages\", new Locale(\"de\", \"AT\")).get(\"test.keycloak-12926-resolving1\"));\n\n                assertEquals(\"only de_AT\", theme.getMessages(\"messages\", new Locale(\"de\", \"AT\", \"variant\")).get(\"test.keycloak-12926-resolving2\"));\n                assertNull(theme.getMessages(\"messages\", new Locale(\"de\")).get(\"test.keycloak-12926-resolving2\"));\n\n                assertEquals(\"only de\", theme.getMessages(\"messages\", new Locale(\"de\", \"AT\", \"variant\")).get(\"test.keycloak-12926-only_de\"));\n                assertNull(theme.getMessages(\"messages\", Locale.ENGLISH).get(\"test.keycloak-12926-only_de\"));\n\n                assertEquals(\"fallback en\", theme.getMessages(\"messages\", new Locale(\"de\", \"AT\", \"variant\")).get(\"test.keycloak-12926-resolving3\"));\n                assertEquals(\"fallback en\", theme.getMessages(\"messages\", new Locale(\"de\", \"AT\")).get(\"test.keycloak-12926-resolving3\"));\n                assertEquals(\"fallback en\", theme.getMessages(\"messages\", new Locale(\"de\")).get(\"test.keycloak-12926-resolving3\"));\n                assertNull(theme.getMessages(\"messages\", Locale.ENGLISH).get(\"fallback en\"));\n\n            } catch (IOException e) {\n                Assert.fail(e.getMessage());\n            }\n        });\n    }\n}",
    "code_after_change": "{\n\n    @Override\n    public void configureTestRealm(RealmRepresentation testRealm) {\n\n    }\n\n    @Test\n    public void getTheme() {\n        testingClient.server().run(session -> {\n            try {\n                Theme theme = session.theme().getTheme(\"base\", Theme.Type.LOGIN);\n                Assert.assertNotNull(theme.getTemplate(\"test.ftl\"));\n            } catch (IOException e) {\n                Assert.fail(e.getMessage());\n            }\n        });\n    }\n\n    @Test\n    public void getResourceAsStream() {\n        testingClient.server().run(session -> {\n            try {\n                Theme theme = session.theme().getTheme(\"base\", Theme.Type.LOGIN);\n                Assert.assertNotNull(theme.getResourceAsStream(\"test.js\"));\n            } catch (IOException e) {\n                Assert.fail(e.getMessage());\n            }\n        });\n    }\n\n    @Test\n    public void getMessages() {\n        testingClient.server().run(session -> {\n            try {\n                Theme theme = session.theme().getTheme(\"base\", Theme.Type.LOGIN);\n                Assert.assertNotNull(theme.getMessages(\"messages\", Locale.ENGLISH).get(\"test.keycloak-8818\"));\n                Assert.assertNotEquals(\"Full name (Theme-resources)\", theme.getMessages(\"messages\", Locale.ENGLISH).get(\"fullName\"));\n            } catch (IOException e) {\n                Assert.fail(e.getMessage());\n            }\n        });\n    }\n\n    @Test\n    public void getResourceIllegalTraversal() {\n        testingClient.server().run(session -> {\n            try {\n                Theme theme = session.theme().getTheme(\"base\", Theme.Type.LOGIN);\n                Assert.assertNull(theme.getResourceAsStream(\"../templates/test.ftl\"));\n            } catch (IOException e) {\n                Assert.fail(e.getMessage());\n            }\n        });\n    }\n\n    @Test\n    public void gzipEncoding() throws IOException {\n        final String resourcesVersion = testingClient.server().fetch(session -> Version.RESOURCES_VERSION, String.class);\n\n        // This will return true if files did not exists before the test OR they did exists, but were successfully deleted.\n        // False will be returned just in case that files were exists, but were NOT successfully deleted.\n        // This can happen in rare case when the file were created before in \"tmp\" directory by different system user and current user can't delete them\n        boolean filesNotExistsInTmp = testingClient.server().fetch(session -> {\n            boolean deleted = true;\n            File file1 = Paths.get(System.getProperty(\"java.io.tmpdir\"), \"kc-gzip-cache\", resourcesVersion, \"welcome\", \"keycloak\", \"css\", \"welcome.css.gz\").toFile();\n            if (file1.isFile()) {\n                deleted = file1.delete();\n            }\n\n            File file2 = Paths.get(System.getProperty(\"java.io.tmpdir\"), \"kc-gzip-cache\", resourcesVersion, \"js\", \"keycloak.js.gz\").toFile();\n            if (file2.isFile()) {\n                deleted = deleted && file2.delete();\n            }\n\n            return deleted;\n        }, Boolean.class);\n\n        assertEncoded(suiteContext.getAuthServerInfo().getContextRoot().toString() + \"/auth/resources/\" + resourcesVersion + \"/welcome/keycloak/css/welcome.css\", \"body {\");\n        assertEncoded(suiteContext.getAuthServerInfo().getContextRoot().toString() + \"/auth/js/keycloak.js\", \"function(root, factory)\");\n\n        // Check no files exists inside \"/tmp\" directory. We need to skip this test in the rare case when there are thombstone files created by different user\n        if (filesNotExistsInTmp) {\n            testingClient.server().run(session -> {\n                assertFalse(Paths.get(System.getProperty(\"java.io.tmpdir\"), \"kc-gzip-cache\", resourcesVersion, \"welcome\", \"keycloak\", \"css\", \"welcome.css.gz\").toFile().isFile());\n                assertFalse(Paths.get(System.getProperty(\"java.io.tmpdir\"), \"kc-gzip-cache\", resourcesVersion, \"js\", \"keycloak.js.gz\").toFile().isFile());\n            });\n        }\n\n        testingClient.server().run(session -> {\n            String serverTmpDir = Platform.getPlatform().getTmpDirectory().toString();\n            assertTrue(Paths.get(serverTmpDir, \"kc-gzip-cache\", resourcesVersion, \"welcome\", \"keycloak\", \"css\", \"welcome.css.gz\").toFile().isFile());\n            assertTrue(Paths.get(serverTmpDir, \"kc-gzip-cache\", resourcesVersion, \"js\", \"keycloak.js.gz\").toFile().isFile());\n        });\n    }\n\n    private void assertEncoded(String url, String expectedContent) throws IOException {\n        try (CloseableHttpClient httpClient = HttpClientBuilder.create().disableContentCompression().build()) {\n            HttpGet get = new HttpGet(url);\n            CloseableHttpResponse response = httpClient.execute(get);\n\n            InputStream is = response.getEntity().getContent();\n            assertNull(response.getFirstHeader(\"Content-Encoding\"));\n\n            String plain = IOUtils.toString(is, StandardCharsets.UTF_8);\n\n            response.close();\n\n            get = new HttpGet(url);\n            get.addHeader(\"Accept-Encoding\", \"gzip\");\n            response = httpClient.execute(get);\n\n\n            is = response.getEntity().getContent();\n            assertEquals(\"gzip\", response.getFirstHeader(\"Content-Encoding\").getValue());\n\n            String gzip = IOUtils.toString(new GZIPInputStream(is), StandardCharsets.UTF_8);\n\n            response.close();\n\n            assertEquals(plain, gzip);\n            assertTrue(plain.contains(expectedContent));\n        }\n    }\n\n    /**\n     * See KEYCLOAK-12926\n     */\n    @Test\n    public void getMessagesLocaleResolving() {\n        testingClient.server().run(session -> {\n            try {\n                Theme theme = session.theme().getTheme(\"base\", Theme.Type.LOGIN);\n                assertEquals(\"Test en_US_variant\", theme.getMessages(\"messages\", new Locale(\"en\", \"US\", \"variant\")).get(\"test.keycloak-12926\"));\n                assertEquals(\"Test en_US\", theme.getMessages(\"messages\", new Locale(\"en\", \"US\")).get(\"test.keycloak-12926\"));\n                assertEquals(\"Test en\", theme.getMessages(\"messages\", Locale.ENGLISH).get(\"test.keycloak-12926\"));\n                assertEquals(\"Test en_US\", theme.getMessages(\"messages\", new Locale(\"en\", \"US\")).get(\"test.keycloak-12926\"));\n                assertEquals(\"Test en\", theme.getMessages(\"messages\", Locale.ENGLISH).get(\"test.keycloak-12926\"));\n\n                assertEquals(\"only de_AT_variant\", theme.getMessages(\"messages\", new Locale(\"de\", \"AT\", \"variant\")).get(\"test.keycloak-12926-resolving1\"));\n                assertNull(theme.getMessages(\"messages\", new Locale(\"de\", \"AT\")).get(\"test.keycloak-12926-resolving1\"));\n\n                assertEquals(\"only de_AT\", theme.getMessages(\"messages\", new Locale(\"de\", \"AT\", \"variant\")).get(\"test.keycloak-12926-resolving2\"));\n                assertNull(theme.getMessages(\"messages\", new Locale(\"de\")).get(\"test.keycloak-12926-resolving2\"));\n\n                assertEquals(\"only de\", theme.getMessages(\"messages\", new Locale(\"de\", \"AT\", \"variant\")).get(\"test.keycloak-12926-only_de\"));\n                assertNull(theme.getMessages(\"messages\", Locale.ENGLISH).get(\"test.keycloak-12926-only_de\"));\n\n                assertEquals(\"fallback en\", theme.getMessages(\"messages\", new Locale(\"de\", \"AT\", \"variant\")).get(\"test.keycloak-12926-resolving3\"));\n                assertEquals(\"fallback en\", theme.getMessages(\"messages\", new Locale(\"de\", \"AT\")).get(\"test.keycloak-12926-resolving3\"));\n                assertEquals(\"fallback en\", theme.getMessages(\"messages\", new Locale(\"de\")).get(\"test.keycloak-12926-resolving3\"));\n                assertNull(theme.getMessages(\"messages\", Locale.ENGLISH).get(\"fallback en\"));\n\n            } catch (IOException e) {\n                Assert.fail(e.getMessage());\n            }\n        });\n    }\n}",
    "patch": "@@ -73,6 +73,18 @@ public void getMessages() {\n         });\n     }\n \n+    @Test\n+    public void getResourceIllegalTraversal() {\n+        testingClient.server().run(session -> {\n+            try {\n+                Theme theme = session.theme().getTheme(\"base\", Theme.Type.LOGIN);\n+                Assert.assertNull(theme.getResourceAsStream(\"../templates/test.ftl\"));\n+            } catch (IOException e) {\n+                Assert.fail(e.getMessage());\n+            }\n+        });\n+    }\n+\n     @Test\n     public void gzipEncoding() throws IOException {\n         final String resourcesVersion = testingClient.server().fetch(session -> Version.RESOURCES_VERSION, String.class);",
    "function_modified_lines": {
      "added": [
        "    @Test\n",
        "    public void getResourceIllegalTraversal() {\n",
        "        testingClient.server().run(session -> {\n",
        "            try {\n",
        "                Theme theme = session.theme().getTheme(\"base\", Theme.Type.LOGIN);\n",
        "                Assert.assertNull(theme.getResourceAsStream(\"../templates/test.ftl\"));\n",
        "            } catch (IOException e) {\n",
        "                Assert.fail(e.getMessage());\n",
        "            }\n",
        "        });\n",
        "    }\n",
        "\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "ClassLoaderTheme and ClasspathThemeResourceProviderFactory allows reading any file available as a resource to the classloader. By sending requests for theme resources with a relative path from an external HTTP client, the client will receive the content of random files if available.",
    "id": 12114
  },
  {
    "cve_id": "CVE-2021-43795",
    "code_before_change": " * Copyright 2017 LINE Corporation\n *\n * LINE Corporation licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\n\npackage com.linecorp.armeria.internal.common;\n\nimport static com.linecorp.armeria.internal.common.ArmeriaHttpUtil.concatPaths;\nimport static com.linecorp.armeria.internal.common.ArmeriaHttpUtil.decodePath;\nimport static com.linecorp.armeria.internal.common.ArmeriaHttpUtil.parseDirectives;\nimport static com.linecorp.armeria.internal.common.ArmeriaHttpUtil.toArmeria;\nimport static com.linecorp.armeria.internal.common.ArmeriaHttpUtil.toNettyHttp1ClientHeaders;\nimport static com.linecorp.armeria.internal.common.ArmeriaHttpUtil.toNettyHttp1ServerHeaders;\nimport static com.linecorp.armeria.internal.common.ArmeriaHttpUtil.toNettyHttp2ClientHeaders;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatThrownBy;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.when;\n\nimport java.net.InetSocketAddress;\nimport java.net.URISyntaxException;\nimport java.util.Arrays;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.function.BiConsumer;\n\nimport org.junit.jupiter.api.Test;\n\nimport com.google.common.collect.ImmutableList;\n\nimport com.linecorp.armeria.common.Http1HeaderNaming;\nimport com.linecorp.armeria.common.HttpHeaderNames;\nimport com.linecorp.armeria.common.HttpHeaders;\nimport com.linecorp.armeria.common.HttpHeadersBuilder;\nimport com.linecorp.armeria.common.HttpResponse;\nimport com.linecorp.armeria.common.HttpStatus;\nimport com.linecorp.armeria.common.MediaType;\nimport com.linecorp.armeria.common.RequestHeaders;\nimport com.linecorp.armeria.common.ResponseHeaders;\nimport com.linecorp.armeria.common.ResponseHeadersBuilder;\nimport com.linecorp.armeria.server.Server;\nimport com.linecorp.armeria.server.ServerConfig;\n\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.handler.codec.http.DefaultHttpHeaders;\nimport io.netty.handler.codec.http.DefaultHttpRequest;\nimport io.netty.handler.codec.http.HttpHeaderValues;\nimport io.netty.handler.codec.http.HttpMethod;\nimport io.netty.handler.codec.http.HttpRequest;\nimport io.netty.handler.codec.http.HttpVersion;\nimport io.netty.handler.codec.http2.Http2Headers;\nimport io.netty.handler.codec.http2.HttpConversionUtil.ExtensionHeaderNames;\nimport io.netty.util.AsciiString;\n\nclass ArmeriaHttpUtilTest {\n\n    @Test\n    void testConcatPaths() throws Exception {\n        assertThat(concatPaths(null, \"a\")).isEqualTo(\"/a\");\n        assertThat(concatPaths(null, \"/a\")).isEqualTo(\"/a\");\n\n        assertThat(concatPaths(\"\", \"a\")).isEqualTo(\"/a\");\n        assertThat(concatPaths(\"\", \"/a\")).isEqualTo(\"/a\");\n",
    "code_after_change": " * LINE Corporation licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\n\npackage com.linecorp.armeria.internal.common;\n\nimport static com.linecorp.armeria.internal.common.ArmeriaHttpUtil.concatPaths;\nimport static com.linecorp.armeria.internal.common.ArmeriaHttpUtil.decodePath;\nimport static com.linecorp.armeria.internal.common.ArmeriaHttpUtil.parseDirectives;\nimport static com.linecorp.armeria.internal.common.ArmeriaHttpUtil.toArmeria;\nimport static com.linecorp.armeria.internal.common.ArmeriaHttpUtil.toNettyHttp1ClientHeaders;\nimport static com.linecorp.armeria.internal.common.ArmeriaHttpUtil.toNettyHttp1ServerHeaders;\nimport static com.linecorp.armeria.internal.common.ArmeriaHttpUtil.toNettyHttp2ClientHeaders;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatThrownBy;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.when;\n\nimport java.net.InetSocketAddress;\nimport java.net.URISyntaxException;\nimport java.util.Arrays;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.function.BiConsumer;\nimport java.util.function.Function;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.CsvSource;\n\nimport com.google.common.collect.ImmutableList;\n\nimport com.linecorp.armeria.common.Http1HeaderNaming;\nimport com.linecorp.armeria.common.HttpHeaderNames;\nimport com.linecorp.armeria.common.HttpHeaders;\nimport com.linecorp.armeria.common.HttpHeadersBuilder;\nimport com.linecorp.armeria.common.HttpResponse;\nimport com.linecorp.armeria.common.HttpStatus;\nimport com.linecorp.armeria.common.MediaType;\nimport com.linecorp.armeria.common.RequestHeaders;\nimport com.linecorp.armeria.common.ResponseHeaders;\nimport com.linecorp.armeria.common.ResponseHeadersBuilder;\nimport com.linecorp.armeria.server.Server;\nimport com.linecorp.armeria.server.ServerConfig;\n\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.handler.codec.http.DefaultHttpHeaders;\nimport io.netty.handler.codec.http.DefaultHttpRequest;\nimport io.netty.handler.codec.http.HttpHeaderValues;\nimport io.netty.handler.codec.http.HttpMethod;\nimport io.netty.handler.codec.http.HttpRequest;\nimport io.netty.handler.codec.http.HttpVersion;\nimport io.netty.handler.codec.http2.Http2Headers;\nimport io.netty.handler.codec.http2.HttpConversionUtil.ExtensionHeaderNames;\nimport io.netty.util.AsciiString;\n\nclass ArmeriaHttpUtilTest {\n\n    @Test\n    void testConcatPaths() throws Exception {\n        assertThat(concatPaths(null, \"a\")).isEqualTo(\"/a\");\n        assertThat(concatPaths(null, \"/a\")).isEqualTo(\"/a\");\n\n        assertThat(concatPaths(\"\", \"a\")).isEqualTo(\"/a\");",
    "patch": "@@ -35,8 +35,11 @@\n import java.util.List;\n import java.util.Map;\n import java.util.function.BiConsumer;\n+import java.util.function.Function;\n \n import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.CsvSource;\n \n import com.google.common.collect.ImmutableList;\n \n@@ -89,21 +92,36 @@ void testConcatPaths() throws Exception {\n         assertThat(concatPaths(\"/a/\", \"?foo=bar\")).isEqualTo(\"/a/?foo=bar\");\n     }\n \n-    @Test\n-    void testDecodePath() throws Exception {\n+    @ParameterizedTest\n+    @CsvSource({ \"true\", \"false\" })\n+    void testDecodePath(boolean isPathParam) throws Exception {\n+        final Function<String, String> decodeFunc;\n+        if (isPathParam) {\n+            decodeFunc = ArmeriaHttpUtil::decodePathParam;\n+        } else {\n+            decodeFunc = ArmeriaHttpUtil::decodePath;\n+        }\n+\n         // Fast path\n         final String pathThatDoesNotNeedDecode = \"/foo_bar_baz\";\n-        assertThat(decodePath(pathThatDoesNotNeedDecode)).isSameAs(pathThatDoesNotNeedDecode);\n+        assertThat(decodeFunc.apply(pathThatDoesNotNeedDecode)).isSameAs(pathThatDoesNotNeedDecode);\n \n         // Slow path\n-        assertThat(decodePath(\"/foo%20bar\\u007fbaz\")).isEqualTo(\"/foo bar\\u007fbaz\");\n-        assertThat(decodePath(\"/%C2%A2\")).isEqualTo(\"/\u00a2\"); // Valid UTF-8 sequence\n-        assertThat(decodePath(\"/%20\\u0080\")).isEqualTo(\"/ \ufffd\"); // Unallowed character\n-        assertThat(decodePath(\"/%\")).isEqualTo(\"/\ufffd\"); // No digit\n-        assertThat(decodePath(\"/%1\")).isEqualTo(\"/\ufffd\"); // Only a single digit\n-        assertThat(decodePath(\"/%G0\")).isEqualTo(\"/\ufffd\"); // First digit is not hex.\n-        assertThat(decodePath(\"/%0G\")).isEqualTo(\"/\ufffd\"); // Second digit is not hex.\n-        assertThat(decodePath(\"/%C3%28\")).isEqualTo(\"/\ufffd(\"); // Invalid UTF-8 sequence\n+        assertThat(decodeFunc.apply(\"/foo%20bar\\u007fbaz\")).isEqualTo(\"/foo bar\\u007fbaz\");\n+        assertThat(decodeFunc.apply(\"/%C2%A2\")).isEqualTo(\"/\u00a2\"); // Valid UTF-8 sequence\n+        assertThat(decodeFunc.apply(\"/%20\\u0080\")).isEqualTo(\"/ \ufffd\"); // Unallowed character\n+        assertThat(decodeFunc.apply(\"/%\")).isEqualTo(\"/\ufffd\"); // No digit\n+        assertThat(decodeFunc.apply(\"/%1\")).isEqualTo(\"/\ufffd\"); // Only a single digit\n+        assertThat(decodeFunc.apply(\"/%G0\")).isEqualTo(\"/\ufffd\"); // First digit is not hex.\n+        assertThat(decodeFunc.apply(\"/%0G\")).isEqualTo(\"/\ufffd\"); // Second digit is not hex.\n+        assertThat(decodeFunc.apply(\"/%C3%28\")).isEqualTo(\"/\ufffd(\"); // Invalid UTF-8 sequence\n+\n+        // %2F (/) must be decoded only for path parameters.\n+        if (isPathParam) {\n+            assertThat(decodeFunc.apply(\"/%2F\")).isEqualTo(\"//\");\n+        } else {\n+            assertThat(decodeFunc.apply(\"/%2F\")).isEqualTo(\"/%2F\");\n+        }\n     }\n \n     @Test",
    "function_modified_lines": {
      "added": [
        "import java.util.function.Function;\n",
        "import org.junit.jupiter.params.ParameterizedTest;\n",
        "import org.junit.jupiter.params.provider.CsvSource;\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "Armeria is an open source microservice framework. In affected versions an attacker can access an Armeria server's local file system beyond its restricted directory by sending an HTTP request whose path contains `%2F` (encoded `/`), such as `/files/..%2Fsecrets.txt`, bypassing Armeria's path validation logic. Armeria 1.13.4 or above contains the hardened path validation logic that handles `%2F` properly. This vulnerability can be worked around by inserting a decorator that performs an additional validation on the request path.",
    "id": 12129
  },
  {
    "cve_id": "CVE-2020-15097",
    "code_before_change": "package org.loklak.tools;\n\nimport javax.annotation.Nonnull;\n\nimport org.loklak.data.DAO;\n\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.security.*;\nimport java.security.spec.InvalidKeySpecException;\nimport java.security.spec.X509EncodedKeySpec;\nimport java.util.Base64;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic final class IO {\n\t\n\tprivate static Map<Path,String> map;\n\tprivate static boolean initialized = false;\n\n\tpublic static String readFile(@Nonnull Path path) throws IOException\n\t{\n\t\tbyte[] encoded = Files.readAllBytes(path);\n\t\treturn new String(encoded);\n\t}\n\t\n\tpublic static String readFileCached(@Nonnull Path path) throws IOException\n\t{\n\t\tPath absPath = path.toAbsolutePath();\n\t\tif(!initialized) init();\n\t\tif(map.containsKey(absPath)){\n\t\t\treturn map.get(absPath);\n\t\t}\n\t\telse{\n\t\t\tString result = readFile(absPath);\n\t\t\tmap.put(absPath, result);\n\t\t\treturn result;\n\t\t}\n\t}\n\t\n\tprivate static void init(){\n\t\tmap = new HashMap<Path,String>();\n\t\tinitialized = true;\n\t}\n\n\t/**\n\t * Create hash for a key\n\t * @param pubkey\n\t * @param algorithm\n\t * @return String hash\n\t */\n\tpublic static String getKeyHash(@Nonnull PublicKey pubkey, @Nonnull String algorithm){\n\t\ttry {\n\t\t\tMessageDigest md = MessageDigest.getInstance(algorithm);\n\t\t\tmd.update(pubkey.getEncoded());\n\t\t\treturn Base64.getEncoder().encodeToString(md.digest());\n\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\tDAO.severe(e);\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Create hash for a key, use default algorithm SHA-256\n\t * @param pubkey\n\t * @return String hash\n\t */\n\tpublic static String getKeyHash(@Nonnull PublicKey pubkey){\n\t\treturn getKeyHash(pubkey, \"SHA-256\");\n\t}\n\n\t/**\n\t * Get String representation of a key\n\t * @param key\n\t * @return String representation of a key\n\t */\n\tpublic static String getKeyAsString(@Nonnull Key key){\n\t\treturn Base64.getEncoder().encodeToString(key.getEncoded());\n\t}\n\n\t/**\n\t * Create PublicKey from String representation\n\t * @param encodedKey\n\t * @param algorithm\n\t * @return PublicKey public_key\n\t */\n\tpublic synchronized static PublicKey decodePublicKey(@Nonnull String encodedKey, @Nonnull String algorithm){\n\t\ttry{\n\t\t\tX509EncodedKeySpec keySpec = new X509EncodedKeySpec(Base64.getDecoder().decode(encodedKey));\n\t\t\tPublicKey pub = KeyFactory.getInstance(algorithm).generatePublic(keySpec);\n\t\t\treturn pub;\n\t\t}\n\t\tcatch(NoSuchAlgorithmException | InvalidKeySpecException e){\n\t\t\tDAO.severe(e);\n\t\t}\n\t\treturn null;\n\t}\n}\n",
    "code_after_change": "{\n\t\n\tprivate static Map<Path,String> map;\n\tprivate static boolean initialized = false;\n\n\tpublic static String readFile(@Nonnull Path path) throws IOException\n\t{\n\t\tbyte[] encoded = Files.readAllBytes(path);\n\t\treturn new String(encoded);\n\t}\n\t\n\tpublic static String readFileCached(@Nonnull Path path) throws IOException\n\t{\n\t\tPath absPath = path.toAbsolutePath();\n\t\tif(!initialized) init();\n\t\tif(map.containsKey(absPath)){\n\t\t\treturn map.get(absPath);\n\t\t}\n\t\telse{\n\t\t\tString result = readFile(absPath);\n\t\t\tmap.put(absPath, result);\n\t\t\treturn result;\n\t\t}\n\t}\n\t\n\tprivate static void init(){\n\t\tmap = new HashMap<Path,String>();\n\t\tinitialized = true;\n\t}\n\n\t/**\n\t * Create hash for a key\n\t * @param pubkey\n\t * @param algorithm\n\t * @return String hash\n\t */\n\tpublic static String getKeyHash(@Nonnull PublicKey pubkey, @Nonnull String algorithm){\n\t\ttry {\n\t\t\tMessageDigest md = MessageDigest.getInstance(algorithm);\n\t\t\tmd.update(pubkey.getEncoded());\n\t\t\treturn Base64.getEncoder().encodeToString(md.digest());\n\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\tDAO.severe(e);\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Create hash for a key, use default algorithm SHA-256\n\t * @param pubkey\n\t * @return String hash\n\t */\n\tpublic static String getKeyHash(@Nonnull PublicKey pubkey){\n\t\treturn getKeyHash(pubkey, \"SHA-256\");\n\t}\n\n\t/**\n\t * Get String representation of a key\n\t * @param key\n\t * @return String representation of a key\n\t */\n\tpublic static String getKeyAsString(@Nonnull Key key){\n\t\treturn Base64.getEncoder().encodeToString(key.getEncoded());\n\t}\n\n\t/**\n\t * Create PublicKey from String representation\n\t * @param encodedKey\n\t * @param algorithm\n\t * @return PublicKey public_key\n\t */\n\tpublic synchronized static PublicKey decodePublicKey(@Nonnull String encodedKey, @Nonnull String algorithm){\n\t\ttry{\n\t\t\tX509EncodedKeySpec keySpec = new X509EncodedKeySpec(Base64.getDecoder().decode(encodedKey));\n\t\t\tPublicKey pub = KeyFactory.getInstance(algorithm).generatePublic(keySpec);\n\t\t\treturn pub;\n\t\t}\n\t\tcatch(NoSuchAlgorithmException | InvalidKeySpecException e){\n\t\t\tDAO.severe(e);\n\t\t}\n\t\treturn null;\n\t}\n\t\n\t/**\n\t * Resolves an untrusted user-specified path against the API's base directory.\n\t * Paths that try to escape the base directory are rejected.\n\t *\n\t * @param baseDirPath  the absolute path of the base directory that all\n\t * user-specified paths should be within\n\t * @param userPath  the untrusted path provided by the API user, expected to be\n\t * relative to {@code baseDirPath}\n\t */\n\tpublic static Path resolvePath(final Path baseDirPath, final Path userPath) {\n\t\tif (!baseDirPath.isAbsolute()) {\n\t\t\tthrow new IllegalArgumentException(\"Base path must be absolute\");\n\t\t}\n\n\t\tif (userPath.isAbsolute()) {\n\t\t\tthrow new IllegalArgumentException(\"User path must be relative\");\n\t\t}\n\n\t\t// Join the two paths together, then normalize so that any \"..\" elements\n\t\t// in the userPath can remove parts of baseDirPath.\n\t\t// (e.g. \"/foo/bar/baz\" + \"../attack\" -> \"/foo/bar/attack\")\n\t\tfinal Path resolvedPath = baseDirPath.resolve(userPath).normalize();\n\n\t\t// Make sure the resulting path is still within the required directory.\n\t\t// (In the example above, \"/foo/bar/attack\" is not.)\n\t\tif (!resolvedPath.startsWith(baseDirPath)) {\n\t\t\tthrow new IllegalArgumentException(\"User path escapes the base path\");\n\t\t}\n\n\t\treturn resolvedPath;\n\t}\n\n\tpublic static Path resolvePath(final Path baseDirPath, final String userPath) {\n\t\treturn resolvePath(baseDirPath, Paths.get(userPath));\n\t}\n\n\t/**\n\t * Checks each subsequent path to be strictly within the baseDirPath so that\n\t * no path argument leads to directory traversal attack\n\t *\n\t * E.g. /models/ + req.model + '/' + req.lang + /images/ + req.image\n\t * Should be checked for ('models', req.model, req.lang, 'images', req.image)\n\t * that each subsequent element is within the previous and not breaking out by passing\n\t * req.model => ..\n\t * req.lang  => ..\n\t * req.image => ../../private/data.json\n\t *\n\t * Since just checking the last argument isn't enough\n\t *\n\t * @param baseDirPath the absolute path of the base directory that all\n\t * user-specified paths should be within\n\t * @param paths the untrusted paths provided by the API user, expected to be\n\t * relative to {@code baseDirPath}\n\t */\n\tpublic static Path resolvePath(final Path baseDirPath, final String... paths) {\n\t\tPath resolved = baseDirPath;\n\t\tfor (String path: paths) {\n\t\t\tresolved = resolvePath(resolved, path);\n\t\t}\n\n\t\treturn resolved;\n\t}\n}",
    "patch": "@@ -7,6 +7,7 @@\n import java.io.IOException;\n import java.nio.file.Files;\n import java.nio.file.Path;\n+import java.nio.file.Paths;\n import java.security.*;\n import java.security.spec.InvalidKeySpecException;\n import java.security.spec.X509EncodedKeySpec;\n@@ -96,4 +97,67 @@ public synchronized static PublicKey decodePublicKey(@Nonnull String encodedKey,\n \t\t}\n \t\treturn null;\n \t}\n+\t\n+\t/**\n+\t * Resolves an untrusted user-specified path against the API's base directory.\n+\t * Paths that try to escape the base directory are rejected.\n+\t *\n+\t * @param baseDirPath  the absolute path of the base directory that all\n+\t * user-specified paths should be within\n+\t * @param userPath  the untrusted path provided by the API user, expected to be\n+\t * relative to {@code baseDirPath}\n+\t */\n+\tpublic static Path resolvePath(final Path baseDirPath, final Path userPath) {\n+\t\tif (!baseDirPath.isAbsolute()) {\n+\t\t\tthrow new IllegalArgumentException(\"Base path must be absolute\");\n+\t\t}\n+\n+\t\tif (userPath.isAbsolute()) {\n+\t\t\tthrow new IllegalArgumentException(\"User path must be relative\");\n+\t\t}\n+\n+\t\t// Join the two paths together, then normalize so that any \"..\" elements\n+\t\t// in the userPath can remove parts of baseDirPath.\n+\t\t// (e.g. \"/foo/bar/baz\" + \"../attack\" -> \"/foo/bar/attack\")\n+\t\tfinal Path resolvedPath = baseDirPath.resolve(userPath).normalize();\n+\n+\t\t// Make sure the resulting path is still within the required directory.\n+\t\t// (In the example above, \"/foo/bar/attack\" is not.)\n+\t\tif (!resolvedPath.startsWith(baseDirPath)) {\n+\t\t\tthrow new IllegalArgumentException(\"User path escapes the base path\");\n+\t\t}\n+\n+\t\treturn resolvedPath;\n+\t}\n+\n+\tpublic static Path resolvePath(final Path baseDirPath, final String userPath) {\n+\t\treturn resolvePath(baseDirPath, Paths.get(userPath));\n+\t}\n+\n+\t/**\n+\t * Checks each subsequent path to be strictly within the baseDirPath so that\n+\t * no path argument leads to directory traversal attack\n+\t *\n+\t * E.g. /models/ + req.model + '/' + req.lang + /images/ + req.image\n+\t * Should be checked for ('models', req.model, req.lang, 'images', req.image)\n+\t * that each subsequent element is within the previous and not breaking out by passing\n+\t * req.model => ..\n+\t * req.lang  => ..\n+\t * req.image => ../../private/data.json\n+\t *\n+\t * Since just checking the last argument isn't enough\n+\t *\n+\t * @param baseDirPath the absolute path of the base directory that all\n+\t * user-specified paths should be within\n+\t * @param paths the untrusted paths provided by the API user, expected to be\n+\t * relative to {@code baseDirPath}\n+\t */\n+\tpublic static Path resolvePath(final Path baseDirPath, final String... paths) {\n+\t\tPath resolved = baseDirPath;\n+\t\tfor (String path: paths) {\n+\t\t\tresolved = resolvePath(resolved, path);\n+\t\t}\n+\n+\t\treturn resolved;\n+\t}\n }",
    "function_modified_lines": {
      "added": [
        "\t\n",
        "\t/**\n",
        "\t * Resolves an untrusted user-specified path against the API's base directory.\n",
        "\t * Paths that try to escape the base directory are rejected.\n",
        "\t *\n",
        "\t * @param baseDirPath  the absolute path of the base directory that all\n",
        "\t * user-specified paths should be within\n",
        "\t * @param userPath  the untrusted path provided by the API user, expected to be\n",
        "\t * relative to {@code baseDirPath}\n",
        "\t */\n",
        "\tpublic static Path resolvePath(final Path baseDirPath, final Path userPath) {\n",
        "\t\tif (!baseDirPath.isAbsolute()) {\n",
        "\t\t\tthrow new IllegalArgumentException(\"Base path must be absolute\");\n",
        "\t\t}\n",
        "\n",
        "\t\tif (userPath.isAbsolute()) {\n",
        "\t\t\tthrow new IllegalArgumentException(\"User path must be relative\");\n",
        "\t\t}\n",
        "\n",
        "\t\t// Join the two paths together, then normalize so that any \"..\" elements\n",
        "\t\t// in the userPath can remove parts of baseDirPath.\n",
        "\t\t// (e.g. \"/foo/bar/baz\" + \"../attack\" -> \"/foo/bar/attack\")\n",
        "\t\tfinal Path resolvedPath = baseDirPath.resolve(userPath).normalize();\n",
        "\n",
        "\t\t// Make sure the resulting path is still within the required directory.\n",
        "\t\t// (In the example above, \"/foo/bar/attack\" is not.)\n",
        "\t\tif (!resolvedPath.startsWith(baseDirPath)) {\n",
        "\t\t\tthrow new IllegalArgumentException(\"User path escapes the base path\");\n",
        "\t\t}\n",
        "\n",
        "\t\treturn resolvedPath;\n",
        "\t}\n",
        "\n",
        "\tpublic static Path resolvePath(final Path baseDirPath, final String userPath) {\n",
        "\t\treturn resolvePath(baseDirPath, Paths.get(userPath));\n",
        "\t}\n",
        "\n",
        "\t/**\n",
        "\t * Checks each subsequent path to be strictly within the baseDirPath so that\n",
        "\t * no path argument leads to directory traversal attack\n",
        "\t *\n",
        "\t * E.g. /models/ + req.model + '/' + req.lang + /images/ + req.image\n",
        "\t * Should be checked for ('models', req.model, req.lang, 'images', req.image)\n",
        "\t * that each subsequent element is within the previous and not breaking out by passing\n",
        "\t * req.model => ..\n",
        "\t * req.lang  => ..\n",
        "\t * req.image => ../../private/data.json\n",
        "\t *\n",
        "\t * Since just checking the last argument isn't enough\n",
        "\t *\n",
        "\t * @param baseDirPath the absolute path of the base directory that all\n",
        "\t * user-specified paths should be within\n",
        "\t * @param paths the untrusted paths provided by the API user, expected to be\n",
        "\t * relative to {@code baseDirPath}\n",
        "\t */\n",
        "\tpublic static Path resolvePath(final Path baseDirPath, final String... paths) {\n",
        "\t\tPath resolved = baseDirPath;\n",
        "\t\tfor (String path: paths) {\n",
        "\t\t\tresolved = resolvePath(resolved, path);\n",
        "\t\t}\n",
        "\n",
        "\t\treturn resolved;\n",
        "\t}\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "loklak is an open-source server application which is able to collect messages from various sources, including twitter. The server contains a search index and a peer-to-peer index sharing interface. All messages are stored in an elasticsearch index. In loklak less than or equal to commit 5f48476, a path traversal vulnerability exists. Insufficient input validation in the APIs exposed by the loklak server allowed a directory traversal vulnerability. Any admin configuration and files readable by the app available on the hosted file system can be retrieved by the attacker. Furthermore, user-controlled content could be written to any admin config and files readable by the application. This has been patched in commit 50dd692. Users will need to upgrade their hosted instances of loklak to not be vulnerable to this exploit.",
    "id": 12150
  },
  {
    "cve_id": "CVE-2020-36628",
    "code_before_change": "{\n\t\t\tzipIn = new ZipInputStream(inputStream);\n\t\t\t\n\t\t\tZipEntry zipEntry;\n\t\t\twhile ((zipEntry = zipIn.getNextEntry()) != null) {\n\t\t\t\tFile file = new File(folder, zipEntry.getName());\n\t\t\t\t\n\t\t\t\tif (zipEntry.isDirectory()) {\n\t\t\t\t\tif (!file.exists() && !file.mkdirs()) return false;\n\t\t\t\t} else {\n\t\t\t\t\tif (!file.getParentFile().exists() && !file.getParentFile().mkdirs()) return false;\n\t\t\t\t\tif (!handleStreamCopy(zipIn, new FileOutputStream(file), false, true)) return false;\n\t\t\t\t\tzipIn.closeEntry();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t}",
    "code_after_change": "{\n\t\t\t\tFile file = new File(folder, zipEntry.getName());\n\t\t\t\tif (file.getCanonicalPath().startsWith(folder.getCanonicalPath())) {\n\t\t\t\t\tSystem.err.println(\"Aborted zip! Attempted zip path traversal attack extracting to: \" + folder.getAbsolutePath());\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (zipEntry.isDirectory()) {\n\t\t\t\t\tif (!file.exists() && !file.mkdirs()) return false;\n\t\t\t\t} else {\n\t\t\t\t\tif (!file.getParentFile().exists() && !file.getParentFile().mkdirs()) return false;\n\t\t\t\t\tif (!handleStreamCopy(zipIn, new FileOutputStream(file), false, true)) return false;\n\t\t\t\t\tzipIn.closeEntry();\n\t\t\t\t}\n\t\t\t}",
    "patch": "@@ -271,6 +271,10 @@ private static boolean handleExtract(InputStream inputStream, File folder) {\n \t\t\tZipEntry zipEntry;\n \t\t\twhile ((zipEntry = zipIn.getNextEntry()) != null) {\n \t\t\t\tFile file = new File(folder, zipEntry.getName());\n+\t\t\t\tif (file.getCanonicalPath().startsWith(folder.getCanonicalPath())) {\n+\t\t\t\t\tSystem.err.println(\"Aborted zip! Attempted zip path traversal attack extracting to: \" + folder.getAbsolutePath());\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n \t\t\t\t\n \t\t\t\tif (zipEntry.isDirectory()) {\n \t\t\t\t\tif (!file.exists() && !file.mkdirs()) return false;",
    "function_modified_lines": {
      "added": [
        "\t\t\t\tif (file.getCanonicalPath().startsWith(folder.getCanonicalPath())) {\n",
        "\t\t\t\t\tSystem.err.println(\"Aborted zip! Attempted zip path traversal attack extracting to: \" + folder.getAbsolutePath());\n",
        "\t\t\t\t\treturn false;\n",
        "\t\t\t\t}\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "A vulnerability classified as critical has been found in Calsign APDE. This affects the function handleExtract of the file APDE/src/main/java/com/calsignlabs/apde/build/dag/CopyBuildTask.java of the component ZIP File Handler. The manipulation leads to path traversal. Upgrading to version 0.5.2-pre2-alpha is able to address this issue. It is recommended to upgrade the affected component. The associated identifier of this vulnerability is VDB-216747.",
    "id": 12182
  },
  {
    "cve_id": "CVE-2021-32769",
    "code_before_change": "{\n\n    private static final Logger LOG = LoggerFactory.getLogger(DefaultClassPathResourceLoader.class);\n\n    private final ClassLoader classLoader;\n    private final String basePath;\n    private final Map<String, Boolean> isDirectoryCache = new ConcurrentLinkedHashMap.Builder<String, Boolean>()\n            .maximumWeightedCapacity(50).build();\n\n    /**\n     * Default constructor.\n     *\n     * @param classLoader The class loader for loading resources\n     */\n    public DefaultClassPathResourceLoader(ClassLoader classLoader) {\n        this(classLoader, null);\n    }\n\n    /**\n     * Use when resources should have a standard base path.\n     *\n     * @param classLoader The class loader for loading resources\n     * @param basePath    The path to look for resources under\n     */\n    public DefaultClassPathResourceLoader(ClassLoader classLoader, String basePath) {\n        this.classLoader = classLoader;\n        this.basePath = normalize(basePath);\n    }\n\n    /**\n     * Obtains a resource as a stream.\n     *\n     * @param path The path\n     * @return An optional resource\n     */\n    @Override\n    public Optional<InputStream> getResourceAsStream(String path) {\n        URL url = classLoader.getResource(prefixPath(path));\n        if (url != null) {\n            try {\n                URI uri = url.toURI();\n                if (uri.getScheme().equals(\"jar\")) {\n                    synchronized (DefaultClassPathResourceLoader.class) {\n                        FileSystem fileSystem = null;\n                        try {\n                            try {\n                                fileSystem = FileSystems.getFileSystem(uri);\n                            } catch (FileSystemNotFoundException e) {\n                                //no-op\n                            }\n                            if (fileSystem == null || !fileSystem.isOpen()) {\n                                try {\n                                    fileSystem = FileSystems.newFileSystem(uri, Collections.emptyMap(), classLoader);\n                                } catch (FileSystemAlreadyExistsException e) {\n                                    fileSystem = FileSystems.getFileSystem(uri);\n                                }\n                            }\n                            Path pathObject = fileSystem.getPath(path);\n                            if (Files.isDirectory(pathObject)) {\n                                return Optional.empty();\n                            }\n                            return Optional.of(new ByteArrayInputStream(Files.readAllBytes(pathObject)));\n                        } finally {\n                            if (fileSystem != null && fileSystem.isOpen()) {\n                                try {\n                                    fileSystem.close();\n                                } catch (IOException e) {\n                                    if (LOG.isDebugEnabled()) {\n                                        LOG.debug(\"Error shutting down JAR file system [\" + fileSystem + \"]: \" + e.getMessage(), e);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                } else if (uri.getScheme().equals(\"file\")) {\n                    Path pathObject = Paths.get(uri);\n                    if (Files.isDirectory(pathObject)) {\n                        return Optional.empty();\n                    }\n                    return Optional.of(Files.newInputStream(pathObject));\n                }\n            } catch (URISyntaxException | IOException | ProviderNotFoundException e) {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Error establishing whether path is a directory: \" + e.getMessage(), e);\n                }\n            }\n        }\n        // fallback to less sophisticated approach\n        if (path.indexOf('.') == -1) {\n            return Optional.empty();\n        }\n        return Optional.ofNullable(classLoader.getResourceAsStream(prefixPath(path)));\n    }\n\n    /**\n     * Obtains a resource URL.\n     *\n     * @param path The path\n     * @return An optional resource\n     */\n    @Override\n    public Optional<URL> getResource(String path) {\n        boolean isDirectory = isDirectory(path);\n\n        if (!isDirectory) {\n            URL url = classLoader.getResource(prefixPath(path));\n            return Optional.ofNullable(url);\n        }\n        return Optional.empty();\n    }\n\n    /**\n     * Obtains a stream of resource URLs.\n     *\n     * @param path The path\n     * @return A resource stream\n     */\n    @Override\n    public Stream<URL> getResources(String path) {\n        Enumeration<URL> all;\n        try {\n            all = classLoader.getResources(prefixPath(path));\n        } catch (IOException e) {\n            return Stream.empty();\n        }\n        Stream.Builder<URL> builder = Stream.builder();\n        while (all.hasMoreElements()) {\n            URL url = all.nextElement();\n            builder.accept(url);\n        }\n        return builder.build();\n    }\n\n    /**\n     * @return The class loader used to retrieve resources\n     */\n    @Override\n    public ClassLoader getClassLoader() {\n        return classLoader;\n    }\n\n    /**\n     * @param basePath The path to load resources\n     * @return The resouce loader\n     */\n    @Override\n    public ResourceLoader forBase(String basePath) {\n        return new DefaultClassPathResourceLoader(classLoader, basePath);\n    }\n\n    @SuppressWarnings(\"MagicNumber\")\n    private String normalize(String path) {\n        if (path != null) {\n            if (path.startsWith(\"classpath:\")) {\n                path = path.substring(10);\n            }\n            if (path.startsWith(\"/\")) {\n                path = path.substring(1);\n            }\n            if (!path.endsWith(\"/\") && StringUtils.isNotEmpty(path)) {\n                path = path + \"/\";\n            }\n        }\n        return path;\n    }\n\n    @SuppressWarnings(\"ConstantConditions\")\n    private boolean isDirectory(String path) {\n        return isDirectoryCache.computeIfAbsent(path, s -> {\n            URL url = classLoader.getResource(prefixPath(path));\n            if (url != null) {\n                try {\n                    URI uri = url.toURI();\n                    Path pathObject;\n                    if (uri.getScheme().equals(\"jar\")) {\n                        synchronized (DefaultClassPathResourceLoader.class) {\n                            FileSystem fileSystem = null;\n                            try {\n                                try {\n                                    fileSystem = FileSystems.getFileSystem(uri);\n                                } catch (FileSystemNotFoundException e) {\n                                    //no-op\n                                }\n                                if (fileSystem == null || !fileSystem.isOpen()) {\n                                    fileSystem = FileSystems.newFileSystem(uri, Collections.emptyMap(), classLoader);\n                                }\n\n                                pathObject = fileSystem.getPath(path);\n                                return pathObject == null || Files.isDirectory(pathObject);\n                            } finally {\n                                if (fileSystem != null && fileSystem.isOpen()) {\n                                    try {\n                                        fileSystem.close();\n                                    } catch (IOException e) {\n                                        if (LOG.isDebugEnabled()) {\n                                            LOG.debug(\"Error shutting down JAR file system [\" + fileSystem + \"]: \" + e.getMessage(), e);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    } else if (uri.getScheme().equals(\"file\")) {\n                        pathObject = Paths.get(uri);\n                        return pathObject == null || Files.isDirectory(pathObject);\n                    }\n                } catch (URISyntaxException | IOException | ProviderNotFoundException e) {\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Error establishing whether path is a directory: \" + e.getMessage(), e);\n                    }\n                }\n            }\n            return path.indexOf('.') == -1; // fallback to less sophisticated approach\n        });\n    }\n\n    @SuppressWarnings(\"MagicNumber\")\n    private String prefixPath(String path) {\n        if (path.startsWith(\"classpath:\")) {\n            path = path.substring(10);\n        }\n        if (basePath != null) {\n            if (path.startsWith(\"/\")) {\n                return basePath + path.substring(1);\n            }\n            return basePath + path;\n        }\n        return path;\n    }\n\n}",
    "code_after_change": "{\n\n    private static final Logger LOG = LoggerFactory.getLogger(DefaultClassPathResourceLoader.class);\n\n    private final ClassLoader classLoader;\n    private final String basePath;\n    private final URL baseURL;\n    private final Map<String, Boolean> isDirectoryCache = new ConcurrentLinkedHashMap.Builder<String, Boolean>()\n            .maximumWeightedCapacity(50).build();\n    private final boolean missingPath;\n\n    /**\n     * Default constructor.\n     *\n     * @param classLoader The class loader for loading resources\n     */\n    public DefaultClassPathResourceLoader(ClassLoader classLoader) {\n        this(classLoader, null);\n    }\n\n    /**\n     * Use when resources should have a standard base path.\n     *\n     * @param classLoader The class loader for loading resources\n     * @param basePath    The path to look for resources under\n     */\n    public DefaultClassPathResourceLoader(ClassLoader classLoader, String basePath) {\n        this.classLoader = classLoader;\n        this.basePath = normalize(basePath);\n        this.baseURL = basePath != null ? classLoader.getResource(normalize(basePath)) : null;\n        this.missingPath = basePath != null && baseURL == null;\n    }\n\n    /**\n     * Obtains a resource as a stream.\n     *\n     * @param path The path\n     * @return An optional resource\n     */\n    @Override\n    public Optional<InputStream> getResourceAsStream(String path) {\n        if (missingPath) {\n            return Optional.empty();\n        }\n\n        URL url = classLoader.getResource(prefixPath(path));\n        if (url != null) {\n            if (startsWithBase(url)) {\n                try {\n                    URI uri = url.toURI();\n                    if (uri.getScheme().equals(\"jar\")) {\n                        synchronized (DefaultClassPathResourceLoader.class) {\n                            FileSystem fileSystem = null;\n                            try {\n                                try {\n                                    fileSystem = FileSystems.getFileSystem(uri);\n                                } catch (FileSystemNotFoundException e) {\n                                    //no-op\n                                }\n                                if (fileSystem == null || !fileSystem.isOpen()) {\n                                    try {\n                                        fileSystem = FileSystems.newFileSystem(uri, Collections.emptyMap(), classLoader);\n                                    } catch (FileSystemAlreadyExistsException e) {\n                                        fileSystem = FileSystems.getFileSystem(uri);\n                                    }\n                                }\n                                Path pathObject = fileSystem.getPath(path);\n                                if (Files.isDirectory(pathObject)) {\n                                    return Optional.empty();\n                                }\n                                return Optional.of(new ByteArrayInputStream(Files.readAllBytes(pathObject)));\n                            } finally {\n                                if (fileSystem != null && fileSystem.isOpen()) {\n                                    try {\n                                        fileSystem.close();\n                                    } catch (IOException e) {\n                                        if (LOG.isDebugEnabled()) {\n                                            LOG.debug(\"Error shutting down JAR file system [\" + fileSystem + \"]: \" + e.getMessage(), e);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    } else if (uri.getScheme().equals(\"file\")) {\n                        Path pathObject = Paths.get(uri);\n                        if (Files.isDirectory(pathObject)) {\n                            return Optional.empty();\n                        }\n                        return Optional.of(Files.newInputStream(pathObject));\n                    }\n                } catch (URISyntaxException | IOException | ProviderNotFoundException e) {\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Error establishing whether path is a directory: \" + e.getMessage(), e);\n                    }\n                }\n            }\n        }\n        // fallback to less sophisticated approach\n        if (path.indexOf('.') == -1) {\n            return Optional.empty();\n        }\n        final URL u = getResource(path).orElse(null);\n        if (u != null) {\n            try {\n                return Optional.of(u.openStream());\n            } catch (IOException e) {\n                // fallback to empty\n            }\n        }\n        return Optional.empty();\n    }\n\n    private boolean startsWithBase(URL url) {\n        if (baseURL == null) {\n            return true;\n        } else {\n            return url.toExternalForm().startsWith(baseURL.toExternalForm());\n        }\n    }\n\n    /**\n     * Obtains a resource URL.\n     *\n     * @param path The path\n     * @return An optional resource\n     */\n    @Override\n    public Optional<URL> getResource(String path) {\n        if (missingPath) {\n            return Optional.empty();\n        }\n\n        boolean isDirectory = isDirectory(path);\n\n        if (!isDirectory) {\n            URL url = classLoader.getResource(prefixPath(path));\n            if (url != null && startsWithBase(url)) {\n                return Optional.of(url);\n            }\n        }\n        return Optional.empty();\n    }\n\n    /**\n     * Obtains a stream of resource URLs.\n     *\n     * @param path The path\n     * @return A resource stream\n     */\n    @Override\n    public Stream<URL> getResources(String path) {\n        Enumeration<URL> all;\n        try {\n            all = classLoader.getResources(prefixPath(path));\n        } catch (IOException e) {\n            return Stream.empty();\n        }\n        Stream.Builder<URL> builder = Stream.builder();\n        while (all.hasMoreElements()) {\n            URL url = all.nextElement();\n            if (startsWithBase(url)) {\n                builder.accept(url);\n            }\n        }\n        return builder.build();\n    }\n\n    /**\n     * @return The class loader used to retrieve resources\n     */\n    @Override\n    public ClassLoader getClassLoader() {\n        return classLoader;\n    }\n\n    /**\n     * @param basePath The path to load resources\n     * @return The resouce loader\n     */\n    @Override\n    public ResourceLoader forBase(String basePath) {\n        return new DefaultClassPathResourceLoader(classLoader, basePath);\n    }\n\n    @SuppressWarnings(\"MagicNumber\")\n    private String normalize(String path) {\n        if (path != null) {\n            if (path.startsWith(\"classpath:\")) {\n                path = path.substring(10);\n            }\n            if (path.startsWith(\"/\")) {\n                path = path.substring(1);\n            }\n            if (!path.endsWith(\"/\") && StringUtils.isNotEmpty(path)) {\n                path = path + \"/\";\n            }\n        }\n        return path;\n    }\n\n    @SuppressWarnings(\"ConstantConditions\")\n    private boolean isDirectory(String path) {\n        return isDirectoryCache.computeIfAbsent(path, s -> {\n            URL url = classLoader.getResource(prefixPath(path));\n            if (url != null) {\n                try {\n                    URI uri = url.toURI();\n                    Path pathObject;\n                    if (uri.getScheme().equals(\"jar\")) {\n                        synchronized (DefaultClassPathResourceLoader.class) {\n                            FileSystem fileSystem = null;\n                            try {\n                                try {\n                                    fileSystem = FileSystems.getFileSystem(uri);\n                                } catch (FileSystemNotFoundException e) {\n                                    //no-op\n                                }\n                                if (fileSystem == null || !fileSystem.isOpen()) {\n                                    fileSystem = FileSystems.newFileSystem(uri, Collections.emptyMap(), classLoader);\n                                }\n\n                                pathObject = fileSystem.getPath(path);\n                                return pathObject == null || Files.isDirectory(pathObject);\n                            } finally {\n                                if (fileSystem != null && fileSystem.isOpen()) {\n                                    try {\n                                        fileSystem.close();\n                                    } catch (IOException e) {\n                                        if (LOG.isDebugEnabled()) {\n                                            LOG.debug(\"Error shutting down JAR file system [\" + fileSystem + \"]: \" + e.getMessage(), e);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    } else if (uri.getScheme().equals(\"file\")) {\n                        pathObject = Paths.get(uri);\n                        return pathObject == null || Files.isDirectory(pathObject);\n                    }\n                } catch (URISyntaxException | IOException | ProviderNotFoundException e) {\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Error establishing whether path is a directory: \" + e.getMessage(), e);\n                    }\n                }\n            }\n            return path.indexOf('.') == -1; // fallback to less sophisticated approach\n        });\n    }\n\n    @SuppressWarnings(\"MagicNumber\")\n    private String prefixPath(String path) {\n        if (path.startsWith(\"classpath:\")) {\n            path = path.substring(10);\n        }\n        if (basePath != null) {\n            if (path.startsWith(\"/\")) {\n                return basePath + path.substring(1);\n            }\n            return basePath + path;\n        }\n        return path;\n    }\n\n}",
    "patch": "@@ -44,8 +44,10 @@ public class DefaultClassPathResourceLoader implements ClassPathResourceLoader {\n \n     private final ClassLoader classLoader;\n     private final String basePath;\n+    private final URL baseURL;\n     private final Map<String, Boolean> isDirectoryCache = new ConcurrentLinkedHashMap.Builder<String, Boolean>()\n             .maximumWeightedCapacity(50).build();\n+    private final boolean missingPath;\n \n     /**\n      * Default constructor.\n@@ -65,6 +67,8 @@ public DefaultClassPathResourceLoader(ClassLoader classLoader) {\n     public DefaultClassPathResourceLoader(ClassLoader classLoader, String basePath) {\n         this.classLoader = classLoader;\n         this.basePath = normalize(basePath);\n+        this.baseURL = basePath != null ? classLoader.getResource(normalize(basePath)) : null;\n+        this.missingPath = basePath != null && baseURL == null;\n     }\n \n     /**\n@@ -75,61 +79,83 @@ public DefaultClassPathResourceLoader(ClassLoader classLoader, String basePath)\n      */\n     @Override\n     public Optional<InputStream> getResourceAsStream(String path) {\n+        if (missingPath) {\n+            return Optional.empty();\n+        }\n+\n         URL url = classLoader.getResource(prefixPath(path));\n         if (url != null) {\n-            try {\n-                URI uri = url.toURI();\n-                if (uri.getScheme().equals(\"jar\")) {\n-                    synchronized (DefaultClassPathResourceLoader.class) {\n-                        FileSystem fileSystem = null;\n-                        try {\n+            if (startsWithBase(url)) {\n+                try {\n+                    URI uri = url.toURI();\n+                    if (uri.getScheme().equals(\"jar\")) {\n+                        synchronized (DefaultClassPathResourceLoader.class) {\n+                            FileSystem fileSystem = null;\n                             try {\n-                                fileSystem = FileSystems.getFileSystem(uri);\n-                            } catch (FileSystemNotFoundException e) {\n-                                //no-op\n-                            }\n-                            if (fileSystem == null || !fileSystem.isOpen()) {\n                                 try {\n-                                    fileSystem = FileSystems.newFileSystem(uri, Collections.emptyMap(), classLoader);\n-                                } catch (FileSystemAlreadyExistsException e) {\n                                     fileSystem = FileSystems.getFileSystem(uri);\n+                                } catch (FileSystemNotFoundException e) {\n+                                    //no-op\n                                 }\n-                            }\n-                            Path pathObject = fileSystem.getPath(path);\n-                            if (Files.isDirectory(pathObject)) {\n-                                return Optional.empty();\n-                            }\n-                            return Optional.of(new ByteArrayInputStream(Files.readAllBytes(pathObject)));\n-                        } finally {\n-                            if (fileSystem != null && fileSystem.isOpen()) {\n-                                try {\n-                                    fileSystem.close();\n-                                } catch (IOException e) {\n-                                    if (LOG.isDebugEnabled()) {\n-                                        LOG.debug(\"Error shutting down JAR file system [\" + fileSystem + \"]: \" + e.getMessage(), e);\n+                                if (fileSystem == null || !fileSystem.isOpen()) {\n+                                    try {\n+                                        fileSystem = FileSystems.newFileSystem(uri, Collections.emptyMap(), classLoader);\n+                                    } catch (FileSystemAlreadyExistsException e) {\n+                                        fileSystem = FileSystems.getFileSystem(uri);\n+                                    }\n+                                }\n+                                Path pathObject = fileSystem.getPath(path);\n+                                if (Files.isDirectory(pathObject)) {\n+                                    return Optional.empty();\n+                                }\n+                                return Optional.of(new ByteArrayInputStream(Files.readAllBytes(pathObject)));\n+                            } finally {\n+                                if (fileSystem != null && fileSystem.isOpen()) {\n+                                    try {\n+                                        fileSystem.close();\n+                                    } catch (IOException e) {\n+                                        if (LOG.isDebugEnabled()) {\n+                                            LOG.debug(\"Error shutting down JAR file system [\" + fileSystem + \"]: \" + e.getMessage(), e);\n+                                        }\n                                     }\n                                 }\n                             }\n                         }\n+                    } else if (uri.getScheme().equals(\"file\")) {\n+                        Path pathObject = Paths.get(uri);\n+                        if (Files.isDirectory(pathObject)) {\n+                            return Optional.empty();\n+                        }\n+                        return Optional.of(Files.newInputStream(pathObject));\n                     }\n-                } else if (uri.getScheme().equals(\"file\")) {\n-                    Path pathObject = Paths.get(uri);\n-                    if (Files.isDirectory(pathObject)) {\n-                        return Optional.empty();\n+                } catch (URISyntaxException | IOException | ProviderNotFoundException e) {\n+                    if (LOG.isDebugEnabled()) {\n+                        LOG.debug(\"Error establishing whether path is a directory: \" + e.getMessage(), e);\n                     }\n-                    return Optional.of(Files.newInputStream(pathObject));\n-                }\n-            } catch (URISyntaxException | IOException | ProviderNotFoundException e) {\n-                if (LOG.isDebugEnabled()) {\n-                    LOG.debug(\"Error establishing whether path is a directory: \" + e.getMessage(), e);\n                 }\n             }\n         }\n         // fallback to less sophisticated approach\n         if (path.indexOf('.') == -1) {\n             return Optional.empty();\n         }\n-        return Optional.ofNullable(classLoader.getResourceAsStream(prefixPath(path)));\n+        final URL u = getResource(path).orElse(null);\n+        if (u != null) {\n+            try {\n+                return Optional.of(u.openStream());\n+            } catch (IOException e) {\n+                // fallback to empty\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    private boolean startsWithBase(URL url) {\n+        if (baseURL == null) {\n+            return true;\n+        } else {\n+            return url.toExternalForm().startsWith(baseURL.toExternalForm());\n+        }\n     }\n \n     /**\n@@ -140,11 +166,17 @@ public Optional<InputStream> getResourceAsStream(String path) {\n      */\n     @Override\n     public Optional<URL> getResource(String path) {\n+        if (missingPath) {\n+            return Optional.empty();\n+        }\n+\n         boolean isDirectory = isDirectory(path);\n \n         if (!isDirectory) {\n             URL url = classLoader.getResource(prefixPath(path));\n-            return Optional.ofNullable(url);\n+            if (url != null && startsWithBase(url)) {\n+                return Optional.of(url);\n+            }\n         }\n         return Optional.empty();\n     }\n@@ -166,7 +198,9 @@ public Stream<URL> getResources(String path) {\n         Stream.Builder<URL> builder = Stream.builder();\n         while (all.hasMoreElements()) {\n             URL url = all.nextElement();\n-            builder.accept(url);\n+            if (startsWithBase(url)) {\n+                builder.accept(url);\n+            }\n         }\n         return builder.build();\n     }",
    "function_modified_lines": {
      "added": [
        "    private final URL baseURL;\n",
        "    private final boolean missingPath;\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "Micronaut is a JVM-based, full stack Java framework designed for building JVM applications. A path traversal vulnerability exists in versions prior to 2.5.9. With a basic configuration, it is possible to access any file from a filesystem, using \"/../../\" in the URL. This occurs because Micronaut does not restrict file access to configured paths. The vulnerability is patched in version 2.5.9. As a workaround, do not use `**` in mapping, use only `*`, which exposes only flat structure of a directory not allowing traversal. If using Linux, another workaround is to run micronaut in chroot.",
    "id": 12188
  },
  {
    "cve_id": "CVE-2021-32769",
    "code_before_change": "    }\n\n    @SuppressWarnings(\"MagicNumber\")\n    private Collection<PropertySourceLoader> evaluatePropertySourceLoaders() {\n        SoftServiceLoader<PropertySourceLoader> definitions = readPropertySourceLoaders();\n        Collection<PropertySourceLoader> allLoaders = new ArrayList<>(10);\n        definitions.collectAll(allLoaders);\n        for (PropertySourceLoader propertySourceLoader : allLoaders) {\n            Set<String> extensions = propertySourceLoader.getExtensions();\n            for (String extension : extensions) {\n                loaderByFormatMap.put(extension, propertySourceLoader);\n            }\n        }\n        return allLoaders;\n    }\n\n    private void loadPropertySourceFromLoader(String name, PropertySourceLoader propertySourceLoader, List<PropertySource> propertySources, ResourceLoader resourceLoader) {\n        Optional<PropertySource> defaultPropertySource = propertySourceLoader.load(name, resourceLoader);\n        defaultPropertySource.ifPresent(propertySources::add);\n        Set<String> activeNames = getActiveNames();\n        int i = 0;\n        for (String activeName: activeNames) {\n            Optional<PropertySource> propertySource = propertySourceLoader.loadEnv(name, resourceLoader, ActiveEnvironment.of(activeName, i));\n            propertySource.ifPresent(propertySources::add);\n            i++;\n        }\n    }\n\n    /**\n     * Read the property source.\n     *\n     * @param fileName             Name of the file to be used as property source name\n     * @param filePath             Absolute file path\n     * @param propertySourceLoader The appropriate property source loader\n     * @throws ConfigurationException If unable to find the appropriate property soruce loader for the given file\n     */\n    private Optional<Map<String, Object>> readPropertiesFromLoader(String fileName, String filePath, PropertySourceLoader propertySourceLoader) throws ConfigurationException {\n        ResourceResolver resourceResolver = new ResourceResolver();\n        Optional<ResourceLoader> resourceLoader = resourceResolver.getSupportingLoader(filePath);\n        ResourceLoader loader = resourceLoader.orElse(FileSystemResourceLoader.defaultLoader());\n        try {\n            Optional<InputStream> inputStream = loader.getResourceAsStream(filePath);\n            if (inputStream.isPresent()) {\n                return Optional.of(propertySourceLoader.read(fileName, inputStream.get()));\n            } else {\n                throw new ConfigurationException(\"Failed to read configuration file: \" + filePath);\n            }\n        } catch (IOException e) {\n            throw new ConfigurationException(\"Unsupported properties file: \" + fileName);\n        }\n    }\n\n    private EnvironmentsAndPackage getEnvironmentsAndPackage(List<String> specifiedNames) {\n        EnvironmentsAndPackage environmentsAndPackage = this.environmentsAndPackage;\n        final boolean extendedDeduction = !specifiedNames.contains(Environment.FUNCTION);\n        if (environmentsAndPackage == null) {\n            synchronized (EnvironmentsAndPackage.class) { // double check\n                environmentsAndPackage = this.environmentsAndPackage;\n                if (environmentsAndPackage == null) {\n                    environmentsAndPackage = deduceEnvironmentsAndPackage(\n                            shouldDeduceEnvironments(),\n                            extendedDeduction,\n                            extendedDeduction,\n                            !extendedDeduction\n                    );\n                    this.environmentsAndPackage = environmentsAndPackage;\n                }\n            }\n        }\n        return environmentsAndPackage;\n    }\n\n    private static EnvironmentsAndPackage deduceEnvironmentsAndPackage(\n            boolean deduceEnvironments,\n            boolean deduceComputePlatform,\n            boolean inspectTrace,",
    "code_after_change": "    }\n\n    @SuppressWarnings(\"MagicNumber\")\n    private Collection<PropertySourceLoader> evaluatePropertySourceLoaders() {\n        SoftServiceLoader<PropertySourceLoader> definitions = readPropertySourceLoaders();\n        Collection<PropertySourceLoader> allLoaders = new ArrayList<>(10);\n        definitions.collectAll(allLoaders);\n        for (PropertySourceLoader propertySourceLoader : allLoaders) {\n            Set<String> extensions = propertySourceLoader.getExtensions();\n            for (String extension : extensions) {\n                loaderByFormatMap.put(extension, propertySourceLoader);\n            }\n        }\n        return allLoaders;\n    }\n\n    private void loadPropertySourceFromLoader(String name, PropertySourceLoader propertySourceLoader, List<PropertySource> propertySources, ResourceLoader resourceLoader) {\n        Optional<PropertySource> defaultPropertySource = propertySourceLoader.load(name, resourceLoader);\n        defaultPropertySource.ifPresent(propertySources::add);\n        Set<String> activeNames = getActiveNames();\n        int i = 0;\n        for (String activeName: activeNames) {\n            Optional<PropertySource> propertySource = propertySourceLoader.loadEnv(name, resourceLoader, ActiveEnvironment.of(activeName, i));\n            propertySource.ifPresent(propertySources::add);\n            i++;\n        }\n    }\n\n    /**\n     * Read the property source.\n     *\n     * @param fileName             Name of the file to be used as property source name\n     * @param filePath             Absolute file path\n     * @param propertySourceLoader The appropriate property source loader\n     * @throws ConfigurationException If unable to find the appropriate property source loader for the given file\n     */\n    private Optional<Map<String, Object>> readPropertiesFromLoader(String fileName, String filePath, PropertySourceLoader propertySourceLoader) throws ConfigurationException {\n        ResourceLoader loader = new ResourceResolver().getSupportingLoader(filePath)\n                .orElse(FileSystemResourceLoader.defaultLoader());\n        try {\n            Optional<InputStream> inputStream = loader.getResourceAsStream(filePath);\n            if (inputStream.isPresent()) {\n                return Optional.of(propertySourceLoader.read(fileName, inputStream.get()));\n            } else {\n                throw new ConfigurationException(\"Failed to read configuration file: \" + filePath);\n            }\n        } catch (IOException e) {\n            throw new ConfigurationException(\"Unsupported properties file: \" + fileName);\n        }\n    }\n\n    private EnvironmentsAndPackage getEnvironmentsAndPackage(List<String> specifiedNames) {\n        EnvironmentsAndPackage environmentsAndPackage = this.environmentsAndPackage;\n        final boolean extendedDeduction = !specifiedNames.contains(Environment.FUNCTION);\n        if (environmentsAndPackage == null) {\n            synchronized (EnvironmentsAndPackage.class) { // double check\n                environmentsAndPackage = this.environmentsAndPackage;\n                if (environmentsAndPackage == null) {\n                    environmentsAndPackage = deduceEnvironmentsAndPackage(\n                            shouldDeduceEnvironments(),\n                            extendedDeduction,\n                            extendedDeduction,\n                            !extendedDeduction\n                    );\n                    this.environmentsAndPackage = environmentsAndPackage;\n                }\n            }\n        }\n        return environmentsAndPackage;\n    }\n\n    private static EnvironmentsAndPackage deduceEnvironmentsAndPackage(\n            boolean deduceEnvironments,\n            boolean deduceComputePlatform,\n            boolean inspectTrace,",
    "patch": "@@ -453,7 +453,7 @@ protected List<PropertySource> readPropertySourceListFromFiles(String files) {\n                             }\n                             order++;\n                         } else {\n-                            throw new ConfigurationException(\"Unsupported properties file format: \" + fileName);\n+                            throw new ConfigurationException(\"Unsupported properties file format: \" + filePath);\n                         }\n                     }\n                 }\n@@ -583,12 +583,11 @@ private void loadPropertySourceFromLoader(String name, PropertySourceLoader prop\n      * @param fileName             Name of the file to be used as property source name\n      * @param filePath             Absolute file path\n      * @param propertySourceLoader The appropriate property source loader\n-     * @throws ConfigurationException If unable to find the appropriate property soruce loader for the given file\n+     * @throws ConfigurationException If unable to find the appropriate property source loader for the given file\n      */\n     private Optional<Map<String, Object>> readPropertiesFromLoader(String fileName, String filePath, PropertySourceLoader propertySourceLoader) throws ConfigurationException {\n-        ResourceResolver resourceResolver = new ResourceResolver();\n-        Optional<ResourceLoader> resourceLoader = resourceResolver.getSupportingLoader(filePath);\n-        ResourceLoader loader = resourceLoader.orElse(FileSystemResourceLoader.defaultLoader());\n+        ResourceLoader loader = new ResourceResolver().getSupportingLoader(filePath)\n+                .orElse(FileSystemResourceLoader.defaultLoader());\n         try {\n             Optional<InputStream> inputStream = loader.getResourceAsStream(filePath);\n             if (inputStream.isPresent()) {",
    "function_modified_lines": {
      "added": [
        "     * @throws ConfigurationException If unable to find the appropriate property source loader for the given file\n",
        "        ResourceLoader loader = new ResourceResolver().getSupportingLoader(filePath)\n",
        "                .orElse(FileSystemResourceLoader.defaultLoader());\n"
      ],
      "deleted": [
        "     * @throws ConfigurationException If unable to find the appropriate property soruce loader for the given file\n",
        "        ResourceResolver resourceResolver = new ResourceResolver();\n",
        "        Optional<ResourceLoader> resourceLoader = resourceResolver.getSupportingLoader(filePath);\n",
        "        ResourceLoader loader = resourceLoader.orElse(FileSystemResourceLoader.defaultLoader());\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "Micronaut is a JVM-based, full stack Java framework designed for building JVM applications. A path traversal vulnerability exists in versions prior to 2.5.9. With a basic configuration, it is possible to access any file from a filesystem, using \"/../../\" in the URL. This occurs because Micronaut does not restrict file access to configured paths. The vulnerability is patched in version 2.5.9. As a workaround, do not use `**` in mapping, use only `*`, which exposes only flat structure of a directory not allowing traversal. If using Linux, another workaround is to run micronaut in chroot.",
    "id": 12189
  },
  {
    "cve_id": "CVE-2021-43289",
    "code_before_change": "{\n        JobIdentifier jobIdentifier;\n        if (!headerConstraint.isSatisfied(request)) {\n            return ResponseCodeView.create(HttpServletResponse.SC_BAD_REQUEST, \"Missing required header 'Confirm'\");\n        }\n        try {\n            jobIdentifier = restfulService.findJob(pipelineName, pipelineCounter, stageName, stageCounter,\n                    buildName, buildId);\n        } catch (Exception e) {\n            return buildNotFound(pipelineName, pipelineCounter, stageName, stageCounter,\n                    buildName);\n        }\n\n        int convertedAttempt = attempt == null ? 1 : attempt;\n\n        try {\n            File artifact = artifactsService.findArtifact(jobIdentifier, filePath);\n            if (artifact.exists() && artifact.isFile()) {\n                return FileModelAndView.fileAlreadyExists(filePath);\n            }\n\n            MultipartFile multipartFile = multipartFile(request);\n            if (multipartFile == null) {\n                return FileModelAndView.invalidUploadRequest();\n            }\n\n            boolean success = saveFile(convertedAttempt, artifact, multipartFile, shouldUnzipStream(multipartFile));\n\n            if (!success) {\n                return FileModelAndView.errorSavingFile(filePath);\n            }\n\n            success = updateChecksumFile(request, jobIdentifier, filePath);\n\n            if (!success) {\n                return FileModelAndView.errorSavingChecksumFile(filePath);\n            }\n\n            return FileModelAndView.fileCreated(filePath);\n\n        } catch (IllegalArtifactLocationException e) {\n            return FileModelAndView.forbiddenUrl(filePath);\n        }\n    }",
    "code_after_change": "{\n        JobIdentifier jobIdentifier;\n        if (!headerConstraint.isSatisfied(request)) {\n            return ResponseCodeView.create(HttpServletResponse.SC_BAD_REQUEST, \"Missing required header 'Confirm'\");\n        }\n        if (!isValidStageCounter(stageCounter)) {\n            return buildNotFound(pipelineName, pipelineCounter, stageName, stageCounter, buildName);\n        }\n        try {\n            jobIdentifier = restfulService.findJob(pipelineName, pipelineCounter, stageName, stageCounter,\n                    buildName, buildId);\n        } catch (Exception e) {\n            return buildNotFound(pipelineName, pipelineCounter, stageName, stageCounter,\n                    buildName);\n        }\n\n        int convertedAttempt = attempt == null ? 1 : attempt;\n\n        try {\n            File artifact = artifactsService.findArtifact(jobIdentifier, filePath);\n            if (artifact.exists() && artifact.isFile()) {\n                return FileModelAndView.fileAlreadyExists(filePath);\n            }\n\n            MultipartFile multipartFile = multipartFile(request);\n            if (multipartFile == null) {\n                return FileModelAndView.invalidUploadRequest();\n            }\n\n            boolean success = saveFile(convertedAttempt, artifact, multipartFile, shouldUnzipStream(multipartFile));\n\n            if (!success) {\n                return FileModelAndView.errorSavingFile(filePath);\n            }\n\n            success = updateChecksumFile(request, jobIdentifier, filePath);\n\n            if (!success) {\n                return FileModelAndView.errorSavingChecksumFile(filePath);\n            }\n\n            return FileModelAndView.fileCreated(filePath);\n\n        } catch (IllegalArtifactLocationException e) {\n            return FileModelAndView.forbiddenUrl(filePath);\n        }\n    }",
    "patch": "@@ -33,6 +33,7 @@\n import com.thoughtworks.go.server.web.ResponseCodeView;\n import com.thoughtworks.go.util.ArtifactLogUtil;\n import com.thoughtworks.go.util.SystemEnvironment;\n+import org.apache.commons.lang3.StringUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.springframework.beans.factory.annotation.Autowired;\n@@ -149,6 +150,9 @@ public ModelAndView postArtifact(@RequestParam(\"pipelineName\") String pipelineNa\n         if (!headerConstraint.isSatisfied(request)) {\n             return ResponseCodeView.create(HttpServletResponse.SC_BAD_REQUEST, \"Missing required header 'Confirm'\");\n         }\n+        if (!isValidStageCounter(stageCounter)) {\n+            return buildNotFound(pipelineName, pipelineCounter, stageName, stageCounter, buildName);\n+        }\n         try {\n             jobIdentifier = restfulService.findJob(pipelineName, pipelineCounter, stageName, stageCounter,\n                     buildName, buildId);\n@@ -224,6 +228,10 @@ public ModelAndView putArtifact(@RequestParam(\"pipelineName\") String pipelineNam\n             return FileModelAndView.forbiddenUrl(filePath);\n         }\n \n+        if (!isValidStageCounter(stageCounter)) {\n+            return buildNotFound(pipelineName, pipelineCounter, stageName, stageCounter, buildName);\n+        }\n+\n         JobIdentifier jobIdentifier;\n         try {\n             jobIdentifier = restfulService.findJob(pipelineName, pipelineCounter, stageName, stageCounter, buildName, buildId);\n@@ -341,4 +349,17 @@ private ModelAndView logsNotFound(JobIdentifier identifier) {\n         String notFound = String.format(\"Console log for %s is unavailable as it may have been purged by Go or deleted externally.\", identifier.toFullString());\n         return ResponseCodeView.create(SC_NOT_FOUND, notFound);\n     }\n+\n+    private boolean isValidStageCounter(String stageCounter) {\n+        if (StringUtils.isEmpty(stageCounter)) {\n+            return true;\n+        }\n+\n+        try {\n+            int value = Integer.parseInt(stageCounter);\n+            return value > 0;\n+        } catch (Exception e) {\n+            return false;\n+        }\n+    }\n }",
    "function_modified_lines": {
      "added": [
        "        if (!isValidStageCounter(stageCounter)) {\n",
        "            return buildNotFound(pipelineName, pipelineCounter, stageName, stageCounter, buildName);\n",
        "        }\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "An issue was discovered in ThoughtWorks GoCD before 21.3.0. An attacker who has compromised a GoCD agent can upload a malicious file into an arbitrary directory of a GoCD server, but does not control the filename.",
    "id": 12227
  },
  {
    "cve_id": "CVE-2021-43289",
    "code_before_change": "{\n        if (filePath.contains(\"..\")) {\n            return FileModelAndView.forbiddenUrl(filePath);\n        }\n\n        JobIdentifier jobIdentifier;\n        try {\n            jobIdentifier = restfulService.findJob(pipelineName, pipelineCounter, stageName, stageCounter, buildName, buildId);\n        } catch (Exception e) {\n            return buildNotFound(pipelineName, pipelineCounter, stageName, stageCounter, buildName);\n        }\n\n        if (isConsoleOutput(filePath)) {\n            return putConsoleOutput(jobIdentifier, request.getInputStream());\n        } else {\n            return putArtifact(jobIdentifier, filePath, request.getInputStream());\n        }\n    }",
    "code_after_change": "{\n        if (filePath.contains(\"..\")) {\n            return FileModelAndView.forbiddenUrl(filePath);\n        }\n\n        if (!isValidStageCounter(stageCounter)) {\n            return buildNotFound(pipelineName, pipelineCounter, stageName, stageCounter, buildName);\n        }\n\n        JobIdentifier jobIdentifier;\n        try {\n            jobIdentifier = restfulService.findJob(pipelineName, pipelineCounter, stageName, stageCounter, buildName, buildId);\n        } catch (Exception e) {\n            return buildNotFound(pipelineName, pipelineCounter, stageName, stageCounter, buildName);\n        }\n\n        if (isConsoleOutput(filePath)) {\n            return putConsoleOutput(jobIdentifier, request.getInputStream());\n        } else {\n            return putArtifact(jobIdentifier, filePath, request.getInputStream());\n        }\n    }",
    "patch": "@@ -33,6 +33,7 @@\n import com.thoughtworks.go.server.web.ResponseCodeView;\n import com.thoughtworks.go.util.ArtifactLogUtil;\n import com.thoughtworks.go.util.SystemEnvironment;\n+import org.apache.commons.lang3.StringUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.springframework.beans.factory.annotation.Autowired;\n@@ -149,6 +150,9 @@ public ModelAndView postArtifact(@RequestParam(\"pipelineName\") String pipelineNa\n         if (!headerConstraint.isSatisfied(request)) {\n             return ResponseCodeView.create(HttpServletResponse.SC_BAD_REQUEST, \"Missing required header 'Confirm'\");\n         }\n+        if (!isValidStageCounter(stageCounter)) {\n+            return buildNotFound(pipelineName, pipelineCounter, stageName, stageCounter, buildName);\n+        }\n         try {\n             jobIdentifier = restfulService.findJob(pipelineName, pipelineCounter, stageName, stageCounter,\n                     buildName, buildId);\n@@ -224,6 +228,10 @@ public ModelAndView putArtifact(@RequestParam(\"pipelineName\") String pipelineNam\n             return FileModelAndView.forbiddenUrl(filePath);\n         }\n \n+        if (!isValidStageCounter(stageCounter)) {\n+            return buildNotFound(pipelineName, pipelineCounter, stageName, stageCounter, buildName);\n+        }\n+\n         JobIdentifier jobIdentifier;\n         try {\n             jobIdentifier = restfulService.findJob(pipelineName, pipelineCounter, stageName, stageCounter, buildName, buildId);\n@@ -341,4 +349,17 @@ private ModelAndView logsNotFound(JobIdentifier identifier) {\n         String notFound = String.format(\"Console log for %s is unavailable as it may have been purged by Go or deleted externally.\", identifier.toFullString());\n         return ResponseCodeView.create(SC_NOT_FOUND, notFound);\n     }\n+\n+    private boolean isValidStageCounter(String stageCounter) {\n+        if (StringUtils.isEmpty(stageCounter)) {\n+            return true;\n+        }\n+\n+        try {\n+            int value = Integer.parseInt(stageCounter);\n+            return value > 0;\n+        } catch (Exception e) {\n+            return false;\n+        }\n+    }\n }",
    "function_modified_lines": {
      "added": [
        "        if (!isValidStageCounter(stageCounter)) {\n",
        "            return buildNotFound(pipelineName, pipelineCounter, stageName, stageCounter, buildName);\n",
        "        }\n",
        "\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "An issue was discovered in ThoughtWorks GoCD before 21.3.0. An attacker who has compromised a GoCD agent can upload a malicious file into an arbitrary directory of a GoCD server, but does not control the filename.",
    "id": 12228
  },
  {
    "cve_id": "CVE-2021-43290",
    "code_before_change": "{\n        JobIdentifier jobIdentifier;\n        if (!headerConstraint.isSatisfied(request)) {\n            return ResponseCodeView.create(HttpServletResponse.SC_BAD_REQUEST, \"Missing required header 'Confirm'\");\n        }\n        try {\n            jobIdentifier = restfulService.findJob(pipelineName, pipelineCounter, stageName, stageCounter,\n                    buildName, buildId);\n        } catch (Exception e) {\n            return buildNotFound(pipelineName, pipelineCounter, stageName, stageCounter,\n                    buildName);\n        }\n\n        int convertedAttempt = attempt == null ? 1 : attempt;\n\n        try {\n            File artifact = artifactsService.findArtifact(jobIdentifier, filePath);\n            if (artifact.exists() && artifact.isFile()) {\n                return FileModelAndView.fileAlreadyExists(filePath);\n            }\n\n            MultipartFile multipartFile = multipartFile(request);\n            if (multipartFile == null) {\n                return FileModelAndView.invalidUploadRequest();\n            }\n\n            boolean success = saveFile(convertedAttempt, artifact, multipartFile, shouldUnzipStream(multipartFile));\n\n            if (!success) {\n                return FileModelAndView.errorSavingFile(filePath);\n            }\n\n            success = updateChecksumFile(request, jobIdentifier, filePath);\n\n            if (!success) {\n                return FileModelAndView.errorSavingChecksumFile(filePath);\n            }\n\n            return FileModelAndView.fileCreated(filePath);\n\n        } catch (IllegalArtifactLocationException e) {\n            return FileModelAndView.forbiddenUrl(filePath);\n        }\n    }",
    "code_after_change": "{\n        JobIdentifier jobIdentifier;\n        if (!headerConstraint.isSatisfied(request)) {\n            return ResponseCodeView.create(HttpServletResponse.SC_BAD_REQUEST, \"Missing required header 'Confirm'\");\n        }\n        if (!isValidStageCounter(stageCounter)) {\n            return buildNotFound(pipelineName, pipelineCounter, stageName, stageCounter, buildName);\n        }\n        try {\n            jobIdentifier = restfulService.findJob(pipelineName, pipelineCounter, stageName, stageCounter,\n                    buildName, buildId);\n        } catch (Exception e) {\n            return buildNotFound(pipelineName, pipelineCounter, stageName, stageCounter,\n                    buildName);\n        }\n\n        int convertedAttempt = attempt == null ? 1 : attempt;\n\n        try {\n            File artifact = artifactsService.findArtifact(jobIdentifier, filePath);\n            if (artifact.exists() && artifact.isFile()) {\n                return FileModelAndView.fileAlreadyExists(filePath);\n            }\n\n            MultipartFile multipartFile = multipartFile(request);\n            if (multipartFile == null) {\n                return FileModelAndView.invalidUploadRequest();\n            }\n\n            boolean success = saveFile(convertedAttempt, artifact, multipartFile, shouldUnzipStream(multipartFile));\n\n            if (!success) {\n                return FileModelAndView.errorSavingFile(filePath);\n            }\n\n            success = updateChecksumFile(request, jobIdentifier, filePath);\n\n            if (!success) {\n                return FileModelAndView.errorSavingChecksumFile(filePath);\n            }\n\n            return FileModelAndView.fileCreated(filePath);\n\n        } catch (IllegalArtifactLocationException e) {\n            return FileModelAndView.forbiddenUrl(filePath);\n        }\n    }",
    "patch": "@@ -33,6 +33,7 @@\n import com.thoughtworks.go.server.web.ResponseCodeView;\n import com.thoughtworks.go.util.ArtifactLogUtil;\n import com.thoughtworks.go.util.SystemEnvironment;\n+import org.apache.commons.lang3.StringUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.springframework.beans.factory.annotation.Autowired;\n@@ -149,6 +150,9 @@ public ModelAndView postArtifact(@RequestParam(\"pipelineName\") String pipelineNa\n         if (!headerConstraint.isSatisfied(request)) {\n             return ResponseCodeView.create(HttpServletResponse.SC_BAD_REQUEST, \"Missing required header 'Confirm'\");\n         }\n+        if (!isValidStageCounter(stageCounter)) {\n+            return buildNotFound(pipelineName, pipelineCounter, stageName, stageCounter, buildName);\n+        }\n         try {\n             jobIdentifier = restfulService.findJob(pipelineName, pipelineCounter, stageName, stageCounter,\n                     buildName, buildId);\n@@ -224,6 +228,10 @@ public ModelAndView putArtifact(@RequestParam(\"pipelineName\") String pipelineNam\n             return FileModelAndView.forbiddenUrl(filePath);\n         }\n \n+        if (!isValidStageCounter(stageCounter)) {\n+            return buildNotFound(pipelineName, pipelineCounter, stageName, stageCounter, buildName);\n+        }\n+\n         JobIdentifier jobIdentifier;\n         try {\n             jobIdentifier = restfulService.findJob(pipelineName, pipelineCounter, stageName, stageCounter, buildName, buildId);\n@@ -341,4 +349,17 @@ private ModelAndView logsNotFound(JobIdentifier identifier) {\n         String notFound = String.format(\"Console log for %s is unavailable as it may have been purged by Go or deleted externally.\", identifier.toFullString());\n         return ResponseCodeView.create(SC_NOT_FOUND, notFound);\n     }\n+\n+    private boolean isValidStageCounter(String stageCounter) {\n+        if (StringUtils.isEmpty(stageCounter)) {\n+            return true;\n+        }\n+\n+        try {\n+            int value = Integer.parseInt(stageCounter);\n+            return value > 0;\n+        } catch (Exception e) {\n+            return false;\n+        }\n+    }\n }",
    "function_modified_lines": {
      "added": [
        "        if (!isValidStageCounter(stageCounter)) {\n",
        "            return buildNotFound(pipelineName, pipelineCounter, stageName, stageCounter, buildName);\n",
        "        }\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "An issue was discovered in ThoughtWorks GoCD before 21.3.0. An attacker who has compromised a GoCD agent can upload a malicious file into a directory of a GoCD server. They can control the filename but the directory is placed inside of a directory that they can't control.",
    "id": 12229
  },
  {
    "cve_id": "CVE-2021-43290",
    "code_before_change": "{\n        if (filePath.contains(\"..\")) {\n            return FileModelAndView.forbiddenUrl(filePath);\n        }\n\n        JobIdentifier jobIdentifier;\n        try {\n            jobIdentifier = restfulService.findJob(pipelineName, pipelineCounter, stageName, stageCounter, buildName, buildId);\n        } catch (Exception e) {\n            return buildNotFound(pipelineName, pipelineCounter, stageName, stageCounter, buildName);\n        }\n\n        if (isConsoleOutput(filePath)) {\n            return putConsoleOutput(jobIdentifier, request.getInputStream());\n        } else {\n            return putArtifact(jobIdentifier, filePath, request.getInputStream());\n        }\n    }",
    "code_after_change": "{\n        if (filePath.contains(\"..\")) {\n            return FileModelAndView.forbiddenUrl(filePath);\n        }\n\n        if (!isValidStageCounter(stageCounter)) {\n            return buildNotFound(pipelineName, pipelineCounter, stageName, stageCounter, buildName);\n        }\n\n        JobIdentifier jobIdentifier;\n        try {\n            jobIdentifier = restfulService.findJob(pipelineName, pipelineCounter, stageName, stageCounter, buildName, buildId);\n        } catch (Exception e) {\n            return buildNotFound(pipelineName, pipelineCounter, stageName, stageCounter, buildName);\n        }\n\n        if (isConsoleOutput(filePath)) {\n            return putConsoleOutput(jobIdentifier, request.getInputStream());\n        } else {\n            return putArtifact(jobIdentifier, filePath, request.getInputStream());\n        }\n    }",
    "patch": "@@ -33,6 +33,7 @@\n import com.thoughtworks.go.server.web.ResponseCodeView;\n import com.thoughtworks.go.util.ArtifactLogUtil;\n import com.thoughtworks.go.util.SystemEnvironment;\n+import org.apache.commons.lang3.StringUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.springframework.beans.factory.annotation.Autowired;\n@@ -149,6 +150,9 @@ public ModelAndView postArtifact(@RequestParam(\"pipelineName\") String pipelineNa\n         if (!headerConstraint.isSatisfied(request)) {\n             return ResponseCodeView.create(HttpServletResponse.SC_BAD_REQUEST, \"Missing required header 'Confirm'\");\n         }\n+        if (!isValidStageCounter(stageCounter)) {\n+            return buildNotFound(pipelineName, pipelineCounter, stageName, stageCounter, buildName);\n+        }\n         try {\n             jobIdentifier = restfulService.findJob(pipelineName, pipelineCounter, stageName, stageCounter,\n                     buildName, buildId);\n@@ -224,6 +228,10 @@ public ModelAndView putArtifact(@RequestParam(\"pipelineName\") String pipelineNam\n             return FileModelAndView.forbiddenUrl(filePath);\n         }\n \n+        if (!isValidStageCounter(stageCounter)) {\n+            return buildNotFound(pipelineName, pipelineCounter, stageName, stageCounter, buildName);\n+        }\n+\n         JobIdentifier jobIdentifier;\n         try {\n             jobIdentifier = restfulService.findJob(pipelineName, pipelineCounter, stageName, stageCounter, buildName, buildId);\n@@ -341,4 +349,17 @@ private ModelAndView logsNotFound(JobIdentifier identifier) {\n         String notFound = String.format(\"Console log for %s is unavailable as it may have been purged by Go or deleted externally.\", identifier.toFullString());\n         return ResponseCodeView.create(SC_NOT_FOUND, notFound);\n     }\n+\n+    private boolean isValidStageCounter(String stageCounter) {\n+        if (StringUtils.isEmpty(stageCounter)) {\n+            return true;\n+        }\n+\n+        try {\n+            int value = Integer.parseInt(stageCounter);\n+            return value > 0;\n+        } catch (Exception e) {\n+            return false;\n+        }\n+    }\n }",
    "function_modified_lines": {
      "added": [
        "        if (!isValidStageCounter(stageCounter)) {\n",
        "            return buildNotFound(pipelineName, pipelineCounter, stageName, stageCounter, buildName);\n",
        "        }\n",
        "\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "An issue was discovered in ThoughtWorks GoCD before 21.3.0. An attacker who has compromised a GoCD agent can upload a malicious file into a directory of a GoCD server. They can control the filename but the directory is placed inside of a directory that they can't control.",
    "id": 12230
  },
  {
    "cve_id": "CVE-2021-43289",
    "code_before_change": "{\n        start = start == null ? 0L : start;\n\n        try {\n            JobIdentifier identifier = restfulService.findJob(pipelineName, pipelineCounter, stageName, stageCounter, buildName);\n            if (jobInstanceDao.isJobCompleted(identifier) && !consoleService.doesLogExist(identifier)) {\n                return logsNotFound(identifier);\n            }\n            ConsoleConsumer streamer = consoleService.getStreamer(start, identifier);\n            return new ModelAndView(new ConsoleOutView(streamer, consoleLogCharset));\n        } catch (Exception e) {\n            return buildNotFound(pipelineName, pipelineCounter, stageName, stageCounter, buildName);\n        }\n    }",
    "code_after_change": "{\n        start = start == null ? 0L : start;\n\n        if (!isValidStageCounter(stageCounter)) {\n            return buildNotFound(pipelineName, pipelineCounter, stageName, stageCounter, buildName);\n        }\n\n        try {\n            JobIdentifier identifier = restfulService.findJob(pipelineName, pipelineCounter, stageName, stageCounter, buildName);\n            if (jobInstanceDao.isJobCompleted(identifier) && !consoleService.doesLogExist(identifier)) {\n                return logsNotFound(identifier);\n            }\n            ConsoleConsumer streamer = consoleService.getStreamer(start, identifier);\n            return new ModelAndView(new ConsoleOutView(streamer, consoleLogCharset));\n        } catch (Exception e) {\n            return buildNotFound(pipelineName, pipelineCounter, stageName, stageCounter, buildName);\n        }\n    }",
    "patch": "@@ -259,6 +259,10 @@ public ModelAndView consoleout(@RequestParam(\"pipelineName\") String pipelineName\n     ) {\n         start = start == null ? 0L : start;\n \n+        if (!isValidStageCounter(stageCounter)) {\n+            return buildNotFound(pipelineName, pipelineCounter, stageName, stageCounter, buildName);\n+        }\n+\n         try {\n             JobIdentifier identifier = restfulService.findJob(pipelineName, pipelineCounter, stageName, stageCounter, buildName);\n             if (jobInstanceDao.isJobCompleted(identifier) && !consoleService.doesLogExist(identifier)) {\n@@ -281,6 +285,11 @@ public ModelAndView handleError(HttpServletRequest request, HttpServletResponse\n \n     ModelAndView getArtifact(String filePath, ArtifactFolderViewFactory folderViewFactory, String pipelineName, String counterOrLabel, String stageName, String stageCounter, String buildName, String sha, String serverAlias) throws Exception {\n         LOGGER.info(\"[Artifact Download] Trying to resolve '{}' for '{}/{}/{}/{}/{}'\", filePath, pipelineName, counterOrLabel, stageName, stageCounter, buildName);\n+\n+        if (!isValidStageCounter(stageCounter)) {\n+            return buildNotFound(pipelineName, counterOrLabel, stageName, stageCounter, buildName);\n+        }\n+\n         long before = System.currentTimeMillis();\n         ArtifactsView view;\n         //Work out the job that we are trying to retrieve",
    "function_modified_lines": {
      "added": [
        "        if (!isValidStageCounter(stageCounter)) {\n",
        "            return buildNotFound(pipelineName, pipelineCounter, stageName, stageCounter, buildName);\n",
        "        }\n",
        "\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "An issue was discovered in ThoughtWorks GoCD before 21.3.0. An attacker who has compromised a GoCD agent can upload a malicious file into an arbitrary directory of a GoCD server, but does not control the filename.",
    "id": 12233
  },
  {
    "cve_id": "CVE-2021-43289",
    "code_before_change": "    }\n\n    /* Other URLs */\n\n    @RequestMapping(value = \"/**/consoleout.json\", method = RequestMethod.GET)\n    public ModelAndView consoleout(@RequestParam(\"pipelineName\") String pipelineName,\n                                   @RequestParam(\"pipelineCounter\") String pipelineCounter,\n                                   @RequestParam(\"stageName\") String stageName,\n                                   @RequestParam(\"buildName\") String buildName,\n                                   @RequestParam(value = \"stageCounter\", required = false) String stageCounter,\n                                   @RequestParam(value = \"startLineNumber\", required = false) Long start\n    ) {\n        start = start == null ? 0L : start;\n\n        try {\n            JobIdentifier identifier = restfulService.findJob(pipelineName, pipelineCounter, stageName, stageCounter, buildName);\n            if (jobInstanceDao.isJobCompleted(identifier) && !consoleService.doesLogExist(identifier)) {\n                return logsNotFound(identifier);\n            }\n            ConsoleConsumer streamer = consoleService.getStreamer(start, identifier);\n            return new ModelAndView(new ConsoleOutView(streamer, consoleLogCharset));\n        } catch (Exception e) {\n            return buildNotFound(pipelineName, pipelineCounter, stageName, stageCounter, buildName);\n        }\n    }\n\n    @ErrorHandler\n    public ModelAndView handleError(HttpServletRequest request, HttpServletResponse response, Exception e) {\n        LOGGER.error(\"Error loading artifacts: \", e);\n        Map model = new HashMap();\n        model.put(ERROR_FOR_PAGE, \"Artifact does not exist.\");\n        return new ModelAndView(\"exceptions_page\", model);\n    }\n\n    ModelAndView getArtifact(String filePath, ArtifactFolderViewFactory folderViewFactory, String pipelineName, String counterOrLabel, String stageName, String stageCounter, String buildName, String sha, String serverAlias) throws Exception {\n        LOGGER.info(\"[Artifact Download] Trying to resolve '{}' for '{}/{}/{}/{}/{}'\", filePath, pipelineName, counterOrLabel, stageName, stageCounter, buildName);\n        long before = System.currentTimeMillis();\n        ArtifactsView view;\n        //Work out the job that we are trying to retrieve\n        JobIdentifier translatedId;\n        try {\n            translatedId = restfulService.findJob(pipelineName, counterOrLabel, stageName, stageCounter, buildName);\n        } catch (Exception e) {\n            return buildNotFound(pipelineName, counterOrLabel, stageName, stageCounter, buildName);\n        }\n\n        if (filePath.contains(\"..\")) {\n            return FileModelAndView.forbiddenUrl(filePath);\n        }\n\n        view = new LocalArtifactsView(folderViewFactory, artifactsService, translatedId, consoleService);\n\n        ModelAndView createdView = view.createView(filePath, sha);\n        LOGGER.info(\"[Artifact Download] Successfully resolved '{}' for '{}/{}/{}/{}/{}'. It took: {}ms\", filePath, pipelineName, counterOrLabel, stageName, stageCounter, buildName, System.currentTimeMillis() - before);\n        return createdView;\n    }\n\n    private boolean shouldUnzipStream(MultipartFile multipartFile) {\n        return multipartFile.getName().equals(ZIP_MULTIPART_FILENAME);\n    }\n\n    private MultipartFile multipartFile(MultipartHttpServletRequest request) {\n        MultipartFile multipartFile = request.getFile(REGULAR_MULTIPART_FILENAME);\n        if (multipartFile == null) {\n            multipartFile = request.getFile(ZIP_MULTIPART_FILENAME);\n        }\n        return multipartFile;\n    }\n\n    private MultipartFile getChecksumFile(MultipartHttpServletRequest request) {\n        return request.getFile(CHECKSUM_MULTIPART_FILENAME);\n    }\n\n    private ModelAndView putConsoleOutput(final JobIdentifier jobIdentifier, final InputStream inputStream) throws Exception {",
    "code_after_change": "{\n        LOGGER.info(\"[Artifact Download] Trying to resolve '{}' for '{}/{}/{}/{}/{}'\", filePath, pipelineName, counterOrLabel, stageName, stageCounter, buildName);\n\n        if (!isValidStageCounter(stageCounter)) {\n            return buildNotFound(pipelineName, counterOrLabel, stageName, stageCounter, buildName);\n        }\n\n        long before = System.currentTimeMillis();\n        ArtifactsView view;\n        //Work out the job that we are trying to retrieve\n        JobIdentifier translatedId;\n        try {\n            translatedId = restfulService.findJob(pipelineName, counterOrLabel, stageName, stageCounter, buildName);\n        } catch (Exception e) {\n            return buildNotFound(pipelineName, counterOrLabel, stageName, stageCounter, buildName);\n        }\n\n        if (filePath.contains(\"..\")) {\n            return FileModelAndView.forbiddenUrl(filePath);\n        }\n\n        view = new LocalArtifactsView(folderViewFactory, artifactsService, translatedId, consoleService);\n\n        ModelAndView createdView = view.createView(filePath, sha);\n        LOGGER.info(\"[Artifact Download] Successfully resolved '{}' for '{}/{}/{}/{}/{}'. It took: {}ms\", filePath, pipelineName, counterOrLabel, stageName, stageCounter, buildName, System.currentTimeMillis() - before);\n        return createdView;\n    }",
    "patch": "@@ -259,6 +259,10 @@ public ModelAndView consoleout(@RequestParam(\"pipelineName\") String pipelineName\n     ) {\n         start = start == null ? 0L : start;\n \n+        if (!isValidStageCounter(stageCounter)) {\n+            return buildNotFound(pipelineName, pipelineCounter, stageName, stageCounter, buildName);\n+        }\n+\n         try {\n             JobIdentifier identifier = restfulService.findJob(pipelineName, pipelineCounter, stageName, stageCounter, buildName);\n             if (jobInstanceDao.isJobCompleted(identifier) && !consoleService.doesLogExist(identifier)) {\n@@ -281,6 +285,11 @@ public ModelAndView handleError(HttpServletRequest request, HttpServletResponse\n \n     ModelAndView getArtifact(String filePath, ArtifactFolderViewFactory folderViewFactory, String pipelineName, String counterOrLabel, String stageName, String stageCounter, String buildName, String sha, String serverAlias) throws Exception {\n         LOGGER.info(\"[Artifact Download] Trying to resolve '{}' for '{}/{}/{}/{}/{}'\", filePath, pipelineName, counterOrLabel, stageName, stageCounter, buildName);\n+\n+        if (!isValidStageCounter(stageCounter)) {\n+            return buildNotFound(pipelineName, counterOrLabel, stageName, stageCounter, buildName);\n+        }\n+\n         long before = System.currentTimeMillis();\n         ArtifactsView view;\n         //Work out the job that we are trying to retrieve",
    "function_modified_lines": {
      "added": [
        "\n",
        "        if (!isValidStageCounter(stageCounter)) {\n",
        "            return buildNotFound(pipelineName, counterOrLabel, stageName, stageCounter, buildName);\n",
        "        }\n",
        "\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "An issue was discovered in ThoughtWorks GoCD before 21.3.0. An attacker who has compromised a GoCD agent can upload a malicious file into an arbitrary directory of a GoCD server, but does not control the filename.",
    "id": 12234
  },
  {
    "cve_id": "CVE-2021-43290",
    "code_before_change": "{\n        start = start == null ? 0L : start;\n\n        try {\n            JobIdentifier identifier = restfulService.findJob(pipelineName, pipelineCounter, stageName, stageCounter, buildName);\n            if (jobInstanceDao.isJobCompleted(identifier) && !consoleService.doesLogExist(identifier)) {\n                return logsNotFound(identifier);\n            }\n            ConsoleConsumer streamer = consoleService.getStreamer(start, identifier);\n            return new ModelAndView(new ConsoleOutView(streamer, consoleLogCharset));\n        } catch (Exception e) {\n            return buildNotFound(pipelineName, pipelineCounter, stageName, stageCounter, buildName);\n        }\n    }",
    "code_after_change": "{\n        start = start == null ? 0L : start;\n\n        if (!isValidStageCounter(stageCounter)) {\n            return buildNotFound(pipelineName, pipelineCounter, stageName, stageCounter, buildName);\n        }\n\n        try {\n            JobIdentifier identifier = restfulService.findJob(pipelineName, pipelineCounter, stageName, stageCounter, buildName);\n            if (jobInstanceDao.isJobCompleted(identifier) && !consoleService.doesLogExist(identifier)) {\n                return logsNotFound(identifier);\n            }\n            ConsoleConsumer streamer = consoleService.getStreamer(start, identifier);\n            return new ModelAndView(new ConsoleOutView(streamer, consoleLogCharset));\n        } catch (Exception e) {\n            return buildNotFound(pipelineName, pipelineCounter, stageName, stageCounter, buildName);\n        }\n    }",
    "patch": "@@ -259,6 +259,10 @@ public ModelAndView consoleout(@RequestParam(\"pipelineName\") String pipelineName\n     ) {\n         start = start == null ? 0L : start;\n \n+        if (!isValidStageCounter(stageCounter)) {\n+            return buildNotFound(pipelineName, pipelineCounter, stageName, stageCounter, buildName);\n+        }\n+\n         try {\n             JobIdentifier identifier = restfulService.findJob(pipelineName, pipelineCounter, stageName, stageCounter, buildName);\n             if (jobInstanceDao.isJobCompleted(identifier) && !consoleService.doesLogExist(identifier)) {\n@@ -281,6 +285,11 @@ public ModelAndView handleError(HttpServletRequest request, HttpServletResponse\n \n     ModelAndView getArtifact(String filePath, ArtifactFolderViewFactory folderViewFactory, String pipelineName, String counterOrLabel, String stageName, String stageCounter, String buildName, String sha, String serverAlias) throws Exception {\n         LOGGER.info(\"[Artifact Download] Trying to resolve '{}' for '{}/{}/{}/{}/{}'\", filePath, pipelineName, counterOrLabel, stageName, stageCounter, buildName);\n+\n+        if (!isValidStageCounter(stageCounter)) {\n+            return buildNotFound(pipelineName, counterOrLabel, stageName, stageCounter, buildName);\n+        }\n+\n         long before = System.currentTimeMillis();\n         ArtifactsView view;\n         //Work out the job that we are trying to retrieve",
    "function_modified_lines": {
      "added": [
        "        if (!isValidStageCounter(stageCounter)) {\n",
        "            return buildNotFound(pipelineName, pipelineCounter, stageName, stageCounter, buildName);\n",
        "        }\n",
        "\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "An issue was discovered in ThoughtWorks GoCD before 21.3.0. An attacker who has compromised a GoCD agent can upload a malicious file into a directory of a GoCD server. They can control the filename but the directory is placed inside of a directory that they can't control.",
    "id": 12235
  },
  {
    "cve_id": "CVE-2023-37913",
    "code_before_change": "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.officeimporter.document;\n\nimport java.util.Map;\n\npublic interface CompatibilityOfficeDocument\n{\n    /**\n     * Returns all the artifacts for this office document. Artifacts are generated during the import operation if the\n     * original office document contains embedded non-textual elements. Also, some office formats (like presentations)\n     * result in multiple output files when converted into html. In this case all these output files will be considered\n     * as artifacts.\n     *\n     * @return a map containing artifacts for this document.\n     * @deprecated Since 13.1RC1 use {@link OfficeDocument#getArtifactsFiles()}.\n     */\n    @Deprecated\n    Map<String, byte[]> getArtifacts();\n}\n",
    "code_after_change": "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.officeimporter.document;\n\nimport java.io.File;\nimport java.util.Collections;\nimport java.util.Map;\nimport java.util.Set;\n\npublic interface CompatibilityOfficeDocument\n{\n    /**\n     * Returns all the artifacts for this office document. Artifacts are generated during the import operation if the\n     * original office document contains embedded non-textual elements. Also, some office formats (like presentations)\n     * result in multiple output files when converted into html. In this case all these output files will be considered\n     * as artifacts.\n     *\n     * @return a map containing artifacts for this document.\n     * @deprecated Since 13.1RC1 use {@link #getArtifactsFiles()}.\n     */\n    @Deprecated\n    Map<String, byte[]> getArtifacts();\n\n    /**\n     * Returns the files corresponding to all the artifacts for this office document, except the conversion of the\n     * document itself.\n     * Artifacts are generated during the import operation if the original office document contains embedded\n     * non-textual elements. Also, some office formats (like presentations) result in multiple output files when\n     * converted into html. In this case all these output files will be considered as artifacts.\n     *\n     * @return the set of artifacts related to this office document.\n     * @since 13.1RC1\n     * @deprecated Use {@link OfficeDocument#getArtifactsMap()} instead.\n     */\n    @Deprecated(since = \"15.3RC1, 14.10.8\")\n    default Set<File> getArtifactsFiles()\n    {\n        return Collections.emptySet();\n    }\n}\n",
    "patch": "@@ -19,7 +19,10 @@\n  */\n package org.xwiki.officeimporter.document;\n \n+import java.io.File;\n+import java.util.Collections;\n import java.util.Map;\n+import java.util.Set;\n \n public interface CompatibilityOfficeDocument\n {\n@@ -30,8 +33,25 @@ public interface CompatibilityOfficeDocument\n      * as artifacts.\n      *\n      * @return a map containing artifacts for this document.\n-     * @deprecated Since 13.1RC1 use {@link OfficeDocument#getArtifactsFiles()}.\n+     * @deprecated Since 13.1RC1 use {@link #getArtifactsFiles()}.\n      */\n     @Deprecated\n     Map<String, byte[]> getArtifacts();\n+\n+    /**\n+     * Returns the files corresponding to all the artifacts for this office document, except the conversion of the\n+     * document itself.\n+     * Artifacts are generated during the import operation if the original office document contains embedded\n+     * non-textual elements. Also, some office formats (like presentations) result in multiple output files when\n+     * converted into html. In this case all these output files will be considered as artifacts.\n+     *\n+     * @return the set of artifacts related to this office document.\n+     * @since 13.1RC1\n+     * @deprecated Use {@link OfficeDocument#getArtifactsMap()} instead.\n+     */\n+    @Deprecated(since = \"15.3RC1, 14.10.8\")\n+    default Set<File> getArtifactsFiles()\n+    {\n+        return Collections.emptySet();\n+    }\n }",
    "function_modified_lines": {
      "added": [
        "import java.io.File;\n",
        "import java.util.Collections;\n",
        "import java.util.Set;\n",
        "     * @deprecated Since 13.1RC1 use {@link #getArtifactsFiles()}.\n",
        "\n",
        "    /**\n",
        "     * Returns the files corresponding to all the artifacts for this office document, except the conversion of the\n",
        "     * document itself.\n",
        "     * Artifacts are generated during the import operation if the original office document contains embedded\n",
        "     * non-textual elements. Also, some office formats (like presentations) result in multiple output files when\n",
        "     * converted into html. In this case all these output files will be considered as artifacts.\n",
        "     *\n",
        "     * @return the set of artifacts related to this office document.\n",
        "     * @since 13.1RC1\n",
        "     * @deprecated Use {@link OfficeDocument#getArtifactsMap()} instead.\n",
        "     */\n",
        "    @Deprecated(since = \"15.3RC1, 14.10.8\")\n",
        "    default Set<File> getArtifactsFiles()\n",
        "    {\n",
        "        return Collections.emptySet();\n",
        "    }\n"
      ],
      "deleted": [
        "     * @deprecated Since 13.1RC1 use {@link OfficeDocument#getArtifactsFiles()}.\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "XWiki Platform is a generic wiki platform offering runtime services for applications built on top of it. Starting in version 3.5-milestone-1 and prior to versions 14.10.8 and 15.3-rc-1, triggering the office converter with a specially crafted file name allows writing the attachment's content to an attacker-controlled location on the server as long as the Java process has write access to that location. In particular in the combination with attachment moving, a feature introduced in XWiki 14.0, this is easy to reproduce but it also possible to reproduce in versions as old as XWiki 3.5 by uploading the attachment through the REST API which doesn't remove `/` or `\\` from the filename. As the mime type of the attachment doesn't matter for the exploitation, this could e.g., be used to replace the `jar`-file of an extension which would allow executing arbitrary Java code and thus impact the confidentiality, integrity and availability of the XWiki installation. This vulnerability has been patched in XWiki 14.10.8 and 15.3RC1. There are no known workarounds apart from disabling the office converter.",
    "id": 12392
  },
  {
    "cve_id": "CVE-2023-37913",
    "code_before_change": "@Override\n    public Set<File> getArtifactsFiles()\n    {\n        return this.artifactFiles;\n    }",
    "code_after_change": "@Override\n    public Map<String, OfficeDocumentArtifact> getArtifactsMap()\n    {\n        return this.artifactsMap;\n    }",
    "patch": "@@ -19,9 +19,8 @@\n  */\n package org.xwiki.officeimporter.document;\n \n-import java.io.File;\n import java.io.IOException;\n-import java.util.Set;\n+import java.util.Map;\n \n import org.apache.commons.lang3.StringUtils;\n import org.xwiki.component.manager.ComponentLookupException;\n@@ -35,6 +34,7 @@\n import org.xwiki.rendering.renderer.printer.DefaultWikiPrinter;\n import org.xwiki.rendering.renderer.printer.WikiPrinter;\n import org.xwiki.rendering.syntax.Syntax;\n+import org.xwiki.stability.Unstable;\n \n /**\n  * An {@link OfficeDocument} backed by an {@link XDOM} document.\n@@ -52,7 +52,7 @@ public class XDOMOfficeDocument implements OfficeDocument\n     /**\n      * Artifacts for this office document.\n      */\n-    private Set<File> artifactFiles;\n+    private final Map<String, OfficeDocumentArtifact> artifactsMap;\n \n     /**\n      * {@link ComponentManager} used to lookup for various renderers.\n@@ -65,16 +65,18 @@ public class XDOMOfficeDocument implements OfficeDocument\n      * Creates a new {@link XDOMOfficeDocument}.\n      *\n      * @param xdom {@link XDOM} corresponding to office document content.\n-     * @param artifactFiles artifacts for this office document.\n+     * @param artifacts artifacts for this office document.\n      * @param componentManager {@link ComponentManager} used to lookup for various renderers.\n      * @param converterResult the {@link OfficeConverterResult} used to build that object.\n-     * @since 13.1RC1\n+     * @since 14.10.8\n+     * @since 15.3-rc-1\n      */\n-    public XDOMOfficeDocument(XDOM xdom, Set<File> artifactFiles, ComponentManager componentManager,\n-        OfficeConverterResult converterResult)\n+    @Unstable\n+    public XDOMOfficeDocument(XDOM xdom, Map<String, OfficeDocumentArtifact> artifacts,\n+        ComponentManager componentManager, OfficeConverterResult converterResult)\n     {\n         this.xdom = xdom;\n-        this.artifactFiles = artifactFiles;\n+        this.artifactsMap = artifacts;\n         this.componentManager = componentManager;\n         this.converterResult = converterResult;\n     }\n@@ -111,9 +113,9 @@ public String getContentAsString(String syntaxId)\n     }\n \n     @Override\n-    public Set<File> getArtifactsFiles()\n+    public Map<String, OfficeDocumentArtifact> getArtifactsMap()\n     {\n-        return this.artifactFiles;\n+        return this.artifactsMap;\n     }\n \n     /**",
    "function_modified_lines": {
      "added": [
        "    public Map<String, OfficeDocumentArtifact> getArtifactsMap()\n",
        "        return this.artifactsMap;\n"
      ],
      "deleted": [
        "    public Set<File> getArtifactsFiles()\n",
        "        return this.artifactFiles;\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "XWiki Platform is a generic wiki platform offering runtime services for applications built on top of it. Starting in version 3.5-milestone-1 and prior to versions 14.10.8 and 15.3-rc-1, triggering the office converter with a specially crafted file name allows writing the attachment's content to an attacker-controlled location on the server as long as the Java process has write access to that location. In particular in the combination with attachment moving, a feature introduced in XWiki 14.0, this is easy to reproduce but it also possible to reproduce in versions as old as XWiki 3.5 by uploading the attachment through the REST API which doesn't remove `/` or `\\` from the filename. As the mime type of the attachment doesn't matter for the exploitation, this could e.g., be used to replace the `jar`-file of an extension which would allow executing arbitrary Java code and thus impact the confidentiality, integrity and availability of the XWiki installation. This vulnerability has been patched in XWiki 14.10.8 and 15.3RC1. There are no known workarounds apart from disabling the office converter.",
    "id": 12393
  },
  {
    "cve_id": "CVE-2023-37913",
    "code_before_change": "@Override\n    public Set<File> getArtifactsFiles()\n    {\n        return this.artifactFiles;\n    }",
    "code_after_change": "@Override\n    public Map<String, OfficeDocumentArtifact> getArtifactsMap()\n    {\n        return this.artifactsMap;\n    }",
    "patch": "@@ -19,12 +19,12 @@\n  */\n package org.xwiki.officeimporter.document;\n \n-import java.io.File;\n import java.io.IOException;\n-import java.util.Set;\n+import java.util.Map;\n \n import org.w3c.dom.Document;\n import org.xwiki.officeimporter.converter.OfficeConverterResult;\n+import org.xwiki.stability.Unstable;\n import org.xwiki.xml.html.HTMLUtils;\n \n /**\n@@ -43,22 +43,25 @@ public class XHTMLOfficeDocument implements OfficeDocument\n     /**\n      * Artifacts for this office document.\n      */\n-    private Set<File> artifactFiles;\n+    private Map<String, OfficeDocumentArtifact> artifactsMap;\n \n     private OfficeConverterResult converterResult;\n \n     /**\n      * Creates a new {@link XHTMLOfficeDocument}.\n      *\n      * @param document the w3c dom representing the office document.\n-     * @param artifactFiles artifacts for this office document.\n+     * @param artifacts artifacts for this office document.\n      * @param converterResult the {@link OfficeConverterResult} used to build that object.\n-     * @since 13.1RC1\n+     * @since 14.10.8\n+     * @since 15.3RC1\n      */\n-    public XHTMLOfficeDocument(Document document, Set<File> artifactFiles, OfficeConverterResult converterResult)\n+    @Unstable\n+    public XHTMLOfficeDocument(Document document, Map<String, OfficeDocumentArtifact> artifacts,\n+        OfficeConverterResult converterResult)\n     {\n         this.document = document;\n-        this.artifactFiles = artifactFiles;\n+        this.artifactsMap = artifacts;\n         this.converterResult = converterResult;\n     }\n \n@@ -75,9 +78,9 @@ public String getContentAsString()\n     }\n \n     @Override\n-    public Set<File> getArtifactsFiles()\n+    public Map<String, OfficeDocumentArtifact> getArtifactsMap()\n     {\n-        return this.artifactFiles;\n+        return this.artifactsMap;\n     }\n \n     @Override",
    "function_modified_lines": {
      "added": [
        "    public Map<String, OfficeDocumentArtifact> getArtifactsMap()\n",
        "        return this.artifactsMap;\n"
      ],
      "deleted": [
        "    public Set<File> getArtifactsFiles()\n",
        "        return this.artifactFiles;\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "XWiki Platform is a generic wiki platform offering runtime services for applications built on top of it. Starting in version 3.5-milestone-1 and prior to versions 14.10.8 and 15.3-rc-1, triggering the office converter with a specially crafted file name allows writing the attachment's content to an attacker-controlled location on the server as long as the Java process has write access to that location. In particular in the combination with attachment moving, a feature introduced in XWiki 14.0, this is easy to reproduce but it also possible to reproduce in versions as old as XWiki 3.5 by uploading the attachment through the REST API which doesn't remove `/` or `\\` from the filename. As the mime type of the attachment doesn't matter for the exploitation, this could e.g., be used to replace the `jar`-file of an extension which would allow executing arbitrary Java code and thus impact the confidentiality, integrity and availability of the XWiki installation. This vulnerability has been patched in XWiki 14.10.8 and 15.3RC1. There are no known workarounds apart from disabling the office converter.",
    "id": 12394
  },
  {
    "cve_id": "CVE-2023-37913",
    "code_before_change": "{\n    /**\n     * The object used to log messages.\n     */\n    @Inject\n    private Logger logger;\n\n    @Inject\n    private ContextualAuthorizationManager contextualAuthorizationManager;\n\n    /**\n     * The {@link DocumentAccessBridge} component.\n     */\n    @Inject\n    private DocumentAccessBridge docBridge;\n\n    /**\n     * Attempts to save the given {@link XDOMOfficeDocument} into the target wiki page specified by arguments.\n     * \n     * @param doc {@link XDOMOfficeDocument} to be saved\n     * @param documentReference the reference of the target wiki page\n     * @param syntaxId syntax of the target wiki page\n     * @param parentReference the reference of the parent wiki page or {@code null}\n     * @param title title of the target wiki page or {@code null}\n     * @param append whether to append content if the target wiki page exists\n     */\n    public void save(XDOMOfficeDocument doc, DocumentReference documentReference, String syntaxId,\n        DocumentReference parentReference, String title, boolean append) throws Exception\n    {\n        // First check if the user has edit rights on the target document.\n        if (!this.contextualAuthorizationManager.hasAccess(Right.EDIT, documentReference)) {\n            String message = \"You do not have edit rights on [%s] document.\";\n            throw new OfficeImporterException(String.format(message, documentReference));\n        }\n\n        // Save.\n        if (this.docBridge.exists(documentReference) && append) {\n            // Check whether existing document's syntax is same as target syntax.\n            String currentSyntaxId =\n                this.docBridge.getTranslatedDocumentInstance(documentReference).getSyntax().toIdString();\n            if (!currentSyntaxId.equals(syntaxId)) {\n                String message =\n                    \"The target page [%s] exists but its syntax [%s] is different from the specified syntax [%s]\";\n                throw new OfficeImporterException(String.format(message, documentReference, currentSyntaxId, syntaxId));\n            }\n\n            // Append the content.\n            String currentContent = this.docBridge.getDocumentContent(documentReference, null);\n            String newContent = currentContent + \"\\n\" + doc.getContentAsString(syntaxId);\n            this.docBridge.setDocumentContent(documentReference, newContent, \"Updated by office importer.\", false);\n        } else {\n            this.docBridge.setDocumentSyntaxId(documentReference, syntaxId);\n            this.docBridge.setDocumentContent(documentReference, doc.getContentAsString(syntaxId),\n                \"Created by office importer.\", false);\n\n            // Set parent if provided.\n            if (null != parentReference) {\n                this.docBridge.setDocumentParentReference(documentReference, parentReference);\n            }\n\n            // If no title is specified, try to extract one.\n            String docTitle = (null == title) ? doc.getTitle() : title;\n\n            // Set title if applicable.\n            if (null != docTitle) {\n                this.docBridge.setDocumentTitle(documentReference, docTitle);\n            }\n        }\n\n        // Finally attach all the artifacts into target document.\n        attachArtifacts(doc.getArtifactsFiles(), documentReference);\n    }\n\n    /**\n     * Utility method for attaching artifacts into a wiki page.\n     * \n     * @param artifactFiles set of artifact files.\n     * @param targetDocumentReference target wiki page into which artifacts are to be attached\n     */\n    private void attachArtifacts(Set<File> artifactFiles, DocumentReference targetDocumentReference)\n    {\n        for (File artifact : artifactFiles) {\n            AttachmentReference attachmentReference =\n                new AttachmentReference(artifact.getName(), targetDocumentReference);\n            try (FileInputStream fis = new FileInputStream(artifact)) {\n                this.docBridge.setAttachmentContent(attachmentReference, IOUtils.toByteArray(fis));\n            } catch (Exception ex) {\n                // Log the error and skip the artifact.\n                this.logger.error(\"Error while attaching artifact.\", ex);\n            }\n        }\n    }\n}",
    "code_after_change": "{\n    /**\n     * The object used to log messages.\n     */\n    @Inject\n    private Logger logger;\n\n    @Inject\n    private ContextualAuthorizationManager contextualAuthorizationManager;\n\n    /**\n     * The {@link DocumentAccessBridge} component.\n     */\n    @Inject\n    private DocumentAccessBridge docBridge;\n\n    /**\n     * Attempts to save the given {@link XDOMOfficeDocument} into the target wiki page specified by arguments.\n     * \n     * @param doc {@link XDOMOfficeDocument} to be saved\n     * @param documentReference the reference of the target wiki page\n     * @param syntaxId syntax of the target wiki page\n     * @param parentReference the reference of the parent wiki page or {@code null}\n     * @param title title of the target wiki page or {@code null}\n     * @param append whether to append content if the target wiki page exists\n     */\n    public void save(XDOMOfficeDocument doc, DocumentReference documentReference, String syntaxId,\n        DocumentReference parentReference, String title, boolean append) throws Exception\n    {\n        // First check if the user has edit rights on the target document.\n        if (!this.contextualAuthorizationManager.hasAccess(Right.EDIT, documentReference)) {\n            String message = \"You do not have edit rights on [%s] document.\";\n            throw new OfficeImporterException(String.format(message, documentReference));\n        }\n\n        // Save.\n        if (this.docBridge.exists(documentReference) && append) {\n            // Check whether existing document's syntax is same as target syntax.\n            String currentSyntaxId =\n                this.docBridge.getTranslatedDocumentInstance(documentReference).getSyntax().toIdString();\n            if (!currentSyntaxId.equals(syntaxId)) {\n                String message =\n                    \"The target page [%s] exists but its syntax [%s] is different from the specified syntax [%s]\";\n                throw new OfficeImporterException(String.format(message, documentReference, currentSyntaxId, syntaxId));\n            }\n\n            // Append the content.\n            String currentContent = this.docBridge.getDocumentContent(documentReference, null);\n            String newContent = currentContent + \"\\n\" + doc.getContentAsString(syntaxId);\n            this.docBridge.setDocumentContent(documentReference, newContent, \"Updated by office importer.\", false);\n        } else {\n            this.docBridge.setDocumentSyntaxId(documentReference, syntaxId);\n            this.docBridge.setDocumentContent(documentReference, doc.getContentAsString(syntaxId),\n                \"Created by office importer.\", false);\n\n            // Set parent if provided.\n            if (null != parentReference) {\n                this.docBridge.setDocumentParentReference(documentReference, parentReference);\n            }\n\n            // If no title is specified, try to extract one.\n            String docTitle = (null == title) ? doc.getTitle() : title;\n\n            // Set title if applicable.\n            if (null != docTitle) {\n                this.docBridge.setDocumentTitle(documentReference, docTitle);\n            }\n        }\n\n        // Finally attach all the artifacts into target document.\n        attachArtifacts(doc.getArtifactsMap(), documentReference);\n    }\n\n    /**\n     * Utility method for attaching artifacts into a wiki page.\n     * \n     * @param artifactFiles set of artifact files.\n     * @param targetDocumentReference target wiki page into which artifacts are to be attached\n     */\n    private void attachArtifacts(Map<String, OfficeDocumentArtifact> artifactFiles,\n        DocumentReference targetDocumentReference)\n    {\n        artifactFiles.forEach((filename, artifact) -> {\n            AttachmentReference attachmentReference = new AttachmentReference(filename, targetDocumentReference);\n            try (InputStream is = artifact.getContentInputStream()) {\n                this.docBridge.setAttachmentContent(attachmentReference, is);\n            } catch (Exception ex) {\n                // Log the error as warning and skip the artifact.\n                this.logger.warn(\"Error while attaching artifact: [{}].\", ExceptionUtils.getRootCauseMessage(ex));\n            }\n        });\n    }\n}",
    "patch": "@@ -19,20 +19,20 @@\n  */\n package org.xwiki.officeimporter.internal;\n \n-import java.io.File;\n-import java.io.FileInputStream;\n-import java.util.Set;\n+import java.io.InputStream;\n+import java.util.Map;\n \n import javax.inject.Inject;\n import javax.inject.Singleton;\n \n-import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.exception.ExceptionUtils;\n import org.slf4j.Logger;\n import org.xwiki.bridge.DocumentAccessBridge;\n import org.xwiki.component.annotation.Component;\n import org.xwiki.model.reference.AttachmentReference;\n import org.xwiki.model.reference.DocumentReference;\n import org.xwiki.officeimporter.OfficeImporterException;\n+import org.xwiki.officeimporter.document.OfficeDocumentArtifact;\n import org.xwiki.officeimporter.document.XDOMOfficeDocument;\n import org.xwiki.security.authorization.ContextualAuthorizationManager;\n import org.xwiki.security.authorization.Right;\n@@ -117,7 +117,7 @@ public void save(XDOMOfficeDocument doc, DocumentReference documentReference, St\n         }\n \n         // Finally attach all the artifacts into target document.\n-        attachArtifacts(doc.getArtifactsFiles(), documentReference);\n+        attachArtifacts(doc.getArtifactsMap(), documentReference);\n     }\n \n     /**\n@@ -126,17 +126,17 @@ public void save(XDOMOfficeDocument doc, DocumentReference documentReference, St\n      * @param artifactFiles set of artifact files.\n      * @param targetDocumentReference target wiki page into which artifacts are to be attached\n      */\n-    private void attachArtifacts(Set<File> artifactFiles, DocumentReference targetDocumentReference)\n+    private void attachArtifacts(Map<String, OfficeDocumentArtifact> artifactFiles,\n+        DocumentReference targetDocumentReference)\n     {\n-        for (File artifact : artifactFiles) {\n-            AttachmentReference attachmentReference =\n-                new AttachmentReference(artifact.getName(), targetDocumentReference);\n-            try (FileInputStream fis = new FileInputStream(artifact)) {\n-                this.docBridge.setAttachmentContent(attachmentReference, IOUtils.toByteArray(fis));\n+        artifactFiles.forEach((filename, artifact) -> {\n+            AttachmentReference attachmentReference = new AttachmentReference(filename, targetDocumentReference);\n+            try (InputStream is = artifact.getContentInputStream()) {\n+                this.docBridge.setAttachmentContent(attachmentReference, is);\n             } catch (Exception ex) {\n-                // Log the error and skip the artifact.\n-                this.logger.error(\"Error while attaching artifact.\", ex);\n+                // Log the error as warning and skip the artifact.\n+                this.logger.warn(\"Error while attaching artifact: [{}].\", ExceptionUtils.getRootCauseMessage(ex));\n             }\n-        }\n+        });\n     }\n }",
    "function_modified_lines": {
      "added": [
        "        attachArtifacts(doc.getArtifactsMap(), documentReference);\n",
        "    private void attachArtifacts(Map<String, OfficeDocumentArtifact> artifactFiles,\n",
        "        DocumentReference targetDocumentReference)\n",
        "        artifactFiles.forEach((filename, artifact) -> {\n",
        "            AttachmentReference attachmentReference = new AttachmentReference(filename, targetDocumentReference);\n",
        "            try (InputStream is = artifact.getContentInputStream()) {\n",
        "                this.docBridge.setAttachmentContent(attachmentReference, is);\n",
        "                // Log the error as warning and skip the artifact.\n",
        "                this.logger.warn(\"Error while attaching artifact: [{}].\", ExceptionUtils.getRootCauseMessage(ex));\n",
        "        });\n"
      ],
      "deleted": [
        "        attachArtifacts(doc.getArtifactsFiles(), documentReference);\n",
        "    private void attachArtifacts(Set<File> artifactFiles, DocumentReference targetDocumentReference)\n",
        "        for (File artifact : artifactFiles) {\n",
        "            AttachmentReference attachmentReference =\n",
        "                new AttachmentReference(artifact.getName(), targetDocumentReference);\n",
        "            try (FileInputStream fis = new FileInputStream(artifact)) {\n",
        "                this.docBridge.setAttachmentContent(attachmentReference, IOUtils.toByteArray(fis));\n",
        "                // Log the error and skip the artifact.\n",
        "                this.logger.error(\"Error while attaching artifact.\", ex);\n",
        "        }\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "XWiki Platform is a generic wiki platform offering runtime services for applications built on top of it. Starting in version 3.5-milestone-1 and prior to versions 14.10.8 and 15.3-rc-1, triggering the office converter with a specially crafted file name allows writing the attachment's content to an attacker-controlled location on the server as long as the Java process has write access to that location. In particular in the combination with attachment moving, a feature introduced in XWiki 14.0, this is easy to reproduce but it also possible to reproduce in versions as old as XWiki 3.5 by uploading the attachment through the REST API which doesn't remove `/` or `\\` from the filename. As the mime type of the attachment doesn't matter for the exploitation, this could e.g., be used to replace the `jar`-file of an extension which would allow executing arbitrary Java code and thus impact the confidentiality, integrity and availability of the XWiki installation. This vulnerability has been patched in XWiki 14.10.8 and 15.3RC1. There are no known workarounds apart from disabling the office converter.",
    "id": 12396
  },
  {
    "cve_id": "CVE-2023-37913",
    "code_before_change": "{\n        // Accents seems to cause issues in some conditions\n        // See https://jira.xwiki.org/browse/XWIKI-14692\n        String cleanedOfficeFileName = StringUtils.stripAccents(officeFileName);\n\n        // Invoke the office document converter.\n        OfficeConverterResult officeConverterResult = importPresentation(officeFileStream, cleanedOfficeFileName);\n\n        Pair<String, Set<File>> htmlPresentationResult = null;\n        // Create presentation HTML.\n        try {\n            htmlPresentationResult = buildPresentationHTML(officeConverterResult,\n                StringUtils.substringBeforeLast(cleanedOfficeFileName, \".\"));\n        } catch (IOException e) {\n            throw new OfficeImporterException(\"Error while preparing the presentation artifacts.\", e);\n        }\n\n        // Clear and adjust presentation HTML (slide image URLs are updated to point to the corresponding attachments).\n        String html = cleanPresentationHTML(htmlPresentationResult.getLeft(), documentReference);\n\n        // Create the XDOM.\n        XDOM xdom = buildPresentationXDOM(html, documentReference);\n\n        return new XDOMOfficeDocument(xdom, htmlPresentationResult.getRight(),\n            this.contextComponentManagerProvider.get(), officeConverterResult);\n    }",
    "code_after_change": "{\n        // Invoke the office document converter.\n        OfficeConverterResult officeConverterResult = importPresentation(officeFileStream, officeFileName);\n\n        Pair<String, Map<String, OfficeDocumentArtifact>> htmlPresentationResult;\n        // Create presentation HTML.\n        try {\n            htmlPresentationResult = buildPresentationHTML(officeConverterResult,\n                StringUtils.substringBeforeLast(officeFileName, \".\"));\n        } catch (IOException e) {\n            throw new OfficeImporterException(\"Error while preparing the presentation artifacts.\", e);\n        }\n\n        // Clear and adjust presentation HTML (slide image URLs are updated to point to the corresponding attachments).\n        String html = cleanPresentationHTML(htmlPresentationResult.getLeft(), documentReference);\n\n        // Create the XDOM.\n        XDOM xdom = buildPresentationXDOM(html, documentReference);\n\n        return new XDOMOfficeDocument(xdom, htmlPresentationResult.getRight(),\n            this.contextComponentManagerProvider.get(), officeConverterResult);\n    }",
    "patch": "@@ -25,10 +25,8 @@\n import java.io.StringReader;\n import java.io.UnsupportedEncodingException;\n import java.net.URLEncoder;\n-import java.nio.file.Files;\n import java.util.Collections;\n import java.util.HashMap;\n-import java.util.HashSet;\n import java.util.Map;\n import java.util.Set;\n import java.util.regex.Matcher;\n@@ -52,14 +50,18 @@\n import org.xwiki.officeimporter.builder.PresentationBuilder;\n import org.xwiki.officeimporter.converter.OfficeConverterException;\n import org.xwiki.officeimporter.converter.OfficeConverterResult;\n+import org.xwiki.officeimporter.document.OfficeDocumentArtifact;\n import org.xwiki.officeimporter.document.XDOMOfficeDocument;\n+import org.xwiki.officeimporter.internal.converter.OfficeConverterFileStorage;\n+import org.xwiki.officeimporter.internal.document.FileOfficeDocumentArtifact;\n import org.xwiki.officeimporter.server.OfficeServer;\n import org.xwiki.rendering.block.Block;\n import org.xwiki.rendering.block.ExpandedMacroBlock;\n import org.xwiki.rendering.block.XDOM;\n import org.xwiki.rendering.listener.MetaData;\n import org.xwiki.rendering.parser.Parser;\n import org.xwiki.rendering.renderer.BlockRenderer;\n+import org.xwiki.xml.XMLUtils;\n import org.xwiki.xml.html.HTMLCleaner;\n import org.xwiki.xml.html.HTMLCleanerConfiguration;\n import org.xwiki.xml.html.HTMLUtils;\n@@ -119,18 +121,14 @@ public class DefaultPresentationBuilder implements PresentationBuilder\n     public XDOMOfficeDocument build(InputStream officeFileStream, String officeFileName,\n         DocumentReference documentReference) throws OfficeImporterException\n     {\n-        // Accents seems to cause issues in some conditions\n-        // See https://jira.xwiki.org/browse/XWIKI-14692\n-        String cleanedOfficeFileName = StringUtils.stripAccents(officeFileName);\n-\n         // Invoke the office document converter.\n-        OfficeConverterResult officeConverterResult = importPresentation(officeFileStream, cleanedOfficeFileName);\n+        OfficeConverterResult officeConverterResult = importPresentation(officeFileStream, officeFileName);\n \n-        Pair<String, Set<File>> htmlPresentationResult = null;\n+        Pair<String, Map<String, OfficeDocumentArtifact>> htmlPresentationResult;\n         // Create presentation HTML.\n         try {\n             htmlPresentationResult = buildPresentationHTML(officeConverterResult,\n-                StringUtils.substringBeforeLast(cleanedOfficeFileName, \".\"));\n+                StringUtils.substringBeforeLast(officeFileName, \".\"));\n         } catch (IOException e) {\n             throw new OfficeImporterException(\"Error while preparing the presentation artifacts.\", e);\n         }\n@@ -157,15 +155,15 @@ public XDOMOfficeDocument build(InputStream officeFileStream, String officeFileN\n     protected OfficeConverterResult importPresentation(InputStream officeFileStream, String officeFileName)\n         throws OfficeImporterException\n     {\n-        Map<String, InputStream> inputStreams = new HashMap<String, InputStream>();\n-        inputStreams.put(officeFileName, officeFileStream);\n+        String inputFileName = OfficeConverterFileStorage.getSafeInputFilenameFromExtension(officeFileName);\n+        Map<String, InputStream> inputStreams = Map.of(inputFileName, officeFileStream);\n         try {\n             // The office converter uses the output file name extension to determine the output format/syntax.\n             // The returned artifacts are of three types: imgX.jpg (slide screen shot), imgX.html (HTML page that\n             // display the corresponding slide screen shot) and textX.html (HTML page that display the text extracted\n             // from the corresponding slide). We use \"img0.html\" as the output file name because the corresponding\n             // artifact displays a screen shot of the first presentation slide.\n-            return this.officeServer.getConverter().convertDocument(inputStreams, officeFileName, \"img0.html\");\n+            return this.officeServer.getConverter().convertDocument(inputStreams, inputFileName, \"img0.html\");\n         } catch (OfficeConverterException e) {\n             String message = \"Error while converting document [%s] into html.\";\n             throw new OfficeImporterException(String.format(message, officeFileName), e);\n@@ -183,22 +181,19 @@ protected OfficeConverterResult importPresentation(InputStream officeFileStream,\n      * @param nameSpace the prefix to add in front of all slide image names to prevent name conflicts\n      * @return the presentation HTML\n      */\n-    protected Pair<String, Set<File>> buildPresentationHTML(OfficeConverterResult officeConverterResult, String nameSpace)\n-        throws IOException\n+    protected Pair<String, Map<String, OfficeDocumentArtifact>> buildPresentationHTML(\n+        OfficeConverterResult officeConverterResult, String nameSpace) throws IOException\n     {\n-        Set<File> artifactFiles = new HashSet<>();\n+        Map<String, OfficeDocumentArtifact> artifactFiles = new HashMap<>();\n         // Iterate all the slides.\n         Set<File> conversionOutputFiles = officeConverterResult.getAllFiles();\n-        File outputDirectory = officeConverterResult.getOutputDirectory();\n         Map<Integer, String> filenames = new HashMap<>();\n         for (File conversionOutputFile : conversionOutputFiles) {\n             Matcher matcher = SLIDE_FORMAT.matcher(conversionOutputFile.getName());\n             if (matcher.matches()) {\n                 String number = matcher.group(\"number\");\n                 String slideImageName = String.format(\"%s-slide%s.jpg\", nameSpace, number);\n-                File artifact = new File(outputDirectory, slideImageName);\n-                artifactFiles.add(artifact);\n-                Files.copy(conversionOutputFile.toPath(), artifact.toPath());\n+                artifactFiles.put(slideImageName, new FileOfficeDocumentArtifact(slideImageName, conversionOutputFile));\n                 // Append slide image to the presentation HTML.\n                 String slideImageURL = null;\n                 try {\n@@ -219,7 +214,7 @@ protected Pair<String, Set<File>> buildPresentationHTML(OfficeConverterResult of\n         }\n         // We sort by number so that the filenames are ordered by slide number.\n         String presentationHTML = filenames.entrySet().stream().sorted(Map.Entry.comparingByKey())\n-            .map(entry -> String.format(\"<p><img src=\\\"%s\\\"/></p>\", entry.getValue()))\n+            .map(entry -> String.format(\"<p><img src=\\\"%s\\\"/></p>\", XMLUtils.escapeAttributeValue(entry.getValue())))\n             .collect(Collectors.joining());\n         return Pair.of(presentationHTML, artifactFiles);\n     }",
    "function_modified_lines": {
      "added": [
        "        OfficeConverterResult officeConverterResult = importPresentation(officeFileStream, officeFileName);\n",
        "        Pair<String, Map<String, OfficeDocumentArtifact>> htmlPresentationResult;\n",
        "                StringUtils.substringBeforeLast(officeFileName, \".\"));\n"
      ],
      "deleted": [
        "        // Accents seems to cause issues in some conditions\n",
        "        // See https://jira.xwiki.org/browse/XWIKI-14692\n",
        "        String cleanedOfficeFileName = StringUtils.stripAccents(officeFileName);\n",
        "\n",
        "        OfficeConverterResult officeConverterResult = importPresentation(officeFileStream, cleanedOfficeFileName);\n",
        "        Pair<String, Set<File>> htmlPresentationResult = null;\n",
        "                StringUtils.substringBeforeLast(cleanedOfficeFileName, \".\"));\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "XWiki Platform is a generic wiki platform offering runtime services for applications built on top of it. Starting in version 3.5-milestone-1 and prior to versions 14.10.8 and 15.3-rc-1, triggering the office converter with a specially crafted file name allows writing the attachment's content to an attacker-controlled location on the server as long as the Java process has write access to that location. In particular in the combination with attachment moving, a feature introduced in XWiki 14.0, this is easy to reproduce but it also possible to reproduce in versions as old as XWiki 3.5 by uploading the attachment through the REST API which doesn't remove `/` or `\\` from the filename. As the mime type of the attachment doesn't matter for the exploitation, this could e.g., be used to replace the `jar`-file of an extension which would allow executing arbitrary Java code and thus impact the confidentiality, integrity and availability of the XWiki installation. This vulnerability has been patched in XWiki 14.10.8 and 15.3RC1. There are no known workarounds apart from disabling the office converter.",
    "id": 12398
  },
  {
    "cve_id": "CVE-2023-37913",
    "code_before_change": "{\n    /**\n     * Used to serialize the reference document name.\n     */\n    @Inject\n    private EntityReferenceSerializer<String> entityReferenceSerializer;\n\n    /**\n     * Used to obtain document converter.\n     */\n    @Inject\n    private OfficeServer officeServer;\n\n    /**\n     * Office HTML cleaner.\n     */\n    @Inject\n    @Named(\"openoffice\")\n    private HTMLCleaner officeHtmlCleaner;\n\n    /**\n     * Used to determine the encoding of the HTML byte array produced by the office server.\n     */\n    private HtmlEncodingDetector htmlEncodingDetector = new HtmlEncodingDetector();\n\n    @Override\n    public XHTMLOfficeDocument build(InputStream officeFileStream, String officeFileName, DocumentReference reference,\n        boolean filterStyles) throws OfficeImporterException\n    {\n        // Accents seems to cause issues in some conditions\n        // See https://jira.xwiki.org/browse/XWIKI-14692\n        String cleanedOfficeFileName = StringUtils.stripAccents(officeFileName);\n\n        // Invoke the office document converter.\n        Map<String, InputStream> inputStreams = new HashMap<String, InputStream>();\n        inputStreams.put(cleanedOfficeFileName, officeFileStream);\n        // The office converter uses the output file name extension to determine the output format/syntax.\n        String outputFileName = StringUtils.substringBeforeLast(cleanedOfficeFileName, \".\") + \".html\";\n        OfficeConverterResult officeConverterResult;\n        try {\n            officeConverterResult =\n                this.officeServer.getConverter().convertDocument(inputStreams, cleanedOfficeFileName, outputFileName);\n        } catch (OfficeConverterException ex) {\n            String message = \"Error while converting document [%s] into html.\";\n            throw new OfficeImporterException(String.format(message, officeFileName), ex);\n        }\n\n        Document xhtmlDoc = this.cleanAndCreateFile(reference, filterStyles, officeConverterResult);\n        Set<File> artifacts = this.handleArtifacts(xhtmlDoc, officeConverterResult);\n\n        // Return a new XHTMLOfficeDocument instance.\n        return new XHTMLOfficeDocument(xhtmlDoc, artifacts, officeConverterResult);\n    }\n\n    private Document cleanAndCreateFile(DocumentReference reference, boolean filterStyles,\n        OfficeConverterResult officeConverterResult) throws OfficeImporterException\n    {\n        // Prepare the parameters for HTML cleaning.\n        Map<String, String> params = new HashMap<String, String>();\n        params.put(\"targetDocument\", this.entityReferenceSerializer.serialize(reference));\n        // Extract the images that are embedded through the Data URI scheme and add them to the other artifacts so that\n        // they end up as attachments.\n        params.put(\"attachEmbeddedImages\", \"true\");\n        if (filterStyles) {\n            params.put(\"filterStyles\", \"strict\");\n        }\n\n        // Parse and clean the HTML output.\n        HTMLCleanerConfiguration configuration = this.officeHtmlCleaner.getDefaultConfiguration();\n        configuration.setParameters(params);\n\n        Reader html = null;\n        try {\n            html = new FileReader(officeConverterResult.getOutputFile());\n        } catch (FileNotFoundException e) {\n            throw new OfficeImporterException(\n                String.format(\"The output file cannot be found: [%s].\", officeConverterResult.getOutputFile()), e);\n        }\n        return this.officeHtmlCleaner.clean(html, configuration);\n    }\n\n    private Set<File> handleArtifacts(Document xhtmlDoc, OfficeConverterResult officeConverterResult)\n        throws OfficeImporterException\n    {\n        Set<File> artifacts = new HashSet<>(officeConverterResult.getAllFiles());\n        artifacts.remove(officeConverterResult.getOutputFile());\n\n        @SuppressWarnings(\"unchecked\")\n        Map<String, byte[]> embeddedImages = (Map<String, byte[]>) xhtmlDoc.getUserData(\"embeddedImages\");\n        if (embeddedImages != null) {\n            File outputDirectory = officeConverterResult.getOutputDirectory();\n            for (Map.Entry<String, byte[]> embeddedImage : embeddedImages.entrySet()) {\n                File outputFile = new File(outputDirectory, embeddedImage.getKey());\n                try (FileOutputStream fos = new FileOutputStream(outputFile)) {\n                    IOUtils.write(embeddedImage.getValue(), fos);\n                } catch (IOException e) {\n                    throw new OfficeImporterException(\n                        String.format(\"Error when writing embedded image file [%s]\", outputFile.getAbsolutePath()), e);\n                }\n                artifacts.add(outputFile);\n            }\n        }\n        return artifacts;\n    }\n}",
    "code_after_change": "{\n    /**\n     * Used to serialize the reference document name.\n     */\n    @Inject\n    private EntityReferenceSerializer<String> entityReferenceSerializer;\n\n    /**\n     * Used to obtain document converter.\n     */\n    @Inject\n    private OfficeServer officeServer;\n\n    /**\n     * Office HTML cleaner.\n     */\n    @Inject\n    @Named(\"openoffice\")\n    private HTMLCleaner officeHtmlCleaner;\n\n    @Override\n    public XHTMLOfficeDocument build(InputStream officeFileStream, String officeFileName, DocumentReference reference,\n        boolean filterStyles) throws OfficeImporterException\n    {\n        String inputFileName = OfficeConverterFileStorage.getSafeInputFilenameFromExtension(officeFileName);\n\n        // Invoke the office document converter.\n        Map<String, InputStream> inputStreams = new HashMap<>();\n        inputStreams.put(inputFileName, officeFileStream);\n        // The office converter uses the output file name extension to determine the output format/syntax.\n        String outputFileName = \"output.html\";\n        OfficeConverterResult officeConverterResult;\n        try {\n            officeConverterResult =\n                this.officeServer.getConverter().convertDocument(inputStreams, inputFileName, outputFileName);\n        } catch (OfficeConverterException ex) {\n            String message = \"Error while converting document [%s] into html.\";\n            throw new OfficeImporterException(String.format(message, officeFileName), ex);\n        }\n\n        // Replace the prefix \"output_html\" that JODConverter/LibreOffice prepend based on the output file name by\n        // prefix based on the user-provided input name\n        String replacePrefix = \"output_html_\";\n        String replacementPrefix = StringUtils.substringBeforeLast(officeFileName, \".\") + \"_\";\n\n        Document xhtmlDoc = this.cleanAndCreateFile(reference, filterStyles, officeConverterResult,\n            replacePrefix, replacementPrefix);\n        Map<String, OfficeDocumentArtifact> artifacts = this.handleArtifacts(xhtmlDoc, officeConverterResult,\n            replacePrefix, replacementPrefix);\n\n        // Return a new XHTMLOfficeDocument instance.\n        return new XHTMLOfficeDocument(xhtmlDoc, artifacts, officeConverterResult);\n    }\n\n    private Document cleanAndCreateFile(DocumentReference reference, boolean filterStyles,\n        OfficeConverterResult officeConverterResult, String replacePrefix, String replacementPrefix)\n        throws OfficeImporterException\n    {\n        // Prepare the parameters for HTML cleaning.\n        Map<String, String> params = new HashMap<String, String>();\n        params.put(\"targetDocument\", this.entityReferenceSerializer.serialize(reference));\n        // Extract the images that are embedded through the Data URI scheme and add them to the other artifacts so that\n        // they end up as attachments.\n        params.put(\"attachEmbeddedImages\", \"true\");\n        // Replace the prefix of the static output filename by the replacement based on the user-provided input\n        // filename.\n        params.put(\"replaceImagePrefix\", replacePrefix);\n        params.put(\"replacementImagePrefix\", replacementPrefix);\n        if (filterStyles) {\n            params.put(\"filterStyles\", \"strict\");\n        }\n\n        // Parse and clean the HTML output.\n        HTMLCleanerConfiguration configuration = this.officeHtmlCleaner.getDefaultConfiguration();\n        configuration.setParameters(params);\n\n        Reader html = null;\n        try {\n            html = new FileReader(officeConverterResult.getOutputFile());\n        } catch (FileNotFoundException e) {\n            throw new OfficeImporterException(\n                String.format(\"The output file cannot be found: [%s].\", officeConverterResult.getOutputFile()), e);\n        }\n        return this.officeHtmlCleaner.clean(html, configuration);\n    }\n\n    private Map<String, OfficeDocumentArtifact> handleArtifacts(Document xhtmlDoc,\n        OfficeConverterResult officeConverterResult, String replacePrefix, String replacementPrefix)\n    {\n        Map<String, OfficeDocumentArtifact> artifacts = new HashMap<>();\n        for (File file : officeConverterResult.getAllFiles()) {\n            // Rename the file if it starts with the static prefix similar to the image filter.\n            String filename = file.getName();\n            if (StringUtils.startsWith(filename, replacePrefix)) {\n                filename = replacementPrefix + StringUtils.removeStart(filename, replacePrefix);\n            }\n            artifacts.put(filename, new FileOfficeDocumentArtifact(file.getName(), file));\n        }\n        // Remove the output file from the artifacts\n        artifacts.remove(officeConverterResult.getOutputFile().getName());\n\n        @SuppressWarnings(\"unchecked\")\n        Map<String, byte[]> embeddedImages = (Map<String, byte[]>) xhtmlDoc.getUserData(\"embeddedImages\");\n        if (embeddedImages != null) {\n            for (Map.Entry<String, byte[]> embeddedImage : embeddedImages.entrySet()) {\n                String fileName = embeddedImage.getKey();\n                artifacts.put(fileName, new ByteArrayOfficeDocumentArtifact(fileName, embeddedImage.getValue()));\n            }\n        }\n        return artifacts;\n    }\n}",
    "patch": "@@ -21,23 +21,17 @@\n \n import java.io.File;\n import java.io.FileNotFoundException;\n-import java.io.FileOutputStream;\n import java.io.FileReader;\n-import java.io.IOException;\n import java.io.InputStream;\n import java.io.Reader;\n import java.util.HashMap;\n-import java.util.HashSet;\n import java.util.Map;\n-import java.util.Set;\n \n import javax.inject.Inject;\n import javax.inject.Named;\n import javax.inject.Singleton;\n \n-import org.apache.commons.io.IOUtils;\n import org.apache.commons.lang3.StringUtils;\n-import org.apache.tika.parser.html.HtmlEncodingDetector;\n import org.w3c.dom.Document;\n import org.xwiki.component.annotation.Component;\n import org.xwiki.model.reference.DocumentReference;\n@@ -46,7 +40,11 @@\n import org.xwiki.officeimporter.builder.XHTMLOfficeDocumentBuilder;\n import org.xwiki.officeimporter.converter.OfficeConverterException;\n import org.xwiki.officeimporter.converter.OfficeConverterResult;\n+import org.xwiki.officeimporter.document.OfficeDocumentArtifact;\n import org.xwiki.officeimporter.document.XHTMLOfficeDocument;\n+import org.xwiki.officeimporter.internal.converter.OfficeConverterFileStorage;\n+import org.xwiki.officeimporter.internal.document.ByteArrayOfficeDocumentArtifact;\n+import org.xwiki.officeimporter.internal.document.FileOfficeDocumentArtifact;\n import org.xwiki.officeimporter.server.OfficeServer;\n import org.xwiki.xml.html.HTMLCleaner;\n import org.xwiki.xml.html.HTMLCleanerConfiguration;\n@@ -80,49 +78,54 @@ public class DefaultXHTMLOfficeDocumentBuilder implements XHTMLOfficeDocumentBui\n     @Named(\"openoffice\")\n     private HTMLCleaner officeHtmlCleaner;\n \n-    /**\n-     * Used to determine the encoding of the HTML byte array produced by the office server.\n-     */\n-    private HtmlEncodingDetector htmlEncodingDetector = new HtmlEncodingDetector();\n-\n     @Override\n     public XHTMLOfficeDocument build(InputStream officeFileStream, String officeFileName, DocumentReference reference,\n         boolean filterStyles) throws OfficeImporterException\n     {\n-        // Accents seems to cause issues in some conditions\n-        // See https://jira.xwiki.org/browse/XWIKI-14692\n-        String cleanedOfficeFileName = StringUtils.stripAccents(officeFileName);\n+        String inputFileName = OfficeConverterFileStorage.getSafeInputFilenameFromExtension(officeFileName);\n \n         // Invoke the office document converter.\n-        Map<String, InputStream> inputStreams = new HashMap<String, InputStream>();\n-        inputStreams.put(cleanedOfficeFileName, officeFileStream);\n+        Map<String, InputStream> inputStreams = new HashMap<>();\n+        inputStreams.put(inputFileName, officeFileStream);\n         // The office converter uses the output file name extension to determine the output format/syntax.\n-        String outputFileName = StringUtils.substringBeforeLast(cleanedOfficeFileName, \".\") + \".html\";\n+        String outputFileName = \"output.html\";\n         OfficeConverterResult officeConverterResult;\n         try {\n             officeConverterResult =\n-                this.officeServer.getConverter().convertDocument(inputStreams, cleanedOfficeFileName, outputFileName);\n+                this.officeServer.getConverter().convertDocument(inputStreams, inputFileName, outputFileName);\n         } catch (OfficeConverterException ex) {\n             String message = \"Error while converting document [%s] into html.\";\n             throw new OfficeImporterException(String.format(message, officeFileName), ex);\n         }\n \n-        Document xhtmlDoc = this.cleanAndCreateFile(reference, filterStyles, officeConverterResult);\n-        Set<File> artifacts = this.handleArtifacts(xhtmlDoc, officeConverterResult);\n+        // Replace the prefix \"output_html\" that JODConverter/LibreOffice prepend based on the output file name by\n+        // prefix based on the user-provided input name\n+        String replacePrefix = \"output_html_\";\n+        String replacementPrefix = StringUtils.substringBeforeLast(officeFileName, \".\") + \"_\";\n+\n+        Document xhtmlDoc = this.cleanAndCreateFile(reference, filterStyles, officeConverterResult,\n+            replacePrefix, replacementPrefix);\n+        Map<String, OfficeDocumentArtifact> artifacts = this.handleArtifacts(xhtmlDoc, officeConverterResult,\n+            replacePrefix, replacementPrefix);\n \n         // Return a new XHTMLOfficeDocument instance.\n         return new XHTMLOfficeDocument(xhtmlDoc, artifacts, officeConverterResult);\n     }\n \n     private Document cleanAndCreateFile(DocumentReference reference, boolean filterStyles,\n-        OfficeConverterResult officeConverterResult) throws OfficeImporterException\n+        OfficeConverterResult officeConverterResult, String replacePrefix, String replacementPrefix)\n+        throws OfficeImporterException\n     {\n         // Prepare the parameters for HTML cleaning.\n         Map<String, String> params = new HashMap<String, String>();\n         params.put(\"targetDocument\", this.entityReferenceSerializer.serialize(reference));\n         // Extract the images that are embedded through the Data URI scheme and add them to the other artifacts so that\n         // they end up as attachments.\n         params.put(\"attachEmbeddedImages\", \"true\");\n+        // Replace the prefix of the static output filename by the replacement based on the user-provided input\n+        // filename.\n+        params.put(\"replaceImagePrefix\", replacePrefix);\n+        params.put(\"replacementImagePrefix\", replacementPrefix);\n         if (filterStyles) {\n             params.put(\"filterStyles\", \"strict\");\n         }\n@@ -141,25 +144,27 @@ private Document cleanAndCreateFile(DocumentReference reference, boolean filterS\n         return this.officeHtmlCleaner.clean(html, configuration);\n     }\n \n-    private Set<File> handleArtifacts(Document xhtmlDoc, OfficeConverterResult officeConverterResult)\n-        throws OfficeImporterException\n+    private Map<String, OfficeDocumentArtifact> handleArtifacts(Document xhtmlDoc,\n+        OfficeConverterResult officeConverterResult, String replacePrefix, String replacementPrefix)\n     {\n-        Set<File> artifacts = new HashSet<>(officeConverterResult.getAllFiles());\n-        artifacts.remove(officeConverterResult.getOutputFile());\n+        Map<String, OfficeDocumentArtifact> artifacts = new HashMap<>();\n+        for (File file : officeConverterResult.getAllFiles()) {\n+            // Rename the file if it starts with the static prefix similar to the image filter.\n+            String filename = file.getName();\n+            if (StringUtils.startsWith(filename, replacePrefix)) {\n+                filename = replacementPrefix + StringUtils.removeStart(filename, replacePrefix);\n+            }\n+            artifacts.put(filename, new FileOfficeDocumentArtifact(file.getName(), file));\n+        }\n+        // Remove the output file from the artifacts\n+        artifacts.remove(officeConverterResult.getOutputFile().getName());\n \n         @SuppressWarnings(\"unchecked\")\n         Map<String, byte[]> embeddedImages = (Map<String, byte[]>) xhtmlDoc.getUserData(\"embeddedImages\");\n         if (embeddedImages != null) {\n-            File outputDirectory = officeConverterResult.getOutputDirectory();\n             for (Map.Entry<String, byte[]> embeddedImage : embeddedImages.entrySet()) {\n-                File outputFile = new File(outputDirectory, embeddedImage.getKey());\n-                try (FileOutputStream fos = new FileOutputStream(outputFile)) {\n-                    IOUtils.write(embeddedImage.getValue(), fos);\n-                } catch (IOException e) {\n-                    throw new OfficeImporterException(\n-                        String.format(\"Error when writing embedded image file [%s]\", outputFile.getAbsolutePath()), e);\n-                }\n-                artifacts.add(outputFile);\n+                String fileName = embeddedImage.getKey();\n+                artifacts.put(fileName, new ByteArrayOfficeDocumentArtifact(fileName, embeddedImage.getValue()));\n             }\n         }\n         return artifacts;",
    "function_modified_lines": {
      "added": [
        "        String inputFileName = OfficeConverterFileStorage.getSafeInputFilenameFromExtension(officeFileName);\n",
        "        Map<String, InputStream> inputStreams = new HashMap<>();\n",
        "        inputStreams.put(inputFileName, officeFileStream);\n",
        "        String outputFileName = \"output.html\";\n",
        "                this.officeServer.getConverter().convertDocument(inputStreams, inputFileName, outputFileName);\n",
        "        // Replace the prefix \"output_html\" that JODConverter/LibreOffice prepend based on the output file name by\n",
        "        // prefix based on the user-provided input name\n",
        "        String replacePrefix = \"output_html_\";\n",
        "        String replacementPrefix = StringUtils.substringBeforeLast(officeFileName, \".\") + \"_\";\n",
        "\n",
        "        Document xhtmlDoc = this.cleanAndCreateFile(reference, filterStyles, officeConverterResult,\n",
        "            replacePrefix, replacementPrefix);\n",
        "        Map<String, OfficeDocumentArtifact> artifacts = this.handleArtifacts(xhtmlDoc, officeConverterResult,\n",
        "            replacePrefix, replacementPrefix);\n",
        "        OfficeConverterResult officeConverterResult, String replacePrefix, String replacementPrefix)\n",
        "        throws OfficeImporterException\n",
        "        // Replace the prefix of the static output filename by the replacement based on the user-provided input\n",
        "        // filename.\n",
        "        params.put(\"replaceImagePrefix\", replacePrefix);\n",
        "        params.put(\"replacementImagePrefix\", replacementPrefix);\n"
      ],
      "deleted": [
        "    /**\n",
        "     * Used to determine the encoding of the HTML byte array produced by the office server.\n",
        "     */\n",
        "    private HtmlEncodingDetector htmlEncodingDetector = new HtmlEncodingDetector();\n",
        "\n",
        "        // Accents seems to cause issues in some conditions\n",
        "        // See https://jira.xwiki.org/browse/XWIKI-14692\n",
        "        String cleanedOfficeFileName = StringUtils.stripAccents(officeFileName);\n",
        "        Map<String, InputStream> inputStreams = new HashMap<String, InputStream>();\n",
        "        inputStreams.put(cleanedOfficeFileName, officeFileStream);\n",
        "        String outputFileName = StringUtils.substringBeforeLast(cleanedOfficeFileName, \".\") + \".html\";\n",
        "                this.officeServer.getConverter().convertDocument(inputStreams, cleanedOfficeFileName, outputFileName);\n",
        "        Document xhtmlDoc = this.cleanAndCreateFile(reference, filterStyles, officeConverterResult);\n",
        "        Set<File> artifacts = this.handleArtifacts(xhtmlDoc, officeConverterResult);\n",
        "        OfficeConverterResult officeConverterResult) throws OfficeImporterException\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "XWiki Platform is a generic wiki platform offering runtime services for applications built on top of it. Starting in version 3.5-milestone-1 and prior to versions 14.10.8 and 15.3-rc-1, triggering the office converter with a specially crafted file name allows writing the attachment's content to an attacker-controlled location on the server as long as the Java process has write access to that location. In particular in the combination with attachment moving, a feature introduced in XWiki 14.0, this is easy to reproduce but it also possible to reproduce in versions as old as XWiki 3.5 by uploading the attachment through the REST API which doesn't remove `/` or `\\` from the filename. As the mime type of the attachment doesn't matter for the exploitation, this could e.g., be used to replace the `jar`-file of an extension which would allow executing arbitrary Java code and thus impact the confidentiality, integrity and availability of the XWiki installation. This vulnerability has been patched in XWiki 14.10.8 and 15.3RC1. There are no known workarounds apart from disabling the office converter.",
    "id": 12399
  },
  {
    "cve_id": "CVE-2023-37913",
    "code_before_change": "{\n            // Prepare temporary storage.\n            OfficeConverterFileStorage storage = new OfficeConverterFileStorage(this.workDir, inputFileName,\n                outputFileName);\n\n            // Write out all the input streams.\n            for (Map.Entry<String, InputStream> entry : inputStreams.entrySet()) {\n                File temp = new File(storage.getInputDir(), entry.getKey());\n                try (FileOutputStream fos = new FileOutputStream(temp)) {\n                    IOUtils.copy(entry.getValue(), fos);\n                }\n            }\n\n            // Perform the conversion.\n            this.converter.convert(storage.getInputFile())\n                .to(storage.getOutputFile())\n                .execute();\n\n            return new DefaultOfficeConverterResult(storage);\n        }",
    "code_after_change": "{\n            // Prepare temporary storage.\n            OfficeConverterFileStorage storage = new OfficeConverterFileStorage(this.workDir, inputFileName,\n                outputFileName);\n\n            // Check that the potentially cleaned filename is actually in the input streams.\n            this.checkInputStream(inputStreams, storage.getInputFile().getName());\n\n            // Write out all the input streams.\n            for (Map.Entry<String, InputStream> entry : inputStreams.entrySet()) {\n                File temp = new File(storage.getInputDir(), entry.getKey());\n                try (FileOutputStream fos = new FileOutputStream(temp)) {\n                    IOUtils.copy(entry.getValue(), fos);\n                }\n            }\n\n            // Perform the conversion.\n            this.converter.convert(storage.getInputFile())\n                .to(storage.getOutputFile())\n                .execute();\n\n            return new DefaultOfficeConverterResult(storage);\n        }",
    "patch": "@@ -92,6 +92,9 @@ public DefaultOfficeConverterResult convertDocument(Map<String, InputStream> inp\n             OfficeConverterFileStorage storage = new OfficeConverterFileStorage(this.workDir, inputFileName,\n                 outputFileName);\n \n+            // Check that the potentially cleaned filename is actually in the input streams.\n+            this.checkInputStream(inputStreams, storage.getInputFile().getName());\n+\n             // Write out all the input streams.\n             for (Map.Entry<String, InputStream> entry : inputStreams.entrySet()) {\n                 File temp = new File(storage.getInputDir(), entry.getKey());",
    "function_modified_lines": {
      "added": [
        "            // Check that the potentially cleaned filename is actually in the input streams.\n",
        "            this.checkInputStream(inputStreams, storage.getInputFile().getName());\n",
        "\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "XWiki Platform is a generic wiki platform offering runtime services for applications built on top of it. Starting in version 3.5-milestone-1 and prior to versions 14.10.8 and 15.3-rc-1, triggering the office converter with a specially crafted file name allows writing the attachment's content to an attacker-controlled location on the server as long as the Java process has write access to that location. In particular in the combination with attachment moving, a feature introduced in XWiki 14.0, this is easy to reproduce but it also possible to reproduce in versions as old as XWiki 3.5 by uploading the attachment through the REST API which doesn't remove `/` or `\\` from the filename. As the mime type of the attachment doesn't matter for the exploitation, this could e.g., be used to replace the `jar`-file of an extension which would allow executing arbitrary Java code and thus impact the confidentiality, integrity and availability of the XWiki installation. This vulnerability has been patched in XWiki 14.10.8 and 15.3RC1. There are no known workarounds apart from disabling the office converter.",
    "id": 12400
  },
  {
    "cve_id": "CVE-2023-37913",
    "code_before_change": "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.officeimporter.internal.converter;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.UUID;\n\nimport org.apache.commons.lang3.StringUtils;\n\n/**\n * Keeps track of file system storage used by {@link org.xwiki.officeimporter.converter.OfficeConverter} for a\n * particular conversion.\n * \n * @version $Id$\n * @since 2.2M2\n */\npublic class OfficeConverterFileStorage\n{\n    /**\n     * Top-level temporary working directory.\n     */\n    private File rootDir;\n\n    /**\n     * Input directory where all the input files are located.\n     */\n    private File inputDir;\n\n    /**\n     * Input office document file.\n     */\n    private File inputFile;\n\n    /**\n     * Output directory.\n     */\n    private File outputDir;\n\n    /**\n     * Main output file.\n     */\n    private File outputFile;\n\n    /**\n     * Creates a new {@link OfficeConverterFileStorage} instance for tracking file system storage for a convert\n     * operation.\n     * \n     * @param parentDir parent directory under which temporary storage is to be allocated.\n     * @param inputFileName main input file which will be fed into office server.\n     * @param outputFileName main output file into which result of the office conversion will be written into.\n     * @throws IOException if an error occurs while creating temporary directory structure.\n     */\n    public OfficeConverterFileStorage(File parentDir, String inputFileName, String outputFileName) throws IOException\n    {\n        boolean success = false;\n\n        // Realize the temporary directory hierarchy.\n        this.rootDir = new File(parentDir, UUID.randomUUID().toString());\n        if (this.rootDir.mkdir()) {\n            this.inputDir = new File(this.rootDir, \"input\");\n            this.outputDir = new File(this.rootDir, \"output\");\n            if (this.inputDir.mkdir() && this.outputDir.mkdir()) {\n                this.inputFile = new File(this.inputDir, StringUtils.stripAccents(inputFileName));\n                this.outputFile = new File(this.outputDir, StringUtils.stripAccents(outputFileName));\n                success = true;\n            }\n        }\n\n        // Cleanup & signal if an error is encountered.\n        if (!success) {\n            cleanUp();\n            throw new IOException(\"Could not create temporary directory hierarchy.\");\n        }\n    }\n\n    /**\n     * @return {@link File} representing the input directory where the main input document as well as any other\n     *         dependent artifacts should be located.\n     */\n    public File getInputDir()\n    {\n        return this.inputDir;\n    }\n\n    /**\n     * @return {@link File} representing the main input file.\n     */\n    public File getInputFile()\n    {\n        return this.inputFile;\n    }\n\n    /**\n     * @return {@link File} representing the output directory where the main output file as well as any other dependent\n     *         artifacts are located.\n     */\n    public File getOutputDir()\n    {\n        return this.outputDir;\n    }\n\n    /**\n     * @return {@link File} representing the main output file.\n     */\n    public File getOutputFile()\n    {\n        return this.outputFile;\n    }\n\n    /**\n     * Cleans up the allocated file storage.\n     * \n     * @return true if the cleanup operation succeeded, false otherwise.\n     */\n    public boolean cleanUp()\n    {\n        if (this.rootDir.exists()) {\n            return delete(this.rootDir);\n        }\n\n        return true;\n    }\n\n    /**\n     * Utility method for deleting a directory or a file.\n     * \n     * @param file file or directory to be deleted.\n     * @return true if the whole operation succeeded, false otherwise.\n     */\n    private boolean delete(File file)\n    {\n        // If directory, recursively delete all of it's content.\n        if (file.isDirectory()) {\n            for (File child : file.listFiles()) {\n                delete(child);\n            }\n        }\n\n        // Finally attempt to delete the parent (or the ordinary file).\n        return file.delete();\n    }\n}\n",
    "code_after_change": "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.officeimporter.internal.converter;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.UUID;\nimport java.util.regex.Pattern;\n\nimport org.apache.commons.compress.utils.FileNameUtils;\nimport org.apache.commons.lang3.StringUtils;\n\n/**\n * Keeps track of file system storage used by {@link org.xwiki.officeimporter.converter.OfficeConverter} for a\n * particular conversion.\n * \n * @version $Id$\n * @since 2.2M2\n */\npublic class OfficeConverterFileStorage\n{\n    /**\n     * Pattern for matching a file extension that is safe, i.e., contains between 1 and 20 alphanumeric\n     * characters. The upper limit is arbitrary but should fit all extensions and is there to ensure that the\n     * filename won't be too long.\n     */\n    private static final Pattern SAFE_EXTENSION = Pattern.compile(\"^[a-zA-Z0-9]{1,20}$\");\n\n    /**\n     * Pattern for matching characters not allowed in filenames. Currently just matches directory separators.\n     */\n    private static final Pattern DISALLOWED_CHARACTERS = Pattern.compile(\"[/\\\\\\\\]\");\n\n    private static final String INPUT = \"input\";\n\n    /**\n     * Top-level temporary working directory.\n     */\n    private File rootDir;\n\n    /**\n     * Input directory where all the input files are located.\n     */\n    private File inputDir;\n\n    /**\n     * Input office document file.\n     */\n    private File inputFile;\n\n    /**\n     * Output directory.\n     */\n    private File outputDir;\n\n    /**\n     * Main output file.\n     */\n    private File outputFile;\n\n    /**\n     * Creates a new {@link OfficeConverterFileStorage} instance for tracking file system storage for a convert\n     * operation.\n     * \n     * @param parentDir parent directory under which temporary storage is to be allocated.\n     * @param inputFileName main input file which will be fed into office server.\n     * @param outputFileName main output file into which result of the office conversion will be written into.\n     * @throws IOException if an error occurs while creating temporary directory structure.\n     */\n    public OfficeConverterFileStorage(File parentDir, String inputFileName, String outputFileName) throws IOException\n    {\n        boolean success = false;\n\n        // Realize the temporary directory hierarchy.\n        this.rootDir = new File(parentDir, UUID.randomUUID().toString());\n        if (this.rootDir.mkdir()) {\n            this.inputDir = new File(this.rootDir, INPUT);\n            this.outputDir = new File(this.rootDir, \"output\");\n            if (this.inputDir.mkdir() && this.outputDir.mkdir()) {\n                this.inputFile = new File(this.inputDir, cleanFilename(inputFileName));\n                this.outputFile = new File(this.outputDir, cleanFilename(outputFileName));\n                success = true;\n            }\n        }\n\n        // Cleanup & signal if an error is encountered.\n        if (!success) {\n            cleanUp();\n            throw new IOException(\"Could not create temporary directory hierarchy.\");\n        }\n    }\n\n    /**\n     * Gets a filename that is safe to use as input filename for a conversion operation.\n     * <p>\n     * The extension is kept from the input filename if it is alphanumeric and contains between 1 and 20 characters.\n     *\n     * @param filename the filename for getting the extension\n     * @return the input filename\n     */\n    public static String getSafeInputFilenameFromExtension(String filename)\n    {\n        String extension = FileNameUtils.getExtension(filename);\n        if (!SAFE_EXTENSION.matcher(extension).matches()) {\n            extension = \"\";\n        }\n\n        return StringUtils.isBlank(extension) ? INPUT : INPUT + \".\" + extension;\n    }\n\n    /**\n     * Clean a file name for use as input or output name.\n     *\n     * @param name the filename to clean\n     * @return the cleaned name, shortened to 255 characters if needed\n     */\n    public static String cleanFilename(String name)\n    {\n        String result = DISALLOWED_CHARACTERS.matcher(StringUtils.stripAccents(name)).replaceAll(\"_\");\n\n        // Make sure that the filename is not blank. Don't use an extension so maybe content guessing works.\n        if (StringUtils.isBlank(result)) {\n            result = \"fallback\";\n        }\n\n        // If the filename is too long, keep the part at the end as it contains the extension.\n        if (result.length() > 255) {\n            result = result.substring(result.length() - 255);\n        }\n\n        return result;\n    }\n\n    /**\n     * @return {@link File} representing the input directory where the main input document as well as any other\n     *         dependent artifacts should be located.\n     */\n    public File getInputDir()\n    {\n        return this.inputDir;\n    }\n\n    /**\n     * @return {@link File} representing the main input file.\n     */\n    public File getInputFile()\n    {\n        return this.inputFile;\n    }\n\n    /**\n     * @return {@link File} representing the output directory where the main output file as well as any other dependent\n     *         artifacts are located.\n     */\n    public File getOutputDir()\n    {\n        return this.outputDir;\n    }\n\n    /**\n     * @return {@link File} representing the main output file.\n     */\n    public File getOutputFile()\n    {\n        return this.outputFile;\n    }\n\n    /**\n     * Cleans up the allocated file storage.\n     * \n     * @return true if the cleanup operation succeeded, false otherwise.\n     */\n    public boolean cleanUp()\n    {\n        if (this.rootDir.exists()) {\n            return delete(this.rootDir);\n        }\n\n        return true;\n    }\n\n    /**\n     * Utility method for deleting a directory or a file.\n     * \n     * @param file file or directory to be deleted.\n     * @return true if the whole operation succeeded, false otherwise.\n     */\n    private boolean delete(File file)\n    {\n        // If directory, recursively delete all of it's content.\n        if (file.isDirectory()) {\n            for (File child : file.listFiles()) {\n                delete(child);\n            }\n        }\n\n        // Finally attempt to delete the parent (or the ordinary file).\n        return file.delete();\n    }\n}\n",
    "patch": "@@ -22,7 +22,9 @@\n import java.io.File;\n import java.io.IOException;\n import java.util.UUID;\n+import java.util.regex.Pattern;\n \n+import org.apache.commons.compress.utils.FileNameUtils;\n import org.apache.commons.lang3.StringUtils;\n \n /**\n@@ -34,6 +36,20 @@\n  */\n public class OfficeConverterFileStorage\n {\n+    /**\n+     * Pattern for matching a file extension that is safe, i.e., contains between 1 and 20 alphanumeric\n+     * characters. The upper limit is arbitrary but should fit all extensions and is there to ensure that the\n+     * filename won't be too long.\n+     */\n+    private static final Pattern SAFE_EXTENSION = Pattern.compile(\"^[a-zA-Z0-9]{1,20}$\");\n+\n+    /**\n+     * Pattern for matching characters not allowed in filenames. Currently just matches directory separators.\n+     */\n+    private static final Pattern DISALLOWED_CHARACTERS = Pattern.compile(\"[/\\\\\\\\]\");\n+\n+    private static final String INPUT = \"input\";\n+\n     /**\n      * Top-level temporary working directory.\n      */\n@@ -75,11 +91,11 @@ public OfficeConverterFileStorage(File parentDir, String inputFileName, String o\n         // Realize the temporary directory hierarchy.\n         this.rootDir = new File(parentDir, UUID.randomUUID().toString());\n         if (this.rootDir.mkdir()) {\n-            this.inputDir = new File(this.rootDir, \"input\");\n+            this.inputDir = new File(this.rootDir, INPUT);\n             this.outputDir = new File(this.rootDir, \"output\");\n             if (this.inputDir.mkdir() && this.outputDir.mkdir()) {\n-                this.inputFile = new File(this.inputDir, StringUtils.stripAccents(inputFileName));\n-                this.outputFile = new File(this.outputDir, StringUtils.stripAccents(outputFileName));\n+                this.inputFile = new File(this.inputDir, cleanFilename(inputFileName));\n+                this.outputFile = new File(this.outputDir, cleanFilename(outputFileName));\n                 success = true;\n             }\n         }\n@@ -91,6 +107,47 @@ public OfficeConverterFileStorage(File parentDir, String inputFileName, String o\n         }\n     }\n \n+    /**\n+     * Gets a filename that is safe to use as input filename for a conversion operation.\n+     * <p>\n+     * The extension is kept from the input filename if it is alphanumeric and contains between 1 and 20 characters.\n+     *\n+     * @param filename the filename for getting the extension\n+     * @return the input filename\n+     */\n+    public static String getSafeInputFilenameFromExtension(String filename)\n+    {\n+        String extension = FileNameUtils.getExtension(filename);\n+        if (!SAFE_EXTENSION.matcher(extension).matches()) {\n+            extension = \"\";\n+        }\n+\n+        return StringUtils.isBlank(extension) ? INPUT : INPUT + \".\" + extension;\n+    }\n+\n+    /**\n+     * Clean a file name for use as input or output name.\n+     *\n+     * @param name the filename to clean\n+     * @return the cleaned name, shortened to 255 characters if needed\n+     */\n+    public static String cleanFilename(String name)\n+    {\n+        String result = DISALLOWED_CHARACTERS.matcher(StringUtils.stripAccents(name)).replaceAll(\"_\");\n+\n+        // Make sure that the filename is not blank. Don't use an extension so maybe content guessing works.\n+        if (StringUtils.isBlank(result)) {\n+            result = \"fallback\";\n+        }\n+\n+        // If the filename is too long, keep the part at the end as it contains the extension.\n+        if (result.length() > 255) {\n+            result = result.substring(result.length() - 255);\n+        }\n+\n+        return result;\n+    }\n+\n     /**\n      * @return {@link File} representing the input directory where the main input document as well as any other\n      *         dependent artifacts should be located.",
    "function_modified_lines": {
      "added": [
        "import java.util.regex.Pattern;\n",
        "import org.apache.commons.compress.utils.FileNameUtils;\n",
        "    /**\n",
        "     * Pattern for matching a file extension that is safe, i.e., contains between 1 and 20 alphanumeric\n",
        "     * characters. The upper limit is arbitrary but should fit all extensions and is there to ensure that the\n",
        "     * filename won't be too long.\n",
        "     */\n",
        "    private static final Pattern SAFE_EXTENSION = Pattern.compile(\"^[a-zA-Z0-9]{1,20}$\");\n",
        "\n",
        "    /**\n",
        "     * Pattern for matching characters not allowed in filenames. Currently just matches directory separators.\n",
        "     */\n",
        "    private static final Pattern DISALLOWED_CHARACTERS = Pattern.compile(\"[/\\\\\\\\]\");\n",
        "\n",
        "    private static final String INPUT = \"input\";\n",
        "\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "XWiki Platform is a generic wiki platform offering runtime services for applications built on top of it. Starting in version 3.5-milestone-1 and prior to versions 14.10.8 and 15.3-rc-1, triggering the office converter with a specially crafted file name allows writing the attachment's content to an attacker-controlled location on the server as long as the Java process has write access to that location. In particular in the combination with attachment moving, a feature introduced in XWiki 14.0, this is easy to reproduce but it also possible to reproduce in versions as old as XWiki 3.5 by uploading the attachment through the REST API which doesn't remove `/` or `\\` from the filename. As the mime type of the attachment doesn't matter for the exploitation, this could e.g., be used to replace the `jar`-file of an extension which would allow executing arbitrary Java code and thus impact the confidentiality, integrity and availability of the XWiki installation. This vulnerability has been patched in XWiki 14.10.8 and 15.3RC1. There are no known workarounds apart from disabling the office converter.",
    "id": 12401
  },
  {
    "cve_id": "CVE-2023-37913",
    "code_before_change": "{\n    /**\n     * Top-level temporary working directory.\n     */\n    private File rootDir;\n\n    /**\n     * Input directory where all the input files are located.\n     */\n    private File inputDir;\n\n    /**\n     * Input office document file.\n     */\n    private File inputFile;\n\n    /**\n     * Output directory.\n     */\n    private File outputDir;\n\n    /**\n     * Main output file.\n     */\n    private File outputFile;\n\n    /**\n     * Creates a new {@link OfficeConverterFileStorage} instance for tracking file system storage for a convert\n     * operation.\n     * \n     * @param parentDir parent directory under which temporary storage is to be allocated.\n     * @param inputFileName main input file which will be fed into office server.\n     * @param outputFileName main output file into which result of the office conversion will be written into.\n     * @throws IOException if an error occurs while creating temporary directory structure.\n     */\n    public OfficeConverterFileStorage(File parentDir, String inputFileName, String outputFileName) throws IOException\n    {\n        boolean success = false;\n\n        // Realize the temporary directory hierarchy.\n        this.rootDir = new File(parentDir, UUID.randomUUID().toString());\n        if (this.rootDir.mkdir()) {\n            this.inputDir = new File(this.rootDir, \"input\");\n            this.outputDir = new File(this.rootDir, \"output\");\n            if (this.inputDir.mkdir() && this.outputDir.mkdir()) {\n                this.inputFile = new File(this.inputDir, StringUtils.stripAccents(inputFileName));\n                this.outputFile = new File(this.outputDir, StringUtils.stripAccents(outputFileName));\n                success = true;\n            }\n        }\n\n        // Cleanup & signal if an error is encountered.\n        if (!success) {\n            cleanUp();\n            throw new IOException(\"Could not create temporary directory hierarchy.\");\n        }\n    }\n\n    /**\n     * @return {@link File} representing the input directory where the main input document as well as any other\n     *         dependent artifacts should be located.\n     */\n    public File getInputDir()\n    {\n        return this.inputDir;\n    }\n\n    /**\n     * @return {@link File} representing the main input file.\n     */\n    public File getInputFile()\n    {\n        return this.inputFile;\n    }\n\n    /**\n     * @return {@link File} representing the output directory where the main output file as well as any other dependent\n     *         artifacts are located.\n     */\n    public File getOutputDir()\n    {\n        return this.outputDir;\n    }\n\n    /**\n     * @return {@link File} representing the main output file.\n     */\n    public File getOutputFile()\n    {\n        return this.outputFile;\n    }\n\n    /**\n     * Cleans up the allocated file storage.\n     * \n     * @return true if the cleanup operation succeeded, false otherwise.\n     */\n    public boolean cleanUp()\n    {\n        if (this.rootDir.exists()) {\n            return delete(this.rootDir);\n        }\n\n        return true;\n    }\n\n    /**\n     * Utility method for deleting a directory or a file.\n     * \n     * @param file file or directory to be deleted.\n     * @return true if the whole operation succeeded, false otherwise.\n     */\n    private boolean delete(File file)\n    {\n        // If directory, recursively delete all of it's content.\n        if (file.isDirectory()) {\n            for (File child : file.listFiles()) {\n                delete(child);\n            }\n        }\n\n        // Finally attempt to delete the parent (or the ordinary file).\n        return file.delete();\n    }\n}",
    "code_after_change": "{\n    /**\n     * Pattern for matching a file extension that is safe, i.e., contains between 1 and 20 alphanumeric\n     * characters. The upper limit is arbitrary but should fit all extensions and is there to ensure that the\n     * filename won't be too long.\n     */\n    private static final Pattern SAFE_EXTENSION = Pattern.compile(\"^[a-zA-Z0-9]{1,20}$\");\n\n    /**\n     * Pattern for matching characters not allowed in filenames. Currently just matches directory separators.\n     */\n    private static final Pattern DISALLOWED_CHARACTERS = Pattern.compile(\"[/\\\\\\\\]\");\n\n    private static final String INPUT = \"input\";\n\n    /**\n     * Top-level temporary working directory.\n     */\n    private File rootDir;\n\n    /**\n     * Input directory where all the input files are located.\n     */\n    private File inputDir;\n\n    /**\n     * Input office document file.\n     */\n    private File inputFile;\n\n    /**\n     * Output directory.\n     */\n    private File outputDir;\n\n    /**\n     * Main output file.\n     */\n    private File outputFile;\n\n    /**\n     * Creates a new {@link OfficeConverterFileStorage} instance for tracking file system storage for a convert\n     * operation.\n     * \n     * @param parentDir parent directory under which temporary storage is to be allocated.\n     * @param inputFileName main input file which will be fed into office server.\n     * @param outputFileName main output file into which result of the office conversion will be written into.\n     * @throws IOException if an error occurs while creating temporary directory structure.\n     */\n    public OfficeConverterFileStorage(File parentDir, String inputFileName, String outputFileName) throws IOException\n    {\n        boolean success = false;\n\n        // Realize the temporary directory hierarchy.\n        this.rootDir = new File(parentDir, UUID.randomUUID().toString());\n        if (this.rootDir.mkdir()) {\n            this.inputDir = new File(this.rootDir, INPUT);\n            this.outputDir = new File(this.rootDir, \"output\");\n            if (this.inputDir.mkdir() && this.outputDir.mkdir()) {\n                this.inputFile = new File(this.inputDir, cleanFilename(inputFileName));\n                this.outputFile = new File(this.outputDir, cleanFilename(outputFileName));\n                success = true;\n            }\n        }\n\n        // Cleanup & signal if an error is encountered.\n        if (!success) {\n            cleanUp();\n            throw new IOException(\"Could not create temporary directory hierarchy.\");\n        }\n    }\n\n    /**\n     * Gets a filename that is safe to use as input filename for a conversion operation.\n     * <p>\n     * The extension is kept from the input filename if it is alphanumeric and contains between 1 and 20 characters.\n     *\n     * @param filename the filename for getting the extension\n     * @return the input filename\n     */\n    public static String getSafeInputFilenameFromExtension(String filename)\n    {\n        String extension = FileNameUtils.getExtension(filename);\n        if (!SAFE_EXTENSION.matcher(extension).matches()) {\n            extension = \"\";\n        }\n\n        return StringUtils.isBlank(extension) ? INPUT : INPUT + \".\" + extension;\n    }\n\n    /**\n     * Clean a file name for use as input or output name.\n     *\n     * @param name the filename to clean\n     * @return the cleaned name, shortened to 255 characters if needed\n     */\n    public static String cleanFilename(String name)\n    {\n        String result = DISALLOWED_CHARACTERS.matcher(StringUtils.stripAccents(name)).replaceAll(\"_\");\n\n        // Make sure that the filename is not blank. Don't use an extension so maybe content guessing works.\n        if (StringUtils.isBlank(result)) {\n            result = \"fallback\";\n        }\n\n        // If the filename is too long, keep the part at the end as it contains the extension.\n        if (result.length() > 255) {\n            result = result.substring(result.length() - 255);\n        }\n\n        return result;\n    }\n\n    /**\n     * @return {@link File} representing the input directory where the main input document as well as any other\n     *         dependent artifacts should be located.\n     */\n    public File getInputDir()\n    {\n        return this.inputDir;\n    }\n\n    /**\n     * @return {@link File} representing the main input file.\n     */\n    public File getInputFile()\n    {\n        return this.inputFile;\n    }\n\n    /**\n     * @return {@link File} representing the output directory where the main output file as well as any other dependent\n     *         artifacts are located.\n     */\n    public File getOutputDir()\n    {\n        return this.outputDir;\n    }\n\n    /**\n     * @return {@link File} representing the main output file.\n     */\n    public File getOutputFile()\n    {\n        return this.outputFile;\n    }\n\n    /**\n     * Cleans up the allocated file storage.\n     * \n     * @return true if the cleanup operation succeeded, false otherwise.\n     */\n    public boolean cleanUp()\n    {\n        if (this.rootDir.exists()) {\n            return delete(this.rootDir);\n        }\n\n        return true;\n    }\n\n    /**\n     * Utility method for deleting a directory or a file.\n     * \n     * @param file file or directory to be deleted.\n     * @return true if the whole operation succeeded, false otherwise.\n     */\n    private boolean delete(File file)\n    {\n        // If directory, recursively delete all of it's content.\n        if (file.isDirectory()) {\n            for (File child : file.listFiles()) {\n                delete(child);\n            }\n        }\n\n        // Finally attempt to delete the parent (or the ordinary file).\n        return file.delete();\n    }\n}",
    "patch": "@@ -22,7 +22,9 @@\n import java.io.File;\n import java.io.IOException;\n import java.util.UUID;\n+import java.util.regex.Pattern;\n \n+import org.apache.commons.compress.utils.FileNameUtils;\n import org.apache.commons.lang3.StringUtils;\n \n /**\n@@ -34,6 +36,20 @@\n  */\n public class OfficeConverterFileStorage\n {\n+    /**\n+     * Pattern for matching a file extension that is safe, i.e., contains between 1 and 20 alphanumeric\n+     * characters. The upper limit is arbitrary but should fit all extensions and is there to ensure that the\n+     * filename won't be too long.\n+     */\n+    private static final Pattern SAFE_EXTENSION = Pattern.compile(\"^[a-zA-Z0-9]{1,20}$\");\n+\n+    /**\n+     * Pattern for matching characters not allowed in filenames. Currently just matches directory separators.\n+     */\n+    private static final Pattern DISALLOWED_CHARACTERS = Pattern.compile(\"[/\\\\\\\\]\");\n+\n+    private static final String INPUT = \"input\";\n+\n     /**\n      * Top-level temporary working directory.\n      */\n@@ -75,11 +91,11 @@ public OfficeConverterFileStorage(File parentDir, String inputFileName, String o\n         // Realize the temporary directory hierarchy.\n         this.rootDir = new File(parentDir, UUID.randomUUID().toString());\n         if (this.rootDir.mkdir()) {\n-            this.inputDir = new File(this.rootDir, \"input\");\n+            this.inputDir = new File(this.rootDir, INPUT);\n             this.outputDir = new File(this.rootDir, \"output\");\n             if (this.inputDir.mkdir() && this.outputDir.mkdir()) {\n-                this.inputFile = new File(this.inputDir, StringUtils.stripAccents(inputFileName));\n-                this.outputFile = new File(this.outputDir, StringUtils.stripAccents(outputFileName));\n+                this.inputFile = new File(this.inputDir, cleanFilename(inputFileName));\n+                this.outputFile = new File(this.outputDir, cleanFilename(outputFileName));\n                 success = true;\n             }\n         }\n@@ -91,6 +107,47 @@ public OfficeConverterFileStorage(File parentDir, String inputFileName, String o\n         }\n     }\n \n+    /**\n+     * Gets a filename that is safe to use as input filename for a conversion operation.\n+     * <p>\n+     * The extension is kept from the input filename if it is alphanumeric and contains between 1 and 20 characters.\n+     *\n+     * @param filename the filename for getting the extension\n+     * @return the input filename\n+     */\n+    public static String getSafeInputFilenameFromExtension(String filename)\n+    {\n+        String extension = FileNameUtils.getExtension(filename);\n+        if (!SAFE_EXTENSION.matcher(extension).matches()) {\n+            extension = \"\";\n+        }\n+\n+        return StringUtils.isBlank(extension) ? INPUT : INPUT + \".\" + extension;\n+    }\n+\n+    /**\n+     * Clean a file name for use as input or output name.\n+     *\n+     * @param name the filename to clean\n+     * @return the cleaned name, shortened to 255 characters if needed\n+     */\n+    public static String cleanFilename(String name)\n+    {\n+        String result = DISALLOWED_CHARACTERS.matcher(StringUtils.stripAccents(name)).replaceAll(\"_\");\n+\n+        // Make sure that the filename is not blank. Don't use an extension so maybe content guessing works.\n+        if (StringUtils.isBlank(result)) {\n+            result = \"fallback\";\n+        }\n+\n+        // If the filename is too long, keep the part at the end as it contains the extension.\n+        if (result.length() > 255) {\n+            result = result.substring(result.length() - 255);\n+        }\n+\n+        return result;\n+    }\n+\n     /**\n      * @return {@link File} representing the input directory where the main input document as well as any other\n      *         dependent artifacts should be located.",
    "function_modified_lines": {
      "added": [
        "            this.inputDir = new File(this.rootDir, INPUT);\n",
        "                this.inputFile = new File(this.inputDir, cleanFilename(inputFileName));\n",
        "                this.outputFile = new File(this.outputDir, cleanFilename(outputFileName));\n",
        "    /**\n",
        "     * Gets a filename that is safe to use as input filename for a conversion operation.\n",
        "     * <p>\n",
        "     * The extension is kept from the input filename if it is alphanumeric and contains between 1 and 20 characters.\n",
        "     *\n",
        "     * @param filename the filename for getting the extension\n",
        "     * @return the input filename\n",
        "     */\n",
        "    public static String getSafeInputFilenameFromExtension(String filename)\n",
        "    {\n",
        "        String extension = FileNameUtils.getExtension(filename);\n",
        "        if (!SAFE_EXTENSION.matcher(extension).matches()) {\n",
        "            extension = \"\";\n",
        "        }\n",
        "\n",
        "        return StringUtils.isBlank(extension) ? INPUT : INPUT + \".\" + extension;\n",
        "    }\n",
        "\n",
        "    /**\n",
        "     * Clean a file name for use as input or output name.\n",
        "     *\n",
        "     * @param name the filename to clean\n",
        "     * @return the cleaned name, shortened to 255 characters if needed\n",
        "     */\n",
        "    public static String cleanFilename(String name)\n",
        "    {\n",
        "        String result = DISALLOWED_CHARACTERS.matcher(StringUtils.stripAccents(name)).replaceAll(\"_\");\n",
        "\n",
        "        // Make sure that the filename is not blank. Don't use an extension so maybe content guessing works.\n",
        "        if (StringUtils.isBlank(result)) {\n",
        "            result = \"fallback\";\n",
        "        }\n",
        "\n",
        "        // If the filename is too long, keep the part at the end as it contains the extension.\n",
        "        if (result.length() > 255) {\n",
        "            result = result.substring(result.length() - 255);\n",
        "        }\n",
        "\n",
        "        return result;\n",
        "    }\n",
        "\n"
      ],
      "deleted": [
        "            this.inputDir = new File(this.rootDir, \"input\");\n",
        "                this.inputFile = new File(this.inputDir, StringUtils.stripAccents(inputFileName));\n",
        "                this.outputFile = new File(this.outputDir, StringUtils.stripAccents(outputFileName));\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "XWiki Platform is a generic wiki platform offering runtime services for applications built on top of it. Starting in version 3.5-milestone-1 and prior to versions 14.10.8 and 15.3-rc-1, triggering the office converter with a specially crafted file name allows writing the attachment's content to an attacker-controlled location on the server as long as the Java process has write access to that location. In particular in the combination with attachment moving, a feature introduced in XWiki 14.0, this is easy to reproduce but it also possible to reproduce in versions as old as XWiki 3.5 by uploading the attachment through the REST API which doesn't remove `/` or `\\` from the filename. As the mime type of the attachment doesn't matter for the exploitation, this could e.g., be used to replace the `jar`-file of an extension which would allow executing arbitrary Java code and thus impact the confidentiality, integrity and availability of the XWiki installation. This vulnerability has been patched in XWiki 14.10.8 and 15.3RC1. There are no known workarounds apart from disabling the office converter.",
    "id": 12402
  },
  {
    "cve_id": "CVE-2023-37913",
    "code_before_change": "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.officeimporter.internal.splitter;\n\nimport java.io.File;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport javax.inject.Inject;\nimport javax.inject.Named;\nimport javax.inject.Provider;\nimport javax.inject.Singleton;\n\nimport org.xwiki.component.annotation.Component;\nimport org.xwiki.component.manager.ComponentLookupException;\nimport org.xwiki.component.manager.ComponentManager;\nimport org.xwiki.officeimporter.OfficeImporterException;\nimport org.xwiki.officeimporter.document.XDOMOfficeDocument;\nimport org.xwiki.officeimporter.splitter.OfficeDocumentSplitterParameters;\nimport org.xwiki.officeimporter.splitter.TargetDocumentDescriptor;\nimport org.xwiki.officeimporter.splitter.XDOMOfficeDocumentSplitter;\nimport org.xwiki.refactoring.WikiDocument;\nimport org.xwiki.refactoring.splitter.DocumentSplitter;\nimport org.xwiki.refactoring.splitter.criterion.HeadingLevelSplittingCriterion;\nimport org.xwiki.refactoring.splitter.criterion.SplittingCriterion;\nimport org.xwiki.refactoring.splitter.criterion.naming.NamingCriterion;\nimport org.xwiki.rendering.block.Block.Axes;\nimport org.xwiki.rendering.block.ImageBlock;\nimport org.xwiki.rendering.block.match.ClassBlockMatcher;\n\n/**\n * Default implementation of {@link XDOMOfficeDocumentSplitter}.\n * \n * @version $Id$\n * @since 2.1M1\n */\n@Component\n@Singleton\npublic class DefaultXDOMOfficeDocumentSplitter implements XDOMOfficeDocumentSplitter\n{\n    /**\n     * The {@link DocumentSplitter} used for splitting wiki documents.\n     */\n    @Inject\n    private DocumentSplitter documentSplitter;\n\n    /**\n     * Used by {@link org.xwiki.officeimporter.splitter.TargetDocumentDescriptor}.\n     */\n    @Inject\n    @Named(\"context\")\n    private Provider<ComponentManager> componentManagerProvider;\n\n    @Override\n    public Map<TargetDocumentDescriptor, XDOMOfficeDocument> split(XDOMOfficeDocument officeDocument,\n        OfficeDocumentSplitterParameters parameters) throws OfficeImporterException\n    {\n        ComponentManager componentManager = this.componentManagerProvider.get();\n        Map<TargetDocumentDescriptor, XDOMOfficeDocument> result =\n            new HashMap<TargetDocumentDescriptor, XDOMOfficeDocument>();\n\n        // Create splitting and naming criterion for refactoring.\n        SplittingCriterion splittingCriterion =\n            new HeadingLevelSplittingCriterion(parameters.getHeadingLevelsToSplit());\n        NamingCriterion namingCriterion;\n        try {\n            namingCriterion = componentManager.getInstance(NamingCriterion.class, parameters.getNamingCriterionHint());\n        } catch (ComponentLookupException e) {\n            throw new OfficeImporterException(\"Failed to create the naming criterion.\", e);\n        }\n        namingCriterion.getParameters().setBaseDocumentReference(parameters.getBaseDocumentReference());\n        namingCriterion.getParameters().setUseTerminalPages(parameters.isUseTerminalPages());\n\n        // Create the root document required by refactoring module.\n        WikiDocument rootDoc =\n            new WikiDocument(parameters.getBaseDocumentReference(), officeDocument.getContentDocument(), null);\n        List<WikiDocument> documents = this.documentSplitter.split(rootDoc, splittingCriterion, namingCriterion);\n\n        for (WikiDocument doc : documents) {\n            // Initialize a target page descriptor.\n            TargetDocumentDescriptor targetDocumentDescriptor =\n                new TargetDocumentDescriptor(doc.getDocumentReference(), componentManager);\n            if (doc.getParent() != null) {\n                targetDocumentDescriptor.setParentReference(doc.getParent().getDocumentReference());\n            }\n\n            // Rewire artifacts.\n            Set<File> artifactsFiles = relocateArtifacts(doc, officeDocument);\n\n            // Create the resulting XDOMOfficeDocument.\n            XDOMOfficeDocument splitDocument = new XDOMOfficeDocument(doc.getXdom(), artifactsFiles, componentManager,\n                officeDocument.getConverterResult());\n            result.put(targetDocumentDescriptor, splitDocument);\n        }\n\n        return result;\n    }\n\n    /**\n     * Move artifacts (i.e. embedded images) from the original office document to a specific wiki document corresponding\n     * to a section. Only the artifacts from that section are moved.\n     * \n     * @param sectionDoc the newly created wiki document corresponding to a section of the original office document\n     * @param officeDocument the office document being splitted into wiki documents\n     * @return the relocated artifacts\n     */\n    private Set<File> relocateArtifacts(WikiDocument sectionDoc, XDOMOfficeDocument officeDocument)\n    {\n        Set<File> artifacts = officeDocument.getArtifactsFiles();\n        Set<File> result = new HashSet<>();\n        List<ImageBlock> imageBlocks =\n            sectionDoc.getXdom().getBlocks(new ClassBlockMatcher(ImageBlock.class), Axes.DESCENDANT);\n        if (!imageBlocks.isEmpty()) {\n            Map<String, File> fileMap = new HashMap<>();\n            artifacts.forEach(item -> fileMap.put(item.getName(), item));\n            for (ImageBlock imageBlock : imageBlocks) {\n                String imageReference = imageBlock.getReference().getReference();\n                File file = fileMap.get(imageReference);\n                result.add(file);\n                artifacts.remove(file);\n            }\n        }\n        return result;\n    }\n}\n",
    "code_after_change": "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.officeimporter.internal.splitter;\n\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport javax.inject.Inject;\nimport javax.inject.Named;\nimport javax.inject.Provider;\nimport javax.inject.Singleton;\n\nimport org.xwiki.component.annotation.Component;\nimport org.xwiki.component.manager.ComponentLookupException;\nimport org.xwiki.component.manager.ComponentManager;\nimport org.xwiki.officeimporter.OfficeImporterException;\nimport org.xwiki.officeimporter.document.OfficeDocumentArtifact;\nimport org.xwiki.officeimporter.document.XDOMOfficeDocument;\nimport org.xwiki.officeimporter.splitter.OfficeDocumentSplitterParameters;\nimport org.xwiki.officeimporter.splitter.TargetDocumentDescriptor;\nimport org.xwiki.officeimporter.splitter.XDOMOfficeDocumentSplitter;\nimport org.xwiki.refactoring.WikiDocument;\nimport org.xwiki.refactoring.splitter.DocumentSplitter;\nimport org.xwiki.refactoring.splitter.criterion.HeadingLevelSplittingCriterion;\nimport org.xwiki.refactoring.splitter.criterion.SplittingCriterion;\nimport org.xwiki.refactoring.splitter.criterion.naming.NamingCriterion;\nimport org.xwiki.rendering.block.Block.Axes;\nimport org.xwiki.rendering.block.ImageBlock;\nimport org.xwiki.rendering.block.match.ClassBlockMatcher;\n\n/**\n * Default implementation of {@link XDOMOfficeDocumentSplitter}.\n * \n * @version $Id$\n * @since 2.1M1\n */\n@Component\n@Singleton\npublic class DefaultXDOMOfficeDocumentSplitter implements XDOMOfficeDocumentSplitter\n{\n    /**\n     * The {@link DocumentSplitter} used for splitting wiki documents.\n     */\n    @Inject\n    private DocumentSplitter documentSplitter;\n\n    /**\n     * Used by {@link org.xwiki.officeimporter.splitter.TargetDocumentDescriptor}.\n     */\n    @Inject\n    @Named(\"context\")\n    private Provider<ComponentManager> componentManagerProvider;\n\n    @Override\n    public Map<TargetDocumentDescriptor, XDOMOfficeDocument> split(XDOMOfficeDocument officeDocument,\n        OfficeDocumentSplitterParameters parameters) throws OfficeImporterException\n    {\n        ComponentManager componentManager = this.componentManagerProvider.get();\n        Map<TargetDocumentDescriptor, XDOMOfficeDocument> result =\n            new HashMap<TargetDocumentDescriptor, XDOMOfficeDocument>();\n\n        // Create splitting and naming criterion for refactoring.\n        SplittingCriterion splittingCriterion =\n            new HeadingLevelSplittingCriterion(parameters.getHeadingLevelsToSplit());\n        NamingCriterion namingCriterion;\n        try {\n            namingCriterion = componentManager.getInstance(NamingCriterion.class, parameters.getNamingCriterionHint());\n        } catch (ComponentLookupException e) {\n            throw new OfficeImporterException(\"Failed to create the naming criterion.\", e);\n        }\n        namingCriterion.getParameters().setBaseDocumentReference(parameters.getBaseDocumentReference());\n        namingCriterion.getParameters().setUseTerminalPages(parameters.isUseTerminalPages());\n\n        // Create the root document required by refactoring module.\n        WikiDocument rootDoc =\n            new WikiDocument(parameters.getBaseDocumentReference(), officeDocument.getContentDocument(), null);\n        List<WikiDocument> documents = this.documentSplitter.split(rootDoc, splittingCriterion, namingCriterion);\n\n        for (WikiDocument doc : documents) {\n            // Initialize a target page descriptor.\n            TargetDocumentDescriptor targetDocumentDescriptor =\n                new TargetDocumentDescriptor(doc.getDocumentReference(), componentManager);\n            if (doc.getParent() != null) {\n                targetDocumentDescriptor.setParentReference(doc.getParent().getDocumentReference());\n            }\n\n            // Rewire artifacts.\n            Map<String, OfficeDocumentArtifact> artifactsMap = relocateArtifacts(doc, officeDocument);\n\n            // Create the resulting XDOMOfficeDocument.\n            XDOMOfficeDocument splitDocument = new XDOMOfficeDocument(doc.getXdom(), artifactsMap, componentManager,\n                officeDocument.getConverterResult());\n            result.put(targetDocumentDescriptor, splitDocument);\n        }\n\n        return result;\n    }\n\n    /**\n     * Copy artifacts (i.e. embedded images) from the original office document to a specific wiki document corresponding\n     * to a section. Only the artifacts from that section are copied.\n     * \n     * @param sectionDoc the newly created wiki document corresponding to a section of the original office document\n     * @param officeDocument the office document being splitted into wiki documents\n     * @return the relocated artifacts\n     */\n    private Map<String, OfficeDocumentArtifact> relocateArtifacts(WikiDocument sectionDoc,\n        XDOMOfficeDocument officeDocument)\n    {\n        Map<String, OfficeDocumentArtifact> artifacts = officeDocument.getArtifactsMap();\n        Map<String, OfficeDocumentArtifact> result = new HashMap<>();\n        List<ImageBlock> imageBlocks =\n            sectionDoc.getXdom().getBlocks(new ClassBlockMatcher(ImageBlock.class), Axes.DESCENDANT);\n        for (ImageBlock imageBlock : imageBlocks) {\n            String imageReference = imageBlock.getReference().getReference();\n            OfficeDocumentArtifact artifact = artifacts.get(imageReference);\n            if (artifact != null) {\n                result.put(imageReference, artifact);\n            }\n        }\n        return result;\n    }\n}\n",
    "patch": "@@ -19,12 +19,9 @@\n  */\n package org.xwiki.officeimporter.internal.splitter;\n \n-import java.io.File;\n import java.util.HashMap;\n-import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n-import java.util.Set;\n \n import javax.inject.Inject;\n import javax.inject.Named;\n@@ -35,6 +32,7 @@\n import org.xwiki.component.manager.ComponentLookupException;\n import org.xwiki.component.manager.ComponentManager;\n import org.xwiki.officeimporter.OfficeImporterException;\n+import org.xwiki.officeimporter.document.OfficeDocumentArtifact;\n import org.xwiki.officeimporter.document.XDOMOfficeDocument;\n import org.xwiki.officeimporter.splitter.OfficeDocumentSplitterParameters;\n import org.xwiki.officeimporter.splitter.TargetDocumentDescriptor;\n@@ -105,10 +103,10 @@ public Map<TargetDocumentDescriptor, XDOMOfficeDocument> split(XDOMOfficeDocumen\n             }\n \n             // Rewire artifacts.\n-            Set<File> artifactsFiles = relocateArtifacts(doc, officeDocument);\n+            Map<String, OfficeDocumentArtifact> artifactsMap = relocateArtifacts(doc, officeDocument);\n \n             // Create the resulting XDOMOfficeDocument.\n-            XDOMOfficeDocument splitDocument = new XDOMOfficeDocument(doc.getXdom(), artifactsFiles, componentManager,\n+            XDOMOfficeDocument splitDocument = new XDOMOfficeDocument(doc.getXdom(), artifactsMap, componentManager,\n                 officeDocument.getConverterResult());\n             result.put(targetDocumentDescriptor, splitDocument);\n         }\n@@ -117,27 +115,25 @@ public Map<TargetDocumentDescriptor, XDOMOfficeDocument> split(XDOMOfficeDocumen\n     }\n \n     /**\n-     * Move artifacts (i.e. embedded images) from the original office document to a specific wiki document corresponding\n-     * to a section. Only the artifacts from that section are moved.\n+     * Copy artifacts (i.e. embedded images) from the original office document to a specific wiki document corresponding\n+     * to a section. Only the artifacts from that section are copied.\n      * \n      * @param sectionDoc the newly created wiki document corresponding to a section of the original office document\n      * @param officeDocument the office document being splitted into wiki documents\n      * @return the relocated artifacts\n      */\n-    private Set<File> relocateArtifacts(WikiDocument sectionDoc, XDOMOfficeDocument officeDocument)\n+    private Map<String, OfficeDocumentArtifact> relocateArtifacts(WikiDocument sectionDoc,\n+        XDOMOfficeDocument officeDocument)\n     {\n-        Set<File> artifacts = officeDocument.getArtifactsFiles();\n-        Set<File> result = new HashSet<>();\n+        Map<String, OfficeDocumentArtifact> artifacts = officeDocument.getArtifactsMap();\n+        Map<String, OfficeDocumentArtifact> result = new HashMap<>();\n         List<ImageBlock> imageBlocks =\n             sectionDoc.getXdom().getBlocks(new ClassBlockMatcher(ImageBlock.class), Axes.DESCENDANT);\n-        if (!imageBlocks.isEmpty()) {\n-            Map<String, File> fileMap = new HashMap<>();\n-            artifacts.forEach(item -> fileMap.put(item.getName(), item));\n-            for (ImageBlock imageBlock : imageBlocks) {\n-                String imageReference = imageBlock.getReference().getReference();\n-                File file = fileMap.get(imageReference);\n-                result.add(file);\n-                artifacts.remove(file);\n+        for (ImageBlock imageBlock : imageBlocks) {\n+            String imageReference = imageBlock.getReference().getReference();\n+            OfficeDocumentArtifact artifact = artifacts.get(imageReference);\n+            if (artifact != null) {\n+                result.put(imageReference, artifact);\n             }\n         }\n         return result;",
    "function_modified_lines": {
      "added": [
        "import org.xwiki.officeimporter.document.OfficeDocumentArtifact;\n"
      ],
      "deleted": [
        "import java.io.File;\n",
        "import java.util.HashSet;\n",
        "import java.util.Set;\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "XWiki Platform is a generic wiki platform offering runtime services for applications built on top of it. Starting in version 3.5-milestone-1 and prior to versions 14.10.8 and 15.3-rc-1, triggering the office converter with a specially crafted file name allows writing the attachment's content to an attacker-controlled location on the server as long as the Java process has write access to that location. In particular in the combination with attachment moving, a feature introduced in XWiki 14.0, this is easy to reproduce but it also possible to reproduce in versions as old as XWiki 3.5 by uploading the attachment through the REST API which doesn't remove `/` or `\\` from the filename. As the mime type of the attachment doesn't matter for the exploitation, this could e.g., be used to replace the `jar`-file of an extension which would allow executing arbitrary Java code and thus impact the confidentiality, integrity and availability of the XWiki installation. This vulnerability has been patched in XWiki 14.10.8 and 15.3RC1. There are no known workarounds apart from disabling the office converter.",
    "id": 12404
  },
  {
    "cve_id": "CVE-2023-37913",
    "code_before_change": "{\n    /**\n     * The {@link DocumentSplitter} used for splitting wiki documents.\n     */\n    @Inject\n    private DocumentSplitter documentSplitter;\n\n    /**\n     * Used by {@link org.xwiki.officeimporter.splitter.TargetDocumentDescriptor}.\n     */\n    @Inject\n    @Named(\"context\")\n    private Provider<ComponentManager> componentManagerProvider;\n\n    @Override\n    public Map<TargetDocumentDescriptor, XDOMOfficeDocument> split(XDOMOfficeDocument officeDocument,\n        OfficeDocumentSplitterParameters parameters) throws OfficeImporterException\n    {\n        ComponentManager componentManager = this.componentManagerProvider.get();\n        Map<TargetDocumentDescriptor, XDOMOfficeDocument> result =\n            new HashMap<TargetDocumentDescriptor, XDOMOfficeDocument>();\n\n        // Create splitting and naming criterion for refactoring.\n        SplittingCriterion splittingCriterion =\n            new HeadingLevelSplittingCriterion(parameters.getHeadingLevelsToSplit());\n        NamingCriterion namingCriterion;\n        try {\n            namingCriterion = componentManager.getInstance(NamingCriterion.class, parameters.getNamingCriterionHint());\n        } catch (ComponentLookupException e) {\n            throw new OfficeImporterException(\"Failed to create the naming criterion.\", e);\n        }\n        namingCriterion.getParameters().setBaseDocumentReference(parameters.getBaseDocumentReference());\n        namingCriterion.getParameters().setUseTerminalPages(parameters.isUseTerminalPages());\n\n        // Create the root document required by refactoring module.\n        WikiDocument rootDoc =\n            new WikiDocument(parameters.getBaseDocumentReference(), officeDocument.getContentDocument(), null);\n        List<WikiDocument> documents = this.documentSplitter.split(rootDoc, splittingCriterion, namingCriterion);\n\n        for (WikiDocument doc : documents) {\n            // Initialize a target page descriptor.\n            TargetDocumentDescriptor targetDocumentDescriptor =\n                new TargetDocumentDescriptor(doc.getDocumentReference(), componentManager);\n            if (doc.getParent() != null) {\n                targetDocumentDescriptor.setParentReference(doc.getParent().getDocumentReference());\n            }\n\n            // Rewire artifacts.\n            Set<File> artifactsFiles = relocateArtifacts(doc, officeDocument);\n\n            // Create the resulting XDOMOfficeDocument.\n            XDOMOfficeDocument splitDocument = new XDOMOfficeDocument(doc.getXdom(), artifactsFiles, componentManager,\n                officeDocument.getConverterResult());\n            result.put(targetDocumentDescriptor, splitDocument);\n        }\n\n        return result;\n    }\n\n    /**\n     * Move artifacts (i.e. embedded images) from the original office document to a specific wiki document corresponding\n     * to a section. Only the artifacts from that section are moved.\n     * \n     * @param sectionDoc the newly created wiki document corresponding to a section of the original office document\n     * @param officeDocument the office document being splitted into wiki documents\n     * @return the relocated artifacts\n     */\n    private Set<File> relocateArtifacts(WikiDocument sectionDoc, XDOMOfficeDocument officeDocument)\n    {\n        Set<File> artifacts = officeDocument.getArtifactsFiles();\n        Set<File> result = new HashSet<>();\n        List<ImageBlock> imageBlocks =\n            sectionDoc.getXdom().getBlocks(new ClassBlockMatcher(ImageBlock.class), Axes.DESCENDANT);\n        if (!imageBlocks.isEmpty()) {\n            Map<String, File> fileMap = new HashMap<>();\n            artifacts.forEach(item -> fileMap.put(item.getName(), item));\n            for (ImageBlock imageBlock : imageBlocks) {\n                String imageReference = imageBlock.getReference().getReference();\n                File file = fileMap.get(imageReference);\n                result.add(file);\n                artifacts.remove(file);\n            }\n        }\n        return result;\n    }\n}",
    "code_after_change": "{\n    /**\n     * The {@link DocumentSplitter} used for splitting wiki documents.\n     */\n    @Inject\n    private DocumentSplitter documentSplitter;\n\n    /**\n     * Used by {@link org.xwiki.officeimporter.splitter.TargetDocumentDescriptor}.\n     */\n    @Inject\n    @Named(\"context\")\n    private Provider<ComponentManager> componentManagerProvider;\n\n    @Override\n    public Map<TargetDocumentDescriptor, XDOMOfficeDocument> split(XDOMOfficeDocument officeDocument,\n        OfficeDocumentSplitterParameters parameters) throws OfficeImporterException\n    {\n        ComponentManager componentManager = this.componentManagerProvider.get();\n        Map<TargetDocumentDescriptor, XDOMOfficeDocument> result =\n            new HashMap<TargetDocumentDescriptor, XDOMOfficeDocument>();\n\n        // Create splitting and naming criterion for refactoring.\n        SplittingCriterion splittingCriterion =\n            new HeadingLevelSplittingCriterion(parameters.getHeadingLevelsToSplit());\n        NamingCriterion namingCriterion;\n        try {\n            namingCriterion = componentManager.getInstance(NamingCriterion.class, parameters.getNamingCriterionHint());\n        } catch (ComponentLookupException e) {\n            throw new OfficeImporterException(\"Failed to create the naming criterion.\", e);\n        }\n        namingCriterion.getParameters().setBaseDocumentReference(parameters.getBaseDocumentReference());\n        namingCriterion.getParameters().setUseTerminalPages(parameters.isUseTerminalPages());\n\n        // Create the root document required by refactoring module.\n        WikiDocument rootDoc =\n            new WikiDocument(parameters.getBaseDocumentReference(), officeDocument.getContentDocument(), null);\n        List<WikiDocument> documents = this.documentSplitter.split(rootDoc, splittingCriterion, namingCriterion);\n\n        for (WikiDocument doc : documents) {\n            // Initialize a target page descriptor.\n            TargetDocumentDescriptor targetDocumentDescriptor =\n                new TargetDocumentDescriptor(doc.getDocumentReference(), componentManager);\n            if (doc.getParent() != null) {\n                targetDocumentDescriptor.setParentReference(doc.getParent().getDocumentReference());\n            }\n\n            // Rewire artifacts.\n            Map<String, OfficeDocumentArtifact> artifactsMap = relocateArtifacts(doc, officeDocument);\n\n            // Create the resulting XDOMOfficeDocument.\n            XDOMOfficeDocument splitDocument = new XDOMOfficeDocument(doc.getXdom(), artifactsMap, componentManager,\n                officeDocument.getConverterResult());\n            result.put(targetDocumentDescriptor, splitDocument);\n        }\n\n        return result;\n    }\n\n    /**\n     * Copy artifacts (i.e. embedded images) from the original office document to a specific wiki document corresponding\n     * to a section. Only the artifacts from that section are copied.\n     * \n     * @param sectionDoc the newly created wiki document corresponding to a section of the original office document\n     * @param officeDocument the office document being splitted into wiki documents\n     * @return the relocated artifacts\n     */\n    private Map<String, OfficeDocumentArtifact> relocateArtifacts(WikiDocument sectionDoc,\n        XDOMOfficeDocument officeDocument)\n    {\n        Map<String, OfficeDocumentArtifact> artifacts = officeDocument.getArtifactsMap();\n        Map<String, OfficeDocumentArtifact> result = new HashMap<>();\n        List<ImageBlock> imageBlocks =\n            sectionDoc.getXdom().getBlocks(new ClassBlockMatcher(ImageBlock.class), Axes.DESCENDANT);\n        for (ImageBlock imageBlock : imageBlocks) {\n            String imageReference = imageBlock.getReference().getReference();\n            OfficeDocumentArtifact artifact = artifacts.get(imageReference);\n            if (artifact != null) {\n                result.put(imageReference, artifact);\n            }\n        }\n        return result;\n    }\n}",
    "patch": "@@ -19,12 +19,9 @@\n  */\n package org.xwiki.officeimporter.internal.splitter;\n \n-import java.io.File;\n import java.util.HashMap;\n-import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n-import java.util.Set;\n \n import javax.inject.Inject;\n import javax.inject.Named;\n@@ -35,6 +32,7 @@\n import org.xwiki.component.manager.ComponentLookupException;\n import org.xwiki.component.manager.ComponentManager;\n import org.xwiki.officeimporter.OfficeImporterException;\n+import org.xwiki.officeimporter.document.OfficeDocumentArtifact;\n import org.xwiki.officeimporter.document.XDOMOfficeDocument;\n import org.xwiki.officeimporter.splitter.OfficeDocumentSplitterParameters;\n import org.xwiki.officeimporter.splitter.TargetDocumentDescriptor;\n@@ -105,10 +103,10 @@ public Map<TargetDocumentDescriptor, XDOMOfficeDocument> split(XDOMOfficeDocumen\n             }\n \n             // Rewire artifacts.\n-            Set<File> artifactsFiles = relocateArtifacts(doc, officeDocument);\n+            Map<String, OfficeDocumentArtifact> artifactsMap = relocateArtifacts(doc, officeDocument);\n \n             // Create the resulting XDOMOfficeDocument.\n-            XDOMOfficeDocument splitDocument = new XDOMOfficeDocument(doc.getXdom(), artifactsFiles, componentManager,\n+            XDOMOfficeDocument splitDocument = new XDOMOfficeDocument(doc.getXdom(), artifactsMap, componentManager,\n                 officeDocument.getConverterResult());\n             result.put(targetDocumentDescriptor, splitDocument);\n         }\n@@ -117,27 +115,25 @@ public Map<TargetDocumentDescriptor, XDOMOfficeDocument> split(XDOMOfficeDocumen\n     }\n \n     /**\n-     * Move artifacts (i.e. embedded images) from the original office document to a specific wiki document corresponding\n-     * to a section. Only the artifacts from that section are moved.\n+     * Copy artifacts (i.e. embedded images) from the original office document to a specific wiki document corresponding\n+     * to a section. Only the artifacts from that section are copied.\n      * \n      * @param sectionDoc the newly created wiki document corresponding to a section of the original office document\n      * @param officeDocument the office document being splitted into wiki documents\n      * @return the relocated artifacts\n      */\n-    private Set<File> relocateArtifacts(WikiDocument sectionDoc, XDOMOfficeDocument officeDocument)\n+    private Map<String, OfficeDocumentArtifact> relocateArtifacts(WikiDocument sectionDoc,\n+        XDOMOfficeDocument officeDocument)\n     {\n-        Set<File> artifacts = officeDocument.getArtifactsFiles();\n-        Set<File> result = new HashSet<>();\n+        Map<String, OfficeDocumentArtifact> artifacts = officeDocument.getArtifactsMap();\n+        Map<String, OfficeDocumentArtifact> result = new HashMap<>();\n         List<ImageBlock> imageBlocks =\n             sectionDoc.getXdom().getBlocks(new ClassBlockMatcher(ImageBlock.class), Axes.DESCENDANT);\n-        if (!imageBlocks.isEmpty()) {\n-            Map<String, File> fileMap = new HashMap<>();\n-            artifacts.forEach(item -> fileMap.put(item.getName(), item));\n-            for (ImageBlock imageBlock : imageBlocks) {\n-                String imageReference = imageBlock.getReference().getReference();\n-                File file = fileMap.get(imageReference);\n-                result.add(file);\n-                artifacts.remove(file);\n+        for (ImageBlock imageBlock : imageBlocks) {\n+            String imageReference = imageBlock.getReference().getReference();\n+            OfficeDocumentArtifact artifact = artifacts.get(imageReference);\n+            if (artifact != null) {\n+                result.put(imageReference, artifact);\n             }\n         }\n         return result;",
    "function_modified_lines": {
      "added": [
        "            Map<String, OfficeDocumentArtifact> artifactsMap = relocateArtifacts(doc, officeDocument);\n",
        "            XDOMOfficeDocument splitDocument = new XDOMOfficeDocument(doc.getXdom(), artifactsMap, componentManager,\n",
        "     * Copy artifacts (i.e. embedded images) from the original office document to a specific wiki document corresponding\n",
        "     * to a section. Only the artifacts from that section are copied.\n",
        "    private Map<String, OfficeDocumentArtifact> relocateArtifacts(WikiDocument sectionDoc,\n",
        "        XDOMOfficeDocument officeDocument)\n",
        "        Map<String, OfficeDocumentArtifact> artifacts = officeDocument.getArtifactsMap();\n",
        "        Map<String, OfficeDocumentArtifact> result = new HashMap<>();\n",
        "        for (ImageBlock imageBlock : imageBlocks) {\n",
        "            String imageReference = imageBlock.getReference().getReference();\n",
        "            OfficeDocumentArtifact artifact = artifacts.get(imageReference);\n",
        "            if (artifact != null) {\n",
        "                result.put(imageReference, artifact);\n"
      ],
      "deleted": [
        "            Set<File> artifactsFiles = relocateArtifacts(doc, officeDocument);\n",
        "            XDOMOfficeDocument splitDocument = new XDOMOfficeDocument(doc.getXdom(), artifactsFiles, componentManager,\n",
        "     * Move artifacts (i.e. embedded images) from the original office document to a specific wiki document corresponding\n",
        "     * to a section. Only the artifacts from that section are moved.\n",
        "    private Set<File> relocateArtifacts(WikiDocument sectionDoc, XDOMOfficeDocument officeDocument)\n",
        "        Set<File> artifacts = officeDocument.getArtifactsFiles();\n",
        "        Set<File> result = new HashSet<>();\n",
        "        if (!imageBlocks.isEmpty()) {\n",
        "            Map<String, File> fileMap = new HashMap<>();\n",
        "            artifacts.forEach(item -> fileMap.put(item.getName(), item));\n",
        "            for (ImageBlock imageBlock : imageBlocks) {\n",
        "                String imageReference = imageBlock.getReference().getReference();\n",
        "                File file = fileMap.get(imageReference);\n",
        "                result.add(file);\n",
        "                artifacts.remove(file);\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "XWiki Platform is a generic wiki platform offering runtime services for applications built on top of it. Starting in version 3.5-milestone-1 and prior to versions 14.10.8 and 15.3-rc-1, triggering the office converter with a specially crafted file name allows writing the attachment's content to an attacker-controlled location on the server as long as the Java process has write access to that location. In particular in the combination with attachment moving, a feature introduced in XWiki 14.0, this is easy to reproduce but it also possible to reproduce in versions as old as XWiki 3.5 by uploading the attachment through the REST API which doesn't remove `/` or `\\` from the filename. As the mime type of the attachment doesn't matter for the exploitation, this could e.g., be used to replace the `jar`-file of an extension which would allow executing arbitrary Java code and thus impact the confidentiality, integrity and availability of the XWiki installation. This vulnerability has been patched in XWiki 14.10.8 and 15.3RC1. There are no known workarounds apart from disabling the office converter.",
    "id": 12405
  },
  {
    "cve_id": "CVE-2023-37913",
    "code_before_change": "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.officeimporter.internal;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.util.Collections;\n\nimport org.apache.commons.io.IOUtils;\nimport org.junit.jupiter.api.Test;\nimport org.xwiki.bridge.DocumentAccessBridge;\nimport org.xwiki.bridge.DocumentModelBridge;\nimport org.xwiki.model.reference.AttachmentReference;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.officeimporter.document.XDOMOfficeDocument;\nimport org.xwiki.rendering.syntax.Syntax;\nimport org.xwiki.rendering.syntax.SyntaxType;\nimport org.xwiki.security.authorization.ContextualAuthorizationManager;\nimport org.xwiki.security.authorization.Right;\nimport org.xwiki.test.junit5.XWikiTempDir;\nimport org.xwiki.test.junit5.mockito.ComponentTest;\nimport org.xwiki.test.junit5.mockito.InjectMockComponents;\nimport org.xwiki.test.junit5.mockito.MockComponent;\n\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\n/**\n * Unit test for {@link ModelBridge}.\n * \n * @version $Id$\n */\n@ComponentTest\nclass ModelBridgeTest\n{\n    @InjectMockComponents\n    private ModelBridge modelBridge;\n\n    @MockComponent\n    private DocumentAccessBridge documentAccessBridge;\n\n    @MockComponent\n    private ContextualAuthorizationManager contextualAuthorizationManager;\n\n    @XWikiTempDir\n    private File tempDir;\n\n    @Test\n    void saveWithOverwrite() throws Exception\n    {\n        XDOMOfficeDocument doc = mock(XDOMOfficeDocument.class);\n        DocumentReference documentReference = new DocumentReference(\"wiki\", \"Space\", \"Page\");\n        DocumentReference parentReference = new DocumentReference(\"wiki\", \"Space\", \"Parent\");\n        String syntaxId = \"test/1.0\";\n        String title = \"Office Document Title\";\n        String content = \"Office Document Content\";\n        String fileName = \"logo.png\";\n        byte[] fileContent = new byte[] {65, 82};\n        File artifact = new File(tempDir, fileName);\n        try (FileOutputStream fos = new FileOutputStream(artifact)) {\n            IOUtils.write(fileContent, fos);\n        }\n\n        when(this.contextualAuthorizationManager.hasAccess(Right.EDIT, documentReference)).thenReturn(true);\n        when(doc.getContentAsString(syntaxId)).thenReturn(content);\n        when(doc.getArtifactsFiles()).thenReturn(Collections.singleton(artifact));\n\n        this.modelBridge.save(doc, documentReference, syntaxId, parentReference, title, false);\n\n        verify(documentAccessBridge).setDocumentSyntaxId(documentReference, syntaxId);\n        verify(documentAccessBridge).setDocumentContent(documentReference, content, \"Created by office importer.\",\n            false);\n        verify(documentAccessBridge).setDocumentParentReference(documentReference, parentReference);\n        verify(documentAccessBridge).setDocumentTitle(documentReference, title);\n        verify(documentAccessBridge).setAttachmentContent(new AttachmentReference(fileName, documentReference),\n            fileContent);\n    }\n\n    @Test\n    void saveWithAppend() throws Exception\n    {\n        XDOMOfficeDocument doc = mock(XDOMOfficeDocument.class);\n        DocumentReference documentReference = new DocumentReference(\"wiki\", \"Space\", \"Page\");\n        String syntaxId = \"test/1.0\";\n\n        when(this.contextualAuthorizationManager.hasAccess(Right.EDIT, documentReference)).thenReturn(true);\n        when(documentAccessBridge.exists(documentReference)).thenReturn(true);\n\n        DocumentModelBridge document = mock(DocumentModelBridge.class);\n        when(documentAccessBridge.getTranslatedDocumentInstance(documentReference)).thenReturn(document);\n        when(document.getSyntax()).thenReturn(new Syntax(new SyntaxType(\"test\", \"Test\"), \"1.0\"));\n\n        when(documentAccessBridge.getDocumentContent(documentReference, null)).thenReturn(\"before\");\n        when(doc.getContentAsString(syntaxId)).thenReturn(\"after\");\n\n        this.modelBridge.save(doc, documentReference, syntaxId, null, null, true);\n\n        verify(documentAccessBridge).setDocumentContent(documentReference, \"before\\nafter\",\n            \"Updated by office importer.\", false);\n    }\n}\n",
    "code_after_change": "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.officeimporter.internal;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.InputStream;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.apache.commons.io.IOUtils;\nimport org.junit.jupiter.api.Test;\nimport org.xwiki.bridge.DocumentAccessBridge;\nimport org.xwiki.bridge.DocumentModelBridge;\nimport org.xwiki.model.reference.AttachmentReference;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.officeimporter.document.XDOMOfficeDocument;\nimport org.xwiki.officeimporter.internal.document.FileOfficeDocumentArtifact;\nimport org.xwiki.rendering.syntax.Syntax;\nimport org.xwiki.rendering.syntax.SyntaxType;\nimport org.xwiki.security.authorization.ContextualAuthorizationManager;\nimport org.xwiki.security.authorization.Right;\nimport org.xwiki.test.junit5.XWikiTempDir;\nimport org.xwiki.test.junit5.mockito.ComponentTest;\nimport org.xwiki.test.junit5.mockito.InjectMockComponents;\nimport org.xwiki.test.junit5.mockito.MockComponent;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.Mockito.doAnswer;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\n/**\n * Unit test for {@link ModelBridge}.\n * \n * @version $Id$\n */\n@ComponentTest\nclass ModelBridgeTest\n{\n    @InjectMockComponents\n    private ModelBridge modelBridge;\n\n    @MockComponent\n    private DocumentAccessBridge documentAccessBridge;\n\n    @MockComponent\n    private ContextualAuthorizationManager contextualAuthorizationManager;\n\n    @XWikiTempDir\n    private File tempDir;\n\n    @Test\n    void saveWithOverwrite() throws Exception\n    {\n        XDOMOfficeDocument doc = mock(XDOMOfficeDocument.class);\n        DocumentReference documentReference = new DocumentReference(\"wiki\", \"Space\", \"Page\");\n        DocumentReference parentReference = new DocumentReference(\"wiki\", \"Space\", \"Parent\");\n        String syntaxId = \"test/1.0\";\n        String title = \"Office Document Title\";\n        String content = \"Office Document Content\";\n        String fileName = \"logo.png\";\n        byte[] fileContent = new byte[] {65, 82};\n        File artifact = new File(tempDir, fileName);\n        try (FileOutputStream fos = new FileOutputStream(artifact)) {\n            IOUtils.write(fileContent, fos);\n        }\n\n        when(this.contextualAuthorizationManager.hasAccess(Right.EDIT, documentReference)).thenReturn(true);\n        when(doc.getContentAsString(syntaxId)).thenReturn(content);\n        when(doc.getArtifactsMap())\n            .thenReturn(Collections.singletonMap(fileName, new FileOfficeDocumentArtifact(fileName, artifact)));\n        // Store all attachment contents that are set on the mock.\n        Map<AttachmentReference, byte[]> attachmentContents = new HashMap<>();\n        doAnswer((invocation) -> attachmentContents.put(\n            invocation.getArgument(0, AttachmentReference.class),\n            IOUtils.toByteArray(invocation.getArgument(1, InputStream.class))\n        )).when(this.documentAccessBridge)\n            .setAttachmentContent(any(AttachmentReference.class), any(InputStream.class));\n\n        this.modelBridge.save(doc, documentReference, syntaxId, parentReference, title, false);\n\n        verify(documentAccessBridge).setDocumentSyntaxId(documentReference, syntaxId);\n        verify(documentAccessBridge).setDocumentContent(documentReference, content, \"Created by office importer.\",\n            false);\n        verify(documentAccessBridge).setDocumentParentReference(documentReference, parentReference);\n        verify(documentAccessBridge).setDocumentTitle(documentReference, title);\n        assertEquals(1, attachmentContents.size());\n        AttachmentReference expectedAttachmentReference = new AttachmentReference(fileName, documentReference);\n        assertEquals(expectedAttachmentReference, attachmentContents.keySet().iterator().next());\n        assertArrayEquals(fileContent, attachmentContents.get(expectedAttachmentReference));\n    }\n\n    @Test\n    void saveWithAppend() throws Exception\n    {\n        XDOMOfficeDocument doc = mock(XDOMOfficeDocument.class);\n        DocumentReference documentReference = new DocumentReference(\"wiki\", \"Space\", \"Page\");\n        String syntaxId = \"test/1.0\";\n\n        when(this.contextualAuthorizationManager.hasAccess(Right.EDIT, documentReference)).thenReturn(true);\n        when(documentAccessBridge.exists(documentReference)).thenReturn(true);\n\n        DocumentModelBridge document = mock(DocumentModelBridge.class);\n        when(documentAccessBridge.getTranslatedDocumentInstance(documentReference)).thenReturn(document);\n        when(document.getSyntax()).thenReturn(new Syntax(new SyntaxType(\"test\", \"Test\"), \"1.0\"));\n\n        when(documentAccessBridge.getDocumentContent(documentReference, null)).thenReturn(\"before\");\n        when(doc.getContentAsString(syntaxId)).thenReturn(\"after\");\n\n        this.modelBridge.save(doc, documentReference, syntaxId, null, null, true);\n\n        verify(documentAccessBridge).setDocumentContent(documentReference, \"before\\nafter\",\n            \"Updated by office importer.\", false);\n    }\n}\n",
    "patch": "@@ -21,7 +21,10 @@\n \n import java.io.File;\n import java.io.FileOutputStream;\n+import java.io.InputStream;\n import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n \n import org.apache.commons.io.IOUtils;\n import org.junit.jupiter.api.Test;\n@@ -30,6 +33,7 @@\n import org.xwiki.model.reference.AttachmentReference;\n import org.xwiki.model.reference.DocumentReference;\n import org.xwiki.officeimporter.document.XDOMOfficeDocument;\n+import org.xwiki.officeimporter.internal.document.FileOfficeDocumentArtifact;\n import org.xwiki.rendering.syntax.Syntax;\n import org.xwiki.rendering.syntax.SyntaxType;\n import org.xwiki.security.authorization.ContextualAuthorizationManager;\n@@ -39,6 +43,10 @@\n import org.xwiki.test.junit5.mockito.InjectMockComponents;\n import org.xwiki.test.junit5.mockito.MockComponent;\n \n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.doAnswer;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n@@ -81,7 +89,15 @@ void saveWithOverwrite() throws Exception\n \n         when(this.contextualAuthorizationManager.hasAccess(Right.EDIT, documentReference)).thenReturn(true);\n         when(doc.getContentAsString(syntaxId)).thenReturn(content);\n-        when(doc.getArtifactsFiles()).thenReturn(Collections.singleton(artifact));\n+        when(doc.getArtifactsMap())\n+            .thenReturn(Collections.singletonMap(fileName, new FileOfficeDocumentArtifact(fileName, artifact)));\n+        // Store all attachment contents that are set on the mock.\n+        Map<AttachmentReference, byte[]> attachmentContents = new HashMap<>();\n+        doAnswer((invocation) -> attachmentContents.put(\n+            invocation.getArgument(0, AttachmentReference.class),\n+            IOUtils.toByteArray(invocation.getArgument(1, InputStream.class))\n+        )).when(this.documentAccessBridge)\n+            .setAttachmentContent(any(AttachmentReference.class), any(InputStream.class));\n \n         this.modelBridge.save(doc, documentReference, syntaxId, parentReference, title, false);\n \n@@ -90,8 +106,10 @@ void saveWithOverwrite() throws Exception\n             false);\n         verify(documentAccessBridge).setDocumentParentReference(documentReference, parentReference);\n         verify(documentAccessBridge).setDocumentTitle(documentReference, title);\n-        verify(documentAccessBridge).setAttachmentContent(new AttachmentReference(fileName, documentReference),\n-            fileContent);\n+        assertEquals(1, attachmentContents.size());\n+        AttachmentReference expectedAttachmentReference = new AttachmentReference(fileName, documentReference);\n+        assertEquals(expectedAttachmentReference, attachmentContents.keySet().iterator().next());\n+        assertArrayEquals(fileContent, attachmentContents.get(expectedAttachmentReference));\n     }\n \n     @Test",
    "function_modified_lines": {
      "added": [
        "import java.io.InputStream;\n",
        "import java.util.HashMap;\n",
        "import java.util.Map;\n",
        "import org.xwiki.officeimporter.internal.document.FileOfficeDocumentArtifact;\n",
        "import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n",
        "import static org.junit.jupiter.api.Assertions.assertEquals;\n",
        "import static org.mockito.ArgumentMatchers.any;\n",
        "import static org.mockito.Mockito.doAnswer;\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "XWiki Platform is a generic wiki platform offering runtime services for applications built on top of it. Starting in version 3.5-milestone-1 and prior to versions 14.10.8 and 15.3-rc-1, triggering the office converter with a specially crafted file name allows writing the attachment's content to an attacker-controlled location on the server as long as the Java process has write access to that location. In particular in the combination with attachment moving, a feature introduced in XWiki 14.0, this is easy to reproduce but it also possible to reproduce in versions as old as XWiki 3.5 by uploading the attachment through the REST API which doesn't remove `/` or `\\` from the filename. As the mime type of the attachment doesn't matter for the exploitation, this could e.g., be used to replace the `jar`-file of an extension which would allow executing arbitrary Java code and thus impact the confidentiality, integrity and availability of the XWiki installation. This vulnerability has been patched in XWiki 14.10.8 and 15.3RC1. There are no known workarounds apart from disabling the office converter.",
    "id": 12406
  },
  {
    "cve_id": "CVE-2023-37913",
    "code_before_change": "{\n        XDOMOfficeDocument doc = mock(XDOMOfficeDocument.class);\n        DocumentReference documentReference = new DocumentReference(\"wiki\", \"Space\", \"Page\");\n        DocumentReference parentReference = new DocumentReference(\"wiki\", \"Space\", \"Parent\");\n        String syntaxId = \"test/1.0\";\n        String title = \"Office Document Title\";\n        String content = \"Office Document Content\";\n        String fileName = \"logo.png\";\n        byte[] fileContent = new byte[] {65, 82};\n        File artifact = new File(tempDir, fileName);\n        try (FileOutputStream fos = new FileOutputStream(artifact)) {\n            IOUtils.write(fileContent, fos);\n        }\n\n        when(this.contextualAuthorizationManager.hasAccess(Right.EDIT, documentReference)).thenReturn(true);\n        when(doc.getContentAsString(syntaxId)).thenReturn(content);\n        when(doc.getArtifactsFiles()).thenReturn(Collections.singleton(artifact));\n\n        this.modelBridge.save(doc, documentReference, syntaxId, parentReference, title, false);\n\n        verify(documentAccessBridge).setDocumentSyntaxId(documentReference, syntaxId);\n        verify(documentAccessBridge).setDocumentContent(documentReference, content, \"Created by office importer.\",\n            false);\n        verify(documentAccessBridge).setDocumentParentReference(documentReference, parentReference);\n        verify(documentAccessBridge).setDocumentTitle(documentReference, title);\n        verify(documentAccessBridge).setAttachmentContent(new AttachmentReference(fileName, documentReference),\n            fileContent);\n    }",
    "code_after_change": "{\n        XDOMOfficeDocument doc = mock(XDOMOfficeDocument.class);\n        DocumentReference documentReference = new DocumentReference(\"wiki\", \"Space\", \"Page\");\n        DocumentReference parentReference = new DocumentReference(\"wiki\", \"Space\", \"Parent\");\n        String syntaxId = \"test/1.0\";\n        String title = \"Office Document Title\";\n        String content = \"Office Document Content\";\n        String fileName = \"logo.png\";\n        byte[] fileContent = new byte[] {65, 82};\n        File artifact = new File(tempDir, fileName);\n        try (FileOutputStream fos = new FileOutputStream(artifact)) {\n            IOUtils.write(fileContent, fos);\n        }\n\n        when(this.contextualAuthorizationManager.hasAccess(Right.EDIT, documentReference)).thenReturn(true);\n        when(doc.getContentAsString(syntaxId)).thenReturn(content);\n        when(doc.getArtifactsMap())\n            .thenReturn(Collections.singletonMap(fileName, new FileOfficeDocumentArtifact(fileName, artifact)));\n        // Store all attachment contents that are set on the mock.\n        Map<AttachmentReference, byte[]> attachmentContents = new HashMap<>();\n        doAnswer((invocation) -> attachmentContents.put(\n            invocation.getArgument(0, AttachmentReference.class),\n            IOUtils.toByteArray(invocation.getArgument(1, InputStream.class))\n        )).when(this.documentAccessBridge)\n            .setAttachmentContent(any(AttachmentReference.class), any(InputStream.class));\n\n        this.modelBridge.save(doc, documentReference, syntaxId, parentReference, title, false);\n\n        verify(documentAccessBridge).setDocumentSyntaxId(documentReference, syntaxId);\n        verify(documentAccessBridge).setDocumentContent(documentReference, content, \"Created by office importer.\",\n            false);\n        verify(documentAccessBridge).setDocumentParentReference(documentReference, parentReference);\n        verify(documentAccessBridge).setDocumentTitle(documentReference, title);\n        assertEquals(1, attachmentContents.size());\n        AttachmentReference expectedAttachmentReference = new AttachmentReference(fileName, documentReference);\n        assertEquals(expectedAttachmentReference, attachmentContents.keySet().iterator().next());\n        assertArrayEquals(fileContent, attachmentContents.get(expectedAttachmentReference));\n    }",
    "patch": "@@ -21,7 +21,10 @@\n \n import java.io.File;\n import java.io.FileOutputStream;\n+import java.io.InputStream;\n import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n \n import org.apache.commons.io.IOUtils;\n import org.junit.jupiter.api.Test;\n@@ -30,6 +33,7 @@\n import org.xwiki.model.reference.AttachmentReference;\n import org.xwiki.model.reference.DocumentReference;\n import org.xwiki.officeimporter.document.XDOMOfficeDocument;\n+import org.xwiki.officeimporter.internal.document.FileOfficeDocumentArtifact;\n import org.xwiki.rendering.syntax.Syntax;\n import org.xwiki.rendering.syntax.SyntaxType;\n import org.xwiki.security.authorization.ContextualAuthorizationManager;\n@@ -39,6 +43,10 @@\n import org.xwiki.test.junit5.mockito.InjectMockComponents;\n import org.xwiki.test.junit5.mockito.MockComponent;\n \n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.doAnswer;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n@@ -81,7 +89,15 @@ void saveWithOverwrite() throws Exception\n \n         when(this.contextualAuthorizationManager.hasAccess(Right.EDIT, documentReference)).thenReturn(true);\n         when(doc.getContentAsString(syntaxId)).thenReturn(content);\n-        when(doc.getArtifactsFiles()).thenReturn(Collections.singleton(artifact));\n+        when(doc.getArtifactsMap())\n+            .thenReturn(Collections.singletonMap(fileName, new FileOfficeDocumentArtifact(fileName, artifact)));\n+        // Store all attachment contents that are set on the mock.\n+        Map<AttachmentReference, byte[]> attachmentContents = new HashMap<>();\n+        doAnswer((invocation) -> attachmentContents.put(\n+            invocation.getArgument(0, AttachmentReference.class),\n+            IOUtils.toByteArray(invocation.getArgument(1, InputStream.class))\n+        )).when(this.documentAccessBridge)\n+            .setAttachmentContent(any(AttachmentReference.class), any(InputStream.class));\n \n         this.modelBridge.save(doc, documentReference, syntaxId, parentReference, title, false);\n \n@@ -90,8 +106,10 @@ void saveWithOverwrite() throws Exception\n             false);\n         verify(documentAccessBridge).setDocumentParentReference(documentReference, parentReference);\n         verify(documentAccessBridge).setDocumentTitle(documentReference, title);\n-        verify(documentAccessBridge).setAttachmentContent(new AttachmentReference(fileName, documentReference),\n-            fileContent);\n+        assertEquals(1, attachmentContents.size());\n+        AttachmentReference expectedAttachmentReference = new AttachmentReference(fileName, documentReference);\n+        assertEquals(expectedAttachmentReference, attachmentContents.keySet().iterator().next());\n+        assertArrayEquals(fileContent, attachmentContents.get(expectedAttachmentReference));\n     }\n \n     @Test",
    "function_modified_lines": {
      "added": [
        "        when(doc.getArtifactsMap())\n",
        "            .thenReturn(Collections.singletonMap(fileName, new FileOfficeDocumentArtifact(fileName, artifact)));\n",
        "        // Store all attachment contents that are set on the mock.\n",
        "        Map<AttachmentReference, byte[]> attachmentContents = new HashMap<>();\n",
        "        doAnswer((invocation) -> attachmentContents.put(\n",
        "            invocation.getArgument(0, AttachmentReference.class),\n",
        "            IOUtils.toByteArray(invocation.getArgument(1, InputStream.class))\n",
        "        )).when(this.documentAccessBridge)\n",
        "            .setAttachmentContent(any(AttachmentReference.class), any(InputStream.class));\n",
        "        assertEquals(1, attachmentContents.size());\n",
        "        AttachmentReference expectedAttachmentReference = new AttachmentReference(fileName, documentReference);\n",
        "        assertEquals(expectedAttachmentReference, attachmentContents.keySet().iterator().next());\n",
        "        assertArrayEquals(fileContent, attachmentContents.get(expectedAttachmentReference));\n"
      ],
      "deleted": [
        "        when(doc.getArtifactsFiles()).thenReturn(Collections.singleton(artifact));\n",
        "        verify(documentAccessBridge).setAttachmentContent(new AttachmentReference(fileName, documentReference),\n",
        "            fileContent);\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "XWiki Platform is a generic wiki platform offering runtime services for applications built on top of it. Starting in version 3.5-milestone-1 and prior to versions 14.10.8 and 15.3-rc-1, triggering the office converter with a specially crafted file name allows writing the attachment's content to an attacker-controlled location on the server as long as the Java process has write access to that location. In particular in the combination with attachment moving, a feature introduced in XWiki 14.0, this is easy to reproduce but it also possible to reproduce in versions as old as XWiki 3.5 by uploading the attachment through the REST API which doesn't remove `/` or `\\` from the filename. As the mime type of the attachment doesn't matter for the exploitation, this could e.g., be used to replace the `jar`-file of an extension which would allow executing arbitrary Java code and thus impact the confidentiality, integrity and availability of the XWiki installation. This vulnerability has been patched in XWiki 14.10.8 and 15.3RC1. There are no known workarounds apart from disabling the office converter.",
    "id": 12407
  },
  {
    "cve_id": "CVE-2023-37913",
    "code_before_change": "@Test\n    public void xdomOfficeDocumentBuilding() throws Exception\n    {\n        // Create & register a mock document converter to by-pass the office server.\n        final InputStream mockOfficeFileStream = new ByteArrayInputStream(new byte[1024]);\n        final Map<String, InputStream> mockInput = new HashMap<String, InputStream>();\n        mockInput.put(INPUT_FILE_NAME, mockOfficeFileStream);\n        OfficeConverterResult converterResult = mock(OfficeConverterResult.class);\n        when(converterResult.getOutputDirectory()).thenReturn(this.outputDirectory);\n        File outputFile = new File(this.outputDirectory, OUTPUT_FILE_NAME);\n        when(converterResult.getOutputFile()).thenReturn(outputFile);\n        Files.createFile(outputFile.toPath());\n        try (FileOutputStream fos = new FileOutputStream(outputFile)) {\n            IOUtils.write(\n                \"<html><head><title></tile></head><body><p><strong>Hello There</strong></p></body></html>\".getBytes(),\n                fos);\n        }\n\n        final OfficeConverter mockDocumentConverter = mock(OfficeConverter.class);\n        final DocumentReference documentReference = new DocumentReference(\"xwiki\", \"Main\", \"Test\");\n\n        when(mockOfficeServer.getConverter()).thenReturn(mockDocumentConverter);\n        when(mockDocumentConverter.convertDocument(mockInput, INPUT_FILE_NAME, OUTPUT_FILE_NAME))\n            .thenReturn(converterResult);\n        when(mockDocumentReferenceResolver.resolve(\"xwiki:Main.Test\")).thenReturn(documentReference);\n        when(mockDefaultStringEntityReferenceSerializer.serialize(documentReference)).thenReturn(\"xwiki:Main.Test\");\n\n        XDOMOfficeDocument document =\n            xdomOfficeDocumentBuilder.build(mockOfficeFileStream, INPUT_FILE_NAME, documentReference, true);\n        assertEquals(\"xwiki:Main.Test\", document.getContentDocument().getMetaData().getMetaData(MetaData.BASE));\n        assertEquals(\"**Hello There**\", document.getContentAsString());\n        assertEquals(0, document.getArtifactsFiles().size());\n\n        verify(mockOfficeServer).getConverter();\n    }",
    "code_after_change": "@Test\n    void xdomOfficeDocumentBuilding() throws Exception\n    {\n        // Create & register a mock document converter to by-pass the office server.\n        final InputStream mockOfficeFileStream = new ByteArrayInputStream(new byte[1024]);\n        final Map<String, InputStream> mockInput = new HashMap<>();\n        String internalInputFilename = \"input.doc\";\n        mockInput.put(internalInputFilename, mockOfficeFileStream);\n        OfficeConverterResult converterResult = mock(OfficeConverterResult.class);\n        when(converterResult.getOutputDirectory()).thenReturn(this.outputDirectory);\n        File outputFile = new File(this.outputDirectory, OUTPUT_FILE_NAME);\n        when(converterResult.getOutputFile()).thenReturn(outputFile);\n        Files.createFile(outputFile.toPath());\n        try (FileOutputStream fos = new FileOutputStream(outputFile)) {\n            IOUtils.write(\n                \"<html><head><title></tile></head><body><p><strong>Hello There</strong></p></body></html>\".getBytes(),\n                fos);\n        }\n\n        final OfficeConverter mockDocumentConverter = mock(OfficeConverter.class);\n        final DocumentReference documentReference = new DocumentReference(\"xwiki\", \"Main\", \"Test\");\n\n        when(mockOfficeServer.getConverter()).thenReturn(mockDocumentConverter);\n        when(mockDocumentConverter.convertDocument(mockInput, internalInputFilename, \"output.html\"))\n            .thenReturn(converterResult);\n        when(mockDocumentReferenceResolver.resolve(\"xwiki:Main.Test\")).thenReturn(documentReference);\n        when(mockDefaultStringEntityReferenceSerializer.serialize(documentReference)).thenReturn(\"xwiki:Main.Test\");\n\n        XDOMOfficeDocument document =\n            xdomOfficeDocumentBuilder.build(mockOfficeFileStream, INPUT_FILE_NAME, documentReference, true);\n        assertEquals(\"xwiki:Main.Test\", document.getContentDocument().getMetaData().getMetaData(MetaData.BASE));\n        assertEquals(\"**Hello There**\", document.getContentAsString());\n        assertEquals(0, document.getArtifactsMap().size());\n\n        verify(mockOfficeServer).getConverter();\n    }",
    "patch": "@@ -57,7 +57,7 @@\n  * @since 2.1M1\n  */\n @ComponentTest\n-public class DefaultXDOMOfficeDocumentBuilderTest extends AbstractOfficeImporterTest\n+class DefaultXDOMOfficeDocumentBuilderTest extends AbstractOfficeImporterTest\n {\n     /**\n      * The name of an input file to be used in tests.\n@@ -91,12 +91,13 @@ public void setUp() throws Exception\n      * Test {@link OfficeDocument} building.\n      */\n     @Test\n-    public void xdomOfficeDocumentBuilding() throws Exception\n+    void xdomOfficeDocumentBuilding() throws Exception\n     {\n         // Create & register a mock document converter to by-pass the office server.\n         final InputStream mockOfficeFileStream = new ByteArrayInputStream(new byte[1024]);\n-        final Map<String, InputStream> mockInput = new HashMap<String, InputStream>();\n-        mockInput.put(INPUT_FILE_NAME, mockOfficeFileStream);\n+        final Map<String, InputStream> mockInput = new HashMap<>();\n+        String internalInputFilename = \"input.doc\";\n+        mockInput.put(internalInputFilename, mockOfficeFileStream);\n         OfficeConverterResult converterResult = mock(OfficeConverterResult.class);\n         when(converterResult.getOutputDirectory()).thenReturn(this.outputDirectory);\n         File outputFile = new File(this.outputDirectory, OUTPUT_FILE_NAME);\n@@ -112,7 +113,7 @@ public void xdomOfficeDocumentBuilding() throws Exception\n         final DocumentReference documentReference = new DocumentReference(\"xwiki\", \"Main\", \"Test\");\n \n         when(mockOfficeServer.getConverter()).thenReturn(mockDocumentConverter);\n-        when(mockDocumentConverter.convertDocument(mockInput, INPUT_FILE_NAME, OUTPUT_FILE_NAME))\n+        when(mockDocumentConverter.convertDocument(mockInput, internalInputFilename, \"output.html\"))\n             .thenReturn(converterResult);\n         when(mockDocumentReferenceResolver.resolve(\"xwiki:Main.Test\")).thenReturn(documentReference);\n         when(mockDefaultStringEntityReferenceSerializer.serialize(documentReference)).thenReturn(\"xwiki:Main.Test\");\n@@ -121,7 +122,7 @@ public void xdomOfficeDocumentBuilding() throws Exception\n             xdomOfficeDocumentBuilder.build(mockOfficeFileStream, INPUT_FILE_NAME, documentReference, true);\n         assertEquals(\"xwiki:Main.Test\", document.getContentDocument().getMetaData().getMetaData(MetaData.BASE));\n         assertEquals(\"**Hello There**\", document.getContentAsString());\n-        assertEquals(0, document.getArtifactsFiles().size());\n+        assertEquals(0, document.getArtifactsMap().size());\n \n         verify(mockOfficeServer).getConverter();\n     }",
    "function_modified_lines": {
      "added": [
        "    void xdomOfficeDocumentBuilding() throws Exception\n",
        "        final Map<String, InputStream> mockInput = new HashMap<>();\n",
        "        String internalInputFilename = \"input.doc\";\n",
        "        mockInput.put(internalInputFilename, mockOfficeFileStream);\n"
      ],
      "deleted": [
        "    public void xdomOfficeDocumentBuilding() throws Exception\n",
        "        final Map<String, InputStream> mockInput = new HashMap<String, InputStream>();\n",
        "        mockInput.put(INPUT_FILE_NAME, mockOfficeFileStream);\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "XWiki Platform is a generic wiki platform offering runtime services for applications built on top of it. Starting in version 3.5-milestone-1 and prior to versions 14.10.8 and 15.3-rc-1, triggering the office converter with a specially crafted file name allows writing the attachment's content to an attacker-controlled location on the server as long as the Java process has write access to that location. In particular in the combination with attachment moving, a feature introduced in XWiki 14.0, this is easy to reproduce but it also possible to reproduce in versions as old as XWiki 3.5 by uploading the attachment through the REST API which doesn't remove `/` or `\\` from the filename. As the mime type of the attachment doesn't matter for the exploitation, this could e.g., be used to replace the `jar`-file of an extension which would allow executing arbitrary Java code and thus impact the confidentiality, integrity and availability of the XWiki installation. This vulnerability has been patched in XWiki 14.10.8 and 15.3RC1. There are no known workarounds apart from disabling the office converter.",
    "id": 12408
  },
  {
    "cve_id": "CVE-2023-37913",
    "code_before_change": "{\n        // Create & register a mock document converter to by-pass the office server.\n        final InputStream mockOfficeFileStream = new ByteArrayInputStream(new byte[1024]);\n        final Map<String, InputStream> mockInput = new HashMap<String, InputStream>();\n        mockInput.put(INPUT_FILE_NAME, mockOfficeFileStream);\n        OfficeConverterResult converterResult = mock(OfficeConverterResult.class);\n        when(converterResult.getOutputDirectory()).thenReturn(this.outputDirectory);\n        File outputFile = new File(this.outputDirectory, OUTPUT_FILE_NAME);\n        when(converterResult.getOutputFile()).thenReturn(outputFile);\n        Files.createFile(outputFile.toPath());\n        try (FileOutputStream fos = new FileOutputStream(outputFile)) {\n            IOUtils.write(\n                \"<html><head><title></tile></head><body><p><strong>Hello There</strong></p></body></html>\".getBytes(),\n                fos);\n        }\n\n        final OfficeConverter mockDocumentConverter = mock(OfficeConverter.class);\n        final DocumentReference documentReference = new DocumentReference(\"xwiki\", \"Main\", \"Test\");\n\n        when(mockOfficeServer.getConverter()).thenReturn(mockDocumentConverter);\n        when(mockDocumentConverter.convertDocument(mockInput, INPUT_FILE_NAME, OUTPUT_FILE_NAME))\n            .thenReturn(converterResult);\n        when(mockDocumentReferenceResolver.resolve(\"xwiki:Main.Test\")).thenReturn(documentReference);\n        when(mockDefaultStringEntityReferenceSerializer.serialize(documentReference)).thenReturn(\"xwiki:Main.Test\");\n\n        XDOMOfficeDocument document =\n            xdomOfficeDocumentBuilder.build(mockOfficeFileStream, INPUT_FILE_NAME, documentReference, true);\n        assertEquals(\"xwiki:Main.Test\", document.getContentDocument().getMetaData().getMetaData(MetaData.BASE));\n        assertEquals(\"**Hello There**\", document.getContentAsString());\n        assertEquals(0, document.getArtifactsFiles().size());\n\n        verify(mockOfficeServer).getConverter();\n    }",
    "code_after_change": "{\n        // Create & register a mock document converter to by-pass the office server.\n        final InputStream mockOfficeFileStream = new ByteArrayInputStream(new byte[1024]);\n        final Map<String, InputStream> mockInput = new HashMap<>();\n        String internalInputFilename = \"input.doc\";\n        mockInput.put(internalInputFilename, mockOfficeFileStream);\n        OfficeConverterResult converterResult = mock(OfficeConverterResult.class);\n        when(converterResult.getOutputDirectory()).thenReturn(this.outputDirectory);\n        File outputFile = new File(this.outputDirectory, OUTPUT_FILE_NAME);\n        when(converterResult.getOutputFile()).thenReturn(outputFile);\n        Files.createFile(outputFile.toPath());\n        try (FileOutputStream fos = new FileOutputStream(outputFile)) {\n            IOUtils.write(\n                \"<html><head><title></tile></head><body><p><strong>Hello There</strong></p></body></html>\".getBytes(),\n                fos);\n        }\n\n        final OfficeConverter mockDocumentConverter = mock(OfficeConverter.class);\n        final DocumentReference documentReference = new DocumentReference(\"xwiki\", \"Main\", \"Test\");\n\n        when(mockOfficeServer.getConverter()).thenReturn(mockDocumentConverter);\n        when(mockDocumentConverter.convertDocument(mockInput, internalInputFilename, \"output.html\"))\n            .thenReturn(converterResult);\n        when(mockDocumentReferenceResolver.resolve(\"xwiki:Main.Test\")).thenReturn(documentReference);\n        when(mockDefaultStringEntityReferenceSerializer.serialize(documentReference)).thenReturn(\"xwiki:Main.Test\");\n\n        XDOMOfficeDocument document =\n            xdomOfficeDocumentBuilder.build(mockOfficeFileStream, INPUT_FILE_NAME, documentReference, true);\n        assertEquals(\"xwiki:Main.Test\", document.getContentDocument().getMetaData().getMetaData(MetaData.BASE));\n        assertEquals(\"**Hello There**\", document.getContentAsString());\n        assertEquals(0, document.getArtifactsMap().size());\n\n        verify(mockOfficeServer).getConverter();\n    }",
    "patch": "@@ -57,7 +57,7 @@\n  * @since 2.1M1\n  */\n @ComponentTest\n-public class DefaultXDOMOfficeDocumentBuilderTest extends AbstractOfficeImporterTest\n+class DefaultXDOMOfficeDocumentBuilderTest extends AbstractOfficeImporterTest\n {\n     /**\n      * The name of an input file to be used in tests.\n@@ -91,12 +91,13 @@ public void setUp() throws Exception\n      * Test {@link OfficeDocument} building.\n      */\n     @Test\n-    public void xdomOfficeDocumentBuilding() throws Exception\n+    void xdomOfficeDocumentBuilding() throws Exception\n     {\n         // Create & register a mock document converter to by-pass the office server.\n         final InputStream mockOfficeFileStream = new ByteArrayInputStream(new byte[1024]);\n-        final Map<String, InputStream> mockInput = new HashMap<String, InputStream>();\n-        mockInput.put(INPUT_FILE_NAME, mockOfficeFileStream);\n+        final Map<String, InputStream> mockInput = new HashMap<>();\n+        String internalInputFilename = \"input.doc\";\n+        mockInput.put(internalInputFilename, mockOfficeFileStream);\n         OfficeConverterResult converterResult = mock(OfficeConverterResult.class);\n         when(converterResult.getOutputDirectory()).thenReturn(this.outputDirectory);\n         File outputFile = new File(this.outputDirectory, OUTPUT_FILE_NAME);\n@@ -112,7 +113,7 @@ public void xdomOfficeDocumentBuilding() throws Exception\n         final DocumentReference documentReference = new DocumentReference(\"xwiki\", \"Main\", \"Test\");\n \n         when(mockOfficeServer.getConverter()).thenReturn(mockDocumentConverter);\n-        when(mockDocumentConverter.convertDocument(mockInput, INPUT_FILE_NAME, OUTPUT_FILE_NAME))\n+        when(mockDocumentConverter.convertDocument(mockInput, internalInputFilename, \"output.html\"))\n             .thenReturn(converterResult);\n         when(mockDocumentReferenceResolver.resolve(\"xwiki:Main.Test\")).thenReturn(documentReference);\n         when(mockDefaultStringEntityReferenceSerializer.serialize(documentReference)).thenReturn(\"xwiki:Main.Test\");\n@@ -121,7 +122,7 @@ public void xdomOfficeDocumentBuilding() throws Exception\n             xdomOfficeDocumentBuilder.build(mockOfficeFileStream, INPUT_FILE_NAME, documentReference, true);\n         assertEquals(\"xwiki:Main.Test\", document.getContentDocument().getMetaData().getMetaData(MetaData.BASE));\n         assertEquals(\"**Hello There**\", document.getContentAsString());\n-        assertEquals(0, document.getArtifactsFiles().size());\n+        assertEquals(0, document.getArtifactsMap().size());\n \n         verify(mockOfficeServer).getConverter();\n     }",
    "function_modified_lines": {
      "added": [
        "        when(mockDocumentConverter.convertDocument(mockInput, internalInputFilename, \"output.html\"))\n",
        "        assertEquals(0, document.getArtifactsMap().size());\n"
      ],
      "deleted": [
        "        when(mockDocumentConverter.convertDocument(mockInput, INPUT_FILE_NAME, OUTPUT_FILE_NAME))\n",
        "        assertEquals(0, document.getArtifactsFiles().size());\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "XWiki Platform is a generic wiki platform offering runtime services for applications built on top of it. Starting in version 3.5-milestone-1 and prior to versions 14.10.8 and 15.3-rc-1, triggering the office converter with a specially crafted file name allows writing the attachment's content to an attacker-controlled location on the server as long as the Java process has write access to that location. In particular in the combination with attachment moving, a feature introduced in XWiki 14.0, this is easy to reproduce but it also possible to reproduce in versions as old as XWiki 3.5 by uploading the attachment through the REST API which doesn't remove `/` or `\\` from the filename. As the mime type of the attachment doesn't matter for the exploitation, this could e.g., be used to replace the `jar`-file of an extension which would allow executing arbitrary Java code and thus impact the confidentiality, integrity and availability of the XWiki installation. This vulnerability has been patched in XWiki 14.10.8 and 15.3RC1. There are no known workarounds apart from disabling the office converter.",
    "id": 12409
  },
  {
    "cve_id": "CVE-2023-37913",
    "code_before_change": "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.officeimporter.internal.builder;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.InputStream;\nimport java.io.Reader;\nimport java.nio.file.Files;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\n\nimport javax.inject.Named;\n\nimport org.apache.commons.io.IOUtils;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.w3c.dom.Document;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.EntityReferenceSerializer;\nimport org.xwiki.officeimporter.converter.OfficeConverter;\nimport org.xwiki.officeimporter.converter.OfficeConverterResult;\nimport org.xwiki.officeimporter.document.XHTMLOfficeDocument;\nimport org.xwiki.officeimporter.server.OfficeServer;\nimport org.xwiki.test.junit5.XWikiTempDir;\nimport org.xwiki.test.junit5.mockito.ComponentTest;\nimport org.xwiki.test.junit5.mockito.InjectMockComponents;\nimport org.xwiki.test.junit5.mockito.MockComponent;\nimport org.xwiki.xml.html.HTMLCleaner;\nimport org.xwiki.xml.html.HTMLCleanerConfiguration;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.mockito.ArgumentMatchers.*;\nimport static org.mockito.Mockito.*;\n\n/**\n * Test case for {@link DefaultXHTMLOfficeDocumentBuilder}.\n *\n * @version $Id$\n * @since 2.1M1\n */\n@ComponentTest\npublic class DefaultXHTMLOfficeDocumentBuilderTest\n{\n    @InjectMockComponents\n    private DefaultXHTMLOfficeDocumentBuilder officeDocumentBuilder;\n\n    @MockComponent\n    private OfficeConverter officeConverter;\n\n    @MockComponent\n    @Named(\"openoffice\")\n    private HTMLCleaner officeHTMLCleaner;\n\n    @MockComponent\n    private EntityReferenceSerializer<String> entityReferenceSerializer;\n\n    @XWikiTempDir\n    private File outputDirectory;\n\n    @MockComponent\n    private OfficeServer officeServer;\n\n    @BeforeEach\n    public void configure() throws Exception\n    {\n        when(this.officeServer.getConverter()).thenReturn(this.officeConverter);\n    }\n\n    @Test\n    public void xhtmlOfficeDocumentBuilding() throws Exception\n    {\n        DocumentReference documentReference = new DocumentReference(\"wiki\", Arrays.asList(\"Path\", \"To\"), \"Page\");\n        when(this.entityReferenceSerializer.serialize(documentReference)).thenReturn(\"wiki:Path.To.Page\");\n\n        InputStream officeFileStream = new ByteArrayInputStream(\"office content\".getBytes());\n\n        OfficeConverterResult converterResult = mock(OfficeConverterResult.class);\n        when(converterResult.getOutputDirectory()).thenReturn(this.outputDirectory);\n        File outputFile = new File(this.outputDirectory, \"file.html\");\n        when(converterResult.getOutputFile()).thenReturn(outputFile);\n        Set<File> allFiles = new HashSet<>();\n        allFiles.add(outputFile);\n        File otherArtifact = new File(this.outputDirectory, \"file.txt\");\n        allFiles.add(otherArtifact);\n\n        for (File file : allFiles) {\n            Files.createFile(file.toPath());\n        }\n        try (FileOutputStream fos = new FileOutputStream(outputFile)) {\n            IOUtils.write(\"HTML content\".getBytes(), fos);\n        }\n        when(converterResult.getAllFiles()).thenReturn(allFiles);\n\n        when(this.officeConverter.convertDocument(Collections.singletonMap(\"file.odt\", officeFileStream), \"file.odt\",\n            \"file.html\")).thenReturn(converterResult);\n\n        Map<String, byte[]> embeddedImages = Collections.singletonMap(\"image.png\", \"Image content\".getBytes());\n        Document xhtmlDoc = mock(Document.class);\n        when(xhtmlDoc.getUserData(\"embeddedImages\")).thenReturn(embeddedImages);\n\n        HTMLCleanerConfiguration config = mock(HTMLCleanerConfiguration.class);\n        when(this.officeHTMLCleaner.getDefaultConfiguration()).thenReturn(config);\n        when(this.officeHTMLCleaner.clean(any(Reader.class), eq(config))).thenReturn(xhtmlDoc);\n\n        XHTMLOfficeDocument result =\n            this.officeDocumentBuilder.build(officeFileStream, \"file.odt\", documentReference, true);\n\n        Map<String, String> params = new HashMap<String, String>();\n        params.put(\"targetDocument\", \"wiki:Path.To.Page\");\n        params.put(\"attachEmbeddedImages\", \"true\");\n        params.put(\"filterStyles\", \"strict\");\n        verify(config).setParameters(params);\n\n        assertEquals(xhtmlDoc, result.getContentDocument());\n\n        Set<File> expectedFileArtifacts = new HashSet<>();\n        expectedFileArtifacts.add(otherArtifact);\n        expectedFileArtifacts.add(new File(this.outputDirectory, \"image.png\"));\n        assertEquals(expectedFileArtifacts, result.getArtifactsFiles());\n    }\n}\n",
    "code_after_change": "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.officeimporter.internal.builder;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.InputStream;\nimport java.io.Reader;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\n\nimport javax.inject.Named;\n\nimport org.apache.commons.io.IOUtils;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.w3c.dom.Document;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.EntityReferenceSerializer;\nimport org.xwiki.officeimporter.converter.OfficeConverter;\nimport org.xwiki.officeimporter.converter.OfficeConverterResult;\nimport org.xwiki.officeimporter.document.OfficeDocumentArtifact;\nimport org.xwiki.officeimporter.document.XHTMLOfficeDocument;\nimport org.xwiki.officeimporter.server.OfficeServer;\nimport org.xwiki.test.junit5.XWikiTempDir;\nimport org.xwiki.test.junit5.mockito.ComponentTest;\nimport org.xwiki.test.junit5.mockito.InjectMockComponents;\nimport org.xwiki.test.junit5.mockito.MockComponent;\nimport org.xwiki.xml.html.HTMLCleaner;\nimport org.xwiki.xml.html.HTMLCleanerConfiguration;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.ArgumentMatchers.eq;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\n/**\n * Test case for {@link DefaultXHTMLOfficeDocumentBuilder}.\n *\n * @version $Id$\n * @since 2.1M1\n */\n@ComponentTest\nclass DefaultXHTMLOfficeDocumentBuilderTest\n{\n    @InjectMockComponents\n    private DefaultXHTMLOfficeDocumentBuilder officeDocumentBuilder;\n\n    @MockComponent\n    private OfficeConverter officeConverter;\n\n    @MockComponent\n    @Named(\"openoffice\")\n    private HTMLCleaner officeHTMLCleaner;\n\n    @MockComponent\n    private EntityReferenceSerializer<String> entityReferenceSerializer;\n\n    @XWikiTempDir\n    private File outputDirectory;\n\n    @MockComponent\n    private OfficeServer officeServer;\n\n    @BeforeEach\n    public void configure() throws Exception\n    {\n        when(this.officeServer.getConverter()).thenReturn(this.officeConverter);\n    }\n\n    @Test\n    void xhtmlOfficeDocumentBuilding() throws Exception\n    {\n        DocumentReference documentReference = new DocumentReference(\"wiki\", Arrays.asList(\"Path\", \"To\"), \"Page\");\n        when(this.entityReferenceSerializer.serialize(documentReference)).thenReturn(\"wiki:Path.To.Page\");\n\n        InputStream officeFileStream = new ByteArrayInputStream(\"office content\".getBytes());\n\n        OfficeConverterResult converterResult = mock(OfficeConverterResult.class);\n        when(converterResult.getOutputDirectory()).thenReturn(this.outputDirectory);\n        File outputFile = new File(this.outputDirectory, \"file.html\");\n        when(converterResult.getOutputFile()).thenReturn(outputFile);\n        Set<File> allFiles = new HashSet<>();\n        allFiles.add(outputFile);\n        File otherArtifact = new File(this.outputDirectory, \"file.txt\");\n        allFiles.add(otherArtifact);\n\n        for (File file : allFiles) {\n            Files.createFile(file.toPath());\n        }\n        try (FileOutputStream fos = new FileOutputStream(outputFile)) {\n            IOUtils.write(\"HTML content\".getBytes(), fos);\n        }\n        String otherArtifactContent = \"Other content\";\n        try (FileOutputStream fos = new FileOutputStream(otherArtifact)) {\n            IOUtils.write(otherArtifactContent.getBytes(), fos);\n        }\n\n        when(converterResult.getAllFiles()).thenReturn(allFiles);\n\n        when(this.officeConverter.convertDocument(Collections.singletonMap(\"input.odt\", officeFileStream), \"input.odt\",\n            \"output.html\")).thenReturn(converterResult);\n\n        byte[] imageContent = \"Image content\".getBytes();\n        Map<String, byte[]> embeddedImages = Collections.singletonMap(\"image.png\", imageContent);\n        Document xhtmlDoc = mock(Document.class);\n        when(xhtmlDoc.getUserData(\"embeddedImages\")).thenReturn(embeddedImages);\n\n        HTMLCleanerConfiguration config = mock(HTMLCleanerConfiguration.class);\n        when(this.officeHTMLCleaner.getDefaultConfiguration()).thenReturn(config);\n        when(this.officeHTMLCleaner.clean(any(Reader.class), eq(config))).thenReturn(xhtmlDoc);\n\n        XHTMLOfficeDocument result =\n            this.officeDocumentBuilder.build(officeFileStream, \"file.odt\", documentReference, true);\n\n        Map<String, String> params = new HashMap<String, String>();\n        params.put(\"targetDocument\", \"wiki:Path.To.Page\");\n        params.put(\"attachEmbeddedImages\", \"true\");\n        params.put(\"filterStyles\", \"strict\");\n        params.put(\"replaceImagePrefix\", \"output_html_\");\n        params.put(\"replacementImagePrefix\", \"file_\");\n        verify(config).setParameters(params);\n\n        assertEquals(xhtmlDoc, result.getContentDocument());\n\n        Map<String, OfficeDocumentArtifact> actualArtifacts = result.getArtifactsMap();\n        OfficeDocumentArtifact actualOtherArtifact = actualArtifacts.get(\"file.txt\");\n        assertEquals(otherArtifactContent,\n            IOUtils.toString(actualOtherArtifact.getContentInputStream(), StandardCharsets.UTF_8));\n        assertTrue(actualArtifacts.containsKey(\"image.png\"));\n        OfficeDocumentArtifact imageArtifact = actualArtifacts.get(\"image.png\");\n        assertArrayEquals(imageContent, IOUtils.toByteArray(imageArtifact.getContentInputStream()));\n    }\n}\n",
    "patch": "@@ -24,6 +24,7 @@\n import java.io.FileOutputStream;\n import java.io.InputStream;\n import java.io.Reader;\n+import java.nio.charset.StandardCharsets;\n import java.nio.file.Files;\n import java.util.Arrays;\n import java.util.Collections;\n@@ -42,6 +43,7 @@\n import org.xwiki.model.reference.EntityReferenceSerializer;\n import org.xwiki.officeimporter.converter.OfficeConverter;\n import org.xwiki.officeimporter.converter.OfficeConverterResult;\n+import org.xwiki.officeimporter.document.OfficeDocumentArtifact;\n import org.xwiki.officeimporter.document.XHTMLOfficeDocument;\n import org.xwiki.officeimporter.server.OfficeServer;\n import org.xwiki.test.junit5.XWikiTempDir;\n@@ -51,9 +53,14 @@\n import org.xwiki.xml.html.HTMLCleaner;\n import org.xwiki.xml.html.HTMLCleanerConfiguration;\n \n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.mockito.ArgumentMatchers.*;\n-import static org.mockito.Mockito.*;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n \n /**\n  * Test case for {@link DefaultXHTMLOfficeDocumentBuilder}.\n@@ -62,7 +69,7 @@\n  * @since 2.1M1\n  */\n @ComponentTest\n-public class DefaultXHTMLOfficeDocumentBuilderTest\n+class DefaultXHTMLOfficeDocumentBuilderTest\n {\n     @InjectMockComponents\n     private DefaultXHTMLOfficeDocumentBuilder officeDocumentBuilder;\n@@ -90,7 +97,7 @@ public void configure() throws Exception\n     }\n \n     @Test\n-    public void xhtmlOfficeDocumentBuilding() throws Exception\n+    void xhtmlOfficeDocumentBuilding() throws Exception\n     {\n         DocumentReference documentReference = new DocumentReference(\"wiki\", Arrays.asList(\"Path\", \"To\"), \"Page\");\n         when(this.entityReferenceSerializer.serialize(documentReference)).thenReturn(\"wiki:Path.To.Page\");\n@@ -112,12 +119,18 @@ public void xhtmlOfficeDocumentBuilding() throws Exception\n         try (FileOutputStream fos = new FileOutputStream(outputFile)) {\n             IOUtils.write(\"HTML content\".getBytes(), fos);\n         }\n+        String otherArtifactContent = \"Other content\";\n+        try (FileOutputStream fos = new FileOutputStream(otherArtifact)) {\n+            IOUtils.write(otherArtifactContent.getBytes(), fos);\n+        }\n+\n         when(converterResult.getAllFiles()).thenReturn(allFiles);\n \n-        when(this.officeConverter.convertDocument(Collections.singletonMap(\"file.odt\", officeFileStream), \"file.odt\",\n-            \"file.html\")).thenReturn(converterResult);\n+        when(this.officeConverter.convertDocument(Collections.singletonMap(\"input.odt\", officeFileStream), \"input.odt\",\n+            \"output.html\")).thenReturn(converterResult);\n \n-        Map<String, byte[]> embeddedImages = Collections.singletonMap(\"image.png\", \"Image content\".getBytes());\n+        byte[] imageContent = \"Image content\".getBytes();\n+        Map<String, byte[]> embeddedImages = Collections.singletonMap(\"image.png\", imageContent);\n         Document xhtmlDoc = mock(Document.class);\n         when(xhtmlDoc.getUserData(\"embeddedImages\")).thenReturn(embeddedImages);\n \n@@ -132,13 +145,18 @@ public void xhtmlOfficeDocumentBuilding() throws Exception\n         params.put(\"targetDocument\", \"wiki:Path.To.Page\");\n         params.put(\"attachEmbeddedImages\", \"true\");\n         params.put(\"filterStyles\", \"strict\");\n+        params.put(\"replaceImagePrefix\", \"output_html_\");\n+        params.put(\"replacementImagePrefix\", \"file_\");\n         verify(config).setParameters(params);\n \n         assertEquals(xhtmlDoc, result.getContentDocument());\n \n-        Set<File> expectedFileArtifacts = new HashSet<>();\n-        expectedFileArtifacts.add(otherArtifact);\n-        expectedFileArtifacts.add(new File(this.outputDirectory, \"image.png\"));\n-        assertEquals(expectedFileArtifacts, result.getArtifactsFiles());\n+        Map<String, OfficeDocumentArtifact> actualArtifacts = result.getArtifactsMap();\n+        OfficeDocumentArtifact actualOtherArtifact = actualArtifacts.get(\"file.txt\");\n+        assertEquals(otherArtifactContent,\n+            IOUtils.toString(actualOtherArtifact.getContentInputStream(), StandardCharsets.UTF_8));\n+        assertTrue(actualArtifacts.containsKey(\"image.png\"));\n+        OfficeDocumentArtifact imageArtifact = actualArtifacts.get(\"image.png\");\n+        assertArrayEquals(imageContent, IOUtils.toByteArray(imageArtifact.getContentInputStream()));\n     }\n }",
    "function_modified_lines": {
      "added": [
        "import java.nio.charset.StandardCharsets;\n",
        "import org.xwiki.officeimporter.document.OfficeDocumentArtifact;\n",
        "import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n",
        "import static org.junit.jupiter.api.Assertions.assertTrue;\n",
        "import static org.mockito.ArgumentMatchers.any;\n",
        "import static org.mockito.ArgumentMatchers.eq;\n",
        "import static org.mockito.Mockito.mock;\n",
        "import static org.mockito.Mockito.verify;\n",
        "import static org.mockito.Mockito.when;\n",
        "class DefaultXHTMLOfficeDocumentBuilderTest\n"
      ],
      "deleted": [
        "import static org.mockito.ArgumentMatchers.*;\n",
        "import static org.mockito.Mockito.*;\n",
        "public class DefaultXHTMLOfficeDocumentBuilderTest\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "XWiki Platform is a generic wiki platform offering runtime services for applications built on top of it. Starting in version 3.5-milestone-1 and prior to versions 14.10.8 and 15.3-rc-1, triggering the office converter with a specially crafted file name allows writing the attachment's content to an attacker-controlled location on the server as long as the Java process has write access to that location. In particular in the combination with attachment moving, a feature introduced in XWiki 14.0, this is easy to reproduce but it also possible to reproduce in versions as old as XWiki 3.5 by uploading the attachment through the REST API which doesn't remove `/` or `\\` from the filename. As the mime type of the attachment doesn't matter for the exploitation, this could e.g., be used to replace the `jar`-file of an extension which would allow executing arbitrary Java code and thus impact the confidentiality, integrity and availability of the XWiki installation. This vulnerability has been patched in XWiki 14.10.8 and 15.3RC1. There are no known workarounds apart from disabling the office converter.",
    "id": 12410
  },
  {
    "cve_id": "CVE-2023-37913",
    "code_before_change": "{\n        DocumentReference documentReference = new DocumentReference(\"wiki\", Arrays.asList(\"Path\", \"To\"), \"Page\");\n        when(this.entityReferenceSerializer.serialize(documentReference)).thenReturn(\"wiki:Path.To.Page\");\n\n        InputStream officeFileStream = new ByteArrayInputStream(\"office content\".getBytes());\n\n        OfficeConverterResult converterResult = mock(OfficeConverterResult.class);\n        when(converterResult.getOutputDirectory()).thenReturn(this.outputDirectory);\n        File outputFile = new File(this.outputDirectory, \"file.html\");\n        when(converterResult.getOutputFile()).thenReturn(outputFile);\n        Set<File> allFiles = new HashSet<>();\n        allFiles.add(outputFile);\n        File otherArtifact = new File(this.outputDirectory, \"file.txt\");\n        allFiles.add(otherArtifact);\n\n        for (File file : allFiles) {\n            Files.createFile(file.toPath());\n        }\n        try (FileOutputStream fos = new FileOutputStream(outputFile)) {\n            IOUtils.write(\"HTML content\".getBytes(), fos);\n        }\n        when(converterResult.getAllFiles()).thenReturn(allFiles);\n\n        when(this.officeConverter.convertDocument(Collections.singletonMap(\"file.odt\", officeFileStream), \"file.odt\",\n            \"file.html\")).thenReturn(converterResult);\n\n        Map<String, byte[]> embeddedImages = Collections.singletonMap(\"image.png\", \"Image content\".getBytes());\n        Document xhtmlDoc = mock(Document.class);\n        when(xhtmlDoc.getUserData(\"embeddedImages\")).thenReturn(embeddedImages);\n\n        HTMLCleanerConfiguration config = mock(HTMLCleanerConfiguration.class);\n        when(this.officeHTMLCleaner.getDefaultConfiguration()).thenReturn(config);\n        when(this.officeHTMLCleaner.clean(any(Reader.class), eq(config))).thenReturn(xhtmlDoc);\n\n        XHTMLOfficeDocument result =\n            this.officeDocumentBuilder.build(officeFileStream, \"file.odt\", documentReference, true);\n\n        Map<String, String> params = new HashMap<String, String>();\n        params.put(\"targetDocument\", \"wiki:Path.To.Page\");\n        params.put(\"attachEmbeddedImages\", \"true\");\n        params.put(\"filterStyles\", \"strict\");\n        verify(config).setParameters(params);\n\n        assertEquals(xhtmlDoc, result.getContentDocument());\n\n        Set<File> expectedFileArtifacts = new HashSet<>();\n        expectedFileArtifacts.add(otherArtifact);\n        expectedFileArtifacts.add(new File(this.outputDirectory, \"image.png\"));\n        assertEquals(expectedFileArtifacts, result.getArtifactsFiles());\n    }",
    "code_after_change": "{\n        DocumentReference documentReference = new DocumentReference(\"wiki\", Arrays.asList(\"Path\", \"To\"), \"Page\");\n        when(this.entityReferenceSerializer.serialize(documentReference)).thenReturn(\"wiki:Path.To.Page\");\n\n        InputStream officeFileStream = new ByteArrayInputStream(\"office content\".getBytes());\n\n        OfficeConverterResult converterResult = mock(OfficeConverterResult.class);\n        when(converterResult.getOutputDirectory()).thenReturn(this.outputDirectory);\n        File outputFile = new File(this.outputDirectory, \"file.html\");\n        when(converterResult.getOutputFile()).thenReturn(outputFile);\n        Set<File> allFiles = new HashSet<>();\n        allFiles.add(outputFile);\n        File otherArtifact = new File(this.outputDirectory, \"file.txt\");\n        allFiles.add(otherArtifact);\n\n        for (File file : allFiles) {\n            Files.createFile(file.toPath());\n        }\n        try (FileOutputStream fos = new FileOutputStream(outputFile)) {\n            IOUtils.write(\"HTML content\".getBytes(), fos);\n        }\n        String otherArtifactContent = \"Other content\";\n        try (FileOutputStream fos = new FileOutputStream(otherArtifact)) {\n            IOUtils.write(otherArtifactContent.getBytes(), fos);\n        }\n\n        when(converterResult.getAllFiles()).thenReturn(allFiles);\n\n        when(this.officeConverter.convertDocument(Collections.singletonMap(\"input.odt\", officeFileStream), \"input.odt\",\n            \"output.html\")).thenReturn(converterResult);\n\n        byte[] imageContent = \"Image content\".getBytes();\n        Map<String, byte[]> embeddedImages = Collections.singletonMap(\"image.png\", imageContent);\n        Document xhtmlDoc = mock(Document.class);\n        when(xhtmlDoc.getUserData(\"embeddedImages\")).thenReturn(embeddedImages);\n\n        HTMLCleanerConfiguration config = mock(HTMLCleanerConfiguration.class);\n        when(this.officeHTMLCleaner.getDefaultConfiguration()).thenReturn(config);\n        when(this.officeHTMLCleaner.clean(any(Reader.class), eq(config))).thenReturn(xhtmlDoc);\n\n        XHTMLOfficeDocument result =\n            this.officeDocumentBuilder.build(officeFileStream, \"file.odt\", documentReference, true);\n\n        Map<String, String> params = new HashMap<String, String>();\n        params.put(\"targetDocument\", \"wiki:Path.To.Page\");\n        params.put(\"attachEmbeddedImages\", \"true\");\n        params.put(\"filterStyles\", \"strict\");\n        params.put(\"replaceImagePrefix\", \"output_html_\");\n        params.put(\"replacementImagePrefix\", \"file_\");\n        verify(config).setParameters(params);\n\n        assertEquals(xhtmlDoc, result.getContentDocument());\n\n        Map<String, OfficeDocumentArtifact> actualArtifacts = result.getArtifactsMap();\n        OfficeDocumentArtifact actualOtherArtifact = actualArtifacts.get(\"file.txt\");\n        assertEquals(otherArtifactContent,\n            IOUtils.toString(actualOtherArtifact.getContentInputStream(), StandardCharsets.UTF_8));\n        assertTrue(actualArtifacts.containsKey(\"image.png\"));\n        OfficeDocumentArtifact imageArtifact = actualArtifacts.get(\"image.png\");\n        assertArrayEquals(imageContent, IOUtils.toByteArray(imageArtifact.getContentInputStream()));\n    }",
    "patch": "@@ -24,6 +24,7 @@\n import java.io.FileOutputStream;\n import java.io.InputStream;\n import java.io.Reader;\n+import java.nio.charset.StandardCharsets;\n import java.nio.file.Files;\n import java.util.Arrays;\n import java.util.Collections;\n@@ -42,6 +43,7 @@\n import org.xwiki.model.reference.EntityReferenceSerializer;\n import org.xwiki.officeimporter.converter.OfficeConverter;\n import org.xwiki.officeimporter.converter.OfficeConverterResult;\n+import org.xwiki.officeimporter.document.OfficeDocumentArtifact;\n import org.xwiki.officeimporter.document.XHTMLOfficeDocument;\n import org.xwiki.officeimporter.server.OfficeServer;\n import org.xwiki.test.junit5.XWikiTempDir;\n@@ -51,9 +53,14 @@\n import org.xwiki.xml.html.HTMLCleaner;\n import org.xwiki.xml.html.HTMLCleanerConfiguration;\n \n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.mockito.ArgumentMatchers.*;\n-import static org.mockito.Mockito.*;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n \n /**\n  * Test case for {@link DefaultXHTMLOfficeDocumentBuilder}.\n@@ -62,7 +69,7 @@\n  * @since 2.1M1\n  */\n @ComponentTest\n-public class DefaultXHTMLOfficeDocumentBuilderTest\n+class DefaultXHTMLOfficeDocumentBuilderTest\n {\n     @InjectMockComponents\n     private DefaultXHTMLOfficeDocumentBuilder officeDocumentBuilder;\n@@ -90,7 +97,7 @@ public void configure() throws Exception\n     }\n \n     @Test\n-    public void xhtmlOfficeDocumentBuilding() throws Exception\n+    void xhtmlOfficeDocumentBuilding() throws Exception\n     {\n         DocumentReference documentReference = new DocumentReference(\"wiki\", Arrays.asList(\"Path\", \"To\"), \"Page\");\n         when(this.entityReferenceSerializer.serialize(documentReference)).thenReturn(\"wiki:Path.To.Page\");\n@@ -112,12 +119,18 @@ public void xhtmlOfficeDocumentBuilding() throws Exception\n         try (FileOutputStream fos = new FileOutputStream(outputFile)) {\n             IOUtils.write(\"HTML content\".getBytes(), fos);\n         }\n+        String otherArtifactContent = \"Other content\";\n+        try (FileOutputStream fos = new FileOutputStream(otherArtifact)) {\n+            IOUtils.write(otherArtifactContent.getBytes(), fos);\n+        }\n+\n         when(converterResult.getAllFiles()).thenReturn(allFiles);\n \n-        when(this.officeConverter.convertDocument(Collections.singletonMap(\"file.odt\", officeFileStream), \"file.odt\",\n-            \"file.html\")).thenReturn(converterResult);\n+        when(this.officeConverter.convertDocument(Collections.singletonMap(\"input.odt\", officeFileStream), \"input.odt\",\n+            \"output.html\")).thenReturn(converterResult);\n \n-        Map<String, byte[]> embeddedImages = Collections.singletonMap(\"image.png\", \"Image content\".getBytes());\n+        byte[] imageContent = \"Image content\".getBytes();\n+        Map<String, byte[]> embeddedImages = Collections.singletonMap(\"image.png\", imageContent);\n         Document xhtmlDoc = mock(Document.class);\n         when(xhtmlDoc.getUserData(\"embeddedImages\")).thenReturn(embeddedImages);\n \n@@ -132,13 +145,18 @@ public void xhtmlOfficeDocumentBuilding() throws Exception\n         params.put(\"targetDocument\", \"wiki:Path.To.Page\");\n         params.put(\"attachEmbeddedImages\", \"true\");\n         params.put(\"filterStyles\", \"strict\");\n+        params.put(\"replaceImagePrefix\", \"output_html_\");\n+        params.put(\"replacementImagePrefix\", \"file_\");\n         verify(config).setParameters(params);\n \n         assertEquals(xhtmlDoc, result.getContentDocument());\n \n-        Set<File> expectedFileArtifacts = new HashSet<>();\n-        expectedFileArtifacts.add(otherArtifact);\n-        expectedFileArtifacts.add(new File(this.outputDirectory, \"image.png\"));\n-        assertEquals(expectedFileArtifacts, result.getArtifactsFiles());\n+        Map<String, OfficeDocumentArtifact> actualArtifacts = result.getArtifactsMap();\n+        OfficeDocumentArtifact actualOtherArtifact = actualArtifacts.get(\"file.txt\");\n+        assertEquals(otherArtifactContent,\n+            IOUtils.toString(actualOtherArtifact.getContentInputStream(), StandardCharsets.UTF_8));\n+        assertTrue(actualArtifacts.containsKey(\"image.png\"));\n+        OfficeDocumentArtifact imageArtifact = actualArtifacts.get(\"image.png\");\n+        assertArrayEquals(imageContent, IOUtils.toByteArray(imageArtifact.getContentInputStream()));\n     }\n }",
    "function_modified_lines": {
      "added": [
        "        String otherArtifactContent = \"Other content\";\n",
        "        try (FileOutputStream fos = new FileOutputStream(otherArtifact)) {\n",
        "            IOUtils.write(otherArtifactContent.getBytes(), fos);\n",
        "        }\n",
        "\n",
        "        when(this.officeConverter.convertDocument(Collections.singletonMap(\"input.odt\", officeFileStream), \"input.odt\",\n",
        "            \"output.html\")).thenReturn(converterResult);\n",
        "        byte[] imageContent = \"Image content\".getBytes();\n",
        "        Map<String, byte[]> embeddedImages = Collections.singletonMap(\"image.png\", imageContent);\n"
      ],
      "deleted": [
        "        when(this.officeConverter.convertDocument(Collections.singletonMap(\"file.odt\", officeFileStream), \"file.odt\",\n",
        "            \"file.html\")).thenReturn(converterResult);\n",
        "        Map<String, byte[]> embeddedImages = Collections.singletonMap(\"image.png\", \"Image content\".getBytes());\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "XWiki Platform is a generic wiki platform offering runtime services for applications built on top of it. Starting in version 3.5-milestone-1 and prior to versions 14.10.8 and 15.3-rc-1, triggering the office converter with a specially crafted file name allows writing the attachment's content to an attacker-controlled location on the server as long as the Java process has write access to that location. In particular in the combination with attachment moving, a feature introduced in XWiki 14.0, this is easy to reproduce but it also possible to reproduce in versions as old as XWiki 3.5 by uploading the attachment through the REST API which doesn't remove `/` or `\\` from the filename. As the mime type of the attachment doesn't matter for the exploitation, this could e.g., be used to replace the `jar`-file of an extension which would allow executing arbitrary Java code and thus impact the confidentiality, integrity and availability of the XWiki installation. This vulnerability has been patched in XWiki 14.10.8 and 15.3RC1. There are no known workarounds apart from disabling the office converter.",
    "id": 12411
  },
  {
    "cve_id": "CVE-2023-37913",
    "code_before_change": "{\n        DocumentReference documentReference = new DocumentReference(\"wiki\", Arrays.asList(\"Path\", \"To\"), \"Page\");\n        when(this.entityReferenceSerializer.serialize(documentReference)).thenReturn(\"wiki:Path.To.Page\");\n\n        InputStream officeFileStream = new ByteArrayInputStream(\"office content\".getBytes());\n\n        OfficeConverterResult converterResult = mock(OfficeConverterResult.class);\n        when(converterResult.getOutputDirectory()).thenReturn(this.outputDirectory);\n        File outputFile = new File(this.outputDirectory, \"file.html\");\n        when(converterResult.getOutputFile()).thenReturn(outputFile);\n        Set<File> allFiles = new HashSet<>();\n        allFiles.add(outputFile);\n        File otherArtifact = new File(this.outputDirectory, \"file.txt\");\n        allFiles.add(otherArtifact);\n\n        for (File file : allFiles) {\n            Files.createFile(file.toPath());\n        }\n        try (FileOutputStream fos = new FileOutputStream(outputFile)) {\n            IOUtils.write(\"HTML content\".getBytes(), fos);\n        }\n        when(converterResult.getAllFiles()).thenReturn(allFiles);\n\n        when(this.officeConverter.convertDocument(Collections.singletonMap(\"file.odt\", officeFileStream), \"file.odt\",\n            \"file.html\")).thenReturn(converterResult);\n\n        Map<String, byte[]> embeddedImages = Collections.singletonMap(\"image.png\", \"Image content\".getBytes());\n        Document xhtmlDoc = mock(Document.class);\n        when(xhtmlDoc.getUserData(\"embeddedImages\")).thenReturn(embeddedImages);\n\n        HTMLCleanerConfiguration config = mock(HTMLCleanerConfiguration.class);\n        when(this.officeHTMLCleaner.getDefaultConfiguration()).thenReturn(config);\n        when(this.officeHTMLCleaner.clean(any(Reader.class), eq(config))).thenReturn(xhtmlDoc);\n\n        XHTMLOfficeDocument result =\n            this.officeDocumentBuilder.build(officeFileStream, \"file.odt\", documentReference, true);\n\n        Map<String, String> params = new HashMap<String, String>();\n        params.put(\"targetDocument\", \"wiki:Path.To.Page\");\n        params.put(\"attachEmbeddedImages\", \"true\");\n        params.put(\"filterStyles\", \"strict\");\n        verify(config).setParameters(params);\n\n        assertEquals(xhtmlDoc, result.getContentDocument());\n\n        Set<File> expectedFileArtifacts = new HashSet<>();\n        expectedFileArtifacts.add(otherArtifact);\n        expectedFileArtifacts.add(new File(this.outputDirectory, \"image.png\"));\n        assertEquals(expectedFileArtifacts, result.getArtifactsFiles());\n    }",
    "code_after_change": "{\n        DocumentReference documentReference = new DocumentReference(\"wiki\", Arrays.asList(\"Path\", \"To\"), \"Page\");\n        when(this.entityReferenceSerializer.serialize(documentReference)).thenReturn(\"wiki:Path.To.Page\");\n\n        InputStream officeFileStream = new ByteArrayInputStream(\"office content\".getBytes());\n\n        OfficeConverterResult converterResult = mock(OfficeConverterResult.class);\n        when(converterResult.getOutputDirectory()).thenReturn(this.outputDirectory);\n        File outputFile = new File(this.outputDirectory, \"file.html\");\n        when(converterResult.getOutputFile()).thenReturn(outputFile);\n        Set<File> allFiles = new HashSet<>();\n        allFiles.add(outputFile);\n        File otherArtifact = new File(this.outputDirectory, \"file.txt\");\n        allFiles.add(otherArtifact);\n\n        for (File file : allFiles) {\n            Files.createFile(file.toPath());\n        }\n        try (FileOutputStream fos = new FileOutputStream(outputFile)) {\n            IOUtils.write(\"HTML content\".getBytes(), fos);\n        }\n        String otherArtifactContent = \"Other content\";\n        try (FileOutputStream fos = new FileOutputStream(otherArtifact)) {\n            IOUtils.write(otherArtifactContent.getBytes(), fos);\n        }\n\n        when(converterResult.getAllFiles()).thenReturn(allFiles);\n\n        when(this.officeConverter.convertDocument(Collections.singletonMap(\"input.odt\", officeFileStream), \"input.odt\",\n            \"output.html\")).thenReturn(converterResult);\n\n        byte[] imageContent = \"Image content\".getBytes();\n        Map<String, byte[]> embeddedImages = Collections.singletonMap(\"image.png\", imageContent);\n        Document xhtmlDoc = mock(Document.class);\n        when(xhtmlDoc.getUserData(\"embeddedImages\")).thenReturn(embeddedImages);\n\n        HTMLCleanerConfiguration config = mock(HTMLCleanerConfiguration.class);\n        when(this.officeHTMLCleaner.getDefaultConfiguration()).thenReturn(config);\n        when(this.officeHTMLCleaner.clean(any(Reader.class), eq(config))).thenReturn(xhtmlDoc);\n\n        XHTMLOfficeDocument result =\n            this.officeDocumentBuilder.build(officeFileStream, \"file.odt\", documentReference, true);\n\n        Map<String, String> params = new HashMap<String, String>();\n        params.put(\"targetDocument\", \"wiki:Path.To.Page\");\n        params.put(\"attachEmbeddedImages\", \"true\");\n        params.put(\"filterStyles\", \"strict\");\n        params.put(\"replaceImagePrefix\", \"output_html_\");\n        params.put(\"replacementImagePrefix\", \"file_\");\n        verify(config).setParameters(params);\n\n        assertEquals(xhtmlDoc, result.getContentDocument());\n\n        Map<String, OfficeDocumentArtifact> actualArtifacts = result.getArtifactsMap();\n        OfficeDocumentArtifact actualOtherArtifact = actualArtifacts.get(\"file.txt\");\n        assertEquals(otherArtifactContent,\n            IOUtils.toString(actualOtherArtifact.getContentInputStream(), StandardCharsets.UTF_8));\n        assertTrue(actualArtifacts.containsKey(\"image.png\"));\n        OfficeDocumentArtifact imageArtifact = actualArtifacts.get(\"image.png\");\n        assertArrayEquals(imageContent, IOUtils.toByteArray(imageArtifact.getContentInputStream()));\n    }",
    "patch": "@@ -24,6 +24,7 @@\n import java.io.FileOutputStream;\n import java.io.InputStream;\n import java.io.Reader;\n+import java.nio.charset.StandardCharsets;\n import java.nio.file.Files;\n import java.util.Arrays;\n import java.util.Collections;\n@@ -42,6 +43,7 @@\n import org.xwiki.model.reference.EntityReferenceSerializer;\n import org.xwiki.officeimporter.converter.OfficeConverter;\n import org.xwiki.officeimporter.converter.OfficeConverterResult;\n+import org.xwiki.officeimporter.document.OfficeDocumentArtifact;\n import org.xwiki.officeimporter.document.XHTMLOfficeDocument;\n import org.xwiki.officeimporter.server.OfficeServer;\n import org.xwiki.test.junit5.XWikiTempDir;\n@@ -51,9 +53,14 @@\n import org.xwiki.xml.html.HTMLCleaner;\n import org.xwiki.xml.html.HTMLCleanerConfiguration;\n \n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.mockito.ArgumentMatchers.*;\n-import static org.mockito.Mockito.*;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n \n /**\n  * Test case for {@link DefaultXHTMLOfficeDocumentBuilder}.\n@@ -62,7 +69,7 @@\n  * @since 2.1M1\n  */\n @ComponentTest\n-public class DefaultXHTMLOfficeDocumentBuilderTest\n+class DefaultXHTMLOfficeDocumentBuilderTest\n {\n     @InjectMockComponents\n     private DefaultXHTMLOfficeDocumentBuilder officeDocumentBuilder;\n@@ -90,7 +97,7 @@ public void configure() throws Exception\n     }\n \n     @Test\n-    public void xhtmlOfficeDocumentBuilding() throws Exception\n+    void xhtmlOfficeDocumentBuilding() throws Exception\n     {\n         DocumentReference documentReference = new DocumentReference(\"wiki\", Arrays.asList(\"Path\", \"To\"), \"Page\");\n         when(this.entityReferenceSerializer.serialize(documentReference)).thenReturn(\"wiki:Path.To.Page\");\n@@ -112,12 +119,18 @@ public void xhtmlOfficeDocumentBuilding() throws Exception\n         try (FileOutputStream fos = new FileOutputStream(outputFile)) {\n             IOUtils.write(\"HTML content\".getBytes(), fos);\n         }\n+        String otherArtifactContent = \"Other content\";\n+        try (FileOutputStream fos = new FileOutputStream(otherArtifact)) {\n+            IOUtils.write(otherArtifactContent.getBytes(), fos);\n+        }\n+\n         when(converterResult.getAllFiles()).thenReturn(allFiles);\n \n-        when(this.officeConverter.convertDocument(Collections.singletonMap(\"file.odt\", officeFileStream), \"file.odt\",\n-            \"file.html\")).thenReturn(converterResult);\n+        when(this.officeConverter.convertDocument(Collections.singletonMap(\"input.odt\", officeFileStream), \"input.odt\",\n+            \"output.html\")).thenReturn(converterResult);\n \n-        Map<String, byte[]> embeddedImages = Collections.singletonMap(\"image.png\", \"Image content\".getBytes());\n+        byte[] imageContent = \"Image content\".getBytes();\n+        Map<String, byte[]> embeddedImages = Collections.singletonMap(\"image.png\", imageContent);\n         Document xhtmlDoc = mock(Document.class);\n         when(xhtmlDoc.getUserData(\"embeddedImages\")).thenReturn(embeddedImages);\n \n@@ -132,13 +145,18 @@ public void xhtmlOfficeDocumentBuilding() throws Exception\n         params.put(\"targetDocument\", \"wiki:Path.To.Page\");\n         params.put(\"attachEmbeddedImages\", \"true\");\n         params.put(\"filterStyles\", \"strict\");\n+        params.put(\"replaceImagePrefix\", \"output_html_\");\n+        params.put(\"replacementImagePrefix\", \"file_\");\n         verify(config).setParameters(params);\n \n         assertEquals(xhtmlDoc, result.getContentDocument());\n \n-        Set<File> expectedFileArtifacts = new HashSet<>();\n-        expectedFileArtifacts.add(otherArtifact);\n-        expectedFileArtifacts.add(new File(this.outputDirectory, \"image.png\"));\n-        assertEquals(expectedFileArtifacts, result.getArtifactsFiles());\n+        Map<String, OfficeDocumentArtifact> actualArtifacts = result.getArtifactsMap();\n+        OfficeDocumentArtifact actualOtherArtifact = actualArtifacts.get(\"file.txt\");\n+        assertEquals(otherArtifactContent,\n+            IOUtils.toString(actualOtherArtifact.getContentInputStream(), StandardCharsets.UTF_8));\n+        assertTrue(actualArtifacts.containsKey(\"image.png\"));\n+        OfficeDocumentArtifact imageArtifact = actualArtifacts.get(\"image.png\");\n+        assertArrayEquals(imageContent, IOUtils.toByteArray(imageArtifact.getContentInputStream()));\n     }\n }",
    "function_modified_lines": {
      "added": [
        "        params.put(\"replaceImagePrefix\", \"output_html_\");\n",
        "        params.put(\"replacementImagePrefix\", \"file_\");\n",
        "        Map<String, OfficeDocumentArtifact> actualArtifacts = result.getArtifactsMap();\n",
        "        OfficeDocumentArtifact actualOtherArtifact = actualArtifacts.get(\"file.txt\");\n",
        "        assertEquals(otherArtifactContent,\n",
        "            IOUtils.toString(actualOtherArtifact.getContentInputStream(), StandardCharsets.UTF_8));\n",
        "        assertTrue(actualArtifacts.containsKey(\"image.png\"));\n",
        "        OfficeDocumentArtifact imageArtifact = actualArtifacts.get(\"image.png\");\n",
        "        assertArrayEquals(imageContent, IOUtils.toByteArray(imageArtifact.getContentInputStream()));\n"
      ],
      "deleted": [
        "        Set<File> expectedFileArtifacts = new HashSet<>();\n",
        "        expectedFileArtifacts.add(otherArtifact);\n",
        "        expectedFileArtifacts.add(new File(this.outputDirectory, \"image.png\"));\n",
        "        assertEquals(expectedFileArtifacts, result.getArtifactsFiles());\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "XWiki Platform is a generic wiki platform offering runtime services for applications built on top of it. Starting in version 3.5-milestone-1 and prior to versions 14.10.8 and 15.3-rc-1, triggering the office converter with a specially crafted file name allows writing the attachment's content to an attacker-controlled location on the server as long as the Java process has write access to that location. In particular in the combination with attachment moving, a feature introduced in XWiki 14.0, this is easy to reproduce but it also possible to reproduce in versions as old as XWiki 3.5 by uploading the attachment through the REST API which doesn't remove `/` or `\\` from the filename. As the mime type of the attachment doesn't matter for the exploitation, this could e.g., be used to replace the `jar`-file of an extension which would allow executing arbitrary Java code and thus impact the confidentiality, integrity and availability of the XWiki installation. This vulnerability has been patched in XWiki 14.10.8 and 15.3RC1. There are no known workarounds apart from disabling the office converter.",
    "id": 12412
  },
  {
    "cve_id": "CVE-2023-37913",
    "code_before_change": "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.officeimporter.internal.filter;\n\nimport java.io.UnsupportedEncodingException;\nimport java.net.URLEncoder;\nimport java.nio.charset.Charset;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\n\nimport javax.inject.Named;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.w3c.dom.Document;\nimport org.xwiki.bridge.DocumentAccessBridge;\nimport org.xwiki.model.reference.AttachmentReference;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.rendering.listener.reference.ResourceReference;\nimport org.xwiki.rendering.listener.reference.ResourceType;\nimport org.xwiki.rendering.renderer.reference.ResourceReferenceSerializer;\nimport org.xwiki.test.junit5.mockito.ComponentTest;\nimport org.xwiki.test.junit5.mockito.MockComponent;\n\nimport com.github.ooxi.jdatauri.DataUri;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.mockito.Mockito.*;\n\n/**\n * Unit tests for {@link ImageFilter}.\n * \n * @version $Id$\n */\n@ComponentTest\npublic class ImageFilterTest extends AbstractHTMLFilterTest\n{\n    @MockComponent\n    private DocumentAccessBridge dab;\n\n    @MockComponent\n    @Named(\"xhtmlmarker\")\n    private ResourceReferenceSerializer xhtmlMarkerSerializer;\n\n    @MockComponent\n    @Named(\"currentmixed\")\n    private DocumentReferenceResolver<String> currentMixedResolver;\n\n    private DocumentReference documentReference = new DocumentReference(\"wiki\", Arrays.asList(\"Path.To\"), \"Page\");\n\n    @BeforeEach\n    @Override\n    public void configure() throws Exception\n    {\n        super.configure();\n        when(this.currentMixedResolver.resolve(\"Path.To.Page\")).thenReturn(this.documentReference);\n    }\n\n    @Test\n    public void filterRemovesAlignAttribute()\n    {\n        filterAndAssertOutput(\"<img align=\\\"center\\\"/>\", \"<img/>\");\n    }\n\n    @Test\n    public void filterAddsImageMarkers()\n    {\n        AttachmentReference attachmentReference = new AttachmentReference(\"-foo--bar.png-\", this.documentReference);\n        when(this.dab.getAttachmentURL(attachmentReference, false)).thenReturn(\"/path/to/foo.png\");\n\n        ResourceReference resourceReference = new ResourceReference(\"-foo--bar.png-\", ResourceType.ATTACHMENT);\n        resourceReference.setTyped(false);\n        when(this.xhtmlMarkerSerializer.serialize(resourceReference)).thenReturn(\"false|-|attach|-|-foo--bar.png-\");\n\n        filterAndAssertOutput(\"<img src=\\\"../../some/path/-foo--b%61r.png-\\\"/>\",\n            Collections.singletonMap(\"targetDocument\", \"Path.To.Page\"),\n            \"<!--startimage:false|-|attach|-|-foo-\\\\-bar.png-\\\\--><img src=\\\"/path/to/foo.png\\\"/><!--stopimage-->\");\n    }\n\n    @Test\n    public void filterAddsImageMarkersSpecialCharacters() throws UnsupportedEncodingException\n    {\n        String imageNameUrl = \"foo&amp;+_b%61r@.png\";\n        String imageName = \"foo&+_bar\\\\@.png\";\n        String encodedImageName = URLEncoder.encode(imageName, \"UTF-8\");\n        AttachmentReference attachmentReference = new AttachmentReference(imageName, this.documentReference);\n        when(this.dab.getAttachmentURL(attachmentReference, false)).thenReturn(\"/path/to/\" + encodedImageName);\n\n        ResourceReference resourceReference = new ResourceReference(imageName, ResourceType.ATTACHMENT);\n        resourceReference.setTyped(false);\n        String imageNameEscaped = \"foo&+_bar\\\\\\\\@.png\";\n        when(this.xhtmlMarkerSerializer.serialize(resourceReference)).thenReturn(\"false|-|attach|-|\" + imageName);\n\n        filterAndAssertOutput(String.format( \"<img src=\\\"../../some/path/%s\\\"/>\", imageNameUrl),\n            Collections.singletonMap(\"targetDocument\", \"Path.To.Page\"),\n            String.format(\"<!--startimage:false|-|attach|-|%s--><img src=\\\"/path/to/%s\\\"/><!--stopimage-->\",\n                imageNameEscaped, encodedImageName));\n    }\n\n    @Test\n    public void filterIgnoresAbsoluteURLs()\n    {\n        filterAndAssertOutput(\"<img src=\\\"http://server/path/to/image.png\\\"/>\",\n            Collections.singletonMap(\"targetDocument\", \"Path.To.Page\"),\n            \"<img src=\\\"http://server/path/to/image.png\\\"/>\");\n        filterAndAssertOutput(\"<img src=\\\"file://path/to/image.png\\\"/>\",\n            Collections.singletonMap(\"targetDocument\", \"Path.To.Page\"), \"<img src=\\\"file://path/to/image.png\\\"/>\");\n    }\n\n    @Test\n    public void filterCollectsEmbeddedImages()\n    {\n        AttachmentReference attachmentReference = new AttachmentReference(\"foo.png\", this.documentReference);\n        when(this.dab.getAttachmentURL(attachmentReference, false)).thenReturn(\"/path/to/foo.png\");\n\n        ResourceReference resourceReference = new ResourceReference(\"foo.png\", ResourceType.ATTACHMENT);\n        resourceReference.setTyped(false);\n        when(this.xhtmlMarkerSerializer.serialize(resourceReference)).thenReturn(\"false|-|attach|-|foo.png\");\n\n        String fileName =\n            DataUri.parse(\"data:image/jpeg;base64,GgoAAAAN==\", Charset.forName(\"UTF-8\")).hashCode() + \".jpg\";\n        attachmentReference = new AttachmentReference(fileName, this.documentReference);\n        when(this.dab.getAttachmentURL(attachmentReference, false)).thenReturn(\"/path/to/\" + fileName);\n\n        resourceReference = new ResourceReference(fileName, ResourceType.ATTACHMENT);\n        resourceReference.setTyped(false);\n        when(this.xhtmlMarkerSerializer.serialize(resourceReference)).thenReturn(\"false|-|attach|-|\" + fileName);\n\n        Map<String, String> parameters = new HashMap<String, String>();\n        parameters.put(\"targetDocument\", \"Path.To.Page\");\n        parameters.put(\"attachEmbeddedImages\", \"true\");\n\n        Document document = filterAndAssertOutput(\n            \"<img src=\\\"data:image/png;fileName=foo.png;base64,iVBORw0K==\\\"/>\"\n                + \"<img src=\\\"data:image/jpeg;base64,GgoAAAAN==\\\"/>\",\n            parameters,\n            \"<!--startimage:false|-|attach|-|foo.png--><img src=\\\"/path/to/foo.png\\\"/><!--stopimage-->\"\n                + \"<!--startimage:false|-|attach|-|\" + fileName + \"--><img src=\\\"/path/to/\" + fileName\n                + \"\\\"/><!--stopimage-->\");\n\n        @SuppressWarnings(\"unchecked\")\n        Map<String, byte[]> embeddedImages = (Map<String, byte[]>) document.getUserData(\"embeddedImages\");\n        assertEquals(new HashSet<>(Arrays.asList(\"foo.png\", fileName)), embeddedImages.keySet());\n    }\n}\n",
    "code_after_change": "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.officeimporter.internal.filter;\n\nimport java.io.UnsupportedEncodingException;\nimport java.net.URLEncoder;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\n\nimport javax.inject.Named;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.w3c.dom.Document;\nimport org.xwiki.bridge.DocumentAccessBridge;\nimport org.xwiki.model.reference.AttachmentReference;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.rendering.internal.renderer.xhtml.XHTMLMarkerResourceReferenceSerializer;\nimport org.xwiki.rendering.listener.reference.ResourceReference;\nimport org.xwiki.rendering.listener.reference.ResourceType;\nimport org.xwiki.test.annotation.ComponentList;\nimport org.xwiki.test.junit5.mockito.ComponentTest;\nimport org.xwiki.test.junit5.mockito.MockComponent;\n\nimport com.github.ooxi.jdatauri.DataUri;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\n/**\n * Unit tests for {@link ImageFilter}.\n * \n * @version $Id$\n */\n@ComponentTest\n@ComponentList({ XHTMLMarkerResourceReferenceSerializer.class })\npublic class ImageFilterTest extends AbstractHTMLFilterTest\n{\n    @MockComponent\n    private DocumentAccessBridge dab;\n\n    @MockComponent\n    @Named(\"currentmixed\")\n    private DocumentReferenceResolver<String> currentMixedResolver;\n\n    private DocumentReference documentReference = new DocumentReference(\"wiki\", Arrays.asList(\"Path.To\"), \"Page\");\n\n    @BeforeEach\n    @Override\n    public void configure() throws Exception\n    {\n        super.configure();\n        when(this.currentMixedResolver.resolve(\"Path.To.Page\")).thenReturn(this.documentReference);\n    }\n\n    @Test\n    public void filterRemovesAlignAttribute()\n    {\n        filterAndAssertOutput(\"<img align=\\\"center\\\"/>\", \"<img/>\");\n    }\n\n    @Test\n    public void filterAddsImageMarkers()\n    {\n        AttachmentReference attachmentReference = new AttachmentReference(\"-foo--bar.png-\", this.documentReference);\n        when(this.dab.getAttachmentURL(attachmentReference, false)).thenReturn(\"/path/to/foo.png\");\n\n        ResourceReference resourceReference = new ResourceReference(\"-foo--bar.png-\", ResourceType.ATTACHMENT);\n        resourceReference.setTyped(false);\n\n        filterAndAssertOutput(\"<img src=\\\"../../some/path/-foo--b%61r.png-\\\"/>\",\n            Collections.singletonMap(\"targetDocument\", \"Path.To.Page\"),\n            \"<!--startimage:false|-|attach|-|-foo-\\\\-bar.png-\\\\--><img src=\\\"/path/to/foo.png\\\"/><!--stopimage-->\");\n    }\n\n    @Test\n    public void filterAddsImageMarkersSpecialCharacters() throws UnsupportedEncodingException\n    {\n        String imageNameUrl = \"foo&amp;+_b%61r@.png\";\n        String imageName = \"foo&+_bar\\\\@.png\";\n        String encodedImageName = URLEncoder.encode(imageName, \"UTF-8\");\n        AttachmentReference attachmentReference = new AttachmentReference(imageName, this.documentReference);\n        when(this.dab.getAttachmentURL(attachmentReference, false)).thenReturn(\"/path/to/\" + encodedImageName);\n\n        ResourceReference resourceReference = new ResourceReference(imageName, ResourceType.ATTACHMENT);\n        resourceReference.setTyped(false);\n        String imageNameEscaped = \"foo&+_bar\\\\\\\\@.png\";\n\n        filterAndAssertOutput(String.format( \"<img src=\\\"../../some/path/%s\\\"/>\", imageNameUrl),\n            Collections.singletonMap(\"targetDocument\", \"Path.To.Page\"),\n            String.format(\"<!--startimage:false|-|attach|-|%s--><img src=\\\"/path/to/%s\\\"/><!--stopimage-->\",\n                imageNameEscaped, encodedImageName));\n    }\n\n    @Test\n    public void filterIgnoresAbsoluteURLs()\n    {\n        filterAndAssertOutput(\"<img src=\\\"http://server/path/to/image.png\\\"/>\",\n            Collections.singletonMap(\"targetDocument\", \"Path.To.Page\"),\n            \"<img src=\\\"http://server/path/to/image.png\\\"/>\");\n        filterAndAssertOutput(\"<img src=\\\"file://path/to/image.png\\\"/>\",\n            Collections.singletonMap(\"targetDocument\", \"Path.To.Page\"), \"<img src=\\\"file://path/to/image.png\\\"/>\");\n    }\n\n    @Test\n    public void filterCollectsEmbeddedImages()\n    {\n        AttachmentReference attachmentReference = new AttachmentReference(\"foo.png\", this.documentReference);\n        when(this.dab.getAttachmentURL(attachmentReference, false)).thenReturn(\"/path/to/foo.png\");\n\n        ResourceReference resourceReference = new ResourceReference(\"foo.png\", ResourceType.ATTACHMENT);\n        resourceReference.setTyped(false);\n\n        String fileName =\n            DataUri.parse(\"data:image/jpeg;base64,GgoAAAAN==\", Charset.forName(\"UTF-8\")).hashCode() + \".jpg\";\n        attachmentReference = new AttachmentReference(fileName, this.documentReference);\n        when(this.dab.getAttachmentURL(attachmentReference, false)).thenReturn(\"/path/to/\" + fileName);\n\n        resourceReference = new ResourceReference(fileName, ResourceType.ATTACHMENT);\n        resourceReference.setTyped(false);\n\n        Map<String, String> parameters = new HashMap<String, String>();\n        parameters.put(\"targetDocument\", \"Path.To.Page\");\n        parameters.put(\"attachEmbeddedImages\", \"true\");\n\n        Document document = filterAndAssertOutput(\n            \"<img src=\\\"data:image/png;fileName=foo.png;base64,iVBORw0K==\\\"/>\"\n                + \"<img src=\\\"data:image/jpeg;base64,GgoAAAAN==\\\"/>\",\n            parameters,\n            \"<!--startimage:false|-|attach|-|foo.png--><img src=\\\"/path/to/foo.png\\\"/><!--stopimage-->\"\n                + \"<!--startimage:false|-|attach|-|\" + fileName + \"--><img src=\\\"/path/to/\" + fileName\n                + \"\\\"/><!--stopimage-->\");\n\n        @SuppressWarnings(\"unchecked\")\n        Map<String, byte[]> embeddedImages = (Map<String, byte[]>) document.getUserData(\"embeddedImages\");\n        assertEquals(new HashSet<>(Arrays.asList(\"foo.png\", fileName)), embeddedImages.keySet());\n    }\n\n    @Test\n    void rewriteImagePrefix() throws UnsupportedEncodingException\n    {\n        Map<String, String> configuration = Map.of(\n            \"targetDocument\", \"Path.To.Page\",\n            \"replaceImagePrefix\", \"output_\",\n            \"replacementImagePrefix\", \"re@placement_\"\n        );\n\n        String imageName = \"re\\\\@placement_image.png\";\n        String encodedImageName = URLEncoder.encode(imageName.replace(\"\\\\@\", \"@\"), StandardCharsets.UTF_8);\n        AttachmentReference attachmentReference = new AttachmentReference(imageName, this.documentReference);\n        when(this.dab.getAttachmentURL(attachmentReference, false)).thenReturn(\"/path/to/\" + encodedImageName);\n\n        filterAndAssertOutput(\"<img src=\\\"output_image.png\\\" />\", configuration,\n            \"<!--startimage:false|-|attach|-|re\\\\\\\\@placement_image.png-->\"\n                + \"<img src=\\\"/path/to/re%40placement_image.png\\\"/><!--stopimage-->\");\n\n        verify(this.dab).getAttachmentURL(attachmentReference, false);\n    }\n}\n",
    "patch": "@@ -22,6 +22,7 @@\n import java.io.UnsupportedEncodingException;\n import java.net.URLEncoder;\n import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n import java.util.Arrays;\n import java.util.Collections;\n import java.util.HashMap;\n@@ -37,32 +38,31 @@\n import org.xwiki.model.reference.AttachmentReference;\n import org.xwiki.model.reference.DocumentReference;\n import org.xwiki.model.reference.DocumentReferenceResolver;\n+import org.xwiki.rendering.internal.renderer.xhtml.XHTMLMarkerResourceReferenceSerializer;\n import org.xwiki.rendering.listener.reference.ResourceReference;\n import org.xwiki.rendering.listener.reference.ResourceType;\n-import org.xwiki.rendering.renderer.reference.ResourceReferenceSerializer;\n+import org.xwiki.test.annotation.ComponentList;\n import org.xwiki.test.junit5.mockito.ComponentTest;\n import org.xwiki.test.junit5.mockito.MockComponent;\n \n import com.github.ooxi.jdatauri.DataUri;\n \n import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.mockito.Mockito.*;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n \n /**\n  * Unit tests for {@link ImageFilter}.\n  * \n  * @version $Id$\n  */\n @ComponentTest\n+@ComponentList({ XHTMLMarkerResourceReferenceSerializer.class })\n public class ImageFilterTest extends AbstractHTMLFilterTest\n {\n     @MockComponent\n     private DocumentAccessBridge dab;\n \n-    @MockComponent\n-    @Named(\"xhtmlmarker\")\n-    private ResourceReferenceSerializer xhtmlMarkerSerializer;\n-\n     @MockComponent\n     @Named(\"currentmixed\")\n     private DocumentReferenceResolver<String> currentMixedResolver;\n@@ -91,7 +91,6 @@ public void filterAddsImageMarkers()\n \n         ResourceReference resourceReference = new ResourceReference(\"-foo--bar.png-\", ResourceType.ATTACHMENT);\n         resourceReference.setTyped(false);\n-        when(this.xhtmlMarkerSerializer.serialize(resourceReference)).thenReturn(\"false|-|attach|-|-foo--bar.png-\");\n \n         filterAndAssertOutput(\"<img src=\\\"../../some/path/-foo--b%61r.png-\\\"/>\",\n             Collections.singletonMap(\"targetDocument\", \"Path.To.Page\"),\n@@ -110,7 +109,6 @@ public void filterAddsImageMarkersSpecialCharacters() throws UnsupportedEncoding\n         ResourceReference resourceReference = new ResourceReference(imageName, ResourceType.ATTACHMENT);\n         resourceReference.setTyped(false);\n         String imageNameEscaped = \"foo&+_bar\\\\\\\\@.png\";\n-        when(this.xhtmlMarkerSerializer.serialize(resourceReference)).thenReturn(\"false|-|attach|-|\" + imageName);\n \n         filterAndAssertOutput(String.format( \"<img src=\\\"../../some/path/%s\\\"/>\", imageNameUrl),\n             Collections.singletonMap(\"targetDocument\", \"Path.To.Page\"),\n@@ -136,7 +134,6 @@ public void filterCollectsEmbeddedImages()\n \n         ResourceReference resourceReference = new ResourceReference(\"foo.png\", ResourceType.ATTACHMENT);\n         resourceReference.setTyped(false);\n-        when(this.xhtmlMarkerSerializer.serialize(resourceReference)).thenReturn(\"false|-|attach|-|foo.png\");\n \n         String fileName =\n             DataUri.parse(\"data:image/jpeg;base64,GgoAAAAN==\", Charset.forName(\"UTF-8\")).hashCode() + \".jpg\";\n@@ -145,7 +142,6 @@ public void filterCollectsEmbeddedImages()\n \n         resourceReference = new ResourceReference(fileName, ResourceType.ATTACHMENT);\n         resourceReference.setTyped(false);\n-        when(this.xhtmlMarkerSerializer.serialize(resourceReference)).thenReturn(\"false|-|attach|-|\" + fileName);\n \n         Map<String, String> parameters = new HashMap<String, String>();\n         parameters.put(\"targetDocument\", \"Path.To.Page\");\n@@ -163,4 +159,25 @@ public void filterCollectsEmbeddedImages()\n         Map<String, byte[]> embeddedImages = (Map<String, byte[]>) document.getUserData(\"embeddedImages\");\n         assertEquals(new HashSet<>(Arrays.asList(\"foo.png\", fileName)), embeddedImages.keySet());\n     }\n+\n+    @Test\n+    void rewriteImagePrefix() throws UnsupportedEncodingException\n+    {\n+        Map<String, String> configuration = Map.of(\n+            \"targetDocument\", \"Path.To.Page\",\n+            \"replaceImagePrefix\", \"output_\",\n+            \"replacementImagePrefix\", \"re@placement_\"\n+        );\n+\n+        String imageName = \"re\\\\@placement_image.png\";\n+        String encodedImageName = URLEncoder.encode(imageName.replace(\"\\\\@\", \"@\"), StandardCharsets.UTF_8);\n+        AttachmentReference attachmentReference = new AttachmentReference(imageName, this.documentReference);\n+        when(this.dab.getAttachmentURL(attachmentReference, false)).thenReturn(\"/path/to/\" + encodedImageName);\n+\n+        filterAndAssertOutput(\"<img src=\\\"output_image.png\\\" />\", configuration,\n+            \"<!--startimage:false|-|attach|-|re\\\\\\\\@placement_image.png-->\"\n+                + \"<img src=\\\"/path/to/re%40placement_image.png\\\"/><!--stopimage-->\");\n+\n+        verify(this.dab).getAttachmentURL(attachmentReference, false);\n+    }\n }",
    "function_modified_lines": {
      "added": [
        "import org.xwiki.rendering.internal.renderer.xhtml.XHTMLMarkerResourceReferenceSerializer;\n",
        "import org.xwiki.test.annotation.ComponentList;\n",
        "import static org.mockito.Mockito.verify;\n",
        "import static org.mockito.Mockito.when;\n",
        "@ComponentList({ XHTMLMarkerResourceReferenceSerializer.class })\n"
      ],
      "deleted": [
        "import org.xwiki.rendering.renderer.reference.ResourceReferenceSerializer;\n",
        "import static org.mockito.Mockito.*;\n",
        "    @MockComponent\n",
        "    @Named(\"xhtmlmarker\")\n",
        "    private ResourceReferenceSerializer xhtmlMarkerSerializer;\n",
        "\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "XWiki Platform is a generic wiki platform offering runtime services for applications built on top of it. Starting in version 3.5-milestone-1 and prior to versions 14.10.8 and 15.3-rc-1, triggering the office converter with a specially crafted file name allows writing the attachment's content to an attacker-controlled location on the server as long as the Java process has write access to that location. In particular in the combination with attachment moving, a feature introduced in XWiki 14.0, this is easy to reproduce but it also possible to reproduce in versions as old as XWiki 3.5 by uploading the attachment through the REST API which doesn't remove `/` or `\\` from the filename. As the mime type of the attachment doesn't matter for the exploitation, this could e.g., be used to replace the `jar`-file of an extension which would allow executing arbitrary Java code and thus impact the confidentiality, integrity and availability of the XWiki installation. This vulnerability has been patched in XWiki 14.10.8 and 15.3RC1. There are no known workarounds apart from disabling the office converter.",
    "id": 12413
  },
  {
    "cve_id": "CVE-2023-37913",
    "code_before_change": "{\n        AttachmentReference attachmentReference = new AttachmentReference(\"foo.png\", this.documentReference);\n        when(this.dab.getAttachmentURL(attachmentReference, false)).thenReturn(\"/path/to/foo.png\");\n\n        ResourceReference resourceReference = new ResourceReference(\"foo.png\", ResourceType.ATTACHMENT);\n        resourceReference.setTyped(false);\n        when(this.xhtmlMarkerSerializer.serialize(resourceReference)).thenReturn(\"false|-|attach|-|foo.png\");\n\n        String fileName =\n            DataUri.parse(\"data:image/jpeg;base64,GgoAAAAN==\", Charset.forName(\"UTF-8\")).hashCode() + \".jpg\";\n        attachmentReference = new AttachmentReference(fileName, this.documentReference);\n        when(this.dab.getAttachmentURL(attachmentReference, false)).thenReturn(\"/path/to/\" + fileName);\n\n        resourceReference = new ResourceReference(fileName, ResourceType.ATTACHMENT);\n        resourceReference.setTyped(false);\n        when(this.xhtmlMarkerSerializer.serialize(resourceReference)).thenReturn(\"false|-|attach|-|\" + fileName);\n\n        Map<String, String> parameters = new HashMap<String, String>();\n        parameters.put(\"targetDocument\", \"Path.To.Page\");\n        parameters.put(\"attachEmbeddedImages\", \"true\");\n\n        Document document = filterAndAssertOutput(\n            \"<img src=\\\"data:image/png;fileName=foo.png;base64,iVBORw0K==\\\"/>\"\n                + \"<img src=\\\"data:image/jpeg;base64,GgoAAAAN==\\\"/>\",\n            parameters,\n            \"<!--startimage:false|-|attach|-|foo.png--><img src=\\\"/path/to/foo.png\\\"/><!--stopimage-->\"\n                + \"<!--startimage:false|-|attach|-|\" + fileName + \"--><img src=\\\"/path/to/\" + fileName\n                + \"\\\"/><!--stopimage-->\");\n\n        @SuppressWarnings(\"unchecked\")\n        Map<String, byte[]> embeddedImages = (Map<String, byte[]>) document.getUserData(\"embeddedImages\");\n        assertEquals(new HashSet<>(Arrays.asList(\"foo.png\", fileName)), embeddedImages.keySet());\n    }",
    "code_after_change": "{\n        AttachmentReference attachmentReference = new AttachmentReference(\"foo.png\", this.documentReference);\n        when(this.dab.getAttachmentURL(attachmentReference, false)).thenReturn(\"/path/to/foo.png\");\n\n        ResourceReference resourceReference = new ResourceReference(\"foo.png\", ResourceType.ATTACHMENT);\n        resourceReference.setTyped(false);\n\n        String fileName =\n            DataUri.parse(\"data:image/jpeg;base64,GgoAAAAN==\", Charset.forName(\"UTF-8\")).hashCode() + \".jpg\";\n        attachmentReference = new AttachmentReference(fileName, this.documentReference);\n        when(this.dab.getAttachmentURL(attachmentReference, false)).thenReturn(\"/path/to/\" + fileName);\n\n        resourceReference = new ResourceReference(fileName, ResourceType.ATTACHMENT);\n        resourceReference.setTyped(false);\n\n        Map<String, String> parameters = new HashMap<String, String>();\n        parameters.put(\"targetDocument\", \"Path.To.Page\");\n        parameters.put(\"attachEmbeddedImages\", \"true\");\n\n        Document document = filterAndAssertOutput(\n            \"<img src=\\\"data:image/png;fileName=foo.png;base64,iVBORw0K==\\\"/>\"\n                + \"<img src=\\\"data:image/jpeg;base64,GgoAAAAN==\\\"/>\",\n            parameters,\n            \"<!--startimage:false|-|attach|-|foo.png--><img src=\\\"/path/to/foo.png\\\"/><!--stopimage-->\"\n                + \"<!--startimage:false|-|attach|-|\" + fileName + \"--><img src=\\\"/path/to/\" + fileName\n                + \"\\\"/><!--stopimage-->\");\n\n        @SuppressWarnings(\"unchecked\")\n        Map<String, byte[]> embeddedImages = (Map<String, byte[]>) document.getUserData(\"embeddedImages\");\n        assertEquals(new HashSet<>(Arrays.asList(\"foo.png\", fileName)), embeddedImages.keySet());\n    }",
    "patch": "@@ -22,6 +22,7 @@\n import java.io.UnsupportedEncodingException;\n import java.net.URLEncoder;\n import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n import java.util.Arrays;\n import java.util.Collections;\n import java.util.HashMap;\n@@ -37,32 +38,31 @@\n import org.xwiki.model.reference.AttachmentReference;\n import org.xwiki.model.reference.DocumentReference;\n import org.xwiki.model.reference.DocumentReferenceResolver;\n+import org.xwiki.rendering.internal.renderer.xhtml.XHTMLMarkerResourceReferenceSerializer;\n import org.xwiki.rendering.listener.reference.ResourceReference;\n import org.xwiki.rendering.listener.reference.ResourceType;\n-import org.xwiki.rendering.renderer.reference.ResourceReferenceSerializer;\n+import org.xwiki.test.annotation.ComponentList;\n import org.xwiki.test.junit5.mockito.ComponentTest;\n import org.xwiki.test.junit5.mockito.MockComponent;\n \n import com.github.ooxi.jdatauri.DataUri;\n \n import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.mockito.Mockito.*;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n \n /**\n  * Unit tests for {@link ImageFilter}.\n  * \n  * @version $Id$\n  */\n @ComponentTest\n+@ComponentList({ XHTMLMarkerResourceReferenceSerializer.class })\n public class ImageFilterTest extends AbstractHTMLFilterTest\n {\n     @MockComponent\n     private DocumentAccessBridge dab;\n \n-    @MockComponent\n-    @Named(\"xhtmlmarker\")\n-    private ResourceReferenceSerializer xhtmlMarkerSerializer;\n-\n     @MockComponent\n     @Named(\"currentmixed\")\n     private DocumentReferenceResolver<String> currentMixedResolver;\n@@ -91,7 +91,6 @@ public void filterAddsImageMarkers()\n \n         ResourceReference resourceReference = new ResourceReference(\"-foo--bar.png-\", ResourceType.ATTACHMENT);\n         resourceReference.setTyped(false);\n-        when(this.xhtmlMarkerSerializer.serialize(resourceReference)).thenReturn(\"false|-|attach|-|-foo--bar.png-\");\n \n         filterAndAssertOutput(\"<img src=\\\"../../some/path/-foo--b%61r.png-\\\"/>\",\n             Collections.singletonMap(\"targetDocument\", \"Path.To.Page\"),\n@@ -110,7 +109,6 @@ public void filterAddsImageMarkersSpecialCharacters() throws UnsupportedEncoding\n         ResourceReference resourceReference = new ResourceReference(imageName, ResourceType.ATTACHMENT);\n         resourceReference.setTyped(false);\n         String imageNameEscaped = \"foo&+_bar\\\\\\\\@.png\";\n-        when(this.xhtmlMarkerSerializer.serialize(resourceReference)).thenReturn(\"false|-|attach|-|\" + imageName);\n \n         filterAndAssertOutput(String.format( \"<img src=\\\"../../some/path/%s\\\"/>\", imageNameUrl),\n             Collections.singletonMap(\"targetDocument\", \"Path.To.Page\"),\n@@ -136,7 +134,6 @@ public void filterCollectsEmbeddedImages()\n \n         ResourceReference resourceReference = new ResourceReference(\"foo.png\", ResourceType.ATTACHMENT);\n         resourceReference.setTyped(false);\n-        when(this.xhtmlMarkerSerializer.serialize(resourceReference)).thenReturn(\"false|-|attach|-|foo.png\");\n \n         String fileName =\n             DataUri.parse(\"data:image/jpeg;base64,GgoAAAAN==\", Charset.forName(\"UTF-8\")).hashCode() + \".jpg\";\n@@ -145,7 +142,6 @@ public void filterCollectsEmbeddedImages()\n \n         resourceReference = new ResourceReference(fileName, ResourceType.ATTACHMENT);\n         resourceReference.setTyped(false);\n-        when(this.xhtmlMarkerSerializer.serialize(resourceReference)).thenReturn(\"false|-|attach|-|\" + fileName);\n \n         Map<String, String> parameters = new HashMap<String, String>();\n         parameters.put(\"targetDocument\", \"Path.To.Page\");\n@@ -163,4 +159,25 @@ public void filterCollectsEmbeddedImages()\n         Map<String, byte[]> embeddedImages = (Map<String, byte[]>) document.getUserData(\"embeddedImages\");\n         assertEquals(new HashSet<>(Arrays.asList(\"foo.png\", fileName)), embeddedImages.keySet());\n     }\n+\n+    @Test\n+    void rewriteImagePrefix() throws UnsupportedEncodingException\n+    {\n+        Map<String, String> configuration = Map.of(\n+            \"targetDocument\", \"Path.To.Page\",\n+            \"replaceImagePrefix\", \"output_\",\n+            \"replacementImagePrefix\", \"re@placement_\"\n+        );\n+\n+        String imageName = \"re\\\\@placement_image.png\";\n+        String encodedImageName = URLEncoder.encode(imageName.replace(\"\\\\@\", \"@\"), StandardCharsets.UTF_8);\n+        AttachmentReference attachmentReference = new AttachmentReference(imageName, this.documentReference);\n+        when(this.dab.getAttachmentURL(attachmentReference, false)).thenReturn(\"/path/to/\" + encodedImageName);\n+\n+        filterAndAssertOutput(\"<img src=\\\"output_image.png\\\" />\", configuration,\n+            \"<!--startimage:false|-|attach|-|re\\\\\\\\@placement_image.png-->\"\n+                + \"<img src=\\\"/path/to/re%40placement_image.png\\\"/><!--stopimage-->\");\n+\n+        verify(this.dab).getAttachmentURL(attachmentReference, false);\n+    }\n }",
    "function_modified_lines": {
      "added": [],
      "deleted": [
        "        when(this.xhtmlMarkerSerializer.serialize(resourceReference)).thenReturn(\"false|-|attach|-|foo.png\");\n",
        "        when(this.xhtmlMarkerSerializer.serialize(resourceReference)).thenReturn(\"false|-|attach|-|\" + fileName);\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "XWiki Platform is a generic wiki platform offering runtime services for applications built on top of it. Starting in version 3.5-milestone-1 and prior to versions 14.10.8 and 15.3-rc-1, triggering the office converter with a specially crafted file name allows writing the attachment's content to an attacker-controlled location on the server as long as the Java process has write access to that location. In particular in the combination with attachment moving, a feature introduced in XWiki 14.0, this is easy to reproduce but it also possible to reproduce in versions as old as XWiki 3.5 by uploading the attachment through the REST API which doesn't remove `/` or `\\` from the filename. As the mime type of the attachment doesn't matter for the exploitation, this could e.g., be used to replace the `jar`-file of an extension which would allow executing arbitrary Java code and thus impact the confidentiality, integrity and availability of the XWiki installation. This vulnerability has been patched in XWiki 14.10.8 and 15.3RC1. There are no known workarounds apart from disabling the office converter.",
    "id": 12414
  },
  {
    "cve_id": "CVE-2023-37913",
    "code_before_change": "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.office.viewer.internal;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\n\nimport javax.inject.Inject;\nimport javax.inject.Named;\nimport javax.inject.Provider;\nimport javax.inject.Singleton;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.slf4j.Logger;\nimport org.xwiki.bridge.DocumentAccessBridge;\nimport org.xwiki.cache.Cache;\nimport org.xwiki.cache.CacheException;\nimport org.xwiki.cache.CacheManager;\nimport org.xwiki.cache.config.LRUCacheConfiguration;\nimport org.xwiki.component.annotation.Component;\nimport org.xwiki.component.phase.Initializable;\nimport org.xwiki.component.phase.InitializationException;\nimport org.xwiki.model.reference.AttachmentReference;\nimport org.xwiki.model.reference.AttachmentReferenceResolver;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.EntityReference;\nimport org.xwiki.model.reference.EntityReferenceSerializer;\nimport org.xwiki.model.reference.PageAttachmentReference;\nimport org.xwiki.model.reference.PageAttachmentReferenceResolver;\nimport org.xwiki.office.viewer.OfficeResourceViewer;\nimport org.xwiki.officeimporter.OfficeImporterException;\nimport org.xwiki.officeimporter.builder.PresentationBuilder;\nimport org.xwiki.officeimporter.builder.XDOMOfficeDocumentBuilder;\nimport org.xwiki.officeimporter.converter.OfficeConverter;\nimport org.xwiki.officeimporter.document.XDOMOfficeDocument;\nimport org.xwiki.officeimporter.server.OfficeServer;",
    "code_after_change": "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.office.viewer.internal;\n\nimport java.io.File;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\n\nimport javax.inject.Inject;\nimport javax.inject.Named;\nimport javax.inject.Provider;\nimport javax.inject.Singleton;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.slf4j.Logger;\nimport org.xwiki.bridge.DocumentAccessBridge;\nimport org.xwiki.cache.Cache;\nimport org.xwiki.cache.CacheException;\nimport org.xwiki.cache.CacheManager;\nimport org.xwiki.cache.config.LRUCacheConfiguration;\nimport org.xwiki.component.annotation.Component;\nimport org.xwiki.component.phase.Initializable;\nimport org.xwiki.component.phase.InitializationException;\nimport org.xwiki.model.reference.AttachmentReference;\nimport org.xwiki.model.reference.AttachmentReferenceResolver;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.EntityReference;\nimport org.xwiki.model.reference.EntityReferenceSerializer;\nimport org.xwiki.model.reference.PageAttachmentReference;\nimport org.xwiki.model.reference.PageAttachmentReferenceResolver;\nimport org.xwiki.office.viewer.OfficeResourceViewer;\nimport org.xwiki.officeimporter.OfficeImporterException;\nimport org.xwiki.officeimporter.builder.PresentationBuilder;\nimport org.xwiki.officeimporter.builder.XDOMOfficeDocumentBuilder;\nimport org.xwiki.officeimporter.converter.OfficeConverter;\nimport org.xwiki.officeimporter.document.OfficeDocumentArtifact;\nimport org.xwiki.officeimporter.document.XDOMOfficeDocument;\nimport org.xwiki.officeimporter.server.OfficeServer;\nimport org.xwiki.properties.ConverterManager;",
    "patch": "@@ -20,12 +20,10 @@\n package org.xwiki.office.viewer.internal;\n \n import java.io.File;\n-import java.io.FileInputStream;\n import java.io.InputStream;\n import java.net.URL;\n import java.util.Arrays;\n import java.util.Collections;\n-import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n@@ -60,6 +58,7 @@\n import org.xwiki.officeimporter.builder.PresentationBuilder;\n import org.xwiki.officeimporter.builder.XDOMOfficeDocumentBuilder;\n import org.xwiki.officeimporter.converter.OfficeConverter;\n+import org.xwiki.officeimporter.document.OfficeDocumentArtifact;\n import org.xwiki.officeimporter.document.XDOMOfficeDocument;\n import org.xwiki.officeimporter.server.OfficeServer;\n import org.xwiki.properties.ConverterManager;\n@@ -200,41 +199,39 @@ public class DefaultOfficeResourceViewer implements OfficeResourceViewer, Initia\n      * images that are view artifacts.\n      * \n      * @param xdom the XDOM whose image blocks are to be processed\n-     * @param artifactFiles specify which of the image blocks should be processed; only the image blocks\n+     * @param artifactMap specify which of the image blocks should be processed; only the image blocks\n      *          that were generated during the office import process should be processed\n      * @param ownerDocumentReference specifies the document that owns the office file\n      * @param parameters the build parameters. Note that currently only {@code filterStyles} is supported and if \"true\"\n      *            it means that styles will be filtered to the maximum and the focus will be put on importing only the\n      * @return the set of temporary files corresponding to image artifacts\n      */\n-    private Set<File> processImages(XDOM xdom, Set<File> artifactFiles, DocumentReference ownerDocumentReference,\n-        Map<String, ?> parameters)\n+    private Set<File> processImages(XDOM xdom, Map<String, OfficeDocumentArtifact> artifactMap,\n+        DocumentReference ownerDocumentReference, Map<String, ?> parameters)\n     {\n         // Process all image blocks.\n         Set<File> temporaryFiles = new HashSet<>();\n         List<ImageBlock> imgBlocks = xdom.getBlocks(new ClassBlockMatcher(ImageBlock.class), Block.Axes.DESCENDANT);\n         if (!imgBlocks.isEmpty()) {\n-            Map<String, File> fileMap = new HashMap<>();\n-            for (File file : artifactFiles) {\n-                fileMap.put(file.getName(), file);\n-            }\n-\n             for (ImageBlock imgBlock : imgBlocks) {\n                 String imageReference = imgBlock.getReference().getReference();\n \n                 // Check whether there is a corresponding artifact.\n-                if (fileMap.containsKey(imageReference)) {\n+                if (artifactMap.containsKey(imageReference)) {\n                     try {\n                         List<String> resourcePath =\n                             Arrays.asList(String.valueOf(parameters.hashCode()), imageReference);\n                         TemporaryResourceReference temporaryResourceReference =\n                             new TemporaryResourceReference(MODULE_NAME, resourcePath, ownerDocumentReference);\n \n                         // Write the image into a temporary file.\n-                        File artifact = fileMap.get(imageReference);\n+                        OfficeDocumentArtifact artifact = artifactMap.get(imageReference);\n \n-                        File tempFile = this.temporaryResourceStore.createTemporaryFile(temporaryResourceReference,\n-                            new FileInputStream(artifact));\n+                        File tempFile;\n+                        try (InputStream inputStream = artifact.getContentInputStream()) {\n+                            tempFile = this.temporaryResourceStore.createTemporaryFile(temporaryResourceReference,\n+                                inputStream);\n+                        }\n \n                         // Create a URL image reference which links to above temporary image file.\n                         String temporaryResourceURL =\n@@ -429,7 +426,7 @@ private OfficeDocumentView getView(ResourceReference reference, AttachmentRefere\n                 // specified by the owner document reference. This way we ensure the path to the temporary files\n                 // doesn't contain redundant information and so it remains as small as possible (considering that the\n                 // path length is limited on some environments).\n-                Set<File> temporaryFiles = processImages(xdom, xdomOfficeDocument.getArtifactsFiles(),\n+                Set<File> temporaryFiles = processImages(xdom, xdomOfficeDocument.getArtifactsMap(),\n                     attachmentReference.getDocumentReference(), parameters);\n                 view = new AttachmentOfficeDocumentView(reference, attachmentReference, attachmentVersion, xdom,\n                     temporaryFiles);\n@@ -457,7 +454,7 @@ private OfficeDocumentView getView(ResourceReference resourceReference, Map<Stri\n             try (XDOMOfficeDocument xdomOfficeDocument = createXDOM(ownerDocument, resourceReference, parameters))\n             {\n                 XDOM xdom = xdomOfficeDocument.getContentDocument();\n-                Set<File> temporaryFiles = processImages(xdom, xdomOfficeDocument.getArtifactsFiles(), ownerDocument,\n+                Set<File> temporaryFiles = processImages(xdom, xdomOfficeDocument.getArtifactsMap(), ownerDocument,\n                     parameters);\n                 view = new OfficeDocumentView(resourceReference, xdom, temporaryFiles);\n ",
    "function_modified_lines": {
      "added": [],
      "deleted": [
        "import java.io.FileInputStream;\n",
        "import java.util.HashMap;\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "XWiki Platform is a generic wiki platform offering runtime services for applications built on top of it. Starting in version 3.5-milestone-1 and prior to versions 14.10.8 and 15.3-rc-1, triggering the office converter with a specially crafted file name allows writing the attachment's content to an attacker-controlled location on the server as long as the Java process has write access to that location. In particular in the combination with attachment moving, a feature introduced in XWiki 14.0, this is easy to reproduce but it also possible to reproduce in versions as old as XWiki 3.5 by uploading the attachment through the REST API which doesn't remove `/` or `\\` from the filename. As the mime type of the attachment doesn't matter for the exploitation, this could e.g., be used to replace the `jar`-file of an extension which would allow executing arbitrary Java code and thus impact the confidentiality, integrity and availability of the XWiki installation. This vulnerability has been patched in XWiki 14.10.8 and 15.3RC1. There are no known workarounds apart from disabling the office converter.",
    "id": 12417
  },
  {
    "cve_id": "CVE-2023-37913",
    "code_before_change": "    private XDOMOfficeDocumentBuilder documentBuilder;\n\n    /**\n     * Used to build XDOM documents from office presentations.\n     */\n    @Inject\n    private PresentationBuilder presentationBuilder;\n\n    /**\n     * Used to access the document converter.\n     */\n    @Inject\n    private OfficeServer officeServer;\n\n    @Inject\n    private ConverterManager converter;\n\n    @Inject\n    private Provider<XWikiContext> contextProvider;\n\n    @Inject\n    private URLSecurityManager urlSecurityManager;\n\n    /**\n     * The logger to log.\n     */\n    @Inject\n    private Logger logger;\n\n    /**\n     * Processes all the image blocks in the given XDOM and changes image URL to point to a temporary file for those\n     * images that are view artifacts.\n     * \n     * @param xdom the XDOM whose image blocks are to be processed\n     * @param artifactFiles specify which of the image blocks should be processed; only the image blocks\n     *          that were generated during the office import process should be processed\n     * @param ownerDocumentReference specifies the document that owns the office file\n     * @param parameters the build parameters. Note that currently only {@code filterStyles} is supported and if \"true\"\n     *            it means that styles will be filtered to the maximum and the focus will be put on importing only the\n     * @return the set of temporary files corresponding to image artifacts\n     */\n    private Set<File> processImages(XDOM xdom, Set<File> artifactFiles, DocumentReference ownerDocumentReference,\n        Map<String, ?> parameters)\n    {\n        // Process all image blocks.\n        Set<File> temporaryFiles = new HashSet<>();\n        List<ImageBlock> imgBlocks = xdom.getBlocks(new ClassBlockMatcher(ImageBlock.class), Block.Axes.DESCENDANT);\n        if (!imgBlocks.isEmpty()) {\n            Map<String, File> fileMap = new HashMap<>();\n            for (File file : artifactFiles) {\n                fileMap.put(file.getName(), file);\n            }\n\n            for (ImageBlock imgBlock : imgBlocks) {\n                String imageReference = imgBlock.getReference().getReference();\n\n                // Check whether there is a corresponding artifact.\n                if (fileMap.containsKey(imageReference)) {\n                    try {\n                        List<String> resourcePath =\n                            Arrays.asList(String.valueOf(parameters.hashCode()), imageReference);\n                        TemporaryResourceReference temporaryResourceReference =\n                            new TemporaryResourceReference(MODULE_NAME, resourcePath, ownerDocumentReference);\n\n                        // Write the image into a temporary file.\n                        File artifact = fileMap.get(imageReference);\n\n                        File tempFile = this.temporaryResourceStore.createTemporaryFile(temporaryResourceReference,\n                            new FileInputStream(artifact));\n\n                        // Create a URL image reference which links to above temporary image file.\n                        String temporaryResourceURL =\n                            this.resourceReferenceSerializer.serialize(temporaryResourceReference).serialize();\n                        ResourceReference urlImageReference =\n                            new ResourceReference(temporaryResourceURL, ResourceType.PATH);\n                        urlImageReference.setTyped(true);\n\n                        // Replace the old image block with a new one that uses the above URL image reference.\n                        Block newImgBlock = new ImageBlock(urlImageReference, false, imgBlock.getParameters());\n                        imgBlock.getParent().replaceChild(Arrays.asList(newImgBlock), imgBlock);\n\n                        // Make sure the new image block is not inside an ExpandedMacroBlock whose's content syntax\n                        // doesn't support relative path resource references (we use relative paths to refer the\n                        // temporary files).\n                        maybeFixExpandedMacroAncestor(newImgBlock);\n\n                        // Collect the temporary file so that it can be cleaned up when the view is disposed from cache.\n                        temporaryFiles.add(tempFile);\n                    } catch (Exception ex) {\n                        String message = \"Error while processing artifact image [%s].\";\n                        this.logger.error(String.format(message, imageReference), ex);\n                    }\n                }\n            }\n        }\n        return temporaryFiles;\n    }\n\n    private void maybeFixExpandedMacroAncestor(Block block)\n    {\n        ExpandedMacroBlock expandedMacro =\n            block.getFirstBlock(new ClassBlockMatcher(ExpandedMacroBlock.class), Block.Axes.ANCESTOR_OR_SELF);\n        if (expandedMacro != null) {\n            Block parent = expandedMacro.getParent();\n            if (!(parent instanceof MetaDataBlock) || !((MetaDataBlock) parent).getMetaData().contains(MODULE_NAME)) {",
    "code_after_change": "    private XDOMOfficeDocumentBuilder documentBuilder;\n\n    /**\n     * Used to build XDOM documents from office presentations.\n     */\n    @Inject\n    private PresentationBuilder presentationBuilder;\n\n    /**\n     * Used to access the document converter.\n     */\n    @Inject\n    private OfficeServer officeServer;\n\n    @Inject\n    private ConverterManager converter;\n\n    @Inject\n    private Provider<XWikiContext> contextProvider;\n\n    @Inject\n    private URLSecurityManager urlSecurityManager;\n\n    /**\n     * The logger to log.\n     */\n    @Inject\n    private Logger logger;\n\n    /**\n     * Processes all the image blocks in the given XDOM and changes image URL to point to a temporary file for those\n     * images that are view artifacts.\n     * \n     * @param xdom the XDOM whose image blocks are to be processed\n     * @param artifactMap specify which of the image blocks should be processed; only the image blocks\n     *          that were generated during the office import process should be processed\n     * @param ownerDocumentReference specifies the document that owns the office file\n     * @param parameters the build parameters. Note that currently only {@code filterStyles} is supported and if \"true\"\n     *            it means that styles will be filtered to the maximum and the focus will be put on importing only the\n     * @return the set of temporary files corresponding to image artifacts\n     */\n    private Set<File> processImages(XDOM xdom, Map<String, OfficeDocumentArtifact> artifactMap,\n        DocumentReference ownerDocumentReference, Map<String, ?> parameters)\n    {\n        // Process all image blocks.\n        Set<File> temporaryFiles = new HashSet<>();\n        List<ImageBlock> imgBlocks = xdom.getBlocks(new ClassBlockMatcher(ImageBlock.class), Block.Axes.DESCENDANT);\n        if (!imgBlocks.isEmpty()) {\n            for (ImageBlock imgBlock : imgBlocks) {\n                String imageReference = imgBlock.getReference().getReference();\n\n                // Check whether there is a corresponding artifact.\n                if (artifactMap.containsKey(imageReference)) {\n                    try {\n                        List<String> resourcePath =\n                            Arrays.asList(String.valueOf(parameters.hashCode()), imageReference);\n                        TemporaryResourceReference temporaryResourceReference =\n                            new TemporaryResourceReference(MODULE_NAME, resourcePath, ownerDocumentReference);\n\n                        // Write the image into a temporary file.\n                        OfficeDocumentArtifact artifact = artifactMap.get(imageReference);\n\n                        File tempFile;\n                        try (InputStream inputStream = artifact.getContentInputStream()) {\n                            tempFile = this.temporaryResourceStore.createTemporaryFile(temporaryResourceReference,\n                                inputStream);\n                        }\n\n                        // Create a URL image reference which links to above temporary image file.\n                        String temporaryResourceURL =\n                            this.resourceReferenceSerializer.serialize(temporaryResourceReference).serialize();\n                        ResourceReference urlImageReference =\n                            new ResourceReference(temporaryResourceURL, ResourceType.PATH);\n                        urlImageReference.setTyped(true);\n\n                        // Replace the old image block with a new one that uses the above URL image reference.\n                        Block newImgBlock = new ImageBlock(urlImageReference, false, imgBlock.getParameters());\n                        imgBlock.getParent().replaceChild(Arrays.asList(newImgBlock), imgBlock);\n\n                        // Make sure the new image block is not inside an ExpandedMacroBlock whose's content syntax\n                        // doesn't support relative path resource references (we use relative paths to refer the\n                        // temporary files).\n                        maybeFixExpandedMacroAncestor(newImgBlock);\n\n                        // Collect the temporary file so that it can be cleaned up when the view is disposed from cache.\n                        temporaryFiles.add(tempFile);\n                    } catch (Exception ex) {\n                        String message = \"Error while processing artifact image [%s].\";\n                        this.logger.error(String.format(message, imageReference), ex);\n                    }\n                }\n            }\n        }\n        return temporaryFiles;\n    }\n\n    private void maybeFixExpandedMacroAncestor(Block block)\n    {\n        ExpandedMacroBlock expandedMacro =\n            block.getFirstBlock(new ClassBlockMatcher(ExpandedMacroBlock.class), Block.Axes.ANCESTOR_OR_SELF);\n        if (expandedMacro != null) {\n            Block parent = expandedMacro.getParent();\n            if (!(parent instanceof MetaDataBlock) || !((MetaDataBlock) parent).getMetaData().contains(MODULE_NAME)) {",
    "patch": "@@ -20,12 +20,10 @@\n package org.xwiki.office.viewer.internal;\n \n import java.io.File;\n-import java.io.FileInputStream;\n import java.io.InputStream;\n import java.net.URL;\n import java.util.Arrays;\n import java.util.Collections;\n-import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n@@ -60,6 +58,7 @@\n import org.xwiki.officeimporter.builder.PresentationBuilder;\n import org.xwiki.officeimporter.builder.XDOMOfficeDocumentBuilder;\n import org.xwiki.officeimporter.converter.OfficeConverter;\n+import org.xwiki.officeimporter.document.OfficeDocumentArtifact;\n import org.xwiki.officeimporter.document.XDOMOfficeDocument;\n import org.xwiki.officeimporter.server.OfficeServer;\n import org.xwiki.properties.ConverterManager;\n@@ -200,41 +199,39 @@ public class DefaultOfficeResourceViewer implements OfficeResourceViewer, Initia\n      * images that are view artifacts.\n      * \n      * @param xdom the XDOM whose image blocks are to be processed\n-     * @param artifactFiles specify which of the image blocks should be processed; only the image blocks\n+     * @param artifactMap specify which of the image blocks should be processed; only the image blocks\n      *          that were generated during the office import process should be processed\n      * @param ownerDocumentReference specifies the document that owns the office file\n      * @param parameters the build parameters. Note that currently only {@code filterStyles} is supported and if \"true\"\n      *            it means that styles will be filtered to the maximum and the focus will be put on importing only the\n      * @return the set of temporary files corresponding to image artifacts\n      */\n-    private Set<File> processImages(XDOM xdom, Set<File> artifactFiles, DocumentReference ownerDocumentReference,\n-        Map<String, ?> parameters)\n+    private Set<File> processImages(XDOM xdom, Map<String, OfficeDocumentArtifact> artifactMap,\n+        DocumentReference ownerDocumentReference, Map<String, ?> parameters)\n     {\n         // Process all image blocks.\n         Set<File> temporaryFiles = new HashSet<>();\n         List<ImageBlock> imgBlocks = xdom.getBlocks(new ClassBlockMatcher(ImageBlock.class), Block.Axes.DESCENDANT);\n         if (!imgBlocks.isEmpty()) {\n-            Map<String, File> fileMap = new HashMap<>();\n-            for (File file : artifactFiles) {\n-                fileMap.put(file.getName(), file);\n-            }\n-\n             for (ImageBlock imgBlock : imgBlocks) {\n                 String imageReference = imgBlock.getReference().getReference();\n \n                 // Check whether there is a corresponding artifact.\n-                if (fileMap.containsKey(imageReference)) {\n+                if (artifactMap.containsKey(imageReference)) {\n                     try {\n                         List<String> resourcePath =\n                             Arrays.asList(String.valueOf(parameters.hashCode()), imageReference);\n                         TemporaryResourceReference temporaryResourceReference =\n                             new TemporaryResourceReference(MODULE_NAME, resourcePath, ownerDocumentReference);\n \n                         // Write the image into a temporary file.\n-                        File artifact = fileMap.get(imageReference);\n+                        OfficeDocumentArtifact artifact = artifactMap.get(imageReference);\n \n-                        File tempFile = this.temporaryResourceStore.createTemporaryFile(temporaryResourceReference,\n-                            new FileInputStream(artifact));\n+                        File tempFile;\n+                        try (InputStream inputStream = artifact.getContentInputStream()) {\n+                            tempFile = this.temporaryResourceStore.createTemporaryFile(temporaryResourceReference,\n+                                inputStream);\n+                        }\n \n                         // Create a URL image reference which links to above temporary image file.\n                         String temporaryResourceURL =\n@@ -429,7 +426,7 @@ private OfficeDocumentView getView(ResourceReference reference, AttachmentRefere\n                 // specified by the owner document reference. This way we ensure the path to the temporary files\n                 // doesn't contain redundant information and so it remains as small as possible (considering that the\n                 // path length is limited on some environments).\n-                Set<File> temporaryFiles = processImages(xdom, xdomOfficeDocument.getArtifactsFiles(),\n+                Set<File> temporaryFiles = processImages(xdom, xdomOfficeDocument.getArtifactsMap(),\n                     attachmentReference.getDocumentReference(), parameters);\n                 view = new AttachmentOfficeDocumentView(reference, attachmentReference, attachmentVersion, xdom,\n                     temporaryFiles);\n@@ -457,7 +454,7 @@ private OfficeDocumentView getView(ResourceReference resourceReference, Map<Stri\n             try (XDOMOfficeDocument xdomOfficeDocument = createXDOM(ownerDocument, resourceReference, parameters))\n             {\n                 XDOM xdom = xdomOfficeDocument.getContentDocument();\n-                Set<File> temporaryFiles = processImages(xdom, xdomOfficeDocument.getArtifactsFiles(), ownerDocument,\n+                Set<File> temporaryFiles = processImages(xdom, xdomOfficeDocument.getArtifactsMap(), ownerDocument,\n                     parameters);\n                 view = new OfficeDocumentView(resourceReference, xdom, temporaryFiles);\n ",
    "function_modified_lines": {
      "added": [
        "     * @param artifactMap specify which of the image blocks should be processed; only the image blocks\n",
        "    private Set<File> processImages(XDOM xdom, Map<String, OfficeDocumentArtifact> artifactMap,\n",
        "        DocumentReference ownerDocumentReference, Map<String, ?> parameters)\n",
        "                if (artifactMap.containsKey(imageReference)) {\n",
        "                        OfficeDocumentArtifact artifact = artifactMap.get(imageReference);\n",
        "                        File tempFile;\n",
        "                        try (InputStream inputStream = artifact.getContentInputStream()) {\n",
        "                            tempFile = this.temporaryResourceStore.createTemporaryFile(temporaryResourceReference,\n",
        "                                inputStream);\n",
        "                        }\n"
      ],
      "deleted": [
        "     * @param artifactFiles specify which of the image blocks should be processed; only the image blocks\n",
        "    private Set<File> processImages(XDOM xdom, Set<File> artifactFiles, DocumentReference ownerDocumentReference,\n",
        "        Map<String, ?> parameters)\n",
        "            Map<String, File> fileMap = new HashMap<>();\n",
        "            for (File file : artifactFiles) {\n",
        "                fileMap.put(file.getName(), file);\n",
        "            }\n",
        "\n",
        "                if (fileMap.containsKey(imageReference)) {\n",
        "                        File artifact = fileMap.get(imageReference);\n",
        "                        File tempFile = this.temporaryResourceStore.createTemporaryFile(temporaryResourceReference,\n",
        "                            new FileInputStream(artifact));\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "XWiki Platform is a generic wiki platform offering runtime services for applications built on top of it. Starting in version 3.5-milestone-1 and prior to versions 14.10.8 and 15.3-rc-1, triggering the office converter with a specially crafted file name allows writing the attachment's content to an attacker-controlled location on the server as long as the Java process has write access to that location. In particular in the combination with attachment moving, a feature introduced in XWiki 14.0, this is easy to reproduce but it also possible to reproduce in versions as old as XWiki 3.5 by uploading the attachment through the REST API which doesn't remove `/` or `\\` from the filename. As the mime type of the attachment doesn't matter for the exploitation, this could e.g., be used to replace the `jar`-file of an extension which would allow executing arbitrary Java code and thus impact the confidentiality, integrity and availability of the XWiki installation. This vulnerability has been patched in XWiki 14.10.8 and 15.3RC1. There are no known workarounds apart from disabling the office converter.",
    "id": 12418
  },
  {
    "cve_id": "CVE-2023-37913",
    "code_before_change": "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.office.viewer.internal;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Optional;\n\nimport javax.inject.Named;\nimport javax.inject.Provider;\n\nimport org.apache.commons.io.IOUtils;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.xwiki.bridge.DocumentAccessBridge;\nimport org.xwiki.cache.Cache;\nimport org.xwiki.cache.CacheManager;\nimport org.xwiki.cache.config.CacheConfiguration;\nimport org.xwiki.model.reference.AttachmentReference;\nimport org.xwiki.model.reference.AttachmentReferenceResolver;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.EntityReferenceSerializer;\nimport org.xwiki.officeimporter.builder.PresentationBuilder;\nimport org.xwiki.officeimporter.builder.XDOMOfficeDocumentBuilder;\nimport org.xwiki.officeimporter.converter.OfficeConverter;\nimport org.xwiki.officeimporter.converter.OfficeConverterResult;\nimport org.xwiki.officeimporter.document.XDOMOfficeDocument;\nimport org.xwiki.officeimporter.server.OfficeServer;\nimport org.xwiki.properties.ConverterManager;\nimport org.xwiki.rendering.block.Block;\nimport org.xwiki.rendering.block.ExpandedMacroBlock;\nimport org.xwiki.rendering.block.ImageBlock;\nimport org.xwiki.rendering.block.MetaDataBlock;\nimport org.xwiki.rendering.block.XDOM;\nimport org.xwiki.rendering.block.match.ClassBlockMatcher;\nimport org.xwiki.rendering.listener.MetaData;\nimport org.xwiki.rendering.listener.reference.AttachmentResourceReference;\nimport org.xwiki.rendering.listener.reference.ResourceReference;\nimport org.xwiki.rendering.listener.reference.ResourceType;\nimport org.xwiki.rendering.renderer.reference.ResourceReferenceTypeSerializer;\nimport org.xwiki.rendering.syntax.Syntax;\nimport org.xwiki.resource.ResourceReferenceSerializer;\nimport org.xwiki.resource.temporary.TemporaryResourceReference;\nimport org.xwiki.resource.temporary.TemporaryResourceStore;\nimport org.xwiki.security.authorization.AccessDeniedException;\nimport org.xwiki.store.TemporaryAttachmentSessionsManager;\nimport org.xwiki.test.annotation.BeforeComponent;\nimport org.xwiki.test.junit5.XWikiTempDir;\nimport org.xwiki.test.junit5.mockito.ComponentTest;\nimport org.xwiki.test.junit5.mockito.InjectMockComponents;\nimport org.xwiki.test.junit5.mockito.MockComponent;\nimport org.xwiki.test.mockito.MockitoComponentManager;\nimport org.xwiki.url.ExtendedURL;\nimport org.xwiki.url.URLSecurityManager;\n\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.doc.XWikiAttachment;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.ArgumentMatchers.eq;",
    "code_after_change": "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.office.viewer.internal;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Optional;\n\nimport javax.inject.Named;\nimport javax.inject.Provider;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.xwiki.bridge.DocumentAccessBridge;\nimport org.xwiki.cache.Cache;\nimport org.xwiki.cache.CacheManager;\nimport org.xwiki.cache.config.CacheConfiguration;\nimport org.xwiki.model.reference.AttachmentReference;\nimport org.xwiki.model.reference.AttachmentReferenceResolver;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.EntityReferenceSerializer;\nimport org.xwiki.officeimporter.builder.PresentationBuilder;\nimport org.xwiki.officeimporter.builder.XDOMOfficeDocumentBuilder;\nimport org.xwiki.officeimporter.converter.OfficeConverter;\nimport org.xwiki.officeimporter.converter.OfficeConverterResult;\nimport org.xwiki.officeimporter.document.XDOMOfficeDocument;\nimport org.xwiki.officeimporter.internal.document.ByteArrayOfficeDocumentArtifact;\nimport org.xwiki.officeimporter.server.OfficeServer;\nimport org.xwiki.properties.ConverterManager;\nimport org.xwiki.rendering.block.Block;\nimport org.xwiki.rendering.block.ExpandedMacroBlock;\nimport org.xwiki.rendering.block.ImageBlock;\nimport org.xwiki.rendering.block.MetaDataBlock;\nimport org.xwiki.rendering.block.XDOM;\nimport org.xwiki.rendering.block.match.ClassBlockMatcher;\nimport org.xwiki.rendering.listener.MetaData;\nimport org.xwiki.rendering.listener.reference.AttachmentResourceReference;\nimport org.xwiki.rendering.listener.reference.ResourceReference;\nimport org.xwiki.rendering.listener.reference.ResourceType;\nimport org.xwiki.rendering.renderer.reference.ResourceReferenceTypeSerializer;\nimport org.xwiki.rendering.syntax.Syntax;\nimport org.xwiki.resource.ResourceReferenceSerializer;\nimport org.xwiki.resource.temporary.TemporaryResourceReference;\nimport org.xwiki.resource.temporary.TemporaryResourceStore;\nimport org.xwiki.security.authorization.AccessDeniedException;\nimport org.xwiki.store.TemporaryAttachmentSessionsManager;\nimport org.xwiki.test.annotation.BeforeComponent;\nimport org.xwiki.test.junit5.XWikiTempDir;\nimport org.xwiki.test.junit5.mockito.ComponentTest;\nimport org.xwiki.test.junit5.mockito.InjectMockComponents;\nimport org.xwiki.test.junit5.mockito.MockComponent;\nimport org.xwiki.test.mockito.MockitoComponentManager;\nimport org.xwiki.url.ExtendedURL;\nimport org.xwiki.url.URLSecurityManager;\n\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.doc.XWikiAttachment;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertThrows;",
    "patch": "@@ -21,7 +21,6 @@\n \n import java.io.ByteArrayInputStream;\n import java.io.File;\n-import java.io.FileOutputStream;\n import java.io.InputStream;\n import java.net.URL;\n import java.util.ArrayList;\n@@ -34,7 +33,6 @@\n import javax.inject.Named;\n import javax.inject.Provider;\n \n-import org.apache.commons.io.IOUtils;\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n import org.xwiki.bridge.DocumentAccessBridge;\n@@ -50,6 +48,7 @@\n import org.xwiki.officeimporter.converter.OfficeConverter;\n import org.xwiki.officeimporter.converter.OfficeConverterResult;\n import org.xwiki.officeimporter.document.XDOMOfficeDocument;\n+import org.xwiki.officeimporter.internal.document.ByteArrayOfficeDocumentArtifact;\n import org.xwiki.officeimporter.server.OfficeServer;\n import org.xwiki.properties.ConverterManager;\n import org.xwiki.rendering.block.Block;\n@@ -281,7 +280,7 @@ void viewExistingOfficeAttachmentWithCacheMiss(MockitoComponentManager component\n         when(documentAccessBridge.getAttachmentContent(ATTACHMENT_REFERENCE)).thenReturn(attachmentContent);\n \n         XDOMOfficeDocument xdomOfficeDocument =\n-            new XDOMOfficeDocument(new XDOM(new ArrayList<Block>()), Collections.emptySet(), componentManager, null);\n+            new XDOMOfficeDocument(new XDOM(new ArrayList<Block>()), Collections.emptyMap(), componentManager, null);\n         when(\n             officeDocumentBuilder.build(attachmentContent, ATTACHMENT_REFERENCE.getName(),\n                 ATTACHMENT_REFERENCE.getDocumentReference(), false)).thenReturn(xdomOfficeDocument);\n@@ -311,7 +310,7 @@ void viewTemporaryUploadedOfficeAttachmentWithCacheMiss(MockitoComponentManager\n         when(attachment.getContentInputStream(this.context)).thenReturn(attachmentContent);\n \n         XDOMOfficeDocument xdomOfficeDocument =\n-            new XDOMOfficeDocument(new XDOM(new ArrayList<Block>()), Collections.emptySet(), componentManager, null);\n+            new XDOMOfficeDocument(new XDOM(new ArrayList<Block>()), Collections.emptyMap(), componentManager, null);\n         when(\n             officeDocumentBuilder.build(attachmentContent, ATTACHMENT_REFERENCE.getName(),\n                 ATTACHMENT_REFERENCE.getDocumentReference(), false)).thenReturn(xdomOfficeDocument);\n@@ -365,7 +364,7 @@ void viewTemporaryUploadedOfficeAttachmentWithCacheHit(MockitoComponentManager c\n         when(attachment.getContentInputStream(this.context)).thenReturn(attachmentContent);\n \n         XDOMOfficeDocument xdomOfficeDocument =\n-            new XDOMOfficeDocument(new XDOM(new ArrayList<Block>()), Collections.emptySet(), componentManager, null);\n+            new XDOMOfficeDocument(new XDOM(new ArrayList<Block>()), Collections.emptyMap(), componentManager, null);\n         when(\n             officeDocumentBuilder.build(attachmentContent, ATTACHMENT_REFERENCE.getName(),\n                 ATTACHMENT_REFERENCE.getDocumentReference(), false)).thenReturn(xdomOfficeDocument);\n@@ -440,7 +439,7 @@ void viewANewVersionOfAnExistingOfficeAttachment(MockitoComponentManager compone\n         when(documentAccessBridge.getAttachmentContent(ATTACHMENT_REFERENCE)).thenReturn(attachmentContent);\n \n         XDOMOfficeDocument xdomOfficeDocument =\n-            new XDOMOfficeDocument(new XDOM(new ArrayList<Block>()), Collections.emptySet(), componentManager, null);\n+            new XDOMOfficeDocument(new XDOM(new ArrayList<Block>()), Collections.emptyMap(), componentManager, null);\n         when(\n             officeDocumentBuilder.build(attachmentContent, ATTACHMENT_REFERENCE.getName(),\n                 ATTACHMENT_REFERENCE.getDocumentReference(), false)).thenReturn(xdomOfficeDocument);\n@@ -471,28 +470,25 @@ void viewPresentation(MockitoComponentManager componentManager) throws Exception\n         ByteArrayInputStream attachmentContent = new ByteArrayInputStream(new byte[256]);\n         when(documentAccessBridge.getAttachmentContent(attachmentReference)).thenReturn(attachmentContent);\n \n-        ResourceReference imageReference = new ResourceReference(\"slide0.png\", ResourceType.URL);\n+        String imageName = \"slide0.png\";\n+        ResourceReference imageReference = new ResourceReference(imageName, ResourceType.URL);\n         ExpandedMacroBlock galleryMacro =\n             new ExpandedMacroBlock(\"gallery\", Collections.singletonMap(\"width\", \"300px\"), null, false);\n         galleryMacro.addChild(new ImageBlock(imageReference, true));\n         XDOM xdom = new XDOM(Collections.<Block>singletonList(galleryMacro));\n \n-        File artifact = new File(this.tempDir, \"slide0.png\");\n-        try (FileOutputStream fos = new FileOutputStream(artifact)) {\n-            IOUtils.write(new byte[8], fos);\n-        }\n         OfficeConverterResult converterResult = mock(OfficeConverterResult.class);\n-        XDOMOfficeDocument xdomOfficeDocument = new XDOMOfficeDocument(xdom, Collections.singleton(artifact),\n-            componentManager, converterResult);\n+        XDOMOfficeDocument xdomOfficeDocument = new XDOMOfficeDocument(xdom, Collections.singletonMap(imageName,\n+            new ByteArrayOfficeDocumentArtifact(imageName, new byte[8])), componentManager, converterResult);\n \n         when(presentationBuilder.build(attachmentContent, attachmentReference.getName(), documentReference))\n             .thenReturn(xdomOfficeDocument);\n \n         Map<String, ?> viewParameters = Collections.singletonMap(\"ownerDocument\", documentReference);\n         TemporaryResourceReference temporaryResourceReference = new TemporaryResourceReference(\"officeviewer\",\n-            Arrays.asList(String.valueOf(viewParameters.hashCode()), \"slide0.png\"), documentReference);\n+            Arrays.asList(String.valueOf(viewParameters.hashCode()), imageName), documentReference);\n \n-        ExtendedURL extendedURL = new ExtendedURL(Arrays.asList(\"url\", \"to\", \"slide0.png\"));\n+        ExtendedURL extendedURL = new ExtendedURL(Arrays.asList(\"url\", \"to\", imageName));\n         when(this.resourceReferenceSerializer.serialize(temporaryResourceReference)).thenReturn(extendedURL);\n \n         XDOM output = this.officeResourceViewer.createView(attachResourceRef, viewParameters);",
    "function_modified_lines": {
      "added": [
        "import org.xwiki.officeimporter.internal.document.ByteArrayOfficeDocumentArtifact;\n"
      ],
      "deleted": [
        "import java.io.FileOutputStream;\n",
        "import org.apache.commons.io.IOUtils;\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "XWiki Platform is a generic wiki platform offering runtime services for applications built on top of it. Starting in version 3.5-milestone-1 and prior to versions 14.10.8 and 15.3-rc-1, triggering the office converter with a specially crafted file name allows writing the attachment's content to an attacker-controlled location on the server as long as the Java process has write access to that location. In particular in the combination with attachment moving, a feature introduced in XWiki 14.0, this is easy to reproduce but it also possible to reproduce in versions as old as XWiki 3.5 by uploading the attachment through the REST API which doesn't remove `/` or `\\` from the filename. As the mime type of the attachment doesn't matter for the exploitation, this could e.g., be used to replace the `jar`-file of an extension which would allow executing arbitrary Java code and thus impact the confidentiality, integrity and availability of the XWiki installation. This vulnerability has been patched in XWiki 14.10.8 and 15.3RC1. There are no known workarounds apart from disabling the office converter.",
    "id": 12419
  },
  {
    "cve_id": "CVE-2023-37913",
    "code_before_change": "{\n        AttachmentResourceReference attachResourceRef =\n            new AttachmentResourceReference(\"xwiki:Some.Page@presentation.odp\");\n        DocumentReference documentReference = new DocumentReference(\"wiki\", \"Some\", \"Page\");\n        AttachmentReference attachmentReference = new AttachmentReference(\"presentation.odp\", documentReference);\n        OfficeConverter officeConverter = mock(OfficeConverter.class);\n        when(this.officeServer.getConverter()).thenReturn(officeConverter);\n        when(officeConverter.isPresentation(\"presentation.odp\")).thenReturn(true);\n\n        when(attachmentReferenceResolver.resolve(attachResourceRef.getReference())).thenReturn(attachmentReference);\n\n        when(documentAccessBridge.getAttachmentReferences(attachmentReference.getDocumentReference())).thenReturn(\n            Arrays.asList(attachmentReference));\n        when(documentAccessBridge.getAttachmentVersion(attachmentReference)).thenReturn(\"3.2\");\n\n        ByteArrayInputStream attachmentContent = new ByteArrayInputStream(new byte[256]);\n        when(documentAccessBridge.getAttachmentContent(attachmentReference)).thenReturn(attachmentContent);\n\n        ResourceReference imageReference = new ResourceReference(\"slide0.png\", ResourceType.URL);\n        ExpandedMacroBlock galleryMacro =\n            new ExpandedMacroBlock(\"gallery\", Collections.singletonMap(\"width\", \"300px\"), null, false);\n        galleryMacro.addChild(new ImageBlock(imageReference, true));\n        XDOM xdom = new XDOM(Collections.<Block>singletonList(galleryMacro));\n\n        File artifact = new File(this.tempDir, \"slide0.png\");\n        try (FileOutputStream fos = new FileOutputStream(artifact)) {\n            IOUtils.write(new byte[8], fos);\n        }\n        OfficeConverterResult converterResult = mock(OfficeConverterResult.class);\n        XDOMOfficeDocument xdomOfficeDocument = new XDOMOfficeDocument(xdom, Collections.singleton(artifact),\n            componentManager, converterResult);\n\n        when(presentationBuilder.build(attachmentContent, attachmentReference.getName(), documentReference))\n            .thenReturn(xdomOfficeDocument);\n\n        Map<String, ?> viewParameters = Collections.singletonMap(\"ownerDocument\", documentReference);\n        TemporaryResourceReference temporaryResourceReference = new TemporaryResourceReference(\"officeviewer\",\n            Arrays.asList(String.valueOf(viewParameters.hashCode()), \"slide0.png\"), documentReference);\n\n        ExtendedURL extendedURL = new ExtendedURL(Arrays.asList(\"url\", \"to\", \"slide0.png\"));\n        when(this.resourceReferenceSerializer.serialize(temporaryResourceReference)).thenReturn(extendedURL);\n\n        XDOM output = this.officeResourceViewer.createView(attachResourceRef, viewParameters);\n\n        ImageBlock imageBlock =\n            (ImageBlock) output.getBlocks(new ClassBlockMatcher(ImageBlock.class), Block.Axes.DESCENDANT).get(0);\n        assertEquals(\"/url/to/slide0.png\", imageBlock.getReference().getReference());\n\n        galleryMacro = (ExpandedMacroBlock) output\n            .getBlocks(new ClassBlockMatcher(ExpandedMacroBlock.class), Block.Axes.DESCENDANT).get(0);\n        assertFalse(galleryMacro.getParent() instanceof XDOM);\n        assertEquals(Syntax.XWIKI_2_1,\n            ((MetaDataBlock) galleryMacro.getParent()).getMetaData().getMetaData(MetaData.SYNTAX));\n\n        verify(this.temporaryResourceStore).createTemporaryFile(eq(temporaryResourceReference), any(InputStream.class));\n        verify(converterResult).close();\n    }",
    "code_after_change": "{\n        AttachmentResourceReference attachResourceRef =\n            new AttachmentResourceReference(\"xwiki:Some.Page@presentation.odp\");\n        DocumentReference documentReference = new DocumentReference(\"wiki\", \"Some\", \"Page\");\n        AttachmentReference attachmentReference = new AttachmentReference(\"presentation.odp\", documentReference);\n        OfficeConverter officeConverter = mock(OfficeConverter.class);\n        when(this.officeServer.getConverter()).thenReturn(officeConverter);\n        when(officeConverter.isPresentation(\"presentation.odp\")).thenReturn(true);\n\n        when(attachmentReferenceResolver.resolve(attachResourceRef.getReference())).thenReturn(attachmentReference);\n\n        when(documentAccessBridge.getAttachmentReferences(attachmentReference.getDocumentReference())).thenReturn(\n            Arrays.asList(attachmentReference));\n        when(documentAccessBridge.getAttachmentVersion(attachmentReference)).thenReturn(\"3.2\");\n\n        ByteArrayInputStream attachmentContent = new ByteArrayInputStream(new byte[256]);\n        when(documentAccessBridge.getAttachmentContent(attachmentReference)).thenReturn(attachmentContent);\n\n        String imageName = \"slide0.png\";\n        ResourceReference imageReference = new ResourceReference(imageName, ResourceType.URL);\n        ExpandedMacroBlock galleryMacro =\n            new ExpandedMacroBlock(\"gallery\", Collections.singletonMap(\"width\", \"300px\"), null, false);\n        galleryMacro.addChild(new ImageBlock(imageReference, true));\n        XDOM xdom = new XDOM(Collections.<Block>singletonList(galleryMacro));\n\n        OfficeConverterResult converterResult = mock(OfficeConverterResult.class);\n        XDOMOfficeDocument xdomOfficeDocument = new XDOMOfficeDocument(xdom, Collections.singletonMap(imageName,\n            new ByteArrayOfficeDocumentArtifact(imageName, new byte[8])), componentManager, converterResult);\n\n        when(presentationBuilder.build(attachmentContent, attachmentReference.getName(), documentReference))\n            .thenReturn(xdomOfficeDocument);\n\n        Map<String, ?> viewParameters = Collections.singletonMap(\"ownerDocument\", documentReference);\n        TemporaryResourceReference temporaryResourceReference = new TemporaryResourceReference(\"officeviewer\",\n            Arrays.asList(String.valueOf(viewParameters.hashCode()), imageName), documentReference);\n\n        ExtendedURL extendedURL = new ExtendedURL(Arrays.asList(\"url\", \"to\", imageName));\n        when(this.resourceReferenceSerializer.serialize(temporaryResourceReference)).thenReturn(extendedURL);\n\n        XDOM output = this.officeResourceViewer.createView(attachResourceRef, viewParameters);\n\n        ImageBlock imageBlock =\n            (ImageBlock) output.getBlocks(new ClassBlockMatcher(ImageBlock.class), Block.Axes.DESCENDANT).get(0);\n        assertEquals(\"/url/to/slide0.png\", imageBlock.getReference().getReference());\n\n        galleryMacro = (ExpandedMacroBlock) output\n            .getBlocks(new ClassBlockMatcher(ExpandedMacroBlock.class), Block.Axes.DESCENDANT).get(0);\n        assertFalse(galleryMacro.getParent() instanceof XDOM);\n        assertEquals(Syntax.XWIKI_2_1,\n            ((MetaDataBlock) galleryMacro.getParent()).getMetaData().getMetaData(MetaData.SYNTAX));\n\n        verify(this.temporaryResourceStore).createTemporaryFile(eq(temporaryResourceReference), any(InputStream.class));\n        verify(converterResult).close();\n    }",
    "patch": "@@ -21,7 +21,6 @@\n \n import java.io.ByteArrayInputStream;\n import java.io.File;\n-import java.io.FileOutputStream;\n import java.io.InputStream;\n import java.net.URL;\n import java.util.ArrayList;\n@@ -34,7 +33,6 @@\n import javax.inject.Named;\n import javax.inject.Provider;\n \n-import org.apache.commons.io.IOUtils;\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n import org.xwiki.bridge.DocumentAccessBridge;\n@@ -50,6 +48,7 @@\n import org.xwiki.officeimporter.converter.OfficeConverter;\n import org.xwiki.officeimporter.converter.OfficeConverterResult;\n import org.xwiki.officeimporter.document.XDOMOfficeDocument;\n+import org.xwiki.officeimporter.internal.document.ByteArrayOfficeDocumentArtifact;\n import org.xwiki.officeimporter.server.OfficeServer;\n import org.xwiki.properties.ConverterManager;\n import org.xwiki.rendering.block.Block;\n@@ -281,7 +280,7 @@ void viewExistingOfficeAttachmentWithCacheMiss(MockitoComponentManager component\n         when(documentAccessBridge.getAttachmentContent(ATTACHMENT_REFERENCE)).thenReturn(attachmentContent);\n \n         XDOMOfficeDocument xdomOfficeDocument =\n-            new XDOMOfficeDocument(new XDOM(new ArrayList<Block>()), Collections.emptySet(), componentManager, null);\n+            new XDOMOfficeDocument(new XDOM(new ArrayList<Block>()), Collections.emptyMap(), componentManager, null);\n         when(\n             officeDocumentBuilder.build(attachmentContent, ATTACHMENT_REFERENCE.getName(),\n                 ATTACHMENT_REFERENCE.getDocumentReference(), false)).thenReturn(xdomOfficeDocument);\n@@ -311,7 +310,7 @@ void viewTemporaryUploadedOfficeAttachmentWithCacheMiss(MockitoComponentManager\n         when(attachment.getContentInputStream(this.context)).thenReturn(attachmentContent);\n \n         XDOMOfficeDocument xdomOfficeDocument =\n-            new XDOMOfficeDocument(new XDOM(new ArrayList<Block>()), Collections.emptySet(), componentManager, null);\n+            new XDOMOfficeDocument(new XDOM(new ArrayList<Block>()), Collections.emptyMap(), componentManager, null);\n         when(\n             officeDocumentBuilder.build(attachmentContent, ATTACHMENT_REFERENCE.getName(),\n                 ATTACHMENT_REFERENCE.getDocumentReference(), false)).thenReturn(xdomOfficeDocument);\n@@ -365,7 +364,7 @@ void viewTemporaryUploadedOfficeAttachmentWithCacheHit(MockitoComponentManager c\n         when(attachment.getContentInputStream(this.context)).thenReturn(attachmentContent);\n \n         XDOMOfficeDocument xdomOfficeDocument =\n-            new XDOMOfficeDocument(new XDOM(new ArrayList<Block>()), Collections.emptySet(), componentManager, null);\n+            new XDOMOfficeDocument(new XDOM(new ArrayList<Block>()), Collections.emptyMap(), componentManager, null);\n         when(\n             officeDocumentBuilder.build(attachmentContent, ATTACHMENT_REFERENCE.getName(),\n                 ATTACHMENT_REFERENCE.getDocumentReference(), false)).thenReturn(xdomOfficeDocument);\n@@ -440,7 +439,7 @@ void viewANewVersionOfAnExistingOfficeAttachment(MockitoComponentManager compone\n         when(documentAccessBridge.getAttachmentContent(ATTACHMENT_REFERENCE)).thenReturn(attachmentContent);\n \n         XDOMOfficeDocument xdomOfficeDocument =\n-            new XDOMOfficeDocument(new XDOM(new ArrayList<Block>()), Collections.emptySet(), componentManager, null);\n+            new XDOMOfficeDocument(new XDOM(new ArrayList<Block>()), Collections.emptyMap(), componentManager, null);\n         when(\n             officeDocumentBuilder.build(attachmentContent, ATTACHMENT_REFERENCE.getName(),\n                 ATTACHMENT_REFERENCE.getDocumentReference(), false)).thenReturn(xdomOfficeDocument);\n@@ -471,28 +470,25 @@ void viewPresentation(MockitoComponentManager componentManager) throws Exception\n         ByteArrayInputStream attachmentContent = new ByteArrayInputStream(new byte[256]);\n         when(documentAccessBridge.getAttachmentContent(attachmentReference)).thenReturn(attachmentContent);\n \n-        ResourceReference imageReference = new ResourceReference(\"slide0.png\", ResourceType.URL);\n+        String imageName = \"slide0.png\";\n+        ResourceReference imageReference = new ResourceReference(imageName, ResourceType.URL);\n         ExpandedMacroBlock galleryMacro =\n             new ExpandedMacroBlock(\"gallery\", Collections.singletonMap(\"width\", \"300px\"), null, false);\n         galleryMacro.addChild(new ImageBlock(imageReference, true));\n         XDOM xdom = new XDOM(Collections.<Block>singletonList(galleryMacro));\n \n-        File artifact = new File(this.tempDir, \"slide0.png\");\n-        try (FileOutputStream fos = new FileOutputStream(artifact)) {\n-            IOUtils.write(new byte[8], fos);\n-        }\n         OfficeConverterResult converterResult = mock(OfficeConverterResult.class);\n-        XDOMOfficeDocument xdomOfficeDocument = new XDOMOfficeDocument(xdom, Collections.singleton(artifact),\n-            componentManager, converterResult);\n+        XDOMOfficeDocument xdomOfficeDocument = new XDOMOfficeDocument(xdom, Collections.singletonMap(imageName,\n+            new ByteArrayOfficeDocumentArtifact(imageName, new byte[8])), componentManager, converterResult);\n \n         when(presentationBuilder.build(attachmentContent, attachmentReference.getName(), documentReference))\n             .thenReturn(xdomOfficeDocument);\n \n         Map<String, ?> viewParameters = Collections.singletonMap(\"ownerDocument\", documentReference);\n         TemporaryResourceReference temporaryResourceReference = new TemporaryResourceReference(\"officeviewer\",\n-            Arrays.asList(String.valueOf(viewParameters.hashCode()), \"slide0.png\"), documentReference);\n+            Arrays.asList(String.valueOf(viewParameters.hashCode()), imageName), documentReference);\n \n-        ExtendedURL extendedURL = new ExtendedURL(Arrays.asList(\"url\", \"to\", \"slide0.png\"));\n+        ExtendedURL extendedURL = new ExtendedURL(Arrays.asList(\"url\", \"to\", imageName));\n         when(this.resourceReferenceSerializer.serialize(temporaryResourceReference)).thenReturn(extendedURL);\n \n         XDOM output = this.officeResourceViewer.createView(attachResourceRef, viewParameters);",
    "function_modified_lines": {
      "added": [
        "        String imageName = \"slide0.png\";\n",
        "        ResourceReference imageReference = new ResourceReference(imageName, ResourceType.URL);\n",
        "        XDOMOfficeDocument xdomOfficeDocument = new XDOMOfficeDocument(xdom, Collections.singletonMap(imageName,\n",
        "            new ByteArrayOfficeDocumentArtifact(imageName, new byte[8])), componentManager, converterResult);\n",
        "            Arrays.asList(String.valueOf(viewParameters.hashCode()), imageName), documentReference);\n",
        "        ExtendedURL extendedURL = new ExtendedURL(Arrays.asList(\"url\", \"to\", imageName));\n"
      ],
      "deleted": [
        "        ResourceReference imageReference = new ResourceReference(\"slide0.png\", ResourceType.URL);\n",
        "        File artifact = new File(this.tempDir, \"slide0.png\");\n",
        "        try (FileOutputStream fos = new FileOutputStream(artifact)) {\n",
        "            IOUtils.write(new byte[8], fos);\n",
        "        }\n",
        "        XDOMOfficeDocument xdomOfficeDocument = new XDOMOfficeDocument(xdom, Collections.singleton(artifact),\n",
        "            componentManager, converterResult);\n",
        "            Arrays.asList(String.valueOf(viewParameters.hashCode()), \"slide0.png\"), documentReference);\n",
        "        ExtendedURL extendedURL = new ExtendedURL(Arrays.asList(\"url\", \"to\", \"slide0.png\"));\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "XWiki Platform is a generic wiki platform offering runtime services for applications built on top of it. Starting in version 3.5-milestone-1 and prior to versions 14.10.8 and 15.3-rc-1, triggering the office converter with a specially crafted file name allows writing the attachment's content to an attacker-controlled location on the server as long as the Java process has write access to that location. In particular in the combination with attachment moving, a feature introduced in XWiki 14.0, this is easy to reproduce but it also possible to reproduce in versions as old as XWiki 3.5 by uploading the attachment through the REST API which doesn't remove `/` or `\\` from the filename. As the mime type of the attachment doesn't matter for the exploitation, this could e.g., be used to replace the `jar`-file of an extension which would allow executing arbitrary Java code and thus impact the confidentiality, integrity and availability of the XWiki installation. This vulnerability has been patched in XWiki 14.10.8 and 15.3RC1. There are no known workarounds apart from disabling the office converter.",
    "id": 12420
  },
  {
    "cve_id": "CVE-2023-37913",
    "code_before_change": "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.doc;\n\nimport org.junit.jupiter.api.Test;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.test.junit5.mockito.InjectMockComponents;\n\nimport com.xpn.xwiki.test.MockitoOldcore;\nimport com.xpn.xwiki.test.junit5.mockito.OldcoreTest;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.mockito.ArgumentMatchers.anyString;\nimport static org.mockito.ArgumentMatchers.eq;\nimport static org.mockito.Mockito.doReturn;\n\n/**\n * Unit tests for {@link DefaultDocumentAccessBridge}.\n *\n * @version $Id$\n */\n@OldcoreTest\nclass DefaultDocumentAccessBridgeTest\n{\n    @InjectMockComponents\n    private DefaultDocumentAccessBridge documentAccessBridge;\n\n    @Test\n    void testGetUrlEmptyDocument(MockitoOldcore oldcore)\n    {\n        DocumentReference documentReference = new DocumentReference(\"Wiki\", \"Space\", \"Page\");\n        XWikiDocument document = new XWikiDocument(documentReference);\n        oldcore.getXWikiContext().setDoc(document);\n        String action = \"view\";\n        String expectedURL = \"/xwiki/bin/view/Main/WebHome\";\n        doReturn(expectedURL)\n            .when(oldcore.getSpyXWiki()).getURL(eq(document.getFullName()), eq(action), anyString(), anyString(),\n                eq(oldcore.getXWikiContext()));\n\n        assertEquals(expectedURL, this.documentAccessBridge.getURL(\"\", action, \"\", \"\"));\n        assertEquals(expectedURL, this.documentAccessBridge.getURL(null, action, \"\", \"\"));\n    }\n}\n",
    "code_after_change": "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.doc;\n\nimport java.io.ByteArrayInputStream;\n\nimport org.apache.commons.io.IOUtils;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.ValueSource;\nimport org.xwiki.model.reference.AttachmentReference;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.test.junit5.mockito.InjectMockComponents;\n\nimport com.xpn.xwiki.test.MockitoOldcore;\nimport com.xpn.xwiki.test.junit5.mockito.OldcoreTest;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.mockito.ArgumentMatchers.anyString;\nimport static org.mockito.ArgumentMatchers.eq;\nimport static org.mockito.Mockito.doReturn;\n\n/**\n * Unit tests for {@link DefaultDocumentAccessBridge}.\n *\n * @version $Id$\n */\n@OldcoreTest\nclass DefaultDocumentAccessBridgeTest\n{\n    @InjectMockComponents\n    private DefaultDocumentAccessBridge documentAccessBridge;\n\n    @Test\n    void testGetUrlEmptyDocument(MockitoOldcore oldcore)\n    {\n        DocumentReference documentReference = new DocumentReference(\"Wiki\", \"Space\", \"Page\");\n        XWikiDocument document = new XWikiDocument(documentReference);\n        oldcore.getXWikiContext().setDoc(document);\n        String action = \"view\";\n        String expectedURL = \"/xwiki/bin/view/Main/WebHome\";\n        doReturn(expectedURL)\n            .when(oldcore.getSpyXWiki()).getURL(eq(document.getFullName()), eq(action), anyString(), anyString(),\n                eq(oldcore.getXWikiContext()));\n\n        assertEquals(expectedURL, this.documentAccessBridge.getURL(\"\", action, \"\", \"\"));\n        assertEquals(expectedURL, this.documentAccessBridge.getURL(null, action, \"\", \"\"));\n    }\n\n    @ParameterizedTest\n    @ValueSource(booleans = { true, false })\n    void setAttachmentContent(boolean useStream, MockitoOldcore oldcore) throws Exception\n    {\n        DocumentReference documentReference = new DocumentReference(\"Wiki\", \"Space\", \"Page\");\n        String fileName = \"image.png\";\n        AttachmentReference attachmentReference = new AttachmentReference(fileName, documentReference);\n        byte[] attachmentContent = new byte[] { 42, 23 };\n        if (useStream) {\n            this.documentAccessBridge.setAttachmentContent(attachmentReference,\n                new ByteArrayInputStream(attachmentContent));\n        } else {\n            this.documentAccessBridge.setAttachmentContent(attachmentReference, attachmentContent);\n        }\n        XWikiDocument document = oldcore.getSpyXWiki().getDocument(documentReference, oldcore.getXWikiContext());\n        XWikiAttachment attachment = document.getAttachment(fileName);\n        assertNotNull(attachment);\n        assertEquals(fileName, attachment.getFilename());\n        assertArrayEquals(attachmentContent,\n            IOUtils.toByteArray(attachment.getAttachmentContent(oldcore.getXWikiContext()).getContentInputStream()));\n    }\n}\n",
    "patch": "@@ -19,14 +19,22 @@\n  */\n package com.xpn.xwiki.doc;\n \n+import java.io.ByteArrayInputStream;\n+\n+import org.apache.commons.io.IOUtils;\n import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+import org.xwiki.model.reference.AttachmentReference;\n import org.xwiki.model.reference.DocumentReference;\n import org.xwiki.test.junit5.mockito.InjectMockComponents;\n \n import com.xpn.xwiki.test.MockitoOldcore;\n import com.xpn.xwiki.test.junit5.mockito.OldcoreTest;\n \n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n import static org.mockito.ArgumentMatchers.anyString;\n import static org.mockito.ArgumentMatchers.eq;\n import static org.mockito.Mockito.doReturn;\n@@ -57,4 +65,26 @@ void testGetUrlEmptyDocument(MockitoOldcore oldcore)\n         assertEquals(expectedURL, this.documentAccessBridge.getURL(\"\", action, \"\", \"\"));\n         assertEquals(expectedURL, this.documentAccessBridge.getURL(null, action, \"\", \"\"));\n     }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = { true, false })\n+    void setAttachmentContent(boolean useStream, MockitoOldcore oldcore) throws Exception\n+    {\n+        DocumentReference documentReference = new DocumentReference(\"Wiki\", \"Space\", \"Page\");\n+        String fileName = \"image.png\";\n+        AttachmentReference attachmentReference = new AttachmentReference(fileName, documentReference);\n+        byte[] attachmentContent = new byte[] { 42, 23 };\n+        if (useStream) {\n+            this.documentAccessBridge.setAttachmentContent(attachmentReference,\n+                new ByteArrayInputStream(attachmentContent));\n+        } else {\n+            this.documentAccessBridge.setAttachmentContent(attachmentReference, attachmentContent);\n+        }\n+        XWikiDocument document = oldcore.getSpyXWiki().getDocument(documentReference, oldcore.getXWikiContext());\n+        XWikiAttachment attachment = document.getAttachment(fileName);\n+        assertNotNull(attachment);\n+        assertEquals(fileName, attachment.getFilename());\n+        assertArrayEquals(attachmentContent,\n+            IOUtils.toByteArray(attachment.getAttachmentContent(oldcore.getXWikiContext()).getContentInputStream()));\n+    }\n }",
    "function_modified_lines": {
      "added": [
        "import java.io.ByteArrayInputStream;\n",
        "\n",
        "import org.apache.commons.io.IOUtils;\n",
        "import org.junit.jupiter.params.ParameterizedTest;\n",
        "import org.junit.jupiter.params.provider.ValueSource;\n",
        "import org.xwiki.model.reference.AttachmentReference;\n",
        "import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n",
        "import static org.junit.jupiter.api.Assertions.assertNotNull;\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "XWiki Platform is a generic wiki platform offering runtime services for applications built on top of it. Starting in version 3.5-milestone-1 and prior to versions 14.10.8 and 15.3-rc-1, triggering the office converter with a specially crafted file name allows writing the attachment's content to an attacker-controlled location on the server as long as the Java process has write access to that location. In particular in the combination with attachment moving, a feature introduced in XWiki 14.0, this is easy to reproduce but it also possible to reproduce in versions as old as XWiki 3.5 by uploading the attachment through the REST API which doesn't remove `/` or `\\` from the filename. As the mime type of the attachment doesn't matter for the exploitation, this could e.g., be used to replace the `jar`-file of an extension which would allow executing arbitrary Java code and thus impact the confidentiality, integrity and availability of the XWiki installation. This vulnerability has been patched in XWiki 14.10.8 and 15.3RC1. There are no known workarounds apart from disabling the office converter.",
    "id": 12421
  },
  {
    "cve_id": "CVE-2023-37913",
    "code_before_change": "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.doc;\n\nimport org.junit.jupiter.api.Test;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.test.junit5.mockito.InjectMockComponents;\n\nimport com.xpn.xwiki.test.MockitoOldcore;\nimport com.xpn.xwiki.test.junit5.mockito.OldcoreTest;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.mockito.ArgumentMatchers.anyString;\nimport static org.mockito.ArgumentMatchers.eq;\nimport static org.mockito.Mockito.doReturn;\n\n/**\n * Unit tests for {@link DefaultDocumentAccessBridge}.\n *\n * @version $Id$\n */\n@OldcoreTest\nclass DefaultDocumentAccessBridgeTest\n{\n    @InjectMockComponents\n    private DefaultDocumentAccessBridge documentAccessBridge;\n\n    @Test\n    void testGetUrlEmptyDocument(MockitoOldcore oldcore)\n    {\n        DocumentReference documentReference = new DocumentReference(\"Wiki\", \"Space\", \"Page\");\n        XWikiDocument document = new XWikiDocument(documentReference);\n        oldcore.getXWikiContext().setDoc(document);\n        String action = \"view\";\n        String expectedURL = \"/xwiki/bin/view/Main/WebHome\";\n        doReturn(expectedURL)\n            .when(oldcore.getSpyXWiki()).getURL(eq(document.getFullName()), eq(action), anyString(), anyString(),\n                eq(oldcore.getXWikiContext()));\n\n        assertEquals(expectedURL, this.documentAccessBridge.getURL(\"\", action, \"\", \"\"));\n        assertEquals(expectedURL, this.documentAccessBridge.getURL(null, action, \"\", \"\"));\n    }\n}\n",
    "code_after_change": "{\n    @InjectMockComponents\n    private DefaultDocumentAccessBridge documentAccessBridge;\n\n    @Test\n    void testGetUrlEmptyDocument(MockitoOldcore oldcore)\n    {\n        DocumentReference documentReference = new DocumentReference(\"Wiki\", \"Space\", \"Page\");\n        XWikiDocument document = new XWikiDocument(documentReference);\n        oldcore.getXWikiContext().setDoc(document);\n        String action = \"view\";\n        String expectedURL = \"/xwiki/bin/view/Main/WebHome\";\n        doReturn(expectedURL)\n            .when(oldcore.getSpyXWiki()).getURL(eq(document.getFullName()), eq(action), anyString(), anyString(),\n                eq(oldcore.getXWikiContext()));\n\n        assertEquals(expectedURL, this.documentAccessBridge.getURL(\"\", action, \"\", \"\"));\n        assertEquals(expectedURL, this.documentAccessBridge.getURL(null, action, \"\", \"\"));\n    }\n\n    @ParameterizedTest\n    @ValueSource(booleans = { true, false })\n    void setAttachmentContent(boolean useStream, MockitoOldcore oldcore) throws Exception\n    {\n        DocumentReference documentReference = new DocumentReference(\"Wiki\", \"Space\", \"Page\");\n        String fileName = \"image.png\";\n        AttachmentReference attachmentReference = new AttachmentReference(fileName, documentReference);\n        byte[] attachmentContent = new byte[] { 42, 23 };\n        if (useStream) {\n            this.documentAccessBridge.setAttachmentContent(attachmentReference,\n                new ByteArrayInputStream(attachmentContent));\n        } else {\n            this.documentAccessBridge.setAttachmentContent(attachmentReference, attachmentContent);\n        }\n        XWikiDocument document = oldcore.getSpyXWiki().getDocument(documentReference, oldcore.getXWikiContext());\n        XWikiAttachment attachment = document.getAttachment(fileName);\n        assertNotNull(attachment);\n        assertEquals(fileName, attachment.getFilename());\n        assertArrayEquals(attachmentContent,\n            IOUtils.toByteArray(attachment.getAttachmentContent(oldcore.getXWikiContext()).getContentInputStream()));\n    }\n}",
    "patch": "@@ -19,14 +19,22 @@\n  */\n package com.xpn.xwiki.doc;\n \n+import java.io.ByteArrayInputStream;\n+\n+import org.apache.commons.io.IOUtils;\n import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+import org.xwiki.model.reference.AttachmentReference;\n import org.xwiki.model.reference.DocumentReference;\n import org.xwiki.test.junit5.mockito.InjectMockComponents;\n \n import com.xpn.xwiki.test.MockitoOldcore;\n import com.xpn.xwiki.test.junit5.mockito.OldcoreTest;\n \n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n import static org.mockito.ArgumentMatchers.anyString;\n import static org.mockito.ArgumentMatchers.eq;\n import static org.mockito.Mockito.doReturn;\n@@ -57,4 +65,26 @@ void testGetUrlEmptyDocument(MockitoOldcore oldcore)\n         assertEquals(expectedURL, this.documentAccessBridge.getURL(\"\", action, \"\", \"\"));\n         assertEquals(expectedURL, this.documentAccessBridge.getURL(null, action, \"\", \"\"));\n     }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = { true, false })\n+    void setAttachmentContent(boolean useStream, MockitoOldcore oldcore) throws Exception\n+    {\n+        DocumentReference documentReference = new DocumentReference(\"Wiki\", \"Space\", \"Page\");\n+        String fileName = \"image.png\";\n+        AttachmentReference attachmentReference = new AttachmentReference(fileName, documentReference);\n+        byte[] attachmentContent = new byte[] { 42, 23 };\n+        if (useStream) {\n+            this.documentAccessBridge.setAttachmentContent(attachmentReference,\n+                new ByteArrayInputStream(attachmentContent));\n+        } else {\n+            this.documentAccessBridge.setAttachmentContent(attachmentReference, attachmentContent);\n+        }\n+        XWikiDocument document = oldcore.getSpyXWiki().getDocument(documentReference, oldcore.getXWikiContext());\n+        XWikiAttachment attachment = document.getAttachment(fileName);\n+        assertNotNull(attachment);\n+        assertEquals(fileName, attachment.getFilename());\n+        assertArrayEquals(attachmentContent,\n+            IOUtils.toByteArray(attachment.getAttachmentContent(oldcore.getXWikiContext()).getContentInputStream()));\n+    }\n }",
    "function_modified_lines": {
      "added": [
        "\n",
        "    @ParameterizedTest\n",
        "    @ValueSource(booleans = { true, false })\n",
        "    void setAttachmentContent(boolean useStream, MockitoOldcore oldcore) throws Exception\n",
        "    {\n",
        "        DocumentReference documentReference = new DocumentReference(\"Wiki\", \"Space\", \"Page\");\n",
        "        String fileName = \"image.png\";\n",
        "        AttachmentReference attachmentReference = new AttachmentReference(fileName, documentReference);\n",
        "        byte[] attachmentContent = new byte[] { 42, 23 };\n",
        "        if (useStream) {\n",
        "            this.documentAccessBridge.setAttachmentContent(attachmentReference,\n",
        "                new ByteArrayInputStream(attachmentContent));\n",
        "        } else {\n",
        "            this.documentAccessBridge.setAttachmentContent(attachmentReference, attachmentContent);\n",
        "        }\n",
        "        XWikiDocument document = oldcore.getSpyXWiki().getDocument(documentReference, oldcore.getXWikiContext());\n",
        "        XWikiAttachment attachment = document.getAttachment(fileName);\n",
        "        assertNotNull(attachment);\n",
        "        assertEquals(fileName, attachment.getFilename());\n",
        "        assertArrayEquals(attachmentContent,\n",
        "            IOUtils.toByteArray(attachment.getAttachmentContent(oldcore.getXWikiContext()).getContentInputStream()));\n",
        "    }\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "XWiki Platform is a generic wiki platform offering runtime services for applications built on top of it. Starting in version 3.5-milestone-1 and prior to versions 14.10.8 and 15.3-rc-1, triggering the office converter with a specially crafted file name allows writing the attachment's content to an attacker-controlled location on the server as long as the Java process has write access to that location. In particular in the combination with attachment moving, a feature introduced in XWiki 14.0, this is easy to reproduce but it also possible to reproduce in versions as old as XWiki 3.5 by uploading the attachment through the REST API which doesn't remove `/` or `\\` from the filename. As the mime type of the attachment doesn't matter for the exploitation, this could e.g., be used to replace the `jar`-file of an extension which would allow executing arbitrary Java code and thus impact the confidentiality, integrity and availability of the XWiki installation. This vulnerability has been patched in XWiki 14.10.8 and 15.3RC1. There are no known workarounds apart from disabling the office converter.",
    "id": 12422
  },
  {
    "cve_id": "CVE-2023-37913",
    "code_before_change": "{\n        InputStream officeFileStream;\n        if (this.documentAccessBridge.getAttachmentVersion(attachmentReference) != null) {\n            officeFileStream = documentAccessBridge.getAttachmentContent(attachmentReference);\n        } else {\n            Optional<XWikiAttachment> uploadedAttachment =\n                this.temporaryAttachmentSessionsManager.getUploadedAttachment(attachmentReference);\n            if (uploadedAttachment.isPresent()) {\n                officeFileStream = uploadedAttachment.get().getContentInputStream(this.contextProvider.get());\n            } else {\n                throw new OfficeImporterException(\n                    String.format(\"Cannot find temporary uplodaded attachment [%s]\", attachmentReference));\n            }\n        }\n        String officeFileName = attachmentReference.getName();\n        DocumentReference targetDocRef = attachmentReference.getDocumentReference();\n        XDOMOfficeDocument xdomOfficeDocument;\n        if (isPresentation(attachmentReference.getName())) {\n            xdomOfficeDocument = presentationBuilder.build(officeFileStream, officeFileName, targetDocRef);\n        } else {\n            xdomOfficeDocument = documentBuilder.build(officeFileStream, officeFileName, targetDocRef, filterStyles);\n        }\n        // Attach the images extracted from the imported office document to the target wiki document.\n        for (File artifact : xdomOfficeDocument.getArtifactsFiles()) {\n\n            AttachmentReference artifactReference = new AttachmentReference(artifact.getName(), targetDocRef);\n            try (FileInputStream fis = new FileInputStream(artifact)) {\n                documentAccessBridge.setAttachmentContent(artifactReference, IOUtils.toByteArray(fis));\n            }\n        }\n        String result = xdomOfficeDocument.getContentAsString(\"annotatedxhtml/1.0\");\n        xdomOfficeDocument.close();\n        return result;\n    }",
    "code_after_change": "{\n        InputStream officeFileStream;\n        if (this.documentAccessBridge.getAttachmentVersion(attachmentReference) != null) {\n            officeFileStream = documentAccessBridge.getAttachmentContent(attachmentReference);\n        } else {\n            Optional<XWikiAttachment> uploadedAttachment =\n                this.temporaryAttachmentSessionsManager.getUploadedAttachment(attachmentReference);\n            if (uploadedAttachment.isPresent()) {\n                officeFileStream = uploadedAttachment.get().getContentInputStream(this.contextProvider.get());\n            } else {\n                throw new OfficeImporterException(\n                    String.format(\"Cannot find temporary uplodaded attachment [%s]\", attachmentReference));\n            }\n        }\n        String officeFileName = attachmentReference.getName();\n        DocumentReference targetDocRef = attachmentReference.getDocumentReference();\n        XDOMOfficeDocument xdomOfficeDocument;\n        if (isPresentation(attachmentReference.getName())) {\n            xdomOfficeDocument = presentationBuilder.build(officeFileStream, officeFileName, targetDocRef);\n        } else {\n            xdomOfficeDocument = documentBuilder.build(officeFileStream, officeFileName, targetDocRef, filterStyles);\n        }\n        // Attach the images extracted from the imported office document to the target wiki document.\n        for (Map.Entry<String, OfficeDocumentArtifact> entry : xdomOfficeDocument.getArtifactsMap().entrySet()) {\n            String filename = entry.getKey();\n            OfficeDocumentArtifact artifact = entry.getValue();\n            AttachmentReference artifactReference = new AttachmentReference(filename, targetDocRef);\n            try (InputStream is = artifact.getContentInputStream()) {\n                this.documentAccessBridge.setAttachmentContent(artifactReference, is);\n            }\n        }\n        String result = xdomOfficeDocument.getContentAsString(\"annotatedxhtml/1.0\");\n        xdomOfficeDocument.close();\n        return result;\n    }",
    "patch": "@@ -19,8 +19,6 @@\n  */\n package org.xwiki.wysiwyg.internal.importer;\n \n-import java.io.File;\n-import java.io.FileInputStream;\n import java.io.InputStream;\n import java.util.Map;\n import java.util.Optional;\n@@ -30,7 +28,6 @@\n import javax.inject.Provider;\n import javax.inject.Singleton;\n \n-import org.apache.commons.io.IOUtils;\n import org.xwiki.bridge.DocumentAccessBridge;\n import org.xwiki.component.annotation.Component;\n import org.xwiki.model.reference.AttachmentReference;\n@@ -39,6 +36,7 @@\n import org.xwiki.officeimporter.OfficeImporterException;\n import org.xwiki.officeimporter.builder.PresentationBuilder;\n import org.xwiki.officeimporter.builder.XDOMOfficeDocumentBuilder;\n+import org.xwiki.officeimporter.document.OfficeDocumentArtifact;\n import org.xwiki.officeimporter.document.XDOMOfficeDocument;\n import org.xwiki.officeimporter.server.OfficeServer;\n import org.xwiki.officeimporter.server.OfficeServer.ServerState;\n@@ -167,11 +165,12 @@ private String convertAttachmentContent(AttachmentReference attachmentReference,\n             xdomOfficeDocument = documentBuilder.build(officeFileStream, officeFileName, targetDocRef, filterStyles);\n         }\n         // Attach the images extracted from the imported office document to the target wiki document.\n-        for (File artifact : xdomOfficeDocument.getArtifactsFiles()) {\n-\n-            AttachmentReference artifactReference = new AttachmentReference(artifact.getName(), targetDocRef);\n-            try (FileInputStream fis = new FileInputStream(artifact)) {\n-                documentAccessBridge.setAttachmentContent(artifactReference, IOUtils.toByteArray(fis));\n+        for (Map.Entry<String, OfficeDocumentArtifact> entry : xdomOfficeDocument.getArtifactsMap().entrySet()) {\n+            String filename = entry.getKey();\n+            OfficeDocumentArtifact artifact = entry.getValue();\n+            AttachmentReference artifactReference = new AttachmentReference(filename, targetDocRef);\n+            try (InputStream is = artifact.getContentInputStream()) {\n+                this.documentAccessBridge.setAttachmentContent(artifactReference, is);\n             }\n         }\n         String result = xdomOfficeDocument.getContentAsString(\"annotatedxhtml/1.0\");",
    "function_modified_lines": {
      "added": [
        "        for (Map.Entry<String, OfficeDocumentArtifact> entry : xdomOfficeDocument.getArtifactsMap().entrySet()) {\n",
        "            String filename = entry.getKey();\n",
        "            OfficeDocumentArtifact artifact = entry.getValue();\n",
        "            AttachmentReference artifactReference = new AttachmentReference(filename, targetDocRef);\n",
        "            try (InputStream is = artifact.getContentInputStream()) {\n",
        "                this.documentAccessBridge.setAttachmentContent(artifactReference, is);\n"
      ],
      "deleted": [
        "        for (File artifact : xdomOfficeDocument.getArtifactsFiles()) {\n",
        "\n",
        "            AttachmentReference artifactReference = new AttachmentReference(artifact.getName(), targetDocRef);\n",
        "            try (FileInputStream fis = new FileInputStream(artifact)) {\n",
        "                documentAccessBridge.setAttachmentContent(artifactReference, IOUtils.toByteArray(fis));\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "XWiki Platform is a generic wiki platform offering runtime services for applications built on top of it. Starting in version 3.5-milestone-1 and prior to versions 14.10.8 and 15.3-rc-1, triggering the office converter with a specially crafted file name allows writing the attachment's content to an attacker-controlled location on the server as long as the Java process has write access to that location. In particular in the combination with attachment moving, a feature introduced in XWiki 14.0, this is easy to reproduce but it also possible to reproduce in versions as old as XWiki 3.5 by uploading the attachment through the REST API which doesn't remove `/` or `\\` from the filename. As the mime type of the attachment doesn't matter for the exploitation, this could e.g., be used to replace the `jar`-file of an extension which would allow executing arbitrary Java code and thus impact the confidentiality, integrity and availability of the XWiki installation. This vulnerability has been patched in XWiki 14.10.8 and 15.3RC1. There are no known workarounds apart from disabling the office converter.",
    "id": 12424
  },
  {
    "cve_id": "CVE-2021-39180",
    "code_before_change": "{\n\t\t\n\t\tVFSRepositoryService vfsRepositoryService = CoreSpringFactory.getImpl(VFSRepositoryService.class);\n\t\t\n\t\ttry(ZipInputStream oZip = new ZipInputStream(in)) {\n\t\t\t// unzip files\n\t\t\tZipEntry oEntr = oZip.getNextEntry();\n\t\t\twhile (oEntr != null) {\n\t\t\t\tif (oEntr.getName() != null && !oEntr.getName().startsWith(DIR_NAME__MACOSX)) {\n\t\t\t\t\tif (oEntr.isDirectory()) {\n\t\t\t\t\t\t// skip MacOSX specific metadata directory\n\t\t\t\t\t\t// create directories\n\t\t\t\t\t\tgetAllSubdirs(targetDir, oEntr.getName(), identity, true);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// create file\n\t\t\t\t\t\tVFSContainer createIn = targetDir;\n\t\t\t\t\t\tString name = oEntr.getName();\n\t\t\t\t\t\t// check if entry has directories which did not show up as\n\t\t\t\t\t\t// directories above\n\t\t\t\t\t\tint dirSepIndex = name.lastIndexOf('/');\n\t\t\t\t\t\tif (dirSepIndex == -1) {\n\t\t\t\t\t\t\t// try it windows style, backslash is also valid format\n\t\t\t\t\t\t\tdirSepIndex = name.lastIndexOf('\\\\');\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (dirSepIndex > 0) {\n\t\t\t\t\t\t\t// create subdirs\n\t\t\t\t\t\t\tcreateIn = getAllSubdirs(targetDir, name.substring(0, dirSepIndex), identity, true);\n\t\t\t\t\t\t\tif (createIn == null) {\n\t\t\t\t\t\t\t\tlog.debug(\"Error creating directory structure for zip entry: {}\", oEntr.getName());\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tname = name.substring(dirSepIndex + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(versioning) {\n\t\t\t\t\t\t\tVFSLeaf newEntry = (VFSLeaf)createIn.resolve(name);\n\t\t\t\t\t\t\tif(newEntry == null) {\n\t\t\t\t\t\t\t\tnewEntry = createIn.createChildLeaf(name);\n\t\t\t\t\t\t\t\tif (!copy(oZip, newEntry)) {\n\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (newEntry.canVersion() == VFSConstants.YES) {\n\t\t\t\t\t\t\t\tvfsRepositoryService.addVersion(newEntry, identity, \"\", oZip);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(newEntry != null && identity != null && newEntry.canMeta() == VFSConstants.YES) {\n\t\t\t\t\t\t\t\tVFSMetadata info = newEntry.getMetaInfo();\n\t\t\t\t\t\t\t\tif(info != null) {\n\t\t\t\t\t\t\t\t\tinfo.setAuthor(identity);\n\t\t\t\t\t\t\t\t\tvfsRepositoryService.updateMetadata(info);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tVFSLeaf newEntry = createIn.createChildLeaf(name);\n\t\t\t\t\t\t\tif (newEntry != null) {\n\t\t\t\t\t\t\t\tif (!copy(oZip, newEntry)) {\n\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t\t\t\tif(identity != null && newEntry.canMeta() == VFSConstants.YES) {\n\t\t\t\t\t\t\t\t\tVFSMetadata info = newEntry.getMetaInfo();\n\t\t\t\t\t\t\t\t\tif(info != null) {\n\t\t\t\t\t\t\t\t\t\tinfo.setAuthor(identity);\n\t\t\t\t\t\t\t\t\t\tvfsRepositoryService.updateMetadata(info);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\toZip.closeEntry();\n\t\t\t\toEntr = oZip.getNextEntry();\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}",
    "code_after_change": "{\n\t\t\n\t\tVFSRepositoryService vfsRepositoryService = CoreSpringFactory.getImpl(VFSRepositoryService.class);\n\n\t\ttry(ZipInputStream oZip = new ZipInputStream(in)) {\n\t\t\t// unzip files\n\t\t\tZipEntry oEntr = oZip.getNextEntry();\n\t\t\twhile (oEntr != null) {\n\t\t\t\tString name = oEntr.getName();\n\t\t\t\tif(!targetDir.isInPath(name)) {\n\t\t\t\t\tthrow new IOException(\"Invalip ZIP\");\n\t\t\t\t}\n\n\t\t\t\tif (name != null && !name.startsWith(DIR_NAME__MACOSX)) {\n\t\t\t\t\tif (oEntr.isDirectory()) {\n\t\t\t\t\t\t// skip MacOSX specific metadata directory\n\t\t\t\t\t\t// create directories\n\t\t\t\t\t\tgetAllSubdirs(targetDir, name, identity, true);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// create file\n\t\t\t\t\t\tVFSContainer createIn = targetDir;\n\t\t\t\t\t\t// check if entry has directories which did not show up as\n\t\t\t\t\t\t// directories above\n\t\t\t\t\t\tint dirSepIndex = name.lastIndexOf('/');\n\t\t\t\t\t\tif (dirSepIndex == -1) {\n\t\t\t\t\t\t\t// try it windows style, backslash is also valid format\n\t\t\t\t\t\t\tdirSepIndex = name.lastIndexOf('\\\\');\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (dirSepIndex > 0) {\n\t\t\t\t\t\t\t// create subdirs\n\t\t\t\t\t\t\tcreateIn = getAllSubdirs(targetDir, name.substring(0, dirSepIndex), identity, true);\n\t\t\t\t\t\t\tif (createIn == null) {\n\t\t\t\t\t\t\t\tlog.debug(\"Error creating directory structure for zip entry: {}\", oEntr.getName());\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tname = name.substring(dirSepIndex + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(versioning) {\n\t\t\t\t\t\t\tVFSLeaf newEntry = (VFSLeaf)createIn.resolve(name);\n\t\t\t\t\t\t\tif(newEntry == null) {\n\t\t\t\t\t\t\t\tnewEntry = createIn.createChildLeaf(name);\n\t\t\t\t\t\t\t\tif (!copy(oZip, newEntry)) {\n\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (newEntry.canVersion() == VFSConstants.YES) {\n\t\t\t\t\t\t\t\tvfsRepositoryService.addVersion(newEntry, identity, \"\", oZip);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(newEntry != null && identity != null && newEntry.canMeta() == VFSConstants.YES) {\n\t\t\t\t\t\t\t\tVFSMetadata info = newEntry.getMetaInfo();\n\t\t\t\t\t\t\t\tif(info != null) {\n\t\t\t\t\t\t\t\t\tinfo.setAuthor(identity);\n\t\t\t\t\t\t\t\t\tvfsRepositoryService.updateMetadata(info);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tVFSLeaf newEntry = createIn.createChildLeaf(name);\n\t\t\t\t\t\t\tif (newEntry != null) {\n\t\t\t\t\t\t\t\tif (!copy(oZip, newEntry)) {\n\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t\t\t\tif(identity != null && newEntry.canMeta() == VFSConstants.YES) {\n\t\t\t\t\t\t\t\t\tVFSMetadata info = newEntry.getMetaInfo();\n\t\t\t\t\t\t\t\t\tif(info != null) {\n\t\t\t\t\t\t\t\t\t\tinfo.setAuthor(identity);\n\t\t\t\t\t\t\t\t\t\tvfsRepositoryService.updateMetadata(info);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\toZip.closeEntry();\n\t\t\t\toEntr = oZip.getNextEntry();\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}",
    "patch": "@@ -37,6 +37,7 @@\n import java.nio.file.FileVisitResult;\n import java.nio.file.Files;\n import java.nio.file.Path;\n+import java.nio.file.Paths;\n import java.nio.file.SimpleFileVisitor;\n import java.nio.file.attribute.BasicFileAttributes;\n import java.util.ArrayList;\n@@ -188,20 +189,24 @@ public static boolean unzip(VFSLeaf zipLeaf, VFSContainer targetDir, Identity id\n \tprivate static boolean unzip(InputStream in, VFSContainer targetDir, Identity identity, boolean versioning) {\n \t\t\n \t\tVFSRepositoryService vfsRepositoryService = CoreSpringFactory.getImpl(VFSRepositoryService.class);\n-\t\t\n+\n \t\ttry(ZipInputStream oZip = new ZipInputStream(in)) {\n \t\t\t// unzip files\n \t\t\tZipEntry oEntr = oZip.getNextEntry();\n \t\t\twhile (oEntr != null) {\n-\t\t\t\tif (oEntr.getName() != null && !oEntr.getName().startsWith(DIR_NAME__MACOSX)) {\n+\t\t\t\tString name = oEntr.getName();\n+\t\t\t\tif(!targetDir.isInPath(name)) {\n+\t\t\t\t\tthrow new IOException(\"Invalip ZIP\");\n+\t\t\t\t}\n+\n+\t\t\t\tif (name != null && !name.startsWith(DIR_NAME__MACOSX)) {\n \t\t\t\t\tif (oEntr.isDirectory()) {\n \t\t\t\t\t\t// skip MacOSX specific metadata directory\n \t\t\t\t\t\t// create directories\n-\t\t\t\t\t\tgetAllSubdirs(targetDir, oEntr.getName(), identity, true);\n+\t\t\t\t\t\tgetAllSubdirs(targetDir, name, identity, true);\n \t\t\t\t\t} else {\n \t\t\t\t\t\t// create file\n \t\t\t\t\t\tVFSContainer createIn = targetDir;\n-\t\t\t\t\t\tString name = oEntr.getName();\n \t\t\t\t\t\t// check if entry has directories which did not show up as\n \t\t\t\t\t\t// directories above\n \t\t\t\t\t\tint dirSepIndex = name.lastIndexOf('/');\n@@ -317,7 +322,7 @@ private static boolean unzipNonStrict(InputStream in, VFSContainer targetDir, Id\n \t\t\tVFSRepositoryService vfsRepositoryService = CoreSpringFactory.getImpl(VFSRepositoryService.class);\n \t\t\t\n \t\t\t// unzip files\n-\t\t\tnet.sf.jazzlib.ZipEntry oEntr = oZip.getNextEntry();\n+\t\t\tnet.sf.jazzlib.ZipEntry oEntr = oZip.getNextEntry();//TODO zip\n \t\t\t\n \t\t\tVFSLeaf lastLeaf = null;\n \t\t\twhile (oEntr != null) {\n@@ -455,7 +460,7 @@ public static List<String> checkLockedFileBeforeUnzipNonStrict(VFSLeaf zipLeaf,\n \t\t\t\t\t\t// skip MacOSX specific metadata directory\n \t\t\t\t\t\t// directories aren't locked\n \t\t\t\t\t\toZip.closeEntry();\n-\t\t\t\t\t\toEntr = oZip.getNextEntry();\n+\t\t\t\t\t\toEntr = oZip.getNextEntry();//TODO zip\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\t} else {\n \t\t\t\t\t\t// search file\n@@ -847,9 +852,17 @@ public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IO\n \t * @param outdir, path to output directory, relative to cwd or absolute\n \t */\n \tprivate static void xxunzip(InputStream is, String outdir) throws IOException {\n+\t\tfinal Path outPath = Paths.get(outdir);\n+\t\t\n \t\ttry(ZipInputStream zis = new ZipInputStream (new BufferedInputStream(is))) {\n \t\t\tZipEntry entry;\n \t\t\twhile ((entry = zis.getNextEntry()) != null) {\n+\t\t\t\tPath filePath = Paths.get(outdir, entry.getName());\n+\t\t\t\tPath normalizedPath = filePath.normalize();\n+\t\t\t\tif(!normalizedPath.startsWith(outPath)) {\n+\t\t\t\t\tthrow new IOException(\"Invalid ZIP\");\n+\t\t\t\t}\n+\t\t\t\t\n \t\t\t\tFile of = new File(outdir, entry.getName());\n \t\t\t\tif (entry.isDirectory()) {\n \t\t\t\t\tof.mkdirs();",
    "function_modified_lines": {
      "added": [
        "\n",
        "\t\t\t\tString name = oEntr.getName();\n",
        "\t\t\t\tif(!targetDir.isInPath(name)) {\n",
        "\t\t\t\t\tthrow new IOException(\"Invalip ZIP\");\n",
        "\t\t\t\t}\n",
        "\n",
        "\t\t\t\tif (name != null && !name.startsWith(DIR_NAME__MACOSX)) {\n",
        "\t\t\t\t\t\tgetAllSubdirs(targetDir, name, identity, true);\n"
      ],
      "deleted": [
        "\t\t\n",
        "\t\t\t\tif (oEntr.getName() != null && !oEntr.getName().startsWith(DIR_NAME__MACOSX)) {\n",
        "\t\t\t\t\t\tgetAllSubdirs(targetDir, oEntr.getName(), identity, true);\n",
        "\t\t\t\t\t\tString name = oEntr.getName();\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "OpenOLAT is a web-based learning management system (LMS). A path traversal vulnerability exists in versions prior to 15.3.18, 15.5.3, and 16.0.0. Using a specially prepared ZIP file, it is possible to overwrite any file that is writable by the application server user (e.g. the tomcat user). Depending on the configuration this can be limited to files of the OpenOlat user data directory, however, if not properly set up, the attack could also be used to overwrite application server config files, java code or even operating system files. The attack could be used to corrupt or modify any OpenOlat file such as course structures, config files or temporary test data. Those attack would require in-depth knowledge of the installation and thus more theoretical. If the app server configuration allows the execution of jsp files and the path to the context is known, it is also possible to execute java code. If the app server runs with the same user that is used to deploy the OpenOlat code or has write permissions on the OpenOlat code files and the path to the context is know, code injection is possible. The attack requires an OpenOlat user account to upload a ZIP file and trigger the unzip method. It can not be exploited by unregistered users. The problem is fixed in versions 15.3.18, 15.5.3 and 16.0.0. There are no known workarounds aside from upgrading.",
    "id": 12517
  },
  {
    "cve_id": "CVE-2021-39180",
    "code_before_change": "{\n\n\tprivate VFSContainer delegate;\n\n\t/**\n\t * @param name\n\t * @param delegate\n\t */\n\tpublic NamedContainerImpl (String name, VFSContainer delegate) {\n\t\tsuper(name);\n\t\tthis.delegate = delegate;\n\t}\n\n\t@Override\n\tpublic boolean exists() {\n\t\tVFSContainer d = getDelegate();\n\t\treturn d != null && d.exists();\n\t}\n\t\n\t@Override\n\tpublic boolean isHidden() {\n\t\tVFSContainer d = getDelegate();\n\t\treturn d != null && d.isHidden();\n\t}\n\n\tpublic VFSContainer getDelegate() {\n\t\treturn delegate;\n\t}\n\t\n\tprotected void setDelegate(VFSContainer delegate) {\n\t\tthis.delegate = delegate;\n\t}\n\t\n\t@Override\n\tpublic VFSContainer getParentContainer() {\n\t\treturn getDelegate().getParentContainer();\n\t}\n\n\t@Override\n\tpublic void setParentContainer(VFSContainer parentContainer) {\n\t\tgetDelegate().setParentContainer(parentContainer);\n\t}\n\n\t@Override\n\tpublic List<VFSItem> getItems() {\n\t\treturn getDelegate().getItems();\n\t}\n\n\t@Override\n\tpublic List<VFSItem> getItems(VFSItemFilter filter) {\n\t\treturn getDelegate().getItems(filter);\n\t}\n\n\t@Override\n\tpublic VFSStatus copyFrom(VFSItem source) {\n\t\treturn getDelegate().copyFrom(source);\n\t}\n\n\t@Override\n\tpublic VFSStatus copyContentOf(VFSContainer container) {\n\t\treturn getDelegate().copyContentOf(container);\n\t}\n\n\t@Override\n\tpublic VFSStatus canWrite() {\n\t\treturn getDelegate().canWrite();\n\t}\n\n\t@Override\n\tpublic VFSStatus canCopy() {\n\t\treturn getDelegate().canCopy();\n\t}\n\n\t@Override\n\tpublic VFSStatus rename(String newname) {\n\t\treturn VFSConstants.NO;\n\t}\n\n\t@Override\n\tpublic String getRelPath() {\n\t\treturn getDelegate().getRelPath();\n\t}\n\n\t@Override\n\tpublic VFSStatus delete() {\n\t\treturn getDelegate().delete();\n\t}\n\n\t@Override\n\tpublic long getLastModified() {\n\t\treturn getDelegate().getLastModified();\n\t}\n\n\t/**\n\t * @see org.olat.core.util.vfs.VFSItem#resolveFile(java.lang.String) \n\t * <br />\n\t * Be aware that this method can return tricky values:\n\t * <ul>\n\t *   <li>If the path is '/', the named container itself is returned</li>\n\t *   <li>for child elements, the item of the delegate object is returned</li>\n\t * </ul>\n\t * In the second case, the returned item does not know anymore that it\n\t * was embedded in a named container. Thus, the isSame() method on the\n\t * root element of the resolved item is not the same as this object.\n\t */\n\t@Override\n\tpublic VFSItem resolve(String path) {\n\t\tpath = VFSManager.sanitizePath(path);\n\t\tif (path.equals(\"/\")) return this;\n\t\treturn getDelegate().resolve(path);\n\t}\n\n\t@Override\n\tpublic VFSContainer createChildContainer(String name) {\n\t\treturn getDelegate().createChildContainer(name);\n\t}\n\n\t@Override\n\tpublic VFSLeaf createChildLeaf(String name) {\n\t\treturn getDelegate().createChildLeaf(name);\n\t}\n\n\t@Override\n\tpublic VFSStatus canMeta() {\n\t\treturn getDelegate().canMeta();\n\t}\n\n\t@Override\n\tpublic VFSStatus canVersion() {\n\t\treturn getDelegate().canVersion();\n\t}\n\n\t@Override\n\tpublic VFSMetadata getMetaInfo() {\n\t\treturn getDelegate().getMetaInfo();\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"NamedContainer \" + getName() + \"-> \" + getDelegate().toString();\n\t}\n\n\t@Override\n\tpublic VFSSecurityCallback getLocalSecurityCallback() {\n\t\treturn getDelegate().getLocalSecurityCallback();\n\t}\n\n\t@Override\n\tpublic void setLocalSecurityCallback(VFSSecurityCallback secCallback) {\n\t\tgetDelegate().setLocalSecurityCallback(secCallback);\n\t}\n\n\t@Override\n\tpublic boolean isSame(VFSItem vfsItem) {\n\t\treturn getDelegate().isSame(vfsItem);\n\t}\n\n\t@Override\n\tpublic void setDefaultItemFilter(VFSItemFilter defaultFilter) {\n\t\tgetDelegate().setDefaultItemFilter(defaultFilter);\n\t}\n\n\t@Override\n\tpublic VFSItemFilter getDefaultItemFilter() {\n\t\treturn getDelegate().getDefaultItemFilter();\n\t}\n\n}",
    "code_after_change": "{\n\n\tprivate VFSContainer delegate;\n\n\t/**\n\t * @param name\n\t * @param delegate\n\t */\n\tpublic NamedContainerImpl (String name, VFSContainer delegate) {\n\t\tsuper(name);\n\t\tthis.delegate = delegate;\n\t}\n\n\t@Override\n\tpublic boolean exists() {\n\t\tVFSContainer d = getDelegate();\n\t\treturn d != null && d.exists();\n\t}\n\t\n\t@Override\n\tpublic boolean isHidden() {\n\t\tVFSContainer d = getDelegate();\n\t\treturn d != null && d.isHidden();\n\t}\n\n\tpublic VFSContainer getDelegate() {\n\t\treturn delegate;\n\t}\n\t\n\tprotected void setDelegate(VFSContainer delegate) {\n\t\tthis.delegate = delegate;\n\t}\n\t\n\t@Override\n\tpublic VFSContainer getParentContainer() {\n\t\treturn getDelegate().getParentContainer();\n\t}\n\n\t@Override\n\tpublic void setParentContainer(VFSContainer parentContainer) {\n\t\tgetDelegate().setParentContainer(parentContainer);\n\t}\n\n\t@Override\n\tpublic List<VFSItem> getItems() {\n\t\treturn getDelegate().getItems();\n\t}\n\n\t@Override\n\tpublic List<VFSItem> getItems(VFSItemFilter filter) {\n\t\treturn getDelegate().getItems(filter);\n\t}\n\n\t@Override\n\tpublic VFSStatus copyFrom(VFSItem source) {\n\t\treturn getDelegate().copyFrom(source);\n\t}\n\n\t@Override\n\tpublic VFSStatus copyContentOf(VFSContainer container) {\n\t\treturn getDelegate().copyContentOf(container);\n\t}\n\n\t@Override\n\tpublic VFSStatus canWrite() {\n\t\treturn getDelegate().canWrite();\n\t}\n\n\t@Override\n\tpublic VFSStatus canCopy() {\n\t\treturn getDelegate().canCopy();\n\t}\n\n\t@Override\n\tpublic VFSStatus rename(String newname) {\n\t\treturn VFSConstants.NO;\n\t}\n\n\t@Override\n\tpublic String getRelPath() {\n\t\treturn getDelegate().getRelPath();\n\t}\n\n\t@Override\n\tpublic boolean isInPath(String path) {\n\t\treturn getDelegate().isInPath(path);\n\t}\n\n\t@Override\n\tpublic VFSStatus delete() {\n\t\treturn getDelegate().delete();\n\t}\n\n\t@Override\n\tpublic long getLastModified() {\n\t\treturn getDelegate().getLastModified();\n\t}\n\n\t/**\n\t * @see org.olat.core.util.vfs.VFSItem#resolveFile(java.lang.String) \n\t * <br />\n\t * Be aware that this method can return tricky values:\n\t * <ul>\n\t *   <li>If the path is '/', the named container itself is returned</li>\n\t *   <li>for child elements, the item of the delegate object is returned</li>\n\t * </ul>\n\t * In the second case, the returned item does not know anymore that it\n\t * was embedded in a named container. Thus, the isSame() method on the\n\t * root element of the resolved item is not the same as this object.\n\t */\n\t@Override\n\tpublic VFSItem resolve(String path) {\n\t\tpath = VFSManager.sanitizePath(path);\n\t\tif (path.equals(\"/\")) return this;\n\t\treturn getDelegate().resolve(path);\n\t}\n\n\t@Override\n\tpublic VFSContainer createChildContainer(String name) {\n\t\treturn getDelegate().createChildContainer(name);\n\t}\n\n\t@Override\n\tpublic VFSLeaf createChildLeaf(String name) {\n\t\treturn getDelegate().createChildLeaf(name);\n\t}\n\n\t@Override\n\tpublic VFSStatus canMeta() {\n\t\treturn getDelegate().canMeta();\n\t}\n\n\t@Override\n\tpublic VFSStatus canVersion() {\n\t\treturn getDelegate().canVersion();\n\t}\n\n\t@Override\n\tpublic VFSMetadata getMetaInfo() {\n\t\treturn getDelegate().getMetaInfo();\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"NamedContainer \" + getName() + \"-> \" + getDelegate().toString();\n\t}\n\n\t@Override\n\tpublic VFSSecurityCallback getLocalSecurityCallback() {\n\t\treturn getDelegate().getLocalSecurityCallback();\n\t}\n\n\t@Override\n\tpublic void setLocalSecurityCallback(VFSSecurityCallback secCallback) {\n\t\tgetDelegate().setLocalSecurityCallback(secCallback);\n\t}\n\n\t@Override\n\tpublic boolean isSame(VFSItem vfsItem) {\n\t\treturn getDelegate().isSame(vfsItem);\n\t}\n\n\t@Override\n\tpublic void setDefaultItemFilter(VFSItemFilter defaultFilter) {\n\t\tgetDelegate().setDefaultItemFilter(defaultFilter);\n\t}\n\n\t@Override\n\tpublic VFSItemFilter getDefaultItemFilter() {\n\t\treturn getDelegate().getDefaultItemFilter();\n\t}\n\n}",
    "patch": "@@ -121,6 +121,11 @@ public String getRelPath() {\n \t\treturn getDelegate().getRelPath();\n \t}\n \n+\t@Override\n+\tpublic boolean isInPath(String path) {\n+\t\treturn getDelegate().isInPath(path);\n+\t}\n+\n \t@Override\n \tpublic VFSStatus delete() {\n \t\treturn getDelegate().delete();",
    "function_modified_lines": {
      "added": [
        "\t@Override\n",
        "\tpublic boolean isInPath(String path) {\n",
        "\t\treturn getDelegate().isInPath(path);\n",
        "\t}\n",
        "\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "OpenOLAT is a web-based learning management system (LMS). A path traversal vulnerability exists in versions prior to 15.3.18, 15.5.3, and 16.0.0. Using a specially prepared ZIP file, it is possible to overwrite any file that is writable by the application server user (e.g. the tomcat user). Depending on the configuration this can be limited to files of the OpenOlat user data directory, however, if not properly set up, the attack could also be used to overwrite application server config files, java code or even operating system files. The attack could be used to corrupt or modify any OpenOlat file such as course structures, config files or temporary test data. Those attack would require in-depth knowledge of the installation and thus more theoretical. If the app server configuration allows the execution of jsp files and the path to the context is known, it is also possible to execute java code. If the app server runs with the same user that is used to deploy the OpenOlat code or has write permissions on the OpenOlat code files and the path to the context is know, code injection is possible. The attack requires an OpenOlat user account to upload a ZIP file and trigger the unzip method. It can not be exploited by unregistered users. The problem is fixed in versions 15.3.18, 15.5.3 and 16.0.0. There are no known workarounds aside from upgrading.",
    "id": 12520
  },
  {
    "cve_id": "CVE-2021-39180",
    "code_before_change": "{\n\n\t/**\n\t * @return a list of VFSItem containing \n\t */\n\tpublic List<VFSItem> getItems();\n\t\n\t/**\n\t * @return a list of VFSItem which are accepted by the given filter. If a\n\t *         default filter is set, the default filter will be applied in\n\t *         addition to the given filter in this method\n\t */\n\tpublic List<VFSItem> getItems(VFSItemFilter filter);\n\t\n\t/**\n\t * copy either a file or a folder to this folder.\n\t * e.g. this folder is based at /bla/blu, copying source bli (from /whatever/bli) \n\t * will add a child bli, so it looks like /bla/blu/bli later.\n\t * the operation fails when\n\t * the source or target do not support canCopyFrom and canCopyTo, resp., or\n\t * there is already a child with the same name, or the quota would be exceeded.\n\t * \n\t * @param source the source (must exist)\n\t * @return the status\n\t */\n\tpublic VFSStatus copyFrom(VFSItem source);\n\t\n\t/**\n\t * \n\t * @param container\n\t * @return\n\t */\n\tpublic VFSStatus copyContentOf(VFSContainer container);\n\n\t/**\n\t * Create a new child container (of same type) if possible.\n\t * \n\t * @param name\n\t * @return VFSItem if successfull, null otherwise.\n\t */\n\tpublic VFSContainer createChildContainer(String name);\n\t\n\t/**\n\t * Create a new leaf (of same type) if possible,\n\t * @param name\n\t * @return VFSItem if successfull, null otherwise.\n\t */\n\tpublic VFSLeaf createChildLeaf(String name);\n\t\n\t/**\n\t * Set a default filter that will be applied to this container getItems method\n\t * \n\t * @param defaultFilter\n\t */\n\tpublic void setDefaultItemFilter(VFSItemFilter defaultFilter);\n\n\t/**\n\t * @return The default filter for this container or NULL if no filter is set\n\t */\n\tpublic VFSItemFilter getDefaultItemFilter();\n\n}",
    "code_after_change": "{\n\n\t/**\n\t * @return a list of VFSItem containing \n\t */\n\tpublic List<VFSItem> getItems();\n\t\n\t/**\n\t * @return a list of VFSItem which are accepted by the given filter. If a\n\t *         default filter is set, the default filter will be applied in\n\t *         addition to the given filter in this method\n\t */\n\tpublic List<VFSItem> getItems(VFSItemFilter filter);\n\t\n\t/**\n\t * copy either a file or a folder to this folder.\n\t * e.g. this folder is based at /bla/blu, copying source bli (from /whatever/bli) \n\t * will add a child bli, so it looks like /bla/blu/bli later.\n\t * the operation fails when\n\t * the source or target do not support canCopyFrom and canCopyTo, resp., or\n\t * there is already a child with the same name, or the quota would be exceeded.\n\t * \n\t * @param source the source (must exist)\n\t * @return the status\n\t */\n\tpublic VFSStatus copyFrom(VFSItem source);\n\t\n\t/**\n\t * \n\t * @param container\n\t * @return\n\t */\n\tpublic VFSStatus copyContentOf(VFSContainer container);\n\n\t/**\n\t * Create a new child container (of same type) if possible.\n\t * \n\t * @param name\n\t * @return VFSItem if successfull, null otherwise.\n\t */\n\tpublic VFSContainer createChildContainer(String name);\n\t\n\t/**\n\t * Create a new leaf (of same type) if possible,\n\t * @param name\n\t * @return VFSItem if successfull, null otherwise.\n\t */\n\tpublic VFSLeaf createChildLeaf(String name);\n\t\n\t/**\n\t * \n\t * @param path\n\t * @return\n\t */\n\tpublic boolean isInPath(String path);\n\t\n\t/**\n\t * Set a default filter that will be applied to this container getItems method\n\t * \n\t * @param defaultFilter\n\t */\n\tpublic void setDefaultItemFilter(VFSItemFilter defaultFilter);\n\n\t/**\n\t * @return The default filter for this container or NULL if no filter is set\n\t */\n\tpublic VFSItemFilter getDefaultItemFilter();\n\n}",
    "patch": "@@ -86,6 +86,13 @@ public interface VFSContainer extends VFSItem {\n \t */\n \tpublic VFSLeaf createChildLeaf(String name);\n \t\n+\t/**\n+\t * \n+\t * @param path\n+\t * @return\n+\t */\n+\tpublic boolean isInPath(String path);\n+\t\n \t/**\n \t * Set a default filter that will be applied to this container getItems method\n \t * ",
    "function_modified_lines": {
      "added": [
        "\t/**\n",
        "\t * \n",
        "\t * @param path\n",
        "\t * @return\n",
        "\t */\n",
        "\tpublic boolean isInPath(String path);\n",
        "\t\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "OpenOLAT is a web-based learning management system (LMS). A path traversal vulnerability exists in versions prior to 15.3.18, 15.5.3, and 16.0.0. Using a specially prepared ZIP file, it is possible to overwrite any file that is writable by the application server user (e.g. the tomcat user). Depending on the configuration this can be limited to files of the OpenOlat user data directory, however, if not properly set up, the attack could also be used to overwrite application server config files, java code or even operating system files. The attack could be used to corrupt or modify any OpenOlat file such as course structures, config files or temporary test data. Those attack would require in-depth knowledge of the installation and thus more theoretical. If the app server configuration allows the execution of jsp files and the path to the context is known, it is also possible to execute java code. If the app server runs with the same user that is used to deploy the OpenOlat code or has write permissions on the OpenOlat code files and the path to the context is know, code injection is possible. The attack requires an OpenOlat user account to upload a ZIP file and trigger the unzip method. It can not be exploited by unregistered users. The problem is fixed in versions 15.3.18, 15.5.3 and 16.0.0. There are no known workarounds aside from upgrading.",
    "id": 12521
  },
  {
    "cve_id": "CVE-2021-39180",
    "code_before_change": "{\n\n\tprivate final List<VFSItem> children = new ArrayList<>();\n\tprivate VFSSecurityCallback secCallback = null;\n\tprivate VFSContainer parentContainer;\n\t\t\n\tpublic VirtualContainer(String name) {\n\t\tsuper(name);\n\t}\t\n\t\n\t@Override\n\tpublic boolean exists() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean isHidden() {\n\t\treturn false;\n\t}\n\n\t/**\n\t * Add a VFSItem to this CirtualContainer.\n\t * @param vfsItem\n\t */\n\tpublic void addItem(VFSItem vfsItem) {\n\t\tchildren.add(vfsItem);\n\t}\n\n\t@Override\n\tpublic List<VFSItem> getItems() {\n\t\treturn children;\n\t}\n\n\t@Override\n\tpublic List<VFSItem> getItems(VFSItemFilter filter) {\n\t\tif (filter == null) {\n\t\t\treturn children;\n\t\t} else {\n\t\t\tList<VFSItem> filtered = new ArrayList<>(children.size());\n\t\t\tfor (VFSItem vfsItem : children) {\n\t\t\t\tif (filter.accept(vfsItem)) {\n\t\t\t\t\tfiltered.add(vfsItem);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn filtered;\n\t\t}\n\t}\n\n\t@Override\n\tpublic VFSStatus canWrite() {\n\t\treturn VFSConstants.NO;\n\t}\n\n\t@Override\n\tpublic VFSSecurityCallback getLocalSecurityCallback() {\n\t\treturn secCallback;\n\t}\n\n\t@Override\n\tpublic VFSContainer getParentContainer() {\n\t\treturn parentContainer;\n\t}\n\n\t@Override\n\tpublic boolean isSame(VFSItem vfsItem) {\n\t\treturn (this == vfsItem);\n\t}\n\n\t@Override\n\tpublic String getRelPath() {\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic VFSItem resolve(String path) {\n\t\tif(path != null && path.length() > 1 && path.startsWith(\"/\")) {\n\t\t\tString childName = VFSManager.extractChild(path);\n\t\t\tString nextPath = path.substring(childName.length() + 1);\n\t\t\t// simple optimized case\n\t\t\tfor (VFSItem container:children) {\n\t\t\t\tif (container.getName().equals(childName)) {\n\t\t\t\t\tVFSItem vfsItem = container.resolve(nextPath);\n\t\t\t\t\t// set default filter on resolved file if it is a container\n\t\t\t\t\tif (vfsItem != null && vfsItem instanceof VFSContainer) {\n\t\t\t\t\t\tVFSContainer resolvedContainer = (VFSContainer) vfsItem;\n\t\t\t\t\t\tresolvedContainer.setDefaultItemFilter(defaultFilter);\n\t\t\t\t\t}\n\t\t\t\t\treturn vfsItem;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn VFSManager.resolveFile(this, path);\n\t}\n\n\t@Override\n\tpublic void setLocalSecurityCallback(VFSSecurityCallback secCallback) {\n\t\tthis.secCallback = secCallback;\n\t}\n\n\t@Override\n\tpublic void setParentContainer(VFSContainer parentContainer) {\n\t\tthis.parentContainer = parentContainer;\n\t}\n}",
    "code_after_change": "{\n\n\tprivate final List<VFSItem> children = new ArrayList<>();\n\tprivate VFSSecurityCallback secCallback = null;\n\tprivate VFSContainer parentContainer;\n\t\t\n\tpublic VirtualContainer(String name) {\n\t\tsuper(name);\n\t}\t\n\t\n\t@Override\n\tpublic boolean exists() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean isHidden() {\n\t\treturn false;\n\t}\n\n\t/**\n\t * Add a VFSItem to this CirtualContainer.\n\t * @param vfsItem\n\t */\n\tpublic void addItem(VFSItem vfsItem) {\n\t\tchildren.add(vfsItem);\n\t}\n\n\t@Override\n\tpublic List<VFSItem> getItems() {\n\t\treturn children;\n\t}\n\n\t@Override\n\tpublic List<VFSItem> getItems(VFSItemFilter filter) {\n\t\tif (filter == null) {\n\t\t\treturn children;\n\t\t} else {\n\t\t\tList<VFSItem> filtered = new ArrayList<>(children.size());\n\t\t\tfor (VFSItem vfsItem : children) {\n\t\t\t\tif (filter.accept(vfsItem)) {\n\t\t\t\t\tfiltered.add(vfsItem);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn filtered;\n\t\t}\n\t}\n\n\t@Override\n\tpublic VFSStatus canWrite() {\n\t\treturn VFSConstants.NO;\n\t}\n\n\t@Override\n\tpublic VFSSecurityCallback getLocalSecurityCallback() {\n\t\treturn secCallback;\n\t}\n\n\t@Override\n\tpublic VFSContainer getParentContainer() {\n\t\treturn parentContainer;\n\t}\n\n\t@Override\n\tpublic boolean isSame(VFSItem vfsItem) {\n\t\treturn (this == vfsItem);\n\t}\n\n\t@Override\n\tpublic String getRelPath() {\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic boolean isInPath(String path) {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic VFSItem resolve(String path) {\n\t\tif(path != null && path.length() > 1 && path.startsWith(\"/\")) {\n\t\t\tString childName = VFSManager.extractChild(path);\n\t\t\tString nextPath = path.substring(childName.length() + 1);\n\t\t\t// simple optimized case\n\t\t\tfor (VFSItem container:children) {\n\t\t\t\tif (container.getName().equals(childName)) {\n\t\t\t\t\tVFSItem vfsItem = container.resolve(nextPath);\n\t\t\t\t\t// set default filter on resolved file if it is a container\n\t\t\t\t\tif (vfsItem != null && vfsItem instanceof VFSContainer) {\n\t\t\t\t\t\tVFSContainer resolvedContainer = (VFSContainer) vfsItem;\n\t\t\t\t\t\tresolvedContainer.setDefaultItemFilter(defaultFilter);\n\t\t\t\t\t}\n\t\t\t\t\treturn vfsItem;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn VFSManager.resolveFile(this, path);\n\t}\n\n\t@Override\n\tpublic void setLocalSecurityCallback(VFSSecurityCallback secCallback) {\n\t\tthis.secCallback = secCallback;\n\t}\n\n\t@Override\n\tpublic void setParentContainer(VFSContainer parentContainer) {\n\t\tthis.parentContainer = parentContainer;\n\t}\n}",
    "patch": "@@ -105,6 +105,11 @@ public String getRelPath() {\n \t\treturn null;\n \t}\n \n+\t@Override\n+\tpublic boolean isInPath(String path) {\n+\t\treturn false;\n+\t}\n+\n \t@Override\n \tpublic VFSItem resolve(String path) {\n \t\tif(path != null && path.length() > 1 && path.startsWith(\"/\")) {",
    "function_modified_lines": {
      "added": [
        "\t@Override\n",
        "\tpublic boolean isInPath(String path) {\n",
        "\t\treturn false;\n",
        "\t}\n",
        "\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "OpenOLAT is a web-based learning management system (LMS). A path traversal vulnerability exists in versions prior to 15.3.18, 15.5.3, and 16.0.0. Using a specially prepared ZIP file, it is possible to overwrite any file that is writable by the application server user (e.g. the tomcat user). Depending on the configuration this can be limited to files of the OpenOlat user data directory, however, if not properly set up, the attack could also be used to overwrite application server config files, java code or even operating system files. The attack could be used to corrupt or modify any OpenOlat file such as course structures, config files or temporary test data. Those attack would require in-depth knowledge of the installation and thus more theoretical. If the app server configuration allows the execution of jsp files and the path to the context is known, it is also possible to execute java code. If the app server runs with the same user that is used to deploy the OpenOlat code or has write permissions on the OpenOlat code files and the path to the context is know, code injection is possible. The attack requires an OpenOlat user account to upload a ZIP file and trigger the unzip method. It can not be exploited by unregistered users. The problem is fixed in versions 15.3.18, 15.5.3 and 16.0.0. There are no known workarounds aside from upgrading.",
    "id": 12522
  },
  {
    "cve_id": "CVE-2021-39180",
    "code_before_change": "{\n\t\n\tprivate static final Logger log = Tracing.createLoggerFor(VFSCPContainer.class);\n\t\n\tprivate VFSSecurityCallback secCallback;\n\tprivate final CPTreeDataModel treeModel;\n\tprivate final ContentPackage cp;\n\tprivate String rootNodeId;\n\t\n\tpublic VFSCPContainer(String name, ContentPackage cp) {\n\t\tsuper(name);\n\t\t\n\t\tString orgaIdentifier = cp.getFirstOrganizationInManifest().getIdentifier();\n\t\trootNodeId = Encoder.md5hash(orgaIdentifier);\n\n\t\tthis.cp = cp;\n\t\tCPManager cpMgm = CoreSpringFactory.getImpl(CPManager.class);\n\t\ttreeModel = cpMgm.getTreeDataModel(cp);\n\t}\n\n\t@Override\n\tpublic boolean exists() {\n\t\treturn true;\n\t}\n\t\n\t@Override\n\tpublic boolean isHidden() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean isSame(VFSItem vfsItem) {\n\t\treturn this == vfsItem;\n\t}\n\t\n\t@Override\n\tpublic VFSItem resolve(String path) {\n\t\tif(path == null || path.length() == 0 || path.equals(\"/\")) {\n\t\t\treturn this;\n\t\t}\n\t\treturn VFSManager.resolveFile(this, path);\n\t}\n\n\t@Override\n\tpublic String getRelPath() {\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic List<VFSItem> getItems() {\n\t\treturn getItems(cp, treeModel, rootNodeId);\n\t}\n\n\tprotected static List<VFSItem> getItems(ContentPackage cp, CPTreeDataModel model, String nodeId) {\n\t\tList<TreeNode> nodes = model.getChildrenFor(nodeId);\n\t\tList<VFSItem> items = new ArrayList<>(nodes.size());\n\t\t\n\t\tif(!nodes.isEmpty()) {\n\t\t\tCPManager cpMgm = CoreSpringFactory.getImpl(CPManager.class);\n\t\t\tfor(TreeNode node:nodes) {\n\t\t\t\ttry {\n\t\t\t\t\tString nid = node.getIdent();\n\t\t\t\t\tString id = model.getIdentifierForNodeID(nid);\n\t\t\t\t\tString filePath = cpMgm.getPageByItemId(cp, id);\n\t\t\t\t\tString title = cpMgm.getItemTitle(cp, id);\n\t\t\t\t\tVFSItem f = cp.getRootDir().resolve(filePath);\n\t\t\t\t\tif(f instanceof VFSLeaf) {\n\t\t\t\t\t\ttitle += \" (\" + filePath + \")\";\n\t\t\t\t\t\t\n\t\t\t\t\t\tVFSItem item;\n\t\t\t\t\t\tList<TreeNode> children = model.getChildrenFor(nid);\n\t\t\t\t\t\tif(children.isEmpty()) {\n\t\t\t\t\t\t\titem = new VFSCPNamedItem(title, (VFSLeaf)f);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\titem = new VFSCPNamedContainerItem(nid, title, (VFSLeaf)f, cp, model);\n\t\t\t\t\t\t}\n\t\t\t\t\t\titems.add(item);\n\t\t\t\t\t}\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tlog.error(\"\", e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn items;\n\t}\n\n\t@Override\n\tpublic List<VFSItem> getItems(VFSItemFilter filter) {\n\t\treturn getItems();\n\t}\n\n\t@Override\n\tpublic VFSContainer getParentContainer() {\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic void setParentContainer(VFSContainer parentContainer) {\n\t\t//\n\t}\n\n\t@Override\n\tpublic VFSStatus canWrite() {\n\t\treturn VFSConstants.NO;\n\t}\n\n\t@Override\n\tpublic VFSSecurityCallback getLocalSecurityCallback() {\n\t\treturn secCallback;\n\t}\n\n\t@Override\n\tpublic void setLocalSecurityCallback(VFSSecurityCallback secCallback) {\n\t\tthis.secCallback = secCallback;\n\t}\n}",
    "code_after_change": "{\n\t\n\tprivate static final Logger log = Tracing.createLoggerFor(VFSCPContainer.class);\n\t\n\tprivate VFSSecurityCallback secCallback;\n\tprivate final CPTreeDataModel treeModel;\n\tprivate final ContentPackage cp;\n\tprivate String rootNodeId;\n\t\n\tpublic VFSCPContainer(String name, ContentPackage cp) {\n\t\tsuper(name);\n\t\t\n\t\tString orgaIdentifier = cp.getFirstOrganizationInManifest().getIdentifier();\n\t\trootNodeId = Encoder.md5hash(orgaIdentifier);\n\n\t\tthis.cp = cp;\n\t\tCPManager cpMgm = CoreSpringFactory.getImpl(CPManager.class);\n\t\ttreeModel = cpMgm.getTreeDataModel(cp);\n\t}\n\n\t@Override\n\tpublic boolean exists() {\n\t\treturn true;\n\t}\n\t\n\t@Override\n\tpublic boolean isHidden() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean isSame(VFSItem vfsItem) {\n\t\treturn this == vfsItem;\n\t}\n\t\n\t@Override\n\tpublic VFSItem resolve(String path) {\n\t\tif(path == null || path.length() == 0 || path.equals(\"/\")) {\n\t\t\treturn this;\n\t\t}\n\t\treturn VFSManager.resolveFile(this, path);\n\t}\n\n\t@Override\n\tpublic String getRelPath() {\n\t\treturn null;\n\t}\n\t\n\t@Override\n\tpublic boolean isInPath(String path) {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic List<VFSItem> getItems() {\n\t\treturn getItems(cp, treeModel, rootNodeId);\n\t}\n\n\tprotected static List<VFSItem> getItems(ContentPackage cp, CPTreeDataModel model, String nodeId) {\n\t\tList<TreeNode> nodes = model.getChildrenFor(nodeId);\n\t\tList<VFSItem> items = new ArrayList<>(nodes.size());\n\t\t\n\t\tif(!nodes.isEmpty()) {\n\t\t\tCPManager cpMgm = CoreSpringFactory.getImpl(CPManager.class);\n\t\t\tfor(TreeNode node:nodes) {\n\t\t\t\ttry {\n\t\t\t\t\tString nid = node.getIdent();\n\t\t\t\t\tString id = model.getIdentifierForNodeID(nid);\n\t\t\t\t\tString filePath = cpMgm.getPageByItemId(cp, id);\n\t\t\t\t\tString title = cpMgm.getItemTitle(cp, id);\n\t\t\t\t\tVFSItem f = cp.getRootDir().resolve(filePath);\n\t\t\t\t\tif(f instanceof VFSLeaf) {\n\t\t\t\t\t\ttitle += \" (\" + filePath + \")\";\n\t\t\t\t\t\t\n\t\t\t\t\t\tVFSItem item;\n\t\t\t\t\t\tList<TreeNode> children = model.getChildrenFor(nid);\n\t\t\t\t\t\tif(children.isEmpty()) {\n\t\t\t\t\t\t\titem = new VFSCPNamedItem(title, (VFSLeaf)f);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\titem = new VFSCPNamedContainerItem(nid, title, (VFSLeaf)f, cp, model);\n\t\t\t\t\t\t}\n\t\t\t\t\t\titems.add(item);\n\t\t\t\t\t}\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tlog.error(\"\", e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn items;\n\t}\n\n\t@Override\n\tpublic List<VFSItem> getItems(VFSItemFilter filter) {\n\t\treturn getItems();\n\t}\n\n\t@Override\n\tpublic VFSContainer getParentContainer() {\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic void setParentContainer(VFSContainer parentContainer) {\n\t\t//\n\t}\n\n\t@Override\n\tpublic VFSStatus canWrite() {\n\t\treturn VFSConstants.NO;\n\t}\n\n\t@Override\n\tpublic VFSSecurityCallback getLocalSecurityCallback() {\n\t\treturn secCallback;\n\t}\n\n\t@Override\n\tpublic void setLocalSecurityCallback(VFSSecurityCallback secCallback) {\n\t\tthis.secCallback = secCallback;\n\t}\n}",
    "patch": "@@ -96,6 +96,11 @@ public VFSItem resolve(String path) {\n \tpublic String getRelPath() {\n \t\treturn null;\n \t}\n+\t\n+\t@Override\n+\tpublic boolean isInPath(String path) {\n+\t\treturn false;\n+\t}\n \n \t@Override\n \tpublic List<VFSItem> getItems() {",
    "function_modified_lines": {
      "added": [
        "\t\n",
        "\t@Override\n",
        "\tpublic boolean isInPath(String path) {\n",
        "\t\treturn false;\n",
        "\t}\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "OpenOLAT is a web-based learning management system (LMS). A path traversal vulnerability exists in versions prior to 15.3.18, 15.5.3, and 16.0.0. Using a specially prepared ZIP file, it is possible to overwrite any file that is writable by the application server user (e.g. the tomcat user). Depending on the configuration this can be limited to files of the OpenOlat user data directory, however, if not properly set up, the attack could also be used to overwrite application server config files, java code or even operating system files. The attack could be used to corrupt or modify any OpenOlat file such as course structures, config files or temporary test data. Those attack would require in-depth knowledge of the installation and thus more theoretical. If the app server configuration allows the execution of jsp files and the path to the context is known, it is also possible to execute java code. If the app server runs with the same user that is used to deploy the OpenOlat code or has write permissions on the OpenOlat code files and the path to the context is know, code injection is possible. The attack requires an OpenOlat user account to upload a ZIP file and trigger the unzip method. It can not be exploited by unregistered users. The problem is fixed in versions 15.3.18, 15.5.3 and 16.0.0. There are no known workarounds aside from upgrading.",
    "id": 12523
  },
  {
    "cve_id": "CVE-2021-39180",
    "code_before_change": "{\n\t\n\tprivate final CPTreeDataModel treeModel;\n\tprivate final ContentPackage cp;\n\tprivate final String ident;\n\t\n\tpublic VFSCPNamedContainerItem(String ident, String name, VFSLeaf delegate, ContentPackage cp, CPTreeDataModel treeModel) {\n\t\tsuper(name, delegate);\n\t\t\n\t\tthis.cp = cp;\n\t\tthis.ident = ident;\n\t\tthis.treeModel = treeModel;\n\t}\n\n\t@Override\n\tpublic VFSItem resolve(String path) {\n\t\treturn VFSManager.resolveFile(this, path);\n\t}\n\n\t@Override\n\tpublic List<VFSItem> getItems() {\n\t\treturn VFSCPContainer.getItems(cp, treeModel, ident);\n\t}\n\n\t@Override\n\tpublic List<VFSItem> getItems(VFSItemFilter filter) {\n\t\treturn getItems();\n\t}\n\n\t@Override\n\tpublic VFSStatus copyFrom(VFSItem source) {\n\t\treturn VFSConstants.NO;\n\t}\n\n\t@Override\n\tpublic VFSStatus copyContentOf(VFSContainer container) {\n\t\treturn VFSConstants.NO;\n\t}\n\n\t@Override\n\tpublic VFSContainer createChildContainer(String containerName) {\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic VFSLeaf createChildLeaf(String leafName) {\n\t\treturn null;\n\t}\n\t\n\t@Override\n\tpublic VFSItemFilter getDefaultItemFilter() {\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic void setDefaultItemFilter(VFSItemFilter defaultFilter) {\n\t\t//\n\t}\n}",
    "code_after_change": "{\n\t\n\tprivate final CPTreeDataModel treeModel;\n\tprivate final ContentPackage cp;\n\tprivate final String ident;\n\t\n\tpublic VFSCPNamedContainerItem(String ident, String name, VFSLeaf delegate, ContentPackage cp, CPTreeDataModel treeModel) {\n\t\tsuper(name, delegate);\n\t\t\n\t\tthis.cp = cp;\n\t\tthis.ident = ident;\n\t\tthis.treeModel = treeModel;\n\t}\n\n\t@Override\n\tpublic VFSItem resolve(String path) {\n\t\treturn VFSManager.resolveFile(this, path);\n\t}\n\n\t@Override\n\tpublic List<VFSItem> getItems() {\n\t\treturn VFSCPContainer.getItems(cp, treeModel, ident);\n\t}\n\n\t@Override\n\tpublic List<VFSItem> getItems(VFSItemFilter filter) {\n\t\treturn getItems();\n\t}\n\n\t@Override\n\tpublic boolean isInPath(String path) {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic VFSStatus copyFrom(VFSItem source) {\n\t\treturn VFSConstants.NO;\n\t}\n\n\t@Override\n\tpublic VFSStatus copyContentOf(VFSContainer container) {\n\t\treturn VFSConstants.NO;\n\t}\n\n\t@Override\n\tpublic VFSContainer createChildContainer(String containerName) {\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic VFSLeaf createChildLeaf(String leafName) {\n\t\treturn null;\n\t}\n\t\n\t@Override\n\tpublic VFSItemFilter getDefaultItemFilter() {\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic void setDefaultItemFilter(VFSItemFilter defaultFilter) {\n\t\t//\n\t}\n}",
    "patch": "@@ -71,6 +71,11 @@ public List<VFSItem> getItems(VFSItemFilter filter) {\n \t\treturn getItems();\n \t}\n \n+\t@Override\n+\tpublic boolean isInPath(String path) {\n+\t\treturn false;\n+\t}\n+\n \t@Override\n \tpublic VFSStatus copyFrom(VFSItem source) {\n \t\treturn VFSConstants.NO;",
    "function_modified_lines": {
      "added": [
        "\t@Override\n",
        "\tpublic boolean isInPath(String path) {\n",
        "\t\treturn false;\n",
        "\t}\n",
        "\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "OpenOLAT is a web-based learning management system (LMS). A path traversal vulnerability exists in versions prior to 15.3.18, 15.5.3, and 16.0.0. Using a specially prepared ZIP file, it is possible to overwrite any file that is writable by the application server user (e.g. the tomcat user). Depending on the configuration this can be limited to files of the OpenOlat user data directory, however, if not properly set up, the attack could also be used to overwrite application server config files, java code or even operating system files. The attack could be used to corrupt or modify any OpenOlat file such as course structures, config files or temporary test data. Those attack would require in-depth knowledge of the installation and thus more theoretical. If the app server configuration allows the execution of jsp files and the path to the context is known, it is also possible to execute java code. If the app server runs with the same user that is used to deploy the OpenOlat code or has write permissions on the OpenOlat code files and the path to the context is know, code injection is possible. The attack requires an OpenOlat user account to upload a ZIP file and trigger the unzip method. It can not be exploited by unregistered users. The problem is fixed in versions 15.3.18, 15.5.3 and 16.0.0. There are no known workarounds aside from upgrading.",
    "id": 12524
  },
  {
    "cve_id": "CVE-2021-39180",
    "code_before_change": "{\n\t\n\tprivate final VFSContainer rootContainer;\n\tprivate VFSSecurityCallback secCallback;\n\n\t\n\tpublic VFSMediaFilesContainer(String name, VFSContainer rootContainer) {\n\t\tsuper(name);\n\t\tthis.rootContainer = rootContainer;\n\t\tthis.rootContainer.setParentContainer(null);\n\t}\n\t\n\t@Override\n\tpublic boolean exists() {\n\t\treturn rootContainer != null && rootContainer.exists();\n\t}\n\t\n\t@Override\n\tpublic boolean isHidden() {\n\t\treturn rootContainer != null && rootContainer.isHidden();\n\t}\n\n\t@Override\n\tpublic boolean isSame(VFSItem vfsItem) {\n\t\treturn this == vfsItem || rootContainer.isSame(vfsItem);\n\t}\n\t\n\t@Override\n\tpublic VFSItem resolve(String path) {\n\t\treturn rootContainer.resolve(path);\n\t}\n\n\t@Override\n\tpublic List<VFSItem> getItems() {\n\t\treturn rootContainer.getItems();\n\t}\n\n\t@Override\n\tpublic List<VFSItem> getItems(VFSItemFilter filter) {\n\t\treturn rootContainer.getItems(filter);\n\t}\n\t\n\t@Override\n\tpublic String getRelPath() {\n\t\treturn rootContainer.getRelPath();\n\t}\n\n\t@Override\n\tpublic VFSContainer getParentContainer() {\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic void setParentContainer(VFSContainer parentContainer) {\n\t\t//\n\t}\n\n\t@Override\n\tpublic VFSStatus canWrite() {\n\t\treturn VFSConstants.NO;\n\t}\n\t\n\t@Override\n\tpublic VFSItemFilter getDefaultItemFilter() {\n\t\treturn rootContainer.getDefaultItemFilter();\n\t}\n\n\t@Override\n\tpublic void setDefaultItemFilter(VFSItemFilter defaultFilter) {\n\t\trootContainer.setDefaultItemFilter(defaultFilter);\n\t}\n\n\t@Override\n\tpublic VFSSecurityCallback getLocalSecurityCallback() {\n\t\treturn secCallback;\n\t}\n\n\t@Override\n\tpublic void setLocalSecurityCallback(VFSSecurityCallback secCallback) {\n\t\tthis.secCallback = secCallback;\n\t}\n}",
    "code_after_change": "{\n\t\n\tprivate final VFSContainer rootContainer;\n\tprivate VFSSecurityCallback secCallback;\n\n\t\n\tpublic VFSMediaFilesContainer(String name, VFSContainer rootContainer) {\n\t\tsuper(name);\n\t\tthis.rootContainer = rootContainer;\n\t\tthis.rootContainer.setParentContainer(null);\n\t}\n\t\n\t@Override\n\tpublic boolean exists() {\n\t\treturn rootContainer != null && rootContainer.exists();\n\t}\n\t\n\t@Override\n\tpublic boolean isHidden() {\n\t\treturn rootContainer != null && rootContainer.isHidden();\n\t}\n\n\t@Override\n\tpublic boolean isSame(VFSItem vfsItem) {\n\t\treturn this == vfsItem || rootContainer.isSame(vfsItem);\n\t}\n\t\n\t@Override\n\tpublic VFSItem resolve(String path) {\n\t\treturn rootContainer.resolve(path);\n\t}\n\n\t@Override\n\tpublic List<VFSItem> getItems() {\n\t\treturn rootContainer.getItems();\n\t}\n\n\t@Override\n\tpublic List<VFSItem> getItems(VFSItemFilter filter) {\n\t\treturn rootContainer.getItems(filter);\n\t}\n\t\n\t@Override\n\tpublic String getRelPath() {\n\t\treturn rootContainer.getRelPath();\n\t}\n\n\t@Override\n\tpublic boolean isInPath(String path) {\n\t\treturn rootContainer.isInPath(path);\n\t}\n\n\t@Override\n\tpublic VFSContainer getParentContainer() {\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic void setParentContainer(VFSContainer parentContainer) {\n\t\t//\n\t}\n\n\t@Override\n\tpublic VFSStatus canWrite() {\n\t\treturn VFSConstants.NO;\n\t}\n\t\n\t@Override\n\tpublic VFSItemFilter getDefaultItemFilter() {\n\t\treturn rootContainer.getDefaultItemFilter();\n\t}\n\n\t@Override\n\tpublic void setDefaultItemFilter(VFSItemFilter defaultFilter) {\n\t\trootContainer.setDefaultItemFilter(defaultFilter);\n\t}\n\n\t@Override\n\tpublic VFSSecurityCallback getLocalSecurityCallback() {\n\t\treturn secCallback;\n\t}\n\n\t@Override\n\tpublic void setLocalSecurityCallback(VFSSecurityCallback secCallback) {\n\t\tthis.secCallback = secCallback;\n\t}\n}",
    "patch": "@@ -85,6 +85,11 @@ public String getRelPath() {\n \t\treturn rootContainer.getRelPath();\n \t}\n \n+\t@Override\n+\tpublic boolean isInPath(String path) {\n+\t\treturn rootContainer.isInPath(path);\n+\t}\n+\n \t@Override\n \tpublic VFSContainer getParentContainer() {\n \t\treturn null;",
    "function_modified_lines": {
      "added": [
        "\t@Override\n",
        "\tpublic boolean isInPath(String path) {\n",
        "\t\treturn rootContainer.isInPath(path);\n",
        "\t}\n",
        "\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "OpenOLAT is a web-based learning management system (LMS). A path traversal vulnerability exists in versions prior to 15.3.18, 15.5.3, and 16.0.0. Using a specially prepared ZIP file, it is possible to overwrite any file that is writable by the application server user (e.g. the tomcat user). Depending on the configuration this can be limited to files of the OpenOlat user data directory, however, if not properly set up, the attack could also be used to overwrite application server config files, java code or even operating system files. The attack could be used to corrupt or modify any OpenOlat file such as course structures, config files or temporary test data. Those attack would require in-depth knowledge of the installation and thus more theoretical. If the app server configuration allows the execution of jsp files and the path to the context is known, it is also possible to execute java code. If the app server runs with the same user that is used to deploy the OpenOlat code or has write permissions on the OpenOlat code files and the path to the context is know, code injection is possible. The attack requires an OpenOlat user account to upload a ZIP file and trigger the unzip method. It can not be exploited by unregistered users. The problem is fixed in versions 15.3.18, 15.5.3 and 16.0.0. There are no known workarounds aside from upgrading.",
    "id": 12525
  },
  {
    "cve_id": "CVE-2021-39180",
    "code_before_change": "{\n\t\n\tprivate VFSContainer rootContainer;\n\n\tprivate VFSSecurityCallback secCallback;\n\n\tprivate final List<VFSItem> roots = new ArrayList<>();\n\t\n\tpublic VFSRootCPContainer(String name, ContentPackage cp, VFSContainer rootContainer, Translator translator) {\n\t\tsuper(name);\n\t\tthis.rootContainer = rootContainer;\n\t\t\n\t\t// real directory that contains all the files\n\t\tString contentTitle = translator.translate(\"cpfileuploadcontroller.pages\");\n\t\tVFSCPContainer cpContainer = new VFSCPContainer(contentTitle, cp);\n\t\troots.add(cpContainer);\n\t\t\n\t\t// virtual directory showing only the media files\n\t\tString mediaTitle = translator.translate(\"cpfileuploadcontroller.media\");\n\t\tVFSContainer mediaContainer = new VFSMediaFilesContainer(mediaTitle, cloneContainer(rootContainer));\n\t\tmediaContainer.setDefaultItemFilter(new VFSMediaFilter(true));\n\t\troots.add(mediaContainer);\n\n\t\t// virtual directory showing only the page (html) files\n\t\tString rawTitle = translator.translate(\"cpfileuploadcontroller.raw\");\n\t\tVFSContainer rawContainer = new VFSMediaFilesContainer(rawTitle, cloneContainer(rootContainer));\n\t\trawContainer.setDefaultItemFilter(new VFSMediaFilter(false));\n\t\troots.add(rawContainer);\n\t\t\n\t\tsecCallback = rootContainer.getLocalSecurityCallback();\n\t}\n\t\n\tprivate VFSContainer cloneContainer(VFSContainer container) {\n\t\tif(container instanceof LocalFolderImpl) {\n\t\t\tLocalFolderImpl folder = (LocalFolderImpl)container;\n\t\t\treturn new LocalFolderImpl(folder.getBasefile(), folder.getParentContainer());\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic boolean exists() {\n\t\treturn rootContainer != null && rootContainer.exists();\n\t}\n\n\t@Override\n\tpublic boolean isHidden() {\n\t\treturn rootContainer != null && rootContainer.isHidden();\n\t}\n\n\t@Override\n\tpublic boolean isSame(VFSItem vfsItem) {\n\t\tif(this == vfsItem) {\n\t\t\treturn true;\n\t\t}\n\t\tfor(VFSItem root:roots) {\n\t\t\tif(root.isSame(vfsItem)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t@Override\n\tpublic String getRelPath() {\n\t\treturn rootContainer.getRelPath();\n\t}\n\n\t@Override\n\tpublic VFSItem resolve(String path) {\n\t\t// 1) try to resolve directly from root (HTML editor instance)\n\t\tVFSItem item = rootContainer.resolve(path);\n\t\tif (item != null) {\n\t\t\treturn item;\n\t\t}\n\t\t\n\t\t// 2) try to resolve from virtual containers (events from link chooser)\n\t\tfor(VFSItem root:roots) {\n\t\t\tif(root instanceof VFSContainer) {\n\t\t\t\tVFSContainer container = (VFSContainer)root;\n\t\t\t\tString dir = container.getName();\n\t\t\t\tif (path.startsWith(\"/\" + dir + \"/\")) {\n\t\t\t\t\t// remove virtual directory name from path to resolve from real container\n\t\t\t\t\titem = container.resolve(path.substring(dir.length() + 1));\n\t\t\t\t\tif(item != null) {\n\t\t\t\t\t\treturn item;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic List<VFSItem> getItems() {\n\t\treturn roots;\n\t}\n\n\t@Override\n\tpublic List<VFSItem> getItems(VFSItemFilter filter) {\n\t\treturn getItems();\n\t}\n\n\t@Override\n\tpublic VFSContainer createChildContainer(String name) {\n\t\treturn rootContainer.createChildContainer(name);\n\t}\n\n\t@Override\n\tpublic VFSLeaf createChildLeaf(String name) {\n\t\treturn rootContainer.createChildLeaf(name);\n\t}\n\n\t@Override\n\tpublic VFSContainer getParentContainer() {\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic void setParentContainer(VFSContainer parentContainer) {\n\t\t//\n\t}\n\n\t@Override\n\tpublic VFSStatus canWrite() {\n\t\treturn VFSConstants.YES;\n\t}\n\n\t@Override\n\tpublic VFSSecurityCallback getLocalSecurityCallback() {\n\t\treturn secCallback;\n\t}\n\n\t@Override\n\tpublic void setLocalSecurityCallback(VFSSecurityCallback secCallback) {\n\t\tthis.secCallback = secCallback;\n\t}\n}",
    "code_after_change": "{\n\t\n\tprivate VFSContainer rootContainer;\n\n\tprivate VFSSecurityCallback secCallback;\n\n\tprivate final List<VFSItem> roots = new ArrayList<>();\n\t\n\tpublic VFSRootCPContainer(String name, ContentPackage cp, VFSContainer rootContainer, Translator translator) {\n\t\tsuper(name);\n\t\tthis.rootContainer = rootContainer;\n\t\t\n\t\t// real directory that contains all the files\n\t\tString contentTitle = translator.translate(\"cpfileuploadcontroller.pages\");\n\t\tVFSCPContainer cpContainer = new VFSCPContainer(contentTitle, cp);\n\t\troots.add(cpContainer);\n\t\t\n\t\t// virtual directory showing only the media files\n\t\tString mediaTitle = translator.translate(\"cpfileuploadcontroller.media\");\n\t\tVFSContainer mediaContainer = new VFSMediaFilesContainer(mediaTitle, cloneContainer(rootContainer));\n\t\tmediaContainer.setDefaultItemFilter(new VFSMediaFilter(true));\n\t\troots.add(mediaContainer);\n\n\t\t// virtual directory showing only the page (html) files\n\t\tString rawTitle = translator.translate(\"cpfileuploadcontroller.raw\");\n\t\tVFSContainer rawContainer = new VFSMediaFilesContainer(rawTitle, cloneContainer(rootContainer));\n\t\trawContainer.setDefaultItemFilter(new VFSMediaFilter(false));\n\t\troots.add(rawContainer);\n\t\t\n\t\tsecCallback = rootContainer.getLocalSecurityCallback();\n\t}\n\t\n\tprivate VFSContainer cloneContainer(VFSContainer container) {\n\t\tif(container instanceof LocalFolderImpl) {\n\t\t\tLocalFolderImpl folder = (LocalFolderImpl)container;\n\t\t\treturn new LocalFolderImpl(folder.getBasefile(), folder.getParentContainer());\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic boolean exists() {\n\t\treturn rootContainer != null && rootContainer.exists();\n\t}\n\n\t@Override\n\tpublic boolean isHidden() {\n\t\treturn rootContainer != null && rootContainer.isHidden();\n\t}\n\n\t@Override\n\tpublic boolean isSame(VFSItem vfsItem) {\n\t\tif(this == vfsItem) {\n\t\t\treturn true;\n\t\t}\n\t\tfor(VFSItem root:roots) {\n\t\t\tif(root.isSame(vfsItem)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t@Override\n\tpublic String getRelPath() {\n\t\treturn rootContainer.getRelPath();\n\t}\n\n\t@Override\n\tpublic boolean isInPath(String path) {\n\t\treturn rootContainer.isInPath(path);\n\t}\n\n\t@Override\n\tpublic VFSItem resolve(String path) {\n\t\t// 1) try to resolve directly from root (HTML editor instance)\n\t\tVFSItem item = rootContainer.resolve(path);\n\t\tif (item != null) {\n\t\t\treturn item;\n\t\t}\n\t\t\n\t\t// 2) try to resolve from virtual containers (events from link chooser)\n\t\tfor(VFSItem root:roots) {\n\t\t\tif(root instanceof VFSContainer) {\n\t\t\t\tVFSContainer container = (VFSContainer)root;\n\t\t\t\tString dir = container.getName();\n\t\t\t\tif (path.startsWith(\"/\" + dir + \"/\")) {\n\t\t\t\t\t// remove virtual directory name from path to resolve from real container\n\t\t\t\t\titem = container.resolve(path.substring(dir.length() + 1));\n\t\t\t\t\tif(item != null) {\n\t\t\t\t\t\treturn item;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic List<VFSItem> getItems() {\n\t\treturn roots;\n\t}\n\n\t@Override\n\tpublic List<VFSItem> getItems(VFSItemFilter filter) {\n\t\treturn getItems();\n\t}\n\n\t@Override\n\tpublic VFSContainer createChildContainer(String name) {\n\t\treturn rootContainer.createChildContainer(name);\n\t}\n\n\t@Override\n\tpublic VFSLeaf createChildLeaf(String name) {\n\t\treturn rootContainer.createChildLeaf(name);\n\t}\n\n\t@Override\n\tpublic VFSContainer getParentContainer() {\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic void setParentContainer(VFSContainer parentContainer) {\n\t\t//\n\t}\n\n\t@Override\n\tpublic VFSStatus canWrite() {\n\t\treturn VFSConstants.YES;\n\t}\n\n\t@Override\n\tpublic VFSSecurityCallback getLocalSecurityCallback() {\n\t\treturn secCallback;\n\t}\n\n\t@Override\n\tpublic void setLocalSecurityCallback(VFSSecurityCallback secCallback) {\n\t\tthis.secCallback = secCallback;\n\t}\n}",
    "patch": "@@ -112,6 +112,11 @@ public String getRelPath() {\n \t\treturn rootContainer.getRelPath();\n \t}\n \n+\t@Override\n+\tpublic boolean isInPath(String path) {\n+\t\treturn rootContainer.isInPath(path);\n+\t}\n+\n \t@Override\n \tpublic VFSItem resolve(String path) {\n \t\t// 1) try to resolve directly from root (HTML editor instance)",
    "function_modified_lines": {
      "added": [
        "\t@Override\n",
        "\tpublic boolean isInPath(String path) {\n",
        "\t\treturn rootContainer.isInPath(path);\n",
        "\t}\n",
        "\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "OpenOLAT is a web-based learning management system (LMS). A path traversal vulnerability exists in versions prior to 15.3.18, 15.5.3, and 16.0.0. Using a specially prepared ZIP file, it is possible to overwrite any file that is writable by the application server user (e.g. the tomcat user). Depending on the configuration this can be limited to files of the OpenOlat user data directory, however, if not properly set up, the attack could also be used to overwrite application server config files, java code or even operating system files. The attack could be used to corrupt or modify any OpenOlat file such as course structures, config files or temporary test data. Those attack would require in-depth knowledge of the installation and thus more theoretical. If the app server configuration allows the execution of jsp files and the path to the context is known, it is also possible to execute java code. If the app server runs with the same user that is used to deploy the OpenOlat code or has write permissions on the OpenOlat code files and the path to the context is know, code injection is possible. The attack requires an OpenOlat user account to upload a ZIP file and trigger the unzip method. It can not be exploited by unregistered users. The problem is fixed in versions 15.3.18, 15.5.3 and 16.0.0. There are no known workarounds aside from upgrading.",
    "id": 12526
  },
  {
    "cve_id": "CVE-2021-39180",
    "code_before_change": "{\n\t\t\tString href = resource.getHref();\n\t\t\tPath parentPath = imsmanifestPath.getParent();\n\t\t\tPath assessmentItemPath = parentPath.resolve(href);\n\t\t\tif(Files.notExists(assessmentItemPath)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\n\t\t\tString dir = qpoolFileStorage.generateDir();\n\t\t\t//storage\n\t\t\tFile itemStorage = qpoolFileStorage.getDirectory(dir);\n\t\t\tFile outputFile = new File(itemStorage, href);\n\t\t\tif(!outputFile.getParentFile().exists()) {\n\t\t\t\toutputFile.getParentFile().mkdirs();\n\t\t\t}\n\t\t\tQTI21Infos infos = getInfos(imsmanifestPath);\n\t\t\tconvertXmlFile(assessmentItemPath, outputFile.toPath(), infos);\n\n\t\t\tQtiXmlReader qtiXmlReader = new QtiXmlReader(qtiService.jqtiExtensionManager());\n\t\t\tResourceLocator fileResourceLocator = new FileResourceLocator();\n\t\t\tResourceLocator inputResourceLocator = \n\t\t\t\t\tImsQTI21Resource.createResolvingResourceLocator(fileResourceLocator);\n\t\t\t\n\t\t\tURI assessmentObjectSystemId = outputFile.toURI();\n\t\t\tAssessmentObjectXmlLoader assessmentObjectXmlLoader = new AssessmentObjectXmlLoader(qtiXmlReader, inputResourceLocator);\n\t\t\tResolvedAssessmentItem resolvedAssessmentItem = assessmentObjectXmlLoader.loadAndResolveAssessmentItem(assessmentObjectSystemId);\n\t\t\tAssessmentItem assessmentItem = resolvedAssessmentItem.getRootNodeLookup().extractIfSuccessful();\n\t\t\t\n\t\t\tif(!AssessmentItemChecker.checkAndCorrect(assessmentItem)) {\n\t\t\t\tqtiService.persistAssessmentObject(outputFile, assessmentItem);\n\t\t\t}\n\t\t\t\n\t\t\tAssessmentItemMetadata metadata = new AssessmentItemMetadata(metadataBuilder);\n\n\t\t\tString editor = null;\n\t\t\tString editorVersion = null;\n\t\t\tif(StringHelper.containsNonWhitespace(assessmentItem.getToolName())) {\n\t\t\t\teditor = assessmentItem.getToolName();\n\t\t\t}\n\t\t\tif(StringHelper.containsNonWhitespace(assessmentItem.getToolVersion())) {\n\t\t\t\teditorVersion = assessmentItem.getToolVersion();\n\t\t\t}\n\n\t\t\tQuestionItemImpl qitem = processItem(assessmentItem, null, href,\n\t\t\t\t\teditor, editorVersion, dir, metadata);\n\n\t\t\t//create manifest\n\t\t\tManifestBuilder manifest = ManifestBuilder.createAssessmentItemBuilder();\n\t\t\tString itemId = IdentifierGenerator.newAsIdentifier(\"item\").toString();\n\t\t\tResourceType importedResource = manifest.appendAssessmentItem(itemId, href);\n\t\t\tManifestMetadataBuilder importedMetadataBuilder = manifest.getMetadataBuilder(importedResource, true);\n\t\t\timportedMetadataBuilder.setMetadata(metadataBuilder.getMetadata());\n\t\t\tmanifest.write(new File(itemStorage, \"imsmanifest.xml\"));\n\t\t\t\n\t\t\t//process material\n\t\t\tList<String> materials = ImportExportHelper.getMaterials(assessmentItem);\n\t\t\tfor(String material:materials) {\n\t\t\t\tif(material.indexOf(\"://\") < 0) {// material can be an external URL\n\t\t\t\t\tPath materialFile = assessmentItemPath.getParent().resolve(material);\n\t\t\t\t\tPathUtils.copyFileToDir(materialFile, outputFile.getParentFile(), material);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn qitem;\n\t\t}",
    "code_after_change": "{\n\t\t\tString href = resource.getHref();\n\t\t\tPath parentPath = imsmanifestPath.getParent();\n\t\t\tPath assessmentItemPath = parentPath.resolve(href);\n\t\t\tif(Files.notExists(assessmentItemPath)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t\n\t\t\tPath normalizedPath = assessmentItemPath.normalize();\n\t\t\tif(!normalizedPath.startsWith(parentPath)) {\n\t\t\t\tthrow new IOException(\"Invalid Item\");\n\t\t\t}\n\t\n\t\t\tString dir = qpoolFileStorage.generateDir();\n\t\t\t//storage\n\t\t\tFile itemStorage = qpoolFileStorage.getDirectory(dir);\n\t\t\tFile outputFile = new File(itemStorage, href);\n\t\t\tif(!outputFile.getParentFile().exists()) {\n\t\t\t\toutputFile.getParentFile().mkdirs();\n\t\t\t}\n\t\t\tQTI21Infos infos = getInfos(imsmanifestPath);\n\t\t\tconvertXmlFile(assessmentItemPath, outputFile.toPath(), infos);\n\n\t\t\tQtiXmlReader qtiXmlReader = new QtiXmlReader(qtiService.jqtiExtensionManager());\n\t\t\tResourceLocator fileResourceLocator = new FileResourceLocator();\n\t\t\tResourceLocator inputResourceLocator = \n\t\t\t\t\tImsQTI21Resource.createResolvingResourceLocator(fileResourceLocator);\n\t\t\t\n\t\t\tURI assessmentObjectSystemId = outputFile.toURI();\n\t\t\tAssessmentObjectXmlLoader assessmentObjectXmlLoader = new AssessmentObjectXmlLoader(qtiXmlReader, inputResourceLocator);\n\t\t\tResolvedAssessmentItem resolvedAssessmentItem = assessmentObjectXmlLoader.loadAndResolveAssessmentItem(assessmentObjectSystemId);\n\t\t\tAssessmentItem assessmentItem = resolvedAssessmentItem.getRootNodeLookup().extractIfSuccessful();\n\t\t\t\n\t\t\tif(!AssessmentItemChecker.checkAndCorrect(assessmentItem)) {\n\t\t\t\tqtiService.persistAssessmentObject(outputFile, assessmentItem);\n\t\t\t}\n\t\t\t\n\t\t\tAssessmentItemMetadata metadata = new AssessmentItemMetadata(metadataBuilder);\n\n\t\t\tString editor = null;\n\t\t\tString editorVersion = null;\n\t\t\tif(StringHelper.containsNonWhitespace(assessmentItem.getToolName())) {\n\t\t\t\teditor = assessmentItem.getToolName();\n\t\t\t}\n\t\t\tif(StringHelper.containsNonWhitespace(assessmentItem.getToolVersion())) {\n\t\t\t\teditorVersion = assessmentItem.getToolVersion();\n\t\t\t}\n\n\t\t\tQuestionItemImpl qitem = processItem(assessmentItem, null, href,\n\t\t\t\t\teditor, editorVersion, dir, metadata);\n\n\t\t\t//create manifest\n\t\t\tManifestBuilder manifest = ManifestBuilder.createAssessmentItemBuilder();\n\t\t\tString itemId = IdentifierGenerator.newAsIdentifier(\"item\").toString();\n\t\t\tResourceType importedResource = manifest.appendAssessmentItem(itemId, href);\n\t\t\tManifestMetadataBuilder importedMetadataBuilder = manifest.getMetadataBuilder(importedResource, true);\n\t\t\timportedMetadataBuilder.setMetadata(metadataBuilder.getMetadata());\n\t\t\tmanifest.write(new File(itemStorage, \"imsmanifest.xml\"));\n\t\t\t\n\t\t\t//process material\n\t\t\tList<String> materials = ImportExportHelper.getMaterials(assessmentItem);\n\t\t\tfor(String material:materials) {\n\t\t\t\tif(material.indexOf(\"://\") < 0) {// material can be an external URL\n\t\t\t\t\tPath materialFile = assessmentItemPath.getParent().resolve(material);\n\t\t\t\t\tPath normalizedMaterialPath = materialFile.normalize();\n\t\t\t\t\tif(!normalizedMaterialPath.startsWith(parentPath)) {\n\t\t\t\t\t\tthrow new IOException(\"Invalid Item\");\n\t\t\t\t\t}\n\t\t\t\t\tPathUtils.copyFileToDir(materialFile, outputFile.getParentFile(), material);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn qitem;\n\t\t}",
    "patch": "@@ -161,6 +161,11 @@ private QuestionItem processResource(ResourceType resource, Path imsmanifestPath\n \t\t\tif(Files.notExists(assessmentItemPath)) {\n \t\t\t\treturn null;\n \t\t\t}\n+\t\t\t\n+\t\t\tPath normalizedPath = assessmentItemPath.normalize();\n+\t\t\tif(!normalizedPath.startsWith(parentPath)) {\n+\t\t\t\tthrow new IOException(\"Invalid Item\");\n+\t\t\t}\n \t\n \t\t\tString dir = qpoolFileStorage.generateDir();\n \t\t\t//storage\n@@ -213,6 +218,10 @@ private QuestionItem processResource(ResourceType resource, Path imsmanifestPath\n \t\t\tfor(String material:materials) {\n \t\t\t\tif(material.indexOf(\"://\") < 0) {// material can be an external URL\n \t\t\t\t\tPath materialFile = assessmentItemPath.getParent().resolve(material);\n+\t\t\t\t\tPath normalizedMaterialPath = materialFile.normalize();\n+\t\t\t\t\tif(!normalizedMaterialPath.startsWith(parentPath)) {\n+\t\t\t\t\t\tthrow new IOException(\"Invalid Item\");\n+\t\t\t\t\t}\n \t\t\t\t\tPathUtils.copyFileToDir(materialFile, outputFile.getParentFile(), material);\n \t\t\t\t}\n \t\t\t}",
    "function_modified_lines": {
      "added": [
        "\t\t\t\n",
        "\t\t\tPath normalizedPath = assessmentItemPath.normalize();\n",
        "\t\t\tif(!normalizedPath.startsWith(parentPath)) {\n",
        "\t\t\t\tthrow new IOException(\"Invalid Item\");\n",
        "\t\t\t}\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "OpenOLAT is a web-based learning management system (LMS). A path traversal vulnerability exists in versions prior to 15.3.18, 15.5.3, and 16.0.0. Using a specially prepared ZIP file, it is possible to overwrite any file that is writable by the application server user (e.g. the tomcat user). Depending on the configuration this can be limited to files of the OpenOlat user data directory, however, if not properly set up, the attack could also be used to overwrite application server config files, java code or even operating system files. The attack could be used to corrupt or modify any OpenOlat file such as course structures, config files or temporary test data. Those attack would require in-depth knowledge of the installation and thus more theoretical. If the app server configuration allows the execution of jsp files and the path to the context is known, it is also possible to execute java code. If the app server runs with the same user that is used to deploy the OpenOlat code or has write permissions on the OpenOlat code files and the path to the context is know, code injection is possible. The attack requires an OpenOlat user account to upload a ZIP file and trigger the unzip method. It can not be exploited by unregistered users. The problem is fixed in versions 15.3.18, 15.5.3 and 16.0.0. There are no known workarounds aside from upgrading.",
    "id": 12527
  },
  {
    "cve_id": "CVE-2021-39180",
    "code_before_change": "{\n\t\t\t\tif(material.indexOf(\"://\") < 0) {// material can be an external URL\n\t\t\t\t\tPath materialFile = assessmentItemPath.getParent().resolve(material);\n\t\t\t\t\tPathUtils.copyFileToDir(materialFile, outputFile.getParentFile(), material);\n\t\t\t\t}\n\t\t\t}",
    "code_after_change": "{// material can be an external URL\n\t\t\t\t\tPath materialFile = assessmentItemPath.getParent().resolve(material);\n\t\t\t\t\tPath normalizedMaterialPath = materialFile.normalize();\n\t\t\t\t\tif(!normalizedMaterialPath.startsWith(parentPath)) {\n\t\t\t\t\t\tthrow new IOException(\"Invalid Item\");\n\t\t\t\t\t}\n\t\t\t\t\tPathUtils.copyFileToDir(materialFile, outputFile.getParentFile(), material);\n\t\t\t\t}",
    "patch": "@@ -161,6 +161,11 @@ private QuestionItem processResource(ResourceType resource, Path imsmanifestPath\n \t\t\tif(Files.notExists(assessmentItemPath)) {\n \t\t\t\treturn null;\n \t\t\t}\n+\t\t\t\n+\t\t\tPath normalizedPath = assessmentItemPath.normalize();\n+\t\t\tif(!normalizedPath.startsWith(parentPath)) {\n+\t\t\t\tthrow new IOException(\"Invalid Item\");\n+\t\t\t}\n \t\n \t\t\tString dir = qpoolFileStorage.generateDir();\n \t\t\t//storage\n@@ -213,6 +218,10 @@ private QuestionItem processResource(ResourceType resource, Path imsmanifestPath\n \t\t\tfor(String material:materials) {\n \t\t\t\tif(material.indexOf(\"://\") < 0) {// material can be an external URL\n \t\t\t\t\tPath materialFile = assessmentItemPath.getParent().resolve(material);\n+\t\t\t\t\tPath normalizedMaterialPath = materialFile.normalize();\n+\t\t\t\t\tif(!normalizedMaterialPath.startsWith(parentPath)) {\n+\t\t\t\t\t\tthrow new IOException(\"Invalid Item\");\n+\t\t\t\t\t}\n \t\t\t\t\tPathUtils.copyFileToDir(materialFile, outputFile.getParentFile(), material);\n \t\t\t\t}\n \t\t\t}",
    "function_modified_lines": {
      "added": [
        "\t\t\t\t\tPath normalizedMaterialPath = materialFile.normalize();\n",
        "\t\t\t\t\tif(!normalizedMaterialPath.startsWith(parentPath)) {\n",
        "\t\t\t\t\t\tthrow new IOException(\"Invalid Item\");\n",
        "\t\t\t\t\t}\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "OpenOLAT is a web-based learning management system (LMS). A path traversal vulnerability exists in versions prior to 15.3.18, 15.5.3, and 16.0.0. Using a specially prepared ZIP file, it is possible to overwrite any file that is writable by the application server user (e.g. the tomcat user). Depending on the configuration this can be limited to files of the OpenOlat user data directory, however, if not properly set up, the attack could also be used to overwrite application server config files, java code or even operating system files. The attack could be used to corrupt or modify any OpenOlat file such as course structures, config files or temporary test data. Those attack would require in-depth knowledge of the installation and thus more theoretical. If the app server configuration allows the execution of jsp files and the path to the context is known, it is also possible to execute java code. If the app server runs with the same user that is used to deploy the OpenOlat code or has write permissions on the OpenOlat code files and the path to the context is know, code injection is possible. The attack requires an OpenOlat user account to upload a ZIP file and trigger the unzip method. It can not be exploited by unregistered users. The problem is fixed in versions 15.3.18, 15.5.3 and 16.0.0. There are no known workarounds aside from upgrading.",
    "id": 12528
  },
  {
    "cve_id": "CVE-2021-39180",
    "code_before_change": "{\n\t\n\tprivate static final Logger log = Tracing.createLoggerFor(CopyAndConvertVisitor.class);\n\t\n\tprivate final Path source;\n\tprivate final Path destDir;\n\tprivate final PathMatcher filter;\n\t\n\tprivate QTI21Infos infos;\n\t\n\tpublic CopyAndConvertVisitor(Path source, Path destDir, QTI21Infos infos, PathMatcher filter) {\n\t\tthis.source = source;\n\t\tthis.destDir = destDir;\n\t\tthis.filter = filter;\n\t\tthis.infos = infos;\n\t}\n\t\n\t@Override\n\tpublic FileVisitResult visitFile(Path file, BasicFileAttributes attrs)\n    throws IOException {\n\t\tPath relativeFile = source.relativize(file);\n\t\tfinal Path destFile = Paths.get(destDir.toString(), relativeFile.toString());\n\t\tif(filter.matches(file)) {\n\t\t\tString filename = file.getFileName().toString();\n\t\t\tif(filename.startsWith(\".\")) {\n\t\t\t\t//ignore\n\t\t\t} else if(filename.endsWith(\"xml\") && !filename.equals(\"imsmanifest.xml\")) {\n\t\t\t\tconvertXmlFile(file, destFile);\n\t\t\t} else {\n\t\t\t\tFiles.copy(file, destFile, StandardCopyOption.REPLACE_EXISTING);\n\t\t\t}\n\t\t}\n        return FileVisitResult.CONTINUE;\n\t}\n \n\t@Override\n\tpublic FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs)\n\tthrows IOException {\n\t\tPath relativeDir = source.relativize(dir);\n        final Path dirToCreate = Paths.get(destDir.toString(), relativeDir.toString());\n        if(!dirToCreate.toFile().exists()) {\n        \tFiles.createDirectory(dirToCreate);\n        }\n        return FileVisitResult.CONTINUE;\n\t}\n\t\n\t/**\n\t * Convert the XML files, assessmentItem or assessmentTest\n\t * \n\t * @param inputFile\n\t * @param outputFile\n\t */\n\tpublic boolean convertXmlFile(Path inputFile, Path outputFile) {\n\t\ttry {\n\t\t\tboolean validated = true;\n\t\t\tQTI21Infos fileInfos = scanFile(inputFile);\n\t\t\t//inherit from test if needed\n\t\t\tif(fileInfos.getEditor() == null && infos.getEditor() != null) {\n\t\t\t\tfileInfos.setEditor(infos.getEditor());\n\t\t\t\tfileInfos.setVersion(infos.getVersion());\n\t\t\t}\n\t\t\tif(onyx38Family(fileInfos)) {\n\t\t\t\tvalidated = convertXmlFile(inputFile, outputFile, fileInfos.getType(), Onyx38ToQtiWorksHandler::new);\n\t\t\t} else if(onyxWebFamily(fileInfos)) {\n\t\t\t\tvalidated = convertXmlFile(inputFile, outputFile, fileInfos.getType(), xtw ->\n\t\t\t\t\t new OnyxToQtiWorksHandler(xtw, infos));\n\t\t\t\t\n\t\t\t\tif(validated && fileInfos.getType() == InputType.assessmentItem) {\n\t\t\t\t\t//check templateVariables\n\t\t\t\t\tcheckAssessmentItem(outputFile);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tFiles.copy(inputFile, outputFile, StandardCopyOption.REPLACE_EXISTING);\n\t\t\t}\n\t\t\treturn validated;\n\t\t} catch (IOException | FactoryConfigurationError e) {\n\t\t\tlog.error(\"\", e);\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\tprivate boolean onyx38Family(QTI21Infos fileInfos) {\n\t\tif(fileInfos == null || fileInfos.getEditor() == null) return false;\n\t\tString version = fileInfos.getVersion();\n\t\treturn \"Onyx Editor\".equals(fileInfos.getEditor()) && version != null &&\n\t\t\t\t(version.startsWith(\"2.\") || version.startsWith(\"3.\"));\n\t}\n\t\n\tprivate boolean onyxWebFamily(QTI21Infos fileInfos) {\n\t\tif(fileInfos == null || fileInfos.getEditor() == null) return false;\n\t\treturn \"ONYX Editor\".equals(fileInfos.getEditor());\n\t}\n\t\n\tprivate QTI21Infos scanFile(Path inputFile) {\n\t\tQTI21ExplorerHandler infosHandler = new QTI21ExplorerHandler();\n\t\ttry(InputStream in = Files.newInputStream(inputFile)) {\n\t\t\tSAXParser saxParser = XMLFactories.newSAXParser();\n\t\t\tsaxParser.setProperty(\"http://xml.org/sax/properties/lexical-handler\", infosHandler);\n\t\t\tsaxParser.parse(in, infosHandler);\n\t\t} catch(Exception e1) {\n\t\t\tlog.error(\"\", e1);\n\t\t}\n\t\treturn infosHandler.getInfos();\n\t}\n\n\tprivate boolean convertXmlFile(Path inputFile, Path outputFile, InputType type, HandlerProvider provider) {\n\t\tFile tmpFile = new File(WebappHelper.getTmpDir(), UUID.randomUUID() + \".xml\");\n\t\ttry(InputStream in = Files.newInputStream(inputFile);\n\t\t\t\tWriter out = Files.newBufferedWriter(tmpFile.toPath(), StandardCharsets.UTF_8)) {\n\t\t\tXMLOutputFactory xof = XMLOutputFactory.newInstance();\n\t        XMLStreamWriter xtw = xof.createXMLStreamWriter(out);\n\t\t\tSAXParser saxParser = XMLFactories.newSAXParser();\n\t\t\tDefaultHandler myHandler = provider.create(xtw);\n\t\t\tsaxParser.setProperty(\"http://xml.org/sax/properties/lexical-handler\", myHandler);\n\t\t\tsaxParser.parse(in, myHandler);\n\t\t\t\n\t\t\tboolean valid = validate(tmpFile.toPath(), type, true);\n\t\t\tif(valid) {\n\t\t\t\tif(!outputFile.getParent().toFile().exists()) {\n\t\t\t\t\toutputFile.getParent().toFile().mkdirs();\n\t\t\t\t}\n\t\t\t\tFiles.copy(tmpFile.toPath(), outputFile, StandardCopyOption.REPLACE_EXISTING);\n\t\t\t}\n\t\t\treturn valid;\n\t\t} catch(Exception e1) {\n\t\t\tlog.error(\"\", e1);\n\t\t\treturn false;\n\t\t} finally {\n\t\t\tFileUtils.deleteFile(tmpFile);\n\t\t}\n\t}\n\t\n\tprivate boolean validate(Path inputFile, InputType type, boolean verbose) {\n\t\ttry {\n\t\t\tQtiXmlReader qtiXmlReader = new QtiXmlReader(new JqtiExtensionManager());\n\t\t\tResourceLocator fileResourceLocator = new PathResourceLocator(inputFile.getParent());\n\t\t\tAssessmentObjectXmlLoader assessmentObjectXmlLoader = new AssessmentObjectXmlLoader(qtiXmlReader, fileResourceLocator);\n\t\t\t\n\t\t\tRootNode rootNode = null;\n\t\t\tBadResourceException e = null;\n\t\t\tURI uri = new URI(\"zip\", inputFile.getFileName().toString(), null);\n\t\t\tif(type == InputType.assessmentItem) {\n\t\t\t\tItemValidationResult itemResult = assessmentObjectXmlLoader.loadResolveAndValidateItem(uri);\n\t\t\t\te = itemResult.getResolvedAssessmentItem().getItemLookup().getBadResourceException();\n\t\t\t\tResolvedAssessmentItem resolvedAssessmentItem = assessmentObjectXmlLoader.loadAndResolveAssessmentItem(uri);\n\t\t\t\trootNode = resolvedAssessmentItem.getRootNodeLookup().extractIfSuccessful();\n\t\t\t} else if(type == InputType.assessmentTest) {\n\t\t\t\tTestValidationResult testResult = assessmentObjectXmlLoader.loadResolveAndValidateTest(uri);\n\t\t\t\te = testResult.getResolvedAssessmentTest().getTestLookup().getBadResourceException();\n\t\t\t\tResolvedAssessmentTest resolvedAssessmentTest = assessmentObjectXmlLoader.loadAndResolveAssessmentTest(uri);\n\t\t\t\trootNode = resolvedAssessmentTest.getRootNodeLookup().extractIfSuccessful();\n\t\t\t}\n\t\t\t\n\t\t\tif(e != null && verbose) {\n\t\t\t\tStringBuilder err = new StringBuilder();\n\t\t\t\tBadRessourceHelper.extractMessage(e, err);\n\t\t\t\tlog.warn(err.toString());\n\t\t\t}\n\t\t\t\n\t\t\treturn (rootNode != null) && (e == null || (e instanceof QtiXmlInterpretationException && ((QtiXmlInterpretationException)e).getXmlParseResult().getFatalErrors().isEmpty()));\n\t\t} catch (URISyntaxException e) {\n\t\t\tlog.error(\"\", e);\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\tprivate void checkAssessmentItem(Path outputFile) {\n\t\tQTI21Service qtiService = CoreSpringFactory.getImpl(QTI21Service.class);\n\t\tQtiXmlReader qtiXmlReader = new QtiXmlReader(qtiService.jqtiExtensionManager());\n\t\tResourceLocator fileResourceLocator = new FileResourceLocator();\n\t\tResourceLocator inputResourceLocator = \n\t\t\t\tImsQTI21Resource.createResolvingResourceLocator(fileResourceLocator);\n\t\t\n\t\tURI assessmentObjectSystemId = outputFile.toFile().toURI();\n\t\tAssessmentObjectXmlLoader assessmentObjectXmlLoader = new AssessmentObjectXmlLoader(qtiXmlReader, inputResourceLocator);\n\t\tResolvedAssessmentItem resolvedAssessmentItem = assessmentObjectXmlLoader.loadAndResolveAssessmentItem(assessmentObjectSystemId);\n\t\tAssessmentItem assessmentItem = resolvedAssessmentItem.getRootNodeLookup().extractIfSuccessful();\n\n\t\tif(!AssessmentItemChecker.checkAndCorrect(assessmentItem)) {\n\t\t\ttry(FileOutputStream out = new FileOutputStream(outputFile.toFile())) {\n\t\t\t\tqtiService.qtiSerializer().serializeJqtiObject(assessmentItem, out);\n\t\t\t} catch(Exception e) {\n\t\t\t\tlog.error(\"\", e);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic interface HandlerProvider {\n\t\t\n\t\tpublic DefaultHandler2 create(XMLStreamWriter xtw);\n\t\t\n\t}\n}",
    "code_after_change": "{\n\t\n\tprivate static final Logger log = Tracing.createLoggerFor(CopyAndConvertVisitor.class);\n\t\n\tprivate final Path source;\n\tprivate final Path destDir;\n\tprivate final PathMatcher filter;\n\t\n\tprivate QTI21Infos infos;\n\t\n\tpublic CopyAndConvertVisitor(Path source, Path destDir, QTI21Infos infos, PathMatcher filter) {\n\t\tthis.source = source;\n\t\tthis.destDir = destDir;\n\t\tthis.filter = filter;\n\t\tthis.infos = infos;\n\t}\n\t\n\t@Override\n\tpublic FileVisitResult visitFile(Path file, BasicFileAttributes attrs)\n    throws IOException {\n\t\tPath relativeFile = source.relativize(file);\n\t\tfinal Path destFile = Paths.get(destDir.toString(), relativeFile.toString());\n\t\tif(filter.matches(file)) {\n\t\t\tString filename = file.getFileName().toString();\n\t\t\tif(filename.startsWith(\".\")) {\n\t\t\t\t//ignore\n\t\t\t} else if(filename.endsWith(\"xml\") && !filename.equals(\"imsmanifest.xml\")) {\n\t\t\t\tcheckPath(destFile);\n\t\t\t\tconvertXmlFile(file, destFile);\n\t\t\t} else {\n\t\t\t\tcheckPath(destFile);\n\t\t\t\tFiles.copy(file, destFile, StandardCopyOption.REPLACE_EXISTING);\n\t\t\t}\n\t\t}\n        return FileVisitResult.CONTINUE;\n\t}\n \n\t@Override\n\tpublic FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs)\n\tthrows IOException {\n\t\tPath relativeDir = source.relativize(dir);\n\t\tfinal Path dirToCreate = Paths.get(destDir.toString(), relativeDir.toString());\n\t\tcheckPath(dirToCreate);\n       \n        if(!dirToCreate.toFile().exists()) {\n        \tFiles.createDirectory(dirToCreate);\n        }\n        return FileVisitResult.CONTINUE;\n\t}\n\t\n\tprivate void checkPath(Path file) throws IOException {\n\t\tPath normalizedPath = file.normalize();\n\t\tif(!normalizedPath.startsWith(destDir)) {\n\t\t\tthrow new IOException(\"Invalid ZIP\");\n\t\t}\n\t}\n\t\n\t/**\n\t * Convert the XML files, assessmentItem or assessmentTest\n\t * \n\t * @param inputFile\n\t * @param outputFile\n\t */\n\tpublic boolean convertXmlFile(Path inputFile, Path outputFile) {\n\t\ttry {\n\t\t\tboolean validated = true;\n\t\t\tQTI21Infos fileInfos = scanFile(inputFile);\n\t\t\t//inherit from test if needed\n\t\t\tif(fileInfos.getEditor() == null && infos.getEditor() != null) {\n\t\t\t\tfileInfos.setEditor(infos.getEditor());\n\t\t\t\tfileInfos.setVersion(infos.getVersion());\n\t\t\t}\n\t\t\tif(onyx38Family(fileInfos)) {\n\t\t\t\tvalidated = convertXmlFile(inputFile, outputFile, fileInfos.getType(), Onyx38ToQtiWorksHandler::new);\n\t\t\t} else if(onyxWebFamily(fileInfos)) {\n\t\t\t\tvalidated = convertXmlFile(inputFile, outputFile, fileInfos.getType(), xtw ->\n\t\t\t\t\t new OnyxToQtiWorksHandler(xtw, infos));\n\t\t\t\t\n\t\t\t\tif(validated && fileInfos.getType() == InputType.assessmentItem) {\n\t\t\t\t\t//check templateVariables\n\t\t\t\t\tcheckAssessmentItem(outputFile);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tFiles.copy(inputFile, outputFile, StandardCopyOption.REPLACE_EXISTING);\n\t\t\t}\n\t\t\treturn validated;\n\t\t} catch (IOException | FactoryConfigurationError e) {\n\t\t\tlog.error(\"\", e);\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\tprivate boolean onyx38Family(QTI21Infos fileInfos) {\n\t\tif(fileInfos == null || fileInfos.getEditor() == null) return false;\n\t\tString version = fileInfos.getVersion();\n\t\treturn \"Onyx Editor\".equals(fileInfos.getEditor()) && version != null &&\n\t\t\t\t(version.startsWith(\"2.\") || version.startsWith(\"3.\"));\n\t}\n\t\n\tprivate boolean onyxWebFamily(QTI21Infos fileInfos) {\n\t\tif(fileInfos == null || fileInfos.getEditor() == null) return false;\n\t\treturn \"ONYX Editor\".equals(fileInfos.getEditor());\n\t}\n\t\n\tprivate QTI21Infos scanFile(Path inputFile) {\n\t\tQTI21ExplorerHandler infosHandler = new QTI21ExplorerHandler();\n\t\ttry(InputStream in = Files.newInputStream(inputFile)) {\n\t\t\tSAXParser saxParser = XMLFactories.newSAXParser();\n\t\t\tsaxParser.setProperty(\"http://xml.org/sax/properties/lexical-handler\", infosHandler);\n\t\t\tsaxParser.parse(in, infosHandler);\n\t\t} catch(Exception e1) {\n\t\t\tlog.error(\"\", e1);\n\t\t}\n\t\treturn infosHandler.getInfos();\n\t}\n\n\tprivate boolean convertXmlFile(Path inputFile, Path outputFile, InputType type, HandlerProvider provider) {\n\t\tFile tmpFile = new File(WebappHelper.getTmpDir(), UUID.randomUUID() + \".xml\");\n\t\ttry(InputStream in = Files.newInputStream(inputFile);\n\t\t\t\tWriter out = Files.newBufferedWriter(tmpFile.toPath(), StandardCharsets.UTF_8)) {\n\t\t\tXMLOutputFactory xof = XMLOutputFactory.newInstance();\n\t        XMLStreamWriter xtw = xof.createXMLStreamWriter(out);\n\t\t\tSAXParser saxParser = XMLFactories.newSAXParser();\n\t\t\tDefaultHandler myHandler = provider.create(xtw);\n\t\t\tsaxParser.setProperty(\"http://xml.org/sax/properties/lexical-handler\", myHandler);\n\t\t\tsaxParser.parse(in, myHandler);\n\t\t\t\n\t\t\tboolean valid = validate(tmpFile.toPath(), type, true);\n\t\t\tif(valid) {\n\t\t\t\tif(!outputFile.getParent().toFile().exists()) {\n\t\t\t\t\toutputFile.getParent().toFile().mkdirs();\n\t\t\t\t}\n\t\t\t\tFiles.copy(tmpFile.toPath(), outputFile, StandardCopyOption.REPLACE_EXISTING);\n\t\t\t}\n\t\t\treturn valid;\n\t\t} catch(Exception e1) {\n\t\t\tlog.error(\"\", e1);\n\t\t\treturn false;\n\t\t} finally {\n\t\t\tFileUtils.deleteFile(tmpFile);\n\t\t}\n\t}\n\t\n\tprivate boolean validate(Path inputFile, InputType type, boolean verbose) {\n\t\ttry {\n\t\t\tQtiXmlReader qtiXmlReader = new QtiXmlReader(new JqtiExtensionManager());\n\t\t\tResourceLocator fileResourceLocator = new PathResourceLocator(inputFile.getParent());\n\t\t\tAssessmentObjectXmlLoader assessmentObjectXmlLoader = new AssessmentObjectXmlLoader(qtiXmlReader, fileResourceLocator);\n\t\t\t\n\t\t\tRootNode rootNode = null;\n\t\t\tBadResourceException e = null;\n\t\t\tURI uri = new URI(\"zip\", inputFile.getFileName().toString(), null);\n\t\t\tif(type == InputType.assessmentItem) {\n\t\t\t\tItemValidationResult itemResult = assessmentObjectXmlLoader.loadResolveAndValidateItem(uri);\n\t\t\t\te = itemResult.getResolvedAssessmentItem().getItemLookup().getBadResourceException();\n\t\t\t\tResolvedAssessmentItem resolvedAssessmentItem = assessmentObjectXmlLoader.loadAndResolveAssessmentItem(uri);\n\t\t\t\trootNode = resolvedAssessmentItem.getRootNodeLookup().extractIfSuccessful();\n\t\t\t} else if(type == InputType.assessmentTest) {\n\t\t\t\tTestValidationResult testResult = assessmentObjectXmlLoader.loadResolveAndValidateTest(uri);\n\t\t\t\te = testResult.getResolvedAssessmentTest().getTestLookup().getBadResourceException();\n\t\t\t\tResolvedAssessmentTest resolvedAssessmentTest = assessmentObjectXmlLoader.loadAndResolveAssessmentTest(uri);\n\t\t\t\trootNode = resolvedAssessmentTest.getRootNodeLookup().extractIfSuccessful();\n\t\t\t}\n\t\t\t\n\t\t\tif(e != null && verbose) {\n\t\t\t\tStringBuilder err = new StringBuilder();\n\t\t\t\tBadRessourceHelper.extractMessage(e, err);\n\t\t\t\tlog.warn(err.toString());\n\t\t\t}\n\t\t\t\n\t\t\treturn (rootNode != null) && (e == null || (e instanceof QtiXmlInterpretationException && ((QtiXmlInterpretationException)e).getXmlParseResult().getFatalErrors().isEmpty()));\n\t\t} catch (URISyntaxException e) {\n\t\t\tlog.error(\"\", e);\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\tprivate void checkAssessmentItem(Path outputFile) {\n\t\tQTI21Service qtiService = CoreSpringFactory.getImpl(QTI21Service.class);\n\t\tQtiXmlReader qtiXmlReader = new QtiXmlReader(qtiService.jqtiExtensionManager());\n\t\tResourceLocator fileResourceLocator = new FileResourceLocator();\n\t\tResourceLocator inputResourceLocator = \n\t\t\t\tImsQTI21Resource.createResolvingResourceLocator(fileResourceLocator);\n\t\t\n\t\tURI assessmentObjectSystemId = outputFile.toFile().toURI();\n\t\tAssessmentObjectXmlLoader assessmentObjectXmlLoader = new AssessmentObjectXmlLoader(qtiXmlReader, inputResourceLocator);\n\t\tResolvedAssessmentItem resolvedAssessmentItem = assessmentObjectXmlLoader.loadAndResolveAssessmentItem(assessmentObjectSystemId);\n\t\tAssessmentItem assessmentItem = resolvedAssessmentItem.getRootNodeLookup().extractIfSuccessful();\n\n\t\tif(!AssessmentItemChecker.checkAndCorrect(assessmentItem)) {\n\t\t\ttry(FileOutputStream out = new FileOutputStream(outputFile.toFile())) {\n\t\t\t\tqtiService.qtiSerializer().serializeJqtiObject(assessmentItem, out);\n\t\t\t} catch(Exception e) {\n\t\t\t\tlog.error(\"\", e);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic interface HandlerProvider {\n\t\t\n\t\tpublic DefaultHandler2 create(XMLStreamWriter xtw);\n\t\t\n\t}\n}",
    "patch": "@@ -115,8 +115,10 @@ public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)\n \t\t\tif(filename.startsWith(\".\")) {\n \t\t\t\t//ignore\n \t\t\t} else if(filename.endsWith(\"xml\") && !filename.equals(\"imsmanifest.xml\")) {\n+\t\t\t\tcheckPath(destFile);\n \t\t\t\tconvertXmlFile(file, destFile);\n \t\t\t} else {\n+\t\t\t\tcheckPath(destFile);\n \t\t\t\tFiles.copy(file, destFile, StandardCopyOption.REPLACE_EXISTING);\n \t\t\t}\n \t\t}\n@@ -127,13 +129,22 @@ public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)\n \tpublic FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs)\n \tthrows IOException {\n \t\tPath relativeDir = source.relativize(dir);\n-        final Path dirToCreate = Paths.get(destDir.toString(), relativeDir.toString());\n+\t\tfinal Path dirToCreate = Paths.get(destDir.toString(), relativeDir.toString());\n+\t\tcheckPath(dirToCreate);\n+       \n         if(!dirToCreate.toFile().exists()) {\n         \tFiles.createDirectory(dirToCreate);\n         }\n         return FileVisitResult.CONTINUE;\n \t}\n \t\n+\tprivate void checkPath(Path file) throws IOException {\n+\t\tPath normalizedPath = file.normalize();\n+\t\tif(!normalizedPath.startsWith(destDir)) {\n+\t\t\tthrow new IOException(\"Invalid ZIP\");\n+\t\t}\n+\t}\n+\t\n \t/**\n \t * Convert the XML files, assessmentItem or assessmentTest\n \t * ",
    "function_modified_lines": {
      "added": [
        "\t\t\t\tcheckPath(destFile);\n",
        "\t\t\t\tcheckPath(destFile);\n",
        "\t\tfinal Path dirToCreate = Paths.get(destDir.toString(), relativeDir.toString());\n",
        "\t\tcheckPath(dirToCreate);\n",
        "       \n",
        "\tprivate void checkPath(Path file) throws IOException {\n",
        "\t\tPath normalizedPath = file.normalize();\n",
        "\t\tif(!normalizedPath.startsWith(destDir)) {\n",
        "\t\t\tthrow new IOException(\"Invalid ZIP\");\n",
        "\t\t}\n",
        "\t}\n",
        "\t\n"
      ],
      "deleted": [
        "        final Path dirToCreate = Paths.get(destDir.toString(), relativeDir.toString());\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "OpenOLAT is a web-based learning management system (LMS). A path traversal vulnerability exists in versions prior to 15.3.18, 15.5.3, and 16.0.0. Using a specially prepared ZIP file, it is possible to overwrite any file that is writable by the application server user (e.g. the tomcat user). Depending on the configuration this can be limited to files of the OpenOlat user data directory, however, if not properly set up, the attack could also be used to overwrite application server config files, java code or even operating system files. The attack could be used to corrupt or modify any OpenOlat file such as course structures, config files or temporary test data. Those attack would require in-depth knowledge of the installation and thus more theoretical. If the app server configuration allows the execution of jsp files and the path to the context is known, it is also possible to execute java code. If the app server runs with the same user that is used to deploy the OpenOlat code or has write permissions on the OpenOlat code files and the path to the context is know, code injection is possible. The attack requires an OpenOlat user account to upload a ZIP file and trigger the unzip method. It can not be exploited by unregistered users. The problem is fixed in versions 15.3.18, 15.5.3 and 16.0.0. There are no known workarounds aside from upgrading.",
    "id": 12529
  },
  {
    "cve_id": "CVE-2021-39180",
    "code_before_change": "/**\n * <a href=\"http://www.openolat.org\">\n * OpenOLAT - Online Learning and Training</a><br>\n * <p>\n * Licensed under the Apache License, Version 2.0 (the \"License\"); <br>\n * you may not use this file except in compliance with the License.<br>\n * You may obtain a copy of the License at the\n * <a href=\"http://www.apache.org/licenses/LICENSE-2.0\">Apache homepage</a>\n * <p>\n * Unless required by applicable law or agreed to in writing,<br>\n * software distributed under the License is distributed on an \"AS IS\" BASIS, <br>\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. <br>\n * See the License for the specific language governing permissions and <br>\n * limitations under the License.\n * <p>\n * Initial code contributed and copyrighted by<br>\n * frentix GmbH, http://www.frentix.com\n * <p>\n */\npackage org.olat.core.util;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.FileSystems;\nimport java.nio.file.FileVisitResult;\nimport java.nio.file.FileVisitor;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.PathMatcher;\nimport java.nio.file.Paths;\nimport java.nio.file.ProviderNotFoundException;\nimport java.nio.file.SimpleFileVisitor;\nimport java.nio.file.StandardCopyOption;\nimport java.nio.file.attribute.BasicFileAttributes;\nimport java.util.ServiceConfigurationError;\n\nimport org.apache.commons.io.IOUtils;\n\n/**\n * \n * Initial date: 08.05.2014<br>\n * @author srosse, stephane.rosse@frentix.com, http://www.frentix.com\n *\n */\npublic class PathUtils {\n\t\n\t/**\n\t * \n\t * @param source\n\t * @param targetDir\n\t * @param path Relative path where the file is saved from targetDir\n\t * @return\n\t * @throws IOException\n\t */\n\tpublic static boolean copyFileToDir(Path source, File targetDir, String path) throws IOException {\n\t\tFile targetFile = new File(targetDir, path);\n\t\tif(!targetFile.getParentFile().exists()) {\n\t\t\ttargetFile.getParentFile().mkdirs();\n\t\t}\n\t\tFiles.copy(source, targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING);\n\t\treturn true;\n\t}\n\t\n\t/**\n\t * Use the closeSubsequentFS method to close the file system.\n\t * \n\t * @param file The file to visit\n\t * @param filename The filename\n\t * @param visitor The visitor\n\t * @return\n\t * @throws IOException\n\t * @throws IllegalArgumentException\n\t */\n\tpublic static Path visit(File file, String filename, FileVisitor<Path> visitor) \n\tthrows IOException, IllegalArgumentException {\n\t\tif(!StringHelper.containsNonWhitespace(filename)) {\n\t\t\tfilename = file.getName();\n\t\t}\n\t\t\n\t\tPath fPath = null;\n\t\tif(file.isDirectory()) {\n\t\t\tfPath = file.toPath();\n\t\t} else if(filename != null && filename.toLowerCase().endsWith(\".zip\")) {\n\t\t\ttry {\n\t\t\t\tfPath = FileSystems.newFileSystem(file.toPath(), null).getPath(\"/\");\n\t\t\t} catch (ProviderNotFoundException | ServiceConfigurationError e) {\n\t\t\t\tthrow new IOException(\"Unreadable file with .zip extension: \" + file, e);\n\t\t\t}\n\t\t} else {\n\t\t\tfPath = file.toPath();\n\t\t}\n\t\tif(fPath != null) {\n\t\t    Files.walkFileTree(fPath, visitor);\n\t\t}\n\t\treturn fPath;\n\t}\n\t\n\tpublic static void closeSubsequentFS(Path path) {\n\t\tif(path != null && FileSystems.getDefault() != path.getFileSystem()) {\n\t\t\tIOUtils.closeQuietly(path.getFileSystem());\n\t\t}\n\t}\n\t\n\tpublic static class YesMatcher implements PathMatcher {\n\t\t@Override\n\t\tpublic boolean matches(Path path) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tpublic static class CopyVisitor extends SimpleFileVisitor<Path> {\n\n\t\tprivate final Path source;\n\t\tprivate final Path destDir;\n\t\tprivate final PathMatcher filter;\n\t\t\n\t\tpublic CopyVisitor(Path source, Path destDir, PathMatcher filter) {\n\t\t\tthis.source = source;\n\t\t\tthis.destDir = destDir;\n\t\t\tthis.filter = filter;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic FileVisitResult visitFile(Path file, BasicFileAttributes attrs)\n\t    throws IOException {\n\t\t\tPath relativeFile = source.relativize(file);\n\t        final Path destFile = Paths.get(destDir.toString(), relativeFile.toString());\n\t        if(filter.matches(file)) {\n\t        \tFiles.copy(file, destFile, StandardCopyOption.REPLACE_EXISTING);\n\t        }\n\t        return FileVisitResult.CONTINUE;\n\t\t}\n\t \n\t\t@Override\n\t\tpublic FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs)\n\t\tthrows IOException {\n\t\t\tPath relativeDir = source.relativize(dir);\n\t        final Path dirToCreate = Paths.get(destDir.toString(), relativeDir.toString());\n\t        if(Files.notExists(dirToCreate)){\n\t        \tFiles.createDirectory(dirToCreate);\n\t        }\n\t        return FileVisitResult.CONTINUE;\n\t\t}\n\t}\n\n}\n",
    "code_after_change": "/**\n * <a href=\"http://www.openolat.org\">\n * OpenOLAT - Online Learning and Training</a><br>\n * <p>\n * Licensed under the Apache License, Version 2.0 (the \"License\"); <br>\n * you may not use this file except in compliance with the License.<br>\n * You may obtain a copy of the License at the\n * <a href=\"http://www.apache.org/licenses/LICENSE-2.0\">Apache homepage</a>\n * <p>\n * Unless required by applicable law or agreed to in writing,<br>\n * software distributed under the License is distributed on an \"AS IS\" BASIS, <br>\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. <br>\n * See the License for the specific language governing permissions and <br>\n * limitations under the License.\n * <p>\n * Initial code contributed and copyrighted by<br>\n * frentix GmbH, http://www.frentix.com\n * <p>\n */\npackage org.olat.core.util;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.FileSystems;\nimport java.nio.file.FileVisitOption;\nimport java.nio.file.FileVisitResult;\nimport java.nio.file.FileVisitor;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.PathMatcher;\nimport java.nio.file.Paths;\nimport java.nio.file.ProviderNotFoundException;\nimport java.nio.file.SimpleFileVisitor;\nimport java.nio.file.StandardCopyOption;\nimport java.nio.file.attribute.BasicFileAttributes;\nimport java.util.EnumSet;\nimport java.util.ServiceConfigurationError;\n\nimport org.apache.commons.io.IOUtils;\nimport org.olat.core.logging.OLATRuntimeException;\n\n/**\n * \n * Initial date: 08.05.2014<br>\n * @author srosse, stephane.rosse@frentix.com, http://www.frentix.com\n *\n */\npublic class PathUtils {\n\t\n\t/**\n\t * \n\t * @param source\n\t * @param targetDir\n\t * @param path Relative path where the file is saved from targetDir\n\t * @return\n\t * @throws IOException\n\t */\n\tpublic static boolean copyFileToDir(Path source, File targetDir, String path) throws IOException {\n\t\tFile targetFile = new File(targetDir, path);\n\t\tif(!targetFile.getParentFile().exists()) {\n\t\t\ttargetFile.getParentFile().mkdirs();\n\t\t}\n\t\tFiles.copy(source, targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING);\n\t\treturn true;\n\t}\n\t\n\t/**\n\t * Use the closeSubsequentFS method to close the file system. The method doesn't\n\t * follow sym. links and its depth is limited.\n\t * \n\t * @param file The file to visit\n\t * @param filename The filename\n\t * @param visitor The visitor\n\t * @return\n\t * @throws IOException\n\t * @throws IllegalArgumentException\n\t */\n\tpublic static Path visit(File file, String filename, FileVisitor<Path> visitor) \n\tthrows IOException, IllegalArgumentException {\n\t\tif(!StringHelper.containsNonWhitespace(filename)) {\n\t\t\tfilename = file.getName();\n\t\t}\n\t\t\n\t\tPath fPath = null;\n\t\tif(file.isDirectory()) {\n\t\t\tfPath = file.toPath();\n\t\t} else if(filename != null && filename.toLowerCase().endsWith(\".zip\")) {\n\t\t\ttry {\n\t\t\t\tfPath = FileSystems.newFileSystem(file.toPath(), null).getPath(\"/\");\n\t\t\t} catch (ProviderNotFoundException | ServiceConfigurationError e) {\n\t\t\t\tthrow new IOException(\"Unreadable file with .zip extension: \" + file, e);\n\t\t\t}\n\t\t} else {\n\t\t\tfPath = file.toPath();\n\t\t}\n\t\tif(fPath != null) {\n\t\t    Files.walkFileTree(fPath, EnumSet.noneOf(FileVisitOption.class), 32, visitor);\n\t\t}\n\t\treturn fPath;\n\t}\n\t\n\tpublic static void closeSubsequentFS(Path path) {\n\t\tif(path != null && FileSystems.getDefault() != path.getFileSystem()) {\n\t\t\tIOUtils.closeQuietly(path.getFileSystem(), null);\n\t\t}\n\t}\n\t\n\tpublic static class YesMatcher implements PathMatcher {\n\t\t@Override\n\t\tpublic boolean matches(Path path) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tpublic static class CopyVisitor extends SimpleFileVisitor<Path> {\n\n\t\tprivate final Path source;\n\t\tprivate final Path destDir;\n\t\tprivate final PathMatcher filter;\n\t\t\n\t\tpublic CopyVisitor(Path source, Path destDir, PathMatcher filter) {\n\t\t\tthis.source = source;\n\t\t\tthis.destDir = destDir;\n\t\t\tthis.filter = filter;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic FileVisitResult visitFile(Path file, BasicFileAttributes attrs)\n\t    throws IOException {\n\t\t\tPath relativeFile = source.relativize(file);\n\t        final Path destFile = Paths.get(destDir.toString(), relativeFile.toString());\n\t        Path normalizedPath = destFile.normalize();\n\t\t\tif(!normalizedPath.startsWith(destDir)) {\n\t\t\t\tthrow new OLATRuntimeException(\"Invalid ZIP\");\n\t\t\t}\n\t        if(filter.matches(file)) {\n\t        \tFiles.copy(file, destFile, StandardCopyOption.REPLACE_EXISTING);\n\t        }\n\t        return FileVisitResult.CONTINUE;\n\t\t}\n\t \n\t\t@Override\n\t\tpublic FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs)\n\t\tthrows IOException {\n\t\t\tPath relativeDir = source.relativize(dir);\n\t        final Path dirToCreate = Paths.get(destDir.toString(), relativeDir.toString());\n\t        if(Files.notExists(dirToCreate)){\n\t        \tFiles.createDirectory(dirToCreate);\n\t        }\n\t        return FileVisitResult.CONTINUE;\n\t\t}\n\t}\n\n}\n",
    "patch": "@@ -22,6 +22,7 @@\n import java.io.File;\n import java.io.IOException;\n import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitOption;\n import java.nio.file.FileVisitResult;\n import java.nio.file.FileVisitor;\n import java.nio.file.Files;\n@@ -32,9 +33,11 @@\n import java.nio.file.SimpleFileVisitor;\n import java.nio.file.StandardCopyOption;\n import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.EnumSet;\n import java.util.ServiceConfigurationError;\n \n import org.apache.commons.io.IOUtils;\n+import org.olat.core.logging.OLATRuntimeException;\n \n /**\n  * \n@@ -62,7 +65,8 @@ public static boolean copyFileToDir(Path source, File targetDir, String path) th\n \t}\n \t\n \t/**\n-\t * Use the closeSubsequentFS method to close the file system.\n+\t * Use the closeSubsequentFS method to close the file system. The method doesn't\n+\t * follow sym. links and its depth is limited.\n \t * \n \t * @param file The file to visit\n \t * @param filename The filename\n@@ -90,14 +94,14 @@ public static Path visit(File file, String filename, FileVisitor<Path> visitor)\n \t\t\tfPath = file.toPath();\n \t\t}\n \t\tif(fPath != null) {\n-\t\t    Files.walkFileTree(fPath, visitor);\n+\t\t    Files.walkFileTree(fPath, EnumSet.noneOf(FileVisitOption.class), 32, visitor);\n \t\t}\n \t\treturn fPath;\n \t}\n \t\n \tpublic static void closeSubsequentFS(Path path) {\n \t\tif(path != null && FileSystems.getDefault() != path.getFileSystem()) {\n-\t\t\tIOUtils.closeQuietly(path.getFileSystem());\n+\t\t\tIOUtils.closeQuietly(path.getFileSystem(), null);\n \t\t}\n \t}\n \t\n@@ -125,6 +129,10 @@ public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)\n \t    throws IOException {\n \t\t\tPath relativeFile = source.relativize(file);\n \t        final Path destFile = Paths.get(destDir.toString(), relativeFile.toString());\n+\t        Path normalizedPath = destFile.normalize();\n+\t\t\tif(!normalizedPath.startsWith(destDir)) {\n+\t\t\t\tthrow new OLATRuntimeException(\"Invalid ZIP\");\n+\t\t\t}\n \t        if(filter.matches(file)) {\n \t        \tFiles.copy(file, destFile, StandardCopyOption.REPLACE_EXISTING);\n \t        }",
    "function_modified_lines": {
      "added": [
        "import java.nio.file.FileVisitOption;\n",
        "import java.util.EnumSet;\n",
        "import org.olat.core.logging.OLATRuntimeException;\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "OpenOLAT is a web-based learning management system (LMS). A path traversal vulnerability exists in versions prior to 15.3.18, 15.5.3, and 16.0.0. Using a specially prepared ZIP file, it is possible to overwrite any file that is writable by the application server user (e.g. the tomcat user). Depending on the configuration this can be limited to files of the OpenOlat user data directory, however, if not properly set up, the attack could also be used to overwrite application server config files, java code or even operating system files. The attack could be used to corrupt or modify any OpenOlat file such as course structures, config files or temporary test data. Those attack would require in-depth knowledge of the installation and thus more theoretical. If the app server configuration allows the execution of jsp files and the path to the context is known, it is also possible to execute java code. If the app server runs with the same user that is used to deploy the OpenOlat code or has write permissions on the OpenOlat code files and the path to the context is know, code injection is possible. The attack requires an OpenOlat user account to upload a ZIP file and trigger the unzip method. It can not be exploited by unregistered users. The problem is fixed in versions 15.3.18, 15.5.3 and 16.0.0. There are no known workarounds aside from upgrading.",
    "id": 12530
  },
  {
    "cve_id": "CVE-2021-39180",
    "code_before_change": "{\n\t\n\t/**\n\t * \n\t * @param source\n\t * @param targetDir\n\t * @param path Relative path where the file is saved from targetDir\n\t * @return\n\t * @throws IOException\n\t */\n\tpublic static boolean copyFileToDir(Path source, File targetDir, String path) throws IOException {\n\t\tFile targetFile = new File(targetDir, path);\n\t\tif(!targetFile.getParentFile().exists()) {\n\t\t\ttargetFile.getParentFile().mkdirs();\n\t\t}\n\t\tFiles.copy(source, targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING);\n\t\treturn true;\n\t}\n\t\n\t/**\n\t * Use the closeSubsequentFS method to close the file system.\n\t * \n\t * @param file The file to visit\n\t * @param filename The filename\n\t * @param visitor The visitor\n\t * @return\n\t * @throws IOException\n\t * @throws IllegalArgumentException\n\t */\n\tpublic static Path visit(File file, String filename, FileVisitor<Path> visitor) \n\tthrows IOException, IllegalArgumentException {\n\t\tif(!StringHelper.containsNonWhitespace(filename)) {\n\t\t\tfilename = file.getName();\n\t\t}\n\t\t\n\t\tPath fPath = null;\n\t\tif(file.isDirectory()) {\n\t\t\tfPath = file.toPath();\n\t\t} else if(filename != null && filename.toLowerCase().endsWith(\".zip\")) {\n\t\t\ttry {\n\t\t\t\tfPath = FileSystems.newFileSystem(file.toPath(), null).getPath(\"/\");\n\t\t\t} catch (ProviderNotFoundException | ServiceConfigurationError e) {\n\t\t\t\tthrow new IOException(\"Unreadable file with .zip extension: \" + file, e);\n\t\t\t}\n\t\t} else {\n\t\t\tfPath = file.toPath();\n\t\t}\n\t\tif(fPath != null) {\n\t\t    Files.walkFileTree(fPath, visitor);\n\t\t}\n\t\treturn fPath;\n\t}\n\t\n\tpublic static void closeSubsequentFS(Path path) {\n\t\tif(path != null && FileSystems.getDefault() != path.getFileSystem()) {\n\t\t\tIOUtils.closeQuietly(path.getFileSystem());\n\t\t}\n\t}\n\t\n\tpublic static class YesMatcher implements PathMatcher {\n\t\t@Override\n\t\tpublic boolean matches(Path path) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tpublic static class CopyVisitor extends SimpleFileVisitor<Path> {\n\n\t\tprivate final Path source;\n\t\tprivate final Path destDir;\n\t\tprivate final PathMatcher filter;\n\t\t\n\t\tpublic CopyVisitor(Path source, Path destDir, PathMatcher filter) {\n\t\t\tthis.source = source;\n\t\t\tthis.destDir = destDir;\n\t\t\tthis.filter = filter;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic FileVisitResult visitFile(Path file, BasicFileAttributes attrs)\n\t    throws IOException {\n\t\t\tPath relativeFile = source.relativize(file);\n\t        final Path destFile = Paths.get(destDir.toString(), relativeFile.toString());\n\t        if(filter.matches(file)) {\n\t        \tFiles.copy(file, destFile, StandardCopyOption.REPLACE_EXISTING);\n\t        }\n\t        return FileVisitResult.CONTINUE;\n\t\t}\n\t \n\t\t@Override\n\t\tpublic FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs)\n\t\tthrows IOException {\n\t\t\tPath relativeDir = source.relativize(dir);\n\t        final Path dirToCreate = Paths.get(destDir.toString(), relativeDir.toString());\n\t        if(Files.notExists(dirToCreate)){\n\t        \tFiles.createDirectory(dirToCreate);\n\t        }\n\t        return FileVisitResult.CONTINUE;\n\t\t}\n\t}\n\n}",
    "code_after_change": "{\n\t\n\t/**\n\t * \n\t * @param source\n\t * @param targetDir\n\t * @param path Relative path where the file is saved from targetDir\n\t * @return\n\t * @throws IOException\n\t */\n\tpublic static boolean copyFileToDir(Path source, File targetDir, String path) throws IOException {\n\t\tFile targetFile = new File(targetDir, path);\n\t\tif(!targetFile.getParentFile().exists()) {\n\t\t\ttargetFile.getParentFile().mkdirs();\n\t\t}\n\t\tFiles.copy(source, targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING);\n\t\treturn true;\n\t}\n\t\n\t/**\n\t * Use the closeSubsequentFS method to close the file system. The method doesn't\n\t * follow sym. links and its depth is limited.\n\t * \n\t * @param file The file to visit\n\t * @param filename The filename\n\t * @param visitor The visitor\n\t * @return\n\t * @throws IOException\n\t * @throws IllegalArgumentException\n\t */\n\tpublic static Path visit(File file, String filename, FileVisitor<Path> visitor) \n\tthrows IOException, IllegalArgumentException {\n\t\tif(!StringHelper.containsNonWhitespace(filename)) {\n\t\t\tfilename = file.getName();\n\t\t}\n\t\t\n\t\tPath fPath = null;\n\t\tif(file.isDirectory()) {\n\t\t\tfPath = file.toPath();\n\t\t} else if(filename != null && filename.toLowerCase().endsWith(\".zip\")) {\n\t\t\ttry {\n\t\t\t\tfPath = FileSystems.newFileSystem(file.toPath(), null).getPath(\"/\");\n\t\t\t} catch (ProviderNotFoundException | ServiceConfigurationError e) {\n\t\t\t\tthrow new IOException(\"Unreadable file with .zip extension: \" + file, e);\n\t\t\t}\n\t\t} else {\n\t\t\tfPath = file.toPath();\n\t\t}\n\t\tif(fPath != null) {\n\t\t    Files.walkFileTree(fPath, EnumSet.noneOf(FileVisitOption.class), 32, visitor);\n\t\t}\n\t\treturn fPath;\n\t}\n\t\n\tpublic static void closeSubsequentFS(Path path) {\n\t\tif(path != null && FileSystems.getDefault() != path.getFileSystem()) {\n\t\t\tIOUtils.closeQuietly(path.getFileSystem(), null);\n\t\t}\n\t}\n\t\n\tpublic static class YesMatcher implements PathMatcher {\n\t\t@Override\n\t\tpublic boolean matches(Path path) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tpublic static class CopyVisitor extends SimpleFileVisitor<Path> {\n\n\t\tprivate final Path source;\n\t\tprivate final Path destDir;\n\t\tprivate final PathMatcher filter;\n\t\t\n\t\tpublic CopyVisitor(Path source, Path destDir, PathMatcher filter) {\n\t\t\tthis.source = source;\n\t\t\tthis.destDir = destDir;\n\t\t\tthis.filter = filter;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic FileVisitResult visitFile(Path file, BasicFileAttributes attrs)\n\t    throws IOException {\n\t\t\tPath relativeFile = source.relativize(file);\n\t        final Path destFile = Paths.get(destDir.toString(), relativeFile.toString());\n\t        Path normalizedPath = destFile.normalize();\n\t\t\tif(!normalizedPath.startsWith(destDir)) {\n\t\t\t\tthrow new OLATRuntimeException(\"Invalid ZIP\");\n\t\t\t}\n\t        if(filter.matches(file)) {\n\t        \tFiles.copy(file, destFile, StandardCopyOption.REPLACE_EXISTING);\n\t        }\n\t        return FileVisitResult.CONTINUE;\n\t\t}\n\t \n\t\t@Override\n\t\tpublic FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs)\n\t\tthrows IOException {\n\t\t\tPath relativeDir = source.relativize(dir);\n\t        final Path dirToCreate = Paths.get(destDir.toString(), relativeDir.toString());\n\t        if(Files.notExists(dirToCreate)){\n\t        \tFiles.createDirectory(dirToCreate);\n\t        }\n\t        return FileVisitResult.CONTINUE;\n\t\t}\n\t}\n\n}",
    "patch": "@@ -22,6 +22,7 @@\n import java.io.File;\n import java.io.IOException;\n import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitOption;\n import java.nio.file.FileVisitResult;\n import java.nio.file.FileVisitor;\n import java.nio.file.Files;\n@@ -32,9 +33,11 @@\n import java.nio.file.SimpleFileVisitor;\n import java.nio.file.StandardCopyOption;\n import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.EnumSet;\n import java.util.ServiceConfigurationError;\n \n import org.apache.commons.io.IOUtils;\n+import org.olat.core.logging.OLATRuntimeException;\n \n /**\n  * \n@@ -62,7 +65,8 @@ public static boolean copyFileToDir(Path source, File targetDir, String path) th\n \t}\n \t\n \t/**\n-\t * Use the closeSubsequentFS method to close the file system.\n+\t * Use the closeSubsequentFS method to close the file system. The method doesn't\n+\t * follow sym. links and its depth is limited.\n \t * \n \t * @param file The file to visit\n \t * @param filename The filename\n@@ -90,14 +94,14 @@ public static Path visit(File file, String filename, FileVisitor<Path> visitor)\n \t\t\tfPath = file.toPath();\n \t\t}\n \t\tif(fPath != null) {\n-\t\t    Files.walkFileTree(fPath, visitor);\n+\t\t    Files.walkFileTree(fPath, EnumSet.noneOf(FileVisitOption.class), 32, visitor);\n \t\t}\n \t\treturn fPath;\n \t}\n \t\n \tpublic static void closeSubsequentFS(Path path) {\n \t\tif(path != null && FileSystems.getDefault() != path.getFileSystem()) {\n-\t\t\tIOUtils.closeQuietly(path.getFileSystem());\n+\t\t\tIOUtils.closeQuietly(path.getFileSystem(), null);\n \t\t}\n \t}\n \t\n@@ -125,6 +129,10 @@ public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)\n \t    throws IOException {\n \t\t\tPath relativeFile = source.relativize(file);\n \t        final Path destFile = Paths.get(destDir.toString(), relativeFile.toString());\n+\t        Path normalizedPath = destFile.normalize();\n+\t\t\tif(!normalizedPath.startsWith(destDir)) {\n+\t\t\t\tthrow new OLATRuntimeException(\"Invalid ZIP\");\n+\t\t\t}\n \t        if(filter.matches(file)) {\n \t        \tFiles.copy(file, destFile, StandardCopyOption.REPLACE_EXISTING);\n \t        }",
    "function_modified_lines": {
      "added": [
        "\t\t    Files.walkFileTree(fPath, EnumSet.noneOf(FileVisitOption.class), 32, visitor);\n",
        "\t\t\tIOUtils.closeQuietly(path.getFileSystem(), null);\n"
      ],
      "deleted": [
        "\t\t    Files.walkFileTree(fPath, visitor);\n",
        "\t\t\tIOUtils.closeQuietly(path.getFileSystem());\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "OpenOLAT is a web-based learning management system (LMS). A path traversal vulnerability exists in versions prior to 15.3.18, 15.5.3, and 16.0.0. Using a specially prepared ZIP file, it is possible to overwrite any file that is writable by the application server user (e.g. the tomcat user). Depending on the configuration this can be limited to files of the OpenOlat user data directory, however, if not properly set up, the attack could also be used to overwrite application server config files, java code or even operating system files. The attack could be used to corrupt or modify any OpenOlat file such as course structures, config files or temporary test data. Those attack would require in-depth knowledge of the installation and thus more theoretical. If the app server configuration allows the execution of jsp files and the path to the context is known, it is also possible to execute java code. If the app server runs with the same user that is used to deploy the OpenOlat code or has write permissions on the OpenOlat code files and the path to the context is know, code injection is possible. The attack requires an OpenOlat user account to upload a ZIP file and trigger the unzip method. It can not be exploited by unregistered users. The problem is fixed in versions 15.3.18, 15.5.3 and 16.0.0. There are no known workarounds aside from upgrading.",
    "id": 12531
  },
  {
    "cve_id": "CVE-2021-39180",
    "code_before_change": "{\n\t\t\tPath relativeFile = source.relativize(file);\n\t        final Path destFile = Paths.get(destDir.toString(), relativeFile.toString());\n\t        if(filter.matches(file)) {\n\t        \tFiles.copy(file, destFile, StandardCopyOption.REPLACE_EXISTING);\n\t        }\n\t        return FileVisitResult.CONTINUE;\n\t\t}",
    "code_after_change": "{\n\t\t\tPath relativeFile = source.relativize(file);\n\t        final Path destFile = Paths.get(destDir.toString(), relativeFile.toString());\n\t        Path normalizedPath = destFile.normalize();\n\t\t\tif(!normalizedPath.startsWith(destDir)) {\n\t\t\t\tthrow new OLATRuntimeException(\"Invalid ZIP\");\n\t\t\t}\n\t        if(filter.matches(file)) {\n\t        \tFiles.copy(file, destFile, StandardCopyOption.REPLACE_EXISTING);\n\t        }\n\t        return FileVisitResult.CONTINUE;\n\t\t}",
    "patch": "@@ -22,6 +22,7 @@\n import java.io.File;\n import java.io.IOException;\n import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitOption;\n import java.nio.file.FileVisitResult;\n import java.nio.file.FileVisitor;\n import java.nio.file.Files;\n@@ -32,9 +33,11 @@\n import java.nio.file.SimpleFileVisitor;\n import java.nio.file.StandardCopyOption;\n import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.EnumSet;\n import java.util.ServiceConfigurationError;\n \n import org.apache.commons.io.IOUtils;\n+import org.olat.core.logging.OLATRuntimeException;\n \n /**\n  * \n@@ -62,7 +65,8 @@ public static boolean copyFileToDir(Path source, File targetDir, String path) th\n \t}\n \t\n \t/**\n-\t * Use the closeSubsequentFS method to close the file system.\n+\t * Use the closeSubsequentFS method to close the file system. The method doesn't\n+\t * follow sym. links and its depth is limited.\n \t * \n \t * @param file The file to visit\n \t * @param filename The filename\n@@ -90,14 +94,14 @@ public static Path visit(File file, String filename, FileVisitor<Path> visitor)\n \t\t\tfPath = file.toPath();\n \t\t}\n \t\tif(fPath != null) {\n-\t\t    Files.walkFileTree(fPath, visitor);\n+\t\t    Files.walkFileTree(fPath, EnumSet.noneOf(FileVisitOption.class), 32, visitor);\n \t\t}\n \t\treturn fPath;\n \t}\n \t\n \tpublic static void closeSubsequentFS(Path path) {\n \t\tif(path != null && FileSystems.getDefault() != path.getFileSystem()) {\n-\t\t\tIOUtils.closeQuietly(path.getFileSystem());\n+\t\t\tIOUtils.closeQuietly(path.getFileSystem(), null);\n \t\t}\n \t}\n \t\n@@ -125,6 +129,10 @@ public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)\n \t    throws IOException {\n \t\t\tPath relativeFile = source.relativize(file);\n \t        final Path destFile = Paths.get(destDir.toString(), relativeFile.toString());\n+\t        Path normalizedPath = destFile.normalize();\n+\t\t\tif(!normalizedPath.startsWith(destDir)) {\n+\t\t\t\tthrow new OLATRuntimeException(\"Invalid ZIP\");\n+\t\t\t}\n \t        if(filter.matches(file)) {\n \t        \tFiles.copy(file, destFile, StandardCopyOption.REPLACE_EXISTING);\n \t        }",
    "function_modified_lines": {
      "added": [
        "\t        Path normalizedPath = destFile.normalize();\n",
        "\t\t\tif(!normalizedPath.startsWith(destDir)) {\n",
        "\t\t\t\tthrow new OLATRuntimeException(\"Invalid ZIP\");\n",
        "\t\t\t}\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "OpenOLAT is a web-based learning management system (LMS). A path traversal vulnerability exists in versions prior to 15.3.18, 15.5.3, and 16.0.0. Using a specially prepared ZIP file, it is possible to overwrite any file that is writable by the application server user (e.g. the tomcat user). Depending on the configuration this can be limited to files of the OpenOlat user data directory, however, if not properly set up, the attack could also be used to overwrite application server config files, java code or even operating system files. The attack could be used to corrupt or modify any OpenOlat file such as course structures, config files or temporary test data. Those attack would require in-depth knowledge of the installation and thus more theoretical. If the app server configuration allows the execution of jsp files and the path to the context is known, it is also possible to execute java code. If the app server runs with the same user that is used to deploy the OpenOlat code or has write permissions on the OpenOlat code files and the path to the context is know, code injection is possible. The attack requires an OpenOlat user account to upload a ZIP file and trigger the unzip method. It can not be exploited by unregistered users. The problem is fixed in versions 15.3.18, 15.5.3 and 16.0.0. There are no known workarounds aside from upgrading.",
    "id": 12532
  },
  {
    "cve_id": "CVE-2021-39180",
    "code_before_change": "/**\n* OLAT - Online Learning and Training<br>\n* http://www.olat.org\n* <p>\n* Licensed under the Apache License, Version 2.0 (the \"License\"); <br>\n* you may not use this file except in compliance with the License.<br>\n* You may obtain a copy of the License at\n* <p>\n* http://www.apache.org/licenses/LICENSE-2.0\n* <p>\n* Unless required by applicable law or agreed to in writing,<br>\n* software distributed under the License is distributed on an \"AS IS\" BASIS, <br>\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. <br>\n* See the License for the specific language governing permissions and <br>\n* limitations under the License.\n* <p>\n* Copyright (c) since 2004 at Multimedia- & E-Learning Services (MELS),<br>\n* University of Zurich, Switzerland.\n* <hr>\n* <a href=\"http://www.openolat.org\">\n* OpenOLAT - Online Learning and Training</a><br>\n* This file has been modified by the OpenOLAT community. Changes are licensed\n* under the Apache 2.0 license as the original file.\n*/\n\npackage org.olat.modules.wiki;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.nio.file.FileVisitResult;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.SimpleFileVisitor;\nimport java.nio.file.StandardCopyOption;\nimport java.nio.file.attribute.BasicFileAttributes;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Properties;\n\nimport org.apache.commons.codec.binary.Base64;\nimport org.apache.logging.log4j.Logger;\nimport org.olat.core.commons.services.notifications.SubscriptionContext;\nimport org.olat.core.gui.UserRequest;\nimport org.olat.core.gui.control.WindowControl;\nimport org.olat.core.id.OLATResourceable;\nimport org.olat.core.logging.AssertException;\nimport org.olat.core.logging.OLATRuntimeException;\nimport org.olat.core.logging.Tracing;\nimport org.olat.core.logging.activity.LearningResourceLoggingAction;\nimport org.olat.core.logging.activity.ThreadLocalUserActivityLogger;\nimport org.olat.core.util.FileUtils;\nimport org.olat.core.util.PathUtils;\nimport org.olat.core.util.cache.CacheWrapper;\nimport org.olat.core.util.coordinate.CoordinatorManager;\nimport org.olat.core.util.resource.OresHelper;\nimport org.olat.core.util.vfs.LocalFolderImpl;\nimport org.olat.core.util.vfs.VFSContainer;\nimport org.olat.core.util.vfs.VFSItem;\nimport org.olat.core.util.vfs.VFSLeaf;\nimport org.olat.core.util.vfs.VFSManager;\nimport org.olat.core.util.vfs.filters.VFSItemFilter;\nimport org.olat.core.util.vfs.filters.VFSItemSuffixFilter;\nimport org.olat.core.util.vfs.filters.VFSLeafFilter;\nimport org.olat.course.CourseModule;\nimport org.olat.course.nodes.WikiCourseNode;\nimport org.olat.course.run.environment.CourseEnvironment;\nimport org.olat.fileresource.FileResourceManager;\nimport org.olat.fileresource.types.FileResource;\nimport org.olat.fileresource.types.WikiResource;\nimport org.olat.group.BusinessGroup;\nimport org.olat.modules.wiki.versioning.DifferenceService;\nimport org.olat.modules.wiki.versioning.diff.CookbookDifferenceService;\nimport org.olat.resource.OLATResource;",
    "code_after_change": "/**\n* OLAT - Online Learning and Training<br>\n* http://www.olat.org\n* <p>\n* Licensed under the Apache License, Version 2.0 (the \"License\"); <br>\n* you may not use this file except in compliance with the License.<br>\n* You may obtain a copy of the License at\n* <p>\n* http://www.apache.org/licenses/LICENSE-2.0\n* <p>\n* Unless required by applicable law or agreed to in writing,<br>\n* software distributed under the License is distributed on an \"AS IS\" BASIS, <br>\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. <br>\n* See the License for the specific language governing permissions and <br>\n* limitations under the License.\n* <p>\n* Copyright (c) since 2004 at Multimedia- & E-Learning Services (MELS),<br>\n* University of Zurich, Switzerland.\n* <hr>\n* <a href=\"http://www.openolat.org\">\n* OpenOLAT - Online Learning and Training</a><br>\n* This file has been modified by the OpenOLAT community. Changes are licensed\n* under the Apache 2.0 license as the original file.\n*/\n\npackage org.olat.modules.wiki;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.nio.file.FileVisitOption;\nimport java.nio.file.FileVisitResult;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.SimpleFileVisitor;\nimport java.nio.file.StandardCopyOption;\nimport java.nio.file.attribute.BasicFileAttributes;\nimport java.util.EnumSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Properties;\n\nimport org.apache.commons.codec.binary.Base64;\nimport org.apache.logging.log4j.Logger;\nimport org.olat.core.commons.services.notifications.SubscriptionContext;\nimport org.olat.core.gui.UserRequest;\nimport org.olat.core.gui.control.WindowControl;\nimport org.olat.core.id.OLATResourceable;\nimport org.olat.core.logging.AssertException;\nimport org.olat.core.logging.OLATRuntimeException;\nimport org.olat.core.logging.Tracing;\nimport org.olat.core.logging.activity.LearningResourceLoggingAction;\nimport org.olat.core.logging.activity.ThreadLocalUserActivityLogger;\nimport org.olat.core.util.FileUtils;\nimport org.olat.core.util.PathUtils;\nimport org.olat.core.util.cache.CacheWrapper;\nimport org.olat.core.util.coordinate.CoordinatorManager;\nimport org.olat.core.util.resource.OresHelper;\nimport org.olat.core.util.vfs.LocalFolderImpl;\nimport org.olat.core.util.vfs.VFSContainer;\nimport org.olat.core.util.vfs.VFSItem;\nimport org.olat.core.util.vfs.VFSLeaf;\nimport org.olat.core.util.vfs.VFSManager;\nimport org.olat.core.util.vfs.filters.VFSItemFilter;\nimport org.olat.core.util.vfs.filters.VFSItemSuffixFilter;\nimport org.olat.core.util.vfs.filters.VFSLeafFilter;\nimport org.olat.course.CourseModule;\nimport org.olat.course.nodes.WikiCourseNode;\nimport org.olat.course.run.environment.CourseEnvironment;\nimport org.olat.fileresource.FileResourceManager;\nimport org.olat.fileresource.types.FileResource;\nimport org.olat.fileresource.types.WikiResource;\nimport org.olat.group.BusinessGroup;\nimport org.olat.modules.wiki.versioning.DifferenceService;",
    "patch": "@@ -30,13 +30,15 @@\n import java.io.InputStream;\n import java.io.OutputStream;\n import java.io.UnsupportedEncodingException;\n+import java.nio.file.FileVisitOption;\n import java.nio.file.FileVisitResult;\n import java.nio.file.Files;\n import java.nio.file.Path;\n import java.nio.file.Paths;\n import java.nio.file.SimpleFileVisitor;\n import java.nio.file.StandardCopyOption;\n import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.EnumSet;\n import java.util.Iterator;\n import java.util.List;\n import java.util.Properties;\n@@ -162,7 +164,7 @@ public boolean importWiki(File file, String filename, File targetDirectory) {\n \t\t\t}\n \t\t\t\n \t\t\tPath destDir = targetDirectory.toPath();\n-\t\t\tFiles.walkFileTree(path, new ImportVisitor(destDir));\n+\t\t\tFiles.walkFileTree(path, EnumSet.noneOf(FileVisitOption.class), 16, new ImportVisitor(destDir));\n \t\t\tPathUtils.closeSubsequentFS(path);\n \t\t\treturn true;\n \t\t} catch (IOException e) {\n@@ -299,26 +301,32 @@ public ImportVisitor(Path destDir) throws IOException {\n \t\tpublic FileVisitResult visitFile(Path file, BasicFileAttributes attrs)\n \t    throws IOException {\n \t\t\tString filename = file.getFileName().toString();\n-\t\t\tPath normalizedPath = file.normalize();\n-\t\t\tif(!normalizedPath.startsWith(destDir)) {\n-\t\t\t\tthrow new IOException(\"Invalid ZIP\");\n-\t\t\t}\n-\t\t\t\n+\n \t        if(filename.endsWith(WikiManager.WIKI_PROPERTIES_SUFFIX)) {\n \t        \tString f = convertAlternativeFilename(file.toString());\n \t        \tfinal Path destFile = Paths.get(wikiDir.toString(), f);\n+\t        \tcheckDestinationFile(destFile);\n \t        \tresetAndCopyProperties(file, destFile);\n \t        } else if (filename.endsWith(WIKI_FILE_SUFFIX)) {\n \t        \tString f = convertAlternativeFilename(file.toString());\n \t        \tfinal Path destFile = Paths.get(wikiDir.toString(), f);\n+\t        \tcheckDestinationFile(destFile);\n \t        \tFiles.copy(file, destFile, StandardCopyOption.REPLACE_EXISTING);\n \t\t\t} else if (!filename.contains(WIKI_FILE_SUFFIX + \"-\")\n \t\t\t\t\t&& !filename.contains(WIKI_PROPERTIES_SUFFIX + \"-\")) {\n \t\t\t\tfinal Path destFile = Paths.get(mediaDir.toString(), file.toString());\n+\t\t\t\tcheckDestinationFile(destFile);\n \t\t\t\tFiles.copy(file, destFile, StandardCopyOption.REPLACE_EXISTING);\n \t\t\t}\n \t        return FileVisitResult.CONTINUE;\n \t\t}\n+\t\t\n+\t\tprivate void checkDestinationFile(Path destFile) throws IOException {\n+\t\t\tPath normalizedPath = destFile.normalize();\n+\t\t\tif(!normalizedPath.startsWith(destDir)) {\n+\t\t\t\tthrow new OLATRuntimeException(\"Invalid ZIP\");\n+\t\t\t}\n+\t\t}\n \t \n \t\t@Override\n \t\tpublic FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs)",
    "function_modified_lines": {
      "added": [
        "import java.nio.file.FileVisitOption;\n",
        "import java.util.EnumSet;\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "OpenOLAT is a web-based learning management system (LMS). A path traversal vulnerability exists in versions prior to 15.3.18, 15.5.3, and 16.0.0. Using a specially prepared ZIP file, it is possible to overwrite any file that is writable by the application server user (e.g. the tomcat user). Depending on the configuration this can be limited to files of the OpenOlat user data directory, however, if not properly set up, the attack could also be used to overwrite application server config files, java code or even operating system files. The attack could be used to corrupt or modify any OpenOlat file such as course structures, config files or temporary test data. Those attack would require in-depth knowledge of the installation and thus more theoretical. If the app server configuration allows the execution of jsp files and the path to the context is known, it is also possible to execute java code. If the app server runs with the same user that is used to deploy the OpenOlat code or has write permissions on the OpenOlat code files and the path to the context is know, code injection is possible. The attack requires an OpenOlat user account to upload a ZIP file and trigger the unzip method. It can not be exploited by unregistered users. The problem is fixed in versions 15.3.18, 15.5.3 and 16.0.0. There are no known workarounds aside from upgrading.",
    "id": 12536
  },
  {
    "cve_id": "CVE-2021-39180",
    "code_before_change": "{\n\t\t\tString filename = file.getFileName().toString();\n\t\t\tPath normalizedPath = file.normalize();\n\t\t\tif(!normalizedPath.startsWith(destDir)) {\n\t\t\t\tthrow new IOException(\"Invalid ZIP\");\n\t\t\t}\n\t\t\t\n\t        if(filename.endsWith(WikiManager.WIKI_PROPERTIES_SUFFIX)) {\n\t        \tString f = convertAlternativeFilename(file.toString());\n\t        \tfinal Path destFile = Paths.get(wikiDir.toString(), f);\n\t        \tresetAndCopyProperties(file, destFile);\n\t        } else if (filename.endsWith(WIKI_FILE_SUFFIX)) {\n\t        \tString f = convertAlternativeFilename(file.toString());\n\t        \tfinal Path destFile = Paths.get(wikiDir.toString(), f);\n\t        \tFiles.copy(file, destFile, StandardCopyOption.REPLACE_EXISTING);\n\t\t\t} else if (!filename.contains(WIKI_FILE_SUFFIX + \"-\")\n\t\t\t\t\t&& !filename.contains(WIKI_PROPERTIES_SUFFIX + \"-\")) {\n\t\t\t\tfinal Path destFile = Paths.get(mediaDir.toString(), file.toString());\n\t\t\t\tFiles.copy(file, destFile, StandardCopyOption.REPLACE_EXISTING);\n\t\t\t}\n\t        return FileVisitResult.CONTINUE;\n\t\t}",
    "code_after_change": "{\n\t\t\n\t\tprivate final Path destDir;\n\t\tprivate final Path wikiDir;\n\t\tprivate final Path mediaDir;\n\t\t\n\t\tpublic ImportVisitor(Path destDir) throws IOException {\n\t\t\tthis.destDir = destDir;\n\t\t\twikiDir = destDir.resolve(WIKI_RESOURCE_FOLDER_NAME);\n\t\t\tFiles.createDirectories(wikiDir);\n\t\t\tmediaDir = destDir.resolve(WikiContainer.MEDIA_FOLDER_NAME);\n\t\t\tFiles.createDirectories(mediaDir);\n\t\t\tPath versionDir = destDir.resolve(VERSION_FOLDER_NAME);\n\t\t\tFiles.createDirectories(versionDir);\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic FileVisitResult visitFile(Path file, BasicFileAttributes attrs)\n\t    throws IOException {\n\t\t\tString filename = file.getFileName().toString();\n\n\t        if(filename.endsWith(WikiManager.WIKI_PROPERTIES_SUFFIX)) {\n\t        \tString f = convertAlternativeFilename(file.toString());\n\t        \tfinal Path destFile = Paths.get(wikiDir.toString(), f);\n\t        \tcheckDestinationFile(destFile);\n\t        \tresetAndCopyProperties(file, destFile);\n\t        } else if (filename.endsWith(WIKI_FILE_SUFFIX)) {\n\t        \tString f = convertAlternativeFilename(file.toString());\n\t        \tfinal Path destFile = Paths.get(wikiDir.toString(), f);\n\t        \tcheckDestinationFile(destFile);\n\t        \tFiles.copy(file, destFile, StandardCopyOption.REPLACE_EXISTING);\n\t\t\t} else if (!filename.contains(WIKI_FILE_SUFFIX + \"-\")\n\t\t\t\t\t&& !filename.contains(WIKI_PROPERTIES_SUFFIX + \"-\")) {\n\t\t\t\tfinal Path destFile = Paths.get(mediaDir.toString(), file.toString());\n\t\t\t\tcheckDestinationFile(destFile);\n\t\t\t\tFiles.copy(file, destFile, StandardCopyOption.REPLACE_EXISTING);\n\t\t\t}\n\t        return FileVisitResult.CONTINUE;\n\t\t}\n\t\t\n\t\tprivate void checkDestinationFile(Path destFile) throws IOException {\n\t\t\tPath normalizedPath = destFile.normalize();\n\t\t\tif(!normalizedPath.startsWith(destDir)) {\n\t\t\t\tthrow new OLATRuntimeException(\"Invalid ZIP\");\n\t\t\t}\n\t\t}\n\t \n\t\t@Override\n\t\tpublic FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs)\n\t\tthrows IOException {\n\t\t\tfinal Path dirToCreate = Paths.get(destDir.toString(), dir.toString());\n\t        if(Files.notExists(dirToCreate)){\n\t        \t\tFiles.createDirectory(dirToCreate);\n\t        }\n\t        return FileVisitResult.CONTINUE;\n\t\t}\n\t}",
    "patch": "@@ -30,13 +30,15 @@\n import java.io.InputStream;\n import java.io.OutputStream;\n import java.io.UnsupportedEncodingException;\n+import java.nio.file.FileVisitOption;\n import java.nio.file.FileVisitResult;\n import java.nio.file.Files;\n import java.nio.file.Path;\n import java.nio.file.Paths;\n import java.nio.file.SimpleFileVisitor;\n import java.nio.file.StandardCopyOption;\n import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.EnumSet;\n import java.util.Iterator;\n import java.util.List;\n import java.util.Properties;\n@@ -162,7 +164,7 @@ public boolean importWiki(File file, String filename, File targetDirectory) {\n \t\t\t}\n \t\t\t\n \t\t\tPath destDir = targetDirectory.toPath();\n-\t\t\tFiles.walkFileTree(path, new ImportVisitor(destDir));\n+\t\t\tFiles.walkFileTree(path, EnumSet.noneOf(FileVisitOption.class), 16, new ImportVisitor(destDir));\n \t\t\tPathUtils.closeSubsequentFS(path);\n \t\t\treturn true;\n \t\t} catch (IOException e) {\n@@ -299,26 +301,32 @@ public ImportVisitor(Path destDir) throws IOException {\n \t\tpublic FileVisitResult visitFile(Path file, BasicFileAttributes attrs)\n \t    throws IOException {\n \t\t\tString filename = file.getFileName().toString();\n-\t\t\tPath normalizedPath = file.normalize();\n-\t\t\tif(!normalizedPath.startsWith(destDir)) {\n-\t\t\t\tthrow new IOException(\"Invalid ZIP\");\n-\t\t\t}\n-\t\t\t\n+\n \t        if(filename.endsWith(WikiManager.WIKI_PROPERTIES_SUFFIX)) {\n \t        \tString f = convertAlternativeFilename(file.toString());\n \t        \tfinal Path destFile = Paths.get(wikiDir.toString(), f);\n+\t        \tcheckDestinationFile(destFile);\n \t        \tresetAndCopyProperties(file, destFile);\n \t        } else if (filename.endsWith(WIKI_FILE_SUFFIX)) {\n \t        \tString f = convertAlternativeFilename(file.toString());\n \t        \tfinal Path destFile = Paths.get(wikiDir.toString(), f);\n+\t        \tcheckDestinationFile(destFile);\n \t        \tFiles.copy(file, destFile, StandardCopyOption.REPLACE_EXISTING);\n \t\t\t} else if (!filename.contains(WIKI_FILE_SUFFIX + \"-\")\n \t\t\t\t\t&& !filename.contains(WIKI_PROPERTIES_SUFFIX + \"-\")) {\n \t\t\t\tfinal Path destFile = Paths.get(mediaDir.toString(), file.toString());\n+\t\t\t\tcheckDestinationFile(destFile);\n \t\t\t\tFiles.copy(file, destFile, StandardCopyOption.REPLACE_EXISTING);\n \t\t\t}\n \t        return FileVisitResult.CONTINUE;\n \t\t}\n+\t\t\n+\t\tprivate void checkDestinationFile(Path destFile) throws IOException {\n+\t\t\tPath normalizedPath = destFile.normalize();\n+\t\t\tif(!normalizedPath.startsWith(destDir)) {\n+\t\t\t\tthrow new OLATRuntimeException(\"Invalid ZIP\");\n+\t\t\t}\n+\t\t}\n \t \n \t\t@Override\n \t\tpublic FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs)",
    "function_modified_lines": {
      "added": [
        "\n",
        "\t        \tcheckDestinationFile(destFile);\n",
        "\t        \tcheckDestinationFile(destFile);\n",
        "\t\t\t\tcheckDestinationFile(destFile);\n",
        "\t\t\n",
        "\t\tprivate void checkDestinationFile(Path destFile) throws IOException {\n",
        "\t\t\tPath normalizedPath = destFile.normalize();\n",
        "\t\t\tif(!normalizedPath.startsWith(destDir)) {\n",
        "\t\t\t\tthrow new OLATRuntimeException(\"Invalid ZIP\");\n",
        "\t\t\t}\n",
        "\t\t}\n"
      ],
      "deleted": [
        "\t\t\tPath normalizedPath = file.normalize();\n",
        "\t\t\tif(!normalizedPath.startsWith(destDir)) {\n",
        "\t\t\t\tthrow new IOException(\"Invalid ZIP\");\n",
        "\t\t\t}\n",
        "\t\t\t\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "OpenOLAT is a web-based learning management system (LMS). A path traversal vulnerability exists in versions prior to 15.3.18, 15.5.3, and 16.0.0. Using a specially prepared ZIP file, it is possible to overwrite any file that is writable by the application server user (e.g. the tomcat user). Depending on the configuration this can be limited to files of the OpenOlat user data directory, however, if not properly set up, the attack could also be used to overwrite application server config files, java code or even operating system files. The attack could be used to corrupt or modify any OpenOlat file such as course structures, config files or temporary test data. Those attack would require in-depth knowledge of the installation and thus more theoretical. If the app server configuration allows the execution of jsp files and the path to the context is known, it is also possible to execute java code. If the app server runs with the same user that is used to deploy the OpenOlat code or has write permissions on the OpenOlat code files and the path to the context is know, code injection is possible. The attack requires an OpenOlat user account to upload a ZIP file and trigger the unzip method. It can not be exploited by unregistered users. The problem is fixed in versions 15.3.18, 15.5.3 and 16.0.0. There are no known workarounds aside from upgrading.",
    "id": 12537
  },
  {
    "cve_id": "CVE-2021-41152",
    "code_before_change": "/**\n* OLAT - Online Learning and Training<br>\n* http://www.olat.org\n* <p>\n* Licensed under the Apache License, Version 2.0 (the \"License\"); <br>\n* you may not use this file except in compliance with the License.<br>\n* You may obtain a copy of the License at\n* <p>\n* http://www.apache.org/licenses/LICENSE-2.0\n* <p>\n* Unless required by applicable law or agreed to in writing,<br>\n* software distributed under the License is distributed on an \"AS IS\" BASIS, <br>\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. <br>\n* See the License for the specific language governing permissions and <br>\n* limitations under the License.\n* <p>\n* Copyright (c) since 2004 at Multimedia- & E-Learning Services (MELS),<br>\n* University of Zurich, Switzerland.\n* <hr>\n* <a href=\"http://www.openolat.org\">\n* OpenOLAT - Online Learning and Training</a><br>\n* This file has been modified by the OpenOLAT community. Changes are licensed\n* under the Apache 2.0 license as the original file.  \n* <p>\n*/ \n\npackage org.olat.core.commons.modules.bc;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport org.olat.core.gui.UserRequest;\nimport org.olat.core.util.FileUtils;\nimport org.olat.core.util.StringHelper;\n\npublic class FileSelection {\n\n\t/** HTML form identifier */\n\tpublic static final String FORM_ID = \"paths\";\n\t\n\tprivate List<String> files = new ArrayList<>();\n\tprivate String currentContainerRelPath;\n\t\n\tpublic FileSelection(UserRequest ureq, String currentContainerRelPath) {\n\t\tif (currentContainerRelPath.equals(\"/\")) currentContainerRelPath = \"\";\n\t\tthis.currentContainerRelPath = currentContainerRelPath;\n\t\tparse(ureq);\n\t}\n\n\tpublic List<String> getFiles() {\n\t\treturn files;\n\t}\n\t\n\t/**\n\t * Checks if there is at least one file with invalid file name in the selection.\n\t * Returns the list with the invalid filenames.\n\t * \n\t * @return\n\t */\n\tpublic List<String> getInvalidFileNames() {\n\t\tList<String> invalidFileNames = new ArrayList<>();\n\t\tList<String> filesList = getFiles();\n\t\tfor(String fileName:filesList) {\n\t\t\tif(!FileUtils.validateFilename(fileName)) {\n\t\t\t\tinvalidFileNames.add(fileName);\n\t\t\t}\n\t\t}\n\t\treturn invalidFileNames;\n\t}\n\t\n\t/**\n\t * Parse paths and build BriefcasePath wrappers.\n\t * @param base\n\t * @param ureq\n\t */\n\tprivate void parse(UserRequest ureq) {\n\t\tString[] sFiles = ureq.getHttpReq().getParameterValues(FORM_ID);\n\t\tif (sFiles == null || sFiles.length == 0) return;\n\t\tfiles = Arrays.asList(sFiles);\n\t}\n\n\t/**\n\t * Render pathset as HTML.\n\t * \n\t * @return HTML Fragment.\n\t */\n\tpublic String renderAsHtml() {\n\t\tStringBuilder sb = new StringBuilder(255);\n\t\tsb.append(\"<ul>\");\n\t\tfor (String filename:files) {\n\t\t\tsb.append(\"<li>\")\n\t\t\t  .append(currentContainerRelPath).append(\"/\").append(StringHelper.escapeHtml(filename))\n\t\t\t  .append(\"</li>\");\n\t\t}\n\t\tsb.append(\"</ul>\");\n\t\treturn sb.toString();\n\t}\n}\n",
    "code_after_change": "/**\n* OLAT - Online Learning and Training<br>\n* http://www.olat.org\n* <p>\n* Licensed under the Apache License, Version 2.0 (the \"License\"); <br>\n* you may not use this file except in compliance with the License.<br>\n* You may obtain a copy of the License at\n* <p>\n* http://www.apache.org/licenses/LICENSE-2.0\n* <p>\n* Unless required by applicable law or agreed to in writing,<br>\n* software distributed under the License is distributed on an \"AS IS\" BASIS, <br>\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. <br>\n* See the License for the specific language governing permissions and <br>\n* limitations under the License.\n* <p>\n* Copyright (c) since 2004 at Multimedia- & E-Learning Services (MELS),<br>\n* University of Zurich, Switzerland.\n* <hr>\n* <a href=\"http://www.openolat.org\">\n* OpenOLAT - Online Learning and Training</a><br>\n* This file has been modified by the OpenOLAT community. Changes are licensed\n* under the Apache 2.0 license as the original file.  \n* <p>\n*/ \n\npackage org.olat.core.commons.modules.bc;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\nimport org.olat.core.gui.UserRequest;\nimport org.olat.core.util.FileUtils;\nimport org.olat.core.util.StringHelper;\nimport org.olat.core.util.vfs.VFSContainer;\nimport org.olat.core.util.vfs.VFSItem;\n\npublic class FileSelection {\n\n\t/** HTML form identifier */\n\tpublic static final String FORM_ID = \"paths\";\n\t\n\tprivate final List<String> files = new ArrayList<>();\n\tprivate final String currentContainerRelPath;\n\tprivate final VFSContainer currentContainer;\n\t\n\tpublic FileSelection(UserRequest ureq, VFSContainer currentContainer, String currentContainerRelPath) {\n\t\tif (currentContainerRelPath.equals(\"/\")) currentContainerRelPath = \"\";\n\t\tthis.currentContainerRelPath = currentContainerRelPath;\n\t\tthis.currentContainer = currentContainer;\n\t\tparse(ureq);\n\t}\n\n\tpublic List<String> getFiles() {\n\t\treturn files;\n\t}\n\t\n\t/**\n\t * Checks if there is at least one file with invalid file name in the selection.\n\t * Returns the list with the invalid filenames.\n\t * \n\t * @return\n\t */\n\tpublic List<String> getInvalidFileNames() {\n\t\tList<String> invalidFileNames = new ArrayList<>();\n\t\tList<String> filesList = getFiles();\n\t\tfor(String fileName:filesList) {\n\t\t\tif(!FileUtils.validateFilename(fileName)) {\n\t\t\t\tinvalidFileNames.add(fileName);\n\t\t\t}\n\t\t}\n\t\treturn invalidFileNames;\n\t}\n\t\n\t/**\n\t * Parse paths and build BriefcasePath wrappers.\n\t * @param base\n\t * @param ureq\n\t */\n\tprivate void parse(UserRequest ureq) {\n\t\tString[] sFiles = ureq.getHttpReq().getParameterValues(FORM_ID);\n\t\tif (sFiles == null || sFiles.length == 0) {\n\t\t\treturn;\n\t\t}\n\t\tList<VFSItem> items = currentContainer.getItems();\n\t\tif(items != null && !items.isEmpty()) {\n\t\t\tSet<String> itemNames =  items.stream()\n\t\t\t\t\t.map(VFSItem::getName)\n\t\t\t\t\t.collect(Collectors.toSet());\n\t\t\tfor(String sFile:sFiles) {\n\t\t\t\tif(itemNames.contains(sFile)) {\n\t\t\t\t\tfiles.add(sFile);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Render pathset as HTML.\n\t * \n\t * @return HTML Fragment.\n\t */\n\tpublic String renderAsHtml() {\n\t\tStringBuilder sb = new StringBuilder(255);\n\t\tsb.append(\"<ul>\");\n\t\tfor (String filename:files) {\n\t\t\tsb.append(\"<li>\")\n\t\t\t  .append(currentContainerRelPath).append(\"/\").append(StringHelper.escapeHtml(filename))\n\t\t\t  .append(\"</li>\");\n\t\t}\n\t\tsb.append(\"</ul>\");\n\t\treturn sb.toString();\n\t}\n}\n",
    "patch": "@@ -27,24 +27,29 @@\n package org.olat.core.commons.modules.bc;\n \n import java.util.ArrayList;\n-import java.util.Arrays;\n import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n \n import org.olat.core.gui.UserRequest;\n import org.olat.core.util.FileUtils;\n import org.olat.core.util.StringHelper;\n+import org.olat.core.util.vfs.VFSContainer;\n+import org.olat.core.util.vfs.VFSItem;\n \n public class FileSelection {\n \n \t/** HTML form identifier */\n \tpublic static final String FORM_ID = \"paths\";\n \t\n-\tprivate List<String> files = new ArrayList<>();\n-\tprivate String currentContainerRelPath;\n+\tprivate final List<String> files = new ArrayList<>();\n+\tprivate final String currentContainerRelPath;\n+\tprivate final VFSContainer currentContainer;\n \t\n-\tpublic FileSelection(UserRequest ureq, String currentContainerRelPath) {\n+\tpublic FileSelection(UserRequest ureq, VFSContainer currentContainer, String currentContainerRelPath) {\n \t\tif (currentContainerRelPath.equals(\"/\")) currentContainerRelPath = \"\";\n \t\tthis.currentContainerRelPath = currentContainerRelPath;\n+\t\tthis.currentContainer = currentContainer;\n \t\tparse(ureq);\n \t}\n \n@@ -76,8 +81,20 @@ public List<String> getInvalidFileNames() {\n \t */\n \tprivate void parse(UserRequest ureq) {\n \t\tString[] sFiles = ureq.getHttpReq().getParameterValues(FORM_ID);\n-\t\tif (sFiles == null || sFiles.length == 0) return;\n-\t\tfiles = Arrays.asList(sFiles);\n+\t\tif (sFiles == null || sFiles.length == 0) {\n+\t\t\treturn;\n+\t\t}\n+\t\tList<VFSItem> items = currentContainer.getItems();\n+\t\tif(items != null && !items.isEmpty()) {\n+\t\t\tSet<String> itemNames =  items.stream()\n+\t\t\t\t\t.map(VFSItem::getName)\n+\t\t\t\t\t.collect(Collectors.toSet());\n+\t\t\tfor(String sFile:sFiles) {\n+\t\t\t\tif(itemNames.contains(sFile)) {\n+\t\t\t\t\tfiles.add(sFile);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \t}\n \n \t/**",
    "function_modified_lines": {
      "added": [
        "import java.util.Set;\n",
        "import java.util.stream.Collectors;\n",
        "import org.olat.core.util.vfs.VFSContainer;\n",
        "import org.olat.core.util.vfs.VFSItem;\n",
        "\tprivate final List<String> files = new ArrayList<>();\n",
        "\tprivate final String currentContainerRelPath;\n",
        "\tprivate final VFSContainer currentContainer;\n",
        "\tpublic FileSelection(UserRequest ureq, VFSContainer currentContainer, String currentContainerRelPath) {\n",
        "\t\tthis.currentContainer = currentContainer;\n"
      ],
      "deleted": [
        "import java.util.Arrays;\n",
        "\tprivate List<String> files = new ArrayList<>();\n",
        "\tprivate String currentContainerRelPath;\n",
        "\tpublic FileSelection(UserRequest ureq, String currentContainerRelPath) {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "OpenOlat is a web-based e-learning platform for teaching, learning, assessment and communication, an LMS, a learning management system. In affected versions by manipulating the HTTP request an attacker can modify the path of a requested file download in the folder component to point to anywhere on the target system. The attack could be used to read any file accessible in the web root folder or outside, depending on the configuration of the system and the properly configured permission of the application server user. The attack requires an OpenOlat user account or the enabled guest user feature together with the usage of the folder component in a course. The attack does not allow writing of arbitrary files, it allows only reading of files and also only ready of files that the attacker knows the exact path which is very unlikely at least for OpenOlat data files. The problem is fixed in version 15.5.8 and 16.0.1 It is advised to upgrade to version 16.0.x. There are no known workarounds to fix this problem, an upgrade is necessary.",
    "id": 12538
  },
  {
    "cve_id": "CVE-2021-41242",
    "code_before_change": "{\n\n\t/**\n\t * @return a list of VFSItem containing \n\t */\n\tpublic List<VFSItem> getItems();\n\t\n\t/**\n\t * @return a list of VFSItem which are accepted by the given filter. If a\n\t *         default filter is set, the default filter will be applied in\n\t *         addition to the given filter in this method\n\t */\n\tpublic List<VFSItem> getItems(VFSItemFilter filter);\n\t\n\t/**\n\t * copy either a file or a folder to this folder.\n\t * e.g. this folder is based at /bla/blu, copying source bli (from /whatever/bli) \n\t * will add a child bli, so it looks like /bla/blu/bli later.\n\t * the operation fails when\n\t * the source or target do not support canCopyFrom and canCopyTo, resp., or\n\t * there is already a child with the same name, or the quota would be exceeded.\n\t * \n\t * @param source the source (must exist)\n\t * @param savedBy The identity who copied the source\n\t * @return the status\n\t */\n\tpublic VFSStatus copyFrom(VFSItem source, Identity savedBy);\n\t\n\t/**\n\t * \n\t * @param container\n\t * @param savedBy  The identity who copied the container\n\t * @return\n\t */\n\tpublic VFSStatus copyContentOf(VFSContainer container, Identity savedBy);\n\n\t/**\n\t * Create a new child container (of same type) if possible.\n\t * \n\t * @param name\n\t * @return VFSItem if successfull, null otherwise.\n\t */\n\tpublic VFSContainer createChildContainer(String name);\n\t\n\t/**\n\t * Create a new leaf (of same type) if possible,\n\t * @param name\n\t * @return VFSItem if successfull, null otherwise.\n\t */\n\tpublic VFSLeaf createChildLeaf(String name);\n\t\n\t/**\n\t * \n\t * @param path\n\t * @return\n\t */\n\tpublic boolean isInPath(String path);\n\t\n\t/**\n\t * Set a default filter that will be applied to this container getItems method\n\t * \n\t * @param defaultFilter\n\t */\n\tpublic void setDefaultItemFilter(VFSItemFilter defaultFilter);\n\n\t/**\n\t * @return The default filter for this container or NULL if no filter is set\n\t */\n\tpublic VFSItemFilter getDefaultItemFilter();\n\n}",
    "code_after_change": "{\n\n\t/**\n\t * @return a list of VFSItem containing \n\t */\n\tpublic List<VFSItem> getItems();\n\t\n\t/**\n\t * @return a list of VFSItem which are accepted by the given filter. If a\n\t *         default filter is set, the default filter will be applied in\n\t *         addition to the given filter in this method\n\t */\n\tpublic List<VFSItem> getItems(VFSItemFilter filter);\n\t\n\t/**\n\t * copy either a file or a folder to this folder.\n\t * e.g. this folder is based at /bla/blu, copying source bli (from /whatever/bli) \n\t * will add a child bli, so it looks like /bla/blu/bli later.\n\t * the operation fails when\n\t * the source or target do not support canCopyFrom and canCopyTo, resp., or\n\t * there is already a child with the same name, or the quota would be exceeded.\n\t * \n\t * @param source the source (must exist)\n\t * @param savedBy The identity who copied the source\n\t * @return the status\n\t */\n\tpublic VFSStatus copyFrom(VFSItem source, Identity savedBy);\n\t\n\t/**\n\t * \n\t * @param container\n\t * @param savedBy  The identity who copied the container\n\t * @return\n\t */\n\tpublic VFSStatus copyContentOf(VFSContainer container, Identity savedBy);\n\n\t/**\n\t * Create a new child container (of same type) if possible.\n\t * \n\t * @param name\n\t * @return VFSItem if successful, null otherwise.\n\t */\n\tpublic VFSContainer createChildContainer(String name);\n\t\n\t/**\n\t * Create a new leaf (of same type) if possible,\n\t * @param name\n\t * @return VFSItem if successful, null otherwise.\n\t */\n\tpublic VFSLeaf createChildLeaf(String name);\n\t\n\t/**\n\t * \n\t * @param path\n\t * @return\n\t */\n\tpublic boolean isInPath(String path);\n\t\n\t/**\n\t * Set a default filter that will be applied to this container getItems method\n\t * \n\t * @param defaultFilter\n\t */\n\tpublic void setDefaultItemFilter(VFSItemFilter defaultFilter);\n\n\t/**\n\t * @return The default filter for this container or NULL if no filter is set\n\t */\n\tpublic VFSItemFilter getDefaultItemFilter();\n\n}",
    "patch": "@@ -78,14 +78,14 @@ public interface VFSContainer extends VFSItem {\n \t * Create a new child container (of same type) if possible.\n \t * \n \t * @param name\n-\t * @return VFSItem if successfull, null otherwise.\n+\t * @return VFSItem if successful, null otherwise.\n \t */\n \tpublic VFSContainer createChildContainer(String name);\n \t\n \t/**\n \t * Create a new leaf (of same type) if possible,\n \t * @param name\n-\t * @return VFSItem if successfull, null otherwise.\n+\t * @return VFSItem if successful, null otherwise.\n \t */\n \tpublic VFSLeaf createChildLeaf(String name);\n \t",
    "function_modified_lines": {
      "added": [
        "\t * @return VFSItem if successful, null otherwise.\n",
        "\t * @return VFSItem if successful, null otherwise.\n"
      ],
      "deleted": [
        "\t * @return VFSItem if successfull, null otherwise.\n",
        "\t * @return VFSItem if successfull, null otherwise.\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "OpenOlat is a web-basedlearning management system. A path traversal vulnerability exists in OpenOlat prior to versions 15.5.12 and 16.0.5. By providing a filename that contains a relative path as a parameter in some REST methods, it is possible to create directory structures and write files anywhere on the target system. The attack could be used to write files anywhere in the web root folder or outside, depending on the configuration of the system and the properly configured permission of the application server user. The attack requires an OpenOlat user account, an enabled REST API and the rights on a business object to call the vulnerable REST calls. The problem is fixed in version 15.5.12 and 16.0.5. There is a workaround available. The vulnerability requires the REST module to be enabled. Disabling the REST module or limiting the REST module via some firewall or web-server access rules to be accessed only be trusted systems will mitigate the risk.",
    "id": 12539
  },
  {
    "cve_id": "CVE-2021-41242",
    "code_before_change": "\t * @file file64 The attachment (encoded as Base64)\n\t * @param request The HTTP request\n\t * @return Ok\n\t */\n\t@POST\n\t@Operation(summary = \"Post attachment\",\n\tdescription = \"Upload the attachment of a message.\")\n\t@Path(\"posts/{messageKey}/attachments\")\n\t@ApiResponse(responseCode = \"200\", description = \"Ok.\")\n\t@ApiResponse(responseCode = \"404\", description = \" The identity or the portrait not found\")\n\t@Consumes(MediaType.APPLICATION_FORM_URLENCODED)\n\t@Produces({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON})\n\tpublic Response replyToPostAttachment(@PathParam(\"messageKey\") Long messageKey, @FormParam(\"filename\") String filename,\n\t\t\t@FormParam(\"file\") String file, @Context HttpServletRequest request) {\n\t\tbyte[] fileAsBytes = Base64.decodeBase64(file);\n\t\tInputStream in = new ByteArrayInputStream(fileAsBytes);\n\t\treturn attachToPost(messageKey, filename, in, request);\n\t}\n\t\n\t@PUT\n\t@Operation(summary = \"Put attachment\", description = \"Upload the attachment of a message.\")\n\t@ApiResponse(responseCode = \"200\", description = \"Ok.\")\n\t@ApiResponse(responseCode = \"404\", description = \" The identity or the portrait not found\")\n\t@Path(\"posts/{messageKey}/attachments\")\n\t@Consumes({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON})\n\t@Produces({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON})\n\tpublic Response replyToPostAttachment(@PathParam(\"messageKey\") Long messageKey,  File64VO file64, @Context HttpServletRequest request) {\n\t\tString file = file64.getFile();\n\t\tString filename = file64.getFilename();\n\t\tbyte[] fileAsBytes = Base64.decodeBase64(file);\n\t\tInputStream in = new ByteArrayInputStream(fileAsBytes);\n\t\treturn attachToPost(messageKey, filename, in, request);\n\t}\n\t\n\tprotected Response attachToPost(Long messageKey, String filename, InputStream file,  HttpServletRequest request) {\n\t\t//load message\n\t\tMessage mess = fom.loadMessage(messageKey);\n\t\tif(mess == null) {\n\t\t\treturn Response.serverError().status(Status.NOT_FOUND).build();\n\t\t}\n\t\tif(!forum.equalsByPersistableKey(mess.getForum())) {\n\t\t\treturn Response.serverError().status(Status.CONFLICT).build();\n\t\t}\n\t\treturn attachToPost(mess, filename, file, request);\n\t}\n\n\tprotected Response attachToPost(Message mess, String filename, InputStream file,  HttpServletRequest request) {\n\t\tIdentity identity = getIdentity(request);\n\t\tif(identity == null) {\n\t\t\treturn Response.serverError().status(Status.UNAUTHORIZED).build();\n\t\t} else if (!identity.equalsByPersistableKey(mess.getCreator())) {\n\t\t\tif(mess.getModifier() == null || !identity.equalsByPersistableKey(mess.getModifier())) {\n\t\t\t\treturn Response.serverError().status(Status.UNAUTHORIZED).build();\n\t\t\t}\n\t\t}\n\n\t\tVFSContainer container = fom.getMessageContainer(mess.getForum().getKey(), mess.getKey());\n\t\tVFSItem item = container.resolve(filename);\n\t\tVFSLeaf attachment = null;\n\t\tif(item == null) {\n\t\t\tattachment = container.createChildLeaf(filename);\n\t\t} else {\n\t\t\tfilename = VFSManager.rename(container, filename);\n\t\t\tif(filename == null) {\n\t\t\t\treturn Response.serverError().status(Status.NOT_ACCEPTABLE).build();\n\t\t\t}\n\t\t\tattachment = container.createChildLeaf(filename);\n\t\t}\n\t\t\n\n\t\ttry(OutputStream out = attachment.getOutputStream(false)) {\n\t\t\tIOUtils.copy(file, out);\n\t\t} catch (IOException e) {\n\t\t\treturn Response.serverError().status(Status.INTERNAL_SERVER_ERROR).build();\n\t\t} finally {\n\t\t\tFileUtils.closeSafely(file);\n\t\t}\n\t\treturn Response.ok().build();\n\t}\n\t\n\tpublic String format(String segment) {\n\t\tsegment = segment.replace(\" \", \"_\");\n\t\treturn segment;",
    "code_after_change": "\t * @file file64 The attachment (encoded as Base64)\n\t * @param request The HTTP request\n\t * @return Ok\n\t */\n\t@POST\n\t@Operation(summary = \"Post attachment\",\n\tdescription = \"Upload the attachment of a message.\")\n\t@Path(\"posts/{messageKey}/attachments\")\n\t@ApiResponse(responseCode = \"200\", description = \"Ok.\")\n\t@ApiResponse(responseCode = \"404\", description = \" The identity or the portrait not found\")\n\t@Consumes(MediaType.APPLICATION_FORM_URLENCODED)\n\t@Produces({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON})\n\tpublic Response replyToPostAttachment(@PathParam(\"messageKey\") Long messageKey, @FormParam(\"filename\") String filename,\n\t\t\t@FormParam(\"file\") String file, @Context HttpServletRequest request) {\n\t\tbyte[] fileAsBytes = Base64.decodeBase64(file);\n\t\tInputStream in = new ByteArrayInputStream(fileAsBytes);\n\t\treturn attachToPost(messageKey, filename, in, request);\n\t}\n\t\n\t@PUT\n\t@Operation(summary = \"Put attachment\", description = \"Upload the attachment of a message.\")\n\t@ApiResponse(responseCode = \"200\", description = \"Ok.\")\n\t@ApiResponse(responseCode = \"404\", description = \" The identity or the portrait not found\")\n\t@Path(\"posts/{messageKey}/attachments\")\n\t@Consumes({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON})\n\t@Produces({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON})\n\tpublic Response replyToPostAttachment(@PathParam(\"messageKey\") Long messageKey,  File64VO file64, @Context HttpServletRequest request) {\n\t\tString file = file64.getFile();\n\t\tString filename = file64.getFilename();\n\t\tbyte[] fileAsBytes = Base64.decodeBase64(file);\n\t\tInputStream in = new ByteArrayInputStream(fileAsBytes);\n\t\treturn attachToPost(messageKey, filename, in, request);\n\t}\n\t\n\tprivate Response attachToPost(Long messageKey, String filename, InputStream file,  HttpServletRequest request) {\n\t\t//load message\n\t\tMessage mess = fom.loadMessage(messageKey);\n\t\tif(mess == null) {\n\t\t\treturn Response.serverError().status(Status.NOT_FOUND).build();\n\t\t}\n\t\tif(!forum.equalsByPersistableKey(mess.getForum())) {\n\t\t\treturn Response.serverError().status(Status.CONFLICT).build();\n\t\t}\n\t\treturn attachToPost(mess, filename, file, request);\n\t}\n\n\tprivate Response attachToPost(Message mess, String filename, InputStream file,  HttpServletRequest request) {\n\t\tIdentity identity = getIdentity(request);\n\t\tif(identity == null) {\n\t\t\treturn Response.serverError().status(Status.UNAUTHORIZED).build();\n\t\t} else if (!identity.equalsByPersistableKey(mess.getCreator())) {\n\t\t\tif(mess.getModifier() == null || !identity.equalsByPersistableKey(mess.getModifier())) {\n\t\t\t\treturn Response.serverError().status(Status.UNAUTHORIZED).build();\n\t\t\t}\n\t\t}\n\n\t\tVFSContainer container = fom.getMessageContainer(mess.getForum().getKey(), mess.getKey());\n\t\tVFSItem item = container.resolve(filename);\n\t\tVFSLeaf attachment = null;\n\t\tif(item == null) {\n\t\t\tattachment = container.createChildLeaf(filename);\n\t\t} else {\n\t\t\tfilename = VFSManager.rename(container, filename);\n\t\t\tif(filename == null) {\n\t\t\t\treturn Response.serverError().status(Status.NOT_ACCEPTABLE).build();\n\t\t\t}\n\t\t\tattachment = container.createChildLeaf(filename);\n\t\t}\n\t\t\n\n\t\ttry(OutputStream out = attachment.getOutputStream(false)) {\n\t\t\tIOUtils.copy(file, out);\n\t\t} catch (IOException e) {\n\t\t\treturn Response.serverError().status(Status.INTERNAL_SERVER_ERROR).build();\n\t\t} finally {\n\t\t\tFileUtils.closeSafely(file);\n\t\t}\n\t\treturn Response.ok().build();\n\t}\n\t\n\tpublic String format(String segment) {\n\t\tsegment = segment.replace(\" \", \"_\");\n\t\treturn segment;",
    "patch": "@@ -598,7 +598,7 @@ public Response replyToPostAttachment(@PathParam(\"messageKey\") Long messageKey,\n \t\treturn attachToPost(messageKey, filename, in, request);\n \t}\n \t\n-\tprotected Response attachToPost(Long messageKey, String filename, InputStream file,  HttpServletRequest request) {\n+\tprivate Response attachToPost(Long messageKey, String filename, InputStream file,  HttpServletRequest request) {\n \t\t//load message\n \t\tMessage mess = fom.loadMessage(messageKey);\n \t\tif(mess == null) {\n@@ -610,7 +610,7 @@ protected Response attachToPost(Long messageKey, String filename, InputStream fi\n \t\treturn attachToPost(mess, filename, file, request);\n \t}\n \n-\tprotected Response attachToPost(Message mess, String filename, InputStream file,  HttpServletRequest request) {\n+\tprivate Response attachToPost(Message mess, String filename, InputStream file,  HttpServletRequest request) {\n \t\tIdentity identity = getIdentity(request);\n \t\tif(identity == null) {\n \t\t\treturn Response.serverError().status(Status.UNAUTHORIZED).build();",
    "function_modified_lines": {
      "added": [
        "\tprivate Response attachToPost(Long messageKey, String filename, InputStream file,  HttpServletRequest request) {\n",
        "\tprivate Response attachToPost(Message mess, String filename, InputStream file,  HttpServletRequest request) {\n"
      ],
      "deleted": [
        "\tprotected Response attachToPost(Long messageKey, String filename, InputStream file,  HttpServletRequest request) {\n",
        "\tprotected Response attachToPost(Message mess, String filename, InputStream file,  HttpServletRequest request) {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "OpenOlat is a web-basedlearning management system. A path traversal vulnerability exists in OpenOlat prior to versions 15.5.12 and 16.0.5. By providing a filename that contains a relative path as a parameter in some REST methods, it is possible to create directory structures and write files anywhere on the target system. The attack could be used to write files anywhere in the web root folder or outside, depending on the configuration of the system and the properly configured permission of the application server user. The attack requires an OpenOlat user account, an enabled REST API and the rights on a business object to call the vulnerable REST calls. The problem is fixed in version 15.5.12 and 16.0.5. There is a workaround available. The vulnerability requires the REST module to be enabled. Disabling the REST module or limiting the REST module via some firewall or web-server access rules to be accessed only be trusted systems will mitigate the risk.",
    "id": 12540
  },
  {
    "cve_id": "CVE-2021-41242",
    "code_before_change": "{\n\t\t\treader = new MultipartReader(request);\n\t\t\tString filename = reader.getValue(\"filename\", \"task\");\n\t\t\tString taskFolderPath = TACourseNode.getTaskFolderPathRelToFolderRoot(course, parentNode.getCourseNode());\n\t\t\tVFSContainer taskFolder = VFSManager.olatRootContainer(taskFolderPath, null);\n\t\t\tVFSLeaf singleFile = (VFSLeaf) taskFolder.resolve(\"/\" + filename);\n\t\t\tif (singleFile == null) {\n\t\t\t\tsingleFile = taskFolder.createChildLeaf(\"/\" + filename);\n\t\t\t}\n\t\t\tFile file = reader.getFile();\n\t\t\tif(file != null) {\n\t\t\t\tin = new FileInputStream(file);\n\t\t\t\tOutputStream out = singleFile.getOutputStream(false);\n\t\t\t\tIOUtils.copy(in, out);\n\t\t\t\tIOUtils.closeQuietly(out);\n\t\t\t} else {\n\t\t\t\treturn Response.status(Status.NOT_ACCEPTABLE).build();\n\t\t\t}\n\t\t}",
    "code_after_change": "{\n\t\t\treader = new MultipartReader(request);\n\t\t\tString filename = reader.getValue(\"filename\", \"task\");\n\t\t\tString taskFolderPath = TACourseNode.getTaskFolderPathRelToFolderRoot(course, parentNode.getCourseNode());\n\t\t\tVFSContainer taskFolder = VFSManager.olatRootContainer(taskFolderPath, null);\n\t\t\tVFSLeaf singleFile = (VFSLeaf)taskFolder.resolve(filename);\n\t\t\tif (singleFile == null) {\n\t\t\t\tsingleFile = taskFolder.createChildLeaf(filename);\n\t\t\t}\n\t\t\tFile file = reader.getFile();\n\t\t\tif(file != null) {\n\t\t\t\tin = new FileInputStream(file);\n\t\t\t\tOutputStream out = singleFile.getOutputStream(false);\n\t\t\t\tIOUtils.copy(in, out);\n\t\t\t\tIOUtils.closeQuietly(out);\n\t\t\t} else {\n\t\t\t\treturn Response.status(Status.NOT_ACCEPTABLE).build();\n\t\t\t}\n\t\t}",
    "patch": "@@ -1365,9 +1365,9 @@ public Response attachTaskFile(@PathParam(\"courseId\") Long courseId, @PathParam(\n \t\t\tString filename = reader.getValue(\"filename\", \"task\");\n \t\t\tString taskFolderPath = TACourseNode.getTaskFolderPathRelToFolderRoot(course, parentNode.getCourseNode());\n \t\t\tVFSContainer taskFolder = VFSManager.olatRootContainer(taskFolderPath, null);\n-\t\t\tVFSLeaf singleFile = (VFSLeaf) taskFolder.resolve(\"/\" + filename);\n+\t\t\tVFSLeaf singleFile = (VFSLeaf)taskFolder.resolve(filename);\n \t\t\tif (singleFile == null) {\n-\t\t\t\tsingleFile = taskFolder.createChildLeaf(\"/\" + filename);\n+\t\t\t\tsingleFile = taskFolder.createChildLeaf(filename);\n \t\t\t}\n \t\t\tFile file = reader.getFile();\n \t\t\tif(file != null) {\n@@ -2314,9 +2314,9 @@ public void configure(ICourse course, CourseNode newNode, ModuleConfiguration mo\n \t\t\tif(STCourseNodeEditController.CONFIG_VALUE_DISPLAY_FILE.equals(moduleConfig.getStringValue(STCourseNodeEditController.CONFIG_KEY_DISPLAY_TYPE))) {\n \t\t\t\tif(in != null && StringHelper.containsNonWhitespace(filename)) {\n \t\t\t\t\tVFSContainer rootContainer = course.getCourseFolderContainer();\n-\t\t\t\t\tVFSLeaf singleFile = (VFSLeaf) rootContainer.resolve(\"/\" + filename);\n+\t\t\t\t\tVFSLeaf singleFile = (VFSLeaf) rootContainer.resolve(filename);\n \t\t\t\t\tif (singleFile == null) {\n-\t\t\t\t\t\tsingleFile = rootContainer.createChildLeaf(\"/\" + filename);\n+\t\t\t\t\t\tsingleFile = rootContainer.createChildLeaf(filename);\n \t\t\t\t\t}\n \t\n \t\t\t\t\tmoduleConfig.set(STCourseNodeEditController.CONFIG_KEY_FILE, \"/\" + filename);\n@@ -2326,7 +2326,7 @@ public void configure(ICourse course, CourseNode newNode, ModuleConfiguration mo\n \t\t\t\t\tFileUtils.closeSafely(in);\n \t\t\t\t} else if (StringHelper.containsNonWhitespace(filename)) {\n \t\t\t\t\tVFSContainer rootContainer = course.getCourseFolderContainer();\n-\t\t\t\t\tVFSLeaf singleFile = (VFSLeaf) rootContainer.resolve(\"/\" + filename);\n+\t\t\t\t\tVFSLeaf singleFile = (VFSLeaf) rootContainer.resolve(filename);\n \t\t\t\t\tif(singleFile != null) {\n \t\t\t\t\t\tmoduleConfig.set(STCourseNodeEditController.CONFIG_KEY_FILE, \"/\" + filename);\n \t\t\t\t\t}\n@@ -2487,9 +2487,9 @@ public boolean isValid() {\n \t\tpublic void configure(ICourse course, CourseNode newNode, ModuleConfiguration moduleConfig) {\n \t\t\tnewNode.setDisplayOption(CourseNode.DISPLAY_OPTS_TITLE_DESCRIPTION_CONTENT);\n \t\t\tVFSContainer rootContainer = course.getCourseFolderContainer();\n-\t\t\tVFSLeaf singleFile = (VFSLeaf) rootContainer.resolve(\"/\" + filename);\n+\t\t\tVFSLeaf singleFile = (VFSLeaf) rootContainer.resolve(filename);\n \t\t\tif (singleFile == null) {\n-\t\t\t\tsingleFile = rootContainer.createChildLeaf(\"/\" + filename);\n+\t\t\t\tsingleFile = rootContainer.createChildLeaf(filename);\n \t\t\t}\n \n \t\t\tif(in != null) {",
    "function_modified_lines": {
      "added": [
        "\t\t\tVFSLeaf singleFile = (VFSLeaf)taskFolder.resolve(filename);\n",
        "\t\t\t\tsingleFile = taskFolder.createChildLeaf(filename);\n"
      ],
      "deleted": [
        "\t\t\tVFSLeaf singleFile = (VFSLeaf) taskFolder.resolve(\"/\" + filename);\n",
        "\t\t\t\tsingleFile = taskFolder.createChildLeaf(\"/\" + filename);\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "OpenOlat is a web-basedlearning management system. A path traversal vulnerability exists in OpenOlat prior to versions 15.5.12 and 16.0.5. By providing a filename that contains a relative path as a parameter in some REST methods, it is possible to create directory structures and write files anywhere on the target system. The attack could be used to write files anywhere in the web root folder or outside, depending on the configuration of the system and the properly configured permission of the application server user. The attack requires an OpenOlat user account, an enabled REST API and the rights on a business object to call the vulnerable REST calls. The problem is fixed in version 15.5.12 and 16.0.5. There is a workaround available. The vulnerability requires the REST module to be enabled. Disabling the REST module or limiting the REST module via some firewall or web-server access rules to be accessed only be trusted systems will mitigate the risk.",
    "id": 12541
  },
  {
    "cve_id": "CVE-2021-41242",
    "code_before_change": "if(in != null && StringHelper.containsNonWhitespace(filename)) {\n\t\t\t\t\tVFSContainer rootContainer = course.getCourseFolderContainer();\n\t\t\t\t\tVFSLeaf singleFile = (VFSLeaf) rootContainer.resolve(\"/\" + filename);\n\t\t\t\t\tif (singleFile == null) {\n\t\t\t\t\t\tsingleFile = rootContainer.createChildLeaf(\"/\" + filename);\n\t\t\t\t\t}\n\t\n\t\t\t\t\tmoduleConfig.set(STCourseNodeEditController.CONFIG_KEY_FILE, \"/\" + filename);\n\t\t\t\t\tOutputStream out = singleFile.getOutputStream(false);\n\t\t\t\t\tFileUtils.copy(in, out);\n\t\t\t\t\tFileUtils.closeSafely(out);\n\t\t\t\t\tFileUtils.closeSafely(in);\n\t\t\t\t} else if (StringHelper.containsNonWhitespace(filename)) {\n\t\t\t\t\tVFSContainer rootContainer = course.getCourseFolderContainer();\n\t\t\t\t\tVFSLeaf singleFile = (VFSLeaf) rootContainer.resolve(\"/\" + filename);\n\t\t\t\t\tif(singleFile != null) {\n\t\t\t\t\t\tmoduleConfig.set(STCourseNodeEditController.CONFIG_KEY_FILE, \"/\" + filename);\n\t\t\t\t\t}\n\t\t\t\t}",
    "code_after_change": "if(in != null && StringHelper.containsNonWhitespace(filename)) {\n\t\t\t\t\tVFSContainer rootContainer = course.getCourseFolderContainer();\n\t\t\t\t\tVFSLeaf singleFile = (VFSLeaf) rootContainer.resolve(filename);\n\t\t\t\t\tif (singleFile == null) {\n\t\t\t\t\t\tsingleFile = rootContainer.createChildLeaf(filename);\n\t\t\t\t\t}\n\t\n\t\t\t\t\tmoduleConfig.set(STCourseNodeEditController.CONFIG_KEY_FILE, \"/\" + filename);\n\t\t\t\t\tOutputStream out = singleFile.getOutputStream(false);\n\t\t\t\t\tFileUtils.copy(in, out);\n\t\t\t\t\tFileUtils.closeSafely(out);\n\t\t\t\t\tFileUtils.closeSafely(in);\n\t\t\t\t} else if (StringHelper.containsNonWhitespace(filename)) {\n\t\t\t\t\tVFSContainer rootContainer = course.getCourseFolderContainer();\n\t\t\t\t\tVFSLeaf singleFile = (VFSLeaf) rootContainer.resolve(filename);\n\t\t\t\t\tif(singleFile != null) {\n\t\t\t\t\t\tmoduleConfig.set(STCourseNodeEditController.CONFIG_KEY_FILE, \"/\" + filename);\n\t\t\t\t\t}\n\t\t\t\t}",
    "patch": "@@ -1365,9 +1365,9 @@ public Response attachTaskFile(@PathParam(\"courseId\") Long courseId, @PathParam(\n \t\t\tString filename = reader.getValue(\"filename\", \"task\");\n \t\t\tString taskFolderPath = TACourseNode.getTaskFolderPathRelToFolderRoot(course, parentNode.getCourseNode());\n \t\t\tVFSContainer taskFolder = VFSManager.olatRootContainer(taskFolderPath, null);\n-\t\t\tVFSLeaf singleFile = (VFSLeaf) taskFolder.resolve(\"/\" + filename);\n+\t\t\tVFSLeaf singleFile = (VFSLeaf)taskFolder.resolve(filename);\n \t\t\tif (singleFile == null) {\n-\t\t\t\tsingleFile = taskFolder.createChildLeaf(\"/\" + filename);\n+\t\t\t\tsingleFile = taskFolder.createChildLeaf(filename);\n \t\t\t}\n \t\t\tFile file = reader.getFile();\n \t\t\tif(file != null) {\n@@ -2314,9 +2314,9 @@ public void configure(ICourse course, CourseNode newNode, ModuleConfiguration mo\n \t\t\tif(STCourseNodeEditController.CONFIG_VALUE_DISPLAY_FILE.equals(moduleConfig.getStringValue(STCourseNodeEditController.CONFIG_KEY_DISPLAY_TYPE))) {\n \t\t\t\tif(in != null && StringHelper.containsNonWhitespace(filename)) {\n \t\t\t\t\tVFSContainer rootContainer = course.getCourseFolderContainer();\n-\t\t\t\t\tVFSLeaf singleFile = (VFSLeaf) rootContainer.resolve(\"/\" + filename);\n+\t\t\t\t\tVFSLeaf singleFile = (VFSLeaf) rootContainer.resolve(filename);\n \t\t\t\t\tif (singleFile == null) {\n-\t\t\t\t\t\tsingleFile = rootContainer.createChildLeaf(\"/\" + filename);\n+\t\t\t\t\t\tsingleFile = rootContainer.createChildLeaf(filename);\n \t\t\t\t\t}\n \t\n \t\t\t\t\tmoduleConfig.set(STCourseNodeEditController.CONFIG_KEY_FILE, \"/\" + filename);\n@@ -2326,7 +2326,7 @@ public void configure(ICourse course, CourseNode newNode, ModuleConfiguration mo\n \t\t\t\t\tFileUtils.closeSafely(in);\n \t\t\t\t} else if (StringHelper.containsNonWhitespace(filename)) {\n \t\t\t\t\tVFSContainer rootContainer = course.getCourseFolderContainer();\n-\t\t\t\t\tVFSLeaf singleFile = (VFSLeaf) rootContainer.resolve(\"/\" + filename);\n+\t\t\t\t\tVFSLeaf singleFile = (VFSLeaf) rootContainer.resolve(filename);\n \t\t\t\t\tif(singleFile != null) {\n \t\t\t\t\t\tmoduleConfig.set(STCourseNodeEditController.CONFIG_KEY_FILE, \"/\" + filename);\n \t\t\t\t\t}\n@@ -2487,9 +2487,9 @@ public boolean isValid() {\n \t\tpublic void configure(ICourse course, CourseNode newNode, ModuleConfiguration moduleConfig) {\n \t\t\tnewNode.setDisplayOption(CourseNode.DISPLAY_OPTS_TITLE_DESCRIPTION_CONTENT);\n \t\t\tVFSContainer rootContainer = course.getCourseFolderContainer();\n-\t\t\tVFSLeaf singleFile = (VFSLeaf) rootContainer.resolve(\"/\" + filename);\n+\t\t\tVFSLeaf singleFile = (VFSLeaf) rootContainer.resolve(filename);\n \t\t\tif (singleFile == null) {\n-\t\t\t\tsingleFile = rootContainer.createChildLeaf(\"/\" + filename);\n+\t\t\t\tsingleFile = rootContainer.createChildLeaf(filename);\n \t\t\t}\n \n \t\t\tif(in != null) {",
    "function_modified_lines": {
      "added": [
        "\t\t\t\t\tVFSLeaf singleFile = (VFSLeaf) rootContainer.resolve(filename);\n",
        "\t\t\t\t\t\tsingleFile = rootContainer.createChildLeaf(filename);\n",
        "\t\t\t\t\tVFSLeaf singleFile = (VFSLeaf) rootContainer.resolve(filename);\n"
      ],
      "deleted": [
        "\t\t\t\t\tVFSLeaf singleFile = (VFSLeaf) rootContainer.resolve(\"/\" + filename);\n",
        "\t\t\t\t\t\tsingleFile = rootContainer.createChildLeaf(\"/\" + filename);\n",
        "\t\t\t\t\tVFSLeaf singleFile = (VFSLeaf) rootContainer.resolve(\"/\" + filename);\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "OpenOlat is a web-basedlearning management system. A path traversal vulnerability exists in OpenOlat prior to versions 15.5.12 and 16.0.5. By providing a filename that contains a relative path as a parameter in some REST methods, it is possible to create directory structures and write files anywhere on the target system. The attack could be used to write files anywhere in the web root folder or outside, depending on the configuration of the system and the properly configured permission of the application server user. The attack requires an OpenOlat user account, an enabled REST API and the rights on a business object to call the vulnerable REST calls. The problem is fixed in version 15.5.12 and 16.0.5. There is a workaround available. The vulnerability requires the REST module to be enabled. Disabling the REST module or limiting the REST module via some firewall or web-server access rules to be accessed only be trusted systems will mitigate the risk.",
    "id": 12542
  },
  {
    "cve_id": "CVE-2021-41242",
    "code_before_change": "{\n\t\t\tnewNode.setDisplayOption(CourseNode.DISPLAY_OPTS_TITLE_DESCRIPTION_CONTENT);\n\t\t\tVFSContainer rootContainer = course.getCourseFolderContainer();\n\t\t\tVFSLeaf singleFile = (VFSLeaf) rootContainer.resolve(\"/\" + filename);\n\t\t\tif (singleFile == null) {\n\t\t\t\tsingleFile = rootContainer.createChildLeaf(\"/\" + filename);\n\t\t\t}\n\n\t\t\tif(in != null) {\n\t\t\t\tmoduleConfig.set(SPEditController.CONFIG_KEY_FILE, \"/\" + filename);\n\t\t\t\t\n\t\t\t\tOutputStream out = singleFile.getOutputStream(false);\n\t\t\t\tFileUtils.copy(in, out);\n\t\t\t\tFileUtils.closeSafely(out);\n\t\t\t\tFileUtils.closeSafely(in);\n\t\t\t} else {\n\t\t\t\tif(StringHelper.containsNonWhitespace(path)) {\n\t\t\t\t\tif(!path.startsWith(\"/\")) {\n\t\t\t\t\t\tpath = \"/\" + path;\n\t\t\t\t\t}\n\t\t\t\t\tif(!path.endsWith(\"/\")) {\n\t\t\t\t\t\tpath += \"/\";\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpath = \"/\";\n\t\t\t\t}\n\t\t\t\tmoduleConfig.set(SPEditController.CONFIG_KEY_FILE, path + filename);\n\t\t\t}\n\t\t\t//saved node configuration\n\t\t}",
    "code_after_change": "{\n\t\t\tnewNode.setDisplayOption(CourseNode.DISPLAY_OPTS_TITLE_DESCRIPTION_CONTENT);\n\t\t\tVFSContainer rootContainer = course.getCourseFolderContainer();\n\t\t\tVFSLeaf singleFile = (VFSLeaf) rootContainer.resolve(filename);\n\t\t\tif (singleFile == null) {\n\t\t\t\tsingleFile = rootContainer.createChildLeaf(filename);\n\t\t\t}\n\n\t\t\tif(in != null) {\n\t\t\t\tmoduleConfig.set(SPEditController.CONFIG_KEY_FILE, \"/\" + filename);\n\t\t\t\t\n\t\t\t\tOutputStream out = singleFile.getOutputStream(false);\n\t\t\t\tFileUtils.copy(in, out);\n\t\t\t\tFileUtils.closeSafely(out);\n\t\t\t\tFileUtils.closeSafely(in);\n\t\t\t} else {\n\t\t\t\tif(StringHelper.containsNonWhitespace(path)) {\n\t\t\t\t\tif(!path.startsWith(\"/\")) {\n\t\t\t\t\t\tpath = \"/\" + path;\n\t\t\t\t\t}\n\t\t\t\t\tif(!path.endsWith(\"/\")) {\n\t\t\t\t\t\tpath += \"/\";\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpath = \"/\";\n\t\t\t\t}\n\t\t\t\tmoduleConfig.set(SPEditController.CONFIG_KEY_FILE, path + filename);\n\t\t\t}\n\t\t\t//saved node configuration\n\t\t}",
    "patch": "@@ -1365,9 +1365,9 @@ public Response attachTaskFile(@PathParam(\"courseId\") Long courseId, @PathParam(\n \t\t\tString filename = reader.getValue(\"filename\", \"task\");\n \t\t\tString taskFolderPath = TACourseNode.getTaskFolderPathRelToFolderRoot(course, parentNode.getCourseNode());\n \t\t\tVFSContainer taskFolder = VFSManager.olatRootContainer(taskFolderPath, null);\n-\t\t\tVFSLeaf singleFile = (VFSLeaf) taskFolder.resolve(\"/\" + filename);\n+\t\t\tVFSLeaf singleFile = (VFSLeaf)taskFolder.resolve(filename);\n \t\t\tif (singleFile == null) {\n-\t\t\t\tsingleFile = taskFolder.createChildLeaf(\"/\" + filename);\n+\t\t\t\tsingleFile = taskFolder.createChildLeaf(filename);\n \t\t\t}\n \t\t\tFile file = reader.getFile();\n \t\t\tif(file != null) {\n@@ -2314,9 +2314,9 @@ public void configure(ICourse course, CourseNode newNode, ModuleConfiguration mo\n \t\t\tif(STCourseNodeEditController.CONFIG_VALUE_DISPLAY_FILE.equals(moduleConfig.getStringValue(STCourseNodeEditController.CONFIG_KEY_DISPLAY_TYPE))) {\n \t\t\t\tif(in != null && StringHelper.containsNonWhitespace(filename)) {\n \t\t\t\t\tVFSContainer rootContainer = course.getCourseFolderContainer();\n-\t\t\t\t\tVFSLeaf singleFile = (VFSLeaf) rootContainer.resolve(\"/\" + filename);\n+\t\t\t\t\tVFSLeaf singleFile = (VFSLeaf) rootContainer.resolve(filename);\n \t\t\t\t\tif (singleFile == null) {\n-\t\t\t\t\t\tsingleFile = rootContainer.createChildLeaf(\"/\" + filename);\n+\t\t\t\t\t\tsingleFile = rootContainer.createChildLeaf(filename);\n \t\t\t\t\t}\n \t\n \t\t\t\t\tmoduleConfig.set(STCourseNodeEditController.CONFIG_KEY_FILE, \"/\" + filename);\n@@ -2326,7 +2326,7 @@ public void configure(ICourse course, CourseNode newNode, ModuleConfiguration mo\n \t\t\t\t\tFileUtils.closeSafely(in);\n \t\t\t\t} else if (StringHelper.containsNonWhitespace(filename)) {\n \t\t\t\t\tVFSContainer rootContainer = course.getCourseFolderContainer();\n-\t\t\t\t\tVFSLeaf singleFile = (VFSLeaf) rootContainer.resolve(\"/\" + filename);\n+\t\t\t\t\tVFSLeaf singleFile = (VFSLeaf) rootContainer.resolve(filename);\n \t\t\t\t\tif(singleFile != null) {\n \t\t\t\t\t\tmoduleConfig.set(STCourseNodeEditController.CONFIG_KEY_FILE, \"/\" + filename);\n \t\t\t\t\t}\n@@ -2487,9 +2487,9 @@ public boolean isValid() {\n \t\tpublic void configure(ICourse course, CourseNode newNode, ModuleConfiguration moduleConfig) {\n \t\t\tnewNode.setDisplayOption(CourseNode.DISPLAY_OPTS_TITLE_DESCRIPTION_CONTENT);\n \t\t\tVFSContainer rootContainer = course.getCourseFolderContainer();\n-\t\t\tVFSLeaf singleFile = (VFSLeaf) rootContainer.resolve(\"/\" + filename);\n+\t\t\tVFSLeaf singleFile = (VFSLeaf) rootContainer.resolve(filename);\n \t\t\tif (singleFile == null) {\n-\t\t\t\tsingleFile = rootContainer.createChildLeaf(\"/\" + filename);\n+\t\t\t\tsingleFile = rootContainer.createChildLeaf(filename);\n \t\t\t}\n \n \t\t\tif(in != null) {",
    "function_modified_lines": {
      "added": [
        "\t\t\tVFSLeaf singleFile = (VFSLeaf) rootContainer.resolve(filename);\n",
        "\t\t\t\tsingleFile = rootContainer.createChildLeaf(filename);\n"
      ],
      "deleted": [
        "\t\t\tVFSLeaf singleFile = (VFSLeaf) rootContainer.resolve(\"/\" + filename);\n",
        "\t\t\t\tsingleFile = rootContainer.createChildLeaf(\"/\" + filename);\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "OpenOlat is a web-basedlearning management system. A path traversal vulnerability exists in OpenOlat prior to versions 15.5.12 and 16.0.5. By providing a filename that contains a relative path as a parameter in some REST methods, it is possible to create directory structures and write files anywhere on the target system. The attack could be used to write files anywhere in the web root folder or outside, depending on the configuration of the system and the properly configured permission of the application server user. The attack requires an OpenOlat user account, an enabled REST API and the rights on a business object to call the vulnerable REST calls. The problem is fixed in version 15.5.12 and 16.0.5. There is a workaround available. The vulnerability requires the REST module to be enabled. Disabling the REST module or limiting the REST module via some firewall or web-server access rules to be accessed only be trusted systems will mitigate the risk.",
    "id": 12543
  },
  {
    "cve_id": "CVE-2022-1721",
    "code_before_change": "{\n        // GAE can't serve dot prefixed folders\n        String uri = request.getRequestURI().replace(\"/.\", \"/\");\n\n        if (uri.toLowerCase().contains(\".json\"))\n        {\n        \tresponse.setContentType(\"application/json\");\n        }\n\n        // Serve whatever was requested from .well-known\n        try (InputStream in = getServletContext().getResourceAsStream(uri))\n        {\n            if (in == null)\n            {\n            \tresponse.sendError(404);\n                return;\n            }\n            \n            byte[] buffer = new byte[8192];\n            int count;\n\n            while ((count = in.read(buffer)) > 0)\n            {\n            \tresponse.getOutputStream().write(buffer, 0, count);\n            }\n            \n            response.getOutputStream().flush();\n            response.getOutputStream().close();\n        }\n    }",
    "code_after_change": "{\n        // GAE can't serve dot prefixed folders\n        String uri = request.getRequestURI().replace(\"/.\", \"/\");\n        \n        // Currently, there is only one file that this servlet serves. This is only\n        // needed if you want OneDrive integration. \n        if (uri != null && uri.equals(\"/well-known/microsoft-identity-association.json\"))\n        {\n            if (uri.toLowerCase().contains(\".json\"))\n            {\n                response.setContentType(\"application/json\");\n            }\n\n            // Serve whatever was requested from .well-known\n            try (InputStream in = getServletContext().getResourceAsStream(uri))\n            {\n                if (in == null)\n                {\n                    response.sendError(404);\n                    return;\n                }\n                \n                byte[] buffer = new byte[8192];\n                int count;\n\n                while ((count = in.read(buffer)) > 0)\n                {\n                    response.getOutputStream().write(buffer, 0, count);\n                }\n                \n                response.getOutputStream().flush();\n                response.getOutputStream().close();\n            }\n        }\n        else\n        {\n            response.sendError(404);\n            return;\n        }\n    }",
    "patch": "@@ -14,7 +14,7 @@\n import javax.servlet.http.HttpServletResponse;\n \n /**\n- * Servlet to fake a .well-known directory\n+ * Servlet to fake a .well-known directory, GAE does not directly support . prefixed directories\n  */\n @SuppressWarnings(\"serial\")\n public class WellKnownServlet extends HttpServlet\n@@ -38,31 +38,41 @@ protected void doGet(HttpServletRequest request,\n \t{\n         // GAE can't serve dot prefixed folders\n         String uri = request.getRequestURI().replace(\"/.\", \"/\");\n-\n-        if (uri.toLowerCase().contains(\".json\"))\n-        {\n-        \tresponse.setContentType(\"application/json\");\n-        }\n-\n-        // Serve whatever was requested from .well-known\n-        try (InputStream in = getServletContext().getResourceAsStream(uri))\n+        \n+        // Currently, there is only one file that this servlet serves. This is only\n+        // needed if you want OneDrive integration. \n+        if (uri != null && uri.equals(\"/well-known/microsoft-identity-association.json\"))\n         {\n-            if (in == null)\n+            if (uri.toLowerCase().contains(\".json\"))\n             {\n-            \tresponse.sendError(404);\n-                return;\n+                response.setContentType(\"application/json\");\n             }\n-            \n-            byte[] buffer = new byte[8192];\n-            int count;\n \n-            while ((count = in.read(buffer)) > 0)\n+            // Serve whatever was requested from .well-known\n+            try (InputStream in = getServletContext().getResourceAsStream(uri))\n             {\n-            \tresponse.getOutputStream().write(buffer, 0, count);\n+                if (in == null)\n+                {\n+                    response.sendError(404);\n+                    return;\n+                }\n+                \n+                byte[] buffer = new byte[8192];\n+                int count;\n+\n+                while ((count = in.read(buffer)) > 0)\n+                {\n+                    response.getOutputStream().write(buffer, 0, count);\n+                }\n+                \n+                response.getOutputStream().flush();\n+                response.getOutputStream().close();\n             }\n-            \n-            response.getOutputStream().flush();\n-            response.getOutputStream().close();\n+        }\n+        else\n+        {\n+            response.sendError(404);\n+            return;\n         }\n     }\n }",
    "function_modified_lines": {
      "added": [
        "        \n",
        "        // Currently, there is only one file that this servlet serves. This is only\n",
        "        // needed if you want OneDrive integration. \n",
        "        if (uri != null && uri.equals(\"/well-known/microsoft-identity-association.json\"))\n",
        "            if (uri.toLowerCase().contains(\".json\"))\n",
        "                response.setContentType(\"application/json\");\n",
        "            // Serve whatever was requested from .well-known\n",
        "            try (InputStream in = getServletContext().getResourceAsStream(uri))\n",
        "                if (in == null)\n",
        "                {\n",
        "                    response.sendError(404);\n",
        "                    return;\n",
        "                }\n",
        "                \n",
        "                byte[] buffer = new byte[8192];\n",
        "                int count;\n",
        "\n",
        "                while ((count = in.read(buffer)) > 0)\n",
        "                {\n",
        "                    response.getOutputStream().write(buffer, 0, count);\n",
        "                }\n",
        "                \n",
        "                response.getOutputStream().flush();\n",
        "                response.getOutputStream().close();\n",
        "        }\n",
        "        else\n",
        "        {\n",
        "            response.sendError(404);\n",
        "            return;\n"
      ],
      "deleted": [
        "\n",
        "        if (uri.toLowerCase().contains(\".json\"))\n",
        "        {\n",
        "        \tresponse.setContentType(\"application/json\");\n",
        "        }\n",
        "\n",
        "        // Serve whatever was requested from .well-known\n",
        "        try (InputStream in = getServletContext().getResourceAsStream(uri))\n",
        "            if (in == null)\n",
        "            \tresponse.sendError(404);\n",
        "                return;\n",
        "            \n",
        "            byte[] buffer = new byte[8192];\n",
        "            int count;\n",
        "            while ((count = in.read(buffer)) > 0)\n",
        "            \tresponse.getOutputStream().write(buffer, 0, count);\n",
        "            \n",
        "            response.getOutputStream().flush();\n",
        "            response.getOutputStream().close();\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "Path Traversal in WellKnownServlet in GitHub repository jgraph/drawio prior to 18.0.5. Read local files of the web application.",
    "id": 12559
  },
  {
    "cve_id": "CVE-2022-23082",
    "code_before_change": "{\n\n  @Test\n  void isFileInDir_outside_successfullyWithResult() throws IOException {\n    Path sourcePath = Paths.get(\"src\").toAbsolutePath();\n    Path cwd = Paths.get(\"\").toAbsolutePath();\n\n    boolean isOutside = FileSecurityUtils.isFileOutsideDir(cwd.toString(), sourcePath.toString());\n    Assertions.assertTrue(isOutside);\n  }\n\n  @Test\n  void isFileInDir_inside_successfullyWithResult() throws IOException {\n    Path sourcePath = Paths.get(\"src\").toAbsolutePath();\n    Path cwd = Paths.get(\"\").toAbsolutePath();\n\n    boolean isOutside = FileSecurityUtils.isFileOutsideDir(sourcePath.toString(), cwd.toString());\n    Assertions.assertFalse(isOutside);\n  }\n\n  @Test\n  void isFileInDir_null_successfully() {\n    Assertions.assertThrows(\n            NullPointerException.class, () -> FileSecurityUtils.isFileOutsideDir(null, null));\n\n    Assertions.assertThrows(\n            NullPointerException.class,\n            () -> FileSecurityUtils.isFileOutsideDir(\"file-path-place-holder\", null));\n\n    Assertions.assertThrows(\n            NullPointerException.class,\n            () -> FileSecurityUtils.isFileOutsideDir(null, \"base-dir-place-holder\"));\n  }\n\n  @Test\n  void normalize_validInput_successfullyWithResult() {\n    String validInput = \"./In/../Valid/Un/../Normalized/./Path\";\n    String expectedResult = \"Valid\" + File.separator + \"Normalized\" + File.separator + \"Path\";\n\n    String actualResult = FileSecurityUtils.normalize(validInput);\n    Assertions.assertEquals(expectedResult, actualResult);\n  }\n\n  @Test\n  void normalize_null_successfully() {\n    Assertions.assertNull(FileSecurityUtils.normalize(null));\n  }\n}",
    "code_after_change": "{\n\n  @Test\n  void isFileInDir_outside_successfullyWithResult() throws IOException {\n    Path sourcePath = Paths.get(\"src\").toAbsolutePath();\n    Path cwd = Paths.get(\"\").toAbsolutePath();\n\n    boolean isOutside = FileSecurityUtils.isFileOutsideDir(cwd.toString(), sourcePath.toString());\n    Assertions.assertTrue(isOutside);\n  }\n\n  @Test\n  void isFileInDir_inside_successfullyWithResult() throws IOException {\n    Path sourcePath = Paths.get(\"src\").toAbsolutePath();\n    Path cwd = Paths.get(\"\").toAbsolutePath();\n\n    boolean isOutside = FileSecurityUtils.isFileOutsideDir(sourcePath.toString(), cwd.toString());\n    Assertions.assertFalse(isOutside);\n  }\n\n  @Test\n  void isFileInDir_null_successfully() {\n    Assertions.assertThrows(\n            NullPointerException.class, () -> FileSecurityUtils.isFileOutsideDir(null, null));\n\n    Assertions.assertThrows(\n            NullPointerException.class,\n            () -> FileSecurityUtils.isFileOutsideDir(\"file-path-place-holder\", null));\n\n    Assertions.assertThrows(\n            NullPointerException.class,\n            () -> FileSecurityUtils.isFileOutsideDir(null, \"base-dir-place-holder\"));\n  }\n\n  @Test\n  void normalize_validInput_successfullyWithResult() {\n    String validInput = \"./In/../Valid/Un/../Normalized/./Path\";\n    String expectedResult = \"Valid\" + File.separator + \"Normalized\" + File.separator + \"Path\";\n\n    String actualResult = FileSecurityUtils.normalize(validInput);\n    Assertions.assertEquals(expectedResult, actualResult);\n  }\n\n  @Test\n  void isFileOutsideDirStartsWithTest() throws IOException {\n    String taintedInput = \"/usr/foo/../foo-bar/bar\";\n    String baseDir = \"/usr/foo\";\n    Assertions.assertTrue(FileSecurityUtils.isFileOutsideDir(taintedInput, baseDir));\n  }\n\n  @Test\n  void normalize_null_successfully() {\n    Assertions.assertNull(FileSecurityUtils.normalize(null));\n  }\n}",
    "patch": "@@ -50,6 +50,13 @@ void normalize_validInput_successfullyWithResult() {\n     Assertions.assertEquals(expectedResult, actualResult);\n   }\n \n+  @Test\n+  void isFileOutsideDirStartsWithTest() throws IOException {\n+    String taintedInput = \"/usr/foo/../foo-bar/bar\";\n+    String baseDir = \"/usr/foo\";\n+    Assertions.assertTrue(FileSecurityUtils.isFileOutsideDir(taintedInput, baseDir));\n+  }\n+\n   @Test\n   void normalize_null_successfully() {\n     Assertions.assertNull(FileSecurityUtils.normalize(null));",
    "function_modified_lines": {
      "added": [
        "  @Test\n",
        "  void isFileOutsideDirStartsWithTest() throws IOException {\n",
        "    String taintedInput = \"/usr/foo/../foo-bar/bar\";\n",
        "    String baseDir = \"/usr/foo\";\n",
        "    Assertions.assertTrue(FileSecurityUtils.isFileOutsideDir(taintedInput, baseDir));\n",
        "  }\n",
        "\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "In CureKit versions v1.0.1 through v1.1.3 are vulnerable to path traversal as the function isFileOutsideDir fails to sanitize the user input which may lead to path traversal.",
    "id": 12577
  },
  {
    "cve_id": "CVE-2022-24830",
    "code_before_change": "{\n        \t// fix path traversal issue\n            excelFile = new File(dir,excelFileName);\n            // backwards compat\n            File oldExcelFile = new File(dir, oldExcelFileName);            \n       \n        \tif (oldExcelFile.exists() && oldExcelFile.length() > 0) {\n                 if (!excelFile.exists() || excelFile.length() <= 0) {\n                     // if the old name exists and the new name does not...\n                     excelFile = oldExcelFile;\n                     excelFileName = oldExcelFileName;\n                 }\n             }                  \n\n        }",
    "code_after_change": "{\n        \t// fix path traversal issue\n            excelFile = new File(dir,excelFileName);\n            // backwards compat\n            File oldExcelFile = new File(dir, oldExcelFileName);            \n            \n            String canonicalPath1= excelFile.getCanonicalPath();\n            String canonicalPath2= oldExcelFile.getCanonicalPath();\n            if (canonicalPath1.startsWith(dir) && canonicalPath2.startsWith(dir)) {\n            \tif (oldExcelFile.exists() && oldExcelFile.length() > 0) {\n                    if (!excelFile.exists() || excelFile.length() <= 0) {\n                        // if the old name exists and the new name does not...\n                        excelFile = oldExcelFile;\n                        excelFileName = oldExcelFileName;\n                    }\n                }     \n            }else {\n            \t addPageMessage(respage.getString(\"the_excel_is_not_available_on_server_contact\"));\n                 forwardPage(Page.CRF_LIST_SERVLET);\n            }\n        \t             \n\n        }",
    "patch": "@@ -95,14 +95,22 @@ public void processRequest() throws Exception {\n             excelFile = new File(dir,excelFileName);\n             // backwards compat\n             File oldExcelFile = new File(dir, oldExcelFileName);            \n-       \n-        \tif (oldExcelFile.exists() && oldExcelFile.length() > 0) {\n-                 if (!excelFile.exists() || excelFile.length() <= 0) {\n-                     // if the old name exists and the new name does not...\n-                     excelFile = oldExcelFile;\n-                     excelFileName = oldExcelFileName;\n-                 }\n-             }                  \n+            \n+            String canonicalPath1= excelFile.getCanonicalPath();\n+            String canonicalPath2= oldExcelFile.getCanonicalPath();\n+            if (canonicalPath1.startsWith(dir) && canonicalPath2.startsWith(dir)) {\n+            \tif (oldExcelFile.exists() && oldExcelFile.length() > 0) {\n+                    if (!excelFile.exists() || excelFile.length() <= 0) {\n+                        // if the old name exists and the new name does not...\n+                        excelFile = oldExcelFile;\n+                        excelFileName = oldExcelFileName;\n+                    }\n+                }     \n+            }else {\n+            \t addPageMessage(respage.getString(\"the_excel_is_not_available_on_server_contact\"));\n+                 forwardPage(Page.CRF_LIST_SERVLET);\n+            }\n+        \t             \n \n         }\n         logger.info(\"looking for : \" + excelFile.getName());",
    "function_modified_lines": {
      "added": [
        "            \n",
        "            String canonicalPath1= excelFile.getCanonicalPath();\n",
        "            String canonicalPath2= oldExcelFile.getCanonicalPath();\n",
        "            if (canonicalPath1.startsWith(dir) && canonicalPath2.startsWith(dir)) {\n",
        "            \tif (oldExcelFile.exists() && oldExcelFile.length() > 0) {\n",
        "                    if (!excelFile.exists() || excelFile.length() <= 0) {\n",
        "                        // if the old name exists and the new name does not...\n",
        "                        excelFile = oldExcelFile;\n",
        "                        excelFileName = oldExcelFileName;\n",
        "                    }\n",
        "                }     \n",
        "            }else {\n",
        "            \t addPageMessage(respage.getString(\"the_excel_is_not_available_on_server_contact\"));\n",
        "                 forwardPage(Page.CRF_LIST_SERVLET);\n",
        "            }\n",
        "        \t             \n"
      ],
      "deleted": [
        "       \n",
        "        \tif (oldExcelFile.exists() && oldExcelFile.length() > 0) {\n",
        "                 if (!excelFile.exists() || excelFile.length() <= 0) {\n",
        "                     // if the old name exists and the new name does not...\n",
        "                     excelFile = oldExcelFile;\n",
        "                     excelFileName = oldExcelFileName;\n",
        "                 }\n",
        "             }                  \n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "OpenClinica is an open source software for Electronic Data Capture (EDC) and Clinical Data Management (CDM). OpenClinica prior to version 3.16 is vulnerable to path traversal in multiple endpoints, leading to arbitrary file read/write, and potential remote code execution. There are no known workarounds. This issue has been patched and users are recommended to upgrade.",
    "id": 12593
  },
  {
    "cve_id": "CVE-2022-24830",
    "code_before_change": "{\r\n        FormProcessor fp = new FormProcessor(request);\r\n        String filePathName = \"\";\r\n        String fileName = fp.getString(\"fileName\");\r\n        File f = new File(fileName);\r\n        \r\n        if(fileName != null && fileName.indexOf(\"..\") > -1) {\r\n        \tthrow new RuntimeException(\"Traversal attempt - absolute path not allowed \" + fileName);\r\n        }\r\n        \r\n        if (fileName != null && fileName.length() > 0) {\r\n            int parentStudyId = currentStudy.getParentStudyId();\r\n            String testPath = Utils.getAttachedFileRootPath();\r\n            String tail = File.separator + f.getName();\r\n            String testName = testPath + currentStudy.getOid() + tail;\r\n            File temp = new File(testName);\r\n            if (temp.exists()) {\r\n                filePathName = testName;\r\n                logger.info(currentStudy.getName() + \" existing filePathName=\" + filePathName);\r\n            } else {\r\n                if (currentStudy.isSite(parentStudyId)) {\r\n                    testName = testPath + ((StudyBean) new StudyDAO(sm.getDataSource()).findByPK(parentStudyId)).getOid() + tail;\r\n                    temp = new File(testName);\r\n                    if (temp.exists()) {\r\n                        filePathName = testName;\r\n                        logger.info(\"parent existing filePathName=\" + filePathName);\r\n                    }\r\n                } else {\r\n                    ArrayList<StudyBean> sites = (ArrayList<StudyBean>) new StudyDAO(sm.getDataSource()).findAllByParent(currentStudy.getId());\r\n                    for (StudyBean s : sites) {\r\n                        testPath = Utils.getAttachedFilePath(s);\r\n                        testName = testPath + tail;//+ s.getIdentifier() + tail;\r\n                        File test = new File(testName);\r\n                        if (test.exists()) {\r\n                            filePathName = testName;\r\n                            logger.info(\"site of currentStudy existing filePathName=\" + filePathName);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        logger.info(\"filePathName=\" + filePathName + \" fileName=\" + fileName);\r\n        File file = new File(filePathName);\r\n        if (!file.exists() || file.length() <= 0) {\r\n            addPageMessage(\"File \" + filePathName + \" \" + respage.getString(\"not_exist\"));\r\n            \r\n            // try to use the passed in the existing file\r\n        \tfile = new File(fileName);\r\n        }\r\n        \r\n        if (!file.exists() || file.length() <= 0) {\r\n            addPageMessage(\"File \" + filePathName + \" \" + respage.getString(\"not_exist\"));\r\n        } else {\r\n//            response.setContentType(\"application/octet-stream\");\r\n            response.setHeader(\"Content-disposition\", \"attachment; filename=\\\"\" + fileName + \"\\\";\");\r\n            response.setHeader(\"Pragma\", \"public\");\r\n\r\n            ServletOutputStream outStream = response.getOutputStream();\r\n            DataInputStream inStream = null;\r\n            try {\r\n                response.setContentType(\"application/download\");\r\n                response.setHeader(\"Cache-Control\", \"max-age=0\");\r\n                response.setContentLength((int) file.length());\r\n\r\n                byte[] bbuf = new byte[(int) file.length()];\r\n                inStream = new DataInputStream(new FileInputStream(file));\r\n                int length;\r\n                while (inStream != null && (length = inStream.read(bbuf)) != -1) {\r\n                    outStream.write(bbuf, 0, length);\r\n                }\r\n\r\n                inStream.close();\r\n                outStream.flush();\r\n                outStream.close();\r\n            } catch (Exception ee) {\r\n                ee.printStackTrace();\r\n            } finally {\r\n                if (inStream != null) {\r\n                    inStream.close();\r\n                }\r\n                if (outStream != null) {\r\n                    outStream.close();\r\n                }\r\n            }\r\n        }\r\n    }",
    "code_after_change": "{\r\n        FormProcessor fp = new FormProcessor(request);\r\n        String filePathName = \"\";\r\n        String fileName = fp.getString(\"fileName\");\r\n        File f = new File(fileName);\r\n              \r\n        if (fileName != null && fileName.length() > 0) {\r\n            int parentStudyId = currentStudy.getParentStudyId();           \r\n            String testPath = Utils.getAttachedFileRootPath();\r\n            String tail = File.separator + f.getName();\r\n            String testName = testPath + currentStudy.getOid() + tail;\r\n            \r\n            String filePath = testPath + currentStudy.getOid() +File.separator;            \r\n            File temp = new File(filePath,f.getName());            \r\n            String canonicalPath= temp.getCanonicalPath();\r\n            \r\n            if (canonicalPath.startsWith(filePath)) {\r\n            \t;\r\n            }else {\r\n            \tthrow new RuntimeException(\"Traversal attempt - file path not allowed \" + fileName);\r\n            }\r\n            \r\n            if (temp.exists()) {\r\n                filePathName = testName;\r\n                logger.info(currentStudy.getName() + \" existing filePathName=\" + filePathName);\r\n            } else {\r\n                if (currentStudy.isSite(parentStudyId)) {\r\n                    testName = testPath + ((StudyBean) new StudyDAO(sm.getDataSource()).findByPK(parentStudyId)).getOid() + tail;\r\n                    temp = new File(testName);\r\n                    if (temp.exists()) {\r\n                        filePathName = testName;\r\n                        logger.info(\"parent existing filePathName=\" + filePathName);\r\n                    }\r\n                } else {\r\n                    ArrayList<StudyBean> sites = (ArrayList<StudyBean>) new StudyDAO(sm.getDataSource()).findAllByParent(currentStudy.getId());\r\n                    for (StudyBean s : sites) {\r\n                        testPath = Utils.getAttachedFilePath(s);\r\n                        testName = testPath + tail;//+ s.getIdentifier() + tail;\r\n                        File test = new File(testName);\r\n                        if (test.exists()) {\r\n                            filePathName = testName;\r\n                            logger.info(\"site of currentStudy existing filePathName=\" + filePathName);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        logger.info(\"filePathName=\" + filePathName + \" fileName=\" + fileName);\r\n        File file = new File(filePathName);\r\n        if (!file.exists() || file.length() <= 0) {\r\n            addPageMessage(\"File \" + filePathName + \" \" + respage.getString(\"not_exist\"));\r\n            \r\n            // try to use the passed in the existing file\r\n        \tfile = new File(fileName);\r\n        }\r\n        \r\n        if (!file.exists() || file.length() <= 0) {\r\n            addPageMessage(\"File \" + filePathName + \" \" + respage.getString(\"not_exist\"));\r\n        } else {\r\n//            response.setContentType(\"application/octet-stream\");\r\n            response.setHeader(\"Content-disposition\", \"attachment; filename=\\\"\" + fileName + \"\\\";\");\r\n            response.setHeader(\"Pragma\", \"public\");\r\n\r\n            ServletOutputStream outStream = response.getOutputStream();\r\n            DataInputStream inStream = null;\r\n            try {\r\n                response.setContentType(\"application/download\");\r\n                response.setHeader(\"Cache-Control\", \"max-age=0\");\r\n                response.setContentLength((int) file.length());\r\n\r\n                byte[] bbuf = new byte[(int) file.length()];\r\n                inStream = new DataInputStream(new FileInputStream(file));\r\n                int length;\r\n                while (inStream != null && (length = inStream.read(bbuf)) != -1) {\r\n                    outStream.write(bbuf, 0, length);\r\n                }\r\n\r\n                inStream.close();\r\n                outStream.flush();\r\n                outStream.close();\r\n            } catch (Exception ee) {\r\n                ee.printStackTrace();\r\n            } finally {\r\n                if (inStream != null) {\r\n                    inStream.close();\r\n                }\r\n                if (outStream != null) {\r\n                    outStream.close();\r\n                }\r\n            }\r\n        }\r\n    }",
    "patch": "@@ -70,17 +70,23 @@ public void processRequest() throws Exception {\n         String filePathName = \"\";\r\n         String fileName = fp.getString(\"fileName\");\r\n         File f = new File(fileName);\r\n-        \r\n-        if(fileName != null && fileName.indexOf(\"..\") > -1) {\r\n-        \tthrow new RuntimeException(\"Traversal attempt - absolute path not allowed \" + fileName);\r\n-        }\r\n-        \r\n+              \r\n         if (fileName != null && fileName.length() > 0) {\r\n-            int parentStudyId = currentStudy.getParentStudyId();\r\n+            int parentStudyId = currentStudy.getParentStudyId();           \r\n             String testPath = Utils.getAttachedFileRootPath();\r\n             String tail = File.separator + f.getName();\r\n             String testName = testPath + currentStudy.getOid() + tail;\r\n-            File temp = new File(testName);\r\n+            \r\n+            String filePath = testPath + currentStudy.getOid() +File.separator;            \r\n+            File temp = new File(filePath,f.getName());            \r\n+            String canonicalPath= temp.getCanonicalPath();\r\n+            \r\n+            if (canonicalPath.startsWith(filePath)) {\r\n+            \t;\r\n+            }else {\r\n+            \tthrow new RuntimeException(\"Traversal attempt - file path not allowed \" + fileName);\r\n+            }\r\n+            \r\n             if (temp.exists()) {\r\n                 filePathName = testName;\r\n                 logger.info(currentStudy.getName() + \" existing filePathName=\" + filePathName);\r",
    "function_modified_lines": {
      "added": [
        "              \r\n",
        "            int parentStudyId = currentStudy.getParentStudyId();           \r\n",
        "            \r\n",
        "            String filePath = testPath + currentStudy.getOid() +File.separator;            \r\n",
        "            File temp = new File(filePath,f.getName());            \r\n",
        "            String canonicalPath= temp.getCanonicalPath();\r\n",
        "            \r\n",
        "            if (canonicalPath.startsWith(filePath)) {\r\n",
        "            \t;\r\n",
        "            }else {\r\n",
        "            \tthrow new RuntimeException(\"Traversal attempt - file path not allowed \" + fileName);\r\n",
        "            }\r\n",
        "            \r\n"
      ],
      "deleted": [
        "        \r\n",
        "        if(fileName != null && fileName.indexOf(\"..\") > -1) {\r\n",
        "        \tthrow new RuntimeException(\"Traversal attempt - absolute path not allowed \" + fileName);\r\n",
        "        }\r\n",
        "        \r\n",
        "            int parentStudyId = currentStudy.getParentStudyId();\r\n",
        "            File temp = new File(testName);\r\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "OpenClinica is an open source software for Electronic Data Capture (EDC) and Clinical Data Management (CDM). OpenClinica prior to version 3.16 is vulnerable to path traversal in multiple endpoints, leading to arbitrary file read/write, and potential remote code execution. There are no known workarounds. This issue has been patched and users are recommended to upgrade.",
    "id": 12594
  },
  {
    "cve_id": "CVE-2022-24830",
    "code_before_change": "{\n        \t//Validate/Sanitize user input filename using a standard library, prevent from path traversal \n            String logFileName = getFilePath() + File.separator + FilenameUtils.getName(fileName);\n            File fileToDownload = new File(logFileName);\n            inputStream = new FileInputStream(fileToDownload);\n            response.setContentType(\"application/force-download\");\n            response.setHeader(\"Content-Disposition\", \"attachment; filename=\" + fileName);\n            IOUtils.copy(inputStream, response.getOutputStream());\n            response.flushBuffer();\n        }",
    "code_after_change": "{\n        \t//Validate/Sanitize user input filename using a standard library, prevent from path traversal \n            String logFilePath = getFilePath() + File.separator;\n            File fileToDownload = new File(logFilePath, fileName);                    \n            String canonicalPath= fileToDownload.getCanonicalPath();\n            \n            if (canonicalPath.startsWith(logFilePath)) {\n            \tinputStream = new FileInputStream(fileToDownload);\n                response.setContentType(\"application/force-download\");\n                response.setHeader(\"Content-Disposition\", \"attachment; filename=\" + fileName);\n                IOUtils.copy(inputStream, response.getOutputStream());\n                response.flushBuffer();\n            }else {\n            \tthrow new RuntimeException(\"Traversal attempt - file path not allowed \" + fileName);\n            }\n            \n        }",
    "patch": "@@ -127,13 +127,20 @@ public void getLogFile(@PathVariable(\"filename\") String fileName, HttpServletRes\n         InputStream inputStream = null;\n         try {\n         \t//Validate/Sanitize user input filename using a standard library, prevent from path traversal \n-            String logFileName = getFilePath() + File.separator + FilenameUtils.getName(fileName);\n-            File fileToDownload = new File(logFileName);\n-            inputStream = new FileInputStream(fileToDownload);\n-            response.setContentType(\"application/force-download\");\n-            response.setHeader(\"Content-Disposition\", \"attachment; filename=\" + fileName);\n-            IOUtils.copy(inputStream, response.getOutputStream());\n-            response.flushBuffer();\n+            String logFilePath = getFilePath() + File.separator;\n+            File fileToDownload = new File(logFilePath, fileName);                    \n+            String canonicalPath= fileToDownload.getCanonicalPath();\n+            \n+            if (canonicalPath.startsWith(logFilePath)) {\n+            \tinputStream = new FileInputStream(fileToDownload);\n+                response.setContentType(\"application/force-download\");\n+                response.setHeader(\"Content-Disposition\", \"attachment; filename=\" + fileName);\n+                IOUtils.copy(inputStream, response.getOutputStream());\n+                response.flushBuffer();\n+            }else {\n+            \tthrow new RuntimeException(\"Traversal attempt - file path not allowed \" + fileName);\n+            }\n+            \n         } catch (Exception e) {\n             logger.debug(\"Request could not be completed at this moment. Please try again.\");\n             logger.debug(e.getStackTrace().toString());",
    "function_modified_lines": {
      "added": [
        "            String logFilePath = getFilePath() + File.separator;\n",
        "            File fileToDownload = new File(logFilePath, fileName);                    \n",
        "            String canonicalPath= fileToDownload.getCanonicalPath();\n",
        "            \n",
        "            if (canonicalPath.startsWith(logFilePath)) {\n",
        "            \tinputStream = new FileInputStream(fileToDownload);\n",
        "                response.setContentType(\"application/force-download\");\n",
        "                response.setHeader(\"Content-Disposition\", \"attachment; filename=\" + fileName);\n",
        "                IOUtils.copy(inputStream, response.getOutputStream());\n",
        "                response.flushBuffer();\n",
        "            }else {\n",
        "            \tthrow new RuntimeException(\"Traversal attempt - file path not allowed \" + fileName);\n",
        "            }\n",
        "            \n"
      ],
      "deleted": [
        "            String logFileName = getFilePath() + File.separator + FilenameUtils.getName(fileName);\n",
        "            File fileToDownload = new File(logFileName);\n",
        "            inputStream = new FileInputStream(fileToDownload);\n",
        "            response.setContentType(\"application/force-download\");\n",
        "            response.setHeader(\"Content-Disposition\", \"attachment; filename=\" + fileName);\n",
        "            IOUtils.copy(inputStream, response.getOutputStream());\n",
        "            response.flushBuffer();\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "OpenClinica is an open source software for Electronic Data Capture (EDC) and Clinical Data Management (CDM). OpenClinica prior to version 3.16 is vulnerable to path traversal in multiple endpoints, leading to arbitrary file read/write, and potential remote code execution. There are no known workarounds. This issue has been patched and users are recommended to upgrade.",
    "id": 12595
  },
  {
    "cve_id": "CVE-2022-26049",
    "code_before_change": "{\n\t\t\tZipEntry entry;\n\t\t\twhile ((entry = zipInput.getNextEntry()) != null) {\n\t\t\t\tFile dest = new File(destinationDir, entry.getName());\n\t\t\t\tif (entry.isDirectory()) {\n\t\t\t\t\tFileMisc.mkdirs(dest);\n\t\t\t\t} else {\n\t\t\t\t\tFileMisc.mkdirs(dest.getParentFile());\n\t\t\t\t\ttry (OutputStream output = new BufferedOutputStream(new FileOutputStream(dest))) {\n\t\t\t\t\t\tcopy(zipInput, output);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}",
    "code_after_change": "{\n\t\t\t\tFile dest = new File(destinationDir, entry.getName());\n\t\t\t\tif (!dest.toPath().normalize().startsWith(destinationDir.toPath().normalize())) {\n\t\t\t\t\tthrow new RuntimeException(\"Bad zip entry\");\n\t\t\t\t}\n\t\t\t\tif (entry.isDirectory()) {\n\t\t\t\t\tFileMisc.mkdirs(dest);\n\t\t\t\t} else {\n\t\t\t\t\tFileMisc.mkdirs(dest.getParentFile());\n\t\t\t\t\ttry (OutputStream output = new BufferedOutputStream(new FileOutputStream(dest))) {\n\t\t\t\t\t\tcopy(zipInput, output);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}",
    "patch": "@@ -178,6 +178,9 @@ public static void unzip(File input, File destinationDir) throws IOException {\n \t\t\tZipEntry entry;\n \t\t\twhile ((entry = zipInput.getNextEntry()) != null) {\n \t\t\t\tFile dest = new File(destinationDir, entry.getName());\n+\t\t\t\tif (!dest.toPath().normalize().startsWith(destinationDir.toPath().normalize())) {\n+\t\t\t\t\tthrow new RuntimeException(\"Bad zip entry\");\n+\t\t\t\t}\n \t\t\t\tif (entry.isDirectory()) {\n \t\t\t\t\tFileMisc.mkdirs(dest);\n \t\t\t\t} else {",
    "function_modified_lines": {
      "added": [
        "\t\t\t\tif (!dest.toPath().normalize().startsWith(destinationDir.toPath().normalize())) {\n",
        "\t\t\t\t\tthrow new RuntimeException(\"Bad zip entry\");\n",
        "\t\t\t\t}\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "This affects the package com.diffplug.gradle:goomph before 3.37.2. It allows a malicious zip file to potentially break out of the expected destination directory, writing contents into arbitrary locations on the file system. Overwriting certain files/directories could allow an attacker to achieve remote code execution on a target system by exploiting this vulnerability. **Note:** This could have allowed a malicious zip file to extract itself into an arbitrary directory. The only file that Goomph extracts is the p2 bootstrapper and eclipse metadata files hosted at eclipse.org, which are not malicious, so the only way this vulnerability could have affected you is if you had set a custom bootstrap zip, and that zip was malicious.",
    "id": 12626
  },
  {
    "cve_id": "CVE-2022-4065",
    "code_before_change": "{\n          InputStream inputStream = jf.getInputStream(je);\n          File copyFile = new File(file, jeName);\n          copyFile.getParentFile().mkdirs();\n          Files.copy(inputStream, copyFile.toPath());\n          if (matchesXmlPathInJar(je)) {\n            suitePath = copyFile.toString();\n          }\n        }",
    "code_after_change": "{\n          InputStream inputStream = jf.getInputStream(je);\n          File copyFile = new File(file, jeName);\n          if (!copyFile.toPath().normalize().startsWith(file.toPath().normalize())) {\n            throw new IOException(\"Bad zip entry\");\n          }\n          copyFile.getParentFile().mkdirs();\n          Files.copy(inputStream, copyFile.toPath());\n          if (matchesXmlPathInJar(je)) {\n            suitePath = copyFile.toString();\n          }\n        }",
    "patch": "@@ -76,6 +76,9 @@ private boolean testngXmlExistsInJar(File jarFile, List<String> classes) throws\n         if (Parser.canParse(jeName.toLowerCase())) {\n           InputStream inputStream = jf.getInputStream(je);\n           File copyFile = new File(file, jeName);\n+          if (!copyFile.toPath().normalize().startsWith(file.toPath().normalize())) {\n+            throw new IOException(\"Bad zip entry\");\n+          }\n           copyFile.getParentFile().mkdirs();\n           Files.copy(inputStream, copyFile.toPath());\n           if (matchesXmlPathInJar(je)) {",
    "function_modified_lines": {
      "added": [
        "          if (!copyFile.toPath().normalize().startsWith(file.toPath().normalize())) {\n",
        "            throw new IOException(\"Bad zip entry\");\n",
        "          }\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "A vulnerability was found in cbeust testng 7.5.0/7.6.0/7.6.1/7.7.0. It has been declared as critical. Affected by this vulnerability is the function testngXmlExistsInJar of the file testng-core/src/main/java/org/testng/JarFileUtils.java of the component XML File Parser. The manipulation leads to path traversal. The attack can be launched remotely. Upgrading to version 7.5.1 and 7.7.1 is able to address this issue. The patch is named 9150736cd2c123a6a3b60e6193630859f9f0422b. It is recommended to upgrade the affected component. The associated identifier of this vulnerability is VDB-214027.",
    "id": 12649
  },
  {
    "cve_id": "CVE-2022-4493",
    "code_before_change": "{\n\t\t\t\tfinal ZipEntry entry = zis.getNextEntry();\n\t\t\t\tif (entry == null) break; // All done!\n\t\t\t\tfinal String name = entry.getName();\n\t\t\t\tfinal File outFile = new File(targetFolder, name);\n\t\t\t\tif (entry.isDirectory()) {\n\t\t\t\t\toutFile.mkdirs();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfinal int size = (int) entry.getSize();\n\t\t\t\t\tint len = 0;\n\t\t\t\t\ttry (final FileOutputStream out = new FileOutputStream(outFile)) {\n\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\tlog.debug(\"Unpacking \" + name + \"; completion\" + (double) len /\n\t\t\t\t\t\t\t\tsize * 100 + \"%\");\n\t\t\t\t\t\t\tfinal int r = zis.read(buf);\n\t\t\t\t\t\t\tif (r < 0) break; // end of entry\n\t\t\t\t\t\t\tlen += r;\n\t\t\t\t\t\t\tout.write(buf, 0, r);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}",
    "code_after_change": "{\n\t\t\t\tfinal ZipEntry entry = zis.getNextEntry();\n\t\t\t\tif (entry == null) break; // All done!\n\t\t\t\tfinal String name = entry.getName();\n\t\t\t\tfinal File outFile = new File(targetFolder, name);\n\t\t\t\tif (!outFile.toPath().normalize().startsWith(targetFolder.toPath().normalize())) {\n\t\t\t\t\tthrow new RuntimeException(\"Bad zip entry\");\n\t\t\t\t}\n\t\t\t\tif (entry.isDirectory()) {\n\t\t\t\t\toutFile.mkdirs();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfinal int size = (int) entry.getSize();\n\t\t\t\t\tint len = 0;\n\t\t\t\t\ttry (final FileOutputStream out = new FileOutputStream(outFile)) {\n\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\tlog.debug(\"Unpacking \" + name + \"; completion\" + (double) len /\n\t\t\t\t\t\t\t\tsize * 100 + \"%\");\n\t\t\t\t\t\t\tfinal int r = zis.read(buf);\n\t\t\t\t\t\t\tif (r < 0) break; // end of entry\n\t\t\t\t\t\t\tlen += r;\n\t\t\t\t\t\t\tout.write(buf, 0, r);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}",
    "patch": "@@ -159,6 +159,9 @@ private void downloadAndUnpackResource(final Location source,\n \t\t\t\tif (entry == null) break; // All done!\n \t\t\t\tfinal String name = entry.getName();\n \t\t\t\tfinal File outFile = new File(targetFolder, name);\n+\t\t\t\tif (!outFile.toPath().normalize().startsWith(targetFolder.toPath().normalize())) {\n+\t\t\t\t\tthrow new RuntimeException(\"Bad zip entry\");\n+\t\t\t\t}\n \t\t\t\tif (entry.isDirectory()) {\n \t\t\t\t\toutFile.mkdirs();\n \t\t\t\t}",
    "function_modified_lines": {
      "added": [
        "\t\t\t\tif (!outFile.toPath().normalize().startsWith(targetFolder.toPath().normalize())) {\n",
        "\t\t\t\t\tthrow new RuntimeException(\"Bad zip entry\");\n",
        "\t\t\t\t}\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "A vulnerability classified as critical was found in scifio. Affected by this vulnerability is the function downloadAndUnpackResource of the file src/test/java/io/scif/util/DefaultSampleFilesService.java of the component ZIP File Handler. The manipulation leads to path traversal. The attack can be launched remotely. The name of the patch is fcb0dbca0ec72b22fe0c9ddc8abc9cb188a0ff31. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-215803.",
    "id": 12682
  },
  {
    "cve_id": "CVE-2022-4494",
    "code_before_change": "{\n                String fileName = ze.getName();\n                File newFile = new File(destDir, fileName);\n                if (ze.isDirectory())\n                {\n                    if (newFile.exists())\n                        deleteDirAndContents(newFile);\n                    newFile.mkdirs();\n                }\n                else\n                {\n                    if (newFile.exists())\n                        newFile.delete();\n                    if (newFile.getParentFile() != null && !newFile.getParentFile().exists())\n                        newFile.getParentFile().mkdirs();\n                    FileOutputStream fos = new FileOutputStream(newFile);\n                    int len;\n                    while ((len = zis.read(buffer)) > 0)\n                        fos.write(buffer, 0, len);\n\n                    fos.close();\n                }\n                ze = zis.getNextEntry();\n            }",
    "code_after_change": "{\n                String fileName = ze.getName();\n                File newFile = new File(destDir, fileName);\n                if (!newFile.toPath().normalize().startsWith(destDir.toPath().normalize())) {\n                    throw new IOException(\"Bad zip entry\");\n                }\n                if (ze.isDirectory())\n                {\n                    if (newFile.exists())\n                        deleteDirAndContents(newFile);\n                    newFile.mkdirs();\n                }\n                else\n                {\n                    if (newFile.exists())\n                        newFile.delete();\n                    if (newFile.getParentFile() != null && !newFile.getParentFile().exists())\n                        newFile.getParentFile().mkdirs();\n                    FileOutputStream fos = new FileOutputStream(newFile);\n                    int len;\n                    while ((len = zis.read(buffer)) > 0)\n                        fos.write(buffer, 0, len);\n\n                    fos.close();\n                }\n                ze = zis.getNextEntry();\n            }",
    "patch": "@@ -220,6 +220,9 @@ public static void extractZip(File zipFile, File destDir) throws IOException\n             {\n                 String fileName = ze.getName();\n                 File newFile = new File(destDir, fileName);\n+                if (!newFile.toPath().normalize().startsWith(destDir.toPath().normalize())) {\n+                    throw new IOException(\"Bad zip entry\");\n+                }\n                 if (ze.isDirectory())\n                 {\n                     if (newFile.exists())",
    "function_modified_lines": {
      "added": [
        "                if (!newFile.toPath().normalize().startsWith(destDir.toPath().normalize())) {\n",
        "                    throw new IOException(\"Bad zip entry\");\n",
        "                }\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "A vulnerability, which was classified as critical, has been found in bspkrs MCPMappingViewer. Affected by this issue is the function extractZip of the file src/main/java/bspkrs/mmv/RemoteZipHandler.java of the component ZIP File Handler. The manipulation leads to path traversal. The attack may be launched remotely. The name of the patch is 6e602746c96b4756c271d080dae7d22ad804a1bd. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-215804.",
    "id": 12683
  },
  {
    "cve_id": "CVE-2022-4583",
    "code_before_change": "{\n         JarEntry je = en.nextElement();\n         java.io.File f = new File(fout,  je.getName());\n         if (je.isDirectory()) {\n            f.mkdirs();\n            continue;\n\n         } else {\n            // f.getParentFile().mkdirs();\n\n            if (f.getPath().indexOf(\"META-INF\") >= 0) {\n               // skip it\n            } else {\n            f.getParentFile().mkdirs();\n            java.io.InputStream is = jf.getInputStream(je);\n            java.io.FileOutputStream fos = new FileOutputStream(f);\n\n            // EFF - buffering, file channels??\n            while (is.available() > 0) {\n               fos.write(is.read());\n            }\n            fos.close();\n            is.close();\n         }\n         }\n      }",
    "code_after_change": "{\n         JarEntry je = en.nextElement();\n         java.io.File f = new File(fout,  je.getName());\n\t\t\t\t\t\t\tif (!f.toPath().normalize().startsWith(fout.toPath().normalize())) {\n\t\t\t\t\t\t\t\tthrow new RuntimeException(\"Bad zip entry\");\n\t\t\t\t\t\t\t}\n         if (je.isDirectory()) {\n            f.mkdirs();\n            continue;\n\n         } else {\n            // f.getParentFile().mkdirs();\n\n            if (f.getPath().indexOf(\"META-INF\") >= 0) {\n               // skip it\n            } else {\n            f.getParentFile().mkdirs();\n            java.io.InputStream is = jf.getInputStream(je);\n            java.io.FileOutputStream fos = new FileOutputStream(f);\n\n            // EFF - buffering, file channels??\n            while (is.available() > 0) {\n               fos.write(is.read());\n            }\n            fos.close();\n            is.close();\n         }\n         }\n      }",
    "patch": "@@ -205,6 +205,9 @@ public static void unpackJar(File fjar, File fout) throws IOException {\n       while (en.hasMoreElements()) {\n          JarEntry je = en.nextElement();\n          java.io.File f = new File(fout,  je.getName());\n+\t\t\t\t\t\t\tif (!f.toPath().normalize().startsWith(fout.toPath().normalize())) {\n+\t\t\t\t\t\t\t\tthrow new RuntimeException(\"Bad zip entry\");\n+\t\t\t\t\t\t\t}\n          if (je.isDirectory()) {\n             f.mkdirs();\n             continue;",
    "function_modified_lines": {
      "added": [
        "\t\t\t\t\t\t\tif (!f.toPath().normalize().startsWith(fout.toPath().normalize())) {\n",
        "\t\t\t\t\t\t\t\tthrow new RuntimeException(\"Bad zip entry\");\n",
        "\t\t\t\t\t\t\t}\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "A vulnerability was found in jLEMS. It has been declared as critical. Affected by this vulnerability is the function unpackJar of the file src/main/java/org/lemsml/jlems/io/util/JUtil.java. The manipulation leads to path traversal. The attack can be launched remotely. The name of the patch is 8c224637d7d561076364a9e3c2c375daeaf463dc. It is recommended to apply a patch to fix this issue. The identifier VDB-216169 was assigned to this vulnerability.",
    "id": 12687
  },
  {
    "cve_id": "CVE-2023-40828",
    "code_before_change": "/*\n * Copyright (C) 2012-present the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.pf4j.util;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * This class extracts the content of the plugin zip into a directory.\n * It's a class for only the internal use.\n *\n * @author Decebal Suiu\n */\npublic class Unzip {\n\n    private static final Logger log = LoggerFactory.getLogger(Unzip.class);\n\n    /**\n     * Holds the destination directory.\n     * File will be unzipped into the destination directory.\n     */\n    private File destination;\n\n    /**\n     * Holds path to zip file.\n     */\n    private File source;\n\n    public Unzip() {\n    }\n\n    public Unzip(File source, File destination) {\n        this.source = source;\n        this.destination = destination;\n    }\n\n    public void setSource(File source) {\n        this.source = source;\n    }\n\n    public void setDestination(File destination) {\n        this.destination = destination;\n    }\n\n    /**\n     * Extract the content of zip file ({@code source}) to destination directory.\n     * If destination directory already exists it will be deleted before.\n     */\n    public void extract() throws IOException {\n        log.debug(\"Extract content of '{}' to '{}'\", source, destination);\n\n        // delete destination directory if exists\n        if (destination.exists() && destination.isDirectory()) {\n            FileUtils.delete(destination.toPath());\n        }\n\n        try (ZipInputStream zipInputStream = new ZipInputStream(new FileInputStream(source))) {\n            ZipEntry zipEntry;\n            while ((zipEntry = zipInputStream.getNextEntry()) != null) {\n                File file = new File(destination, zipEntry.getName());\n\n                // create intermediary directories - sometimes zip don't add them\n                File dir = new File(file.getParent());\n\n                mkdirsOrThrow(dir);\n\n                if (zipEntry.isDirectory()) {\n                    mkdirsOrThrow(file);\n                } else {\n                    byte[] buffer = new byte[1024];\n                    int length;\n                    try (FileOutputStream fos = new FileOutputStream(file)) {\n                        while ((length = zipInputStream.read(buffer)) >= 0) {\n                            fos.write(buffer, 0, length);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    private static void mkdirsOrThrow(File dir) throws IOException {\n        if (!dir.exists() && !dir.mkdirs()) {\n            throw new IOException(\"Failed to create directory \" + dir);\n        }\n    }\n\n}\n",
    "code_after_change": "/*\n * Copyright (C) 2012-present the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.pf4j.util;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipException;\nimport java.util.zip.ZipInputStream;\n\n/**\n * This class extracts the content of the plugin zip into a directory.\n * It's a class for only the internal use.\n *\n * @author Decebal Suiu\n */\npublic class Unzip {\n\n    private static final Logger log = LoggerFactory.getLogger(Unzip.class);\n\n    /**\n     * Holds the destination directory.\n     * File will be unzipped into the destination directory.\n     */\n    private File destination;\n\n    /**\n     * Holds path to zip file.\n     */\n    private File source;\n\n    public Unzip() {\n    }\n\n    public Unzip(File source, File destination) {\n        this.source = source;\n        this.destination = destination;\n    }\n\n    public void setSource(File source) {\n        this.source = source;\n    }\n\n    public void setDestination(File destination) {\n        this.destination = destination;\n    }\n\n    /**\n     * Extract the content of zip file ({@code source}) to destination directory.\n     * If destination directory already exists it will be deleted before.\n     */\n    public void extract() throws IOException {\n        log.debug(\"Extract content of '{}' to '{}'\", source, destination);\n\n        // delete destination directory if exists\n        if (destination.exists() && destination.isDirectory()) {\n            FileUtils.delete(destination.toPath());\n        }\n\n        String destinationCanonicalPath = destination.getCanonicalPath();\n        try (ZipInputStream zipInputStream = new ZipInputStream(new FileInputStream(source))) {\n            ZipEntry zipEntry;\n            while ((zipEntry = zipInputStream.getNextEntry()) != null) {\n                File file = new File(destination, zipEntry.getName());\n\n                String fileCanonicalPath = file.getCanonicalPath();\n                if (!fileCanonicalPath.startsWith(destinationCanonicalPath)) {\n                    throw new ZipException(\"The file \"+ zipEntry.getName() + \" is trying to leave the target output directory of \"+ destination);\n                }\n\n                // create intermediary directories - sometimes zip don't add them\n                File dir = new File(file.getParent());\n\n                mkdirsOrThrow(dir);\n\n                if (zipEntry.isDirectory()) {\n                    mkdirsOrThrow(file);\n                } else {\n                    byte[] buffer = new byte[1024];\n                    int length;\n                    try (FileOutputStream fos = new FileOutputStream(file)) {\n                        while ((length = zipInputStream.read(buffer)) >= 0) {\n                            fos.write(buffer, 0, length);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    private static void mkdirsOrThrow(File dir) throws IOException {\n        if (!dir.exists() && !dir.mkdirs()) {\n            throw new IOException(\"Failed to create directory \" + dir);\n        }\n    }\n\n}\n",
    "patch": "@@ -15,17 +15,17 @@\n  */\n package org.pf4j.util;\n \n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n import java.io.File;\n import java.io.FileInputStream;\n-import java.io.FileNotFoundException;\n import java.io.FileOutputStream;\n import java.io.IOException;\n import java.util.zip.ZipEntry;\n+import java.util.zip.ZipException;\n import java.util.zip.ZipInputStream;\n \n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n /**\n  * This class extracts the content of the plugin zip into a directory.\n  * It's a class for only the internal use.\n@@ -75,11 +75,17 @@ public void extract() throws IOException {\n             FileUtils.delete(destination.toPath());\n         }\n \n+        String destinationCanonicalPath = destination.getCanonicalPath();\n         try (ZipInputStream zipInputStream = new ZipInputStream(new FileInputStream(source))) {\n             ZipEntry zipEntry;\n             while ((zipEntry = zipInputStream.getNextEntry()) != null) {\n                 File file = new File(destination, zipEntry.getName());\n \n+                String fileCanonicalPath = file.getCanonicalPath();\n+                if (!fileCanonicalPath.startsWith(destinationCanonicalPath)) {\n+                    throw new ZipException(\"The file \"+ zipEntry.getName() + \" is trying to leave the target output directory of \"+ destination);\n+                }\n+\n                 // create intermediary directories - sometimes zip don't add them\n                 File dir = new File(file.getParent());\n ",
    "function_modified_lines": {
      "added": [
        "import org.slf4j.Logger;\n",
        "import org.slf4j.LoggerFactory;\n",
        "\n",
        "import java.util.zip.ZipException;\n"
      ],
      "deleted": [
        "import java.io.FileNotFoundException;\n",
        "import org.slf4j.Logger;\n",
        "import org.slf4j.LoggerFactory;\n",
        "\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "An issue in pf4j pf4j v.3.9.0 and before allows a remote attacker to obtain sensitive information and execute arbitrary code via the expandIfZip method in the extract function.",
    "id": 12845
  },
  {
    "cve_id": "CVE-2023-40828",
    "code_before_change": "{\n        log.debug(\"Extract content of '{}' to '{}'\", source, destination);\n\n        // delete destination directory if exists\n        if (destination.exists() && destination.isDirectory()) {\n            FileUtils.delete(destination.toPath());\n        }\n\n        try (ZipInputStream zipInputStream = new ZipInputStream(new FileInputStream(source))) {\n            ZipEntry zipEntry;\n            while ((zipEntry = zipInputStream.getNextEntry()) != null) {\n                File file = new File(destination, zipEntry.getName());\n\n                // create intermediary directories - sometimes zip don't add them\n                File dir = new File(file.getParent());\n\n                mkdirsOrThrow(dir);\n\n                if (zipEntry.isDirectory()) {\n                    mkdirsOrThrow(file);\n                } else {\n                    byte[] buffer = new byte[1024];\n                    int length;\n                    try (FileOutputStream fos = new FileOutputStream(file)) {\n                        while ((length = zipInputStream.read(buffer)) >= 0) {\n                            fos.write(buffer, 0, length);\n                        }\n                    }\n                }\n            }\n        }\n    }",
    "code_after_change": "{\n        log.debug(\"Extract content of '{}' to '{}'\", source, destination);\n\n        // delete destination directory if exists\n        if (destination.exists() && destination.isDirectory()) {\n            FileUtils.delete(destination.toPath());\n        }\n\n        String destinationCanonicalPath = destination.getCanonicalPath();\n        try (ZipInputStream zipInputStream = new ZipInputStream(new FileInputStream(source))) {\n            ZipEntry zipEntry;\n            while ((zipEntry = zipInputStream.getNextEntry()) != null) {\n                File file = new File(destination, zipEntry.getName());\n\n                String fileCanonicalPath = file.getCanonicalPath();\n                if (!fileCanonicalPath.startsWith(destinationCanonicalPath)) {\n                    throw new ZipException(\"The file \"+ zipEntry.getName() + \" is trying to leave the target output directory of \"+ destination);\n                }\n\n                // create intermediary directories - sometimes zip don't add them\n                File dir = new File(file.getParent());\n\n                mkdirsOrThrow(dir);\n\n                if (zipEntry.isDirectory()) {\n                    mkdirsOrThrow(file);\n                } else {\n                    byte[] buffer = new byte[1024];\n                    int length;\n                    try (FileOutputStream fos = new FileOutputStream(file)) {\n                        while ((length = zipInputStream.read(buffer)) >= 0) {\n                            fos.write(buffer, 0, length);\n                        }\n                    }\n                }\n            }\n        }\n    }",
    "patch": "@@ -15,17 +15,17 @@\n  */\n package org.pf4j.util;\n \n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n import java.io.File;\n import java.io.FileInputStream;\n-import java.io.FileNotFoundException;\n import java.io.FileOutputStream;\n import java.io.IOException;\n import java.util.zip.ZipEntry;\n+import java.util.zip.ZipException;\n import java.util.zip.ZipInputStream;\n \n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n /**\n  * This class extracts the content of the plugin zip into a directory.\n  * It's a class for only the internal use.\n@@ -75,11 +75,17 @@ public void extract() throws IOException {\n             FileUtils.delete(destination.toPath());\n         }\n \n+        String destinationCanonicalPath = destination.getCanonicalPath();\n         try (ZipInputStream zipInputStream = new ZipInputStream(new FileInputStream(source))) {\n             ZipEntry zipEntry;\n             while ((zipEntry = zipInputStream.getNextEntry()) != null) {\n                 File file = new File(destination, zipEntry.getName());\n \n+                String fileCanonicalPath = file.getCanonicalPath();\n+                if (!fileCanonicalPath.startsWith(destinationCanonicalPath)) {\n+                    throw new ZipException(\"The file \"+ zipEntry.getName() + \" is trying to leave the target output directory of \"+ destination);\n+                }\n+\n                 // create intermediary directories - sometimes zip don't add them\n                 File dir = new File(file.getParent());\n ",
    "function_modified_lines": {
      "added": [
        "        String destinationCanonicalPath = destination.getCanonicalPath();\n",
        "                String fileCanonicalPath = file.getCanonicalPath();\n",
        "                if (!fileCanonicalPath.startsWith(destinationCanonicalPath)) {\n",
        "                    throw new ZipException(\"The file \"+ zipEntry.getName() + \" is trying to leave the target output directory of \"+ destination);\n",
        "                }\n",
        "\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "An issue in pf4j pf4j v.3.9.0 and before allows a remote attacker to obtain sensitive information and execute arbitrary code via the expandIfZip method in the extract function.",
    "id": 12846
  },
  {
    "cve_id": "CVE-2023-48299",
    "code_before_change": "{\n                String name = entry.getName().substring(entry.getName().indexOf('/') + 1);\n                File file = new File(dest, name);\n                if (entry.isDirectory()) {\n                    FileUtils.forceMkdir(file);\n                } else {\n                    File parentFile = file.getParentFile();\n                    FileUtils.forceMkdir(parentFile);\n                    try (OutputStream os = Files.newOutputStream(file.toPath())) {\n                        IOUtils.copy(tis, os);\n                    }\n                }\n            }",
    "code_after_change": "{\n                String name = entry.getName().substring(entry.getName().indexOf('/') + 1);\n                File file = new File(dest, name);\n                File canonicalDestDir = dest.getCanonicalFile();\n                File canonicalFile = file.getCanonicalFile();\n\n                // Check for Zip Slip vulnerability\n                if (!canonicalFile.getPath().startsWith(canonicalDestDir.getPath())) {\n                    throw new IOException(\"Detected Zip Slip vulnerability: \" + entry.getName());\n                }\n\n                if (entry.isDirectory()) {\n                    FileUtils.forceMkdir(file);\n                } else {\n                    File parentFile = file.getParentFile();\n                    FileUtils.forceMkdir(parentFile);\n                    try (OutputStream os = Files.newOutputStream(file.toPath())) {\n                        IOUtils.copy(tis, os);\n                    }\n                }\n            }",
    "patch": "@@ -28,8 +28,15 @@ public static void unzip(InputStream is, File dest) throws IOException {\n         try (ZipInputStream zis = new ZipInputStream(is)) {\n             ZipEntry entry;\n             while ((entry = zis.getNextEntry()) != null) {\n-                String name = entry.getName();\n-                File file = new File(dest, name);\n+                File file = new File(dest, entry.getName());\n+                File canonicalDestDir = dest.getCanonicalFile();\n+                File canonicalFile = file.getCanonicalFile();\n+\n+                // Check for Zip Slip vulnerability\n+                if (!canonicalFile.getPath().startsWith(canonicalDestDir.getPath())) {\n+                    throw new IOException(\"Detected Zip Slip vulnerability: \" + entry.getName());\n+                }\n+\n                 if (entry.isDirectory()) {\n                     FileUtils.forceMkdir(file);\n                 } else {\n@@ -108,6 +115,14 @@ public static void decompressTarGzipFile(InputStream is, File dest) throws IOExc\n             while ((entry = tis.getNextEntry()) != null) {\n                 String name = entry.getName().substring(entry.getName().indexOf('/') + 1);\n                 File file = new File(dest, name);\n+                File canonicalDestDir = dest.getCanonicalFile();\n+                File canonicalFile = file.getCanonicalFile();\n+\n+                // Check for Zip Slip vulnerability\n+                if (!canonicalFile.getPath().startsWith(canonicalDestDir.getPath())) {\n+                    throw new IOException(\"Detected Zip Slip vulnerability: \" + entry.getName());\n+                }\n+\n                 if (entry.isDirectory()) {\n                     FileUtils.forceMkdir(file);\n                 } else {",
    "function_modified_lines": {
      "added": [
        "                File canonicalDestDir = dest.getCanonicalFile();\n",
        "                File canonicalFile = file.getCanonicalFile();\n",
        "\n",
        "                // Check for Zip Slip vulnerability\n",
        "                if (!canonicalFile.getPath().startsWith(canonicalDestDir.getPath())) {\n",
        "                    throw new IOException(\"Detected Zip Slip vulnerability: \" + entry.getName());\n",
        "                }\n",
        "\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "TorchServe is a tool for serving and scaling PyTorch models in production. Starting in version 0.1.0 and prior to version 0.9.0, using the model/workflow management API, there is a chance of uploading potentially harmful archives that contain files that are extracted to any location on the filesystem that is within the process permissions. Leveraging this issue could aid third-party actors in hiding harmful code in open-source/public models, which can be downloaded from the internet, and take advantage of machines running Torchserve. The ZipSlip issue in TorchServe has been fixed by validating the paths of files contained within a zip archive before extracting them. TorchServe release 0.9.0 includes fixes to address the ZipSlip vulnerability.",
    "id": 12924
  },
  {
    "cve_id": "CVE-2024-24565",
    "code_before_change": "/*\n * Licensed to Crate.io GmbH (\"Crate\") under one or more contributor\n * license agreements.  See the NOTICE file distributed with this work for\n * additional information regarding copyright ownership.  Crate licenses\n * this file to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.  You may\n * obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n * License for the specific language governing permissions and limitations\n * under the License.\n *\n * However, if you have executed another commercial license agreement\n * with Crate these terms will supersede the license and you may use the\n * software solely pursuant to the terms of the relevant commercial agreement.\n */\n\npackage io.crate.execution.engine.collect.sources;\n\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.CompletableFuture;\n\nimport org.elasticsearch.cluster.service.ClusterService;\nimport org.elasticsearch.common.inject.Inject;\nimport org.elasticsearch.common.inject.Singleton;\nimport org.elasticsearch.threadpool.ThreadPool;\n\nimport io.crate.analyze.AnalyzedCopyFrom;\nimport io.crate.analyze.CopyFromParserProperties;\nimport io.crate.analyze.SymbolEvaluator;\nimport io.crate.common.annotations.VisibleForTesting;\nimport io.crate.data.BatchIterator;\nimport io.crate.data.Row;\nimport io.crate.data.SkippingBatchIterator;\nimport io.crate.execution.dsl.phases.CollectPhase;\nimport io.crate.execution.dsl.phases.FileUriCollectPhase;\nimport io.crate.execution.engine.collect.CollectTask;\nimport io.crate.execution.engine.collect.files.FileInputFactory;\nimport io.crate.execution.engine.collect.files.FileReadingIterator;\nimport io.crate.execution.engine.collect.files.LineCollectorExpression;\nimport io.crate.execution.engine.collect.files.LineProcessor;\nimport io.crate.expression.InputFactory;\nimport io.crate.expression.reference.file.FileLineReferenceResolver;\nimport io.crate.expression.symbol.Symbol;\nimport io.crate.metadata.NodeContext;\nimport io.crate.metadata.TransactionContext;\nimport io.crate.planner.operators.SubQueryResults;\nimport io.crate.types.DataTypes;\n\n@Singleton\npublic class FileCollectSource implements CollectSource {\n\n    private final ClusterService clusterService;\n    private final Map<String, FileInputFactory> fileInputFactoryMap;\n    private final InputFactory inputFactory;\n    private final NodeContext nodeCtx;\n    private final ThreadPool threadPool;\n\n    @Inject\n    public FileCollectSource(NodeContext nodeCtx,\n                             ClusterService clusterService,\n                             Map<String, FileInputFactory> fileInputFactoryMap,\n                             ThreadPool threadPool) {\n        this.fileInputFactoryMap = fileInputFactoryMap;\n        this.nodeCtx = nodeCtx;\n        this.inputFactory = new InputFactory(nodeCtx);\n        this.clusterService = clusterService;\n        this.threadPool = threadPool;\n    }\n\n    @Override\n    public CompletableFuture<BatchIterator<Row>> getIterator(TransactionContext txnCtx,\n                                                             CollectPhase collectPhase,\n                                                             CollectTask collectTask,\n                                                             boolean supportMoveToStart) {\n        FileUriCollectPhase fileUriCollectPhase = (FileUriCollectPhase) collectPhase;\n        InputFactory.Context<LineCollectorExpression<?>> ctx =\n            inputFactory.ctxForRefs(txnCtx, FileLineReferenceResolver::getImplementation);\n        ctx.add(collectPhase.toCollect());\n\n        List<String> fileUris = targetUriToStringList(txnCtx, nodeCtx, fileUriCollectPhase.targetUri());\n        FileReadingIterator fileReadingIterator = new FileReadingIterator(\n            fileUris,\n            fileUriCollectPhase.compression(),\n            fileInputFactoryMap,\n            fileUriCollectPhase.sharedStorage(),\n            fileUriCollectPhase.nodeIds().size(),\n            getReaderNumber(fileUriCollectPhase.nodeIds(), clusterService.state().nodes().getLocalNodeId()),\n            fileUriCollectPhase.withClauseOptions(),\n            threadPool.scheduler()\n        );\n        CopyFromParserProperties parserProperties = fileUriCollectPhase.parserProperties();\n        LineProcessor lineProcessor = new LineProcessor(\n            parserProperties.skipNumLines() > 0\n                ? new SkippingBatchIterator<>(fileReadingIterator, (int) parserProperties.skipNumLines())\n                : fileReadingIterator,\n            ctx.topLevelInputs(),\n            ctx.expressions(),\n            fileUriCollectPhase.inputFormat(),\n            parserProperties,\n            fileUriCollectPhase.targetColumns()\n        );\n        return CompletableFuture.completedFuture(lineProcessor);\n    }\n\n    @VisibleForTesting\n    public static int getReaderNumber(Collection<String> nodeIds, String localNodeId) {\n        String[] readers = nodeIds.toArray(new String[0]);\n        Arrays.sort(readers);\n        return Arrays.binarySearch(readers, localNodeId);\n    }\n\n    private static List<String> targetUriToStringList(TransactionContext txnCtx,\n                                                      NodeContext nodeCtx,\n                                                      Symbol targetUri) {\n        Object value = SymbolEvaluator.evaluate(txnCtx, nodeCtx, targetUri, Row.EMPTY, SubQueryResults.EMPTY);\n        if (targetUri.valueType().id() == DataTypes.STRING.id()) {\n            String uri = (String) value;\n            return Collections.singletonList(uri);\n        } else if (DataTypes.STRING_ARRAY.equals(targetUri.valueType())) {\n            return DataTypes.STRING_ARRAY.implicitCast(value);\n        }\n\n        // this case actually never happens because the check is already done in the analyzer\n        throw AnalyzedCopyFrom.raiseInvalidType(targetUri.valueType());\n    }\n}\n",
    "code_after_change": "/*\n * Licensed to Crate.io GmbH (\"Crate\") under one or more contributor\n * license agreements.  See the NOTICE file distributed with this work for\n * additional information regarding copyright ownership.  Crate licenses\n * this file to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.  You may\n * obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n * License for the specific language governing permissions and limitations\n * under the License.\n *\n * However, if you have executed another commercial license agreement\n * with Crate these terms will supersede the license and you may use the\n * software solely pursuant to the terms of the relevant commercial agreement.\n */\n\npackage io.crate.execution.engine.collect.sources;\n\nimport static java.util.Objects.requireNonNull;\n\nimport java.net.URI;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.CompletableFuture;\n\nimport org.elasticsearch.cluster.service.ClusterService;\nimport org.elasticsearch.common.inject.Inject;\nimport org.elasticsearch.common.inject.Singleton;\nimport org.elasticsearch.threadpool.ThreadPool;\n\nimport io.crate.analyze.AnalyzedCopyFrom;\nimport io.crate.analyze.CopyFromParserProperties;\nimport io.crate.analyze.SymbolEvaluator;\nimport io.crate.common.annotations.VisibleForTesting;\nimport io.crate.data.BatchIterator;\nimport io.crate.data.Row;\nimport io.crate.data.SkippingBatchIterator;\nimport io.crate.exceptions.UnauthorizedException;\nimport io.crate.execution.dsl.phases.CollectPhase;\nimport io.crate.execution.dsl.phases.FileUriCollectPhase;\nimport io.crate.execution.engine.collect.CollectTask;\nimport io.crate.execution.engine.collect.files.FileInputFactory;\nimport io.crate.execution.engine.collect.files.FileReadingIterator;\nimport io.crate.execution.engine.collect.files.LineCollectorExpression;\nimport io.crate.execution.engine.collect.files.LineProcessor;\nimport io.crate.expression.InputFactory;\nimport io.crate.expression.reference.file.FileLineReferenceResolver;\nimport io.crate.expression.symbol.Symbol;\nimport io.crate.metadata.NodeContext;\nimport io.crate.metadata.TransactionContext;\nimport io.crate.planner.operators.SubQueryResults;\nimport io.crate.role.Role;\nimport io.crate.role.Roles;\nimport io.crate.types.DataTypes;\n\n@Singleton\npublic class FileCollectSource implements CollectSource {\n\n    private final ClusterService clusterService;\n    private final Map<String, FileInputFactory> fileInputFactoryMap;\n    private final InputFactory inputFactory;\n    private final NodeContext nodeCtx;\n    private final ThreadPool threadPool;\n    private final Roles roles;\n\n    @Inject\n    public FileCollectSource(NodeContext nodeCtx,\n                             ClusterService clusterService,\n                             Map<String, FileInputFactory> fileInputFactoryMap,\n                             ThreadPool threadPool,\n                             Roles roles) {\n        this.fileInputFactoryMap = fileInputFactoryMap;\n        this.nodeCtx = nodeCtx;\n        this.inputFactory = new InputFactory(nodeCtx);\n        this.clusterService = clusterService;\n        this.threadPool = threadPool;\n        this.roles = roles;\n    }\n\n    @Override\n    public CompletableFuture<BatchIterator<Row>> getIterator(TransactionContext txnCtx,\n                                                             CollectPhase collectPhase,\n                                                             CollectTask collectTask,\n                                                             boolean supportMoveToStart) {\n        FileUriCollectPhase fileUriCollectPhase = (FileUriCollectPhase) collectPhase;\n        InputFactory.Context<LineCollectorExpression<?>> ctx =\n            inputFactory.ctxForRefs(txnCtx, FileLineReferenceResolver::getImplementation);\n        ctx.add(collectPhase.toCollect());\n\n        Role user = requireNonNull(roles.findUser(txnCtx.sessionSettings().userName()), \"User who invoked a statement must exist\");\n        List<URI> fileUris = targetUriToStringList(txnCtx, nodeCtx, fileUriCollectPhase.targetUri()).stream()\n            .map(s -> {\n                var uri = FileReadingIterator.toURI(s);\n                if (uri.getScheme().equals(\"file\") && user.isSuperUser() == false) {\n                    throw new UnauthorizedException(\"Only a superuser can read from the local file system\");\n                }\n                return uri;\n            })\n            .toList();\n        FileReadingIterator fileReadingIterator = new FileReadingIterator(\n            fileUris,\n            fileUriCollectPhase.compression(),\n            fileInputFactoryMap,\n            fileUriCollectPhase.sharedStorage(),\n            fileUriCollectPhase.nodeIds().size(),\n            getReaderNumber(fileUriCollectPhase.nodeIds(), clusterService.state().nodes().getLocalNodeId()),\n            fileUriCollectPhase.withClauseOptions(),\n            threadPool.scheduler()\n        );\n        CopyFromParserProperties parserProperties = fileUriCollectPhase.parserProperties();\n        LineProcessor lineProcessor = new LineProcessor(\n            parserProperties.skipNumLines() > 0\n                ? new SkippingBatchIterator<>(fileReadingIterator, (int) parserProperties.skipNumLines())\n                : fileReadingIterator,\n            ctx.topLevelInputs(),\n            ctx.expressions(),\n            fileUriCollectPhase.inputFormat(),\n            parserProperties,\n            fileUriCollectPhase.targetColumns()\n        );\n        return CompletableFuture.completedFuture(lineProcessor);\n    }\n\n    @VisibleForTesting\n    public static int getReaderNumber(Collection<String> nodeIds, String localNodeId) {\n        String[] readers = nodeIds.toArray(new String[0]);\n        Arrays.sort(readers);\n        return Arrays.binarySearch(readers, localNodeId);\n    }\n\n    private static List<String> targetUriToStringList(TransactionContext txnCtx,\n                                                      NodeContext nodeCtx,\n                                                      Symbol targetUri) {\n        Object value = SymbolEvaluator.evaluate(txnCtx, nodeCtx, targetUri, Row.EMPTY, SubQueryResults.EMPTY);\n        if (targetUri.valueType().id() == DataTypes.STRING.id()) {\n            String uri = (String) value;\n            return Collections.singletonList(uri);\n        } else if (DataTypes.STRING_ARRAY.equals(targetUri.valueType())) {\n            return DataTypes.STRING_ARRAY.implicitCast(value);\n        }\n\n        // this case actually never happens because the check is already done in the analyzer\n        throw AnalyzedCopyFrom.raiseInvalidType(targetUri.valueType());\n    }\n}\n",
    "patch": "@@ -21,6 +21,9 @@\n \n package io.crate.execution.engine.collect.sources;\n \n+import static java.util.Objects.requireNonNull;\n+\n+import java.net.URI;\n import java.util.Arrays;\n import java.util.Collection;\n import java.util.Collections;\n@@ -40,6 +43,7 @@\n import io.crate.data.BatchIterator;\n import io.crate.data.Row;\n import io.crate.data.SkippingBatchIterator;\n+import io.crate.exceptions.UnauthorizedException;\n import io.crate.execution.dsl.phases.CollectPhase;\n import io.crate.execution.dsl.phases.FileUriCollectPhase;\n import io.crate.execution.engine.collect.CollectTask;\n@@ -53,6 +57,8 @@\n import io.crate.metadata.NodeContext;\n import io.crate.metadata.TransactionContext;\n import io.crate.planner.operators.SubQueryResults;\n+import io.crate.role.Role;\n+import io.crate.role.Roles;\n import io.crate.types.DataTypes;\n \n @Singleton\n@@ -63,17 +69,20 @@ public class FileCollectSource implements CollectSource {\n     private final InputFactory inputFactory;\n     private final NodeContext nodeCtx;\n     private final ThreadPool threadPool;\n+    private final Roles roles;\n \n     @Inject\n     public FileCollectSource(NodeContext nodeCtx,\n                              ClusterService clusterService,\n                              Map<String, FileInputFactory> fileInputFactoryMap,\n-                             ThreadPool threadPool) {\n+                             ThreadPool threadPool,\n+                             Roles roles) {\n         this.fileInputFactoryMap = fileInputFactoryMap;\n         this.nodeCtx = nodeCtx;\n         this.inputFactory = new InputFactory(nodeCtx);\n         this.clusterService = clusterService;\n         this.threadPool = threadPool;\n+        this.roles = roles;\n     }\n \n     @Override\n@@ -86,7 +95,16 @@ public CompletableFuture<BatchIterator<Row>> getIterator(TransactionContext txnC\n             inputFactory.ctxForRefs(txnCtx, FileLineReferenceResolver::getImplementation);\n         ctx.add(collectPhase.toCollect());\n \n-        List<String> fileUris = targetUriToStringList(txnCtx, nodeCtx, fileUriCollectPhase.targetUri());\n+        Role user = requireNonNull(roles.findUser(txnCtx.sessionSettings().userName()), \"User who invoked a statement must exist\");\n+        List<URI> fileUris = targetUriToStringList(txnCtx, nodeCtx, fileUriCollectPhase.targetUri()).stream()\n+            .map(s -> {\n+                var uri = FileReadingIterator.toURI(s);\n+                if (uri.getScheme().equals(\"file\") && user.isSuperUser() == false) {\n+                    throw new UnauthorizedException(\"Only a superuser can read from the local file system\");\n+                }\n+                return uri;\n+            })\n+            .toList();\n         FileReadingIterator fileReadingIterator = new FileReadingIterator(\n             fileUris,\n             fileUriCollectPhase.compression(),",
    "function_modified_lines": {
      "added": [
        "import static java.util.Objects.requireNonNull;\n",
        "\n",
        "import java.net.URI;\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "CrateDB is a distributed SQL database that makes it simple to store and analyze massive amounts of data in real-time. There is a COPY FROM function in the CrateDB database that is used to import file data into database tables. This function has a flaw, and authenticated attackers can use the COPY FROM function to import arbitrary file content into database tables, resulting in information leakage. This vulnerability is patched in 5.3.9, 5.4.8, 5.5.4, and 5.6.1.",
    "id": 12945
  },
  {
    "cve_id": "CVE-2024-24565",
    "code_before_change": "/*\n * Licensed to Crate.io GmbH (\"Crate\") under one or more contributor\n * license agreements.  See the NOTICE file distributed with this work for\n * additional information regarding copyright ownership.  Crate licenses\n * this file to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.  You may\n * obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n * License for the specific language governing permissions and limitations\n * under the License.\n *\n * However, if you have executed another commercial license agreement\n * with Crate these terms will supersede the license and you may use the\n * software solely pursuant to the terms of the relevant commercial agreement.\n */\n\npackage io.crate.execution.engine.collect;\n\nimport static io.crate.testing.TestingHelpers.createNodeContext;\nimport static io.crate.testing.TestingHelpers.createReference;\nimport static io.crate.testing.TestingHelpers.isRow;\nimport static org.hamcrest.Matchers.contains;\nimport static org.junit.Assert.assertThat;\nimport static org.mockito.Mockito.mock;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.OutputStreamWriter;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Paths;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.UUID;\nimport java.util.concurrent.TimeUnit;\n\nimport org.elasticsearch.common.settings.Settings;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.rules.TemporaryFolder;\n\nimport io.crate.analyze.CopyFromParserProperties;\nimport io.crate.data.BatchIterator;\nimport io.crate.data.CollectionBucket;\nimport io.crate.data.Row;\nimport io.crate.data.testing.TestingRowConsumer;\nimport io.crate.execution.dsl.phases.FileUriCollectPhase;\nimport io.crate.execution.engine.collect.sources.FileCollectSource;\nimport io.crate.expression.symbol.Literal;\nimport io.crate.metadata.ColumnIdent;\nimport io.crate.metadata.CoordinatorTxnCtx;\nimport io.crate.test.integration.CrateDummyClusterServiceUnitTest;\nimport io.crate.types.DataTypes;\n\n\npublic class MapSideDataCollectOperationTest extends CrateDummyClusterServiceUnitTest {\n\n    @Rule\n    public TemporaryFolder temporaryFolder = new TemporaryFolder();\n\n    @Test\n    public void testFileUriCollect() throws Exception {\n        FileCollectSource fileCollectSource = new FileCollectSource(\n            createNodeContext(),\n            clusterService,\n            Collections.emptyMap(),\n            THREAD_POOL\n            );\n\n        File tmpFile = temporaryFolder.newFile(\"fileUriCollectOperation.json\");\n        try (OutputStreamWriter writer = new OutputStreamWriter(new FileOutputStream(tmpFile), StandardCharsets.UTF_8)) {\n            writer.write(\"{\\\"name\\\": \\\"Arthur\\\", \\\"id\\\": 4, \\\"details\\\": {\\\"age\\\": 38}}\\n\");\n            writer.write(\"{\\\"id\\\": 5, \\\"name\\\": \\\"Trillian\\\", \\\"details\\\": {\\\"age\\\": 33}}\\n\");\n        }\n\n        FileUriCollectPhase collectNode = new FileUriCollectPhase(\n            UUID.randomUUID(),\n            0,\n            \"test\",\n            Collections.singletonList(\"noop_id\"),\n            Literal.of(Paths.get(tmpFile.toURI()).toUri().toString()),\n            List.of(\"a\", \"b\"),\n            Arrays.asList(\n                createReference(\"name\", DataTypes.STRING),\n                createReference(new ColumnIdent(\"details\", \"age\"), DataTypes.INTEGER)\n            ),\n            Collections.emptyList(),\n            null,\n            false,\n            CopyFromParserProperties.DEFAULT,\n            FileUriCollectPhase.InputFormat.JSON,\n            Settings.EMPTY\n        );\n        TestingRowConsumer consumer = new TestingRowConsumer();\n        CollectTask collectTask = mock(CollectTask.class);\n        BatchIterator<Row> iterator = fileCollectSource.getIterator(\n            CoordinatorTxnCtx.systemTransactionContext(), collectNode, collectTask, false).get(5, TimeUnit.SECONDS);\n        consumer.accept(iterator, null);\n        assertThat(new CollectionBucket(consumer.getResult()), contains(\n            isRow(\"Arthur\", 38),\n            isRow(\"Trillian\", 33)\n        ));\n    }\n}\n",
    "code_after_change": "/*\n * Licensed to Crate.io GmbH (\"Crate\") under one or more contributor\n * license agreements.  See the NOTICE file distributed with this work for\n * additional information regarding copyright ownership.  Crate licenses\n * this file to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.  You may\n * obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n * License for the specific language governing permissions and limitations\n * under the License.\n *\n * However, if you have executed another commercial license agreement\n * with Crate these terms will supersede the license and you may use the\n * software solely pursuant to the terms of the relevant commercial agreement.\n */\n\npackage io.crate.execution.engine.collect;\n\nimport static io.crate.testing.TestingHelpers.createNodeContext;\nimport static io.crate.testing.TestingHelpers.createReference;\nimport static io.crate.testing.TestingHelpers.isRow;\nimport static org.hamcrest.Matchers.contains;\nimport static org.junit.Assert.assertThat;\nimport static org.mockito.Mockito.mock;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.OutputStreamWriter;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Paths;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.UUID;\nimport java.util.concurrent.TimeUnit;\n\nimport org.elasticsearch.common.settings.Settings;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.rules.TemporaryFolder;\n\nimport io.crate.analyze.CopyFromParserProperties;\nimport io.crate.data.BatchIterator;\nimport io.crate.data.CollectionBucket;\nimport io.crate.data.Row;\nimport io.crate.data.testing.TestingRowConsumer;\nimport io.crate.execution.dsl.phases.FileUriCollectPhase;\nimport io.crate.execution.engine.collect.sources.FileCollectSource;\nimport io.crate.expression.symbol.Literal;\nimport io.crate.metadata.ColumnIdent;\nimport io.crate.metadata.CoordinatorTxnCtx;\nimport io.crate.role.Role;\nimport io.crate.test.integration.CrateDummyClusterServiceUnitTest;\nimport io.crate.types.DataTypes;\n\n\npublic class MapSideDataCollectOperationTest extends CrateDummyClusterServiceUnitTest {\n\n    @Rule\n    public TemporaryFolder temporaryFolder = new TemporaryFolder();\n\n    @Test\n    public void testFileUriCollect() throws Exception {\n        FileCollectSource fileCollectSource = new FileCollectSource(\n            createNodeContext(),\n            clusterService,\n            Collections.emptyMap(),\n            THREAD_POOL,\n            () -> List.of(Role.CRATE_USER)\n            );\n\n        File tmpFile = temporaryFolder.newFile(\"fileUriCollectOperation.json\");\n        try (OutputStreamWriter writer = new OutputStreamWriter(new FileOutputStream(tmpFile), StandardCharsets.UTF_8)) {\n            writer.write(\"{\\\"name\\\": \\\"Arthur\\\", \\\"id\\\": 4, \\\"details\\\": {\\\"age\\\": 38}}\\n\");\n            writer.write(\"{\\\"id\\\": 5, \\\"name\\\": \\\"Trillian\\\", \\\"details\\\": {\\\"age\\\": 33}}\\n\");\n        }\n\n        FileUriCollectPhase collectNode = new FileUriCollectPhase(\n            UUID.randomUUID(),\n            0,\n            \"test\",\n            Collections.singletonList(\"noop_id\"),\n            Literal.of(Paths.get(tmpFile.toURI()).toUri().toString()),\n            List.of(\"a\", \"b\"),\n            Arrays.asList(\n                createReference(\"name\", DataTypes.STRING),\n                createReference(new ColumnIdent(\"details\", \"age\"), DataTypes.INTEGER)\n            ),\n            Collections.emptyList(),\n            null,\n            false,\n            CopyFromParserProperties.DEFAULT,\n            FileUriCollectPhase.InputFormat.JSON,\n            Settings.EMPTY\n        );\n        TestingRowConsumer consumer = new TestingRowConsumer();\n        CollectTask collectTask = mock(CollectTask.class);\n        BatchIterator<Row> iterator = fileCollectSource.getIterator(\n            CoordinatorTxnCtx.systemTransactionContext(), collectNode, collectTask, false).get(5, TimeUnit.SECONDS);\n        consumer.accept(iterator, null);\n        assertThat(new CollectionBucket(consumer.getResult()), contains(\n            isRow(\"Arthur\", 38),\n            isRow(\"Trillian\", 33)\n        ));\n    }\n}\n",
    "patch": "@@ -54,6 +54,7 @@\n import io.crate.expression.symbol.Literal;\n import io.crate.metadata.ColumnIdent;\n import io.crate.metadata.CoordinatorTxnCtx;\n+import io.crate.role.Role;\n import io.crate.test.integration.CrateDummyClusterServiceUnitTest;\n import io.crate.types.DataTypes;\n \n@@ -69,7 +70,8 @@ public void testFileUriCollect() throws Exception {\n             createNodeContext(),\n             clusterService,\n             Collections.emptyMap(),\n-            THREAD_POOL\n+            THREAD_POOL,\n+            () -> List.of(Role.CRATE_USER)\n             );\n \n         File tmpFile = temporaryFolder.newFile(\"fileUriCollectOperation.json\");",
    "function_modified_lines": {
      "added": [
        "import io.crate.role.Role;\n",
        "            THREAD_POOL,\n",
        "            () -> List.of(Role.CRATE_USER)\n"
      ],
      "deleted": [
        "            THREAD_POOL\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "CrateDB is a distributed SQL database that makes it simple to store and analyze massive amounts of data in real-time. There is a COPY FROM function in the CrateDB database that is used to import file data into database tables. This function has a flaw, and authenticated attackers can use the COPY FROM function to import arbitrary file content into database tables, resulting in information leakage. This vulnerability is patched in 5.3.9, 5.4.8, 5.5.4, and 5.6.1.",
    "id": 12946
  },
  {
    "cve_id": "CVE-2024-25125",
    "code_before_change": "{\n            Path path = getPrefixDir(dateDir, attemptDir).resolve(fileName);\n            try (InputStream in = Files.newInputStream(path)) {\n                return ByteStreams.toByteArray(in);\n            }\n            catch (FileNotFoundException ex) {\n                throw new StorageFileNotFoundException(ex);\n            }\n            catch (IOException ex) {\n                throw ThrowablesUtil.propagate(ex);\n            }\n        }",
    "code_after_change": "{\n            Path prefixDir = getPrefixDir(dateDir, attemptDir);\n            Path path = prefixDir.resolve(fileName).normalize();\n            if (!path.startsWith(prefixDir)) {\n                throw new IllegalArgumentException(\"Invalid file name: \" + fileName);\n            }\n            try (InputStream in = Files.newInputStream(path)) {\n                return ByteStreams.toByteArray(in);\n            }\n            catch (FileNotFoundException | NoSuchFileException ex) {\n                throw new StorageFileNotFoundException(ex);\n            }\n            catch (IOException ex) {\n                throw ThrowablesUtil.propagate(ex);\n            }\n        }",
    "patch": "@@ -1,5 +1,6 @@\n package io.digdag.core.log;\n \n+import java.nio.file.NoSuchFileException;\n import java.util.concurrent.locks.ReentrantReadWriteLock;\n import java.io.InputStream;\n import java.io.OutputStream;\n@@ -122,11 +123,15 @@ protected void listFiles(String dateDir, String attemptDir, boolean enableDirect\n         protected byte[] getFile(String dateDir, String attemptDir, String fileName)\n             throws StorageFileNotFoundException\n         {\n-            Path path = getPrefixDir(dateDir, attemptDir).resolve(fileName);\n+            Path prefixDir = getPrefixDir(dateDir, attemptDir);\n+            Path path = prefixDir.resolve(fileName).normalize();\n+            if (!path.startsWith(prefixDir)) {\n+                throw new IllegalArgumentException(\"Invalid file name: \" + fileName);\n+            }\n             try (InputStream in = Files.newInputStream(path)) {\n                 return ByteStreams.toByteArray(in);\n             }\n-            catch (FileNotFoundException ex) {\n+            catch (FileNotFoundException | NoSuchFileException ex) {\n                 throw new StorageFileNotFoundException(ex);\n             }\n             catch (IOException ex) {",
    "function_modified_lines": {
      "added": [
        "            Path prefixDir = getPrefixDir(dateDir, attemptDir);\n",
        "            Path path = prefixDir.resolve(fileName).normalize();\n",
        "            if (!path.startsWith(prefixDir)) {\n",
        "                throw new IllegalArgumentException(\"Invalid file name: \" + fileName);\n",
        "            }\n",
        "            catch (FileNotFoundException | NoSuchFileException ex) {\n"
      ],
      "deleted": [
        "            Path path = getPrefixDir(dateDir, attemptDir).resolve(fileName);\n",
        "            catch (FileNotFoundException ex) {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "Digdag is an open source tool that to build, run, schedule, and monitor complex pipelines of tasks across various platforms. Treasure Data's digdag workload automation system is susceptible to a path traversal vulnerability if it's configured to store log files locally. This issue may lead to information disclosure and has been addressed in release version 0.10.5.1. Users are advised to upgrade. There are no known workarounds for this vulnerability.",
    "id": 12948
  },
  {
    "cve_id": "CVE-2024-25125",
    "code_before_change": "package io.digdag.core.log;\n\nimport io.digdag.client.DigdagClient;\nimport io.digdag.client.config.Config;\nimport io.digdag.client.config.ConfigFactory;\nimport io.digdag.core.agent.AgentId;\nimport io.digdag.core.config.PropertyUtils;\nimport io.digdag.spi.LogFilePrefix;\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.rules.TemporaryFolder;\nimport static org.hamcrest.Matchers.is;\nimport static org.hamcrest.MatcherAssert.assertThat;\n\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Path;\nimport java.time.Instant;\nimport java.time.ZoneId;\nimport com.google.common.base.Optional;\nimport java.util.Properties;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\n\nimport io.digdag.core.log.LocalFileLogServerFactory.LocalFileLogServer.LocalFileDirectTaskLogger;\n\npublic class LocalFileLogServerFactoryTest\n{\n    private static final ConfigFactory CONFIG_FACTORY = new ConfigFactory(DigdagClient.objectMapper());\n\n    @Rule\n    public TemporaryFolder tempFolder = new TemporaryFolder();\n\n    Path taskLogPath;\n    Properties props;\n    Config systemConfig;\n    LocalFileLogServerFactory logServerFactory;\n    LocalFileLogServerFactory.LocalFileLogServer localServer;\n\n    LogFilePrefix prefix = LogFilePrefix.builder()\n            .createdAt(Instant.now())\n            .retryAttemptName(Optional.absent())\n            .projectId(1)\n            .sessionTime(Instant.now())\n            .siteId(1)\n            .timeZone(ZoneId.systemDefault())\n            .workflowName(\"test1\")\n            .build();\n    LocalFileDirectTaskLogger taskLogger;\n\n    @Before\n    public void setUp() throws IOException\n    {\n        taskLogPath = tempFolder.newFolder(\"task_logs\").toPath();\n    }\n\n    private void setUpTaskLogger(Optional<String> size)\n    {\n        props = new Properties();\n        props.setProperty(\"log-server.local.path\", taskLogPath.toString());\n        if (size.isPresent()) {\n            props.setProperty(\"log-server.local.split_size\", size.get());\n        }\n        else {\n        }\n        systemConfig = PropertyUtils.toConfigElement(props).toConfig(CONFIG_FACTORY);\n        System.out.println(systemConfig);\n        logServerFactory = new LocalFileLogServerFactory(systemConfig, AgentId.of(\"agentA\"));\n        localServer = (LocalFileLogServerFactory.LocalFileLogServer) logServerFactory.getLogServer();\n        taskLogger = localServer.newDirectTaskLogger(prefix, \"+task1\");\n    }\n\n    @Test\n    public void checkSplitSize()\n    {\n        setUpTaskLogger(Optional.of(\"100\"));\n        String msg = repeatedString(\"a\", 51);\n        for (int i = 0; i < 100; i++) {\n            taskLogger.log(msg.getBytes(UTF_8), 0, msg.length());\n        }\n        taskLogger.close();\n        for (File f : taskLogPath.toFile().listFiles()) {\n            for (File f2: f.listFiles()) {\n                File[] taskLogs = f2.listFiles();\n                for (File f3: taskLogs) {\n                    System.out.println(f3);\n                }\n                assertThat(\"log file should be splitted\", f2.listFiles().length > 1, is(true));\n            }\n        }\n    }\n\n    @Test\n    public void checkSplitSizeIsZero()\n    {\n        setUpTaskLogger(Optional.of(\"0\"));\n\n        String msg = repeatedString(\"a\", 51);\n        for (int i = 0; i < 100; i++) {\n            taskLogger.log(msg.getBytes(UTF_8), 0, msg.length());\n        }\n        taskLogger.close();\n        for (File f : taskLogPath.toFile().listFiles()) {\n            for (File f2: f.listFiles()) {\n                File[] taskLogs = f2.listFiles();\n                for (File f3: taskLogs) {\n                    System.out.println(f3);\n                }\n                assertThat(\"log file should be a file\", f2.listFiles().length, is(1));\n            }\n        }\n    }\n\n    @Test\n    public void checkNoSplitSize()\n    {\n        setUpTaskLogger(Optional.absent());\n\n        String msg = repeatedString(\"a\", 51);\n        for (int i = 0; i < 100; i++) {\n            taskLogger.log(msg.getBytes(UTF_8), 0, msg.length());\n        }\n        taskLogger.close();\n        for (File f : taskLogPath.toFile().listFiles()) {\n            for (File f2: f.listFiles()) {\n                File[] taskLogs = f2.listFiles();\n                for (File f3: taskLogs) {\n                    System.out.println(f3);\n                }\n                assertThat(\"log file should be a file\", f2.listFiles().length, is(1));\n            }\n        }\n    }\n\n    private String repeatedString(String v, int num)\n    {\n        StringBuilder b = new StringBuilder();\n        for (int i = 0; i < num; i++) {\n            b.append(v);\n        }\n        return b.toString();\n    }\n}\n",
    "code_after_change": "package io.digdag.core.log;\n\nimport io.digdag.client.DigdagClient;\nimport io.digdag.client.config.Config;\nimport io.digdag.client.config.ConfigFactory;\nimport io.digdag.core.agent.AgentId;\nimport io.digdag.core.config.PropertyUtils;\nimport io.digdag.spi.LogFilePrefix;\nimport io.digdag.spi.StorageFileNotFoundException;\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.rules.TemporaryFolder;\nimport static org.hamcrest.Matchers.is;\nimport static org.hamcrest.MatcherAssert.assertThat;\n\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Path;\nimport java.time.Instant;\nimport java.time.ZoneId;\nimport com.google.common.base.Optional;\nimport java.util.Properties;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static org.junit.Assert.assertThrows;\n\nimport io.digdag.core.log.LocalFileLogServerFactory.LocalFileLogServer.LocalFileDirectTaskLogger;\n\npublic class LocalFileLogServerFactoryTest\n{\n    private static final ConfigFactory CONFIG_FACTORY = new ConfigFactory(DigdagClient.objectMapper());\n\n    @Rule\n    public TemporaryFolder tempFolder = new TemporaryFolder();\n\n    Path taskLogPath;\n    Properties props;\n    Config systemConfig;\n    LocalFileLogServerFactory logServerFactory;\n    LocalFileLogServerFactory.LocalFileLogServer localServer;\n\n    LogFilePrefix prefix = LogFilePrefix.builder()\n            .createdAt(Instant.now())\n            .retryAttemptName(Optional.absent())\n            .projectId(1)\n            .sessionTime(Instant.now())\n            .siteId(1)\n            .timeZone(ZoneId.systemDefault())\n            .workflowName(\"test1\")\n            .build();\n    LocalFileDirectTaskLogger taskLogger;\n\n    @Before\n    public void setUp() throws IOException\n    {\n        taskLogPath = tempFolder.newFolder(\"task_logs\").toPath();\n    }\n\n    private void setUpTaskLogger(Optional<String> size)\n    {\n        props = new Properties();\n        props.setProperty(\"log-server.local.path\", taskLogPath.toString());\n        if (size.isPresent()) {\n            props.setProperty(\"log-server.local.split_size\", size.get());\n        }\n        else {\n        }\n        systemConfig = PropertyUtils.toConfigElement(props).toConfig(CONFIG_FACTORY);\n        System.out.println(systemConfig);\n        logServerFactory = new LocalFileLogServerFactory(systemConfig, AgentId.of(\"agentA\"));\n        localServer = (LocalFileLogServerFactory.LocalFileLogServer) logServerFactory.getLogServer();\n        taskLogger = localServer.newDirectTaskLogger(prefix, \"+task1\");\n    }\n\n    @Test\n    public void checkSplitSize()\n    {\n        setUpTaskLogger(Optional.of(\"100\"));\n        String msg = repeatedString(\"a\", 51);\n        for (int i = 0; i < 100; i++) {\n            taskLogger.log(msg.getBytes(UTF_8), 0, msg.length());\n        }\n        taskLogger.close();\n        for (File f : taskLogPath.toFile().listFiles()) {\n            for (File f2: f.listFiles()) {\n                File[] taskLogs = f2.listFiles();\n                for (File f3: taskLogs) {\n                    System.out.println(f3);\n                }\n                assertThat(\"log file should be splitted\", f2.listFiles().length > 1, is(true));\n            }\n        }\n    }\n\n    @Test\n    public void checkSplitSizeIsZero()\n    {\n        setUpTaskLogger(Optional.of(\"0\"));\n\n        String msg = repeatedString(\"a\", 51);\n        for (int i = 0; i < 100; i++) {\n            taskLogger.log(msg.getBytes(UTF_8), 0, msg.length());\n        }\n        taskLogger.close();\n        for (File f : taskLogPath.toFile().listFiles()) {\n            for (File f2: f.listFiles()) {\n                File[] taskLogs = f2.listFiles();\n                for (File f3: taskLogs) {\n                    System.out.println(f3);\n                }\n                assertThat(\"log file should be a file\", f2.listFiles().length, is(1));\n            }\n        }\n    }\n\n    @Test\n    public void checkNoSplitSize()\n    {\n        setUpTaskLogger(Optional.absent());\n\n        String msg = repeatedString(\"a\", 51);\n        for (int i = 0; i < 100; i++) {\n            taskLogger.log(msg.getBytes(UTF_8), 0, msg.length());\n        }\n        taskLogger.close();\n        for (File f : taskLogPath.toFile().listFiles()) {\n            for (File f2: f.listFiles()) {\n                File[] taskLogs = f2.listFiles();\n                for (File f3: taskLogs) {\n                    System.out.println(f3);\n                }\n                assertThat(\"log file should be a file\", f2.listFiles().length, is(1));\n            }\n        }\n    }\n\n    private String repeatedString(String v, int num)\n    {\n        StringBuilder b = new StringBuilder();\n        for (int i = 0; i < num; i++) {\n            b.append(v);\n        }\n        return b.toString();\n    }\n\n    @Test\n    public void testGetFile() throws StorageFileNotFoundException\n    {\n        setUpTaskLogger(Optional.absent());\n        String fileName = localServer.putFile(prefix, \"+task\", Instant.now(), \"agent\", \"foo\".getBytes(UTF_8));\n        byte[] data = localServer.getFile(prefix, fileName);\n        assertThat(new String(data, UTF_8), is(\"foo\"));\n    }\n\n    @Test\n    public void testGetFileNotFound()\n    {\n        setUpTaskLogger(Optional.absent());\n        assertThrows(StorageFileNotFoundException.class, () -> localServer.getFile(prefix, \"foo\"));\n    }\n\n    @Test\n    public void testGetFileInvalidFileName()\n    {\n        setUpTaskLogger(Optional.absent());\n        assertThrows(IllegalArgumentException.class, () -> localServer.getFile(prefix, \"..\"));\n        assertThrows(IllegalArgumentException.class, () -> localServer.getFile(prefix, \"../foo\"));\n        assertThrows(IllegalArgumentException.class, () -> localServer.getFile(prefix, \"/foo\"));\n        assertThrows(IllegalArgumentException.class, () -> localServer.getFile(prefix, \"foo/../../bar\"));\n    }\n}\n",
    "patch": "@@ -6,6 +6,7 @@\n import io.digdag.core.agent.AgentId;\n import io.digdag.core.config.PropertyUtils;\n import io.digdag.spi.LogFilePrefix;\n+import io.digdag.spi.StorageFileNotFoundException;\n import org.junit.Before;\n import org.junit.Rule;\n import org.junit.Test;\n@@ -23,6 +24,7 @@\n import java.util.Properties;\n \n import static java.nio.charset.StandardCharsets.UTF_8;\n+import static org.junit.Assert.assertThrows;\n \n import io.digdag.core.log.LocalFileLogServerFactory.LocalFileLogServer.LocalFileDirectTaskLogger;\n \n@@ -142,4 +144,30 @@ private String repeatedString(String v, int num)\n         }\n         return b.toString();\n     }\n+\n+    @Test\n+    public void testGetFile() throws StorageFileNotFoundException\n+    {\n+        setUpTaskLogger(Optional.absent());\n+        String fileName = localServer.putFile(prefix, \"+task\", Instant.now(), \"agent\", \"foo\".getBytes(UTF_8));\n+        byte[] data = localServer.getFile(prefix, fileName);\n+        assertThat(new String(data, UTF_8), is(\"foo\"));\n+    }\n+\n+    @Test\n+    public void testGetFileNotFound()\n+    {\n+        setUpTaskLogger(Optional.absent());\n+        assertThrows(StorageFileNotFoundException.class, () -> localServer.getFile(prefix, \"foo\"));\n+    }\n+\n+    @Test\n+    public void testGetFileInvalidFileName()\n+    {\n+        setUpTaskLogger(Optional.absent());\n+        assertThrows(IllegalArgumentException.class, () -> localServer.getFile(prefix, \"..\"));\n+        assertThrows(IllegalArgumentException.class, () -> localServer.getFile(prefix, \"../foo\"));\n+        assertThrows(IllegalArgumentException.class, () -> localServer.getFile(prefix, \"/foo\"));\n+        assertThrows(IllegalArgumentException.class, () -> localServer.getFile(prefix, \"foo/../../bar\"));\n+    }\n }",
    "function_modified_lines": {
      "added": [
        "import io.digdag.spi.StorageFileNotFoundException;\n",
        "import static org.junit.Assert.assertThrows;\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "Digdag is an open source tool that to build, run, schedule, and monitor complex pipelines of tasks across various platforms. Treasure Data's digdag workload automation system is susceptible to a path traversal vulnerability if it's configured to store log files locally. This issue may lead to information disclosure and has been addressed in release version 0.10.5.1. Users are advised to upgrade. There are no known workarounds for this vulnerability.",
    "id": 12949
  },
  {
    "cve_id": "CVE-2024-25125",
    "code_before_change": "package acceptance;\n\nimport io.digdag.client.DigdagClient;\nimport io.digdag.client.api.Id;\nimport io.digdag.client.api.RestSessionAttempt;\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.rules.TemporaryFolder;\nimport utils.CommandStatus;\nimport utils.TemporaryDigdagServer;\n\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.regex.Pattern;\n\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.hamcrest.Matchers.is;\nimport static org.junit.Assert.assertTrue;\nimport static utils.TestUtils.*;\n\n\npublic class LogIT {\n    @Rule\n    public TemporaryFolder folder = new TemporaryFolder();\n\n    @Rule\n    public TemporaryDigdagServer server = TemporaryDigdagServer.of();\n\n    private Path config;\n    private Path projectDir;\n    private DigdagClient client;\n\n    @Before\n    public void setUp()\n            throws Exception {\n        projectDir = folder.getRoot().toPath().resolve(\"foobar\");\n        Files.createDirectories(projectDir);\n        config = folder.newFile().toPath();\n        client = DigdagClient.builder()\n                .host(server.host())\n                .port(server.port())\n                .build();\n    }\n\n    @Test\n    public void verifyLogWithAttemptIdAndSessionId()\n            throws Exception {\n        // Create new project\n        CommandStatus initStatus = main(\"init\",\n                \"-c\", config.toString(),\n                projectDir.toString());\n        assertThat(initStatus.errUtf8(), initStatus.code(), is(0));\n\n        copyResource(\"acceptance/basic.dig\", projectDir.resolve(\"basic.dig\"));\n\n        // Push the project\n        CommandStatus pushStatus = main(\"push\",\n                \"--project\", projectDir.toString(),\n                \"foobar\",\n                \"-c\", config.toString(),\n                \"-e\", server.endpoint());\n        assertThat(pushStatus.errUtf8(), pushStatus.code(), is(0));\n\n        // Start the workflow\n        Id attemptId;\n        {\n            CommandStatus startStatus = main(\"start\",\n                    \"-c\", config.toString(),\n                    \"-e\", server.endpoint(),\n                    \"foobar\", \"foobar\",\n                    \"--session\", \"now\");\n            assertThat(startStatus.code(), is(0));\n            attemptId = getAttemptId(startStatus);\n        }\n\n        // Wait for the attempt to complete\n        {\n            RestSessionAttempt attempt = null;\n            for (int i = 0; i < 30; i++) {\n                attempt = client.getSessionAttempt(attemptId);\n                if (attempt.getDone()) {\n                    break;\n                }\n                Thread.sleep(1000);\n            }\n            assertThat(attempt.getSuccess(), is(true));\n        }\n\n        final String logs = getAttemptLogs(client, attemptId);\n\n        final String regex = \"\\\\[\\\\d+:\\\\w+:\\\\d+:\\\\d+]\";\n        assertTrue(Pattern.compile(regex, Pattern.DOTALL).matcher(logs).find());\n    }\n}\n",
    "code_after_change": "package acceptance;\n\nimport io.digdag.client.DigdagClient;\nimport io.digdag.client.api.Id;\nimport io.digdag.client.api.RestSessionAttempt;\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.rules.TemporaryFolder;\nimport utils.CommandStatus;\nimport utils.TemporaryDigdagServer;\n\nimport javax.ws.rs.BadRequestException;\nimport javax.ws.rs.NotFoundException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.regex.Pattern;\n\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.hamcrest.Matchers.is;\nimport static org.junit.Assert.assertThrows;\nimport static org.junit.Assert.assertTrue;\nimport static utils.TestUtils.*;\n\n\npublic class LogIT {\n    @Rule\n    public TemporaryFolder folder = new TemporaryFolder();\n\n    @Rule\n    public TemporaryDigdagServer server = TemporaryDigdagServer.of();\n\n    private Path config;\n    private Path projectDir;\n    private DigdagClient client;\n\n    @Before\n    public void setUp()\n            throws Exception {\n        projectDir = folder.getRoot().toPath().resolve(\"foobar\");\n        Files.createDirectories(projectDir);\n        config = folder.newFile().toPath();\n        client = DigdagClient.builder()\n                .host(server.host())\n                .port(server.port())\n                .build();\n    }\n\n    @Test\n    public void verifyLogWithAttemptIdAndSessionId()\n            throws Exception {\n        // Create new project\n        CommandStatus initStatus = main(\"init\",\n                \"-c\", config.toString(),\n                projectDir.toString());\n        assertThat(initStatus.errUtf8(), initStatus.code(), is(0));\n\n        copyResource(\"acceptance/basic.dig\", projectDir.resolve(\"basic.dig\"));\n\n        // Push the project\n        CommandStatus pushStatus = main(\"push\",\n                \"--project\", projectDir.toString(),\n                \"foobar\",\n                \"-c\", config.toString(),\n                \"-e\", server.endpoint());\n        assertThat(pushStatus.errUtf8(), pushStatus.code(), is(0));\n\n        // Start the workflow\n        Id attemptId;\n        {\n            CommandStatus startStatus = main(\"start\",\n                    \"-c\", config.toString(),\n                    \"-e\", server.endpoint(),\n                    \"foobar\", \"foobar\",\n                    \"--session\", \"now\");\n            assertThat(startStatus.code(), is(0));\n            attemptId = getAttemptId(startStatus);\n        }\n\n        // Wait for the attempt to complete\n        {\n            RestSessionAttempt attempt = null;\n            for (int i = 0; i < 30; i++) {\n                attempt = client.getSessionAttempt(attemptId);\n                if (attempt.getDone()) {\n                    break;\n                }\n                Thread.sleep(1000);\n            }\n            assertThat(attempt.getSuccess(), is(true));\n        }\n\n        final String logs = getAttemptLogs(client, attemptId);\n\n        final String regex = \"\\\\[\\\\d+:\\\\w+:\\\\d+:\\\\d+]\";\n        assertTrue(Pattern.compile(regex, Pattern.DOTALL).matcher(logs).find());\n\n        assertThrows(NotFoundException.class, () -> client.getLogFile(attemptId, \"foo\"));\n        assertThrows(BadRequestException.class, () -> client.getLogFile(attemptId, \"/foo\"));\n    }\n}\n",
    "patch": "@@ -10,12 +10,15 @@\n import utils.CommandStatus;\n import utils.TemporaryDigdagServer;\n \n+import javax.ws.rs.BadRequestException;\n+import javax.ws.rs.NotFoundException;\n import java.nio.file.Files;\n import java.nio.file.Path;\n import java.util.regex.Pattern;\n \n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertThrows;\n import static org.junit.Assert.assertTrue;\n import static utils.TestUtils.*;\n \n@@ -91,5 +94,8 @@ public void verifyLogWithAttemptIdAndSessionId()\n \n         final String regex = \"\\\\[\\\\d+:\\\\w+:\\\\d+:\\\\d+]\";\n         assertTrue(Pattern.compile(regex, Pattern.DOTALL).matcher(logs).find());\n+\n+        assertThrows(NotFoundException.class, () -> client.getLogFile(attemptId, \"foo\"));\n+        assertThrows(BadRequestException.class, () -> client.getLogFile(attemptId, \"/foo\"));\n     }\n }",
    "function_modified_lines": {
      "added": [
        "import javax.ws.rs.BadRequestException;\n",
        "import javax.ws.rs.NotFoundException;\n",
        "import static org.junit.Assert.assertThrows;\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "Digdag is an open source tool that to build, run, schedule, and monitor complex pipelines of tasks across various platforms. Treasure Data's digdag workload automation system is susceptible to a path traversal vulnerability if it's configured to store log files locally. This issue may lead to information disclosure and has been addressed in release version 0.10.5.1. Users are advised to upgrade. There are no known workarounds for this vulnerability.",
    "id": 12951
  },
  {
    "cve_id": "CVE-2024-25125",
    "code_before_change": "package acceptance;\n\nimport io.digdag.client.DigdagClient;\nimport io.digdag.client.api.Id;\nimport io.digdag.client.api.RestSessionAttempt;\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.rules.TemporaryFolder;\nimport utils.CommandStatus;\nimport utils.TemporaryDigdagServer;\n\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.regex.Pattern;\n\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.hamcrest.Matchers.is;\nimport static org.junit.Assert.assertTrue;\nimport static utils.TestUtils.*;\n\n\npublic class LogIT {\n    @Rule\n    public TemporaryFolder folder = new TemporaryFolder();\n\n    @Rule\n    public TemporaryDigdagServer server = TemporaryDigdagServer.of();\n\n    private Path config;\n    private Path projectDir;\n    private DigdagClient client;\n\n    @Before\n    public void setUp()\n            throws Exception {\n        projectDir = folder.getRoot().toPath().resolve(\"foobar\");\n        Files.createDirectories(projectDir);\n        config = folder.newFile().toPath();\n        client = DigdagClient.builder()\n                .host(server.host())\n                .port(server.port())\n                .build();\n    }\n\n    @Test\n    public void verifyLogWithAttemptIdAndSessionId()\n            throws Exception {\n        // Create new project\n        CommandStatus initStatus = main(\"init\",\n                \"-c\", config.toString(),\n                projectDir.toString());\n        assertThat(initStatus.errUtf8(), initStatus.code(), is(0));\n\n        copyResource(\"acceptance/basic.dig\", projectDir.resolve(\"basic.dig\"));\n\n        // Push the project\n        CommandStatus pushStatus = main(\"push\",\n                \"--project\", projectDir.toString(),\n                \"foobar\",\n                \"-c\", config.toString(),\n                \"-e\", server.endpoint());\n        assertThat(pushStatus.errUtf8(), pushStatus.code(), is(0));\n\n        // Start the workflow\n        Id attemptId;\n        {\n            CommandStatus startStatus = main(\"start\",\n                    \"-c\", config.toString(),\n                    \"-e\", server.endpoint(),\n                    \"foobar\", \"foobar\",\n                    \"--session\", \"now\");\n            assertThat(startStatus.code(), is(0));\n            attemptId = getAttemptId(startStatus);\n        }\n\n        // Wait for the attempt to complete\n        {\n            RestSessionAttempt attempt = null;\n            for (int i = 0; i < 30; i++) {\n                attempt = client.getSessionAttempt(attemptId);\n                if (attempt.getDone()) {\n                    break;\n                }\n                Thread.sleep(1000);\n            }\n            assertThat(attempt.getSuccess(), is(true));\n        }\n\n        final String logs = getAttemptLogs(client, attemptId);\n\n        final String regex = \"\\\\[\\\\d+:\\\\w+:\\\\d+:\\\\d+]\";\n        assertTrue(Pattern.compile(regex, Pattern.DOTALL).matcher(logs).find());\n    }\n}\n",
    "code_after_change": "{\n        // Create new project\n        CommandStatus initStatus = main(\"init\",\n                \"-c\", config.toString(),\n                projectDir.toString());\n        assertThat(initStatus.errUtf8(), initStatus.code(), is(0));\n\n        copyResource(\"acceptance/basic.dig\", projectDir.resolve(\"basic.dig\"));\n\n        // Push the project\n        CommandStatus pushStatus = main(\"push\",\n                \"--project\", projectDir.toString(),\n                \"foobar\",\n                \"-c\", config.toString(),\n                \"-e\", server.endpoint());\n        assertThat(pushStatus.errUtf8(), pushStatus.code(), is(0));\n\n        // Start the workflow\n        Id attemptId;\n        {\n            CommandStatus startStatus = main(\"start\",\n                    \"-c\", config.toString(),\n                    \"-e\", server.endpoint(),\n                    \"foobar\", \"foobar\",\n                    \"--session\", \"now\");\n            assertThat(startStatus.code(), is(0));\n            attemptId = getAttemptId(startStatus);\n        }\n\n        // Wait for the attempt to complete\n        {\n            RestSessionAttempt attempt = null;\n            for (int i = 0; i < 30; i++) {\n                attempt = client.getSessionAttempt(attemptId);\n                if (attempt.getDone()) {\n                    break;\n                }\n                Thread.sleep(1000);\n            }\n            assertThat(attempt.getSuccess(), is(true));\n        }\n\n        final String logs = getAttemptLogs(client, attemptId);\n\n        final String regex = \"\\\\[\\\\d+:\\\\w+:\\\\d+:\\\\d+]\";\n        assertTrue(Pattern.compile(regex, Pattern.DOTALL).matcher(logs).find());\n\n        assertThrows(NotFoundException.class, () -> client.getLogFile(attemptId, \"foo\"));\n        assertThrows(BadRequestException.class, () -> client.getLogFile(attemptId, \"/foo\"));\n    }",
    "patch": "@@ -10,12 +10,15 @@\n import utils.CommandStatus;\n import utils.TemporaryDigdagServer;\n \n+import javax.ws.rs.BadRequestException;\n+import javax.ws.rs.NotFoundException;\n import java.nio.file.Files;\n import java.nio.file.Path;\n import java.util.regex.Pattern;\n \n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertThrows;\n import static org.junit.Assert.assertTrue;\n import static utils.TestUtils.*;\n \n@@ -91,5 +94,8 @@ public void verifyLogWithAttemptIdAndSessionId()\n \n         final String regex = \"\\\\[\\\\d+:\\\\w+:\\\\d+:\\\\d+]\";\n         assertTrue(Pattern.compile(regex, Pattern.DOTALL).matcher(logs).find());\n+\n+        assertThrows(NotFoundException.class, () -> client.getLogFile(attemptId, \"foo\"));\n+        assertThrows(BadRequestException.class, () -> client.getLogFile(attemptId, \"/foo\"));\n     }\n }",
    "function_modified_lines": {
      "added": [
        "\n",
        "        assertThrows(NotFoundException.class, () -> client.getLogFile(attemptId, \"foo\"));\n",
        "        assertThrows(BadRequestException.class, () -> client.getLogFile(attemptId, \"/foo\"));\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-22"
    ],
    "cve_description": "Digdag is an open source tool that to build, run, schedule, and monitor complex pipelines of tasks across various platforms. Treasure Data's digdag workload automation system is susceptible to a path traversal vulnerability if it's configured to store log files locally. This issue may lead to information disclosure and has been addressed in release version 0.10.5.1. Users are advised to upgrade. There are no known workarounds for this vulnerability.",
    "id": 12952
  }
]