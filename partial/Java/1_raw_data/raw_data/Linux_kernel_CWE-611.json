[
  {
    "cve_id": "CVE-2014-125087",
    "code_before_change": "import javax.xml.xpath.XPathFactory;\n\nimport net.iharder.Base64;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\n\n/**\n * Base abstract class for all XML Builder implementations.\n * Most of the work is done here.\n *\n * @author jmurty\n */\npublic abstract class BaseXMLBuilder {\n\n    /**\n     * A DOM Document that stores the underlying XML document operated on by\n     * BaseXMLBuilder instances. This document object belongs to the root node\n     * of a document, and is shared by this node with all other BaseXMLBuilder\n     * instances via the {@link #getDocument()} method.\n     * This instance variable must only be created once, by the root node for\n     * any given document.\n     */\n    private Document xmlDocument = null;\n\n    /**\n     * The underlying node represented by this builder node.\n     */\n    private Node xmlNode = null;\n\n    private static boolean isNamespaceAware = true;\n\n    /**\n     * Construct a new builder object that wraps the given XML document.\n     * This constructor is for internal use only.\n     *\n     * @param xmlDocument\n     * an XML document that the builder will manage and manipulate.\n     */\n    protected BaseXMLBuilder(Document xmlDocument) {\n        this.xmlDocument = xmlDocument;\n        this.xmlNode = xmlDocument.getDocumentElement();\n    }\n\n    /**\n     * Construct a new builder object that wraps the given XML document and node.\n     * This constructor is for internal use only.\n     *\n     * @param myNode\n     * the XML node that this builder node will wrap. This node may\n     * be part of the XML document, or it may be a new element that is to be\n     * added to the document.\n     * @param parentNode\n     * If not null, the given myElement will be appended as child node of the\n     * parentNode node.\n     */\n    protected BaseXMLBuilder(Node myNode, Node parentNode) {\n        this.xmlNode = myNode;\n        if (myNode instanceof Document) {\n            this.xmlDocument = (Document) myNode;\n        } else {\n            this.xmlDocument = myNode.getOwnerDocument();\n        }\n        if (parentNode != null) {\n            parentNode.appendChild(myNode);\n        }\n    }\n\n    /**\n     * Construct an XML Document with a default namespace with the given",
    "code_after_change": "import net.iharder.Base64;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\n\n/**\n * Base abstract class for all XML Builder implementations.\n * Most of the work is done here.\n *\n * @author jmurty\n */\npublic abstract class BaseXMLBuilder {\n\n    /**\n     * A DOM Document that stores the underlying XML document operated on by\n     * BaseXMLBuilder instances. This document object belongs to the root node\n     * of a document, and is shared by this node with all other BaseXMLBuilder\n     * instances via the {@link #getDocument()} method.\n     * This instance variable must only be created once, by the root node for\n     * any given document.\n     */\n    private Document xmlDocument = null;\n\n    /**\n     * The underlying node represented by this builder node.\n     */\n    private Node xmlNode = null;\n\n    private static boolean isNamespaceAware = true;\n\n    /**\n     * If true, the builder will raise an {@link XMLBuilderRuntimeException}\n     * if external general and parameter entities cannot be explicitly enabled\n     * or disabled.\n     */\n    public static boolean failIfExternalEntityParsingCannotBeConfigured = true;\n\n    /**\n     * Construct a new builder object that wraps the given XML document.\n     * This constructor is for internal use only.\n     *\n     * @param xmlDocument\n     * an XML document that the builder will manage and manipulate.\n     */\n    protected BaseXMLBuilder(Document xmlDocument) {\n        this.xmlDocument = xmlDocument;\n        this.xmlNode = xmlDocument.getDocumentElement();\n    }\n\n    /**\n     * Construct a new builder object that wraps the given XML document and node.\n     * This constructor is for internal use only.\n     *\n     * @param myNode\n     * the XML node that this builder node will wrap. This node may\n     * be part of the XML document, or it may be a new element that is to be\n     * added to the document.\n     * @param parentNode\n     * If not null, the given myElement will be appended as child node of the\n     * parentNode node.\n     */\n    protected BaseXMLBuilder(Node myNode, Node parentNode) {\n        this.xmlNode = myNode;\n        if (myNode instanceof Document) {\n            this.xmlDocument = (Document) myNode;\n        } else {\n            this.xmlDocument = myNode.getOwnerDocument();\n        }\n        if (parentNode != null) {\n            parentNode.appendChild(myNode);\n        }\n    }\n",
    "patch": "@@ -76,6 +76,13 @@ public abstract class BaseXMLBuilder {\n \n     private static boolean isNamespaceAware = true;\n \n+    /**\n+     * If true, the builder will raise an {@link XMLBuilderRuntimeException}\n+     * if external general and parameter entities cannot be explicitly enabled\n+     * or disabled.\n+     */\n+    public static boolean failIfExternalEntityParsingCannotBeConfigured = true;\n+\n     /**\n      * Construct a new builder object that wraps the given XML document.\n      * This constructor is for internal use only.\n@@ -112,6 +119,78 @@ protected BaseXMLBuilder(Node myNode, Node parentNode) {\n         }\n     }\n \n+    /**\n+     * Explicitly enable or disable the 'external-general-entities' and\n+     * 'external-parameter-entities' features of the underlying\n+     * DocumentBuilderFactory.\n+     *\n+     * TODO This is a naive approach that simply tries to apply all known\n+     * feature name/URL values in turn until one succeeds, or none do.\n+     *\n+     * @param factory\n+     * factory which will have external general and parameter entities enabled\n+     * or disabled.\n+     * @param enableExternalEntities\n+     * if true external entities will be explicitly enabled, otherwise they\n+     * will be explicitly disabled.\n+     */\n+    protected static void enableOrDisableExternalEntityParsing(\n+        DocumentBuilderFactory factory, boolean enableExternalEntities)\n+    {\n+        // Feature list drawn from:\n+        // https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Processing\n+\n+        /* Enable or disable external general entities */\n+        String[] externalGeneralEntitiesFeatures = {\n+            // General\n+            \"http://xml.org/sax/features/external-general-entities\",\n+            // Xerces 1\n+            \"http://xerces.apache.org/xerces-j/features.html#external-general-entities\",\n+            // Xerces 2\n+            \"http://xerces.apache.org/xerces2-j/features.html#external-general-entities\",\n+        };\n+        boolean success = false;\n+        for (String feature: externalGeneralEntitiesFeatures) {\n+            try {\n+                factory.setFeature(feature, enableExternalEntities);\n+                success = true;\n+                break;\n+            } catch (ParserConfigurationException e) {\n+            }\n+        }\n+        if (!success && failIfExternalEntityParsingCannotBeConfigured) {\n+            throw new XMLBuilderRuntimeException(\n+                new ParserConfigurationException(\n+                    \"Failed to set 'external-general-entities' feature to \"\n+                    + enableExternalEntities));\n+        }\n+\n+        /* Enable or disable external parameter entities */\n+        String[] externalParameterEntitiesFeatures = {\n+            // General\n+            \"http://xml.org/sax/features/external-parameter-entities\",\n+            // Xerces 1\n+            \"http://xerces.apache.org/xerces-j/features.html#external-parameter-entities\",\n+            // Xerces 2\n+            \"http://xerces.apache.org/xerces2-j/features.html#external-parameter-entities\",\n+        };\n+        success = false;\n+        for (String feature: externalParameterEntitiesFeatures) {\n+            try {\n+                factory.setFeature(feature, enableExternalEntities);\n+                success = true;\n+                break;\n+            } catch (ParserConfigurationException e) {\n+            }\n+        }\n+        if (!success && failIfExternalEntityParsingCannotBeConfigured) {\n+            throw new XMLBuilderRuntimeException(\n+                new ParserConfigurationException(\n+                    \"Failed to set 'external-parameter-entities' feature to \"\n+                    + enableExternalEntities));\n+        }\n+    }\n+\n     /**\n      * Construct an XML Document with a default namespace with the given\n      * root element.\n@@ -126,11 +205,13 @@ protected BaseXMLBuilder(Node myNode, Node parentNode) {\n      * @throws FactoryConfigurationError\n      * @throws ParserConfigurationException\n      */\n-    protected static Document createDocumentImpl(String name, String namespaceURI)\n+    protected static Document createDocumentImpl(\n+        String name, String namespaceURI, boolean enableExternalEntities)\n         throws ParserConfigurationException, FactoryConfigurationError\n     {\n         DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n         factory.setNamespaceAware(isNamespaceAware);\n+        enableOrDisableExternalEntityParsing(factory, enableExternalEntities);\n         DocumentBuilder builder = factory.newDocumentBuilder();\n         Document document = builder.newDocument();\n         Element rootElement = null;\n@@ -157,11 +238,13 @@ protected static Document createDocumentImpl(String name, String namespaceURI)\n      * @throws IOException\n      * @throws SAXException\n      */\n-    protected static Document parseDocumentImpl(InputSource inputSource)\n+    protected static Document parseDocumentImpl(\n+        InputSource inputSource, boolean enableExternalEntities)\n         throws ParserConfigurationException, SAXException, IOException\n     {\n         DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n         factory.setNamespaceAware(isNamespaceAware);\n+        enableOrDisableExternalEntityParsing(factory, enableExternalEntities);\n         DocumentBuilder builder = factory.newDocumentBuilder();\n         Document document = builder.parse(inputSource);\n         return document;",
    "function_modified_lines": {
      "added": [
        "    /**\n",
        "     * If true, the builder will raise an {@link XMLBuilderRuntimeException}\n",
        "     * if external general and parameter entities cannot be explicitly enabled\n",
        "     * or disabled.\n",
        "     */\n",
        "    public static boolean failIfExternalEntityParsingCannotBeConfigured = true;\n",
        "\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "A vulnerability was found in java-xmlbuilder up to 1.1. It has been rated as problematic. Affected by this issue is some unknown functionality. The manipulation leads to xml external entity reference. Upgrading to version 1.2 is able to address this issue. The name of the patch is e6fddca201790abab4f2c274341c0bb8835c3e73. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-221480.",
    "id": 11984
  },
  {
    "cve_id": "CVE-2015-7326",
    "code_before_change": "{\r\n            log.debug( \"processing content\" );\r\n            ByteArrayInputStream bin = new ByteArrayInputStream( arr );\r\n            XMLReader reader = XMLReaderFactory.createXMLReader();\r\n\t\t\treader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\r\n            PropPatchSaxHandler handler = new PropPatchSaxHandler();\r\n            reader.setContentHandler( handler );\r\n            reader.parse( new InputSource( bin ) );\r\n            log.debug( \"toset: \" + handler.getAttributesToSet().size());\r\n            return new PropPatchParseResult( handler.getAttributesToSet(), handler.getAttributesToRemove().keySet() );\r\n        }",
    "code_after_change": "{\r\n            log.debug( \"processing content\" );\r\n            ByteArrayInputStream bin = new ByteArrayInputStream( arr );\r\n            XMLReader reader = XMLReaderFactory.createXMLReader();\r\n\t\t\treader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\r\n\t\t\t// https://www.owasp.org/index.php/XML_External_Entity_%28XXE%29_Processing\r\n\t\t\treader.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\r\n\t\t\treader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\r\n\r\n            PropPatchSaxHandler handler = new PropPatchSaxHandler();\r\n            reader.setContentHandler( handler );\r\n            reader.parse( new InputSource( bin ) );\r\n            log.debug( \"toset: \" + handler.getAttributesToSet().size());\r\n            return new PropPatchParseResult( handler.getAttributesToSet(), handler.getAttributesToRemove().keySet() );\r\n        }",
    "patch": "@@ -69,6 +69,10 @@ private PropPatchParseResult parseContent( byte[] arr ) throws IOException, SAXE\n             ByteArrayInputStream bin = new ByteArrayInputStream( arr );\r\n             XMLReader reader = XMLReaderFactory.createXMLReader();\r\n \t\t\treader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\r\n+\t\t\t// https://www.owasp.org/index.php/XML_External_Entity_%28XXE%29_Processing\r\n+\t\t\treader.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\r\n+\t\t\treader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\r\n+\r\n             PropPatchSaxHandler handler = new PropPatchSaxHandler();\r\n             reader.setContentHandler( handler );\r\n             reader.parse( new InputSource( bin ) );\r",
    "function_modified_lines": {
      "added": [
        "\t\t\t// https://www.owasp.org/index.php/XML_External_Entity_%28XXE%29_Processing\r\n",
        "\t\t\treader.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\r\n",
        "\t\t\treader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\r\n",
        "\r\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "XML External Entity (XXE) vulnerability in Milton Webdav before 2.7.0.3.",
    "id": 12018
  },
  {
    "cve_id": "CVE-2020-10683",
    "code_before_change": "/**\n     * <p>\n     * makeElement\n     * </p>\n     * a helper method which navigates from the given Document or Element node\n     * to some Element using the path expression, creating any necessary\n     * elements along the way. For example the path <code>a/b/c</code> would\n     * get the first child &lt;a&gt; element, which would be created if it did\n     * not exist, then the next child &lt;b&gt; and so on until finally a\n     * &lt;c&gt; element is returned.\n     * \n     * @param source\n     *            is the Element or Document to start navigating from\n     * @param path\n     *            is a simple path expression, seperated by '/' which denotes\n     *            the path from the source to the resulting element such as\n     *            a/b/c\n     * \n     * @return the first Element on the given path which either already existed\n     *         on the path or were created by this method.\n     */",
    "code_after_change": "/**\n     * <p>\n     * makeElement\n     * </p>\n     * a helper method which navigates from the given Document or Element node\n     * to some Element using the path expression, creating any necessary\n     * elements along the way. For example the path <code>a/b/c</code> would\n     * get the first child &lt;a&gt; element, which would be created if it did\n     * not exist, then the next child &lt;b&gt; and so on until finally a\n     * &lt;c&gt; element is returned.\n     *\n     * @param source\n     *            is the Element or Document to start navigating from\n     * @param path\n     *            is a simple path expression, seperated by '/' which denotes\n     *            the path from the source to the resulting element such as\n     *            a/b/c\n     *\n     * @return the first Element on the given path which either already existed\n     *         on the path or were created by this method.\n     */",
    "patch": "@@ -107,12 +107,12 @@ public static QName createQName(String localName) {\n      * XPath <code>XPath</code> instance using the singleton {@link\n      * DocumentFactory}.\n      * </p>\n-     * \n+     *\n      * @param xpathExpression\n      *            is the XPath expression to create\n-     * \n+     *\n      * @return a new <code>XPath</code> instance\n-     * \n+     *\n      * @throws InvalidXPathException\n      *             if the XPath expression is invalid\n      */\n@@ -127,14 +127,14 @@ public static XPath createXPath(String xpathExpression)\n      * XPath <code>XPath</code> instance using the singleton {@link\n      * DocumentFactory}.\n      * </p>\n-     * \n+     *\n      * @param xpathExpression\n      *            is the XPath expression to create\n      * @param context\n      *            is the variable context to use when evaluating the XPath\n-     * \n+     *\n      * @return a new <code>XPath</code> instance\n-     * \n+     *\n      * @throws InvalidXPathException\n      *             if the XPath expression is invalid\n      */\n@@ -150,10 +150,10 @@ public static XPath createXPath(String xpathExpression,\n      * filter expressions occur within XPath expressions such as\n      * <code>self::node()[ filterExpression ]</code>\n      * </p>\n-     * \n+     *\n      * @param xpathFilterExpression\n      *            is the XPath filter expression to create\n-     * \n+     *\n      * @return a new <code>NodeFilter</code> instance\n      */\n     public static NodeFilter createXPathFilter(String xpathFilterExpression) {\n@@ -166,10 +166,10 @@ public static NodeFilter createXPathFilter(String xpathFilterExpression) {\n      * an XSLT style {@link Pattern}instance which can then be used in an XSLT\n      * processing model.\n      * </p>\n-     * \n+     *\n      * @param xpathPattern\n      *            is the XPath pattern expression to create\n-     * \n+     *\n      * @return a new <code>Pattern</code> instance\n      */\n     public static Pattern createPattern(String xpathPattern) {\n@@ -182,12 +182,12 @@ public static Pattern createPattern(String xpathPattern) {\n      * {@link List}of {@link Node}instances appending all the results together\n      * into a single list.\n      * </p>\n-     * \n+     *\n      * @param xpathFilterExpression\n      *            is the XPath filter expression to evaluate\n      * @param nodes\n      *            is the list of nodes on which to evalute the XPath\n-     * \n+     *\n      * @return the results of all the XPath evaluations as a single list\n      */\n     public static List<Node> selectNodes(String xpathFilterExpression, List<Node> nodes) {\n@@ -202,12 +202,12 @@ public static List<Node> selectNodes(String xpathFilterExpression, List<Node> no\n      * {@link List}of {@link Node}instances appending all the results together\n      * into a single list.\n      * </p>\n-     * \n+     *\n      * @param xpathFilterExpression\n      *            is the XPath filter expression to evaluate\n      * @param node\n      *            is the Node on which to evalute the XPath\n-     * \n+     *\n      * @return the results of all the XPath evaluations as a single list\n      */\n     public static List<Node> selectNodes(String xpathFilterExpression, Node node) {\n@@ -221,7 +221,7 @@ public static List<Node> selectNodes(String xpathFilterExpression, Node node) {\n      * <code>sort</code> sorts the given List of Nodes using an XPath\n      * expression as a {@link java.util.Comparator}.\n      * </p>\n-     * \n+     *\n      * @param list\n      *            is the list of Nodes to sort\n      * @param xpathExpression\n@@ -238,7 +238,7 @@ public static void sort(List<Node> list, String xpathExpression) {\n      * expression as a {@link java.util.Comparator}and optionally removing\n      * duplicates.\n      * </p>\n-     * \n+     *\n      * @param list\n      *            is the list of Nodes to sort\n      * @param expression\n@@ -259,24 +259,17 @@ public static void sort(List<Node> list, String expression, boolean distinct) {\n      * </p>\n      *\n      * Loading external DTD and entities is disabled (if it is possible) for security reasons.\n-     * \n+     *\n      * @param text\n      *            the XML text to be parsed\n-     * \n+     *\n      * @return a newly parsed Document\n-     * \n+     *\n      * @throws DocumentException\n      *             if the document could not be parsed\n      */\n     public static Document parseText(String text) throws DocumentException {\n-        SAXReader reader = new SAXReader();\n-        try {\n-            reader.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n-            reader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n-            reader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n-        } catch (SAXException e) {\n-            //Parse with external resources downloading allowed.\n-        }\n+        SAXReader reader = SAXReader.createDefault();\n \n         String encoding = getEncoding(text);\n \n@@ -330,14 +323,14 @@ private static String getEncoding(String text) {\n      * get the first child &lt;a&gt; element, which would be created if it did\n      * not exist, then the next child &lt;b&gt; and so on until finally a\n      * &lt;c&gt; element is returned.\n-     * \n+     *\n      * @param source\n      *            is the Element or Document to start navigating from\n      * @param path\n      *            is a simple path expression, seperated by '/' which denotes\n      *            the path from the source to the resulting element such as\n      *            a/b/c\n-     * \n+     *\n      * @return the first Element on the given path which either already existed\n      *         on the path or were created by this method.\n      */\n@@ -386,24 +379,24 @@ public static Element makeElement(Branch source, String path) {\n  * Redistribution and use of this software and associated documentation\n  * (\"Software\"), with or without modification, are permitted provided that the\n  * following conditions are met:\n- * \n+ *\n  * 1. Redistributions of source code must retain copyright statements and\n  * notices. Redistributions must also contain a copy of this document.\n- * \n+ *\n  * 2. Redistributions in binary form must reproduce the above copyright notice,\n  * this list of conditions and the following disclaimer in the documentation\n  * and/or other materials provided with the distribution.\n- * \n+ *\n  * 3. The name \"DOM4J\" must not be used to endorse or promote products derived\n  * from this Software without prior written permission of MetaStuff, Ltd. For\n  * written permission, please contact dom4j-info@metastuff.com.\n- * \n+ *\n  * 4. Products derived from this Software may not be called \"DOM4J\" nor may\n  * \"DOM4J\" appear in their names without prior written permission of MetaStuff,\n  * Ltd. DOM4J is a registered trademark of MetaStuff, Ltd.\n- * \n+ *\n  * 5. Due credit should be given to the DOM4J Project - http://www.dom4j.org\n- * \n+ *\n  * THIS SOFTWARE IS PROVIDED BY METASTUFF, LTD. AND CONTRIBUTORS ``AS IS'' AND\n  * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n@@ -415,6 +408,6 @@ public static Element makeElement(Branch source, String path) {\n  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n  * POSSIBILITY OF SUCH DAMAGE.\n- * \n+ *\n  * Copyright 2001-2005 (C) MetaStuff, Ltd. All Rights Reserved.\n  */",
    "function_modified_lines": {
      "added": [
        "     *\n",
        "     *\n"
      ],
      "deleted": [
        "     * \n",
        "     * \n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "dom4j before 2.0.3 and 2.1.x before 2.1.3 allows external DTDs and External Entities by default, which might enable XXE attacks. However, there is popular external documentation from OWASP showing how to enable the safe, non-default behavior in any application that uses dom4j.",
    "id": 12084
  },
  {
    "cve_id": "CVE-2020-10683",
    "code_before_change": "/*\n * Redistribution and use of this software and associated documentation\n * (\"Software\"), with or without modification, are permitted provided that the\n * following conditions are met:\n * \n * 1. Redistributions of source code must retain copyright statements and\n * notices. Redistributions must also contain a copy of this document.\n * \n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n * \n * 3. The name \"DOM4J\" must not be used to endorse or promote products derived\n * from this Software without prior written permission of MetaStuff, Ltd. For\n * written permission, please contact dom4j-info@metastuff.com.\n * \n * 4. Products derived from this Software may not be called \"DOM4J\" nor may\n * \"DOM4J\" appear in their names without prior written permission of MetaStuff,\n * Ltd. DOM4J is a registered trademark of MetaStuff, Ltd.\n * \n * 5. Due credit should be given to the DOM4J Project - http://www.dom4j.org\n * \n * THIS SOFTWARE IS PROVIDED BY METASTUFF, LTD. AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL METASTUFF, LTD. OR ITS CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n * \n * Copyright 2001-2005 (C) MetaStuff, Ltd. All Rights Reserved.\n */",
    "code_after_change": "/*\n * Redistribution and use of this software and associated documentation\n * (\"Software\"), with or without modification, are permitted provided that the\n * following conditions are met:\n *\n * 1. Redistributions of source code must retain copyright statements and\n * notices. Redistributions must also contain a copy of this document.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * 3. The name \"DOM4J\" must not be used to endorse or promote products derived\n * from this Software without prior written permission of MetaStuff, Ltd. For\n * written permission, please contact dom4j-info@metastuff.com.\n *\n * 4. Products derived from this Software may not be called \"DOM4J\" nor may\n * \"DOM4J\" appear in their names without prior written permission of MetaStuff,\n * Ltd. DOM4J is a registered trademark of MetaStuff, Ltd.\n *\n * 5. Due credit should be given to the DOM4J Project - http://www.dom4j.org\n *\n * THIS SOFTWARE IS PROVIDED BY METASTUFF, LTD. AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL METASTUFF, LTD. OR ITS CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *\n * Copyright 2001-2005 (C) MetaStuff, Ltd. All Rights Reserved.\n */",
    "patch": "@@ -107,12 +107,12 @@ public static QName createQName(String localName) {\n      * XPath <code>XPath</code> instance using the singleton {@link\n      * DocumentFactory}.\n      * </p>\n-     * \n+     *\n      * @param xpathExpression\n      *            is the XPath expression to create\n-     * \n+     *\n      * @return a new <code>XPath</code> instance\n-     * \n+     *\n      * @throws InvalidXPathException\n      *             if the XPath expression is invalid\n      */\n@@ -127,14 +127,14 @@ public static XPath createXPath(String xpathExpression)\n      * XPath <code>XPath</code> instance using the singleton {@link\n      * DocumentFactory}.\n      * </p>\n-     * \n+     *\n      * @param xpathExpression\n      *            is the XPath expression to create\n      * @param context\n      *            is the variable context to use when evaluating the XPath\n-     * \n+     *\n      * @return a new <code>XPath</code> instance\n-     * \n+     *\n      * @throws InvalidXPathException\n      *             if the XPath expression is invalid\n      */\n@@ -150,10 +150,10 @@ public static XPath createXPath(String xpathExpression,\n      * filter expressions occur within XPath expressions such as\n      * <code>self::node()[ filterExpression ]</code>\n      * </p>\n-     * \n+     *\n      * @param xpathFilterExpression\n      *            is the XPath filter expression to create\n-     * \n+     *\n      * @return a new <code>NodeFilter</code> instance\n      */\n     public static NodeFilter createXPathFilter(String xpathFilterExpression) {\n@@ -166,10 +166,10 @@ public static NodeFilter createXPathFilter(String xpathFilterExpression) {\n      * an XSLT style {@link Pattern}instance which can then be used in an XSLT\n      * processing model.\n      * </p>\n-     * \n+     *\n      * @param xpathPattern\n      *            is the XPath pattern expression to create\n-     * \n+     *\n      * @return a new <code>Pattern</code> instance\n      */\n     public static Pattern createPattern(String xpathPattern) {\n@@ -182,12 +182,12 @@ public static Pattern createPattern(String xpathPattern) {\n      * {@link List}of {@link Node}instances appending all the results together\n      * into a single list.\n      * </p>\n-     * \n+     *\n      * @param xpathFilterExpression\n      *            is the XPath filter expression to evaluate\n      * @param nodes\n      *            is the list of nodes on which to evalute the XPath\n-     * \n+     *\n      * @return the results of all the XPath evaluations as a single list\n      */\n     public static List<Node> selectNodes(String xpathFilterExpression, List<Node> nodes) {\n@@ -202,12 +202,12 @@ public static List<Node> selectNodes(String xpathFilterExpression, List<Node> no\n      * {@link List}of {@link Node}instances appending all the results together\n      * into a single list.\n      * </p>\n-     * \n+     *\n      * @param xpathFilterExpression\n      *            is the XPath filter expression to evaluate\n      * @param node\n      *            is the Node on which to evalute the XPath\n-     * \n+     *\n      * @return the results of all the XPath evaluations as a single list\n      */\n     public static List<Node> selectNodes(String xpathFilterExpression, Node node) {\n@@ -221,7 +221,7 @@ public static List<Node> selectNodes(String xpathFilterExpression, Node node) {\n      * <code>sort</code> sorts the given List of Nodes using an XPath\n      * expression as a {@link java.util.Comparator}.\n      * </p>\n-     * \n+     *\n      * @param list\n      *            is the list of Nodes to sort\n      * @param xpathExpression\n@@ -238,7 +238,7 @@ public static void sort(List<Node> list, String xpathExpression) {\n      * expression as a {@link java.util.Comparator}and optionally removing\n      * duplicates.\n      * </p>\n-     * \n+     *\n      * @param list\n      *            is the list of Nodes to sort\n      * @param expression\n@@ -259,24 +259,17 @@ public static void sort(List<Node> list, String expression, boolean distinct) {\n      * </p>\n      *\n      * Loading external DTD and entities is disabled (if it is possible) for security reasons.\n-     * \n+     *\n      * @param text\n      *            the XML text to be parsed\n-     * \n+     *\n      * @return a newly parsed Document\n-     * \n+     *\n      * @throws DocumentException\n      *             if the document could not be parsed\n      */\n     public static Document parseText(String text) throws DocumentException {\n-        SAXReader reader = new SAXReader();\n-        try {\n-            reader.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n-            reader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n-            reader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n-        } catch (SAXException e) {\n-            //Parse with external resources downloading allowed.\n-        }\n+        SAXReader reader = SAXReader.createDefault();\n \n         String encoding = getEncoding(text);\n \n@@ -330,14 +323,14 @@ private static String getEncoding(String text) {\n      * get the first child &lt;a&gt; element, which would be created if it did\n      * not exist, then the next child &lt;b&gt; and so on until finally a\n      * &lt;c&gt; element is returned.\n-     * \n+     *\n      * @param source\n      *            is the Element or Document to start navigating from\n      * @param path\n      *            is a simple path expression, seperated by '/' which denotes\n      *            the path from the source to the resulting element such as\n      *            a/b/c\n-     * \n+     *\n      * @return the first Element on the given path which either already existed\n      *         on the path or were created by this method.\n      */\n@@ -386,24 +379,24 @@ public static Element makeElement(Branch source, String path) {\n  * Redistribution and use of this software and associated documentation\n  * (\"Software\"), with or without modification, are permitted provided that the\n  * following conditions are met:\n- * \n+ *\n  * 1. Redistributions of source code must retain copyright statements and\n  * notices. Redistributions must also contain a copy of this document.\n- * \n+ *\n  * 2. Redistributions in binary form must reproduce the above copyright notice,\n  * this list of conditions and the following disclaimer in the documentation\n  * and/or other materials provided with the distribution.\n- * \n+ *\n  * 3. The name \"DOM4J\" must not be used to endorse or promote products derived\n  * from this Software without prior written permission of MetaStuff, Ltd. For\n  * written permission, please contact dom4j-info@metastuff.com.\n- * \n+ *\n  * 4. Products derived from this Software may not be called \"DOM4J\" nor may\n  * \"DOM4J\" appear in their names without prior written permission of MetaStuff,\n  * Ltd. DOM4J is a registered trademark of MetaStuff, Ltd.\n- * \n+ *\n  * 5. Due credit should be given to the DOM4J Project - http://www.dom4j.org\n- * \n+ *\n  * THIS SOFTWARE IS PROVIDED BY METASTUFF, LTD. AND CONTRIBUTORS ``AS IS'' AND\n  * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n@@ -415,6 +408,6 @@ public static Element makeElement(Branch source, String path) {\n  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n  * POSSIBILITY OF SUCH DAMAGE.\n- * \n+ *\n  * Copyright 2001-2005 (C) MetaStuff, Ltd. All Rights Reserved.\n  */",
    "function_modified_lines": {
      "added": [
        " *\n",
        " *\n",
        " *\n",
        " *\n",
        " *\n",
        " *\n",
        " *\n"
      ],
      "deleted": [
        " * \n",
        " * \n",
        " * \n",
        " * \n",
        " * \n",
        " * \n",
        " * \n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "dom4j before 2.0.3 and 2.1.x before 2.1.3 allows external DTDs and External Entities by default, which might enable XXE attacks. However, there is popular external documentation from OWASP showing how to enable the safe, non-default behavior in any application that uses dom4j.",
    "id": 12085
  },
  {
    "cve_id": "CVE-2020-10683",
    "code_before_change": "/**\n     * Creats a default XMLReader via the org.xml.sax.driver system property or\n     * JAXP if the system property is not set.\n     * \n     * @param validating\n     *            DOCUMENT ME!\n     * \n     * @return DOCUMENT ME!\n     * \n     * @throws SAXException\n     *             DOCUMENT ME!\n     */",
    "code_after_change": "/**\n     * Creats a default XMLReader via the org.xml.sax.driver system property or\n     * JAXP if the system property is not set.\n     *\n     * This method internally calls {@link SAXParserFactory}{@code .newInstance().newSAXParser().getXMLReader()} or {@link XMLReaderFactory#createXMLReader()}.\n     * Be sure to configure returned reader if the default configuration does not suit you. Consider setting the following properties:\n     *\n     * <pre>\n     * reader.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n     * reader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n     * reader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n     * </pre>\n     *\n     * @param validating\n     *            DOCUMENT ME!\n     *\n     * @return DOCUMENT ME!\n     *\n     * @throws SAXException\n     *             DOCUMENT ME!\n     */",
    "patch": "@@ -13,12 +13,14 @@\n import org.xml.sax.XMLReader;\n import org.xml.sax.helpers.XMLReaderFactory;\n \n+import javax.xml.parsers.SAXParserFactory;\n+\n /**\n  * <p>\n  * <code>SAXHelper</code> contains some helper methods for working with SAX\n  * and XMLReader objects.\n  * </p>\n- * \n+ *\n  * @author <a href=\"mailto:james.strachan@metastuff.com\">James Strachan </a>\n  * @version $Revision: 1.18 $\n  */\n@@ -61,12 +63,21 @@ public static boolean setParserFeature(XMLReader reader,\n     /**\n      * Creats a default XMLReader via the org.xml.sax.driver system property or\n      * JAXP if the system property is not set.\n-     * \n+     *\n+     * This method internally calls {@link SAXParserFactory}{@code .newInstance().newSAXParser().getXMLReader()} or {@link XMLReaderFactory#createXMLReader()}.\n+     * Be sure to configure returned reader if the default configuration does not suit you. Consider setting the following properties:\n+     *\n+     * <pre>\n+     * reader.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n+     * reader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n+     * reader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n+     * </pre>\n+     *\n      * @param validating\n      *            DOCUMENT ME!\n-     * \n+     *\n      * @return DOCUMENT ME!\n-     * \n+     *\n      * @throws SAXException\n      *             DOCUMENT ME!\n      */\n@@ -125,12 +136,12 @@ public static XMLReader createXMLReader(boolean validating)\n      * This method attempts to use JAXP to locate the SAX2 XMLReader\n      * implementation. This method uses reflection to avoid being dependent\n      * directly on the JAXP classes.\n-     * \n+     *\n      * @param validating\n      *            DOCUMENT ME!\n      * @param namespaceAware\n      *            DOCUMENT ME!\n-     * \n+     *\n      * @return DOCUMENT ME!\n      */\n     protected static XMLReader createXMLReaderViaJAXP(boolean validating,\n@@ -176,24 +187,24 @@ protected static boolean isVerboseErrorReporting() {\n  * Redistribution and use of this software and associated documentation\n  * (\"Software\"), with or without modification, are permitted provided that the\n  * following conditions are met:\n- * \n+ *\n  * 1. Redistributions of source code must retain copyright statements and\n  * notices. Redistributions must also contain a copy of this document.\n- * \n+ *\n  * 2. Redistributions in binary form must reproduce the above copyright notice,\n  * this list of conditions and the following disclaimer in the documentation\n  * and/or other materials provided with the distribution.\n- * \n+ *\n  * 3. The name \"DOM4J\" must not be used to endorse or promote products derived\n  * from this Software without prior written permission of MetaStuff, Ltd. For\n  * written permission, please contact dom4j-info@metastuff.com.\n- * \n+ *\n  * 4. Products derived from this Software may not be called \"DOM4J\" nor may\n  * \"DOM4J\" appear in their names without prior written permission of MetaStuff,\n  * Ltd. DOM4J is a registered trademark of MetaStuff, Ltd.\n- * \n+ *\n  * 5. Due credit should be given to the DOM4J Project - http://www.dom4j.org\n- * \n+ *\n  * THIS SOFTWARE IS PROVIDED BY METASTUFF, LTD. AND CONTRIBUTORS ``AS IS'' AND\n  * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n@@ -205,6 +216,6 @@ protected static boolean isVerboseErrorReporting() {\n  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n  * POSSIBILITY OF SUCH DAMAGE.\n- * \n+ *\n  * Copyright 2001-2005 (C) MetaStuff, Ltd. All Rights Reserved.\n  */",
    "function_modified_lines": {
      "added": [
        "     *\n",
        "     * This method internally calls {@link SAXParserFactory}{@code .newInstance().newSAXParser().getXMLReader()} or {@link XMLReaderFactory#createXMLReader()}.\n",
        "     * Be sure to configure returned reader if the default configuration does not suit you. Consider setting the following properties:\n",
        "     *\n",
        "     * <pre>\n",
        "     * reader.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n",
        "     * reader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n",
        "     * reader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n",
        "     * </pre>\n",
        "     *\n",
        "     *\n",
        "     *\n"
      ],
      "deleted": [
        "     * \n",
        "     * \n",
        "     * \n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "dom4j before 2.0.3 and 2.1.x before 2.1.3 allows external DTDs and External Entities by default, which might enable XXE attacks. However, there is popular external documentation from OWASP showing how to enable the safe, non-default behavior in any application that uses dom4j.",
    "id": 12086
  },
  {
    "cve_id": "CVE-2020-10683",
    "code_before_change": "/**\n     * This method attempts to use JAXP to locate the SAX2 XMLReader\n     * implementation. This method uses reflection to avoid being dependent\n     * directly on the JAXP classes.\n     * \n     * @param validating\n     *            DOCUMENT ME!\n     * @param namespaceAware\n     *            DOCUMENT ME!\n     * \n     * @return DOCUMENT ME!\n     */",
    "code_after_change": "/**\n     * This method attempts to use JAXP to locate the SAX2 XMLReader\n     * implementation. This method uses reflection to avoid being dependent\n     * directly on the JAXP classes.\n     *\n     * @param validating\n     *            DOCUMENT ME!\n     * @param namespaceAware\n     *            DOCUMENT ME!\n     *\n     * @return DOCUMENT ME!\n     */",
    "patch": "@@ -13,12 +13,14 @@\n import org.xml.sax.XMLReader;\n import org.xml.sax.helpers.XMLReaderFactory;\n \n+import javax.xml.parsers.SAXParserFactory;\n+\n /**\n  * <p>\n  * <code>SAXHelper</code> contains some helper methods for working with SAX\n  * and XMLReader objects.\n  * </p>\n- * \n+ *\n  * @author <a href=\"mailto:james.strachan@metastuff.com\">James Strachan </a>\n  * @version $Revision: 1.18 $\n  */\n@@ -61,12 +63,21 @@ public static boolean setParserFeature(XMLReader reader,\n     /**\n      * Creats a default XMLReader via the org.xml.sax.driver system property or\n      * JAXP if the system property is not set.\n-     * \n+     *\n+     * This method internally calls {@link SAXParserFactory}{@code .newInstance().newSAXParser().getXMLReader()} or {@link XMLReaderFactory#createXMLReader()}.\n+     * Be sure to configure returned reader if the default configuration does not suit you. Consider setting the following properties:\n+     *\n+     * <pre>\n+     * reader.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n+     * reader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n+     * reader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n+     * </pre>\n+     *\n      * @param validating\n      *            DOCUMENT ME!\n-     * \n+     *\n      * @return DOCUMENT ME!\n-     * \n+     *\n      * @throws SAXException\n      *             DOCUMENT ME!\n      */\n@@ -125,12 +136,12 @@ public static XMLReader createXMLReader(boolean validating)\n      * This method attempts to use JAXP to locate the SAX2 XMLReader\n      * implementation. This method uses reflection to avoid being dependent\n      * directly on the JAXP classes.\n-     * \n+     *\n      * @param validating\n      *            DOCUMENT ME!\n      * @param namespaceAware\n      *            DOCUMENT ME!\n-     * \n+     *\n      * @return DOCUMENT ME!\n      */\n     protected static XMLReader createXMLReaderViaJAXP(boolean validating,\n@@ -176,24 +187,24 @@ protected static boolean isVerboseErrorReporting() {\n  * Redistribution and use of this software and associated documentation\n  * (\"Software\"), with or without modification, are permitted provided that the\n  * following conditions are met:\n- * \n+ *\n  * 1. Redistributions of source code must retain copyright statements and\n  * notices. Redistributions must also contain a copy of this document.\n- * \n+ *\n  * 2. Redistributions in binary form must reproduce the above copyright notice,\n  * this list of conditions and the following disclaimer in the documentation\n  * and/or other materials provided with the distribution.\n- * \n+ *\n  * 3. The name \"DOM4J\" must not be used to endorse or promote products derived\n  * from this Software without prior written permission of MetaStuff, Ltd. For\n  * written permission, please contact dom4j-info@metastuff.com.\n- * \n+ *\n  * 4. Products derived from this Software may not be called \"DOM4J\" nor may\n  * \"DOM4J\" appear in their names without prior written permission of MetaStuff,\n  * Ltd. DOM4J is a registered trademark of MetaStuff, Ltd.\n- * \n+ *\n  * 5. Due credit should be given to the DOM4J Project - http://www.dom4j.org\n- * \n+ *\n  * THIS SOFTWARE IS PROVIDED BY METASTUFF, LTD. AND CONTRIBUTORS ``AS IS'' AND\n  * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n@@ -205,6 +216,6 @@ protected static boolean isVerboseErrorReporting() {\n  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n  * POSSIBILITY OF SUCH DAMAGE.\n- * \n+ *\n  * Copyright 2001-2005 (C) MetaStuff, Ltd. All Rights Reserved.\n  */",
    "function_modified_lines": {
      "added": [
        "     *\n",
        "     *\n"
      ],
      "deleted": [
        "     * \n",
        "     * \n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "dom4j before 2.0.3 and 2.1.x before 2.1.3 allows external DTDs and External Entities by default, which might enable XXE attacks. However, there is popular external documentation from OWASP showing how to enable the safe, non-default behavior in any application that uses dom4j.",
    "id": 12087
  },
  {
    "cve_id": "CVE-2020-10683",
    "code_before_change": "/*\n * Redistribution and use of this software and associated documentation\n * (\"Software\"), with or without modification, are permitted provided that the\n * following conditions are met:\n * \n * 1. Redistributions of source code must retain copyright statements and\n * notices. Redistributions must also contain a copy of this document.\n * \n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n * \n * 3. The name \"DOM4J\" must not be used to endorse or promote products derived\n * from this Software without prior written permission of MetaStuff, Ltd. For\n * written permission, please contact dom4j-info@metastuff.com.\n * \n * 4. Products derived from this Software may not be called \"DOM4J\" nor may\n * \"DOM4J\" appear in their names without prior written permission of MetaStuff,\n * Ltd. DOM4J is a registered trademark of MetaStuff, Ltd.\n * \n * 5. Due credit should be given to the DOM4J Project - http://www.dom4j.org\n * \n * THIS SOFTWARE IS PROVIDED BY METASTUFF, LTD. AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL METASTUFF, LTD. OR ITS CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n * \n * Copyright 2001-2005 (C) MetaStuff, Ltd. All Rights Reserved.\n */",
    "code_after_change": "/*\n * Redistribution and use of this software and associated documentation\n * (\"Software\"), with or without modification, are permitted provided that the\n * following conditions are met:\n *\n * 1. Redistributions of source code must retain copyright statements and\n * notices. Redistributions must also contain a copy of this document.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * 3. The name \"DOM4J\" must not be used to endorse or promote products derived\n * from this Software without prior written permission of MetaStuff, Ltd. For\n * written permission, please contact dom4j-info@metastuff.com.\n *\n * 4. Products derived from this Software may not be called \"DOM4J\" nor may\n * \"DOM4J\" appear in their names without prior written permission of MetaStuff,\n * Ltd. DOM4J is a registered trademark of MetaStuff, Ltd.\n *\n * 5. Due credit should be given to the DOM4J Project - http://www.dom4j.org\n *\n * THIS SOFTWARE IS PROVIDED BY METASTUFF, LTD. AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL METASTUFF, LTD. OR ITS CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *\n * Copyright 2001-2005 (C) MetaStuff, Ltd. All Rights Reserved.\n */",
    "patch": "@@ -13,12 +13,14 @@\n import org.xml.sax.XMLReader;\n import org.xml.sax.helpers.XMLReaderFactory;\n \n+import javax.xml.parsers.SAXParserFactory;\n+\n /**\n  * <p>\n  * <code>SAXHelper</code> contains some helper methods for working with SAX\n  * and XMLReader objects.\n  * </p>\n- * \n+ *\n  * @author <a href=\"mailto:james.strachan@metastuff.com\">James Strachan </a>\n  * @version $Revision: 1.18 $\n  */\n@@ -61,12 +63,21 @@ public static boolean setParserFeature(XMLReader reader,\n     /**\n      * Creats a default XMLReader via the org.xml.sax.driver system property or\n      * JAXP if the system property is not set.\n-     * \n+     *\n+     * This method internally calls {@link SAXParserFactory}{@code .newInstance().newSAXParser().getXMLReader()} or {@link XMLReaderFactory#createXMLReader()}.\n+     * Be sure to configure returned reader if the default configuration does not suit you. Consider setting the following properties:\n+     *\n+     * <pre>\n+     * reader.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n+     * reader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n+     * reader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n+     * </pre>\n+     *\n      * @param validating\n      *            DOCUMENT ME!\n-     * \n+     *\n      * @return DOCUMENT ME!\n-     * \n+     *\n      * @throws SAXException\n      *             DOCUMENT ME!\n      */\n@@ -125,12 +136,12 @@ public static XMLReader createXMLReader(boolean validating)\n      * This method attempts to use JAXP to locate the SAX2 XMLReader\n      * implementation. This method uses reflection to avoid being dependent\n      * directly on the JAXP classes.\n-     * \n+     *\n      * @param validating\n      *            DOCUMENT ME!\n      * @param namespaceAware\n      *            DOCUMENT ME!\n-     * \n+     *\n      * @return DOCUMENT ME!\n      */\n     protected static XMLReader createXMLReaderViaJAXP(boolean validating,\n@@ -176,24 +187,24 @@ protected static boolean isVerboseErrorReporting() {\n  * Redistribution and use of this software and associated documentation\n  * (\"Software\"), with or without modification, are permitted provided that the\n  * following conditions are met:\n- * \n+ *\n  * 1. Redistributions of source code must retain copyright statements and\n  * notices. Redistributions must also contain a copy of this document.\n- * \n+ *\n  * 2. Redistributions in binary form must reproduce the above copyright notice,\n  * this list of conditions and the following disclaimer in the documentation\n  * and/or other materials provided with the distribution.\n- * \n+ *\n  * 3. The name \"DOM4J\" must not be used to endorse or promote products derived\n  * from this Software without prior written permission of MetaStuff, Ltd. For\n  * written permission, please contact dom4j-info@metastuff.com.\n- * \n+ *\n  * 4. Products derived from this Software may not be called \"DOM4J\" nor may\n  * \"DOM4J\" appear in their names without prior written permission of MetaStuff,\n  * Ltd. DOM4J is a registered trademark of MetaStuff, Ltd.\n- * \n+ *\n  * 5. Due credit should be given to the DOM4J Project - http://www.dom4j.org\n- * \n+ *\n  * THIS SOFTWARE IS PROVIDED BY METASTUFF, LTD. AND CONTRIBUTORS ``AS IS'' AND\n  * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n@@ -205,6 +216,6 @@ protected static boolean isVerboseErrorReporting() {\n  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n  * POSSIBILITY OF SUCH DAMAGE.\n- * \n+ *\n  * Copyright 2001-2005 (C) MetaStuff, Ltd. All Rights Reserved.\n  */",
    "function_modified_lines": {
      "added": [
        " *\n",
        " *\n",
        " *\n",
        " *\n",
        " *\n",
        " *\n",
        " *\n"
      ],
      "deleted": [
        " * \n",
        " * \n",
        " * \n",
        " * \n",
        " * \n",
        " * \n",
        " * \n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "dom4j before 2.0.3 and 2.1.x before 2.1.3 allows external DTDs and External Entities by default, which might enable XXE attacks. However, there is popular external documentation from OWASP showing how to enable the safe, non-default behavior in any application that uses dom4j.",
    "id": 12088
  },
  {
    "cve_id": "CVE-2020-10683",
    "code_before_change": "/**\n * <code>SAXReader</code> creates a DOM4J tree from SAX parsing events.\n *\n * The actual SAX parser that is used by this class is configurable so you can\n * use your favourite SAX parser if you wish. DOM4J comes configured with its\n * own SAX parser so you do not need to worry about configuring the SAX parser.\n *\n * To explicitly configure the SAX parser that is used via Java code you can use\n * a constructor or use the {@link #setXMLReader(XMLReader)}or {@link\n * #setXMLReaderClassName(String)} methods.\n *\n * If the parser is not specified explicitly then the standard SAX policy of\n * using the <code>org.xml.sax.driver</code> system property is used to\n * determine the implementation class of {@link XMLReader}.\n *\n * If the <code>org.xml.sax.driver</code> system property is not defined then\n * JAXP is used via reflection (so that DOM4J is not explicitly dependent on the\n * JAXP classes) to load the JAXP configured SAXParser. If there is any error\n * creating a JAXP SAXParser an informational message is output and then the\n * default (Aelfred) SAX parser is used instead.\n *\n * If you are trying to use JAXP to explicitly set your SAX parser and are\n * experiencing problems, you can turn on verbose error reporting by defining\n * the system property <code>org.dom4j.verbose</code> to be \"true\" which will\n * output a more detailed description of why JAXP could not find a SAX parser\n *\n * For more information on JAXP please go to <a\n * href=\"http://java.sun.com/xml/\">Sun's Java &amp; XML site </a>\n *\n * @author <a href=\"mailto:james.strachan@metastuff.com\">James Strachan </a>\n * @version $Revision: 1.58 $\n */",
    "code_after_change": "/*\n * Copyright 2001-2005 (C) MetaStuff, Ltd. All Rights Reserved.\n *\n * This software is open source.\n * See the bottom of this file for the licence.\n */\n\npackage org.dom4j.io;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.InputStream;\nimport java.io.Reader;\nimport java.io.Serializable;\nimport java.net.URL;\n\nimport org.dom4j.Document;\nimport org.dom4j.DocumentException;\nimport org.dom4j.DocumentFactory;\nimport org.dom4j.ElementHandler;\n\nimport org.xml.sax.EntityResolver;\nimport org.xml.sax.ErrorHandler;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.SAXParseException;\nimport org.xml.sax.XMLFilter;\nimport org.xml.sax.XMLReader;\nimport org.xml.sax.helpers.DefaultHandler;\nimport org.xml.sax.helpers.XMLReaderFactory;\n\nimport javax.xml.parsers.SAXParserFactory;\n\n/**\n * <code>SAXReader</code> creates a DOM4J tree from SAX parsing events.\n * <p>\n * The actual SAX parser that is used by this class is configurable so you can\n * use your favourite SAX parser if you wish. DOM4J comes configured with its\n * own SAX parser so you do not need to worry about configuring the SAX parser.\n * <p>\n * To explicitly configure the SAX parser that is used via Java code you can use\n * a constructor or use the {@link #setXMLReader(XMLReader)}or {@link\n * #setXMLReaderClassName(String)} methods.\n * <p>\n * If the parser is not specified explicitly then the standard SAX policy of\n * using the <code>org.xml.sax.driver</code> system property is used to\n * determine the implementation class of {@link XMLReader}.\n * <p>\n * If the <code>org.xml.sax.driver</code> system property is not defined then\n * JAXP is used via reflection (so that DOM4J is not explicitly dependent on the\n * JAXP classes) to load the JAXP configured SAXParser. If there is any error\n * creating a JAXP SAXParser an informational message is output and then the\n * default (Aelfred) SAX parser is used instead.\n * <p>\n * If you are trying to use JAXP to explicitly set your SAX parser and are\n * experiencing problems, you can turn on verbose error reporting by defining\n * the system property <code>org.dom4j.verbose</code> to be \"true\" which will\n * output a more detailed description of why JAXP could not find a SAX parser\n * <p>\n * For more information on JAXP please go to <a\n * href=\"http://java.sun.com/xml/\">Sun's Java &amp; XML site </a>\n *\n * @author <a href=\"mailto:james.strachan@metastuff.com\">James Strachan </a>\n * @version $Revision: 1.58 $\n */\npublic class SAXReader {\n  private static final String SAX_STRING_INTERNING =\n          \"http://xml.org/sax/features/string-interning\";\n  private static final String SAX_DECL_HANDLER =\n          \"http://xml.org/sax/properties/declaration-handler\";\n  private static final String SAX_LEXICAL_HANDLER =\n          \"http://xml.org/sax/properties/lexical-handler\";\n  private static final String SAX_LEXICALHANDLER =\n          \"http://xml.org/sax/handlers/LexicalHandler\";\n\n  /**\n   * <code>DocumentFactory</code> used to create new document objects\n   */\n  private DocumentFactory factory;\n\n  /**\n   * <code>XMLReader</code> used to parse the SAX events\n   */\n  private XMLReader xmlReader;\n\n  /**\n   * Whether validation should occur\n   */\n  private boolean validating;\n\n  /**\n   * DispatchHandler to call when each <code>Element</code> is encountered\n   */\n  private DispatchHandler dispatchHandler;\n",
    "patch": "@@ -30,965 +30,981 @@\n import org.xml.sax.helpers.DefaultHandler;\n import org.xml.sax.helpers.XMLReaderFactory;\n \n+import javax.xml.parsers.SAXParserFactory;\n+\n /**\n  * <code>SAXReader</code> creates a DOM4J tree from SAX parsing events.\n- *\n+ * <p>\n  * The actual SAX parser that is used by this class is configurable so you can\n  * use your favourite SAX parser if you wish. DOM4J comes configured with its\n  * own SAX parser so you do not need to worry about configuring the SAX parser.\n- *\n+ * <p>\n  * To explicitly configure the SAX parser that is used via Java code you can use\n  * a constructor or use the {@link #setXMLReader(XMLReader)}or {@link\n  * #setXMLReaderClassName(String)} methods.\n- *\n+ * <p>\n  * If the parser is not specified explicitly then the standard SAX policy of\n  * using the <code>org.xml.sax.driver</code> system property is used to\n  * determine the implementation class of {@link XMLReader}.\n- *\n+ * <p>\n  * If the <code>org.xml.sax.driver</code> system property is not defined then\n  * JAXP is used via reflection (so that DOM4J is not explicitly dependent on the\n  * JAXP classes) to load the JAXP configured SAXParser. If there is any error\n  * creating a JAXP SAXParser an informational message is output and then the\n  * default (Aelfred) SAX parser is used instead.\n- *\n+ * <p>\n  * If you are trying to use JAXP to explicitly set your SAX parser and are\n  * experiencing problems, you can turn on verbose error reporting by defining\n  * the system property <code>org.dom4j.verbose</code> to be \"true\" which will\n  * output a more detailed description of why JAXP could not find a SAX parser\n- *\n+ * <p>\n  * For more information on JAXP please go to <a\n  * href=\"http://java.sun.com/xml/\">Sun's Java &amp; XML site </a>\n  *\n  * @author <a href=\"mailto:james.strachan@metastuff.com\">James Strachan </a>\n  * @version $Revision: 1.58 $\n  */\n public class SAXReader {\n-    private static final String SAX_STRING_INTERNING = \n-            \"http://xml.org/sax/features/string-interning\";\n-    private static final String SAX_DECL_HANDLER =\n-            \"http://xml.org/sax/properties/declaration-handler\";\n-    private static final String SAX_LEXICAL_HANDLER = \n-            \"http://xml.org/sax/properties/lexical-handler\";\n-    private static final String SAX_LEXICALHANDLER = \n-            \"http://xml.org/sax/handlers/LexicalHandler\";\n-\n-    /** <code>DocumentFactory</code> used to create new document objects */\n-    private DocumentFactory factory;\n-\n-    /** <code>XMLReader</code> used to parse the SAX events */\n-    private XMLReader xmlReader;\n-\n-    /** Whether validation should occur */\n-    private boolean validating;\n-\n-    /** DispatchHandler to call when each <code>Element</code> is encountered */\n-    private DispatchHandler dispatchHandler;\n-\n-    /** ErrorHandler class to use */\n-    private ErrorHandler errorHandler;\n-\n-    /** The entity resolver */\n-    private EntityResolver entityResolver;\n-\n-    /** Should element & attribute names and namespace URIs be interned? */\n-    private boolean stringInternEnabled = true;\n-\n-    /** Should internal DTD declarations be expanded into a List in the DTD */\n-    private boolean includeInternalDTDDeclarations = false;\n-\n-    /** Should external DTD declarations be expanded into a List in the DTD */\n-    private boolean includeExternalDTDDeclarations = false;\n-\n-    /** Whether adjacent text nodes should be merged */\n-    private boolean mergeAdjacentText = false;\n-\n-    /** Holds value of property stripWhitespaceText. */\n-    private boolean stripWhitespaceText = false;\n-\n-    /** Should we ignore comments */\n-    private boolean ignoreComments = false;\n-\n-    /** Encoding of InputSource - null means system default encoding */\n-    private String encoding = null;\n-\n-    // private boolean includeExternalGeneralEntities = false;\n-    // private boolean includeExternalParameterEntities = false;\n-\n-    /** The SAX filter used to filter SAX events */\n-    private XMLFilter xmlFilter;\n-\n-    public SAXReader() {\n-    }\n-\n-    public SAXReader(boolean validating) {\n-        this.validating = validating;\n-    }\n-\n-    public SAXReader(DocumentFactory factory) {\n-        this.factory = factory;\n-    }\n-\n-    public SAXReader(DocumentFactory factory, boolean validating) {\n-        this.factory = factory;\n-        this.validating = validating;\n-    }\n-\n-    public SAXReader(XMLReader xmlReader) {\n-        this.xmlReader = xmlReader;\n-    }\n-\n-    public SAXReader(XMLReader xmlReader, boolean validating) {\n-        this.xmlReader = xmlReader;\n-        this.validating = validating;\n-    }\n-\n-    public SAXReader(String xmlReaderClassName) throws SAXException {\n-        if (xmlReaderClassName != null) {\n-            this.xmlReader = XMLReaderFactory\n-                    .createXMLReader(xmlReaderClassName);\n+  private static final String SAX_STRING_INTERNING =\n+          \"http://xml.org/sax/features/string-interning\";\n+  private static final String SAX_DECL_HANDLER =\n+          \"http://xml.org/sax/properties/declaration-handler\";\n+  private static final String SAX_LEXICAL_HANDLER =\n+          \"http://xml.org/sax/properties/lexical-handler\";\n+  private static final String SAX_LEXICALHANDLER =\n+          \"http://xml.org/sax/handlers/LexicalHandler\";\n+\n+  /**\n+   * <code>DocumentFactory</code> used to create new document objects\n+   */\n+  private DocumentFactory factory;\n+\n+  /**\n+   * <code>XMLReader</code> used to parse the SAX events\n+   */\n+  private XMLReader xmlReader;\n+\n+  /**\n+   * Whether validation should occur\n+   */\n+  private boolean validating;\n+\n+  /**\n+   * DispatchHandler to call when each <code>Element</code> is encountered\n+   */\n+  private DispatchHandler dispatchHandler;\n+\n+  /**\n+   * ErrorHandler class to use\n+   */\n+  private ErrorHandler errorHandler;\n+\n+  /**\n+   * The entity resolver\n+   */\n+  private EntityResolver entityResolver;\n+\n+  /**\n+   * Should element & attribute names and namespace URIs be interned?\n+   */\n+  private boolean stringInternEnabled = true;\n+\n+  /**\n+   * Should internal DTD declarations be expanded into a List in the DTD\n+   */\n+  private boolean includeInternalDTDDeclarations = false;\n+\n+  /**\n+   * Should external DTD declarations be expanded into a List in the DTD\n+   */\n+  private boolean includeExternalDTDDeclarations = false;\n+\n+  /**\n+   * Whether adjacent text nodes should be merged\n+   */\n+  private boolean mergeAdjacentText = false;\n+\n+  /**\n+   * Holds value of property stripWhitespaceText.\n+   */\n+  private boolean stripWhitespaceText = false;\n+\n+  /**\n+   * Should we ignore comments\n+   */\n+  private boolean ignoreComments = false;\n+\n+  /**\n+   * Encoding of InputSource - null means system default encoding\n+   */\n+  private String encoding = null;\n+\n+  // private boolean includeExternalGeneralEntities = false;\n+  // private boolean includeExternalParameterEntities = false;\n+\n+  /**\n+   * The SAX filter used to filter SAX events\n+   *\n+   * @since 2.1.2\n+   */\n+  private XMLFilter xmlFilter;\n+\n+  public static SAXReader createDefault() {\n+    SAXReader reader = new SAXReader();\n+    try {\n+      reader.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n+      reader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n+      reader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n+    } catch (SAXException e) {\n+      // nothing to do, incompatible reader\n+    }\n+    return reader;\n+  }\n+\n+  /**\n+   * This method internally calls {@link SAXParserFactory}{@code .newInstance().newSAXParser().getXMLReader()} or {@link XMLReaderFactory#createXMLReader()}.\n+   * Be sure to configure returned reader if the default configuration does not suit you. Consider setting the following properties:\n+   *\n+   * <pre>\n+   * reader.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n+   * reader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n+   * reader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n+   * </pre>\n+   */\n+  public SAXReader() {\n+  }\n+\n+  /**\n+   * This method internally calls {@link SAXParserFactory}{@code .newInstance().newSAXParser().getXMLReader()} or {@link XMLReaderFactory#createXMLReader()}.\n+   * Be sure to configure returned reader if the default configuration does not suit you. Consider setting the following properties:\n+   *\n+   * <pre>\n+   * reader.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n+   * reader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n+   * reader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n+   * </pre>\n+   *\n+   * @param validating\n+   */\n+  public SAXReader(boolean validating) {\n+    this.validating = validating;\n+  }\n+\n+  /**\n+   * This method internally calls {@link SAXParserFactory}{@code .newInstance().newSAXParser().getXMLReader()} or {@link XMLReaderFactory#createXMLReader()}.\n+   * Be sure to configure returned reader if the default configuration does not suit you. Consider setting the following properties:\n+   *\n+   * <pre>\n+   * reader.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n+   * reader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n+   * reader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n+   * </pre>\n+   *\n+   * @param factory\n+   */\n+  public SAXReader(DocumentFactory factory) {\n+    this.factory = factory;\n+  }\n+\n+  /**\n+   * This method internally calls {@link SAXParserFactory}{@code .newInstance().newSAXParser().getXMLReader()} or {@link XMLReaderFactory#createXMLReader()}.\n+   * Be sure to configure returned reader if the default configuration does not suit you. Consider setting the following properties:\n+   *\n+   * <pre>\n+   * reader.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n+   * reader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n+   * reader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n+   * </pre>\n+   *\n+   * @param factory\n+   * @param validating\n+   */\n+  public SAXReader(DocumentFactory factory, boolean validating) {\n+    this.factory = factory;\n+    this.validating = validating;\n+  }\n+\n+  public SAXReader(XMLReader xmlReader) {\n+    this.xmlReader = xmlReader;\n+  }\n+\n+  public SAXReader(XMLReader xmlReader, boolean validating) {\n+    this.xmlReader = xmlReader;\n+    this.validating = validating;\n+  }\n+\n+  public SAXReader(String xmlReaderClassName) throws SAXException {\n+    if (xmlReaderClassName != null) {\n+      this.xmlReader = XMLReaderFactory\n+              .createXMLReader(xmlReaderClassName);\n+    }\n+  }\n+\n+  public SAXReader(String xmlReaderClassName, boolean validating)\n+          throws SAXException {\n+    if (xmlReaderClassName != null) {\n+      this.xmlReader = XMLReaderFactory\n+              .createXMLReader(xmlReaderClassName);\n+    }\n+\n+    this.validating = validating;\n+  }\n+\n+  /**\n+   * Allows a SAX property to be set on the underlying SAX parser. This can be\n+   * useful to set parser-specific properties such as the location of schema\n+   * or DTD resources. Though use this method with caution as it has the\n+   * possibility of breaking the standard behaviour. An alternative to calling\n+   * this method is to correctly configure an XMLReader object instance and\n+   * call the {@link #setXMLReader(XMLReader)}method\n+   *\n+   * @param name  is the SAX property name\n+   * @param value is the value of the SAX property\n+   * @throws SAXException if the XMLReader could not be created or the property could\n+   *                      not be changed.\n+   */\n+  public void setProperty(String name, Object value) throws SAXException {\n+    getXMLReader().setProperty(name, value);\n+  }\n+\n+  /**\n+   * Sets a SAX feature on the underlying SAX parser. This can be useful to\n+   * set parser-specific features. Though use this method with caution as it\n+   * has the possibility of breaking the standard behaviour. An alternative to\n+   * calling this method is to correctly configure an XMLReader object\n+   * instance and call the {@link #setXMLReader(XMLReader)}method\n+   *\n+   * @param name  is the SAX feature name\n+   * @param value is the value of the SAX feature\n+   * @throws SAXException if the XMLReader could not be created or the feature could\n+   *                      not be changed.\n+   */\n+  public void setFeature(String name, boolean value) throws SAXException {\n+    getXMLReader().setFeature(name, value);\n+  }\n+\n+  /**\n+   * <p>\n+   * Reads a Document from the given <code>File</code>\n+   * </p>\n+   *\n+   * @param file is the <code>File</code> to read from.\n+   * @return the newly created Document instance\n+   * @throws DocumentException if an error occurs during parsing.\n+   */\n+  public Document read(File file) throws DocumentException {\n+    try {\n+      /*\n+       * We cannot convert the file to an URL because if the filename\n+       * contains '#' characters, there will be problems with the URL in\n+       * the InputSource (because a URL like\n+       * http://myhost.com/index#anchor is treated the same as\n+       * http://myhost.com/index) Thanks to Christian Oetterli\n+       */\n+      InputSource source = new InputSource(new FileInputStream(file));\n+      if (this.encoding != null) {\n+        source.setEncoding(this.encoding);\n+      }\n+      String path = file.getAbsolutePath();\n+\n+      if (path != null) {\n+        // Code taken from Ant FileUtils\n+        StringBuffer sb = new StringBuffer(\"file://\");\n+\n+        // add an extra slash for filesystems with drive-specifiers\n+        if (!path.startsWith(File.separator)) {\n+          sb.append(\"/\");\n         }\n-    }\n \n-    public SAXReader(String xmlReaderClassName, boolean validating)\n-            throws SAXException {\n-        if (xmlReaderClassName != null) {\n-            this.xmlReader = XMLReaderFactory\n-                    .createXMLReader(xmlReaderClassName);\n+        path = path.replace('\\\\', '/');\n+        sb.append(path);\n+\n+        source.setSystemId(sb.toString());\n+      }\n+\n+      return read(source);\n+    } catch (FileNotFoundException e) {\n+      throw new DocumentException(e.getMessage(), e);\n+    }\n+  }\n+\n+  /**\n+   * <p>\n+   * Reads a Document from the given <code>URL</code> using SAX\n+   * </p>\n+   *\n+   * @param url <code>URL</code> to read from.\n+   * @return the newly created Document instance\n+   * @throws DocumentException if an error occurs during parsing.\n+   */\n+  public Document read(URL url) throws DocumentException {\n+    String systemID = url.toExternalForm();\n+\n+    InputSource source = new InputSource(systemID);\n+    if (this.encoding != null) {\n+      source.setEncoding(this.encoding);\n+    }\n+\n+    return read(source);\n+  }\n+\n+  /**\n+   * <p>\n+   * Reads a Document from the given URL or filename using SAX.\n+   * </p>\n+   *\n+   * <p>\n+   * If the systemId contains a <code>':'</code> character then it is\n+   * assumed to be a URL otherwise its assumed to be a file name. If you want\n+   * finer grained control over this mechansim then please explicitly pass in\n+   * either a {@link URL}or a {@link File}instance instead of a {@link\n+   * String} to denote the source of the document.\n+   * </p>\n+   *\n+   * @param systemId is a URL for a document or a file name.\n+   * @return the newly created Document instance\n+   * @throws DocumentException if an error occurs during parsing.\n+   */\n+  public Document read(String systemId) throws DocumentException {\n+    InputSource source = new InputSource(systemId);\n+    if (this.encoding != null) {\n+      source.setEncoding(this.encoding);\n+    }\n+\n+    return read(source);\n+  }\n+\n+  /**\n+   * <p>\n+   * Reads a Document from the given stream using SAX\n+   * </p>\n+   *\n+   * @param in <code>InputStream</code> to read from.\n+   * @return the newly created Document instance\n+   * @throws DocumentException if an error occurs during parsing.\n+   */\n+  public Document read(InputStream in) throws DocumentException {\n+    InputSource source = new InputSource(in);\n+    if (this.encoding != null) {\n+      source.setEncoding(this.encoding);\n+    }\n+\n+    return read(source);\n+  }\n+\n+  /**\n+   * Reads a Document from the given <code>Reader</code> using SAX\n+   *\n+   * @param reader is the reader for the input\n+   * @return the newly created Document instance\n+   * @throws DocumentException if an error occurs during parsing.\n+   */\n+  public Document read(Reader reader) throws DocumentException {\n+    InputSource source = new InputSource(reader);\n+    if (this.encoding != null) {\n+      source.setEncoding(this.encoding);\n+    }\n+\n+    return read(source);\n+  }\n+\n+  /**\n+   * <p>\n+   * Reads a Document from the given stream using SAX\n+   * </p>\n+   *\n+   * @param in       <code>InputStream</code> to read from.\n+   * @param systemId is the URI for the input\n+   * @return the newly created Document instance\n+   * @throws DocumentException if an error occurs during parsing.\n+   */\n+  public Document read(InputStream in, String systemId)\n+          throws DocumentException {\n+    InputSource source = new InputSource(in);\n+    source.setSystemId(systemId);\n+    if (this.encoding != null) {\n+      source.setEncoding(this.encoding);\n+    }\n+\n+    return read(source);\n+  }\n+\n+  /**\n+   * <p>\n+   * Reads a Document from the given <code>Reader</code> using SAX\n+   * </p>\n+   *\n+   * @param reader   is the reader for the input\n+   * @param systemId is the URI for the input\n+   * @return the newly created Document instance\n+   * @throws DocumentException if an error occurs during parsing.\n+   */\n+  public Document read(Reader reader, String systemId)\n+          throws DocumentException {\n+    InputSource source = new InputSource(reader);\n+    source.setSystemId(systemId);\n+    if (this.encoding != null) {\n+      source.setEncoding(this.encoding);\n+    }\n+\n+    return read(source);\n+  }\n+\n+  /**\n+   * <p>\n+   * Reads a Document from the given <code>InputSource</code> using SAX\n+   * </p>\n+   *\n+   * @param in <code>InputSource</code> to read from.\n+   * @return the newly created Document instance\n+   * @throws DocumentException if an error occurs during parsing.\n+   */\n+  public Document read(InputSource in) throws DocumentException {\n+    try {\n+      XMLReader reader = getXMLReader();\n+\n+      reader = installXMLFilter(reader);\n+\n+      EntityResolver thatEntityResolver = this.entityResolver;\n+\n+      if (thatEntityResolver == null) {\n+        thatEntityResolver = createDefaultEntityResolver(in\n+                .getSystemId());\n+        this.entityResolver = thatEntityResolver;\n+      }\n+\n+      reader.setEntityResolver(thatEntityResolver);\n+\n+      SAXContentHandler contentHandler = createContentHandler(reader);\n+      contentHandler.setEntityResolver(thatEntityResolver);\n+      contentHandler.setInputSource(in);\n+\n+      boolean internal = isIncludeInternalDTDDeclarations();\n+      boolean external = isIncludeExternalDTDDeclarations();\n+\n+      contentHandler.setIncludeInternalDTDDeclarations(internal);\n+      contentHandler.setIncludeExternalDTDDeclarations(external);\n+      contentHandler.setMergeAdjacentText(isMergeAdjacentText());\n+      contentHandler.setStripWhitespaceText(isStripWhitespaceText());\n+      contentHandler.setIgnoreComments(isIgnoreComments());\n+      reader.setContentHandler(contentHandler);\n+\n+      configureReader(reader, contentHandler);\n+\n+      reader.parse(in);\n+\n+      return contentHandler.getDocument();\n+    } catch (Exception e) {\n+      if (e instanceof SAXParseException) {\n+        // e.printStackTrace();\n+        SAXParseException parseException = (SAXParseException) e;\n+        String systemId = parseException.getSystemId();\n+\n+        if (systemId == null) {\n+          systemId = \"\";\n         }\n \n-        this.validating = validating;\n-    }\n-\n-    /**\n-     * Allows a SAX property to be set on the underlying SAX parser. This can be\n-     * useful to set parser-specific properties such as the location of schema\n-     * or DTD resources. Though use this method with caution as it has the\n-     * possibility of breaking the standard behaviour. An alternative to calling\n-     * this method is to correctly configure an XMLReader object instance and\n-     * call the {@link #setXMLReader(XMLReader)}method\n-     * \n-     * @param name\n-     *            is the SAX property name\n-     * @param value\n-     *            is the value of the SAX property\n-     * \n-     * @throws SAXException\n-     *             if the XMLReader could not be created or the property could\n-     *             not be changed.\n-     */\n-    public void setProperty(String name, Object value) throws SAXException {\n-        getXMLReader().setProperty(name, value);\n-    }\n-\n-    /**\n-     * Sets a SAX feature on the underlying SAX parser. This can be useful to\n-     * set parser-specific features. Though use this method with caution as it\n-     * has the possibility of breaking the standard behaviour. An alternative to\n-     * calling this method is to correctly configure an XMLReader object\n-     * instance and call the {@link #setXMLReader(XMLReader)}method\n-     * \n-     * @param name\n-     *            is the SAX feature name\n-     * @param value\n-     *            is the value of the SAX feature\n-     * \n-     * @throws SAXException\n-     *             if the XMLReader could not be created or the feature could\n-     *             not be changed.\n-     */\n-    public void setFeature(String name, boolean value) throws SAXException {\n-        getXMLReader().setFeature(name, value);\n-    }\n-\n-    /**\n-     * <p>\n-     * Reads a Document from the given <code>File</code>\n-     * </p>\n-     * \n-     * @param file\n-     *            is the <code>File</code> to read from.\n-     * \n-     * @return the newly created Document instance\n-     * \n-     * @throws DocumentException\n-     *             if an error occurs during parsing.\n-     */\n-    public Document read(File file) throws DocumentException {\n-        try {\n-            /*\n-             * We cannot convert the file to an URL because if the filename\n-             * contains '#' characters, there will be problems with the URL in\n-             * the InputSource (because a URL like\n-             * http://myhost.com/index#anchor is treated the same as\n-             * http://myhost.com/index) Thanks to Christian Oetterli\n-             */\n-            InputSource source = new InputSource(new FileInputStream(file));\n-            if (this.encoding != null) {\n-                source.setEncoding(this.encoding);\n-            }\n-            String path = file.getAbsolutePath();\n-\n-            if (path != null) {\n-                // Code taken from Ant FileUtils\n-                StringBuffer sb = new StringBuffer(\"file://\");\n-\n-                // add an extra slash for filesystems with drive-specifiers\n-                if (!path.startsWith(File.separator)) {\n-                    sb.append(\"/\");\n-                }\n-\n-                path = path.replace('\\\\', '/');\n-                sb.append(path);\n-\n-                source.setSystemId(sb.toString());\n-            }\n-\n-            return read(source);\n-        } catch (FileNotFoundException e) {\n-            throw new DocumentException(e.getMessage(), e);\n+        String message = \"Error on line \"\n+                + parseException.getLineNumber() + \" of document \"\n+                + systemId + \" : \" + parseException.getMessage();\n+\n+        throw new DocumentException(message, e);\n+      } else {\n+        throw new DocumentException(e.getMessage(), e);\n+      }\n+    }\n+  }\n+\n+  // Properties\n+  // -------------------------------------------------------------------------\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return the validation mode, true if validating will be done otherwise\n+   * false.\n+   */\n+  public boolean isValidating() {\n+    return validating;\n+  }\n+\n+  /**\n+   * Sets the validation mode.\n+   *\n+   * @param validation indicates whether or not validation should occur.\n+   */\n+  public void setValidation(boolean validation) {\n+    this.validating = validation;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return whether internal DTD declarations should be expanded into the\n+   * DocumentType object or not.\n+   */\n+  public boolean isIncludeInternalDTDDeclarations() {\n+    return includeInternalDTDDeclarations;\n+  }\n+\n+  /**\n+   * Sets whether internal DTD declarations should be expanded into the\n+   * DocumentType object or not.\n+   *\n+   * @param include whether or not DTD declarations should be expanded and\n+   *                included into the DocumentType object.\n+   */\n+  public void setIncludeInternalDTDDeclarations(boolean include) {\n+    this.includeInternalDTDDeclarations = include;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return whether external DTD declarations should be expanded into the\n+   * DocumentType object or not.\n+   */\n+  public boolean isIncludeExternalDTDDeclarations() {\n+    return includeExternalDTDDeclarations;\n+  }\n+\n+  /**\n+   * Sets whether DTD external declarations should be expanded into the\n+   * DocumentType object or not.\n+   *\n+   * @param include whether or not DTD declarations should be expanded and\n+   *                included into the DocumentType object.\n+   */\n+  public void setIncludeExternalDTDDeclarations(boolean include) {\n+    this.includeExternalDTDDeclarations = include;\n+  }\n+\n+  /**\n+   * Sets whether String interning is enabled or disabled for element &amp;\n+   * attribute names and namespace URIs. This proprety is enabled by default.\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public boolean isStringInternEnabled() {\n+    return stringInternEnabled;\n+  }\n+\n+  /**\n+   * Sets whether String interning is enabled or disabled for element &amp;\n+   * attribute names and namespace URIs\n+   *\n+   * @param stringInternEnabled DOCUMENT ME!\n+   */\n+  public void setStringInternEnabled(boolean stringInternEnabled) {\n+    this.stringInternEnabled = stringInternEnabled;\n+  }\n+\n+  /**\n+   * Returns whether adjacent text nodes should be merged together.\n+   *\n+   * @return Value of property mergeAdjacentText.\n+   */\n+  public boolean isMergeAdjacentText() {\n+    return mergeAdjacentText;\n+  }\n+\n+  /**\n+   * Sets whether or not adjacent text nodes should be merged together when\n+   * parsing.\n+   *\n+   * @param mergeAdjacentText New value of property mergeAdjacentText.\n+   */\n+  public void setMergeAdjacentText(boolean mergeAdjacentText) {\n+    this.mergeAdjacentText = mergeAdjacentText;\n+  }\n+\n+  /**\n+   * Sets whether whitespace between element start and end tags should be\n+   * ignored\n+   *\n+   * @return Value of property stripWhitespaceText.\n+   */\n+  public boolean isStripWhitespaceText() {\n+    return stripWhitespaceText;\n+  }\n+\n+  /**\n+   * Sets whether whitespace between element start and end tags should be\n+   * ignored.\n+   *\n+   * @param stripWhitespaceText New value of property stripWhitespaceText.\n+   */\n+  public void setStripWhitespaceText(boolean stripWhitespaceText) {\n+    this.stripWhitespaceText = stripWhitespaceText;\n+  }\n+\n+  /**\n+   * Returns whether we should ignore comments or not.\n+   *\n+   * @return boolean\n+   */\n+  public boolean isIgnoreComments() {\n+    return ignoreComments;\n+  }\n+\n+  /**\n+   * Sets whether we should ignore comments or not.\n+   *\n+   * @param ignoreComments whether we should ignore comments or not.\n+   */\n+  public void setIgnoreComments(boolean ignoreComments) {\n+    this.ignoreComments = ignoreComments;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return the <code>DocumentFactory</code> used to create document\n+   * objects\n+   */\n+  public DocumentFactory getDocumentFactory() {\n+    if (factory == null) {\n+      factory = DocumentFactory.getInstance();\n+    }\n+\n+    return factory;\n+  }\n+\n+  /**\n+   * <p>\n+   * This sets the <code>DocumentFactory</code> used to create new\n+   * documents. This method allows the building of custom DOM4J tree objects\n+   * to be implemented easily using a custom derivation of\n+   * {@link DocumentFactory}\n+   * </p>\n+   *\n+   * @param documentFactory <code>DocumentFactory</code> used to create DOM4J objects\n+   */\n+  public void setDocumentFactory(DocumentFactory documentFactory) {\n+    this.factory = documentFactory;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return the <code>ErrorHandler</code> used by SAX\n+   */\n+  public ErrorHandler getErrorHandler() {\n+    return errorHandler;\n+  }\n+\n+  /**\n+   * Sets the <code>ErrorHandler</code> used by the SAX\n+   * <code>XMLReader</code>.\n+   *\n+   * @param errorHandler is the <code>ErrorHandler</code> used by SAX\n+   */\n+  public void setErrorHandler(ErrorHandler errorHandler) {\n+    this.errorHandler = errorHandler;\n+  }\n+\n+  /**\n+   * Returns the current entity resolver used to resolve entities\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public EntityResolver getEntityResolver() {\n+    return entityResolver;\n+  }\n+\n+  /**\n+   * Sets the entity resolver used to resolve entities.\n+   *\n+   * @param entityResolver DOCUMENT ME!\n+   */\n+  public void setEntityResolver(EntityResolver entityResolver) {\n+    this.entityResolver = entityResolver;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return the <code>XMLReader</code> used to parse SAX events\n+   * @throws SAXException DOCUMENT ME!\n+   */\n+  public XMLReader getXMLReader() throws SAXException {\n+    if (xmlReader == null) {\n+      xmlReader = createXMLReader();\n+    }\n+\n+    return xmlReader;\n+  }\n+\n+  /**\n+   * Sets the <code>XMLReader</code> used to parse SAX events\n+   *\n+   * @param reader is the <code>XMLReader</code> to parse SAX events\n+   */\n+  public void setXMLReader(XMLReader reader) {\n+    this.xmlReader = reader;\n+  }\n+\n+  /**\n+   * Returns encoding used for InputSource (null means system default\n+   * encoding)\n+   *\n+   * @return encoding used for InputSource\n+   */\n+  public String getEncoding() {\n+    return encoding;\n+  }\n+\n+  /**\n+   * Sets encoding used for InputSource (null means system default encoding)\n+   *\n+   * @param encoding is encoding used for InputSource\n+   */\n+  public void setEncoding(String encoding) {\n+    this.encoding = encoding;\n+  }\n+\n+  /**\n+   * Sets the class name of the <code>XMLReader</code> to be used to parse\n+   * SAX events.\n+   *\n+   * @param xmlReaderClassName is the class name of the <code>XMLReader</code> to parse SAX\n+   *                           events\n+   * @throws SAXException DOCUMENT ME!\n+   */\n+  public void setXMLReaderClassName(String xmlReaderClassName)\n+          throws SAXException {\n+    setXMLReader(XMLReaderFactory.createXMLReader(xmlReaderClassName));\n+  }\n+\n+  /**\n+   * Adds the <code>ElementHandler</code> to be called when the specified\n+   * path is encounted.\n+   *\n+   * @param path    is the path to be handled\n+   * @param handler is the <code>ElementHandler</code> to be called by the event\n+   *                based processor.\n+   */\n+  public void addHandler(String path, ElementHandler handler) {\n+    getDispatchHandler().addHandler(path, handler);\n+  }\n+\n+  /**\n+   * Removes the <code>ElementHandler</code> from the event based processor,\n+   * for the specified path.\n+   *\n+   * @param path is the path to remove the <code>ElementHandler</code> for.\n+   */\n+  public void removeHandler(String path) {\n+    getDispatchHandler().removeHandler(path);\n+  }\n+\n+  /**\n+   * When multiple <code>ElementHandler</code> instances have been\n+   * registered, this will set a default <code>ElementHandler</code> to be\n+   * called for any path which does <b>NOT </b> have a handler registered.\n+   *\n+   * @param handler is the <code>ElementHandler</code> to be called by the event\n+   *                based processor.\n+   */\n+  public void setDefaultHandler(ElementHandler handler) {\n+    getDispatchHandler().setDefaultHandler(handler);\n+  }\n+\n+  /**\n+   * This method clears out all the existing handlers and default handler\n+   * setting things back as if no handler existed. Useful when reusing an\n+   * object instance.\n+   */\n+  public void resetHandlers() {\n+    getDispatchHandler().resetHandlers();\n+  }\n+\n+  /**\n+   * Returns the SAX filter being used to filter SAX events.\n+   *\n+   * @return the SAX filter being used or null if no SAX filter is installed\n+   */\n+  public XMLFilter getXMLFilter() {\n+    return xmlFilter;\n+  }\n+\n+  /**\n+   * Sets the SAX filter to be used when filtering SAX events\n+   *\n+   * @param filter is the SAX filter to use or null to disable filtering\n+   */\n+  public void setXMLFilter(XMLFilter filter) {\n+    this.xmlFilter = filter;\n+  }\n+\n+  // Implementation methods\n+  // -------------------------------------------------------------------------\n+\n+  /**\n+   * Installs any XMLFilter objects required to allow the SAX event stream to\n+   * be filtered and preprocessed before it gets to dom4j.\n+   *\n+   * @param reader DOCUMENT ME!\n+   * @return the new XMLFilter if applicable or the original XMLReader if no\n+   * filter is being used.\n+   */\n+  protected XMLReader installXMLFilter(XMLReader reader) {\n+    XMLFilter filter = getXMLFilter();\n+\n+    if (filter != null) {\n+      // find the root XMLFilter\n+      XMLFilter root = filter;\n+\n+      while (true) {\n+        XMLReader parent = root.getParent();\n+\n+        if (parent instanceof XMLFilter) {\n+          root = (XMLFilter) parent;\n+        } else {\n+          break;\n         }\n+      }\n+\n+      root.setParent(reader);\n+\n+      return filter;\n     }\n \n-    /**\n-     * <p>\n-     * Reads a Document from the given <code>URL</code> using SAX\n-     * </p>\n-     * \n-     * @param url\n-     *            <code>URL</code> to read from.\n-     * \n-     * @return the newly created Document instance\n-     * \n-     * @throws DocumentException\n-     *             if an error occurs during parsing.\n-     */\n-    public Document read(URL url) throws DocumentException {\n-        String systemID = url.toExternalForm();\n-\n-        InputSource source = new InputSource(systemID);\n-        if (this.encoding != null) {\n-            source.setEncoding(this.encoding);\n-        }\n+    return reader;\n+  }\n \n-        return read(source);\n-    }\n-\n-    /**\n-     * <p>\n-     * Reads a Document from the given URL or filename using SAX.\n-     * </p>\n-     * \n-     * <p>\n-     * If the systemId contains a <code>':'</code> character then it is\n-     * assumed to be a URL otherwise its assumed to be a file name. If you want\n-     * finer grained control over this mechansim then please explicitly pass in\n-     * either a {@link URL}or a {@link File}instance instead of a {@link\n-     * String} to denote the source of the document.\n-     * </p>\n-     * \n-     * @param systemId\n-     *            is a URL for a document or a file name.\n-     * \n-     * @return the newly created Document instance\n-     * \n-     * @throws DocumentException\n-     *             if an error occurs during parsing.\n-     */\n-    public Document read(String systemId) throws DocumentException {\n-        InputSource source = new InputSource(systemId);\n-        if (this.encoding != null) {\n-            source.setEncoding(this.encoding);\n-        }\n-\n-        return read(source);\n-    }\n-\n-    /**\n-     * <p>\n-     * Reads a Document from the given stream using SAX\n-     * </p>\n-     * \n-     * @param in\n-     *            <code>InputStream</code> to read from.\n-     * \n-     * @return the newly created Document instance\n-     * \n-     * @throws DocumentException\n-     *             if an error occurs during parsing.\n-     */\n-    public Document read(InputStream in) throws DocumentException {\n-        InputSource source = new InputSource(in);\n-        if (this.encoding != null) {\n-            source.setEncoding(this.encoding);\n-        }\n-\n-        return read(source);\n-    }\n-\n-    /**\n-     * Reads a Document from the given <code>Reader</code> using SAX\n-     *\n-     * @param reader\n-     *            is the reader for the input\n-     * \n-     * @return the newly created Document instance\n-     * \n-     * @throws DocumentException\n-     *             if an error occurs during parsing.\n-     */\n-    public Document read(Reader reader) throws DocumentException {\n-        InputSource source = new InputSource(reader);\n-        if (this.encoding != null) {\n-            source.setEncoding(this.encoding);\n-        }\n-\n-        return read(source);\n-    }\n-\n-    /**\n-     * <p>\n-     * Reads a Document from the given stream using SAX\n-     * </p>\n-     * \n-     * @param in\n-     *            <code>InputStream</code> to read from.\n-     * @param systemId\n-     *            is the URI for the input\n-     * \n-     * @return the newly created Document instance\n-     * \n-     * @throws DocumentException\n-     *             if an error occurs during parsing.\n-     */\n-    public Document read(InputStream in, String systemId)\n-            throws DocumentException {\n-        InputSource source = new InputSource(in);\n-        source.setSystemId(systemId);\n-        if (this.encoding != null) {\n-            source.setEncoding(this.encoding);\n-        }\n-\n-        return read(source);\n-    }\n-\n-    /**\n-     * <p>\n-     * Reads a Document from the given <code>Reader</code> using SAX\n-     * </p>\n-     * \n-     * @param reader\n-     *            is the reader for the input\n-     * @param systemId\n-     *            is the URI for the input\n-     * \n-     * @return the newly created Document instance\n-     * \n-     * @throws DocumentException\n-     *             if an error occurs during parsing.\n-     */\n-    public Document read(Reader reader, String systemId)\n-            throws DocumentException {\n-        InputSource source = new InputSource(reader);\n-        source.setSystemId(systemId);\n-        if (this.encoding != null) {\n-            source.setEncoding(this.encoding);\n-        }\n-\n-        return read(source);\n-    }\n-\n-    /**\n-     * <p>\n-     * Reads a Document from the given <code>InputSource</code> using SAX\n-     * </p>\n-     * \n-     * @param in\n-     *            <code>InputSource</code> to read from.\n-     * \n-     * @return the newly created Document instance\n-     * \n-     * @throws DocumentException\n-     *             if an error occurs during parsing.\n-     */\n-    public Document read(InputSource in) throws DocumentException {\n-        try {\n-            XMLReader reader = getXMLReader();\n-\n-            reader = installXMLFilter(reader);\n-\n-            EntityResolver thatEntityResolver = this.entityResolver;\n-\n-            if (thatEntityResolver == null) {\n-                thatEntityResolver = createDefaultEntityResolver(in\n-                        .getSystemId());\n-                this.entityResolver = thatEntityResolver;\n-            }\n-\n-            reader.setEntityResolver(thatEntityResolver);\n-\n-            SAXContentHandler contentHandler = createContentHandler(reader);\n-            contentHandler.setEntityResolver(thatEntityResolver);\n-            contentHandler.setInputSource(in);\n-\n-            boolean internal = isIncludeInternalDTDDeclarations();\n-            boolean external = isIncludeExternalDTDDeclarations();\n-\n-            contentHandler.setIncludeInternalDTDDeclarations(internal);\n-            contentHandler.setIncludeExternalDTDDeclarations(external);\n-            contentHandler.setMergeAdjacentText(isMergeAdjacentText());\n-            contentHandler.setStripWhitespaceText(isStripWhitespaceText());\n-            contentHandler.setIgnoreComments(isIgnoreComments());\n-            reader.setContentHandler(contentHandler);\n-\n-            configureReader(reader, contentHandler);\n-\n-            reader.parse(in);\n-\n-            return contentHandler.getDocument();\n-        } catch (Exception e) {\n-            if (e instanceof SAXParseException) {\n-                // e.printStackTrace();\n-                SAXParseException parseException = (SAXParseException) e;\n-                String systemId = parseException.getSystemId();\n-\n-                if (systemId == null) {\n-                    systemId = \"\";\n-                }\n-\n-                String message = \"Error on line \"\n-                        + parseException.getLineNumber() + \" of document \"\n-                        + systemId + \" : \" + parseException.getMessage();\n-\n-                throw new DocumentException(message, e);\n-            } else {\n-                throw new DocumentException(e.getMessage(), e);\n-            }\n+  protected DispatchHandler getDispatchHandler() {\n+    if (dispatchHandler == null) {\n+      dispatchHandler = new DispatchHandler();\n+    }\n+\n+    return dispatchHandler;\n+  }\n+\n+  protected void setDispatchHandler(DispatchHandler dispatchHandler) {\n+    this.dispatchHandler = dispatchHandler;\n+  }\n+\n+  /**\n+   * Factory Method to allow alternate methods of creating and configuring\n+   * XMLReader objects\n+   *\n+   * @return DOCUMENT ME!\n+   * @throws SAXException DOCUMENT ME!\n+   */\n+  protected XMLReader createXMLReader() throws SAXException {\n+    return SAXHelper.createXMLReader(isValidating());\n+  }\n+\n+  /**\n+   * Configures the XMLReader before use\n+   *\n+   * @param reader  DOCUMENT ME!\n+   * @param handler DOCUMENT ME!\n+   * @throws DocumentException DOCUMENT ME!\n+   */\n+  protected void configureReader(XMLReader reader, DefaultHandler handler)\n+          throws DocumentException {\n+    // configure lexical handling\n+    SAXHelper.setParserProperty(reader, SAX_LEXICALHANDLER, handler);\n+\n+    // try alternate property just in case\n+    SAXHelper.setParserProperty(reader, SAX_LEXICAL_HANDLER, handler);\n+\n+    // register the DeclHandler\n+    if (includeInternalDTDDeclarations || includeExternalDTDDeclarations) {\n+      SAXHelper.setParserProperty(reader, SAX_DECL_HANDLER, handler);\n+    }\n+\n+    // string interning\n+    SAXHelper.setParserFeature(reader, SAX_STRING_INTERNING,\n+            isStringInternEnabled());\n+\n+    try {\n+      // configure validation support\n+      reader.setFeature(\"http://xml.org/sax/features/validation\",\n+              isValidating());\n+\n+      if (errorHandler != null) {\n+        reader.setErrorHandler(errorHandler);\n+      } else {\n+        reader.setErrorHandler(handler);\n+      }\n+    } catch (Exception e) {\n+      if (isValidating()) {\n+        throw new DocumentException(\"Validation not supported for\"\n+                + \" XMLReader: \" + reader, e);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Factory Method to allow user derived SAXContentHandler objects to be used\n+   *\n+   * @param reader DOCUMENT ME!\n+   * @return DOCUMENT ME!\n+   */\n+  protected SAXContentHandler createContentHandler(XMLReader reader) {\n+    return new SAXContentHandler(getDocumentFactory(), dispatchHandler);\n+  }\n+\n+  protected EntityResolver createDefaultEntityResolver(String systemId) {\n+    String prefix = null;\n+\n+    if ((systemId != null) && (systemId.length() > 0)) {\n+      int idx = systemId.lastIndexOf('/');\n+\n+      if (idx > 0) {\n+        prefix = systemId.substring(0, idx + 1);\n+      }\n+    }\n+\n+    return new SAXEntityResolver(prefix);\n+  }\n+\n+  protected static class SAXEntityResolver implements EntityResolver,\n+          Serializable {\n+    protected String uriPrefix;\n+\n+    public SAXEntityResolver(String uriPrefix) {\n+      this.uriPrefix = uriPrefix;\n+    }\n+\n+    public InputSource resolveEntity(String publicId, String systemId) {\n+      // try create a relative URI reader...\n+      if ((systemId != null) && (systemId.length() > 0)) {\n+        if ((uriPrefix != null) && (systemId.indexOf(':') <= 0)) {\n+          systemId = uriPrefix + systemId;\n         }\n-    }\n-\n-    // Properties\n-    // -------------------------------------------------------------------------\n-\n-    /**\n-     * DOCUMENT ME!\n-     * \n-     * @return the validation mode, true if validating will be done otherwise\n-     *         false.\n-     */\n-    public boolean isValidating() {\n-        return validating;\n-    }\n-\n-    /**\n-     * Sets the validation mode.\n-     * \n-     * @param validation\n-     *            indicates whether or not validation should occur.\n-     */\n-    public void setValidation(boolean validation) {\n-        this.validating = validation;\n-    }\n+      }\n \n-    /**\n-     * DOCUMENT ME!\n-     * \n-     * @return whether internal DTD declarations should be expanded into the\n-     *         DocumentType object or not.\n-     */\n-    public boolean isIncludeInternalDTDDeclarations() {\n-        return includeInternalDTDDeclarations;\n-    }\n-\n-    /**\n-     * Sets whether internal DTD declarations should be expanded into the\n-     * DocumentType object or not.\n-     * \n-     * @param include\n-     *            whether or not DTD declarations should be expanded and\n-     *            included into the DocumentType object.\n-     */\n-    public void setIncludeInternalDTDDeclarations(boolean include) {\n-        this.includeInternalDTDDeclarations = include;\n-    }\n-\n-    /**\n-     * DOCUMENT ME!\n-     * \n-     * @return whether external DTD declarations should be expanded into the\n-     *         DocumentType object or not.\n-     */\n-    public boolean isIncludeExternalDTDDeclarations() {\n-        return includeExternalDTDDeclarations;\n-    }\n-\n-    /**\n-     * Sets whether DTD external declarations should be expanded into the\n-     * DocumentType object or not.\n-     * \n-     * @param include\n-     *            whether or not DTD declarations should be expanded and\n-     *            included into the DocumentType object.\n-     */\n-    public void setIncludeExternalDTDDeclarations(boolean include) {\n-        this.includeExternalDTDDeclarations = include;\n-    }\n-\n-    /**\n-     * Sets whether String interning is enabled or disabled for element &amp;\n-     * attribute names and namespace URIs. This proprety is enabled by default.\n-     * \n-     * @return DOCUMENT ME!\n-     */\n-    public boolean isStringInternEnabled() {\n-        return stringInternEnabled;\n-    }\n-\n-    /**\n-     * Sets whether String interning is enabled or disabled for element &amp;\n-     * attribute names and namespace URIs\n-     * \n-     * @param stringInternEnabled\n-     *            DOCUMENT ME!\n-     */\n-    public void setStringInternEnabled(boolean stringInternEnabled) {\n-        this.stringInternEnabled = stringInternEnabled;\n-    }\n-\n-    /**\n-     * Returns whether adjacent text nodes should be merged together.\n-     * \n-     * @return Value of property mergeAdjacentText.\n-     */\n-    public boolean isMergeAdjacentText() {\n-        return mergeAdjacentText;\n-    }\n-\n-    /**\n-     * Sets whether or not adjacent text nodes should be merged together when\n-     * parsing.\n-     * \n-     * @param mergeAdjacentText\n-     *            New value of property mergeAdjacentText.\n-     */\n-    public void setMergeAdjacentText(boolean mergeAdjacentText) {\n-        this.mergeAdjacentText = mergeAdjacentText;\n-    }\n-\n-    /**\n-     * Sets whether whitespace between element start and end tags should be\n-     * ignored\n-     * \n-     * @return Value of property stripWhitespaceText.\n-     */\n-    public boolean isStripWhitespaceText() {\n-        return stripWhitespaceText;\n-    }\n-\n-    /**\n-     * Sets whether whitespace between element start and end tags should be\n-     * ignored.\n-     * \n-     * @param stripWhitespaceText\n-     *            New value of property stripWhitespaceText.\n-     */\n-    public void setStripWhitespaceText(boolean stripWhitespaceText) {\n-        this.stripWhitespaceText = stripWhitespaceText;\n-    }\n-\n-    /**\n-     * Returns whether we should ignore comments or not.\n-     * \n-     * @return boolean\n-     */\n-    public boolean isIgnoreComments() {\n-        return ignoreComments;\n-    }\n-\n-    /**\n-     * Sets whether we should ignore comments or not.\n-     * \n-     * @param ignoreComments\n-     *            whether we should ignore comments or not.\n-     */\n-    public void setIgnoreComments(boolean ignoreComments) {\n-        this.ignoreComments = ignoreComments;\n-    }\n-\n-    /**\n-     * DOCUMENT ME!\n-     * \n-     * @return the <code>DocumentFactory</code> used to create document\n-     *         objects\n-     */\n-    public DocumentFactory getDocumentFactory() {\n-        if (factory == null) {\n-            factory = DocumentFactory.getInstance();\n-        }\n-\n-        return factory;\n-    }\n-\n-    /**\n-     * <p>\n-     * This sets the <code>DocumentFactory</code> used to create new\n-     * documents. This method allows the building of custom DOM4J tree objects\n-     * to be implemented easily using a custom derivation of\n-     * {@link DocumentFactory}\n-     * </p>\n-     * \n-     * @param documentFactory\n-     *            <code>DocumentFactory</code> used to create DOM4J objects\n-     */\n-    public void setDocumentFactory(DocumentFactory documentFactory) {\n-        this.factory = documentFactory;\n-    }\n-\n-    /**\n-     * DOCUMENT ME!\n-     * \n-     * @return the <code>ErrorHandler</code> used by SAX\n-     */\n-    public ErrorHandler getErrorHandler() {\n-        return errorHandler;\n-    }\n-\n-    /**\n-     * Sets the <code>ErrorHandler</code> used by the SAX\n-     * <code>XMLReader</code>.\n-     * \n-     * @param errorHandler\n-     *            is the <code>ErrorHandler</code> used by SAX\n-     */\n-    public void setErrorHandler(ErrorHandler errorHandler) {\n-        this.errorHandler = errorHandler;\n-    }\n-\n-    /**\n-     * Returns the current entity resolver used to resolve entities\n-     * \n-     * @return DOCUMENT ME!\n-     */\n-    public EntityResolver getEntityResolver() {\n-        return entityResolver;\n-    }\n-\n-    /**\n-     * Sets the entity resolver used to resolve entities.\n-     * \n-     * @param entityResolver\n-     *            DOCUMENT ME!\n-     */\n-    public void setEntityResolver(EntityResolver entityResolver) {\n-        this.entityResolver = entityResolver;\n-    }\n-\n-    /**\n-     * DOCUMENT ME!\n-     * \n-     * @return the <code>XMLReader</code> used to parse SAX events\n-     * \n-     * @throws SAXException\n-     *             DOCUMENT ME!\n-     */\n-    public XMLReader getXMLReader() throws SAXException {\n-        if (xmlReader == null) {\n-            xmlReader = createXMLReader();\n-        }\n-\n-        return xmlReader;\n-    }\n-\n-    /**\n-     * Sets the <code>XMLReader</code> used to parse SAX events\n-     * \n-     * @param reader\n-     *            is the <code>XMLReader</code> to parse SAX events\n-     */\n-    public void setXMLReader(XMLReader reader) {\n-        this.xmlReader = reader;\n-    }\n-\n-    /**\n-     * Returns encoding used for InputSource (null means system default\n-     * encoding)\n-     * \n-     * @return encoding used for InputSource\n-     * \n-     */\n-    public String getEncoding() {\n-        return encoding;\n-    }\n-\n-    /**\n-     * Sets encoding used for InputSource (null means system default encoding)\n-     * \n-     * @param encoding\n-     *            is encoding used for InputSource\n-     */\n-    public void setEncoding(String encoding) {\n-        this.encoding = encoding;\n-    }\n-\n-    /**\n-     * Sets the class name of the <code>XMLReader</code> to be used to parse\n-     * SAX events.\n-     * \n-     * @param xmlReaderClassName\n-     *            is the class name of the <code>XMLReader</code> to parse SAX\n-     *            events\n-     * \n-     * @throws SAXException\n-     *             DOCUMENT ME!\n-     */\n-    public void setXMLReaderClassName(String xmlReaderClassName)\n-            throws SAXException {\n-        setXMLReader(XMLReaderFactory.createXMLReader(xmlReaderClassName));\n-    }\n-\n-    /**\n-     * Adds the <code>ElementHandler</code> to be called when the specified\n-     * path is encounted.\n-     * \n-     * @param path\n-     *            is the path to be handled\n-     * @param handler\n-     *            is the <code>ElementHandler</code> to be called by the event\n-     *            based processor.\n-     */\n-    public void addHandler(String path, ElementHandler handler) {\n-        getDispatchHandler().addHandler(path, handler);\n-    }\n-\n-    /**\n-     * Removes the <code>ElementHandler</code> from the event based processor,\n-     * for the specified path.\n-     * \n-     * @param path\n-     *            is the path to remove the <code>ElementHandler</code> for.\n-     */\n-    public void removeHandler(String path) {\n-        getDispatchHandler().removeHandler(path);\n-    }\n-\n-    /**\n-     * When multiple <code>ElementHandler</code> instances have been\n-     * registered, this will set a default <code>ElementHandler</code> to be\n-     * called for any path which does <b>NOT </b> have a handler registered.\n-     * \n-     * @param handler\n-     *            is the <code>ElementHandler</code> to be called by the event\n-     *            based processor.\n-     */\n-    public void setDefaultHandler(ElementHandler handler) {\n-        getDispatchHandler().setDefaultHandler(handler);\n-    }\n-\n-    /**\n-     * This method clears out all the existing handlers and default handler\n-     * setting things back as if no handler existed. Useful when reusing an\n-     * object instance.\n-     */\n-    public void resetHandlers() {\n-        getDispatchHandler().resetHandlers();\n-    }\n-\n-    /**\n-     * Returns the SAX filter being used to filter SAX events.\n-     * \n-     * @return the SAX filter being used or null if no SAX filter is installed\n-     */\n-    public XMLFilter getXMLFilter() {\n-        return xmlFilter;\n-    }\n-\n-    /**\n-     * Sets the SAX filter to be used when filtering SAX events\n-     * \n-     * @param filter\n-     *            is the SAX filter to use or null to disable filtering\n-     */\n-    public void setXMLFilter(XMLFilter filter) {\n-        this.xmlFilter = filter;\n-    }\n-\n-    // Implementation methods\n-    // -------------------------------------------------------------------------\n-\n-    /**\n-     * Installs any XMLFilter objects required to allow the SAX event stream to\n-     * be filtered and preprocessed before it gets to dom4j.\n-     * \n-     * @param reader\n-     *            DOCUMENT ME!\n-     * \n-     * @return the new XMLFilter if applicable or the original XMLReader if no\n-     *         filter is being used.\n-     */\n-    protected XMLReader installXMLFilter(XMLReader reader) {\n-        XMLFilter filter = getXMLFilter();\n-\n-        if (filter != null) {\n-            // find the root XMLFilter\n-            XMLFilter root = filter;\n-\n-            while (true) {\n-                XMLReader parent = root.getParent();\n-\n-                if (parent instanceof XMLFilter) {\n-                    root = (XMLFilter) parent;\n-                } else {\n-                    break;\n-                }\n-            }\n-\n-            root.setParent(reader);\n-\n-            return filter;\n-        }\n-\n-        return reader;\n-    }\n-\n-    protected DispatchHandler getDispatchHandler() {\n-        if (dispatchHandler == null) {\n-            dispatchHandler = new DispatchHandler();\n-        }\n-\n-        return dispatchHandler;\n-    }\n-\n-    protected void setDispatchHandler(DispatchHandler dispatchHandler) {\n-        this.dispatchHandler = dispatchHandler;\n-    }\n-\n-    /**\n-     * Factory Method to allow alternate methods of creating and configuring\n-     * XMLReader objects\n-     * \n-     * @return DOCUMENT ME!\n-     * \n-     * @throws SAXException\n-     *             DOCUMENT ME!\n-     */\n-    protected XMLReader createXMLReader() throws SAXException {\n-        return SAXHelper.createXMLReader(isValidating());\n-    }\n-\n-    /**\n-     * Configures the XMLReader before use\n-     * \n-     * @param reader\n-     *            DOCUMENT ME!\n-     * @param handler\n-     *            DOCUMENT ME!\n-     * \n-     * @throws DocumentException\n-     *             DOCUMENT ME!\n-     */\n-    protected void configureReader(XMLReader reader, DefaultHandler handler)\n-            throws DocumentException {\n-        // configure lexical handling\n-        SAXHelper.setParserProperty(reader, SAX_LEXICALHANDLER, handler);\n-\n-        // try alternate property just in case\n-        SAXHelper.setParserProperty(reader, SAX_LEXICAL_HANDLER, handler);\n-\n-        // register the DeclHandler\n-        if (includeInternalDTDDeclarations || includeExternalDTDDeclarations) {\n-            SAXHelper.setParserProperty(reader, SAX_DECL_HANDLER, handler);\n-        }\n-\n-        // string interning\n-        SAXHelper.setParserFeature(reader, SAX_STRING_INTERNING,\n-                isStringInternEnabled());\n-\n-        try {\n-            // configure validation support\n-            reader.setFeature(\"http://xml.org/sax/features/validation\",\n-                    isValidating());\n-\n-            if (errorHandler != null) {\n-                reader.setErrorHandler(errorHandler);\n-            } else {\n-                reader.setErrorHandler(handler);\n-            }\n-        } catch (Exception e) {\n-            if (isValidating()) {\n-                throw new DocumentException(\"Validation not supported for\"\n-                        + \" XMLReader: \" + reader, e);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Factory Method to allow user derived SAXContentHandler objects to be used\n-     * \n-     * @param reader\n-     *            DOCUMENT ME!\n-     * \n-     * @return DOCUMENT ME!\n-     */\n-    protected SAXContentHandler createContentHandler(XMLReader reader) {\n-        return new SAXContentHandler(getDocumentFactory(), dispatchHandler);\n-    }\n-\n-    protected EntityResolver createDefaultEntityResolver(String systemId) {\n-        String prefix = null;\n-\n-        if ((systemId != null) && (systemId.length() > 0)) {\n-            int idx = systemId.lastIndexOf('/');\n-\n-            if (idx > 0) {\n-                prefix = systemId.substring(0, idx + 1);\n-            }\n-        }\n-\n-        return new SAXEntityResolver(prefix);\n-    }\n-\n-    protected static class SAXEntityResolver implements EntityResolver,\n-            Serializable {\n-        protected String uriPrefix;\n-\n-        public SAXEntityResolver(String uriPrefix) {\n-            this.uriPrefix = uriPrefix;\n-        }\n-\n-        public InputSource resolveEntity(String publicId, String systemId) {\n-            // try create a relative URI reader...\n-            if ((systemId != null) && (systemId.length() > 0)) {\n-                if ((uriPrefix != null) && (systemId.indexOf(':') <= 0)) {\n-                    systemId = uriPrefix + systemId;\n-                }\n-            }\n-\n-            return new InputSource(systemId);\n-        }\n+      return new InputSource(systemId);\n     }\n+  }\n }\n \n /*\n  * Redistribution and use of this software and associated documentation\n  * (\"Software\"), with or without modification, are permitted provided that the\n  * following conditions are met:\n- * \n+ *\n  * 1. Redistributions of source code must retain copyright statements and\n  * notices. Redistributions must also contain a copy of this document.\n- * \n+ *\n  * 2. Redistributions in binary form must reproduce the above copyright notice,\n  * this list of conditions and the following disclaimer in the documentation\n  * and/or other materials provided with the distribution.\n- * \n+ *\n  * 3. The name \"DOM4J\" must not be used to endorse or promote products derived\n  * from this Software without prior written permission of MetaStuff, Ltd. For\n  * written permission, please contact dom4j-info@metastuff.com.\n- * \n+ *\n  * 4. Products derived from this Software may not be called \"DOM4J\" nor may\n  * \"DOM4J\" appear in their names without prior written permission of MetaStuff,\n  * Ltd. DOM4J is a registered trademark of MetaStuff, Ltd.\n- * \n+ *\n  * 5. Due credit should be given to the DOM4J Project - http://www.dom4j.org\n- * \n+ *\n  * THIS SOFTWARE IS PROVIDED BY METASTUFF, LTD. AND CONTRIBUTORS ``AS IS'' AND\n  * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n@@ -1000,6 +1016,6 @@ public InputSource resolveEntity(String publicId, String systemId) {\n  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n  * POSSIBILITY OF SUCH DAMAGE.\n- * \n+ *\n  * Copyright 2001-2005 (C) MetaStuff, Ltd. All Rights Reserved.\n  */",
    "function_modified_lines": {
      "added": [
        "import javax.xml.parsers.SAXParserFactory;\n",
        "\n",
        " * <p>\n",
        " * <p>\n",
        " * <p>\n",
        " * <p>\n",
        " * <p>\n",
        " * <p>\n"
      ],
      "deleted": [
        " *\n",
        " *\n",
        " *\n",
        " *\n",
        " *\n",
        " *\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "dom4j before 2.0.3 and 2.1.x before 2.1.3 allows external DTDs and External Entities by default, which might enable XXE attacks. However, there is popular external documentation from OWASP showing how to enable the safe, non-default behavior in any application that uses dom4j.",
    "id": 12089
  },
  {
    "cve_id": "CVE-2020-10990",
    "code_before_change": "/*\n\n    Copyright 2018-2020 Accenture Technology\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n        http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n */\n\npackage org.platformlambda.core.serializers;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.w3c.dom.*;\nimport org.xml.sax.SAXException;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class SimpleXmlParser {\n    private static final Logger log = LoggerFactory.getLogger(SimpleXmlParser.class);\n\n    private static final String VALUE = \"value\";\n    private static List<String> defaultDrop = new ArrayList<>();\n    private List<String> drop = new ArrayList<>();\n\n    public static void setDefaultDropAttributes(List<String> attributesToIgnore) {\n        if (attributesToIgnore != null) {\n            SimpleXmlParser.defaultDrop = attributesToIgnore;\n            log.info(\"Default XML attributes to ignore - {}\", attributesToIgnore);\n        }\n    }\n\n    public void setDropAttributes(List<String> attributesToIgnore) {\n        if (attributesToIgnore != null) {\n            this.drop = attributesToIgnore;\n            log.info(\"XML attributes to ignore - {}\", attributesToIgnore);\n        }\n    }\n\n    public Map<String, Object> parse(String xml) throws IOException {\n        return parse(new ByteArrayInputStream(xml.getBytes(\"UTF-8\")));\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public Map<String, Object> parse(InputStream res) throws IOException {\n        Map<String, Object> map = new HashMap<>();\n\n        Document doc;\n        try {\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            doc = dBuilder.parse(res);\n            doc.getDocumentElement().normalize();\n        } catch (ParserConfigurationException | SAXException e) {\n            // Simplify by converting to IOException\n            throw new IOException(e);\n        }\n\n        Element root = doc.getDocumentElement();\n\n        Map<String, Object> rootMap = new HashMap<>();\n        map.put(root.getNodeName(), rootMap);\n\n        NamedNodeMap attributes = root.getAttributes();\n        int count = attributes.getLength();\n        for (int i=0; i < count; i++) {\n            rootMap.put(attributes.item(i).getNodeName(), attributes.item(i).getNodeValue());\n        }\n\n        NodeList nodes = root.getChildNodes();\n        if (nodes != null && nodes.getLength() > 0) {\n            int len = nodes.getLength();\n            for (int i=0; i < len; i++) {\n                parseXML(nodes.item(i), rootMap, root.getNodeName(), rootMap);\n            }\n        }\n        /*\n         * Extract root node if any\n         */\n        if (map.size() == 1) {\n            for (String key : map.keySet()) {\n                Object rootNode = map.get(key);\n                if (rootNode instanceof Map) {\n                    return (Map<String, Object>) rootNode;\n                }\n            }\n        }\n        return map;\n    }\n\n    private void parseXML(Node node, Map<String, Object> parent, String grandParentName, Map<String, Object> grandParent) {\n\n        if (node.getNodeType() == Node.TEXT_NODE) {\n            String value = node.getTextContent().trim();\n            if (value.length() > 0) {\n                boolean hasAttributes = false;\n                if (grandParent.containsKey(grandParentName)) {\n                    hasAttributes = true;\n                    if (parent.isEmpty()) {\n                        grandParent.put(grandParentName, value);\n                    } else {\n                        parent.put(VALUE, value);\n                    }\n\n                }\n                if (!hasAttributes) {\n                    additivePut(grandParent, grandParentName, value);\n                }\n            }\n        }\n        if (node.getNodeType() == Node.ELEMENT_NODE) {\n            Map<String, Object> childMap = new HashMap<>();\n            additivePut(parent, node.getNodeName(), childMap);\n\n            NamedNodeMap attributes = node.getAttributes();\n            if (attributes != null) {\n                int count = attributes.getLength();\n                for (int i=0; i < count; i++) {\n                    String attributeName = attributes.item(i).getNodeName();\n                    if (!canIgnore(attributeName)) {\n                        additivePut(childMap, attributeName, attributes.item(i).getNodeValue());\n                    }\n                }\n            }\n            NodeList nodes = node.getChildNodes();\n            if (nodes != null && nodes.getLength() > 0) {\n                int len = nodes.getLength();\n                for (int i=0; i < len; i++) {\n                    parseXML(nodes.item(i), childMap, node.getNodeName(), parent);\n                }\n            }\n\n        }\n    }\n\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    private void additivePut(Map<String, Object> map, String key, Object value) {\n        if (map.containsKey(key)) {\n            // turn into array\n            Object o = map.get(key);\n            if (o instanceof List) {\n                List list = (List) o;\n                list.add(value);\n            } else {\n                // skip empty map\n                if (o instanceof Map) {\n                    Map om = (Map) o;\n                    if (om.isEmpty()) {\n                        map.put(key, value);\n                        return;\n                    }\n                }\n                List<Object> nList = new ArrayList<>();\n                nList.add(o);\n                nList.add(value);\n                map.put(key, nList);\n            }\n\n        } else {\n            map.put(key, value);\n        }\n    }\n\n    private boolean canIgnore(String attributeName) {\n        return !drop.isEmpty() ? drop.contains(attributeName) : SimpleXmlParser.defaultDrop.contains(attributeName);\n    }\n\n}\n",
    "code_after_change": "{\n    private static final Logger log = LoggerFactory.getLogger(SimpleXmlParser.class);\n\n    /*\n     * Acknowledgement:\n     *\n     * The solution to avoid XML external entity (XXE) injection attack was contributed by Sajeeb Lohani\n     * (github handles @prodigysml and @n33dle) on 1/6/2020.\n     *\n     * The corresponding Unit test is org.platformlambda.core.util.XmlParserFeatureTest\n     */\n    private static final String[] FEATURES_TO_ENABLE = {\n            \"http://apache.org/xml/features/disallow-doctype-decl\"\n    };\n    private static final String[] FEATURES_TO_DISABLE = {\n            \"http://xml.org/sax/features/external-general-entities\",\n            \"http://xml.org/sax/features/external-parameter-entities\",\n            \"http://apache.org/xml/features/nonvalidating/load-external-dtd\"\n    };\n\n    private static final String VALUE = \"value\";\n    private static List<String> defaultDrop = new ArrayList<>();\n    private List<String> drop = new ArrayList<>();\n\n    public static void setDefaultDropAttributes(List<String> attributesToIgnore) {\n        if (attributesToIgnore != null) {\n            SimpleXmlParser.defaultDrop = attributesToIgnore;\n            log.info(\"Default XML attributes to ignore - {}\", attributesToIgnore);\n        }\n    }\n\n    public void setDropAttributes(List<String> attributesToIgnore) {\n        if (attributesToIgnore != null) {\n            this.drop = attributesToIgnore;\n            log.info(\"XML attributes to ignore - {}\", attributesToIgnore);\n        }\n    }\n\n    public Map<String, Object> parse(String xml) throws IOException {\n        return parse(new ByteArrayInputStream(xml.getBytes(StandardCharsets.UTF_8)));\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public Map<String, Object> parse(InputStream res) throws IOException {\n        Map<String, Object> map = new HashMap<>();\n\n        Document doc;\n        try {\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            for (String feature: FEATURES_TO_ENABLE) {\n                setFeature(dbf, feature, true);\n            }\n            for (String feature: FEATURES_TO_DISABLE) {\n                setFeature(dbf, feature, false);\n            }\n            dbf.setXIncludeAware(false);\n            dbf.setExpandEntityReferences(false);\n            DocumentBuilder dBuilder = dbf.newDocumentBuilder();\n            dBuilder.setErrorHandler(null);\n            doc = dBuilder.parse(res);\n            doc.getDocumentElement().normalize();\n        } catch (ParserConfigurationException | SAXException e) {\n            // Simplify by converting to IOException\n            throw new IOException(e);\n        }\n\n        Element root = doc.getDocumentElement();\n\n        Map<String, Object> rootMap = new HashMap<>();\n        map.put(root.getNodeName(), rootMap);\n\n        NamedNodeMap attributes = root.getAttributes();\n        int count = attributes.getLength();\n        for (int i=0; i < count; i++) {\n            rootMap.put(attributes.item(i).getNodeName(), attributes.item(i).getNodeValue());\n        }\n\n        NodeList nodes = root.getChildNodes();\n        if (nodes != null && nodes.getLength() > 0) {\n            int len = nodes.getLength();\n            for (int i=0; i < len; i++) {\n                parseXML(nodes.item(i), rootMap, root.getNodeName(), rootMap);\n            }\n        }\n        /*\n         * Extract root node if any\n         */\n        if (map.size() == 1) {\n            for (String key : map.keySet()) {\n                Object rootNode = map.get(key);\n                if (rootNode instanceof Map) {\n                    return (Map<String, Object>) rootNode;\n                }\n            }\n        }\n        return map;\n    }\n\n    private void parseXML(Node node, Map<String, Object> parent, String grandParentName, Map<String, Object> grandParent) {\n        if (node.getNodeType() == Node.TEXT_NODE) {\n            String value = node.getTextContent().trim();\n            if (value.length() > 0) {\n                boolean hasAttributes = false;\n                if (grandParent.containsKey(grandParentName)) {\n                    hasAttributes = true;\n                    if (parent.isEmpty()) {\n                        grandParent.put(grandParentName, value);\n                    } else {\n                        parent.put(VALUE, value);\n                    }\n\n                }\n                if (!hasAttributes) {\n                    additivePut(grandParent, grandParentName, value);\n                }\n            }\n        }\n        if (node.getNodeType() == Node.ELEMENT_NODE) {\n            Map<String, Object> childMap = new HashMap<>();\n            additivePut(parent, node.getNodeName(), childMap);\n\n            NamedNodeMap attributes = node.getAttributes();\n            if (attributes != null) {\n                int count = attributes.getLength();\n                for (int i=0; i < count; i++) {\n                    String attributeName = attributes.item(i).getNodeName();\n                    if (!canIgnore(attributeName)) {\n                        additivePut(childMap, attributeName, attributes.item(i).getNodeValue());\n                    }\n                }\n            }\n            NodeList nodes = node.getChildNodes();\n            if (nodes != null && nodes.getLength() > 0) {\n                int len = nodes.getLength();\n                for (int i=0; i < len; i++) {\n                    parseXML(nodes.item(i), childMap, node.getNodeName(), parent);\n                }\n            }\n\n        }\n    }\n\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    private void additivePut(Map<String, Object> map, String key, Object value) {\n        if (map.containsKey(key)) {\n            // turn into array\n            Object o = map.get(key);\n            if (o instanceof List) {\n                List list = (List) o;\n                list.add(value);\n            } else {\n                // skip empty map\n                if (o instanceof Map) {\n                    Map om = (Map) o;\n                    if (om.isEmpty()) {\n                        map.put(key, value);\n                        return;\n                    }\n                }\n                List<Object> nList = new ArrayList<>();\n                nList.add(o);\n                nList.add(value);\n                map.put(key, nList);\n            }\n\n        } else {\n            map.put(key, value);\n        }\n    }\n\n    private boolean canIgnore(String attributeName) {\n        return !drop.isEmpty() ? drop.contains(attributeName) : SimpleXmlParser.defaultDrop.contains(attributeName);\n    }\n\n    private boolean setFeature(DocumentBuilderFactory dbf, String feature, boolean enable) {\n        try {\n            dbf.setFeature(feature, enable);\n            return dbf.getFeature(feature) == enable;\n        } catch (ParserConfigurationException e) {\n            log.error(\"Unable to {} feature - {}\", enable? \"enable\" : \"disable\", e.getMessage());\n            return false;\n        }\n    }\n\n}",
    "patch": "@@ -29,6 +29,7 @@\n import java.io.ByteArrayInputStream;\n import java.io.IOException;\n import java.io.InputStream;\n+import java.nio.charset.StandardCharsets;\n import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.List;\n@@ -37,6 +38,23 @@\n public class SimpleXmlParser {\n     private static final Logger log = LoggerFactory.getLogger(SimpleXmlParser.class);\n \n+    /*\n+     * Acknowledgement:\n+     *\n+     * The solution to avoid XML external entity (XXE) injection attack was contributed by Sajeeb Lohani\n+     * (github handles @prodigysml and @n33dle) on 1/6/2020.\n+     *\n+     * The corresponding Unit test is org.platformlambda.core.util.XmlParserFeatureTest\n+     */\n+    private static final String[] FEATURES_TO_ENABLE = {\n+            \"http://apache.org/xml/features/disallow-doctype-decl\"\n+    };\n+    private static final String[] FEATURES_TO_DISABLE = {\n+            \"http://xml.org/sax/features/external-general-entities\",\n+            \"http://xml.org/sax/features/external-parameter-entities\",\n+            \"http://apache.org/xml/features/nonvalidating/load-external-dtd\"\n+    };\n+\n     private static final String VALUE = \"value\";\n     private static List<String> defaultDrop = new ArrayList<>();\n     private List<String> drop = new ArrayList<>();\n@@ -56,7 +74,7 @@ public void setDropAttributes(List<String> attributesToIgnore) {\n     }\n \n     public Map<String, Object> parse(String xml) throws IOException {\n-        return parse(new ByteArrayInputStream(xml.getBytes(\"UTF-8\")));\n+        return parse(new ByteArrayInputStream(xml.getBytes(StandardCharsets.UTF_8)));\n     }\n \n     @SuppressWarnings(\"unchecked\")\n@@ -65,8 +83,17 @@ public Map<String, Object> parse(InputStream res) throws IOException {\n \n         Document doc;\n         try {\n-            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n-            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n+            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n+            for (String feature: FEATURES_TO_ENABLE) {\n+                setFeature(dbf, feature, true);\n+            }\n+            for (String feature: FEATURES_TO_DISABLE) {\n+                setFeature(dbf, feature, false);\n+            }\n+            dbf.setXIncludeAware(false);\n+            dbf.setExpandEntityReferences(false);\n+            DocumentBuilder dBuilder = dbf.newDocumentBuilder();\n+            dBuilder.setErrorHandler(null);\n             doc = dBuilder.parse(res);\n             doc.getDocumentElement().normalize();\n         } catch (ParserConfigurationException | SAXException e) {\n@@ -107,7 +134,6 @@ public Map<String, Object> parse(InputStream res) throws IOException {\n     }\n \n     private void parseXML(Node node, Map<String, Object> parent, String grandParentName, Map<String, Object> grandParent) {\n-\n         if (node.getNodeType() == Node.TEXT_NODE) {\n             String value = node.getTextContent().trim();\n             if (value.length() > 0) {\n@@ -183,4 +209,14 @@ private boolean canIgnore(String attributeName) {\n         return !drop.isEmpty() ? drop.contains(attributeName) : SimpleXmlParser.defaultDrop.contains(attributeName);\n     }\n \n+    private boolean setFeature(DocumentBuilderFactory dbf, String feature, boolean enable) {\n+        try {\n+            dbf.setFeature(feature, enable);\n+            return dbf.getFeature(feature) == enable;\n+        } catch (ParserConfigurationException e) {\n+            log.error(\"Unable to {} feature - {}\", enable? \"enable\" : \"disable\", e.getMessage());\n+            return false;\n+        }\n+    }\n+\n }",
    "function_modified_lines": {
      "added": [
        "    private boolean setFeature(DocumentBuilderFactory dbf, String feature, boolean enable) {\n",
        "        try {\n",
        "            dbf.setFeature(feature, enable);\n",
        "            return dbf.getFeature(feature) == enable;\n",
        "        } catch (ParserConfigurationException e) {\n",
        "            log.error(\"Unable to {} feature - {}\", enable? \"enable\" : \"disable\", e.getMessage());\n",
        "            return false;\n",
        "        }\n",
        "    }\n",
        "\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "An XXE issue exists in Accenture Mercury before 1.12.28 because of the platformlambda/core/serializers/SimpleXmlParser.java component.",
    "id": 12141
  },
  {
    "cve_id": "CVE-2020-13692",
    "code_before_change": " */\n\npackage org.postgresql.jdbc;\n\nimport org.postgresql.Driver;\nimport org.postgresql.PGNotification;\nimport org.postgresql.PGProperty;\nimport org.postgresql.copy.CopyManager;\nimport org.postgresql.core.BaseConnection;\nimport org.postgresql.core.BaseStatement;\nimport org.postgresql.core.CachedQuery;\nimport org.postgresql.core.ConnectionFactory;\nimport org.postgresql.core.Encoding;\nimport org.postgresql.core.Oid;\nimport org.postgresql.core.Provider;\nimport org.postgresql.core.Query;\nimport org.postgresql.core.QueryExecutor;\nimport org.postgresql.core.ReplicationProtocol;\nimport org.postgresql.core.ResultHandlerBase;\nimport org.postgresql.core.ServerVersion;\nimport org.postgresql.core.SqlCommand;\nimport org.postgresql.core.TransactionState;\nimport org.postgresql.core.TypeInfo;\nimport org.postgresql.core.Utils;\nimport org.postgresql.core.Version;\nimport org.postgresql.fastpath.Fastpath;\nimport org.postgresql.largeobject.LargeObjectManager;\nimport org.postgresql.replication.PGReplicationConnection;\nimport org.postgresql.replication.PGReplicationConnectionImpl;\nimport org.postgresql.util.GT;\nimport org.postgresql.util.HostSpec;\nimport org.postgresql.util.LruCache;\nimport org.postgresql.util.PGBinaryObject;\nimport org.postgresql.util.PGobject;\nimport org.postgresql.util.PSQLException;\nimport org.postgresql.util.PSQLState;\n\nimport java.io.IOException;\nimport java.sql.Array;\nimport java.sql.Blob;\nimport java.sql.CallableStatement;\nimport java.sql.ClientInfoStatus;\nimport java.sql.Clob;\nimport java.sql.Connection;\nimport java.sql.DatabaseMetaData;\nimport java.sql.NClob;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLClientInfoException;\nimport java.sql.SQLException;\nimport java.sql.SQLPermission;\nimport java.sql.SQLWarning;\nimport java.sql.SQLXML;\nimport java.sql.Savepoint;\nimport java.sql.Statement;\nimport java.sql.Struct;\nimport java.sql.Types;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TimeZone;\nimport java.util.Timer;\nimport java.util.TimerTask;\nimport java.util.concurrent.Executor;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n",
    "code_after_change": "package org.postgresql.jdbc;\n\nimport org.postgresql.Driver;\nimport org.postgresql.PGNotification;\nimport org.postgresql.PGProperty;\nimport org.postgresql.copy.CopyManager;\nimport org.postgresql.core.BaseConnection;\nimport org.postgresql.core.BaseStatement;\nimport org.postgresql.core.CachedQuery;\nimport org.postgresql.core.ConnectionFactory;\nimport org.postgresql.core.Encoding;\nimport org.postgresql.core.Oid;\nimport org.postgresql.core.Provider;\nimport org.postgresql.core.Query;\nimport org.postgresql.core.QueryExecutor;\nimport org.postgresql.core.ReplicationProtocol;\nimport org.postgresql.core.ResultHandlerBase;\nimport org.postgresql.core.ServerVersion;\nimport org.postgresql.core.SqlCommand;\nimport org.postgresql.core.TransactionState;\nimport org.postgresql.core.TypeInfo;\nimport org.postgresql.core.Utils;\nimport org.postgresql.core.Version;\nimport org.postgresql.fastpath.Fastpath;\nimport org.postgresql.largeobject.LargeObjectManager;\nimport org.postgresql.replication.PGReplicationConnection;\nimport org.postgresql.replication.PGReplicationConnectionImpl;\nimport org.postgresql.util.GT;\nimport org.postgresql.util.HostSpec;\nimport org.postgresql.util.LruCache;\nimport org.postgresql.util.PGBinaryObject;\nimport org.postgresql.util.PGobject;\nimport org.postgresql.util.PSQLException;\nimport org.postgresql.util.PSQLState;\nimport org.postgresql.xml.DefaultPGXmlFactoryFactory;\nimport org.postgresql.xml.LegacyInsecurePGXmlFactoryFactory;\nimport org.postgresql.xml.PGXmlFactoryFactory;\n\nimport java.io.IOException;\nimport java.sql.Array;\nimport java.sql.Blob;\nimport java.sql.CallableStatement;\nimport java.sql.ClientInfoStatus;\nimport java.sql.Clob;\nimport java.sql.Connection;\nimport java.sql.DatabaseMetaData;\nimport java.sql.NClob;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLClientInfoException;\nimport java.sql.SQLException;\nimport java.sql.SQLPermission;\nimport java.sql.SQLWarning;\nimport java.sql.SQLXML;\nimport java.sql.Savepoint;\nimport java.sql.Statement;\nimport java.sql.Struct;\nimport java.sql.Types;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TimeZone;\nimport java.util.Timer;\nimport java.util.TimerTask;\nimport java.util.concurrent.Executor;\nimport java.util.logging.Level;",
    "patch": "@@ -37,6 +37,9 @@\n import org.postgresql.util.PGobject;\n import org.postgresql.util.PSQLException;\n import org.postgresql.util.PSQLState;\n+import org.postgresql.xml.DefaultPGXmlFactoryFactory;\n+import org.postgresql.xml.LegacyInsecurePGXmlFactoryFactory;\n+import org.postgresql.xml.PGXmlFactoryFactory;\n \n import java.io.IOException;\n import java.sql.Array;\n@@ -156,6 +159,9 @@ private enum ReadOnlyBehavior {\n \n   private final LruCache<FieldMetadata.Key, FieldMetadata> fieldMetadataCache;\n \n+  private final String xmlFactoryFactoryClass;\n+  private PGXmlFactoryFactory xmlFactoryFactory;\n+\n   final CachedQuery borrowQuery(String sql) throws SQLException {\n     return queryExecutor.borrowQuery(sql);\n   }\n@@ -311,6 +317,8 @@ public TimeZone get() {\n         false);\n \n     replicationConnection = PGProperty.REPLICATION.get(info) != null;\n+\n+    xmlFactoryFactoryClass = PGProperty.XML_FACTORY_FACTORY.get(info);\n   }\n \n   private static ReadOnlyBehavior getReadOnlyBehavior(String property) {\n@@ -1823,4 +1831,36 @@ public final String getParameterStatus(String parameterName) {\n     return queryExecutor.getParameterStatus(parameterName);\n   }\n \n+  @Override\n+  public PGXmlFactoryFactory getXmlFactoryFactory() throws SQLException {\n+    if (xmlFactoryFactory == null) {\n+      if (xmlFactoryFactoryClass == null || xmlFactoryFactoryClass.equals(\"\")) {\n+        xmlFactoryFactory = DefaultPGXmlFactoryFactory.INSTANCE;\n+      } else if (xmlFactoryFactoryClass.equals(\"LEGACY_INSECURE\")) {\n+        xmlFactoryFactory = LegacyInsecurePGXmlFactoryFactory.INSTANCE;\n+      } else {\n+        Class<?> clazz;\n+        try {\n+          clazz = Class.forName(xmlFactoryFactoryClass);\n+        } catch (ClassNotFoundException ex) {\n+          throw new PSQLException(\n+              GT.tr(\"Could not instantiate xmlFactoryFactory: {0}\", xmlFactoryFactoryClass),\n+              PSQLState.INVALID_PARAMETER_VALUE, ex);\n+        }\n+        if (!clazz.isAssignableFrom(PGXmlFactoryFactory.class)) {\n+          throw new PSQLException(\n+              GT.tr(\"Connection property xmlFactoryFactory must implement PGXmlFactoryFactory: {0}\", xmlFactoryFactoryClass),\n+              PSQLState.INVALID_PARAMETER_VALUE);\n+        }\n+        try {\n+          xmlFactoryFactory = (PGXmlFactoryFactory) clazz.newInstance();\n+        } catch (Exception ex) {\n+          throw new PSQLException(\n+              GT.tr(\"Could not instantiate xmlFactoryFactory: {0}\", xmlFactoryFactoryClass),\n+              PSQLState.INVALID_PARAMETER_VALUE, ex);\n+        }\n+      }\n+    }\n+    return xmlFactoryFactory;\n+  }\n }",
    "function_modified_lines": {
      "added": [
        "import org.postgresql.xml.DefaultPGXmlFactoryFactory;\n",
        "import org.postgresql.xml.LegacyInsecurePGXmlFactoryFactory;\n",
        "import org.postgresql.xml.PGXmlFactoryFactory;\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "PostgreSQL JDBC Driver (aka PgJDBC) before 42.2.13 allows XXE.",
    "id": 12144
  },
  {
    "cve_id": "CVE-2021-41098",
    "code_before_change": "package nokogiri;\n\nimport static nokogiri.XmlSaxPushParser.terminateExecution;\nimport static nokogiri.internals.NokogiriHelpers.getNokogiriClass;\nimport static org.jruby.runtime.Helpers.invoke;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.InputStream;\nimport java.io.IOException;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.FutureTask;\nimport java.util.concurrent.ThreadFactory;\n\nimport nokogiri.internals.*;\n\nimport org.jruby.Ruby;\nimport org.jruby.RubyClass;\nimport org.jruby.RubyObject;\nimport org.jruby.anno.JRubyClass;\nimport org.jruby.anno.JRubyMethod;\nimport org.jruby.exceptions.RaiseException;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\n\n/**\n * Class for Nokogiri::HTML4::SAX::PushParser\n *\n * @author\n * @author Piotr Szmielew <p.szmielew@ava.waw.pl> - based on Nokogiri::XML::SAX::PushParser\n */\n@JRubyClass(name = \"Nokogiri::HTML4::SAX::PushParser\")\npublic class Html4SaxPushParser extends RubyObject\n{\n  ParserContext.Options options;\n  IRubyObject saxParser;\n\n  NokogiriBlockingQueueInputStream stream;\n\n  private ParserTask parserTask = null;\n  private FutureTask<Html4SaxParserContext> futureTask = null;\n  private ExecutorService executor = null;\n\n  public\n  Html4SaxPushParser(Ruby ruby, RubyClass rubyClass)\n  {\n    super(ruby, rubyClass);\n  }\n\n  @Override\n  public void\n  finalize()\n  {\n    try {\n      terminateImpl();\n    } catch (Exception e) { /* ignored */ }\n  }\n\n  @JRubyMethod\n  public IRubyObject\n  initialize_native(final ThreadContext context,\n                    IRubyObject saxParser,\n                    IRubyObject fileName,\n                    IRubyObject encoding)\n  {\n    // NOTE: Silently skips provided encoding\n    options = new ParserContext.Options(0);\n    this.saxParser = saxParser;\n    return this;\n  }\n\n  private transient IRubyObject parse_options;\n\n  private IRubyObject\n  parse_options(final ThreadContext context)\n  {\n    if (parse_options == null) {\n      parse_options = invoke(context, context.runtime.getClassFromPath(\"Nokogiri::XML::ParseOptions\"), \"new\");\n    }\n    return parse_options;\n  }\n\n  @JRubyMethod(name = \"options\")\n  public IRubyObject\n  getOptions(ThreadContext context)\n  {\n    return invoke(context, parse_options(context), \"options\");\n  }\n\n  @JRubyMethod(name = \"options=\")\n  public IRubyObject\n  setOptions(ThreadContext context, IRubyObject opts)\n  {\n    invoke(context, parse_options(context), \"options=\", opts);\n    options = new ParserContext.Options(opts.convertToInteger().getLongValue());\n    return getOptions(context);\n  }\n\n  @JRubyMethod\n  public IRubyObject\n  native_write(ThreadContext context, IRubyObject chunk, IRubyObject isLast)\n  {\n    try {\n      initialize_task(context);\n    } catch (IOException e) {\n      throw context.getRuntime().newRuntimeError(e.getMessage());\n    }\n    final ByteArrayInputStream data = NokogiriHelpers.stringBytesToStream(chunk);\n    if (data == null) {\n      terminateTask(context.runtime);\n      throw XmlSyntaxError.createHTMLSyntaxError(context.runtime).toThrowable(); // Nokogiri::HTML4::SyntaxError\n    }\n\n    int errorCount0 = parserTask.getErrorCount();\n\n    if (isLast.isTrue()) {\n      IRubyObject document = invoke(context, this, \"document\");\n      invoke(context, document, \"end_document\");\n      terminateTask(context.runtime);\n    } else {\n      try {\n        Future<Void> task = stream.addChunk(data);\n        task.get();\n      } catch (ClosedStreamException ex) {\n        // this means the stream is closed, ignore this exception\n      } catch (Exception e) {\n        throw context.runtime.newRuntimeError(e.getMessage());\n      }\n\n    }\n\n    if (!options.recover && parserTask.getErrorCount() > errorCount0) {\n      terminateTask(context.runtime);\n      throw parserTask.getLastError();\n    }\n\n    return this;\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  private void\n  initialize_task(ThreadContext context) throws IOException\n  {\n    if (futureTask == null || stream == null) {\n      stream = new NokogiriBlockingQueueInputStream();\n\n      assert saxParser != null : \"saxParser null\";\n      parserTask = new ParserTask(context, saxParser, stream);\n      futureTask = new FutureTask<Html4SaxParserContext>((Callable) parserTask);\n      executor = Executors.newSingleThreadExecutor(new ThreadFactory() {\n        @Override\n        public Thread newThread(Runnable r) {\n          Thread t = new Thread(r);\n          t.setName(\"Html4SaxPushParser\");\n          t.setDaemon(true);\n          return t;\n        }\n      });\n      executor.submit(futureTask);\n    }\n  }\n\n  private void\n  terminateTask(final Ruby runtime)\n  {\n    if (executor == null) { return; }\n\n    try {\n      terminateImpl();\n    } catch (InterruptedException e) {\n      throw runtime.newRuntimeError(e.toString());\n    } catch (Exception e) {\n      throw runtime.newRuntimeError(e.toString());\n    }\n  }\n\n  private synchronized void\n  terminateImpl() throws InterruptedException, ExecutionException\n  {\n    terminateExecution(executor, stream, futureTask);\n\n    executor = null;\n    stream = null;\n    futureTask = null;\n  }\n\n  private static Html4SaxParserContext\n  parse(final Ruby runtime, final InputStream stream)\n  {\n    RubyClass klazz = getNokogiriClass(runtime, \"Nokogiri::HTML4::SAX::ParserContext\");\n    return Html4SaxParserContext.parse_stream(runtime, klazz, stream);\n  }\n\n  static class ParserTask extends XmlSaxPushParser.ParserTask /* <Html4SaxPushParser> */\n  {\n\n    private\n    ParserTask(ThreadContext context, IRubyObject handler, InputStream stream)\n    {\n      super(context, handler, parse(context.runtime, stream), stream);\n    }\n\n    @Override\n    public Html4SaxParserContext\n    call() throws Exception\n    {\n      return (Html4SaxParserContext) super.call();\n    }\n\n  }\n\n}\n",
    "code_after_change": "package nokogiri;\n\nimport nokogiri.internals.ClosedStreamException;\nimport nokogiri.internals.NokogiriBlockingQueueInputStream;\nimport nokogiri.internals.NokogiriHelpers;\nimport nokogiri.internals.ParserContext;\nimport org.jruby.Ruby;\nimport org.jruby.RubyClass;\nimport org.jruby.RubyObject;\nimport org.jruby.anno.JRubyClass;\nimport org.jruby.anno.JRubyMethod;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.concurrent.*;\n\nimport static nokogiri.XmlSaxPushParser.terminateExecution;\nimport static nokogiri.internals.NokogiriHelpers.getNokogiriClass;\nimport static org.jruby.runtime.Helpers.invoke;\n\n/**\n * Class for Nokogiri::HTML4::SAX::PushParser\n *\n * @author\n * @author Piotr Szmielew <p.szmielew@ava.waw.pl> - based on Nokogiri::XML::SAX::PushParser\n */\n@JRubyClass(name = \"Nokogiri::HTML4::SAX::PushParser\")\npublic class Html4SaxPushParser extends RubyObject\n{\n  ParserContext.Options options;\n  IRubyObject saxParser;\n\n  NokogiriBlockingQueueInputStream stream;\n\n  private ParserTask parserTask = null;\n  private FutureTask<Html4SaxParserContext> futureTask = null;\n  private ExecutorService executor = null;\n\n  public\n  Html4SaxPushParser(Ruby ruby, RubyClass rubyClass)\n  {\n    super(ruby, rubyClass);\n  }\n\n  @Override\n  public void\n  finalize()\n  {\n    try {\n      terminateImpl();\n    } catch (Exception e) { /* ignored */ }\n  }\n\n  @JRubyMethod\n  public IRubyObject\n  initialize_native(final ThreadContext context,\n                    IRubyObject saxParser,\n                    IRubyObject fileName,\n                    IRubyObject encoding)\n  {\n    // NOTE: Silently skips provided encoding\n    options = new ParserContext.Options(0);\n    this.saxParser = saxParser;\n    return this;\n  }\n\n  private transient IRubyObject parse_options;\n\n  private IRubyObject\n  parse_options(final ThreadContext context)\n  {\n    if (parse_options == null) {\n      parse_options = invoke(context, context.runtime.getClassFromPath(\"Nokogiri::XML::ParseOptions\"), \"new\");\n    }\n    return parse_options;\n  }\n\n  @JRubyMethod(name = \"options\")\n  public IRubyObject\n  getOptions(ThreadContext context)\n  {\n    return invoke(context, parse_options(context), \"options\");\n  }\n\n  @JRubyMethod(name = \"options=\")\n  public IRubyObject\n  setOptions(ThreadContext context, IRubyObject opts)\n  {\n    invoke(context, parse_options(context), \"options=\", opts);\n    options = new ParserContext.Options(opts.convertToInteger().getLongValue());\n    return getOptions(context);\n  }\n\n  @JRubyMethod\n  public IRubyObject\n  native_write(ThreadContext context, IRubyObject chunk, IRubyObject isLast)\n  {\n    try {\n      initialize_task(context);\n    } catch (IOException e) {\n      throw context.getRuntime().newRuntimeError(e.getMessage());\n    }\n    final ByteArrayInputStream data = NokogiriHelpers.stringBytesToStream(chunk);\n    if (data == null) {\n      terminateTask(context.runtime);\n      throw XmlSyntaxError.createHTMLSyntaxError(context.runtime).toThrowable(); // Nokogiri::HTML4::SyntaxError\n    }\n\n    int errorCount0 = parserTask.getErrorCount();\n\n    if (isLast.isTrue()) {\n      IRubyObject document = invoke(context, this, \"document\");\n      invoke(context, document, \"end_document\");\n      terminateTask(context.runtime);\n    } else {\n      try {\n        Future<Void> task = stream.addChunk(data);\n        task.get();\n      } catch (ClosedStreamException ex) {\n        // this means the stream is closed, ignore this exception\n      } catch (Exception e) {\n        throw context.runtime.newRuntimeError(e.getMessage());\n      }\n\n    }\n\n    if (!options.recover && parserTask.getErrorCount() > errorCount0) {\n      terminateTask(context.runtime);\n      throw parserTask.getLastError().toThrowable();\n    }\n\n    return this;\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  private void\n  initialize_task(ThreadContext context) throws IOException\n  {\n    if (futureTask == null || stream == null) {\n      stream = new NokogiriBlockingQueueInputStream();\n\n      assert saxParser != null : \"saxParser null\";\n      parserTask = new ParserTask(context, saxParser, stream);\n      futureTask = new FutureTask<Html4SaxParserContext>((Callable) parserTask);\n      executor = Executors.newSingleThreadExecutor(new ThreadFactory() {\n        @Override\n        public Thread newThread(Runnable r) {\n          Thread t = new Thread(r);\n          t.setName(\"Html4SaxPushParser\");\n          t.setDaemon(true);\n          return t;\n        }\n      });\n      executor.submit(futureTask);\n    }\n  }\n\n  private void\n  terminateTask(final Ruby runtime)\n  {\n    if (executor == null) { return; }\n\n    try {\n      terminateImpl();\n    } catch (InterruptedException e) {\n      throw runtime.newRuntimeError(e.toString());\n    } catch (Exception e) {\n      throw runtime.newRuntimeError(e.toString());\n    }\n  }\n\n  private synchronized void\n  terminateImpl() throws InterruptedException, ExecutionException\n  {\n    terminateExecution(executor, stream, futureTask);\n\n    executor = null;\n    stream = null;\n    futureTask = null;\n  }\n\n  private static Html4SaxParserContext\n  parse(final Ruby runtime, final InputStream stream)\n  {\n    RubyClass klazz = getNokogiriClass(runtime, \"Nokogiri::HTML4::SAX::ParserContext\");\n    return Html4SaxParserContext.parse_stream(runtime, klazz, stream);\n  }\n\n  static class ParserTask extends XmlSaxPushParser.ParserTask /* <Html4SaxPushParser> */\n  {\n\n    private\n    ParserTask(ThreadContext context, IRubyObject handler, InputStream stream)\n    {\n      super(context, handler, parse(context.runtime, stream), stream);\n    }\n\n    @Override\n    public Html4SaxParserContext\n    call() throws Exception\n    {\n      return (Html4SaxParserContext) super.call();\n    }\n\n  }\n\n}\n",
    "patch": "@@ -1,31 +1,26 @@\n package nokogiri;\n \n-import static nokogiri.XmlSaxPushParser.terminateExecution;\n-import static nokogiri.internals.NokogiriHelpers.getNokogiriClass;\n-import static org.jruby.runtime.Helpers.invoke;\n-\n-import java.io.ByteArrayInputStream;\n-import java.io.InputStream;\n-import java.io.IOException;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.FutureTask;\n-import java.util.concurrent.ThreadFactory;\n-\n-import nokogiri.internals.*;\n-\n+import nokogiri.internals.ClosedStreamException;\n+import nokogiri.internals.NokogiriBlockingQueueInputStream;\n+import nokogiri.internals.NokogiriHelpers;\n+import nokogiri.internals.ParserContext;\n import org.jruby.Ruby;\n import org.jruby.RubyClass;\n import org.jruby.RubyObject;\n import org.jruby.anno.JRubyClass;\n import org.jruby.anno.JRubyMethod;\n-import org.jruby.exceptions.RaiseException;\n import org.jruby.runtime.ThreadContext;\n import org.jruby.runtime.builtin.IRubyObject;\n \n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.concurrent.*;\n+\n+import static nokogiri.XmlSaxPushParser.terminateExecution;\n+import static nokogiri.internals.NokogiriHelpers.getNokogiriClass;\n+import static org.jruby.runtime.Helpers.invoke;\n+\n /**\n  * Class for Nokogiri::HTML4::SAX::PushParser\n  *\n@@ -134,7 +129,7 @@ public class Html4SaxPushParser extends RubyObject\n \n     if (!options.recover && parserTask.getErrorCount() > errorCount0) {\n       terminateTask(context.runtime);\n-      throw parserTask.getLastError();\n+      throw parserTask.getLastError().toThrowable();\n     }\n \n     return this;",
    "function_modified_lines": {
      "added": [
        "import nokogiri.internals.ClosedStreamException;\n",
        "import nokogiri.internals.NokogiriBlockingQueueInputStream;\n",
        "import nokogiri.internals.NokogiriHelpers;\n",
        "import nokogiri.internals.ParserContext;\n",
        "import java.io.ByteArrayInputStream;\n",
        "import java.io.IOException;\n",
        "import java.io.InputStream;\n",
        "import java.util.concurrent.*;\n",
        "\n",
        "import static nokogiri.XmlSaxPushParser.terminateExecution;\n",
        "import static nokogiri.internals.NokogiriHelpers.getNokogiriClass;\n",
        "import static org.jruby.runtime.Helpers.invoke;\n",
        "\n"
      ],
      "deleted": [
        "import static nokogiri.XmlSaxPushParser.terminateExecution;\n",
        "import static nokogiri.internals.NokogiriHelpers.getNokogiriClass;\n",
        "import static org.jruby.runtime.Helpers.invoke;\n",
        "\n",
        "import java.io.ByteArrayInputStream;\n",
        "import java.io.InputStream;\n",
        "import java.io.IOException;\n",
        "import java.util.concurrent.Callable;\n",
        "import java.util.concurrent.ExecutionException;\n",
        "import java.util.concurrent.ExecutorService;\n",
        "import java.util.concurrent.Executors;\n",
        "import java.util.concurrent.Future;\n",
        "import java.util.concurrent.FutureTask;\n",
        "import java.util.concurrent.ThreadFactory;\n",
        "\n",
        "import nokogiri.internals.*;\n",
        "\n",
        "import org.jruby.exceptions.RaiseException;\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "Nokogiri is a Rubygem providing HTML, XML, SAX, and Reader parsers with XPath and CSS selector support. In Nokogiri v1.12.4 and earlier, on JRuby only, the SAX parser resolves external entities by default. Users of Nokogiri on JRuby who parse untrusted documents using any of these classes are affected: Nokogiri::XML::SAX::Parse, Nokogiri::HTML4::SAX::Parser or its alias Nokogiri::HTML::SAX::Parser, Nokogiri::XML::SAX::PushParser, and Nokogiri::HTML4::SAX::PushParser or its alias Nokogiri::HTML::SAX::PushParser. JRuby users should upgrade to Nokogiri v1.12.5 or later to receive a patch for this issue. There are no workarounds available for v1.12.4 or earlier. CRuby users are not affected.",
    "id": 12166
  },
  {
    "cve_id": "CVE-2021-41098",
    "code_before_change": "package nokogiri;\n\nimport static nokogiri.internals.NokogiriHelpers.getNokogiriClass;\nimport static org.jruby.runtime.Helpers.invoke;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.FutureTask;\nimport java.util.concurrent.ThreadFactory;\n\nimport org.jruby.Ruby;\nimport org.jruby.RubyClass;\nimport org.jruby.RubyObject;\nimport org.jruby.anno.JRubyClass;\nimport org.jruby.anno.JRubyMethod;\nimport org.jruby.exceptions.RaiseException;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\n\nimport nokogiri.internals.ClosedStreamException;\nimport nokogiri.internals.NokogiriBlockingQueueInputStream;\nimport nokogiri.internals.NokogiriHandler;\nimport nokogiri.internals.NokogiriHelpers;\nimport nokogiri.internals.ParserContext;\n\n/**\n * Class for Nokogiri::XML::SAX::PushParser\n *\n * @author Patrick Mahoney <pat@polycrystal.org>\n * @author Yoko Harada <yokolet@gmail.com>\n */\n@JRubyClass(name = \"Nokogiri::XML::SAX::PushParser\")\npublic class XmlSaxPushParser extends RubyObject\n{\n  ParserContext.Options options;\n  IRubyObject saxParser;\n\n  NokogiriBlockingQueueInputStream stream;\n\n  private ParserTask parserTask = null;\n  private FutureTask<XmlSaxParserContext> futureTask = null;\n  private ExecutorService executor = null;\n  RaiseException ex = null;\n\n  public\n  XmlSaxPushParser(Ruby ruby, RubyClass rubyClass)\n  {\n    super(ruby, rubyClass);\n  }\n\n  @Override\n  public void\n  finalize()\n  {\n    try {\n      terminateImpl();\n    } catch (Exception e) { /* ignored */ }\n  }\n\n  @JRubyMethod\n  public IRubyObject\n  initialize_native(final ThreadContext context, IRubyObject saxParser, IRubyObject fileName)\n  {\n    options = new ParserContext.Options(0);\n    this.saxParser = saxParser;\n    return this;\n  }\n\n  private transient IRubyObject parse_options;\n\n  private IRubyObject\n  parse_options(final ThreadContext context)\n  {\n    if (parse_options == null) {\n      parse_options = invoke(context, context.runtime.getClassFromPath(\"Nokogiri::XML::ParseOptions\"), \"new\");\n    }\n    return parse_options;\n  }\n\n  @JRubyMethod(name = \"options\")\n  public IRubyObject\n  getOptions(ThreadContext context)\n  {\n    return invoke(context, parse_options(context), \"options\");\n  }\n\n  @JRubyMethod(name = \"options=\")\n  public IRubyObject\n  setOptions(ThreadContext context, IRubyObject opts)\n  {\n    invoke(context, parse_options(context), \"options=\", opts);\n    options = new ParserContext.Options(opts.convertToInteger().getLongValue());\n    return getOptions(context);\n  }\n\n  /**\n   * Can take a boolean assignment.\n   *\n   * @param context\n   * @param value\n   * @return\n   */\n  @JRubyMethod(name = \"replace_entities=\")\n  public IRubyObject\n  setReplaceEntities(ThreadContext context, IRubyObject value)\n  {\n    // Ignore the value.\n    return this;\n  }\n\n  @JRubyMethod(name = \"replace_entities\")\n  public IRubyObject\n  getReplaceEntities(ThreadContext context)\n  {\n    // The java parser always replaces entities.\n    return context.getRuntime().getTrue();\n  }\n\n  @JRubyMethod\n  public IRubyObject\n  native_write(ThreadContext context, IRubyObject chunk,\n               IRubyObject isLast)\n  {\n    if (ex != null) {\n      // parser has already errored, rethrow the exception\n      throw ex;\n    }\n\n    try {\n      initialize_task(context);\n    } catch (IOException e) {\n      throw context.runtime.newRuntimeError(e.getMessage());\n    }\n    final ByteArrayInputStream data = NokogiriHelpers.stringBytesToStream(chunk);\n    if (data == null) {\n      return this;\n    }\n\n    int errorCount0 = parserTask.getErrorCount();\n\n    try {\n      Future<Void> task = stream.addChunk(data);\n      task.get();\n    } catch (ClosedStreamException ex) {\n      // this means the stream is closed, ignore this exception\n    } catch (Exception e) {\n      throw context.runtime.newRuntimeError(e.toString());\n    }\n\n    if (isLast.isTrue()) {\n      parserTask.getNokogiriHandler().endDocument();\n      terminateTask(context.runtime);\n    }\n\n    if (!options.recover && parserTask.getErrorCount() > errorCount0) {\n      terminateTask(context.runtime);\n      throw ex = parserTask.getLastError();\n    }\n\n    return this;\n  }\n\n  private void\n  initialize_task(ThreadContext context) throws IOException\n  {\n    if (futureTask == null || stream == null) {\n      stream = new NokogiriBlockingQueueInputStream();\n\n      assert saxParser != null : \"saxParser null\";\n      parserTask = new ParserTask(context, saxParser, stream);\n      futureTask = new FutureTask<XmlSaxParserContext>(parserTask);\n      executor = Executors.newSingleThreadExecutor(new ThreadFactory() {\n        @Override\n        public Thread newThread(Runnable r) {\n          Thread t = new Thread(r);\n          t.setName(\"XmlSaxPushParser\");\n          t.setDaemon(true);\n          return t;\n        }\n      });\n      executor.submit(futureTask);\n    }\n  }\n\n  private void\n  terminateTask(final Ruby runtime)\n  {\n    if (executor == null) { return; }\n\n    try {\n      terminateImpl();\n    } catch (InterruptedException e) {\n      throw runtime.newRuntimeError(e.toString());\n    } catch (Exception e) {\n      throw runtime.newRuntimeError(e.toString());\n    }\n  }\n\n  private synchronized void\n  terminateImpl() throws InterruptedException, ExecutionException\n  {\n    terminateExecution(executor, stream, futureTask);\n\n    executor = null;\n    stream = null;\n    futureTask = null;\n  }\n\n  // SHARED for Html4SaxPushParser\n  static void\n  terminateExecution(final ExecutorService executor, final NokogiriBlockingQueueInputStream stream,\n                     final FutureTask<?> futureTask)\n  throws InterruptedException, ExecutionException\n  {\n\n    if (executor == null) { return; }\n\n    try {\n      Future<Void> task = stream.addChunk(NokogiriBlockingQueueInputStream.END);\n      task.get();\n    } catch (ClosedStreamException ex) {\n      // ignore this exception, it means the stream was closed\n    }\n    futureTask.cancel(true);\n    executor.shutdown();\n  }\n\n  private static XmlSaxParserContext\n  parse(final Ruby runtime, final InputStream stream)\n  {\n    RubyClass klazz = getNokogiriClass(runtime, \"Nokogiri::XML::SAX::ParserContext\");\n    return XmlSaxParserContext.parse_stream(runtime, klazz, stream);\n  }\n\n  static class ParserTask extends ParserContext.ParserTask<XmlSaxParserContext>\n  {\n\n    final InputStream stream;\n\n    private\n    ParserTask(ThreadContext context, IRubyObject handler, InputStream stream)\n    {\n      this(context, handler, parse(context.runtime, stream), stream);\n    }\n\n    // IMPL with Html4SaxPushParser\n    protected\n    ParserTask(ThreadContext context, IRubyObject handler, XmlSaxParserContext parser, InputStream stream)\n    {\n      super(context, handler, parser);\n      this.stream = stream;\n    }\n\n    @Override\n    public XmlSaxParserContext\n    call() throws Exception\n    {\n      try {\n        parser.parse_with(context, handler);\n      } finally { stream.close(); }\n      // we have to close the stream before exiting, otherwise someone\n      // can add a chunk and block on task.get() forever.\n      return parser;\n    }\n\n    final NokogiriHandler\n    getNokogiriHandler()\n    {\n      return parser.getNokogiriHandler();\n    }\n\n    synchronized final int\n    getErrorCount()\n    {\n      // check for null because thread may not have started yet\n      if (parser.getNokogiriHandler() == null) { return 0; }\n      return parser.getNokogiriHandler().getErrorCount();\n    }\n\n    synchronized final RaiseException\n    getLastError()\n    {\n      return parser.getNokogiriHandler().getLastError();\n    }\n\n  }\n\n}\n",
    "code_after_change": "package nokogiri;\n\nimport nokogiri.internals.*;\nimport org.jruby.Ruby;\nimport org.jruby.RubyClass;\nimport org.jruby.RubyException;\nimport org.jruby.RubyObject;\nimport org.jruby.anno.JRubyClass;\nimport org.jruby.anno.JRubyMethod;\nimport org.jruby.exceptions.RaiseException;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.List;\nimport java.util.concurrent.*;\n\nimport static nokogiri.internals.NokogiriHelpers.getNokogiriClass;\nimport static org.jruby.runtime.Helpers.invoke;\n\n/**\n * Class for Nokogiri::XML::SAX::PushParser\n *\n * @author Patrick Mahoney <pat@polycrystal.org>\n * @author Yoko Harada <yokolet@gmail.com>\n */\n@JRubyClass(name = \"Nokogiri::XML::SAX::PushParser\")\npublic class XmlSaxPushParser extends RubyObject\n{\n  ParserContext.Options options;\n  IRubyObject saxParser;\n\n  NokogiriBlockingQueueInputStream stream;\n\n  private ParserTask parserTask = null;\n  private FutureTask<XmlSaxParserContext> futureTask = null;\n  private ExecutorService executor = null;\n  RaiseException ex = null;\n\n  public\n  XmlSaxPushParser(Ruby ruby, RubyClass rubyClass)\n  {\n    super(ruby, rubyClass);\n  }\n\n  @Override\n  public void\n  finalize()\n  {\n    try {\n      terminateImpl();\n    } catch (Exception e) { /* ignored */ }\n  }\n\n  @JRubyMethod\n  public IRubyObject\n  initialize_native(final ThreadContext context, IRubyObject saxParser, IRubyObject fileName)\n  {\n    options = new ParserContext.Options(0);\n    this.saxParser = saxParser;\n    return this;\n  }\n\n  private transient IRubyObject parse_options;\n\n  private IRubyObject\n  parse_options(final ThreadContext context)\n  {\n    if (parse_options == null) {\n      parse_options = invoke(context, context.runtime.getClassFromPath(\"Nokogiri::XML::ParseOptions\"), \"new\");\n    }\n    return parse_options;\n  }\n\n  @JRubyMethod(name = \"options\")\n  public IRubyObject\n  getOptions(ThreadContext context)\n  {\n    return invoke(context, parse_options(context), \"options\");\n  }\n\n  @JRubyMethod(name = \"options=\")\n  public IRubyObject\n  setOptions(ThreadContext context, IRubyObject opts)\n  {\n    invoke(context, parse_options(context), \"options=\", opts);\n    options = new ParserContext.Options(opts.convertToInteger().getLongValue());\n    return getOptions(context);\n  }\n\n  /**\n   * Can take a boolean assignment.\n   *\n   * @param context\n   * @param value\n   * @return\n   */\n  @JRubyMethod(name = \"replace_entities=\")\n  public IRubyObject\n  setReplaceEntities(ThreadContext context, IRubyObject value)\n  {\n    // Ignore the value.\n    return this;\n  }\n\n  @JRubyMethod(name = \"replace_entities\")\n  public IRubyObject\n  getReplaceEntities(ThreadContext context)\n  {\n    // The java parser always replaces entities.\n    return context.getRuntime().getTrue();\n  }\n\n  @JRubyMethod\n  public IRubyObject\n  native_write(ThreadContext context, IRubyObject chunk,\n               IRubyObject isLast)\n  {\n    if (ex != null) {\n      // parser has already errored, rethrow the exception\n      throw ex;\n    }\n\n    try {\n      initialize_task(context);\n    } catch (IOException e) {\n      throw context.runtime.newRuntimeError(e.getMessage());\n    }\n    final ByteArrayInputStream data = NokogiriHelpers.stringBytesToStream(chunk);\n    if (data == null) {\n      return this;\n    }\n\n    int errorCount0 = parserTask.getErrorCount();\n\n    try {\n      Future<Void> task = stream.addChunk(data);\n      task.get();\n    } catch (ClosedStreamException ex) {\n      // this means the stream is closed, ignore this exception\n    } catch (Exception e) {\n      throw context.runtime.newRuntimeError(e.toString());\n    }\n\n    if (isLast.isTrue()) {\n      parserTask.getNokogiriHandler().endDocument();\n      terminateTask(context.runtime);\n    }\n\n    if (!options.recover && parserTask.getErrorCount() > errorCount0) {\n      terminateTask(context.runtime);\n      ex = parserTask.getLastError().toThrowable();\n      throw ex;\n    }\n\n    return this;\n  }\n\n  private void\n  initialize_task(ThreadContext context) throws IOException\n  {\n    if (futureTask == null || stream == null) {\n      stream = new NokogiriBlockingQueueInputStream();\n\n      assert saxParser != null : \"saxParser null\";\n      parserTask = new ParserTask(context, saxParser, stream);\n      futureTask = new FutureTask<XmlSaxParserContext>(parserTask);\n      executor = Executors.newSingleThreadExecutor(new ThreadFactory() {\n        @Override\n        public Thread newThread(Runnable r) {\n          Thread t = new Thread(r);\n          t.setName(\"XmlSaxPushParser\");\n          t.setDaemon(true);\n          return t;\n        }\n      });\n      executor.submit(futureTask);\n    }\n  }\n\n  private void\n  terminateTask(final Ruby runtime)\n  {\n    if (executor == null) { return; }\n\n    try {\n      terminateImpl();\n    } catch (InterruptedException e) {\n      throw runtime.newRuntimeError(e.toString());\n    } catch (Exception e) {\n      throw runtime.newRuntimeError(e.toString());\n    }\n  }\n\n  private synchronized void\n  terminateImpl() throws InterruptedException, ExecutionException\n  {\n    terminateExecution(executor, stream, futureTask);\n\n    executor = null;\n    stream = null;\n    futureTask = null;\n  }\n\n  // SHARED for Html4SaxPushParser\n  static void\n  terminateExecution(final ExecutorService executor, final NokogiriBlockingQueueInputStream stream,\n                     final FutureTask<?> futureTask)\n  throws InterruptedException, ExecutionException\n  {\n\n    if (executor == null) { return; }\n\n    try {\n      Future<Void> task = stream.addChunk(NokogiriBlockingQueueInputStream.END);\n      task.get();\n    } catch (ClosedStreamException ex) {\n      // ignore this exception, it means the stream was closed\n    }\n    futureTask.cancel(true);\n    executor.shutdown();\n  }\n\n  private static XmlSaxParserContext\n  parse(final Ruby runtime, final InputStream stream)\n  {\n    RubyClass klazz = getNokogiriClass(runtime, \"Nokogiri::XML::SAX::ParserContext\");\n    return XmlSaxParserContext.parse_stream(runtime, klazz, stream);\n  }\n\n  static class ParserTask extends ParserContext.ParserTask<XmlSaxParserContext>\n  {\n\n    final InputStream stream;\n\n    private\n    ParserTask(ThreadContext context, IRubyObject handler, InputStream stream)\n    {\n      this(context, handler, parse(context.runtime, stream), stream);\n    }\n\n    // IMPL with Html4SaxPushParser\n    protected\n    ParserTask(ThreadContext context, IRubyObject handler, XmlSaxParserContext parser, InputStream stream)\n    {\n      super(context, handler, parser);\n      this.stream = stream;\n    }\n\n    @Override\n    public XmlSaxParserContext\n    call() throws Exception\n    {\n      try {\n        parser.parse_with(context, handler);\n      } finally { stream.close(); }\n      // we have to close the stream before exiting, otherwise someone\n      // can add a chunk and block on task.get() forever.\n      return parser;\n    }\n\n    final NokogiriHandler\n    getNokogiriHandler()\n    {\n      return parser.getNokogiriHandler();\n    }\n\n    synchronized final int\n    getErrorCount()\n    {\n      // check for null because thread may not have started yet\n      if (parser.getNokogiriErrorHandler() == null) { return 0; }\n      return parser.getNokogiriErrorHandler().getErrors().size();\n    }\n\n    synchronized final RubyException\n    getLastError()\n    {\n      List<RubyException> errors = parser.getNokogiriErrorHandler().getErrors();\n      return errors.get(errors.size() - 1);\n    }\n  }\n}\n",
    "patch": "@@ -1,32 +1,24 @@\n package nokogiri;\n \n-import static nokogiri.internals.NokogiriHelpers.getNokogiriClass;\n-import static org.jruby.runtime.Helpers.invoke;\n-\n-import java.io.ByteArrayInputStream;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.FutureTask;\n-import java.util.concurrent.ThreadFactory;\n-\n+import nokogiri.internals.*;\n import org.jruby.Ruby;\n import org.jruby.RubyClass;\n+import org.jruby.RubyException;\n import org.jruby.RubyObject;\n import org.jruby.anno.JRubyClass;\n import org.jruby.anno.JRubyMethod;\n import org.jruby.exceptions.RaiseException;\n import org.jruby.runtime.ThreadContext;\n import org.jruby.runtime.builtin.IRubyObject;\n \n-import nokogiri.internals.ClosedStreamException;\n-import nokogiri.internals.NokogiriBlockingQueueInputStream;\n-import nokogiri.internals.NokogiriHandler;\n-import nokogiri.internals.NokogiriHelpers;\n-import nokogiri.internals.ParserContext;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.List;\n+import java.util.concurrent.*;\n+\n+import static nokogiri.internals.NokogiriHelpers.getNokogiriClass;\n+import static org.jruby.runtime.Helpers.invoke;\n \n /**\n  * Class for Nokogiri::XML::SAX::PushParser\n@@ -159,7 +151,8 @@ public class XmlSaxPushParser extends RubyObject\n \n     if (!options.recover && parserTask.getErrorCount() > errorCount0) {\n       terminateTask(context.runtime);\n-      throw ex = parserTask.getLastError();\n+      ex = parserTask.getLastError().toThrowable();\n+      throw ex;\n     }\n \n     return this;\n@@ -278,16 +271,15 @@ static class ParserTask extends ParserContext.ParserTask<XmlSaxParserContext>\n     getErrorCount()\n     {\n       // check for null because thread may not have started yet\n-      if (parser.getNokogiriHandler() == null) { return 0; }\n-      return parser.getNokogiriHandler().getErrorCount();\n+      if (parser.getNokogiriErrorHandler() == null) { return 0; }\n+      return parser.getNokogiriErrorHandler().getErrors().size();\n     }\n \n-    synchronized final RaiseException\n+    synchronized final RubyException\n     getLastError()\n     {\n-      return parser.getNokogiriHandler().getLastError();\n+      List<RubyException> errors = parser.getNokogiriErrorHandler().getErrors();\n+      return errors.get(errors.size() - 1);\n     }\n-\n   }\n-\n }",
    "function_modified_lines": {
      "added": [
        "import nokogiri.internals.*;\n",
        "import org.jruby.RubyException;\n",
        "import java.io.ByteArrayInputStream;\n",
        "import java.io.IOException;\n",
        "import java.io.InputStream;\n",
        "import java.util.List;\n",
        "import java.util.concurrent.*;\n",
        "\n",
        "import static nokogiri.internals.NokogiriHelpers.getNokogiriClass;\n",
        "import static org.jruby.runtime.Helpers.invoke;\n"
      ],
      "deleted": [
        "import static nokogiri.internals.NokogiriHelpers.getNokogiriClass;\n",
        "import static org.jruby.runtime.Helpers.invoke;\n",
        "\n",
        "import java.io.ByteArrayInputStream;\n",
        "import java.io.IOException;\n",
        "import java.io.InputStream;\n",
        "import java.util.concurrent.ExecutionException;\n",
        "import java.util.concurrent.ExecutorService;\n",
        "import java.util.concurrent.Executors;\n",
        "import java.util.concurrent.Future;\n",
        "import java.util.concurrent.FutureTask;\n",
        "import java.util.concurrent.ThreadFactory;\n",
        "\n",
        "import nokogiri.internals.ClosedStreamException;\n",
        "import nokogiri.internals.NokogiriBlockingQueueInputStream;\n",
        "import nokogiri.internals.NokogiriHandler;\n",
        "import nokogiri.internals.NokogiriHelpers;\n",
        "import nokogiri.internals.ParserContext;\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "Nokogiri is a Rubygem providing HTML, XML, SAX, and Reader parsers with XPath and CSS selector support. In Nokogiri v1.12.4 and earlier, on JRuby only, the SAX parser resolves external entities by default. Users of Nokogiri on JRuby who parse untrusted documents using any of these classes are affected: Nokogiri::XML::SAX::Parse, Nokogiri::HTML4::SAX::Parser or its alias Nokogiri::HTML::SAX::Parser, Nokogiri::XML::SAX::PushParser, and Nokogiri::HTML4::SAX::PushParser or its alias Nokogiri::HTML::SAX::PushParser. JRuby users should upgrade to Nokogiri v1.12.5 or later to receive a patch for this issue. There are no workarounds available for v1.12.4 or earlier. CRuby users are not affected.",
    "id": 12169
  },
  {
    "cve_id": "CVE-2021-41098",
    "code_before_change": "{\n  ParserContext.Options options;\n  IRubyObject saxParser;\n\n  NokogiriBlockingQueueInputStream stream;\n\n  private ParserTask parserTask = null;\n  private FutureTask<XmlSaxParserContext> futureTask = null;\n  private ExecutorService executor = null;\n  RaiseException ex = null;\n\n  public\n  XmlSaxPushParser(Ruby ruby, RubyClass rubyClass)\n  {\n    super(ruby, rubyClass);\n  }\n\n  @Override\n  public void\n  finalize()\n  {\n    try {\n      terminateImpl();\n    } catch (Exception e) { /* ignored */ }\n  }\n\n  @JRubyMethod\n  public IRubyObject\n  initialize_native(final ThreadContext context, IRubyObject saxParser, IRubyObject fileName)\n  {\n    options = new ParserContext.Options(0);\n    this.saxParser = saxParser;\n    return this;\n  }\n\n  private transient IRubyObject parse_options;\n\n  private IRubyObject\n  parse_options(final ThreadContext context)\n  {\n    if (parse_options == null) {\n      parse_options = invoke(context, context.runtime.getClassFromPath(\"Nokogiri::XML::ParseOptions\"), \"new\");\n    }\n    return parse_options;\n  }\n\n  @JRubyMethod(name = \"options\")\n  public IRubyObject\n  getOptions(ThreadContext context)\n  {\n    return invoke(context, parse_options(context), \"options\");\n  }\n\n  @JRubyMethod(name = \"options=\")\n  public IRubyObject\n  setOptions(ThreadContext context, IRubyObject opts)\n  {\n    invoke(context, parse_options(context), \"options=\", opts);\n    options = new ParserContext.Options(opts.convertToInteger().getLongValue());\n    return getOptions(context);\n  }\n\n  /**\n   * Can take a boolean assignment.\n   *\n   * @param context\n   * @param value\n   * @return\n   */\n  @JRubyMethod(name = \"replace_entities=\")\n  public IRubyObject\n  setReplaceEntities(ThreadContext context, IRubyObject value)\n  {\n    // Ignore the value.\n    return this;\n  }\n\n  @JRubyMethod(name = \"replace_entities\")\n  public IRubyObject\n  getReplaceEntities(ThreadContext context)\n  {\n    // The java parser always replaces entities.\n    return context.getRuntime().getTrue();\n  }\n\n  @JRubyMethod\n  public IRubyObject\n  native_write(ThreadContext context, IRubyObject chunk,\n               IRubyObject isLast)\n  {\n    if (ex != null) {\n      // parser has already errored, rethrow the exception\n      throw ex;\n    }\n\n    try {\n      initialize_task(context);\n    } catch (IOException e) {\n      throw context.runtime.newRuntimeError(e.getMessage());\n    }\n    final ByteArrayInputStream data = NokogiriHelpers.stringBytesToStream(chunk);\n    if (data == null) {\n      return this;\n    }\n\n    int errorCount0 = parserTask.getErrorCount();\n\n    try {\n      Future<Void> task = stream.addChunk(data);\n      task.get();\n    } catch (ClosedStreamException ex) {\n      // this means the stream is closed, ignore this exception\n    } catch (Exception e) {\n      throw context.runtime.newRuntimeError(e.toString());\n    }\n\n    if (isLast.isTrue()) {\n      parserTask.getNokogiriHandler().endDocument();\n      terminateTask(context.runtime);\n    }\n\n    if (!options.recover && parserTask.getErrorCount() > errorCount0) {\n      terminateTask(context.runtime);\n      throw ex = parserTask.getLastError();\n    }\n\n    return this;\n  }\n\n  private void\n  initialize_task(ThreadContext context) throws IOException\n  {\n    if (futureTask == null || stream == null) {\n      stream = new NokogiriBlockingQueueInputStream();\n\n      assert saxParser != null : \"saxParser null\";\n      parserTask = new ParserTask(context, saxParser, stream);\n      futureTask = new FutureTask<XmlSaxParserContext>(parserTask);\n      executor = Executors.newSingleThreadExecutor(new ThreadFactory() {\n        @Override\n        public Thread newThread(Runnable r) {\n          Thread t = new Thread(r);\n          t.setName(\"XmlSaxPushParser\");\n          t.setDaemon(true);\n          return t;\n        }\n      });\n      executor.submit(futureTask);\n    }\n  }\n\n  private void\n  terminateTask(final Ruby runtime)\n  {\n    if (executor == null) { return; }\n\n    try {\n      terminateImpl();\n    } catch (InterruptedException e) {\n      throw runtime.newRuntimeError(e.toString());\n    } catch (Exception e) {\n      throw runtime.newRuntimeError(e.toString());\n    }\n  }\n\n  private synchronized void\n  terminateImpl() throws InterruptedException, ExecutionException\n  {\n    terminateExecution(executor, stream, futureTask);\n\n    executor = null;\n    stream = null;\n    futureTask = null;\n  }\n\n  // SHARED for Html4SaxPushParser\n  static void\n  terminateExecution(final ExecutorService executor, final NokogiriBlockingQueueInputStream stream,\n                     final FutureTask<?> futureTask)\n  throws InterruptedException, ExecutionException\n  {\n\n    if (executor == null) { return; }\n\n    try {\n      Future<Void> task = stream.addChunk(NokogiriBlockingQueueInputStream.END);\n      task.get();\n    } catch (ClosedStreamException ex) {\n      // ignore this exception, it means the stream was closed\n    }\n    futureTask.cancel(true);\n    executor.shutdown();\n  }\n\n  private static XmlSaxParserContext\n  parse(final Ruby runtime, final InputStream stream)\n  {\n    RubyClass klazz = getNokogiriClass(runtime, \"Nokogiri::XML::SAX::ParserContext\");\n    return XmlSaxParserContext.parse_stream(runtime, klazz, stream);\n  }\n\n  static class ParserTask extends ParserContext.ParserTask<XmlSaxParserContext>\n  {\n\n    final InputStream stream;\n\n    private\n    ParserTask(ThreadContext context, IRubyObject handler, InputStream stream)\n    {\n      this(context, handler, parse(context.runtime, stream), stream);\n    }\n\n    // IMPL with Html4SaxPushParser\n    protected\n    ParserTask(ThreadContext context, IRubyObject handler, XmlSaxParserContext parser, InputStream stream)\n    {\n      super(context, handler, parser);\n      this.stream = stream;\n    }\n\n    @Override\n    public XmlSaxParserContext\n    call() throws Exception\n    {\n      try {\n        parser.parse_with(context, handler);\n      } finally { stream.close(); }\n      // we have to close the stream before exiting, otherwise someone\n      // can add a chunk and block on task.get() forever.\n      return parser;\n    }\n\n    final NokogiriHandler\n    getNokogiriHandler()\n    {\n      return parser.getNokogiriHandler();\n    }\n\n    synchronized final int\n    getErrorCount()\n    {\n      // check for null because thread may not have started yet\n      if (parser.getNokogiriHandler() == null) { return 0; }\n      return parser.getNokogiriHandler().getErrorCount();\n    }\n\n    synchronized final RaiseException\n    getLastError()\n    {\n      return parser.getNokogiriHandler().getLastError();\n    }\n\n  }\n\n}",
    "code_after_change": "{\n\n    final InputStream stream;\n\n    private\n    ParserTask(ThreadContext context, IRubyObject handler, InputStream stream)\n    {\n      this(context, handler, parse(context.runtime, stream), stream);\n    }\n\n    // IMPL with Html4SaxPushParser\n    protected\n    ParserTask(ThreadContext context, IRubyObject handler, XmlSaxParserContext parser, InputStream stream)\n    {\n      super(context, handler, parser);\n      this.stream = stream;\n    }\n\n    @Override\n    public XmlSaxParserContext\n    call() throws Exception\n    {\n      try {\n        parser.parse_with(context, handler);\n      } finally { stream.close(); }\n      // we have to close the stream before exiting, otherwise someone\n      // can add a chunk and block on task.get() forever.\n      return parser;\n    }\n\n    final NokogiriHandler\n    getNokogiriHandler()\n    {\n      return parser.getNokogiriHandler();\n    }\n\n    synchronized final int\n    getErrorCount()\n    {\n      // check for null because thread may not have started yet\n      if (parser.getNokogiriErrorHandler() == null) { return 0; }\n      return parser.getNokogiriErrorHandler().getErrors().size();\n    }\n\n    synchronized final RubyException\n    getLastError()\n    {\n      List<RubyException> errors = parser.getNokogiriErrorHandler().getErrors();\n      return errors.get(errors.size() - 1);\n    }\n  }",
    "patch": "@@ -1,32 +1,24 @@\n package nokogiri;\n \n-import static nokogiri.internals.NokogiriHelpers.getNokogiriClass;\n-import static org.jruby.runtime.Helpers.invoke;\n-\n-import java.io.ByteArrayInputStream;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.FutureTask;\n-import java.util.concurrent.ThreadFactory;\n-\n+import nokogiri.internals.*;\n import org.jruby.Ruby;\n import org.jruby.RubyClass;\n+import org.jruby.RubyException;\n import org.jruby.RubyObject;\n import org.jruby.anno.JRubyClass;\n import org.jruby.anno.JRubyMethod;\n import org.jruby.exceptions.RaiseException;\n import org.jruby.runtime.ThreadContext;\n import org.jruby.runtime.builtin.IRubyObject;\n \n-import nokogiri.internals.ClosedStreamException;\n-import nokogiri.internals.NokogiriBlockingQueueInputStream;\n-import nokogiri.internals.NokogiriHandler;\n-import nokogiri.internals.NokogiriHelpers;\n-import nokogiri.internals.ParserContext;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.List;\n+import java.util.concurrent.*;\n+\n+import static nokogiri.internals.NokogiriHelpers.getNokogiriClass;\n+import static org.jruby.runtime.Helpers.invoke;\n \n /**\n  * Class for Nokogiri::XML::SAX::PushParser\n@@ -159,7 +151,8 @@ public class XmlSaxPushParser extends RubyObject\n \n     if (!options.recover && parserTask.getErrorCount() > errorCount0) {\n       terminateTask(context.runtime);\n-      throw ex = parserTask.getLastError();\n+      ex = parserTask.getLastError().toThrowable();\n+      throw ex;\n     }\n \n     return this;\n@@ -278,16 +271,15 @@ static class ParserTask extends ParserContext.ParserTask<XmlSaxParserContext>\n     getErrorCount()\n     {\n       // check for null because thread may not have started yet\n-      if (parser.getNokogiriHandler() == null) { return 0; }\n-      return parser.getNokogiriHandler().getErrorCount();\n+      if (parser.getNokogiriErrorHandler() == null) { return 0; }\n+      return parser.getNokogiriErrorHandler().getErrors().size();\n     }\n \n-    synchronized final RaiseException\n+    synchronized final RubyException\n     getLastError()\n     {\n-      return parser.getNokogiriHandler().getLastError();\n+      List<RubyException> errors = parser.getNokogiriErrorHandler().getErrors();\n+      return errors.get(errors.size() - 1);\n     }\n-\n   }\n-\n }",
    "function_modified_lines": {
      "added": [
        "      if (parser.getNokogiriErrorHandler() == null) { return 0; }\n",
        "      return parser.getNokogiriErrorHandler().getErrors().size();\n",
        "    synchronized final RubyException\n",
        "      List<RubyException> errors = parser.getNokogiriErrorHandler().getErrors();\n",
        "      return errors.get(errors.size() - 1);\n"
      ],
      "deleted": [
        "      if (parser.getNokogiriHandler() == null) { return 0; }\n",
        "      return parser.getNokogiriHandler().getErrorCount();\n",
        "    synchronized final RaiseException\n",
        "      return parser.getNokogiriHandler().getLastError();\n",
        "\n",
        "\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "Nokogiri is a Rubygem providing HTML, XML, SAX, and Reader parsers with XPath and CSS selector support. In Nokogiri v1.12.4 and earlier, on JRuby only, the SAX parser resolves external entities by default. Users of Nokogiri on JRuby who parse untrusted documents using any of these classes are affected: Nokogiri::XML::SAX::Parse, Nokogiri::HTML4::SAX::Parser or its alias Nokogiri::HTML::SAX::Parser, Nokogiri::XML::SAX::PushParser, and Nokogiri::HTML4::SAX::PushParser or its alias Nokogiri::HTML::SAX::PushParser. JRuby users should upgrade to Nokogiri v1.12.5 or later to receive a patch for this issue. There are no workarounds available for v1.12.4 or earlier. CRuby users are not affected.",
    "id": 12170
  },
  {
    "cve_id": "CVE-2021-41098",
    "code_before_change": "package nokogiri.internals;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.xerces.xni.parser.XMLErrorHandler;\nimport org.xml.sax.ErrorHandler;\n\n/**\n * Super class of error handlers.\n *\n * XMLErrorHandler is used by nokogiri.internals.HtmlDomParserContext since NekoHtml\n * uses this type of the error handler.\n *\n * @author sergio\n * @author Yoko Harada <yokolet@gmail.com>\n */\npublic abstract class NokogiriErrorHandler implements ErrorHandler, XMLErrorHandler\n{\n  protected final List<Exception> errors;\n  protected boolean noerror;\n  protected boolean nowarning;\n\n  public\n  NokogiriErrorHandler(boolean noerror, boolean nowarning)\n  {\n    this.errors = new ArrayList<Exception>(4);\n    this.noerror = noerror;\n    this.nowarning = nowarning;\n  }\n\n  List<Exception>\n  getErrors() { return errors; }\n\n  public void\n  addError(Exception ex) { errors.add(ex); }\n\n  protected boolean\n  usesNekoHtml(String domain)\n  {\n    return \"http://cyberneko.org/html\".equals(domain);\n  }\n\n}\n",
    "code_after_change": "package nokogiri.internals;\n\nimport nokogiri.XmlSyntaxError;\nimport org.apache.xerces.xni.parser.XMLErrorHandler;\nimport org.jruby.Ruby;\nimport org.jruby.RubyException;\nimport org.jruby.exceptions.RaiseException;\nimport org.xml.sax.ErrorHandler;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Super class of error handlers.\n *\n * XMLErrorHandler is used by nokogiri.internals.HtmlDomParserContext since NekoHtml\n * uses this type of the error handler.\n *\n * @author sergio\n * @author Yoko Harada <yokolet@gmail.com>\n */\npublic abstract class NokogiriErrorHandler implements ErrorHandler, XMLErrorHandler\n{\n  private final Ruby runtime;\n  protected final List<RubyException> errors;\n  protected boolean noerror;\n  protected boolean nowarning;\n\n  public\n  NokogiriErrorHandler(Ruby runtime, boolean noerror, boolean nowarning)\n  {\n    this.runtime = runtime;\n    this.errors = new ArrayList<RubyException>(4);\n    this.noerror = noerror;\n    this.nowarning = nowarning;\n  }\n\n  public List<RubyException>\n  getErrors() { return errors; }\n\n  public void\n  addError(Exception ex)\n  {\n    addError(XmlSyntaxError.createXMLSyntaxError(runtime, ex));\n  }\n\n  public void\n  addError(RubyException ex)\n  {\n    errors.add(ex);\n  }\n\n  public void\n  addError(RaiseException ex)\n  {\n    addError(ex.getException());\n  }\n\n  protected boolean\n  usesNekoHtml(String domain)\n  {\n    return \"http://cyberneko.org/html\".equals(domain);\n  }\n\n}\n",
    "patch": "@@ -1,11 +1,15 @@\n package nokogiri.internals;\n \n-import java.util.ArrayList;\n-import java.util.List;\n-\n+import nokogiri.XmlSyntaxError;\n import org.apache.xerces.xni.parser.XMLErrorHandler;\n+import org.jruby.Ruby;\n+import org.jruby.RubyException;\n+import org.jruby.exceptions.RaiseException;\n import org.xml.sax.ErrorHandler;\n \n+import java.util.ArrayList;\n+import java.util.List;\n+\n /**\n  * Super class of error handlers.\n  *\n@@ -17,23 +21,40 @@\n  */\n public abstract class NokogiriErrorHandler implements ErrorHandler, XMLErrorHandler\n {\n-  protected final List<Exception> errors;\n+  private final Ruby runtime;\n+  protected final List<RubyException> errors;\n   protected boolean noerror;\n   protected boolean nowarning;\n \n   public\n-  NokogiriErrorHandler(boolean noerror, boolean nowarning)\n+  NokogiriErrorHandler(Ruby runtime, boolean noerror, boolean nowarning)\n   {\n-    this.errors = new ArrayList<Exception>(4);\n+    this.runtime = runtime;\n+    this.errors = new ArrayList<RubyException>(4);\n     this.noerror = noerror;\n     this.nowarning = nowarning;\n   }\n \n-  List<Exception>\n+  public List<RubyException>\n   getErrors() { return errors; }\n \n   public void\n-  addError(Exception ex) { errors.add(ex); }\n+  addError(Exception ex)\n+  {\n+    addError(XmlSyntaxError.createXMLSyntaxError(runtime, ex));\n+  }\n+\n+  public void\n+  addError(RubyException ex)\n+  {\n+    errors.add(ex);\n+  }\n+\n+  public void\n+  addError(RaiseException ex)\n+  {\n+    addError(ex.getException());\n+  }\n \n   protected boolean\n   usesNekoHtml(String domain)",
    "function_modified_lines": {
      "added": [
        "import nokogiri.XmlSyntaxError;\n",
        "import org.jruby.Ruby;\n",
        "import org.jruby.RubyException;\n",
        "import org.jruby.exceptions.RaiseException;\n",
        "import java.util.ArrayList;\n",
        "import java.util.List;\n",
        "\n",
        "  private final Ruby runtime;\n",
        "  protected final List<RubyException> errors;\n",
        "  NokogiriErrorHandler(Ruby runtime, boolean noerror, boolean nowarning)\n",
        "    this.runtime = runtime;\n",
        "    this.errors = new ArrayList<RubyException>(4);\n",
        "  public List<RubyException>\n",
        "  addError(Exception ex)\n",
        "  {\n",
        "    addError(XmlSyntaxError.createXMLSyntaxError(runtime, ex));\n",
        "  }\n",
        "\n",
        "  public void\n",
        "  addError(RubyException ex)\n",
        "  {\n",
        "    errors.add(ex);\n",
        "  }\n",
        "\n",
        "  public void\n",
        "  addError(RaiseException ex)\n",
        "  {\n",
        "    addError(ex.getException());\n",
        "  }\n"
      ],
      "deleted": [
        "import java.util.ArrayList;\n",
        "import java.util.List;\n",
        "\n",
        "  protected final List<Exception> errors;\n",
        "  NokogiriErrorHandler(boolean noerror, boolean nowarning)\n",
        "    this.errors = new ArrayList<Exception>(4);\n",
        "  List<Exception>\n",
        "  addError(Exception ex) { errors.add(ex); }\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "Nokogiri is a Rubygem providing HTML, XML, SAX, and Reader parsers with XPath and CSS selector support. In Nokogiri v1.12.4 and earlier, on JRuby only, the SAX parser resolves external entities by default. Users of Nokogiri on JRuby who parse untrusted documents using any of these classes are affected: Nokogiri::XML::SAX::Parse, Nokogiri::HTML4::SAX::Parser or its alias Nokogiri::HTML::SAX::Parser, Nokogiri::XML::SAX::PushParser, and Nokogiri::HTML4::SAX::PushParser or its alias Nokogiri::HTML::SAX::PushParser. JRuby users should upgrade to Nokogiri v1.12.5 or later to receive a patch for this issue. There are no workarounds available for v1.12.4 or earlier. CRuby users are not affected.",
    "id": 12171
  },
  {
    "cve_id": "CVE-2021-41098",
    "code_before_change": "try {\n      final String msg = ex.getMessage();\n      call(\"error\", runtime.newString(msg == null ? \"\" : msg));\n      addError(XmlSyntaxError.createError(runtime, ex).toThrowable());\n    } catch (RaiseException e) {\n      addError(e);\n      throw e;\n    }",
    "code_after_change": "try {\n      final String msg = ex.getMessage();\n      call(\"error\", runtime.newString(msg == null ? \"\" : msg));\n      errorHandler.addError(ex);\n    } catch (RaiseException e) {\n      errorHandler.addError(e);\n      throw e;\n    }",
    "patch": "@@ -38,25 +38,19 @@ public class NokogiriHandler extends DefaultHandler2 implements XmlDeclHandler\n   private final Ruby runtime;\n   private final RubyClass attrClass;\n   private final IRubyObject object;\n-\n-  /**\n-   * Stores parse errors with the most-recent error last.\n-   *\n-   * TODO: should these be stored in the document 'errors' array?\n-   * Currently only string messages are stored there.\n-   */\n-  private final LinkedList<RaiseException> errors = new LinkedList<RaiseException>();\n+  private NokogiriErrorHandler errorHandler;\n \n   private Locator locator;\n   private boolean needEmptyAttrCheck;\n \n   public\n-  NokogiriHandler(Ruby runtime, IRubyObject object)\n+  NokogiriHandler(Ruby runtime, IRubyObject object, NokogiriErrorHandler errorHandler)\n   {\n     assert object != null;\n     this.runtime = runtime;\n     this.attrClass = (RubyClass) runtime.getClassFromPath(\"Nokogiri::XML::SAX::Parser::Attribute\");\n     this.object = object;\n+    this.errorHandler = errorHandler;\n     charactersBuilder = new StringBuilder();\n     String objectName = object.getMetaClass().getName();\n     if (\"Nokogiri::HTML4::SAX::Parser\".equals(objectName)) { needEmptyAttrCheck = true; }\n@@ -253,9 +247,9 @@ public class NokogiriHandler extends DefaultHandler2 implements XmlDeclHandler\n     try {\n       final String msg = ex.getMessage();\n       call(\"error\", runtime.newString(msg == null ? \"\" : msg));\n-      addError(XmlSyntaxError.createError(runtime, ex).toThrowable());\n+      errorHandler.addError(ex);\n     } catch (RaiseException e) {\n-      addError(e);\n+      errorHandler.addError(e);\n       throw e;\n     }\n   }\n@@ -282,22 +276,10 @@ public class NokogiriHandler extends DefaultHandler2 implements XmlDeclHandler\n     call(\"warning\", runtime.newString(msg == null ? \"\" : msg));\n   }\n \n-  protected synchronized void\n-  addError(RaiseException e)\n-  {\n-    errors.add(e);\n-  }\n-\n   public synchronized int\n   getErrorCount()\n   {\n-    return errors.size();\n-  }\n-\n-  public synchronized RaiseException\n-  getLastError()\n-  {\n-    return errors.getLast();\n+    return errorHandler.getErrors().size();\n   }\n \n   private void",
    "function_modified_lines": {
      "added": [
        "      errorHandler.addError(ex);\n",
        "      errorHandler.addError(e);\n"
      ],
      "deleted": [
        "      addError(XmlSyntaxError.createError(runtime, ex).toThrowable());\n",
        "      addError(e);\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "Nokogiri is a Rubygem providing HTML, XML, SAX, and Reader parsers with XPath and CSS selector support. In Nokogiri v1.12.4 and earlier, on JRuby only, the SAX parser resolves external entities by default. Users of Nokogiri on JRuby who parse untrusted documents using any of these classes are affected: Nokogiri::XML::SAX::Parse, Nokogiri::HTML4::SAX::Parser or its alias Nokogiri::HTML::SAX::Parser, Nokogiri::XML::SAX::PushParser, and Nokogiri::HTML4::SAX::PushParser or its alias Nokogiri::HTML::SAX::PushParser. JRuby users should upgrade to Nokogiri v1.12.5 or later to receive a patch for this issue. There are no workarounds available for v1.12.4 or earlier. CRuby users are not affected.",
    "id": 12172
  },
  {
    "cve_id": "CVE-2021-41098",
    "code_before_change": "package nokogiri.internals;\n\nimport org.apache.xerces.xni.parser.XMLParseException;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.SAXParseException;\n\n/**\n * Error Handler for XML document when recover is true (default).\n *\n * @author sergio\n * @author Yoko Harada <yokolet@gmail.com>\n */\npublic class NokogiriNonStrictErrorHandler extends NokogiriErrorHandler\n{\n  public\n  NokogiriNonStrictErrorHandler(boolean noerror, boolean nowarning)\n  {\n    super(noerror, nowarning);\n  }\n\n  public void\n  warning(SAXParseException ex) throws SAXException\n  {\n    errors.add(ex);\n  }\n\n  public void\n  error(SAXParseException ex) throws SAXException\n  {\n    errors.add(ex);\n  }\n\n  public void\n  fatalError(SAXParseException ex) throws SAXException\n  {\n    // fix #837\n    // Xerces won't skip the reference entity (and other invalid) constructs\n    // found in the prolog, instead it will keep calling this method and we'll\n    // keep inserting the error in the document errors array until we run\n    // out of memory\n    errors.add(ex);\n    String message = ex.getMessage();\n\n    // The problem with Xerces is that some errors will cause the\n    // parser not to advance the reader and it will keep reporting\n    // the same error over and over, which will cause the parser\n    // to enter an infinite loop unless we throw the exception.\n    if (message != null && isFatal(message)) {\n      throw ex;\n    }\n  }\n\n  public void\n  error(String domain, String key, XMLParseException e)\n  {\n    errors.add(e);\n  }\n\n  public void\n  fatalError(String domain, String key, XMLParseException e)\n  {\n    errors.add(e);\n  }\n\n  public void\n  warning(String domain, String key, XMLParseException e)\n  {\n    errors.add(e);\n  }\n\n  /*\n   * Determine whether this is a fatal error that should cause\n   * the parsing to stop, or an error that can be ignored.\n   */\n  private static boolean\n  isFatal(String msg)\n  {\n    String msgLowerCase = msg.toLowerCase();\n    return\n      msgLowerCase.contains(\"in prolog\") ||\n      msgLowerCase.contains(\"limit\") ||\n      msgLowerCase.contains(\"preceding the root element must be well-formed\") ||\n      msgLowerCase.contains(\"following the root element must be well-formed\");\n  }\n}\n",
    "code_after_change": "package nokogiri.internals;\n\nimport org.apache.xerces.xni.parser.XMLParseException;\nimport org.jruby.Ruby;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.SAXParseException;\n\n/**\n * Error Handler for XML document when recover is true (default).\n *\n * @author sergio\n * @author Yoko Harada <yokolet@gmail.com>\n */\npublic class NokogiriNonStrictErrorHandler extends NokogiriErrorHandler\n{\n  public\n  NokogiriNonStrictErrorHandler(Ruby runtime, boolean noerror, boolean nowarning)\n  {\n    super(runtime, noerror, nowarning);\n  }\n\n  public void\n  warning(SAXParseException ex) throws SAXException\n  {\n    addError(ex);\n  }\n\n  public void\n  error(SAXParseException ex) throws SAXException\n  {\n    addError(ex);\n  }\n\n  public void\n  fatalError(SAXParseException ex) throws SAXException\n  {\n    // fix #837\n    // Xerces won't skip the reference entity (and other invalid) constructs\n    // found in the prolog, instead it will keep calling this method and we'll\n    // keep inserting the error in the document errors array until we run\n    // out of memory\n    addError(ex);\n    String message = ex.getMessage();\n\n    // The problem with Xerces is that some errors will cause the\n    // parser not to advance the reader and it will keep reporting\n    // the same error over and over, which will cause the parser\n    // to enter an infinite loop unless we throw the exception.\n    if (message != null && isFatal(message)) {\n      throw ex;\n    }\n  }\n\n  public void\n  error(String domain, String key, XMLParseException e)\n  {\n    addError(e);\n  }\n\n  public void\n  fatalError(String domain, String key, XMLParseException e)\n  {\n    addError(e);\n  }\n\n  public void\n  warning(String domain, String key, XMLParseException e)\n  {\n    addError(e);\n  }\n\n  /*\n   * Determine whether this is a fatal error that should cause\n   * the parsing to stop, or an error that can be ignored.\n   */\n  private static boolean\n  isFatal(String msg)\n  {\n    String msgLowerCase = msg.toLowerCase();\n    return\n      msgLowerCase.contains(\"in prolog\") ||\n      msgLowerCase.contains(\"limit\") ||\n      msgLowerCase.contains(\"preceding the root element must be well-formed\") ||\n      msgLowerCase.contains(\"following the root element must be well-formed\");\n  }\n}\n",
    "patch": "@@ -1,6 +1,7 @@\n package nokogiri.internals;\n \n import org.apache.xerces.xni.parser.XMLParseException;\n+import org.jruby.Ruby;\n import org.xml.sax.SAXException;\n import org.xml.sax.SAXParseException;\n \n@@ -13,21 +14,21 @@\n public class NokogiriNonStrictErrorHandler extends NokogiriErrorHandler\n {\n   public\n-  NokogiriNonStrictErrorHandler(boolean noerror, boolean nowarning)\n+  NokogiriNonStrictErrorHandler(Ruby runtime, boolean noerror, boolean nowarning)\n   {\n-    super(noerror, nowarning);\n+    super(runtime, noerror, nowarning);\n   }\n \n   public void\n   warning(SAXParseException ex) throws SAXException\n   {\n-    errors.add(ex);\n+    addError(ex);\n   }\n \n   public void\n   error(SAXParseException ex) throws SAXException\n   {\n-    errors.add(ex);\n+    addError(ex);\n   }\n \n   public void\n@@ -38,7 +39,7 @@ public class NokogiriNonStrictErrorHandler extends NokogiriErrorHandler\n     // found in the prolog, instead it will keep calling this method and we'll\n     // keep inserting the error in the document errors array until we run\n     // out of memory\n-    errors.add(ex);\n+    addError(ex);\n     String message = ex.getMessage();\n \n     // The problem with Xerces is that some errors will cause the\n@@ -53,19 +54,19 @@ public class NokogiriNonStrictErrorHandler extends NokogiriErrorHandler\n   public void\n   error(String domain, String key, XMLParseException e)\n   {\n-    errors.add(e);\n+    addError(e);\n   }\n \n   public void\n   fatalError(String domain, String key, XMLParseException e)\n   {\n-    errors.add(e);\n+    addError(e);\n   }\n \n   public void\n   warning(String domain, String key, XMLParseException e)\n   {\n-    errors.add(e);\n+    addError(e);\n   }\n \n   /*",
    "function_modified_lines": {
      "added": [
        "import org.jruby.Ruby;\n",
        "  NokogiriNonStrictErrorHandler(Ruby runtime, boolean noerror, boolean nowarning)\n",
        "    super(runtime, noerror, nowarning);\n",
        "    addError(ex);\n",
        "    addError(ex);\n",
        "    addError(ex);\n",
        "    addError(e);\n",
        "    addError(e);\n",
        "    addError(e);\n"
      ],
      "deleted": [
        "  NokogiriNonStrictErrorHandler(boolean noerror, boolean nowarning)\n",
        "    super(noerror, nowarning);\n",
        "    errors.add(ex);\n",
        "    errors.add(ex);\n",
        "    errors.add(ex);\n",
        "    errors.add(e);\n",
        "    errors.add(e);\n",
        "    errors.add(e);\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "Nokogiri is a Rubygem providing HTML, XML, SAX, and Reader parsers with XPath and CSS selector support. In Nokogiri v1.12.4 and earlier, on JRuby only, the SAX parser resolves external entities by default. Users of Nokogiri on JRuby who parse untrusted documents using any of these classes are affected: Nokogiri::XML::SAX::Parse, Nokogiri::HTML4::SAX::Parser or its alias Nokogiri::HTML::SAX::Parser, Nokogiri::XML::SAX::PushParser, and Nokogiri::HTML4::SAX::PushParser or its alias Nokogiri::HTML::SAX::PushParser. JRuby users should upgrade to Nokogiri v1.12.5 or later to receive a patch for this issue. There are no workarounds available for v1.12.4 or earlier. CRuby users are not affected.",
    "id": 12173
  },
  {
    "cve_id": "CVE-2021-41098",
    "code_before_change": "{\n\n  public\n  NokogiriNonStrictErrorHandler4NekoHtml(boolean nowarning)\n  {\n    super(false, nowarning);\n  }\n\n  public\n  NokogiriNonStrictErrorHandler4NekoHtml(boolean noerror, boolean nowarning)\n  {\n    super(noerror, nowarning);\n  }\n\n  public void\n  warning(SAXParseException ex) throws SAXException\n  {\n    //noop. NekoHtml adds too many warnings.\n  }\n\n  public void\n  error(SAXParseException ex) throws SAXException\n  {\n    errors.add(ex);\n  }\n\n  public void\n  fatalError(SAXParseException ex) throws SAXException\n  {\n    errors.add(ex);\n  }\n\n  /**\n   * Implementation of org.apache.xerces.xni.parser.XMLErrorHandler. This method\n   * is invoked during parsing fired by HtmlDomParserContext and is a NekoHtml requirement.\n   *\n   * @param domain The domain of the error. The domain can be any string but is\n   *               suggested to be a valid URI. The domain can be used to conveniently\n   *               specify a web site location of the relevant specification or\n   *               document pertaining to this warning.\n   * @param key The error key. This key can be any string and is implementation\n   *            dependent.\n   * @param e Exception.\n   */\n  public void\n  error(String domain, String key, XMLParseException e)\n  {\n    errors.add(e);\n  }\n\n  /**\n   * Implementation of org.apache.xerces.xni.parser.XMLErrorHandler. This method\n   * is invoked during parsing fired by HtmlDomParserContext and is a NekoHtml requirement.\n   *\n   * @param domain The domain of the fatal error. The domain can be any string but is\n   *               suggested to be a valid URI. The domain can be used to conveniently\n   *               specify a web site location of the relevant specification or\n   *               document pertaining to this warning.\n   * @param key The fatal error key. This key can be any string and is implementation\n   *            dependent.\n   * @param e Exception.\n   */\n  public void\n  fatalError(String domain, String key, XMLParseException e)\n  {\n    errors.add(e);\n  }\n\n  /**\n   * Implementation of org.apache.xerces.xni.parser.XMLErrorHandler. This method\n   * is invoked during parsing fired by HtmlDomParserContext and is a NekoHtml requirement.\n   *\n   * @param domain The domain of the warning. The domain can be any string but is\n   *               suggested to be a valid URI. The domain can be used to conveniently\n   *               specify a web site location of the relevant specification or\n   *               document pertaining to this warning.\n   * @param key The warning key. This key can be any string and is implementation\n   *            dependent.\n   * @param e Exception.\n   */\n  public void\n  warning(String domain, String key, XMLParseException e)\n  {\n    errors.add(e);\n  }\n\n}",
    "code_after_change": "{\n\n  public\n  NokogiriNonStrictErrorHandler4NekoHtml(Ruby runtime, boolean nowarning)\n  {\n    super(runtime, false, nowarning);\n  }\n\n  public\n  NokogiriNonStrictErrorHandler4NekoHtml(Ruby runtime, boolean noerror, boolean nowarning)\n  {\n    super(runtime, noerror, nowarning);\n  }\n\n  public void\n  warning(SAXParseException ex) throws SAXException\n  {\n    //noop. NekoHtml adds too many warnings.\n  }\n\n  public void\n  error(SAXParseException ex) throws SAXException\n  {\n    addError(ex);\n  }\n\n  public void\n  fatalError(SAXParseException ex) throws SAXException\n  {\n    addError(ex);\n  }\n\n  /**\n   * Implementation of org.apache.xerces.xni.parser.XMLErrorHandler. This method\n   * is invoked during parsing fired by HtmlDomParserContext and is a NekoHtml requirement.\n   *\n   * @param domain The domain of the error. The domain can be any string but is\n   *               suggested to be a valid URI. The domain can be used to conveniently\n   *               specify a web site location of the relevant specification or\n   *               document pertaining to this warning.\n   * @param key The error key. This key can be any string and is implementation\n   *            dependent.\n   * @param e Exception.\n   */\n  public void\n  error(String domain, String key, XMLParseException e)\n  {\n    addError(e);\n  }\n\n  /**\n   * Implementation of org.apache.xerces.xni.parser.XMLErrorHandler. This method\n   * is invoked during parsing fired by HtmlDomParserContext and is a NekoHtml requirement.\n   *\n   * @param domain The domain of the fatal error. The domain can be any string but is\n   *               suggested to be a valid URI. The domain can be used to conveniently\n   *               specify a web site location of the relevant specification or\n   *               document pertaining to this warning.\n   * @param key The fatal error key. This key can be any string and is implementation\n   *            dependent.\n   * @param e Exception.\n   */\n  public void\n  fatalError(String domain, String key, XMLParseException e)\n  {\n    addError(e);\n  }\n\n  /**\n   * Implementation of org.apache.xerces.xni.parser.XMLErrorHandler. This method\n   * is invoked during parsing fired by HtmlDomParserContext and is a NekoHtml requirement.\n   *\n   * @param domain The domain of the warning. The domain can be any string but is\n   *               suggested to be a valid URI. The domain can be used to conveniently\n   *               specify a web site location of the relevant specification or\n   *               document pertaining to this warning.\n   * @param key The warning key. This key can be any string and is implementation\n   *            dependent.\n   * @param e Exception.\n   */\n  public void\n  warning(String domain, String key, XMLParseException e)\n  {\n    addError(e);\n  }\n\n}",
    "patch": "@@ -1,6 +1,7 @@\n package nokogiri.internals;\n \n import org.apache.xerces.xni.parser.XMLParseException;\n+import org.jruby.Ruby;\n import org.xml.sax.SAXException;\n import org.xml.sax.SAXParseException;\n \n@@ -20,15 +21,15 @@ public class NokogiriNonStrictErrorHandler4NekoHtml extends NokogiriErrorHandler\n {\n \n   public\n-  NokogiriNonStrictErrorHandler4NekoHtml(boolean nowarning)\n+  NokogiriNonStrictErrorHandler4NekoHtml(Ruby runtime, boolean nowarning)\n   {\n-    super(false, nowarning);\n+    super(runtime, false, nowarning);\n   }\n \n   public\n-  NokogiriNonStrictErrorHandler4NekoHtml(boolean noerror, boolean nowarning)\n+  NokogiriNonStrictErrorHandler4NekoHtml(Ruby runtime, boolean noerror, boolean nowarning)\n   {\n-    super(noerror, nowarning);\n+    super(runtime, noerror, nowarning);\n   }\n \n   public void\n@@ -40,13 +41,13 @@ public class NokogiriNonStrictErrorHandler4NekoHtml extends NokogiriErrorHandler\n   public void\n   error(SAXParseException ex) throws SAXException\n   {\n-    errors.add(ex);\n+    addError(ex);\n   }\n \n   public void\n   fatalError(SAXParseException ex) throws SAXException\n   {\n-    errors.add(ex);\n+    addError(ex);\n   }\n \n   /**\n@@ -64,7 +65,7 @@ public class NokogiriNonStrictErrorHandler4NekoHtml extends NokogiriErrorHandler\n   public void\n   error(String domain, String key, XMLParseException e)\n   {\n-    errors.add(e);\n+    addError(e);\n   }\n \n   /**\n@@ -82,7 +83,7 @@ public class NokogiriNonStrictErrorHandler4NekoHtml extends NokogiriErrorHandler\n   public void\n   fatalError(String domain, String key, XMLParseException e)\n   {\n-    errors.add(e);\n+    addError(e);\n   }\n \n   /**\n@@ -100,7 +101,7 @@ public class NokogiriNonStrictErrorHandler4NekoHtml extends NokogiriErrorHandler\n   public void\n   warning(String domain, String key, XMLParseException e)\n   {\n-    errors.add(e);\n+    addError(e);\n   }\n \n }",
    "function_modified_lines": {
      "added": [
        "  NokogiriNonStrictErrorHandler4NekoHtml(Ruby runtime, boolean nowarning)\n",
        "    super(runtime, false, nowarning);\n",
        "  NokogiriNonStrictErrorHandler4NekoHtml(Ruby runtime, boolean noerror, boolean nowarning)\n",
        "    super(runtime, noerror, nowarning);\n",
        "    addError(ex);\n",
        "    addError(ex);\n"
      ],
      "deleted": [
        "  NokogiriNonStrictErrorHandler4NekoHtml(boolean nowarning)\n",
        "    super(false, nowarning);\n",
        "  NokogiriNonStrictErrorHandler4NekoHtml(boolean noerror, boolean nowarning)\n",
        "    super(noerror, nowarning);\n",
        "    errors.add(ex);\n",
        "    errors.add(ex);\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "Nokogiri is a Rubygem providing HTML, XML, SAX, and Reader parsers with XPath and CSS selector support. In Nokogiri v1.12.4 and earlier, on JRuby only, the SAX parser resolves external entities by default. Users of Nokogiri on JRuby who parse untrusted documents using any of these classes are affected: Nokogiri::XML::SAX::Parse, Nokogiri::HTML4::SAX::Parser or its alias Nokogiri::HTML::SAX::Parser, Nokogiri::XML::SAX::PushParser, and Nokogiri::HTML4::SAX::PushParser or its alias Nokogiri::HTML::SAX::PushParser. JRuby users should upgrade to Nokogiri v1.12.5 or later to receive a patch for this issue. There are no workarounds available for v1.12.4 or earlier. CRuby users are not affected.",
    "id": 12174
  },
  {
    "cve_id": "CVE-2021-41098",
    "code_before_change": "{\n\n  protected static final String FEATURE_LOAD_EXTERNAL_DTD =\n    \"http://apache.org/xml/features/nonvalidating/load-external-dtd\";\n  protected static final String FEATURE_LOAD_DTD_GRAMMAR =\n    \"http://apache.org/xml/features/nonvalidating/load-dtd-grammar\";\n  protected static final String FEATURE_INCLUDE_IGNORABLE_WHITESPACE =\n    \"http://apache.org/xml/features/dom/include-ignorable-whitespace\";\n  protected static final String CONTINUE_AFTER_FATAL_ERROR =\n    \"http://apache.org/xml/features/continue-after-fatal-error\";\n  protected static final String FEATURE_NOT_EXPAND_ENTITY =\n    \"http://apache.org/xml/features/dom/create-entity-ref-nodes\";\n  protected static final String FEATURE_VALIDATION = \"http://xml.org/sax/features/validation\";\n  private static final String XINCLUDE_FEATURE_ID = \"http://apache.org/xml/features/xinclude\";\n  private static final String SECURITY_MANAGER = \"http://apache.org/xml/properties/security-manager\";\n\n  protected ParserContext.Options options;\n  protected DOMParser parser;\n  protected NokogiriErrorHandler errorHandler;\n  protected IRubyObject ruby_encoding;\n\n  public\n  XmlDomParserContext(Ruby runtime, IRubyObject options)\n  {\n    this(runtime, runtime.getNil(), options);\n  }\n\n  public\n  XmlDomParserContext(Ruby runtime, IRubyObject encoding, IRubyObject options)\n  {\n    super(runtime);\n    this.options = new ParserContext.Options(RubyFixnum.fix2long(options));\n    java_encoding = NokogiriHelpers.getValidEncodingOrNull(encoding);\n    ruby_encoding = encoding;\n    initErrorHandler();\n    initParser(runtime);\n  }\n\n  protected void\n  initErrorHandler()\n  {\n    if (options.recover) {\n      errorHandler = new NokogiriNonStrictErrorHandler(options.noError, options.noWarning);\n    } else {\n      errorHandler = new NokogiriStrictErrorHandler(options.noError, options.noWarning);\n    }\n  }\n\n  protected void\n  initParser(Ruby runtime)\n  {\n    if (options.xInclude) {\n      System.setProperty(\"org.apache.xerces.xni.parser.XMLParserConfiguration\",\n                         \"org.apache.xerces.parsers.XIncludeParserConfiguration\");\n    }\n\n    parser = new NokogiriDomParser(options);\n    parser.setErrorHandler(errorHandler);\n\n    // Fix for Issue#586.  This limits entity expansion up to 100000 and nodes up to 3000.\n    setProperty(SECURITY_MANAGER, new org.apache.xerces.util.SecurityManager());\n\n    if (options.noBlanks) {\n      setFeature(FEATURE_INCLUDE_IGNORABLE_WHITESPACE, false);\n    }\n\n    if (options.recover) {\n      setFeature(CONTINUE_AFTER_FATAL_ERROR, true);\n    }\n\n    if (options.dtdValid) {\n      setFeature(FEATURE_VALIDATION, true);\n    }\n\n    if (!options.noEnt) {\n      setFeature(FEATURE_NOT_EXPAND_ENTITY, true);\n    }\n    // If we turn off loading of external DTDs complete, we don't\n    // getthe publicID.  Instead of turning off completely, we use\n    // an entity resolver that returns empty documents.\n    if (options.dtdLoad) {\n      setFeature(FEATURE_LOAD_EXTERNAL_DTD, true);\n      setFeature(FEATURE_LOAD_DTD_GRAMMAR, true);\n    }\n    parser.setEntityResolver(new NokogiriEntityResolver(runtime, errorHandler, options));\n  }\n\n  /**\n   * Convenience method that catches and ignores SAXException\n   * (unrecognized and unsupported exceptions).\n   */\n  protected void\n  setFeature(String feature, boolean value)\n  {\n    try {\n      parser.setFeature(feature, value);\n    } catch (SAXException e) {\n      // ignore\n    }\n  }\n\n  /**\n   * Convenience method that catches and ignores SAXException\n   * (unrecognized and unsupported exceptions).\n   */\n  protected void\n  setProperty(String property, Object value)\n  {\n    try {\n      parser.setProperty(property, value);\n    } catch (SAXException e) {\n      // ignore\n    }\n  }\n\n  public void\n  addErrorsIfNecessary(ThreadContext context, XmlDocument doc)\n  {\n    doc.setInstanceVariable(\"@errors\", mapErrors(context, errorHandler));\n  }\n\n\n  public static RubyArray\n  mapErrors(ThreadContext context, NokogiriErrorHandler errorHandler)\n  {\n    final Ruby runtime = context.runtime;\n    final List<Exception> errors = errorHandler.getErrors();\n    final IRubyObject[] errorsAry = new IRubyObject[errors.size()];\n    for (int i = 0; i < errors.size(); i++) {\n      XmlSyntaxError xmlSyntaxError = XmlSyntaxError.createXMLSyntaxError(runtime);\n      xmlSyntaxError.setException(errors.get(i));\n      errorsAry[i] = xmlSyntaxError;\n    }\n    return runtime.newArrayNoCopy(errorsAry);\n  }\n\n  public XmlDocument\n  getDocumentWithErrorsOrRaiseException(ThreadContext context, RubyClass klazz, Exception ex)\n  {\n    if (options.recover) {\n      XmlDocument xmlDocument = getInterruptedOrNewXmlDocument(context, klazz);\n      this.addErrorsIfNecessary(context, xmlDocument);\n      XmlSyntaxError xmlSyntaxError = XmlSyntaxError.createXMLSyntaxError(context.runtime);\n      xmlSyntaxError.setException(ex);\n      ((RubyArray) xmlDocument.getInstanceVariable(\"@errors\")).append(xmlSyntaxError);\n      return xmlDocument;\n    } else {\n      XmlSyntaxError xmlSyntaxError = XmlSyntaxError.createXMLSyntaxError(context.runtime);\n      xmlSyntaxError.setException(ex);\n      throw xmlSyntaxError.toThrowable();\n    }\n  }\n\n  private XmlDocument\n  getInterruptedOrNewXmlDocument(ThreadContext context, RubyClass klass)\n  {\n    Document document = parser.getDocument();\n    XmlDocument xmlDocument = new XmlDocument(context.runtime, klass, document);\n    xmlDocument.setEncoding(ruby_encoding);\n    return xmlDocument;\n  }\n\n  /**\n   * This method is broken out so that HtmlDomParserContext can\n   * override it.\n   */\n  protected XmlDocument\n  wrapDocument(ThreadContext context, RubyClass klass, Document doc)\n  {\n    XmlDocument xmlDocument = new XmlDocument(context.runtime, klass, doc);\n    Helpers.invoke(context, xmlDocument, \"initialize\");\n    xmlDocument.setEncoding(ruby_encoding);\n\n    if (options.dtdLoad) {\n      IRubyObject dtd = XmlDtd.newFromExternalSubset(context.runtime, doc);\n      if (!dtd.isNil()) {\n        doc.setUserData(XmlDocument.DTD_EXTERNAL_SUBSET, (XmlDtd) dtd, null);\n      }\n    }\n    return xmlDocument;\n  }\n\n  /**\n   * Must call setInputSource() before this method.\n   */\n  public XmlDocument\n  parse(ThreadContext context, RubyClass klass, IRubyObject url)\n  {\n    XmlDocument xmlDoc;\n    try {\n      Document doc = do_parse();\n      xmlDoc = wrapDocument(context, klass, doc);\n      xmlDoc.setUrl(url);\n      addErrorsIfNecessary(context, xmlDoc);\n      return xmlDoc;\n    } catch (SAXException e) {\n      return getDocumentWithErrorsOrRaiseException(context, klass, e);\n    } catch (IOException e) {\n      return getDocumentWithErrorsOrRaiseException(context, klass, e);\n    }\n  }\n\n  protected Document\n  do_parse() throws SAXException, IOException\n  {\n    try {\n      parser.parse(getInputSource());\n    } catch (NullPointerException ex) {\n      // FIXME: this is really a hack to fix #838. Xerces will throw a NullPointerException\n      // if we tried to parse '<? ?>'. We should submit a patch to Xerces.\n    }\n    if (options.noBlanks) {\n      List<Node> emptyNodes = new ArrayList<Node>();\n      findEmptyTexts(parser.getDocument(), emptyNodes);\n      if (emptyNodes.size() > 0) {\n        for (Node node : emptyNodes) {\n          node.getParentNode().removeChild(node);\n        }\n      }\n    }\n    return parser.getDocument();\n  }\n\n  private static void\n  findEmptyTexts(Node node, List<Node> emptyNodes)\n  {\n    if (node.getNodeType() == Node.TEXT_NODE && isBlank(node.getTextContent())) {\n      emptyNodes.add(node);\n    } else {\n      NodeList children = node.getChildNodes();\n      for (int i = 0; i < children.getLength(); i++) {\n        findEmptyTexts(children.item(i), emptyNodes);\n      }\n    }\n  }\n}",
    "code_after_change": "{\n\n  protected static final String FEATURE_LOAD_EXTERNAL_DTD =\n    \"http://apache.org/xml/features/nonvalidating/load-external-dtd\";\n  protected static final String FEATURE_LOAD_DTD_GRAMMAR =\n    \"http://apache.org/xml/features/nonvalidating/load-dtd-grammar\";\n  protected static final String FEATURE_INCLUDE_IGNORABLE_WHITESPACE =\n    \"http://apache.org/xml/features/dom/include-ignorable-whitespace\";\n  protected static final String CONTINUE_AFTER_FATAL_ERROR =\n    \"http://apache.org/xml/features/continue-after-fatal-error\";\n  protected static final String FEATURE_NOT_EXPAND_ENTITY =\n    \"http://apache.org/xml/features/dom/create-entity-ref-nodes\";\n  protected static final String FEATURE_VALIDATION = \"http://xml.org/sax/features/validation\";\n  private static final String SECURITY_MANAGER = \"http://apache.org/xml/properties/security-manager\";\n\n  protected ParserContext.Options options;\n  protected DOMParser parser;\n  protected NokogiriErrorHandler errorHandler;\n  protected IRubyObject ruby_encoding;\n\n  public\n  XmlDomParserContext(Ruby runtime, IRubyObject options)\n  {\n    this(runtime, runtime.getNil(), options);\n  }\n\n  public\n  XmlDomParserContext(Ruby runtime, IRubyObject encoding, IRubyObject options)\n  {\n    super(runtime);\n    this.options = new ParserContext.Options(RubyFixnum.fix2long(options));\n    java_encoding = NokogiriHelpers.getValidEncodingOrNull(encoding);\n    ruby_encoding = encoding;\n    initErrorHandler(runtime);\n    initParser(runtime);\n  }\n\n  protected void\n  initErrorHandler(Ruby runtime)\n  {\n    if (options.recover) {\n      errorHandler = new NokogiriNonStrictErrorHandler(runtime, options.noError, options.noWarning);\n    } else {\n      errorHandler = new NokogiriStrictErrorHandler(runtime, options.noError, options.noWarning);\n    }\n  }\n\n  protected void\n  initParser(Ruby runtime)\n  {\n    if (options.xInclude) {\n      System.setProperty(\"org.apache.xerces.xni.parser.XMLParserConfiguration\",\n                         \"org.apache.xerces.parsers.XIncludeParserConfiguration\");\n    }\n\n    parser = new NokogiriDomParser(options);\n    parser.setErrorHandler(errorHandler);\n\n    // Fix for Issue#586.  This limits entity expansion up to 100000 and nodes up to 3000.\n    setProperty(SECURITY_MANAGER, new org.apache.xerces.util.SecurityManager());\n\n    if (options.noBlanks) {\n      setFeature(FEATURE_INCLUDE_IGNORABLE_WHITESPACE, false);\n    }\n\n    if (options.recover) {\n      setFeature(CONTINUE_AFTER_FATAL_ERROR, true);\n    }\n\n    if (options.dtdValid) {\n      setFeature(FEATURE_VALIDATION, true);\n    }\n\n    if (!options.noEnt) {\n      setFeature(FEATURE_NOT_EXPAND_ENTITY, true);\n    }\n    // If we turn off loading of external DTDs complete, we don't\n    // getthe publicID.  Instead of turning off completely, we use\n    // an entity resolver that returns empty documents.\n    if (options.dtdLoad) {\n      setFeature(FEATURE_LOAD_EXTERNAL_DTD, true);\n      setFeature(FEATURE_LOAD_DTD_GRAMMAR, true);\n    }\n    parser.setEntityResolver(new NokogiriEntityResolver(runtime, errorHandler, options));\n  }\n\n  /**\n   * Convenience method that catches and ignores SAXException\n   * (unrecognized and unsupported exceptions).\n   */\n  protected void\n  setFeature(String feature, boolean value)\n  {\n    try {\n      parser.setFeature(feature, value);\n    } catch (SAXException e) {\n      // ignore\n    }\n  }\n\n  /**\n   * Convenience method that catches and ignores SAXException\n   * (unrecognized and unsupported exceptions).\n   */\n  protected void\n  setProperty(String property, Object value)\n  {\n    try {\n      parser.setProperty(property, value);\n    } catch (SAXException e) {\n      // ignore\n    }\n  }\n\n  public void\n  addErrorsIfNecessary(ThreadContext context, XmlDocument doc)\n  {\n    doc.setInstanceVariable(\"@errors\", mapErrors(context, errorHandler));\n  }\n\n\n  public static RubyArray\n  mapErrors(ThreadContext context, NokogiriErrorHandler errorHandler)\n  {\n    final Ruby runtime = context.runtime;\n    final List<RubyException> errors = errorHandler.getErrors();\n    final IRubyObject[] errorsAry = new IRubyObject[errors.size()];\n    for (int i = 0; i < errors.size(); i++) {\n      errorsAry[i] = errors.get(i);\n    }\n    return runtime.newArrayNoCopy(errorsAry);\n  }\n\n  public XmlDocument\n  getDocumentWithErrorsOrRaiseException(ThreadContext context, RubyClass klazz, Exception ex)\n  {\n    if (options.recover) {\n      XmlDocument xmlDocument = getInterruptedOrNewXmlDocument(context, klazz);\n      this.addErrorsIfNecessary(context, xmlDocument);\n      XmlSyntaxError xmlSyntaxError = XmlSyntaxError.createXMLSyntaxError(context.runtime);\n      xmlSyntaxError.setException(ex);\n      ((RubyArray) xmlDocument.getInstanceVariable(\"@errors\")).append(xmlSyntaxError);\n      return xmlDocument;\n    } else {\n      XmlSyntaxError xmlSyntaxError = XmlSyntaxError.createXMLSyntaxError(context.runtime);\n      xmlSyntaxError.setException(ex);\n      throw xmlSyntaxError.toThrowable();\n    }\n  }\n\n  private XmlDocument\n  getInterruptedOrNewXmlDocument(ThreadContext context, RubyClass klass)\n  {\n    Document document = parser.getDocument();\n    XmlDocument xmlDocument = new XmlDocument(context.runtime, klass, document);\n    xmlDocument.setEncoding(ruby_encoding);\n    return xmlDocument;\n  }\n\n  /**\n   * This method is broken out so that HtmlDomParserContext can\n   * override it.\n   */\n  protected XmlDocument\n  wrapDocument(ThreadContext context, RubyClass klass, Document doc)\n  {\n    XmlDocument xmlDocument = new XmlDocument(context.runtime, klass, doc);\n    Helpers.invoke(context, xmlDocument, \"initialize\");\n    xmlDocument.setEncoding(ruby_encoding);\n\n    if (options.dtdLoad) {\n      IRubyObject dtd = XmlDtd.newFromExternalSubset(context.runtime, doc);\n      if (!dtd.isNil()) {\n        doc.setUserData(XmlDocument.DTD_EXTERNAL_SUBSET, (XmlDtd) dtd, null);\n      }\n    }\n    return xmlDocument;\n  }\n\n  /**\n   * Must call setInputSource() before this method.\n   */\n  public XmlDocument\n  parse(ThreadContext context, RubyClass klass, IRubyObject url)\n  {\n    XmlDocument xmlDoc;\n    try {\n      Document doc = do_parse();\n      xmlDoc = wrapDocument(context, klass, doc);\n      xmlDoc.setUrl(url);\n      addErrorsIfNecessary(context, xmlDoc);\n      return xmlDoc;\n    } catch (SAXException e) {\n      return getDocumentWithErrorsOrRaiseException(context, klass, e);\n    } catch (IOException e) {\n      return getDocumentWithErrorsOrRaiseException(context, klass, e);\n    }\n  }\n\n  protected Document\n  do_parse() throws SAXException, IOException\n  {\n    try {\n      parser.parse(getInputSource());\n    } catch (NullPointerException ex) {\n      // FIXME: this is really a hack to fix #838. Xerces will throw a NullPointerException\n      // if we tried to parse '<? ?>'. We should submit a patch to Xerces.\n    }\n    if (options.noBlanks) {\n      List<Node> emptyNodes = new ArrayList<Node>();\n      findEmptyTexts(parser.getDocument(), emptyNodes);\n      if (emptyNodes.size() > 0) {\n        for (Node node : emptyNodes) {\n          node.getParentNode().removeChild(node);\n        }\n      }\n    }\n    return parser.getDocument();\n  }\n\n  private static void\n  findEmptyTexts(Node node, List<Node> emptyNodes)\n  {\n    if (node.getNodeType() == Node.TEXT_NODE && isBlank(node.getTextContent())) {\n      emptyNodes.add(node);\n    } else {\n      NodeList children = node.getChildNodes();\n      for (int i = 0; i < children.getLength(); i++) {\n        findEmptyTexts(children.item(i), emptyNodes);\n      }\n    }\n  }\n}",
    "patch": "@@ -1,30 +1,24 @@\n package nokogiri.internals;\n \n-import static nokogiri.internals.NokogiriHelpers.getNokogiriClass;\n-import static nokogiri.internals.NokogiriHelpers.isBlank;\n-\n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.List;\n-\n+import nokogiri.XmlDocument;\n+import nokogiri.XmlDtd;\n+import nokogiri.XmlSyntaxError;\n import org.apache.xerces.parsers.DOMParser;\n-import org.jruby.Ruby;\n-import org.jruby.RubyArray;\n-import org.jruby.RubyClass;\n-import org.jruby.RubyFixnum;\n+import org.jruby.*;\n import org.jruby.exceptions.RaiseException;\n-import org.jruby.runtime.ThreadContext;\n import org.jruby.runtime.Helpers;\n+import org.jruby.runtime.ThreadContext;\n import org.jruby.runtime.builtin.IRubyObject;\n import org.w3c.dom.Document;\n import org.w3c.dom.Node;\n import org.w3c.dom.NodeList;\n import org.xml.sax.SAXException;\n \n-import nokogiri.NokogiriService;\n-import nokogiri.XmlDocument;\n-import nokogiri.XmlDtd;\n-import nokogiri.XmlSyntaxError;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static nokogiri.internals.NokogiriHelpers.isBlank;\n \n /**\n  * Parser class for XML DOM processing. This class actually parses XML document\n@@ -48,7 +42,6 @@ public class XmlDomParserContext extends ParserContext\n   protected static final String FEATURE_NOT_EXPAND_ENTITY =\n     \"http://apache.org/xml/features/dom/create-entity-ref-nodes\";\n   protected static final String FEATURE_VALIDATION = \"http://xml.org/sax/features/validation\";\n-  private static final String XINCLUDE_FEATURE_ID = \"http://apache.org/xml/features/xinclude\";\n   private static final String SECURITY_MANAGER = \"http://apache.org/xml/properties/security-manager\";\n \n   protected ParserContext.Options options;\n@@ -69,17 +62,17 @@ public class XmlDomParserContext extends ParserContext\n     this.options = new ParserContext.Options(RubyFixnum.fix2long(options));\n     java_encoding = NokogiriHelpers.getValidEncodingOrNull(encoding);\n     ruby_encoding = encoding;\n-    initErrorHandler();\n+    initErrorHandler(runtime);\n     initParser(runtime);\n   }\n \n   protected void\n-  initErrorHandler()\n+  initErrorHandler(Ruby runtime)\n   {\n     if (options.recover) {\n-      errorHandler = new NokogiriNonStrictErrorHandler(options.noError, options.noWarning);\n+      errorHandler = new NokogiriNonStrictErrorHandler(runtime, options.noError, options.noWarning);\n     } else {\n-      errorHandler = new NokogiriStrictErrorHandler(options.noError, options.noWarning);\n+      errorHandler = new NokogiriStrictErrorHandler(runtime, options.noError, options.noWarning);\n     }\n   }\n \n@@ -161,12 +154,10 @@ public class XmlDomParserContext extends ParserContext\n   mapErrors(ThreadContext context, NokogiriErrorHandler errorHandler)\n   {\n     final Ruby runtime = context.runtime;\n-    final List<Exception> errors = errorHandler.getErrors();\n+    final List<RubyException> errors = errorHandler.getErrors();\n     final IRubyObject[] errorsAry = new IRubyObject[errors.size()];\n     for (int i = 0; i < errors.size(); i++) {\n-      XmlSyntaxError xmlSyntaxError = XmlSyntaxError.createXMLSyntaxError(runtime);\n-      xmlSyntaxError.setException(errors.get(i));\n-      errorsAry[i] = xmlSyntaxError;\n+      errorsAry[i] = errors.get(i);\n     }\n     return runtime.newArrayNoCopy(errorsAry);\n   }",
    "function_modified_lines": {
      "added": [
        "    initErrorHandler(runtime);\n",
        "  initErrorHandler(Ruby runtime)\n",
        "      errorHandler = new NokogiriNonStrictErrorHandler(runtime, options.noError, options.noWarning);\n",
        "      errorHandler = new NokogiriStrictErrorHandler(runtime, options.noError, options.noWarning);\n"
      ],
      "deleted": [
        "    initErrorHandler();\n",
        "  initErrorHandler()\n",
        "      errorHandler = new NokogiriNonStrictErrorHandler(options.noError, options.noWarning);\n",
        "      errorHandler = new NokogiriStrictErrorHandler(options.noError, options.noWarning);\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "Nokogiri is a Rubygem providing HTML, XML, SAX, and Reader parsers with XPath and CSS selector support. In Nokogiri v1.12.4 and earlier, on JRuby only, the SAX parser resolves external entities by default. Users of Nokogiri on JRuby who parse untrusted documents using any of these classes are affected: Nokogiri::XML::SAX::Parse, Nokogiri::HTML4::SAX::Parser or its alias Nokogiri::HTML::SAX::Parser, Nokogiri::XML::SAX::PushParser, and Nokogiri::HTML4::SAX::PushParser or its alias Nokogiri::HTML::SAX::PushParser. JRuby users should upgrade to Nokogiri v1.12.5 or later to receive a patch for this issue. There are no workarounds available for v1.12.4 or earlier. CRuby users are not affected.",
    "id": 12176
  },
  {
    "cve_id": "CVE-2021-41098",
    "code_before_change": "{\n    final Ruby runtime = context.runtime;\n    final List<Exception> errors = errorHandler.getErrors();\n    final IRubyObject[] errorsAry = new IRubyObject[errors.size()];\n    for (int i = 0; i < errors.size(); i++) {\n      XmlSyntaxError xmlSyntaxError = XmlSyntaxError.createXMLSyntaxError(runtime);\n      xmlSyntaxError.setException(errors.get(i));\n      errorsAry[i] = xmlSyntaxError;\n    }\n    return runtime.newArrayNoCopy(errorsAry);\n  }",
    "code_after_change": "{\n    final Ruby runtime = context.runtime;\n    final List<RubyException> errors = errorHandler.getErrors();\n    final IRubyObject[] errorsAry = new IRubyObject[errors.size()];\n    for (int i = 0; i < errors.size(); i++) {\n      errorsAry[i] = errors.get(i);\n    }\n    return runtime.newArrayNoCopy(errorsAry);\n  }",
    "patch": "@@ -1,30 +1,24 @@\n package nokogiri.internals;\n \n-import static nokogiri.internals.NokogiriHelpers.getNokogiriClass;\n-import static nokogiri.internals.NokogiriHelpers.isBlank;\n-\n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.List;\n-\n+import nokogiri.XmlDocument;\n+import nokogiri.XmlDtd;\n+import nokogiri.XmlSyntaxError;\n import org.apache.xerces.parsers.DOMParser;\n-import org.jruby.Ruby;\n-import org.jruby.RubyArray;\n-import org.jruby.RubyClass;\n-import org.jruby.RubyFixnum;\n+import org.jruby.*;\n import org.jruby.exceptions.RaiseException;\n-import org.jruby.runtime.ThreadContext;\n import org.jruby.runtime.Helpers;\n+import org.jruby.runtime.ThreadContext;\n import org.jruby.runtime.builtin.IRubyObject;\n import org.w3c.dom.Document;\n import org.w3c.dom.Node;\n import org.w3c.dom.NodeList;\n import org.xml.sax.SAXException;\n \n-import nokogiri.NokogiriService;\n-import nokogiri.XmlDocument;\n-import nokogiri.XmlDtd;\n-import nokogiri.XmlSyntaxError;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static nokogiri.internals.NokogiriHelpers.isBlank;\n \n /**\n  * Parser class for XML DOM processing. This class actually parses XML document\n@@ -48,7 +42,6 @@ public class XmlDomParserContext extends ParserContext\n   protected static final String FEATURE_NOT_EXPAND_ENTITY =\n     \"http://apache.org/xml/features/dom/create-entity-ref-nodes\";\n   protected static final String FEATURE_VALIDATION = \"http://xml.org/sax/features/validation\";\n-  private static final String XINCLUDE_FEATURE_ID = \"http://apache.org/xml/features/xinclude\";\n   private static final String SECURITY_MANAGER = \"http://apache.org/xml/properties/security-manager\";\n \n   protected ParserContext.Options options;\n@@ -69,17 +62,17 @@ public class XmlDomParserContext extends ParserContext\n     this.options = new ParserContext.Options(RubyFixnum.fix2long(options));\n     java_encoding = NokogiriHelpers.getValidEncodingOrNull(encoding);\n     ruby_encoding = encoding;\n-    initErrorHandler();\n+    initErrorHandler(runtime);\n     initParser(runtime);\n   }\n \n   protected void\n-  initErrorHandler()\n+  initErrorHandler(Ruby runtime)\n   {\n     if (options.recover) {\n-      errorHandler = new NokogiriNonStrictErrorHandler(options.noError, options.noWarning);\n+      errorHandler = new NokogiriNonStrictErrorHandler(runtime, options.noError, options.noWarning);\n     } else {\n-      errorHandler = new NokogiriStrictErrorHandler(options.noError, options.noWarning);\n+      errorHandler = new NokogiriStrictErrorHandler(runtime, options.noError, options.noWarning);\n     }\n   }\n \n@@ -161,12 +154,10 @@ public class XmlDomParserContext extends ParserContext\n   mapErrors(ThreadContext context, NokogiriErrorHandler errorHandler)\n   {\n     final Ruby runtime = context.runtime;\n-    final List<Exception> errors = errorHandler.getErrors();\n+    final List<RubyException> errors = errorHandler.getErrors();\n     final IRubyObject[] errorsAry = new IRubyObject[errors.size()];\n     for (int i = 0; i < errors.size(); i++) {\n-      XmlSyntaxError xmlSyntaxError = XmlSyntaxError.createXMLSyntaxError(runtime);\n-      xmlSyntaxError.setException(errors.get(i));\n-      errorsAry[i] = xmlSyntaxError;\n+      errorsAry[i] = errors.get(i);\n     }\n     return runtime.newArrayNoCopy(errorsAry);\n   }",
    "function_modified_lines": {
      "added": [
        "    final List<RubyException> errors = errorHandler.getErrors();\n",
        "      errorsAry[i] = errors.get(i);\n"
      ],
      "deleted": [
        "    final List<Exception> errors = errorHandler.getErrors();\n",
        "      XmlSyntaxError xmlSyntaxError = XmlSyntaxError.createXMLSyntaxError(runtime);\n",
        "      xmlSyntaxError.setException(errors.get(i));\n",
        "      errorsAry[i] = xmlSyntaxError;\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "Nokogiri is a Rubygem providing HTML, XML, SAX, and Reader parsers with XPath and CSS selector support. In Nokogiri v1.12.4 and earlier, on JRuby only, the SAX parser resolves external entities by default. Users of Nokogiri on JRuby who parse untrusted documents using any of these classes are affected: Nokogiri::XML::SAX::Parse, Nokogiri::HTML4::SAX::Parser or its alias Nokogiri::HTML::SAX::Parser, Nokogiri::XML::SAX::PushParser, and Nokogiri::HTML4::SAX::PushParser or its alias Nokogiri::HTML::SAX::PushParser. JRuby users should upgrade to Nokogiri v1.12.5 or later to receive a patch for this issue. There are no workarounds available for v1.12.4 or earlier. CRuby users are not affected.",
    "id": 12177
  },
  {
    "cve_id": "CVE-2021-23792",
    "code_before_change": "{\n        Validate.notNull(input, \"input\");\n\n        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n        factory.setNamespaceAware(true);\n\n        try {\n            // TODO: Consider parsing using SAX?\n            // TODO: Determine encoding and parse using a Reader...\n            // TODO: Refactor scanner to return inputstream?\n            // TODO: Be smarter about ASCII-NULL termination/padding (the SAXParser aka Xerces DOMParser doesn't like it)...\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            builder.setErrorHandler(new DefaultHandler());\n            Document document = builder.parse(new InputSource(IIOUtil.createStreamAdapter(input)));\n\n//            XMLSerializer serializer = new XMLSerializer(System.err, System.getProperty(\"file.encoding\"));\n//            serializer.serialize(document);\n\n            String toolkit = getToolkit(document);\n            Node rdfRoot = document.getElementsByTagNameNS(XMP.NS_RDF, \"RDF\").item(0);\n            NodeList descriptions = document.getElementsByTagNameNS(XMP.NS_RDF, \"Description\");\n\n            return parseDirectories(rdfRoot, descriptions, toolkit);\n        }\n        catch (SAXException e) {\n            throw new IIOException(e.getMessage(), e);\n        }\n        catch (ParserConfigurationException e) {\n            throw new RuntimeException(e); // TODO: Or IOException?\n        }\n    }",
    "code_after_change": "{\n    // See http://www.scribd.com/doc/56852716/XMPSpecificationPart1\n\n    // TODO: Types? Probably defined in XMP/RDF XML schema. Or are we happy that everything is a string?\n\n    @Override\n    public Directory read(final ImageInputStream input) throws IOException {\n        Validate.notNull(input, \"input\");\n\n        try {\n            DocumentBuilderFactory factory = createDocumentBuilderFactory();\n\n            // TODO: Consider parsing using SAX?\n            // TODO: Determine encoding and parse using a Reader...\n            // TODO: Refactor scanner to return inputstream?\n            // TODO: Be smarter about ASCII-NULL termination/padding (the SAXParser aka Xerces DOMParser doesn't like it)...\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            builder.setErrorHandler(new DefaultHandler());\n            Document document = builder.parse(new InputSource(IIOUtil.createStreamAdapter(input)));\n\n            String toolkit = getToolkit(document);\n            Node rdfRoot = document.getElementsByTagNameNS(XMP.NS_RDF, \"RDF\").item(0);\n            NodeList descriptions = document.getElementsByTagNameNS(XMP.NS_RDF, \"Description\");\n\n            return parseDirectories(rdfRoot, descriptions, toolkit);\n        }\n        catch (SAXException e) {\n            throw new IIOException(e.getMessage(), e);\n        }\n        catch (ParserConfigurationException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private DocumentBuilderFactory createDocumentBuilderFactory() throws ParserConfigurationException {\n        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n        factory.setNamespaceAware(true);\n\n        // Security: Disable XInclude & expanding entity references (\"bombs\"), not needed for XMP\n        factory.setXIncludeAware(false);\n        factory.setExpandEntityReferences(false);\n\n        // Security: Enable \"secure processing\", to prevent DoS attacks\n        factory.setAttribute(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n\n        // Security: Remove possibility to access external DTDs or Schema, not needed for XMP\n        factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, \"\");\n        factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_SCHEMA, \"\");\n\n        // Security: Disable loading of external DTD and entities, not needed for XMP\n        factory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n        factory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n        factory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n\n        return factory;\n    }\n\n    private String getToolkit(Document document) {\n        NodeList xmpmeta = document.getElementsByTagNameNS(XMP.NS_X, \"xmpmeta\");\n\n        if (xmpmeta == null || xmpmeta.getLength() <= 0) {\n            return null;\n        }\n\n        Node toolkit = xmpmeta.item(0).getAttributes().getNamedItemNS(XMP.NS_X, \"xmptk\");\n\n        return toolkit != null ? toolkit.getNodeValue() : null;\n    }\n\n    private XMPDirectory parseDirectories(final Node pParentNode, NodeList pNodes, String toolkit) {\n        Map<String, List<Entry>> subdirs = new LinkedHashMap<>();\n\n        for (Node desc : asIterable(pNodes)) {\n            if (desc.getParentNode() != pParentNode) {\n                continue;\n            }\n\n            // Support attribute short-hand syntax\n            parseAttributesForKnownElements(subdirs, desc);\n\n            for (Node node : asIterable(desc.getChildNodes())) {\n                if (node.getNodeType() != Node.ELEMENT_NODE) {\n                    continue;\n                }\n\n                // Lookup\n                List<Entry> dir = subdirs.get(node.getNamespaceURI());\n                if (dir == null) {\n                    dir = new ArrayList<>();\n                    subdirs.put(node.getNamespaceURI(), dir);\n                }\n\n                Object value;\n\n                if (isResourceType(node)) {\n                    value = parseAsResource(node);\n                }\n                else {\n                    // TODO: This method contains loads of duplication an should be cleaned up...\n                    // Support attribute short-hand syntax\n                    Map<String, List<Entry>> subsubdirs = new LinkedHashMap<>();\n\n                    parseAttributesForKnownElements(subsubdirs, node);\n\n                    if (!subsubdirs.isEmpty()) {\n                        List<Entry> entries = new ArrayList<>(subsubdirs.size());\n\n                        for (Map.Entry<String, List<Entry>> entry : subsubdirs.entrySet()) {\n                            entries.addAll(entry.getValue());\n                        }\n\n                        value = new RDFDescription(entries);\n                    }\n                    else {\n                        value = getChildTextValue(node);\n                    }\n                }\n\n                dir.add(new XMPEntry(node.getNamespaceURI() + node.getLocalName(), node.getLocalName(), value));\n            }\n        }\n\n        List<Directory> entries = new ArrayList<>(subdirs.size());\n\n        // TODO: Should we still allow asking for a subdirectory by item id?\n        for (Map.Entry<String, List<Entry>> entry : subdirs.entrySet()) {\n            entries.add(new RDFDescription(entry.getKey(), entry.getValue()));\n        }\n\n        return new XMPDirectory(entries, toolkit);\n    }\n\n    private boolean isResourceType(Node node) {\n        Node parseType = node.getAttributes().getNamedItemNS(XMP.NS_RDF, \"parseType\");\n\n        return parseType != null && \"Resource\".equals(parseType.getNodeValue());\n    }\n\n    private RDFDescription parseAsResource(Node node) {\n        // See: http://www.w3.org/TR/REC-rdf-syntax/#section-Syntax-parsetype-resource\n        List<Entry> entries = new ArrayList<>();\n\n        for (Node child : asIterable(node.getChildNodes())) {\n            if (child.getNodeType() != Node.ELEMENT_NODE) {\n                continue;\n            }\n\n            entries.add(new XMPEntry(child.getNamespaceURI() + child.getLocalName(), child.getLocalName(), getChildTextValue(child)));\n        }\n\n        return new RDFDescription(entries);\n    }\n\n    private void parseAttributesForKnownElements(Map<String, List<Entry>> subdirs, Node desc) {\n        // NOTE: NamedNodeMap does not have any particular order...\n        NamedNodeMap attributes = desc.getAttributes();\n\n        for (Node attr : asIterable(attributes)) {\n            if (!XMP.ELEMENTS.contains(attr.getNamespaceURI())) {\n                continue;\n            }\n\n            List<Entry> dir = subdirs.get(attr.getNamespaceURI());\n\n            if (dir == null) {\n                dir = new ArrayList<>();\n                subdirs.put(attr.getNamespaceURI(), dir);\n            }\n\n            dir.add(new XMPEntry(attr.getNamespaceURI() + attr.getLocalName(), attr.getLocalName(), attr.getNodeValue()));\n        }\n    }\n\n    private Object getChildTextValue(final Node node) {\n        for (Node child : asIterable(node.getChildNodes())) {\n            if (XMP.NS_RDF.equals(child.getNamespaceURI()) && \"Alt\".equals(child.getLocalName())) {\n                // Support for <rdf:Alt><rdf:li> -> return a Map<String, Object> keyed on xml:lang\n                Map<String, Object> alternatives = new LinkedHashMap<>();\n                for (Node alternative : asIterable(child.getChildNodes())) {\n                    if (XMP.NS_RDF.equals(alternative.getNamespaceURI()) && \"li\".equals(alternative.getLocalName())) {\n                        NamedNodeMap attributes = alternative.getAttributes();\n                        Node key = attributes.getNamedItem(\"xml:lang\");\n                        alternatives.put(key == null ? null : key.getTextContent(), getChildTextValue(alternative));\n                    }\n                }\n\n                return alternatives;\n            }\n            else if (XMP.NS_RDF.equals(child.getNamespaceURI()) && (\"Seq\".equals(child.getLocalName()) || \"Bag\".equals(child.getLocalName()))) {\n                // Support for <rdf:Seq><rdf:li> -> return array\n                // Support for <rdf:Bag><rdf:li> -> return array/unordered collection (how can a serialized collection not have order?)\n                List<Object> seq = new ArrayList<>();\n\n                for (Node sequence : asIterable(child.getChildNodes())) {\n                    if (XMP.NS_RDF.equals(sequence.getNamespaceURI()) && \"li\".equals(sequence.getLocalName())) {\n                        Object value = getChildTextValue(sequence);\n                        seq.add(value);\n                    }\n                }\n\n                // TODO: Strictly a bag should not be a list, but there's no Bag type (or similar) in Java.\n                // Consider something like Google collections Multiset or Apache commons Bag (the former seems more well-defined)\n                // Note: Collection does not have defined equals() semantics, and so using\n                // Collections.unmodifiableCollection() doesn't work for comparing values (uses Object.equals())\n                return Collections.unmodifiableList(seq);\n            }\n        }\n\n        // Need to support rdf:parseType=\"Resource\" here as well...\n        if (isResourceType(node)) {\n            return parseAsResource(node);\n        }\n\n        Node child = node.getFirstChild();\n        String strVal = child != null ? child.getNodeValue() : null;\n        return strVal != null ? strVal.trim() : \"\";\n    }\n\n    private Iterable<? extends Node> asIterable(final NamedNodeMap pNodeList) {\n        return new Iterable<Node>() {\n            public Iterator<Node> iterator() {\n                return new Iterator<Node>() {\n                    private int index;\n\n                    public boolean hasNext() {\n                        return pNodeList != null && pNodeList.getLength() > index;\n                    }\n\n                    public Node next() {\n                        return pNodeList.item(index++);\n                    }\n\n                    public void remove() {\n                        throw new UnsupportedOperationException(\"Method remove not supported\");\n                    }\n                };\n            }\n        };\n    }\n\n    private Iterable<? extends Node> asIterable(final NodeList pNodeList) {\n        return new Iterable<Node>() {\n            public Iterator<Node> iterator() {\n                return new Iterator<Node>() {\n                    private int index;\n\n                    public boolean hasNext() {\n                        return pNodeList != null && pNodeList.getLength() > index;\n                    }\n\n                    public Node next() {\n                        return pNodeList.item(index++);\n                    }\n\n                    public void remove() {\n                        throw new UnsupportedOperationException(\"Method remove not supported\");\n                    }\n                };\n            }\n        };\n    }\n}",
    "patch": "@@ -30,11 +30,21 @@\n \n package com.twelvemonkeys.imageio.metadata.xmp;\n \n-import com.twelvemonkeys.imageio.metadata.Directory;\n-import com.twelvemonkeys.imageio.metadata.Entry;\n-import com.twelvemonkeys.imageio.metadata.MetadataReader;\n-import com.twelvemonkeys.imageio.util.IIOUtil;\n-import com.twelvemonkeys.lang.Validate;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.imageio.IIOException;\n+import javax.imageio.stream.ImageInputStream;\n+import javax.xml.XMLConstants;\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.parsers.ParserConfigurationException;\n+\n import org.w3c.dom.Document;\n import org.w3c.dom.NamedNodeMap;\n import org.w3c.dom.Node;\n@@ -43,13 +53,11 @@\n import org.xml.sax.SAXException;\n import org.xml.sax.helpers.DefaultHandler;\n \n-import javax.imageio.IIOException;\n-import javax.imageio.stream.ImageInputStream;\n-import javax.xml.parsers.DocumentBuilder;\n-import javax.xml.parsers.DocumentBuilderFactory;\n-import javax.xml.parsers.ParserConfigurationException;\n-import java.io.IOException;\n-import java.util.*;\n+import com.twelvemonkeys.imageio.metadata.Directory;\n+import com.twelvemonkeys.imageio.metadata.Entry;\n+import com.twelvemonkeys.imageio.metadata.MetadataReader;\n+import com.twelvemonkeys.imageio.util.IIOUtil;\n+import com.twelvemonkeys.lang.Validate;\n \n /**\n  * XMPReader\n@@ -67,10 +75,9 @@ public final class XMPReader extends MetadataReader {\n     public Directory read(final ImageInputStream input) throws IOException {\n         Validate.notNull(input, \"input\");\n \n-        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n-        factory.setNamespaceAware(true);\n-\n         try {\n+            DocumentBuilderFactory factory = createDocumentBuilderFactory();\n+\n             // TODO: Consider parsing using SAX?\n             // TODO: Determine encoding and parse using a Reader...\n             // TODO: Refactor scanner to return inputstream?\n@@ -79,9 +86,6 @@ public Directory read(final ImageInputStream input) throws IOException {\n             builder.setErrorHandler(new DefaultHandler());\n             Document document = builder.parse(new InputSource(IIOUtil.createStreamAdapter(input)));\n \n-//            XMLSerializer serializer = new XMLSerializer(System.err, System.getProperty(\"file.encoding\"));\n-//            serializer.serialize(document);\n-\n             String toolkit = getToolkit(document);\n             Node rdfRoot = document.getElementsByTagNameNS(XMP.NS_RDF, \"RDF\").item(0);\n             NodeList descriptions = document.getElementsByTagNameNS(XMP.NS_RDF, \"Description\");\n@@ -92,10 +96,33 @@ public Directory read(final ImageInputStream input) throws IOException {\n             throw new IIOException(e.getMessage(), e);\n         }\n         catch (ParserConfigurationException e) {\n-            throw new RuntimeException(e); // TODO: Or IOException?\n+            throw new RuntimeException(e);\n         }\n     }\n \n+    private DocumentBuilderFactory createDocumentBuilderFactory() throws ParserConfigurationException {\n+        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n+        factory.setNamespaceAware(true);\n+\n+        // Security: Disable XInclude & expanding entity references (\"bombs\"), not needed for XMP\n+        factory.setXIncludeAware(false);\n+        factory.setExpandEntityReferences(false);\n+\n+        // Security: Enable \"secure processing\", to prevent DoS attacks\n+        factory.setAttribute(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n+\n+        // Security: Remove possibility to access external DTDs or Schema, not needed for XMP\n+        factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, \"\");\n+        factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_SCHEMA, \"\");\n+\n+        // Security: Disable loading of external DTD and entities, not needed for XMP\n+        factory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n+        factory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n+        factory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n+\n+        return factory;\n+    }\n+\n     private String getToolkit(Document document) {\n         NodeList xmpmeta = document.getElementsByTagNameNS(XMP.NS_X, \"xmpmeta\");\n \n@@ -109,7 +136,7 @@ private String getToolkit(Document document) {\n     }\n \n     private XMPDirectory parseDirectories(final Node pParentNode, NodeList pNodes, String toolkit) {\n-        Map<String, List<Entry>> subdirs = new LinkedHashMap<String, List<Entry>>();\n+        Map<String, List<Entry>> subdirs = new LinkedHashMap<>();\n \n         for (Node desc : asIterable(pNodes)) {\n             if (desc.getParentNode() != pParentNode) {\n@@ -127,7 +154,7 @@ private XMPDirectory parseDirectories(final Node pParentNode, NodeList pNodes, S\n                 // Lookup\n                 List<Entry> dir = subdirs.get(node.getNamespaceURI());\n                 if (dir == null) {\n-                    dir = new ArrayList<Entry>();\n+                    dir = new ArrayList<>();\n                     subdirs.put(node.getNamespaceURI(), dir);\n                 }\n \n@@ -139,7 +166,7 @@ private XMPDirectory parseDirectories(final Node pParentNode, NodeList pNodes, S\n                 else {\n                     // TODO: This method contains loads of duplication an should be cleaned up...\n                     // Support attribute short-hand syntax\n-                    Map<String, List<Entry>> subsubdirs = new LinkedHashMap<String, List<Entry>>();\n+                    Map<String, List<Entry>> subsubdirs = new LinkedHashMap<>();\n \n                     parseAttributesForKnownElements(subsubdirs, node);\n \n@@ -161,7 +188,7 @@ private XMPDirectory parseDirectories(final Node pParentNode, NodeList pNodes, S\n             }\n         }\n \n-        List<Directory> entries = new ArrayList<Directory>(subdirs.size());\n+        List<Directory> entries = new ArrayList<>(subdirs.size());\n \n         // TODO: Should we still allow asking for a subdirectory by item id?\n         for (Map.Entry<String, List<Entry>> entry : subdirs.entrySet()) {\n@@ -179,7 +206,7 @@ private boolean isResourceType(Node node) {\n \n     private RDFDescription parseAsResource(Node node) {\n         // See: http://www.w3.org/TR/REC-rdf-syntax/#section-Syntax-parsetype-resource\n-        List<Entry> entries = new ArrayList<Entry>();\n+        List<Entry> entries = new ArrayList<>();\n \n         for (Node child : asIterable(node.getChildNodes())) {\n             if (child.getNodeType() != Node.ELEMENT_NODE) {\n@@ -204,7 +231,7 @@ private void parseAttributesForKnownElements(Map<String, List<Entry>> subdirs, N\n             List<Entry> dir = subdirs.get(attr.getNamespaceURI());\n \n             if (dir == null) {\n-                dir = new ArrayList<Entry>();\n+                dir = new ArrayList<>();\n                 subdirs.put(attr.getNamespaceURI(), dir);\n             }\n \n@@ -216,7 +243,7 @@ private Object getChildTextValue(final Node node) {\n         for (Node child : asIterable(node.getChildNodes())) {\n             if (XMP.NS_RDF.equals(child.getNamespaceURI()) && \"Alt\".equals(child.getLocalName())) {\n                 // Support for <rdf:Alt><rdf:li> -> return a Map<String, Object> keyed on xml:lang\n-                Map<String, Object> alternatives = new LinkedHashMap<String, Object>();\n+                Map<String, Object> alternatives = new LinkedHashMap<>();\n                 for (Node alternative : asIterable(child.getChildNodes())) {\n                     if (XMP.NS_RDF.equals(alternative.getNamespaceURI()) && \"li\".equals(alternative.getLocalName())) {\n                         NamedNodeMap attributes = alternative.getAttributes();\n@@ -230,7 +257,7 @@ private Object getChildTextValue(final Node node) {\n             else if (XMP.NS_RDF.equals(child.getNamespaceURI()) && (\"Seq\".equals(child.getLocalName()) || \"Bag\".equals(child.getLocalName()))) {\n                 // Support for <rdf:Seq><rdf:li> -> return array\n                 // Support for <rdf:Bag><rdf:li> -> return array/unordered collection (how can a serialized collection not have order?)\n-                List<Object> seq = new ArrayList<Object>();\n+                List<Object> seq = new ArrayList<>();\n \n                 for (Node sequence : asIterable(child.getChildNodes())) {\n                     if (XMP.NS_RDF.equals(sequence.getNamespaceURI()) && \"li\".equals(sequence.getLocalName())) {",
    "function_modified_lines": {
      "added": [
        "            DocumentBuilderFactory factory = createDocumentBuilderFactory();\n",
        "\n",
        "            throw new RuntimeException(e);\n",
        "    private DocumentBuilderFactory createDocumentBuilderFactory() throws ParserConfigurationException {\n",
        "        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n",
        "        factory.setNamespaceAware(true);\n",
        "\n",
        "        // Security: Disable XInclude & expanding entity references (\"bombs\"), not needed for XMP\n",
        "        factory.setXIncludeAware(false);\n",
        "        factory.setExpandEntityReferences(false);\n",
        "\n",
        "        // Security: Enable \"secure processing\", to prevent DoS attacks\n",
        "        factory.setAttribute(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n",
        "\n",
        "        // Security: Remove possibility to access external DTDs or Schema, not needed for XMP\n",
        "        factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, \"\");\n",
        "        factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_SCHEMA, \"\");\n",
        "\n",
        "        // Security: Disable loading of external DTD and entities, not needed for XMP\n",
        "        factory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n",
        "        factory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n",
        "        factory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n",
        "\n",
        "        return factory;\n",
        "    }\n",
        "\n"
      ],
      "deleted": [
        "        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n",
        "        factory.setNamespaceAware(true);\n",
        "\n",
        "//            XMLSerializer serializer = new XMLSerializer(System.err, System.getProperty(\"file.encoding\"));\n",
        "//            serializer.serialize(document);\n",
        "\n",
        "            throw new RuntimeException(e); // TODO: Or IOException?\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "The package com.twelvemonkeys.imageio:imageio-metadata before 3.7.1 are vulnerable to XML External Entity (XXE) Injection due to an insecurely initialized XML parser for reading XMP Metadata. An attacker can exploit this vulnerability if they are able to supply a file (e.g. when an online profile picture is processed) with a malicious XMP segment. If the XMP metadata of the uploaded image is parsed, then the XXE vulnerability is triggered.",
    "id": 12212
  },
  {
    "cve_id": "CVE-2021-23792",
    "code_before_change": "{\n                if (node.getNodeType() != Node.ELEMENT_NODE) {\n                    continue;\n                }\n\n                // Lookup\n                List<Entry> dir = subdirs.get(node.getNamespaceURI());\n                if (dir == null) {\n                    dir = new ArrayList<Entry>();\n                    subdirs.put(node.getNamespaceURI(), dir);\n                }\n\n                Object value;\n\n                if (isResourceType(node)) {\n                    value = parseAsResource(node);\n                }\n                else {\n                    // TODO: This method contains loads of duplication an should be cleaned up...\n                    // Support attribute short-hand syntax\n                    Map<String, List<Entry>> subsubdirs = new LinkedHashMap<String, List<Entry>>();\n\n                    parseAttributesForKnownElements(subsubdirs, node);\n\n                    if (!subsubdirs.isEmpty()) {\n                        List<Entry> entries = new ArrayList<>(subsubdirs.size());\n\n                        for (Map.Entry<String, List<Entry>> entry : subsubdirs.entrySet()) {\n                            entries.addAll(entry.getValue());\n                        }\n\n                        value = new RDFDescription(entries);\n                    }\n                    else {\n                        value = getChildTextValue(node);\n                    }\n                }\n\n                dir.add(new XMPEntry(node.getNamespaceURI() + node.getLocalName(), node.getLocalName(), value));\n            }",
    "code_after_change": "{\n                if (node.getNodeType() != Node.ELEMENT_NODE) {\n                    continue;\n                }\n\n                // Lookup\n                List<Entry> dir = subdirs.get(node.getNamespaceURI());\n                if (dir == null) {\n                    dir = new ArrayList<>();\n                    subdirs.put(node.getNamespaceURI(), dir);\n                }\n\n                Object value;\n\n                if (isResourceType(node)) {\n                    value = parseAsResource(node);\n                }\n                else {\n                    // TODO: This method contains loads of duplication an should be cleaned up...\n                    // Support attribute short-hand syntax\n                    Map<String, List<Entry>> subsubdirs = new LinkedHashMap<>();\n\n                    parseAttributesForKnownElements(subsubdirs, node);\n\n                    if (!subsubdirs.isEmpty()) {\n                        List<Entry> entries = new ArrayList<>(subsubdirs.size());\n\n                        for (Map.Entry<String, List<Entry>> entry : subsubdirs.entrySet()) {\n                            entries.addAll(entry.getValue());\n                        }\n\n                        value = new RDFDescription(entries);\n                    }\n                    else {\n                        value = getChildTextValue(node);\n                    }\n                }\n\n                dir.add(new XMPEntry(node.getNamespaceURI() + node.getLocalName(), node.getLocalName(), value));\n            }",
    "patch": "@@ -30,11 +30,21 @@\n \n package com.twelvemonkeys.imageio.metadata.xmp;\n \n-import com.twelvemonkeys.imageio.metadata.Directory;\n-import com.twelvemonkeys.imageio.metadata.Entry;\n-import com.twelvemonkeys.imageio.metadata.MetadataReader;\n-import com.twelvemonkeys.imageio.util.IIOUtil;\n-import com.twelvemonkeys.lang.Validate;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.imageio.IIOException;\n+import javax.imageio.stream.ImageInputStream;\n+import javax.xml.XMLConstants;\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.parsers.ParserConfigurationException;\n+\n import org.w3c.dom.Document;\n import org.w3c.dom.NamedNodeMap;\n import org.w3c.dom.Node;\n@@ -43,13 +53,11 @@\n import org.xml.sax.SAXException;\n import org.xml.sax.helpers.DefaultHandler;\n \n-import javax.imageio.IIOException;\n-import javax.imageio.stream.ImageInputStream;\n-import javax.xml.parsers.DocumentBuilder;\n-import javax.xml.parsers.DocumentBuilderFactory;\n-import javax.xml.parsers.ParserConfigurationException;\n-import java.io.IOException;\n-import java.util.*;\n+import com.twelvemonkeys.imageio.metadata.Directory;\n+import com.twelvemonkeys.imageio.metadata.Entry;\n+import com.twelvemonkeys.imageio.metadata.MetadataReader;\n+import com.twelvemonkeys.imageio.util.IIOUtil;\n+import com.twelvemonkeys.lang.Validate;\n \n /**\n  * XMPReader\n@@ -67,10 +75,9 @@ public final class XMPReader extends MetadataReader {\n     public Directory read(final ImageInputStream input) throws IOException {\n         Validate.notNull(input, \"input\");\n \n-        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n-        factory.setNamespaceAware(true);\n-\n         try {\n+            DocumentBuilderFactory factory = createDocumentBuilderFactory();\n+\n             // TODO: Consider parsing using SAX?\n             // TODO: Determine encoding and parse using a Reader...\n             // TODO: Refactor scanner to return inputstream?\n@@ -79,9 +86,6 @@ public Directory read(final ImageInputStream input) throws IOException {\n             builder.setErrorHandler(new DefaultHandler());\n             Document document = builder.parse(new InputSource(IIOUtil.createStreamAdapter(input)));\n \n-//            XMLSerializer serializer = new XMLSerializer(System.err, System.getProperty(\"file.encoding\"));\n-//            serializer.serialize(document);\n-\n             String toolkit = getToolkit(document);\n             Node rdfRoot = document.getElementsByTagNameNS(XMP.NS_RDF, \"RDF\").item(0);\n             NodeList descriptions = document.getElementsByTagNameNS(XMP.NS_RDF, \"Description\");\n@@ -92,10 +96,33 @@ public Directory read(final ImageInputStream input) throws IOException {\n             throw new IIOException(e.getMessage(), e);\n         }\n         catch (ParserConfigurationException e) {\n-            throw new RuntimeException(e); // TODO: Or IOException?\n+            throw new RuntimeException(e);\n         }\n     }\n \n+    private DocumentBuilderFactory createDocumentBuilderFactory() throws ParserConfigurationException {\n+        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n+        factory.setNamespaceAware(true);\n+\n+        // Security: Disable XInclude & expanding entity references (\"bombs\"), not needed for XMP\n+        factory.setXIncludeAware(false);\n+        factory.setExpandEntityReferences(false);\n+\n+        // Security: Enable \"secure processing\", to prevent DoS attacks\n+        factory.setAttribute(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n+\n+        // Security: Remove possibility to access external DTDs or Schema, not needed for XMP\n+        factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, \"\");\n+        factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_SCHEMA, \"\");\n+\n+        // Security: Disable loading of external DTD and entities, not needed for XMP\n+        factory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n+        factory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n+        factory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n+\n+        return factory;\n+    }\n+\n     private String getToolkit(Document document) {\n         NodeList xmpmeta = document.getElementsByTagNameNS(XMP.NS_X, \"xmpmeta\");\n \n@@ -109,7 +136,7 @@ private String getToolkit(Document document) {\n     }\n \n     private XMPDirectory parseDirectories(final Node pParentNode, NodeList pNodes, String toolkit) {\n-        Map<String, List<Entry>> subdirs = new LinkedHashMap<String, List<Entry>>();\n+        Map<String, List<Entry>> subdirs = new LinkedHashMap<>();\n \n         for (Node desc : asIterable(pNodes)) {\n             if (desc.getParentNode() != pParentNode) {\n@@ -127,7 +154,7 @@ private XMPDirectory parseDirectories(final Node pParentNode, NodeList pNodes, S\n                 // Lookup\n                 List<Entry> dir = subdirs.get(node.getNamespaceURI());\n                 if (dir == null) {\n-                    dir = new ArrayList<Entry>();\n+                    dir = new ArrayList<>();\n                     subdirs.put(node.getNamespaceURI(), dir);\n                 }\n \n@@ -139,7 +166,7 @@ private XMPDirectory parseDirectories(final Node pParentNode, NodeList pNodes, S\n                 else {\n                     // TODO: This method contains loads of duplication an should be cleaned up...\n                     // Support attribute short-hand syntax\n-                    Map<String, List<Entry>> subsubdirs = new LinkedHashMap<String, List<Entry>>();\n+                    Map<String, List<Entry>> subsubdirs = new LinkedHashMap<>();\n \n                     parseAttributesForKnownElements(subsubdirs, node);\n \n@@ -161,7 +188,7 @@ private XMPDirectory parseDirectories(final Node pParentNode, NodeList pNodes, S\n             }\n         }\n \n-        List<Directory> entries = new ArrayList<Directory>(subdirs.size());\n+        List<Directory> entries = new ArrayList<>(subdirs.size());\n \n         // TODO: Should we still allow asking for a subdirectory by item id?\n         for (Map.Entry<String, List<Entry>> entry : subdirs.entrySet()) {\n@@ -179,7 +206,7 @@ private boolean isResourceType(Node node) {\n \n     private RDFDescription parseAsResource(Node node) {\n         // See: http://www.w3.org/TR/REC-rdf-syntax/#section-Syntax-parsetype-resource\n-        List<Entry> entries = new ArrayList<Entry>();\n+        List<Entry> entries = new ArrayList<>();\n \n         for (Node child : asIterable(node.getChildNodes())) {\n             if (child.getNodeType() != Node.ELEMENT_NODE) {\n@@ -204,7 +231,7 @@ private void parseAttributesForKnownElements(Map<String, List<Entry>> subdirs, N\n             List<Entry> dir = subdirs.get(attr.getNamespaceURI());\n \n             if (dir == null) {\n-                dir = new ArrayList<Entry>();\n+                dir = new ArrayList<>();\n                 subdirs.put(attr.getNamespaceURI(), dir);\n             }\n \n@@ -216,7 +243,7 @@ private Object getChildTextValue(final Node node) {\n         for (Node child : asIterable(node.getChildNodes())) {\n             if (XMP.NS_RDF.equals(child.getNamespaceURI()) && \"Alt\".equals(child.getLocalName())) {\n                 // Support for <rdf:Alt><rdf:li> -> return a Map<String, Object> keyed on xml:lang\n-                Map<String, Object> alternatives = new LinkedHashMap<String, Object>();\n+                Map<String, Object> alternatives = new LinkedHashMap<>();\n                 for (Node alternative : asIterable(child.getChildNodes())) {\n                     if (XMP.NS_RDF.equals(alternative.getNamespaceURI()) && \"li\".equals(alternative.getLocalName())) {\n                         NamedNodeMap attributes = alternative.getAttributes();\n@@ -230,7 +257,7 @@ private Object getChildTextValue(final Node node) {\n             else if (XMP.NS_RDF.equals(child.getNamespaceURI()) && (\"Seq\".equals(child.getLocalName()) || \"Bag\".equals(child.getLocalName()))) {\n                 // Support for <rdf:Seq><rdf:li> -> return array\n                 // Support for <rdf:Bag><rdf:li> -> return array/unordered collection (how can a serialized collection not have order?)\n-                List<Object> seq = new ArrayList<Object>();\n+                List<Object> seq = new ArrayList<>();\n \n                 for (Node sequence : asIterable(child.getChildNodes())) {\n                     if (XMP.NS_RDF.equals(sequence.getNamespaceURI()) && \"li\".equals(sequence.getLocalName())) {",
    "function_modified_lines": {
      "added": [
        "                    dir = new ArrayList<>();\n",
        "                    Map<String, List<Entry>> subsubdirs = new LinkedHashMap<>();\n"
      ],
      "deleted": [
        "                    dir = new ArrayList<Entry>();\n",
        "                    Map<String, List<Entry>> subsubdirs = new LinkedHashMap<String, List<Entry>>();\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "The package com.twelvemonkeys.imageio:imageio-metadata before 3.7.1 are vulnerable to XML External Entity (XXE) Injection due to an insecurely initialized XML parser for reading XMP Metadata. An attacker can exploit this vulnerability if they are able to supply a file (e.g. when an online profile picture is processed) with a malicious XMP segment. If the XMP metadata of the uploaded image is parsed, then the XXE vulnerability is triggered.",
    "id": 12213
  },
  {
    "cve_id": "CVE-2021-23899",
    "code_before_change": "{\n        String sanitized0 = JsonSanitizer.sanitize(fuzzyWuzzyString);\n        String sanitized1 = JsonSanitizer.sanitize(sanitized0);\n        // Test idempotence.\n        assertEquals(fuzzyWuzzyString + \"  =>  \" + sanitized0, sanitized0,\n                     sanitized1);\n      }",
    "code_after_change": "{\n        String sanitized0 = JsonSanitizer.sanitize(fuzzyWuzzyString);\n        String sanitized1 = JsonSanitizer.sanitize(sanitized0);\n        // Test idempotence.\n        if (!sanitized0.equals(sanitized1)) {\n          int commonPrefixLen = 0;\n          int minLength = Math.min(sanitized0.length(), sanitized1.length());\n          while (commonPrefixLen < minLength) {\n            if (sanitized0.charAt(commonPrefixLen) != sanitized1.charAt(commonPrefixLen)) {\n              break;\n            }\n            ++commonPrefixLen;\n          }\n\n          int right0 = sanitized0.length();\n          int right1 = sanitized1.length();\n          while (right0 > commonPrefixLen && right1 > commonPrefixLen) {\n            if (sanitized0.charAt(right0 - 1) != sanitized1.charAt(right1 - 1)) {\n              break;\n            }\n            --right0;\n            --right1;\n          }\n\n          int commonSuffixLen = sanitized0.length() - right0;\n\n          System.err.println(\"Difference at \" + commonPrefixLen + \" to -\" + commonSuffixLen);\n          System.err.println(\"Before: \" + excerpt(sanitized0, commonPrefixLen, right0));\n          System.err.println(\"After:  \" + excerpt(sanitized0, commonPrefixLen, right1));\n        }\n        assertEquals(fuzzyWuzzyString + \"  =>  \" + sanitized0, sanitized0,\n                     sanitized1);\n      }",
    "patch": "@@ -62,6 +62,32 @@ public static final void testSanitizerLikesFuzzyWuzzyInputs()\n         String sanitized0 = JsonSanitizer.sanitize(fuzzyWuzzyString);\n         String sanitized1 = JsonSanitizer.sanitize(sanitized0);\n         // Test idempotence.\n+        if (!sanitized0.equals(sanitized1)) {\n+          int commonPrefixLen = 0;\n+          int minLength = Math.min(sanitized0.length(), sanitized1.length());\n+          while (commonPrefixLen < minLength) {\n+            if (sanitized0.charAt(commonPrefixLen) != sanitized1.charAt(commonPrefixLen)) {\n+              break;\n+            }\n+            ++commonPrefixLen;\n+          }\n+\n+          int right0 = sanitized0.length();\n+          int right1 = sanitized1.length();\n+          while (right0 > commonPrefixLen && right1 > commonPrefixLen) {\n+            if (sanitized0.charAt(right0 - 1) != sanitized1.charAt(right1 - 1)) {\n+              break;\n+            }\n+            --right0;\n+            --right1;\n+          }\n+\n+          int commonSuffixLen = sanitized0.length() - right0;\n+\n+          System.err.println(\"Difference at \" + commonPrefixLen + \" to -\" + commonSuffixLen);\n+          System.err.println(\"Before: \" + excerpt(sanitized0, commonPrefixLen, right0));\n+          System.err.println(\"After:  \" + excerpt(sanitized0, commonPrefixLen, right1));\n+        }\n         assertEquals(fuzzyWuzzyString + \"  =>  \" + sanitized0, sanitized0,\n                      sanitized1);\n       } catch (Throwable th) {\n@@ -90,6 +116,23 @@ private static void hexDump(byte[] bytes, Appendable app)\n       app.append(\"0123456789ABCDEF\".charAt((b >>> 0) & 0xf));\n     }\n   }\n+\n+  private static String excerpt(String s, int left, int right) {\n+    int leftIncl = left - 10;\n+    boolean ellipseLeft = leftIncl > 0;\n+    if (!ellipseLeft) { leftIncl = 0; }\n+\n+    int rightIncl = right + 10;\n+    boolean ellipseRight = s.length() > rightIncl;\n+    if (!ellipseRight) {\n+      rightIncl = s.length();\n+    }\n+\n+    return s.substring(leftIncl, rightIncl)\n+            .replace(\"\\r\", \"\\\\r\")\n+            .replace(\"\\n\", \"\\\\n\")\n+            .replace(\"\\\\\", \"\\\\\\\\\");\n+  }\n }\n \n final class FuzzyStringGenerator implements Iterable<String> {",
    "function_modified_lines": {
      "added": [
        "        if (!sanitized0.equals(sanitized1)) {\n",
        "          int commonPrefixLen = 0;\n",
        "          int minLength = Math.min(sanitized0.length(), sanitized1.length());\n",
        "          while (commonPrefixLen < minLength) {\n",
        "            if (sanitized0.charAt(commonPrefixLen) != sanitized1.charAt(commonPrefixLen)) {\n",
        "              break;\n",
        "            }\n",
        "            ++commonPrefixLen;\n",
        "          }\n",
        "\n",
        "          int right0 = sanitized0.length();\n",
        "          int right1 = sanitized1.length();\n",
        "          while (right0 > commonPrefixLen && right1 > commonPrefixLen) {\n",
        "            if (sanitized0.charAt(right0 - 1) != sanitized1.charAt(right1 - 1)) {\n",
        "              break;\n",
        "            }\n",
        "            --right0;\n",
        "            --right1;\n",
        "          }\n",
        "\n",
        "          int commonSuffixLen = sanitized0.length() - right0;\n",
        "\n",
        "          System.err.println(\"Difference at \" + commonPrefixLen + \" to -\" + commonSuffixLen);\n",
        "          System.err.println(\"Before: \" + excerpt(sanitized0, commonPrefixLen, right0));\n",
        "          System.err.println(\"After:  \" + excerpt(sanitized0, commonPrefixLen, right1));\n",
        "        }\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "OWASP json-sanitizer before 1.2.2 may emit closing SCRIPT tags and CDATA section delimiters for crafted input. This allows an attacker to inject arbitrary HTML or XML into embedding documents.",
    "id": 12215
  },
  {
    "cve_id": "CVE-2021-27736",
    "code_before_change": "      return Base64.getEncoder().encodeToString(xml.getBytes(StandardCharsets.UTF_8));\n    } catch (Exception e) {\n      throw new SAMLException(\"Unable to sign XML SAML response\", e);\n    }\n  }\n\n  private String buildRedirectAuthnRequest(AuthnRequestType authnRequest, String relayState, boolean sign,\n                                           PrivateKey key, Algorithm algorithm) throws SAMLException {\n    try {\n      byte[] xml = marshallToBytes(PROTOCOL_OBJECT_FACTORY.createAuthnRequest(authnRequest), AuthnRequestType.class);\n      String encodedResult = deflateAndEncode(xml);\n      String parameters = \"SAMLRequest=\" + URLEncoder.encode(encodedResult, \"UTF-8\");\n      if (relayState != null) {\n        parameters += \"&RelayState=\" + URLEncoder.encode(relayState, \"UTF-8\");\n      }\n\n      if (sign && key != null && algorithm != null) {\n        Signature signature;\n        parameters += \"&SigAlg=\" + URLEncoder.encode(algorithm.uri, \"UTF-8\");\n        signature = Signature.getInstance(algorithm.name);\n        signature.initSign(key);\n        signature.update(parameters.getBytes(StandardCharsets.UTF_8));\n\n        String signatureParameter = Base64.getEncoder().encodeToString(signature.sign());\n        parameters += \"&Signature=\" + URLEncoder.encode(signatureParameter, \"UTF-8\");\n      }\n\n      return parameters;\n    } catch (Exception e) {\n      // Not possible but freak out\n      throw new SAMLException(e);\n    }\n  }\n\n  private ZonedDateTime convertToZonedDateTime(XMLGregorianCalendar cal) {\n    return cal != null ? cal.toGregorianCalendar().toZonedDateTime() : null;\n  }\n\n  private byte[] decodeAndInflate(String encodedRequest) throws SAMLException {\n    byte[] bytes = Base64.getMimeDecoder().decode(encodedRequest);\n    Inflater inflater = new Inflater(true);\n    inflater.setInput(bytes);\n    inflater.finished();\n\n    try {\n      ByteArrayOutputStream baos = new ByteArrayOutputStream();\n      byte[] result = new byte[bytes.length];\n      while (!inflater.finished()) {\n        int length = inflater.inflate(result);\n        if (length > 0) {\n          baos.write(result, 0, length);\n        }\n      }\n\n      return baos.toByteArray();\n    } catch (DataFormatException e) {\n      throw new SAMLException(\"Invalid AuthnRequest. Inflating the bytes failed.\", e);\n    }\n  }\n\n  private String deflateAndEncode(byte[] result) {\n    Deflater deflater = new Deflater(Deflater.DEFLATED, true);\n    deflater.setInput(result);\n    deflater.finish();\n    byte[] deflatedResult = new byte[result.length];\n    int length = deflater.deflate(deflatedResult);\n    deflater.end();\n    byte[] src = Arrays.copyOf(deflatedResult, length);\n    return Base64.getEncoder().encodeToString(src);\n  }\n\n  private void fixIDs(Element element) {\n    NamedNodeMap attributes = element.getAttributes();\n    for (int i = 0; i < attributes.getLength(); i++) {\n      Attr attribute = (Attr) attributes.item(i);\n      if (attribute.getLocalName().equalsIgnoreCase(\"id\")) {\n        element.setIdAttributeNode(attribute, true);\n      }\n    }\n\n    NodeList children = element.getChildNodes();\n    for (int i = 0; i < children.getLength(); i++) {\n      Node child = children.item(i);\n      if (child.getNodeType() == Node.ELEMENT_NODE) {\n        fixIDs((Element) child);\n      }\n    }\n  }\n\n  private <T> byte[] marshallToBytes(JAXBElement<T> object, Class<T> type) throws SAMLException {\n    try {\n      JAXBContext context = JAXBContext.newInstance(type);\n      Marshaller marshaller = context.createMarshaller();\n      ByteArrayOutputStream baos = new ByteArrayOutputStream();\n      marshaller.marshal(object, baos);\n      return baos.toByteArray();\n    } catch (JAXBException e) {\n      throw new SAMLException(\"Unable to marshallRequest JAXB SAML object to bytes.\", e);\n    }\n  }\n\n  @SuppressWarnings(\"SameParameterValue\")\n  private <T> Document marshallToDocument(JAXBElement<T> object, Class<T> type) throws SAMLException {\n    try {\n      JAXBContext context = JAXBContext.newInstance(type);\n      Marshaller marshaller = context.createMarshaller();\n      DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();",
    "code_after_change": "      }\n\n      return Base64.getEncoder().encodeToString(xml.getBytes(StandardCharsets.UTF_8));\n    } catch (Exception e) {\n      throw new SAMLException(\"Unable to sign XML SAML response\", e);\n    }\n  }\n\n  private String buildRedirectAuthnRequest(AuthnRequestType authnRequest, String relayState, boolean sign,\n                                           PrivateKey key, Algorithm algorithm) throws SAMLException {\n    try {\n      byte[] xml = marshallToBytes(PROTOCOL_OBJECT_FACTORY.createAuthnRequest(authnRequest), AuthnRequestType.class);\n      String encodedResult = SAMLTools.deflateAndEncode(xml);\n      String parameters = \"SAMLRequest=\" + URLEncoder.encode(encodedResult, \"UTF-8\");\n      if (relayState != null) {\n        parameters += \"&RelayState=\" + URLEncoder.encode(relayState, \"UTF-8\");\n      }\n\n      if (sign && key != null && algorithm != null) {\n        Signature signature;\n        parameters += \"&SigAlg=\" + URLEncoder.encode(algorithm.uri, \"UTF-8\");\n        signature = Signature.getInstance(algorithm.name);\n        signature.initSign(key);\n        signature.update(parameters.getBytes(StandardCharsets.UTF_8));\n\n        String signatureParameter = Base64.getEncoder().encodeToString(signature.sign());\n        parameters += \"&Signature=\" + URLEncoder.encode(signatureParameter, \"UTF-8\");\n      }\n\n      return parameters;\n    } catch (Exception e) {\n      // Not possible but freak out\n      throw new SAMLException(e);\n    }\n  }\n\n  private void fixIDs(Element element) {\n    NamedNodeMap attributes = element.getAttributes();\n    for (int i = 0; i < attributes.getLength(); i++) {\n      Attr attribute = (Attr) attributes.item(i);\n      if (attribute.getLocalName().equalsIgnoreCase(\"id\")) {\n        element.setIdAttributeNode(attribute, true);\n      }\n    }\n\n    NodeList children = element.getChildNodes();\n    for (int i = 0; i < children.getLength(); i++) {\n      Node child = children.item(i);\n      if (child.getNodeType() == Node.ELEMENT_NODE) {\n        fixIDs((Element) child);\n      }\n    }\n  }\n\n  private SubjectConfirmation parseConfirmation(SubjectConfirmationType subjectConfirmationType) {\n    SubjectConfirmation subjectConfirmation = new SubjectConfirmation();\n    SubjectConfirmationDataType data = subjectConfirmationType.getSubjectConfirmationData();\n    if (data != null) {\n      subjectConfirmation.address = data.getAddress();\n      subjectConfirmation.inResponseTo = data.getInResponseTo();\n      subjectConfirmation.notBefore = toZonedDateTime(data.getNotBefore());\n      subjectConfirmation.notOnOrAfter = toZonedDateTime(data.getNotOnOrAfter());\n      subjectConfirmation.recipient = data.getRecipient();\n    }\n\n    subjectConfirmation.method = ConfirmationMethod.fromSAMLFormat(subjectConfirmationType.getMethod());\n\n    return subjectConfirmation;\n  }\n\n  private AuthnRequestParseResult parseRequest(byte[] xmlBytes) throws SAMLException {\n    String xml = new String(xmlBytes, StandardCharsets.UTF_8);\n    if (logger.isDebugEnabled()) {\n      logger.debug(\"SAMLRequest XML is\\n{}\", xml);",
    "patch": "@@ -15,11 +15,7 @@\n  */\n package io.fusionauth.samlv2.service;\n \n-import javax.xml.bind.JAXBContext;\n import javax.xml.bind.JAXBElement;\n-import javax.xml.bind.JAXBException;\n-import javax.xml.bind.Marshaller;\n-import javax.xml.bind.Unmarshaller;\n import javax.xml.crypto.KeySelector;\n import javax.xml.crypto.MarshalException;\n import javax.xml.crypto.dsig.CanonicalizationMethod;\n@@ -37,19 +33,7 @@\n import javax.xml.crypto.dsig.keyinfo.X509Data;\n import javax.xml.crypto.dsig.spec.C14NMethodParameterSpec;\n import javax.xml.crypto.dsig.spec.TransformParameterSpec;\n-import javax.xml.datatype.XMLGregorianCalendar;\n-import javax.xml.parsers.DocumentBuilder;\n-import javax.xml.parsers.DocumentBuilderFactory;\n-import javax.xml.parsers.ParserConfigurationException;\n-import javax.xml.transform.Transformer;\n import javax.xml.transform.TransformerException;\n-import javax.xml.transform.TransformerFactory;\n-import javax.xml.transform.dom.DOMSource;\n-import javax.xml.transform.stream.StreamResult;\n-import java.io.ByteArrayInputStream;\n-import java.io.ByteArrayOutputStream;\n-import java.io.IOException;\n-import java.io.StringWriter;\n import java.io.UnsupportedEncodingException;\n import java.net.URLEncoder;\n import java.nio.charset.StandardCharsets;\n@@ -59,8 +43,6 @@\n import java.security.PrivateKey;\n import java.security.Signature;\n import java.security.cert.Certificate;\n-import java.security.cert.CertificateException;\n-import java.security.cert.CertificateFactory;\n import java.security.cert.X509Certificate;\n import java.time.ZoneOffset;\n import java.time.ZonedDateTime;\n@@ -75,9 +57,6 @@\n import java.util.UUID;\n import java.util.function.Function;\n import java.util.stream.Collectors;\n-import java.util.zip.DataFormatException;\n-import java.util.zip.Deflater;\n-import java.util.zip.Inflater;\n \n import com.sun.org.apache.xerces.internal.jaxp.datatype.XMLGregorianCalendarImpl;\n import io.fusionauth.samlv2.domain.Algorithm;\n@@ -89,7 +68,6 @@\n import io.fusionauth.samlv2.domain.MetaData;\n import io.fusionauth.samlv2.domain.MetaData.IDPMetaData;\n import io.fusionauth.samlv2.domain.MetaData.SPMetaData;\n-import io.fusionauth.samlv2.domain.NameID;\n import io.fusionauth.samlv2.domain.NameIDFormat;\n import io.fusionauth.samlv2.domain.ResponseStatus;\n import io.fusionauth.samlv2.domain.SAMLException;\n@@ -128,6 +106,7 @@\n import io.fusionauth.samlv2.domain.jaxb.oasis.protocol.StatusType;\n import io.fusionauth.samlv2.domain.jaxb.w3c.xmldsig.KeyInfoType;\n import io.fusionauth.samlv2.domain.jaxb.w3c.xmldsig.X509DataType;\n+import io.fusionauth.samlv2.util.SAMLTools;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.w3c.dom.Attr;\n@@ -136,7 +115,16 @@\n import org.w3c.dom.NamedNodeMap;\n import org.w3c.dom.Node;\n import org.w3c.dom.NodeList;\n-import org.xml.sax.SAXException;\n+import static io.fusionauth.samlv2.util.SAMLTools.convertToZonedDateTime;\n+import static io.fusionauth.samlv2.util.SAMLTools.decodeAndInflate;\n+import static io.fusionauth.samlv2.util.SAMLTools.marshallToBytes;\n+import static io.fusionauth.samlv2.util.SAMLTools.marshallToDocument;\n+import static io.fusionauth.samlv2.util.SAMLTools.marshallToString;\n+import static io.fusionauth.samlv2.util.SAMLTools.newDocumentFromBytes;\n+import static io.fusionauth.samlv2.util.SAMLTools.parseNameId;\n+import static io.fusionauth.samlv2.util.SAMLTools.toXMLGregorianCalendar;\n+import static io.fusionauth.samlv2.util.SAMLTools.toZonedDateTime;\n+import static io.fusionauth.samlv2.util.SAMLTools.unmarshallFromDocument;\n \n /**\n  * Default implementation of the SAML service.\n@@ -411,7 +399,7 @@ public String buildRedirectAuthnRequest(AuthenticationRequest request, String re\n \n   @Override\n   public MetaData parseMetaData(String metaDataXML) throws SAMLException {\n-    Document document = parseFromBytes(metaDataXML.getBytes(StandardCharsets.UTF_8));\n+    Document document = newDocumentFromBytes(metaDataXML.getBytes(StandardCharsets.UTF_8));\n     EntityDescriptorType root = unmarshallFromDocument(document, EntityDescriptorType.class);\n     MetaData metaData = new MetaData();\n     metaData.id = root.getID();\n@@ -450,7 +438,7 @@ public MetaData parseMetaData(String metaDataXML) throws SAMLException {\n         metaData.idp.certificates = idp.getKeyDescriptor()\n                                        .stream()\n                                        .filter(kd -> kd.getUse() == KeyTypes.SIGNING)\n-                                       .map(this::toCertificate)\n+                                       .map(SAMLTools::toCertificate)\n                                        .filter(Objects::nonNull)\n                                        .collect(Collectors.toList());\n       } catch (IllegalArgumentException e) {\n@@ -532,7 +520,7 @@ public AuthenticationResponse parseResponse(String encodedResponse, boolean veri\n     byte[] decodedResponse = Base64.getMimeDecoder().decode(encodedResponse);\n     response.rawResponse = new String(decodedResponse, StandardCharsets.UTF_8);\n \n-    Document document = parseFromBytes(decodedResponse);\n+    Document document = newDocumentFromBytes(decodedResponse);\n     if (verifySignature) {\n       verifySignature(document, keySelector);\n     }\n@@ -613,7 +601,7 @@ public AuthenticationResponse parseResponse(String encodedResponse, boolean veri\n               AttributeType attributeType = (AttributeType) attributeObject;\n               String name = attributeType.getName();\n               List<Object> attributeValues = attributeType.getAttributeValue();\n-              List<String> values = attributeValues.stream().map(this::attributeToString).collect(Collectors.toList());\n+              List<String> values = attributeValues.stream().map(SAMLTools::attributeToString).collect(Collectors.toList());\n               response.assertion.attributes.computeIfAbsent(name, k -> new ArrayList<>()).addAll(values);\n             } else {\n               throw new SAMLException(\"This library currently doesn't support encrypted attributes\");\n@@ -646,24 +634,6 @@ private void addKeyDescriptors(SSODescriptorType descriptor, List<Certificate> c\n     });\n   }\n \n-  private String attributeToString(Object attribute) {\n-    if (attribute == null) {\n-      return null;\n-    }\n-\n-    if (attribute instanceof Number) {\n-      return attribute.toString();\n-    } else if (attribute instanceof String) {\n-      return (String) attribute;\n-    } else if (attribute instanceof Element) {\n-      return ((Element) attribute).getTextContent();\n-    } else {\n-      logger.warn(\"This library currently doesn't handle attributes of type [\" + attribute.getClass() + \"]\");\n-    }\n-\n-    return null;\n-  }\n-\n   private String buildPostAuthnRequest(AuthnRequestType authnRequest, boolean sign, PrivateKey privateKey,\n                                        X509Certificate certificate,\n                                        Algorithm algorithm, String xmlSignatureC14nMethod) throws SAMLException {\n@@ -687,7 +657,7 @@ private String buildRedirectAuthnRequest(AuthnRequestType authnRequest, String r\n                                            PrivateKey key, Algorithm algorithm) throws SAMLException {\n     try {\n       byte[] xml = marshallToBytes(PROTOCOL_OBJECT_FACTORY.createAuthnRequest(authnRequest), AuthnRequestType.class);\n-      String encodedResult = deflateAndEncode(xml);\n+      String encodedResult = SAMLTools.deflateAndEncode(xml);\n       String parameters = \"SAMLRequest=\" + URLEncoder.encode(encodedResult, \"UTF-8\");\n       if (relayState != null) {\n         parameters += \"&RelayState=\" + URLEncoder.encode(relayState, \"UTF-8\");\n@@ -711,43 +681,6 @@ private String buildRedirectAuthnRequest(AuthnRequestType authnRequest, String r\n     }\n   }\n \n-  private ZonedDateTime convertToZonedDateTime(XMLGregorianCalendar cal) {\n-    return cal != null ? cal.toGregorianCalendar().toZonedDateTime() : null;\n-  }\n-\n-  private byte[] decodeAndInflate(String encodedRequest) throws SAMLException {\n-    byte[] bytes = Base64.getMimeDecoder().decode(encodedRequest);\n-    Inflater inflater = new Inflater(true);\n-    inflater.setInput(bytes);\n-    inflater.finished();\n-\n-    try {\n-      ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-      byte[] result = new byte[bytes.length];\n-      while (!inflater.finished()) {\n-        int length = inflater.inflate(result);\n-        if (length > 0) {\n-          baos.write(result, 0, length);\n-        }\n-      }\n-\n-      return baos.toByteArray();\n-    } catch (DataFormatException e) {\n-      throw new SAMLException(\"Invalid AuthnRequest. Inflating the bytes failed.\", e);\n-    }\n-  }\n-\n-  private String deflateAndEncode(byte[] result) {\n-    Deflater deflater = new Deflater(Deflater.DEFLATED, true);\n-    deflater.setInput(result);\n-    deflater.finish();\n-    byte[] deflatedResult = new byte[result.length];\n-    int length = deflater.deflate(deflatedResult);\n-    deflater.end();\n-    byte[] src = Arrays.copyOf(deflatedResult, length);\n-    return Base64.getEncoder().encodeToString(src);\n-  }\n-\n   private void fixIDs(Element element) {\n     NamedNodeMap attributes = element.getAttributes();\n     for (int i = 0; i < attributes.getLength(); i++) {\n@@ -766,42 +699,6 @@ private void fixIDs(Element element) {\n     }\n   }\n \n-  private <T> byte[] marshallToBytes(JAXBElement<T> object, Class<T> type) throws SAMLException {\n-    try {\n-      JAXBContext context = JAXBContext.newInstance(type);\n-      Marshaller marshaller = context.createMarshaller();\n-      ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-      marshaller.marshal(object, baos);\n-      return baos.toByteArray();\n-    } catch (JAXBException e) {\n-      throw new SAMLException(\"Unable to marshallRequest JAXB SAML object to bytes.\", e);\n-    }\n-  }\n-\n-  @SuppressWarnings(\"SameParameterValue\")\n-  private <T> Document marshallToDocument(JAXBElement<T> object, Class<T> type) throws SAMLException {\n-    try {\n-      JAXBContext context = JAXBContext.newInstance(type);\n-      Marshaller marshaller = context.createMarshaller();\n-      DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n-      dbf.setNamespaceAware(true);\n-      DocumentBuilder db = dbf.newDocumentBuilder();\n-      Document document = db.newDocument();\n-      marshaller.marshal(object, document);\n-      return document;\n-    } catch (JAXBException | ParserConfigurationException e) {\n-      throw new SAMLException(\"Unable to marshallRequest JAXB SAML object to DOM.\", e);\n-    }\n-  }\n-\n-  private String marshallToString(Document document) throws TransformerException {\n-    StringWriter sw = new StringWriter();\n-    TransformerFactory tf = TransformerFactory.newInstance();\n-    Transformer transformer = tf.newTransformer();\n-    transformer.transform(new DOMSource(document), new StreamResult(sw));\n-    return sw.toString();\n-  }\n-\n   private SubjectConfirmation parseConfirmation(SubjectConfirmationType subjectConfirmationType) {\n     SubjectConfirmation subjectConfirmation = new SubjectConfirmation();\n     SubjectConfirmationDataType data = subjectConfirmationType.getSubjectConfirmationData();\n@@ -818,32 +715,14 @@ private SubjectConfirmation parseConfirmation(SubjectConfirmationType subjectCon\n     return subjectConfirmation;\n   }\n \n-  private Document parseFromBytes(byte[] bytes) throws SAMLException {\n-    DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n-    documentBuilderFactory.setNamespaceAware(true);\n-    try {\n-      DocumentBuilder builder = documentBuilderFactory.newDocumentBuilder();\n-      return builder.parse(new ByteArrayInputStream(bytes));\n-    } catch (ParserConfigurationException | SAXException | IOException e) {\n-      throw new SAMLException(\"Unable to parse SAML v2.0 authentication response\", e);\n-    }\n-  }\n-\n-  private NameID parseNameId(NameIDType element) {\n-    NameID nameId = new NameID();\n-    nameId.format = NameIDFormat.fromSAMLFormat(element.getFormat());\n-    nameId.id = element.getValue();\n-    return nameId;\n-  }\n-\n   private AuthnRequestParseResult parseRequest(byte[] xmlBytes) throws SAMLException {\n     String xml = new String(xmlBytes, StandardCharsets.UTF_8);\n     if (logger.isDebugEnabled()) {\n       logger.debug(\"SAMLRequest XML is\\n{}\", xml);\n     }\n \n     AuthnRequestParseResult result = new AuthnRequestParseResult();\n-    result.document = parseFromBytes(xmlBytes);\n+    result.document = newDocumentFromBytes(xmlBytes);\n     result.authnRequest = unmarshallFromDocument(result.document, AuthnRequestType.class);\n     result.request = new AuthenticationRequest();\n     result.request.xml = xml;\n@@ -907,60 +786,6 @@ private AuthnRequestType toAuthnRequest(AuthenticationRequest request, String ve\n     return authnRequest;\n   }\n \n-  private Certificate toCertificate(KeyDescriptorType keyDescriptorType) {\n-    try {\n-      List<Object> keyData = keyDescriptorType.getKeyInfo().getContent();\n-      for (Object keyDatum : keyData) {\n-        if (keyDatum instanceof JAXBElement<?>) {\n-          JAXBElement<?> element = (JAXBElement<?>) keyDatum;\n-          if (element.getDeclaredType() == X509DataType.class) {\n-            X509DataType cert = (X509DataType) element.getValue();\n-            List<Object> certData = cert.getX509IssuerSerialOrX509SKIOrX509SubjectName();\n-            for (Object certDatum : certData) {\n-              element = (JAXBElement<?>) certDatum;\n-              if (element.getName().getLocalPart().equals(\"X509Certificate\")) {\n-                byte[] certBytes = (byte[]) element.getValue();\n-                CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n-                return cf.generateCertificate(new ByteArrayInputStream(certBytes));\n-              }\n-            }\n-          }\n-        }\n-      }\n-\n-      return null;\n-    } catch (CertificateException e) {\n-      throw new IllegalArgumentException(e);\n-    }\n-  }\n-\n-  private XMLGregorianCalendar toXMLGregorianCalendar(ZonedDateTime instant) {\n-    if (instant == null) {\n-      return null;\n-    }\n-\n-    return new XMLGregorianCalendarImpl(GregorianCalendar.from(instant));\n-  }\n-\n-  private ZonedDateTime toZonedDateTime(XMLGregorianCalendar instant) {\n-    if (instant == null) {\n-      return null;\n-    }\n-\n-    return instant.toGregorianCalendar().toZonedDateTime();\n-  }\n-\n-  private <T> T unmarshallFromDocument(Document document, Class<T> type) throws SAMLException {\n-    try {\n-      JAXBContext context = JAXBContext.newInstance(type);\n-      Unmarshaller unmarshaller = context.createUnmarshaller();\n-      JAXBElement<T> element = unmarshaller.unmarshal(document, type);\n-      return element.getValue();\n-    } catch (JAXBException e) {\n-      throw new SAMLException(\"Unable to unmarshall SAML response\", e);\n-    }\n-  }\n-\n   private void verifySignature(Document document, KeySelector keySelector) throws SAMLException {\n     // Fix the IDs in the entire document per the suggestions at http://stackoverflow.com/questions/17331187/xml-dig-sig-error-after-upgrade-to-java7u25\n     fixIDs(document.getDocumentElement());",
    "function_modified_lines": {
      "added": [],
      "deleted": [
        "  private ZonedDateTime convertToZonedDateTime(XMLGregorianCalendar cal) {\n",
        "    return cal != null ? cal.toGregorianCalendar().toZonedDateTime() : null;\n",
        "  }\n",
        "\n",
        "  private byte[] decodeAndInflate(String encodedRequest) throws SAMLException {\n",
        "    byte[] bytes = Base64.getMimeDecoder().decode(encodedRequest);\n",
        "    Inflater inflater = new Inflater(true);\n",
        "    inflater.setInput(bytes);\n",
        "    inflater.finished();\n",
        "\n",
        "    try {\n",
        "      ByteArrayOutputStream baos = new ByteArrayOutputStream();\n",
        "      byte[] result = new byte[bytes.length];\n",
        "      while (!inflater.finished()) {\n",
        "        int length = inflater.inflate(result);\n",
        "        if (length > 0) {\n",
        "          baos.write(result, 0, length);\n",
        "        }\n",
        "      }\n",
        "\n",
        "      return baos.toByteArray();\n",
        "    } catch (DataFormatException e) {\n",
        "      throw new SAMLException(\"Invalid AuthnRequest. Inflating the bytes failed.\", e);\n",
        "    }\n",
        "  }\n",
        "\n",
        "  private String deflateAndEncode(byte[] result) {\n",
        "    Deflater deflater = new Deflater(Deflater.DEFLATED, true);\n",
        "    deflater.setInput(result);\n",
        "    deflater.finish();\n",
        "    byte[] deflatedResult = new byte[result.length];\n",
        "    int length = deflater.deflate(deflatedResult);\n",
        "    deflater.end();\n",
        "    byte[] src = Arrays.copyOf(deflatedResult, length);\n",
        "    return Base64.getEncoder().encodeToString(src);\n",
        "  }\n",
        "\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "FusionAuth fusionauth-samlv2 before 0.5.4 allows XXE attacks via a forged AuthnRequest or LogoutRequest because parseFromBytes uses javax.xml.parsers.DocumentBuilderFactory unsafely.",
    "id": 12242
  },
  {
    "cve_id": "CVE-2021-27736",
    "code_before_change": "    } catch (DataFormatException e) {\n      throw new SAMLException(\"Invalid AuthnRequest. Inflating the bytes failed.\", e);\n    }\n  }\n\n  private String deflateAndEncode(byte[] result) {\n    Deflater deflater = new Deflater(Deflater.DEFLATED, true);\n    deflater.setInput(result);\n    deflater.finish();\n    byte[] deflatedResult = new byte[result.length];\n    int length = deflater.deflate(deflatedResult);\n    deflater.end();\n    byte[] src = Arrays.copyOf(deflatedResult, length);\n    return Base64.getEncoder().encodeToString(src);\n  }\n\n  private void fixIDs(Element element) {\n    NamedNodeMap attributes = element.getAttributes();\n    for (int i = 0; i < attributes.getLength(); i++) {\n      Attr attribute = (Attr) attributes.item(i);\n      if (attribute.getLocalName().equalsIgnoreCase(\"id\")) {\n        element.setIdAttributeNode(attribute, true);\n      }\n    }\n\n    NodeList children = element.getChildNodes();\n    for (int i = 0; i < children.getLength(); i++) {\n      Node child = children.item(i);\n      if (child.getNodeType() == Node.ELEMENT_NODE) {\n        fixIDs((Element) child);\n      }\n    }\n  }\n\n  private <T> byte[] marshallToBytes(JAXBElement<T> object, Class<T> type) throws SAMLException {\n    try {\n      JAXBContext context = JAXBContext.newInstance(type);\n      Marshaller marshaller = context.createMarshaller();\n      ByteArrayOutputStream baos = new ByteArrayOutputStream();\n      marshaller.marshal(object, baos);\n      return baos.toByteArray();\n    } catch (JAXBException e) {\n      throw new SAMLException(\"Unable to marshallRequest JAXB SAML object to bytes.\", e);\n    }\n  }\n\n  @SuppressWarnings(\"SameParameterValue\")\n  private <T> Document marshallToDocument(JAXBElement<T> object, Class<T> type) throws SAMLException {\n    try {\n      JAXBContext context = JAXBContext.newInstance(type);\n      Marshaller marshaller = context.createMarshaller();\n      DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n      dbf.setNamespaceAware(true);\n      DocumentBuilder db = dbf.newDocumentBuilder();\n      Document document = db.newDocument();\n      marshaller.marshal(object, document);\n      return document;\n    } catch (JAXBException | ParserConfigurationException e) {\n      throw new SAMLException(\"Unable to marshallRequest JAXB SAML object to DOM.\", e);\n    }\n  }\n\n  private String marshallToString(Document document) throws TransformerException {\n    StringWriter sw = new StringWriter();\n    TransformerFactory tf = TransformerFactory.newInstance();\n    Transformer transformer = tf.newTransformer();\n    transformer.transform(new DOMSource(document), new StreamResult(sw));\n    return sw.toString();\n  }\n\n  private SubjectConfirmation parseConfirmation(SubjectConfirmationType subjectConfirmationType) {\n    SubjectConfirmation subjectConfirmation = new SubjectConfirmation();\n    SubjectConfirmationDataType data = subjectConfirmationType.getSubjectConfirmationData();\n    if (data != null) {\n      subjectConfirmation.address = data.getAddress();\n      subjectConfirmation.inResponseTo = data.getInResponseTo();\n      subjectConfirmation.notBefore = toZonedDateTime(data.getNotBefore());\n      subjectConfirmation.notOnOrAfter = toZonedDateTime(data.getNotOnOrAfter());\n      subjectConfirmation.recipient = data.getRecipient();\n    }\n\n    subjectConfirmation.method = ConfirmationMethod.fromSAMLFormat(subjectConfirmationType.getMethod());\n\n    return subjectConfirmation;\n  }\n\n  private Document parseFromBytes(byte[] bytes) throws SAMLException {\n    DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n    documentBuilderFactory.setNamespaceAware(true);\n    try {\n      DocumentBuilder builder = documentBuilderFactory.newDocumentBuilder();\n      return builder.parse(new ByteArrayInputStream(bytes));\n    } catch (ParserConfigurationException | SAXException | IOException e) {\n      throw new SAMLException(\"Unable to parse SAML v2.0 authentication response\", e);\n    }\n  }\n\n  private NameID parseNameId(NameIDType element) {\n    NameID nameId = new NameID();\n    nameId.format = NameIDFormat.fromSAMLFormat(element.getFormat());\n    nameId.id = element.getValue();\n    return nameId;\n  }\n\n  private AuthnRequestParseResult parseRequest(byte[] xmlBytes) throws SAMLException {\n    String xml = new String(xmlBytes, StandardCharsets.UTF_8);",
    "code_after_change": "      if (sign && key != null && algorithm != null) {\n        Signature signature;\n        parameters += \"&SigAlg=\" + URLEncoder.encode(algorithm.uri, \"UTF-8\");\n        signature = Signature.getInstance(algorithm.name);\n        signature.initSign(key);\n        signature.update(parameters.getBytes(StandardCharsets.UTF_8));\n\n        String signatureParameter = Base64.getEncoder().encodeToString(signature.sign());\n        parameters += \"&Signature=\" + URLEncoder.encode(signatureParameter, \"UTF-8\");\n      }\n\n      return parameters;\n    } catch (Exception e) {\n      // Not possible but freak out\n      throw new SAMLException(e);\n    }\n  }\n\n  private void fixIDs(Element element) {\n    NamedNodeMap attributes = element.getAttributes();\n    for (int i = 0; i < attributes.getLength(); i++) {\n      Attr attribute = (Attr) attributes.item(i);\n      if (attribute.getLocalName().equalsIgnoreCase(\"id\")) {\n        element.setIdAttributeNode(attribute, true);\n      }\n    }\n\n    NodeList children = element.getChildNodes();\n    for (int i = 0; i < children.getLength(); i++) {\n      Node child = children.item(i);\n      if (child.getNodeType() == Node.ELEMENT_NODE) {\n        fixIDs((Element) child);\n      }\n    }\n  }\n\n  private SubjectConfirmation parseConfirmation(SubjectConfirmationType subjectConfirmationType) {\n    SubjectConfirmation subjectConfirmation = new SubjectConfirmation();\n    SubjectConfirmationDataType data = subjectConfirmationType.getSubjectConfirmationData();\n    if (data != null) {\n      subjectConfirmation.address = data.getAddress();\n      subjectConfirmation.inResponseTo = data.getInResponseTo();\n      subjectConfirmation.notBefore = toZonedDateTime(data.getNotBefore());\n      subjectConfirmation.notOnOrAfter = toZonedDateTime(data.getNotOnOrAfter());\n      subjectConfirmation.recipient = data.getRecipient();\n    }\n\n    subjectConfirmation.method = ConfirmationMethod.fromSAMLFormat(subjectConfirmationType.getMethod());\n\n    return subjectConfirmation;\n  }\n\n  private AuthnRequestParseResult parseRequest(byte[] xmlBytes) throws SAMLException {\n    String xml = new String(xmlBytes, StandardCharsets.UTF_8);\n    if (logger.isDebugEnabled()) {\n      logger.debug(\"SAMLRequest XML is\\n{}\", xml);\n    }\n\n    AuthnRequestParseResult result = new AuthnRequestParseResult();\n    result.document = newDocumentFromBytes(xmlBytes);\n    result.authnRequest = unmarshallFromDocument(result.document, AuthnRequestType.class);\n    result.request = new AuthenticationRequest();\n    result.request.xml = xml;\n    result.request.id = result.authnRequest.getID();\n    result.request.issuer = result.authnRequest.getIssuer().getValue();\n    result.request.issueInstant = result.authnRequest.getIssueInstant().toGregorianCalendar().toZonedDateTime();\n    NameIDPolicyType nameIdPolicyType = result.authnRequest.getNameIDPolicy();\n    if (nameIdPolicyType == null) {\n      result.request.nameIdFormat = NameIDFormat.EmailAddress;\n    } else {\n      result.request.nameIdFormat = NameIDFormat.fromSAMLFormat(nameIdPolicyType.getFormat());\n    }\n    result.request.version = result.authnRequest.getVersion();\n    return result;",
    "patch": "@@ -15,11 +15,7 @@\n  */\n package io.fusionauth.samlv2.service;\n \n-import javax.xml.bind.JAXBContext;\n import javax.xml.bind.JAXBElement;\n-import javax.xml.bind.JAXBException;\n-import javax.xml.bind.Marshaller;\n-import javax.xml.bind.Unmarshaller;\n import javax.xml.crypto.KeySelector;\n import javax.xml.crypto.MarshalException;\n import javax.xml.crypto.dsig.CanonicalizationMethod;\n@@ -37,19 +33,7 @@\n import javax.xml.crypto.dsig.keyinfo.X509Data;\n import javax.xml.crypto.dsig.spec.C14NMethodParameterSpec;\n import javax.xml.crypto.dsig.spec.TransformParameterSpec;\n-import javax.xml.datatype.XMLGregorianCalendar;\n-import javax.xml.parsers.DocumentBuilder;\n-import javax.xml.parsers.DocumentBuilderFactory;\n-import javax.xml.parsers.ParserConfigurationException;\n-import javax.xml.transform.Transformer;\n import javax.xml.transform.TransformerException;\n-import javax.xml.transform.TransformerFactory;\n-import javax.xml.transform.dom.DOMSource;\n-import javax.xml.transform.stream.StreamResult;\n-import java.io.ByteArrayInputStream;\n-import java.io.ByteArrayOutputStream;\n-import java.io.IOException;\n-import java.io.StringWriter;\n import java.io.UnsupportedEncodingException;\n import java.net.URLEncoder;\n import java.nio.charset.StandardCharsets;\n@@ -59,8 +43,6 @@\n import java.security.PrivateKey;\n import java.security.Signature;\n import java.security.cert.Certificate;\n-import java.security.cert.CertificateException;\n-import java.security.cert.CertificateFactory;\n import java.security.cert.X509Certificate;\n import java.time.ZoneOffset;\n import java.time.ZonedDateTime;\n@@ -75,9 +57,6 @@\n import java.util.UUID;\n import java.util.function.Function;\n import java.util.stream.Collectors;\n-import java.util.zip.DataFormatException;\n-import java.util.zip.Deflater;\n-import java.util.zip.Inflater;\n \n import com.sun.org.apache.xerces.internal.jaxp.datatype.XMLGregorianCalendarImpl;\n import io.fusionauth.samlv2.domain.Algorithm;\n@@ -89,7 +68,6 @@\n import io.fusionauth.samlv2.domain.MetaData;\n import io.fusionauth.samlv2.domain.MetaData.IDPMetaData;\n import io.fusionauth.samlv2.domain.MetaData.SPMetaData;\n-import io.fusionauth.samlv2.domain.NameID;\n import io.fusionauth.samlv2.domain.NameIDFormat;\n import io.fusionauth.samlv2.domain.ResponseStatus;\n import io.fusionauth.samlv2.domain.SAMLException;\n@@ -128,6 +106,7 @@\n import io.fusionauth.samlv2.domain.jaxb.oasis.protocol.StatusType;\n import io.fusionauth.samlv2.domain.jaxb.w3c.xmldsig.KeyInfoType;\n import io.fusionauth.samlv2.domain.jaxb.w3c.xmldsig.X509DataType;\n+import io.fusionauth.samlv2.util.SAMLTools;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.w3c.dom.Attr;\n@@ -136,7 +115,16 @@\n import org.w3c.dom.NamedNodeMap;\n import org.w3c.dom.Node;\n import org.w3c.dom.NodeList;\n-import org.xml.sax.SAXException;\n+import static io.fusionauth.samlv2.util.SAMLTools.convertToZonedDateTime;\n+import static io.fusionauth.samlv2.util.SAMLTools.decodeAndInflate;\n+import static io.fusionauth.samlv2.util.SAMLTools.marshallToBytes;\n+import static io.fusionauth.samlv2.util.SAMLTools.marshallToDocument;\n+import static io.fusionauth.samlv2.util.SAMLTools.marshallToString;\n+import static io.fusionauth.samlv2.util.SAMLTools.newDocumentFromBytes;\n+import static io.fusionauth.samlv2.util.SAMLTools.parseNameId;\n+import static io.fusionauth.samlv2.util.SAMLTools.toXMLGregorianCalendar;\n+import static io.fusionauth.samlv2.util.SAMLTools.toZonedDateTime;\n+import static io.fusionauth.samlv2.util.SAMLTools.unmarshallFromDocument;\n \n /**\n  * Default implementation of the SAML service.\n@@ -411,7 +399,7 @@ public String buildRedirectAuthnRequest(AuthenticationRequest request, String re\n \n   @Override\n   public MetaData parseMetaData(String metaDataXML) throws SAMLException {\n-    Document document = parseFromBytes(metaDataXML.getBytes(StandardCharsets.UTF_8));\n+    Document document = newDocumentFromBytes(metaDataXML.getBytes(StandardCharsets.UTF_8));\n     EntityDescriptorType root = unmarshallFromDocument(document, EntityDescriptorType.class);\n     MetaData metaData = new MetaData();\n     metaData.id = root.getID();\n@@ -450,7 +438,7 @@ public MetaData parseMetaData(String metaDataXML) throws SAMLException {\n         metaData.idp.certificates = idp.getKeyDescriptor()\n                                        .stream()\n                                        .filter(kd -> kd.getUse() == KeyTypes.SIGNING)\n-                                       .map(this::toCertificate)\n+                                       .map(SAMLTools::toCertificate)\n                                        .filter(Objects::nonNull)\n                                        .collect(Collectors.toList());\n       } catch (IllegalArgumentException e) {\n@@ -532,7 +520,7 @@ public AuthenticationResponse parseResponse(String encodedResponse, boolean veri\n     byte[] decodedResponse = Base64.getMimeDecoder().decode(encodedResponse);\n     response.rawResponse = new String(decodedResponse, StandardCharsets.UTF_8);\n \n-    Document document = parseFromBytes(decodedResponse);\n+    Document document = newDocumentFromBytes(decodedResponse);\n     if (verifySignature) {\n       verifySignature(document, keySelector);\n     }\n@@ -613,7 +601,7 @@ public AuthenticationResponse parseResponse(String encodedResponse, boolean veri\n               AttributeType attributeType = (AttributeType) attributeObject;\n               String name = attributeType.getName();\n               List<Object> attributeValues = attributeType.getAttributeValue();\n-              List<String> values = attributeValues.stream().map(this::attributeToString).collect(Collectors.toList());\n+              List<String> values = attributeValues.stream().map(SAMLTools::attributeToString).collect(Collectors.toList());\n               response.assertion.attributes.computeIfAbsent(name, k -> new ArrayList<>()).addAll(values);\n             } else {\n               throw new SAMLException(\"This library currently doesn't support encrypted attributes\");\n@@ -646,24 +634,6 @@ private void addKeyDescriptors(SSODescriptorType descriptor, List<Certificate> c\n     });\n   }\n \n-  private String attributeToString(Object attribute) {\n-    if (attribute == null) {\n-      return null;\n-    }\n-\n-    if (attribute instanceof Number) {\n-      return attribute.toString();\n-    } else if (attribute instanceof String) {\n-      return (String) attribute;\n-    } else if (attribute instanceof Element) {\n-      return ((Element) attribute).getTextContent();\n-    } else {\n-      logger.warn(\"This library currently doesn't handle attributes of type [\" + attribute.getClass() + \"]\");\n-    }\n-\n-    return null;\n-  }\n-\n   private String buildPostAuthnRequest(AuthnRequestType authnRequest, boolean sign, PrivateKey privateKey,\n                                        X509Certificate certificate,\n                                        Algorithm algorithm, String xmlSignatureC14nMethod) throws SAMLException {\n@@ -687,7 +657,7 @@ private String buildRedirectAuthnRequest(AuthnRequestType authnRequest, String r\n                                            PrivateKey key, Algorithm algorithm) throws SAMLException {\n     try {\n       byte[] xml = marshallToBytes(PROTOCOL_OBJECT_FACTORY.createAuthnRequest(authnRequest), AuthnRequestType.class);\n-      String encodedResult = deflateAndEncode(xml);\n+      String encodedResult = SAMLTools.deflateAndEncode(xml);\n       String parameters = \"SAMLRequest=\" + URLEncoder.encode(encodedResult, \"UTF-8\");\n       if (relayState != null) {\n         parameters += \"&RelayState=\" + URLEncoder.encode(relayState, \"UTF-8\");\n@@ -711,43 +681,6 @@ private String buildRedirectAuthnRequest(AuthnRequestType authnRequest, String r\n     }\n   }\n \n-  private ZonedDateTime convertToZonedDateTime(XMLGregorianCalendar cal) {\n-    return cal != null ? cal.toGregorianCalendar().toZonedDateTime() : null;\n-  }\n-\n-  private byte[] decodeAndInflate(String encodedRequest) throws SAMLException {\n-    byte[] bytes = Base64.getMimeDecoder().decode(encodedRequest);\n-    Inflater inflater = new Inflater(true);\n-    inflater.setInput(bytes);\n-    inflater.finished();\n-\n-    try {\n-      ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-      byte[] result = new byte[bytes.length];\n-      while (!inflater.finished()) {\n-        int length = inflater.inflate(result);\n-        if (length > 0) {\n-          baos.write(result, 0, length);\n-        }\n-      }\n-\n-      return baos.toByteArray();\n-    } catch (DataFormatException e) {\n-      throw new SAMLException(\"Invalid AuthnRequest. Inflating the bytes failed.\", e);\n-    }\n-  }\n-\n-  private String deflateAndEncode(byte[] result) {\n-    Deflater deflater = new Deflater(Deflater.DEFLATED, true);\n-    deflater.setInput(result);\n-    deflater.finish();\n-    byte[] deflatedResult = new byte[result.length];\n-    int length = deflater.deflate(deflatedResult);\n-    deflater.end();\n-    byte[] src = Arrays.copyOf(deflatedResult, length);\n-    return Base64.getEncoder().encodeToString(src);\n-  }\n-\n   private void fixIDs(Element element) {\n     NamedNodeMap attributes = element.getAttributes();\n     for (int i = 0; i < attributes.getLength(); i++) {\n@@ -766,42 +699,6 @@ private void fixIDs(Element element) {\n     }\n   }\n \n-  private <T> byte[] marshallToBytes(JAXBElement<T> object, Class<T> type) throws SAMLException {\n-    try {\n-      JAXBContext context = JAXBContext.newInstance(type);\n-      Marshaller marshaller = context.createMarshaller();\n-      ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-      marshaller.marshal(object, baos);\n-      return baos.toByteArray();\n-    } catch (JAXBException e) {\n-      throw new SAMLException(\"Unable to marshallRequest JAXB SAML object to bytes.\", e);\n-    }\n-  }\n-\n-  @SuppressWarnings(\"SameParameterValue\")\n-  private <T> Document marshallToDocument(JAXBElement<T> object, Class<T> type) throws SAMLException {\n-    try {\n-      JAXBContext context = JAXBContext.newInstance(type);\n-      Marshaller marshaller = context.createMarshaller();\n-      DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n-      dbf.setNamespaceAware(true);\n-      DocumentBuilder db = dbf.newDocumentBuilder();\n-      Document document = db.newDocument();\n-      marshaller.marshal(object, document);\n-      return document;\n-    } catch (JAXBException | ParserConfigurationException e) {\n-      throw new SAMLException(\"Unable to marshallRequest JAXB SAML object to DOM.\", e);\n-    }\n-  }\n-\n-  private String marshallToString(Document document) throws TransformerException {\n-    StringWriter sw = new StringWriter();\n-    TransformerFactory tf = TransformerFactory.newInstance();\n-    Transformer transformer = tf.newTransformer();\n-    transformer.transform(new DOMSource(document), new StreamResult(sw));\n-    return sw.toString();\n-  }\n-\n   private SubjectConfirmation parseConfirmation(SubjectConfirmationType subjectConfirmationType) {\n     SubjectConfirmation subjectConfirmation = new SubjectConfirmation();\n     SubjectConfirmationDataType data = subjectConfirmationType.getSubjectConfirmationData();\n@@ -818,32 +715,14 @@ private SubjectConfirmation parseConfirmation(SubjectConfirmationType subjectCon\n     return subjectConfirmation;\n   }\n \n-  private Document parseFromBytes(byte[] bytes) throws SAMLException {\n-    DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n-    documentBuilderFactory.setNamespaceAware(true);\n-    try {\n-      DocumentBuilder builder = documentBuilderFactory.newDocumentBuilder();\n-      return builder.parse(new ByteArrayInputStream(bytes));\n-    } catch (ParserConfigurationException | SAXException | IOException e) {\n-      throw new SAMLException(\"Unable to parse SAML v2.0 authentication response\", e);\n-    }\n-  }\n-\n-  private NameID parseNameId(NameIDType element) {\n-    NameID nameId = new NameID();\n-    nameId.format = NameIDFormat.fromSAMLFormat(element.getFormat());\n-    nameId.id = element.getValue();\n-    return nameId;\n-  }\n-\n   private AuthnRequestParseResult parseRequest(byte[] xmlBytes) throws SAMLException {\n     String xml = new String(xmlBytes, StandardCharsets.UTF_8);\n     if (logger.isDebugEnabled()) {\n       logger.debug(\"SAMLRequest XML is\\n{}\", xml);\n     }\n \n     AuthnRequestParseResult result = new AuthnRequestParseResult();\n-    result.document = parseFromBytes(xmlBytes);\n+    result.document = newDocumentFromBytes(xmlBytes);\n     result.authnRequest = unmarshallFromDocument(result.document, AuthnRequestType.class);\n     result.request = new AuthenticationRequest();\n     result.request.xml = xml;\n@@ -907,60 +786,6 @@ private AuthnRequestType toAuthnRequest(AuthenticationRequest request, String ve\n     return authnRequest;\n   }\n \n-  private Certificate toCertificate(KeyDescriptorType keyDescriptorType) {\n-    try {\n-      List<Object> keyData = keyDescriptorType.getKeyInfo().getContent();\n-      for (Object keyDatum : keyData) {\n-        if (keyDatum instanceof JAXBElement<?>) {\n-          JAXBElement<?> element = (JAXBElement<?>) keyDatum;\n-          if (element.getDeclaredType() == X509DataType.class) {\n-            X509DataType cert = (X509DataType) element.getValue();\n-            List<Object> certData = cert.getX509IssuerSerialOrX509SKIOrX509SubjectName();\n-            for (Object certDatum : certData) {\n-              element = (JAXBElement<?>) certDatum;\n-              if (element.getName().getLocalPart().equals(\"X509Certificate\")) {\n-                byte[] certBytes = (byte[]) element.getValue();\n-                CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n-                return cf.generateCertificate(new ByteArrayInputStream(certBytes));\n-              }\n-            }\n-          }\n-        }\n-      }\n-\n-      return null;\n-    } catch (CertificateException e) {\n-      throw new IllegalArgumentException(e);\n-    }\n-  }\n-\n-  private XMLGregorianCalendar toXMLGregorianCalendar(ZonedDateTime instant) {\n-    if (instant == null) {\n-      return null;\n-    }\n-\n-    return new XMLGregorianCalendarImpl(GregorianCalendar.from(instant));\n-  }\n-\n-  private ZonedDateTime toZonedDateTime(XMLGregorianCalendar instant) {\n-    if (instant == null) {\n-      return null;\n-    }\n-\n-    return instant.toGregorianCalendar().toZonedDateTime();\n-  }\n-\n-  private <T> T unmarshallFromDocument(Document document, Class<T> type) throws SAMLException {\n-    try {\n-      JAXBContext context = JAXBContext.newInstance(type);\n-      Unmarshaller unmarshaller = context.createUnmarshaller();\n-      JAXBElement<T> element = unmarshaller.unmarshal(document, type);\n-      return element.getValue();\n-    } catch (JAXBException e) {\n-      throw new SAMLException(\"Unable to unmarshall SAML response\", e);\n-    }\n-  }\n-\n   private void verifySignature(Document document, KeySelector keySelector) throws SAMLException {\n     // Fix the IDs in the entire document per the suggestions at http://stackoverflow.com/questions/17331187/xml-dig-sig-error-after-upgrade-to-java7u25\n     fixIDs(document.getDocumentElement());",
    "function_modified_lines": {
      "added": [],
      "deleted": [
        "  private <T> byte[] marshallToBytes(JAXBElement<T> object, Class<T> type) throws SAMLException {\n",
        "    try {\n",
        "      JAXBContext context = JAXBContext.newInstance(type);\n",
        "      Marshaller marshaller = context.createMarshaller();\n",
        "      ByteArrayOutputStream baos = new ByteArrayOutputStream();\n",
        "      marshaller.marshal(object, baos);\n",
        "      return baos.toByteArray();\n",
        "    } catch (JAXBException e) {\n",
        "      throw new SAMLException(\"Unable to marshallRequest JAXB SAML object to bytes.\", e);\n",
        "    }\n",
        "  }\n",
        "\n",
        "  @SuppressWarnings(\"SameParameterValue\")\n",
        "  private <T> Document marshallToDocument(JAXBElement<T> object, Class<T> type) throws SAMLException {\n",
        "    try {\n",
        "      JAXBContext context = JAXBContext.newInstance(type);\n",
        "      Marshaller marshaller = context.createMarshaller();\n",
        "      DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n",
        "      dbf.setNamespaceAware(true);\n",
        "      DocumentBuilder db = dbf.newDocumentBuilder();\n",
        "      Document document = db.newDocument();\n",
        "      marshaller.marshal(object, document);\n",
        "      return document;\n",
        "    } catch (JAXBException | ParserConfigurationException e) {\n",
        "      throw new SAMLException(\"Unable to marshallRequest JAXB SAML object to DOM.\", e);\n",
        "    }\n",
        "  }\n",
        "\n",
        "  private String marshallToString(Document document) throws TransformerException {\n",
        "    StringWriter sw = new StringWriter();\n",
        "    TransformerFactory tf = TransformerFactory.newInstance();\n",
        "    Transformer transformer = tf.newTransformer();\n",
        "    transformer.transform(new DOMSource(document), new StreamResult(sw));\n",
        "    return sw.toString();\n",
        "  }\n",
        "\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "FusionAuth fusionauth-samlv2 before 0.5.4 allows XXE attacks via a forged AuthnRequest or LogoutRequest because parseFromBytes uses javax.xml.parsers.DocumentBuilderFactory unsafely.",
    "id": 12243
  },
  {
    "cve_id": "CVE-2021-27736",
    "code_before_change": "      dbf.setNamespaceAware(true);\n      DocumentBuilder db = dbf.newDocumentBuilder();\n      Document document = db.newDocument();\n      marshaller.marshal(object, document);\n      return document;\n    } catch (JAXBException | ParserConfigurationException e) {\n      throw new SAMLException(\"Unable to marshallRequest JAXB SAML object to DOM.\", e);\n    }\n  }\n\n  private String marshallToString(Document document) throws TransformerException {\n    StringWriter sw = new StringWriter();\n    TransformerFactory tf = TransformerFactory.newInstance();\n    Transformer transformer = tf.newTransformer();\n    transformer.transform(new DOMSource(document), new StreamResult(sw));\n    return sw.toString();\n  }\n\n  private SubjectConfirmation parseConfirmation(SubjectConfirmationType subjectConfirmationType) {\n    SubjectConfirmation subjectConfirmation = new SubjectConfirmation();\n    SubjectConfirmationDataType data = subjectConfirmationType.getSubjectConfirmationData();\n    if (data != null) {\n      subjectConfirmation.address = data.getAddress();\n      subjectConfirmation.inResponseTo = data.getInResponseTo();\n      subjectConfirmation.notBefore = toZonedDateTime(data.getNotBefore());\n      subjectConfirmation.notOnOrAfter = toZonedDateTime(data.getNotOnOrAfter());\n      subjectConfirmation.recipient = data.getRecipient();\n    }\n\n    subjectConfirmation.method = ConfirmationMethod.fromSAMLFormat(subjectConfirmationType.getMethod());\n\n    return subjectConfirmation;\n  }\n\n  private Document parseFromBytes(byte[] bytes) throws SAMLException {\n    DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n    documentBuilderFactory.setNamespaceAware(true);\n    try {\n      DocumentBuilder builder = documentBuilderFactory.newDocumentBuilder();\n      return builder.parse(new ByteArrayInputStream(bytes));\n    } catch (ParserConfigurationException | SAXException | IOException e) {\n      throw new SAMLException(\"Unable to parse SAML v2.0 authentication response\", e);\n    }\n  }\n\n  private NameID parseNameId(NameIDType element) {\n    NameID nameId = new NameID();\n    nameId.format = NameIDFormat.fromSAMLFormat(element.getFormat());\n    nameId.id = element.getValue();\n    return nameId;\n  }\n\n  private AuthnRequestParseResult parseRequest(byte[] xmlBytes) throws SAMLException {\n    String xml = new String(xmlBytes, StandardCharsets.UTF_8);\n    if (logger.isDebugEnabled()) {\n      logger.debug(\"SAMLRequest XML is\\n{}\", xml);\n    }\n\n    AuthnRequestParseResult result = new AuthnRequestParseResult();\n    result.document = parseFromBytes(xmlBytes);\n    result.authnRequest = unmarshallFromDocument(result.document, AuthnRequestType.class);\n    result.request = new AuthenticationRequest();\n    result.request.xml = xml;\n    result.request.id = result.authnRequest.getID();\n    result.request.issuer = result.authnRequest.getIssuer().getValue();\n    result.request.issueInstant = result.authnRequest.getIssueInstant().toGregorianCalendar().toZonedDateTime();\n    NameIDPolicyType nameIdPolicyType = result.authnRequest.getNameIDPolicy();\n    if (nameIdPolicyType == null) {\n      result.request.nameIdFormat = NameIDFormat.EmailAddress;\n    } else {\n      result.request.nameIdFormat = NameIDFormat.fromSAMLFormat(nameIdPolicyType.getFormat());\n    }\n    result.request.version = result.authnRequest.getVersion();\n    return result;\n  }\n\n  private String signXML(PrivateKey privateKey, X509Certificate certificate, Algorithm algorithm,\n                         String xmlSignatureC14nMethod, Document document, Element toSign, Node insertBefore)\n      throws NoSuchAlgorithmException, InvalidAlgorithmParameterException, MarshalException, XMLSignatureException, TransformerException {\n    // Set the id attribute node. Yucky! Yuck!\n    toSign.setIdAttributeNode(toSign.getAttributeNode(\"ID\"), true);\n\n    // If there is an insert before, set it so that the signature is in the place that some IdPs require\n    // - If insertBefore is 'null' the signature will be inserted as the last element.\n    DOMSignContext dsc = new DOMSignContext(privateKey, toSign);\n    dsc.setNextSibling(insertBefore);\n\n    // Sign away\n    XMLSignatureFactory factory = XMLSignatureFactory.getInstance(\"DOM\");\n    CanonicalizationMethod c14n = factory.newCanonicalizationMethod(xmlSignatureC14nMethod, (C14NMethodParameterSpec) null);\n    Reference ref = factory.newReference(\"#\" + toSign.getAttribute(\"ID\"),\n        factory.newDigestMethod(DigestMethod.SHA256, null),\n        Arrays.asList(factory.newTransform(Transform.ENVELOPED, (TransformParameterSpec) null), c14n),\n        null,\n        null);\n    SignedInfo si = factory.newSignedInfo(c14n,",
    "code_after_change": "  }\n\n  private void fixIDs(Element element) {\n    NamedNodeMap attributes = element.getAttributes();\n    for (int i = 0; i < attributes.getLength(); i++) {\n      Attr attribute = (Attr) attributes.item(i);\n      if (attribute.getLocalName().equalsIgnoreCase(\"id\")) {\n        element.setIdAttributeNode(attribute, true);\n      }\n    }\n\n    NodeList children = element.getChildNodes();\n    for (int i = 0; i < children.getLength(); i++) {\n      Node child = children.item(i);\n      if (child.getNodeType() == Node.ELEMENT_NODE) {\n        fixIDs((Element) child);\n      }\n    }\n  }\n\n  private SubjectConfirmation parseConfirmation(SubjectConfirmationType subjectConfirmationType) {\n    SubjectConfirmation subjectConfirmation = new SubjectConfirmation();\n    SubjectConfirmationDataType data = subjectConfirmationType.getSubjectConfirmationData();\n    if (data != null) {\n      subjectConfirmation.address = data.getAddress();\n      subjectConfirmation.inResponseTo = data.getInResponseTo();\n      subjectConfirmation.notBefore = toZonedDateTime(data.getNotBefore());\n      subjectConfirmation.notOnOrAfter = toZonedDateTime(data.getNotOnOrAfter());\n      subjectConfirmation.recipient = data.getRecipient();\n    }\n\n    subjectConfirmation.method = ConfirmationMethod.fromSAMLFormat(subjectConfirmationType.getMethod());\n\n    return subjectConfirmation;\n  }\n\n  private AuthnRequestParseResult parseRequest(byte[] xmlBytes) throws SAMLException {\n    String xml = new String(xmlBytes, StandardCharsets.UTF_8);\n    if (logger.isDebugEnabled()) {\n      logger.debug(\"SAMLRequest XML is\\n{}\", xml);\n    }\n\n    AuthnRequestParseResult result = new AuthnRequestParseResult();\n    result.document = newDocumentFromBytes(xmlBytes);\n    result.authnRequest = unmarshallFromDocument(result.document, AuthnRequestType.class);\n    result.request = new AuthenticationRequest();\n    result.request.xml = xml;\n    result.request.id = result.authnRequest.getID();\n    result.request.issuer = result.authnRequest.getIssuer().getValue();\n    result.request.issueInstant = result.authnRequest.getIssueInstant().toGregorianCalendar().toZonedDateTime();\n    NameIDPolicyType nameIdPolicyType = result.authnRequest.getNameIDPolicy();\n    if (nameIdPolicyType == null) {\n      result.request.nameIdFormat = NameIDFormat.EmailAddress;\n    } else {\n      result.request.nameIdFormat = NameIDFormat.fromSAMLFormat(nameIdPolicyType.getFormat());\n    }\n    result.request.version = result.authnRequest.getVersion();\n    return result;\n  }\n\n  private String signXML(PrivateKey privateKey, X509Certificate certificate, Algorithm algorithm,\n                         String xmlSignatureC14nMethod, Document document, Element toSign, Node insertBefore)\n      throws NoSuchAlgorithmException, InvalidAlgorithmParameterException, MarshalException, XMLSignatureException, TransformerException {\n    // Set the id attribute node. Yucky! Yuck!\n    toSign.setIdAttributeNode(toSign.getAttributeNode(\"ID\"), true);\n\n    // If there is an insert before, set it so that the signature is in the place that some IdPs require\n    // - If insertBefore is 'null' the signature will be inserted as the last element.\n    DOMSignContext dsc = new DOMSignContext(privateKey, toSign);\n    dsc.setNextSibling(insertBefore);\n\n    // Sign away\n    XMLSignatureFactory factory = XMLSignatureFactory.getInstance(\"DOM\");\n    CanonicalizationMethod c14n = factory.newCanonicalizationMethod(xmlSignatureC14nMethod, (C14NMethodParameterSpec) null);\n    Reference ref = factory.newReference(\"#\" + toSign.getAttribute(\"ID\"),\n        factory.newDigestMethod(DigestMethod.SHA256, null),\n        Arrays.asList(factory.newTransform(Transform.ENVELOPED, (TransformParameterSpec) null), c14n),\n        null,\n        null);\n    SignedInfo si = factory.newSignedInfo(c14n,",
    "patch": "@@ -15,11 +15,7 @@\n  */\n package io.fusionauth.samlv2.service;\n \n-import javax.xml.bind.JAXBContext;\n import javax.xml.bind.JAXBElement;\n-import javax.xml.bind.JAXBException;\n-import javax.xml.bind.Marshaller;\n-import javax.xml.bind.Unmarshaller;\n import javax.xml.crypto.KeySelector;\n import javax.xml.crypto.MarshalException;\n import javax.xml.crypto.dsig.CanonicalizationMethod;\n@@ -37,19 +33,7 @@\n import javax.xml.crypto.dsig.keyinfo.X509Data;\n import javax.xml.crypto.dsig.spec.C14NMethodParameterSpec;\n import javax.xml.crypto.dsig.spec.TransformParameterSpec;\n-import javax.xml.datatype.XMLGregorianCalendar;\n-import javax.xml.parsers.DocumentBuilder;\n-import javax.xml.parsers.DocumentBuilderFactory;\n-import javax.xml.parsers.ParserConfigurationException;\n-import javax.xml.transform.Transformer;\n import javax.xml.transform.TransformerException;\n-import javax.xml.transform.TransformerFactory;\n-import javax.xml.transform.dom.DOMSource;\n-import javax.xml.transform.stream.StreamResult;\n-import java.io.ByteArrayInputStream;\n-import java.io.ByteArrayOutputStream;\n-import java.io.IOException;\n-import java.io.StringWriter;\n import java.io.UnsupportedEncodingException;\n import java.net.URLEncoder;\n import java.nio.charset.StandardCharsets;\n@@ -59,8 +43,6 @@\n import java.security.PrivateKey;\n import java.security.Signature;\n import java.security.cert.Certificate;\n-import java.security.cert.CertificateException;\n-import java.security.cert.CertificateFactory;\n import java.security.cert.X509Certificate;\n import java.time.ZoneOffset;\n import java.time.ZonedDateTime;\n@@ -75,9 +57,6 @@\n import java.util.UUID;\n import java.util.function.Function;\n import java.util.stream.Collectors;\n-import java.util.zip.DataFormatException;\n-import java.util.zip.Deflater;\n-import java.util.zip.Inflater;\n \n import com.sun.org.apache.xerces.internal.jaxp.datatype.XMLGregorianCalendarImpl;\n import io.fusionauth.samlv2.domain.Algorithm;\n@@ -89,7 +68,6 @@\n import io.fusionauth.samlv2.domain.MetaData;\n import io.fusionauth.samlv2.domain.MetaData.IDPMetaData;\n import io.fusionauth.samlv2.domain.MetaData.SPMetaData;\n-import io.fusionauth.samlv2.domain.NameID;\n import io.fusionauth.samlv2.domain.NameIDFormat;\n import io.fusionauth.samlv2.domain.ResponseStatus;\n import io.fusionauth.samlv2.domain.SAMLException;\n@@ -128,6 +106,7 @@\n import io.fusionauth.samlv2.domain.jaxb.oasis.protocol.StatusType;\n import io.fusionauth.samlv2.domain.jaxb.w3c.xmldsig.KeyInfoType;\n import io.fusionauth.samlv2.domain.jaxb.w3c.xmldsig.X509DataType;\n+import io.fusionauth.samlv2.util.SAMLTools;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.w3c.dom.Attr;\n@@ -136,7 +115,16 @@\n import org.w3c.dom.NamedNodeMap;\n import org.w3c.dom.Node;\n import org.w3c.dom.NodeList;\n-import org.xml.sax.SAXException;\n+import static io.fusionauth.samlv2.util.SAMLTools.convertToZonedDateTime;\n+import static io.fusionauth.samlv2.util.SAMLTools.decodeAndInflate;\n+import static io.fusionauth.samlv2.util.SAMLTools.marshallToBytes;\n+import static io.fusionauth.samlv2.util.SAMLTools.marshallToDocument;\n+import static io.fusionauth.samlv2.util.SAMLTools.marshallToString;\n+import static io.fusionauth.samlv2.util.SAMLTools.newDocumentFromBytes;\n+import static io.fusionauth.samlv2.util.SAMLTools.parseNameId;\n+import static io.fusionauth.samlv2.util.SAMLTools.toXMLGregorianCalendar;\n+import static io.fusionauth.samlv2.util.SAMLTools.toZonedDateTime;\n+import static io.fusionauth.samlv2.util.SAMLTools.unmarshallFromDocument;\n \n /**\n  * Default implementation of the SAML service.\n@@ -411,7 +399,7 @@ public String buildRedirectAuthnRequest(AuthenticationRequest request, String re\n \n   @Override\n   public MetaData parseMetaData(String metaDataXML) throws SAMLException {\n-    Document document = parseFromBytes(metaDataXML.getBytes(StandardCharsets.UTF_8));\n+    Document document = newDocumentFromBytes(metaDataXML.getBytes(StandardCharsets.UTF_8));\n     EntityDescriptorType root = unmarshallFromDocument(document, EntityDescriptorType.class);\n     MetaData metaData = new MetaData();\n     metaData.id = root.getID();\n@@ -450,7 +438,7 @@ public MetaData parseMetaData(String metaDataXML) throws SAMLException {\n         metaData.idp.certificates = idp.getKeyDescriptor()\n                                        .stream()\n                                        .filter(kd -> kd.getUse() == KeyTypes.SIGNING)\n-                                       .map(this::toCertificate)\n+                                       .map(SAMLTools::toCertificate)\n                                        .filter(Objects::nonNull)\n                                        .collect(Collectors.toList());\n       } catch (IllegalArgumentException e) {\n@@ -532,7 +520,7 @@ public AuthenticationResponse parseResponse(String encodedResponse, boolean veri\n     byte[] decodedResponse = Base64.getMimeDecoder().decode(encodedResponse);\n     response.rawResponse = new String(decodedResponse, StandardCharsets.UTF_8);\n \n-    Document document = parseFromBytes(decodedResponse);\n+    Document document = newDocumentFromBytes(decodedResponse);\n     if (verifySignature) {\n       verifySignature(document, keySelector);\n     }\n@@ -613,7 +601,7 @@ public AuthenticationResponse parseResponse(String encodedResponse, boolean veri\n               AttributeType attributeType = (AttributeType) attributeObject;\n               String name = attributeType.getName();\n               List<Object> attributeValues = attributeType.getAttributeValue();\n-              List<String> values = attributeValues.stream().map(this::attributeToString).collect(Collectors.toList());\n+              List<String> values = attributeValues.stream().map(SAMLTools::attributeToString).collect(Collectors.toList());\n               response.assertion.attributes.computeIfAbsent(name, k -> new ArrayList<>()).addAll(values);\n             } else {\n               throw new SAMLException(\"This library currently doesn't support encrypted attributes\");\n@@ -646,24 +634,6 @@ private void addKeyDescriptors(SSODescriptorType descriptor, List<Certificate> c\n     });\n   }\n \n-  private String attributeToString(Object attribute) {\n-    if (attribute == null) {\n-      return null;\n-    }\n-\n-    if (attribute instanceof Number) {\n-      return attribute.toString();\n-    } else if (attribute instanceof String) {\n-      return (String) attribute;\n-    } else if (attribute instanceof Element) {\n-      return ((Element) attribute).getTextContent();\n-    } else {\n-      logger.warn(\"This library currently doesn't handle attributes of type [\" + attribute.getClass() + \"]\");\n-    }\n-\n-    return null;\n-  }\n-\n   private String buildPostAuthnRequest(AuthnRequestType authnRequest, boolean sign, PrivateKey privateKey,\n                                        X509Certificate certificate,\n                                        Algorithm algorithm, String xmlSignatureC14nMethod) throws SAMLException {\n@@ -687,7 +657,7 @@ private String buildRedirectAuthnRequest(AuthnRequestType authnRequest, String r\n                                            PrivateKey key, Algorithm algorithm) throws SAMLException {\n     try {\n       byte[] xml = marshallToBytes(PROTOCOL_OBJECT_FACTORY.createAuthnRequest(authnRequest), AuthnRequestType.class);\n-      String encodedResult = deflateAndEncode(xml);\n+      String encodedResult = SAMLTools.deflateAndEncode(xml);\n       String parameters = \"SAMLRequest=\" + URLEncoder.encode(encodedResult, \"UTF-8\");\n       if (relayState != null) {\n         parameters += \"&RelayState=\" + URLEncoder.encode(relayState, \"UTF-8\");\n@@ -711,43 +681,6 @@ private String buildRedirectAuthnRequest(AuthnRequestType authnRequest, String r\n     }\n   }\n \n-  private ZonedDateTime convertToZonedDateTime(XMLGregorianCalendar cal) {\n-    return cal != null ? cal.toGregorianCalendar().toZonedDateTime() : null;\n-  }\n-\n-  private byte[] decodeAndInflate(String encodedRequest) throws SAMLException {\n-    byte[] bytes = Base64.getMimeDecoder().decode(encodedRequest);\n-    Inflater inflater = new Inflater(true);\n-    inflater.setInput(bytes);\n-    inflater.finished();\n-\n-    try {\n-      ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-      byte[] result = new byte[bytes.length];\n-      while (!inflater.finished()) {\n-        int length = inflater.inflate(result);\n-        if (length > 0) {\n-          baos.write(result, 0, length);\n-        }\n-      }\n-\n-      return baos.toByteArray();\n-    } catch (DataFormatException e) {\n-      throw new SAMLException(\"Invalid AuthnRequest. Inflating the bytes failed.\", e);\n-    }\n-  }\n-\n-  private String deflateAndEncode(byte[] result) {\n-    Deflater deflater = new Deflater(Deflater.DEFLATED, true);\n-    deflater.setInput(result);\n-    deflater.finish();\n-    byte[] deflatedResult = new byte[result.length];\n-    int length = deflater.deflate(deflatedResult);\n-    deflater.end();\n-    byte[] src = Arrays.copyOf(deflatedResult, length);\n-    return Base64.getEncoder().encodeToString(src);\n-  }\n-\n   private void fixIDs(Element element) {\n     NamedNodeMap attributes = element.getAttributes();\n     for (int i = 0; i < attributes.getLength(); i++) {\n@@ -766,42 +699,6 @@ private void fixIDs(Element element) {\n     }\n   }\n \n-  private <T> byte[] marshallToBytes(JAXBElement<T> object, Class<T> type) throws SAMLException {\n-    try {\n-      JAXBContext context = JAXBContext.newInstance(type);\n-      Marshaller marshaller = context.createMarshaller();\n-      ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-      marshaller.marshal(object, baos);\n-      return baos.toByteArray();\n-    } catch (JAXBException e) {\n-      throw new SAMLException(\"Unable to marshallRequest JAXB SAML object to bytes.\", e);\n-    }\n-  }\n-\n-  @SuppressWarnings(\"SameParameterValue\")\n-  private <T> Document marshallToDocument(JAXBElement<T> object, Class<T> type) throws SAMLException {\n-    try {\n-      JAXBContext context = JAXBContext.newInstance(type);\n-      Marshaller marshaller = context.createMarshaller();\n-      DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n-      dbf.setNamespaceAware(true);\n-      DocumentBuilder db = dbf.newDocumentBuilder();\n-      Document document = db.newDocument();\n-      marshaller.marshal(object, document);\n-      return document;\n-    } catch (JAXBException | ParserConfigurationException e) {\n-      throw new SAMLException(\"Unable to marshallRequest JAXB SAML object to DOM.\", e);\n-    }\n-  }\n-\n-  private String marshallToString(Document document) throws TransformerException {\n-    StringWriter sw = new StringWriter();\n-    TransformerFactory tf = TransformerFactory.newInstance();\n-    Transformer transformer = tf.newTransformer();\n-    transformer.transform(new DOMSource(document), new StreamResult(sw));\n-    return sw.toString();\n-  }\n-\n   private SubjectConfirmation parseConfirmation(SubjectConfirmationType subjectConfirmationType) {\n     SubjectConfirmation subjectConfirmation = new SubjectConfirmation();\n     SubjectConfirmationDataType data = subjectConfirmationType.getSubjectConfirmationData();\n@@ -818,32 +715,14 @@ private SubjectConfirmation parseConfirmation(SubjectConfirmationType subjectCon\n     return subjectConfirmation;\n   }\n \n-  private Document parseFromBytes(byte[] bytes) throws SAMLException {\n-    DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n-    documentBuilderFactory.setNamespaceAware(true);\n-    try {\n-      DocumentBuilder builder = documentBuilderFactory.newDocumentBuilder();\n-      return builder.parse(new ByteArrayInputStream(bytes));\n-    } catch (ParserConfigurationException | SAXException | IOException e) {\n-      throw new SAMLException(\"Unable to parse SAML v2.0 authentication response\", e);\n-    }\n-  }\n-\n-  private NameID parseNameId(NameIDType element) {\n-    NameID nameId = new NameID();\n-    nameId.format = NameIDFormat.fromSAMLFormat(element.getFormat());\n-    nameId.id = element.getValue();\n-    return nameId;\n-  }\n-\n   private AuthnRequestParseResult parseRequest(byte[] xmlBytes) throws SAMLException {\n     String xml = new String(xmlBytes, StandardCharsets.UTF_8);\n     if (logger.isDebugEnabled()) {\n       logger.debug(\"SAMLRequest XML is\\n{}\", xml);\n     }\n \n     AuthnRequestParseResult result = new AuthnRequestParseResult();\n-    result.document = parseFromBytes(xmlBytes);\n+    result.document = newDocumentFromBytes(xmlBytes);\n     result.authnRequest = unmarshallFromDocument(result.document, AuthnRequestType.class);\n     result.request = new AuthenticationRequest();\n     result.request.xml = xml;\n@@ -907,60 +786,6 @@ private AuthnRequestType toAuthnRequest(AuthenticationRequest request, String ve\n     return authnRequest;\n   }\n \n-  private Certificate toCertificate(KeyDescriptorType keyDescriptorType) {\n-    try {\n-      List<Object> keyData = keyDescriptorType.getKeyInfo().getContent();\n-      for (Object keyDatum : keyData) {\n-        if (keyDatum instanceof JAXBElement<?>) {\n-          JAXBElement<?> element = (JAXBElement<?>) keyDatum;\n-          if (element.getDeclaredType() == X509DataType.class) {\n-            X509DataType cert = (X509DataType) element.getValue();\n-            List<Object> certData = cert.getX509IssuerSerialOrX509SKIOrX509SubjectName();\n-            for (Object certDatum : certData) {\n-              element = (JAXBElement<?>) certDatum;\n-              if (element.getName().getLocalPart().equals(\"X509Certificate\")) {\n-                byte[] certBytes = (byte[]) element.getValue();\n-                CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n-                return cf.generateCertificate(new ByteArrayInputStream(certBytes));\n-              }\n-            }\n-          }\n-        }\n-      }\n-\n-      return null;\n-    } catch (CertificateException e) {\n-      throw new IllegalArgumentException(e);\n-    }\n-  }\n-\n-  private XMLGregorianCalendar toXMLGregorianCalendar(ZonedDateTime instant) {\n-    if (instant == null) {\n-      return null;\n-    }\n-\n-    return new XMLGregorianCalendarImpl(GregorianCalendar.from(instant));\n-  }\n-\n-  private ZonedDateTime toZonedDateTime(XMLGregorianCalendar instant) {\n-    if (instant == null) {\n-      return null;\n-    }\n-\n-    return instant.toGregorianCalendar().toZonedDateTime();\n-  }\n-\n-  private <T> T unmarshallFromDocument(Document document, Class<T> type) throws SAMLException {\n-    try {\n-      JAXBContext context = JAXBContext.newInstance(type);\n-      Unmarshaller unmarshaller = context.createUnmarshaller();\n-      JAXBElement<T> element = unmarshaller.unmarshal(document, type);\n-      return element.getValue();\n-    } catch (JAXBException e) {\n-      throw new SAMLException(\"Unable to unmarshall SAML response\", e);\n-    }\n-  }\n-\n   private void verifySignature(Document document, KeySelector keySelector) throws SAMLException {\n     // Fix the IDs in the entire document per the suggestions at http://stackoverflow.com/questions/17331187/xml-dig-sig-error-after-upgrade-to-java7u25\n     fixIDs(document.getDocumentElement());",
    "function_modified_lines": {
      "added": [
        "    result.document = newDocumentFromBytes(xmlBytes);\n"
      ],
      "deleted": [
        "  private Document parseFromBytes(byte[] bytes) throws SAMLException {\n",
        "    DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n",
        "    documentBuilderFactory.setNamespaceAware(true);\n",
        "    try {\n",
        "      DocumentBuilder builder = documentBuilderFactory.newDocumentBuilder();\n",
        "      return builder.parse(new ByteArrayInputStream(bytes));\n",
        "    } catch (ParserConfigurationException | SAXException | IOException e) {\n",
        "      throw new SAMLException(\"Unable to parse SAML v2.0 authentication response\", e);\n",
        "    }\n",
        "  }\n",
        "\n",
        "  private NameID parseNameId(NameIDType element) {\n",
        "    NameID nameId = new NameID();\n",
        "    nameId.format = NameIDFormat.fromSAMLFormat(element.getFormat());\n",
        "    nameId.id = element.getValue();\n",
        "    return nameId;\n",
        "  }\n",
        "\n",
        "    result.document = parseFromBytes(xmlBytes);\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "FusionAuth fusionauth-samlv2 before 0.5.4 allows XXE attacks via a forged AuthnRequest or LogoutRequest because parseFromBytes uses javax.xml.parsers.DocumentBuilderFactory unsafely.",
    "id": 12244
  },
  {
    "cve_id": "CVE-2021-33950",
    "code_before_change": "{\n\t\t\tCharArrayWriter writer = new CharArrayWriter();\n\t\t\tExtractorHandler handler = new ExtractorHandler(writer);\n\n\t\t\t// TODO: Use a pull parser to avoid the memory overhead\n\t\t\tSAXParserFactory factory = SAXParserFactory.newInstance();\n\t\t\tSAXParser parser = factory.newSAXParser();\n\t\t\tXMLReader reader = parser.getXMLReader();\n\t\t\treader.setContentHandler(handler);\n\t\t\treader.setErrorHandler(handler);\n\n\t\t\t// It is unspecified whether the XML parser closes the stream when\n\t\t\t// done parsing. To ensure that the stream gets closed just once,\n\t\t\t// we prevent the parser from closing it by catching the close()\n\t\t\t// call and explicitly close the stream in a finally block.\n\t\t\tInputSource source = new InputSource(new FilterInputStream(stream) {\n\t\t\t\tpublic void close() {\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (encoding != null) {\n\t\t\t\ttry {\n\t\t\t\t\tCharset.forName(encoding);\n\t\t\t\t\tsource.setEncoding(encoding);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tlogger.warn(\"Unsupported encoding '{}', using default ({}) instead.\",\n\t\t\t\t\t\t\tnew Object[]{encoding, System.getProperty(\"file.encoding\")});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treader.parse(source);\n\t\t\treturn writer.toString();\n\t\t}",
    "code_after_change": "{\n\t\t\tCharArrayWriter writer = new CharArrayWriter();\n\t\t\tExtractorHandler handler = new ExtractorHandler(writer);\n\n\t\t\t// TODO: Use a pull parser to avoid the memory overhead\n\t\t\tSAXParserFactory factory = SAXParserFactory.newInstance();\n\t\t\tSAXParser parser = factory.newSAXParser();\n\t\t\tXMLReader reader = parser.getXMLReader();\n\t\t\treader.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n\t\t\treader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n\t\t\treader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n\t\t\treader.setFeature(\"http://xml.org/sax/features/validation\", false);\n\t\t\treader.setContentHandler(handler);\n\t\t\treader.setErrorHandler(handler);\n\n\t\t\t// It is unspecified whether the XML parser closes the stream when\n\t\t\t// done parsing. To ensure that the stream gets closed just once,\n\t\t\t// we prevent the parser from closing it by catching the close()\n\t\t\t// call and explicitly close the stream in a finally block.\n\t\t\tInputSource source = new InputSource(new FilterInputStream(stream) {\n\t\t\t\tpublic void close() {\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (encoding != null) {\n\t\t\t\ttry {\n\t\t\t\t\tCharset.forName(encoding);\n\t\t\t\t\tsource.setEncoding(encoding);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tlogger.warn(\"Unsupported encoding '{}', using default ({}) instead.\",\n\t\t\t\t\t\t\tnew Object[]{encoding, System.getProperty(\"file.encoding\")});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treader.parse(source);\n\t\t\treturn writer.toString();\n\t\t}",
    "patch": "@@ -81,6 +81,10 @@ public String extractText(InputStream stream, String type, String encoding) thro\n \t\t\tSAXParserFactory factory = SAXParserFactory.newInstance();\n \t\t\tSAXParser parser = factory.newSAXParser();\n \t\t\tXMLReader reader = parser.getXMLReader();\n+\t\t\treader.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n+\t\t\treader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n+\t\t\treader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n+\t\t\treader.setFeature(\"http://xml.org/sax/features/validation\", false);\n \t\t\treader.setContentHandler(handler);\n \t\t\treader.setErrorHandler(handler);\n ",
    "function_modified_lines": {
      "added": [
        "\t\t\treader.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n",
        "\t\t\treader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n",
        "\t\t\treader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n",
        "\t\t\treader.setFeature(\"http://xml.org/sax/features/validation\", false);\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "An issue discovered in OpenKM v6.3.10 allows attackers to obtain sensitive information via the XMLTextExtractor function.",
    "id": 12497
  },
  {
    "cve_id": "CVE-2022-24898",
    "code_before_change": "\n    /** Regular expression recognizing XML-escaped \"single quote\" characters. */\n    private static final Pattern APOS_PATTERN = Pattern.compile(\"&(?:apos|#0*+39|#x0*+27);\");\n\n    /** XML encoding of the \"double quote\" character. */\n    private static final String QUOT = \"&#34;\";\n\n    /** Regular expression recognizing XML-escaped \"double quote\" characters. */\n    private static final Pattern QUOT_PATTERN = Pattern.compile(\"&(?:quot|#0*+34|#x0*+22);\");\n\n    /** XML encoding of the \"left curly bracket\". */\n    private static final String LCURL = \"&#123;\";\n\n    /** Regular expression recognizing XML-escaped \"left curly bracket\" characters. */\n    private static final Pattern LCURL_PATTERN = Pattern.compile(\"&(?:#0*+123|#x0*+7[bB]);\");\n\n    /** XML encoding of the \"less than\" character. */\n    private static final String LT = \"&#60;\";\n\n    /** Regular expression recognizing XML-escaped \"less than\" characters. */\n    private static final Pattern LT_PATTERN = Pattern.compile(\"&(?:lt|#0*+60|#x0*+3[cC]);\");\n\n    /** XML encoding of the \"greater than\" character. */\n    private static final String GT = \"&#62;\";\n\n    /** Regular expression recognizing XML-escaped \"greater than\" characters. */\n    private static final Pattern GT_PATTERN = Pattern.compile(\"&(?:gt|#0*+62|#x0*+3[eE]);\");\n\n    private static final char[] ELEMENT_SYNTAX = new char[] {'<', '&'};\n\n    /** Helper object for manipulating DOM Level 3 Load and Save APIs. */\n    private static final DOMImplementationLS LS_IMPL;\n\n    /** Xerces configuration parameter for disabling fetching and checking XMLs against their DTD. */\n    private static final String DISABLE_DTD_PARAM = \"http://apache.org/xml/features/nonvalidating/load-external-dtd\";\n\n    static {\n        DOMImplementationLS implementation = null;\n        try {\n            implementation =\n                (DOMImplementationLS) DOMImplementationRegistry.newInstance().getDOMImplementation(\"LS 3.0\");\n        } catch (Exception ex) {\n            LOGGER.warn(\"Cannot initialize the XML Script Service: [{}]\", ex.getMessage());\n        }\n        LS_IMPL = implementation;\n    }\n\n    /**\n     * Private constructor since this is a utility class that shouldn't be instantiated (all methods are static).\n     */\n    private XMLUtils()\n    {\n        // Nothing to do\n    }\n\n    /**\n     * Extracts a well-formed XML fragment from the given DOM tree.\n     *\n     * @param node the root of the DOM tree where the extraction takes place\n     * @param start the index of the first character\n     * @param length the maximum number of characters in text nodes to include in the returned fragment\n     * @return a well-formed XML fragment starting at the given character index and having up to the specified length,\n     *         summing only the characters in text nodes\n     * @since 1.6M2\n     */\n    public static String extractXML(Node node, int start, int length)\n    {\n        ExtractHandler handler = null;\n        try {\n            handler = new ExtractHandler(start, length);\n            Transformer xformer = TransformerFactory.newInstance().newTransformer();\n            xformer.transform(new DOMSource(node), new SAXResult(handler));\n            return handler.getResult();\n        } catch (Throwable t) {",
    "code_after_change": "    private static final Pattern APOS_PATTERN = Pattern.compile(\"&(?:apos|#0*+39|#x0*+27);\");\n\n    /** XML encoding of the \"double quote\" character. */\n    private static final String QUOT = \"&#34;\";\n\n    /** Regular expression recognizing XML-escaped \"double quote\" characters. */\n    private static final Pattern QUOT_PATTERN = Pattern.compile(\"&(?:quot|#0*+34|#x0*+22);\");\n\n    /** XML encoding of the \"left curly bracket\". */\n    private static final String LCURL = \"&#123;\";\n\n    /** Regular expression recognizing XML-escaped \"left curly bracket\" characters. */\n    private static final Pattern LCURL_PATTERN = Pattern.compile(\"&(?:#0*+123|#x0*+7[bB]);\");\n\n    /** XML encoding of the \"less than\" character. */\n    private static final String LT = \"&#60;\";\n\n    /** Regular expression recognizing XML-escaped \"less than\" characters. */\n    private static final Pattern LT_PATTERN = Pattern.compile(\"&(?:lt|#0*+60|#x0*+3[cC]);\");\n\n    /** XML encoding of the \"greater than\" character. */\n    private static final String GT = \"&#62;\";\n\n    /** Regular expression recognizing XML-escaped \"greater than\" characters. */\n    private static final Pattern GT_PATTERN = Pattern.compile(\"&(?:gt|#0*+62|#x0*+3[eE]);\");\n\n    private static final char[] ELEMENT_SYNTAX = new char[] {'<', '&'};\n\n    /** Helper object for manipulating DOM Level 3 Load and Save APIs. */\n    private static final DOMImplementationLS LS_IMPL;\n\n    /** Xerces configuration parameter for disabling fetching and checking XMLs against their DTD. */\n    private static final String DISABLE_DTD_PARAM = \"http://apache.org/xml/features/nonvalidating/load-external-dtd\";\n\n    /** Xerces configuration parameter for prevent DOCTYPE definition. */\n    private static final String DISABLE_EXTERNAL_DOCTYPE_DECLARATION =\n        \"http://apache.org/xml/features/disallow-doctype-decl\";\n\n    /** Xerces configuration parameter for disabling inserting entities defined in external files. */\n    private static final String DISABLE_EXTERNAL_PARAMETER_ENTITIES =\n        \"http://xml.org/sax/features/external-parameter-entities\";\n\n    /** Xerces configuration parameter for disabling inserting entities defined in external files. */\n    private static final String DISABLE_EXTERNAL_GENERAL_ENTITIES =\n        \"http://xml.org/sax/features/external-general-entities\";\n\n    static {\n        DOMImplementationLS implementation = null;\n        try {\n            implementation =\n                (DOMImplementationLS) DOMImplementationRegistry.newInstance().getDOMImplementation(\"LS 3.0\");\n        } catch (Exception ex) {\n            LOGGER.warn(\"Cannot initialize the XML Script Service: [{}]\", ex.getMessage());\n        }\n        LS_IMPL = implementation;\n    }\n\n    /**\n     * Private constructor since this is a utility class that shouldn't be instantiated (all methods are static).\n     */\n    private XMLUtils()\n    {\n        // Nothing to do\n    }\n\n    /**\n     * Extracts a well-formed XML fragment from the given DOM tree.\n     *\n     * @param node the root of the DOM tree where the extraction takes place\n     * @param start the index of the first character\n     * @param length the maximum number of characters in text nodes to include in the returned fragment\n     * @return a well-formed XML fragment starting at the given character index and having up to the specified length,\n     *         summing only the characters in text nodes\n     * @since 1.6M2\n     */\n    public static String extractXML(Node node, int start, int length)\n    {\n        ExtractHandler handler = null;\n        try {\n            handler = new ExtractHandler(start, length);\n            Transformer xformer = TransformerFactory.newInstance().newTransformer();\n            xformer.transform(new DOMSource(node), new SAXResult(handler));",
    "patch": "@@ -110,6 +110,18 @@ public final class XMLUtils\n     /** Xerces configuration parameter for disabling fetching and checking XMLs against their DTD. */\n     private static final String DISABLE_DTD_PARAM = \"http://apache.org/xml/features/nonvalidating/load-external-dtd\";\n \n+    /** Xerces configuration parameter for prevent DOCTYPE definition. */\n+    private static final String DISABLE_EXTERNAL_DOCTYPE_DECLARATION =\n+        \"http://apache.org/xml/features/disallow-doctype-decl\";\n+\n+    /** Xerces configuration parameter for disabling inserting entities defined in external files. */\n+    private static final String DISABLE_EXTERNAL_PARAMETER_ENTITIES =\n+        \"http://xml.org/sax/features/external-parameter-entities\";\n+\n+    /** Xerces configuration parameter for disabling inserting entities defined in external files. */\n+    private static final String DISABLE_EXTERNAL_GENERAL_ENTITIES =\n+        \"http://xml.org/sax/features/external-general-entities\";\n+\n     static {\n         DOMImplementationLS implementation = null;\n         try {\n@@ -516,6 +528,17 @@ public static Document parse(LSInput source)\n             if (p.getDomConfig().canSetParameter(DISABLE_DTD_PARAM, false)) {\n                 p.getDomConfig().setParameter(DISABLE_DTD_PARAM, false);\n             }\n+\n+            // Avoid XML eXternal Entity injection (XXE)\n+            if (p.getDomConfig().canSetParameter(DISABLE_EXTERNAL_DOCTYPE_DECLARATION, false)) {\n+                p.getDomConfig().setParameter(DISABLE_EXTERNAL_DOCTYPE_DECLARATION, false);\n+            }\n+            if (p.getDomConfig().canSetParameter(DISABLE_EXTERNAL_PARAMETER_ENTITIES, false)) {\n+                p.getDomConfig().setParameter(DISABLE_EXTERNAL_PARAMETER_ENTITIES, false);\n+            }\n+            if (p.getDomConfig().canSetParameter(DISABLE_EXTERNAL_GENERAL_ENTITIES, false)) {\n+                p.getDomConfig().setParameter(DISABLE_EXTERNAL_GENERAL_ENTITIES, false);\n+            }\n             return p.parse(source);\n         } catch (Exception ex) {\n             LOGGER.warn(\"Cannot parse XML document: [{}]\", ex.getMessage());",
    "function_modified_lines": {
      "added": [
        "    /** Xerces configuration parameter for prevent DOCTYPE definition. */\n",
        "    private static final String DISABLE_EXTERNAL_DOCTYPE_DECLARATION =\n",
        "        \"http://apache.org/xml/features/disallow-doctype-decl\";\n",
        "\n",
        "    /** Xerces configuration parameter for disabling inserting entities defined in external files. */\n",
        "    private static final String DISABLE_EXTERNAL_PARAMETER_ENTITIES =\n",
        "        \"http://xml.org/sax/features/external-parameter-entities\";\n",
        "\n",
        "    /** Xerces configuration parameter for disabling inserting entities defined in external files. */\n",
        "    private static final String DISABLE_EXTERNAL_GENERAL_ENTITIES =\n",
        "        \"http://xml.org/sax/features/external-general-entities\";\n",
        "\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "org.xwiki.commons:xwiki-commons-xml is a common module used by other XWiki top level projects. Starting in version 2.7 and prior to versions 12.10.10, 13.4.4, and 13.8-rc-1, it is possible for a script to access any file accessing to the user running XWiki application server with XML External Entity Injection through the XML script service. The problem has been patched in versions 12.10.10, 13.4.4, and 13.8-rc-1. There is no easy workaround for fixing this vulnerability other than upgrading and being careful when giving Script rights.",
    "id": 12601
  },
  {
    "cve_id": "CVE-2022-24898",
    "code_before_change": "try {\n            LSParser p = LS_IMPL.createLSParser(DOMImplementationLS.MODE_SYNCHRONOUS, null);\n            // Disable validation, since this takes a lot of time and causes unneeded network traffic\n            p.getDomConfig().setParameter(\"validate\", false);\n            if (p.getDomConfig().canSetParameter(DISABLE_DTD_PARAM, false)) {\n                p.getDomConfig().setParameter(DISABLE_DTD_PARAM, false);\n            }\n            return p.parse(source);\n        } catch (Exception ex) {\n            LOGGER.warn(\"Cannot parse XML document: [{}]\", ex.getMessage());\n            return null;\n        }",
    "code_after_change": "{\n            LSParser p = LS_IMPL.createLSParser(DOMImplementationLS.MODE_SYNCHRONOUS, null);\n            // Disable validation, since this takes a lot of time and causes unneeded network traffic\n            p.getDomConfig().setParameter(\"validate\", false);\n            if (p.getDomConfig().canSetParameter(DISABLE_DTD_PARAM, false)) {\n                p.getDomConfig().setParameter(DISABLE_DTD_PARAM, false);\n            }\n\n            // Avoid XML eXternal Entity injection (XXE)\n            if (p.getDomConfig().canSetParameter(DISABLE_EXTERNAL_DOCTYPE_DECLARATION, false)) {\n                p.getDomConfig().setParameter(DISABLE_EXTERNAL_DOCTYPE_DECLARATION, false);\n            }\n            if (p.getDomConfig().canSetParameter(DISABLE_EXTERNAL_PARAMETER_ENTITIES, false)) {\n                p.getDomConfig().setParameter(DISABLE_EXTERNAL_PARAMETER_ENTITIES, false);\n            }\n            if (p.getDomConfig().canSetParameter(DISABLE_EXTERNAL_GENERAL_ENTITIES, false)) {\n                p.getDomConfig().setParameter(DISABLE_EXTERNAL_GENERAL_ENTITIES, false);\n            }\n            return p.parse(source);\n        }",
    "patch": "@@ -110,6 +110,18 @@ public final class XMLUtils\n     /** Xerces configuration parameter for disabling fetching and checking XMLs against their DTD. */\n     private static final String DISABLE_DTD_PARAM = \"http://apache.org/xml/features/nonvalidating/load-external-dtd\";\n \n+    /** Xerces configuration parameter for prevent DOCTYPE definition. */\n+    private static final String DISABLE_EXTERNAL_DOCTYPE_DECLARATION =\n+        \"http://apache.org/xml/features/disallow-doctype-decl\";\n+\n+    /** Xerces configuration parameter for disabling inserting entities defined in external files. */\n+    private static final String DISABLE_EXTERNAL_PARAMETER_ENTITIES =\n+        \"http://xml.org/sax/features/external-parameter-entities\";\n+\n+    /** Xerces configuration parameter for disabling inserting entities defined in external files. */\n+    private static final String DISABLE_EXTERNAL_GENERAL_ENTITIES =\n+        \"http://xml.org/sax/features/external-general-entities\";\n+\n     static {\n         DOMImplementationLS implementation = null;\n         try {\n@@ -516,6 +528,17 @@ public static Document parse(LSInput source)\n             if (p.getDomConfig().canSetParameter(DISABLE_DTD_PARAM, false)) {\n                 p.getDomConfig().setParameter(DISABLE_DTD_PARAM, false);\n             }\n+\n+            // Avoid XML eXternal Entity injection (XXE)\n+            if (p.getDomConfig().canSetParameter(DISABLE_EXTERNAL_DOCTYPE_DECLARATION, false)) {\n+                p.getDomConfig().setParameter(DISABLE_EXTERNAL_DOCTYPE_DECLARATION, false);\n+            }\n+            if (p.getDomConfig().canSetParameter(DISABLE_EXTERNAL_PARAMETER_ENTITIES, false)) {\n+                p.getDomConfig().setParameter(DISABLE_EXTERNAL_PARAMETER_ENTITIES, false);\n+            }\n+            if (p.getDomConfig().canSetParameter(DISABLE_EXTERNAL_GENERAL_ENTITIES, false)) {\n+                p.getDomConfig().setParameter(DISABLE_EXTERNAL_GENERAL_ENTITIES, false);\n+            }\n             return p.parse(source);\n         } catch (Exception ex) {\n             LOGGER.warn(\"Cannot parse XML document: [{}]\", ex.getMessage());",
    "function_modified_lines": {
      "added": [
        "\n",
        "            // Avoid XML eXternal Entity injection (XXE)\n",
        "            if (p.getDomConfig().canSetParameter(DISABLE_EXTERNAL_DOCTYPE_DECLARATION, false)) {\n",
        "                p.getDomConfig().setParameter(DISABLE_EXTERNAL_DOCTYPE_DECLARATION, false);\n",
        "            }\n",
        "            if (p.getDomConfig().canSetParameter(DISABLE_EXTERNAL_PARAMETER_ENTITIES, false)) {\n",
        "                p.getDomConfig().setParameter(DISABLE_EXTERNAL_PARAMETER_ENTITIES, false);\n",
        "            }\n",
        "            if (p.getDomConfig().canSetParameter(DISABLE_EXTERNAL_GENERAL_ENTITIES, false)) {\n",
        "                p.getDomConfig().setParameter(DISABLE_EXTERNAL_GENERAL_ENTITIES, false);\n",
        "            }\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "org.xwiki.commons:xwiki-commons-xml is a common module used by other XWiki top level projects. Starting in version 2.7 and prior to versions 12.10.10, 13.4.4, and 13.8-rc-1, it is possible for a script to access any file accessing to the user running XWiki application server with XML External Entity Injection through the XML script service. The problem has been patched in versions 12.10.10, 13.4.4, and 13.8-rc-1. There is no easy workaround for fixing this vulnerability other than upgrading and being careful when giving Script rights.",
    "id": 12602
  },
  {
    "cve_id": "CVE-2022-41967",
    "code_before_change": "/*\n * Dragonfly - Runtime dependency management library\n *  Copyright (c) 2021 Joshua Sing <joshua@hypera.dev>\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"Software\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in all\n *  copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *  SOFTWARE.\n */\n\npackage dev.hypera.dragonfly;\n\nimport dev.hypera.dragonfly.dependency.Dependency;\nimport dev.hypera.dragonfly.downloaders.DependencyDownloader;\nimport dev.hypera.dragonfly.loading.DependencyLoader;\nimport dev.hypera.dragonfly.loading.IClassLoader;\nimport dev.hypera.dragonfly.objects.Status;\nimport dev.hypera.dragonfly.relocation.DependencyRelocator;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.function.Consumer;\nimport java.util.stream.Collectors;\nimport org.jetbrains.annotations.ApiStatus.Internal;\n\n/**\n * Main Dragonfly class.\n * @author Joshua Sing <joshua@hypera.dev>\n */\npublic class Dragonfly {\n\n\tprivate static final String VERSION = \"0.3.0-SNAPSHOT\";\n\n\tprivate final int timeout;\n\tprivate final Path directory;\n\tprivate final Set<String> repositories;\n\tprivate final Consumer<Status> statusHandler;\n\n\tprivate final DependencyDownloader dependencyDownloader = new DependencyDownloader(this);\n\tprivate final DependencyRelocator dependencyRelocator;\n\tprivate final DependencyLoader dependencyLoader;\n\n\n\t@Internal\n\tprotected Dragonfly(int timeout, IClassLoader classLoader, Path directory, Set<String> repositories, boolean delete, Consumer<Status> statusHandler) throws IOException {\n\t\tthis.timeout = timeout;\n\t\tthis.directory = directory;\n\t\tthis.repositories = repositories;\n\t\tthis.statusHandler = statusHandler;\n\n\t\tthis.dependencyRelocator = new DependencyRelocator(this, delete);\n\t\tthis.dependencyLoader = new DependencyLoader(this, classLoader);\n\n\t\tif (!Files.exists(directory)) {\n\t\t\tFiles.createDirectories(directory);\n\t\t}\n\t}\n\n\tpublic static String getVersion() {\n\t\treturn VERSION;\n\t}\n\n\t/**\n\t * Download, relocate and load dependencies.\n\t *\n\t * @param dependencies Dependencies to be loaded.\n\t * @return If the load was successful, in the form of a {@link CompletableFuture<Boolean>}.\n\t */\n\tpublic CompletableFuture<Boolean> load(Dependency... dependencies) {\n\t\treturn CompletableFuture.supplyAsync(() -> {\n\t\t\ttry {\n\t\t\t\tstatusHandler.accept(Status.STARTING);\n\t\t\t\tList<Dependency> dependencyList = Arrays.stream(dependencies)\n\t\t\t\t\t\t.sorted(Comparator.comparingInt(Dependency::getPriority)).collect(Collectors.toList());\n\n\t\t\t\tif (dependencyList.size() > 0) {\n\t\t\t\t\tList<Dependency> downloadList = dependencyList.stream().filter(d -> !isDownloaded(d))\n\t\t\t\t\t\t\t.collect(Collectors.toList());\n\t\t\t\t\tif (downloadList.size() > 0) {\n\t\t\t\t\t\tstatusHandler.accept(Status.DOWNLOADING);\n\t\t\t\t\t\tdependencyDownloader.download(downloadList);\n\n\t\t\t\t\t\tif (downloadList.stream().anyMatch(d -> d.getRelocations().size() > 0)) {\n\t\t\t\t\t\t\tstatusHandler.accept(Status.RELOCATING);\n\t\t\t\t\t\t\tdependencyRelocator.relocate(downloadList);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tdependencyList.stream().filter(d -> d.getRelocations().size() > 0 && !d.isRelocated())\n\t\t\t\t\t\t\t.forEach(d -> d.setFileName(dependencyRelocator.getRelocatedFileName(d)));\n\n\t\t\t\t\tstatusHandler.accept(Status.LOADING);\n\t\t\t\t\tdependencyLoader.load(dependencyList);\n\t\t\t\t}\n\n\t\t\t\tstatusHandler.accept(Status.FINISHED);\n\t\t\t\treturn true;\n\t\t\t} catch (Exception ex) {\n\t\t\t\tthrow new IllegalStateException(ex);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * If a dependency has been downloaded or not.\n\t *\n\t * @param dependency Dependency.\n\t * @return If the given dependency has been downloaded or not.\n\t */\n\tprivate boolean isDownloaded(Dependency dependency) {\n\t\tif (dependencyRelocator.isRelocated(dependency)) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn Files.exists(directory.resolve(dependency.getFileName()));\n\t\t}\n\t}\n\n\tpublic int getTimeout() {\n\t\treturn timeout;\n\t}\n\n\tpublic Path getDirectory() {\n\t\treturn directory;\n\t}\n\n\tpublic Set<String> getRepositories() {\n\t\treturn repositories;\n\t}\n\n\t/**\n\t * Get {@link DependencyDownloader}, for internal use only.\n\t *\n\t * @return Stored instance of {@link DependencyDownloader}.\n\t */\n\t@Internal\n\tpublic DependencyDownloader getDependencyDownloader() {\n\t\treturn dependencyDownloader;\n\t}\n\n}\n",
    "code_after_change": "/*\n * Dragonfly - Runtime dependency management library\n *  Copyright (c) 2021 Joshua Sing <joshua@hypera.dev>\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"Software\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in all\n *  copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *  SOFTWARE.\n */\n\npackage dev.hypera.dragonfly;\n\nimport dev.hypera.dragonfly.dependency.Dependency;\nimport dev.hypera.dragonfly.downloaders.DependencyDownloader;\nimport dev.hypera.dragonfly.loading.DependencyLoader;\nimport dev.hypera.dragonfly.loading.IClassLoader;\nimport dev.hypera.dragonfly.objects.Status;\nimport dev.hypera.dragonfly.relocation.DependencyRelocator;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.function.Consumer;\nimport java.util.stream.Collectors;\nimport org.jetbrains.annotations.ApiStatus.Internal;\nimport org.jetbrains.annotations.NotNull;\n\n/**\n * Main Dragonfly class.\n * @author Joshua Sing <joshua@hypera.dev>\n */\npublic class Dragonfly {\n\n\tprivate static final @NotNull String VERSION = \"0.3.1-SNAPSHOT\";\n\n\tprivate final int timeout;\n\tprivate final @NotNull Path directory;\n\tprivate final @NotNull Set<String> repositories;\n\tprivate final @NotNull Consumer<Status> statusHandler;\n\n\tprivate final @NotNull DependencyDownloader dependencyDownloader = new DependencyDownloader(this);\n\tprivate final @NotNull DependencyRelocator dependencyRelocator;\n\tprivate final @NotNull DependencyLoader dependencyLoader;\n\n\n\t@Internal\n\tprotected Dragonfly(int timeout, IClassLoader classLoader, Path directory, Set<String> repositories, boolean delete, Consumer<Status> statusHandler) throws IOException {\n\t\tthis.timeout = timeout;\n\t\tthis.directory = directory;\n\t\tthis.repositories = repositories;\n\t\tthis.statusHandler = statusHandler;\n\n\t\tthis.dependencyRelocator = new DependencyRelocator(this, delete);\n\t\tthis.dependencyLoader = new DependencyLoader(this, classLoader);\n\n\t\tif (!Files.exists(directory)) {\n\t\t\tFiles.createDirectories(directory);\n\t\t}\n\t}\n\n\tpublic static @NotNull String getVersion() {\n\t\treturn VERSION;\n\t}\n\n\t/**\n\t * Download, relocate and load dependencies.\n\t *\n\t * @param dependencies Dependencies to be loaded.\n\t * @return If the load was successful, in the form of a {@link CompletableFuture<Boolean>}.\n\t */\n\tpublic @NotNull CompletableFuture<Boolean> load(@NotNull Dependency... dependencies) {\n\t\treturn CompletableFuture.supplyAsync(() -> {\n\t\t\ttry {\n\t\t\t\tstatusHandler.accept(Status.STARTING);\n\t\t\t\tList<Dependency> dependencyList = Arrays.stream(dependencies)\n\t\t\t\t\t\t.sorted(Comparator.comparingInt(Dependency::getPriority)).collect(Collectors.toList());\n\n\t\t\t\tif (dependencyList.size() > 0) {\n\t\t\t\t\tList<Dependency> downloadList = dependencyList.stream().filter(d -> !isDownloaded(d))\n\t\t\t\t\t\t\t.collect(Collectors.toList());\n\t\t\t\t\tif (downloadList.size() > 0) {\n\t\t\t\t\t\tstatusHandler.accept(Status.DOWNLOADING);\n\t\t\t\t\t\tdependencyDownloader.download(downloadList);\n\n\t\t\t\t\t\tif (downloadList.stream().anyMatch(d -> d.getRelocations().size() > 0)) {\n\t\t\t\t\t\t\tstatusHandler.accept(Status.RELOCATING);\n\t\t\t\t\t\t\tdependencyRelocator.relocate(downloadList);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tdependencyList.stream().filter(d -> d.getRelocations().size() > 0 && !d.isRelocated())\n\t\t\t\t\t\t\t.forEach(d -> d.setFileName(dependencyRelocator.getRelocatedFileName(d)));\n\n\t\t\t\t\tstatusHandler.accept(Status.LOADING);\n\t\t\t\t\tdependencyLoader.load(dependencyList);\n\t\t\t\t}\n\n\t\t\t\tstatusHandler.accept(Status.FINISHED);\n\t\t\t\treturn true;\n\t\t\t} catch (Exception ex) {\n\t\t\t\tthrow new IllegalStateException(ex);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * If a dependency has been downloaded or not.\n\t *\n\t * @param dependency Dependency.\n\t * @return If the given dependency has been downloaded or not.\n\t */\n\tprivate boolean isDownloaded(Dependency dependency) {\n\t\tif (dependencyRelocator.isRelocated(dependency)) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn Files.exists(directory.resolve(dependency.getFileName()));\n\t\t}\n\t}\n\n\tpublic int getTimeout() {\n\t\treturn timeout;\n\t}\n\n\tpublic @NotNull Path getDirectory() {\n\t\treturn directory;\n\t}\n\n\tpublic @NotNull Set<String> getRepositories() {\n\t\treturn repositories;\n\t}\n\n\t/**\n\t * Get {@link DependencyDownloader}, for internal use only.\n\t *\n\t * @return Stored instance of {@link DependencyDownloader}.\n\t */\n\t@Internal\n\tpublic @NotNull DependencyDownloader getDependencyDownloader() {\n\t\treturn dependencyDownloader;\n\t}\n\n}\n",
    "patch": "@@ -40,23 +40,24 @@\n import java.util.function.Consumer;\n import java.util.stream.Collectors;\n import org.jetbrains.annotations.ApiStatus.Internal;\n+import org.jetbrains.annotations.NotNull;\n \n /**\n  * Main Dragonfly class.\n  * @author Joshua Sing <joshua@hypera.dev>\n  */\n public class Dragonfly {\n \n-\tprivate static final String VERSION = \"0.3.0-SNAPSHOT\";\n+\tprivate static final @NotNull String VERSION = \"0.3.1-SNAPSHOT\";\n \n \tprivate final int timeout;\n-\tprivate final Path directory;\n-\tprivate final Set<String> repositories;\n-\tprivate final Consumer<Status> statusHandler;\n+\tprivate final @NotNull Path directory;\n+\tprivate final @NotNull Set<String> repositories;\n+\tprivate final @NotNull Consumer<Status> statusHandler;\n \n-\tprivate final DependencyDownloader dependencyDownloader = new DependencyDownloader(this);\n-\tprivate final DependencyRelocator dependencyRelocator;\n-\tprivate final DependencyLoader dependencyLoader;\n+\tprivate final @NotNull DependencyDownloader dependencyDownloader = new DependencyDownloader(this);\n+\tprivate final @NotNull DependencyRelocator dependencyRelocator;\n+\tprivate final @NotNull DependencyLoader dependencyLoader;\n \n \n \t@Internal\n@@ -74,7 +75,7 @@ protected Dragonfly(int timeout, IClassLoader classLoader, Path directory, Set<S\n \t\t}\n \t}\n \n-\tpublic static String getVersion() {\n+\tpublic static @NotNull String getVersion() {\n \t\treturn VERSION;\n \t}\n \n@@ -84,7 +85,7 @@ public static String getVersion() {\n \t * @param dependencies Dependencies to be loaded.\n \t * @return If the load was successful, in the form of a {@link CompletableFuture<Boolean>}.\n \t */\n-\tpublic CompletableFuture<Boolean> load(Dependency... dependencies) {\n+\tpublic @NotNull CompletableFuture<Boolean> load(@NotNull Dependency... dependencies) {\n \t\treturn CompletableFuture.supplyAsync(() -> {\n \t\t\ttry {\n \t\t\t\tstatusHandler.accept(Status.STARTING);\n@@ -137,11 +138,11 @@ public int getTimeout() {\n \t\treturn timeout;\n \t}\n \n-\tpublic Path getDirectory() {\n+\tpublic @NotNull Path getDirectory() {\n \t\treturn directory;\n \t}\n \n-\tpublic Set<String> getRepositories() {\n+\tpublic @NotNull Set<String> getRepositories() {\n \t\treturn repositories;\n \t}\n \n@@ -151,7 +152,7 @@ public Set<String> getRepositories() {\n \t * @return Stored instance of {@link DependencyDownloader}.\n \t */\n \t@Internal\n-\tpublic DependencyDownloader getDependencyDownloader() {\n+\tpublic @NotNull DependencyDownloader getDependencyDownloader() {\n \t\treturn dependencyDownloader;\n \t}\n ",
    "function_modified_lines": {
      "added": [
        "import org.jetbrains.annotations.NotNull;\n",
        "\tprivate static final @NotNull String VERSION = \"0.3.1-SNAPSHOT\";\n",
        "\tprivate final @NotNull Path directory;\n",
        "\tprivate final @NotNull Set<String> repositories;\n",
        "\tprivate final @NotNull Consumer<Status> statusHandler;\n",
        "\tprivate final @NotNull DependencyDownloader dependencyDownloader = new DependencyDownloader(this);\n",
        "\tprivate final @NotNull DependencyRelocator dependencyRelocator;\n",
        "\tprivate final @NotNull DependencyLoader dependencyLoader;\n"
      ],
      "deleted": [
        "\tprivate static final String VERSION = \"0.3.0-SNAPSHOT\";\n",
        "\tprivate final Path directory;\n",
        "\tprivate final Set<String> repositories;\n",
        "\tprivate final Consumer<Status> statusHandler;\n",
        "\tprivate final DependencyDownloader dependencyDownloader = new DependencyDownloader(this);\n",
        "\tprivate final DependencyRelocator dependencyRelocator;\n",
        "\tprivate final DependencyLoader dependencyLoader;\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "Dragonfly is a Java runtime dependency management library. Dragonfly v0.3.0-SNAPSHOT does not configure DocumentBuilderFactory to prevent XML external entity (XXE) attacks. This issue is patched in 0.3.1-SNAPSHOT. As a workaround, since Dragonfly only parses XML `SNAPSHOT` versions are being resolved, this vulnerability may be avoided by not trying to resolve `SNAPSHOT` versions.",
    "id": 12668
  },
  {
    "cve_id": "CVE-2022-41967",
    "code_before_change": "{\n\n\tprivate static final String VERSION = \"0.3.0-SNAPSHOT\";\n\n\tprivate final int timeout;\n\tprivate final Path directory;\n\tprivate final Set<String> repositories;\n\tprivate final Consumer<Status> statusHandler;\n\n\tprivate final DependencyDownloader dependencyDownloader = new DependencyDownloader(this);\n\tprivate final DependencyRelocator dependencyRelocator;\n\tprivate final DependencyLoader dependencyLoader;\n\n\n\t@Internal\n\tprotected Dragonfly(int timeout, IClassLoader classLoader, Path directory, Set<String> repositories, boolean delete, Consumer<Status> statusHandler) throws IOException {\n\t\tthis.timeout = timeout;\n\t\tthis.directory = directory;\n\t\tthis.repositories = repositories;\n\t\tthis.statusHandler = statusHandler;\n\n\t\tthis.dependencyRelocator = new DependencyRelocator(this, delete);\n\t\tthis.dependencyLoader = new DependencyLoader(this, classLoader);\n\n\t\tif (!Files.exists(directory)) {\n\t\t\tFiles.createDirectories(directory);\n\t\t}\n\t}\n\n\tpublic static String getVersion() {\n\t\treturn VERSION;\n\t}\n\n\t/**\n\t * Download, relocate and load dependencies.\n\t *\n\t * @param dependencies Dependencies to be loaded.\n\t * @return If the load was successful, in the form of a {@link CompletableFuture<Boolean>}.\n\t */\n\tpublic CompletableFuture<Boolean> load(Dependency... dependencies) {\n\t\treturn CompletableFuture.supplyAsync(() -> {\n\t\t\ttry {\n\t\t\t\tstatusHandler.accept(Status.STARTING);\n\t\t\t\tList<Dependency> dependencyList = Arrays.stream(dependencies)\n\t\t\t\t\t\t.sorted(Comparator.comparingInt(Dependency::getPriority)).collect(Collectors.toList());\n\n\t\t\t\tif (dependencyList.size() > 0) {\n\t\t\t\t\tList<Dependency> downloadList = dependencyList.stream().filter(d -> !isDownloaded(d))\n\t\t\t\t\t\t\t.collect(Collectors.toList());\n\t\t\t\t\tif (downloadList.size() > 0) {\n\t\t\t\t\t\tstatusHandler.accept(Status.DOWNLOADING);\n\t\t\t\t\t\tdependencyDownloader.download(downloadList);\n\n\t\t\t\t\t\tif (downloadList.stream().anyMatch(d -> d.getRelocations().size() > 0)) {\n\t\t\t\t\t\t\tstatusHandler.accept(Status.RELOCATING);\n\t\t\t\t\t\t\tdependencyRelocator.relocate(downloadList);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tdependencyList.stream().filter(d -> d.getRelocations().size() > 0 && !d.isRelocated())\n\t\t\t\t\t\t\t.forEach(d -> d.setFileName(dependencyRelocator.getRelocatedFileName(d)));\n\n\t\t\t\t\tstatusHandler.accept(Status.LOADING);\n\t\t\t\t\tdependencyLoader.load(dependencyList);\n\t\t\t\t}\n\n\t\t\t\tstatusHandler.accept(Status.FINISHED);\n\t\t\t\treturn true;\n\t\t\t} catch (Exception ex) {\n\t\t\t\tthrow new IllegalStateException(ex);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * If a dependency has been downloaded or not.\n\t *\n\t * @param dependency Dependency.\n\t * @return If the given dependency has been downloaded or not.\n\t */\n\tprivate boolean isDownloaded(Dependency dependency) {\n\t\tif (dependencyRelocator.isRelocated(dependency)) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn Files.exists(directory.resolve(dependency.getFileName()));\n\t\t}\n\t}\n\n\tpublic int getTimeout() {\n\t\treturn timeout;\n\t}\n\n\tpublic Path getDirectory() {\n\t\treturn directory;\n\t}\n\n\tpublic Set<String> getRepositories() {\n\t\treturn repositories;\n\t}\n\n\t/**\n\t * Get {@link DependencyDownloader}, for internal use only.\n\t *\n\t * @return Stored instance of {@link DependencyDownloader}.\n\t */\n\t@Internal\n\tpublic DependencyDownloader getDependencyDownloader() {\n\t\treturn dependencyDownloader;\n\t}\n\n}",
    "code_after_change": "{\n\n\tprivate static final @NotNull String VERSION = \"0.3.1-SNAPSHOT\";\n\n\tprivate final int timeout;\n\tprivate final @NotNull Path directory;\n\tprivate final @NotNull Set<String> repositories;\n\tprivate final @NotNull Consumer<Status> statusHandler;\n\n\tprivate final @NotNull DependencyDownloader dependencyDownloader = new DependencyDownloader(this);\n\tprivate final @NotNull DependencyRelocator dependencyRelocator;\n\tprivate final @NotNull DependencyLoader dependencyLoader;\n\n\n\t@Internal\n\tprotected Dragonfly(int timeout, IClassLoader classLoader, Path directory, Set<String> repositories, boolean delete, Consumer<Status> statusHandler) throws IOException {\n\t\tthis.timeout = timeout;\n\t\tthis.directory = directory;\n\t\tthis.repositories = repositories;\n\t\tthis.statusHandler = statusHandler;\n\n\t\tthis.dependencyRelocator = new DependencyRelocator(this, delete);\n\t\tthis.dependencyLoader = new DependencyLoader(this, classLoader);\n\n\t\tif (!Files.exists(directory)) {\n\t\t\tFiles.createDirectories(directory);\n\t\t}\n\t}\n\n\tpublic static @NotNull String getVersion() {\n\t\treturn VERSION;\n\t}\n\n\t/**\n\t * Download, relocate and load dependencies.\n\t *\n\t * @param dependencies Dependencies to be loaded.\n\t * @return If the load was successful, in the form of a {@link CompletableFuture<Boolean>}.\n\t */\n\tpublic @NotNull CompletableFuture<Boolean> load(@NotNull Dependency... dependencies) {\n\t\treturn CompletableFuture.supplyAsync(() -> {\n\t\t\ttry {\n\t\t\t\tstatusHandler.accept(Status.STARTING);\n\t\t\t\tList<Dependency> dependencyList = Arrays.stream(dependencies)\n\t\t\t\t\t\t.sorted(Comparator.comparingInt(Dependency::getPriority)).collect(Collectors.toList());\n\n\t\t\t\tif (dependencyList.size() > 0) {\n\t\t\t\t\tList<Dependency> downloadList = dependencyList.stream().filter(d -> !isDownloaded(d))\n\t\t\t\t\t\t\t.collect(Collectors.toList());\n\t\t\t\t\tif (downloadList.size() > 0) {\n\t\t\t\t\t\tstatusHandler.accept(Status.DOWNLOADING);\n\t\t\t\t\t\tdependencyDownloader.download(downloadList);\n\n\t\t\t\t\t\tif (downloadList.stream().anyMatch(d -> d.getRelocations().size() > 0)) {\n\t\t\t\t\t\t\tstatusHandler.accept(Status.RELOCATING);\n\t\t\t\t\t\t\tdependencyRelocator.relocate(downloadList);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tdependencyList.stream().filter(d -> d.getRelocations().size() > 0 && !d.isRelocated())\n\t\t\t\t\t\t\t.forEach(d -> d.setFileName(dependencyRelocator.getRelocatedFileName(d)));\n\n\t\t\t\t\tstatusHandler.accept(Status.LOADING);\n\t\t\t\t\tdependencyLoader.load(dependencyList);\n\t\t\t\t}\n\n\t\t\t\tstatusHandler.accept(Status.FINISHED);\n\t\t\t\treturn true;\n\t\t\t} catch (Exception ex) {\n\t\t\t\tthrow new IllegalStateException(ex);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * If a dependency has been downloaded or not.\n\t *\n\t * @param dependency Dependency.\n\t * @return If the given dependency has been downloaded or not.\n\t */\n\tprivate boolean isDownloaded(Dependency dependency) {\n\t\tif (dependencyRelocator.isRelocated(dependency)) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn Files.exists(directory.resolve(dependency.getFileName()));\n\t\t}\n\t}\n\n\tpublic int getTimeout() {\n\t\treturn timeout;\n\t}\n\n\tpublic @NotNull Path getDirectory() {\n\t\treturn directory;\n\t}\n\n\tpublic @NotNull Set<String> getRepositories() {\n\t\treturn repositories;\n\t}\n\n\t/**\n\t * Get {@link DependencyDownloader}, for internal use only.\n\t *\n\t * @return Stored instance of {@link DependencyDownloader}.\n\t */\n\t@Internal\n\tpublic @NotNull DependencyDownloader getDependencyDownloader() {\n\t\treturn dependencyDownloader;\n\t}\n\n}",
    "patch": "@@ -40,23 +40,24 @@\n import java.util.function.Consumer;\n import java.util.stream.Collectors;\n import org.jetbrains.annotations.ApiStatus.Internal;\n+import org.jetbrains.annotations.NotNull;\n \n /**\n  * Main Dragonfly class.\n  * @author Joshua Sing <joshua@hypera.dev>\n  */\n public class Dragonfly {\n \n-\tprivate static final String VERSION = \"0.3.0-SNAPSHOT\";\n+\tprivate static final @NotNull String VERSION = \"0.3.1-SNAPSHOT\";\n \n \tprivate final int timeout;\n-\tprivate final Path directory;\n-\tprivate final Set<String> repositories;\n-\tprivate final Consumer<Status> statusHandler;\n+\tprivate final @NotNull Path directory;\n+\tprivate final @NotNull Set<String> repositories;\n+\tprivate final @NotNull Consumer<Status> statusHandler;\n \n-\tprivate final DependencyDownloader dependencyDownloader = new DependencyDownloader(this);\n-\tprivate final DependencyRelocator dependencyRelocator;\n-\tprivate final DependencyLoader dependencyLoader;\n+\tprivate final @NotNull DependencyDownloader dependencyDownloader = new DependencyDownloader(this);\n+\tprivate final @NotNull DependencyRelocator dependencyRelocator;\n+\tprivate final @NotNull DependencyLoader dependencyLoader;\n \n \n \t@Internal\n@@ -74,7 +75,7 @@ protected Dragonfly(int timeout, IClassLoader classLoader, Path directory, Set<S\n \t\t}\n \t}\n \n-\tpublic static String getVersion() {\n+\tpublic static @NotNull String getVersion() {\n \t\treturn VERSION;\n \t}\n \n@@ -84,7 +85,7 @@ public static String getVersion() {\n \t * @param dependencies Dependencies to be loaded.\n \t * @return If the load was successful, in the form of a {@link CompletableFuture<Boolean>}.\n \t */\n-\tpublic CompletableFuture<Boolean> load(Dependency... dependencies) {\n+\tpublic @NotNull CompletableFuture<Boolean> load(@NotNull Dependency... dependencies) {\n \t\treturn CompletableFuture.supplyAsync(() -> {\n \t\t\ttry {\n \t\t\t\tstatusHandler.accept(Status.STARTING);\n@@ -137,11 +138,11 @@ public int getTimeout() {\n \t\treturn timeout;\n \t}\n \n-\tpublic Path getDirectory() {\n+\tpublic @NotNull Path getDirectory() {\n \t\treturn directory;\n \t}\n \n-\tpublic Set<String> getRepositories() {\n+\tpublic @NotNull Set<String> getRepositories() {\n \t\treturn repositories;\n \t}\n \n@@ -151,7 +152,7 @@ public Set<String> getRepositories() {\n \t * @return Stored instance of {@link DependencyDownloader}.\n \t */\n \t@Internal\n-\tpublic DependencyDownloader getDependencyDownloader() {\n+\tpublic @NotNull DependencyDownloader getDependencyDownloader() {\n \t\treturn dependencyDownloader;\n \t}\n ",
    "function_modified_lines": {
      "added": [
        "\tpublic static @NotNull String getVersion() {\n",
        "\tpublic @NotNull CompletableFuture<Boolean> load(@NotNull Dependency... dependencies) {\n"
      ],
      "deleted": [
        "\tpublic static String getVersion() {\n",
        "\tpublic CompletableFuture<Boolean> load(Dependency... dependencies) {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "Dragonfly is a Java runtime dependency management library. Dragonfly v0.3.0-SNAPSHOT does not configure DocumentBuilderFactory to prevent XML external entity (XXE) attacks. This issue is patched in 0.3.1-SNAPSHOT. As a workaround, since Dragonfly only parses XML `SNAPSHOT` versions are being resolved, this vulnerability may be avoided by not trying to resolve `SNAPSHOT` versions.",
    "id": 12669
  },
  {
    "cve_id": "CVE-2022-41967",
    "code_before_change": "{\n\n\tprivate static final String VERSION = \"0.3.0-SNAPSHOT\";\n\n\tprivate final int timeout;\n\tprivate final Path directory;\n\tprivate final Set<String> repositories;\n\tprivate final Consumer<Status> statusHandler;\n\n\tprivate final DependencyDownloader dependencyDownloader = new DependencyDownloader(this);\n\tprivate final DependencyRelocator dependencyRelocator;\n\tprivate final DependencyLoader dependencyLoader;\n\n\n\t@Internal\n\tprotected Dragonfly(int timeout, IClassLoader classLoader, Path directory, Set<String> repositories, boolean delete, Consumer<Status> statusHandler) throws IOException {\n\t\tthis.timeout = timeout;\n\t\tthis.directory = directory;\n\t\tthis.repositories = repositories;\n\t\tthis.statusHandler = statusHandler;\n\n\t\tthis.dependencyRelocator = new DependencyRelocator(this, delete);\n\t\tthis.dependencyLoader = new DependencyLoader(this, classLoader);\n\n\t\tif (!Files.exists(directory)) {\n\t\t\tFiles.createDirectories(directory);\n\t\t}\n\t}\n\n\tpublic static String getVersion() {\n\t\treturn VERSION;\n\t}\n\n\t/**\n\t * Download, relocate and load dependencies.\n\t *\n\t * @param dependencies Dependencies to be loaded.\n\t * @return If the load was successful, in the form of a {@link CompletableFuture<Boolean>}.\n\t */\n\tpublic CompletableFuture<Boolean> load(Dependency... dependencies) {\n\t\treturn CompletableFuture.supplyAsync(() -> {\n\t\t\ttry {\n\t\t\t\tstatusHandler.accept(Status.STARTING);\n\t\t\t\tList<Dependency> dependencyList = Arrays.stream(dependencies)\n\t\t\t\t\t\t.sorted(Comparator.comparingInt(Dependency::getPriority)).collect(Collectors.toList());\n\n\t\t\t\tif (dependencyList.size() > 0) {\n\t\t\t\t\tList<Dependency> downloadList = dependencyList.stream().filter(d -> !isDownloaded(d))\n\t\t\t\t\t\t\t.collect(Collectors.toList());\n\t\t\t\t\tif (downloadList.size() > 0) {\n\t\t\t\t\t\tstatusHandler.accept(Status.DOWNLOADING);\n\t\t\t\t\t\tdependencyDownloader.download(downloadList);\n\n\t\t\t\t\t\tif (downloadList.stream().anyMatch(d -> d.getRelocations().size() > 0)) {\n\t\t\t\t\t\t\tstatusHandler.accept(Status.RELOCATING);\n\t\t\t\t\t\t\tdependencyRelocator.relocate(downloadList);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tdependencyList.stream().filter(d -> d.getRelocations().size() > 0 && !d.isRelocated())\n\t\t\t\t\t\t\t.forEach(d -> d.setFileName(dependencyRelocator.getRelocatedFileName(d)));\n\n\t\t\t\t\tstatusHandler.accept(Status.LOADING);\n\t\t\t\t\tdependencyLoader.load(dependencyList);\n\t\t\t\t}\n\n\t\t\t\tstatusHandler.accept(Status.FINISHED);\n\t\t\t\treturn true;\n\t\t\t} catch (Exception ex) {\n\t\t\t\tthrow new IllegalStateException(ex);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * If a dependency has been downloaded or not.\n\t *\n\t * @param dependency Dependency.\n\t * @return If the given dependency has been downloaded or not.\n\t */\n\tprivate boolean isDownloaded(Dependency dependency) {\n\t\tif (dependencyRelocator.isRelocated(dependency)) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn Files.exists(directory.resolve(dependency.getFileName()));\n\t\t}\n\t}\n\n\tpublic int getTimeout() {\n\t\treturn timeout;\n\t}\n\n\tpublic Path getDirectory() {\n\t\treturn directory;\n\t}\n\n\tpublic Set<String> getRepositories() {\n\t\treturn repositories;\n\t}\n\n\t/**\n\t * Get {@link DependencyDownloader}, for internal use only.\n\t *\n\t * @return Stored instance of {@link DependencyDownloader}.\n\t */\n\t@Internal\n\tpublic DependencyDownloader getDependencyDownloader() {\n\t\treturn dependencyDownloader;\n\t}\n\n}",
    "code_after_change": "{\n\n\tprivate static final @NotNull String VERSION = \"0.3.1-SNAPSHOT\";\n\n\tprivate final int timeout;\n\tprivate final @NotNull Path directory;\n\tprivate final @NotNull Set<String> repositories;\n\tprivate final @NotNull Consumer<Status> statusHandler;\n\n\tprivate final @NotNull DependencyDownloader dependencyDownloader = new DependencyDownloader(this);\n\tprivate final @NotNull DependencyRelocator dependencyRelocator;\n\tprivate final @NotNull DependencyLoader dependencyLoader;\n\n\n\t@Internal\n\tprotected Dragonfly(int timeout, IClassLoader classLoader, Path directory, Set<String> repositories, boolean delete, Consumer<Status> statusHandler) throws IOException {\n\t\tthis.timeout = timeout;\n\t\tthis.directory = directory;\n\t\tthis.repositories = repositories;\n\t\tthis.statusHandler = statusHandler;\n\n\t\tthis.dependencyRelocator = new DependencyRelocator(this, delete);\n\t\tthis.dependencyLoader = new DependencyLoader(this, classLoader);\n\n\t\tif (!Files.exists(directory)) {\n\t\t\tFiles.createDirectories(directory);\n\t\t}\n\t}\n\n\tpublic static @NotNull String getVersion() {\n\t\treturn VERSION;\n\t}\n\n\t/**\n\t * Download, relocate and load dependencies.\n\t *\n\t * @param dependencies Dependencies to be loaded.\n\t * @return If the load was successful, in the form of a {@link CompletableFuture<Boolean>}.\n\t */\n\tpublic @NotNull CompletableFuture<Boolean> load(@NotNull Dependency... dependencies) {\n\t\treturn CompletableFuture.supplyAsync(() -> {\n\t\t\ttry {\n\t\t\t\tstatusHandler.accept(Status.STARTING);\n\t\t\t\tList<Dependency> dependencyList = Arrays.stream(dependencies)\n\t\t\t\t\t\t.sorted(Comparator.comparingInt(Dependency::getPriority)).collect(Collectors.toList());\n\n\t\t\t\tif (dependencyList.size() > 0) {\n\t\t\t\t\tList<Dependency> downloadList = dependencyList.stream().filter(d -> !isDownloaded(d))\n\t\t\t\t\t\t\t.collect(Collectors.toList());\n\t\t\t\t\tif (downloadList.size() > 0) {\n\t\t\t\t\t\tstatusHandler.accept(Status.DOWNLOADING);\n\t\t\t\t\t\tdependencyDownloader.download(downloadList);\n\n\t\t\t\t\t\tif (downloadList.stream().anyMatch(d -> d.getRelocations().size() > 0)) {\n\t\t\t\t\t\t\tstatusHandler.accept(Status.RELOCATING);\n\t\t\t\t\t\t\tdependencyRelocator.relocate(downloadList);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tdependencyList.stream().filter(d -> d.getRelocations().size() > 0 && !d.isRelocated())\n\t\t\t\t\t\t\t.forEach(d -> d.setFileName(dependencyRelocator.getRelocatedFileName(d)));\n\n\t\t\t\t\tstatusHandler.accept(Status.LOADING);\n\t\t\t\t\tdependencyLoader.load(dependencyList);\n\t\t\t\t}\n\n\t\t\t\tstatusHandler.accept(Status.FINISHED);\n\t\t\t\treturn true;\n\t\t\t} catch (Exception ex) {\n\t\t\t\tthrow new IllegalStateException(ex);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * If a dependency has been downloaded or not.\n\t *\n\t * @param dependency Dependency.\n\t * @return If the given dependency has been downloaded or not.\n\t */\n\tprivate boolean isDownloaded(Dependency dependency) {\n\t\tif (dependencyRelocator.isRelocated(dependency)) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn Files.exists(directory.resolve(dependency.getFileName()));\n\t\t}\n\t}\n\n\tpublic int getTimeout() {\n\t\treturn timeout;\n\t}\n\n\tpublic @NotNull Path getDirectory() {\n\t\treturn directory;\n\t}\n\n\tpublic @NotNull Set<String> getRepositories() {\n\t\treturn repositories;\n\t}\n\n\t/**\n\t * Get {@link DependencyDownloader}, for internal use only.\n\t *\n\t * @return Stored instance of {@link DependencyDownloader}.\n\t */\n\t@Internal\n\tpublic @NotNull DependencyDownloader getDependencyDownloader() {\n\t\treturn dependencyDownloader;\n\t}\n\n}",
    "patch": "@@ -40,23 +40,24 @@\n import java.util.function.Consumer;\n import java.util.stream.Collectors;\n import org.jetbrains.annotations.ApiStatus.Internal;\n+import org.jetbrains.annotations.NotNull;\n \n /**\n  * Main Dragonfly class.\n  * @author Joshua Sing <joshua@hypera.dev>\n  */\n public class Dragonfly {\n \n-\tprivate static final String VERSION = \"0.3.0-SNAPSHOT\";\n+\tprivate static final @NotNull String VERSION = \"0.3.1-SNAPSHOT\";\n \n \tprivate final int timeout;\n-\tprivate final Path directory;\n-\tprivate final Set<String> repositories;\n-\tprivate final Consumer<Status> statusHandler;\n+\tprivate final @NotNull Path directory;\n+\tprivate final @NotNull Set<String> repositories;\n+\tprivate final @NotNull Consumer<Status> statusHandler;\n \n-\tprivate final DependencyDownloader dependencyDownloader = new DependencyDownloader(this);\n-\tprivate final DependencyRelocator dependencyRelocator;\n-\tprivate final DependencyLoader dependencyLoader;\n+\tprivate final @NotNull DependencyDownloader dependencyDownloader = new DependencyDownloader(this);\n+\tprivate final @NotNull DependencyRelocator dependencyRelocator;\n+\tprivate final @NotNull DependencyLoader dependencyLoader;\n \n \n \t@Internal\n@@ -74,7 +75,7 @@ protected Dragonfly(int timeout, IClassLoader classLoader, Path directory, Set<S\n \t\t}\n \t}\n \n-\tpublic static String getVersion() {\n+\tpublic static @NotNull String getVersion() {\n \t\treturn VERSION;\n \t}\n \n@@ -84,7 +85,7 @@ public static String getVersion() {\n \t * @param dependencies Dependencies to be loaded.\n \t * @return If the load was successful, in the form of a {@link CompletableFuture<Boolean>}.\n \t */\n-\tpublic CompletableFuture<Boolean> load(Dependency... dependencies) {\n+\tpublic @NotNull CompletableFuture<Boolean> load(@NotNull Dependency... dependencies) {\n \t\treturn CompletableFuture.supplyAsync(() -> {\n \t\t\ttry {\n \t\t\t\tstatusHandler.accept(Status.STARTING);\n@@ -137,11 +138,11 @@ public int getTimeout() {\n \t\treturn timeout;\n \t}\n \n-\tpublic Path getDirectory() {\n+\tpublic @NotNull Path getDirectory() {\n \t\treturn directory;\n \t}\n \n-\tpublic Set<String> getRepositories() {\n+\tpublic @NotNull Set<String> getRepositories() {\n \t\treturn repositories;\n \t}\n \n@@ -151,7 +152,7 @@ public Set<String> getRepositories() {\n \t * @return Stored instance of {@link DependencyDownloader}.\n \t */\n \t@Internal\n-\tpublic DependencyDownloader getDependencyDownloader() {\n+\tpublic @NotNull DependencyDownloader getDependencyDownloader() {\n \t\treturn dependencyDownloader;\n \t}\n ",
    "function_modified_lines": {
      "added": [
        "\tpublic @NotNull Path getDirectory() {\n",
        "\tpublic @NotNull Set<String> getRepositories() {\n",
        "\tpublic @NotNull DependencyDownloader getDependencyDownloader() {\n"
      ],
      "deleted": [
        "\tpublic Path getDirectory() {\n",
        "\tpublic Set<String> getRepositories() {\n",
        "\tpublic DependencyDownloader getDependencyDownloader() {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "Dragonfly is a Java runtime dependency management library. Dragonfly v0.3.0-SNAPSHOT does not configure DocumentBuilderFactory to prevent XML external entity (XXE) attacks. This issue is patched in 0.3.1-SNAPSHOT. As a workaround, since Dragonfly only parses XML `SNAPSHOT` versions are being resolved, this vulnerability may be avoided by not trying to resolve `SNAPSHOT` versions.",
    "id": 12670
  },
  {
    "cve_id": "CVE-2022-41967",
    "code_before_change": "{\n\n\tpublic DownloadFailureException() {\n\t\tsuper();\n\t}\n\n\tpublic DownloadFailureException(String message) {\n\t\tsuper(message);\n\t}\n\n\tpublic DownloadFailureException(String message, Throwable cause) {\n\t\tsuper(message, cause);\n\t}\n\n\tpublic DownloadFailureException(Throwable cause) {\n\t\tsuper(cause);\n\t}\n\n\tprotected DownloadFailureException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {\n\t\tsuper(message, cause, enableSuppression, writableStackTrace);\n\t}\n\n}",
    "code_after_change": "/*\n * Dragonfly - Runtime dependency management library\n *  Copyright (c) 2021 Joshua Sing <joshua@hypera.dev>\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"Software\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in all\n *  copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *  SOFTWARE.\n */\n\npackage dev.hypera.dragonfly.exceptions;\n\nimport org.jetbrains.annotations.NotNull;\n\npublic class DownloadFailureException extends DragonflyException {\n\n\tprivate static final long serialVersionUID = 5648475409314204882L;\n\n\tpublic DownloadFailureException() {\n\t\tsuper();\n\t}\n\n\tpublic DownloadFailureException(@NotNull String message) {\n\t\tsuper(message);\n\t}\n\n\tpublic DownloadFailureException(@NotNull String message, @NotNull Throwable cause) {\n\t\tsuper(message, cause);\n\t}\n\n\tpublic DownloadFailureException(@NotNull Throwable cause) {\n\t\tsuper(cause);\n\t}\n\n\tprotected DownloadFailureException(@NotNull String message, @NotNull Throwable cause, boolean enableSuppression, boolean writableStackTrace) {\n\t\tsuper(message, cause, enableSuppression, writableStackTrace);\n\t}\n\n}\n",
    "patch": "@@ -23,25 +23,29 @@\n \n package dev.hypera.dragonfly.exceptions;\n \n+import org.jetbrains.annotations.NotNull;\n+\n public class DownloadFailureException extends DragonflyException {\n \n+\tprivate static final long serialVersionUID = 5648475409314204882L;\n+\n \tpublic DownloadFailureException() {\n \t\tsuper();\n \t}\n \n-\tpublic DownloadFailureException(String message) {\n+\tpublic DownloadFailureException(@NotNull String message) {\n \t\tsuper(message);\n \t}\n \n-\tpublic DownloadFailureException(String message, Throwable cause) {\n+\tpublic DownloadFailureException(@NotNull String message, @NotNull Throwable cause) {\n \t\tsuper(message, cause);\n \t}\n \n-\tpublic DownloadFailureException(Throwable cause) {\n+\tpublic DownloadFailureException(@NotNull Throwable cause) {\n \t\tsuper(cause);\n \t}\n \n-\tprotected DownloadFailureException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {\n+\tprotected DownloadFailureException(@NotNull String message, @NotNull Throwable cause, boolean enableSuppression, boolean writableStackTrace) {\n \t\tsuper(message, cause, enableSuppression, writableStackTrace);\n \t}\n ",
    "function_modified_lines": {
      "added": [
        "import org.jetbrains.annotations.NotNull;\n",
        "\n",
        "\tprivate static final long serialVersionUID = 5648475409314204882L;\n",
        "\n",
        "\tpublic DownloadFailureException(@NotNull String message) {\n",
        "\tpublic DownloadFailureException(@NotNull String message, @NotNull Throwable cause) {\n",
        "\tpublic DownloadFailureException(@NotNull Throwable cause) {\n",
        "\tprotected DownloadFailureException(@NotNull String message, @NotNull Throwable cause, boolean enableSuppression, boolean writableStackTrace) {\n"
      ],
      "deleted": [
        "\tpublic DownloadFailureException(String message) {\n",
        "\tpublic DownloadFailureException(String message, Throwable cause) {\n",
        "\tpublic DownloadFailureException(Throwable cause) {\n",
        "\tprotected DownloadFailureException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "Dragonfly is a Java runtime dependency management library. Dragonfly v0.3.0-SNAPSHOT does not configure DocumentBuilderFactory to prevent XML external entity (XXE) attacks. This issue is patched in 0.3.1-SNAPSHOT. As a workaround, since Dragonfly only parses XML `SNAPSHOT` versions are being resolved, this vulnerability may be avoided by not trying to resolve `SNAPSHOT` versions.",
    "id": 12671
  },
  {
    "cve_id": "CVE-2022-41967",
    "code_before_change": "{\n\n\tpublic DragonflyException() {\n\t\tsuper();\n\t}\n\n\tpublic DragonflyException(String message) {\n\t\tsuper(message);\n\t}\n\n\tpublic DragonflyException(String message, Throwable cause) {\n\t\tsuper(message, cause);\n\t}\n\n\tpublic DragonflyException(Throwable cause) {\n\t\tsuper(cause);\n\t}\n\n\tprotected DragonflyException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {\n\t\tsuper(message, cause, enableSuppression, writableStackTrace);\n\t}\n\n}",
    "code_after_change": "/*\n * Dragonfly - Runtime dependency management library\n *  Copyright (c) 2021 Joshua Sing <joshua@hypera.dev>\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"Software\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in all\n *  copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *  SOFTWARE.\n */\n\npackage dev.hypera.dragonfly.exceptions;\n\nimport org.jetbrains.annotations.NotNull;\n\n/**\n * Dragonfly Exception.\n * @author Joshua Sing <joshua@hypera.dev>\n */\npublic class DragonflyException extends Exception {\n\n\tprivate static final long serialVersionUID = 3565376065959848642L;\n\n\tpublic DragonflyException() {\n\t\tsuper();\n\t}\n\n\tpublic DragonflyException(@NotNull String message) {\n\t\tsuper(message);\n\t}\n\n\tpublic DragonflyException(@NotNull String message, @NotNull Throwable cause) {\n\t\tsuper(message, cause);\n\t}\n\n\tpublic DragonflyException(@NotNull Throwable cause) {\n\t\tsuper(cause);\n\t}\n\n\tprotected DragonflyException(@NotNull String message, @NotNull Throwable cause, boolean enableSuppression, boolean writableStackTrace) {\n\t\tsuper(message, cause, enableSuppression, writableStackTrace);\n\t}\n\n}\n",
    "patch": "@@ -23,29 +23,33 @@\n \n package dev.hypera.dragonfly.exceptions;\n \n+import org.jetbrains.annotations.NotNull;\n+\n /**\n  * Dragonfly Exception.\n  * @author Joshua Sing <joshua@hypera.dev>\n  */\n public class DragonflyException extends Exception {\n \n+\tprivate static final long serialVersionUID = 3565376065959848642L;\n+\n \tpublic DragonflyException() {\n \t\tsuper();\n \t}\n \n-\tpublic DragonflyException(String message) {\n+\tpublic DragonflyException(@NotNull String message) {\n \t\tsuper(message);\n \t}\n \n-\tpublic DragonflyException(String message, Throwable cause) {\n+\tpublic DragonflyException(@NotNull String message, @NotNull Throwable cause) {\n \t\tsuper(message, cause);\n \t}\n \n-\tpublic DragonflyException(Throwable cause) {\n+\tpublic DragonflyException(@NotNull Throwable cause) {\n \t\tsuper(cause);\n \t}\n \n-\tprotected DragonflyException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {\n+\tprotected DragonflyException(@NotNull String message, @NotNull Throwable cause, boolean enableSuppression, boolean writableStackTrace) {\n \t\tsuper(message, cause, enableSuppression, writableStackTrace);\n \t}\n ",
    "function_modified_lines": {
      "added": [
        "import org.jetbrains.annotations.NotNull;\n",
        "\n",
        "\tprivate static final long serialVersionUID = 3565376065959848642L;\n",
        "\n",
        "\tpublic DragonflyException(@NotNull String message) {\n",
        "\tpublic DragonflyException(@NotNull String message, @NotNull Throwable cause) {\n",
        "\tpublic DragonflyException(@NotNull Throwable cause) {\n",
        "\tprotected DragonflyException(@NotNull String message, @NotNull Throwable cause, boolean enableSuppression, boolean writableStackTrace) {\n"
      ],
      "deleted": [
        "\tpublic DragonflyException(String message) {\n",
        "\tpublic DragonflyException(String message, Throwable cause) {\n",
        "\tpublic DragonflyException(Throwable cause) {\n",
        "\tprotected DragonflyException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "Dragonfly is a Java runtime dependency management library. Dragonfly v0.3.0-SNAPSHOT does not configure DocumentBuilderFactory to prevent XML external entity (XXE) attacks. This issue is patched in 0.3.1-SNAPSHOT. As a workaround, since Dragonfly only parses XML `SNAPSHOT` versions are being resolved, this vulnerability may be avoided by not trying to resolve `SNAPSHOT` versions.",
    "id": 12672
  },
  {
    "cve_id": "CVE-2022-41967",
    "code_before_change": "{\n\n\tpublic LoadFailureException() {\n\t\tsuper();\n\t}\n\n\tpublic LoadFailureException(String message) {\n\t\tsuper(message);\n\t}\n\n\tpublic LoadFailureException(String message, Throwable cause) {\n\t\tsuper(message, cause);\n\t}\n\n\tpublic LoadFailureException(Throwable cause) {\n\t\tsuper(cause);\n\t}\n\n\tprotected LoadFailureException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {\n\t\tsuper(message, cause, enableSuppression, writableStackTrace);\n\t}\n\n}",
    "code_after_change": "/*\n * Dragonfly - Runtime dependency management library\n *  Copyright (c) 2021 Joshua Sing <joshua@hypera.dev>\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"Software\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in all\n *  copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *  SOFTWARE.\n */\n\npackage dev.hypera.dragonfly.exceptions;\n\nimport org.jetbrains.annotations.NotNull;\n\npublic class LoadFailureException extends DragonflyException {\n\n\tprivate static final long serialVersionUID = -8555618454694039541L;\n\n\tpublic LoadFailureException() {\n\t\tsuper();\n\t}\n\n\tpublic LoadFailureException(@NotNull String message) {\n\t\tsuper(message);\n\t}\n\n\tpublic LoadFailureException(@NotNull String message, @NotNull Throwable cause) {\n\t\tsuper(message, cause);\n\t}\n\n\tpublic LoadFailureException(@NotNull Throwable cause) {\n\t\tsuper(cause);\n\t}\n\n\tprotected LoadFailureException(@NotNull String message, @NotNull Throwable cause, boolean enableSuppression, boolean writableStackTrace) {\n\t\tsuper(message, cause, enableSuppression, writableStackTrace);\n\t}\n\n}\n",
    "patch": "@@ -23,25 +23,29 @@\n \n package dev.hypera.dragonfly.exceptions;\n \n+import org.jetbrains.annotations.NotNull;\n+\n public class LoadFailureException extends DragonflyException {\n \n+\tprivate static final long serialVersionUID = -8555618454694039541L;\n+\n \tpublic LoadFailureException() {\n \t\tsuper();\n \t}\n \n-\tpublic LoadFailureException(String message) {\n+\tpublic LoadFailureException(@NotNull String message) {\n \t\tsuper(message);\n \t}\n \n-\tpublic LoadFailureException(String message, Throwable cause) {\n+\tpublic LoadFailureException(@NotNull String message, @NotNull Throwable cause) {\n \t\tsuper(message, cause);\n \t}\n \n-\tpublic LoadFailureException(Throwable cause) {\n+\tpublic LoadFailureException(@NotNull Throwable cause) {\n \t\tsuper(cause);\n \t}\n \n-\tprotected LoadFailureException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {\n+\tprotected LoadFailureException(@NotNull String message, @NotNull Throwable cause, boolean enableSuppression, boolean writableStackTrace) {\n \t\tsuper(message, cause, enableSuppression, writableStackTrace);\n \t}\n ",
    "function_modified_lines": {
      "added": [
        "import org.jetbrains.annotations.NotNull;\n",
        "\n",
        "\tprivate static final long serialVersionUID = -8555618454694039541L;\n",
        "\n",
        "\tpublic LoadFailureException(@NotNull String message) {\n",
        "\tpublic LoadFailureException(@NotNull String message, @NotNull Throwable cause) {\n",
        "\tpublic LoadFailureException(@NotNull Throwable cause) {\n",
        "\tprotected LoadFailureException(@NotNull String message, @NotNull Throwable cause, boolean enableSuppression, boolean writableStackTrace) {\n"
      ],
      "deleted": [
        "\tpublic LoadFailureException(String message) {\n",
        "\tpublic LoadFailureException(String message, Throwable cause) {\n",
        "\tpublic LoadFailureException(Throwable cause) {\n",
        "\tprotected LoadFailureException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "Dragonfly is a Java runtime dependency management library. Dragonfly v0.3.0-SNAPSHOT does not configure DocumentBuilderFactory to prevent XML external entity (XXE) attacks. This issue is patched in 0.3.1-SNAPSHOT. As a workaround, since Dragonfly only parses XML `SNAPSHOT` versions are being resolved, this vulnerability may be avoided by not trying to resolve `SNAPSHOT` versions.",
    "id": 12673
  },
  {
    "cve_id": "CVE-2022-41967",
    "code_before_change": "{\n\n\tpublic RelocationFailureException() {\n\t\tsuper();\n\t}\n\n\tpublic RelocationFailureException(String message) {\n\t\tsuper(message);\n\t}\n\n\tpublic RelocationFailureException(String message, Throwable cause) {\n\t\tsuper(message, cause);\n\t}\n\n\tpublic RelocationFailureException(Throwable cause) {\n\t\tsuper(cause);\n\t}\n\n\tprotected RelocationFailureException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {\n\t\tsuper(message, cause, enableSuppression, writableStackTrace);\n\t}\n\n}",
    "code_after_change": "/*\n * Dragonfly - Runtime dependency management library\n *  Copyright (c) 2021 Joshua Sing <joshua@hypera.dev>\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"Software\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in all\n *  copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *  SOFTWARE.\n */\n\npackage dev.hypera.dragonfly.exceptions;\n\nimport org.jetbrains.annotations.NotNull;\n\npublic class RelocationFailureException extends DragonflyException {\n\n\tprivate static final long serialVersionUID = -2817144091943660838L;\n\n\tpublic RelocationFailureException() {\n\t\tsuper();\n\t}\n\n\tpublic RelocationFailureException(@NotNull String message) {\n\t\tsuper(message);\n\t}\n\n\tpublic RelocationFailureException(@NotNull String message, @NotNull Throwable cause) {\n\t\tsuper(message, cause);\n\t}\n\n\tpublic RelocationFailureException(@NotNull Throwable cause) {\n\t\tsuper(cause);\n\t}\n\n\tprotected RelocationFailureException(@NotNull String message, @NotNull Throwable cause, boolean enableSuppression, boolean writableStackTrace) {\n\t\tsuper(message, cause, enableSuppression, writableStackTrace);\n\t}\n\n}\n",
    "patch": "@@ -23,25 +23,29 @@\n \n package dev.hypera.dragonfly.exceptions;\n \n+import org.jetbrains.annotations.NotNull;\n+\n public class RelocationFailureException extends DragonflyException {\n \n+\tprivate static final long serialVersionUID = -2817144091943660838L;\n+\n \tpublic RelocationFailureException() {\n \t\tsuper();\n \t}\n \n-\tpublic RelocationFailureException(String message) {\n+\tpublic RelocationFailureException(@NotNull String message) {\n \t\tsuper(message);\n \t}\n \n-\tpublic RelocationFailureException(String message, Throwable cause) {\n+\tpublic RelocationFailureException(@NotNull String message, @NotNull Throwable cause) {\n \t\tsuper(message, cause);\n \t}\n \n-\tpublic RelocationFailureException(Throwable cause) {\n+\tpublic RelocationFailureException(@NotNull Throwable cause) {\n \t\tsuper(cause);\n \t}\n \n-\tprotected RelocationFailureException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {\n+\tprotected RelocationFailureException(@NotNull String message, @NotNull Throwable cause, boolean enableSuppression, boolean writableStackTrace) {\n \t\tsuper(message, cause, enableSuppression, writableStackTrace);\n \t}\n ",
    "function_modified_lines": {
      "added": [
        "import org.jetbrains.annotations.NotNull;\n",
        "\n",
        "\tprivate static final long serialVersionUID = -2817144091943660838L;\n",
        "\n",
        "\tpublic RelocationFailureException(@NotNull String message) {\n",
        "\tpublic RelocationFailureException(@NotNull String message, @NotNull Throwable cause) {\n",
        "\tpublic RelocationFailureException(@NotNull Throwable cause) {\n",
        "\tprotected RelocationFailureException(@NotNull String message, @NotNull Throwable cause, boolean enableSuppression, boolean writableStackTrace) {\n"
      ],
      "deleted": [
        "\tpublic RelocationFailureException(String message) {\n",
        "\tpublic RelocationFailureException(String message, Throwable cause) {\n",
        "\tpublic RelocationFailureException(Throwable cause) {\n",
        "\tprotected RelocationFailureException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "Dragonfly is a Java runtime dependency management library. Dragonfly v0.3.0-SNAPSHOT does not configure DocumentBuilderFactory to prevent XML external entity (XXE) attacks. This issue is patched in 0.3.1-SNAPSHOT. As a workaround, since Dragonfly only parses XML `SNAPSHOT` versions are being resolved, this vulnerability may be avoided by not trying to resolve `SNAPSHOT` versions.",
    "id": 12674
  },
  {
    "cve_id": "CVE-2022-41967",
    "code_before_change": "{\n\n\tpublic ResolveFailureException() {\n\t\tsuper();\n\t}\n\n\tpublic ResolveFailureException(String message) {\n\t\tsuper(message);\n\t}\n\n\tpublic ResolveFailureException(String message, Throwable cause) {\n\t\tsuper(message, cause);\n\t}\n\n\tpublic ResolveFailureException(Throwable cause) {\n\t\tsuper(cause);\n\t}\n\n\tprotected ResolveFailureException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {\n\t\tsuper(message, cause, enableSuppression, writableStackTrace);\n\t}\n\n}",
    "code_after_change": "/*\n * Dragonfly - Runtime dependency management library\n *  Copyright (c) 2021 Joshua Sing <joshua@hypera.dev>\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"Software\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in all\n *  copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *  SOFTWARE.\n */\n\npackage dev.hypera.dragonfly.exceptions;\n\nimport org.jetbrains.annotations.NotNull;\n\npublic class ResolveFailureException extends DownloadFailureException {\n\n\tprivate static final long serialVersionUID = -8393996338726021911L;\n\n\tpublic ResolveFailureException() {\n\t\tsuper();\n\t}\n\n\tpublic ResolveFailureException(@NotNull String message) {\n\t\tsuper(message);\n\t}\n\n\tpublic ResolveFailureException(@NotNull String message, @NotNull Throwable cause) {\n\t\tsuper(message, cause);\n\t}\n\n\tpublic ResolveFailureException(@NotNull Throwable cause) {\n\t\tsuper(cause);\n\t}\n\n\tprotected ResolveFailureException(@NotNull String message, @NotNull Throwable cause, boolean enableSuppression, boolean writableStackTrace) {\n\t\tsuper(message, cause, enableSuppression, writableStackTrace);\n\t}\n\n}\n",
    "patch": "@@ -23,25 +23,29 @@\n \n package dev.hypera.dragonfly.exceptions;\n \n+import org.jetbrains.annotations.NotNull;\n+\n public class ResolveFailureException extends DownloadFailureException {\n \n+\tprivate static final long serialVersionUID = -8393996338726021911L;\n+\n \tpublic ResolveFailureException() {\n \t\tsuper();\n \t}\n \n-\tpublic ResolveFailureException(String message) {\n+\tpublic ResolveFailureException(@NotNull String message) {\n \t\tsuper(message);\n \t}\n \n-\tpublic ResolveFailureException(String message, Throwable cause) {\n+\tpublic ResolveFailureException(@NotNull String message, @NotNull Throwable cause) {\n \t\tsuper(message, cause);\n \t}\n \n-\tpublic ResolveFailureException(Throwable cause) {\n+\tpublic ResolveFailureException(@NotNull Throwable cause) {\n \t\tsuper(cause);\n \t}\n \n-\tprotected ResolveFailureException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {\n+\tprotected ResolveFailureException(@NotNull String message, @NotNull Throwable cause, boolean enableSuppression, boolean writableStackTrace) {\n \t\tsuper(message, cause, enableSuppression, writableStackTrace);\n \t}\n ",
    "function_modified_lines": {
      "added": [
        "import org.jetbrains.annotations.NotNull;\n",
        "\n",
        "\tprivate static final long serialVersionUID = -8393996338726021911L;\n",
        "\n",
        "\tpublic ResolveFailureException(@NotNull String message) {\n",
        "\tpublic ResolveFailureException(@NotNull String message, @NotNull Throwable cause) {\n",
        "\tpublic ResolveFailureException(@NotNull Throwable cause) {\n",
        "\tprotected ResolveFailureException(@NotNull String message, @NotNull Throwable cause, boolean enableSuppression, boolean writableStackTrace) {\n"
      ],
      "deleted": [
        "\tpublic ResolveFailureException(String message) {\n",
        "\tpublic ResolveFailureException(String message, Throwable cause) {\n",
        "\tpublic ResolveFailureException(Throwable cause) {\n",
        "\tprotected ResolveFailureException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "Dragonfly is a Java runtime dependency management library. Dragonfly v0.3.0-SNAPSHOT does not configure DocumentBuilderFactory to prevent XML external entity (XXE) attacks. This issue is patched in 0.3.1-SNAPSHOT. As a workaround, since Dragonfly only parses XML `SNAPSHOT` versions are being resolved, this vulnerability may be avoided by not trying to resolve `SNAPSHOT` versions.",
    "id": 12675
  },
  {
    "cve_id": "CVE-2022-41967",
    "code_before_change": "/*\n * Dragonfly - Runtime dependency management library\n *  Copyright (c) 2021 Joshua Sing <joshua@hypera.dev>\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"Software\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in all\n *  copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *  SOFTWARE.\n */\n\npackage dev.hypera.dragonfly.loading;\n\nimport dev.hypera.dragonfly.Dragonfly;\nimport dev.hypera.dragonfly.dependency.Dependency;\nimport dev.hypera.dragonfly.exceptions.LoadFailureException;\nimport java.net.MalformedURLException;\nimport java.util.List;\nimport org.jetbrains.annotations.ApiStatus.Internal;\n\n/**\n * Dependency loader.\n *\n * @author Joshua Sing <joshua@hypera.dev>\n */\npublic class DependencyLoader {\n\n\tprivate final Dragonfly dragonfly;\n\tprivate final IClassLoader classLoader;\n\n\t@Internal\n\tpublic DependencyLoader(Dragonfly dragonfly, IClassLoader classLoader) {\n\t\tthis.dragonfly = dragonfly;\n\t\tthis.classLoader = classLoader;\n\t}\n\n\t/**\n\t * Attempt to load a list of dependencies.\n\t *\n\t * @param dependencies Dependencies to be loaded.\n\t * @throws LoadFailureException if something went wrong while loading the dependencies.\n\t */\n\tpublic void load(List<Dependency> dependencies) throws LoadFailureException {\n\t\tfor (Dependency dependency : dependencies) {\n\t\t\tload(dependency);\n\t\t}\n\t}\n\n\t/**\n\t * Attempt to load a dependency.\n\t *\n\t * @param dependency Dependency to be loaded.\n\t * @throws LoadFailureException if something went wrong while loading the dependency.\n\t */\n\tprivate void load(Dependency dependency) throws LoadFailureException {\n\t\ttry {\n\t\t\tclassLoader.addURL(dragonfly.getDirectory().resolve(dependency.getFileName()).toUri().toURL());\n\t\t} catch (MalformedURLException ex) {\n\t\t\tthrow new LoadFailureException(ex);\n\t\t}\n\t}\n\n}\n",
    "code_after_change": "/*\n * Dragonfly - Runtime dependency management library\n *  Copyright (c) 2021 Joshua Sing <joshua@hypera.dev>\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"Software\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in all\n *  copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *  SOFTWARE.\n */\n\npackage dev.hypera.dragonfly.loading;\n\nimport dev.hypera.dragonfly.Dragonfly;\nimport dev.hypera.dragonfly.dependency.Dependency;\nimport dev.hypera.dragonfly.exceptions.LoadFailureException;\nimport java.net.MalformedURLException;\nimport java.util.List;\nimport org.jetbrains.annotations.ApiStatus.Internal;\nimport org.jetbrains.annotations.NotNull;\n\n/**\n * Dependency loader.\n *\n * @author Joshua Sing <joshua@hypera.dev>\n */\npublic class DependencyLoader {\n\n\tprivate final @NotNull Dragonfly dragonfly;\n\tprivate final @NotNull IClassLoader classLoader;\n\n\t@Internal\n\tpublic DependencyLoader(@NotNull Dragonfly dragonfly, @NotNull IClassLoader classLoader) {\n\t\tthis.dragonfly = dragonfly;\n\t\tthis.classLoader = classLoader;\n\t}\n\n\t/**\n\t * Attempt to load a list of dependencies.\n\t *\n\t * @param dependencies Dependencies to be loaded.\n\t * @throws LoadFailureException if something went wrong while loading the dependencies.\n\t */\n\tpublic void load(@NotNull List<Dependency> dependencies) throws LoadFailureException {\n\t\tfor (Dependency dependency : dependencies) {\n\t\t\tload(dependency);\n\t\t}\n\t}\n\n\t/**\n\t * Attempt to load a dependency.\n\t *\n\t * @param dependency Dependency to be loaded.\n\t * @throws LoadFailureException if something went wrong while loading the dependency.\n\t */\n\tprivate void load(@NotNull Dependency dependency) throws LoadFailureException {\n\t\ttry {\n\t\t\tclassLoader.addURL(dragonfly.getDirectory().resolve(dependency.getFileName()).toUri().toURL());\n\t\t} catch (MalformedURLException ex) {\n\t\t\tthrow new LoadFailureException(ex);\n\t\t}\n\t}\n\n}\n",
    "patch": "@@ -29,6 +29,7 @@\n import java.net.MalformedURLException;\n import java.util.List;\n import org.jetbrains.annotations.ApiStatus.Internal;\n+import org.jetbrains.annotations.NotNull;\n \n /**\n  * Dependency loader.\n@@ -37,11 +38,11 @@\n  */\n public class DependencyLoader {\n \n-\tprivate final Dragonfly dragonfly;\n-\tprivate final IClassLoader classLoader;\n+\tprivate final @NotNull Dragonfly dragonfly;\n+\tprivate final @NotNull IClassLoader classLoader;\n \n \t@Internal\n-\tpublic DependencyLoader(Dragonfly dragonfly, IClassLoader classLoader) {\n+\tpublic DependencyLoader(@NotNull Dragonfly dragonfly, @NotNull IClassLoader classLoader) {\n \t\tthis.dragonfly = dragonfly;\n \t\tthis.classLoader = classLoader;\n \t}\n@@ -52,7 +53,7 @@ public DependencyLoader(Dragonfly dragonfly, IClassLoader classLoader) {\n \t * @param dependencies Dependencies to be loaded.\n \t * @throws LoadFailureException if something went wrong while loading the dependencies.\n \t */\n-\tpublic void load(List<Dependency> dependencies) throws LoadFailureException {\n+\tpublic void load(@NotNull List<Dependency> dependencies) throws LoadFailureException {\n \t\tfor (Dependency dependency : dependencies) {\n \t\t\tload(dependency);\n \t\t}\n@@ -64,7 +65,7 @@ public void load(List<Dependency> dependencies) throws LoadFailureException {\n \t * @param dependency Dependency to be loaded.\n \t * @throws LoadFailureException if something went wrong while loading the dependency.\n \t */\n-\tprivate void load(Dependency dependency) throws LoadFailureException {\n+\tprivate void load(@NotNull Dependency dependency) throws LoadFailureException {\n \t\ttry {\n \t\t\tclassLoader.addURL(dragonfly.getDirectory().resolve(dependency.getFileName()).toUri().toURL());\n \t\t} catch (MalformedURLException ex) {",
    "function_modified_lines": {
      "added": [
        "import org.jetbrains.annotations.NotNull;\n",
        "\tprivate final @NotNull Dragonfly dragonfly;\n",
        "\tprivate final @NotNull IClassLoader classLoader;\n",
        "\tpublic DependencyLoader(@NotNull Dragonfly dragonfly, @NotNull IClassLoader classLoader) {\n",
        "\tpublic void load(@NotNull List<Dependency> dependencies) throws LoadFailureException {\n",
        "\tprivate void load(@NotNull Dependency dependency) throws LoadFailureException {\n"
      ],
      "deleted": [
        "\tprivate final Dragonfly dragonfly;\n",
        "\tprivate final IClassLoader classLoader;\n",
        "\tpublic DependencyLoader(Dragonfly dragonfly, IClassLoader classLoader) {\n",
        "\tpublic void load(List<Dependency> dependencies) throws LoadFailureException {\n",
        "\tprivate void load(Dependency dependency) throws LoadFailureException {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "Dragonfly is a Java runtime dependency management library. Dragonfly v0.3.0-SNAPSHOT does not configure DocumentBuilderFactory to prevent XML external entity (XXE) attacks. This issue is patched in 0.3.1-SNAPSHOT. As a workaround, since Dragonfly only parses XML `SNAPSHOT` versions are being resolved, this vulnerability may be avoided by not trying to resolve `SNAPSHOT` versions.",
    "id": 12676
  },
  {
    "cve_id": "CVE-2022-41967",
    "code_before_change": "/*\n * Dragonfly - Runtime dependency management library\n *  Copyright (c) 2021 Joshua Sing <joshua@hypera.dev>\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"Software\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in all\n *  copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *  SOFTWARE.\n */\n\npackage dev.hypera.dragonfly.loading;\n\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport org.jetbrains.annotations.ApiStatus.Internal;\n\n/**\n * Dragonfly class loader, a child-first {@link URLClassLoader} used for loading Dragonfly's internal dependencies.\n *\n * @author Joshua Sing <joshua@hypera.dev>\n */\n@Internal\npublic class DragonflyClassLoader extends URLClassLoader {\n\n\tpublic DragonflyClassLoader(ClassLoader classLoader) {\n\t\tsuper(new URL[0], classLoader);\n\t}\n\n\t@Override\n\tpublic void addURL(URL url) {\n\t\tsuper.addURL(url);\n\t}\n\n\t@Override\n\tprotected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {\n\t\tClass<?> loadedClass = findLoadedClass(name);\n\t\tif (null == loadedClass) {\n\t\t\ttry {\n\t\t\t\tloadedClass = findClass(name);\n\t\t\t} catch (ClassNotFoundException ex) {\n\t\t\t\tloadedClass = super.loadClass(name, resolve);\n\t\t\t}\n\t\t}\n\n\t\tif (resolve) {\n\t\t\tresolveClass(loadedClass);\n\t\t}\n\n\t\treturn loadedClass;\n\t}\n\n}\n",
    "code_after_change": "/*\n * Dragonfly - Runtime dependency management library\n *  Copyright (c) 2021 Joshua Sing <joshua@hypera.dev>\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"Software\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in all\n *  copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *  SOFTWARE.\n */\n\npackage dev.hypera.dragonfly.loading;\n\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport org.jetbrains.annotations.ApiStatus.Internal;\nimport org.jetbrains.annotations.NotNull;\n\n/**\n * Dragonfly class loader, a child-first {@link URLClassLoader} used for loading Dragonfly's internal dependencies.\n *\n * @author Joshua Sing <joshua@hypera.dev>\n */\n@Internal\npublic class DragonflyClassLoader extends URLClassLoader {\n\n\tpublic DragonflyClassLoader(@NotNull ClassLoader classLoader) {\n\t\tsuper(new URL[0], classLoader);\n\t}\n\n\t@Override\n\tpublic void addURL(@NotNull URL url) {\n\t\tsuper.addURL(url);\n\t}\n\n\t@Override\n\tprotected @NotNull Class<?> loadClass(@NotNull String name, boolean resolve) throws ClassNotFoundException {\n\t\tClass<?> loadedClass = findLoadedClass(name);\n\t\tif (null == loadedClass) {\n\t\t\ttry {\n\t\t\t\tloadedClass = findClass(name);\n\t\t\t} catch (ClassNotFoundException ex) {\n\t\t\t\tloadedClass = super.loadClass(name, resolve);\n\t\t\t}\n\t\t}\n\n\t\tif (resolve) {\n\t\t\tresolveClass(loadedClass);\n\t\t}\n\n\t\treturn loadedClass;\n\t}\n\n}\n",
    "patch": "@@ -26,6 +26,7 @@\n import java.net.URL;\n import java.net.URLClassLoader;\n import org.jetbrains.annotations.ApiStatus.Internal;\n+import org.jetbrains.annotations.NotNull;\n \n /**\n  * Dragonfly class loader, a child-first {@link URLClassLoader} used for loading Dragonfly's internal dependencies.\n@@ -35,17 +36,17 @@\n @Internal\n public class DragonflyClassLoader extends URLClassLoader {\n \n-\tpublic DragonflyClassLoader(ClassLoader classLoader) {\n+\tpublic DragonflyClassLoader(@NotNull ClassLoader classLoader) {\n \t\tsuper(new URL[0], classLoader);\n \t}\n \n \t@Override\n-\tpublic void addURL(URL url) {\n+\tpublic void addURL(@NotNull URL url) {\n \t\tsuper.addURL(url);\n \t}\n \n \t@Override\n-\tprotected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {\n+\tprotected @NotNull Class<?> loadClass(@NotNull String name, boolean resolve) throws ClassNotFoundException {\n \t\tClass<?> loadedClass = findLoadedClass(name);\n \t\tif (null == loadedClass) {\n \t\t\ttry {",
    "function_modified_lines": {
      "added": [
        "import org.jetbrains.annotations.NotNull;\n",
        "\tpublic DragonflyClassLoader(@NotNull ClassLoader classLoader) {\n",
        "\tpublic void addURL(@NotNull URL url) {\n",
        "\tprotected @NotNull Class<?> loadClass(@NotNull String name, boolean resolve) throws ClassNotFoundException {\n"
      ],
      "deleted": [
        "\tpublic DragonflyClassLoader(ClassLoader classLoader) {\n",
        "\tpublic void addURL(URL url) {\n",
        "\tprotected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "Dragonfly is a Java runtime dependency management library. Dragonfly v0.3.0-SNAPSHOT does not configure DocumentBuilderFactory to prevent XML external entity (XXE) attacks. This issue is patched in 0.3.1-SNAPSHOT. As a workaround, since Dragonfly only parses XML `SNAPSHOT` versions are being resolved, this vulnerability may be avoided by not trying to resolve `SNAPSHOT` versions.",
    "id": 12677
  },
  {
    "cve_id": "CVE-2022-41967",
    "code_before_change": "/*\n * Dragonfly - Runtime dependency management library\n *  Copyright (c) 2021 Joshua Sing <joshua@hypera.dev>\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"Software\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in all\n *  copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *  SOFTWARE.\n */\n\npackage dev.hypera.dragonfly.relocation;\n\nimport dev.hypera.dragonfly.Dragonfly;\nimport dev.hypera.dragonfly.dependency.Dependency;\nimport dev.hypera.dragonfly.exceptions.DownloadFailureException;\nimport dev.hypera.dragonfly.exceptions.LoadFailureException;\nimport dev.hypera.dragonfly.exceptions.RelocationFailureException;\nimport dev.hypera.dragonfly.loading.DependencyLoader;\nimport dev.hypera.dragonfly.loading.DragonflyClassLoader;\nimport java.io.File;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport org.jetbrains.annotations.ApiStatus.Internal;\nimport org.jetbrains.annotations.NotNull;\n\n/**\n * Dependency relocator.\n *\n * @author Joshua Sing <joshua@hypera.dev>\n */\npublic class DependencyRelocator {\n\n\tprivate static final String RELOCATED_FILENAME = \"%s-relocated.jar\";\n\n\tprivate final Dragonfly dragonfly;\n\tprivate final boolean deleteOld;\n\n\tprivate final DragonflyClassLoader classLoader;\n\tprivate final DependencyLoader dependencyLoader;\n\n\tprivate boolean dependenciesLoaded;\n\n\tprivate Constructor<?> constructor;\n\tprivate Method method;\n\n\t@Internal\n\tpublic DependencyRelocator(Dragonfly dragonfly, boolean deleteOld) {\n\t\tthis.dragonfly = dragonfly;\n\t\tthis.deleteOld = deleteOld;\n\t\tthis.classLoader = new DragonflyClassLoader(getClass().getClassLoader());\n\t\tthis.dependencyLoader = new DependencyLoader(dragonfly, classLoader::addURL);\n\t}\n\n\n\t/**\n\t * Initialise relocator.\n\t *\n\t * @throws RelocationFailureException if something went wrong while initialising.\n\t */\n\tprivate void init() throws RelocationFailureException {\n\t\tif (null == constructor && null == method) {\n\t\t\ttry {\n\t\t\t\tClass<?> clazz = classLoader.loadClass(\"me.lucko.jarrelocator.JarRelocator\");\n\n\t\t\t\tconstructor = clazz.getDeclaredConstructor(File.class, File.class, Map.class);\n\t\t\t\tmethod = clazz.getDeclaredMethod(\"run\");\n\n\t\t\t\tconstructor.setAccessible(true);\n\t\t\t\tmethod.setAccessible(true);\n\t\t\t} catch (Exception ex) {\n\t\t\t\tthrow new RelocationFailureException(ex);\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Attempt to relocate a list of dependencies.\n\t *\n\t * @param dependencies Dependencies to be relocated.\n\t * @throws RelocationFailureException if something went wrong while relocating the dependencies.\n\t * @throws DownloadFailureException   if something went wrong while downloading internal dependencies.\n\t * @throws LoadFailureException       if something went wrong while loading the internal dependencies.\n\t */\n\tpublic void relocate(@NotNull List<Dependency> dependencies) throws RelocationFailureException, DownloadFailureException, LoadFailureException {\n\t\tloadInternalDependencies(getDependencies());\n\t\tinit();\n\n\t\tfor (Dependency dependency : dependencies) {\n\t\t\tif (dependency.getRelocations().size() > 0) {\n\t\t\t\trelocate(dependency);\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Attempt to relocate a dependency.\n\t *\n\t * @param dependency Dependency to be relocated.\n\t * @throws RelocationFailureException if something went wrong while relocating the dependency.\n\t */\n\tprivate void relocate(@NotNull Dependency dependency) throws RelocationFailureException {\n\t\ttry {\n\t\t\tPath relocatedPath = getRelocatedPath(dependency);\n\t\t\tif (Files.exists(relocatedPath)) {\n\t\t\t\tdependency.setFileName(getRelocatedFileName(dependency));\n\t\t\t\tdependency.setRelocated(true);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tMap<String, String> relocations = new HashMap<>();\n\t\t\tdependency.getRelocations().forEach(r -> relocations.put(r.getFrom(), r.getTo()));\n\n\t\t\tObject object = constructor.newInstance(dragonfly.getDirectory().resolve(dependency.getFileName())\n\t\t\t\t\t.toFile(), relocatedPath.toFile(), relocations);\n\t\t\tmethod.invoke(object);\n\n\t\t\tif (deleteOld) {\n\t\t\t\tFiles.delete(dragonfly.getDirectory().resolve(dependency.getFileName()));\n\t\t\t}\n\n\t\t\tdependency.setFileName(getRelocatedFileName(dependency));\n\t\t\tdependency.setRelocated(true);\n\t\t} catch (Exception ex) {\n\t\t\tthrow new RelocationFailureException(ex);\n\t\t}\n\t}\n\n\t/**\n\t * If a dependency has been relocated or not.\n\t *\n\t * @param dependency Dependency.\n\t * @return If the given dependency has been relocated or not.\n\t */\n\tpublic boolean isRelocated(@NotNull Dependency dependency) {\n\t\tif (dependency.getRelocations().size() > 0) {\n\t\t\treturn Files.exists(getRelocatedPath(dependency));\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Get the relocated path of a dependency.\n\t *\n\t * @param dependency Dependency to get the relocated path of.\n\t * @return Relocated path of the given dependency.\n\t */\n\tpublic @NotNull Path getRelocatedPath(@NotNull Dependency dependency) {\n\t\treturn dragonfly.getDirectory().resolve(getRelocatedFileName(dependency));\n\t}\n\n\t/**\n\t * Get the relocated filename of a dependency.\n\t *\n\t * @param dependency Dependency to get the relocated filename of.\n\t * @return Relocated filename of the given dependency.\n\t */\n\tpublic @NotNull String getRelocatedFileName(@NotNull Dependency dependency) {\n\t\treturn String.format(RELOCATED_FILENAME, dependency.getFileName().split(\"\\\\.jar\")[0]);\n\t}\n\n\t/**\n\t * Attempt to download and load internal dependencies.\n\t *\n\t * @param dependencies Dependencies to be downloaded and loaded.\n\t * @throws DownloadFailureException if something went wrong while downloading the dependencies.\n\t * @throws LoadFailureException     if something went wrong while loading the dependencies.\n\t */\n\tprivate void loadInternalDependencies(List<Dependency> dependencies) throws DownloadFailureException, LoadFailureException {\n\t\tif (!dependenciesLoaded) {\n\t\t\tdragonfly.getDependencyDownloader().download(dependencies);\n\t\t\tdependencyLoader.load(dependencies);\n\t\t\tdependenciesLoaded = true;\n\t\t}\n\t}\n\n\t/**\n\t * Get internal dependencies.\n\t *\n\t * @return Internal dependencies.\n\t */\n\tpublic @NotNull List<Dependency> getDependencies() {\n\t\treturn Arrays.asList(\n\t\t\t\tDependency.maven(-3, \"org.ow2.asm\", \"asm\", \"9.2\"),\n\t\t\t\tDependency.maven(-2, \"org.ow2.asm\", \"asm-commons\", \"9.2\"),\n\t\t\t\tDependency.maven(-1, \"me.lucko\", \"jar-relocator\", \"1.5\")\n\t\t);\n\t}\n\n}\n",
    "code_after_change": "/*\n * Dragonfly - Runtime dependency management library\n *  Copyright (c) 2021 Joshua Sing <joshua@hypera.dev>\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"Software\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in all\n *  copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *  SOFTWARE.\n */\n\npackage dev.hypera.dragonfly.relocation;\n\nimport dev.hypera.dragonfly.Dragonfly;\nimport dev.hypera.dragonfly.dependency.Dependency;\nimport dev.hypera.dragonfly.exceptions.DownloadFailureException;\nimport dev.hypera.dragonfly.exceptions.LoadFailureException;\nimport dev.hypera.dragonfly.exceptions.RelocationFailureException;\nimport dev.hypera.dragonfly.loading.DependencyLoader;\nimport dev.hypera.dragonfly.loading.DragonflyClassLoader;\nimport java.io.File;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport org.jetbrains.annotations.ApiStatus.Internal;\nimport org.jetbrains.annotations.NotNull;\nimport org.jetbrains.annotations.Nullable;\n\n/**\n * Dependency relocator.\n *\n * @author Joshua Sing <joshua@hypera.dev>\n */\npublic class DependencyRelocator {\n\n\tprivate static final @NotNull String RELOCATED_FILENAME = \"%s-relocated.jar\";\n\n\tprivate final @NotNull Dragonfly dragonfly;\n\tprivate final boolean deleteOld;\n\n\tprivate final @NotNull DragonflyClassLoader classLoader;\n\tprivate final @NotNull DependencyLoader dependencyLoader;\n\n\tprivate boolean dependenciesLoaded;\n\n\tprivate @Nullable Constructor<?> constructor;\n\tprivate @Nullable Method method;\n\n\t@Internal\n\tpublic DependencyRelocator(@NotNull Dragonfly dragonfly, boolean deleteOld) {\n\t\tthis.dragonfly = dragonfly;\n\t\tthis.deleteOld = deleteOld;\n\t\tthis.classLoader = new DragonflyClassLoader(getClass().getClassLoader());\n\t\tthis.dependencyLoader = new DependencyLoader(dragonfly, classLoader::addURL);\n\t}\n\n\n\t/**\n\t * Initialise relocator.\n\t *\n\t * @throws RelocationFailureException if something went wrong while initialising.\n\t */\n\tprivate void init() throws RelocationFailureException {\n\t\tif (null == constructor && null == method) {\n\t\t\ttry {\n\t\t\t\tClass<?> clazz = classLoader.loadClass(\"me.lucko.jarrelocator.JarRelocator\");\n\n\t\t\t\tconstructor = clazz.getDeclaredConstructor(File.class, File.class, Map.class);\n\t\t\t\tmethod = clazz.getDeclaredMethod(\"run\");\n\n\t\t\t\tconstructor.setAccessible(true);\n\t\t\t\tmethod.setAccessible(true);\n\t\t\t} catch (Exception ex) {\n\t\t\t\tthrow new RelocationFailureException(ex);\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Attempt to relocate a list of dependencies.\n\t *\n\t * @param dependencies Dependencies to be relocated.\n\t * @throws RelocationFailureException if something went wrong while relocating the dependencies.\n\t * @throws DownloadFailureException   if something went wrong while downloading internal dependencies.\n\t * @throws LoadFailureException       if something went wrong while loading the internal dependencies.\n\t */\n\tpublic void relocate(@NotNull List<Dependency> dependencies) throws RelocationFailureException, DownloadFailureException, LoadFailureException {\n\t\tloadInternalDependencies(getDependencies());\n\t\tinit();\n\n\t\tfor (Dependency dependency : dependencies) {\n\t\t\tif (dependency.getRelocations().size() > 0) {\n\t\t\t\trelocate(dependency);\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Attempt to relocate a dependency.\n\t *\n\t * @param dependency Dependency to be relocated.\n\t * @throws RelocationFailureException if something went wrong while relocating the dependency.\n\t */\n\tprivate void relocate(@NotNull Dependency dependency) throws RelocationFailureException {\n\t\ttry {\n\t\t\tPath relocatedPath = getRelocatedPath(dependency);\n\t\t\tif (Files.exists(relocatedPath)) {\n\t\t\t\tdependency.setFileName(getRelocatedFileName(dependency));\n\t\t\t\tdependency.setRelocated(true);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tMap<String, String> relocations = new HashMap<>();\n\t\t\tdependency.getRelocations().forEach(r -> relocations.put(r.getFrom(), r.getTo()));\n\n\t\t\tObject object = constructor.newInstance(dragonfly.getDirectory().resolve(dependency.getFileName())\n\t\t\t\t\t.toFile(), relocatedPath.toFile(), relocations);\n\t\t\tmethod.invoke(object);\n\n\t\t\tif (deleteOld) {\n\t\t\t\tFiles.delete(dragonfly.getDirectory().resolve(dependency.getFileName()));\n\t\t\t}\n\n\t\t\tdependency.setFileName(getRelocatedFileName(dependency));\n\t\t\tdependency.setRelocated(true);\n\t\t} catch (Exception ex) {\n\t\t\tthrow new RelocationFailureException(ex);\n\t\t}\n\t}\n\n\t/**\n\t * If a dependency has been relocated or not.\n\t *\n\t * @param dependency Dependency.\n\t * @return If the given dependency has been relocated or not.\n\t */\n\tpublic boolean isRelocated(@NotNull Dependency dependency) {\n\t\tif (dependency.getRelocations().size() > 0) {\n\t\t\treturn Files.exists(getRelocatedPath(dependency));\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Get the relocated path of a dependency.\n\t *\n\t * @param dependency Dependency to get the relocated path of.\n\t * @return Relocated path of the given dependency.\n\t */\n\tpublic @NotNull Path getRelocatedPath(@NotNull Dependency dependency) {\n\t\treturn dragonfly.getDirectory().resolve(getRelocatedFileName(dependency));\n\t}\n\n\t/**\n\t * Get the relocated filename of a dependency.\n\t *\n\t * @param dependency Dependency to get the relocated filename of.\n\t * @return Relocated filename of the given dependency.\n\t */\n\tpublic @NotNull String getRelocatedFileName(@NotNull Dependency dependency) {\n\t\treturn String.format(RELOCATED_FILENAME, dependency.getFileName().split(\"\\\\.jar\")[0]);\n\t}\n\n\t/**\n\t * Attempt to download and load internal dependencies.\n\t *\n\t * @param dependencies Dependencies to be downloaded and loaded.\n\t * @throws DownloadFailureException if something went wrong while downloading the dependencies.\n\t * @throws LoadFailureException     if something went wrong while loading the dependencies.\n\t */\n\tprivate void loadInternalDependencies(List<Dependency> dependencies) throws DownloadFailureException, LoadFailureException {\n\t\tif (!dependenciesLoaded) {\n\t\t\tdragonfly.getDependencyDownloader().download(dependencies);\n\t\t\tdependencyLoader.load(dependencies);\n\t\t\tdependenciesLoaded = true;\n\t\t}\n\t}\n\n\t/**\n\t * Get internal dependencies.\n\t *\n\t * @return Internal dependencies.\n\t */\n\tpublic @NotNull List<Dependency> getDependencies() {\n\t\treturn Arrays.asList(\n\t\t\t\tDependency.maven(-3, \"org.ow2.asm\", \"asm\", \"9.2\"),\n\t\t\t\tDependency.maven(-2, \"org.ow2.asm\", \"asm-commons\", \"9.2\"),\n\t\t\t\tDependency.maven(-1, \"me.lucko\", \"jar-relocator\", \"1.5\")\n\t\t);\n\t}\n\n}\n",
    "patch": "@@ -41,6 +41,7 @@\n import java.util.Map;\n import org.jetbrains.annotations.ApiStatus.Internal;\n import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n \n /**\n  * Dependency relocator.\n@@ -49,21 +50,21 @@\n  */\n public class DependencyRelocator {\n \n-\tprivate static final String RELOCATED_FILENAME = \"%s-relocated.jar\";\n+\tprivate static final @NotNull String RELOCATED_FILENAME = \"%s-relocated.jar\";\n \n-\tprivate final Dragonfly dragonfly;\n+\tprivate final @NotNull Dragonfly dragonfly;\n \tprivate final boolean deleteOld;\n \n-\tprivate final DragonflyClassLoader classLoader;\n-\tprivate final DependencyLoader dependencyLoader;\n+\tprivate final @NotNull DragonflyClassLoader classLoader;\n+\tprivate final @NotNull DependencyLoader dependencyLoader;\n \n \tprivate boolean dependenciesLoaded;\n \n-\tprivate Constructor<?> constructor;\n-\tprivate Method method;\n+\tprivate @Nullable Constructor<?> constructor;\n+\tprivate @Nullable Method method;\n \n \t@Internal\n-\tpublic DependencyRelocator(Dragonfly dragonfly, boolean deleteOld) {\n+\tpublic DependencyRelocator(@NotNull Dragonfly dragonfly, boolean deleteOld) {\n \t\tthis.dragonfly = dragonfly;\n \t\tthis.deleteOld = deleteOld;\n \t\tthis.classLoader = new DragonflyClassLoader(getClass().getClassLoader());",
    "function_modified_lines": {
      "added": [
        "import org.jetbrains.annotations.Nullable;\n",
        "\tprivate static final @NotNull String RELOCATED_FILENAME = \"%s-relocated.jar\";\n",
        "\tprivate final @NotNull Dragonfly dragonfly;\n",
        "\tprivate final @NotNull DragonflyClassLoader classLoader;\n",
        "\tprivate final @NotNull DependencyLoader dependencyLoader;\n",
        "\tprivate @Nullable Constructor<?> constructor;\n",
        "\tprivate @Nullable Method method;\n",
        "\tpublic DependencyRelocator(@NotNull Dragonfly dragonfly, boolean deleteOld) {\n"
      ],
      "deleted": [
        "\tprivate static final String RELOCATED_FILENAME = \"%s-relocated.jar\";\n",
        "\tprivate final Dragonfly dragonfly;\n",
        "\tprivate final DragonflyClassLoader classLoader;\n",
        "\tprivate final DependencyLoader dependencyLoader;\n",
        "\tprivate Constructor<?> constructor;\n",
        "\tprivate Method method;\n",
        "\tpublic DependencyRelocator(Dragonfly dragonfly, boolean deleteOld) {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "Dragonfly is a Java runtime dependency management library. Dragonfly v0.3.0-SNAPSHOT does not configure DocumentBuilderFactory to prevent XML external entity (XXE) attacks. This issue is patched in 0.3.1-SNAPSHOT. As a workaround, since Dragonfly only parses XML `SNAPSHOT` versions are being resolved, this vulnerability may be avoided by not trying to resolve `SNAPSHOT` versions.",
    "id": 12678
  },
  {
    "cve_id": "CVE-2022-41967",
    "code_before_change": "{\n\n\tprivate final String from;\n\tprivate final String to;\n\n\tprivate Relocation(String from, String to) {\n\t\tthis.from = from.replace(\"\\\\.\", \".\");\n\t\tthis.to = to;\n\t}\n\n\tpublic static @NotNull Relocation of(@NotNull String from, @NotNull String to) {\n\t\treturn new Relocation(from, to);\n\t}\n\n\tpublic String getFrom() {\n\t\treturn from;\n\t}\n\n\tpublic String getTo() {\n\t\treturn to;\n\t}\n\n}",
    "code_after_change": "{\n\n\tprivate final @NotNull String from;\n\tprivate final @NotNull String to;\n\n\tprivate Relocation(@NotNull String from, @NotNull String to) {\n\t\tthis.from = from.replace(\"\\\\.\", \".\");\n\t\tthis.to = to;\n\t}\n\n\tpublic static @NotNull Relocation of(@NotNull String from, @NotNull String to) {\n\t\treturn new Relocation(from, to);\n\t}\n\n\tpublic @NotNull String getFrom() {\n\t\treturn from;\n\t}\n\n\tpublic @NotNull String getTo() {\n\t\treturn to;\n\t}\n\n}",
    "patch": "@@ -32,10 +32,10 @@\n  */\n public class Relocation {\n \n-\tprivate final String from;\n-\tprivate final String to;\n+\tprivate final @NotNull String from;\n+\tprivate final @NotNull String to;\n \n-\tprivate Relocation(String from, String to) {\n+\tprivate Relocation(@NotNull String from, @NotNull String to) {\n \t\tthis.from = from.replace(\"\\\\.\", \".\");\n \t\tthis.to = to;\n \t}\n@@ -44,11 +44,11 @@ private Relocation(String from, String to) {\n \t\treturn new Relocation(from, to);\n \t}\n \n-\tpublic String getFrom() {\n+\tpublic @NotNull String getFrom() {\n \t\treturn from;\n \t}\n \n-\tpublic String getTo() {\n+\tpublic @NotNull String getTo() {\n \t\treturn to;\n \t}\n ",
    "function_modified_lines": {
      "added": [
        "\tprivate final @NotNull String from;\n",
        "\tprivate final @NotNull String to;\n",
        "\tprivate Relocation(@NotNull String from, @NotNull String to) {\n",
        "\tpublic @NotNull String getFrom() {\n",
        "\tpublic @NotNull String getTo() {\n"
      ],
      "deleted": [
        "\tprivate final String from;\n",
        "\tprivate final String to;\n",
        "\tprivate Relocation(String from, String to) {\n",
        "\tpublic String getFrom() {\n",
        "\tpublic String getTo() {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "Dragonfly is a Java runtime dependency management library. Dragonfly v0.3.0-SNAPSHOT does not configure DocumentBuilderFactory to prevent XML external entity (XXE) attacks. This issue is patched in 0.3.1-SNAPSHOT. As a workaround, since Dragonfly only parses XML `SNAPSHOT` versions are being resolved, this vulnerability may be avoided by not trying to resolve `SNAPSHOT` versions.",
    "id": 12679
  },
  {
    "cve_id": "CVE-2022-41967",
    "code_before_change": "/*\n * Dragonfly - Runtime dependency management library\n *  Copyright (c) 2021 Joshua Sing <joshua@hypera.dev>\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"Software\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in all\n *  copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *  SOFTWARE.\n */\n\npackage dev.hypera.dragonfly.resolvers.impl;\n\nimport dev.hypera.dragonfly.Dragonfly;\nimport dev.hypera.dragonfly.dependency.impl.MavenDependency;\nimport dev.hypera.dragonfly.exceptions.ResolveFailureException;\nimport dev.hypera.dragonfly.resolvers.IResolver;\nimport java.io.StringReader;\nimport java.util.Set;\nimport java.util.stream.Collectors;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport org.jetbrains.annotations.NotNull;\nimport org.jetbrains.annotations.Nullable;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.xml.sax.InputSource;\n\n/**\n * Maven snapshot resolver.\n *\n * @author Joshua Sing <joshua@hypera.dev>\n */\npublic class MavenSnapshotResolver implements IResolver<MavenDependency> {\n\n\tprivate static final String FORMAT = \"%s%s/%s/%s/maven-metadata.xml\";\n\tprivate static final String OUTPUT_FORMAT = \"%s/%s-%s-%s-%s.jar\";\n\n\t@Override\n\tpublic @Nullable String resolve(@NotNull Dragonfly dragonfly, @NotNull MavenDependency dependency) throws ResolveFailureException {\n\t\tif (!dependency.getVersion().contains(\"SNAPSHOT\")) {\n\t\t\tthrow new ResolveFailureException(\"Cannot resolve a dependency as a snapshot if it isn't a snapshot\");\n\t\t} else {\n\t\t\tSet<String> urls = getUrls(dragonfly, dependency);\n\t\t\tif (urls.isEmpty()) {\n\t\t\t\tthrow new ResolveFailureException(\"Cannot resolve dependency: \" + dependency);\n\t\t\t}\n\n\t\t\tString data = null;\n\t\t\tString resolvedUrl = null;\n\t\t\tfor (String url : urls) {\n\t\t\t\tif ((data = get(url, dragonfly.getTimeout())) != null) {\n\t\t\t\t\tresolvedUrl = url;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (null == data) {\n\t\t\t\tthrow new ResolveFailureException(\"Cannot resolve dependency: \" + dependency);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tDocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n\t\t\t\tDocument document = builder.parse(new InputSource(new StringReader(data)));\n\t\t\t\tElement root = document.getDocumentElement();\n\t\t\t\tElement snapshotData = (Element) root.getElementsByTagName(\"snapshot\").item(0);\n\n\t\t\t\tString timestamp = snapshotData.getElementsByTagName(\"timestamp\").item(0).getTextContent();\n\t\t\t\tString buildNumber = snapshotData.getElementsByTagName(\"buildNumber\").item(0).getTextContent();\n\n\t\t\t\treturn String.format(\n\t\t\t\t\t\tOUTPUT_FORMAT,\n\t\t\t\t\t\tresolvedUrl.replace(\"/maven-metadata.xml\", \"\"),\n\t\t\t\t\t\tdependency.getArtifactId(),\n\t\t\t\t\t\tdependency.getVersion().replace(\"-SNAPSHOT\", \"\"),\n\t\t\t\t\t\ttimestamp,\n\t\t\t\t\t\tbuildNumber\n\t\t\t\t);\n\t\t\t} catch (Exception ex) {\n\t\t\t\tthrow new ResolveFailureException(\"Cannot resolve dependency: \" + dependency, ex);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tprivate Set<String> getUrls(@NotNull Dragonfly dragonfly, @NotNull MavenDependency dependency) {\n\t\treturn dragonfly.getRepositories().stream().map(repo -> String.format(\n\t\t\t\tFORMAT, repo,\n\t\t\t\tdependency.getGroupId().replace(\".\", \"/\"),\n\t\t\t\tdependency.getArtifactId(),\n\t\t\t\tdependency.getVersion()\n\t\t)).collect(Collectors.toSet());\n\t}\n\n}\n",
    "code_after_change": "/*\n * Dragonfly - Runtime dependency management library\n *  Copyright (c) 2021 Joshua Sing <joshua@hypera.dev>\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"Software\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in all\n *  copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *  SOFTWARE.\n */\n\npackage dev.hypera.dragonfly.resolvers.impl;\n\nimport dev.hypera.dragonfly.Dragonfly;\nimport dev.hypera.dragonfly.dependency.impl.MavenDependency;\nimport dev.hypera.dragonfly.exceptions.ResolveFailureException;\nimport dev.hypera.dragonfly.resolvers.IResolver;\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.util.Set;\nimport java.util.stream.Collectors;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.jetbrains.annotations.NotNull;\nimport org.jetbrains.annotations.Nullable;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.xml.sax.InputSource;\nimport sun.tools.jstat.ParserException;\n\n/**\n * Maven snapshot resolver.\n *\n * @author Joshua Sing <joshua@hypera.dev>\n */\npublic class MavenSnapshotResolver implements IResolver<MavenDependency> {\n\n\tprivate static final @NotNull String FORMAT = \"%s%s/%s/%s/maven-metadata.xml\";\n\tprivate static final @NotNull String OUTPUT_FORMAT = \"%s/%s-%s-%s-%s.jar\";\n\tprivate final @NotNull DocumentBuilderFactory documentBuilderFactory;\n\n\tpublic MavenSnapshotResolver() {\n\t\ttry {\n\t\t\t/* The below is an attempt to create an XML parser while preventing XML External Entity attacks */\n\t\t\t/* Read more: https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#java */\n\t\t\tDocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n\t\t\tfactory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n\t\t\tfactory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n\t\t\tfactory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n\t\t\tfactory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n\t\t\tfactory.setXIncludeAware(false);\n\t\t\tfactory.setExpandEntityReferences(false);\n\t\t\tthis.documentBuilderFactory = factory;\n\t\t} catch (ParserConfigurationException ex) {\n\t\t\tthrow new RuntimeException(\"Failed to create DocumentBuilderFactory\", ex);\n\t\t}\n\t}\n\n\t@Override\n\tpublic @Nullable String resolve(@NotNull Dragonfly dragonfly, @NotNull MavenDependency dependency) throws ResolveFailureException {\n\t\tif (!dependency.getVersion().contains(\"SNAPSHOT\")) {\n\t\t\tthrow new ResolveFailureException(\"Cannot resolve a dependency as a snapshot if it isn't a snapshot\");\n\t\t} else {\n\t\t\tSet<String> urls = getUrls(dragonfly, dependency);\n\t\t\tif (urls.isEmpty()) {\n\t\t\t\tthrow new ResolveFailureException(\"Cannot resolve dependency: \" + dependency);\n\t\t\t}\n\n\t\t\tString data = null;\n\t\t\tString resolvedUrl = null;\n\t\t\tfor (String url : urls) {\n\t\t\t\tif ((data = get(url, dragonfly.getTimeout())) != null) {\n\t\t\t\t\tresolvedUrl = url;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (null == data) {\n\t\t\t\tthrow new ResolveFailureException(\"Cannot resolve dependency: \" + dependency);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tDocumentBuilder builder = documentBuilderFactory.newDocumentBuilder();\n\t\t\t\tDocument document = builder.parse(new InputSource(new StringReader(data)));\n\t\t\t\tElement root = document.getDocumentElement();\n\t\t\t\tElement snapshotData = (Element) root.getElementsByTagName(\"snapshot\").item(0);\n\n\t\t\t\tString timestamp = snapshotData.getElementsByTagName(\"timestamp\").item(0).getTextContent();\n\t\t\t\tString buildNumber = snapshotData.getElementsByTagName(\"buildNumber\").item(0).getTextContent();\n\n\t\t\t\treturn String.format(\n\t\t\t\t\t\tOUTPUT_FORMAT,\n\t\t\t\t\t\tresolvedUrl.replace(\"/maven-metadata.xml\", \"\"),\n\t\t\t\t\t\tdependency.getArtifactId(),\n\t\t\t\t\t\tdependency.getVersion().replace(\"-SNAPSHOT\", \"\"),\n\t\t\t\t\t\ttimestamp,\n\t\t\t\t\t\tbuildNumber\n\t\t\t\t);\n\t\t\t} catch (Exception ex) {\n\t\t\t\tthrow new ResolveFailureException(\"Cannot resolve dependency: \" + dependency, ex);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tprivate Set<String> getUrls(@NotNull Dragonfly dragonfly, @NotNull MavenDependency dependency) {\n\t\treturn dragonfly.getRepositories().stream().map(repo -> String.format(\n\t\t\t\tFORMAT, repo,\n\t\t\t\tdependency.getGroupId().replace(\".\", \"/\"),\n\t\t\t\tdependency.getArtifactId(),\n\t\t\t\tdependency.getVersion()\n\t\t)).collect(Collectors.toSet());\n\t}\n\n}\n",
    "patch": "@@ -27,16 +27,19 @@\n import dev.hypera.dragonfly.dependency.impl.MavenDependency;\n import dev.hypera.dragonfly.exceptions.ResolveFailureException;\n import dev.hypera.dragonfly.resolvers.IResolver;\n+import java.io.IOException;\n import java.io.StringReader;\n import java.util.Set;\n import java.util.stream.Collectors;\n import javax.xml.parsers.DocumentBuilder;\n import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.parsers.ParserConfigurationException;\n import org.jetbrains.annotations.NotNull;\n import org.jetbrains.annotations.Nullable;\n import org.w3c.dom.Document;\n import org.w3c.dom.Element;\n import org.xml.sax.InputSource;\n+import sun.tools.jstat.ParserException;\n \n /**\n  * Maven snapshot resolver.\n@@ -45,8 +48,26 @@\n  */\n public class MavenSnapshotResolver implements IResolver<MavenDependency> {\n \n-\tprivate static final String FORMAT = \"%s%s/%s/%s/maven-metadata.xml\";\n-\tprivate static final String OUTPUT_FORMAT = \"%s/%s-%s-%s-%s.jar\";\n+\tprivate static final @NotNull String FORMAT = \"%s%s/%s/%s/maven-metadata.xml\";\n+\tprivate static final @NotNull String OUTPUT_FORMAT = \"%s/%s-%s-%s-%s.jar\";\n+\tprivate final @NotNull DocumentBuilderFactory documentBuilderFactory;\n+\n+\tpublic MavenSnapshotResolver() {\n+\t\ttry {\n+\t\t\t/* The below is an attempt to create an XML parser while preventing XML External Entity attacks */\n+\t\t\t/* Read more: https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#java */\n+\t\t\tDocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n+\t\t\tfactory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n+\t\t\tfactory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n+\t\t\tfactory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n+\t\t\tfactory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n+\t\t\tfactory.setXIncludeAware(false);\n+\t\t\tfactory.setExpandEntityReferences(false);\n+\t\t\tthis.documentBuilderFactory = factory;\n+\t\t} catch (ParserConfigurationException ex) {\n+\t\t\tthrow new RuntimeException(\"Failed to create DocumentBuilderFactory\", ex);\n+\t\t}\n+\t}\n \n \t@Override\n \tpublic @Nullable String resolve(@NotNull Dragonfly dragonfly, @NotNull MavenDependency dependency) throws ResolveFailureException {\n@@ -72,7 +93,7 @@ public class MavenSnapshotResolver implements IResolver<MavenDependency> {\n \t\t\t}\n \n \t\t\ttry {\n-\t\t\t\tDocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n+\t\t\t\tDocumentBuilder builder = documentBuilderFactory.newDocumentBuilder();\n \t\t\t\tDocument document = builder.parse(new InputSource(new StringReader(data)));\n \t\t\t\tElement root = document.getDocumentElement();\n \t\t\t\tElement snapshotData = (Element) root.getElementsByTagName(\"snapshot\").item(0);",
    "function_modified_lines": {
      "added": [
        "import java.io.IOException;\n",
        "import javax.xml.parsers.ParserConfigurationException;\n",
        "import sun.tools.jstat.ParserException;\n",
        "\tprivate static final @NotNull String FORMAT = \"%s%s/%s/%s/maven-metadata.xml\";\n",
        "\tprivate static final @NotNull String OUTPUT_FORMAT = \"%s/%s-%s-%s-%s.jar\";\n",
        "\tprivate final @NotNull DocumentBuilderFactory documentBuilderFactory;\n",
        "\n",
        "\tpublic MavenSnapshotResolver() {\n",
        "\t\ttry {\n",
        "\t\t\t/* The below is an attempt to create an XML parser while preventing XML External Entity attacks */\n",
        "\t\t\t/* Read more: https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#java */\n",
        "\t\t\tDocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n",
        "\t\t\tfactory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n",
        "\t\t\tfactory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n",
        "\t\t\tfactory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n",
        "\t\t\tfactory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n",
        "\t\t\tfactory.setXIncludeAware(false);\n",
        "\t\t\tfactory.setExpandEntityReferences(false);\n",
        "\t\t\tthis.documentBuilderFactory = factory;\n",
        "\t\t} catch (ParserConfigurationException ex) {\n",
        "\t\t\tthrow new RuntimeException(\"Failed to create DocumentBuilderFactory\", ex);\n",
        "\t\t}\n",
        "\t}\n"
      ],
      "deleted": [
        "\tprivate static final String FORMAT = \"%s%s/%s/%s/maven-metadata.xml\";\n",
        "\tprivate static final String OUTPUT_FORMAT = \"%s/%s-%s-%s-%s.jar\";\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "Dragonfly is a Java runtime dependency management library. Dragonfly v0.3.0-SNAPSHOT does not configure DocumentBuilderFactory to prevent XML external entity (XXE) attacks. This issue is patched in 0.3.1-SNAPSHOT. As a workaround, since Dragonfly only parses XML `SNAPSHOT` versions are being resolved, this vulnerability may be avoided by not trying to resolve `SNAPSHOT` versions.",
    "id": 12680
  },
  {
    "cve_id": "CVE-2022-4607",
    "code_before_change": "package vcs.citydb.wfs.operation.storedquery;\n\nimport net.opengis.fes._2.AbstractQueryExpressionType;\nimport net.opengis.fes._2.FilterType;\nimport net.opengis.fes._2.ResourceIdType;\nimport net.opengis.wfs._2.*;\nimport org.citygml4j.builder.jaxb.CityGMLBuilder;\nimport org.citygml4j.model.module.citygml.CityGMLModule;\nimport org.citygml4j.model.module.citygml.CityGMLModuleType;\nimport org.citygml4j.model.module.citygml.CityGMLVersion;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.*;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.XMLReader;\nimport vcs.citydb.wfs.config.Constants;\nimport vcs.citydb.wfs.config.WFSConfig;\nimport vcs.citydb.wfs.exception.WFSException;\nimport vcs.citydb.wfs.exception.WFSExceptionCode;\nimport vcs.citydb.wfs.kvp.KVPConstants;\nimport vcs.citydb.wfs.util.xml.NamespaceFilter;\n\nimport javax.xml.XMLConstants;\nimport javax.xml.bind.*;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.stream.XMLOutputFactory;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpression;\nimport javax.xml.xpath.XPathExpressionException;\nimport javax.xml.xpath.XPathFactory;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class StoredQueryManager {\n\tprivate final String GET_FEATURE_BY_ID_NAME = \"http://www.opengis.net/def/query/OGC-WFS/0/GetFeatureById\";\n\tprivate final String DEPRECATED_GET_FEATURE_BY_ID_NAME = \"urn:ogc:def:query:OGC-WFS::GetFeatureById\";\n\n\tprivate final StoredQuery DEFAULT_QUERY;\n\tprivate final CityGMLBuilder cityGMLBuilder;\n\tprivate final SAXParserFactory saxParserFactory;\n\tprivate final TransformerFactory transformerFactory;\n\tprivate final DocumentBuilderFactory documentBuilderFactory;\n\tprivate final XMLOutputFactory xmlOutputFactory;\n\tprivate final Path storedQueriesPath;\n\tprivate final ObjectFactory wfsFactory;\n\tprivate final WFSConfig wfsConfig;\n\tprivate final MessageDigest md5;\n\n\tpublic StoredQueryManager(CityGMLBuilder cityGMLBuilder, SAXParserFactory saxParserFactory, String path, WFSConfig wfsConfig) throws ParserConfigurationException, SAXException, NoSuchAlgorithmException, IOException {\n\t\tthis.cityGMLBuilder = cityGMLBuilder;\n\t\tthis.saxParserFactory = saxParserFactory;\n\t\tthis.wfsConfig = wfsConfig;\n\n\t\tmd5 = MessageDigest.getInstance(\"MD5\");\n\t\twfsFactory = new ObjectFactory();\n\t\ttransformerFactory = TransformerFactory.newInstance();\n\t\txmlOutputFactory = XMLOutputFactory.newInstance();\n\t\tdocumentBuilderFactory = DocumentBuilderFactory.newInstance();\n\t\tdocumentBuilderFactory.setNamespaceAware(true);\n\n\t\tstoredQueriesPath = Paths.get(path);\n\t\tFiles.createDirectories(storedQueriesPath);\n\t\tif (!Files.isDirectory(storedQueriesPath) || !Files.isReadable(storedQueriesPath))",
    "code_after_change": "package vcs.citydb.wfs.operation.storedquery;\n\nimport net.opengis.fes._2.AbstractQueryExpressionType;\nimport net.opengis.fes._2.FilterType;\nimport net.opengis.fes._2.ResourceIdType;\nimport net.opengis.wfs._2.*;\nimport org.citydb.util.xml.SecureXMLProcessors;\nimport org.citygml4j.builder.jaxb.CityGMLBuilder;\nimport org.citygml4j.model.module.citygml.CityGMLModule;\nimport org.citygml4j.model.module.citygml.CityGMLModuleType;\nimport org.citygml4j.model.module.citygml.CityGMLVersion;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.*;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.XMLReader;\nimport vcs.citydb.wfs.config.Constants;\nimport vcs.citydb.wfs.config.WFSConfig;\nimport vcs.citydb.wfs.exception.WFSException;\nimport vcs.citydb.wfs.exception.WFSExceptionCode;\nimport vcs.citydb.wfs.kvp.KVPConstants;\nimport vcs.citydb.wfs.util.xml.NamespaceFilter;\n\nimport javax.xml.XMLConstants;\nimport javax.xml.bind.*;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.stream.XMLOutputFactory;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpression;\nimport javax.xml.xpath.XPathExpressionException;\nimport javax.xml.xpath.XPathFactory;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.nio.file.DirectoryStream;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class StoredQueryManager {\n\tprivate final String GET_FEATURE_BY_ID_NAME = \"http://www.opengis.net/def/query/OGC-WFS/0/GetFeatureById\";\n\tprivate final String DEPRECATED_GET_FEATURE_BY_ID_NAME = \"urn:ogc:def:query:OGC-WFS::GetFeatureById\";\n\n\tprivate final StoredQuery DEFAULT_QUERY;\n\tprivate final CityGMLBuilder cityGMLBuilder;\n\tprivate final SAXParserFactory saxParserFactory;\n\tprivate final TransformerFactory transformerFactory;\n\tprivate final DocumentBuilderFactory documentBuilderFactory;\n\tprivate final XMLOutputFactory xmlOutputFactory;\n\tprivate final Path storedQueriesPath;\n\tprivate final ObjectFactory wfsFactory;\n\tprivate final WFSConfig wfsConfig;\n\tprivate final MessageDigest md5;\n\n\tpublic StoredQueryManager(CityGMLBuilder cityGMLBuilder, SAXParserFactory saxParserFactory, String path, WFSConfig wfsConfig) throws ParserConfigurationException, SAXException, NoSuchAlgorithmException, IOException, TransformerConfigurationException {\n\t\tthis.cityGMLBuilder = cityGMLBuilder;\n\t\tthis.saxParserFactory = saxParserFactory;\n\t\tthis.wfsConfig = wfsConfig;\n\n\t\tmd5 = MessageDigest.getInstance(\"MD5\");\n\t\twfsFactory = new ObjectFactory();\n\t\ttransformerFactory = SecureXMLProcessors.newTransformerFactory();\n\t\txmlOutputFactory = XMLOutputFactory.newInstance();\n\t\tdocumentBuilderFactory = SecureXMLProcessors.newDocumentBuilderFactory();\n\t\tdocumentBuilderFactory.setNamespaceAware(true);\n\n\t\tstoredQueriesPath = Paths.get(path);",
    "patch": "@@ -4,6 +4,7 @@\n import net.opengis.fes._2.FilterType;\n import net.opengis.fes._2.ResourceIdType;\n import net.opengis.wfs._2.*;\n+import org.citydb.util.xml.SecureXMLProcessors;\n import org.citygml4j.builder.jaxb.CityGMLBuilder;\n import org.citygml4j.model.module.citygml.CityGMLModule;\n import org.citygml4j.model.module.citygml.CityGMLModuleType;\n@@ -27,6 +28,7 @@\n import javax.xml.parsers.SAXParser;\n import javax.xml.parsers.SAXParserFactory;\n import javax.xml.stream.XMLOutputFactory;\n+import javax.xml.transform.TransformerConfigurationException;\n import javax.xml.transform.TransformerFactory;\n import javax.xml.xpath.XPathConstants;\n import javax.xml.xpath.XPathExpression;\n@@ -35,6 +37,7 @@\n import java.io.BufferedReader;\n import java.io.FileReader;\n import java.io.IOException;\n+import java.nio.file.DirectoryStream;\n import java.nio.file.Files;\n import java.nio.file.Path;\n import java.nio.file.Paths;\n@@ -58,16 +61,16 @@ public class StoredQueryManager {\n \tprivate final WFSConfig wfsConfig;\n \tprivate final MessageDigest md5;\n \n-\tpublic StoredQueryManager(CityGMLBuilder cityGMLBuilder, SAXParserFactory saxParserFactory, String path, WFSConfig wfsConfig) throws ParserConfigurationException, SAXException, NoSuchAlgorithmException, IOException {\n+\tpublic StoredQueryManager(CityGMLBuilder cityGMLBuilder, SAXParserFactory saxParserFactory, String path, WFSConfig wfsConfig) throws ParserConfigurationException, SAXException, NoSuchAlgorithmException, IOException, TransformerConfigurationException {\n \t\tthis.cityGMLBuilder = cityGMLBuilder;\n \t\tthis.saxParserFactory = saxParserFactory;\n \t\tthis.wfsConfig = wfsConfig;\n \n \t\tmd5 = MessageDigest.getInstance(\"MD5\");\n \t\twfsFactory = new ObjectFactory();\n-\t\ttransformerFactory = TransformerFactory.newInstance();\n+\t\ttransformerFactory = SecureXMLProcessors.newTransformerFactory();\n \t\txmlOutputFactory = XMLOutputFactory.newInstance();\n-\t\tdocumentBuilderFactory = DocumentBuilderFactory.newInstance();\n+\t\tdocumentBuilderFactory = SecureXMLProcessors.newDocumentBuilderFactory();\n \t\tdocumentBuilderFactory.setNamespaceAware(true);\n \n \t\tstoredQueriesPath = Paths.get(path);\n@@ -83,9 +86,11 @@ public List<StoredQueryAdapter> listStoredQueries(String handle) throws WFSExcep\n \t\tstoredQueries.add(new StoredQueryAdapter(DEFAULT_QUERY.getId()));\n \n \t\ttry {\n-\t\t\tfor (Path file : Files.newDirectoryStream(storedQueriesPath)) {\n-\t\t\t\tif (Files.isRegularFile(file))\n-\t\t\t\t\tstoredQueries.add(new StoredQueryAdapter(file));\n+\t\t\ttry (DirectoryStream<Path> stream = Files.newDirectoryStream(storedQueriesPath)) {\n+\t\t\t\tfor (Path file : stream) {\n+\t\t\t\t\tif (Files.isRegularFile(file))\n+\t\t\t\t\t\tstoredQueries.add(new StoredQueryAdapter(file));\n+\t\t\t\t}\n \t\t\t}\n \t\t} catch (IOException e) {\n \t\t\tthrow new WFSException(WFSExceptionCode.OPERATION_PROCESSING_FAILED, \"Failed to list stored queries.\", handle, e);",
    "function_modified_lines": {
      "added": [
        "import javax.xml.transform.TransformerConfigurationException;\n",
        "import java.nio.file.DirectoryStream;\n"
      ],
      "deleted": []
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "A vulnerability was found in 3D City Database OGC Web Feature Service up to 5.2.0. It has been rated as problematic. This issue affects some unknown processing. The manipulation leads to xml external entity reference. Upgrading to version 5.2.1 is able to address this issue. The name of the patch is 246f4e2a97ad81491c00a7ed72ce5e7c7f75050a. It is recommended to upgrade the affected component. The associated identifier of this vulnerability is VDB-216215.",
    "id": 12688
  },
  {
    "cve_id": "CVE-2022-4607",
    "code_before_change": "import javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.stream.XMLOutputFactory;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpression;\nimport javax.xml.xpath.XPathExpressionException;\nimport javax.xml.xpath.XPathFactory;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class StoredQueryManager {\n\tprivate final String GET_FEATURE_BY_ID_NAME = \"http://www.opengis.net/def/query/OGC-WFS/0/GetFeatureById\";\n\tprivate final String DEPRECATED_GET_FEATURE_BY_ID_NAME = \"urn:ogc:def:query:OGC-WFS::GetFeatureById\";\n\n\tprivate final StoredQuery DEFAULT_QUERY;\n\tprivate final CityGMLBuilder cityGMLBuilder;\n\tprivate final SAXParserFactory saxParserFactory;\n\tprivate final TransformerFactory transformerFactory;\n\tprivate final DocumentBuilderFactory documentBuilderFactory;\n\tprivate final XMLOutputFactory xmlOutputFactory;\n\tprivate final Path storedQueriesPath;\n\tprivate final ObjectFactory wfsFactory;\n\tprivate final WFSConfig wfsConfig;\n\tprivate final MessageDigest md5;\n\n\tpublic StoredQueryManager(CityGMLBuilder cityGMLBuilder, SAXParserFactory saxParserFactory, String path, WFSConfig wfsConfig) throws ParserConfigurationException, SAXException, NoSuchAlgorithmException, IOException {\n\t\tthis.cityGMLBuilder = cityGMLBuilder;\n\t\tthis.saxParserFactory = saxParserFactory;\n\t\tthis.wfsConfig = wfsConfig;\n\n\t\tmd5 = MessageDigest.getInstance(\"MD5\");\n\t\twfsFactory = new ObjectFactory();\n\t\ttransformerFactory = TransformerFactory.newInstance();\n\t\txmlOutputFactory = XMLOutputFactory.newInstance();\n\t\tdocumentBuilderFactory = DocumentBuilderFactory.newInstance();\n\t\tdocumentBuilderFactory.setNamespaceAware(true);\n\n\t\tstoredQueriesPath = Paths.get(path);\n\t\tFiles.createDirectories(storedQueriesPath);\n\t\tif (!Files.isDirectory(storedQueriesPath) || !Files.isReadable(storedQueriesPath))\n\t\t\tthrow new IOException(\"Path for stored queries is not readable.\");\n\n\t\tDEFAULT_QUERY = createDefaultStoredQuery();\n\t}\n\n\tpublic List<StoredQueryAdapter> listStoredQueries(String handle) throws WFSException {\n\t\tList<StoredQueryAdapter> storedQueries = new ArrayList<>();\n\t\tstoredQueries.add(new StoredQueryAdapter(DEFAULT_QUERY.getId()));\n\n\t\ttry {\n\t\t\tfor (Path file : Files.newDirectoryStream(storedQueriesPath)) {\n\t\t\t\tif (Files.isRegularFile(file))\n\t\t\t\t\tstoredQueries.add(new StoredQueryAdapter(file));\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new WFSException(WFSExceptionCode.OPERATION_PROCESSING_FAILED, \"Failed to list stored queries.\", handle, e);\n\t\t}\n\n\t\treturn storedQueries;\n\t}\n\n\tpublic StoredQuery getStoredQuery(StoredQueryAdapter adapter, String handle) throws WFSException {\n\t\t// urn:ogc:def:query:OGC-WFS::GetFeatureById is deprecated since 2.0.2 but still supported\n\t\tif (GET_FEATURE_BY_ID_NAME.equals(adapter.getId()) || DEPRECATED_GET_FEATURE_BY_ID_NAME.equals(adapter.getId()))\n\t\t\treturn DEFAULT_QUERY;\n\n\t\tPath file = adapter.isSetId() ? storedQueriesPath.resolve(getFileName(adapter.getId())) : adapter.getFile();\n\t\tif (!Files.exists(file))\n\t\t\tthrow new WFSException(WFSExceptionCode.INVALID_PARAMETER_VALUE, \"A stored query with identifier '\" + adapter.getId() + \"' is not offered by this server.\", KVPConstants.STOREDQUERY_ID);\n\n\t\treturn unmarshalStoredQuery(file, handle);",
    "code_after_change": "import javax.xml.stream.XMLOutputFactory;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpression;\nimport javax.xml.xpath.XPathExpressionException;\nimport javax.xml.xpath.XPathFactory;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.nio.file.DirectoryStream;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class StoredQueryManager {\n\tprivate final String GET_FEATURE_BY_ID_NAME = \"http://www.opengis.net/def/query/OGC-WFS/0/GetFeatureById\";\n\tprivate final String DEPRECATED_GET_FEATURE_BY_ID_NAME = \"urn:ogc:def:query:OGC-WFS::GetFeatureById\";\n\n\tprivate final StoredQuery DEFAULT_QUERY;\n\tprivate final CityGMLBuilder cityGMLBuilder;\n\tprivate final SAXParserFactory saxParserFactory;\n\tprivate final TransformerFactory transformerFactory;\n\tprivate final DocumentBuilderFactory documentBuilderFactory;\n\tprivate final XMLOutputFactory xmlOutputFactory;\n\tprivate final Path storedQueriesPath;\n\tprivate final ObjectFactory wfsFactory;\n\tprivate final WFSConfig wfsConfig;\n\tprivate final MessageDigest md5;\n\n\tpublic StoredQueryManager(CityGMLBuilder cityGMLBuilder, SAXParserFactory saxParserFactory, String path, WFSConfig wfsConfig) throws ParserConfigurationException, SAXException, NoSuchAlgorithmException, IOException, TransformerConfigurationException {\n\t\tthis.cityGMLBuilder = cityGMLBuilder;\n\t\tthis.saxParserFactory = saxParserFactory;\n\t\tthis.wfsConfig = wfsConfig;\n\n\t\tmd5 = MessageDigest.getInstance(\"MD5\");\n\t\twfsFactory = new ObjectFactory();\n\t\ttransformerFactory = SecureXMLProcessors.newTransformerFactory();\n\t\txmlOutputFactory = XMLOutputFactory.newInstance();\n\t\tdocumentBuilderFactory = SecureXMLProcessors.newDocumentBuilderFactory();\n\t\tdocumentBuilderFactory.setNamespaceAware(true);\n\n\t\tstoredQueriesPath = Paths.get(path);\n\t\tFiles.createDirectories(storedQueriesPath);\n\t\tif (!Files.isDirectory(storedQueriesPath) || !Files.isReadable(storedQueriesPath))\n\t\t\tthrow new IOException(\"Path for stored queries is not readable.\");\n\n\t\tDEFAULT_QUERY = createDefaultStoredQuery();\n\t}\n\n\tpublic List<StoredQueryAdapter> listStoredQueries(String handle) throws WFSException {\n\t\tList<StoredQueryAdapter> storedQueries = new ArrayList<>();\n\t\tstoredQueries.add(new StoredQueryAdapter(DEFAULT_QUERY.getId()));\n\n\t\ttry {\n\t\t\ttry (DirectoryStream<Path> stream = Files.newDirectoryStream(storedQueriesPath)) {\n\t\t\t\tfor (Path file : stream) {\n\t\t\t\t\tif (Files.isRegularFile(file))\n\t\t\t\t\t\tstoredQueries.add(new StoredQueryAdapter(file));\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new WFSException(WFSExceptionCode.OPERATION_PROCESSING_FAILED, \"Failed to list stored queries.\", handle, e);\n\t\t}\n\n\t\treturn storedQueries;\n\t}\n\n\tpublic StoredQuery getStoredQuery(StoredQueryAdapter adapter, String handle) throws WFSException {\n\t\t// urn:ogc:def:query:OGC-WFS::GetFeatureById is deprecated since 2.0.2 but still supported\n\t\tif (GET_FEATURE_BY_ID_NAME.equals(adapter.getId()) || DEPRECATED_GET_FEATURE_BY_ID_NAME.equals(adapter.getId()))\n\t\t\treturn DEFAULT_QUERY;\n\n\t\tPath file = adapter.isSetId() ? storedQueriesPath.resolve(getFileName(adapter.getId())) : adapter.getFile();\n\t\tif (!Files.exists(file))\n\t\t\tthrow new WFSException(WFSExceptionCode.INVALID_PARAMETER_VALUE, \"A stored query with identifier '\" + adapter.getId() + \"' is not offered by this server.\", KVPConstants.STOREDQUERY_ID);",
    "patch": "@@ -4,6 +4,7 @@\n import net.opengis.fes._2.FilterType;\n import net.opengis.fes._2.ResourceIdType;\n import net.opengis.wfs._2.*;\n+import org.citydb.util.xml.SecureXMLProcessors;\n import org.citygml4j.builder.jaxb.CityGMLBuilder;\n import org.citygml4j.model.module.citygml.CityGMLModule;\n import org.citygml4j.model.module.citygml.CityGMLModuleType;\n@@ -27,6 +28,7 @@\n import javax.xml.parsers.SAXParser;\n import javax.xml.parsers.SAXParserFactory;\n import javax.xml.stream.XMLOutputFactory;\n+import javax.xml.transform.TransformerConfigurationException;\n import javax.xml.transform.TransformerFactory;\n import javax.xml.xpath.XPathConstants;\n import javax.xml.xpath.XPathExpression;\n@@ -35,6 +37,7 @@\n import java.io.BufferedReader;\n import java.io.FileReader;\n import java.io.IOException;\n+import java.nio.file.DirectoryStream;\n import java.nio.file.Files;\n import java.nio.file.Path;\n import java.nio.file.Paths;\n@@ -58,16 +61,16 @@ public class StoredQueryManager {\n \tprivate final WFSConfig wfsConfig;\n \tprivate final MessageDigest md5;\n \n-\tpublic StoredQueryManager(CityGMLBuilder cityGMLBuilder, SAXParserFactory saxParserFactory, String path, WFSConfig wfsConfig) throws ParserConfigurationException, SAXException, NoSuchAlgorithmException, IOException {\n+\tpublic StoredQueryManager(CityGMLBuilder cityGMLBuilder, SAXParserFactory saxParserFactory, String path, WFSConfig wfsConfig) throws ParserConfigurationException, SAXException, NoSuchAlgorithmException, IOException, TransformerConfigurationException {\n \t\tthis.cityGMLBuilder = cityGMLBuilder;\n \t\tthis.saxParserFactory = saxParserFactory;\n \t\tthis.wfsConfig = wfsConfig;\n \n \t\tmd5 = MessageDigest.getInstance(\"MD5\");\n \t\twfsFactory = new ObjectFactory();\n-\t\ttransformerFactory = TransformerFactory.newInstance();\n+\t\ttransformerFactory = SecureXMLProcessors.newTransformerFactory();\n \t\txmlOutputFactory = XMLOutputFactory.newInstance();\n-\t\tdocumentBuilderFactory = DocumentBuilderFactory.newInstance();\n+\t\tdocumentBuilderFactory = SecureXMLProcessors.newDocumentBuilderFactory();\n \t\tdocumentBuilderFactory.setNamespaceAware(true);\n \n \t\tstoredQueriesPath = Paths.get(path);\n@@ -83,9 +86,11 @@ public List<StoredQueryAdapter> listStoredQueries(String handle) throws WFSExcep\n \t\tstoredQueries.add(new StoredQueryAdapter(DEFAULT_QUERY.getId()));\n \n \t\ttry {\n-\t\t\tfor (Path file : Files.newDirectoryStream(storedQueriesPath)) {\n-\t\t\t\tif (Files.isRegularFile(file))\n-\t\t\t\t\tstoredQueries.add(new StoredQueryAdapter(file));\n+\t\t\ttry (DirectoryStream<Path> stream = Files.newDirectoryStream(storedQueriesPath)) {\n+\t\t\t\tfor (Path file : stream) {\n+\t\t\t\t\tif (Files.isRegularFile(file))\n+\t\t\t\t\t\tstoredQueries.add(new StoredQueryAdapter(file));\n+\t\t\t\t}\n \t\t\t}\n \t\t} catch (IOException e) {\n \t\t\tthrow new WFSException(WFSExceptionCode.OPERATION_PROCESSING_FAILED, \"Failed to list stored queries.\", handle, e);",
    "function_modified_lines": {
      "added": [
        "\tpublic StoredQueryManager(CityGMLBuilder cityGMLBuilder, SAXParserFactory saxParserFactory, String path, WFSConfig wfsConfig) throws ParserConfigurationException, SAXException, NoSuchAlgorithmException, IOException, TransformerConfigurationException {\n",
        "\t\ttransformerFactory = SecureXMLProcessors.newTransformerFactory();\n",
        "\t\tdocumentBuilderFactory = SecureXMLProcessors.newDocumentBuilderFactory();\n"
      ],
      "deleted": [
        "\tpublic StoredQueryManager(CityGMLBuilder cityGMLBuilder, SAXParserFactory saxParserFactory, String path, WFSConfig wfsConfig) throws ParserConfigurationException, SAXException, NoSuchAlgorithmException, IOException {\n",
        "\t\ttransformerFactory = TransformerFactory.newInstance();\n",
        "\t\tdocumentBuilderFactory = DocumentBuilderFactory.newInstance();\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "A vulnerability was found in 3D City Database OGC Web Feature Service up to 5.2.0. It has been rated as problematic. This issue affects some unknown processing. The manipulation leads to xml external entity reference. Upgrading to version 5.2.1 is able to address this issue. The name of the patch is 246f4e2a97ad81491c00a7ed72ce5e7c7f75050a. It is recommended to upgrade the affected component. The associated identifier of this vulnerability is VDB-216215.",
    "id": 12689
  },
  {
    "cve_id": "CVE-2022-4607",
    "code_before_change": "{\n\t\t\tfor (Path file : Files.newDirectoryStream(storedQueriesPath)) {\n\t\t\t\tif (Files.isRegularFile(file))\n\t\t\t\t\tstoredQueries.add(new StoredQueryAdapter(file));\n\t\t\t}\n\t\t}",
    "code_after_change": "{\n\t\t\ttry (DirectoryStream<Path> stream = Files.newDirectoryStream(storedQueriesPath)) {\n\t\t\t\tfor (Path file : stream) {\n\t\t\t\t\tif (Files.isRegularFile(file))\n\t\t\t\t\t\tstoredQueries.add(new StoredQueryAdapter(file));\n\t\t\t\t}\n\t\t\t}\n\t\t}",
    "patch": "@@ -4,6 +4,7 @@\n import net.opengis.fes._2.FilterType;\n import net.opengis.fes._2.ResourceIdType;\n import net.opengis.wfs._2.*;\n+import org.citydb.util.xml.SecureXMLProcessors;\n import org.citygml4j.builder.jaxb.CityGMLBuilder;\n import org.citygml4j.model.module.citygml.CityGMLModule;\n import org.citygml4j.model.module.citygml.CityGMLModuleType;\n@@ -27,6 +28,7 @@\n import javax.xml.parsers.SAXParser;\n import javax.xml.parsers.SAXParserFactory;\n import javax.xml.stream.XMLOutputFactory;\n+import javax.xml.transform.TransformerConfigurationException;\n import javax.xml.transform.TransformerFactory;\n import javax.xml.xpath.XPathConstants;\n import javax.xml.xpath.XPathExpression;\n@@ -35,6 +37,7 @@\n import java.io.BufferedReader;\n import java.io.FileReader;\n import java.io.IOException;\n+import java.nio.file.DirectoryStream;\n import java.nio.file.Files;\n import java.nio.file.Path;\n import java.nio.file.Paths;\n@@ -58,16 +61,16 @@ public class StoredQueryManager {\n \tprivate final WFSConfig wfsConfig;\n \tprivate final MessageDigest md5;\n \n-\tpublic StoredQueryManager(CityGMLBuilder cityGMLBuilder, SAXParserFactory saxParserFactory, String path, WFSConfig wfsConfig) throws ParserConfigurationException, SAXException, NoSuchAlgorithmException, IOException {\n+\tpublic StoredQueryManager(CityGMLBuilder cityGMLBuilder, SAXParserFactory saxParserFactory, String path, WFSConfig wfsConfig) throws ParserConfigurationException, SAXException, NoSuchAlgorithmException, IOException, TransformerConfigurationException {\n \t\tthis.cityGMLBuilder = cityGMLBuilder;\n \t\tthis.saxParserFactory = saxParserFactory;\n \t\tthis.wfsConfig = wfsConfig;\n \n \t\tmd5 = MessageDigest.getInstance(\"MD5\");\n \t\twfsFactory = new ObjectFactory();\n-\t\ttransformerFactory = TransformerFactory.newInstance();\n+\t\ttransformerFactory = SecureXMLProcessors.newTransformerFactory();\n \t\txmlOutputFactory = XMLOutputFactory.newInstance();\n-\t\tdocumentBuilderFactory = DocumentBuilderFactory.newInstance();\n+\t\tdocumentBuilderFactory = SecureXMLProcessors.newDocumentBuilderFactory();\n \t\tdocumentBuilderFactory.setNamespaceAware(true);\n \n \t\tstoredQueriesPath = Paths.get(path);\n@@ -83,9 +86,11 @@ public List<StoredQueryAdapter> listStoredQueries(String handle) throws WFSExcep\n \t\tstoredQueries.add(new StoredQueryAdapter(DEFAULT_QUERY.getId()));\n \n \t\ttry {\n-\t\t\tfor (Path file : Files.newDirectoryStream(storedQueriesPath)) {\n-\t\t\t\tif (Files.isRegularFile(file))\n-\t\t\t\t\tstoredQueries.add(new StoredQueryAdapter(file));\n+\t\t\ttry (DirectoryStream<Path> stream = Files.newDirectoryStream(storedQueriesPath)) {\n+\t\t\t\tfor (Path file : stream) {\n+\t\t\t\t\tif (Files.isRegularFile(file))\n+\t\t\t\t\t\tstoredQueries.add(new StoredQueryAdapter(file));\n+\t\t\t\t}\n \t\t\t}\n \t\t} catch (IOException e) {\n \t\t\tthrow new WFSException(WFSExceptionCode.OPERATION_PROCESSING_FAILED, \"Failed to list stored queries.\", handle, e);",
    "function_modified_lines": {
      "added": [
        "\t\t\ttry (DirectoryStream<Path> stream = Files.newDirectoryStream(storedQueriesPath)) {\n",
        "\t\t\t\tfor (Path file : stream) {\n",
        "\t\t\t\t\tif (Files.isRegularFile(file))\n",
        "\t\t\t\t\t\tstoredQueries.add(new StoredQueryAdapter(file));\n",
        "\t\t\t\t}\n"
      ],
      "deleted": [
        "\t\t\tfor (Path file : Files.newDirectoryStream(storedQueriesPath)) {\n",
        "\t\t\t\tif (Files.isRegularFile(file))\n",
        "\t\t\t\t\tstoredQueries.add(new StoredQueryAdapter(file));\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "A vulnerability was found in 3D City Database OGC Web Feature Service up to 5.2.0. It has been rated as problematic. This issue affects some unknown processing. The manipulation leads to xml external entity reference. Upgrading to version 5.2.1 is able to address this issue. The name of the patch is 246f4e2a97ad81491c00a7ed72ce5e7c7f75050a. It is recommended to upgrade the affected component. The associated identifier of this vulnerability is VDB-216215.",
    "id": 12690
  },
  {
    "cve_id": "CVE-2023-4218",
    "code_before_change": "/*******************************************************************************\n * Copyright (c) 2000, 2018 IBM Corporation and others.\n *\n * This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n *\n * Contributors:\n *     IBM Corporation - initial API and implementation\n *******************************************************************************/\npackage org.eclipse.text.templates;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.MissingResourceException;\nimport java.util.ResourceBundle;\nimport java.util.Set;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.DefaultHandler;\n\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.Text;\n\nimport org.eclipse.osgi.util.NLS;\n\nimport org.eclipse.core.runtime.Assert;\nimport org.eclipse.core.runtime.ILog;\nimport org.eclipse.core.runtime.IStatus;\nimport org.eclipse.core.runtime.Platform;\nimport org.eclipse.core.runtime.Status;\n\nimport org.eclipse.jface.text.templates.Template;\n\n/**\n * Serializes templates as character or byte stream and reads the same format\n * back.\n * <p>\n * Clients may instantiate this class, it is not intended to be\n * subclassed.</p>\n *\n * @since 3.7\n * @noextend This class is not intended to be subclassed by clients.\n */\npublic class TemplateReaderWriter {\n",
    "code_after_change": "/*******************************************************************************\n * Copyright (c) 2000, 2018 IBM Corporation and others.\n *\n * This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n *\n * Contributors:\n *     IBM Corporation - initial API and implementation\n *******************************************************************************/\npackage org.eclipse.text.templates;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.MissingResourceException;\nimport java.util.ResourceBundle;\nimport java.util.Set;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.DefaultHandler;\n\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.Text;\n\nimport org.eclipse.osgi.util.NLS;\n\nimport org.eclipse.core.runtime.Assert;\nimport org.eclipse.core.runtime.ILog;\nimport org.eclipse.core.runtime.IStatus;\nimport org.eclipse.core.runtime.Platform;\nimport org.eclipse.core.runtime.Status;\n\nimport org.eclipse.jface.text.templates.Template;\n\n/**\n * Serializes templates as character or byte stream and reads the same format\n * back.\n * <p>\n * Clients may instantiate this class, it is not intended to be\n * subclassed.</p>\n *\n * @since 3.7\n * @noextend This class is not intended to be subclassed by clients.\n */\npublic class TemplateReaderWriter {\n\n\tprivate static final String TEMPLATE_ROOT = \"templates\"; //$NON-NLS-1$\n\tprivate static final String TEMPLATE_ELEMENT = \"template\"; //$NON-NLS-1$",
    "patch": "@@ -27,12 +27,10 @@\n import java.util.Set;\n \n import javax.xml.parsers.DocumentBuilder;\n-import javax.xml.parsers.DocumentBuilderFactory;\n import javax.xml.parsers.ParserConfigurationException;\n import javax.xml.transform.OutputKeys;\n import javax.xml.transform.Transformer;\n import javax.xml.transform.TransformerException;\n-import javax.xml.transform.TransformerFactory;\n import javax.xml.transform.dom.DOMSource;\n import javax.xml.transform.stream.StreamResult;\n \n@@ -157,8 +155,8 @@ private TemplatePersistenceData[] read(InputSource source, ResourceBundle bundle\n \t\t\tCollection<TemplatePersistenceData> templates= new ArrayList<>();\n \t\t\tSet<String> ids= new HashSet<>();\n \n-\t\t\tDocumentBuilderFactory factory= DocumentBuilderFactory.newInstance();\n-\t\t\tDocumentBuilder parser= factory.newDocumentBuilder();\n+\t\t\t@SuppressWarnings(\"restriction\")\n+\t\t\tDocumentBuilder parser= org.eclipse.core.internal.runtime.XmlProcessorFactory.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tparser.setErrorHandler(new DefaultHandler());\n \t\t\tDocument document= parser.parse(source);\n \n@@ -263,10 +261,8 @@ public void save(TemplatePersistenceData[] templates, Writer writer) throws IOEx\n \t */\n \tprivate void save(TemplatePersistenceData[] templates, StreamResult result) throws IOException {\n \t\ttry {\n-\t\t\tDocumentBuilderFactory factory= DocumentBuilderFactory.newInstance();\n-\t\t\tDocumentBuilder builder= factory.newDocumentBuilder();\n-\t\t\tDocument document= builder.newDocument();\n-\n+\t\t\t@SuppressWarnings(\"restriction\")\n+\t\t\tDocument document= org.eclipse.core.internal.runtime.XmlProcessorFactory.newDocumentWithErrorOnDOCTYPE();\n \t\t\tNode root= document.createElement(TEMPLATE_ROOT);\n \t\t\tdocument.appendChild(root);\n \n@@ -322,9 +318,8 @@ private void save(TemplatePersistenceData[] templates, StreamResult result) thro\n \t\t\t\t\tnode.appendChild(pattern);\n \t\t\t\t}\n \t\t\t}\n-\n-\n-\t\t\tTransformer transformer=TransformerFactory.newInstance().newTransformer();\n+\t\t\t@SuppressWarnings(\"restriction\")\n+\t\t\tTransformer transformer= org.eclipse.core.internal.runtime.XmlProcessorFactory.createTransformerFactoryWithErrorOnDOCTYPE().newTransformer();\n \t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n \t\t\ttransformer.setOutputProperty(OutputKeys.ENCODING, StandardCharsets.UTF_8.name());\n \t\t\tDOMSource source = new DOMSource(document);",
    "function_modified_lines": {
      "added": [],
      "deleted": [
        "import javax.xml.parsers.DocumentBuilderFactory;\n",
        "import javax.xml.transform.TransformerFactory;\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "In Eclipse IDE versions < 2023-09 (4.29) some files with xml content are parsed vulnerable against all sorts of XXE attacks. The user just needs to open any evil project or update an open project with a vulnerable file (for example for review a foreign repository or patch).\n",
    "id": 12847
  },
  {
    "cve_id": "CVE-2023-4218",
    "code_before_change": "{\n\n\t\tdocumentBuilderFactory.setNamespaceAware(true);\n\t\tdocumentBuilderFactory.setIgnoringComments(true);\n\n\t\treset();\n\t\ttry {\n\t\t\tDocumentBuilder parser = documentBuilderFactory\n\t\t\t\t\t.newDocumentBuilder();\n\t\t\tparser.setErrorHandler(new ParseErrorHandler());\n\t\t\tInputSource source = new InputSource(is);\n\t\t\tDocument doc = parser.parse(source);\n\t\t\tprocessDocument(doc, expandURLs);\n\t\t} catch (ParserConfigurationException | SAXException e) {\n\t\t\tSWT.error(SWT.ERROR_INVALID_ARGUMENT, e, \" \" + e.getMessage()); //$NON-NLS-1$\n\t\t} catch (IOException e) {\n\t\t\tSWT.error(SWT.ERROR_IO, e);\n\t\t}\n\t}",
    "code_after_change": "{\n\n\t\tDOCUMENT_BUILDER_FACTORY.setNamespaceAware(true);\n\t\tDOCUMENT_BUILDER_FACTORY.setIgnoringComments(true);\n\n\t\treset();\n\t\ttry {\n\t\t\tDocumentBuilder parser = DOCUMENT_BUILDER_FACTORY.newDocumentBuilder();\n\t\t\tparser.setErrorHandler(new ParseErrorHandler());\n\t\t\tInputSource source = new InputSource(is);\n\t\t\tDocument doc = parser.parse(source);\n\t\t\tprocessDocument(doc, expandURLs);\n\t\t} catch (ParserConfigurationException | SAXException e) {\n\t\t\tSWT.error(SWT.ERROR_INVALID_ARGUMENT, e, \" \" + e.getMessage()); //$NON-NLS-1$\n\t\t} catch (IOException e) {\n\t\t\tSWT.error(SWT.ERROR_IO, e);\n\t\t}\n\t}",
    "patch": "@@ -56,8 +56,9 @@ public void warning(SAXParseException arg0) throws SAXException {\n \t\t}\n \t}\n \n-\tprivate static final DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory\n-\t\t\t.newInstance();\n+\t@SuppressWarnings(\"restriction\")\n+\tprivate static final DocumentBuilderFactory DOCUMENT_BUILDER_FACTORY = org.eclipse.core.internal.runtime.XmlProcessorFactory\n+\t\t\t.createDocumentBuilderFactoryWithErrorOnDOCTYPE();\n \n \tprivate boolean whitespaceNormalized = true;\n \n@@ -132,13 +133,12 @@ private String processAmpersandEscapes(String pTaggedText) {\n \n \tpublic void parseInputStream(InputStream is, boolean expandURLs) {\n \n-\t\tdocumentBuilderFactory.setNamespaceAware(true);\n-\t\tdocumentBuilderFactory.setIgnoringComments(true);\n+\t\tDOCUMENT_BUILDER_FACTORY.setNamespaceAware(true);\n+\t\tDOCUMENT_BUILDER_FACTORY.setIgnoringComments(true);\n \n \t\treset();\n \t\ttry {\n-\t\t\tDocumentBuilder parser = documentBuilderFactory\n-\t\t\t\t\t.newDocumentBuilder();\n+\t\t\tDocumentBuilder parser = DOCUMENT_BUILDER_FACTORY.newDocumentBuilder();\n \t\t\tparser.setErrorHandler(new ParseErrorHandler());\n \t\t\tInputSource source = new InputSource(is);\n \t\t\tDocument doc = parser.parse(source);",
    "function_modified_lines": {
      "added": [
        "\t\tDOCUMENT_BUILDER_FACTORY.setNamespaceAware(true);\n",
        "\t\tDOCUMENT_BUILDER_FACTORY.setIgnoringComments(true);\n",
        "\t\t\tDocumentBuilder parser = DOCUMENT_BUILDER_FACTORY.newDocumentBuilder();\n"
      ],
      "deleted": [
        "\t\tdocumentBuilderFactory.setNamespaceAware(true);\n",
        "\t\tdocumentBuilderFactory.setIgnoringComments(true);\n",
        "\t\t\tDocumentBuilder parser = documentBuilderFactory\n",
        "\t\t\t\t\t.newDocumentBuilder();\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "In Eclipse IDE versions < 2023-09 (4.29) some files with xml content are parsed vulnerable against all sorts of XXE attacks. The user just needs to open any evil project or update an open project with a vulnerable file (for example for review a foreign repository or patch).\n",
    "id": 12848
  },
  {
    "cve_id": "CVE-2023-4218",
    "code_before_change": "{\n\t\t\tDocumentBuilderFactory factory= DocumentBuilderFactory.newInstance();\n\t\t\tDocumentBuilder builder= factory.newDocumentBuilder();\n\t\t\tDocument document= builder.newDocument();\n\n\t\t\tElement rootElement = document.createElement(fRootNodeName);\n\t\t\tdocument.appendChild(rootElement);\n\n\t\t\tIterator<V> values= getValues().iterator();\n\t\t\twhile (values.hasNext()) {\n\t\t\t\tObject object= values.next();\n\t\t\t\tElement element= document.createElement(fInfoNodeName);\n\t\t\t\tsetAttributes(object, element);\n\t\t\t\trootElement.appendChild(element);\n\t\t\t}\n\n\t\t\tTransformer transformer=TransformerFactory.newInstance().newTransformer();\n\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\t\ttransformer.setOutputProperty(OutputKeys.ENCODING, \"UTF-8\"); //$NON-NLS-1$\n\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\t\t\tDOMSource source = new DOMSource(document);\n\t\t\tStreamResult result = new StreamResult(stream);\n\n\t\t\ttransformer.transform(source, result);\n\t\t}",
    "code_after_change": "{\n\t\t\tDocumentBuilderFactory factory= XmlProcessorFactoryJdtUi.createDocumentBuilderFactoryWithErrorOnDOCTYPE();\n\t\t\tDocumentBuilder builder= factory.newDocumentBuilder();\n\t\t\tDocument document= builder.newDocument();\n\n\t\t\tElement rootElement = document.createElement(fRootNodeName);\n\t\t\tdocument.appendChild(rootElement);\n\n\t\t\tIterator<V> values= getValues().iterator();\n\t\t\twhile (values.hasNext()) {\n\t\t\t\tObject object= values.next();\n\t\t\t\tElement element= document.createElement(fInfoNodeName);\n\t\t\t\tsetAttributes(object, element);\n\t\t\t\trootElement.appendChild(element);\n\t\t\t}\n\n\t\t\tTransformer transformer= XmlProcessorFactoryJdtUi.createTransformerFactoryWithErrorOnDOCTYPE().newTransformer();\n\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\t\ttransformer.setOutputProperty(OutputKeys.ENCODING, \"UTF-8\"); //$NON-NLS-1$\n\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\t\t\tDOMSource source = new DOMSource(document);\n\t\t\tStreamResult result = new StreamResult(stream);\n\n\t\t\ttransformer.transform(source, result);\n\t\t}",
    "patch": "@@ -32,7 +32,6 @@\n import javax.xml.transform.OutputKeys;\n import javax.xml.transform.Transformer;\n import javax.xml.transform.TransformerException;\n-import javax.xml.transform.TransformerFactory;\n import javax.xml.transform.TransformerFactoryConfigurationError;\n import javax.xml.transform.dom.DOMSource;\n import javax.xml.transform.stream.StreamResult;\n@@ -56,6 +55,7 @@\n import org.eclipse.jdt.internal.ui.JavaPlugin;\n import org.eclipse.jdt.internal.ui.JavaUIException;\n import org.eclipse.jdt.internal.ui.JavaUIStatus;\n+import org.eclipse.jdt.internal.ui.util.XmlProcessorFactoryJdtUi;\n \n /**\n  * History stores a list of key, object pairs. The list is bounded at size\n@@ -232,7 +232,7 @@ private void rebuildPositions() {\n \tprivate void load(InputSource inputSource) throws CoreException {\n \t\tElement root;\n \t\ttry {\n-\t\t\tDocumentBuilder parser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n+\t\t\tDocumentBuilder parser = XmlProcessorFactoryJdtUi.createDocumentBuilderFactoryWithErrorOnDOCTYPE().newDocumentBuilder();\n \t\t\tparser.setErrorHandler(new DefaultHandler());\n \t\t\troot = parser.parse(inputSource).getDocumentElement();\n \t\t} catch (SAXException | ParserConfigurationException | IOException e) {\n@@ -262,7 +262,7 @@ private void load(InputSource inputSource) throws CoreException {\n \n \tprivate void save(OutputStream stream) throws CoreException {\n \t\ttry {\n-\t\t\tDocumentBuilderFactory factory= DocumentBuilderFactory.newInstance();\n+\t\t\tDocumentBuilderFactory factory= XmlProcessorFactoryJdtUi.createDocumentBuilderFactoryWithErrorOnDOCTYPE();\n \t\t\tDocumentBuilder builder= factory.newDocumentBuilder();\n \t\t\tDocument document= builder.newDocument();\n \n@@ -277,7 +277,7 @@ private void save(OutputStream stream) throws CoreException {\n \t\t\t\trootElement.appendChild(element);\n \t\t\t}\n \n-\t\t\tTransformer transformer=TransformerFactory.newInstance().newTransformer();\n+\t\t\tTransformer transformer= XmlProcessorFactoryJdtUi.createTransformerFactoryWithErrorOnDOCTYPE().newTransformer();\n \t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n \t\t\ttransformer.setOutputProperty(OutputKeys.ENCODING, \"UTF-8\"); //$NON-NLS-1$\n \t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$",
    "function_modified_lines": {
      "added": [
        "\t\t\tDocumentBuilderFactory factory= XmlProcessorFactoryJdtUi.createDocumentBuilderFactoryWithErrorOnDOCTYPE();\n",
        "\t\t\tTransformer transformer= XmlProcessorFactoryJdtUi.createTransformerFactoryWithErrorOnDOCTYPE().newTransformer();\n"
      ],
      "deleted": [
        "\t\t\tDocumentBuilderFactory factory= DocumentBuilderFactory.newInstance();\n",
        "\t\t\tTransformer transformer=TransformerFactory.newInstance().newTransformer();\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "In Eclipse IDE versions < 2023-09 (4.29) some files with xml content are parsed vulnerable against all sorts of XXE attacks. The user just needs to open any evil project or update an open project with a vulnerable file (for example for review a foreign repository or patch).\n",
    "id": 12850
  },
  {
    "cve_id": "CVE-2023-4218",
    "code_before_change": "/*******************************************************************************\n * Copyright (c) 2009, 2014 IBM Corporation and others.\n *\n * This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n *\n * Contributors:\n *     IBM Corporation - initial API and implementation\n *     Ferenc Hechler, ferenc_hechler@users.sourceforge.net - 83258 [jar exporter] Deploy java application as executable jar\n *     Ferenc Hechler, ferenc_hechler@users.sourceforge.net - 262766 [jar exporter] ANT file for Jar-in-Jar option contains relative path to jar-rsrc-loader.zip\n *     Ferenc Hechler, ferenc_hechler@users.sourceforge.net - 262763 [jar exporter] remove Built-By attribute in ANT files from Fat JAR Exporter\n *     Ferenc Hechler, ferenc_hechler@users.sourceforge.net - 269201 [jar exporter] ant file produced by Export runnable jar contains absolut paths instead of relative to workspace\n *******************************************************************************/\npackage org.eclipse.jdt.internal.ui.jarpackagerfat;\n\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\n\nimport org.eclipse.core.runtime.IPath;\n\nimport org.eclipse.debug.core.ILaunchConfiguration;\n\n/**\n * @since 3.5\n */\npublic class UnpackFatJarAntExporter extends FatJarAntExporter {\n\n\tpublic UnpackFatJarAntExporter(IPath antScriptLocation, IPath jarLocation, ILaunchConfiguration launchConfiguration) {\n\t\tsuper(antScriptLocation, jarLocation, launchConfiguration);\n\t}\n\n\t@Override\n\tprotected void buildANTScript(IPath antScriptLocation, String projectName, IPath absJarfile, String mainClass, SourceInfo[] sourceInfos) throws IOException {\n\t\ttry (OutputStream outputStream = new FileOutputStream(antScriptLocation.toFile())) {\n\t\t\tString absJarname= absJarfile.toString();\n\n\t\t\tDocumentBuilder docBuilder= null;\n\t\t\tDocumentBuilderFactory factory= DocumentBuilderFactory.newInstance();\n\t\t\tfactory.setValidating(false);\n\t\t\ttry {\n\t\t\t\tdocBuilder= factory.newDocumentBuilder();\n\t\t\t} catch (ParserConfigurationException ex) {\n\t\t\t\tthrow new IOException(FatJarPackagerMessages.FatJarPackageAntScript_error_couldNotGetXmlBuilder);\n\t\t\t}\n\t\t\tDocument document= docBuilder.newDocument();\n\n\t\t\tNode comment;\n\n\t\t\t// Create the document\n\t\t\tElement project= document.createElement(\"project\"); //$NON-NLS-1$\n\t\t\tproject.setAttribute(\"name\", \"Create Runnable Jar for Project \" + projectName); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\tproject.setAttribute(\"default\", \"create_run_jar\"); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\tdocument.appendChild(project);\n\t\t\tcomment= document.createComment(\"this file was created by Eclipse Runnable JAR Export Wizard\"); //$NON-NLS-1$\n\t\t\tproject.appendChild(comment);\n\t\t\tcomment= document.createComment(\"ANT 1.7 is required                                        \"); //$NON-NLS-1$\n\t\t\tproject.appendChild(comment);\n\n\t\t\taddBaseDirProperties(document, project);\n\n\t\t\tElement target= document.createElement(\"target\"); //$NON-NLS-1$\n\t\t\ttarget.setAttribute(\"name\", \"create_run_jar\"); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\tproject.appendChild(target);\n\n\t\t\tElement jar= document.createElement(\"jar\"); //$NON-NLS-1$\n\t\t\tjar.setAttribute(\"destfile\", substituteBaseDirs(absJarname)); //$NON-NLS-1$s\n\t\t\tjar.setAttribute(\"filesetmanifest\", \"mergewithoutmain\"); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\ttarget.appendChild(jar);\n\n\t\t\tElement manifest= document.createElement(\"manifest\"); //$NON-NLS-1$\n\t\t\tjar.appendChild(manifest);\n\n\t\t\tElement attribute= document.createElement(\"attribute\"); //$NON-NLS-1$\n\t\t\tattribute.setAttribute(\"name\", \"Main-Class\"); //$NON-NLS-1$ //$NON-NLS-2$s\n\t\t\tattribute.setAttribute(\"value\", mainClass); //$NON-NLS-1$\n\t\t\tmanifest.appendChild(attribute);\n\n\t\t\tattribute= document.createElement(\"attribute\"); //$NON-NLS-1$\n\t\t\tattribute.setAttribute(\"name\", \"Class-Path\"); //$NON-NLS-1$ //$NON-NLS-2$s\n\t\t\tattribute.setAttribute(\"value\", \".\"); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\tmanifest.appendChild(attribute);\n\n\t\t\tfor (SourceInfo sourceInfo : sourceInfos) {\n\t\t\t\tif (sourceInfo.isJar) {\n\t\t\t\t\tElement zipfileset= document.createElement(\"zipfileset\"); //$NON-NLS-1$\n\t\t\t\t\tzipfileset.setAttribute(\"src\", substituteBaseDirs(sourceInfo.absPath)); //$NON-NLS-1$\n\t\t\t\t\tzipfileset.setAttribute(\"excludes\", \"META-INF/*.SF\"); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\tjar.appendChild(zipfileset);\n\t\t\t\t} else {\n\t\t\t\t\tElement fileset= document.createElement(\"fileset\"); //$NON-NLS-1$\n\t\t\t\t\tfileset.setAttribute(\"dir\", substituteBaseDirs(sourceInfo.absPath)); //$NON-NLS-1$\n\t\t\t\t\tjar.appendChild(fileset);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\t// Write the document to the stream\n\t\t\t\tTransformer transformer= TransformerFactory.newInstance().newTransformer();\n\t\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\t\t\ttransformer.setOutputProperty(OutputKeys.ENCODING, \"UTF-8\"); //$NON-NLS-1$\n\t\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\t\t\t\ttransformer.setOutputProperty(\"{http://xml.apache.org/xslt}indent-amount\", \"4\"); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\tDOMSource source= new DOMSource(document);\n\t\t\t\tStreamResult result= new StreamResult(outputStream);\n\t\t\t\ttransformer.transform(source, result);\n\t\t\t} catch (TransformerException e) {\n\t\t\t\tthrow new IOException(FatJarPackagerMessages.FatJarPackageAntScript_error_couldNotTransformToXML);\n\t\t\t}\n\t\t}\n\t}\n\n}\n",
    "code_after_change": "/*******************************************************************************\n * Copyright (c) 2009, 2014 IBM Corporation and others.\n *\n * This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n *\n * Contributors:\n *     IBM Corporation - initial API and implementation\n *     Ferenc Hechler, ferenc_hechler@users.sourceforge.net - 83258 [jar exporter] Deploy java application as executable jar\n *     Ferenc Hechler, ferenc_hechler@users.sourceforge.net - 262766 [jar exporter] ANT file for Jar-in-Jar option contains relative path to jar-rsrc-loader.zip\n *     Ferenc Hechler, ferenc_hechler@users.sourceforge.net - 262763 [jar exporter] remove Built-By attribute in ANT files from Fat JAR Exporter\n *     Ferenc Hechler, ferenc_hechler@users.sourceforge.net - 269201 [jar exporter] ant file produced by Export runnable jar contains absolut paths instead of relative to workspace\n *******************************************************************************/\npackage org.eclipse.jdt.internal.ui.jarpackagerfat;\n\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\n\nimport org.eclipse.core.runtime.IPath;\n\nimport org.eclipse.debug.core.ILaunchConfiguration;\n\nimport org.eclipse.jdt.internal.ui.util.XmlProcessorFactoryJdtUi;\n\n/**\n * @since 3.5\n */\npublic class UnpackFatJarAntExporter extends FatJarAntExporter {\n\n\tpublic UnpackFatJarAntExporter(IPath antScriptLocation, IPath jarLocation, ILaunchConfiguration launchConfiguration) {\n\t\tsuper(antScriptLocation, jarLocation, launchConfiguration);\n\t}\n\n\t@Override\n\tprotected void buildANTScript(IPath antScriptLocation, String projectName, IPath absJarfile, String mainClass, SourceInfo[] sourceInfos) throws IOException {\n\t\ttry (OutputStream outputStream = new FileOutputStream(antScriptLocation.toFile())) {\n\t\t\tString absJarname= absJarfile.toString();\n\n\t\t\tDocumentBuilder docBuilder= null;\n\t\t\tDocumentBuilderFactory factory= XmlProcessorFactoryJdtUi.createDocumentBuilderFactoryWithErrorOnDOCTYPE();\n\t\t\tfactory.setValidating(false);\n\t\t\ttry {\n\t\t\t\tdocBuilder= factory.newDocumentBuilder();\n\t\t\t} catch (ParserConfigurationException ex) {\n\t\t\t\tthrow new IOException(FatJarPackagerMessages.FatJarPackageAntScript_error_couldNotGetXmlBuilder);\n\t\t\t}\n\t\t\tDocument document= docBuilder.newDocument();\n\n\t\t\tNode comment;\n\n\t\t\t// Create the document\n\t\t\tElement project= document.createElement(\"project\"); //$NON-NLS-1$\n\t\t\tproject.setAttribute(\"name\", \"Create Runnable Jar for Project \" + projectName); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\tproject.setAttribute(\"default\", \"create_run_jar\"); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\tdocument.appendChild(project);\n\t\t\tcomment= document.createComment(\"this file was created by Eclipse Runnable JAR Export Wizard\"); //$NON-NLS-1$\n\t\t\tproject.appendChild(comment);\n\t\t\tcomment= document.createComment(\"ANT 1.7 is required                                        \"); //$NON-NLS-1$\n\t\t\tproject.appendChild(comment);\n\n\t\t\taddBaseDirProperties(document, project);\n\n\t\t\tElement target= document.createElement(\"target\"); //$NON-NLS-1$\n\t\t\ttarget.setAttribute(\"name\", \"create_run_jar\"); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\tproject.appendChild(target);\n\n\t\t\tElement jar= document.createElement(\"jar\"); //$NON-NLS-1$\n\t\t\tjar.setAttribute(\"destfile\", substituteBaseDirs(absJarname)); //$NON-NLS-1$s\n\t\t\tjar.setAttribute(\"filesetmanifest\", \"mergewithoutmain\"); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\ttarget.appendChild(jar);\n\n\t\t\tElement manifest= document.createElement(\"manifest\"); //$NON-NLS-1$\n\t\t\tjar.appendChild(manifest);\n\n\t\t\tElement attribute= document.createElement(\"attribute\"); //$NON-NLS-1$\n\t\t\tattribute.setAttribute(\"name\", \"Main-Class\"); //$NON-NLS-1$ //$NON-NLS-2$s\n\t\t\tattribute.setAttribute(\"value\", mainClass); //$NON-NLS-1$\n\t\t\tmanifest.appendChild(attribute);\n\n\t\t\tattribute= document.createElement(\"attribute\"); //$NON-NLS-1$\n\t\t\tattribute.setAttribute(\"name\", \"Class-Path\"); //$NON-NLS-1$ //$NON-NLS-2$s\n\t\t\tattribute.setAttribute(\"value\", \".\"); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\tmanifest.appendChild(attribute);\n\n\t\t\tfor (SourceInfo sourceInfo : sourceInfos) {\n\t\t\t\tif (sourceInfo.isJar) {\n\t\t\t\t\tElement zipfileset= document.createElement(\"zipfileset\"); //$NON-NLS-1$\n\t\t\t\t\tzipfileset.setAttribute(\"src\", substituteBaseDirs(sourceInfo.absPath)); //$NON-NLS-1$\n\t\t\t\t\tzipfileset.setAttribute(\"excludes\", \"META-INF/*.SF\"); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\tjar.appendChild(zipfileset);\n\t\t\t\t} else {\n\t\t\t\t\tElement fileset= document.createElement(\"fileset\"); //$NON-NLS-1$\n\t\t\t\t\tfileset.setAttribute(\"dir\", substituteBaseDirs(sourceInfo.absPath)); //$NON-NLS-1$\n\t\t\t\t\tjar.appendChild(fileset);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\t// Write the document to the stream\n\t\t\t\tTransformer transformer= XmlProcessorFactoryJdtUi.createTransformerFactoryWithErrorOnDOCTYPE().newTransformer();\n\t\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\t\t\ttransformer.setOutputProperty(OutputKeys.ENCODING, \"UTF-8\"); //$NON-NLS-1$\n\t\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\t\t\t\ttransformer.setOutputProperty(\"{http://xml.apache.org/xslt}indent-amount\", \"4\"); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\tDOMSource source= new DOMSource(document);\n\t\t\t\tStreamResult result= new StreamResult(outputStream);\n\t\t\t\ttransformer.transform(source, result);\n\t\t\t} catch (TransformerException e) {\n\t\t\t\tthrow new IOException(FatJarPackagerMessages.FatJarPackageAntScript_error_couldNotTransformToXML);\n\t\t\t}\n\t\t}\n\t}\n\n}\n",
    "patch": "@@ -27,7 +27,6 @@\n import javax.xml.transform.OutputKeys;\n import javax.xml.transform.Transformer;\n import javax.xml.transform.TransformerException;\n-import javax.xml.transform.TransformerFactory;\n import javax.xml.transform.dom.DOMSource;\n import javax.xml.transform.stream.StreamResult;\n \n@@ -39,6 +38,8 @@\n \n import org.eclipse.debug.core.ILaunchConfiguration;\n \n+import org.eclipse.jdt.internal.ui.util.XmlProcessorFactoryJdtUi;\n+\n /**\n  * @since 3.5\n  */\n@@ -54,7 +55,7 @@ protected void buildANTScript(IPath antScriptLocation, String projectName, IPath\n \t\t\tString absJarname= absJarfile.toString();\n \n \t\t\tDocumentBuilder docBuilder= null;\n-\t\t\tDocumentBuilderFactory factory= DocumentBuilderFactory.newInstance();\n+\t\t\tDocumentBuilderFactory factory= XmlProcessorFactoryJdtUi.createDocumentBuilderFactoryWithErrorOnDOCTYPE();\n \t\t\tfactory.setValidating(false);\n \t\t\ttry {\n \t\t\t\tdocBuilder= factory.newDocumentBuilder();\n@@ -114,7 +115,7 @@ protected void buildANTScript(IPath antScriptLocation, String projectName, IPath\n \n \t\t\ttry {\n \t\t\t\t// Write the document to the stream\n-\t\t\t\tTransformer transformer= TransformerFactory.newInstance().newTransformer();\n+\t\t\t\tTransformer transformer= XmlProcessorFactoryJdtUi.createTransformerFactoryWithErrorOnDOCTYPE().newTransformer();\n \t\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n \t\t\t\ttransformer.setOutputProperty(OutputKeys.ENCODING, \"UTF-8\"); //$NON-NLS-1$\n \t\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$",
    "function_modified_lines": {
      "added": [
        "import org.eclipse.jdt.internal.ui.util.XmlProcessorFactoryJdtUi;\n",
        "\n",
        "\t\t\tDocumentBuilderFactory factory= XmlProcessorFactoryJdtUi.createDocumentBuilderFactoryWithErrorOnDOCTYPE();\n"
      ],
      "deleted": [
        "import javax.xml.transform.TransformerFactory;\n",
        "\t\t\tDocumentBuilderFactory factory= DocumentBuilderFactory.newInstance();\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "In Eclipse IDE versions < 2023-09 (4.29) some files with xml content are parsed vulnerable against all sorts of XXE attacks. The user just needs to open any evil project or update an open project with a vulnerable file (for example for review a foreign repository or patch).\n",
    "id": 12852
  },
  {
    "cve_id": "CVE-2023-4218",
    "code_before_change": "{\n\n\t\tprivate static final String NODE_ROOT= \"history\"; //$NON-NLS-1$\n\t\tprivate static final String NODE_LHS= \"lhs\"; //$NON-NLS-1$\n\t\tprivate static final String NODE_RHS= \"rhs\"; //$NON-NLS-1$\n\t\tprivate static final String ATTRIBUTE_NAME= \"name\"; //$NON-NLS-1$\n\t\tprivate static final String ATTRIBUTE_MAX_LHS= \"maxLHS\"; //$NON-NLS-1$\n\t\tprivate static final String ATTRIBUTE_MAX_RHS= \"maxRHS\"; //$NON-NLS-1$\n\n\t\tpublic void store(ContentAssistHistory history, StreamResult result) throws CoreException {\n\t\t\ttry {\n\t\t\t\tDocumentBuilderFactory factory= DocumentBuilderFactory.newInstance();\n\t\t\t\tDocumentBuilder builder= factory.newDocumentBuilder();\n\t\t\t\tDocument document= builder.newDocument();\n\n\t\t\t\tElement rootElement = document.createElement(NODE_ROOT);\n\t\t\t\trootElement.setAttribute(ATTRIBUTE_MAX_LHS, Integer.toString(history.fMaxLHS));\n\t\t\t\trootElement.setAttribute(ATTRIBUTE_MAX_RHS, Integer.toString(history.fMaxRHS));\n\t\t\t\tdocument.appendChild(rootElement);\n\n\t\t\t\tfor (Entry<String, MRUSet<String>> entry : history.fLHSCache.entrySet()) {\n\t\t\t\t\tString lhs = entry.getKey();\n\t\t\t\t\tElement lhsElement= document.createElement(NODE_LHS);\n\t\t\t\t\tlhsElement.setAttribute(ATTRIBUTE_NAME, lhs);\n\t\t\t\t\trootElement.appendChild(lhsElement);\n\t\t\t\t\tfor (String rhs : entry.getValue()) {\n\t\t\t\t\t\tElement rhsElement= document.createElement(NODE_RHS);\n\t\t\t\t\t\trhsElement.setAttribute(ATTRIBUTE_NAME, rhs);\n\t\t\t\t\t\tlhsElement.appendChild(rhsElement);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tTransformer transformer=TransformerFactory.newInstance().newTransformer();\n\t\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\t\t\ttransformer.setOutputProperty(OutputKeys.ENCODING, \"UTF-8\"); //$NON-NLS-1$\n\t\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"no\"); //$NON-NLS-1$\n\t\t\t\tDOMSource source = new DOMSource(document);\n\n\t\t\t\ttransformer.transform(source, result);\n\t\t\t} catch (TransformerException | ParserConfigurationException e) {\n\t\t\t\tthrow createException(e, JavaTextMessages.ContentAssistHistory_serialize_error);\n\t\t\t}\n\t\t}\n\n\t\tpublic ContentAssistHistory load(InputSource source) throws CoreException {\n\t\t\tElement root;\n\t\t\ttry {\n\t\t\t\tDocumentBuilder parser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n\t\t\t\tparser.setErrorHandler(new DefaultHandler());\n\t\t\t\troot = parser.parse(source).getDocumentElement();\n\t\t\t} catch (SAXException | ParserConfigurationException | IOException e) {\n\t\t\t\tthrow createException(e, JavaTextMessages.ContentAssistHistory_deserialize_error);\n\t\t\t}\n\n\t\t\tif (root == null || !NODE_ROOT.equalsIgnoreCase(root.getNodeName()))\n\t\t\t\treturn null;\n\n\t\t\tint maxLHS= parseNaturalInt(root.getAttribute(ATTRIBUTE_MAX_LHS), DEFAULT_TRACKED_LHS);\n\t\t\tint maxRHS= parseNaturalInt(root.getAttribute(ATTRIBUTE_MAX_RHS), DEFAULT_TRACKED_RHS);\n\n\t\t\tContentAssistHistory history= new ContentAssistHistory(maxLHS, maxRHS);\n\n\t\t\tNodeList list= root.getChildNodes();\n\t\t\tint length= list.getLength();\n\t\t\tfor (int i= 0; i < length; ++i) {\n\t\t\t\tNode lhsNode= list.item(i);\n\t\t\t\tif (lhsNode.getNodeType() == Node.ELEMENT_NODE) {\n\t\t\t\t\tElement lhsElement= (Element) lhsNode;\n\t\t\t\t\tif (NODE_LHS.equalsIgnoreCase(lhsElement.getNodeName())) {\n\t\t\t\t\t\tString lhs= lhsElement.getAttribute(ATTRIBUTE_NAME);\n\t\t\t\t\t\tif (lhs != null) {\n\t\t\t\t\t\t\tSet<String> cache= history.getCache(lhs);\n\t\t\t\t\t\t\tNodeList children= lhsElement.getChildNodes();\n\t\t\t\t\t\t\tint nRHS= children.getLength();\n\t\t\t\t\t\t\tfor (int j= 0; j < nRHS; j++) {\n\t\t\t\t\t\t\t\tNode rhsNode= children.item(j);\n\t\t\t\t\t\t\t\tif (rhsNode.getNodeType() == Node.ELEMENT_NODE) {\n\t\t\t\t\t\t\t\t\tElement rhsElement= (Element) rhsNode;\n\t\t\t\t\t\t\t\t\tif (NODE_RHS.equalsIgnoreCase(rhsElement.getNodeName())) {\n\t\t\t\t\t\t\t\t\t\tString rhs= rhsElement.getAttribute(ATTRIBUTE_NAME);\n\t\t\t\t\t\t\t\t\t\tif (rhs != null) {\n\t\t\t\t\t\t\t\t\t\t\tcache.add(rhs);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn history;\n\t\t}\n\n\t\tprivate int parseNaturalInt(String attribute, int defaultValue) {\n\t\t\ttry {\n\t\t\t\tint integer= Integer.parseInt(attribute);\n\t\t\t\tif (integer > 0)\n\t\t\t\t\treturn integer;\n\t\t\t\treturn defaultValue;\n\t\t\t} catch (NumberFormatException e) {\n\t\t\t\treturn defaultValue;\n\t\t\t}\n\t\t}\n\n\t\tprivate JavaUIException createException(Exception e, String message) {\n\t\t\treturn new JavaUIException(JavaUIStatus.createError(IStatus.ERROR, message, e));\n\t\t}\n\t}",
    "code_after_change": "{\n\n\t\tprivate static final String NODE_ROOT= \"history\"; //$NON-NLS-1$\n\t\tprivate static final String NODE_LHS= \"lhs\"; //$NON-NLS-1$\n\t\tprivate static final String NODE_RHS= \"rhs\"; //$NON-NLS-1$\n\t\tprivate static final String ATTRIBUTE_NAME= \"name\"; //$NON-NLS-1$\n\t\tprivate static final String ATTRIBUTE_MAX_LHS= \"maxLHS\"; //$NON-NLS-1$\n\t\tprivate static final String ATTRIBUTE_MAX_RHS= \"maxRHS\"; //$NON-NLS-1$\n\n\t\tpublic void store(ContentAssistHistory history, StreamResult result) throws CoreException {\n\t\t\ttry {\n\t\t\t\tDocumentBuilderFactory factory= XmlProcessorFactoryJdtUi.createDocumentBuilderFactoryWithErrorOnDOCTYPE();\n\t\t\t\tDocumentBuilder builder= factory.newDocumentBuilder();\n\t\t\t\tDocument document= builder.newDocument();\n\n\t\t\t\tElement rootElement = document.createElement(NODE_ROOT);\n\t\t\t\trootElement.setAttribute(ATTRIBUTE_MAX_LHS, Integer.toString(history.fMaxLHS));\n\t\t\t\trootElement.setAttribute(ATTRIBUTE_MAX_RHS, Integer.toString(history.fMaxRHS));\n\t\t\t\tdocument.appendChild(rootElement);\n\n\t\t\t\tfor (Entry<String, MRUSet<String>> entry : history.fLHSCache.entrySet()) {\n\t\t\t\t\tString lhs = entry.getKey();\n\t\t\t\t\tElement lhsElement= document.createElement(NODE_LHS);\n\t\t\t\t\tlhsElement.setAttribute(ATTRIBUTE_NAME, lhs);\n\t\t\t\t\trootElement.appendChild(lhsElement);\n\t\t\t\t\tfor (String rhs : entry.getValue()) {\n\t\t\t\t\t\tElement rhsElement= document.createElement(NODE_RHS);\n\t\t\t\t\t\trhsElement.setAttribute(ATTRIBUTE_NAME, rhs);\n\t\t\t\t\t\tlhsElement.appendChild(rhsElement);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tTransformer transformer= XmlProcessorFactoryJdtUi.createTransformerFactoryWithErrorOnDOCTYPE().newTransformer();\n\t\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\t\t\ttransformer.setOutputProperty(OutputKeys.ENCODING, \"UTF-8\"); //$NON-NLS-1$\n\t\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"no\"); //$NON-NLS-1$\n\t\t\t\tDOMSource source = new DOMSource(document);\n\n\t\t\t\ttransformer.transform(source, result);\n\t\t\t} catch (TransformerException | ParserConfigurationException e) {\n\t\t\t\tthrow createException(e, JavaTextMessages.ContentAssistHistory_serialize_error);\n\t\t\t}\n\t\t}\n\n\t\tpublic ContentAssistHistory load(InputSource source) throws CoreException {\n\t\t\tElement root;\n\t\t\ttry {\n\t\t\t\tDocumentBuilder parser = XmlProcessorFactoryJdtUi.createDocumentBuilderFactoryWithErrorOnDOCTYPE().newDocumentBuilder();\n\t\t\t\tparser.setErrorHandler(new DefaultHandler());\n\t\t\t\troot = parser.parse(source).getDocumentElement();\n\t\t\t} catch (SAXException | ParserConfigurationException | IOException e) {\n\t\t\t\tthrow createException(e, JavaTextMessages.ContentAssistHistory_deserialize_error);\n\t\t\t}\n\n\t\t\tif (root == null || !NODE_ROOT.equalsIgnoreCase(root.getNodeName()))\n\t\t\t\treturn null;\n\n\t\t\tint maxLHS= parseNaturalInt(root.getAttribute(ATTRIBUTE_MAX_LHS), DEFAULT_TRACKED_LHS);\n\t\t\tint maxRHS= parseNaturalInt(root.getAttribute(ATTRIBUTE_MAX_RHS), DEFAULT_TRACKED_RHS);\n\n\t\t\tContentAssistHistory history= new ContentAssistHistory(maxLHS, maxRHS);\n\n\t\t\tNodeList list= root.getChildNodes();\n\t\t\tint length= list.getLength();\n\t\t\tfor (int i= 0; i < length; ++i) {\n\t\t\t\tNode lhsNode= list.item(i);\n\t\t\t\tif (lhsNode.getNodeType() == Node.ELEMENT_NODE) {\n\t\t\t\t\tElement lhsElement= (Element) lhsNode;\n\t\t\t\t\tif (NODE_LHS.equalsIgnoreCase(lhsElement.getNodeName())) {\n\t\t\t\t\t\tString lhs= lhsElement.getAttribute(ATTRIBUTE_NAME);\n\t\t\t\t\t\tif (lhs != null) {\n\t\t\t\t\t\t\tSet<String> cache= history.getCache(lhs);\n\t\t\t\t\t\t\tNodeList children= lhsElement.getChildNodes();\n\t\t\t\t\t\t\tint nRHS= children.getLength();\n\t\t\t\t\t\t\tfor (int j= 0; j < nRHS; j++) {\n\t\t\t\t\t\t\t\tNode rhsNode= children.item(j);\n\t\t\t\t\t\t\t\tif (rhsNode.getNodeType() == Node.ELEMENT_NODE) {\n\t\t\t\t\t\t\t\t\tElement rhsElement= (Element) rhsNode;\n\t\t\t\t\t\t\t\t\tif (NODE_RHS.equalsIgnoreCase(rhsElement.getNodeName())) {\n\t\t\t\t\t\t\t\t\t\tString rhs= rhsElement.getAttribute(ATTRIBUTE_NAME);\n\t\t\t\t\t\t\t\t\t\tif (rhs != null) {\n\t\t\t\t\t\t\t\t\t\t\tcache.add(rhs);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn history;\n\t\t}\n\n\t\tprivate int parseNaturalInt(String attribute, int defaultValue) {\n\t\t\ttry {\n\t\t\t\tint integer= Integer.parseInt(attribute);\n\t\t\t\tif (integer > 0)\n\t\t\t\t\treturn integer;\n\t\t\t\treturn defaultValue;\n\t\t\t} catch (NumberFormatException e) {\n\t\t\t\treturn defaultValue;\n\t\t\t}\n\t\t}\n\n\t\tprivate JavaUIException createException(Exception e, String message) {\n\t\t\treturn new JavaUIException(JavaUIStatus.createError(IStatus.ERROR, message, e));\n\t\t}\n\t}",
    "patch": "@@ -34,7 +34,6 @@\n import javax.xml.transform.OutputKeys;\n import javax.xml.transform.Transformer;\n import javax.xml.transform.TransformerException;\n-import javax.xml.transform.TransformerFactory;\n import javax.xml.transform.dom.DOMSource;\n import javax.xml.transform.stream.StreamResult;\n \n@@ -62,6 +61,7 @@\n import org.eclipse.jdt.internal.ui.JavaPlugin;\n import org.eclipse.jdt.internal.ui.JavaUIException;\n import org.eclipse.jdt.internal.ui.JavaUIStatus;\n+import org.eclipse.jdt.internal.ui.util.XmlProcessorFactoryJdtUi;\n \n /**\n  * An LRU cache for code assist.\n@@ -85,7 +85,7 @@ private static final class ReaderWriter {\n \n \t\tpublic void store(ContentAssistHistory history, StreamResult result) throws CoreException {\n \t\t\ttry {\n-\t\t\t\tDocumentBuilderFactory factory= DocumentBuilderFactory.newInstance();\n+\t\t\t\tDocumentBuilderFactory factory= XmlProcessorFactoryJdtUi.createDocumentBuilderFactoryWithErrorOnDOCTYPE();\n \t\t\t\tDocumentBuilder builder= factory.newDocumentBuilder();\n \t\t\t\tDocument document= builder.newDocument();\n \n@@ -106,7 +106,7 @@ public void store(ContentAssistHistory history, StreamResult result) throws Core\n \t\t\t\t\t}\n \t\t\t\t}\n \n-\t\t\t\tTransformer transformer=TransformerFactory.newInstance().newTransformer();\n+\t\t\t\tTransformer transformer= XmlProcessorFactoryJdtUi.createTransformerFactoryWithErrorOnDOCTYPE().newTransformer();\n \t\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n \t\t\t\ttransformer.setOutputProperty(OutputKeys.ENCODING, \"UTF-8\"); //$NON-NLS-1$\n \t\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"no\"); //$NON-NLS-1$\n@@ -121,7 +121,7 @@ public void store(ContentAssistHistory history, StreamResult result) throws Core\n \t\tpublic ContentAssistHistory load(InputSource source) throws CoreException {\n \t\t\tElement root;\n \t\t\ttry {\n-\t\t\t\tDocumentBuilder parser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n+\t\t\t\tDocumentBuilder parser = XmlProcessorFactoryJdtUi.createDocumentBuilderFactoryWithErrorOnDOCTYPE().newDocumentBuilder();\n \t\t\t\tparser.setErrorHandler(new DefaultHandler());\n \t\t\t\troot = parser.parse(source).getDocumentElement();\n \t\t\t} catch (SAXException | ParserConfigurationException | IOException e) {",
    "function_modified_lines": {
      "added": [
        "\t\t\t\tTransformer transformer= XmlProcessorFactoryJdtUi.createTransformerFactoryWithErrorOnDOCTYPE().newTransformer();\n",
        "\t\t\t\tDocumentBuilder parser = XmlProcessorFactoryJdtUi.createDocumentBuilderFactoryWithErrorOnDOCTYPE().newDocumentBuilder();\n"
      ],
      "deleted": [
        "\t\t\t\tTransformer transformer=TransformerFactory.newInstance().newTransformer();\n",
        "\t\t\t\tDocumentBuilder parser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "In Eclipse IDE versions < 2023-09 (4.29) some files with xml content are parsed vulnerable against all sorts of XXE attacks. The user just needs to open any evil project or update an open project with a vulnerable file (for example for review a foreign repository or patch).\n",
    "id": 12854
  },
  {
    "cve_id": "CVE-2023-4218",
    "code_before_change": "try {\n\t\t\tsaxParser = SAXParserFactory.newInstance().newSAXParser();\n\t\t} catch (ParserConfigurationException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn null;\n\t\t} catch (SAXException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn null;\n\t\t}",
    "code_after_change": "try {\n\t\t\t@SuppressWarnings(\"restriction\")\n\t\t\tSAXParser p = org.eclipse.core.internal.runtime.XmlProcessorFactory.createSAXParserWithErrorOnDOCTYPE();\n\t\t\tsaxParser =p;\n\t\t} catch (SAXException | ParserConfigurationException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn null;\n\t\t}",
    "patch": "@@ -42,11 +42,10 @@ public static String[] buildTables(\n \t\tList<String> result = new ArrayList<>();\n \t\tSAXParser saxParser = null;\n \t\ttry {\n-\t\t\tsaxParser = SAXParserFactory.newInstance().newSAXParser();\n-\t\t} catch (ParserConfigurationException e) {\n-\t\t\te.printStackTrace();\n-\t\t\treturn null;\n-\t\t} catch (SAXException e) {\n+\t\t\t@SuppressWarnings(\"restriction\")\n+\t\t\tSAXParser p = org.eclipse.core.internal.runtime.XmlProcessorFactory.createSAXParserWithErrorOnDOCTYPE();\n+\t\t\tsaxParser =p;\n+\t\t} catch (SAXException | ParserConfigurationException e) {\n \t\t\te.printStackTrace();\n \t\t\treturn null;\n \t\t}",
    "function_modified_lines": {
      "added": [
        "\t\t\t@SuppressWarnings(\"restriction\")\n",
        "\t\t\tSAXParser p = org.eclipse.core.internal.runtime.XmlProcessorFactory.createSAXParserWithErrorOnDOCTYPE();\n",
        "\t\t\tsaxParser =p;\n",
        "\t\t} catch (SAXException | ParserConfigurationException e) {\n"
      ],
      "deleted": [
        "\t\t\tsaxParser = SAXParserFactory.newInstance().newSAXParser();\n",
        "\t\t} catch (ParserConfigurationException e) {\n",
        "\t\t\te.printStackTrace();\n",
        "\t\t\treturn null;\n",
        "\t\t} catch (SAXException e) {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "In Eclipse IDE versions < 2023-09 (4.29) some files with xml content are parsed vulnerable against all sorts of XXE attacks. The user just needs to open any evil project or update an open project with a vulnerable file (for example for review a foreign repository or patch).\n",
    "id": 12855
  },
  {
    "cve_id": "CVE-2023-4218",
    "code_before_change": "/*******************************************************************************\n * Copyright (c) 2009, 2016 Red Hat Inc. and others.\n *\n * This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n *\n * Contributors:\n *     Red Hat Inc. - initial API and implementation\n *******************************************************************************/\npackage org.eclipse.cdt.internal.autotools.core.configure;\n\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Random;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\n\nimport org.eclipse.cdt.autotools.core.AutotoolsNewProjectNature;\nimport org.eclipse.cdt.autotools.core.AutotoolsPlugin;\nimport org.eclipse.cdt.autotools.core.IAutotoolsOption;\nimport org.eclipse.cdt.core.model.CoreModel;\nimport org.eclipse.cdt.core.settings.model.ICConfigurationDescription;\nimport org.eclipse.cdt.core.settings.model.ICProjectDescription;\nimport org.eclipse.cdt.core.settings.model.extension.CConfigurationData;\nimport org.eclipse.cdt.internal.autotools.core.configure.AutotoolsConfiguration.Option;\nimport org.eclipse.cdt.managedbuilder.core.BuildException;\nimport org.eclipse.cdt.managedbuilder.core.IConfiguration;\nimport org.eclipse.cdt.managedbuilder.core.IHoldsOptions;\nimport org.eclipse.cdt.managedbuilder.core.IOption;\nimport org.eclipse.cdt.managedbuilder.core.ITool;\nimport org.eclipse.cdt.managedbuilder.core.IToolChain;\nimport org.eclipse.cdt.managedbuilder.core.ManagedBuildManager;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.resources.IResourceChangeEvent;\nimport org.eclipse.core.resources.IResourceChangeListener;\nimport org.eclipse.core.resources.IResourceDelta;\nimport org.eclipse.core.resources.IWorkspaceRoot;\nimport org.eclipse.core.resources.ResourcesPlugin;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.IPath;\nimport org.eclipse.core.runtime.IStatus;\nimport org.eclipse.core.runtime.Status;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.SAXException;\n\npublic class AutotoolsConfigurationManager implements IResourceChangeListener {\n\n\tpublic static final String CFG_FILE_NAME = \".autotools\"; //$NON-NLS-1$\n\tprivate static final String CFG_CANT_SAVE = \"Configure.Error.NoProjectToSave\"; //$NON-NLS-1$\n\n\t/**\n\t * @since 1.2\n\t */\n\tpublic static final String INVALID_AUTOTOOLS_PROJECT = \"CfgOptions.Invalid.Project\"; //$NON-NLS-1$\n\t/**\n\t * @since 1.2\n\t */\n\n\tpublic static final String INVALID_AUTOTOOLS_CONFIG_ID = \"CfgOptions.Invalid.Config\"; //$NON-NLS-1$\n\n\tprivate static AutotoolsConfigurationManager instance;\n\tprivate static Random rand = new Random();\n\n\tprivate boolean isSyncing;\n\n\tprivate static Map<String, Map<String, IAConfiguration>> configs;\n\tprivate static Map<String, Map<String, IAConfiguration>> tmpConfigs;\n\n\tprivate AutotoolsConfigurationManager() {\n\t\tconfigs = new HashMap<>();\n\t\ttmpConfigs = new HashMap<>();\n\t\tResourcesPlugin.getWorkspace().addResourceChangeListener(this);\n\t}\n\n\tpublic static AutotoolsConfigurationManager getInstance() {",
    "code_after_change": "/*******************************************************************************\n * Copyright (c) 2009, 2016 Red Hat Inc. and others.\n *\n * This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n *\n * Contributors:\n *     Red Hat Inc. - initial API and implementation\n *******************************************************************************/\npackage org.eclipse.cdt.internal.autotools.core.configure;\n\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Random;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.ParserConfigurationException;\n\nimport org.eclipse.cdt.autotools.core.AutotoolsNewProjectNature;\nimport org.eclipse.cdt.autotools.core.AutotoolsPlugin;\nimport org.eclipse.cdt.autotools.core.IAutotoolsOption;\nimport org.eclipse.cdt.core.model.CoreModel;\nimport org.eclipse.cdt.core.settings.model.ICConfigurationDescription;\nimport org.eclipse.cdt.core.settings.model.ICProjectDescription;\nimport org.eclipse.cdt.core.settings.model.extension.CConfigurationData;\nimport org.eclipse.cdt.internal.autotools.core.configure.AutotoolsConfiguration.Option;\nimport org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\nimport org.eclipse.cdt.managedbuilder.core.BuildException;\nimport org.eclipse.cdt.managedbuilder.core.IConfiguration;\nimport org.eclipse.cdt.managedbuilder.core.IHoldsOptions;\nimport org.eclipse.cdt.managedbuilder.core.IOption;\nimport org.eclipse.cdt.managedbuilder.core.ITool;\nimport org.eclipse.cdt.managedbuilder.core.IToolChain;\nimport org.eclipse.cdt.managedbuilder.core.ManagedBuildManager;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.resources.IResourceChangeEvent;\nimport org.eclipse.core.resources.IResourceChangeListener;\nimport org.eclipse.core.resources.IResourceDelta;\nimport org.eclipse.core.resources.IWorkspaceRoot;\nimport org.eclipse.core.resources.ResourcesPlugin;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.IPath;\nimport org.eclipse.core.runtime.IStatus;\nimport org.eclipse.core.runtime.Platform;\nimport org.eclipse.core.runtime.Status;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.SAXException;\n\npublic class AutotoolsConfigurationManager implements IResourceChangeListener {\n\n\tpublic static final String CFG_FILE_NAME = \".autotools\"; //$NON-NLS-1$\n\tprivate static final String CFG_CANT_SAVE = \"Configure.Error.NoProjectToSave\"; //$NON-NLS-1$\n\n\t/**\n\t * @since 1.2\n\t */\n\tpublic static final String INVALID_AUTOTOOLS_PROJECT = \"CfgOptions.Invalid.Project\"; //$NON-NLS-1$\n\t/**\n\t * @since 1.2\n\t */\n\n\tpublic static final String INVALID_AUTOTOOLS_CONFIG_ID = \"CfgOptions.Invalid.Config\"; //$NON-NLS-1$\n\n\tprivate static AutotoolsConfigurationManager instance;\n\tprivate static Random rand = new Random();\n\n\tprivate boolean isSyncing;\n\n\tprivate static Map<String, Map<String, IAConfiguration>> configs;\n\tprivate static Map<String, Map<String, IAConfiguration>> tmpConfigs;\n\n\tprivate AutotoolsConfigurationManager() {\n\t\tconfigs = new HashMap<>();\n\t\ttmpConfigs = new HashMap<>();\n\t\tResourcesPlugin.getWorkspace().addResourceChangeListener(this);\n\t}",
    "patch": "@@ -27,7 +27,6 @@\n import java.util.Random;\n \n import javax.xml.parsers.DocumentBuilder;\n-import javax.xml.parsers.DocumentBuilderFactory;\n import javax.xml.parsers.ParserConfigurationException;\n \n import org.eclipse.cdt.autotools.core.AutotoolsNewProjectNature;\n@@ -38,6 +37,7 @@\n import org.eclipse.cdt.core.settings.model.ICProjectDescription;\n import org.eclipse.cdt.core.settings.model.extension.CConfigurationData;\n import org.eclipse.cdt.internal.autotools.core.configure.AutotoolsConfiguration.Option;\n+import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n import org.eclipse.cdt.managedbuilder.core.BuildException;\n import org.eclipse.cdt.managedbuilder.core.IConfiguration;\n import org.eclipse.cdt.managedbuilder.core.IHoldsOptions;\n@@ -55,6 +55,7 @@\n import org.eclipse.core.runtime.CoreException;\n import org.eclipse.core.runtime.IPath;\n import org.eclipse.core.runtime.IStatus;\n+import org.eclipse.core.runtime.Platform;\n import org.eclipse.core.runtime.Status;\n import org.w3c.dom.Document;\n import org.w3c.dom.Element;\n@@ -203,8 +204,7 @@ private Map<String, IAConfiguration> getSavedConfigs(IProject project) {\n \t\t\t\tIPath fileLocation = project.getLocation().append(CFG_FILE_NAME);\n \t\t\t\tFile dirFile = fileLocation.toFile();\n \t\t\t\tMap<String, IAConfiguration> cfgList = new HashMap<>();\n-\t\t\t\tDocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n-\t\t\t\tDocumentBuilder db = dbf.newDocumentBuilder();\n+\t\t\t\tDocumentBuilder db = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\t\tif (dirFile.exists()) {\n \t\t\t\t\tDocument d = db.parse(dirFile);\n \t\t\t\t\tElement e = d.getDocumentElement();\n@@ -269,7 +269,8 @@ else if (nameNode != null) {\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t} catch (ParserConfigurationException | SAXException | IOException e) {\n-\t\t\t\te.printStackTrace();\n+\t\t\t\tPlatform.getLog(AutotoolsConfigurationManager.class)\n+\t\t\t\t\t\t.error(\"Error while parsing .autotools file in project\", e); //$NON-NLS-1$\n \t\t\t}\n \t\t}\n \t\treturn list;",
    "function_modified_lines": {
      "added": [
        "import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n",
        "import org.eclipse.core.runtime.Platform;\n"
      ],
      "deleted": [
        "import javax.xml.parsers.DocumentBuilderFactory;\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "In Eclipse IDE versions < 2023-09 (4.29) some files with xml content are parsed vulnerable against all sorts of XXE attacks. The user just needs to open any evil project or update an open project with a vulnerable file (for example for review a foreign repository or patch).\n",
    "id": 12856
  },
  {
    "cve_id": "CVE-2023-4218",
    "code_before_change": "/*******************************************************************************\n * Copyright (c) 2008, 2016 Red Hat Inc. and others.\n *\n * This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n *\n * Contributors:\n *     Red Hat Incorporated - initial API and implementation\n *     Marc-Andre Laperle - Fix failing test on Windows\n *******************************************************************************/\npackage org.eclipse.cdt.autotools.tests;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\n\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.Map;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\n\nimport org.eclipse.cdt.autotools.core.AutotoolsOptionConstants;\nimport org.eclipse.cdt.autotools.core.IAutotoolsOption;\nimport org.eclipse.cdt.core.model.CoreModel;\nimport org.eclipse.cdt.core.settings.model.ICConfigurationDescription;\nimport org.eclipse.cdt.internal.autotools.core.configure.AutotoolsConfigurationManager;\nimport org.eclipse.cdt.managedbuilder.core.IConfiguration;\nimport org.eclipse.cdt.managedbuilder.core.ManagedBuildManager;\nimport org.eclipse.cdt.managedbuilder.core.ManagedCProjectNature;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.runtime.IPath;\nimport org.eclipse.core.runtime.NullProgressMonitor;\nimport org.eclipse.core.runtime.Path;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.SAXException;\n\n// This test verifies an autogen.sh project that builds configure, but\n// does not run it.\npublic class UpdateConfigureTest {\n\n\tprivate IProject testProject;\n\n\t@Before\n\tpublic void setUp() throws Exception {\n\t\tif (!ProjectTools.setup())\n\t\t\tfail(\"could not perform basic project workspace setup\");\n\t\ttestProject = ProjectTools.createProject(\"testProject2\");\n\t\tif (testProject == null) {\n\t\t\tfail(\"Unable to create test project\");\n\t\t}\n\t\ttestProject.open(new NullProgressMonitor());\n\t}\n\n\t/**\n\t * Test setting the special advanced options for gcov, gprof, and debug flags.  Verify that\n\t * the configure script sets both the C and C++ flags.",
    "code_after_change": "/*******************************************************************************\n * Copyright (c) 2008, 2016 Red Hat Inc. and others.\n *\n * This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n *\n * Contributors:\n *     Red Hat Incorporated - initial API and implementation\n *     Marc-Andre Laperle - Fix failing test on Windows\n *******************************************************************************/\npackage org.eclipse.cdt.autotools.tests;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\n\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.Map;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.ParserConfigurationException;\n\nimport org.eclipse.cdt.autotools.core.AutotoolsOptionConstants;\nimport org.eclipse.cdt.autotools.core.IAutotoolsOption;\nimport org.eclipse.cdt.core.model.CoreModel;\nimport org.eclipse.cdt.core.settings.model.ICConfigurationDescription;\nimport org.eclipse.cdt.internal.autotools.core.configure.AutotoolsConfigurationManager;\nimport org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\nimport org.eclipse.cdt.managedbuilder.core.IConfiguration;\nimport org.eclipse.cdt.managedbuilder.core.ManagedBuildManager;\nimport org.eclipse.cdt.managedbuilder.core.ManagedCProjectNature;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.runtime.IPath;\nimport org.eclipse.core.runtime.NullProgressMonitor;\nimport org.eclipse.core.runtime.Path;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.SAXException;\n\n// This test verifies an autogen.sh project that builds configure, but\n// does not run it.\npublic class UpdateConfigureTest {\n\n\tprivate IProject testProject;\n\n\t@Before\n\tpublic void setUp() throws Exception {\n\t\tif (!ProjectTools.setup())\n\t\t\tfail(\"could not perform basic project workspace setup\");\n\t\ttestProject = ProjectTools.createProject(\"testProject2\");\n\t\tif (testProject == null) {\n\t\t\tfail(\"Unable to create test project\");\n\t\t}\n\t\ttestProject.open(new NullProgressMonitor());\n\t}\n\n\t/**",
    "patch": "@@ -25,14 +25,14 @@\n import java.util.Map;\n \n import javax.xml.parsers.DocumentBuilder;\n-import javax.xml.parsers.DocumentBuilderFactory;\n import javax.xml.parsers.ParserConfigurationException;\n \n import org.eclipse.cdt.autotools.core.AutotoolsOptionConstants;\n import org.eclipse.cdt.autotools.core.IAutotoolsOption;\n import org.eclipse.cdt.core.model.CoreModel;\n import org.eclipse.cdt.core.settings.model.ICConfigurationDescription;\n import org.eclipse.cdt.internal.autotools.core.configure.AutotoolsConfigurationManager;\n+import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n import org.eclipse.cdt.managedbuilder.core.IConfiguration;\n import org.eclipse.cdt.managedbuilder.core.ManagedBuildManager;\n import org.eclipse.cdt.managedbuilder.core.ManagedCProjectNature;\n@@ -535,8 +535,7 @@ public void testGetAndUpdateConfigureOptions() throws Exception {\n \t\ttry {\n \t\t\tIPath fileLocation = testProject.getLocation().append(\".autotools\"); //$NON-NLS-1$\n \t\t\tFile dirFile = fileLocation.toFile();\n-\t\t\tDocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n-\t\t\tDocumentBuilder db = dbf.newDocumentBuilder();\n+\t\t\tDocumentBuilder db = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tassertTrue(dirFile.exists());\n \t\t\tDocument d = db.parse(dirFile);\n \t\t\tElement e = d.getDocumentElement();",
    "function_modified_lines": {
      "added": [
        "import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n"
      ],
      "deleted": [
        "import javax.xml.parsers.DocumentBuilderFactory;\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "In Eclipse IDE versions < 2023-09 (4.29) some files with xml content are parsed vulnerable against all sorts of XXE attacks. The user just needs to open any evil project or update an open project with a vulnerable file (for example for review a foreign repository or patch).\n",
    "id": 12857
  },
  {
    "cve_id": "CVE-2023-4218",
    "code_before_change": " *  https://www.eclipse.org/legal/epl-2.0/\n *\n *  SPDX-License-Identifier: EPL-2.0\n *\n *  Contributors:\n *     IBM - Initial API and implementation\n *     Anna Dushistova (MontaVista) - [366771]Converter fails to convert a CDT makefile project\n *******************************************************************************/\npackage org.eclipse.cdt.managedbuilder.core;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URI;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Random;\nimport java.util.Set;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.FactoryConfigurationError;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.TransformerFactoryConfigurationError;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.eclipse.cdt.core.AbstractCExtension;\nimport org.eclipse.cdt.core.CCorePlugin;\nimport org.eclipse.cdt.core.IConsoleParser;\nimport org.eclipse.cdt.core.language.settings.providers.ICBuildOutputParser;\nimport org.eclipse.cdt.core.language.settings.providers.ILanguageSettingsProvider;\nimport org.eclipse.cdt.core.language.settings.providers.ILanguageSettingsProvidersKeeper;\nimport org.eclipse.cdt.core.language.settings.providers.IWorkingDirectoryTracker;\nimport org.eclipse.cdt.core.language.settings.providers.LanguageSettingsManager;\nimport org.eclipse.cdt.core.model.CoreModel;\nimport org.eclipse.cdt.core.model.CoreModelUtil;\nimport org.eclipse.cdt.core.settings.model.ICConfigurationDescription;\nimport org.eclipse.cdt.core.settings.model.ICMultiConfigDescription;\nimport org.eclipse.cdt.core.settings.model.ICProjectDescription;\nimport org.eclipse.cdt.core.settings.model.ICProjectDescriptionManager;\nimport org.eclipse.cdt.core.settings.model.ICSettingEntry;\nimport org.eclipse.cdt.core.settings.model.XmlStorageUtil;\nimport org.eclipse.cdt.core.settings.model.extension.CConfigurationData;\nimport org.eclipse.cdt.managedbuilder.buildproperties.IBuildProperty;\nimport org.eclipse.cdt.managedbuilder.buildproperties.IBuildPropertyManager;\nimport org.eclipse.cdt.managedbuilder.envvar.IEnvironmentVariableProvider;\nimport org.eclipse.cdt.managedbuilder.internal.buildproperties.BuildPropertyManager;\nimport org.eclipse.cdt.managedbuilder.internal.core.BooleanExpressionApplicabilityCalculator;\nimport org.eclipse.cdt.managedbuilder.internal.core.BuildDbgUtil;\nimport org.eclipse.cdt.managedbuilder.internal.core.BuildObject;\nimport org.eclipse.cdt.managedbuilder.internal.core.BuildSettingsUtil;\nimport org.eclipse.cdt.managedbuilder.internal.core.Builder;\nimport org.eclipse.cdt.managedbuilder.internal.core.BuilderFactory;\nimport org.eclipse.cdt.managedbuilder.internal.core.CommonBuilder;\nimport org.eclipse.cdt.managedbuilder.internal.core.Configuration;\nimport org.eclipse.cdt.managedbuilder.internal.core.DefaultManagedConfigElement;\nimport org.eclipse.cdt.managedbuilder.internal.core.FolderInfo;\nimport org.eclipse.cdt.managedbuilder.internal.core.IMatchKeyProvider;",
    "code_after_change": " *  are made available under the terms of the Eclipse Public License 2.0\n *  which accompanies this distribution, and is available at\n *  https://www.eclipse.org/legal/epl-2.0/\n *\n *  SPDX-License-Identifier: EPL-2.0\n *\n *  Contributors:\n *     IBM - Initial API and implementation\n *     Anna Dushistova (MontaVista) - [366771]Converter fails to convert a CDT makefile project\n *******************************************************************************/\npackage org.eclipse.cdt.managedbuilder.core;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URI;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Random;\nimport java.util.Set;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.FactoryConfigurationError;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactoryConfigurationError;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.eclipse.cdt.core.AbstractCExtension;\nimport org.eclipse.cdt.core.CCorePlugin;\nimport org.eclipse.cdt.core.IConsoleParser;\nimport org.eclipse.cdt.core.language.settings.providers.ICBuildOutputParser;\nimport org.eclipse.cdt.core.language.settings.providers.ILanguageSettingsProvider;\nimport org.eclipse.cdt.core.language.settings.providers.ILanguageSettingsProvidersKeeper;\nimport org.eclipse.cdt.core.language.settings.providers.IWorkingDirectoryTracker;\nimport org.eclipse.cdt.core.language.settings.providers.LanguageSettingsManager;\nimport org.eclipse.cdt.core.model.CoreModel;\nimport org.eclipse.cdt.core.model.CoreModelUtil;\nimport org.eclipse.cdt.core.settings.model.ICConfigurationDescription;\nimport org.eclipse.cdt.core.settings.model.ICMultiConfigDescription;\nimport org.eclipse.cdt.core.settings.model.ICProjectDescription;\nimport org.eclipse.cdt.core.settings.model.ICProjectDescriptionManager;\nimport org.eclipse.cdt.core.settings.model.ICSettingEntry;\nimport org.eclipse.cdt.core.settings.model.XmlStorageUtil;\nimport org.eclipse.cdt.core.settings.model.extension.CConfigurationData;\nimport org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\nimport org.eclipse.cdt.managedbuilder.buildproperties.IBuildProperty;\nimport org.eclipse.cdt.managedbuilder.buildproperties.IBuildPropertyManager;\nimport org.eclipse.cdt.managedbuilder.envvar.IEnvironmentVariableProvider;\nimport org.eclipse.cdt.managedbuilder.internal.buildproperties.BuildPropertyManager;\nimport org.eclipse.cdt.managedbuilder.internal.core.BooleanExpressionApplicabilityCalculator;\nimport org.eclipse.cdt.managedbuilder.internal.core.BuildDbgUtil;\nimport org.eclipse.cdt.managedbuilder.internal.core.BuildObject;\nimport org.eclipse.cdt.managedbuilder.internal.core.BuildSettingsUtil;\nimport org.eclipse.cdt.managedbuilder.internal.core.Builder;\nimport org.eclipse.cdt.managedbuilder.internal.core.BuilderFactory;\nimport org.eclipse.cdt.managedbuilder.internal.core.CommonBuilder;\nimport org.eclipse.cdt.managedbuilder.internal.core.Configuration;\nimport org.eclipse.cdt.managedbuilder.internal.core.DefaultManagedConfigElement;\nimport org.eclipse.cdt.managedbuilder.internal.core.FolderInfo;\nimport org.eclipse.cdt.managedbuilder.internal.core.IMatchKeyProvider;\nimport org.eclipse.cdt.managedbuilder.internal.core.InputType;",
    "patch": "@@ -38,14 +38,12 @@\n import java.util.TreeMap;\n \n import javax.xml.parsers.DocumentBuilder;\n-import javax.xml.parsers.DocumentBuilderFactory;\n import javax.xml.parsers.FactoryConfigurationError;\n import javax.xml.parsers.ParserConfigurationException;\n import javax.xml.transform.OutputKeys;\n import javax.xml.transform.Transformer;\n import javax.xml.transform.TransformerConfigurationException;\n import javax.xml.transform.TransformerException;\n-import javax.xml.transform.TransformerFactory;\n import javax.xml.transform.TransformerFactoryConfigurationError;\n import javax.xml.transform.dom.DOMSource;\n import javax.xml.transform.stream.StreamResult;\n@@ -67,6 +65,7 @@\n import org.eclipse.cdt.core.settings.model.ICSettingEntry;\n import org.eclipse.cdt.core.settings.model.XmlStorageUtil;\n import org.eclipse.cdt.core.settings.model.extension.CConfigurationData;\n+import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n import org.eclipse.cdt.managedbuilder.buildproperties.IBuildProperty;\n import org.eclipse.cdt.managedbuilder.buildproperties.IBuildPropertyManager;\n import org.eclipse.cdt.managedbuilder.envvar.IEnvironmentVariableProvider;\n@@ -1089,7 +1088,7 @@ public static boolean saveBuildInfoLegacy(IProject project, boolean force) {\n \t\t// Create document\n \t\tException err = null;\n \t\ttry {\n-\t\t\tDocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n+\t\t\tDocumentBuilder builder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tDocument doc = builder.newDocument();\n \n \t\t\t// Get the build information for the project\n@@ -1111,7 +1110,8 @@ public static boolean saveBuildInfoLegacy(IProject project, boolean force) {\n \n \t\t\t\t// Transform the document to something we can save in a file\n \t\t\t\tByteArrayOutputStream stream = new ByteArrayOutputStream();\n-\t\t\t\tTransformer transformer = TransformerFactory.newInstance().newTransformer();\n+\t\t\t\tTransformer transformer = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE()\n+\t\t\t\t\t\t.newTransformer();\n \t\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n \t\t\t\ttransformer.setOutputProperty(OutputKeys.ENCODING, \"UTF-8\"); //$NON-NLS-1$\n \t\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n@@ -1261,7 +1261,7 @@ private static boolean updateBuildInfo(IProject project, boolean force) throws C\n \t\t// Create document\n \t\tException err = null;\n \t\ttry {\n-\t\t\tDocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n+\t\t\tDocumentBuilder builder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tDocument doc = builder.newDocument();\n \n \t\t\t// Get the build information for the project\n@@ -1284,7 +1284,7 @@ private static boolean updateBuildInfo(IProject project, boolean force) throws C\n \n \t\t\t\t// Transform the document to something we can save in a file\n \t\t\t\tByteArrayOutputStream stream = new ByteArrayOutputStream();\n-\t\t\t\tTransformer transformer = TransformerFactory.newInstance().newTransformer();\n+\t\t\t\tTransformer transformer = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE().newTransformer();\n \t\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\");\t//$NON-NLS-1$\n \t\t\t\ttransformer.setOutputProperty(OutputKeys.ENCODING, \"UTF-8\"); //$NON-NLS-1$\n \t\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\t//$NON-NLS-1$\n@@ -1836,7 +1836,7 @@ private static ManagedBuildInfo loadOldStyleBuildInfo(final IProject project) th\n \n \t\t// So there is a project file, load the information there\n \t\ttry (InputStream stream = new FileInputStream(cdtbuild)) {\n-\t\t\tDocumentBuilder parser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n+\t\t\tDocumentBuilder parser = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tDocument document = parser.parse(stream);\n \t\t\tString fileVersion = null;\n \n@@ -2516,7 +2516,7 @@ public static boolean manages(IResource resource) {\n \t\t//\t\tif (file.exists()) {\n \t\t//\t\t\ttry {\n \t\t//\t\t\t\tInputStream stream = file.getContents();\n-\t\t//\t\t\t\tDocumentBuilder parser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n+\t\t//\t\t\t\tDocumentBuilder parser = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t//\t\t\t\tDocument document = parser.parse(stream);\n \t\t//\t\t\t\tNodeList nodes = document.getElementsByTagName(ROOT_NODE_NAME);\n \t\t//\t\t\t\treturn (nodes.getLength() > 0);",
    "function_modified_lines": {
      "added": [],
      "deleted": [
        "import javax.xml.parsers.DocumentBuilderFactory;\n",
        "import javax.xml.transform.TransformerFactory;\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "In Eclipse IDE versions < 2023-09 (4.29) some files with xml content are parsed vulnerable against all sorts of XXE attacks. The user just needs to open any evil project or update an open project with a vulnerable file (for example for review a foreign repository or patch).\n",
    "id": 12858
  },
  {
    "cve_id": "CVE-2023-4218",
    "code_before_change": "/*******************************************************************************\n * Copyright (c) 2007, 2015 IBM Corporation and others.\n *\n * This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n *\n * Contributors:\n * \t   IBM Corporation - Initial API and implementation\n *     James Blackburn (Broadcom Corp.)\n *     Sergey Prigogin (Google)\n *******************************************************************************/\npackage org.eclipse.cdt.internal.core.language;\n\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.io.StringWriter;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.TreeMap;\n\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.TransformerFactoryConfigurationError;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.eclipse.cdt.core.CCorePlugin;\nimport org.eclipse.cdt.core.CCorePreferenceConstants;\nimport org.eclipse.cdt.core.language.ProjectLanguageConfiguration;\nimport org.eclipse.cdt.core.language.WorkspaceLanguageConfiguration;\nimport org.eclipse.cdt.core.settings.model.ICConfigurationDescription;\nimport org.eclipse.cdt.core.settings.model.ICProjectDescription;\nimport org.eclipse.cdt.core.settings.model.ICStorageElement;\nimport org.eclipse.cdt.internal.core.Util;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.preferences.DefaultScope;\nimport org.eclipse.core.runtime.preferences.IEclipsePreferences;\nimport org.eclipse.core.runtime.preferences.InstanceScope;\nimport org.osgi.service.prefs.BackingStoreException;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\n\n/**\n * Serializes and deserializes language mappings to and from persistent storage.\n */\npublic class LanguageMappingStore {\n\tprivate static final String LANGUAGE_MAPPING_ID = \"org.eclipse.cdt.core.language.mapping\"; //$NON-NLS-1$\n\tprivate static final String PROJECT_MAPPINGS = \"project-mappings\"; //$NON-NLS-1$\n\tprivate static final String WORKSPACE_MAPPINGS = \"workspace-mappings\"; //$NON-NLS-1$\n\tprivate static final String CONTENT_TYPE_MAPPING = \"content-type-mapping\"; //$NON-NLS-1$\n\tprivate static final String FILE_MAPPING = \"file-mapping\"; //$NON-NLS-1$\n\tprivate static final String ATTRIBUTE_PATH = \"path\"; //$NON-NLS-1$\n\tprivate static final String ATTRIBUTE_CONTENT_TYPE = \"content-type\"; //$NON-NLS-1$\n\tprivate static final String ATTRIBUTE_LANGUAGE = \"language\"; //$NON-NLS-1$\n\tprivate static final String ATTRIBUTE_CONFIGURATION = \"configuration\"; //$NON-NLS-1$\n\n\tpublic LanguageMappingStore() {\n\t}\n\n\tpublic ProjectLanguageConfiguration decodeMappings(IProject project) throws CoreException {\n\t\tProjectLanguageConfiguration config = new ProjectLanguageConfiguration();\n\t\tICProjectDescription descriptor = getProjectDescription(project, false);\n\t\tif (descriptor != null) {\n\t\t\tICStorageElement rootElement = descriptor.getStorage(LANGUAGE_MAPPING_ID, false);\n\t\t\tif (rootElement == null) {\n\t\t\t\t// bug 367061 - backwards compatibility: fallback to default configuration settings\n\t\t\t\tICConfigurationDescription cfgDesc = descriptor.getDefaultSettingConfiguration();\n\t\t\t\tif (cfgDesc != null) {\n\t\t\t\t\trootElement = cfgDesc.getStorage(LANGUAGE_MAPPING_ID, false);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rootElement != null) {\n\t\t\t\tICStorageElement[] mappingElements = rootElement.getChildrenByName(PROJECT_MAPPINGS);\n\t\t\t\tif (mappingElements.length > 0) {\n\t\t\t\t\tICStorageElement element = mappingElements[0];\n\t\t\t\t\tconfig.setContentTypeMappings(decodeProjectContentTypeMappings(element));\n\t\t\t\t\tconfig.setFileMappings(decodeFileMappings(element));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn config;\n\t}\n\n\tprivate Map<String, Map<String, String>> decodeProjectContentTypeMappings(ICStorageElement rootElement) {\n\t\tMap<String, Map<String, String>> decodedMappings = new TreeMap<>();\n\t\tICStorageElement[] mappingElements = rootElement.getChildrenByName(CONTENT_TYPE_MAPPING);\n\t\tfor (int j = 0; j < mappingElements.length; j++) {\n\t\t\tICStorageElement mapping = mappingElements[j];\n\t\t\tString configuration = mapping.getAttribute(ATTRIBUTE_CONFIGURATION);\n\n\t\t\tMap<String, String> contentTypeMappings = decodedMappings.get(configuration);\n\t\t\tif (contentTypeMappings == null) {\n\t\t\t\tcontentTypeMappings = new TreeMap<>();\n\t\t\t\tdecodedMappings.put(configuration, contentTypeMappings);\n\t\t\t}\n\t\t\tString contentType = mapping.getAttribute(ATTRIBUTE_CONTENT_TYPE);\n\t\t\tString language = mapping.getAttribute(ATTRIBUTE_LANGUAGE);\n\t\t\tcontentTypeMappings.put(contentType, language);\n\t\t}\n\t\treturn decodedMappings;\n\t}\n\n\tprotected ICProjectDescription getProjectDescription(IProject project, boolean write) throws CoreException {\n\t\treturn CCorePlugin.getDefault().getProjectDescription(project, write);\n\t}\n\n\tprivate Map<String, String> decodeContentTypeMappings(Element rootElement) throws CoreException {\n\t\treturn decodeMappings(rootElement, CONTENT_TYPE_MAPPING, ATTRIBUTE_CONTENT_TYPE, ATTRIBUTE_LANGUAGE);\n\t}\n\n\tprivate Map<String, Map<String, String>> decodeFileMappings(ICStorageElement rootElement) throws CoreException {\n\t\tMap<String, Map<String, String>> decodedMappings = new TreeMap<>();\n\t\tICStorageElement[] mappingElements = rootElement.getChildrenByName(FILE_MAPPING);\n\t\tfor (int j = 0; j < mappingElements.length; j++) {\n\t\t\tICStorageElement mapping = mappingElements[j];\n\t\t\tString path = mapping.getAttribute(ATTRIBUTE_PATH);\n\n\t\t\tMap<String, String> configurationMappings = decodedMappings.get(path);\n\t\t\tif (configurationMappings == null) {\n\t\t\t\tconfigurationMappings = new TreeMap<>();\n\t\t\t\tdecodedMappings.put(path, configurationMappings);\n\t\t\t}\n\t\t\tString configuration = mapping.getAttribute(ATTRIBUTE_CONFIGURATION);\n\t\t\tString language = mapping.getAttribute(ATTRIBUTE_LANGUAGE);\n\t\t\tconfigurationMappings.put(configuration, language);\n\t\t}\n\t\treturn decodedMappings;\n\t}\n\n\tprivate Map<String, String> decodeMappings(Element rootElement, String category, String keyName, String valueName) {\n\t\tMap<String, String> decodedMappings = new TreeMap<>();\n\t\tNodeList mappingElements = rootElement.getElementsByTagName(category);\n\t\tfor (int j = 0; j < mappingElements.getLength(); j++) {\n\t\t\tElement mapping = (Element) mappingElements.item(j);\n\t\t\tString key = mapping.getAttribute(keyName);\n\t\t\tString value = mapping.getAttribute(valueName);\n\t\t\tdecodedMappings.put(key, value);\n\t\t}\n\t\treturn decodedMappings;\n\t}\n\n\tpublic void storeMappings(IProject project, ProjectLanguageConfiguration config) throws CoreException {\n\t\tICProjectDescription descriptor = getProjectDescription(project, true);\n\t\tICConfigurationDescription cfgDesc = descriptor.getDefaultSettingConfiguration();\n\t\t// remove old storage location if any\n\t\tif (cfgDesc != null && cfgDesc.getStorage(LANGUAGE_MAPPING_ID, false) != null) {\n\t\t\tcfgDesc.removeStorage(LANGUAGE_MAPPING_ID);\n\t\t}\n\t\tICStorageElement rootElement = descriptor.getStorage(LANGUAGE_MAPPING_ID, true);\n\t\t// clear all children and settings\n\t\trootElement.clear();\n\n\t\tICStorageElement projectMappings = rootElement.createChild(PROJECT_MAPPINGS);\n\n\t\taddProjectContentTypeMappings(config.getContentTypeMappings(), projectMappings);\n\t\taddFileMappings(config.getFileMappings(), projectMappings);\n\t\tCCorePlugin.getDefault().setProjectDescription(project, descriptor);\n\t}\n\n\tprivate void addProjectContentTypeMappings(Map<String, Map<String, String>> contentTypeMappings,\n\t\t\tICStorageElement rootElement) {\n\t\tIterator<Entry<String, Map<String, String>>> entries = contentTypeMappings.entrySet().iterator();\n\t\twhile (entries.hasNext()) {\n\t\t\tEntry<String, Map<String, String>> entry = entries.next();\n\n\t\t\tString configuration = entry.getKey();\n\t\t\tIterator<Entry<String, String>> contentTypeEntries = entry.getValue().entrySet().iterator();\n\t\t\twhile (contentTypeEntries.hasNext()) {\n\t\t\t\tEntry<String, String> configurationEntry = contentTypeEntries.next();\n\t\t\t\tString contentType = configurationEntry.getKey();\n\t\t\t\tString language = configurationEntry.getValue();\n\n\t\t\t\tICStorageElement mapping = rootElement.createChild(CONTENT_TYPE_MAPPING);\n\t\t\t\tmapping.setAttribute(ATTRIBUTE_CONTENT_TYPE, contentType);\n\t\t\t\tmapping.setAttribute(ATTRIBUTE_CONFIGURATION, configuration);\n\t\t\t\tmapping.setAttribute(ATTRIBUTE_LANGUAGE, language);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void storeMappings(WorkspaceLanguageConfiguration config) throws CoreException {\n\t\ttry {\n\t\t\t// Encode mappings as XML and serialize as a String.\n\t\t\tDocument doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n\t\t\tElement rootElement = doc.createElement(WORKSPACE_MAPPINGS);\n\t\t\tdoc.appendChild(rootElement);\n\t\t\taddContentTypeMappings(config.getWorkspaceMappings(), rootElement);\n\t\t\tTransformer serializer = createSerializer();\n\t\t\tDOMSource source = new DOMSource(doc);\n\t\t\tStringWriter buffer = new StringWriter();\n\t\t\tStreamResult result = new StreamResult(buffer);\n\t\t\tserializer.transform(source, result);\n\t\t\tString encodedMappings = buffer.getBuffer().toString();\n\n\t\t\tIEclipsePreferences node = InstanceScope.INSTANCE.getNode(CCorePlugin.PLUGIN_ID);\n\t\t\tnode.put(CCorePreferenceConstants.WORKSPACE_LANGUAGE_MAPPINGS, encodedMappings);\n\t\t\tnode.flush();\n\t\t} catch (ParserConfigurationException e) {\n\t\t\tthrow new CoreException(Util.createStatus(e));\n\t\t} catch (TransformerException e) {\n\t\t\tthrow new CoreException(Util.createStatus(e));\n\t\t} catch (BackingStoreException e) {\n\t\t\tthrow new CoreException(Util.createStatus(e));\n\t\t}\n\t}\n\n\tpublic WorkspaceLanguageConfiguration decodeWorkspaceMappings() throws CoreException {\n\t\tIEclipsePreferences node = InstanceScope.INSTANCE.getNode(CCorePlugin.PLUGIN_ID);\n\t\tIEclipsePreferences defaultNode = DefaultScope.INSTANCE.getNode(CCorePlugin.PLUGIN_ID);\n\t\tString encodedMappings = node.get(CCorePreferenceConstants.WORKSPACE_LANGUAGE_MAPPINGS, null);\n\t\tif (encodedMappings == null) {\n\t\t\tencodedMappings = defaultNode.get(CCorePreferenceConstants.WORKSPACE_LANGUAGE_MAPPINGS, null);\n\t\t}\n\t\tWorkspaceLanguageConfiguration config = new WorkspaceLanguageConfiguration();\n\n\t\tif (encodedMappings == null || encodedMappings.length() == 0) {\n\t\t\treturn config;\n\t\t}\n\n\t\t// The mappings are encoded as XML in a String so we need to parse it.\n\t\tInputSource input = new InputSource(new StringReader(encodedMappings));\n\t\ttry {\n\t\t\tDocument document = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(input);\n\t\t\tconfig.setWorkspaceMappings(decodeContentTypeMappings(document.getDocumentElement()));\n\t\t\treturn config;\n\t\t} catch (SAXException e) {\n\t\t\tthrow new CoreException(Util.createStatus(e));\n\t\t} catch (IOException e) {\n\t\t\tthrow new CoreException(Util.createStatus(e));\n\t\t} catch (ParserConfigurationException e) {\n\t\t\tthrow new CoreException(Util.createStatus(e));\n\t\t}\n\t}\n\n\tprivate Transformer createSerializer() throws CoreException {\n\t\ttry {\n\t\t\treturn TransformerFactory.newInstance().newTransformer();\n\t\t} catch (TransformerConfigurationException e) {\n\t\t\tthrow new CoreException(Util.createStatus(e));\n\t\t} catch (TransformerFactoryConfigurationError e) {\n\t\t\tthrow new CoreException(Util.createStatus(e));\n\t\t}\n\t}\n\n\tprivate void addMappings(Map<String, String> mappings, Element rootElement, String category, String keyName,\n\t\t\tString valueName) {\n\t\tDocument document = rootElement.getOwnerDocument();\n\t\tIterator<Entry<String, String>> entries = mappings.entrySet().iterator();\n\t\twhile (entries.hasNext()) {\n\t\t\tEntry<String, String> entry = entries.next();\n\t\t\tElement mapping = document.createElement(category);\n\t\t\tmapping.setAttribute(keyName, entry.getKey());\n\t\t\tmapping.setAttribute(valueName, entry.getValue());\n\t\t\trootElement.appendChild(mapping);\n\t\t}\n\t}\n\n\tprivate void addContentTypeMappings(Map<String, String> mappings, Element rootElement) {\n\t\taddMappings(mappings, rootElement, CONTENT_TYPE_MAPPING, ATTRIBUTE_CONTENT_TYPE, ATTRIBUTE_LANGUAGE);\n\t}\n\n\tprivate void addFileMappings(Map<String, Map<String, String>> mappings, ICStorageElement rootElement) {\n\t\tfor (Map.Entry<String, Map<String, String>> entry : mappings.entrySet()) {\n\t\t\tif (!entry.getValue().isEmpty()) {\n\t\t\t\tICStorageElement mapping = rootElement.createChild(FILE_MAPPING);\n\t\t\t\tString path = entry.getKey();\n\t\t\t\tfor (Entry<String, String> configurationEntry : entry.getValue().entrySet()) {\n\t\t\t\t\tString configuration = configurationEntry.getKey();\n\t\t\t\t\tString language = configurationEntry.getValue();\n\n\t\t\t\t\tmapping.setAttribute(ATTRIBUTE_PATH, path);\n\t\t\t\t\tmapping.setAttribute(ATTRIBUTE_CONFIGURATION, configuration);\n\t\t\t\t\tmapping.setAttribute(ATTRIBUTE_LANGUAGE, language);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n",
    "code_after_change": "/*******************************************************************************\n * Copyright (c) 2007, 2015 IBM Corporation and others.\n *\n * This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n *\n * Contributors:\n * \t   IBM Corporation - Initial API and implementation\n *     James Blackburn (Broadcom Corp.)\n *     Sergey Prigogin (Google)\n *******************************************************************************/\npackage org.eclipse.cdt.internal.core.language;\n\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.io.StringWriter;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.TreeMap;\n\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactoryConfigurationError;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.eclipse.cdt.core.CCorePlugin;\nimport org.eclipse.cdt.core.CCorePreferenceConstants;\nimport org.eclipse.cdt.core.language.ProjectLanguageConfiguration;\nimport org.eclipse.cdt.core.language.WorkspaceLanguageConfiguration;\nimport org.eclipse.cdt.core.settings.model.ICConfigurationDescription;\nimport org.eclipse.cdt.core.settings.model.ICProjectDescription;\nimport org.eclipse.cdt.core.settings.model.ICStorageElement;\nimport org.eclipse.cdt.internal.core.Util;\nimport org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.preferences.DefaultScope;\nimport org.eclipse.core.runtime.preferences.IEclipsePreferences;\nimport org.eclipse.core.runtime.preferences.InstanceScope;\nimport org.osgi.service.prefs.BackingStoreException;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\n\n/**\n * Serializes and deserializes language mappings to and from persistent storage.\n */\npublic class LanguageMappingStore {\n\tprivate static final String LANGUAGE_MAPPING_ID = \"org.eclipse.cdt.core.language.mapping\"; //$NON-NLS-1$\n\tprivate static final String PROJECT_MAPPINGS = \"project-mappings\"; //$NON-NLS-1$\n\tprivate static final String WORKSPACE_MAPPINGS = \"workspace-mappings\"; //$NON-NLS-1$\n\tprivate static final String CONTENT_TYPE_MAPPING = \"content-type-mapping\"; //$NON-NLS-1$\n\tprivate static final String FILE_MAPPING = \"file-mapping\"; //$NON-NLS-1$\n\tprivate static final String ATTRIBUTE_PATH = \"path\"; //$NON-NLS-1$\n\tprivate static final String ATTRIBUTE_CONTENT_TYPE = \"content-type\"; //$NON-NLS-1$\n\tprivate static final String ATTRIBUTE_LANGUAGE = \"language\"; //$NON-NLS-1$\n\tprivate static final String ATTRIBUTE_CONFIGURATION = \"configuration\"; //$NON-NLS-1$\n\n\tpublic LanguageMappingStore() {\n\t}\n\n\tpublic ProjectLanguageConfiguration decodeMappings(IProject project) throws CoreException {\n\t\tProjectLanguageConfiguration config = new ProjectLanguageConfiguration();\n\t\tICProjectDescription descriptor = getProjectDescription(project, false);\n\t\tif (descriptor != null) {\n\t\t\tICStorageElement rootElement = descriptor.getStorage(LANGUAGE_MAPPING_ID, false);\n\t\t\tif (rootElement == null) {\n\t\t\t\t// bug 367061 - backwards compatibility: fallback to default configuration settings\n\t\t\t\tICConfigurationDescription cfgDesc = descriptor.getDefaultSettingConfiguration();\n\t\t\t\tif (cfgDesc != null) {\n\t\t\t\t\trootElement = cfgDesc.getStorage(LANGUAGE_MAPPING_ID, false);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rootElement != null) {\n\t\t\t\tICStorageElement[] mappingElements = rootElement.getChildrenByName(PROJECT_MAPPINGS);\n\t\t\t\tif (mappingElements.length > 0) {\n\t\t\t\t\tICStorageElement element = mappingElements[0];\n\t\t\t\t\tconfig.setContentTypeMappings(decodeProjectContentTypeMappings(element));\n\t\t\t\t\tconfig.setFileMappings(decodeFileMappings(element));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn config;\n\t}\n\n\tprivate Map<String, Map<String, String>> decodeProjectContentTypeMappings(ICStorageElement rootElement) {\n\t\tMap<String, Map<String, String>> decodedMappings = new TreeMap<>();\n\t\tICStorageElement[] mappingElements = rootElement.getChildrenByName(CONTENT_TYPE_MAPPING);\n\t\tfor (int j = 0; j < mappingElements.length; j++) {\n\t\t\tICStorageElement mapping = mappingElements[j];\n\t\t\tString configuration = mapping.getAttribute(ATTRIBUTE_CONFIGURATION);\n\n\t\t\tMap<String, String> contentTypeMappings = decodedMappings.get(configuration);\n\t\t\tif (contentTypeMappings == null) {\n\t\t\t\tcontentTypeMappings = new TreeMap<>();\n\t\t\t\tdecodedMappings.put(configuration, contentTypeMappings);\n\t\t\t}\n\t\t\tString contentType = mapping.getAttribute(ATTRIBUTE_CONTENT_TYPE);\n\t\t\tString language = mapping.getAttribute(ATTRIBUTE_LANGUAGE);\n\t\t\tcontentTypeMappings.put(contentType, language);\n\t\t}\n\t\treturn decodedMappings;\n\t}\n\n\tprotected ICProjectDescription getProjectDescription(IProject project, boolean write) throws CoreException {\n\t\treturn CCorePlugin.getDefault().getProjectDescription(project, write);\n\t}\n\n\tprivate Map<String, String> decodeContentTypeMappings(Element rootElement) throws CoreException {\n\t\treturn decodeMappings(rootElement, CONTENT_TYPE_MAPPING, ATTRIBUTE_CONTENT_TYPE, ATTRIBUTE_LANGUAGE);\n\t}\n\n\tprivate Map<String, Map<String, String>> decodeFileMappings(ICStorageElement rootElement) throws CoreException {\n\t\tMap<String, Map<String, String>> decodedMappings = new TreeMap<>();\n\t\tICStorageElement[] mappingElements = rootElement.getChildrenByName(FILE_MAPPING);\n\t\tfor (int j = 0; j < mappingElements.length; j++) {\n\t\t\tICStorageElement mapping = mappingElements[j];\n\t\t\tString path = mapping.getAttribute(ATTRIBUTE_PATH);\n\n\t\t\tMap<String, String> configurationMappings = decodedMappings.get(path);\n\t\t\tif (configurationMappings == null) {\n\t\t\t\tconfigurationMappings = new TreeMap<>();\n\t\t\t\tdecodedMappings.put(path, configurationMappings);\n\t\t\t}\n\t\t\tString configuration = mapping.getAttribute(ATTRIBUTE_CONFIGURATION);\n\t\t\tString language = mapping.getAttribute(ATTRIBUTE_LANGUAGE);\n\t\t\tconfigurationMappings.put(configuration, language);\n\t\t}\n\t\treturn decodedMappings;\n\t}\n\n\tprivate Map<String, String> decodeMappings(Element rootElement, String category, String keyName, String valueName) {\n\t\tMap<String, String> decodedMappings = new TreeMap<>();\n\t\tNodeList mappingElements = rootElement.getElementsByTagName(category);\n\t\tfor (int j = 0; j < mappingElements.getLength(); j++) {\n\t\t\tElement mapping = (Element) mappingElements.item(j);\n\t\t\tString key = mapping.getAttribute(keyName);\n\t\t\tString value = mapping.getAttribute(valueName);\n\t\t\tdecodedMappings.put(key, value);\n\t\t}\n\t\treturn decodedMappings;\n\t}\n\n\tpublic void storeMappings(IProject project, ProjectLanguageConfiguration config) throws CoreException {\n\t\tICProjectDescription descriptor = getProjectDescription(project, true);\n\t\tICConfigurationDescription cfgDesc = descriptor.getDefaultSettingConfiguration();\n\t\t// remove old storage location if any\n\t\tif (cfgDesc != null && cfgDesc.getStorage(LANGUAGE_MAPPING_ID, false) != null) {\n\t\t\tcfgDesc.removeStorage(LANGUAGE_MAPPING_ID);\n\t\t}\n\t\tICStorageElement rootElement = descriptor.getStorage(LANGUAGE_MAPPING_ID, true);\n\t\t// clear all children and settings\n\t\trootElement.clear();\n\n\t\tICStorageElement projectMappings = rootElement.createChild(PROJECT_MAPPINGS);\n\n\t\taddProjectContentTypeMappings(config.getContentTypeMappings(), projectMappings);\n\t\taddFileMappings(config.getFileMappings(), projectMappings);\n\t\tCCorePlugin.getDefault().setProjectDescription(project, descriptor);\n\t}\n\n\tprivate void addProjectContentTypeMappings(Map<String, Map<String, String>> contentTypeMappings,\n\t\t\tICStorageElement rootElement) {\n\t\tIterator<Entry<String, Map<String, String>>> entries = contentTypeMappings.entrySet().iterator();\n\t\twhile (entries.hasNext()) {\n\t\t\tEntry<String, Map<String, String>> entry = entries.next();\n\n\t\t\tString configuration = entry.getKey();\n\t\t\tIterator<Entry<String, String>> contentTypeEntries = entry.getValue().entrySet().iterator();\n\t\t\twhile (contentTypeEntries.hasNext()) {\n\t\t\t\tEntry<String, String> configurationEntry = contentTypeEntries.next();\n\t\t\t\tString contentType = configurationEntry.getKey();\n\t\t\t\tString language = configurationEntry.getValue();\n\n\t\t\t\tICStorageElement mapping = rootElement.createChild(CONTENT_TYPE_MAPPING);\n\t\t\t\tmapping.setAttribute(ATTRIBUTE_CONTENT_TYPE, contentType);\n\t\t\t\tmapping.setAttribute(ATTRIBUTE_CONFIGURATION, configuration);\n\t\t\t\tmapping.setAttribute(ATTRIBUTE_LANGUAGE, language);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void storeMappings(WorkspaceLanguageConfiguration config) throws CoreException {\n\t\ttry {\n\t\t\t// Encode mappings as XML and serialize as a String.\n\t\t\tDocument doc = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE().newDocument();\n\t\t\tElement rootElement = doc.createElement(WORKSPACE_MAPPINGS);\n\t\t\tdoc.appendChild(rootElement);\n\t\t\taddContentTypeMappings(config.getWorkspaceMappings(), rootElement);\n\t\t\tTransformer serializer = createSerializer();\n\t\t\tDOMSource source = new DOMSource(doc);\n\t\t\tStringWriter buffer = new StringWriter();\n\t\t\tStreamResult result = new StreamResult(buffer);\n\t\t\tserializer.transform(source, result);\n\t\t\tString encodedMappings = buffer.getBuffer().toString();\n\n\t\t\tIEclipsePreferences node = InstanceScope.INSTANCE.getNode(CCorePlugin.PLUGIN_ID);\n\t\t\tnode.put(CCorePreferenceConstants.WORKSPACE_LANGUAGE_MAPPINGS, encodedMappings);\n\t\t\tnode.flush();\n\t\t} catch (ParserConfigurationException e) {\n\t\t\tthrow new CoreException(Util.createStatus(e));\n\t\t} catch (TransformerException e) {\n\t\t\tthrow new CoreException(Util.createStatus(e));\n\t\t} catch (BackingStoreException e) {\n\t\t\tthrow new CoreException(Util.createStatus(e));\n\t\t}\n\t}\n\n\tpublic WorkspaceLanguageConfiguration decodeWorkspaceMappings() throws CoreException {\n\t\tIEclipsePreferences node = InstanceScope.INSTANCE.getNode(CCorePlugin.PLUGIN_ID);\n\t\tIEclipsePreferences defaultNode = DefaultScope.INSTANCE.getNode(CCorePlugin.PLUGIN_ID);\n\t\tString encodedMappings = node.get(CCorePreferenceConstants.WORKSPACE_LANGUAGE_MAPPINGS, null);\n\t\tif (encodedMappings == null) {\n\t\t\tencodedMappings = defaultNode.get(CCorePreferenceConstants.WORKSPACE_LANGUAGE_MAPPINGS, null);\n\t\t}\n\t\tWorkspaceLanguageConfiguration config = new WorkspaceLanguageConfiguration();\n\n\t\tif (encodedMappings == null || encodedMappings.length() == 0) {\n\t\t\treturn config;\n\t\t}\n\n\t\t// The mappings are encoded as XML in a String so we need to parse it.\n\t\tInputSource input = new InputSource(new StringReader(encodedMappings));\n\t\ttry {\n\t\t\tDocument document = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE().parse(input);\n\t\t\tconfig.setWorkspaceMappings(decodeContentTypeMappings(document.getDocumentElement()));\n\t\t\treturn config;\n\t\t} catch (SAXException e) {\n\t\t\tthrow new CoreException(Util.createStatus(e));\n\t\t} catch (IOException e) {\n\t\t\tthrow new CoreException(Util.createStatus(e));\n\t\t} catch (ParserConfigurationException e) {\n\t\t\tthrow new CoreException(Util.createStatus(e));\n\t\t}\n\t}\n\n\tprivate Transformer createSerializer() throws CoreException {\n\t\ttry {\n\t\t\treturn XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE().newTransformer();\n\t\t} catch (TransformerConfigurationException e) {\n\t\t\tthrow new CoreException(Util.createStatus(e));\n\t\t} catch (TransformerFactoryConfigurationError e) {\n\t\t\tthrow new CoreException(Util.createStatus(e));\n\t\t}\n\t}\n\n\tprivate void addMappings(Map<String, String> mappings, Element rootElement, String category, String keyName,\n\t\t\tString valueName) {\n\t\tDocument document = rootElement.getOwnerDocument();\n\t\tIterator<Entry<String, String>> entries = mappings.entrySet().iterator();\n\t\twhile (entries.hasNext()) {\n\t\t\tEntry<String, String> entry = entries.next();\n\t\t\tElement mapping = document.createElement(category);\n\t\t\tmapping.setAttribute(keyName, entry.getKey());\n\t\t\tmapping.setAttribute(valueName, entry.getValue());\n\t\t\trootElement.appendChild(mapping);\n\t\t}\n\t}\n\n\tprivate void addContentTypeMappings(Map<String, String> mappings, Element rootElement) {\n\t\taddMappings(mappings, rootElement, CONTENT_TYPE_MAPPING, ATTRIBUTE_CONTENT_TYPE, ATTRIBUTE_LANGUAGE);\n\t}\n\n\tprivate void addFileMappings(Map<String, Map<String, String>> mappings, ICStorageElement rootElement) {\n\t\tfor (Map.Entry<String, Map<String, String>> entry : mappings.entrySet()) {\n\t\t\tif (!entry.getValue().isEmpty()) {\n\t\t\t\tICStorageElement mapping = rootElement.createChild(FILE_MAPPING);\n\t\t\t\tString path = entry.getKey();\n\t\t\t\tfor (Entry<String, String> configurationEntry : entry.getValue().entrySet()) {\n\t\t\t\t\tString configuration = configurationEntry.getKey();\n\t\t\t\t\tString language = configurationEntry.getValue();\n\n\t\t\t\t\tmapping.setAttribute(ATTRIBUTE_PATH, path);\n\t\t\t\t\tmapping.setAttribute(ATTRIBUTE_CONFIGURATION, configuration);\n\t\t\t\t\tmapping.setAttribute(ATTRIBUTE_LANGUAGE, language);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n",
    "patch": "@@ -23,12 +23,10 @@\n import java.util.Map.Entry;\n import java.util.TreeMap;\n \n-import javax.xml.parsers.DocumentBuilderFactory;\n import javax.xml.parsers.ParserConfigurationException;\n import javax.xml.transform.Transformer;\n import javax.xml.transform.TransformerConfigurationException;\n import javax.xml.transform.TransformerException;\n-import javax.xml.transform.TransformerFactory;\n import javax.xml.transform.TransformerFactoryConfigurationError;\n import javax.xml.transform.dom.DOMSource;\n import javax.xml.transform.stream.StreamResult;\n@@ -41,6 +39,7 @@\n import org.eclipse.cdt.core.settings.model.ICProjectDescription;\n import org.eclipse.cdt.core.settings.model.ICStorageElement;\n import org.eclipse.cdt.internal.core.Util;\n+import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n import org.eclipse.core.resources.IProject;\n import org.eclipse.core.runtime.CoreException;\n import org.eclipse.core.runtime.preferences.DefaultScope;\n@@ -194,7 +193,7 @@ private void addProjectContentTypeMappings(Map<String, Map<String, String>> cont\n \tpublic void storeMappings(WorkspaceLanguageConfiguration config) throws CoreException {\n \t\ttry {\n \t\t\t// Encode mappings as XML and serialize as a String.\n-\t\t\tDocument doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n+\t\t\tDocument doc = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE().newDocument();\n \t\t\tElement rootElement = doc.createElement(WORKSPACE_MAPPINGS);\n \t\t\tdoc.appendChild(rootElement);\n \t\t\taddContentTypeMappings(config.getWorkspaceMappings(), rootElement);\n@@ -233,7 +232,7 @@ public WorkspaceLanguageConfiguration decodeWorkspaceMappings() throws CoreExcep\n \t\t// The mappings are encoded as XML in a String so we need to parse it.\n \t\tInputSource input = new InputSource(new StringReader(encodedMappings));\n \t\ttry {\n-\t\t\tDocument document = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(input);\n+\t\t\tDocument document = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE().parse(input);\n \t\t\tconfig.setWorkspaceMappings(decodeContentTypeMappings(document.getDocumentElement()));\n \t\t\treturn config;\n \t\t} catch (SAXException e) {\n@@ -247,7 +246,7 @@ public WorkspaceLanguageConfiguration decodeWorkspaceMappings() throws CoreExcep\n \n \tprivate Transformer createSerializer() throws CoreException {\n \t\ttry {\n-\t\t\treturn TransformerFactory.newInstance().newTransformer();\n+\t\t\treturn XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE().newTransformer();\n \t\t} catch (TransformerConfigurationException e) {\n \t\t\tthrow new CoreException(Util.createStatus(e));\n \t\t} catch (TransformerFactoryConfigurationError e) {",
    "function_modified_lines": {
      "added": [
        "import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n"
      ],
      "deleted": [
        "import javax.xml.parsers.DocumentBuilderFactory;\n",
        "import javax.xml.transform.TransformerFactory;\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "In Eclipse IDE versions < 2023-09 (4.29) some files with xml content are parsed vulnerable against all sorts of XXE attacks. The user just needs to open any evil project or update an open project with a vulnerable file (for example for review a foreign repository or patch).\n",
    "id": 12859
  },
  {
    "cve_id": "CVE-2023-4218",
    "code_before_change": "{\n\tprivate static final String LANGUAGE_MAPPING_ID = \"org.eclipse.cdt.core.language.mapping\"; //$NON-NLS-1$\n\tprivate static final String PROJECT_MAPPINGS = \"project-mappings\"; //$NON-NLS-1$\n\tprivate static final String WORKSPACE_MAPPINGS = \"workspace-mappings\"; //$NON-NLS-1$\n\tprivate static final String CONTENT_TYPE_MAPPING = \"content-type-mapping\"; //$NON-NLS-1$\n\tprivate static final String FILE_MAPPING = \"file-mapping\"; //$NON-NLS-1$\n\tprivate static final String ATTRIBUTE_PATH = \"path\"; //$NON-NLS-1$\n\tprivate static final String ATTRIBUTE_CONTENT_TYPE = \"content-type\"; //$NON-NLS-1$\n\tprivate static final String ATTRIBUTE_LANGUAGE = \"language\"; //$NON-NLS-1$\n\tprivate static final String ATTRIBUTE_CONFIGURATION = \"configuration\"; //$NON-NLS-1$\n\n\tpublic LanguageMappingStore() {\n\t}\n\n\tpublic ProjectLanguageConfiguration decodeMappings(IProject project) throws CoreException {\n\t\tProjectLanguageConfiguration config = new ProjectLanguageConfiguration();\n\t\tICProjectDescription descriptor = getProjectDescription(project, false);\n\t\tif (descriptor != null) {\n\t\t\tICStorageElement rootElement = descriptor.getStorage(LANGUAGE_MAPPING_ID, false);\n\t\t\tif (rootElement == null) {\n\t\t\t\t// bug 367061 - backwards compatibility: fallback to default configuration settings\n\t\t\t\tICConfigurationDescription cfgDesc = descriptor.getDefaultSettingConfiguration();\n\t\t\t\tif (cfgDesc != null) {\n\t\t\t\t\trootElement = cfgDesc.getStorage(LANGUAGE_MAPPING_ID, false);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rootElement != null) {\n\t\t\t\tICStorageElement[] mappingElements = rootElement.getChildrenByName(PROJECT_MAPPINGS);\n\t\t\t\tif (mappingElements.length > 0) {\n\t\t\t\t\tICStorageElement element = mappingElements[0];\n\t\t\t\t\tconfig.setContentTypeMappings(decodeProjectContentTypeMappings(element));\n\t\t\t\t\tconfig.setFileMappings(decodeFileMappings(element));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn config;\n\t}\n\n\tprivate Map<String, Map<String, String>> decodeProjectContentTypeMappings(ICStorageElement rootElement) {\n\t\tMap<String, Map<String, String>> decodedMappings = new TreeMap<>();\n\t\tICStorageElement[] mappingElements = rootElement.getChildrenByName(CONTENT_TYPE_MAPPING);\n\t\tfor (int j = 0; j < mappingElements.length; j++) {\n\t\t\tICStorageElement mapping = mappingElements[j];\n\t\t\tString configuration = mapping.getAttribute(ATTRIBUTE_CONFIGURATION);\n\n\t\t\tMap<String, String> contentTypeMappings = decodedMappings.get(configuration);\n\t\t\tif (contentTypeMappings == null) {\n\t\t\t\tcontentTypeMappings = new TreeMap<>();\n\t\t\t\tdecodedMappings.put(configuration, contentTypeMappings);\n\t\t\t}\n\t\t\tString contentType = mapping.getAttribute(ATTRIBUTE_CONTENT_TYPE);\n\t\t\tString language = mapping.getAttribute(ATTRIBUTE_LANGUAGE);\n\t\t\tcontentTypeMappings.put(contentType, language);\n\t\t}\n\t\treturn decodedMappings;\n\t}\n\n\tprotected ICProjectDescription getProjectDescription(IProject project, boolean write) throws CoreException {\n\t\treturn CCorePlugin.getDefault().getProjectDescription(project, write);\n\t}\n\n\tprivate Map<String, String> decodeContentTypeMappings(Element rootElement) throws CoreException {\n\t\treturn decodeMappings(rootElement, CONTENT_TYPE_MAPPING, ATTRIBUTE_CONTENT_TYPE, ATTRIBUTE_LANGUAGE);\n\t}\n\n\tprivate Map<String, Map<String, String>> decodeFileMappings(ICStorageElement rootElement) throws CoreException {\n\t\tMap<String, Map<String, String>> decodedMappings = new TreeMap<>();\n\t\tICStorageElement[] mappingElements = rootElement.getChildrenByName(FILE_MAPPING);\n\t\tfor (int j = 0; j < mappingElements.length; j++) {\n\t\t\tICStorageElement mapping = mappingElements[j];\n\t\t\tString path = mapping.getAttribute(ATTRIBUTE_PATH);\n\n\t\t\tMap<String, String> configurationMappings = decodedMappings.get(path);\n\t\t\tif (configurationMappings == null) {\n\t\t\t\tconfigurationMappings = new TreeMap<>();\n\t\t\t\tdecodedMappings.put(path, configurationMappings);\n\t\t\t}\n\t\t\tString configuration = mapping.getAttribute(ATTRIBUTE_CONFIGURATION);\n\t\t\tString language = mapping.getAttribute(ATTRIBUTE_LANGUAGE);\n\t\t\tconfigurationMappings.put(configuration, language);\n\t\t}\n\t\treturn decodedMappings;\n\t}\n\n\tprivate Map<String, String> decodeMappings(Element rootElement, String category, String keyName, String valueName) {\n\t\tMap<String, String> decodedMappings = new TreeMap<>();\n\t\tNodeList mappingElements = rootElement.getElementsByTagName(category);\n\t\tfor (int j = 0; j < mappingElements.getLength(); j++) {\n\t\t\tElement mapping = (Element) mappingElements.item(j);\n\t\t\tString key = mapping.getAttribute(keyName);\n\t\t\tString value = mapping.getAttribute(valueName);\n\t\t\tdecodedMappings.put(key, value);\n\t\t}\n\t\treturn decodedMappings;\n\t}\n\n\tpublic void storeMappings(IProject project, ProjectLanguageConfiguration config) throws CoreException {\n\t\tICProjectDescription descriptor = getProjectDescription(project, true);\n\t\tICConfigurationDescription cfgDesc = descriptor.getDefaultSettingConfiguration();\n\t\t// remove old storage location if any\n\t\tif (cfgDesc != null && cfgDesc.getStorage(LANGUAGE_MAPPING_ID, false) != null) {\n\t\t\tcfgDesc.removeStorage(LANGUAGE_MAPPING_ID);\n\t\t}\n\t\tICStorageElement rootElement = descriptor.getStorage(LANGUAGE_MAPPING_ID, true);\n\t\t// clear all children and settings\n\t\trootElement.clear();\n\n\t\tICStorageElement projectMappings = rootElement.createChild(PROJECT_MAPPINGS);\n\n\t\taddProjectContentTypeMappings(config.getContentTypeMappings(), projectMappings);\n\t\taddFileMappings(config.getFileMappings(), projectMappings);\n\t\tCCorePlugin.getDefault().setProjectDescription(project, descriptor);\n\t}\n\n\tprivate void addProjectContentTypeMappings(Map<String, Map<String, String>> contentTypeMappings,\n\t\t\tICStorageElement rootElement) {\n\t\tIterator<Entry<String, Map<String, String>>> entries = contentTypeMappings.entrySet().iterator();\n\t\twhile (entries.hasNext()) {\n\t\t\tEntry<String, Map<String, String>> entry = entries.next();\n\n\t\t\tString configuration = entry.getKey();\n\t\t\tIterator<Entry<String, String>> contentTypeEntries = entry.getValue().entrySet().iterator();\n\t\t\twhile (contentTypeEntries.hasNext()) {\n\t\t\t\tEntry<String, String> configurationEntry = contentTypeEntries.next();\n\t\t\t\tString contentType = configurationEntry.getKey();\n\t\t\t\tString language = configurationEntry.getValue();\n\n\t\t\t\tICStorageElement mapping = rootElement.createChild(CONTENT_TYPE_MAPPING);\n\t\t\t\tmapping.setAttribute(ATTRIBUTE_CONTENT_TYPE, contentType);\n\t\t\t\tmapping.setAttribute(ATTRIBUTE_CONFIGURATION, configuration);\n\t\t\t\tmapping.setAttribute(ATTRIBUTE_LANGUAGE, language);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void storeMappings(WorkspaceLanguageConfiguration config) throws CoreException {\n\t\ttry {\n\t\t\t// Encode mappings as XML and serialize as a String.\n\t\t\tDocument doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n\t\t\tElement rootElement = doc.createElement(WORKSPACE_MAPPINGS);\n\t\t\tdoc.appendChild(rootElement);\n\t\t\taddContentTypeMappings(config.getWorkspaceMappings(), rootElement);\n\t\t\tTransformer serializer = createSerializer();\n\t\t\tDOMSource source = new DOMSource(doc);\n\t\t\tStringWriter buffer = new StringWriter();\n\t\t\tStreamResult result = new StreamResult(buffer);\n\t\t\tserializer.transform(source, result);\n\t\t\tString encodedMappings = buffer.getBuffer().toString();\n\n\t\t\tIEclipsePreferences node = InstanceScope.INSTANCE.getNode(CCorePlugin.PLUGIN_ID);\n\t\t\tnode.put(CCorePreferenceConstants.WORKSPACE_LANGUAGE_MAPPINGS, encodedMappings);\n\t\t\tnode.flush();\n\t\t} catch (ParserConfigurationException e) {\n\t\t\tthrow new CoreException(Util.createStatus(e));\n\t\t} catch (TransformerException e) {\n\t\t\tthrow new CoreException(Util.createStatus(e));\n\t\t} catch (BackingStoreException e) {\n\t\t\tthrow new CoreException(Util.createStatus(e));\n\t\t}\n\t}\n\n\tpublic WorkspaceLanguageConfiguration decodeWorkspaceMappings() throws CoreException {\n\t\tIEclipsePreferences node = InstanceScope.INSTANCE.getNode(CCorePlugin.PLUGIN_ID);\n\t\tIEclipsePreferences defaultNode = DefaultScope.INSTANCE.getNode(CCorePlugin.PLUGIN_ID);\n\t\tString encodedMappings = node.get(CCorePreferenceConstants.WORKSPACE_LANGUAGE_MAPPINGS, null);\n\t\tif (encodedMappings == null) {\n\t\t\tencodedMappings = defaultNode.get(CCorePreferenceConstants.WORKSPACE_LANGUAGE_MAPPINGS, null);\n\t\t}\n\t\tWorkspaceLanguageConfiguration config = new WorkspaceLanguageConfiguration();\n\n\t\tif (encodedMappings == null || encodedMappings.length() == 0) {\n\t\t\treturn config;\n\t\t}\n\n\t\t// The mappings are encoded as XML in a String so we need to parse it.\n\t\tInputSource input = new InputSource(new StringReader(encodedMappings));\n\t\ttry {\n\t\t\tDocument document = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(input);\n\t\t\tconfig.setWorkspaceMappings(decodeContentTypeMappings(document.getDocumentElement()));\n\t\t\treturn config;\n\t\t} catch (SAXException e) {\n\t\t\tthrow new CoreException(Util.createStatus(e));\n\t\t} catch (IOException e) {\n\t\t\tthrow new CoreException(Util.createStatus(e));\n\t\t} catch (ParserConfigurationException e) {\n\t\t\tthrow new CoreException(Util.createStatus(e));\n\t\t}\n\t}\n\n\tprivate Transformer createSerializer() throws CoreException {\n\t\ttry {\n\t\t\treturn TransformerFactory.newInstance().newTransformer();\n\t\t} catch (TransformerConfigurationException e) {\n\t\t\tthrow new CoreException(Util.createStatus(e));\n\t\t} catch (TransformerFactoryConfigurationError e) {\n\t\t\tthrow new CoreException(Util.createStatus(e));\n\t\t}\n\t}\n\n\tprivate void addMappings(Map<String, String> mappings, Element rootElement, String category, String keyName,\n\t\t\tString valueName) {\n\t\tDocument document = rootElement.getOwnerDocument();\n\t\tIterator<Entry<String, String>> entries = mappings.entrySet().iterator();\n\t\twhile (entries.hasNext()) {\n\t\t\tEntry<String, String> entry = entries.next();\n\t\t\tElement mapping = document.createElement(category);\n\t\t\tmapping.setAttribute(keyName, entry.getKey());\n\t\t\tmapping.setAttribute(valueName, entry.getValue());\n\t\t\trootElement.appendChild(mapping);\n\t\t}\n\t}\n\n\tprivate void addContentTypeMappings(Map<String, String> mappings, Element rootElement) {\n\t\taddMappings(mappings, rootElement, CONTENT_TYPE_MAPPING, ATTRIBUTE_CONTENT_TYPE, ATTRIBUTE_LANGUAGE);\n\t}\n\n\tprivate void addFileMappings(Map<String, Map<String, String>> mappings, ICStorageElement rootElement) {\n\t\tfor (Map.Entry<String, Map<String, String>> entry : mappings.entrySet()) {\n\t\t\tif (!entry.getValue().isEmpty()) {\n\t\t\t\tICStorageElement mapping = rootElement.createChild(FILE_MAPPING);\n\t\t\t\tString path = entry.getKey();\n\t\t\t\tfor (Entry<String, String> configurationEntry : entry.getValue().entrySet()) {\n\t\t\t\t\tString configuration = configurationEntry.getKey();\n\t\t\t\t\tString language = configurationEntry.getValue();\n\n\t\t\t\t\tmapping.setAttribute(ATTRIBUTE_PATH, path);\n\t\t\t\t\tmapping.setAttribute(ATTRIBUTE_CONFIGURATION, configuration);\n\t\t\t\t\tmapping.setAttribute(ATTRIBUTE_LANGUAGE, language);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
    "code_after_change": "{\n\tprivate static final String LANGUAGE_MAPPING_ID = \"org.eclipse.cdt.core.language.mapping\"; //$NON-NLS-1$\n\tprivate static final String PROJECT_MAPPINGS = \"project-mappings\"; //$NON-NLS-1$\n\tprivate static final String WORKSPACE_MAPPINGS = \"workspace-mappings\"; //$NON-NLS-1$\n\tprivate static final String CONTENT_TYPE_MAPPING = \"content-type-mapping\"; //$NON-NLS-1$\n\tprivate static final String FILE_MAPPING = \"file-mapping\"; //$NON-NLS-1$\n\tprivate static final String ATTRIBUTE_PATH = \"path\"; //$NON-NLS-1$\n\tprivate static final String ATTRIBUTE_CONTENT_TYPE = \"content-type\"; //$NON-NLS-1$\n\tprivate static final String ATTRIBUTE_LANGUAGE = \"language\"; //$NON-NLS-1$\n\tprivate static final String ATTRIBUTE_CONFIGURATION = \"configuration\"; //$NON-NLS-1$\n\n\tpublic LanguageMappingStore() {\n\t}\n\n\tpublic ProjectLanguageConfiguration decodeMappings(IProject project) throws CoreException {\n\t\tProjectLanguageConfiguration config = new ProjectLanguageConfiguration();\n\t\tICProjectDescription descriptor = getProjectDescription(project, false);\n\t\tif (descriptor != null) {\n\t\t\tICStorageElement rootElement = descriptor.getStorage(LANGUAGE_MAPPING_ID, false);\n\t\t\tif (rootElement == null) {\n\t\t\t\t// bug 367061 - backwards compatibility: fallback to default configuration settings\n\t\t\t\tICConfigurationDescription cfgDesc = descriptor.getDefaultSettingConfiguration();\n\t\t\t\tif (cfgDesc != null) {\n\t\t\t\t\trootElement = cfgDesc.getStorage(LANGUAGE_MAPPING_ID, false);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rootElement != null) {\n\t\t\t\tICStorageElement[] mappingElements = rootElement.getChildrenByName(PROJECT_MAPPINGS);\n\t\t\t\tif (mappingElements.length > 0) {\n\t\t\t\t\tICStorageElement element = mappingElements[0];\n\t\t\t\t\tconfig.setContentTypeMappings(decodeProjectContentTypeMappings(element));\n\t\t\t\t\tconfig.setFileMappings(decodeFileMappings(element));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn config;\n\t}\n\n\tprivate Map<String, Map<String, String>> decodeProjectContentTypeMappings(ICStorageElement rootElement) {\n\t\tMap<String, Map<String, String>> decodedMappings = new TreeMap<>();\n\t\tICStorageElement[] mappingElements = rootElement.getChildrenByName(CONTENT_TYPE_MAPPING);\n\t\tfor (int j = 0; j < mappingElements.length; j++) {\n\t\t\tICStorageElement mapping = mappingElements[j];\n\t\t\tString configuration = mapping.getAttribute(ATTRIBUTE_CONFIGURATION);\n\n\t\t\tMap<String, String> contentTypeMappings = decodedMappings.get(configuration);\n\t\t\tif (contentTypeMappings == null) {\n\t\t\t\tcontentTypeMappings = new TreeMap<>();\n\t\t\t\tdecodedMappings.put(configuration, contentTypeMappings);\n\t\t\t}\n\t\t\tString contentType = mapping.getAttribute(ATTRIBUTE_CONTENT_TYPE);\n\t\t\tString language = mapping.getAttribute(ATTRIBUTE_LANGUAGE);\n\t\t\tcontentTypeMappings.put(contentType, language);\n\t\t}\n\t\treturn decodedMappings;\n\t}\n\n\tprotected ICProjectDescription getProjectDescription(IProject project, boolean write) throws CoreException {\n\t\treturn CCorePlugin.getDefault().getProjectDescription(project, write);\n\t}\n\n\tprivate Map<String, String> decodeContentTypeMappings(Element rootElement) throws CoreException {\n\t\treturn decodeMappings(rootElement, CONTENT_TYPE_MAPPING, ATTRIBUTE_CONTENT_TYPE, ATTRIBUTE_LANGUAGE);\n\t}\n\n\tprivate Map<String, Map<String, String>> decodeFileMappings(ICStorageElement rootElement) throws CoreException {\n\t\tMap<String, Map<String, String>> decodedMappings = new TreeMap<>();\n\t\tICStorageElement[] mappingElements = rootElement.getChildrenByName(FILE_MAPPING);\n\t\tfor (int j = 0; j < mappingElements.length; j++) {\n\t\t\tICStorageElement mapping = mappingElements[j];\n\t\t\tString path = mapping.getAttribute(ATTRIBUTE_PATH);\n\n\t\t\tMap<String, String> configurationMappings = decodedMappings.get(path);\n\t\t\tif (configurationMappings == null) {\n\t\t\t\tconfigurationMappings = new TreeMap<>();\n\t\t\t\tdecodedMappings.put(path, configurationMappings);\n\t\t\t}\n\t\t\tString configuration = mapping.getAttribute(ATTRIBUTE_CONFIGURATION);\n\t\t\tString language = mapping.getAttribute(ATTRIBUTE_LANGUAGE);\n\t\t\tconfigurationMappings.put(configuration, language);\n\t\t}\n\t\treturn decodedMappings;\n\t}\n\n\tprivate Map<String, String> decodeMappings(Element rootElement, String category, String keyName, String valueName) {\n\t\tMap<String, String> decodedMappings = new TreeMap<>();\n\t\tNodeList mappingElements = rootElement.getElementsByTagName(category);\n\t\tfor (int j = 0; j < mappingElements.getLength(); j++) {\n\t\t\tElement mapping = (Element) mappingElements.item(j);\n\t\t\tString key = mapping.getAttribute(keyName);\n\t\t\tString value = mapping.getAttribute(valueName);\n\t\t\tdecodedMappings.put(key, value);\n\t\t}\n\t\treturn decodedMappings;\n\t}\n\n\tpublic void storeMappings(IProject project, ProjectLanguageConfiguration config) throws CoreException {\n\t\tICProjectDescription descriptor = getProjectDescription(project, true);\n\t\tICConfigurationDescription cfgDesc = descriptor.getDefaultSettingConfiguration();\n\t\t// remove old storage location if any\n\t\tif (cfgDesc != null && cfgDesc.getStorage(LANGUAGE_MAPPING_ID, false) != null) {\n\t\t\tcfgDesc.removeStorage(LANGUAGE_MAPPING_ID);\n\t\t}\n\t\tICStorageElement rootElement = descriptor.getStorage(LANGUAGE_MAPPING_ID, true);\n\t\t// clear all children and settings\n\t\trootElement.clear();\n\n\t\tICStorageElement projectMappings = rootElement.createChild(PROJECT_MAPPINGS);\n\n\t\taddProjectContentTypeMappings(config.getContentTypeMappings(), projectMappings);\n\t\taddFileMappings(config.getFileMappings(), projectMappings);\n\t\tCCorePlugin.getDefault().setProjectDescription(project, descriptor);\n\t}\n\n\tprivate void addProjectContentTypeMappings(Map<String, Map<String, String>> contentTypeMappings,\n\t\t\tICStorageElement rootElement) {\n\t\tIterator<Entry<String, Map<String, String>>> entries = contentTypeMappings.entrySet().iterator();\n\t\twhile (entries.hasNext()) {\n\t\t\tEntry<String, Map<String, String>> entry = entries.next();\n\n\t\t\tString configuration = entry.getKey();\n\t\t\tIterator<Entry<String, String>> contentTypeEntries = entry.getValue().entrySet().iterator();\n\t\t\twhile (contentTypeEntries.hasNext()) {\n\t\t\t\tEntry<String, String> configurationEntry = contentTypeEntries.next();\n\t\t\t\tString contentType = configurationEntry.getKey();\n\t\t\t\tString language = configurationEntry.getValue();\n\n\t\t\t\tICStorageElement mapping = rootElement.createChild(CONTENT_TYPE_MAPPING);\n\t\t\t\tmapping.setAttribute(ATTRIBUTE_CONTENT_TYPE, contentType);\n\t\t\t\tmapping.setAttribute(ATTRIBUTE_CONFIGURATION, configuration);\n\t\t\t\tmapping.setAttribute(ATTRIBUTE_LANGUAGE, language);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void storeMappings(WorkspaceLanguageConfiguration config) throws CoreException {\n\t\ttry {\n\t\t\t// Encode mappings as XML and serialize as a String.\n\t\t\tDocument doc = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE().newDocument();\n\t\t\tElement rootElement = doc.createElement(WORKSPACE_MAPPINGS);\n\t\t\tdoc.appendChild(rootElement);\n\t\t\taddContentTypeMappings(config.getWorkspaceMappings(), rootElement);\n\t\t\tTransformer serializer = createSerializer();\n\t\t\tDOMSource source = new DOMSource(doc);\n\t\t\tStringWriter buffer = new StringWriter();\n\t\t\tStreamResult result = new StreamResult(buffer);\n\t\t\tserializer.transform(source, result);\n\t\t\tString encodedMappings = buffer.getBuffer().toString();\n\n\t\t\tIEclipsePreferences node = InstanceScope.INSTANCE.getNode(CCorePlugin.PLUGIN_ID);\n\t\t\tnode.put(CCorePreferenceConstants.WORKSPACE_LANGUAGE_MAPPINGS, encodedMappings);\n\t\t\tnode.flush();\n\t\t} catch (ParserConfigurationException e) {\n\t\t\tthrow new CoreException(Util.createStatus(e));\n\t\t} catch (TransformerException e) {\n\t\t\tthrow new CoreException(Util.createStatus(e));\n\t\t} catch (BackingStoreException e) {\n\t\t\tthrow new CoreException(Util.createStatus(e));\n\t\t}\n\t}\n\n\tpublic WorkspaceLanguageConfiguration decodeWorkspaceMappings() throws CoreException {\n\t\tIEclipsePreferences node = InstanceScope.INSTANCE.getNode(CCorePlugin.PLUGIN_ID);\n\t\tIEclipsePreferences defaultNode = DefaultScope.INSTANCE.getNode(CCorePlugin.PLUGIN_ID);\n\t\tString encodedMappings = node.get(CCorePreferenceConstants.WORKSPACE_LANGUAGE_MAPPINGS, null);\n\t\tif (encodedMappings == null) {\n\t\t\tencodedMappings = defaultNode.get(CCorePreferenceConstants.WORKSPACE_LANGUAGE_MAPPINGS, null);\n\t\t}\n\t\tWorkspaceLanguageConfiguration config = new WorkspaceLanguageConfiguration();\n\n\t\tif (encodedMappings == null || encodedMappings.length() == 0) {\n\t\t\treturn config;\n\t\t}\n\n\t\t// The mappings are encoded as XML in a String so we need to parse it.\n\t\tInputSource input = new InputSource(new StringReader(encodedMappings));\n\t\ttry {\n\t\t\tDocument document = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE().parse(input);\n\t\t\tconfig.setWorkspaceMappings(decodeContentTypeMappings(document.getDocumentElement()));\n\t\t\treturn config;\n\t\t} catch (SAXException e) {\n\t\t\tthrow new CoreException(Util.createStatus(e));\n\t\t} catch (IOException e) {\n\t\t\tthrow new CoreException(Util.createStatus(e));\n\t\t} catch (ParserConfigurationException e) {\n\t\t\tthrow new CoreException(Util.createStatus(e));\n\t\t}\n\t}\n\n\tprivate Transformer createSerializer() throws CoreException {\n\t\ttry {\n\t\t\treturn XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE().newTransformer();\n\t\t} catch (TransformerConfigurationException e) {\n\t\t\tthrow new CoreException(Util.createStatus(e));\n\t\t} catch (TransformerFactoryConfigurationError e) {\n\t\t\tthrow new CoreException(Util.createStatus(e));\n\t\t}\n\t}\n\n\tprivate void addMappings(Map<String, String> mappings, Element rootElement, String category, String keyName,\n\t\t\tString valueName) {\n\t\tDocument document = rootElement.getOwnerDocument();\n\t\tIterator<Entry<String, String>> entries = mappings.entrySet().iterator();\n\t\twhile (entries.hasNext()) {\n\t\t\tEntry<String, String> entry = entries.next();\n\t\t\tElement mapping = document.createElement(category);\n\t\t\tmapping.setAttribute(keyName, entry.getKey());\n\t\t\tmapping.setAttribute(valueName, entry.getValue());\n\t\t\trootElement.appendChild(mapping);\n\t\t}\n\t}\n\n\tprivate void addContentTypeMappings(Map<String, String> mappings, Element rootElement) {\n\t\taddMappings(mappings, rootElement, CONTENT_TYPE_MAPPING, ATTRIBUTE_CONTENT_TYPE, ATTRIBUTE_LANGUAGE);\n\t}\n\n\tprivate void addFileMappings(Map<String, Map<String, String>> mappings, ICStorageElement rootElement) {\n\t\tfor (Map.Entry<String, Map<String, String>> entry : mappings.entrySet()) {\n\t\t\tif (!entry.getValue().isEmpty()) {\n\t\t\t\tICStorageElement mapping = rootElement.createChild(FILE_MAPPING);\n\t\t\t\tString path = entry.getKey();\n\t\t\t\tfor (Entry<String, String> configurationEntry : entry.getValue().entrySet()) {\n\t\t\t\t\tString configuration = configurationEntry.getKey();\n\t\t\t\t\tString language = configurationEntry.getValue();\n\n\t\t\t\t\tmapping.setAttribute(ATTRIBUTE_PATH, path);\n\t\t\t\t\tmapping.setAttribute(ATTRIBUTE_CONFIGURATION, configuration);\n\t\t\t\t\tmapping.setAttribute(ATTRIBUTE_LANGUAGE, language);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
    "patch": "@@ -23,12 +23,10 @@\n import java.util.Map.Entry;\n import java.util.TreeMap;\n \n-import javax.xml.parsers.DocumentBuilderFactory;\n import javax.xml.parsers.ParserConfigurationException;\n import javax.xml.transform.Transformer;\n import javax.xml.transform.TransformerConfigurationException;\n import javax.xml.transform.TransformerException;\n-import javax.xml.transform.TransformerFactory;\n import javax.xml.transform.TransformerFactoryConfigurationError;\n import javax.xml.transform.dom.DOMSource;\n import javax.xml.transform.stream.StreamResult;\n@@ -41,6 +39,7 @@\n import org.eclipse.cdt.core.settings.model.ICProjectDescription;\n import org.eclipse.cdt.core.settings.model.ICStorageElement;\n import org.eclipse.cdt.internal.core.Util;\n+import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n import org.eclipse.core.resources.IProject;\n import org.eclipse.core.runtime.CoreException;\n import org.eclipse.core.runtime.preferences.DefaultScope;\n@@ -194,7 +193,7 @@ private void addProjectContentTypeMappings(Map<String, Map<String, String>> cont\n \tpublic void storeMappings(WorkspaceLanguageConfiguration config) throws CoreException {\n \t\ttry {\n \t\t\t// Encode mappings as XML and serialize as a String.\n-\t\t\tDocument doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n+\t\t\tDocument doc = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE().newDocument();\n \t\t\tElement rootElement = doc.createElement(WORKSPACE_MAPPINGS);\n \t\t\tdoc.appendChild(rootElement);\n \t\t\taddContentTypeMappings(config.getWorkspaceMappings(), rootElement);\n@@ -233,7 +232,7 @@ public WorkspaceLanguageConfiguration decodeWorkspaceMappings() throws CoreExcep\n \t\t// The mappings are encoded as XML in a String so we need to parse it.\n \t\tInputSource input = new InputSource(new StringReader(encodedMappings));\n \t\ttry {\n-\t\t\tDocument document = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(input);\n+\t\t\tDocument document = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE().parse(input);\n \t\t\tconfig.setWorkspaceMappings(decodeContentTypeMappings(document.getDocumentElement()));\n \t\t\treturn config;\n \t\t} catch (SAXException e) {\n@@ -247,7 +246,7 @@ public WorkspaceLanguageConfiguration decodeWorkspaceMappings() throws CoreExcep\n \n \tprivate Transformer createSerializer() throws CoreException {\n \t\ttry {\n-\t\t\treturn TransformerFactory.newInstance().newTransformer();\n+\t\t\treturn XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE().newTransformer();\n \t\t} catch (TransformerConfigurationException e) {\n \t\t\tthrow new CoreException(Util.createStatus(e));\n \t\t} catch (TransformerFactoryConfigurationError e) {",
    "function_modified_lines": {
      "added": [
        "\t\t\tDocument document = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE().parse(input);\n",
        "\t\t\treturn XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE().newTransformer();\n"
      ],
      "deleted": [
        "\t\t\tDocument document = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(input);\n",
        "\t\t\treturn TransformerFactory.newInstance().newTransformer();\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "In Eclipse IDE versions < 2023-09 (4.29) some files with xml content are parsed vulnerable against all sorts of XXE attacks. The user just needs to open any evil project or update an open project with a vulnerable file (for example for review a foreign repository or patch).\n",
    "id": 12860
  },
  {
    "cve_id": "CVE-2023-4218",
    "code_before_change": " *     IBM Corporation\n *     James Blackburn (Broadcom Corp.)\n *     Alex Blewitt Bug 132511 - nature order not preserved\n *     Christian Walther (Indel AG) - [436060] Race condition in updateProjectDescriptions()\n *     Alexander Fedorov (ArSysOp) - Bug 561992\n *******************************************************************************/\npackage org.eclipse.cdt.internal.core.settings.model;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URI;\nimport java.text.MessageFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.concurrent.CopyOnWriteArraySet;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.FactoryConfigurationError;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.eclipse.cdt.core.CCorePlugin;\nimport org.eclipse.cdt.core.language.settings.providers.ILanguageSettingsProvider;\nimport org.eclipse.cdt.core.language.settings.providers.ILanguageSettingsProvidersKeeper;\nimport org.eclipse.cdt.core.model.CModelException;\nimport org.eclipse.cdt.core.model.ICElement;\nimport org.eclipse.cdt.core.model.ICElementDelta;\nimport org.eclipse.cdt.core.model.ICProject;\nimport org.eclipse.cdt.core.settings.model.CExternalSetting;\nimport org.eclipse.cdt.core.settings.model.CProjectDescriptionEvent;\nimport org.eclipse.cdt.core.settings.model.ICBuildSetting;\nimport org.eclipse.cdt.core.settings.model.ICConfigurationDescription;\nimport org.eclipse.cdt.core.settings.model.ICDescriptionDelta;\nimport org.eclipse.cdt.core.settings.model.ICFileDescription;\nimport org.eclipse.cdt.core.settings.model.ICFolderDescription;\nimport org.eclipse.cdt.core.settings.model.ICLanguageSetting;\nimport org.eclipse.cdt.core.settings.model.ICLanguageSettingEntry;\nimport org.eclipse.cdt.core.settings.model.ICProjectDescription;\nimport org.eclipse.cdt.core.settings.model.ICProjectDescriptionListener;\nimport org.eclipse.cdt.core.settings.model.ICProjectDescriptionManager;\nimport org.eclipse.cdt.core.settings.model.ICProjectDescriptionWorkspacePreferences;\nimport org.eclipse.cdt.core.settings.model.ICResourceDescription;\nimport org.eclipse.cdt.core.settings.model.ICSettingBase;\nimport org.eclipse.cdt.core.settings.model.ICSettingEntry;\nimport org.eclipse.cdt.core.settings.model.ICSettingObject;\nimport org.eclipse.cdt.core.settings.model.ICSettingsStorage;\nimport org.eclipse.cdt.core.settings.model.ICSourceEntry;\nimport org.eclipse.cdt.core.settings.model.ICStorageElement;\nimport org.eclipse.cdt.core.settings.model.ICTargetPlatformSetting;\nimport org.eclipse.cdt.core.settings.model.extension.CConfigurationData;\nimport org.eclipse.cdt.core.settings.model.extension.CConfigurationDataProvider;\nimport org.eclipse.cdt.core.settings.model.extension.CFileData;\nimport org.eclipse.cdt.core.settings.model.extension.CFolderData;\nimport org.eclipse.cdt.core.settings.model.extension.CLanguageData;",
    "code_after_change": " *     Intel Corporation - Initial API and implementation\n *     Markus Schorn (Wind River Systems)\n *     IBM Corporation\n *     James Blackburn (Broadcom Corp.)\n *     Alex Blewitt Bug 132511 - nature order not preserved\n *     Christian Walther (Indel AG) - [436060] Race condition in updateProjectDescriptions()\n *     Alexander Fedorov (ArSysOp) - Bug 561992\n *******************************************************************************/\npackage org.eclipse.cdt.internal.core.settings.model;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URI;\nimport java.text.MessageFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.concurrent.CopyOnWriteArraySet;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.FactoryConfigurationError;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.eclipse.cdt.core.CCorePlugin;\nimport org.eclipse.cdt.core.language.settings.providers.ILanguageSettingsProvider;\nimport org.eclipse.cdt.core.language.settings.providers.ILanguageSettingsProvidersKeeper;\nimport org.eclipse.cdt.core.model.CModelException;\nimport org.eclipse.cdt.core.model.ICElement;\nimport org.eclipse.cdt.core.model.ICElementDelta;\nimport org.eclipse.cdt.core.model.ICProject;\nimport org.eclipse.cdt.core.settings.model.CExternalSetting;\nimport org.eclipse.cdt.core.settings.model.CProjectDescriptionEvent;\nimport org.eclipse.cdt.core.settings.model.ICBuildSetting;\nimport org.eclipse.cdt.core.settings.model.ICConfigurationDescription;\nimport org.eclipse.cdt.core.settings.model.ICDescriptionDelta;\nimport org.eclipse.cdt.core.settings.model.ICFileDescription;\nimport org.eclipse.cdt.core.settings.model.ICFolderDescription;\nimport org.eclipse.cdt.core.settings.model.ICLanguageSetting;\nimport org.eclipse.cdt.core.settings.model.ICLanguageSettingEntry;\nimport org.eclipse.cdt.core.settings.model.ICProjectDescription;\nimport org.eclipse.cdt.core.settings.model.ICProjectDescriptionListener;\nimport org.eclipse.cdt.core.settings.model.ICProjectDescriptionManager;\nimport org.eclipse.cdt.core.settings.model.ICProjectDescriptionWorkspacePreferences;\nimport org.eclipse.cdt.core.settings.model.ICResourceDescription;\nimport org.eclipse.cdt.core.settings.model.ICSettingBase;\nimport org.eclipse.cdt.core.settings.model.ICSettingEntry;\nimport org.eclipse.cdt.core.settings.model.ICSettingObject;\nimport org.eclipse.cdt.core.settings.model.ICSettingsStorage;\nimport org.eclipse.cdt.core.settings.model.ICSourceEntry;\nimport org.eclipse.cdt.core.settings.model.ICStorageElement;\nimport org.eclipse.cdt.core.settings.model.ICTargetPlatformSetting;\nimport org.eclipse.cdt.core.settings.model.extension.CConfigurationData;\nimport org.eclipse.cdt.core.settings.model.extension.CConfigurationDataProvider;\nimport org.eclipse.cdt.core.settings.model.extension.CFileData;\nimport org.eclipse.cdt.core.settings.model.extension.CFolderData;\nimport org.eclipse.cdt.core.settings.model.extension.CLanguageData;\nimport org.eclipse.cdt.core.settings.model.extension.CResourceData;\nimport org.eclipse.cdt.core.settings.model.extension.ICProjectConverter;",
    "patch": "@@ -45,14 +45,12 @@\n import java.util.concurrent.CopyOnWriteArraySet;\n \n import javax.xml.parsers.DocumentBuilder;\n-import javax.xml.parsers.DocumentBuilderFactory;\n import javax.xml.parsers.FactoryConfigurationError;\n import javax.xml.parsers.ParserConfigurationException;\n import javax.xml.transform.OutputKeys;\n import javax.xml.transform.Transformer;\n import javax.xml.transform.TransformerConfigurationException;\n import javax.xml.transform.TransformerException;\n-import javax.xml.transform.TransformerFactory;\n import javax.xml.transform.dom.DOMSource;\n import javax.xml.transform.stream.StreamResult;\n \n@@ -98,6 +96,7 @@\n import org.eclipse.cdt.core.settings.model.util.PathSettingsContainer;\n import org.eclipse.cdt.core.settings.model.util.PatternNameMap;\n import org.eclipse.cdt.internal.core.CConfigBasedDescriptorManager;\n+import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n import org.eclipse.cdt.internal.core.model.CElementDelta;\n import org.eclipse.cdt.internal.core.settings.model.CExternalSettinsDeltaCalculator.ExtSettingsDelta;\n import org.eclipse.cdt.internal.core.settings.model.xml.InternalXmlStorageElement;\n@@ -918,7 +917,8 @@ private void serializePreference(String key, InternalXmlStorageElement element)\n \t\tByteArrayOutputStream stream = new ByteArrayOutputStream();\n \t\tFileOutputStream fileStream = null;\n \t\ttry {\n-\t\t\tTransformer transformer = TransformerFactory.newInstance().newTransformer();\n+\t\t\tTransformer transformer = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE()\n+\t\t\t\t\t.newTransformer();\n \t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n \t\t\ttransformer.setOutputProperty(OutputKeys.ENCODING, \"UTF-8\"); //$NON-NLS-1$\n \t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n@@ -1234,7 +1234,7 @@ private void initProviderInfo() {\n \tpublic ICStorageElement createPreferenceStorage(String key, boolean createEmptyIfNotFound, boolean readOnly)\n \t\t\tthrows CoreException {\n \t\ttry {\n-\t\t\tDocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n+\t\t\tDocumentBuilder builder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tDocument doc = null;\n \t\t\tElement element = null;\n \t\t\tInputStream stream = null;",
    "function_modified_lines": {
      "added": [],
      "deleted": [
        "import javax.xml.parsers.DocumentBuilderFactory;\n",
        "import javax.xml.transform.TransformerFactory;\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "In Eclipse IDE versions < 2023-09 (4.29) some files with xml content are parsed vulnerable against all sorts of XXE attacks. The user just needs to open any evil project or update an open project with a vulnerable file (for example for review a foreign repository or patch).\n",
    "id": 12861
  },
  {
    "cve_id": "CVE-2023-4218",
    "code_before_change": "/*******************************************************************************\n * Copyright (c) 2008, 2011 Broadcom Corporation and others.\n *\n * This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n *\n * Contributors:\n *     James Blackburn (Broadcom Corp.)\n *******************************************************************************/\n\npackage org.eclipse.cdt.internal.core.settings.model;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URI;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.TransformerFactoryConfigurationError;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.eclipse.cdt.core.CCorePlugin;\nimport org.eclipse.cdt.core.settings.model.ICProjectDescription;\nimport org.eclipse.cdt.internal.core.CConfigBasedDescriptorManager;\nimport org.eclipse.cdt.internal.core.XmlUtil;\nimport org.eclipse.cdt.internal.core.settings.model.ICProjectDescriptionStorageType.CProjectDescriptionStorageTypeProxy;\nimport org.eclipse.cdt.internal.core.settings.model.xml.XmlProjectDescriptionStorage;\nimport org.eclipse.cdt.internal.core.settings.model.xml2.XmlProjectDescriptionStorage2;\nimport org.eclipse.core.filesystem.EFS;\nimport org.eclipse.core.filesystem.IFileInfo;\nimport org.eclipse.core.filesystem.IFileStore;\nimport org.eclipse.core.resources.IContainer;\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.resources.ResourceAttributes;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.IConfigurationElement;\nimport org.eclipse.core.runtime.IExtension;\nimport org.eclipse.core.runtime.IExtensionPoint;\nimport org.eclipse.core.runtime.IProgressMonitor;\nimport org.eclipse.core.runtime.IStatus;\nimport org.eclipse.core.runtime.NullProgressMonitor;\nimport org.eclipse.core.runtime.Platform;\nimport org.osgi.framework.Version;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.ProcessingInstruction;\n\n/**\n * Class that marshals creation of AbstractCProjectDescriptionStorages\n * for a given project.\n *\n * Persist Storage type ID in the .cproject file, and provides backwards compatibility\n * for existing project descriptions which don't encode the storage type in the project\n * description.\n */\npublic class CProjectDescriptionStorageManager {\n\n\t/* Extension point data */",
    "code_after_change": "/*******************************************************************************\n * Copyright (c) 2008, 2011 Broadcom Corporation and others.\n *\n * This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n *\n * Contributors:\n *     James Blackburn (Broadcom Corp.)\n *******************************************************************************/\n\npackage org.eclipse.cdt.internal.core.settings.model;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URI;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactoryConfigurationError;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.eclipse.cdt.core.CCorePlugin;\nimport org.eclipse.cdt.core.settings.model.ICProjectDescription;\nimport org.eclipse.cdt.internal.core.CConfigBasedDescriptorManager;\nimport org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\nimport org.eclipse.cdt.internal.core.XmlUtil;\nimport org.eclipse.cdt.internal.core.settings.model.ICProjectDescriptionStorageType.CProjectDescriptionStorageTypeProxy;\nimport org.eclipse.cdt.internal.core.settings.model.xml.XmlProjectDescriptionStorage;\nimport org.eclipse.cdt.internal.core.settings.model.xml2.XmlProjectDescriptionStorage2;\nimport org.eclipse.core.filesystem.EFS;\nimport org.eclipse.core.filesystem.IFileInfo;\nimport org.eclipse.core.filesystem.IFileStore;\nimport org.eclipse.core.resources.IContainer;\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.resources.ResourceAttributes;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.IConfigurationElement;\nimport org.eclipse.core.runtime.IExtension;\nimport org.eclipse.core.runtime.IExtensionPoint;\nimport org.eclipse.core.runtime.IProgressMonitor;\nimport org.eclipse.core.runtime.IStatus;\nimport org.eclipse.core.runtime.NullProgressMonitor;\nimport org.eclipse.core.runtime.Platform;\nimport org.osgi.framework.Version;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.ProcessingInstruction;\nimport org.xml.sax.SAXException;\n\n/**\n * Class that marshals creation of AbstractCProjectDescriptionStorages\n * for a given project.\n *\n * Persist Storage type ID in the .cproject file, and provides backwards compatibility\n * for existing project descriptions which don't encode the storage type in the project\n * description.\n */",
    "patch": "@@ -27,20 +27,19 @@\n import java.util.concurrent.ConcurrentHashMap;\n \n import javax.xml.parsers.DocumentBuilder;\n-import javax.xml.parsers.DocumentBuilderFactory;\n import javax.xml.parsers.ParserConfigurationException;\n import javax.xml.transform.OutputKeys;\n import javax.xml.transform.Transformer;\n import javax.xml.transform.TransformerConfigurationException;\n import javax.xml.transform.TransformerException;\n-import javax.xml.transform.TransformerFactory;\n import javax.xml.transform.TransformerFactoryConfigurationError;\n import javax.xml.transform.dom.DOMSource;\n import javax.xml.transform.stream.StreamResult;\n \n import org.eclipse.cdt.core.CCorePlugin;\n import org.eclipse.cdt.core.settings.model.ICProjectDescription;\n import org.eclipse.cdt.internal.core.CConfigBasedDescriptorManager;\n+import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n import org.eclipse.cdt.internal.core.XmlUtil;\n import org.eclipse.cdt.internal.core.settings.model.ICProjectDescriptionStorageType.CProjectDescriptionStorageTypeProxy;\n import org.eclipse.cdt.internal.core.settings.model.xml.XmlProjectDescriptionStorage;\n@@ -67,6 +66,7 @@\n import org.w3c.dom.Node;\n import org.w3c.dom.NodeList;\n import org.w3c.dom.ProcessingInstruction;\n+import org.xml.sax.SAXException;\n \n /**\n  * Class that marshals creation of AbstractCProjectDescriptionStorages\n@@ -163,7 +163,7 @@ private void writeProjectStorageType(IProject project, CProjectDescriptionStorag\n \t\t\tthrows CoreException {\n \t\tDocument doc;\n \t\ttry {\n-\t\t\tdoc = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n+\t\t\tdoc = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE().newDocument();\n \t\t\t// Set the version\n \t\t\tProcessingInstruction instruction = doc.createProcessingInstruction(\n \t\t\t\t\tICProjectDescriptionStorageType.STORAGE_VERSION_NAME, type.version.toString());\n@@ -175,7 +175,8 @@ private void writeProjectStorageType(IProject project, CProjectDescriptionStorag\n \t\t\tXmlUtil.prettyFormat(doc);\n \n \t\t\tByteArrayOutputStream stream = new ByteArrayOutputStream();\n-\t\t\tTransformer transformer = TransformerFactory.newInstance().newTransformer();\n+\t\t\tTransformer transformer = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE()\n+\t\t\t\t\t.newTransformer();\n \t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n \t\t\ttransformer.setOutputProperty(OutputKeys.ENCODING, \"UTF-8\"); //$NON-NLS-1$\n \t\t\t// Indentation is done with XmlUtil.prettyFormat(doc)\n@@ -222,7 +223,7 @@ private AbstractCProjectDescriptionStorage loadProjectStorage(IProject project)\n \n \t\tInputStream stream = null;\n \t\ttry {\n-\t\t\tDocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n+\t\t\tDocumentBuilder builder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tstream = getInputStreamForIFile(project, ICProjectDescriptionStorageType.STORAGE_FILE_NAME);\n \t\t\tif (stream != null) {\n \t\t\t\tDocument doc = builder.parse(stream);\n@@ -352,7 +353,7 @@ private synchronized void initExtensionPoints() {\n \t\t\t\t\tCProjectDescriptionStorageTypeProxy type = initStorageType(configEl);\n \t\t\t\t\tif (type != null) {\n \t\t\t\t\t\tif (!m.containsKey(type.id))\n-\t\t\t\t\t\t\tm.put(type.id, new LinkedList<CProjectDescriptionStorageTypeProxy>());\n+\t\t\t\t\t\t\tm.put(type.id, new LinkedList<>());\n \t\t\t\t\t\tm.get(type.id).add(type);\n \t\t\t\t\t}\n \t\t\t\t}",
    "function_modified_lines": {
      "added": [
        "import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n"
      ],
      "deleted": [
        "import javax.xml.parsers.DocumentBuilderFactory;\n",
        "import javax.xml.transform.TransformerFactory;\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "In Eclipse IDE versions < 2023-09 (4.29) some files with xml content are parsed vulnerable against all sorts of XXE attacks. The user just needs to open any evil project or update an open project with a vulnerable file (for example for review a foreign repository or patch).\n",
    "id": 12862
  },
  {
    "cve_id": "CVE-2023-4218",
    "code_before_change": "{\n\t\t\tdoc = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n\t\t\t// Set the version\n\t\t\tProcessingInstruction instruction = doc.createProcessingInstruction(\n\t\t\t\t\tICProjectDescriptionStorageType.STORAGE_VERSION_NAME, type.version.toString());\n\t\t\tdoc.appendChild(instruction);\n\t\t\t// Set the type id\n\t\t\tElement el = doc.createElement(ICProjectDescriptionStorageType.STORAGE_ROOT_ELEMENT_NAME);\n\t\t\tel.setAttribute(ICProjectDescriptionStorageType.STORAGE_TYPE_ATTRIBUTE, type.id);\n\t\t\tdoc.appendChild(el);\n\t\t\tXmlUtil.prettyFormat(doc);\n\n\t\t\tByteArrayOutputStream stream = new ByteArrayOutputStream();\n\t\t\tTransformer transformer = TransformerFactory.newInstance().newTransformer();\n\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\t\ttransformer.setOutputProperty(OutputKeys.ENCODING, \"UTF-8\"); //$NON-NLS-1$\n\t\t\t// Indentation is done with XmlUtil.prettyFormat(doc)\n\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"no\"); //$NON-NLS-1$\n\t\t\tDOMSource source = new DOMSource(doc);\n\t\t\tStreamResult result = new StreamResult(stream);\n\t\t\ttransformer.transform(source, result);\n\n\t\t\tInputStream input = new ByteArrayInputStream(stream.toByteArray());\n\n\t\t\t// Set the project description storage type\n\t\t\tIFile f = project.getFile(ICProjectDescriptionStorageType.STORAGE_FILE_NAME);\n\t\t\tif (!f.exists())\n\t\t\t\tf.refreshLocal(IResource.DEPTH_INFINITE, new NullProgressMonitor());\n\t\t\tensureWritable(f);\n\t\t\tif (!f.exists())\n\t\t\t\tf.create(input, true, new NullProgressMonitor());\n\t\t\telse\n\t\t\t\tf.setContents(input, IResource.FORCE, new NullProgressMonitor());\n\t\t}",
    "code_after_change": "{\n\t\t\tdoc = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE().newDocument();\n\t\t\t// Set the version\n\t\t\tProcessingInstruction instruction = doc.createProcessingInstruction(\n\t\t\t\t\tICProjectDescriptionStorageType.STORAGE_VERSION_NAME, type.version.toString());\n\t\t\tdoc.appendChild(instruction);\n\t\t\t// Set the type id\n\t\t\tElement el = doc.createElement(ICProjectDescriptionStorageType.STORAGE_ROOT_ELEMENT_NAME);\n\t\t\tel.setAttribute(ICProjectDescriptionStorageType.STORAGE_TYPE_ATTRIBUTE, type.id);\n\t\t\tdoc.appendChild(el);\n\t\t\tXmlUtil.prettyFormat(doc);\n\n\t\t\tByteArrayOutputStream stream = new ByteArrayOutputStream();\n\t\t\tTransformer transformer = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE()\n\t\t\t\t\t.newTransformer();\n\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\t\ttransformer.setOutputProperty(OutputKeys.ENCODING, \"UTF-8\"); //$NON-NLS-1$\n\t\t\t// Indentation is done with XmlUtil.prettyFormat(doc)\n\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"no\"); //$NON-NLS-1$\n\t\t\tDOMSource source = new DOMSource(doc);\n\t\t\tStreamResult result = new StreamResult(stream);\n\t\t\ttransformer.transform(source, result);\n\n\t\t\tInputStream input = new ByteArrayInputStream(stream.toByteArray());\n\n\t\t\t// Set the project description storage type\n\t\t\tIFile f = project.getFile(ICProjectDescriptionStorageType.STORAGE_FILE_NAME);\n\t\t\tif (!f.exists())\n\t\t\t\tf.refreshLocal(IResource.DEPTH_INFINITE, new NullProgressMonitor());\n\t\t\tensureWritable(f);\n\t\t\tif (!f.exists())\n\t\t\t\tf.create(input, true, new NullProgressMonitor());\n\t\t\telse\n\t\t\t\tf.setContents(input, IResource.FORCE, new NullProgressMonitor());\n\t\t}",
    "patch": "@@ -27,20 +27,19 @@\n import java.util.concurrent.ConcurrentHashMap;\n \n import javax.xml.parsers.DocumentBuilder;\n-import javax.xml.parsers.DocumentBuilderFactory;\n import javax.xml.parsers.ParserConfigurationException;\n import javax.xml.transform.OutputKeys;\n import javax.xml.transform.Transformer;\n import javax.xml.transform.TransformerConfigurationException;\n import javax.xml.transform.TransformerException;\n-import javax.xml.transform.TransformerFactory;\n import javax.xml.transform.TransformerFactoryConfigurationError;\n import javax.xml.transform.dom.DOMSource;\n import javax.xml.transform.stream.StreamResult;\n \n import org.eclipse.cdt.core.CCorePlugin;\n import org.eclipse.cdt.core.settings.model.ICProjectDescription;\n import org.eclipse.cdt.internal.core.CConfigBasedDescriptorManager;\n+import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n import org.eclipse.cdt.internal.core.XmlUtil;\n import org.eclipse.cdt.internal.core.settings.model.ICProjectDescriptionStorageType.CProjectDescriptionStorageTypeProxy;\n import org.eclipse.cdt.internal.core.settings.model.xml.XmlProjectDescriptionStorage;\n@@ -67,6 +66,7 @@\n import org.w3c.dom.Node;\n import org.w3c.dom.NodeList;\n import org.w3c.dom.ProcessingInstruction;\n+import org.xml.sax.SAXException;\n \n /**\n  * Class that marshals creation of AbstractCProjectDescriptionStorages\n@@ -163,7 +163,7 @@ private void writeProjectStorageType(IProject project, CProjectDescriptionStorag\n \t\t\tthrows CoreException {\n \t\tDocument doc;\n \t\ttry {\n-\t\t\tdoc = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n+\t\t\tdoc = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE().newDocument();\n \t\t\t// Set the version\n \t\t\tProcessingInstruction instruction = doc.createProcessingInstruction(\n \t\t\t\t\tICProjectDescriptionStorageType.STORAGE_VERSION_NAME, type.version.toString());\n@@ -175,7 +175,8 @@ private void writeProjectStorageType(IProject project, CProjectDescriptionStorag\n \t\t\tXmlUtil.prettyFormat(doc);\n \n \t\t\tByteArrayOutputStream stream = new ByteArrayOutputStream();\n-\t\t\tTransformer transformer = TransformerFactory.newInstance().newTransformer();\n+\t\t\tTransformer transformer = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE()\n+\t\t\t\t\t.newTransformer();\n \t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n \t\t\ttransformer.setOutputProperty(OutputKeys.ENCODING, \"UTF-8\"); //$NON-NLS-1$\n \t\t\t// Indentation is done with XmlUtil.prettyFormat(doc)\n@@ -222,7 +223,7 @@ private AbstractCProjectDescriptionStorage loadProjectStorage(IProject project)\n \n \t\tInputStream stream = null;\n \t\ttry {\n-\t\t\tDocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n+\t\t\tDocumentBuilder builder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tstream = getInputStreamForIFile(project, ICProjectDescriptionStorageType.STORAGE_FILE_NAME);\n \t\t\tif (stream != null) {\n \t\t\t\tDocument doc = builder.parse(stream);\n@@ -352,7 +353,7 @@ private synchronized void initExtensionPoints() {\n \t\t\t\t\tCProjectDescriptionStorageTypeProxy type = initStorageType(configEl);\n \t\t\t\t\tif (type != null) {\n \t\t\t\t\t\tif (!m.containsKey(type.id))\n-\t\t\t\t\t\t\tm.put(type.id, new LinkedList<CProjectDescriptionStorageTypeProxy>());\n+\t\t\t\t\t\t\tm.put(type.id, new LinkedList<>());\n \t\t\t\t\t\tm.get(type.id).add(type);\n \t\t\t\t\t}\n \t\t\t\t}",
    "function_modified_lines": {
      "added": [
        "\t\t\tdoc = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE().newDocument();\n",
        "\t\t\tTransformer transformer = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE()\n",
        "\t\t\t\t\t.newTransformer();\n"
      ],
      "deleted": [
        "\t\t\tdoc = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n",
        "\t\t\tTransformer transformer = TransformerFactory.newInstance().newTransformer();\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "In Eclipse IDE versions < 2023-09 (4.29) some files with xml content are parsed vulnerable against all sorts of XXE attacks. The user just needs to open any evil project or update an open project with a vulnerable file (for example for review a foreign repository or patch).\n",
    "id": 12863
  },
  {
    "cve_id": "CVE-2023-4218",
    "code_before_change": "/*******************************************************************************\n * Copyright (c) 2007, 2013 Intel Corporation and others.\n *\n * This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n *\n * Contributors:\n *     Intel Corporation - Initial API and implementation\n *     Markus Schorn (Wind River Systems)\n *     IBM Corporation\n *     James Blackburn (Broadcom Corp.)\n *     Marc-Andre Laperle (Ericsson)\n *******************************************************************************/\npackage org.eclipse.cdt.internal.core.settings.model.xml;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.lang.ref.Reference;\nimport java.lang.ref.SoftReference;\nimport java.net.URI;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.FactoryConfigurationError;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.eclipse.cdt.core.CCorePlugin;\nimport org.eclipse.cdt.core.settings.model.ICProjectDescription;\nimport org.eclipse.cdt.core.settings.model.ICProjectDescriptionManager;\nimport org.eclipse.cdt.core.settings.model.ICSettingsStorage;\nimport org.eclipse.cdt.core.settings.model.ICStorageElement;\nimport org.eclipse.cdt.core.settings.model.extension.ICProjectConverter;\nimport org.eclipse.cdt.core.settings.model.util.CDataUtil;\nimport org.eclipse.cdt.internal.core.XmlUtil;\nimport org.eclipse.cdt.internal.core.envvar.ContributedEnvironment;\nimport org.eclipse.cdt.internal.core.language.settings.providers.LanguageSettingsProvidersSerializer;\nimport org.eclipse.cdt.internal.core.model.Util;\nimport org.eclipse.cdt.internal.core.settings.model.AbstractCProjectDescriptionStorage;\nimport org.eclipse.cdt.internal.core.settings.model.CProjectDescription;\nimport org.eclipse.cdt.internal.core.settings.model.CProjectDescriptionManager;\nimport org.eclipse.cdt.internal.core.settings.model.CProjectDescriptionStorageManager;\nimport org.eclipse.cdt.internal.core.settings.model.ExceptionFactory;\nimport org.eclipse.cdt.internal.core.settings.model.ICProjectDescriptionStorageType;\nimport org.eclipse.cdt.internal.core.settings.model.ICProjectDescriptionStorageType.CProjectDescriptionStorageTypeProxy;\nimport org.eclipse.cdt.internal.core.settings.model.SettingsContext;\nimport org.eclipse.cdt.internal.core.settings.model.SettingsModelMessages;\nimport org.eclipse.core.filesystem.EFS;\nimport org.eclipse.core.filesystem.IFileInfo;\nimport org.eclipse.core.filesystem.IFileStore;\nimport org.eclipse.core.resources.IContainer;\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.resources.IProjectDescription;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.resources.IWorkspace;\nimport org.eclipse.core.resources.IWorkspaceRunnable;\nimport org.eclipse.core.resources.ResourcesPlugin;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.IProgressMonitor;\nimport org.eclipse.core.runtime.IStatus;\nimport org.eclipse.core.runtime.NullProgressMonitor;\nimport org.eclipse.core.runtime.Path;\nimport org.eclipse.core.runtime.QualifiedName;\nimport org.eclipse.core.runtime.Status;\nimport org.eclipse.core.runtime.jobs.IJobChangeEvent;\nimport org.eclipse.core.runtime.jobs.ILock;\nimport org.eclipse.core.runtime.jobs.ISchedulingRule;\nimport org.eclipse.core.runtime.jobs.Job;\nimport org.eclipse.core.runtime.jobs.JobChangeAdapter;\nimport org.eclipse.core.runtime.jobs.MultiRule;\nimport org.osgi.framework.Version;",
    "code_after_change": "/*******************************************************************************\n * Copyright (c) 2007, 2013 Intel Corporation and others.\n *\n * This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n *\n * Contributors:\n *     Intel Corporation - Initial API and implementation\n *     Markus Schorn (Wind River Systems)\n *     IBM Corporation\n *     James Blackburn (Broadcom Corp.)\n *     Marc-Andre Laperle (Ericsson)\n *******************************************************************************/\npackage org.eclipse.cdt.internal.core.settings.model.xml;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.lang.ref.Reference;\nimport java.lang.ref.SoftReference;\nimport java.net.URI;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.FactoryConfigurationError;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.eclipse.cdt.core.CCorePlugin;\nimport org.eclipse.cdt.core.settings.model.ICProjectDescription;\nimport org.eclipse.cdt.core.settings.model.ICProjectDescriptionManager;\nimport org.eclipse.cdt.core.settings.model.ICSettingsStorage;\nimport org.eclipse.cdt.core.settings.model.ICStorageElement;\nimport org.eclipse.cdt.core.settings.model.extension.ICProjectConverter;\nimport org.eclipse.cdt.core.settings.model.util.CDataUtil;\nimport org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\nimport org.eclipse.cdt.internal.core.XmlUtil;\nimport org.eclipse.cdt.internal.core.envvar.ContributedEnvironment;\nimport org.eclipse.cdt.internal.core.language.settings.providers.LanguageSettingsProvidersSerializer;\nimport org.eclipse.cdt.internal.core.model.Util;\nimport org.eclipse.cdt.internal.core.settings.model.AbstractCProjectDescriptionStorage;\nimport org.eclipse.cdt.internal.core.settings.model.CProjectDescription;\nimport org.eclipse.cdt.internal.core.settings.model.CProjectDescriptionManager;\nimport org.eclipse.cdt.internal.core.settings.model.CProjectDescriptionStorageManager;\nimport org.eclipse.cdt.internal.core.settings.model.ExceptionFactory;\nimport org.eclipse.cdt.internal.core.settings.model.ICProjectDescriptionStorageType;\nimport org.eclipse.cdt.internal.core.settings.model.ICProjectDescriptionStorageType.CProjectDescriptionStorageTypeProxy;\nimport org.eclipse.cdt.internal.core.settings.model.SettingsContext;\nimport org.eclipse.cdt.internal.core.settings.model.SettingsModelMessages;\nimport org.eclipse.core.filesystem.EFS;\nimport org.eclipse.core.filesystem.IFileInfo;\nimport org.eclipse.core.filesystem.IFileStore;\nimport org.eclipse.core.resources.IContainer;\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.resources.IProjectDescription;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.resources.IWorkspace;\nimport org.eclipse.core.resources.IWorkspaceRunnable;\nimport org.eclipse.core.resources.ResourcesPlugin;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.IProgressMonitor;\nimport org.eclipse.core.runtime.IStatus;\nimport org.eclipse.core.runtime.NullProgressMonitor;\nimport org.eclipse.core.runtime.Path;\nimport org.eclipse.core.runtime.QualifiedName;\nimport org.eclipse.core.runtime.Status;\nimport org.eclipse.core.runtime.jobs.IJobChangeEvent;\nimport org.eclipse.core.runtime.jobs.ILock;\nimport org.eclipse.core.runtime.jobs.ISchedulingRule;\nimport org.eclipse.core.runtime.jobs.Job;\nimport org.eclipse.core.runtime.jobs.JobChangeAdapter;",
    "patch": "@@ -26,14 +26,12 @@\n import java.net.URI;\n \n import javax.xml.parsers.DocumentBuilder;\n-import javax.xml.parsers.DocumentBuilderFactory;\n import javax.xml.parsers.FactoryConfigurationError;\n import javax.xml.parsers.ParserConfigurationException;\n import javax.xml.transform.OutputKeys;\n import javax.xml.transform.Transformer;\n import javax.xml.transform.TransformerConfigurationException;\n import javax.xml.transform.TransformerException;\n-import javax.xml.transform.TransformerFactory;\n import javax.xml.transform.dom.DOMSource;\n import javax.xml.transform.stream.StreamResult;\n \n@@ -44,6 +42,7 @@\n import org.eclipse.cdt.core.settings.model.ICStorageElement;\n import org.eclipse.cdt.core.settings.model.extension.ICProjectConverter;\n import org.eclipse.cdt.core.settings.model.util.CDataUtil;\n+import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n import org.eclipse.cdt.internal.core.XmlUtil;\n import org.eclipse.cdt.internal.core.envvar.ContributedEnvironment;\n import org.eclipse.cdt.internal.core.language.settings.providers.LanguageSettingsProvidersSerializer;\n@@ -543,7 +542,8 @@ private ByteArrayOutputStream write(ICStorageElement element) throws CoreExcepti\n \n \t\tByteArrayOutputStream stream = new ByteArrayOutputStream();\n \t\ttry {\n-\t\t\tTransformer transformer = TransformerFactory.newInstance().newTransformer();\n+\t\t\tTransformer transformer = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE()\n+\t\t\t\t\t.newTransformer();\n \t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n \t\t\ttransformer.setOutputProperty(OutputKeys.ENCODING, \"UTF-8\"); //$NON-NLS-1$\n \t\t\t// Indentation is done with XmlUtil.prettyFormat(doc)\n@@ -632,7 +632,7 @@ protected long serialize(IContainer container, String file, ICStorageElement ele\n \tprivate ICStorageElement readOldCDTProjectFile(IProject project) throws CoreException {\n \t\tICStorageElement storage = null;\n \t\ttry {\n-\t\t\tDocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n+\t\t\tDocumentBuilder builder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tDocument doc = null;\n \t\t\tInputStream stream = getSharedProperty(project, OLD_CDTPROJECT_FILE_NAME);\n \t\t\tif (stream != null) {\n@@ -669,7 +669,7 @@ private ICStorageElement readOldCDTProjectFile(IProject project) throws CoreExce\n \tprotected InternalXmlStorageElement createStorage(IContainer container, String fileName, boolean reCreate,\n \t\t\tboolean createEmptyIfNotFound, boolean readOnly) throws CoreException {\n \t\ttry {\n-\t\t\tDocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n+\t\t\tDocumentBuilder builder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tDocument doc = null;\n \t\t\tElement element = null;\n \t\t\tInputStream stream = null;\n@@ -851,7 +851,7 @@ public void projectMove(IProject newProject) {\n \t */\n \tpublic Element createXmlElementCopy(InternalXmlStorageElement el) throws CoreException {\n \t\ttry {\n-\t\t\tDocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n+\t\t\tDocumentBuilder builder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tDocument doc = builder.newDocument();\n \t\t\tElement newXmlEl = null;\n \t\t\tsynchronized (doc) {",
    "function_modified_lines": {
      "added": [
        "import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n"
      ],
      "deleted": [
        "import javax.xml.parsers.DocumentBuilderFactory;\n",
        "import javax.xml.transform.TransformerFactory;\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "In Eclipse IDE versions < 2023-09 (4.29) some files with xml content are parsed vulnerable against all sorts of XXE attacks. The user just needs to open any evil project or update an open project with a vulnerable file (for example for review a foreign repository or patch).\n",
    "id": 12864
  },
  {
    "cve_id": "CVE-2023-4218",
    "code_before_change": "/*******************************************************************************\n * Copyright (c) 2005, 2016 Intel Corporation and others.\n *\n * This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n *\n * Contributors:\n * Intel Corporation - Initial API and implementation\n *******************************************************************************/\npackage org.eclipse.cdt.internal.core.cdtvariables;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Objects;\nimport java.util.Set;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.eclipse.cdt.core.CCorePlugin;\nimport org.eclipse.cdt.core.cdtvariables.CdtVariableException;\nimport org.eclipse.cdt.core.cdtvariables.ICdtVariable;\nimport org.eclipse.cdt.core.settings.model.ICStorageElement;\nimport org.eclipse.cdt.internal.core.settings.model.CConfigurationSpecSettings;\nimport org.eclipse.cdt.internal.core.settings.model.ExceptionFactory;\nimport org.eclipse.cdt.internal.core.settings.model.IInternalCCfgInfo;\nimport org.eclipse.cdt.internal.core.settings.model.xml.XmlStorageElement;\nimport org.eclipse.cdt.utils.cdtvariables.CdtVariableResolver;\nimport org.eclipse.core.resources.IWorkspace;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.preferences.InstanceScope;\nimport org.osgi.service.prefs.BackingStoreException;\nimport org.osgi.service.prefs.Preferences;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\n\n/**\n * This supplier is used to obtain the user-defined macros\n *\n * @since 3.0\n */\npublic class UserDefinedVariableSupplier extends CoreMacroSupplierBase {\n\t//\tpublic static final String MACROS_ELEMENT_NAME = \"macros\"; //$NON-NLS-1$\n\tpublic static final String NODENAME = \"macros\"; //$NON-NLS-1$\n\tpublic static final String PREFNAME_WORKSPACE = \"workspace\"; //$NON-NLS-1$\n\tstatic final String OLD_VARIABLE_PREFIX = \"pathEntryVariable.\"; //$NON-NLS-1$\n\n\tprivate static UserDefinedVariableSupplier fInstance;\n\n\tprivate StorableCdtVariables fWorkspaceMacros;\n\tprivate Set<ICdtVariableChangeListener> fListeners;\n\n\tprivate StorableCdtVariables getStorableMacros(int contextType, Object contextData) {\n\t\tStorableCdtVariables macros = null;\n\t\tswitch (contextType) {\n\t\tcase ICoreVariableContextInfo.CONTEXT_CONFIGURATION:\n\t\t\tif (contextData instanceof IInternalCCfgInfo) {\n\t\t\t\ttry {\n\t\t\t\t\tCConfigurationSpecSettings settings = ((IInternalCCfgInfo) contextData).getSpecSettings();",
    "code_after_change": "/*******************************************************************************\n * Copyright (c) 2005, 2016 Intel Corporation and others.\n *\n * This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n *\n * Contributors:\n * Intel Corporation - Initial API and implementation\n *******************************************************************************/\npackage org.eclipse.cdt.internal.core.cdtvariables;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Objects;\nimport java.util.Set;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.eclipse.cdt.core.CCorePlugin;\nimport org.eclipse.cdt.core.cdtvariables.CdtVariableException;\nimport org.eclipse.cdt.core.cdtvariables.ICdtVariable;\nimport org.eclipse.cdt.core.settings.model.ICStorageElement;\nimport org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\nimport org.eclipse.cdt.internal.core.settings.model.CConfigurationSpecSettings;\nimport org.eclipse.cdt.internal.core.settings.model.ExceptionFactory;\nimport org.eclipse.cdt.internal.core.settings.model.IInternalCCfgInfo;\nimport org.eclipse.cdt.internal.core.settings.model.xml.XmlStorageElement;\nimport org.eclipse.cdt.utils.cdtvariables.CdtVariableResolver;\nimport org.eclipse.core.resources.IWorkspace;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.preferences.InstanceScope;\nimport org.osgi.service.prefs.BackingStoreException;\nimport org.osgi.service.prefs.Preferences;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\n\n/**\n * This supplier is used to obtain the user-defined macros\n *\n * @since 3.0\n */\npublic class UserDefinedVariableSupplier extends CoreMacroSupplierBase {\n\t//\tpublic static final String MACROS_ELEMENT_NAME = \"macros\"; //$NON-NLS-1$\n\tpublic static final String NODENAME = \"macros\"; //$NON-NLS-1$\n\tpublic static final String PREFNAME_WORKSPACE = \"workspace\"; //$NON-NLS-1$\n\tstatic final String OLD_VARIABLE_PREFIX = \"pathEntryVariable.\"; //$NON-NLS-1$\n\n\tprivate static UserDefinedVariableSupplier fInstance;\n\n\tprivate StorableCdtVariables fWorkspaceMacros;\n\tprivate Set<ICdtVariableChangeListener> fListeners;\n\n\tprivate StorableCdtVariables getStorableMacros(int contextType, Object contextData) {\n\t\tStorableCdtVariables macros = null;\n\t\tswitch (contextType) {\n\t\tcase ICoreVariableContextInfo.CONTEXT_CONFIGURATION:\n\t\t\tif (contextData instanceof IInternalCCfgInfo) {",
    "patch": "@@ -25,20 +25,19 @@\n import java.util.Set;\n \n import javax.xml.parsers.DocumentBuilder;\n-import javax.xml.parsers.DocumentBuilderFactory;\n import javax.xml.parsers.ParserConfigurationException;\n import javax.xml.transform.OutputKeys;\n import javax.xml.transform.Transformer;\n import javax.xml.transform.TransformerConfigurationException;\n import javax.xml.transform.TransformerException;\n-import javax.xml.transform.TransformerFactory;\n import javax.xml.transform.dom.DOMSource;\n import javax.xml.transform.stream.StreamResult;\n \n import org.eclipse.cdt.core.CCorePlugin;\n import org.eclipse.cdt.core.cdtvariables.CdtVariableException;\n import org.eclipse.cdt.core.cdtvariables.ICdtVariable;\n import org.eclipse.cdt.core.settings.model.ICStorageElement;\n+import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n import org.eclipse.cdt.internal.core.settings.model.CConfigurationSpecSettings;\n import org.eclipse.cdt.internal.core.settings.model.ExceptionFactory;\n import org.eclipse.cdt.internal.core.settings.model.IInternalCCfgInfo;\n@@ -94,7 +93,7 @@ private StorableCdtVariables getStorableMacros(int contextType, Object contextDa\n \t}\n \n \tprivate UserDefinedVariableSupplier() {\n-\t\tfListeners = Collections.synchronizedSet(new HashSet<ICdtVariableChangeListener>());\n+\t\tfListeners = Collections.synchronizedSet(new HashSet<>());\n \t}\n \n \tpublic static UserDefinedVariableSupplier getInstance() {\n@@ -532,7 +531,7 @@ protected void storeWorkspaceMacros(StorableCdtVariables macros, boolean force)\n \n \tprivate StorableCdtVariables loadMacrosFromStream(InputStream stream, boolean readOnly) {\n \t\ttry {\n-\t\t\tDocumentBuilder parser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n+\t\t\tDocumentBuilder parser = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tInputSource inputSource = new InputSource(stream);\n \t\t\tDocument document = parser.parse(inputSource);\n \t\t\tElement rootElement = document.getDocumentElement();\n@@ -554,16 +553,16 @@ private StorableCdtVariables loadMacrosFromStream(InputStream stream, boolean re\n \n \tprivate ByteArrayOutputStream storeMacrosToStream(StorableCdtVariables macros) throws CoreException {\n \t\ttry {\n-\t\t\tDocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n-\t\t\tDocumentBuilder builder = factory.newDocumentBuilder();\n+\t\t\tDocumentBuilder builder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tDocument document = builder.newDocument();\n \n \t\t\tElement rootElement = document.createElement(StorableCdtVariables.MACROS_ELEMENT_NAME);\n \t\t\tdocument.appendChild(rootElement);\n \t\t\tICStorageElement storageElement = new XmlStorageElement(rootElement);\n \t\t\tmacros.serialize(storageElement);\n \n-\t\t\tTransformer transformer = TransformerFactory.newInstance().newTransformer();\n+\t\t\tTransformer transformer = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE()\n+\t\t\t\t\t.newTransformer();\n \t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n \t\t\ttransformer.setOutputProperty(OutputKeys.ENCODING, \"UTF-8\"); //$NON-NLS-1$\n \t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$",
    "function_modified_lines": {
      "added": [
        "import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n"
      ],
      "deleted": [
        "import javax.xml.parsers.DocumentBuilderFactory;\n",
        "import javax.xml.transform.TransformerFactory;\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "In Eclipse IDE versions < 2023-09 (4.29) some files with xml content are parsed vulnerable against all sorts of XXE attacks. The user just needs to open any evil project or update an open project with a vulnerable file (for example for review a foreign repository or patch).\n",
    "id": 12865
  },
  {
    "cve_id": "CVE-2023-4218",
    "code_before_change": "{\n\t\t\tDocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n\t\t\tDocumentBuilder builder = factory.newDocumentBuilder();\n\t\t\tDocument document = builder.newDocument();\n\n\t\t\tElement rootElement = document.createElement(StorableCdtVariables.MACROS_ELEMENT_NAME);\n\t\t\tdocument.appendChild(rootElement);\n\t\t\tICStorageElement storageElement = new XmlStorageElement(rootElement);\n\t\t\tmacros.serialize(storageElement);\n\n\t\t\tTransformer transformer = TransformerFactory.newInstance().newTransformer();\n\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\t\ttransformer.setOutputProperty(OutputKeys.ENCODING, \"UTF-8\"); //$NON-NLS-1$\n\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\t\t\tDOMSource source = new DOMSource(document);\n\n\t\t\tByteArrayOutputStream stream = new ByteArrayOutputStream();\n\t\t\tStreamResult result = new StreamResult(stream);\n\n\t\t\ttransformer.transform(source, result);\n\t\t\treturn stream;\n\t\t}",
    "code_after_change": "{\n\t\t\tDocumentBuilder builder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n\t\t\tDocument document = builder.newDocument();\n\n\t\t\tElement rootElement = document.createElement(StorableCdtVariables.MACROS_ELEMENT_NAME);\n\t\t\tdocument.appendChild(rootElement);\n\t\t\tICStorageElement storageElement = new XmlStorageElement(rootElement);\n\t\t\tmacros.serialize(storageElement);\n\n\t\t\tTransformer transformer = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE()\n\t\t\t\t\t.newTransformer();\n\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\t\ttransformer.setOutputProperty(OutputKeys.ENCODING, \"UTF-8\"); //$NON-NLS-1$\n\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\t\t\tDOMSource source = new DOMSource(document);\n\n\t\t\tByteArrayOutputStream stream = new ByteArrayOutputStream();\n\t\t\tStreamResult result = new StreamResult(stream);\n\n\t\t\ttransformer.transform(source, result);\n\t\t\treturn stream;\n\t\t}",
    "patch": "@@ -25,20 +25,19 @@\n import java.util.Set;\n \n import javax.xml.parsers.DocumentBuilder;\n-import javax.xml.parsers.DocumentBuilderFactory;\n import javax.xml.parsers.ParserConfigurationException;\n import javax.xml.transform.OutputKeys;\n import javax.xml.transform.Transformer;\n import javax.xml.transform.TransformerConfigurationException;\n import javax.xml.transform.TransformerException;\n-import javax.xml.transform.TransformerFactory;\n import javax.xml.transform.dom.DOMSource;\n import javax.xml.transform.stream.StreamResult;\n \n import org.eclipse.cdt.core.CCorePlugin;\n import org.eclipse.cdt.core.cdtvariables.CdtVariableException;\n import org.eclipse.cdt.core.cdtvariables.ICdtVariable;\n import org.eclipse.cdt.core.settings.model.ICStorageElement;\n+import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n import org.eclipse.cdt.internal.core.settings.model.CConfigurationSpecSettings;\n import org.eclipse.cdt.internal.core.settings.model.ExceptionFactory;\n import org.eclipse.cdt.internal.core.settings.model.IInternalCCfgInfo;\n@@ -94,7 +93,7 @@ private StorableCdtVariables getStorableMacros(int contextType, Object contextDa\n \t}\n \n \tprivate UserDefinedVariableSupplier() {\n-\t\tfListeners = Collections.synchronizedSet(new HashSet<ICdtVariableChangeListener>());\n+\t\tfListeners = Collections.synchronizedSet(new HashSet<>());\n \t}\n \n \tpublic static UserDefinedVariableSupplier getInstance() {\n@@ -532,7 +531,7 @@ protected void storeWorkspaceMacros(StorableCdtVariables macros, boolean force)\n \n \tprivate StorableCdtVariables loadMacrosFromStream(InputStream stream, boolean readOnly) {\n \t\ttry {\n-\t\t\tDocumentBuilder parser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n+\t\t\tDocumentBuilder parser = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tInputSource inputSource = new InputSource(stream);\n \t\t\tDocument document = parser.parse(inputSource);\n \t\t\tElement rootElement = document.getDocumentElement();\n@@ -554,16 +553,16 @@ private StorableCdtVariables loadMacrosFromStream(InputStream stream, boolean re\n \n \tprivate ByteArrayOutputStream storeMacrosToStream(StorableCdtVariables macros) throws CoreException {\n \t\ttry {\n-\t\t\tDocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n-\t\t\tDocumentBuilder builder = factory.newDocumentBuilder();\n+\t\t\tDocumentBuilder builder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tDocument document = builder.newDocument();\n \n \t\t\tElement rootElement = document.createElement(StorableCdtVariables.MACROS_ELEMENT_NAME);\n \t\t\tdocument.appendChild(rootElement);\n \t\t\tICStorageElement storageElement = new XmlStorageElement(rootElement);\n \t\t\tmacros.serialize(storageElement);\n \n-\t\t\tTransformer transformer = TransformerFactory.newInstance().newTransformer();\n+\t\t\tTransformer transformer = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE()\n+\t\t\t\t\t.newTransformer();\n \t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n \t\t\ttransformer.setOutputProperty(OutputKeys.ENCODING, \"UTF-8\"); //$NON-NLS-1$\n \t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$",
    "function_modified_lines": {
      "added": [
        "\t\t\tDocumentBuilder builder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n",
        "\t\t\tTransformer transformer = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE()\n",
        "\t\t\t\t\t.newTransformer();\n"
      ],
      "deleted": [
        "\t\t\tDocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n",
        "\t\t\tDocumentBuilder builder = factory.newDocumentBuilder();\n",
        "\t\t\tTransformer transformer = TransformerFactory.newInstance().newTransformer();\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "In Eclipse IDE versions < 2023-09 (4.29) some files with xml content are parsed vulnerable against all sorts of XXE attacks. The user just needs to open any evil project or update an open project with a vulnerable file (for example for review a foreign repository or patch).\n",
    "id": 12866
  },
  {
    "cve_id": "CVE-2023-4218",
    "code_before_change": "{\n\t\tDocument d;\n\t\ttry {\n\t\t\td = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n\t\t} catch (ParserConfigurationException e) {\n\t\t\tTemplateEngineUtil.log(e);\n\t\t\treturn xmlFile;\n\t\t}\n\t\tNode rootElement = d.appendChild(d.createElement(\"SharedRoot\")); //$NON-NLS-1$\n\t\tElement element = (Element) rootElement.appendChild(d.createElement(\"SharedProperty\")); //$NON-NLS-1$\n\t\telement.setAttribute(TemplateEngineHelper.ID, \"\"); //$NON-NLS-1$\n\t\telement.setAttribute(TemplateEngineHelper.VALUE, \"\"); //$NON-NLS-1$\n\n\t\tDOMSource domSource = new DOMSource(d);\n\t\tTransformerFactory transFactory = TransformerFactory.newInstance();\n\n\t\ttry {\n\t\t\tFileOutputStream fos = null;\n\t\t\ttry {\n\t\t\t\tfos = new FileOutputStream(xmlFile);\n\t\t\t\tResult fileResult = new StreamResult(fos);\n\t\t\t\ttransFactory.newTransformer().transform(domSource, fileResult);\n\t\t\t} finally {\n\t\t\t\tif (fos != null) {\n\t\t\t\t\tfos.close();\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException ioe) {\n\t\t\tTemplateEngineUtil.log(ioe);\n\t\t} catch (TransformerConfigurationException tce) {\n\t\t\tTemplateEngineUtil.log(tce);\n\t\t} catch (TransformerException te) {\n\t\t\tTemplateEngineUtil.log(te);\n\t\t}\n\t\treturn xmlFile;\n\t}",
    "code_after_change": "{\n\t\tDocument d;\n\t\ttry {\n\t\t\td = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE().newDocument();\n\t\t} catch (ParserConfigurationException e) {\n\t\t\tTemplateEngineUtil.log(e);\n\t\t\treturn xmlFile;\n\t\t}\n\t\tNode rootElement = d.appendChild(d.createElement(\"SharedRoot\")); //$NON-NLS-1$\n\t\tElement element = (Element) rootElement.appendChild(d.createElement(\"SharedProperty\")); //$NON-NLS-1$\n\t\telement.setAttribute(TemplateEngineHelper.ID, \"\"); //$NON-NLS-1$\n\t\telement.setAttribute(TemplateEngineHelper.VALUE, \"\"); //$NON-NLS-1$\n\n\t\tDOMSource domSource = new DOMSource(d);\n\t\tTransformerFactory transFactory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n\n\t\ttry {\n\t\t\tFileOutputStream fos = null;\n\t\t\ttry {\n\t\t\t\tfos = new FileOutputStream(xmlFile);\n\t\t\t\tResult fileResult = new StreamResult(fos);\n\t\t\t\ttransFactory.newTransformer().transform(domSource, fileResult);\n\t\t\t} finally {\n\t\t\t\tif (fos != null) {\n\t\t\t\t\tfos.close();\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException ioe) {\n\t\t\tTemplateEngineUtil.log(ioe);\n\t\t} catch (TransformerConfigurationException tce) {\n\t\t\tTemplateEngineUtil.log(tce);\n\t\t} catch (TransformerException te) {\n\t\t\tTemplateEngineUtil.log(te);\n\t\t}\n\t\treturn xmlFile;\n\t}",
    "patch": "@@ -20,7 +20,6 @@\n import java.util.List;\n import java.util.Map;\n \n-import javax.xml.parsers.DocumentBuilderFactory;\n import javax.xml.parsers.ParserConfigurationException;\n import javax.xml.transform.Result;\n import javax.xml.transform.TransformerConfigurationException;\n@@ -29,6 +28,7 @@\n import javax.xml.transform.dom.DOMSource;\n import javax.xml.transform.stream.StreamResult;\n \n+import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n import org.w3c.dom.Document;\n import org.w3c.dom.Element;\n import org.w3c.dom.Node;\n@@ -126,7 +126,7 @@ private void initSharedDefaults() {\n \t\t\tif (length == 0) {\n \t\t\t\tparsedXML = createDefaultXMLFormat(parsedXML);\n \t\t\t}\n-\t\t\tdocument = DocumentBuilderFactory.newInstance().newDocumentBuilder()\n+\t\t\tdocument = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE()\n \t\t\t\t\t.parse(parsedXML.toURI().toURL().openStream());\n \t\t} catch (Exception exp) {\n \t\t\tTemplateEngineUtil.log(exp);\n@@ -198,7 +198,7 @@ public void addToBackEndStorage(String name, String value) {\n \t */\n \tpublic void updateToBackEndStorage(String updateName, String updateValue) {\n \t\ttry {\n-\t\t\tdocument = DocumentBuilderFactory.newInstance().newDocumentBuilder()\n+\t\t\tdocument = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE()\n \t\t\t\t\t.parse(parsedXML.toURI().toURL().openStream());\n \t\t} catch (Exception exp) {\n \t\t\tTemplateEngineUtil.log(exp);\n@@ -227,7 +227,7 @@ public void updateToBackEndStorage(String updateName, String updateValue) {\n \t */\n \tpublic void deleteBackEndStorage(String[] deleteName) {\n \t\ttry {\n-\t\t\tdocument = DocumentBuilderFactory.newInstance().newDocumentBuilder()\n+\t\t\tdocument = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE()\n \t\t\t\t\t.parse(parsedXML.toURI().toURL().openStream());\n \t\t} catch (Exception exp) {\n \t\t\tTemplateEngineUtil.log(exp);\n@@ -261,7 +261,7 @@ public void deleteBackEndStorage(String[] deleteName) {\n \tprivate File createDefaultXMLFormat(File xmlFile) {\n \t\tDocument d;\n \t\ttry {\n-\t\t\td = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n+\t\t\td = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE().newDocument();\n \t\t} catch (ParserConfigurationException e) {\n \t\t\tTemplateEngineUtil.log(e);\n \t\t\treturn xmlFile;\n@@ -272,7 +272,7 @@ private File createDefaultXMLFormat(File xmlFile) {\n \t\telement.setAttribute(TemplateEngineHelper.VALUE, \"\"); //$NON-NLS-1$\n \n \t\tDOMSource domSource = new DOMSource(d);\n-\t\tTransformerFactory transFactory = TransformerFactory.newInstance();\n+\t\tTransformerFactory transFactory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n \n \t\ttry {\n \t\t\tFileOutputStream fos = null;\n@@ -303,7 +303,7 @@ private File createDefaultXMLFormat(File xmlFile) {\n \tprivate void generateSharedXML(File xmlFile) {\n \t\tDocument d;\n \t\ttry {\n-\t\t\td = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n+\t\t\td = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE().newDocument();\n \t\t} catch (ParserConfigurationException e) {\n \t\t\tTemplateEngineUtil.log(e);\n \t\t\treturn;\n@@ -317,7 +317,7 @@ private void generateSharedXML(File xmlFile) {\n \t\t}\n \n \t\tDOMSource domSource = new DOMSource(d);\n-\t\tTransformerFactory transFactory = TransformerFactory.newInstance();\n+\t\tTransformerFactory transFactory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n \t\tResult fileResult = new StreamResult(xmlFile);\n \t\ttry {\n \t\t\ttransFactory.newTransformer().transform(domSource, fileResult);",
    "function_modified_lines": {
      "added": [
        "\t\t\td = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE().newDocument();\n",
        "\t\tTransformerFactory transFactory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n"
      ],
      "deleted": [
        "\t\t\td = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n",
        "\t\tTransformerFactory transFactory = TransformerFactory.newInstance();\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "In Eclipse IDE versions < 2023-09 (4.29) some files with xml content are parsed vulnerable against all sorts of XXE attacks. The user just needs to open any evil project or update an open project with a vulnerable file (for example for review a foreign repository or patch).\n",
    "id": 12868
  },
  {
    "cve_id": "CVE-2023-4218",
    "code_before_change": "{\n\t\tDocument d;\n\t\ttry {\n\t\t\td = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n\t\t} catch (ParserConfigurationException e) {\n\t\t\tTemplateEngineUtil.log(e);\n\t\t\treturn;\n\t\t}\n\t\tNode rootElement = d.appendChild(d.createElement(\"SharedRoot\")); //$NON-NLS-1$\n\n\t\tfor (String key : sharedDefaultsMap.keySet()) {\n\t\t\tElement element = (Element) rootElement.appendChild(d.createElement(\"SharedProperty\")); //$NON-NLS-1$\n\t\t\telement.setAttribute(TemplateEngineHelper.ID, key);\n\t\t\telement.setAttribute(TemplateEngineHelper.VALUE, sharedDefaultsMap.get(key));\n\t\t}\n\n\t\tDOMSource domSource = new DOMSource(d);\n\t\tTransformerFactory transFactory = TransformerFactory.newInstance();\n\t\tResult fileResult = new StreamResult(xmlFile);\n\t\ttry {\n\t\t\ttransFactory.newTransformer().transform(domSource, fileResult);\n\t\t} catch (Throwable t) {\n\t\t\tTemplateEngineUtil.log(t);\n\t\t}\n\t}",
    "code_after_change": "{\n\t\tDocument d;\n\t\ttry {\n\t\t\td = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE().newDocument();\n\t\t} catch (ParserConfigurationException e) {\n\t\t\tTemplateEngineUtil.log(e);\n\t\t\treturn;\n\t\t}\n\t\tNode rootElement = d.appendChild(d.createElement(\"SharedRoot\")); //$NON-NLS-1$\n\n\t\tfor (String key : sharedDefaultsMap.keySet()) {\n\t\t\tElement element = (Element) rootElement.appendChild(d.createElement(\"SharedProperty\")); //$NON-NLS-1$\n\t\t\telement.setAttribute(TemplateEngineHelper.ID, key);\n\t\t\telement.setAttribute(TemplateEngineHelper.VALUE, sharedDefaultsMap.get(key));\n\t\t}\n\n\t\tDOMSource domSource = new DOMSource(d);\n\t\tTransformerFactory transFactory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n\t\tResult fileResult = new StreamResult(xmlFile);\n\t\ttry {\n\t\t\ttransFactory.newTransformer().transform(domSource, fileResult);\n\t\t} catch (Throwable t) {\n\t\t\tTemplateEngineUtil.log(t);\n\t\t}\n\t}",
    "patch": "@@ -20,7 +20,6 @@\n import java.util.List;\n import java.util.Map;\n \n-import javax.xml.parsers.DocumentBuilderFactory;\n import javax.xml.parsers.ParserConfigurationException;\n import javax.xml.transform.Result;\n import javax.xml.transform.TransformerConfigurationException;\n@@ -29,6 +28,7 @@\n import javax.xml.transform.dom.DOMSource;\n import javax.xml.transform.stream.StreamResult;\n \n+import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n import org.w3c.dom.Document;\n import org.w3c.dom.Element;\n import org.w3c.dom.Node;\n@@ -126,7 +126,7 @@ private void initSharedDefaults() {\n \t\t\tif (length == 0) {\n \t\t\t\tparsedXML = createDefaultXMLFormat(parsedXML);\n \t\t\t}\n-\t\t\tdocument = DocumentBuilderFactory.newInstance().newDocumentBuilder()\n+\t\t\tdocument = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE()\n \t\t\t\t\t.parse(parsedXML.toURI().toURL().openStream());\n \t\t} catch (Exception exp) {\n \t\t\tTemplateEngineUtil.log(exp);\n@@ -198,7 +198,7 @@ public void addToBackEndStorage(String name, String value) {\n \t */\n \tpublic void updateToBackEndStorage(String updateName, String updateValue) {\n \t\ttry {\n-\t\t\tdocument = DocumentBuilderFactory.newInstance().newDocumentBuilder()\n+\t\t\tdocument = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE()\n \t\t\t\t\t.parse(parsedXML.toURI().toURL().openStream());\n \t\t} catch (Exception exp) {\n \t\t\tTemplateEngineUtil.log(exp);\n@@ -227,7 +227,7 @@ public void updateToBackEndStorage(String updateName, String updateValue) {\n \t */\n \tpublic void deleteBackEndStorage(String[] deleteName) {\n \t\ttry {\n-\t\t\tdocument = DocumentBuilderFactory.newInstance().newDocumentBuilder()\n+\t\t\tdocument = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE()\n \t\t\t\t\t.parse(parsedXML.toURI().toURL().openStream());\n \t\t} catch (Exception exp) {\n \t\t\tTemplateEngineUtil.log(exp);\n@@ -261,7 +261,7 @@ public void deleteBackEndStorage(String[] deleteName) {\n \tprivate File createDefaultXMLFormat(File xmlFile) {\n \t\tDocument d;\n \t\ttry {\n-\t\t\td = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n+\t\t\td = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE().newDocument();\n \t\t} catch (ParserConfigurationException e) {\n \t\t\tTemplateEngineUtil.log(e);\n \t\t\treturn xmlFile;\n@@ -272,7 +272,7 @@ private File createDefaultXMLFormat(File xmlFile) {\n \t\telement.setAttribute(TemplateEngineHelper.VALUE, \"\"); //$NON-NLS-1$\n \n \t\tDOMSource domSource = new DOMSource(d);\n-\t\tTransformerFactory transFactory = TransformerFactory.newInstance();\n+\t\tTransformerFactory transFactory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n \n \t\ttry {\n \t\t\tFileOutputStream fos = null;\n@@ -303,7 +303,7 @@ private File createDefaultXMLFormat(File xmlFile) {\n \tprivate void generateSharedXML(File xmlFile) {\n \t\tDocument d;\n \t\ttry {\n-\t\t\td = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n+\t\t\td = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE().newDocument();\n \t\t} catch (ParserConfigurationException e) {\n \t\t\tTemplateEngineUtil.log(e);\n \t\t\treturn;\n@@ -317,7 +317,7 @@ private void generateSharedXML(File xmlFile) {\n \t\t}\n \n \t\tDOMSource domSource = new DOMSource(d);\n-\t\tTransformerFactory transFactory = TransformerFactory.newInstance();\n+\t\tTransformerFactory transFactory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n \t\tResult fileResult = new StreamResult(xmlFile);\n \t\ttry {\n \t\t\ttransFactory.newTransformer().transform(domSource, fileResult);",
    "function_modified_lines": {
      "added": [
        "\t\t\td = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE().newDocument();\n",
        "\t\tTransformerFactory transFactory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n"
      ],
      "deleted": [
        "\t\t\td = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n",
        "\t\tTransformerFactory transFactory = TransformerFactory.newInstance();\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "In Eclipse IDE versions < 2023-09 (4.29) some files with xml content are parsed vulnerable against all sorts of XXE attacks. The user just needs to open any evil project or update an open project with a vulnerable file (for example for review a foreign repository or patch).\n",
    "id": 12869
  },
  {
    "cve_id": "CVE-2023-4218",
    "code_before_change": "/*******************************************************************************\n * Copyright (c) 2009, 2013 Andrew Gvozdev (Quoin Inc.).\n *\n * This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n *\n * Contributors:\n *     Andrew Gvozdev (Quoin Inc.)\n *******************************************************************************/\npackage org.eclipse.cdt.internal.core;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URI;\nimport java.util.Arrays;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.eclipse.cdt.core.CCorePlugin;\nimport org.eclipse.cdt.core.resources.ResourcesUtil;\nimport org.eclipse.cdt.internal.core.model.Util;\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.runtime.CoreException;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\n/**\n * XML utilities.\n *\n */\npublic class XmlUtil {\n\tprivate static final String ENCODING_UTF_8 = \"UTF-8\"; //$NON-NLS-1$\n\tprivate static final String EOL_XML = \"\\n\"; //$NON-NLS-1$\n\tprivate static final String DEFAULT_INDENT = \"\\t\"; //$NON-NLS-1$\n\tprivate static String LINE_SEPARATOR = System.getProperty(\"line.separator\"); //$NON-NLS-1$\n\n\t/**\n\t * Convenience method to create new XML DOM Document.\n\t *\n\t * @return a new instance of a DOM {@link Document}.\n\t * @throws ParserConfigurationException in case of a problem retrieving {@link DocumentBuilder}.\n\t */\n\tpublic static Document newDocument() throws ParserConfigurationException {\n\t\tDocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n\t\treturn builder.newDocument();\n\t}\n",
    "code_after_change": "/*******************************************************************************\n * Copyright (c) 2009, 2013 Andrew Gvozdev (Quoin Inc.).\n *\n * This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n *\n * Contributors:\n *     Andrew Gvozdev (Quoin Inc.)\n *******************************************************************************/\npackage org.eclipse.cdt.internal.core;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URI;\nimport java.util.Arrays;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.eclipse.cdt.core.CCorePlugin;\nimport org.eclipse.cdt.core.resources.ResourcesUtil;\nimport org.eclipse.cdt.internal.core.model.Util;\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.runtime.CoreException;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\n/**\n * XML utilities.\n *\n */\npublic class XmlUtil {\n\tprivate static final String ENCODING_UTF_8 = \"UTF-8\"; //$NON-NLS-1$\n\tprivate static final String EOL_XML = \"\\n\"; //$NON-NLS-1$\n\tprivate static final String DEFAULT_INDENT = \"\\t\"; //$NON-NLS-1$\n\tprivate static String LINE_SEPARATOR = System.getProperty(\"line.separator\"); //$NON-NLS-1$\n\n\t/**\n\t * Convenience method to create new XML DOM Document.\n\t *\n\t * @return a new instance of a DOM {@link Document}.\n\t * @throws ParserConfigurationException in case of a problem retrieving {@link DocumentBuilder}.\n\t */\n\tpublic static Document newDocument() throws ParserConfigurationException {\n\t\tDocumentBuilder builder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n\t\treturn builder.newDocument();\n\t}\n\n\t/**\n\t * Convenience method to retrieve value of a node.",
    "patch": "@@ -25,12 +25,10 @@\n import java.util.Arrays;\n \n import javax.xml.parsers.DocumentBuilder;\n-import javax.xml.parsers.DocumentBuilderFactory;\n import javax.xml.parsers.ParserConfigurationException;\n import javax.xml.transform.OutputKeys;\n import javax.xml.transform.Transformer;\n import javax.xml.transform.TransformerException;\n-import javax.xml.transform.TransformerFactory;\n import javax.xml.transform.dom.DOMSource;\n import javax.xml.transform.stream.StreamResult;\n \n@@ -63,7 +61,7 @@ public class XmlUtil {\n \t * @throws ParserConfigurationException in case of a problem retrieving {@link DocumentBuilder}.\n \t */\n \tpublic static Document newDocument() throws ParserConfigurationException {\n-\t\tDocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n+\t\tDocumentBuilder builder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\treturn builder.newDocument();\n \t}\n \n@@ -227,7 +225,7 @@ private static void prettyFormat(Node node, String indentLevel, String indent) {\n \t */\n \tprivate static Document loadXml(InputStream xmlStream) throws CoreException {\n \t\ttry {\n-\t\t\tDocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n+\t\t\tDocumentBuilder builder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\treturn builder.parse(xmlStream);\n \t\t} catch (Exception e) {\n \t\t\tthrow new CoreException(CCorePlugin.createStatus(Messages.XmlUtil_InternalErrorLoading, e));\n@@ -370,7 +368,8 @@ private static FileOutputStream getFileOutputStreamWorkaround(java.io.File store\n \tprivate static byte[] toByteArray(Document doc) throws CoreException {\n \t\ttry {\n \t\t\tByteArrayOutputStream stream = new ByteArrayOutputStream();\n-\t\t\tTransformer transformer = TransformerFactory.newInstance().newTransformer();\n+\t\t\tTransformer transformer = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE()\n+\t\t\t\t\t.newTransformer();\n \t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n \t\t\ttransformer.setOutputProperty(OutputKeys.ENCODING, ENCODING_UTF_8);\n \t\t\t// Indentation is done with XmlUtil.prettyFormat(doc).",
    "function_modified_lines": {
      "added": [],
      "deleted": [
        "import javax.xml.parsers.DocumentBuilderFactory;\n",
        "import javax.xml.transform.TransformerFactory;\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "In Eclipse IDE versions < 2023-09 (4.29) some files with xml content are parsed vulnerable against all sorts of XXE attacks. The user just needs to open any evil project or update an open project with a vulnerable file (for example for review a foreign repository or patch).\n",
    "id": 12870
  },
  {
    "cve_id": "CVE-2023-4218",
    "code_before_change": "{\n\t\t\tDocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n\t\t\tDocumentBuilder builder = factory.newDocumentBuilder();\n\t\t\tDocument document = builder.newDocument();\n\n\t\t\tElement el = document.createElement(StorableEnvironment.ENVIRONMENT_ELEMENT_NAME);\n\t\t\tdocument.appendChild(el);\n\t\t\tXmlStorageElement rootElement = new XmlStorageElement(el);\n\t\t\tenv.serialize(rootElement);\n\n\t\t\tTransformer transformer = TransformerFactory.newInstance().newTransformer();\n\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\t\ttransformer.setOutputProperty(OutputKeys.ENCODING, \"UTF-8\"); //$NON-NLS-1$\n\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\t\t\tDOMSource source = new DOMSource(document);\n\n\t\t\tByteArrayOutputStream stream = new ByteArrayOutputStream();\n\t\t\tStreamResult result = new StreamResult(stream);\n\n\t\t\ttransformer.transform(source, result);\n\t\t\treturn stream;\n\t\t}",
    "code_after_change": "{\n\t\t\tDocumentBuilder builder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n\t\t\tDocument document = builder.newDocument();\n\n\t\t\tElement el = document.createElement(StorableEnvironment.ENVIRONMENT_ELEMENT_NAME);\n\t\t\tdocument.appendChild(el);\n\t\t\tXmlStorageElement rootElement = new XmlStorageElement(el);\n\t\t\tenv.serialize(rootElement);\n\n\t\t\tTransformer transformer = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE()\n\t\t\t\t\t.newTransformer();\n\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\t\ttransformer.setOutputProperty(OutputKeys.ENCODING, \"UTF-8\"); //$NON-NLS-1$\n\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\t\t\tDOMSource source = new DOMSource(document);\n\n\t\t\tByteArrayOutputStream stream = new ByteArrayOutputStream();\n\t\t\tStreamResult result = new StreamResult(stream);\n\n\t\t\ttransformer.transform(source, result);\n\t\t\treturn stream;\n\t\t}",
    "patch": "@@ -20,18 +20,17 @@\n import java.io.UnsupportedEncodingException;\n \n import javax.xml.parsers.DocumentBuilder;\n-import javax.xml.parsers.DocumentBuilderFactory;\n import javax.xml.parsers.ParserConfigurationException;\n import javax.xml.transform.OutputKeys;\n import javax.xml.transform.Transformer;\n import javax.xml.transform.TransformerConfigurationException;\n import javax.xml.transform.TransformerException;\n-import javax.xml.transform.TransformerFactory;\n import javax.xml.transform.dom.DOMSource;\n import javax.xml.transform.stream.StreamResult;\n \n import org.eclipse.cdt.core.CCorePlugin;\n import org.eclipse.cdt.core.settings.model.ICStorageElement;\n+import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n import org.eclipse.cdt.internal.core.settings.model.xml.XmlStorageElement;\n import org.eclipse.core.runtime.CoreException;\n import org.eclipse.core.runtime.IStatus;\n@@ -148,7 +147,7 @@ static ICStorageElement environmentStorageFromString(String env) {\n \t\tif (env == null)\n \t\t\treturn null;\n \t\ttry {\n-\t\t\tDocumentBuilder parser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n+\t\t\tDocumentBuilder parser = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tInputSource inputSource = new InputSource(new ByteArrayInputStream(env.getBytes()));\n \t\t\tDocument document = parser.parse(inputSource);\n \t\t\tElement el = document.getDocumentElement();\n@@ -170,16 +169,16 @@ static ICStorageElement environmentStorageFromString(String env) {\n \n \tprivate ByteArrayOutputStream storeEnvironmentToStream(StorableEnvironment env) throws CoreException {\n \t\ttry {\n-\t\t\tDocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n-\t\t\tDocumentBuilder builder = factory.newDocumentBuilder();\n+\t\t\tDocumentBuilder builder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tDocument document = builder.newDocument();\n \n \t\t\tElement el = document.createElement(StorableEnvironment.ENVIRONMENT_ELEMENT_NAME);\n \t\t\tdocument.appendChild(el);\n \t\t\tXmlStorageElement rootElement = new XmlStorageElement(el);\n \t\t\tenv.serialize(rootElement);\n \n-\t\t\tTransformer transformer = TransformerFactory.newInstance().newTransformer();\n+\t\t\tTransformer transformer = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE()\n+\t\t\t\t\t.newTransformer();\n \t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n \t\t\ttransformer.setOutputProperty(OutputKeys.ENCODING, \"UTF-8\"); //$NON-NLS-1$\n \t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$",
    "function_modified_lines": {
      "added": [
        "\t\t\tDocumentBuilder builder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n",
        "\t\t\tTransformer transformer = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE()\n",
        "\t\t\t\t\t.newTransformer();\n"
      ],
      "deleted": [
        "\t\t\tDocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n",
        "\t\t\tDocumentBuilder builder = factory.newDocumentBuilder();\n",
        "\t\t\tTransformer transformer = TransformerFactory.newInstance().newTransformer();\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "In Eclipse IDE versions < 2023-09 (4.29) some files with xml content are parsed vulnerable against all sorts of XXE attacks. The user just needs to open any evil project or update an open project with a vulnerable file (for example for review a foreign repository or patch).\n",
    "id": 12871
  },
  {
    "cve_id": "CVE-2023-4218",
    "code_before_change": "try {\n\t\t\tInputStream stream = new FileInputStream(fname);\n\t\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(stream));\n\t\t\tInputSource src = new InputSource(reader);\n\t\t\tDocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n\t\t\tdoc = builder.parse(src);\n\t\t\tElement e = doc.getDocumentElement();\n\t\t\tif (NODE_HEAD.equals(e.getNodeName())) {\n\t\t\t\tNodeList list = e.getChildNodes();\n\t\t\t\tfor (int j = 0; j < list.getLength(); j++) {\n\t\t\t\t\tNode node = list.item(j);\n\t\t\t\t\tif (node.getNodeType() != Node.ELEMENT_NODE)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (NODE_BOOK.equals(node.getNodeName())) {\n\t\t\t\t\t\tchbl.add(new CHelpBook((Element) node));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (ParserConfigurationException e) {\n\t\t} catch (SAXException e) {\n\t\t} catch (IOException e) {\n\t\t}",
    "code_after_change": "try {\n\t\t\tInputStream stream = new FileInputStream(fname);\n\t\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(stream));\n\t\t\tInputSource src = new InputSource(reader);\n\t\t\tDocumentBuilder builder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n\t\t\tdoc = builder.parse(src);\n\t\t\tElement e = doc.getDocumentElement();\n\t\t\tif (NODE_HEAD.equals(e.getNodeName())) {\n\t\t\t\tNodeList list = e.getChildNodes();\n\t\t\t\tfor (int j = 0; j < list.getLength(); j++) {\n\t\t\t\t\tNode node = list.item(j);\n\t\t\t\t\tif (node.getNodeType() != Node.ELEMENT_NODE)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (NODE_BOOK.equals(node.getNodeName())) {\n\t\t\t\t\t\tchbl.add(new CHelpBook((Element) node));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tCUIPlugin.log(\"Failed to load helpbook in \" + pluginId, e); //$NON-NLS-1$\n\t\t}",
    "patch": "@@ -23,9 +23,9 @@\n import java.util.List;\n \n import javax.xml.parsers.DocumentBuilder;\n-import javax.xml.parsers.DocumentBuilderFactory;\n-import javax.xml.parsers.ParserConfigurationException;\n \n+import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n+import org.eclipse.cdt.ui.CUIPlugin;\n import org.eclipse.cdt.ui.ICHelpBook;\n import org.eclipse.cdt.ui.ICHelpProvider;\n import org.eclipse.cdt.ui.ICHelpResourceDescriptor;\n@@ -42,7 +42,6 @@\n import org.w3c.dom.Node;\n import org.w3c.dom.NodeList;\n import org.xml.sax.InputSource;\n-import org.xml.sax.SAXException;\n \n public class CHelpProvider implements ICHelpProvider {\n \n@@ -175,7 +174,7 @@ private void loadFile(IConfigurationElement el, ArrayList<ICHelpBook> chbl, Stri\n \t\t\tInputStream stream = new FileInputStream(fname);\n \t\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(stream));\n \t\t\tInputSource src = new InputSource(reader);\n-\t\t\tDocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n+\t\t\tDocumentBuilder builder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tdoc = builder.parse(src);\n \t\t\tElement e = doc.getDocumentElement();\n \t\t\tif (NODE_HEAD.equals(e.getNodeName())) {\n@@ -189,9 +188,8 @@ private void loadFile(IConfigurationElement el, ArrayList<ICHelpBook> chbl, Stri\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n-\t\t} catch (ParserConfigurationException e) {\n-\t\t} catch (SAXException e) {\n-\t\t} catch (IOException e) {\n+\t\t} catch (Exception e) {\n+\t\t\tCUIPlugin.log(\"Failed to load helpbook in \" + pluginId, e); //$NON-NLS-1$\n \t\t}\n \t}\n }",
    "function_modified_lines": {
      "added": [
        "\t\t\tDocumentBuilder builder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n",
        "\t\t} catch (Exception e) {\n",
        "\t\t\tCUIPlugin.log(\"Failed to load helpbook in \" + pluginId, e); //$NON-NLS-1$\n"
      ],
      "deleted": [
        "\t\t\tDocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n",
        "\t\t} catch (ParserConfigurationException e) {\n",
        "\t\t} catch (SAXException e) {\n",
        "\t\t} catch (IOException e) {\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "In Eclipse IDE versions < 2023-09 (4.29) some files with xml content are parsed vulnerable against all sorts of XXE attacks. The user just needs to open any evil project or update an open project with a vulnerable file (for example for review a foreign repository or patch).\n",
    "id": 12872
  },
  {
    "cve_id": "CVE-2023-4218",
    "code_before_change": "/*******************************************************************************\n * Copyright (c) 2008, 2012 IBM Corporation and others.\n *\n * This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n *\n * Contributors:\n *     IBM Corporation - initial API and implementation\n *******************************************************************************/\npackage org.eclipse.cdt.internal.ui.wizards.settingswizards;\n\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.net.URI;\nimport java.util.List;\n\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.sax.SAXTransformerFactory;\nimport javax.xml.transform.sax.TransformerHandler;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.eclipse.cdt.core.resources.ResourcesUtil;\nimport org.eclipse.cdt.core.settings.model.ICConfigurationDescription;\nimport org.eclipse.cdt.core.settings.model.ICFolderDescription;\nimport org.eclipse.cdt.ui.CUIPlugin;\nimport org.eclipse.core.filesystem.URIUtil;\nimport org.eclipse.core.runtime.IPath;\nimport org.eclipse.core.runtime.Path;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.AttributesImpl;\n\n/**\n * Custom behavior for the Export wizard.\n *\n * @author Mike Kucera\n * @since 5.1\n *\n */\npublic class ProjectSettingsExportStrategy implements IProjectSettingsWizardPageStrategy {\n\n\tpublic static final String ROOT_ELEMENT = \"cdtprojectproperties\"; //$NON-NLS-1$\n\tpublic static final String SECTION_ELEMENT = \"section\"; //$NON-NLS-1$\n\tpublic static final String SECTION_NAME_ATTRIBUTE = \"name\"; //$NON-NLS-1$\n\n\tprivate static final String NONE = \"\"; //$NON-NLS-1$\n\tprivate static final String CDATA = \"CDATA\"; //$NON-NLS-1$\n\n\t@Override\n\tpublic String getMessage(MessageType type) {\n\t\tswitch (type) {\n\t\tcase TITLE:\n\t\t\treturn Messages.ProjectSettingsWizardPage_Export_title;\n\t\tcase MESSAGE:\n\t\t\treturn Messages.ProjectSettingsWizardPage_Export_message;\n\t\tcase CHECKBOX:\n\t\t\treturn Messages.ProjectSettingsWizardPage_Export_checkBox;\n\t\tcase FILE:\n\t\t\treturn Messages.ProjectSettingsWizardPage_Export_file;\n\t\tcase SETTINGS:\n\t\t\treturn Messages.ProjectSettingsWizardPage_Export_selectSettings;\n\t\tdefault:\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t@Override\n\tpublic void pageCreated(IProjectSettingsWizardPage page) {\n\t\t// do nothing\n\t}\n\n\t@Override\n\tpublic void fileSelected(IProjectSettingsWizardPage page) {\n\t\t// do nothing\n\t}\n\n\tprivate FileOutputStream getFileOutputStream(IProjectSettingsWizardPage page) throws IOException {\n\t\tIPath path = new Path(page.getDestinationFilePath());\n\t\tif (!IProjectSettingsWizardPage.FILENAME_EXTENSION.equals(path.getFileExtension()))\n\t\t\tpath.addFileExtension(IProjectSettingsWizardPage.FILENAME_EXTENSION);\n\n\t\treturn new FileOutputStream(path.toFile());\n\t}\n\n\t/**\n\t * Exports the selected project settings to an XML file.\n\t */\n\t@Override\n\tpublic boolean finish(IProjectSettingsWizardPage page) {\n\t\tSAXTransformerFactory factory = (SAXTransformerFactory) TransformerFactory.newInstance();\n\t\tTransformerHandler handler = null;\n\t\ttry {\n\t\t\thandler = factory.newTransformerHandler();\n\t\t} catch (TransformerConfigurationException e) {\n\t\t\tCUIPlugin.log(e);\n\t\t\tpage.showErrorDialog(Messages.ProjectSettingsExportStrategy_exportError,\n\t\t\t\t\tMessages.ProjectSettingsExportStrategy_exportFailed);\n\t\t\treturn false;\n\t\t}\n\n\t\t// gets a writer for the file that was selected by the user\n\t\tFileOutputStream outputStream;\n\t\ttry {\n\t\t\toutputStream = getFileOutputStream(page);\n\t\t} catch (IOException e) {\n\t\t\tpage.showErrorDialog(Messages.ProjectSettingsExportStrategy_fileOpenError,\n\t\t\t\t\tMessages.ProjectSettingsExportStrategy_couldNotOpen);\n\t\t\treturn false;\n\t\t}\n\n\t\t// write out the XML header\n\t\tTransformer transformer = handler.getTransformer();\n\t\ttransformer.setOutputProperty(OutputKeys.ENCODING, \"UTF-8\"); //$NON-NLS-1$\n\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\t\ttransformer.setOutputProperty(\"{http://xml.apache.org/xslt}indent-amount\", \"2\"); //$NON-NLS-1$ //$NON-NLS-2$\n\t\ttransformer.setOutputProperty(OutputKeys.DOCTYPE_PUBLIC, \"yes\"); //$NON-NLS-1$\n\n\t\t// stream the results to the writer as text\n\t\thandler.setResult(new StreamResult(outputStream));\n\n\t\tList<ISettingsProcessor> exporters = page.getSelectedSettingsProcessors();\n\n\t\tICConfigurationDescription config = page.getSelectedConfiguration();\n\t\tICFolderDescription projectRoot = config.getRootFolderDescription();\n\n\t\tboolean result = false;\n\t\ttry {\n\t\t\tAttributesImpl attributes = new AttributesImpl();\n\n\t\t\thandler.startDocument();\n\t\t\thandler.startElement(NONE, NONE, ROOT_ELEMENT, null);\n\n\t\t\tfor (ISettingsProcessor exporter : exporters) {\n\t\t\t\tattributes.clear();\n\t\t\t\tattributes.addAttribute(NONE, NONE, SECTION_NAME_ATTRIBUTE, CDATA, exporter.getSectionName());\n\t\t\t\thandler.startElement(NONE, NONE, SECTION_ELEMENT, attributes);\n\n\t\t\t\t// each exporter is responsible for writing out its own section of the file\n\t\t\t\texporter.writeSectionXML(projectRoot, handler);\n\n\t\t\t\thandler.endElement(NONE, NONE, SECTION_ELEMENT);\n\t\t\t}\n\n\t\t\thandler.endElement(NONE, NONE, ROOT_ELEMENT);\n\t\t\thandler.endDocument();\n\n\t\t\tresult = true;\n\t\t} catch (SAXException e) {\n\t\t\tCUIPlugin.log(e);\n\t\t\tpage.showErrorDialog(Messages.ProjectSettingsExportStrategy_exportError,\n\t\t\t\t\tMessages.ProjectSettingsExportStrategy_xmlError);\n\t\t\tresult = false;\n\t\t} catch (SettingsImportExportException e) {\n\t\t\tCUIPlugin.log(e);\n\t\t\tpage.showErrorDialog(Messages.ProjectSettingsExportStrategy_fileOpenError,\n\t\t\t\t\tMessages.ProjectSettingsExportStrategy_couldNotOpen);\n\t\t\tresult = false;\n\t\t}\n\n\t\tURI uri = URIUtil.toURI(page.getDestinationFilePath());\n\t\tResourcesUtil.refreshWorkspaceFiles(uri);\n\n\t\treturn result;\n\t}\n\n}\n",
    "code_after_change": "/*******************************************************************************\n * Copyright (c) 2008, 2012 IBM Corporation and others.\n *\n * This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n *\n * Contributors:\n *     IBM Corporation - initial API and implementation\n *******************************************************************************/\npackage org.eclipse.cdt.internal.ui.wizards.settingswizards;\n\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.net.URI;\nimport java.util.List;\n\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.sax.SAXTransformerFactory;\nimport javax.xml.transform.sax.TransformerHandler;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.eclipse.cdt.core.resources.ResourcesUtil;\nimport org.eclipse.cdt.core.settings.model.ICConfigurationDescription;\nimport org.eclipse.cdt.core.settings.model.ICFolderDescription;\nimport org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\nimport org.eclipse.cdt.ui.CUIPlugin;\nimport org.eclipse.core.filesystem.URIUtil;\nimport org.eclipse.core.runtime.IPath;\nimport org.eclipse.core.runtime.Path;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.AttributesImpl;\n\n/**\n * Custom behavior for the Export wizard.\n *\n * @author Mike Kucera\n * @since 5.1\n *\n */\npublic class ProjectSettingsExportStrategy implements IProjectSettingsWizardPageStrategy {\n\n\tpublic static final String ROOT_ELEMENT = \"cdtprojectproperties\"; //$NON-NLS-1$\n\tpublic static final String SECTION_ELEMENT = \"section\"; //$NON-NLS-1$\n\tpublic static final String SECTION_NAME_ATTRIBUTE = \"name\"; //$NON-NLS-1$\n\n\tprivate static final String NONE = \"\"; //$NON-NLS-1$\n\tprivate static final String CDATA = \"CDATA\"; //$NON-NLS-1$\n\n\t@Override\n\tpublic String getMessage(MessageType type) {\n\t\tswitch (type) {\n\t\tcase TITLE:\n\t\t\treturn Messages.ProjectSettingsWizardPage_Export_title;\n\t\tcase MESSAGE:\n\t\t\treturn Messages.ProjectSettingsWizardPage_Export_message;\n\t\tcase CHECKBOX:\n\t\t\treturn Messages.ProjectSettingsWizardPage_Export_checkBox;\n\t\tcase FILE:\n\t\t\treturn Messages.ProjectSettingsWizardPage_Export_file;\n\t\tcase SETTINGS:\n\t\t\treturn Messages.ProjectSettingsWizardPage_Export_selectSettings;\n\t\tdefault:\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t@Override\n\tpublic void pageCreated(IProjectSettingsWizardPage page) {\n\t\t// do nothing\n\t}\n\n\t@Override\n\tpublic void fileSelected(IProjectSettingsWizardPage page) {\n\t\t// do nothing\n\t}\n\n\tprivate FileOutputStream getFileOutputStream(IProjectSettingsWizardPage page) throws IOException {\n\t\tIPath path = new Path(page.getDestinationFilePath());\n\t\tif (!IProjectSettingsWizardPage.FILENAME_EXTENSION.equals(path.getFileExtension()))\n\t\t\tpath.addFileExtension(IProjectSettingsWizardPage.FILENAME_EXTENSION);\n\n\t\treturn new FileOutputStream(path.toFile());\n\t}\n\n\t/**\n\t * Exports the selected project settings to an XML file.\n\t */\n\t@Override\n\tpublic boolean finish(IProjectSettingsWizardPage page) {\n\t\tSAXTransformerFactory factory = (SAXTransformerFactory) XmlProcessorFactoryCdt\n\t\t\t\t.createTransformerFactoryWithErrorOnDOCTYPE();\n\t\tTransformerHandler handler = null;\n\t\ttry {\n\t\t\thandler = factory.newTransformerHandler();\n\t\t} catch (TransformerConfigurationException e) {\n\t\t\tCUIPlugin.log(e);\n\t\t\tpage.showErrorDialog(Messages.ProjectSettingsExportStrategy_exportError,\n\t\t\t\t\tMessages.ProjectSettingsExportStrategy_exportFailed);\n\t\t\treturn false;\n\t\t}\n\n\t\t// gets a writer for the file that was selected by the user\n\t\tFileOutputStream outputStream;\n\t\ttry {\n\t\t\toutputStream = getFileOutputStream(page);\n\t\t} catch (IOException e) {\n\t\t\tpage.showErrorDialog(Messages.ProjectSettingsExportStrategy_fileOpenError,\n\t\t\t\t\tMessages.ProjectSettingsExportStrategy_couldNotOpen);\n\t\t\treturn false;\n\t\t}\n\n\t\t// write out the XML header\n\t\tTransformer transformer = handler.getTransformer();\n\t\ttransformer.setOutputProperty(OutputKeys.ENCODING, \"UTF-8\"); //$NON-NLS-1$\n\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\t\ttransformer.setOutputProperty(\"{http://xml.apache.org/xslt}indent-amount\", \"2\"); //$NON-NLS-1$ //$NON-NLS-2$\n\t\ttransformer.setOutputProperty(OutputKeys.DOCTYPE_PUBLIC, \"yes\"); //$NON-NLS-1$\n\n\t\t// stream the results to the writer as text\n\t\thandler.setResult(new StreamResult(outputStream));\n\n\t\tList<ISettingsProcessor> exporters = page.getSelectedSettingsProcessors();\n\n\t\tICConfigurationDescription config = page.getSelectedConfiguration();\n\t\tICFolderDescription projectRoot = config.getRootFolderDescription();\n\n\t\tboolean result = false;\n\t\ttry {\n\t\t\tAttributesImpl attributes = new AttributesImpl();\n\n\t\t\thandler.startDocument();\n\t\t\thandler.startElement(NONE, NONE, ROOT_ELEMENT, null);\n\n\t\t\tfor (ISettingsProcessor exporter : exporters) {\n\t\t\t\tattributes.clear();\n\t\t\t\tattributes.addAttribute(NONE, NONE, SECTION_NAME_ATTRIBUTE, CDATA, exporter.getSectionName());\n\t\t\t\thandler.startElement(NONE, NONE, SECTION_ELEMENT, attributes);\n\n\t\t\t\t// each exporter is responsible for writing out its own section of the file\n\t\t\t\texporter.writeSectionXML(projectRoot, handler);\n\n\t\t\t\thandler.endElement(NONE, NONE, SECTION_ELEMENT);\n\t\t\t}\n\n\t\t\thandler.endElement(NONE, NONE, ROOT_ELEMENT);\n\t\t\thandler.endDocument();\n\n\t\t\tresult = true;\n\t\t} catch (SAXException e) {\n\t\t\tCUIPlugin.log(e);\n\t\t\tpage.showErrorDialog(Messages.ProjectSettingsExportStrategy_exportError,\n\t\t\t\t\tMessages.ProjectSettingsExportStrategy_xmlError);\n\t\t\tresult = false;\n\t\t} catch (SettingsImportExportException e) {\n\t\t\tCUIPlugin.log(e);\n\t\t\tpage.showErrorDialog(Messages.ProjectSettingsExportStrategy_fileOpenError,\n\t\t\t\t\tMessages.ProjectSettingsExportStrategy_couldNotOpen);\n\t\t\tresult = false;\n\t\t}\n\n\t\tURI uri = URIUtil.toURI(page.getDestinationFilePath());\n\t\tResourcesUtil.refreshWorkspaceFiles(uri);\n\n\t\treturn result;\n\t}\n\n}\n",
    "patch": "@@ -21,14 +21,14 @@\n import javax.xml.transform.OutputKeys;\n import javax.xml.transform.Transformer;\n import javax.xml.transform.TransformerConfigurationException;\n-import javax.xml.transform.TransformerFactory;\n import javax.xml.transform.sax.SAXTransformerFactory;\n import javax.xml.transform.sax.TransformerHandler;\n import javax.xml.transform.stream.StreamResult;\n \n import org.eclipse.cdt.core.resources.ResourcesUtil;\n import org.eclipse.cdt.core.settings.model.ICConfigurationDescription;\n import org.eclipse.cdt.core.settings.model.ICFolderDescription;\n+import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n import org.eclipse.cdt.ui.CUIPlugin;\n import org.eclipse.core.filesystem.URIUtil;\n import org.eclipse.core.runtime.IPath;\n@@ -93,7 +93,8 @@ private FileOutputStream getFileOutputStream(IProjectSettingsWizardPage page) th\n \t */\n \t@Override\n \tpublic boolean finish(IProjectSettingsWizardPage page) {\n-\t\tSAXTransformerFactory factory = (SAXTransformerFactory) TransformerFactory.newInstance();\n+\t\tSAXTransformerFactory factory = (SAXTransformerFactory) XmlProcessorFactoryCdt\n+\t\t\t\t.createTransformerFactoryWithErrorOnDOCTYPE();\n \t\tTransformerHandler handler = null;\n \t\ttry {\n \t\t\thandler = factory.newTransformerHandler();",
    "function_modified_lines": {
      "added": [
        "import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n"
      ],
      "deleted": [
        "import javax.xml.transform.TransformerFactory;\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "In Eclipse IDE versions < 2023-09 (4.29) some files with xml content are parsed vulnerable against all sorts of XXE attacks. The user just needs to open any evil project or update an open project with a vulnerable file (for example for review a foreign repository or patch).\n",
    "id": 12873
  },
  {
    "cve_id": "CVE-2023-4218",
    "code_before_change": "/*******************************************************************************\n * Copyright (c) 2007, 2014 Nokia and others.\n *\n * This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n *\n * Contributors:\n *     Nokia - initial API and implementation\n *******************************************************************************/\npackage org.eclipse.cdt.debug.core.breakpointactions;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.StringReader;\nimport java.util.ArrayList;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.eclipse.cdt.debug.core.CDebugCorePlugin;\nimport org.eclipse.core.resources.IMarker;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.IAdaptable;\nimport org.eclipse.core.runtime.IConfigurationElement;\nimport org.eclipse.core.runtime.IExtension;\nimport org.eclipse.core.runtime.IExtensionPoint;\nimport org.eclipse.core.runtime.IProgressMonitor;\nimport org.eclipse.core.runtime.IStatus;\nimport org.eclipse.core.runtime.Platform;\nimport org.eclipse.core.runtime.Status;\nimport org.eclipse.core.runtime.jobs.Job;\nimport org.eclipse.debug.core.model.IBreakpoint;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.helpers.DefaultHandler;\n\npublic class BreakpointActionManager {\n\n\tpublic static final String BREAKPOINT_ACTION_ATTRIBUTE = \"BREAKPOINT_ACTIONS\"; //$NON-NLS-1$\n\tprivate static final String BREAKPOINT_ACTION_DATA = \"BreakpointActionManager.actionData\"; //$NON-NLS-1$\n\n\tprivate IExtension[] breakpointActionExtensions = null;\n\tprivate ArrayList<IBreakpointAction> breakpointActions = null;\n\n\tpublic BreakpointActionManager() {\n\t}\n\n\tpublic void addAction(IBreakpointAction action) {\n\t\tgetBreakpointActions().add(action);\n\t}\n\n\tprivate IBreakpointAction createActionFromClassName(String name, String className) {\n\n\t\tIBreakpointAction action = null;\n\t\tIExtension[] actionExtensions = CDebugCorePlugin.getDefault().getBreakpointActionManager()\n\t\t\t\t.getBreakpointActionExtensions();\n\n\t\ttry {\n\n\t\t\tfor (int i = 0; i < actionExtensions.length && action == null; i++) {\n\t\t\t\tIConfigurationElement[] elements = actionExtensions[i].getConfigurationElements();\n\t\t\t\tfor (int j = 0; j < elements.length && action == null; j++) {\n\t\t\t\t\tIConfigurationElement element = elements[j];\n\t\t\t\t\tif (element.getName().equals(CDebugCorePlugin.ACTION_TYPE_ELEMENT)) {\n\t\t\t\t\t\tif (element.getAttribute(\"class\").equals(className)) { //$NON-NLS-1$\n\t\t\t\t\t\t\taction = (IBreakpointAction) element.createExecutableExtension(\"class\"); //$NON-NLS-1$\n\t\t\t\t\t\t\taction.setName(name);\n\t\t\t\t\t\t\tCDebugCorePlugin.getDefault().getBreakpointActionManager().addAction(action);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t} catch (CoreException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\treturn action;\n\t}\n\n\tpublic void deleteAction(IBreakpointAction action) {\n\t\tgetBreakpointActions().remove(action);\n\t}\n\n\tpublic boolean breakpointHasActions(IBreakpoint breakpoint) {\n\t\tif (breakpoint != null) {\n\t\t\tIMarker marker = breakpoint.getMarker();\n\t\t\tString actionNames = marker.getAttribute(BREAKPOINT_ACTION_ATTRIBUTE, \"\"); //$NON-NLS-1$\n\t\t\treturn actionNames.length() > 0;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic void executeActions(final IBreakpoint breakpoint, final IAdaptable context) {\n\t\tif (breakpoint != null) {\n\t\t\tIMarker marker = breakpoint.getMarker();\n\t\t\tString actionNames = marker.getAttribute(BREAKPOINT_ACTION_ATTRIBUTE, \"\"); //$NON-NLS-1$\n\t\t\tif (actionNames.length() > 0) {\n\t\t\t\tfinal String[] actions = actionNames.split(\",\"); //$NON-NLS-1$\n\t\t\t\tif (actions.length > 0) {\n\t\t\t\t\tJob job = new Job(\"Execute breakpoint actions\") { //$NON-NLS-1$\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic IStatus run(final IProgressMonitor monitor) {\n\t\t\t\t\t\t\treturn doExecuteActions(breakpoint, context, actions, monitor);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tjob.schedule();\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// wait for actions to execute\n\t\t\t\t\t\tjob.join();\n\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate IStatus doExecuteActions(final IBreakpoint breakpoint, final IAdaptable context, String[] actions,\n\t\t\tIProgressMonitor monitor) {\n\t\ttry {\n\t\t\tfor (int i = 0; i < actions.length && !monitor.isCanceled(); i++) {\n\t\t\t\tString actionName = actions[i];\n\t\t\t\tIBreakpointAction action = findBreakpointAction(actionName);\n\t\t\t\tif (action != null) {\n\t\t\t\t\tmonitor.setTaskName(action.getSummary());\n\t\t\t\t\tIStatus status = action.execute(breakpoint, context, monitor);\n\t\t\t\t\tif (status.getCode() != IStatus.OK) {\n\t\t\t\t\t\t// do not log status if user canceled.\n\t\t\t\t\t\tif (status.getCode() != IStatus.CANCEL)\n\t\t\t\t\t\t\tCDebugCorePlugin.log(status);\n\t\t\t\t\t\treturn status;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmonitor.worked(1);\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\treturn new Status(IStatus.ERROR, CDebugCorePlugin.getUniqueIdentifier(), CDebugCorePlugin.INTERNAL_ERROR,\n\t\t\t\t\t\"Internal Error\", e); //$NON-NLS-1$\n\t\t}\n\t\treturn monitor.isCanceled() ? Status.CANCEL_STATUS : Status.OK_STATUS;\n\t}\n\n\tpublic IBreakpointAction findBreakpointAction(String name) {\n\t\tfor (IBreakpointAction action : getBreakpointActions()) {\n\t\t\tif (action.getName().equals(name))\n\t\t\t\treturn action;\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic IExtension[] getBreakpointActionExtensions() {\n\t\tif (breakpointActionExtensions == null) {\n\t\t\tIExtensionPoint point = Platform.getExtensionRegistry().getExtensionPoint(CDebugCorePlugin.PLUGIN_ID,\n\t\t\t\t\tCDebugCorePlugin.BREAKPOINT_ACTION_EXTENSION_POINT_ID);\n\t\t\tif (point == null)\n\t\t\t\tbreakpointActionExtensions = new IExtension[0];\n\t\t\telse {\n\t\t\t\tbreakpointActionExtensions = point.getExtensions();\n\t\t\t}\n\t\t}\n\n\t\treturn breakpointActionExtensions;\n\t}\n\n\tpublic ArrayList<IBreakpointAction> getBreakpointActions() {\n\t\tif (breakpointActions == null) {\n\t\t\tbreakpointActions = new ArrayList<>();\n\t\t\tCDebugCorePlugin.getDefault().getBreakpointActionManager().loadActionData();\n\t\t}\n\t\treturn breakpointActions;\n\t}\n\n\tprivate void loadActionData() {\n\n\t\tString actionData = CDebugCorePlugin.getDefault().getPluginPreferences().getString(BREAKPOINT_ACTION_DATA);\n\n\t\tif (actionData == null || actionData.length() == 0)\n\t\t\treturn;\n\n\t\tElement root = null;\n\t\tDocumentBuilder parser;\n\t\ttry {\n\t\t\tparser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n\t\t\tparser.setErrorHandler(new DefaultHandler());\n\t\t\troot = parser.parse(new InputSource(new StringReader(actionData))).getDocumentElement();\n\n\t\t\tNodeList nodeList = root.getChildNodes();\n\t\t\tint entryCount = nodeList.getLength();\n\n\t\t\tfor (int i = 0; i < entryCount; i++) {\n\t\t\t\tNode node = nodeList.item(i);\n\t\t\t\tshort type = node.getNodeType();\n\t\t\t\tif (type == Node.ELEMENT_NODE) {\n\t\t\t\t\tElement subElement = (Element) node;\n\t\t\t\t\tString nodeName = subElement.getNodeName();\n\t\t\t\t\tif (nodeName.equalsIgnoreCase(\"actionEntry\")) { //$NON-NLS-1$\n\t\t\t\t\t\tString name = subElement.getAttribute(\"name\"); //$NON-NLS-1$\n\t\t\t\t\t\tif (name == null)\n\t\t\t\t\t\t\tthrow new Exception();\n\t\t\t\t\t\tString value = subElement.getAttribute(\"value\"); //$NON-NLS-1$\n\t\t\t\t\t\tif (value == null)\n\t\t\t\t\t\t\tthrow new Exception();\n\t\t\t\t\t\tString className = subElement.getAttribute(\"class\"); //$NON-NLS-1$\n\t\t\t\t\t\tif (className == null)\n\t\t\t\t\t\t\tthrow new Exception();\n\n\t\t\t\t\t\tIBreakpointAction action = createActionFromClassName(name, className);\n\t\t\t\t\t\taction.initializeFromMemento(value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tpublic String makeUniqueActionName(String defaultName) {\n\t\tString result = defaultName;\n\t\tIBreakpointAction action = findBreakpointAction(defaultName);\n\t\tint actionCount = 1;\n\t\twhile (action != null) {\n\t\t\tresult = defaultName + \"(\" + actionCount + \")\"; //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\taction = findBreakpointAction(result);\n\t\t\tactionCount++;\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic void revertActionData() {\n\t\tbreakpointActions = null;\n\t}\n\n\tpublic void saveActionData() {\n\t\tString actionData = \"\"; //$NON-NLS-1$\n\n\t\tDocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();\n\t\tDocumentBuilder docBuilder = null;\n\t\ttry {\n\t\t\tdocBuilder = dfactory.newDocumentBuilder();\n\t\t\tDocument doc = docBuilder.newDocument();\n\n\t\t\tElement rootElement = doc.createElement(\"breakpointActionData\"); //$NON-NLS-1$\n\t\t\tdoc.appendChild(rootElement);\n\n\t\t\tfor (IBreakpointAction action : getBreakpointActions()) {\n\t\t\t\tElement element = doc.createElement(\"actionEntry\"); //$NON-NLS-1$\n\t\t\t\telement.setAttribute(\"name\", action.getName()); //$NON-NLS-1$\n\t\t\t\telement.setAttribute(\"class\", action.getClass().getName()); //$NON-NLS-1$\n\t\t\t\telement.setAttribute(\"value\", action.getMemento()); //$NON-NLS-1$\n\t\t\t\trootElement.appendChild(element);\n\t\t\t}\n\n\t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n\n\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n\t\t\tTransformer transformer = factory.newTransformer();\n\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\n\t\t\tDOMSource source = new DOMSource(doc);\n\t\t\tStreamResult outputTarget = new StreamResult(s);\n\t\t\ttransformer.transform(source, outputTarget);\n\n\t\t\tactionData = s.toString(\"UTF8\"); //$NON-NLS-1$\n\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tCDebugCorePlugin.getDefault().getPluginPreferences().setValue(BREAKPOINT_ACTION_DATA, actionData);\n\t\tCDebugCorePlugin.getDefault().savePluginPreferences();\n\t}\n\n}\n",
    "code_after_change": "/*******************************************************************************\n * Copyright (c) 2007, 2014 Nokia and others.\n *\n * This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n *\n * Contributors:\n *     Nokia - initial API and implementation\n *******************************************************************************/\npackage org.eclipse.cdt.debug.core.breakpointactions;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.StringReader;\nimport java.util.ArrayList;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.eclipse.cdt.debug.core.CDebugCorePlugin;\nimport org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\nimport org.eclipse.core.resources.IMarker;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.IAdaptable;\nimport org.eclipse.core.runtime.IConfigurationElement;\nimport org.eclipse.core.runtime.IExtension;\nimport org.eclipse.core.runtime.IExtensionPoint;\nimport org.eclipse.core.runtime.IProgressMonitor;\nimport org.eclipse.core.runtime.IStatus;\nimport org.eclipse.core.runtime.Platform;\nimport org.eclipse.core.runtime.Status;\nimport org.eclipse.core.runtime.jobs.Job;\nimport org.eclipse.debug.core.model.IBreakpoint;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.helpers.DefaultHandler;\n\npublic class BreakpointActionManager {\n\n\tpublic static final String BREAKPOINT_ACTION_ATTRIBUTE = \"BREAKPOINT_ACTIONS\"; //$NON-NLS-1$\n\tprivate static final String BREAKPOINT_ACTION_DATA = \"BreakpointActionManager.actionData\"; //$NON-NLS-1$\n\n\tprivate IExtension[] breakpointActionExtensions = null;\n\tprivate ArrayList<IBreakpointAction> breakpointActions = null;\n\n\tpublic BreakpointActionManager() {\n\t}\n\n\tpublic void addAction(IBreakpointAction action) {\n\t\tgetBreakpointActions().add(action);\n\t}\n\n\tprivate IBreakpointAction createActionFromClassName(String name, String className) {\n\n\t\tIBreakpointAction action = null;\n\t\tIExtension[] actionExtensions = CDebugCorePlugin.getDefault().getBreakpointActionManager()\n\t\t\t\t.getBreakpointActionExtensions();\n\n\t\ttry {\n\n\t\t\tfor (int i = 0; i < actionExtensions.length && action == null; i++) {\n\t\t\t\tIConfigurationElement[] elements = actionExtensions[i].getConfigurationElements();\n\t\t\t\tfor (int j = 0; j < elements.length && action == null; j++) {\n\t\t\t\t\tIConfigurationElement element = elements[j];\n\t\t\t\t\tif (element.getName().equals(CDebugCorePlugin.ACTION_TYPE_ELEMENT)) {\n\t\t\t\t\t\tif (element.getAttribute(\"class\").equals(className)) { //$NON-NLS-1$\n\t\t\t\t\t\t\taction = (IBreakpointAction) element.createExecutableExtension(\"class\"); //$NON-NLS-1$\n\t\t\t\t\t\t\taction.setName(name);\n\t\t\t\t\t\t\tCDebugCorePlugin.getDefault().getBreakpointActionManager().addAction(action);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t} catch (CoreException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\treturn action;\n\t}\n\n\tpublic void deleteAction(IBreakpointAction action) {\n\t\tgetBreakpointActions().remove(action);\n\t}\n\n\tpublic boolean breakpointHasActions(IBreakpoint breakpoint) {\n\t\tif (breakpoint != null) {\n\t\t\tIMarker marker = breakpoint.getMarker();\n\t\t\tString actionNames = marker.getAttribute(BREAKPOINT_ACTION_ATTRIBUTE, \"\"); //$NON-NLS-1$\n\t\t\treturn actionNames.length() > 0;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic void executeActions(final IBreakpoint breakpoint, final IAdaptable context) {\n\t\tif (breakpoint != null) {\n\t\t\tIMarker marker = breakpoint.getMarker();\n\t\t\tString actionNames = marker.getAttribute(BREAKPOINT_ACTION_ATTRIBUTE, \"\"); //$NON-NLS-1$\n\t\t\tif (actionNames.length() > 0) {\n\t\t\t\tfinal String[] actions = actionNames.split(\",\"); //$NON-NLS-1$\n\t\t\t\tif (actions.length > 0) {\n\t\t\t\t\tJob job = new Job(\"Execute breakpoint actions\") { //$NON-NLS-1$\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic IStatus run(final IProgressMonitor monitor) {\n\t\t\t\t\t\t\treturn doExecuteActions(breakpoint, context, actions, monitor);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tjob.schedule();\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// wait for actions to execute\n\t\t\t\t\t\tjob.join();\n\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate IStatus doExecuteActions(final IBreakpoint breakpoint, final IAdaptable context, String[] actions,\n\t\t\tIProgressMonitor monitor) {\n\t\ttry {\n\t\t\tfor (int i = 0; i < actions.length && !monitor.isCanceled(); i++) {\n\t\t\t\tString actionName = actions[i];\n\t\t\t\tIBreakpointAction action = findBreakpointAction(actionName);\n\t\t\t\tif (action != null) {\n\t\t\t\t\tmonitor.setTaskName(action.getSummary());\n\t\t\t\t\tIStatus status = action.execute(breakpoint, context, monitor);\n\t\t\t\t\tif (status.getCode() != IStatus.OK) {\n\t\t\t\t\t\t// do not log status if user canceled.\n\t\t\t\t\t\tif (status.getCode() != IStatus.CANCEL)\n\t\t\t\t\t\t\tCDebugCorePlugin.log(status);\n\t\t\t\t\t\treturn status;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmonitor.worked(1);\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\treturn new Status(IStatus.ERROR, CDebugCorePlugin.getUniqueIdentifier(), CDebugCorePlugin.INTERNAL_ERROR,\n\t\t\t\t\t\"Internal Error\", e); //$NON-NLS-1$\n\t\t}\n\t\treturn monitor.isCanceled() ? Status.CANCEL_STATUS : Status.OK_STATUS;\n\t}\n\n\tpublic IBreakpointAction findBreakpointAction(String name) {\n\t\tfor (IBreakpointAction action : getBreakpointActions()) {\n\t\t\tif (action.getName().equals(name))\n\t\t\t\treturn action;\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic IExtension[] getBreakpointActionExtensions() {\n\t\tif (breakpointActionExtensions == null) {\n\t\t\tIExtensionPoint point = Platform.getExtensionRegistry().getExtensionPoint(CDebugCorePlugin.PLUGIN_ID,\n\t\t\t\t\tCDebugCorePlugin.BREAKPOINT_ACTION_EXTENSION_POINT_ID);\n\t\t\tif (point == null)\n\t\t\t\tbreakpointActionExtensions = new IExtension[0];\n\t\t\telse {\n\t\t\t\tbreakpointActionExtensions = point.getExtensions();\n\t\t\t}\n\t\t}\n\n\t\treturn breakpointActionExtensions;\n\t}\n\n\tpublic ArrayList<IBreakpointAction> getBreakpointActions() {\n\t\tif (breakpointActions == null) {\n\t\t\tbreakpointActions = new ArrayList<>();\n\t\t\tCDebugCorePlugin.getDefault().getBreakpointActionManager().loadActionData();\n\t\t}\n\t\treturn breakpointActions;\n\t}\n\n\tprivate void loadActionData() {\n\n\t\tString actionData = CDebugCorePlugin.getDefault().getPluginPreferences().getString(BREAKPOINT_ACTION_DATA);\n\n\t\tif (actionData == null || actionData.length() == 0)\n\t\t\treturn;\n\n\t\tElement root = null;\n\t\tDocumentBuilder parser;\n\t\ttry {\n\t\t\tparser = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n\t\t\tparser.setErrorHandler(new DefaultHandler());\n\t\t\troot = parser.parse(new InputSource(new StringReader(actionData))).getDocumentElement();\n\n\t\t\tNodeList nodeList = root.getChildNodes();\n\t\t\tint entryCount = nodeList.getLength();\n\n\t\t\tfor (int i = 0; i < entryCount; i++) {\n\t\t\t\tNode node = nodeList.item(i);\n\t\t\t\tshort type = node.getNodeType();\n\t\t\t\tif (type == Node.ELEMENT_NODE) {\n\t\t\t\t\tElement subElement = (Element) node;\n\t\t\t\t\tString nodeName = subElement.getNodeName();\n\t\t\t\t\tif (nodeName.equalsIgnoreCase(\"actionEntry\")) { //$NON-NLS-1$\n\t\t\t\t\t\tString name = subElement.getAttribute(\"name\"); //$NON-NLS-1$\n\t\t\t\t\t\tif (name == null)\n\t\t\t\t\t\t\tthrow new Exception();\n\t\t\t\t\t\tString value = subElement.getAttribute(\"value\"); //$NON-NLS-1$\n\t\t\t\t\t\tif (value == null)\n\t\t\t\t\t\t\tthrow new Exception();\n\t\t\t\t\t\tString className = subElement.getAttribute(\"class\"); //$NON-NLS-1$\n\t\t\t\t\t\tif (className == null)\n\t\t\t\t\t\t\tthrow new Exception();\n\n\t\t\t\t\t\tIBreakpointAction action = createActionFromClassName(name, className);\n\t\t\t\t\t\taction.initializeFromMemento(value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tpublic String makeUniqueActionName(String defaultName) {\n\t\tString result = defaultName;\n\t\tIBreakpointAction action = findBreakpointAction(defaultName);\n\t\tint actionCount = 1;\n\t\twhile (action != null) {\n\t\t\tresult = defaultName + \"(\" + actionCount + \")\"; //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\taction = findBreakpointAction(result);\n\t\t\tactionCount++;\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic void revertActionData() {\n\t\tbreakpointActions = null;\n\t}\n\n\tpublic void saveActionData() {\n\t\tString actionData = \"\"; //$NON-NLS-1$\n\n\t\ttry {\n\t\t\tDocumentBuilder docBuilder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n\t\t\tDocument doc = docBuilder.newDocument();\n\n\t\t\tElement rootElement = doc.createElement(\"breakpointActionData\"); //$NON-NLS-1$\n\t\t\tdoc.appendChild(rootElement);\n\n\t\t\tfor (IBreakpointAction action : getBreakpointActions()) {\n\t\t\t\tElement element = doc.createElement(\"actionEntry\"); //$NON-NLS-1$\n\t\t\t\telement.setAttribute(\"name\", action.getName()); //$NON-NLS-1$\n\t\t\t\telement.setAttribute(\"class\", action.getClass().getName()); //$NON-NLS-1$\n\t\t\t\telement.setAttribute(\"value\", action.getMemento()); //$NON-NLS-1$\n\t\t\t\trootElement.appendChild(element);\n\t\t\t}\n\n\t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n\n\t\t\tTransformerFactory factory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n\t\t\tTransformer transformer = factory.newTransformer();\n\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\n\t\t\tDOMSource source = new DOMSource(doc);\n\t\t\tStreamResult outputTarget = new StreamResult(s);\n\t\t\ttransformer.transform(source, outputTarget);\n\n\t\t\tactionData = s.toString(\"UTF8\"); //$NON-NLS-1$\n\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tCDebugCorePlugin.getDefault().getPluginPreferences().setValue(BREAKPOINT_ACTION_DATA, actionData);\n\t\tCDebugCorePlugin.getDefault().savePluginPreferences();\n\t}\n\n}\n",
    "patch": "@@ -18,14 +18,14 @@\n import java.util.ArrayList;\n \n import javax.xml.parsers.DocumentBuilder;\n-import javax.xml.parsers.DocumentBuilderFactory;\n import javax.xml.transform.OutputKeys;\n import javax.xml.transform.Transformer;\n import javax.xml.transform.TransformerFactory;\n import javax.xml.transform.dom.DOMSource;\n import javax.xml.transform.stream.StreamResult;\n \n import org.eclipse.cdt.debug.core.CDebugCorePlugin;\n+import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n import org.eclipse.core.resources.IMarker;\n import org.eclipse.core.runtime.CoreException;\n import org.eclipse.core.runtime.IAdaptable;\n@@ -192,7 +192,7 @@ private void loadActionData() {\n \t\tElement root = null;\n \t\tDocumentBuilder parser;\n \t\ttry {\n-\t\t\tparser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n+\t\t\tparser = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tparser.setErrorHandler(new DefaultHandler());\n \t\t\troot = parser.parse(new InputSource(new StringReader(actionData))).getDocumentElement();\n \n@@ -246,10 +246,8 @@ public void revertActionData() {\n \tpublic void saveActionData() {\n \t\tString actionData = \"\"; //$NON-NLS-1$\n \n-\t\tDocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();\n-\t\tDocumentBuilder docBuilder = null;\n \t\ttry {\n-\t\t\tdocBuilder = dfactory.newDocumentBuilder();\n+\t\t\tDocumentBuilder docBuilder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tDocument doc = docBuilder.newDocument();\n \n \t\t\tElement rootElement = doc.createElement(\"breakpointActionData\"); //$NON-NLS-1$\n@@ -265,7 +263,7 @@ public void saveActionData() {\n \n \t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n \n-\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n+\t\t\tTransformerFactory factory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n \t\t\tTransformer transformer = factory.newTransformer();\n \t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n \t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$",
    "function_modified_lines": {
      "added": [
        "import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n"
      ],
      "deleted": [
        "import javax.xml.parsers.DocumentBuilderFactory;\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "In Eclipse IDE versions < 2023-09 (4.29) some files with xml content are parsed vulnerable against all sorts of XXE attacks. The user just needs to open any evil project or update an open project with a vulnerable file (for example for review a foreign repository or patch).\n",
    "id": 12874
  },
  {
    "cve_id": "CVE-2023-4218",
    "code_before_change": "/*******************************************************************************\n * Copyright (c) 2000, 2016 QNX Software Systems and others.\n *\n * This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n *\n * Contributors:\n *     QNX Software Systems - Initial API and implementation\n *******************************************************************************/\npackage org.eclipse.cdt.debug.internal.core.sourcelookup;\n\nimport java.io.File;\nimport java.io.FileFilter;\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.TransformerException;\n\nimport org.eclipse.cdt.core.resources.FileStorage;\nimport org.eclipse.cdt.debug.core.CDebugCorePlugin;\nimport org.eclipse.cdt.debug.core.CDebugUtils;\nimport org.eclipse.cdt.debug.core.sourcelookup.ICSourceLocation;\nimport org.eclipse.cdt.debug.core.sourcelookup.IDirectorySourceLocation;\nimport org.eclipse.cdt.internal.core.resources.ResourceLookup;\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.core.resources.IStorage;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.IPath;\nimport org.eclipse.core.runtime.IStatus;\nimport org.eclipse.core.runtime.Path;\nimport org.eclipse.core.runtime.Status;\nimport org.eclipse.osgi.util.NLS;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\n\n/**\n *\n * Locates source elements in a directory in the local\n * file system. Returns instances of <code>FileStorage</code>.\n *\n * @since Sep 23, 2002\n */\npublic class CDirectorySourceLocation implements IDirectorySourceLocation {\n\tprivate static final String ELEMENT_NAME = \"cDirectorySourceLocation\"; //$NON-NLS-1$\n\tprivate static final String ATTR_DIRECTORY = \"directory\"; //$NON-NLS-1$\n\tprivate static final String ATTR_ASSOCIATION = \"association\"; //$NON-NLS-1$\n\tprivate static final String ATTR_SEARCH_SUBFOLDERS = \"searchSubfolders\"; //$NON-NLS-1$\n\n\t/**\n\t * The root directory of this source location\n\t */\n\tprivate IPath fDirectory;\n\t/**\n\t * The associated path of this source location.\n\t */\n\tprivate IPath fAssociation;\n\tprivate boolean fSearchForDuplicateFiles;\n\tprivate boolean fSearchSubfolders;\n\tprivate File[] fFolders;",
    "code_after_change": "/*******************************************************************************\n * Copyright (c) 2000, 2016 QNX Software Systems and others.\n *\n * This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n *\n * Contributors:\n *     QNX Software Systems - Initial API and implementation\n *******************************************************************************/\npackage org.eclipse.cdt.debug.internal.core.sourcelookup;\n\nimport java.io.File;\nimport java.io.FileFilter;\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.TransformerException;\n\nimport org.eclipse.cdt.core.resources.FileStorage;\nimport org.eclipse.cdt.debug.core.CDebugCorePlugin;\nimport org.eclipse.cdt.debug.core.CDebugUtils;\nimport org.eclipse.cdt.debug.core.sourcelookup.ICSourceLocation;\nimport org.eclipse.cdt.debug.core.sourcelookup.IDirectorySourceLocation;\nimport org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\nimport org.eclipse.cdt.internal.core.resources.ResourceLookup;\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.core.resources.IStorage;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.IPath;\nimport org.eclipse.core.runtime.IStatus;\nimport org.eclipse.core.runtime.Path;\nimport org.eclipse.core.runtime.Status;\nimport org.eclipse.osgi.util.NLS;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\n\n/**\n *\n * Locates source elements in a directory in the local\n * file system. Returns instances of <code>FileStorage</code>.\n *\n * @since Sep 23, 2002\n */\npublic class CDirectorySourceLocation implements IDirectorySourceLocation {\n\tprivate static final String ELEMENT_NAME = \"cDirectorySourceLocation\"; //$NON-NLS-1$\n\tprivate static final String ATTR_DIRECTORY = \"directory\"; //$NON-NLS-1$\n\tprivate static final String ATTR_ASSOCIATION = \"association\"; //$NON-NLS-1$\n\tprivate static final String ATTR_SEARCH_SUBFOLDERS = \"searchSubfolders\"; //$NON-NLS-1$\n\n\t/**\n\t * The root directory of this source location\n\t */\n\tprivate IPath fDirectory;\n\t/**\n\t * The associated path of this source location.\n\t */\n\tprivate IPath fAssociation;\n\tprivate boolean fSearchForDuplicateFiles;",
    "patch": "@@ -23,7 +23,6 @@\n import java.util.List;\n \n import javax.xml.parsers.DocumentBuilder;\n-import javax.xml.parsers.DocumentBuilderFactory;\n import javax.xml.parsers.ParserConfigurationException;\n import javax.xml.transform.TransformerException;\n \n@@ -32,6 +31,7 @@\n import org.eclipse.cdt.debug.core.CDebugUtils;\n import org.eclipse.cdt.debug.core.sourcelookup.ICSourceLocation;\n import org.eclipse.cdt.debug.core.sourcelookup.IDirectorySourceLocation;\n+import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n import org.eclipse.cdt.internal.core.resources.ResourceLookup;\n import org.eclipse.core.resources.IFile;\n import org.eclipse.core.resources.IStorage;\n@@ -279,7 +279,7 @@ public String getMemento() throws CoreException {\n \t\tDocument document = null;\n \t\tThrowable ex = null;\n \t\ttry {\n-\t\t\tdocument = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n+\t\t\tdocument = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE().newDocument();\n \t\t\tElement node = document.createElement(ELEMENT_NAME);\n \t\t\tdocument.appendChild(node);\n \t\t\tnode.setAttribute(ATTR_DIRECTORY, getDirectory().toOSString());\n@@ -307,7 +307,7 @@ public void initializeFrom(String memento) throws CoreException {\n \t\tException ex = null;\n \t\ttry {\n \t\t\tElement root = null;\n-\t\t\tDocumentBuilder parser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n+\t\t\tDocumentBuilder parser = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tStringReader reader = new StringReader(memento);\n \t\t\tInputSource source = new InputSource(reader);\n \t\t\troot = parser.parse(source).getDocumentElement();",
    "function_modified_lines": {
      "added": [
        "import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n"
      ],
      "deleted": [
        "import javax.xml.parsers.DocumentBuilderFactory;\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "In Eclipse IDE versions < 2023-09 (4.29) some files with xml content are parsed vulnerable against all sorts of XXE attacks. The user just needs to open any evil project or update an open project with a vulnerable file (for example for review a foreign repository or patch).\n",
    "id": 12875
  },
  {
    "cve_id": "CVE-2023-4218",
    "code_before_change": "/*******************************************************************************\n * Copyright (c) 2004, 2014 QNX Software Systems and others.\n *\n * This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n *\n * Contributors:\n *     QNX Software Systems - Initial API and implementation\n *******************************************************************************/\npackage org.eclipse.cdt.debug.internal.core.sourcelookup;\n\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.text.MessageFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.TransformerException;\n\nimport org.eclipse.cdt.debug.core.CDebugCorePlugin;\nimport org.eclipse.cdt.debug.core.CDebugUtils;\nimport org.eclipse.cdt.debug.core.model.ICStackFrame;\nimport org.eclipse.cdt.debug.core.sourcelookup.ICSourceLocation;\nimport org.eclipse.cdt.debug.core.sourcelookup.ICSourceLocator;\nimport org.eclipse.cdt.debug.core.sourcelookup.IProjectSourceLocation;\nimport org.eclipse.cdt.debug.core.sourcelookup.SourceLookupFactory;\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.resources.IResourceChangeEvent;\nimport org.eclipse.core.resources.IResourceChangeListener;\nimport org.eclipse.core.resources.IResourceDelta;\nimport org.eclipse.core.resources.IWorkspace;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.IStatus;\nimport org.eclipse.core.runtime.MultiStatus;\nimport org.eclipse.core.runtime.Status;\nimport org.eclipse.debug.core.ILaunchConfiguration;\nimport org.eclipse.debug.core.model.IPersistableSourceLocator;\nimport org.eclipse.debug.core.model.IStackFrame;\nimport org.osgi.framework.Bundle;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\n\n/**\n * Default source locator.\n */\npublic class CSourceLocator implements ICSourceLocator, IPersistableSourceLocator, IResourceChangeListener {\n\tprivate static final String SOURCE_LOCATOR_NAME = \"cSourceLocator\"; //$NON-NLS-1$\n\tprivate static final String DISABLED_GENERIC_PROJECT_NAME = \"disabledGenericProject\"; //$NON-NLS-1$\n\tprivate static final String ADDITIONAL_SOURCE_LOCATION_NAME = \"additionalSourceLocation\"; //$NON-NLS-1$\n\tprivate static final String SOURCE_LOCATION_NAME = \"cSourceLocation\"; //$NON-NLS-1$\n\tprivate static final String ATTR_CLASS = \"class\"; //$NON-NLS-1$\n\tprivate static final String ATTR_MEMENTO = \"memento\"; //$NON-NLS-1$\n\tprivate static final String ATTR_PROJECT_NAME = \"projectName\"; //$NON-NLS-1$\n\tprivate static final String ATTR_DUPLICATE_FILES = \"duplicateFiles\"; //$NON-NLS-1$\n\n\t/**\n\t * The project associated with this locator.\n\t */",
    "code_after_change": "/*******************************************************************************\n * Copyright (c) 2004, 2014 QNX Software Systems and others.\n *\n * This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n *\n * Contributors:\n *     QNX Software Systems - Initial API and implementation\n *******************************************************************************/\npackage org.eclipse.cdt.debug.internal.core.sourcelookup;\n\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.text.MessageFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.TransformerException;\n\nimport org.eclipse.cdt.debug.core.CDebugCorePlugin;\nimport org.eclipse.cdt.debug.core.CDebugUtils;\nimport org.eclipse.cdt.debug.core.model.ICStackFrame;\nimport org.eclipse.cdt.debug.core.sourcelookup.ICSourceLocation;\nimport org.eclipse.cdt.debug.core.sourcelookup.ICSourceLocator;\nimport org.eclipse.cdt.debug.core.sourcelookup.IProjectSourceLocation;\nimport org.eclipse.cdt.debug.core.sourcelookup.SourceLookupFactory;\nimport org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.resources.IResourceChangeEvent;\nimport org.eclipse.core.resources.IResourceChangeListener;\nimport org.eclipse.core.resources.IResourceDelta;\nimport org.eclipse.core.resources.IWorkspace;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.IStatus;\nimport org.eclipse.core.runtime.MultiStatus;\nimport org.eclipse.core.runtime.Status;\nimport org.eclipse.debug.core.ILaunchConfiguration;\nimport org.eclipse.debug.core.model.IPersistableSourceLocator;\nimport org.eclipse.debug.core.model.IStackFrame;\nimport org.osgi.framework.Bundle;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\n\n/**\n * Default source locator.\n */\npublic class CSourceLocator implements ICSourceLocator, IPersistableSourceLocator, IResourceChangeListener {\n\tprivate static final String SOURCE_LOCATOR_NAME = \"cSourceLocator\"; //$NON-NLS-1$\n\tprivate static final String DISABLED_GENERIC_PROJECT_NAME = \"disabledGenericProject\"; //$NON-NLS-1$\n\tprivate static final String ADDITIONAL_SOURCE_LOCATION_NAME = \"additionalSourceLocation\"; //$NON-NLS-1$\n\tprivate static final String SOURCE_LOCATION_NAME = \"cSourceLocation\"; //$NON-NLS-1$\n\tprivate static final String ATTR_CLASS = \"class\"; //$NON-NLS-1$\n\tprivate static final String ATTR_MEMENTO = \"memento\"; //$NON-NLS-1$\n\tprivate static final String ATTR_PROJECT_NAME = \"projectName\"; //$NON-NLS-1$\n\tprivate static final String ATTR_DUPLICATE_FILES = \"duplicateFiles\"; //$NON-NLS-1$\n\n\t/**",
    "patch": "@@ -24,7 +24,6 @@\n import java.util.List;\n \n import javax.xml.parsers.DocumentBuilder;\n-import javax.xml.parsers.DocumentBuilderFactory;\n import javax.xml.parsers.ParserConfigurationException;\n import javax.xml.transform.TransformerException;\n \n@@ -35,6 +34,7 @@\n import org.eclipse.cdt.debug.core.sourcelookup.ICSourceLocator;\n import org.eclipse.cdt.debug.core.sourcelookup.IProjectSourceLocation;\n import org.eclipse.cdt.debug.core.sourcelookup.SourceLookupFactory;\n+import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n import org.eclipse.core.resources.IFile;\n import org.eclipse.core.resources.IProject;\n import org.eclipse.core.resources.IResource;\n@@ -239,7 +239,7 @@ public String getMemento() throws CoreException {\n \t\tDocument document = null;\n \t\tThrowable ex = null;\n \t\ttry {\n-\t\t\tdocument = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n+\t\t\tdocument = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE().newDocument();\n \t\t\tElement node = document.createElement(SOURCE_LOCATOR_NAME);\n \t\t\tdocument.appendChild(node);\n \t\t\tICSourceLocation[] locations = getSourceLocations();\n@@ -269,7 +269,7 @@ public void initializeFromMemento(String memento) throws CoreException {\n \t\tException ex = null;\n \t\ttry {\n \t\t\tElement root = null;\n-\t\t\tDocumentBuilder parser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n+\t\t\tDocumentBuilder parser = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tStringReader reader = new StringReader(memento);\n \t\t\tInputSource source = new InputSource(reader);\n \t\t\troot = parser.parse(source).getDocumentElement();",
    "function_modified_lines": {
      "added": [
        "import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n"
      ],
      "deleted": [
        "import javax.xml.parsers.DocumentBuilderFactory;\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "In Eclipse IDE versions < 2023-09 (4.29) some files with xml content are parsed vulnerable against all sorts of XXE attacks. The user just needs to open any evil project or update an open project with a vulnerable file (for example for review a foreign repository or patch).\n",
    "id": 12877
  },
  {
    "cve_id": "CVE-2023-4218",
    "code_before_change": "/*******************************************************************************\n * Copyright (c) 2000, 2015 QNX Software Systems and others.\n *\n * This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n *\n * Contributors:\n *     QNX Software Systems - Initial API and implementation\n *     Sergey Prigogin (Google)\n *******************************************************************************/\npackage org.eclipse.cdt.debug.internal.core.sourcelookup;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.text.MessageFormat;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Set;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.TransformerException;\n\nimport org.eclipse.cdt.core.model.CoreModel;\nimport org.eclipse.cdt.core.model.ICProject;\nimport org.eclipse.cdt.core.model.ITranslationUnit;\nimport org.eclipse.cdt.debug.core.CDebugCorePlugin;\nimport org.eclipse.cdt.debug.core.CDebugUtils;\nimport org.eclipse.cdt.debug.core.ICDTLaunchConfigurationConstants;\nimport org.eclipse.cdt.debug.core.sourcelookup.CProjectSourceContainer;\nimport org.eclipse.cdt.debug.core.sourcelookup.ICSourceLocation;\nimport org.eclipse.cdt.debug.core.sourcelookup.IDirectorySourceLocation;\nimport org.eclipse.cdt.debug.core.sourcelookup.IMappingSourceContainer;\nimport org.eclipse.cdt.debug.core.sourcelookup.IProjectSourceLocation;\nimport org.eclipse.cdt.debug.core.sourcelookup.MappingSourceContainer;\nimport org.eclipse.cdt.internal.core.resources.ResourceLookup;\nimport org.eclipse.core.filesystem.URIUtil;\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.resources.ResourcesPlugin;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.IPath;\nimport org.eclipse.core.runtime.IStatus;\nimport org.eclipse.core.runtime.Path;\nimport org.eclipse.core.runtime.Status;\nimport org.eclipse.debug.core.ILaunchConfiguration;\nimport org.eclipse.debug.core.sourcelookup.ISourceContainer;\nimport org.eclipse.debug.core.sourcelookup.ISourceLookupDirector;\nimport org.eclipse.debug.core.sourcelookup.containers.DirectorySourceContainer;\nimport org.eclipse.debug.core.sourcelookup.containers.LocalFileStorage;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\n\npublic class SourceUtils {\n\tprivate static final String NAME_COMMON_SOURCE_LOCATIONS = \"commonSourceLocations\"; //$NON-NLS-1$\n\tprivate static final String NAME_SOURCE_LOCATION = \"sourceLocation\"; //$NON-NLS-1$\n\tprivate static final String ATTR_CLASS = \"class\"; //$NON-NLS-1$\n\tprivate static final String ATTR_MEMENTO = \"memento\"; //$NON-NLS-1$\n\n\tpublic static String getCommonSourceLocationsMemento(ICSourceLocation[] locations) {\n\t\tDocument document = null;\n\t\tThrowable ex = null;\n\t\ttry {\n\t\t\tdocument = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n\t\t\tElement element = document.createElement(NAME_COMMON_SOURCE_LOCATIONS);\n\t\t\tdocument.appendChild(element);\n\t\t\tsaveSourceLocations(document, element, locations);\n\t\t\treturn CDebugUtils.serializeDocument(document);\n\t\t} catch (ParserConfigurationException e) {",
    "code_after_change": "/*******************************************************************************\n * Copyright (c) 2000, 2015 QNX Software Systems and others.\n *\n * This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n *\n * Contributors:\n *     QNX Software Systems - Initial API and implementation\n *     Sergey Prigogin (Google)\n *******************************************************************************/\npackage org.eclipse.cdt.debug.internal.core.sourcelookup;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.text.MessageFormat;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Set;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.TransformerException;\n\nimport org.eclipse.cdt.core.model.CoreModel;\nimport org.eclipse.cdt.core.model.ICProject;\nimport org.eclipse.cdt.core.model.ITranslationUnit;\nimport org.eclipse.cdt.debug.core.CDebugCorePlugin;\nimport org.eclipse.cdt.debug.core.CDebugUtils;\nimport org.eclipse.cdt.debug.core.ICDTLaunchConfigurationConstants;\nimport org.eclipse.cdt.debug.core.sourcelookup.CProjectSourceContainer;\nimport org.eclipse.cdt.debug.core.sourcelookup.ICSourceLocation;\nimport org.eclipse.cdt.debug.core.sourcelookup.IDirectorySourceLocation;\nimport org.eclipse.cdt.debug.core.sourcelookup.IMappingSourceContainer;\nimport org.eclipse.cdt.debug.core.sourcelookup.IProjectSourceLocation;\nimport org.eclipse.cdt.debug.core.sourcelookup.MappingSourceContainer;\nimport org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\nimport org.eclipse.cdt.internal.core.resources.ResourceLookup;\nimport org.eclipse.core.filesystem.URIUtil;\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.resources.ResourcesPlugin;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.IPath;\nimport org.eclipse.core.runtime.IStatus;\nimport org.eclipse.core.runtime.Path;\nimport org.eclipse.core.runtime.Status;\nimport org.eclipse.debug.core.ILaunchConfiguration;\nimport org.eclipse.debug.core.sourcelookup.ISourceContainer;\nimport org.eclipse.debug.core.sourcelookup.ISourceLookupDirector;\nimport org.eclipse.debug.core.sourcelookup.containers.DirectorySourceContainer;\nimport org.eclipse.debug.core.sourcelookup.containers.LocalFileStorage;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\n\npublic class SourceUtils {\n\tprivate static final String NAME_COMMON_SOURCE_LOCATIONS = \"commonSourceLocations\"; //$NON-NLS-1$\n\tprivate static final String NAME_SOURCE_LOCATION = \"sourceLocation\"; //$NON-NLS-1$\n\tprivate static final String ATTR_CLASS = \"class\"; //$NON-NLS-1$\n\tprivate static final String ATTR_MEMENTO = \"memento\"; //$NON-NLS-1$\n\n\tpublic static String getCommonSourceLocationsMemento(ICSourceLocation[] locations) {\n\t\tDocument document = null;\n\t\tThrowable ex = null;\n\t\ttry {\n\t\t\tdocument = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE().newDocument();\n\t\t\tElement element = document.createElement(NAME_COMMON_SOURCE_LOCATIONS);\n\t\t\tdocument.appendChild(element);\n\t\t\tsaveSourceLocations(document, element, locations);",
    "patch": "@@ -25,7 +25,6 @@\n import java.util.Set;\n \n import javax.xml.parsers.DocumentBuilder;\n-import javax.xml.parsers.DocumentBuilderFactory;\n import javax.xml.parsers.ParserConfigurationException;\n import javax.xml.transform.TransformerException;\n \n@@ -41,6 +40,7 @@\n import org.eclipse.cdt.debug.core.sourcelookup.IMappingSourceContainer;\n import org.eclipse.cdt.debug.core.sourcelookup.IProjectSourceLocation;\n import org.eclipse.cdt.debug.core.sourcelookup.MappingSourceContainer;\n+import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n import org.eclipse.cdt.internal.core.resources.ResourceLookup;\n import org.eclipse.core.filesystem.URIUtil;\n import org.eclipse.core.resources.IFile;\n@@ -73,7 +73,7 @@ public static String getCommonSourceLocationsMemento(ICSourceLocation[] location\n \t\tDocument document = null;\n \t\tThrowable ex = null;\n \t\ttry {\n-\t\t\tdocument = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n+\t\t\tdocument = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE().newDocument();\n \t\t\tElement element = document.createElement(NAME_COMMON_SOURCE_LOCATIONS);\n \t\t\tdocument.appendChild(element);\n \t\t\tsaveSourceLocations(document, element, locations);\n@@ -108,7 +108,7 @@ public static ICSourceLocation[] getCommonSourceLocationsFromMemento(String meme\n \t\tICSourceLocation[] result = new ICSourceLocation[0];\n \t\tif (!isEmpty(memento)) {\n \t\t\ttry {\n-\t\t\t\tDocumentBuilder parser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n+\t\t\t\tDocumentBuilder parser = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\t\tStringReader reader = new StringReader(memento);\n \t\t\t\tInputSource source = new InputSource(reader);\n \t\t\t\tElement root = parser.parse(source).getDocumentElement();",
    "function_modified_lines": {
      "added": [
        "import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n"
      ],
      "deleted": [
        "import javax.xml.parsers.DocumentBuilderFactory;\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "In Eclipse IDE versions < 2023-09 (4.29) some files with xml content are parsed vulnerable against all sorts of XXE attacks. The user just needs to open any evil project or update an open project with a vulnerable file (for example for review a foreign repository or patch).\n",
    "id": 12878
  },
  {
    "cve_id": "CVE-2023-4218",
    "code_before_change": "/*******************************************************************************\n * Copyright (c) 2007, 2012 Nokia and others.\n *\n * This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n *\n * Contributors:\n *     Nokia - initial API and implementation\n *******************************************************************************/\npackage org.eclipse.cdt.debug.ui.breakpointactions;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.StringReader;\nimport java.text.MessageFormat;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.eclipse.cdt.debug.core.CDIDebugModel;\nimport org.eclipse.cdt.debug.core.breakpointactions.AbstractBreakpointAction;\nimport org.eclipse.cdt.debug.internal.core.ICDebugInternalConstants;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.IAdaptable;\nimport org.eclipse.core.runtime.IProgressMonitor;\nimport org.eclipse.core.runtime.IStatus;\nimport org.eclipse.core.runtime.MultiStatus;\nimport org.eclipse.core.runtime.Status;\nimport org.eclipse.core.runtime.jobs.Job;\nimport org.eclipse.debug.core.DebugPlugin;\nimport org.eclipse.debug.core.ILaunchConfiguration;\nimport org.eclipse.debug.core.ILaunchManager;\nimport org.eclipse.debug.core.model.IBreakpoint;\nimport org.eclipse.debug.ui.DebugUITools;\nimport org.eclipse.ui.progress.WorkbenchJob;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.helpers.DefaultHandler;\n\npublic class ExternalToolAction extends AbstractBreakpointAction {\n\n\tprivate String externalToolName = \"\"; //$NON-NLS-1$\n\n\t@Override\n\tpublic IStatus execute(final IBreakpoint breakpoint, final IAdaptable context, final IProgressMonitor monitor) {\n\t\tJob uiJob = new WorkbenchJob(\"ExternalToolAction\") { //$NON-NLS-1$\n\t\t\t{\n\t\t\t\tsetPriority(INTERACTIVE);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic IStatus runInUIThread(IProgressMonitor monitor) {\n\t\t\t\treturn executeInUIThread(breakpoint, context, monitor);\n\t\t\t}\n\t\t};\n\t\tuiJob.schedule();\n\t\ttry {\n\t\t\tuiJob.join();\n\t\t} catch (InterruptedException e) {\n\t\t\treturn Status.CANCEL_STATUS;\n\t\t}\n\t\treturn uiJob.getResult();\n\t}\n\n\tprivate IStatus executeInUIThread(IBreakpoint breakpoint, IAdaptable context, IProgressMonitor monitor) {\n\t\tIStatus errorStatus = null;\n\t\tILaunchManager lcm = DebugPlugin.getDefault().getLaunchManager();\n\t\ttry {\n\t\t\tboolean launched = false;\n\t\t\tILaunchConfiguration[] launchConfigurations = lcm.getLaunchConfigurations();\n\t\t\tfor (int i = 0; i < launchConfigurations.length; i++) {\n\t\t\t\tif (launchConfigurations[i].getName().equals(externalToolName)) {\n\t\t\t\t\tDebugUITools.launch(launchConfigurations[i], ILaunchManager.RUN_MODE);\n\t\t\t\t\tlaunched = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!launched) {\n\t\t\t\tString errorMsg = MessageFormat.format(Messages.getString(\"ExternalToolAction.error.0\"), //$NON-NLS-1$\n\t\t\t\t\t\tnew Object[] { externalToolName });\n\t\t\t\terrorStatus = new Status(IStatus.ERROR, CDIDebugModel.getPluginIdentifier(),\n\t\t\t\t\t\tICDebugInternalConstants.STATUS_CODE_ERROR, errorMsg, null);\n\t\t\t}\n\n\t\t} catch (CoreException e) {\n\t\t\terrorStatus = e.getStatus();\n\t\t} catch (Exception e) {\n\t\t\terrorStatus = new Status(IStatus.ERROR, CDIDebugModel.getPluginIdentifier(),\n\t\t\t\t\tICDebugInternalConstants.STATUS_CODE_ERROR, e.getMessage(), e);\n\t\t}\n\n\t\tif (errorStatus != null) {\n\t\t\tString errorMsg = MessageFormat.format(Messages.getString(\"ExternalToolAction.error.1\"), //$NON-NLS-1$\n\t\t\t\t\tnew Object[] { externalToolName });\n\t\t\tMultiStatus ms = new MultiStatus(CDIDebugModel.getPluginIdentifier(),\n\t\t\t\t\tICDebugInternalConstants.STATUS_CODE_ERROR, errorMsg, null);\n\t\t\tms.add(errorStatus);\n\t\t\treturn ms;\n\t\t}\n\n\t\treturn Status.OK_STATUS;\n\t}\n\n\t@Override\n\tpublic String getDefaultName() {\n\t\treturn \"Untitled External Tool Action\"; //$NON-NLS-1$\n\t}\n\n\tpublic String getExternalToolName() {\n\t\treturn externalToolName;\n\t}\n\n\tpublic void setExternalToolName(String launchConfigName) {\n\t\tthis.externalToolName = launchConfigName;\n\t}\n\n\t@Override\n\tpublic String getIdentifier() {\n\t\treturn \"org.eclipse.cdt.debug.ui.breakpointactions.ExternalToolAction\"; //$NON-NLS-1$\n\t}\n\n\t@Override\n\tpublic String getMemento() {\n\t\tString executeData = \"\"; //$NON-NLS-1$\n\t\tif (externalToolName != null) {\n\t\t\tDocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();\n\t\t\tDocumentBuilder docBuilder = null;\n\t\t\ttry {\n\t\t\t\tdocBuilder = dfactory.newDocumentBuilder();\n\t\t\t\tDocument doc = docBuilder.newDocument();\n\n\t\t\t\tElement rootElement = doc.createElement(\"launchConfigName\"); //$NON-NLS-1$\n\t\t\t\trootElement.setAttribute(\"configName\", externalToolName); //$NON-NLS-1$\n\n\t\t\t\tdoc.appendChild(rootElement);\n\n\t\t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n\n\t\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n\t\t\t\tTransformer transformer = factory.newTransformer();\n\t\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\n\t\t\t\tDOMSource source = new DOMSource(doc);\n\t\t\t\tStreamResult outputTarget = new StreamResult(s);\n\t\t\t\ttransformer.transform(source, outputTarget);\n\n\t\t\t\texecuteData = s.toString(\"UTF8\"); //$NON-NLS-1$\n\n\t\t\t} catch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\treturn executeData;\n\t}\n\n\t@Override\n\tpublic String getSummary() {\n\t\treturn MessageFormat.format(Messages.getString(\"ExternalToolAction.Summary\"), //$NON-NLS-1$\n\t\t\t\tnew Object[] { externalToolName });\n\t}\n\n\t@Override\n\tpublic String getTypeName() {\n\t\treturn Messages.getString(\"ExternalToolAction.TypeName\"); //$NON-NLS-1$\n\t}\n\n\t@Override\n\tpublic void initializeFromMemento(String data) {\n\t\tElement root = null;\n\t\tDocumentBuilder parser;\n\t\ttry {\n\t\t\tparser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n\t\t\tparser.setErrorHandler(new DefaultHandler());\n\t\t\troot = parser.parse(new InputSource(new StringReader(data))).getDocumentElement();\n\t\t\tString value = root.getAttribute(\"configName\"); //$NON-NLS-1$\n\t\t\tif (value == null)\n\t\t\t\tthrow new Exception();\n\t\t\texternalToolName = value;\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n}\n",
    "code_after_change": "/*******************************************************************************\n * Copyright (c) 2007, 2012 Nokia and others.\n *\n * This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n *\n * Contributors:\n *     Nokia - initial API and implementation\n *******************************************************************************/\npackage org.eclipse.cdt.debug.ui.breakpointactions;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.StringReader;\nimport java.text.MessageFormat;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.eclipse.cdt.debug.core.CDIDebugModel;\nimport org.eclipse.cdt.debug.core.breakpointactions.AbstractBreakpointAction;\nimport org.eclipse.cdt.debug.internal.core.ICDebugInternalConstants;\nimport org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.IAdaptable;\nimport org.eclipse.core.runtime.IProgressMonitor;\nimport org.eclipse.core.runtime.IStatus;\nimport org.eclipse.core.runtime.MultiStatus;\nimport org.eclipse.core.runtime.Status;\nimport org.eclipse.core.runtime.jobs.Job;\nimport org.eclipse.debug.core.DebugPlugin;\nimport org.eclipse.debug.core.ILaunchConfiguration;\nimport org.eclipse.debug.core.ILaunchManager;\nimport org.eclipse.debug.core.model.IBreakpoint;\nimport org.eclipse.debug.ui.DebugUITools;\nimport org.eclipse.ui.progress.WorkbenchJob;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.helpers.DefaultHandler;\n\npublic class ExternalToolAction extends AbstractBreakpointAction {\n\n\tprivate String externalToolName = \"\"; //$NON-NLS-1$\n\n\t@Override\n\tpublic IStatus execute(final IBreakpoint breakpoint, final IAdaptable context, final IProgressMonitor monitor) {\n\t\tJob uiJob = new WorkbenchJob(\"ExternalToolAction\") { //$NON-NLS-1$\n\t\t\t{\n\t\t\t\tsetPriority(INTERACTIVE);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic IStatus runInUIThread(IProgressMonitor monitor) {\n\t\t\t\treturn executeInUIThread(breakpoint, context, monitor);\n\t\t\t}\n\t\t};\n\t\tuiJob.schedule();\n\t\ttry {\n\t\t\tuiJob.join();\n\t\t} catch (InterruptedException e) {\n\t\t\treturn Status.CANCEL_STATUS;\n\t\t}\n\t\treturn uiJob.getResult();\n\t}\n\n\tprivate IStatus executeInUIThread(IBreakpoint breakpoint, IAdaptable context, IProgressMonitor monitor) {\n\t\tIStatus errorStatus = null;\n\t\tILaunchManager lcm = DebugPlugin.getDefault().getLaunchManager();\n\t\ttry {\n\t\t\tboolean launched = false;\n\t\t\tILaunchConfiguration[] launchConfigurations = lcm.getLaunchConfigurations();\n\t\t\tfor (int i = 0; i < launchConfigurations.length; i++) {\n\t\t\t\tif (launchConfigurations[i].getName().equals(externalToolName)) {\n\t\t\t\t\tDebugUITools.launch(launchConfigurations[i], ILaunchManager.RUN_MODE);\n\t\t\t\t\tlaunched = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!launched) {\n\t\t\t\tString errorMsg = MessageFormat.format(Messages.getString(\"ExternalToolAction.error.0\"), //$NON-NLS-1$\n\t\t\t\t\t\tnew Object[] { externalToolName });\n\t\t\t\terrorStatus = new Status(IStatus.ERROR, CDIDebugModel.getPluginIdentifier(),\n\t\t\t\t\t\tICDebugInternalConstants.STATUS_CODE_ERROR, errorMsg, null);\n\t\t\t}\n\n\t\t} catch (CoreException e) {\n\t\t\terrorStatus = e.getStatus();\n\t\t} catch (Exception e) {\n\t\t\terrorStatus = new Status(IStatus.ERROR, CDIDebugModel.getPluginIdentifier(),\n\t\t\t\t\tICDebugInternalConstants.STATUS_CODE_ERROR, e.getMessage(), e);\n\t\t}\n\n\t\tif (errorStatus != null) {\n\t\t\tString errorMsg = MessageFormat.format(Messages.getString(\"ExternalToolAction.error.1\"), //$NON-NLS-1$\n\t\t\t\t\tnew Object[] { externalToolName });\n\t\t\tMultiStatus ms = new MultiStatus(CDIDebugModel.getPluginIdentifier(),\n\t\t\t\t\tICDebugInternalConstants.STATUS_CODE_ERROR, errorMsg, null);\n\t\t\tms.add(errorStatus);\n\t\t\treturn ms;\n\t\t}\n\n\t\treturn Status.OK_STATUS;\n\t}\n\n\t@Override\n\tpublic String getDefaultName() {\n\t\treturn \"Untitled External Tool Action\"; //$NON-NLS-1$\n\t}\n\n\tpublic String getExternalToolName() {\n\t\treturn externalToolName;\n\t}\n\n\tpublic void setExternalToolName(String launchConfigName) {\n\t\tthis.externalToolName = launchConfigName;\n\t}\n\n\t@Override\n\tpublic String getIdentifier() {\n\t\treturn \"org.eclipse.cdt.debug.ui.breakpointactions.ExternalToolAction\"; //$NON-NLS-1$\n\t}\n\n\t@Override\n\tpublic String getMemento() {\n\t\tString executeData = \"\"; //$NON-NLS-1$\n\t\tif (externalToolName != null) {\n\t\t\ttry {\n\t\t\t\tDocumentBuilder docBuilder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n\t\t\t\tDocument doc = docBuilder.newDocument();\n\n\t\t\t\tElement rootElement = doc.createElement(\"launchConfigName\"); //$NON-NLS-1$\n\t\t\t\trootElement.setAttribute(\"configName\", externalToolName); //$NON-NLS-1$\n\n\t\t\t\tdoc.appendChild(rootElement);\n\n\t\t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n\n\t\t\t\tTransformerFactory factory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n\t\t\t\tTransformer transformer = factory.newTransformer();\n\t\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\n\t\t\t\tDOMSource source = new DOMSource(doc);\n\t\t\t\tStreamResult outputTarget = new StreamResult(s);\n\t\t\t\ttransformer.transform(source, outputTarget);\n\n\t\t\t\texecuteData = s.toString(\"UTF8\"); //$NON-NLS-1$\n\n\t\t\t} catch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\treturn executeData;\n\t}\n\n\t@Override\n\tpublic String getSummary() {\n\t\treturn MessageFormat.format(Messages.getString(\"ExternalToolAction.Summary\"), //$NON-NLS-1$\n\t\t\t\tnew Object[] { externalToolName });\n\t}\n\n\t@Override\n\tpublic String getTypeName() {\n\t\treturn Messages.getString(\"ExternalToolAction.TypeName\"); //$NON-NLS-1$\n\t}\n\n\t@Override\n\tpublic void initializeFromMemento(String data) {\n\t\tElement root = null;\n\t\tDocumentBuilder parser;\n\t\ttry {\n\t\t\tparser = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n\t\t\tparser.setErrorHandler(new DefaultHandler());\n\t\t\troot = parser.parse(new InputSource(new StringReader(data))).getDocumentElement();\n\t\t\tString value = root.getAttribute(\"configName\"); //$NON-NLS-1$\n\t\t\tif (value == null)\n\t\t\t\tthrow new Exception();\n\t\t\texternalToolName = value;\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n}\n",
    "patch": "@@ -18,7 +18,6 @@\n import java.text.MessageFormat;\n \n import javax.xml.parsers.DocumentBuilder;\n-import javax.xml.parsers.DocumentBuilderFactory;\n import javax.xml.transform.OutputKeys;\n import javax.xml.transform.Transformer;\n import javax.xml.transform.TransformerFactory;\n@@ -28,6 +27,7 @@\n import org.eclipse.cdt.debug.core.CDIDebugModel;\n import org.eclipse.cdt.debug.core.breakpointactions.AbstractBreakpointAction;\n import org.eclipse.cdt.debug.internal.core.ICDebugInternalConstants;\n+import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n import org.eclipse.core.runtime.CoreException;\n import org.eclipse.core.runtime.IAdaptable;\n import org.eclipse.core.runtime.IProgressMonitor;\n@@ -132,10 +132,8 @@ public String getIdentifier() {\n \tpublic String getMemento() {\n \t\tString executeData = \"\"; //$NON-NLS-1$\n \t\tif (externalToolName != null) {\n-\t\t\tDocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();\n-\t\t\tDocumentBuilder docBuilder = null;\n \t\t\ttry {\n-\t\t\t\tdocBuilder = dfactory.newDocumentBuilder();\n+\t\t\t\tDocumentBuilder docBuilder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\t\tDocument doc = docBuilder.newDocument();\n \n \t\t\t\tElement rootElement = doc.createElement(\"launchConfigName\"); //$NON-NLS-1$\n@@ -145,7 +143,7 @@ public String getMemento() {\n \n \t\t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n \n-\t\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n+\t\t\t\tTransformerFactory factory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n \t\t\t\tTransformer transformer = factory.newTransformer();\n \t\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n \t\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n@@ -179,7 +177,7 @@ public void initializeFromMemento(String data) {\n \t\tElement root = null;\n \t\tDocumentBuilder parser;\n \t\ttry {\n-\t\t\tparser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n+\t\t\tparser = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tparser.setErrorHandler(new DefaultHandler());\n \t\t\troot = parser.parse(new InputSource(new StringReader(data))).getDocumentElement();\n \t\t\tString value = root.getAttribute(\"configName\"); //$NON-NLS-1$",
    "function_modified_lines": {
      "added": [
        "import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n"
      ],
      "deleted": [
        "import javax.xml.parsers.DocumentBuilderFactory;\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "In Eclipse IDE versions < 2023-09 (4.29) some files with xml content are parsed vulnerable against all sorts of XXE attacks. The user just needs to open any evil project or update an open project with a vulnerable file (for example for review a foreign repository or patch).\n",
    "id": 12879
  },
  {
    "cve_id": "CVE-2023-4218",
    "code_before_change": "{\n\t\t\tDocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();\n\t\t\tDocumentBuilder docBuilder = null;\n\t\t\ttry {\n\t\t\t\tdocBuilder = dfactory.newDocumentBuilder();\n\t\t\t\tDocument doc = docBuilder.newDocument();\n\n\t\t\t\tElement rootElement = doc.createElement(\"launchConfigName\"); //$NON-NLS-1$\n\t\t\t\trootElement.setAttribute(\"configName\", externalToolName); //$NON-NLS-1$\n\n\t\t\t\tdoc.appendChild(rootElement);\n\n\t\t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n\n\t\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n\t\t\t\tTransformer transformer = factory.newTransformer();\n\t\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\n\t\t\t\tDOMSource source = new DOMSource(doc);\n\t\t\t\tStreamResult outputTarget = new StreamResult(s);\n\t\t\t\ttransformer.transform(source, outputTarget);\n\n\t\t\t\texecuteData = s.toString(\"UTF8\"); //$NON-NLS-1$\n\n\t\t\t} catch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}",
    "code_after_change": "{\n\t\t\t\tDocumentBuilder docBuilder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n\t\t\t\tDocument doc = docBuilder.newDocument();\n\n\t\t\t\tElement rootElement = doc.createElement(\"launchConfigName\"); //$NON-NLS-1$\n\t\t\t\trootElement.setAttribute(\"configName\", externalToolName); //$NON-NLS-1$\n\n\t\t\t\tdoc.appendChild(rootElement);\n\n\t\t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n\n\t\t\t\tTransformerFactory factory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n\t\t\t\tTransformer transformer = factory.newTransformer();\n\t\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\n\t\t\t\tDOMSource source = new DOMSource(doc);\n\t\t\t\tStreamResult outputTarget = new StreamResult(s);\n\t\t\t\ttransformer.transform(source, outputTarget);\n\n\t\t\t\texecuteData = s.toString(\"UTF8\"); //$NON-NLS-1$\n\n\t\t\t}",
    "patch": "@@ -18,7 +18,6 @@\n import java.text.MessageFormat;\n \n import javax.xml.parsers.DocumentBuilder;\n-import javax.xml.parsers.DocumentBuilderFactory;\n import javax.xml.transform.OutputKeys;\n import javax.xml.transform.Transformer;\n import javax.xml.transform.TransformerFactory;\n@@ -28,6 +27,7 @@\n import org.eclipse.cdt.debug.core.CDIDebugModel;\n import org.eclipse.cdt.debug.core.breakpointactions.AbstractBreakpointAction;\n import org.eclipse.cdt.debug.internal.core.ICDebugInternalConstants;\n+import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n import org.eclipse.core.runtime.CoreException;\n import org.eclipse.core.runtime.IAdaptable;\n import org.eclipse.core.runtime.IProgressMonitor;\n@@ -132,10 +132,8 @@ public String getIdentifier() {\n \tpublic String getMemento() {\n \t\tString executeData = \"\"; //$NON-NLS-1$\n \t\tif (externalToolName != null) {\n-\t\t\tDocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();\n-\t\t\tDocumentBuilder docBuilder = null;\n \t\t\ttry {\n-\t\t\t\tdocBuilder = dfactory.newDocumentBuilder();\n+\t\t\t\tDocumentBuilder docBuilder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\t\tDocument doc = docBuilder.newDocument();\n \n \t\t\t\tElement rootElement = doc.createElement(\"launchConfigName\"); //$NON-NLS-1$\n@@ -145,7 +143,7 @@ public String getMemento() {\n \n \t\t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n \n-\t\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n+\t\t\t\tTransformerFactory factory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n \t\t\t\tTransformer transformer = factory.newTransformer();\n \t\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n \t\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n@@ -179,7 +177,7 @@ public void initializeFromMemento(String data) {\n \t\tElement root = null;\n \t\tDocumentBuilder parser;\n \t\ttry {\n-\t\t\tparser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n+\t\t\tparser = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tparser.setErrorHandler(new DefaultHandler());\n \t\t\troot = parser.parse(new InputSource(new StringReader(data))).getDocumentElement();\n \t\t\tString value = root.getAttribute(\"configName\"); //$NON-NLS-1$",
    "function_modified_lines": {
      "added": [
        "\t\t\t\tDocumentBuilder docBuilder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n",
        "\t\t\t\tTransformerFactory factory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n"
      ],
      "deleted": [
        "\t\t\tDocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();\n",
        "\t\t\tDocumentBuilder docBuilder = null;\n",
        "\t\t\t\tdocBuilder = dfactory.newDocumentBuilder();\n",
        "\t\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "In Eclipse IDE versions < 2023-09 (4.29) some files with xml content are parsed vulnerable against all sorts of XXE attacks. The user just needs to open any evil project or update an open project with a vulnerable file (for example for review a foreign repository or patch).\n",
    "id": 12880
  },
  {
    "cve_id": "CVE-2023-4218",
    "code_before_change": "/*******************************************************************************\n * Copyright (c) 2007, 2015 Nokia and others.\n *\n * This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n *\n * Contributors:\n *     Nokia - initial API and implementation\n *******************************************************************************/\npackage org.eclipse.cdt.debug.ui.breakpointactions;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.StringReader;\nimport java.text.MessageFormat;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.eclipse.cdt.debug.core.CDIDebugModel;\nimport org.eclipse.cdt.debug.core.breakpointactions.AbstractBreakpointAction;\nimport org.eclipse.cdt.debug.core.breakpointactions.ILogActionEnabler;\nimport org.eclipse.cdt.debug.internal.core.ICDebugInternalConstants;\nimport org.eclipse.core.runtime.IAdaptable;\nimport org.eclipse.core.runtime.IProgressMonitor;\nimport org.eclipse.core.runtime.IStatus;\nimport org.eclipse.core.runtime.Status;\nimport org.eclipse.debug.core.model.IBreakpoint;\nimport org.eclipse.ui.console.ConsolePlugin;\nimport org.eclipse.ui.console.IConsole;\nimport org.eclipse.ui.console.MessageConsole;\nimport org.eclipse.ui.console.MessageConsoleStream;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.helpers.DefaultHandler;\n\npublic class LogAction extends AbstractBreakpointAction {\n\n\tprivate String message = \"\"; //$NON-NLS-1$\n\tprivate boolean evaluateExpression;\n\tprivate MessageConsole console;\n\n\tpublic boolean isEvaluateExpression() {\n\t\treturn evaluateExpression;\n\t}\n\n\tpublic void setEvaluateExpression(boolean evaluateExpression) {\n\t\tthis.evaluateExpression = evaluateExpression;\n\t}\n\n\t@Override\n\tpublic IStatus execute(IBreakpoint breakpoint, IAdaptable context, IProgressMonitor monitor) {\n\t\tIStatus result = Status.OK_STATUS;\n\t\ttry {\n\t\t\topenConsole(Messages.getString(\"LogAction.ConsoleTitle\")); //$NON-NLS-1$\n\t\t\tString logMessage = getMessage();\n\n\t\t\tif (isEvaluateExpression()) {\n\t\t\t\tILogActionEnabler enabler = context.getAdapter(ILogActionEnabler.class);\n\t\t\t\tif (enabler != null)\n\t\t\t\t\tlogMessage = enabler.evaluateExpression(logMessage);\n\t\t\t}\n\n\t\t\tMessageConsoleStream stream = console.newMessageStream();\n\t\t\tstream.println(logMessage);\n\t\t\tstream.close();\n\t\t} catch (Exception e) {\n\t\t\tString errorMsg = MessageFormat.format(Messages.getString(\"LogAction.error.0\"), //$NON-NLS-1$\n\t\t\t\t\tnew Object[] { getSummary() });\n\t\t\tresult = new Status(IStatus.ERROR, CDIDebugModel.getPluginIdentifier(),\n\t\t\t\t\tICDebugInternalConstants.STATUS_CODE_ERROR, errorMsg, e);\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate void openConsole(String consoleName) {\n\t\t// add it if necessary\n\t\tboolean found = false;\n\n\t\tIConsole[] consoles = ConsolePlugin.getDefault().getConsoleManager().getConsoles();\n\t\tfor (int i = 0; i < consoles.length; i++) {\n\t\t\tif (consoleName.equals(consoles[i].getName())) {\n\t\t\t\tconsole = (MessageConsole) consoles[i];\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!found) {\n\t\t\tconsole = new MessageConsole(consoleName, null);\n\t\t\tConsolePlugin.getDefault().getConsoleManager().addConsoles(new IConsole[] { console });\n\t\t}\n\n\t\tConsolePlugin.getDefault().getConsoleManager().showConsoleView(console);\n\t}\n\n\t@Override\n\tpublic String getDefaultName() {\n\t\treturn Messages.getString(\"LogAction.UntitledName\"); //$NON-NLS-1$\n\t}\n\n\t@Override\n\tpublic String getIdentifier() {\n\t\treturn \"org.eclipse.cdt.debug.ui.breakpointactions.LogAction\"; //$NON-NLS-1$\n\t}\n\n\t@Override\n\tpublic String getMemento() {\n\t\tString logData = \"\"; //$NON-NLS-1$\n\n\t\tDocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();\n\t\tDocumentBuilder docBuilder = null;\n\t\ttry {\n\t\t\tdocBuilder = dfactory.newDocumentBuilder();\n\t\t\tDocument doc = docBuilder.newDocument();\n\n\t\t\tElement rootElement = doc.createElement(\"logData\"); //$NON-NLS-1$\n\t\t\trootElement.setAttribute(\"message\", message); //$NON-NLS-1$\n\t\t\trootElement.setAttribute(\"evalExpr\", Boolean.toString(evaluateExpression)); //$NON-NLS-1$\n\n\t\t\tdoc.appendChild(rootElement);\n\n\t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n\n\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n\t\t\tTransformer transformer = factory.newTransformer();\n\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\n\t\t\tDOMSource source = new DOMSource(doc);\n\t\t\tStreamResult outputTarget = new StreamResult(s);\n\t\t\ttransformer.transform(source, outputTarget);\n\n\t\t\tlogData = s.toString(\"UTF8\"); //$NON-NLS-1$\n\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn logData;\n\t}\n\n\tpublic String getMessage() {\n\t\treturn message;\n\t}\n\n\tpublic void setMessage(String message) {\n\t\tthis.message = message;\n\t}\n\n\t@Override\n\tpublic String getSummary() {\n\t\tString summary = getMessage();\n\t\tif (summary.length() > 32)\n\t\t\tsummary = getMessage().substring(0, 32);\n\t\treturn summary;\n\t}\n\n\t@Override\n\tpublic String getTypeName() {\n\t\treturn Messages.getString(\"LogAction.TypeName\"); //$NON-NLS-1$\n\t}\n\n\t@Override\n\tpublic void initializeFromMemento(String data) {\n\t\tElement root = null;\n\t\tDocumentBuilder parser;\n\t\ttry {\n\t\t\tparser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n\t\t\tparser.setErrorHandler(new DefaultHandler());\n\t\t\troot = parser.parse(new InputSource(new StringReader(data))).getDocumentElement();\n\t\t\tString value = root.getAttribute(\"message\"); //$NON-NLS-1$\n\t\t\tif (value == null)\n\t\t\t\tthrow new Exception();\n\t\t\tmessage = value;\n\t\t\tvalue = root.getAttribute(\"evalExpr\"); //$NON-NLS-1$\n\t\t\tif (value == null)\n\t\t\t\tthrow new Exception();\n\t\t\tevaluateExpression = Boolean.valueOf(value).booleanValue();\n\t\t\tvalue = root.getAttribute(\"resume\"); //$NON-NLS-1$\n\t\t\tif (value == null)\n\t\t\t\tthrow new Exception();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n}\n",
    "code_after_change": "/*******************************************************************************\n * Copyright (c) 2007, 2015 Nokia and others.\n *\n * This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n *\n * Contributors:\n *     Nokia - initial API and implementation\n *******************************************************************************/\npackage org.eclipse.cdt.debug.ui.breakpointactions;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.StringReader;\nimport java.text.MessageFormat;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.eclipse.cdt.debug.core.CDIDebugModel;\nimport org.eclipse.cdt.debug.core.breakpointactions.AbstractBreakpointAction;\nimport org.eclipse.cdt.debug.core.breakpointactions.ILogActionEnabler;\nimport org.eclipse.cdt.debug.internal.core.ICDebugInternalConstants;\nimport org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\nimport org.eclipse.core.runtime.IAdaptable;\nimport org.eclipse.core.runtime.IProgressMonitor;\nimport org.eclipse.core.runtime.IStatus;\nimport org.eclipse.core.runtime.Status;\nimport org.eclipse.debug.core.model.IBreakpoint;\nimport org.eclipse.ui.console.ConsolePlugin;\nimport org.eclipse.ui.console.IConsole;\nimport org.eclipse.ui.console.MessageConsole;\nimport org.eclipse.ui.console.MessageConsoleStream;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.helpers.DefaultHandler;\n\npublic class LogAction extends AbstractBreakpointAction {\n\n\tprivate String message = \"\"; //$NON-NLS-1$\n\tprivate boolean evaluateExpression;\n\tprivate MessageConsole console;\n\n\tpublic boolean isEvaluateExpression() {\n\t\treturn evaluateExpression;\n\t}\n\n\tpublic void setEvaluateExpression(boolean evaluateExpression) {\n\t\tthis.evaluateExpression = evaluateExpression;\n\t}\n\n\t@Override\n\tpublic IStatus execute(IBreakpoint breakpoint, IAdaptable context, IProgressMonitor monitor) {\n\t\tIStatus result = Status.OK_STATUS;\n\t\ttry {\n\t\t\topenConsole(Messages.getString(\"LogAction.ConsoleTitle\")); //$NON-NLS-1$\n\t\t\tString logMessage = getMessage();\n\n\t\t\tif (isEvaluateExpression()) {\n\t\t\t\tILogActionEnabler enabler = context.getAdapter(ILogActionEnabler.class);\n\t\t\t\tif (enabler != null)\n\t\t\t\t\tlogMessage = enabler.evaluateExpression(logMessage);\n\t\t\t}\n\n\t\t\tMessageConsoleStream stream = console.newMessageStream();\n\t\t\tstream.println(logMessage);\n\t\t\tstream.close();\n\t\t} catch (Exception e) {\n\t\t\tString errorMsg = MessageFormat.format(Messages.getString(\"LogAction.error.0\"), //$NON-NLS-1$\n\t\t\t\t\tnew Object[] { getSummary() });\n\t\t\tresult = new Status(IStatus.ERROR, CDIDebugModel.getPluginIdentifier(),\n\t\t\t\t\tICDebugInternalConstants.STATUS_CODE_ERROR, errorMsg, e);\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate void openConsole(String consoleName) {\n\t\t// add it if necessary\n\t\tboolean found = false;\n\n\t\tIConsole[] consoles = ConsolePlugin.getDefault().getConsoleManager().getConsoles();\n\t\tfor (int i = 0; i < consoles.length; i++) {\n\t\t\tif (consoleName.equals(consoles[i].getName())) {\n\t\t\t\tconsole = (MessageConsole) consoles[i];\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!found) {\n\t\t\tconsole = new MessageConsole(consoleName, null);\n\t\t\tConsolePlugin.getDefault().getConsoleManager().addConsoles(new IConsole[] { console });\n\t\t}\n\n\t\tConsolePlugin.getDefault().getConsoleManager().showConsoleView(console);\n\t}\n\n\t@Override\n\tpublic String getDefaultName() {\n\t\treturn Messages.getString(\"LogAction.UntitledName\"); //$NON-NLS-1$\n\t}\n\n\t@Override\n\tpublic String getIdentifier() {\n\t\treturn \"org.eclipse.cdt.debug.ui.breakpointactions.LogAction\"; //$NON-NLS-1$\n\t}\n\n\t@Override\n\tpublic String getMemento() {\n\t\tString logData = \"\"; //$NON-NLS-1$\n\n\t\ttry {\n\t\t\tDocumentBuilder docBuilder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n\t\t\tDocument doc = docBuilder.newDocument();\n\n\t\t\tElement rootElement = doc.createElement(\"logData\"); //$NON-NLS-1$\n\t\t\trootElement.setAttribute(\"message\", message); //$NON-NLS-1$\n\t\t\trootElement.setAttribute(\"evalExpr\", Boolean.toString(evaluateExpression)); //$NON-NLS-1$\n\n\t\t\tdoc.appendChild(rootElement);\n\n\t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n\n\t\t\tTransformerFactory factory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n\t\t\tTransformer transformer = factory.newTransformer();\n\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\n\t\t\tDOMSource source = new DOMSource(doc);\n\t\t\tStreamResult outputTarget = new StreamResult(s);\n\t\t\ttransformer.transform(source, outputTarget);\n\n\t\t\tlogData = s.toString(\"UTF8\"); //$NON-NLS-1$\n\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn logData;\n\t}\n\n\tpublic String getMessage() {\n\t\treturn message;\n\t}\n\n\tpublic void setMessage(String message) {\n\t\tthis.message = message;\n\t}\n\n\t@Override\n\tpublic String getSummary() {\n\t\tString summary = getMessage();\n\t\tif (summary.length() > 32)\n\t\t\tsummary = getMessage().substring(0, 32);\n\t\treturn summary;\n\t}\n\n\t@Override\n\tpublic String getTypeName() {\n\t\treturn Messages.getString(\"LogAction.TypeName\"); //$NON-NLS-1$\n\t}\n\n\t@Override\n\tpublic void initializeFromMemento(String data) {\n\t\tElement root = null;\n\t\tDocumentBuilder parser;\n\t\ttry {\n\t\t\tparser = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n\t\t\tparser.setErrorHandler(new DefaultHandler());\n\t\t\troot = parser.parse(new InputSource(new StringReader(data))).getDocumentElement();\n\t\t\tString value = root.getAttribute(\"message\"); //$NON-NLS-1$\n\t\t\tif (value == null)\n\t\t\t\tthrow new Exception();\n\t\t\tmessage = value;\n\t\t\tvalue = root.getAttribute(\"evalExpr\"); //$NON-NLS-1$\n\t\t\tif (value == null)\n\t\t\t\tthrow new Exception();\n\t\t\tevaluateExpression = Boolean.valueOf(value).booleanValue();\n\t\t\tvalue = root.getAttribute(\"resume\"); //$NON-NLS-1$\n\t\t\tif (value == null)\n\t\t\t\tthrow new Exception();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n}\n",
    "patch": "@@ -18,7 +18,6 @@\n import java.text.MessageFormat;\n \n import javax.xml.parsers.DocumentBuilder;\n-import javax.xml.parsers.DocumentBuilderFactory;\n import javax.xml.transform.OutputKeys;\n import javax.xml.transform.Transformer;\n import javax.xml.transform.TransformerFactory;\n@@ -29,6 +28,7 @@\n import org.eclipse.cdt.debug.core.breakpointactions.AbstractBreakpointAction;\n import org.eclipse.cdt.debug.core.breakpointactions.ILogActionEnabler;\n import org.eclipse.cdt.debug.internal.core.ICDebugInternalConstants;\n+import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n import org.eclipse.core.runtime.IAdaptable;\n import org.eclipse.core.runtime.IProgressMonitor;\n import org.eclipse.core.runtime.IStatus;\n@@ -117,10 +117,8 @@ public String getIdentifier() {\n \tpublic String getMemento() {\n \t\tString logData = \"\"; //$NON-NLS-1$\n \n-\t\tDocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();\n-\t\tDocumentBuilder docBuilder = null;\n \t\ttry {\n-\t\t\tdocBuilder = dfactory.newDocumentBuilder();\n+\t\t\tDocumentBuilder docBuilder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tDocument doc = docBuilder.newDocument();\n \n \t\t\tElement rootElement = doc.createElement(\"logData\"); //$NON-NLS-1$\n@@ -131,7 +129,7 @@ public String getMemento() {\n \n \t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n \n-\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n+\t\t\tTransformerFactory factory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n \t\t\tTransformer transformer = factory.newTransformer();\n \t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n \t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n@@ -174,7 +172,7 @@ public void initializeFromMemento(String data) {\n \t\tElement root = null;\n \t\tDocumentBuilder parser;\n \t\ttry {\n-\t\t\tparser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n+\t\t\tparser = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tparser.setErrorHandler(new DefaultHandler());\n \t\t\troot = parser.parse(new InputSource(new StringReader(data))).getDocumentElement();\n \t\t\tString value = root.getAttribute(\"message\"); //$NON-NLS-1$",
    "function_modified_lines": {
      "added": [
        "import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n"
      ],
      "deleted": [
        "import javax.xml.parsers.DocumentBuilderFactory;\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "In Eclipse IDE versions < 2023-09 (4.29) some files with xml content are parsed vulnerable against all sorts of XXE attacks. The user just needs to open any evil project or update an open project with a vulnerable file (for example for review a foreign repository or patch).\n",
    "id": 12881
  },
  {
    "cve_id": "CVE-2023-4218",
    "code_before_change": "{\n\t\tString logData = \"\"; //$NON-NLS-1$\n\n\t\tDocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();\n\t\tDocumentBuilder docBuilder = null;\n\t\ttry {\n\t\t\tdocBuilder = dfactory.newDocumentBuilder();\n\t\t\tDocument doc = docBuilder.newDocument();\n\n\t\t\tElement rootElement = doc.createElement(\"logData\"); //$NON-NLS-1$\n\t\t\trootElement.setAttribute(\"message\", message); //$NON-NLS-1$\n\t\t\trootElement.setAttribute(\"evalExpr\", Boolean.toString(evaluateExpression)); //$NON-NLS-1$\n\n\t\t\tdoc.appendChild(rootElement);\n\n\t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n\n\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n\t\t\tTransformer transformer = factory.newTransformer();\n\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\n\t\t\tDOMSource source = new DOMSource(doc);\n\t\t\tStreamResult outputTarget = new StreamResult(s);\n\t\t\ttransformer.transform(source, outputTarget);\n\n\t\t\tlogData = s.toString(\"UTF8\"); //$NON-NLS-1$\n\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn logData;\n\t}",
    "code_after_change": "{\n\t\t\tDocumentBuilder docBuilder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n\t\t\tDocument doc = docBuilder.newDocument();\n\n\t\t\tElement rootElement = doc.createElement(\"logData\"); //$NON-NLS-1$\n\t\t\trootElement.setAttribute(\"message\", message); //$NON-NLS-1$\n\t\t\trootElement.setAttribute(\"evalExpr\", Boolean.toString(evaluateExpression)); //$NON-NLS-1$\n\n\t\t\tdoc.appendChild(rootElement);\n\n\t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n\n\t\t\tTransformerFactory factory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n\t\t\tTransformer transformer = factory.newTransformer();\n\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\n\t\t\tDOMSource source = new DOMSource(doc);\n\t\t\tStreamResult outputTarget = new StreamResult(s);\n\t\t\ttransformer.transform(source, outputTarget);\n\n\t\t\tlogData = s.toString(\"UTF8\"); //$NON-NLS-1$\n\n\t\t}",
    "patch": "@@ -18,7 +18,6 @@\n import java.text.MessageFormat;\n \n import javax.xml.parsers.DocumentBuilder;\n-import javax.xml.parsers.DocumentBuilderFactory;\n import javax.xml.transform.OutputKeys;\n import javax.xml.transform.Transformer;\n import javax.xml.transform.TransformerFactory;\n@@ -29,6 +28,7 @@\n import org.eclipse.cdt.debug.core.breakpointactions.AbstractBreakpointAction;\n import org.eclipse.cdt.debug.core.breakpointactions.ILogActionEnabler;\n import org.eclipse.cdt.debug.internal.core.ICDebugInternalConstants;\n+import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n import org.eclipse.core.runtime.IAdaptable;\n import org.eclipse.core.runtime.IProgressMonitor;\n import org.eclipse.core.runtime.IStatus;\n@@ -117,10 +117,8 @@ public String getIdentifier() {\n \tpublic String getMemento() {\n \t\tString logData = \"\"; //$NON-NLS-1$\n \n-\t\tDocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();\n-\t\tDocumentBuilder docBuilder = null;\n \t\ttry {\n-\t\t\tdocBuilder = dfactory.newDocumentBuilder();\n+\t\t\tDocumentBuilder docBuilder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tDocument doc = docBuilder.newDocument();\n \n \t\t\tElement rootElement = doc.createElement(\"logData\"); //$NON-NLS-1$\n@@ -131,7 +129,7 @@ public String getMemento() {\n \n \t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n \n-\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n+\t\t\tTransformerFactory factory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n \t\t\tTransformer transformer = factory.newTransformer();\n \t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n \t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n@@ -174,7 +172,7 @@ public void initializeFromMemento(String data) {\n \t\tElement root = null;\n \t\tDocumentBuilder parser;\n \t\ttry {\n-\t\t\tparser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n+\t\t\tparser = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tparser.setErrorHandler(new DefaultHandler());\n \t\t\troot = parser.parse(new InputSource(new StringReader(data))).getDocumentElement();\n \t\t\tString value = root.getAttribute(\"message\"); //$NON-NLS-1$",
    "function_modified_lines": {
      "added": [
        "\t\t\tDocumentBuilder docBuilder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n",
        "\t\t\tTransformerFactory factory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n"
      ],
      "deleted": [
        "\t\tDocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();\n",
        "\t\tDocumentBuilder docBuilder = null;\n",
        "\t\t\tdocBuilder = dfactory.newDocumentBuilder();\n",
        "\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "In Eclipse IDE versions < 2023-09 (4.29) some files with xml content are parsed vulnerable against all sorts of XXE attacks. The user just needs to open any evil project or update an open project with a vulnerable file (for example for review a foreign repository or patch).\n",
    "id": 12882
  },
  {
    "cve_id": "CVE-2023-4218",
    "code_before_change": "/*******************************************************************************\n * Copyright (c) 2007, 2015 Nokia and others.\n *\n * This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n *\n * Contributors:\n *     Nokia - initial API and implementation\n *******************************************************************************/\npackage org.eclipse.cdt.debug.ui.breakpointactions;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.StringReader;\nimport java.text.MessageFormat;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.eclipse.cdt.debug.core.CDIDebugModel;\nimport org.eclipse.cdt.debug.core.breakpointactions.AbstractBreakpointAction;\nimport org.eclipse.cdt.debug.core.breakpointactions.IResumeActionEnabler;\nimport org.eclipse.cdt.debug.internal.core.ICDebugInternalConstants;\nimport org.eclipse.cdt.debug.internal.ui.IInternalCDebugUIConstants;\nimport org.eclipse.cdt.debug.ui.CDebugUIPlugin;\nimport org.eclipse.core.runtime.IAdaptable;\nimport org.eclipse.core.runtime.IProgressMonitor;\nimport org.eclipse.core.runtime.IStatus;\nimport org.eclipse.core.runtime.MultiStatus;\nimport org.eclipse.core.runtime.Status;\nimport org.eclipse.debug.core.model.IBreakpoint;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.helpers.DefaultHandler;\n\npublic class ResumeAction extends AbstractBreakpointAction {\n\n\tfinal static int INCRIMENT_MSEC = 100;\n\n\tint pauseTime = 0;\n\n\t@Override\n\tpublic IStatus execute(IBreakpoint breakpoint, IAdaptable context, IProgressMonitor monitor) {\n\t\tIStatus errorStatus = null;\n\t\tlong endTime = System.currentTimeMillis() + getPauseTime() * 1000;\n\t\tIResumeActionEnabler enabler = context.getAdapter(IResumeActionEnabler.class);\n\n\t\tif (enabler != null) {\n\t\t\ttry {\n\t\t\t\tmonitor.beginTask(getName(), getPauseTime() * 1000 / INCRIMENT_MSEC);\n\n\t\t\t\tlong currentTime = System.currentTimeMillis();\n\t\t\t\twhile (!monitor.isCanceled() && currentTime < endTime) {\n\t\t\t\t\tmonitor.setTaskName(MessageFormat.format(Messages.getString(\"ResumeAction.SummaryResumeTime\"), //$NON-NLS-1$\n\t\t\t\t\t\t\tnew Object[] { Long.valueOf((endTime - currentTime) / 1000) })); //)\n\t\t\t\t\tmonitor.worked(1);\n\t\t\t\t\tThread.sleep(INCRIMENT_MSEC);\n\t\t\t\t\tcurrentTime = System.currentTimeMillis();\n\t\t\t\t}\n\n\t\t\t\tif (!monitor.isCanceled()) {\n\t\t\t\t\tmonitor.setTaskName(Messages.getString(\"ResumeAction.SummaryImmediately\")); //$NON-NLS-1$)\n\t\t\t\t\tenabler.resume();\n\t\t\t\t}\n\t\t\t\tmonitor.worked(1);\n\t\t\t} catch (Exception e) {\n\t\t\t\terrorStatus = new Status(IStatus.ERROR, CDIDebugModel.getPluginIdentifier(),\n\t\t\t\t\t\tICDebugInternalConstants.STATUS_CODE_ERROR, e.getMessage(), e);\n\t\t\t}\n\t\t} else\n\t\t\terrorStatus = new Status(IStatus.ERROR, CDebugUIPlugin.getUniqueIdentifier(),\n\t\t\t\t\tIInternalCDebugUIConstants.INTERNAL_ERROR, Messages.getString(\"ResumeAction.error.0\"), null); //$NON-NLS-1$\n\n\t\tif (errorStatus != null) {\n\t\t\tMultiStatus ms = new MultiStatus(CDIDebugModel.getPluginIdentifier(),\n\t\t\t\t\tICDebugInternalConstants.STATUS_CODE_ERROR, Messages.getString(\"ResumeAction.error.1\"), null); //$NON-NLS-1$\n\t\t\tms.add(errorStatus);\n\t\t\terrorStatus = ms;\n\t\t} else {\n\t\t\terrorStatus = monitor.isCanceled() ? Status.CANCEL_STATUS : Status.OK_STATUS;\n\t\t}\n\t\treturn errorStatus;\n\t}\n\n\t@Override\n\tpublic String getDefaultName() {\n\t\treturn Messages.getString(\"ResumeAction.UntitledName\"); //$NON-NLS-1$\n\t}\n\n\tpublic int getPauseTime() {\n\t\treturn pauseTime;\n\t}\n\n\tpublic void setPauseTime(int pauseTime) {\n\t\tthis.pauseTime = pauseTime;\n\t}\n\n\t@Override\n\tpublic String getIdentifier() {\n\t\treturn \"org.eclipse.cdt.debug.ui.breakpointactions.ResumeAction\"; //$NON-NLS-1$\n\t}\n\n\t@Override\n\tpublic String getMemento() {\n\t\tString resumeData = \"\"; //$NON-NLS-1$\n\n\t\tDocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();\n\t\tDocumentBuilder docBuilder = null;\n\t\ttry {\n\t\t\tdocBuilder = dfactory.newDocumentBuilder();\n\t\t\tDocument doc = docBuilder.newDocument();\n\n\t\t\tElement rootElement = doc.createElement(\"resumeData\"); //$NON-NLS-1$\n\t\t\trootElement.setAttribute(\"pauseTime\", Integer.toString(pauseTime)); //$NON-NLS-1$\n\n\t\t\tdoc.appendChild(rootElement);\n\n\t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n\n\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n\t\t\tTransformer transformer = factory.newTransformer();\n\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\n\t\t\tDOMSource source = new DOMSource(doc);\n\t\t\tStreamResult outputTarget = new StreamResult(s);\n\t\t\ttransformer.transform(source, outputTarget);\n\n\t\t\tresumeData = s.toString(\"UTF8\"); //$NON-NLS-1$\n\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn resumeData;\n\t}\n\n\t@Override\n\tpublic String getSummary() {\n\t\tif (pauseTime == 0)\n\t\t\treturn Messages.getString(\"ResumeAction.SummaryImmediately\"); //$NON-NLS-1$\n\t\treturn MessageFormat.format(Messages.getString(\"ResumeAction.SummaryResumeTime\"), //$NON-NLS-1$\n\t\t\t\tnew Object[] { Integer.valueOf(pauseTime) });\n\t}\n\n\t@Override\n\tpublic String getTypeName() {\n\t\treturn Messages.getString(\"ResumeAction.TypeName\"); //$NON-NLS-1$\n\t}\n\n\t@Override\n\tpublic void initializeFromMemento(String data) {\n\t\tElement root = null;\n\t\tDocumentBuilder parser;\n\t\ttry {\n\t\t\tparser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n\t\t\tparser.setErrorHandler(new DefaultHandler());\n\t\t\troot = parser.parse(new InputSource(new StringReader(data))).getDocumentElement();\n\t\t\tString value = root.getAttribute(\"pauseTime\"); //$NON-NLS-1$\n\t\t\tif (value == null)\n\t\t\t\tthrow new Exception();\n\t\t\tpauseTime = Integer.parseInt(value);\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n}\n",
    "code_after_change": "/*******************************************************************************\n * Copyright (c) 2007, 2015 Nokia and others.\n *\n * This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n *\n * Contributors:\n *     Nokia - initial API and implementation\n *******************************************************************************/\npackage org.eclipse.cdt.debug.ui.breakpointactions;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.StringReader;\nimport java.text.MessageFormat;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.eclipse.cdt.debug.core.CDIDebugModel;\nimport org.eclipse.cdt.debug.core.breakpointactions.AbstractBreakpointAction;\nimport org.eclipse.cdt.debug.core.breakpointactions.IResumeActionEnabler;\nimport org.eclipse.cdt.debug.internal.core.ICDebugInternalConstants;\nimport org.eclipse.cdt.debug.internal.ui.IInternalCDebugUIConstants;\nimport org.eclipse.cdt.debug.ui.CDebugUIPlugin;\nimport org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\nimport org.eclipse.core.runtime.IAdaptable;\nimport org.eclipse.core.runtime.IProgressMonitor;\nimport org.eclipse.core.runtime.IStatus;\nimport org.eclipse.core.runtime.MultiStatus;\nimport org.eclipse.core.runtime.Status;\nimport org.eclipse.debug.core.model.IBreakpoint;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.helpers.DefaultHandler;\n\npublic class ResumeAction extends AbstractBreakpointAction {\n\n\tfinal static int INCRIMENT_MSEC = 100;\n\n\tint pauseTime = 0;\n\n\t@Override\n\tpublic IStatus execute(IBreakpoint breakpoint, IAdaptable context, IProgressMonitor monitor) {\n\t\tIStatus errorStatus = null;\n\t\tlong endTime = System.currentTimeMillis() + getPauseTime() * 1000;\n\t\tIResumeActionEnabler enabler = context.getAdapter(IResumeActionEnabler.class);\n\n\t\tif (enabler != null) {\n\t\t\ttry {\n\t\t\t\tmonitor.beginTask(getName(), getPauseTime() * 1000 / INCRIMENT_MSEC);\n\n\t\t\t\tlong currentTime = System.currentTimeMillis();\n\t\t\t\twhile (!monitor.isCanceled() && currentTime < endTime) {\n\t\t\t\t\tmonitor.setTaskName(MessageFormat.format(Messages.getString(\"ResumeAction.SummaryResumeTime\"), //$NON-NLS-1$\n\t\t\t\t\t\t\tnew Object[] { Long.valueOf((endTime - currentTime) / 1000) })); //)\n\t\t\t\t\tmonitor.worked(1);\n\t\t\t\t\tThread.sleep(INCRIMENT_MSEC);\n\t\t\t\t\tcurrentTime = System.currentTimeMillis();\n\t\t\t\t}\n\n\t\t\t\tif (!monitor.isCanceled()) {\n\t\t\t\t\tmonitor.setTaskName(Messages.getString(\"ResumeAction.SummaryImmediately\")); //$NON-NLS-1$)\n\t\t\t\t\tenabler.resume();\n\t\t\t\t}\n\t\t\t\tmonitor.worked(1);\n\t\t\t} catch (Exception e) {\n\t\t\t\terrorStatus = new Status(IStatus.ERROR, CDIDebugModel.getPluginIdentifier(),\n\t\t\t\t\t\tICDebugInternalConstants.STATUS_CODE_ERROR, e.getMessage(), e);\n\t\t\t}\n\t\t} else\n\t\t\terrorStatus = new Status(IStatus.ERROR, CDebugUIPlugin.getUniqueIdentifier(),\n\t\t\t\t\tIInternalCDebugUIConstants.INTERNAL_ERROR, Messages.getString(\"ResumeAction.error.0\"), null); //$NON-NLS-1$\n\n\t\tif (errorStatus != null) {\n\t\t\tMultiStatus ms = new MultiStatus(CDIDebugModel.getPluginIdentifier(),\n\t\t\t\t\tICDebugInternalConstants.STATUS_CODE_ERROR, Messages.getString(\"ResumeAction.error.1\"), null); //$NON-NLS-1$\n\t\t\tms.add(errorStatus);\n\t\t\terrorStatus = ms;\n\t\t} else {\n\t\t\terrorStatus = monitor.isCanceled() ? Status.CANCEL_STATUS : Status.OK_STATUS;\n\t\t}\n\t\treturn errorStatus;\n\t}\n\n\t@Override\n\tpublic String getDefaultName() {\n\t\treturn Messages.getString(\"ResumeAction.UntitledName\"); //$NON-NLS-1$\n\t}\n\n\tpublic int getPauseTime() {\n\t\treturn pauseTime;\n\t}\n\n\tpublic void setPauseTime(int pauseTime) {\n\t\tthis.pauseTime = pauseTime;\n\t}\n\n\t@Override\n\tpublic String getIdentifier() {\n\t\treturn \"org.eclipse.cdt.debug.ui.breakpointactions.ResumeAction\"; //$NON-NLS-1$\n\t}\n\n\t@Override\n\tpublic String getMemento() {\n\t\tString resumeData = \"\"; //$NON-NLS-1$\n\n\t\ttry {\n\t\t\tDocumentBuilder docBuilder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n\t\t\tDocument doc = docBuilder.newDocument();\n\n\t\t\tElement rootElement = doc.createElement(\"resumeData\"); //$NON-NLS-1$\n\t\t\trootElement.setAttribute(\"pauseTime\", Integer.toString(pauseTime)); //$NON-NLS-1$\n\n\t\t\tdoc.appendChild(rootElement);\n\n\t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n\n\t\t\tTransformerFactory factory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n\t\t\tTransformer transformer = factory.newTransformer();\n\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\n\t\t\tDOMSource source = new DOMSource(doc);\n\t\t\tStreamResult outputTarget = new StreamResult(s);\n\t\t\ttransformer.transform(source, outputTarget);\n\n\t\t\tresumeData = s.toString(\"UTF8\"); //$NON-NLS-1$\n\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn resumeData;\n\t}\n\n\t@Override\n\tpublic String getSummary() {\n\t\tif (pauseTime == 0)\n\t\t\treturn Messages.getString(\"ResumeAction.SummaryImmediately\"); //$NON-NLS-1$\n\t\treturn MessageFormat.format(Messages.getString(\"ResumeAction.SummaryResumeTime\"), //$NON-NLS-1$\n\t\t\t\tnew Object[] { Integer.valueOf(pauseTime) });\n\t}\n\n\t@Override\n\tpublic String getTypeName() {\n\t\treturn Messages.getString(\"ResumeAction.TypeName\"); //$NON-NLS-1$\n\t}\n\n\t@Override\n\tpublic void initializeFromMemento(String data) {\n\t\tElement root = null;\n\t\tDocumentBuilder parser;\n\t\ttry {\n\t\t\tparser = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n\t\t\tparser.setErrorHandler(new DefaultHandler());\n\t\t\troot = parser.parse(new InputSource(new StringReader(data))).getDocumentElement();\n\t\t\tString value = root.getAttribute(\"pauseTime\"); //$NON-NLS-1$\n\t\t\tif (value == null)\n\t\t\t\tthrow new Exception();\n\t\t\tpauseTime = Integer.parseInt(value);\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n}\n",
    "patch": "@@ -18,7 +18,6 @@\n import java.text.MessageFormat;\n \n import javax.xml.parsers.DocumentBuilder;\n-import javax.xml.parsers.DocumentBuilderFactory;\n import javax.xml.transform.OutputKeys;\n import javax.xml.transform.Transformer;\n import javax.xml.transform.TransformerFactory;\n@@ -31,6 +30,7 @@\n import org.eclipse.cdt.debug.internal.core.ICDebugInternalConstants;\n import org.eclipse.cdt.debug.internal.ui.IInternalCDebugUIConstants;\n import org.eclipse.cdt.debug.ui.CDebugUIPlugin;\n+import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n import org.eclipse.core.runtime.IAdaptable;\n import org.eclipse.core.runtime.IProgressMonitor;\n import org.eclipse.core.runtime.IStatus;\n@@ -113,10 +113,8 @@ public String getIdentifier() {\n \tpublic String getMemento() {\n \t\tString resumeData = \"\"; //$NON-NLS-1$\n \n-\t\tDocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();\n-\t\tDocumentBuilder docBuilder = null;\n \t\ttry {\n-\t\t\tdocBuilder = dfactory.newDocumentBuilder();\n+\t\t\tDocumentBuilder docBuilder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tDocument doc = docBuilder.newDocument();\n \n \t\t\tElement rootElement = doc.createElement(\"resumeData\"); //$NON-NLS-1$\n@@ -126,7 +124,7 @@ public String getMemento() {\n \n \t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n \n-\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n+\t\t\tTransformerFactory factory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n \t\t\tTransformer transformer = factory.newTransformer();\n \t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n \t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n@@ -161,7 +159,7 @@ public void initializeFromMemento(String data) {\n \t\tElement root = null;\n \t\tDocumentBuilder parser;\n \t\ttry {\n-\t\t\tparser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n+\t\t\tparser = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tparser.setErrorHandler(new DefaultHandler());\n \t\t\troot = parser.parse(new InputSource(new StringReader(data))).getDocumentElement();\n \t\t\tString value = root.getAttribute(\"pauseTime\"); //$NON-NLS-1$",
    "function_modified_lines": {
      "added": [
        "import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n"
      ],
      "deleted": [
        "import javax.xml.parsers.DocumentBuilderFactory;\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "In Eclipse IDE versions < 2023-09 (4.29) some files with xml content are parsed vulnerable against all sorts of XXE attacks. The user just needs to open any evil project or update an open project with a vulnerable file (for example for review a foreign repository or patch).\n",
    "id": 12883
  },
  {
    "cve_id": "CVE-2023-4218",
    "code_before_change": "{\n\t\tString resumeData = \"\"; //$NON-NLS-1$\n\n\t\tDocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();\n\t\tDocumentBuilder docBuilder = null;\n\t\ttry {\n\t\t\tdocBuilder = dfactory.newDocumentBuilder();\n\t\t\tDocument doc = docBuilder.newDocument();\n\n\t\t\tElement rootElement = doc.createElement(\"resumeData\"); //$NON-NLS-1$\n\t\t\trootElement.setAttribute(\"pauseTime\", Integer.toString(pauseTime)); //$NON-NLS-1$\n\n\t\t\tdoc.appendChild(rootElement);\n\n\t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n\n\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n\t\t\tTransformer transformer = factory.newTransformer();\n\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\n\t\t\tDOMSource source = new DOMSource(doc);\n\t\t\tStreamResult outputTarget = new StreamResult(s);\n\t\t\ttransformer.transform(source, outputTarget);\n\n\t\t\tresumeData = s.toString(\"UTF8\"); //$NON-NLS-1$\n\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn resumeData;\n\t}",
    "code_after_change": "{\n\t\t\tDocumentBuilder docBuilder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n\t\t\tDocument doc = docBuilder.newDocument();\n\n\t\t\tElement rootElement = doc.createElement(\"resumeData\"); //$NON-NLS-1$\n\t\t\trootElement.setAttribute(\"pauseTime\", Integer.toString(pauseTime)); //$NON-NLS-1$\n\n\t\t\tdoc.appendChild(rootElement);\n\n\t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n\n\t\t\tTransformerFactory factory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n\t\t\tTransformer transformer = factory.newTransformer();\n\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\n\t\t\tDOMSource source = new DOMSource(doc);\n\t\t\tStreamResult outputTarget = new StreamResult(s);\n\t\t\ttransformer.transform(source, outputTarget);\n\n\t\t\tresumeData = s.toString(\"UTF8\"); //$NON-NLS-1$\n\n\t\t}",
    "patch": "@@ -18,7 +18,6 @@\n import java.text.MessageFormat;\n \n import javax.xml.parsers.DocumentBuilder;\n-import javax.xml.parsers.DocumentBuilderFactory;\n import javax.xml.transform.OutputKeys;\n import javax.xml.transform.Transformer;\n import javax.xml.transform.TransformerFactory;\n@@ -31,6 +30,7 @@\n import org.eclipse.cdt.debug.internal.core.ICDebugInternalConstants;\n import org.eclipse.cdt.debug.internal.ui.IInternalCDebugUIConstants;\n import org.eclipse.cdt.debug.ui.CDebugUIPlugin;\n+import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n import org.eclipse.core.runtime.IAdaptable;\n import org.eclipse.core.runtime.IProgressMonitor;\n import org.eclipse.core.runtime.IStatus;\n@@ -113,10 +113,8 @@ public String getIdentifier() {\n \tpublic String getMemento() {\n \t\tString resumeData = \"\"; //$NON-NLS-1$\n \n-\t\tDocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();\n-\t\tDocumentBuilder docBuilder = null;\n \t\ttry {\n-\t\t\tdocBuilder = dfactory.newDocumentBuilder();\n+\t\t\tDocumentBuilder docBuilder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tDocument doc = docBuilder.newDocument();\n \n \t\t\tElement rootElement = doc.createElement(\"resumeData\"); //$NON-NLS-1$\n@@ -126,7 +124,7 @@ public String getMemento() {\n \n \t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n \n-\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n+\t\t\tTransformerFactory factory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n \t\t\tTransformer transformer = factory.newTransformer();\n \t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n \t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n@@ -161,7 +159,7 @@ public void initializeFromMemento(String data) {\n \t\tElement root = null;\n \t\tDocumentBuilder parser;\n \t\ttry {\n-\t\t\tparser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n+\t\t\tparser = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tparser.setErrorHandler(new DefaultHandler());\n \t\t\troot = parser.parse(new InputSource(new StringReader(data))).getDocumentElement();\n \t\t\tString value = root.getAttribute(\"pauseTime\"); //$NON-NLS-1$",
    "function_modified_lines": {
      "added": [
        "\t\t\tDocumentBuilder docBuilder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n",
        "\t\t\tTransformerFactory factory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n"
      ],
      "deleted": [
        "\t\tDocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();\n",
        "\t\tDocumentBuilder docBuilder = null;\n",
        "\t\t\tdocBuilder = dfactory.newDocumentBuilder();\n",
        "\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "In Eclipse IDE versions < 2023-09 (4.29) some files with xml content are parsed vulnerable against all sorts of XXE attacks. The user just needs to open any evil project or update an open project with a vulnerable file (for example for review a foreign repository or patch).\n",
    "id": 12884
  },
  {
    "cve_id": "CVE-2023-4218",
    "code_before_change": "/*******************************************************************************\n * Copyright (c) 2007, 2015 Nokia and others.\n *\n * This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n *\n * Contributors:\n *     Ericsson - initial implementation\n *******************************************************************************/\npackage org.eclipse.cdt.debug.ui.breakpointactions;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.StringReader;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.eclipse.cdt.debug.core.CDIDebugModel;\nimport org.eclipse.cdt.debug.core.breakpointactions.AbstractBreakpointAction;\nimport org.eclipse.cdt.debug.core.breakpointactions.IReverseDebugEnabler;\nimport org.eclipse.cdt.debug.internal.core.ICDebugInternalConstants;\nimport org.eclipse.cdt.debug.internal.ui.IInternalCDebugUIConstants;\nimport org.eclipse.cdt.debug.ui.CDebugUIPlugin;\nimport org.eclipse.core.runtime.IAdaptable;\nimport org.eclipse.core.runtime.IProgressMonitor;\nimport org.eclipse.core.runtime.IStatus;\nimport org.eclipse.core.runtime.MultiStatus;\nimport org.eclipse.core.runtime.Status;\nimport org.eclipse.debug.core.model.IBreakpoint;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.helpers.DefaultHandler;\n\n/**\n * Implements the reverse debug breakpoint action\n *\n *@since 7.3\n */\npublic class ReverseDebugAction extends AbstractBreakpointAction {\n\t/**\n\t * The available reverse debug action modes: enable, disable and toggle.\n\t */\n\tpublic static enum REVERSE_DEBUG_ACTIONS_ENUM {\n\n\t\tENABLE, DISABLE, TOGGLE;\n\n\t\t/**\n\t\t * @param index\n\t\t * @return the enum value for the given index\n\t\t */\n\t\tpublic static REVERSE_DEBUG_ACTIONS_ENUM getValue(int index) {\n\t\t\treturn REVERSE_DEBUG_ACTIONS_ENUM.values()[index];\n\t\t}\n\t}\n\n\tprivate REVERSE_DEBUG_ACTIONS_ENUM fOperation;\n\n\t/**\n\t * @return the currently configured reverse debug mode, for this BP action\n\t */\n\tpublic REVERSE_DEBUG_ACTIONS_ENUM getOperation() {\n\t\treturn fOperation;\n\t}\n\n\t/**\n\t * Sets the currently configured reverse debug mode, for this BP action\n\t * @param operation\n\t */\n\tpublic void setOperation(REVERSE_DEBUG_ACTIONS_ENUM operation) {\n\t\tthis.fOperation = operation;\n\t}\n\n\t@Override\n\tpublic IStatus execute(IBreakpoint breakpoint, IAdaptable context, IProgressMonitor monitor) {\n\t\tIStatus errorStatus = null;\n\n\t\tIReverseDebugEnabler enabler = context.getAdapter(IReverseDebugEnabler.class);\n\t\tif (enabler != null) {\n\t\t\ttry {\n\t\t\t\tswitch (fOperation) {\n\t\t\t\tcase TOGGLE:\n\t\t\t\t\tenabler.toggle();\n\t\t\t\t\tbreak;\n\t\t\t\tcase ENABLE:\n\t\t\t\t\tenabler.enable();\n\t\t\t\t\tbreak;\n\t\t\t\tcase DISABLE:\n\t\t\t\t\tenabler.disable();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t} catch (Exception e) {\n\t\t\t\terrorStatus = new Status(IStatus.ERROR, CDIDebugModel.getPluginIdentifier(),\n\t\t\t\t\t\tICDebugInternalConstants.STATUS_CODE_ERROR, e.getMessage(), e);\n\t\t\t}\n\t\t} else\n\t\t\terrorStatus = new Status(IStatus.ERROR, CDebugUIPlugin.getUniqueIdentifier(),\n\t\t\t\t\tIInternalCDebugUIConstants.INTERNAL_ERROR, Messages.getString(\"ReverseDebugAction.error.0\"), null); //$NON-NLS-1$\n\n\t\tif (errorStatus != null) {\n\t\t\tMultiStatus ms = new MultiStatus(CDIDebugModel.getPluginIdentifier(),\n\t\t\t\t\tICDebugInternalConstants.STATUS_CODE_ERROR, Messages.getString(\"ReverseDebugAction.error.1\"), null); //$NON-NLS-1$\n\t\t\tms.add(errorStatus);\n\t\t\terrorStatus = ms;\n\t\t} else {\n\t\t\terrorStatus = monitor.isCanceled() ? Status.CANCEL_STATUS : Status.OK_STATUS;\n\t\t}\n\n\t\treturn errorStatus;\n\t}\n\n\t@Override\n\tpublic String getMemento() {\n\t\tString reverseDebugData = \"\"; //$NON-NLS-1$\n\n\t\tDocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();\n\t\tDocumentBuilder docBuilder = null;\n\t\ttry {\n\t\t\tdocBuilder = dfactory.newDocumentBuilder();\n\t\t\tDocument doc = docBuilder.newDocument();\n\n\t\t\tElement rootElement = doc.createElement(\"reverseDebugData\"); //$NON-NLS-1$\n\t\t\trootElement.setAttribute(\"operation\", fOperation.toString()); //$NON-NLS-1$\n\n\t\t\tdoc.appendChild(rootElement);\n\n\t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n\n\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n\t\t\tTransformer transformer = factory.newTransformer();\n\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\n\t\t\tDOMSource source = new DOMSource(doc);\n\t\t\tStreamResult outputTarget = new StreamResult(s);\n\t\t\ttransformer.transform(source, outputTarget);\n\n\t\t\treverseDebugData = s.toString(\"UTF8\"); //$NON-NLS-1$\n\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn reverseDebugData;\n\n\t}\n\n\t@Override\n\tpublic void initializeFromMemento(String data) {\n\t\tElement root = null;\n\t\tDocumentBuilder parser;\n\t\ttry {\n\t\t\tparser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n\t\t\tparser.setErrorHandler(new DefaultHandler());\n\t\t\troot = parser.parse(new InputSource(new StringReader(data))).getDocumentElement();\n\t\t\tString value = root.getAttribute(\"operation\"); //$NON-NLS-1$\n\t\t\tif (value == null)\n\t\t\t\tthrow new Exception();\n\t\t\tfOperation = REVERSE_DEBUG_ACTIONS_ENUM.valueOf(value);\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t}\n\n\t@Override\n\tpublic String getDefaultName() {\n\t\treturn Messages.getString(\"ReverseDebugAction.UntitledName\"); //$NON-NLS-1$\n\t}\n\n\t@Override\n\tpublic String getSummary() {\n\t\t// get translated operation\n\t\tString operation = Messages.getString(\"ReverseDebugAction.\" + fOperation.toString().toLowerCase()); //$NON-NLS-1$\n\n\t\treturn operation + \" \" + Messages.getString(\"ReverseDebugAction.Summary\"); //$NON-NLS-1$ //$NON-NLS-2$\n\t}\n\n\t@Override\n\tpublic String getTypeName() {\n\t\treturn Messages.getString(\"ReverseDebugAction.TypeName\"); //$NON-NLS-1$\n\t}\n\n\t@Override\n\tpublic String getIdentifier() {\n\t\treturn \"org.eclipse.cdt.debug.ui.breakpointactions.ReverseDebugAction\"; //$NON-NLS-1$\n\t}\n\n}\n",
    "code_after_change": "/*******************************************************************************\n * Copyright (c) 2007, 2015 Nokia and others.\n *\n * This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n *\n * Contributors:\n *     Ericsson - initial implementation\n *******************************************************************************/\npackage org.eclipse.cdt.debug.ui.breakpointactions;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.StringReader;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.eclipse.cdt.debug.core.CDIDebugModel;\nimport org.eclipse.cdt.debug.core.breakpointactions.AbstractBreakpointAction;\nimport org.eclipse.cdt.debug.core.breakpointactions.IReverseDebugEnabler;\nimport org.eclipse.cdt.debug.internal.core.ICDebugInternalConstants;\nimport org.eclipse.cdt.debug.internal.ui.IInternalCDebugUIConstants;\nimport org.eclipse.cdt.debug.ui.CDebugUIPlugin;\nimport org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\nimport org.eclipse.core.runtime.IAdaptable;\nimport org.eclipse.core.runtime.IProgressMonitor;\nimport org.eclipse.core.runtime.IStatus;\nimport org.eclipse.core.runtime.MultiStatus;\nimport org.eclipse.core.runtime.Status;\nimport org.eclipse.debug.core.model.IBreakpoint;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.helpers.DefaultHandler;\n\n/**\n * Implements the reverse debug breakpoint action\n *\n *@since 7.3\n */\npublic class ReverseDebugAction extends AbstractBreakpointAction {\n\t/**\n\t * The available reverse debug action modes: enable, disable and toggle.\n\t */\n\tpublic static enum REVERSE_DEBUG_ACTIONS_ENUM {\n\n\t\tENABLE, DISABLE, TOGGLE;\n\n\t\t/**\n\t\t * @param index\n\t\t * @return the enum value for the given index\n\t\t */\n\t\tpublic static REVERSE_DEBUG_ACTIONS_ENUM getValue(int index) {\n\t\t\treturn REVERSE_DEBUG_ACTIONS_ENUM.values()[index];\n\t\t}\n\t}\n\n\tprivate REVERSE_DEBUG_ACTIONS_ENUM fOperation;\n\n\t/**\n\t * @return the currently configured reverse debug mode, for this BP action\n\t */\n\tpublic REVERSE_DEBUG_ACTIONS_ENUM getOperation() {\n\t\treturn fOperation;\n\t}\n\n\t/**\n\t * Sets the currently configured reverse debug mode, for this BP action\n\t * @param operation\n\t */\n\tpublic void setOperation(REVERSE_DEBUG_ACTIONS_ENUM operation) {\n\t\tthis.fOperation = operation;\n\t}\n\n\t@Override\n\tpublic IStatus execute(IBreakpoint breakpoint, IAdaptable context, IProgressMonitor monitor) {\n\t\tIStatus errorStatus = null;\n\n\t\tIReverseDebugEnabler enabler = context.getAdapter(IReverseDebugEnabler.class);\n\t\tif (enabler != null) {\n\t\t\ttry {\n\t\t\t\tswitch (fOperation) {\n\t\t\t\tcase TOGGLE:\n\t\t\t\t\tenabler.toggle();\n\t\t\t\t\tbreak;\n\t\t\t\tcase ENABLE:\n\t\t\t\t\tenabler.enable();\n\t\t\t\t\tbreak;\n\t\t\t\tcase DISABLE:\n\t\t\t\t\tenabler.disable();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t} catch (Exception e) {\n\t\t\t\terrorStatus = new Status(IStatus.ERROR, CDIDebugModel.getPluginIdentifier(),\n\t\t\t\t\t\tICDebugInternalConstants.STATUS_CODE_ERROR, e.getMessage(), e);\n\t\t\t}\n\t\t} else\n\t\t\terrorStatus = new Status(IStatus.ERROR, CDebugUIPlugin.getUniqueIdentifier(),\n\t\t\t\t\tIInternalCDebugUIConstants.INTERNAL_ERROR, Messages.getString(\"ReverseDebugAction.error.0\"), null); //$NON-NLS-1$\n\n\t\tif (errorStatus != null) {\n\t\t\tMultiStatus ms = new MultiStatus(CDIDebugModel.getPluginIdentifier(),\n\t\t\t\t\tICDebugInternalConstants.STATUS_CODE_ERROR, Messages.getString(\"ReverseDebugAction.error.1\"), null); //$NON-NLS-1$\n\t\t\tms.add(errorStatus);\n\t\t\terrorStatus = ms;\n\t\t} else {\n\t\t\terrorStatus = monitor.isCanceled() ? Status.CANCEL_STATUS : Status.OK_STATUS;\n\t\t}\n\n\t\treturn errorStatus;\n\t}\n\n\t@Override\n\tpublic String getMemento() {\n\t\tString reverseDebugData = \"\"; //$NON-NLS-1$\n\n\t\ttry {\n\t\t\tDocumentBuilder docBuilder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n\t\t\tDocument doc = docBuilder.newDocument();\n\n\t\t\tElement rootElement = doc.createElement(\"reverseDebugData\"); //$NON-NLS-1$\n\t\t\trootElement.setAttribute(\"operation\", fOperation.toString()); //$NON-NLS-1$\n\n\t\t\tdoc.appendChild(rootElement);\n\n\t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n\n\t\t\tTransformerFactory factory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n\t\t\tTransformer transformer = factory.newTransformer();\n\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\n\t\t\tDOMSource source = new DOMSource(doc);\n\t\t\tStreamResult outputTarget = new StreamResult(s);\n\t\t\ttransformer.transform(source, outputTarget);\n\n\t\t\treverseDebugData = s.toString(\"UTF8\"); //$NON-NLS-1$\n\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn reverseDebugData;\n\n\t}\n\n\t@Override\n\tpublic void initializeFromMemento(String data) {\n\t\tElement root = null;\n\t\tDocumentBuilder parser;\n\t\ttry {\n\t\t\tparser = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n\t\t\tparser.setErrorHandler(new DefaultHandler());\n\t\t\troot = parser.parse(new InputSource(new StringReader(data))).getDocumentElement();\n\t\t\tString value = root.getAttribute(\"operation\"); //$NON-NLS-1$\n\t\t\tif (value == null)\n\t\t\t\tthrow new Exception();\n\t\t\tfOperation = REVERSE_DEBUG_ACTIONS_ENUM.valueOf(value);\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t}\n\n\t@Override\n\tpublic String getDefaultName() {\n\t\treturn Messages.getString(\"ReverseDebugAction.UntitledName\"); //$NON-NLS-1$\n\t}\n\n\t@Override\n\tpublic String getSummary() {\n\t\t// get translated operation\n\t\tString operation = Messages.getString(\"ReverseDebugAction.\" + fOperation.toString().toLowerCase()); //$NON-NLS-1$\n\n\t\treturn operation + \" \" + Messages.getString(\"ReverseDebugAction.Summary\"); //$NON-NLS-1$ //$NON-NLS-2$\n\t}\n\n\t@Override\n\tpublic String getTypeName() {\n\t\treturn Messages.getString(\"ReverseDebugAction.TypeName\"); //$NON-NLS-1$\n\t}\n\n\t@Override\n\tpublic String getIdentifier() {\n\t\treturn \"org.eclipse.cdt.debug.ui.breakpointactions.ReverseDebugAction\"; //$NON-NLS-1$\n\t}\n\n}\n",
    "patch": "@@ -17,7 +17,6 @@\n import java.io.StringReader;\n \n import javax.xml.parsers.DocumentBuilder;\n-import javax.xml.parsers.DocumentBuilderFactory;\n import javax.xml.transform.OutputKeys;\n import javax.xml.transform.Transformer;\n import javax.xml.transform.TransformerFactory;\n@@ -30,6 +29,7 @@\n import org.eclipse.cdt.debug.internal.core.ICDebugInternalConstants;\n import org.eclipse.cdt.debug.internal.ui.IInternalCDebugUIConstants;\n import org.eclipse.cdt.debug.ui.CDebugUIPlugin;\n+import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n import org.eclipse.core.runtime.IAdaptable;\n import org.eclipse.core.runtime.IProgressMonitor;\n import org.eclipse.core.runtime.IStatus;\n@@ -123,10 +123,8 @@ public IStatus execute(IBreakpoint breakpoint, IAdaptable context, IProgressMoni\n \tpublic String getMemento() {\n \t\tString reverseDebugData = \"\"; //$NON-NLS-1$\n \n-\t\tDocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();\n-\t\tDocumentBuilder docBuilder = null;\n \t\ttry {\n-\t\t\tdocBuilder = dfactory.newDocumentBuilder();\n+\t\t\tDocumentBuilder docBuilder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tDocument doc = docBuilder.newDocument();\n \n \t\t\tElement rootElement = doc.createElement(\"reverseDebugData\"); //$NON-NLS-1$\n@@ -136,7 +134,7 @@ public String getMemento() {\n \n \t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n \n-\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n+\t\t\tTransformerFactory factory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n \t\t\tTransformer transformer = factory.newTransformer();\n \t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n \t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n@@ -159,7 +157,7 @@ public void initializeFromMemento(String data) {\n \t\tElement root = null;\n \t\tDocumentBuilder parser;\n \t\ttry {\n-\t\t\tparser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n+\t\t\tparser = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tparser.setErrorHandler(new DefaultHandler());\n \t\t\troot = parser.parse(new InputSource(new StringReader(data))).getDocumentElement();\n \t\t\tString value = root.getAttribute(\"operation\"); //$NON-NLS-1$",
    "function_modified_lines": {
      "added": [
        "import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n"
      ],
      "deleted": [
        "import javax.xml.parsers.DocumentBuilderFactory;\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "In Eclipse IDE versions < 2023-09 (4.29) some files with xml content are parsed vulnerable against all sorts of XXE attacks. The user just needs to open any evil project or update an open project with a vulnerable file (for example for review a foreign repository or patch).\n",
    "id": 12885
  },
  {
    "cve_id": "CVE-2023-4218",
    "code_before_change": "{\n\t\tString reverseDebugData = \"\"; //$NON-NLS-1$\n\n\t\tDocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();\n\t\tDocumentBuilder docBuilder = null;\n\t\ttry {\n\t\t\tdocBuilder = dfactory.newDocumentBuilder();\n\t\t\tDocument doc = docBuilder.newDocument();\n\n\t\t\tElement rootElement = doc.createElement(\"reverseDebugData\"); //$NON-NLS-1$\n\t\t\trootElement.setAttribute(\"operation\", fOperation.toString()); //$NON-NLS-1$\n\n\t\t\tdoc.appendChild(rootElement);\n\n\t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n\n\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n\t\t\tTransformer transformer = factory.newTransformer();\n\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\n\t\t\tDOMSource source = new DOMSource(doc);\n\t\t\tStreamResult outputTarget = new StreamResult(s);\n\t\t\ttransformer.transform(source, outputTarget);\n\n\t\t\treverseDebugData = s.toString(\"UTF8\"); //$NON-NLS-1$\n\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn reverseDebugData;\n\n\t}",
    "code_after_change": "{\n\t\t\tDocumentBuilder docBuilder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n\t\t\tDocument doc = docBuilder.newDocument();\n\n\t\t\tElement rootElement = doc.createElement(\"reverseDebugData\"); //$NON-NLS-1$\n\t\t\trootElement.setAttribute(\"operation\", fOperation.toString()); //$NON-NLS-1$\n\n\t\t\tdoc.appendChild(rootElement);\n\n\t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n\n\t\t\tTransformerFactory factory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n\t\t\tTransformer transformer = factory.newTransformer();\n\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\n\t\t\tDOMSource source = new DOMSource(doc);\n\t\t\tStreamResult outputTarget = new StreamResult(s);\n\t\t\ttransformer.transform(source, outputTarget);\n\n\t\t\treverseDebugData = s.toString(\"UTF8\"); //$NON-NLS-1$\n\n\t\t}",
    "patch": "@@ -17,7 +17,6 @@\n import java.io.StringReader;\n \n import javax.xml.parsers.DocumentBuilder;\n-import javax.xml.parsers.DocumentBuilderFactory;\n import javax.xml.transform.OutputKeys;\n import javax.xml.transform.Transformer;\n import javax.xml.transform.TransformerFactory;\n@@ -30,6 +29,7 @@\n import org.eclipse.cdt.debug.internal.core.ICDebugInternalConstants;\n import org.eclipse.cdt.debug.internal.ui.IInternalCDebugUIConstants;\n import org.eclipse.cdt.debug.ui.CDebugUIPlugin;\n+import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n import org.eclipse.core.runtime.IAdaptable;\n import org.eclipse.core.runtime.IProgressMonitor;\n import org.eclipse.core.runtime.IStatus;\n@@ -123,10 +123,8 @@ public IStatus execute(IBreakpoint breakpoint, IAdaptable context, IProgressMoni\n \tpublic String getMemento() {\n \t\tString reverseDebugData = \"\"; //$NON-NLS-1$\n \n-\t\tDocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();\n-\t\tDocumentBuilder docBuilder = null;\n \t\ttry {\n-\t\t\tdocBuilder = dfactory.newDocumentBuilder();\n+\t\t\tDocumentBuilder docBuilder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tDocument doc = docBuilder.newDocument();\n \n \t\t\tElement rootElement = doc.createElement(\"reverseDebugData\"); //$NON-NLS-1$\n@@ -136,7 +134,7 @@ public String getMemento() {\n \n \t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n \n-\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n+\t\t\tTransformerFactory factory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n \t\t\tTransformer transformer = factory.newTransformer();\n \t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n \t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n@@ -159,7 +157,7 @@ public void initializeFromMemento(String data) {\n \t\tElement root = null;\n \t\tDocumentBuilder parser;\n \t\ttry {\n-\t\t\tparser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n+\t\t\tparser = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tparser.setErrorHandler(new DefaultHandler());\n \t\t\troot = parser.parse(new InputSource(new StringReader(data))).getDocumentElement();\n \t\t\tString value = root.getAttribute(\"operation\"); //$NON-NLS-1$",
    "function_modified_lines": {
      "added": [
        "\t\t\tDocumentBuilder docBuilder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n",
        "\t\t\tTransformerFactory factory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n"
      ],
      "deleted": [
        "\t\tDocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();\n",
        "\t\tDocumentBuilder docBuilder = null;\n",
        "\t\t\tdocBuilder = dfactory.newDocumentBuilder();\n",
        "\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "In Eclipse IDE versions < 2023-09 (4.29) some files with xml content are parsed vulnerable against all sorts of XXE attacks. The user just needs to open any evil project or update an open project with a vulnerable file (for example for review a foreign repository or patch).\n",
    "id": 12886
  },
  {
    "cve_id": "CVE-2023-4218",
    "code_before_change": "/*******************************************************************************\n * Copyright (c) 2007, 2012 Nokia and others.\n *\n * This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n *\n * Contributors:\n *     Nokia - initial API and implementation\n *******************************************************************************/\npackage org.eclipse.cdt.debug.ui.breakpointactions;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.text.MessageFormat;\n\nimport javax.sound.sampled.AudioFormat;\nimport javax.sound.sampled.AudioInputStream;\nimport javax.sound.sampled.AudioSystem;\nimport javax.sound.sampled.DataLine;\nimport javax.sound.sampled.LineUnavailableException;\nimport javax.sound.sampled.SourceDataLine;\nimport javax.sound.sampled.UnsupportedAudioFileException;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.eclipse.cdt.debug.core.CDIDebugModel;\nimport org.eclipse.cdt.debug.core.breakpointactions.AbstractBreakpointAction;\nimport org.eclipse.cdt.debug.internal.core.ICDebugInternalConstants;\nimport org.eclipse.core.runtime.IAdaptable;\nimport org.eclipse.core.runtime.IProgressMonitor;\nimport org.eclipse.core.runtime.IStatus;\nimport org.eclipse.core.runtime.Status;\nimport org.eclipse.debug.core.model.IBreakpoint;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.helpers.DefaultHandler;\n\npublic class SoundAction extends AbstractBreakpointAction {\n\n\tstatic public void playSoundFile(final File soundFile) {\n\n\t\tclass SoundPlayer extends Thread {\n\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tAudioInputStream soundStream;\n\t\t\t\ttry {\n\t\t\t\t\tsoundStream = AudioSystem.getAudioInputStream(soundFile);\n\t\t\t\t\tAudioFormat audioFormat = soundStream.getFormat();\n\t\t\t\t\tDataLine.Info dataLineInfo = new DataLine.Info(SourceDataLine.class, audioFormat);\n\t\t\t\t\tSourceDataLine sourceDataLine = (SourceDataLine) AudioSystem.getLine(dataLineInfo);\n\t\t\t\t\tbyte[] soundBuffer = new byte[5000];\n\t\t\t\t\tsourceDataLine.open(audioFormat);\n\t\t\t\t\tsourceDataLine.start();\n\t\t\t\t\tint dataCount = 0;\n\n\t\t\t\t\twhile ((dataCount = soundStream.read(soundBuffer, 0, soundBuffer.length)) != -1) {\n\t\t\t\t\t\tif (dataCount > 0) {\n\t\t\t\t\t\t\tsourceDataLine.write(soundBuffer, 0, dataCount);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tsourceDataLine.drain();\n\t\t\t\t\tsourceDataLine.close();\n\n\t\t\t\t} catch (UnsupportedAudioFileException e) {\n\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t} catch (LineUnavailableException e) {\n\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif (soundFile.exists()) {\n\t\t\tnew SoundPlayer().start();\n\t\t}\n\t}\n\n\tprivate File soundFile;\n\n\tpublic SoundAction() {\n\t}\n\n\t@Override\n\tpublic IStatus execute(IBreakpoint breakpoint, IAdaptable context, IProgressMonitor monitor) {\n\t\tif (soundFile == null || !soundFile.exists()) {\n\t\t\tString errorMsg = MessageFormat.format(Messages.getString(\"SoundAction.error.0\"), //$NON-NLS-1$\n\t\t\t\t\tnew Object[] { getSummary() });\n\t\t\treturn new Status(IStatus.ERROR, CDIDebugModel.getPluginIdentifier(),\n\t\t\t\t\tICDebugInternalConstants.STATUS_CODE_ERROR, errorMsg, null);\n\t\t}\n\n\t\tplaySoundFile(soundFile);\n\t\treturn Status.OK_STATUS;\n\t}\n\n\t@Override\n\tpublic String getDefaultName() {\n\t\treturn Messages.getString(\"SoundAction.UntitledName\"); //$NON-NLS-1$\n\t}\n\n\tpublic File getSoundFile() {\n\t\treturn soundFile;\n\t}\n\n\t@Override\n\tpublic String getSummary() {\n\t\tif (soundFile == null)\n\t\t\treturn \"\"; //$NON-NLS-1$\n\t\treturn soundFile.getAbsolutePath();\n\t}\n\n\t@Override\n\tpublic String getTypeName() {\n\t\treturn Messages.getString(\"SoundAction.ActionTypeName\"); //$NON-NLS-1$\n\t}\n\n\t@Override\n\tpublic String getMemento() {\n\t\tString soundData = \"\"; //$NON-NLS-1$\n\t\tif (soundFile != null) {\n\t\t\tDocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();\n\t\t\tDocumentBuilder docBuilder = null;\n\t\t\ttry {\n\t\t\t\tdocBuilder = dfactory.newDocumentBuilder();\n\t\t\t\tDocument doc = docBuilder.newDocument();\n\n\t\t\t\tElement rootElement = doc.createElement(\"soundData\"); //$NON-NLS-1$\n\t\t\t\trootElement.setAttribute(\"file\", soundFile.getAbsolutePath()); //$NON-NLS-1$\n\n\t\t\t\tdoc.appendChild(rootElement);\n\n\t\t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n\n\t\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n\t\t\t\tTransformer transformer = factory.newTransformer();\n\t\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\n\t\t\t\tDOMSource source = new DOMSource(doc);\n\t\t\t\tStreamResult outputTarget = new StreamResult(s);\n\t\t\t\ttransformer.transform(source, outputTarget);\n\n\t\t\t\tsoundData = s.toString(\"UTF8\"); //$NON-NLS-1$\n\n\t\t\t} catch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\treturn soundData;\n\t}\n\n\t@Override\n\tpublic void initializeFromMemento(String data) {\n\t\tElement root = null;\n\t\tDocumentBuilder parser;\n\t\ttry {\n\t\t\tparser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n\t\t\tparser.setErrorHandler(new DefaultHandler());\n\t\t\troot = parser.parse(new InputSource(new StringReader(data))).getDocumentElement();\n\t\t\tString value = root.getAttribute(\"file\"); //$NON-NLS-1$\n\t\t\tif (value == null)\n\t\t\t\tthrow new Exception();\n\t\t\tsoundFile = new File(value);\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\t@Override\n\tpublic String getIdentifier() {\n\t\treturn \"org.eclipse.cdt.debug.ui.breakpointactions.SoundAction\"; //$NON-NLS-1$\n\t}\n\n\tpublic void setSoundFile(File soundFile) {\n\t\tthis.soundFile = soundFile;\n\t}\n\n}\n",
    "code_after_change": "/*******************************************************************************\n * Copyright (c) 2007, 2012 Nokia and others.\n *\n * This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n *\n * Contributors:\n *     Nokia - initial API and implementation\n *******************************************************************************/\npackage org.eclipse.cdt.debug.ui.breakpointactions;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.text.MessageFormat;\n\nimport javax.sound.sampled.AudioFormat;\nimport javax.sound.sampled.AudioInputStream;\nimport javax.sound.sampled.AudioSystem;\nimport javax.sound.sampled.DataLine;\nimport javax.sound.sampled.LineUnavailableException;\nimport javax.sound.sampled.SourceDataLine;\nimport javax.sound.sampled.UnsupportedAudioFileException;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.eclipse.cdt.debug.core.CDIDebugModel;\nimport org.eclipse.cdt.debug.core.breakpointactions.AbstractBreakpointAction;\nimport org.eclipse.cdt.debug.internal.core.ICDebugInternalConstants;\nimport org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\nimport org.eclipse.core.runtime.IAdaptable;\nimport org.eclipse.core.runtime.IProgressMonitor;\nimport org.eclipse.core.runtime.IStatus;\nimport org.eclipse.core.runtime.Status;\nimport org.eclipse.debug.core.model.IBreakpoint;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.helpers.DefaultHandler;\n\npublic class SoundAction extends AbstractBreakpointAction {\n\n\tstatic public void playSoundFile(final File soundFile) {\n\n\t\tclass SoundPlayer extends Thread {\n\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tAudioInputStream soundStream;\n\t\t\t\ttry {\n\t\t\t\t\tsoundStream = AudioSystem.getAudioInputStream(soundFile);\n\t\t\t\t\tAudioFormat audioFormat = soundStream.getFormat();\n\t\t\t\t\tDataLine.Info dataLineInfo = new DataLine.Info(SourceDataLine.class, audioFormat);\n\t\t\t\t\tSourceDataLine sourceDataLine = (SourceDataLine) AudioSystem.getLine(dataLineInfo);\n\t\t\t\t\tbyte[] soundBuffer = new byte[5000];\n\t\t\t\t\tsourceDataLine.open(audioFormat);\n\t\t\t\t\tsourceDataLine.start();\n\t\t\t\t\tint dataCount = 0;\n\n\t\t\t\t\twhile ((dataCount = soundStream.read(soundBuffer, 0, soundBuffer.length)) != -1) {\n\t\t\t\t\t\tif (dataCount > 0) {\n\t\t\t\t\t\t\tsourceDataLine.write(soundBuffer, 0, dataCount);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tsourceDataLine.drain();\n\t\t\t\t\tsourceDataLine.close();\n\n\t\t\t\t} catch (UnsupportedAudioFileException e) {\n\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t} catch (LineUnavailableException e) {\n\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif (soundFile.exists()) {\n\t\t\tnew SoundPlayer().start();\n\t\t}\n\t}\n\n\tprivate File soundFile;\n\n\tpublic SoundAction() {\n\t}\n\n\t@Override\n\tpublic IStatus execute(IBreakpoint breakpoint, IAdaptable context, IProgressMonitor monitor) {\n\t\tif (soundFile == null || !soundFile.exists()) {\n\t\t\tString errorMsg = MessageFormat.format(Messages.getString(\"SoundAction.error.0\"), //$NON-NLS-1$\n\t\t\t\t\tnew Object[] { getSummary() });\n\t\t\treturn new Status(IStatus.ERROR, CDIDebugModel.getPluginIdentifier(),\n\t\t\t\t\tICDebugInternalConstants.STATUS_CODE_ERROR, errorMsg, null);\n\t\t}\n\n\t\tplaySoundFile(soundFile);\n\t\treturn Status.OK_STATUS;\n\t}\n\n\t@Override\n\tpublic String getDefaultName() {\n\t\treturn Messages.getString(\"SoundAction.UntitledName\"); //$NON-NLS-1$\n\t}\n\n\tpublic File getSoundFile() {\n\t\treturn soundFile;\n\t}\n\n\t@Override\n\tpublic String getSummary() {\n\t\tif (soundFile == null)\n\t\t\treturn \"\"; //$NON-NLS-1$\n\t\treturn soundFile.getAbsolutePath();\n\t}\n\n\t@Override\n\tpublic String getTypeName() {\n\t\treturn Messages.getString(\"SoundAction.ActionTypeName\"); //$NON-NLS-1$\n\t}\n\n\t@Override\n\tpublic String getMemento() {\n\t\tString soundData = \"\"; //$NON-NLS-1$\n\t\tif (soundFile != null) {\n\t\t\ttry {\n\t\t\t\tDocumentBuilder docBuilder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n\t\t\t\tDocument doc = docBuilder.newDocument();\n\n\t\t\t\tElement rootElement = doc.createElement(\"soundData\"); //$NON-NLS-1$\n\t\t\t\trootElement.setAttribute(\"file\", soundFile.getAbsolutePath()); //$NON-NLS-1$\n\n\t\t\t\tdoc.appendChild(rootElement);\n\n\t\t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n\n\t\t\t\tTransformerFactory factory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n\t\t\t\tTransformer transformer = factory.newTransformer();\n\t\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\n\t\t\t\tDOMSource source = new DOMSource(doc);\n\t\t\t\tStreamResult outputTarget = new StreamResult(s);\n\t\t\t\ttransformer.transform(source, outputTarget);\n\n\t\t\t\tsoundData = s.toString(\"UTF8\"); //$NON-NLS-1$\n\n\t\t\t} catch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\treturn soundData;\n\t}\n\n\t@Override\n\tpublic void initializeFromMemento(String data) {\n\t\tif (data == null || data.isBlank()) {\n\t\t\t// An empty string will cause a sax parser error below\n\t\t\treturn;\n\t\t}\n\n\t\tElement root = null;\n\t\tDocumentBuilder parser;\n\t\ttry {\n\t\t\tparser = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n\t\t\tparser.setErrorHandler(new DefaultHandler());\n\t\t\troot = parser.parse(new InputSource(new StringReader(data))).getDocumentElement();\n\t\t\tString value = root.getAttribute(\"file\"); //$NON-NLS-1$\n\t\t\tif (value == null)\n\t\t\t\tthrow new Exception();\n\t\t\tsoundFile = new File(value);\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\t@Override\n\tpublic String getIdentifier() {\n\t\treturn \"org.eclipse.cdt.debug.ui.breakpointactions.SoundAction\"; //$NON-NLS-1$\n\t}\n\n\tpublic void setSoundFile(File soundFile) {\n\t\tthis.soundFile = soundFile;\n\t}\n\n}\n",
    "patch": "@@ -27,7 +27,6 @@\n import javax.sound.sampled.SourceDataLine;\n import javax.sound.sampled.UnsupportedAudioFileException;\n import javax.xml.parsers.DocumentBuilder;\n-import javax.xml.parsers.DocumentBuilderFactory;\n import javax.xml.transform.OutputKeys;\n import javax.xml.transform.Transformer;\n import javax.xml.transform.TransformerFactory;\n@@ -37,6 +36,7 @@\n import org.eclipse.cdt.debug.core.CDIDebugModel;\n import org.eclipse.cdt.debug.core.breakpointactions.AbstractBreakpointAction;\n import org.eclipse.cdt.debug.internal.core.ICDebugInternalConstants;\n+import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n import org.eclipse.core.runtime.IAdaptable;\n import org.eclipse.core.runtime.IProgressMonitor;\n import org.eclipse.core.runtime.IStatus;\n@@ -137,10 +137,8 @@ public String getTypeName() {\n \tpublic String getMemento() {\n \t\tString soundData = \"\"; //$NON-NLS-1$\n \t\tif (soundFile != null) {\n-\t\t\tDocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();\n-\t\t\tDocumentBuilder docBuilder = null;\n \t\t\ttry {\n-\t\t\t\tdocBuilder = dfactory.newDocumentBuilder();\n+\t\t\t\tDocumentBuilder docBuilder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\t\tDocument doc = docBuilder.newDocument();\n \n \t\t\t\tElement rootElement = doc.createElement(\"soundData\"); //$NON-NLS-1$\n@@ -150,7 +148,7 @@ public String getMemento() {\n \n \t\t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n \n-\t\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n+\t\t\t\tTransformerFactory factory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n \t\t\t\tTransformer transformer = factory.newTransformer();\n \t\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n \t\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n@@ -170,10 +168,15 @@ public String getMemento() {\n \n \t@Override\n \tpublic void initializeFromMemento(String data) {\n+\t\tif (data == null || data.isBlank()) {\n+\t\t\t// An empty string will cause a sax parser error below\n+\t\t\treturn;\n+\t\t}\n+\n \t\tElement root = null;\n \t\tDocumentBuilder parser;\n \t\ttry {\n-\t\t\tparser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n+\t\t\tparser = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tparser.setErrorHandler(new DefaultHandler());\n \t\t\troot = parser.parse(new InputSource(new StringReader(data))).getDocumentElement();\n \t\t\tString value = root.getAttribute(\"file\"); //$NON-NLS-1$",
    "function_modified_lines": {
      "added": [
        "import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n"
      ],
      "deleted": [
        "import javax.xml.parsers.DocumentBuilderFactory;\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "In Eclipse IDE versions < 2023-09 (4.29) some files with xml content are parsed vulnerable against all sorts of XXE attacks. The user just needs to open any evil project or update an open project with a vulnerable file (for example for review a foreign repository or patch).\n",
    "id": 12887
  },
  {
    "cve_id": "CVE-2023-4218",
    "code_before_change": "{\n\t\t\tDocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();\n\t\t\tDocumentBuilder docBuilder = null;\n\t\t\ttry {\n\t\t\t\tdocBuilder = dfactory.newDocumentBuilder();\n\t\t\t\tDocument doc = docBuilder.newDocument();\n\n\t\t\t\tElement rootElement = doc.createElement(\"soundData\"); //$NON-NLS-1$\n\t\t\t\trootElement.setAttribute(\"file\", soundFile.getAbsolutePath()); //$NON-NLS-1$\n\n\t\t\t\tdoc.appendChild(rootElement);\n\n\t\t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n\n\t\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n\t\t\t\tTransformer transformer = factory.newTransformer();\n\t\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\n\t\t\t\tDOMSource source = new DOMSource(doc);\n\t\t\t\tStreamResult outputTarget = new StreamResult(s);\n\t\t\t\ttransformer.transform(source, outputTarget);\n\n\t\t\t\tsoundData = s.toString(\"UTF8\"); //$NON-NLS-1$\n\n\t\t\t} catch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}",
    "code_after_change": "{\n\t\t\t\tDocumentBuilder docBuilder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n\t\t\t\tDocument doc = docBuilder.newDocument();\n\n\t\t\t\tElement rootElement = doc.createElement(\"soundData\"); //$NON-NLS-1$\n\t\t\t\trootElement.setAttribute(\"file\", soundFile.getAbsolutePath()); //$NON-NLS-1$\n\n\t\t\t\tdoc.appendChild(rootElement);\n\n\t\t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n\n\t\t\t\tTransformerFactory factory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n\t\t\t\tTransformer transformer = factory.newTransformer();\n\t\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\n\t\t\t\tDOMSource source = new DOMSource(doc);\n\t\t\t\tStreamResult outputTarget = new StreamResult(s);\n\t\t\t\ttransformer.transform(source, outputTarget);\n\n\t\t\t\tsoundData = s.toString(\"UTF8\"); //$NON-NLS-1$\n\n\t\t\t}",
    "patch": "@@ -27,7 +27,6 @@\n import javax.sound.sampled.SourceDataLine;\n import javax.sound.sampled.UnsupportedAudioFileException;\n import javax.xml.parsers.DocumentBuilder;\n-import javax.xml.parsers.DocumentBuilderFactory;\n import javax.xml.transform.OutputKeys;\n import javax.xml.transform.Transformer;\n import javax.xml.transform.TransformerFactory;\n@@ -37,6 +36,7 @@\n import org.eclipse.cdt.debug.core.CDIDebugModel;\n import org.eclipse.cdt.debug.core.breakpointactions.AbstractBreakpointAction;\n import org.eclipse.cdt.debug.internal.core.ICDebugInternalConstants;\n+import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n import org.eclipse.core.runtime.IAdaptable;\n import org.eclipse.core.runtime.IProgressMonitor;\n import org.eclipse.core.runtime.IStatus;\n@@ -137,10 +137,8 @@ public String getTypeName() {\n \tpublic String getMemento() {\n \t\tString soundData = \"\"; //$NON-NLS-1$\n \t\tif (soundFile != null) {\n-\t\t\tDocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();\n-\t\t\tDocumentBuilder docBuilder = null;\n \t\t\ttry {\n-\t\t\t\tdocBuilder = dfactory.newDocumentBuilder();\n+\t\t\t\tDocumentBuilder docBuilder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\t\tDocument doc = docBuilder.newDocument();\n \n \t\t\t\tElement rootElement = doc.createElement(\"soundData\"); //$NON-NLS-1$\n@@ -150,7 +148,7 @@ public String getMemento() {\n \n \t\t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n \n-\t\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n+\t\t\t\tTransformerFactory factory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n \t\t\t\tTransformer transformer = factory.newTransformer();\n \t\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n \t\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n@@ -170,10 +168,15 @@ public String getMemento() {\n \n \t@Override\n \tpublic void initializeFromMemento(String data) {\n+\t\tif (data == null || data.isBlank()) {\n+\t\t\t// An empty string will cause a sax parser error below\n+\t\t\treturn;\n+\t\t}\n+\n \t\tElement root = null;\n \t\tDocumentBuilder parser;\n \t\ttry {\n-\t\t\tparser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n+\t\t\tparser = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tparser.setErrorHandler(new DefaultHandler());\n \t\t\troot = parser.parse(new InputSource(new StringReader(data))).getDocumentElement();\n \t\t\tString value = root.getAttribute(\"file\"); //$NON-NLS-1$",
    "function_modified_lines": {
      "added": [
        "\t\t\t\tDocumentBuilder docBuilder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n",
        "\t\t\t\tTransformerFactory factory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n"
      ],
      "deleted": [
        "\t\t\tDocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();\n",
        "\t\t\tDocumentBuilder docBuilder = null;\n",
        "\t\t\t\tdocBuilder = dfactory.newDocumentBuilder();\n",
        "\t\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "In Eclipse IDE versions < 2023-09 (4.29) some files with xml content are parsed vulnerable against all sorts of XXE attacks. The user just needs to open any evil project or update an open project with a vulnerable file (for example for review a foreign repository or patch).\n",
    "id": 12888
  },
  {
    "cve_id": "CVE-2023-4218",
    "code_before_change": "/*******************************************************************************\n * Copyright (c) 2007, 2012 Nokia and others.\n *\n * This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n *\n * Contributors:\n *     Nokia - initial API and implementation\n *******************************************************************************/\npackage org.eclipse.cdt.debug.ui.breakpointactions;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.StringReader;\nimport java.util.ArrayList;\nimport java.util.Iterator;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.eclipse.cdt.debug.core.breakpointactions.IBreakpointAction;\nimport org.eclipse.cdt.debug.ui.CDebugUIPlugin;\nimport org.eclipse.core.runtime.Path;\nimport org.eclipse.core.runtime.PlatformObject;\nimport org.eclipse.swt.widgets.Composite;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.helpers.DefaultHandler;\n\npublic class SoundActionPage extends PlatformObject implements IBreakpointActionPage {\n\n\tprivate static final String SOUND_ACTION_RECENT = \"SoundBehaviorDialog.recentSounds\"; //$NON-NLS-1$\n\n\tprivate static boolean isWindows() {\n\t\tString os = System.getProperty(\"os.name\"); //$NON-NLS-1$\n\t\treturn (os != null && os.toLowerCase().startsWith(\"win\")); //$NON-NLS-1$\n\t}\n\n\tprivate static boolean isMacOS() {\n\t\tString os = System.getProperty(\"os.name\"); //$NON-NLS-1$\n\t\treturn (os != null && os.toLowerCase().startsWith(\"mac\")); //$NON-NLS-1$\n\t}\n\n\tprivate SoundActionComposite editor = null;\n\tprivate String mediaPath = \"\"; //$NON-NLS-1$\n\n\tprivate ArrayList<File> recentSounds = new ArrayList<>();\n\n\tprivate SoundAction soundAction;\n\n\tpublic SoundActionPage() {\n\t\tif (isWindows())\n\t\t\tmediaPath = \"C:\\\\WINNT\\\\Media\\\\\"; //$NON-NLS-1$\n\t\tif (isMacOS())\n\t\t\tmediaPath = \"/System/Library/Sounds\"; //$NON-NLS-1$\n\n\t\tloadRecentSounds();\n\t}\n\n\t@Override\n\tpublic void actionDialogCanceled() {\n\t}\n\n\t@Override\n\tpublic void actionDialogOK() {\n\t\tsaveRecentSounds();\n\t\tsoundAction.setSoundFile(editor.getSoundFile());\n\t}\n\n\tpublic void addRecentSound(File soundFile) {\n\t\tString soundFilePath = soundFile.getAbsolutePath();\n\t\tint removeIndex = -1;\n\t\tint fileCount = 0;\n\t\tfor (Iterator<File> iter = recentSounds.iterator(); iter.hasNext() && removeIndex < 0;) {\n\t\t\tFile element = iter.next();\n\t\t\tif (element.getAbsolutePath().equals(soundFilePath))\n\t\t\t\tremoveIndex = fileCount;\n\t\t\tfileCount++;\n\t\t}\n\t\tif (removeIndex >= 0)\n\t\t\trecentSounds.remove(removeIndex);\n\t\trecentSounds.add(soundFile);\n\t\tif (recentSounds.size() > 10)\n\t\t\trecentSounds.remove(0);\n\n\t}\n\n\t@Override\n\tpublic Composite createComposite(IBreakpointAction action, Composite composite, int style) {\n\t\tthis.soundAction = (SoundAction) action;\n\t\tloadRecentSounds();\n\t\tif (soundAction.getSoundFile() == null && recentSounds.size() > 0)\n\t\t\tsoundAction.setSoundFile(recentSounds.get(0));\n\t\teditor = new SoundActionComposite(composite, style, this);\n\t\treturn editor;\n\t}\n\n\tpublic String getMediaPath() {\n\t\treturn mediaPath;\n\t}\n\n\tpublic ArrayList<File> getRecentSounds() {\n\t\treturn recentSounds;\n\t}\n\n\tpublic String getSummary() {\n\t\tif (soundAction.getSoundFile() == null)\n\t\t\treturn \"\"; //$NON-NLS-1$\n\t\treturn soundAction.getSoundFile().getAbsolutePath();\n\t}\n\n\tprivate void initializeRecentSounds() {\n\n\t\tif (isWindows()) {\n\t\t\tString defaultSounds[] = { \"chimes.wav\", \"chord.wav\", \"ding.wav\", \"notify.wav\", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$\n\t\t\t\t\t\"tada.wav\" }; //$NON-NLS-1$\n\n\t\t\tfor (int i = 0; i < defaultSounds.length; i++) {\n\t\t\t\tFile soundFile = new File(mediaPath + defaultSounds[i]);\n\t\t\t\tif (soundFile.exists())\n\t\t\t\t\trecentSounds.add(soundFile);\n\t\t\t}\n\t\t}\n\t\tif (isMacOS()) {\n\t\t\tFile macSounds = new File(mediaPath);\n\t\t\tFile[] soundFiles = macSounds.listFiles();\n\n\t\t\tfor (int i = 0; i < soundFiles.length; i++) {\n\t\t\t\tString fileExtension = new Path(soundFiles[i].getAbsolutePath()).getFileExtension();\n\t\t\t\tif (fileExtension.equalsIgnoreCase(\"aiff\") || fileExtension.equalsIgnoreCase(\"wav\")) //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\trecentSounds.add(soundFiles[i]);\n\n\t\t\t}\n\t\t}\n\t\tsaveRecentSounds();\n\n\t}\n\n\tprivate void loadRecentSounds() {\n\t\tString recentSoundData = CDebugUIPlugin.getDefault().getPreferenceStore().getString(SOUND_ACTION_RECENT);\n\n\t\tif (recentSoundData == null || recentSoundData.length() == 0) {\n\t\t\tinitializeRecentSounds();\n\t\t\treturn;\n\t\t}\n\n\t\trecentSounds = new ArrayList<>();\n\n\t\tElement root = null;\n\t\tDocumentBuilder parser;\n\t\ttry {\n\t\t\tparser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n\t\t\tparser.setErrorHandler(new DefaultHandler());\n\t\t\troot = parser.parse(new InputSource(new StringReader(recentSoundData))).getDocumentElement();\n\n\t\t\tNodeList nodeList = root.getChildNodes();\n\t\t\tint entryCount = nodeList.getLength();\n\n\t\t\tfor (int i = 0; i < entryCount; i++) {\n\t\t\t\tNode node = nodeList.item(i);\n\t\t\t\tshort type = node.getNodeType();\n\t\t\t\tif (type == Node.ELEMENT_NODE) {\n\t\t\t\t\tElement subElement = (Element) node;\n\t\t\t\t\tString nodeName = subElement.getNodeName();\n\t\t\t\t\tif (nodeName.equalsIgnoreCase(\"soundFileName\")) { //$NON-NLS-1$\n\t\t\t\t\t\tString value = subElement.getAttribute(\"name\"); //$NON-NLS-1$\n\t\t\t\t\t\tif (value == null)\n\t\t\t\t\t\t\tthrow new Exception();\n\n\t\t\t\t\t\tFile soundFile = new File(value);\n\t\t\t\t\t\tif (soundFile.exists()) {\n\t\t\t\t\t\t\trecentSounds.add(soundFile);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\tif (recentSounds.size() == 0)\n\t\t\tinitializeRecentSounds();\n\t}\n\n\tpublic void saveRecentSounds() {\n\t\tString recentSoundData = \"\"; //$NON-NLS-1$\n\n\t\tDocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();\n\t\tDocumentBuilder docBuilder = null;\n\t\ttry {\n\t\t\tdocBuilder = dfactory.newDocumentBuilder();\n\t\t\tDocument doc = docBuilder.newDocument();\n\n\t\t\tElement rootElement = doc.createElement(\"recentSounds\"); //$NON-NLS-1$\n\t\t\tdoc.appendChild(rootElement);\n\n\t\t\tfor (Iterator<File> iter = recentSounds.iterator(); iter.hasNext();) {\n\t\t\t\tFile soundFile = iter.next();\n\n\t\t\t\tElement element = doc.createElement(\"soundFileName\"); //$NON-NLS-1$\n\t\t\t\telement.setAttribute(\"name\", soundFile.getAbsolutePath()); //$NON-NLS-1$\n\t\t\t\trootElement.appendChild(element);\n\n\t\t\t}\n\n\t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n\n\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n\t\t\tTransformer transformer = factory.newTransformer();\n\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\n\t\t\tDOMSource source = new DOMSource(doc);\n\t\t\tStreamResult outputTarget = new StreamResult(s);\n\t\t\ttransformer.transform(source, outputTarget);\n\n\t\t\trecentSoundData = s.toString(\"UTF8\"); //$NON-NLS-1$\n\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\tCDebugUIPlugin.getDefault().getPreferenceStore().setValue(SOUND_ACTION_RECENT, recentSoundData);\n\t}\n\n\tpublic SoundAction getSoundAction() {\n\t\treturn soundAction;\n\t}\n\n}\n",
    "code_after_change": "/*******************************************************************************\n * Copyright (c) 2007, 2012 Nokia and others.\n *\n * This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n *\n * Contributors:\n *     Nokia - initial API and implementation\n *******************************************************************************/\npackage org.eclipse.cdt.debug.ui.breakpointactions;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.StringReader;\nimport java.util.ArrayList;\nimport java.util.Iterator;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.eclipse.cdt.debug.core.breakpointactions.IBreakpointAction;\nimport org.eclipse.cdt.debug.ui.CDebugUIPlugin;\nimport org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\nimport org.eclipse.core.runtime.Path;\nimport org.eclipse.core.runtime.PlatformObject;\nimport org.eclipse.swt.widgets.Composite;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.helpers.DefaultHandler;\n\npublic class SoundActionPage extends PlatformObject implements IBreakpointActionPage {\n\n\tprivate static final String SOUND_ACTION_RECENT = \"SoundBehaviorDialog.recentSounds\"; //$NON-NLS-1$\n\n\tprivate static boolean isWindows() {\n\t\tString os = System.getProperty(\"os.name\"); //$NON-NLS-1$\n\t\treturn (os != null && os.toLowerCase().startsWith(\"win\")); //$NON-NLS-1$\n\t}\n\n\tprivate static boolean isMacOS() {\n\t\tString os = System.getProperty(\"os.name\"); //$NON-NLS-1$\n\t\treturn (os != null && os.toLowerCase().startsWith(\"mac\")); //$NON-NLS-1$\n\t}\n\n\tprivate SoundActionComposite editor = null;\n\tprivate String mediaPath = \"\"; //$NON-NLS-1$\n\n\tprivate ArrayList<File> recentSounds = new ArrayList<>();\n\n\tprivate SoundAction soundAction;\n\n\tpublic SoundActionPage() {\n\t\tif (isWindows())\n\t\t\tmediaPath = \"C:\\\\WINNT\\\\Media\\\\\"; //$NON-NLS-1$\n\t\tif (isMacOS())\n\t\t\tmediaPath = \"/System/Library/Sounds\"; //$NON-NLS-1$\n\n\t\tloadRecentSounds();\n\t}\n\n\t@Override\n\tpublic void actionDialogCanceled() {\n\t}\n\n\t@Override\n\tpublic void actionDialogOK() {\n\t\tsaveRecentSounds();\n\t\tsoundAction.setSoundFile(editor.getSoundFile());\n\t}\n\n\tpublic void addRecentSound(File soundFile) {\n\t\tString soundFilePath = soundFile.getAbsolutePath();\n\t\tint removeIndex = -1;\n\t\tint fileCount = 0;\n\t\tfor (Iterator<File> iter = recentSounds.iterator(); iter.hasNext() && removeIndex < 0;) {\n\t\t\tFile element = iter.next();\n\t\t\tif (element.getAbsolutePath().equals(soundFilePath))\n\t\t\t\tremoveIndex = fileCount;\n\t\t\tfileCount++;\n\t\t}\n\t\tif (removeIndex >= 0)\n\t\t\trecentSounds.remove(removeIndex);\n\t\trecentSounds.add(soundFile);\n\t\tif (recentSounds.size() > 10)\n\t\t\trecentSounds.remove(0);\n\n\t}\n\n\t@Override\n\tpublic Composite createComposite(IBreakpointAction action, Composite composite, int style) {\n\t\tthis.soundAction = (SoundAction) action;\n\t\tloadRecentSounds();\n\t\tif (soundAction.getSoundFile() == null && recentSounds.size() > 0)\n\t\t\tsoundAction.setSoundFile(recentSounds.get(0));\n\t\teditor = new SoundActionComposite(composite, style, this);\n\t\treturn editor;\n\t}\n\n\tpublic String getMediaPath() {\n\t\treturn mediaPath;\n\t}\n\n\tpublic ArrayList<File> getRecentSounds() {\n\t\treturn recentSounds;\n\t}\n\n\tpublic String getSummary() {\n\t\tif (soundAction.getSoundFile() == null)\n\t\t\treturn \"\"; //$NON-NLS-1$\n\t\treturn soundAction.getSoundFile().getAbsolutePath();\n\t}\n\n\tprivate void initializeRecentSounds() {\n\n\t\tif (isWindows()) {\n\t\t\tString defaultSounds[] = { \"chimes.wav\", \"chord.wav\", \"ding.wav\", \"notify.wav\", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$\n\t\t\t\t\t\"tada.wav\" }; //$NON-NLS-1$\n\n\t\t\tfor (int i = 0; i < defaultSounds.length; i++) {\n\t\t\t\tFile soundFile = new File(mediaPath + defaultSounds[i]);\n\t\t\t\tif (soundFile.exists())\n\t\t\t\t\trecentSounds.add(soundFile);\n\t\t\t}\n\t\t}\n\t\tif (isMacOS()) {\n\t\t\tFile macSounds = new File(mediaPath);\n\t\t\tFile[] soundFiles = macSounds.listFiles();\n\n\t\t\tfor (int i = 0; i < soundFiles.length; i++) {\n\t\t\t\tString fileExtension = new Path(soundFiles[i].getAbsolutePath()).getFileExtension();\n\t\t\t\tif (fileExtension.equalsIgnoreCase(\"aiff\") || fileExtension.equalsIgnoreCase(\"wav\")) //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\trecentSounds.add(soundFiles[i]);\n\n\t\t\t}\n\t\t}\n\t\tsaveRecentSounds();\n\n\t}\n\n\tprivate void loadRecentSounds() {\n\t\tString recentSoundData = CDebugUIPlugin.getDefault().getPreferenceStore().getString(SOUND_ACTION_RECENT);\n\n\t\tif (recentSoundData == null || recentSoundData.length() == 0) {\n\t\t\tinitializeRecentSounds();\n\t\t\treturn;\n\t\t}\n\n\t\trecentSounds = new ArrayList<>();\n\n\t\tElement root = null;\n\t\tDocumentBuilder parser;\n\t\ttry {\n\t\t\tparser = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n\t\t\tparser.setErrorHandler(new DefaultHandler());\n\t\t\troot = parser.parse(new InputSource(new StringReader(recentSoundData))).getDocumentElement();\n\n\t\t\tNodeList nodeList = root.getChildNodes();\n\t\t\tint entryCount = nodeList.getLength();\n\n\t\t\tfor (int i = 0; i < entryCount; i++) {\n\t\t\t\tNode node = nodeList.item(i);\n\t\t\t\tshort type = node.getNodeType();\n\t\t\t\tif (type == Node.ELEMENT_NODE) {\n\t\t\t\t\tElement subElement = (Element) node;\n\t\t\t\t\tString nodeName = subElement.getNodeName();\n\t\t\t\t\tif (nodeName.equalsIgnoreCase(\"soundFileName\")) { //$NON-NLS-1$\n\t\t\t\t\t\tString value = subElement.getAttribute(\"name\"); //$NON-NLS-1$\n\t\t\t\t\t\tif (value == null)\n\t\t\t\t\t\t\tthrow new Exception();\n\n\t\t\t\t\t\tFile soundFile = new File(value);\n\t\t\t\t\t\tif (soundFile.exists()) {\n\t\t\t\t\t\t\trecentSounds.add(soundFile);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\tif (recentSounds.size() == 0)\n\t\t\tinitializeRecentSounds();\n\t}\n\n\tpublic void saveRecentSounds() {\n\t\tString recentSoundData = \"\"; //$NON-NLS-1$\n\n\t\ttry {\n\t\t\tDocumentBuilder docBuilder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n\t\t\tDocument doc = docBuilder.newDocument();\n\n\t\t\tElement rootElement = doc.createElement(\"recentSounds\"); //$NON-NLS-1$\n\t\t\tdoc.appendChild(rootElement);\n\n\t\t\tfor (Iterator<File> iter = recentSounds.iterator(); iter.hasNext();) {\n\t\t\t\tFile soundFile = iter.next();\n\n\t\t\t\tElement element = doc.createElement(\"soundFileName\"); //$NON-NLS-1$\n\t\t\t\telement.setAttribute(\"name\", soundFile.getAbsolutePath()); //$NON-NLS-1$\n\t\t\t\trootElement.appendChild(element);\n\n\t\t\t}\n\n\t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n\n\t\t\tTransformerFactory factory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n\t\t\tTransformer transformer = factory.newTransformer();\n\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\n\t\t\tDOMSource source = new DOMSource(doc);\n\t\t\tStreamResult outputTarget = new StreamResult(s);\n\t\t\ttransformer.transform(source, outputTarget);\n\n\t\t\trecentSoundData = s.toString(\"UTF8\"); //$NON-NLS-1$\n\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\tCDebugUIPlugin.getDefault().getPreferenceStore().setValue(SOUND_ACTION_RECENT, recentSoundData);\n\t}\n\n\tpublic SoundAction getSoundAction() {\n\t\treturn soundAction;\n\t}\n\n}\n",
    "patch": "@@ -20,7 +20,6 @@\n import java.util.Iterator;\n \n import javax.xml.parsers.DocumentBuilder;\n-import javax.xml.parsers.DocumentBuilderFactory;\n import javax.xml.transform.OutputKeys;\n import javax.xml.transform.Transformer;\n import javax.xml.transform.TransformerFactory;\n@@ -29,6 +28,7 @@\n \n import org.eclipse.cdt.debug.core.breakpointactions.IBreakpointAction;\n import org.eclipse.cdt.debug.ui.CDebugUIPlugin;\n+import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n import org.eclipse.core.runtime.Path;\n import org.eclipse.core.runtime.PlatformObject;\n import org.eclipse.swt.widgets.Composite;\n@@ -161,7 +161,7 @@ private void loadRecentSounds() {\n \t\tElement root = null;\n \t\tDocumentBuilder parser;\n \t\ttry {\n-\t\t\tparser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n+\t\t\tparser = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tparser.setErrorHandler(new DefaultHandler());\n \t\t\troot = parser.parse(new InputSource(new StringReader(recentSoundData))).getDocumentElement();\n \n@@ -198,10 +198,8 @@ private void loadRecentSounds() {\n \tpublic void saveRecentSounds() {\n \t\tString recentSoundData = \"\"; //$NON-NLS-1$\n \n-\t\tDocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();\n-\t\tDocumentBuilder docBuilder = null;\n \t\ttry {\n-\t\t\tdocBuilder = dfactory.newDocumentBuilder();\n+\t\t\tDocumentBuilder docBuilder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tDocument doc = docBuilder.newDocument();\n \n \t\t\tElement rootElement = doc.createElement(\"recentSounds\"); //$NON-NLS-1$\n@@ -218,7 +216,7 @@ public void saveRecentSounds() {\n \n \t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n \n-\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n+\t\t\tTransformerFactory factory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n \t\t\tTransformer transformer = factory.newTransformer();\n \t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n \t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$",
    "function_modified_lines": {
      "added": [
        "import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n"
      ],
      "deleted": [
        "import javax.xml.parsers.DocumentBuilderFactory;\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "In Eclipse IDE versions < 2023-09 (4.29) some files with xml content are parsed vulnerable against all sorts of XXE attacks. The user just needs to open any evil project or update an open project with a vulnerable file (for example for review a foreign repository or patch).\n",
    "id": 12889
  },
  {
    "cve_id": "CVE-2023-4218",
    "code_before_change": "/*******************************************************************************\n * Copyright (c) 2004, 2016 QNX Software Systems and others.\n *\n * This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n *\n * Contributors:\n * QNX Software Systems - Initial API and implementation\n *******************************************************************************/\npackage org.eclipse.cdt.debug.ui.sourcelookup;\n\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.text.MessageFormat;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.TransformerException;\n\nimport org.eclipse.cdt.debug.core.CDebugUtils;\nimport org.eclipse.cdt.debug.core.ICDTLaunchConfigurationConstants;\nimport org.eclipse.cdt.debug.core.sourcelookup.ICSourceLocator;\nimport org.eclipse.cdt.debug.core.sourcelookup.SourceLookupFactory;\nimport org.eclipse.cdt.debug.ui.CDebugUIPlugin;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.resources.IResourceChangeListener;\nimport org.eclipse.core.resources.ResourcesPlugin;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.IAdaptable;\nimport org.eclipse.core.runtime.IStatus;\nimport org.eclipse.core.runtime.Status;\nimport org.eclipse.debug.core.ILaunchConfiguration;\nimport org.eclipse.debug.core.model.IPersistableSourceLocator;\nimport org.eclipse.debug.core.model.IStackFrame;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\n\n/**\n * Old default source locator. We keep it for migration purposes.\n */\npublic class OldDefaultSourceLocator implements IPersistableSourceLocator, IAdaptable {\n\n\t/**\n\t * Identifier for the 'Default C/C++ Source Locator' extension (value <code>\"org.eclipse.cdt.debug.ui.DefaultSourceLocator\"</code>).\n\t */\n\tpublic static final String ID_DEFAULT_SOURCE_LOCATOR = CDebugUIPlugin.getUniqueIdentifier()\n\t\t\t+ \".DefaultSourceLocator\"; //$NON-NLS-1$\n\n\t// to support old configurations\n\tpublic static final String ID_OLD_DEFAULT_SOURCE_LOCATOR = \"org.eclipse.cdt.launch\" + \".DefaultSourceLocator\"; //$NON-NLS-1$ //$NON-NLS-2$\n\n\tprotected static final String ELEMENT_NAME = \"PromptingSourceLocator\"; //$NON-NLS-1$\n\n\tprivate static final String ATTR_PROJECT = \"project\"; //$NON-NLS-1$\n\n\tprivate static final String ATTR_MEMENTO = \"memento\"; //$NON-NLS-1$\n\n\t/**\n\t * Underlying source locator.\n\t */\n\tprivate ICSourceLocator fSourceLocator;\n\n\tpublic OldDefaultSourceLocator() {\n\t\tsuper();\n\t}\n\n\t/* (non-Javadoc)\n\t * @see org.eclipse.debug.core.model.IPersistableSourceLocator#getMemento()\n\t */\n\t@Override\n\tpublic String getMemento() throws CoreException {\n\t\tif (getCSourceLocator() != null) {\n\t\t\tDocument document = null;\n\t\t\tThrowable ex = null;\n\t\t\ttry {\n\t\t\t\tdocument = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n\t\t\t\tElement element = document.createElement(ELEMENT_NAME);\n\t\t\t\tdocument.appendChild(element);\n\t\t\t\telement.setAttribute(ATTR_PROJECT, getCSourceLocator().getProject().getName());\n\t\t\t\tIPersistableSourceLocator psl = getPersistableSourceLocator();\n\t\t\t\tif (psl != null) {\n\t\t\t\t\telement.setAttribute(ATTR_MEMENTO, psl.getMemento());\n\t\t\t\t}\n\t\t\t\treturn CDebugUtils.serializeDocument(document);\n\t\t\t} catch (ParserConfigurationException e) {\n\t\t\t\tex = e;\n\t\t\t} catch (IOException e) {\n\t\t\t\tex = e;\n\t\t\t} catch (TransformerException e) {\n\t\t\t\tex = e;\n\t\t\t}\n\t\t\tabort(SourceLookupMessages.getString(\"OldDefaultSourceLocator.1\"), ex); //$NON-NLS-1$\n\t\t}\n\t\treturn null;\n\t}\n\n\t/* (non-Javadoc)\n\t * @see org.eclipse.debug.core.model.IPersistableSourceLocator#initializeFromMemento(java.lang.String)\n\t */\n\t@Override\n\tpublic void initializeFromMemento(String memento) throws CoreException {\n\t\tException ex = null;\n\t\ttry {\n\t\t\tElement root = null;\n\t\t\tDocumentBuilder parser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n\t\t\tStringReader reader = new StringReader(memento);\n\t\t\tInputSource source = new InputSource(reader);\n\t\t\troot = parser.parse(source).getDocumentElement();\n\t\t\tif (!root.getNodeName().equalsIgnoreCase(ELEMENT_NAME)) {\n\t\t\t\tabort(SourceLookupMessages.getString(\"OldDefaultSourceLocator.2\"), null); //$NON-NLS-1$\n\t\t\t}\n\t\t\tString projectName = root.getAttribute(ATTR_PROJECT);\n\t\t\tString data = root.getAttribute(ATTR_MEMENTO);\n\t\t\tif (isEmpty(projectName)) {\n\t\t\t\tabort(SourceLookupMessages.getString(\"OldDefaultSourceLocator.3\"), null); //$NON-NLS-1$\n\t\t\t}\n\t\t\tIProject project = ResourcesPlugin.getWorkspace().getRoot().getProject(projectName);\n\t\t\tif (getCSourceLocator() == null)\n\t\t\t\tsetCSourceLocator(SourceLookupFactory.createSourceLocator(project));\n\t\t\tif (getCSourceLocator().getProject() != null && !getCSourceLocator().getProject().equals(project))\n\t\t\t\treturn;\n\t\t\tif (project == null || !project.exists() || !project.isOpen())\n\t\t\t\tabort(MessageFormat.format(SourceLookupMessages.getString(\"OldDefaultSourceLocator.4\"), //$NON-NLS-1$\n\t\t\t\t\t\tnew Object[] { projectName }), null);\n\t\t\tIPersistableSourceLocator psl = getPersistableSourceLocator();\n\t\t\tif (psl != null)\n\t\t\t\tpsl.initializeFromMemento(data);\n\t\t\telse\n\t\t\t\tabort(SourceLookupMessages.getString(\"OldDefaultSourceLocator.5\"), null); //$NON-NLS-1$\n\t\t\treturn;\n\t\t} catch (ParserConfigurationException e) {\n\t\t\tex = e;\n\t\t} catch (SAXException e) {\n\t\t\tex = e;\n\t\t} catch (IOException e) {\n\t\t\tex = e;\n\t\t}\n\t\tabort(SourceLookupMessages.getString(\"OldDefaultSourceLocator.6\"), ex); //$NON-NLS-1$\n\t}\n\n\t/* (non-Javadoc)\n\t * @see org.eclipse.debug.core.model.IPersistableSourceLocator#initializeDefaults(org.eclipse.debug.core.ILaunchConfiguration)\n\t */\n\t@Override\n\tpublic void initializeDefaults(ILaunchConfiguration configuration) throws CoreException {\n\t\tsetCSourceLocator(SourceLookupFactory.createSourceLocator(getProject(configuration)));\n\t\tString memento = configuration.getAttribute(ILaunchConfiguration.ATTR_SOURCE_LOCATOR_MEMENTO, \"\"); //$NON-NLS-1$\n\t\tif (!isEmpty(memento))\n\t\t\tinitializeFromMemento(memento);\n\t}\n\n\t@Override\n\tpublic <T> T getAdapter(Class<T> adapter) {\n\t\tif (getCSourceLocator() instanceof IAdaptable) {\n\t\t\tif (adapter.equals(ICSourceLocator.class)) {\n\t\t\t\treturn ((IAdaptable) getCSourceLocator()).getAdapter(adapter);\n\t\t\t}\n\t\t\tif (adapter.equals(IResourceChangeListener.class)) {\n\t\t\t\treturn ((IAdaptable) getCSourceLocator()).getAdapter(adapter);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/* (non-Javadoc)\n\t * @see org.eclipse.debug.core.model.ISourceLocator#getSourceElement(org.eclipse.debug.core.model.IStackFrame)\n\t */\n\t@Override\n\tpublic Object getSourceElement(IStackFrame stackFrame) {\n\t\treturn null;\n\t}\n\n\tprivate ICSourceLocator getCSourceLocator() {\n\t\treturn fSourceLocator;\n\t}\n\n\tprivate void setCSourceLocator(ICSourceLocator locator) {\n\t\tfSourceLocator = locator;\n\t}\n\n\tprivate IPersistableSourceLocator getPersistableSourceLocator() {\n\t\tICSourceLocator sl = getCSourceLocator();\n\t\treturn (sl instanceof IPersistableSourceLocator) ? (IPersistableSourceLocator) sl : null;\n\t}\n\n\t/**\n\t * Throws an internal error exception\n\t */\n\tprivate void abort(String message, Throwable e) throws CoreException {\n\t\tIStatus s = new Status(IStatus.ERROR, CDebugUIPlugin.getUniqueIdentifier(), 0, message, e);\n\t\tthrow new CoreException(s);\n\t}\n\n\tprivate boolean isEmpty(String string) {\n\t\treturn string == null || string.trim().length() == 0;\n\t}\n\n\tprivate IProject getProject(ILaunchConfiguration configuration) throws CoreException {\n\t\tString projectName = configuration.getAttribute(ICDTLaunchConfigurationConstants.ATTR_PROJECT_NAME,\n\t\t\t\t(String) null);\n\t\tif (!isEmpty(projectName)) {\n\t\t\tIProject project = ResourcesPlugin.getWorkspace().getRoot().getProject(projectName);\n\t\t\tif (project.exists()) {\n\t\t\t\treturn project;\n\t\t\t}\n\t\t}\n\t\tabort(MessageFormat.format(SourceLookupMessages.getString(\"OldDefaultSourceLocator.9\"), //$NON-NLS-1$\n\t\t\t\tnew Object[] { projectName }), null);\n\t\treturn null;\n\t}\n}\n",
    "code_after_change": "/*******************************************************************************\n * Copyright (c) 2004, 2016 QNX Software Systems and others.\n *\n * This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n *\n * Contributors:\n * QNX Software Systems - Initial API and implementation\n *******************************************************************************/\npackage org.eclipse.cdt.debug.ui.sourcelookup;\n\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.text.MessageFormat;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.TransformerException;\n\nimport org.eclipse.cdt.debug.core.CDebugUtils;\nimport org.eclipse.cdt.debug.core.ICDTLaunchConfigurationConstants;\nimport org.eclipse.cdt.debug.core.sourcelookup.ICSourceLocator;\nimport org.eclipse.cdt.debug.core.sourcelookup.SourceLookupFactory;\nimport org.eclipse.cdt.debug.ui.CDebugUIPlugin;\nimport org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.resources.IResourceChangeListener;\nimport org.eclipse.core.resources.ResourcesPlugin;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.IAdaptable;\nimport org.eclipse.core.runtime.IStatus;\nimport org.eclipse.core.runtime.Status;\nimport org.eclipse.debug.core.ILaunchConfiguration;\nimport org.eclipse.debug.core.model.IPersistableSourceLocator;\nimport org.eclipse.debug.core.model.IStackFrame;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\n\n/**\n * Old default source locator. We keep it for migration purposes.\n */\npublic class OldDefaultSourceLocator implements IPersistableSourceLocator, IAdaptable {\n\n\t/**\n\t * Identifier for the 'Default C/C++ Source Locator' extension (value <code>\"org.eclipse.cdt.debug.ui.DefaultSourceLocator\"</code>).\n\t */\n\tpublic static final String ID_DEFAULT_SOURCE_LOCATOR = CDebugUIPlugin.getUniqueIdentifier()\n\t\t\t+ \".DefaultSourceLocator\"; //$NON-NLS-1$\n\n\t// to support old configurations\n\tpublic static final String ID_OLD_DEFAULT_SOURCE_LOCATOR = \"org.eclipse.cdt.launch\" + \".DefaultSourceLocator\"; //$NON-NLS-1$ //$NON-NLS-2$\n\n\tprotected static final String ELEMENT_NAME = \"PromptingSourceLocator\"; //$NON-NLS-1$\n\n\tprivate static final String ATTR_PROJECT = \"project\"; //$NON-NLS-1$\n\n\tprivate static final String ATTR_MEMENTO = \"memento\"; //$NON-NLS-1$\n\n\t/**\n\t * Underlying source locator.\n\t */\n\tprivate ICSourceLocator fSourceLocator;\n\n\tpublic OldDefaultSourceLocator() {\n\t\tsuper();\n\t}\n\n\t/* (non-Javadoc)\n\t * @see org.eclipse.debug.core.model.IPersistableSourceLocator#getMemento()\n\t */\n\t@Override\n\tpublic String getMemento() throws CoreException {\n\t\tif (getCSourceLocator() != null) {\n\t\t\tDocument document = null;\n\t\t\tThrowable ex = null;\n\t\t\ttry {\n\t\t\t\tdocument = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE().newDocument();\n\t\t\t\tElement element = document.createElement(ELEMENT_NAME);\n\t\t\t\tdocument.appendChild(element);\n\t\t\t\telement.setAttribute(ATTR_PROJECT, getCSourceLocator().getProject().getName());\n\t\t\t\tIPersistableSourceLocator psl = getPersistableSourceLocator();\n\t\t\t\tif (psl != null) {\n\t\t\t\t\telement.setAttribute(ATTR_MEMENTO, psl.getMemento());\n\t\t\t\t}\n\t\t\t\treturn CDebugUtils.serializeDocument(document);\n\t\t\t} catch (ParserConfigurationException e) {\n\t\t\t\tex = e;\n\t\t\t} catch (IOException e) {\n\t\t\t\tex = e;\n\t\t\t} catch (TransformerException e) {\n\t\t\t\tex = e;\n\t\t\t}\n\t\t\tabort(SourceLookupMessages.getString(\"OldDefaultSourceLocator.1\"), ex); //$NON-NLS-1$\n\t\t}\n\t\treturn null;\n\t}\n\n\t/* (non-Javadoc)\n\t * @see org.eclipse.debug.core.model.IPersistableSourceLocator#initializeFromMemento(java.lang.String)\n\t */\n\t@Override\n\tpublic void initializeFromMemento(String memento) throws CoreException {\n\t\tException ex = null;\n\t\ttry {\n\t\t\tElement root = null;\n\t\t\tDocumentBuilder parser = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n\t\t\tStringReader reader = new StringReader(memento);\n\t\t\tInputSource source = new InputSource(reader);\n\t\t\troot = parser.parse(source).getDocumentElement();\n\t\t\tif (!root.getNodeName().equalsIgnoreCase(ELEMENT_NAME)) {\n\t\t\t\tabort(SourceLookupMessages.getString(\"OldDefaultSourceLocator.2\"), null); //$NON-NLS-1$\n\t\t\t}\n\t\t\tString projectName = root.getAttribute(ATTR_PROJECT);\n\t\t\tString data = root.getAttribute(ATTR_MEMENTO);\n\t\t\tif (isEmpty(projectName)) {\n\t\t\t\tabort(SourceLookupMessages.getString(\"OldDefaultSourceLocator.3\"), null); //$NON-NLS-1$\n\t\t\t}\n\t\t\tIProject project = ResourcesPlugin.getWorkspace().getRoot().getProject(projectName);\n\t\t\tif (getCSourceLocator() == null)\n\t\t\t\tsetCSourceLocator(SourceLookupFactory.createSourceLocator(project));\n\t\t\tif (getCSourceLocator().getProject() != null && !getCSourceLocator().getProject().equals(project))\n\t\t\t\treturn;\n\t\t\tif (project == null || !project.exists() || !project.isOpen())\n\t\t\t\tabort(MessageFormat.format(SourceLookupMessages.getString(\"OldDefaultSourceLocator.4\"), //$NON-NLS-1$\n\t\t\t\t\t\tnew Object[] { projectName }), null);\n\t\t\tIPersistableSourceLocator psl = getPersistableSourceLocator();\n\t\t\tif (psl != null)\n\t\t\t\tpsl.initializeFromMemento(data);\n\t\t\telse\n\t\t\t\tabort(SourceLookupMessages.getString(\"OldDefaultSourceLocator.5\"), null); //$NON-NLS-1$\n\t\t\treturn;\n\t\t} catch (ParserConfigurationException e) {\n\t\t\tex = e;\n\t\t} catch (SAXException e) {\n\t\t\tex = e;\n\t\t} catch (IOException e) {\n\t\t\tex = e;\n\t\t}\n\t\tabort(SourceLookupMessages.getString(\"OldDefaultSourceLocator.6\"), ex); //$NON-NLS-1$\n\t}\n\n\t/* (non-Javadoc)\n\t * @see org.eclipse.debug.core.model.IPersistableSourceLocator#initializeDefaults(org.eclipse.debug.core.ILaunchConfiguration)\n\t */\n\t@Override\n\tpublic void initializeDefaults(ILaunchConfiguration configuration) throws CoreException {\n\t\tsetCSourceLocator(SourceLookupFactory.createSourceLocator(getProject(configuration)));\n\t\tString memento = configuration.getAttribute(ILaunchConfiguration.ATTR_SOURCE_LOCATOR_MEMENTO, \"\"); //$NON-NLS-1$\n\t\tif (!isEmpty(memento))\n\t\t\tinitializeFromMemento(memento);\n\t}\n\n\t@Override\n\tpublic <T> T getAdapter(Class<T> adapter) {\n\t\tif (getCSourceLocator() instanceof IAdaptable) {\n\t\t\tif (adapter.equals(ICSourceLocator.class)) {\n\t\t\t\treturn ((IAdaptable) getCSourceLocator()).getAdapter(adapter);\n\t\t\t}\n\t\t\tif (adapter.equals(IResourceChangeListener.class)) {\n\t\t\t\treturn ((IAdaptable) getCSourceLocator()).getAdapter(adapter);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/* (non-Javadoc)\n\t * @see org.eclipse.debug.core.model.ISourceLocator#getSourceElement(org.eclipse.debug.core.model.IStackFrame)\n\t */\n\t@Override\n\tpublic Object getSourceElement(IStackFrame stackFrame) {\n\t\treturn null;\n\t}\n\n\tprivate ICSourceLocator getCSourceLocator() {\n\t\treturn fSourceLocator;\n\t}\n\n\tprivate void setCSourceLocator(ICSourceLocator locator) {\n\t\tfSourceLocator = locator;\n\t}\n\n\tprivate IPersistableSourceLocator getPersistableSourceLocator() {\n\t\tICSourceLocator sl = getCSourceLocator();\n\t\treturn (sl instanceof IPersistableSourceLocator) ? (IPersistableSourceLocator) sl : null;\n\t}\n\n\t/**\n\t * Throws an internal error exception\n\t */\n\tprivate void abort(String message, Throwable e) throws CoreException {\n\t\tIStatus s = new Status(IStatus.ERROR, CDebugUIPlugin.getUniqueIdentifier(), 0, message, e);\n\t\tthrow new CoreException(s);\n\t}\n\n\tprivate boolean isEmpty(String string) {\n\t\treturn string == null || string.trim().length() == 0;\n\t}\n\n\tprivate IProject getProject(ILaunchConfiguration configuration) throws CoreException {\n\t\tString projectName = configuration.getAttribute(ICDTLaunchConfigurationConstants.ATTR_PROJECT_NAME,\n\t\t\t\t(String) null);\n\t\tif (!isEmpty(projectName)) {\n\t\t\tIProject project = ResourcesPlugin.getWorkspace().getRoot().getProject(projectName);\n\t\t\tif (project.exists()) {\n\t\t\t\treturn project;\n\t\t\t}\n\t\t}\n\t\tabort(MessageFormat.format(SourceLookupMessages.getString(\"OldDefaultSourceLocator.9\"), //$NON-NLS-1$\n\t\t\t\tnew Object[] { projectName }), null);\n\t\treturn null;\n\t}\n}\n",
    "patch": "@@ -18,7 +18,6 @@\n import java.text.MessageFormat;\n \n import javax.xml.parsers.DocumentBuilder;\n-import javax.xml.parsers.DocumentBuilderFactory;\n import javax.xml.parsers.ParserConfigurationException;\n import javax.xml.transform.TransformerException;\n \n@@ -27,6 +26,7 @@\n import org.eclipse.cdt.debug.core.sourcelookup.ICSourceLocator;\n import org.eclipse.cdt.debug.core.sourcelookup.SourceLookupFactory;\n import org.eclipse.cdt.debug.ui.CDebugUIPlugin;\n+import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n import org.eclipse.core.resources.IProject;\n import org.eclipse.core.resources.IResourceChangeListener;\n import org.eclipse.core.resources.ResourcesPlugin;\n@@ -80,7 +80,7 @@ public String getMemento() throws CoreException {\n \t\t\tDocument document = null;\n \t\t\tThrowable ex = null;\n \t\t\ttry {\n-\t\t\t\tdocument = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n+\t\t\t\tdocument = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE().newDocument();\n \t\t\t\tElement element = document.createElement(ELEMENT_NAME);\n \t\t\t\tdocument.appendChild(element);\n \t\t\t\telement.setAttribute(ATTR_PROJECT, getCSourceLocator().getProject().getName());\n@@ -109,7 +109,7 @@ public void initializeFromMemento(String memento) throws CoreException {\n \t\tException ex = null;\n \t\ttry {\n \t\t\tElement root = null;\n-\t\t\tDocumentBuilder parser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n+\t\t\tDocumentBuilder parser = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tStringReader reader = new StringReader(memento);\n \t\t\tInputSource source = new InputSource(reader);\n \t\t\troot = parser.parse(source).getDocumentElement();",
    "function_modified_lines": {
      "added": [
        "import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n"
      ],
      "deleted": [
        "import javax.xml.parsers.DocumentBuilderFactory;\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "In Eclipse IDE versions < 2023-09 (4.29) some files with xml content are parsed vulnerable against all sorts of XXE attacks. The user just needs to open any evil project or update an open project with a vulnerable file (for example for review a foreign repository or patch).\n",
    "id": 12890
  },
  {
    "cve_id": "CVE-2023-4218",
    "code_before_change": "{\n\t\tString returnValue = null;\n\n\t\tDocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();\n\t\tDocumentBuilder docBuilder = null;\n\t\ttry {\n\t\t\tdocBuilder = dfactory.newDocumentBuilder();\n\t\t\tDocument doc = docBuilder.newDocument();\n\n\t\t\tElement rootElement = doc.createElement(ROOT_ELEMENT_TAGNAME);\n\t\t\tdoc.appendChild(rootElement);\n\t\t\t// create one XML element per list entry to save\n\t\t\tfor (String lbl : labels) {\n\t\t\t\tElement elem = doc.createElement(ELEMENT_TAGNAME);\n\t\t\t\telem.setAttribute(ATTRIBUTE_VALUE, lbl);\n\t\t\t\trootElement.appendChild(elem);\n\t\t\t}\n\n\t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n\n\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n\t\t\tTransformer transformer = factory.newTransformer();\n\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\n\t\t\tDOMSource source = new DOMSource(doc);\n\t\t\tStreamResult outputTarget = new StreamResult(s);\n\t\t\ttransformer.transform(source, outputTarget);\n\n\t\t\treturnValue = s.toString(\"UTF8\"); //$NON-NLS-1$\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn returnValue;\n\t}",
    "code_after_change": "{\n\t\t\tDocumentBuilder docBuilder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n\t\t\tDocument doc = docBuilder.newDocument();\n\n\t\t\tElement rootElement = doc.createElement(ROOT_ELEMENT_TAGNAME);\n\t\t\tdoc.appendChild(rootElement);\n\t\t\t// create one XML element per list entry to save\n\t\t\tfor (String lbl : labels) {\n\t\t\t\tElement elem = doc.createElement(ELEMENT_TAGNAME);\n\t\t\t\telem.setAttribute(ATTRIBUTE_VALUE, lbl);\n\t\t\t\trootElement.appendChild(elem);\n\t\t\t}\n\n\t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n\n\t\t\tTransformerFactory factory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n\t\t\tTransformer transformer = factory.newTransformer();\n\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\n\t\t\tDOMSource source = new DOMSource(doc);\n\t\t\tStreamResult outputTarget = new StreamResult(s);\n\t\t\ttransformer.transform(source, outputTarget);\n\n\t\t\treturnValue = s.toString(\"UTF8\"); //$NON-NLS-1$\n\t\t}",
    "patch": "@@ -22,13 +22,13 @@\n import java.util.Map;\n \n import javax.xml.parsers.DocumentBuilder;\n-import javax.xml.parsers.DocumentBuilderFactory;\n import javax.xml.transform.OutputKeys;\n import javax.xml.transform.Transformer;\n import javax.xml.transform.TransformerFactory;\n import javax.xml.transform.dom.DOMSource;\n import javax.xml.transform.stream.StreamResult;\n \n+import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n import org.w3c.dom.Attr;\n import org.w3c.dom.Document;\n import org.w3c.dom.Element;\n@@ -61,10 +61,8 @@ public static String decodeStringFromMemento(String memento) {\n \tpublic static String encodeMapIntoMemento(Map<String, String> keyPairValues) {\n \t\tString returnValue = null;\n \n-\t\tDocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();\n-\t\tDocumentBuilder docBuilder = null;\n \t\ttry {\n-\t\t\tdocBuilder = dfactory.newDocumentBuilder();\n+\t\t\tDocumentBuilder docBuilder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tDocument doc = docBuilder.newDocument();\n \n \t\t\tElement rootElement = doc.createElement(ROOT_ELEMENT_TAGNAME);\n@@ -80,7 +78,7 @@ public static String encodeMapIntoMemento(Map<String, String> keyPairValues) {\n \n \t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n \n-\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n+\t\t\tTransformerFactory factory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n \t\t\tTransformer transformer = factory.newTransformer();\n \t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n \t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n@@ -103,7 +101,7 @@ public static Map<String, String> decodeMapFromMemento(String memento) {\n \t\tElement root = null;\n \t\tDocumentBuilder parser;\n \t\ttry {\n-\t\t\tparser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n+\t\t\tparser = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tparser.setErrorHandler(new DefaultHandler());\n \t\t\troot = parser.parse(new InputSource(new StringReader(memento))).getDocumentElement();\n \t\t\tNodeList nodeList = root.getChildNodes();\n@@ -142,10 +140,8 @@ public static Map<String, String> decodeMapFromMemento(String memento) {\n \tpublic static String encodeListIntoMemento(List<String> labels) {\n \t\tString returnValue = null;\n \n-\t\tDocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();\n-\t\tDocumentBuilder docBuilder = null;\n \t\ttry {\n-\t\t\tdocBuilder = dfactory.newDocumentBuilder();\n+\t\t\tDocumentBuilder docBuilder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tDocument doc = docBuilder.newDocument();\n \n \t\t\tElement rootElement = doc.createElement(ROOT_ELEMENT_TAGNAME);\n@@ -159,7 +155,7 @@ public static String encodeListIntoMemento(List<String> labels) {\n \n \t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n \n-\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n+\t\t\tTransformerFactory factory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n \t\t\tTransformer transformer = factory.newTransformer();\n \t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n \t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n@@ -182,7 +178,7 @@ public static List<String> decodeListFromMemento(String memento) {\n \t\tElement root = null;\n \t\tDocumentBuilder parser;\n \t\ttry {\n-\t\t\tparser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n+\t\t\tparser = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tparser.setErrorHandler(new DefaultHandler());\n \t\t\troot = parser.parse(new InputSource(new StringReader(memento))).getDocumentElement();\n \t\t\tNodeList nodeList = root.getChildNodes();",
    "function_modified_lines": {
      "added": [
        "\t\t\tDocumentBuilder docBuilder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n",
        "\t\t\tTransformerFactory factory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n"
      ],
      "deleted": [
        "\t\tDocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();\n",
        "\t\tDocumentBuilder docBuilder = null;\n",
        "\t\t\tdocBuilder = dfactory.newDocumentBuilder();\n",
        "\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "In Eclipse IDE versions < 2023-09 (4.29) some files with xml content are parsed vulnerable against all sorts of XXE attacks. The user just needs to open any evil project or update an open project with a vulnerable file (for example for review a foreign repository or patch).\n",
    "id": 12891
  },
  {
    "cve_id": "CVE-2023-4218",
    "code_before_change": "{\n\t\tString collectData = \"\"; //$NON-NLS-1$\n\n\t\tDocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();\n\t\tDocumentBuilder docBuilder = null;\n\t\ttry {\n\t\t\tdocBuilder = dfactory.newDocumentBuilder();\n\t\t\tDocument doc = docBuilder.newDocument();\n\n\t\t\tElement rootElement = doc.createElement(COLLECT_ACTION_ELEMENT_NAME);\n\n\t\t\t// Store the different attributes of this collect action\n\t\t\trootElement.setAttribute(COLLECT_STRING_ATTR, fCollectString);\n\t\t\trootElement.setAttribute(COLLECT_AS_STRING_ATTR, Boolean.toString(fCharPtrAsStrings));\n\t\t\trootElement.setAttribute(COLLECT_AS_STRING_LIMIT_ATTR,\n\t\t\t\t\tfCharPtrAsStringsLimit == null ? \"\" : fCharPtrAsStringsLimit.toString()); //$NON-NLS-1$\n\n\t\t\tdoc.appendChild(rootElement);\n\n\t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n\n\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n\t\t\tTransformer transformer = factory.newTransformer();\n\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\n\t\t\tDOMSource source = new DOMSource(doc);\n\t\t\tStreamResult outputTarget = new StreamResult(s);\n\t\t\ttransformer.transform(source, outputTarget);\n\n\t\t\tcollectData = s.toString(\"UTF8\"); //$NON-NLS-1$\n\n\t\t} catch (Exception e) {\n\t\t\tGdbPlugin.log(e);\n\t\t}\n\t\treturn collectData;\n\t}",
    "code_after_change": "{\n\t\t\tDocumentBuilder docBuilder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n\t\t\tDocument doc = docBuilder.newDocument();\n\n\t\t\tElement rootElement = doc.createElement(COLLECT_ACTION_ELEMENT_NAME);\n\n\t\t\t// Store the different attributes of this collect action\n\t\t\trootElement.setAttribute(COLLECT_STRING_ATTR, fCollectString);\n\t\t\trootElement.setAttribute(COLLECT_AS_STRING_ATTR, Boolean.toString(fCharPtrAsStrings));\n\t\t\trootElement.setAttribute(COLLECT_AS_STRING_LIMIT_ATTR,\n\t\t\t\t\tfCharPtrAsStringsLimit == null ? \"\" : fCharPtrAsStringsLimit.toString()); //$NON-NLS-1$\n\n\t\t\tdoc.appendChild(rootElement);\n\n\t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n\n\t\t\tTransformerFactory factory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n\t\t\tTransformer transformer = factory.newTransformer();\n\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\n\t\t\tDOMSource source = new DOMSource(doc);\n\t\t\tStreamResult outputTarget = new StreamResult(s);\n\t\t\ttransformer.transform(source, outputTarget);\n\n\t\t\tcollectData = s.toString(\"UTF8\"); //$NON-NLS-1$\n\n\t\t}",
    "patch": "@@ -18,14 +18,14 @@\n import java.io.StringReader;\n \n import javax.xml.parsers.DocumentBuilder;\n-import javax.xml.parsers.DocumentBuilderFactory;\n import javax.xml.transform.OutputKeys;\n import javax.xml.transform.Transformer;\n import javax.xml.transform.TransformerFactory;\n import javax.xml.transform.dom.DOMSource;\n import javax.xml.transform.stream.StreamResult;\n \n import org.eclipse.cdt.dsf.gdb.internal.GdbPlugin;\n+import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n import org.w3c.dom.Document;\n import org.w3c.dom.Element;\n import org.xml.sax.InputSource;\n@@ -124,10 +124,8 @@ public String getIdentifier() {\n \tpublic String getMemento() {\n \t\tString collectData = \"\"; //$NON-NLS-1$\n \n-\t\tDocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();\n-\t\tDocumentBuilder docBuilder = null;\n \t\ttry {\n-\t\t\tdocBuilder = dfactory.newDocumentBuilder();\n+\t\t\tDocumentBuilder docBuilder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tDocument doc = docBuilder.newDocument();\n \n \t\t\tElement rootElement = doc.createElement(COLLECT_ACTION_ELEMENT_NAME);\n@@ -142,7 +140,7 @@ public String getMemento() {\n \n \t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n \n-\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n+\t\t\tTransformerFactory factory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n \t\t\tTransformer transformer = factory.newTransformer();\n \t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n \t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n@@ -189,7 +187,7 @@ public void initializeFromMemento(String data) {\n \t\tElement root = null;\n \t\tDocumentBuilder parser;\n \t\ttry {\n-\t\t\tparser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n+\t\t\tparser = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tparser.setErrorHandler(new DefaultHandler());\n \t\t\troot = parser.parse(new InputSource(new StringReader(data))).getDocumentElement();\n ",
    "function_modified_lines": {
      "added": [
        "\t\t\tDocumentBuilder docBuilder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n",
        "\t\t\tTransformerFactory factory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n"
      ],
      "deleted": [
        "\t\tDocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();\n",
        "\t\tDocumentBuilder docBuilder = null;\n",
        "\t\t\tdocBuilder = dfactory.newDocumentBuilder();\n",
        "\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "In Eclipse IDE versions < 2023-09 (4.29) some files with xml content are parsed vulnerable against all sorts of XXE attacks. The user just needs to open any evil project or update an open project with a vulnerable file (for example for review a foreign repository or patch).\n",
    "id": 12893
  },
  {
    "cve_id": "CVE-2023-4218",
    "code_before_change": "/*******************************************************************************\n * Copyright (c) 2010, 2016 Ericsson and others.\n *\n * This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n *\n * Contributors:\n *     Ericsson - initial API and implementation\n *     Marc Khouzam (Ericsson) - Don't use translatable strings for the command summary\n *                               since it will be send directly to GDB\n *******************************************************************************/\npackage org.eclipse.cdt.dsf.gdb.internal.tracepointactions;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.StringReader;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.eclipse.cdt.dsf.gdb.internal.GdbPlugin;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.helpers.DefaultHandler;\n\n/**\n * @since 3.0\n */\npublic class EvaluateAction extends AbstractTracepointAction {\n\tprivate static final String EVALUATE_ACTION_ID = \"org.eclipse.cdt.dsf.gdb.tracepointactions.EvaluateAction\"; //$NON-NLS-1$\n\n\tprivate String fEvalString = \"\"; //$NON-NLS-1$\n\n\t@Override\n\tpublic String getDefaultName() {\n\t\treturn MessagesForTracepointActions.TracepointActions_Untitled_Evaluate;\n\t}\n\n\tpublic String getEvalString() {\n\t\treturn fEvalString;\n\t}\n\n\tpublic void setEvalString(String str) {\n\t\tfEvalString = str;\n\t}\n\n\t@Override\n\tpublic String getIdentifier() {\n\t\treturn EVALUATE_ACTION_ID;\n\t}\n\n\t@Override\n\tpublic String getMemento() {\n\t\tString collectData = \"\"; //$NON-NLS-1$\n\n\t\tDocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();\n\t\tDocumentBuilder docBuilder = null;\n\t\ttry {\n\t\t\tdocBuilder = dfactory.newDocumentBuilder();\n\t\t\tDocument doc = docBuilder.newDocument();\n\n\t\t\tElement rootElement = doc.createElement(\"evalData\"); //$NON-NLS-1$\n\t\t\trootElement.setAttribute(\"evalString\", fEvalString); //$NON-NLS-1$\n\n\t\t\tdoc.appendChild(rootElement);\n\n\t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n\n\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n\t\t\tTransformer transformer = factory.newTransformer();\n\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\n\t\t\tDOMSource source = new DOMSource(doc);\n\t\t\tStreamResult outputTarget = new StreamResult(s);\n\t\t\ttransformer.transform(source, outputTarget);\n\n\t\t\tcollectData = s.toString(\"UTF8\"); //$NON-NLS-1$\n\n\t\t} catch (Exception e) {\n\t\t\tGdbPlugin.log(e);\n\t\t}\n\t\treturn collectData;\n\t}\n\n\t@Override\n\tpublic String getSummary() {\n\t\t// Create command to be sent to GDB\n\t\treturn String.format(\"teval %s\", fEvalString); //$NON-NLS-1$\n\t}\n\n\t@Override\n\tpublic String getTypeName() {\n\t\treturn MessagesForTracepointActions.TracepointActions_Evaluate_Name;\n\t}\n\n\t@Override\n\tpublic void initializeFromMemento(String data) {\n\t\tElement root = null;\n\t\tDocumentBuilder parser;\n\t\ttry {\n\t\t\tparser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n\t\t\tparser.setErrorHandler(new DefaultHandler());\n\t\t\troot = parser.parse(new InputSource(new StringReader(data))).getDocumentElement();\n\t\t\tfEvalString = root.getAttribute(\"evalString\"); //$NON-NLS-1$\n\t\t\tif (fEvalString == null)\n\t\t\t\tthrow new Exception();\n\t\t} catch (Exception e) {\n\t\t\tGdbPlugin.log(e);\n\t\t}\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn getSummary();\n\t}\n}\n",
    "code_after_change": "/*******************************************************************************\n * Copyright (c) 2010, 2016 Ericsson and others.\n *\n * This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n *\n * Contributors:\n *     Ericsson - initial API and implementation\n *     Marc Khouzam (Ericsson) - Don't use translatable strings for the command summary\n *                               since it will be send directly to GDB\n *******************************************************************************/\npackage org.eclipse.cdt.dsf.gdb.internal.tracepointactions;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.StringReader;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.eclipse.cdt.dsf.gdb.internal.GdbPlugin;\nimport org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.helpers.DefaultHandler;\n\n/**\n * @since 3.0\n */\npublic class EvaluateAction extends AbstractTracepointAction {\n\tprivate static final String EVALUATE_ACTION_ID = \"org.eclipse.cdt.dsf.gdb.tracepointactions.EvaluateAction\"; //$NON-NLS-1$\n\n\tprivate String fEvalString = \"\"; //$NON-NLS-1$\n\n\t@Override\n\tpublic String getDefaultName() {\n\t\treturn MessagesForTracepointActions.TracepointActions_Untitled_Evaluate;\n\t}\n\n\tpublic String getEvalString() {\n\t\treturn fEvalString;\n\t}\n\n\tpublic void setEvalString(String str) {\n\t\tfEvalString = str;\n\t}\n\n\t@Override\n\tpublic String getIdentifier() {\n\t\treturn EVALUATE_ACTION_ID;\n\t}\n\n\t@Override\n\tpublic String getMemento() {\n\t\tString collectData = \"\"; //$NON-NLS-1$\n\n\t\ttry {\n\t\t\tDocumentBuilder docBuilder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n\t\t\tDocument doc = docBuilder.newDocument();\n\n\t\t\tElement rootElement = doc.createElement(\"evalData\"); //$NON-NLS-1$\n\t\t\trootElement.setAttribute(\"evalString\", fEvalString); //$NON-NLS-1$\n\n\t\t\tdoc.appendChild(rootElement);\n\n\t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n\n\t\t\tTransformerFactory factory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n\t\t\tTransformer transformer = factory.newTransformer();\n\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\n\t\t\tDOMSource source = new DOMSource(doc);\n\t\t\tStreamResult outputTarget = new StreamResult(s);\n\t\t\ttransformer.transform(source, outputTarget);\n\n\t\t\tcollectData = s.toString(\"UTF8\"); //$NON-NLS-1$\n\n\t\t} catch (Exception e) {\n\t\t\tGdbPlugin.log(e);\n\t\t}\n\t\treturn collectData;\n\t}\n\n\t@Override\n\tpublic String getSummary() {\n\t\t// Create command to be sent to GDB\n\t\treturn String.format(\"teval %s\", fEvalString); //$NON-NLS-1$\n\t}\n\n\t@Override\n\tpublic String getTypeName() {\n\t\treturn MessagesForTracepointActions.TracepointActions_Evaluate_Name;\n\t}\n\n\t@Override\n\tpublic void initializeFromMemento(String data) {\n\t\tElement root = null;\n\t\tDocumentBuilder parser;\n\t\ttry {\n\t\t\tparser = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n\t\t\tparser.setErrorHandler(new DefaultHandler());\n\t\t\troot = parser.parse(new InputSource(new StringReader(data))).getDocumentElement();\n\t\t\tfEvalString = root.getAttribute(\"evalString\"); //$NON-NLS-1$\n\t\t\tif (fEvalString == null)\n\t\t\t\tthrow new Exception();\n\t\t} catch (Exception e) {\n\t\t\tGdbPlugin.log(e);\n\t\t}\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn getSummary();\n\t}\n}\n",
    "patch": "@@ -19,14 +19,14 @@\n import java.io.StringReader;\n \n import javax.xml.parsers.DocumentBuilder;\n-import javax.xml.parsers.DocumentBuilderFactory;\n import javax.xml.transform.OutputKeys;\n import javax.xml.transform.Transformer;\n import javax.xml.transform.TransformerFactory;\n import javax.xml.transform.dom.DOMSource;\n import javax.xml.transform.stream.StreamResult;\n \n import org.eclipse.cdt.dsf.gdb.internal.GdbPlugin;\n+import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n import org.w3c.dom.Document;\n import org.w3c.dom.Element;\n import org.xml.sax.InputSource;\n@@ -62,10 +62,8 @@ public String getIdentifier() {\n \tpublic String getMemento() {\n \t\tString collectData = \"\"; //$NON-NLS-1$\n \n-\t\tDocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();\n-\t\tDocumentBuilder docBuilder = null;\n \t\ttry {\n-\t\t\tdocBuilder = dfactory.newDocumentBuilder();\n+\t\t\tDocumentBuilder docBuilder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tDocument doc = docBuilder.newDocument();\n \n \t\t\tElement rootElement = doc.createElement(\"evalData\"); //$NON-NLS-1$\n@@ -75,7 +73,7 @@ public String getMemento() {\n \n \t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n \n-\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n+\t\t\tTransformerFactory factory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n \t\t\tTransformer transformer = factory.newTransformer();\n \t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n \t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n@@ -108,7 +106,7 @@ public void initializeFromMemento(String data) {\n \t\tElement root = null;\n \t\tDocumentBuilder parser;\n \t\ttry {\n-\t\t\tparser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n+\t\t\tparser = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tparser.setErrorHandler(new DefaultHandler());\n \t\t\troot = parser.parse(new InputSource(new StringReader(data))).getDocumentElement();\n \t\t\tfEvalString = root.getAttribute(\"evalString\"); //$NON-NLS-1$",
    "function_modified_lines": {
      "added": [
        "import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n"
      ],
      "deleted": [
        "import javax.xml.parsers.DocumentBuilderFactory;\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "In Eclipse IDE versions < 2023-09 (4.29) some files with xml content are parsed vulnerable against all sorts of XXE attacks. The user just needs to open any evil project or update an open project with a vulnerable file (for example for review a foreign repository or patch).\n",
    "id": 12894
  },
  {
    "cve_id": "CVE-2023-4218",
    "code_before_change": "{\n\t\tString collectData = \"\"; //$NON-NLS-1$\n\n\t\tDocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();\n\t\tDocumentBuilder docBuilder = null;\n\t\ttry {\n\t\t\tdocBuilder = dfactory.newDocumentBuilder();\n\t\t\tDocument doc = docBuilder.newDocument();\n\n\t\t\tElement rootElement = doc.createElement(\"evalData\"); //$NON-NLS-1$\n\t\t\trootElement.setAttribute(\"evalString\", fEvalString); //$NON-NLS-1$\n\n\t\t\tdoc.appendChild(rootElement);\n\n\t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n\n\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n\t\t\tTransformer transformer = factory.newTransformer();\n\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\n\t\t\tDOMSource source = new DOMSource(doc);\n\t\t\tStreamResult outputTarget = new StreamResult(s);\n\t\t\ttransformer.transform(source, outputTarget);\n\n\t\t\tcollectData = s.toString(\"UTF8\"); //$NON-NLS-1$\n\n\t\t} catch (Exception e) {\n\t\t\tGdbPlugin.log(e);\n\t\t}\n\t\treturn collectData;\n\t}",
    "code_after_change": "{\n\t\t\tDocumentBuilder docBuilder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n\t\t\tDocument doc = docBuilder.newDocument();\n\n\t\t\tElement rootElement = doc.createElement(\"evalData\"); //$NON-NLS-1$\n\t\t\trootElement.setAttribute(\"evalString\", fEvalString); //$NON-NLS-1$\n\n\t\t\tdoc.appendChild(rootElement);\n\n\t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n\n\t\t\tTransformerFactory factory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n\t\t\tTransformer transformer = factory.newTransformer();\n\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\n\t\t\tDOMSource source = new DOMSource(doc);\n\t\t\tStreamResult outputTarget = new StreamResult(s);\n\t\t\ttransformer.transform(source, outputTarget);\n\n\t\t\tcollectData = s.toString(\"UTF8\"); //$NON-NLS-1$\n\n\t\t}",
    "patch": "@@ -19,14 +19,14 @@\n import java.io.StringReader;\n \n import javax.xml.parsers.DocumentBuilder;\n-import javax.xml.parsers.DocumentBuilderFactory;\n import javax.xml.transform.OutputKeys;\n import javax.xml.transform.Transformer;\n import javax.xml.transform.TransformerFactory;\n import javax.xml.transform.dom.DOMSource;\n import javax.xml.transform.stream.StreamResult;\n \n import org.eclipse.cdt.dsf.gdb.internal.GdbPlugin;\n+import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n import org.w3c.dom.Document;\n import org.w3c.dom.Element;\n import org.xml.sax.InputSource;\n@@ -62,10 +62,8 @@ public String getIdentifier() {\n \tpublic String getMemento() {\n \t\tString collectData = \"\"; //$NON-NLS-1$\n \n-\t\tDocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();\n-\t\tDocumentBuilder docBuilder = null;\n \t\ttry {\n-\t\t\tdocBuilder = dfactory.newDocumentBuilder();\n+\t\t\tDocumentBuilder docBuilder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tDocument doc = docBuilder.newDocument();\n \n \t\t\tElement rootElement = doc.createElement(\"evalData\"); //$NON-NLS-1$\n@@ -75,7 +73,7 @@ public String getMemento() {\n \n \t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n \n-\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n+\t\t\tTransformerFactory factory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n \t\t\tTransformer transformer = factory.newTransformer();\n \t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n \t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n@@ -108,7 +106,7 @@ public void initializeFromMemento(String data) {\n \t\tElement root = null;\n \t\tDocumentBuilder parser;\n \t\ttry {\n-\t\t\tparser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n+\t\t\tparser = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tparser.setErrorHandler(new DefaultHandler());\n \t\t\troot = parser.parse(new InputSource(new StringReader(data))).getDocumentElement();\n \t\t\tfEvalString = root.getAttribute(\"evalString\"); //$NON-NLS-1$",
    "function_modified_lines": {
      "added": [
        "\t\t\tDocumentBuilder docBuilder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n",
        "\t\t\tTransformerFactory factory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n"
      ],
      "deleted": [
        "\t\tDocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();\n",
        "\t\tDocumentBuilder docBuilder = null;\n",
        "\t\t\tdocBuilder = dfactory.newDocumentBuilder();\n",
        "\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "In Eclipse IDE versions < 2023-09 (4.29) some files with xml content are parsed vulnerable against all sorts of XXE attacks. The user just needs to open any evil project or update an open project with a vulnerable file (for example for review a foreign repository or patch).\n",
    "id": 12895
  },
  {
    "cve_id": "CVE-2023-4218",
    "code_before_change": "/*******************************************************************************\n * Copyright (c) 2010, 2016 Ericsson and others.\n *\n * This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n *\n * Contributors:\n *     Ericsson - initial API and implementation\n *******************************************************************************/\npackage org.eclipse.cdt.dsf.gdb.internal.tracepointactions;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.StringReader;\nimport java.util.ArrayList;\nimport java.util.Iterator;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.eclipse.cdt.dsf.gdb.internal.GdbPlugin;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.helpers.DefaultHandler;\n\n/**\n * @since 3.0\n */\npublic class TracepointActionManager {\n\n\tprivate static final String TRACEPOINT_ACTION_DATA = \"TracepointActionManager.actionData\"; //$NON-NLS-1$\n\tprivate static final TracepointActionManager fTracepointActionManager = new TracepointActionManager();\n\n\t// We need a delimiter that the user won't type directly.\n\t// Bug 346215\n\tpublic static final String TRACEPOINT_ACTION_DELIMITER = \"%_#\"; //$NON-NLS-1$\n\n\tprivate ArrayList<ITracepointAction> tracepointActions = null;\n\n\tprivate TracepointActionManager() {\n\t}\n\n\tpublic static TracepointActionManager getInstance() {\n\t\treturn fTracepointActionManager;\n\t}\n\n\tpublic void addAction(ITracepointAction action) {\n\t\tgetActions().add(action);\n\t}\n\n\tpublic void deleteAction(ITracepointAction action) {\n\t\tgetActions().remove(action);\n\t}\n\n\tpublic ITracepointAction findAction(String name) {\n\t\tfor (ITracepointAction action : getActions()) {\n\t\t\tif (action.getName().equals(name)) {\n\t\t\t\treturn action;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic ArrayList<ITracepointAction> getActions() {\n\t\tif (tracepointActions == null) {\n\t\t\ttracepointActions = new ArrayList<>();\n\t\t\tloadActionData();\n\t\t}\n\t\treturn tracepointActions;\n\t}\n\n\tprivate void loadActionData() {\n\n\t\tString actionData = GdbPlugin.getDefault().getPluginPreferences().getString(TRACEPOINT_ACTION_DATA);\n\n\t\tif (actionData == null || actionData.length() == 0)\n\t\t\treturn;\n\n\t\tElement root = null;\n\t\tDocumentBuilder parser;\n\t\ttry {\n\t\t\tparser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n\t\t\tparser.setErrorHandler(new DefaultHandler());\n\t\t\troot = parser.parse(new InputSource(new StringReader(actionData))).getDocumentElement();\n\n\t\t\tNodeList nodeList = root.getChildNodes();\n\t\t\tint entryCount = nodeList.getLength();\n\n\t\t\tfor (int i = 0; i < entryCount; i++) {\n\t\t\t\tNode node = nodeList.item(i);\n\t\t\t\tshort type = node.getNodeType();\n\t\t\t\tif (type == Node.ELEMENT_NODE) {\n\t\t\t\t\tElement subElement = (Element) node;\n\t\t\t\t\tString nodeName = subElement.getNodeName();\n\t\t\t\t\tif (nodeName.equalsIgnoreCase(\"actionEntry\")) { //$NON-NLS-1$\n\t\t\t\t\t\tString name = subElement.getAttribute(\"name\"); //$NON-NLS-1$\n\t\t\t\t\t\tif (name == null)\n\t\t\t\t\t\t\tthrow new Exception();\n\t\t\t\t\t\tString value = subElement.getAttribute(\"value\"); //$NON-NLS-1$\n\t\t\t\t\t\tif (value == null)\n\t\t\t\t\t\t\tthrow new Exception();\n\t\t\t\t\t\tString className = subElement.getAttribute(\"class\"); //$NON-NLS-1$\n\t\t\t\t\t\tif (className == null)\n\t\t\t\t\t\t\tthrow new Exception();\n\n\t\t\t\t\t\tITracepointAction action = (ITracepointAction) Class.forName(className).newInstance();\n\t\t\t\t\t\taction.setName(name);\n\t\t\t\t\t\taction.initializeFromMemento(value);\n\t\t\t\t\t\taddAction(action);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tpublic String makeUniqueActionName(String defaultName) {\n\t\tString result = defaultName;\n\t\tITracepointAction action = findAction(defaultName);\n\t\tint actionCount = 1;\n\t\twhile (action != null) {\n\t\t\tresult = defaultName + \"(\" + actionCount + \")\"; //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\taction = findAction(result);\n\t\t\tactionCount++;\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic void revertActionData() {\n\t\ttracepointActions = null;\n\t}\n\n\tpublic void saveActionData() {\n\t\tString actionData = \"\"; //$NON-NLS-1$\n\n\t\tDocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();\n\t\tDocumentBuilder docBuilder = null;\n\t\ttry {\n\t\t\tdocBuilder = dfactory.newDocumentBuilder();\n\t\t\tDocument doc = docBuilder.newDocument();\n\n\t\t\tElement rootElement = doc.createElement(\"tracepointActionData\"); //$NON-NLS-1$\n\t\t\tdoc.appendChild(rootElement);\n\n\t\t\tfor (Iterator<ITracepointAction> iter = getActions().iterator(); iter.hasNext();) {\n\t\t\t\tITracepointAction action = iter.next();\n\n\t\t\t\tElement element = doc.createElement(\"actionEntry\"); //$NON-NLS-1$\n\t\t\t\telement.setAttribute(\"name\", action.getName()); //$NON-NLS-1$\n\t\t\t\telement.setAttribute(\"class\", action.getClass().getName()); //$NON-NLS-1$\n\t\t\t\telement.setAttribute(\"value\", action.getMemento()); //$NON-NLS-1$\n\t\t\t\trootElement.appendChild(element);\n\n\t\t\t}\n\n\t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n\n\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n\t\t\tTransformer transformer = factory.newTransformer();\n\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\n\t\t\tDOMSource source = new DOMSource(doc);\n\t\t\tStreamResult outputTarget = new StreamResult(s);\n\t\t\ttransformer.transform(source, outputTarget);\n\n\t\t\tactionData = s.toString(\"UTF8\"); //$NON-NLS-1$\n\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tGdbPlugin.getDefault().getPluginPreferences().setValue(TRACEPOINT_ACTION_DATA, actionData);\n\t\tGdbPlugin.getDefault().savePluginPreferences();\n\t}\n\n}\n",
    "code_after_change": "/*******************************************************************************\n * Copyright (c) 2010, 2016 Ericsson and others.\n *\n * This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n *\n * Contributors:\n *     Ericsson - initial API and implementation\n *******************************************************************************/\npackage org.eclipse.cdt.dsf.gdb.internal.tracepointactions;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.StringReader;\nimport java.util.ArrayList;\nimport java.util.Iterator;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.eclipse.cdt.dsf.gdb.internal.GdbPlugin;\nimport org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.helpers.DefaultHandler;\n\n/**\n * @since 3.0\n */\npublic class TracepointActionManager {\n\n\tprivate static final String TRACEPOINT_ACTION_DATA = \"TracepointActionManager.actionData\"; //$NON-NLS-1$\n\tprivate static final TracepointActionManager fTracepointActionManager = new TracepointActionManager();\n\n\t// We need a delimiter that the user won't type directly.\n\t// Bug 346215\n\tpublic static final String TRACEPOINT_ACTION_DELIMITER = \"%_#\"; //$NON-NLS-1$\n\n\tprivate ArrayList<ITracepointAction> tracepointActions = null;\n\n\tprivate TracepointActionManager() {\n\t}\n\n\tpublic static TracepointActionManager getInstance() {\n\t\treturn fTracepointActionManager;\n\t}\n\n\tpublic void addAction(ITracepointAction action) {\n\t\tgetActions().add(action);\n\t}\n\n\tpublic void deleteAction(ITracepointAction action) {\n\t\tgetActions().remove(action);\n\t}\n\n\tpublic ITracepointAction findAction(String name) {\n\t\tfor (ITracepointAction action : getActions()) {\n\t\t\tif (action.getName().equals(name)) {\n\t\t\t\treturn action;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic ArrayList<ITracepointAction> getActions() {\n\t\tif (tracepointActions == null) {\n\t\t\ttracepointActions = new ArrayList<>();\n\t\t\tloadActionData();\n\t\t}\n\t\treturn tracepointActions;\n\t}\n\n\tprivate void loadActionData() {\n\n\t\tString actionData = GdbPlugin.getDefault().getPluginPreferences().getString(TRACEPOINT_ACTION_DATA);\n\n\t\tif (actionData == null || actionData.length() == 0)\n\t\t\treturn;\n\n\t\tElement root = null;\n\t\tDocumentBuilder parser;\n\t\ttry {\n\t\t\tparser = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n\t\t\tparser.setErrorHandler(new DefaultHandler());\n\t\t\troot = parser.parse(new InputSource(new StringReader(actionData))).getDocumentElement();\n\n\t\t\tNodeList nodeList = root.getChildNodes();\n\t\t\tint entryCount = nodeList.getLength();\n\n\t\t\tfor (int i = 0; i < entryCount; i++) {\n\t\t\t\tNode node = nodeList.item(i);\n\t\t\t\tshort type = node.getNodeType();\n\t\t\t\tif (type == Node.ELEMENT_NODE) {\n\t\t\t\t\tElement subElement = (Element) node;\n\t\t\t\t\tString nodeName = subElement.getNodeName();\n\t\t\t\t\tif (nodeName.equalsIgnoreCase(\"actionEntry\")) { //$NON-NLS-1$\n\t\t\t\t\t\tString name = subElement.getAttribute(\"name\"); //$NON-NLS-1$\n\t\t\t\t\t\tif (name == null)\n\t\t\t\t\t\t\tthrow new Exception();\n\t\t\t\t\t\tString value = subElement.getAttribute(\"value\"); //$NON-NLS-1$\n\t\t\t\t\t\tif (value == null)\n\t\t\t\t\t\t\tthrow new Exception();\n\t\t\t\t\t\tString className = subElement.getAttribute(\"class\"); //$NON-NLS-1$\n\t\t\t\t\t\tif (className == null)\n\t\t\t\t\t\t\tthrow new Exception();\n\n\t\t\t\t\t\tITracepointAction action = (ITracepointAction) Class.forName(className).newInstance();\n\t\t\t\t\t\taction.setName(name);\n\t\t\t\t\t\taction.initializeFromMemento(value);\n\t\t\t\t\t\taddAction(action);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tpublic String makeUniqueActionName(String defaultName) {\n\t\tString result = defaultName;\n\t\tITracepointAction action = findAction(defaultName);\n\t\tint actionCount = 1;\n\t\twhile (action != null) {\n\t\t\tresult = defaultName + \"(\" + actionCount + \")\"; //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\taction = findAction(result);\n\t\t\tactionCount++;\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic void revertActionData() {\n\t\ttracepointActions = null;\n\t}\n\n\tpublic void saveActionData() {\n\t\tString actionData = \"\"; //$NON-NLS-1$\n\n\t\ttry {\n\t\t\tDocumentBuilder docBuilder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n\t\t\tDocument doc = docBuilder.newDocument();\n\n\t\t\tElement rootElement = doc.createElement(\"tracepointActionData\"); //$NON-NLS-1$\n\t\t\tdoc.appendChild(rootElement);\n\n\t\t\tfor (Iterator<ITracepointAction> iter = getActions().iterator(); iter.hasNext();) {\n\t\t\t\tITracepointAction action = iter.next();\n\n\t\t\t\tElement element = doc.createElement(\"actionEntry\"); //$NON-NLS-1$\n\t\t\t\telement.setAttribute(\"name\", action.getName()); //$NON-NLS-1$\n\t\t\t\telement.setAttribute(\"class\", action.getClass().getName()); //$NON-NLS-1$\n\t\t\t\telement.setAttribute(\"value\", action.getMemento()); //$NON-NLS-1$\n\t\t\t\trootElement.appendChild(element);\n\n\t\t\t}\n\n\t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n\n\t\t\tTransformerFactory factory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n\t\t\tTransformer transformer = factory.newTransformer();\n\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\n\t\t\tDOMSource source = new DOMSource(doc);\n\t\t\tStreamResult outputTarget = new StreamResult(s);\n\t\t\ttransformer.transform(source, outputTarget);\n\n\t\t\tactionData = s.toString(\"UTF8\"); //$NON-NLS-1$\n\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tGdbPlugin.getDefault().getPluginPreferences().setValue(TRACEPOINT_ACTION_DATA, actionData);\n\t\tGdbPlugin.getDefault().savePluginPreferences();\n\t}\n\n}\n",
    "patch": "@@ -19,14 +19,14 @@\n import java.util.Iterator;\n \n import javax.xml.parsers.DocumentBuilder;\n-import javax.xml.parsers.DocumentBuilderFactory;\n import javax.xml.transform.OutputKeys;\n import javax.xml.transform.Transformer;\n import javax.xml.transform.TransformerFactory;\n import javax.xml.transform.dom.DOMSource;\n import javax.xml.transform.stream.StreamResult;\n \n import org.eclipse.cdt.dsf.gdb.internal.GdbPlugin;\n+import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n import org.w3c.dom.Document;\n import org.w3c.dom.Element;\n import org.w3c.dom.Node;\n@@ -90,7 +90,7 @@ private void loadActionData() {\n \t\tElement root = null;\n \t\tDocumentBuilder parser;\n \t\ttry {\n-\t\t\tparser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n+\t\t\tparser = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tparser.setErrorHandler(new DefaultHandler());\n \t\t\troot = parser.parse(new InputSource(new StringReader(actionData))).getDocumentElement();\n \n@@ -146,10 +146,8 @@ public void revertActionData() {\n \tpublic void saveActionData() {\n \t\tString actionData = \"\"; //$NON-NLS-1$\n \n-\t\tDocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();\n-\t\tDocumentBuilder docBuilder = null;\n \t\ttry {\n-\t\t\tdocBuilder = dfactory.newDocumentBuilder();\n+\t\t\tDocumentBuilder docBuilder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tDocument doc = docBuilder.newDocument();\n \n \t\t\tElement rootElement = doc.createElement(\"tracepointActionData\"); //$NON-NLS-1$\n@@ -168,7 +166,7 @@ public void saveActionData() {\n \n \t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n \n-\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n+\t\t\tTransformerFactory factory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n \t\t\tTransformer transformer = factory.newTransformer();\n \t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n \t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$",
    "function_modified_lines": {
      "added": [
        "import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n"
      ],
      "deleted": [
        "import javax.xml.parsers.DocumentBuilderFactory;\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "In Eclipse IDE versions < 2023-09 (4.29) some files with xml content are parsed vulnerable against all sorts of XXE attacks. The user just needs to open any evil project or update an open project with a vulnerable file (for example for review a foreign repository or patch).\n",
    "id": 12896
  },
  {
    "cve_id": "CVE-2023-4218",
    "code_before_change": "/*******************************************************************************\n * Copyright (c) 2010, 2016 Ericsson and others.\n *\n * This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n *\n * Contributors:\n *     Ericsson - initial API and implementation\n *     Marc Khouzam (Ericsson) - Don't use translatable strings for the command summary\n *                               since it will be send directly to GDB\n *******************************************************************************/\npackage org.eclipse.cdt.dsf.gdb.internal.tracepointactions;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.StringReader;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.eclipse.cdt.dsf.gdb.internal.GdbPlugin;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.helpers.DefaultHandler;\n\n/**\n * @since 3.0\n */\npublic class WhileSteppingAction extends AbstractTracepointAction {\n\tprivate static final String WHILE_STEPPING_ACTION_ID = \"org.eclipse.cdt.dsf.gdb.tracepointactions.WhileSteppingAction\"; //$NON-NLS-1$\n\n\t// The name of the sub actions\n\tprivate String fSubActionNames = \"\"; //$NON-NLS-1$\n\t// A comma-separated string of the actual content of each sub command\n\t// This is the string than can be sent to GDB\n\tprivate String fSubActionContent = \"\"; //$NON-NLS-1$\n\t// The number of steps this while-stepping command will occur\n\tprivate int fStepCount = 1;\n\n\t@Override\n\tpublic String getDefaultName() {\n\t\treturn MessagesForTracepointActions.TracepointActions_Untitled_WhileStepping;\n\t}\n\n\tpublic String getSubActionsNames() {\n\t\treturn fSubActionNames;\n\t}\n\n\tpublic void setSubActionsNames(String str) {\n\t\tfSubActionNames = str;\n\t}\n\n\tpublic String getSubActionsContent() {\n\t\treturn fSubActionContent;\n\t}\n\n\t// Take all the sub action names, and find their corresponding action,\n\t// then build the content string\n\tpublic void setSubActionsContent(String subActionNames) {\n\t\tString[] names = subActionNames.split(\",\"); //$NON-NLS-1$\n\t\tfSubActionContent = \"\"; //$NON-NLS-1$\n\n\t\tfor (String name : names) {\n\t\t\tITracepointAction action = TracepointActionManager.getInstance().findAction(name.trim());\n\t\t\tif (action != null) {\n\t\t\t\tfSubActionContent += action.getSummary() + \",\"; //$NON-NLS-1$\n\t\t\t}\n\t\t}\n\t\t// Remove last comma\n\t\tif (fSubActionContent.length() > 0) {\n\t\t\tfSubActionContent = fSubActionContent.substring(0, fSubActionContent.length() - 1);\n\t\t}\n\t}\n\n\tpublic int getStepCount() {\n\t\treturn fStepCount;\n\t}\n\n\tpublic void setStepCount(int count) {\n\t\tfStepCount = count;\n\t}\n\n\t@Override\n\tpublic String getIdentifier() {\n\t\treturn WHILE_STEPPING_ACTION_ID;\n\t}\n\n\t@Override\n\tpublic String getMemento() {\n\t\tString collectData = \"\"; //$NON-NLS-1$\n\n\t\tDocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();\n\t\tDocumentBuilder docBuilder = null;\n\t\ttry {\n\t\t\tdocBuilder = dfactory.newDocumentBuilder();\n\t\t\tDocument doc = docBuilder.newDocument();\n\n\t\t\tElement rootElement = doc.createElement(\"whileSteppingData\"); //$NON-NLS-1$\n\t\t\trootElement.setAttribute(\"whileSteppingCount\", Integer.toString(fStepCount)); //$NON-NLS-1$\n\t\t\trootElement.setAttribute(\"subActionNames\", fSubActionNames); //$NON-NLS-1$\n\n\t\t\tdoc.appendChild(rootElement);\n\n\t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n\n\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n\t\t\tTransformer transformer = factory.newTransformer();\n\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\n\t\t\tDOMSource source = new DOMSource(doc);\n\t\t\tStreamResult outputTarget = new StreamResult(s);\n\t\t\ttransformer.transform(source, outputTarget);\n\n\t\t\tcollectData = s.toString(\"UTF8\"); //$NON-NLS-1$\n\n\t\t} catch (Exception e) {\n\t\t\tGdbPlugin.log(e);\n\t\t}\n\t\treturn collectData;\n\t}\n\n\t@Override\n\tpublic String getSummary() {\n\t\t// Create command to be sent to GDB\n\t\treturn String.format(\"while-stepping %s %s\", fStepCount, fSubActionContent); //$NON-NLS-1$\n\t}\n\n\t@Override\n\tpublic String getTypeName() {\n\t\treturn MessagesForTracepointActions.TracepointActions_WhileStepping_Name;\n\t}\n\n\t@Override\n\tpublic void initializeFromMemento(String data) {\n\t\tElement root = null;\n\t\tDocumentBuilder parser;\n\t\ttry {\n\t\t\tparser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n\t\t\tparser.setErrorHandler(new DefaultHandler());\n\t\t\troot = parser.parse(new InputSource(new StringReader(data))).getDocumentElement();\n\t\t\tsetStepCount(Integer.parseInt(root.getAttribute(\"whileSteppingCount\"))); //$NON-NLS-1$\n\t\t\tsetSubActionsNames(root.getAttribute(\"subActionNames\")); //$NON-NLS-1$\n\t\t\tif (fSubActionNames == null)\n\t\t\t\tthrow new Exception();\n\t\t\tsetSubActionsContent(fSubActionNames);\n\t\t} catch (Exception e) {\n\t\t\tGdbPlugin.log(e);\n\t\t}\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn getSummary();\n\t}\n}\n",
    "code_after_change": "/*******************************************************************************\n * Copyright (c) 2010, 2016 Ericsson and others.\n *\n * This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n *\n * Contributors:\n *     Ericsson - initial API and implementation\n *     Marc Khouzam (Ericsson) - Don't use translatable strings for the command summary\n *                               since it will be send directly to GDB\n *******************************************************************************/\npackage org.eclipse.cdt.dsf.gdb.internal.tracepointactions;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.StringReader;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.eclipse.cdt.dsf.gdb.internal.GdbPlugin;\nimport org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.helpers.DefaultHandler;\n\n/**\n * @since 3.0\n */\npublic class WhileSteppingAction extends AbstractTracepointAction {\n\tprivate static final String WHILE_STEPPING_ACTION_ID = \"org.eclipse.cdt.dsf.gdb.tracepointactions.WhileSteppingAction\"; //$NON-NLS-1$\n\n\t// The name of the sub actions\n\tprivate String fSubActionNames = \"\"; //$NON-NLS-1$\n\t// A comma-separated string of the actual content of each sub command\n\t// This is the string than can be sent to GDB\n\tprivate String fSubActionContent = \"\"; //$NON-NLS-1$\n\t// The number of steps this while-stepping command will occur\n\tprivate int fStepCount = 1;\n\n\t@Override\n\tpublic String getDefaultName() {\n\t\treturn MessagesForTracepointActions.TracepointActions_Untitled_WhileStepping;\n\t}\n\n\tpublic String getSubActionsNames() {\n\t\treturn fSubActionNames;\n\t}\n\n\tpublic void setSubActionsNames(String str) {\n\t\tfSubActionNames = str;\n\t}\n\n\tpublic String getSubActionsContent() {\n\t\treturn fSubActionContent;\n\t}\n\n\t// Take all the sub action names, and find their corresponding action,\n\t// then build the content string\n\tpublic void setSubActionsContent(String subActionNames) {\n\t\tString[] names = subActionNames.split(\",\"); //$NON-NLS-1$\n\t\tfSubActionContent = \"\"; //$NON-NLS-1$\n\n\t\tfor (String name : names) {\n\t\t\tITracepointAction action = TracepointActionManager.getInstance().findAction(name.trim());\n\t\t\tif (action != null) {\n\t\t\t\tfSubActionContent += action.getSummary() + \",\"; //$NON-NLS-1$\n\t\t\t}\n\t\t}\n\t\t// Remove last comma\n\t\tif (fSubActionContent.length() > 0) {\n\t\t\tfSubActionContent = fSubActionContent.substring(0, fSubActionContent.length() - 1);\n\t\t}\n\t}\n\n\tpublic int getStepCount() {\n\t\treturn fStepCount;\n\t}\n\n\tpublic void setStepCount(int count) {\n\t\tfStepCount = count;\n\t}\n\n\t@Override\n\tpublic String getIdentifier() {\n\t\treturn WHILE_STEPPING_ACTION_ID;\n\t}\n\n\t@Override\n\tpublic String getMemento() {\n\t\tString collectData = \"\"; //$NON-NLS-1$\n\n\t\ttry {\n\t\t\tDocumentBuilder docBuilder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n\t\t\tDocument doc = docBuilder.newDocument();\n\n\t\t\tElement rootElement = doc.createElement(\"whileSteppingData\"); //$NON-NLS-1$\n\t\t\trootElement.setAttribute(\"whileSteppingCount\", Integer.toString(fStepCount)); //$NON-NLS-1$\n\t\t\trootElement.setAttribute(\"subActionNames\", fSubActionNames); //$NON-NLS-1$\n\n\t\t\tdoc.appendChild(rootElement);\n\n\t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n\n\t\t\tTransformerFactory factory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n\t\t\tTransformer transformer = factory.newTransformer();\n\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\n\t\t\tDOMSource source = new DOMSource(doc);\n\t\t\tStreamResult outputTarget = new StreamResult(s);\n\t\t\ttransformer.transform(source, outputTarget);\n\n\t\t\tcollectData = s.toString(\"UTF8\"); //$NON-NLS-1$\n\n\t\t} catch (Exception e) {\n\t\t\tGdbPlugin.log(e);\n\t\t}\n\t\treturn collectData;\n\t}\n\n\t@Override\n\tpublic String getSummary() {\n\t\t// Create command to be sent to GDB\n\t\treturn String.format(\"while-stepping %s %s\", fStepCount, fSubActionContent); //$NON-NLS-1$\n\t}\n\n\t@Override\n\tpublic String getTypeName() {\n\t\treturn MessagesForTracepointActions.TracepointActions_WhileStepping_Name;\n\t}\n\n\t@Override\n\tpublic void initializeFromMemento(String data) {\n\t\tElement root = null;\n\t\tDocumentBuilder parser;\n\t\ttry {\n\t\t\tparser = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n\t\t\tparser.setErrorHandler(new DefaultHandler());\n\t\t\troot = parser.parse(new InputSource(new StringReader(data))).getDocumentElement();\n\t\t\tsetStepCount(Integer.parseInt(root.getAttribute(\"whileSteppingCount\"))); //$NON-NLS-1$\n\t\t\tsetSubActionsNames(root.getAttribute(\"subActionNames\")); //$NON-NLS-1$\n\t\t\tif (fSubActionNames == null)\n\t\t\t\tthrow new Exception();\n\t\t\tsetSubActionsContent(fSubActionNames);\n\t\t} catch (Exception e) {\n\t\t\tGdbPlugin.log(e);\n\t\t}\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn getSummary();\n\t}\n}\n",
    "patch": "@@ -19,14 +19,14 @@\n import java.io.StringReader;\n \n import javax.xml.parsers.DocumentBuilder;\n-import javax.xml.parsers.DocumentBuilderFactory;\n import javax.xml.transform.OutputKeys;\n import javax.xml.transform.Transformer;\n import javax.xml.transform.TransformerFactory;\n import javax.xml.transform.dom.DOMSource;\n import javax.xml.transform.stream.StreamResult;\n \n import org.eclipse.cdt.dsf.gdb.internal.GdbPlugin;\n+import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n import org.w3c.dom.Document;\n import org.w3c.dom.Element;\n import org.xml.sax.InputSource;\n@@ -98,10 +98,8 @@ public String getIdentifier() {\n \tpublic String getMemento() {\n \t\tString collectData = \"\"; //$NON-NLS-1$\n \n-\t\tDocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();\n-\t\tDocumentBuilder docBuilder = null;\n \t\ttry {\n-\t\t\tdocBuilder = dfactory.newDocumentBuilder();\n+\t\t\tDocumentBuilder docBuilder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tDocument doc = docBuilder.newDocument();\n \n \t\t\tElement rootElement = doc.createElement(\"whileSteppingData\"); //$NON-NLS-1$\n@@ -112,7 +110,7 @@ public String getMemento() {\n \n \t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n \n-\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n+\t\t\tTransformerFactory factory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n \t\t\tTransformer transformer = factory.newTransformer();\n \t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n \t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n@@ -145,7 +143,7 @@ public void initializeFromMemento(String data) {\n \t\tElement root = null;\n \t\tDocumentBuilder parser;\n \t\ttry {\n-\t\t\tparser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n+\t\t\tparser = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tparser.setErrorHandler(new DefaultHandler());\n \t\t\troot = parser.parse(new InputSource(new StringReader(data))).getDocumentElement();\n \t\t\tsetStepCount(Integer.parseInt(root.getAttribute(\"whileSteppingCount\"))); //$NON-NLS-1$",
    "function_modified_lines": {
      "added": [
        "import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n"
      ],
      "deleted": [
        "import javax.xml.parsers.DocumentBuilderFactory;\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "In Eclipse IDE versions < 2023-09 (4.29) some files with xml content are parsed vulnerable against all sorts of XXE attacks. The user just needs to open any evil project or update an open project with a vulnerable file (for example for review a foreign repository or patch).\n",
    "id": 12897
  },
  {
    "cve_id": "CVE-2023-4218",
    "code_before_change": "{\n\t\tString collectData = \"\"; //$NON-NLS-1$\n\n\t\tDocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();\n\t\tDocumentBuilder docBuilder = null;\n\t\ttry {\n\t\t\tdocBuilder = dfactory.newDocumentBuilder();\n\t\t\tDocument doc = docBuilder.newDocument();\n\n\t\t\tElement rootElement = doc.createElement(\"whileSteppingData\"); //$NON-NLS-1$\n\t\t\trootElement.setAttribute(\"whileSteppingCount\", Integer.toString(fStepCount)); //$NON-NLS-1$\n\t\t\trootElement.setAttribute(\"subActionNames\", fSubActionNames); //$NON-NLS-1$\n\n\t\t\tdoc.appendChild(rootElement);\n\n\t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n\n\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n\t\t\tTransformer transformer = factory.newTransformer();\n\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\n\t\t\tDOMSource source = new DOMSource(doc);\n\t\t\tStreamResult outputTarget = new StreamResult(s);\n\t\t\ttransformer.transform(source, outputTarget);\n\n\t\t\tcollectData = s.toString(\"UTF8\"); //$NON-NLS-1$\n\n\t\t} catch (Exception e) {\n\t\t\tGdbPlugin.log(e);\n\t\t}\n\t\treturn collectData;\n\t}",
    "code_after_change": "{\n\t\t\tDocumentBuilder docBuilder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n\t\t\tDocument doc = docBuilder.newDocument();\n\n\t\t\tElement rootElement = doc.createElement(\"whileSteppingData\"); //$NON-NLS-1$\n\t\t\trootElement.setAttribute(\"whileSteppingCount\", Integer.toString(fStepCount)); //$NON-NLS-1$\n\t\t\trootElement.setAttribute(\"subActionNames\", fSubActionNames); //$NON-NLS-1$\n\n\t\t\tdoc.appendChild(rootElement);\n\n\t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n\n\t\t\tTransformerFactory factory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n\t\t\tTransformer transformer = factory.newTransformer();\n\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\n\t\t\tDOMSource source = new DOMSource(doc);\n\t\t\tStreamResult outputTarget = new StreamResult(s);\n\t\t\ttransformer.transform(source, outputTarget);\n\n\t\t\tcollectData = s.toString(\"UTF8\"); //$NON-NLS-1$\n\n\t\t}",
    "patch": "@@ -19,14 +19,14 @@\n import java.io.StringReader;\n \n import javax.xml.parsers.DocumentBuilder;\n-import javax.xml.parsers.DocumentBuilderFactory;\n import javax.xml.transform.OutputKeys;\n import javax.xml.transform.Transformer;\n import javax.xml.transform.TransformerFactory;\n import javax.xml.transform.dom.DOMSource;\n import javax.xml.transform.stream.StreamResult;\n \n import org.eclipse.cdt.dsf.gdb.internal.GdbPlugin;\n+import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n import org.w3c.dom.Document;\n import org.w3c.dom.Element;\n import org.xml.sax.InputSource;\n@@ -98,10 +98,8 @@ public String getIdentifier() {\n \tpublic String getMemento() {\n \t\tString collectData = \"\"; //$NON-NLS-1$\n \n-\t\tDocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();\n-\t\tDocumentBuilder docBuilder = null;\n \t\ttry {\n-\t\t\tdocBuilder = dfactory.newDocumentBuilder();\n+\t\t\tDocumentBuilder docBuilder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tDocument doc = docBuilder.newDocument();\n \n \t\t\tElement rootElement = doc.createElement(\"whileSteppingData\"); //$NON-NLS-1$\n@@ -112,7 +110,7 @@ public String getMemento() {\n \n \t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n \n-\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n+\t\t\tTransformerFactory factory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n \t\t\tTransformer transformer = factory.newTransformer();\n \t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n \t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n@@ -145,7 +143,7 @@ public void initializeFromMemento(String data) {\n \t\tElement root = null;\n \t\tDocumentBuilder parser;\n \t\ttry {\n-\t\t\tparser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n+\t\t\tparser = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tparser.setErrorHandler(new DefaultHandler());\n \t\t\troot = parser.parse(new InputSource(new StringReader(data))).getDocumentElement();\n \t\t\tsetStepCount(Integer.parseInt(root.getAttribute(\"whileSteppingCount\"))); //$NON-NLS-1$",
    "function_modified_lines": {
      "added": [
        "\t\t\tDocumentBuilder docBuilder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n",
        "\t\t\tTransformerFactory factory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n"
      ],
      "deleted": [
        "\t\tDocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();\n",
        "\t\tDocumentBuilder docBuilder = null;\n",
        "\t\t\tdocBuilder = dfactory.newDocumentBuilder();\n",
        "\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n"
      ]
    },
    "lang": "Java",
    "cwe": [
      "CWE-611"
    ],
    "cve_description": "In Eclipse IDE versions < 2023-09 (4.29) some files with xml content are parsed vulnerable against all sorts of XXE attacks. The user just needs to open any evil project or update an open project with a vulnerable file (for example for review a foreign repository or patch).\n",
    "id": 12898
  }
]