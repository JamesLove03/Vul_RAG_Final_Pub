[
    {
        "cve_id": "CVE-2013-4521",
        "code_before_change": "package org.richfaces.demo.paint2d;\r\n\r\nimport java.io.Serializable;\r\n\r\npublic class PaintData implements Serializable{\r\n\t/**\r\n\t * \r\n\t */\r\n\tprivate static final long serialVersionUID = 1L;\r\n\tString text;\r\n\tInteger color;\r\n\tfloat scale;\r\n\r\n\r\n\tpublic Integer getColor() {\r\n\t\treturn color;\r\n\t}\r\n\tpublic void setColor(Integer color) {\r\n\t\tthis.color = color;\r\n\t}\r\n\tpublic float getScale() {\r\n\t\treturn scale;\r\n\t}\r\n\tpublic void setScale(float scale) {\r\n\t\tthis.scale = scale;\r\n\t}\r\n\r\n\tpublic String getText() {\r\n\t\treturn text;\r\n\t}\r\n\tpublic void setText(String text) {\r\n\t\tthis.text = text;\r\n\t}\r\n}\r\n",
        "code_after_change": "package org.richfaces.demo.paint2d;\r\n\r\nimport org.ajax4jsf.resource.SerializableResource;\r\n\r\npublic class PaintData implements SerializableResource {\r\n\t/**\r\n\t * \r\n\t */\r\n\tprivate static final long serialVersionUID = 1L;\r\n\tString text;\r\n\tInteger color;\r\n\tfloat scale;\r\n\r\n\r\n\tpublic Integer getColor() {\r\n\t\treturn color;\r\n\t}\r\n\tpublic void setColor(Integer color) {\r\n\t\tthis.color = color;\r\n\t}\r\n\tpublic float getScale() {\r\n\t\treturn scale;\r\n\t}\r\n\tpublic void setScale(float scale) {\r\n\t\tthis.scale = scale;\r\n\t}\r\n\r\n\tpublic String getText() {\r\n\t\treturn text;\r\n\t}\r\n\tpublic void setText(String text) {\r\n\t\tthis.text = text;\r\n\t}\r\n}\r\n",
        "patch": "@@ -1,8 +1,8 @@\n package org.richfaces.demo.paint2d;\r\n \r\n-import java.io.Serializable;\r\n+import org.ajax4jsf.resource.SerializableResource;\r\n \r\n-public class PaintData implements Serializable{\r\n+public class PaintData implements SerializableResource {\r\n \t/**\r\n \t * \r\n \t */\r",
        "function_modified_lines": {
            "added": [
                "import org.ajax4jsf.resource.SerializableResource;\r\n",
                "public class PaintData implements SerializableResource {\r\n"
            ],
            "deleted": [
                "import java.io.Serializable;\r\n",
                "public class PaintData implements Serializable{\r\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-502"
        ],
        "cve_description": "RichFaces implementation in Nuxeo Platform 5.6.0 before HF27 and 5.8.0 before HF-01 does not restrict the classes for which deserialization methods can be called, which allows remote attackers to execute arbitrary code via crafted serialized data. NOTE: this vulnerability may overlap CVE-2013-2165.",
        "id": 11955
    },
    {
        "cve_id": "CVE-2023-36480",
        "code_before_change": "{\n\t\tcase ParticleType.STRING:\n\t\t\treturn Buffer.utf8ToString(buf, offset, len);\n\n\t\tcase ParticleType.INTEGER:\n\t\t\treturn Buffer.bytesToNumber(buf, offset, len);\n\n\t\tcase ParticleType.BOOL:\n\t\t\treturn Buffer.bytesToBool(buf, offset, len);\n\n\t\tcase ParticleType.DOUBLE:\n\t\t\treturn Buffer.bytesToDouble(buf, offset);\n\n\t\tcase ParticleType.BLOB:\n\t\t\treturn Arrays.copyOfRange(buf, offset, offset+len);\n\n\t\tcase ParticleType.JBLOB:\n\t\t\treturn Buffer.bytesToObject(buf, offset, len);\n\n\t\tcase ParticleType.GEOJSON:\n\t\t\treturn Buffer.bytesToGeoJSON(buf, offset, len);\n\n\t\tcase ParticleType.HLL:\n\t\t\treturn Buffer.bytesToHLL(buf, offset, len);\n\n\t\tcase ParticleType.LIST:\n\t\t\treturn Unpacker.unpackObjectList(buf, offset, len);\n\n\t\tcase ParticleType.MAP:\n\t\t\treturn Unpacker.unpackObjectMap(buf, offset, len);\n\n\t\tdefault:\n\t\t\treturn null;\n\t\t}",
        "code_after_change": "{\n\t\tcase ParticleType.STRING:\n\t\t\treturn Buffer.utf8ToString(buf, offset, len);\n\n\t\tcase ParticleType.INTEGER:\n\t\t\treturn Buffer.bytesToNumber(buf, offset, len);\n\n\t\tcase ParticleType.BOOL:\n\t\t\treturn Buffer.bytesToBool(buf, offset, len);\n\n\t\tcase ParticleType.DOUBLE:\n\t\t\treturn Buffer.bytesToDouble(buf, offset);\n\n\t\tcase ParticleType.BLOB:\n\t\t\treturn Arrays.copyOfRange(buf, offset, offset+len);\n\n\t\tcase ParticleType.GEOJSON:\n\t\t\treturn Buffer.bytesToGeoJSON(buf, offset, len);\n\n\t\tcase ParticleType.HLL:\n\t\t\treturn Buffer.bytesToHLL(buf, offset, len);\n\n\t\tcase ParticleType.LIST:\n\t\t\treturn Unpacker.unpackObjectList(buf, offset, len);\n\n\t\tcase ParticleType.MAP:\n\t\t\treturn Unpacker.unpackObjectMap(buf, offset, len);\n\n\t\tdefault:\n\t\t\treturn null;\n\t\t}",
        "patch": "@@ -16,8 +16,6 @@\n  */\n package com.aerospike.client.command;\n \n-import java.io.ByteArrayInputStream;\n-import java.io.ObjectInputStream;\n import java.math.BigInteger;\n import java.nio.charset.StandardCharsets;\n import java.util.Arrays;\n@@ -69,9 +67,6 @@ public static Object bytesToParticle(int type, byte[] buf, int offset, int len)\n \t\tcase ParticleType.BLOB:\n \t\t\treturn Arrays.copyOfRange(buf, offset, offset+len);\n \n-\t\tcase ParticleType.JBLOB:\n-\t\t\treturn Buffer.bytesToObject(buf, offset, len);\n-\n \t\tcase ParticleType.GEOJSON:\n \t\t\treturn Buffer.bytesToGeoJSON(buf, offset, len);\n \n@@ -297,25 +292,6 @@ public static String bytesToHexString(byte[] buf, int offset, int length) {\n \t\treturn sb.toString();\n \t}\n \n-\tpublic static Object bytesToObject(byte[] buf, int offset, int length) {\n-\t\tif (length <= 0) {\n-\t\t\treturn null;\n-\t\t}\n-\n-\t\tif (Value.DisableDeserializer) {\n-\t\t\tthrow new AerospikeException.Serialize(\"Object deserializer has been disabled\");\n-\t\t}\n-\n-\t\ttry (ByteArrayInputStream bastream = new ByteArrayInputStream(buf, offset, length)) {\n-\t\t\ttry (ObjectInputStream oistream = new ObjectInputStream(bastream)) {\n-\t\t\t\treturn oistream.readObject();\n-\t\t\t}\n-\t\t}\n-\t\tcatch (Throwable e) {\n-\t\t\tthrow new AerospikeException.Serialize(e);\n-\t\t}\n-\t}\n-\n \tpublic static Value bytesToLongValue(byte[] buf, int offset, int len) {\n \t\tlong val = 0;\n ",
        "function_modified_lines": {
            "added": [],
            "deleted": [
                "\t\tcase ParticleType.JBLOB:\n",
                "\t\t\treturn Buffer.bytesToObject(buf, offset, len);\n",
                "\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-502"
        ],
        "cve_description": "The Aerospike Java client is a Java application that implements a network protocol to communicate with an Aerospike server. Prior to versions 7.0.0, 6.2.0, 5.2.0, and 4.5.0 some of the messages received from the server contain Java objects that the client deserializes when it encounters them without further validation. Attackers that manage to trick clients into communicating with a malicious server can include especially crafted objects in its responses that, once deserialized by the client, force it to execute arbitrary code. This can be abused to take control of the machine the client is running on. Versions 7.0.0, 6.2.0, 5.2.0, and 4.5.0 contain a patch for this issue.",
        "id": 12734
    },
    {
        "cve_id": "CVE-2023-36480",
        "code_before_change": "\n\t/**\n\t * Get sorted map or null value instance.\n\t */\n\tpublic static Value get(SortedMap<?,?> value) {\n\t\treturn (value == null)? NullValue.INSTANCE : new MapValue(value, MapOrder.KEY_ORDERED);\n\t}\n\n\t/**\n\t * This method is deprecated.\n\t * Use {@link #get(Map)} if the map is unsorted (like HashMap).\n\t * Use {@link #get(SortedMap)} if the map is sorted (like TreeMap).\n\t * <p>\n\t * Get map or null value instance.\n\t */\n\t@Deprecated\n\tpublic static Value get(Map<?,?> value, MapOrder order) {\n\t\treturn (value == null)? NullValue.INSTANCE : new MapValue(value, order);\n\t}\n\n\t/**\n\t * Get sorted map or null value instance.\n\t */\n\tpublic static Value get(List<? extends Entry<?,?>> value, MapOrder mapOrder) {\n\t\treturn (value == null)? NullValue.INSTANCE : new SortedMapValue(value, mapOrder);\n\t}\n\n\t/**\n\t * Get value array instance.\n\t */\n\tpublic static Value get(Value[] value) {\n\t\treturn (value == null)? NullValue.INSTANCE : new ValueArray(value);\n\t}\n\n\t/**\n\t * Get blob or null value instance.\n\t */\n\tpublic static Value getAsBlob(Object value) {\n\t\treturn (value == null)? NullValue.INSTANCE : new BlobValue(value);\n\t}\n\n\t/**\n\t * Get GeoJSON or null value instance.\n\t */\n\tpublic static Value getAsGeoJSON(String value) {\n\t\treturn (value == null)? NullValue.INSTANCE : new GeoJSONValue(value);\n\t}\n\n\t/**\n\t * Get HyperLogLog or null value instance.\n\t */\n\tpublic static Value getAsHLL(byte[] value) {\n\t\treturn (value == null)? NullValue.INSTANCE : new HLLValue(value);\n\t}\n\n\t/**\n\t * Get null value instance.\n\t */\n\tpublic static Value getAsNull() {\n\t\treturn NullValue.INSTANCE;\n\t}\n\n\t/**\n\t * Determine value given generic object.\n\t * This is the slowest of the Value get() methods.\n\t * Useful when copying records from one cluster to another.\n\t */\n\tpublic static Value get(Object value) {\n\t\tif (value == null) {\n\t\t\treturn NullValue.INSTANCE;\n\t\t}\n\n\t\tif (value instanceof Value) {\n\t\t\treturn (Value)value;\n\t\t}\n\n\t\tif (value instanceof byte[]) {",
        "code_after_change": "\t\treturn (value == null)? NullValue.INSTANCE : new MapValue(value);\n\t}\n\n\t/**\n\t * Get sorted map or null value instance.\n\t */\n\tpublic static Value get(SortedMap<?,?> value) {\n\t\treturn (value == null)? NullValue.INSTANCE : new MapValue(value, MapOrder.KEY_ORDERED);\n\t}\n\n\t/**\n\t * This method is deprecated.\n\t * Use {@link #get(Map)} if the map is unsorted (like HashMap).\n\t * Use {@link #get(SortedMap)} if the map is sorted (like TreeMap).\n\t * <p>\n\t * Get map or null value instance.\n\t */\n\t@Deprecated\n\tpublic static Value get(Map<?,?> value, MapOrder order) {\n\t\treturn (value == null)? NullValue.INSTANCE : new MapValue(value, order);\n\t}\n\n\t/**\n\t * Get sorted map or null value instance.\n\t */\n\tpublic static Value get(List<? extends Entry<?,?>> value, MapOrder mapOrder) {\n\t\treturn (value == null)? NullValue.INSTANCE : new SortedMapValue(value, mapOrder);\n\t}\n\n\t/**\n\t * Get value array instance.\n\t */\n\tpublic static Value get(Value[] value) {\n\t\treturn (value == null)? NullValue.INSTANCE : new ValueArray(value);\n\t}\n\n\t/**\n\t * Get GeoJSON or null value instance.\n\t */\n\tpublic static Value getAsGeoJSON(String value) {\n\t\treturn (value == null)? NullValue.INSTANCE : new GeoJSONValue(value);\n\t}\n\n\t/**\n\t * Get HyperLogLog or null value instance.\n\t */\n\tpublic static Value getAsHLL(byte[] value) {\n\t\treturn (value == null)? NullValue.INSTANCE : new HLLValue(value);\n\t}\n\n\t/**\n\t * Get null value instance.\n\t */\n\tpublic static Value getAsNull() {\n\t\treturn NullValue.INSTANCE;\n\t}\n\n\t/**\n\t * Determine value given generic object.\n\t * This is the slowest of the Value get() methods.\n\t * Useful when copying records from one cluster to another.\n\t */\n\tpublic static Value get(Object value) {\n\t\tif (value == null) {\n\t\t\treturn NullValue.INSTANCE;\n\t\t}\n\n\t\tif (value instanceof Value) {\n\t\t\treturn (Value)value;\n\t\t}\n\n\t\tif (value instanceof byte[]) {\n\t\t\treturn new BytesValue((byte[])value);\n\t\t}",
        "patch": "@@ -16,8 +16,6 @@\n  */\n package com.aerospike.client;\n \n-import java.io.ByteArrayOutputStream;\n-import java.io.ObjectOutputStream;\n import java.nio.ByteBuffer;\n import java.util.Arrays;\n import java.util.List;\n@@ -52,24 +50,6 @@ public abstract class Value {\n \t */\n \tpublic static boolean UseBoolBin = true;\n \n-\t/**\n-\t * Should default object serializer be disabled. If true, an exception will be thrown when\n-\t * a default object serialization is attempted. Default object serialization is triggered\n-\t * when a bin constructed by {@link com.aerospike.client.Bin#Bin(String, Object)} or\n-\t * {@link com.aerospike.client.Bin#asBlob(String, Object)} is used in a write command\n-\t * with an unrecognized object type.\n-\t */\n-\tpublic static boolean DisableSerializer = false;\n-\n-\t/**\n-\t * Should default object deserializer be disabled. If true, an exception will be thrown when\n-\t * a default object deserialization is attempted. Default object serialization is triggered\n-\t * when serialized data is read/parsed from the server. DisableDeserializer is separate from\n-\t * DisableSerializer because there may be cases when no new serialization is allowed, but\n-\t * existing serialized objects need to be supported.\n-\t */\n-\tpublic static boolean DisableDeserializer = false;\n-\n \t/**\n \t * Should the client return a map when {@link com.aerospike.client.cdt.MapReturnType#KEY_VALUE}\n \t * is specified in a map read operation and the server returns a list of key/value pairs.\n@@ -241,13 +221,6 @@ public static Value get(Value[] value) {\n \t\treturn (value == null)? NullValue.INSTANCE : new ValueArray(value);\n \t}\n \n-\t/**\n-\t * Get blob or null value instance.\n-\t */\n-\tpublic static Value getAsBlob(Object value) {\n-\t\treturn (value == null)? NullValue.INSTANCE : new BlobValue(value);\n-\t}\n-\n \t/**\n \t * Get GeoJSON or null value instance.\n \t */\n@@ -349,7 +322,7 @@ public static Value get(Object value) {\n \t\t\treturn new BytesValue(bb.array());\n \t\t}\n \n-\t\treturn new BlobValue(value);\n+\t\tthrow new AerospikeException(\"Unsupported type: \" + value.getClass().getName());\n \t}\n \n \t/**\n@@ -1260,88 +1233,6 @@ public long toLong() {\n \t\t}\n \t}\n \n-\t/**\n-\t * Blob value.\n-\t */\n-\tpublic static final class BlobValue extends Value {\n-\t\tprivate final Object object;\n-\t\tprivate byte[] bytes;\n-\n-\t\tpublic BlobValue(Object object) {\n-\t\t\tthis.object = object;\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic int estimateSize() throws AerospikeException.Serialize {\n-\t\t\tbytes = serialize(object);\n-\t\t\treturn bytes.length;\n-\t\t}\n-\n-\t\tpublic static byte[] serialize(Object val) {\n-\t\t\tif (DisableSerializer) {\n-\t\t\t\tthrow new AerospikeException(\"Object serializer has been disabled\");\n-\t\t\t}\n-\n-\t\t\ttry (ByteArrayOutputStream bstream = new ByteArrayOutputStream()) {\n-\t\t\t\ttry (ObjectOutputStream ostream = new ObjectOutputStream(bstream)) {\n-\t\t\t\t\tostream.writeObject(val);\n-\t\t\t\t}\n-\t\t\t\treturn bstream.toByteArray();\n-\t\t\t}\n-\t\t\tcatch (Throwable e) {\n-\t\t\t\tthrow new AerospikeException.Serialize(e);\n-\t\t\t}\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic int write(byte[] buffer, int offset) {\n-\t\t\tSystem.arraycopy(bytes, 0, buffer, offset, bytes.length);\n-\t\t\treturn bytes.length;\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void pack(Packer packer) {\n-\t\t\tpacker.packBlob(object);\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void validateKeyType() {\n-\t\t\tthrow new AerospikeException(ResultCode.PARAMETER_ERROR, \"Invalid key type: jblob\");\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic int getType() {\n-\t\t\treturn ParticleType.JBLOB;\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic Object getObject() {\n-\t\t\treturn object;\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic LuaValue getLuaValue(LuaInstance instance) {\n-\t\t\treturn LuaString.valueOf(bytes);\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic String toString() {\n-\t\t\treturn Buffer.bytesToHexString(bytes);\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic boolean equals(Object other) {\n-\t\t\treturn (other != null &&\n-\t\t\t\tthis.getClass().equals(other.getClass()) &&\n-\t\t\t\tthis.object.equals(((BlobValue)other).object));\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic int hashCode() {\n-\t\t\treturn object.hashCode();\n-\t\t}\n-\t}\n-\n \t/**\n \t * GeoJSON value.\n \t */",
        "function_modified_lines": {
            "added": [],
            "deleted": [
                "\t/**\n",
                "\t * Get blob or null value instance.\n",
                "\t */\n",
                "\tpublic static Value getAsBlob(Object value) {\n",
                "\t\treturn (value == null)? NullValue.INSTANCE : new BlobValue(value);\n",
                "\t}\n",
                "\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-502"
        ],
        "cve_description": "The Aerospike Java client is a Java application that implements a network protocol to communicate with an Aerospike server. Prior to versions 7.0.0, 6.2.0, 5.2.0, and 4.5.0 some of the messages received from the server contain Java objects that the client deserializes when it encounters them without further validation. Attackers that manage to trick clients into communicating with a malicious server can include especially crafted objects in its responses that, once deserialized by the client, force it to execute arbitrary code. This can be abused to take control of the machine the client is running on. Versions 7.0.0, 6.2.0, 5.2.0, and 4.5.0 contain a patch for this issue.",
        "id": 12732
    },
    {
        "cve_id": "CVE-2023-36480",
        "code_before_change": "{\n\n\t\tpublic ObjectUnpacker(byte[] buffer, int offset, int length) {\n\t\t\tsuper(buffer, offset, length);\n\t\t}\n\n\t\t@Override\n\t\tprotected Object getMap(Map<Object,Object> value) {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tprotected Object getList(List<Object> value) {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tprotected Object getJavaBlob(Object value) {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tprotected Object getBlob(byte[] value) {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tprotected Object getString(String value) {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tprotected Object getLong(long value) {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tprotected Object getDouble(double value) {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tprotected Object getBoolean(boolean value) {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tprotected Object getGeoJSON(String value) {\n\t\t\treturn Value.getAsGeoJSON(value);\n\t\t}\n\t}",
        "code_after_change": "{\n\n\t\tpublic ObjectUnpacker(byte[] buffer, int offset, int length) {\n\t\t\tsuper(buffer, offset, length);\n\t\t}\n\n\t\t@Override\n\t\tprotected Object getMap(Map<Object,Object> value) {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tprotected Object getList(List<Object> value) {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tprotected Object getBlob(byte[] value) {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tprotected Object getString(String value) {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tprotected Object getLong(long value) {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tprotected Object getDouble(double value) {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tprotected Object getBoolean(boolean value) {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tprotected Object getGeoJSON(String value) {\n\t\t\treturn Value.getAsGeoJSON(value);\n\t\t}\n\t}",
        "patch": "@@ -16,9 +16,7 @@\n  */\n package com.aerospike.client.util;\n \n-import java.io.ByteArrayInputStream;\n import java.io.IOException;\n-import java.io.ObjectInputStream;\n import java.nio.ByteBuffer;\n import java.util.AbstractMap;\n import java.util.ArrayList;\n@@ -234,21 +232,6 @@ private T unpackBlob(int count) throws IOException, ClassNotFoundException {\n \t\t\tval = getString(Buffer.utf8ToString(buffer, offset, count));\n \t\t\tbreak;\n \n-\t\tcase ParticleType.JBLOB:\n-\t\t\tif (Value.DisableDeserializer) {\n-\t\t\t\tthrow new AerospikeException.Serialize(\"Object deserializer has been disabled\");\n-\t\t\t}\n-\n-\t\t\ttry (ByteArrayInputStream bastream = new ByteArrayInputStream(buffer, offset, count)) {\n-\t\t\t\ttry (ObjectInputStream oistream = new ObjectInputStream(bastream)) {\n-\t\t\t\t\tval = getJavaBlob(oistream.readObject());\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tcatch (Throwable e) {\n-\t\t\t\tthrow new AerospikeException.Serialize(e);\n-\t\t\t}\n-\t\t\tbreak;\n-\n \t\tcase ParticleType.GEOJSON:\n \t\t\tval = getGeoJSON(Buffer.utf8ToString(buffer, offset, count));\n \t\t\tbreak;\n@@ -451,7 +434,6 @@ public T unpackObject() throws IOException, ClassNotFoundException {\n \n \tprotected abstract T getMap(Map<T,T> value);\n \tprotected abstract T getList(List<T> value);\n-\tprotected abstract T getJavaBlob(Object value);\n \tprotected abstract T getBlob(byte[] value);\n \tprotected abstract T getString(String value);\n \tprotected abstract T getLong(long value);\n@@ -498,11 +480,6 @@ protected Object getList(List<Object> value) {\n \t\t\treturn value;\n \t\t}\n \n-\t\t@Override\n-\t\tprotected Object getJavaBlob(Object value) {\n-\t\t\treturn value;\n-\t\t}\n-\n \t\t@Override\n \t\tprotected Object getBlob(byte[] value) {\n \t\t\treturn value;",
        "function_modified_lines": {
            "added": [],
            "deleted": [
                "\t\t@Override\n",
                "\t\tprotected Object getJavaBlob(Object value) {\n",
                "\t\t\treturn value;\n",
                "\t\t}\n",
                "\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-502"
        ],
        "cve_description": "The Aerospike Java client is a Java application that implements a network protocol to communicate with an Aerospike server. Prior to versions 7.0.0, 6.2.0, 5.2.0, and 4.5.0 some of the messages received from the server contain Java objects that the client deserializes when it encounters them without further validation. Attackers that manage to trick clients into communicating with a malicious server can include especially crafted objects in its responses that, once deserialized by the client, force it to execute arbitrary code. This can be abused to take control of the machine the client is running on. Versions 7.0.0, 6.2.0, 5.2.0, and 4.5.0 contain a patch for this issue.",
        "id": 12740
    },
    {
        "cve_id": "CVE-2023-38689",
        "code_before_change": "package logisticspipes.network.abstractguis;\n\nimport java.io.IOException;\n\nimport net.minecraft.entity.player.EntityPlayer;\nimport net.minecraft.inventory.Slot;\n\nimport lombok.AccessLevel;\nimport lombok.Getter;\nimport lombok.Setter;\n\nimport logisticspipes.network.exception.TargetNotFoundException;\nimport logisticspipes.utils.gui.DummyContainer;\nimport network.rs485.logisticspipes.util.LPDataInput;\nimport network.rs485.logisticspipes.util.LPDataOutput;\n\npublic abstract class UpgradeCoordinatesGuiProvider extends CoordinatesPopupGuiProvider {\n\n\tpublic UpgradeCoordinatesGuiProvider(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Getter(AccessLevel.PROTECTED)\n\t@Setter(AccessLevel.PRIVATE)\n\tprivate int positionInt;\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\tsuper.writeData(output);\n\t\toutput.writeInt(positionInt);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tsuper.readData(input);\n\t\tpositionInt = input.readInt();\n\t}\n\n\tpublic UpgradeCoordinatesGuiProvider setSlot(Slot slot) {\n\t\tthis.setPositionInt(slot.slotNumber);\n\t\treturn this;\n\t}\n\n\tpublic <T extends Slot> T getSlot(EntityPlayer player, Class<T> clazz) {\n\t\tif (player.openContainer instanceof DummyContainer) {\n\t\t\tif (positionInt >= player.openContainer.inventorySlots.size()) {\n\t\t\t\ttargetNotFound(\"The requested Slot was out of range\");\n\t\t\t} else {\n\t\t\t\tSlot slot = player.openContainer.getSlot(positionInt);\n\t\t\t\tif (slot == null) {\n\t\t\t\t\ttargetNotFound(\"The requested Slot was null\");\n\t\t\t\t} else if (!clazz.isAssignableFrom(slot.getClass())) {\n\t\t\t\t\ttargetNotFound(\"Couldn't find \" + clazz.getName() + \", found slot with \" + slot.getClass());\n\t\t\t\t} else {\n\t\t\t\t\treturn (T) slot;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprotected void targetNotFound(String message) {\n\t\tthrow new TargetNotFoundException(message, this);\n\t}\n}\n",
        "code_after_change": "package logisticspipes.network.abstractguis;\n\nimport net.minecraft.entity.player.EntityPlayer;\nimport net.minecraft.inventory.Slot;\n\nimport lombok.AccessLevel;\nimport lombok.Getter;\nimport lombok.Setter;\n\nimport logisticspipes.network.exception.TargetNotFoundException;\nimport logisticspipes.utils.gui.DummyContainer;\nimport network.rs485.logisticspipes.util.LPDataInput;\nimport network.rs485.logisticspipes.util.LPDataOutput;\n\npublic abstract class UpgradeCoordinatesGuiProvider extends CoordinatesPopupGuiProvider {\n\n\t@Getter(AccessLevel.PROTECTED)\n\t@Setter(AccessLevel.PRIVATE)\n\tprivate int positionInt;\n\n\tpublic UpgradeCoordinatesGuiProvider(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\tsuper.writeData(output);\n\t\toutput.writeInt(positionInt);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tsuper.readData(input);\n\t\tpositionInt = input.readInt();\n\t}\n\n\tpublic UpgradeCoordinatesGuiProvider setSlot(Slot slot) {\n\t\tthis.setPositionInt(slot.slotNumber);\n\t\treturn this;\n\t}\n\n\tpublic <T extends Slot> T getSlot(EntityPlayer player, Class<T> clazz) {\n\t\tif (player.openContainer instanceof DummyContainer) {\n\t\t\tif (positionInt >= player.openContainer.inventorySlots.size()) {\n\t\t\t\ttargetNotFound(\"The requested Slot was out of range\");\n\t\t\t} else {\n\t\t\t\tSlot slot = player.openContainer.getSlot(positionInt);\n\t\t\t\tif (slot == null) {\n\t\t\t\t\ttargetNotFound(\"The requested Slot was null\");\n\t\t\t\t} else if (!clazz.isAssignableFrom(slot.getClass())) {\n\t\t\t\t\ttargetNotFound(\"Couldn't find \" + clazz.getName() + \", found slot with \" + slot.getClass());\n\t\t\t\t} else {\n\t\t\t\t\treturn (T) slot;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprotected void targetNotFound(String message) {\n\t\tthrow new TargetNotFoundException(message, this);\n\t}\n}\n",
        "patch": "@@ -1,7 +1,5 @@\n package logisticspipes.network.abstractguis;\n \n-import java.io.IOException;\n-\n import net.minecraft.entity.player.EntityPlayer;\n import net.minecraft.inventory.Slot;\n \n@@ -16,22 +14,22 @@\n \n public abstract class UpgradeCoordinatesGuiProvider extends CoordinatesPopupGuiProvider {\n \n-\tpublic UpgradeCoordinatesGuiProvider(int id) {\n-\t\tsuper(id);\n-\t}\n-\n \t@Getter(AccessLevel.PROTECTED)\n \t@Setter(AccessLevel.PRIVATE)\n \tprivate int positionInt;\n \n+\tpublic UpgradeCoordinatesGuiProvider(int id) {\n+\t\tsuper(id);\n+\t}\n+\n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\tsuper.writeData(output);\n \t\toutput.writeInt(positionInt);\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tsuper.readData(input);\n \t\tpositionInt = input.readInt();\n \t}",
        "function_modified_lines": {
            "added": [
                "\tpublic UpgradeCoordinatesGuiProvider(int id) {\n",
                "\t\tsuper(id);\n",
                "\t}\n",
                "\n",
                "\tpublic void writeData(LPDataOutput output) {\n",
                "\tpublic void readData(LPDataInput input) {\n"
            ],
            "deleted": [
                "import java.io.IOException;\n",
                "\n",
                "\tpublic UpgradeCoordinatesGuiProvider(int id) {\n",
                "\t\tsuper(id);\n",
                "\t}\n",
                "\n",
                "\tpublic void writeData(LPDataOutput output) throws IOException {\n",
                "\tpublic void readData(LPDataInput input) throws IOException {\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-502"
        ],
        "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
        "id": 12769
    },
    {
        "cve_id": "CVE-2023-38689",
        "code_before_change": "package logisticspipes.network.packets.routingdebug;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInput;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutput;\nimport java.io.ObjectOutputStream;\n\nimport net.minecraft.block.Block;\nimport net.minecraft.entity.player.EntityPlayer;\nimport net.minecraft.tileentity.TileEntity;\nimport net.minecraft.util.ChatComponentText;\n\nimport lombok.Getter;\nimport lombok.Setter;\n\nimport logisticspipes.commands.chathelper.LPChatListener;\nimport logisticspipes.network.PacketHandler;\nimport logisticspipes.network.abstractpackets.ModernPacket;\nimport logisticspipes.network.packets.gui.OpenChatGui;\nimport logisticspipes.pipes.basic.CoreRoutedPipe;\nimport logisticspipes.pipes.basic.LogisticsTileGenericPipe;\nimport logisticspipes.proxy.MainProxy;\nimport logisticspipes.routing.ServerRouter;\nimport logisticspipes.routing.debug.DebugController;\nimport logisticspipes.utils.string.ChatColor;\nimport network.rs485.logisticspipes.util.LPDataInput;\nimport network.rs485.logisticspipes.util.LPDataOutput;\n\npublic class RoutingUpdateTargetResponse extends ModernPacket {\n\n\tpublic RoutingUpdateTargetResponse(int id) {\n\t\tsuper(id);\n\t}\n\n\tpublic enum TargetMode {\n\t\tBlock,\n\t\tEntity,\n\t\tNone\n\t}\n\n\t@Getter\n\t@Setter\n\tprivate TargetMode mode;\n\n\t@Getter\n\t@Setter\n\tprivate Object[] additions = new Object[0];\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tmode = TargetMode.values()[input.readByte()];\n\t\tint size = input.readInt();\n\t\tadditions = new Object[size];\n\t\tfor (int i = 0; i < size; i++) {\n\t\t\tbyte[] bytes = input.readByteArray();\n\t\t\tByteArrayInputStream bis = new ByteArrayInputStream(bytes);\n\t\t\tObjectInput in = new ObjectInputStream(bis);\n\t\t\ttry {\n\t\t\t\tObject o = in.readObject();\n\t\t\t\tadditions[i] = o;\n\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\tthrow new UnsupportedOperationException(e);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void processPacket(final EntityPlayer player) {\n\t\tif (mode == TargetMode.None) {\n\t\t\tplayer.addChatMessage(new ChatComponentText(ChatColor.RED + \"No Target Found\"));\n\t\t} else if (mode == TargetMode.Block) {\n\t\t\tint x = (Integer) additions[0];\n\t\t\tint y = (Integer) additions[1];\n\t\t\tint z = (Integer) additions[2];\n\t\t\tplayer.addChatMessage(new ChatComponentText(\"Checking Block at: x:\" + x + \" y:\" + y + \" z:\" + z));\n\t\t\tBlock id = player.worldObj.getBlock(x, y, z);\n\t\t\tplayer.addChatMessage(new ChatComponentText(\"Found Block with Id: \" + Block.getIdFromBlock(id)));\n\t\t\tfinal TileEntity tile = player.worldObj.getTileEntity(x, y, z);\n\t\t\tif (tile == null) {\n\t\t\t\tplayer.addChatMessage(new ChatComponentText(ChatColor.RED + \"No TileEntity found\"));\n\t\t\t} else if (!(tile instanceof LogisticsTileGenericPipe)) {\n\t\t\t\tplayer.addChatMessage(new ChatComponentText(ChatColor.RED + \"No LogisticsTileGenericPipe found\"));\n\t\t\t} else if (!(((LogisticsTileGenericPipe) tile).pipe instanceof CoreRoutedPipe)) {\n\t\t\t\tplayer.addChatMessage(new ChatComponentText(ChatColor.RED + \"No CoreRoutedPipe found\"));\n\t\t\t} else {\n\t\t\t\tLPChatListener.addTask(() -> {\n\t\t\t\t\tplayer.addChatMessage(new ChatComponentText(ChatColor.GREEN + \"Starting RoutingTable debug update.\"));\n\t\t\t\t\tDebugController.instance(player).debug(((ServerRouter) ((CoreRoutedPipe) ((LogisticsTileGenericPipe) tile).pipe).getRouter()));\n\t\t\t\t\tMainProxy.sendPacketToPlayer(PacketHandler.getPacket(OpenChatGui.class), player);\n\t\t\t\t\treturn true;\n\t\t\t\t}, player);\n\t\t\t\tplayer.addChatMessage(new ChatComponentText(\n\t\t\t\t\t\tChatColor.AQUA + \"Start RoutingTable debug update ? \" + ChatColor.RESET + \"<\" + ChatColor.GREEN + \"yes\" + ChatColor.RESET + \"/\"\n\t\t\t\t\t\t\t\t+ ChatColor.RED + \"no\" + ChatColor.RESET + \">\"));\n\t\t\t\tMainProxy.sendPacketToPlayer(PacketHandler.getPacket(OpenChatGui.class), player);\n\t\t\t}\n\t\t} else if (mode == TargetMode.Entity) {\n\t\t\tplayer.addChatMessage(new ChatComponentText(ChatColor.RED + \"Entity not allowed\"));\n\t\t}\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\toutput.writeByte(mode.ordinal());\n\t\toutput.writeInt(additions.length);\n\t\tfor (Object addition : additions) {\n\t\t\tByteArrayOutputStream bos = new ByteArrayOutputStream();\n\t\t\tObjectOutput out = new ObjectOutputStream(bos);\n\t\t\tout.writeObject(addition);\n\t\t\toutput.writeByteArray(bos.toByteArray());\n\t\t}\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new RoutingUpdateTargetResponse(getId());\n\t}\n\n\t@Override\n\tpublic boolean isCompressable() {\n\t\treturn true;\n\t}\n}\n",
        "code_after_change": "package logisticspipes.network.packets.routingdebug;\n\nimport net.minecraft.block.Block;\nimport net.minecraft.entity.player.EntityPlayer;\nimport net.minecraft.tileentity.TileEntity;\nimport net.minecraft.util.ChatComponentText;\n\nimport lombok.Getter;\nimport lombok.Setter;\n\nimport logisticspipes.commands.chathelper.LPChatListener;\nimport logisticspipes.network.PacketHandler;\nimport logisticspipes.network.abstractpackets.ModernPacket;\nimport logisticspipes.network.packets.gui.OpenChatGui;\nimport logisticspipes.pipes.basic.CoreRoutedPipe;\nimport logisticspipes.pipes.basic.LogisticsTileGenericPipe;\nimport logisticspipes.proxy.MainProxy;\nimport logisticspipes.routing.ServerRouter;\nimport logisticspipes.routing.debug.DebugController;\nimport logisticspipes.utils.string.ChatColor;\nimport network.rs485.logisticspipes.util.LPDataInput;\nimport network.rs485.logisticspipes.util.LPDataOutput;\n\npublic class RoutingUpdateTargetResponse extends ModernPacket {\n\n\t@Getter\n\t@Setter\n\tprivate TargetMode mode;\n\t@Getter\n\t@Setter\n\tprivate int[] additions = new int[0];\n\n\tpublic RoutingUpdateTargetResponse(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tmode = TargetMode.values()[input.readByte()];\n\t\tadditions = input.readIntArray();\n\t}\n\n\t@Override\n\tpublic void processPacket(final EntityPlayer player) {\n\t\tif (mode == TargetMode.None) {\n\t\t\tplayer.addChatMessage(new ChatComponentText(ChatColor.RED + \"No Target Found\"));\n\t\t} else if (mode == TargetMode.Block) {\n\t\t\tint x = additions[0];\n\t\t\tint y = additions[1];\n\t\t\tint z = additions[2];\n\t\t\tplayer.addChatMessage(new ChatComponentText(\"Checking Block at: x:\" + x + \" y:\" + y + \" z:\" + z));\n\t\t\tBlock id = player.worldObj.getBlock(x, y, z);\n\t\t\tplayer.addChatMessage(new ChatComponentText(\"Found Block with Id: \" + Block.getIdFromBlock(id)));\n\t\t\tfinal TileEntity tile = player.worldObj.getTileEntity(x, y, z);\n\t\t\tif (tile == null) {\n\t\t\t\tplayer.addChatMessage(new ChatComponentText(ChatColor.RED + \"No TileEntity found\"));\n\t\t\t} else if (!(tile instanceof LogisticsTileGenericPipe)) {\n\t\t\t\tplayer.addChatMessage(new ChatComponentText(ChatColor.RED + \"No LogisticsTileGenericPipe found\"));\n\t\t\t} else if (!(((LogisticsTileGenericPipe) tile).pipe instanceof CoreRoutedPipe)) {\n\t\t\t\tplayer.addChatMessage(new ChatComponentText(ChatColor.RED + \"No CoreRoutedPipe found\"));\n\t\t\t} else {\n\t\t\t\tLPChatListener.addTask(() -> {\n\t\t\t\t\tplayer.addChatMessage(new ChatComponentText(ChatColor.GREEN + \"Starting RoutingTable debug update.\"));\n\t\t\t\t\tDebugController.instance(player).debug(((ServerRouter) ((CoreRoutedPipe) ((LogisticsTileGenericPipe) tile).pipe).getRouter()));\n\t\t\t\t\tMainProxy.sendPacketToPlayer(PacketHandler.getPacket(OpenChatGui.class), player);\n\t\t\t\t\treturn true;\n\t\t\t\t}, player);\n\t\t\t\tplayer.addChatMessage(new ChatComponentText(\n\t\t\t\t\t\tChatColor.AQUA + \"Start RoutingTable debug update ? \" + ChatColor.RESET + \"<\" + ChatColor.GREEN + \"yes\" + ChatColor.RESET + \"/\"\n\t\t\t\t\t\t\t\t+ ChatColor.RED + \"no\" + ChatColor.RESET + \">\"));\n\t\t\t\tMainProxy.sendPacketToPlayer(PacketHandler.getPacket(OpenChatGui.class), player);\n\t\t\t}\n\t\t} else if (mode == TargetMode.Entity) {\n\t\t\tplayer.addChatMessage(new ChatComponentText(ChatColor.RED + \"Entity not allowed\"));\n\t\t}\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\toutput.writeByte(mode.ordinal());\n\t\toutput.writeIntArray(additions);\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new RoutingUpdateTargetResponse(getId());\n\t}\n\n\t@Override\n\tpublic boolean isCompressable() {\n\t\treturn true;\n\t}\n\n\tpublic enum TargetMode {\n\t\tBlock,\n\t\tEntity,\n\t\tNone\n\t}\n}\n",
        "patch": "@@ -1,13 +1,5 @@\n package logisticspipes.network.packets.routingdebug;\n \n-import java.io.ByteArrayInputStream;\n-import java.io.ByteArrayOutputStream;\n-import java.io.IOException;\n-import java.io.ObjectInput;\n-import java.io.ObjectInputStream;\n-import java.io.ObjectOutput;\n-import java.io.ObjectOutputStream;\n-\n import net.minecraft.block.Block;\n import net.minecraft.entity.player.EntityPlayer;\n import net.minecraft.tileentity.TileEntity;\n@@ -31,50 +23,31 @@\n \n public class RoutingUpdateTargetResponse extends ModernPacket {\n \n-\tpublic RoutingUpdateTargetResponse(int id) {\n-\t\tsuper(id);\n-\t}\n-\n-\tpublic enum TargetMode {\n-\t\tBlock,\n-\t\tEntity,\n-\t\tNone\n-\t}\n-\n \t@Getter\n \t@Setter\n \tprivate TargetMode mode;\n-\n \t@Getter\n \t@Setter\n-\tprivate Object[] additions = new Object[0];\n+\tprivate int[] additions = new int[0];\n+\n+\tpublic RoutingUpdateTargetResponse(int id) {\n+\t\tsuper(id);\n+\t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tmode = TargetMode.values()[input.readByte()];\n-\t\tint size = input.readInt();\n-\t\tadditions = new Object[size];\n-\t\tfor (int i = 0; i < size; i++) {\n-\t\t\tbyte[] bytes = input.readByteArray();\n-\t\t\tByteArrayInputStream bis = new ByteArrayInputStream(bytes);\n-\t\t\tObjectInput in = new ObjectInputStream(bis);\n-\t\t\ttry {\n-\t\t\t\tObject o = in.readObject();\n-\t\t\t\tadditions[i] = o;\n-\t\t\t} catch (ClassNotFoundException e) {\n-\t\t\t\tthrow new UnsupportedOperationException(e);\n-\t\t\t}\n-\t\t}\n+\t\tadditions = input.readIntArray();\n \t}\n \n \t@Override\n \tpublic void processPacket(final EntityPlayer player) {\n \t\tif (mode == TargetMode.None) {\n \t\t\tplayer.addChatMessage(new ChatComponentText(ChatColor.RED + \"No Target Found\"));\n \t\t} else if (mode == TargetMode.Block) {\n-\t\t\tint x = (Integer) additions[0];\n-\t\t\tint y = (Integer) additions[1];\n-\t\t\tint z = (Integer) additions[2];\n+\t\t\tint x = additions[0];\n+\t\t\tint y = additions[1];\n+\t\t\tint z = additions[2];\n \t\t\tplayer.addChatMessage(new ChatComponentText(\"Checking Block at: x:\" + x + \" y:\" + y + \" z:\" + z));\n \t\t\tBlock id = player.worldObj.getBlock(x, y, z);\n \t\t\tplayer.addChatMessage(new ChatComponentText(\"Found Block with Id: \" + Block.getIdFromBlock(id)));\n@@ -103,15 +76,9 @@ public void processPacket(final EntityPlayer player) {\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\toutput.writeByte(mode.ordinal());\n-\t\toutput.writeInt(additions.length);\n-\t\tfor (Object addition : additions) {\n-\t\t\tByteArrayOutputStream bos = new ByteArrayOutputStream();\n-\t\t\tObjectOutput out = new ObjectOutputStream(bos);\n-\t\t\tout.writeObject(addition);\n-\t\t\toutput.writeByteArray(bos.toByteArray());\n-\t\t}\n+\t\toutput.writeIntArray(additions);\n \t}\n \n \t@Override\n@@ -123,4 +90,10 @@ public ModernPacket template() {\n \tpublic boolean isCompressable() {\n \t\treturn true;\n \t}\n+\n+\tpublic enum TargetMode {\n+\t\tBlock,\n+\t\tEntity,\n+\t\tNone\n+\t}\n }",
        "function_modified_lines": {
            "added": [],
            "deleted": [
                "import java.io.ByteArrayInputStream;\n",
                "import java.io.ByteArrayOutputStream;\n",
                "import java.io.IOException;\n",
                "import java.io.ObjectInput;\n",
                "import java.io.ObjectInputStream;\n",
                "import java.io.ObjectOutput;\n",
                "import java.io.ObjectOutputStream;\n",
                "\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-502"
        ],
        "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
        "id": 12823
    },
    {
        "cve_id": "CVE-2023-38689",
        "code_before_change": "{\n\n\tpublic static List<ModernPacket> packetlist;\n\tpublic static Map<Class<? extends ModernPacket>, ModernPacket> packetmap;\n\n\tprivate static int packetDebugID = 1;\n\tpublic static final Map<Integer, StackTraceElement[]> debugMap = new HashMap<>();\n\n\t@SuppressWarnings(\"unchecked\")\n\t// Suppressed because this cast should never fail.\n\tpublic static <T extends ModernPacket> T getPacket(Class<T> clazz) {\n\t\tT packet = (T) PacketHandler.packetmap.get(clazz).template();\n\t\tif (LPConstants.DEBUG && MainProxy.proxy.getSide().equals(\"Client\")) {\n\t\t\tStackTraceElement[] trace = Thread.currentThread().getStackTrace();\n\t\t\tsynchronized (PacketHandler.debugMap) { //Unique id\n\t\t\t\tint id = PacketHandler.packetDebugID++;\n\t\t\t\tPacketHandler.debugMap.put(id, trace);\n\t\t\t\tpacket.setDebugId(id);\n\t\t\t}\n\t\t}\n\t\treturn packet;\n\t}\n\n\t//horrible hack to carry the proper player for the side along...\n\tstatic class InboundModernPacketWrapper {\n\n\t\tfinal ModernPacket packet;\n\t\tfinal EntityPlayer player;\n\n\t\tInboundModernPacketWrapper(ModernPacket p, EntityPlayer e) {\n\t\t\tpacket = p;\n\t\t\tplayer = e;\n\t\t}\n\t}\n\n\t/*\n\t * enumerates all ModernPackets, sets their IDs and populate packetlist/packetmap\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\t@SneakyThrows({ IOException.class, InvocationTargetException.class, IllegalAccessException.class, InstantiationException.class, IllegalArgumentException.class, NoSuchMethodException.class, SecurityException.class })\n\t// Suppression+sneakiness because these shouldn't ever fail, and if they do, it needs to fail.\n\tpublic static final void initialize() {\n\t\tfinal List<ClassInfo> classes = new ArrayList<>(ClassPath.from(PacketHandler.class.getClassLoader())\n\t\t\t\t.getTopLevelClassesRecursive(\"logisticspipes.network.packets\"));\n\t\tCollections.sort(classes, (o1, o2) -> o1.getSimpleName().compareTo(o2.getSimpleName()));\n\n\t\tPacketHandler.packetlist = new ArrayList<>(classes.size());\n\t\tPacketHandler.packetmap = new HashMap<>(classes.size());\n\n\t\tint currentid = 0;\n\n\t\tfor (ClassInfo c : classes) {\n\t\t\tfinal Class<?> cls = c.load();\n\t\t\tfinal ModernPacket instance = (ModernPacket) cls.getConstructor(int.class).newInstance(currentid);\n\t\t\tPacketHandler.packetlist.add(instance);\n\t\t\tPacketHandler.packetmap.put((Class<? extends ModernPacket>) cls, instance);\n\t\t\tcurrentid++;\n\t\t}\n\t}\n\n\t//TODO correct to work with WeakReference (See FML original)\n\tprotected static final AttributeKey<ThreadLocal<FMLProxyPacket>> INBOUNDPACKETTRACKER = new AttributeKey<>(\"lp:inboundpacket\");\n\n\t@Override\n\tpublic void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n\t\tsuper.handlerAdded(ctx);\n\t\tctx.attr(PacketHandler.INBOUNDPACKETTRACKER).set(new ThreadLocal<>());\n\t}\n\n\t//Used to provide the Description packet\n\tpublic static FMLProxyPacket toFMLPacket(ModernPacket msg) throws Exception {\n\t\treturn PacketHandler.toFMLPacket(msg, MainProxy.networkChannelName);\n\t}\n\n\tprivate static FMLProxyPacket toFMLPacket(ModernPacket msg, String channel) throws Exception {\n\t\tByteBuf buffer = Unpooled.buffer();\n\t\tbuffer.writeShort(msg.getId());\n\t\tbuffer.writeInt(msg.getDebugId());\n\n\t\tLPDataIOWrapper.writeData(buffer, msg::writeData);\n\n\t\treturn new FMLProxyPacket(buffer, channel);\n\t}\n\n\t@Override\n\tprotected final void encode(ChannelHandlerContext ctx, ModernPacket msg, List<Object> out) throws Exception {\n\t\tFMLProxyPacket proxy = PacketHandler.toFMLPacket(msg, ctx.channel().attr(NetworkRegistry.FML_CHANNEL).get());\n\t\tFMLProxyPacket old = ctx.attr(PacketHandler.INBOUNDPACKETTRACKER).get().get();\n\t\tif (old != null) {\n\t\t\tproxy.setDispatcher(old.getDispatcher());\n\t\t}\n\t\tout.add(proxy);\n\t}\n\n\t@Override\n\tprotected final void decode(ChannelHandlerContext ctx, FMLProxyPacket msg, List<Object> out) throws Exception {\n\t\tByteBuf payload = msg.payload();\n\t\tint packetID = payload.readShort();\n\t\tfinal ModernPacket packet = PacketHandler.packetlist.get(packetID).template();\n\t\tpacket.setDebugId(payload.readInt());\n\t\tctx.attr(PacketHandler.INBOUNDPACKETTRACKER).get().set(msg);\n\n\t\tLPDataIOWrapper.provideData(payload.slice(), packet::readData);\n\n\t\tout.add(new InboundModernPacketWrapper(packet, MainProxy.proxy.getEntityPlayerFromNetHandler(msg.handler())));\n\t}\n\n\t@Override\n\tpublic void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n\t\tFMLLog.log(Level.ERROR, cause, \"LogisticsPipes PacketHandler exception caught\");\n\t\tsuper.exceptionCaught(ctx, cause);\n\t}\n\n\t//hacky callback to process packets coming from by the packetbufferhandler decompressors\n\t//TODO replace with proper netty implementation\n\tpublic static void onPacketData(final LPDataInput data, final EntityPlayer player) throws IOException {\n\t\tif (player == null) {\n\t\t\treturn;\n\t\t}\n\t\tfinal int packetID = data.readShort();\n\t\tfinal ModernPacket packet = PacketHandler.packetlist.get(packetID).template();\n\t\tpacket.setDebugId(data.readInt());\n\t\tpacket.readData(data);\n\t\tPacketHandler.onPacketData(packet, player);\n\t}\n\n\tprivate static void onPacketData(ModernPacket packet, final EntityPlayer player) {\n\t\ttry {\n\t\t\tpacket.processPacket(player);\n\t\t\tif (LPConstants.DEBUG) {\n\t\t\t\tPacketHandler.debugMap.remove(packet.getDebugId());\n\t\t\t}\n\t\t} catch (DelayPacketException e) {\n\t\t\tif (packet.retry() && MainProxy.isClient(player.getEntityWorld())) {\n\t\t\t\tSimpleServiceLocator.clientBufferHandler.queueFailedPacket(packet, player);\n\t\t\t} else if (LPConstants.DEBUG) {\n\t\t\t\tLogisticsPipes.log.error(packet.getClass().getName());\n\t\t\t\tLogisticsPipes.log.error(packet.toString());\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n}",
        "code_after_change": "{\n\n\tpublic static final Map<Integer, StackTraceElement[]> debugMap = new HashMap<>();\n\t//TODO correct to work with WeakReference (See FML original)\n\tprotected static final AttributeKey<ThreadLocal<FMLProxyPacket>> INBOUNDPACKETTRACKER = new AttributeKey<>(\"lp:inboundpacket\");\n\tpublic static List<ModernPacket> packetlist;\n\tpublic static Map<Class<? extends ModernPacket>, ModernPacket> packetmap;\n\tprivate static int packetDebugID = 1;\n\n\t@SuppressWarnings(\"unchecked\")\n\t// Suppressed because this cast should never fail.\n\tpublic static <T extends ModernPacket> T getPacket(Class<T> clazz) {\n\t\tT packet = (T) PacketHandler.packetmap.get(clazz).template();\n\t\tif (LPConstants.DEBUG && MainProxy.proxy.getSide().equals(\"Client\")) {\n\t\t\tStackTraceElement[] trace = Thread.currentThread().getStackTrace();\n\t\t\tsynchronized (PacketHandler.debugMap) { //Unique id\n\t\t\t\tint id = PacketHandler.packetDebugID++;\n\t\t\t\tPacketHandler.debugMap.put(id, trace);\n\t\t\t\tpacket.setDebugId(id);\n\t\t\t}\n\t\t}\n\t\treturn packet;\n\t}\n\n\t/*\n\t * enumerates all ModernPackets, sets their IDs and populate packetlist/packetmap\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\t@SneakyThrows({ IOException.class, InvocationTargetException.class, IllegalAccessException.class, InstantiationException.class, IllegalArgumentException.class, NoSuchMethodException.class, SecurityException.class })\n\t// Suppression+sneakiness because these shouldn't ever fail, and if they do, it needs to fail.\n\tpublic static final void initialize() {\n\t\tfinal List<ClassInfo> classes = new ArrayList<>(ClassPath.from(PacketHandler.class.getClassLoader())\n\t\t\t\t.getTopLevelClassesRecursive(\"logisticspipes.network.packets\"));\n\t\tCollections.sort(classes, (o1, o2) -> o1.getSimpleName().compareTo(o2.getSimpleName()));\n\n\t\tPacketHandler.packetlist = new ArrayList<>(classes.size());\n\t\tPacketHandler.packetmap = new HashMap<>(classes.size());\n\n\t\tint currentid = 0;\n\n\t\tfor (ClassInfo c : classes) {\n\t\t\tfinal Class<?> cls = c.load();\n\t\t\tfinal ModernPacket instance = (ModernPacket) cls.getConstructor(int.class).newInstance(currentid);\n\t\t\tPacketHandler.packetlist.add(instance);\n\t\t\tPacketHandler.packetmap.put((Class<? extends ModernPacket>) cls, instance);\n\t\t\tcurrentid++;\n\t\t}\n\t}\n\n\t//Used to provide the Description packet\n\tpublic static FMLProxyPacket toFMLPacket(ModernPacket msg) throws Exception {\n\t\treturn PacketHandler.toFMLPacket(msg, MainProxy.networkChannelName);\n\t}\n\n\tprivate static FMLProxyPacket toFMLPacket(ModernPacket msg, String channel) throws Exception {\n\t\tByteBuf buffer = Unpooled.buffer();\n\t\tbuffer.writeShort(msg.getId());\n\t\tbuffer.writeInt(msg.getDebugId());\n\n\t\tLPDataIOWrapper.writeData(buffer, msg::writeData);\n\n\t\treturn new FMLProxyPacket(buffer, channel);\n\t}\n\n\t//hacky callback to process packets coming from by the packetbufferhandler decompressors\n\t//TODO replace with proper netty implementation\n\tpublic static void onPacketData(final LPDataInput data, final EntityPlayer player) {\n\t\tif (player == null) {\n\t\t\treturn;\n\t\t}\n\t\tfinal int packetID = data.readShort();\n\t\tfinal ModernPacket packet = PacketHandler.packetlist.get(packetID).template();\n\t\tpacket.setDebugId(data.readInt());\n\t\tpacket.readData(data);\n\t\tPacketHandler.onPacketData(packet, player);\n\t}\n\n\tprivate static void onPacketData(ModernPacket packet, final EntityPlayer player) {\n\t\ttry {\n\t\t\tpacket.processPacket(player);\n\t\t\tif (LPConstants.DEBUG) {\n\t\t\t\tPacketHandler.debugMap.remove(packet.getDebugId());\n\t\t\t}\n\t\t} catch (DelayPacketException e) {\n\t\t\tif (packet.retry() && MainProxy.isClient(player.getEntityWorld())) {\n\t\t\t\tSimpleServiceLocator.clientBufferHandler.queueFailedPacket(packet, player);\n\t\t\t} else if (LPConstants.DEBUG) {\n\t\t\t\tLogisticsPipes.log.error(packet.getClass().getName());\n\t\t\t\tLogisticsPipes.log.error(packet.toString());\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n\t\tsuper.handlerAdded(ctx);\n\t\tctx.attr(PacketHandler.INBOUNDPACKETTRACKER).set(new ThreadLocal<>());\n\t}\n\n\t@Override\n\tprotected final void encode(ChannelHandlerContext ctx, ModernPacket msg, List<Object> out) throws Exception {\n\t\tFMLProxyPacket proxy = PacketHandler.toFMLPacket(msg, ctx.channel().attr(NetworkRegistry.FML_CHANNEL).get());\n\t\tFMLProxyPacket old = ctx.attr(PacketHandler.INBOUNDPACKETTRACKER).get().get();\n\t\tif (old != null) {\n\t\t\tproxy.setDispatcher(old.getDispatcher());\n\t\t}\n\t\tout.add(proxy);\n\t}\n\n\t@Override\n\tprotected final void decode(ChannelHandlerContext ctx, FMLProxyPacket msg, List<Object> out) throws Exception {\n\t\tByteBuf payload = msg.payload();\n\t\tint packetID = payload.readShort();\n\t\tfinal ModernPacket packet = PacketHandler.packetlist.get(packetID).template();\n\t\tpacket.setDebugId(payload.readInt());\n\t\tctx.attr(PacketHandler.INBOUNDPACKETTRACKER).get().set(msg);\n\n\t\tLPDataIOWrapper.provideData(payload.slice(), packet::readData);\n\n\t\tout.add(new InboundModernPacketWrapper(packet, MainProxy.proxy.getEntityPlayerFromNetHandler(msg.handler())));\n\t}\n\n\t@Override\n\tpublic void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n\t\tFMLLog.log(Level.ERROR, cause, \"LogisticsPipes PacketHandler exception caught\");\n\t\tsuper.exceptionCaught(ctx, cause);\n\t}\n\n\t//horrible hack to carry the proper player for the side along...\n\tstatic class InboundModernPacketWrapper {\n\n\t\tfinal ModernPacket packet;\n\t\tfinal EntityPlayer player;\n\n\t\tInboundModernPacketWrapper(ModernPacket p, EntityPlayer e) {\n\t\t\tpacket = p;\n\t\t\tplayer = e;\n\t\t}\n\t}\n}",
        "patch": "@@ -39,11 +39,12 @@\n @Sharable\n public class PacketHandler extends MessageToMessageCodec<FMLProxyPacket, ModernPacket> {\n \n+\tpublic static final Map<Integer, StackTraceElement[]> debugMap = new HashMap<>();\n+\t//TODO correct to work with WeakReference (See FML original)\n+\tprotected static final AttributeKey<ThreadLocal<FMLProxyPacket>> INBOUNDPACKETTRACKER = new AttributeKey<>(\"lp:inboundpacket\");\n \tpublic static List<ModernPacket> packetlist;\n \tpublic static Map<Class<? extends ModernPacket>, ModernPacket> packetmap;\n-\n \tprivate static int packetDebugID = 1;\n-\tpublic static final Map<Integer, StackTraceElement[]> debugMap = new HashMap<>();\n \n \t@SuppressWarnings(\"unchecked\")\n \t// Suppressed because this cast should never fail.\n@@ -60,18 +61,6 @@ public static <T extends ModernPacket> T getPacket(Class<T> clazz) {\n \t\treturn packet;\n \t}\n \n-\t//horrible hack to carry the proper player for the side along...\n-\tstatic class InboundModernPacketWrapper {\n-\n-\t\tfinal ModernPacket packet;\n-\t\tfinal EntityPlayer player;\n-\n-\t\tInboundModernPacketWrapper(ModernPacket p, EntityPlayer e) {\n-\t\t\tpacket = p;\n-\t\t\tplayer = e;\n-\t\t}\n-\t}\n-\n \t/*\n \t * enumerates all ModernPackets, sets their IDs and populate packetlist/packetmap\n \t */\n@@ -97,15 +86,6 @@ public static final void initialize() {\n \t\t}\n \t}\n \n-\t//TODO correct to work with WeakReference (See FML original)\n-\tprotected static final AttributeKey<ThreadLocal<FMLProxyPacket>> INBOUNDPACKETTRACKER = new AttributeKey<>(\"lp:inboundpacket\");\n-\n-\t@Override\n-\tpublic void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n-\t\tsuper.handlerAdded(ctx);\n-\t\tctx.attr(PacketHandler.INBOUNDPACKETTRACKER).set(new ThreadLocal<>());\n-\t}\n-\n \t//Used to provide the Description packet\n \tpublic static FMLProxyPacket toFMLPacket(ModernPacket msg) throws Exception {\n \t\treturn PacketHandler.toFMLPacket(msg, MainProxy.networkChannelName);\n@@ -121,6 +101,44 @@ private static FMLProxyPacket toFMLPacket(ModernPacket msg, String channel) thro\n \t\treturn new FMLProxyPacket(buffer, channel);\n \t}\n \n+\t//hacky callback to process packets coming from by the packetbufferhandler decompressors\n+\t//TODO replace with proper netty implementation\n+\tpublic static void onPacketData(final LPDataInput data, final EntityPlayer player) {\n+\t\tif (player == null) {\n+\t\t\treturn;\n+\t\t}\n+\t\tfinal int packetID = data.readShort();\n+\t\tfinal ModernPacket packet = PacketHandler.packetlist.get(packetID).template();\n+\t\tpacket.setDebugId(data.readInt());\n+\t\tpacket.readData(data);\n+\t\tPacketHandler.onPacketData(packet, player);\n+\t}\n+\n+\tprivate static void onPacketData(ModernPacket packet, final EntityPlayer player) {\n+\t\ttry {\n+\t\t\tpacket.processPacket(player);\n+\t\t\tif (LPConstants.DEBUG) {\n+\t\t\t\tPacketHandler.debugMap.remove(packet.getDebugId());\n+\t\t\t}\n+\t\t} catch (DelayPacketException e) {\n+\t\t\tif (packet.retry() && MainProxy.isClient(player.getEntityWorld())) {\n+\t\t\t\tSimpleServiceLocator.clientBufferHandler.queueFailedPacket(packet, player);\n+\t\t\t} else if (LPConstants.DEBUG) {\n+\t\t\t\tLogisticsPipes.log.error(packet.getClass().getName());\n+\t\t\t\tLogisticsPipes.log.error(packet.toString());\n+\t\t\t\te.printStackTrace();\n+\t\t\t}\n+\t\t} catch (Exception e) {\n+\t\t\tthrow new RuntimeException(e);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n+\t\tsuper.handlerAdded(ctx);\n+\t\tctx.attr(PacketHandler.INBOUNDPACKETTRACKER).set(new ThreadLocal<>());\n+\t}\n+\n \t@Override\n \tprotected final void encode(ChannelHandlerContext ctx, ModernPacket msg, List<Object> out) throws Exception {\n \t\tFMLProxyPacket proxy = PacketHandler.toFMLPacket(msg, ctx.channel().attr(NetworkRegistry.FML_CHANNEL).get());\n@@ -150,35 +168,15 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws E\n \t\tsuper.exceptionCaught(ctx, cause);\n \t}\n \n-\t//hacky callback to process packets coming from by the packetbufferhandler decompressors\n-\t//TODO replace with proper netty implementation\n-\tpublic static void onPacketData(final LPDataInput data, final EntityPlayer player) throws IOException {\n-\t\tif (player == null) {\n-\t\t\treturn;\n-\t\t}\n-\t\tfinal int packetID = data.readShort();\n-\t\tfinal ModernPacket packet = PacketHandler.packetlist.get(packetID).template();\n-\t\tpacket.setDebugId(data.readInt());\n-\t\tpacket.readData(data);\n-\t\tPacketHandler.onPacketData(packet, player);\n-\t}\n+\t//horrible hack to carry the proper player for the side along...\n+\tstatic class InboundModernPacketWrapper {\n \n-\tprivate static void onPacketData(ModernPacket packet, final EntityPlayer player) {\n-\t\ttry {\n-\t\t\tpacket.processPacket(player);\n-\t\t\tif (LPConstants.DEBUG) {\n-\t\t\t\tPacketHandler.debugMap.remove(packet.getDebugId());\n-\t\t\t}\n-\t\t} catch (DelayPacketException e) {\n-\t\t\tif (packet.retry() && MainProxy.isClient(player.getEntityWorld())) {\n-\t\t\t\tSimpleServiceLocator.clientBufferHandler.queueFailedPacket(packet, player);\n-\t\t\t} else if (LPConstants.DEBUG) {\n-\t\t\t\tLogisticsPipes.log.error(packet.getClass().getName());\n-\t\t\t\tLogisticsPipes.log.error(packet.toString());\n-\t\t\t\te.printStackTrace();\n-\t\t\t}\n-\t\t} catch (Exception e) {\n-\t\t\tthrow new RuntimeException(e);\n+\t\tfinal ModernPacket packet;\n+\t\tfinal EntityPlayer player;\n+\n+\t\tInboundModernPacketWrapper(ModernPacket p, EntityPlayer e) {\n+\t\t\tpacket = p;\n+\t\t\tplayer = e;\n \t\t}\n \t}\n }",
        "function_modified_lines": {
            "added": [],
            "deleted": [
                "\t//horrible hack to carry the proper player for the side along...\n",
                "\tstatic class InboundModernPacketWrapper {\n",
                "\n",
                "\t\tfinal ModernPacket packet;\n",
                "\t\tfinal EntityPlayer player;\n",
                "\n",
                "\t\tInboundModernPacketWrapper(ModernPacket p, EntityPlayer e) {\n",
                "\t\t\tpacket = p;\n",
                "\t\t\tplayer = e;\n",
                "\t\t}\n",
                "\t}\n",
                "\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-502"
        ],
        "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
        "id": 12760
    },
    {
        "cve_id": "CVE-2023-38689",
        "code_before_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate BitSet flags;\n\n\tpublic BitSetCoordinatesPacket(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\tsuper.writeData(output);\n\t\toutput.writeBitSet(getFlags());\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tsuper.readData(input);\n\t\tsetFlags(input.readBitSet());\n\t}\n}",
        "code_after_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate BitSet flags;\n\n\tpublic BitSetCoordinatesPacket(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\tsuper.writeData(output);\n\t\toutput.writeBitSet(getFlags());\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tsuper.readData(input);\n\t\tsetFlags(input.readBitSet());\n\t}\n}",
        "patch": "@@ -1,6 +1,5 @@\n package logisticspipes.network.abstractpackets;\n \n-import java.io.IOException;\n import java.util.BitSet;\n \n import lombok.Getter;\n@@ -20,13 +19,13 @@ public BitSetCoordinatesPacket(int id) {\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\tsuper.writeData(output);\n \t\toutput.writeBitSet(getFlags());\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tsuper.readData(input);\n \t\tsetFlags(input.readBitSet());\n \t}",
        "function_modified_lines": {
            "added": [
                "\tpublic void writeData(LPDataOutput output) {\n",
                "\tpublic void readData(LPDataInput input) {\n"
            ],
            "deleted": [
                "\tpublic void writeData(LPDataOutput output) throws IOException {\n",
                "\tpublic void readData(LPDataInput input) throws IOException {\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-502"
        ],
        "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
        "id": 12770
    },
    {
        "cve_id": "CVE-2023-38689",
        "code_before_change": "{\n\n\tpublic PipeItemsBasicTransport(Item item) {\n\t\tsuper(new PipeTransportLogistics(false), item);\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {}\n\n\t@Override\n\tpublic int getIconIndex(ForgeDirection direction) {\n\t\treturn Textures.LOGISTICSPIPE_BASIC_TRANSPORT_TEXTURE.normal;\n\t}\n\n\t@Override\n\tpublic int getTextureIndex() {\n\t\treturn Textures.LOGISTICSPIPE_BASIC_TRANSPORT_TEXTURE.newTexture;\n\t}\n\n\t@Override\n\tpublic IHighlightPlacementRenderer getHighlightRenderer() {\n\t\treturn LogisticsRenderPipe.secondRenderer;\n\t}\n}",
        "code_after_change": "{\n\n\tpublic PipeItemsBasicTransport(Item item) {\n\t\tsuper(new PipeTransportLogistics(false), item);\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {}\n\n\t@Override\n\tpublic int getIconIndex(ForgeDirection direction) {\n\t\treturn Textures.LOGISTICSPIPE_BASIC_TRANSPORT_TEXTURE.normal;\n\t}\n\n\t@Override\n\tpublic int getTextureIndex() {\n\t\treturn Textures.LOGISTICSPIPE_BASIC_TRANSPORT_TEXTURE.newTexture;\n\t}\n\n\t@Override\n\tpublic IHighlightPlacementRenderer getHighlightRenderer() {\n\t\treturn LogisticsRenderPipe.secondRenderer;\n\t}\n}",
        "patch": "@@ -1,7 +1,5 @@\n package logisticspipes.pipes.unrouted;\n \n-import java.io.IOException;\n-\n import net.minecraft.item.Item;\n import net.minecraftforge.common.util.ForgeDirection;\n \n@@ -20,10 +18,10 @@ public PipeItemsBasicTransport(Item item) {\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {}\n+\tpublic void writeData(LPDataOutput output) {}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {}\n+\tpublic void readData(LPDataInput input) {}\n \n \t@Override\n \tpublic int getIconIndex(ForgeDirection direction) {",
        "function_modified_lines": {
            "added": [
                "\tpublic void writeData(LPDataOutput output) {}\n",
                "\tpublic void readData(LPDataInput input) {}\n"
            ],
            "deleted": [
                "\tpublic void writeData(LPDataOutput output) throws IOException {}\n",
                "\tpublic void readData(LPDataInput input) throws IOException {}\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-502"
        ],
        "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
        "id": 12836
    },
    {
        "cve_id": "CVE-2023-38689",
        "code_before_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate List<ItemIdentifierStack> identList;\n\n\tpublic RunningCraftingTasks(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tif (FMLClientHandler.instance().getClient().currentScreen instanceof GuiStatistics) {\n\t\t\t((GuiStatistics) FMLClientHandler.instance().getClient().currentScreen).handlePacket_2(getIdentList());\n\t\t}\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\toutput.writeCollection(identList, LPDataOutput::writeItemIdentifierStack);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tidentList = input.readArrayList(LPDataInput::readItemIdentifierStack);\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new RunningCraftingTasks(getId());\n\t}\n}",
        "code_after_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate List<ItemIdentifierStack> identList;\n\n\tpublic RunningCraftingTasks(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tif (FMLClientHandler.instance().getClient().currentScreen instanceof GuiStatistics) {\n\t\t\t((GuiStatistics) FMLClientHandler.instance().getClient().currentScreen).handlePacket_2(getIdentList());\n\t\t}\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\toutput.writeCollection(identList, LPDataOutput::writeItemIdentifierStack);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tidentList = input.readArrayList(LPDataInput::readItemIdentifierStack);\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new RunningCraftingTasks(getId());\n\t}\n}",
        "patch": "@@ -1,6 +1,5 @@\n package logisticspipes.network.packets.block;\n \n-import java.io.IOException;\n import java.util.List;\n \n import net.minecraft.entity.player.EntityPlayer;\n@@ -33,12 +32,12 @@ public void processPacket(EntityPlayer player) {\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\toutput.writeCollection(identList, LPDataOutput::writeItemIdentifierStack);\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tidentList = input.readArrayList(LPDataInput::readItemIdentifierStack);\n \t}\n ",
        "function_modified_lines": {
            "added": [
                "\tpublic void writeData(LPDataOutput output) {\n",
                "\tpublic void readData(LPDataInput input) {\n"
            ],
            "deleted": [
                "\tpublic void writeData(LPDataOutput output) throws IOException {\n",
                "\tpublic void readData(LPDataInput input) throws IOException {\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-502"
        ],
        "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
        "id": 12797
    },
    {
        "cve_id": "CVE-2023-38689",
        "code_before_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate ItemIdentifierStack stack = null;\n\n\tpublic ItemAmountSignUpdatePacket(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tLogisticsTileGenericPipe pipe = this.getPipe(player.getEntityWorld());\n\t\tif (pipe == null || !pipe.isInitialized()) {\n\t\t\treturn;\n\t\t}\n\n\t\tIPipeSign sign = ((CoreRoutedPipe) pipe.pipe).getPipeSign(ForgeDirection.getOrientation(getInteger()));\n\t\tif (sign == null) {\n\t\t\treturn;\n\t\t}\n\t\t((ItemAmountPipeSign) sign).amount = getInteger2();\n\t\t((ItemAmountPipeSign) sign).itemTypeInv.setInventorySlotContents(0, stack);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tsuper.readData(input);\n\t\tif (input.readBoolean()) {\n\t\t\tstack = input.readItemIdentifierStack();\n\t\t}\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\tsuper.writeData(output);\n\t\tif (stack == null) {\n\t\t\toutput.writeBoolean(false);\n\t\t} else {\n\t\t\toutput.writeBoolean(true);\n\t\t\toutput.writeItemIdentifierStack(stack);\n\t\t}\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new ItemAmountSignUpdatePacket(getId());\n\t}\n}",
        "code_after_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate ItemIdentifierStack stack = null;\n\n\tpublic ItemAmountSignUpdatePacket(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tLogisticsTileGenericPipe pipe = this.getPipe(player.getEntityWorld());\n\t\tif (pipe == null || !pipe.isInitialized()) {\n\t\t\treturn;\n\t\t}\n\n\t\tIPipeSign sign = ((CoreRoutedPipe) pipe.pipe).getPipeSign(ForgeDirection.getOrientation(getInteger()));\n\t\tif (sign == null) {\n\t\t\treturn;\n\t\t}\n\t\t((ItemAmountPipeSign) sign).amount = getInteger2();\n\t\t((ItemAmountPipeSign) sign).itemTypeInv.setInventorySlotContents(0, stack);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tsuper.readData(input);\n\t\tif (input.readBoolean()) {\n\t\t\tstack = input.readItemIdentifierStack();\n\t\t}\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\tsuper.writeData(output);\n\t\tif (stack == null) {\n\t\t\toutput.writeBoolean(false);\n\t\t} else {\n\t\t\toutput.writeBoolean(true);\n\t\t\toutput.writeItemIdentifierStack(stack);\n\t\t}\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new ItemAmountSignUpdatePacket(getId());\n\t}\n}",
        "patch": "@@ -1,7 +1,5 @@\n package logisticspipes.network.packets.pipe;\n \n-import java.io.IOException;\n-\n import net.minecraft.entity.player.EntityPlayer;\n import net.minecraftforge.common.util.ForgeDirection;\n \n@@ -44,15 +42,15 @@ public void processPacket(EntityPlayer player) {\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tsuper.readData(input);\n \t\tif (input.readBoolean()) {\n \t\t\tstack = input.readItemIdentifierStack();\n \t\t}\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\tsuper.writeData(output);\n \t\tif (stack == null) {\n \t\t\toutput.writeBoolean(false);",
        "function_modified_lines": {
            "added": [
                "\tpublic void readData(LPDataInput input) {\n",
                "\tpublic void writeData(LPDataOutput output) {\n"
            ],
            "deleted": [
                "\tpublic void readData(LPDataInput input) throws IOException {\n",
                "\tpublic void writeData(LPDataOutput output) throws IOException {\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-502"
        ],
        "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
        "id": 12814
    },
    {
        "cve_id": "CVE-2023-38689",
        "code_before_change": "\t\treturn (super.canPipeConnect(tile, dir) || logisitcsIsPipeConnected(tile, dir)) && !disconnectPipe(tile, dir);\n\t}\n\n\t@Override\n\tpublic final boolean isSideBlocked(ForgeDirection side, boolean ignoreSystemDisconnection) {\n\t\tif (getUpgradeManager().isSideDisconnected(side)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (container != null && side != ForgeDirection.UNKNOWN && container.tilePart.hasBlockingPluggable(side)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!stillNeedReplace) {\n\t\t\tif (getRouter().isSideDisconneceted(side) && !ignoreSystemDisconnection && !globalIgnoreConnectionDisconnection) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic void connectionUpdate() {\n\t\tif (container != null && !stillNeedReplace) {\n\t\t\tcontainer.scheduleNeighborChange();\n\t\t\tgetWorld().notifyBlockChange(getX(), getY(), getZ(), getWorld().getBlock(getX(), getY(), getZ()));\n\t\t}\n\t}\n\n\tpublic UUID getSecurityID() {\n\t\treturn getOriginalUpgradeManager().getSecurityID();\n\t}\n\n\tpublic void insetSecurityID(UUID id) {\n\t\tgetOriginalUpgradeManager().insetSecurityID(id);\n\t}\n\n\t/* Power System */\n\n\tpublic List<Pair<ILogisticsPowerProvider, List<IFilter>>> getRoutedPowerProviders() {\n\t\tif (MainProxy.isClient(getWorld())) {\n\t\t\treturn null;\n\t\t}\n\t\tif (stillNeedReplace) {\n\t\t\treturn null;\n\t\t}\n\t\treturn getRouter().getPowerProvider();\n\t}\n\n\t@Override\n\tpublic boolean useEnergy(int amount) {\n\t\treturn useEnergy(amount, null, true);\n\t}\n\n\tpublic boolean useEnergy(int amount, boolean sparkles) {\n\t\treturn useEnergy(amount, null, sparkles);\n\t}\n\n\t@Override\n\tpublic boolean canUseEnergy(int amount) {\n\t\treturn canUseEnergy(amount, null);\n\t}\n\n\t@Override\n\tpublic boolean canUseEnergy(int amount, List<Object> providersToIgnore) {\n\t\tif (MainProxy.isClient(getWorld())) {\n\t\t\treturn false;\n\t\t}\n\t\tif (Configs.LOGISTICS_POWER_USAGE_DISABLED) {\n\t\t\treturn true;\n\t\t}\n\t\tif (amount == 0) {\n\t\t\treturn true;\n\t\t}\n\t\tif (providersToIgnore != null && providersToIgnore.contains(this)) {\n\t\t\treturn false;\n\t\t}\n\t\tList<Pair<ILogisticsPowerProvider, List<IFilter>>> list = getRoutedPowerProviders();\n\t\tif (list == null) {\n\t\t\treturn false;\n\t\t}\n\t\touter:\n\t\tfor (Pair<ILogisticsPowerProvider, List<IFilter>> provider : list) {\n\t\t\tfor (IFilter filter : provider.getValue2()) {\n\t\t\t\tif (filter.blockPower()) {\n\t\t\t\t\tcontinue outer;\n\t\t\t\t}",
        "code_after_change": "\t\t\treturn false;\n\t\t}\n\t\treturn (super.canPipeConnect(tile, dir) || logisitcsIsPipeConnected(tile, dir)) && !disconnectPipe(tile, dir);\n\t}\n\n\t@Override\n\tpublic final boolean isSideBlocked(ForgeDirection side, boolean ignoreSystemDisconnection) {\n\t\tif (getUpgradeManager().isSideDisconnected(side)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (container != null && side != ForgeDirection.UNKNOWN && container.tilePart.hasBlockingPluggable(side)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!stillNeedReplace) {\n\t\t\tif (getRouter().isSideDisconneceted(side) && !ignoreSystemDisconnection && !globalIgnoreConnectionDisconnection) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic void connectionUpdate() {\n\t\tif (container != null && !stillNeedReplace) {\n\t\t\tcontainer.scheduleNeighborChange();\n\t\t\tgetWorld().notifyBlockChange(getX(), getY(), getZ(), getWorld().getBlock(getX(), getY(), getZ()));\n\t\t}\n\t}\n\n\tpublic UUID getSecurityID() {\n\t\treturn getOriginalUpgradeManager().getSecurityID();\n\t}\n\n\tpublic void insetSecurityID(UUID id) {\n\t\tgetOriginalUpgradeManager().insetSecurityID(id);\n\t}\n\n\tpublic List<Pair<ILogisticsPowerProvider, List<IFilter>>> getRoutedPowerProviders() {\n\t\tif (MainProxy.isClient(getWorld())) {\n\t\t\treturn null;\n\t\t}\n\t\tif (stillNeedReplace) {\n\t\t\treturn null;\n\t\t}\n\t\treturn getRouter().getPowerProvider();\n\t}\n\n\t/* Power System */\n\n\t@Override\n\tpublic boolean useEnergy(int amount) {\n\t\treturn useEnergy(amount, null, true);\n\t}\n\n\tpublic boolean useEnergy(int amount, boolean sparkles) {\n\t\treturn useEnergy(amount, null, sparkles);\n\t}\n\n\t@Override\n\tpublic boolean canUseEnergy(int amount) {\n\t\treturn canUseEnergy(amount, null);\n\t}\n\n\t@Override\n\tpublic boolean canUseEnergy(int amount, List<Object> providersToIgnore) {\n\t\tif (MainProxy.isClient(getWorld())) {\n\t\t\treturn false;\n\t\t}\n\t\tif (Configs.LOGISTICS_POWER_USAGE_DISABLED) {\n\t\t\treturn true;\n\t\t}\n\t\tif (amount == 0) {\n\t\t\treturn true;\n\t\t}\n\t\tif (providersToIgnore != null && providersToIgnore.contains(this)) {\n\t\t\treturn false;\n\t\t}\n\t\tList<Pair<ILogisticsPowerProvider, List<IFilter>>> list = getRoutedPowerProviders();\n\t\tif (list == null) {\n\t\t\treturn false;\n\t\t}\n\t\touter:\n\t\tfor (Pair<ILogisticsPowerProvider, List<IFilter>> provider : list) {\n\t\t\tfor (IFilter filter : provider.getValue2()) {\n\t\t\t\tif (filter.blockPower()) {",
        "patch": "@@ -7,7 +7,6 @@\n \n package logisticspipes.pipes.basic;\n \n-import java.io.IOException;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.BitSet;\n@@ -132,71 +131,49 @@\n public abstract class CoreRoutedPipe extends CoreUnroutedPipe\n \t\timplements IClientState, IRequestItems, ITrackStatistics, IWorldProvider, IWatchingHandler, IPipeServiceProvider, IQueueCCEvent, ILPPositionProvider {\n \n-\tpublic enum ItemSendMode {\n-\t\tNormal,\n-\t\tFast\n-\t}\n-\n-\tprotected boolean stillNeedReplace = true;\n-\tprivate boolean recheckConnections = false;\n-\n-\tprotected IRouter router;\n-\tprotected String routerId;\n-\tprotected Object routerIdLock = new Object();\n \tprivate static int pipecount = 0;\n-\tprotected int _delayOffset = 0;\n-\n+\tpublic final PlayerCollectionList watchers = new PlayerCollectionList();\n+\tprotected final PriorityBlockingQueue<ItemRoutingInformation> _inTransitToMe = new PriorityBlockingQueue<>(10,\n+\t\t\tnew ItemRoutingInformation.DelayComparator());\n+\tprotected final LinkedList<Triplet<IRoutedItem, ForgeDirection, ItemSendMode>> _sendQueue = new LinkedList<>();\n+\tprotected final Map<ItemIdentifier, Queue<Pair<Integer, ItemRoutingInformation>>> queuedDataForUnroutedItems = Collections.synchronizedMap(new TreeMap<>());\n \tpublic boolean _textureBufferPowered;\n-\n-\tprotected boolean _initialInit = true;\n-\n-\tprivate boolean enabled = true;\n-\tprivate boolean preventRemove = false;\n-\tprivate boolean destroyByPlayer = false;\n-\tprivate PowerSupplierHandler powerHandler = new PowerSupplierHandler(this);\n-\n \tpublic long delayTo = 0;\n \tpublic int repeatFor = 0;\n-\n-\tprotected RouteLayer _routeLayer;\n-\tprotected TransportLayer _transportLayer;\n-\tprotected final PriorityBlockingQueue<ItemRoutingInformation> _inTransitToMe = new PriorityBlockingQueue<>(10,\n-\t\t\tnew ItemRoutingInformation.DelayComparator());\n-\n-\tprotected UpgradeManager upgradeManager = new UpgradeManager(this);\n-\tprotected LogisticsItemOrderManager _orderItemManager = null;\n-\n-\t@Getter\n-\tprivate List<IOrderInfoProvider> clientSideOrderManager = new ArrayList<>();\n-\n \tpublic int stat_session_sent;\n \tpublic int stat_session_recieved;\n \tpublic int stat_session_relayed;\n-\n \tpublic long stat_lifetime_sent;\n \tpublic long stat_lifetime_recieved;\n \tpublic long stat_lifetime_relayed;\n-\n \tpublic int server_routing_table_size = 0;\n-\n-\tprotected final LinkedList<Triplet<IRoutedItem, ForgeDirection, ItemSendMode>> _sendQueue = new LinkedList<>();\n-\n-\tprotected final Map<ItemIdentifier, Queue<Pair<Integer, ItemRoutingInformation>>> queuedDataForUnroutedItems = Collections.synchronizedMap(new TreeMap<>());\n-\n-\tpublic final PlayerCollectionList watchers = new PlayerCollectionList();\n-\n+\tpublic boolean globalIgnoreConnectionDisconnection = false;\n+\tprotected boolean stillNeedReplace = true;\n+\tprotected IRouter router;\n+\tprotected String routerId;\n+\tprotected Object routerIdLock = new Object();\n+\tprotected int _delayOffset = 0;\n+\tprotected boolean _initialInit = true;\n+\tprotected RouteLayer _routeLayer;\n+\tprotected TransportLayer _transportLayer;\n+\tprotected UpgradeManager upgradeManager = new UpgradeManager(this);\n+\tprotected LogisticsItemOrderManager _orderItemManager = null;\n \tprotected List<IInventory> _cachedAdjacentInventories;\n-\n \tprotected ForgeDirection pointedDirection = ForgeDirection.UNKNOWN;\n \t//public BaseRoutingLogic logic;\n \t// from BaseRoutingLogic\n \tprotected int throttleTime = 20;\n+\tprotected IPipeSign[] signItem = new IPipeSign[6];\n+\tprivate boolean recheckConnections = false;\n+\tprivate boolean enabled = true;\n+\tprivate boolean preventRemove = false;\n+\tprivate boolean destroyByPlayer = false;\n+\tprivate PowerSupplierHandler powerHandler = new PowerSupplierHandler(this);\n+\t@Getter\n+\tprivate List<IOrderInfoProvider> clientSideOrderManager = new ArrayList<>();\n \tprivate int throttleTimeLeft = 20 + new Random().nextInt(Configs.LOGISTICS_DETECTION_FREQUENCY);\n-\n \tprivate int[] queuedParticles = new int[Particles.values().length];\n \tprivate boolean hasQueuedParticles = false;\n-\n-\tprotected IPipeSign[] signItem = new IPipeSign[6];\n \tprivate boolean isOpaqueClientSide = false;\n \n \tprivate CacheHolder cacheHolder;\n@@ -1030,8 +1007,6 @@ public final boolean canPipeConnect(TileEntity tile, ForgeDirection dir) {\n \t\treturn canPipeConnect(tile, dir, false);\n \t}\n \n-\tpublic boolean globalIgnoreConnectionDisconnection = false;\n-\n \t@Override\n \tpublic final boolean canPipeConnect(TileEntity tile, ForgeDirection dir, boolean ignoreSystemDisconnection) {\n \t\tForgeDirection side = OrientationsUtil.getOrientationOfTilewithTile(container, tile);\n@@ -1072,8 +1047,6 @@ public void insetSecurityID(UUID id) {\n \t\tgetOriginalUpgradeManager().insetSecurityID(id);\n \t}\n \n-\t/* Power System */\n-\n \tpublic List<Pair<ILogisticsPowerProvider, List<IFilter>>> getRoutedPowerProviders() {\n \t\tif (MainProxy.isClient(getWorld())) {\n \t\t\treturn null;\n@@ -1084,6 +1057,8 @@ public List<Pair<ILogisticsPowerProvider, List<IFilter>>> getRoutedPowerProvider\n \t\treturn getRouter().getPowerProvider();\n \t}\n \n+\t/* Power System */\n+\n \t@Override\n \tpublic boolean useEnergy(int amount) {\n \t\treturn useEnergy(amount, null, true);\n@@ -1378,21 +1353,21 @@ public String getRouterUUID(Double id) {\n \t\treturn router.getId().toString();\n \t}\n \n-\t@CCCommand(description = \"Sets the TurtleConnect flag for this Turtle on this LogisticsPipe\")\n+\t@CCCommand(description = \"Returns the TurtleConnect flag for this Turtle on this LogisticsPipe\")\n \t@CCDirectCall\n-\tpublic void setTurtleConnect(Boolean flag) {\n+\tpublic boolean getTurtleConnect() {\n \t\tif (container instanceof LogisticsTileGenericPipe) {\n-\t\t\tcontainer.setTurtleConnect(flag);\n+\t\t\treturn container.getTurtleConnect();\n \t\t}\n+\t\treturn false;\n \t}\n \n-\t@CCCommand(description = \"Returns the TurtleConnect flag for this Turtle on this LogisticsPipe\")\n+\t@CCCommand(description = \"Sets the TurtleConnect flag for this Turtle on this LogisticsPipe\")\n \t@CCDirectCall\n-\tpublic boolean getTurtleConnect() {\n+\tpublic void setTurtleConnect(Boolean flag) {\n \t\tif (container instanceof LogisticsTileGenericPipe) {\n-\t\t\treturn container.getTurtleConnect();\n+\t\t\tcontainer.setTurtleConnect(flag);\n \t\t}\n-\t\treturn false;\n \t}\n \n \t@CCCommand(description = \"Returns true if the computer is allowed to interact with the connected pipe.\", needPermission = false)\n@@ -1743,12 +1718,12 @@ public IPipeSign getPipeSign(ForgeDirection dir) {\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\toutput.writeBoolean(isOpaque());\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tisOpaqueClientSide = input.readBoolean();\n \t}\n \n@@ -1841,4 +1816,9 @@ public CacheHolder getCacheHolder() {\n \tpublic IHighlightPlacementRenderer getHighlightRenderer() {\n \t\treturn LogisticsRenderPipe.secondRenderer;\n \t}\n+\n+\tpublic enum ItemSendMode {\n+\t\tNormal,\n+\t\tFast\n+\t}\n }",
        "function_modified_lines": {
            "added": [
                "\t/* Power System */\n",
                "\n"
            ],
            "deleted": [
                "\t/* Power System */\n",
                "\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-502"
        ],
        "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
        "id": 12825
    },
    {
        "cve_id": "CVE-2023-38689",
        "code_before_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate int pipePosX;\n\t@Getter\n\t@Setter\n\tprivate int pipePosY;\n\t@Getter\n\t@Setter\n\tprivate int pipePosZ;\n\t@Setter\n\tprivate int inventorySlot;\n\t@Getter\n\t@Setter\n\tprivate int slot;\n\n\tpublic SlotFinderNumberPacket(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new SlotFinderNumberPacket(getId());\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic void processPacket(EntityPlayer player) {\n\t\tIInventory inv = this.getTile(player.worldObj, IInventory.class);\n\t\tif (inv instanceof ISidedInventory) {\n\t\t\tinv = new SidedInventoryMinecraftAdapter((ISidedInventory) inv, ForgeDirection.UNKNOWN, false);\n\t\t}\n\t\tIInventoryUtil util = SimpleServiceLocator.inventoryUtilFactory.getInventoryUtil(inv);\n\t\tSlot result = null;\n\t\tif (((List<Slot>) player.openContainer.inventorySlots).get(inventorySlot).slotNumber == inventorySlot) {\n\t\t\tresult = ((List<Slot>) player.openContainer.inventorySlots).get(inventorySlot);\n\t\t}\n\t\tif (result == null) {\n\t\t\tfor (Slot slotObject : (List<Slot>) player.openContainer.inventorySlots) {\n\t\t\t\tif (slotObject.slotNumber == inventorySlot) {\n\t\t\t\t\tresult = slotObject;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (result == null) {\n\t\t\tplayer.addChatComponentMessage(new ChatComponentTranslation(\"lp.chat.slotnotfound\"));\n\t\t}\n\t\tint resultIndex = -1;\n\t\tif (resultIndex == -1) {\n\t\t\tItemStack content = result.getStack();\n\t\t\tif (content != null) {\n\t\t\t\tfor (int i = 0; i < util.getSizeInventory(); i++) {\n\t\t\t\t\tif (content == util.getStackInSlot(i)) {\n\t\t\t\t\t\tresultIndex = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tItemStack dummyStack = new ItemStack(Blocks.stone, 0, 0);\n\t\t\t\tNBTTagCompound nbt = new NBTTagCompound();\n\t\t\t\tnbt.setBoolean(\"LPStackFinderBoolean\", true); //Make it unique\n\t\t\t\tdummyStack.setTagCompound(nbt);\n\t\t\t\tresult.putStack(dummyStack);\n\t\t\t\tfor (int i = 0; i < util.getSizeInventory(); i++) {\n\t\t\t\t\tif (dummyStack == util.getStackInSlot(i)) {\n\t\t\t\t\t\tresultIndex = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (resultIndex == -1) {\n\t\t\t\t\tfor (int i = 0; i < util.getSizeInventory(); i++) {\n\t\t\t\t\t\tItemStack stack = util.getStackInSlot(i);\n\t\t\t\t\t\tif (stack == null) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ItemIdentifier.get(stack).equals(ItemIdentifier.get(dummyStack)) && stack.stackSize == dummyStack.stackSize) {\n\t\t\t\t\t\t\tresultIndex = i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresult.putStack(null);\n\t\t\t}\n\t\t}\n\t\tif (resultIndex == -1) {\n\t\t\tplayer.addChatComponentMessage(new ChatComponentTranslation(\"lp.chat.slotnotfound\"));\n\t\t} else {\n\t\t\t//Copy pipe to coordinates to use the getPipe method\n\t\t\tsetPosX(getPipePosX());\n\t\t\tsetPosY(getPipePosY());\n\t\t\tsetPosZ(getPipePosZ());\n\t\t\tModuleActiveSupplier module = this.getLogisticsModule(player, ModuleActiveSupplier.class);\n\t\t\tif (module != null) {\n\t\t\t\tmodule.slotArray[slot] = resultIndex;\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\tsuper.writeData(output);\n\t\toutput.writeInt(inventorySlot);\n\t\toutput.writeInt(slot);\n\t\toutput.writeInt(pipePosX);\n\t\toutput.writeInt(pipePosY);\n\t\toutput.writeInt(pipePosZ);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tsuper.readData(input);\n\t\tinventorySlot = input.readInt();\n\t\tslot = input.readInt();\n\t\tpipePosX = input.readInt();\n\t\tpipePosY = input.readInt();\n\t\tpipePosZ = input.readInt();\n\t}\n}",
        "code_after_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate int pipePosX;\n\t@Getter\n\t@Setter\n\tprivate int pipePosY;\n\t@Getter\n\t@Setter\n\tprivate int pipePosZ;\n\t@Setter\n\tprivate int inventorySlot;\n\t@Getter\n\t@Setter\n\tprivate int slot;\n\n\tpublic SlotFinderNumberPacket(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new SlotFinderNumberPacket(getId());\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic void processPacket(EntityPlayer player) {\n\t\tIInventory inv = this.getTile(player.worldObj, IInventory.class);\n\t\tif (inv instanceof ISidedInventory) {\n\t\t\tinv = new SidedInventoryMinecraftAdapter((ISidedInventory) inv, ForgeDirection.UNKNOWN, false);\n\t\t}\n\t\tIInventoryUtil util = SimpleServiceLocator.inventoryUtilFactory.getInventoryUtil(inv);\n\t\tSlot result = null;\n\t\tif (((List<Slot>) player.openContainer.inventorySlots).get(inventorySlot).slotNumber == inventorySlot) {\n\t\t\tresult = ((List<Slot>) player.openContainer.inventorySlots).get(inventorySlot);\n\t\t}\n\t\tif (result == null) {\n\t\t\tfor (Slot slotObject : (List<Slot>) player.openContainer.inventorySlots) {\n\t\t\t\tif (slotObject.slotNumber == inventorySlot) {\n\t\t\t\t\tresult = slotObject;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (result == null) {\n\t\t\tplayer.addChatComponentMessage(new ChatComponentTranslation(\"lp.chat.slotnotfound\"));\n\t\t}\n\t\tint resultIndex = -1;\n\t\tif (resultIndex == -1) {\n\t\t\tItemStack content = result.getStack();\n\t\t\tif (content != null) {\n\t\t\t\tfor (int i = 0; i < util.getSizeInventory(); i++) {\n\t\t\t\t\tif (content == util.getStackInSlot(i)) {\n\t\t\t\t\t\tresultIndex = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tItemStack dummyStack = new ItemStack(Blocks.stone, 0, 0);\n\t\t\t\tNBTTagCompound nbt = new NBTTagCompound();\n\t\t\t\tnbt.setBoolean(\"LPStackFinderBoolean\", true); //Make it unique\n\t\t\t\tdummyStack.setTagCompound(nbt);\n\t\t\t\tresult.putStack(dummyStack);\n\t\t\t\tfor (int i = 0; i < util.getSizeInventory(); i++) {\n\t\t\t\t\tif (dummyStack == util.getStackInSlot(i)) {\n\t\t\t\t\t\tresultIndex = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (resultIndex == -1) {\n\t\t\t\t\tfor (int i = 0; i < util.getSizeInventory(); i++) {\n\t\t\t\t\t\tItemStack stack = util.getStackInSlot(i);\n\t\t\t\t\t\tif (stack == null) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ItemIdentifier.get(stack).equals(ItemIdentifier.get(dummyStack)) && stack.stackSize == dummyStack.stackSize) {\n\t\t\t\t\t\t\tresultIndex = i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresult.putStack(null);\n\t\t\t}\n\t\t}\n\t\tif (resultIndex == -1) {\n\t\t\tplayer.addChatComponentMessage(new ChatComponentTranslation(\"lp.chat.slotnotfound\"));\n\t\t} else {\n\t\t\t//Copy pipe to coordinates to use the getPipe method\n\t\t\tsetPosX(getPipePosX());\n\t\t\tsetPosY(getPipePosY());\n\t\t\tsetPosZ(getPipePosZ());\n\t\t\tModuleActiveSupplier module = this.getLogisticsModule(player, ModuleActiveSupplier.class);\n\t\t\tif (module != null) {\n\t\t\t\tmodule.slotArray[slot] = resultIndex;\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\tsuper.writeData(output);\n\t\toutput.writeInt(inventorySlot);\n\t\toutput.writeInt(slot);\n\t\toutput.writeInt(pipePosX);\n\t\toutput.writeInt(pipePosY);\n\t\toutput.writeInt(pipePosZ);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tsuper.readData(input);\n\t\tinventorySlot = input.readInt();\n\t\tslot = input.readInt();\n\t\tpipePosX = input.readInt();\n\t\tpipePosY = input.readInt();\n\t\tpipePosZ = input.readInt();\n\t}\n}",
        "patch": "@@ -1,6 +1,5 @@\n package logisticspipes.network.packets.pipe;\n \n-import java.io.IOException;\n import java.util.List;\n \n import net.minecraft.entity.player.EntityPlayer;\n@@ -127,7 +126,7 @@ public void processPacket(EntityPlayer player) {\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\tsuper.writeData(output);\n \t\toutput.writeInt(inventorySlot);\n \t\toutput.writeInt(slot);\n@@ -137,7 +136,7 @@ public void writeData(LPDataOutput output) throws IOException {\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tsuper.readData(input);\n \t\tinventorySlot = input.readInt();\n \t\tslot = input.readInt();",
        "function_modified_lines": {
            "added": [
                "\tpublic void writeData(LPDataOutput output) {\n",
                "\tpublic void readData(LPDataInput input) {\n"
            ],
            "deleted": [
                "\tpublic void writeData(LPDataOutput output) throws IOException {\n",
                "\tpublic void readData(LPDataInput input) throws IOException {\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-502"
        ],
        "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
        "id": 12820
    },
    {
        "cve_id": "CVE-2023-38689",
        "code_before_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate byte[] payload;\n\n\t@Getter\n\t@Setter\n\tprivate int identifier;\n\n\tpublic DebugDataPacket(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tpayload = input.readByteArray();\n\t\tidentifier = input.readInt();\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tDebugGuiController.instance().handleDataPacket(payload, identifier, player);\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\toutput.writeByteArray(payload);\n\t\toutput.writeInt(identifier);\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new DebugDataPacket(getId());\n\t}\n}",
        "code_after_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate byte[] payload;\n\n\t@Getter\n\t@Setter\n\tprivate int identifier;\n\n\tpublic DebugDataPacket(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tpayload = input.readByteArray();\n\t\tidentifier = input.readInt();\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tDebugGuiController.instance().handleDataPacket(payload, identifier, player);\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\toutput.writeByteArray(payload);\n\t\toutput.writeInt(identifier);\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new DebugDataPacket(getId());\n\t}\n}",
        "patch": "@@ -1,7 +1,5 @@\n package logisticspipes.network.packets.debuggui;\n \n-import java.io.IOException;\n-\n import net.minecraft.entity.player.EntityPlayer;\n \n import lombok.Getter;\n@@ -27,7 +25,7 @@ public DebugDataPacket(int id) {\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tpayload = input.readByteArray();\n \t\tidentifier = input.readInt();\n \t}\n@@ -38,7 +36,7 @@ public void processPacket(EntityPlayer player) {\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\toutput.writeByteArray(payload);\n \t\toutput.writeInt(identifier);\n \t}",
        "function_modified_lines": {
            "added": [
                "\tpublic void readData(LPDataInput input) {\n",
                "\tpublic void writeData(LPDataOutput output) {\n"
            ],
            "deleted": [
                "\tpublic void readData(LPDataInput input) throws IOException {\n",
                "\tpublic void writeData(LPDataOutput output) throws IOException {\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-502"
        ],
        "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
        "id": 12804
    },
    {
        "cve_id": "CVE-2023-38689",
        "code_before_change": "{\n\n\tpublic PipeContentPacket(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Getter\n\t@Setter\n\tprivate ItemIdentifierStack item;\n\t@Getter\n\t@Setter\n\tprivate int travelId;\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\titem = input.readItemIdentifierStack();\n\t\ttravelId = input.readInt();\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tWeakReference<LPTravelingItemClient> ref = LPTravelingItem.clientList.get(travelId);\n\t\tLPTravelingItemClient content = null;\n\t\tif (ref != null) {\n\t\t\tcontent = ref.get();\n\t\t}\n\t\tif (content == null) {\n\t\t\tcontent = new LPTravelingItemClient(travelId, item);\n\t\t\tLPTravelingItem.clientList.put(travelId, new WeakReference<>(content));\n\t\t\tsynchronized (LPTravelingItem.forceKeep) {\n\t\t\t\tLPTravelingItem.forceKeep.add(new Pair<>(10, content)); //Keep in memory for min 10 ticks\n\t\t\t}\n\t\t} else {\n\t\t\tcontent.setItem(item);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\toutput.writeItemIdentifierStack(item);\n\t\toutput.writeInt(travelId);\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new PipeContentPacket(getId());\n\t}\n}",
        "code_after_change": "public class PipeContentPacket extends ModernPacket {\n\n\t@Getter\n\t@Setter\n\tprivate ItemIdentifierStack item;\n\t@Getter\n\t@Setter\n\tprivate int travelId;\n\n\tpublic PipeContentPacket(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\titem = input.readItemIdentifierStack();\n\t\ttravelId = input.readInt();\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tWeakReference<LPTravelingItemClient> ref = LPTravelingItem.clientList.get(travelId);\n\t\tLPTravelingItemClient content = null;\n\t\tif (ref != null) {\n\t\t\tcontent = ref.get();\n\t\t}\n\t\tif (content == null) {\n\t\t\tcontent = new LPTravelingItemClient(travelId, item);\n\t\t\tLPTravelingItem.clientList.put(travelId, new WeakReference<>(content));\n\t\t\tsynchronized (LPTravelingItem.forceKeep) {\n\t\t\t\tLPTravelingItem.forceKeep.add(new Pair<>(10, content)); //Keep in memory for min 10 ticks\n\t\t\t}\n\t\t} else {\n\t\t\tcontent.setItem(item);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\toutput.writeItemIdentifierStack(item);\n\t\toutput.writeInt(travelId);\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new PipeContentPacket(getId());\n\t}\n}",
        "patch": "@@ -1,6 +1,5 @@\n package logisticspipes.network.packets.pipe;\n \n-import java.io.IOException;\n import java.lang.ref.WeakReference;\n \n import net.minecraft.entity.player.EntityPlayer;\n@@ -18,19 +17,19 @@\n \n public class PipeContentPacket extends ModernPacket {\n \n-\tpublic PipeContentPacket(int id) {\n-\t\tsuper(id);\n-\t}\n-\n \t@Getter\n \t@Setter\n \tprivate ItemIdentifierStack item;\n \t@Getter\n \t@Setter\n \tprivate int travelId;\n \n+\tpublic PipeContentPacket(int id) {\n+\t\tsuper(id);\n+\t}\n+\n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\titem = input.readItemIdentifierStack();\n \t\ttravelId = input.readInt();\n \t}\n@@ -54,7 +53,7 @@ public void processPacket(EntityPlayer player) {\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\toutput.writeItemIdentifierStack(item);\n \t\toutput.writeInt(travelId);\n \t}",
        "function_modified_lines": {
            "added": [
                "\tpublic PipeContentPacket(int id) {\n",
                "\t\tsuper(id);\n",
                "\t}\n",
                "\n",
                "\tpublic void readData(LPDataInput input) {\n"
            ],
            "deleted": [
                "\tpublic PipeContentPacket(int id) {\n",
                "\t\tsuper(id);\n",
                "\t}\n",
                "\n",
                "\tpublic void readData(LPDataInput input) throws IOException {\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-502"
        ],
        "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
        "id": 12817
    },
    {
        "cve_id": "CVE-2023-38689",
        "code_before_change": "{\n\n\tpublic OpenChatGui(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {}\n\n\t@Override\n\t@ClientSideOnlyMethodContent\n\tpublic void processPacket(EntityPlayer player) {\n\t\tFMLClientHandler.instance().getClient().displayGuiScreen(new GuiChat());\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new OpenChatGui(getId());\n\t}\n}",
        "code_after_change": "{\n\n\tpublic OpenChatGui(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {}\n\n\t@Override\n\t@ClientSideOnlyMethodContent\n\tpublic void processPacket(EntityPlayer player) {\n\t\tFMLClientHandler.instance().getClient().displayGuiScreen(new GuiChat());\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new OpenChatGui(getId());\n\t}\n}",
        "patch": "@@ -1,7 +1,5 @@\n package logisticspipes.network.packets.gui;\n \n-import java.io.IOException;\n-\n import net.minecraft.client.gui.GuiChat;\n import net.minecraft.entity.player.EntityPlayer;\n import cpw.mods.fml.client.FMLClientHandler;\n@@ -18,7 +16,7 @@ public OpenChatGui(int id) {\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {}\n+\tpublic void readData(LPDataInput input) {}\n \n \t@Override\n \t@ClientSideOnlyMethodContent\n@@ -27,7 +25,7 @@ public void processPacket(EntityPlayer player) {\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {}\n+\tpublic void writeData(LPDataOutput output) {}\n \n \t@Override\n \tpublic ModernPacket template() {",
        "function_modified_lines": {
            "added": [
                "\tpublic void readData(LPDataInput input) {}\n",
                "\tpublic void writeData(LPDataOutput output) {}\n"
            ],
            "deleted": [
                "\tpublic void readData(LPDataInput input) throws IOException {}\n",
                "\tpublic void writeData(LPDataOutput output) throws IOException {}\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-502"
        ],
        "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
        "id": 12809
    },
    {
        "cve_id": "CVE-2023-38689",
        "code_before_change": "package logisticspipes.network.abstractguis;\n\nimport java.io.IOException;\n\nimport lombok.Getter;\nimport lombok.Setter;\n\nimport network.rs485.logisticspipes.util.LPDataInput;\nimport network.rs485.logisticspipes.util.LPDataOutput;\n\npublic abstract class BooleanModuleCoordinatesGuiProvider extends ModuleCoordinatesGuiProvider {\n\n\tpublic BooleanModuleCoordinatesGuiProvider(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Getter\n\t@Setter\n\tprivate boolean flag;\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\tsuper.writeData(output);\n\t\toutput.writeBoolean(flag);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tsuper.readData(input);\n\t\tflag = input.readBoolean();\n\t}\n}\n",
        "code_after_change": "package logisticspipes.network.abstractguis;\n\nimport lombok.Getter;\nimport lombok.Setter;\n\nimport network.rs485.logisticspipes.util.LPDataInput;\nimport network.rs485.logisticspipes.util.LPDataOutput;\n\npublic abstract class BooleanModuleCoordinatesGuiProvider extends ModuleCoordinatesGuiProvider {\n\n\t@Getter\n\t@Setter\n\tprivate boolean flag;\n\n\tpublic BooleanModuleCoordinatesGuiProvider(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\tsuper.writeData(output);\n\t\toutput.writeBoolean(flag);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tsuper.readData(input);\n\t\tflag = input.readBoolean();\n\t}\n}\n",
        "patch": "@@ -1,7 +1,5 @@\n package logisticspipes.network.abstractguis;\n \n-import java.io.IOException;\n-\n import lombok.Getter;\n import lombok.Setter;\n \n@@ -10,22 +8,22 @@\n \n public abstract class BooleanModuleCoordinatesGuiProvider extends ModuleCoordinatesGuiProvider {\n \n-\tpublic BooleanModuleCoordinatesGuiProvider(int id) {\n-\t\tsuper(id);\n-\t}\n-\n \t@Getter\n \t@Setter\n \tprivate boolean flag;\n \n+\tpublic BooleanModuleCoordinatesGuiProvider(int id) {\n+\t\tsuper(id);\n+\t}\n+\n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\tsuper.writeData(output);\n \t\toutput.writeBoolean(flag);\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tsuper.readData(input);\n \t\tflag = input.readBoolean();\n \t}",
        "function_modified_lines": {
            "added": [
                "\tpublic BooleanModuleCoordinatesGuiProvider(int id) {\n",
                "\t\tsuper(id);\n",
                "\t}\n",
                "\n",
                "\tpublic void writeData(LPDataOutput output) {\n",
                "\tpublic void readData(LPDataInput input) {\n"
            ],
            "deleted": [
                "import java.io.IOException;\n",
                "\n",
                "\tpublic BooleanModuleCoordinatesGuiProvider(int id) {\n",
                "\t\tsuper(id);\n",
                "\t}\n",
                "\n",
                "\tpublic void writeData(LPDataOutput output) throws IOException {\n",
                "\tpublic void readData(LPDataInput input) throws IOException {\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-502"
        ],
        "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
        "id": 12762
    },
    {
        "cve_id": "CVE-2023-38689",
        "code_before_change": "{\n\n\t@AllArgsConstructor\n\tpublic enum SpeedupDirection implements ITubeRenderOrientation, ITubeOrientation {\n\t\t//@formatter:off\n\t\tNORTH(ForgeDirection.NORTH),\n\t\tSOUTH(ForgeDirection.SOUTH),\n\t\tEAST(ForgeDirection.EAST),\n\t\tWEST(ForgeDirection.WEST);\n\t\t//@formatter:on\n\t\t@Getter\n\t\tForgeDirection dir1;\n\n\t\t@Override\n\t\tpublic void rotatePositions(IPositionRotateble set) {\n\t\t\tif (this == SOUTH) {\n\t\t\t\tset.rotateLeft();\n\t\t\t\tset.rotateLeft();\n\t\t\t} else if (this == EAST) {\n\t\t\t\tset.rotateRight();\n\t\t\t} else if (this == WEST) {\n\t\t\t\tset.rotateLeft();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic ITubeRenderOrientation getRenderOrientation() {\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic DoubleCoordinates getOffset() {\n\t\t\treturn new DoubleCoordinates(0, 0, 0);\n\t\t}\n\n\t\t@Override\n\t\tpublic void setOnPipe(CoreMultiBlockPipe pipe) {\n\t\t\t((HSTubeSpeedup) pipe).orientation = this;\n\t\t}\n\t}\n\n\t@Getter\n\tprivate SpeedupDirection orientation;\n\n\tpublic HSTubeSpeedup(Item item) {\n\t\tsuper(new PipeMultiBlockTransportLogistics() {\n\n\t\t\t@Override\n\t\t\tpublic boolean canPipeConnect(TileEntity tile, ForgeDirection side) {\n\t\t\t\tif (side.getOpposite() == ((HSTubeSpeedup) getMultiPipe()).orientation.dir1) {\n\t\t\t\t\treturn super.canPipeConnect_internal(tile, side);\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected void handleTileReachedServer(LPTravelingItemServer arrivingItem, TileEntity tile, ForgeDirection dir) {\n\t\t\t\tif (dir.getOpposite() == ((HSTubeSpeedup) getMultiPipe()).orientation.dir1) {\n\t\t\t\t\tarrivingItem.setSpeed(LPConstants.PIPE_NORMAL_SPEED * 20);\n\t\t\t\t\thandleTileReachedServer_internal(arrivingItem, tile, dir);\n\t\t\t\t} else {\n\t\t\t\t\tsuper.handleTileReachedServer(arrivingItem, tile, dir);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected void handleTileReachedClient(LPTravelingItemClient arrivingItem, TileEntity tile, ForgeDirection dir) {\n\t\t\t\tif (dir.getOpposite() == ((HSTubeSpeedup) getMultiPipe()).orientation.dir1) {\n\t\t\t\t\tif (SimpleServiceLocator.pipeInformationManager.isItemPipe(tile)) {\n\t\t\t\t\t\tarrivingItem.setSpeed(LPConstants.PIPE_NORMAL_SPEED * 20);\n\t\t\t\t\t\tpassToNextPipe(arrivingItem, tile);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tsuper.handleTileReachedClient(arrivingItem, tile, dir);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}, item);\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\toutput.writeEnum(orientation);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\torientation = input.readEnum(SpeedupDirection.class);\n\t}\n\n\t@Override\n\tpublic LPPositionSet<DoubleCoordinatesType<SubBlockTypeForShare>> getSubBlocks() {\n\t\tLPPositionSet<DoubleCoordinatesType<SubBlockTypeForShare>> set = new LPPositionSet<>(DoubleCoordinatesType.class);\n\t\tset.add(new DoubleCoordinatesType<>(0, 0, -1, SubBlockTypeForShare.NON_SHARE));\n\t\tset.add(new DoubleCoordinatesType<>(0, 0, -2, SubBlockTypeForShare.NON_SHARE));\n\t\tset.add(new DoubleCoordinatesType<>(0, 0, -3, SubBlockTypeForShare.NON_SHARE));\n\t\treturn set;\n\t}\n\n\t@Override\n\tpublic LPPositionSet<DoubleCoordinatesType<SubBlockTypeForShare>> getRotatedSubBlocks() {\n\t\tLPPositionSet<DoubleCoordinatesType<SubBlockTypeForShare>> set = getSubBlocks();\n\t\torientation.rotatePositions(set);\n\t\treturn set;\n\t}\n\n\t@Override\n\tpublic void addCollisionBoxesToList(List arraylist, AxisAlignedBB axisalignedbb) {\n\t\tDoubleCoordinates pos = getLPPosition();\n\t\tDoubleCoordinates posMin = new DoubleCoordinates(LPConstants.PIPE_MIN_POS, LPConstants.PIPE_MIN_POS, LPConstants.PIPE_MIN_POS);\n\t\tDoubleCoordinates posMax = new DoubleCoordinates(LPConstants.PIPE_MAX_POS, LPConstants.PIPE_MAX_POS, -3);\n\t\torientation.rotatePositions(posMin);\n\t\torientation.rotatePositions(posMax);\n\t\tif (orientation == SpeedupDirection.EAST) {\n\t\t\tpos.add(new DoubleCoordinates(1, 0, 0));\n\t\t} else if (orientation == SpeedupDirection.SOUTH) {\n\t\t\tpos.add(new DoubleCoordinates(1, 0, 1));\n\t\t} else if (orientation == SpeedupDirection.WEST) {\n\t\t\tpos.add(new DoubleCoordinates(0, 0, 1));\n\t\t}\n\t\tposMin.add(pos);\n\t\tposMax.add(pos);\n\t\tLPPositionSet<DoubleCoordinates> set = new LPPositionSet<>(DoubleCoordinates.class);\n\t\tset.add(posMin);\n\t\tset.add(posMax);\n\t\tAxisAlignedBB box = set.toABB();\n\t\tif (box != null && (axisalignedbb == null || axisalignedbb.intersectsWith(box))) {\n\t\t\tarraylist.add(box);\n\t\t}\n\t}\n\n\t@Override\n\tpublic AxisAlignedBB getCompleteBox() {\n\t\treturn SpeedupTubeRenderer.tubeSpeedup.get(orientation).bounds().toAABB();\n\t}\n\n\t@Override\n\tpublic ITubeOrientation getTubeOrientation(EntityPlayer player, int xPos, int zPos) {\n\t\tdouble x = xPos + 0.5 - player.posX;\n\t\tdouble z = zPos + 0.5 - player.posZ;\n\t\tdouble w = Math.atan2(x, z);\n\t\tdouble halfPI = Math.PI / 2;\n\t\tdouble halfhalfPI = halfPI / 2;\n\t\tw -= halfhalfPI;\n\t\tif (w < 0) {\n\t\t\tw += 2 * Math.PI;\n\t\t}\n\t\tForgeDirection dir = ForgeDirection.UNKNOWN;\n\t\tif (0 < w && w <= halfPI) {\n\t\t\tdir = ForgeDirection.WEST;\n\t\t} else if (halfPI < w && w <= 2 * halfPI) {\n\t\t\tdir = ForgeDirection.SOUTH;\n\t\t} else if (2 * halfPI < w && w <= 3 * halfPI) {\n\t\t\tdir = ForgeDirection.EAST;\n\t\t} else if (3 * halfPI < w && w <= 4 * halfPI) {\n\t\t\tdir = ForgeDirection.NORTH;\n\t\t}\n\t\tfor (SpeedupDirection ori : SpeedupDirection.values()) {\n\t\t\tif (ori.dir1.getOpposite().equals(dir)) {\n\t\t\t\treturn ori;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic void writeToNBT(NBTTagCompound data) {\n\t\tsuper.writeToNBT(data);\n\t\tdata.setString(\"orientation\", orientation.name());\n\t}\n\n\t@Override\n\tpublic void readFromNBT(NBTTagCompound data) {\n\t\tsuper.readFromNBT(data);\n\t\torientation = SpeedupDirection.valueOf(data.getString(\"orientation\"));\n\t}\n\n\t@Override\n\tpublic float getPipeLength() {\n\t\treturn 4;\n\t}\n\n\t@Override\n\tpublic ForgeDirection getExitForInput(ForgeDirection commingFrom) {\n\t\treturn commingFrom.getOpposite();\n\t}\n\n\t@Override\n\tpublic TileEntity getConnectedEndTile(ForgeDirection output) {\n\t\tif (orientation.dir1 == output) {\n\t\t\tDoubleCoordinates pos = new DoubleCoordinates(0, 0, -3);\n\t\t\tLPPositionSet<DoubleCoordinates> set = new LPPositionSet<>(DoubleCoordinates.class);\n\t\t\tset.add(pos);\n\t\t\torientation.rotatePositions(set);\n\t\t\tTileEntity subTile = pos.add(getLPPosition()).getTileEntity(getWorld());\n\t\t\tif (subTile instanceof LogisticsTileGenericSubMultiBlock) {\n\t\t\t\treturn ((LogisticsTileGenericSubMultiBlock) subTile).getTile(output);\n\t\t\t}\n\t\t} else if (orientation.dir1.getOpposite() == output) {\n\t\t\treturn container.getTile(output);\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic boolean actAsNormalPipe() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic ISpecialPipeRenderer getSpecialRenderer() {\n\t\treturn SpeedupTubeRenderer.instance;\n\t}\n\n\t@Override\n\tpublic IHighlightPlacementRenderer getHighlightRenderer() {\n\t\treturn SpeedupTubeRenderer.instance;\n\t}\n\n\t@Override\n\tpublic int getIconIndex(ForgeDirection direction) {\n\t\t// TODO Auto-generated method stub\n\t\treturn 0;\n\t}\n\n\t@Override\n\tpublic int getTextureIndex() {\n\t\t// TODO Auto-generated method stub\n\t\treturn 0;\n\t}\n\n\t@Override\n\tpublic boolean hasSpecialPipeEndAt(ForgeDirection dir) {\n\t\treturn dir == orientation.dir1;\n\t}\n\n\t@Override\n\tpublic DoubleCoordinates getItemRenderPos(float fPos, LPTravelingItem travelItem) {\n\t\tDoubleCoordinates pos = new DoubleCoordinates(0.5D, 0.5D, 0.5D);\n\t\tfloat pPos = fPos;\n\t\tif (travelItem.input.getOpposite() == orientation.dir1) {\n\t\t\tCoordinateUtils.add(pos, orientation.dir1, 3);\n\t\t\tpPos = this.getPipeLength() - fPos;\n\t\t}\n\t\tif (pPos < 0.5) {\n\t\t\tif (travelItem.input == ForgeDirection.UNKNOWN) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (!container.renderState.pipeConnectionMatrix.isConnected(travelItem.input.getOpposite())) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tCoordinateUtils.add(pos, travelItem.input.getOpposite(), 0.5 - fPos);\n\t\t} else {\n\t\t\tif (travelItem.output == ForgeDirection.UNKNOWN) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tCoordinateUtils.add(pos, travelItem.output, fPos - 0.5);\n\t\t}\n\t\treturn pos;\n\t}\n\n\t@Override\n\tpublic boolean canPipeConnect(TileEntity tile, ForgeDirection side) {\n\t\tif (tile instanceof LogisticsTileGenericSubMultiBlock) {\n\t\t\tif (this.getOrientation().getDir1() != side) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn super.canPipeConnect(tile, side);\n\t}\n\n\t@Override\n\tpublic boolean isHSTube() {\n\t\treturn true;\n\t}\n}",
        "code_after_change": "public class HSTubeSpeedup extends CoreMultiBlockPipe {\n\n\t@Getter\n\tprivate SpeedupDirection orientation;\n\n\tpublic HSTubeSpeedup(Item item) {\n\t\tsuper(new PipeMultiBlockTransportLogistics() {\n\n\t\t\t@Override\n\t\t\tpublic boolean canPipeConnect(TileEntity tile, ForgeDirection side) {\n\t\t\t\tif (side.getOpposite() == ((HSTubeSpeedup) getMultiPipe()).orientation.dir1) {\n\t\t\t\t\treturn super.canPipeConnect_internal(tile, side);\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected void handleTileReachedServer(LPTravelingItemServer arrivingItem, TileEntity tile, ForgeDirection dir) {\n\t\t\t\tif (dir.getOpposite() == ((HSTubeSpeedup) getMultiPipe()).orientation.dir1) {\n\t\t\t\t\tarrivingItem.setSpeed(LPConstants.PIPE_NORMAL_SPEED * 20);\n\t\t\t\t\thandleTileReachedServer_internal(arrivingItem, tile, dir);\n\t\t\t\t} else {\n\t\t\t\t\tsuper.handleTileReachedServer(arrivingItem, tile, dir);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected void handleTileReachedClient(LPTravelingItemClient arrivingItem, TileEntity tile, ForgeDirection dir) {\n\t\t\t\tif (dir.getOpposite() == ((HSTubeSpeedup) getMultiPipe()).orientation.dir1) {\n\t\t\t\t\tif (SimpleServiceLocator.pipeInformationManager.isItemPipe(tile)) {\n\t\t\t\t\t\tarrivingItem.setSpeed(LPConstants.PIPE_NORMAL_SPEED * 20);\n\t\t\t\t\t\tpassToNextPipe(arrivingItem, tile);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tsuper.handleTileReachedClient(arrivingItem, tile, dir);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}, item);\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\toutput.writeEnum(orientation);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\torientation = input.readEnum(SpeedupDirection.class);\n\t}\n\n\t@Override\n\tpublic LPPositionSet<DoubleCoordinatesType<SubBlockTypeForShare>> getSubBlocks() {\n\t\tLPPositionSet<DoubleCoordinatesType<SubBlockTypeForShare>> set = new LPPositionSet<>(DoubleCoordinatesType.class);\n\t\tset.add(new DoubleCoordinatesType<>(0, 0, -1, SubBlockTypeForShare.NON_SHARE));\n\t\tset.add(new DoubleCoordinatesType<>(0, 0, -2, SubBlockTypeForShare.NON_SHARE));\n\t\tset.add(new DoubleCoordinatesType<>(0, 0, -3, SubBlockTypeForShare.NON_SHARE));\n\t\treturn set;\n\t}\n\n\t@Override\n\tpublic LPPositionSet<DoubleCoordinatesType<SubBlockTypeForShare>> getRotatedSubBlocks() {\n\t\tLPPositionSet<DoubleCoordinatesType<SubBlockTypeForShare>> set = getSubBlocks();\n\t\torientation.rotatePositions(set);\n\t\treturn set;\n\t}\n\n\t@Override\n\tpublic void addCollisionBoxesToList(List arraylist, AxisAlignedBB axisalignedbb) {\n\t\tDoubleCoordinates pos = getLPPosition();\n\t\tDoubleCoordinates posMin = new DoubleCoordinates(LPConstants.PIPE_MIN_POS, LPConstants.PIPE_MIN_POS, LPConstants.PIPE_MIN_POS);\n\t\tDoubleCoordinates posMax = new DoubleCoordinates(LPConstants.PIPE_MAX_POS, LPConstants.PIPE_MAX_POS, -3);\n\t\torientation.rotatePositions(posMin);\n\t\torientation.rotatePositions(posMax);\n\t\tif (orientation == SpeedupDirection.EAST) {\n\t\t\tpos.add(new DoubleCoordinates(1, 0, 0));\n\t\t} else if (orientation == SpeedupDirection.SOUTH) {\n\t\t\tpos.add(new DoubleCoordinates(1, 0, 1));\n\t\t} else if (orientation == SpeedupDirection.WEST) {\n\t\t\tpos.add(new DoubleCoordinates(0, 0, 1));\n\t\t}\n\t\tposMin.add(pos);\n\t\tposMax.add(pos);\n\t\tLPPositionSet<DoubleCoordinates> set = new LPPositionSet<>(DoubleCoordinates.class);\n\t\tset.add(posMin);\n\t\tset.add(posMax);\n\t\tAxisAlignedBB box = set.toABB();\n\t\tif (box != null && (axisalignedbb == null || axisalignedbb.intersectsWith(box))) {\n\t\t\tarraylist.add(box);\n\t\t}\n\t}\n\n\t@Override\n\tpublic AxisAlignedBB getCompleteBox() {\n\t\treturn SpeedupTubeRenderer.tubeSpeedup.get(orientation).bounds().toAABB();\n\t}\n\n\t@Override\n\tpublic ITubeOrientation getTubeOrientation(EntityPlayer player, int xPos, int zPos) {\n\t\tdouble x = xPos + 0.5 - player.posX;\n\t\tdouble z = zPos + 0.5 - player.posZ;\n\t\tdouble w = Math.atan2(x, z);\n\t\tdouble halfPI = Math.PI / 2;\n\t\tdouble halfhalfPI = halfPI / 2;\n\t\tw -= halfhalfPI;\n\t\tif (w < 0) {\n\t\t\tw += 2 * Math.PI;\n\t\t}\n\t\tForgeDirection dir = ForgeDirection.UNKNOWN;\n\t\tif (0 < w && w <= halfPI) {\n\t\t\tdir = ForgeDirection.WEST;\n\t\t} else if (halfPI < w && w <= 2 * halfPI) {\n\t\t\tdir = ForgeDirection.SOUTH;\n\t\t} else if (2 * halfPI < w && w <= 3 * halfPI) {\n\t\t\tdir = ForgeDirection.EAST;\n\t\t} else if (3 * halfPI < w && w <= 4 * halfPI) {\n\t\t\tdir = ForgeDirection.NORTH;\n\t\t}\n\t\tfor (SpeedupDirection ori : SpeedupDirection.values()) {\n\t\t\tif (ori.dir1.getOpposite().equals(dir)) {\n\t\t\t\treturn ori;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic void writeToNBT(NBTTagCompound data) {\n\t\tsuper.writeToNBT(data);\n\t\tdata.setString(\"orientation\", orientation.name());\n\t}\n\n\t@Override\n\tpublic void readFromNBT(NBTTagCompound data) {\n\t\tsuper.readFromNBT(data);\n\t\torientation = SpeedupDirection.valueOf(data.getString(\"orientation\"));\n\t}\n\n\t@Override\n\tpublic float getPipeLength() {\n\t\treturn 4;\n\t}\n\n\t@Override\n\tpublic ForgeDirection getExitForInput(ForgeDirection commingFrom) {\n\t\treturn commingFrom.getOpposite();\n\t}\n\n\t@Override\n\tpublic TileEntity getConnectedEndTile(ForgeDirection output) {\n\t\tif (orientation.dir1 == output) {\n\t\t\tDoubleCoordinates pos = new DoubleCoordinates(0, 0, -3);\n\t\t\tLPPositionSet<DoubleCoordinates> set = new LPPositionSet<>(DoubleCoordinates.class);\n\t\t\tset.add(pos);\n\t\t\torientation.rotatePositions(set);\n\t\t\tTileEntity subTile = pos.add(getLPPosition()).getTileEntity(getWorld());\n\t\t\tif (subTile instanceof LogisticsTileGenericSubMultiBlock) {\n\t\t\t\treturn ((LogisticsTileGenericSubMultiBlock) subTile).getTile(output);\n\t\t\t}\n\t\t} else if (orientation.dir1.getOpposite() == output) {\n\t\t\treturn container.getTile(output);\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic boolean actAsNormalPipe() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic ISpecialPipeRenderer getSpecialRenderer() {\n\t\treturn SpeedupTubeRenderer.instance;\n\t}\n\n\t@Override\n\tpublic IHighlightPlacementRenderer getHighlightRenderer() {\n\t\treturn SpeedupTubeRenderer.instance;\n\t}\n\n\t@Override\n\tpublic int getIconIndex(ForgeDirection direction) {\n\t\t// TODO Auto-generated method stub\n\t\treturn 0;\n\t}\n\n\t@Override\n\tpublic int getTextureIndex() {\n\t\t// TODO Auto-generated method stub\n\t\treturn 0;\n\t}\n\n\t@Override\n\tpublic boolean hasSpecialPipeEndAt(ForgeDirection dir) {\n\t\treturn dir == orientation.dir1;\n\t}\n\n\t@Override\n\tpublic DoubleCoordinates getItemRenderPos(float fPos, LPTravelingItem travelItem) {\n\t\tDoubleCoordinates pos = new DoubleCoordinates(0.5D, 0.5D, 0.5D);\n\t\tfloat pPos = fPos;\n\t\tif (travelItem.input.getOpposite() == orientation.dir1) {\n\t\t\tCoordinateUtils.add(pos, orientation.dir1, 3);\n\t\t\tpPos = this.getPipeLength() - fPos;\n\t\t}\n\t\tif (pPos < 0.5) {\n\t\t\tif (travelItem.input == ForgeDirection.UNKNOWN) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (!container.renderState.pipeConnectionMatrix.isConnected(travelItem.input.getOpposite())) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tCoordinateUtils.add(pos, travelItem.input.getOpposite(), 0.5 - fPos);\n\t\t} else {\n\t\t\tif (travelItem.output == ForgeDirection.UNKNOWN) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tCoordinateUtils.add(pos, travelItem.output, fPos - 0.5);\n\t\t}\n\t\treturn pos;\n\t}\n\n\t@Override\n\tpublic boolean canPipeConnect(TileEntity tile, ForgeDirection side) {\n\t\tif (tile instanceof LogisticsTileGenericSubMultiBlock) {\n\t\t\tif (this.getOrientation().getDir1() != side) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn super.canPipeConnect(tile, side);\n\t}\n\n\t@Override\n\tpublic boolean isHSTube() {\n\t\treturn true;\n\t}\n\n\t@AllArgsConstructor\n\tpublic enum SpeedupDirection implements ITubeRenderOrientation, ITubeOrientation {\n\t\t//@formatter:off\n\t\tNORTH(ForgeDirection.NORTH),\n\t\tSOUTH(ForgeDirection.SOUTH),\n\t\tEAST(ForgeDirection.EAST),\n\t\tWEST(ForgeDirection.WEST);\n\t\t//@formatter:on\n\t\t@Getter\n\t\tForgeDirection dir1;\n\n\t\t@Override\n\t\tpublic void rotatePositions(IPositionRotateble set) {\n\t\t\tif (this == SOUTH) {\n\t\t\t\tset.rotateLeft();\n\t\t\t\tset.rotateLeft();\n\t\t\t} else if (this == EAST) {\n\t\t\t\tset.rotateRight();\n\t\t\t} else if (this == WEST) {\n\t\t\t\tset.rotateLeft();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic ITubeRenderOrientation getRenderOrientation() {\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic DoubleCoordinates getOffset() {\n\t\t\treturn new DoubleCoordinates(0, 0, 0);\n\t\t}\n\n\t\t@Override\n\t\tpublic void setOnPipe(CoreMultiBlockPipe pipe) {\n\t\t\t((HSTubeSpeedup) pipe).orientation = this;\n\t\t}\n\t}\n}",
        "patch": "@@ -1,6 +1,5 @@\n package logisticspipes.pipes.tubes;\n \n-import java.io.IOException;\n import java.util.List;\n \n import net.minecraft.entity.player.EntityPlayer;\n@@ -36,45 +35,6 @@\n \n public class HSTubeSpeedup extends CoreMultiBlockPipe {\n \n-\t@AllArgsConstructor\n-\tpublic enum SpeedupDirection implements ITubeRenderOrientation, ITubeOrientation {\n-\t\t//@formatter:off\n-\t\tNORTH(ForgeDirection.NORTH),\n-\t\tSOUTH(ForgeDirection.SOUTH),\n-\t\tEAST(ForgeDirection.EAST),\n-\t\tWEST(ForgeDirection.WEST);\n-\t\t//@formatter:on\n-\t\t@Getter\n-\t\tForgeDirection dir1;\n-\n-\t\t@Override\n-\t\tpublic void rotatePositions(IPositionRotateble set) {\n-\t\t\tif (this == SOUTH) {\n-\t\t\t\tset.rotateLeft();\n-\t\t\t\tset.rotateLeft();\n-\t\t\t} else if (this == EAST) {\n-\t\t\t\tset.rotateRight();\n-\t\t\t} else if (this == WEST) {\n-\t\t\t\tset.rotateLeft();\n-\t\t\t}\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic ITubeRenderOrientation getRenderOrientation() {\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic DoubleCoordinates getOffset() {\n-\t\t\treturn new DoubleCoordinates(0, 0, 0);\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void setOnPipe(CoreMultiBlockPipe pipe) {\n-\t\t\t((HSTubeSpeedup) pipe).orientation = this;\n-\t\t}\n-\t}\n-\n \t@Getter\n \tprivate SpeedupDirection orientation;\n \n@@ -115,12 +75,12 @@ protected void handleTileReachedClient(LPTravelingItemClient arrivingItem, TileE\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\toutput.writeEnum(orientation);\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\torientation = input.readEnum(SpeedupDirection.class);\n \t}\n \n@@ -309,4 +269,43 @@ public boolean canPipeConnect(TileEntity tile, ForgeDirection side) {\n \tpublic boolean isHSTube() {\n \t\treturn true;\n \t}\n+\n+\t@AllArgsConstructor\n+\tpublic enum SpeedupDirection implements ITubeRenderOrientation, ITubeOrientation {\n+\t\t//@formatter:off\n+\t\tNORTH(ForgeDirection.NORTH),\n+\t\tSOUTH(ForgeDirection.SOUTH),\n+\t\tEAST(ForgeDirection.EAST),\n+\t\tWEST(ForgeDirection.WEST);\n+\t\t//@formatter:on\n+\t\t@Getter\n+\t\tForgeDirection dir1;\n+\n+\t\t@Override\n+\t\tpublic void rotatePositions(IPositionRotateble set) {\n+\t\t\tif (this == SOUTH) {\n+\t\t\t\tset.rotateLeft();\n+\t\t\t\tset.rotateLeft();\n+\t\t\t} else if (this == EAST) {\n+\t\t\t\tset.rotateRight();\n+\t\t\t} else if (this == WEST) {\n+\t\t\t\tset.rotateLeft();\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic ITubeRenderOrientation getRenderOrientation() {\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic DoubleCoordinates getOffset() {\n+\t\t\treturn new DoubleCoordinates(0, 0, 0);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void setOnPipe(CoreMultiBlockPipe pipe) {\n+\t\t\t((HSTubeSpeedup) pipe).orientation = this;\n+\t\t}\n+\t}\n }",
        "function_modified_lines": {
            "added": [],
            "deleted": [
                "\t@AllArgsConstructor\n",
                "\tpublic enum SpeedupDirection implements ITubeRenderOrientation, ITubeOrientation {\n",
                "\t\t//@formatter:off\n",
                "\t\tNORTH(ForgeDirection.NORTH),\n",
                "\t\tSOUTH(ForgeDirection.SOUTH),\n",
                "\t\tEAST(ForgeDirection.EAST),\n",
                "\t\tWEST(ForgeDirection.WEST);\n",
                "\t\t//@formatter:on\n",
                "\t\t@Getter\n",
                "\t\tForgeDirection dir1;\n",
                "\n",
                "\t\t@Override\n",
                "\t\tpublic void rotatePositions(IPositionRotateble set) {\n",
                "\t\t\tif (this == SOUTH) {\n",
                "\t\t\t\tset.rotateLeft();\n",
                "\t\t\t\tset.rotateLeft();\n",
                "\t\t\t} else if (this == EAST) {\n",
                "\t\t\t\tset.rotateRight();\n",
                "\t\t\t} else if (this == WEST) {\n",
                "\t\t\t\tset.rotateLeft();\n",
                "\t\t\t}\n",
                "\t\t}\n",
                "\n",
                "\t\t@Override\n",
                "\t\tpublic ITubeRenderOrientation getRenderOrientation() {\n",
                "\t\t\treturn this;\n",
                "\t\t}\n",
                "\n",
                "\t\t@Override\n",
                "\t\tpublic DoubleCoordinates getOffset() {\n",
                "\t\t\treturn new DoubleCoordinates(0, 0, 0);\n",
                "\t\t}\n",
                "\n",
                "\t\t@Override\n",
                "\t\tpublic void setOnPipe(CoreMultiBlockPipe pipe) {\n",
                "\t\t\t((HSTubeSpeedup) pipe).orientation = this;\n",
                "\t\t}\n",
                "\t}\n",
                "\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-502"
        ],
        "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
        "id": 12834
    },
    {
        "cve_id": "CVE-2023-38689",
        "code_before_change": "{\n\n\tpublic ParticleFX(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Getter\n\t@Setter\n\t@NonNull\n\tprivate Collection<ParticleCount> particles;\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new ParticleFX(getId());\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tsuper.readData(input);\n\t\tint nparticles = input.readInt();\n\t\tparticles = new ArrayList<>(nparticles);\n\t\tfor (int i = 0; i < nparticles; i++) {\n\t\t\tint particle = input.readByte();\n\t\t\tint amount = input.readInt();\n\t\t\tparticles.add(new ParticleCount(Particles.values()[particle], amount));\n\t\t}\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\tsuper.writeData(output);\n\t\toutput.writeInt(particles.size());\n\t\tfor (ParticleCount pc : particles) {\n\t\t\toutput.writeByte(pc.getParticle().ordinal());\n\t\t\toutput.writeInt(pc.getAmount());\n\t\t}\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tif (!Minecraft.isFancyGraphicsEnabled()) {\n\t\t\treturn;\n\t\t}\n\t\tfor (ParticleCount pc : particles) {\n\t\t\tPipeFXRenderHandler.spawnGenericParticle(pc.getParticle(), getPosX(), getPosY(), getPosZ(), pc.getAmount());\n\t\t}\n\t}\n}",
        "code_after_change": "{\n\n\t@Getter\n\t@Setter\n\t@NonNull\n\tprivate Collection<ParticleCount> particles;\n\n\tpublic ParticleFX(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new ParticleFX(getId());\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tsuper.readData(input);\n\t\tint nparticles = input.readInt();\n\t\tparticles = new ArrayList<>(nparticles);\n\t\tfor (int i = 0; i < nparticles; i++) {\n\t\t\tint particle = input.readByte();\n\t\t\tint amount = input.readInt();\n\t\t\tparticles.add(new ParticleCount(Particles.values()[particle], amount));\n\t\t}\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\tsuper.writeData(output);\n\t\toutput.writeInt(particles.size());\n\t\tfor (ParticleCount pc : particles) {\n\t\t\toutput.writeByte(pc.getParticle().ordinal());\n\t\t\toutput.writeInt(pc.getAmount());\n\t\t}\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tif (!Minecraft.isFancyGraphicsEnabled()) {\n\t\t\treturn;\n\t\t}\n\t\tfor (ParticleCount pc : particles) {\n\t\t\tPipeFXRenderHandler.spawnGenericParticle(pc.getParticle(), getPosX(), getPosY(), getPosZ(), pc.getAmount());\n\t\t}\n\t}\n}",
        "patch": "@@ -1,6 +1,5 @@\n package logisticspipes.network.packets.pipe;\n \n-import java.io.IOException;\n import java.util.ArrayList;\n import java.util.Collection;\n \n@@ -21,22 +20,22 @@\n \n public class ParticleFX extends CoordinatesPacket {\n \n-\tpublic ParticleFX(int id) {\n-\t\tsuper(id);\n-\t}\n-\n \t@Getter\n \t@Setter\n \t@NonNull\n \tprivate Collection<ParticleCount> particles;\n \n+\tpublic ParticleFX(int id) {\n+\t\tsuper(id);\n+\t}\n+\n \t@Override\n \tpublic ModernPacket template() {\n \t\treturn new ParticleFX(getId());\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tsuper.readData(input);\n \t\tint nparticles = input.readInt();\n \t\tparticles = new ArrayList<>(nparticles);\n@@ -48,7 +47,7 @@ public void readData(LPDataInput input) throws IOException {\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\tsuper.writeData(output);\n \t\toutput.writeInt(particles.size());\n \t\tfor (ParticleCount pc : particles) {",
        "function_modified_lines": {
            "added": [
                "\tpublic ParticleFX(int id) {\n",
                "\t\tsuper(id);\n",
                "\t}\n",
                "\n",
                "\tpublic void readData(LPDataInput input) {\n",
                "\tpublic void writeData(LPDataOutput output) {\n"
            ],
            "deleted": [
                "\tpublic ParticleFX(int id) {\n",
                "\t\tsuper(id);\n",
                "\t}\n",
                "\n",
                "\tpublic void readData(LPDataInput input) throws IOException {\n",
                "\tpublic void writeData(LPDataOutput output) throws IOException {\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-502"
        ],
        "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
        "id": 12816
    },
    {
        "cve_id": "CVE-2023-38689",
        "code_before_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate byte[] content;\n\n\tpublic BufferTransfer(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new BufferTransfer(getId());\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tif (MainProxy.isClient(player.worldObj)) {\n\t\t\tSimpleServiceLocator.clientBufferHandler.handlePacket(content);\n\t\t} else {\n\t\t\tSimpleServiceLocator.serverBufferHandler.handlePacket(content, player);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tcontent = input.readByteArray();\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\toutput.writeByteArray(content);\n\t}\n}",
        "code_after_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate byte[] content;\n\n\tpublic BufferTransfer(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new BufferTransfer(getId());\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tif (MainProxy.isClient(player.worldObj)) {\n\t\t\tSimpleServiceLocator.clientBufferHandler.handlePacket(content);\n\t\t} else {\n\t\t\tSimpleServiceLocator.serverBufferHandler.handlePacket(content, player);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tcontent = input.readByteArray();\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\toutput.writeByteArray(content);\n\t}\n}",
        "patch": "@@ -1,7 +1,5 @@\n package logisticspipes.network.packets;\n \n-import java.io.IOException;\n-\n import net.minecraft.entity.player.EntityPlayer;\n \n import lombok.Getter;\n@@ -38,12 +36,12 @@ public void processPacket(EntityPlayer player) {\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tcontent = input.readByteArray();\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\toutput.writeByteArray(content);\n \t}\n }",
        "function_modified_lines": {
            "added": [
                "\tpublic void readData(LPDataInput input) {\n",
                "\tpublic void writeData(LPDataOutput output) {\n"
            ],
            "deleted": [
                "\tpublic void readData(LPDataInput input) throws IOException {\n",
                "\tpublic void writeData(LPDataOutput output) throws IOException {\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-502"
        ],
        "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
        "id": 12787
    },
    {
        "cve_id": "CVE-2023-38689",
        "code_before_change": "import java.io.IOException;\nimport java.util.List;\n\nimport net.minecraft.entity.player.EntityPlayer;\nimport net.minecraft.item.Item;\nimport net.minecraft.nbt.NBTTagCompound;\nimport net.minecraft.tileentity.TileEntity;\nimport net.minecraft.util.AxisAlignedBB;\nimport net.minecraftforge.common.util.ForgeDirection;\nimport cpw.mods.fml.relauncher.Side;\nimport cpw.mods.fml.relauncher.SideOnly;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Getter;\n\nimport logisticspipes.LPConstants;\nimport logisticspipes.interfaces.ITubeOrientation;\nimport logisticspipes.interfaces.ITubeRenderOrientation;\nimport logisticspipes.pipes.basic.CoreMultiBlockPipe;\nimport logisticspipes.pipes.basic.LogisticsTileGenericSubMultiBlock;\nimport logisticspipes.renderer.newpipe.IHighlightPlacementRenderer;\nimport logisticspipes.renderer.newpipe.ISpecialPipeRenderer;\nimport logisticspipes.renderer.newpipe.tube.CurveTubeRenderer;\nimport logisticspipes.transport.LPTravelingItem;\nimport logisticspipes.transport.PipeMultiBlockTransportLogistics;\nimport logisticspipes.utils.IPositionRotateble;\nimport logisticspipes.utils.LPPositionSet;\nimport network.rs485.logisticspipes.util.LPDataInput;\nimport network.rs485.logisticspipes.util.LPDataOutput;\nimport network.rs485.logisticspipes.world.DoubleCoordinates;\nimport network.rs485.logisticspipes.world.DoubleCoordinatesType;\n\npublic class HSTubeCurve extends CoreMultiBlockPipe {\n\n\t@AllArgsConstructor\n\tpublic enum CurveOrientation implements ITubeOrientation {\n\t\t//@formatter:off\n\t\t// Name: Placement from  _ TurnDirection\n\t\tNORTH_NORTH_EAST(TurnDirection.NORTH_EAST, new DoubleCoordinates(2, 0, 2), ForgeDirection.NORTH, ForgeDirection.EAST),\n\t\tNORTH_WEST_NORTH(TurnDirection.WEST_NORTH, new DoubleCoordinates(0, 0, 0), ForgeDirection.NORTH, ForgeDirection.WEST),\n\t\tWEST_WEST_NORTH(TurnDirection.WEST_NORTH, new DoubleCoordinates(2, 0, -2), ForgeDirection.WEST, ForgeDirection.NORTH),\n\t\tWEST_SOUTH_WEST(TurnDirection.SOUTH_WEST, new DoubleCoordinates(0, 0, 0), ForgeDirection.WEST, ForgeDirection.SOUTH),\n\t\tSOUTH_SOUTH_WEST(TurnDirection.SOUTH_WEST, new DoubleCoordinates(-2, 0, -2), ForgeDirection.SOUTH, ForgeDirection.WEST),\n\t\tSOUTH_EAST_SOUTH(TurnDirection.EAST_SOUTH, new DoubleCoordinates(0, 0, 0), ForgeDirection.SOUTH, ForgeDirection.EAST),\n\t\tEAST_EAST_SOUTH(TurnDirection.EAST_SOUTH, new DoubleCoordinates(-2, 0, 2), ForgeDirection.EAST, ForgeDirection.SOUTH),\n\t\tEAST_NORTH_EAST(TurnDirection.NORTH_EAST, new DoubleCoordinates(0, 0, 0), ForgeDirection.EAST, ForgeDirection.NORTH);\n\t\t//@formatter:on\n\t\t@Getter\n\t\tTurnDirection renderOrientation;\n\t\t@Getter\n\t\tDoubleCoordinates offset;\n\t\t@Getter\n\t\tForgeDirection from;\n\t\t@Getter\n\t\tForgeDirection looking;\n\n\t\t@Override\n\t\tpublic void rotatePositions(IPositionRotateble set) {\n\t\t\trenderOrientation.rotatePositions(set);\n\t\t}\n\n\t\t@Override\n\t\tpublic void setOnPipe(CoreMultiBlockPipe pipe) {\n\t\t\t((HSTubeCurve) pipe).orientation = this;\n\t\t}\n\t}\n\n\t@AllArgsConstructor\n\tpublic enum TurnDirection implements ITubeRenderOrientation {\n\t\t//@formatter:off\n\t\tNORTH_EAST(ForgeDirection.NORTH, ForgeDirection.EAST),\n\t\tEAST_SOUTH(ForgeDirection.EAST, ForgeDirection.SOUTH),\n\t\tSOUTH_WEST(ForgeDirection.SOUTH, ForgeDirection.WEST),\n\t\tWEST_NORTH(ForgeDirection.WEST, ForgeDirection.NORTH);\n\t\t//@formatter:on\n\t\t@Getter\n\t\tForgeDirection dir1;\n\t\tForgeDirection dir2;\n\n\t\tpublic void rotatePositions(IPositionRotateble set) {\n\t\t\tif (this == WEST_NORTH) {\n\t\t\t\treturn;\n\t\t\t} else if (this == NORTH_EAST) {\n\t\t\t\tset.rotateRight();\n\t\t\t} else if (this == EAST_SOUTH) {\n\t\t\t\tset.rotateLeft();\n\t\t\t\tset.rotateLeft();\n\t\t\t} else if (this == SOUTH_WEST) {\n\t\t\t\tset.rotateLeft();\n\t\t\t}\n\t\t}\n\t}\n\n\t@Getter\n\tprivate CurveOrientation orientation;\n\n\tpublic HSTubeCurve(Item item) {\n\t\tsuper(new PipeMultiBlockTransportLogistics(), item);\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\tif (orientation == null) {\n\t\t\toutput.writeBoolean(false);\n\t\t} else {\n\t\t\toutput.writeBoolean(true);\n\t\t\toutput.writeEnum(orientation);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tif (input.readBoolean()) {\n\t\t\torientation = input.readEnum(CurveOrientation.class);\n\t\t}\n\t}\n\n\t@Override\n\tpublic int getIconIndex(ForgeDirection direction) {\n\t\t// TODO Auto-generated method stub\n\t\treturn 0;\n\t}\n\n\t@Override\n\tpublic int getTextureIndex() {\n\t\t// TODO Auto-generated method stub\n\t\treturn 0;\n\t}\n\n\t@Override\n\tpublic LPPositionSet<DoubleCoordinatesType<SubBlockTypeForShare>> getSubBlocks() {\n\t\tLPPositionSet<DoubleCoordinatesType<SubBlockTypeForShare>> list = new LPPositionSet<>(DoubleCoordinatesType.class);\n\t\tlist.add(new DoubleCoordinatesType<>(-1, 0, 0, SubBlockTypeForShare.CURVE_INNER_A));\n\t\tlist.add(new DoubleCoordinatesType<>(0, 0, 1, SubBlockTypeForShare.CURVE_OUT_A));\n\t\tlist.add(new DoubleCoordinatesType<>(-1, 0, 1, SubBlockTypeForShare.NON_SHARE));\n\t\tlist.add(new DoubleCoordinatesType<>(-2, 0, 1, SubBlockTypeForShare.CURVE_INNER_B));\n\t\tlist.add(new DoubleCoordinatesType<>(-1, 0, 2, SubBlockTypeForShare.CURVE_OUT_B));\n\t\tlist.add(new DoubleCoordinatesType<>(-2, 0, 2, SubBlockTypeForShare.NON_SHARE));\n\t\treturn list;\n\t}\n\n\t@Override\n\tpublic LPPositionSet<DoubleCoordinatesType<SubBlockTypeForShare>> getRotatedSubBlocks() {\n\t\tLPPositionSet<DoubleCoordinatesType<SubBlockTypeForShare>> set = getSubBlocks();\n\t\torientation.rotatePositions(set);\n\t\treturn set;\n\t}\n",
        "code_after_change": "package logisticspipes.pipes.tubes;\n\nimport java.util.List;\n\nimport net.minecraft.entity.player.EntityPlayer;\nimport net.minecraft.item.Item;\nimport net.minecraft.nbt.NBTTagCompound;\nimport net.minecraft.tileentity.TileEntity;\nimport net.minecraft.util.AxisAlignedBB;\nimport net.minecraftforge.common.util.ForgeDirection;\nimport cpw.mods.fml.relauncher.Side;\nimport cpw.mods.fml.relauncher.SideOnly;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Getter;\n\nimport logisticspipes.LPConstants;\nimport logisticspipes.interfaces.ITubeOrientation;\nimport logisticspipes.interfaces.ITubeRenderOrientation;\nimport logisticspipes.pipes.basic.CoreMultiBlockPipe;\nimport logisticspipes.pipes.basic.LogisticsTileGenericSubMultiBlock;\nimport logisticspipes.renderer.newpipe.IHighlightPlacementRenderer;\nimport logisticspipes.renderer.newpipe.ISpecialPipeRenderer;\nimport logisticspipes.renderer.newpipe.tube.CurveTubeRenderer;\nimport logisticspipes.transport.LPTravelingItem;\nimport logisticspipes.transport.PipeMultiBlockTransportLogistics;\nimport logisticspipes.utils.IPositionRotateble;\nimport logisticspipes.utils.LPPositionSet;\nimport network.rs485.logisticspipes.util.LPDataInput;\nimport network.rs485.logisticspipes.util.LPDataOutput;\nimport network.rs485.logisticspipes.world.DoubleCoordinates;\nimport network.rs485.logisticspipes.world.DoubleCoordinatesType;\n\npublic class HSTubeCurve extends CoreMultiBlockPipe {\n\n\t@Getter\n\tprivate CurveOrientation orientation;\n\n\tpublic HSTubeCurve(Item item) {\n\t\tsuper(new PipeMultiBlockTransportLogistics(), item);\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\tif (orientation == null) {\n\t\t\toutput.writeBoolean(false);\n\t\t} else {\n\t\t\toutput.writeBoolean(true);\n\t\t\toutput.writeEnum(orientation);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tif (input.readBoolean()) {\n\t\t\torientation = input.readEnum(CurveOrientation.class);\n\t\t}\n\t}\n\n\t@Override\n\tpublic int getIconIndex(ForgeDirection direction) {\n\t\t// TODO Auto-generated method stub\n\t\treturn 0;\n\t}\n\n\t@Override\n\tpublic int getTextureIndex() {\n\t\t// TODO Auto-generated method stub\n\t\treturn 0;\n\t}\n\n\t@Override\n\tpublic LPPositionSet<DoubleCoordinatesType<SubBlockTypeForShare>> getSubBlocks() {\n\t\tLPPositionSet<DoubleCoordinatesType<SubBlockTypeForShare>> list = new LPPositionSet<>(DoubleCoordinatesType.class);\n\t\tlist.add(new DoubleCoordinatesType<>(-1, 0, 0, SubBlockTypeForShare.CURVE_INNER_A));\n\t\tlist.add(new DoubleCoordinatesType<>(0, 0, 1, SubBlockTypeForShare.CURVE_OUT_A));\n\t\tlist.add(new DoubleCoordinatesType<>(-1, 0, 1, SubBlockTypeForShare.NON_SHARE));\n\t\tlist.add(new DoubleCoordinatesType<>(-2, 0, 1, SubBlockTypeForShare.CURVE_INNER_B));\n\t\tlist.add(new DoubleCoordinatesType<>(-1, 0, 2, SubBlockTypeForShare.CURVE_OUT_B));\n\t\tlist.add(new DoubleCoordinatesType<>(-2, 0, 2, SubBlockTypeForShare.NON_SHARE));\n\t\treturn list;\n\t}\n\n\t@Override\n\tpublic LPPositionSet<DoubleCoordinatesType<SubBlockTypeForShare>> getRotatedSubBlocks() {\n\t\tLPPositionSet<DoubleCoordinatesType<SubBlockTypeForShare>> set = getSubBlocks();\n\t\torientation.rotatePositions(set);\n\t\treturn set;\n\t}\n",
        "patch": "@@ -1,6 +1,5 @@\n package logisticspipes.pipes.tubes;\n \n-import java.io.IOException;\n import java.util.List;\n \n import net.minecraft.entity.player.EntityPlayer;\n@@ -34,65 +33,6 @@\n \n public class HSTubeCurve extends CoreMultiBlockPipe {\n \n-\t@AllArgsConstructor\n-\tpublic enum CurveOrientation implements ITubeOrientation {\n-\t\t//@formatter:off\n-\t\t// Name: Placement from  _ TurnDirection\n-\t\tNORTH_NORTH_EAST(TurnDirection.NORTH_EAST, new DoubleCoordinates(2, 0, 2), ForgeDirection.NORTH, ForgeDirection.EAST),\n-\t\tNORTH_WEST_NORTH(TurnDirection.WEST_NORTH, new DoubleCoordinates(0, 0, 0), ForgeDirection.NORTH, ForgeDirection.WEST),\n-\t\tWEST_WEST_NORTH(TurnDirection.WEST_NORTH, new DoubleCoordinates(2, 0, -2), ForgeDirection.WEST, ForgeDirection.NORTH),\n-\t\tWEST_SOUTH_WEST(TurnDirection.SOUTH_WEST, new DoubleCoordinates(0, 0, 0), ForgeDirection.WEST, ForgeDirection.SOUTH),\n-\t\tSOUTH_SOUTH_WEST(TurnDirection.SOUTH_WEST, new DoubleCoordinates(-2, 0, -2), ForgeDirection.SOUTH, ForgeDirection.WEST),\n-\t\tSOUTH_EAST_SOUTH(TurnDirection.EAST_SOUTH, new DoubleCoordinates(0, 0, 0), ForgeDirection.SOUTH, ForgeDirection.EAST),\n-\t\tEAST_EAST_SOUTH(TurnDirection.EAST_SOUTH, new DoubleCoordinates(-2, 0, 2), ForgeDirection.EAST, ForgeDirection.SOUTH),\n-\t\tEAST_NORTH_EAST(TurnDirection.NORTH_EAST, new DoubleCoordinates(0, 0, 0), ForgeDirection.EAST, ForgeDirection.NORTH);\n-\t\t//@formatter:on\n-\t\t@Getter\n-\t\tTurnDirection renderOrientation;\n-\t\t@Getter\n-\t\tDoubleCoordinates offset;\n-\t\t@Getter\n-\t\tForgeDirection from;\n-\t\t@Getter\n-\t\tForgeDirection looking;\n-\n-\t\t@Override\n-\t\tpublic void rotatePositions(IPositionRotateble set) {\n-\t\t\trenderOrientation.rotatePositions(set);\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void setOnPipe(CoreMultiBlockPipe pipe) {\n-\t\t\t((HSTubeCurve) pipe).orientation = this;\n-\t\t}\n-\t}\n-\n-\t@AllArgsConstructor\n-\tpublic enum TurnDirection implements ITubeRenderOrientation {\n-\t\t//@formatter:off\n-\t\tNORTH_EAST(ForgeDirection.NORTH, ForgeDirection.EAST),\n-\t\tEAST_SOUTH(ForgeDirection.EAST, ForgeDirection.SOUTH),\n-\t\tSOUTH_WEST(ForgeDirection.SOUTH, ForgeDirection.WEST),\n-\t\tWEST_NORTH(ForgeDirection.WEST, ForgeDirection.NORTH);\n-\t\t//@formatter:on\n-\t\t@Getter\n-\t\tForgeDirection dir1;\n-\t\tForgeDirection dir2;\n-\n-\t\tpublic void rotatePositions(IPositionRotateble set) {\n-\t\t\tif (this == WEST_NORTH) {\n-\t\t\t\treturn;\n-\t\t\t} else if (this == NORTH_EAST) {\n-\t\t\t\tset.rotateRight();\n-\t\t\t} else if (this == EAST_SOUTH) {\n-\t\t\t\tset.rotateLeft();\n-\t\t\t\tset.rotateLeft();\n-\t\t\t} else if (this == SOUTH_WEST) {\n-\t\t\t\tset.rotateLeft();\n-\t\t\t}\n-\t\t}\n-\t}\n-\n \t@Getter\n \tprivate CurveOrientation orientation;\n \n@@ -101,7 +41,7 @@ public HSTubeCurve(Item item) {\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\tif (orientation == null) {\n \t\t\toutput.writeBoolean(false);\n \t\t} else {\n@@ -111,7 +51,7 @@ public void writeData(LPDataOutput output) throws IOException {\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tif (input.readBoolean()) {\n \t\t\torientation = input.readEnum(CurveOrientation.class);\n \t\t}\n@@ -399,4 +339,63 @@ public double getBoxRenderScale(float fPos, LPTravelingItem travelItem) {\n \tpublic boolean isHSTube() {\n \t\treturn true;\n \t}\n+\n+\t@AllArgsConstructor\n+\tpublic enum CurveOrientation implements ITubeOrientation {\n+\t\t//@formatter:off\n+\t\t// Name: Placement from  _ TurnDirection\n+\t\tNORTH_NORTH_EAST(TurnDirection.NORTH_EAST, new DoubleCoordinates(2, 0, 2), ForgeDirection.NORTH, ForgeDirection.EAST),\n+\t\tNORTH_WEST_NORTH(TurnDirection.WEST_NORTH, new DoubleCoordinates(0, 0, 0), ForgeDirection.NORTH, ForgeDirection.WEST),\n+\t\tWEST_WEST_NORTH(TurnDirection.WEST_NORTH, new DoubleCoordinates(2, 0, -2), ForgeDirection.WEST, ForgeDirection.NORTH),\n+\t\tWEST_SOUTH_WEST(TurnDirection.SOUTH_WEST, new DoubleCoordinates(0, 0, 0), ForgeDirection.WEST, ForgeDirection.SOUTH),\n+\t\tSOUTH_SOUTH_WEST(TurnDirection.SOUTH_WEST, new DoubleCoordinates(-2, 0, -2), ForgeDirection.SOUTH, ForgeDirection.WEST),\n+\t\tSOUTH_EAST_SOUTH(TurnDirection.EAST_SOUTH, new DoubleCoordinates(0, 0, 0), ForgeDirection.SOUTH, ForgeDirection.EAST),\n+\t\tEAST_EAST_SOUTH(TurnDirection.EAST_SOUTH, new DoubleCoordinates(-2, 0, 2), ForgeDirection.EAST, ForgeDirection.SOUTH),\n+\t\tEAST_NORTH_EAST(TurnDirection.NORTH_EAST, new DoubleCoordinates(0, 0, 0), ForgeDirection.EAST, ForgeDirection.NORTH);\n+\t\t//@formatter:on\n+\t\t@Getter\n+\t\tTurnDirection renderOrientation;\n+\t\t@Getter\n+\t\tDoubleCoordinates offset;\n+\t\t@Getter\n+\t\tForgeDirection from;\n+\t\t@Getter\n+\t\tForgeDirection looking;\n+\n+\t\t@Override\n+\t\tpublic void rotatePositions(IPositionRotateble set) {\n+\t\t\trenderOrientation.rotatePositions(set);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void setOnPipe(CoreMultiBlockPipe pipe) {\n+\t\t\t((HSTubeCurve) pipe).orientation = this;\n+\t\t}\n+\t}\n+\n+\t@AllArgsConstructor\n+\tpublic enum TurnDirection implements ITubeRenderOrientation {\n+\t\t//@formatter:off\n+\t\tNORTH_EAST(ForgeDirection.NORTH, ForgeDirection.EAST),\n+\t\tEAST_SOUTH(ForgeDirection.EAST, ForgeDirection.SOUTH),\n+\t\tSOUTH_WEST(ForgeDirection.SOUTH, ForgeDirection.WEST),\n+\t\tWEST_NORTH(ForgeDirection.WEST, ForgeDirection.NORTH);\n+\t\t//@formatter:on\n+\t\t@Getter\n+\t\tForgeDirection dir1;\n+\t\tForgeDirection dir2;\n+\n+\t\tpublic void rotatePositions(IPositionRotateble set) {\n+\t\t\tif (this == WEST_NORTH) {\n+\t\t\t\treturn;\n+\t\t\t} else if (this == NORTH_EAST) {\n+\t\t\t\tset.rotateRight();\n+\t\t\t} else if (this == EAST_SOUTH) {\n+\t\t\t\tset.rotateLeft();\n+\t\t\t\tset.rotateLeft();\n+\t\t\t} else if (this == SOUTH_WEST) {\n+\t\t\t\tset.rotateLeft();\n+\t\t\t}\n+\t\t}\n+\t}\n }",
        "function_modified_lines": {
            "added": [
                "\tpublic void writeData(LPDataOutput output) {\n",
                "\tpublic void readData(LPDataInput input) {\n"
            ],
            "deleted": [
                "\t@AllArgsConstructor\n",
                "\tpublic enum CurveOrientation implements ITubeOrientation {\n",
                "\t\t//@formatter:off\n",
                "\t\t// Name: Placement from  _ TurnDirection\n",
                "\t\tNORTH_NORTH_EAST(TurnDirection.NORTH_EAST, new DoubleCoordinates(2, 0, 2), ForgeDirection.NORTH, ForgeDirection.EAST),\n",
                "\t\tNORTH_WEST_NORTH(TurnDirection.WEST_NORTH, new DoubleCoordinates(0, 0, 0), ForgeDirection.NORTH, ForgeDirection.WEST),\n",
                "\t\tWEST_WEST_NORTH(TurnDirection.WEST_NORTH, new DoubleCoordinates(2, 0, -2), ForgeDirection.WEST, ForgeDirection.NORTH),\n",
                "\t\tWEST_SOUTH_WEST(TurnDirection.SOUTH_WEST, new DoubleCoordinates(0, 0, 0), ForgeDirection.WEST, ForgeDirection.SOUTH),\n",
                "\t\tSOUTH_SOUTH_WEST(TurnDirection.SOUTH_WEST, new DoubleCoordinates(-2, 0, -2), ForgeDirection.SOUTH, ForgeDirection.WEST),\n",
                "\t\tSOUTH_EAST_SOUTH(TurnDirection.EAST_SOUTH, new DoubleCoordinates(0, 0, 0), ForgeDirection.SOUTH, ForgeDirection.EAST),\n",
                "\t\tEAST_EAST_SOUTH(TurnDirection.EAST_SOUTH, new DoubleCoordinates(-2, 0, 2), ForgeDirection.EAST, ForgeDirection.SOUTH),\n",
                "\t\tEAST_NORTH_EAST(TurnDirection.NORTH_EAST, new DoubleCoordinates(0, 0, 0), ForgeDirection.EAST, ForgeDirection.NORTH);\n",
                "\t\t//@formatter:on\n",
                "\t\t@Getter\n",
                "\t\tTurnDirection renderOrientation;\n",
                "\t\t@Getter\n",
                "\t\tDoubleCoordinates offset;\n",
                "\t\t@Getter\n",
                "\t\tForgeDirection from;\n",
                "\t\t@Getter\n",
                "\t\tForgeDirection looking;\n",
                "\n",
                "\t\t@Override\n",
                "\t\tpublic void rotatePositions(IPositionRotateble set) {\n",
                "\t\t\trenderOrientation.rotatePositions(set);\n",
                "\t\t}\n",
                "\n",
                "\t\t@Override\n",
                "\t\tpublic void setOnPipe(CoreMultiBlockPipe pipe) {\n",
                "\t\t\t((HSTubeCurve) pipe).orientation = this;\n",
                "\t\t}\n",
                "\t}\n",
                "\n",
                "\t@AllArgsConstructor\n",
                "\tpublic enum TurnDirection implements ITubeRenderOrientation {\n",
                "\t\t//@formatter:off\n",
                "\t\tNORTH_EAST(ForgeDirection.NORTH, ForgeDirection.EAST),\n",
                "\t\tEAST_SOUTH(ForgeDirection.EAST, ForgeDirection.SOUTH),\n",
                "\t\tSOUTH_WEST(ForgeDirection.SOUTH, ForgeDirection.WEST),\n",
                "\t\tWEST_NORTH(ForgeDirection.WEST, ForgeDirection.NORTH);\n",
                "\t\t//@formatter:on\n",
                "\t\t@Getter\n",
                "\t\tForgeDirection dir1;\n",
                "\t\tForgeDirection dir2;\n",
                "\n",
                "\t\tpublic void rotatePositions(IPositionRotateble set) {\n",
                "\t\t\tif (this == WEST_NORTH) {\n",
                "\t\t\t\treturn;\n",
                "\t\t\t} else if (this == NORTH_EAST) {\n",
                "\t\t\t\tset.rotateRight();\n",
                "\t\t\t} else if (this == EAST_SOUTH) {\n",
                "\t\t\t\tset.rotateLeft();\n",
                "\t\t\t\tset.rotateLeft();\n",
                "\t\t\t} else if (this == SOUTH_WEST) {\n",
                "\t\t\t\tset.rotateLeft();\n",
                "\t\t\t}\n",
                "\t\t}\n",
                "\t}\n",
                "\n",
                "\tpublic void writeData(LPDataOutput output) throws IOException {\n",
                "\tpublic void readData(LPDataInput input) throws IOException {\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-502"
        ],
        "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
        "id": 12830
    },
    {
        "cve_id": "CVE-2023-38689",
        "code_before_change": "{\n\n\t@Setter\n\t@Getter\n\tprivate String name;\n\n\t@Getter\n\t@Setter\n\tprivate int identification;\n\n\tpublic DebugPanelOpen(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new DebugPanelOpen(getId());\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tsetName(input.readUTF());\n\t\tsetIdentification(input.readInt());\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\toutput.writeUTF(getName());\n\t\toutput.writeInt(getIdentification());\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\ttry {\n\t\t\tDebugGuiController.instance().createNewDebugGui(getName(), getIdentification());\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isCompressable() {\n\t\treturn true;\n\t}\n}",
        "code_after_change": "{\n\n\t@Setter\n\t@Getter\n\tprivate String name;\n\n\t@Getter\n\t@Setter\n\tprivate int identification;\n\n\tpublic DebugPanelOpen(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new DebugPanelOpen(getId());\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tsetName(input.readUTF());\n\t\tsetIdentification(input.readInt());\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\toutput.writeUTF(getName());\n\t\toutput.writeInt(getIdentification());\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\ttry {\n\t\t\tDebugGuiController.instance().createNewDebugGui(getName(), getIdentification());\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isCompressable() {\n\t\treturn true;\n\t}\n}",
        "patch": "@@ -1,7 +1,5 @@\n package logisticspipes.network.packets.debuggui;\n \n-import java.io.IOException;\n-\n import net.minecraft.entity.player.EntityPlayer;\n \n import lombok.Getter;\n@@ -32,13 +30,13 @@ public ModernPacket template() {\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tsetName(input.readUTF());\n \t\tsetIdentification(input.readInt());\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\toutput.writeUTF(getName());\n \t\toutput.writeInt(getIdentification());\n \t}",
        "function_modified_lines": {
            "added": [
                "\tpublic void readData(LPDataInput input) {\n",
                "\tpublic void writeData(LPDataOutput output) {\n"
            ],
            "deleted": [
                "\tpublic void readData(LPDataInput input) throws IOException {\n",
                "\tpublic void writeData(LPDataOutput output) throws IOException {\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-502"
        ],
        "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
        "id": 12805
    },
    {
        "cve_id": "CVE-2023-38689",
        "code_before_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate String string;\n\n\tpublic StringCoordinatesPacket(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\tsuper.writeData(output);\n\t\toutput.writeUTF(getString());\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tsuper.readData(input);\n\t\tsetString(input.readUTF());\n\t}\n}",
        "code_after_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate String string;\n\n\tpublic StringCoordinatesPacket(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\tsuper.writeData(output);\n\t\toutput.writeUTF(getString());\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tsuper.readData(input);\n\t\tsetString(input.readUTF());\n\t}\n}",
        "patch": "@@ -1,7 +1,5 @@\n package logisticspipes.network.abstractpackets;\n \n-import java.io.IOException;\n-\n import lombok.Getter;\n import lombok.Setter;\n \n@@ -19,13 +17,13 @@ public StringCoordinatesPacket(int id) {\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\tsuper.writeData(output);\n \t\toutput.writeUTF(getString());\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tsuper.readData(input);\n \t\tsetString(input.readUTF());\n \t}",
        "function_modified_lines": {
            "added": [
                "\tpublic void writeData(LPDataOutput output) {\n",
                "\tpublic void readData(LPDataInput input) {\n"
            ],
            "deleted": [
                "\tpublic void writeData(LPDataOutput output) throws IOException {\n",
                "\tpublic void readData(LPDataInput input) throws IOException {\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-502"
        ],
        "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
        "id": 12781
    },
    {
        "cve_id": "CVE-2023-38689",
        "code_before_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate int slot;\n\n\tpublic SlotFinderOpenGuiPacket(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\t//hack to avoid wrenching blocks\n\t\tint savedEquipped = player.inventory.currentItem;\n\t\tboolean foundSlot = false;\n\t\t//try to find a empty slot\n\t\tfor (int i = 0; i < 9; i++) {\n\t\t\tif (player.inventory.getStackInSlot(i) == null) {\n\t\t\t\tfoundSlot = true;\n\t\t\t\tplayer.inventory.currentItem = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t//okay, anything that's a block?\n\t\tif (!foundSlot) {\n\t\t\tfor (int i = 0; i < 9; i++) {\n\t\t\t\tItemStack is = player.inventory.getStackInSlot(i);\n\t\t\t\tif (is.getItem() instanceof ItemBlock) {\n\t\t\t\t\tfoundSlot = true;\n\t\t\t\t\tplayer.inventory.currentItem = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//give up and select whatever is right of the current slot\n\t\tif (!foundSlot) {\n\t\t\tplayer.inventory.currentItem = (player.inventory.currentItem + 1) % 9;\n\t\t}\n\n\t\tWorldCoordinatesWrapper worldCoordinates = new WorldCoordinatesWrapper(player.worldObj, getPosX(), getPosY(), getPosZ());\n\t\tIterator<AdjacentTileEntity> adjacentIt = worldCoordinates.getConnectedAdjacentTileEntities(ConnectionPipeType.ITEM).iterator();\n\n\t\tboolean found = false;\n\t\twhile (adjacentIt.hasNext()) {\n\t\t\tAdjacentTileEntity adjacent = adjacentIt.next();\n\n\t\t\tif (adjacent.tileEntity instanceof IInventory) {\n\t\t\t\tif (!(SimpleServiceLocator.inventoryUtilFactory.getInventoryUtil((IInventory) adjacent.tileEntity) instanceof ISpecialInsertion)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (ICraftingRecipeProvider provider : SimpleServiceLocator.craftingRecipeProviders) {\n\t\t\t\tif (provider.canOpenGui(adjacent.tileEntity)) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!found) {\n\t\t\t\tfound = (adjacent.tileEntity instanceof IInventory);\n\t\t\t}\n\n\t\t\tif (found) {\n\t\t\t\tBlock block = adjacent.tileEntity.getBlockType();\n\t\t\t\tint xCoord = adjacent.tileEntity.xCoord;\n\t\t\t\tint yCoord = adjacent.tileEntity.yCoord;\n\t\t\t\tint zCoord = adjacent.tileEntity.zCoord;\n\n\t\t\t\tif (SimpleServiceLocator.enderStorageProxy.isEnderChestBlock(block)) {\n\t\t\t\t\tSimpleServiceLocator.enderStorageProxy.openEnderChest(player.worldObj, xCoord, yCoord, zCoord, player);\n\t\t\t\t\t//@formatter:off\n\t\t\t\t\tMainProxy.sendPacketToPlayer(PacketHandler.getPacket(SlotFinderActivatePacket.class)\n\t\t\t\t\t\t\t.setTagetPosX(xCoord).setTagetPosY(yCoord).setTagetPosZ(zCoord).setSlot(getSlot()).setPacketPos(this), player);\n\t\t\t\t\t//@formatter:on\n\t\t\t\t}\n\n\t\t\t\tif (block != null) {\n\t\t\t\t\tif (block.onBlockActivated(player.worldObj, xCoord, yCoord, zCoord, player, 0, 0, 0, 0)) {\n\t\t\t\t\t\t//@formatter:off\n\t\t\t\t\t\tMainProxy.sendPacketToPlayer(PacketHandler.getPacket(SlotFinderActivatePacket.class)\n\t\t\t\t\t\t\t\t.setTagetPosX(xCoord).setTagetPosY(yCoord).setTagetPosZ(zCoord).setSlot(getSlot()).setPacketPos(this), player);\n\t\t\t\t\t\t//@formatter:on\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tplayer.inventory.currentItem = savedEquipped;\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new SlotFinderOpenGuiPacket(getId());\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\tsuper.writeData(output);\n\t\toutput.writeInt(slot);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tsuper.readData(input);\n\t\tslot = input.readInt();\n\t}\n}",
        "code_after_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate int slot;\n\n\tpublic SlotFinderOpenGuiPacket(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\t//hack to avoid wrenching blocks\n\t\tint savedEquipped = player.inventory.currentItem;\n\t\tboolean foundSlot = false;\n\t\t//try to find a empty slot\n\t\tfor (int i = 0; i < 9; i++) {\n\t\t\tif (player.inventory.getStackInSlot(i) == null) {\n\t\t\t\tfoundSlot = true;\n\t\t\t\tplayer.inventory.currentItem = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t//okay, anything that's a block?\n\t\tif (!foundSlot) {\n\t\t\tfor (int i = 0; i < 9; i++) {\n\t\t\t\tItemStack is = player.inventory.getStackInSlot(i);\n\t\t\t\tif (is.getItem() instanceof ItemBlock) {\n\t\t\t\t\tfoundSlot = true;\n\t\t\t\t\tplayer.inventory.currentItem = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//give up and select whatever is right of the current slot\n\t\tif (!foundSlot) {\n\t\t\tplayer.inventory.currentItem = (player.inventory.currentItem + 1) % 9;\n\t\t}\n\n\t\tWorldCoordinatesWrapper worldCoordinates = new WorldCoordinatesWrapper(player.worldObj, getPosX(), getPosY(), getPosZ());\n\t\tIterator<AdjacentTileEntity> adjacentIt = worldCoordinates.getConnectedAdjacentTileEntities(ConnectionPipeType.ITEM).iterator();\n\n\t\tboolean found = false;\n\t\twhile (adjacentIt.hasNext()) {\n\t\t\tAdjacentTileEntity adjacent = adjacentIt.next();\n\n\t\t\tif (adjacent.tileEntity instanceof IInventory) {\n\t\t\t\tif (!(SimpleServiceLocator.inventoryUtilFactory.getInventoryUtil((IInventory) adjacent.tileEntity) instanceof ISpecialInsertion)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (ICraftingRecipeProvider provider : SimpleServiceLocator.craftingRecipeProviders) {\n\t\t\t\tif (provider.canOpenGui(adjacent.tileEntity)) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!found) {\n\t\t\t\tfound = (adjacent.tileEntity instanceof IInventory);\n\t\t\t}\n\n\t\t\tif (found) {\n\t\t\t\tBlock block = adjacent.tileEntity.getBlockType();\n\t\t\t\tint xCoord = adjacent.tileEntity.xCoord;\n\t\t\t\tint yCoord = adjacent.tileEntity.yCoord;\n\t\t\t\tint zCoord = adjacent.tileEntity.zCoord;\n\n\t\t\t\tif (SimpleServiceLocator.enderStorageProxy.isEnderChestBlock(block)) {\n\t\t\t\t\tSimpleServiceLocator.enderStorageProxy.openEnderChest(player.worldObj, xCoord, yCoord, zCoord, player);\n\t\t\t\t\t//@formatter:off\n\t\t\t\t\tMainProxy.sendPacketToPlayer(PacketHandler.getPacket(SlotFinderActivatePacket.class)\n\t\t\t\t\t\t\t.setTagetPosX(xCoord).setTagetPosY(yCoord).setTagetPosZ(zCoord).setSlot(getSlot()).setPacketPos(this), player);\n\t\t\t\t\t//@formatter:on\n\t\t\t\t}\n\n\t\t\t\tif (block != null) {\n\t\t\t\t\tif (block.onBlockActivated(player.worldObj, xCoord, yCoord, zCoord, player, 0, 0, 0, 0)) {\n\t\t\t\t\t\t//@formatter:off\n\t\t\t\t\t\tMainProxy.sendPacketToPlayer(PacketHandler.getPacket(SlotFinderActivatePacket.class)\n\t\t\t\t\t\t\t\t.setTagetPosX(xCoord).setTagetPosY(yCoord).setTagetPosZ(zCoord).setSlot(getSlot()).setPacketPos(this), player);\n\t\t\t\t\t\t//@formatter:on\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tplayer.inventory.currentItem = savedEquipped;\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new SlotFinderOpenGuiPacket(getId());\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\tsuper.writeData(output);\n\t\toutput.writeInt(slot);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tsuper.readData(input);\n\t\tslot = input.readInt();\n\t}\n}",
        "patch": "@@ -1,6 +1,5 @@\n package logisticspipes.network.packets.pipe;\n \n-import java.io.IOException;\n import java.util.Iterator;\n \n import net.minecraft.block.Block;\n@@ -122,13 +121,13 @@ public ModernPacket template() {\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\tsuper.writeData(output);\n \t\toutput.writeInt(slot);\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tsuper.readData(input);\n \t\tslot = input.readInt();\n \t}",
        "function_modified_lines": {
            "added": [
                "\tpublic void writeData(LPDataOutput output) {\n",
                "\tpublic void readData(LPDataInput input) {\n"
            ],
            "deleted": [
                "\tpublic void writeData(LPDataOutput output) throws IOException {\n",
                "\tpublic void readData(LPDataInput input) throws IOException {\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-502"
        ],
        "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
        "id": 12821
    },
    {
        "cve_id": "CVE-2023-38689",
        "code_before_change": "{\n\n\tpublic ItemBufferSyncPacket(int id, int x, int y, int z) {\n\t\tsuper(id, x, y, z);\n\t}\n\n\tpublic ItemBufferSyncPacket(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void writeObject(LPDataOutput output,\n\t\t\tTriplet<ItemIdentifierStack, Pair<Integer /* Time */, Integer /* BufferCounter */>, LPTravelingItemServer> object) throws IOException {\n\t\toutput.writeItemIdentifierStack(object.getValue1());\n\t}\n\n\t@Override\n\tpublic Triplet<ItemIdentifierStack, Pair<Integer /* Time */, Integer /* BufferCounter */>, LPTravelingItemServer> readObject(LPDataInput input)\n\t\t\tthrows IOException {\n\t\treturn new Triplet<>(input.readItemIdentifierStack(), null, null);\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tLogisticsTileGenericPipe pipe = this.getPipe(player.getEntityWorld());\n\t\tif (pipe == null || pipe.pipe == null || pipe.pipe.transport == null) {\n\t\t\treturn;\n\t\t}\n\t\tpipe.pipe.transport._itemBuffer.clear();\n\t\tpipe.pipe.transport._itemBuffer.addAll(getList());\n\t}\n\n\t@Override\n\tpublic ItemBufferSyncPacket template() {\n\t\treturn new ItemBufferSyncPacket(getId(), getPosX(), getPosY(), getPosZ());\n\t}\n}",
        "code_after_change": "{\n\n\tpublic ItemBufferSyncPacket(int id, int x, int y, int z) {\n\t\tsuper(id, x, y, z);\n\t}\n\n\tpublic ItemBufferSyncPacket(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void writeObject(LPDataOutput output,\n\t\t\tTriplet<ItemIdentifierStack, Pair<Integer /* Time */, Integer /* BufferCounter */>, LPTravelingItemServer> object) {\n\t\toutput.writeItemIdentifierStack(object.getValue1());\n\t}\n\n\t@Override\n\tpublic Triplet<ItemIdentifierStack, Pair<Integer /* Time */, Integer /* BufferCounter */>, LPTravelingItemServer> readObject(LPDataInput input) {\n\t\treturn new Triplet<>(input.readItemIdentifierStack(), null, null);\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tLogisticsTileGenericPipe pipe = this.getPipe(player.getEntityWorld());\n\t\tif (pipe == null || pipe.pipe == null || pipe.pipe.transport == null) {\n\t\t\treturn;\n\t\t}\n\t\tpipe.pipe.transport._itemBuffer.clear();\n\t\tpipe.pipe.transport._itemBuffer.addAll(getList());\n\t}\n\n\t@Override\n\tpublic ItemBufferSyncPacket template() {\n\t\treturn new ItemBufferSyncPacket(getId(), getPosX(), getPosY(), getPosZ());\n\t}\n}",
        "patch": "@@ -1,7 +1,5 @@\n package logisticspipes.network.packets.pipe;\n \n-import java.io.IOException;\n-\n import net.minecraft.entity.player.EntityPlayer;\n \n import logisticspipes.network.abstractpackets.ListSyncPacket;\n@@ -26,13 +24,12 @@ public ItemBufferSyncPacket(int id) {\n \n \t@Override\n \tpublic void writeObject(LPDataOutput output,\n-\t\t\tTriplet<ItemIdentifierStack, Pair<Integer /* Time */, Integer /* BufferCounter */>, LPTravelingItemServer> object) throws IOException {\n+\t\t\tTriplet<ItemIdentifierStack, Pair<Integer /* Time */, Integer /* BufferCounter */>, LPTravelingItemServer> object) {\n \t\toutput.writeItemIdentifierStack(object.getValue1());\n \t}\n \n \t@Override\n-\tpublic Triplet<ItemIdentifierStack, Pair<Integer /* Time */, Integer /* BufferCounter */>, LPTravelingItemServer> readObject(LPDataInput input)\n-\t\t\tthrows IOException {\n+\tpublic Triplet<ItemIdentifierStack, Pair<Integer /* Time */, Integer /* BufferCounter */>, LPTravelingItemServer> readObject(LPDataInput input) {\n \t\treturn new Triplet<>(input.readItemIdentifierStack(), null, null);\n \t}\n ",
        "function_modified_lines": {
            "added": [
                "\t\t\tTriplet<ItemIdentifierStack, Pair<Integer /* Time */, Integer /* BufferCounter */>, LPTravelingItemServer> object) {\n",
                "\tpublic Triplet<ItemIdentifierStack, Pair<Integer /* Time */, Integer /* BufferCounter */>, LPTravelingItemServer> readObject(LPDataInput input) {\n"
            ],
            "deleted": [
                "\t\t\tTriplet<ItemIdentifierStack, Pair<Integer /* Time */, Integer /* BufferCounter */>, LPTravelingItemServer> object) throws IOException {\n",
                "\tpublic Triplet<ItemIdentifierStack, Pair<Integer /* Time */, Integer /* BufferCounter */>, LPTravelingItemServer> readObject(LPDataInput input)\n",
                "\t\t\tthrows IOException {\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-502"
        ],
        "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
        "id": 12815
    },
    {
        "cve_id": "CVE-2023-38689",
        "code_before_change": "{\n\n\tpublic int everyNthTick = 20 * 60;\n\tpublic ItemIdentifier item;\n\tpublic int arrayPos = 0;\n\tpublic long[] amountRecorded = new long[1440]; //24h with 20ticks and 60sec\n\n\tpublic void tick(int tickCount, CoreRoutedPipe pipe) {\n\t\tif (tickCount % everyNthTick != 0) {\n\t\t\treturn;\n\t\t}\n\t\tIRouter router = pipe.getRouter();\n\t\tif (router == null) {\n\t\t\treturn;\n\t\t}\n\t\tamountRecorded[arrayPos++] = SimpleServiceLocator.logisticsManager.getAmountFor(item, router.getIRoutersByCost());\n\t\tif (arrayPos >= amountRecorded.length) {\n\t\t\tarrayPos = 0;\n\t\t}\n\t}\n\n\tpublic void readFromNBT(NBTTagCompound nbt) {\n\t\tint[] amountRecorded_A = nbt.getIntArray(\"amountRecorded_A\");\n\t\tint[] amountRecorded_B = nbt.getIntArray(\"amountRecorded_B\");\n\t\tfor (int i = 0; i < amountRecorded.length; i++) {\n\t\t\tif (i >= amountRecorded_A.length || i >= amountRecorded_B.length) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tamountRecorded[i] = (((long) amountRecorded_B[i]) << 32) | amountRecorded_A[i];\n\t\t}\n\t\tarrayPos = nbt.getInteger(\"arrayPos\");\n\t\titem = ItemIdentifier.get(ItemStack.loadItemStackFromNBT(nbt));\n\t}\n\n\tpublic void writeToNBT(NBTTagCompound nbt) {\n\t\tint[] amountRecorded_A = new int[amountRecorded.length];\n\t\tint[] amountRecorded_B = new int[amountRecorded.length];\n\t\tfor (int i = 0; i < amountRecorded.length; i++) {\n\t\t\tamountRecorded_A[i] = (int) amountRecorded[i];\n\t\t\tamountRecorded_B[i] = (int) (amountRecorded[i] >> 32);\n\t\t}\n\t\tnbt.setIntArray(\"amountRecorded_A\", amountRecorded_A);\n\t\tnbt.setIntArray(\"amountRecorded_B\", amountRecorded_B);\n\t\tnbt.setInteger(\"arrayPos\", arrayPos);\n\t\titem.makeNormalStack(1).writeToNBT(nbt);\n\t}\n\n\tpublic void writeToLPData(LPDataOutput output) throws IOException {\n\t\toutput.writeLongArray(amountRecorded);\n\t\toutput.writeInt(arrayPos);\n\t\toutput.writeItemIdentifier(item);\n\t}\n\n\tpublic void readFromLPData(LPDataInput input) throws IOException {\n\t\tamountRecorded = input.readLongArray();\n\t\tarrayPos = input.readInt();\n\t\titem = input.readItemIdentifier();\n\t}\n}",
        "code_after_change": "{\n\n\tpublic int everyNthTick = 20 * 60;\n\tpublic ItemIdentifier item;\n\tpublic int arrayPos = 0;\n\tpublic long[] amountRecorded = new long[1440]; //24h with 20ticks and 60sec\n\n\tpublic void tick(int tickCount, CoreRoutedPipe pipe) {\n\t\tif (tickCount % everyNthTick != 0) {\n\t\t\treturn;\n\t\t}\n\t\tIRouter router = pipe.getRouter();\n\t\tif (router == null) {\n\t\t\treturn;\n\t\t}\n\t\tamountRecorded[arrayPos++] = SimpleServiceLocator.logisticsManager.getAmountFor(item, router.getIRoutersByCost());\n\t\tif (arrayPos >= amountRecorded.length) {\n\t\t\tarrayPos = 0;\n\t\t}\n\t}\n\n\tpublic void readFromNBT(NBTTagCompound nbt) {\n\t\tint[] amountRecorded_A = nbt.getIntArray(\"amountRecorded_A\");\n\t\tint[] amountRecorded_B = nbt.getIntArray(\"amountRecorded_B\");\n\t\tfor (int i = 0; i < amountRecorded.length; i++) {\n\t\t\tif (i >= amountRecorded_A.length || i >= amountRecorded_B.length) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tamountRecorded[i] = (((long) amountRecorded_B[i]) << 32) | amountRecorded_A[i];\n\t\t}\n\t\tarrayPos = nbt.getInteger(\"arrayPos\");\n\t\titem = ItemIdentifier.get(ItemStack.loadItemStackFromNBT(nbt));\n\t}\n\n\tpublic void writeToNBT(NBTTagCompound nbt) {\n\t\tint[] amountRecorded_A = new int[amountRecorded.length];\n\t\tint[] amountRecorded_B = new int[amountRecorded.length];\n\t\tfor (int i = 0; i < amountRecorded.length; i++) {\n\t\t\tamountRecorded_A[i] = (int) amountRecorded[i];\n\t\t\tamountRecorded_B[i] = (int) (amountRecorded[i] >> 32);\n\t\t}\n\t\tnbt.setIntArray(\"amountRecorded_A\", amountRecorded_A);\n\t\tnbt.setIntArray(\"amountRecorded_B\", amountRecorded_B);\n\t\tnbt.setInteger(\"arrayPos\", arrayPos);\n\t\titem.makeNormalStack(1).writeToNBT(nbt);\n\t}\n\n\tpublic void writeToLPData(LPDataOutput output) {\n\t\toutput.writeLongArray(amountRecorded);\n\t\toutput.writeInt(arrayPos);\n\t\toutput.writeItemIdentifier(item);\n\t}\n\n\tpublic void readFromLPData(LPDataInput input) {\n\t\tamountRecorded = input.readLongArray();\n\t\tarrayPos = input.readInt();\n\t\titem = input.readItemIdentifier();\n\t}\n}",
        "patch": "@@ -1,7 +1,5 @@\n package logisticspipes.blocks.stats;\n \n-import java.io.IOException;\n-\n import net.minecraft.item.ItemStack;\n import net.minecraft.nbt.NBTTagCompound;\n \n@@ -59,13 +57,13 @@ public void writeToNBT(NBTTagCompound nbt) {\n \t\titem.makeNormalStack(1).writeToNBT(nbt);\n \t}\n \n-\tpublic void writeToLPData(LPDataOutput output) throws IOException {\n+\tpublic void writeToLPData(LPDataOutput output) {\n \t\toutput.writeLongArray(amountRecorded);\n \t\toutput.writeInt(arrayPos);\n \t\toutput.writeItemIdentifier(item);\n \t}\n \n-\tpublic void readFromLPData(LPDataInput input) throws IOException {\n+\tpublic void readFromLPData(LPDataInput input) {\n \t\tamountRecorded = input.readLongArray();\n \t\tarrayPos = input.readInt();\n \t\titem = input.readItemIdentifier();",
        "function_modified_lines": {
            "added": [
                "\tpublic void writeToLPData(LPDataOutput output) {\n",
                "\tpublic void readFromLPData(LPDataInput input) {\n"
            ],
            "deleted": [
                "\tpublic void writeToLPData(LPDataOutput output) throws IOException {\n",
                "\tpublic void readFromLPData(LPDataInput input) throws IOException {\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-502"
        ],
        "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
        "id": 12758
    },
    {
        "cve_id": "CVE-2023-38689",
        "code_before_change": "{\n\n\tpublic PlayerListRequest(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new PlayerListRequest(getId());\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tStream<?> allPlayers = Arrays.stream(DimensionManager.getWorlds()).map(worldServer -> worldServer.playerEntities).flatMap(Collection::stream);\n\t\tStream<EntityPlayer> allPlayerEntities = allPlayers.filter(o -> o instanceof EntityPlayer).map(o -> (EntityPlayer) o);\n\t\tMainProxy.sendPacketToPlayer(PacketHandler.getPacket(PlayerList.class)\n\t\t\t\t.setStringList(allPlayerEntities.map(entityPlayer -> entityPlayer.getGameProfile().getName()).collect(Collectors.toList())), player);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {}\n}",
        "code_after_change": "{\n\n\tpublic PlayerListRequest(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new PlayerListRequest(getId());\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tStream<?> allPlayers = Arrays.stream(DimensionManager.getWorlds()).map(worldServer -> worldServer.playerEntities).flatMap(Collection::stream);\n\t\tStream<EntityPlayer> allPlayerEntities = allPlayers.filter(o -> o instanceof EntityPlayer).map(o -> (EntityPlayer) o);\n\t\tMainProxy.sendPacketToPlayer(PacketHandler.getPacket(PlayerList.class)\n\t\t\t\t.setStringList(allPlayerEntities.map(entityPlayer -> entityPlayer.getGameProfile().getName()).collect(Collectors.toList())), player);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {}\n}",
        "patch": "@@ -1,6 +1,5 @@\n package logisticspipes.network.packets;\n \n-import java.io.IOException;\n import java.util.Arrays;\n import java.util.Collection;\n import java.util.stream.Collectors;\n@@ -35,8 +34,8 @@ public void processPacket(EntityPlayer player) {\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {}\n+\tpublic void readData(LPDataInput input) {}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {}\n+\tpublic void writeData(LPDataOutput output) {}\n }",
        "function_modified_lines": {
            "added": [
                "\tpublic void readData(LPDataInput input) {}\n",
                "\tpublic void writeData(LPDataOutput output) {}\n"
            ],
            "deleted": [
                "\tpublic void readData(LPDataInput input) throws IOException {}\n",
                "\tpublic void writeData(LPDataOutput output) throws IOException {}\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-502"
        ],
        "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
        "id": 12788
    },
    {
        "cve_id": "CVE-2023-38689",
        "code_before_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate int windowID;\n\n\t@Getter\n\t@Setter\n\tprivate String line;\n\n\tpublic SendNewLogLine(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\twindowID = input.readInt();\n\t\tline = input.readUTF();\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tLogWindow.getWindow(windowID).newLine(line);\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\toutput.writeInt(windowID);\n\t\toutput.writeUTF(line);\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new SendNewLogLine(getId());\n\t}\n\n\t@Override\n\tpublic boolean isCompressable() {\n\t\treturn true;\n\t}\n}",
        "code_after_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate int windowID;\n\n\t@Getter\n\t@Setter\n\tprivate String line;\n\n\tpublic SendNewLogLine(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\twindowID = input.readInt();\n\t\tline = input.readUTF();\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tLogWindow.getWindow(windowID).newLine(line);\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\toutput.writeInt(windowID);\n\t\toutput.writeUTF(line);\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new SendNewLogLine(getId());\n\t}\n\n\t@Override\n\tpublic boolean isCompressable() {\n\t\treturn true;\n\t}\n}",
        "patch": "@@ -1,7 +1,5 @@\n package logisticspipes.network.packets.debug;\n \n-import java.io.IOException;\n-\n import net.minecraft.entity.player.EntityPlayer;\n \n import lombok.Getter;\n@@ -27,7 +25,7 @@ public SendNewLogLine(int id) {\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\twindowID = input.readInt();\n \t\tline = input.readUTF();\n \t}\n@@ -38,7 +36,7 @@ public void processPacket(EntityPlayer player) {\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\toutput.writeInt(windowID);\n \t\toutput.writeUTF(line);\n \t}",
        "function_modified_lines": {
            "added": [
                "\tpublic void readData(LPDataInput input) {\n",
                "\tpublic void writeData(LPDataOutput output) {\n"
            ],
            "deleted": [
                "\tpublic void readData(LPDataInput input) throws IOException {\n",
                "\tpublic void writeData(LPDataOutput output) throws IOException {\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-502"
        ],
        "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
        "id": 12800
    },
    {
        "cve_id": "CVE-2023-38689",
        "code_before_change": "{\n\n\tprivate int mask = 0;\n\tprivate int isBCPipeMask = 0;\n\tprivate int isTDPipeMask = 0;\n\tprivate boolean dirty = false;\n\n\tpublic boolean isConnected(ForgeDirection direction) {\n\t\t// test if the direction.ordinal()'th bit of mask is set\n\t\treturn (mask & (1 << direction.ordinal())) != 0;\n\t}\n\n\tpublic void setConnected(ForgeDirection direction, boolean value) {\n\t\tif (isConnected(direction) != value) {\n\t\t\t// invert the direction.ordinal()'th bit of mask\n\t\t\tmask ^= 1 << direction.ordinal();\n\t\t\tdirty = true;\n\t\t}\n\t\tif (!value) {\n\t\t\tsetBCConnected(direction, false);\n\t\t\tsetTDConnected(direction, false);\n\t\t}\n\t}\n\n\tpublic boolean isBCConnected(ForgeDirection direction) {\n\t\t// test if the direction.ordinal()'th bit of mask is set\n\t\treturn (isBCPipeMask & (1 << direction.ordinal())) != 0;\n\t}\n\n\tpublic void setBCConnected(ForgeDirection direction, boolean value) {\n\t\tif (isBCConnected(direction) != value) {\n\t\t\t// invert the direction.ordinal()'th bit of mask\n\t\t\tisBCPipeMask ^= 1 << direction.ordinal();\n\t\t\tdirty = true;\n\t\t}\n\t}\n\n\tpublic boolean isTDConnected(ForgeDirection direction) {\n\t\t// test if the direction.ordinal()'th bit of mask is set\n\t\treturn (isTDPipeMask & (1 << direction.ordinal())) != 0;\n\t}\n\n\tpublic void setTDConnected(ForgeDirection direction, boolean value) {\n\t\tif (isTDConnected(direction) != value) {\n\t\t\t// invert the direction.ordinal()'th bit of mask\n\t\t\tisTDPipeMask ^= 1 << direction.ordinal();\n\t\t\tdirty = true;\n\t\t}\n\t}\n\n\t/**\n\t * Return a mask representing the connectivity for all sides.\n\t *\n\t * @return mask in ForgeDirection order, least significant bit = first entry\n\t */\n\tpublic int getMask() {\n\t\treturn mask;\n\t}\n\n\tpublic boolean isDirty() {\n\t\treturn dirty;\n\t}\n\n\tpublic void clean() {\n\t\tdirty = false;\n\t}\n\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\toutput.writeByte(mask);\n\t\toutput.writeByte(isBCPipeMask);\n\t\toutput.writeByte(isTDPipeMask);\n\t}\n\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tbyte newMask = input.readByte();\n\n\t\tif (newMask != mask) {\n\t\t\tmask = newMask;\n\t\t\tdirty = true;\n\t\t}\n\n\t\tnewMask = input.readByte();\n\t\tif (newMask != isBCPipeMask) {\n\t\t\tisBCPipeMask = newMask;\n\t\t\tdirty = true;\n\t\t}\n\n\t\tnewMask = input.readByte();\n\t\tif (newMask != isTDPipeMask) {\n\t\t\tisTDPipeMask = newMask;\n\t\t\tdirty = true;\n\t\t}\n\t}\n}",
        "code_after_change": "{\n\n\tprivate int mask = 0;\n\tprivate int isBCPipeMask = 0;\n\tprivate int isTDPipeMask = 0;\n\tprivate boolean dirty = false;\n\n\tpublic boolean isConnected(ForgeDirection direction) {\n\t\t// test if the direction.ordinal()'th bit of mask is set\n\t\treturn (mask & (1 << direction.ordinal())) != 0;\n\t}\n\n\tpublic void setConnected(ForgeDirection direction, boolean value) {\n\t\tif (isConnected(direction) != value) {\n\t\t\t// invert the direction.ordinal()'th bit of mask\n\t\t\tmask ^= 1 << direction.ordinal();\n\t\t\tdirty = true;\n\t\t}\n\t\tif (!value) {\n\t\t\tsetBCConnected(direction, false);\n\t\t\tsetTDConnected(direction, false);\n\t\t}\n\t}\n\n\tpublic boolean isBCConnected(ForgeDirection direction) {\n\t\t// test if the direction.ordinal()'th bit of mask is set\n\t\treturn (isBCPipeMask & (1 << direction.ordinal())) != 0;\n\t}\n\n\tpublic void setBCConnected(ForgeDirection direction, boolean value) {\n\t\tif (isBCConnected(direction) != value) {\n\t\t\t// invert the direction.ordinal()'th bit of mask\n\t\t\tisBCPipeMask ^= 1 << direction.ordinal();\n\t\t\tdirty = true;\n\t\t}\n\t}\n\n\tpublic boolean isTDConnected(ForgeDirection direction) {\n\t\t// test if the direction.ordinal()'th bit of mask is set\n\t\treturn (isTDPipeMask & (1 << direction.ordinal())) != 0;\n\t}\n\n\tpublic void setTDConnected(ForgeDirection direction, boolean value) {\n\t\tif (isTDConnected(direction) != value) {\n\t\t\t// invert the direction.ordinal()'th bit of mask\n\t\t\tisTDPipeMask ^= 1 << direction.ordinal();\n\t\t\tdirty = true;\n\t\t}\n\t}\n\n\t/**\n\t * Return a mask representing the connectivity for all sides.\n\t *\n\t * @return mask in ForgeDirection order, least significant bit = first entry\n\t */\n\tpublic int getMask() {\n\t\treturn mask;\n\t}\n\n\tpublic boolean isDirty() {\n\t\treturn dirty;\n\t}\n\n\tpublic void clean() {\n\t\tdirty = false;\n\t}\n\n\tpublic void writeData(LPDataOutput output) {\n\t\toutput.writeByte(mask);\n\t\toutput.writeByte(isBCPipeMask);\n\t\toutput.writeByte(isTDPipeMask);\n\t}\n\n\tpublic void readData(LPDataInput input) {\n\t\tbyte newMask = input.readByte();\n\n\t\tif (newMask != mask) {\n\t\t\tmask = newMask;\n\t\t\tdirty = true;\n\t\t}\n\n\t\tnewMask = input.readByte();\n\t\tif (newMask != isBCPipeMask) {\n\t\t\tisBCPipeMask = newMask;\n\t\t\tdirty = true;\n\t\t}\n\n\t\tnewMask = input.readByte();\n\t\tif (newMask != isTDPipeMask) {\n\t\t\tisTDPipeMask = newMask;\n\t\t\tdirty = true;\n\t\t}\n\t}\n}",
        "patch": "@@ -1,7 +1,5 @@\n package logisticspipes.renderer.state;\n \n-import java.io.IOException;\n-\n import net.minecraftforge.common.util.ForgeDirection;\n \n import network.rs485.logisticspipes.util.LPDataInput;\n@@ -74,13 +72,13 @@ public void clean() {\n \t\tdirty = false;\n \t}\n \n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\toutput.writeByte(mask);\n \t\toutput.writeByte(isBCPipeMask);\n \t\toutput.writeByte(isTDPipeMask);\n \t}\n \n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tbyte newMask = input.readByte();\n \n \t\tif (newMask != mask) {",
        "function_modified_lines": {
            "added": [
                "\tpublic void writeData(LPDataOutput output) {\n",
                "\tpublic void readData(LPDataInput input) {\n"
            ],
            "deleted": [
                "\tpublic void writeData(LPDataOutput output) throws IOException {\n",
                "\tpublic void readData(LPDataInput input) throws IOException {\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-502"
        ],
        "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
        "id": 12837
    },
    {
        "cve_id": "CVE-2023-38689",
        "code_before_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate int integer;\n\n\tpublic IntegerCoordinatesPacket(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tsuper.readData(input);\n\t\tsetInteger(input.readInt());\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\tsuper.writeData(output);\n\t\toutput.writeInt(getInteger());\n\t}\n}",
        "code_after_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate int integer;\n\n\tpublic IntegerCoordinatesPacket(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tsuper.readData(input);\n\t\tsetInteger(input.readInt());\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\tsuper.writeData(output);\n\t\toutput.writeInt(getInteger());\n\t}\n}",
        "patch": "@@ -1,7 +1,5 @@\n package logisticspipes.network.abstractpackets;\n \n-import java.io.IOException;\n-\n import lombok.Getter;\n import lombok.Setter;\n \n@@ -19,13 +17,13 @@ public IntegerCoordinatesPacket(int id) {\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tsuper.readData(input);\n \t\tsetInteger(input.readInt());\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\tsuper.writeData(output);\n \t\toutput.writeInt(getInteger());\n \t}",
        "function_modified_lines": {
            "added": [
                "\tpublic void readData(LPDataInput input) {\n",
                "\tpublic void writeData(LPDataOutput output) {\n"
            ],
            "deleted": [
                "\tpublic void readData(LPDataInput input) throws IOException {\n",
                "\tpublic void writeData(LPDataOutput output) throws IOException {\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-502"
        ],
        "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
        "id": 12775
    },
    {
        "cve_id": "CVE-2023-38689",
        "code_before_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate ItemIdentifier ident;\n\n\t@Getter\n\t@Setter\n\tprivate String name;\n\n\tpublic UpdateName(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new UpdateName(getId());\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tif (MainProxy.isClient(player.worldObj)) {\n\t\t\tMainProxy.sendPacketToServer(PacketHandler.getPacket(UpdateName.class).setIdent(getIdent()).setName(getIdent().getFriendlyName()));\n\t\t} else {\n\t\t\tMainProxy.proxy.updateNames(getIdent(), getName());\n\t\t}\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) throws IOException {\n\t\tident = input.readItemIdentifierStack().getItem();\n\t\tname = input.readUTF();\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) throws IOException {\n\t\toutput.writeItemIdentifierStack(ident.makeStack(0));\n\t\toutput.writeUTF(name);\n\t}\n\n\t@Override\n\tpublic boolean isCompressable() {\n\t\treturn true;\n\t}\n}",
        "code_after_change": "{\n\n\t@Getter\n\t@Setter\n\tprivate ItemIdentifier ident;\n\n\t@Getter\n\t@Setter\n\tprivate String name;\n\n\tpublic UpdateName(int id) {\n\t\tsuper(id);\n\t}\n\n\t@Override\n\tpublic ModernPacket template() {\n\t\treturn new UpdateName(getId());\n\t}\n\n\t@Override\n\tpublic void processPacket(EntityPlayer player) {\n\t\tif (MainProxy.isClient(player.worldObj)) {\n\t\t\tMainProxy.sendPacketToServer(PacketHandler.getPacket(UpdateName.class).setIdent(getIdent()).setName(getIdent().getFriendlyName()));\n\t\t} else {\n\t\t\tMainProxy.proxy.updateNames(getIdent(), getName());\n\t\t}\n\t}\n\n\t@Override\n\tpublic void readData(LPDataInput input) {\n\t\tident = input.readItemIdentifierStack().getItem();\n\t\tname = input.readUTF();\n\t}\n\n\t@Override\n\tpublic void writeData(LPDataOutput output) {\n\t\toutput.writeItemIdentifierStack(ident.makeStack(0));\n\t\toutput.writeUTF(name);\n\t}\n\n\t@Override\n\tpublic boolean isCompressable() {\n\t\treturn true;\n\t}\n}",
        "patch": "@@ -1,7 +1,5 @@\n package logisticspipes.network.packets;\n \n-import java.io.IOException;\n-\n import net.minecraft.entity.player.EntityPlayer;\n \n import lombok.Getter;\n@@ -43,13 +41,13 @@ public void processPacket(EntityPlayer player) {\n \t}\n \n \t@Override\n-\tpublic void readData(LPDataInput input) throws IOException {\n+\tpublic void readData(LPDataInput input) {\n \t\tident = input.readItemIdentifierStack().getItem();\n \t\tname = input.readUTF();\n \t}\n \n \t@Override\n-\tpublic void writeData(LPDataOutput output) throws IOException {\n+\tpublic void writeData(LPDataOutput output) {\n \t\toutput.writeItemIdentifierStack(ident.makeStack(0));\n \t\toutput.writeUTF(name);\n \t}",
        "function_modified_lines": {
            "added": [
                "\tpublic void readData(LPDataInput input) {\n",
                "\tpublic void writeData(LPDataOutput output) {\n"
            ],
            "deleted": [
                "\tpublic void readData(LPDataInput input) throws IOException {\n",
                "\tpublic void writeData(LPDataOutput output) throws IOException {\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-502"
        ],
        "cve_description": "Logistics Pipes is a modification (a.k.a. mod) for the computer game Minecraft Java Edition. The mod used Java's `ObjectInputStream#readObject` on untrusted data coming from clients or servers over the network resulting in possible remote code execution when sending specifically crafted network packets after connecting. The affected versions were released between 2013 and 2016 and the issue (back then unknown) was fixed in 2016 by a refactoring of the network IO code.  \nThe issue is present in all Logistics Pipes versions ranged from 0.7.0.91 prior to 0.10.0.71, which were downloaded from different platforms summing up to multi-million downloads. For Minecraft version 1.7.10 the issue was fixed in build 0.10.0.71. Everybody on Minecraft 1.7.10 should check their version number of Logistics Pipes in their modlist and update, if the version number is smaller than 0.10.0.71. Any newer supported Minecraft version (like 1.12.2) never had a Logistics Pipes version with vulnerable code. The best available workaround for vulnerable versions is to play in singleplayer only or update to newer Minecraft versions and modpacks.",
        "id": 12789
    },
    {
        "cve_id": "CVE-2023-42809",
        "code_before_change": "/**\n * Copyright (c) 2013-2022 Nikita Koksharov\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.redisson.codec;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\n\nimport org.redisson.client.codec.BaseCodec;\nimport org.redisson.client.handler.State;\nimport org.redisson.client.protocol.Decoder;\nimport org.redisson.client.protocol.Encoder;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.ByteBufAllocator;\nimport io.netty.buffer.ByteBufInputStream;\nimport io.netty.buffer.ByteBufOutputStream;\n\n/**\n * JDK's serialization codec.\n * <p>\n * Fully thread-safe.*\n *\n * @author Nikita Koksharov\n *\n */\npublic class SerializationCodec extends BaseCodec {\n\n    private final Decoder<Object> decoder = new Decoder<Object>() {\n        @Override\n        public Object decode(ByteBuf buf, State state) throws IOException {\n            try {\n                //set thread context class loader to be the classLoader variable as there could be reflection\n                //done while reading from input stream which reflection will use thread class loader to load classes on demand\n                ClassLoader currentThreadClassLoader = Thread.currentThread().getContextClassLoader();\n                try {\n                    ByteBufInputStream in = new ByteBufInputStream(buf);\n                    ObjectInputStream inputStream;\n                    if (classLoader != null) {\n                        Thread.currentThread().setContextClassLoader(classLoader);\n                        inputStream = new CustomObjectInputStream(classLoader, in);\n                    } else {\n                        inputStream = new ObjectInputStream(in);\n                    }\n                    return inputStream.readObject();\n                } finally {\n                    Thread.currentThread().setContextClassLoader(currentThreadClassLoader);\n                }\n            } catch (IOException e) {\n                throw e;\n            } catch (Exception e) {\n                throw new IOException(e);\n            }\n        }\n    };\n\n    private final Encoder encoder = new Encoder() {\n\n        @Override\n        public ByteBuf encode(Object in) throws IOException {\n            ByteBuf out = ByteBufAllocator.DEFAULT.buffer();\n            try {\n                ByteBufOutputStream result = new ByteBufOutputStream(out);\n                ObjectOutputStream outputStream = new ObjectOutputStream(result);\n                outputStream.writeObject(in);\n                outputStream.close();\n                return result.buffer();\n            } catch (IOException e) {\n                out.release();\n                throw e;\n            }\n        }\n    };\n    \n    private final ClassLoader classLoader;\n\n    public SerializationCodec() {\n        this(null);\n    }\n    \n    public SerializationCodec(ClassLoader classLoader) {\n        this.classLoader = classLoader;\n    }\n\n    public SerializationCodec(ClassLoader classLoader, SerializationCodec codec) {\n        this.classLoader = classLoader;\n    }\n    \n    @Override\n    public Decoder<Object> getValueDecoder() {\n        return decoder;\n    }\n\n    @Override\n    public Encoder getValueEncoder() {\n        return encoder;\n    }\n    \n    @Override\n    public ClassLoader getClassLoader() {\n        if (classLoader != null) {\n            return classLoader;\n        }\n        return getClass().getClassLoader();\n    }\n\n}\n",
        "code_after_change": "/**\n * Copyright (c) 2013-2022 Nikita Koksharov\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.redisson.codec;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.ByteBufAllocator;\nimport io.netty.buffer.ByteBufInputStream;\nimport io.netty.buffer.ByteBufOutputStream;\nimport org.redisson.client.codec.BaseCodec;\nimport org.redisson.client.handler.State;\nimport org.redisson.client.protocol.Decoder;\nimport org.redisson.client.protocol.Encoder;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.util.Set;\n\n/**\n * JDK's serialization codec.\n * <p>\n * Fully thread-safe.*\n *\n * @author Nikita Koksharov\n *\n */\npublic class SerializationCodec extends BaseCodec {\n\n    private final Decoder<Object> decoder = new Decoder<Object>() {\n        @Override\n        public Object decode(ByteBuf buf, State state) throws IOException {\n            try {\n                //set thread context class loader to be the classLoader variable as there could be reflection\n                //done while reading from input stream which reflection will use thread class loader to load classes on demand\n                ClassLoader currentThreadClassLoader = Thread.currentThread().getContextClassLoader();\n                try {\n                    ByteBufInputStream in = new ByteBufInputStream(buf);\n                    ObjectInputStream inputStream;\n                    if (classLoader != null) {\n                        Thread.currentThread().setContextClassLoader(classLoader);\n                        inputStream = new CustomObjectInputStream(classLoader, in, allowedClasses);\n                    } else {\n                        inputStream = new ObjectInputStream(in);\n                    }\n                    return inputStream.readObject();\n                } finally {\n                    Thread.currentThread().setContextClassLoader(currentThreadClassLoader);\n                }\n            } catch (IOException e) {\n                throw e;\n            } catch (Exception e) {\n                throw new IOException(e);\n            }\n        }\n    };\n\n    private final Encoder encoder = new Encoder() {\n\n        @Override\n        public ByteBuf encode(Object in) throws IOException {\n            ByteBuf out = ByteBufAllocator.DEFAULT.buffer();\n            try {\n                ByteBufOutputStream result = new ByteBufOutputStream(out);\n                ObjectOutputStream outputStream = new ObjectOutputStream(result);\n                outputStream.writeObject(in);\n                outputStream.close();\n                return result.buffer();\n            } catch (IOException e) {\n                out.release();\n                throw e;\n            }\n        }\n    };\n\n    private Set<String> allowedClasses;\n    private final ClassLoader classLoader;\n\n    public SerializationCodec() {\n        this(null);\n    }\n    \n    public SerializationCodec(ClassLoader classLoader) {\n        this.classLoader = classLoader;\n    }\n\n    public SerializationCodec(ClassLoader classLoader, SerializationCodec codec) {\n        this.classLoader = classLoader;\n        this.allowedClasses = codec.allowedClasses;\n    }\n\n    public SerializationCodec(ClassLoader classLoader, Set<String> allowedClasses) {\n        this.classLoader = classLoader;\n        this.allowedClasses = allowedClasses;\n    }\n    \n    @Override\n    public Decoder<Object> getValueDecoder() {\n        return decoder;\n    }\n\n    @Override\n    public Encoder getValueEncoder() {\n        return encoder;\n    }\n    \n    @Override\n    public ClassLoader getClassLoader() {\n        if (classLoader != null) {\n            return classLoader;\n        }\n        return getClass().getClassLoader();\n    }\n\n}\n",
        "patch": "@@ -15,19 +15,19 @@\n  */\n package org.redisson.codec;\n \n-import java.io.IOException;\n-import java.io.ObjectInputStream;\n-import java.io.ObjectOutputStream;\n-\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.buffer.ByteBufInputStream;\n+import io.netty.buffer.ByteBufOutputStream;\n import org.redisson.client.codec.BaseCodec;\n import org.redisson.client.handler.State;\n import org.redisson.client.protocol.Decoder;\n import org.redisson.client.protocol.Encoder;\n \n-import io.netty.buffer.ByteBuf;\n-import io.netty.buffer.ByteBufAllocator;\n-import io.netty.buffer.ByteBufInputStream;\n-import io.netty.buffer.ByteBufOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.util.Set;\n \n /**\n  * JDK's serialization codec.\n@@ -51,7 +51,7 @@ public Object decode(ByteBuf buf, State state) throws IOException {\n                     ObjectInputStream inputStream;\n                     if (classLoader != null) {\n                         Thread.currentThread().setContextClassLoader(classLoader);\n-                        inputStream = new CustomObjectInputStream(classLoader, in);\n+                        inputStream = new CustomObjectInputStream(classLoader, in, allowedClasses);\n                     } else {\n                         inputStream = new ObjectInputStream(in);\n                     }\n@@ -84,7 +84,8 @@ public ByteBuf encode(Object in) throws IOException {\n             }\n         }\n     };\n-    \n+\n+    private Set<String> allowedClasses;\n     private final ClassLoader classLoader;\n \n     public SerializationCodec() {\n@@ -97,6 +98,12 @@ public SerializationCodec(ClassLoader classLoader) {\n \n     public SerializationCodec(ClassLoader classLoader, SerializationCodec codec) {\n         this.classLoader = classLoader;\n+        this.allowedClasses = codec.allowedClasses;\n+    }\n+\n+    public SerializationCodec(ClassLoader classLoader, Set<String> allowedClasses) {\n+        this.classLoader = classLoader;\n+        this.allowedClasses = allowedClasses;\n     }\n     \n     @Override",
        "function_modified_lines": {
            "added": [
                "import io.netty.buffer.ByteBuf;\n",
                "import io.netty.buffer.ByteBufAllocator;\n",
                "import io.netty.buffer.ByteBufInputStream;\n",
                "import io.netty.buffer.ByteBufOutputStream;\n",
                "import java.io.IOException;\n",
                "import java.io.ObjectInputStream;\n",
                "import java.io.ObjectOutputStream;\n",
                "import java.util.Set;\n"
            ],
            "deleted": [
                "import java.io.IOException;\n",
                "import java.io.ObjectInputStream;\n",
                "import java.io.ObjectOutputStream;\n",
                "\n",
                "import io.netty.buffer.ByteBuf;\n",
                "import io.netty.buffer.ByteBufAllocator;\n",
                "import io.netty.buffer.ByteBufInputStream;\n",
                "import io.netty.buffer.ByteBufOutputStream;\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-502"
        ],
        "cve_description": "Redisson is a Java Redis client that uses the Netty framework. Prior to version 3.22.0, some of the messages received from the Redis server contain Java objects that the client deserializes without further validation. Attackers that manage to trick clients into communicating with a malicious server can include especially crafted objects in its responses that, once deserialized by the client, force it to execute arbitrary code. This can be abused to take control of the machine the client is running in. Version 3.22.0 contains a patch for this issue.\n\nSome post-fix advice is available. Do NOT use `Kryo5Codec` as deserialization codec, as it is still vulnerable to arbitrary object deserialization due to the `setRegistrationRequired(false)` call. On the contrary, `KryoCodec` is safe to use. The fix applied to `SerializationCodec` only consists of adding an optional allowlist of class names, even though making this behavior the default is recommended. When instantiating `SerializationCodec` please use the `SerializationCodec(ClassLoader classLoader, Set<String> allowedClasses)` constructor to restrict the allowed classes for deserialization.",
        "id": 12899
    }
]