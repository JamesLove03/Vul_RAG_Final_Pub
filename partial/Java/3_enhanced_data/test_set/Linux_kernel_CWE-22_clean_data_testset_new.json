[
    {
        "cve_id": "CVE-2018-9159",
        "code_before_change": "/*\n * Copyright 2011- Per Wendel\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage spark.examples.staticresources;\n\nimport static spark.Spark.get;\nimport static spark.Spark.staticFileLocation;\n\n/**\n * Example showing how serve static resources.\n */\npublic class StaticResources {\n\n    public static void main(String[] args) {\n\n        // Will serve all static file are under \"/public\" in classpath if the route isn't consumed by others routes.\n        staticFileLocation(\"/public\");\n\n        get(\"/hello\", (request, response) -> {\n            return \"Hello World!\";\n        });\n    }\n}\n",
        "code_after_change": "/*\n * Copyright 2011- Per Wendel\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage spark.examples.staticresources;\n\nimport static spark.Spark.get;\nimport static spark.Spark.staticFiles;\n\n/**\n * Example showing how serve static resources.\n */\npublic class StaticResources {\n\n    public static void main(String[] args) {\n\n        // Will serve all static file are under \"/public\" in classpath if the route isn't consumed by others routes.\n        staticFiles.location(\"/public\");\n\n        get(\"/hello\", (request, response) -> {\n            return \"Hello World!\";\n        });\n    }\n}\n",
        "patch": "@@ -17,7 +17,7 @@\n package spark.examples.staticresources;\n \n import static spark.Spark.get;\n-import static spark.Spark.staticFileLocation;\n+import static spark.Spark.staticFiles;\n \n /**\n  * Example showing how serve static resources.\n@@ -27,7 +27,7 @@ public class StaticResources {\n     public static void main(String[] args) {\n \n         // Will serve all static file are under \"/public\" in classpath if the route isn't consumed by others routes.\n-        staticFileLocation(\"/public\");\n+        staticFiles.location(\"/public\");\n \n         get(\"/hello\", (request, response) -> {\n             return \"Hello World!\";",
        "function_modified_lines": {
            "added": [
                "import static spark.Spark.staticFiles;\n",
                "        staticFiles.location(\"/public\");\n"
            ],
            "deleted": [
                "import static spark.Spark.staticFileLocation;\n",
                "        staticFileLocation(\"/public\");\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-22"
        ],
        "cve_description": "In Spark before 2.7.2, a remote attacker can read unintended static files via various representations of absolute or relative pathnames, as demonstrated by file: URLs and directory traversal sequences. NOTE: this product is unrelated to Ignite Realtime Spark.",
        "id": 12103
    },
    {
        "cve_id": "CVE-2021-32769",
        "code_before_change": "    }\n\n    @SuppressWarnings(\"MagicNumber\")\n    private Collection<PropertySourceLoader> evaluatePropertySourceLoaders() {\n        SoftServiceLoader<PropertySourceLoader> definitions = readPropertySourceLoaders();\n        Collection<PropertySourceLoader> allLoaders = new ArrayList<>(10);\n        definitions.collectAll(allLoaders);\n        for (PropertySourceLoader propertySourceLoader : allLoaders) {\n            Set<String> extensions = propertySourceLoader.getExtensions();\n            for (String extension : extensions) {\n                loaderByFormatMap.put(extension, propertySourceLoader);\n            }\n        }\n        return allLoaders;\n    }\n\n    private void loadPropertySourceFromLoader(String name, PropertySourceLoader propertySourceLoader, List<PropertySource> propertySources, ResourceLoader resourceLoader) {\n        Optional<PropertySource> defaultPropertySource = propertySourceLoader.load(name, resourceLoader);\n        defaultPropertySource.ifPresent(propertySources::add);\n        Set<String> activeNames = getActiveNames();\n        int i = 0;\n        for (String activeName: activeNames) {\n            Optional<PropertySource> propertySource = propertySourceLoader.loadEnv(name, resourceLoader, ActiveEnvironment.of(activeName, i));\n            propertySource.ifPresent(propertySources::add);\n            i++;\n        }\n    }\n\n    /**\n     * Read the property source.\n     *\n     * @param fileName             Name of the file to be used as property source name\n     * @param filePath             Absolute file path\n     * @param propertySourceLoader The appropriate property source loader\n     * @throws ConfigurationException If unable to find the appropriate property soruce loader for the given file\n     */\n    private Optional<Map<String, Object>> readPropertiesFromLoader(String fileName, String filePath, PropertySourceLoader propertySourceLoader) throws ConfigurationException {\n        ResourceResolver resourceResolver = new ResourceResolver();\n        Optional<ResourceLoader> resourceLoader = resourceResolver.getSupportingLoader(filePath);\n        ResourceLoader loader = resourceLoader.orElse(FileSystemResourceLoader.defaultLoader());\n        try {\n            Optional<InputStream> inputStream = loader.getResourceAsStream(filePath);\n            if (inputStream.isPresent()) {\n                return Optional.of(propertySourceLoader.read(fileName, inputStream.get()));\n            } else {\n                throw new ConfigurationException(\"Failed to read configuration file: \" + filePath);\n            }\n        } catch (IOException e) {\n            throw new ConfigurationException(\"Unsupported properties file: \" + fileName);\n        }\n    }\n\n    private EnvironmentsAndPackage getEnvironmentsAndPackage(List<String> specifiedNames) {\n        EnvironmentsAndPackage environmentsAndPackage = this.environmentsAndPackage;\n        final boolean extendedDeduction = !specifiedNames.contains(Environment.FUNCTION);\n        if (environmentsAndPackage == null) {\n            synchronized (EnvironmentsAndPackage.class) { // double check\n                environmentsAndPackage = this.environmentsAndPackage;\n                if (environmentsAndPackage == null) {\n                    environmentsAndPackage = deduceEnvironmentsAndPackage(\n                            shouldDeduceEnvironments(),\n                            extendedDeduction,\n                            extendedDeduction,\n                            !extendedDeduction\n                    );\n                    this.environmentsAndPackage = environmentsAndPackage;\n                }\n            }\n        }\n        return environmentsAndPackage;\n    }\n\n    private static EnvironmentsAndPackage deduceEnvironmentsAndPackage(\n            boolean deduceEnvironments,\n            boolean deduceComputePlatform,\n            boolean inspectTrace,",
        "code_after_change": "    }\n\n    @SuppressWarnings(\"MagicNumber\")\n    private Collection<PropertySourceLoader> evaluatePropertySourceLoaders() {\n        SoftServiceLoader<PropertySourceLoader> definitions = readPropertySourceLoaders();\n        Collection<PropertySourceLoader> allLoaders = new ArrayList<>(10);\n        definitions.collectAll(allLoaders);\n        for (PropertySourceLoader propertySourceLoader : allLoaders) {\n            Set<String> extensions = propertySourceLoader.getExtensions();\n            for (String extension : extensions) {\n                loaderByFormatMap.put(extension, propertySourceLoader);\n            }\n        }\n        return allLoaders;\n    }\n\n    private void loadPropertySourceFromLoader(String name, PropertySourceLoader propertySourceLoader, List<PropertySource> propertySources, ResourceLoader resourceLoader) {\n        Optional<PropertySource> defaultPropertySource = propertySourceLoader.load(name, resourceLoader);\n        defaultPropertySource.ifPresent(propertySources::add);\n        Set<String> activeNames = getActiveNames();\n        int i = 0;\n        for (String activeName: activeNames) {\n            Optional<PropertySource> propertySource = propertySourceLoader.loadEnv(name, resourceLoader, ActiveEnvironment.of(activeName, i));\n            propertySource.ifPresent(propertySources::add);\n            i++;\n        }\n    }\n\n    /**\n     * Read the property source.\n     *\n     * @param fileName             Name of the file to be used as property source name\n     * @param filePath             Absolute file path\n     * @param propertySourceLoader The appropriate property source loader\n     * @throws ConfigurationException If unable to find the appropriate property source loader for the given file\n     */\n    private Optional<Map<String, Object>> readPropertiesFromLoader(String fileName, String filePath, PropertySourceLoader propertySourceLoader) throws ConfigurationException {\n        ResourceLoader loader = new ResourceResolver().getSupportingLoader(filePath)\n                .orElse(FileSystemResourceLoader.defaultLoader());\n        try {\n            Optional<InputStream> inputStream = loader.getResourceAsStream(filePath);\n            if (inputStream.isPresent()) {\n                return Optional.of(propertySourceLoader.read(fileName, inputStream.get()));\n            } else {\n                throw new ConfigurationException(\"Failed to read configuration file: \" + filePath);\n            }\n        } catch (IOException e) {\n            throw new ConfigurationException(\"Unsupported properties file: \" + fileName);\n        }\n    }\n\n    private EnvironmentsAndPackage getEnvironmentsAndPackage(List<String> specifiedNames) {\n        EnvironmentsAndPackage environmentsAndPackage = this.environmentsAndPackage;\n        final boolean extendedDeduction = !specifiedNames.contains(Environment.FUNCTION);\n        if (environmentsAndPackage == null) {\n            synchronized (EnvironmentsAndPackage.class) { // double check\n                environmentsAndPackage = this.environmentsAndPackage;\n                if (environmentsAndPackage == null) {\n                    environmentsAndPackage = deduceEnvironmentsAndPackage(\n                            shouldDeduceEnvironments(),\n                            extendedDeduction,\n                            extendedDeduction,\n                            !extendedDeduction\n                    );\n                    this.environmentsAndPackage = environmentsAndPackage;\n                }\n            }\n        }\n        return environmentsAndPackage;\n    }\n\n    private static EnvironmentsAndPackage deduceEnvironmentsAndPackage(\n            boolean deduceEnvironments,\n            boolean deduceComputePlatform,\n            boolean inspectTrace,",
        "patch": "@@ -453,7 +453,7 @@ protected List<PropertySource> readPropertySourceListFromFiles(String files) {\n                             }\n                             order++;\n                         } else {\n-                            throw new ConfigurationException(\"Unsupported properties file format: \" + fileName);\n+                            throw new ConfigurationException(\"Unsupported properties file format: \" + filePath);\n                         }\n                     }\n                 }\n@@ -583,12 +583,11 @@ private void loadPropertySourceFromLoader(String name, PropertySourceLoader prop\n      * @param fileName             Name of the file to be used as property source name\n      * @param filePath             Absolute file path\n      * @param propertySourceLoader The appropriate property source loader\n-     * @throws ConfigurationException If unable to find the appropriate property soruce loader for the given file\n+     * @throws ConfigurationException If unable to find the appropriate property source loader for the given file\n      */\n     private Optional<Map<String, Object>> readPropertiesFromLoader(String fileName, String filePath, PropertySourceLoader propertySourceLoader) throws ConfigurationException {\n-        ResourceResolver resourceResolver = new ResourceResolver();\n-        Optional<ResourceLoader> resourceLoader = resourceResolver.getSupportingLoader(filePath);\n-        ResourceLoader loader = resourceLoader.orElse(FileSystemResourceLoader.defaultLoader());\n+        ResourceLoader loader = new ResourceResolver().getSupportingLoader(filePath)\n+                .orElse(FileSystemResourceLoader.defaultLoader());\n         try {\n             Optional<InputStream> inputStream = loader.getResourceAsStream(filePath);\n             if (inputStream.isPresent()) {",
        "function_modified_lines": {
            "added": [
                "     * @throws ConfigurationException If unable to find the appropriate property source loader for the given file\n",
                "        ResourceLoader loader = new ResourceResolver().getSupportingLoader(filePath)\n",
                "                .orElse(FileSystemResourceLoader.defaultLoader());\n"
            ],
            "deleted": [
                "     * @throws ConfigurationException If unable to find the appropriate property soruce loader for the given file\n",
                "        ResourceResolver resourceResolver = new ResourceResolver();\n",
                "        Optional<ResourceLoader> resourceLoader = resourceResolver.getSupportingLoader(filePath);\n",
                "        ResourceLoader loader = resourceLoader.orElse(FileSystemResourceLoader.defaultLoader());\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-22"
        ],
        "cve_description": "Micronaut is a JVM-based, full stack Java framework designed for building JVM applications. A path traversal vulnerability exists in versions prior to 2.5.9. With a basic configuration, it is possible to access any file from a filesystem, using \"/../../\" in the URL. This occurs because Micronaut does not restrict file access to configured paths. The vulnerability is patched in version 2.5.9. As a workaround, do not use `**` in mapping, use only `*`, which exposes only flat structure of a directory not allowing traversal. If using Linux, another workaround is to run micronaut in chroot.",
        "id": 12189
    },
    {
        "cve_id": "CVE-2021-43289",
        "code_before_change": "{\n        JobIdentifier jobIdentifier;\n        if (!headerConstraint.isSatisfied(request)) {\n            return ResponseCodeView.create(HttpServletResponse.SC_BAD_REQUEST, \"Missing required header 'Confirm'\");\n        }\n        try {\n            jobIdentifier = restfulService.findJob(pipelineName, pipelineCounter, stageName, stageCounter,\n                    buildName, buildId);\n        } catch (Exception e) {\n            return buildNotFound(pipelineName, pipelineCounter, stageName, stageCounter,\n                    buildName);\n        }\n\n        int convertedAttempt = attempt == null ? 1 : attempt;\n\n        try {\n            File artifact = artifactsService.findArtifact(jobIdentifier, filePath);\n            if (artifact.exists() && artifact.isFile()) {\n                return FileModelAndView.fileAlreadyExists(filePath);\n            }\n\n            MultipartFile multipartFile = multipartFile(request);\n            if (multipartFile == null) {\n                return FileModelAndView.invalidUploadRequest();\n            }\n\n            boolean success = saveFile(convertedAttempt, artifact, multipartFile, shouldUnzipStream(multipartFile));\n\n            if (!success) {\n                return FileModelAndView.errorSavingFile(filePath);\n            }\n\n            success = updateChecksumFile(request, jobIdentifier, filePath);\n\n            if (!success) {\n                return FileModelAndView.errorSavingChecksumFile(filePath);\n            }\n\n            return FileModelAndView.fileCreated(filePath);\n\n        } catch (IllegalArtifactLocationException e) {\n            return FileModelAndView.forbiddenUrl(filePath);\n        }\n    }",
        "code_after_change": "{\n        JobIdentifier jobIdentifier;\n        if (!headerConstraint.isSatisfied(request)) {\n            return ResponseCodeView.create(HttpServletResponse.SC_BAD_REQUEST, \"Missing required header 'Confirm'\");\n        }\n        if (!isValidStageCounter(stageCounter)) {\n            return buildNotFound(pipelineName, pipelineCounter, stageName, stageCounter, buildName);\n        }\n        try {\n            jobIdentifier = restfulService.findJob(pipelineName, pipelineCounter, stageName, stageCounter,\n                    buildName, buildId);\n        } catch (Exception e) {\n            return buildNotFound(pipelineName, pipelineCounter, stageName, stageCounter,\n                    buildName);\n        }\n\n        int convertedAttempt = attempt == null ? 1 : attempt;\n\n        try {\n            File artifact = artifactsService.findArtifact(jobIdentifier, filePath);\n            if (artifact.exists() && artifact.isFile()) {\n                return FileModelAndView.fileAlreadyExists(filePath);\n            }\n\n            MultipartFile multipartFile = multipartFile(request);\n            if (multipartFile == null) {\n                return FileModelAndView.invalidUploadRequest();\n            }\n\n            boolean success = saveFile(convertedAttempt, artifact, multipartFile, shouldUnzipStream(multipartFile));\n\n            if (!success) {\n                return FileModelAndView.errorSavingFile(filePath);\n            }\n\n            success = updateChecksumFile(request, jobIdentifier, filePath);\n\n            if (!success) {\n                return FileModelAndView.errorSavingChecksumFile(filePath);\n            }\n\n            return FileModelAndView.fileCreated(filePath);\n\n        } catch (IllegalArtifactLocationException e) {\n            return FileModelAndView.forbiddenUrl(filePath);\n        }\n    }",
        "patch": "@@ -33,6 +33,7 @@\n import com.thoughtworks.go.server.web.ResponseCodeView;\n import com.thoughtworks.go.util.ArtifactLogUtil;\n import com.thoughtworks.go.util.SystemEnvironment;\n+import org.apache.commons.lang3.StringUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.springframework.beans.factory.annotation.Autowired;\n@@ -149,6 +150,9 @@ public ModelAndView postArtifact(@RequestParam(\"pipelineName\") String pipelineNa\n         if (!headerConstraint.isSatisfied(request)) {\n             return ResponseCodeView.create(HttpServletResponse.SC_BAD_REQUEST, \"Missing required header 'Confirm'\");\n         }\n+        if (!isValidStageCounter(stageCounter)) {\n+            return buildNotFound(pipelineName, pipelineCounter, stageName, stageCounter, buildName);\n+        }\n         try {\n             jobIdentifier = restfulService.findJob(pipelineName, pipelineCounter, stageName, stageCounter,\n                     buildName, buildId);\n@@ -224,6 +228,10 @@ public ModelAndView putArtifact(@RequestParam(\"pipelineName\") String pipelineNam\n             return FileModelAndView.forbiddenUrl(filePath);\n         }\n \n+        if (!isValidStageCounter(stageCounter)) {\n+            return buildNotFound(pipelineName, pipelineCounter, stageName, stageCounter, buildName);\n+        }\n+\n         JobIdentifier jobIdentifier;\n         try {\n             jobIdentifier = restfulService.findJob(pipelineName, pipelineCounter, stageName, stageCounter, buildName, buildId);\n@@ -341,4 +349,17 @@ private ModelAndView logsNotFound(JobIdentifier identifier) {\n         String notFound = String.format(\"Console log for %s is unavailable as it may have been purged by Go or deleted externally.\", identifier.toFullString());\n         return ResponseCodeView.create(SC_NOT_FOUND, notFound);\n     }\n+\n+    private boolean isValidStageCounter(String stageCounter) {\n+        if (StringUtils.isEmpty(stageCounter)) {\n+            return true;\n+        }\n+\n+        try {\n+            int value = Integer.parseInt(stageCounter);\n+            return value > 0;\n+        } catch (Exception e) {\n+            return false;\n+        }\n+    }\n }",
        "function_modified_lines": {
            "added": [
                "        if (!isValidStageCounter(stageCounter)) {\n",
                "            return buildNotFound(pipelineName, pipelineCounter, stageName, stageCounter, buildName);\n",
                "        }\n"
            ],
            "deleted": []
        },
        "lang": "Java",
        "cwe": [
            "CWE-22"
        ],
        "cve_description": "An issue was discovered in ThoughtWorks GoCD before 21.3.0. An attacker who has compromised a GoCD agent can upload a malicious file into an arbitrary directory of a GoCD server, but does not control the filename.",
        "id": 12227
    },
    {
        "cve_id": "CVE-2021-43290",
        "code_before_change": "{\n        JobIdentifier jobIdentifier;\n        if (!headerConstraint.isSatisfied(request)) {\n            return ResponseCodeView.create(HttpServletResponse.SC_BAD_REQUEST, \"Missing required header 'Confirm'\");\n        }\n        try {\n            jobIdentifier = restfulService.findJob(pipelineName, pipelineCounter, stageName, stageCounter,\n                    buildName, buildId);\n        } catch (Exception e) {\n            return buildNotFound(pipelineName, pipelineCounter, stageName, stageCounter,\n                    buildName);\n        }\n\n        int convertedAttempt = attempt == null ? 1 : attempt;\n\n        try {\n            File artifact = artifactsService.findArtifact(jobIdentifier, filePath);\n            if (artifact.exists() && artifact.isFile()) {\n                return FileModelAndView.fileAlreadyExists(filePath);\n            }\n\n            MultipartFile multipartFile = multipartFile(request);\n            if (multipartFile == null) {\n                return FileModelAndView.invalidUploadRequest();\n            }\n\n            boolean success = saveFile(convertedAttempt, artifact, multipartFile, shouldUnzipStream(multipartFile));\n\n            if (!success) {\n                return FileModelAndView.errorSavingFile(filePath);\n            }\n\n            success = updateChecksumFile(request, jobIdentifier, filePath);\n\n            if (!success) {\n                return FileModelAndView.errorSavingChecksumFile(filePath);\n            }\n\n            return FileModelAndView.fileCreated(filePath);\n\n        } catch (IllegalArtifactLocationException e) {\n            return FileModelAndView.forbiddenUrl(filePath);\n        }\n    }",
        "code_after_change": "{\n        JobIdentifier jobIdentifier;\n        if (!headerConstraint.isSatisfied(request)) {\n            return ResponseCodeView.create(HttpServletResponse.SC_BAD_REQUEST, \"Missing required header 'Confirm'\");\n        }\n        if (!isValidStageCounter(stageCounter)) {\n            return buildNotFound(pipelineName, pipelineCounter, stageName, stageCounter, buildName);\n        }\n        try {\n            jobIdentifier = restfulService.findJob(pipelineName, pipelineCounter, stageName, stageCounter,\n                    buildName, buildId);\n        } catch (Exception e) {\n            return buildNotFound(pipelineName, pipelineCounter, stageName, stageCounter,\n                    buildName);\n        }\n\n        int convertedAttempt = attempt == null ? 1 : attempt;\n\n        try {\n            File artifact = artifactsService.findArtifact(jobIdentifier, filePath);\n            if (artifact.exists() && artifact.isFile()) {\n                return FileModelAndView.fileAlreadyExists(filePath);\n            }\n\n            MultipartFile multipartFile = multipartFile(request);\n            if (multipartFile == null) {\n                return FileModelAndView.invalidUploadRequest();\n            }\n\n            boolean success = saveFile(convertedAttempt, artifact, multipartFile, shouldUnzipStream(multipartFile));\n\n            if (!success) {\n                return FileModelAndView.errorSavingFile(filePath);\n            }\n\n            success = updateChecksumFile(request, jobIdentifier, filePath);\n\n            if (!success) {\n                return FileModelAndView.errorSavingChecksumFile(filePath);\n            }\n\n            return FileModelAndView.fileCreated(filePath);\n\n        } catch (IllegalArtifactLocationException e) {\n            return FileModelAndView.forbiddenUrl(filePath);\n        }\n    }",
        "patch": "@@ -33,6 +33,7 @@\n import com.thoughtworks.go.server.web.ResponseCodeView;\n import com.thoughtworks.go.util.ArtifactLogUtil;\n import com.thoughtworks.go.util.SystemEnvironment;\n+import org.apache.commons.lang3.StringUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.springframework.beans.factory.annotation.Autowired;\n@@ -149,6 +150,9 @@ public ModelAndView postArtifact(@RequestParam(\"pipelineName\") String pipelineNa\n         if (!headerConstraint.isSatisfied(request)) {\n             return ResponseCodeView.create(HttpServletResponse.SC_BAD_REQUEST, \"Missing required header 'Confirm'\");\n         }\n+        if (!isValidStageCounter(stageCounter)) {\n+            return buildNotFound(pipelineName, pipelineCounter, stageName, stageCounter, buildName);\n+        }\n         try {\n             jobIdentifier = restfulService.findJob(pipelineName, pipelineCounter, stageName, stageCounter,\n                     buildName, buildId);\n@@ -224,6 +228,10 @@ public ModelAndView putArtifact(@RequestParam(\"pipelineName\") String pipelineNam\n             return FileModelAndView.forbiddenUrl(filePath);\n         }\n \n+        if (!isValidStageCounter(stageCounter)) {\n+            return buildNotFound(pipelineName, pipelineCounter, stageName, stageCounter, buildName);\n+        }\n+\n         JobIdentifier jobIdentifier;\n         try {\n             jobIdentifier = restfulService.findJob(pipelineName, pipelineCounter, stageName, stageCounter, buildName, buildId);\n@@ -341,4 +349,17 @@ private ModelAndView logsNotFound(JobIdentifier identifier) {\n         String notFound = String.format(\"Console log for %s is unavailable as it may have been purged by Go or deleted externally.\", identifier.toFullString());\n         return ResponseCodeView.create(SC_NOT_FOUND, notFound);\n     }\n+\n+    private boolean isValidStageCounter(String stageCounter) {\n+        if (StringUtils.isEmpty(stageCounter)) {\n+            return true;\n+        }\n+\n+        try {\n+            int value = Integer.parseInt(stageCounter);\n+            return value > 0;\n+        } catch (Exception e) {\n+            return false;\n+        }\n+    }\n }",
        "function_modified_lines": {
            "added": [
                "        if (!isValidStageCounter(stageCounter)) {\n",
                "            return buildNotFound(pipelineName, pipelineCounter, stageName, stageCounter, buildName);\n",
                "        }\n"
            ],
            "deleted": []
        },
        "lang": "Java",
        "cwe": [
            "CWE-22"
        ],
        "cve_description": "An issue was discovered in ThoughtWorks GoCD before 21.3.0. An attacker who has compromised a GoCD agent can upload a malicious file into a directory of a GoCD server. They can control the filename but the directory is placed inside of a directory that they can't control.",
        "id": 12229
    },
    {
        "cve_id": "CVE-2023-37913",
        "code_before_change": "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.officeimporter.document;\n\nimport java.util.Map;\n\npublic interface CompatibilityOfficeDocument\n{\n    /**\n     * Returns all the artifacts for this office document. Artifacts are generated during the import operation if the\n     * original office document contains embedded non-textual elements. Also, some office formats (like presentations)\n     * result in multiple output files when converted into html. In this case all these output files will be considered\n     * as artifacts.\n     *\n     * @return a map containing artifacts for this document.\n     * @deprecated Since 13.1RC1 use {@link OfficeDocument#getArtifactsFiles()}.\n     */\n    @Deprecated\n    Map<String, byte[]> getArtifacts();\n}\n",
        "code_after_change": "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.officeimporter.document;\n\nimport java.io.File;\nimport java.util.Collections;\nimport java.util.Map;\nimport java.util.Set;\n\npublic interface CompatibilityOfficeDocument\n{\n    /**\n     * Returns all the artifacts for this office document. Artifacts are generated during the import operation if the\n     * original office document contains embedded non-textual elements. Also, some office formats (like presentations)\n     * result in multiple output files when converted into html. In this case all these output files will be considered\n     * as artifacts.\n     *\n     * @return a map containing artifacts for this document.\n     * @deprecated Since 13.1RC1 use {@link #getArtifactsFiles()}.\n     */\n    @Deprecated\n    Map<String, byte[]> getArtifacts();\n\n    /**\n     * Returns the files corresponding to all the artifacts for this office document, except the conversion of the\n     * document itself.\n     * Artifacts are generated during the import operation if the original office document contains embedded\n     * non-textual elements. Also, some office formats (like presentations) result in multiple output files when\n     * converted into html. In this case all these output files will be considered as artifacts.\n     *\n     * @return the set of artifacts related to this office document.\n     * @since 13.1RC1\n     * @deprecated Use {@link OfficeDocument#getArtifactsMap()} instead.\n     */\n    @Deprecated(since = \"15.3RC1, 14.10.8\")\n    default Set<File> getArtifactsFiles()\n    {\n        return Collections.emptySet();\n    }\n}\n",
        "patch": "@@ -19,7 +19,10 @@\n  */\n package org.xwiki.officeimporter.document;\n \n+import java.io.File;\n+import java.util.Collections;\n import java.util.Map;\n+import java.util.Set;\n \n public interface CompatibilityOfficeDocument\n {\n@@ -30,8 +33,25 @@ public interface CompatibilityOfficeDocument\n      * as artifacts.\n      *\n      * @return a map containing artifacts for this document.\n-     * @deprecated Since 13.1RC1 use {@link OfficeDocument#getArtifactsFiles()}.\n+     * @deprecated Since 13.1RC1 use {@link #getArtifactsFiles()}.\n      */\n     @Deprecated\n     Map<String, byte[]> getArtifacts();\n+\n+    /**\n+     * Returns the files corresponding to all the artifacts for this office document, except the conversion of the\n+     * document itself.\n+     * Artifacts are generated during the import operation if the original office document contains embedded\n+     * non-textual elements. Also, some office formats (like presentations) result in multiple output files when\n+     * converted into html. In this case all these output files will be considered as artifacts.\n+     *\n+     * @return the set of artifacts related to this office document.\n+     * @since 13.1RC1\n+     * @deprecated Use {@link OfficeDocument#getArtifactsMap()} instead.\n+     */\n+    @Deprecated(since = \"15.3RC1, 14.10.8\")\n+    default Set<File> getArtifactsFiles()\n+    {\n+        return Collections.emptySet();\n+    }\n }",
        "function_modified_lines": {
            "added": [
                "import java.io.File;\n",
                "import java.util.Collections;\n",
                "import java.util.Set;\n",
                "     * @deprecated Since 13.1RC1 use {@link #getArtifactsFiles()}.\n",
                "\n",
                "    /**\n",
                "     * Returns the files corresponding to all the artifacts for this office document, except the conversion of the\n",
                "     * document itself.\n",
                "     * Artifacts are generated during the import operation if the original office document contains embedded\n",
                "     * non-textual elements. Also, some office formats (like presentations) result in multiple output files when\n",
                "     * converted into html. In this case all these output files will be considered as artifacts.\n",
                "     *\n",
                "     * @return the set of artifacts related to this office document.\n",
                "     * @since 13.1RC1\n",
                "     * @deprecated Use {@link OfficeDocument#getArtifactsMap()} instead.\n",
                "     */\n",
                "    @Deprecated(since = \"15.3RC1, 14.10.8\")\n",
                "    default Set<File> getArtifactsFiles()\n",
                "    {\n",
                "        return Collections.emptySet();\n",
                "    }\n"
            ],
            "deleted": [
                "     * @deprecated Since 13.1RC1 use {@link OfficeDocument#getArtifactsFiles()}.\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-22"
        ],
        "cve_description": "XWiki Platform is a generic wiki platform offering runtime services for applications built on top of it. Starting in version 3.5-milestone-1 and prior to versions 14.10.8 and 15.3-rc-1, triggering the office converter with a specially crafted file name allows writing the attachment's content to an attacker-controlled location on the server as long as the Java process has write access to that location. In particular in the combination with attachment moving, a feature introduced in XWiki 14.0, this is easy to reproduce but it also possible to reproduce in versions as old as XWiki 3.5 by uploading the attachment through the REST API which doesn't remove `/` or `\\` from the filename. As the mime type of the attachment doesn't matter for the exploitation, this could e.g., be used to replace the `jar`-file of an extension which would allow executing arbitrary Java code and thus impact the confidentiality, integrity and availability of the XWiki installation. This vulnerability has been patched in XWiki 14.10.8 and 15.3RC1. There are no known workarounds apart from disabling the office converter.",
        "id": 12392
    },
    {
        "cve_id": "CVE-2023-37913",
        "code_before_change": "{\n    /**\n     * Top-level temporary working directory.\n     */\n    private File rootDir;\n\n    /**\n     * Input directory where all the input files are located.\n     */\n    private File inputDir;\n\n    /**\n     * Input office document file.\n     */\n    private File inputFile;\n\n    /**\n     * Output directory.\n     */\n    private File outputDir;\n\n    /**\n     * Main output file.\n     */\n    private File outputFile;\n\n    /**\n     * Creates a new {@link OfficeConverterFileStorage} instance for tracking file system storage for a convert\n     * operation.\n     * \n     * @param parentDir parent directory under which temporary storage is to be allocated.\n     * @param inputFileName main input file which will be fed into office server.\n     * @param outputFileName main output file into which result of the office conversion will be written into.\n     * @throws IOException if an error occurs while creating temporary directory structure.\n     */\n    public OfficeConverterFileStorage(File parentDir, String inputFileName, String outputFileName) throws IOException\n    {\n        boolean success = false;\n\n        // Realize the temporary directory hierarchy.\n        this.rootDir = new File(parentDir, UUID.randomUUID().toString());\n        if (this.rootDir.mkdir()) {\n            this.inputDir = new File(this.rootDir, \"input\");\n            this.outputDir = new File(this.rootDir, \"output\");\n            if (this.inputDir.mkdir() && this.outputDir.mkdir()) {\n                this.inputFile = new File(this.inputDir, StringUtils.stripAccents(inputFileName));\n                this.outputFile = new File(this.outputDir, StringUtils.stripAccents(outputFileName));\n                success = true;\n            }\n        }\n\n        // Cleanup & signal if an error is encountered.\n        if (!success) {\n            cleanUp();\n            throw new IOException(\"Could not create temporary directory hierarchy.\");\n        }\n    }\n\n    /**\n     * @return {@link File} representing the input directory where the main input document as well as any other\n     *         dependent artifacts should be located.\n     */\n    public File getInputDir()\n    {\n        return this.inputDir;\n    }\n\n    /**\n     * @return {@link File} representing the main input file.\n     */\n    public File getInputFile()\n    {\n        return this.inputFile;\n    }\n\n    /**\n     * @return {@link File} representing the output directory where the main output file as well as any other dependent\n     *         artifacts are located.\n     */\n    public File getOutputDir()\n    {\n        return this.outputDir;\n    }\n\n    /**\n     * @return {@link File} representing the main output file.\n     */\n    public File getOutputFile()\n    {\n        return this.outputFile;\n    }\n\n    /**\n     * Cleans up the allocated file storage.\n     * \n     * @return true if the cleanup operation succeeded, false otherwise.\n     */\n    public boolean cleanUp()\n    {\n        if (this.rootDir.exists()) {\n            return delete(this.rootDir);\n        }\n\n        return true;\n    }\n\n    /**\n     * Utility method for deleting a directory or a file.\n     * \n     * @param file file or directory to be deleted.\n     * @return true if the whole operation succeeded, false otherwise.\n     */\n    private boolean delete(File file)\n    {\n        // If directory, recursively delete all of it's content.\n        if (file.isDirectory()) {\n            for (File child : file.listFiles()) {\n                delete(child);\n            }\n        }\n\n        // Finally attempt to delete the parent (or the ordinary file).\n        return file.delete();\n    }\n}",
        "code_after_change": "{\n    /**\n     * Pattern for matching a file extension that is safe, i.e., contains between 1 and 20 alphanumeric\n     * characters. The upper limit is arbitrary but should fit all extensions and is there to ensure that the\n     * filename won't be too long.\n     */\n    private static final Pattern SAFE_EXTENSION = Pattern.compile(\"^[a-zA-Z0-9]{1,20}$\");\n\n    /**\n     * Pattern for matching characters not allowed in filenames. Currently just matches directory separators.\n     */\n    private static final Pattern DISALLOWED_CHARACTERS = Pattern.compile(\"[/\\\\\\\\]\");\n\n    private static final String INPUT = \"input\";\n\n    /**\n     * Top-level temporary working directory.\n     */\n    private File rootDir;\n\n    /**\n     * Input directory where all the input files are located.\n     */\n    private File inputDir;\n\n    /**\n     * Input office document file.\n     */\n    private File inputFile;\n\n    /**\n     * Output directory.\n     */\n    private File outputDir;\n\n    /**\n     * Main output file.\n     */\n    private File outputFile;\n\n    /**\n     * Creates a new {@link OfficeConverterFileStorage} instance for tracking file system storage for a convert\n     * operation.\n     * \n     * @param parentDir parent directory under which temporary storage is to be allocated.\n     * @param inputFileName main input file which will be fed into office server.\n     * @param outputFileName main output file into which result of the office conversion will be written into.\n     * @throws IOException if an error occurs while creating temporary directory structure.\n     */\n    public OfficeConverterFileStorage(File parentDir, String inputFileName, String outputFileName) throws IOException\n    {\n        boolean success = false;\n\n        // Realize the temporary directory hierarchy.\n        this.rootDir = new File(parentDir, UUID.randomUUID().toString());\n        if (this.rootDir.mkdir()) {\n            this.inputDir = new File(this.rootDir, INPUT);\n            this.outputDir = new File(this.rootDir, \"output\");\n            if (this.inputDir.mkdir() && this.outputDir.mkdir()) {\n                this.inputFile = new File(this.inputDir, cleanFilename(inputFileName));\n                this.outputFile = new File(this.outputDir, cleanFilename(outputFileName));\n                success = true;\n            }\n        }\n\n        // Cleanup & signal if an error is encountered.\n        if (!success) {\n            cleanUp();\n            throw new IOException(\"Could not create temporary directory hierarchy.\");\n        }\n    }\n\n    /**\n     * Gets a filename that is safe to use as input filename for a conversion operation.\n     * <p>\n     * The extension is kept from the input filename if it is alphanumeric and contains between 1 and 20 characters.\n     *\n     * @param filename the filename for getting the extension\n     * @return the input filename\n     */\n    public static String getSafeInputFilenameFromExtension(String filename)\n    {\n        String extension = FileNameUtils.getExtension(filename);\n        if (!SAFE_EXTENSION.matcher(extension).matches()) {\n            extension = \"\";\n        }\n\n        return StringUtils.isBlank(extension) ? INPUT : INPUT + \".\" + extension;\n    }\n\n    /**\n     * Clean a file name for use as input or output name.\n     *\n     * @param name the filename to clean\n     * @return the cleaned name, shortened to 255 characters if needed\n     */\n    public static String cleanFilename(String name)\n    {\n        String result = DISALLOWED_CHARACTERS.matcher(StringUtils.stripAccents(name)).replaceAll(\"_\");\n\n        // Make sure that the filename is not blank. Don't use an extension so maybe content guessing works.\n        if (StringUtils.isBlank(result)) {\n            result = \"fallback\";\n        }\n\n        // If the filename is too long, keep the part at the end as it contains the extension.\n        if (result.length() > 255) {\n            result = result.substring(result.length() - 255);\n        }\n\n        return result;\n    }\n\n    /**\n     * @return {@link File} representing the input directory where the main input document as well as any other\n     *         dependent artifacts should be located.\n     */\n    public File getInputDir()\n    {\n        return this.inputDir;\n    }\n\n    /**\n     * @return {@link File} representing the main input file.\n     */\n    public File getInputFile()\n    {\n        return this.inputFile;\n    }\n\n    /**\n     * @return {@link File} representing the output directory where the main output file as well as any other dependent\n     *         artifacts are located.\n     */\n    public File getOutputDir()\n    {\n        return this.outputDir;\n    }\n\n    /**\n     * @return {@link File} representing the main output file.\n     */\n    public File getOutputFile()\n    {\n        return this.outputFile;\n    }\n\n    /**\n     * Cleans up the allocated file storage.\n     * \n     * @return true if the cleanup operation succeeded, false otherwise.\n     */\n    public boolean cleanUp()\n    {\n        if (this.rootDir.exists()) {\n            return delete(this.rootDir);\n        }\n\n        return true;\n    }\n\n    /**\n     * Utility method for deleting a directory or a file.\n     * \n     * @param file file or directory to be deleted.\n     * @return true if the whole operation succeeded, false otherwise.\n     */\n    private boolean delete(File file)\n    {\n        // If directory, recursively delete all of it's content.\n        if (file.isDirectory()) {\n            for (File child : file.listFiles()) {\n                delete(child);\n            }\n        }\n\n        // Finally attempt to delete the parent (or the ordinary file).\n        return file.delete();\n    }\n}",
        "patch": "@@ -22,7 +22,9 @@\n import java.io.File;\n import java.io.IOException;\n import java.util.UUID;\n+import java.util.regex.Pattern;\n \n+import org.apache.commons.compress.utils.FileNameUtils;\n import org.apache.commons.lang3.StringUtils;\n \n /**\n@@ -34,6 +36,20 @@\n  */\n public class OfficeConverterFileStorage\n {\n+    /**\n+     * Pattern for matching a file extension that is safe, i.e., contains between 1 and 20 alphanumeric\n+     * characters. The upper limit is arbitrary but should fit all extensions and is there to ensure that the\n+     * filename won't be too long.\n+     */\n+    private static final Pattern SAFE_EXTENSION = Pattern.compile(\"^[a-zA-Z0-9]{1,20}$\");\n+\n+    /**\n+     * Pattern for matching characters not allowed in filenames. Currently just matches directory separators.\n+     */\n+    private static final Pattern DISALLOWED_CHARACTERS = Pattern.compile(\"[/\\\\\\\\]\");\n+\n+    private static final String INPUT = \"input\";\n+\n     /**\n      * Top-level temporary working directory.\n      */\n@@ -75,11 +91,11 @@ public OfficeConverterFileStorage(File parentDir, String inputFileName, String o\n         // Realize the temporary directory hierarchy.\n         this.rootDir = new File(parentDir, UUID.randomUUID().toString());\n         if (this.rootDir.mkdir()) {\n-            this.inputDir = new File(this.rootDir, \"input\");\n+            this.inputDir = new File(this.rootDir, INPUT);\n             this.outputDir = new File(this.rootDir, \"output\");\n             if (this.inputDir.mkdir() && this.outputDir.mkdir()) {\n-                this.inputFile = new File(this.inputDir, StringUtils.stripAccents(inputFileName));\n-                this.outputFile = new File(this.outputDir, StringUtils.stripAccents(outputFileName));\n+                this.inputFile = new File(this.inputDir, cleanFilename(inputFileName));\n+                this.outputFile = new File(this.outputDir, cleanFilename(outputFileName));\n                 success = true;\n             }\n         }\n@@ -91,6 +107,47 @@ public OfficeConverterFileStorage(File parentDir, String inputFileName, String o\n         }\n     }\n \n+    /**\n+     * Gets a filename that is safe to use as input filename for a conversion operation.\n+     * <p>\n+     * The extension is kept from the input filename if it is alphanumeric and contains between 1 and 20 characters.\n+     *\n+     * @param filename the filename for getting the extension\n+     * @return the input filename\n+     */\n+    public static String getSafeInputFilenameFromExtension(String filename)\n+    {\n+        String extension = FileNameUtils.getExtension(filename);\n+        if (!SAFE_EXTENSION.matcher(extension).matches()) {\n+            extension = \"\";\n+        }\n+\n+        return StringUtils.isBlank(extension) ? INPUT : INPUT + \".\" + extension;\n+    }\n+\n+    /**\n+     * Clean a file name for use as input or output name.\n+     *\n+     * @param name the filename to clean\n+     * @return the cleaned name, shortened to 255 characters if needed\n+     */\n+    public static String cleanFilename(String name)\n+    {\n+        String result = DISALLOWED_CHARACTERS.matcher(StringUtils.stripAccents(name)).replaceAll(\"_\");\n+\n+        // Make sure that the filename is not blank. Don't use an extension so maybe content guessing works.\n+        if (StringUtils.isBlank(result)) {\n+            result = \"fallback\";\n+        }\n+\n+        // If the filename is too long, keep the part at the end as it contains the extension.\n+        if (result.length() > 255) {\n+            result = result.substring(result.length() - 255);\n+        }\n+\n+        return result;\n+    }\n+\n     /**\n      * @return {@link File} representing the input directory where the main input document as well as any other\n      *         dependent artifacts should be located.",
        "function_modified_lines": {
            "added": [
                "            this.inputDir = new File(this.rootDir, INPUT);\n",
                "                this.inputFile = new File(this.inputDir, cleanFilename(inputFileName));\n",
                "                this.outputFile = new File(this.outputDir, cleanFilename(outputFileName));\n",
                "    /**\n",
                "     * Gets a filename that is safe to use as input filename for a conversion operation.\n",
                "     * <p>\n",
                "     * The extension is kept from the input filename if it is alphanumeric and contains between 1 and 20 characters.\n",
                "     *\n",
                "     * @param filename the filename for getting the extension\n",
                "     * @return the input filename\n",
                "     */\n",
                "    public static String getSafeInputFilenameFromExtension(String filename)\n",
                "    {\n",
                "        String extension = FileNameUtils.getExtension(filename);\n",
                "        if (!SAFE_EXTENSION.matcher(extension).matches()) {\n",
                "            extension = \"\";\n",
                "        }\n",
                "\n",
                "        return StringUtils.isBlank(extension) ? INPUT : INPUT + \".\" + extension;\n",
                "    }\n",
                "\n",
                "    /**\n",
                "     * Clean a file name for use as input or output name.\n",
                "     *\n",
                "     * @param name the filename to clean\n",
                "     * @return the cleaned name, shortened to 255 characters if needed\n",
                "     */\n",
                "    public static String cleanFilename(String name)\n",
                "    {\n",
                "        String result = DISALLOWED_CHARACTERS.matcher(StringUtils.stripAccents(name)).replaceAll(\"_\");\n",
                "\n",
                "        // Make sure that the filename is not blank. Don't use an extension so maybe content guessing works.\n",
                "        if (StringUtils.isBlank(result)) {\n",
                "            result = \"fallback\";\n",
                "        }\n",
                "\n",
                "        // If the filename is too long, keep the part at the end as it contains the extension.\n",
                "        if (result.length() > 255) {\n",
                "            result = result.substring(result.length() - 255);\n",
                "        }\n",
                "\n",
                "        return result;\n",
                "    }\n",
                "\n"
            ],
            "deleted": [
                "            this.inputDir = new File(this.rootDir, \"input\");\n",
                "                this.inputFile = new File(this.inputDir, StringUtils.stripAccents(inputFileName));\n",
                "                this.outputFile = new File(this.outputDir, StringUtils.stripAccents(outputFileName));\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-22"
        ],
        "cve_description": "XWiki Platform is a generic wiki platform offering runtime services for applications built on top of it. Starting in version 3.5-milestone-1 and prior to versions 14.10.8 and 15.3-rc-1, triggering the office converter with a specially crafted file name allows writing the attachment's content to an attacker-controlled location on the server as long as the Java process has write access to that location. In particular in the combination with attachment moving, a feature introduced in XWiki 14.0, this is easy to reproduce but it also possible to reproduce in versions as old as XWiki 3.5 by uploading the attachment through the REST API which doesn't remove `/` or `\\` from the filename. As the mime type of the attachment doesn't matter for the exploitation, this could e.g., be used to replace the `jar`-file of an extension which would allow executing arbitrary Java code and thus impact the confidentiality, integrity and availability of the XWiki installation. This vulnerability has been patched in XWiki 14.10.8 and 15.3RC1. There are no known workarounds apart from disabling the office converter.",
        "id": 12402
    },
    {
        "cve_id": "CVE-2023-37913",
        "code_before_change": "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.officeimporter.internal;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.util.Collections;\n\nimport org.apache.commons.io.IOUtils;\nimport org.junit.jupiter.api.Test;\nimport org.xwiki.bridge.DocumentAccessBridge;\nimport org.xwiki.bridge.DocumentModelBridge;\nimport org.xwiki.model.reference.AttachmentReference;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.officeimporter.document.XDOMOfficeDocument;\nimport org.xwiki.rendering.syntax.Syntax;\nimport org.xwiki.rendering.syntax.SyntaxType;\nimport org.xwiki.security.authorization.ContextualAuthorizationManager;\nimport org.xwiki.security.authorization.Right;\nimport org.xwiki.test.junit5.XWikiTempDir;\nimport org.xwiki.test.junit5.mockito.ComponentTest;\nimport org.xwiki.test.junit5.mockito.InjectMockComponents;\nimport org.xwiki.test.junit5.mockito.MockComponent;\n\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\n/**\n * Unit test for {@link ModelBridge}.\n * \n * @version $Id$\n */\n@ComponentTest\nclass ModelBridgeTest\n{\n    @InjectMockComponents\n    private ModelBridge modelBridge;\n\n    @MockComponent\n    private DocumentAccessBridge documentAccessBridge;\n\n    @MockComponent\n    private ContextualAuthorizationManager contextualAuthorizationManager;\n\n    @XWikiTempDir\n    private File tempDir;\n\n    @Test\n    void saveWithOverwrite() throws Exception\n    {\n        XDOMOfficeDocument doc = mock(XDOMOfficeDocument.class);\n        DocumentReference documentReference = new DocumentReference(\"wiki\", \"Space\", \"Page\");\n        DocumentReference parentReference = new DocumentReference(\"wiki\", \"Space\", \"Parent\");\n        String syntaxId = \"test/1.0\";\n        String title = \"Office Document Title\";\n        String content = \"Office Document Content\";\n        String fileName = \"logo.png\";\n        byte[] fileContent = new byte[] {65, 82};\n        File artifact = new File(tempDir, fileName);\n        try (FileOutputStream fos = new FileOutputStream(artifact)) {\n            IOUtils.write(fileContent, fos);\n        }\n\n        when(this.contextualAuthorizationManager.hasAccess(Right.EDIT, documentReference)).thenReturn(true);\n        when(doc.getContentAsString(syntaxId)).thenReturn(content);\n        when(doc.getArtifactsFiles()).thenReturn(Collections.singleton(artifact));\n\n        this.modelBridge.save(doc, documentReference, syntaxId, parentReference, title, false);\n\n        verify(documentAccessBridge).setDocumentSyntaxId(documentReference, syntaxId);\n        verify(documentAccessBridge).setDocumentContent(documentReference, content, \"Created by office importer.\",\n            false);\n        verify(documentAccessBridge).setDocumentParentReference(documentReference, parentReference);\n        verify(documentAccessBridge).setDocumentTitle(documentReference, title);\n        verify(documentAccessBridge).setAttachmentContent(new AttachmentReference(fileName, documentReference),\n            fileContent);\n    }\n\n    @Test\n    void saveWithAppend() throws Exception\n    {\n        XDOMOfficeDocument doc = mock(XDOMOfficeDocument.class);\n        DocumentReference documentReference = new DocumentReference(\"wiki\", \"Space\", \"Page\");\n        String syntaxId = \"test/1.0\";\n\n        when(this.contextualAuthorizationManager.hasAccess(Right.EDIT, documentReference)).thenReturn(true);\n        when(documentAccessBridge.exists(documentReference)).thenReturn(true);\n\n        DocumentModelBridge document = mock(DocumentModelBridge.class);\n        when(documentAccessBridge.getTranslatedDocumentInstance(documentReference)).thenReturn(document);\n        when(document.getSyntax()).thenReturn(new Syntax(new SyntaxType(\"test\", \"Test\"), \"1.0\"));\n\n        when(documentAccessBridge.getDocumentContent(documentReference, null)).thenReturn(\"before\");\n        when(doc.getContentAsString(syntaxId)).thenReturn(\"after\");\n\n        this.modelBridge.save(doc, documentReference, syntaxId, null, null, true);\n\n        verify(documentAccessBridge).setDocumentContent(documentReference, \"before\\nafter\",\n            \"Updated by office importer.\", false);\n    }\n}\n",
        "code_after_change": "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.officeimporter.internal;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.InputStream;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.apache.commons.io.IOUtils;\nimport org.junit.jupiter.api.Test;\nimport org.xwiki.bridge.DocumentAccessBridge;\nimport org.xwiki.bridge.DocumentModelBridge;\nimport org.xwiki.model.reference.AttachmentReference;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.officeimporter.document.XDOMOfficeDocument;\nimport org.xwiki.officeimporter.internal.document.FileOfficeDocumentArtifact;\nimport org.xwiki.rendering.syntax.Syntax;\nimport org.xwiki.rendering.syntax.SyntaxType;\nimport org.xwiki.security.authorization.ContextualAuthorizationManager;\nimport org.xwiki.security.authorization.Right;\nimport org.xwiki.test.junit5.XWikiTempDir;\nimport org.xwiki.test.junit5.mockito.ComponentTest;\nimport org.xwiki.test.junit5.mockito.InjectMockComponents;\nimport org.xwiki.test.junit5.mockito.MockComponent;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.Mockito.doAnswer;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\n/**\n * Unit test for {@link ModelBridge}.\n * \n * @version $Id$\n */\n@ComponentTest\nclass ModelBridgeTest\n{\n    @InjectMockComponents\n    private ModelBridge modelBridge;\n\n    @MockComponent\n    private DocumentAccessBridge documentAccessBridge;\n\n    @MockComponent\n    private ContextualAuthorizationManager contextualAuthorizationManager;\n\n    @XWikiTempDir\n    private File tempDir;\n\n    @Test\n    void saveWithOverwrite() throws Exception\n    {\n        XDOMOfficeDocument doc = mock(XDOMOfficeDocument.class);\n        DocumentReference documentReference = new DocumentReference(\"wiki\", \"Space\", \"Page\");\n        DocumentReference parentReference = new DocumentReference(\"wiki\", \"Space\", \"Parent\");\n        String syntaxId = \"test/1.0\";\n        String title = \"Office Document Title\";\n        String content = \"Office Document Content\";\n        String fileName = \"logo.png\";\n        byte[] fileContent = new byte[] {65, 82};\n        File artifact = new File(tempDir, fileName);\n        try (FileOutputStream fos = new FileOutputStream(artifact)) {\n            IOUtils.write(fileContent, fos);\n        }\n\n        when(this.contextualAuthorizationManager.hasAccess(Right.EDIT, documentReference)).thenReturn(true);\n        when(doc.getContentAsString(syntaxId)).thenReturn(content);\n        when(doc.getArtifactsMap())\n            .thenReturn(Collections.singletonMap(fileName, new FileOfficeDocumentArtifact(fileName, artifact)));\n        // Store all attachment contents that are set on the mock.\n        Map<AttachmentReference, byte[]> attachmentContents = new HashMap<>();\n        doAnswer((invocation) -> attachmentContents.put(\n            invocation.getArgument(0, AttachmentReference.class),\n            IOUtils.toByteArray(invocation.getArgument(1, InputStream.class))\n        )).when(this.documentAccessBridge)\n            .setAttachmentContent(any(AttachmentReference.class), any(InputStream.class));\n\n        this.modelBridge.save(doc, documentReference, syntaxId, parentReference, title, false);\n\n        verify(documentAccessBridge).setDocumentSyntaxId(documentReference, syntaxId);\n        verify(documentAccessBridge).setDocumentContent(documentReference, content, \"Created by office importer.\",\n            false);\n        verify(documentAccessBridge).setDocumentParentReference(documentReference, parentReference);\n        verify(documentAccessBridge).setDocumentTitle(documentReference, title);\n        assertEquals(1, attachmentContents.size());\n        AttachmentReference expectedAttachmentReference = new AttachmentReference(fileName, documentReference);\n        assertEquals(expectedAttachmentReference, attachmentContents.keySet().iterator().next());\n        assertArrayEquals(fileContent, attachmentContents.get(expectedAttachmentReference));\n    }\n\n    @Test\n    void saveWithAppend() throws Exception\n    {\n        XDOMOfficeDocument doc = mock(XDOMOfficeDocument.class);\n        DocumentReference documentReference = new DocumentReference(\"wiki\", \"Space\", \"Page\");\n        String syntaxId = \"test/1.0\";\n\n        when(this.contextualAuthorizationManager.hasAccess(Right.EDIT, documentReference)).thenReturn(true);\n        when(documentAccessBridge.exists(documentReference)).thenReturn(true);\n\n        DocumentModelBridge document = mock(DocumentModelBridge.class);\n        when(documentAccessBridge.getTranslatedDocumentInstance(documentReference)).thenReturn(document);\n        when(document.getSyntax()).thenReturn(new Syntax(new SyntaxType(\"test\", \"Test\"), \"1.0\"));\n\n        when(documentAccessBridge.getDocumentContent(documentReference, null)).thenReturn(\"before\");\n        when(doc.getContentAsString(syntaxId)).thenReturn(\"after\");\n\n        this.modelBridge.save(doc, documentReference, syntaxId, null, null, true);\n\n        verify(documentAccessBridge).setDocumentContent(documentReference, \"before\\nafter\",\n            \"Updated by office importer.\", false);\n    }\n}\n",
        "patch": "@@ -21,7 +21,10 @@\n \n import java.io.File;\n import java.io.FileOutputStream;\n+import java.io.InputStream;\n import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n \n import org.apache.commons.io.IOUtils;\n import org.junit.jupiter.api.Test;\n@@ -30,6 +33,7 @@\n import org.xwiki.model.reference.AttachmentReference;\n import org.xwiki.model.reference.DocumentReference;\n import org.xwiki.officeimporter.document.XDOMOfficeDocument;\n+import org.xwiki.officeimporter.internal.document.FileOfficeDocumentArtifact;\n import org.xwiki.rendering.syntax.Syntax;\n import org.xwiki.rendering.syntax.SyntaxType;\n import org.xwiki.security.authorization.ContextualAuthorizationManager;\n@@ -39,6 +43,10 @@\n import org.xwiki.test.junit5.mockito.InjectMockComponents;\n import org.xwiki.test.junit5.mockito.MockComponent;\n \n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.doAnswer;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n@@ -81,7 +89,15 @@ void saveWithOverwrite() throws Exception\n \n         when(this.contextualAuthorizationManager.hasAccess(Right.EDIT, documentReference)).thenReturn(true);\n         when(doc.getContentAsString(syntaxId)).thenReturn(content);\n-        when(doc.getArtifactsFiles()).thenReturn(Collections.singleton(artifact));\n+        when(doc.getArtifactsMap())\n+            .thenReturn(Collections.singletonMap(fileName, new FileOfficeDocumentArtifact(fileName, artifact)));\n+        // Store all attachment contents that are set on the mock.\n+        Map<AttachmentReference, byte[]> attachmentContents = new HashMap<>();\n+        doAnswer((invocation) -> attachmentContents.put(\n+            invocation.getArgument(0, AttachmentReference.class),\n+            IOUtils.toByteArray(invocation.getArgument(1, InputStream.class))\n+        )).when(this.documentAccessBridge)\n+            .setAttachmentContent(any(AttachmentReference.class), any(InputStream.class));\n \n         this.modelBridge.save(doc, documentReference, syntaxId, parentReference, title, false);\n \n@@ -90,8 +106,10 @@ void saveWithOverwrite() throws Exception\n             false);\n         verify(documentAccessBridge).setDocumentParentReference(documentReference, parentReference);\n         verify(documentAccessBridge).setDocumentTitle(documentReference, title);\n-        verify(documentAccessBridge).setAttachmentContent(new AttachmentReference(fileName, documentReference),\n-            fileContent);\n+        assertEquals(1, attachmentContents.size());\n+        AttachmentReference expectedAttachmentReference = new AttachmentReference(fileName, documentReference);\n+        assertEquals(expectedAttachmentReference, attachmentContents.keySet().iterator().next());\n+        assertArrayEquals(fileContent, attachmentContents.get(expectedAttachmentReference));\n     }\n \n     @Test",
        "function_modified_lines": {
            "added": [
                "import java.io.InputStream;\n",
                "import java.util.HashMap;\n",
                "import java.util.Map;\n",
                "import org.xwiki.officeimporter.internal.document.FileOfficeDocumentArtifact;\n",
                "import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n",
                "import static org.junit.jupiter.api.Assertions.assertEquals;\n",
                "import static org.mockito.ArgumentMatchers.any;\n",
                "import static org.mockito.Mockito.doAnswer;\n"
            ],
            "deleted": []
        },
        "lang": "Java",
        "cwe": [
            "CWE-22"
        ],
        "cve_description": "XWiki Platform is a generic wiki platform offering runtime services for applications built on top of it. Starting in version 3.5-milestone-1 and prior to versions 14.10.8 and 15.3-rc-1, triggering the office converter with a specially crafted file name allows writing the attachment's content to an attacker-controlled location on the server as long as the Java process has write access to that location. In particular in the combination with attachment moving, a feature introduced in XWiki 14.0, this is easy to reproduce but it also possible to reproduce in versions as old as XWiki 3.5 by uploading the attachment through the REST API which doesn't remove `/` or `\\` from the filename. As the mime type of the attachment doesn't matter for the exploitation, this could e.g., be used to replace the `jar`-file of an extension which would allow executing arbitrary Java code and thus impact the confidentiality, integrity and availability of the XWiki installation. This vulnerability has been patched in XWiki 14.10.8 and 15.3RC1. There are no known workarounds apart from disabling the office converter.",
        "id": 12406
    },
    {
        "cve_id": "CVE-2023-37913",
        "code_before_change": "{\n        InputStream officeFileStream;\n        if (this.documentAccessBridge.getAttachmentVersion(attachmentReference) != null) {\n            officeFileStream = documentAccessBridge.getAttachmentContent(attachmentReference);\n        } else {\n            Optional<XWikiAttachment> uploadedAttachment =\n                this.temporaryAttachmentSessionsManager.getUploadedAttachment(attachmentReference);\n            if (uploadedAttachment.isPresent()) {\n                officeFileStream = uploadedAttachment.get().getContentInputStream(this.contextProvider.get());\n            } else {\n                throw new OfficeImporterException(\n                    String.format(\"Cannot find temporary uplodaded attachment [%s]\", attachmentReference));\n            }\n        }\n        String officeFileName = attachmentReference.getName();\n        DocumentReference targetDocRef = attachmentReference.getDocumentReference();\n        XDOMOfficeDocument xdomOfficeDocument;\n        if (isPresentation(attachmentReference.getName())) {\n            xdomOfficeDocument = presentationBuilder.build(officeFileStream, officeFileName, targetDocRef);\n        } else {\n            xdomOfficeDocument = documentBuilder.build(officeFileStream, officeFileName, targetDocRef, filterStyles);\n        }\n        // Attach the images extracted from the imported office document to the target wiki document.\n        for (File artifact : xdomOfficeDocument.getArtifactsFiles()) {\n\n            AttachmentReference artifactReference = new AttachmentReference(artifact.getName(), targetDocRef);\n            try (FileInputStream fis = new FileInputStream(artifact)) {\n                documentAccessBridge.setAttachmentContent(artifactReference, IOUtils.toByteArray(fis));\n            }\n        }\n        String result = xdomOfficeDocument.getContentAsString(\"annotatedxhtml/1.0\");\n        xdomOfficeDocument.close();\n        return result;\n    }",
        "code_after_change": "{\n        InputStream officeFileStream;\n        if (this.documentAccessBridge.getAttachmentVersion(attachmentReference) != null) {\n            officeFileStream = documentAccessBridge.getAttachmentContent(attachmentReference);\n        } else {\n            Optional<XWikiAttachment> uploadedAttachment =\n                this.temporaryAttachmentSessionsManager.getUploadedAttachment(attachmentReference);\n            if (uploadedAttachment.isPresent()) {\n                officeFileStream = uploadedAttachment.get().getContentInputStream(this.contextProvider.get());\n            } else {\n                throw new OfficeImporterException(\n                    String.format(\"Cannot find temporary uplodaded attachment [%s]\", attachmentReference));\n            }\n        }\n        String officeFileName = attachmentReference.getName();\n        DocumentReference targetDocRef = attachmentReference.getDocumentReference();\n        XDOMOfficeDocument xdomOfficeDocument;\n        if (isPresentation(attachmentReference.getName())) {\n            xdomOfficeDocument = presentationBuilder.build(officeFileStream, officeFileName, targetDocRef);\n        } else {\n            xdomOfficeDocument = documentBuilder.build(officeFileStream, officeFileName, targetDocRef, filterStyles);\n        }\n        // Attach the images extracted from the imported office document to the target wiki document.\n        for (Map.Entry<String, OfficeDocumentArtifact> entry : xdomOfficeDocument.getArtifactsMap().entrySet()) {\n            String filename = entry.getKey();\n            OfficeDocumentArtifact artifact = entry.getValue();\n            AttachmentReference artifactReference = new AttachmentReference(filename, targetDocRef);\n            try (InputStream is = artifact.getContentInputStream()) {\n                this.documentAccessBridge.setAttachmentContent(artifactReference, is);\n            }\n        }\n        String result = xdomOfficeDocument.getContentAsString(\"annotatedxhtml/1.0\");\n        xdomOfficeDocument.close();\n        return result;\n    }",
        "patch": "@@ -19,8 +19,6 @@\n  */\n package org.xwiki.wysiwyg.internal.importer;\n \n-import java.io.File;\n-import java.io.FileInputStream;\n import java.io.InputStream;\n import java.util.Map;\n import java.util.Optional;\n@@ -30,7 +28,6 @@\n import javax.inject.Provider;\n import javax.inject.Singleton;\n \n-import org.apache.commons.io.IOUtils;\n import org.xwiki.bridge.DocumentAccessBridge;\n import org.xwiki.component.annotation.Component;\n import org.xwiki.model.reference.AttachmentReference;\n@@ -39,6 +36,7 @@\n import org.xwiki.officeimporter.OfficeImporterException;\n import org.xwiki.officeimporter.builder.PresentationBuilder;\n import org.xwiki.officeimporter.builder.XDOMOfficeDocumentBuilder;\n+import org.xwiki.officeimporter.document.OfficeDocumentArtifact;\n import org.xwiki.officeimporter.document.XDOMOfficeDocument;\n import org.xwiki.officeimporter.server.OfficeServer;\n import org.xwiki.officeimporter.server.OfficeServer.ServerState;\n@@ -167,11 +165,12 @@ private String convertAttachmentContent(AttachmentReference attachmentReference,\n             xdomOfficeDocument = documentBuilder.build(officeFileStream, officeFileName, targetDocRef, filterStyles);\n         }\n         // Attach the images extracted from the imported office document to the target wiki document.\n-        for (File artifact : xdomOfficeDocument.getArtifactsFiles()) {\n-\n-            AttachmentReference artifactReference = new AttachmentReference(artifact.getName(), targetDocRef);\n-            try (FileInputStream fis = new FileInputStream(artifact)) {\n-                documentAccessBridge.setAttachmentContent(artifactReference, IOUtils.toByteArray(fis));\n+        for (Map.Entry<String, OfficeDocumentArtifact> entry : xdomOfficeDocument.getArtifactsMap().entrySet()) {\n+            String filename = entry.getKey();\n+            OfficeDocumentArtifact artifact = entry.getValue();\n+            AttachmentReference artifactReference = new AttachmentReference(filename, targetDocRef);\n+            try (InputStream is = artifact.getContentInputStream()) {\n+                this.documentAccessBridge.setAttachmentContent(artifactReference, is);\n             }\n         }\n         String result = xdomOfficeDocument.getContentAsString(\"annotatedxhtml/1.0\");",
        "function_modified_lines": {
            "added": [
                "        for (Map.Entry<String, OfficeDocumentArtifact> entry : xdomOfficeDocument.getArtifactsMap().entrySet()) {\n",
                "            String filename = entry.getKey();\n",
                "            OfficeDocumentArtifact artifact = entry.getValue();\n",
                "            AttachmentReference artifactReference = new AttachmentReference(filename, targetDocRef);\n",
                "            try (InputStream is = artifact.getContentInputStream()) {\n",
                "                this.documentAccessBridge.setAttachmentContent(artifactReference, is);\n"
            ],
            "deleted": [
                "        for (File artifact : xdomOfficeDocument.getArtifactsFiles()) {\n",
                "\n",
                "            AttachmentReference artifactReference = new AttachmentReference(artifact.getName(), targetDocRef);\n",
                "            try (FileInputStream fis = new FileInputStream(artifact)) {\n",
                "                documentAccessBridge.setAttachmentContent(artifactReference, IOUtils.toByteArray(fis));\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-22"
        ],
        "cve_description": "XWiki Platform is a generic wiki platform offering runtime services for applications built on top of it. Starting in version 3.5-milestone-1 and prior to versions 14.10.8 and 15.3-rc-1, triggering the office converter with a specially crafted file name allows writing the attachment's content to an attacker-controlled location on the server as long as the Java process has write access to that location. In particular in the combination with attachment moving, a feature introduced in XWiki 14.0, this is easy to reproduce but it also possible to reproduce in versions as old as XWiki 3.5 by uploading the attachment through the REST API which doesn't remove `/` or `\\` from the filename. As the mime type of the attachment doesn't matter for the exploitation, this could e.g., be used to replace the `jar`-file of an extension which would allow executing arbitrary Java code and thus impact the confidentiality, integrity and availability of the XWiki installation. This vulnerability has been patched in XWiki 14.10.8 and 15.3RC1. There are no known workarounds apart from disabling the office converter.",
        "id": 12424
    },
    {
        "cve_id": "CVE-2023-37913",
        "code_before_change": "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.officeimporter.internal.filter;\n\nimport java.io.UnsupportedEncodingException;\nimport java.net.URLEncoder;\nimport java.nio.charset.Charset;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\n\nimport javax.inject.Named;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.w3c.dom.Document;\nimport org.xwiki.bridge.DocumentAccessBridge;\nimport org.xwiki.model.reference.AttachmentReference;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.rendering.listener.reference.ResourceReference;\nimport org.xwiki.rendering.listener.reference.ResourceType;\nimport org.xwiki.rendering.renderer.reference.ResourceReferenceSerializer;\nimport org.xwiki.test.junit5.mockito.ComponentTest;\nimport org.xwiki.test.junit5.mockito.MockComponent;\n\nimport com.github.ooxi.jdatauri.DataUri;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.mockito.Mockito.*;\n\n/**\n * Unit tests for {@link ImageFilter}.\n * \n * @version $Id$\n */\n@ComponentTest\npublic class ImageFilterTest extends AbstractHTMLFilterTest\n{\n    @MockComponent\n    private DocumentAccessBridge dab;\n\n    @MockComponent\n    @Named(\"xhtmlmarker\")\n    private ResourceReferenceSerializer xhtmlMarkerSerializer;\n\n    @MockComponent\n    @Named(\"currentmixed\")\n    private DocumentReferenceResolver<String> currentMixedResolver;\n\n    private DocumentReference documentReference = new DocumentReference(\"wiki\", Arrays.asList(\"Path.To\"), \"Page\");\n\n    @BeforeEach\n    @Override\n    public void configure() throws Exception\n    {\n        super.configure();\n        when(this.currentMixedResolver.resolve(\"Path.To.Page\")).thenReturn(this.documentReference);\n    }\n\n    @Test\n    public void filterRemovesAlignAttribute()\n    {\n        filterAndAssertOutput(\"<img align=\\\"center\\\"/>\", \"<img/>\");\n    }\n\n    @Test\n    public void filterAddsImageMarkers()\n    {\n        AttachmentReference attachmentReference = new AttachmentReference(\"-foo--bar.png-\", this.documentReference);\n        when(this.dab.getAttachmentURL(attachmentReference, false)).thenReturn(\"/path/to/foo.png\");\n\n        ResourceReference resourceReference = new ResourceReference(\"-foo--bar.png-\", ResourceType.ATTACHMENT);\n        resourceReference.setTyped(false);\n        when(this.xhtmlMarkerSerializer.serialize(resourceReference)).thenReturn(\"false|-|attach|-|-foo--bar.png-\");\n\n        filterAndAssertOutput(\"<img src=\\\"../../some/path/-foo--b%61r.png-\\\"/>\",\n            Collections.singletonMap(\"targetDocument\", \"Path.To.Page\"),\n            \"<!--startimage:false|-|attach|-|-foo-\\\\-bar.png-\\\\--><img src=\\\"/path/to/foo.png\\\"/><!--stopimage-->\");\n    }\n\n    @Test\n    public void filterAddsImageMarkersSpecialCharacters() throws UnsupportedEncodingException\n    {\n        String imageNameUrl = \"foo&amp;+_b%61r@.png\";\n        String imageName = \"foo&+_bar\\\\@.png\";\n        String encodedImageName = URLEncoder.encode(imageName, \"UTF-8\");\n        AttachmentReference attachmentReference = new AttachmentReference(imageName, this.documentReference);\n        when(this.dab.getAttachmentURL(attachmentReference, false)).thenReturn(\"/path/to/\" + encodedImageName);\n\n        ResourceReference resourceReference = new ResourceReference(imageName, ResourceType.ATTACHMENT);\n        resourceReference.setTyped(false);\n        String imageNameEscaped = \"foo&+_bar\\\\\\\\@.png\";\n        when(this.xhtmlMarkerSerializer.serialize(resourceReference)).thenReturn(\"false|-|attach|-|\" + imageName);\n\n        filterAndAssertOutput(String.format( \"<img src=\\\"../../some/path/%s\\\"/>\", imageNameUrl),\n            Collections.singletonMap(\"targetDocument\", \"Path.To.Page\"),\n            String.format(\"<!--startimage:false|-|attach|-|%s--><img src=\\\"/path/to/%s\\\"/><!--stopimage-->\",\n                imageNameEscaped, encodedImageName));\n    }\n\n    @Test\n    public void filterIgnoresAbsoluteURLs()\n    {\n        filterAndAssertOutput(\"<img src=\\\"http://server/path/to/image.png\\\"/>\",\n            Collections.singletonMap(\"targetDocument\", \"Path.To.Page\"),\n            \"<img src=\\\"http://server/path/to/image.png\\\"/>\");\n        filterAndAssertOutput(\"<img src=\\\"file://path/to/image.png\\\"/>\",\n            Collections.singletonMap(\"targetDocument\", \"Path.To.Page\"), \"<img src=\\\"file://path/to/image.png\\\"/>\");\n    }\n\n    @Test\n    public void filterCollectsEmbeddedImages()\n    {\n        AttachmentReference attachmentReference = new AttachmentReference(\"foo.png\", this.documentReference);\n        when(this.dab.getAttachmentURL(attachmentReference, false)).thenReturn(\"/path/to/foo.png\");\n\n        ResourceReference resourceReference = new ResourceReference(\"foo.png\", ResourceType.ATTACHMENT);\n        resourceReference.setTyped(false);\n        when(this.xhtmlMarkerSerializer.serialize(resourceReference)).thenReturn(\"false|-|attach|-|foo.png\");\n\n        String fileName =\n            DataUri.parse(\"data:image/jpeg;base64,GgoAAAAN==\", Charset.forName(\"UTF-8\")).hashCode() + \".jpg\";\n        attachmentReference = new AttachmentReference(fileName, this.documentReference);\n        when(this.dab.getAttachmentURL(attachmentReference, false)).thenReturn(\"/path/to/\" + fileName);\n\n        resourceReference = new ResourceReference(fileName, ResourceType.ATTACHMENT);\n        resourceReference.setTyped(false);\n        when(this.xhtmlMarkerSerializer.serialize(resourceReference)).thenReturn(\"false|-|attach|-|\" + fileName);\n\n        Map<String, String> parameters = new HashMap<String, String>();\n        parameters.put(\"targetDocument\", \"Path.To.Page\");\n        parameters.put(\"attachEmbeddedImages\", \"true\");\n\n        Document document = filterAndAssertOutput(\n            \"<img src=\\\"data:image/png;fileName=foo.png;base64,iVBORw0K==\\\"/>\"\n                + \"<img src=\\\"data:image/jpeg;base64,GgoAAAAN==\\\"/>\",\n            parameters,\n            \"<!--startimage:false|-|attach|-|foo.png--><img src=\\\"/path/to/foo.png\\\"/><!--stopimage-->\"\n                + \"<!--startimage:false|-|attach|-|\" + fileName + \"--><img src=\\\"/path/to/\" + fileName\n                + \"\\\"/><!--stopimage-->\");\n\n        @SuppressWarnings(\"unchecked\")\n        Map<String, byte[]> embeddedImages = (Map<String, byte[]>) document.getUserData(\"embeddedImages\");\n        assertEquals(new HashSet<>(Arrays.asList(\"foo.png\", fileName)), embeddedImages.keySet());\n    }\n}\n",
        "code_after_change": "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.officeimporter.internal.filter;\n\nimport java.io.UnsupportedEncodingException;\nimport java.net.URLEncoder;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\n\nimport javax.inject.Named;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.w3c.dom.Document;\nimport org.xwiki.bridge.DocumentAccessBridge;\nimport org.xwiki.model.reference.AttachmentReference;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.rendering.internal.renderer.xhtml.XHTMLMarkerResourceReferenceSerializer;\nimport org.xwiki.rendering.listener.reference.ResourceReference;\nimport org.xwiki.rendering.listener.reference.ResourceType;\nimport org.xwiki.test.annotation.ComponentList;\nimport org.xwiki.test.junit5.mockito.ComponentTest;\nimport org.xwiki.test.junit5.mockito.MockComponent;\n\nimport com.github.ooxi.jdatauri.DataUri;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\n/**\n * Unit tests for {@link ImageFilter}.\n * \n * @version $Id$\n */\n@ComponentTest\n@ComponentList({ XHTMLMarkerResourceReferenceSerializer.class })\npublic class ImageFilterTest extends AbstractHTMLFilterTest\n{\n    @MockComponent\n    private DocumentAccessBridge dab;\n\n    @MockComponent\n    @Named(\"currentmixed\")\n    private DocumentReferenceResolver<String> currentMixedResolver;\n\n    private DocumentReference documentReference = new DocumentReference(\"wiki\", Arrays.asList(\"Path.To\"), \"Page\");\n\n    @BeforeEach\n    @Override\n    public void configure() throws Exception\n    {\n        super.configure();\n        when(this.currentMixedResolver.resolve(\"Path.To.Page\")).thenReturn(this.documentReference);\n    }\n\n    @Test\n    public void filterRemovesAlignAttribute()\n    {\n        filterAndAssertOutput(\"<img align=\\\"center\\\"/>\", \"<img/>\");\n    }\n\n    @Test\n    public void filterAddsImageMarkers()\n    {\n        AttachmentReference attachmentReference = new AttachmentReference(\"-foo--bar.png-\", this.documentReference);\n        when(this.dab.getAttachmentURL(attachmentReference, false)).thenReturn(\"/path/to/foo.png\");\n\n        ResourceReference resourceReference = new ResourceReference(\"-foo--bar.png-\", ResourceType.ATTACHMENT);\n        resourceReference.setTyped(false);\n\n        filterAndAssertOutput(\"<img src=\\\"../../some/path/-foo--b%61r.png-\\\"/>\",\n            Collections.singletonMap(\"targetDocument\", \"Path.To.Page\"),\n            \"<!--startimage:false|-|attach|-|-foo-\\\\-bar.png-\\\\--><img src=\\\"/path/to/foo.png\\\"/><!--stopimage-->\");\n    }\n\n    @Test\n    public void filterAddsImageMarkersSpecialCharacters() throws UnsupportedEncodingException\n    {\n        String imageNameUrl = \"foo&amp;+_b%61r@.png\";\n        String imageName = \"foo&+_bar\\\\@.png\";\n        String encodedImageName = URLEncoder.encode(imageName, \"UTF-8\");\n        AttachmentReference attachmentReference = new AttachmentReference(imageName, this.documentReference);\n        when(this.dab.getAttachmentURL(attachmentReference, false)).thenReturn(\"/path/to/\" + encodedImageName);\n\n        ResourceReference resourceReference = new ResourceReference(imageName, ResourceType.ATTACHMENT);\n        resourceReference.setTyped(false);\n        String imageNameEscaped = \"foo&+_bar\\\\\\\\@.png\";\n\n        filterAndAssertOutput(String.format( \"<img src=\\\"../../some/path/%s\\\"/>\", imageNameUrl),\n            Collections.singletonMap(\"targetDocument\", \"Path.To.Page\"),\n            String.format(\"<!--startimage:false|-|attach|-|%s--><img src=\\\"/path/to/%s\\\"/><!--stopimage-->\",\n                imageNameEscaped, encodedImageName));\n    }\n\n    @Test\n    public void filterIgnoresAbsoluteURLs()\n    {\n        filterAndAssertOutput(\"<img src=\\\"http://server/path/to/image.png\\\"/>\",\n            Collections.singletonMap(\"targetDocument\", \"Path.To.Page\"),\n            \"<img src=\\\"http://server/path/to/image.png\\\"/>\");\n        filterAndAssertOutput(\"<img src=\\\"file://path/to/image.png\\\"/>\",\n            Collections.singletonMap(\"targetDocument\", \"Path.To.Page\"), \"<img src=\\\"file://path/to/image.png\\\"/>\");\n    }\n\n    @Test\n    public void filterCollectsEmbeddedImages()\n    {\n        AttachmentReference attachmentReference = new AttachmentReference(\"foo.png\", this.documentReference);\n        when(this.dab.getAttachmentURL(attachmentReference, false)).thenReturn(\"/path/to/foo.png\");\n\n        ResourceReference resourceReference = new ResourceReference(\"foo.png\", ResourceType.ATTACHMENT);\n        resourceReference.setTyped(false);\n\n        String fileName =\n            DataUri.parse(\"data:image/jpeg;base64,GgoAAAAN==\", Charset.forName(\"UTF-8\")).hashCode() + \".jpg\";\n        attachmentReference = new AttachmentReference(fileName, this.documentReference);\n        when(this.dab.getAttachmentURL(attachmentReference, false)).thenReturn(\"/path/to/\" + fileName);\n\n        resourceReference = new ResourceReference(fileName, ResourceType.ATTACHMENT);\n        resourceReference.setTyped(false);\n\n        Map<String, String> parameters = new HashMap<String, String>();\n        parameters.put(\"targetDocument\", \"Path.To.Page\");\n        parameters.put(\"attachEmbeddedImages\", \"true\");\n\n        Document document = filterAndAssertOutput(\n            \"<img src=\\\"data:image/png;fileName=foo.png;base64,iVBORw0K==\\\"/>\"\n                + \"<img src=\\\"data:image/jpeg;base64,GgoAAAAN==\\\"/>\",\n            parameters,\n            \"<!--startimage:false|-|attach|-|foo.png--><img src=\\\"/path/to/foo.png\\\"/><!--stopimage-->\"\n                + \"<!--startimage:false|-|attach|-|\" + fileName + \"--><img src=\\\"/path/to/\" + fileName\n                + \"\\\"/><!--stopimage-->\");\n\n        @SuppressWarnings(\"unchecked\")\n        Map<String, byte[]> embeddedImages = (Map<String, byte[]>) document.getUserData(\"embeddedImages\");\n        assertEquals(new HashSet<>(Arrays.asList(\"foo.png\", fileName)), embeddedImages.keySet());\n    }\n\n    @Test\n    void rewriteImagePrefix() throws UnsupportedEncodingException\n    {\n        Map<String, String> configuration = Map.of(\n            \"targetDocument\", \"Path.To.Page\",\n            \"replaceImagePrefix\", \"output_\",\n            \"replacementImagePrefix\", \"re@placement_\"\n        );\n\n        String imageName = \"re\\\\@placement_image.png\";\n        String encodedImageName = URLEncoder.encode(imageName.replace(\"\\\\@\", \"@\"), StandardCharsets.UTF_8);\n        AttachmentReference attachmentReference = new AttachmentReference(imageName, this.documentReference);\n        when(this.dab.getAttachmentURL(attachmentReference, false)).thenReturn(\"/path/to/\" + encodedImageName);\n\n        filterAndAssertOutput(\"<img src=\\\"output_image.png\\\" />\", configuration,\n            \"<!--startimage:false|-|attach|-|re\\\\\\\\@placement_image.png-->\"\n                + \"<img src=\\\"/path/to/re%40placement_image.png\\\"/><!--stopimage-->\");\n\n        verify(this.dab).getAttachmentURL(attachmentReference, false);\n    }\n}\n",
        "patch": "@@ -22,6 +22,7 @@\n import java.io.UnsupportedEncodingException;\n import java.net.URLEncoder;\n import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n import java.util.Arrays;\n import java.util.Collections;\n import java.util.HashMap;\n@@ -37,32 +38,31 @@\n import org.xwiki.model.reference.AttachmentReference;\n import org.xwiki.model.reference.DocumentReference;\n import org.xwiki.model.reference.DocumentReferenceResolver;\n+import org.xwiki.rendering.internal.renderer.xhtml.XHTMLMarkerResourceReferenceSerializer;\n import org.xwiki.rendering.listener.reference.ResourceReference;\n import org.xwiki.rendering.listener.reference.ResourceType;\n-import org.xwiki.rendering.renderer.reference.ResourceReferenceSerializer;\n+import org.xwiki.test.annotation.ComponentList;\n import org.xwiki.test.junit5.mockito.ComponentTest;\n import org.xwiki.test.junit5.mockito.MockComponent;\n \n import com.github.ooxi.jdatauri.DataUri;\n \n import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.mockito.Mockito.*;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n \n /**\n  * Unit tests for {@link ImageFilter}.\n  * \n  * @version $Id$\n  */\n @ComponentTest\n+@ComponentList({ XHTMLMarkerResourceReferenceSerializer.class })\n public class ImageFilterTest extends AbstractHTMLFilterTest\n {\n     @MockComponent\n     private DocumentAccessBridge dab;\n \n-    @MockComponent\n-    @Named(\"xhtmlmarker\")\n-    private ResourceReferenceSerializer xhtmlMarkerSerializer;\n-\n     @MockComponent\n     @Named(\"currentmixed\")\n     private DocumentReferenceResolver<String> currentMixedResolver;\n@@ -91,7 +91,6 @@ public void filterAddsImageMarkers()\n \n         ResourceReference resourceReference = new ResourceReference(\"-foo--bar.png-\", ResourceType.ATTACHMENT);\n         resourceReference.setTyped(false);\n-        when(this.xhtmlMarkerSerializer.serialize(resourceReference)).thenReturn(\"false|-|attach|-|-foo--bar.png-\");\n \n         filterAndAssertOutput(\"<img src=\\\"../../some/path/-foo--b%61r.png-\\\"/>\",\n             Collections.singletonMap(\"targetDocument\", \"Path.To.Page\"),\n@@ -110,7 +109,6 @@ public void filterAddsImageMarkersSpecialCharacters() throws UnsupportedEncoding\n         ResourceReference resourceReference = new ResourceReference(imageName, ResourceType.ATTACHMENT);\n         resourceReference.setTyped(false);\n         String imageNameEscaped = \"foo&+_bar\\\\\\\\@.png\";\n-        when(this.xhtmlMarkerSerializer.serialize(resourceReference)).thenReturn(\"false|-|attach|-|\" + imageName);\n \n         filterAndAssertOutput(String.format( \"<img src=\\\"../../some/path/%s\\\"/>\", imageNameUrl),\n             Collections.singletonMap(\"targetDocument\", \"Path.To.Page\"),\n@@ -136,7 +134,6 @@ public void filterCollectsEmbeddedImages()\n \n         ResourceReference resourceReference = new ResourceReference(\"foo.png\", ResourceType.ATTACHMENT);\n         resourceReference.setTyped(false);\n-        when(this.xhtmlMarkerSerializer.serialize(resourceReference)).thenReturn(\"false|-|attach|-|foo.png\");\n \n         String fileName =\n             DataUri.parse(\"data:image/jpeg;base64,GgoAAAAN==\", Charset.forName(\"UTF-8\")).hashCode() + \".jpg\";\n@@ -145,7 +142,6 @@ public void filterCollectsEmbeddedImages()\n \n         resourceReference = new ResourceReference(fileName, ResourceType.ATTACHMENT);\n         resourceReference.setTyped(false);\n-        when(this.xhtmlMarkerSerializer.serialize(resourceReference)).thenReturn(\"false|-|attach|-|\" + fileName);\n \n         Map<String, String> parameters = new HashMap<String, String>();\n         parameters.put(\"targetDocument\", \"Path.To.Page\");\n@@ -163,4 +159,25 @@ public void filterCollectsEmbeddedImages()\n         Map<String, byte[]> embeddedImages = (Map<String, byte[]>) document.getUserData(\"embeddedImages\");\n         assertEquals(new HashSet<>(Arrays.asList(\"foo.png\", fileName)), embeddedImages.keySet());\n     }\n+\n+    @Test\n+    void rewriteImagePrefix() throws UnsupportedEncodingException\n+    {\n+        Map<String, String> configuration = Map.of(\n+            \"targetDocument\", \"Path.To.Page\",\n+            \"replaceImagePrefix\", \"output_\",\n+            \"replacementImagePrefix\", \"re@placement_\"\n+        );\n+\n+        String imageName = \"re\\\\@placement_image.png\";\n+        String encodedImageName = URLEncoder.encode(imageName.replace(\"\\\\@\", \"@\"), StandardCharsets.UTF_8);\n+        AttachmentReference attachmentReference = new AttachmentReference(imageName, this.documentReference);\n+        when(this.dab.getAttachmentURL(attachmentReference, false)).thenReturn(\"/path/to/\" + encodedImageName);\n+\n+        filterAndAssertOutput(\"<img src=\\\"output_image.png\\\" />\", configuration,\n+            \"<!--startimage:false|-|attach|-|re\\\\\\\\@placement_image.png-->\"\n+                + \"<img src=\\\"/path/to/re%40placement_image.png\\\"/><!--stopimage-->\");\n+\n+        verify(this.dab).getAttachmentURL(attachmentReference, false);\n+    }\n }",
        "function_modified_lines": {
            "added": [
                "import org.xwiki.rendering.internal.renderer.xhtml.XHTMLMarkerResourceReferenceSerializer;\n",
                "import org.xwiki.test.annotation.ComponentList;\n",
                "import static org.mockito.Mockito.verify;\n",
                "import static org.mockito.Mockito.when;\n",
                "@ComponentList({ XHTMLMarkerResourceReferenceSerializer.class })\n"
            ],
            "deleted": [
                "import org.xwiki.rendering.renderer.reference.ResourceReferenceSerializer;\n",
                "import static org.mockito.Mockito.*;\n",
                "    @MockComponent\n",
                "    @Named(\"xhtmlmarker\")\n",
                "    private ResourceReferenceSerializer xhtmlMarkerSerializer;\n",
                "\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-22"
        ],
        "cve_description": "XWiki Platform is a generic wiki platform offering runtime services for applications built on top of it. Starting in version 3.5-milestone-1 and prior to versions 14.10.8 and 15.3-rc-1, triggering the office converter with a specially crafted file name allows writing the attachment's content to an attacker-controlled location on the server as long as the Java process has write access to that location. In particular in the combination with attachment moving, a feature introduced in XWiki 14.0, this is easy to reproduce but it also possible to reproduce in versions as old as XWiki 3.5 by uploading the attachment through the REST API which doesn't remove `/` or `\\` from the filename. As the mime type of the attachment doesn't matter for the exploitation, this could e.g., be used to replace the `jar`-file of an extension which would allow executing arbitrary Java code and thus impact the confidentiality, integrity and availability of the XWiki installation. This vulnerability has been patched in XWiki 14.10.8 and 15.3RC1. There are no known workarounds apart from disabling the office converter.",
        "id": 12413
    },
    {
        "cve_id": "CVE-2023-37913",
        "code_before_change": "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.office.viewer.internal;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\n\nimport javax.inject.Inject;\nimport javax.inject.Named;\nimport javax.inject.Provider;\nimport javax.inject.Singleton;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.slf4j.Logger;\nimport org.xwiki.bridge.DocumentAccessBridge;\nimport org.xwiki.cache.Cache;\nimport org.xwiki.cache.CacheException;\nimport org.xwiki.cache.CacheManager;\nimport org.xwiki.cache.config.LRUCacheConfiguration;\nimport org.xwiki.component.annotation.Component;\nimport org.xwiki.component.phase.Initializable;\nimport org.xwiki.component.phase.InitializationException;\nimport org.xwiki.model.reference.AttachmentReference;\nimport org.xwiki.model.reference.AttachmentReferenceResolver;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.EntityReference;\nimport org.xwiki.model.reference.EntityReferenceSerializer;\nimport org.xwiki.model.reference.PageAttachmentReference;\nimport org.xwiki.model.reference.PageAttachmentReferenceResolver;\nimport org.xwiki.office.viewer.OfficeResourceViewer;\nimport org.xwiki.officeimporter.OfficeImporterException;\nimport org.xwiki.officeimporter.builder.PresentationBuilder;\nimport org.xwiki.officeimporter.builder.XDOMOfficeDocumentBuilder;\nimport org.xwiki.officeimporter.converter.OfficeConverter;\nimport org.xwiki.officeimporter.document.XDOMOfficeDocument;\nimport org.xwiki.officeimporter.server.OfficeServer;",
        "code_after_change": "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.office.viewer.internal;\n\nimport java.io.File;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\n\nimport javax.inject.Inject;\nimport javax.inject.Named;\nimport javax.inject.Provider;\nimport javax.inject.Singleton;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.slf4j.Logger;\nimport org.xwiki.bridge.DocumentAccessBridge;\nimport org.xwiki.cache.Cache;\nimport org.xwiki.cache.CacheException;\nimport org.xwiki.cache.CacheManager;\nimport org.xwiki.cache.config.LRUCacheConfiguration;\nimport org.xwiki.component.annotation.Component;\nimport org.xwiki.component.phase.Initializable;\nimport org.xwiki.component.phase.InitializationException;\nimport org.xwiki.model.reference.AttachmentReference;\nimport org.xwiki.model.reference.AttachmentReferenceResolver;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.EntityReference;\nimport org.xwiki.model.reference.EntityReferenceSerializer;\nimport org.xwiki.model.reference.PageAttachmentReference;\nimport org.xwiki.model.reference.PageAttachmentReferenceResolver;\nimport org.xwiki.office.viewer.OfficeResourceViewer;\nimport org.xwiki.officeimporter.OfficeImporterException;\nimport org.xwiki.officeimporter.builder.PresentationBuilder;\nimport org.xwiki.officeimporter.builder.XDOMOfficeDocumentBuilder;\nimport org.xwiki.officeimporter.converter.OfficeConverter;\nimport org.xwiki.officeimporter.document.OfficeDocumentArtifact;\nimport org.xwiki.officeimporter.document.XDOMOfficeDocument;\nimport org.xwiki.officeimporter.server.OfficeServer;\nimport org.xwiki.properties.ConverterManager;",
        "patch": "@@ -20,12 +20,10 @@\n package org.xwiki.office.viewer.internal;\n \n import java.io.File;\n-import java.io.FileInputStream;\n import java.io.InputStream;\n import java.net.URL;\n import java.util.Arrays;\n import java.util.Collections;\n-import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n@@ -60,6 +58,7 @@\n import org.xwiki.officeimporter.builder.PresentationBuilder;\n import org.xwiki.officeimporter.builder.XDOMOfficeDocumentBuilder;\n import org.xwiki.officeimporter.converter.OfficeConverter;\n+import org.xwiki.officeimporter.document.OfficeDocumentArtifact;\n import org.xwiki.officeimporter.document.XDOMOfficeDocument;\n import org.xwiki.officeimporter.server.OfficeServer;\n import org.xwiki.properties.ConverterManager;\n@@ -200,41 +199,39 @@ public class DefaultOfficeResourceViewer implements OfficeResourceViewer, Initia\n      * images that are view artifacts.\n      * \n      * @param xdom the XDOM whose image blocks are to be processed\n-     * @param artifactFiles specify which of the image blocks should be processed; only the image blocks\n+     * @param artifactMap specify which of the image blocks should be processed; only the image blocks\n      *          that were generated during the office import process should be processed\n      * @param ownerDocumentReference specifies the document that owns the office file\n      * @param parameters the build parameters. Note that currently only {@code filterStyles} is supported and if \"true\"\n      *            it means that styles will be filtered to the maximum and the focus will be put on importing only the\n      * @return the set of temporary files corresponding to image artifacts\n      */\n-    private Set<File> processImages(XDOM xdom, Set<File> artifactFiles, DocumentReference ownerDocumentReference,\n-        Map<String, ?> parameters)\n+    private Set<File> processImages(XDOM xdom, Map<String, OfficeDocumentArtifact> artifactMap,\n+        DocumentReference ownerDocumentReference, Map<String, ?> parameters)\n     {\n         // Process all image blocks.\n         Set<File> temporaryFiles = new HashSet<>();\n         List<ImageBlock> imgBlocks = xdom.getBlocks(new ClassBlockMatcher(ImageBlock.class), Block.Axes.DESCENDANT);\n         if (!imgBlocks.isEmpty()) {\n-            Map<String, File> fileMap = new HashMap<>();\n-            for (File file : artifactFiles) {\n-                fileMap.put(file.getName(), file);\n-            }\n-\n             for (ImageBlock imgBlock : imgBlocks) {\n                 String imageReference = imgBlock.getReference().getReference();\n \n                 // Check whether there is a corresponding artifact.\n-                if (fileMap.containsKey(imageReference)) {\n+                if (artifactMap.containsKey(imageReference)) {\n                     try {\n                         List<String> resourcePath =\n                             Arrays.asList(String.valueOf(parameters.hashCode()), imageReference);\n                         TemporaryResourceReference temporaryResourceReference =\n                             new TemporaryResourceReference(MODULE_NAME, resourcePath, ownerDocumentReference);\n \n                         // Write the image into a temporary file.\n-                        File artifact = fileMap.get(imageReference);\n+                        OfficeDocumentArtifact artifact = artifactMap.get(imageReference);\n \n-                        File tempFile = this.temporaryResourceStore.createTemporaryFile(temporaryResourceReference,\n-                            new FileInputStream(artifact));\n+                        File tempFile;\n+                        try (InputStream inputStream = artifact.getContentInputStream()) {\n+                            tempFile = this.temporaryResourceStore.createTemporaryFile(temporaryResourceReference,\n+                                inputStream);\n+                        }\n \n                         // Create a URL image reference which links to above temporary image file.\n                         String temporaryResourceURL =\n@@ -429,7 +426,7 @@ private OfficeDocumentView getView(ResourceReference reference, AttachmentRefere\n                 // specified by the owner document reference. This way we ensure the path to the temporary files\n                 // doesn't contain redundant information and so it remains as small as possible (considering that the\n                 // path length is limited on some environments).\n-                Set<File> temporaryFiles = processImages(xdom, xdomOfficeDocument.getArtifactsFiles(),\n+                Set<File> temporaryFiles = processImages(xdom, xdomOfficeDocument.getArtifactsMap(),\n                     attachmentReference.getDocumentReference(), parameters);\n                 view = new AttachmentOfficeDocumentView(reference, attachmentReference, attachmentVersion, xdom,\n                     temporaryFiles);\n@@ -457,7 +454,7 @@ private OfficeDocumentView getView(ResourceReference resourceReference, Map<Stri\n             try (XDOMOfficeDocument xdomOfficeDocument = createXDOM(ownerDocument, resourceReference, parameters))\n             {\n                 XDOM xdom = xdomOfficeDocument.getContentDocument();\n-                Set<File> temporaryFiles = processImages(xdom, xdomOfficeDocument.getArtifactsFiles(), ownerDocument,\n+                Set<File> temporaryFiles = processImages(xdom, xdomOfficeDocument.getArtifactsMap(), ownerDocument,\n                     parameters);\n                 view = new OfficeDocumentView(resourceReference, xdom, temporaryFiles);\n ",
        "function_modified_lines": {
            "added": [],
            "deleted": [
                "import java.io.FileInputStream;\n",
                "import java.util.HashMap;\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-22"
        ],
        "cve_description": "XWiki Platform is a generic wiki platform offering runtime services for applications built on top of it. Starting in version 3.5-milestone-1 and prior to versions 14.10.8 and 15.3-rc-1, triggering the office converter with a specially crafted file name allows writing the attachment's content to an attacker-controlled location on the server as long as the Java process has write access to that location. In particular in the combination with attachment moving, a feature introduced in XWiki 14.0, this is easy to reproduce but it also possible to reproduce in versions as old as XWiki 3.5 by uploading the attachment through the REST API which doesn't remove `/` or `\\` from the filename. As the mime type of the attachment doesn't matter for the exploitation, this could e.g., be used to replace the `jar`-file of an extension which would allow executing arbitrary Java code and thus impact the confidentiality, integrity and availability of the XWiki installation. This vulnerability has been patched in XWiki 14.10.8 and 15.3RC1. There are no known workarounds apart from disabling the office converter.",
        "id": 12417
    },
    {
        "cve_id": "CVE-2021-39180",
        "code_before_change": "/**\n * <a href=\"http://www.openolat.org\">\n * OpenOLAT - Online Learning and Training</a><br>\n * <p>\n * Licensed under the Apache License, Version 2.0 (the \"License\"); <br>\n * you may not use this file except in compliance with the License.<br>\n * You may obtain a copy of the License at the\n * <a href=\"http://www.apache.org/licenses/LICENSE-2.0\">Apache homepage</a>\n * <p>\n * Unless required by applicable law or agreed to in writing,<br>\n * software distributed under the License is distributed on an \"AS IS\" BASIS, <br>\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. <br>\n * See the License for the specific language governing permissions and <br>\n * limitations under the License.\n * <p>\n * Initial code contributed and copyrighted by<br>\n * frentix GmbH, http://www.frentix.com\n * <p>\n */\npackage org.olat.core.util;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.FileSystems;\nimport java.nio.file.FileVisitResult;\nimport java.nio.file.FileVisitor;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.PathMatcher;\nimport java.nio.file.Paths;\nimport java.nio.file.ProviderNotFoundException;\nimport java.nio.file.SimpleFileVisitor;\nimport java.nio.file.StandardCopyOption;\nimport java.nio.file.attribute.BasicFileAttributes;\nimport java.util.ServiceConfigurationError;\n\nimport org.apache.commons.io.IOUtils;\n\n/**\n * \n * Initial date: 08.05.2014<br>\n * @author srosse, stephane.rosse@frentix.com, http://www.frentix.com\n *\n */\npublic class PathUtils {\n\t\n\t/**\n\t * \n\t * @param source\n\t * @param targetDir\n\t * @param path Relative path where the file is saved from targetDir\n\t * @return\n\t * @throws IOException\n\t */\n\tpublic static boolean copyFileToDir(Path source, File targetDir, String path) throws IOException {\n\t\tFile targetFile = new File(targetDir, path);\n\t\tif(!targetFile.getParentFile().exists()) {\n\t\t\ttargetFile.getParentFile().mkdirs();\n\t\t}\n\t\tFiles.copy(source, targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING);\n\t\treturn true;\n\t}\n\t\n\t/**\n\t * Use the closeSubsequentFS method to close the file system.\n\t * \n\t * @param file The file to visit\n\t * @param filename The filename\n\t * @param visitor The visitor\n\t * @return\n\t * @throws IOException\n\t * @throws IllegalArgumentException\n\t */\n\tpublic static Path visit(File file, String filename, FileVisitor<Path> visitor) \n\tthrows IOException, IllegalArgumentException {\n\t\tif(!StringHelper.containsNonWhitespace(filename)) {\n\t\t\tfilename = file.getName();\n\t\t}\n\t\t\n\t\tPath fPath = null;\n\t\tif(file.isDirectory()) {\n\t\t\tfPath = file.toPath();\n\t\t} else if(filename != null && filename.toLowerCase().endsWith(\".zip\")) {\n\t\t\ttry {\n\t\t\t\tfPath = FileSystems.newFileSystem(file.toPath(), null).getPath(\"/\");\n\t\t\t} catch (ProviderNotFoundException | ServiceConfigurationError e) {\n\t\t\t\tthrow new IOException(\"Unreadable file with .zip extension: \" + file, e);\n\t\t\t}\n\t\t} else {\n\t\t\tfPath = file.toPath();\n\t\t}\n\t\tif(fPath != null) {\n\t\t    Files.walkFileTree(fPath, visitor);\n\t\t}\n\t\treturn fPath;\n\t}\n\t\n\tpublic static void closeSubsequentFS(Path path) {\n\t\tif(path != null && FileSystems.getDefault() != path.getFileSystem()) {\n\t\t\tIOUtils.closeQuietly(path.getFileSystem());\n\t\t}\n\t}\n\t\n\tpublic static class YesMatcher implements PathMatcher {\n\t\t@Override\n\t\tpublic boolean matches(Path path) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tpublic static class CopyVisitor extends SimpleFileVisitor<Path> {\n\n\t\tprivate final Path source;\n\t\tprivate final Path destDir;\n\t\tprivate final PathMatcher filter;\n\t\t\n\t\tpublic CopyVisitor(Path source, Path destDir, PathMatcher filter) {\n\t\t\tthis.source = source;\n\t\t\tthis.destDir = destDir;\n\t\t\tthis.filter = filter;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic FileVisitResult visitFile(Path file, BasicFileAttributes attrs)\n\t    throws IOException {\n\t\t\tPath relativeFile = source.relativize(file);\n\t        final Path destFile = Paths.get(destDir.toString(), relativeFile.toString());\n\t        if(filter.matches(file)) {\n\t        \tFiles.copy(file, destFile, StandardCopyOption.REPLACE_EXISTING);\n\t        }\n\t        return FileVisitResult.CONTINUE;\n\t\t}\n\t \n\t\t@Override\n\t\tpublic FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs)\n\t\tthrows IOException {\n\t\t\tPath relativeDir = source.relativize(dir);\n\t        final Path dirToCreate = Paths.get(destDir.toString(), relativeDir.toString());\n\t        if(Files.notExists(dirToCreate)){\n\t        \tFiles.createDirectory(dirToCreate);\n\t        }\n\t        return FileVisitResult.CONTINUE;\n\t\t}\n\t}\n\n}\n",
        "code_after_change": "/**\n * <a href=\"http://www.openolat.org\">\n * OpenOLAT - Online Learning and Training</a><br>\n * <p>\n * Licensed under the Apache License, Version 2.0 (the \"License\"); <br>\n * you may not use this file except in compliance with the License.<br>\n * You may obtain a copy of the License at the\n * <a href=\"http://www.apache.org/licenses/LICENSE-2.0\">Apache homepage</a>\n * <p>\n * Unless required by applicable law or agreed to in writing,<br>\n * software distributed under the License is distributed on an \"AS IS\" BASIS, <br>\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. <br>\n * See the License for the specific language governing permissions and <br>\n * limitations under the License.\n * <p>\n * Initial code contributed and copyrighted by<br>\n * frentix GmbH, http://www.frentix.com\n * <p>\n */\npackage org.olat.core.util;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.FileSystems;\nimport java.nio.file.FileVisitOption;\nimport java.nio.file.FileVisitResult;\nimport java.nio.file.FileVisitor;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.PathMatcher;\nimport java.nio.file.Paths;\nimport java.nio.file.ProviderNotFoundException;\nimport java.nio.file.SimpleFileVisitor;\nimport java.nio.file.StandardCopyOption;\nimport java.nio.file.attribute.BasicFileAttributes;\nimport java.util.EnumSet;\nimport java.util.ServiceConfigurationError;\n\nimport org.apache.commons.io.IOUtils;\nimport org.olat.core.logging.OLATRuntimeException;\n\n/**\n * \n * Initial date: 08.05.2014<br>\n * @author srosse, stephane.rosse@frentix.com, http://www.frentix.com\n *\n */\npublic class PathUtils {\n\t\n\t/**\n\t * \n\t * @param source\n\t * @param targetDir\n\t * @param path Relative path where the file is saved from targetDir\n\t * @return\n\t * @throws IOException\n\t */\n\tpublic static boolean copyFileToDir(Path source, File targetDir, String path) throws IOException {\n\t\tFile targetFile = new File(targetDir, path);\n\t\tif(!targetFile.getParentFile().exists()) {\n\t\t\ttargetFile.getParentFile().mkdirs();\n\t\t}\n\t\tFiles.copy(source, targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING);\n\t\treturn true;\n\t}\n\t\n\t/**\n\t * Use the closeSubsequentFS method to close the file system. The method doesn't\n\t * follow sym. links and its depth is limited.\n\t * \n\t * @param file The file to visit\n\t * @param filename The filename\n\t * @param visitor The visitor\n\t * @return\n\t * @throws IOException\n\t * @throws IllegalArgumentException\n\t */\n\tpublic static Path visit(File file, String filename, FileVisitor<Path> visitor) \n\tthrows IOException, IllegalArgumentException {\n\t\tif(!StringHelper.containsNonWhitespace(filename)) {\n\t\t\tfilename = file.getName();\n\t\t}\n\t\t\n\t\tPath fPath = null;\n\t\tif(file.isDirectory()) {\n\t\t\tfPath = file.toPath();\n\t\t} else if(filename != null && filename.toLowerCase().endsWith(\".zip\")) {\n\t\t\ttry {\n\t\t\t\tfPath = FileSystems.newFileSystem(file.toPath(), null).getPath(\"/\");\n\t\t\t} catch (ProviderNotFoundException | ServiceConfigurationError e) {\n\t\t\t\tthrow new IOException(\"Unreadable file with .zip extension: \" + file, e);\n\t\t\t}\n\t\t} else {\n\t\t\tfPath = file.toPath();\n\t\t}\n\t\tif(fPath != null) {\n\t\t    Files.walkFileTree(fPath, EnumSet.noneOf(FileVisitOption.class), 32, visitor);\n\t\t}\n\t\treturn fPath;\n\t}\n\t\n\tpublic static void closeSubsequentFS(Path path) {\n\t\tif(path != null && FileSystems.getDefault() != path.getFileSystem()) {\n\t\t\tIOUtils.closeQuietly(path.getFileSystem(), null);\n\t\t}\n\t}\n\t\n\tpublic static class YesMatcher implements PathMatcher {\n\t\t@Override\n\t\tpublic boolean matches(Path path) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tpublic static class CopyVisitor extends SimpleFileVisitor<Path> {\n\n\t\tprivate final Path source;\n\t\tprivate final Path destDir;\n\t\tprivate final PathMatcher filter;\n\t\t\n\t\tpublic CopyVisitor(Path source, Path destDir, PathMatcher filter) {\n\t\t\tthis.source = source;\n\t\t\tthis.destDir = destDir;\n\t\t\tthis.filter = filter;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic FileVisitResult visitFile(Path file, BasicFileAttributes attrs)\n\t    throws IOException {\n\t\t\tPath relativeFile = source.relativize(file);\n\t        final Path destFile = Paths.get(destDir.toString(), relativeFile.toString());\n\t        Path normalizedPath = destFile.normalize();\n\t\t\tif(!normalizedPath.startsWith(destDir)) {\n\t\t\t\tthrow new OLATRuntimeException(\"Invalid ZIP\");\n\t\t\t}\n\t        if(filter.matches(file)) {\n\t        \tFiles.copy(file, destFile, StandardCopyOption.REPLACE_EXISTING);\n\t        }\n\t        return FileVisitResult.CONTINUE;\n\t\t}\n\t \n\t\t@Override\n\t\tpublic FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs)\n\t\tthrows IOException {\n\t\t\tPath relativeDir = source.relativize(dir);\n\t        final Path dirToCreate = Paths.get(destDir.toString(), relativeDir.toString());\n\t        if(Files.notExists(dirToCreate)){\n\t        \tFiles.createDirectory(dirToCreate);\n\t        }\n\t        return FileVisitResult.CONTINUE;\n\t\t}\n\t}\n\n}\n",
        "patch": "@@ -22,6 +22,7 @@\n import java.io.File;\n import java.io.IOException;\n import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitOption;\n import java.nio.file.FileVisitResult;\n import java.nio.file.FileVisitor;\n import java.nio.file.Files;\n@@ -32,9 +33,11 @@\n import java.nio.file.SimpleFileVisitor;\n import java.nio.file.StandardCopyOption;\n import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.EnumSet;\n import java.util.ServiceConfigurationError;\n \n import org.apache.commons.io.IOUtils;\n+import org.olat.core.logging.OLATRuntimeException;\n \n /**\n  * \n@@ -62,7 +65,8 @@ public static boolean copyFileToDir(Path source, File targetDir, String path) th\n \t}\n \t\n \t/**\n-\t * Use the closeSubsequentFS method to close the file system.\n+\t * Use the closeSubsequentFS method to close the file system. The method doesn't\n+\t * follow sym. links and its depth is limited.\n \t * \n \t * @param file The file to visit\n \t * @param filename The filename\n@@ -90,14 +94,14 @@ public static Path visit(File file, String filename, FileVisitor<Path> visitor)\n \t\t\tfPath = file.toPath();\n \t\t}\n \t\tif(fPath != null) {\n-\t\t    Files.walkFileTree(fPath, visitor);\n+\t\t    Files.walkFileTree(fPath, EnumSet.noneOf(FileVisitOption.class), 32, visitor);\n \t\t}\n \t\treturn fPath;\n \t}\n \t\n \tpublic static void closeSubsequentFS(Path path) {\n \t\tif(path != null && FileSystems.getDefault() != path.getFileSystem()) {\n-\t\t\tIOUtils.closeQuietly(path.getFileSystem());\n+\t\t\tIOUtils.closeQuietly(path.getFileSystem(), null);\n \t\t}\n \t}\n \t\n@@ -125,6 +129,10 @@ public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)\n \t    throws IOException {\n \t\t\tPath relativeFile = source.relativize(file);\n \t        final Path destFile = Paths.get(destDir.toString(), relativeFile.toString());\n+\t        Path normalizedPath = destFile.normalize();\n+\t\t\tif(!normalizedPath.startsWith(destDir)) {\n+\t\t\t\tthrow new OLATRuntimeException(\"Invalid ZIP\");\n+\t\t\t}\n \t        if(filter.matches(file)) {\n \t        \tFiles.copy(file, destFile, StandardCopyOption.REPLACE_EXISTING);\n \t        }",
        "function_modified_lines": {
            "added": [
                "import java.nio.file.FileVisitOption;\n",
                "import java.util.EnumSet;\n",
                "import org.olat.core.logging.OLATRuntimeException;\n"
            ],
            "deleted": []
        },
        "lang": "Java",
        "cwe": [
            "CWE-22"
        ],
        "cve_description": "OpenOLAT is a web-based learning management system (LMS). A path traversal vulnerability exists in versions prior to 15.3.18, 15.5.3, and 16.0.0. Using a specially prepared ZIP file, it is possible to overwrite any file that is writable by the application server user (e.g. the tomcat user). Depending on the configuration this can be limited to files of the OpenOlat user data directory, however, if not properly set up, the attack could also be used to overwrite application server config files, java code or even operating system files. The attack could be used to corrupt or modify any OpenOlat file such as course structures, config files or temporary test data. Those attack would require in-depth knowledge of the installation and thus more theoretical. If the app server configuration allows the execution of jsp files and the path to the context is known, it is also possible to execute java code. If the app server runs with the same user that is used to deploy the OpenOlat code or has write permissions on the OpenOlat code files and the path to the context is know, code injection is possible. The attack requires an OpenOlat user account to upload a ZIP file and trigger the unzip method. It can not be exploited by unregistered users. The problem is fixed in versions 15.3.18, 15.5.3 and 16.0.0. There are no known workarounds aside from upgrading.",
        "id": 12530
    },
    {
        "cve_id": "CVE-2021-39180",
        "code_before_change": "{\n\t\t\n\t\tVFSRepositoryService vfsRepositoryService = CoreSpringFactory.getImpl(VFSRepositoryService.class);\n\t\t\n\t\ttry(ZipInputStream oZip = new ZipInputStream(in)) {\n\t\t\t// unzip files\n\t\t\tZipEntry oEntr = oZip.getNextEntry();\n\t\t\twhile (oEntr != null) {\n\t\t\t\tif (oEntr.getName() != null && !oEntr.getName().startsWith(DIR_NAME__MACOSX)) {\n\t\t\t\t\tif (oEntr.isDirectory()) {\n\t\t\t\t\t\t// skip MacOSX specific metadata directory\n\t\t\t\t\t\t// create directories\n\t\t\t\t\t\tgetAllSubdirs(targetDir, oEntr.getName(), identity, true);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// create file\n\t\t\t\t\t\tVFSContainer createIn = targetDir;\n\t\t\t\t\t\tString name = oEntr.getName();\n\t\t\t\t\t\t// check if entry has directories which did not show up as\n\t\t\t\t\t\t// directories above\n\t\t\t\t\t\tint dirSepIndex = name.lastIndexOf('/');\n\t\t\t\t\t\tif (dirSepIndex == -1) {\n\t\t\t\t\t\t\t// try it windows style, backslash is also valid format\n\t\t\t\t\t\t\tdirSepIndex = name.lastIndexOf('\\\\');\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (dirSepIndex > 0) {\n\t\t\t\t\t\t\t// create subdirs\n\t\t\t\t\t\t\tcreateIn = getAllSubdirs(targetDir, name.substring(0, dirSepIndex), identity, true);\n\t\t\t\t\t\t\tif (createIn == null) {\n\t\t\t\t\t\t\t\tlog.debug(\"Error creating directory structure for zip entry: {}\", oEntr.getName());\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tname = name.substring(dirSepIndex + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(versioning) {\n\t\t\t\t\t\t\tVFSLeaf newEntry = (VFSLeaf)createIn.resolve(name);\n\t\t\t\t\t\t\tif(newEntry == null) {\n\t\t\t\t\t\t\t\tnewEntry = createIn.createChildLeaf(name);\n\t\t\t\t\t\t\t\tif (!copy(oZip, newEntry)) {\n\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (newEntry.canVersion() == VFSConstants.YES) {\n\t\t\t\t\t\t\t\tvfsRepositoryService.addVersion(newEntry, identity, \"\", oZip);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(newEntry != null && identity != null && newEntry.canMeta() == VFSConstants.YES) {\n\t\t\t\t\t\t\t\tVFSMetadata info = newEntry.getMetaInfo();\n\t\t\t\t\t\t\t\tif(info != null) {\n\t\t\t\t\t\t\t\t\tinfo.setAuthor(identity);\n\t\t\t\t\t\t\t\t\tvfsRepositoryService.updateMetadata(info);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tVFSLeaf newEntry = createIn.createChildLeaf(name);\n\t\t\t\t\t\t\tif (newEntry != null) {\n\t\t\t\t\t\t\t\tif (!copy(oZip, newEntry)) {\n\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t\t\t\tif(identity != null && newEntry.canMeta() == VFSConstants.YES) {\n\t\t\t\t\t\t\t\t\tVFSMetadata info = newEntry.getMetaInfo();\n\t\t\t\t\t\t\t\t\tif(info != null) {\n\t\t\t\t\t\t\t\t\t\tinfo.setAuthor(identity);\n\t\t\t\t\t\t\t\t\t\tvfsRepositoryService.updateMetadata(info);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\toZip.closeEntry();\n\t\t\t\toEntr = oZip.getNextEntry();\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}",
        "code_after_change": "{\n\t\t\n\t\tVFSRepositoryService vfsRepositoryService = CoreSpringFactory.getImpl(VFSRepositoryService.class);\n\n\t\ttry(ZipInputStream oZip = new ZipInputStream(in)) {\n\t\t\t// unzip files\n\t\t\tZipEntry oEntr = oZip.getNextEntry();\n\t\t\twhile (oEntr != null) {\n\t\t\t\tString name = oEntr.getName();\n\t\t\t\tif(!targetDir.isInPath(name)) {\n\t\t\t\t\tthrow new IOException(\"Invalip ZIP\");\n\t\t\t\t}\n\n\t\t\t\tif (name != null && !name.startsWith(DIR_NAME__MACOSX)) {\n\t\t\t\t\tif (oEntr.isDirectory()) {\n\t\t\t\t\t\t// skip MacOSX specific metadata directory\n\t\t\t\t\t\t// create directories\n\t\t\t\t\t\tgetAllSubdirs(targetDir, name, identity, true);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// create file\n\t\t\t\t\t\tVFSContainer createIn = targetDir;\n\t\t\t\t\t\t// check if entry has directories which did not show up as\n\t\t\t\t\t\t// directories above\n\t\t\t\t\t\tint dirSepIndex = name.lastIndexOf('/');\n\t\t\t\t\t\tif (dirSepIndex == -1) {\n\t\t\t\t\t\t\t// try it windows style, backslash is also valid format\n\t\t\t\t\t\t\tdirSepIndex = name.lastIndexOf('\\\\');\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (dirSepIndex > 0) {\n\t\t\t\t\t\t\t// create subdirs\n\t\t\t\t\t\t\tcreateIn = getAllSubdirs(targetDir, name.substring(0, dirSepIndex), identity, true);\n\t\t\t\t\t\t\tif (createIn == null) {\n\t\t\t\t\t\t\t\tlog.debug(\"Error creating directory structure for zip entry: {}\", oEntr.getName());\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tname = name.substring(dirSepIndex + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(versioning) {\n\t\t\t\t\t\t\tVFSLeaf newEntry = (VFSLeaf)createIn.resolve(name);\n\t\t\t\t\t\t\tif(newEntry == null) {\n\t\t\t\t\t\t\t\tnewEntry = createIn.createChildLeaf(name);\n\t\t\t\t\t\t\t\tif (!copy(oZip, newEntry)) {\n\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (newEntry.canVersion() == VFSConstants.YES) {\n\t\t\t\t\t\t\t\tvfsRepositoryService.addVersion(newEntry, identity, \"\", oZip);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(newEntry != null && identity != null && newEntry.canMeta() == VFSConstants.YES) {\n\t\t\t\t\t\t\t\tVFSMetadata info = newEntry.getMetaInfo();\n\t\t\t\t\t\t\t\tif(info != null) {\n\t\t\t\t\t\t\t\t\tinfo.setAuthor(identity);\n\t\t\t\t\t\t\t\t\tvfsRepositoryService.updateMetadata(info);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tVFSLeaf newEntry = createIn.createChildLeaf(name);\n\t\t\t\t\t\t\tif (newEntry != null) {\n\t\t\t\t\t\t\t\tif (!copy(oZip, newEntry)) {\n\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t\t\t\tif(identity != null && newEntry.canMeta() == VFSConstants.YES) {\n\t\t\t\t\t\t\t\t\tVFSMetadata info = newEntry.getMetaInfo();\n\t\t\t\t\t\t\t\t\tif(info != null) {\n\t\t\t\t\t\t\t\t\t\tinfo.setAuthor(identity);\n\t\t\t\t\t\t\t\t\t\tvfsRepositoryService.updateMetadata(info);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\toZip.closeEntry();\n\t\t\t\toEntr = oZip.getNextEntry();\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}",
        "patch": "@@ -37,6 +37,7 @@\n import java.nio.file.FileVisitResult;\n import java.nio.file.Files;\n import java.nio.file.Path;\n+import java.nio.file.Paths;\n import java.nio.file.SimpleFileVisitor;\n import java.nio.file.attribute.BasicFileAttributes;\n import java.util.ArrayList;\n@@ -188,20 +189,24 @@ public static boolean unzip(VFSLeaf zipLeaf, VFSContainer targetDir, Identity id\n \tprivate static boolean unzip(InputStream in, VFSContainer targetDir, Identity identity, boolean versioning) {\n \t\t\n \t\tVFSRepositoryService vfsRepositoryService = CoreSpringFactory.getImpl(VFSRepositoryService.class);\n-\t\t\n+\n \t\ttry(ZipInputStream oZip = new ZipInputStream(in)) {\n \t\t\t// unzip files\n \t\t\tZipEntry oEntr = oZip.getNextEntry();\n \t\t\twhile (oEntr != null) {\n-\t\t\t\tif (oEntr.getName() != null && !oEntr.getName().startsWith(DIR_NAME__MACOSX)) {\n+\t\t\t\tString name = oEntr.getName();\n+\t\t\t\tif(!targetDir.isInPath(name)) {\n+\t\t\t\t\tthrow new IOException(\"Invalip ZIP\");\n+\t\t\t\t}\n+\n+\t\t\t\tif (name != null && !name.startsWith(DIR_NAME__MACOSX)) {\n \t\t\t\t\tif (oEntr.isDirectory()) {\n \t\t\t\t\t\t// skip MacOSX specific metadata directory\n \t\t\t\t\t\t// create directories\n-\t\t\t\t\t\tgetAllSubdirs(targetDir, oEntr.getName(), identity, true);\n+\t\t\t\t\t\tgetAllSubdirs(targetDir, name, identity, true);\n \t\t\t\t\t} else {\n \t\t\t\t\t\t// create file\n \t\t\t\t\t\tVFSContainer createIn = targetDir;\n-\t\t\t\t\t\tString name = oEntr.getName();\n \t\t\t\t\t\t// check if entry has directories which did not show up as\n \t\t\t\t\t\t// directories above\n \t\t\t\t\t\tint dirSepIndex = name.lastIndexOf('/');\n@@ -317,7 +322,7 @@ private static boolean unzipNonStrict(InputStream in, VFSContainer targetDir, Id\n \t\t\tVFSRepositoryService vfsRepositoryService = CoreSpringFactory.getImpl(VFSRepositoryService.class);\n \t\t\t\n \t\t\t// unzip files\n-\t\t\tnet.sf.jazzlib.ZipEntry oEntr = oZip.getNextEntry();\n+\t\t\tnet.sf.jazzlib.ZipEntry oEntr = oZip.getNextEntry();//TODO zip\n \t\t\t\n \t\t\tVFSLeaf lastLeaf = null;\n \t\t\twhile (oEntr != null) {\n@@ -455,7 +460,7 @@ public static List<String> checkLockedFileBeforeUnzipNonStrict(VFSLeaf zipLeaf,\n \t\t\t\t\t\t// skip MacOSX specific metadata directory\n \t\t\t\t\t\t// directories aren't locked\n \t\t\t\t\t\toZip.closeEntry();\n-\t\t\t\t\t\toEntr = oZip.getNextEntry();\n+\t\t\t\t\t\toEntr = oZip.getNextEntry();//TODO zip\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\t} else {\n \t\t\t\t\t\t// search file\n@@ -847,9 +852,17 @@ public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IO\n \t * @param outdir, path to output directory, relative to cwd or absolute\n \t */\n \tprivate static void xxunzip(InputStream is, String outdir) throws IOException {\n+\t\tfinal Path outPath = Paths.get(outdir);\n+\t\t\n \t\ttry(ZipInputStream zis = new ZipInputStream (new BufferedInputStream(is))) {\n \t\t\tZipEntry entry;\n \t\t\twhile ((entry = zis.getNextEntry()) != null) {\n+\t\t\t\tPath filePath = Paths.get(outdir, entry.getName());\n+\t\t\t\tPath normalizedPath = filePath.normalize();\n+\t\t\t\tif(!normalizedPath.startsWith(outPath)) {\n+\t\t\t\t\tthrow new IOException(\"Invalid ZIP\");\n+\t\t\t\t}\n+\t\t\t\t\n \t\t\t\tFile of = new File(outdir, entry.getName());\n \t\t\t\tif (entry.isDirectory()) {\n \t\t\t\t\tof.mkdirs();",
        "function_modified_lines": {
            "added": [
                "\n",
                "\t\t\t\tString name = oEntr.getName();\n",
                "\t\t\t\tif(!targetDir.isInPath(name)) {\n",
                "\t\t\t\t\tthrow new IOException(\"Invalip ZIP\");\n",
                "\t\t\t\t}\n",
                "\n",
                "\t\t\t\tif (name != null && !name.startsWith(DIR_NAME__MACOSX)) {\n",
                "\t\t\t\t\t\tgetAllSubdirs(targetDir, name, identity, true);\n"
            ],
            "deleted": [
                "\t\t\n",
                "\t\t\t\tif (oEntr.getName() != null && !oEntr.getName().startsWith(DIR_NAME__MACOSX)) {\n",
                "\t\t\t\t\t\tgetAllSubdirs(targetDir, oEntr.getName(), identity, true);\n",
                "\t\t\t\t\t\tString name = oEntr.getName();\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-22"
        ],
        "cve_description": "OpenOLAT is a web-based learning management system (LMS). A path traversal vulnerability exists in versions prior to 15.3.18, 15.5.3, and 16.0.0. Using a specially prepared ZIP file, it is possible to overwrite any file that is writable by the application server user (e.g. the tomcat user). Depending on the configuration this can be limited to files of the OpenOlat user data directory, however, if not properly set up, the attack could also be used to overwrite application server config files, java code or even operating system files. The attack could be used to corrupt or modify any OpenOlat file such as course structures, config files or temporary test data. Those attack would require in-depth knowledge of the installation and thus more theoretical. If the app server configuration allows the execution of jsp files and the path to the context is known, it is also possible to execute java code. If the app server runs with the same user that is used to deploy the OpenOlat code or has write permissions on the OpenOlat code files and the path to the context is know, code injection is possible. The attack requires an OpenOlat user account to upload a ZIP file and trigger the unzip method. It can not be exploited by unregistered users. The problem is fixed in versions 15.3.18, 15.5.3 and 16.0.0. There are no known workarounds aside from upgrading.",
        "id": 12517
    },
    {
        "cve_id": "CVE-2021-39180",
        "code_before_change": "{\n\t\t\tString filename = file.getFileName().toString();\n\t\t\tPath normalizedPath = file.normalize();\n\t\t\tif(!normalizedPath.startsWith(destDir)) {\n\t\t\t\tthrow new IOException(\"Invalid ZIP\");\n\t\t\t}\n\t\t\t\n\t        if(filename.endsWith(WikiManager.WIKI_PROPERTIES_SUFFIX)) {\n\t        \tString f = convertAlternativeFilename(file.toString());\n\t        \tfinal Path destFile = Paths.get(wikiDir.toString(), f);\n\t        \tresetAndCopyProperties(file, destFile);\n\t        } else if (filename.endsWith(WIKI_FILE_SUFFIX)) {\n\t        \tString f = convertAlternativeFilename(file.toString());\n\t        \tfinal Path destFile = Paths.get(wikiDir.toString(), f);\n\t        \tFiles.copy(file, destFile, StandardCopyOption.REPLACE_EXISTING);\n\t\t\t} else if (!filename.contains(WIKI_FILE_SUFFIX + \"-\")\n\t\t\t\t\t&& !filename.contains(WIKI_PROPERTIES_SUFFIX + \"-\")) {\n\t\t\t\tfinal Path destFile = Paths.get(mediaDir.toString(), file.toString());\n\t\t\t\tFiles.copy(file, destFile, StandardCopyOption.REPLACE_EXISTING);\n\t\t\t}\n\t        return FileVisitResult.CONTINUE;\n\t\t}",
        "code_after_change": "{\n\t\t\n\t\tprivate final Path destDir;\n\t\tprivate final Path wikiDir;\n\t\tprivate final Path mediaDir;\n\t\t\n\t\tpublic ImportVisitor(Path destDir) throws IOException {\n\t\t\tthis.destDir = destDir;\n\t\t\twikiDir = destDir.resolve(WIKI_RESOURCE_FOLDER_NAME);\n\t\t\tFiles.createDirectories(wikiDir);\n\t\t\tmediaDir = destDir.resolve(WikiContainer.MEDIA_FOLDER_NAME);\n\t\t\tFiles.createDirectories(mediaDir);\n\t\t\tPath versionDir = destDir.resolve(VERSION_FOLDER_NAME);\n\t\t\tFiles.createDirectories(versionDir);\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic FileVisitResult visitFile(Path file, BasicFileAttributes attrs)\n\t    throws IOException {\n\t\t\tString filename = file.getFileName().toString();\n\n\t        if(filename.endsWith(WikiManager.WIKI_PROPERTIES_SUFFIX)) {\n\t        \tString f = convertAlternativeFilename(file.toString());\n\t        \tfinal Path destFile = Paths.get(wikiDir.toString(), f);\n\t        \tcheckDestinationFile(destFile);\n\t        \tresetAndCopyProperties(file, destFile);\n\t        } else if (filename.endsWith(WIKI_FILE_SUFFIX)) {\n\t        \tString f = convertAlternativeFilename(file.toString());\n\t        \tfinal Path destFile = Paths.get(wikiDir.toString(), f);\n\t        \tcheckDestinationFile(destFile);\n\t        \tFiles.copy(file, destFile, StandardCopyOption.REPLACE_EXISTING);\n\t\t\t} else if (!filename.contains(WIKI_FILE_SUFFIX + \"-\")\n\t\t\t\t\t&& !filename.contains(WIKI_PROPERTIES_SUFFIX + \"-\")) {\n\t\t\t\tfinal Path destFile = Paths.get(mediaDir.toString(), file.toString());\n\t\t\t\tcheckDestinationFile(destFile);\n\t\t\t\tFiles.copy(file, destFile, StandardCopyOption.REPLACE_EXISTING);\n\t\t\t}\n\t        return FileVisitResult.CONTINUE;\n\t\t}\n\t\t\n\t\tprivate void checkDestinationFile(Path destFile) throws IOException {\n\t\t\tPath normalizedPath = destFile.normalize();\n\t\t\tif(!normalizedPath.startsWith(destDir)) {\n\t\t\t\tthrow new OLATRuntimeException(\"Invalid ZIP\");\n\t\t\t}\n\t\t}\n\t \n\t\t@Override\n\t\tpublic FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs)\n\t\tthrows IOException {\n\t\t\tfinal Path dirToCreate = Paths.get(destDir.toString(), dir.toString());\n\t        if(Files.notExists(dirToCreate)){\n\t        \t\tFiles.createDirectory(dirToCreate);\n\t        }\n\t        return FileVisitResult.CONTINUE;\n\t\t}\n\t}",
        "patch": "@@ -30,13 +30,15 @@\n import java.io.InputStream;\n import java.io.OutputStream;\n import java.io.UnsupportedEncodingException;\n+import java.nio.file.FileVisitOption;\n import java.nio.file.FileVisitResult;\n import java.nio.file.Files;\n import java.nio.file.Path;\n import java.nio.file.Paths;\n import java.nio.file.SimpleFileVisitor;\n import java.nio.file.StandardCopyOption;\n import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.EnumSet;\n import java.util.Iterator;\n import java.util.List;\n import java.util.Properties;\n@@ -162,7 +164,7 @@ public boolean importWiki(File file, String filename, File targetDirectory) {\n \t\t\t}\n \t\t\t\n \t\t\tPath destDir = targetDirectory.toPath();\n-\t\t\tFiles.walkFileTree(path, new ImportVisitor(destDir));\n+\t\t\tFiles.walkFileTree(path, EnumSet.noneOf(FileVisitOption.class), 16, new ImportVisitor(destDir));\n \t\t\tPathUtils.closeSubsequentFS(path);\n \t\t\treturn true;\n \t\t} catch (IOException e) {\n@@ -299,26 +301,32 @@ public ImportVisitor(Path destDir) throws IOException {\n \t\tpublic FileVisitResult visitFile(Path file, BasicFileAttributes attrs)\n \t    throws IOException {\n \t\t\tString filename = file.getFileName().toString();\n-\t\t\tPath normalizedPath = file.normalize();\n-\t\t\tif(!normalizedPath.startsWith(destDir)) {\n-\t\t\t\tthrow new IOException(\"Invalid ZIP\");\n-\t\t\t}\n-\t\t\t\n+\n \t        if(filename.endsWith(WikiManager.WIKI_PROPERTIES_SUFFIX)) {\n \t        \tString f = convertAlternativeFilename(file.toString());\n \t        \tfinal Path destFile = Paths.get(wikiDir.toString(), f);\n+\t        \tcheckDestinationFile(destFile);\n \t        \tresetAndCopyProperties(file, destFile);\n \t        } else if (filename.endsWith(WIKI_FILE_SUFFIX)) {\n \t        \tString f = convertAlternativeFilename(file.toString());\n \t        \tfinal Path destFile = Paths.get(wikiDir.toString(), f);\n+\t        \tcheckDestinationFile(destFile);\n \t        \tFiles.copy(file, destFile, StandardCopyOption.REPLACE_EXISTING);\n \t\t\t} else if (!filename.contains(WIKI_FILE_SUFFIX + \"-\")\n \t\t\t\t\t&& !filename.contains(WIKI_PROPERTIES_SUFFIX + \"-\")) {\n \t\t\t\tfinal Path destFile = Paths.get(mediaDir.toString(), file.toString());\n+\t\t\t\tcheckDestinationFile(destFile);\n \t\t\t\tFiles.copy(file, destFile, StandardCopyOption.REPLACE_EXISTING);\n \t\t\t}\n \t        return FileVisitResult.CONTINUE;\n \t\t}\n+\t\t\n+\t\tprivate void checkDestinationFile(Path destFile) throws IOException {\n+\t\t\tPath normalizedPath = destFile.normalize();\n+\t\t\tif(!normalizedPath.startsWith(destDir)) {\n+\t\t\t\tthrow new OLATRuntimeException(\"Invalid ZIP\");\n+\t\t\t}\n+\t\t}\n \t \n \t\t@Override\n \t\tpublic FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs)",
        "function_modified_lines": {
            "added": [
                "\n",
                "\t        \tcheckDestinationFile(destFile);\n",
                "\t        \tcheckDestinationFile(destFile);\n",
                "\t\t\t\tcheckDestinationFile(destFile);\n",
                "\t\t\n",
                "\t\tprivate void checkDestinationFile(Path destFile) throws IOException {\n",
                "\t\t\tPath normalizedPath = destFile.normalize();\n",
                "\t\t\tif(!normalizedPath.startsWith(destDir)) {\n",
                "\t\t\t\tthrow new OLATRuntimeException(\"Invalid ZIP\");\n",
                "\t\t\t}\n",
                "\t\t}\n"
            ],
            "deleted": [
                "\t\t\tPath normalizedPath = file.normalize();\n",
                "\t\t\tif(!normalizedPath.startsWith(destDir)) {\n",
                "\t\t\t\tthrow new IOException(\"Invalid ZIP\");\n",
                "\t\t\t}\n",
                "\t\t\t\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-22"
        ],
        "cve_description": "OpenOLAT is a web-based learning management system (LMS). A path traversal vulnerability exists in versions prior to 15.3.18, 15.5.3, and 16.0.0. Using a specially prepared ZIP file, it is possible to overwrite any file that is writable by the application server user (e.g. the tomcat user). Depending on the configuration this can be limited to files of the OpenOlat user data directory, however, if not properly set up, the attack could also be used to overwrite application server config files, java code or even operating system files. The attack could be used to corrupt or modify any OpenOlat file such as course structures, config files or temporary test data. Those attack would require in-depth knowledge of the installation and thus more theoretical. If the app server configuration allows the execution of jsp files and the path to the context is known, it is also possible to execute java code. If the app server runs with the same user that is used to deploy the OpenOlat code or has write permissions on the OpenOlat code files and the path to the context is know, code injection is possible. The attack requires an OpenOlat user account to upload a ZIP file and trigger the unzip method. It can not be exploited by unregistered users. The problem is fixed in versions 15.3.18, 15.5.3 and 16.0.0. There are no known workarounds aside from upgrading.",
        "id": 12537
    },
    {
        "cve_id": "CVE-2021-39180",
        "code_before_change": "{\n\n\t/**\n\t * @return a list of VFSItem containing \n\t */\n\tpublic List<VFSItem> getItems();\n\t\n\t/**\n\t * @return a list of VFSItem which are accepted by the given filter. If a\n\t *         default filter is set, the default filter will be applied in\n\t *         addition to the given filter in this method\n\t */\n\tpublic List<VFSItem> getItems(VFSItemFilter filter);\n\t\n\t/**\n\t * copy either a file or a folder to this folder.\n\t * e.g. this folder is based at /bla/blu, copying source bli (from /whatever/bli) \n\t * will add a child bli, so it looks like /bla/blu/bli later.\n\t * the operation fails when\n\t * the source or target do not support canCopyFrom and canCopyTo, resp., or\n\t * there is already a child with the same name, or the quota would be exceeded.\n\t * \n\t * @param source the source (must exist)\n\t * @return the status\n\t */\n\tpublic VFSStatus copyFrom(VFSItem source);\n\t\n\t/**\n\t * \n\t * @param container\n\t * @return\n\t */\n\tpublic VFSStatus copyContentOf(VFSContainer container);\n\n\t/**\n\t * Create a new child container (of same type) if possible.\n\t * \n\t * @param name\n\t * @return VFSItem if successfull, null otherwise.\n\t */\n\tpublic VFSContainer createChildContainer(String name);\n\t\n\t/**\n\t * Create a new leaf (of same type) if possible,\n\t * @param name\n\t * @return VFSItem if successfull, null otherwise.\n\t */\n\tpublic VFSLeaf createChildLeaf(String name);\n\t\n\t/**\n\t * Set a default filter that will be applied to this container getItems method\n\t * \n\t * @param defaultFilter\n\t */\n\tpublic void setDefaultItemFilter(VFSItemFilter defaultFilter);\n\n\t/**\n\t * @return The default filter for this container or NULL if no filter is set\n\t */\n\tpublic VFSItemFilter getDefaultItemFilter();\n\n}",
        "code_after_change": "{\n\n\t/**\n\t * @return a list of VFSItem containing \n\t */\n\tpublic List<VFSItem> getItems();\n\t\n\t/**\n\t * @return a list of VFSItem which are accepted by the given filter. If a\n\t *         default filter is set, the default filter will be applied in\n\t *         addition to the given filter in this method\n\t */\n\tpublic List<VFSItem> getItems(VFSItemFilter filter);\n\t\n\t/**\n\t * copy either a file or a folder to this folder.\n\t * e.g. this folder is based at /bla/blu, copying source bli (from /whatever/bli) \n\t * will add a child bli, so it looks like /bla/blu/bli later.\n\t * the operation fails when\n\t * the source or target do not support canCopyFrom and canCopyTo, resp., or\n\t * there is already a child with the same name, or the quota would be exceeded.\n\t * \n\t * @param source the source (must exist)\n\t * @return the status\n\t */\n\tpublic VFSStatus copyFrom(VFSItem source);\n\t\n\t/**\n\t * \n\t * @param container\n\t * @return\n\t */\n\tpublic VFSStatus copyContentOf(VFSContainer container);\n\n\t/**\n\t * Create a new child container (of same type) if possible.\n\t * \n\t * @param name\n\t * @return VFSItem if successfull, null otherwise.\n\t */\n\tpublic VFSContainer createChildContainer(String name);\n\t\n\t/**\n\t * Create a new leaf (of same type) if possible,\n\t * @param name\n\t * @return VFSItem if successfull, null otherwise.\n\t */\n\tpublic VFSLeaf createChildLeaf(String name);\n\t\n\t/**\n\t * \n\t * @param path\n\t * @return\n\t */\n\tpublic boolean isInPath(String path);\n\t\n\t/**\n\t * Set a default filter that will be applied to this container getItems method\n\t * \n\t * @param defaultFilter\n\t */\n\tpublic void setDefaultItemFilter(VFSItemFilter defaultFilter);\n\n\t/**\n\t * @return The default filter for this container or NULL if no filter is set\n\t */\n\tpublic VFSItemFilter getDefaultItemFilter();\n\n}",
        "patch": "@@ -86,6 +86,13 @@ public interface VFSContainer extends VFSItem {\n \t */\n \tpublic VFSLeaf createChildLeaf(String name);\n \t\n+\t/**\n+\t * \n+\t * @param path\n+\t * @return\n+\t */\n+\tpublic boolean isInPath(String path);\n+\t\n \t/**\n \t * Set a default filter that will be applied to this container getItems method\n \t * ",
        "function_modified_lines": {
            "added": [
                "\t/**\n",
                "\t * \n",
                "\t * @param path\n",
                "\t * @return\n",
                "\t */\n",
                "\tpublic boolean isInPath(String path);\n",
                "\t\n"
            ],
            "deleted": []
        },
        "lang": "Java",
        "cwe": [
            "CWE-22"
        ],
        "cve_description": "OpenOLAT is a web-based learning management system (LMS). A path traversal vulnerability exists in versions prior to 15.3.18, 15.5.3, and 16.0.0. Using a specially prepared ZIP file, it is possible to overwrite any file that is writable by the application server user (e.g. the tomcat user). Depending on the configuration this can be limited to files of the OpenOlat user data directory, however, if not properly set up, the attack could also be used to overwrite application server config files, java code or even operating system files. The attack could be used to corrupt or modify any OpenOlat file such as course structures, config files or temporary test data. Those attack would require in-depth knowledge of the installation and thus more theoretical. If the app server configuration allows the execution of jsp files and the path to the context is known, it is also possible to execute java code. If the app server runs with the same user that is used to deploy the OpenOlat code or has write permissions on the OpenOlat code files and the path to the context is know, code injection is possible. The attack requires an OpenOlat user account to upload a ZIP file and trigger the unzip method. It can not be exploited by unregistered users. The problem is fixed in versions 15.3.18, 15.5.3 and 16.0.0. There are no known workarounds aside from upgrading.",
        "id": 12521
    },
    {
        "cve_id": "CVE-2021-39180",
        "code_before_change": "{\n\t\n\tprivate static final Logger log = Tracing.createLoggerFor(CopyAndConvertVisitor.class);\n\t\n\tprivate final Path source;\n\tprivate final Path destDir;\n\tprivate final PathMatcher filter;\n\t\n\tprivate QTI21Infos infos;\n\t\n\tpublic CopyAndConvertVisitor(Path source, Path destDir, QTI21Infos infos, PathMatcher filter) {\n\t\tthis.source = source;\n\t\tthis.destDir = destDir;\n\t\tthis.filter = filter;\n\t\tthis.infos = infos;\n\t}\n\t\n\t@Override\n\tpublic FileVisitResult visitFile(Path file, BasicFileAttributes attrs)\n    throws IOException {\n\t\tPath relativeFile = source.relativize(file);\n\t\tfinal Path destFile = Paths.get(destDir.toString(), relativeFile.toString());\n\t\tif(filter.matches(file)) {\n\t\t\tString filename = file.getFileName().toString();\n\t\t\tif(filename.startsWith(\".\")) {\n\t\t\t\t//ignore\n\t\t\t} else if(filename.endsWith(\"xml\") && !filename.equals(\"imsmanifest.xml\")) {\n\t\t\t\tconvertXmlFile(file, destFile);\n\t\t\t} else {\n\t\t\t\tFiles.copy(file, destFile, StandardCopyOption.REPLACE_EXISTING);\n\t\t\t}\n\t\t}\n        return FileVisitResult.CONTINUE;\n\t}\n \n\t@Override\n\tpublic FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs)\n\tthrows IOException {\n\t\tPath relativeDir = source.relativize(dir);\n        final Path dirToCreate = Paths.get(destDir.toString(), relativeDir.toString());\n        if(!dirToCreate.toFile().exists()) {\n        \tFiles.createDirectory(dirToCreate);\n        }\n        return FileVisitResult.CONTINUE;\n\t}\n\t\n\t/**\n\t * Convert the XML files, assessmentItem or assessmentTest\n\t * \n\t * @param inputFile\n\t * @param outputFile\n\t */\n\tpublic boolean convertXmlFile(Path inputFile, Path outputFile) {\n\t\ttry {\n\t\t\tboolean validated = true;\n\t\t\tQTI21Infos fileInfos = scanFile(inputFile);\n\t\t\t//inherit from test if needed\n\t\t\tif(fileInfos.getEditor() == null && infos.getEditor() != null) {\n\t\t\t\tfileInfos.setEditor(infos.getEditor());\n\t\t\t\tfileInfos.setVersion(infos.getVersion());\n\t\t\t}\n\t\t\tif(onyx38Family(fileInfos)) {\n\t\t\t\tvalidated = convertXmlFile(inputFile, outputFile, fileInfos.getType(), Onyx38ToQtiWorksHandler::new);\n\t\t\t} else if(onyxWebFamily(fileInfos)) {\n\t\t\t\tvalidated = convertXmlFile(inputFile, outputFile, fileInfos.getType(), xtw ->\n\t\t\t\t\t new OnyxToQtiWorksHandler(xtw, infos));\n\t\t\t\t\n\t\t\t\tif(validated && fileInfos.getType() == InputType.assessmentItem) {\n\t\t\t\t\t//check templateVariables\n\t\t\t\t\tcheckAssessmentItem(outputFile);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tFiles.copy(inputFile, outputFile, StandardCopyOption.REPLACE_EXISTING);\n\t\t\t}\n\t\t\treturn validated;\n\t\t} catch (IOException | FactoryConfigurationError e) {\n\t\t\tlog.error(\"\", e);\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\tprivate boolean onyx38Family(QTI21Infos fileInfos) {\n\t\tif(fileInfos == null || fileInfos.getEditor() == null) return false;\n\t\tString version = fileInfos.getVersion();\n\t\treturn \"Onyx Editor\".equals(fileInfos.getEditor()) && version != null &&\n\t\t\t\t(version.startsWith(\"2.\") || version.startsWith(\"3.\"));\n\t}\n\t\n\tprivate boolean onyxWebFamily(QTI21Infos fileInfos) {\n\t\tif(fileInfos == null || fileInfos.getEditor() == null) return false;\n\t\treturn \"ONYX Editor\".equals(fileInfos.getEditor());\n\t}\n\t\n\tprivate QTI21Infos scanFile(Path inputFile) {\n\t\tQTI21ExplorerHandler infosHandler = new QTI21ExplorerHandler();\n\t\ttry(InputStream in = Files.newInputStream(inputFile)) {\n\t\t\tSAXParser saxParser = XMLFactories.newSAXParser();\n\t\t\tsaxParser.setProperty(\"http://xml.org/sax/properties/lexical-handler\", infosHandler);\n\t\t\tsaxParser.parse(in, infosHandler);\n\t\t} catch(Exception e1) {\n\t\t\tlog.error(\"\", e1);\n\t\t}\n\t\treturn infosHandler.getInfos();\n\t}\n\n\tprivate boolean convertXmlFile(Path inputFile, Path outputFile, InputType type, HandlerProvider provider) {\n\t\tFile tmpFile = new File(WebappHelper.getTmpDir(), UUID.randomUUID() + \".xml\");\n\t\ttry(InputStream in = Files.newInputStream(inputFile);\n\t\t\t\tWriter out = Files.newBufferedWriter(tmpFile.toPath(), StandardCharsets.UTF_8)) {\n\t\t\tXMLOutputFactory xof = XMLOutputFactory.newInstance();\n\t        XMLStreamWriter xtw = xof.createXMLStreamWriter(out);\n\t\t\tSAXParser saxParser = XMLFactories.newSAXParser();\n\t\t\tDefaultHandler myHandler = provider.create(xtw);\n\t\t\tsaxParser.setProperty(\"http://xml.org/sax/properties/lexical-handler\", myHandler);\n\t\t\tsaxParser.parse(in, myHandler);\n\t\t\t\n\t\t\tboolean valid = validate(tmpFile.toPath(), type, true);\n\t\t\tif(valid) {\n\t\t\t\tif(!outputFile.getParent().toFile().exists()) {\n\t\t\t\t\toutputFile.getParent().toFile().mkdirs();\n\t\t\t\t}\n\t\t\t\tFiles.copy(tmpFile.toPath(), outputFile, StandardCopyOption.REPLACE_EXISTING);\n\t\t\t}\n\t\t\treturn valid;\n\t\t} catch(Exception e1) {\n\t\t\tlog.error(\"\", e1);\n\t\t\treturn false;\n\t\t} finally {\n\t\t\tFileUtils.deleteFile(tmpFile);\n\t\t}\n\t}\n\t\n\tprivate boolean validate(Path inputFile, InputType type, boolean verbose) {\n\t\ttry {\n\t\t\tQtiXmlReader qtiXmlReader = new QtiXmlReader(new JqtiExtensionManager());\n\t\t\tResourceLocator fileResourceLocator = new PathResourceLocator(inputFile.getParent());\n\t\t\tAssessmentObjectXmlLoader assessmentObjectXmlLoader = new AssessmentObjectXmlLoader(qtiXmlReader, fileResourceLocator);\n\t\t\t\n\t\t\tRootNode rootNode = null;\n\t\t\tBadResourceException e = null;\n\t\t\tURI uri = new URI(\"zip\", inputFile.getFileName().toString(), null);\n\t\t\tif(type == InputType.assessmentItem) {\n\t\t\t\tItemValidationResult itemResult = assessmentObjectXmlLoader.loadResolveAndValidateItem(uri);\n\t\t\t\te = itemResult.getResolvedAssessmentItem().getItemLookup().getBadResourceException();\n\t\t\t\tResolvedAssessmentItem resolvedAssessmentItem = assessmentObjectXmlLoader.loadAndResolveAssessmentItem(uri);\n\t\t\t\trootNode = resolvedAssessmentItem.getRootNodeLookup().extractIfSuccessful();\n\t\t\t} else if(type == InputType.assessmentTest) {\n\t\t\t\tTestValidationResult testResult = assessmentObjectXmlLoader.loadResolveAndValidateTest(uri);\n\t\t\t\te = testResult.getResolvedAssessmentTest().getTestLookup().getBadResourceException();\n\t\t\t\tResolvedAssessmentTest resolvedAssessmentTest = assessmentObjectXmlLoader.loadAndResolveAssessmentTest(uri);\n\t\t\t\trootNode = resolvedAssessmentTest.getRootNodeLookup().extractIfSuccessful();\n\t\t\t}\n\t\t\t\n\t\t\tif(e != null && verbose) {\n\t\t\t\tStringBuilder err = new StringBuilder();\n\t\t\t\tBadRessourceHelper.extractMessage(e, err);\n\t\t\t\tlog.warn(err.toString());\n\t\t\t}\n\t\t\t\n\t\t\treturn (rootNode != null) && (e == null || (e instanceof QtiXmlInterpretationException && ((QtiXmlInterpretationException)e).getXmlParseResult().getFatalErrors().isEmpty()));\n\t\t} catch (URISyntaxException e) {\n\t\t\tlog.error(\"\", e);\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\tprivate void checkAssessmentItem(Path outputFile) {\n\t\tQTI21Service qtiService = CoreSpringFactory.getImpl(QTI21Service.class);\n\t\tQtiXmlReader qtiXmlReader = new QtiXmlReader(qtiService.jqtiExtensionManager());\n\t\tResourceLocator fileResourceLocator = new FileResourceLocator();\n\t\tResourceLocator inputResourceLocator = \n\t\t\t\tImsQTI21Resource.createResolvingResourceLocator(fileResourceLocator);\n\t\t\n\t\tURI assessmentObjectSystemId = outputFile.toFile().toURI();\n\t\tAssessmentObjectXmlLoader assessmentObjectXmlLoader = new AssessmentObjectXmlLoader(qtiXmlReader, inputResourceLocator);\n\t\tResolvedAssessmentItem resolvedAssessmentItem = assessmentObjectXmlLoader.loadAndResolveAssessmentItem(assessmentObjectSystemId);\n\t\tAssessmentItem assessmentItem = resolvedAssessmentItem.getRootNodeLookup().extractIfSuccessful();\n\n\t\tif(!AssessmentItemChecker.checkAndCorrect(assessmentItem)) {\n\t\t\ttry(FileOutputStream out = new FileOutputStream(outputFile.toFile())) {\n\t\t\t\tqtiService.qtiSerializer().serializeJqtiObject(assessmentItem, out);\n\t\t\t} catch(Exception e) {\n\t\t\t\tlog.error(\"\", e);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic interface HandlerProvider {\n\t\t\n\t\tpublic DefaultHandler2 create(XMLStreamWriter xtw);\n\t\t\n\t}\n}",
        "code_after_change": "{\n\t\n\tprivate static final Logger log = Tracing.createLoggerFor(CopyAndConvertVisitor.class);\n\t\n\tprivate final Path source;\n\tprivate final Path destDir;\n\tprivate final PathMatcher filter;\n\t\n\tprivate QTI21Infos infos;\n\t\n\tpublic CopyAndConvertVisitor(Path source, Path destDir, QTI21Infos infos, PathMatcher filter) {\n\t\tthis.source = source;\n\t\tthis.destDir = destDir;\n\t\tthis.filter = filter;\n\t\tthis.infos = infos;\n\t}\n\t\n\t@Override\n\tpublic FileVisitResult visitFile(Path file, BasicFileAttributes attrs)\n    throws IOException {\n\t\tPath relativeFile = source.relativize(file);\n\t\tfinal Path destFile = Paths.get(destDir.toString(), relativeFile.toString());\n\t\tif(filter.matches(file)) {\n\t\t\tString filename = file.getFileName().toString();\n\t\t\tif(filename.startsWith(\".\")) {\n\t\t\t\t//ignore\n\t\t\t} else if(filename.endsWith(\"xml\") && !filename.equals(\"imsmanifest.xml\")) {\n\t\t\t\tcheckPath(destFile);\n\t\t\t\tconvertXmlFile(file, destFile);\n\t\t\t} else {\n\t\t\t\tcheckPath(destFile);\n\t\t\t\tFiles.copy(file, destFile, StandardCopyOption.REPLACE_EXISTING);\n\t\t\t}\n\t\t}\n        return FileVisitResult.CONTINUE;\n\t}\n \n\t@Override\n\tpublic FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs)\n\tthrows IOException {\n\t\tPath relativeDir = source.relativize(dir);\n\t\tfinal Path dirToCreate = Paths.get(destDir.toString(), relativeDir.toString());\n\t\tcheckPath(dirToCreate);\n       \n        if(!dirToCreate.toFile().exists()) {\n        \tFiles.createDirectory(dirToCreate);\n        }\n        return FileVisitResult.CONTINUE;\n\t}\n\t\n\tprivate void checkPath(Path file) throws IOException {\n\t\tPath normalizedPath = file.normalize();\n\t\tif(!normalizedPath.startsWith(destDir)) {\n\t\t\tthrow new IOException(\"Invalid ZIP\");\n\t\t}\n\t}\n\t\n\t/**\n\t * Convert the XML files, assessmentItem or assessmentTest\n\t * \n\t * @param inputFile\n\t * @param outputFile\n\t */\n\tpublic boolean convertXmlFile(Path inputFile, Path outputFile) {\n\t\ttry {\n\t\t\tboolean validated = true;\n\t\t\tQTI21Infos fileInfos = scanFile(inputFile);\n\t\t\t//inherit from test if needed\n\t\t\tif(fileInfos.getEditor() == null && infos.getEditor() != null) {\n\t\t\t\tfileInfos.setEditor(infos.getEditor());\n\t\t\t\tfileInfos.setVersion(infos.getVersion());\n\t\t\t}\n\t\t\tif(onyx38Family(fileInfos)) {\n\t\t\t\tvalidated = convertXmlFile(inputFile, outputFile, fileInfos.getType(), Onyx38ToQtiWorksHandler::new);\n\t\t\t} else if(onyxWebFamily(fileInfos)) {\n\t\t\t\tvalidated = convertXmlFile(inputFile, outputFile, fileInfos.getType(), xtw ->\n\t\t\t\t\t new OnyxToQtiWorksHandler(xtw, infos));\n\t\t\t\t\n\t\t\t\tif(validated && fileInfos.getType() == InputType.assessmentItem) {\n\t\t\t\t\t//check templateVariables\n\t\t\t\t\tcheckAssessmentItem(outputFile);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tFiles.copy(inputFile, outputFile, StandardCopyOption.REPLACE_EXISTING);\n\t\t\t}\n\t\t\treturn validated;\n\t\t} catch (IOException | FactoryConfigurationError e) {\n\t\t\tlog.error(\"\", e);\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\tprivate boolean onyx38Family(QTI21Infos fileInfos) {\n\t\tif(fileInfos == null || fileInfos.getEditor() == null) return false;\n\t\tString version = fileInfos.getVersion();\n\t\treturn \"Onyx Editor\".equals(fileInfos.getEditor()) && version != null &&\n\t\t\t\t(version.startsWith(\"2.\") || version.startsWith(\"3.\"));\n\t}\n\t\n\tprivate boolean onyxWebFamily(QTI21Infos fileInfos) {\n\t\tif(fileInfos == null || fileInfos.getEditor() == null) return false;\n\t\treturn \"ONYX Editor\".equals(fileInfos.getEditor());\n\t}\n\t\n\tprivate QTI21Infos scanFile(Path inputFile) {\n\t\tQTI21ExplorerHandler infosHandler = new QTI21ExplorerHandler();\n\t\ttry(InputStream in = Files.newInputStream(inputFile)) {\n\t\t\tSAXParser saxParser = XMLFactories.newSAXParser();\n\t\t\tsaxParser.setProperty(\"http://xml.org/sax/properties/lexical-handler\", infosHandler);\n\t\t\tsaxParser.parse(in, infosHandler);\n\t\t} catch(Exception e1) {\n\t\t\tlog.error(\"\", e1);\n\t\t}\n\t\treturn infosHandler.getInfos();\n\t}\n\n\tprivate boolean convertXmlFile(Path inputFile, Path outputFile, InputType type, HandlerProvider provider) {\n\t\tFile tmpFile = new File(WebappHelper.getTmpDir(), UUID.randomUUID() + \".xml\");\n\t\ttry(InputStream in = Files.newInputStream(inputFile);\n\t\t\t\tWriter out = Files.newBufferedWriter(tmpFile.toPath(), StandardCharsets.UTF_8)) {\n\t\t\tXMLOutputFactory xof = XMLOutputFactory.newInstance();\n\t        XMLStreamWriter xtw = xof.createXMLStreamWriter(out);\n\t\t\tSAXParser saxParser = XMLFactories.newSAXParser();\n\t\t\tDefaultHandler myHandler = provider.create(xtw);\n\t\t\tsaxParser.setProperty(\"http://xml.org/sax/properties/lexical-handler\", myHandler);\n\t\t\tsaxParser.parse(in, myHandler);\n\t\t\t\n\t\t\tboolean valid = validate(tmpFile.toPath(), type, true);\n\t\t\tif(valid) {\n\t\t\t\tif(!outputFile.getParent().toFile().exists()) {\n\t\t\t\t\toutputFile.getParent().toFile().mkdirs();\n\t\t\t\t}\n\t\t\t\tFiles.copy(tmpFile.toPath(), outputFile, StandardCopyOption.REPLACE_EXISTING);\n\t\t\t}\n\t\t\treturn valid;\n\t\t} catch(Exception e1) {\n\t\t\tlog.error(\"\", e1);\n\t\t\treturn false;\n\t\t} finally {\n\t\t\tFileUtils.deleteFile(tmpFile);\n\t\t}\n\t}\n\t\n\tprivate boolean validate(Path inputFile, InputType type, boolean verbose) {\n\t\ttry {\n\t\t\tQtiXmlReader qtiXmlReader = new QtiXmlReader(new JqtiExtensionManager());\n\t\t\tResourceLocator fileResourceLocator = new PathResourceLocator(inputFile.getParent());\n\t\t\tAssessmentObjectXmlLoader assessmentObjectXmlLoader = new AssessmentObjectXmlLoader(qtiXmlReader, fileResourceLocator);\n\t\t\t\n\t\t\tRootNode rootNode = null;\n\t\t\tBadResourceException e = null;\n\t\t\tURI uri = new URI(\"zip\", inputFile.getFileName().toString(), null);\n\t\t\tif(type == InputType.assessmentItem) {\n\t\t\t\tItemValidationResult itemResult = assessmentObjectXmlLoader.loadResolveAndValidateItem(uri);\n\t\t\t\te = itemResult.getResolvedAssessmentItem().getItemLookup().getBadResourceException();\n\t\t\t\tResolvedAssessmentItem resolvedAssessmentItem = assessmentObjectXmlLoader.loadAndResolveAssessmentItem(uri);\n\t\t\t\trootNode = resolvedAssessmentItem.getRootNodeLookup().extractIfSuccessful();\n\t\t\t} else if(type == InputType.assessmentTest) {\n\t\t\t\tTestValidationResult testResult = assessmentObjectXmlLoader.loadResolveAndValidateTest(uri);\n\t\t\t\te = testResult.getResolvedAssessmentTest().getTestLookup().getBadResourceException();\n\t\t\t\tResolvedAssessmentTest resolvedAssessmentTest = assessmentObjectXmlLoader.loadAndResolveAssessmentTest(uri);\n\t\t\t\trootNode = resolvedAssessmentTest.getRootNodeLookup().extractIfSuccessful();\n\t\t\t}\n\t\t\t\n\t\t\tif(e != null && verbose) {\n\t\t\t\tStringBuilder err = new StringBuilder();\n\t\t\t\tBadRessourceHelper.extractMessage(e, err);\n\t\t\t\tlog.warn(err.toString());\n\t\t\t}\n\t\t\t\n\t\t\treturn (rootNode != null) && (e == null || (e instanceof QtiXmlInterpretationException && ((QtiXmlInterpretationException)e).getXmlParseResult().getFatalErrors().isEmpty()));\n\t\t} catch (URISyntaxException e) {\n\t\t\tlog.error(\"\", e);\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\tprivate void checkAssessmentItem(Path outputFile) {\n\t\tQTI21Service qtiService = CoreSpringFactory.getImpl(QTI21Service.class);\n\t\tQtiXmlReader qtiXmlReader = new QtiXmlReader(qtiService.jqtiExtensionManager());\n\t\tResourceLocator fileResourceLocator = new FileResourceLocator();\n\t\tResourceLocator inputResourceLocator = \n\t\t\t\tImsQTI21Resource.createResolvingResourceLocator(fileResourceLocator);\n\t\t\n\t\tURI assessmentObjectSystemId = outputFile.toFile().toURI();\n\t\tAssessmentObjectXmlLoader assessmentObjectXmlLoader = new AssessmentObjectXmlLoader(qtiXmlReader, inputResourceLocator);\n\t\tResolvedAssessmentItem resolvedAssessmentItem = assessmentObjectXmlLoader.loadAndResolveAssessmentItem(assessmentObjectSystemId);\n\t\tAssessmentItem assessmentItem = resolvedAssessmentItem.getRootNodeLookup().extractIfSuccessful();\n\n\t\tif(!AssessmentItemChecker.checkAndCorrect(assessmentItem)) {\n\t\t\ttry(FileOutputStream out = new FileOutputStream(outputFile.toFile())) {\n\t\t\t\tqtiService.qtiSerializer().serializeJqtiObject(assessmentItem, out);\n\t\t\t} catch(Exception e) {\n\t\t\t\tlog.error(\"\", e);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic interface HandlerProvider {\n\t\t\n\t\tpublic DefaultHandler2 create(XMLStreamWriter xtw);\n\t\t\n\t}\n}",
        "patch": "@@ -115,8 +115,10 @@ public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)\n \t\t\tif(filename.startsWith(\".\")) {\n \t\t\t\t//ignore\n \t\t\t} else if(filename.endsWith(\"xml\") && !filename.equals(\"imsmanifest.xml\")) {\n+\t\t\t\tcheckPath(destFile);\n \t\t\t\tconvertXmlFile(file, destFile);\n \t\t\t} else {\n+\t\t\t\tcheckPath(destFile);\n \t\t\t\tFiles.copy(file, destFile, StandardCopyOption.REPLACE_EXISTING);\n \t\t\t}\n \t\t}\n@@ -127,13 +129,22 @@ public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)\n \tpublic FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs)\n \tthrows IOException {\n \t\tPath relativeDir = source.relativize(dir);\n-        final Path dirToCreate = Paths.get(destDir.toString(), relativeDir.toString());\n+\t\tfinal Path dirToCreate = Paths.get(destDir.toString(), relativeDir.toString());\n+\t\tcheckPath(dirToCreate);\n+       \n         if(!dirToCreate.toFile().exists()) {\n         \tFiles.createDirectory(dirToCreate);\n         }\n         return FileVisitResult.CONTINUE;\n \t}\n \t\n+\tprivate void checkPath(Path file) throws IOException {\n+\t\tPath normalizedPath = file.normalize();\n+\t\tif(!normalizedPath.startsWith(destDir)) {\n+\t\t\tthrow new IOException(\"Invalid ZIP\");\n+\t\t}\n+\t}\n+\t\n \t/**\n \t * Convert the XML files, assessmentItem or assessmentTest\n \t * ",
        "function_modified_lines": {
            "added": [
                "\t\t\t\tcheckPath(destFile);\n",
                "\t\t\t\tcheckPath(destFile);\n",
                "\t\tfinal Path dirToCreate = Paths.get(destDir.toString(), relativeDir.toString());\n",
                "\t\tcheckPath(dirToCreate);\n",
                "       \n",
                "\tprivate void checkPath(Path file) throws IOException {\n",
                "\t\tPath normalizedPath = file.normalize();\n",
                "\t\tif(!normalizedPath.startsWith(destDir)) {\n",
                "\t\t\tthrow new IOException(\"Invalid ZIP\");\n",
                "\t\t}\n",
                "\t}\n",
                "\t\n"
            ],
            "deleted": [
                "        final Path dirToCreate = Paths.get(destDir.toString(), relativeDir.toString());\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-22"
        ],
        "cve_description": "OpenOLAT is a web-based learning management system (LMS). A path traversal vulnerability exists in versions prior to 15.3.18, 15.5.3, and 16.0.0. Using a specially prepared ZIP file, it is possible to overwrite any file that is writable by the application server user (e.g. the tomcat user). Depending on the configuration this can be limited to files of the OpenOlat user data directory, however, if not properly set up, the attack could also be used to overwrite application server config files, java code or even operating system files. The attack could be used to corrupt or modify any OpenOlat file such as course structures, config files or temporary test data. Those attack would require in-depth knowledge of the installation and thus more theoretical. If the app server configuration allows the execution of jsp files and the path to the context is known, it is also possible to execute java code. If the app server runs with the same user that is used to deploy the OpenOlat code or has write permissions on the OpenOlat code files and the path to the context is know, code injection is possible. The attack requires an OpenOlat user account to upload a ZIP file and trigger the unzip method. It can not be exploited by unregistered users. The problem is fixed in versions 15.3.18, 15.5.3 and 16.0.0. There are no known workarounds aside from upgrading.",
        "id": 12529
    },
    {
        "cve_id": "CVE-2021-41242",
        "code_before_change": "\t * @file file64 The attachment (encoded as Base64)\n\t * @param request The HTTP request\n\t * @return Ok\n\t */\n\t@POST\n\t@Operation(summary = \"Post attachment\",\n\tdescription = \"Upload the attachment of a message.\")\n\t@Path(\"posts/{messageKey}/attachments\")\n\t@ApiResponse(responseCode = \"200\", description = \"Ok.\")\n\t@ApiResponse(responseCode = \"404\", description = \" The identity or the portrait not found\")\n\t@Consumes(MediaType.APPLICATION_FORM_URLENCODED)\n\t@Produces({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON})\n\tpublic Response replyToPostAttachment(@PathParam(\"messageKey\") Long messageKey, @FormParam(\"filename\") String filename,\n\t\t\t@FormParam(\"file\") String file, @Context HttpServletRequest request) {\n\t\tbyte[] fileAsBytes = Base64.decodeBase64(file);\n\t\tInputStream in = new ByteArrayInputStream(fileAsBytes);\n\t\treturn attachToPost(messageKey, filename, in, request);\n\t}\n\t\n\t@PUT\n\t@Operation(summary = \"Put attachment\", description = \"Upload the attachment of a message.\")\n\t@ApiResponse(responseCode = \"200\", description = \"Ok.\")\n\t@ApiResponse(responseCode = \"404\", description = \" The identity or the portrait not found\")\n\t@Path(\"posts/{messageKey}/attachments\")\n\t@Consumes({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON})\n\t@Produces({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON})\n\tpublic Response replyToPostAttachment(@PathParam(\"messageKey\") Long messageKey,  File64VO file64, @Context HttpServletRequest request) {\n\t\tString file = file64.getFile();\n\t\tString filename = file64.getFilename();\n\t\tbyte[] fileAsBytes = Base64.decodeBase64(file);\n\t\tInputStream in = new ByteArrayInputStream(fileAsBytes);\n\t\treturn attachToPost(messageKey, filename, in, request);\n\t}\n\t\n\tprotected Response attachToPost(Long messageKey, String filename, InputStream file,  HttpServletRequest request) {\n\t\t//load message\n\t\tMessage mess = fom.loadMessage(messageKey);\n\t\tif(mess == null) {\n\t\t\treturn Response.serverError().status(Status.NOT_FOUND).build();\n\t\t}\n\t\tif(!forum.equalsByPersistableKey(mess.getForum())) {\n\t\t\treturn Response.serverError().status(Status.CONFLICT).build();\n\t\t}\n\t\treturn attachToPost(mess, filename, file, request);\n\t}\n\n\tprotected Response attachToPost(Message mess, String filename, InputStream file,  HttpServletRequest request) {\n\t\tIdentity identity = getIdentity(request);\n\t\tif(identity == null) {\n\t\t\treturn Response.serverError().status(Status.UNAUTHORIZED).build();\n\t\t} else if (!identity.equalsByPersistableKey(mess.getCreator())) {\n\t\t\tif(mess.getModifier() == null || !identity.equalsByPersistableKey(mess.getModifier())) {\n\t\t\t\treturn Response.serverError().status(Status.UNAUTHORIZED).build();\n\t\t\t}\n\t\t}\n\n\t\tVFSContainer container = fom.getMessageContainer(mess.getForum().getKey(), mess.getKey());\n\t\tVFSItem item = container.resolve(filename);\n\t\tVFSLeaf attachment = null;\n\t\tif(item == null) {\n\t\t\tattachment = container.createChildLeaf(filename);\n\t\t} else {\n\t\t\tfilename = VFSManager.rename(container, filename);\n\t\t\tif(filename == null) {\n\t\t\t\treturn Response.serverError().status(Status.NOT_ACCEPTABLE).build();\n\t\t\t}\n\t\t\tattachment = container.createChildLeaf(filename);\n\t\t}\n\t\t\n\n\t\ttry(OutputStream out = attachment.getOutputStream(false)) {\n\t\t\tIOUtils.copy(file, out);\n\t\t} catch (IOException e) {\n\t\t\treturn Response.serverError().status(Status.INTERNAL_SERVER_ERROR).build();\n\t\t} finally {\n\t\t\tFileUtils.closeSafely(file);\n\t\t}\n\t\treturn Response.ok().build();\n\t}\n\t\n\tpublic String format(String segment) {\n\t\tsegment = segment.replace(\" \", \"_\");\n\t\treturn segment;",
        "code_after_change": "\t * @file file64 The attachment (encoded as Base64)\n\t * @param request The HTTP request\n\t * @return Ok\n\t */\n\t@POST\n\t@Operation(summary = \"Post attachment\",\n\tdescription = \"Upload the attachment of a message.\")\n\t@Path(\"posts/{messageKey}/attachments\")\n\t@ApiResponse(responseCode = \"200\", description = \"Ok.\")\n\t@ApiResponse(responseCode = \"404\", description = \" The identity or the portrait not found\")\n\t@Consumes(MediaType.APPLICATION_FORM_URLENCODED)\n\t@Produces({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON})\n\tpublic Response replyToPostAttachment(@PathParam(\"messageKey\") Long messageKey, @FormParam(\"filename\") String filename,\n\t\t\t@FormParam(\"file\") String file, @Context HttpServletRequest request) {\n\t\tbyte[] fileAsBytes = Base64.decodeBase64(file);\n\t\tInputStream in = new ByteArrayInputStream(fileAsBytes);\n\t\treturn attachToPost(messageKey, filename, in, request);\n\t}\n\t\n\t@PUT\n\t@Operation(summary = \"Put attachment\", description = \"Upload the attachment of a message.\")\n\t@ApiResponse(responseCode = \"200\", description = \"Ok.\")\n\t@ApiResponse(responseCode = \"404\", description = \" The identity or the portrait not found\")\n\t@Path(\"posts/{messageKey}/attachments\")\n\t@Consumes({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON})\n\t@Produces({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON})\n\tpublic Response replyToPostAttachment(@PathParam(\"messageKey\") Long messageKey,  File64VO file64, @Context HttpServletRequest request) {\n\t\tString file = file64.getFile();\n\t\tString filename = file64.getFilename();\n\t\tbyte[] fileAsBytes = Base64.decodeBase64(file);\n\t\tInputStream in = new ByteArrayInputStream(fileAsBytes);\n\t\treturn attachToPost(messageKey, filename, in, request);\n\t}\n\t\n\tprivate Response attachToPost(Long messageKey, String filename, InputStream file,  HttpServletRequest request) {\n\t\t//load message\n\t\tMessage mess = fom.loadMessage(messageKey);\n\t\tif(mess == null) {\n\t\t\treturn Response.serverError().status(Status.NOT_FOUND).build();\n\t\t}\n\t\tif(!forum.equalsByPersistableKey(mess.getForum())) {\n\t\t\treturn Response.serverError().status(Status.CONFLICT).build();\n\t\t}\n\t\treturn attachToPost(mess, filename, file, request);\n\t}\n\n\tprivate Response attachToPost(Message mess, String filename, InputStream file,  HttpServletRequest request) {\n\t\tIdentity identity = getIdentity(request);\n\t\tif(identity == null) {\n\t\t\treturn Response.serverError().status(Status.UNAUTHORIZED).build();\n\t\t} else if (!identity.equalsByPersistableKey(mess.getCreator())) {\n\t\t\tif(mess.getModifier() == null || !identity.equalsByPersistableKey(mess.getModifier())) {\n\t\t\t\treturn Response.serverError().status(Status.UNAUTHORIZED).build();\n\t\t\t}\n\t\t}\n\n\t\tVFSContainer container = fom.getMessageContainer(mess.getForum().getKey(), mess.getKey());\n\t\tVFSItem item = container.resolve(filename);\n\t\tVFSLeaf attachment = null;\n\t\tif(item == null) {\n\t\t\tattachment = container.createChildLeaf(filename);\n\t\t} else {\n\t\t\tfilename = VFSManager.rename(container, filename);\n\t\t\tif(filename == null) {\n\t\t\t\treturn Response.serverError().status(Status.NOT_ACCEPTABLE).build();\n\t\t\t}\n\t\t\tattachment = container.createChildLeaf(filename);\n\t\t}\n\t\t\n\n\t\ttry(OutputStream out = attachment.getOutputStream(false)) {\n\t\t\tIOUtils.copy(file, out);\n\t\t} catch (IOException e) {\n\t\t\treturn Response.serverError().status(Status.INTERNAL_SERVER_ERROR).build();\n\t\t} finally {\n\t\t\tFileUtils.closeSafely(file);\n\t\t}\n\t\treturn Response.ok().build();\n\t}\n\t\n\tpublic String format(String segment) {\n\t\tsegment = segment.replace(\" \", \"_\");\n\t\treturn segment;",
        "patch": "@@ -598,7 +598,7 @@ public Response replyToPostAttachment(@PathParam(\"messageKey\") Long messageKey,\n \t\treturn attachToPost(messageKey, filename, in, request);\n \t}\n \t\n-\tprotected Response attachToPost(Long messageKey, String filename, InputStream file,  HttpServletRequest request) {\n+\tprivate Response attachToPost(Long messageKey, String filename, InputStream file,  HttpServletRequest request) {\n \t\t//load message\n \t\tMessage mess = fom.loadMessage(messageKey);\n \t\tif(mess == null) {\n@@ -610,7 +610,7 @@ protected Response attachToPost(Long messageKey, String filename, InputStream fi\n \t\treturn attachToPost(mess, filename, file, request);\n \t}\n \n-\tprotected Response attachToPost(Message mess, String filename, InputStream file,  HttpServletRequest request) {\n+\tprivate Response attachToPost(Message mess, String filename, InputStream file,  HttpServletRequest request) {\n \t\tIdentity identity = getIdentity(request);\n \t\tif(identity == null) {\n \t\t\treturn Response.serverError().status(Status.UNAUTHORIZED).build();",
        "function_modified_lines": {
            "added": [
                "\tprivate Response attachToPost(Long messageKey, String filename, InputStream file,  HttpServletRequest request) {\n",
                "\tprivate Response attachToPost(Message mess, String filename, InputStream file,  HttpServletRequest request) {\n"
            ],
            "deleted": [
                "\tprotected Response attachToPost(Long messageKey, String filename, InputStream file,  HttpServletRequest request) {\n",
                "\tprotected Response attachToPost(Message mess, String filename, InputStream file,  HttpServletRequest request) {\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-22"
        ],
        "cve_description": "OpenOlat is a web-basedlearning management system. A path traversal vulnerability exists in OpenOlat prior to versions 15.5.12 and 16.0.5. By providing a filename that contains a relative path as a parameter in some REST methods, it is possible to create directory structures and write files anywhere on the target system. The attack could be used to write files anywhere in the web root folder or outside, depending on the configuration of the system and the properly configured permission of the application server user. The attack requires an OpenOlat user account, an enabled REST API and the rights on a business object to call the vulnerable REST calls. The problem is fixed in version 15.5.12 and 16.0.5. There is a workaround available. The vulnerability requires the REST module to be enabled. Disabling the REST module or limiting the REST module via some firewall or web-server access rules to be accessed only be trusted systems will mitigate the risk.",
        "id": 12540
    },
    {
        "cve_id": "CVE-2022-24830",
        "code_before_change": "{\r\n        FormProcessor fp = new FormProcessor(request);\r\n        String filePathName = \"\";\r\n        String fileName = fp.getString(\"fileName\");\r\n        File f = new File(fileName);\r\n        \r\n        if(fileName != null && fileName.indexOf(\"..\") > -1) {\r\n        \tthrow new RuntimeException(\"Traversal attempt - absolute path not allowed \" + fileName);\r\n        }\r\n        \r\n        if (fileName != null && fileName.length() > 0) {\r\n            int parentStudyId = currentStudy.getParentStudyId();\r\n            String testPath = Utils.getAttachedFileRootPath();\r\n            String tail = File.separator + f.getName();\r\n            String testName = testPath + currentStudy.getOid() + tail;\r\n            File temp = new File(testName);\r\n            if (temp.exists()) {\r\n                filePathName = testName;\r\n                logger.info(currentStudy.getName() + \" existing filePathName=\" + filePathName);\r\n            } else {\r\n                if (currentStudy.isSite(parentStudyId)) {\r\n                    testName = testPath + ((StudyBean) new StudyDAO(sm.getDataSource()).findByPK(parentStudyId)).getOid() + tail;\r\n                    temp = new File(testName);\r\n                    if (temp.exists()) {\r\n                        filePathName = testName;\r\n                        logger.info(\"parent existing filePathName=\" + filePathName);\r\n                    }\r\n                } else {\r\n                    ArrayList<StudyBean> sites = (ArrayList<StudyBean>) new StudyDAO(sm.getDataSource()).findAllByParent(currentStudy.getId());\r\n                    for (StudyBean s : sites) {\r\n                        testPath = Utils.getAttachedFilePath(s);\r\n                        testName = testPath + tail;//+ s.getIdentifier() + tail;\r\n                        File test = new File(testName);\r\n                        if (test.exists()) {\r\n                            filePathName = testName;\r\n                            logger.info(\"site of currentStudy existing filePathName=\" + filePathName);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        logger.info(\"filePathName=\" + filePathName + \" fileName=\" + fileName);\r\n        File file = new File(filePathName);\r\n        if (!file.exists() || file.length() <= 0) {\r\n            addPageMessage(\"File \" + filePathName + \" \" + respage.getString(\"not_exist\"));\r\n            \r\n            // try to use the passed in the existing file\r\n        \tfile = new File(fileName);\r\n        }\r\n        \r\n        if (!file.exists() || file.length() <= 0) {\r\n            addPageMessage(\"File \" + filePathName + \" \" + respage.getString(\"not_exist\"));\r\n        } else {\r\n//            response.setContentType(\"application/octet-stream\");\r\n            response.setHeader(\"Content-disposition\", \"attachment; filename=\\\"\" + fileName + \"\\\";\");\r\n            response.setHeader(\"Pragma\", \"public\");\r\n\r\n            ServletOutputStream outStream = response.getOutputStream();\r\n            DataInputStream inStream = null;\r\n            try {\r\n                response.setContentType(\"application/download\");\r\n                response.setHeader(\"Cache-Control\", \"max-age=0\");\r\n                response.setContentLength((int) file.length());\r\n\r\n                byte[] bbuf = new byte[(int) file.length()];\r\n                inStream = new DataInputStream(new FileInputStream(file));\r\n                int length;\r\n                while (inStream != null && (length = inStream.read(bbuf)) != -1) {\r\n                    outStream.write(bbuf, 0, length);\r\n                }\r\n\r\n                inStream.close();\r\n                outStream.flush();\r\n                outStream.close();\r\n            } catch (Exception ee) {\r\n                ee.printStackTrace();\r\n            } finally {\r\n                if (inStream != null) {\r\n                    inStream.close();\r\n                }\r\n                if (outStream != null) {\r\n                    outStream.close();\r\n                }\r\n            }\r\n        }\r\n    }",
        "code_after_change": "{\r\n        FormProcessor fp = new FormProcessor(request);\r\n        String filePathName = \"\";\r\n        String fileName = fp.getString(\"fileName\");\r\n        File f = new File(fileName);\r\n              \r\n        if (fileName != null && fileName.length() > 0) {\r\n            int parentStudyId = currentStudy.getParentStudyId();           \r\n            String testPath = Utils.getAttachedFileRootPath();\r\n            String tail = File.separator + f.getName();\r\n            String testName = testPath + currentStudy.getOid() + tail;\r\n            \r\n            String filePath = testPath + currentStudy.getOid() +File.separator;            \r\n            File temp = new File(filePath,f.getName());            \r\n            String canonicalPath= temp.getCanonicalPath();\r\n            \r\n            if (canonicalPath.startsWith(filePath)) {\r\n            \t;\r\n            }else {\r\n            \tthrow new RuntimeException(\"Traversal attempt - file path not allowed \" + fileName);\r\n            }\r\n            \r\n            if (temp.exists()) {\r\n                filePathName = testName;\r\n                logger.info(currentStudy.getName() + \" existing filePathName=\" + filePathName);\r\n            } else {\r\n                if (currentStudy.isSite(parentStudyId)) {\r\n                    testName = testPath + ((StudyBean) new StudyDAO(sm.getDataSource()).findByPK(parentStudyId)).getOid() + tail;\r\n                    temp = new File(testName);\r\n                    if (temp.exists()) {\r\n                        filePathName = testName;\r\n                        logger.info(\"parent existing filePathName=\" + filePathName);\r\n                    }\r\n                } else {\r\n                    ArrayList<StudyBean> sites = (ArrayList<StudyBean>) new StudyDAO(sm.getDataSource()).findAllByParent(currentStudy.getId());\r\n                    for (StudyBean s : sites) {\r\n                        testPath = Utils.getAttachedFilePath(s);\r\n                        testName = testPath + tail;//+ s.getIdentifier() + tail;\r\n                        File test = new File(testName);\r\n                        if (test.exists()) {\r\n                            filePathName = testName;\r\n                            logger.info(\"site of currentStudy existing filePathName=\" + filePathName);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        logger.info(\"filePathName=\" + filePathName + \" fileName=\" + fileName);\r\n        File file = new File(filePathName);\r\n        if (!file.exists() || file.length() <= 0) {\r\n            addPageMessage(\"File \" + filePathName + \" \" + respage.getString(\"not_exist\"));\r\n            \r\n            // try to use the passed in the existing file\r\n        \tfile = new File(fileName);\r\n        }\r\n        \r\n        if (!file.exists() || file.length() <= 0) {\r\n            addPageMessage(\"File \" + filePathName + \" \" + respage.getString(\"not_exist\"));\r\n        } else {\r\n//            response.setContentType(\"application/octet-stream\");\r\n            response.setHeader(\"Content-disposition\", \"attachment; filename=\\\"\" + fileName + \"\\\";\");\r\n            response.setHeader(\"Pragma\", \"public\");\r\n\r\n            ServletOutputStream outStream = response.getOutputStream();\r\n            DataInputStream inStream = null;\r\n            try {\r\n                response.setContentType(\"application/download\");\r\n                response.setHeader(\"Cache-Control\", \"max-age=0\");\r\n                response.setContentLength((int) file.length());\r\n\r\n                byte[] bbuf = new byte[(int) file.length()];\r\n                inStream = new DataInputStream(new FileInputStream(file));\r\n                int length;\r\n                while (inStream != null && (length = inStream.read(bbuf)) != -1) {\r\n                    outStream.write(bbuf, 0, length);\r\n                }\r\n\r\n                inStream.close();\r\n                outStream.flush();\r\n                outStream.close();\r\n            } catch (Exception ee) {\r\n                ee.printStackTrace();\r\n            } finally {\r\n                if (inStream != null) {\r\n                    inStream.close();\r\n                }\r\n                if (outStream != null) {\r\n                    outStream.close();\r\n                }\r\n            }\r\n        }\r\n    }",
        "patch": "@@ -70,17 +70,23 @@ public void processRequest() throws Exception {\n         String filePathName = \"\";\r\n         String fileName = fp.getString(\"fileName\");\r\n         File f = new File(fileName);\r\n-        \r\n-        if(fileName != null && fileName.indexOf(\"..\") > -1) {\r\n-        \tthrow new RuntimeException(\"Traversal attempt - absolute path not allowed \" + fileName);\r\n-        }\r\n-        \r\n+              \r\n         if (fileName != null && fileName.length() > 0) {\r\n-            int parentStudyId = currentStudy.getParentStudyId();\r\n+            int parentStudyId = currentStudy.getParentStudyId();           \r\n             String testPath = Utils.getAttachedFileRootPath();\r\n             String tail = File.separator + f.getName();\r\n             String testName = testPath + currentStudy.getOid() + tail;\r\n-            File temp = new File(testName);\r\n+            \r\n+            String filePath = testPath + currentStudy.getOid() +File.separator;            \r\n+            File temp = new File(filePath,f.getName());            \r\n+            String canonicalPath= temp.getCanonicalPath();\r\n+            \r\n+            if (canonicalPath.startsWith(filePath)) {\r\n+            \t;\r\n+            }else {\r\n+            \tthrow new RuntimeException(\"Traversal attempt - file path not allowed \" + fileName);\r\n+            }\r\n+            \r\n             if (temp.exists()) {\r\n                 filePathName = testName;\r\n                 logger.info(currentStudy.getName() + \" existing filePathName=\" + filePathName);\r",
        "function_modified_lines": {
            "added": [
                "              \r\n",
                "            int parentStudyId = currentStudy.getParentStudyId();           \r\n",
                "            \r\n",
                "            String filePath = testPath + currentStudy.getOid() +File.separator;            \r\n",
                "            File temp = new File(filePath,f.getName());            \r\n",
                "            String canonicalPath= temp.getCanonicalPath();\r\n",
                "            \r\n",
                "            if (canonicalPath.startsWith(filePath)) {\r\n",
                "            \t;\r\n",
                "            }else {\r\n",
                "            \tthrow new RuntimeException(\"Traversal attempt - file path not allowed \" + fileName);\r\n",
                "            }\r\n",
                "            \r\n"
            ],
            "deleted": [
                "        \r\n",
                "        if(fileName != null && fileName.indexOf(\"..\") > -1) {\r\n",
                "        \tthrow new RuntimeException(\"Traversal attempt - absolute path not allowed \" + fileName);\r\n",
                "        }\r\n",
                "        \r\n",
                "            int parentStudyId = currentStudy.getParentStudyId();\r\n",
                "            File temp = new File(testName);\r\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-22"
        ],
        "cve_description": "OpenClinica is an open source software for Electronic Data Capture (EDC) and Clinical Data Management (CDM). OpenClinica prior to version 3.16 is vulnerable to path traversal in multiple endpoints, leading to arbitrary file read/write, and potential remote code execution. There are no known workarounds. This issue has been patched and users are recommended to upgrade.",
        "id": 12594
    },
    {
        "cve_id": "CVE-2022-24830",
        "code_before_change": "{\n        \t// fix path traversal issue\n            excelFile = new File(dir,excelFileName);\n            // backwards compat\n            File oldExcelFile = new File(dir, oldExcelFileName);            \n       \n        \tif (oldExcelFile.exists() && oldExcelFile.length() > 0) {\n                 if (!excelFile.exists() || excelFile.length() <= 0) {\n                     // if the old name exists and the new name does not...\n                     excelFile = oldExcelFile;\n                     excelFileName = oldExcelFileName;\n                 }\n             }                  \n\n        }",
        "code_after_change": "{\n        \t// fix path traversal issue\n            excelFile = new File(dir,excelFileName);\n            // backwards compat\n            File oldExcelFile = new File(dir, oldExcelFileName);            \n            \n            String canonicalPath1= excelFile.getCanonicalPath();\n            String canonicalPath2= oldExcelFile.getCanonicalPath();\n            if (canonicalPath1.startsWith(dir) && canonicalPath2.startsWith(dir)) {\n            \tif (oldExcelFile.exists() && oldExcelFile.length() > 0) {\n                    if (!excelFile.exists() || excelFile.length() <= 0) {\n                        // if the old name exists and the new name does not...\n                        excelFile = oldExcelFile;\n                        excelFileName = oldExcelFileName;\n                    }\n                }     \n            }else {\n            \t addPageMessage(respage.getString(\"the_excel_is_not_available_on_server_contact\"));\n                 forwardPage(Page.CRF_LIST_SERVLET);\n            }\n        \t             \n\n        }",
        "patch": "@@ -95,14 +95,22 @@ public void processRequest() throws Exception {\n             excelFile = new File(dir,excelFileName);\n             // backwards compat\n             File oldExcelFile = new File(dir, oldExcelFileName);            \n-       \n-        \tif (oldExcelFile.exists() && oldExcelFile.length() > 0) {\n-                 if (!excelFile.exists() || excelFile.length() <= 0) {\n-                     // if the old name exists and the new name does not...\n-                     excelFile = oldExcelFile;\n-                     excelFileName = oldExcelFileName;\n-                 }\n-             }                  \n+            \n+            String canonicalPath1= excelFile.getCanonicalPath();\n+            String canonicalPath2= oldExcelFile.getCanonicalPath();\n+            if (canonicalPath1.startsWith(dir) && canonicalPath2.startsWith(dir)) {\n+            \tif (oldExcelFile.exists() && oldExcelFile.length() > 0) {\n+                    if (!excelFile.exists() || excelFile.length() <= 0) {\n+                        // if the old name exists and the new name does not...\n+                        excelFile = oldExcelFile;\n+                        excelFileName = oldExcelFileName;\n+                    }\n+                }     \n+            }else {\n+            \t addPageMessage(respage.getString(\"the_excel_is_not_available_on_server_contact\"));\n+                 forwardPage(Page.CRF_LIST_SERVLET);\n+            }\n+        \t             \n \n         }\n         logger.info(\"looking for : \" + excelFile.getName());",
        "function_modified_lines": {
            "added": [
                "            \n",
                "            String canonicalPath1= excelFile.getCanonicalPath();\n",
                "            String canonicalPath2= oldExcelFile.getCanonicalPath();\n",
                "            if (canonicalPath1.startsWith(dir) && canonicalPath2.startsWith(dir)) {\n",
                "            \tif (oldExcelFile.exists() && oldExcelFile.length() > 0) {\n",
                "                    if (!excelFile.exists() || excelFile.length() <= 0) {\n",
                "                        // if the old name exists and the new name does not...\n",
                "                        excelFile = oldExcelFile;\n",
                "                        excelFileName = oldExcelFileName;\n",
                "                    }\n",
                "                }     \n",
                "            }else {\n",
                "            \t addPageMessage(respage.getString(\"the_excel_is_not_available_on_server_contact\"));\n",
                "                 forwardPage(Page.CRF_LIST_SERVLET);\n",
                "            }\n",
                "        \t             \n"
            ],
            "deleted": [
                "       \n",
                "        \tif (oldExcelFile.exists() && oldExcelFile.length() > 0) {\n",
                "                 if (!excelFile.exists() || excelFile.length() <= 0) {\n",
                "                     // if the old name exists and the new name does not...\n",
                "                     excelFile = oldExcelFile;\n",
                "                     excelFileName = oldExcelFileName;\n",
                "                 }\n",
                "             }                  \n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-22"
        ],
        "cve_description": "OpenClinica is an open source software for Electronic Data Capture (EDC) and Clinical Data Management (CDM). OpenClinica prior to version 3.16 is vulnerable to path traversal in multiple endpoints, leading to arbitrary file read/write, and potential remote code execution. There are no known workarounds. This issue has been patched and users are recommended to upgrade.",
        "id": 12593
    },
    {
        "cve_id": "CVE-2023-40828",
        "code_before_change": "/*\n * Copyright (C) 2012-present the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.pf4j.util;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * This class extracts the content of the plugin zip into a directory.\n * It's a class for only the internal use.\n *\n * @author Decebal Suiu\n */\npublic class Unzip {\n\n    private static final Logger log = LoggerFactory.getLogger(Unzip.class);\n\n    /**\n     * Holds the destination directory.\n     * File will be unzipped into the destination directory.\n     */\n    private File destination;\n\n    /**\n     * Holds path to zip file.\n     */\n    private File source;\n\n    public Unzip() {\n    }\n\n    public Unzip(File source, File destination) {\n        this.source = source;\n        this.destination = destination;\n    }\n\n    public void setSource(File source) {\n        this.source = source;\n    }\n\n    public void setDestination(File destination) {\n        this.destination = destination;\n    }\n\n    /**\n     * Extract the content of zip file ({@code source}) to destination directory.\n     * If destination directory already exists it will be deleted before.\n     */\n    public void extract() throws IOException {\n        log.debug(\"Extract content of '{}' to '{}'\", source, destination);\n\n        // delete destination directory if exists\n        if (destination.exists() && destination.isDirectory()) {\n            FileUtils.delete(destination.toPath());\n        }\n\n        try (ZipInputStream zipInputStream = new ZipInputStream(new FileInputStream(source))) {\n            ZipEntry zipEntry;\n            while ((zipEntry = zipInputStream.getNextEntry()) != null) {\n                File file = new File(destination, zipEntry.getName());\n\n                // create intermediary directories - sometimes zip don't add them\n                File dir = new File(file.getParent());\n\n                mkdirsOrThrow(dir);\n\n                if (zipEntry.isDirectory()) {\n                    mkdirsOrThrow(file);\n                } else {\n                    byte[] buffer = new byte[1024];\n                    int length;\n                    try (FileOutputStream fos = new FileOutputStream(file)) {\n                        while ((length = zipInputStream.read(buffer)) >= 0) {\n                            fos.write(buffer, 0, length);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    private static void mkdirsOrThrow(File dir) throws IOException {\n        if (!dir.exists() && !dir.mkdirs()) {\n            throw new IOException(\"Failed to create directory \" + dir);\n        }\n    }\n\n}\n",
        "code_after_change": "/*\n * Copyright (C) 2012-present the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.pf4j.util;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipException;\nimport java.util.zip.ZipInputStream;\n\n/**\n * This class extracts the content of the plugin zip into a directory.\n * It's a class for only the internal use.\n *\n * @author Decebal Suiu\n */\npublic class Unzip {\n\n    private static final Logger log = LoggerFactory.getLogger(Unzip.class);\n\n    /**\n     * Holds the destination directory.\n     * File will be unzipped into the destination directory.\n     */\n    private File destination;\n\n    /**\n     * Holds path to zip file.\n     */\n    private File source;\n\n    public Unzip() {\n    }\n\n    public Unzip(File source, File destination) {\n        this.source = source;\n        this.destination = destination;\n    }\n\n    public void setSource(File source) {\n        this.source = source;\n    }\n\n    public void setDestination(File destination) {\n        this.destination = destination;\n    }\n\n    /**\n     * Extract the content of zip file ({@code source}) to destination directory.\n     * If destination directory already exists it will be deleted before.\n     */\n    public void extract() throws IOException {\n        log.debug(\"Extract content of '{}' to '{}'\", source, destination);\n\n        // delete destination directory if exists\n        if (destination.exists() && destination.isDirectory()) {\n            FileUtils.delete(destination.toPath());\n        }\n\n        String destinationCanonicalPath = destination.getCanonicalPath();\n        try (ZipInputStream zipInputStream = new ZipInputStream(new FileInputStream(source))) {\n            ZipEntry zipEntry;\n            while ((zipEntry = zipInputStream.getNextEntry()) != null) {\n                File file = new File(destination, zipEntry.getName());\n\n                String fileCanonicalPath = file.getCanonicalPath();\n                if (!fileCanonicalPath.startsWith(destinationCanonicalPath)) {\n                    throw new ZipException(\"The file \"+ zipEntry.getName() + \" is trying to leave the target output directory of \"+ destination);\n                }\n\n                // create intermediary directories - sometimes zip don't add them\n                File dir = new File(file.getParent());\n\n                mkdirsOrThrow(dir);\n\n                if (zipEntry.isDirectory()) {\n                    mkdirsOrThrow(file);\n                } else {\n                    byte[] buffer = new byte[1024];\n                    int length;\n                    try (FileOutputStream fos = new FileOutputStream(file)) {\n                        while ((length = zipInputStream.read(buffer)) >= 0) {\n                            fos.write(buffer, 0, length);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    private static void mkdirsOrThrow(File dir) throws IOException {\n        if (!dir.exists() && !dir.mkdirs()) {\n            throw new IOException(\"Failed to create directory \" + dir);\n        }\n    }\n\n}\n",
        "patch": "@@ -15,17 +15,17 @@\n  */\n package org.pf4j.util;\n \n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n import java.io.File;\n import java.io.FileInputStream;\n-import java.io.FileNotFoundException;\n import java.io.FileOutputStream;\n import java.io.IOException;\n import java.util.zip.ZipEntry;\n+import java.util.zip.ZipException;\n import java.util.zip.ZipInputStream;\n \n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n /**\n  * This class extracts the content of the plugin zip into a directory.\n  * It's a class for only the internal use.\n@@ -75,11 +75,17 @@ public void extract() throws IOException {\n             FileUtils.delete(destination.toPath());\n         }\n \n+        String destinationCanonicalPath = destination.getCanonicalPath();\n         try (ZipInputStream zipInputStream = new ZipInputStream(new FileInputStream(source))) {\n             ZipEntry zipEntry;\n             while ((zipEntry = zipInputStream.getNextEntry()) != null) {\n                 File file = new File(destination, zipEntry.getName());\n \n+                String fileCanonicalPath = file.getCanonicalPath();\n+                if (!fileCanonicalPath.startsWith(destinationCanonicalPath)) {\n+                    throw new ZipException(\"The file \"+ zipEntry.getName() + \" is trying to leave the target output directory of \"+ destination);\n+                }\n+\n                 // create intermediary directories - sometimes zip don't add them\n                 File dir = new File(file.getParent());\n ",
        "function_modified_lines": {
            "added": [
                "import org.slf4j.Logger;\n",
                "import org.slf4j.LoggerFactory;\n",
                "\n",
                "import java.util.zip.ZipException;\n"
            ],
            "deleted": [
                "import java.io.FileNotFoundException;\n",
                "import org.slf4j.Logger;\n",
                "import org.slf4j.LoggerFactory;\n",
                "\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-22"
        ],
        "cve_description": "An issue in pf4j pf4j v.3.9.0 and before allows a remote attacker to obtain sensitive information and execute arbitrary code via the expandIfZip method in the extract function.",
        "id": 12845
    },
    {
        "cve_id": "CVE-2024-24565",
        "code_before_change": "/*\n * Licensed to Crate.io GmbH (\"Crate\") under one or more contributor\n * license agreements.  See the NOTICE file distributed with this work for\n * additional information regarding copyright ownership.  Crate licenses\n * this file to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.  You may\n * obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n * License for the specific language governing permissions and limitations\n * under the License.\n *\n * However, if you have executed another commercial license agreement\n * with Crate these terms will supersede the license and you may use the\n * software solely pursuant to the terms of the relevant commercial agreement.\n */\n\npackage io.crate.execution.engine.collect.sources;\n\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.CompletableFuture;\n\nimport org.elasticsearch.cluster.service.ClusterService;\nimport org.elasticsearch.common.inject.Inject;\nimport org.elasticsearch.common.inject.Singleton;\nimport org.elasticsearch.threadpool.ThreadPool;\n\nimport io.crate.analyze.AnalyzedCopyFrom;\nimport io.crate.analyze.CopyFromParserProperties;\nimport io.crate.analyze.SymbolEvaluator;\nimport io.crate.common.annotations.VisibleForTesting;\nimport io.crate.data.BatchIterator;\nimport io.crate.data.Row;\nimport io.crate.data.SkippingBatchIterator;\nimport io.crate.execution.dsl.phases.CollectPhase;\nimport io.crate.execution.dsl.phases.FileUriCollectPhase;\nimport io.crate.execution.engine.collect.CollectTask;\nimport io.crate.execution.engine.collect.files.FileInputFactory;\nimport io.crate.execution.engine.collect.files.FileReadingIterator;\nimport io.crate.execution.engine.collect.files.LineCollectorExpression;\nimport io.crate.execution.engine.collect.files.LineProcessor;\nimport io.crate.expression.InputFactory;\nimport io.crate.expression.reference.file.FileLineReferenceResolver;\nimport io.crate.expression.symbol.Symbol;\nimport io.crate.metadata.NodeContext;\nimport io.crate.metadata.TransactionContext;\nimport io.crate.planner.operators.SubQueryResults;\nimport io.crate.types.DataTypes;\n\n@Singleton\npublic class FileCollectSource implements CollectSource {\n\n    private final ClusterService clusterService;\n    private final Map<String, FileInputFactory> fileInputFactoryMap;\n    private final InputFactory inputFactory;\n    private final NodeContext nodeCtx;\n    private final ThreadPool threadPool;\n\n    @Inject\n    public FileCollectSource(NodeContext nodeCtx,\n                             ClusterService clusterService,\n                             Map<String, FileInputFactory> fileInputFactoryMap,\n                             ThreadPool threadPool) {\n        this.fileInputFactoryMap = fileInputFactoryMap;\n        this.nodeCtx = nodeCtx;\n        this.inputFactory = new InputFactory(nodeCtx);\n        this.clusterService = clusterService;\n        this.threadPool = threadPool;\n    }\n\n    @Override\n    public CompletableFuture<BatchIterator<Row>> getIterator(TransactionContext txnCtx,\n                                                             CollectPhase collectPhase,\n                                                             CollectTask collectTask,\n                                                             boolean supportMoveToStart) {\n        FileUriCollectPhase fileUriCollectPhase = (FileUriCollectPhase) collectPhase;\n        InputFactory.Context<LineCollectorExpression<?>> ctx =\n            inputFactory.ctxForRefs(txnCtx, FileLineReferenceResolver::getImplementation);\n        ctx.add(collectPhase.toCollect());\n\n        List<String> fileUris = targetUriToStringList(txnCtx, nodeCtx, fileUriCollectPhase.targetUri());\n        FileReadingIterator fileReadingIterator = new FileReadingIterator(\n            fileUris,\n            fileUriCollectPhase.compression(),\n            fileInputFactoryMap,\n            fileUriCollectPhase.sharedStorage(),\n            fileUriCollectPhase.nodeIds().size(),\n            getReaderNumber(fileUriCollectPhase.nodeIds(), clusterService.state().nodes().getLocalNodeId()),\n            fileUriCollectPhase.withClauseOptions(),\n            threadPool.scheduler()\n        );\n        CopyFromParserProperties parserProperties = fileUriCollectPhase.parserProperties();\n        LineProcessor lineProcessor = new LineProcessor(\n            parserProperties.skipNumLines() > 0\n                ? new SkippingBatchIterator<>(fileReadingIterator, (int) parserProperties.skipNumLines())\n                : fileReadingIterator,\n            ctx.topLevelInputs(),\n            ctx.expressions(),\n            fileUriCollectPhase.inputFormat(),\n            parserProperties,\n            fileUriCollectPhase.targetColumns()\n        );\n        return CompletableFuture.completedFuture(lineProcessor);\n    }\n\n    @VisibleForTesting\n    public static int getReaderNumber(Collection<String> nodeIds, String localNodeId) {\n        String[] readers = nodeIds.toArray(new String[0]);\n        Arrays.sort(readers);\n        return Arrays.binarySearch(readers, localNodeId);\n    }\n\n    private static List<String> targetUriToStringList(TransactionContext txnCtx,\n                                                      NodeContext nodeCtx,\n                                                      Symbol targetUri) {\n        Object value = SymbolEvaluator.evaluate(txnCtx, nodeCtx, targetUri, Row.EMPTY, SubQueryResults.EMPTY);\n        if (targetUri.valueType().id() == DataTypes.STRING.id()) {\n            String uri = (String) value;\n            return Collections.singletonList(uri);\n        } else if (DataTypes.STRING_ARRAY.equals(targetUri.valueType())) {\n            return DataTypes.STRING_ARRAY.implicitCast(value);\n        }\n\n        // this case actually never happens because the check is already done in the analyzer\n        throw AnalyzedCopyFrom.raiseInvalidType(targetUri.valueType());\n    }\n}\n",
        "code_after_change": "/*\n * Licensed to Crate.io GmbH (\"Crate\") under one or more contributor\n * license agreements.  See the NOTICE file distributed with this work for\n * additional information regarding copyright ownership.  Crate licenses\n * this file to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.  You may\n * obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n * License for the specific language governing permissions and limitations\n * under the License.\n *\n * However, if you have executed another commercial license agreement\n * with Crate these terms will supersede the license and you may use the\n * software solely pursuant to the terms of the relevant commercial agreement.\n */\n\npackage io.crate.execution.engine.collect.sources;\n\nimport static java.util.Objects.requireNonNull;\n\nimport java.net.URI;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.CompletableFuture;\n\nimport org.elasticsearch.cluster.service.ClusterService;\nimport org.elasticsearch.common.inject.Inject;\nimport org.elasticsearch.common.inject.Singleton;\nimport org.elasticsearch.threadpool.ThreadPool;\n\nimport io.crate.analyze.AnalyzedCopyFrom;\nimport io.crate.analyze.CopyFromParserProperties;\nimport io.crate.analyze.SymbolEvaluator;\nimport io.crate.common.annotations.VisibleForTesting;\nimport io.crate.data.BatchIterator;\nimport io.crate.data.Row;\nimport io.crate.data.SkippingBatchIterator;\nimport io.crate.exceptions.UnauthorizedException;\nimport io.crate.execution.dsl.phases.CollectPhase;\nimport io.crate.execution.dsl.phases.FileUriCollectPhase;\nimport io.crate.execution.engine.collect.CollectTask;\nimport io.crate.execution.engine.collect.files.FileInputFactory;\nimport io.crate.execution.engine.collect.files.FileReadingIterator;\nimport io.crate.execution.engine.collect.files.LineCollectorExpression;\nimport io.crate.execution.engine.collect.files.LineProcessor;\nimport io.crate.expression.InputFactory;\nimport io.crate.expression.reference.file.FileLineReferenceResolver;\nimport io.crate.expression.symbol.Symbol;\nimport io.crate.metadata.NodeContext;\nimport io.crate.metadata.TransactionContext;\nimport io.crate.planner.operators.SubQueryResults;\nimport io.crate.role.Role;\nimport io.crate.role.Roles;\nimport io.crate.types.DataTypes;\n\n@Singleton\npublic class FileCollectSource implements CollectSource {\n\n    private final ClusterService clusterService;\n    private final Map<String, FileInputFactory> fileInputFactoryMap;\n    private final InputFactory inputFactory;\n    private final NodeContext nodeCtx;\n    private final ThreadPool threadPool;\n    private final Roles roles;\n\n    @Inject\n    public FileCollectSource(NodeContext nodeCtx,\n                             ClusterService clusterService,\n                             Map<String, FileInputFactory> fileInputFactoryMap,\n                             ThreadPool threadPool,\n                             Roles roles) {\n        this.fileInputFactoryMap = fileInputFactoryMap;\n        this.nodeCtx = nodeCtx;\n        this.inputFactory = new InputFactory(nodeCtx);\n        this.clusterService = clusterService;\n        this.threadPool = threadPool;\n        this.roles = roles;\n    }\n\n    @Override\n    public CompletableFuture<BatchIterator<Row>> getIterator(TransactionContext txnCtx,\n                                                             CollectPhase collectPhase,\n                                                             CollectTask collectTask,\n                                                             boolean supportMoveToStart) {\n        FileUriCollectPhase fileUriCollectPhase = (FileUriCollectPhase) collectPhase;\n        InputFactory.Context<LineCollectorExpression<?>> ctx =\n            inputFactory.ctxForRefs(txnCtx, FileLineReferenceResolver::getImplementation);\n        ctx.add(collectPhase.toCollect());\n\n        Role user = requireNonNull(roles.findUser(txnCtx.sessionSettings().userName()), \"User who invoked a statement must exist\");\n        List<URI> fileUris = targetUriToStringList(txnCtx, nodeCtx, fileUriCollectPhase.targetUri()).stream()\n            .map(s -> {\n                var uri = FileReadingIterator.toURI(s);\n                if (uri.getScheme().equals(\"file\") && user.isSuperUser() == false) {\n                    throw new UnauthorizedException(\"Only a superuser can read from the local file system\");\n                }\n                return uri;\n            })\n            .toList();\n        FileReadingIterator fileReadingIterator = new FileReadingIterator(\n            fileUris,\n            fileUriCollectPhase.compression(),\n            fileInputFactoryMap,\n            fileUriCollectPhase.sharedStorage(),\n            fileUriCollectPhase.nodeIds().size(),\n            getReaderNumber(fileUriCollectPhase.nodeIds(), clusterService.state().nodes().getLocalNodeId()),\n            fileUriCollectPhase.withClauseOptions(),\n            threadPool.scheduler()\n        );\n        CopyFromParserProperties parserProperties = fileUriCollectPhase.parserProperties();\n        LineProcessor lineProcessor = new LineProcessor(\n            parserProperties.skipNumLines() > 0\n                ? new SkippingBatchIterator<>(fileReadingIterator, (int) parserProperties.skipNumLines())\n                : fileReadingIterator,\n            ctx.topLevelInputs(),\n            ctx.expressions(),\n            fileUriCollectPhase.inputFormat(),\n            parserProperties,\n            fileUriCollectPhase.targetColumns()\n        );\n        return CompletableFuture.completedFuture(lineProcessor);\n    }\n\n    @VisibleForTesting\n    public static int getReaderNumber(Collection<String> nodeIds, String localNodeId) {\n        String[] readers = nodeIds.toArray(new String[0]);\n        Arrays.sort(readers);\n        return Arrays.binarySearch(readers, localNodeId);\n    }\n\n    private static List<String> targetUriToStringList(TransactionContext txnCtx,\n                                                      NodeContext nodeCtx,\n                                                      Symbol targetUri) {\n        Object value = SymbolEvaluator.evaluate(txnCtx, nodeCtx, targetUri, Row.EMPTY, SubQueryResults.EMPTY);\n        if (targetUri.valueType().id() == DataTypes.STRING.id()) {\n            String uri = (String) value;\n            return Collections.singletonList(uri);\n        } else if (DataTypes.STRING_ARRAY.equals(targetUri.valueType())) {\n            return DataTypes.STRING_ARRAY.implicitCast(value);\n        }\n\n        // this case actually never happens because the check is already done in the analyzer\n        throw AnalyzedCopyFrom.raiseInvalidType(targetUri.valueType());\n    }\n}\n",
        "patch": "@@ -21,6 +21,9 @@\n \n package io.crate.execution.engine.collect.sources;\n \n+import static java.util.Objects.requireNonNull;\n+\n+import java.net.URI;\n import java.util.Arrays;\n import java.util.Collection;\n import java.util.Collections;\n@@ -40,6 +43,7 @@\n import io.crate.data.BatchIterator;\n import io.crate.data.Row;\n import io.crate.data.SkippingBatchIterator;\n+import io.crate.exceptions.UnauthorizedException;\n import io.crate.execution.dsl.phases.CollectPhase;\n import io.crate.execution.dsl.phases.FileUriCollectPhase;\n import io.crate.execution.engine.collect.CollectTask;\n@@ -53,6 +57,8 @@\n import io.crate.metadata.NodeContext;\n import io.crate.metadata.TransactionContext;\n import io.crate.planner.operators.SubQueryResults;\n+import io.crate.role.Role;\n+import io.crate.role.Roles;\n import io.crate.types.DataTypes;\n \n @Singleton\n@@ -63,17 +69,20 @@ public class FileCollectSource implements CollectSource {\n     private final InputFactory inputFactory;\n     private final NodeContext nodeCtx;\n     private final ThreadPool threadPool;\n+    private final Roles roles;\n \n     @Inject\n     public FileCollectSource(NodeContext nodeCtx,\n                              ClusterService clusterService,\n                              Map<String, FileInputFactory> fileInputFactoryMap,\n-                             ThreadPool threadPool) {\n+                             ThreadPool threadPool,\n+                             Roles roles) {\n         this.fileInputFactoryMap = fileInputFactoryMap;\n         this.nodeCtx = nodeCtx;\n         this.inputFactory = new InputFactory(nodeCtx);\n         this.clusterService = clusterService;\n         this.threadPool = threadPool;\n+        this.roles = roles;\n     }\n \n     @Override\n@@ -86,7 +95,16 @@ public CompletableFuture<BatchIterator<Row>> getIterator(TransactionContext txnC\n             inputFactory.ctxForRefs(txnCtx, FileLineReferenceResolver::getImplementation);\n         ctx.add(collectPhase.toCollect());\n \n-        List<String> fileUris = targetUriToStringList(txnCtx, nodeCtx, fileUriCollectPhase.targetUri());\n+        Role user = requireNonNull(roles.findUser(txnCtx.sessionSettings().userName()), \"User who invoked a statement must exist\");\n+        List<URI> fileUris = targetUriToStringList(txnCtx, nodeCtx, fileUriCollectPhase.targetUri()).stream()\n+            .map(s -> {\n+                var uri = FileReadingIterator.toURI(s);\n+                if (uri.getScheme().equals(\"file\") && user.isSuperUser() == false) {\n+                    throw new UnauthorizedException(\"Only a superuser can read from the local file system\");\n+                }\n+                return uri;\n+            })\n+            .toList();\n         FileReadingIterator fileReadingIterator = new FileReadingIterator(\n             fileUris,\n             fileUriCollectPhase.compression(),",
        "function_modified_lines": {
            "added": [
                "import static java.util.Objects.requireNonNull;\n",
                "\n",
                "import java.net.URI;\n"
            ],
            "deleted": []
        },
        "lang": "Java",
        "cwe": [
            "CWE-22"
        ],
        "cve_description": "CrateDB is a distributed SQL database that makes it simple to store and analyze massive amounts of data in real-time. There is a COPY FROM function in the CrateDB database that is used to import file data into database tables. This function has a flaw, and authenticated attackers can use the COPY FROM function to import arbitrary file content into database tables, resulting in information leakage. This vulnerability is patched in 5.3.9, 5.4.8, 5.5.4, and 5.6.1.",
        "id": 12945
    },
    {
        "cve_id": "CVE-2024-25125",
        "code_before_change": "{\n            Path path = getPrefixDir(dateDir, attemptDir).resolve(fileName);\n            try (InputStream in = Files.newInputStream(path)) {\n                return ByteStreams.toByteArray(in);\n            }\n            catch (FileNotFoundException ex) {\n                throw new StorageFileNotFoundException(ex);\n            }\n            catch (IOException ex) {\n                throw ThrowablesUtil.propagate(ex);\n            }\n        }",
        "code_after_change": "{\n            Path prefixDir = getPrefixDir(dateDir, attemptDir);\n            Path path = prefixDir.resolve(fileName).normalize();\n            if (!path.startsWith(prefixDir)) {\n                throw new IllegalArgumentException(\"Invalid file name: \" + fileName);\n            }\n            try (InputStream in = Files.newInputStream(path)) {\n                return ByteStreams.toByteArray(in);\n            }\n            catch (FileNotFoundException | NoSuchFileException ex) {\n                throw new StorageFileNotFoundException(ex);\n            }\n            catch (IOException ex) {\n                throw ThrowablesUtil.propagate(ex);\n            }\n        }",
        "patch": "@@ -1,5 +1,6 @@\n package io.digdag.core.log;\n \n+import java.nio.file.NoSuchFileException;\n import java.util.concurrent.locks.ReentrantReadWriteLock;\n import java.io.InputStream;\n import java.io.OutputStream;\n@@ -122,11 +123,15 @@ protected void listFiles(String dateDir, String attemptDir, boolean enableDirect\n         protected byte[] getFile(String dateDir, String attemptDir, String fileName)\n             throws StorageFileNotFoundException\n         {\n-            Path path = getPrefixDir(dateDir, attemptDir).resolve(fileName);\n+            Path prefixDir = getPrefixDir(dateDir, attemptDir);\n+            Path path = prefixDir.resolve(fileName).normalize();\n+            if (!path.startsWith(prefixDir)) {\n+                throw new IllegalArgumentException(\"Invalid file name: \" + fileName);\n+            }\n             try (InputStream in = Files.newInputStream(path)) {\n                 return ByteStreams.toByteArray(in);\n             }\n-            catch (FileNotFoundException ex) {\n+            catch (FileNotFoundException | NoSuchFileException ex) {\n                 throw new StorageFileNotFoundException(ex);\n             }\n             catch (IOException ex) {",
        "function_modified_lines": {
            "added": [
                "            Path prefixDir = getPrefixDir(dateDir, attemptDir);\n",
                "            Path path = prefixDir.resolve(fileName).normalize();\n",
                "            if (!path.startsWith(prefixDir)) {\n",
                "                throw new IllegalArgumentException(\"Invalid file name: \" + fileName);\n",
                "            }\n",
                "            catch (FileNotFoundException | NoSuchFileException ex) {\n"
            ],
            "deleted": [
                "            Path path = getPrefixDir(dateDir, attemptDir).resolve(fileName);\n",
                "            catch (FileNotFoundException ex) {\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-22"
        ],
        "cve_description": "Digdag is an open source tool that to build, run, schedule, and monitor complex pipelines of tasks across various platforms. Treasure Data's digdag workload automation system is susceptible to a path traversal vulnerability if it's configured to store log files locally. This issue may lead to information disclosure and has been addressed in release version 0.10.5.1. Users are advised to upgrade. There are no known workarounds for this vulnerability.",
        "id": 12948
    }
]