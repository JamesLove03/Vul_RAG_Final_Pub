[
    {
        "cve_id": "CVE-2020-10683",
        "code_before_change": "/**\n     * <p>\n     * makeElement\n     * </p>\n     * a helper method which navigates from the given Document or Element node\n     * to some Element using the path expression, creating any necessary\n     * elements along the way. For example the path <code>a/b/c</code> would\n     * get the first child &lt;a&gt; element, which would be created if it did\n     * not exist, then the next child &lt;b&gt; and so on until finally a\n     * &lt;c&gt; element is returned.\n     * \n     * @param source\n     *            is the Element or Document to start navigating from\n     * @param path\n     *            is a simple path expression, seperated by '/' which denotes\n     *            the path from the source to the resulting element such as\n     *            a/b/c\n     * \n     * @return the first Element on the given path which either already existed\n     *         on the path or were created by this method.\n     */",
        "code_after_change": "/**\n     * <p>\n     * makeElement\n     * </p>\n     * a helper method which navigates from the given Document or Element node\n     * to some Element using the path expression, creating any necessary\n     * elements along the way. For example the path <code>a/b/c</code> would\n     * get the first child &lt;a&gt; element, which would be created if it did\n     * not exist, then the next child &lt;b&gt; and so on until finally a\n     * &lt;c&gt; element is returned.\n     *\n     * @param source\n     *            is the Element or Document to start navigating from\n     * @param path\n     *            is a simple path expression, seperated by '/' which denotes\n     *            the path from the source to the resulting element such as\n     *            a/b/c\n     *\n     * @return the first Element on the given path which either already existed\n     *         on the path or were created by this method.\n     */",
        "patch": "@@ -107,12 +107,12 @@ public static QName createQName(String localName) {\n      * XPath <code>XPath</code> instance using the singleton {@link\n      * DocumentFactory}.\n      * </p>\n-     * \n+     *\n      * @param xpathExpression\n      *            is the XPath expression to create\n-     * \n+     *\n      * @return a new <code>XPath</code> instance\n-     * \n+     *\n      * @throws InvalidXPathException\n      *             if the XPath expression is invalid\n      */\n@@ -127,14 +127,14 @@ public static XPath createXPath(String xpathExpression)\n      * XPath <code>XPath</code> instance using the singleton {@link\n      * DocumentFactory}.\n      * </p>\n-     * \n+     *\n      * @param xpathExpression\n      *            is the XPath expression to create\n      * @param context\n      *            is the variable context to use when evaluating the XPath\n-     * \n+     *\n      * @return a new <code>XPath</code> instance\n-     * \n+     *\n      * @throws InvalidXPathException\n      *             if the XPath expression is invalid\n      */\n@@ -150,10 +150,10 @@ public static XPath createXPath(String xpathExpression,\n      * filter expressions occur within XPath expressions such as\n      * <code>self::node()[ filterExpression ]</code>\n      * </p>\n-     * \n+     *\n      * @param xpathFilterExpression\n      *            is the XPath filter expression to create\n-     * \n+     *\n      * @return a new <code>NodeFilter</code> instance\n      */\n     public static NodeFilter createXPathFilter(String xpathFilterExpression) {\n@@ -166,10 +166,10 @@ public static NodeFilter createXPathFilter(String xpathFilterExpression) {\n      * an XSLT style {@link Pattern}instance which can then be used in an XSLT\n      * processing model.\n      * </p>\n-     * \n+     *\n      * @param xpathPattern\n      *            is the XPath pattern expression to create\n-     * \n+     *\n      * @return a new <code>Pattern</code> instance\n      */\n     public static Pattern createPattern(String xpathPattern) {\n@@ -182,12 +182,12 @@ public static Pattern createPattern(String xpathPattern) {\n      * {@link List}of {@link Node}instances appending all the results together\n      * into a single list.\n      * </p>\n-     * \n+     *\n      * @param xpathFilterExpression\n      *            is the XPath filter expression to evaluate\n      * @param nodes\n      *            is the list of nodes on which to evalute the XPath\n-     * \n+     *\n      * @return the results of all the XPath evaluations as a single list\n      */\n     public static List<Node> selectNodes(String xpathFilterExpression, List<Node> nodes) {\n@@ -202,12 +202,12 @@ public static List<Node> selectNodes(String xpathFilterExpression, List<Node> no\n      * {@link List}of {@link Node}instances appending all the results together\n      * into a single list.\n      * </p>\n-     * \n+     *\n      * @param xpathFilterExpression\n      *            is the XPath filter expression to evaluate\n      * @param node\n      *            is the Node on which to evalute the XPath\n-     * \n+     *\n      * @return the results of all the XPath evaluations as a single list\n      */\n     public static List<Node> selectNodes(String xpathFilterExpression, Node node) {\n@@ -221,7 +221,7 @@ public static List<Node> selectNodes(String xpathFilterExpression, Node node) {\n      * <code>sort</code> sorts the given List of Nodes using an XPath\n      * expression as a {@link java.util.Comparator}.\n      * </p>\n-     * \n+     *\n      * @param list\n      *            is the list of Nodes to sort\n      * @param xpathExpression\n@@ -238,7 +238,7 @@ public static void sort(List<Node> list, String xpathExpression) {\n      * expression as a {@link java.util.Comparator}and optionally removing\n      * duplicates.\n      * </p>\n-     * \n+     *\n      * @param list\n      *            is the list of Nodes to sort\n      * @param expression\n@@ -259,24 +259,17 @@ public static void sort(List<Node> list, String expression, boolean distinct) {\n      * </p>\n      *\n      * Loading external DTD and entities is disabled (if it is possible) for security reasons.\n-     * \n+     *\n      * @param text\n      *            the XML text to be parsed\n-     * \n+     *\n      * @return a newly parsed Document\n-     * \n+     *\n      * @throws DocumentException\n      *             if the document could not be parsed\n      */\n     public static Document parseText(String text) throws DocumentException {\n-        SAXReader reader = new SAXReader();\n-        try {\n-            reader.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n-            reader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n-            reader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n-        } catch (SAXException e) {\n-            //Parse with external resources downloading allowed.\n-        }\n+        SAXReader reader = SAXReader.createDefault();\n \n         String encoding = getEncoding(text);\n \n@@ -330,14 +323,14 @@ private static String getEncoding(String text) {\n      * get the first child &lt;a&gt; element, which would be created if it did\n      * not exist, then the next child &lt;b&gt; and so on until finally a\n      * &lt;c&gt; element is returned.\n-     * \n+     *\n      * @param source\n      *            is the Element or Document to start navigating from\n      * @param path\n      *            is a simple path expression, seperated by '/' which denotes\n      *            the path from the source to the resulting element such as\n      *            a/b/c\n-     * \n+     *\n      * @return the first Element on the given path which either already existed\n      *         on the path or were created by this method.\n      */\n@@ -386,24 +379,24 @@ public static Element makeElement(Branch source, String path) {\n  * Redistribution and use of this software and associated documentation\n  * (\"Software\"), with or without modification, are permitted provided that the\n  * following conditions are met:\n- * \n+ *\n  * 1. Redistributions of source code must retain copyright statements and\n  * notices. Redistributions must also contain a copy of this document.\n- * \n+ *\n  * 2. Redistributions in binary form must reproduce the above copyright notice,\n  * this list of conditions and the following disclaimer in the documentation\n  * and/or other materials provided with the distribution.\n- * \n+ *\n  * 3. The name \"DOM4J\" must not be used to endorse or promote products derived\n  * from this Software without prior written permission of MetaStuff, Ltd. For\n  * written permission, please contact dom4j-info@metastuff.com.\n- * \n+ *\n  * 4. Products derived from this Software may not be called \"DOM4J\" nor may\n  * \"DOM4J\" appear in their names without prior written permission of MetaStuff,\n  * Ltd. DOM4J is a registered trademark of MetaStuff, Ltd.\n- * \n+ *\n  * 5. Due credit should be given to the DOM4J Project - http://www.dom4j.org\n- * \n+ *\n  * THIS SOFTWARE IS PROVIDED BY METASTUFF, LTD. AND CONTRIBUTORS ``AS IS'' AND\n  * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n@@ -415,6 +408,6 @@ public static Element makeElement(Branch source, String path) {\n  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n  * POSSIBILITY OF SUCH DAMAGE.\n- * \n+ *\n  * Copyright 2001-2005 (C) MetaStuff, Ltd. All Rights Reserved.\n  */",
        "function_modified_lines": {
            "added": [
                "     *\n",
                "     *\n"
            ],
            "deleted": [
                "     * \n",
                "     * \n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-611"
        ],
        "cve_description": "dom4j before 2.0.3 and 2.1.x before 2.1.3 allows external DTDs and External Entities by default, which might enable XXE attacks. However, there is popular external documentation from OWASP showing how to enable the safe, non-default behavior in any application that uses dom4j.",
        "id": 12084
    },
    {
        "cve_id": "CVE-2020-10683",
        "code_before_change": "/**\n * <code>SAXReader</code> creates a DOM4J tree from SAX parsing events.\n *\n * The actual SAX parser that is used by this class is configurable so you can\n * use your favourite SAX parser if you wish. DOM4J comes configured with its\n * own SAX parser so you do not need to worry about configuring the SAX parser.\n *\n * To explicitly configure the SAX parser that is used via Java code you can use\n * a constructor or use the {@link #setXMLReader(XMLReader)}or {@link\n * #setXMLReaderClassName(String)} methods.\n *\n * If the parser is not specified explicitly then the standard SAX policy of\n * using the <code>org.xml.sax.driver</code> system property is used to\n * determine the implementation class of {@link XMLReader}.\n *\n * If the <code>org.xml.sax.driver</code> system property is not defined then\n * JAXP is used via reflection (so that DOM4J is not explicitly dependent on the\n * JAXP classes) to load the JAXP configured SAXParser. If there is any error\n * creating a JAXP SAXParser an informational message is output and then the\n * default (Aelfred) SAX parser is used instead.\n *\n * If you are trying to use JAXP to explicitly set your SAX parser and are\n * experiencing problems, you can turn on verbose error reporting by defining\n * the system property <code>org.dom4j.verbose</code> to be \"true\" which will\n * output a more detailed description of why JAXP could not find a SAX parser\n *\n * For more information on JAXP please go to <a\n * href=\"http://java.sun.com/xml/\">Sun's Java &amp; XML site </a>\n *\n * @author <a href=\"mailto:james.strachan@metastuff.com\">James Strachan </a>\n * @version $Revision: 1.58 $\n */",
        "code_after_change": "/*\n * Copyright 2001-2005 (C) MetaStuff, Ltd. All Rights Reserved.\n *\n * This software is open source.\n * See the bottom of this file for the licence.\n */\n\npackage org.dom4j.io;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.InputStream;\nimport java.io.Reader;\nimport java.io.Serializable;\nimport java.net.URL;\n\nimport org.dom4j.Document;\nimport org.dom4j.DocumentException;\nimport org.dom4j.DocumentFactory;\nimport org.dom4j.ElementHandler;\n\nimport org.xml.sax.EntityResolver;\nimport org.xml.sax.ErrorHandler;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.SAXParseException;\nimport org.xml.sax.XMLFilter;\nimport org.xml.sax.XMLReader;\nimport org.xml.sax.helpers.DefaultHandler;\nimport org.xml.sax.helpers.XMLReaderFactory;\n\nimport javax.xml.parsers.SAXParserFactory;\n\n/**\n * <code>SAXReader</code> creates a DOM4J tree from SAX parsing events.\n * <p>\n * The actual SAX parser that is used by this class is configurable so you can\n * use your favourite SAX parser if you wish. DOM4J comes configured with its\n * own SAX parser so you do not need to worry about configuring the SAX parser.\n * <p>\n * To explicitly configure the SAX parser that is used via Java code you can use\n * a constructor or use the {@link #setXMLReader(XMLReader)}or {@link\n * #setXMLReaderClassName(String)} methods.\n * <p>\n * If the parser is not specified explicitly then the standard SAX policy of\n * using the <code>org.xml.sax.driver</code> system property is used to\n * determine the implementation class of {@link XMLReader}.\n * <p>\n * If the <code>org.xml.sax.driver</code> system property is not defined then\n * JAXP is used via reflection (so that DOM4J is not explicitly dependent on the\n * JAXP classes) to load the JAXP configured SAXParser. If there is any error\n * creating a JAXP SAXParser an informational message is output and then the\n * default (Aelfred) SAX parser is used instead.\n * <p>\n * If you are trying to use JAXP to explicitly set your SAX parser and are\n * experiencing problems, you can turn on verbose error reporting by defining\n * the system property <code>org.dom4j.verbose</code> to be \"true\" which will\n * output a more detailed description of why JAXP could not find a SAX parser\n * <p>\n * For more information on JAXP please go to <a\n * href=\"http://java.sun.com/xml/\">Sun's Java &amp; XML site </a>\n *\n * @author <a href=\"mailto:james.strachan@metastuff.com\">James Strachan </a>\n * @version $Revision: 1.58 $\n */\npublic class SAXReader {\n  private static final String SAX_STRING_INTERNING =\n          \"http://xml.org/sax/features/string-interning\";\n  private static final String SAX_DECL_HANDLER =\n          \"http://xml.org/sax/properties/declaration-handler\";\n  private static final String SAX_LEXICAL_HANDLER =\n          \"http://xml.org/sax/properties/lexical-handler\";\n  private static final String SAX_LEXICALHANDLER =\n          \"http://xml.org/sax/handlers/LexicalHandler\";\n\n  /**\n   * <code>DocumentFactory</code> used to create new document objects\n   */\n  private DocumentFactory factory;\n\n  /**\n   * <code>XMLReader</code> used to parse the SAX events\n   */\n  private XMLReader xmlReader;\n\n  /**\n   * Whether validation should occur\n   */\n  private boolean validating;\n\n  /**\n   * DispatchHandler to call when each <code>Element</code> is encountered\n   */\n  private DispatchHandler dispatchHandler;\n",
        "patch": "@@ -30,965 +30,981 @@\n import org.xml.sax.helpers.DefaultHandler;\n import org.xml.sax.helpers.XMLReaderFactory;\n \n+import javax.xml.parsers.SAXParserFactory;\n+\n /**\n  * <code>SAXReader</code> creates a DOM4J tree from SAX parsing events.\n- *\n+ * <p>\n  * The actual SAX parser that is used by this class is configurable so you can\n  * use your favourite SAX parser if you wish. DOM4J comes configured with its\n  * own SAX parser so you do not need to worry about configuring the SAX parser.\n- *\n+ * <p>\n  * To explicitly configure the SAX parser that is used via Java code you can use\n  * a constructor or use the {@link #setXMLReader(XMLReader)}or {@link\n  * #setXMLReaderClassName(String)} methods.\n- *\n+ * <p>\n  * If the parser is not specified explicitly then the standard SAX policy of\n  * using the <code>org.xml.sax.driver</code> system property is used to\n  * determine the implementation class of {@link XMLReader}.\n- *\n+ * <p>\n  * If the <code>org.xml.sax.driver</code> system property is not defined then\n  * JAXP is used via reflection (so that DOM4J is not explicitly dependent on the\n  * JAXP classes) to load the JAXP configured SAXParser. If there is any error\n  * creating a JAXP SAXParser an informational message is output and then the\n  * default (Aelfred) SAX parser is used instead.\n- *\n+ * <p>\n  * If you are trying to use JAXP to explicitly set your SAX parser and are\n  * experiencing problems, you can turn on verbose error reporting by defining\n  * the system property <code>org.dom4j.verbose</code> to be \"true\" which will\n  * output a more detailed description of why JAXP could not find a SAX parser\n- *\n+ * <p>\n  * For more information on JAXP please go to <a\n  * href=\"http://java.sun.com/xml/\">Sun's Java &amp; XML site </a>\n  *\n  * @author <a href=\"mailto:james.strachan@metastuff.com\">James Strachan </a>\n  * @version $Revision: 1.58 $\n  */\n public class SAXReader {\n-    private static final String SAX_STRING_INTERNING = \n-            \"http://xml.org/sax/features/string-interning\";\n-    private static final String SAX_DECL_HANDLER =\n-            \"http://xml.org/sax/properties/declaration-handler\";\n-    private static final String SAX_LEXICAL_HANDLER = \n-            \"http://xml.org/sax/properties/lexical-handler\";\n-    private static final String SAX_LEXICALHANDLER = \n-            \"http://xml.org/sax/handlers/LexicalHandler\";\n-\n-    /** <code>DocumentFactory</code> used to create new document objects */\n-    private DocumentFactory factory;\n-\n-    /** <code>XMLReader</code> used to parse the SAX events */\n-    private XMLReader xmlReader;\n-\n-    /** Whether validation should occur */\n-    private boolean validating;\n-\n-    /** DispatchHandler to call when each <code>Element</code> is encountered */\n-    private DispatchHandler dispatchHandler;\n-\n-    /** ErrorHandler class to use */\n-    private ErrorHandler errorHandler;\n-\n-    /** The entity resolver */\n-    private EntityResolver entityResolver;\n-\n-    /** Should element & attribute names and namespace URIs be interned? */\n-    private boolean stringInternEnabled = true;\n-\n-    /** Should internal DTD declarations be expanded into a List in the DTD */\n-    private boolean includeInternalDTDDeclarations = false;\n-\n-    /** Should external DTD declarations be expanded into a List in the DTD */\n-    private boolean includeExternalDTDDeclarations = false;\n-\n-    /** Whether adjacent text nodes should be merged */\n-    private boolean mergeAdjacentText = false;\n-\n-    /** Holds value of property stripWhitespaceText. */\n-    private boolean stripWhitespaceText = false;\n-\n-    /** Should we ignore comments */\n-    private boolean ignoreComments = false;\n-\n-    /** Encoding of InputSource - null means system default encoding */\n-    private String encoding = null;\n-\n-    // private boolean includeExternalGeneralEntities = false;\n-    // private boolean includeExternalParameterEntities = false;\n-\n-    /** The SAX filter used to filter SAX events */\n-    private XMLFilter xmlFilter;\n-\n-    public SAXReader() {\n-    }\n-\n-    public SAXReader(boolean validating) {\n-        this.validating = validating;\n-    }\n-\n-    public SAXReader(DocumentFactory factory) {\n-        this.factory = factory;\n-    }\n-\n-    public SAXReader(DocumentFactory factory, boolean validating) {\n-        this.factory = factory;\n-        this.validating = validating;\n-    }\n-\n-    public SAXReader(XMLReader xmlReader) {\n-        this.xmlReader = xmlReader;\n-    }\n-\n-    public SAXReader(XMLReader xmlReader, boolean validating) {\n-        this.xmlReader = xmlReader;\n-        this.validating = validating;\n-    }\n-\n-    public SAXReader(String xmlReaderClassName) throws SAXException {\n-        if (xmlReaderClassName != null) {\n-            this.xmlReader = XMLReaderFactory\n-                    .createXMLReader(xmlReaderClassName);\n+  private static final String SAX_STRING_INTERNING =\n+          \"http://xml.org/sax/features/string-interning\";\n+  private static final String SAX_DECL_HANDLER =\n+          \"http://xml.org/sax/properties/declaration-handler\";\n+  private static final String SAX_LEXICAL_HANDLER =\n+          \"http://xml.org/sax/properties/lexical-handler\";\n+  private static final String SAX_LEXICALHANDLER =\n+          \"http://xml.org/sax/handlers/LexicalHandler\";\n+\n+  /**\n+   * <code>DocumentFactory</code> used to create new document objects\n+   */\n+  private DocumentFactory factory;\n+\n+  /**\n+   * <code>XMLReader</code> used to parse the SAX events\n+   */\n+  private XMLReader xmlReader;\n+\n+  /**\n+   * Whether validation should occur\n+   */\n+  private boolean validating;\n+\n+  /**\n+   * DispatchHandler to call when each <code>Element</code> is encountered\n+   */\n+  private DispatchHandler dispatchHandler;\n+\n+  /**\n+   * ErrorHandler class to use\n+   */\n+  private ErrorHandler errorHandler;\n+\n+  /**\n+   * The entity resolver\n+   */\n+  private EntityResolver entityResolver;\n+\n+  /**\n+   * Should element & attribute names and namespace URIs be interned?\n+   */\n+  private boolean stringInternEnabled = true;\n+\n+  /**\n+   * Should internal DTD declarations be expanded into a List in the DTD\n+   */\n+  private boolean includeInternalDTDDeclarations = false;\n+\n+  /**\n+   * Should external DTD declarations be expanded into a List in the DTD\n+   */\n+  private boolean includeExternalDTDDeclarations = false;\n+\n+  /**\n+   * Whether adjacent text nodes should be merged\n+   */\n+  private boolean mergeAdjacentText = false;\n+\n+  /**\n+   * Holds value of property stripWhitespaceText.\n+   */\n+  private boolean stripWhitespaceText = false;\n+\n+  /**\n+   * Should we ignore comments\n+   */\n+  private boolean ignoreComments = false;\n+\n+  /**\n+   * Encoding of InputSource - null means system default encoding\n+   */\n+  private String encoding = null;\n+\n+  // private boolean includeExternalGeneralEntities = false;\n+  // private boolean includeExternalParameterEntities = false;\n+\n+  /**\n+   * The SAX filter used to filter SAX events\n+   *\n+   * @since 2.1.2\n+   */\n+  private XMLFilter xmlFilter;\n+\n+  public static SAXReader createDefault() {\n+    SAXReader reader = new SAXReader();\n+    try {\n+      reader.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n+      reader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n+      reader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n+    } catch (SAXException e) {\n+      // nothing to do, incompatible reader\n+    }\n+    return reader;\n+  }\n+\n+  /**\n+   * This method internally calls {@link SAXParserFactory}{@code .newInstance().newSAXParser().getXMLReader()} or {@link XMLReaderFactory#createXMLReader()}.\n+   * Be sure to configure returned reader if the default configuration does not suit you. Consider setting the following properties:\n+   *\n+   * <pre>\n+   * reader.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n+   * reader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n+   * reader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n+   * </pre>\n+   */\n+  public SAXReader() {\n+  }\n+\n+  /**\n+   * This method internally calls {@link SAXParserFactory}{@code .newInstance().newSAXParser().getXMLReader()} or {@link XMLReaderFactory#createXMLReader()}.\n+   * Be sure to configure returned reader if the default configuration does not suit you. Consider setting the following properties:\n+   *\n+   * <pre>\n+   * reader.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n+   * reader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n+   * reader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n+   * </pre>\n+   *\n+   * @param validating\n+   */\n+  public SAXReader(boolean validating) {\n+    this.validating = validating;\n+  }\n+\n+  /**\n+   * This method internally calls {@link SAXParserFactory}{@code .newInstance().newSAXParser().getXMLReader()} or {@link XMLReaderFactory#createXMLReader()}.\n+   * Be sure to configure returned reader if the default configuration does not suit you. Consider setting the following properties:\n+   *\n+   * <pre>\n+   * reader.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n+   * reader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n+   * reader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n+   * </pre>\n+   *\n+   * @param factory\n+   */\n+  public SAXReader(DocumentFactory factory) {\n+    this.factory = factory;\n+  }\n+\n+  /**\n+   * This method internally calls {@link SAXParserFactory}{@code .newInstance().newSAXParser().getXMLReader()} or {@link XMLReaderFactory#createXMLReader()}.\n+   * Be sure to configure returned reader if the default configuration does not suit you. Consider setting the following properties:\n+   *\n+   * <pre>\n+   * reader.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n+   * reader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n+   * reader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n+   * </pre>\n+   *\n+   * @param factory\n+   * @param validating\n+   */\n+  public SAXReader(DocumentFactory factory, boolean validating) {\n+    this.factory = factory;\n+    this.validating = validating;\n+  }\n+\n+  public SAXReader(XMLReader xmlReader) {\n+    this.xmlReader = xmlReader;\n+  }\n+\n+  public SAXReader(XMLReader xmlReader, boolean validating) {\n+    this.xmlReader = xmlReader;\n+    this.validating = validating;\n+  }\n+\n+  public SAXReader(String xmlReaderClassName) throws SAXException {\n+    if (xmlReaderClassName != null) {\n+      this.xmlReader = XMLReaderFactory\n+              .createXMLReader(xmlReaderClassName);\n+    }\n+  }\n+\n+  public SAXReader(String xmlReaderClassName, boolean validating)\n+          throws SAXException {\n+    if (xmlReaderClassName != null) {\n+      this.xmlReader = XMLReaderFactory\n+              .createXMLReader(xmlReaderClassName);\n+    }\n+\n+    this.validating = validating;\n+  }\n+\n+  /**\n+   * Allows a SAX property to be set on the underlying SAX parser. This can be\n+   * useful to set parser-specific properties such as the location of schema\n+   * or DTD resources. Though use this method with caution as it has the\n+   * possibility of breaking the standard behaviour. An alternative to calling\n+   * this method is to correctly configure an XMLReader object instance and\n+   * call the {@link #setXMLReader(XMLReader)}method\n+   *\n+   * @param name  is the SAX property name\n+   * @param value is the value of the SAX property\n+   * @throws SAXException if the XMLReader could not be created or the property could\n+   *                      not be changed.\n+   */\n+  public void setProperty(String name, Object value) throws SAXException {\n+    getXMLReader().setProperty(name, value);\n+  }\n+\n+  /**\n+   * Sets a SAX feature on the underlying SAX parser. This can be useful to\n+   * set parser-specific features. Though use this method with caution as it\n+   * has the possibility of breaking the standard behaviour. An alternative to\n+   * calling this method is to correctly configure an XMLReader object\n+   * instance and call the {@link #setXMLReader(XMLReader)}method\n+   *\n+   * @param name  is the SAX feature name\n+   * @param value is the value of the SAX feature\n+   * @throws SAXException if the XMLReader could not be created or the feature could\n+   *                      not be changed.\n+   */\n+  public void setFeature(String name, boolean value) throws SAXException {\n+    getXMLReader().setFeature(name, value);\n+  }\n+\n+  /**\n+   * <p>\n+   * Reads a Document from the given <code>File</code>\n+   * </p>\n+   *\n+   * @param file is the <code>File</code> to read from.\n+   * @return the newly created Document instance\n+   * @throws DocumentException if an error occurs during parsing.\n+   */\n+  public Document read(File file) throws DocumentException {\n+    try {\n+      /*\n+       * We cannot convert the file to an URL because if the filename\n+       * contains '#' characters, there will be problems with the URL in\n+       * the InputSource (because a URL like\n+       * http://myhost.com/index#anchor is treated the same as\n+       * http://myhost.com/index) Thanks to Christian Oetterli\n+       */\n+      InputSource source = new InputSource(new FileInputStream(file));\n+      if (this.encoding != null) {\n+        source.setEncoding(this.encoding);\n+      }\n+      String path = file.getAbsolutePath();\n+\n+      if (path != null) {\n+        // Code taken from Ant FileUtils\n+        StringBuffer sb = new StringBuffer(\"file://\");\n+\n+        // add an extra slash for filesystems with drive-specifiers\n+        if (!path.startsWith(File.separator)) {\n+          sb.append(\"/\");\n         }\n-    }\n \n-    public SAXReader(String xmlReaderClassName, boolean validating)\n-            throws SAXException {\n-        if (xmlReaderClassName != null) {\n-            this.xmlReader = XMLReaderFactory\n-                    .createXMLReader(xmlReaderClassName);\n+        path = path.replace('\\\\', '/');\n+        sb.append(path);\n+\n+        source.setSystemId(sb.toString());\n+      }\n+\n+      return read(source);\n+    } catch (FileNotFoundException e) {\n+      throw new DocumentException(e.getMessage(), e);\n+    }\n+  }\n+\n+  /**\n+   * <p>\n+   * Reads a Document from the given <code>URL</code> using SAX\n+   * </p>\n+   *\n+   * @param url <code>URL</code> to read from.\n+   * @return the newly created Document instance\n+   * @throws DocumentException if an error occurs during parsing.\n+   */\n+  public Document read(URL url) throws DocumentException {\n+    String systemID = url.toExternalForm();\n+\n+    InputSource source = new InputSource(systemID);\n+    if (this.encoding != null) {\n+      source.setEncoding(this.encoding);\n+    }\n+\n+    return read(source);\n+  }\n+\n+  /**\n+   * <p>\n+   * Reads a Document from the given URL or filename using SAX.\n+   * </p>\n+   *\n+   * <p>\n+   * If the systemId contains a <code>':'</code> character then it is\n+   * assumed to be a URL otherwise its assumed to be a file name. If you want\n+   * finer grained control over this mechansim then please explicitly pass in\n+   * either a {@link URL}or a {@link File}instance instead of a {@link\n+   * String} to denote the source of the document.\n+   * </p>\n+   *\n+   * @param systemId is a URL for a document or a file name.\n+   * @return the newly created Document instance\n+   * @throws DocumentException if an error occurs during parsing.\n+   */\n+  public Document read(String systemId) throws DocumentException {\n+    InputSource source = new InputSource(systemId);\n+    if (this.encoding != null) {\n+      source.setEncoding(this.encoding);\n+    }\n+\n+    return read(source);\n+  }\n+\n+  /**\n+   * <p>\n+   * Reads a Document from the given stream using SAX\n+   * </p>\n+   *\n+   * @param in <code>InputStream</code> to read from.\n+   * @return the newly created Document instance\n+   * @throws DocumentException if an error occurs during parsing.\n+   */\n+  public Document read(InputStream in) throws DocumentException {\n+    InputSource source = new InputSource(in);\n+    if (this.encoding != null) {\n+      source.setEncoding(this.encoding);\n+    }\n+\n+    return read(source);\n+  }\n+\n+  /**\n+   * Reads a Document from the given <code>Reader</code> using SAX\n+   *\n+   * @param reader is the reader for the input\n+   * @return the newly created Document instance\n+   * @throws DocumentException if an error occurs during parsing.\n+   */\n+  public Document read(Reader reader) throws DocumentException {\n+    InputSource source = new InputSource(reader);\n+    if (this.encoding != null) {\n+      source.setEncoding(this.encoding);\n+    }\n+\n+    return read(source);\n+  }\n+\n+  /**\n+   * <p>\n+   * Reads a Document from the given stream using SAX\n+   * </p>\n+   *\n+   * @param in       <code>InputStream</code> to read from.\n+   * @param systemId is the URI for the input\n+   * @return the newly created Document instance\n+   * @throws DocumentException if an error occurs during parsing.\n+   */\n+  public Document read(InputStream in, String systemId)\n+          throws DocumentException {\n+    InputSource source = new InputSource(in);\n+    source.setSystemId(systemId);\n+    if (this.encoding != null) {\n+      source.setEncoding(this.encoding);\n+    }\n+\n+    return read(source);\n+  }\n+\n+  /**\n+   * <p>\n+   * Reads a Document from the given <code>Reader</code> using SAX\n+   * </p>\n+   *\n+   * @param reader   is the reader for the input\n+   * @param systemId is the URI for the input\n+   * @return the newly created Document instance\n+   * @throws DocumentException if an error occurs during parsing.\n+   */\n+  public Document read(Reader reader, String systemId)\n+          throws DocumentException {\n+    InputSource source = new InputSource(reader);\n+    source.setSystemId(systemId);\n+    if (this.encoding != null) {\n+      source.setEncoding(this.encoding);\n+    }\n+\n+    return read(source);\n+  }\n+\n+  /**\n+   * <p>\n+   * Reads a Document from the given <code>InputSource</code> using SAX\n+   * </p>\n+   *\n+   * @param in <code>InputSource</code> to read from.\n+   * @return the newly created Document instance\n+   * @throws DocumentException if an error occurs during parsing.\n+   */\n+  public Document read(InputSource in) throws DocumentException {\n+    try {\n+      XMLReader reader = getXMLReader();\n+\n+      reader = installXMLFilter(reader);\n+\n+      EntityResolver thatEntityResolver = this.entityResolver;\n+\n+      if (thatEntityResolver == null) {\n+        thatEntityResolver = createDefaultEntityResolver(in\n+                .getSystemId());\n+        this.entityResolver = thatEntityResolver;\n+      }\n+\n+      reader.setEntityResolver(thatEntityResolver);\n+\n+      SAXContentHandler contentHandler = createContentHandler(reader);\n+      contentHandler.setEntityResolver(thatEntityResolver);\n+      contentHandler.setInputSource(in);\n+\n+      boolean internal = isIncludeInternalDTDDeclarations();\n+      boolean external = isIncludeExternalDTDDeclarations();\n+\n+      contentHandler.setIncludeInternalDTDDeclarations(internal);\n+      contentHandler.setIncludeExternalDTDDeclarations(external);\n+      contentHandler.setMergeAdjacentText(isMergeAdjacentText());\n+      contentHandler.setStripWhitespaceText(isStripWhitespaceText());\n+      contentHandler.setIgnoreComments(isIgnoreComments());\n+      reader.setContentHandler(contentHandler);\n+\n+      configureReader(reader, contentHandler);\n+\n+      reader.parse(in);\n+\n+      return contentHandler.getDocument();\n+    } catch (Exception e) {\n+      if (e instanceof SAXParseException) {\n+        // e.printStackTrace();\n+        SAXParseException parseException = (SAXParseException) e;\n+        String systemId = parseException.getSystemId();\n+\n+        if (systemId == null) {\n+          systemId = \"\";\n         }\n \n-        this.validating = validating;\n-    }\n-\n-    /**\n-     * Allows a SAX property to be set on the underlying SAX parser. This can be\n-     * useful to set parser-specific properties such as the location of schema\n-     * or DTD resources. Though use this method with caution as it has the\n-     * possibility of breaking the standard behaviour. An alternative to calling\n-     * this method is to correctly configure an XMLReader object instance and\n-     * call the {@link #setXMLReader(XMLReader)}method\n-     * \n-     * @param name\n-     *            is the SAX property name\n-     * @param value\n-     *            is the value of the SAX property\n-     * \n-     * @throws SAXException\n-     *             if the XMLReader could not be created or the property could\n-     *             not be changed.\n-     */\n-    public void setProperty(String name, Object value) throws SAXException {\n-        getXMLReader().setProperty(name, value);\n-    }\n-\n-    /**\n-     * Sets a SAX feature on the underlying SAX parser. This can be useful to\n-     * set parser-specific features. Though use this method with caution as it\n-     * has the possibility of breaking the standard behaviour. An alternative to\n-     * calling this method is to correctly configure an XMLReader object\n-     * instance and call the {@link #setXMLReader(XMLReader)}method\n-     * \n-     * @param name\n-     *            is the SAX feature name\n-     * @param value\n-     *            is the value of the SAX feature\n-     * \n-     * @throws SAXException\n-     *             if the XMLReader could not be created or the feature could\n-     *             not be changed.\n-     */\n-    public void setFeature(String name, boolean value) throws SAXException {\n-        getXMLReader().setFeature(name, value);\n-    }\n-\n-    /**\n-     * <p>\n-     * Reads a Document from the given <code>File</code>\n-     * </p>\n-     * \n-     * @param file\n-     *            is the <code>File</code> to read from.\n-     * \n-     * @return the newly created Document instance\n-     * \n-     * @throws DocumentException\n-     *             if an error occurs during parsing.\n-     */\n-    public Document read(File file) throws DocumentException {\n-        try {\n-            /*\n-             * We cannot convert the file to an URL because if the filename\n-             * contains '#' characters, there will be problems with the URL in\n-             * the InputSource (because a URL like\n-             * http://myhost.com/index#anchor is treated the same as\n-             * http://myhost.com/index) Thanks to Christian Oetterli\n-             */\n-            InputSource source = new InputSource(new FileInputStream(file));\n-            if (this.encoding != null) {\n-                source.setEncoding(this.encoding);\n-            }\n-            String path = file.getAbsolutePath();\n-\n-            if (path != null) {\n-                // Code taken from Ant FileUtils\n-                StringBuffer sb = new StringBuffer(\"file://\");\n-\n-                // add an extra slash for filesystems with drive-specifiers\n-                if (!path.startsWith(File.separator)) {\n-                    sb.append(\"/\");\n-                }\n-\n-                path = path.replace('\\\\', '/');\n-                sb.append(path);\n-\n-                source.setSystemId(sb.toString());\n-            }\n-\n-            return read(source);\n-        } catch (FileNotFoundException e) {\n-            throw new DocumentException(e.getMessage(), e);\n+        String message = \"Error on line \"\n+                + parseException.getLineNumber() + \" of document \"\n+                + systemId + \" : \" + parseException.getMessage();\n+\n+        throw new DocumentException(message, e);\n+      } else {\n+        throw new DocumentException(e.getMessage(), e);\n+      }\n+    }\n+  }\n+\n+  // Properties\n+  // -------------------------------------------------------------------------\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return the validation mode, true if validating will be done otherwise\n+   * false.\n+   */\n+  public boolean isValidating() {\n+    return validating;\n+  }\n+\n+  /**\n+   * Sets the validation mode.\n+   *\n+   * @param validation indicates whether or not validation should occur.\n+   */\n+  public void setValidation(boolean validation) {\n+    this.validating = validation;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return whether internal DTD declarations should be expanded into the\n+   * DocumentType object or not.\n+   */\n+  public boolean isIncludeInternalDTDDeclarations() {\n+    return includeInternalDTDDeclarations;\n+  }\n+\n+  /**\n+   * Sets whether internal DTD declarations should be expanded into the\n+   * DocumentType object or not.\n+   *\n+   * @param include whether or not DTD declarations should be expanded and\n+   *                included into the DocumentType object.\n+   */\n+  public void setIncludeInternalDTDDeclarations(boolean include) {\n+    this.includeInternalDTDDeclarations = include;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return whether external DTD declarations should be expanded into the\n+   * DocumentType object or not.\n+   */\n+  public boolean isIncludeExternalDTDDeclarations() {\n+    return includeExternalDTDDeclarations;\n+  }\n+\n+  /**\n+   * Sets whether DTD external declarations should be expanded into the\n+   * DocumentType object or not.\n+   *\n+   * @param include whether or not DTD declarations should be expanded and\n+   *                included into the DocumentType object.\n+   */\n+  public void setIncludeExternalDTDDeclarations(boolean include) {\n+    this.includeExternalDTDDeclarations = include;\n+  }\n+\n+  /**\n+   * Sets whether String interning is enabled or disabled for element &amp;\n+   * attribute names and namespace URIs. This proprety is enabled by default.\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public boolean isStringInternEnabled() {\n+    return stringInternEnabled;\n+  }\n+\n+  /**\n+   * Sets whether String interning is enabled or disabled for element &amp;\n+   * attribute names and namespace URIs\n+   *\n+   * @param stringInternEnabled DOCUMENT ME!\n+   */\n+  public void setStringInternEnabled(boolean stringInternEnabled) {\n+    this.stringInternEnabled = stringInternEnabled;\n+  }\n+\n+  /**\n+   * Returns whether adjacent text nodes should be merged together.\n+   *\n+   * @return Value of property mergeAdjacentText.\n+   */\n+  public boolean isMergeAdjacentText() {\n+    return mergeAdjacentText;\n+  }\n+\n+  /**\n+   * Sets whether or not adjacent text nodes should be merged together when\n+   * parsing.\n+   *\n+   * @param mergeAdjacentText New value of property mergeAdjacentText.\n+   */\n+  public void setMergeAdjacentText(boolean mergeAdjacentText) {\n+    this.mergeAdjacentText = mergeAdjacentText;\n+  }\n+\n+  /**\n+   * Sets whether whitespace between element start and end tags should be\n+   * ignored\n+   *\n+   * @return Value of property stripWhitespaceText.\n+   */\n+  public boolean isStripWhitespaceText() {\n+    return stripWhitespaceText;\n+  }\n+\n+  /**\n+   * Sets whether whitespace between element start and end tags should be\n+   * ignored.\n+   *\n+   * @param stripWhitespaceText New value of property stripWhitespaceText.\n+   */\n+  public void setStripWhitespaceText(boolean stripWhitespaceText) {\n+    this.stripWhitespaceText = stripWhitespaceText;\n+  }\n+\n+  /**\n+   * Returns whether we should ignore comments or not.\n+   *\n+   * @return boolean\n+   */\n+  public boolean isIgnoreComments() {\n+    return ignoreComments;\n+  }\n+\n+  /**\n+   * Sets whether we should ignore comments or not.\n+   *\n+   * @param ignoreComments whether we should ignore comments or not.\n+   */\n+  public void setIgnoreComments(boolean ignoreComments) {\n+    this.ignoreComments = ignoreComments;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return the <code>DocumentFactory</code> used to create document\n+   * objects\n+   */\n+  public DocumentFactory getDocumentFactory() {\n+    if (factory == null) {\n+      factory = DocumentFactory.getInstance();\n+    }\n+\n+    return factory;\n+  }\n+\n+  /**\n+   * <p>\n+   * This sets the <code>DocumentFactory</code> used to create new\n+   * documents. This method allows the building of custom DOM4J tree objects\n+   * to be implemented easily using a custom derivation of\n+   * {@link DocumentFactory}\n+   * </p>\n+   *\n+   * @param documentFactory <code>DocumentFactory</code> used to create DOM4J objects\n+   */\n+  public void setDocumentFactory(DocumentFactory documentFactory) {\n+    this.factory = documentFactory;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return the <code>ErrorHandler</code> used by SAX\n+   */\n+  public ErrorHandler getErrorHandler() {\n+    return errorHandler;\n+  }\n+\n+  /**\n+   * Sets the <code>ErrorHandler</code> used by the SAX\n+   * <code>XMLReader</code>.\n+   *\n+   * @param errorHandler is the <code>ErrorHandler</code> used by SAX\n+   */\n+  public void setErrorHandler(ErrorHandler errorHandler) {\n+    this.errorHandler = errorHandler;\n+  }\n+\n+  /**\n+   * Returns the current entity resolver used to resolve entities\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public EntityResolver getEntityResolver() {\n+    return entityResolver;\n+  }\n+\n+  /**\n+   * Sets the entity resolver used to resolve entities.\n+   *\n+   * @param entityResolver DOCUMENT ME!\n+   */\n+  public void setEntityResolver(EntityResolver entityResolver) {\n+    this.entityResolver = entityResolver;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return the <code>XMLReader</code> used to parse SAX events\n+   * @throws SAXException DOCUMENT ME!\n+   */\n+  public XMLReader getXMLReader() throws SAXException {\n+    if (xmlReader == null) {\n+      xmlReader = createXMLReader();\n+    }\n+\n+    return xmlReader;\n+  }\n+\n+  /**\n+   * Sets the <code>XMLReader</code> used to parse SAX events\n+   *\n+   * @param reader is the <code>XMLReader</code> to parse SAX events\n+   */\n+  public void setXMLReader(XMLReader reader) {\n+    this.xmlReader = reader;\n+  }\n+\n+  /**\n+   * Returns encoding used for InputSource (null means system default\n+   * encoding)\n+   *\n+   * @return encoding used for InputSource\n+   */\n+  public String getEncoding() {\n+    return encoding;\n+  }\n+\n+  /**\n+   * Sets encoding used for InputSource (null means system default encoding)\n+   *\n+   * @param encoding is encoding used for InputSource\n+   */\n+  public void setEncoding(String encoding) {\n+    this.encoding = encoding;\n+  }\n+\n+  /**\n+   * Sets the class name of the <code>XMLReader</code> to be used to parse\n+   * SAX events.\n+   *\n+   * @param xmlReaderClassName is the class name of the <code>XMLReader</code> to parse SAX\n+   *                           events\n+   * @throws SAXException DOCUMENT ME!\n+   */\n+  public void setXMLReaderClassName(String xmlReaderClassName)\n+          throws SAXException {\n+    setXMLReader(XMLReaderFactory.createXMLReader(xmlReaderClassName));\n+  }\n+\n+  /**\n+   * Adds the <code>ElementHandler</code> to be called when the specified\n+   * path is encounted.\n+   *\n+   * @param path    is the path to be handled\n+   * @param handler is the <code>ElementHandler</code> to be called by the event\n+   *                based processor.\n+   */\n+  public void addHandler(String path, ElementHandler handler) {\n+    getDispatchHandler().addHandler(path, handler);\n+  }\n+\n+  /**\n+   * Removes the <code>ElementHandler</code> from the event based processor,\n+   * for the specified path.\n+   *\n+   * @param path is the path to remove the <code>ElementHandler</code> for.\n+   */\n+  public void removeHandler(String path) {\n+    getDispatchHandler().removeHandler(path);\n+  }\n+\n+  /**\n+   * When multiple <code>ElementHandler</code> instances have been\n+   * registered, this will set a default <code>ElementHandler</code> to be\n+   * called for any path which does <b>NOT </b> have a handler registered.\n+   *\n+   * @param handler is the <code>ElementHandler</code> to be called by the event\n+   *                based processor.\n+   */\n+  public void setDefaultHandler(ElementHandler handler) {\n+    getDispatchHandler().setDefaultHandler(handler);\n+  }\n+\n+  /**\n+   * This method clears out all the existing handlers and default handler\n+   * setting things back as if no handler existed. Useful when reusing an\n+   * object instance.\n+   */\n+  public void resetHandlers() {\n+    getDispatchHandler().resetHandlers();\n+  }\n+\n+  /**\n+   * Returns the SAX filter being used to filter SAX events.\n+   *\n+   * @return the SAX filter being used or null if no SAX filter is installed\n+   */\n+  public XMLFilter getXMLFilter() {\n+    return xmlFilter;\n+  }\n+\n+  /**\n+   * Sets the SAX filter to be used when filtering SAX events\n+   *\n+   * @param filter is the SAX filter to use or null to disable filtering\n+   */\n+  public void setXMLFilter(XMLFilter filter) {\n+    this.xmlFilter = filter;\n+  }\n+\n+  // Implementation methods\n+  // -------------------------------------------------------------------------\n+\n+  /**\n+   * Installs any XMLFilter objects required to allow the SAX event stream to\n+   * be filtered and preprocessed before it gets to dom4j.\n+   *\n+   * @param reader DOCUMENT ME!\n+   * @return the new XMLFilter if applicable or the original XMLReader if no\n+   * filter is being used.\n+   */\n+  protected XMLReader installXMLFilter(XMLReader reader) {\n+    XMLFilter filter = getXMLFilter();\n+\n+    if (filter != null) {\n+      // find the root XMLFilter\n+      XMLFilter root = filter;\n+\n+      while (true) {\n+        XMLReader parent = root.getParent();\n+\n+        if (parent instanceof XMLFilter) {\n+          root = (XMLFilter) parent;\n+        } else {\n+          break;\n         }\n+      }\n+\n+      root.setParent(reader);\n+\n+      return filter;\n     }\n \n-    /**\n-     * <p>\n-     * Reads a Document from the given <code>URL</code> using SAX\n-     * </p>\n-     * \n-     * @param url\n-     *            <code>URL</code> to read from.\n-     * \n-     * @return the newly created Document instance\n-     * \n-     * @throws DocumentException\n-     *             if an error occurs during parsing.\n-     */\n-    public Document read(URL url) throws DocumentException {\n-        String systemID = url.toExternalForm();\n-\n-        InputSource source = new InputSource(systemID);\n-        if (this.encoding != null) {\n-            source.setEncoding(this.encoding);\n-        }\n+    return reader;\n+  }\n \n-        return read(source);\n-    }\n-\n-    /**\n-     * <p>\n-     * Reads a Document from the given URL or filename using SAX.\n-     * </p>\n-     * \n-     * <p>\n-     * If the systemId contains a <code>':'</code> character then it is\n-     * assumed to be a URL otherwise its assumed to be a file name. If you want\n-     * finer grained control over this mechansim then please explicitly pass in\n-     * either a {@link URL}or a {@link File}instance instead of a {@link\n-     * String} to denote the source of the document.\n-     * </p>\n-     * \n-     * @param systemId\n-     *            is a URL for a document or a file name.\n-     * \n-     * @return the newly created Document instance\n-     * \n-     * @throws DocumentException\n-     *             if an error occurs during parsing.\n-     */\n-    public Document read(String systemId) throws DocumentException {\n-        InputSource source = new InputSource(systemId);\n-        if (this.encoding != null) {\n-            source.setEncoding(this.encoding);\n-        }\n-\n-        return read(source);\n-    }\n-\n-    /**\n-     * <p>\n-     * Reads a Document from the given stream using SAX\n-     * </p>\n-     * \n-     * @param in\n-     *            <code>InputStream</code> to read from.\n-     * \n-     * @return the newly created Document instance\n-     * \n-     * @throws DocumentException\n-     *             if an error occurs during parsing.\n-     */\n-    public Document read(InputStream in) throws DocumentException {\n-        InputSource source = new InputSource(in);\n-        if (this.encoding != null) {\n-            source.setEncoding(this.encoding);\n-        }\n-\n-        return read(source);\n-    }\n-\n-    /**\n-     * Reads a Document from the given <code>Reader</code> using SAX\n-     *\n-     * @param reader\n-     *            is the reader for the input\n-     * \n-     * @return the newly created Document instance\n-     * \n-     * @throws DocumentException\n-     *             if an error occurs during parsing.\n-     */\n-    public Document read(Reader reader) throws DocumentException {\n-        InputSource source = new InputSource(reader);\n-        if (this.encoding != null) {\n-            source.setEncoding(this.encoding);\n-        }\n-\n-        return read(source);\n-    }\n-\n-    /**\n-     * <p>\n-     * Reads a Document from the given stream using SAX\n-     * </p>\n-     * \n-     * @param in\n-     *            <code>InputStream</code> to read from.\n-     * @param systemId\n-     *            is the URI for the input\n-     * \n-     * @return the newly created Document instance\n-     * \n-     * @throws DocumentException\n-     *             if an error occurs during parsing.\n-     */\n-    public Document read(InputStream in, String systemId)\n-            throws DocumentException {\n-        InputSource source = new InputSource(in);\n-        source.setSystemId(systemId);\n-        if (this.encoding != null) {\n-            source.setEncoding(this.encoding);\n-        }\n-\n-        return read(source);\n-    }\n-\n-    /**\n-     * <p>\n-     * Reads a Document from the given <code>Reader</code> using SAX\n-     * </p>\n-     * \n-     * @param reader\n-     *            is the reader for the input\n-     * @param systemId\n-     *            is the URI for the input\n-     * \n-     * @return the newly created Document instance\n-     * \n-     * @throws DocumentException\n-     *             if an error occurs during parsing.\n-     */\n-    public Document read(Reader reader, String systemId)\n-            throws DocumentException {\n-        InputSource source = new InputSource(reader);\n-        source.setSystemId(systemId);\n-        if (this.encoding != null) {\n-            source.setEncoding(this.encoding);\n-        }\n-\n-        return read(source);\n-    }\n-\n-    /**\n-     * <p>\n-     * Reads a Document from the given <code>InputSource</code> using SAX\n-     * </p>\n-     * \n-     * @param in\n-     *            <code>InputSource</code> to read from.\n-     * \n-     * @return the newly created Document instance\n-     * \n-     * @throws DocumentException\n-     *             if an error occurs during parsing.\n-     */\n-    public Document read(InputSource in) throws DocumentException {\n-        try {\n-            XMLReader reader = getXMLReader();\n-\n-            reader = installXMLFilter(reader);\n-\n-            EntityResolver thatEntityResolver = this.entityResolver;\n-\n-            if (thatEntityResolver == null) {\n-                thatEntityResolver = createDefaultEntityResolver(in\n-                        .getSystemId());\n-                this.entityResolver = thatEntityResolver;\n-            }\n-\n-            reader.setEntityResolver(thatEntityResolver);\n-\n-            SAXContentHandler contentHandler = createContentHandler(reader);\n-            contentHandler.setEntityResolver(thatEntityResolver);\n-            contentHandler.setInputSource(in);\n-\n-            boolean internal = isIncludeInternalDTDDeclarations();\n-            boolean external = isIncludeExternalDTDDeclarations();\n-\n-            contentHandler.setIncludeInternalDTDDeclarations(internal);\n-            contentHandler.setIncludeExternalDTDDeclarations(external);\n-            contentHandler.setMergeAdjacentText(isMergeAdjacentText());\n-            contentHandler.setStripWhitespaceText(isStripWhitespaceText());\n-            contentHandler.setIgnoreComments(isIgnoreComments());\n-            reader.setContentHandler(contentHandler);\n-\n-            configureReader(reader, contentHandler);\n-\n-            reader.parse(in);\n-\n-            return contentHandler.getDocument();\n-        } catch (Exception e) {\n-            if (e instanceof SAXParseException) {\n-                // e.printStackTrace();\n-                SAXParseException parseException = (SAXParseException) e;\n-                String systemId = parseException.getSystemId();\n-\n-                if (systemId == null) {\n-                    systemId = \"\";\n-                }\n-\n-                String message = \"Error on line \"\n-                        + parseException.getLineNumber() + \" of document \"\n-                        + systemId + \" : \" + parseException.getMessage();\n-\n-                throw new DocumentException(message, e);\n-            } else {\n-                throw new DocumentException(e.getMessage(), e);\n-            }\n+  protected DispatchHandler getDispatchHandler() {\n+    if (dispatchHandler == null) {\n+      dispatchHandler = new DispatchHandler();\n+    }\n+\n+    return dispatchHandler;\n+  }\n+\n+  protected void setDispatchHandler(DispatchHandler dispatchHandler) {\n+    this.dispatchHandler = dispatchHandler;\n+  }\n+\n+  /**\n+   * Factory Method to allow alternate methods of creating and configuring\n+   * XMLReader objects\n+   *\n+   * @return DOCUMENT ME!\n+   * @throws SAXException DOCUMENT ME!\n+   */\n+  protected XMLReader createXMLReader() throws SAXException {\n+    return SAXHelper.createXMLReader(isValidating());\n+  }\n+\n+  /**\n+   * Configures the XMLReader before use\n+   *\n+   * @param reader  DOCUMENT ME!\n+   * @param handler DOCUMENT ME!\n+   * @throws DocumentException DOCUMENT ME!\n+   */\n+  protected void configureReader(XMLReader reader, DefaultHandler handler)\n+          throws DocumentException {\n+    // configure lexical handling\n+    SAXHelper.setParserProperty(reader, SAX_LEXICALHANDLER, handler);\n+\n+    // try alternate property just in case\n+    SAXHelper.setParserProperty(reader, SAX_LEXICAL_HANDLER, handler);\n+\n+    // register the DeclHandler\n+    if (includeInternalDTDDeclarations || includeExternalDTDDeclarations) {\n+      SAXHelper.setParserProperty(reader, SAX_DECL_HANDLER, handler);\n+    }\n+\n+    // string interning\n+    SAXHelper.setParserFeature(reader, SAX_STRING_INTERNING,\n+            isStringInternEnabled());\n+\n+    try {\n+      // configure validation support\n+      reader.setFeature(\"http://xml.org/sax/features/validation\",\n+              isValidating());\n+\n+      if (errorHandler != null) {\n+        reader.setErrorHandler(errorHandler);\n+      } else {\n+        reader.setErrorHandler(handler);\n+      }\n+    } catch (Exception e) {\n+      if (isValidating()) {\n+        throw new DocumentException(\"Validation not supported for\"\n+                + \" XMLReader: \" + reader, e);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Factory Method to allow user derived SAXContentHandler objects to be used\n+   *\n+   * @param reader DOCUMENT ME!\n+   * @return DOCUMENT ME!\n+   */\n+  protected SAXContentHandler createContentHandler(XMLReader reader) {\n+    return new SAXContentHandler(getDocumentFactory(), dispatchHandler);\n+  }\n+\n+  protected EntityResolver createDefaultEntityResolver(String systemId) {\n+    String prefix = null;\n+\n+    if ((systemId != null) && (systemId.length() > 0)) {\n+      int idx = systemId.lastIndexOf('/');\n+\n+      if (idx > 0) {\n+        prefix = systemId.substring(0, idx + 1);\n+      }\n+    }\n+\n+    return new SAXEntityResolver(prefix);\n+  }\n+\n+  protected static class SAXEntityResolver implements EntityResolver,\n+          Serializable {\n+    protected String uriPrefix;\n+\n+    public SAXEntityResolver(String uriPrefix) {\n+      this.uriPrefix = uriPrefix;\n+    }\n+\n+    public InputSource resolveEntity(String publicId, String systemId) {\n+      // try create a relative URI reader...\n+      if ((systemId != null) && (systemId.length() > 0)) {\n+        if ((uriPrefix != null) && (systemId.indexOf(':') <= 0)) {\n+          systemId = uriPrefix + systemId;\n         }\n-    }\n-\n-    // Properties\n-    // -------------------------------------------------------------------------\n-\n-    /**\n-     * DOCUMENT ME!\n-     * \n-     * @return the validation mode, true if validating will be done otherwise\n-     *         false.\n-     */\n-    public boolean isValidating() {\n-        return validating;\n-    }\n-\n-    /**\n-     * Sets the validation mode.\n-     * \n-     * @param validation\n-     *            indicates whether or not validation should occur.\n-     */\n-    public void setValidation(boolean validation) {\n-        this.validating = validation;\n-    }\n+      }\n \n-    /**\n-     * DOCUMENT ME!\n-     * \n-     * @return whether internal DTD declarations should be expanded into the\n-     *         DocumentType object or not.\n-     */\n-    public boolean isIncludeInternalDTDDeclarations() {\n-        return includeInternalDTDDeclarations;\n-    }\n-\n-    /**\n-     * Sets whether internal DTD declarations should be expanded into the\n-     * DocumentType object or not.\n-     * \n-     * @param include\n-     *            whether or not DTD declarations should be expanded and\n-     *            included into the DocumentType object.\n-     */\n-    public void setIncludeInternalDTDDeclarations(boolean include) {\n-        this.includeInternalDTDDeclarations = include;\n-    }\n-\n-    /**\n-     * DOCUMENT ME!\n-     * \n-     * @return whether external DTD declarations should be expanded into the\n-     *         DocumentType object or not.\n-     */\n-    public boolean isIncludeExternalDTDDeclarations() {\n-        return includeExternalDTDDeclarations;\n-    }\n-\n-    /**\n-     * Sets whether DTD external declarations should be expanded into the\n-     * DocumentType object or not.\n-     * \n-     * @param include\n-     *            whether or not DTD declarations should be expanded and\n-     *            included into the DocumentType object.\n-     */\n-    public void setIncludeExternalDTDDeclarations(boolean include) {\n-        this.includeExternalDTDDeclarations = include;\n-    }\n-\n-    /**\n-     * Sets whether String interning is enabled or disabled for element &amp;\n-     * attribute names and namespace URIs. This proprety is enabled by default.\n-     * \n-     * @return DOCUMENT ME!\n-     */\n-    public boolean isStringInternEnabled() {\n-        return stringInternEnabled;\n-    }\n-\n-    /**\n-     * Sets whether String interning is enabled or disabled for element &amp;\n-     * attribute names and namespace URIs\n-     * \n-     * @param stringInternEnabled\n-     *            DOCUMENT ME!\n-     */\n-    public void setStringInternEnabled(boolean stringInternEnabled) {\n-        this.stringInternEnabled = stringInternEnabled;\n-    }\n-\n-    /**\n-     * Returns whether adjacent text nodes should be merged together.\n-     * \n-     * @return Value of property mergeAdjacentText.\n-     */\n-    public boolean isMergeAdjacentText() {\n-        return mergeAdjacentText;\n-    }\n-\n-    /**\n-     * Sets whether or not adjacent text nodes should be merged together when\n-     * parsing.\n-     * \n-     * @param mergeAdjacentText\n-     *            New value of property mergeAdjacentText.\n-     */\n-    public void setMergeAdjacentText(boolean mergeAdjacentText) {\n-        this.mergeAdjacentText = mergeAdjacentText;\n-    }\n-\n-    /**\n-     * Sets whether whitespace between element start and end tags should be\n-     * ignored\n-     * \n-     * @return Value of property stripWhitespaceText.\n-     */\n-    public boolean isStripWhitespaceText() {\n-        return stripWhitespaceText;\n-    }\n-\n-    /**\n-     * Sets whether whitespace between element start and end tags should be\n-     * ignored.\n-     * \n-     * @param stripWhitespaceText\n-     *            New value of property stripWhitespaceText.\n-     */\n-    public void setStripWhitespaceText(boolean stripWhitespaceText) {\n-        this.stripWhitespaceText = stripWhitespaceText;\n-    }\n-\n-    /**\n-     * Returns whether we should ignore comments or not.\n-     * \n-     * @return boolean\n-     */\n-    public boolean isIgnoreComments() {\n-        return ignoreComments;\n-    }\n-\n-    /**\n-     * Sets whether we should ignore comments or not.\n-     * \n-     * @param ignoreComments\n-     *            whether we should ignore comments or not.\n-     */\n-    public void setIgnoreComments(boolean ignoreComments) {\n-        this.ignoreComments = ignoreComments;\n-    }\n-\n-    /**\n-     * DOCUMENT ME!\n-     * \n-     * @return the <code>DocumentFactory</code> used to create document\n-     *         objects\n-     */\n-    public DocumentFactory getDocumentFactory() {\n-        if (factory == null) {\n-            factory = DocumentFactory.getInstance();\n-        }\n-\n-        return factory;\n-    }\n-\n-    /**\n-     * <p>\n-     * This sets the <code>DocumentFactory</code> used to create new\n-     * documents. This method allows the building of custom DOM4J tree objects\n-     * to be implemented easily using a custom derivation of\n-     * {@link DocumentFactory}\n-     * </p>\n-     * \n-     * @param documentFactory\n-     *            <code>DocumentFactory</code> used to create DOM4J objects\n-     */\n-    public void setDocumentFactory(DocumentFactory documentFactory) {\n-        this.factory = documentFactory;\n-    }\n-\n-    /**\n-     * DOCUMENT ME!\n-     * \n-     * @return the <code>ErrorHandler</code> used by SAX\n-     */\n-    public ErrorHandler getErrorHandler() {\n-        return errorHandler;\n-    }\n-\n-    /**\n-     * Sets the <code>ErrorHandler</code> used by the SAX\n-     * <code>XMLReader</code>.\n-     * \n-     * @param errorHandler\n-     *            is the <code>ErrorHandler</code> used by SAX\n-     */\n-    public void setErrorHandler(ErrorHandler errorHandler) {\n-        this.errorHandler = errorHandler;\n-    }\n-\n-    /**\n-     * Returns the current entity resolver used to resolve entities\n-     * \n-     * @return DOCUMENT ME!\n-     */\n-    public EntityResolver getEntityResolver() {\n-        return entityResolver;\n-    }\n-\n-    /**\n-     * Sets the entity resolver used to resolve entities.\n-     * \n-     * @param entityResolver\n-     *            DOCUMENT ME!\n-     */\n-    public void setEntityResolver(EntityResolver entityResolver) {\n-        this.entityResolver = entityResolver;\n-    }\n-\n-    /**\n-     * DOCUMENT ME!\n-     * \n-     * @return the <code>XMLReader</code> used to parse SAX events\n-     * \n-     * @throws SAXException\n-     *             DOCUMENT ME!\n-     */\n-    public XMLReader getXMLReader() throws SAXException {\n-        if (xmlReader == null) {\n-            xmlReader = createXMLReader();\n-        }\n-\n-        return xmlReader;\n-    }\n-\n-    /**\n-     * Sets the <code>XMLReader</code> used to parse SAX events\n-     * \n-     * @param reader\n-     *            is the <code>XMLReader</code> to parse SAX events\n-     */\n-    public void setXMLReader(XMLReader reader) {\n-        this.xmlReader = reader;\n-    }\n-\n-    /**\n-     * Returns encoding used for InputSource (null means system default\n-     * encoding)\n-     * \n-     * @return encoding used for InputSource\n-     * \n-     */\n-    public String getEncoding() {\n-        return encoding;\n-    }\n-\n-    /**\n-     * Sets encoding used for InputSource (null means system default encoding)\n-     * \n-     * @param encoding\n-     *            is encoding used for InputSource\n-     */\n-    public void setEncoding(String encoding) {\n-        this.encoding = encoding;\n-    }\n-\n-    /**\n-     * Sets the class name of the <code>XMLReader</code> to be used to parse\n-     * SAX events.\n-     * \n-     * @param xmlReaderClassName\n-     *            is the class name of the <code>XMLReader</code> to parse SAX\n-     *            events\n-     * \n-     * @throws SAXException\n-     *             DOCUMENT ME!\n-     */\n-    public void setXMLReaderClassName(String xmlReaderClassName)\n-            throws SAXException {\n-        setXMLReader(XMLReaderFactory.createXMLReader(xmlReaderClassName));\n-    }\n-\n-    /**\n-     * Adds the <code>ElementHandler</code> to be called when the specified\n-     * path is encounted.\n-     * \n-     * @param path\n-     *            is the path to be handled\n-     * @param handler\n-     *            is the <code>ElementHandler</code> to be called by the event\n-     *            based processor.\n-     */\n-    public void addHandler(String path, ElementHandler handler) {\n-        getDispatchHandler().addHandler(path, handler);\n-    }\n-\n-    /**\n-     * Removes the <code>ElementHandler</code> from the event based processor,\n-     * for the specified path.\n-     * \n-     * @param path\n-     *            is the path to remove the <code>ElementHandler</code> for.\n-     */\n-    public void removeHandler(String path) {\n-        getDispatchHandler().removeHandler(path);\n-    }\n-\n-    /**\n-     * When multiple <code>ElementHandler</code> instances have been\n-     * registered, this will set a default <code>ElementHandler</code> to be\n-     * called for any path which does <b>NOT </b> have a handler registered.\n-     * \n-     * @param handler\n-     *            is the <code>ElementHandler</code> to be called by the event\n-     *            based processor.\n-     */\n-    public void setDefaultHandler(ElementHandler handler) {\n-        getDispatchHandler().setDefaultHandler(handler);\n-    }\n-\n-    /**\n-     * This method clears out all the existing handlers and default handler\n-     * setting things back as if no handler existed. Useful when reusing an\n-     * object instance.\n-     */\n-    public void resetHandlers() {\n-        getDispatchHandler().resetHandlers();\n-    }\n-\n-    /**\n-     * Returns the SAX filter being used to filter SAX events.\n-     * \n-     * @return the SAX filter being used or null if no SAX filter is installed\n-     */\n-    public XMLFilter getXMLFilter() {\n-        return xmlFilter;\n-    }\n-\n-    /**\n-     * Sets the SAX filter to be used when filtering SAX events\n-     * \n-     * @param filter\n-     *            is the SAX filter to use or null to disable filtering\n-     */\n-    public void setXMLFilter(XMLFilter filter) {\n-        this.xmlFilter = filter;\n-    }\n-\n-    // Implementation methods\n-    // -------------------------------------------------------------------------\n-\n-    /**\n-     * Installs any XMLFilter objects required to allow the SAX event stream to\n-     * be filtered and preprocessed before it gets to dom4j.\n-     * \n-     * @param reader\n-     *            DOCUMENT ME!\n-     * \n-     * @return the new XMLFilter if applicable or the original XMLReader if no\n-     *         filter is being used.\n-     */\n-    protected XMLReader installXMLFilter(XMLReader reader) {\n-        XMLFilter filter = getXMLFilter();\n-\n-        if (filter != null) {\n-            // find the root XMLFilter\n-            XMLFilter root = filter;\n-\n-            while (true) {\n-                XMLReader parent = root.getParent();\n-\n-                if (parent instanceof XMLFilter) {\n-                    root = (XMLFilter) parent;\n-                } else {\n-                    break;\n-                }\n-            }\n-\n-            root.setParent(reader);\n-\n-            return filter;\n-        }\n-\n-        return reader;\n-    }\n-\n-    protected DispatchHandler getDispatchHandler() {\n-        if (dispatchHandler == null) {\n-            dispatchHandler = new DispatchHandler();\n-        }\n-\n-        return dispatchHandler;\n-    }\n-\n-    protected void setDispatchHandler(DispatchHandler dispatchHandler) {\n-        this.dispatchHandler = dispatchHandler;\n-    }\n-\n-    /**\n-     * Factory Method to allow alternate methods of creating and configuring\n-     * XMLReader objects\n-     * \n-     * @return DOCUMENT ME!\n-     * \n-     * @throws SAXException\n-     *             DOCUMENT ME!\n-     */\n-    protected XMLReader createXMLReader() throws SAXException {\n-        return SAXHelper.createXMLReader(isValidating());\n-    }\n-\n-    /**\n-     * Configures the XMLReader before use\n-     * \n-     * @param reader\n-     *            DOCUMENT ME!\n-     * @param handler\n-     *            DOCUMENT ME!\n-     * \n-     * @throws DocumentException\n-     *             DOCUMENT ME!\n-     */\n-    protected void configureReader(XMLReader reader, DefaultHandler handler)\n-            throws DocumentException {\n-        // configure lexical handling\n-        SAXHelper.setParserProperty(reader, SAX_LEXICALHANDLER, handler);\n-\n-        // try alternate property just in case\n-        SAXHelper.setParserProperty(reader, SAX_LEXICAL_HANDLER, handler);\n-\n-        // register the DeclHandler\n-        if (includeInternalDTDDeclarations || includeExternalDTDDeclarations) {\n-            SAXHelper.setParserProperty(reader, SAX_DECL_HANDLER, handler);\n-        }\n-\n-        // string interning\n-        SAXHelper.setParserFeature(reader, SAX_STRING_INTERNING,\n-                isStringInternEnabled());\n-\n-        try {\n-            // configure validation support\n-            reader.setFeature(\"http://xml.org/sax/features/validation\",\n-                    isValidating());\n-\n-            if (errorHandler != null) {\n-                reader.setErrorHandler(errorHandler);\n-            } else {\n-                reader.setErrorHandler(handler);\n-            }\n-        } catch (Exception e) {\n-            if (isValidating()) {\n-                throw new DocumentException(\"Validation not supported for\"\n-                        + \" XMLReader: \" + reader, e);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Factory Method to allow user derived SAXContentHandler objects to be used\n-     * \n-     * @param reader\n-     *            DOCUMENT ME!\n-     * \n-     * @return DOCUMENT ME!\n-     */\n-    protected SAXContentHandler createContentHandler(XMLReader reader) {\n-        return new SAXContentHandler(getDocumentFactory(), dispatchHandler);\n-    }\n-\n-    protected EntityResolver createDefaultEntityResolver(String systemId) {\n-        String prefix = null;\n-\n-        if ((systemId != null) && (systemId.length() > 0)) {\n-            int idx = systemId.lastIndexOf('/');\n-\n-            if (idx > 0) {\n-                prefix = systemId.substring(0, idx + 1);\n-            }\n-        }\n-\n-        return new SAXEntityResolver(prefix);\n-    }\n-\n-    protected static class SAXEntityResolver implements EntityResolver,\n-            Serializable {\n-        protected String uriPrefix;\n-\n-        public SAXEntityResolver(String uriPrefix) {\n-            this.uriPrefix = uriPrefix;\n-        }\n-\n-        public InputSource resolveEntity(String publicId, String systemId) {\n-            // try create a relative URI reader...\n-            if ((systemId != null) && (systemId.length() > 0)) {\n-                if ((uriPrefix != null) && (systemId.indexOf(':') <= 0)) {\n-                    systemId = uriPrefix + systemId;\n-                }\n-            }\n-\n-            return new InputSource(systemId);\n-        }\n+      return new InputSource(systemId);\n     }\n+  }\n }\n \n /*\n  * Redistribution and use of this software and associated documentation\n  * (\"Software\"), with or without modification, are permitted provided that the\n  * following conditions are met:\n- * \n+ *\n  * 1. Redistributions of source code must retain copyright statements and\n  * notices. Redistributions must also contain a copy of this document.\n- * \n+ *\n  * 2. Redistributions in binary form must reproduce the above copyright notice,\n  * this list of conditions and the following disclaimer in the documentation\n  * and/or other materials provided with the distribution.\n- * \n+ *\n  * 3. The name \"DOM4J\" must not be used to endorse or promote products derived\n  * from this Software without prior written permission of MetaStuff, Ltd. For\n  * written permission, please contact dom4j-info@metastuff.com.\n- * \n+ *\n  * 4. Products derived from this Software may not be called \"DOM4J\" nor may\n  * \"DOM4J\" appear in their names without prior written permission of MetaStuff,\n  * Ltd. DOM4J is a registered trademark of MetaStuff, Ltd.\n- * \n+ *\n  * 5. Due credit should be given to the DOM4J Project - http://www.dom4j.org\n- * \n+ *\n  * THIS SOFTWARE IS PROVIDED BY METASTUFF, LTD. AND CONTRIBUTORS ``AS IS'' AND\n  * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n@@ -1000,6 +1016,6 @@ public InputSource resolveEntity(String publicId, String systemId) {\n  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n  * POSSIBILITY OF SUCH DAMAGE.\n- * \n+ *\n  * Copyright 2001-2005 (C) MetaStuff, Ltd. All Rights Reserved.\n  */",
        "function_modified_lines": {
            "added": [
                "import javax.xml.parsers.SAXParserFactory;\n",
                "\n",
                " * <p>\n",
                " * <p>\n",
                " * <p>\n",
                " * <p>\n",
                " * <p>\n",
                " * <p>\n"
            ],
            "deleted": [
                " *\n",
                " *\n",
                " *\n",
                " *\n",
                " *\n",
                " *\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-611"
        ],
        "cve_description": "dom4j before 2.0.3 and 2.1.x before 2.1.3 allows external DTDs and External Entities by default, which might enable XXE attacks. However, there is popular external documentation from OWASP showing how to enable the safe, non-default behavior in any application that uses dom4j.",
        "id": 12089
    },
    {
        "cve_id": "CVE-2021-41098",
        "code_before_change": "package nokogiri.internals;\n\nimport org.apache.xerces.xni.parser.XMLParseException;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.SAXParseException;\n\n/**\n * Error Handler for XML document when recover is true (default).\n *\n * @author sergio\n * @author Yoko Harada <yokolet@gmail.com>\n */\npublic class NokogiriNonStrictErrorHandler extends NokogiriErrorHandler\n{\n  public\n  NokogiriNonStrictErrorHandler(boolean noerror, boolean nowarning)\n  {\n    super(noerror, nowarning);\n  }\n\n  public void\n  warning(SAXParseException ex) throws SAXException\n  {\n    errors.add(ex);\n  }\n\n  public void\n  error(SAXParseException ex) throws SAXException\n  {\n    errors.add(ex);\n  }\n\n  public void\n  fatalError(SAXParseException ex) throws SAXException\n  {\n    // fix #837\n    // Xerces won't skip the reference entity (and other invalid) constructs\n    // found in the prolog, instead it will keep calling this method and we'll\n    // keep inserting the error in the document errors array until we run\n    // out of memory\n    errors.add(ex);\n    String message = ex.getMessage();\n\n    // The problem with Xerces is that some errors will cause the\n    // parser not to advance the reader and it will keep reporting\n    // the same error over and over, which will cause the parser\n    // to enter an infinite loop unless we throw the exception.\n    if (message != null && isFatal(message)) {\n      throw ex;\n    }\n  }\n\n  public void\n  error(String domain, String key, XMLParseException e)\n  {\n    errors.add(e);\n  }\n\n  public void\n  fatalError(String domain, String key, XMLParseException e)\n  {\n    errors.add(e);\n  }\n\n  public void\n  warning(String domain, String key, XMLParseException e)\n  {\n    errors.add(e);\n  }\n\n  /*\n   * Determine whether this is a fatal error that should cause\n   * the parsing to stop, or an error that can be ignored.\n   */\n  private static boolean\n  isFatal(String msg)\n  {\n    String msgLowerCase = msg.toLowerCase();\n    return\n      msgLowerCase.contains(\"in prolog\") ||\n      msgLowerCase.contains(\"limit\") ||\n      msgLowerCase.contains(\"preceding the root element must be well-formed\") ||\n      msgLowerCase.contains(\"following the root element must be well-formed\");\n  }\n}\n",
        "code_after_change": "package nokogiri.internals;\n\nimport org.apache.xerces.xni.parser.XMLParseException;\nimport org.jruby.Ruby;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.SAXParseException;\n\n/**\n * Error Handler for XML document when recover is true (default).\n *\n * @author sergio\n * @author Yoko Harada <yokolet@gmail.com>\n */\npublic class NokogiriNonStrictErrorHandler extends NokogiriErrorHandler\n{\n  public\n  NokogiriNonStrictErrorHandler(Ruby runtime, boolean noerror, boolean nowarning)\n  {\n    super(runtime, noerror, nowarning);\n  }\n\n  public void\n  warning(SAXParseException ex) throws SAXException\n  {\n    addError(ex);\n  }\n\n  public void\n  error(SAXParseException ex) throws SAXException\n  {\n    addError(ex);\n  }\n\n  public void\n  fatalError(SAXParseException ex) throws SAXException\n  {\n    // fix #837\n    // Xerces won't skip the reference entity (and other invalid) constructs\n    // found in the prolog, instead it will keep calling this method and we'll\n    // keep inserting the error in the document errors array until we run\n    // out of memory\n    addError(ex);\n    String message = ex.getMessage();\n\n    // The problem with Xerces is that some errors will cause the\n    // parser not to advance the reader and it will keep reporting\n    // the same error over and over, which will cause the parser\n    // to enter an infinite loop unless we throw the exception.\n    if (message != null && isFatal(message)) {\n      throw ex;\n    }\n  }\n\n  public void\n  error(String domain, String key, XMLParseException e)\n  {\n    addError(e);\n  }\n\n  public void\n  fatalError(String domain, String key, XMLParseException e)\n  {\n    addError(e);\n  }\n\n  public void\n  warning(String domain, String key, XMLParseException e)\n  {\n    addError(e);\n  }\n\n  /*\n   * Determine whether this is a fatal error that should cause\n   * the parsing to stop, or an error that can be ignored.\n   */\n  private static boolean\n  isFatal(String msg)\n  {\n    String msgLowerCase = msg.toLowerCase();\n    return\n      msgLowerCase.contains(\"in prolog\") ||\n      msgLowerCase.contains(\"limit\") ||\n      msgLowerCase.contains(\"preceding the root element must be well-formed\") ||\n      msgLowerCase.contains(\"following the root element must be well-formed\");\n  }\n}\n",
        "patch": "@@ -1,6 +1,7 @@\n package nokogiri.internals;\n \n import org.apache.xerces.xni.parser.XMLParseException;\n+import org.jruby.Ruby;\n import org.xml.sax.SAXException;\n import org.xml.sax.SAXParseException;\n \n@@ -13,21 +14,21 @@\n public class NokogiriNonStrictErrorHandler extends NokogiriErrorHandler\n {\n   public\n-  NokogiriNonStrictErrorHandler(boolean noerror, boolean nowarning)\n+  NokogiriNonStrictErrorHandler(Ruby runtime, boolean noerror, boolean nowarning)\n   {\n-    super(noerror, nowarning);\n+    super(runtime, noerror, nowarning);\n   }\n \n   public void\n   warning(SAXParseException ex) throws SAXException\n   {\n-    errors.add(ex);\n+    addError(ex);\n   }\n \n   public void\n   error(SAXParseException ex) throws SAXException\n   {\n-    errors.add(ex);\n+    addError(ex);\n   }\n \n   public void\n@@ -38,7 +39,7 @@ public class NokogiriNonStrictErrorHandler extends NokogiriErrorHandler\n     // found in the prolog, instead it will keep calling this method and we'll\n     // keep inserting the error in the document errors array until we run\n     // out of memory\n-    errors.add(ex);\n+    addError(ex);\n     String message = ex.getMessage();\n \n     // The problem with Xerces is that some errors will cause the\n@@ -53,19 +54,19 @@ public class NokogiriNonStrictErrorHandler extends NokogiriErrorHandler\n   public void\n   error(String domain, String key, XMLParseException e)\n   {\n-    errors.add(e);\n+    addError(e);\n   }\n \n   public void\n   fatalError(String domain, String key, XMLParseException e)\n   {\n-    errors.add(e);\n+    addError(e);\n   }\n \n   public void\n   warning(String domain, String key, XMLParseException e)\n   {\n-    errors.add(e);\n+    addError(e);\n   }\n \n   /*",
        "function_modified_lines": {
            "added": [
                "import org.jruby.Ruby;\n",
                "  NokogiriNonStrictErrorHandler(Ruby runtime, boolean noerror, boolean nowarning)\n",
                "    super(runtime, noerror, nowarning);\n",
                "    addError(ex);\n",
                "    addError(ex);\n",
                "    addError(ex);\n",
                "    addError(e);\n",
                "    addError(e);\n",
                "    addError(e);\n"
            ],
            "deleted": [
                "  NokogiriNonStrictErrorHandler(boolean noerror, boolean nowarning)\n",
                "    super(noerror, nowarning);\n",
                "    errors.add(ex);\n",
                "    errors.add(ex);\n",
                "    errors.add(ex);\n",
                "    errors.add(e);\n",
                "    errors.add(e);\n",
                "    errors.add(e);\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-611"
        ],
        "cve_description": "Nokogiri is a Rubygem providing HTML, XML, SAX, and Reader parsers with XPath and CSS selector support. In Nokogiri v1.12.4 and earlier, on JRuby only, the SAX parser resolves external entities by default. Users of Nokogiri on JRuby who parse untrusted documents using any of these classes are affected: Nokogiri::XML::SAX::Parse, Nokogiri::HTML4::SAX::Parser or its alias Nokogiri::HTML::SAX::Parser, Nokogiri::XML::SAX::PushParser, and Nokogiri::HTML4::SAX::PushParser or its alias Nokogiri::HTML::SAX::PushParser. JRuby users should upgrade to Nokogiri v1.12.5 or later to receive a patch for this issue. There are no workarounds available for v1.12.4 or earlier. CRuby users are not affected.",
        "id": 12173
    },
    {
        "cve_id": "CVE-2021-41098",
        "code_before_change": "package nokogiri.internals;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.xerces.xni.parser.XMLErrorHandler;\nimport org.xml.sax.ErrorHandler;\n\n/**\n * Super class of error handlers.\n *\n * XMLErrorHandler is used by nokogiri.internals.HtmlDomParserContext since NekoHtml\n * uses this type of the error handler.\n *\n * @author sergio\n * @author Yoko Harada <yokolet@gmail.com>\n */\npublic abstract class NokogiriErrorHandler implements ErrorHandler, XMLErrorHandler\n{\n  protected final List<Exception> errors;\n  protected boolean noerror;\n  protected boolean nowarning;\n\n  public\n  NokogiriErrorHandler(boolean noerror, boolean nowarning)\n  {\n    this.errors = new ArrayList<Exception>(4);\n    this.noerror = noerror;\n    this.nowarning = nowarning;\n  }\n\n  List<Exception>\n  getErrors() { return errors; }\n\n  public void\n  addError(Exception ex) { errors.add(ex); }\n\n  protected boolean\n  usesNekoHtml(String domain)\n  {\n    return \"http://cyberneko.org/html\".equals(domain);\n  }\n\n}\n",
        "code_after_change": "package nokogiri.internals;\n\nimport nokogiri.XmlSyntaxError;\nimport org.apache.xerces.xni.parser.XMLErrorHandler;\nimport org.jruby.Ruby;\nimport org.jruby.RubyException;\nimport org.jruby.exceptions.RaiseException;\nimport org.xml.sax.ErrorHandler;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Super class of error handlers.\n *\n * XMLErrorHandler is used by nokogiri.internals.HtmlDomParserContext since NekoHtml\n * uses this type of the error handler.\n *\n * @author sergio\n * @author Yoko Harada <yokolet@gmail.com>\n */\npublic abstract class NokogiriErrorHandler implements ErrorHandler, XMLErrorHandler\n{\n  private final Ruby runtime;\n  protected final List<RubyException> errors;\n  protected boolean noerror;\n  protected boolean nowarning;\n\n  public\n  NokogiriErrorHandler(Ruby runtime, boolean noerror, boolean nowarning)\n  {\n    this.runtime = runtime;\n    this.errors = new ArrayList<RubyException>(4);\n    this.noerror = noerror;\n    this.nowarning = nowarning;\n  }\n\n  public List<RubyException>\n  getErrors() { return errors; }\n\n  public void\n  addError(Exception ex)\n  {\n    addError(XmlSyntaxError.createXMLSyntaxError(runtime, ex));\n  }\n\n  public void\n  addError(RubyException ex)\n  {\n    errors.add(ex);\n  }\n\n  public void\n  addError(RaiseException ex)\n  {\n    addError(ex.getException());\n  }\n\n  protected boolean\n  usesNekoHtml(String domain)\n  {\n    return \"http://cyberneko.org/html\".equals(domain);\n  }\n\n}\n",
        "patch": "@@ -1,11 +1,15 @@\n package nokogiri.internals;\n \n-import java.util.ArrayList;\n-import java.util.List;\n-\n+import nokogiri.XmlSyntaxError;\n import org.apache.xerces.xni.parser.XMLErrorHandler;\n+import org.jruby.Ruby;\n+import org.jruby.RubyException;\n+import org.jruby.exceptions.RaiseException;\n import org.xml.sax.ErrorHandler;\n \n+import java.util.ArrayList;\n+import java.util.List;\n+\n /**\n  * Super class of error handlers.\n  *\n@@ -17,23 +21,40 @@\n  */\n public abstract class NokogiriErrorHandler implements ErrorHandler, XMLErrorHandler\n {\n-  protected final List<Exception> errors;\n+  private final Ruby runtime;\n+  protected final List<RubyException> errors;\n   protected boolean noerror;\n   protected boolean nowarning;\n \n   public\n-  NokogiriErrorHandler(boolean noerror, boolean nowarning)\n+  NokogiriErrorHandler(Ruby runtime, boolean noerror, boolean nowarning)\n   {\n-    this.errors = new ArrayList<Exception>(4);\n+    this.runtime = runtime;\n+    this.errors = new ArrayList<RubyException>(4);\n     this.noerror = noerror;\n     this.nowarning = nowarning;\n   }\n \n-  List<Exception>\n+  public List<RubyException>\n   getErrors() { return errors; }\n \n   public void\n-  addError(Exception ex) { errors.add(ex); }\n+  addError(Exception ex)\n+  {\n+    addError(XmlSyntaxError.createXMLSyntaxError(runtime, ex));\n+  }\n+\n+  public void\n+  addError(RubyException ex)\n+  {\n+    errors.add(ex);\n+  }\n+\n+  public void\n+  addError(RaiseException ex)\n+  {\n+    addError(ex.getException());\n+  }\n \n   protected boolean\n   usesNekoHtml(String domain)",
        "function_modified_lines": {
            "added": [
                "import nokogiri.XmlSyntaxError;\n",
                "import org.jruby.Ruby;\n",
                "import org.jruby.RubyException;\n",
                "import org.jruby.exceptions.RaiseException;\n",
                "import java.util.ArrayList;\n",
                "import java.util.List;\n",
                "\n",
                "  private final Ruby runtime;\n",
                "  protected final List<RubyException> errors;\n",
                "  NokogiriErrorHandler(Ruby runtime, boolean noerror, boolean nowarning)\n",
                "    this.runtime = runtime;\n",
                "    this.errors = new ArrayList<RubyException>(4);\n",
                "  public List<RubyException>\n",
                "  addError(Exception ex)\n",
                "  {\n",
                "    addError(XmlSyntaxError.createXMLSyntaxError(runtime, ex));\n",
                "  }\n",
                "\n",
                "  public void\n",
                "  addError(RubyException ex)\n",
                "  {\n",
                "    errors.add(ex);\n",
                "  }\n",
                "\n",
                "  public void\n",
                "  addError(RaiseException ex)\n",
                "  {\n",
                "    addError(ex.getException());\n",
                "  }\n"
            ],
            "deleted": [
                "import java.util.ArrayList;\n",
                "import java.util.List;\n",
                "\n",
                "  protected final List<Exception> errors;\n",
                "  NokogiriErrorHandler(boolean noerror, boolean nowarning)\n",
                "    this.errors = new ArrayList<Exception>(4);\n",
                "  List<Exception>\n",
                "  addError(Exception ex) { errors.add(ex); }\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-611"
        ],
        "cve_description": "Nokogiri is a Rubygem providing HTML, XML, SAX, and Reader parsers with XPath and CSS selector support. In Nokogiri v1.12.4 and earlier, on JRuby only, the SAX parser resolves external entities by default. Users of Nokogiri on JRuby who parse untrusted documents using any of these classes are affected: Nokogiri::XML::SAX::Parse, Nokogiri::HTML4::SAX::Parser or its alias Nokogiri::HTML::SAX::Parser, Nokogiri::XML::SAX::PushParser, and Nokogiri::HTML4::SAX::PushParser or its alias Nokogiri::HTML::SAX::PushParser. JRuby users should upgrade to Nokogiri v1.12.5 or later to receive a patch for this issue. There are no workarounds available for v1.12.4 or earlier. CRuby users are not affected.",
        "id": 12171
    },
    {
        "cve_id": "CVE-2021-23792",
        "code_before_change": "{\n        Validate.notNull(input, \"input\");\n\n        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n        factory.setNamespaceAware(true);\n\n        try {\n            // TODO: Consider parsing using SAX?\n            // TODO: Determine encoding and parse using a Reader...\n            // TODO: Refactor scanner to return inputstream?\n            // TODO: Be smarter about ASCII-NULL termination/padding (the SAXParser aka Xerces DOMParser doesn't like it)...\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            builder.setErrorHandler(new DefaultHandler());\n            Document document = builder.parse(new InputSource(IIOUtil.createStreamAdapter(input)));\n\n//            XMLSerializer serializer = new XMLSerializer(System.err, System.getProperty(\"file.encoding\"));\n//            serializer.serialize(document);\n\n            String toolkit = getToolkit(document);\n            Node rdfRoot = document.getElementsByTagNameNS(XMP.NS_RDF, \"RDF\").item(0);\n            NodeList descriptions = document.getElementsByTagNameNS(XMP.NS_RDF, \"Description\");\n\n            return parseDirectories(rdfRoot, descriptions, toolkit);\n        }\n        catch (SAXException e) {\n            throw new IIOException(e.getMessage(), e);\n        }\n        catch (ParserConfigurationException e) {\n            throw new RuntimeException(e); // TODO: Or IOException?\n        }\n    }",
        "code_after_change": "{\n    // See http://www.scribd.com/doc/56852716/XMPSpecificationPart1\n\n    // TODO: Types? Probably defined in XMP/RDF XML schema. Or are we happy that everything is a string?\n\n    @Override\n    public Directory read(final ImageInputStream input) throws IOException {\n        Validate.notNull(input, \"input\");\n\n        try {\n            DocumentBuilderFactory factory = createDocumentBuilderFactory();\n\n            // TODO: Consider parsing using SAX?\n            // TODO: Determine encoding and parse using a Reader...\n            // TODO: Refactor scanner to return inputstream?\n            // TODO: Be smarter about ASCII-NULL termination/padding (the SAXParser aka Xerces DOMParser doesn't like it)...\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            builder.setErrorHandler(new DefaultHandler());\n            Document document = builder.parse(new InputSource(IIOUtil.createStreamAdapter(input)));\n\n            String toolkit = getToolkit(document);\n            Node rdfRoot = document.getElementsByTagNameNS(XMP.NS_RDF, \"RDF\").item(0);\n            NodeList descriptions = document.getElementsByTagNameNS(XMP.NS_RDF, \"Description\");\n\n            return parseDirectories(rdfRoot, descriptions, toolkit);\n        }\n        catch (SAXException e) {\n            throw new IIOException(e.getMessage(), e);\n        }\n        catch (ParserConfigurationException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private DocumentBuilderFactory createDocumentBuilderFactory() throws ParserConfigurationException {\n        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n        factory.setNamespaceAware(true);\n\n        // Security: Disable XInclude & expanding entity references (\"bombs\"), not needed for XMP\n        factory.setXIncludeAware(false);\n        factory.setExpandEntityReferences(false);\n\n        // Security: Enable \"secure processing\", to prevent DoS attacks\n        factory.setAttribute(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n\n        // Security: Remove possibility to access external DTDs or Schema, not needed for XMP\n        factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, \"\");\n        factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_SCHEMA, \"\");\n\n        // Security: Disable loading of external DTD and entities, not needed for XMP\n        factory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n        factory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n        factory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n\n        return factory;\n    }\n\n    private String getToolkit(Document document) {\n        NodeList xmpmeta = document.getElementsByTagNameNS(XMP.NS_X, \"xmpmeta\");\n\n        if (xmpmeta == null || xmpmeta.getLength() <= 0) {\n            return null;\n        }\n\n        Node toolkit = xmpmeta.item(0).getAttributes().getNamedItemNS(XMP.NS_X, \"xmptk\");\n\n        return toolkit != null ? toolkit.getNodeValue() : null;\n    }\n\n    private XMPDirectory parseDirectories(final Node pParentNode, NodeList pNodes, String toolkit) {\n        Map<String, List<Entry>> subdirs = new LinkedHashMap<>();\n\n        for (Node desc : asIterable(pNodes)) {\n            if (desc.getParentNode() != pParentNode) {\n                continue;\n            }\n\n            // Support attribute short-hand syntax\n            parseAttributesForKnownElements(subdirs, desc);\n\n            for (Node node : asIterable(desc.getChildNodes())) {\n                if (node.getNodeType() != Node.ELEMENT_NODE) {\n                    continue;\n                }\n\n                // Lookup\n                List<Entry> dir = subdirs.get(node.getNamespaceURI());\n                if (dir == null) {\n                    dir = new ArrayList<>();\n                    subdirs.put(node.getNamespaceURI(), dir);\n                }\n\n                Object value;\n\n                if (isResourceType(node)) {\n                    value = parseAsResource(node);\n                }\n                else {\n                    // TODO: This method contains loads of duplication an should be cleaned up...\n                    // Support attribute short-hand syntax\n                    Map<String, List<Entry>> subsubdirs = new LinkedHashMap<>();\n\n                    parseAttributesForKnownElements(subsubdirs, node);\n\n                    if (!subsubdirs.isEmpty()) {\n                        List<Entry> entries = new ArrayList<>(subsubdirs.size());\n\n                        for (Map.Entry<String, List<Entry>> entry : subsubdirs.entrySet()) {\n                            entries.addAll(entry.getValue());\n                        }\n\n                        value = new RDFDescription(entries);\n                    }\n                    else {\n                        value = getChildTextValue(node);\n                    }\n                }\n\n                dir.add(new XMPEntry(node.getNamespaceURI() + node.getLocalName(), node.getLocalName(), value));\n            }\n        }\n\n        List<Directory> entries = new ArrayList<>(subdirs.size());\n\n        // TODO: Should we still allow asking for a subdirectory by item id?\n        for (Map.Entry<String, List<Entry>> entry : subdirs.entrySet()) {\n            entries.add(new RDFDescription(entry.getKey(), entry.getValue()));\n        }\n\n        return new XMPDirectory(entries, toolkit);\n    }\n\n    private boolean isResourceType(Node node) {\n        Node parseType = node.getAttributes().getNamedItemNS(XMP.NS_RDF, \"parseType\");\n\n        return parseType != null && \"Resource\".equals(parseType.getNodeValue());\n    }\n\n    private RDFDescription parseAsResource(Node node) {\n        // See: http://www.w3.org/TR/REC-rdf-syntax/#section-Syntax-parsetype-resource\n        List<Entry> entries = new ArrayList<>();\n\n        for (Node child : asIterable(node.getChildNodes())) {\n            if (child.getNodeType() != Node.ELEMENT_NODE) {\n                continue;\n            }\n\n            entries.add(new XMPEntry(child.getNamespaceURI() + child.getLocalName(), child.getLocalName(), getChildTextValue(child)));\n        }\n\n        return new RDFDescription(entries);\n    }\n\n    private void parseAttributesForKnownElements(Map<String, List<Entry>> subdirs, Node desc) {\n        // NOTE: NamedNodeMap does not have any particular order...\n        NamedNodeMap attributes = desc.getAttributes();\n\n        for (Node attr : asIterable(attributes)) {\n            if (!XMP.ELEMENTS.contains(attr.getNamespaceURI())) {\n                continue;\n            }\n\n            List<Entry> dir = subdirs.get(attr.getNamespaceURI());\n\n            if (dir == null) {\n                dir = new ArrayList<>();\n                subdirs.put(attr.getNamespaceURI(), dir);\n            }\n\n            dir.add(new XMPEntry(attr.getNamespaceURI() + attr.getLocalName(), attr.getLocalName(), attr.getNodeValue()));\n        }\n    }\n\n    private Object getChildTextValue(final Node node) {\n        for (Node child : asIterable(node.getChildNodes())) {\n            if (XMP.NS_RDF.equals(child.getNamespaceURI()) && \"Alt\".equals(child.getLocalName())) {\n                // Support for <rdf:Alt><rdf:li> -> return a Map<String, Object> keyed on xml:lang\n                Map<String, Object> alternatives = new LinkedHashMap<>();\n                for (Node alternative : asIterable(child.getChildNodes())) {\n                    if (XMP.NS_RDF.equals(alternative.getNamespaceURI()) && \"li\".equals(alternative.getLocalName())) {\n                        NamedNodeMap attributes = alternative.getAttributes();\n                        Node key = attributes.getNamedItem(\"xml:lang\");\n                        alternatives.put(key == null ? null : key.getTextContent(), getChildTextValue(alternative));\n                    }\n                }\n\n                return alternatives;\n            }\n            else if (XMP.NS_RDF.equals(child.getNamespaceURI()) && (\"Seq\".equals(child.getLocalName()) || \"Bag\".equals(child.getLocalName()))) {\n                // Support for <rdf:Seq><rdf:li> -> return array\n                // Support for <rdf:Bag><rdf:li> -> return array/unordered collection (how can a serialized collection not have order?)\n                List<Object> seq = new ArrayList<>();\n\n                for (Node sequence : asIterable(child.getChildNodes())) {\n                    if (XMP.NS_RDF.equals(sequence.getNamespaceURI()) && \"li\".equals(sequence.getLocalName())) {\n                        Object value = getChildTextValue(sequence);\n                        seq.add(value);\n                    }\n                }\n\n                // TODO: Strictly a bag should not be a list, but there's no Bag type (or similar) in Java.\n                // Consider something like Google collections Multiset or Apache commons Bag (the former seems more well-defined)\n                // Note: Collection does not have defined equals() semantics, and so using\n                // Collections.unmodifiableCollection() doesn't work for comparing values (uses Object.equals())\n                return Collections.unmodifiableList(seq);\n            }\n        }\n\n        // Need to support rdf:parseType=\"Resource\" here as well...\n        if (isResourceType(node)) {\n            return parseAsResource(node);\n        }\n\n        Node child = node.getFirstChild();\n        String strVal = child != null ? child.getNodeValue() : null;\n        return strVal != null ? strVal.trim() : \"\";\n    }\n\n    private Iterable<? extends Node> asIterable(final NamedNodeMap pNodeList) {\n        return new Iterable<Node>() {\n            public Iterator<Node> iterator() {\n                return new Iterator<Node>() {\n                    private int index;\n\n                    public boolean hasNext() {\n                        return pNodeList != null && pNodeList.getLength() > index;\n                    }\n\n                    public Node next() {\n                        return pNodeList.item(index++);\n                    }\n\n                    public void remove() {\n                        throw new UnsupportedOperationException(\"Method remove not supported\");\n                    }\n                };\n            }\n        };\n    }\n\n    private Iterable<? extends Node> asIterable(final NodeList pNodeList) {\n        return new Iterable<Node>() {\n            public Iterator<Node> iterator() {\n                return new Iterator<Node>() {\n                    private int index;\n\n                    public boolean hasNext() {\n                        return pNodeList != null && pNodeList.getLength() > index;\n                    }\n\n                    public Node next() {\n                        return pNodeList.item(index++);\n                    }\n\n                    public void remove() {\n                        throw new UnsupportedOperationException(\"Method remove not supported\");\n                    }\n                };\n            }\n        };\n    }\n}",
        "patch": "@@ -30,11 +30,21 @@\n \n package com.twelvemonkeys.imageio.metadata.xmp;\n \n-import com.twelvemonkeys.imageio.metadata.Directory;\n-import com.twelvemonkeys.imageio.metadata.Entry;\n-import com.twelvemonkeys.imageio.metadata.MetadataReader;\n-import com.twelvemonkeys.imageio.util.IIOUtil;\n-import com.twelvemonkeys.lang.Validate;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.imageio.IIOException;\n+import javax.imageio.stream.ImageInputStream;\n+import javax.xml.XMLConstants;\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.parsers.ParserConfigurationException;\n+\n import org.w3c.dom.Document;\n import org.w3c.dom.NamedNodeMap;\n import org.w3c.dom.Node;\n@@ -43,13 +53,11 @@\n import org.xml.sax.SAXException;\n import org.xml.sax.helpers.DefaultHandler;\n \n-import javax.imageio.IIOException;\n-import javax.imageio.stream.ImageInputStream;\n-import javax.xml.parsers.DocumentBuilder;\n-import javax.xml.parsers.DocumentBuilderFactory;\n-import javax.xml.parsers.ParserConfigurationException;\n-import java.io.IOException;\n-import java.util.*;\n+import com.twelvemonkeys.imageio.metadata.Directory;\n+import com.twelvemonkeys.imageio.metadata.Entry;\n+import com.twelvemonkeys.imageio.metadata.MetadataReader;\n+import com.twelvemonkeys.imageio.util.IIOUtil;\n+import com.twelvemonkeys.lang.Validate;\n \n /**\n  * XMPReader\n@@ -67,10 +75,9 @@ public final class XMPReader extends MetadataReader {\n     public Directory read(final ImageInputStream input) throws IOException {\n         Validate.notNull(input, \"input\");\n \n-        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n-        factory.setNamespaceAware(true);\n-\n         try {\n+            DocumentBuilderFactory factory = createDocumentBuilderFactory();\n+\n             // TODO: Consider parsing using SAX?\n             // TODO: Determine encoding and parse using a Reader...\n             // TODO: Refactor scanner to return inputstream?\n@@ -79,9 +86,6 @@ public Directory read(final ImageInputStream input) throws IOException {\n             builder.setErrorHandler(new DefaultHandler());\n             Document document = builder.parse(new InputSource(IIOUtil.createStreamAdapter(input)));\n \n-//            XMLSerializer serializer = new XMLSerializer(System.err, System.getProperty(\"file.encoding\"));\n-//            serializer.serialize(document);\n-\n             String toolkit = getToolkit(document);\n             Node rdfRoot = document.getElementsByTagNameNS(XMP.NS_RDF, \"RDF\").item(0);\n             NodeList descriptions = document.getElementsByTagNameNS(XMP.NS_RDF, \"Description\");\n@@ -92,10 +96,33 @@ public Directory read(final ImageInputStream input) throws IOException {\n             throw new IIOException(e.getMessage(), e);\n         }\n         catch (ParserConfigurationException e) {\n-            throw new RuntimeException(e); // TODO: Or IOException?\n+            throw new RuntimeException(e);\n         }\n     }\n \n+    private DocumentBuilderFactory createDocumentBuilderFactory() throws ParserConfigurationException {\n+        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n+        factory.setNamespaceAware(true);\n+\n+        // Security: Disable XInclude & expanding entity references (\"bombs\"), not needed for XMP\n+        factory.setXIncludeAware(false);\n+        factory.setExpandEntityReferences(false);\n+\n+        // Security: Enable \"secure processing\", to prevent DoS attacks\n+        factory.setAttribute(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n+\n+        // Security: Remove possibility to access external DTDs or Schema, not needed for XMP\n+        factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, \"\");\n+        factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_SCHEMA, \"\");\n+\n+        // Security: Disable loading of external DTD and entities, not needed for XMP\n+        factory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n+        factory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n+        factory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n+\n+        return factory;\n+    }\n+\n     private String getToolkit(Document document) {\n         NodeList xmpmeta = document.getElementsByTagNameNS(XMP.NS_X, \"xmpmeta\");\n \n@@ -109,7 +136,7 @@ private String getToolkit(Document document) {\n     }\n \n     private XMPDirectory parseDirectories(final Node pParentNode, NodeList pNodes, String toolkit) {\n-        Map<String, List<Entry>> subdirs = new LinkedHashMap<String, List<Entry>>();\n+        Map<String, List<Entry>> subdirs = new LinkedHashMap<>();\n \n         for (Node desc : asIterable(pNodes)) {\n             if (desc.getParentNode() != pParentNode) {\n@@ -127,7 +154,7 @@ private XMPDirectory parseDirectories(final Node pParentNode, NodeList pNodes, S\n                 // Lookup\n                 List<Entry> dir = subdirs.get(node.getNamespaceURI());\n                 if (dir == null) {\n-                    dir = new ArrayList<Entry>();\n+                    dir = new ArrayList<>();\n                     subdirs.put(node.getNamespaceURI(), dir);\n                 }\n \n@@ -139,7 +166,7 @@ private XMPDirectory parseDirectories(final Node pParentNode, NodeList pNodes, S\n                 else {\n                     // TODO: This method contains loads of duplication an should be cleaned up...\n                     // Support attribute short-hand syntax\n-                    Map<String, List<Entry>> subsubdirs = new LinkedHashMap<String, List<Entry>>();\n+                    Map<String, List<Entry>> subsubdirs = new LinkedHashMap<>();\n \n                     parseAttributesForKnownElements(subsubdirs, node);\n \n@@ -161,7 +188,7 @@ private XMPDirectory parseDirectories(final Node pParentNode, NodeList pNodes, S\n             }\n         }\n \n-        List<Directory> entries = new ArrayList<Directory>(subdirs.size());\n+        List<Directory> entries = new ArrayList<>(subdirs.size());\n \n         // TODO: Should we still allow asking for a subdirectory by item id?\n         for (Map.Entry<String, List<Entry>> entry : subdirs.entrySet()) {\n@@ -179,7 +206,7 @@ private boolean isResourceType(Node node) {\n \n     private RDFDescription parseAsResource(Node node) {\n         // See: http://www.w3.org/TR/REC-rdf-syntax/#section-Syntax-parsetype-resource\n-        List<Entry> entries = new ArrayList<Entry>();\n+        List<Entry> entries = new ArrayList<>();\n \n         for (Node child : asIterable(node.getChildNodes())) {\n             if (child.getNodeType() != Node.ELEMENT_NODE) {\n@@ -204,7 +231,7 @@ private void parseAttributesForKnownElements(Map<String, List<Entry>> subdirs, N\n             List<Entry> dir = subdirs.get(attr.getNamespaceURI());\n \n             if (dir == null) {\n-                dir = new ArrayList<Entry>();\n+                dir = new ArrayList<>();\n                 subdirs.put(attr.getNamespaceURI(), dir);\n             }\n \n@@ -216,7 +243,7 @@ private Object getChildTextValue(final Node node) {\n         for (Node child : asIterable(node.getChildNodes())) {\n             if (XMP.NS_RDF.equals(child.getNamespaceURI()) && \"Alt\".equals(child.getLocalName())) {\n                 // Support for <rdf:Alt><rdf:li> -> return a Map<String, Object> keyed on xml:lang\n-                Map<String, Object> alternatives = new LinkedHashMap<String, Object>();\n+                Map<String, Object> alternatives = new LinkedHashMap<>();\n                 for (Node alternative : asIterable(child.getChildNodes())) {\n                     if (XMP.NS_RDF.equals(alternative.getNamespaceURI()) && \"li\".equals(alternative.getLocalName())) {\n                         NamedNodeMap attributes = alternative.getAttributes();\n@@ -230,7 +257,7 @@ private Object getChildTextValue(final Node node) {\n             else if (XMP.NS_RDF.equals(child.getNamespaceURI()) && (\"Seq\".equals(child.getLocalName()) || \"Bag\".equals(child.getLocalName()))) {\n                 // Support for <rdf:Seq><rdf:li> -> return array\n                 // Support for <rdf:Bag><rdf:li> -> return array/unordered collection (how can a serialized collection not have order?)\n-                List<Object> seq = new ArrayList<Object>();\n+                List<Object> seq = new ArrayList<>();\n \n                 for (Node sequence : asIterable(child.getChildNodes())) {\n                     if (XMP.NS_RDF.equals(sequence.getNamespaceURI()) && \"li\".equals(sequence.getLocalName())) {",
        "function_modified_lines": {
            "added": [
                "            DocumentBuilderFactory factory = createDocumentBuilderFactory();\n",
                "\n",
                "            throw new RuntimeException(e);\n",
                "    private DocumentBuilderFactory createDocumentBuilderFactory() throws ParserConfigurationException {\n",
                "        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n",
                "        factory.setNamespaceAware(true);\n",
                "\n",
                "        // Security: Disable XInclude & expanding entity references (\"bombs\"), not needed for XMP\n",
                "        factory.setXIncludeAware(false);\n",
                "        factory.setExpandEntityReferences(false);\n",
                "\n",
                "        // Security: Enable \"secure processing\", to prevent DoS attacks\n",
                "        factory.setAttribute(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n",
                "\n",
                "        // Security: Remove possibility to access external DTDs or Schema, not needed for XMP\n",
                "        factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, \"\");\n",
                "        factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_SCHEMA, \"\");\n",
                "\n",
                "        // Security: Disable loading of external DTD and entities, not needed for XMP\n",
                "        factory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n",
                "        factory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n",
                "        factory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n",
                "\n",
                "        return factory;\n",
                "    }\n",
                "\n"
            ],
            "deleted": [
                "        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n",
                "        factory.setNamespaceAware(true);\n",
                "\n",
                "//            XMLSerializer serializer = new XMLSerializer(System.err, System.getProperty(\"file.encoding\"));\n",
                "//            serializer.serialize(document);\n",
                "\n",
                "            throw new RuntimeException(e); // TODO: Or IOException?\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-611"
        ],
        "cve_description": "The package com.twelvemonkeys.imageio:imageio-metadata before 3.7.1 are vulnerable to XML External Entity (XXE) Injection due to an insecurely initialized XML parser for reading XMP Metadata. An attacker can exploit this vulnerability if they are able to supply a file (e.g. when an online profile picture is processed) with a malicious XMP segment. If the XMP metadata of the uploaded image is parsed, then the XXE vulnerability is triggered.",
        "id": 12212
    },
    {
        "cve_id": "CVE-2021-27736",
        "code_before_change": "      return Base64.getEncoder().encodeToString(xml.getBytes(StandardCharsets.UTF_8));\n    } catch (Exception e) {\n      throw new SAMLException(\"Unable to sign XML SAML response\", e);\n    }\n  }\n\n  private String buildRedirectAuthnRequest(AuthnRequestType authnRequest, String relayState, boolean sign,\n                                           PrivateKey key, Algorithm algorithm) throws SAMLException {\n    try {\n      byte[] xml = marshallToBytes(PROTOCOL_OBJECT_FACTORY.createAuthnRequest(authnRequest), AuthnRequestType.class);\n      String encodedResult = deflateAndEncode(xml);\n      String parameters = \"SAMLRequest=\" + URLEncoder.encode(encodedResult, \"UTF-8\");\n      if (relayState != null) {\n        parameters += \"&RelayState=\" + URLEncoder.encode(relayState, \"UTF-8\");\n      }\n\n      if (sign && key != null && algorithm != null) {\n        Signature signature;\n        parameters += \"&SigAlg=\" + URLEncoder.encode(algorithm.uri, \"UTF-8\");\n        signature = Signature.getInstance(algorithm.name);\n        signature.initSign(key);\n        signature.update(parameters.getBytes(StandardCharsets.UTF_8));\n\n        String signatureParameter = Base64.getEncoder().encodeToString(signature.sign());\n        parameters += \"&Signature=\" + URLEncoder.encode(signatureParameter, \"UTF-8\");\n      }\n\n      return parameters;\n    } catch (Exception e) {\n      // Not possible but freak out\n      throw new SAMLException(e);\n    }\n  }\n\n  private ZonedDateTime convertToZonedDateTime(XMLGregorianCalendar cal) {\n    return cal != null ? cal.toGregorianCalendar().toZonedDateTime() : null;\n  }\n\n  private byte[] decodeAndInflate(String encodedRequest) throws SAMLException {\n    byte[] bytes = Base64.getMimeDecoder().decode(encodedRequest);\n    Inflater inflater = new Inflater(true);\n    inflater.setInput(bytes);\n    inflater.finished();\n\n    try {\n      ByteArrayOutputStream baos = new ByteArrayOutputStream();\n      byte[] result = new byte[bytes.length];\n      while (!inflater.finished()) {\n        int length = inflater.inflate(result);\n        if (length > 0) {\n          baos.write(result, 0, length);\n        }\n      }\n\n      return baos.toByteArray();\n    } catch (DataFormatException e) {\n      throw new SAMLException(\"Invalid AuthnRequest. Inflating the bytes failed.\", e);\n    }\n  }\n\n  private String deflateAndEncode(byte[] result) {\n    Deflater deflater = new Deflater(Deflater.DEFLATED, true);\n    deflater.setInput(result);\n    deflater.finish();\n    byte[] deflatedResult = new byte[result.length];\n    int length = deflater.deflate(deflatedResult);\n    deflater.end();\n    byte[] src = Arrays.copyOf(deflatedResult, length);\n    return Base64.getEncoder().encodeToString(src);\n  }\n\n  private void fixIDs(Element element) {\n    NamedNodeMap attributes = element.getAttributes();\n    for (int i = 0; i < attributes.getLength(); i++) {\n      Attr attribute = (Attr) attributes.item(i);\n      if (attribute.getLocalName().equalsIgnoreCase(\"id\")) {\n        element.setIdAttributeNode(attribute, true);\n      }\n    }\n\n    NodeList children = element.getChildNodes();\n    for (int i = 0; i < children.getLength(); i++) {\n      Node child = children.item(i);\n      if (child.getNodeType() == Node.ELEMENT_NODE) {\n        fixIDs((Element) child);\n      }\n    }\n  }\n\n  private <T> byte[] marshallToBytes(JAXBElement<T> object, Class<T> type) throws SAMLException {\n    try {\n      JAXBContext context = JAXBContext.newInstance(type);\n      Marshaller marshaller = context.createMarshaller();\n      ByteArrayOutputStream baos = new ByteArrayOutputStream();\n      marshaller.marshal(object, baos);\n      return baos.toByteArray();\n    } catch (JAXBException e) {\n      throw new SAMLException(\"Unable to marshallRequest JAXB SAML object to bytes.\", e);\n    }\n  }\n\n  @SuppressWarnings(\"SameParameterValue\")\n  private <T> Document marshallToDocument(JAXBElement<T> object, Class<T> type) throws SAMLException {\n    try {\n      JAXBContext context = JAXBContext.newInstance(type);\n      Marshaller marshaller = context.createMarshaller();\n      DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();",
        "code_after_change": "      }\n\n      return Base64.getEncoder().encodeToString(xml.getBytes(StandardCharsets.UTF_8));\n    } catch (Exception e) {\n      throw new SAMLException(\"Unable to sign XML SAML response\", e);\n    }\n  }\n\n  private String buildRedirectAuthnRequest(AuthnRequestType authnRequest, String relayState, boolean sign,\n                                           PrivateKey key, Algorithm algorithm) throws SAMLException {\n    try {\n      byte[] xml = marshallToBytes(PROTOCOL_OBJECT_FACTORY.createAuthnRequest(authnRequest), AuthnRequestType.class);\n      String encodedResult = SAMLTools.deflateAndEncode(xml);\n      String parameters = \"SAMLRequest=\" + URLEncoder.encode(encodedResult, \"UTF-8\");\n      if (relayState != null) {\n        parameters += \"&RelayState=\" + URLEncoder.encode(relayState, \"UTF-8\");\n      }\n\n      if (sign && key != null && algorithm != null) {\n        Signature signature;\n        parameters += \"&SigAlg=\" + URLEncoder.encode(algorithm.uri, \"UTF-8\");\n        signature = Signature.getInstance(algorithm.name);\n        signature.initSign(key);\n        signature.update(parameters.getBytes(StandardCharsets.UTF_8));\n\n        String signatureParameter = Base64.getEncoder().encodeToString(signature.sign());\n        parameters += \"&Signature=\" + URLEncoder.encode(signatureParameter, \"UTF-8\");\n      }\n\n      return parameters;\n    } catch (Exception e) {\n      // Not possible but freak out\n      throw new SAMLException(e);\n    }\n  }\n\n  private void fixIDs(Element element) {\n    NamedNodeMap attributes = element.getAttributes();\n    for (int i = 0; i < attributes.getLength(); i++) {\n      Attr attribute = (Attr) attributes.item(i);\n      if (attribute.getLocalName().equalsIgnoreCase(\"id\")) {\n        element.setIdAttributeNode(attribute, true);\n      }\n    }\n\n    NodeList children = element.getChildNodes();\n    for (int i = 0; i < children.getLength(); i++) {\n      Node child = children.item(i);\n      if (child.getNodeType() == Node.ELEMENT_NODE) {\n        fixIDs((Element) child);\n      }\n    }\n  }\n\n  private SubjectConfirmation parseConfirmation(SubjectConfirmationType subjectConfirmationType) {\n    SubjectConfirmation subjectConfirmation = new SubjectConfirmation();\n    SubjectConfirmationDataType data = subjectConfirmationType.getSubjectConfirmationData();\n    if (data != null) {\n      subjectConfirmation.address = data.getAddress();\n      subjectConfirmation.inResponseTo = data.getInResponseTo();\n      subjectConfirmation.notBefore = toZonedDateTime(data.getNotBefore());\n      subjectConfirmation.notOnOrAfter = toZonedDateTime(data.getNotOnOrAfter());\n      subjectConfirmation.recipient = data.getRecipient();\n    }\n\n    subjectConfirmation.method = ConfirmationMethod.fromSAMLFormat(subjectConfirmationType.getMethod());\n\n    return subjectConfirmation;\n  }\n\n  private AuthnRequestParseResult parseRequest(byte[] xmlBytes) throws SAMLException {\n    String xml = new String(xmlBytes, StandardCharsets.UTF_8);\n    if (logger.isDebugEnabled()) {\n      logger.debug(\"SAMLRequest XML is\\n{}\", xml);",
        "patch": "@@ -15,11 +15,7 @@\n  */\n package io.fusionauth.samlv2.service;\n \n-import javax.xml.bind.JAXBContext;\n import javax.xml.bind.JAXBElement;\n-import javax.xml.bind.JAXBException;\n-import javax.xml.bind.Marshaller;\n-import javax.xml.bind.Unmarshaller;\n import javax.xml.crypto.KeySelector;\n import javax.xml.crypto.MarshalException;\n import javax.xml.crypto.dsig.CanonicalizationMethod;\n@@ -37,19 +33,7 @@\n import javax.xml.crypto.dsig.keyinfo.X509Data;\n import javax.xml.crypto.dsig.spec.C14NMethodParameterSpec;\n import javax.xml.crypto.dsig.spec.TransformParameterSpec;\n-import javax.xml.datatype.XMLGregorianCalendar;\n-import javax.xml.parsers.DocumentBuilder;\n-import javax.xml.parsers.DocumentBuilderFactory;\n-import javax.xml.parsers.ParserConfigurationException;\n-import javax.xml.transform.Transformer;\n import javax.xml.transform.TransformerException;\n-import javax.xml.transform.TransformerFactory;\n-import javax.xml.transform.dom.DOMSource;\n-import javax.xml.transform.stream.StreamResult;\n-import java.io.ByteArrayInputStream;\n-import java.io.ByteArrayOutputStream;\n-import java.io.IOException;\n-import java.io.StringWriter;\n import java.io.UnsupportedEncodingException;\n import java.net.URLEncoder;\n import java.nio.charset.StandardCharsets;\n@@ -59,8 +43,6 @@\n import java.security.PrivateKey;\n import java.security.Signature;\n import java.security.cert.Certificate;\n-import java.security.cert.CertificateException;\n-import java.security.cert.CertificateFactory;\n import java.security.cert.X509Certificate;\n import java.time.ZoneOffset;\n import java.time.ZonedDateTime;\n@@ -75,9 +57,6 @@\n import java.util.UUID;\n import java.util.function.Function;\n import java.util.stream.Collectors;\n-import java.util.zip.DataFormatException;\n-import java.util.zip.Deflater;\n-import java.util.zip.Inflater;\n \n import com.sun.org.apache.xerces.internal.jaxp.datatype.XMLGregorianCalendarImpl;\n import io.fusionauth.samlv2.domain.Algorithm;\n@@ -89,7 +68,6 @@\n import io.fusionauth.samlv2.domain.MetaData;\n import io.fusionauth.samlv2.domain.MetaData.IDPMetaData;\n import io.fusionauth.samlv2.domain.MetaData.SPMetaData;\n-import io.fusionauth.samlv2.domain.NameID;\n import io.fusionauth.samlv2.domain.NameIDFormat;\n import io.fusionauth.samlv2.domain.ResponseStatus;\n import io.fusionauth.samlv2.domain.SAMLException;\n@@ -128,6 +106,7 @@\n import io.fusionauth.samlv2.domain.jaxb.oasis.protocol.StatusType;\n import io.fusionauth.samlv2.domain.jaxb.w3c.xmldsig.KeyInfoType;\n import io.fusionauth.samlv2.domain.jaxb.w3c.xmldsig.X509DataType;\n+import io.fusionauth.samlv2.util.SAMLTools;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.w3c.dom.Attr;\n@@ -136,7 +115,16 @@\n import org.w3c.dom.NamedNodeMap;\n import org.w3c.dom.Node;\n import org.w3c.dom.NodeList;\n-import org.xml.sax.SAXException;\n+import static io.fusionauth.samlv2.util.SAMLTools.convertToZonedDateTime;\n+import static io.fusionauth.samlv2.util.SAMLTools.decodeAndInflate;\n+import static io.fusionauth.samlv2.util.SAMLTools.marshallToBytes;\n+import static io.fusionauth.samlv2.util.SAMLTools.marshallToDocument;\n+import static io.fusionauth.samlv2.util.SAMLTools.marshallToString;\n+import static io.fusionauth.samlv2.util.SAMLTools.newDocumentFromBytes;\n+import static io.fusionauth.samlv2.util.SAMLTools.parseNameId;\n+import static io.fusionauth.samlv2.util.SAMLTools.toXMLGregorianCalendar;\n+import static io.fusionauth.samlv2.util.SAMLTools.toZonedDateTime;\n+import static io.fusionauth.samlv2.util.SAMLTools.unmarshallFromDocument;\n \n /**\n  * Default implementation of the SAML service.\n@@ -411,7 +399,7 @@ public String buildRedirectAuthnRequest(AuthenticationRequest request, String re\n \n   @Override\n   public MetaData parseMetaData(String metaDataXML) throws SAMLException {\n-    Document document = parseFromBytes(metaDataXML.getBytes(StandardCharsets.UTF_8));\n+    Document document = newDocumentFromBytes(metaDataXML.getBytes(StandardCharsets.UTF_8));\n     EntityDescriptorType root = unmarshallFromDocument(document, EntityDescriptorType.class);\n     MetaData metaData = new MetaData();\n     metaData.id = root.getID();\n@@ -450,7 +438,7 @@ public MetaData parseMetaData(String metaDataXML) throws SAMLException {\n         metaData.idp.certificates = idp.getKeyDescriptor()\n                                        .stream()\n                                        .filter(kd -> kd.getUse() == KeyTypes.SIGNING)\n-                                       .map(this::toCertificate)\n+                                       .map(SAMLTools::toCertificate)\n                                        .filter(Objects::nonNull)\n                                        .collect(Collectors.toList());\n       } catch (IllegalArgumentException e) {\n@@ -532,7 +520,7 @@ public AuthenticationResponse parseResponse(String encodedResponse, boolean veri\n     byte[] decodedResponse = Base64.getMimeDecoder().decode(encodedResponse);\n     response.rawResponse = new String(decodedResponse, StandardCharsets.UTF_8);\n \n-    Document document = parseFromBytes(decodedResponse);\n+    Document document = newDocumentFromBytes(decodedResponse);\n     if (verifySignature) {\n       verifySignature(document, keySelector);\n     }\n@@ -613,7 +601,7 @@ public AuthenticationResponse parseResponse(String encodedResponse, boolean veri\n               AttributeType attributeType = (AttributeType) attributeObject;\n               String name = attributeType.getName();\n               List<Object> attributeValues = attributeType.getAttributeValue();\n-              List<String> values = attributeValues.stream().map(this::attributeToString).collect(Collectors.toList());\n+              List<String> values = attributeValues.stream().map(SAMLTools::attributeToString).collect(Collectors.toList());\n               response.assertion.attributes.computeIfAbsent(name, k -> new ArrayList<>()).addAll(values);\n             } else {\n               throw new SAMLException(\"This library currently doesn't support encrypted attributes\");\n@@ -646,24 +634,6 @@ private void addKeyDescriptors(SSODescriptorType descriptor, List<Certificate> c\n     });\n   }\n \n-  private String attributeToString(Object attribute) {\n-    if (attribute == null) {\n-      return null;\n-    }\n-\n-    if (attribute instanceof Number) {\n-      return attribute.toString();\n-    } else if (attribute instanceof String) {\n-      return (String) attribute;\n-    } else if (attribute instanceof Element) {\n-      return ((Element) attribute).getTextContent();\n-    } else {\n-      logger.warn(\"This library currently doesn't handle attributes of type [\" + attribute.getClass() + \"]\");\n-    }\n-\n-    return null;\n-  }\n-\n   private String buildPostAuthnRequest(AuthnRequestType authnRequest, boolean sign, PrivateKey privateKey,\n                                        X509Certificate certificate,\n                                        Algorithm algorithm, String xmlSignatureC14nMethod) throws SAMLException {\n@@ -687,7 +657,7 @@ private String buildRedirectAuthnRequest(AuthnRequestType authnRequest, String r\n                                            PrivateKey key, Algorithm algorithm) throws SAMLException {\n     try {\n       byte[] xml = marshallToBytes(PROTOCOL_OBJECT_FACTORY.createAuthnRequest(authnRequest), AuthnRequestType.class);\n-      String encodedResult = deflateAndEncode(xml);\n+      String encodedResult = SAMLTools.deflateAndEncode(xml);\n       String parameters = \"SAMLRequest=\" + URLEncoder.encode(encodedResult, \"UTF-8\");\n       if (relayState != null) {\n         parameters += \"&RelayState=\" + URLEncoder.encode(relayState, \"UTF-8\");\n@@ -711,43 +681,6 @@ private String buildRedirectAuthnRequest(AuthnRequestType authnRequest, String r\n     }\n   }\n \n-  private ZonedDateTime convertToZonedDateTime(XMLGregorianCalendar cal) {\n-    return cal != null ? cal.toGregorianCalendar().toZonedDateTime() : null;\n-  }\n-\n-  private byte[] decodeAndInflate(String encodedRequest) throws SAMLException {\n-    byte[] bytes = Base64.getMimeDecoder().decode(encodedRequest);\n-    Inflater inflater = new Inflater(true);\n-    inflater.setInput(bytes);\n-    inflater.finished();\n-\n-    try {\n-      ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-      byte[] result = new byte[bytes.length];\n-      while (!inflater.finished()) {\n-        int length = inflater.inflate(result);\n-        if (length > 0) {\n-          baos.write(result, 0, length);\n-        }\n-      }\n-\n-      return baos.toByteArray();\n-    } catch (DataFormatException e) {\n-      throw new SAMLException(\"Invalid AuthnRequest. Inflating the bytes failed.\", e);\n-    }\n-  }\n-\n-  private String deflateAndEncode(byte[] result) {\n-    Deflater deflater = new Deflater(Deflater.DEFLATED, true);\n-    deflater.setInput(result);\n-    deflater.finish();\n-    byte[] deflatedResult = new byte[result.length];\n-    int length = deflater.deflate(deflatedResult);\n-    deflater.end();\n-    byte[] src = Arrays.copyOf(deflatedResult, length);\n-    return Base64.getEncoder().encodeToString(src);\n-  }\n-\n   private void fixIDs(Element element) {\n     NamedNodeMap attributes = element.getAttributes();\n     for (int i = 0; i < attributes.getLength(); i++) {\n@@ -766,42 +699,6 @@ private void fixIDs(Element element) {\n     }\n   }\n \n-  private <T> byte[] marshallToBytes(JAXBElement<T> object, Class<T> type) throws SAMLException {\n-    try {\n-      JAXBContext context = JAXBContext.newInstance(type);\n-      Marshaller marshaller = context.createMarshaller();\n-      ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-      marshaller.marshal(object, baos);\n-      return baos.toByteArray();\n-    } catch (JAXBException e) {\n-      throw new SAMLException(\"Unable to marshallRequest JAXB SAML object to bytes.\", e);\n-    }\n-  }\n-\n-  @SuppressWarnings(\"SameParameterValue\")\n-  private <T> Document marshallToDocument(JAXBElement<T> object, Class<T> type) throws SAMLException {\n-    try {\n-      JAXBContext context = JAXBContext.newInstance(type);\n-      Marshaller marshaller = context.createMarshaller();\n-      DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n-      dbf.setNamespaceAware(true);\n-      DocumentBuilder db = dbf.newDocumentBuilder();\n-      Document document = db.newDocument();\n-      marshaller.marshal(object, document);\n-      return document;\n-    } catch (JAXBException | ParserConfigurationException e) {\n-      throw new SAMLException(\"Unable to marshallRequest JAXB SAML object to DOM.\", e);\n-    }\n-  }\n-\n-  private String marshallToString(Document document) throws TransformerException {\n-    StringWriter sw = new StringWriter();\n-    TransformerFactory tf = TransformerFactory.newInstance();\n-    Transformer transformer = tf.newTransformer();\n-    transformer.transform(new DOMSource(document), new StreamResult(sw));\n-    return sw.toString();\n-  }\n-\n   private SubjectConfirmation parseConfirmation(SubjectConfirmationType subjectConfirmationType) {\n     SubjectConfirmation subjectConfirmation = new SubjectConfirmation();\n     SubjectConfirmationDataType data = subjectConfirmationType.getSubjectConfirmationData();\n@@ -818,32 +715,14 @@ private SubjectConfirmation parseConfirmation(SubjectConfirmationType subjectCon\n     return subjectConfirmation;\n   }\n \n-  private Document parseFromBytes(byte[] bytes) throws SAMLException {\n-    DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n-    documentBuilderFactory.setNamespaceAware(true);\n-    try {\n-      DocumentBuilder builder = documentBuilderFactory.newDocumentBuilder();\n-      return builder.parse(new ByteArrayInputStream(bytes));\n-    } catch (ParserConfigurationException | SAXException | IOException e) {\n-      throw new SAMLException(\"Unable to parse SAML v2.0 authentication response\", e);\n-    }\n-  }\n-\n-  private NameID parseNameId(NameIDType element) {\n-    NameID nameId = new NameID();\n-    nameId.format = NameIDFormat.fromSAMLFormat(element.getFormat());\n-    nameId.id = element.getValue();\n-    return nameId;\n-  }\n-\n   private AuthnRequestParseResult parseRequest(byte[] xmlBytes) throws SAMLException {\n     String xml = new String(xmlBytes, StandardCharsets.UTF_8);\n     if (logger.isDebugEnabled()) {\n       logger.debug(\"SAMLRequest XML is\\n{}\", xml);\n     }\n \n     AuthnRequestParseResult result = new AuthnRequestParseResult();\n-    result.document = parseFromBytes(xmlBytes);\n+    result.document = newDocumentFromBytes(xmlBytes);\n     result.authnRequest = unmarshallFromDocument(result.document, AuthnRequestType.class);\n     result.request = new AuthenticationRequest();\n     result.request.xml = xml;\n@@ -907,60 +786,6 @@ private AuthnRequestType toAuthnRequest(AuthenticationRequest request, String ve\n     return authnRequest;\n   }\n \n-  private Certificate toCertificate(KeyDescriptorType keyDescriptorType) {\n-    try {\n-      List<Object> keyData = keyDescriptorType.getKeyInfo().getContent();\n-      for (Object keyDatum : keyData) {\n-        if (keyDatum instanceof JAXBElement<?>) {\n-          JAXBElement<?> element = (JAXBElement<?>) keyDatum;\n-          if (element.getDeclaredType() == X509DataType.class) {\n-            X509DataType cert = (X509DataType) element.getValue();\n-            List<Object> certData = cert.getX509IssuerSerialOrX509SKIOrX509SubjectName();\n-            for (Object certDatum : certData) {\n-              element = (JAXBElement<?>) certDatum;\n-              if (element.getName().getLocalPart().equals(\"X509Certificate\")) {\n-                byte[] certBytes = (byte[]) element.getValue();\n-                CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n-                return cf.generateCertificate(new ByteArrayInputStream(certBytes));\n-              }\n-            }\n-          }\n-        }\n-      }\n-\n-      return null;\n-    } catch (CertificateException e) {\n-      throw new IllegalArgumentException(e);\n-    }\n-  }\n-\n-  private XMLGregorianCalendar toXMLGregorianCalendar(ZonedDateTime instant) {\n-    if (instant == null) {\n-      return null;\n-    }\n-\n-    return new XMLGregorianCalendarImpl(GregorianCalendar.from(instant));\n-  }\n-\n-  private ZonedDateTime toZonedDateTime(XMLGregorianCalendar instant) {\n-    if (instant == null) {\n-      return null;\n-    }\n-\n-    return instant.toGregorianCalendar().toZonedDateTime();\n-  }\n-\n-  private <T> T unmarshallFromDocument(Document document, Class<T> type) throws SAMLException {\n-    try {\n-      JAXBContext context = JAXBContext.newInstance(type);\n-      Unmarshaller unmarshaller = context.createUnmarshaller();\n-      JAXBElement<T> element = unmarshaller.unmarshal(document, type);\n-      return element.getValue();\n-    } catch (JAXBException e) {\n-      throw new SAMLException(\"Unable to unmarshall SAML response\", e);\n-    }\n-  }\n-\n   private void verifySignature(Document document, KeySelector keySelector) throws SAMLException {\n     // Fix the IDs in the entire document per the suggestions at http://stackoverflow.com/questions/17331187/xml-dig-sig-error-after-upgrade-to-java7u25\n     fixIDs(document.getDocumentElement());",
        "function_modified_lines": {
            "added": [],
            "deleted": [
                "  private ZonedDateTime convertToZonedDateTime(XMLGregorianCalendar cal) {\n",
                "    return cal != null ? cal.toGregorianCalendar().toZonedDateTime() : null;\n",
                "  }\n",
                "\n",
                "  private byte[] decodeAndInflate(String encodedRequest) throws SAMLException {\n",
                "    byte[] bytes = Base64.getMimeDecoder().decode(encodedRequest);\n",
                "    Inflater inflater = new Inflater(true);\n",
                "    inflater.setInput(bytes);\n",
                "    inflater.finished();\n",
                "\n",
                "    try {\n",
                "      ByteArrayOutputStream baos = new ByteArrayOutputStream();\n",
                "      byte[] result = new byte[bytes.length];\n",
                "      while (!inflater.finished()) {\n",
                "        int length = inflater.inflate(result);\n",
                "        if (length > 0) {\n",
                "          baos.write(result, 0, length);\n",
                "        }\n",
                "      }\n",
                "\n",
                "      return baos.toByteArray();\n",
                "    } catch (DataFormatException e) {\n",
                "      throw new SAMLException(\"Invalid AuthnRequest. Inflating the bytes failed.\", e);\n",
                "    }\n",
                "  }\n",
                "\n",
                "  private String deflateAndEncode(byte[] result) {\n",
                "    Deflater deflater = new Deflater(Deflater.DEFLATED, true);\n",
                "    deflater.setInput(result);\n",
                "    deflater.finish();\n",
                "    byte[] deflatedResult = new byte[result.length];\n",
                "    int length = deflater.deflate(deflatedResult);\n",
                "    deflater.end();\n",
                "    byte[] src = Arrays.copyOf(deflatedResult, length);\n",
                "    return Base64.getEncoder().encodeToString(src);\n",
                "  }\n",
                "\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-611"
        ],
        "cve_description": "FusionAuth fusionauth-samlv2 before 0.5.4 allows XXE attacks via a forged AuthnRequest or LogoutRequest because parseFromBytes uses javax.xml.parsers.DocumentBuilderFactory unsafely.",
        "id": 12242
    },
    {
        "cve_id": "CVE-2022-24898",
        "code_before_change": "\n    /** Regular expression recognizing XML-escaped \"single quote\" characters. */\n    private static final Pattern APOS_PATTERN = Pattern.compile(\"&(?:apos|#0*+39|#x0*+27);\");\n\n    /** XML encoding of the \"double quote\" character. */\n    private static final String QUOT = \"&#34;\";\n\n    /** Regular expression recognizing XML-escaped \"double quote\" characters. */\n    private static final Pattern QUOT_PATTERN = Pattern.compile(\"&(?:quot|#0*+34|#x0*+22);\");\n\n    /** XML encoding of the \"left curly bracket\". */\n    private static final String LCURL = \"&#123;\";\n\n    /** Regular expression recognizing XML-escaped \"left curly bracket\" characters. */\n    private static final Pattern LCURL_PATTERN = Pattern.compile(\"&(?:#0*+123|#x0*+7[bB]);\");\n\n    /** XML encoding of the \"less than\" character. */\n    private static final String LT = \"&#60;\";\n\n    /** Regular expression recognizing XML-escaped \"less than\" characters. */\n    private static final Pattern LT_PATTERN = Pattern.compile(\"&(?:lt|#0*+60|#x0*+3[cC]);\");\n\n    /** XML encoding of the \"greater than\" character. */\n    private static final String GT = \"&#62;\";\n\n    /** Regular expression recognizing XML-escaped \"greater than\" characters. */\n    private static final Pattern GT_PATTERN = Pattern.compile(\"&(?:gt|#0*+62|#x0*+3[eE]);\");\n\n    private static final char[] ELEMENT_SYNTAX = new char[] {'<', '&'};\n\n    /** Helper object for manipulating DOM Level 3 Load and Save APIs. */\n    private static final DOMImplementationLS LS_IMPL;\n\n    /** Xerces configuration parameter for disabling fetching and checking XMLs against their DTD. */\n    private static final String DISABLE_DTD_PARAM = \"http://apache.org/xml/features/nonvalidating/load-external-dtd\";\n\n    static {\n        DOMImplementationLS implementation = null;\n        try {\n            implementation =\n                (DOMImplementationLS) DOMImplementationRegistry.newInstance().getDOMImplementation(\"LS 3.0\");\n        } catch (Exception ex) {\n            LOGGER.warn(\"Cannot initialize the XML Script Service: [{}]\", ex.getMessage());\n        }\n        LS_IMPL = implementation;\n    }\n\n    /**\n     * Private constructor since this is a utility class that shouldn't be instantiated (all methods are static).\n     */\n    private XMLUtils()\n    {\n        // Nothing to do\n    }\n\n    /**\n     * Extracts a well-formed XML fragment from the given DOM tree.\n     *\n     * @param node the root of the DOM tree where the extraction takes place\n     * @param start the index of the first character\n     * @param length the maximum number of characters in text nodes to include in the returned fragment\n     * @return a well-formed XML fragment starting at the given character index and having up to the specified length,\n     *         summing only the characters in text nodes\n     * @since 1.6M2\n     */\n    public static String extractXML(Node node, int start, int length)\n    {\n        ExtractHandler handler = null;\n        try {\n            handler = new ExtractHandler(start, length);\n            Transformer xformer = TransformerFactory.newInstance().newTransformer();\n            xformer.transform(new DOMSource(node), new SAXResult(handler));\n            return handler.getResult();\n        } catch (Throwable t) {",
        "code_after_change": "    private static final Pattern APOS_PATTERN = Pattern.compile(\"&(?:apos|#0*+39|#x0*+27);\");\n\n    /** XML encoding of the \"double quote\" character. */\n    private static final String QUOT = \"&#34;\";\n\n    /** Regular expression recognizing XML-escaped \"double quote\" characters. */\n    private static final Pattern QUOT_PATTERN = Pattern.compile(\"&(?:quot|#0*+34|#x0*+22);\");\n\n    /** XML encoding of the \"left curly bracket\". */\n    private static final String LCURL = \"&#123;\";\n\n    /** Regular expression recognizing XML-escaped \"left curly bracket\" characters. */\n    private static final Pattern LCURL_PATTERN = Pattern.compile(\"&(?:#0*+123|#x0*+7[bB]);\");\n\n    /** XML encoding of the \"less than\" character. */\n    private static final String LT = \"&#60;\";\n\n    /** Regular expression recognizing XML-escaped \"less than\" characters. */\n    private static final Pattern LT_PATTERN = Pattern.compile(\"&(?:lt|#0*+60|#x0*+3[cC]);\");\n\n    /** XML encoding of the \"greater than\" character. */\n    private static final String GT = \"&#62;\";\n\n    /** Regular expression recognizing XML-escaped \"greater than\" characters. */\n    private static final Pattern GT_PATTERN = Pattern.compile(\"&(?:gt|#0*+62|#x0*+3[eE]);\");\n\n    private static final char[] ELEMENT_SYNTAX = new char[] {'<', '&'};\n\n    /** Helper object for manipulating DOM Level 3 Load and Save APIs. */\n    private static final DOMImplementationLS LS_IMPL;\n\n    /** Xerces configuration parameter for disabling fetching and checking XMLs against their DTD. */\n    private static final String DISABLE_DTD_PARAM = \"http://apache.org/xml/features/nonvalidating/load-external-dtd\";\n\n    /** Xerces configuration parameter for prevent DOCTYPE definition. */\n    private static final String DISABLE_EXTERNAL_DOCTYPE_DECLARATION =\n        \"http://apache.org/xml/features/disallow-doctype-decl\";\n\n    /** Xerces configuration parameter for disabling inserting entities defined in external files. */\n    private static final String DISABLE_EXTERNAL_PARAMETER_ENTITIES =\n        \"http://xml.org/sax/features/external-parameter-entities\";\n\n    /** Xerces configuration parameter for disabling inserting entities defined in external files. */\n    private static final String DISABLE_EXTERNAL_GENERAL_ENTITIES =\n        \"http://xml.org/sax/features/external-general-entities\";\n\n    static {\n        DOMImplementationLS implementation = null;\n        try {\n            implementation =\n                (DOMImplementationLS) DOMImplementationRegistry.newInstance().getDOMImplementation(\"LS 3.0\");\n        } catch (Exception ex) {\n            LOGGER.warn(\"Cannot initialize the XML Script Service: [{}]\", ex.getMessage());\n        }\n        LS_IMPL = implementation;\n    }\n\n    /**\n     * Private constructor since this is a utility class that shouldn't be instantiated (all methods are static).\n     */\n    private XMLUtils()\n    {\n        // Nothing to do\n    }\n\n    /**\n     * Extracts a well-formed XML fragment from the given DOM tree.\n     *\n     * @param node the root of the DOM tree where the extraction takes place\n     * @param start the index of the first character\n     * @param length the maximum number of characters in text nodes to include in the returned fragment\n     * @return a well-formed XML fragment starting at the given character index and having up to the specified length,\n     *         summing only the characters in text nodes\n     * @since 1.6M2\n     */\n    public static String extractXML(Node node, int start, int length)\n    {\n        ExtractHandler handler = null;\n        try {\n            handler = new ExtractHandler(start, length);\n            Transformer xformer = TransformerFactory.newInstance().newTransformer();\n            xformer.transform(new DOMSource(node), new SAXResult(handler));",
        "patch": "@@ -110,6 +110,18 @@ public final class XMLUtils\n     /** Xerces configuration parameter for disabling fetching and checking XMLs against their DTD. */\n     private static final String DISABLE_DTD_PARAM = \"http://apache.org/xml/features/nonvalidating/load-external-dtd\";\n \n+    /** Xerces configuration parameter for prevent DOCTYPE definition. */\n+    private static final String DISABLE_EXTERNAL_DOCTYPE_DECLARATION =\n+        \"http://apache.org/xml/features/disallow-doctype-decl\";\n+\n+    /** Xerces configuration parameter for disabling inserting entities defined in external files. */\n+    private static final String DISABLE_EXTERNAL_PARAMETER_ENTITIES =\n+        \"http://xml.org/sax/features/external-parameter-entities\";\n+\n+    /** Xerces configuration parameter for disabling inserting entities defined in external files. */\n+    private static final String DISABLE_EXTERNAL_GENERAL_ENTITIES =\n+        \"http://xml.org/sax/features/external-general-entities\";\n+\n     static {\n         DOMImplementationLS implementation = null;\n         try {\n@@ -516,6 +528,17 @@ public static Document parse(LSInput source)\n             if (p.getDomConfig().canSetParameter(DISABLE_DTD_PARAM, false)) {\n                 p.getDomConfig().setParameter(DISABLE_DTD_PARAM, false);\n             }\n+\n+            // Avoid XML eXternal Entity injection (XXE)\n+            if (p.getDomConfig().canSetParameter(DISABLE_EXTERNAL_DOCTYPE_DECLARATION, false)) {\n+                p.getDomConfig().setParameter(DISABLE_EXTERNAL_DOCTYPE_DECLARATION, false);\n+            }\n+            if (p.getDomConfig().canSetParameter(DISABLE_EXTERNAL_PARAMETER_ENTITIES, false)) {\n+                p.getDomConfig().setParameter(DISABLE_EXTERNAL_PARAMETER_ENTITIES, false);\n+            }\n+            if (p.getDomConfig().canSetParameter(DISABLE_EXTERNAL_GENERAL_ENTITIES, false)) {\n+                p.getDomConfig().setParameter(DISABLE_EXTERNAL_GENERAL_ENTITIES, false);\n+            }\n             return p.parse(source);\n         } catch (Exception ex) {\n             LOGGER.warn(\"Cannot parse XML document: [{}]\", ex.getMessage());",
        "function_modified_lines": {
            "added": [
                "    /** Xerces configuration parameter for prevent DOCTYPE definition. */\n",
                "    private static final String DISABLE_EXTERNAL_DOCTYPE_DECLARATION =\n",
                "        \"http://apache.org/xml/features/disallow-doctype-decl\";\n",
                "\n",
                "    /** Xerces configuration parameter for disabling inserting entities defined in external files. */\n",
                "    private static final String DISABLE_EXTERNAL_PARAMETER_ENTITIES =\n",
                "        \"http://xml.org/sax/features/external-parameter-entities\";\n",
                "\n",
                "    /** Xerces configuration parameter for disabling inserting entities defined in external files. */\n",
                "    private static final String DISABLE_EXTERNAL_GENERAL_ENTITIES =\n",
                "        \"http://xml.org/sax/features/external-general-entities\";\n",
                "\n"
            ],
            "deleted": []
        },
        "lang": "Java",
        "cwe": [
            "CWE-611"
        ],
        "cve_description": "org.xwiki.commons:xwiki-commons-xml is a common module used by other XWiki top level projects. Starting in version 2.7 and prior to versions 12.10.10, 13.4.4, and 13.8-rc-1, it is possible for a script to access any file accessing to the user running XWiki application server with XML External Entity Injection through the XML script service. The problem has been patched in versions 12.10.10, 13.4.4, and 13.8-rc-1. There is no easy workaround for fixing this vulnerability other than upgrading and being careful when giving Script rights.",
        "id": 12601
    },
    {
        "cve_id": "CVE-2022-41967",
        "code_before_change": "/*\n * Dragonfly - Runtime dependency management library\n *  Copyright (c) 2021 Joshua Sing <joshua@hypera.dev>\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"Software\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in all\n *  copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *  SOFTWARE.\n */\n\npackage dev.hypera.dragonfly.resolvers.impl;\n\nimport dev.hypera.dragonfly.Dragonfly;\nimport dev.hypera.dragonfly.dependency.impl.MavenDependency;\nimport dev.hypera.dragonfly.exceptions.ResolveFailureException;\nimport dev.hypera.dragonfly.resolvers.IResolver;\nimport java.io.StringReader;\nimport java.util.Set;\nimport java.util.stream.Collectors;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport org.jetbrains.annotations.NotNull;\nimport org.jetbrains.annotations.Nullable;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.xml.sax.InputSource;\n\n/**\n * Maven snapshot resolver.\n *\n * @author Joshua Sing <joshua@hypera.dev>\n */\npublic class MavenSnapshotResolver implements IResolver<MavenDependency> {\n\n\tprivate static final String FORMAT = \"%s%s/%s/%s/maven-metadata.xml\";\n\tprivate static final String OUTPUT_FORMAT = \"%s/%s-%s-%s-%s.jar\";\n\n\t@Override\n\tpublic @Nullable String resolve(@NotNull Dragonfly dragonfly, @NotNull MavenDependency dependency) throws ResolveFailureException {\n\t\tif (!dependency.getVersion().contains(\"SNAPSHOT\")) {\n\t\t\tthrow new ResolveFailureException(\"Cannot resolve a dependency as a snapshot if it isn't a snapshot\");\n\t\t} else {\n\t\t\tSet<String> urls = getUrls(dragonfly, dependency);\n\t\t\tif (urls.isEmpty()) {\n\t\t\t\tthrow new ResolveFailureException(\"Cannot resolve dependency: \" + dependency);\n\t\t\t}\n\n\t\t\tString data = null;\n\t\t\tString resolvedUrl = null;\n\t\t\tfor (String url : urls) {\n\t\t\t\tif ((data = get(url, dragonfly.getTimeout())) != null) {\n\t\t\t\t\tresolvedUrl = url;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (null == data) {\n\t\t\t\tthrow new ResolveFailureException(\"Cannot resolve dependency: \" + dependency);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tDocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n\t\t\t\tDocument document = builder.parse(new InputSource(new StringReader(data)));\n\t\t\t\tElement root = document.getDocumentElement();\n\t\t\t\tElement snapshotData = (Element) root.getElementsByTagName(\"snapshot\").item(0);\n\n\t\t\t\tString timestamp = snapshotData.getElementsByTagName(\"timestamp\").item(0).getTextContent();\n\t\t\t\tString buildNumber = snapshotData.getElementsByTagName(\"buildNumber\").item(0).getTextContent();\n\n\t\t\t\treturn String.format(\n\t\t\t\t\t\tOUTPUT_FORMAT,\n\t\t\t\t\t\tresolvedUrl.replace(\"/maven-metadata.xml\", \"\"),\n\t\t\t\t\t\tdependency.getArtifactId(),\n\t\t\t\t\t\tdependency.getVersion().replace(\"-SNAPSHOT\", \"\"),\n\t\t\t\t\t\ttimestamp,\n\t\t\t\t\t\tbuildNumber\n\t\t\t\t);\n\t\t\t} catch (Exception ex) {\n\t\t\t\tthrow new ResolveFailureException(\"Cannot resolve dependency: \" + dependency, ex);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tprivate Set<String> getUrls(@NotNull Dragonfly dragonfly, @NotNull MavenDependency dependency) {\n\t\treturn dragonfly.getRepositories().stream().map(repo -> String.format(\n\t\t\t\tFORMAT, repo,\n\t\t\t\tdependency.getGroupId().replace(\".\", \"/\"),\n\t\t\t\tdependency.getArtifactId(),\n\t\t\t\tdependency.getVersion()\n\t\t)).collect(Collectors.toSet());\n\t}\n\n}\n",
        "code_after_change": "/*\n * Dragonfly - Runtime dependency management library\n *  Copyright (c) 2021 Joshua Sing <joshua@hypera.dev>\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"Software\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in all\n *  copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *  SOFTWARE.\n */\n\npackage dev.hypera.dragonfly.resolvers.impl;\n\nimport dev.hypera.dragonfly.Dragonfly;\nimport dev.hypera.dragonfly.dependency.impl.MavenDependency;\nimport dev.hypera.dragonfly.exceptions.ResolveFailureException;\nimport dev.hypera.dragonfly.resolvers.IResolver;\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.util.Set;\nimport java.util.stream.Collectors;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.jetbrains.annotations.NotNull;\nimport org.jetbrains.annotations.Nullable;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.xml.sax.InputSource;\nimport sun.tools.jstat.ParserException;\n\n/**\n * Maven snapshot resolver.\n *\n * @author Joshua Sing <joshua@hypera.dev>\n */\npublic class MavenSnapshotResolver implements IResolver<MavenDependency> {\n\n\tprivate static final @NotNull String FORMAT = \"%s%s/%s/%s/maven-metadata.xml\";\n\tprivate static final @NotNull String OUTPUT_FORMAT = \"%s/%s-%s-%s-%s.jar\";\n\tprivate final @NotNull DocumentBuilderFactory documentBuilderFactory;\n\n\tpublic MavenSnapshotResolver() {\n\t\ttry {\n\t\t\t/* The below is an attempt to create an XML parser while preventing XML External Entity attacks */\n\t\t\t/* Read more: https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#java */\n\t\t\tDocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n\t\t\tfactory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n\t\t\tfactory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n\t\t\tfactory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n\t\t\tfactory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n\t\t\tfactory.setXIncludeAware(false);\n\t\t\tfactory.setExpandEntityReferences(false);\n\t\t\tthis.documentBuilderFactory = factory;\n\t\t} catch (ParserConfigurationException ex) {\n\t\t\tthrow new RuntimeException(\"Failed to create DocumentBuilderFactory\", ex);\n\t\t}\n\t}\n\n\t@Override\n\tpublic @Nullable String resolve(@NotNull Dragonfly dragonfly, @NotNull MavenDependency dependency) throws ResolveFailureException {\n\t\tif (!dependency.getVersion().contains(\"SNAPSHOT\")) {\n\t\t\tthrow new ResolveFailureException(\"Cannot resolve a dependency as a snapshot if it isn't a snapshot\");\n\t\t} else {\n\t\t\tSet<String> urls = getUrls(dragonfly, dependency);\n\t\t\tif (urls.isEmpty()) {\n\t\t\t\tthrow new ResolveFailureException(\"Cannot resolve dependency: \" + dependency);\n\t\t\t}\n\n\t\t\tString data = null;\n\t\t\tString resolvedUrl = null;\n\t\t\tfor (String url : urls) {\n\t\t\t\tif ((data = get(url, dragonfly.getTimeout())) != null) {\n\t\t\t\t\tresolvedUrl = url;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (null == data) {\n\t\t\t\tthrow new ResolveFailureException(\"Cannot resolve dependency: \" + dependency);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tDocumentBuilder builder = documentBuilderFactory.newDocumentBuilder();\n\t\t\t\tDocument document = builder.parse(new InputSource(new StringReader(data)));\n\t\t\t\tElement root = document.getDocumentElement();\n\t\t\t\tElement snapshotData = (Element) root.getElementsByTagName(\"snapshot\").item(0);\n\n\t\t\t\tString timestamp = snapshotData.getElementsByTagName(\"timestamp\").item(0).getTextContent();\n\t\t\t\tString buildNumber = snapshotData.getElementsByTagName(\"buildNumber\").item(0).getTextContent();\n\n\t\t\t\treturn String.format(\n\t\t\t\t\t\tOUTPUT_FORMAT,\n\t\t\t\t\t\tresolvedUrl.replace(\"/maven-metadata.xml\", \"\"),\n\t\t\t\t\t\tdependency.getArtifactId(),\n\t\t\t\t\t\tdependency.getVersion().replace(\"-SNAPSHOT\", \"\"),\n\t\t\t\t\t\ttimestamp,\n\t\t\t\t\t\tbuildNumber\n\t\t\t\t);\n\t\t\t} catch (Exception ex) {\n\t\t\t\tthrow new ResolveFailureException(\"Cannot resolve dependency: \" + dependency, ex);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tprivate Set<String> getUrls(@NotNull Dragonfly dragonfly, @NotNull MavenDependency dependency) {\n\t\treturn dragonfly.getRepositories().stream().map(repo -> String.format(\n\t\t\t\tFORMAT, repo,\n\t\t\t\tdependency.getGroupId().replace(\".\", \"/\"),\n\t\t\t\tdependency.getArtifactId(),\n\t\t\t\tdependency.getVersion()\n\t\t)).collect(Collectors.toSet());\n\t}\n\n}\n",
        "patch": "@@ -27,16 +27,19 @@\n import dev.hypera.dragonfly.dependency.impl.MavenDependency;\n import dev.hypera.dragonfly.exceptions.ResolveFailureException;\n import dev.hypera.dragonfly.resolvers.IResolver;\n+import java.io.IOException;\n import java.io.StringReader;\n import java.util.Set;\n import java.util.stream.Collectors;\n import javax.xml.parsers.DocumentBuilder;\n import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.parsers.ParserConfigurationException;\n import org.jetbrains.annotations.NotNull;\n import org.jetbrains.annotations.Nullable;\n import org.w3c.dom.Document;\n import org.w3c.dom.Element;\n import org.xml.sax.InputSource;\n+import sun.tools.jstat.ParserException;\n \n /**\n  * Maven snapshot resolver.\n@@ -45,8 +48,26 @@\n  */\n public class MavenSnapshotResolver implements IResolver<MavenDependency> {\n \n-\tprivate static final String FORMAT = \"%s%s/%s/%s/maven-metadata.xml\";\n-\tprivate static final String OUTPUT_FORMAT = \"%s/%s-%s-%s-%s.jar\";\n+\tprivate static final @NotNull String FORMAT = \"%s%s/%s/%s/maven-metadata.xml\";\n+\tprivate static final @NotNull String OUTPUT_FORMAT = \"%s/%s-%s-%s-%s.jar\";\n+\tprivate final @NotNull DocumentBuilderFactory documentBuilderFactory;\n+\n+\tpublic MavenSnapshotResolver() {\n+\t\ttry {\n+\t\t\t/* The below is an attempt to create an XML parser while preventing XML External Entity attacks */\n+\t\t\t/* Read more: https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#java */\n+\t\t\tDocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n+\t\t\tfactory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n+\t\t\tfactory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n+\t\t\tfactory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n+\t\t\tfactory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n+\t\t\tfactory.setXIncludeAware(false);\n+\t\t\tfactory.setExpandEntityReferences(false);\n+\t\t\tthis.documentBuilderFactory = factory;\n+\t\t} catch (ParserConfigurationException ex) {\n+\t\t\tthrow new RuntimeException(\"Failed to create DocumentBuilderFactory\", ex);\n+\t\t}\n+\t}\n \n \t@Override\n \tpublic @Nullable String resolve(@NotNull Dragonfly dragonfly, @NotNull MavenDependency dependency) throws ResolveFailureException {\n@@ -72,7 +93,7 @@ public class MavenSnapshotResolver implements IResolver<MavenDependency> {\n \t\t\t}\n \n \t\t\ttry {\n-\t\t\t\tDocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n+\t\t\t\tDocumentBuilder builder = documentBuilderFactory.newDocumentBuilder();\n \t\t\t\tDocument document = builder.parse(new InputSource(new StringReader(data)));\n \t\t\t\tElement root = document.getDocumentElement();\n \t\t\t\tElement snapshotData = (Element) root.getElementsByTagName(\"snapshot\").item(0);",
        "function_modified_lines": {
            "added": [
                "import java.io.IOException;\n",
                "import javax.xml.parsers.ParserConfigurationException;\n",
                "import sun.tools.jstat.ParserException;\n",
                "\tprivate static final @NotNull String FORMAT = \"%s%s/%s/%s/maven-metadata.xml\";\n",
                "\tprivate static final @NotNull String OUTPUT_FORMAT = \"%s/%s-%s-%s-%s.jar\";\n",
                "\tprivate final @NotNull DocumentBuilderFactory documentBuilderFactory;\n",
                "\n",
                "\tpublic MavenSnapshotResolver() {\n",
                "\t\ttry {\n",
                "\t\t\t/* The below is an attempt to create an XML parser while preventing XML External Entity attacks */\n",
                "\t\t\t/* Read more: https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#java */\n",
                "\t\t\tDocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n",
                "\t\t\tfactory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n",
                "\t\t\tfactory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n",
                "\t\t\tfactory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n",
                "\t\t\tfactory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n",
                "\t\t\tfactory.setXIncludeAware(false);\n",
                "\t\t\tfactory.setExpandEntityReferences(false);\n",
                "\t\t\tthis.documentBuilderFactory = factory;\n",
                "\t\t} catch (ParserConfigurationException ex) {\n",
                "\t\t\tthrow new RuntimeException(\"Failed to create DocumentBuilderFactory\", ex);\n",
                "\t\t}\n",
                "\t}\n"
            ],
            "deleted": [
                "\tprivate static final String FORMAT = \"%s%s/%s/%s/maven-metadata.xml\";\n",
                "\tprivate static final String OUTPUT_FORMAT = \"%s/%s-%s-%s-%s.jar\";\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-611"
        ],
        "cve_description": "Dragonfly is a Java runtime dependency management library. Dragonfly v0.3.0-SNAPSHOT does not configure DocumentBuilderFactory to prevent XML external entity (XXE) attacks. This issue is patched in 0.3.1-SNAPSHOT. As a workaround, since Dragonfly only parses XML `SNAPSHOT` versions are being resolved, this vulnerability may be avoided by not trying to resolve `SNAPSHOT` versions.",
        "id": 12680
    },
    {
        "cve_id": "CVE-2022-41967",
        "code_before_change": "{\n\n\tprivate static final String VERSION = \"0.3.0-SNAPSHOT\";\n\n\tprivate final int timeout;\n\tprivate final Path directory;\n\tprivate final Set<String> repositories;\n\tprivate final Consumer<Status> statusHandler;\n\n\tprivate final DependencyDownloader dependencyDownloader = new DependencyDownloader(this);\n\tprivate final DependencyRelocator dependencyRelocator;\n\tprivate final DependencyLoader dependencyLoader;\n\n\n\t@Internal\n\tprotected Dragonfly(int timeout, IClassLoader classLoader, Path directory, Set<String> repositories, boolean delete, Consumer<Status> statusHandler) throws IOException {\n\t\tthis.timeout = timeout;\n\t\tthis.directory = directory;\n\t\tthis.repositories = repositories;\n\t\tthis.statusHandler = statusHandler;\n\n\t\tthis.dependencyRelocator = new DependencyRelocator(this, delete);\n\t\tthis.dependencyLoader = new DependencyLoader(this, classLoader);\n\n\t\tif (!Files.exists(directory)) {\n\t\t\tFiles.createDirectories(directory);\n\t\t}\n\t}\n\n\tpublic static String getVersion() {\n\t\treturn VERSION;\n\t}\n\n\t/**\n\t * Download, relocate and load dependencies.\n\t *\n\t * @param dependencies Dependencies to be loaded.\n\t * @return If the load was successful, in the form of a {@link CompletableFuture<Boolean>}.\n\t */\n\tpublic CompletableFuture<Boolean> load(Dependency... dependencies) {\n\t\treturn CompletableFuture.supplyAsync(() -> {\n\t\t\ttry {\n\t\t\t\tstatusHandler.accept(Status.STARTING);\n\t\t\t\tList<Dependency> dependencyList = Arrays.stream(dependencies)\n\t\t\t\t\t\t.sorted(Comparator.comparingInt(Dependency::getPriority)).collect(Collectors.toList());\n\n\t\t\t\tif (dependencyList.size() > 0) {\n\t\t\t\t\tList<Dependency> downloadList = dependencyList.stream().filter(d -> !isDownloaded(d))\n\t\t\t\t\t\t\t.collect(Collectors.toList());\n\t\t\t\t\tif (downloadList.size() > 0) {\n\t\t\t\t\t\tstatusHandler.accept(Status.DOWNLOADING);\n\t\t\t\t\t\tdependencyDownloader.download(downloadList);\n\n\t\t\t\t\t\tif (downloadList.stream().anyMatch(d -> d.getRelocations().size() > 0)) {\n\t\t\t\t\t\t\tstatusHandler.accept(Status.RELOCATING);\n\t\t\t\t\t\t\tdependencyRelocator.relocate(downloadList);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tdependencyList.stream().filter(d -> d.getRelocations().size() > 0 && !d.isRelocated())\n\t\t\t\t\t\t\t.forEach(d -> d.setFileName(dependencyRelocator.getRelocatedFileName(d)));\n\n\t\t\t\t\tstatusHandler.accept(Status.LOADING);\n\t\t\t\t\tdependencyLoader.load(dependencyList);\n\t\t\t\t}\n\n\t\t\t\tstatusHandler.accept(Status.FINISHED);\n\t\t\t\treturn true;\n\t\t\t} catch (Exception ex) {\n\t\t\t\tthrow new IllegalStateException(ex);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * If a dependency has been downloaded or not.\n\t *\n\t * @param dependency Dependency.\n\t * @return If the given dependency has been downloaded or not.\n\t */\n\tprivate boolean isDownloaded(Dependency dependency) {\n\t\tif (dependencyRelocator.isRelocated(dependency)) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn Files.exists(directory.resolve(dependency.getFileName()));\n\t\t}\n\t}\n\n\tpublic int getTimeout() {\n\t\treturn timeout;\n\t}\n\n\tpublic Path getDirectory() {\n\t\treturn directory;\n\t}\n\n\tpublic Set<String> getRepositories() {\n\t\treturn repositories;\n\t}\n\n\t/**\n\t * Get {@link DependencyDownloader}, for internal use only.\n\t *\n\t * @return Stored instance of {@link DependencyDownloader}.\n\t */\n\t@Internal\n\tpublic DependencyDownloader getDependencyDownloader() {\n\t\treturn dependencyDownloader;\n\t}\n\n}",
        "code_after_change": "{\n\n\tprivate static final @NotNull String VERSION = \"0.3.1-SNAPSHOT\";\n\n\tprivate final int timeout;\n\tprivate final @NotNull Path directory;\n\tprivate final @NotNull Set<String> repositories;\n\tprivate final @NotNull Consumer<Status> statusHandler;\n\n\tprivate final @NotNull DependencyDownloader dependencyDownloader = new DependencyDownloader(this);\n\tprivate final @NotNull DependencyRelocator dependencyRelocator;\n\tprivate final @NotNull DependencyLoader dependencyLoader;\n\n\n\t@Internal\n\tprotected Dragonfly(int timeout, IClassLoader classLoader, Path directory, Set<String> repositories, boolean delete, Consumer<Status> statusHandler) throws IOException {\n\t\tthis.timeout = timeout;\n\t\tthis.directory = directory;\n\t\tthis.repositories = repositories;\n\t\tthis.statusHandler = statusHandler;\n\n\t\tthis.dependencyRelocator = new DependencyRelocator(this, delete);\n\t\tthis.dependencyLoader = new DependencyLoader(this, classLoader);\n\n\t\tif (!Files.exists(directory)) {\n\t\t\tFiles.createDirectories(directory);\n\t\t}\n\t}\n\n\tpublic static @NotNull String getVersion() {\n\t\treturn VERSION;\n\t}\n\n\t/**\n\t * Download, relocate and load dependencies.\n\t *\n\t * @param dependencies Dependencies to be loaded.\n\t * @return If the load was successful, in the form of a {@link CompletableFuture<Boolean>}.\n\t */\n\tpublic @NotNull CompletableFuture<Boolean> load(@NotNull Dependency... dependencies) {\n\t\treturn CompletableFuture.supplyAsync(() -> {\n\t\t\ttry {\n\t\t\t\tstatusHandler.accept(Status.STARTING);\n\t\t\t\tList<Dependency> dependencyList = Arrays.stream(dependencies)\n\t\t\t\t\t\t.sorted(Comparator.comparingInt(Dependency::getPriority)).collect(Collectors.toList());\n\n\t\t\t\tif (dependencyList.size() > 0) {\n\t\t\t\t\tList<Dependency> downloadList = dependencyList.stream().filter(d -> !isDownloaded(d))\n\t\t\t\t\t\t\t.collect(Collectors.toList());\n\t\t\t\t\tif (downloadList.size() > 0) {\n\t\t\t\t\t\tstatusHandler.accept(Status.DOWNLOADING);\n\t\t\t\t\t\tdependencyDownloader.download(downloadList);\n\n\t\t\t\t\t\tif (downloadList.stream().anyMatch(d -> d.getRelocations().size() > 0)) {\n\t\t\t\t\t\t\tstatusHandler.accept(Status.RELOCATING);\n\t\t\t\t\t\t\tdependencyRelocator.relocate(downloadList);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tdependencyList.stream().filter(d -> d.getRelocations().size() > 0 && !d.isRelocated())\n\t\t\t\t\t\t\t.forEach(d -> d.setFileName(dependencyRelocator.getRelocatedFileName(d)));\n\n\t\t\t\t\tstatusHandler.accept(Status.LOADING);\n\t\t\t\t\tdependencyLoader.load(dependencyList);\n\t\t\t\t}\n\n\t\t\t\tstatusHandler.accept(Status.FINISHED);\n\t\t\t\treturn true;\n\t\t\t} catch (Exception ex) {\n\t\t\t\tthrow new IllegalStateException(ex);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * If a dependency has been downloaded or not.\n\t *\n\t * @param dependency Dependency.\n\t * @return If the given dependency has been downloaded or not.\n\t */\n\tprivate boolean isDownloaded(Dependency dependency) {\n\t\tif (dependencyRelocator.isRelocated(dependency)) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn Files.exists(directory.resolve(dependency.getFileName()));\n\t\t}\n\t}\n\n\tpublic int getTimeout() {\n\t\treturn timeout;\n\t}\n\n\tpublic @NotNull Path getDirectory() {\n\t\treturn directory;\n\t}\n\n\tpublic @NotNull Set<String> getRepositories() {\n\t\treturn repositories;\n\t}\n\n\t/**\n\t * Get {@link DependencyDownloader}, for internal use only.\n\t *\n\t * @return Stored instance of {@link DependencyDownloader}.\n\t */\n\t@Internal\n\tpublic @NotNull DependencyDownloader getDependencyDownloader() {\n\t\treturn dependencyDownloader;\n\t}\n\n}",
        "patch": "@@ -40,23 +40,24 @@\n import java.util.function.Consumer;\n import java.util.stream.Collectors;\n import org.jetbrains.annotations.ApiStatus.Internal;\n+import org.jetbrains.annotations.NotNull;\n \n /**\n  * Main Dragonfly class.\n  * @author Joshua Sing <joshua@hypera.dev>\n  */\n public class Dragonfly {\n \n-\tprivate static final String VERSION = \"0.3.0-SNAPSHOT\";\n+\tprivate static final @NotNull String VERSION = \"0.3.1-SNAPSHOT\";\n \n \tprivate final int timeout;\n-\tprivate final Path directory;\n-\tprivate final Set<String> repositories;\n-\tprivate final Consumer<Status> statusHandler;\n+\tprivate final @NotNull Path directory;\n+\tprivate final @NotNull Set<String> repositories;\n+\tprivate final @NotNull Consumer<Status> statusHandler;\n \n-\tprivate final DependencyDownloader dependencyDownloader = new DependencyDownloader(this);\n-\tprivate final DependencyRelocator dependencyRelocator;\n-\tprivate final DependencyLoader dependencyLoader;\n+\tprivate final @NotNull DependencyDownloader dependencyDownloader = new DependencyDownloader(this);\n+\tprivate final @NotNull DependencyRelocator dependencyRelocator;\n+\tprivate final @NotNull DependencyLoader dependencyLoader;\n \n \n \t@Internal\n@@ -74,7 +75,7 @@ protected Dragonfly(int timeout, IClassLoader classLoader, Path directory, Set<S\n \t\t}\n \t}\n \n-\tpublic static String getVersion() {\n+\tpublic static @NotNull String getVersion() {\n \t\treturn VERSION;\n \t}\n \n@@ -84,7 +85,7 @@ public static String getVersion() {\n \t * @param dependencies Dependencies to be loaded.\n \t * @return If the load was successful, in the form of a {@link CompletableFuture<Boolean>}.\n \t */\n-\tpublic CompletableFuture<Boolean> load(Dependency... dependencies) {\n+\tpublic @NotNull CompletableFuture<Boolean> load(@NotNull Dependency... dependencies) {\n \t\treturn CompletableFuture.supplyAsync(() -> {\n \t\t\ttry {\n \t\t\t\tstatusHandler.accept(Status.STARTING);\n@@ -137,11 +138,11 @@ public int getTimeout() {\n \t\treturn timeout;\n \t}\n \n-\tpublic Path getDirectory() {\n+\tpublic @NotNull Path getDirectory() {\n \t\treturn directory;\n \t}\n \n-\tpublic Set<String> getRepositories() {\n+\tpublic @NotNull Set<String> getRepositories() {\n \t\treturn repositories;\n \t}\n \n@@ -151,7 +152,7 @@ public Set<String> getRepositories() {\n \t * @return Stored instance of {@link DependencyDownloader}.\n \t */\n \t@Internal\n-\tpublic DependencyDownloader getDependencyDownloader() {\n+\tpublic @NotNull DependencyDownloader getDependencyDownloader() {\n \t\treturn dependencyDownloader;\n \t}\n ",
        "function_modified_lines": {
            "added": [
                "\tpublic @NotNull Path getDirectory() {\n",
                "\tpublic @NotNull Set<String> getRepositories() {\n",
                "\tpublic @NotNull DependencyDownloader getDependencyDownloader() {\n"
            ],
            "deleted": [
                "\tpublic Path getDirectory() {\n",
                "\tpublic Set<String> getRepositories() {\n",
                "\tpublic DependencyDownloader getDependencyDownloader() {\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-611"
        ],
        "cve_description": "Dragonfly is a Java runtime dependency management library. Dragonfly v0.3.0-SNAPSHOT does not configure DocumentBuilderFactory to prevent XML external entity (XXE) attacks. This issue is patched in 0.3.1-SNAPSHOT. As a workaround, since Dragonfly only parses XML `SNAPSHOT` versions are being resolved, this vulnerability may be avoided by not trying to resolve `SNAPSHOT` versions.",
        "id": 12670
    },
    {
        "cve_id": "CVE-2022-41967",
        "code_before_change": "{\n\n\tprivate static final String VERSION = \"0.3.0-SNAPSHOT\";\n\n\tprivate final int timeout;\n\tprivate final Path directory;\n\tprivate final Set<String> repositories;\n\tprivate final Consumer<Status> statusHandler;\n\n\tprivate final DependencyDownloader dependencyDownloader = new DependencyDownloader(this);\n\tprivate final DependencyRelocator dependencyRelocator;\n\tprivate final DependencyLoader dependencyLoader;\n\n\n\t@Internal\n\tprotected Dragonfly(int timeout, IClassLoader classLoader, Path directory, Set<String> repositories, boolean delete, Consumer<Status> statusHandler) throws IOException {\n\t\tthis.timeout = timeout;\n\t\tthis.directory = directory;\n\t\tthis.repositories = repositories;\n\t\tthis.statusHandler = statusHandler;\n\n\t\tthis.dependencyRelocator = new DependencyRelocator(this, delete);\n\t\tthis.dependencyLoader = new DependencyLoader(this, classLoader);\n\n\t\tif (!Files.exists(directory)) {\n\t\t\tFiles.createDirectories(directory);\n\t\t}\n\t}\n\n\tpublic static String getVersion() {\n\t\treturn VERSION;\n\t}\n\n\t/**\n\t * Download, relocate and load dependencies.\n\t *\n\t * @param dependencies Dependencies to be loaded.\n\t * @return If the load was successful, in the form of a {@link CompletableFuture<Boolean>}.\n\t */\n\tpublic CompletableFuture<Boolean> load(Dependency... dependencies) {\n\t\treturn CompletableFuture.supplyAsync(() -> {\n\t\t\ttry {\n\t\t\t\tstatusHandler.accept(Status.STARTING);\n\t\t\t\tList<Dependency> dependencyList = Arrays.stream(dependencies)\n\t\t\t\t\t\t.sorted(Comparator.comparingInt(Dependency::getPriority)).collect(Collectors.toList());\n\n\t\t\t\tif (dependencyList.size() > 0) {\n\t\t\t\t\tList<Dependency> downloadList = dependencyList.stream().filter(d -> !isDownloaded(d))\n\t\t\t\t\t\t\t.collect(Collectors.toList());\n\t\t\t\t\tif (downloadList.size() > 0) {\n\t\t\t\t\t\tstatusHandler.accept(Status.DOWNLOADING);\n\t\t\t\t\t\tdependencyDownloader.download(downloadList);\n\n\t\t\t\t\t\tif (downloadList.stream().anyMatch(d -> d.getRelocations().size() > 0)) {\n\t\t\t\t\t\t\tstatusHandler.accept(Status.RELOCATING);\n\t\t\t\t\t\t\tdependencyRelocator.relocate(downloadList);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tdependencyList.stream().filter(d -> d.getRelocations().size() > 0 && !d.isRelocated())\n\t\t\t\t\t\t\t.forEach(d -> d.setFileName(dependencyRelocator.getRelocatedFileName(d)));\n\n\t\t\t\t\tstatusHandler.accept(Status.LOADING);\n\t\t\t\t\tdependencyLoader.load(dependencyList);\n\t\t\t\t}\n\n\t\t\t\tstatusHandler.accept(Status.FINISHED);\n\t\t\t\treturn true;\n\t\t\t} catch (Exception ex) {\n\t\t\t\tthrow new IllegalStateException(ex);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * If a dependency has been downloaded or not.\n\t *\n\t * @param dependency Dependency.\n\t * @return If the given dependency has been downloaded or not.\n\t */\n\tprivate boolean isDownloaded(Dependency dependency) {\n\t\tif (dependencyRelocator.isRelocated(dependency)) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn Files.exists(directory.resolve(dependency.getFileName()));\n\t\t}\n\t}\n\n\tpublic int getTimeout() {\n\t\treturn timeout;\n\t}\n\n\tpublic Path getDirectory() {\n\t\treturn directory;\n\t}\n\n\tpublic Set<String> getRepositories() {\n\t\treturn repositories;\n\t}\n\n\t/**\n\t * Get {@link DependencyDownloader}, for internal use only.\n\t *\n\t * @return Stored instance of {@link DependencyDownloader}.\n\t */\n\t@Internal\n\tpublic DependencyDownloader getDependencyDownloader() {\n\t\treturn dependencyDownloader;\n\t}\n\n}",
        "code_after_change": "{\n\n\tprivate static final @NotNull String VERSION = \"0.3.1-SNAPSHOT\";\n\n\tprivate final int timeout;\n\tprivate final @NotNull Path directory;\n\tprivate final @NotNull Set<String> repositories;\n\tprivate final @NotNull Consumer<Status> statusHandler;\n\n\tprivate final @NotNull DependencyDownloader dependencyDownloader = new DependencyDownloader(this);\n\tprivate final @NotNull DependencyRelocator dependencyRelocator;\n\tprivate final @NotNull DependencyLoader dependencyLoader;\n\n\n\t@Internal\n\tprotected Dragonfly(int timeout, IClassLoader classLoader, Path directory, Set<String> repositories, boolean delete, Consumer<Status> statusHandler) throws IOException {\n\t\tthis.timeout = timeout;\n\t\tthis.directory = directory;\n\t\tthis.repositories = repositories;\n\t\tthis.statusHandler = statusHandler;\n\n\t\tthis.dependencyRelocator = new DependencyRelocator(this, delete);\n\t\tthis.dependencyLoader = new DependencyLoader(this, classLoader);\n\n\t\tif (!Files.exists(directory)) {\n\t\t\tFiles.createDirectories(directory);\n\t\t}\n\t}\n\n\tpublic static @NotNull String getVersion() {\n\t\treturn VERSION;\n\t}\n\n\t/**\n\t * Download, relocate and load dependencies.\n\t *\n\t * @param dependencies Dependencies to be loaded.\n\t * @return If the load was successful, in the form of a {@link CompletableFuture<Boolean>}.\n\t */\n\tpublic @NotNull CompletableFuture<Boolean> load(@NotNull Dependency... dependencies) {\n\t\treturn CompletableFuture.supplyAsync(() -> {\n\t\t\ttry {\n\t\t\t\tstatusHandler.accept(Status.STARTING);\n\t\t\t\tList<Dependency> dependencyList = Arrays.stream(dependencies)\n\t\t\t\t\t\t.sorted(Comparator.comparingInt(Dependency::getPriority)).collect(Collectors.toList());\n\n\t\t\t\tif (dependencyList.size() > 0) {\n\t\t\t\t\tList<Dependency> downloadList = dependencyList.stream().filter(d -> !isDownloaded(d))\n\t\t\t\t\t\t\t.collect(Collectors.toList());\n\t\t\t\t\tif (downloadList.size() > 0) {\n\t\t\t\t\t\tstatusHandler.accept(Status.DOWNLOADING);\n\t\t\t\t\t\tdependencyDownloader.download(downloadList);\n\n\t\t\t\t\t\tif (downloadList.stream().anyMatch(d -> d.getRelocations().size() > 0)) {\n\t\t\t\t\t\t\tstatusHandler.accept(Status.RELOCATING);\n\t\t\t\t\t\t\tdependencyRelocator.relocate(downloadList);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tdependencyList.stream().filter(d -> d.getRelocations().size() > 0 && !d.isRelocated())\n\t\t\t\t\t\t\t.forEach(d -> d.setFileName(dependencyRelocator.getRelocatedFileName(d)));\n\n\t\t\t\t\tstatusHandler.accept(Status.LOADING);\n\t\t\t\t\tdependencyLoader.load(dependencyList);\n\t\t\t\t}\n\n\t\t\t\tstatusHandler.accept(Status.FINISHED);\n\t\t\t\treturn true;\n\t\t\t} catch (Exception ex) {\n\t\t\t\tthrow new IllegalStateException(ex);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * If a dependency has been downloaded or not.\n\t *\n\t * @param dependency Dependency.\n\t * @return If the given dependency has been downloaded or not.\n\t */\n\tprivate boolean isDownloaded(Dependency dependency) {\n\t\tif (dependencyRelocator.isRelocated(dependency)) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn Files.exists(directory.resolve(dependency.getFileName()));\n\t\t}\n\t}\n\n\tpublic int getTimeout() {\n\t\treturn timeout;\n\t}\n\n\tpublic @NotNull Path getDirectory() {\n\t\treturn directory;\n\t}\n\n\tpublic @NotNull Set<String> getRepositories() {\n\t\treturn repositories;\n\t}\n\n\t/**\n\t * Get {@link DependencyDownloader}, for internal use only.\n\t *\n\t * @return Stored instance of {@link DependencyDownloader}.\n\t */\n\t@Internal\n\tpublic @NotNull DependencyDownloader getDependencyDownloader() {\n\t\treturn dependencyDownloader;\n\t}\n\n}",
        "patch": "@@ -40,23 +40,24 @@\n import java.util.function.Consumer;\n import java.util.stream.Collectors;\n import org.jetbrains.annotations.ApiStatus.Internal;\n+import org.jetbrains.annotations.NotNull;\n \n /**\n  * Main Dragonfly class.\n  * @author Joshua Sing <joshua@hypera.dev>\n  */\n public class Dragonfly {\n \n-\tprivate static final String VERSION = \"0.3.0-SNAPSHOT\";\n+\tprivate static final @NotNull String VERSION = \"0.3.1-SNAPSHOT\";\n \n \tprivate final int timeout;\n-\tprivate final Path directory;\n-\tprivate final Set<String> repositories;\n-\tprivate final Consumer<Status> statusHandler;\n+\tprivate final @NotNull Path directory;\n+\tprivate final @NotNull Set<String> repositories;\n+\tprivate final @NotNull Consumer<Status> statusHandler;\n \n-\tprivate final DependencyDownloader dependencyDownloader = new DependencyDownloader(this);\n-\tprivate final DependencyRelocator dependencyRelocator;\n-\tprivate final DependencyLoader dependencyLoader;\n+\tprivate final @NotNull DependencyDownloader dependencyDownloader = new DependencyDownloader(this);\n+\tprivate final @NotNull DependencyRelocator dependencyRelocator;\n+\tprivate final @NotNull DependencyLoader dependencyLoader;\n \n \n \t@Internal\n@@ -74,7 +75,7 @@ protected Dragonfly(int timeout, IClassLoader classLoader, Path directory, Set<S\n \t\t}\n \t}\n \n-\tpublic static String getVersion() {\n+\tpublic static @NotNull String getVersion() {\n \t\treturn VERSION;\n \t}\n \n@@ -84,7 +85,7 @@ public static String getVersion() {\n \t * @param dependencies Dependencies to be loaded.\n \t * @return If the load was successful, in the form of a {@link CompletableFuture<Boolean>}.\n \t */\n-\tpublic CompletableFuture<Boolean> load(Dependency... dependencies) {\n+\tpublic @NotNull CompletableFuture<Boolean> load(@NotNull Dependency... dependencies) {\n \t\treturn CompletableFuture.supplyAsync(() -> {\n \t\t\ttry {\n \t\t\t\tstatusHandler.accept(Status.STARTING);\n@@ -137,11 +138,11 @@ public int getTimeout() {\n \t\treturn timeout;\n \t}\n \n-\tpublic Path getDirectory() {\n+\tpublic @NotNull Path getDirectory() {\n \t\treturn directory;\n \t}\n \n-\tpublic Set<String> getRepositories() {\n+\tpublic @NotNull Set<String> getRepositories() {\n \t\treturn repositories;\n \t}\n \n@@ -151,7 +152,7 @@ public Set<String> getRepositories() {\n \t * @return Stored instance of {@link DependencyDownloader}.\n \t */\n \t@Internal\n-\tpublic DependencyDownloader getDependencyDownloader() {\n+\tpublic @NotNull DependencyDownloader getDependencyDownloader() {\n \t\treturn dependencyDownloader;\n \t}\n ",
        "function_modified_lines": {
            "added": [
                "\tpublic static @NotNull String getVersion() {\n",
                "\tpublic @NotNull CompletableFuture<Boolean> load(@NotNull Dependency... dependencies) {\n"
            ],
            "deleted": [
                "\tpublic static String getVersion() {\n",
                "\tpublic CompletableFuture<Boolean> load(Dependency... dependencies) {\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-611"
        ],
        "cve_description": "Dragonfly is a Java runtime dependency management library. Dragonfly v0.3.0-SNAPSHOT does not configure DocumentBuilderFactory to prevent XML external entity (XXE) attacks. This issue is patched in 0.3.1-SNAPSHOT. As a workaround, since Dragonfly only parses XML `SNAPSHOT` versions are being resolved, this vulnerability may be avoided by not trying to resolve `SNAPSHOT` versions.",
        "id": 12669
    },
    {
        "cve_id": "CVE-2022-41967",
        "code_before_change": "/*\n * Dragonfly - Runtime dependency management library\n *  Copyright (c) 2021 Joshua Sing <joshua@hypera.dev>\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"Software\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in all\n *  copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *  SOFTWARE.\n */\n\npackage dev.hypera.dragonfly.relocation;\n\nimport dev.hypera.dragonfly.Dragonfly;\nimport dev.hypera.dragonfly.dependency.Dependency;\nimport dev.hypera.dragonfly.exceptions.DownloadFailureException;\nimport dev.hypera.dragonfly.exceptions.LoadFailureException;\nimport dev.hypera.dragonfly.exceptions.RelocationFailureException;\nimport dev.hypera.dragonfly.loading.DependencyLoader;\nimport dev.hypera.dragonfly.loading.DragonflyClassLoader;\nimport java.io.File;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport org.jetbrains.annotations.ApiStatus.Internal;\nimport org.jetbrains.annotations.NotNull;\n\n/**\n * Dependency relocator.\n *\n * @author Joshua Sing <joshua@hypera.dev>\n */\npublic class DependencyRelocator {\n\n\tprivate static final String RELOCATED_FILENAME = \"%s-relocated.jar\";\n\n\tprivate final Dragonfly dragonfly;\n\tprivate final boolean deleteOld;\n\n\tprivate final DragonflyClassLoader classLoader;\n\tprivate final DependencyLoader dependencyLoader;\n\n\tprivate boolean dependenciesLoaded;\n\n\tprivate Constructor<?> constructor;\n\tprivate Method method;\n\n\t@Internal\n\tpublic DependencyRelocator(Dragonfly dragonfly, boolean deleteOld) {\n\t\tthis.dragonfly = dragonfly;\n\t\tthis.deleteOld = deleteOld;\n\t\tthis.classLoader = new DragonflyClassLoader(getClass().getClassLoader());\n\t\tthis.dependencyLoader = new DependencyLoader(dragonfly, classLoader::addURL);\n\t}\n\n\n\t/**\n\t * Initialise relocator.\n\t *\n\t * @throws RelocationFailureException if something went wrong while initialising.\n\t */\n\tprivate void init() throws RelocationFailureException {\n\t\tif (null == constructor && null == method) {\n\t\t\ttry {\n\t\t\t\tClass<?> clazz = classLoader.loadClass(\"me.lucko.jarrelocator.JarRelocator\");\n\n\t\t\t\tconstructor = clazz.getDeclaredConstructor(File.class, File.class, Map.class);\n\t\t\t\tmethod = clazz.getDeclaredMethod(\"run\");\n\n\t\t\t\tconstructor.setAccessible(true);\n\t\t\t\tmethod.setAccessible(true);\n\t\t\t} catch (Exception ex) {\n\t\t\t\tthrow new RelocationFailureException(ex);\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Attempt to relocate a list of dependencies.\n\t *\n\t * @param dependencies Dependencies to be relocated.\n\t * @throws RelocationFailureException if something went wrong while relocating the dependencies.\n\t * @throws DownloadFailureException   if something went wrong while downloading internal dependencies.\n\t * @throws LoadFailureException       if something went wrong while loading the internal dependencies.\n\t */\n\tpublic void relocate(@NotNull List<Dependency> dependencies) throws RelocationFailureException, DownloadFailureException, LoadFailureException {\n\t\tloadInternalDependencies(getDependencies());\n\t\tinit();\n\n\t\tfor (Dependency dependency : dependencies) {\n\t\t\tif (dependency.getRelocations().size() > 0) {\n\t\t\t\trelocate(dependency);\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Attempt to relocate a dependency.\n\t *\n\t * @param dependency Dependency to be relocated.\n\t * @throws RelocationFailureException if something went wrong while relocating the dependency.\n\t */\n\tprivate void relocate(@NotNull Dependency dependency) throws RelocationFailureException {\n\t\ttry {\n\t\t\tPath relocatedPath = getRelocatedPath(dependency);\n\t\t\tif (Files.exists(relocatedPath)) {\n\t\t\t\tdependency.setFileName(getRelocatedFileName(dependency));\n\t\t\t\tdependency.setRelocated(true);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tMap<String, String> relocations = new HashMap<>();\n\t\t\tdependency.getRelocations().forEach(r -> relocations.put(r.getFrom(), r.getTo()));\n\n\t\t\tObject object = constructor.newInstance(dragonfly.getDirectory().resolve(dependency.getFileName())\n\t\t\t\t\t.toFile(), relocatedPath.toFile(), relocations);\n\t\t\tmethod.invoke(object);\n\n\t\t\tif (deleteOld) {\n\t\t\t\tFiles.delete(dragonfly.getDirectory().resolve(dependency.getFileName()));\n\t\t\t}\n\n\t\t\tdependency.setFileName(getRelocatedFileName(dependency));\n\t\t\tdependency.setRelocated(true);\n\t\t} catch (Exception ex) {\n\t\t\tthrow new RelocationFailureException(ex);\n\t\t}\n\t}\n\n\t/**\n\t * If a dependency has been relocated or not.\n\t *\n\t * @param dependency Dependency.\n\t * @return If the given dependency has been relocated or not.\n\t */\n\tpublic boolean isRelocated(@NotNull Dependency dependency) {\n\t\tif (dependency.getRelocations().size() > 0) {\n\t\t\treturn Files.exists(getRelocatedPath(dependency));\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Get the relocated path of a dependency.\n\t *\n\t * @param dependency Dependency to get the relocated path of.\n\t * @return Relocated path of the given dependency.\n\t */\n\tpublic @NotNull Path getRelocatedPath(@NotNull Dependency dependency) {\n\t\treturn dragonfly.getDirectory().resolve(getRelocatedFileName(dependency));\n\t}\n\n\t/**\n\t * Get the relocated filename of a dependency.\n\t *\n\t * @param dependency Dependency to get the relocated filename of.\n\t * @return Relocated filename of the given dependency.\n\t */\n\tpublic @NotNull String getRelocatedFileName(@NotNull Dependency dependency) {\n\t\treturn String.format(RELOCATED_FILENAME, dependency.getFileName().split(\"\\\\.jar\")[0]);\n\t}\n\n\t/**\n\t * Attempt to download and load internal dependencies.\n\t *\n\t * @param dependencies Dependencies to be downloaded and loaded.\n\t * @throws DownloadFailureException if something went wrong while downloading the dependencies.\n\t * @throws LoadFailureException     if something went wrong while loading the dependencies.\n\t */\n\tprivate void loadInternalDependencies(List<Dependency> dependencies) throws DownloadFailureException, LoadFailureException {\n\t\tif (!dependenciesLoaded) {\n\t\t\tdragonfly.getDependencyDownloader().download(dependencies);\n\t\t\tdependencyLoader.load(dependencies);\n\t\t\tdependenciesLoaded = true;\n\t\t}\n\t}\n\n\t/**\n\t * Get internal dependencies.\n\t *\n\t * @return Internal dependencies.\n\t */\n\tpublic @NotNull List<Dependency> getDependencies() {\n\t\treturn Arrays.asList(\n\t\t\t\tDependency.maven(-3, \"org.ow2.asm\", \"asm\", \"9.2\"),\n\t\t\t\tDependency.maven(-2, \"org.ow2.asm\", \"asm-commons\", \"9.2\"),\n\t\t\t\tDependency.maven(-1, \"me.lucko\", \"jar-relocator\", \"1.5\")\n\t\t);\n\t}\n\n}\n",
        "code_after_change": "/*\n * Dragonfly - Runtime dependency management library\n *  Copyright (c) 2021 Joshua Sing <joshua@hypera.dev>\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"Software\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in all\n *  copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *  SOFTWARE.\n */\n\npackage dev.hypera.dragonfly.relocation;\n\nimport dev.hypera.dragonfly.Dragonfly;\nimport dev.hypera.dragonfly.dependency.Dependency;\nimport dev.hypera.dragonfly.exceptions.DownloadFailureException;\nimport dev.hypera.dragonfly.exceptions.LoadFailureException;\nimport dev.hypera.dragonfly.exceptions.RelocationFailureException;\nimport dev.hypera.dragonfly.loading.DependencyLoader;\nimport dev.hypera.dragonfly.loading.DragonflyClassLoader;\nimport java.io.File;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport org.jetbrains.annotations.ApiStatus.Internal;\nimport org.jetbrains.annotations.NotNull;\nimport org.jetbrains.annotations.Nullable;\n\n/**\n * Dependency relocator.\n *\n * @author Joshua Sing <joshua@hypera.dev>\n */\npublic class DependencyRelocator {\n\n\tprivate static final @NotNull String RELOCATED_FILENAME = \"%s-relocated.jar\";\n\n\tprivate final @NotNull Dragonfly dragonfly;\n\tprivate final boolean deleteOld;\n\n\tprivate final @NotNull DragonflyClassLoader classLoader;\n\tprivate final @NotNull DependencyLoader dependencyLoader;\n\n\tprivate boolean dependenciesLoaded;\n\n\tprivate @Nullable Constructor<?> constructor;\n\tprivate @Nullable Method method;\n\n\t@Internal\n\tpublic DependencyRelocator(@NotNull Dragonfly dragonfly, boolean deleteOld) {\n\t\tthis.dragonfly = dragonfly;\n\t\tthis.deleteOld = deleteOld;\n\t\tthis.classLoader = new DragonflyClassLoader(getClass().getClassLoader());\n\t\tthis.dependencyLoader = new DependencyLoader(dragonfly, classLoader::addURL);\n\t}\n\n\n\t/**\n\t * Initialise relocator.\n\t *\n\t * @throws RelocationFailureException if something went wrong while initialising.\n\t */\n\tprivate void init() throws RelocationFailureException {\n\t\tif (null == constructor && null == method) {\n\t\t\ttry {\n\t\t\t\tClass<?> clazz = classLoader.loadClass(\"me.lucko.jarrelocator.JarRelocator\");\n\n\t\t\t\tconstructor = clazz.getDeclaredConstructor(File.class, File.class, Map.class);\n\t\t\t\tmethod = clazz.getDeclaredMethod(\"run\");\n\n\t\t\t\tconstructor.setAccessible(true);\n\t\t\t\tmethod.setAccessible(true);\n\t\t\t} catch (Exception ex) {\n\t\t\t\tthrow new RelocationFailureException(ex);\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Attempt to relocate a list of dependencies.\n\t *\n\t * @param dependencies Dependencies to be relocated.\n\t * @throws RelocationFailureException if something went wrong while relocating the dependencies.\n\t * @throws DownloadFailureException   if something went wrong while downloading internal dependencies.\n\t * @throws LoadFailureException       if something went wrong while loading the internal dependencies.\n\t */\n\tpublic void relocate(@NotNull List<Dependency> dependencies) throws RelocationFailureException, DownloadFailureException, LoadFailureException {\n\t\tloadInternalDependencies(getDependencies());\n\t\tinit();\n\n\t\tfor (Dependency dependency : dependencies) {\n\t\t\tif (dependency.getRelocations().size() > 0) {\n\t\t\t\trelocate(dependency);\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Attempt to relocate a dependency.\n\t *\n\t * @param dependency Dependency to be relocated.\n\t * @throws RelocationFailureException if something went wrong while relocating the dependency.\n\t */\n\tprivate void relocate(@NotNull Dependency dependency) throws RelocationFailureException {\n\t\ttry {\n\t\t\tPath relocatedPath = getRelocatedPath(dependency);\n\t\t\tif (Files.exists(relocatedPath)) {\n\t\t\t\tdependency.setFileName(getRelocatedFileName(dependency));\n\t\t\t\tdependency.setRelocated(true);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tMap<String, String> relocations = new HashMap<>();\n\t\t\tdependency.getRelocations().forEach(r -> relocations.put(r.getFrom(), r.getTo()));\n\n\t\t\tObject object = constructor.newInstance(dragonfly.getDirectory().resolve(dependency.getFileName())\n\t\t\t\t\t.toFile(), relocatedPath.toFile(), relocations);\n\t\t\tmethod.invoke(object);\n\n\t\t\tif (deleteOld) {\n\t\t\t\tFiles.delete(dragonfly.getDirectory().resolve(dependency.getFileName()));\n\t\t\t}\n\n\t\t\tdependency.setFileName(getRelocatedFileName(dependency));\n\t\t\tdependency.setRelocated(true);\n\t\t} catch (Exception ex) {\n\t\t\tthrow new RelocationFailureException(ex);\n\t\t}\n\t}\n\n\t/**\n\t * If a dependency has been relocated or not.\n\t *\n\t * @param dependency Dependency.\n\t * @return If the given dependency has been relocated or not.\n\t */\n\tpublic boolean isRelocated(@NotNull Dependency dependency) {\n\t\tif (dependency.getRelocations().size() > 0) {\n\t\t\treturn Files.exists(getRelocatedPath(dependency));\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Get the relocated path of a dependency.\n\t *\n\t * @param dependency Dependency to get the relocated path of.\n\t * @return Relocated path of the given dependency.\n\t */\n\tpublic @NotNull Path getRelocatedPath(@NotNull Dependency dependency) {\n\t\treturn dragonfly.getDirectory().resolve(getRelocatedFileName(dependency));\n\t}\n\n\t/**\n\t * Get the relocated filename of a dependency.\n\t *\n\t * @param dependency Dependency to get the relocated filename of.\n\t * @return Relocated filename of the given dependency.\n\t */\n\tpublic @NotNull String getRelocatedFileName(@NotNull Dependency dependency) {\n\t\treturn String.format(RELOCATED_FILENAME, dependency.getFileName().split(\"\\\\.jar\")[0]);\n\t}\n\n\t/**\n\t * Attempt to download and load internal dependencies.\n\t *\n\t * @param dependencies Dependencies to be downloaded and loaded.\n\t * @throws DownloadFailureException if something went wrong while downloading the dependencies.\n\t * @throws LoadFailureException     if something went wrong while loading the dependencies.\n\t */\n\tprivate void loadInternalDependencies(List<Dependency> dependencies) throws DownloadFailureException, LoadFailureException {\n\t\tif (!dependenciesLoaded) {\n\t\t\tdragonfly.getDependencyDownloader().download(dependencies);\n\t\t\tdependencyLoader.load(dependencies);\n\t\t\tdependenciesLoaded = true;\n\t\t}\n\t}\n\n\t/**\n\t * Get internal dependencies.\n\t *\n\t * @return Internal dependencies.\n\t */\n\tpublic @NotNull List<Dependency> getDependencies() {\n\t\treturn Arrays.asList(\n\t\t\t\tDependency.maven(-3, \"org.ow2.asm\", \"asm\", \"9.2\"),\n\t\t\t\tDependency.maven(-2, \"org.ow2.asm\", \"asm-commons\", \"9.2\"),\n\t\t\t\tDependency.maven(-1, \"me.lucko\", \"jar-relocator\", \"1.5\")\n\t\t);\n\t}\n\n}\n",
        "patch": "@@ -41,6 +41,7 @@\n import java.util.Map;\n import org.jetbrains.annotations.ApiStatus.Internal;\n import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n \n /**\n  * Dependency relocator.\n@@ -49,21 +50,21 @@\n  */\n public class DependencyRelocator {\n \n-\tprivate static final String RELOCATED_FILENAME = \"%s-relocated.jar\";\n+\tprivate static final @NotNull String RELOCATED_FILENAME = \"%s-relocated.jar\";\n \n-\tprivate final Dragonfly dragonfly;\n+\tprivate final @NotNull Dragonfly dragonfly;\n \tprivate final boolean deleteOld;\n \n-\tprivate final DragonflyClassLoader classLoader;\n-\tprivate final DependencyLoader dependencyLoader;\n+\tprivate final @NotNull DragonflyClassLoader classLoader;\n+\tprivate final @NotNull DependencyLoader dependencyLoader;\n \n \tprivate boolean dependenciesLoaded;\n \n-\tprivate Constructor<?> constructor;\n-\tprivate Method method;\n+\tprivate @Nullable Constructor<?> constructor;\n+\tprivate @Nullable Method method;\n \n \t@Internal\n-\tpublic DependencyRelocator(Dragonfly dragonfly, boolean deleteOld) {\n+\tpublic DependencyRelocator(@NotNull Dragonfly dragonfly, boolean deleteOld) {\n \t\tthis.dragonfly = dragonfly;\n \t\tthis.deleteOld = deleteOld;\n \t\tthis.classLoader = new DragonflyClassLoader(getClass().getClassLoader());",
        "function_modified_lines": {
            "added": [
                "import org.jetbrains.annotations.Nullable;\n",
                "\tprivate static final @NotNull String RELOCATED_FILENAME = \"%s-relocated.jar\";\n",
                "\tprivate final @NotNull Dragonfly dragonfly;\n",
                "\tprivate final @NotNull DragonflyClassLoader classLoader;\n",
                "\tprivate final @NotNull DependencyLoader dependencyLoader;\n",
                "\tprivate @Nullable Constructor<?> constructor;\n",
                "\tprivate @Nullable Method method;\n",
                "\tpublic DependencyRelocator(@NotNull Dragonfly dragonfly, boolean deleteOld) {\n"
            ],
            "deleted": [
                "\tprivate static final String RELOCATED_FILENAME = \"%s-relocated.jar\";\n",
                "\tprivate final Dragonfly dragonfly;\n",
                "\tprivate final DragonflyClassLoader classLoader;\n",
                "\tprivate final DependencyLoader dependencyLoader;\n",
                "\tprivate Constructor<?> constructor;\n",
                "\tprivate Method method;\n",
                "\tpublic DependencyRelocator(Dragonfly dragonfly, boolean deleteOld) {\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-611"
        ],
        "cve_description": "Dragonfly is a Java runtime dependency management library. Dragonfly v0.3.0-SNAPSHOT does not configure DocumentBuilderFactory to prevent XML external entity (XXE) attacks. This issue is patched in 0.3.1-SNAPSHOT. As a workaround, since Dragonfly only parses XML `SNAPSHOT` versions are being resolved, this vulnerability may be avoided by not trying to resolve `SNAPSHOT` versions.",
        "id": 12678
    },
    {
        "cve_id": "CVE-2022-4607",
        "code_before_change": "package vcs.citydb.wfs.operation.storedquery;\n\nimport net.opengis.fes._2.AbstractQueryExpressionType;\nimport net.opengis.fes._2.FilterType;\nimport net.opengis.fes._2.ResourceIdType;\nimport net.opengis.wfs._2.*;\nimport org.citygml4j.builder.jaxb.CityGMLBuilder;\nimport org.citygml4j.model.module.citygml.CityGMLModule;\nimport org.citygml4j.model.module.citygml.CityGMLModuleType;\nimport org.citygml4j.model.module.citygml.CityGMLVersion;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.*;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.XMLReader;\nimport vcs.citydb.wfs.config.Constants;\nimport vcs.citydb.wfs.config.WFSConfig;\nimport vcs.citydb.wfs.exception.WFSException;\nimport vcs.citydb.wfs.exception.WFSExceptionCode;\nimport vcs.citydb.wfs.kvp.KVPConstants;\nimport vcs.citydb.wfs.util.xml.NamespaceFilter;\n\nimport javax.xml.XMLConstants;\nimport javax.xml.bind.*;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.stream.XMLOutputFactory;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpression;\nimport javax.xml.xpath.XPathExpressionException;\nimport javax.xml.xpath.XPathFactory;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class StoredQueryManager {\n\tprivate final String GET_FEATURE_BY_ID_NAME = \"http://www.opengis.net/def/query/OGC-WFS/0/GetFeatureById\";\n\tprivate final String DEPRECATED_GET_FEATURE_BY_ID_NAME = \"urn:ogc:def:query:OGC-WFS::GetFeatureById\";\n\n\tprivate final StoredQuery DEFAULT_QUERY;\n\tprivate final CityGMLBuilder cityGMLBuilder;\n\tprivate final SAXParserFactory saxParserFactory;\n\tprivate final TransformerFactory transformerFactory;\n\tprivate final DocumentBuilderFactory documentBuilderFactory;\n\tprivate final XMLOutputFactory xmlOutputFactory;\n\tprivate final Path storedQueriesPath;\n\tprivate final ObjectFactory wfsFactory;\n\tprivate final WFSConfig wfsConfig;\n\tprivate final MessageDigest md5;\n\n\tpublic StoredQueryManager(CityGMLBuilder cityGMLBuilder, SAXParserFactory saxParserFactory, String path, WFSConfig wfsConfig) throws ParserConfigurationException, SAXException, NoSuchAlgorithmException, IOException {\n\t\tthis.cityGMLBuilder = cityGMLBuilder;\n\t\tthis.saxParserFactory = saxParserFactory;\n\t\tthis.wfsConfig = wfsConfig;\n\n\t\tmd5 = MessageDigest.getInstance(\"MD5\");\n\t\twfsFactory = new ObjectFactory();\n\t\ttransformerFactory = TransformerFactory.newInstance();\n\t\txmlOutputFactory = XMLOutputFactory.newInstance();\n\t\tdocumentBuilderFactory = DocumentBuilderFactory.newInstance();\n\t\tdocumentBuilderFactory.setNamespaceAware(true);\n\n\t\tstoredQueriesPath = Paths.get(path);\n\t\tFiles.createDirectories(storedQueriesPath);\n\t\tif (!Files.isDirectory(storedQueriesPath) || !Files.isReadable(storedQueriesPath))",
        "code_after_change": "package vcs.citydb.wfs.operation.storedquery;\n\nimport net.opengis.fes._2.AbstractQueryExpressionType;\nimport net.opengis.fes._2.FilterType;\nimport net.opengis.fes._2.ResourceIdType;\nimport net.opengis.wfs._2.*;\nimport org.citydb.util.xml.SecureXMLProcessors;\nimport org.citygml4j.builder.jaxb.CityGMLBuilder;\nimport org.citygml4j.model.module.citygml.CityGMLModule;\nimport org.citygml4j.model.module.citygml.CityGMLModuleType;\nimport org.citygml4j.model.module.citygml.CityGMLVersion;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.*;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.XMLReader;\nimport vcs.citydb.wfs.config.Constants;\nimport vcs.citydb.wfs.config.WFSConfig;\nimport vcs.citydb.wfs.exception.WFSException;\nimport vcs.citydb.wfs.exception.WFSExceptionCode;\nimport vcs.citydb.wfs.kvp.KVPConstants;\nimport vcs.citydb.wfs.util.xml.NamespaceFilter;\n\nimport javax.xml.XMLConstants;\nimport javax.xml.bind.*;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.stream.XMLOutputFactory;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpression;\nimport javax.xml.xpath.XPathExpressionException;\nimport javax.xml.xpath.XPathFactory;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.nio.file.DirectoryStream;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class StoredQueryManager {\n\tprivate final String GET_FEATURE_BY_ID_NAME = \"http://www.opengis.net/def/query/OGC-WFS/0/GetFeatureById\";\n\tprivate final String DEPRECATED_GET_FEATURE_BY_ID_NAME = \"urn:ogc:def:query:OGC-WFS::GetFeatureById\";\n\n\tprivate final StoredQuery DEFAULT_QUERY;\n\tprivate final CityGMLBuilder cityGMLBuilder;\n\tprivate final SAXParserFactory saxParserFactory;\n\tprivate final TransformerFactory transformerFactory;\n\tprivate final DocumentBuilderFactory documentBuilderFactory;\n\tprivate final XMLOutputFactory xmlOutputFactory;\n\tprivate final Path storedQueriesPath;\n\tprivate final ObjectFactory wfsFactory;\n\tprivate final WFSConfig wfsConfig;\n\tprivate final MessageDigest md5;\n\n\tpublic StoredQueryManager(CityGMLBuilder cityGMLBuilder, SAXParserFactory saxParserFactory, String path, WFSConfig wfsConfig) throws ParserConfigurationException, SAXException, NoSuchAlgorithmException, IOException, TransformerConfigurationException {\n\t\tthis.cityGMLBuilder = cityGMLBuilder;\n\t\tthis.saxParserFactory = saxParserFactory;\n\t\tthis.wfsConfig = wfsConfig;\n\n\t\tmd5 = MessageDigest.getInstance(\"MD5\");\n\t\twfsFactory = new ObjectFactory();\n\t\ttransformerFactory = SecureXMLProcessors.newTransformerFactory();\n\t\txmlOutputFactory = XMLOutputFactory.newInstance();\n\t\tdocumentBuilderFactory = SecureXMLProcessors.newDocumentBuilderFactory();\n\t\tdocumentBuilderFactory.setNamespaceAware(true);\n\n\t\tstoredQueriesPath = Paths.get(path);",
        "patch": "@@ -4,6 +4,7 @@\n import net.opengis.fes._2.FilterType;\n import net.opengis.fes._2.ResourceIdType;\n import net.opengis.wfs._2.*;\n+import org.citydb.util.xml.SecureXMLProcessors;\n import org.citygml4j.builder.jaxb.CityGMLBuilder;\n import org.citygml4j.model.module.citygml.CityGMLModule;\n import org.citygml4j.model.module.citygml.CityGMLModuleType;\n@@ -27,6 +28,7 @@\n import javax.xml.parsers.SAXParser;\n import javax.xml.parsers.SAXParserFactory;\n import javax.xml.stream.XMLOutputFactory;\n+import javax.xml.transform.TransformerConfigurationException;\n import javax.xml.transform.TransformerFactory;\n import javax.xml.xpath.XPathConstants;\n import javax.xml.xpath.XPathExpression;\n@@ -35,6 +37,7 @@\n import java.io.BufferedReader;\n import java.io.FileReader;\n import java.io.IOException;\n+import java.nio.file.DirectoryStream;\n import java.nio.file.Files;\n import java.nio.file.Path;\n import java.nio.file.Paths;\n@@ -58,16 +61,16 @@ public class StoredQueryManager {\n \tprivate final WFSConfig wfsConfig;\n \tprivate final MessageDigest md5;\n \n-\tpublic StoredQueryManager(CityGMLBuilder cityGMLBuilder, SAXParserFactory saxParserFactory, String path, WFSConfig wfsConfig) throws ParserConfigurationException, SAXException, NoSuchAlgorithmException, IOException {\n+\tpublic StoredQueryManager(CityGMLBuilder cityGMLBuilder, SAXParserFactory saxParserFactory, String path, WFSConfig wfsConfig) throws ParserConfigurationException, SAXException, NoSuchAlgorithmException, IOException, TransformerConfigurationException {\n \t\tthis.cityGMLBuilder = cityGMLBuilder;\n \t\tthis.saxParserFactory = saxParserFactory;\n \t\tthis.wfsConfig = wfsConfig;\n \n \t\tmd5 = MessageDigest.getInstance(\"MD5\");\n \t\twfsFactory = new ObjectFactory();\n-\t\ttransformerFactory = TransformerFactory.newInstance();\n+\t\ttransformerFactory = SecureXMLProcessors.newTransformerFactory();\n \t\txmlOutputFactory = XMLOutputFactory.newInstance();\n-\t\tdocumentBuilderFactory = DocumentBuilderFactory.newInstance();\n+\t\tdocumentBuilderFactory = SecureXMLProcessors.newDocumentBuilderFactory();\n \t\tdocumentBuilderFactory.setNamespaceAware(true);\n \n \t\tstoredQueriesPath = Paths.get(path);\n@@ -83,9 +86,11 @@ public List<StoredQueryAdapter> listStoredQueries(String handle) throws WFSExcep\n \t\tstoredQueries.add(new StoredQueryAdapter(DEFAULT_QUERY.getId()));\n \n \t\ttry {\n-\t\t\tfor (Path file : Files.newDirectoryStream(storedQueriesPath)) {\n-\t\t\t\tif (Files.isRegularFile(file))\n-\t\t\t\t\tstoredQueries.add(new StoredQueryAdapter(file));\n+\t\t\ttry (DirectoryStream<Path> stream = Files.newDirectoryStream(storedQueriesPath)) {\n+\t\t\t\tfor (Path file : stream) {\n+\t\t\t\t\tif (Files.isRegularFile(file))\n+\t\t\t\t\t\tstoredQueries.add(new StoredQueryAdapter(file));\n+\t\t\t\t}\n \t\t\t}\n \t\t} catch (IOException e) {\n \t\t\tthrow new WFSException(WFSExceptionCode.OPERATION_PROCESSING_FAILED, \"Failed to list stored queries.\", handle, e);",
        "function_modified_lines": {
            "added": [
                "import javax.xml.transform.TransformerConfigurationException;\n",
                "import java.nio.file.DirectoryStream;\n"
            ],
            "deleted": []
        },
        "lang": "Java",
        "cwe": [
            "CWE-611"
        ],
        "cve_description": "A vulnerability was found in 3D City Database OGC Web Feature Service up to 5.2.0. It has been rated as problematic. This issue affects some unknown processing. The manipulation leads to xml external entity reference. Upgrading to version 5.2.1 is able to address this issue. The name of the patch is 246f4e2a97ad81491c00a7ed72ce5e7c7f75050a. It is recommended to upgrade the affected component. The associated identifier of this vulnerability is VDB-216215.",
        "id": 12688
    },
    {
        "cve_id": "CVE-2023-4218",
        "code_before_change": "/*******************************************************************************\n * Copyright (c) 2007, 2015 Nokia and others.\n *\n * This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n *\n * Contributors:\n *     Nokia - initial API and implementation\n *******************************************************************************/\npackage org.eclipse.cdt.debug.ui.breakpointactions;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.StringReader;\nimport java.text.MessageFormat;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.eclipse.cdt.debug.core.CDIDebugModel;\nimport org.eclipse.cdt.debug.core.breakpointactions.AbstractBreakpointAction;\nimport org.eclipse.cdt.debug.core.breakpointactions.IResumeActionEnabler;\nimport org.eclipse.cdt.debug.internal.core.ICDebugInternalConstants;\nimport org.eclipse.cdt.debug.internal.ui.IInternalCDebugUIConstants;\nimport org.eclipse.cdt.debug.ui.CDebugUIPlugin;\nimport org.eclipse.core.runtime.IAdaptable;\nimport org.eclipse.core.runtime.IProgressMonitor;\nimport org.eclipse.core.runtime.IStatus;\nimport org.eclipse.core.runtime.MultiStatus;\nimport org.eclipse.core.runtime.Status;\nimport org.eclipse.debug.core.model.IBreakpoint;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.helpers.DefaultHandler;\n\npublic class ResumeAction extends AbstractBreakpointAction {\n\n\tfinal static int INCRIMENT_MSEC = 100;\n\n\tint pauseTime = 0;\n\n\t@Override\n\tpublic IStatus execute(IBreakpoint breakpoint, IAdaptable context, IProgressMonitor monitor) {\n\t\tIStatus errorStatus = null;\n\t\tlong endTime = System.currentTimeMillis() + getPauseTime() * 1000;\n\t\tIResumeActionEnabler enabler = context.getAdapter(IResumeActionEnabler.class);\n\n\t\tif (enabler != null) {\n\t\t\ttry {\n\t\t\t\tmonitor.beginTask(getName(), getPauseTime() * 1000 / INCRIMENT_MSEC);\n\n\t\t\t\tlong currentTime = System.currentTimeMillis();\n\t\t\t\twhile (!monitor.isCanceled() && currentTime < endTime) {\n\t\t\t\t\tmonitor.setTaskName(MessageFormat.format(Messages.getString(\"ResumeAction.SummaryResumeTime\"), //$NON-NLS-1$\n\t\t\t\t\t\t\tnew Object[] { Long.valueOf((endTime - currentTime) / 1000) })); //)\n\t\t\t\t\tmonitor.worked(1);\n\t\t\t\t\tThread.sleep(INCRIMENT_MSEC);\n\t\t\t\t\tcurrentTime = System.currentTimeMillis();\n\t\t\t\t}\n\n\t\t\t\tif (!monitor.isCanceled()) {\n\t\t\t\t\tmonitor.setTaskName(Messages.getString(\"ResumeAction.SummaryImmediately\")); //$NON-NLS-1$)\n\t\t\t\t\tenabler.resume();\n\t\t\t\t}\n\t\t\t\tmonitor.worked(1);\n\t\t\t} catch (Exception e) {\n\t\t\t\terrorStatus = new Status(IStatus.ERROR, CDIDebugModel.getPluginIdentifier(),\n\t\t\t\t\t\tICDebugInternalConstants.STATUS_CODE_ERROR, e.getMessage(), e);\n\t\t\t}\n\t\t} else\n\t\t\terrorStatus = new Status(IStatus.ERROR, CDebugUIPlugin.getUniqueIdentifier(),\n\t\t\t\t\tIInternalCDebugUIConstants.INTERNAL_ERROR, Messages.getString(\"ResumeAction.error.0\"), null); //$NON-NLS-1$\n\n\t\tif (errorStatus != null) {\n\t\t\tMultiStatus ms = new MultiStatus(CDIDebugModel.getPluginIdentifier(),\n\t\t\t\t\tICDebugInternalConstants.STATUS_CODE_ERROR, Messages.getString(\"ResumeAction.error.1\"), null); //$NON-NLS-1$\n\t\t\tms.add(errorStatus);\n\t\t\terrorStatus = ms;\n\t\t} else {\n\t\t\terrorStatus = monitor.isCanceled() ? Status.CANCEL_STATUS : Status.OK_STATUS;\n\t\t}\n\t\treturn errorStatus;\n\t}\n\n\t@Override\n\tpublic String getDefaultName() {\n\t\treturn Messages.getString(\"ResumeAction.UntitledName\"); //$NON-NLS-1$\n\t}\n\n\tpublic int getPauseTime() {\n\t\treturn pauseTime;\n\t}\n\n\tpublic void setPauseTime(int pauseTime) {\n\t\tthis.pauseTime = pauseTime;\n\t}\n\n\t@Override\n\tpublic String getIdentifier() {\n\t\treturn \"org.eclipse.cdt.debug.ui.breakpointactions.ResumeAction\"; //$NON-NLS-1$\n\t}\n\n\t@Override\n\tpublic String getMemento() {\n\t\tString resumeData = \"\"; //$NON-NLS-1$\n\n\t\tDocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();\n\t\tDocumentBuilder docBuilder = null;\n\t\ttry {\n\t\t\tdocBuilder = dfactory.newDocumentBuilder();\n\t\t\tDocument doc = docBuilder.newDocument();\n\n\t\t\tElement rootElement = doc.createElement(\"resumeData\"); //$NON-NLS-1$\n\t\t\trootElement.setAttribute(\"pauseTime\", Integer.toString(pauseTime)); //$NON-NLS-1$\n\n\t\t\tdoc.appendChild(rootElement);\n\n\t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n\n\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n\t\t\tTransformer transformer = factory.newTransformer();\n\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\n\t\t\tDOMSource source = new DOMSource(doc);\n\t\t\tStreamResult outputTarget = new StreamResult(s);\n\t\t\ttransformer.transform(source, outputTarget);\n\n\t\t\tresumeData = s.toString(\"UTF8\"); //$NON-NLS-1$\n\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn resumeData;\n\t}\n\n\t@Override\n\tpublic String getSummary() {\n\t\tif (pauseTime == 0)\n\t\t\treturn Messages.getString(\"ResumeAction.SummaryImmediately\"); //$NON-NLS-1$\n\t\treturn MessageFormat.format(Messages.getString(\"ResumeAction.SummaryResumeTime\"), //$NON-NLS-1$\n\t\t\t\tnew Object[] { Integer.valueOf(pauseTime) });\n\t}\n\n\t@Override\n\tpublic String getTypeName() {\n\t\treturn Messages.getString(\"ResumeAction.TypeName\"); //$NON-NLS-1$\n\t}\n\n\t@Override\n\tpublic void initializeFromMemento(String data) {\n\t\tElement root = null;\n\t\tDocumentBuilder parser;\n\t\ttry {\n\t\t\tparser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n\t\t\tparser.setErrorHandler(new DefaultHandler());\n\t\t\troot = parser.parse(new InputSource(new StringReader(data))).getDocumentElement();\n\t\t\tString value = root.getAttribute(\"pauseTime\"); //$NON-NLS-1$\n\t\t\tif (value == null)\n\t\t\t\tthrow new Exception();\n\t\t\tpauseTime = Integer.parseInt(value);\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n}\n",
        "code_after_change": "/*******************************************************************************\n * Copyright (c) 2007, 2015 Nokia and others.\n *\n * This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n *\n * Contributors:\n *     Nokia - initial API and implementation\n *******************************************************************************/\npackage org.eclipse.cdt.debug.ui.breakpointactions;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.StringReader;\nimport java.text.MessageFormat;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.eclipse.cdt.debug.core.CDIDebugModel;\nimport org.eclipse.cdt.debug.core.breakpointactions.AbstractBreakpointAction;\nimport org.eclipse.cdt.debug.core.breakpointactions.IResumeActionEnabler;\nimport org.eclipse.cdt.debug.internal.core.ICDebugInternalConstants;\nimport org.eclipse.cdt.debug.internal.ui.IInternalCDebugUIConstants;\nimport org.eclipse.cdt.debug.ui.CDebugUIPlugin;\nimport org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\nimport org.eclipse.core.runtime.IAdaptable;\nimport org.eclipse.core.runtime.IProgressMonitor;\nimport org.eclipse.core.runtime.IStatus;\nimport org.eclipse.core.runtime.MultiStatus;\nimport org.eclipse.core.runtime.Status;\nimport org.eclipse.debug.core.model.IBreakpoint;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.helpers.DefaultHandler;\n\npublic class ResumeAction extends AbstractBreakpointAction {\n\n\tfinal static int INCRIMENT_MSEC = 100;\n\n\tint pauseTime = 0;\n\n\t@Override\n\tpublic IStatus execute(IBreakpoint breakpoint, IAdaptable context, IProgressMonitor monitor) {\n\t\tIStatus errorStatus = null;\n\t\tlong endTime = System.currentTimeMillis() + getPauseTime() * 1000;\n\t\tIResumeActionEnabler enabler = context.getAdapter(IResumeActionEnabler.class);\n\n\t\tif (enabler != null) {\n\t\t\ttry {\n\t\t\t\tmonitor.beginTask(getName(), getPauseTime() * 1000 / INCRIMENT_MSEC);\n\n\t\t\t\tlong currentTime = System.currentTimeMillis();\n\t\t\t\twhile (!monitor.isCanceled() && currentTime < endTime) {\n\t\t\t\t\tmonitor.setTaskName(MessageFormat.format(Messages.getString(\"ResumeAction.SummaryResumeTime\"), //$NON-NLS-1$\n\t\t\t\t\t\t\tnew Object[] { Long.valueOf((endTime - currentTime) / 1000) })); //)\n\t\t\t\t\tmonitor.worked(1);\n\t\t\t\t\tThread.sleep(INCRIMENT_MSEC);\n\t\t\t\t\tcurrentTime = System.currentTimeMillis();\n\t\t\t\t}\n\n\t\t\t\tif (!monitor.isCanceled()) {\n\t\t\t\t\tmonitor.setTaskName(Messages.getString(\"ResumeAction.SummaryImmediately\")); //$NON-NLS-1$)\n\t\t\t\t\tenabler.resume();\n\t\t\t\t}\n\t\t\t\tmonitor.worked(1);\n\t\t\t} catch (Exception e) {\n\t\t\t\terrorStatus = new Status(IStatus.ERROR, CDIDebugModel.getPluginIdentifier(),\n\t\t\t\t\t\tICDebugInternalConstants.STATUS_CODE_ERROR, e.getMessage(), e);\n\t\t\t}\n\t\t} else\n\t\t\terrorStatus = new Status(IStatus.ERROR, CDebugUIPlugin.getUniqueIdentifier(),\n\t\t\t\t\tIInternalCDebugUIConstants.INTERNAL_ERROR, Messages.getString(\"ResumeAction.error.0\"), null); //$NON-NLS-1$\n\n\t\tif (errorStatus != null) {\n\t\t\tMultiStatus ms = new MultiStatus(CDIDebugModel.getPluginIdentifier(),\n\t\t\t\t\tICDebugInternalConstants.STATUS_CODE_ERROR, Messages.getString(\"ResumeAction.error.1\"), null); //$NON-NLS-1$\n\t\t\tms.add(errorStatus);\n\t\t\terrorStatus = ms;\n\t\t} else {\n\t\t\terrorStatus = monitor.isCanceled() ? Status.CANCEL_STATUS : Status.OK_STATUS;\n\t\t}\n\t\treturn errorStatus;\n\t}\n\n\t@Override\n\tpublic String getDefaultName() {\n\t\treturn Messages.getString(\"ResumeAction.UntitledName\"); //$NON-NLS-1$\n\t}\n\n\tpublic int getPauseTime() {\n\t\treturn pauseTime;\n\t}\n\n\tpublic void setPauseTime(int pauseTime) {\n\t\tthis.pauseTime = pauseTime;\n\t}\n\n\t@Override\n\tpublic String getIdentifier() {\n\t\treturn \"org.eclipse.cdt.debug.ui.breakpointactions.ResumeAction\"; //$NON-NLS-1$\n\t}\n\n\t@Override\n\tpublic String getMemento() {\n\t\tString resumeData = \"\"; //$NON-NLS-1$\n\n\t\ttry {\n\t\t\tDocumentBuilder docBuilder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n\t\t\tDocument doc = docBuilder.newDocument();\n\n\t\t\tElement rootElement = doc.createElement(\"resumeData\"); //$NON-NLS-1$\n\t\t\trootElement.setAttribute(\"pauseTime\", Integer.toString(pauseTime)); //$NON-NLS-1$\n\n\t\t\tdoc.appendChild(rootElement);\n\n\t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n\n\t\t\tTransformerFactory factory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n\t\t\tTransformer transformer = factory.newTransformer();\n\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\n\t\t\tDOMSource source = new DOMSource(doc);\n\t\t\tStreamResult outputTarget = new StreamResult(s);\n\t\t\ttransformer.transform(source, outputTarget);\n\n\t\t\tresumeData = s.toString(\"UTF8\"); //$NON-NLS-1$\n\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn resumeData;\n\t}\n\n\t@Override\n\tpublic String getSummary() {\n\t\tif (pauseTime == 0)\n\t\t\treturn Messages.getString(\"ResumeAction.SummaryImmediately\"); //$NON-NLS-1$\n\t\treturn MessageFormat.format(Messages.getString(\"ResumeAction.SummaryResumeTime\"), //$NON-NLS-1$\n\t\t\t\tnew Object[] { Integer.valueOf(pauseTime) });\n\t}\n\n\t@Override\n\tpublic String getTypeName() {\n\t\treturn Messages.getString(\"ResumeAction.TypeName\"); //$NON-NLS-1$\n\t}\n\n\t@Override\n\tpublic void initializeFromMemento(String data) {\n\t\tElement root = null;\n\t\tDocumentBuilder parser;\n\t\ttry {\n\t\t\tparser = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n\t\t\tparser.setErrorHandler(new DefaultHandler());\n\t\t\troot = parser.parse(new InputSource(new StringReader(data))).getDocumentElement();\n\t\t\tString value = root.getAttribute(\"pauseTime\"); //$NON-NLS-1$\n\t\t\tif (value == null)\n\t\t\t\tthrow new Exception();\n\t\t\tpauseTime = Integer.parseInt(value);\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n}\n",
        "patch": "@@ -18,7 +18,6 @@\n import java.text.MessageFormat;\n \n import javax.xml.parsers.DocumentBuilder;\n-import javax.xml.parsers.DocumentBuilderFactory;\n import javax.xml.transform.OutputKeys;\n import javax.xml.transform.Transformer;\n import javax.xml.transform.TransformerFactory;\n@@ -31,6 +30,7 @@\n import org.eclipse.cdt.debug.internal.core.ICDebugInternalConstants;\n import org.eclipse.cdt.debug.internal.ui.IInternalCDebugUIConstants;\n import org.eclipse.cdt.debug.ui.CDebugUIPlugin;\n+import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n import org.eclipse.core.runtime.IAdaptable;\n import org.eclipse.core.runtime.IProgressMonitor;\n import org.eclipse.core.runtime.IStatus;\n@@ -113,10 +113,8 @@ public String getIdentifier() {\n \tpublic String getMemento() {\n \t\tString resumeData = \"\"; //$NON-NLS-1$\n \n-\t\tDocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();\n-\t\tDocumentBuilder docBuilder = null;\n \t\ttry {\n-\t\t\tdocBuilder = dfactory.newDocumentBuilder();\n+\t\t\tDocumentBuilder docBuilder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tDocument doc = docBuilder.newDocument();\n \n \t\t\tElement rootElement = doc.createElement(\"resumeData\"); //$NON-NLS-1$\n@@ -126,7 +124,7 @@ public String getMemento() {\n \n \t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n \n-\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n+\t\t\tTransformerFactory factory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n \t\t\tTransformer transformer = factory.newTransformer();\n \t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n \t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n@@ -161,7 +159,7 @@ public void initializeFromMemento(String data) {\n \t\tElement root = null;\n \t\tDocumentBuilder parser;\n \t\ttry {\n-\t\t\tparser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n+\t\t\tparser = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tparser.setErrorHandler(new DefaultHandler());\n \t\t\troot = parser.parse(new InputSource(new StringReader(data))).getDocumentElement();\n \t\t\tString value = root.getAttribute(\"pauseTime\"); //$NON-NLS-1$",
        "function_modified_lines": {
            "added": [
                "import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n"
            ],
            "deleted": [
                "import javax.xml.parsers.DocumentBuilderFactory;\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-611"
        ],
        "cve_description": "In Eclipse IDE versions < 2023-09 (4.29) some files with xml content are parsed vulnerable against all sorts of XXE attacks. The user just needs to open any evil project or update an open project with a vulnerable file (for example for review a foreign repository or patch).\n",
        "id": 12883
    },
    {
        "cve_id": "CVE-2023-4218",
        "code_before_change": "{\n\t\tString collectData = \"\"; //$NON-NLS-1$\n\n\t\tDocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();\n\t\tDocumentBuilder docBuilder = null;\n\t\ttry {\n\t\t\tdocBuilder = dfactory.newDocumentBuilder();\n\t\t\tDocument doc = docBuilder.newDocument();\n\n\t\t\tElement rootElement = doc.createElement(COLLECT_ACTION_ELEMENT_NAME);\n\n\t\t\t// Store the different attributes of this collect action\n\t\t\trootElement.setAttribute(COLLECT_STRING_ATTR, fCollectString);\n\t\t\trootElement.setAttribute(COLLECT_AS_STRING_ATTR, Boolean.toString(fCharPtrAsStrings));\n\t\t\trootElement.setAttribute(COLLECT_AS_STRING_LIMIT_ATTR,\n\t\t\t\t\tfCharPtrAsStringsLimit == null ? \"\" : fCharPtrAsStringsLimit.toString()); //$NON-NLS-1$\n\n\t\t\tdoc.appendChild(rootElement);\n\n\t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n\n\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n\t\t\tTransformer transformer = factory.newTransformer();\n\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\n\t\t\tDOMSource source = new DOMSource(doc);\n\t\t\tStreamResult outputTarget = new StreamResult(s);\n\t\t\ttransformer.transform(source, outputTarget);\n\n\t\t\tcollectData = s.toString(\"UTF8\"); //$NON-NLS-1$\n\n\t\t} catch (Exception e) {\n\t\t\tGdbPlugin.log(e);\n\t\t}\n\t\treturn collectData;\n\t}",
        "code_after_change": "{\n\t\t\tDocumentBuilder docBuilder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n\t\t\tDocument doc = docBuilder.newDocument();\n\n\t\t\tElement rootElement = doc.createElement(COLLECT_ACTION_ELEMENT_NAME);\n\n\t\t\t// Store the different attributes of this collect action\n\t\t\trootElement.setAttribute(COLLECT_STRING_ATTR, fCollectString);\n\t\t\trootElement.setAttribute(COLLECT_AS_STRING_ATTR, Boolean.toString(fCharPtrAsStrings));\n\t\t\trootElement.setAttribute(COLLECT_AS_STRING_LIMIT_ATTR,\n\t\t\t\t\tfCharPtrAsStringsLimit == null ? \"\" : fCharPtrAsStringsLimit.toString()); //$NON-NLS-1$\n\n\t\t\tdoc.appendChild(rootElement);\n\n\t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n\n\t\t\tTransformerFactory factory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n\t\t\tTransformer transformer = factory.newTransformer();\n\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\n\t\t\tDOMSource source = new DOMSource(doc);\n\t\t\tStreamResult outputTarget = new StreamResult(s);\n\t\t\ttransformer.transform(source, outputTarget);\n\n\t\t\tcollectData = s.toString(\"UTF8\"); //$NON-NLS-1$\n\n\t\t}",
        "patch": "@@ -18,14 +18,14 @@\n import java.io.StringReader;\n \n import javax.xml.parsers.DocumentBuilder;\n-import javax.xml.parsers.DocumentBuilderFactory;\n import javax.xml.transform.OutputKeys;\n import javax.xml.transform.Transformer;\n import javax.xml.transform.TransformerFactory;\n import javax.xml.transform.dom.DOMSource;\n import javax.xml.transform.stream.StreamResult;\n \n import org.eclipse.cdt.dsf.gdb.internal.GdbPlugin;\n+import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n import org.w3c.dom.Document;\n import org.w3c.dom.Element;\n import org.xml.sax.InputSource;\n@@ -124,10 +124,8 @@ public String getIdentifier() {\n \tpublic String getMemento() {\n \t\tString collectData = \"\"; //$NON-NLS-1$\n \n-\t\tDocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();\n-\t\tDocumentBuilder docBuilder = null;\n \t\ttry {\n-\t\t\tdocBuilder = dfactory.newDocumentBuilder();\n+\t\t\tDocumentBuilder docBuilder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tDocument doc = docBuilder.newDocument();\n \n \t\t\tElement rootElement = doc.createElement(COLLECT_ACTION_ELEMENT_NAME);\n@@ -142,7 +140,7 @@ public String getMemento() {\n \n \t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n \n-\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n+\t\t\tTransformerFactory factory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n \t\t\tTransformer transformer = factory.newTransformer();\n \t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n \t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n@@ -189,7 +187,7 @@ public void initializeFromMemento(String data) {\n \t\tElement root = null;\n \t\tDocumentBuilder parser;\n \t\ttry {\n-\t\t\tparser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n+\t\t\tparser = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tparser.setErrorHandler(new DefaultHandler());\n \t\t\troot = parser.parse(new InputSource(new StringReader(data))).getDocumentElement();\n ",
        "function_modified_lines": {
            "added": [
                "\t\t\tDocumentBuilder docBuilder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n",
                "\t\t\tTransformerFactory factory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n"
            ],
            "deleted": [
                "\t\tDocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();\n",
                "\t\tDocumentBuilder docBuilder = null;\n",
                "\t\t\tdocBuilder = dfactory.newDocumentBuilder();\n",
                "\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-611"
        ],
        "cve_description": "In Eclipse IDE versions < 2023-09 (4.29) some files with xml content are parsed vulnerable against all sorts of XXE attacks. The user just needs to open any evil project or update an open project with a vulnerable file (for example for review a foreign repository or patch).\n",
        "id": 12893
    },
    {
        "cve_id": "CVE-2023-4218",
        "code_before_change": "/*******************************************************************************\n * Copyright (c) 2010, 2016 Ericsson and others.\n *\n * This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n *\n * Contributors:\n *     Ericsson - initial API and implementation\n *     Marc Khouzam (Ericsson) - Don't use translatable strings for the command summary\n *                               since it will be send directly to GDB\n *******************************************************************************/\npackage org.eclipse.cdt.dsf.gdb.internal.tracepointactions;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.StringReader;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.eclipse.cdt.dsf.gdb.internal.GdbPlugin;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.helpers.DefaultHandler;\n\n/**\n * @since 3.0\n */\npublic class WhileSteppingAction extends AbstractTracepointAction {\n\tprivate static final String WHILE_STEPPING_ACTION_ID = \"org.eclipse.cdt.dsf.gdb.tracepointactions.WhileSteppingAction\"; //$NON-NLS-1$\n\n\t// The name of the sub actions\n\tprivate String fSubActionNames = \"\"; //$NON-NLS-1$\n\t// A comma-separated string of the actual content of each sub command\n\t// This is the string than can be sent to GDB\n\tprivate String fSubActionContent = \"\"; //$NON-NLS-1$\n\t// The number of steps this while-stepping command will occur\n\tprivate int fStepCount = 1;\n\n\t@Override\n\tpublic String getDefaultName() {\n\t\treturn MessagesForTracepointActions.TracepointActions_Untitled_WhileStepping;\n\t}\n\n\tpublic String getSubActionsNames() {\n\t\treturn fSubActionNames;\n\t}\n\n\tpublic void setSubActionsNames(String str) {\n\t\tfSubActionNames = str;\n\t}\n\n\tpublic String getSubActionsContent() {\n\t\treturn fSubActionContent;\n\t}\n\n\t// Take all the sub action names, and find their corresponding action,\n\t// then build the content string\n\tpublic void setSubActionsContent(String subActionNames) {\n\t\tString[] names = subActionNames.split(\",\"); //$NON-NLS-1$\n\t\tfSubActionContent = \"\"; //$NON-NLS-1$\n\n\t\tfor (String name : names) {\n\t\t\tITracepointAction action = TracepointActionManager.getInstance().findAction(name.trim());\n\t\t\tif (action != null) {\n\t\t\t\tfSubActionContent += action.getSummary() + \",\"; //$NON-NLS-1$\n\t\t\t}\n\t\t}\n\t\t// Remove last comma\n\t\tif (fSubActionContent.length() > 0) {\n\t\t\tfSubActionContent = fSubActionContent.substring(0, fSubActionContent.length() - 1);\n\t\t}\n\t}\n\n\tpublic int getStepCount() {\n\t\treturn fStepCount;\n\t}\n\n\tpublic void setStepCount(int count) {\n\t\tfStepCount = count;\n\t}\n\n\t@Override\n\tpublic String getIdentifier() {\n\t\treturn WHILE_STEPPING_ACTION_ID;\n\t}\n\n\t@Override\n\tpublic String getMemento() {\n\t\tString collectData = \"\"; //$NON-NLS-1$\n\n\t\tDocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();\n\t\tDocumentBuilder docBuilder = null;\n\t\ttry {\n\t\t\tdocBuilder = dfactory.newDocumentBuilder();\n\t\t\tDocument doc = docBuilder.newDocument();\n\n\t\t\tElement rootElement = doc.createElement(\"whileSteppingData\"); //$NON-NLS-1$\n\t\t\trootElement.setAttribute(\"whileSteppingCount\", Integer.toString(fStepCount)); //$NON-NLS-1$\n\t\t\trootElement.setAttribute(\"subActionNames\", fSubActionNames); //$NON-NLS-1$\n\n\t\t\tdoc.appendChild(rootElement);\n\n\t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n\n\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n\t\t\tTransformer transformer = factory.newTransformer();\n\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\n\t\t\tDOMSource source = new DOMSource(doc);\n\t\t\tStreamResult outputTarget = new StreamResult(s);\n\t\t\ttransformer.transform(source, outputTarget);\n\n\t\t\tcollectData = s.toString(\"UTF8\"); //$NON-NLS-1$\n\n\t\t} catch (Exception e) {\n\t\t\tGdbPlugin.log(e);\n\t\t}\n\t\treturn collectData;\n\t}\n\n\t@Override\n\tpublic String getSummary() {\n\t\t// Create command to be sent to GDB\n\t\treturn String.format(\"while-stepping %s %s\", fStepCount, fSubActionContent); //$NON-NLS-1$\n\t}\n\n\t@Override\n\tpublic String getTypeName() {\n\t\treturn MessagesForTracepointActions.TracepointActions_WhileStepping_Name;\n\t}\n\n\t@Override\n\tpublic void initializeFromMemento(String data) {\n\t\tElement root = null;\n\t\tDocumentBuilder parser;\n\t\ttry {\n\t\t\tparser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n\t\t\tparser.setErrorHandler(new DefaultHandler());\n\t\t\troot = parser.parse(new InputSource(new StringReader(data))).getDocumentElement();\n\t\t\tsetStepCount(Integer.parseInt(root.getAttribute(\"whileSteppingCount\"))); //$NON-NLS-1$\n\t\t\tsetSubActionsNames(root.getAttribute(\"subActionNames\")); //$NON-NLS-1$\n\t\t\tif (fSubActionNames == null)\n\t\t\t\tthrow new Exception();\n\t\t\tsetSubActionsContent(fSubActionNames);\n\t\t} catch (Exception e) {\n\t\t\tGdbPlugin.log(e);\n\t\t}\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn getSummary();\n\t}\n}\n",
        "code_after_change": "/*******************************************************************************\n * Copyright (c) 2010, 2016 Ericsson and others.\n *\n * This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n *\n * Contributors:\n *     Ericsson - initial API and implementation\n *     Marc Khouzam (Ericsson) - Don't use translatable strings for the command summary\n *                               since it will be send directly to GDB\n *******************************************************************************/\npackage org.eclipse.cdt.dsf.gdb.internal.tracepointactions;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.StringReader;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.eclipse.cdt.dsf.gdb.internal.GdbPlugin;\nimport org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.helpers.DefaultHandler;\n\n/**\n * @since 3.0\n */\npublic class WhileSteppingAction extends AbstractTracepointAction {\n\tprivate static final String WHILE_STEPPING_ACTION_ID = \"org.eclipse.cdt.dsf.gdb.tracepointactions.WhileSteppingAction\"; //$NON-NLS-1$\n\n\t// The name of the sub actions\n\tprivate String fSubActionNames = \"\"; //$NON-NLS-1$\n\t// A comma-separated string of the actual content of each sub command\n\t// This is the string than can be sent to GDB\n\tprivate String fSubActionContent = \"\"; //$NON-NLS-1$\n\t// The number of steps this while-stepping command will occur\n\tprivate int fStepCount = 1;\n\n\t@Override\n\tpublic String getDefaultName() {\n\t\treturn MessagesForTracepointActions.TracepointActions_Untitled_WhileStepping;\n\t}\n\n\tpublic String getSubActionsNames() {\n\t\treturn fSubActionNames;\n\t}\n\n\tpublic void setSubActionsNames(String str) {\n\t\tfSubActionNames = str;\n\t}\n\n\tpublic String getSubActionsContent() {\n\t\treturn fSubActionContent;\n\t}\n\n\t// Take all the sub action names, and find their corresponding action,\n\t// then build the content string\n\tpublic void setSubActionsContent(String subActionNames) {\n\t\tString[] names = subActionNames.split(\",\"); //$NON-NLS-1$\n\t\tfSubActionContent = \"\"; //$NON-NLS-1$\n\n\t\tfor (String name : names) {\n\t\t\tITracepointAction action = TracepointActionManager.getInstance().findAction(name.trim());\n\t\t\tif (action != null) {\n\t\t\t\tfSubActionContent += action.getSummary() + \",\"; //$NON-NLS-1$\n\t\t\t}\n\t\t}\n\t\t// Remove last comma\n\t\tif (fSubActionContent.length() > 0) {\n\t\t\tfSubActionContent = fSubActionContent.substring(0, fSubActionContent.length() - 1);\n\t\t}\n\t}\n\n\tpublic int getStepCount() {\n\t\treturn fStepCount;\n\t}\n\n\tpublic void setStepCount(int count) {\n\t\tfStepCount = count;\n\t}\n\n\t@Override\n\tpublic String getIdentifier() {\n\t\treturn WHILE_STEPPING_ACTION_ID;\n\t}\n\n\t@Override\n\tpublic String getMemento() {\n\t\tString collectData = \"\"; //$NON-NLS-1$\n\n\t\ttry {\n\t\t\tDocumentBuilder docBuilder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n\t\t\tDocument doc = docBuilder.newDocument();\n\n\t\t\tElement rootElement = doc.createElement(\"whileSteppingData\"); //$NON-NLS-1$\n\t\t\trootElement.setAttribute(\"whileSteppingCount\", Integer.toString(fStepCount)); //$NON-NLS-1$\n\t\t\trootElement.setAttribute(\"subActionNames\", fSubActionNames); //$NON-NLS-1$\n\n\t\t\tdoc.appendChild(rootElement);\n\n\t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n\n\t\t\tTransformerFactory factory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n\t\t\tTransformer transformer = factory.newTransformer();\n\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\n\t\t\tDOMSource source = new DOMSource(doc);\n\t\t\tStreamResult outputTarget = new StreamResult(s);\n\t\t\ttransformer.transform(source, outputTarget);\n\n\t\t\tcollectData = s.toString(\"UTF8\"); //$NON-NLS-1$\n\n\t\t} catch (Exception e) {\n\t\t\tGdbPlugin.log(e);\n\t\t}\n\t\treturn collectData;\n\t}\n\n\t@Override\n\tpublic String getSummary() {\n\t\t// Create command to be sent to GDB\n\t\treturn String.format(\"while-stepping %s %s\", fStepCount, fSubActionContent); //$NON-NLS-1$\n\t}\n\n\t@Override\n\tpublic String getTypeName() {\n\t\treturn MessagesForTracepointActions.TracepointActions_WhileStepping_Name;\n\t}\n\n\t@Override\n\tpublic void initializeFromMemento(String data) {\n\t\tElement root = null;\n\t\tDocumentBuilder parser;\n\t\ttry {\n\t\t\tparser = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n\t\t\tparser.setErrorHandler(new DefaultHandler());\n\t\t\troot = parser.parse(new InputSource(new StringReader(data))).getDocumentElement();\n\t\t\tsetStepCount(Integer.parseInt(root.getAttribute(\"whileSteppingCount\"))); //$NON-NLS-1$\n\t\t\tsetSubActionsNames(root.getAttribute(\"subActionNames\")); //$NON-NLS-1$\n\t\t\tif (fSubActionNames == null)\n\t\t\t\tthrow new Exception();\n\t\t\tsetSubActionsContent(fSubActionNames);\n\t\t} catch (Exception e) {\n\t\t\tGdbPlugin.log(e);\n\t\t}\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn getSummary();\n\t}\n}\n",
        "patch": "@@ -19,14 +19,14 @@\n import java.io.StringReader;\n \n import javax.xml.parsers.DocumentBuilder;\n-import javax.xml.parsers.DocumentBuilderFactory;\n import javax.xml.transform.OutputKeys;\n import javax.xml.transform.Transformer;\n import javax.xml.transform.TransformerFactory;\n import javax.xml.transform.dom.DOMSource;\n import javax.xml.transform.stream.StreamResult;\n \n import org.eclipse.cdt.dsf.gdb.internal.GdbPlugin;\n+import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n import org.w3c.dom.Document;\n import org.w3c.dom.Element;\n import org.xml.sax.InputSource;\n@@ -98,10 +98,8 @@ public String getIdentifier() {\n \tpublic String getMemento() {\n \t\tString collectData = \"\"; //$NON-NLS-1$\n \n-\t\tDocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();\n-\t\tDocumentBuilder docBuilder = null;\n \t\ttry {\n-\t\t\tdocBuilder = dfactory.newDocumentBuilder();\n+\t\t\tDocumentBuilder docBuilder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tDocument doc = docBuilder.newDocument();\n \n \t\t\tElement rootElement = doc.createElement(\"whileSteppingData\"); //$NON-NLS-1$\n@@ -112,7 +110,7 @@ public String getMemento() {\n \n \t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n \n-\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n+\t\t\tTransformerFactory factory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n \t\t\tTransformer transformer = factory.newTransformer();\n \t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n \t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n@@ -145,7 +143,7 @@ public void initializeFromMemento(String data) {\n \t\tElement root = null;\n \t\tDocumentBuilder parser;\n \t\ttry {\n-\t\t\tparser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n+\t\t\tparser = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tparser.setErrorHandler(new DefaultHandler());\n \t\t\troot = parser.parse(new InputSource(new StringReader(data))).getDocumentElement();\n \t\t\tsetStepCount(Integer.parseInt(root.getAttribute(\"whileSteppingCount\"))); //$NON-NLS-1$",
        "function_modified_lines": {
            "added": [
                "import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n"
            ],
            "deleted": [
                "import javax.xml.parsers.DocumentBuilderFactory;\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-611"
        ],
        "cve_description": "In Eclipse IDE versions < 2023-09 (4.29) some files with xml content are parsed vulnerable against all sorts of XXE attacks. The user just needs to open any evil project or update an open project with a vulnerable file (for example for review a foreign repository or patch).\n",
        "id": 12897
    },
    {
        "cve_id": "CVE-2023-4218",
        "code_before_change": "try {\n\t\t\tsaxParser = SAXParserFactory.newInstance().newSAXParser();\n\t\t} catch (ParserConfigurationException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn null;\n\t\t} catch (SAXException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn null;\n\t\t}",
        "code_after_change": "try {\n\t\t\t@SuppressWarnings(\"restriction\")\n\t\t\tSAXParser p = org.eclipse.core.internal.runtime.XmlProcessorFactory.createSAXParserWithErrorOnDOCTYPE();\n\t\t\tsaxParser =p;\n\t\t} catch (SAXException | ParserConfigurationException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn null;\n\t\t}",
        "patch": "@@ -42,11 +42,10 @@ public static String[] buildTables(\n \t\tList<String> result = new ArrayList<>();\n \t\tSAXParser saxParser = null;\n \t\ttry {\n-\t\t\tsaxParser = SAXParserFactory.newInstance().newSAXParser();\n-\t\t} catch (ParserConfigurationException e) {\n-\t\t\te.printStackTrace();\n-\t\t\treturn null;\n-\t\t} catch (SAXException e) {\n+\t\t\t@SuppressWarnings(\"restriction\")\n+\t\t\tSAXParser p = org.eclipse.core.internal.runtime.XmlProcessorFactory.createSAXParserWithErrorOnDOCTYPE();\n+\t\t\tsaxParser =p;\n+\t\t} catch (SAXException | ParserConfigurationException e) {\n \t\t\te.printStackTrace();\n \t\t\treturn null;\n \t\t}",
        "function_modified_lines": {
            "added": [
                "\t\t\t@SuppressWarnings(\"restriction\")\n",
                "\t\t\tSAXParser p = org.eclipse.core.internal.runtime.XmlProcessorFactory.createSAXParserWithErrorOnDOCTYPE();\n",
                "\t\t\tsaxParser =p;\n",
                "\t\t} catch (SAXException | ParserConfigurationException e) {\n"
            ],
            "deleted": [
                "\t\t\tsaxParser = SAXParserFactory.newInstance().newSAXParser();\n",
                "\t\t} catch (ParserConfigurationException e) {\n",
                "\t\t\te.printStackTrace();\n",
                "\t\t\treturn null;\n",
                "\t\t} catch (SAXException e) {\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-611"
        ],
        "cve_description": "In Eclipse IDE versions < 2023-09 (4.29) some files with xml content are parsed vulnerable against all sorts of XXE attacks. The user just needs to open any evil project or update an open project with a vulnerable file (for example for review a foreign repository or patch).\n",
        "id": 12855
    },
    {
        "cve_id": "CVE-2023-4218",
        "code_before_change": "{\n\t\tString collectData = \"\"; //$NON-NLS-1$\n\n\t\tDocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();\n\t\tDocumentBuilder docBuilder = null;\n\t\ttry {\n\t\t\tdocBuilder = dfactory.newDocumentBuilder();\n\t\t\tDocument doc = docBuilder.newDocument();\n\n\t\t\tElement rootElement = doc.createElement(\"whileSteppingData\"); //$NON-NLS-1$\n\t\t\trootElement.setAttribute(\"whileSteppingCount\", Integer.toString(fStepCount)); //$NON-NLS-1$\n\t\t\trootElement.setAttribute(\"subActionNames\", fSubActionNames); //$NON-NLS-1$\n\n\t\t\tdoc.appendChild(rootElement);\n\n\t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n\n\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n\t\t\tTransformer transformer = factory.newTransformer();\n\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\n\t\t\tDOMSource source = new DOMSource(doc);\n\t\t\tStreamResult outputTarget = new StreamResult(s);\n\t\t\ttransformer.transform(source, outputTarget);\n\n\t\t\tcollectData = s.toString(\"UTF8\"); //$NON-NLS-1$\n\n\t\t} catch (Exception e) {\n\t\t\tGdbPlugin.log(e);\n\t\t}\n\t\treturn collectData;\n\t}",
        "code_after_change": "{\n\t\t\tDocumentBuilder docBuilder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n\t\t\tDocument doc = docBuilder.newDocument();\n\n\t\t\tElement rootElement = doc.createElement(\"whileSteppingData\"); //$NON-NLS-1$\n\t\t\trootElement.setAttribute(\"whileSteppingCount\", Integer.toString(fStepCount)); //$NON-NLS-1$\n\t\t\trootElement.setAttribute(\"subActionNames\", fSubActionNames); //$NON-NLS-1$\n\n\t\t\tdoc.appendChild(rootElement);\n\n\t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n\n\t\t\tTransformerFactory factory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n\t\t\tTransformer transformer = factory.newTransformer();\n\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\n\t\t\tDOMSource source = new DOMSource(doc);\n\t\t\tStreamResult outputTarget = new StreamResult(s);\n\t\t\ttransformer.transform(source, outputTarget);\n\n\t\t\tcollectData = s.toString(\"UTF8\"); //$NON-NLS-1$\n\n\t\t}",
        "patch": "@@ -19,14 +19,14 @@\n import java.io.StringReader;\n \n import javax.xml.parsers.DocumentBuilder;\n-import javax.xml.parsers.DocumentBuilderFactory;\n import javax.xml.transform.OutputKeys;\n import javax.xml.transform.Transformer;\n import javax.xml.transform.TransformerFactory;\n import javax.xml.transform.dom.DOMSource;\n import javax.xml.transform.stream.StreamResult;\n \n import org.eclipse.cdt.dsf.gdb.internal.GdbPlugin;\n+import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n import org.w3c.dom.Document;\n import org.w3c.dom.Element;\n import org.xml.sax.InputSource;\n@@ -98,10 +98,8 @@ public String getIdentifier() {\n \tpublic String getMemento() {\n \t\tString collectData = \"\"; //$NON-NLS-1$\n \n-\t\tDocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();\n-\t\tDocumentBuilder docBuilder = null;\n \t\ttry {\n-\t\t\tdocBuilder = dfactory.newDocumentBuilder();\n+\t\t\tDocumentBuilder docBuilder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tDocument doc = docBuilder.newDocument();\n \n \t\t\tElement rootElement = doc.createElement(\"whileSteppingData\"); //$NON-NLS-1$\n@@ -112,7 +110,7 @@ public String getMemento() {\n \n \t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n \n-\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n+\t\t\tTransformerFactory factory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n \t\t\tTransformer transformer = factory.newTransformer();\n \t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n \t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n@@ -145,7 +143,7 @@ public void initializeFromMemento(String data) {\n \t\tElement root = null;\n \t\tDocumentBuilder parser;\n \t\ttry {\n-\t\t\tparser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n+\t\t\tparser = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tparser.setErrorHandler(new DefaultHandler());\n \t\t\troot = parser.parse(new InputSource(new StringReader(data))).getDocumentElement();\n \t\t\tsetStepCount(Integer.parseInt(root.getAttribute(\"whileSteppingCount\"))); //$NON-NLS-1$",
        "function_modified_lines": {
            "added": [
                "\t\t\tDocumentBuilder docBuilder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n",
                "\t\t\tTransformerFactory factory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n"
            ],
            "deleted": [
                "\t\tDocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();\n",
                "\t\tDocumentBuilder docBuilder = null;\n",
                "\t\t\tdocBuilder = dfactory.newDocumentBuilder();\n",
                "\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-611"
        ],
        "cve_description": "In Eclipse IDE versions < 2023-09 (4.29) some files with xml content are parsed vulnerable against all sorts of XXE attacks. The user just needs to open any evil project or update an open project with a vulnerable file (for example for review a foreign repository or patch).\n",
        "id": 12898
    },
    {
        "cve_id": "CVE-2023-4218",
        "code_before_change": "/*******************************************************************************\n * Copyright (c) 2007, 2014 Nokia and others.\n *\n * This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n *\n * Contributors:\n *     Nokia - initial API and implementation\n *******************************************************************************/\npackage org.eclipse.cdt.debug.core.breakpointactions;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.StringReader;\nimport java.util.ArrayList;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.eclipse.cdt.debug.core.CDebugCorePlugin;\nimport org.eclipse.core.resources.IMarker;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.IAdaptable;\nimport org.eclipse.core.runtime.IConfigurationElement;\nimport org.eclipse.core.runtime.IExtension;\nimport org.eclipse.core.runtime.IExtensionPoint;\nimport org.eclipse.core.runtime.IProgressMonitor;\nimport org.eclipse.core.runtime.IStatus;\nimport org.eclipse.core.runtime.Platform;\nimport org.eclipse.core.runtime.Status;\nimport org.eclipse.core.runtime.jobs.Job;\nimport org.eclipse.debug.core.model.IBreakpoint;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.helpers.DefaultHandler;\n\npublic class BreakpointActionManager {\n\n\tpublic static final String BREAKPOINT_ACTION_ATTRIBUTE = \"BREAKPOINT_ACTIONS\"; //$NON-NLS-1$\n\tprivate static final String BREAKPOINT_ACTION_DATA = \"BreakpointActionManager.actionData\"; //$NON-NLS-1$\n\n\tprivate IExtension[] breakpointActionExtensions = null;\n\tprivate ArrayList<IBreakpointAction> breakpointActions = null;\n\n\tpublic BreakpointActionManager() {\n\t}\n\n\tpublic void addAction(IBreakpointAction action) {\n\t\tgetBreakpointActions().add(action);\n\t}\n\n\tprivate IBreakpointAction createActionFromClassName(String name, String className) {\n\n\t\tIBreakpointAction action = null;\n\t\tIExtension[] actionExtensions = CDebugCorePlugin.getDefault().getBreakpointActionManager()\n\t\t\t\t.getBreakpointActionExtensions();\n\n\t\ttry {\n\n\t\t\tfor (int i = 0; i < actionExtensions.length && action == null; i++) {\n\t\t\t\tIConfigurationElement[] elements = actionExtensions[i].getConfigurationElements();\n\t\t\t\tfor (int j = 0; j < elements.length && action == null; j++) {\n\t\t\t\t\tIConfigurationElement element = elements[j];\n\t\t\t\t\tif (element.getName().equals(CDebugCorePlugin.ACTION_TYPE_ELEMENT)) {\n\t\t\t\t\t\tif (element.getAttribute(\"class\").equals(className)) { //$NON-NLS-1$\n\t\t\t\t\t\t\taction = (IBreakpointAction) element.createExecutableExtension(\"class\"); //$NON-NLS-1$\n\t\t\t\t\t\t\taction.setName(name);\n\t\t\t\t\t\t\tCDebugCorePlugin.getDefault().getBreakpointActionManager().addAction(action);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t} catch (CoreException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\treturn action;\n\t}\n\n\tpublic void deleteAction(IBreakpointAction action) {\n\t\tgetBreakpointActions().remove(action);\n\t}\n\n\tpublic boolean breakpointHasActions(IBreakpoint breakpoint) {\n\t\tif (breakpoint != null) {\n\t\t\tIMarker marker = breakpoint.getMarker();\n\t\t\tString actionNames = marker.getAttribute(BREAKPOINT_ACTION_ATTRIBUTE, \"\"); //$NON-NLS-1$\n\t\t\treturn actionNames.length() > 0;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic void executeActions(final IBreakpoint breakpoint, final IAdaptable context) {\n\t\tif (breakpoint != null) {\n\t\t\tIMarker marker = breakpoint.getMarker();\n\t\t\tString actionNames = marker.getAttribute(BREAKPOINT_ACTION_ATTRIBUTE, \"\"); //$NON-NLS-1$\n\t\t\tif (actionNames.length() > 0) {\n\t\t\t\tfinal String[] actions = actionNames.split(\",\"); //$NON-NLS-1$\n\t\t\t\tif (actions.length > 0) {\n\t\t\t\t\tJob job = new Job(\"Execute breakpoint actions\") { //$NON-NLS-1$\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic IStatus run(final IProgressMonitor monitor) {\n\t\t\t\t\t\t\treturn doExecuteActions(breakpoint, context, actions, monitor);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tjob.schedule();\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// wait for actions to execute\n\t\t\t\t\t\tjob.join();\n\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate IStatus doExecuteActions(final IBreakpoint breakpoint, final IAdaptable context, String[] actions,\n\t\t\tIProgressMonitor monitor) {\n\t\ttry {\n\t\t\tfor (int i = 0; i < actions.length && !monitor.isCanceled(); i++) {\n\t\t\t\tString actionName = actions[i];\n\t\t\t\tIBreakpointAction action = findBreakpointAction(actionName);\n\t\t\t\tif (action != null) {\n\t\t\t\t\tmonitor.setTaskName(action.getSummary());\n\t\t\t\t\tIStatus status = action.execute(breakpoint, context, monitor);\n\t\t\t\t\tif (status.getCode() != IStatus.OK) {\n\t\t\t\t\t\t// do not log status if user canceled.\n\t\t\t\t\t\tif (status.getCode() != IStatus.CANCEL)\n\t\t\t\t\t\t\tCDebugCorePlugin.log(status);\n\t\t\t\t\t\treturn status;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmonitor.worked(1);\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\treturn new Status(IStatus.ERROR, CDebugCorePlugin.getUniqueIdentifier(), CDebugCorePlugin.INTERNAL_ERROR,\n\t\t\t\t\t\"Internal Error\", e); //$NON-NLS-1$\n\t\t}\n\t\treturn monitor.isCanceled() ? Status.CANCEL_STATUS : Status.OK_STATUS;\n\t}\n\n\tpublic IBreakpointAction findBreakpointAction(String name) {\n\t\tfor (IBreakpointAction action : getBreakpointActions()) {\n\t\t\tif (action.getName().equals(name))\n\t\t\t\treturn action;\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic IExtension[] getBreakpointActionExtensions() {\n\t\tif (breakpointActionExtensions == null) {\n\t\t\tIExtensionPoint point = Platform.getExtensionRegistry().getExtensionPoint(CDebugCorePlugin.PLUGIN_ID,\n\t\t\t\t\tCDebugCorePlugin.BREAKPOINT_ACTION_EXTENSION_POINT_ID);\n\t\t\tif (point == null)\n\t\t\t\tbreakpointActionExtensions = new IExtension[0];\n\t\t\telse {\n\t\t\t\tbreakpointActionExtensions = point.getExtensions();\n\t\t\t}\n\t\t}\n\n\t\treturn breakpointActionExtensions;\n\t}\n\n\tpublic ArrayList<IBreakpointAction> getBreakpointActions() {\n\t\tif (breakpointActions == null) {\n\t\t\tbreakpointActions = new ArrayList<>();\n\t\t\tCDebugCorePlugin.getDefault().getBreakpointActionManager().loadActionData();\n\t\t}\n\t\treturn breakpointActions;\n\t}\n\n\tprivate void loadActionData() {\n\n\t\tString actionData = CDebugCorePlugin.getDefault().getPluginPreferences().getString(BREAKPOINT_ACTION_DATA);\n\n\t\tif (actionData == null || actionData.length() == 0)\n\t\t\treturn;\n\n\t\tElement root = null;\n\t\tDocumentBuilder parser;\n\t\ttry {\n\t\t\tparser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n\t\t\tparser.setErrorHandler(new DefaultHandler());\n\t\t\troot = parser.parse(new InputSource(new StringReader(actionData))).getDocumentElement();\n\n\t\t\tNodeList nodeList = root.getChildNodes();\n\t\t\tint entryCount = nodeList.getLength();\n\n\t\t\tfor (int i = 0; i < entryCount; i++) {\n\t\t\t\tNode node = nodeList.item(i);\n\t\t\t\tshort type = node.getNodeType();\n\t\t\t\tif (type == Node.ELEMENT_NODE) {\n\t\t\t\t\tElement subElement = (Element) node;\n\t\t\t\t\tString nodeName = subElement.getNodeName();\n\t\t\t\t\tif (nodeName.equalsIgnoreCase(\"actionEntry\")) { //$NON-NLS-1$\n\t\t\t\t\t\tString name = subElement.getAttribute(\"name\"); //$NON-NLS-1$\n\t\t\t\t\t\tif (name == null)\n\t\t\t\t\t\t\tthrow new Exception();\n\t\t\t\t\t\tString value = subElement.getAttribute(\"value\"); //$NON-NLS-1$\n\t\t\t\t\t\tif (value == null)\n\t\t\t\t\t\t\tthrow new Exception();\n\t\t\t\t\t\tString className = subElement.getAttribute(\"class\"); //$NON-NLS-1$\n\t\t\t\t\t\tif (className == null)\n\t\t\t\t\t\t\tthrow new Exception();\n\n\t\t\t\t\t\tIBreakpointAction action = createActionFromClassName(name, className);\n\t\t\t\t\t\taction.initializeFromMemento(value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tpublic String makeUniqueActionName(String defaultName) {\n\t\tString result = defaultName;\n\t\tIBreakpointAction action = findBreakpointAction(defaultName);\n\t\tint actionCount = 1;\n\t\twhile (action != null) {\n\t\t\tresult = defaultName + \"(\" + actionCount + \")\"; //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\taction = findBreakpointAction(result);\n\t\t\tactionCount++;\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic void revertActionData() {\n\t\tbreakpointActions = null;\n\t}\n\n\tpublic void saveActionData() {\n\t\tString actionData = \"\"; //$NON-NLS-1$\n\n\t\tDocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();\n\t\tDocumentBuilder docBuilder = null;\n\t\ttry {\n\t\t\tdocBuilder = dfactory.newDocumentBuilder();\n\t\t\tDocument doc = docBuilder.newDocument();\n\n\t\t\tElement rootElement = doc.createElement(\"breakpointActionData\"); //$NON-NLS-1$\n\t\t\tdoc.appendChild(rootElement);\n\n\t\t\tfor (IBreakpointAction action : getBreakpointActions()) {\n\t\t\t\tElement element = doc.createElement(\"actionEntry\"); //$NON-NLS-1$\n\t\t\t\telement.setAttribute(\"name\", action.getName()); //$NON-NLS-1$\n\t\t\t\telement.setAttribute(\"class\", action.getClass().getName()); //$NON-NLS-1$\n\t\t\t\telement.setAttribute(\"value\", action.getMemento()); //$NON-NLS-1$\n\t\t\t\trootElement.appendChild(element);\n\t\t\t}\n\n\t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n\n\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n\t\t\tTransformer transformer = factory.newTransformer();\n\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\n\t\t\tDOMSource source = new DOMSource(doc);\n\t\t\tStreamResult outputTarget = new StreamResult(s);\n\t\t\ttransformer.transform(source, outputTarget);\n\n\t\t\tactionData = s.toString(\"UTF8\"); //$NON-NLS-1$\n\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tCDebugCorePlugin.getDefault().getPluginPreferences().setValue(BREAKPOINT_ACTION_DATA, actionData);\n\t\tCDebugCorePlugin.getDefault().savePluginPreferences();\n\t}\n\n}\n",
        "code_after_change": "/*******************************************************************************\n * Copyright (c) 2007, 2014 Nokia and others.\n *\n * This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n *\n * Contributors:\n *     Nokia - initial API and implementation\n *******************************************************************************/\npackage org.eclipse.cdt.debug.core.breakpointactions;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.StringReader;\nimport java.util.ArrayList;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.eclipse.cdt.debug.core.CDebugCorePlugin;\nimport org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\nimport org.eclipse.core.resources.IMarker;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.IAdaptable;\nimport org.eclipse.core.runtime.IConfigurationElement;\nimport org.eclipse.core.runtime.IExtension;\nimport org.eclipse.core.runtime.IExtensionPoint;\nimport org.eclipse.core.runtime.IProgressMonitor;\nimport org.eclipse.core.runtime.IStatus;\nimport org.eclipse.core.runtime.Platform;\nimport org.eclipse.core.runtime.Status;\nimport org.eclipse.core.runtime.jobs.Job;\nimport org.eclipse.debug.core.model.IBreakpoint;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.helpers.DefaultHandler;\n\npublic class BreakpointActionManager {\n\n\tpublic static final String BREAKPOINT_ACTION_ATTRIBUTE = \"BREAKPOINT_ACTIONS\"; //$NON-NLS-1$\n\tprivate static final String BREAKPOINT_ACTION_DATA = \"BreakpointActionManager.actionData\"; //$NON-NLS-1$\n\n\tprivate IExtension[] breakpointActionExtensions = null;\n\tprivate ArrayList<IBreakpointAction> breakpointActions = null;\n\n\tpublic BreakpointActionManager() {\n\t}\n\n\tpublic void addAction(IBreakpointAction action) {\n\t\tgetBreakpointActions().add(action);\n\t}\n\n\tprivate IBreakpointAction createActionFromClassName(String name, String className) {\n\n\t\tIBreakpointAction action = null;\n\t\tIExtension[] actionExtensions = CDebugCorePlugin.getDefault().getBreakpointActionManager()\n\t\t\t\t.getBreakpointActionExtensions();\n\n\t\ttry {\n\n\t\t\tfor (int i = 0; i < actionExtensions.length && action == null; i++) {\n\t\t\t\tIConfigurationElement[] elements = actionExtensions[i].getConfigurationElements();\n\t\t\t\tfor (int j = 0; j < elements.length && action == null; j++) {\n\t\t\t\t\tIConfigurationElement element = elements[j];\n\t\t\t\t\tif (element.getName().equals(CDebugCorePlugin.ACTION_TYPE_ELEMENT)) {\n\t\t\t\t\t\tif (element.getAttribute(\"class\").equals(className)) { //$NON-NLS-1$\n\t\t\t\t\t\t\taction = (IBreakpointAction) element.createExecutableExtension(\"class\"); //$NON-NLS-1$\n\t\t\t\t\t\t\taction.setName(name);\n\t\t\t\t\t\t\tCDebugCorePlugin.getDefault().getBreakpointActionManager().addAction(action);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t} catch (CoreException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\treturn action;\n\t}\n\n\tpublic void deleteAction(IBreakpointAction action) {\n\t\tgetBreakpointActions().remove(action);\n\t}\n\n\tpublic boolean breakpointHasActions(IBreakpoint breakpoint) {\n\t\tif (breakpoint != null) {\n\t\t\tIMarker marker = breakpoint.getMarker();\n\t\t\tString actionNames = marker.getAttribute(BREAKPOINT_ACTION_ATTRIBUTE, \"\"); //$NON-NLS-1$\n\t\t\treturn actionNames.length() > 0;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic void executeActions(final IBreakpoint breakpoint, final IAdaptable context) {\n\t\tif (breakpoint != null) {\n\t\t\tIMarker marker = breakpoint.getMarker();\n\t\t\tString actionNames = marker.getAttribute(BREAKPOINT_ACTION_ATTRIBUTE, \"\"); //$NON-NLS-1$\n\t\t\tif (actionNames.length() > 0) {\n\t\t\t\tfinal String[] actions = actionNames.split(\",\"); //$NON-NLS-1$\n\t\t\t\tif (actions.length > 0) {\n\t\t\t\t\tJob job = new Job(\"Execute breakpoint actions\") { //$NON-NLS-1$\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic IStatus run(final IProgressMonitor monitor) {\n\t\t\t\t\t\t\treturn doExecuteActions(breakpoint, context, actions, monitor);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tjob.schedule();\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// wait for actions to execute\n\t\t\t\t\t\tjob.join();\n\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate IStatus doExecuteActions(final IBreakpoint breakpoint, final IAdaptable context, String[] actions,\n\t\t\tIProgressMonitor monitor) {\n\t\ttry {\n\t\t\tfor (int i = 0; i < actions.length && !monitor.isCanceled(); i++) {\n\t\t\t\tString actionName = actions[i];\n\t\t\t\tIBreakpointAction action = findBreakpointAction(actionName);\n\t\t\t\tif (action != null) {\n\t\t\t\t\tmonitor.setTaskName(action.getSummary());\n\t\t\t\t\tIStatus status = action.execute(breakpoint, context, monitor);\n\t\t\t\t\tif (status.getCode() != IStatus.OK) {\n\t\t\t\t\t\t// do not log status if user canceled.\n\t\t\t\t\t\tif (status.getCode() != IStatus.CANCEL)\n\t\t\t\t\t\t\tCDebugCorePlugin.log(status);\n\t\t\t\t\t\treturn status;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmonitor.worked(1);\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\treturn new Status(IStatus.ERROR, CDebugCorePlugin.getUniqueIdentifier(), CDebugCorePlugin.INTERNAL_ERROR,\n\t\t\t\t\t\"Internal Error\", e); //$NON-NLS-1$\n\t\t}\n\t\treturn monitor.isCanceled() ? Status.CANCEL_STATUS : Status.OK_STATUS;\n\t}\n\n\tpublic IBreakpointAction findBreakpointAction(String name) {\n\t\tfor (IBreakpointAction action : getBreakpointActions()) {\n\t\t\tif (action.getName().equals(name))\n\t\t\t\treturn action;\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic IExtension[] getBreakpointActionExtensions() {\n\t\tif (breakpointActionExtensions == null) {\n\t\t\tIExtensionPoint point = Platform.getExtensionRegistry().getExtensionPoint(CDebugCorePlugin.PLUGIN_ID,\n\t\t\t\t\tCDebugCorePlugin.BREAKPOINT_ACTION_EXTENSION_POINT_ID);\n\t\t\tif (point == null)\n\t\t\t\tbreakpointActionExtensions = new IExtension[0];\n\t\t\telse {\n\t\t\t\tbreakpointActionExtensions = point.getExtensions();\n\t\t\t}\n\t\t}\n\n\t\treturn breakpointActionExtensions;\n\t}\n\n\tpublic ArrayList<IBreakpointAction> getBreakpointActions() {\n\t\tif (breakpointActions == null) {\n\t\t\tbreakpointActions = new ArrayList<>();\n\t\t\tCDebugCorePlugin.getDefault().getBreakpointActionManager().loadActionData();\n\t\t}\n\t\treturn breakpointActions;\n\t}\n\n\tprivate void loadActionData() {\n\n\t\tString actionData = CDebugCorePlugin.getDefault().getPluginPreferences().getString(BREAKPOINT_ACTION_DATA);\n\n\t\tif (actionData == null || actionData.length() == 0)\n\t\t\treturn;\n\n\t\tElement root = null;\n\t\tDocumentBuilder parser;\n\t\ttry {\n\t\t\tparser = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n\t\t\tparser.setErrorHandler(new DefaultHandler());\n\t\t\troot = parser.parse(new InputSource(new StringReader(actionData))).getDocumentElement();\n\n\t\t\tNodeList nodeList = root.getChildNodes();\n\t\t\tint entryCount = nodeList.getLength();\n\n\t\t\tfor (int i = 0; i < entryCount; i++) {\n\t\t\t\tNode node = nodeList.item(i);\n\t\t\t\tshort type = node.getNodeType();\n\t\t\t\tif (type == Node.ELEMENT_NODE) {\n\t\t\t\t\tElement subElement = (Element) node;\n\t\t\t\t\tString nodeName = subElement.getNodeName();\n\t\t\t\t\tif (nodeName.equalsIgnoreCase(\"actionEntry\")) { //$NON-NLS-1$\n\t\t\t\t\t\tString name = subElement.getAttribute(\"name\"); //$NON-NLS-1$\n\t\t\t\t\t\tif (name == null)\n\t\t\t\t\t\t\tthrow new Exception();\n\t\t\t\t\t\tString value = subElement.getAttribute(\"value\"); //$NON-NLS-1$\n\t\t\t\t\t\tif (value == null)\n\t\t\t\t\t\t\tthrow new Exception();\n\t\t\t\t\t\tString className = subElement.getAttribute(\"class\"); //$NON-NLS-1$\n\t\t\t\t\t\tif (className == null)\n\t\t\t\t\t\t\tthrow new Exception();\n\n\t\t\t\t\t\tIBreakpointAction action = createActionFromClassName(name, className);\n\t\t\t\t\t\taction.initializeFromMemento(value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tpublic String makeUniqueActionName(String defaultName) {\n\t\tString result = defaultName;\n\t\tIBreakpointAction action = findBreakpointAction(defaultName);\n\t\tint actionCount = 1;\n\t\twhile (action != null) {\n\t\t\tresult = defaultName + \"(\" + actionCount + \")\"; //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\taction = findBreakpointAction(result);\n\t\t\tactionCount++;\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic void revertActionData() {\n\t\tbreakpointActions = null;\n\t}\n\n\tpublic void saveActionData() {\n\t\tString actionData = \"\"; //$NON-NLS-1$\n\n\t\ttry {\n\t\t\tDocumentBuilder docBuilder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n\t\t\tDocument doc = docBuilder.newDocument();\n\n\t\t\tElement rootElement = doc.createElement(\"breakpointActionData\"); //$NON-NLS-1$\n\t\t\tdoc.appendChild(rootElement);\n\n\t\t\tfor (IBreakpointAction action : getBreakpointActions()) {\n\t\t\t\tElement element = doc.createElement(\"actionEntry\"); //$NON-NLS-1$\n\t\t\t\telement.setAttribute(\"name\", action.getName()); //$NON-NLS-1$\n\t\t\t\telement.setAttribute(\"class\", action.getClass().getName()); //$NON-NLS-1$\n\t\t\t\telement.setAttribute(\"value\", action.getMemento()); //$NON-NLS-1$\n\t\t\t\trootElement.appendChild(element);\n\t\t\t}\n\n\t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n\n\t\t\tTransformerFactory factory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n\t\t\tTransformer transformer = factory.newTransformer();\n\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\n\t\t\tDOMSource source = new DOMSource(doc);\n\t\t\tStreamResult outputTarget = new StreamResult(s);\n\t\t\ttransformer.transform(source, outputTarget);\n\n\t\t\tactionData = s.toString(\"UTF8\"); //$NON-NLS-1$\n\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tCDebugCorePlugin.getDefault().getPluginPreferences().setValue(BREAKPOINT_ACTION_DATA, actionData);\n\t\tCDebugCorePlugin.getDefault().savePluginPreferences();\n\t}\n\n}\n",
        "patch": "@@ -18,14 +18,14 @@\n import java.util.ArrayList;\n \n import javax.xml.parsers.DocumentBuilder;\n-import javax.xml.parsers.DocumentBuilderFactory;\n import javax.xml.transform.OutputKeys;\n import javax.xml.transform.Transformer;\n import javax.xml.transform.TransformerFactory;\n import javax.xml.transform.dom.DOMSource;\n import javax.xml.transform.stream.StreamResult;\n \n import org.eclipse.cdt.debug.core.CDebugCorePlugin;\n+import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n import org.eclipse.core.resources.IMarker;\n import org.eclipse.core.runtime.CoreException;\n import org.eclipse.core.runtime.IAdaptable;\n@@ -192,7 +192,7 @@ private void loadActionData() {\n \t\tElement root = null;\n \t\tDocumentBuilder parser;\n \t\ttry {\n-\t\t\tparser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n+\t\t\tparser = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tparser.setErrorHandler(new DefaultHandler());\n \t\t\troot = parser.parse(new InputSource(new StringReader(actionData))).getDocumentElement();\n \n@@ -246,10 +246,8 @@ public void revertActionData() {\n \tpublic void saveActionData() {\n \t\tString actionData = \"\"; //$NON-NLS-1$\n \n-\t\tDocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();\n-\t\tDocumentBuilder docBuilder = null;\n \t\ttry {\n-\t\t\tdocBuilder = dfactory.newDocumentBuilder();\n+\t\t\tDocumentBuilder docBuilder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tDocument doc = docBuilder.newDocument();\n \n \t\t\tElement rootElement = doc.createElement(\"breakpointActionData\"); //$NON-NLS-1$\n@@ -265,7 +263,7 @@ public void saveActionData() {\n \n \t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n \n-\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n+\t\t\tTransformerFactory factory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n \t\t\tTransformer transformer = factory.newTransformer();\n \t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n \t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$",
        "function_modified_lines": {
            "added": [
                "import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n"
            ],
            "deleted": [
                "import javax.xml.parsers.DocumentBuilderFactory;\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-611"
        ],
        "cve_description": "In Eclipse IDE versions < 2023-09 (4.29) some files with xml content are parsed vulnerable against all sorts of XXE attacks. The user just needs to open any evil project or update an open project with a vulnerable file (for example for review a foreign repository or patch).\n",
        "id": 12874
    },
    {
        "cve_id": "CVE-2023-4218",
        "code_before_change": "/*******************************************************************************\n * Copyright (c) 2009, 2013 Andrew Gvozdev (Quoin Inc.).\n *\n * This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n *\n * Contributors:\n *     Andrew Gvozdev (Quoin Inc.)\n *******************************************************************************/\npackage org.eclipse.cdt.internal.core;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URI;\nimport java.util.Arrays;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.eclipse.cdt.core.CCorePlugin;\nimport org.eclipse.cdt.core.resources.ResourcesUtil;\nimport org.eclipse.cdt.internal.core.model.Util;\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.runtime.CoreException;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\n/**\n * XML utilities.\n *\n */\npublic class XmlUtil {\n\tprivate static final String ENCODING_UTF_8 = \"UTF-8\"; //$NON-NLS-1$\n\tprivate static final String EOL_XML = \"\\n\"; //$NON-NLS-1$\n\tprivate static final String DEFAULT_INDENT = \"\\t\"; //$NON-NLS-1$\n\tprivate static String LINE_SEPARATOR = System.getProperty(\"line.separator\"); //$NON-NLS-1$\n\n\t/**\n\t * Convenience method to create new XML DOM Document.\n\t *\n\t * @return a new instance of a DOM {@link Document}.\n\t * @throws ParserConfigurationException in case of a problem retrieving {@link DocumentBuilder}.\n\t */\n\tpublic static Document newDocument() throws ParserConfigurationException {\n\t\tDocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n\t\treturn builder.newDocument();\n\t}\n",
        "code_after_change": "/*******************************************************************************\n * Copyright (c) 2009, 2013 Andrew Gvozdev (Quoin Inc.).\n *\n * This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n *\n * Contributors:\n *     Andrew Gvozdev (Quoin Inc.)\n *******************************************************************************/\npackage org.eclipse.cdt.internal.core;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URI;\nimport java.util.Arrays;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.eclipse.cdt.core.CCorePlugin;\nimport org.eclipse.cdt.core.resources.ResourcesUtil;\nimport org.eclipse.cdt.internal.core.model.Util;\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.runtime.CoreException;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\n/**\n * XML utilities.\n *\n */\npublic class XmlUtil {\n\tprivate static final String ENCODING_UTF_8 = \"UTF-8\"; //$NON-NLS-1$\n\tprivate static final String EOL_XML = \"\\n\"; //$NON-NLS-1$\n\tprivate static final String DEFAULT_INDENT = \"\\t\"; //$NON-NLS-1$\n\tprivate static String LINE_SEPARATOR = System.getProperty(\"line.separator\"); //$NON-NLS-1$\n\n\t/**\n\t * Convenience method to create new XML DOM Document.\n\t *\n\t * @return a new instance of a DOM {@link Document}.\n\t * @throws ParserConfigurationException in case of a problem retrieving {@link DocumentBuilder}.\n\t */\n\tpublic static Document newDocument() throws ParserConfigurationException {\n\t\tDocumentBuilder builder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n\t\treturn builder.newDocument();\n\t}\n\n\t/**\n\t * Convenience method to retrieve value of a node.",
        "patch": "@@ -25,12 +25,10 @@\n import java.util.Arrays;\n \n import javax.xml.parsers.DocumentBuilder;\n-import javax.xml.parsers.DocumentBuilderFactory;\n import javax.xml.parsers.ParserConfigurationException;\n import javax.xml.transform.OutputKeys;\n import javax.xml.transform.Transformer;\n import javax.xml.transform.TransformerException;\n-import javax.xml.transform.TransformerFactory;\n import javax.xml.transform.dom.DOMSource;\n import javax.xml.transform.stream.StreamResult;\n \n@@ -63,7 +61,7 @@ public class XmlUtil {\n \t * @throws ParserConfigurationException in case of a problem retrieving {@link DocumentBuilder}.\n \t */\n \tpublic static Document newDocument() throws ParserConfigurationException {\n-\t\tDocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n+\t\tDocumentBuilder builder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\treturn builder.newDocument();\n \t}\n \n@@ -227,7 +225,7 @@ private static void prettyFormat(Node node, String indentLevel, String indent) {\n \t */\n \tprivate static Document loadXml(InputStream xmlStream) throws CoreException {\n \t\ttry {\n-\t\t\tDocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n+\t\t\tDocumentBuilder builder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\treturn builder.parse(xmlStream);\n \t\t} catch (Exception e) {\n \t\t\tthrow new CoreException(CCorePlugin.createStatus(Messages.XmlUtil_InternalErrorLoading, e));\n@@ -370,7 +368,8 @@ private static FileOutputStream getFileOutputStreamWorkaround(java.io.File store\n \tprivate static byte[] toByteArray(Document doc) throws CoreException {\n \t\ttry {\n \t\t\tByteArrayOutputStream stream = new ByteArrayOutputStream();\n-\t\t\tTransformer transformer = TransformerFactory.newInstance().newTransformer();\n+\t\t\tTransformer transformer = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE()\n+\t\t\t\t\t.newTransformer();\n \t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n \t\t\ttransformer.setOutputProperty(OutputKeys.ENCODING, ENCODING_UTF_8);\n \t\t\t// Indentation is done with XmlUtil.prettyFormat(doc).",
        "function_modified_lines": {
            "added": [],
            "deleted": [
                "import javax.xml.parsers.DocumentBuilderFactory;\n",
                "import javax.xml.transform.TransformerFactory;\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-611"
        ],
        "cve_description": "In Eclipse IDE versions < 2023-09 (4.29) some files with xml content are parsed vulnerable against all sorts of XXE attacks. The user just needs to open any evil project or update an open project with a vulnerable file (for example for review a foreign repository or patch).\n",
        "id": 12870
    },
    {
        "cve_id": "CVE-2023-4218",
        "code_before_change": "{\n\t\tDocument d;\n\t\ttry {\n\t\t\td = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n\t\t} catch (ParserConfigurationException e) {\n\t\t\tTemplateEngineUtil.log(e);\n\t\t\treturn xmlFile;\n\t\t}\n\t\tNode rootElement = d.appendChild(d.createElement(\"SharedRoot\")); //$NON-NLS-1$\n\t\tElement element = (Element) rootElement.appendChild(d.createElement(\"SharedProperty\")); //$NON-NLS-1$\n\t\telement.setAttribute(TemplateEngineHelper.ID, \"\"); //$NON-NLS-1$\n\t\telement.setAttribute(TemplateEngineHelper.VALUE, \"\"); //$NON-NLS-1$\n\n\t\tDOMSource domSource = new DOMSource(d);\n\t\tTransformerFactory transFactory = TransformerFactory.newInstance();\n\n\t\ttry {\n\t\t\tFileOutputStream fos = null;\n\t\t\ttry {\n\t\t\t\tfos = new FileOutputStream(xmlFile);\n\t\t\t\tResult fileResult = new StreamResult(fos);\n\t\t\t\ttransFactory.newTransformer().transform(domSource, fileResult);\n\t\t\t} finally {\n\t\t\t\tif (fos != null) {\n\t\t\t\t\tfos.close();\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException ioe) {\n\t\t\tTemplateEngineUtil.log(ioe);\n\t\t} catch (TransformerConfigurationException tce) {\n\t\t\tTemplateEngineUtil.log(tce);\n\t\t} catch (TransformerException te) {\n\t\t\tTemplateEngineUtil.log(te);\n\t\t}\n\t\treturn xmlFile;\n\t}",
        "code_after_change": "{\n\t\tDocument d;\n\t\ttry {\n\t\t\td = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE().newDocument();\n\t\t} catch (ParserConfigurationException e) {\n\t\t\tTemplateEngineUtil.log(e);\n\t\t\treturn xmlFile;\n\t\t}\n\t\tNode rootElement = d.appendChild(d.createElement(\"SharedRoot\")); //$NON-NLS-1$\n\t\tElement element = (Element) rootElement.appendChild(d.createElement(\"SharedProperty\")); //$NON-NLS-1$\n\t\telement.setAttribute(TemplateEngineHelper.ID, \"\"); //$NON-NLS-1$\n\t\telement.setAttribute(TemplateEngineHelper.VALUE, \"\"); //$NON-NLS-1$\n\n\t\tDOMSource domSource = new DOMSource(d);\n\t\tTransformerFactory transFactory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n\n\t\ttry {\n\t\t\tFileOutputStream fos = null;\n\t\t\ttry {\n\t\t\t\tfos = new FileOutputStream(xmlFile);\n\t\t\t\tResult fileResult = new StreamResult(fos);\n\t\t\t\ttransFactory.newTransformer().transform(domSource, fileResult);\n\t\t\t} finally {\n\t\t\t\tif (fos != null) {\n\t\t\t\t\tfos.close();\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException ioe) {\n\t\t\tTemplateEngineUtil.log(ioe);\n\t\t} catch (TransformerConfigurationException tce) {\n\t\t\tTemplateEngineUtil.log(tce);\n\t\t} catch (TransformerException te) {\n\t\t\tTemplateEngineUtil.log(te);\n\t\t}\n\t\treturn xmlFile;\n\t}",
        "patch": "@@ -20,7 +20,6 @@\n import java.util.List;\n import java.util.Map;\n \n-import javax.xml.parsers.DocumentBuilderFactory;\n import javax.xml.parsers.ParserConfigurationException;\n import javax.xml.transform.Result;\n import javax.xml.transform.TransformerConfigurationException;\n@@ -29,6 +28,7 @@\n import javax.xml.transform.dom.DOMSource;\n import javax.xml.transform.stream.StreamResult;\n \n+import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n import org.w3c.dom.Document;\n import org.w3c.dom.Element;\n import org.w3c.dom.Node;\n@@ -126,7 +126,7 @@ private void initSharedDefaults() {\n \t\t\tif (length == 0) {\n \t\t\t\tparsedXML = createDefaultXMLFormat(parsedXML);\n \t\t\t}\n-\t\t\tdocument = DocumentBuilderFactory.newInstance().newDocumentBuilder()\n+\t\t\tdocument = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE()\n \t\t\t\t\t.parse(parsedXML.toURI().toURL().openStream());\n \t\t} catch (Exception exp) {\n \t\t\tTemplateEngineUtil.log(exp);\n@@ -198,7 +198,7 @@ public void addToBackEndStorage(String name, String value) {\n \t */\n \tpublic void updateToBackEndStorage(String updateName, String updateValue) {\n \t\ttry {\n-\t\t\tdocument = DocumentBuilderFactory.newInstance().newDocumentBuilder()\n+\t\t\tdocument = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE()\n \t\t\t\t\t.parse(parsedXML.toURI().toURL().openStream());\n \t\t} catch (Exception exp) {\n \t\t\tTemplateEngineUtil.log(exp);\n@@ -227,7 +227,7 @@ public void updateToBackEndStorage(String updateName, String updateValue) {\n \t */\n \tpublic void deleteBackEndStorage(String[] deleteName) {\n \t\ttry {\n-\t\t\tdocument = DocumentBuilderFactory.newInstance().newDocumentBuilder()\n+\t\t\tdocument = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE()\n \t\t\t\t\t.parse(parsedXML.toURI().toURL().openStream());\n \t\t} catch (Exception exp) {\n \t\t\tTemplateEngineUtil.log(exp);\n@@ -261,7 +261,7 @@ public void deleteBackEndStorage(String[] deleteName) {\n \tprivate File createDefaultXMLFormat(File xmlFile) {\n \t\tDocument d;\n \t\ttry {\n-\t\t\td = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n+\t\t\td = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE().newDocument();\n \t\t} catch (ParserConfigurationException e) {\n \t\t\tTemplateEngineUtil.log(e);\n \t\t\treturn xmlFile;\n@@ -272,7 +272,7 @@ private File createDefaultXMLFormat(File xmlFile) {\n \t\telement.setAttribute(TemplateEngineHelper.VALUE, \"\"); //$NON-NLS-1$\n \n \t\tDOMSource domSource = new DOMSource(d);\n-\t\tTransformerFactory transFactory = TransformerFactory.newInstance();\n+\t\tTransformerFactory transFactory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n \n \t\ttry {\n \t\t\tFileOutputStream fos = null;\n@@ -303,7 +303,7 @@ private File createDefaultXMLFormat(File xmlFile) {\n \tprivate void generateSharedXML(File xmlFile) {\n \t\tDocument d;\n \t\ttry {\n-\t\t\td = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n+\t\t\td = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE().newDocument();\n \t\t} catch (ParserConfigurationException e) {\n \t\t\tTemplateEngineUtil.log(e);\n \t\t\treturn;\n@@ -317,7 +317,7 @@ private void generateSharedXML(File xmlFile) {\n \t\t}\n \n \t\tDOMSource domSource = new DOMSource(d);\n-\t\tTransformerFactory transFactory = TransformerFactory.newInstance();\n+\t\tTransformerFactory transFactory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n \t\tResult fileResult = new StreamResult(xmlFile);\n \t\ttry {\n \t\t\ttransFactory.newTransformer().transform(domSource, fileResult);",
        "function_modified_lines": {
            "added": [
                "\t\t\td = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE().newDocument();\n",
                "\t\tTransformerFactory transFactory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n"
            ],
            "deleted": [
                "\t\t\td = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n",
                "\t\tTransformerFactory transFactory = TransformerFactory.newInstance();\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-611"
        ],
        "cve_description": "In Eclipse IDE versions < 2023-09 (4.29) some files with xml content are parsed vulnerable against all sorts of XXE attacks. The user just needs to open any evil project or update an open project with a vulnerable file (for example for review a foreign repository or patch).\n",
        "id": 12868
    },
    {
        "cve_id": "CVE-2023-4218",
        "code_before_change": "/*******************************************************************************\n * Copyright (c) 2010, 2016 Ericsson and others.\n *\n * This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n *\n * Contributors:\n *     Ericsson - initial API and implementation\n *******************************************************************************/\npackage org.eclipse.cdt.dsf.gdb.internal.tracepointactions;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.StringReader;\nimport java.util.ArrayList;\nimport java.util.Iterator;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.eclipse.cdt.dsf.gdb.internal.GdbPlugin;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.helpers.DefaultHandler;\n\n/**\n * @since 3.0\n */\npublic class TracepointActionManager {\n\n\tprivate static final String TRACEPOINT_ACTION_DATA = \"TracepointActionManager.actionData\"; //$NON-NLS-1$\n\tprivate static final TracepointActionManager fTracepointActionManager = new TracepointActionManager();\n\n\t// We need a delimiter that the user won't type directly.\n\t// Bug 346215\n\tpublic static final String TRACEPOINT_ACTION_DELIMITER = \"%_#\"; //$NON-NLS-1$\n\n\tprivate ArrayList<ITracepointAction> tracepointActions = null;\n\n\tprivate TracepointActionManager() {\n\t}\n\n\tpublic static TracepointActionManager getInstance() {\n\t\treturn fTracepointActionManager;\n\t}\n\n\tpublic void addAction(ITracepointAction action) {\n\t\tgetActions().add(action);\n\t}\n\n\tpublic void deleteAction(ITracepointAction action) {\n\t\tgetActions().remove(action);\n\t}\n\n\tpublic ITracepointAction findAction(String name) {\n\t\tfor (ITracepointAction action : getActions()) {\n\t\t\tif (action.getName().equals(name)) {\n\t\t\t\treturn action;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic ArrayList<ITracepointAction> getActions() {\n\t\tif (tracepointActions == null) {\n\t\t\ttracepointActions = new ArrayList<>();\n\t\t\tloadActionData();\n\t\t}\n\t\treturn tracepointActions;\n\t}\n\n\tprivate void loadActionData() {\n\n\t\tString actionData = GdbPlugin.getDefault().getPluginPreferences().getString(TRACEPOINT_ACTION_DATA);\n\n\t\tif (actionData == null || actionData.length() == 0)\n\t\t\treturn;\n\n\t\tElement root = null;\n\t\tDocumentBuilder parser;\n\t\ttry {\n\t\t\tparser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n\t\t\tparser.setErrorHandler(new DefaultHandler());\n\t\t\troot = parser.parse(new InputSource(new StringReader(actionData))).getDocumentElement();\n\n\t\t\tNodeList nodeList = root.getChildNodes();\n\t\t\tint entryCount = nodeList.getLength();\n\n\t\t\tfor (int i = 0; i < entryCount; i++) {\n\t\t\t\tNode node = nodeList.item(i);\n\t\t\t\tshort type = node.getNodeType();\n\t\t\t\tif (type == Node.ELEMENT_NODE) {\n\t\t\t\t\tElement subElement = (Element) node;\n\t\t\t\t\tString nodeName = subElement.getNodeName();\n\t\t\t\t\tif (nodeName.equalsIgnoreCase(\"actionEntry\")) { //$NON-NLS-1$\n\t\t\t\t\t\tString name = subElement.getAttribute(\"name\"); //$NON-NLS-1$\n\t\t\t\t\t\tif (name == null)\n\t\t\t\t\t\t\tthrow new Exception();\n\t\t\t\t\t\tString value = subElement.getAttribute(\"value\"); //$NON-NLS-1$\n\t\t\t\t\t\tif (value == null)\n\t\t\t\t\t\t\tthrow new Exception();\n\t\t\t\t\t\tString className = subElement.getAttribute(\"class\"); //$NON-NLS-1$\n\t\t\t\t\t\tif (className == null)\n\t\t\t\t\t\t\tthrow new Exception();\n\n\t\t\t\t\t\tITracepointAction action = (ITracepointAction) Class.forName(className).newInstance();\n\t\t\t\t\t\taction.setName(name);\n\t\t\t\t\t\taction.initializeFromMemento(value);\n\t\t\t\t\t\taddAction(action);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tpublic String makeUniqueActionName(String defaultName) {\n\t\tString result = defaultName;\n\t\tITracepointAction action = findAction(defaultName);\n\t\tint actionCount = 1;\n\t\twhile (action != null) {\n\t\t\tresult = defaultName + \"(\" + actionCount + \")\"; //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\taction = findAction(result);\n\t\t\tactionCount++;\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic void revertActionData() {\n\t\ttracepointActions = null;\n\t}\n\n\tpublic void saveActionData() {\n\t\tString actionData = \"\"; //$NON-NLS-1$\n\n\t\tDocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();\n\t\tDocumentBuilder docBuilder = null;\n\t\ttry {\n\t\t\tdocBuilder = dfactory.newDocumentBuilder();\n\t\t\tDocument doc = docBuilder.newDocument();\n\n\t\t\tElement rootElement = doc.createElement(\"tracepointActionData\"); //$NON-NLS-1$\n\t\t\tdoc.appendChild(rootElement);\n\n\t\t\tfor (Iterator<ITracepointAction> iter = getActions().iterator(); iter.hasNext();) {\n\t\t\t\tITracepointAction action = iter.next();\n\n\t\t\t\tElement element = doc.createElement(\"actionEntry\"); //$NON-NLS-1$\n\t\t\t\telement.setAttribute(\"name\", action.getName()); //$NON-NLS-1$\n\t\t\t\telement.setAttribute(\"class\", action.getClass().getName()); //$NON-NLS-1$\n\t\t\t\telement.setAttribute(\"value\", action.getMemento()); //$NON-NLS-1$\n\t\t\t\trootElement.appendChild(element);\n\n\t\t\t}\n\n\t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n\n\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n\t\t\tTransformer transformer = factory.newTransformer();\n\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\n\t\t\tDOMSource source = new DOMSource(doc);\n\t\t\tStreamResult outputTarget = new StreamResult(s);\n\t\t\ttransformer.transform(source, outputTarget);\n\n\t\t\tactionData = s.toString(\"UTF8\"); //$NON-NLS-1$\n\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tGdbPlugin.getDefault().getPluginPreferences().setValue(TRACEPOINT_ACTION_DATA, actionData);\n\t\tGdbPlugin.getDefault().savePluginPreferences();\n\t}\n\n}\n",
        "code_after_change": "/*******************************************************************************\n * Copyright (c) 2010, 2016 Ericsson and others.\n *\n * This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n *\n * Contributors:\n *     Ericsson - initial API and implementation\n *******************************************************************************/\npackage org.eclipse.cdt.dsf.gdb.internal.tracepointactions;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.StringReader;\nimport java.util.ArrayList;\nimport java.util.Iterator;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.eclipse.cdt.dsf.gdb.internal.GdbPlugin;\nimport org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.helpers.DefaultHandler;\n\n/**\n * @since 3.0\n */\npublic class TracepointActionManager {\n\n\tprivate static final String TRACEPOINT_ACTION_DATA = \"TracepointActionManager.actionData\"; //$NON-NLS-1$\n\tprivate static final TracepointActionManager fTracepointActionManager = new TracepointActionManager();\n\n\t// We need a delimiter that the user won't type directly.\n\t// Bug 346215\n\tpublic static final String TRACEPOINT_ACTION_DELIMITER = \"%_#\"; //$NON-NLS-1$\n\n\tprivate ArrayList<ITracepointAction> tracepointActions = null;\n\n\tprivate TracepointActionManager() {\n\t}\n\n\tpublic static TracepointActionManager getInstance() {\n\t\treturn fTracepointActionManager;\n\t}\n\n\tpublic void addAction(ITracepointAction action) {\n\t\tgetActions().add(action);\n\t}\n\n\tpublic void deleteAction(ITracepointAction action) {\n\t\tgetActions().remove(action);\n\t}\n\n\tpublic ITracepointAction findAction(String name) {\n\t\tfor (ITracepointAction action : getActions()) {\n\t\t\tif (action.getName().equals(name)) {\n\t\t\t\treturn action;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic ArrayList<ITracepointAction> getActions() {\n\t\tif (tracepointActions == null) {\n\t\t\ttracepointActions = new ArrayList<>();\n\t\t\tloadActionData();\n\t\t}\n\t\treturn tracepointActions;\n\t}\n\n\tprivate void loadActionData() {\n\n\t\tString actionData = GdbPlugin.getDefault().getPluginPreferences().getString(TRACEPOINT_ACTION_DATA);\n\n\t\tif (actionData == null || actionData.length() == 0)\n\t\t\treturn;\n\n\t\tElement root = null;\n\t\tDocumentBuilder parser;\n\t\ttry {\n\t\t\tparser = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n\t\t\tparser.setErrorHandler(new DefaultHandler());\n\t\t\troot = parser.parse(new InputSource(new StringReader(actionData))).getDocumentElement();\n\n\t\t\tNodeList nodeList = root.getChildNodes();\n\t\t\tint entryCount = nodeList.getLength();\n\n\t\t\tfor (int i = 0; i < entryCount; i++) {\n\t\t\t\tNode node = nodeList.item(i);\n\t\t\t\tshort type = node.getNodeType();\n\t\t\t\tif (type == Node.ELEMENT_NODE) {\n\t\t\t\t\tElement subElement = (Element) node;\n\t\t\t\t\tString nodeName = subElement.getNodeName();\n\t\t\t\t\tif (nodeName.equalsIgnoreCase(\"actionEntry\")) { //$NON-NLS-1$\n\t\t\t\t\t\tString name = subElement.getAttribute(\"name\"); //$NON-NLS-1$\n\t\t\t\t\t\tif (name == null)\n\t\t\t\t\t\t\tthrow new Exception();\n\t\t\t\t\t\tString value = subElement.getAttribute(\"value\"); //$NON-NLS-1$\n\t\t\t\t\t\tif (value == null)\n\t\t\t\t\t\t\tthrow new Exception();\n\t\t\t\t\t\tString className = subElement.getAttribute(\"class\"); //$NON-NLS-1$\n\t\t\t\t\t\tif (className == null)\n\t\t\t\t\t\t\tthrow new Exception();\n\n\t\t\t\t\t\tITracepointAction action = (ITracepointAction) Class.forName(className).newInstance();\n\t\t\t\t\t\taction.setName(name);\n\t\t\t\t\t\taction.initializeFromMemento(value);\n\t\t\t\t\t\taddAction(action);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tpublic String makeUniqueActionName(String defaultName) {\n\t\tString result = defaultName;\n\t\tITracepointAction action = findAction(defaultName);\n\t\tint actionCount = 1;\n\t\twhile (action != null) {\n\t\t\tresult = defaultName + \"(\" + actionCount + \")\"; //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\taction = findAction(result);\n\t\t\tactionCount++;\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic void revertActionData() {\n\t\ttracepointActions = null;\n\t}\n\n\tpublic void saveActionData() {\n\t\tString actionData = \"\"; //$NON-NLS-1$\n\n\t\ttry {\n\t\t\tDocumentBuilder docBuilder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n\t\t\tDocument doc = docBuilder.newDocument();\n\n\t\t\tElement rootElement = doc.createElement(\"tracepointActionData\"); //$NON-NLS-1$\n\t\t\tdoc.appendChild(rootElement);\n\n\t\t\tfor (Iterator<ITracepointAction> iter = getActions().iterator(); iter.hasNext();) {\n\t\t\t\tITracepointAction action = iter.next();\n\n\t\t\t\tElement element = doc.createElement(\"actionEntry\"); //$NON-NLS-1$\n\t\t\t\telement.setAttribute(\"name\", action.getName()); //$NON-NLS-1$\n\t\t\t\telement.setAttribute(\"class\", action.getClass().getName()); //$NON-NLS-1$\n\t\t\t\telement.setAttribute(\"value\", action.getMemento()); //$NON-NLS-1$\n\t\t\t\trootElement.appendChild(element);\n\n\t\t\t}\n\n\t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n\n\t\t\tTransformerFactory factory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n\t\t\tTransformer transformer = factory.newTransformer();\n\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\n\t\t\tDOMSource source = new DOMSource(doc);\n\t\t\tStreamResult outputTarget = new StreamResult(s);\n\t\t\ttransformer.transform(source, outputTarget);\n\n\t\t\tactionData = s.toString(\"UTF8\"); //$NON-NLS-1$\n\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tGdbPlugin.getDefault().getPluginPreferences().setValue(TRACEPOINT_ACTION_DATA, actionData);\n\t\tGdbPlugin.getDefault().savePluginPreferences();\n\t}\n\n}\n",
        "patch": "@@ -19,14 +19,14 @@\n import java.util.Iterator;\n \n import javax.xml.parsers.DocumentBuilder;\n-import javax.xml.parsers.DocumentBuilderFactory;\n import javax.xml.transform.OutputKeys;\n import javax.xml.transform.Transformer;\n import javax.xml.transform.TransformerFactory;\n import javax.xml.transform.dom.DOMSource;\n import javax.xml.transform.stream.StreamResult;\n \n import org.eclipse.cdt.dsf.gdb.internal.GdbPlugin;\n+import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n import org.w3c.dom.Document;\n import org.w3c.dom.Element;\n import org.w3c.dom.Node;\n@@ -90,7 +90,7 @@ private void loadActionData() {\n \t\tElement root = null;\n \t\tDocumentBuilder parser;\n \t\ttry {\n-\t\t\tparser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n+\t\t\tparser = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tparser.setErrorHandler(new DefaultHandler());\n \t\t\troot = parser.parse(new InputSource(new StringReader(actionData))).getDocumentElement();\n \n@@ -146,10 +146,8 @@ public void revertActionData() {\n \tpublic void saveActionData() {\n \t\tString actionData = \"\"; //$NON-NLS-1$\n \n-\t\tDocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();\n-\t\tDocumentBuilder docBuilder = null;\n \t\ttry {\n-\t\t\tdocBuilder = dfactory.newDocumentBuilder();\n+\t\t\tDocumentBuilder docBuilder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tDocument doc = docBuilder.newDocument();\n \n \t\t\tElement rootElement = doc.createElement(\"tracepointActionData\"); //$NON-NLS-1$\n@@ -168,7 +166,7 @@ public void saveActionData() {\n \n \t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n \n-\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n+\t\t\tTransformerFactory factory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n \t\t\tTransformer transformer = factory.newTransformer();\n \t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n \t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$",
        "function_modified_lines": {
            "added": [
                "import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n"
            ],
            "deleted": [
                "import javax.xml.parsers.DocumentBuilderFactory;\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-611"
        ],
        "cve_description": "In Eclipse IDE versions < 2023-09 (4.29) some files with xml content are parsed vulnerable against all sorts of XXE attacks. The user just needs to open any evil project or update an open project with a vulnerable file (for example for review a foreign repository or patch).\n",
        "id": 12896
    },
    {
        "cve_id": "CVE-2023-4218",
        "code_before_change": " *     IBM Corporation\n *     James Blackburn (Broadcom Corp.)\n *     Alex Blewitt Bug 132511 - nature order not preserved\n *     Christian Walther (Indel AG) - [436060] Race condition in updateProjectDescriptions()\n *     Alexander Fedorov (ArSysOp) - Bug 561992\n *******************************************************************************/\npackage org.eclipse.cdt.internal.core.settings.model;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URI;\nimport java.text.MessageFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.concurrent.CopyOnWriteArraySet;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.FactoryConfigurationError;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.eclipse.cdt.core.CCorePlugin;\nimport org.eclipse.cdt.core.language.settings.providers.ILanguageSettingsProvider;\nimport org.eclipse.cdt.core.language.settings.providers.ILanguageSettingsProvidersKeeper;\nimport org.eclipse.cdt.core.model.CModelException;\nimport org.eclipse.cdt.core.model.ICElement;\nimport org.eclipse.cdt.core.model.ICElementDelta;\nimport org.eclipse.cdt.core.model.ICProject;\nimport org.eclipse.cdt.core.settings.model.CExternalSetting;\nimport org.eclipse.cdt.core.settings.model.CProjectDescriptionEvent;\nimport org.eclipse.cdt.core.settings.model.ICBuildSetting;\nimport org.eclipse.cdt.core.settings.model.ICConfigurationDescription;\nimport org.eclipse.cdt.core.settings.model.ICDescriptionDelta;\nimport org.eclipse.cdt.core.settings.model.ICFileDescription;\nimport org.eclipse.cdt.core.settings.model.ICFolderDescription;\nimport org.eclipse.cdt.core.settings.model.ICLanguageSetting;\nimport org.eclipse.cdt.core.settings.model.ICLanguageSettingEntry;\nimport org.eclipse.cdt.core.settings.model.ICProjectDescription;\nimport org.eclipse.cdt.core.settings.model.ICProjectDescriptionListener;\nimport org.eclipse.cdt.core.settings.model.ICProjectDescriptionManager;\nimport org.eclipse.cdt.core.settings.model.ICProjectDescriptionWorkspacePreferences;\nimport org.eclipse.cdt.core.settings.model.ICResourceDescription;\nimport org.eclipse.cdt.core.settings.model.ICSettingBase;\nimport org.eclipse.cdt.core.settings.model.ICSettingEntry;\nimport org.eclipse.cdt.core.settings.model.ICSettingObject;\nimport org.eclipse.cdt.core.settings.model.ICSettingsStorage;\nimport org.eclipse.cdt.core.settings.model.ICSourceEntry;\nimport org.eclipse.cdt.core.settings.model.ICStorageElement;\nimport org.eclipse.cdt.core.settings.model.ICTargetPlatformSetting;\nimport org.eclipse.cdt.core.settings.model.extension.CConfigurationData;\nimport org.eclipse.cdt.core.settings.model.extension.CConfigurationDataProvider;\nimport org.eclipse.cdt.core.settings.model.extension.CFileData;\nimport org.eclipse.cdt.core.settings.model.extension.CFolderData;\nimport org.eclipse.cdt.core.settings.model.extension.CLanguageData;",
        "code_after_change": " *     Intel Corporation - Initial API and implementation\n *     Markus Schorn (Wind River Systems)\n *     IBM Corporation\n *     James Blackburn (Broadcom Corp.)\n *     Alex Blewitt Bug 132511 - nature order not preserved\n *     Christian Walther (Indel AG) - [436060] Race condition in updateProjectDescriptions()\n *     Alexander Fedorov (ArSysOp) - Bug 561992\n *******************************************************************************/\npackage org.eclipse.cdt.internal.core.settings.model;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URI;\nimport java.text.MessageFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.concurrent.CopyOnWriteArraySet;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.FactoryConfigurationError;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.eclipse.cdt.core.CCorePlugin;\nimport org.eclipse.cdt.core.language.settings.providers.ILanguageSettingsProvider;\nimport org.eclipse.cdt.core.language.settings.providers.ILanguageSettingsProvidersKeeper;\nimport org.eclipse.cdt.core.model.CModelException;\nimport org.eclipse.cdt.core.model.ICElement;\nimport org.eclipse.cdt.core.model.ICElementDelta;\nimport org.eclipse.cdt.core.model.ICProject;\nimport org.eclipse.cdt.core.settings.model.CExternalSetting;\nimport org.eclipse.cdt.core.settings.model.CProjectDescriptionEvent;\nimport org.eclipse.cdt.core.settings.model.ICBuildSetting;\nimport org.eclipse.cdt.core.settings.model.ICConfigurationDescription;\nimport org.eclipse.cdt.core.settings.model.ICDescriptionDelta;\nimport org.eclipse.cdt.core.settings.model.ICFileDescription;\nimport org.eclipse.cdt.core.settings.model.ICFolderDescription;\nimport org.eclipse.cdt.core.settings.model.ICLanguageSetting;\nimport org.eclipse.cdt.core.settings.model.ICLanguageSettingEntry;\nimport org.eclipse.cdt.core.settings.model.ICProjectDescription;\nimport org.eclipse.cdt.core.settings.model.ICProjectDescriptionListener;\nimport org.eclipse.cdt.core.settings.model.ICProjectDescriptionManager;\nimport org.eclipse.cdt.core.settings.model.ICProjectDescriptionWorkspacePreferences;\nimport org.eclipse.cdt.core.settings.model.ICResourceDescription;\nimport org.eclipse.cdt.core.settings.model.ICSettingBase;\nimport org.eclipse.cdt.core.settings.model.ICSettingEntry;\nimport org.eclipse.cdt.core.settings.model.ICSettingObject;\nimport org.eclipse.cdt.core.settings.model.ICSettingsStorage;\nimport org.eclipse.cdt.core.settings.model.ICSourceEntry;\nimport org.eclipse.cdt.core.settings.model.ICStorageElement;\nimport org.eclipse.cdt.core.settings.model.ICTargetPlatformSetting;\nimport org.eclipse.cdt.core.settings.model.extension.CConfigurationData;\nimport org.eclipse.cdt.core.settings.model.extension.CConfigurationDataProvider;\nimport org.eclipse.cdt.core.settings.model.extension.CFileData;\nimport org.eclipse.cdt.core.settings.model.extension.CFolderData;\nimport org.eclipse.cdt.core.settings.model.extension.CLanguageData;\nimport org.eclipse.cdt.core.settings.model.extension.CResourceData;\nimport org.eclipse.cdt.core.settings.model.extension.ICProjectConverter;",
        "patch": "@@ -45,14 +45,12 @@\n import java.util.concurrent.CopyOnWriteArraySet;\n \n import javax.xml.parsers.DocumentBuilder;\n-import javax.xml.parsers.DocumentBuilderFactory;\n import javax.xml.parsers.FactoryConfigurationError;\n import javax.xml.parsers.ParserConfigurationException;\n import javax.xml.transform.OutputKeys;\n import javax.xml.transform.Transformer;\n import javax.xml.transform.TransformerConfigurationException;\n import javax.xml.transform.TransformerException;\n-import javax.xml.transform.TransformerFactory;\n import javax.xml.transform.dom.DOMSource;\n import javax.xml.transform.stream.StreamResult;\n \n@@ -98,6 +96,7 @@\n import org.eclipse.cdt.core.settings.model.util.PathSettingsContainer;\n import org.eclipse.cdt.core.settings.model.util.PatternNameMap;\n import org.eclipse.cdt.internal.core.CConfigBasedDescriptorManager;\n+import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n import org.eclipse.cdt.internal.core.model.CElementDelta;\n import org.eclipse.cdt.internal.core.settings.model.CExternalSettinsDeltaCalculator.ExtSettingsDelta;\n import org.eclipse.cdt.internal.core.settings.model.xml.InternalXmlStorageElement;\n@@ -918,7 +917,8 @@ private void serializePreference(String key, InternalXmlStorageElement element)\n \t\tByteArrayOutputStream stream = new ByteArrayOutputStream();\n \t\tFileOutputStream fileStream = null;\n \t\ttry {\n-\t\t\tTransformer transformer = TransformerFactory.newInstance().newTransformer();\n+\t\t\tTransformer transformer = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE()\n+\t\t\t\t\t.newTransformer();\n \t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n \t\t\ttransformer.setOutputProperty(OutputKeys.ENCODING, \"UTF-8\"); //$NON-NLS-1$\n \t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n@@ -1234,7 +1234,7 @@ private void initProviderInfo() {\n \tpublic ICStorageElement createPreferenceStorage(String key, boolean createEmptyIfNotFound, boolean readOnly)\n \t\t\tthrows CoreException {\n \t\ttry {\n-\t\t\tDocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n+\t\t\tDocumentBuilder builder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tDocument doc = null;\n \t\t\tElement element = null;\n \t\t\tInputStream stream = null;",
        "function_modified_lines": {
            "added": [],
            "deleted": [
                "import javax.xml.parsers.DocumentBuilderFactory;\n",
                "import javax.xml.transform.TransformerFactory;\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-611"
        ],
        "cve_description": "In Eclipse IDE versions < 2023-09 (4.29) some files with xml content are parsed vulnerable against all sorts of XXE attacks. The user just needs to open any evil project or update an open project with a vulnerable file (for example for review a foreign repository or patch).\n",
        "id": 12861
    },
    {
        "cve_id": "CVE-2023-4218",
        "code_before_change": "/*******************************************************************************\n * Copyright (c) 2007, 2013 Intel Corporation and others.\n *\n * This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n *\n * Contributors:\n *     Intel Corporation - Initial API and implementation\n *     Markus Schorn (Wind River Systems)\n *     IBM Corporation\n *     James Blackburn (Broadcom Corp.)\n *     Marc-Andre Laperle (Ericsson)\n *******************************************************************************/\npackage org.eclipse.cdt.internal.core.settings.model.xml;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.lang.ref.Reference;\nimport java.lang.ref.SoftReference;\nimport java.net.URI;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.FactoryConfigurationError;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.eclipse.cdt.core.CCorePlugin;\nimport org.eclipse.cdt.core.settings.model.ICProjectDescription;\nimport org.eclipse.cdt.core.settings.model.ICProjectDescriptionManager;\nimport org.eclipse.cdt.core.settings.model.ICSettingsStorage;\nimport org.eclipse.cdt.core.settings.model.ICStorageElement;\nimport org.eclipse.cdt.core.settings.model.extension.ICProjectConverter;\nimport org.eclipse.cdt.core.settings.model.util.CDataUtil;\nimport org.eclipse.cdt.internal.core.XmlUtil;\nimport org.eclipse.cdt.internal.core.envvar.ContributedEnvironment;\nimport org.eclipse.cdt.internal.core.language.settings.providers.LanguageSettingsProvidersSerializer;\nimport org.eclipse.cdt.internal.core.model.Util;\nimport org.eclipse.cdt.internal.core.settings.model.AbstractCProjectDescriptionStorage;\nimport org.eclipse.cdt.internal.core.settings.model.CProjectDescription;\nimport org.eclipse.cdt.internal.core.settings.model.CProjectDescriptionManager;\nimport org.eclipse.cdt.internal.core.settings.model.CProjectDescriptionStorageManager;\nimport org.eclipse.cdt.internal.core.settings.model.ExceptionFactory;\nimport org.eclipse.cdt.internal.core.settings.model.ICProjectDescriptionStorageType;\nimport org.eclipse.cdt.internal.core.settings.model.ICProjectDescriptionStorageType.CProjectDescriptionStorageTypeProxy;\nimport org.eclipse.cdt.internal.core.settings.model.SettingsContext;\nimport org.eclipse.cdt.internal.core.settings.model.SettingsModelMessages;\nimport org.eclipse.core.filesystem.EFS;\nimport org.eclipse.core.filesystem.IFileInfo;\nimport org.eclipse.core.filesystem.IFileStore;\nimport org.eclipse.core.resources.IContainer;\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.resources.IProjectDescription;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.resources.IWorkspace;\nimport org.eclipse.core.resources.IWorkspaceRunnable;\nimport org.eclipse.core.resources.ResourcesPlugin;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.IProgressMonitor;\nimport org.eclipse.core.runtime.IStatus;\nimport org.eclipse.core.runtime.NullProgressMonitor;\nimport org.eclipse.core.runtime.Path;\nimport org.eclipse.core.runtime.QualifiedName;\nimport org.eclipse.core.runtime.Status;\nimport org.eclipse.core.runtime.jobs.IJobChangeEvent;\nimport org.eclipse.core.runtime.jobs.ILock;\nimport org.eclipse.core.runtime.jobs.ISchedulingRule;\nimport org.eclipse.core.runtime.jobs.Job;\nimport org.eclipse.core.runtime.jobs.JobChangeAdapter;\nimport org.eclipse.core.runtime.jobs.MultiRule;\nimport org.osgi.framework.Version;",
        "code_after_change": "/*******************************************************************************\n * Copyright (c) 2007, 2013 Intel Corporation and others.\n *\n * This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n *\n * Contributors:\n *     Intel Corporation - Initial API and implementation\n *     Markus Schorn (Wind River Systems)\n *     IBM Corporation\n *     James Blackburn (Broadcom Corp.)\n *     Marc-Andre Laperle (Ericsson)\n *******************************************************************************/\npackage org.eclipse.cdt.internal.core.settings.model.xml;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.lang.ref.Reference;\nimport java.lang.ref.SoftReference;\nimport java.net.URI;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.FactoryConfigurationError;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.eclipse.cdt.core.CCorePlugin;\nimport org.eclipse.cdt.core.settings.model.ICProjectDescription;\nimport org.eclipse.cdt.core.settings.model.ICProjectDescriptionManager;\nimport org.eclipse.cdt.core.settings.model.ICSettingsStorage;\nimport org.eclipse.cdt.core.settings.model.ICStorageElement;\nimport org.eclipse.cdt.core.settings.model.extension.ICProjectConverter;\nimport org.eclipse.cdt.core.settings.model.util.CDataUtil;\nimport org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\nimport org.eclipse.cdt.internal.core.XmlUtil;\nimport org.eclipse.cdt.internal.core.envvar.ContributedEnvironment;\nimport org.eclipse.cdt.internal.core.language.settings.providers.LanguageSettingsProvidersSerializer;\nimport org.eclipse.cdt.internal.core.model.Util;\nimport org.eclipse.cdt.internal.core.settings.model.AbstractCProjectDescriptionStorage;\nimport org.eclipse.cdt.internal.core.settings.model.CProjectDescription;\nimport org.eclipse.cdt.internal.core.settings.model.CProjectDescriptionManager;\nimport org.eclipse.cdt.internal.core.settings.model.CProjectDescriptionStorageManager;\nimport org.eclipse.cdt.internal.core.settings.model.ExceptionFactory;\nimport org.eclipse.cdt.internal.core.settings.model.ICProjectDescriptionStorageType;\nimport org.eclipse.cdt.internal.core.settings.model.ICProjectDescriptionStorageType.CProjectDescriptionStorageTypeProxy;\nimport org.eclipse.cdt.internal.core.settings.model.SettingsContext;\nimport org.eclipse.cdt.internal.core.settings.model.SettingsModelMessages;\nimport org.eclipse.core.filesystem.EFS;\nimport org.eclipse.core.filesystem.IFileInfo;\nimport org.eclipse.core.filesystem.IFileStore;\nimport org.eclipse.core.resources.IContainer;\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.resources.IProjectDescription;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.resources.IWorkspace;\nimport org.eclipse.core.resources.IWorkspaceRunnable;\nimport org.eclipse.core.resources.ResourcesPlugin;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.IProgressMonitor;\nimport org.eclipse.core.runtime.IStatus;\nimport org.eclipse.core.runtime.NullProgressMonitor;\nimport org.eclipse.core.runtime.Path;\nimport org.eclipse.core.runtime.QualifiedName;\nimport org.eclipse.core.runtime.Status;\nimport org.eclipse.core.runtime.jobs.IJobChangeEvent;\nimport org.eclipse.core.runtime.jobs.ILock;\nimport org.eclipse.core.runtime.jobs.ISchedulingRule;\nimport org.eclipse.core.runtime.jobs.Job;\nimport org.eclipse.core.runtime.jobs.JobChangeAdapter;",
        "patch": "@@ -26,14 +26,12 @@\n import java.net.URI;\n \n import javax.xml.parsers.DocumentBuilder;\n-import javax.xml.parsers.DocumentBuilderFactory;\n import javax.xml.parsers.FactoryConfigurationError;\n import javax.xml.parsers.ParserConfigurationException;\n import javax.xml.transform.OutputKeys;\n import javax.xml.transform.Transformer;\n import javax.xml.transform.TransformerConfigurationException;\n import javax.xml.transform.TransformerException;\n-import javax.xml.transform.TransformerFactory;\n import javax.xml.transform.dom.DOMSource;\n import javax.xml.transform.stream.StreamResult;\n \n@@ -44,6 +42,7 @@\n import org.eclipse.cdt.core.settings.model.ICStorageElement;\n import org.eclipse.cdt.core.settings.model.extension.ICProjectConverter;\n import org.eclipse.cdt.core.settings.model.util.CDataUtil;\n+import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n import org.eclipse.cdt.internal.core.XmlUtil;\n import org.eclipse.cdt.internal.core.envvar.ContributedEnvironment;\n import org.eclipse.cdt.internal.core.language.settings.providers.LanguageSettingsProvidersSerializer;\n@@ -543,7 +542,8 @@ private ByteArrayOutputStream write(ICStorageElement element) throws CoreExcepti\n \n \t\tByteArrayOutputStream stream = new ByteArrayOutputStream();\n \t\ttry {\n-\t\t\tTransformer transformer = TransformerFactory.newInstance().newTransformer();\n+\t\t\tTransformer transformer = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE()\n+\t\t\t\t\t.newTransformer();\n \t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n \t\t\ttransformer.setOutputProperty(OutputKeys.ENCODING, \"UTF-8\"); //$NON-NLS-1$\n \t\t\t// Indentation is done with XmlUtil.prettyFormat(doc)\n@@ -632,7 +632,7 @@ protected long serialize(IContainer container, String file, ICStorageElement ele\n \tprivate ICStorageElement readOldCDTProjectFile(IProject project) throws CoreException {\n \t\tICStorageElement storage = null;\n \t\ttry {\n-\t\t\tDocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n+\t\t\tDocumentBuilder builder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tDocument doc = null;\n \t\t\tInputStream stream = getSharedProperty(project, OLD_CDTPROJECT_FILE_NAME);\n \t\t\tif (stream != null) {\n@@ -669,7 +669,7 @@ private ICStorageElement readOldCDTProjectFile(IProject project) throws CoreExce\n \tprotected InternalXmlStorageElement createStorage(IContainer container, String fileName, boolean reCreate,\n \t\t\tboolean createEmptyIfNotFound, boolean readOnly) throws CoreException {\n \t\ttry {\n-\t\t\tDocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n+\t\t\tDocumentBuilder builder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tDocument doc = null;\n \t\t\tElement element = null;\n \t\t\tInputStream stream = null;\n@@ -851,7 +851,7 @@ public void projectMove(IProject newProject) {\n \t */\n \tpublic Element createXmlElementCopy(InternalXmlStorageElement el) throws CoreException {\n \t\ttry {\n-\t\t\tDocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n+\t\t\tDocumentBuilder builder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tDocument doc = builder.newDocument();\n \t\t\tElement newXmlEl = null;\n \t\t\tsynchronized (doc) {",
        "function_modified_lines": {
            "added": [
                "import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n"
            ],
            "deleted": [
                "import javax.xml.parsers.DocumentBuilderFactory;\n",
                "import javax.xml.transform.TransformerFactory;\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-611"
        ],
        "cve_description": "In Eclipse IDE versions < 2023-09 (4.29) some files with xml content are parsed vulnerable against all sorts of XXE attacks. The user just needs to open any evil project or update an open project with a vulnerable file (for example for review a foreign repository or patch).\n",
        "id": 12864
    },
    {
        "cve_id": "CVE-2023-4218",
        "code_before_change": "/*******************************************************************************\n * Copyright (c) 2007, 2012 Nokia and others.\n *\n * This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n *\n * Contributors:\n *     Nokia - initial API and implementation\n *******************************************************************************/\npackage org.eclipse.cdt.debug.ui.breakpointactions;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.StringReader;\nimport java.text.MessageFormat;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.eclipse.cdt.debug.core.CDIDebugModel;\nimport org.eclipse.cdt.debug.core.breakpointactions.AbstractBreakpointAction;\nimport org.eclipse.cdt.debug.internal.core.ICDebugInternalConstants;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.IAdaptable;\nimport org.eclipse.core.runtime.IProgressMonitor;\nimport org.eclipse.core.runtime.IStatus;\nimport org.eclipse.core.runtime.MultiStatus;\nimport org.eclipse.core.runtime.Status;\nimport org.eclipse.core.runtime.jobs.Job;\nimport org.eclipse.debug.core.DebugPlugin;\nimport org.eclipse.debug.core.ILaunchConfiguration;\nimport org.eclipse.debug.core.ILaunchManager;\nimport org.eclipse.debug.core.model.IBreakpoint;\nimport org.eclipse.debug.ui.DebugUITools;\nimport org.eclipse.ui.progress.WorkbenchJob;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.helpers.DefaultHandler;\n\npublic class ExternalToolAction extends AbstractBreakpointAction {\n\n\tprivate String externalToolName = \"\"; //$NON-NLS-1$\n\n\t@Override\n\tpublic IStatus execute(final IBreakpoint breakpoint, final IAdaptable context, final IProgressMonitor monitor) {\n\t\tJob uiJob = new WorkbenchJob(\"ExternalToolAction\") { //$NON-NLS-1$\n\t\t\t{\n\t\t\t\tsetPriority(INTERACTIVE);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic IStatus runInUIThread(IProgressMonitor monitor) {\n\t\t\t\treturn executeInUIThread(breakpoint, context, monitor);\n\t\t\t}\n\t\t};\n\t\tuiJob.schedule();\n\t\ttry {\n\t\t\tuiJob.join();\n\t\t} catch (InterruptedException e) {\n\t\t\treturn Status.CANCEL_STATUS;\n\t\t}\n\t\treturn uiJob.getResult();\n\t}\n\n\tprivate IStatus executeInUIThread(IBreakpoint breakpoint, IAdaptable context, IProgressMonitor monitor) {\n\t\tIStatus errorStatus = null;\n\t\tILaunchManager lcm = DebugPlugin.getDefault().getLaunchManager();\n\t\ttry {\n\t\t\tboolean launched = false;\n\t\t\tILaunchConfiguration[] launchConfigurations = lcm.getLaunchConfigurations();\n\t\t\tfor (int i = 0; i < launchConfigurations.length; i++) {\n\t\t\t\tif (launchConfigurations[i].getName().equals(externalToolName)) {\n\t\t\t\t\tDebugUITools.launch(launchConfigurations[i], ILaunchManager.RUN_MODE);\n\t\t\t\t\tlaunched = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!launched) {\n\t\t\t\tString errorMsg = MessageFormat.format(Messages.getString(\"ExternalToolAction.error.0\"), //$NON-NLS-1$\n\t\t\t\t\t\tnew Object[] { externalToolName });\n\t\t\t\terrorStatus = new Status(IStatus.ERROR, CDIDebugModel.getPluginIdentifier(),\n\t\t\t\t\t\tICDebugInternalConstants.STATUS_CODE_ERROR, errorMsg, null);\n\t\t\t}\n\n\t\t} catch (CoreException e) {\n\t\t\terrorStatus = e.getStatus();\n\t\t} catch (Exception e) {\n\t\t\terrorStatus = new Status(IStatus.ERROR, CDIDebugModel.getPluginIdentifier(),\n\t\t\t\t\tICDebugInternalConstants.STATUS_CODE_ERROR, e.getMessage(), e);\n\t\t}\n\n\t\tif (errorStatus != null) {\n\t\t\tString errorMsg = MessageFormat.format(Messages.getString(\"ExternalToolAction.error.1\"), //$NON-NLS-1$\n\t\t\t\t\tnew Object[] { externalToolName });\n\t\t\tMultiStatus ms = new MultiStatus(CDIDebugModel.getPluginIdentifier(),\n\t\t\t\t\tICDebugInternalConstants.STATUS_CODE_ERROR, errorMsg, null);\n\t\t\tms.add(errorStatus);\n\t\t\treturn ms;\n\t\t}\n\n\t\treturn Status.OK_STATUS;\n\t}\n\n\t@Override\n\tpublic String getDefaultName() {\n\t\treturn \"Untitled External Tool Action\"; //$NON-NLS-1$\n\t}\n\n\tpublic String getExternalToolName() {\n\t\treturn externalToolName;\n\t}\n\n\tpublic void setExternalToolName(String launchConfigName) {\n\t\tthis.externalToolName = launchConfigName;\n\t}\n\n\t@Override\n\tpublic String getIdentifier() {\n\t\treturn \"org.eclipse.cdt.debug.ui.breakpointactions.ExternalToolAction\"; //$NON-NLS-1$\n\t}\n\n\t@Override\n\tpublic String getMemento() {\n\t\tString executeData = \"\"; //$NON-NLS-1$\n\t\tif (externalToolName != null) {\n\t\t\tDocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();\n\t\t\tDocumentBuilder docBuilder = null;\n\t\t\ttry {\n\t\t\t\tdocBuilder = dfactory.newDocumentBuilder();\n\t\t\t\tDocument doc = docBuilder.newDocument();\n\n\t\t\t\tElement rootElement = doc.createElement(\"launchConfigName\"); //$NON-NLS-1$\n\t\t\t\trootElement.setAttribute(\"configName\", externalToolName); //$NON-NLS-1$\n\n\t\t\t\tdoc.appendChild(rootElement);\n\n\t\t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n\n\t\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n\t\t\t\tTransformer transformer = factory.newTransformer();\n\t\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\n\t\t\t\tDOMSource source = new DOMSource(doc);\n\t\t\t\tStreamResult outputTarget = new StreamResult(s);\n\t\t\t\ttransformer.transform(source, outputTarget);\n\n\t\t\t\texecuteData = s.toString(\"UTF8\"); //$NON-NLS-1$\n\n\t\t\t} catch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\treturn executeData;\n\t}\n\n\t@Override\n\tpublic String getSummary() {\n\t\treturn MessageFormat.format(Messages.getString(\"ExternalToolAction.Summary\"), //$NON-NLS-1$\n\t\t\t\tnew Object[] { externalToolName });\n\t}\n\n\t@Override\n\tpublic String getTypeName() {\n\t\treturn Messages.getString(\"ExternalToolAction.TypeName\"); //$NON-NLS-1$\n\t}\n\n\t@Override\n\tpublic void initializeFromMemento(String data) {\n\t\tElement root = null;\n\t\tDocumentBuilder parser;\n\t\ttry {\n\t\t\tparser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n\t\t\tparser.setErrorHandler(new DefaultHandler());\n\t\t\troot = parser.parse(new InputSource(new StringReader(data))).getDocumentElement();\n\t\t\tString value = root.getAttribute(\"configName\"); //$NON-NLS-1$\n\t\t\tif (value == null)\n\t\t\t\tthrow new Exception();\n\t\t\texternalToolName = value;\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n}\n",
        "code_after_change": "/*******************************************************************************\n * Copyright (c) 2007, 2012 Nokia and others.\n *\n * This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n *\n * Contributors:\n *     Nokia - initial API and implementation\n *******************************************************************************/\npackage org.eclipse.cdt.debug.ui.breakpointactions;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.StringReader;\nimport java.text.MessageFormat;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.eclipse.cdt.debug.core.CDIDebugModel;\nimport org.eclipse.cdt.debug.core.breakpointactions.AbstractBreakpointAction;\nimport org.eclipse.cdt.debug.internal.core.ICDebugInternalConstants;\nimport org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.IAdaptable;\nimport org.eclipse.core.runtime.IProgressMonitor;\nimport org.eclipse.core.runtime.IStatus;\nimport org.eclipse.core.runtime.MultiStatus;\nimport org.eclipse.core.runtime.Status;\nimport org.eclipse.core.runtime.jobs.Job;\nimport org.eclipse.debug.core.DebugPlugin;\nimport org.eclipse.debug.core.ILaunchConfiguration;\nimport org.eclipse.debug.core.ILaunchManager;\nimport org.eclipse.debug.core.model.IBreakpoint;\nimport org.eclipse.debug.ui.DebugUITools;\nimport org.eclipse.ui.progress.WorkbenchJob;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.helpers.DefaultHandler;\n\npublic class ExternalToolAction extends AbstractBreakpointAction {\n\n\tprivate String externalToolName = \"\"; //$NON-NLS-1$\n\n\t@Override\n\tpublic IStatus execute(final IBreakpoint breakpoint, final IAdaptable context, final IProgressMonitor monitor) {\n\t\tJob uiJob = new WorkbenchJob(\"ExternalToolAction\") { //$NON-NLS-1$\n\t\t\t{\n\t\t\t\tsetPriority(INTERACTIVE);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic IStatus runInUIThread(IProgressMonitor monitor) {\n\t\t\t\treturn executeInUIThread(breakpoint, context, monitor);\n\t\t\t}\n\t\t};\n\t\tuiJob.schedule();\n\t\ttry {\n\t\t\tuiJob.join();\n\t\t} catch (InterruptedException e) {\n\t\t\treturn Status.CANCEL_STATUS;\n\t\t}\n\t\treturn uiJob.getResult();\n\t}\n\n\tprivate IStatus executeInUIThread(IBreakpoint breakpoint, IAdaptable context, IProgressMonitor monitor) {\n\t\tIStatus errorStatus = null;\n\t\tILaunchManager lcm = DebugPlugin.getDefault().getLaunchManager();\n\t\ttry {\n\t\t\tboolean launched = false;\n\t\t\tILaunchConfiguration[] launchConfigurations = lcm.getLaunchConfigurations();\n\t\t\tfor (int i = 0; i < launchConfigurations.length; i++) {\n\t\t\t\tif (launchConfigurations[i].getName().equals(externalToolName)) {\n\t\t\t\t\tDebugUITools.launch(launchConfigurations[i], ILaunchManager.RUN_MODE);\n\t\t\t\t\tlaunched = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!launched) {\n\t\t\t\tString errorMsg = MessageFormat.format(Messages.getString(\"ExternalToolAction.error.0\"), //$NON-NLS-1$\n\t\t\t\t\t\tnew Object[] { externalToolName });\n\t\t\t\terrorStatus = new Status(IStatus.ERROR, CDIDebugModel.getPluginIdentifier(),\n\t\t\t\t\t\tICDebugInternalConstants.STATUS_CODE_ERROR, errorMsg, null);\n\t\t\t}\n\n\t\t} catch (CoreException e) {\n\t\t\terrorStatus = e.getStatus();\n\t\t} catch (Exception e) {\n\t\t\terrorStatus = new Status(IStatus.ERROR, CDIDebugModel.getPluginIdentifier(),\n\t\t\t\t\tICDebugInternalConstants.STATUS_CODE_ERROR, e.getMessage(), e);\n\t\t}\n\n\t\tif (errorStatus != null) {\n\t\t\tString errorMsg = MessageFormat.format(Messages.getString(\"ExternalToolAction.error.1\"), //$NON-NLS-1$\n\t\t\t\t\tnew Object[] { externalToolName });\n\t\t\tMultiStatus ms = new MultiStatus(CDIDebugModel.getPluginIdentifier(),\n\t\t\t\t\tICDebugInternalConstants.STATUS_CODE_ERROR, errorMsg, null);\n\t\t\tms.add(errorStatus);\n\t\t\treturn ms;\n\t\t}\n\n\t\treturn Status.OK_STATUS;\n\t}\n\n\t@Override\n\tpublic String getDefaultName() {\n\t\treturn \"Untitled External Tool Action\"; //$NON-NLS-1$\n\t}\n\n\tpublic String getExternalToolName() {\n\t\treturn externalToolName;\n\t}\n\n\tpublic void setExternalToolName(String launchConfigName) {\n\t\tthis.externalToolName = launchConfigName;\n\t}\n\n\t@Override\n\tpublic String getIdentifier() {\n\t\treturn \"org.eclipse.cdt.debug.ui.breakpointactions.ExternalToolAction\"; //$NON-NLS-1$\n\t}\n\n\t@Override\n\tpublic String getMemento() {\n\t\tString executeData = \"\"; //$NON-NLS-1$\n\t\tif (externalToolName != null) {\n\t\t\ttry {\n\t\t\t\tDocumentBuilder docBuilder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n\t\t\t\tDocument doc = docBuilder.newDocument();\n\n\t\t\t\tElement rootElement = doc.createElement(\"launchConfigName\"); //$NON-NLS-1$\n\t\t\t\trootElement.setAttribute(\"configName\", externalToolName); //$NON-NLS-1$\n\n\t\t\t\tdoc.appendChild(rootElement);\n\n\t\t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n\n\t\t\t\tTransformerFactory factory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n\t\t\t\tTransformer transformer = factory.newTransformer();\n\t\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\n\t\t\t\tDOMSource source = new DOMSource(doc);\n\t\t\t\tStreamResult outputTarget = new StreamResult(s);\n\t\t\t\ttransformer.transform(source, outputTarget);\n\n\t\t\t\texecuteData = s.toString(\"UTF8\"); //$NON-NLS-1$\n\n\t\t\t} catch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\treturn executeData;\n\t}\n\n\t@Override\n\tpublic String getSummary() {\n\t\treturn MessageFormat.format(Messages.getString(\"ExternalToolAction.Summary\"), //$NON-NLS-1$\n\t\t\t\tnew Object[] { externalToolName });\n\t}\n\n\t@Override\n\tpublic String getTypeName() {\n\t\treturn Messages.getString(\"ExternalToolAction.TypeName\"); //$NON-NLS-1$\n\t}\n\n\t@Override\n\tpublic void initializeFromMemento(String data) {\n\t\tElement root = null;\n\t\tDocumentBuilder parser;\n\t\ttry {\n\t\t\tparser = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n\t\t\tparser.setErrorHandler(new DefaultHandler());\n\t\t\troot = parser.parse(new InputSource(new StringReader(data))).getDocumentElement();\n\t\t\tString value = root.getAttribute(\"configName\"); //$NON-NLS-1$\n\t\t\tif (value == null)\n\t\t\t\tthrow new Exception();\n\t\t\texternalToolName = value;\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n}\n",
        "patch": "@@ -18,7 +18,6 @@\n import java.text.MessageFormat;\n \n import javax.xml.parsers.DocumentBuilder;\n-import javax.xml.parsers.DocumentBuilderFactory;\n import javax.xml.transform.OutputKeys;\n import javax.xml.transform.Transformer;\n import javax.xml.transform.TransformerFactory;\n@@ -28,6 +27,7 @@\n import org.eclipse.cdt.debug.core.CDIDebugModel;\n import org.eclipse.cdt.debug.core.breakpointactions.AbstractBreakpointAction;\n import org.eclipse.cdt.debug.internal.core.ICDebugInternalConstants;\n+import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n import org.eclipse.core.runtime.CoreException;\n import org.eclipse.core.runtime.IAdaptable;\n import org.eclipse.core.runtime.IProgressMonitor;\n@@ -132,10 +132,8 @@ public String getIdentifier() {\n \tpublic String getMemento() {\n \t\tString executeData = \"\"; //$NON-NLS-1$\n \t\tif (externalToolName != null) {\n-\t\t\tDocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();\n-\t\t\tDocumentBuilder docBuilder = null;\n \t\t\ttry {\n-\t\t\t\tdocBuilder = dfactory.newDocumentBuilder();\n+\t\t\t\tDocumentBuilder docBuilder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\t\tDocument doc = docBuilder.newDocument();\n \n \t\t\t\tElement rootElement = doc.createElement(\"launchConfigName\"); //$NON-NLS-1$\n@@ -145,7 +143,7 @@ public String getMemento() {\n \n \t\t\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n \n-\t\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n+\t\t\t\tTransformerFactory factory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n \t\t\t\tTransformer transformer = factory.newTransformer();\n \t\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n \t\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n@@ -179,7 +177,7 @@ public void initializeFromMemento(String data) {\n \t\tElement root = null;\n \t\tDocumentBuilder parser;\n \t\ttry {\n-\t\t\tparser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n+\t\t\tparser = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tparser.setErrorHandler(new DefaultHandler());\n \t\t\troot = parser.parse(new InputSource(new StringReader(data))).getDocumentElement();\n \t\t\tString value = root.getAttribute(\"configName\"); //$NON-NLS-1$",
        "function_modified_lines": {
            "added": [
                "import org.eclipse.cdt.internal.core.XmlProcessorFactoryCdt;\n"
            ],
            "deleted": [
                "import javax.xml.parsers.DocumentBuilderFactory;\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-611"
        ],
        "cve_description": "In Eclipse IDE versions < 2023-09 (4.29) some files with xml content are parsed vulnerable against all sorts of XXE attacks. The user just needs to open any evil project or update an open project with a vulnerable file (for example for review a foreign repository or patch).\n",
        "id": 12879
    },
    {
        "cve_id": "CVE-2023-4218",
        "code_before_change": "/*******************************************************************************\n * Copyright (c) 2000, 2018 IBM Corporation and others.\n *\n * This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n *\n * Contributors:\n *     IBM Corporation - initial API and implementation\n *******************************************************************************/\npackage org.eclipse.text.templates;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.MissingResourceException;\nimport java.util.ResourceBundle;\nimport java.util.Set;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.DefaultHandler;\n\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.Text;\n\nimport org.eclipse.osgi.util.NLS;\n\nimport org.eclipse.core.runtime.Assert;\nimport org.eclipse.core.runtime.ILog;\nimport org.eclipse.core.runtime.IStatus;\nimport org.eclipse.core.runtime.Platform;\nimport org.eclipse.core.runtime.Status;\n\nimport org.eclipse.jface.text.templates.Template;\n\n/**\n * Serializes templates as character or byte stream and reads the same format\n * back.\n * <p>\n * Clients may instantiate this class, it is not intended to be\n * subclassed.</p>\n *\n * @since 3.7\n * @noextend This class is not intended to be subclassed by clients.\n */\npublic class TemplateReaderWriter {\n",
        "code_after_change": "/*******************************************************************************\n * Copyright (c) 2000, 2018 IBM Corporation and others.\n *\n * This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n *\n * Contributors:\n *     IBM Corporation - initial API and implementation\n *******************************************************************************/\npackage org.eclipse.text.templates;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.MissingResourceException;\nimport java.util.ResourceBundle;\nimport java.util.Set;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.DefaultHandler;\n\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.Text;\n\nimport org.eclipse.osgi.util.NLS;\n\nimport org.eclipse.core.runtime.Assert;\nimport org.eclipse.core.runtime.ILog;\nimport org.eclipse.core.runtime.IStatus;\nimport org.eclipse.core.runtime.Platform;\nimport org.eclipse.core.runtime.Status;\n\nimport org.eclipse.jface.text.templates.Template;\n\n/**\n * Serializes templates as character or byte stream and reads the same format\n * back.\n * <p>\n * Clients may instantiate this class, it is not intended to be\n * subclassed.</p>\n *\n * @since 3.7\n * @noextend This class is not intended to be subclassed by clients.\n */\npublic class TemplateReaderWriter {\n\n\tprivate static final String TEMPLATE_ROOT = \"templates\"; //$NON-NLS-1$\n\tprivate static final String TEMPLATE_ELEMENT = \"template\"; //$NON-NLS-1$",
        "patch": "@@ -27,12 +27,10 @@\n import java.util.Set;\n \n import javax.xml.parsers.DocumentBuilder;\n-import javax.xml.parsers.DocumentBuilderFactory;\n import javax.xml.parsers.ParserConfigurationException;\n import javax.xml.transform.OutputKeys;\n import javax.xml.transform.Transformer;\n import javax.xml.transform.TransformerException;\n-import javax.xml.transform.TransformerFactory;\n import javax.xml.transform.dom.DOMSource;\n import javax.xml.transform.stream.StreamResult;\n \n@@ -157,8 +155,8 @@ private TemplatePersistenceData[] read(InputSource source, ResourceBundle bundle\n \t\t\tCollection<TemplatePersistenceData> templates= new ArrayList<>();\n \t\t\tSet<String> ids= new HashSet<>();\n \n-\t\t\tDocumentBuilderFactory factory= DocumentBuilderFactory.newInstance();\n-\t\t\tDocumentBuilder parser= factory.newDocumentBuilder();\n+\t\t\t@SuppressWarnings(\"restriction\")\n+\t\t\tDocumentBuilder parser= org.eclipse.core.internal.runtime.XmlProcessorFactory.createDocumentBuilderWithErrorOnDOCTYPE();\n \t\t\tparser.setErrorHandler(new DefaultHandler());\n \t\t\tDocument document= parser.parse(source);\n \n@@ -263,10 +261,8 @@ public void save(TemplatePersistenceData[] templates, Writer writer) throws IOEx\n \t */\n \tprivate void save(TemplatePersistenceData[] templates, StreamResult result) throws IOException {\n \t\ttry {\n-\t\t\tDocumentBuilderFactory factory= DocumentBuilderFactory.newInstance();\n-\t\t\tDocumentBuilder builder= factory.newDocumentBuilder();\n-\t\t\tDocument document= builder.newDocument();\n-\n+\t\t\t@SuppressWarnings(\"restriction\")\n+\t\t\tDocument document= org.eclipse.core.internal.runtime.XmlProcessorFactory.newDocumentWithErrorOnDOCTYPE();\n \t\t\tNode root= document.createElement(TEMPLATE_ROOT);\n \t\t\tdocument.appendChild(root);\n \n@@ -322,9 +318,8 @@ private void save(TemplatePersistenceData[] templates, StreamResult result) thro\n \t\t\t\t\tnode.appendChild(pattern);\n \t\t\t\t}\n \t\t\t}\n-\n-\n-\t\t\tTransformer transformer=TransformerFactory.newInstance().newTransformer();\n+\t\t\t@SuppressWarnings(\"restriction\")\n+\t\t\tTransformer transformer= org.eclipse.core.internal.runtime.XmlProcessorFactory.createTransformerFactoryWithErrorOnDOCTYPE().newTransformer();\n \t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n \t\t\ttransformer.setOutputProperty(OutputKeys.ENCODING, StandardCharsets.UTF_8.name());\n \t\t\tDOMSource source = new DOMSource(document);",
        "function_modified_lines": {
            "added": [],
            "deleted": [
                "import javax.xml.parsers.DocumentBuilderFactory;\n",
                "import javax.xml.transform.TransformerFactory;\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-611"
        ],
        "cve_description": "In Eclipse IDE versions < 2023-09 (4.29) some files with xml content are parsed vulnerable against all sorts of XXE attacks. The user just needs to open any evil project or update an open project with a vulnerable file (for example for review a foreign repository or patch).\n",
        "id": 12847
    }
]