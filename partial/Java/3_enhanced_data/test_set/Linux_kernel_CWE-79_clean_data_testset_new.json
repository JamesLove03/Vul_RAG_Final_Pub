[
    {
        "cve_id": "CVE-2018-1000129",
        "code_before_change": "    public void doHandle(HttpExchange pExchange) throws IOException {\n        if (requestHandler == null) {\n            throw new IllegalStateException(\"Handler not yet started\");\n        }\n\n        JSONAware json = null;\n        URI uri = pExchange.getRequestURI();\n        ParsedUri parsedUri = new ParsedUri(uri, context);\n        try {\n            // Check access policy\n            InetSocketAddress address = pExchange.getRemoteAddress();\n            requestHandler.checkAccess(getHostName(address),\n                                       address.getAddress().getHostAddress(),\n                                       extractOriginOrReferer(pExchange));\n            String method = pExchange.getRequestMethod();\n\n            // Dispatch for the proper HTTP request method\n            if (\"GET\".equalsIgnoreCase(method)) {\n                setHeaders(pExchange);\n                json = executeGetRequest(parsedUri);\n            } else if (\"POST\".equalsIgnoreCase(method)) {\n                setHeaders(pExchange);\n                json = executePostRequest(pExchange, parsedUri);\n            } else if (\"OPTIONS\".equalsIgnoreCase(method)) {\n                performCorsPreflightCheck(pExchange);\n            } else {\n                throw new IllegalArgumentException(\"HTTP Method \" + method + \" is not supported.\");\n            }\n        } catch (Throwable exp) {\n            json = requestHandler.handleThrowable(\n                    exp instanceof RuntimeMBeanException ? ((RuntimeMBeanException) exp).getTargetException() : exp);\n        } finally {\n            sendResponse(pExchange, parsedUri, json);\n        }\n    }\n\n    // ========================================================================\n\n    // Used for checking origin or referer is an origin policy is enabled\n    private String extractOriginOrReferer(HttpExchange pExchange) {\n        Headers headers = pExchange.getRequestHeaders();\n        String origin = headers.getFirst(\"Origin\");\n        if (origin == null) {\n            origin = headers.getFirst(\"Referer\");\n        }\n        return origin != null ? origin.replaceAll(\"[\\\\n\\\\r]*\",\"\") : null;\n    }\n\n    // Return hostnmae of given address, but only when reverse DNS lookups are allowed\n    private String getHostName(InetSocketAddress address) {\n        return configuration.getAsBoolean(ConfigKey.ALLOW_DNS_REVERSE_LOOKUP) ? address.getHostName() : null;\n    }\n\n    private JSONAware executeGetRequest(ParsedUri parsedUri) {\n        return requestHandler.handleGetRequest(parsedUri.getUri().toString(),parsedUri.getPathInfo(), parsedUri.getParameterMap());\n    }\n\n    private JSONAware executePostRequest(HttpExchange pExchange, ParsedUri pUri) throws MalformedObjectNameException, IOException {\n        String encoding = null;\n        Headers headers = pExchange.getRequestHeaders();\n        String cType =  headers.getFirst(\"Content-Type\");\n        if (cType != null) {\n            Matcher matcher = contentTypePattern.matcher(cType);\n            if (matcher.matches()) {\n                encoding = matcher.group(1);\n            }\n        }\n        InputStream is = pExchange.getRequestBody();\n        return requestHandler.handlePostRequest(pUri.toString(),is, encoding, pUri.getParameterMap());\n    }\n\n    private void performCorsPreflightCheck(HttpExchange pExchange) {\n        Headers requestHeaders = pExchange.getRequestHeaders();\n        Map<String,String> respHeaders =",
        "code_after_change": "        JSONAware json = null;\n        URI uri = pExchange.getRequestURI();\n        ParsedUri parsedUri = new ParsedUri(uri, context);\n        try {\n            // Check access policy\n            InetSocketAddress address = pExchange.getRemoteAddress();\n            requestHandler.checkAccess(getHostName(address),\n                                       address.getAddress().getHostAddress(),\n                                       extractOriginOrReferer(pExchange));\n            String method = pExchange.getRequestMethod();\n\n            // If a callback is given, check this is a valid javascript function name\n            validateCallbackIfGiven(parsedUri);\n\n            // Dispatch for the proper HTTP request method\n            if (\"GET\".equalsIgnoreCase(method)) {\n                setHeaders(pExchange);\n                json = executeGetRequest(parsedUri);\n            } else if (\"POST\".equalsIgnoreCase(method)) {\n                setHeaders(pExchange);\n                json = executePostRequest(pExchange, parsedUri);\n            } else if (\"OPTIONS\".equalsIgnoreCase(method)) {\n                performCorsPreflightCheck(pExchange);\n            } else {\n                throw new IllegalArgumentException(\"HTTP Method \" + method + \" is not supported.\");\n            }\n        } catch (Throwable exp) {\n            json = requestHandler.handleThrowable(\n                    exp instanceof RuntimeMBeanException ? ((RuntimeMBeanException) exp).getTargetException() : exp);\n        } finally {\n            sendResponse(pExchange, parsedUri, json);\n        }\n    }\n\n\n    private void validateCallbackIfGiven(ParsedUri pUri) {\n        String callback = pUri.getParameter(ConfigKey.CALLBACK.getKeyValue());\n        if (callback != null && !MimeTypeUtil.isValidCallback(callback)) {\n            throw new IllegalArgumentException(\"Invalid callback name given, which must be a valid javascript function name\");\n        }\n    }\n\n    // ========================================================================\n\n    // Used for checking origin or referer is an origin policy is enabled\n    private String extractOriginOrReferer(HttpExchange pExchange) {\n        Headers headers = pExchange.getRequestHeaders();\n        String origin = headers.getFirst(\"Origin\");\n        if (origin == null) {\n            origin = headers.getFirst(\"Referer\");\n        }\n        return origin != null ? origin.replaceAll(\"[\\\\n\\\\r]*\",\"\") : null;\n    }\n\n    // Return hostnmae of given address, but only when reverse DNS lookups are allowed\n    private String getHostName(InetSocketAddress address) {\n        return configuration.getAsBoolean(ConfigKey.ALLOW_DNS_REVERSE_LOOKUP) ? address.getHostName() : null;\n    }\n\n    private JSONAware executeGetRequest(ParsedUri parsedUri) {\n        return requestHandler.handleGetRequest(parsedUri.getUri().toString(),parsedUri.getPathInfo(), parsedUri.getParameterMap());\n    }\n\n    private JSONAware executePostRequest(HttpExchange pExchange, ParsedUri pUri) throws MalformedObjectNameException, IOException {\n        String encoding = null;\n        Headers headers = pExchange.getRequestHeaders();\n        String cType =  headers.getFirst(\"Content-Type\");\n        if (cType != null) {\n            Matcher matcher = contentTypePattern.matcher(cType);\n            if (matcher.matches()) {\n                encoding = matcher.group(1);\n            }\n        }\n        InputStream is = pExchange.getRequestBody();\n        return requestHandler.handlePostRequest(pUri.toString(),is, encoding, pUri.getParameterMap());\n    }\n\n    private void performCorsPreflightCheck(HttpExchange pExchange) {",
        "patch": "@@ -224,6 +224,9 @@ public void doHandle(HttpExchange pExchange) throws IOException {\n                                        extractOriginOrReferer(pExchange));\n             String method = pExchange.getRequestMethod();\n \n+            // If a callback is given, check this is a valid javascript function name\n+            validateCallbackIfGiven(parsedUri);\n+\n             // Dispatch for the proper HTTP request method\n             if (\"GET\".equalsIgnoreCase(method)) {\n                 setHeaders(pExchange);\n@@ -244,6 +247,14 @@ public void doHandle(HttpExchange pExchange) throws IOException {\n         }\n     }\n \n+\n+    private void validateCallbackIfGiven(ParsedUri pUri) {\n+        String callback = pUri.getParameter(ConfigKey.CALLBACK.getKeyValue());\n+        if (callback != null && !MimeTypeUtil.isValidCallback(callback)) {\n+            throw new IllegalArgumentException(\"Invalid callback name given, which must be a valid javascript function name\");\n+        }\n+    }\n+\n     // ========================================================================\n \n     // Used for checking origin or referer is an origin policy is enabled\n@@ -342,10 +353,11 @@ private void sendStreamingResponse(HttpExchange pExchange, ParsedUri pParsedUri,\n         Headers headers = pExchange.getResponseHeaders();\n         if (pJson != null) {\n             headers.set(\"Content-Type\", getMimeType(pParsedUri) + \"; charset=utf-8\");\n-            String callback = pParsedUri.getParameter(ConfigKey.CALLBACK.getKeyValue());\n             pExchange.sendResponseHeaders(200, 0);\n             Writer writer = new OutputStreamWriter(pExchange.getResponseBody(), \"UTF-8\");\n-            IoUtil.streamResponseAndClose(writer, pJson, callback);\n+\n+            String callback = pParsedUri.getParameter(ConfigKey.CALLBACK.getKeyValue());\n+            IoUtil.streamResponseAndClose(writer, pJson, callback != null && MimeTypeUtil.isValidCallback(callback) ? callback : null);\n         } else {\n             headers.set(\"Content-Type\", \"text/plain\");\n             pExchange.sendResponseHeaders(200,-1);\n@@ -360,7 +372,7 @@ private void sendAllJSON(HttpExchange pExchange, ParsedUri pParsedUri, JSONAware\n                 headers.set(\"Content-Type\", getMimeType(pParsedUri) + \"; charset=utf-8\");\n                 String json = pJson.toJSONString();\n                 String callback = pParsedUri.getParameter(ConfigKey.CALLBACK.getKeyValue());\n-                String content = callback == null ? json : callback + \"(\" + json + \");\";\n+                String content = callback != null && MimeTypeUtil.isValidCallback(callback) ? callback + \"(\" + json + \");\" : json;\n                 byte[] response = content.getBytes(\"UTF8\");\n                 pExchange.sendResponseHeaders(200,response.length);\n                 out = pExchange.getResponseBody();\n@@ -380,16 +392,10 @@ private void sendAllJSON(HttpExchange pExchange, ParsedUri pParsedUri, JSONAware\n \n     // Get the proper mime type according to configuration\n     private String getMimeType(ParsedUri pParsedUri) {\n-        if (pParsedUri.getParameter(ConfigKey.CALLBACK.getKeyValue()) != null) {\n-            return \"text/javascript\";\n-        } else {\n-            String mimeType = pParsedUri.getParameter(ConfigKey.MIME_TYPE.getKeyValue());\n-            if (mimeType != null) {\n-                return mimeType;\n-            }\n-            mimeType = configuration.get(ConfigKey.MIME_TYPE);\n-            return mimeType != null ? mimeType : ConfigKey.MIME_TYPE.getDefaultValue();\n-        }\n+        return MimeTypeUtil.getResponseMimeType(\n+            pParsedUri.getParameter(ConfigKey.MIME_TYPE.getKeyValue()),\n+            configuration.get(ConfigKey.MIME_TYPE),\n+            pParsedUri.getParameter(ConfigKey.CALLBACK.getKeyValue()));\n     }\n \n     // Creat a log handler from either the given class or by creating a default log handler printing",
        "function_modified_lines": {
            "added": [
                "\n",
                "    private void validateCallbackIfGiven(ParsedUri pUri) {\n",
                "        String callback = pUri.getParameter(ConfigKey.CALLBACK.getKeyValue());\n",
                "        if (callback != null && !MimeTypeUtil.isValidCallback(callback)) {\n",
                "            throw new IllegalArgumentException(\"Invalid callback name given, which must be a valid javascript function name\");\n",
                "        }\n",
                "    }\n",
                "\n"
            ],
            "deleted": []
        },
        "lang": "Java",
        "cwe": [
            "CWE-79"
        ],
        "cve_description": "An XSS vulnerability exists in the Jolokia agent version 1.3.7 in the HTTP servlet that allows an attacker to execute malicious javascript in the victim's browser.",
        "id": 11979
    },
    {
        "cve_id": "CVE-2021-25929",
        "code_before_change": "/*******************************************************************************\n * This file is part of OpenNMS(R).\n *\n * Copyright (C) 2011-2014 The OpenNMS Group, Inc.\n * OpenNMS(R) is Copyright (C) 1999-2014 The OpenNMS Group, Inc.\n *\n * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n *\n * OpenNMS(R) is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published\n * by the Free Software Foundation, either version 3 of the License,\n * or (at your option) any later version.\n *\n * OpenNMS(R) is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with OpenNMS(R).  If not, see:\n *      http://www.gnu.org/licenses/\n *\n * For more information contact:\n *     OpenNMS(R) Licensing <license@opennms.org>\n *     http://www.opennms.org/\n *     http://www.opennms.com/\n *******************************************************************************/\n\npackage org.opennms.smoketest;\n\nimport static org.junit.Assert.assertEquals;\n\nimport java.util.List;\n\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.openqa.selenium.Alert;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebElement;\nimport org.openqa.selenium.support.ui.ExpectedConditions;\nimport org.openqa.selenium.support.ui.Select;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class UserIT extends OpenNMSSeleniumIT {\n    private static final Logger LOG = LoggerFactory.getLogger(UserIT.class);\n\n    @Before\n    public void setUp() throws Exception {\n        driver.get(getBaseUrlInternal() + \"opennms/account/selfService/index.jsp\");\n    }\n\n    @Test\n    public void testExpectedTextAndLinksArePresent() throws Exception {\n        final List<WebElement> headers = driver.findElements(By.xpath(\"//div[@class='card-header']/span\"));\n        assertEquals(\"Account page should have 2 panels\", 2, headers.size());\n        assertEquals(\"Account page should have \\\"User Account Self-Service\\\" panel\", \"User Account Self-Service\", headers.get(0).getText());\n        assertEquals(\"Account page should have \\\"User Account Self-Service Options\\\" panel\", \"Account Self-Service Options\", headers.get(1).getText());\n    }\n\n    @Test\n    public void testSubmitWithWrongPassword() throws InterruptedException {\n        driver.findElement(By.linkText(\"Change Password\")).click();\n        enterText(By.cssSelector(\"input[type=password][name=oldpass]\"), \"12345\");\n        enterText(By.cssSelector(\"input[type=password][name=pass1]\"), \"23456\");\n        enterText(By.cssSelector(\"input[type=password][name=pass2]\"), \"34567\");\n        driver.findElement(By.cssSelector(\"button[type=submit]\")).click();\n\n        try {\n            final Alert alert = wait.until(ExpectedConditions.alertIsPresent());\n            alert.dismiss();\n        } catch (final Exception e) {\n            LOG.debug(\"Got an exception waiting for a 'wrong password' alert.\", e);\n            throw e;\n        }\n    }\n\n    @Test\n    public void testUsersAndGroups() throws Exception {\n        adminPage();\n        findElementByLink(\"Configure Users, Groups and On-Call Roles\").click();\n        findElementByLink(\"Configure Users\").click();\n        findElementByLink(\"Add new user\").click();\n\n        enterText(By.id(\"userID\"), USER_NAME);\n        enterText(By.id(\"pass1\"), \"SmokeTestPassword\");\n        enterText(By.id(\"pass2\"), \"SmokeTestPassword\");\n        findElementByXpath(\"//button[@type='submit' and text()='OK']\").click();\n\n        findElementById(\"saveUserButton\").click();\n        findElementById(\"users(\" + USER_NAME + \").doDetails\");\n\n        adminPage();\n        findElementByLink(\"Configure Users, Groups and On-Call Roles\").click();\n        findElementByLink(\"Configure Groups\").click();\n        findElementByLink(\"Add new group\").click();\n\n        enterText(By.id(\"groupName\"), GROUP_NAME);\n        enterText(By.id(\"groupComment\"), \"Test\");\n        findElementByXpath(\"//button[@type='submit' and text()='OK']\").click();\n\n        final Select select = new Select(findElementByName(\"availableUsers\"));\n        select.selectByVisibleText(USER_NAME);\n        findElementById(\"users.doAdd\").click();\n\n        findElementByName(\"finish\").click();\n\n        findElementByLink(GROUP_NAME).click();\n        driver.findElement(By.xpath(\"//div[@class='card-header']/span[text()='Details for Group: \" + GROUP_NAME + \"']\"));\n\n        findElementByLink(\"Group List\").click();\n        findElementById(GROUP_NAME + \".doDelete\").click();\n        handleAlert(\"Are you sure you want to delete the group \" + GROUP_NAME + \"?\");\n        assertElementDoesNotExist(By.id(GROUP_NAME));\n\n        findElementByLink(\"Users and Groups\").click();\n        findElementByLink(\"Configure Users\").click();\n        findElementById(\"user-\" + USER_NAME);\n        findElementById(\"users(\" + USER_NAME + \").doDelete\").click();\n        handleAlert(\"Are you sure you want to delete the user \" + USER_NAME + \"?\");\n        assertElementDoesNotExist(By.id(USER_NAME));\n    }\n\n}\n",
        "code_after_change": "/*******************************************************************************\n * This file is part of OpenNMS(R).\n *\n * Copyright (C) 2011-2014 The OpenNMS Group, Inc.\n * OpenNMS(R) is Copyright (C) 1999-2014 The OpenNMS Group, Inc.\n *\n * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n *\n * OpenNMS(R) is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published\n * by the Free Software Foundation, either version 3 of the License,\n * or (at your option) any later version.\n *\n * OpenNMS(R) is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with OpenNMS(R).  If not, see:\n *      http://www.gnu.org/licenses/\n *\n * For more information contact:\n *     OpenNMS(R) Licensing <license@opennms.org>\n *     http://www.opennms.org/\n *     http://www.opennms.com/\n *******************************************************************************/\n\npackage org.opennms.smoketest;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n\nimport java.time.Duration;\nimport java.time.temporal.ChronoUnit;\nimport java.util.List;\n\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.openqa.selenium.Alert;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebElement;\nimport org.openqa.selenium.support.ui.ExpectedConditions;\nimport org.openqa.selenium.support.ui.Select;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class UserIT extends OpenNMSSeleniumIT {\n    private static final Logger LOG = LoggerFactory.getLogger(UserIT.class);\n\n    @Before\n    public void setUp() throws Exception {\n        driver.get(getBaseUrlInternal() + \"opennms/account/selfService/index.jsp\");\n    }\n\n    @Test\n    public void testExpectedTextAndLinksArePresent() throws Exception {\n        final List<WebElement> headers = driver.findElements(By.xpath(\"//div[@class='card-header']/span\"));\n        assertEquals(\"Account page should have 2 panels\", 2, headers.size());\n        assertEquals(\"Account page should have \\\"User Account Self-Service\\\" panel\", \"User Account Self-Service\", headers.get(0).getText());\n        assertEquals(\"Account page should have \\\"User Account Self-Service Options\\\" panel\", \"Account Self-Service Options\", headers.get(1).getText());\n    }\n\n    @Test\n    public void testSubmitWithWrongPassword() throws InterruptedException {\n        driver.findElement(By.linkText(\"Change Password\")).click();\n        enterText(By.cssSelector(\"input[type=password][name=oldpass]\"), \"12345\");\n        enterText(By.cssSelector(\"input[type=password][name=pass1]\"), \"23456\");\n        enterText(By.cssSelector(\"input[type=password][name=pass2]\"), \"34567\");\n        driver.findElement(By.cssSelector(\"button[type=submit]\")).click();\n\n        try {\n            final Alert alert = wait.until(ExpectedConditions.alertIsPresent());\n            alert.dismiss();\n        } catch (final Exception e) {\n            LOG.debug(\"Got an exception waiting for a 'wrong password' alert.\", e);\n            throw e;\n        }\n    }\n\n    @Test\n    public void testUsersAndGroups() throws Exception {\n        adminPage();\n        findElementByLink(\"Configure Users, Groups and On-Call Roles\").click();\n        findElementByLink(\"Configure Users\").click();\n        findElementByLink(\"Add new user\").click();\n\n        enterText(By.id(\"userID\"), USER_NAME);\n        enterText(By.id(\"pass1\"), \"SmokeTestPassword\");\n        enterText(By.id(\"pass2\"), \"SmokeTestPassword\");\n        findElementByXpath(\"//button[@type='submit' and text()='OK']\").click();\n\n        findElementById(\"saveUserButton\").click();\n        findElementById(\"users(\" + USER_NAME + \").doDetails\");\n\n        adminPage();\n        findElementByLink(\"Configure Users, Groups and On-Call Roles\").click();\n        findElementByLink(\"Configure Groups\").click();\n        findElementByLink(\"Add new group\").click();\n\n        enterText(By.id(\"groupName\"), GROUP_NAME);\n        enterText(By.id(\"groupComment\"), \"Test\");\n        findElementByXpath(\"//button[@type='submit' and text()='OK']\").click();\n\n        final Select select = new Select(findElementByName(\"availableUsers\"));\n        select.selectByVisibleText(USER_NAME);\n        findElementById(\"users.doAdd\").click();\n\n        findElementByName(\"finish\").click();\n\n        findElementByLink(GROUP_NAME).click();\n        driver.findElement(By.xpath(\"//div[@class='card-header']/span[text()='Details for Group: \" + GROUP_NAME + \"']\"));\n\n        findElementByLink(\"Group List\").click();\n        findElementById(GROUP_NAME + \".doDelete\").click();\n        handleAlert(\"Are you sure you want to delete the group \" + GROUP_NAME + \"?\");\n        assertElementDoesNotExist(By.id(GROUP_NAME));\n\n        findElementByLink(\"Users and Groups\").click();\n        findElementByLink(\"Configure Users\").click();\n        findElementById(\"user-\" + USER_NAME);\n        findElementById(\"users(\" + USER_NAME + \").doDelete\").click();\n        handleAlert(\"Are you sure you want to delete the user \" + USER_NAME + \"?\");\n        assertElementDoesNotExist(By.id(USER_NAME));\n    }\n\n    @Test\n    public void testInvalidUserIds() {\n        testInvalidUserId(\"John<b>Doe</b>\",true);\n        testInvalidUserId(\"Jane'Doe'\",true);\n        testInvalidUserId(\"John&Doe\",true);\n        testInvalidUserId(\"Jane\\\"\\\"Doe\",true);\n    }\n\n    @Test\n    public void testValidUserIds() {\n        testInvalidUserId(\"John-Doe\",false);\n        testInvalidUserId(\"Jane/Doe\",false);\n        testInvalidUserId(\"John.Doe\",false);\n        testInvalidUserId(\"Jane#Doe\", false);\n        testInvalidUserId(\"John@D\u00f6e.com\", false);\n        testInvalidUserId(\"JohnDo\u00e9\", false);\n    }\n\n    @Test\n    public void testInvalidGroupIds() {\n        testInvalidGroupId(\"John<b>Doe</b>\",true);\n        testInvalidGroupId(\"Jane'Doe'\",true);\n        testInvalidGroupId(\"John&Doe\",true);\n        testInvalidGroupId(\"Jane\\\"\\\"Doe\",true);\n    }\n\n    @Test\n    public void testValidGroupIds() {\n        testInvalidGroupId(\"John-Doe\",false);\n        testInvalidGroupId(\"Jane/Doe\",false);\n        testInvalidGroupId(\"John.Doe\",false);\n        testInvalidGroupId(\"Jane#Doe\", false);\n        testInvalidGroupId(\"John@D\u00f6e.com\", false);\n        testInvalidGroupId(\"JohnDo\u00e9\", false);\n    }\n\n    public void testInvalidUserId(final String userId, final boolean mustFail) {\n        adminPage();\n        findElementByLink(\"Configure Users, Groups and On-Call Roles\").click();\n        findElementByLink(\"Configure Users\").click();\n        findElementByLink(\"Add new user\").click();\n\n        enterText(By.id(\"userID\"), userId);\n        enterText(By.id(\"pass1\"), \"SmokeTestPassword\");\n        enterText(By.id(\"pass2\"), \"SmokeTestPassword\");\n        findElementByXpath(\"//button[@type='submit' and text()='OK']\").click();\n\n        if (mustFail) {\n            try {\n                final Alert alert = wait.withTimeout(Duration.of(5, ChronoUnit.SECONDS)).until(ExpectedConditions.alertIsPresent());\n                alert.dismiss();\n            } catch (final Exception e) {\n                LOG.debug(\"Got an exception waiting for a 'invalid user ID' alert.\", e);\n                throw e;\n            }\n        } else {\n            wait.until(ExpectedConditions.elementToBeClickable(By.name(\"finish\")));\n        }\n    }\n\n    public void testInvalidGroupId(final String groupId, final boolean mustFail) {\n        adminPage();\n        findElementByLink(\"Configure Users, Groups and On-Call Roles\").click();\n        findElementByLink(\"Configure Groups\").click();\n        findElementByLink(\"Add new group\").click();\n\n        enterText(By.id(\"groupName\"), groupId);\n        enterText(By.id(\"groupComment\"), \"SmokeTestComment\");\n        findElementByXpath(\"//button[@type='submit' and text()='OK']\").click();\n\n        if (mustFail) {\n            try {\n                final Alert alert = wait.withTimeout(Duration.of(5, ChronoUnit.SECONDS)).until(ExpectedConditions.alertIsPresent());\n                alert.dismiss();\n            } catch (final Exception e) {\n                LOG.debug(\"Got an exception waiting for a 'invalid group ID' alert.\", e);\n                throw e;\n            }\n        } else {\n            wait.until(ExpectedConditions.elementToBeClickable(By.name(\"finish\")));\n        }\n    }\n}\n",
        "patch": "@@ -29,7 +29,10 @@\n package org.opennms.smoketest;\n \n import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n \n+import java.time.Duration;\n+import java.time.temporal.ChronoUnit;\n import java.util.List;\n \n import org.junit.Before;\n@@ -121,4 +124,86 @@ public void testUsersAndGroups() throws Exception {\n         assertElementDoesNotExist(By.id(USER_NAME));\n     }\n \n+    @Test\n+    public void testInvalidUserIds() {\n+        testInvalidUserId(\"John<b>Doe</b>\",true);\n+        testInvalidUserId(\"Jane'Doe'\",true);\n+        testInvalidUserId(\"John&Doe\",true);\n+        testInvalidUserId(\"Jane\\\"\\\"Doe\",true);\n+    }\n+\n+    @Test\n+    public void testValidUserIds() {\n+        testInvalidUserId(\"John-Doe\",false);\n+        testInvalidUserId(\"Jane/Doe\",false);\n+        testInvalidUserId(\"John.Doe\",false);\n+        testInvalidUserId(\"Jane#Doe\", false);\n+        testInvalidUserId(\"John@D\u00f6e.com\", false);\n+        testInvalidUserId(\"JohnDo\u00e9\", false);\n+    }\n+\n+    @Test\n+    public void testInvalidGroupIds() {\n+        testInvalidGroupId(\"John<b>Doe</b>\",true);\n+        testInvalidGroupId(\"Jane'Doe'\",true);\n+        testInvalidGroupId(\"John&Doe\",true);\n+        testInvalidGroupId(\"Jane\\\"\\\"Doe\",true);\n+    }\n+\n+    @Test\n+    public void testValidGroupIds() {\n+        testInvalidGroupId(\"John-Doe\",false);\n+        testInvalidGroupId(\"Jane/Doe\",false);\n+        testInvalidGroupId(\"John.Doe\",false);\n+        testInvalidGroupId(\"Jane#Doe\", false);\n+        testInvalidGroupId(\"John@D\u00f6e.com\", false);\n+        testInvalidGroupId(\"JohnDo\u00e9\", false);\n+    }\n+\n+    public void testInvalidUserId(final String userId, final boolean mustFail) {\n+        adminPage();\n+        findElementByLink(\"Configure Users, Groups and On-Call Roles\").click();\n+        findElementByLink(\"Configure Users\").click();\n+        findElementByLink(\"Add new user\").click();\n+\n+        enterText(By.id(\"userID\"), userId);\n+        enterText(By.id(\"pass1\"), \"SmokeTestPassword\");\n+        enterText(By.id(\"pass2\"), \"SmokeTestPassword\");\n+        findElementByXpath(\"//button[@type='submit' and text()='OK']\").click();\n+\n+        if (mustFail) {\n+            try {\n+                final Alert alert = wait.withTimeout(Duration.of(5, ChronoUnit.SECONDS)).until(ExpectedConditions.alertIsPresent());\n+                alert.dismiss();\n+            } catch (final Exception e) {\n+                LOG.debug(\"Got an exception waiting for a 'invalid user ID' alert.\", e);\n+                throw e;\n+            }\n+        } else {\n+            wait.until(ExpectedConditions.elementToBeClickable(By.name(\"finish\")));\n+        }\n+    }\n+\n+    public void testInvalidGroupId(final String groupId, final boolean mustFail) {\n+        adminPage();\n+        findElementByLink(\"Configure Users, Groups and On-Call Roles\").click();\n+        findElementByLink(\"Configure Groups\").click();\n+        findElementByLink(\"Add new group\").click();\n+\n+        enterText(By.id(\"groupName\"), groupId);\n+        enterText(By.id(\"groupComment\"), \"SmokeTestComment\");\n+        findElementByXpath(\"//button[@type='submit' and text()='OK']\").click();\n+\n+        if (mustFail) {\n+            try {\n+                final Alert alert = wait.withTimeout(Duration.of(5, ChronoUnit.SECONDS)).until(ExpectedConditions.alertIsPresent());\n+                alert.dismiss();\n+            } catch (final Exception e) {\n+                LOG.debug(\"Got an exception waiting for a 'invalid group ID' alert.\", e);\n+                throw e;\n+            }\n+        } else {\n+            wait.until(ExpectedConditions.elementToBeClickable(By.name(\"finish\")));\n+        }\n+    }\n }",
        "function_modified_lines": {
            "added": [
                "import static org.junit.Assert.assertTrue;\n",
                "import java.time.Duration;\n",
                "import java.time.temporal.ChronoUnit;\n"
            ],
            "deleted": []
        },
        "lang": "Java",
        "cwe": [
            "CWE-79"
        ],
        "cve_description": "In OpenNMS Horizon, versions opennms-1-0-stable through opennms-27.1.0-1; OpenNMS Meridian, versions meridian-foundation-2015.1.0-1 through meridian-foundation-2019.1.18-1; meridian-foundation-2020.1.0-1 through meridian-foundation-2020.1.6-1 are vulnerable to Stored Cross-Site Scripting since there is no validation on the input being sent to the `name` parameter in `noticeWizard` endpoint. Due to this flaw an authenticated attacker could inject arbitrary script and trick other admin users into downloading malicious files.",
        "id": 12052
    },
    {
        "cve_id": "CVE-2021-25932",
        "code_before_change": "{\n        String userID = request.getParameter(\"userID\");\n        String newID = request.getParameter(\"newID\");\n\n        // now save to the xml file\n        try {\n            UserManager userFactory = UserFactory.getInstance();\n            userFactory.renameUser(userID, newID);\n        } catch (Throwable e) {\n            throw new ServletException(\"Error renaming user \" + userID + \" to \" + newID, e);\n        }\n\n        response.sendRedirect(\"list.jsp\");\n    }",
        "code_after_change": "{\n        String userID = request.getParameter(\"userID\");\n        String newID = request.getParameter(\"newID\");\n\n        if (newID != null && newID.matches(\".*[&<>\\\"`']+.*\")) {\n            throw new ServletException(\"User ID must not contain any HTML markup.\");\n        }\n\n        // now save to the xml file\n        try {\n            UserManager userFactory = UserFactory.getInstance();\n            userFactory.renameUser(userID, newID);\n        } catch (Throwable e) {\n            throw new ServletException(\"Error renaming user \" + userID + \" to \" + newID, e);\n        }\n\n        response.sendRedirect(\"list.jsp\");\n    }",
        "patch": "@@ -60,6 +60,10 @@ public void doPost(HttpServletRequest request, HttpServletResponse response) thr\n         String userID = request.getParameter(\"userID\");\n         String newID = request.getParameter(\"newID\");\n \n+        if (newID != null && newID.matches(\".*[&<>\\\"`']+.*\")) {\n+            throw new ServletException(\"User ID must not contain any HTML markup.\");\n+        }\n+\n         // now save to the xml file\n         try {\n             UserManager userFactory = UserFactory.getInstance();",
        "function_modified_lines": {
            "added": [
                "        if (newID != null && newID.matches(\".*[&<>\\\"`']+.*\")) {\n",
                "            throw new ServletException(\"User ID must not contain any HTML markup.\");\n",
                "        }\n",
                "\n"
            ],
            "deleted": []
        },
        "lang": "Java",
        "cwe": [
            "CWE-79"
        ],
        "cve_description": "In OpenNMS Horizon, versions opennms-1-0-stable through opennms-27.1.0-1; OpenNMS Meridian, versions meridian-foundation-2015.1.0-1 through meridian-foundation-2019.1.18-1; meridian-foundation-2020.1.0-1 through meridian-foundation-2020.1.6-1 are vulnerable to Stored Cross-Site Scripting, since the function `validateFormInput()` performs improper validation checks on the input sent to the `userID` parameter. Due to this flaw an attacker could inject an arbitrary script which will be stored in the database.",
        "id": 12062
    },
    {
        "cve_id": "CVE-2021-25932",
        "code_before_change": "{    \n                \n        String groupName = request.getParameter(\"groupName\");\n        String groupComment = request.getParameter(\"groupComment\");\n        if (groupComment == null) {\n            groupComment = \"\";\n        }\n\n        boolean hasGroup = false;\n        try {\n            hasGroup = m_groupRepository.groupExists(groupName);\n        } catch (Throwable e) {\n            throw new ServletException(\"Can't determine if group \" + groupName + \" already exists in groups.xml.\", e);\n        }\n        \n        if (hasGroup) {\n            return new ModelAndView(\"admin/userGroupView/groups/newGroup\", \"action\", \"redo\");            \n        } else {\n            WebGroup newGroup = new WebGroup();\n            newGroup.setName(groupName);\n            newGroup.setComments(groupComment);\n            \n            return editGroup(request, newGroup);\n        }\n    }",
        "code_after_change": "{    \n                \n        String groupName = request.getParameter(\"groupName\");\n        String groupComment = request.getParameter(\"groupComment\");\n        if (groupComment == null) {\n            groupComment = \"\";\n        }\n\n        if (groupName != null && groupName.matches(\".*[&<>\\\"`']+.*\")) {\n            throw new ServletException(\"Group ID must not contain any HTML markup.\");\n        }\n\n        if (groupComment != null && groupComment.matches(\".*[&<>\\\"`']+.*\")) {\n            throw new ServletException(\"Group comment must not contain any HTML markup.\");\n        }\n\n        boolean hasGroup = false;\n        try {\n            hasGroup = m_groupRepository.groupExists(groupName);\n        } catch (Throwable e) {\n            throw new ServletException(\"Can't determine if group \" + groupName + \" already exists in groups.xml.\", e);\n        }\n        \n        if (hasGroup) {\n            return new ModelAndView(\"admin/userGroupView/groups/newGroup\", \"action\", \"redo\");            \n        } else {\n            WebGroup newGroup = new WebGroup();\n            newGroup.setName(groupName);\n            newGroup.setComments(groupComment);\n            \n            return editGroup(request, newGroup);\n        }\n    }",
        "patch": "@@ -151,7 +151,11 @@ private ModelAndView renameGroup(HttpServletRequest request, HttpServletResponse\n         \n         String oldName = request.getParameter(\"groupName\");\n         String newName = request.getParameter(\"newName\");\n-        \n+\n+        if (newName != null && newName.matches(\".*[&<>\\\"`']+.*\")) {\n+            throw new ServletException(\"Group ID must not contain any HTML markup.\");\n+        }\n+\n         if (StringUtils.hasText(oldName) && StringUtils.hasText(newName)) {\n             m_groupRepository.renameGroup(oldName, newName);\n         }\n@@ -312,6 +316,14 @@ private ModelAndView addGroup(HttpServletRequest request, HttpServletResponse re\n             groupComment = \"\";\n         }\n \n+        if (groupName != null && groupName.matches(\".*[&<>\\\"`']+.*\")) {\n+            throw new ServletException(\"Group ID must not contain any HTML markup.\");\n+        }\n+\n+        if (groupComment != null && groupComment.matches(\".*[&<>\\\"`']+.*\")) {\n+            throw new ServletException(\"Group comment must not contain any HTML markup.\");\n+        }\n+\n         boolean hasGroup = false;\n         try {\n             hasGroup = m_groupRepository.groupExists(groupName);",
        "function_modified_lines": {
            "added": [
                "        if (groupName != null && groupName.matches(\".*[&<>\\\"`']+.*\")) {\n",
                "            throw new ServletException(\"Group ID must not contain any HTML markup.\");\n",
                "        }\n",
                "\n",
                "        if (groupComment != null && groupComment.matches(\".*[&<>\\\"`']+.*\")) {\n",
                "            throw new ServletException(\"Group comment must not contain any HTML markup.\");\n",
                "        }\n",
                "\n"
            ],
            "deleted": []
        },
        "lang": "Java",
        "cwe": [
            "CWE-79"
        ],
        "cve_description": "In OpenNMS Horizon, versions opennms-1-0-stable through opennms-27.1.0-1; OpenNMS Meridian, versions meridian-foundation-2015.1.0-1 through meridian-foundation-2019.1.18-1; meridian-foundation-2020.1.0-1 through meridian-foundation-2020.1.6-1 are vulnerable to Stored Cross-Site Scripting, since the function `validateFormInput()` performs improper validation checks on the input sent to the `userID` parameter. Due to this flaw an attacker could inject an arbitrary script which will be stored in the database.",
        "id": 12063
    },
    {
        "cve_id": "CVE-2021-25933",
        "code_before_change": "{    \n                \n        String groupName = request.getParameter(\"groupName\");\n        String groupComment = request.getParameter(\"groupComment\");\n        if (groupComment == null) {\n            groupComment = \"\";\n        }\n\n        boolean hasGroup = false;\n        try {\n            hasGroup = m_groupRepository.groupExists(groupName);\n        } catch (Throwable e) {\n            throw new ServletException(\"Can't determine if group \" + groupName + \" already exists in groups.xml.\", e);\n        }\n        \n        if (hasGroup) {\n            return new ModelAndView(\"admin/userGroupView/groups/newGroup\", \"action\", \"redo\");            \n        } else {\n            WebGroup newGroup = new WebGroup();\n            newGroup.setName(groupName);\n            newGroup.setComments(groupComment);\n            \n            return editGroup(request, newGroup);\n        }\n    }",
        "code_after_change": "{    \n                \n        String groupName = request.getParameter(\"groupName\");\n        String groupComment = request.getParameter(\"groupComment\");\n        if (groupComment == null) {\n            groupComment = \"\";\n        }\n\n        if (groupName != null && groupName.matches(\".*[&<>\\\"`']+.*\")) {\n            throw new ServletException(\"Group ID must not contain any HTML markup.\");\n        }\n\n        if (groupComment != null && groupComment.matches(\".*[&<>\\\"`']+.*\")) {\n            throw new ServletException(\"Group comment must not contain any HTML markup.\");\n        }\n\n        boolean hasGroup = false;\n        try {\n            hasGroup = m_groupRepository.groupExists(groupName);\n        } catch (Throwable e) {\n            throw new ServletException(\"Can't determine if group \" + groupName + \" already exists in groups.xml.\", e);\n        }\n        \n        if (hasGroup) {\n            return new ModelAndView(\"admin/userGroupView/groups/newGroup\", \"action\", \"redo\");            \n        } else {\n            WebGroup newGroup = new WebGroup();\n            newGroup.setName(groupName);\n            newGroup.setComments(groupComment);\n            \n            return editGroup(request, newGroup);\n        }\n    }",
        "patch": "@@ -151,7 +151,11 @@ private ModelAndView renameGroup(HttpServletRequest request, HttpServletResponse\n         \n         String oldName = request.getParameter(\"groupName\");\n         String newName = request.getParameter(\"newName\");\n-        \n+\n+        if (newName != null && newName.matches(\".*[&<>\\\"`']+.*\")) {\n+            throw new ServletException(\"Group ID must not contain any HTML markup.\");\n+        }\n+\n         if (StringUtils.hasText(oldName) && StringUtils.hasText(newName)) {\n             m_groupRepository.renameGroup(oldName, newName);\n         }\n@@ -312,6 +316,14 @@ private ModelAndView addGroup(HttpServletRequest request, HttpServletResponse re\n             groupComment = \"\";\n         }\n \n+        if (groupName != null && groupName.matches(\".*[&<>\\\"`']+.*\")) {\n+            throw new ServletException(\"Group ID must not contain any HTML markup.\");\n+        }\n+\n+        if (groupComment != null && groupComment.matches(\".*[&<>\\\"`']+.*\")) {\n+            throw new ServletException(\"Group comment must not contain any HTML markup.\");\n+        }\n+\n         boolean hasGroup = false;\n         try {\n             hasGroup = m_groupRepository.groupExists(groupName);",
        "function_modified_lines": {
            "added": [
                "        if (groupName != null && groupName.matches(\".*[&<>\\\"`']+.*\")) {\n",
                "            throw new ServletException(\"Group ID must not contain any HTML markup.\");\n",
                "        }\n",
                "\n",
                "        if (groupComment != null && groupComment.matches(\".*[&<>\\\"`']+.*\")) {\n",
                "            throw new ServletException(\"Group comment must not contain any HTML markup.\");\n",
                "        }\n",
                "\n"
            ],
            "deleted": []
        },
        "lang": "Java",
        "cwe": [
            "CWE-79"
        ],
        "cve_description": "In OpenNMS Horizon, versions opennms-1-0-stable through opennms-27.1.0-1; OpenNMS Meridian, versions meridian-foundation-2015.1.0-1 through meridian-foundation-2019.1.18-1; meridian-foundation-2020.1.0-1 through meridian-foundation-2020.1.6-1 are vulnerable to Stored Cross-Site Scripting, since the function `validateFormInput()` performs improper validation checks on the input sent to the `groupName` and `groupComment` parameters. Due to this flaw, an authenticated attacker could inject arbitrary script and trick other admin users into downloading malicious files which can cause severe damage to the organization using opennms.",
        "id": 12048
    },
    {
        "cve_id": "CVE-2021-25934",
        "code_before_change": "{\n        try {\n            UserFactory.init();\n        } catch (Throwable e) {\n            throw new ServletException(\"AddNewUserServlet: Error initialising user factory.\" + e);\n        }\n        UserManager userFactory = UserFactory.getInstance();\n\n        String userID = request.getParameter(\"userID\");\n        String password = request.getParameter(\"pass1\");\n\n        boolean hasUser = false;\n        try {\n            hasUser = userFactory.hasUser(userID);\n        } catch (Throwable e) {\n            throw new ServletException(\"can't determine if user \" + userID + \" already exists in users.xml.\", e);\n        }\n\n        if (hasUser) {\n            RequestDispatcher dispatcher = this.getServletContext().getRequestDispatcher(\"/admin/userGroupView/users/newUser.jsp?action=redo\");\n            dispatcher.forward(request, response);\n        } else {\n            final Password pass = new Password();\n            pass.setEncryptedPassword(UserFactory.getInstance().encryptedPassword(password, true));\n            pass.setSalt(true);\n\n            final User newUser = new User();\n            newUser.setUserId(userID);\n            newUser.setPassword(pass);\n\n            final HttpSession userSession = request.getSession(false);\n            userSession.setAttribute(\"user.modifyUser.jsp\", newUser);\n\n            // forward the request for proper display\n            RequestDispatcher dispatcher = this.getServletContext().getRequestDispatcher(\"/admin/userGroupView/users/modifyUser.jsp\");\n            dispatcher.forward(request, response);\n        }\n    }",
        "code_after_change": "{\n        try {\n            UserFactory.init();\n        } catch (Throwable e) {\n            throw new ServletException(\"AddNewUserServlet: Error initialising user factory.\" + e);\n        }\n        UserManager userFactory = UserFactory.getInstance();\n\n        String userID = request.getParameter(\"userID\");\n\n        if (userID != null && userID.matches(\".*[&<>\\\"`']+.*\")) {\n            throw new ServletException(\"User ID must not contain any HTML markup.\");\n        }\n\n        String password = request.getParameter(\"pass1\");\n\n        boolean hasUser = false;\n        try {\n            hasUser = userFactory.hasUser(userID);\n        } catch (Throwable e) {\n            throw new ServletException(\"can't determine if user \" + userID + \" already exists in users.xml.\", e);\n        }\n\n        if (hasUser) {\n            RequestDispatcher dispatcher = this.getServletContext().getRequestDispatcher(\"/admin/userGroupView/users/newUser.jsp?action=redo\");\n            dispatcher.forward(request, response);\n        } else {\n            final Password pass = new Password();\n            pass.setEncryptedPassword(UserFactory.getInstance().encryptedPassword(password, true));\n            pass.setSalt(true);\n\n            final User newUser = new User();\n            newUser.setUserId(userID);\n            newUser.setPassword(pass);\n\n            final HttpSession userSession = request.getSession(false);\n            userSession.setAttribute(\"user.modifyUser.jsp\", newUser);\n\n            // forward the request for proper display\n            RequestDispatcher dispatcher = this.getServletContext().getRequestDispatcher(\"/admin/userGroupView/users/modifyUser.jsp\");\n            dispatcher.forward(request, response);\n        }\n    }",
        "patch": "@@ -69,6 +69,11 @@ public void doPost(HttpServletRequest request, HttpServletResponse response) thr\n         UserManager userFactory = UserFactory.getInstance();\n \n         String userID = request.getParameter(\"userID\");\n+\n+        if (userID != null && userID.matches(\".*[&<>\\\"`']+.*\")) {\n+            throw new ServletException(\"User ID must not contain any HTML markup.\");\n+        }\n+\n         String password = request.getParameter(\"pass1\");\n \n         boolean hasUser = false;",
        "function_modified_lines": {
            "added": [
                "\n",
                "        if (userID != null && userID.matches(\".*[&<>\\\"`']+.*\")) {\n",
                "            throw new ServletException(\"User ID must not contain any HTML markup.\");\n",
                "        }\n",
                "\n"
            ],
            "deleted": []
        },
        "lang": "Java",
        "cwe": [
            "CWE-79"
        ],
        "cve_description": "In OpenNMS Horizon, versions opennms-18.0.0-1 through opennms-27.1.0-1; OpenNMS Meridian, versions meridian-foundation-2015.1.0-1 through meridian-foundation-2019.1.18-1; meridian-foundation-2020.1.0-1 through meridian-foundation-2020.1.7-1 are vulnerable to Stored Cross-Site Scripting, since the function `createRequisitionedNode()` does not perform any validation checks on the input sent to the `node-label` parameter. Due to this flaw an attacker could inject an arbitrary script which will be stored in the database.",
        "id": 12069
    },
    {
        "cve_id": "CVE-2021-25935",
        "code_before_change": "{\n        String userID = request.getParameter(\"userID\");\n        String newID = request.getParameter(\"newID\");\n\n        // now save to the xml file\n        try {\n            UserManager userFactory = UserFactory.getInstance();\n            userFactory.renameUser(userID, newID);\n        } catch (Throwable e) {\n            throw new ServletException(\"Error renaming user \" + userID + \" to \" + newID, e);\n        }\n\n        response.sendRedirect(\"list.jsp\");\n    }",
        "code_after_change": "{\n        String userID = request.getParameter(\"userID\");\n        String newID = request.getParameter(\"newID\");\n\n        if (newID != null && newID.matches(\".*[&<>\\\"`']+.*\")) {\n            throw new ServletException(\"User ID must not contain any HTML markup.\");\n        }\n\n        // now save to the xml file\n        try {\n            UserManager userFactory = UserFactory.getInstance();\n            userFactory.renameUser(userID, newID);\n        } catch (Throwable e) {\n            throw new ServletException(\"Error renaming user \" + userID + \" to \" + newID, e);\n        }\n\n        response.sendRedirect(\"list.jsp\");\n    }",
        "patch": "@@ -60,6 +60,10 @@ public void doPost(HttpServletRequest request, HttpServletResponse response) thr\n         String userID = request.getParameter(\"userID\");\n         String newID = request.getParameter(\"newID\");\n \n+        if (newID != null && newID.matches(\".*[&<>\\\"`']+.*\")) {\n+            throw new ServletException(\"User ID must not contain any HTML markup.\");\n+        }\n+\n         // now save to the xml file\n         try {\n             UserManager userFactory = UserFactory.getInstance();",
        "function_modified_lines": {
            "added": [
                "        if (newID != null && newID.matches(\".*[&<>\\\"`']+.*\")) {\n",
                "            throw new ServletException(\"User ID must not contain any HTML markup.\");\n",
                "        }\n",
                "\n"
            ],
            "deleted": []
        },
        "lang": "Java",
        "cwe": [
            "CWE-79"
        ],
        "cve_description": "In OpenNMS Horizon, versions opennms-17.0.0-1 through opennms-27.1.0-1; OpenNMS Meridian, versions meridian-foundation-2015.1.0-1 through meridian-foundation-2019.1.18-1; meridian-foundation-2020.1.0-1 through meridian-foundation-2020.1.7-1 are vulnerable to Stored Cross-Site Scripting, since the function `add()` performs improper validation checks on the input sent to the `foreign-source` parameter. Due to this flaw an attacker could bypass the existing regex validation and inject an arbitrary script which will be stored in the database.",
        "id": 12074
    },
    {
        "cve_id": "CVE-2021-25935",
        "code_before_change": "{    \n                \n        String groupName = request.getParameter(\"groupName\");\n        String groupComment = request.getParameter(\"groupComment\");\n        if (groupComment == null) {\n            groupComment = \"\";\n        }\n\n        boolean hasGroup = false;\n        try {\n            hasGroup = m_groupRepository.groupExists(groupName);\n        } catch (Throwable e) {\n            throw new ServletException(\"Can't determine if group \" + groupName + \" already exists in groups.xml.\", e);\n        }\n        \n        if (hasGroup) {\n            return new ModelAndView(\"admin/userGroupView/groups/newGroup\", \"action\", \"redo\");            \n        } else {\n            WebGroup newGroup = new WebGroup();\n            newGroup.setName(groupName);\n            newGroup.setComments(groupComment);\n            \n            return editGroup(request, newGroup);\n        }\n    }",
        "code_after_change": "{    \n                \n        String groupName = request.getParameter(\"groupName\");\n        String groupComment = request.getParameter(\"groupComment\");\n        if (groupComment == null) {\n            groupComment = \"\";\n        }\n\n        if (groupName != null && groupName.matches(\".*[&<>\\\"`']+.*\")) {\n            throw new ServletException(\"Group ID must not contain any HTML markup.\");\n        }\n\n        if (groupComment != null && groupComment.matches(\".*[&<>\\\"`']+.*\")) {\n            throw new ServletException(\"Group comment must not contain any HTML markup.\");\n        }\n\n        boolean hasGroup = false;\n        try {\n            hasGroup = m_groupRepository.groupExists(groupName);\n        } catch (Throwable e) {\n            throw new ServletException(\"Can't determine if group \" + groupName + \" already exists in groups.xml.\", e);\n        }\n        \n        if (hasGroup) {\n            return new ModelAndView(\"admin/userGroupView/groups/newGroup\", \"action\", \"redo\");            \n        } else {\n            WebGroup newGroup = new WebGroup();\n            newGroup.setName(groupName);\n            newGroup.setComments(groupComment);\n            \n            return editGroup(request, newGroup);\n        }\n    }",
        "patch": "@@ -151,7 +151,11 @@ private ModelAndView renameGroup(HttpServletRequest request, HttpServletResponse\n         \n         String oldName = request.getParameter(\"groupName\");\n         String newName = request.getParameter(\"newName\");\n-        \n+\n+        if (newName != null && newName.matches(\".*[&<>\\\"`']+.*\")) {\n+            throw new ServletException(\"Group ID must not contain any HTML markup.\");\n+        }\n+\n         if (StringUtils.hasText(oldName) && StringUtils.hasText(newName)) {\n             m_groupRepository.renameGroup(oldName, newName);\n         }\n@@ -312,6 +316,14 @@ private ModelAndView addGroup(HttpServletRequest request, HttpServletResponse re\n             groupComment = \"\";\n         }\n \n+        if (groupName != null && groupName.matches(\".*[&<>\\\"`']+.*\")) {\n+            throw new ServletException(\"Group ID must not contain any HTML markup.\");\n+        }\n+\n+        if (groupComment != null && groupComment.matches(\".*[&<>\\\"`']+.*\")) {\n+            throw new ServletException(\"Group comment must not contain any HTML markup.\");\n+        }\n+\n         boolean hasGroup = false;\n         try {\n             hasGroup = m_groupRepository.groupExists(groupName);",
        "function_modified_lines": {
            "added": [
                "        if (groupName != null && groupName.matches(\".*[&<>\\\"`']+.*\")) {\n",
                "            throw new ServletException(\"Group ID must not contain any HTML markup.\");\n",
                "        }\n",
                "\n",
                "        if (groupComment != null && groupComment.matches(\".*[&<>\\\"`']+.*\")) {\n",
                "            throw new ServletException(\"Group comment must not contain any HTML markup.\");\n",
                "        }\n",
                "\n"
            ],
            "deleted": []
        },
        "lang": "Java",
        "cwe": [
            "CWE-79"
        ],
        "cve_description": "In OpenNMS Horizon, versions opennms-17.0.0-1 through opennms-27.1.0-1; OpenNMS Meridian, versions meridian-foundation-2015.1.0-1 through meridian-foundation-2019.1.18-1; meridian-foundation-2020.1.0-1 through meridian-foundation-2020.1.7-1 are vulnerable to Stored Cross-Site Scripting, since the function `add()` performs improper validation checks on the input sent to the `foreign-source` parameter. Due to this flaw an attacker could bypass the existing regex validation and inject an arbitrary script which will be stored in the database.",
        "id": 12075
    },
    {
        "cve_id": "CVE-2023-31544",
        "code_before_change": "{\n\n        StringBuffer result = new StringBuffer();\n        result.append(\"<p><b>\").append(CmsClientStringUtil.shortenString(infoBean.getTitle(), 70)).append(\"</b></p>\");\n        if (infoBean.hasAdditionalInfo()) {\n            for (CmsAdditionalInfoBean additionalInfo : infoBean.getAdditionalInfo()) {\n                result.append(\"<p>\").append(additionalInfo.getName()).append(\":&nbsp;\");\n                // shorten the value to max 45 characters\n                result.append(CmsClientStringUtil.shortenString(additionalInfo.getValue(), 45)).append(\"</p>\");\n            }\n        }\n        return result.toString();\n    }",
        "code_after_change": "{\n\n        Element root = DOM.createElement(\"div\");\n        appendDom(appendDom(root, \"p\"), \"b\").setInnerText(CmsClientStringUtil.shortenString(infoBean.getTitle(), 70));\n        if (infoBean.hasAdditionalInfo()) {\n            for (CmsAdditionalInfoBean additionalInfo : infoBean.getAdditionalInfo()) {\n                appendDom(root, \"p\").setInnerText(\n                    additionalInfo.getName()\n                        + \":\\u00a0\"\n                        + CmsClientStringUtil.shortenString(additionalInfo.getValue(), 45));\n            }\n        }\n        return root.getInnerHTML();\n    }",
        "patch": "@@ -39,6 +39,8 @@\n import org.opencms.gwt.shared.CmsAdditionalInfoBean;\n import org.opencms.gwt.shared.CmsListInfoBean;\n \n+import com.google.gwt.dom.client.Element;\n+import com.google.gwt.user.client.DOM;\n import com.google.gwt.user.client.ui.HTML;\n \n /**\n@@ -155,6 +157,13 @@ public CmsResultItemWidget(CmsResultItemBean infoBean, boolean showPath) {\n \n     }\n \n+    private static Element appendDom(Element parent, String name) {\n+\n+        Element child = DOM.createElement(name);\n+        parent.appendChild(child);\n+        return child;\n+    }\n+\n     /**\n      * Gets the image tile.<p>\n      *\n@@ -213,16 +222,17 @@ protected void onDetach() {\n      */\n     private String generateTooltipHtml(CmsListInfoBean infoBean) {\n \n-        StringBuffer result = new StringBuffer();\n-        result.append(\"<p><b>\").append(CmsClientStringUtil.shortenString(infoBean.getTitle(), 70)).append(\"</b></p>\");\n+        Element root = DOM.createElement(\"div\");\n+        appendDom(appendDom(root, \"p\"), \"b\").setInnerText(CmsClientStringUtil.shortenString(infoBean.getTitle(), 70));\n         if (infoBean.hasAdditionalInfo()) {\n             for (CmsAdditionalInfoBean additionalInfo : infoBean.getAdditionalInfo()) {\n-                result.append(\"<p>\").append(additionalInfo.getName()).append(\":&nbsp;\");\n-                // shorten the value to max 45 characters\n-                result.append(CmsClientStringUtil.shortenString(additionalInfo.getValue(), 45)).append(\"</p>\");\n+                appendDom(root, \"p\").setInnerText(\n+                    additionalInfo.getName()\n+                        + \":\\u00a0\"\n+                        + CmsClientStringUtil.shortenString(additionalInfo.getValue(), 45));\n             }\n         }\n-        return result.toString();\n+        return root.getInnerHTML();\n     }\n \n     /**",
        "function_modified_lines": {
            "added": [
                "        Element root = DOM.createElement(\"div\");\n",
                "        appendDom(appendDom(root, \"p\"), \"b\").setInnerText(CmsClientStringUtil.shortenString(infoBean.getTitle(), 70));\n",
                "                appendDom(root, \"p\").setInnerText(\n",
                "                    additionalInfo.getName()\n",
                "                        + \":\\u00a0\"\n",
                "                        + CmsClientStringUtil.shortenString(additionalInfo.getValue(), 45));\n",
                "        return root.getInnerHTML();\n"
            ],
            "deleted": [
                "        StringBuffer result = new StringBuffer();\n",
                "        result.append(\"<p><b>\").append(CmsClientStringUtil.shortenString(infoBean.getTitle(), 70)).append(\"</b></p>\");\n",
                "                result.append(\"<p>\").append(additionalInfo.getName()).append(\":&nbsp;\");\n",
                "                // shorten the value to max 45 characters\n",
                "                result.append(CmsClientStringUtil.shortenString(additionalInfo.getValue(), 45)).append(\"</p>\");\n",
                "        return result.toString();\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-79"
        ],
        "cve_description": "A stored cross-site scripting (XSS) vulnerability in alkacon-OpenCMS v11.0.0.0 allows attackers to execute arbitrary web scripts or HTML via a crafted payload injected into the Title field under the Upload Image module.",
        "id": 12112
    },
    {
        "cve_id": "CVE-2020-36635",
        "code_before_change": "/**\r\n * The contents of this file are subject to the OpenMRS Public License\r\n * Version 1.0 (the \"License\"); you may not use this file except in\r\n * compliance with the License. You may obtain a copy of the License at\r\n * http://license.openmrs.org\r\n *\r\n * Software distributed under the License is distributed on an \"AS IS\"\r\n * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing rights and limitations\r\n * under the License.\r\n *\r\n * Copyright (C) OpenMRS, LLC.  All Rights Reserved.\r\n */\r\npackage org.openmrs.module.appointmentscheduling.validator;\r\n\r\nimport org.apache.commons.logging.Log;\r\nimport org.apache.commons.logging.LogFactory;\r\nimport org.openmrs.annotation.Handler;\r\nimport org.openmrs.module.appointmentscheduling.AppointmentType;\r\nimport org.openmrs.module.appointmentscheduling.api.AppointmentService;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.beans.factory.annotation.Qualifier;\r\nimport org.springframework.validation.Errors;\r\nimport org.springframework.validation.ValidationUtils;\r\nimport org.springframework.validation.Validator;\r\n\r\n/**\r\n * Validates attributes on the {@link AppointmentType} object.\r\n */\r\n@Handler(supports = { AppointmentType.class }, order = 50)\r\npublic class AppointmentTypeValidator implements Validator {\r\n\t\r\n\t/** Log for this class and subclasses */\r\n\tprotected final Log log = LogFactory.getLog(getClass());\r\n\t\r\n\t@Autowired\r\n\t@Qualifier(\"appointmentService\")\r\n\tprivate AppointmentService appointmentService;\r\n\t\r\n\t/**\r\n\t * Determines if the command object being submitted is a valid type\r\n\t * \r\n\t * @see org.springframework.validation.Validator#supports(java.lang.Class)\r\n\t */\r\n\t@SuppressWarnings(\"unchecked\")\r\n\tpublic boolean supports(Class c) {\r\n\t\treturn c.equals(AppointmentType.class);\r\n\t}\r\n\t\r\n\tpublic void setAppointmentService(AppointmentService appointmentService) {\r\n\t\tthis.appointmentService = appointmentService;\r\n\t}\r\n\t\r\n\tpublic AppointmentService getAppointmentService() {\r\n\t\treturn appointmentService;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Checks the form object for any inconsistencies/errors\r\n\t * \r\n\t * @see org.springframework.validation.Validator#validate(java.lang.Object,\r\n\t *      org.springframework.validation.Errors)\r\n\t * <strong>Should</strong> fail validation if name is null or empty or whitespace\r\n\t * <strong>Should</strong> pass validation if all required fields have proper values\r\n\t */\r\n\tpublic void validate(Object obj, Errors errors) {\r\n\t\tAppointmentType appointmentType = (AppointmentType) obj;\r\n\t\tif (appointmentType == null) {\r\n\t\t\terrors.rejectValue(\"appointmentType\", \"error.general\");\r\n\t\t} else {\r\n\t\t\tvalidateDurationField(errors, appointmentType);\r\n\t\t\tvalidateFieldName(errors, appointmentType);\r\n\t\t\tvalidateDescriptionField(errors, appointmentType.getDescription());\r\n\t\t}\r\n\t}\r\n\t\r\n\tprivate void validateFieldName(Errors errors, AppointmentType appointmentType) {\r\n\t\tValidationUtils.rejectIfEmptyOrWhitespace(errors, \"name\", \"error.name\");\r\n\t\tif (appointmentService.verifyDuplicatedAppointmentTypeName(appointmentType)) {\r\n\t\t\terrors.rejectValue(\"name\", \"appointmentscheduling.AppointmentType.nameDuplicated\");\r\n\t\t}\r\n\t\tif (verifyIfNameHasMoreThan100Characters(appointmentType.getName())) {\r\n\t\t\terrors.rejectValue(\"name\", \"appointmentscheduling.AppointmentType.longName.errorMessage\");\r\n\t\t}\r\n\t}\r\n\t\r\n\tprivate boolean verifyIfNameHasMoreThan100Characters(String appointmentName) {\r\n\t\tif (appointmentName != null) {\r\n\t\t\treturn (appointmentName.length() > 100) ? true : false;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\t\r\n\tprivate void validateDurationField(Errors errors, AppointmentType appointmentType) {\r\n\t\tValidationUtils.rejectIfEmpty(errors, \"duration\", \"appointmentscheduling.AppointmentType.durationEmpty\");\r\n\t\tif (appointmentType.getDuration() == null || appointmentType.getDuration() <= 0) {\r\n\t\t\terrors.rejectValue(\"duration\", \"appointmentscheduling.AppointmentType.duration.errorMessage\");\r\n\t\t}\r\n\t}\r\n\t\r\n\tprivate void validateDescriptionField(Errors errors, String description) {\r\n\t\tif (verifyIfDescriptionHasMoreThan1024Characters(description)) {\r\n\t\t\terrors.rejectValue(\"description\", \"appointmentscheduling.AppointmentType.description.errorMessage\");\r\n\t\t}\r\n\t}\r\n\t\r\n\tprivate boolean verifyIfDescriptionHasMoreThan1024Characters(String description) {\r\n\t\tif (description != null) {\r\n\t\t\treturn (description.length() > 1024) ? true : false;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\t\r\n}\r\n",
        "code_after_change": "{\r\n\t\r\n\t/** Log for this class and subclasses */\r\n\tprotected final Log log = LogFactory.getLog(getClass());\r\n\t\r\n\t@Autowired\r\n\t@Qualifier(\"appointmentService\")\r\n\tprivate AppointmentService appointmentService;\r\n\t\r\n\t/**\r\n\t * Determines if the command object being submitted is a valid type\r\n\t * \r\n\t * @see org.springframework.validation.Validator#supports(java.lang.Class)\r\n\t */\r\n\t@SuppressWarnings(\"unchecked\")\r\n\tpublic boolean supports(Class c) {\r\n\t\treturn c.equals(AppointmentType.class);\r\n\t}\r\n\t\r\n\tpublic void setAppointmentService(AppointmentService appointmentService) {\r\n\t\tthis.appointmentService = appointmentService;\r\n\t}\r\n\t\r\n\tpublic AppointmentService getAppointmentService() {\r\n\t\treturn appointmentService;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Checks the form object for any inconsistencies/errors\r\n\t * \r\n\t * @see org.springframework.validation.Validator#validate(java.lang.Object,\r\n\t *      org.springframework.validation.Errors)\r\n\t * <strong>Should</strong> fail validation if name is null or empty or whitespace\r\n\t * <strong>Should</strong> pass validation if all required fields have proper values\r\n\t */\r\n\tpublic void validate(Object obj, Errors errors) {\r\n\t\tAppointmentType appointmentType = (AppointmentType) obj;\r\n\t\tif (appointmentType == null) {\r\n\t\t\terrors.rejectValue(\"appointmentType\", \"error.general\");\r\n\t\t} else {\r\n\t\t\tvalidateDurationField(errors, appointmentType);\r\n\t\t\tvalidateFieldName(errors, appointmentType);\r\n\t\t\tvalidateDescriptionField(errors, appointmentType.getDescription());\r\n\t\t}\r\n\t}\r\n\t\r\n\tprivate void validateFieldName(Errors errors, AppointmentType appointmentType) {\r\n\t\tValidationUtils.rejectIfEmptyOrWhitespace(errors, \"name\", \"error.name\");\r\n\t\tif (appointmentService.verifyDuplicatedAppointmentTypeName(appointmentType)) {\r\n\t\t\terrors.rejectValue(\"name\", \"appointmentscheduling.AppointmentType.nameDuplicated\");\r\n\t\t}\r\n\t\tif (verifyIfNameHasMoreThan100Characters(appointmentType.getName())) {\r\n\t\t\terrors.rejectValue(\"name\", \"appointmentscheduling.AppointmentType.longName.errorMessage\");\r\n\t\t}\r\n\t\tif(verifyIfNameHasHtmlEncodableChars(appointmentType.getName())){\r\n\t\t\terrors.rejectValue(\"name\", \"appointmentscheduling.AppointmentType.unsafeName.errorMessage\");\r\n\t\t}\r\n\t}\r\n\t\r\n\tprivate boolean verifyIfNameHasMoreThan100Characters(String appointmentName) {\r\n\t\tif (appointmentName != null) {\r\n\t\t\treturn (appointmentName.length() > 100) ? true : false;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\t\r\n\tprivate void validateDurationField(Errors errors, AppointmentType appointmentType) {\r\n\t\tValidationUtils.rejectIfEmpty(errors, \"duration\", \"appointmentscheduling.AppointmentType.durationEmpty\");\r\n\t\tif (appointmentType.getDuration() == null || appointmentType.getDuration() <= 0) {\r\n\t\t\terrors.rejectValue(\"duration\", \"appointmentscheduling.AppointmentType.duration.errorMessage\");\r\n\t\t}\r\n\t}\r\n\t\r\n\tprivate void validateDescriptionField(Errors errors, String description) {\r\n\t\tif (verifyIfDescriptionHasMoreThan1024Characters(description)) {\r\n\t\t\terrors.rejectValue(\"description\", \"appointmentscheduling.AppointmentType.description.errorMessage\");\r\n\t\t}\r\n\t}\r\n\t\r\n\tprivate boolean verifyIfDescriptionHasMoreThan1024Characters(String description) {\r\n\t\tif (description != null) {\r\n\t\t\treturn (description.length() > 1024) ? true : false;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\tprivate boolean verifyIfNameHasHtmlEncodableChars(String appointmentName) {\r\n\t\tif(appointmentName != null){\r\n\t\t\treturn !WebUtil.escapeHTML(appointmentName).equals(appointmentName);\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\t\r\n}",
        "patch": "@@ -18,6 +18,7 @@\n import org.openmrs.annotation.Handler;\r\n import org.openmrs.module.appointmentscheduling.AppointmentType;\r\n import org.openmrs.module.appointmentscheduling.api.AppointmentService;\r\n+import org.openmrs.web.WebUtil;\r\n import org.springframework.beans.factory.annotation.Autowired;\r\n import org.springframework.beans.factory.annotation.Qualifier;\r\n import org.springframework.validation.Errors;\r\n@@ -82,6 +83,9 @@ private void validateFieldName(Errors errors, AppointmentType appointmentType) {\n \t\tif (verifyIfNameHasMoreThan100Characters(appointmentType.getName())) {\r\n \t\t\terrors.rejectValue(\"name\", \"appointmentscheduling.AppointmentType.longName.errorMessage\");\r\n \t\t}\r\n+\t\tif(verifyIfNameHasHtmlEncodableChars(appointmentType.getName())){\r\n+\t\t\terrors.rejectValue(\"name\", \"appointmentscheduling.AppointmentType.unsafeName.errorMessage\");\r\n+\t\t}\r\n \t}\r\n \t\r\n \tprivate boolean verifyIfNameHasMoreThan100Characters(String appointmentName) {\r\n@@ -110,5 +114,12 @@ private boolean verifyIfDescriptionHasMoreThan1024Characters(String description)\n \t\t}\r\n \t\treturn false;\r\n \t}\r\n+\r\n+\tprivate boolean verifyIfNameHasHtmlEncodableChars(String appointmentName) {\r\n+\t\tif(appointmentName != null){\r\n+\t\t\treturn !WebUtil.escapeHTML(appointmentName).equals(appointmentName);\r\n+\t\t}\r\n+\t\treturn false;\r\n+\t}\r\n \t\r\n }\r",
        "function_modified_lines": {
            "added": [
                "\r\n",
                "\tprivate boolean verifyIfNameHasHtmlEncodableChars(String appointmentName) {\r\n",
                "\t\tif(appointmentName != null){\r\n",
                "\t\t\treturn !WebUtil.escapeHTML(appointmentName).equals(appointmentName);\r\n",
                "\t\t}\r\n",
                "\t\treturn false;\r\n",
                "\t}\r\n"
            ],
            "deleted": []
        },
        "lang": "Java",
        "cwe": [
            "CWE-79"
        ],
        "cve_description": "A vulnerability was found in OpenMRS Appointment Scheduling Module up to 1.12.x. It has been classified as problematic. This affects the function validateFieldName of the file api/src/main/java/org/openmrs/module/appointmentscheduling/validator/AppointmentTypeValidator.java. The manipulation leads to cross site scripting. It is possible to initiate the attack remotely. Upgrading to version 1.13.0 is able to address this issue. The name of the patch is 34213c3f6ea22df427573076fb62744694f601d8. It is recommended to upgrade the affected component. The associated identifier of this vulnerability is VDB-216915.",
        "id": 12184
    },
    {
        "cve_id": "CVE-2023-29206",
        "code_before_change": "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.plugin.skinx;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.xwiki.bridge.event.DocumentCreatedEvent;\nimport org.xwiki.bridge.event.DocumentDeletedEvent;\nimport org.xwiki.bridge.event.DocumentUpdatedEvent;\nimport org.xwiki.bridge.event.WikiDeletedEvent;\nimport org.xwiki.model.EntityType;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.EntityReferenceResolver;\nimport org.xwiki.model.reference.EntityReferenceSerializer;\nimport org.xwiki.observation.EventListener;\nimport org.xwiki.observation.ObservationManager;\nimport org.xwiki.observation.event.Event;\nimport org.xwiki.security.authorization.AuthorizationManager;\nimport org.xwiki.security.authorization.ContextualAuthorizationManager;\nimport org.xwiki.security.authorization.Right;\n\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.objects.BaseObject;\nimport com.xpn.xwiki.objects.classes.BaseClass;\nimport com.xpn.xwiki.web.Utils;\n\n/**\n * Abstract SX plugin for wiki-document-based extensions (Extensions written as object of a XWiki Extension class).\n * Provides a generic method to initialize the XWiki class upon plugin initialization if needed. Provide a notification\n * mechanism for extensions marked as \"use-always\".\n * \n * @version $Id$\n * @since 1.4\n * @see JsSkinExtensionPlugin\n * @see CssSkinExtensionPlugin\n */\npublic abstract class AbstractDocumentSkinExtensionPlugin extends AbstractSkinExtensionPlugin implements EventListener\n{\n    /**\n     * Log helper for logging messages in this class.\n     */\n    protected static final Logger LOGGER = LoggerFactory.getLogger(AbstractDocumentSkinExtensionPlugin.class);\n\n    /**\n     * The name of the field that indicates whether an extension should always be used, or only when explicitly pulled.\n     */\n    private static final String USE_FIELDNAME = \"use\";\n",
        "code_after_change": "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.plugin.skinx;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.exception.ExceptionUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.xwiki.bridge.event.DocumentCreatedEvent;\nimport org.xwiki.bridge.event.DocumentDeletedEvent;\nimport org.xwiki.bridge.event.DocumentUpdatedEvent;\nimport org.xwiki.bridge.event.WikiDeletedEvent;\nimport org.xwiki.model.EntityType;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.model.reference.EntityReferenceResolver;\nimport org.xwiki.model.reference.EntityReferenceSerializer;\nimport org.xwiki.observation.EventListener;\nimport org.xwiki.observation.ObservationManager;\nimport org.xwiki.observation.event.Event;\nimport org.xwiki.security.authorization.AuthorizationManager;\nimport org.xwiki.security.authorization.ContextualAuthorizationManager;\nimport org.xwiki.security.authorization.Right;\n\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.objects.BaseObject;\nimport com.xpn.xwiki.objects.classes.BaseClass;\nimport com.xpn.xwiki.web.Utils;\n\n/**\n * Abstract SX plugin for wiki-document-based extensions (Extensions written as object of a XWiki Extension class).\n * Provides a generic method to initialize the XWiki class upon plugin initialization if needed. Provide a notification\n * mechanism for extensions marked as \"use-always\".\n * \n * @version $Id$\n * @since 1.4\n * @see JsSkinExtensionPlugin\n * @see CssSkinExtensionPlugin\n */\npublic abstract class AbstractDocumentSkinExtensionPlugin extends AbstractSkinExtensionPlugin implements EventListener\n{\n    /**\n     * Log helper for logging messages in this class.\n     */\n    protected static final Logger LOGGER = LoggerFactory.getLogger(AbstractDocumentSkinExtensionPlugin.class);\n\n    /**\n     * The name of the field that indicates whether an extension should always be used, or only when explicitly pulled.\n     */",
        "patch": "@@ -29,6 +29,7 @@\n import java.util.Set;\n \n import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.exception.ExceptionUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.xwiki.bridge.event.DocumentCreatedEvent;\n@@ -37,6 +38,7 @@\n import org.xwiki.bridge.event.WikiDeletedEvent;\n import org.xwiki.model.EntityType;\n import org.xwiki.model.reference.DocumentReference;\n+import org.xwiki.model.reference.DocumentReferenceResolver;\n import org.xwiki.model.reference.EntityReferenceResolver;\n import org.xwiki.model.reference.EntityReferenceSerializer;\n import org.xwiki.observation.EventListener;\n@@ -85,6 +87,10 @@ public abstract class AbstractDocumentSkinExtensionPlugin extends AbstractSkinEx\n      */\n     private final List<Event> events = new ArrayList<>(3);\n \n+    private AuthorizationManager authorizationManager;\n+    private DocumentReferenceResolver<String> stringDocumentReferenceResolver;\n+    private EntityReferenceResolver<String> currentEntityReferenceResolver;\n+\n     /**\n      * XWiki plugin constructor.\n      * \n@@ -174,7 +180,7 @@ public void virtualInit(XWikiContext context)\n     @Override\n     public Set<String> getAlwaysUsedExtensions(XWikiContext context)\n     {\n-        EntityReferenceSerializer<String> serializer = Utils.getComponent(EntityReferenceSerializer.TYPE_STRING);\n+        EntityReferenceSerializer<String> serializer = getDefaultEntityReferenceSerializer();\n         Set<DocumentReference> references = getAlwaysUsedExtensions();\n         Set<String> names = new HashSet<>(references.size());\n         for (DocumentReference reference : references) {\n@@ -214,7 +220,7 @@ public Set<DocumentReference> getAlwaysUsedExtensions()\n                         XWikiDocument doc = context.getWiki().getDocument(extension, context);\n                         // Only add the extension as being \"always used\" if the page holding it has been saved with\n                         // programming rights.\n-                        if (Utils.getComponent(AuthorizationManager.class).hasAccess(Right.PROGRAM,\n+                        if (getAuthorizationManager().hasAccess(Right.PROGRAM,\n                             doc.getAuthorReference(), doc.getDocumentReference())) {\n                             extensions.add(extension);\n                         }\n@@ -236,36 +242,83 @@ public Set<DocumentReference> getAlwaysUsedExtensions()\n     public boolean hasPageExtensions(XWikiContext context)\n     {\n         XWikiDocument doc = context.getDoc();\n-        if (doc != null) {\n-            List<BaseObject> objects = doc.getObjects(getExtensionClassName());\n-            if (objects != null) {\n-                for (BaseObject obj : objects) {\n-                    if (obj == null) {\n-                        continue;\n-                    }\n-                    if (obj.getStringValue(USE_FIELDNAME).equals(\"currentPage\")) {\n-                        return true;\n-                    }\n+        boolean result = false;\n+        if (doc != null && this.hasCurrentPageExtensionObjects(doc)) {\n+            if (getAuthorizationManager().hasAccess(Right.SCRIPT, doc.getAuthorReference(),\n+                doc.getDocumentReference())) {\n+                result = true;\n+            } else {\n+                displayScriptRightLog(doc.getDocumentReference());\n+            }\n+        }\n+        return result;\n+    }\n+\n+    private void displayScriptRightLog(Object documentReference)\n+    {\n+        LOGGER.warn(\"Extensions present in [{}] ignored because of lack of script right from the author.\",\n+            documentReference);\n+    }\n+\n+    private boolean hasCurrentPageExtensionObjects(XWikiDocument doc)\n+    {\n+        List<BaseObject> objects = doc.getObjects(getExtensionClassName());\n+        if (objects != null) {\n+            for (BaseObject obj : objects) {\n+                if (obj == null) {\n+                    continue;\n+                }\n+                if (StringUtils.equals(obj.getStringValue(USE_FIELDNAME), \"currentPage\")) {\n+                    return true;\n                 }\n             }\n         }\n         return false;\n     }\n \n     @Override\n-    public void use(String resource, XWikiContext context)\n+    public void use(String resource, Map<String, Object> parameters, XWikiContext context)\n     {\n         String canonicalResource = getCanonicalDocumentName(resource);\n \n-        super.use(canonicalResource, context);\n+        if (this.canResourceBeUsed(canonicalResource, context)) {\n+            super.use(canonicalResource, parameters, context);\n+        } else {\n+            displayScriptRightLog(canonicalResource);\n+        }\n     }\n \n-    @Override\n-    public void use(String resource, Map<String, Object> parameters, XWikiContext context)\n+    private DocumentReferenceResolver<String> getDocumentReferenceResolver()\n     {\n-        String canonicalResource = getCanonicalDocumentName(resource);\n+        if (this.stringDocumentReferenceResolver == null) {\n+            this.stringDocumentReferenceResolver = Utils.getComponent(DocumentReferenceResolver.TYPE_STRING);\n+        }\n+        return this.stringDocumentReferenceResolver;\n+    }\n \n-        super.use(canonicalResource, parameters, context);\n+    private AuthorizationManager getAuthorizationManager()\n+    {\n+        if (this.authorizationManager == null) {\n+            this.authorizationManager = Utils.getComponent(AuthorizationManager.class);\n+        }\n+        return this.authorizationManager;\n+    }\n+\n+    private boolean canResourceBeUsed(String resource, XWikiContext context)\n+    {\n+        DocumentReferenceResolver<String> documentReferenceResolver = getDocumentReferenceResolver();\n+        DocumentReference documentReference = documentReferenceResolver.resolve(resource);\n+\n+        try {\n+            XWikiDocument document = context.getWiki().getDocument(documentReference, context);\n+            DocumentReference authorReference = document.getAuthorReference();\n+            return getAuthorizationManager().hasAccess(Right.SCRIPT, authorReference, documentReference);\n+        } catch (XWikiException e) {\n+            LOGGER.error(\"Error while loading [{}] for checking script right: [{}]\", documentReference,\n+                ExceptionUtils.getRootCauseMessage(e));\n+            LOGGER.debug(\"Original error stack trace: \", e);\n+            return false;\n+        }\n     }\n \n     /**\n@@ -332,7 +385,7 @@ private void onDocumentEvent(XWikiDocument document)\n         if (document.getObject(getExtensionClassName()) != null) {\n             // new or already existing object\n             if (document.getObject(getExtensionClassName(), USE_FIELDNAME, \"always\", false) != null) {\n-                if (Utils.getComponent(AuthorizationManager.class).hasAccess(Right.PROGRAM,\n+                if (getAuthorizationManager().hasAccess(Right.PROGRAM,\n                     document.getAuthorReference(), document.getDocumentReference())) {\n                     getAlwaysUsedExtensions().add(document.getDocumentReference());\n \n@@ -355,6 +408,14 @@ private void onDocumentEvent(XWikiDocument document)\n         }\n     }\n \n+    private EntityReferenceResolver<String> getCurrentEntityReferenceResolver()\n+    {\n+        if (this.currentEntityReferenceResolver == null) {\n+            this.currentEntityReferenceResolver = Utils.getComponent(EntityReferenceResolver.TYPE_STRING, \"current\");\n+        }\n+        return this.currentEntityReferenceResolver;\n+    }\n+\n     /**\n      * Get the canonical serialization of a document name, in the {@code wiki:Space.Document} format.\n      *\n@@ -363,10 +424,8 @@ private void onDocumentEvent(XWikiDocument document)\n      */\n     private String getCanonicalDocumentName(String documentName)\n     {\n-        @SuppressWarnings(\"unchecked\")\n-        EntityReferenceResolver<String> resolver = Utils.getComponent(EntityReferenceResolver.TYPE_STRING, \"current\");\n-        @SuppressWarnings(\"unchecked\")\n-        EntityReferenceSerializer<String> serializer = Utils.getComponent(EntityReferenceSerializer.TYPE_STRING);\n+        EntityReferenceResolver<String> resolver = getCurrentEntityReferenceResolver();\n+        EntityReferenceSerializer<String> serializer = getDefaultEntityReferenceSerializer();\n         return serializer.serialize(resolver.resolve(documentName, EntityType.DOCUMENT));\n     }\n ",
        "function_modified_lines": {
            "added": [
                "import org.apache.commons.lang3.exception.ExceptionUtils;\n",
                "import org.xwiki.model.reference.DocumentReferenceResolver;\n"
            ],
            "deleted": []
        },
        "lang": "Java",
        "cwe": [
            "CWE-79"
        ],
        "cve_description": "XWiki Commons are technical libraries common to several other top level XWiki projects. There was no check in the author of a JavaScript xobject or StyleSheet xobject added in a XWiki document, so until now it was possible for a user having only Edit Right to create such object and to craft a script allowing to perform some operations when executing by a user with appropriate rights. This has been patched in XWiki 14.9-rc-1 by only executing the script if the author of it has Script rights.",
        "id": 12315
    },
    {
        "cve_id": "CVE-2023-29506",
        "code_before_change": "{\n    @InjectMockComponents\n    private AuthenticationResourceReferenceHandler resourceReferenceHandler;\n\n    @MockComponent\n    private XWikiContextInitializer xWikiContextInitializer;\n\n    @MockComponent\n    private Execution execution;\n\n    private XWikiResponse response;\n\n    private XWiki xwiki;\n\n    private XWikiContext context;\n\n    private ServletOutputStream servletOutputStream;\n\n    private WikiReference currentWiki;\n\n    @BeforeEach\n    void setup() throws XWikiException, IOException\n    {\n        ExecutionContext executionContext = mock(ExecutionContext.class);\n        when(this.execution.getContext()).thenReturn(executionContext);\n        this.context = mock(XWikiContext.class);\n        when(this.xWikiContextInitializer.initialize(executionContext)).thenReturn(context);\n        this.response = mock(XWikiResponse.class);\n        when(context.getResponse()).thenReturn(response);\n        this.xwiki = mock(XWiki.class);\n        when(context.getWiki()).thenReturn(xwiki);\n        when(this.xwiki.getEncoding()).thenReturn(\"UTF-8\");\n        XWikiPluginManager pluginManager = mock(XWikiPluginManager.class);\n        when(this.xwiki.getPluginManager()).thenReturn(pluginManager);\n        when(pluginManager.endParsing(any(), eq(context)))\n            .then(invocationOnMock -> invocationOnMock.getArgument(0));\n        this.servletOutputStream = mock(ServletOutputStream.class);\n        when(this.response.getOutputStream()).thenReturn(servletOutputStream);\n        currentWiki = new WikiReference(\"currentWiki\");\n        when(context.getWikiReference()).thenReturn(currentWiki);\n    }\n\n    @Test\n    void getSupportedResourceReferences()\n    {\n        assertEquals(Collections.singletonList(AuthenticationResourceReference.TYPE),\n            this.resourceReferenceHandler.getSupportedResourceReferences());\n    }\n\n    @Test\n    void handleResetPassword() throws Exception\n    {\n        WikiReference wikiReference = new WikiReference(\"foo\");\n        AuthenticationResourceReference resourceReference = new AuthenticationResourceReference(\n            wikiReference,\n            AuthenticationAction.RESET_PASSWORD);\n\n        when(this.xwiki.evaluateTemplate(\"resetpassword.vm\", context)).thenReturn(\"Reset password content\");\n\n        ResourceReferenceHandlerChain chain = mock(ResourceReferenceHandlerChain.class);\n        this.resourceReferenceHandler.handle(resourceReference, chain);\n\n        verify(response).setContentType(\"text/html; charset=UTF-8\");\n        verify(this.xWikiContextInitializer).initialize(any(ExecutionContext.class));\n        verify(servletOutputStream).write(\"Reset password content\".getBytes(StandardCharsets.UTF_8));\n        verify(chain).handleNext(resourceReference);\n        verify(context).setWikiReference(wikiReference);\n        verify(context).setWikiReference(currentWiki);\n    }\n\n    @Test\n    void handleForgotUsername() throws Exception\n    {\n        WikiReference wikiReference = new WikiReference(\"bar\");\n        AuthenticationResourceReference resourceReference = new AuthenticationResourceReference(\n            wikiReference,\n            AuthenticationAction.RETRIEVE_USERNAME);\n\n        when(this.xwiki.evaluateTemplate(\"forgotusername.vm\", context)).thenReturn(\"Forgot user name content\");\n\n        ResourceReferenceHandlerChain chain = mock(ResourceReferenceHandlerChain.class);\n        this.resourceReferenceHandler.handle(resourceReference, chain);\n\n        verify(response).setContentType(\"text/html; charset=UTF-8\");\n        verify(this.xWikiContextInitializer).initialize(any(ExecutionContext.class));\n        verify(servletOutputStream).write(\"Forgot user name content\".getBytes(StandardCharsets.UTF_8));\n        verify(chain).handleNext(resourceReference);\n        verify(context).setWikiReference(wikiReference);\n        verify(context).setWikiReference(currentWiki);\n    }\n}",
        "code_after_change": "{\n    @InjectMockComponents\n    private AuthenticationResourceReferenceHandler resourceReferenceHandler;\n\n    @MockComponent\n    private XWikiContextInitializer xWikiContextInitializer;\n\n    @MockComponent\n    private Execution execution;\n\n    @MockComponent\n    private WikiDescriptorManager wikiDescriptorManager;\n\n    private XWikiResponse response;\n\n    private XWiki xwiki;\n\n    private XWikiContext context;\n\n    private ServletOutputStream servletOutputStream;\n\n    private WikiReference currentWiki;\n\n    @BeforeEach\n    void setup() throws XWikiException, IOException\n    {\n        ExecutionContext executionContext = mock(ExecutionContext.class);\n        when(this.execution.getContext()).thenReturn(executionContext);\n        this.context = mock(XWikiContext.class);\n        when(this.xWikiContextInitializer.initialize(executionContext)).thenReturn(context);\n        this.response = mock(XWikiResponse.class);\n        when(context.getResponse()).thenReturn(response);\n        this.xwiki = mock(XWiki.class);\n        when(context.getWiki()).thenReturn(xwiki);\n        when(this.xwiki.getEncoding()).thenReturn(\"UTF-8\");\n        XWikiPluginManager pluginManager = mock(XWikiPluginManager.class);\n        when(this.xwiki.getPluginManager()).thenReturn(pluginManager);\n        when(pluginManager.endParsing(any(), eq(context)))\n            .then(invocationOnMock -> invocationOnMock.getArgument(0));\n        this.servletOutputStream = mock(ServletOutputStream.class);\n        when(this.response.getOutputStream()).thenReturn(servletOutputStream);\n        currentWiki = new WikiReference(\"currentWiki\");\n        when(context.getWikiReference()).thenReturn(currentWiki);\n    }\n\n    @Test\n    void getSupportedResourceReferences()\n    {\n        assertEquals(Collections.singletonList(AuthenticationResourceReference.TYPE),\n            this.resourceReferenceHandler.getSupportedResourceReferences());\n    }\n\n    @Test\n    void handleResetPassword() throws Exception\n    {\n        WikiReference wikiReference = new WikiReference(\"foo\");\n        when(this.wikiDescriptorManager.exists(\"foo\")).thenReturn(false);\n        AuthenticationResourceReference resourceReference = new AuthenticationResourceReference(\n            wikiReference,\n            AuthenticationAction.RESET_PASSWORD);\n\n        ResourceReferenceHandlerChain chain = mock(ResourceReferenceHandlerChain.class);\n        ResourceReferenceHandlerException exception =\n            assertThrows(ResourceReferenceHandlerException.class,\n                () -> this.resourceReferenceHandler.handle(resourceReference, chain));\n        assertEquals(\"The wiki [foo] does not exist.\", exception.getMessage());\n\n        when(this.wikiDescriptorManager.exists(\"foo\")).thenReturn(true);\n        when(this.xwiki.evaluateTemplate(\"resetpassword.vm\", context)).thenReturn(\"Reset password content\");\n        this.resourceReferenceHandler.handle(resourceReference, chain);\n\n        verify(response).setContentType(\"text/html; charset=UTF-8\");\n        verify(this.xWikiContextInitializer).initialize(any(ExecutionContext.class));\n        verify(servletOutputStream).write(\"Reset password content\".getBytes(StandardCharsets.UTF_8));\n        verify(chain).handleNext(resourceReference);\n        verify(context).setWikiReference(wikiReference);\n        verify(context).setWikiReference(currentWiki);\n    }\n\n    @Test\n    void handleForgotUsername() throws Exception\n    {\n        WikiReference wikiReference = new WikiReference(\"bar\");\n        when(this.wikiDescriptorManager.exists(\"bar\")).thenReturn(false);\n        AuthenticationResourceReference resourceReference = new AuthenticationResourceReference(\n            wikiReference,\n            AuthenticationAction.RETRIEVE_USERNAME);\n\n        ResourceReferenceHandlerChain chain = mock(ResourceReferenceHandlerChain.class);\n        ResourceReferenceHandlerException exception =\n            assertThrows(ResourceReferenceHandlerException.class,\n                () -> this.resourceReferenceHandler.handle(resourceReference, chain));\n        assertEquals(\"The wiki [bar] does not exist.\", exception.getMessage());\n\n        when(this.wikiDescriptorManager.exists(\"bar\")).thenReturn(true);\n        when(this.xwiki.evaluateTemplate(\"forgotusername.vm\", context)).thenReturn(\"Forgot user name content\");\n\n        this.resourceReferenceHandler.handle(resourceReference, chain);\n        verify(response).setContentType(\"text/html; charset=UTF-8\");\n        verify(this.xWikiContextInitializer).initialize(any(ExecutionContext.class));\n        verify(servletOutputStream).write(\"Forgot user name content\".getBytes(StandardCharsets.UTF_8));\n        verify(chain).handleNext(resourceReference);\n        verify(context).setWikiReference(wikiReference);\n        verify(context).setWikiReference(currentWiki);\n    }\n\n    @Test\n    void handleForgotUsernameWikiDescriptorError() throws Exception\n    {\n        WikiReference wikiReference = new WikiReference(\"bar\");\n        when(this.wikiDescriptorManager.exists(\"bar\")).thenThrow(new WikiManagerException(\"Cannot access wiki\"));\n        AuthenticationResourceReference resourceReference = new AuthenticationResourceReference(\n            wikiReference,\n            AuthenticationAction.RETRIEVE_USERNAME);\n\n        ResourceReferenceHandlerChain chain = mock(ResourceReferenceHandlerChain.class);\n        ResourceReferenceHandlerException exception =\n            assertThrows(ResourceReferenceHandlerException.class,\n                () -> this.resourceReferenceHandler.handle(resourceReference, chain));\n        assertEquals(\"Error when checking if wiki [bar] exists.\", exception.getMessage());\n    }\n}",
        "patch": "@@ -31,11 +31,14 @@\n import org.xwiki.context.ExecutionContext;\n import org.xwiki.model.reference.WikiReference;\n import org.xwiki.resource.ResourceReferenceHandlerChain;\n+import org.xwiki.resource.ResourceReferenceHandlerException;\n import org.xwiki.security.authentication.AuthenticationAction;\n import org.xwiki.security.authentication.AuthenticationResourceReference;\n import org.xwiki.test.junit5.mockito.ComponentTest;\n import org.xwiki.test.junit5.mockito.InjectMockComponents;\n import org.xwiki.test.junit5.mockito.MockComponent;\n+import org.xwiki.wiki.descriptor.WikiDescriptorManager;\n+import org.xwiki.wiki.manager.WikiManagerException;\n \n import com.xpn.xwiki.XWiki;\n import com.xpn.xwiki.XWikiContext;\n@@ -45,6 +48,7 @@\n import com.xpn.xwiki.web.XWikiResponse;\n \n import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.ArgumentMatchers.eq;\n import static org.mockito.Mockito.mock;\n@@ -69,6 +73,9 @@ class AuthenticationResourceReferenceHandlerTest\n     @MockComponent\n     private Execution execution;\n \n+    @MockComponent\n+    private WikiDescriptorManager wikiDescriptorManager;\n+\n     private XWikiResponse response;\n \n     private XWiki xwiki;\n@@ -112,13 +119,19 @@ void getSupportedResourceReferences()\n     void handleResetPassword() throws Exception\n     {\n         WikiReference wikiReference = new WikiReference(\"foo\");\n+        when(this.wikiDescriptorManager.exists(\"foo\")).thenReturn(false);\n         AuthenticationResourceReference resourceReference = new AuthenticationResourceReference(\n             wikiReference,\n             AuthenticationAction.RESET_PASSWORD);\n \n-        when(this.xwiki.evaluateTemplate(\"resetpassword.vm\", context)).thenReturn(\"Reset password content\");\n-\n         ResourceReferenceHandlerChain chain = mock(ResourceReferenceHandlerChain.class);\n+        ResourceReferenceHandlerException exception =\n+            assertThrows(ResourceReferenceHandlerException.class,\n+                () -> this.resourceReferenceHandler.handle(resourceReference, chain));\n+        assertEquals(\"The wiki [foo] does not exist.\", exception.getMessage());\n+\n+        when(this.wikiDescriptorManager.exists(\"foo\")).thenReturn(true);\n+        when(this.xwiki.evaluateTemplate(\"resetpassword.vm\", context)).thenReturn(\"Reset password content\");\n         this.resourceReferenceHandler.handle(resourceReference, chain);\n \n         verify(response).setContentType(\"text/html; charset=UTF-8\");\n@@ -133,20 +146,42 @@ void handleResetPassword() throws Exception\n     void handleForgotUsername() throws Exception\n     {\n         WikiReference wikiReference = new WikiReference(\"bar\");\n+        when(this.wikiDescriptorManager.exists(\"bar\")).thenReturn(false);\n         AuthenticationResourceReference resourceReference = new AuthenticationResourceReference(\n             wikiReference,\n             AuthenticationAction.RETRIEVE_USERNAME);\n \n+        ResourceReferenceHandlerChain chain = mock(ResourceReferenceHandlerChain.class);\n+        ResourceReferenceHandlerException exception =\n+            assertThrows(ResourceReferenceHandlerException.class,\n+                () -> this.resourceReferenceHandler.handle(resourceReference, chain));\n+        assertEquals(\"The wiki [bar] does not exist.\", exception.getMessage());\n+\n+        when(this.wikiDescriptorManager.exists(\"bar\")).thenReturn(true);\n         when(this.xwiki.evaluateTemplate(\"forgotusername.vm\", context)).thenReturn(\"Forgot user name content\");\n \n-        ResourceReferenceHandlerChain chain = mock(ResourceReferenceHandlerChain.class);\n         this.resourceReferenceHandler.handle(resourceReference, chain);\n-\n         verify(response).setContentType(\"text/html; charset=UTF-8\");\n         verify(this.xWikiContextInitializer).initialize(any(ExecutionContext.class));\n         verify(servletOutputStream).write(\"Forgot user name content\".getBytes(StandardCharsets.UTF_8));\n         verify(chain).handleNext(resourceReference);\n         verify(context).setWikiReference(wikiReference);\n         verify(context).setWikiReference(currentWiki);\n     }\n+\n+    @Test\n+    void handleForgotUsernameWikiDescriptorError() throws Exception\n+    {\n+        WikiReference wikiReference = new WikiReference(\"bar\");\n+        when(this.wikiDescriptorManager.exists(\"bar\")).thenThrow(new WikiManagerException(\"Cannot access wiki\"));\n+        AuthenticationResourceReference resourceReference = new AuthenticationResourceReference(\n+            wikiReference,\n+            AuthenticationAction.RETRIEVE_USERNAME);\n+\n+        ResourceReferenceHandlerChain chain = mock(ResourceReferenceHandlerChain.class);\n+        ResourceReferenceHandlerException exception =\n+            assertThrows(ResourceReferenceHandlerException.class,\n+                () -> this.resourceReferenceHandler.handle(resourceReference, chain));\n+        assertEquals(\"Error when checking if wiki [bar] exists.\", exception.getMessage());\n+    }\n }",
        "function_modified_lines": {
            "added": [
                "    @MockComponent\n",
                "    private WikiDescriptorManager wikiDescriptorManager;\n",
                "\n"
            ],
            "deleted": []
        },
        "lang": "Java",
        "cwe": [
            "CWE-79"
        ],
        "cve_description": "XWiki Commons are technical libraries common to several other top level XWiki projects. It was possible to inject some code using the URL of authenticated endpoints. This problem has been patched on XWiki 13.10.11, 14.4.7 and 14.10.",
        "id": 12335
    },
    {
        "cve_id": "CVE-2021-4266",
        "code_before_change": "{\n      case CSS:\n        return new StringFilter() {\n          public String filter( String input ) {\n            return filter( input, \"\" );\n          }\n\n          public String filter( String input, String baseUrl ) {\n            return String.format(\n              \"\\t\\t<link href=\\\"%s%s\\\" rel=\\\"stylesheet\\\" type=\\\"text/css\\\" />\\n\",\n              baseUrl, baseUrl.endsWith( \"/\" ) && input.startsWith( \"/\" ) ? input.replaceFirst( \"/\", \"\" ) : input );\n          }\n        };\n      case JS:\n        return new StringFilter() {\n          public String filter( String input ) {\n            return filter( input, \"\" );\n          }\n\n          public String filter( String input, String baseUrl ) {\n            return String.format(\n              \"\\t\\t<script language=\\\"javascript\\\" type=\\\"text/javascript\\\" src=\\\"%s%s\\\"></script>\\n\",\n              baseUrl, baseUrl.endsWith( \"/\" ) && input.startsWith( \"/\" ) ? input.replaceFirst( \"/\", \"\" ) : input );\n          }\n        };\n      case MAP:\n        return new StringFilter() {\n          @Override\n          public String filter( String input ) {\n            return \"\";\n          }\n\n          @Override\n          public String filter( String input, String absRoot ) {\n            return \"\";\n          }\n        };\n      default:\n        return new StringFilter() {\n          public String filter( String input ) {\n            return filter( input, \"\" );\n          }\n\n          public String filter( String input, String baseUrl ) {\n            return baseUrl + input + \"\\n\";\n          }\n        };\n    }",
        "code_after_change": "{\n      case CSS:\n        return new StringFilter() {\n          public String filter( String input ) {\n            return filter( input, \"\" );\n          }\n\n          public String filter( String input, String baseUrl ) {\n            baseUrl = Encode.forHtmlAttribute( baseUrl );\n            return String.format(\n              \"\\t\\t<link href=\\\"%s%s\\\" rel=\\\"stylesheet\\\" type=\\\"text/css\\\" />\\n\",\n              baseUrl, baseUrl.endsWith( \"/\" ) && input.startsWith( \"/\" ) ? input.replaceFirst( \"/\", \"\" ) : input );\n          }\n        };\n      case JS:\n        return new StringFilter() {\n          public String filter( String input ) {\n            return filter( input, \"\" );\n          }\n\n          public String filter( String input, String baseUrl ) {\n            baseUrl = Encode.forHtmlAttribute( baseUrl );\n            return String.format(\n              \"\\t\\t<script language=\\\"javascript\\\" type=\\\"text/javascript\\\" src=\\\"%s%s\\\"></script>\\n\",\n              baseUrl, baseUrl.endsWith( \"/\" ) && input.startsWith( \"/\" ) ? input.replaceFirst( \"/\", \"\" ) : input );\n          }\n        };\n      case MAP:\n        return new StringFilter() {\n          @Override\n          public String filter( String input ) {\n            return \"\";\n          }\n\n          @Override\n          public String filter( String input, String absRoot ) {\n            return \"\";\n          }\n        };\n      default:\n        return new StringFilter() {\n          public String filter( String input ) {\n            return filter( input, \"\" );\n          }\n\n          public String filter( String input, String baseUrl ) {\n            return Encode.forHtmlAttribute( baseUrl ) + input + \"\\n\";\n          }\n        };\n    }",
        "patch": "@@ -1,5 +1,5 @@\n /*!\n- * Copyright 2002 - 2019 Webdetails, a Hitachi Vantara company.  All rights reserved.\n+ * Copyright 2002 - 2021 Webdetails, a Hitachi Vantara company.  All rights reserved.\n  *\n  * This software was developed by Webdetails and is provided under the terms\n  * of the Mozilla Public License, Version 2.0, or any later version. You may not use\n@@ -12,6 +12,7 @@\n  */\n package pt.webdetails.cpf.packager;\n \n+import org.owasp.encoder.Encode;\n import pt.webdetails.cpf.context.api.IUrlProvider;\n import pt.webdetails.cpf.packager.dependencies.CssMinifiedDependency;\n import pt.webdetails.cpf.packager.dependencies.Dependency;\n@@ -276,6 +277,7 @@ public String filter( String input ) {\n           }\n \n           public String filter( String input, String baseUrl ) {\n+            baseUrl = Encode.forHtmlAttribute( baseUrl );\n             return String.format(\n               \"\\t\\t<link href=\\\"%s%s\\\" rel=\\\"stylesheet\\\" type=\\\"text/css\\\" />\\n\",\n               baseUrl, baseUrl.endsWith( \"/\" ) && input.startsWith( \"/\" ) ? input.replaceFirst( \"/\", \"\" ) : input );\n@@ -288,6 +290,7 @@ public String filter( String input ) {\n           }\n \n           public String filter( String input, String baseUrl ) {\n+            baseUrl = Encode.forHtmlAttribute( baseUrl );\n             return String.format(\n               \"\\t\\t<script language=\\\"javascript\\\" type=\\\"text/javascript\\\" src=\\\"%s%s\\\"></script>\\n\",\n               baseUrl, baseUrl.endsWith( \"/\" ) && input.startsWith( \"/\" ) ? input.replaceFirst( \"/\", \"\" ) : input );\n@@ -312,7 +315,7 @@ public String filter( String input ) {\n           }\n \n           public String filter( String input, String baseUrl ) {\n-            return baseUrl + input + \"\\n\";\n+            return Encode.forHtmlAttribute( baseUrl ) + input + \"\\n\";\n           }\n         };\n     }",
        "function_modified_lines": {
            "added": [
                "            baseUrl = Encode.forHtmlAttribute( baseUrl );\n",
                "            baseUrl = Encode.forHtmlAttribute( baseUrl );\n"
            ],
            "deleted": []
        },
        "lang": "Java",
        "cwe": [
            "CWE-79"
        ],
        "cve_description": "A vulnerability classified as problematic has been found in Webdetails cpf up to 9.5.0.0-80. Affected is an unknown function of the file core/src/main/java/pt/webdetails/cpf/packager/DependenciesPackage.java. The manipulation of the argument baseUrl leads to cross site scripting. It is possible to launch the attack remotely. Upgrading to version 9.5.0.0-81 is able to address this issue. The name of the patch is 3bff900d228e8cae3af256b447c5d15bdb03c174. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-216468.",
        "id": 12553
    },
    {
        "cve_id": "CVE-2022-1782",
        "code_before_change": "/*\n * Copyright 2013-2022 Erudika. https://erudika.com\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * For issues and patches go to: https://github.com/erudika\n */\npackage com.erudika.para.core.utils;\n\nimport com.erudika.para.core.utils.Config;\nimport com.erudika.para.core.utils.Utils;\nimport com.erudika.para.core.annotations.Locked;\nimport com.erudika.para.core.App;\nimport com.erudika.para.core.ParaObject;\nimport com.erudika.para.core.Sysprop;\nimport com.erudika.para.core.Tag;\nimport com.erudika.para.core.User;\nimport com.erudika.para.core.Votable;\nimport static com.erudika.para.core.utils.Utils.*;\nimport static com.erudika.para.core.utils.ParaObjectUtils.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\nimport org.apache.commons.lang3.StringUtils;\nimport static org.junit.Assert.*;\nimport org.junit.Test;\n\n/**\n *\n * @author Alex Bogdanovski [alex@erudika.com]\n */\npublic class UtilsTest {\n\n\tpublic UtilsTest() {\n\t}\n\n\t@Test\n\tpublic void testMD5() {\n\t\tassertEquals(\"098f6bcd4621d373cade4e832627b4f6\", md5(\"test\"));\n\t\tassertEquals(\"47ec2dd791e31e2ef2076caf64ed9b3d\", md5(\"test123456\"));\n\t\tassertEquals(\"d41d8cd98f00b204e9800998ecf8427e\", md5(\"\"));\n\t\tassertEquals(\"\", md5(null));\n\t}\n\n\t@Test\n\tpublic void testBcrypt() {\n\t\tassertNull(bcrypt(null));\n\t\tassertFalse(bcrypt(\"\").isEmpty());\n\t\tassertFalse(bcrypt(\"test\").isEmpty());",
        "code_after_change": "/*\n * Copyright 2013-2022 Erudika. https://erudika.com\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * For issues and patches go to: https://github.com/erudika\n */\npackage com.erudika.para.core.utils;\n\nimport com.erudika.para.core.App;\nimport com.erudika.para.core.ParaObject;\nimport com.erudika.para.core.Sysprop;\nimport com.erudika.para.core.Tag;\nimport com.erudika.para.core.User;\nimport com.erudika.para.core.Votable;\nimport com.erudika.para.core.annotations.Locked;\nimport static com.erudika.para.core.utils.ParaObjectUtils.*;\nimport static com.erudika.para.core.utils.Utils.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\nimport org.apache.commons.lang3.StringUtils;\nimport static org.junit.Assert.*;\nimport org.junit.Test;\n\n/**\n *\n * @author Alex Bogdanovski [alex@erudika.com]\n */\npublic class UtilsTest {\n\n\tpublic UtilsTest() {\n\t}\n\n\t@Test\n\tpublic void testMD5() {\n\t\tassertEquals(\"098f6bcd4621d373cade4e832627b4f6\", md5(\"test\"));\n\t\tassertEquals(\"47ec2dd791e31e2ef2076caf64ed9b3d\", md5(\"test123456\"));\n\t\tassertEquals(\"d41d8cd98f00b204e9800998ecf8427e\", md5(\"\"));\n\t\tassertEquals(\"\", md5(null));\n\t}\n\n\t@Test\n\tpublic void testBcrypt() {\n\t\tassertNull(bcrypt(null));\n\t\tassertFalse(bcrypt(\"\").isEmpty());\n\t\tassertFalse(bcrypt(\"test\").isEmpty());\n\t\tassertNotEquals(bcrypt(\"testpass\"), bcrypt(\"testpass\")); // bcrypt hashes are salted i.e. !=",
        "patch": "@@ -17,17 +17,15 @@\n  */\n package com.erudika.para.core.utils;\n \n-import com.erudika.para.core.utils.Config;\n-import com.erudika.para.core.utils.Utils;\n-import com.erudika.para.core.annotations.Locked;\n import com.erudika.para.core.App;\n import com.erudika.para.core.ParaObject;\n import com.erudika.para.core.Sysprop;\n import com.erudika.para.core.Tag;\n import com.erudika.para.core.User;\n import com.erudika.para.core.Votable;\n-import static com.erudika.para.core.utils.Utils.*;\n+import com.erudika.para.core.annotations.Locked;\n import static com.erudika.para.core.utils.ParaObjectUtils.*;\n+import static com.erudika.para.core.utils.Utils.*;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collections;\n@@ -114,6 +112,8 @@ public void testCompileMustache() {\n \t\tMap<String, Object> map = new HashMap<>();\n \t\tmap.put(\"test\", \"string\");\n \t\tassertEquals(\"<html>string</html>\", compileMustache(map, \"<html>{{test}}</html>\"));\n+\t\tmap.put(\"test\", \"<b>string</b>\");\n+\t\tassertEquals(\"<html>&lt;b&gt;string&lt;/b&gt;</html>\", compileMustache(map, \"<html>{{test}}</html>\", true));\n \t}\n \n \t@Test",
        "function_modified_lines": {
            "added": [
                "import com.erudika.para.core.annotations.Locked;\n",
                "import static com.erudika.para.core.utils.Utils.*;\n"
            ],
            "deleted": [
                "import com.erudika.para.core.utils.Config;\n",
                "import com.erudika.para.core.utils.Utils;\n",
                "import com.erudika.para.core.annotations.Locked;\n",
                "import static com.erudika.para.core.utils.Utils.*;\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-79"
        ],
        "cve_description": "Cross-site Scripting (XSS) - Generic in GitHub repository erudika/para prior to v1.45.11.",
        "id": 12571
    },
    {
        "cve_id": "CVE-2023-29201",
        "code_before_change": "     * Test {@link UniqueIdFilter}.\n     */\n    @Test\n    public void duplicateIds(ComponentManager componentManager) throws Exception\n    {\n        String actual = \"<p id=\\\"x\\\">1</p><p id=\\\"xy\\\">2</p><p id=\\\"x\\\">3</p>\";\n        String expected = \"<p id=\\\"x\\\">1</p><p id=\\\"xy\\\">2</p><p id=\\\"x0\\\">3</p>\";\n        List<HTMLFilter> filters = new ArrayList<>(this.cleanerConfiguration.getFilters());\n        filters.add(componentManager.getInstance(HTMLFilter.class, \"uniqueId\"));\n        this.cleanerConfiguration.setFilters(filters);\n        assertEquals(getHeaderFull() + expected + FOOTER,\n            HTMLUtils.toString(clean(actual)));\n    }\n\n    /**\n     * Test that tags with a namespace are not considered as unknown tags by HTMLCleaner (see also <a\n     * href=\"https://jira.xwiki.org/browse/XWIKI-9753\">XWIKI-9753</a>).\n     */\n    @Test\n    void cleanSVGTags() throws Exception\n    {\n        String input =\n            \"<p>before</p>\\n\" + \"<p><svg xmlns=\\\"http://www.w3.org/2000/svg\\\" version=\\\"1.1\\\">\\n\"\n                + \"<circle cx=\\\"100\\\" cy=\\\"50\\\" fill=\\\"red\\\" r=\\\"40\\\" stroke=\\\"black\\\" stroke-width=\\\"2\\\"></circle>\\n\"\n                + \"</svg></p>\\n\" + \"<p>after</p>\\n\";\n        assertHTML(input, getHeaderFull() + input + FOOTER);\n    }\n\n    /**\n     * Test that cleaning works when there's a TITLE element in the body (but with a namespace). The issue was that\n     * HTMLCleaner would consider it a duplicate of the TITLE element in the HEAD even though it's namespaced. (see\n     * also\n     * <a href=\"https://jira.xwiki.org/browse/XWIKI-9753\">XWIKI-9753</a>).\n     */\n    @Disabled(\"See https://jira.xwiki.org/browse/XWIKI-9753\")\n    @Test\n    void cleanTitleWithNamespace()\n    {\n        // Test with TITLE in HEAD\n        String input =\n            \"<html xmlns=\\\"http://www.w3.org/1999/xhtml\\\" lang=\\\"en\\\" xml:lang=\\\"en\\\">\\n\"\n                + \"  <head>\\n\"\n                + \"    <title>Title test</title>\\n\"\n                + \"  </head>\\n\"\n                + \"  <body>\\n\"\n                + \"    <p>before</p>\\n\"\n                + \"    <svg xmlns=\\\"http://www.w3.org/2000/svg\\\" height=\\\"300\\\" width=\\\"500\\\">\\n\"\n                + \"      <g>\\n\"\n                + \"        <title>SVG Title Demo example</title>\\n\"\n                + \"        <rect height=\\\"50\\\" style=\\\"fill:none; stroke:blue; stroke-width:1px\\\" width=\\\"200\\\" x=\\\"10\\\" \"\n                + \"y=\\\"10\\\"></rect>\\n\" + \"      </g>\\n\" + \"    </svg>\\n\" + \"    <p>after</p>\\n\";\n        assertEquals(getHeader() + input + FOOTER,\n            HTMLUtils.toString(clean(input)));\n    }\n\n    /**\n     * Verify that a xmlns namespace set on the HTML element is not removed by default and it's removed if {@link\n     * HTMLCleanerConfiguration#NAMESPACES_AWARE} is set to false.\n     */\n    @Test\n    void cleanHTMLTagWithNamespace()\n    {\n        String input = \"<html xmlns=\\\"http://www.w3.org/1999/xhtml\\\"><head></head><body>\";\n\n        // Default\n        assertEquals(getHeader() + input + FOOTER,\n            HTMLUtils.toString(clean(input)));\n\n        // Configured for namespace awareness being false\n        Map<String, String> parameters = new HashMap<>(this.cleanerConfiguration.getParameters());\n        parameters.put(HTMLCleanerConfiguration.NAMESPACES_AWARE, \"false\");\n        this.cleanerConfiguration.setParameters(parameters);\n        assertEquals(getHeader() + \"<html><head></head><body>\" + FOOTER,\n            HTMLUtils.toString(clean(input)));\n    }\n\n    /**\n     * Test that cleaning an empty DIV works (it used to fail, see <a href=\"https://jira.xwiki.org/browse/XWIKI-4007\">XWIKI-4007</a>).\n     */\n    @Test\n    void cleanEmptyDIV()\n    {\n        String input = \"<div id=\\\"y\\\"></div><div id=\\\"z\\\">something</div>\";\n        assertHTML(input, getHeaderFull() + input + FOOTER);\n    }\n\n    @Test\n    void verifyLegendTagNotStripped()\n    {\n        String input = \"<fieldset><legend>test</legend><div>content</div></fieldset>\";\n        assertHTML(input, getHeaderFull() + input + FOOTER);\n    }\n\n    @Test",
        "code_after_change": "        String actual = \"<p id=\\\"x\\\">1</p><p id=\\\"xy\\\">2</p><p id=\\\"x\\\">3</p>\";\n        String expected = \"<p id=\\\"x\\\">1</p><p id=\\\"xy\\\">2</p><p id=\\\"x0\\\">3</p>\";\n        List<HTMLFilter> filters = new ArrayList<>(this.cleanerConfiguration.getFilters());\n        filters.add(componentManager.getInstance(HTMLFilter.class, \"uniqueId\"));\n        this.cleanerConfiguration.setFilters(filters);\n        assertEquals(getHeaderFull() + expected + FOOTER,\n            HTMLUtils.toString(clean(actual)));\n    }\n\n    /**\n     * Test that tags with a namespace are not considered as unknown tags by HTMLCleaner (see also <a\n     * href=\"https://jira.xwiki.org/browse/XWIKI-9753\">XWIKI-9753</a>).\n     */\n    @Test\n    void cleanSVGTags() throws Exception\n    {\n        String input =\n            \"<p>before</p>\\n\" + \"<p><svg xmlns=\\\"http://www.w3.org/2000/svg\\\" version=\\\"1.1\\\">\\n\"\n                + \"<circle cx=\\\"100\\\" cy=\\\"50\\\" fill=\\\"red\\\" r=\\\"40\\\" stroke=\\\"black\\\" stroke-width=\\\"2\\\"></circle>\\n\"\n                + \"</svg></p>\\n\" + \"<p>after</p>\\n\";\n        assertHTML(input, getHeaderFull() + input + FOOTER);\n    }\n\n    /**\n     * Test that cleaning works when there's a TITLE element in the body (but with a namespace). The issue was that\n     * HTMLCleaner would consider it a duplicate of the TITLE element in the HEAD even though it's namespaced. (see\n     * also\n     * <a href=\"https://jira.xwiki.org/browse/XWIKI-9753\">XWIKI-9753</a>).\n     */\n    @Test\n    void cleanTitleWithNamespace()\n    {\n        // Test with TITLE in HEAD\n        String input =\n            \"<html xmlns=\\\"http://www.w3.org/1999/xhtml\\\" lang=\\\"en\\\">\"\n                + \"<head>\\n\"\n                + \"    <title>Title test</title>\\n\"\n                + \"  </head>\"\n                + \"<body>\\n\"\n                + \"    <p>before</p>\\n\"\n                + \"    <p><svg xmlns=\\\"http://www.w3.org/2000/svg\\\" height=\\\"300\\\" width=\\\"500\\\">\\n\"\n                + \"      <g>\\n\"\n                + \"        <title>SVG Title Demo example</title>\\n\"\n                + \"        <rect height=\\\"50\\\" style=\\\"fill:none; stroke:blue; stroke-width:1px\\\" width=\\\"200\\\" x=\\\"10\\\" \"\n                + \"y=\\\"10\\\"></rect>\\n\" + \"      </g>\\n\" + \"    </svg></p>\\n\" + \"    <p>after</p>\\n\";\n        assertEquals(getHeader() + input + FOOTER,\n            HTMLUtils.toString(clean(input)));\n    }\n\n    /**\n     * Verify that a xmlns namespace set on the HTML element is not removed by default and it's removed if\n     * {@link HTMLCleanerConfiguration#NAMESPACES_AWARE} is set to false.\n     */\n    @Test\n    void cleanHTMLTagWithNamespace()\n    {\n        String input = \"<html xmlns=\\\"http://www.w3.org/1999/xhtml\\\"><head></head><body>\";\n\n        // Default\n        assertEquals(getHeader() + input + FOOTER,\n            HTMLUtils.toString(clean(input)));\n\n        // Configured for namespace awareness being false\n        Map<String, String> parameters = new HashMap<>(this.cleanerConfiguration.getParameters());\n        parameters.put(HTMLCleanerConfiguration.NAMESPACES_AWARE, \"false\");\n        this.cleanerConfiguration.setParameters(parameters);\n        assertEquals(getHeader() + \"<html><head></head><body>\" + FOOTER,\n            HTMLUtils.toString(clean(input)));\n    }\n\n    /**\n     * Check that template tags inside select don't survive, might be security-relevant, DOMPurify contains a similar\n     * check, see <a href=\"https://github.com/cure53/DOMPurify/commit/e32ca248c0e9450fb182e52e978631cbd78f1123\">commit\n     * e32ca248c0 in DOMPurify</a>.\n     */\n    @Test\n    void cleanTemplateInsideSelect()\n    {\n        assertHTML(\"<p><select></select></p>\", \"<select><template></template></select>\");\n    }\n\n    /**\n     * Test that cleaning an empty DIV works (it used to fail, see <a\n     * href=\"https://jira.xwiki.org/browse/XWIKI-4007\">XWIKI-4007</a>).\n     */\n    @Test\n    void cleanEmptyDIV()\n    {",
        "patch": "@@ -36,6 +36,7 @@\n import org.w3c.dom.Document;\n import org.w3c.dom.NodeList;\n import org.xwiki.component.manager.ComponentManager;\n+import org.xwiki.configuration.internal.RestrictedConfigurationSourceProvider;\n import org.xwiki.test.annotation.ComponentList;\n import org.xwiki.test.junit5.mockito.ComponentTest;\n import org.xwiki.test.junit5.mockito.InjectMockComponents;\n@@ -49,6 +50,7 @@\n import org.xwiki.xml.internal.html.filter.LinkFilter;\n import org.xwiki.xml.internal.html.filter.ListFilter;\n import org.xwiki.xml.internal.html.filter.ListItemFilter;\n+import org.xwiki.xml.internal.html.filter.SanitizerFilter;\n import org.xwiki.xml.internal.html.filter.UniqueIdFilter;\n \n import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -71,6 +73,14 @@\n     DefaultHTMLCleaner.class,\n     LinkFilter.class,\n     ControlCharactersFilter.class,\n+    SanitizerFilter.class,\n+    DefaultHTMLElementSanitizer.class,\n+    SecureHTMLElementSanitizer.class,\n+    HTMLElementSanitizerConfiguration.class,\n+    RestrictedConfigurationSourceProvider.class,\n+    HTMLDefinitions.class,\n+    MathMLDefinitions.class,\n+    SVGDefinitions.class,\n     XWikiHTML5TagProvider.class\n })\n // @formatter:on\n@@ -107,7 +117,7 @@ public String getHeaderFull()\n \n     /**\n      * Cleans using the cleaner configuration {@link DefaultHTMLCleanerTest#cleanerConfiguration}.\n-     *\n+     * <p>\n      * Ensures that always the correct configuration is used and allows executing the same tests for HTML 4 and HTML 5.\n      *\n      * @param originalHtmlContent The content to clean as string.\n@@ -322,6 +332,31 @@ void restrictedHtml()\n         assertEquals(getHeaderFull() + \"<pre>p {color:white;}</pre>\" + FOOTER, result);\n     }\n \n+    /**\n+     * Verify that the restricted parameter forbids dangerous attributes and tags.\n+     */\n+    @Test\n+    void restrictedAttributesAndTags() throws Exception\n+    {\n+        Map<String, String> parameters = new HashMap<>(this.cleanerConfiguration.getParameters());\n+        parameters.put(\"restricted\", \"true\");\n+        this.cleanerConfiguration.setParameters(parameters);\n+\n+        assertHTML(\"<p><img src=\\\"img.png\\\" /></p>\", \"<img onerror=\\\"alert(1)\\\" src=img.png />\");\n+        assertHTML(\"<p><a>Hello!</a></p>\", \"<a href=\\\"javascript:alert(1)\\\">Hello!</a>\");\n+        assertHTML(\"<p></p>\", \"<iframe src=\\\"whatever\\\"/>\");\n+\n+        // Check that SVG is still working in restricted mode.\n+        cleanSVGTags();\n+        cleanTitleWithNamespace();\n+\n+        // Check that MathML is still working in restricted mode.\n+        assertHTML(\"<p><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><mtext>X</mtext><mi><span>foo</span>\"\n+                + \"</mi></math></p>\",\n+            \"<math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><span></span><mtext>X</mtext><mi><span>foo</span>\"\n+                + \"</mi></math>\");\n+    }\n+\n     /**\n      * Verify that passing a fully-formed XHTML header works fine.\n      */\n@@ -366,30 +401,29 @@ void cleanSVGTags() throws Exception\n      * also\n      * <a href=\"https://jira.xwiki.org/browse/XWIKI-9753\">XWIKI-9753</a>).\n      */\n-    @Disabled(\"See https://jira.xwiki.org/browse/XWIKI-9753\")\n     @Test\n     void cleanTitleWithNamespace()\n     {\n         // Test with TITLE in HEAD\n         String input =\n-            \"<html xmlns=\\\"http://www.w3.org/1999/xhtml\\\" lang=\\\"en\\\" xml:lang=\\\"en\\\">\\n\"\n-                + \"  <head>\\n\"\n+            \"<html xmlns=\\\"http://www.w3.org/1999/xhtml\\\" lang=\\\"en\\\">\"\n+                + \"<head>\\n\"\n                 + \"    <title>Title test</title>\\n\"\n-                + \"  </head>\\n\"\n-                + \"  <body>\\n\"\n+                + \"  </head>\"\n+                + \"<body>\\n\"\n                 + \"    <p>before</p>\\n\"\n-                + \"    <svg xmlns=\\\"http://www.w3.org/2000/svg\\\" height=\\\"300\\\" width=\\\"500\\\">\\n\"\n+                + \"    <p><svg xmlns=\\\"http://www.w3.org/2000/svg\\\" height=\\\"300\\\" width=\\\"500\\\">\\n\"\n                 + \"      <g>\\n\"\n                 + \"        <title>SVG Title Demo example</title>\\n\"\n                 + \"        <rect height=\\\"50\\\" style=\\\"fill:none; stroke:blue; stroke-width:1px\\\" width=\\\"200\\\" x=\\\"10\\\" \"\n-                + \"y=\\\"10\\\"></rect>\\n\" + \"      </g>\\n\" + \"    </svg>\\n\" + \"    <p>after</p>\\n\";\n+                + \"y=\\\"10\\\"></rect>\\n\" + \"      </g>\\n\" + \"    </svg></p>\\n\" + \"    <p>after</p>\\n\";\n         assertEquals(getHeader() + input + FOOTER,\n             HTMLUtils.toString(clean(input)));\n     }\n \n     /**\n-     * Verify that a xmlns namespace set on the HTML element is not removed by default and it's removed if {@link\n-     * HTMLCleanerConfiguration#NAMESPACES_AWARE} is set to false.\n+     * Verify that a xmlns namespace set on the HTML element is not removed by default and it's removed if\n+     * {@link HTMLCleanerConfiguration#NAMESPACES_AWARE} is set to false.\n      */\n     @Test\n     void cleanHTMLTagWithNamespace()\n@@ -409,7 +443,19 @@ void cleanHTMLTagWithNamespace()\n     }\n \n     /**\n-     * Test that cleaning an empty DIV works (it used to fail, see <a href=\"https://jira.xwiki.org/browse/XWIKI-4007\">XWIKI-4007</a>).\n+     * Check that template tags inside select don't survive, might be security-relevant, DOMPurify contains a similar\n+     * check, see <a href=\"https://github.com/cure53/DOMPurify/commit/e32ca248c0e9450fb182e52e978631cbd78f1123\">commit\n+     * e32ca248c0 in DOMPurify</a>.\n+     */\n+    @Test\n+    void cleanTemplateInsideSelect()\n+    {\n+        assertHTML(\"<p><select></select></p>\", \"<select><template></template></select>\");\n+    }\n+\n+    /**\n+     * Test that cleaning an empty DIV works (it used to fail, see <a\n+     * href=\"https://jira.xwiki.org/browse/XWIKI-4007\">XWIKI-4007</a>).\n      */\n     @Test\n     void cleanEmptyDIV()\n@@ -607,7 +653,7 @@ void divInsideDl()\n \n     /**\n      * Check what happens when the dt-tag is inside div.\n-     *\n+     * <p>\n      * This should add a wrapping dl but doesn't for HTML 4, but it works in HTML5, see\n      * {@link HTML5HTMLCleanerTest#divWithDt()}.\n      *",
        "function_modified_lines": {
            "added": [
                "            \"<html xmlns=\\\"http://www.w3.org/1999/xhtml\\\" lang=\\\"en\\\">\"\n",
                "                + \"<head>\\n\"\n",
                "                + \"  </head>\"\n",
                "                + \"<body>\\n\"\n",
                "                + \"    <p><svg xmlns=\\\"http://www.w3.org/2000/svg\\\" height=\\\"300\\\" width=\\\"500\\\">\\n\"\n",
                "                + \"y=\\\"10\\\"></rect>\\n\" + \"      </g>\\n\" + \"    </svg></p>\\n\" + \"    <p>after</p>\\n\";\n",
                "     * Verify that a xmlns namespace set on the HTML element is not removed by default and it's removed if\n",
                "     * {@link HTMLCleanerConfiguration#NAMESPACES_AWARE} is set to false.\n"
            ],
            "deleted": [
                "    @Disabled(\"See https://jira.xwiki.org/browse/XWIKI-9753\")\n",
                "            \"<html xmlns=\\\"http://www.w3.org/1999/xhtml\\\" lang=\\\"en\\\" xml:lang=\\\"en\\\">\\n\"\n",
                "                + \"  <head>\\n\"\n",
                "                + \"  </head>\\n\"\n",
                "                + \"  <body>\\n\"\n",
                "                + \"    <svg xmlns=\\\"http://www.w3.org/2000/svg\\\" height=\\\"300\\\" width=\\\"500\\\">\\n\"\n",
                "                + \"y=\\\"10\\\"></rect>\\n\" + \"      </g>\\n\" + \"    </svg>\\n\" + \"    <p>after</p>\\n\";\n",
                "     * Verify that a xmlns namespace set on the HTML element is not removed by default and it's removed if {@link\n",
                "     * HTMLCleanerConfiguration#NAMESPACES_AWARE} is set to false.\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-79"
        ],
        "cve_description": "XWiki Commons are technical libraries common to several other top level XWiki projects. The \"restricted\" mode of the HTML cleaner in XWiki, introduced in version 4.2-milestone-1, only escaped `<script>` and `<style>`-tags but neither attributes that can be used to inject scripts nor other dangerous HTML tags like `<iframe>`. As a consequence, any code relying on this \"restricted\" mode for security is vulnerable to JavaScript injection (\"cross-site scripting\"/XSS). When a privileged user with programming rights visits such a comment in XWiki, the malicious JavaScript code is executed in the context of the user session. This allows server-side code execution with programming rights, impacting the confidentiality, integrity and availability of the XWiki instance. This problem has been patched in XWiki 14.6 RC1 with the introduction of a filter with allowed HTML elements and attributes that is enabled in restricted mode. There are no known workarounds apart from upgrading to a version including the fix.",
        "id": 12605
    },
    {
        "cve_id": "CVE-2023-36471",
        "code_before_change": "(\"a\", \"abbr\", \"acronym\", \"address\", \"area\", \"article\", \"aside\", \"audio\", \"b\", \"bdi\", \"bdo\",\n                \"big\", \"blink\", \"blockquote\", \"body\", \"br\", \"button\", \"canvas\", \"caption\", \"center\", \"cite\", \"code\",\n                \"col\", \"colgroup\", \"content\", \"data\", \"datalist\", \"dd\", \"decorator\", \"del\", \"details\", \"dfn\", \"dialog\",\n                \"dir\", \"div\", \"dl\", \"dt\", \"element\", \"em\", \"fieldset\", \"figcaption\", \"figure\", \"font\", \"footer\", \"form\",\n                \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"head\", \"header\", \"hgroup\", \"hr\", \"html\", \"i\", \"img\", \"input\",\n                \"ins\", \"kbd\", \"label\", \"legend\", \"li\", \"main\", \"map\", \"mark\", \"marquee\", \"menu\", \"menuitem\", \"meter\",\n                \"nav\", \"nobr\", \"ol\", \"optgroup\", \"option\", \"output\", \"p\", \"picture\", \"pre\", \"progress\", \"q\", \"rp\", \"rt\",\n                \"ruby\", \"s\", \"samp\", \"section\", \"select\", \"shadow\", \"small\", \"source\", \"spacer\", \"span\", \"strike\",\n                \"strong\", \"style\", \"sub\", \"summary\", \"sup\", \"table\", \"tbody\", \"td\", \"template\", \"textarea\", \"tfoot\",\n                \"th\", \"thead\", \"time\", \"tr\", \"track\", \"tt\", \"u\", \"ul\", \"var\", \"video\", \"wbr\")",
        "code_after_change": "{\n        // Compared to DOMPurify, this disallows form-related tags as they can be dangerous in the context of XWiki.\n        this.htmlTags = new HashSet<>(\n            Arrays.asList(\"a\", \"abbr\", \"acronym\", \"address\", \"area\", \"article\", \"aside\", \"audio\", \"b\", \"bdi\", \"bdo\",\n                \"big\", \"blink\", \"blockquote\", \"body\", \"br\", \"canvas\", \"caption\", \"center\", \"cite\", \"code\",\n                \"col\", \"colgroup\", \"content\", \"data\", \"datalist\", \"dd\", \"decorator\", \"del\", \"details\", \"dfn\", \"dialog\",\n                \"dir\", \"div\", \"dl\", \"dt\", \"element\", \"em\", \"fieldset\", \"figcaption\", \"figure\", \"font\", \"footer\",\n                \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"head\", \"header\", \"hgroup\", \"hr\", \"html\", \"i\", \"img\",\n                \"ins\", \"kbd\", \"label\", \"legend\", \"li\", \"main\", \"map\", \"mark\", \"marquee\", \"menu\", \"menuitem\", \"meter\",\n                \"nav\", \"nobr\", \"ol\", \"optgroup\", \"option\", \"output\", \"p\", \"picture\", \"pre\", \"progress\", \"q\", \"rp\", \"rt\",\n                \"ruby\", \"s\", \"samp\", \"section\", \"shadow\", \"small\", \"source\", \"spacer\", \"span\", \"strike\",\n                \"strong\", \"style\", \"sub\", \"summary\", \"sup\", \"table\", \"tbody\", \"td\", \"template\", \"tfoot\",\n                \"th\", \"thead\", \"time\", \"tr\", \"track\", \"tt\", \"u\", \"ul\", \"var\", \"video\", \"wbr\"));\n\n        // Attributes that are in general allowed. Note that \"target\" is not generally safe, but XWiki contains code\n        // that already adds the necessary attributes to make it safe both in HTMLCleaner and in XHTML rendering.\n        this.htmlAttributes = new HashSet<>(\n            Arrays.asList(\"accept\", \"action\", \"align\", \"alt\", \"autocapitalize\", \"autocomplete\", \"autopictureinpicture\",\n                \"autoplay\", \"background\", \"bgcolor\", \"border\", \"capture\", \"cellpadding\", \"cellspacing\", \"checked\",\n                \"cite\", \"class\", \"clear\", \"color\", \"cols\", \"colspan\", \"controls\", \"controlslist\", \"coords\",\n                \"crossorigin\", \"datetime\", \"decoding\", \"default\", \"dir\", \"disabled\", \"disablepictureinpicture\",\n                \"disableremoteplayback\", \"download\", \"draggable\", \"enctype\", \"enterkeyhint\", \"face\", \"for\", \"headers\",\n                \"height\", \"hidden\", \"high\", \"href\", \"hreflang\", \"id\", \"inputmode\", \"integrity\", \"ismap\", \"kind\",\n                \"label\", \"lang\", \"list\", \"loading\", \"loop\", \"low\", \"max\", \"maxlength\", \"media\", \"method\", \"min\",\n                \"minlength\", \"multiple\", \"muted\", \"name\", \"nonce\", \"noshade\", \"novalidate\", \"nowrap\", \"open\", \"optimum\",\n                \"pattern\", \"placeholder\", \"playsinline\", \"poster\", \"preload\", \"pubdate\", \"radiogroup\", \"readonly\",\n                \"rel\", \"required\", \"rev\", \"reversed\", \"role\", \"rows\", \"rowspan\", \"spellcheck\", \"scope\", \"selected\",\n                \"shape\", \"size\", \"sizes\", \"span\", \"srclang\", \"start\", \"src\", \"srcset\", \"step\", \"style\", \"summary\",\n                \"tabindex\", \"title\", \"translate\", \"type\", \"usemap\", \"valign\", \"value\", \"width\", \"xmlns\", \"slot\",\n                \"target\"));\n    }",
        "patch": "@@ -60,16 +60,17 @@ public class HTMLDefinitions\n      */\n     public HTMLDefinitions()\n     {\n+        // Compared to DOMPurify, this disallows form-related tags as they can be dangerous in the context of XWiki.\n         this.htmlTags = new HashSet<>(\n             Arrays.asList(\"a\", \"abbr\", \"acronym\", \"address\", \"area\", \"article\", \"aside\", \"audio\", \"b\", \"bdi\", \"bdo\",\n-                \"big\", \"blink\", \"blockquote\", \"body\", \"br\", \"button\", \"canvas\", \"caption\", \"center\", \"cite\", \"code\",\n+                \"big\", \"blink\", \"blockquote\", \"body\", \"br\", \"canvas\", \"caption\", \"center\", \"cite\", \"code\",\n                 \"col\", \"colgroup\", \"content\", \"data\", \"datalist\", \"dd\", \"decorator\", \"del\", \"details\", \"dfn\", \"dialog\",\n-                \"dir\", \"div\", \"dl\", \"dt\", \"element\", \"em\", \"fieldset\", \"figcaption\", \"figure\", \"font\", \"footer\", \"form\",\n-                \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"head\", \"header\", \"hgroup\", \"hr\", \"html\", \"i\", \"img\", \"input\",\n+                \"dir\", \"div\", \"dl\", \"dt\", \"element\", \"em\", \"fieldset\", \"figcaption\", \"figure\", \"font\", \"footer\",\n+                \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"head\", \"header\", \"hgroup\", \"hr\", \"html\", \"i\", \"img\",\n                 \"ins\", \"kbd\", \"label\", \"legend\", \"li\", \"main\", \"map\", \"mark\", \"marquee\", \"menu\", \"menuitem\", \"meter\",\n                 \"nav\", \"nobr\", \"ol\", \"optgroup\", \"option\", \"output\", \"p\", \"picture\", \"pre\", \"progress\", \"q\", \"rp\", \"rt\",\n-                \"ruby\", \"s\", \"samp\", \"section\", \"select\", \"shadow\", \"small\", \"source\", \"spacer\", \"span\", \"strike\",\n-                \"strong\", \"style\", \"sub\", \"summary\", \"sup\", \"table\", \"tbody\", \"td\", \"template\", \"textarea\", \"tfoot\",\n+                \"ruby\", \"s\", \"samp\", \"section\", \"shadow\", \"small\", \"source\", \"spacer\", \"span\", \"strike\",\n+                \"strong\", \"style\", \"sub\", \"summary\", \"sup\", \"table\", \"tbody\", \"td\", \"template\", \"tfoot\",\n                 \"th\", \"thead\", \"time\", \"tr\", \"track\", \"tt\", \"u\", \"ul\", \"var\", \"video\", \"wbr\"));\n \n         // Attributes that are in general allowed. Note that \"target\" is not generally safe, but XWiki contains code",
        "function_modified_lines": {
            "added": [
                "        // Compared to DOMPurify, this disallows form-related tags as they can be dangerous in the context of XWiki.\n",
                "                \"big\", \"blink\", \"blockquote\", \"body\", \"br\", \"canvas\", \"caption\", \"center\", \"cite\", \"code\",\n",
                "                \"dir\", \"div\", \"dl\", \"dt\", \"element\", \"em\", \"fieldset\", \"figcaption\", \"figure\", \"font\", \"footer\",\n",
                "                \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"head\", \"header\", \"hgroup\", \"hr\", \"html\", \"i\", \"img\",\n",
                "                \"ruby\", \"s\", \"samp\", \"section\", \"shadow\", \"small\", \"source\", \"spacer\", \"span\", \"strike\",\n",
                "                \"strong\", \"style\", \"sub\", \"summary\", \"sup\", \"table\", \"tbody\", \"td\", \"template\", \"tfoot\",\n"
            ],
            "deleted": [
                "                \"big\", \"blink\", \"blockquote\", \"body\", \"br\", \"button\", \"canvas\", \"caption\", \"center\", \"cite\", \"code\",\n",
                "                \"dir\", \"div\", \"dl\", \"dt\", \"element\", \"em\", \"fieldset\", \"figcaption\", \"figure\", \"font\", \"footer\", \"form\",\n",
                "                \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"head\", \"header\", \"hgroup\", \"hr\", \"html\", \"i\", \"img\", \"input\",\n",
                "                \"ruby\", \"s\", \"samp\", \"section\", \"select\", \"shadow\", \"small\", \"source\", \"spacer\", \"span\", \"strike\",\n",
                "                \"strong\", \"style\", \"sub\", \"summary\", \"sup\", \"table\", \"tbody\", \"td\", \"template\", \"textarea\", \"tfoot\",\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-79"
        ],
        "cve_description": "Xwiki commons is the common modules used by other XWiki top level projects. The HTML sanitizer that is included in XWiki since version 14.6RC1 allowed form and input HTML tags. In the context of XWiki, this allows an attacker without script right to either create forms that can be used for phishing attacks or also in the context of a sheet, the attacker could add an input like `{{html}}<input type=\"hidden\" name=\"content\" value=\"{{groovy}}println(&quot;Hello from Groovy!&quot;)\" />{{/html}}` that would allow remote code execution when it is submitted by an admin (the sheet is rendered as part of the edit form). The attacker would need to ensure that the edit form looks plausible, though, which can be non-trivial as without script right the attacker cannot display the regular content of the document. This has been patched in XWiki 14.10.6 and 15.2RC1 by removing the central form-related tags from the list of allowed tags. Users are advised to upgrade. As a workaround an admin can manually disallow the tags by adding `form, input, select, textarea, button` to the configuration option `xml.htmlElementSanitizer.forbidTags` in the `xwiki.properties` configuration file.",
        "id": 12609
    },
    {
        "cve_id": "CVE-2023-0301",
        "code_before_change": "{\n\n    private MustacheCustomTag() {}\n\n    private static final Pattern ARG_PATTERN = Pattern.compile(\"\\\\[(.*?)]\");\n    private static final String LOCALE_LABEL = \"locale:\";\n\n    static final Mustache.Lambda FORMAT_DATE = (frag, out) -> {\n        String execution = frag.execute().trim();\n        ZonedDateTime d = ZonedDateTime.parse(substring(execution, 0, execution.indexOf(' ')));\n        Pair<String, Optional<Locale>> p = parseParams(execution);\n        if (p.getRight().isPresent()) {\n            out.write(DateTimeFormatter.ofPattern(p.getLeft(), p.getRight().get()).format(d));\n        } else {\n            out.write(DateTimeFormatter.ofPattern(p.getLeft()).format(d));\n        }\n    };\n\n    /**\n     * {{#render-markdown}}[markdown][.html|.text]{{/render-markdown}}\n     * The string must end with either .html or .text, otherwise Markdown won't be parsed\n     * e.g.\n     * {{#render-markdown}}(link)[description].html{{/render-markdown}} will produce HTML output\n     * {{#render-markdown}}(link)[description].text{{/render-markdown}} will produce text/plain output\n     */\n    static final Mustache.Lambda RENDER_MARKDOWN = (frag, out) -> {\n        String execution = frag.execute().strip();\n        if(execution.endsWith(\".html\")) {\n            out.write(renderToHtmlCommonmarkEscaped(StringUtils.removeEnd(execution, \".html\")));\n        } else if(execution.endsWith(\".text\")) {\n            out.write(renderToTextCommonmark(StringUtils.removeEnd(execution, \".text\")));\n        } else {\n            out.write(execution);\n        }\n    };\n\n    static final Mustache.Lambda COUNTRY_NAME = (frag, out) -> {\n        String execution = frag.execute().trim();\n        String code = substring(execution, 0, 2);\n        Pair<String, Optional<Locale>> p = parseParams(execution);\n        out.write(translateCountryCode(code, p.getRight().orElse(null)));\n    };\n\n    static String translateCountryCode(String code, Locale locale) {\n        Locale lang = locale != null ? locale : Locale.ENGLISH;\n        return Stream.concat(TicketHelper.getLocalizedCountries(lang).stream(), TicketHelper.getLocalizedCountriesForVat(lang).stream())\n            .filter(p -> p.getKey().equalsIgnoreCase(code))\n            .map(Pair::getValue)\n            .findFirst()\n            .orElse(code);\n    }\n\n    /**\n     * {{#additional-field-value}}[Prefix][name][suffix]{{/additional-field-value}}\n     * prefix is optional, unless a suffix is needed.\n     */\n    static final Function<Object, Mustache.Lambda> ADDITIONAL_FIELD_VALUE = obj -> (frag, out) -> {\n        if( !(obj instanceof Map) || ((Map<?,?>)obj).isEmpty()) {\n            log.warn(\"map not found or empty. Skipping additionalFieldValue tag\");\n            return;\n        }\n        Map<?, ?> fieldNamesAndValues = (Map<?, ?>) obj;\n        String execution = frag.execute().trim();\n        Matcher matcher = ARG_PATTERN.matcher(execution);\n        List<String> args = new ArrayList<>();\n        while(matcher.find()) {\n            args.add(matcher.group(1));\n        }\n        if(args.isEmpty()) {\n            return;\n        }\n        String name = args.get(args.size() > 1 ? 1 : 0);\n        String prefix = args.size() > 1 ? args.get(0) + \" \" : \"\";\n        String suffix = args.size() > 2 ? \" \"+args.get(2) : \"\";\n\n        if(fieldNamesAndValues.containsKey(name)) {\n            out.write(prefix + fieldNamesAndValues.get(name) + suffix);\n        }\n    };\n\n    private static Pair<String, Optional<Locale>> parseParams(String r) {\n\n        int indexLocale = r.indexOf(LOCALE_LABEL);\n        int end = Math.min(r.length(), indexLocale != -1 ? indexLocale : r.length());\n        String format = substring(r, r.indexOf(' '), end);\n\n        //\n        String[] res = r.split(\"\\\\s+\");\n        Optional<Locale> locale = Arrays.stream(res).filter(s -> s.startsWith(LOCALE_LABEL)).findFirst()\n                .map(l -> LocaleUtil.forLanguageTag(substring(l, LOCALE_LABEL.length())));\n        //\n\n        return Pair.of(format, locale);\n    }\n\n\n    private static final List<Extension> COMMONMARK_EXTENSIONS = List.of(TablesExtension.create());\n    private static final Parser COMMONMARK_PARSER = Parser.builder().extensions(COMMONMARK_EXTENSIONS).build();\n    private static final HtmlRenderer COMMONMARK_RENDERER = HtmlRenderer.builder().extensions(COMMONMARK_EXTENSIONS).attributeProviderFactory((ctx) -> new TargetBlankProvider()).build();\n    private static final TextContentRenderer COMMONMARK_TEXT_RENDERER = TextContentRenderer.builder().extensions(COMMONMARK_EXTENSIONS).build();\n    private static final ThreadLocal<String> A11Y_NEW_TAB_LABEL = new ThreadLocal<>();\n\n    //Open in a new window if the link contains an absolute url\n    private static class TargetBlankProvider implements AttributeProvider {\n        @Override\n        public void setAttributes(Node node, String tagName, Map<String, String> attributes) {\n            if (node instanceof Link) {\n                Link l = (Link) node;\n                String destination = StringUtils.trimToEmpty(l.getDestination());\n                if (UrlUtils.isAbsoluteUrl(destination)) {\n                    attributes.put(\"target\", \"_blank\");\n                    attributes.put(\"rel\", \"nofollow noopener noreferrer\");\n                    var newTabLabel = A11Y_NEW_TAB_LABEL.get();\n                    if (newTabLabel != null) {\n                        attributes.put(\"aria-label\", ((Text)node.getFirstChild()).getLiteral() + \" \" + newTabLabel);\n                    }\n                }\n            }\n        }\n    }\n    public static String renderToHtmlCommonmarkEscaped(String input) {\n        return renderToHtmlCommonmarkEscaped(input, null);\n    }\n\n    public static String renderToHtmlCommonmarkEscaped(String input, String localizedNewWindowLabel) {\n        try {\n            A11Y_NEW_TAB_LABEL.set(localizedNewWindowLabel);\n            Node document = COMMONMARK_PARSER.parse(StringEscapeUtils.escapeHtml4(input));\n            return COMMONMARK_RENDERER.render(document);\n        } finally {\n            A11Y_NEW_TAB_LABEL.remove();\n        }\n    }\n\n    public static String renderToTextCommonmark(String input) {\n        Node document = COMMONMARK_PARSER.parse(input);\n        return COMMONMARK_TEXT_RENDERER.render(document);\n    }\n}",
        "code_after_change": "{\n\n    private MustacheCustomTag() {}\n\n    private static final Pattern ARG_PATTERN = Pattern.compile(\"\\\\[(.*?)]\");\n    private static final String LOCALE_LABEL = \"locale:\";\n\n    static final Mustache.Lambda FORMAT_DATE = (frag, out) -> {\n        String execution = frag.execute().trim();\n        ZonedDateTime d = ZonedDateTime.parse(substring(execution, 0, execution.indexOf(' ')));\n        Pair<String, Optional<Locale>> p = parseParams(execution);\n        if (p.getRight().isPresent()) {\n            out.write(DateTimeFormatter.ofPattern(p.getLeft(), p.getRight().get()).format(d));\n        } else {\n            out.write(DateTimeFormatter.ofPattern(p.getLeft()).format(d));\n        }\n    };\n\n    /**\n     * {{#render-markdown}}[markdown][.html|.text]{{/render-markdown}}\n     * The string must end with either .html or .text, otherwise Markdown won't be parsed\n     * e.g.\n     * {{#render-markdown}}(link)[description].html{{/render-markdown}} will produce HTML output\n     * {{#render-markdown}}(link)[description].text{{/render-markdown}} will produce text/plain output\n     */\n    static final Mustache.Lambda RENDER_MARKDOWN = (frag, out) -> {\n        String execution = frag.execute().strip();\n        if(execution.endsWith(\".html\")) {\n            out.write(renderToHtmlCommonmarkEscaped(StringUtils.removeEnd(execution, \".html\")));\n        } else if(execution.endsWith(\".text\")) {\n            out.write(renderToTextCommonmark(StringUtils.removeEnd(execution, \".text\")));\n        } else {\n            out.write(execution);\n        }\n    };\n\n    static final Mustache.Lambda COUNTRY_NAME = (frag, out) -> {\n        String execution = frag.execute().trim();\n        String code = substring(execution, 0, 2);\n        Pair<String, Optional<Locale>> p = parseParams(execution);\n        out.write(translateCountryCode(code, p.getRight().orElse(null)));\n    };\n\n    static String translateCountryCode(String code, Locale locale) {\n        Locale lang = locale != null ? locale : Locale.ENGLISH;\n        return Stream.concat(TicketHelper.getLocalizedCountries(lang).stream(), TicketHelper.getLocalizedCountriesForVat(lang).stream())\n            .filter(p -> p.getKey().equalsIgnoreCase(code))\n            .map(Pair::getValue)\n            .findFirst()\n            .orElse(code);\n    }\n\n    /**\n     * {{#additional-field-value}}[Prefix][name][suffix]{{/additional-field-value}}\n     * prefix is optional, unless a suffix is needed.\n     */\n    static final Function<Object, Mustache.Lambda> ADDITIONAL_FIELD_VALUE = obj -> (frag, out) -> {\n        if( !(obj instanceof Map) || ((Map<?,?>)obj).isEmpty()) {\n            log.warn(\"map not found or empty. Skipping additionalFieldValue tag\");\n            return;\n        }\n        Map<?, ?> fieldNamesAndValues = (Map<?, ?>) obj;\n        String execution = frag.execute().trim();\n        Matcher matcher = ARG_PATTERN.matcher(execution);\n        List<String> args = new ArrayList<>();\n        while(matcher.find()) {\n            args.add(matcher.group(1));\n        }\n        if(args.isEmpty()) {\n            return;\n        }\n        String name = args.get(args.size() > 1 ? 1 : 0);\n        String prefix = args.size() > 1 ? args.get(0) + \" \" : \"\";\n        String suffix = args.size() > 2 ? \" \"+args.get(2) : \"\";\n\n        if(fieldNamesAndValues.containsKey(name)) {\n            out.write(prefix + fieldNamesAndValues.get(name) + suffix);\n        }\n    };\n\n    private static Pair<String, Optional<Locale>> parseParams(String r) {\n\n        int indexLocale = r.indexOf(LOCALE_LABEL);\n        int end = Math.min(r.length(), indexLocale != -1 ? indexLocale : r.length());\n        String format = substring(r, r.indexOf(' '), end);\n\n        //\n        String[] res = r.split(\"\\\\s+\");\n        Optional<Locale> locale = Arrays.stream(res).filter(s -> s.startsWith(LOCALE_LABEL)).findFirst()\n                .map(l -> LocaleUtil.forLanguageTag(substring(l, LOCALE_LABEL.length())));\n        //\n\n        return Pair.of(format, locale);\n    }\n\n\n    private static final List<Extension> COMMONMARK_EXTENSIONS = List.of(TablesExtension.create());\n    private static final Parser COMMONMARK_PARSER = Parser.builder().extensions(COMMONMARK_EXTENSIONS).build();\n    private static final HtmlRenderer COMMONMARK_RENDERER = HtmlRenderer.builder().extensions(COMMONMARK_EXTENSIONS).attributeProviderFactory((ctx) -> new TargetBlankProvider()).build();\n    private static final TextContentRenderer COMMONMARK_TEXT_RENDERER = TextContentRenderer.builder().extensions(COMMONMARK_EXTENSIONS).build();\n    private static final ThreadLocal<String> A11Y_NEW_TAB_LABEL = new ThreadLocal<>();\n\n    //Open in a new window if the link contains an absolute url\n    private static class TargetBlankProvider implements AttributeProvider {\n        @Override\n        public void setAttributes(Node node, String tagName, Map<String, String> attributes) {\n            if (node instanceof Link) {\n                Link l = (Link) node;\n                String destination = StringUtils.trimToEmpty(l.getDestination());\n                var scheme = getScheme(destination);\n                scheme.ifPresent(resolvedScheme -> {\n                    if (!Set.of(\"http\", \"https\").contains(resolvedScheme)) {\n                        log.info(\"User tried to set an url with scheme {}, only http/https are accepted, href has been removed\", resolvedScheme);\n                        attributes.remove(\"href\");\n                    }\n                });\n                if (UrlUtils.isAbsoluteUrl(destination)) {\n                    // accept only http or https protocols if we have an absolute link, else we override with an empty string\n                    attributes.put(\"target\", \"_blank\");\n                    attributes.put(\"rel\", \"nofollow noopener noreferrer\");\n                    var newTabLabel = A11Y_NEW_TAB_LABEL.get();\n                    if (newTabLabel != null) {\n                        attributes.put(\"aria-label\", ((Text)node.getFirstChild()).getLiteral() + \" \" + newTabLabel);\n                    }\n                }\n            }\n        }\n    }\n    public static String renderToHtmlCommonmarkEscaped(String input) {\n        return renderToHtmlCommonmarkEscaped(input, null);\n    }\n\n    /**\n     * return lowercase scheme if present\n     */\n    private static Optional<String> getScheme(String uri) {\n        var s = StringUtils.trimToEmpty(uri).toLowerCase(Locale.ROOT);\n        return s.indexOf(':') >= 0 ? Optional.of(StringUtils.substringBefore(s, ':')) : Optional.empty();\n    }\n\n    public static String renderToHtmlCommonmarkEscaped(String input, String localizedNewWindowLabel) {\n        try {\n            A11Y_NEW_TAB_LABEL.set(localizedNewWindowLabel);\n            Node document = COMMONMARK_PARSER.parse(StringEscapeUtils.escapeHtml4(input));\n            return COMMONMARK_RENDERER.render(document);\n        } finally {\n            A11Y_NEW_TAB_LABEL.remove();\n        }\n    }\n\n    public static String renderToTextCommonmark(String input) {\n        Node document = COMMONMARK_PARSER.parse(input);\n        return COMMONMARK_TEXT_RENDERER.render(document);\n    }\n}",
        "patch": "@@ -168,7 +168,15 @@ public void setAttributes(Node node, String tagName, Map<String, String> attribu\n             if (node instanceof Link) {\n                 Link l = (Link) node;\n                 String destination = StringUtils.trimToEmpty(l.getDestination());\n+                var scheme = getScheme(destination);\n+                scheme.ifPresent(resolvedScheme -> {\n+                    if (!Set.of(\"http\", \"https\").contains(resolvedScheme)) {\n+                        log.info(\"User tried to set an url with scheme {}, only http/https are accepted, href has been removed\", resolvedScheme);\n+                        attributes.remove(\"href\");\n+                    }\n+                });\n                 if (UrlUtils.isAbsoluteUrl(destination)) {\n+                    // accept only http or https protocols if we have an absolute link, else we override with an empty string\n                     attributes.put(\"target\", \"_blank\");\n                     attributes.put(\"rel\", \"nofollow noopener noreferrer\");\n                     var newTabLabel = A11Y_NEW_TAB_LABEL.get();\n@@ -183,6 +191,14 @@ public static String renderToHtmlCommonmarkEscaped(String input) {\n         return renderToHtmlCommonmarkEscaped(input, null);\n     }\n \n+    /**\n+     * return lowercase scheme if present\n+     */\n+    private static Optional<String> getScheme(String uri) {\n+        var s = StringUtils.trimToEmpty(uri).toLowerCase(Locale.ROOT);\n+        return s.indexOf(':') >= 0 ? Optional.of(StringUtils.substringBefore(s, ':')) : Optional.empty();\n+    }\n+\n     public static String renderToHtmlCommonmarkEscaped(String input, String localizedNewWindowLabel) {\n         try {\n             A11Y_NEW_TAB_LABEL.set(localizedNewWindowLabel);",
        "function_modified_lines": {
            "added": [
                "                var scheme = getScheme(destination);\n",
                "                scheme.ifPresent(resolvedScheme -> {\n",
                "                    if (!Set.of(\"http\", \"https\").contains(resolvedScheme)) {\n",
                "                        log.info(\"User tried to set an url with scheme {}, only http/https are accepted, href has been removed\", resolvedScheme);\n",
                "                        attributes.remove(\"href\");\n",
                "                    }\n",
                "                });\n",
                "                    // accept only http or https protocols if we have an absolute link, else we override with an empty string\n",
                "    /**\n",
                "     * return lowercase scheme if present\n",
                "     */\n",
                "    private static Optional<String> getScheme(String uri) {\n",
                "        var s = StringUtils.trimToEmpty(uri).toLowerCase(Locale.ROOT);\n",
                "        return s.indexOf(':') >= 0 ? Optional.of(StringUtils.substringBefore(s, ':')) : Optional.empty();\n",
                "    }\n",
                "\n"
            ],
            "deleted": []
        },
        "lang": "Java",
        "cwe": [
            "CWE-79"
        ],
        "cve_description": "Cross-site Scripting (XSS) - Stored in GitHub repository alfio-event/alf.io prior to Alf.io 2.0-M4-2301.",
        "id": 12697
    },
    {
        "cve_id": "CVE-2023-32070",
        "code_before_change": "{\n    private static final String ELEM_SPAN = \"span\";\n\n    private static final String ELEM_PRE = \"pre\";\n\n    private static final String PROP_CLASS = \"class\";\n\n    private static final String FIGURE_TAG = \"figure\";\n\n    private static final String FIGURE_CAPTION_TAG = \"figcaption\";\n\n    /**\n     * @param linkRenderer the object to render link events into XHTML. This is done so that it's pluggable because link\n     * rendering depends on how the underlying system wants to handle it. For example for XWiki we check if the document\n     * exists, we get the document URL, etc.\n     * @param imageRenderer the object to render image events into XHTML. This is done so that it's pluggable because\n     * image rendering depends on how the underlying system wants to handle it. For example for XWiki we check if the\n     * image exists as a document attachments, we get its URL, etc.\n     * @param listenerChain the chain of listener filters used to compute various states\n     */\n    public HTML5ChainingRenderer(XHTMLLinkRenderer linkRenderer,\n            XHTMLImageRenderer imageRenderer,\n            ListenerChain listenerChain)\n    {\n        super(linkRenderer, imageRenderer, listenerChain);\n    }\n\n    @Override\n    public void beginFormat(Format format, Map<String, String> parameters)\n    {\n        // Right now, the only difference with the super class is about the \"monospace\" format\n        if (format == Format.MONOSPACE) {\n            Map<String, String> attributes = new HashMap<>();\n            attributes.putAll(parameters);\n            String cssClass = \"monospace\";\n            // The element may already have a class\n            if (attributes.containsKey(PROP_CLASS)) {\n                cssClass = String.format(\"%s %s\", cssClass, attributes.get(PROP_CLASS));\n            }\n            attributes.put(PROP_CLASS, cssClass);\n            getXHTMLWikiPrinter().printXMLStartElement(ELEM_SPAN, attributes);\n        } else {\n            // Call the super class\n            super.beginFormat(format, parameters);\n        }\n\n    }\n\n    @Override\n    public void endFormat(Format format, Map<String, String> parameters)\n    {\n        if (!parameters.isEmpty()) {\n            getXHTMLWikiPrinter().printXMLEndElement(ELEM_SPAN);\n        }\n        // Right now, the only difference with the super class is about the \"monospace\" format\n        if (format == Format.MONOSPACE) {\n            if (parameters.isEmpty()) {\n                // if the parameters are not empty, the span element has already been closed\n                getXHTMLWikiPrinter().printXMLEndElement(ELEM_SPAN);\n            }\n        } else {\n            // Call the super class, with an empty parameters map to avoid closing the span element twice\n            super.endFormat(format, new HashMap<String, String>());\n        }\n    }\n\n    @Override\n    public void onVerbatim(String content, boolean inline, Map<String, String> parameters)\n    {\n        if (inline) {\n            // Note: We generate a span element rather than a pre element since pre elements cannot be located inside\n            // paragraphs for example.\n            // The class is what is expected by wikimodel to understand the span as meaning a verbatim and not a\n            // Monospace element.\n            getXHTMLWikiPrinter().printXMLStartElement(ELEM_SPAN,\n                new String[][] { { PROP_CLASS, \"wikimodel-verbatim\" } });\n            getXHTMLWikiPrinter().printXML(content);\n            getXHTMLWikiPrinter().printXMLEndElement(ELEM_SPAN);\n        } else {\n            getXHTMLWikiPrinter().printXMLStartElement(ELEM_PRE, parameters);\n            getXHTMLWikiPrinter().printXML(content);\n            getXHTMLWikiPrinter().printXMLEndElement(ELEM_PRE);\n        }\n    }\n\n    @Override\n    public void beginFigure(Map<String, String> parameters)\n    {\n        getXHTMLWikiPrinter().printXMLStartElement(FIGURE_TAG, parameters);\n    }\n\n    @Override\n    public void beginFigureCaption(Map<String, String> parameters)\n    {\n        getXHTMLWikiPrinter().printXMLStartElement(FIGURE_CAPTION_TAG, parameters);\n    }\n\n    @Override\n    public void endFigure(Map<String, String> parameters)\n    {\n        getXHTMLWikiPrinter().printXMLEndElement(FIGURE_TAG);\n    }\n\n    @Override\n    public void endFigureCaption(Map<String, String> parameters)\n    {\n        getXHTMLWikiPrinter().printXMLEndElement(FIGURE_CAPTION_TAG);\n    }\n}",
        "code_after_change": "{\n    private static final String ELEM_SPAN = \"span\";\n\n    private static final String ELEM_PRE = \"pre\";\n\n    private static final String PROP_CLASS = \"class\";\n\n    private static final String FIGURE_TAG = \"figure\";\n\n    private static final String FIGURE_CAPTION_TAG = \"figcaption\";\n\n    /**\n     * @param linkRenderer the object to render link events into XHTML. This is done so that it's pluggable because link\n     * rendering depends on how the underlying system wants to handle it. For example for XWiki we check if the document\n     * exists, we get the document URL, etc.\n     * @param imageRenderer the object to render image events into XHTML. This is done so that it's pluggable because\n     * image rendering depends on how the underlying system wants to handle it. For example for XWiki we check if the\n     * image exists as a document attachments, we get its URL, etc.\n     * @param htmlElementSanitizer the sanitizer to use for sanitizing HTML elements and attributes\n     * @param listenerChain the chain of listener filters used to compute various states\n     */\n    public HTML5ChainingRenderer(XHTMLLinkRenderer linkRenderer,\n            XHTMLImageRenderer imageRenderer, HTMLElementSanitizer htmlElementSanitizer,\n            ListenerChain listenerChain)\n    {\n        super(linkRenderer, imageRenderer, htmlElementSanitizer, listenerChain);\n    }\n\n    @Override\n    public void beginFormat(Format format, Map<String, String> parameters)\n    {\n        // Right now, the only difference with the super class is about the \"monospace\" format\n        if (format == Format.MONOSPACE) {\n            Map<String, String> attributes = new LinkedHashMap<>(parameters);\n            String cssClass = \"monospace\";\n            // The element may already have a class\n            if (attributes.containsKey(PROP_CLASS)) {\n                cssClass = String.format(\"%s %s\", cssClass, attributes.get(PROP_CLASS));\n            }\n            attributes.put(PROP_CLASS, cssClass);\n            getXHTMLWikiPrinter().printXMLStartElement(ELEM_SPAN, attributes);\n        } else {\n            // Call the super class\n            super.beginFormat(format, parameters);\n        }\n\n    }\n\n    @Override\n    public void endFormat(Format format, Map<String, String> parameters)\n    {\n        if (!parameters.isEmpty()) {\n            getXHTMLWikiPrinter().printXMLEndElement(ELEM_SPAN);\n        }\n        // Right now, the only difference with the super class is about the \"monospace\" format\n        if (format == Format.MONOSPACE) {\n            if (parameters.isEmpty()) {\n                // if the parameters are not empty, the span element has already been closed\n                getXHTMLWikiPrinter().printXMLEndElement(ELEM_SPAN);\n            }\n        } else {\n            // Call the super class, with an empty parameters map to avoid closing the span element twice\n            super.endFormat(format, new HashMap<String, String>());\n        }\n    }\n\n    @Override\n    public void onVerbatim(String content, boolean inline, Map<String, String> parameters)\n    {\n        if (inline) {\n            // Note: We generate a span element rather than a pre element since pre elements cannot be located inside\n            // paragraphs for example.\n            // The class is what is expected by wikimodel to understand the span as meaning a verbatim and not a\n            // Monospace element.\n            getXHTMLWikiPrinter().printXMLStartElement(ELEM_SPAN,\n                new String[][] { { PROP_CLASS, \"wikimodel-verbatim\" } });\n            getXHTMLWikiPrinter().printXML(content);\n            getXHTMLWikiPrinter().printXMLEndElement(ELEM_SPAN);\n        } else {\n            getXHTMLWikiPrinter().printXMLStartElement(ELEM_PRE, parameters);\n            getXHTMLWikiPrinter().printXML(content);\n            getXHTMLWikiPrinter().printXMLEndElement(ELEM_PRE);\n        }\n    }\n\n    @Override\n    public void beginFigure(Map<String, String> parameters)\n    {\n        getXHTMLWikiPrinter().printXMLStartElement(FIGURE_TAG, parameters);\n    }\n\n    @Override\n    public void beginFigureCaption(Map<String, String> parameters)\n    {\n        getXHTMLWikiPrinter().printXMLStartElement(FIGURE_CAPTION_TAG, parameters);\n    }\n\n    @Override\n    public void endFigure(Map<String, String> parameters)\n    {\n        getXHTMLWikiPrinter().printXMLEndElement(FIGURE_TAG);\n    }\n\n    @Override\n    public void endFigureCaption(Map<String, String> parameters)\n    {\n        getXHTMLWikiPrinter().printXMLEndElement(FIGURE_CAPTION_TAG);\n    }\n}",
        "patch": "@@ -20,13 +20,15 @@\n package org.xwiki.rendering.internal.renderer.html5;\n \n import java.util.HashMap;\n+import java.util.LinkedHashMap;\n import java.util.Map;\n \n import org.xwiki.rendering.internal.renderer.xhtml.XHTMLChainingRenderer;\n import org.xwiki.rendering.internal.renderer.xhtml.image.XHTMLImageRenderer;\n import org.xwiki.rendering.internal.renderer.xhtml.link.XHTMLLinkRenderer;\n import org.xwiki.rendering.listener.Format;\n import org.xwiki.rendering.listener.chaining.ListenerChain;\n+import org.xwiki.xml.html.HTMLElementSanitizer;\n \n /**\n  * Convert listener events to HTML5.\n@@ -53,22 +55,22 @@ public class HTML5ChainingRenderer extends XHTMLChainingRenderer\n      * @param imageRenderer the object to render image events into XHTML. This is done so that it's pluggable because\n      * image rendering depends on how the underlying system wants to handle it. For example for XWiki we check if the\n      * image exists as a document attachments, we get its URL, etc.\n+     * @param htmlElementSanitizer the sanitizer to use for sanitizing HTML elements and attributes\n      * @param listenerChain the chain of listener filters used to compute various states\n      */\n     public HTML5ChainingRenderer(XHTMLLinkRenderer linkRenderer,\n-            XHTMLImageRenderer imageRenderer,\n+            XHTMLImageRenderer imageRenderer, HTMLElementSanitizer htmlElementSanitizer,\n             ListenerChain listenerChain)\n     {\n-        super(linkRenderer, imageRenderer, listenerChain);\n+        super(linkRenderer, imageRenderer, htmlElementSanitizer, listenerChain);\n     }\n \n     @Override\n     public void beginFormat(Format format, Map<String, String> parameters)\n     {\n         // Right now, the only difference with the super class is about the \"monospace\" format\n         if (format == Format.MONOSPACE) {\n-            Map<String, String> attributes = new HashMap<>();\n-            attributes.putAll(parameters);\n+            Map<String, String> attributes = new LinkedHashMap<>(parameters);\n             String cssClass = \"monospace\";\n             // The element may already have a class\n             if (attributes.containsKey(PROP_CLASS)) {",
        "function_modified_lines": {
            "added": [
                "     * @param htmlElementSanitizer the sanitizer to use for sanitizing HTML elements and attributes\n",
                "            XHTMLImageRenderer imageRenderer, HTMLElementSanitizer htmlElementSanitizer,\n",
                "        super(linkRenderer, imageRenderer, htmlElementSanitizer, listenerChain);\n",
                "            Map<String, String> attributes = new LinkedHashMap<>(parameters);\n"
            ],
            "deleted": [
                "            XHTMLImageRenderer imageRenderer,\n",
                "        super(linkRenderer, imageRenderer, listenerChain);\n",
                "            Map<String, String> attributes = new HashMap<>();\n",
                "            attributes.putAll(parameters);\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-79"
        ],
        "cve_description": "XWiki Platform is a generic wiki platform. Prior to version 14.6-rc-1, HTML rendering didn't check for dangerous attributes/attribute values. This allowed cross-site scripting (XSS) attacks via attributes and link URLs, e.g., supported in XWiki syntax. This has been patched in XWiki 14.6-rc-1. There are no known workarounds apart from upgrading to a fixed version.",
        "id": 12703
    },
    {
        "cve_id": "CVE-2023-32070",
        "code_before_change": "import org.xwiki.rendering.listener.reference.ResourceReference;\nimport org.xwiki.rendering.renderer.AbstractChainingPrintRenderer;\nimport org.xwiki.rendering.renderer.printer.WikiPrinter;\nimport org.xwiki.rendering.renderer.printer.XHTMLWikiPrinter;\nimport org.xwiki.rendering.syntax.Syntax;\nimport org.xwiki.rendering.syntax.SyntaxType;\nimport org.xwiki.xml.html.HTMLConstants;\n\n/**\n * Convert listener events to XHTML.\n *\n * @version $Id$\n * @since 1.8RC1\n */\npublic class XHTMLChainingRenderer extends AbstractChainingPrintRenderer\n{\n    /**\n     * Class attribute value that indicates if the header was generated by a macro.\n     */\n    public static final String GENERATEDHEADERCLASS = \"wikigeneratedheader\";\n\n    /**\n     * Class attribute value that indicates if the header id attribute was generated automatically or if it was the user\n     * who specified an id.\n     */\n    public static final String GENERATEDIDCLASS = \"wikigeneratedid\";\n\n    private XHTMLLinkRenderer linkRenderer;\n\n    private XHTMLImageRenderer imageRenderer;\n\n    private XHTMLWikiPrinter xhtmlWikiPrinter;\n\n    /**\n     * @param linkRenderer the object to render link events into XHTML. This is done so that it's pluggable because link\n     *            rendering depends on how the underlying system wants to handle it. For example for XWiki we check if\n     *            the document exists, we get the document URL, etc.\n     * @param imageRenderer the object to render image events into XHTML. This is done so that it's pluggable because\n     *            image rendering depends on how the underlying system wants to handle it. For example for XWiki we\n     *            check if the image exists as a document attachments, we get its URL, etc.\n     * @param listenerChain the chain of listener filters used to compute various states\n     */\n    public XHTMLChainingRenderer(XHTMLLinkRenderer linkRenderer, XHTMLImageRenderer imageRenderer,\n        ListenerChain listenerChain)\n    {\n        setListenerChain(listenerChain);\n\n        this.linkRenderer = linkRenderer;\n        this.imageRenderer = imageRenderer;\n    }\n\n    // State\n\n    protected BlockStateChainingListener getBlockState()\n    {\n        return (BlockStateChainingListener) getListenerChain().getListener(BlockStateChainingListener.class);\n    }\n\n    protected EmptyBlockChainingListener getEmptyBlockState()\n    {\n        return (EmptyBlockChainingListener) getListenerChain().getListener(EmptyBlockChainingListener.class);\n    }\n\n    protected MetaDataStateChainingListener getMetaDataState()\n    {\n        return (MetaDataStateChainingListener) getListenerChain().getListener(MetaDataStateChainingListener.class);\n    }\n\n    // Printer\n\n    @Override\n    protected void pushPrinter(WikiPrinter wikiPrinter)\n    {\n        super.pushPrinter(wikiPrinter);\n        getXHTMLWikiPrinter().setWikiPrinter(getPrinter());\n    }\n\n    @Override\n    protected void popPrinter()\n    {",
        "code_after_change": "import org.xwiki.rendering.listener.chaining.ListenerChain;\nimport org.xwiki.rendering.listener.chaining.MetaDataStateChainingListener;\nimport org.xwiki.rendering.listener.reference.ResourceReference;\nimport org.xwiki.rendering.renderer.AbstractChainingPrintRenderer;\nimport org.xwiki.rendering.renderer.printer.WikiPrinter;\nimport org.xwiki.rendering.renderer.printer.XHTMLWikiPrinter;\nimport org.xwiki.rendering.syntax.Syntax;\nimport org.xwiki.rendering.syntax.SyntaxType;\nimport org.xwiki.xml.html.HTMLConstants;\nimport org.xwiki.xml.html.HTMLElementSanitizer;\n\n/**\n * Convert listener events to XHTML.\n *\n * @version $Id$\n * @since 1.8RC1\n */\npublic class XHTMLChainingRenderer extends AbstractChainingPrintRenderer\n{\n    /**\n     * Class attribute value that indicates if the header was generated by a macro.\n     */\n    public static final String GENERATEDHEADERCLASS = \"wikigeneratedheader\";\n\n    /**\n     * Class attribute value that indicates if the header id attribute was generated automatically or if it was the user\n     * who specified an id.\n     */\n    public static final String GENERATEDIDCLASS = \"wikigeneratedid\";\n\n    private XHTMLLinkRenderer linkRenderer;\n\n    private XHTMLImageRenderer imageRenderer;\n\n    private final HTMLElementSanitizer htmlElementSanitizer;\n\n    private XHTMLWikiPrinter xhtmlWikiPrinter;\n\n    /**\n     * @param linkRenderer the object to render link events into XHTML. This is done so that it's pluggable because\n     *     link rendering depends on how the underlying system wants to handle it. For example for XWiki we check if the\n     *     document exists, we get the document URL, etc.\n     * @param imageRenderer the object to render image events into XHTML. This is done so that it's pluggable\n     *     because image rendering depends on how the underlying system wants to handle it. For example for XWiki we\n     *     check if the image exists as a document attachments, we get its URL, etc.\n     * @param htmlElementSanitizer the sanitizer for XHTML elements\n     * @param listenerChain the chain of listener filters used to compute various states\n     */\n    public XHTMLChainingRenderer(XHTMLLinkRenderer linkRenderer, XHTMLImageRenderer imageRenderer,\n        HTMLElementSanitizer htmlElementSanitizer, ListenerChain listenerChain)\n    {\n        setListenerChain(listenerChain);\n\n        this.linkRenderer = linkRenderer;\n        this.imageRenderer = imageRenderer;\n        this.htmlElementSanitizer = htmlElementSanitizer;\n    }\n\n    // State\n\n    protected BlockStateChainingListener getBlockState()\n    {\n        return (BlockStateChainingListener) getListenerChain().getListener(BlockStateChainingListener.class);\n    }\n\n    protected EmptyBlockChainingListener getEmptyBlockState()\n    {\n        return (EmptyBlockChainingListener) getListenerChain().getListener(EmptyBlockChainingListener.class);\n    }\n\n    protected MetaDataStateChainingListener getMetaDataState()\n    {\n        return (MetaDataStateChainingListener) getListenerChain().getListener(MetaDataStateChainingListener.class);\n    }\n\n    // Printer\n\n    @Override\n    protected void pushPrinter(WikiPrinter wikiPrinter)\n    {\n        super.pushPrinter(wikiPrinter);\n        getXHTMLWikiPrinter().setWikiPrinter(getPrinter());\n    }\n\n    @Override\n    protected void popPrinter()\n    {\n        super.popPrinter();\n        getXHTMLWikiPrinter().setWikiPrinter(getPrinter());\n    }\n\n    protected XHTMLWikiPrinter getXHTMLWikiPrinter()",
        "patch": "@@ -41,6 +41,7 @@\n import org.xwiki.rendering.syntax.Syntax;\n import org.xwiki.rendering.syntax.SyntaxType;\n import org.xwiki.xml.html.HTMLConstants;\n+import org.xwiki.xml.html.HTMLElementSanitizer;\n \n /**\n  * Convert listener events to XHTML.\n@@ -65,24 +66,28 @@ public class XHTMLChainingRenderer extends AbstractChainingPrintRenderer\n \n     private XHTMLImageRenderer imageRenderer;\n \n+    private final HTMLElementSanitizer htmlElementSanitizer;\n+\n     private XHTMLWikiPrinter xhtmlWikiPrinter;\n \n     /**\n-     * @param linkRenderer the object to render link events into XHTML. This is done so that it's pluggable because link\n-     *            rendering depends on how the underlying system wants to handle it. For example for XWiki we check if\n-     *            the document exists, we get the document URL, etc.\n-     * @param imageRenderer the object to render image events into XHTML. This is done so that it's pluggable because\n-     *            image rendering depends on how the underlying system wants to handle it. For example for XWiki we\n-     *            check if the image exists as a document attachments, we get its URL, etc.\n+     * @param linkRenderer the object to render link events into XHTML. This is done so that it's pluggable because\n+     *     link rendering depends on how the underlying system wants to handle it. For example for XWiki we check if the\n+     *     document exists, we get the document URL, etc.\n+     * @param imageRenderer the object to render image events into XHTML. This is done so that it's pluggable\n+     *     because image rendering depends on how the underlying system wants to handle it. For example for XWiki we\n+     *     check if the image exists as a document attachments, we get its URL, etc.\n+     * @param htmlElementSanitizer the sanitizer for XHTML elements\n      * @param listenerChain the chain of listener filters used to compute various states\n      */\n     public XHTMLChainingRenderer(XHTMLLinkRenderer linkRenderer, XHTMLImageRenderer imageRenderer,\n-        ListenerChain listenerChain)\n+        HTMLElementSanitizer htmlElementSanitizer, ListenerChain listenerChain)\n     {\n         setListenerChain(listenerChain);\n \n         this.linkRenderer = linkRenderer;\n         this.imageRenderer = imageRenderer;\n+        this.htmlElementSanitizer = htmlElementSanitizer;\n     }\n \n     // State\n@@ -121,11 +126,16 @@ protected void popPrinter()\n     protected XHTMLWikiPrinter getXHTMLWikiPrinter()\n     {\n         if (this.xhtmlWikiPrinter == null) {\n-            this.xhtmlWikiPrinter = new XHTMLWikiPrinter(getPrinter());\n+            this.xhtmlWikiPrinter = new XHTMLWikiPrinter(getPrinter(), getHtmlElementSanitizer());\n         }\n         return this.xhtmlWikiPrinter;\n     }\n \n+    protected HTMLElementSanitizer getHtmlElementSanitizer()\n+    {\n+        return this.htmlElementSanitizer;\n+    }\n+\n     // Events\n \n     @Override",
        "function_modified_lines": {
            "added": [
                "    private final HTMLElementSanitizer htmlElementSanitizer;\n",
                "\n",
                "     * @param linkRenderer the object to render link events into XHTML. This is done so that it's pluggable because\n",
                "     *     link rendering depends on how the underlying system wants to handle it. For example for XWiki we check if the\n",
                "     *     document exists, we get the document URL, etc.\n",
                "     * @param imageRenderer the object to render image events into XHTML. This is done so that it's pluggable\n",
                "     *     because image rendering depends on how the underlying system wants to handle it. For example for XWiki we\n",
                "     *     check if the image exists as a document attachments, we get its URL, etc.\n",
                "     * @param htmlElementSanitizer the sanitizer for XHTML elements\n",
                "        HTMLElementSanitizer htmlElementSanitizer, ListenerChain listenerChain)\n",
                "        this.htmlElementSanitizer = htmlElementSanitizer;\n"
            ],
            "deleted": [
                "     * @param linkRenderer the object to render link events into XHTML. This is done so that it's pluggable because link\n",
                "     *            rendering depends on how the underlying system wants to handle it. For example for XWiki we check if\n",
                "     *            the document exists, we get the document URL, etc.\n",
                "     * @param imageRenderer the object to render image events into XHTML. This is done so that it's pluggable because\n",
                "     *            image rendering depends on how the underlying system wants to handle it. For example for XWiki we\n",
                "     *            check if the image exists as a document attachments, we get its URL, etc.\n",
                "        ListenerChain listenerChain)\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-79"
        ],
        "cve_description": "XWiki Platform is a generic wiki platform. Prior to version 14.6-rc-1, HTML rendering didn't check for dangerous attributes/attribute values. This allowed cross-site scripting (XSS) attacks via attributes and link URLs, e.g., supported in XWiki syntax. This has been patched in XWiki 14.6-rc-1. There are no known workarounds apart from upgrading to a fixed version.",
        "id": 12705
    },
    {
        "cve_id": "CVE-2023-32070",
        "code_before_change": "{\n    /**\n     * Those events are hard to test since there's no easy syntax to input them (requires XWiki 2.0+ Syntax with a\n     * Macro transformation applied).\n     */\n    @Test\n    void outputFigureCaptionEvents()\n    {\n        XHTMLChainingRenderer renderer = new XHTMLChainingRenderer(null, null, new ListenerChain());\n        WikiPrinter wikiPrinter = new DefaultWikiPrinter();\n        renderer.setPrinter(wikiPrinter);\n        renderer.beginFigureCaption(Collections.emptyMap());\n        renderer.onWord(\"caption\");\n        renderer.endFigureCaption(Collections.emptyMap());\n\n        assertEquals(\"<div class=\\\"figcaption\\\">caption</div>\", wikiPrinter.toString());\n    }\n\n    @Test\n    void onRawText()\n    {\n        XHTMLChainingRenderer renderer = new XHTMLChainingRenderer(null, null, new ListenerChain());\n        WikiPrinter wikiPrinter = new DefaultWikiPrinter();\n        renderer.setPrinter(wikiPrinter);\n        renderer.onRawText(\"xhtml/1.0\", Syntax.XHTML_1_0);\n        renderer.onRawText(\"html/4.01\", Syntax.HTML_4_01);\n        renderer.onRawText(\"html/5.0\", Syntax.HTML_5_0);\n        renderer.onRawText(\"annotatedxhtml/1.0\", Syntax.ANNOTATED_XHTML_1_0);\n        renderer.onRawText(\"annotatedhtml/5.0\", Syntax.ANNOTATED_HTML_5_0);\n        renderer.onRawText(\"plain/1.0\", Syntax.PLAIN_1_0);\n\n        assertEquals(\"xhtml/1.0html/4.01html/5.0annotatedxhtml/1.0annotatedhtml/5.0\", wikiPrinter.toString());\n    }\n}",
        "code_after_change": "{\n    /**\n     * Those events are hard to test since there's no easy syntax to input them (requires XWiki 2.0+ Syntax with a\n     * Macro transformation applied).\n     */\n    @Test\n    void outputFigureCaptionEvents()\n    {\n        XHTMLChainingRenderer renderer = new XHTMLChainingRenderer(null, null, null, new ListenerChain());\n        WikiPrinter wikiPrinter = new DefaultWikiPrinter();\n        renderer.setPrinter(wikiPrinter);\n        renderer.beginFigureCaption(Collections.emptyMap());\n        renderer.onWord(\"caption\");\n        renderer.endFigureCaption(Collections.emptyMap());\n\n        assertEquals(\"<div class=\\\"figcaption\\\">caption</div>\", wikiPrinter.toString());\n    }\n\n    @Test\n    void onRawText()\n    {\n        XHTMLChainingRenderer renderer = new XHTMLChainingRenderer(null, null, null, new ListenerChain());\n        WikiPrinter wikiPrinter = new DefaultWikiPrinter();\n        renderer.setPrinter(wikiPrinter);\n        renderer.onRawText(\"xhtml/1.0\", Syntax.XHTML_1_0);\n        renderer.onRawText(\"html/4.01\", Syntax.HTML_4_01);\n        renderer.onRawText(\"html/5.0\", Syntax.HTML_5_0);\n        renderer.onRawText(\"annotatedxhtml/1.0\", Syntax.ANNOTATED_XHTML_1_0);\n        renderer.onRawText(\"annotatedhtml/5.0\", Syntax.ANNOTATED_HTML_5_0);\n        renderer.onRawText(\"plain/1.0\", Syntax.PLAIN_1_0);\n\n        assertEquals(\"xhtml/1.0html/4.01html/5.0annotatedxhtml/1.0annotatedhtml/5.0\", wikiPrinter.toString());\n    }\n}",
        "patch": "@@ -44,7 +44,7 @@ class XHTMLChainingRendererTest\n     @Test\n     void outputFigureCaptionEvents()\n     {\n-        XHTMLChainingRenderer renderer = new XHTMLChainingRenderer(null, null, new ListenerChain());\n+        XHTMLChainingRenderer renderer = new XHTMLChainingRenderer(null, null, null, new ListenerChain());\n         WikiPrinter wikiPrinter = new DefaultWikiPrinter();\n         renderer.setPrinter(wikiPrinter);\n         renderer.beginFigureCaption(Collections.emptyMap());\n@@ -57,7 +57,7 @@ void outputFigureCaptionEvents()\n     @Test\n     void onRawText()\n     {\n-        XHTMLChainingRenderer renderer = new XHTMLChainingRenderer(null, null, new ListenerChain());\n+        XHTMLChainingRenderer renderer = new XHTMLChainingRenderer(null, null, null, new ListenerChain());\n         WikiPrinter wikiPrinter = new DefaultWikiPrinter();\n         renderer.setPrinter(wikiPrinter);\n         renderer.onRawText(\"xhtml/1.0\", Syntax.XHTML_1_0);",
        "function_modified_lines": {
            "added": [
                "        XHTMLChainingRenderer renderer = new XHTMLChainingRenderer(null, null, null, new ListenerChain());\n",
                "        XHTMLChainingRenderer renderer = new XHTMLChainingRenderer(null, null, null, new ListenerChain());\n"
            ],
            "deleted": [
                "        XHTMLChainingRenderer renderer = new XHTMLChainingRenderer(null, null, new ListenerChain());\n",
                "        XHTMLChainingRenderer renderer = new XHTMLChainingRenderer(null, null, new ListenerChain());\n"
            ]
        },
        "lang": "Java",
        "cwe": [
            "CWE-79"
        ],
        "cve_description": "XWiki Platform is a generic wiki platform. Prior to version 14.6-rc-1, HTML rendering didn't check for dangerous attributes/attribute values. This allowed cross-site scripting (XSS) attacks via attributes and link URLs, e.g., supported in XWiki syntax. This has been patched in XWiki 14.6-rc-1. There are no known workarounds apart from upgrading to a fixed version.",
        "id": 12707
    },
    {
        "cve_id": "CVE-2023-37908",
        "code_before_change": "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.rendering.renderer.printer;\n\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.CsvSource;\n\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.verify;\n\n/**\n * Unit tests for {@link XHTMLWikiPrinter}.\n *\n * @version $Id$\n */\nclass XHTMLWikiPrinterTest\n{\n    @ParameterizedTest\n    @CsvSource({\n        \"Closing the {{/html}} macro., Closing the &#123;&#123;/html}} macro.\",\n        \"Starting a macro {, Starting a macro &#123;\",\n        \"Partial: {{/h, Partial: {&#123;/h\",\n        \"{{html}}, {{html}}\"\n    })\n    void testRawEscaping(String input, String expected)\n    {\n        WikiPrinter mockPrinter = mock(WikiPrinter.class);\n        XHTMLWikiPrinter xhtmlWikiPrinter = new XHTMLWikiPrinter(mockPrinter);\n        xhtmlWikiPrinter.printRaw(input);\n        verify(mockPrinter).print(expected);\n    }\n}\n",
        "code_after_change": "{\n    @ParameterizedTest\n    @CsvSource({\n        \"Closing the {{/html}} macro., Closing the &#123;&#123;/html}} macro.\",\n        \"Starting a macro {, Starting a macro &#123;\",\n        \"Partial: {{/h, Partial: {&#123;/h\",\n        \"{{html}}, {{html}}\"\n    })\n    void testRawEscaping(String input, String expected)\n    {\n        WikiPrinter mockPrinter = mock(WikiPrinter.class);\n        XHTMLWikiPrinter xhtmlWikiPrinter = new XHTMLWikiPrinter(mockPrinter);\n        xhtmlWikiPrinter.printRaw(input);\n        verify(mockPrinter).print(expected);\n    }\n\n    @ParameterizedTest\n    @CsvSource({\n        \"invalid, value, data-xwiki-translated-attribute-invalid, value\",\n        \"valid, test&, valid, test&amp;\",\n        \"in/valid, value, data-xwiki-translated-attribute-invalid, value\"\n    })\n    void testParameterCleaning(String parameterName, String parameterValue, String expectedName, String expectedValue)\n    {\n        HTMLElementSanitizer mockSanitizer = mock(HTMLElementSanitizer.class);\n        when(mockSanitizer.isElementAllowed(anyString())).thenReturn(true);\n        when(mockSanitizer.isAttributeAllowed(anyString(), anyString(), anyString())).then(invocation ->\n        {\n            String attributeName = invocation.getArgument(1, String.class);\n            return \"valid\".equals(attributeName) || attributeName.startsWith(\"data-\");\n        });\n\n        // Test all possibilities of invoking the printer (with different kinds of arguments).\n        WikiPrinter mockPrinter = mock(WikiPrinter.class);\n        XHTMLWikiPrinter xhtmlWikiPrinter = new XHTMLWikiPrinter(mockPrinter, mockSanitizer);\n        Map<String, String> mapParameters = Map.of(parameterName, parameterValue);\n        xhtmlWikiPrinter.printXMLStartElement(\"div\", mapParameters);\n        verify(mockSanitizer, atLeast(1)).isElementAllowed(\"div\");\n        verify(mockSanitizer, atLeast(1)).isAttributeAllowed(\"div\", parameterName, parameterValue);\n        verify(mockSanitizer, atLeast(1)).isAttributeAllowed(\"div\", expectedName, parameterValue);\n        verifyPrinting(mockPrinter, expectedName, expectedValue, true);\n\n        mockPrinter = mock(WikiPrinter.class);\n        xhtmlWikiPrinter = new XHTMLWikiPrinter(mockPrinter, mockSanitizer);\n        xhtmlWikiPrinter.printXMLElement(\"div\", mapParameters);\n        verifyPrinting(mockPrinter, expectedName, expectedValue, false);\n\n        mockPrinter = mock(WikiPrinter.class);\n        xhtmlWikiPrinter = new XHTMLWikiPrinter(mockPrinter, mockSanitizer);\n        String[][] arrayParameters = { { parameterName, parameterValue } };\n        xhtmlWikiPrinter.printXMLStartElement(\"div\", arrayParameters);\n        verifyPrinting(mockPrinter, expectedName, expectedValue, true);\n\n        mockPrinter = mock(WikiPrinter.class);\n        xhtmlWikiPrinter = new XHTMLWikiPrinter(mockPrinter, mockSanitizer);\n        xhtmlWikiPrinter.printXMLElement(\"div\", arrayParameters);\n        verifyPrinting(mockPrinter, expectedName, expectedValue, false);\n\n        mockPrinter = mock(WikiPrinter.class);\n        xhtmlWikiPrinter = new XHTMLWikiPrinter(mockPrinter, mockSanitizer);\n        AttributesImpl attributes = new AttributesImpl();\n        attributes.addAttribute(null, null, parameterName, null, parameterValue);\n        xhtmlWikiPrinter.printXMLStartElement(\"div\", attributes);\n        verifyPrinting(mockPrinter, expectedName, expectedValue, true);\n    }\n\n    private void verifyPrinting(WikiPrinter mockPrinter, String attributeName,\n        String attributeValue, boolean isStart)\n    {\n        InOrder inOrder = Mockito.inOrder(mockPrinter);\n        inOrder.verify(mockPrinter).print(\"<\");\n        inOrder.verify(mockPrinter).print(\"div\");\n        inOrder.verify(mockPrinter).print(\" \");\n        inOrder.verify(mockPrinter).print(attributeName);\n        inOrder.verify(mockPrinter).print(\"=\");\n        inOrder.verify(mockPrinter).print(\"\\\"\");\n        inOrder.verify(mockPrinter).print(attributeValue);\n        inOrder.verify(mockPrinter).print(\"\\\"\");\n        if (isStart) {\n            inOrder.verify(mockPrinter).print(\">\");\n        } else {\n            inOrder.verify(mockPrinter).print(\"/>\");\n        }\n        verifyNoMoreInteractions(mockPrinter);\n\n    }\n}",
        "patch": "@@ -19,11 +19,21 @@\n  */\n package org.xwiki.rendering.renderer.printer;\n \n+import java.util.Map;\n+\n import org.junit.jupiter.params.ParameterizedTest;\n import org.junit.jupiter.params.provider.CsvSource;\n+import org.mockito.InOrder;\n+import org.mockito.Mockito;\n+import org.xml.sax.helpers.AttributesImpl;\n+import org.xwiki.xml.html.HTMLElementSanitizer;\n \n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.atLeast;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.when;\n \n /**\n  * Unit tests for {@link XHTMLWikiPrinter}.\n@@ -46,4 +56,75 @@ void testRawEscaping(String input, String expected)\n         xhtmlWikiPrinter.printRaw(input);\n         verify(mockPrinter).print(expected);\n     }\n+\n+    @ParameterizedTest\n+    @CsvSource({\n+        \"invalid, value, data-xwiki-translated-attribute-invalid, value\",\n+        \"valid, test&, valid, test&amp;\",\n+        \"in/valid, value, data-xwiki-translated-attribute-invalid, value\"\n+    })\n+    void testParameterCleaning(String parameterName, String parameterValue, String expectedName, String expectedValue)\n+    {\n+        HTMLElementSanitizer mockSanitizer = mock(HTMLElementSanitizer.class);\n+        when(mockSanitizer.isElementAllowed(anyString())).thenReturn(true);\n+        when(mockSanitizer.isAttributeAllowed(anyString(), anyString(), anyString())).then(invocation ->\n+        {\n+            String attributeName = invocation.getArgument(1, String.class);\n+            return \"valid\".equals(attributeName) || attributeName.startsWith(\"data-\");\n+        });\n+\n+        // Test all possibilities of invoking the printer (with different kinds of arguments).\n+        WikiPrinter mockPrinter = mock(WikiPrinter.class);\n+        XHTMLWikiPrinter xhtmlWikiPrinter = new XHTMLWikiPrinter(mockPrinter, mockSanitizer);\n+        Map<String, String> mapParameters = Map.of(parameterName, parameterValue);\n+        xhtmlWikiPrinter.printXMLStartElement(\"div\", mapParameters);\n+        verify(mockSanitizer, atLeast(1)).isElementAllowed(\"div\");\n+        verify(mockSanitizer, atLeast(1)).isAttributeAllowed(\"div\", parameterName, parameterValue);\n+        verify(mockSanitizer, atLeast(1)).isAttributeAllowed(\"div\", expectedName, parameterValue);\n+        verifyPrinting(mockPrinter, expectedName, expectedValue, true);\n+\n+        mockPrinter = mock(WikiPrinter.class);\n+        xhtmlWikiPrinter = new XHTMLWikiPrinter(mockPrinter, mockSanitizer);\n+        xhtmlWikiPrinter.printXMLElement(\"div\", mapParameters);\n+        verifyPrinting(mockPrinter, expectedName, expectedValue, false);\n+\n+        mockPrinter = mock(WikiPrinter.class);\n+        xhtmlWikiPrinter = new XHTMLWikiPrinter(mockPrinter, mockSanitizer);\n+        String[][] arrayParameters = { { parameterName, parameterValue } };\n+        xhtmlWikiPrinter.printXMLStartElement(\"div\", arrayParameters);\n+        verifyPrinting(mockPrinter, expectedName, expectedValue, true);\n+\n+        mockPrinter = mock(WikiPrinter.class);\n+        xhtmlWikiPrinter = new XHTMLWikiPrinter(mockPrinter, mockSanitizer);\n+        xhtmlWikiPrinter.printXMLElement(\"div\", arrayParameters);\n+        verifyPrinting(mockPrinter, expectedName, expectedValue, false);\n+\n+        mockPrinter = mock(WikiPrinter.class);\n+        xhtmlWikiPrinter = new XHTMLWikiPrinter(mockPrinter, mockSanitizer);\n+        AttributesImpl attributes = new AttributesImpl();\n+        attributes.addAttribute(null, null, parameterName, null, parameterValue);\n+        xhtmlWikiPrinter.printXMLStartElement(\"div\", attributes);\n+        verifyPrinting(mockPrinter, expectedName, expectedValue, true);\n+    }\n+\n+    private void verifyPrinting(WikiPrinter mockPrinter, String attributeName,\n+        String attributeValue, boolean isStart)\n+    {\n+        InOrder inOrder = Mockito.inOrder(mockPrinter);\n+        inOrder.verify(mockPrinter).print(\"<\");\n+        inOrder.verify(mockPrinter).print(\"div\");\n+        inOrder.verify(mockPrinter).print(\" \");\n+        inOrder.verify(mockPrinter).print(attributeName);\n+        inOrder.verify(mockPrinter).print(\"=\");\n+        inOrder.verify(mockPrinter).print(\"\\\"\");\n+        inOrder.verify(mockPrinter).print(attributeValue);\n+        inOrder.verify(mockPrinter).print(\"\\\"\");\n+        if (isStart) {\n+            inOrder.verify(mockPrinter).print(\">\");\n+        } else {\n+            inOrder.verify(mockPrinter).print(\"/>\");\n+        }\n+        verifyNoMoreInteractions(mockPrinter);\n+\n+    }\n }",
        "function_modified_lines": {
            "added": [
                "\n",
                "    @ParameterizedTest\n",
                "    @CsvSource({\n",
                "        \"invalid, value, data-xwiki-translated-attribute-invalid, value\",\n",
                "        \"valid, test&, valid, test&amp;\",\n",
                "        \"in/valid, value, data-xwiki-translated-attribute-invalid, value\"\n",
                "    })\n",
                "    void testParameterCleaning(String parameterName, String parameterValue, String expectedName, String expectedValue)\n",
                "    {\n",
                "        HTMLElementSanitizer mockSanitizer = mock(HTMLElementSanitizer.class);\n",
                "        when(mockSanitizer.isElementAllowed(anyString())).thenReturn(true);\n",
                "        when(mockSanitizer.isAttributeAllowed(anyString(), anyString(), anyString())).then(invocation ->\n",
                "        {\n",
                "            String attributeName = invocation.getArgument(1, String.class);\n",
                "            return \"valid\".equals(attributeName) || attributeName.startsWith(\"data-\");\n",
                "        });\n",
                "\n",
                "        // Test all possibilities of invoking the printer (with different kinds of arguments).\n",
                "        WikiPrinter mockPrinter = mock(WikiPrinter.class);\n",
                "        XHTMLWikiPrinter xhtmlWikiPrinter = new XHTMLWikiPrinter(mockPrinter, mockSanitizer);\n",
                "        Map<String, String> mapParameters = Map.of(parameterName, parameterValue);\n",
                "        xhtmlWikiPrinter.printXMLStartElement(\"div\", mapParameters);\n",
                "        verify(mockSanitizer, atLeast(1)).isElementAllowed(\"div\");\n",
                "        verify(mockSanitizer, atLeast(1)).isAttributeAllowed(\"div\", parameterName, parameterValue);\n",
                "        verify(mockSanitizer, atLeast(1)).isAttributeAllowed(\"div\", expectedName, parameterValue);\n",
                "        verifyPrinting(mockPrinter, expectedName, expectedValue, true);\n",
                "\n",
                "        mockPrinter = mock(WikiPrinter.class);\n",
                "        xhtmlWikiPrinter = new XHTMLWikiPrinter(mockPrinter, mockSanitizer);\n",
                "        xhtmlWikiPrinter.printXMLElement(\"div\", mapParameters);\n",
                "        verifyPrinting(mockPrinter, expectedName, expectedValue, false);\n",
                "\n",
                "        mockPrinter = mock(WikiPrinter.class);\n",
                "        xhtmlWikiPrinter = new XHTMLWikiPrinter(mockPrinter, mockSanitizer);\n",
                "        String[][] arrayParameters = { { parameterName, parameterValue } };\n",
                "        xhtmlWikiPrinter.printXMLStartElement(\"div\", arrayParameters);\n",
                "        verifyPrinting(mockPrinter, expectedName, expectedValue, true);\n",
                "\n",
                "        mockPrinter = mock(WikiPrinter.class);\n",
                "        xhtmlWikiPrinter = new XHTMLWikiPrinter(mockPrinter, mockSanitizer);\n",
                "        xhtmlWikiPrinter.printXMLElement(\"div\", arrayParameters);\n",
                "        verifyPrinting(mockPrinter, expectedName, expectedValue, false);\n",
                "\n",
                "        mockPrinter = mock(WikiPrinter.class);\n",
                "        xhtmlWikiPrinter = new XHTMLWikiPrinter(mockPrinter, mockSanitizer);\n",
                "        AttributesImpl attributes = new AttributesImpl();\n",
                "        attributes.addAttribute(null, null, parameterName, null, parameterValue);\n",
                "        xhtmlWikiPrinter.printXMLStartElement(\"div\", attributes);\n",
                "        verifyPrinting(mockPrinter, expectedName, expectedValue, true);\n",
                "    }\n",
                "\n",
                "    private void verifyPrinting(WikiPrinter mockPrinter, String attributeName,\n",
                "        String attributeValue, boolean isStart)\n",
                "    {\n",
                "        InOrder inOrder = Mockito.inOrder(mockPrinter);\n",
                "        inOrder.verify(mockPrinter).print(\"<\");\n",
                "        inOrder.verify(mockPrinter).print(\"div\");\n",
                "        inOrder.verify(mockPrinter).print(\" \");\n",
                "        inOrder.verify(mockPrinter).print(attributeName);\n",
                "        inOrder.verify(mockPrinter).print(\"=\");\n",
                "        inOrder.verify(mockPrinter).print(\"\\\"\");\n",
                "        inOrder.verify(mockPrinter).print(attributeValue);\n",
                "        inOrder.verify(mockPrinter).print(\"\\\"\");\n",
                "        if (isStart) {\n",
                "            inOrder.verify(mockPrinter).print(\">\");\n",
                "        } else {\n",
                "            inOrder.verify(mockPrinter).print(\"/>\");\n",
                "        }\n",
                "        verifyNoMoreInteractions(mockPrinter);\n",
                "\n",
                "    }\n"
            ],
            "deleted": []
        },
        "lang": "Java",
        "cwe": [
            "CWE-79"
        ],
        "cve_description": "XWiki Rendering is a generic Rendering system that converts textual input in a given syntax into another syntax. The cleaning of attributes during XHTML rendering, introduced in version 14.6-rc-1, allowed the injection of arbitrary HTML code and thus cross-site scripting via invalid attribute names. This can be exploited, e.g., via the link syntax in any content that supports XWiki syntax like comments in XWiki. When a user moves the mouse over a malicious link, the malicious JavaScript code is executed in the context of the user session. When this user is a privileged user who has programming rights, this allows server-side code execution with programming rights, impacting the confidentiality, integrity and availability of the XWiki instance. While this attribute was correctly recognized as not allowed, the attribute was still printed with a prefix `data-xwiki-translated-attribute-` without further cleaning or validation. This problem has been patched in XWiki 14.10.4 and 15.0 RC1 by removing characters not allowed in data attributes and then validating the cleaned attribute again. There are no known workarounds apart from upgrading to a version including the fix.",
        "id": 12713
    }
]