[
    {
        "cve_id": "CVE-2014-3182",
        "code_before_change": "static void logi_dj_recv_add_djhid_device(struct dj_receiver_dev *djrcv_dev,\n\t\t\t\t\t  struct dj_report *dj_report)\n{\n\t/* Called in delayed work context */\n\tstruct hid_device *djrcv_hdev = djrcv_dev->hdev;\n\tstruct usb_interface *intf = to_usb_interface(djrcv_hdev->dev.parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(intf);\n\tstruct hid_device *dj_hiddev;\n\tstruct dj_device *dj_dev;\n\n\t/* Device index goes from 1 to 6, we need 3 bytes to store the\n\t * semicolon, the index, and a null terminator\n\t */\n\tunsigned char tmpstr[3];\n\n\tif (dj_report->report_params[DEVICE_PAIRED_PARAM_SPFUNCTION] &\n\t    SPFUNCTION_DEVICE_LIST_EMPTY) {\n\t\tdbg_hid(\"%s: device list is empty\\n\", __func__);\n\t\tdjrcv_dev->querying_devices = false;\n\t\treturn;\n\t}\n\n\tif ((dj_report->device_index < DJ_DEVICE_INDEX_MIN) ||\n\t    (dj_report->device_index > DJ_DEVICE_INDEX_MAX)) {\n\t\tdev_err(&djrcv_hdev->dev, \"%s: invalid device index:%d\\n\",\n\t\t\t__func__, dj_report->device_index);\n\t\treturn;\n\t}\n\n\tif (djrcv_dev->paired_dj_devices[dj_report->device_index]) {\n\t\t/* The device is already known. No need to reallocate it. */\n\t\tdbg_hid(\"%s: device is already known\\n\", __func__);\n\t\treturn;\n\t}\n\n\tdj_hiddev = hid_allocate_device();\n\tif (IS_ERR(dj_hiddev)) {\n\t\tdev_err(&djrcv_hdev->dev, \"%s: hid_allocate_device failed\\n\",\n\t\t\t__func__);\n\t\treturn;\n\t}\n\n\tdj_hiddev->ll_driver = &logi_dj_ll_driver;\n\n\tdj_hiddev->dev.parent = &djrcv_hdev->dev;\n\tdj_hiddev->bus = BUS_USB;\n\tdj_hiddev->vendor = le16_to_cpu(usbdev->descriptor.idVendor);\n\tdj_hiddev->product = le16_to_cpu(usbdev->descriptor.idProduct);\n\tsnprintf(dj_hiddev->name, sizeof(dj_hiddev->name),\n\t\t\"Logitech Unifying Device. Wireless PID:%02x%02x\",\n\t\tdj_report->report_params[DEVICE_PAIRED_PARAM_EQUAD_ID_MSB],\n\t\tdj_report->report_params[DEVICE_PAIRED_PARAM_EQUAD_ID_LSB]);\n\n\tusb_make_path(usbdev, dj_hiddev->phys, sizeof(dj_hiddev->phys));\n\tsnprintf(tmpstr, sizeof(tmpstr), \":%d\", dj_report->device_index);\n\tstrlcat(dj_hiddev->phys, tmpstr, sizeof(dj_hiddev->phys));\n\n\tdj_dev = kzalloc(sizeof(struct dj_device), GFP_KERNEL);\n\n\tif (!dj_dev) {\n\t\tdev_err(&djrcv_hdev->dev, \"%s: failed allocating dj_device\\n\",\n\t\t\t__func__);\n\t\tgoto dj_device_allocate_fail;\n\t}\n\n\tdj_dev->reports_supported = get_unaligned_le32(\n\t\tdj_report->report_params + DEVICE_PAIRED_RF_REPORT_TYPE);\n\tdj_dev->hdev = dj_hiddev;\n\tdj_dev->dj_receiver_dev = djrcv_dev;\n\tdj_dev->device_index = dj_report->device_index;\n\tdj_hiddev->driver_data = dj_dev;\n\n\tdjrcv_dev->paired_dj_devices[dj_report->device_index] = dj_dev;\n\n\tif (hid_add_device(dj_hiddev)) {\n\t\tdev_err(&djrcv_hdev->dev, \"%s: failed adding dj_device\\n\",\n\t\t\t__func__);\n\t\tgoto hid_add_device_fail;\n\t}\n\n\treturn;\n\nhid_add_device_fail:\n\tdjrcv_dev->paired_dj_devices[dj_report->device_index] = NULL;\n\tkfree(dj_dev);\ndj_device_allocate_fail:\n\thid_destroy_device(dj_hiddev);\n}",
        "code_after_change": "static void logi_dj_recv_add_djhid_device(struct dj_receiver_dev *djrcv_dev,\n\t\t\t\t\t  struct dj_report *dj_report)\n{\n\t/* Called in delayed work context */\n\tstruct hid_device *djrcv_hdev = djrcv_dev->hdev;\n\tstruct usb_interface *intf = to_usb_interface(djrcv_hdev->dev.parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(intf);\n\tstruct hid_device *dj_hiddev;\n\tstruct dj_device *dj_dev;\n\n\t/* Device index goes from 1 to 6, we need 3 bytes to store the\n\t * semicolon, the index, and a null terminator\n\t */\n\tunsigned char tmpstr[3];\n\n\tif (dj_report->report_params[DEVICE_PAIRED_PARAM_SPFUNCTION] &\n\t    SPFUNCTION_DEVICE_LIST_EMPTY) {\n\t\tdbg_hid(\"%s: device list is empty\\n\", __func__);\n\t\tdjrcv_dev->querying_devices = false;\n\t\treturn;\n\t}\n\n\tif (djrcv_dev->paired_dj_devices[dj_report->device_index]) {\n\t\t/* The device is already known. No need to reallocate it. */\n\t\tdbg_hid(\"%s: device is already known\\n\", __func__);\n\t\treturn;\n\t}\n\n\tdj_hiddev = hid_allocate_device();\n\tif (IS_ERR(dj_hiddev)) {\n\t\tdev_err(&djrcv_hdev->dev, \"%s: hid_allocate_device failed\\n\",\n\t\t\t__func__);\n\t\treturn;\n\t}\n\n\tdj_hiddev->ll_driver = &logi_dj_ll_driver;\n\n\tdj_hiddev->dev.parent = &djrcv_hdev->dev;\n\tdj_hiddev->bus = BUS_USB;\n\tdj_hiddev->vendor = le16_to_cpu(usbdev->descriptor.idVendor);\n\tdj_hiddev->product = le16_to_cpu(usbdev->descriptor.idProduct);\n\tsnprintf(dj_hiddev->name, sizeof(dj_hiddev->name),\n\t\t\"Logitech Unifying Device. Wireless PID:%02x%02x\",\n\t\tdj_report->report_params[DEVICE_PAIRED_PARAM_EQUAD_ID_MSB],\n\t\tdj_report->report_params[DEVICE_PAIRED_PARAM_EQUAD_ID_LSB]);\n\n\tusb_make_path(usbdev, dj_hiddev->phys, sizeof(dj_hiddev->phys));\n\tsnprintf(tmpstr, sizeof(tmpstr), \":%d\", dj_report->device_index);\n\tstrlcat(dj_hiddev->phys, tmpstr, sizeof(dj_hiddev->phys));\n\n\tdj_dev = kzalloc(sizeof(struct dj_device), GFP_KERNEL);\n\n\tif (!dj_dev) {\n\t\tdev_err(&djrcv_hdev->dev, \"%s: failed allocating dj_device\\n\",\n\t\t\t__func__);\n\t\tgoto dj_device_allocate_fail;\n\t}\n\n\tdj_dev->reports_supported = get_unaligned_le32(\n\t\tdj_report->report_params + DEVICE_PAIRED_RF_REPORT_TYPE);\n\tdj_dev->hdev = dj_hiddev;\n\tdj_dev->dj_receiver_dev = djrcv_dev;\n\tdj_dev->device_index = dj_report->device_index;\n\tdj_hiddev->driver_data = dj_dev;\n\n\tdjrcv_dev->paired_dj_devices[dj_report->device_index] = dj_dev;\n\n\tif (hid_add_device(dj_hiddev)) {\n\t\tdev_err(&djrcv_hdev->dev, \"%s: failed adding dj_device\\n\",\n\t\t\t__func__);\n\t\tgoto hid_add_device_fail;\n\t}\n\n\treturn;\n\nhid_add_device_fail:\n\tdjrcv_dev->paired_dj_devices[dj_report->device_index] = NULL;\n\tkfree(dj_dev);\ndj_device_allocate_fail:\n\thid_destroy_device(dj_hiddev);\n}",
        "patch": "--- code before\n+++ code after\n@@ -17,13 +17,6 @@\n \t    SPFUNCTION_DEVICE_LIST_EMPTY) {\n \t\tdbg_hid(\"%s: device list is empty\\n\", __func__);\n \t\tdjrcv_dev->querying_devices = false;\n-\t\treturn;\n-\t}\n-\n-\tif ((dj_report->device_index < DJ_DEVICE_INDEX_MIN) ||\n-\t    (dj_report->device_index > DJ_DEVICE_INDEX_MAX)) {\n-\t\tdev_err(&djrcv_hdev->dev, \"%s: invalid device index:%d\\n\",\n-\t\t\t__func__, dj_report->device_index);\n \t\treturn;\n \t}\n ",
        "function_modified_lines": {
            "added": [],
            "deleted": [
                "\t\treturn;",
                "\t}",
                "",
                "\tif ((dj_report->device_index < DJ_DEVICE_INDEX_MIN) ||",
                "\t    (dj_report->device_index > DJ_DEVICE_INDEX_MAX)) {",
                "\t\tdev_err(&djrcv_hdev->dev, \"%s: invalid device index:%d\\n\",",
                "\t\t\t__func__, dj_report->device_index);"
            ]
        },
        "cwe": [
            "CWE-119"
        ],
        "cve_description": "Array index error in the logi_dj_raw_event function in drivers/hid/hid-logitech-dj.c in the Linux kernel before 3.16.2 allows physically proximate attackers to execute arbitrary code or cause a denial of service (invalid kfree) via a crafted device that provides a malformed REPORT_TYPE_NOTIF_DEVICE_UNPAIRED value.",
        "id": 512
    },
    {
        "cve_id": "CVE-2016-3134",
        "code_before_change": "static bool check_underflow(const struct ip6t_entry *e)\n{\n\tconst struct xt_entry_target *t;\n\tunsigned int verdict;\n\n\tif (!unconditional(&e->ipv6))\n\t\treturn false;\n\tt = ip6t_get_target_c(e);\n\tif (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)\n\t\treturn false;\n\tverdict = ((struct xt_standard_target *)t)->verdict;\n\tverdict = -verdict - 1;\n\treturn verdict == NF_DROP || verdict == NF_ACCEPT;\n}",
        "code_after_change": "static bool check_underflow(const struct ip6t_entry *e)\n{\n\tconst struct xt_entry_target *t;\n\tunsigned int verdict;\n\n\tif (!unconditional(e))\n\t\treturn false;\n\tt = ip6t_get_target_c(e);\n\tif (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)\n\t\treturn false;\n\tverdict = ((struct xt_standard_target *)t)->verdict;\n\tverdict = -verdict - 1;\n\treturn verdict == NF_DROP || verdict == NF_ACCEPT;\n}",
        "patch": "--- code before\n+++ code after\n@@ -3,7 +3,7 @@\n \tconst struct xt_entry_target *t;\n \tunsigned int verdict;\n \n-\tif (!unconditional(&e->ipv6))\n+\tif (!unconditional(e))\n \t\treturn false;\n \tt = ip6t_get_target_c(e);\n \tif (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)",
        "function_modified_lines": {
            "added": [
                "\tif (!unconditional(e))"
            ],
            "deleted": [
                "\tif (!unconditional(&e->ipv6))"
            ]
        },
        "cwe": [
            "CWE-119"
        ],
        "cve_description": "The netfilter subsystem in the Linux kernel through 4.5.2 does not validate certain offset fields, which allows local users to gain privileges or cause a denial of service (heap memory corruption) via an IPT_SO_SET_REPLACE setsockopt call.",
        "id": 970
    },
    {
        "cve_id": "CVE-2016-3134",
        "code_before_change": "static int\ncheck_entry_size_and_hooks(struct ipt_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\n\tif ((unsigned long)e % __alignof__(struct ipt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ipt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset\n\t    < sizeof(struct ipt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_err(\"Underflows must be unconditional and \"\n\t\t\t\t       \"use the STANDARD target with \"\n\t\t\t\t       \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\n\t/* Clear counters and comefrom */\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}",
        "code_after_change": "static int\ncheck_entry_size_and_hooks(struct ipt_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\n\tif ((unsigned long)e % __alignof__(struct ipt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ipt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset\n\t    < sizeof(struct ipt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\n\t/* Clear counters and comefrom */\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -36,9 +36,9 @@\n \t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n \t\tif ((unsigned char *)e - base == underflows[h]) {\n \t\t\tif (!check_underflow(e)) {\n-\t\t\t\tpr_err(\"Underflows must be unconditional and \"\n-\t\t\t\t       \"use the STANDARD target with \"\n-\t\t\t\t       \"ACCEPT/DROP\\n\");\n+\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n+\t\t\t\t\t \"use the STANDARD target with \"\n+\t\t\t\t\t \"ACCEPT/DROP\\n\");\n \t\t\t\treturn -EINVAL;\n \t\t\t}\n \t\t\tnewinfo->underflow[h] = underflows[h];",
        "function_modified_lines": {
            "added": [
                "\t\t\t\tpr_debug(\"Underflows must be unconditional and \"",
                "\t\t\t\t\t \"use the STANDARD target with \"",
                "\t\t\t\t\t \"ACCEPT/DROP\\n\");"
            ],
            "deleted": [
                "\t\t\t\tpr_err(\"Underflows must be unconditional and \"",
                "\t\t\t\t       \"use the STANDARD target with \"",
                "\t\t\t\t       \"ACCEPT/DROP\\n\");"
            ]
        },
        "cwe": [
            "CWE-119"
        ],
        "cve_description": "The netfilter subsystem in the Linux kernel through 4.5.2 does not validate certain offset fields, which allows local users to gain privileges or cause a denial of service (heap memory corruption) via an IPT_SO_SET_REPLACE setsockopt call.",
        "id": 965
    },
    {
        "cve_id": "CVE-2016-3134",
        "code_before_change": "static int mark_source_chains(const struct xt_table_info *newinfo,\n\t\t\t      unsigned int valid_hooks, void *entry0)\n{\n\tunsigned int hook;\n\n\t/* No recursion; use packet counter to save back ptrs (reset\n\t * to 0 as we leave), and comefrom to save source hook bitmask.\n\t */\n\tfor (hook = 0; hook < NF_ARP_NUMHOOKS; hook++) {\n\t\tunsigned int pos = newinfo->hook_entry[hook];\n\t\tstruct arpt_entry *e\n\t\t\t= (struct arpt_entry *)(entry0 + pos);\n\n\t\tif (!(valid_hooks & (1 << hook)))\n\t\t\tcontinue;\n\n\t\t/* Set initial back pointer. */\n\t\te->counters.pcnt = pos;\n\n\t\tfor (;;) {\n\t\t\tconst struct xt_standard_target *t\n\t\t\t\t= (void *)arpt_get_target_c(e);\n\t\t\tint visited = e->comefrom & (1 << hook);\n\n\t\t\tif (e->comefrom & (1 << NF_ARP_NUMHOOKS)) {\n\t\t\t\tpr_notice(\"arptables: loop hook %u pos %u %08X.\\n\",\n\t\t\t\t       hook, pos, e->comefrom);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\te->comefrom\n\t\t\t\t|= ((1 << hook) | (1 << NF_ARP_NUMHOOKS));\n\n\t\t\t/* Unconditional return/END. */\n\t\t\tif ((e->target_offset == sizeof(struct arpt_entry) &&\n\t\t\t     (strcmp(t->target.u.user.name,\n\t\t\t\t     XT_STANDARD_TARGET) == 0) &&\n\t\t\t     t->verdict < 0 && unconditional(&e->arp)) ||\n\t\t\t    visited) {\n\t\t\t\tunsigned int oldpos, size;\n\n\t\t\t\tif ((strcmp(t->target.u.user.name,\n\t\t\t\t\t    XT_STANDARD_TARGET) == 0) &&\n\t\t\t\t    t->verdict < -NF_MAX_VERDICT - 1) {\n\t\t\t\t\tduprintf(\"mark_source_chains: bad \"\n\t\t\t\t\t\t\"negative verdict (%i)\\n\",\n\t\t\t\t\t\t\t\tt->verdict);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\t/* Return: backtrack through the last\n\t\t\t\t * big jump.\n\t\t\t\t */\n\t\t\t\tdo {\n\t\t\t\t\te->comefrom ^= (1<<NF_ARP_NUMHOOKS);\n\t\t\t\t\toldpos = pos;\n\t\t\t\t\tpos = e->counters.pcnt;\n\t\t\t\t\te->counters.pcnt = 0;\n\n\t\t\t\t\t/* We're at the start. */\n\t\t\t\t\tif (pos == oldpos)\n\t\t\t\t\t\tgoto next;\n\n\t\t\t\t\te = (struct arpt_entry *)\n\t\t\t\t\t\t(entry0 + pos);\n\t\t\t\t} while (oldpos == pos + e->next_offset);\n\n\t\t\t\t/* Move along one */\n\t\t\t\tsize = e->next_offset;\n\t\t\t\te = (struct arpt_entry *)\n\t\t\t\t\t(entry0 + pos + size);\n\t\t\t\te->counters.pcnt = pos;\n\t\t\t\tpos += size;\n\t\t\t} else {\n\t\t\t\tint newpos = t->verdict;\n\n\t\t\t\tif (strcmp(t->target.u.user.name,\n\t\t\t\t\t   XT_STANDARD_TARGET) == 0 &&\n\t\t\t\t    newpos >= 0) {\n\t\t\t\t\tif (newpos > newinfo->size -\n\t\t\t\t\t\tsizeof(struct arpt_entry)) {\n\t\t\t\t\t\tduprintf(\"mark_source_chains: \"\n\t\t\t\t\t\t\t\"bad verdict (%i)\\n\",\n\t\t\t\t\t\t\t\tnewpos);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* This a jump; chase it. */\n\t\t\t\t\tduprintf(\"Jump rule %u -> %u\\n\",\n\t\t\t\t\t\t pos, newpos);\n\t\t\t\t} else {\n\t\t\t\t\t/* ... this is a fallthru */\n\t\t\t\t\tnewpos = pos + e->next_offset;\n\t\t\t\t}\n\t\t\t\te = (struct arpt_entry *)\n\t\t\t\t\t(entry0 + newpos);\n\t\t\t\te->counters.pcnt = pos;\n\t\t\t\tpos = newpos;\n\t\t\t}\n\t\t}\nnext:\n\t\tduprintf(\"Finished chain %u\\n\", hook);\n\t}\n\treturn 1;\n}",
        "code_after_change": "static int mark_source_chains(const struct xt_table_info *newinfo,\n\t\t\t      unsigned int valid_hooks, void *entry0)\n{\n\tunsigned int hook;\n\n\t/* No recursion; use packet counter to save back ptrs (reset\n\t * to 0 as we leave), and comefrom to save source hook bitmask.\n\t */\n\tfor (hook = 0; hook < NF_ARP_NUMHOOKS; hook++) {\n\t\tunsigned int pos = newinfo->hook_entry[hook];\n\t\tstruct arpt_entry *e\n\t\t\t= (struct arpt_entry *)(entry0 + pos);\n\n\t\tif (!(valid_hooks & (1 << hook)))\n\t\t\tcontinue;\n\n\t\t/* Set initial back pointer. */\n\t\te->counters.pcnt = pos;\n\n\t\tfor (;;) {\n\t\t\tconst struct xt_standard_target *t\n\t\t\t\t= (void *)arpt_get_target_c(e);\n\t\t\tint visited = e->comefrom & (1 << hook);\n\n\t\t\tif (e->comefrom & (1 << NF_ARP_NUMHOOKS)) {\n\t\t\t\tpr_notice(\"arptables: loop hook %u pos %u %08X.\\n\",\n\t\t\t\t       hook, pos, e->comefrom);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\te->comefrom\n\t\t\t\t|= ((1 << hook) | (1 << NF_ARP_NUMHOOKS));\n\n\t\t\t/* Unconditional return/END. */\n\t\t\tif ((unconditional(e) &&\n\t\t\t     (strcmp(t->target.u.user.name,\n\t\t\t\t     XT_STANDARD_TARGET) == 0) &&\n\t\t\t     t->verdict < 0) || visited) {\n\t\t\t\tunsigned int oldpos, size;\n\n\t\t\t\tif ((strcmp(t->target.u.user.name,\n\t\t\t\t\t    XT_STANDARD_TARGET) == 0) &&\n\t\t\t\t    t->verdict < -NF_MAX_VERDICT - 1) {\n\t\t\t\t\tduprintf(\"mark_source_chains: bad \"\n\t\t\t\t\t\t\"negative verdict (%i)\\n\",\n\t\t\t\t\t\t\t\tt->verdict);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\t/* Return: backtrack through the last\n\t\t\t\t * big jump.\n\t\t\t\t */\n\t\t\t\tdo {\n\t\t\t\t\te->comefrom ^= (1<<NF_ARP_NUMHOOKS);\n\t\t\t\t\toldpos = pos;\n\t\t\t\t\tpos = e->counters.pcnt;\n\t\t\t\t\te->counters.pcnt = 0;\n\n\t\t\t\t\t/* We're at the start. */\n\t\t\t\t\tif (pos == oldpos)\n\t\t\t\t\t\tgoto next;\n\n\t\t\t\t\te = (struct arpt_entry *)\n\t\t\t\t\t\t(entry0 + pos);\n\t\t\t\t} while (oldpos == pos + e->next_offset);\n\n\t\t\t\t/* Move along one */\n\t\t\t\tsize = e->next_offset;\n\t\t\t\te = (struct arpt_entry *)\n\t\t\t\t\t(entry0 + pos + size);\n\t\t\t\te->counters.pcnt = pos;\n\t\t\t\tpos += size;\n\t\t\t} else {\n\t\t\t\tint newpos = t->verdict;\n\n\t\t\t\tif (strcmp(t->target.u.user.name,\n\t\t\t\t\t   XT_STANDARD_TARGET) == 0 &&\n\t\t\t\t    newpos >= 0) {\n\t\t\t\t\tif (newpos > newinfo->size -\n\t\t\t\t\t\tsizeof(struct arpt_entry)) {\n\t\t\t\t\t\tduprintf(\"mark_source_chains: \"\n\t\t\t\t\t\t\t\"bad verdict (%i)\\n\",\n\t\t\t\t\t\t\t\tnewpos);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* This a jump; chase it. */\n\t\t\t\t\tduprintf(\"Jump rule %u -> %u\\n\",\n\t\t\t\t\t\t pos, newpos);\n\t\t\t\t} else {\n\t\t\t\t\t/* ... this is a fallthru */\n\t\t\t\t\tnewpos = pos + e->next_offset;\n\t\t\t\t}\n\t\t\t\te = (struct arpt_entry *)\n\t\t\t\t\t(entry0 + newpos);\n\t\t\t\te->counters.pcnt = pos;\n\t\t\t\tpos = newpos;\n\t\t\t}\n\t\t}\nnext:\n\t\tduprintf(\"Finished chain %u\\n\", hook);\n\t}\n\treturn 1;\n}",
        "patch": "--- code before\n+++ code after\n@@ -31,11 +31,10 @@\n \t\t\t\t|= ((1 << hook) | (1 << NF_ARP_NUMHOOKS));\n \n \t\t\t/* Unconditional return/END. */\n-\t\t\tif ((e->target_offset == sizeof(struct arpt_entry) &&\n+\t\t\tif ((unconditional(e) &&\n \t\t\t     (strcmp(t->target.u.user.name,\n \t\t\t\t     XT_STANDARD_TARGET) == 0) &&\n-\t\t\t     t->verdict < 0 && unconditional(&e->arp)) ||\n-\t\t\t    visited) {\n+\t\t\t     t->verdict < 0) || visited) {\n \t\t\t\tunsigned int oldpos, size;\n \n \t\t\t\tif ((strcmp(t->target.u.user.name,",
        "function_modified_lines": {
            "added": [
                "\t\t\tif ((unconditional(e) &&",
                "\t\t\t     t->verdict < 0) || visited) {"
            ],
            "deleted": [
                "\t\t\tif ((e->target_offset == sizeof(struct arpt_entry) &&",
                "\t\t\t     t->verdict < 0 && unconditional(&e->arp)) ||",
                "\t\t\t    visited) {"
            ]
        },
        "cwe": [
            "CWE-119"
        ],
        "cve_description": "The netfilter subsystem in the Linux kernel through 4.5.2 does not validate certain offset fields, which allows local users to gain privileges or cause a denial of service (heap memory corruption) via an IPT_SO_SET_REPLACE setsockopt call.",
        "id": 964
    },
    {
        "cve_id": "CVE-2016-3134",
        "code_before_change": "static bool check_underflow(const struct arpt_entry *e)\n{\n\tconst struct xt_entry_target *t;\n\tunsigned int verdict;\n\n\tif (!unconditional(&e->arp))\n\t\treturn false;\n\tt = arpt_get_target_c(e);\n\tif (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)\n\t\treturn false;\n\tverdict = ((struct xt_standard_target *)t)->verdict;\n\tverdict = -verdict - 1;\n\treturn verdict == NF_DROP || verdict == NF_ACCEPT;\n}",
        "code_after_change": "static bool check_underflow(const struct arpt_entry *e)\n{\n\tconst struct xt_entry_target *t;\n\tunsigned int verdict;\n\n\tif (!unconditional(e))\n\t\treturn false;\n\tt = arpt_get_target_c(e);\n\tif (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)\n\t\treturn false;\n\tverdict = ((struct xt_standard_target *)t)->verdict;\n\tverdict = -verdict - 1;\n\treturn verdict == NF_DROP || verdict == NF_ACCEPT;\n}",
        "patch": "--- code before\n+++ code after\n@@ -3,7 +3,7 @@\n \tconst struct xt_entry_target *t;\n \tunsigned int verdict;\n \n-\tif (!unconditional(&e->arp))\n+\tif (!unconditional(e))\n \t\treturn false;\n \tt = arpt_get_target_c(e);\n \tif (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)",
        "function_modified_lines": {
            "added": [
                "\tif (!unconditional(e))"
            ],
            "deleted": [
                "\tif (!unconditional(&e->arp))"
            ]
        },
        "cwe": [
            "CWE-119"
        ],
        "cve_description": "The netfilter subsystem in the Linux kernel through 4.5.2 does not validate certain offset fields, which allows local users to gain privileges or cause a denial of service (heap memory corruption) via an IPT_SO_SET_REPLACE setsockopt call.",
        "id": 963
    },
    {
        "cve_id": "CVE-2016-3134",
        "code_before_change": "static int\nmark_source_chains(const struct xt_table_info *newinfo,\n\t\t   unsigned int valid_hooks, void *entry0)\n{\n\tunsigned int hook;\n\n\t/* No recursion; use packet counter to save back ptrs (reset\n\t   to 0 as we leave), and comefrom to save source hook bitmask */\n\tfor (hook = 0; hook < NF_INET_NUMHOOKS; hook++) {\n\t\tunsigned int pos = newinfo->hook_entry[hook];\n\t\tstruct ipt_entry *e = (struct ipt_entry *)(entry0 + pos);\n\n\t\tif (!(valid_hooks & (1 << hook)))\n\t\t\tcontinue;\n\n\t\t/* Set initial back pointer. */\n\t\te->counters.pcnt = pos;\n\n\t\tfor (;;) {\n\t\t\tconst struct xt_standard_target *t\n\t\t\t\t= (void *)ipt_get_target_c(e);\n\t\t\tint visited = e->comefrom & (1 << hook);\n\n\t\t\tif (e->comefrom & (1 << NF_INET_NUMHOOKS)) {\n\t\t\t\tpr_err(\"iptables: loop hook %u pos %u %08X.\\n\",\n\t\t\t\t       hook, pos, e->comefrom);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\te->comefrom |= ((1 << hook) | (1 << NF_INET_NUMHOOKS));\n\n\t\t\t/* Unconditional return/END. */\n\t\t\tif ((e->target_offset == sizeof(struct ipt_entry) &&\n\t\t\t     (strcmp(t->target.u.user.name,\n\t\t\t\t     XT_STANDARD_TARGET) == 0) &&\n\t\t\t     t->verdict < 0 && unconditional(&e->ip)) ||\n\t\t\t    visited) {\n\t\t\t\tunsigned int oldpos, size;\n\n\t\t\t\tif ((strcmp(t->target.u.user.name,\n\t\t\t\t\t    XT_STANDARD_TARGET) == 0) &&\n\t\t\t\t    t->verdict < -NF_MAX_VERDICT - 1) {\n\t\t\t\t\tduprintf(\"mark_source_chains: bad \"\n\t\t\t\t\t\t\"negative verdict (%i)\\n\",\n\t\t\t\t\t\t\t\tt->verdict);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\t/* Return: backtrack through the last\n\t\t\t\t   big jump. */\n\t\t\t\tdo {\n\t\t\t\t\te->comefrom ^= (1<<NF_INET_NUMHOOKS);\n#ifdef DEBUG_IP_FIREWALL_USER\n\t\t\t\t\tif (e->comefrom\n\t\t\t\t\t    & (1 << NF_INET_NUMHOOKS)) {\n\t\t\t\t\t\tduprintf(\"Back unset \"\n\t\t\t\t\t\t\t \"on hook %u \"\n\t\t\t\t\t\t\t \"rule %u\\n\",\n\t\t\t\t\t\t\t hook, pos);\n\t\t\t\t\t}\n#endif\n\t\t\t\t\toldpos = pos;\n\t\t\t\t\tpos = e->counters.pcnt;\n\t\t\t\t\te->counters.pcnt = 0;\n\n\t\t\t\t\t/* We're at the start. */\n\t\t\t\t\tif (pos == oldpos)\n\t\t\t\t\t\tgoto next;\n\n\t\t\t\t\te = (struct ipt_entry *)\n\t\t\t\t\t\t(entry0 + pos);\n\t\t\t\t} while (oldpos == pos + e->next_offset);\n\n\t\t\t\t/* Move along one */\n\t\t\t\tsize = e->next_offset;\n\t\t\t\te = (struct ipt_entry *)\n\t\t\t\t\t(entry0 + pos + size);\n\t\t\t\te->counters.pcnt = pos;\n\t\t\t\tpos += size;\n\t\t\t} else {\n\t\t\t\tint newpos = t->verdict;\n\n\t\t\t\tif (strcmp(t->target.u.user.name,\n\t\t\t\t\t   XT_STANDARD_TARGET) == 0 &&\n\t\t\t\t    newpos >= 0) {\n\t\t\t\t\tif (newpos > newinfo->size -\n\t\t\t\t\t\tsizeof(struct ipt_entry)) {\n\t\t\t\t\t\tduprintf(\"mark_source_chains: \"\n\t\t\t\t\t\t\t\"bad verdict (%i)\\n\",\n\t\t\t\t\t\t\t\tnewpos);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\t/* This a jump; chase it. */\n\t\t\t\t\tduprintf(\"Jump rule %u -> %u\\n\",\n\t\t\t\t\t\t pos, newpos);\n\t\t\t\t} else {\n\t\t\t\t\t/* ... this is a fallthru */\n\t\t\t\t\tnewpos = pos + e->next_offset;\n\t\t\t\t}\n\t\t\t\te = (struct ipt_entry *)\n\t\t\t\t\t(entry0 + newpos);\n\t\t\t\te->counters.pcnt = pos;\n\t\t\t\tpos = newpos;\n\t\t\t}\n\t\t}\nnext:\n\t\tduprintf(\"Finished chain %u\\n\", hook);\n\t}\n\treturn 1;\n}",
        "code_after_change": "static int\nmark_source_chains(const struct xt_table_info *newinfo,\n\t\t   unsigned int valid_hooks, void *entry0)\n{\n\tunsigned int hook;\n\n\t/* No recursion; use packet counter to save back ptrs (reset\n\t   to 0 as we leave), and comefrom to save source hook bitmask */\n\tfor (hook = 0; hook < NF_INET_NUMHOOKS; hook++) {\n\t\tunsigned int pos = newinfo->hook_entry[hook];\n\t\tstruct ipt_entry *e = (struct ipt_entry *)(entry0 + pos);\n\n\t\tif (!(valid_hooks & (1 << hook)))\n\t\t\tcontinue;\n\n\t\t/* Set initial back pointer. */\n\t\te->counters.pcnt = pos;\n\n\t\tfor (;;) {\n\t\t\tconst struct xt_standard_target *t\n\t\t\t\t= (void *)ipt_get_target_c(e);\n\t\t\tint visited = e->comefrom & (1 << hook);\n\n\t\t\tif (e->comefrom & (1 << NF_INET_NUMHOOKS)) {\n\t\t\t\tpr_err(\"iptables: loop hook %u pos %u %08X.\\n\",\n\t\t\t\t       hook, pos, e->comefrom);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\te->comefrom |= ((1 << hook) | (1 << NF_INET_NUMHOOKS));\n\n\t\t\t/* Unconditional return/END. */\n\t\t\tif ((unconditional(e) &&\n\t\t\t     (strcmp(t->target.u.user.name,\n\t\t\t\t     XT_STANDARD_TARGET) == 0) &&\n\t\t\t     t->verdict < 0) || visited) {\n\t\t\t\tunsigned int oldpos, size;\n\n\t\t\t\tif ((strcmp(t->target.u.user.name,\n\t\t\t\t\t    XT_STANDARD_TARGET) == 0) &&\n\t\t\t\t    t->verdict < -NF_MAX_VERDICT - 1) {\n\t\t\t\t\tduprintf(\"mark_source_chains: bad \"\n\t\t\t\t\t\t\"negative verdict (%i)\\n\",\n\t\t\t\t\t\t\t\tt->verdict);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\t/* Return: backtrack through the last\n\t\t\t\t   big jump. */\n\t\t\t\tdo {\n\t\t\t\t\te->comefrom ^= (1<<NF_INET_NUMHOOKS);\n#ifdef DEBUG_IP_FIREWALL_USER\n\t\t\t\t\tif (e->comefrom\n\t\t\t\t\t    & (1 << NF_INET_NUMHOOKS)) {\n\t\t\t\t\t\tduprintf(\"Back unset \"\n\t\t\t\t\t\t\t \"on hook %u \"\n\t\t\t\t\t\t\t \"rule %u\\n\",\n\t\t\t\t\t\t\t hook, pos);\n\t\t\t\t\t}\n#endif\n\t\t\t\t\toldpos = pos;\n\t\t\t\t\tpos = e->counters.pcnt;\n\t\t\t\t\te->counters.pcnt = 0;\n\n\t\t\t\t\t/* We're at the start. */\n\t\t\t\t\tif (pos == oldpos)\n\t\t\t\t\t\tgoto next;\n\n\t\t\t\t\te = (struct ipt_entry *)\n\t\t\t\t\t\t(entry0 + pos);\n\t\t\t\t} while (oldpos == pos + e->next_offset);\n\n\t\t\t\t/* Move along one */\n\t\t\t\tsize = e->next_offset;\n\t\t\t\te = (struct ipt_entry *)\n\t\t\t\t\t(entry0 + pos + size);\n\t\t\t\te->counters.pcnt = pos;\n\t\t\t\tpos += size;\n\t\t\t} else {\n\t\t\t\tint newpos = t->verdict;\n\n\t\t\t\tif (strcmp(t->target.u.user.name,\n\t\t\t\t\t   XT_STANDARD_TARGET) == 0 &&\n\t\t\t\t    newpos >= 0) {\n\t\t\t\t\tif (newpos > newinfo->size -\n\t\t\t\t\t\tsizeof(struct ipt_entry)) {\n\t\t\t\t\t\tduprintf(\"mark_source_chains: \"\n\t\t\t\t\t\t\t\"bad verdict (%i)\\n\",\n\t\t\t\t\t\t\t\tnewpos);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\t/* This a jump; chase it. */\n\t\t\t\t\tduprintf(\"Jump rule %u -> %u\\n\",\n\t\t\t\t\t\t pos, newpos);\n\t\t\t\t} else {\n\t\t\t\t\t/* ... this is a fallthru */\n\t\t\t\t\tnewpos = pos + e->next_offset;\n\t\t\t\t}\n\t\t\t\te = (struct ipt_entry *)\n\t\t\t\t\t(entry0 + newpos);\n\t\t\t\te->counters.pcnt = pos;\n\t\t\t\tpos = newpos;\n\t\t\t}\n\t\t}\nnext:\n\t\tduprintf(\"Finished chain %u\\n\", hook);\n\t}\n\treturn 1;\n}",
        "patch": "--- code before\n+++ code after\n@@ -29,11 +29,10 @@\n \t\t\te->comefrom |= ((1 << hook) | (1 << NF_INET_NUMHOOKS));\n \n \t\t\t/* Unconditional return/END. */\n-\t\t\tif ((e->target_offset == sizeof(struct ipt_entry) &&\n+\t\t\tif ((unconditional(e) &&\n \t\t\t     (strcmp(t->target.u.user.name,\n \t\t\t\t     XT_STANDARD_TARGET) == 0) &&\n-\t\t\t     t->verdict < 0 && unconditional(&e->ip)) ||\n-\t\t\t    visited) {\n+\t\t\t     t->verdict < 0) || visited) {\n \t\t\t\tunsigned int oldpos, size;\n \n \t\t\t\tif ((strcmp(t->target.u.user.name,",
        "function_modified_lines": {
            "added": [
                "\t\t\tif ((unconditional(e) &&",
                "\t\t\t     t->verdict < 0) || visited) {"
            ],
            "deleted": [
                "\t\t\tif ((e->target_offset == sizeof(struct ipt_entry) &&",
                "\t\t\t     t->verdict < 0 && unconditional(&e->ip)) ||",
                "\t\t\t    visited) {"
            ]
        },
        "cwe": [
            "CWE-119"
        ],
        "cve_description": "The netfilter subsystem in the Linux kernel through 4.5.2 does not validate certain offset fields, which allows local users to gain privileges or cause a denial of service (heap memory corruption) via an IPT_SO_SET_REPLACE setsockopt call.",
        "id": 967
    },
    {
        "cve_id": "CVE-2012-3364",
        "code_before_change": "static __u8 *nci_extract_rf_params_nfca_passive_poll(struct nci_dev *ndev,\n\t\t\tstruct rf_tech_specific_params_nfca_poll *nfca_poll,\n\t\t\t\t\t\t     __u8 *data)\n{\n\tnfca_poll->sens_res = __le16_to_cpu(*((__u16 *)data));\n\tdata += 2;\n\n\tnfca_poll->nfcid1_len = *data++;\n\n\tpr_debug(\"sens_res 0x%x, nfcid1_len %d\\n\",\n\t\t nfca_poll->sens_res, nfca_poll->nfcid1_len);\n\n\tmemcpy(nfca_poll->nfcid1, data, nfca_poll->nfcid1_len);\n\tdata += nfca_poll->nfcid1_len;\n\n\tnfca_poll->sel_res_len = *data++;\n\n\tif (nfca_poll->sel_res_len != 0)\n\t\tnfca_poll->sel_res = *data++;\n\n\tpr_debug(\"sel_res_len %d, sel_res 0x%x\\n\",\n\t\t nfca_poll->sel_res_len,\n\t\t nfca_poll->sel_res);\n\n\treturn data;\n}",
        "code_after_change": "static __u8 *nci_extract_rf_params_nfca_passive_poll(struct nci_dev *ndev,\n\t\t\tstruct rf_tech_specific_params_nfca_poll *nfca_poll,\n\t\t\t\t\t\t     __u8 *data)\n{\n\tnfca_poll->sens_res = __le16_to_cpu(*((__u16 *)data));\n\tdata += 2;\n\n\tnfca_poll->nfcid1_len = min_t(__u8, *data++, NFC_NFCID1_MAXSIZE);\n\n\tpr_debug(\"sens_res 0x%x, nfcid1_len %d\\n\",\n\t\t nfca_poll->sens_res, nfca_poll->nfcid1_len);\n\n\tmemcpy(nfca_poll->nfcid1, data, nfca_poll->nfcid1_len);\n\tdata += nfca_poll->nfcid1_len;\n\n\tnfca_poll->sel_res_len = *data++;\n\n\tif (nfca_poll->sel_res_len != 0)\n\t\tnfca_poll->sel_res = *data++;\n\n\tpr_debug(\"sel_res_len %d, sel_res 0x%x\\n\",\n\t\t nfca_poll->sel_res_len,\n\t\t nfca_poll->sel_res);\n\n\treturn data;\n}",
        "patch": "--- code before\n+++ code after\n@@ -5,7 +5,7 @@\n \tnfca_poll->sens_res = __le16_to_cpu(*((__u16 *)data));\n \tdata += 2;\n \n-\tnfca_poll->nfcid1_len = *data++;\n+\tnfca_poll->nfcid1_len = min_t(__u8, *data++, NFC_NFCID1_MAXSIZE);\n \n \tpr_debug(\"sens_res 0x%x, nfcid1_len %d\\n\",\n \t\t nfca_poll->sens_res, nfca_poll->nfcid1_len);",
        "function_modified_lines": {
            "added": [
                "\tnfca_poll->nfcid1_len = min_t(__u8, *data++, NFC_NFCID1_MAXSIZE);"
            ],
            "deleted": [
                "\tnfca_poll->nfcid1_len = *data++;"
            ]
        },
        "cwe": [
            "CWE-119"
        ],
        "cve_description": "Multiple stack-based buffer overflows in the Near Field Communication Controller Interface (NCI) in the Linux kernel before 3.4.5 allow remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via incoming frames with crafted length fields.",
        "id": 56
    },
    {
        "cve_id": "CVE-2012-3364",
        "code_before_change": "static __u8 *nci_extract_rf_params_nfcf_passive_poll(struct nci_dev *ndev,\n\t\t\tstruct rf_tech_specific_params_nfcf_poll *nfcf_poll,\n\t\t\t\t\t\t     __u8 *data)\n{\n\tnfcf_poll->bit_rate = *data++;\n\tnfcf_poll->sensf_res_len = *data++;\n\n\tpr_debug(\"bit_rate %d, sensf_res_len %d\\n\",\n\t\t nfcf_poll->bit_rate, nfcf_poll->sensf_res_len);\n\n\tmemcpy(nfcf_poll->sensf_res, data, nfcf_poll->sensf_res_len);\n\tdata += nfcf_poll->sensf_res_len;\n\n\treturn data;\n}",
        "code_after_change": "static __u8 *nci_extract_rf_params_nfcf_passive_poll(struct nci_dev *ndev,\n\t\t\tstruct rf_tech_specific_params_nfcf_poll *nfcf_poll,\n\t\t\t\t\t\t     __u8 *data)\n{\n\tnfcf_poll->bit_rate = *data++;\n\tnfcf_poll->sensf_res_len = min_t(__u8, *data++, NFC_SENSF_RES_MAXSIZE);\n\n\tpr_debug(\"bit_rate %d, sensf_res_len %d\\n\",\n\t\t nfcf_poll->bit_rate, nfcf_poll->sensf_res_len);\n\n\tmemcpy(nfcf_poll->sensf_res, data, nfcf_poll->sensf_res_len);\n\tdata += nfcf_poll->sensf_res_len;\n\n\treturn data;\n}",
        "patch": "--- code before\n+++ code after\n@@ -3,7 +3,7 @@\n \t\t\t\t\t\t     __u8 *data)\n {\n \tnfcf_poll->bit_rate = *data++;\n-\tnfcf_poll->sensf_res_len = *data++;\n+\tnfcf_poll->sensf_res_len = min_t(__u8, *data++, NFC_SENSF_RES_MAXSIZE);\n \n \tpr_debug(\"bit_rate %d, sensf_res_len %d\\n\",\n \t\t nfcf_poll->bit_rate, nfcf_poll->sensf_res_len);",
        "function_modified_lines": {
            "added": [
                "\tnfcf_poll->sensf_res_len = min_t(__u8, *data++, NFC_SENSF_RES_MAXSIZE);"
            ],
            "deleted": [
                "\tnfcf_poll->sensf_res_len = *data++;"
            ]
        },
        "cwe": [
            "CWE-119"
        ],
        "cve_description": "Multiple stack-based buffer overflows in the Near Field Communication Controller Interface (NCI) in the Linux kernel before 3.4.5 allow remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via incoming frames with crafted length fields.",
        "id": 55
    },
    {
        "cve_id": "CVE-2017-15126",
        "code_before_change": "static void userfaultfd_event_wait_completion(struct userfaultfd_ctx *ctx,\n\t\t\t\t\t      struct userfaultfd_wait_queue *ewq)\n{\n\tif (WARN_ON_ONCE(current->flags & PF_EXITING))\n\t\tgoto out;\n\n\tewq->ctx = ctx;\n\tinit_waitqueue_entry(&ewq->wq, current);\n\n\tspin_lock(&ctx->event_wqh.lock);\n\t/*\n\t * After the __add_wait_queue the uwq is visible to userland\n\t * through poll/read().\n\t */\n\t__add_wait_queue(&ctx->event_wqh, &ewq->wq);\n\tfor (;;) {\n\t\tset_current_state(TASK_KILLABLE);\n\t\tif (ewq->msg.event == 0)\n\t\t\tbreak;\n\t\tif (ACCESS_ONCE(ctx->released) ||\n\t\t    fatal_signal_pending(current)) {\n\t\t\t__remove_wait_queue(&ctx->event_wqh, &ewq->wq);\n\t\t\tif (ewq->msg.event == UFFD_EVENT_FORK) {\n\t\t\t\tstruct userfaultfd_ctx *new;\n\n\t\t\t\tnew = (struct userfaultfd_ctx *)\n\t\t\t\t\t(unsigned long)\n\t\t\t\t\tewq->msg.arg.reserved.reserved1;\n\n\t\t\t\tuserfaultfd_ctx_put(new);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tspin_unlock(&ctx->event_wqh.lock);\n\n\t\twake_up_poll(&ctx->fd_wqh, POLLIN);\n\t\tschedule();\n\n\t\tspin_lock(&ctx->event_wqh.lock);\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tspin_unlock(&ctx->event_wqh.lock);\n\n\t/*\n\t * ctx may go away after this if the userfault pseudo fd is\n\t * already released.\n\t */\nout:\n\tuserfaultfd_ctx_put(ctx);\n}",
        "code_after_change": "static void userfaultfd_event_wait_completion(struct userfaultfd_ctx *ctx,\n\t\t\t\t\t      struct userfaultfd_wait_queue *ewq)\n{\n\tif (WARN_ON_ONCE(current->flags & PF_EXITING))\n\t\tgoto out;\n\n\tewq->ctx = ctx;\n\tinit_waitqueue_entry(&ewq->wq, current);\n\n\tspin_lock(&ctx->event_wqh.lock);\n\t/*\n\t * After the __add_wait_queue the uwq is visible to userland\n\t * through poll/read().\n\t */\n\t__add_wait_queue(&ctx->event_wqh, &ewq->wq);\n\tfor (;;) {\n\t\tset_current_state(TASK_KILLABLE);\n\t\tif (ewq->msg.event == 0)\n\t\t\tbreak;\n\t\tif (ACCESS_ONCE(ctx->released) ||\n\t\t    fatal_signal_pending(current)) {\n\t\t\t/*\n\t\t\t * &ewq->wq may be queued in fork_event, but\n\t\t\t * __remove_wait_queue ignores the head\n\t\t\t * parameter. It would be a problem if it\n\t\t\t * didn't.\n\t\t\t */\n\t\t\t__remove_wait_queue(&ctx->event_wqh, &ewq->wq);\n\t\t\tif (ewq->msg.event == UFFD_EVENT_FORK) {\n\t\t\t\tstruct userfaultfd_ctx *new;\n\n\t\t\t\tnew = (struct userfaultfd_ctx *)\n\t\t\t\t\t(unsigned long)\n\t\t\t\t\tewq->msg.arg.reserved.reserved1;\n\n\t\t\t\tuserfaultfd_ctx_put(new);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tspin_unlock(&ctx->event_wqh.lock);\n\n\t\twake_up_poll(&ctx->fd_wqh, POLLIN);\n\t\tschedule();\n\n\t\tspin_lock(&ctx->event_wqh.lock);\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tspin_unlock(&ctx->event_wqh.lock);\n\n\t/*\n\t * ctx may go away after this if the userfault pseudo fd is\n\t * already released.\n\t */\nout:\n\tuserfaultfd_ctx_put(ctx);\n}",
        "patch": "--- code before\n+++ code after\n@@ -19,6 +19,12 @@\n \t\t\tbreak;\n \t\tif (ACCESS_ONCE(ctx->released) ||\n \t\t    fatal_signal_pending(current)) {\n+\t\t\t/*\n+\t\t\t * &ewq->wq may be queued in fork_event, but\n+\t\t\t * __remove_wait_queue ignores the head\n+\t\t\t * parameter. It would be a problem if it\n+\t\t\t * didn't.\n+\t\t\t */\n \t\t\t__remove_wait_queue(&ctx->event_wqh, &ewq->wq);\n \t\t\tif (ewq->msg.event == UFFD_EVENT_FORK) {\n \t\t\t\tstruct userfaultfd_ctx *new;",
        "function_modified_lines": {
            "added": [
                "\t\t\t/*",
                "\t\t\t * &ewq->wq may be queued in fork_event, but",
                "\t\t\t * __remove_wait_queue ignores the head",
                "\t\t\t * parameter. It would be a problem if it",
                "\t\t\t * didn't.",
                "\t\t\t */"
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-119"
        ],
        "cve_description": "A use-after-free flaw was found in fs/userfaultfd.c in the Linux kernel before 4.13.6. The issue is related to the handling of fork failure when dealing with event messages. Failure to fork correctly can lead to a situation where a fork event will be removed from an already freed list of events with userfaultfd_ctx_put().",
        "id": 1297
    },
    {
        "cve_id": "CVE-2016-4998",
        "code_before_change": "static inline int check_entry_size_and_hooks(struct arpt_entry *e,\n\t\t\t\t\t     struct xt_table_info *newinfo,\n\t\t\t\t\t     const unsigned char *base,\n\t\t\t\t\t     const unsigned char *limit,\n\t\t\t\t\t     const unsigned int *hook_entries,\n\t\t\t\t\t     const unsigned int *underflows,\n\t\t\t\t\t     unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\n\tif ((unsigned long)e % __alignof__(struct arpt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct arpt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset\n\t    < sizeof(struct arpt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!arp_checkentry(&e->arp))\n\t\treturn -EINVAL;\n\n\terr = xt_check_entry_offsets(e, e->target_offset, e->next_offset);\n\tif (err)\n\t\treturn err;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_ARP_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\n\t/* Clear counters and comefrom */\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}",
        "code_after_change": "static inline int check_entry_size_and_hooks(struct arpt_entry *e,\n\t\t\t\t\t     struct xt_table_info *newinfo,\n\t\t\t\t\t     const unsigned char *base,\n\t\t\t\t\t     const unsigned char *limit,\n\t\t\t\t\t     const unsigned int *hook_entries,\n\t\t\t\t\t     const unsigned int *underflows,\n\t\t\t\t\t     unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\n\tif ((unsigned long)e % __alignof__(struct arpt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct arpt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset\n\t    < sizeof(struct arpt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!arp_checkentry(&e->arp))\n\t\treturn -EINVAL;\n\n\terr = xt_check_entry_offsets(e, e->elems, e->target_offset,\n\t\t\t\t     e->next_offset);\n\tif (err)\n\t\treturn err;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_ARP_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\n\t/* Clear counters and comefrom */\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -26,7 +26,8 @@\n \tif (!arp_checkentry(&e->arp))\n \t\treturn -EINVAL;\n \n-\terr = xt_check_entry_offsets(e, e->target_offset, e->next_offset);\n+\terr = xt_check_entry_offsets(e, e->elems, e->target_offset,\n+\t\t\t\t     e->next_offset);\n \tif (err)\n \t\treturn err;\n ",
        "function_modified_lines": {
            "added": [
                "\terr = xt_check_entry_offsets(e, e->elems, e->target_offset,",
                "\t\t\t\t     e->next_offset);"
            ],
            "deleted": [
                "\terr = xt_check_entry_offsets(e, e->target_offset, e->next_offset);"
            ]
        },
        "cwe": [
            "CWE-119"
        ],
        "cve_description": "The IPT_SO_SET_REPLACE setsockopt implementation in the netfilter subsystem in the Linux kernel before 4.6 allows local users to cause a denial of service (out-of-bounds read) or possibly obtain sensitive information from kernel heap memory by leveraging in-container root access to provide a crafted offset value that leads to crossing a ruleset blob boundary.",
        "id": 1046
    },
    {
        "cve_id": "CVE-2016-4998",
        "code_before_change": "static int\ncheck_compat_entry_size_and_hooks(struct compat_ipt_entry *e,\n\t\t\t\t  struct xt_table_info *newinfo,\n\t\t\t\t  unsigned int *size,\n\t\t\t\t  const unsigned char *base,\n\t\t\t\t  const unsigned char *limit,\n\t\t\t\t  const unsigned int *hook_entries,\n\t\t\t\t  const unsigned int *underflows,\n\t\t\t\t  const char *name)\n{\n\tstruct xt_entry_match *ematch;\n\tstruct xt_entry_target *t;\n\tstruct xt_target *target;\n\tunsigned int entry_offset;\n\tunsigned int j;\n\tint ret, off, h;\n\n\tduprintf(\"check_compat_entry_size_and_hooks %p\\n\", e);\n\tif ((unsigned long)e % __alignof__(struct compat_ipt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct compat_ipt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p, limit = %p\\n\", e, limit);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset < sizeof(struct compat_ipt_entry) +\n\t\t\t     sizeof(struct compat_xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!ip_checkentry(&e->ip))\n\t\treturn -EINVAL;\n\n\tret = xt_compat_check_entry_offsets(e,\n\t\t\t\t\t    e->target_offset, e->next_offset);\n\tif (ret)\n\t\treturn ret;\n\n\toff = sizeof(struct ipt_entry) - sizeof(struct compat_ipt_entry);\n\tentry_offset = (void *)e - (void *)base;\n\tj = 0;\n\txt_ematch_foreach(ematch, e) {\n\t\tret = compat_find_calc_match(ematch, name, &e->ip, &off);\n\t\tif (ret != 0)\n\t\t\tgoto release_matches;\n\t\t++j;\n\t}\n\n\tt = compat_ipt_get_target(e);\n\ttarget = xt_request_find_target(NFPROTO_IPV4, t->u.user.name,\n\t\t\t\t\tt->u.user.revision);\n\tif (IS_ERR(target)) {\n\t\tduprintf(\"check_compat_entry_size_and_hooks: `%s' not found\\n\",\n\t\t\t t->u.user.name);\n\t\tret = PTR_ERR(target);\n\t\tgoto release_matches;\n\t}\n\tt->u.kernel.target = target;\n\n\toff += xt_compat_target_offset(target);\n\t*size += off;\n\tret = xt_compat_add_offset(AF_INET, entry_offset, off);\n\tif (ret)\n\t\tgoto out;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h])\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t}\n\n\t/* Clear counters and comefrom */\n\tmemset(&e->counters, 0, sizeof(e->counters));\n\te->comefrom = 0;\n\treturn 0;\n\nout:\n\tmodule_put(t->u.kernel.target->me);\nrelease_matches:\n\txt_ematch_foreach(ematch, e) {\n\t\tif (j-- == 0)\n\t\t\tbreak;\n\t\tmodule_put(ematch->u.kernel.match->me);\n\t}\n\treturn ret;\n}",
        "code_after_change": "static int\ncheck_compat_entry_size_and_hooks(struct compat_ipt_entry *e,\n\t\t\t\t  struct xt_table_info *newinfo,\n\t\t\t\t  unsigned int *size,\n\t\t\t\t  const unsigned char *base,\n\t\t\t\t  const unsigned char *limit,\n\t\t\t\t  const unsigned int *hook_entries,\n\t\t\t\t  const unsigned int *underflows,\n\t\t\t\t  const char *name)\n{\n\tstruct xt_entry_match *ematch;\n\tstruct xt_entry_target *t;\n\tstruct xt_target *target;\n\tunsigned int entry_offset;\n\tunsigned int j;\n\tint ret, off, h;\n\n\tduprintf(\"check_compat_entry_size_and_hooks %p\\n\", e);\n\tif ((unsigned long)e % __alignof__(struct compat_ipt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct compat_ipt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p, limit = %p\\n\", e, limit);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset < sizeof(struct compat_ipt_entry) +\n\t\t\t     sizeof(struct compat_xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!ip_checkentry(&e->ip))\n\t\treturn -EINVAL;\n\n\tret = xt_compat_check_entry_offsets(e, e->elems,\n\t\t\t\t\t    e->target_offset, e->next_offset);\n\tif (ret)\n\t\treturn ret;\n\n\toff = sizeof(struct ipt_entry) - sizeof(struct compat_ipt_entry);\n\tentry_offset = (void *)e - (void *)base;\n\tj = 0;\n\txt_ematch_foreach(ematch, e) {\n\t\tret = compat_find_calc_match(ematch, name, &e->ip, &off);\n\t\tif (ret != 0)\n\t\t\tgoto release_matches;\n\t\t++j;\n\t}\n\n\tt = compat_ipt_get_target(e);\n\ttarget = xt_request_find_target(NFPROTO_IPV4, t->u.user.name,\n\t\t\t\t\tt->u.user.revision);\n\tif (IS_ERR(target)) {\n\t\tduprintf(\"check_compat_entry_size_and_hooks: `%s' not found\\n\",\n\t\t\t t->u.user.name);\n\t\tret = PTR_ERR(target);\n\t\tgoto release_matches;\n\t}\n\tt->u.kernel.target = target;\n\n\toff += xt_compat_target_offset(target);\n\t*size += off;\n\tret = xt_compat_add_offset(AF_INET, entry_offset, off);\n\tif (ret)\n\t\tgoto out;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h])\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t}\n\n\t/* Clear counters and comefrom */\n\tmemset(&e->counters, 0, sizeof(e->counters));\n\te->comefrom = 0;\n\treturn 0;\n\nout:\n\tmodule_put(t->u.kernel.target->me);\nrelease_matches:\n\txt_ematch_foreach(ematch, e) {\n\t\tif (j-- == 0)\n\t\t\tbreak;\n\t\tmodule_put(ematch->u.kernel.match->me);\n\t}\n\treturn ret;\n}",
        "patch": "--- code before\n+++ code after\n@@ -33,7 +33,7 @@\n \tif (!ip_checkentry(&e->ip))\n \t\treturn -EINVAL;\n \n-\tret = xt_compat_check_entry_offsets(e,\n+\tret = xt_compat_check_entry_offsets(e, e->elems,\n \t\t\t\t\t    e->target_offset, e->next_offset);\n \tif (ret)\n \t\treturn ret;",
        "function_modified_lines": {
            "added": [
                "\tret = xt_compat_check_entry_offsets(e, e->elems,"
            ],
            "deleted": [
                "\tret = xt_compat_check_entry_offsets(e,"
            ]
        },
        "cwe": [
            "CWE-119"
        ],
        "cve_description": "The IPT_SO_SET_REPLACE setsockopt implementation in the netfilter subsystem in the Linux kernel before 4.6 allows local users to cause a denial of service (out-of-bounds read) or possibly obtain sensitive information from kernel heap memory by leveraging in-container root access to provide a crafted offset value that leads to crossing a ruleset blob boundary.",
        "id": 1048
    },
    {
        "cve_id": "CVE-2017-5548",
        "code_before_change": "static int atusb_get_and_show_revision(struct atusb *atusb)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tunsigned char buffer[3];\n\tint ret;\n\n\t/* Get a couple of the ATMega Firmware values */\n\tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t\tATUSB_ID, ATUSB_REQ_FROM_DEV, 0, 0,\n\t\t\t\tbuffer, 3, 1000);\n\tif (ret >= 0) {\n\t\tatusb->fw_ver_maj = buffer[0];\n\t\tatusb->fw_ver_min = buffer[1];\n\t\tatusb->fw_hw_type = buffer[2];\n\n\t\tdev_info(&usb_dev->dev,\n\t\t\t \"Firmware: major: %u, minor: %u, hardware type: %u\\n\",\n\t\t\t atusb->fw_ver_maj, atusb->fw_ver_min, atusb->fw_hw_type);\n\t}\n\tif (atusb->fw_ver_maj == 0 && atusb->fw_ver_min < 2) {\n\t\tdev_info(&usb_dev->dev,\n\t\t\t \"Firmware version (%u.%u) predates our first public release.\",\n\t\t\t atusb->fw_ver_maj, atusb->fw_ver_min);\n\t\tdev_info(&usb_dev->dev, \"Please update to version 0.2 or newer\");\n\t}\n\n\treturn ret;\n}",
        "code_after_change": "static int atusb_get_and_show_revision(struct atusb *atusb)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tunsigned char *buffer;\n\tint ret;\n\n\tbuffer = kmalloc(3, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\t/* Get a couple of the ATMega Firmware values */\n\tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t\tATUSB_ID, ATUSB_REQ_FROM_DEV, 0, 0,\n\t\t\t\tbuffer, 3, 1000);\n\tif (ret >= 0) {\n\t\tatusb->fw_ver_maj = buffer[0];\n\t\tatusb->fw_ver_min = buffer[1];\n\t\tatusb->fw_hw_type = buffer[2];\n\n\t\tdev_info(&usb_dev->dev,\n\t\t\t \"Firmware: major: %u, minor: %u, hardware type: %u\\n\",\n\t\t\t atusb->fw_ver_maj, atusb->fw_ver_min, atusb->fw_hw_type);\n\t}\n\tif (atusb->fw_ver_maj == 0 && atusb->fw_ver_min < 2) {\n\t\tdev_info(&usb_dev->dev,\n\t\t\t \"Firmware version (%u.%u) predates our first public release.\",\n\t\t\t atusb->fw_ver_maj, atusb->fw_ver_min);\n\t\tdev_info(&usb_dev->dev, \"Please update to version 0.2 or newer\");\n\t}\n\n\tkfree(buffer);\n\treturn ret;\n}",
        "patch": "--- code before\n+++ code after\n@@ -1,8 +1,12 @@\n static int atusb_get_and_show_revision(struct atusb *atusb)\n {\n \tstruct usb_device *usb_dev = atusb->usb_dev;\n-\tunsigned char buffer[3];\n+\tunsigned char *buffer;\n \tint ret;\n+\n+\tbuffer = kmalloc(3, GFP_KERNEL);\n+\tif (!buffer)\n+\t\treturn -ENOMEM;\n \n \t/* Get a couple of the ATMega Firmware values */\n \tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n@@ -24,5 +28,6 @@\n \t\tdev_info(&usb_dev->dev, \"Please update to version 0.2 or newer\");\n \t}\n \n+\tkfree(buffer);\n \treturn ret;\n }",
        "function_modified_lines": {
            "added": [
                "\tunsigned char *buffer;",
                "",
                "\tbuffer = kmalloc(3, GFP_KERNEL);",
                "\tif (!buffer)",
                "\t\treturn -ENOMEM;",
                "\tkfree(buffer);"
            ],
            "deleted": [
                "\tunsigned char buffer[3];"
            ]
        },
        "cwe": [
            "CWE-119"
        ],
        "cve_description": "drivers/net/ieee802154/atusb.c in the Linux kernel 4.9.x before 4.9.6 interacts incorrectly with the CONFIG_VMAP_STACK option, which allows local users to cause a denial of service (system crash or memory corruption) or possibly have unspecified other impact by leveraging use of more than one virtual page for a DMA scatterlist.",
        "id": 1463
    },
    {
        "cve_id": "CVE-2012-6712",
        "code_before_change": "static void iwl_sta_ucode_activate(struct iwl_priv *priv, u8 sta_id)\n{\n\n\tif (!(priv->stations[sta_id].used & IWL_STA_DRIVER_ACTIVE))\n\t\tIWL_ERR(priv, \"ACTIVATE a non DRIVER active station id %u \"\n\t\t\t\"addr %pM\\n\",\n\t\t\tsta_id, priv->stations[sta_id].sta.sta.addr);\n\n\tif (priv->stations[sta_id].used & IWL_STA_UCODE_ACTIVE) {\n\t\tIWL_DEBUG_ASSOC(priv,\n\t\t\t\t\"STA id %u addr %pM already present in uCode \"\n\t\t\t\t\"(according to driver)\\n\",\n\t\t\t\tsta_id, priv->stations[sta_id].sta.sta.addr);\n\t} else {\n\t\tpriv->stations[sta_id].used |= IWL_STA_UCODE_ACTIVE;\n\t\tIWL_DEBUG_ASSOC(priv, \"Added STA id %u addr %pM to uCode\\n\",\n\t\t\t\tsta_id, priv->stations[sta_id].sta.sta.addr);\n\t}\n}",
        "code_after_change": "static int iwl_sta_ucode_activate(struct iwl_priv *priv, u8 sta_id)\n{\n\tif (sta_id >= IWLAGN_STATION_COUNT) {\n\t\tIWL_ERR(priv, \"invalid sta_id %u\", sta_id);\n\t\treturn -EINVAL;\n\t}\n\tif (!(priv->stations[sta_id].used & IWL_STA_DRIVER_ACTIVE))\n\t\tIWL_ERR(priv, \"ACTIVATE a non DRIVER active station id %u \"\n\t\t\t\"addr %pM\\n\",\n\t\t\tsta_id, priv->stations[sta_id].sta.sta.addr);\n\n\tif (priv->stations[sta_id].used & IWL_STA_UCODE_ACTIVE) {\n\t\tIWL_DEBUG_ASSOC(priv,\n\t\t\t\t\"STA id %u addr %pM already present in uCode \"\n\t\t\t\t\"(according to driver)\\n\",\n\t\t\t\tsta_id, priv->stations[sta_id].sta.sta.addr);\n\t} else {\n\t\tpriv->stations[sta_id].used |= IWL_STA_UCODE_ACTIVE;\n\t\tIWL_DEBUG_ASSOC(priv, \"Added STA id %u addr %pM to uCode\\n\",\n\t\t\t\tsta_id, priv->stations[sta_id].sta.sta.addr);\n\t}\n\treturn 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -1,6 +1,9 @@\n-static void iwl_sta_ucode_activate(struct iwl_priv *priv, u8 sta_id)\n+static int iwl_sta_ucode_activate(struct iwl_priv *priv, u8 sta_id)\n {\n-\n+\tif (sta_id >= IWLAGN_STATION_COUNT) {\n+\t\tIWL_ERR(priv, \"invalid sta_id %u\", sta_id);\n+\t\treturn -EINVAL;\n+\t}\n \tif (!(priv->stations[sta_id].used & IWL_STA_DRIVER_ACTIVE))\n \t\tIWL_ERR(priv, \"ACTIVATE a non DRIVER active station id %u \"\n \t\t\t\"addr %pM\\n\",\n@@ -16,4 +19,5 @@\n \t\tIWL_DEBUG_ASSOC(priv, \"Added STA id %u addr %pM to uCode\\n\",\n \t\t\t\tsta_id, priv->stations[sta_id].sta.sta.addr);\n \t}\n+\treturn 0;\n }",
        "function_modified_lines": {
            "added": [
                "static int iwl_sta_ucode_activate(struct iwl_priv *priv, u8 sta_id)",
                "\tif (sta_id >= IWLAGN_STATION_COUNT) {",
                "\t\tIWL_ERR(priv, \"invalid sta_id %u\", sta_id);",
                "\t\treturn -EINVAL;",
                "\t}",
                "\treturn 0;"
            ],
            "deleted": [
                "static void iwl_sta_ucode_activate(struct iwl_priv *priv, u8 sta_id)",
                ""
            ]
        },
        "cwe": [
            "CWE-119"
        ],
        "cve_description": "In the Linux kernel before 3.4, a buffer overflow occurs in drivers/net/wireless/iwlwifi/iwl-agn-sta.c, which will cause at least memory corruption.",
        "id": 144
    },
    {
        "cve_id": "CVE-2017-16996",
        "code_before_change": "static int check_alu_op(struct bpf_verifier_env *env, struct bpf_insn *insn)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env);\n\tu8 opcode = BPF_OP(insn->code);\n\tint err;\n\n\tif (opcode == BPF_END || opcode == BPF_NEG) {\n\t\tif (opcode == BPF_NEG) {\n\t\t\tif (BPF_SRC(insn->code) != 0 ||\n\t\t\t    insn->src_reg != BPF_REG_0 ||\n\t\t\t    insn->off != 0 || insn->imm != 0) {\n\t\t\t\tverbose(env, \"BPF_NEG uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\tif (insn->src_reg != BPF_REG_0 || insn->off != 0 ||\n\t\t\t    (insn->imm != 16 && insn->imm != 32 && insn->imm != 64) ||\n\t\t\t    BPF_CLASS(insn->code) == BPF_ALU64) {\n\t\t\t\tverbose(env, \"BPF_END uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/* check src operand */\n\t\terr = check_reg_arg(env, insn->dst_reg, SRC_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (is_pointer_value(env, insn->dst_reg)) {\n\t\t\tverbose(env, \"R%d pointer arithmetic prohibited\\n\",\n\t\t\t\tinsn->dst_reg);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\t/* check dest operand */\n\t\terr = check_reg_arg(env, insn->dst_reg, DST_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t} else if (opcode == BPF_MOV) {\n\n\t\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tif (insn->imm != 0 || insn->off != 0) {\n\t\t\t\tverbose(env, \"BPF_MOV uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\t/* check src operand */\n\t\t\terr = check_reg_arg(env, insn->src_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\tif (insn->src_reg != BPF_REG_0 || insn->off != 0) {\n\t\t\t\tverbose(env, \"BPF_MOV uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/* check dest operand */\n\t\terr = check_reg_arg(env, insn->dst_reg, DST_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tif (BPF_CLASS(insn->code) == BPF_ALU64) {\n\t\t\t\t/* case: R1 = R2\n\t\t\t\t * copy register state to dest reg\n\t\t\t\t */\n\t\t\t\tregs[insn->dst_reg] = regs[insn->src_reg];\n\t\t\t\tregs[insn->dst_reg].live |= REG_LIVE_WRITTEN;\n\t\t\t} else {\n\t\t\t\t/* R1 = (u32) R2 */\n\t\t\t\tif (is_pointer_value(env, insn->src_reg)) {\n\t\t\t\t\tverbose(env,\n\t\t\t\t\t\t\"R%d partial copy of pointer\\n\",\n\t\t\t\t\t\tinsn->src_reg);\n\t\t\t\t\treturn -EACCES;\n\t\t\t\t}\n\t\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\t\t/* high 32 bits are known zero. */\n\t\t\t\tregs[insn->dst_reg].var_off = tnum_cast(\n\t\t\t\t\t\tregs[insn->dst_reg].var_off, 4);\n\t\t\t\t__update_reg_bounds(&regs[insn->dst_reg]);\n\t\t\t}\n\t\t} else {\n\t\t\t/* case: R = imm\n\t\t\t * remember the value we stored into this reg\n\t\t\t */\n\t\t\tregs[insn->dst_reg].type = SCALAR_VALUE;\n\t\t\tif (BPF_CLASS(insn->code) == BPF_ALU64) {\n\t\t\t\t__mark_reg_known(regs + insn->dst_reg,\n\t\t\t\t\t\t insn->imm);\n\t\t\t} else {\n\t\t\t\t__mark_reg_known(regs + insn->dst_reg,\n\t\t\t\t\t\t (u32)insn->imm);\n\t\t\t}\n\t\t}\n\n\t} else if (opcode > BPF_END) {\n\t\tverbose(env, \"invalid BPF_ALU opcode %x\\n\", opcode);\n\t\treturn -EINVAL;\n\n\t} else {\t/* all other ALU ops: and, sub, xor, add, ... */\n\n\t\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tif (insn->imm != 0 || insn->off != 0) {\n\t\t\t\tverbose(env, \"BPF_ALU uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t/* check src1 operand */\n\t\t\terr = check_reg_arg(env, insn->src_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\tif (insn->src_reg != BPF_REG_0 || insn->off != 0) {\n\t\t\t\tverbose(env, \"BPF_ALU uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/* check src2 operand */\n\t\terr = check_reg_arg(env, insn->dst_reg, SRC_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif ((opcode == BPF_MOD || opcode == BPF_DIV) &&\n\t\t    BPF_SRC(insn->code) == BPF_K && insn->imm == 0) {\n\t\t\tverbose(env, \"div by zero\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif ((opcode == BPF_LSH || opcode == BPF_RSH ||\n\t\t     opcode == BPF_ARSH) && BPF_SRC(insn->code) == BPF_K) {\n\t\t\tint size = BPF_CLASS(insn->code) == BPF_ALU64 ? 64 : 32;\n\n\t\t\tif (insn->imm < 0 || insn->imm >= size) {\n\t\t\t\tverbose(env, \"invalid shift %d\\n\", insn->imm);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/* check dest operand */\n\t\terr = check_reg_arg(env, insn->dst_reg, DST_OP_NO_MARK);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\treturn adjust_reg_min_max_vals(env, insn);\n\t}\n\n\treturn 0;\n}",
        "code_after_change": "static int check_alu_op(struct bpf_verifier_env *env, struct bpf_insn *insn)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env);\n\tu8 opcode = BPF_OP(insn->code);\n\tint err;\n\n\tif (opcode == BPF_END || opcode == BPF_NEG) {\n\t\tif (opcode == BPF_NEG) {\n\t\t\tif (BPF_SRC(insn->code) != 0 ||\n\t\t\t    insn->src_reg != BPF_REG_0 ||\n\t\t\t    insn->off != 0 || insn->imm != 0) {\n\t\t\t\tverbose(env, \"BPF_NEG uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\tif (insn->src_reg != BPF_REG_0 || insn->off != 0 ||\n\t\t\t    (insn->imm != 16 && insn->imm != 32 && insn->imm != 64) ||\n\t\t\t    BPF_CLASS(insn->code) == BPF_ALU64) {\n\t\t\t\tverbose(env, \"BPF_END uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/* check src operand */\n\t\terr = check_reg_arg(env, insn->dst_reg, SRC_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (is_pointer_value(env, insn->dst_reg)) {\n\t\t\tverbose(env, \"R%d pointer arithmetic prohibited\\n\",\n\t\t\t\tinsn->dst_reg);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\t/* check dest operand */\n\t\terr = check_reg_arg(env, insn->dst_reg, DST_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t} else if (opcode == BPF_MOV) {\n\n\t\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tif (insn->imm != 0 || insn->off != 0) {\n\t\t\t\tverbose(env, \"BPF_MOV uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\t/* check src operand */\n\t\t\terr = check_reg_arg(env, insn->src_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\tif (insn->src_reg != BPF_REG_0 || insn->off != 0) {\n\t\t\t\tverbose(env, \"BPF_MOV uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/* check dest operand */\n\t\terr = check_reg_arg(env, insn->dst_reg, DST_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tif (BPF_CLASS(insn->code) == BPF_ALU64) {\n\t\t\t\t/* case: R1 = R2\n\t\t\t\t * copy register state to dest reg\n\t\t\t\t */\n\t\t\t\tregs[insn->dst_reg] = regs[insn->src_reg];\n\t\t\t\tregs[insn->dst_reg].live |= REG_LIVE_WRITTEN;\n\t\t\t} else {\n\t\t\t\t/* R1 = (u32) R2 */\n\t\t\t\tif (is_pointer_value(env, insn->src_reg)) {\n\t\t\t\t\tverbose(env,\n\t\t\t\t\t\t\"R%d partial copy of pointer\\n\",\n\t\t\t\t\t\tinsn->src_reg);\n\t\t\t\t\treturn -EACCES;\n\t\t\t\t}\n\t\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\t\tcoerce_reg_to_size(&regs[insn->dst_reg], 4);\n\t\t\t}\n\t\t} else {\n\t\t\t/* case: R = imm\n\t\t\t * remember the value we stored into this reg\n\t\t\t */\n\t\t\tregs[insn->dst_reg].type = SCALAR_VALUE;\n\t\t\tif (BPF_CLASS(insn->code) == BPF_ALU64) {\n\t\t\t\t__mark_reg_known(regs + insn->dst_reg,\n\t\t\t\t\t\t insn->imm);\n\t\t\t} else {\n\t\t\t\t__mark_reg_known(regs + insn->dst_reg,\n\t\t\t\t\t\t (u32)insn->imm);\n\t\t\t}\n\t\t}\n\n\t} else if (opcode > BPF_END) {\n\t\tverbose(env, \"invalid BPF_ALU opcode %x\\n\", opcode);\n\t\treturn -EINVAL;\n\n\t} else {\t/* all other ALU ops: and, sub, xor, add, ... */\n\n\t\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tif (insn->imm != 0 || insn->off != 0) {\n\t\t\t\tverbose(env, \"BPF_ALU uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t/* check src1 operand */\n\t\t\terr = check_reg_arg(env, insn->src_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\tif (insn->src_reg != BPF_REG_0 || insn->off != 0) {\n\t\t\t\tverbose(env, \"BPF_ALU uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/* check src2 operand */\n\t\terr = check_reg_arg(env, insn->dst_reg, SRC_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif ((opcode == BPF_MOD || opcode == BPF_DIV) &&\n\t\t    BPF_SRC(insn->code) == BPF_K && insn->imm == 0) {\n\t\t\tverbose(env, \"div by zero\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif ((opcode == BPF_LSH || opcode == BPF_RSH ||\n\t\t     opcode == BPF_ARSH) && BPF_SRC(insn->code) == BPF_K) {\n\t\t\tint size = BPF_CLASS(insn->code) == BPF_ALU64 ? 64 : 32;\n\n\t\t\tif (insn->imm < 0 || insn->imm >= size) {\n\t\t\t\tverbose(env, \"invalid shift %d\\n\", insn->imm);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/* check dest operand */\n\t\terr = check_reg_arg(env, insn->dst_reg, DST_OP_NO_MARK);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\treturn adjust_reg_min_max_vals(env, insn);\n\t}\n\n\treturn 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -77,10 +77,7 @@\n \t\t\t\t\treturn -EACCES;\n \t\t\t\t}\n \t\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n-\t\t\t\t/* high 32 bits are known zero. */\n-\t\t\t\tregs[insn->dst_reg].var_off = tnum_cast(\n-\t\t\t\t\t\tregs[insn->dst_reg].var_off, 4);\n-\t\t\t\t__update_reg_bounds(&regs[insn->dst_reg]);\n+\t\t\t\tcoerce_reg_to_size(&regs[insn->dst_reg], 4);\n \t\t\t}\n \t\t} else {\n \t\t\t/* case: R = imm",
        "function_modified_lines": {
            "added": [
                "\t\t\t\tcoerce_reg_to_size(&regs[insn->dst_reg], 4);"
            ],
            "deleted": [
                "\t\t\t\t/* high 32 bits are known zero. */",
                "\t\t\t\tregs[insn->dst_reg].var_off = tnum_cast(",
                "\t\t\t\t\t\tregs[insn->dst_reg].var_off, 4);",
                "\t\t\t\t__update_reg_bounds(&regs[insn->dst_reg]);"
            ]
        },
        "cwe": [
            "CWE-119"
        ],
        "cve_description": "kernel/bpf/verifier.c in the Linux kernel through 4.14.8 allows local users to cause a denial of service (memory corruption) or possibly have unspecified other impact by leveraging register truncation mishandling.",
        "id": 1355
    },
    {
        "cve_id": "CVE-2013-2850",
        "code_before_change": "static int iscsi_add_notunderstood_response(\n\tchar *key,\n\tchar *value,\n\tstruct iscsi_param_list *param_list)\n{\n\tstruct iscsi_extra_response *extra_response;\n\n\tif (strlen(value) > VALUE_MAXLEN) {\n\t\tpr_err(\"Value for notunderstood key \\\"%s\\\" exceeds %d,\"\n\t\t\t\" protocol error.\\n\", key, VALUE_MAXLEN);\n\t\treturn -1;\n\t}\n\n\textra_response = kzalloc(sizeof(struct iscsi_extra_response), GFP_KERNEL);\n\tif (!extra_response) {\n\t\tpr_err(\"Unable to allocate memory for\"\n\t\t\t\" struct iscsi_extra_response.\\n\");\n\t\treturn -1;\n\t}\n\tINIT_LIST_HEAD(&extra_response->er_list);\n\n\tstrncpy(extra_response->key, key, strlen(key) + 1);\n\tstrncpy(extra_response->value, NOTUNDERSTOOD,\n\t\t\tstrlen(NOTUNDERSTOOD) + 1);\n\n\tlist_add_tail(&extra_response->er_list,\n\t\t\t&param_list->extra_response_list);\n\treturn 0;\n}",
        "code_after_change": "static int iscsi_add_notunderstood_response(\n\tchar *key,\n\tchar *value,\n\tstruct iscsi_param_list *param_list)\n{\n\tstruct iscsi_extra_response *extra_response;\n\n\tif (strlen(value) > VALUE_MAXLEN) {\n\t\tpr_err(\"Value for notunderstood key \\\"%s\\\" exceeds %d,\"\n\t\t\t\" protocol error.\\n\", key, VALUE_MAXLEN);\n\t\treturn -1;\n\t}\n\n\textra_response = kzalloc(sizeof(struct iscsi_extra_response), GFP_KERNEL);\n\tif (!extra_response) {\n\t\tpr_err(\"Unable to allocate memory for\"\n\t\t\t\" struct iscsi_extra_response.\\n\");\n\t\treturn -1;\n\t}\n\tINIT_LIST_HEAD(&extra_response->er_list);\n\n\tstrlcpy(extra_response->key, key, sizeof(extra_response->key));\n\tstrlcpy(extra_response->value, NOTUNDERSTOOD,\n\t\tsizeof(extra_response->value));\n\n\tlist_add_tail(&extra_response->er_list,\n\t\t\t&param_list->extra_response_list);\n\treturn 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -19,9 +19,9 @@\n \t}\n \tINIT_LIST_HEAD(&extra_response->er_list);\n \n-\tstrncpy(extra_response->key, key, strlen(key) + 1);\n-\tstrncpy(extra_response->value, NOTUNDERSTOOD,\n-\t\t\tstrlen(NOTUNDERSTOOD) + 1);\n+\tstrlcpy(extra_response->key, key, sizeof(extra_response->key));\n+\tstrlcpy(extra_response->value, NOTUNDERSTOOD,\n+\t\tsizeof(extra_response->value));\n \n \tlist_add_tail(&extra_response->er_list,\n \t\t\t&param_list->extra_response_list);",
        "function_modified_lines": {
            "added": [
                "\tstrlcpy(extra_response->key, key, sizeof(extra_response->key));",
                "\tstrlcpy(extra_response->value, NOTUNDERSTOOD,",
                "\t\tsizeof(extra_response->value));"
            ],
            "deleted": [
                "\tstrncpy(extra_response->key, key, strlen(key) + 1);",
                "\tstrncpy(extra_response->value, NOTUNDERSTOOD,",
                "\t\t\tstrlen(NOTUNDERSTOOD) + 1);"
            ]
        },
        "cwe": [
            "CWE-119"
        ],
        "cve_description": "Heap-based buffer overflow in the iscsi_add_notunderstood_response function in drivers/target/iscsi/iscsi_target_parameters.c in the iSCSI target subsystem in the Linux kernel through 3.9.4 allows remote attackers to cause a denial of service (memory corruption and OOPS) or possibly execute arbitrary code via a long key that is not properly handled during construction of an error-response packet.",
        "id": 239
    },
    {
        "cve_id": "CVE-2014-3184",
        "code_before_change": "static __u8 *sp_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tif (*rsize >= 107 && rdesc[104] == 0x26 && rdesc[105] == 0x80 &&\n\t\t\trdesc[106] == 0x03) {\n\t\thid_info(hdev, \"fixing up Sunplus Wireless Desktop report descriptor\\n\");\n\t\trdesc[105] = rdesc[110] = 0x03;\n\t\trdesc[106] = rdesc[111] = 0x21;\n\t}\n\treturn rdesc;\n}",
        "code_after_change": "static __u8 *sp_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tif (*rsize >= 112 && rdesc[104] == 0x26 && rdesc[105] == 0x80 &&\n\t\t\trdesc[106] == 0x03) {\n\t\thid_info(hdev, \"fixing up Sunplus Wireless Desktop report descriptor\\n\");\n\t\trdesc[105] = rdesc[110] = 0x03;\n\t\trdesc[106] = rdesc[111] = 0x21;\n\t}\n\treturn rdesc;\n}",
        "patch": "--- code before\n+++ code after\n@@ -1,7 +1,7 @@\n static __u8 *sp_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n \t\tunsigned int *rsize)\n {\n-\tif (*rsize >= 107 && rdesc[104] == 0x26 && rdesc[105] == 0x80 &&\n+\tif (*rsize >= 112 && rdesc[104] == 0x26 && rdesc[105] == 0x80 &&\n \t\t\trdesc[106] == 0x03) {\n \t\thid_info(hdev, \"fixing up Sunplus Wireless Desktop report descriptor\\n\");\n \t\trdesc[105] = rdesc[110] = 0x03;",
        "function_modified_lines": {
            "added": [
                "\tif (*rsize >= 112 && rdesc[104] == 0x26 && rdesc[105] == 0x80 &&"
            ],
            "deleted": [
                "\tif (*rsize >= 107 && rdesc[104] == 0x26 && rdesc[105] == 0x80 &&"
            ]
        },
        "cwe": [
            "CWE-119"
        ],
        "cve_description": "The report_fixup functions in the HID subsystem in the Linux kernel before 3.16.2 might allow physically proximate attackers to cause a denial of service (out-of-bounds write) via a crafted device that provides a small report descriptor, related to (1) drivers/hid/hid-cherry.c, (2) drivers/hid/hid-kye.c, (3) drivers/hid/hid-lg.c, (4) drivers/hid/hid-monterey.c, (5) drivers/hid/hid-petalynx.c, and (6) drivers/hid/hid-sunplus.c.",
        "id": 520
    },
    {
        "cve_id": "CVE-2014-3184",
        "code_before_change": "static __u8 *pl_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tif (*rsize >= 60 && rdesc[39] == 0x2a && rdesc[40] == 0xf5 &&\n\t\t\trdesc[41] == 0x00 && rdesc[59] == 0x26 &&\n\t\t\trdesc[60] == 0xf9 && rdesc[61] == 0x00) {\n\t\thid_info(hdev, \"fixing up Petalynx Maxter Remote report descriptor\\n\");\n\t\trdesc[60] = 0xfa;\n\t\trdesc[40] = 0xfa;\n\t}\n\treturn rdesc;\n}",
        "code_after_change": "static __u8 *pl_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tif (*rsize >= 62 && rdesc[39] == 0x2a && rdesc[40] == 0xf5 &&\n\t\t\trdesc[41] == 0x00 && rdesc[59] == 0x26 &&\n\t\t\trdesc[60] == 0xf9 && rdesc[61] == 0x00) {\n\t\thid_info(hdev, \"fixing up Petalynx Maxter Remote report descriptor\\n\");\n\t\trdesc[60] = 0xfa;\n\t\trdesc[40] = 0xfa;\n\t}\n\treturn rdesc;\n}",
        "patch": "--- code before\n+++ code after\n@@ -1,7 +1,7 @@\n static __u8 *pl_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n \t\tunsigned int *rsize)\n {\n-\tif (*rsize >= 60 && rdesc[39] == 0x2a && rdesc[40] == 0xf5 &&\n+\tif (*rsize >= 62 && rdesc[39] == 0x2a && rdesc[40] == 0xf5 &&\n \t\t\trdesc[41] == 0x00 && rdesc[59] == 0x26 &&\n \t\t\trdesc[60] == 0xf9 && rdesc[61] == 0x00) {\n \t\thid_info(hdev, \"fixing up Petalynx Maxter Remote report descriptor\\n\");",
        "function_modified_lines": {
            "added": [
                "\tif (*rsize >= 62 && rdesc[39] == 0x2a && rdesc[40] == 0xf5 &&"
            ],
            "deleted": [
                "\tif (*rsize >= 60 && rdesc[39] == 0x2a && rdesc[40] == 0xf5 &&"
            ]
        },
        "cwe": [
            "CWE-119"
        ],
        "cve_description": "The report_fixup functions in the HID subsystem in the Linux kernel before 3.16.2 might allow physically proximate attackers to cause a denial of service (out-of-bounds write) via a crafted device that provides a small report descriptor, related to (1) drivers/hid/hid-cherry.c, (2) drivers/hid/hid-kye.c, (3) drivers/hid/hid-lg.c, (4) drivers/hid/hid-monterey.c, (5) drivers/hid/hid-petalynx.c, and (6) drivers/hid/hid-sunplus.c.",
        "id": 519
    },
    {
        "cve_id": "CVE-2018-7740",
        "code_before_change": "int hugetlb_reserve_pages(struct inode *inode,\n\t\t\t\t\tlong from, long to,\n\t\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\t\tvm_flags_t vm_flags)\n{\n\tlong ret, chg;\n\tstruct hstate *h = hstate_inode(inode);\n\tstruct hugepage_subpool *spool = subpool_inode(inode);\n\tstruct resv_map *resv_map;\n\tlong gbl_reserve;\n\n\t/*\n\t * Only apply hugepage reservation if asked. At fault time, an\n\t * attempt will be made for VM_NORESERVE to allocate a page\n\t * without using reserves\n\t */\n\tif (vm_flags & VM_NORESERVE)\n\t\treturn 0;\n\n\t/*\n\t * Shared mappings base their reservation on the number of pages that\n\t * are already allocated on behalf of the file. Private mappings need\n\t * to reserve the full area even if read-only as mprotect() may be\n\t * called to make the mapping read-write. Assume !vma is a shm mapping\n\t */\n\tif (!vma || vma->vm_flags & VM_MAYSHARE) {\n\t\tresv_map = inode_resv_map(inode);\n\n\t\tchg = region_chg(resv_map, from, to);\n\n\t} else {\n\t\tresv_map = resv_map_alloc();\n\t\tif (!resv_map)\n\t\t\treturn -ENOMEM;\n\n\t\tchg = to - from;\n\n\t\tset_vma_resv_map(vma, resv_map);\n\t\tset_vma_resv_flags(vma, HPAGE_RESV_OWNER);\n\t}\n\n\tif (chg < 0) {\n\t\tret = chg;\n\t\tgoto out_err;\n\t}\n\n\t/*\n\t * There must be enough pages in the subpool for the mapping. If\n\t * the subpool has a minimum size, there may be some global\n\t * reservations already in place (gbl_reserve).\n\t */\n\tgbl_reserve = hugepage_subpool_get_pages(spool, chg);\n\tif (gbl_reserve < 0) {\n\t\tret = -ENOSPC;\n\t\tgoto out_err;\n\t}\n\n\t/*\n\t * Check enough hugepages are available for the reservation.\n\t * Hand the pages back to the subpool if there are not\n\t */\n\tret = hugetlb_acct_memory(h, gbl_reserve);\n\tif (ret < 0) {\n\t\t/* put back original number of pages, chg */\n\t\t(void)hugepage_subpool_put_pages(spool, chg);\n\t\tgoto out_err;\n\t}\n\n\t/*\n\t * Account for the reservations made. Shared mappings record regions\n\t * that have reservations as they are shared by multiple VMAs.\n\t * When the last VMA disappears, the region map says how much\n\t * the reservation was and the page cache tells how much of\n\t * the reservation was consumed. Private mappings are per-VMA and\n\t * only the consumed reservations are tracked. When the VMA\n\t * disappears, the original reservation is the VMA size and the\n\t * consumed reservations are stored in the map. Hence, nothing\n\t * else has to be done for private mappings here\n\t */\n\tif (!vma || vma->vm_flags & VM_MAYSHARE) {\n\t\tlong add = region_add(resv_map, from, to);\n\n\t\tif (unlikely(chg > add)) {\n\t\t\t/*\n\t\t\t * pages in this range were added to the reserve\n\t\t\t * map between region_chg and region_add.  This\n\t\t\t * indicates a race with alloc_huge_page.  Adjust\n\t\t\t * the subpool and reserve counts modified above\n\t\t\t * based on the difference.\n\t\t\t */\n\t\t\tlong rsv_adjust;\n\n\t\t\trsv_adjust = hugepage_subpool_put_pages(spool,\n\t\t\t\t\t\t\t\tchg - add);\n\t\t\thugetlb_acct_memory(h, -rsv_adjust);\n\t\t}\n\t}\n\treturn 0;\nout_err:\n\tif (!vma || vma->vm_flags & VM_MAYSHARE)\n\t\t/* Don't call region_abort if region_chg failed */\n\t\tif (chg >= 0)\n\t\t\tregion_abort(resv_map, from, to);\n\tif (vma && is_vma_resv_set(vma, HPAGE_RESV_OWNER))\n\t\tkref_put(&resv_map->refs, resv_map_release);\n\treturn ret;\n}",
        "code_after_change": "int hugetlb_reserve_pages(struct inode *inode,\n\t\t\t\t\tlong from, long to,\n\t\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\t\tvm_flags_t vm_flags)\n{\n\tlong ret, chg;\n\tstruct hstate *h = hstate_inode(inode);\n\tstruct hugepage_subpool *spool = subpool_inode(inode);\n\tstruct resv_map *resv_map;\n\tlong gbl_reserve;\n\n\t/* This should never happen */\n\tif (from > to) {\n\t\tVM_WARN(1, \"%s called with a negative range\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Only apply hugepage reservation if asked. At fault time, an\n\t * attempt will be made for VM_NORESERVE to allocate a page\n\t * without using reserves\n\t */\n\tif (vm_flags & VM_NORESERVE)\n\t\treturn 0;\n\n\t/*\n\t * Shared mappings base their reservation on the number of pages that\n\t * are already allocated on behalf of the file. Private mappings need\n\t * to reserve the full area even if read-only as mprotect() may be\n\t * called to make the mapping read-write. Assume !vma is a shm mapping\n\t */\n\tif (!vma || vma->vm_flags & VM_MAYSHARE) {\n\t\tresv_map = inode_resv_map(inode);\n\n\t\tchg = region_chg(resv_map, from, to);\n\n\t} else {\n\t\tresv_map = resv_map_alloc();\n\t\tif (!resv_map)\n\t\t\treturn -ENOMEM;\n\n\t\tchg = to - from;\n\n\t\tset_vma_resv_map(vma, resv_map);\n\t\tset_vma_resv_flags(vma, HPAGE_RESV_OWNER);\n\t}\n\n\tif (chg < 0) {\n\t\tret = chg;\n\t\tgoto out_err;\n\t}\n\n\t/*\n\t * There must be enough pages in the subpool for the mapping. If\n\t * the subpool has a minimum size, there may be some global\n\t * reservations already in place (gbl_reserve).\n\t */\n\tgbl_reserve = hugepage_subpool_get_pages(spool, chg);\n\tif (gbl_reserve < 0) {\n\t\tret = -ENOSPC;\n\t\tgoto out_err;\n\t}\n\n\t/*\n\t * Check enough hugepages are available for the reservation.\n\t * Hand the pages back to the subpool if there are not\n\t */\n\tret = hugetlb_acct_memory(h, gbl_reserve);\n\tif (ret < 0) {\n\t\t/* put back original number of pages, chg */\n\t\t(void)hugepage_subpool_put_pages(spool, chg);\n\t\tgoto out_err;\n\t}\n\n\t/*\n\t * Account for the reservations made. Shared mappings record regions\n\t * that have reservations as they are shared by multiple VMAs.\n\t * When the last VMA disappears, the region map says how much\n\t * the reservation was and the page cache tells how much of\n\t * the reservation was consumed. Private mappings are per-VMA and\n\t * only the consumed reservations are tracked. When the VMA\n\t * disappears, the original reservation is the VMA size and the\n\t * consumed reservations are stored in the map. Hence, nothing\n\t * else has to be done for private mappings here\n\t */\n\tif (!vma || vma->vm_flags & VM_MAYSHARE) {\n\t\tlong add = region_add(resv_map, from, to);\n\n\t\tif (unlikely(chg > add)) {\n\t\t\t/*\n\t\t\t * pages in this range were added to the reserve\n\t\t\t * map between region_chg and region_add.  This\n\t\t\t * indicates a race with alloc_huge_page.  Adjust\n\t\t\t * the subpool and reserve counts modified above\n\t\t\t * based on the difference.\n\t\t\t */\n\t\t\tlong rsv_adjust;\n\n\t\t\trsv_adjust = hugepage_subpool_put_pages(spool,\n\t\t\t\t\t\t\t\tchg - add);\n\t\t\thugetlb_acct_memory(h, -rsv_adjust);\n\t\t}\n\t}\n\treturn 0;\nout_err:\n\tif (!vma || vma->vm_flags & VM_MAYSHARE)\n\t\t/* Don't call region_abort if region_chg failed */\n\t\tif (chg >= 0)\n\t\t\tregion_abort(resv_map, from, to);\n\tif (vma && is_vma_resv_set(vma, HPAGE_RESV_OWNER))\n\t\tkref_put(&resv_map->refs, resv_map_release);\n\treturn ret;\n}",
        "patch": "--- code before\n+++ code after\n@@ -8,6 +8,12 @@\n \tstruct hugepage_subpool *spool = subpool_inode(inode);\n \tstruct resv_map *resv_map;\n \tlong gbl_reserve;\n+\n+\t/* This should never happen */\n+\tif (from > to) {\n+\t\tVM_WARN(1, \"%s called with a negative range\\n\", __func__);\n+\t\treturn -EINVAL;\n+\t}\n \n \t/*\n \t * Only apply hugepage reservation if asked. At fault time, an",
        "function_modified_lines": {
            "added": [
                "",
                "\t/* This should never happen */",
                "\tif (from > to) {",
                "\t\tVM_WARN(1, \"%s called with a negative range\\n\", __func__);",
                "\t\treturn -EINVAL;",
                "\t}"
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-119"
        ],
        "cve_description": "The resv_map_release function in mm/hugetlb.c in the Linux kernel through 4.15.7 allows local users to cause a denial of service (BUG) via a crafted application that makes mmap system calls and has a large pgoff argument to the remap_file_pages system call.",
        "id": 1849
    },
    {
        "cve_id": "CVE-2014-6416",
        "code_before_change": "static int ceph_x_verify_authorizer_reply(struct ceph_auth_client *ac,\n\t\t\t\t\t  struct ceph_authorizer *a, size_t len)\n{\n\tstruct ceph_x_authorizer *au = (void *)a;\n\tstruct ceph_x_ticket_handler *th;\n\tint ret = 0;\n\tstruct ceph_x_authorize_reply reply;\n\tvoid *p = au->reply_buf;\n\tvoid *end = p + sizeof(au->reply_buf);\n\n\tth = get_ticket_handler(ac, au->service);\n\tif (IS_ERR(th))\n\t\treturn PTR_ERR(th);\n\tret = ceph_x_decrypt(&th->session_key, &p, end, &reply, sizeof(reply));\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret != sizeof(reply))\n\t\treturn -EPERM;\n\n\tif (au->nonce + 1 != le64_to_cpu(reply.nonce_plus_one))\n\t\tret = -EPERM;\n\telse\n\t\tret = 0;\n\tdout(\"verify_authorizer_reply nonce %llx got %llx ret %d\\n\",\n\t     au->nonce, le64_to_cpu(reply.nonce_plus_one), ret);\n\treturn ret;\n}",
        "code_after_change": "static int ceph_x_verify_authorizer_reply(struct ceph_auth_client *ac,\n\t\t\t\t\t  struct ceph_authorizer *a, size_t len)\n{\n\tstruct ceph_x_authorizer *au = (void *)a;\n\tstruct ceph_x_ticket_handler *th;\n\tint ret = 0;\n\tstruct ceph_x_authorize_reply reply;\n\tvoid *preply = &reply;\n\tvoid *p = au->reply_buf;\n\tvoid *end = p + sizeof(au->reply_buf);\n\n\tth = get_ticket_handler(ac, au->service);\n\tif (IS_ERR(th))\n\t\treturn PTR_ERR(th);\n\tret = ceph_x_decrypt(&th->session_key, &p, end, &preply, sizeof(reply));\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret != sizeof(reply))\n\t\treturn -EPERM;\n\n\tif (au->nonce + 1 != le64_to_cpu(reply.nonce_plus_one))\n\t\tret = -EPERM;\n\telse\n\t\tret = 0;\n\tdout(\"verify_authorizer_reply nonce %llx got %llx ret %d\\n\",\n\t     au->nonce, le64_to_cpu(reply.nonce_plus_one), ret);\n\treturn ret;\n}",
        "patch": "--- code before\n+++ code after\n@@ -5,13 +5,14 @@\n \tstruct ceph_x_ticket_handler *th;\n \tint ret = 0;\n \tstruct ceph_x_authorize_reply reply;\n+\tvoid *preply = &reply;\n \tvoid *p = au->reply_buf;\n \tvoid *end = p + sizeof(au->reply_buf);\n \n \tth = get_ticket_handler(ac, au->service);\n \tif (IS_ERR(th))\n \t\treturn PTR_ERR(th);\n-\tret = ceph_x_decrypt(&th->session_key, &p, end, &reply, sizeof(reply));\n+\tret = ceph_x_decrypt(&th->session_key, &p, end, &preply, sizeof(reply));\n \tif (ret < 0)\n \t\treturn ret;\n \tif (ret != sizeof(reply))",
        "function_modified_lines": {
            "added": [
                "\tvoid *preply = &reply;",
                "\tret = ceph_x_decrypt(&th->session_key, &p, end, &preply, sizeof(reply));"
            ],
            "deleted": [
                "\tret = ceph_x_decrypt(&th->session_key, &p, end, &reply, sizeof(reply));"
            ]
        },
        "cwe": [
            "CWE-119"
        ],
        "cve_description": "Buffer overflow in net/ceph/auth_x.c in Ceph, as used in the Linux kernel before 3.16.3, allows remote attackers to cause a denial of service (memory corruption and panic) or possibly have unspecified other impact via a long unencrypted auth ticket.",
        "id": 581
    },
    {
        "cve_id": "CVE-2017-7895",
        "code_before_change": "int\nnfs3svc_decode_writeargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_writeargs *args)\n{\n\tunsigned int len, v, hdr, dlen;\n\tu32 max_blocksize = svc_max_payload(rqstp);\n\tstruct kvec *head = rqstp->rq_arg.head;\n\tstruct kvec *tail = rqstp->rq_arg.tail;\n\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\tp = xdr_decode_hyper(p, &args->offset);\n\n\targs->count = ntohl(*p++);\n\targs->stable = ntohl(*p++);\n\tlen = args->len = ntohl(*p++);\n\t/*\n\t * The count must equal the amount of data passed.\n\t */\n\tif (args->count != args->len)\n\t\treturn 0;\n\n\t/*\n\t * Check to make sure that we got the right number of\n\t * bytes.\n\t */\n\thdr = (void*)p - head->iov_base;\n\tdlen = head->iov_len + rqstp->rq_arg.page_len + tail->iov_len - hdr;\n\t/*\n\t * Round the length of the data which was specified up to\n\t * the next multiple of XDR units and then compare that\n\t * against the length which was actually received.\n\t * Note that when RPCSEC/GSS (for example) is used, the\n\t * data buffer can be padded so dlen might be larger\n\t * than required.  It must never be smaller.\n\t */\n\tif (dlen < XDR_QUADLEN(len)*4)\n\t\treturn 0;\n\n\tif (args->count > max_blocksize) {\n\t\targs->count = max_blocksize;\n\t\tlen = args->len = max_blocksize;\n\t}\n\trqstp->rq_vec[0].iov_base = (void*)p;\n\trqstp->rq_vec[0].iov_len = head->iov_len - hdr;\n\tv = 0;\n\twhile (len > rqstp->rq_vec[v].iov_len) {\n\t\tlen -= rqstp->rq_vec[v].iov_len;\n\t\tv++;\n\t\trqstp->rq_vec[v].iov_base = page_address(rqstp->rq_pages[v]);\n\t\trqstp->rq_vec[v].iov_len = PAGE_SIZE;\n\t}\n\trqstp->rq_vec[v].iov_len = len;\n\targs->vlen = v + 1;\n\treturn 1;\n}",
        "code_after_change": "int\nnfs3svc_decode_writeargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_writeargs *args)\n{\n\tunsigned int len, v, hdr, dlen;\n\tu32 max_blocksize = svc_max_payload(rqstp);\n\tstruct kvec *head = rqstp->rq_arg.head;\n\tstruct kvec *tail = rqstp->rq_arg.tail;\n\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\tp = xdr_decode_hyper(p, &args->offset);\n\n\targs->count = ntohl(*p++);\n\targs->stable = ntohl(*p++);\n\tlen = args->len = ntohl(*p++);\n\tif ((void *)p > head->iov_base + head->iov_len)\n\t\treturn 0;\n\t/*\n\t * The count must equal the amount of data passed.\n\t */\n\tif (args->count != args->len)\n\t\treturn 0;\n\n\t/*\n\t * Check to make sure that we got the right number of\n\t * bytes.\n\t */\n\thdr = (void*)p - head->iov_base;\n\tdlen = head->iov_len + rqstp->rq_arg.page_len + tail->iov_len - hdr;\n\t/*\n\t * Round the length of the data which was specified up to\n\t * the next multiple of XDR units and then compare that\n\t * against the length which was actually received.\n\t * Note that when RPCSEC/GSS (for example) is used, the\n\t * data buffer can be padded so dlen might be larger\n\t * than required.  It must never be smaller.\n\t */\n\tif (dlen < XDR_QUADLEN(len)*4)\n\t\treturn 0;\n\n\tif (args->count > max_blocksize) {\n\t\targs->count = max_blocksize;\n\t\tlen = args->len = max_blocksize;\n\t}\n\trqstp->rq_vec[0].iov_base = (void*)p;\n\trqstp->rq_vec[0].iov_len = head->iov_len - hdr;\n\tv = 0;\n\twhile (len > rqstp->rq_vec[v].iov_len) {\n\t\tlen -= rqstp->rq_vec[v].iov_len;\n\t\tv++;\n\t\trqstp->rq_vec[v].iov_base = page_address(rqstp->rq_pages[v]);\n\t\trqstp->rq_vec[v].iov_len = PAGE_SIZE;\n\t}\n\trqstp->rq_vec[v].iov_len = len;\n\targs->vlen = v + 1;\n\treturn 1;\n}",
        "patch": "--- code before\n+++ code after\n@@ -15,6 +15,8 @@\n \targs->count = ntohl(*p++);\n \targs->stable = ntohl(*p++);\n \tlen = args->len = ntohl(*p++);\n+\tif ((void *)p > head->iov_base + head->iov_len)\n+\t\treturn 0;\n \t/*\n \t * The count must equal the amount of data passed.\n \t */",
        "function_modified_lines": {
            "added": [
                "\tif ((void *)p > head->iov_base + head->iov_len)",
                "\t\treturn 0;"
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-119"
        ],
        "cve_description": "The NFSv2 and NFSv3 server implementations in the Linux kernel through 4.10.13 lack certain checks for the end of a buffer, which allows remote attackers to trigger pointer-arithmetic errors or possibly have unspecified other impact via crafted requests, related to fs/nfsd/nfs3xdr.c and fs/nfsd/nfsxdr.c.",
        "id": 1532
    },
    {
        "cve_id": "CVE-2017-7895",
        "code_before_change": "int\nnfs3svc_decode_symlinkargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_symlinkargs *args)\n{\n\tunsigned int len, avail;\n\tchar *old, *new;\n\tstruct kvec *vec;\n\n\tif (!(p = decode_fh(p, &args->ffh)) ||\n\t    !(p = decode_filename(p, &args->fname, &args->flen))\n\t\t)\n\t\treturn 0;\n\tp = decode_sattr3(p, &args->attrs);\n\n\t/* now decode the pathname, which might be larger than the first page.\n\t * As we have to check for nul's anyway, we copy it into a new page\n\t * This page appears in the rq_res.pages list, but as pages_len is always\n\t * 0, it won't get in the way\n\t */\n\tlen = ntohl(*p++);\n\tif (len == 0 || len > NFS3_MAXPATHLEN || len >= PAGE_SIZE)\n\t\treturn 0;\n\targs->tname = new = page_address(*(rqstp->rq_next_page++));\n\targs->tlen = len;\n\t/* first copy and check from the first page */\n\told = (char*)p;\n\tvec = &rqstp->rq_arg.head[0];\n\tavail = vec->iov_len - (old - (char*)vec->iov_base);\n\twhile (len && avail && *old) {\n\t\t*new++ = *old++;\n\t\tlen--;\n\t\tavail--;\n\t}\n\t/* now copy next page if there is one */\n\tif (len && !avail && rqstp->rq_arg.page_len) {\n\t\tavail = min_t(unsigned int, rqstp->rq_arg.page_len, PAGE_SIZE);\n\t\told = page_address(rqstp->rq_arg.pages[0]);\n\t}\n\twhile (len && avail && *old) {\n\t\t*new++ = *old++;\n\t\tlen--;\n\t\tavail--;\n\t}\n\t*new = '\\0';\n\tif (len)\n\t\treturn 0;\n\n\treturn 1;\n}",
        "code_after_change": "int\nnfs3svc_decode_symlinkargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_symlinkargs *args)\n{\n\tunsigned int len, avail;\n\tchar *old, *new;\n\tstruct kvec *vec;\n\n\tif (!(p = decode_fh(p, &args->ffh)) ||\n\t    !(p = decode_filename(p, &args->fname, &args->flen))\n\t\t)\n\t\treturn 0;\n\tp = decode_sattr3(p, &args->attrs);\n\n\t/* now decode the pathname, which might be larger than the first page.\n\t * As we have to check for nul's anyway, we copy it into a new page\n\t * This page appears in the rq_res.pages list, but as pages_len is always\n\t * 0, it won't get in the way\n\t */\n\tlen = ntohl(*p++);\n\tif (len == 0 || len > NFS3_MAXPATHLEN || len >= PAGE_SIZE)\n\t\treturn 0;\n\targs->tname = new = page_address(*(rqstp->rq_next_page++));\n\targs->tlen = len;\n\t/* first copy and check from the first page */\n\told = (char*)p;\n\tvec = &rqstp->rq_arg.head[0];\n\tif ((void *)old > vec->iov_base + vec->iov_len)\n\t\treturn 0;\n\tavail = vec->iov_len - (old - (char*)vec->iov_base);\n\twhile (len && avail && *old) {\n\t\t*new++ = *old++;\n\t\tlen--;\n\t\tavail--;\n\t}\n\t/* now copy next page if there is one */\n\tif (len && !avail && rqstp->rq_arg.page_len) {\n\t\tavail = min_t(unsigned int, rqstp->rq_arg.page_len, PAGE_SIZE);\n\t\told = page_address(rqstp->rq_arg.pages[0]);\n\t}\n\twhile (len && avail && *old) {\n\t\t*new++ = *old++;\n\t\tlen--;\n\t\tavail--;\n\t}\n\t*new = '\\0';\n\tif (len)\n\t\treturn 0;\n\n\treturn 1;\n}",
        "patch": "--- code before\n+++ code after\n@@ -25,6 +25,8 @@\n \t/* first copy and check from the first page */\n \told = (char*)p;\n \tvec = &rqstp->rq_arg.head[0];\n+\tif ((void *)old > vec->iov_base + vec->iov_len)\n+\t\treturn 0;\n \tavail = vec->iov_len - (old - (char*)vec->iov_base);\n \twhile (len && avail && *old) {\n \t\t*new++ = *old++;",
        "function_modified_lines": {
            "added": [
                "\tif ((void *)old > vec->iov_base + vec->iov_len)",
                "\t\treturn 0;"
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-119"
        ],
        "cve_description": "The NFSv2 and NFSv3 server implementations in the Linux kernel through 4.10.13 lack certain checks for the end of a buffer, which allows remote attackers to trigger pointer-arithmetic errors or possibly have unspecified other impact via crafted requests, related to fs/nfsd/nfs3xdr.c and fs/nfsd/nfsxdr.c.",
        "id": 1531
    },
    {
        "cve_id": "CVE-2017-18222",
        "code_before_change": "static int hns_xgmac_get_sset_count(int stringset)\n{\n\tif (stringset == ETH_SS_STATS)\n\t\treturn ARRAY_SIZE(g_xgmac_stats_string);\n\n\treturn 0;\n}",
        "code_after_change": "static int hns_xgmac_get_sset_count(int stringset)\n{\n\tif (stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS)\n\t\treturn ARRAY_SIZE(g_xgmac_stats_string);\n\n\treturn 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -1,6 +1,6 @@\n static int hns_xgmac_get_sset_count(int stringset)\n {\n-\tif (stringset == ETH_SS_STATS)\n+\tif (stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS)\n \t\treturn ARRAY_SIZE(g_xgmac_stats_string);\n \n \treturn 0;",
        "function_modified_lines": {
            "added": [
                "\tif (stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS)"
            ],
            "deleted": [
                "\tif (stringset == ETH_SS_STATS)"
            ]
        },
        "cwe": [
            "CWE-119"
        ],
        "cve_description": "In the Linux kernel before 4.12, Hisilicon Network Subsystem (HNS) does not consider the ETH_SS_PRIV_FLAGS case when retrieving sset_count data, which allows local users to cause a denial of service (buffer overflow and memory corruption) or possibly have unspecified other impact, as demonstrated by incompatibility between hns_get_sset_count and ethtool_get_strings.",
        "id": 1410
    },
    {
        "cve_id": "CVE-2017-18222",
        "code_before_change": "int hns_rcb_get_ring_sset_count(int stringset)\n{\n\tif (stringset == ETH_SS_STATS)\n\t\treturn HNS_RING_STATIC_REG_NUM;\n\n\treturn 0;\n}",
        "code_after_change": "int hns_rcb_get_ring_sset_count(int stringset)\n{\n\tif (stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS)\n\t\treturn HNS_RING_STATIC_REG_NUM;\n\n\treturn 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -1,6 +1,6 @@\n int hns_rcb_get_ring_sset_count(int stringset)\n {\n-\tif (stringset == ETH_SS_STATS)\n+\tif (stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS)\n \t\treturn HNS_RING_STATIC_REG_NUM;\n \n \treturn 0;",
        "function_modified_lines": {
            "added": [
                "\tif (stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS)"
            ],
            "deleted": [
                "\tif (stringset == ETH_SS_STATS)"
            ]
        },
        "cwe": [
            "CWE-119"
        ],
        "cve_description": "In the Linux kernel before 4.12, Hisilicon Network Subsystem (HNS) does not consider the ETH_SS_PRIV_FLAGS case when retrieving sset_count data, which allows local users to cause a denial of service (buffer overflow and memory corruption) or possibly have unspecified other impact, as demonstrated by incompatibility between hns_get_sset_count and ethtool_get_strings.",
        "id": 1409
    },
    {
        "cve_id": "CVE-2013-4312",
        "code_before_change": "void unix_inflight(struct file *fp)\n{\n\tstruct sock *s = unix_get_socket(fp);\n\n\tif (s) {\n\t\tstruct unix_sock *u = unix_sk(s);\n\n\t\tspin_lock(&unix_gc_lock);\n\n\t\tif (atomic_long_inc_return(&u->inflight) == 1) {\n\t\t\tBUG_ON(!list_empty(&u->link));\n\t\t\tlist_add_tail(&u->link, &gc_inflight_list);\n\t\t} else {\n\t\t\tBUG_ON(list_empty(&u->link));\n\t\t}\n\t\tunix_tot_inflight++;\n\t\tspin_unlock(&unix_gc_lock);\n\t}\n}",
        "code_after_change": "void unix_inflight(struct file *fp)\n{\n\tstruct sock *s = unix_get_socket(fp);\n\n\tspin_lock(&unix_gc_lock);\n\n\tif (s) {\n\t\tstruct unix_sock *u = unix_sk(s);\n\n\t\tif (atomic_long_inc_return(&u->inflight) == 1) {\n\t\t\tBUG_ON(!list_empty(&u->link));\n\t\t\tlist_add_tail(&u->link, &gc_inflight_list);\n\t\t} else {\n\t\t\tBUG_ON(list_empty(&u->link));\n\t\t}\n\t\tunix_tot_inflight++;\n\t}\n\tfp->f_cred->user->unix_inflight++;\n\tspin_unlock(&unix_gc_lock);\n}",
        "patch": "--- code before\n+++ code after\n@@ -2,10 +2,10 @@\n {\n \tstruct sock *s = unix_get_socket(fp);\n \n+\tspin_lock(&unix_gc_lock);\n+\n \tif (s) {\n \t\tstruct unix_sock *u = unix_sk(s);\n-\n-\t\tspin_lock(&unix_gc_lock);\n \n \t\tif (atomic_long_inc_return(&u->inflight) == 1) {\n \t\t\tBUG_ON(!list_empty(&u->link));\n@@ -14,6 +14,7 @@\n \t\t\tBUG_ON(list_empty(&u->link));\n \t\t}\n \t\tunix_tot_inflight++;\n-\t\tspin_unlock(&unix_gc_lock);\n \t}\n+\tfp->f_cred->user->unix_inflight++;\n+\tspin_unlock(&unix_gc_lock);\n }",
        "function_modified_lines": {
            "added": [
                "\tspin_lock(&unix_gc_lock);",
                "",
                "\tfp->f_cred->user->unix_inflight++;",
                "\tspin_unlock(&unix_gc_lock);"
            ],
            "deleted": [
                "",
                "\t\tspin_lock(&unix_gc_lock);",
                "\t\tspin_unlock(&unix_gc_lock);"
            ]
        },
        "cwe": [
            "CWE-119"
        ],
        "cve_description": "The Linux kernel before 4.4.1 allows local users to bypass file-descriptor limits and cause a denial of service (memory consumption) by sending each descriptor over a UNIX socket before closing it, related to net/unix/af_unix.c and net/unix/garbage.c.",
        "id": 296
    },
    {
        "cve_id": "CVE-2017-8062",
        "code_before_change": "static int tt_s2_4600_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dvb_usb_device *d = adap->dev;\n\tstruct dw2102_state *state = d->priv;\n\tu8 obuf[3] = { 0xe, 0x80, 0 };\n\tu8 ibuf[] = { 0 };\n\tstruct i2c_adapter *i2c_adapter;\n\tstruct i2c_client *client;\n\tstruct i2c_board_info board_info;\n\tstruct m88ds3103_platform_data m88ds3103_pdata = {};\n\tstruct ts2020_config ts2020_config = {};\n\n\tif (dvb_usb_generic_rw(d, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\n\tobuf[0] = 0xe;\n\tobuf[1] = 0x02;\n\tobuf[2] = 1;\n\n\tif (dvb_usb_generic_rw(d, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\tmsleep(300);\n\n\tobuf[0] = 0xe;\n\tobuf[1] = 0x83;\n\tobuf[2] = 0;\n\n\tif (dvb_usb_generic_rw(d, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\n\tobuf[0] = 0xe;\n\tobuf[1] = 0x83;\n\tobuf[2] = 1;\n\n\tif (dvb_usb_generic_rw(d, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\n\tobuf[0] = 0x51;\n\n\tif (dvb_usb_generic_rw(d, obuf, 1, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x51 transfer failed.\");\n\n\t/* attach demod */\n\tm88ds3103_pdata.clk = 27000000;\n\tm88ds3103_pdata.i2c_wr_max = 33;\n\tm88ds3103_pdata.ts_mode = M88DS3103_TS_CI;\n\tm88ds3103_pdata.ts_clk = 16000;\n\tm88ds3103_pdata.ts_clk_pol = 0;\n\tm88ds3103_pdata.spec_inv = 0;\n\tm88ds3103_pdata.agc = 0x99;\n\tm88ds3103_pdata.agc_inv = 0;\n\tm88ds3103_pdata.clk_out = M88DS3103_CLOCK_OUT_ENABLED;\n\tm88ds3103_pdata.envelope_mode = 0;\n\tm88ds3103_pdata.lnb_hv_pol = 1;\n\tm88ds3103_pdata.lnb_en_pol = 0;\n\tmemset(&board_info, 0, sizeof(board_info));\n\tstrlcpy(board_info.type, \"m88ds3103\", I2C_NAME_SIZE);\n\tboard_info.addr = 0x68;\n\tboard_info.platform_data = &m88ds3103_pdata;\n\trequest_module(\"m88ds3103\");\n\tclient = i2c_new_device(&d->i2c_adap, &board_info);\n\tif (client == NULL || client->dev.driver == NULL)\n\t\treturn -ENODEV;\n\tif (!try_module_get(client->dev.driver->owner)) {\n\t\ti2c_unregister_device(client);\n\t\treturn -ENODEV;\n\t}\n\tadap->fe_adap[0].fe = m88ds3103_pdata.get_dvb_frontend(client);\n\ti2c_adapter = m88ds3103_pdata.get_i2c_adapter(client);\n\n\tstate->i2c_client_demod = client;\n\n\t/* attach tuner */\n\tts2020_config.fe = adap->fe_adap[0].fe;\n\tmemset(&board_info, 0, sizeof(board_info));\n\tstrlcpy(board_info.type, \"ts2022\", I2C_NAME_SIZE);\n\tboard_info.addr = 0x60;\n\tboard_info.platform_data = &ts2020_config;\n\trequest_module(\"ts2020\");\n\tclient = i2c_new_device(i2c_adapter, &board_info);\n\n\tif (client == NULL || client->dev.driver == NULL) {\n\t\tdvb_frontend_detach(adap->fe_adap[0].fe);\n\t\treturn -ENODEV;\n\t}\n\n\tif (!try_module_get(client->dev.driver->owner)) {\n\t\ti2c_unregister_device(client);\n\t\tdvb_frontend_detach(adap->fe_adap[0].fe);\n\t\treturn -ENODEV;\n\t}\n\n\t/* delegate signal strength measurement to tuner */\n\tadap->fe_adap[0].fe->ops.read_signal_strength =\n\t\t\tadap->fe_adap[0].fe->ops.tuner_ops.get_rf_strength;\n\n\tstate->i2c_client_tuner = client;\n\n\t/* hook fe: need to resync the slave fifo when signal locks */\n\tstate->fe_read_status = adap->fe_adap[0].fe->ops.read_status;\n\tadap->fe_adap[0].fe->ops.read_status = tt_s2_4600_read_status;\n\n\tstate->last_lock = 0;\n\n\treturn 0;\n}",
        "code_after_change": "static int tt_s2_4600_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dvb_usb_device *d = adap->dev;\n\tstruct dw2102_state *state = d->priv;\n\tstruct i2c_adapter *i2c_adapter;\n\tstruct i2c_client *client;\n\tstruct i2c_board_info board_info;\n\tstruct m88ds3103_platform_data m88ds3103_pdata = {};\n\tstruct ts2020_config ts2020_config = {};\n\n\tmutex_lock(&d->data_mutex);\n\n\tstate->data[0] = 0xe;\n\tstate->data[1] = 0x80;\n\tstate->data[2] = 0x0;\n\n\tif (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\n\tstate->data[0] = 0xe;\n\tstate->data[1] = 0x02;\n\tstate->data[2] = 1;\n\n\tif (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\tmsleep(300);\n\n\tstate->data[0] = 0xe;\n\tstate->data[1] = 0x83;\n\tstate->data[2] = 0;\n\n\tif (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\n\tstate->data[0] = 0xe;\n\tstate->data[1] = 0x83;\n\tstate->data[2] = 1;\n\n\tif (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\n\tstate->data[0] = 0x51;\n\n\tif (dvb_usb_generic_rw(d, state->data, 1, state->data, 1, 0) < 0)\n\t\terr(\"command 0x51 transfer failed.\");\n\n\tmutex_unlock(&d->data_mutex);\n\n\t/* attach demod */\n\tm88ds3103_pdata.clk = 27000000;\n\tm88ds3103_pdata.i2c_wr_max = 33;\n\tm88ds3103_pdata.ts_mode = M88DS3103_TS_CI;\n\tm88ds3103_pdata.ts_clk = 16000;\n\tm88ds3103_pdata.ts_clk_pol = 0;\n\tm88ds3103_pdata.spec_inv = 0;\n\tm88ds3103_pdata.agc = 0x99;\n\tm88ds3103_pdata.agc_inv = 0;\n\tm88ds3103_pdata.clk_out = M88DS3103_CLOCK_OUT_ENABLED;\n\tm88ds3103_pdata.envelope_mode = 0;\n\tm88ds3103_pdata.lnb_hv_pol = 1;\n\tm88ds3103_pdata.lnb_en_pol = 0;\n\tmemset(&board_info, 0, sizeof(board_info));\n\tstrlcpy(board_info.type, \"m88ds3103\", I2C_NAME_SIZE);\n\tboard_info.addr = 0x68;\n\tboard_info.platform_data = &m88ds3103_pdata;\n\trequest_module(\"m88ds3103\");\n\tclient = i2c_new_device(&d->i2c_adap, &board_info);\n\tif (client == NULL || client->dev.driver == NULL)\n\t\treturn -ENODEV;\n\tif (!try_module_get(client->dev.driver->owner)) {\n\t\ti2c_unregister_device(client);\n\t\treturn -ENODEV;\n\t}\n\tadap->fe_adap[0].fe = m88ds3103_pdata.get_dvb_frontend(client);\n\ti2c_adapter = m88ds3103_pdata.get_i2c_adapter(client);\n\n\tstate->i2c_client_demod = client;\n\n\t/* attach tuner */\n\tts2020_config.fe = adap->fe_adap[0].fe;\n\tmemset(&board_info, 0, sizeof(board_info));\n\tstrlcpy(board_info.type, \"ts2022\", I2C_NAME_SIZE);\n\tboard_info.addr = 0x60;\n\tboard_info.platform_data = &ts2020_config;\n\trequest_module(\"ts2020\");\n\tclient = i2c_new_device(i2c_adapter, &board_info);\n\n\tif (client == NULL || client->dev.driver == NULL) {\n\t\tdvb_frontend_detach(adap->fe_adap[0].fe);\n\t\treturn -ENODEV;\n\t}\n\n\tif (!try_module_get(client->dev.driver->owner)) {\n\t\ti2c_unregister_device(client);\n\t\tdvb_frontend_detach(adap->fe_adap[0].fe);\n\t\treturn -ENODEV;\n\t}\n\n\t/* delegate signal strength measurement to tuner */\n\tadap->fe_adap[0].fe->ops.read_signal_strength =\n\t\t\tadap->fe_adap[0].fe->ops.tuner_ops.get_rf_strength;\n\n\tstate->i2c_client_tuner = client;\n\n\t/* hook fe: need to resync the slave fifo when signal locks */\n\tstate->fe_read_status = adap->fe_adap[0].fe->ops.read_status;\n\tadap->fe_adap[0].fe->ops.read_status = tt_s2_4600_read_status;\n\n\tstate->last_lock = 0;\n\n\treturn 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -2,43 +2,49 @@\n {\n \tstruct dvb_usb_device *d = adap->dev;\n \tstruct dw2102_state *state = d->priv;\n-\tu8 obuf[3] = { 0xe, 0x80, 0 };\n-\tu8 ibuf[] = { 0 };\n \tstruct i2c_adapter *i2c_adapter;\n \tstruct i2c_client *client;\n \tstruct i2c_board_info board_info;\n \tstruct m88ds3103_platform_data m88ds3103_pdata = {};\n \tstruct ts2020_config ts2020_config = {};\n \n-\tif (dvb_usb_generic_rw(d, obuf, 3, ibuf, 1, 0) < 0)\n+\tmutex_lock(&d->data_mutex);\n+\n+\tstate->data[0] = 0xe;\n+\tstate->data[1] = 0x80;\n+\tstate->data[2] = 0x0;\n+\n+\tif (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)\n \t\terr(\"command 0x0e transfer failed.\");\n \n-\tobuf[0] = 0xe;\n-\tobuf[1] = 0x02;\n-\tobuf[2] = 1;\n+\tstate->data[0] = 0xe;\n+\tstate->data[1] = 0x02;\n+\tstate->data[2] = 1;\n \n-\tif (dvb_usb_generic_rw(d, obuf, 3, ibuf, 1, 0) < 0)\n+\tif (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)\n \t\terr(\"command 0x0e transfer failed.\");\n \tmsleep(300);\n \n-\tobuf[0] = 0xe;\n-\tobuf[1] = 0x83;\n-\tobuf[2] = 0;\n+\tstate->data[0] = 0xe;\n+\tstate->data[1] = 0x83;\n+\tstate->data[2] = 0;\n \n-\tif (dvb_usb_generic_rw(d, obuf, 3, ibuf, 1, 0) < 0)\n+\tif (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)\n \t\terr(\"command 0x0e transfer failed.\");\n \n-\tobuf[0] = 0xe;\n-\tobuf[1] = 0x83;\n-\tobuf[2] = 1;\n+\tstate->data[0] = 0xe;\n+\tstate->data[1] = 0x83;\n+\tstate->data[2] = 1;\n \n-\tif (dvb_usb_generic_rw(d, obuf, 3, ibuf, 1, 0) < 0)\n+\tif (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)\n \t\terr(\"command 0x0e transfer failed.\");\n \n-\tobuf[0] = 0x51;\n+\tstate->data[0] = 0x51;\n \n-\tif (dvb_usb_generic_rw(d, obuf, 1, ibuf, 1, 0) < 0)\n+\tif (dvb_usb_generic_rw(d, state->data, 1, state->data, 1, 0) < 0)\n \t\terr(\"command 0x51 transfer failed.\");\n+\n+\tmutex_unlock(&d->data_mutex);\n \n \t/* attach demod */\n \tm88ds3103_pdata.clk = 27000000;",
        "function_modified_lines": {
            "added": [
                "\tmutex_lock(&d->data_mutex);",
                "",
                "\tstate->data[0] = 0xe;",
                "\tstate->data[1] = 0x80;",
                "\tstate->data[2] = 0x0;",
                "",
                "\tif (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)",
                "\tstate->data[0] = 0xe;",
                "\tstate->data[1] = 0x02;",
                "\tstate->data[2] = 1;",
                "\tif (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)",
                "\tstate->data[0] = 0xe;",
                "\tstate->data[1] = 0x83;",
                "\tstate->data[2] = 0;",
                "\tif (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)",
                "\tstate->data[0] = 0xe;",
                "\tstate->data[1] = 0x83;",
                "\tstate->data[2] = 1;",
                "\tif (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)",
                "\tstate->data[0] = 0x51;",
                "\tif (dvb_usb_generic_rw(d, state->data, 1, state->data, 1, 0) < 0)",
                "",
                "\tmutex_unlock(&d->data_mutex);"
            ],
            "deleted": [
                "\tu8 obuf[3] = { 0xe, 0x80, 0 };",
                "\tu8 ibuf[] = { 0 };",
                "\tif (dvb_usb_generic_rw(d, obuf, 3, ibuf, 1, 0) < 0)",
                "\tobuf[0] = 0xe;",
                "\tobuf[1] = 0x02;",
                "\tobuf[2] = 1;",
                "\tif (dvb_usb_generic_rw(d, obuf, 3, ibuf, 1, 0) < 0)",
                "\tobuf[0] = 0xe;",
                "\tobuf[1] = 0x83;",
                "\tobuf[2] = 0;",
                "\tif (dvb_usb_generic_rw(d, obuf, 3, ibuf, 1, 0) < 0)",
                "\tobuf[0] = 0xe;",
                "\tobuf[1] = 0x83;",
                "\tobuf[2] = 1;",
                "\tif (dvb_usb_generic_rw(d, obuf, 3, ibuf, 1, 0) < 0)",
                "\tobuf[0] = 0x51;",
                "\tif (dvb_usb_generic_rw(d, obuf, 1, ibuf, 1, 0) < 0)"
            ]
        },
        "cwe": [
            "CWE-119"
        ],
        "cve_description": "drivers/media/usb/dvb-usb/dw2102.c in the Linux kernel 4.9.x and 4.10.x before 4.10.4 interacts incorrectly with the CONFIG_VMAP_STACK option, which allows local users to cause a denial of service (system crash or memory corruption) or possibly have unspecified other impact by leveraging use of more than one virtual page for a DMA scatterlist.",
        "id": 1538
    },
    {
        "cve_id": "CVE-2013-2893",
        "code_before_change": "int lg2ff_init(struct hid_device *hid)\n{\n\tstruct lg2ff_device *lg2ff;\n\tstruct hid_report *report;\n\tstruct hid_input *hidinput = list_entry(hid->inputs.next,\n\t\t\t\t\t\tstruct hid_input, list);\n\tstruct list_head *report_list =\n\t\t\t&hid->report_enum[HID_OUTPUT_REPORT].report_list;\n\tstruct input_dev *dev = hidinput->input;\n\tint error;\n\n\tif (list_empty(report_list)) {\n\t\thid_err(hid, \"no output report found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treport = list_entry(report_list->next, struct hid_report, list);\n\n\tif (report->maxfield < 1) {\n\t\thid_err(hid, \"output report is empty\\n\");\n\t\treturn -ENODEV;\n\t}\n\tif (report->field[0]->report_count < 7) {\n\t\thid_err(hid, \"not enough values in the field\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tlg2ff = kmalloc(sizeof(struct lg2ff_device), GFP_KERNEL);\n\tif (!lg2ff)\n\t\treturn -ENOMEM;\n\n\tset_bit(FF_RUMBLE, dev->ffbit);\n\n\terror = input_ff_create_memless(dev, lg2ff, play_effect);\n\tif (error) {\n\t\tkfree(lg2ff);\n\t\treturn error;\n\t}\n\n\tlg2ff->report = report;\n\treport->field[0]->value[0] = 0xf3;\n\treport->field[0]->value[1] = 0x00;\n\treport->field[0]->value[2] = 0x00;\n\treport->field[0]->value[3] = 0x00;\n\treport->field[0]->value[4] = 0x00;\n\treport->field[0]->value[5] = 0x00;\n\treport->field[0]->value[6] = 0x00;\n\n\thid_hw_request(hid, report, HID_REQ_SET_REPORT);\n\n\thid_info(hid, \"Force feedback for Logitech RumblePad/Rumblepad 2 by Anssi Hannula <anssi.hannula@gmail.com>\\n\");\n\n\treturn 0;\n}",
        "code_after_change": "int lg2ff_init(struct hid_device *hid)\n{\n\tstruct lg2ff_device *lg2ff;\n\tstruct hid_report *report;\n\tstruct hid_input *hidinput = list_entry(hid->inputs.next,\n\t\t\t\t\t\tstruct hid_input, list);\n\tstruct input_dev *dev = hidinput->input;\n\tint error;\n\n\t/* Check that the report looks ok */\n\treport = hid_validate_values(hid, HID_OUTPUT_REPORT, 0, 0, 7);\n\tif (!report)\n\t\treturn -ENODEV;\n\n\tlg2ff = kmalloc(sizeof(struct lg2ff_device), GFP_KERNEL);\n\tif (!lg2ff)\n\t\treturn -ENOMEM;\n\n\tset_bit(FF_RUMBLE, dev->ffbit);\n\n\terror = input_ff_create_memless(dev, lg2ff, play_effect);\n\tif (error) {\n\t\tkfree(lg2ff);\n\t\treturn error;\n\t}\n\n\tlg2ff->report = report;\n\treport->field[0]->value[0] = 0xf3;\n\treport->field[0]->value[1] = 0x00;\n\treport->field[0]->value[2] = 0x00;\n\treport->field[0]->value[3] = 0x00;\n\treport->field[0]->value[4] = 0x00;\n\treport->field[0]->value[5] = 0x00;\n\treport->field[0]->value[6] = 0x00;\n\n\thid_hw_request(hid, report, HID_REQ_SET_REPORT);\n\n\thid_info(hid, \"Force feedback for Logitech RumblePad/Rumblepad 2 by Anssi Hannula <anssi.hannula@gmail.com>\\n\");\n\n\treturn 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -4,26 +4,13 @@\n \tstruct hid_report *report;\n \tstruct hid_input *hidinput = list_entry(hid->inputs.next,\n \t\t\t\t\t\tstruct hid_input, list);\n-\tstruct list_head *report_list =\n-\t\t\t&hid->report_enum[HID_OUTPUT_REPORT].report_list;\n \tstruct input_dev *dev = hidinput->input;\n \tint error;\n \n-\tif (list_empty(report_list)) {\n-\t\thid_err(hid, \"no output report found\\n\");\n+\t/* Check that the report looks ok */\n+\treport = hid_validate_values(hid, HID_OUTPUT_REPORT, 0, 0, 7);\n+\tif (!report)\n \t\treturn -ENODEV;\n-\t}\n-\n-\treport = list_entry(report_list->next, struct hid_report, list);\n-\n-\tif (report->maxfield < 1) {\n-\t\thid_err(hid, \"output report is empty\\n\");\n-\t\treturn -ENODEV;\n-\t}\n-\tif (report->field[0]->report_count < 7) {\n-\t\thid_err(hid, \"not enough values in the field\\n\");\n-\t\treturn -ENODEV;\n-\t}\n \n \tlg2ff = kmalloc(sizeof(struct lg2ff_device), GFP_KERNEL);\n \tif (!lg2ff)",
        "function_modified_lines": {
            "added": [
                "\t/* Check that the report looks ok */",
                "\treport = hid_validate_values(hid, HID_OUTPUT_REPORT, 0, 0, 7);",
                "\tif (!report)"
            ],
            "deleted": [
                "\tstruct list_head *report_list =",
                "\t\t\t&hid->report_enum[HID_OUTPUT_REPORT].report_list;",
                "\tif (list_empty(report_list)) {",
                "\t\thid_err(hid, \"no output report found\\n\");",
                "\t}",
                "",
                "\treport = list_entry(report_list->next, struct hid_report, list);",
                "",
                "\tif (report->maxfield < 1) {",
                "\t\thid_err(hid, \"output report is empty\\n\");",
                "\t\treturn -ENODEV;",
                "\t}",
                "\tif (report->field[0]->report_count < 7) {",
                "\t\thid_err(hid, \"not enough values in the field\\n\");",
                "\t\treturn -ENODEV;",
                "\t}"
            ]
        },
        "cwe": [
            "CWE-119"
        ],
        "cve_description": "The Human Interface Device (HID) subsystem in the Linux kernel through 3.11, when CONFIG_LOGITECH_FF, CONFIG_LOGIG940_FF, or CONFIG_LOGIWHEELS_FF is enabled, allows physically proximate attackers to cause a denial of service (heap-based out-of-bounds write) via a crafted device, related to (1) drivers/hid/hid-lgff.c, (2) drivers/hid/hid-lg3ff.c, and (3) drivers/hid/hid-lg4ff.c.",
        "id": 249
    },
    {
        "cve_id": "CVE-2017-8068",
        "code_before_change": "static int get_registers(pegasus_t *pegasus, __u16 indx, __u16 size, void *data)\n{\n\tint ret;\n\n\tret = usb_control_msg(pegasus->usb, usb_rcvctrlpipe(pegasus->usb, 0),\n\t\t\t      PEGASUS_REQ_GET_REGS, PEGASUS_REQT_READ, 0,\n\t\t\t      indx, data, size, 1000);\n\tif (ret < 0)\n\t\tnetif_dbg(pegasus, drv, pegasus->net,\n\t\t\t  \"%s returned %d\\n\", __func__, ret);\n\treturn ret;\n}",
        "code_after_change": "static int get_registers(pegasus_t *pegasus, __u16 indx, __u16 size, void *data)\n{\n\tu8 *buf;\n\tint ret;\n\n\tbuf = kmalloc(size, GFP_NOIO);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = usb_control_msg(pegasus->usb, usb_rcvctrlpipe(pegasus->usb, 0),\n\t\t\t      PEGASUS_REQ_GET_REGS, PEGASUS_REQT_READ, 0,\n\t\t\t      indx, buf, size, 1000);\n\tif (ret < 0)\n\t\tnetif_dbg(pegasus, drv, pegasus->net,\n\t\t\t  \"%s returned %d\\n\", __func__, ret);\n\telse if (ret <= size)\n\t\tmemcpy(data, buf, ret);\n\tkfree(buf);\n\treturn ret;\n}",
        "patch": "--- code before\n+++ code after\n@@ -1,12 +1,20 @@\n static int get_registers(pegasus_t *pegasus, __u16 indx, __u16 size, void *data)\n {\n+\tu8 *buf;\n \tint ret;\n+\n+\tbuf = kmalloc(size, GFP_NOIO);\n+\tif (!buf)\n+\t\treturn -ENOMEM;\n \n \tret = usb_control_msg(pegasus->usb, usb_rcvctrlpipe(pegasus->usb, 0),\n \t\t\t      PEGASUS_REQ_GET_REGS, PEGASUS_REQT_READ, 0,\n-\t\t\t      indx, data, size, 1000);\n+\t\t\t      indx, buf, size, 1000);\n \tif (ret < 0)\n \t\tnetif_dbg(pegasus, drv, pegasus->net,\n \t\t\t  \"%s returned %d\\n\", __func__, ret);\n+\telse if (ret <= size)\n+\t\tmemcpy(data, buf, ret);\n+\tkfree(buf);\n \treturn ret;\n }",
        "function_modified_lines": {
            "added": [
                "\tu8 *buf;",
                "",
                "\tbuf = kmalloc(size, GFP_NOIO);",
                "\tif (!buf)",
                "\t\treturn -ENOMEM;",
                "\t\t\t      indx, buf, size, 1000);",
                "\telse if (ret <= size)",
                "\t\tmemcpy(data, buf, ret);",
                "\tkfree(buf);"
            ],
            "deleted": [
                "\t\t\t      indx, data, size, 1000);"
            ]
        },
        "cwe": [
            "CWE-119"
        ],
        "cve_description": "drivers/net/usb/pegasus.c in the Linux kernel 4.9.x before 4.9.11 interacts incorrectly with the CONFIG_VMAP_STACK option, which allows local users to cause a denial of service (system crash or memory corruption) or possibly have unspecified other impact by leveraging use of more than one virtual page for a DMA scatterlist.",
        "id": 1543
    },
    {
        "cve_id": "CVE-2013-1772",
        "code_before_change": "void __init setup_log_buf(int early)\n{\n\tunsigned long flags;\n\tunsigned start, dest_idx, offset;\n\tchar *new_log_buf;\n\tint free;\n\n\tif (!new_log_buf_len)\n\t\treturn;\n\n\tif (early) {\n\t\tunsigned long mem;\n\n\t\tmem = memblock_alloc(new_log_buf_len, PAGE_SIZE);\n\t\tif (!mem)\n\t\t\treturn;\n\t\tnew_log_buf = __va(mem);\n\t} else {\n\t\tnew_log_buf = alloc_bootmem_nopanic(new_log_buf_len);\n\t}\n\n\tif (unlikely(!new_log_buf)) {\n\t\tpr_err(\"log_buf_len: %ld bytes not available\\n\",\n\t\t\tnew_log_buf_len);\n\t\treturn;\n\t}\n\n\traw_spin_lock_irqsave(&logbuf_lock, flags);\n\tlog_buf_len = new_log_buf_len;\n\tlog_buf = new_log_buf;\n\tnew_log_buf_len = 0;\n\tfree = __LOG_BUF_LEN - log_end;\n\n\toffset = start = min(con_start, log_start);\n\tdest_idx = 0;\n\twhile (start != log_end) {\n\t\tunsigned log_idx_mask = start & (__LOG_BUF_LEN - 1);\n\n\t\tlog_buf[dest_idx] = __log_buf[log_idx_mask];\n\t\tstart++;\n\t\tdest_idx++;\n\t}\n\tlog_start -= offset;\n\tcon_start -= offset;\n\tlog_end -= offset;\n\traw_spin_unlock_irqrestore(&logbuf_lock, flags);\n\n\tpr_info(\"log_buf_len: %d\\n\", log_buf_len);\n\tpr_info(\"early log buf free: %d(%d%%)\\n\",\n\t\tfree, (free * 100) / __LOG_BUF_LEN);\n}",
        "code_after_change": "void __init setup_log_buf(int early)\n{\n\tunsigned long flags;\n\tchar *new_log_buf;\n\tint free;\n\n\tif (!new_log_buf_len)\n\t\treturn;\n\n\tif (early) {\n\t\tunsigned long mem;\n\n\t\tmem = memblock_alloc(new_log_buf_len, PAGE_SIZE);\n\t\tif (!mem)\n\t\t\treturn;\n\t\tnew_log_buf = __va(mem);\n\t} else {\n\t\tnew_log_buf = alloc_bootmem_nopanic(new_log_buf_len);\n\t}\n\n\tif (unlikely(!new_log_buf)) {\n\t\tpr_err(\"log_buf_len: %ld bytes not available\\n\",\n\t\t\tnew_log_buf_len);\n\t\treturn;\n\t}\n\n\traw_spin_lock_irqsave(&logbuf_lock, flags);\n\tlog_buf_len = new_log_buf_len;\n\tlog_buf = new_log_buf;\n\tnew_log_buf_len = 0;\n\tfree = __LOG_BUF_LEN - log_next_idx;\n\tmemcpy(log_buf, __log_buf, __LOG_BUF_LEN);\n\traw_spin_unlock_irqrestore(&logbuf_lock, flags);\n\n\tpr_info(\"log_buf_len: %d\\n\", log_buf_len);\n\tpr_info(\"early log buf free: %d(%d%%)\\n\",\n\t\tfree, (free * 100) / __LOG_BUF_LEN);\n}",
        "patch": "--- code before\n+++ code after\n@@ -1,7 +1,6 @@\n void __init setup_log_buf(int early)\n {\n \tunsigned long flags;\n-\tunsigned start, dest_idx, offset;\n \tchar *new_log_buf;\n \tint free;\n \n@@ -29,20 +28,8 @@\n \tlog_buf_len = new_log_buf_len;\n \tlog_buf = new_log_buf;\n \tnew_log_buf_len = 0;\n-\tfree = __LOG_BUF_LEN - log_end;\n-\n-\toffset = start = min(con_start, log_start);\n-\tdest_idx = 0;\n-\twhile (start != log_end) {\n-\t\tunsigned log_idx_mask = start & (__LOG_BUF_LEN - 1);\n-\n-\t\tlog_buf[dest_idx] = __log_buf[log_idx_mask];\n-\t\tstart++;\n-\t\tdest_idx++;\n-\t}\n-\tlog_start -= offset;\n-\tcon_start -= offset;\n-\tlog_end -= offset;\n+\tfree = __LOG_BUF_LEN - log_next_idx;\n+\tmemcpy(log_buf, __log_buf, __LOG_BUF_LEN);\n \traw_spin_unlock_irqrestore(&logbuf_lock, flags);\n \n \tpr_info(\"log_buf_len: %d\\n\", log_buf_len);",
        "function_modified_lines": {
            "added": [
                "\tfree = __LOG_BUF_LEN - log_next_idx;",
                "\tmemcpy(log_buf, __log_buf, __LOG_BUF_LEN);"
            ],
            "deleted": [
                "\tunsigned start, dest_idx, offset;",
                "\tfree = __LOG_BUF_LEN - log_end;",
                "",
                "\toffset = start = min(con_start, log_start);",
                "\tdest_idx = 0;",
                "\twhile (start != log_end) {",
                "\t\tunsigned log_idx_mask = start & (__LOG_BUF_LEN - 1);",
                "",
                "\t\tlog_buf[dest_idx] = __log_buf[log_idx_mask];",
                "\t\tstart++;",
                "\t\tdest_idx++;",
                "\t}",
                "\tlog_start -= offset;",
                "\tcon_start -= offset;",
                "\tlog_end -= offset;"
            ]
        },
        "cwe": [
            "CWE-119"
        ],
        "cve_description": "The log_prefix function in kernel/printk.c in the Linux kernel 3.x before 3.4.33 does not properly remove a prefix string from a syslog header, which allows local users to cause a denial of service (buffer overflow and system crash) by leveraging /dev/kmsg write access and triggering a call_console_drivers function call.",
        "id": 172
    },
    {
        "cve_id": "CVE-2013-1772",
        "code_before_change": "void console_unlock(void)\n{\n\tunsigned long flags;\n\tunsigned _con_start, _log_end;\n\tunsigned wake_klogd = 0, retry = 0;\n\n\tif (console_suspended) {\n\t\tup(&console_sem);\n\t\treturn;\n\t}\n\n\tconsole_may_schedule = 0;\n\nagain:\n\tfor ( ; ; ) {\n\t\traw_spin_lock_irqsave(&logbuf_lock, flags);\n\t\twake_klogd |= log_start - log_end;\n\t\tif (con_start == log_end)\n\t\t\tbreak;\t\t\t/* Nothing to print */\n\t\t_con_start = con_start;\n\t\t_log_end = log_end;\n\t\tcon_start = log_end;\t\t/* Flush */\n\t\traw_spin_unlock(&logbuf_lock);\n\t\tstop_critical_timings();\t/* don't trace print latency */\n\t\tcall_console_drivers(_con_start, _log_end);\n\t\tstart_critical_timings();\n\t\tlocal_irq_restore(flags);\n\t}\n\tconsole_locked = 0;\n\n\t/* Release the exclusive_console once it is used */\n\tif (unlikely(exclusive_console))\n\t\texclusive_console = NULL;\n\n\traw_spin_unlock(&logbuf_lock);\n\n\tup(&console_sem);\n\n\t/*\n\t * Someone could have filled up the buffer again, so re-check if there's\n\t * something to flush. In case we cannot trylock the console_sem again,\n\t * there's a new owner and the console_unlock() from them will do the\n\t * flush, no worries.\n\t */\n\traw_spin_lock(&logbuf_lock);\n\tif (con_start != log_end)\n\t\tretry = 1;\n\traw_spin_unlock_irqrestore(&logbuf_lock, flags);\n\n\tif (retry && console_trylock())\n\t\tgoto again;\n\n\tif (wake_klogd)\n\t\twake_up_klogd();\n}",
        "code_after_change": "void console_unlock(void)\n{\n\tstatic u64 seen_seq;\n\tunsigned long flags;\n\tbool wake_klogd = false;\n\tbool retry;\n\n\tif (console_suspended) {\n\t\tup(&console_sem);\n\t\treturn;\n\t}\n\n\tconsole_may_schedule = 0;\n\nagain:\n\tfor (;;) {\n\t\tstruct log *msg;\n\t\tstatic char text[LOG_LINE_MAX];\n\t\tsize_t len;\n\t\tint level;\n\n\t\traw_spin_lock_irqsave(&logbuf_lock, flags);\n\t\tif (seen_seq != log_next_seq) {\n\t\t\twake_klogd = true;\n\t\t\tseen_seq = log_next_seq;\n\t\t}\n\n\t\tif (console_seq < log_first_seq) {\n\t\t\t/* messages are gone, move to first one */\n\t\t\tconsole_seq = log_first_seq;\n\t\t\tconsole_idx = log_first_idx;\n\t\t}\n\n\t\tif (console_seq == log_next_seq)\n\t\t\tbreak;\n\n\t\tmsg = log_from_idx(console_idx);\n\t\tlevel = msg->level & 7;\n\t\tlen = msg->text_len;\n\t\tif (len+1 >= sizeof(text))\n\t\t\tlen = sizeof(text)-1;\n\t\tmemcpy(text, log_text(msg), len);\n\t\ttext[len++] = '\\n';\n\n\t\tconsole_idx = log_next(console_idx);\n\t\tconsole_seq++;\n\t\traw_spin_unlock(&logbuf_lock);\n\n\t\tstop_critical_timings();\t/* don't trace print latency */\n\t\tcall_console_drivers(level, text, len);\n\t\tstart_critical_timings();\n\t\tlocal_irq_restore(flags);\n\t}\n\tconsole_locked = 0;\n\n\t/* Release the exclusive_console once it is used */\n\tif (unlikely(exclusive_console))\n\t\texclusive_console = NULL;\n\n\traw_spin_unlock(&logbuf_lock);\n\n\tup(&console_sem);\n\n\t/*\n\t * Someone could have filled up the buffer again, so re-check if there's\n\t * something to flush. In case we cannot trylock the console_sem again,\n\t * there's a new owner and the console_unlock() from them will do the\n\t * flush, no worries.\n\t */\n\traw_spin_lock(&logbuf_lock);\n\tretry = console_seq != log_next_seq;\n\traw_spin_unlock_irqrestore(&logbuf_lock, flags);\n\n\tif (retry && console_trylock())\n\t\tgoto again;\n\n\tif (wake_klogd)\n\t\twake_up_klogd();\n}",
        "patch": "--- code before\n+++ code after\n@@ -1,8 +1,9 @@\n void console_unlock(void)\n {\n+\tstatic u64 seen_seq;\n \tunsigned long flags;\n-\tunsigned _con_start, _log_end;\n-\tunsigned wake_klogd = 0, retry = 0;\n+\tbool wake_klogd = false;\n+\tbool retry;\n \n \tif (console_suspended) {\n \t\tup(&console_sem);\n@@ -12,17 +13,41 @@\n \tconsole_may_schedule = 0;\n \n again:\n-\tfor ( ; ; ) {\n+\tfor (;;) {\n+\t\tstruct log *msg;\n+\t\tstatic char text[LOG_LINE_MAX];\n+\t\tsize_t len;\n+\t\tint level;\n+\n \t\traw_spin_lock_irqsave(&logbuf_lock, flags);\n-\t\twake_klogd |= log_start - log_end;\n-\t\tif (con_start == log_end)\n-\t\t\tbreak;\t\t\t/* Nothing to print */\n-\t\t_con_start = con_start;\n-\t\t_log_end = log_end;\n-\t\tcon_start = log_end;\t\t/* Flush */\n+\t\tif (seen_seq != log_next_seq) {\n+\t\t\twake_klogd = true;\n+\t\t\tseen_seq = log_next_seq;\n+\t\t}\n+\n+\t\tif (console_seq < log_first_seq) {\n+\t\t\t/* messages are gone, move to first one */\n+\t\t\tconsole_seq = log_first_seq;\n+\t\t\tconsole_idx = log_first_idx;\n+\t\t}\n+\n+\t\tif (console_seq == log_next_seq)\n+\t\t\tbreak;\n+\n+\t\tmsg = log_from_idx(console_idx);\n+\t\tlevel = msg->level & 7;\n+\t\tlen = msg->text_len;\n+\t\tif (len+1 >= sizeof(text))\n+\t\t\tlen = sizeof(text)-1;\n+\t\tmemcpy(text, log_text(msg), len);\n+\t\ttext[len++] = '\\n';\n+\n+\t\tconsole_idx = log_next(console_idx);\n+\t\tconsole_seq++;\n \t\traw_spin_unlock(&logbuf_lock);\n+\n \t\tstop_critical_timings();\t/* don't trace print latency */\n-\t\tcall_console_drivers(_con_start, _log_end);\n+\t\tcall_console_drivers(level, text, len);\n \t\tstart_critical_timings();\n \t\tlocal_irq_restore(flags);\n \t}\n@@ -43,8 +68,7 @@\n \t * flush, no worries.\n \t */\n \traw_spin_lock(&logbuf_lock);\n-\tif (con_start != log_end)\n-\t\tretry = 1;\n+\tretry = console_seq != log_next_seq;\n \traw_spin_unlock_irqrestore(&logbuf_lock, flags);\n \n \tif (retry && console_trylock())",
        "function_modified_lines": {
            "added": [
                "\tstatic u64 seen_seq;",
                "\tbool wake_klogd = false;",
                "\tbool retry;",
                "\tfor (;;) {",
                "\t\tstruct log *msg;",
                "\t\tstatic char text[LOG_LINE_MAX];",
                "\t\tsize_t len;",
                "\t\tint level;",
                "",
                "\t\tif (seen_seq != log_next_seq) {",
                "\t\t\twake_klogd = true;",
                "\t\t\tseen_seq = log_next_seq;",
                "\t\t}",
                "",
                "\t\tif (console_seq < log_first_seq) {",
                "\t\t\t/* messages are gone, move to first one */",
                "\t\t\tconsole_seq = log_first_seq;",
                "\t\t\tconsole_idx = log_first_idx;",
                "\t\t}",
                "",
                "\t\tif (console_seq == log_next_seq)",
                "\t\t\tbreak;",
                "",
                "\t\tmsg = log_from_idx(console_idx);",
                "\t\tlevel = msg->level & 7;",
                "\t\tlen = msg->text_len;",
                "\t\tif (len+1 >= sizeof(text))",
                "\t\t\tlen = sizeof(text)-1;",
                "\t\tmemcpy(text, log_text(msg), len);",
                "\t\ttext[len++] = '\\n';",
                "",
                "\t\tconsole_idx = log_next(console_idx);",
                "\t\tconsole_seq++;",
                "",
                "\t\tcall_console_drivers(level, text, len);",
                "\tretry = console_seq != log_next_seq;"
            ],
            "deleted": [
                "\tunsigned _con_start, _log_end;",
                "\tunsigned wake_klogd = 0, retry = 0;",
                "\tfor ( ; ; ) {",
                "\t\twake_klogd |= log_start - log_end;",
                "\t\tif (con_start == log_end)",
                "\t\t\tbreak;\t\t\t/* Nothing to print */",
                "\t\t_con_start = con_start;",
                "\t\t_log_end = log_end;",
                "\t\tcon_start = log_end;\t\t/* Flush */",
                "\t\tcall_console_drivers(_con_start, _log_end);",
                "\tif (con_start != log_end)",
                "\t\tretry = 1;"
            ]
        },
        "cwe": [
            "CWE-119"
        ],
        "cve_description": "The log_prefix function in kernel/printk.c in the Linux kernel 3.x before 3.4.33 does not properly remove a prefix string from a syslog header, which allows local users to cause a denial of service (buffer overflow and system crash) by leveraging /dev/kmsg write access and triggering a call_console_drivers function call.",
        "id": 171
    },
    {
        "cve_id": "CVE-2021-4204",
        "code_before_change": "static int check_func_arg(struct bpf_verifier_env *env, u32 arg,\n\t\t\t  struct bpf_call_arg_meta *meta,\n\t\t\t  const struct bpf_func_proto *fn)\n{\n\tu32 regno = BPF_REG_1 + arg;\n\tstruct bpf_reg_state *regs = cur_regs(env), *reg = &regs[regno];\n\tenum bpf_arg_type arg_type = fn->arg_type[arg];\n\tenum bpf_reg_type type = reg->type;\n\tint err = 0;\n\n\tif (arg_type == ARG_DONTCARE)\n\t\treturn 0;\n\n\terr = check_reg_arg(env, regno, SRC_OP);\n\tif (err)\n\t\treturn err;\n\n\tif (arg_type == ARG_ANYTHING) {\n\t\tif (is_pointer_value(env, regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into helper function\\n\",\n\t\t\t\tregno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (type_is_pkt_pointer(type) &&\n\t    !may_access_direct_pkt_data(env, meta, BPF_READ)) {\n\t\tverbose(env, \"helper access to the packet is not allowed\\n\");\n\t\treturn -EACCES;\n\t}\n\n\tif (base_type(arg_type) == ARG_PTR_TO_MAP_VALUE ||\n\t    base_type(arg_type) == ARG_PTR_TO_UNINIT_MAP_VALUE) {\n\t\terr = resolve_map_arg_type(env, meta, &arg_type);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (register_is_null(reg) && type_may_be_null(arg_type))\n\t\t/* A NULL register has a SCALAR_VALUE type, so skip\n\t\t * type checking.\n\t\t */\n\t\tgoto skip_type_check;\n\n\terr = check_reg_type(env, regno, arg_type, fn->arg_btf_id[arg]);\n\tif (err)\n\t\treturn err;\n\n\tif (type == PTR_TO_CTX) {\n\t\terr = check_ctx_reg(env, reg, regno);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\nskip_type_check:\n\tif (reg->ref_obj_id) {\n\t\tif (meta->ref_obj_id) {\n\t\t\tverbose(env, \"verifier internal error: more than one arg with ref_obj_id R%d %u %u\\n\",\n\t\t\t\tregno, reg->ref_obj_id,\n\t\t\t\tmeta->ref_obj_id);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tmeta->ref_obj_id = reg->ref_obj_id;\n\t}\n\n\tif (arg_type == ARG_CONST_MAP_PTR) {\n\t\t/* bpf_map_xxx(map_ptr) call: remember that map_ptr */\n\t\tif (meta->map_ptr) {\n\t\t\t/* Use map_uid (which is unique id of inner map) to reject:\n\t\t\t * inner_map1 = bpf_map_lookup_elem(outer_map, key1)\n\t\t\t * inner_map2 = bpf_map_lookup_elem(outer_map, key2)\n\t\t\t * if (inner_map1 && inner_map2) {\n\t\t\t *     timer = bpf_map_lookup_elem(inner_map1);\n\t\t\t *     if (timer)\n\t\t\t *         // mismatch would have been allowed\n\t\t\t *         bpf_timer_init(timer, inner_map2);\n\t\t\t * }\n\t\t\t *\n\t\t\t * Comparing map_ptr is enough to distinguish normal and outer maps.\n\t\t\t */\n\t\t\tif (meta->map_ptr != reg->map_ptr ||\n\t\t\t    meta->map_uid != reg->map_uid) {\n\t\t\t\tverbose(env,\n\t\t\t\t\t\"timer pointer in R1 map_uid=%d doesn't match map pointer in R2 map_uid=%d\\n\",\n\t\t\t\t\tmeta->map_uid, reg->map_uid);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\tmeta->map_ptr = reg->map_ptr;\n\t\tmeta->map_uid = reg->map_uid;\n\t} else if (arg_type == ARG_PTR_TO_MAP_KEY) {\n\t\t/* bpf_map_xxx(..., map_ptr, ..., key) call:\n\t\t * check that [key, key + map->key_size) are within\n\t\t * stack limits and initialized\n\t\t */\n\t\tif (!meta->map_ptr) {\n\t\t\t/* in function declaration map_ptr must come before\n\t\t\t * map_key, so that it's verified and known before\n\t\t\t * we have to check map_key here. Otherwise it means\n\t\t\t * that kernel subsystem misconfigured verifier\n\t\t\t */\n\t\t\tverbose(env, \"invalid map_ptr to access map->key\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_helper_mem_access(env, regno,\n\t\t\t\t\t      meta->map_ptr->key_size, false,\n\t\t\t\t\t      NULL);\n\t} else if (base_type(arg_type) == ARG_PTR_TO_MAP_VALUE ||\n\t\t   base_type(arg_type) == ARG_PTR_TO_UNINIT_MAP_VALUE) {\n\t\tif (type_may_be_null(arg_type) && register_is_null(reg))\n\t\t\treturn 0;\n\n\t\t/* bpf_map_xxx(..., map_ptr, ..., value) call:\n\t\t * check [value, value + map->value_size) validity\n\t\t */\n\t\tif (!meta->map_ptr) {\n\t\t\t/* kernel subsystem misconfigured verifier */\n\t\t\tverbose(env, \"invalid map_ptr to access map->value\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\tmeta->raw_mode = (arg_type == ARG_PTR_TO_UNINIT_MAP_VALUE);\n\t\terr = check_helper_mem_access(env, regno,\n\t\t\t\t\t      meta->map_ptr->value_size, false,\n\t\t\t\t\t      meta);\n\t} else if (arg_type == ARG_PTR_TO_PERCPU_BTF_ID) {\n\t\tif (!reg->btf_id) {\n\t\t\tverbose(env, \"Helper has invalid btf_id in R%d\\n\", regno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\tmeta->ret_btf = reg->btf;\n\t\tmeta->ret_btf_id = reg->btf_id;\n\t} else if (arg_type == ARG_PTR_TO_SPIN_LOCK) {\n\t\tif (meta->func_id == BPF_FUNC_spin_lock) {\n\t\t\tif (process_spin_lock(env, regno, true))\n\t\t\t\treturn -EACCES;\n\t\t} else if (meta->func_id == BPF_FUNC_spin_unlock) {\n\t\t\tif (process_spin_lock(env, regno, false))\n\t\t\t\treturn -EACCES;\n\t\t} else {\n\t\t\tverbose(env, \"verifier internal error\\n\");\n\t\t\treturn -EFAULT;\n\t\t}\n\t} else if (arg_type == ARG_PTR_TO_TIMER) {\n\t\tif (process_timer_func(env, regno, meta))\n\t\t\treturn -EACCES;\n\t} else if (arg_type == ARG_PTR_TO_FUNC) {\n\t\tmeta->subprogno = reg->subprogno;\n\t} else if (arg_type_is_mem_ptr(arg_type)) {\n\t\t/* The access to this pointer is only checked when we hit the\n\t\t * next is_mem_size argument below.\n\t\t */\n\t\tmeta->raw_mode = (arg_type == ARG_PTR_TO_UNINIT_MEM);\n\t} else if (arg_type_is_mem_size(arg_type)) {\n\t\tbool zero_size_allowed = (arg_type == ARG_CONST_SIZE_OR_ZERO);\n\n\t\t/* This is used to refine r0 return value bounds for helpers\n\t\t * that enforce this value as an upper bound on return values.\n\t\t * See do_refine_retval_range() for helpers that can refine\n\t\t * the return value. C type of helper is u32 so we pull register\n\t\t * bound from umax_value however, if negative verifier errors\n\t\t * out. Only upper bounds can be learned because retval is an\n\t\t * int type and negative retvals are allowed.\n\t\t */\n\t\tmeta->msize_max_value = reg->umax_value;\n\n\t\t/* The register is SCALAR_VALUE; the access check\n\t\t * happens using its boundaries.\n\t\t */\n\t\tif (!tnum_is_const(reg->var_off))\n\t\t\t/* For unprivileged variable accesses, disable raw\n\t\t\t * mode so that the program is required to\n\t\t\t * initialize all the memory that the helper could\n\t\t\t * just partially fill up.\n\t\t\t */\n\t\t\tmeta = NULL;\n\n\t\tif (reg->smin_value < 0) {\n\t\t\tverbose(env, \"R%d min value is negative, either use unsigned or 'var &= const'\\n\",\n\t\t\t\tregno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (reg->umin_value == 0) {\n\t\t\terr = check_helper_mem_access(env, regno - 1, 0,\n\t\t\t\t\t\t      zero_size_allowed,\n\t\t\t\t\t\t      meta);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tif (reg->umax_value >= BPF_MAX_VAR_SIZ) {\n\t\t\tverbose(env, \"R%d unbounded memory access, use 'var &= const' or 'if (var < const)'\\n\",\n\t\t\t\tregno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_helper_mem_access(env, regno - 1,\n\t\t\t\t\t      reg->umax_value,\n\t\t\t\t\t      zero_size_allowed, meta);\n\t\tif (!err)\n\t\t\terr = mark_chain_precision(env, regno);\n\t} else if (arg_type_is_alloc_size(arg_type)) {\n\t\tif (!tnum_is_const(reg->var_off)) {\n\t\t\tverbose(env, \"R%d is not a known constant'\\n\",\n\t\t\t\tregno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\tmeta->mem_size = reg->var_off.value;\n\t} else if (arg_type_is_int_ptr(arg_type)) {\n\t\tint size = int_ptr_type_to_size(arg_type);\n\n\t\terr = check_helper_mem_access(env, regno, size, false, meta);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = check_ptr_alignment(env, reg, 0, size, true);\n\t} else if (arg_type == ARG_PTR_TO_CONST_STR) {\n\t\tstruct bpf_map *map = reg->map_ptr;\n\t\tint map_off;\n\t\tu64 map_addr;\n\t\tchar *str_ptr;\n\n\t\tif (!bpf_map_is_rdonly(map)) {\n\t\t\tverbose(env, \"R%d does not point to a readonly map'\\n\", regno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (!tnum_is_const(reg->var_off)) {\n\t\t\tverbose(env, \"R%d is not a constant address'\\n\", regno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (!map->ops->map_direct_value_addr) {\n\t\t\tverbose(env, \"no direct value access support for this map type\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\terr = check_map_access(env, regno, reg->off,\n\t\t\t\t       map->value_size - reg->off, false);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tmap_off = reg->off + reg->var_off.value;\n\t\terr = map->ops->map_direct_value_addr(map, &map_addr, map_off);\n\t\tif (err) {\n\t\t\tverbose(env, \"direct value access on string failed\\n\");\n\t\t\treturn err;\n\t\t}\n\n\t\tstr_ptr = (char *)(long)(map_addr);\n\t\tif (!strnchr(str_ptr + map_off, map->value_size - map_off, 0)) {\n\t\t\tverbose(env, \"string is not zero-terminated\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn err;\n}",
        "code_after_change": "static int check_func_arg(struct bpf_verifier_env *env, u32 arg,\n\t\t\t  struct bpf_call_arg_meta *meta,\n\t\t\t  const struct bpf_func_proto *fn)\n{\n\tu32 regno = BPF_REG_1 + arg;\n\tstruct bpf_reg_state *regs = cur_regs(env), *reg = &regs[regno];\n\tenum bpf_arg_type arg_type = fn->arg_type[arg];\n\tenum bpf_reg_type type = reg->type;\n\tint err = 0;\n\n\tif (arg_type == ARG_DONTCARE)\n\t\treturn 0;\n\n\terr = check_reg_arg(env, regno, SRC_OP);\n\tif (err)\n\t\treturn err;\n\n\tif (arg_type == ARG_ANYTHING) {\n\t\tif (is_pointer_value(env, regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into helper function\\n\",\n\t\t\t\tregno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (type_is_pkt_pointer(type) &&\n\t    !may_access_direct_pkt_data(env, meta, BPF_READ)) {\n\t\tverbose(env, \"helper access to the packet is not allowed\\n\");\n\t\treturn -EACCES;\n\t}\n\n\tif (base_type(arg_type) == ARG_PTR_TO_MAP_VALUE ||\n\t    base_type(arg_type) == ARG_PTR_TO_UNINIT_MAP_VALUE) {\n\t\terr = resolve_map_arg_type(env, meta, &arg_type);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (register_is_null(reg) && type_may_be_null(arg_type))\n\t\t/* A NULL register has a SCALAR_VALUE type, so skip\n\t\t * type checking.\n\t\t */\n\t\tgoto skip_type_check;\n\n\terr = check_reg_type(env, regno, arg_type, fn->arg_btf_id[arg]);\n\tif (err)\n\t\treturn err;\n\n\tif (type == PTR_TO_CTX) {\n\t\terr = check_ptr_off_reg(env, reg, regno);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\nskip_type_check:\n\tif (reg->ref_obj_id) {\n\t\tif (meta->ref_obj_id) {\n\t\t\tverbose(env, \"verifier internal error: more than one arg with ref_obj_id R%d %u %u\\n\",\n\t\t\t\tregno, reg->ref_obj_id,\n\t\t\t\tmeta->ref_obj_id);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tmeta->ref_obj_id = reg->ref_obj_id;\n\t}\n\n\tif (arg_type == ARG_CONST_MAP_PTR) {\n\t\t/* bpf_map_xxx(map_ptr) call: remember that map_ptr */\n\t\tif (meta->map_ptr) {\n\t\t\t/* Use map_uid (which is unique id of inner map) to reject:\n\t\t\t * inner_map1 = bpf_map_lookup_elem(outer_map, key1)\n\t\t\t * inner_map2 = bpf_map_lookup_elem(outer_map, key2)\n\t\t\t * if (inner_map1 && inner_map2) {\n\t\t\t *     timer = bpf_map_lookup_elem(inner_map1);\n\t\t\t *     if (timer)\n\t\t\t *         // mismatch would have been allowed\n\t\t\t *         bpf_timer_init(timer, inner_map2);\n\t\t\t * }\n\t\t\t *\n\t\t\t * Comparing map_ptr is enough to distinguish normal and outer maps.\n\t\t\t */\n\t\t\tif (meta->map_ptr != reg->map_ptr ||\n\t\t\t    meta->map_uid != reg->map_uid) {\n\t\t\t\tverbose(env,\n\t\t\t\t\t\"timer pointer in R1 map_uid=%d doesn't match map pointer in R2 map_uid=%d\\n\",\n\t\t\t\t\tmeta->map_uid, reg->map_uid);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\tmeta->map_ptr = reg->map_ptr;\n\t\tmeta->map_uid = reg->map_uid;\n\t} else if (arg_type == ARG_PTR_TO_MAP_KEY) {\n\t\t/* bpf_map_xxx(..., map_ptr, ..., key) call:\n\t\t * check that [key, key + map->key_size) are within\n\t\t * stack limits and initialized\n\t\t */\n\t\tif (!meta->map_ptr) {\n\t\t\t/* in function declaration map_ptr must come before\n\t\t\t * map_key, so that it's verified and known before\n\t\t\t * we have to check map_key here. Otherwise it means\n\t\t\t * that kernel subsystem misconfigured verifier\n\t\t\t */\n\t\t\tverbose(env, \"invalid map_ptr to access map->key\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_helper_mem_access(env, regno,\n\t\t\t\t\t      meta->map_ptr->key_size, false,\n\t\t\t\t\t      NULL);\n\t} else if (base_type(arg_type) == ARG_PTR_TO_MAP_VALUE ||\n\t\t   base_type(arg_type) == ARG_PTR_TO_UNINIT_MAP_VALUE) {\n\t\tif (type_may_be_null(arg_type) && register_is_null(reg))\n\t\t\treturn 0;\n\n\t\t/* bpf_map_xxx(..., map_ptr, ..., value) call:\n\t\t * check [value, value + map->value_size) validity\n\t\t */\n\t\tif (!meta->map_ptr) {\n\t\t\t/* kernel subsystem misconfigured verifier */\n\t\t\tverbose(env, \"invalid map_ptr to access map->value\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\tmeta->raw_mode = (arg_type == ARG_PTR_TO_UNINIT_MAP_VALUE);\n\t\terr = check_helper_mem_access(env, regno,\n\t\t\t\t\t      meta->map_ptr->value_size, false,\n\t\t\t\t\t      meta);\n\t} else if (arg_type == ARG_PTR_TO_PERCPU_BTF_ID) {\n\t\tif (!reg->btf_id) {\n\t\t\tverbose(env, \"Helper has invalid btf_id in R%d\\n\", regno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\tmeta->ret_btf = reg->btf;\n\t\tmeta->ret_btf_id = reg->btf_id;\n\t} else if (arg_type == ARG_PTR_TO_SPIN_LOCK) {\n\t\tif (meta->func_id == BPF_FUNC_spin_lock) {\n\t\t\tif (process_spin_lock(env, regno, true))\n\t\t\t\treturn -EACCES;\n\t\t} else if (meta->func_id == BPF_FUNC_spin_unlock) {\n\t\t\tif (process_spin_lock(env, regno, false))\n\t\t\t\treturn -EACCES;\n\t\t} else {\n\t\t\tverbose(env, \"verifier internal error\\n\");\n\t\t\treturn -EFAULT;\n\t\t}\n\t} else if (arg_type == ARG_PTR_TO_TIMER) {\n\t\tif (process_timer_func(env, regno, meta))\n\t\t\treturn -EACCES;\n\t} else if (arg_type == ARG_PTR_TO_FUNC) {\n\t\tmeta->subprogno = reg->subprogno;\n\t} else if (arg_type_is_mem_ptr(arg_type)) {\n\t\t/* The access to this pointer is only checked when we hit the\n\t\t * next is_mem_size argument below.\n\t\t */\n\t\tmeta->raw_mode = (arg_type == ARG_PTR_TO_UNINIT_MEM);\n\t} else if (arg_type_is_mem_size(arg_type)) {\n\t\tbool zero_size_allowed = (arg_type == ARG_CONST_SIZE_OR_ZERO);\n\n\t\t/* This is used to refine r0 return value bounds for helpers\n\t\t * that enforce this value as an upper bound on return values.\n\t\t * See do_refine_retval_range() for helpers that can refine\n\t\t * the return value. C type of helper is u32 so we pull register\n\t\t * bound from umax_value however, if negative verifier errors\n\t\t * out. Only upper bounds can be learned because retval is an\n\t\t * int type and negative retvals are allowed.\n\t\t */\n\t\tmeta->msize_max_value = reg->umax_value;\n\n\t\t/* The register is SCALAR_VALUE; the access check\n\t\t * happens using its boundaries.\n\t\t */\n\t\tif (!tnum_is_const(reg->var_off))\n\t\t\t/* For unprivileged variable accesses, disable raw\n\t\t\t * mode so that the program is required to\n\t\t\t * initialize all the memory that the helper could\n\t\t\t * just partially fill up.\n\t\t\t */\n\t\t\tmeta = NULL;\n\n\t\tif (reg->smin_value < 0) {\n\t\t\tverbose(env, \"R%d min value is negative, either use unsigned or 'var &= const'\\n\",\n\t\t\t\tregno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (reg->umin_value == 0) {\n\t\t\terr = check_helper_mem_access(env, regno - 1, 0,\n\t\t\t\t\t\t      zero_size_allowed,\n\t\t\t\t\t\t      meta);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tif (reg->umax_value >= BPF_MAX_VAR_SIZ) {\n\t\t\tverbose(env, \"R%d unbounded memory access, use 'var &= const' or 'if (var < const)'\\n\",\n\t\t\t\tregno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_helper_mem_access(env, regno - 1,\n\t\t\t\t\t      reg->umax_value,\n\t\t\t\t\t      zero_size_allowed, meta);\n\t\tif (!err)\n\t\t\terr = mark_chain_precision(env, regno);\n\t} else if (arg_type_is_alloc_size(arg_type)) {\n\t\tif (!tnum_is_const(reg->var_off)) {\n\t\t\tverbose(env, \"R%d is not a known constant'\\n\",\n\t\t\t\tregno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\tmeta->mem_size = reg->var_off.value;\n\t} else if (arg_type_is_int_ptr(arg_type)) {\n\t\tint size = int_ptr_type_to_size(arg_type);\n\n\t\terr = check_helper_mem_access(env, regno, size, false, meta);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = check_ptr_alignment(env, reg, 0, size, true);\n\t} else if (arg_type == ARG_PTR_TO_CONST_STR) {\n\t\tstruct bpf_map *map = reg->map_ptr;\n\t\tint map_off;\n\t\tu64 map_addr;\n\t\tchar *str_ptr;\n\n\t\tif (!bpf_map_is_rdonly(map)) {\n\t\t\tverbose(env, \"R%d does not point to a readonly map'\\n\", regno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (!tnum_is_const(reg->var_off)) {\n\t\t\tverbose(env, \"R%d is not a constant address'\\n\", regno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (!map->ops->map_direct_value_addr) {\n\t\t\tverbose(env, \"no direct value access support for this map type\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\terr = check_map_access(env, regno, reg->off,\n\t\t\t\t       map->value_size - reg->off, false);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tmap_off = reg->off + reg->var_off.value;\n\t\terr = map->ops->map_direct_value_addr(map, &map_addr, map_off);\n\t\tif (err) {\n\t\t\tverbose(env, \"direct value access on string failed\\n\");\n\t\t\treturn err;\n\t\t}\n\n\t\tstr_ptr = (char *)(long)(map_addr);\n\t\tif (!strnchr(str_ptr + map_off, map->value_size - map_off, 0)) {\n\t\t\tverbose(env, \"string is not zero-terminated\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn err;\n}",
        "patch": "--- code before\n+++ code after\n@@ -48,7 +48,7 @@\n \t\treturn err;\n \n \tif (type == PTR_TO_CTX) {\n-\t\terr = check_ctx_reg(env, reg, regno);\n+\t\terr = check_ptr_off_reg(env, reg, regno);\n \t\tif (err < 0)\n \t\t\treturn err;\n \t}",
        "function_modified_lines": {
            "added": [
                "\t\terr = check_ptr_off_reg(env, reg, regno);"
            ],
            "deleted": [
                "\t\terr = check_ctx_reg(env, reg, regno);"
            ]
        },
        "cwe": [
            "CWE-119"
        ],
        "cve_description": "An out-of-bounds (OOB) memory access flaw was found in the Linux kernel's eBPF due to an Improper Input Validation. This flaw allows a local attacker with a special privilege to crash the system or leak internal information.",
        "id": 3152
    },
    {
        "cve_id": "CVE-2011-4098",
        "code_before_change": "static int fallocate_chunk(struct inode *inode, loff_t offset, loff_t len,\n\t\t\t   int mode)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct buffer_head *dibh;\n\tint error;\n\tu64 start = offset >> PAGE_CACHE_SHIFT;\n\tunsigned int start_offset = offset & ~PAGE_CACHE_MASK;\n\tu64 end = (offset + len - 1) >> PAGE_CACHE_SHIFT;\n\tpgoff_t curr;\n\tstruct page *page;\n\tunsigned int end_offset = (offset + len) & ~PAGE_CACHE_MASK;\n\tunsigned int from, to;\n\n\tif (!end_offset)\n\t\tend_offset = PAGE_CACHE_SIZE;\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (unlikely(error))\n\t\tgoto out;\n\n\tgfs2_trans_add_bh(ip->i_gl, dibh, 1);\n\n\tif (gfs2_is_stuffed(ip)) {\n\t\terror = gfs2_unstuff_dinode(ip, NULL);\n\t\tif (unlikely(error))\n\t\t\tgoto out;\n\t}\n\n\tcurr = start;\n\toffset = start << PAGE_CACHE_SHIFT;\n\tfrom = start_offset;\n\tto = PAGE_CACHE_SIZE;\n\twhile (curr <= end) {\n\t\tpage = grab_cache_page_write_begin(inode->i_mapping, curr,\n\t\t\t\t\t\t   AOP_FLAG_NOFS);\n\t\tif (unlikely(!page)) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (curr == end)\n\t\t\tto = end_offset;\n\t\terror = write_empty_blocks(page, from, to, mode);\n\t\tif (!error && offset + to > inode->i_size &&\n\t\t    !(mode & FALLOC_FL_KEEP_SIZE)) {\n\t\t\ti_size_write(inode, offset + to);\n\t\t}\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tcurr++;\n\t\toffset += PAGE_CACHE_SIZE;\n\t\tfrom = 0;\n\t}\n\n\tmark_inode_dirty(inode);\n\n\tbrelse(dibh);\n\nout:\n\treturn error;\n}",
        "code_after_change": "static int fallocate_chunk(struct inode *inode, loff_t offset, loff_t len,\n\t\t\t   int mode)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct buffer_head *dibh;\n\tint error;\n\tunsigned int nr_blks;\n\tsector_t lblock = offset >> inode->i_blkbits;\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (unlikely(error))\n\t\treturn error;\n\n\tgfs2_trans_add_bh(ip->i_gl, dibh, 1);\n\n\tif (gfs2_is_stuffed(ip)) {\n\t\terror = gfs2_unstuff_dinode(ip, NULL);\n\t\tif (unlikely(error))\n\t\t\tgoto out;\n\t}\n\n\twhile (len) {\n\t\tstruct buffer_head bh_map = { .b_state = 0, .b_blocknr = 0 };\n\t\tbh_map.b_size = len;\n\t\tset_buffer_zeronew(&bh_map);\n\n\t\terror = gfs2_block_map(inode, lblock, &bh_map, 1);\n\t\tif (unlikely(error))\n\t\t\tgoto out;\n\t\tlen -= bh_map.b_size;\n\t\tnr_blks = bh_map.b_size >> inode->i_blkbits;\n\t\tlblock += nr_blks;\n\t\tif (!buffer_new(&bh_map))\n\t\t\tcontinue;\n\t\tif (unlikely(!buffer_zeronew(&bh_map))) {\n\t\t\terror = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (offset + len > inode->i_size && !(mode & FALLOC_FL_KEEP_SIZE))\n\t\ti_size_write(inode, offset + len);\n\n\tmark_inode_dirty(inode);\n\nout:\n\tbrelse(dibh);\n\treturn error;\n}",
        "patch": "--- code before\n+++ code after\n@@ -4,20 +4,12 @@\n \tstruct gfs2_inode *ip = GFS2_I(inode);\n \tstruct buffer_head *dibh;\n \tint error;\n-\tu64 start = offset >> PAGE_CACHE_SHIFT;\n-\tunsigned int start_offset = offset & ~PAGE_CACHE_MASK;\n-\tu64 end = (offset + len - 1) >> PAGE_CACHE_SHIFT;\n-\tpgoff_t curr;\n-\tstruct page *page;\n-\tunsigned int end_offset = (offset + len) & ~PAGE_CACHE_MASK;\n-\tunsigned int from, to;\n-\n-\tif (!end_offset)\n-\t\tend_offset = PAGE_CACHE_SIZE;\n+\tunsigned int nr_blks;\n+\tsector_t lblock = offset >> inode->i_blkbits;\n \n \terror = gfs2_meta_inode_buffer(ip, &dibh);\n \tif (unlikely(error))\n-\t\tgoto out;\n+\t\treturn error;\n \n \tgfs2_trans_add_bh(ip->i_gl, dibh, 1);\n \n@@ -27,38 +19,30 @@\n \t\t\tgoto out;\n \t}\n \n-\tcurr = start;\n-\toffset = start << PAGE_CACHE_SHIFT;\n-\tfrom = start_offset;\n-\tto = PAGE_CACHE_SIZE;\n-\twhile (curr <= end) {\n-\t\tpage = grab_cache_page_write_begin(inode->i_mapping, curr,\n-\t\t\t\t\t\t   AOP_FLAG_NOFS);\n-\t\tif (unlikely(!page)) {\n-\t\t\terror = -ENOMEM;\n+\twhile (len) {\n+\t\tstruct buffer_head bh_map = { .b_state = 0, .b_blocknr = 0 };\n+\t\tbh_map.b_size = len;\n+\t\tset_buffer_zeronew(&bh_map);\n+\n+\t\terror = gfs2_block_map(inode, lblock, &bh_map, 1);\n+\t\tif (unlikely(error))\n+\t\t\tgoto out;\n+\t\tlen -= bh_map.b_size;\n+\t\tnr_blks = bh_map.b_size >> inode->i_blkbits;\n+\t\tlblock += nr_blks;\n+\t\tif (!buffer_new(&bh_map))\n+\t\t\tcontinue;\n+\t\tif (unlikely(!buffer_zeronew(&bh_map))) {\n+\t\t\terror = -EIO;\n \t\t\tgoto out;\n \t\t}\n-\n-\t\tif (curr == end)\n-\t\t\tto = end_offset;\n-\t\terror = write_empty_blocks(page, from, to, mode);\n-\t\tif (!error && offset + to > inode->i_size &&\n-\t\t    !(mode & FALLOC_FL_KEEP_SIZE)) {\n-\t\t\ti_size_write(inode, offset + to);\n-\t\t}\n-\t\tunlock_page(page);\n-\t\tpage_cache_release(page);\n-\t\tif (error)\n-\t\t\tgoto out;\n-\t\tcurr++;\n-\t\toffset += PAGE_CACHE_SIZE;\n-\t\tfrom = 0;\n \t}\n+\tif (offset + len > inode->i_size && !(mode & FALLOC_FL_KEEP_SIZE))\n+\t\ti_size_write(inode, offset + len);\n \n \tmark_inode_dirty(inode);\n \n+out:\n \tbrelse(dibh);\n-\n-out:\n \treturn error;\n }",
        "function_modified_lines": {
            "added": [
                "\tunsigned int nr_blks;",
                "\tsector_t lblock = offset >> inode->i_blkbits;",
                "\t\treturn error;",
                "\twhile (len) {",
                "\t\tstruct buffer_head bh_map = { .b_state = 0, .b_blocknr = 0 };",
                "\t\tbh_map.b_size = len;",
                "\t\tset_buffer_zeronew(&bh_map);",
                "",
                "\t\terror = gfs2_block_map(inode, lblock, &bh_map, 1);",
                "\t\tif (unlikely(error))",
                "\t\t\tgoto out;",
                "\t\tlen -= bh_map.b_size;",
                "\t\tnr_blks = bh_map.b_size >> inode->i_blkbits;",
                "\t\tlblock += nr_blks;",
                "\t\tif (!buffer_new(&bh_map))",
                "\t\t\tcontinue;",
                "\t\tif (unlikely(!buffer_zeronew(&bh_map))) {",
                "\t\t\terror = -EIO;",
                "\tif (offset + len > inode->i_size && !(mode & FALLOC_FL_KEEP_SIZE))",
                "\t\ti_size_write(inode, offset + len);",
                "out:"
            ],
            "deleted": [
                "\tu64 start = offset >> PAGE_CACHE_SHIFT;",
                "\tunsigned int start_offset = offset & ~PAGE_CACHE_MASK;",
                "\tu64 end = (offset + len - 1) >> PAGE_CACHE_SHIFT;",
                "\tpgoff_t curr;",
                "\tstruct page *page;",
                "\tunsigned int end_offset = (offset + len) & ~PAGE_CACHE_MASK;",
                "\tunsigned int from, to;",
                "",
                "\tif (!end_offset)",
                "\t\tend_offset = PAGE_CACHE_SIZE;",
                "\t\tgoto out;",
                "\tcurr = start;",
                "\toffset = start << PAGE_CACHE_SHIFT;",
                "\tfrom = start_offset;",
                "\tto = PAGE_CACHE_SIZE;",
                "\twhile (curr <= end) {",
                "\t\tpage = grab_cache_page_write_begin(inode->i_mapping, curr,",
                "\t\t\t\t\t\t   AOP_FLAG_NOFS);",
                "\t\tif (unlikely(!page)) {",
                "\t\t\terror = -ENOMEM;",
                "",
                "\t\tif (curr == end)",
                "\t\t\tto = end_offset;",
                "\t\terror = write_empty_blocks(page, from, to, mode);",
                "\t\tif (!error && offset + to > inode->i_size &&",
                "\t\t    !(mode & FALLOC_FL_KEEP_SIZE)) {",
                "\t\t\ti_size_write(inode, offset + to);",
                "\t\t}",
                "\t\tunlock_page(page);",
                "\t\tpage_cache_release(page);",
                "\t\tif (error)",
                "\t\t\tgoto out;",
                "\t\tcurr++;",
                "\t\toffset += PAGE_CACHE_SIZE;",
                "\t\tfrom = 0;",
                "",
                "out:"
            ]
        },
        "cwe": [
            "CWE-119"
        ],
        "cve_description": "The fallocate implementation in the GFS2 filesystem in the Linux kernel before 3.2 relies on the page cache, which might allow local users to cause a denial of service by preallocating blocks in certain situations involving insufficient memory.",
        "id": 31
    },
    {
        "cve_id": "CVE-2013-1773",
        "code_before_change": "static int\nxlate_to_uni(const unsigned char *name, int len, unsigned char *outname,\n\t     int *longlen, int *outlen, int escape, int utf8,\n\t     struct nls_table *nls)\n{\n\tconst unsigned char *ip;\n\tunsigned char nc;\n\tunsigned char *op;\n\tunsigned int ec;\n\tint i, k, fill;\n\tint charlen;\n\n\tif (utf8) {\n\t\t*outlen = utf8s_to_utf16s(name, len, (wchar_t *)outname);\n\t\tif (*outlen < 0)\n\t\t\treturn *outlen;\n\t\telse if (*outlen > FAT_LFN_LEN)\n\t\t\treturn -ENAMETOOLONG;\n\n\t\top = &outname[*outlen * sizeof(wchar_t)];\n\t} else {\n\t\tif (nls) {\n\t\t\tfor (i = 0, ip = name, op = outname, *outlen = 0;\n\t\t\t     i < len && *outlen <= FAT_LFN_LEN;\n\t\t\t     *outlen += 1)\n\t\t\t{\n\t\t\t\tif (escape && (*ip == ':')) {\n\t\t\t\t\tif (i > len - 5)\n\t\t\t\t\t\treturn -EINVAL;\n\t\t\t\t\tec = 0;\n\t\t\t\t\tfor (k = 1; k < 5; k++) {\n\t\t\t\t\t\tnc = ip[k];\n\t\t\t\t\t\tec <<= 4;\n\t\t\t\t\t\tif (nc >= '0' && nc <= '9') {\n\t\t\t\t\t\t\tec |= nc - '0';\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (nc >= 'a' && nc <= 'f') {\n\t\t\t\t\t\t\tec |= nc - ('a' - 10);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (nc >= 'A' && nc <= 'F') {\n\t\t\t\t\t\t\tec |= nc - ('A' - 10);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn -EINVAL;\n\t\t\t\t\t}\n\t\t\t\t\t*op++ = ec & 0xFF;\n\t\t\t\t\t*op++ = ec >> 8;\n\t\t\t\t\tip += 5;\n\t\t\t\t\ti += 5;\n\t\t\t\t} else {\n\t\t\t\t\tif ((charlen = nls->char2uni(ip, len - i, (wchar_t *)op)) < 0)\n\t\t\t\t\t\treturn -EINVAL;\n\t\t\t\t\tip += charlen;\n\t\t\t\t\ti += charlen;\n\t\t\t\t\top += 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i < len)\n\t\t\t\treturn -ENAMETOOLONG;\n\t\t} else {\n\t\t\tfor (i = 0, ip = name, op = outname, *outlen = 0;\n\t\t\t     i < len && *outlen <= FAT_LFN_LEN;\n\t\t\t     i++, *outlen += 1)\n\t\t\t{\n\t\t\t\t*op++ = *ip++;\n\t\t\t\t*op++ = 0;\n\t\t\t}\n\t\t\tif (i < len)\n\t\t\t\treturn -ENAMETOOLONG;\n\t\t}\n\t}\n\n\t*longlen = *outlen;\n\tif (*outlen % 13) {\n\t\t*op++ = 0;\n\t\t*op++ = 0;\n\t\t*outlen += 1;\n\t\tif (*outlen % 13) {\n\t\t\tfill = 13 - (*outlen % 13);\n\t\t\tfor (i = 0; i < fill; i++) {\n\t\t\t\t*op++ = 0xff;\n\t\t\t\t*op++ = 0xff;\n\t\t\t}\n\t\t\t*outlen += fill;\n\t\t}\n\t}\n\n\treturn 0;\n}",
        "code_after_change": "static int\nxlate_to_uni(const unsigned char *name, int len, unsigned char *outname,\n\t     int *longlen, int *outlen, int escape, int utf8,\n\t     struct nls_table *nls)\n{\n\tconst unsigned char *ip;\n\tunsigned char nc;\n\tunsigned char *op;\n\tunsigned int ec;\n\tint i, k, fill;\n\tint charlen;\n\n\tif (utf8) {\n\t\t*outlen = utf8s_to_utf16s(name, len, UTF16_HOST_ENDIAN,\n\t\t\t\t(wchar_t *) outname, FAT_LFN_LEN + 2);\n\t\tif (*outlen < 0)\n\t\t\treturn *outlen;\n\t\telse if (*outlen > FAT_LFN_LEN)\n\t\t\treturn -ENAMETOOLONG;\n\n\t\top = &outname[*outlen * sizeof(wchar_t)];\n\t} else {\n\t\tif (nls) {\n\t\t\tfor (i = 0, ip = name, op = outname, *outlen = 0;\n\t\t\t     i < len && *outlen <= FAT_LFN_LEN;\n\t\t\t     *outlen += 1)\n\t\t\t{\n\t\t\t\tif (escape && (*ip == ':')) {\n\t\t\t\t\tif (i > len - 5)\n\t\t\t\t\t\treturn -EINVAL;\n\t\t\t\t\tec = 0;\n\t\t\t\t\tfor (k = 1; k < 5; k++) {\n\t\t\t\t\t\tnc = ip[k];\n\t\t\t\t\t\tec <<= 4;\n\t\t\t\t\t\tif (nc >= '0' && nc <= '9') {\n\t\t\t\t\t\t\tec |= nc - '0';\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (nc >= 'a' && nc <= 'f') {\n\t\t\t\t\t\t\tec |= nc - ('a' - 10);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (nc >= 'A' && nc <= 'F') {\n\t\t\t\t\t\t\tec |= nc - ('A' - 10);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn -EINVAL;\n\t\t\t\t\t}\n\t\t\t\t\t*op++ = ec & 0xFF;\n\t\t\t\t\t*op++ = ec >> 8;\n\t\t\t\t\tip += 5;\n\t\t\t\t\ti += 5;\n\t\t\t\t} else {\n\t\t\t\t\tif ((charlen = nls->char2uni(ip, len - i, (wchar_t *)op)) < 0)\n\t\t\t\t\t\treturn -EINVAL;\n\t\t\t\t\tip += charlen;\n\t\t\t\t\ti += charlen;\n\t\t\t\t\top += 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i < len)\n\t\t\t\treturn -ENAMETOOLONG;\n\t\t} else {\n\t\t\tfor (i = 0, ip = name, op = outname, *outlen = 0;\n\t\t\t     i < len && *outlen <= FAT_LFN_LEN;\n\t\t\t     i++, *outlen += 1)\n\t\t\t{\n\t\t\t\t*op++ = *ip++;\n\t\t\t\t*op++ = 0;\n\t\t\t}\n\t\t\tif (i < len)\n\t\t\t\treturn -ENAMETOOLONG;\n\t\t}\n\t}\n\n\t*longlen = *outlen;\n\tif (*outlen % 13) {\n\t\t*op++ = 0;\n\t\t*op++ = 0;\n\t\t*outlen += 1;\n\t\tif (*outlen % 13) {\n\t\t\tfill = 13 - (*outlen % 13);\n\t\t\tfor (i = 0; i < fill; i++) {\n\t\t\t\t*op++ = 0xff;\n\t\t\t\t*op++ = 0xff;\n\t\t\t}\n\t\t\t*outlen += fill;\n\t\t}\n\t}\n\n\treturn 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -11,7 +11,8 @@\n \tint charlen;\n \n \tif (utf8) {\n-\t\t*outlen = utf8s_to_utf16s(name, len, (wchar_t *)outname);\n+\t\t*outlen = utf8s_to_utf16s(name, len, UTF16_HOST_ENDIAN,\n+\t\t\t\t(wchar_t *) outname, FAT_LFN_LEN + 2);\n \t\tif (*outlen < 0)\n \t\t\treturn *outlen;\n \t\telse if (*outlen > FAT_LFN_LEN)",
        "function_modified_lines": {
            "added": [
                "\t\t*outlen = utf8s_to_utf16s(name, len, UTF16_HOST_ENDIAN,",
                "\t\t\t\t(wchar_t *) outname, FAT_LFN_LEN + 2);"
            ],
            "deleted": [
                "\t\t*outlen = utf8s_to_utf16s(name, len, (wchar_t *)outname);"
            ]
        },
        "cwe": [
            "CWE-119"
        ],
        "cve_description": "Buffer overflow in the VFAT filesystem implementation in the Linux kernel before 3.3 allows local users to gain privileges or cause a denial of service (system crash) via a VFAT write operation on a filesystem with the utf8 mount option, which is not properly handled during UTF-8 to UTF-16 conversion.",
        "id": 182
    },
    {
        "cve_id": "CVE-2013-4588",
        "code_before_change": "static int\ndo_ip_vs_set_ctl(struct sock *sk, int cmd, void __user *user, unsigned int len)\n{\n\tint ret;\n\tunsigned char arg[MAX_ARG_LEN];\n\tstruct ip_vs_service_user *usvc_compat;\n\tstruct ip_vs_service_user_kern usvc;\n\tstruct ip_vs_service *svc;\n\tstruct ip_vs_dest_user *udest_compat;\n\tstruct ip_vs_dest_user_kern udest;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (len != set_arglen[SET_CMDID(cmd)]) {\n\t\tpr_err(\"set_ctl: len %u != %u\\n\",\n\t\t       len, set_arglen[SET_CMDID(cmd)]);\n\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(arg, user, len) != 0)\n\t\treturn -EFAULT;\n\n\t/* increase the module use count */\n\tip_vs_use_count_inc();\n\n\tif (mutex_lock_interruptible(&__ip_vs_mutex)) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto out_dec;\n\t}\n\n\tif (cmd == IP_VS_SO_SET_FLUSH) {\n\t\t/* Flush the virtual service */\n\t\tret = ip_vs_flush();\n\t\tgoto out_unlock;\n\t} else if (cmd == IP_VS_SO_SET_TIMEOUT) {\n\t\t/* Set timeout values for (tcp tcpfin udp) */\n\t\tret = ip_vs_set_timeout((struct ip_vs_timeout_user *)arg);\n\t\tgoto out_unlock;\n\t} else if (cmd == IP_VS_SO_SET_STARTDAEMON) {\n\t\tstruct ip_vs_daemon_user *dm = (struct ip_vs_daemon_user *)arg;\n\t\tret = start_sync_thread(dm->state, dm->mcast_ifn, dm->syncid);\n\t\tgoto out_unlock;\n\t} else if (cmd == IP_VS_SO_SET_STOPDAEMON) {\n\t\tstruct ip_vs_daemon_user *dm = (struct ip_vs_daemon_user *)arg;\n\t\tret = stop_sync_thread(dm->state);\n\t\tgoto out_unlock;\n\t}\n\n\tusvc_compat = (struct ip_vs_service_user *)arg;\n\tudest_compat = (struct ip_vs_dest_user *)(usvc_compat + 1);\n\n\t/* We only use the new structs internally, so copy userspace compat\n\t * structs to extended internal versions */\n\tip_vs_copy_usvc_compat(&usvc, usvc_compat);\n\tip_vs_copy_udest_compat(&udest, udest_compat);\n\n\tif (cmd == IP_VS_SO_SET_ZERO) {\n\t\t/* if no service address is set, zero counters in all */\n\t\tif (!usvc.fwmark && !usvc.addr.ip && !usvc.port) {\n\t\t\tret = ip_vs_zero_all();\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\t/* Check for valid protocol: TCP or UDP, even for fwmark!=0 */\n\tif (usvc.protocol != IPPROTO_TCP && usvc.protocol != IPPROTO_UDP) {\n\t\tpr_err(\"set_ctl: invalid protocol: %d %pI4:%d %s\\n\",\n\t\t       usvc.protocol, &usvc.addr.ip,\n\t\t       ntohs(usvc.port), usvc.sched_name);\n\t\tret = -EFAULT;\n\t\tgoto out_unlock;\n\t}\n\n\t/* Lookup the exact service by <protocol, addr, port> or fwmark */\n\tif (usvc.fwmark == 0)\n\t\tsvc = __ip_vs_service_get(usvc.af, usvc.protocol,\n\t\t\t\t\t  &usvc.addr, usvc.port);\n\telse\n\t\tsvc = __ip_vs_svc_fwm_get(usvc.af, usvc.fwmark);\n\n\tif (cmd != IP_VS_SO_SET_ADD\n\t    && (svc == NULL || svc->protocol != usvc.protocol)) {\n\t\tret = -ESRCH;\n\t\tgoto out_unlock;\n\t}\n\n\tswitch (cmd) {\n\tcase IP_VS_SO_SET_ADD:\n\t\tif (svc != NULL)\n\t\t\tret = -EEXIST;\n\t\telse\n\t\t\tret = ip_vs_add_service(&usvc, &svc);\n\t\tbreak;\n\tcase IP_VS_SO_SET_EDIT:\n\t\tret = ip_vs_edit_service(svc, &usvc);\n\t\tbreak;\n\tcase IP_VS_SO_SET_DEL:\n\t\tret = ip_vs_del_service(svc);\n\t\tif (!ret)\n\t\t\tgoto out_unlock;\n\t\tbreak;\n\tcase IP_VS_SO_SET_ZERO:\n\t\tret = ip_vs_zero_service(svc);\n\t\tbreak;\n\tcase IP_VS_SO_SET_ADDDEST:\n\t\tret = ip_vs_add_dest(svc, &udest);\n\t\tbreak;\n\tcase IP_VS_SO_SET_EDITDEST:\n\t\tret = ip_vs_edit_dest(svc, &udest);\n\t\tbreak;\n\tcase IP_VS_SO_SET_DELDEST:\n\t\tret = ip_vs_del_dest(svc, &udest);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tif (svc)\n\t\tip_vs_service_put(svc);\n\n  out_unlock:\n\tmutex_unlock(&__ip_vs_mutex);\n  out_dec:\n\t/* decrease the module use count */\n\tip_vs_use_count_dec();\n\n\treturn ret;\n}",
        "code_after_change": "static int\ndo_ip_vs_set_ctl(struct sock *sk, int cmd, void __user *user, unsigned int len)\n{\n\tint ret;\n\tunsigned char arg[MAX_ARG_LEN];\n\tstruct ip_vs_service_user *usvc_compat;\n\tstruct ip_vs_service_user_kern usvc;\n\tstruct ip_vs_service *svc;\n\tstruct ip_vs_dest_user *udest_compat;\n\tstruct ip_vs_dest_user_kern udest;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (cmd < IP_VS_BASE_CTL || cmd > IP_VS_SO_SET_MAX)\n\t\treturn -EINVAL;\n\tif (len < 0 || len >  MAX_ARG_LEN)\n\t\treturn -EINVAL;\n\tif (len != set_arglen[SET_CMDID(cmd)]) {\n\t\tpr_err(\"set_ctl: len %u != %u\\n\",\n\t\t       len, set_arglen[SET_CMDID(cmd)]);\n\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(arg, user, len) != 0)\n\t\treturn -EFAULT;\n\n\t/* increase the module use count */\n\tip_vs_use_count_inc();\n\n\tif (mutex_lock_interruptible(&__ip_vs_mutex)) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto out_dec;\n\t}\n\n\tif (cmd == IP_VS_SO_SET_FLUSH) {\n\t\t/* Flush the virtual service */\n\t\tret = ip_vs_flush();\n\t\tgoto out_unlock;\n\t} else if (cmd == IP_VS_SO_SET_TIMEOUT) {\n\t\t/* Set timeout values for (tcp tcpfin udp) */\n\t\tret = ip_vs_set_timeout((struct ip_vs_timeout_user *)arg);\n\t\tgoto out_unlock;\n\t} else if (cmd == IP_VS_SO_SET_STARTDAEMON) {\n\t\tstruct ip_vs_daemon_user *dm = (struct ip_vs_daemon_user *)arg;\n\t\tret = start_sync_thread(dm->state, dm->mcast_ifn, dm->syncid);\n\t\tgoto out_unlock;\n\t} else if (cmd == IP_VS_SO_SET_STOPDAEMON) {\n\t\tstruct ip_vs_daemon_user *dm = (struct ip_vs_daemon_user *)arg;\n\t\tret = stop_sync_thread(dm->state);\n\t\tgoto out_unlock;\n\t}\n\n\tusvc_compat = (struct ip_vs_service_user *)arg;\n\tudest_compat = (struct ip_vs_dest_user *)(usvc_compat + 1);\n\n\t/* We only use the new structs internally, so copy userspace compat\n\t * structs to extended internal versions */\n\tip_vs_copy_usvc_compat(&usvc, usvc_compat);\n\tip_vs_copy_udest_compat(&udest, udest_compat);\n\n\tif (cmd == IP_VS_SO_SET_ZERO) {\n\t\t/* if no service address is set, zero counters in all */\n\t\tif (!usvc.fwmark && !usvc.addr.ip && !usvc.port) {\n\t\t\tret = ip_vs_zero_all();\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\t/* Check for valid protocol: TCP or UDP, even for fwmark!=0 */\n\tif (usvc.protocol != IPPROTO_TCP && usvc.protocol != IPPROTO_UDP) {\n\t\tpr_err(\"set_ctl: invalid protocol: %d %pI4:%d %s\\n\",\n\t\t       usvc.protocol, &usvc.addr.ip,\n\t\t       ntohs(usvc.port), usvc.sched_name);\n\t\tret = -EFAULT;\n\t\tgoto out_unlock;\n\t}\n\n\t/* Lookup the exact service by <protocol, addr, port> or fwmark */\n\tif (usvc.fwmark == 0)\n\t\tsvc = __ip_vs_service_get(usvc.af, usvc.protocol,\n\t\t\t\t\t  &usvc.addr, usvc.port);\n\telse\n\t\tsvc = __ip_vs_svc_fwm_get(usvc.af, usvc.fwmark);\n\n\tif (cmd != IP_VS_SO_SET_ADD\n\t    && (svc == NULL || svc->protocol != usvc.protocol)) {\n\t\tret = -ESRCH;\n\t\tgoto out_unlock;\n\t}\n\n\tswitch (cmd) {\n\tcase IP_VS_SO_SET_ADD:\n\t\tif (svc != NULL)\n\t\t\tret = -EEXIST;\n\t\telse\n\t\t\tret = ip_vs_add_service(&usvc, &svc);\n\t\tbreak;\n\tcase IP_VS_SO_SET_EDIT:\n\t\tret = ip_vs_edit_service(svc, &usvc);\n\t\tbreak;\n\tcase IP_VS_SO_SET_DEL:\n\t\tret = ip_vs_del_service(svc);\n\t\tif (!ret)\n\t\t\tgoto out_unlock;\n\t\tbreak;\n\tcase IP_VS_SO_SET_ZERO:\n\t\tret = ip_vs_zero_service(svc);\n\t\tbreak;\n\tcase IP_VS_SO_SET_ADDDEST:\n\t\tret = ip_vs_add_dest(svc, &udest);\n\t\tbreak;\n\tcase IP_VS_SO_SET_EDITDEST:\n\t\tret = ip_vs_edit_dest(svc, &udest);\n\t\tbreak;\n\tcase IP_VS_SO_SET_DELDEST:\n\t\tret = ip_vs_del_dest(svc, &udest);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tif (svc)\n\t\tip_vs_service_put(svc);\n\n  out_unlock:\n\tmutex_unlock(&__ip_vs_mutex);\n  out_dec:\n\t/* decrease the module use count */\n\tip_vs_use_count_dec();\n\n\treturn ret;\n}",
        "patch": "--- code before\n+++ code after\n@@ -12,6 +12,10 @@\n \tif (!capable(CAP_NET_ADMIN))\n \t\treturn -EPERM;\n \n+\tif (cmd < IP_VS_BASE_CTL || cmd > IP_VS_SO_SET_MAX)\n+\t\treturn -EINVAL;\n+\tif (len < 0 || len >  MAX_ARG_LEN)\n+\t\treturn -EINVAL;\n \tif (len != set_arglen[SET_CMDID(cmd)]) {\n \t\tpr_err(\"set_ctl: len %u != %u\\n\",\n \t\t       len, set_arglen[SET_CMDID(cmd)]);",
        "function_modified_lines": {
            "added": [
                "\tif (cmd < IP_VS_BASE_CTL || cmd > IP_VS_SO_SET_MAX)",
                "\t\treturn -EINVAL;",
                "\tif (len < 0 || len >  MAX_ARG_LEN)",
                "\t\treturn -EINVAL;"
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-119"
        ],
        "cve_description": "Multiple stack-based buffer overflows in net/netfilter/ipvs/ip_vs_ctl.c in the Linux kernel before 2.6.33, when CONFIG_IP_VS is used, allow local users to gain privileges by leveraging the CAP_NET_ADMIN capability for (1) a getsockopt system call, related to the do_ip_vs_get_ctl function, or (2) a setsockopt system call, related to the do_ip_vs_set_ctl function.",
        "id": 333
    },
    {
        "cve_id": "CVE-2015-4036",
        "code_before_change": "static struct se_portal_group *\nvhost_scsi_make_tpg(struct se_wwn *wwn,\n\t\t   struct config_group *group,\n\t\t   const char *name)\n{\n\tstruct vhost_scsi_tport *tport = container_of(wwn,\n\t\t\tstruct vhost_scsi_tport, tport_wwn);\n\n\tstruct vhost_scsi_tpg *tpg;\n\tunsigned long tpgt;\n\tint ret;\n\n\tif (strstr(name, \"tpgt_\") != name)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (kstrtoul(name + 5, 10, &tpgt) || tpgt > UINT_MAX)\n\t\treturn ERR_PTR(-EINVAL);\n\n\ttpg = kzalloc(sizeof(struct vhost_scsi_tpg), GFP_KERNEL);\n\tif (!tpg) {\n\t\tpr_err(\"Unable to allocate struct vhost_scsi_tpg\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tmutex_init(&tpg->tv_tpg_mutex);\n\tINIT_LIST_HEAD(&tpg->tv_tpg_list);\n\ttpg->tport = tport;\n\ttpg->tport_tpgt = tpgt;\n\n\tret = core_tpg_register(&vhost_scsi_fabric_configfs->tf_ops, wwn,\n\t\t\t\t&tpg->se_tpg, tpg, TRANSPORT_TPG_TYPE_NORMAL);\n\tif (ret < 0) {\n\t\tkfree(tpg);\n\t\treturn NULL;\n\t}\n\tmutex_lock(&vhost_scsi_mutex);\n\tlist_add_tail(&tpg->tv_tpg_list, &vhost_scsi_list);\n\tmutex_unlock(&vhost_scsi_mutex);\n\n\treturn &tpg->se_tpg;\n}",
        "code_after_change": "static struct se_portal_group *\nvhost_scsi_make_tpg(struct se_wwn *wwn,\n\t\t   struct config_group *group,\n\t\t   const char *name)\n{\n\tstruct vhost_scsi_tport *tport = container_of(wwn,\n\t\t\tstruct vhost_scsi_tport, tport_wwn);\n\n\tstruct vhost_scsi_tpg *tpg;\n\tu16 tpgt;\n\tint ret;\n\n\tif (strstr(name, \"tpgt_\") != name)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (kstrtou16(name + 5, 10, &tpgt) || tpgt >= VHOST_SCSI_MAX_TARGET)\n\t\treturn ERR_PTR(-EINVAL);\n\n\ttpg = kzalloc(sizeof(struct vhost_scsi_tpg), GFP_KERNEL);\n\tif (!tpg) {\n\t\tpr_err(\"Unable to allocate struct vhost_scsi_tpg\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tmutex_init(&tpg->tv_tpg_mutex);\n\tINIT_LIST_HEAD(&tpg->tv_tpg_list);\n\ttpg->tport = tport;\n\ttpg->tport_tpgt = tpgt;\n\n\tret = core_tpg_register(&vhost_scsi_fabric_configfs->tf_ops, wwn,\n\t\t\t\t&tpg->se_tpg, tpg, TRANSPORT_TPG_TYPE_NORMAL);\n\tif (ret < 0) {\n\t\tkfree(tpg);\n\t\treturn NULL;\n\t}\n\tmutex_lock(&vhost_scsi_mutex);\n\tlist_add_tail(&tpg->tv_tpg_list, &vhost_scsi_list);\n\tmutex_unlock(&vhost_scsi_mutex);\n\n\treturn &tpg->se_tpg;\n}",
        "patch": "--- code before\n+++ code after\n@@ -7,12 +7,12 @@\n \t\t\tstruct vhost_scsi_tport, tport_wwn);\n \n \tstruct vhost_scsi_tpg *tpg;\n-\tunsigned long tpgt;\n+\tu16 tpgt;\n \tint ret;\n \n \tif (strstr(name, \"tpgt_\") != name)\n \t\treturn ERR_PTR(-EINVAL);\n-\tif (kstrtoul(name + 5, 10, &tpgt) || tpgt > UINT_MAX)\n+\tif (kstrtou16(name + 5, 10, &tpgt) || tpgt >= VHOST_SCSI_MAX_TARGET)\n \t\treturn ERR_PTR(-EINVAL);\n \n \ttpg = kzalloc(sizeof(struct vhost_scsi_tpg), GFP_KERNEL);",
        "function_modified_lines": {
            "added": [
                "\tu16 tpgt;",
                "\tif (kstrtou16(name + 5, 10, &tpgt) || tpgt >= VHOST_SCSI_MAX_TARGET)"
            ],
            "deleted": [
                "\tunsigned long tpgt;",
                "\tif (kstrtoul(name + 5, 10, &tpgt) || tpgt > UINT_MAX)"
            ]
        },
        "cwe": [
            "CWE-119"
        ],
        "cve_description": "Array index error in the tcm_vhost_make_tpg function in drivers/vhost/scsi.c in the Linux kernel before 4.0 might allow guest OS users to cause a denial of service (memory corruption) or possibly have unspecified other impact via a crafted VHOST_SCSI_SET_ENDPOINT ioctl call.  NOTE: the affected function was renamed to vhost_scsi_make_tpg before the vulnerability was announced.",
        "id": 761
    },
    {
        "cve_id": "CVE-2013-0231",
        "code_before_change": "int xen_pcibk_enable_msi(struct xen_pcibk_device *pdev,\n\t\t\t struct pci_dev *dev, struct xen_pci_op *op)\n{\n\tstruct xen_pcibk_dev_data *dev_data;\n\tint otherend = pdev->xdev->otherend_id;\n\tint status;\n\n\tif (unlikely(verbose_request))\n\t\tprintk(KERN_DEBUG DRV_NAME \": %s: enable MSI\\n\", pci_name(dev));\n\n\tstatus = pci_enable_msi(dev);\n\n\tif (status) {\n\t\tprintk(KERN_ERR \"error enable msi for guest %x status %x\\n\",\n\t\t\totherend, status);\n\t\top->value = 0;\n\t\treturn XEN_PCI_ERR_op_failed;\n\t}\n\n\t/* The value the guest needs is actually the IDT vector, not the\n\t * the local domain's IRQ number. */\n\n\top->value = dev->irq ? xen_pirq_from_irq(dev->irq) : 0;\n\tif (unlikely(verbose_request))\n\t\tprintk(KERN_DEBUG DRV_NAME \": %s: MSI: %d\\n\", pci_name(dev),\n\t\t\top->value);\n\n\tdev_data = pci_get_drvdata(dev);\n\tif (dev_data)\n\t\tdev_data->ack_intr = 0;\n\n\treturn 0;\n}",
        "code_after_change": "int xen_pcibk_enable_msi(struct xen_pcibk_device *pdev,\n\t\t\t struct pci_dev *dev, struct xen_pci_op *op)\n{\n\tstruct xen_pcibk_dev_data *dev_data;\n\tint status;\n\n\tif (unlikely(verbose_request))\n\t\tprintk(KERN_DEBUG DRV_NAME \": %s: enable MSI\\n\", pci_name(dev));\n\n\tstatus = pci_enable_msi(dev);\n\n\tif (status) {\n\t\tpr_warn_ratelimited(DRV_NAME \": %s: error enabling MSI for guest %u: err %d\\n\",\n\t\t\t\t    pci_name(dev), pdev->xdev->otherend_id,\n\t\t\t\t    status);\n\t\top->value = 0;\n\t\treturn XEN_PCI_ERR_op_failed;\n\t}\n\n\t/* The value the guest needs is actually the IDT vector, not the\n\t * the local domain's IRQ number. */\n\n\top->value = dev->irq ? xen_pirq_from_irq(dev->irq) : 0;\n\tif (unlikely(verbose_request))\n\t\tprintk(KERN_DEBUG DRV_NAME \": %s: MSI: %d\\n\", pci_name(dev),\n\t\t\top->value);\n\n\tdev_data = pci_get_drvdata(dev);\n\tif (dev_data)\n\t\tdev_data->ack_intr = 0;\n\n\treturn 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -2,7 +2,6 @@\n \t\t\t struct pci_dev *dev, struct xen_pci_op *op)\n {\n \tstruct xen_pcibk_dev_data *dev_data;\n-\tint otherend = pdev->xdev->otherend_id;\n \tint status;\n \n \tif (unlikely(verbose_request))\n@@ -11,8 +10,9 @@\n \tstatus = pci_enable_msi(dev);\n \n \tif (status) {\n-\t\tprintk(KERN_ERR \"error enable msi for guest %x status %x\\n\",\n-\t\t\totherend, status);\n+\t\tpr_warn_ratelimited(DRV_NAME \": %s: error enabling MSI for guest %u: err %d\\n\",\n+\t\t\t\t    pci_name(dev), pdev->xdev->otherend_id,\n+\t\t\t\t    status);\n \t\top->value = 0;\n \t\treturn XEN_PCI_ERR_op_failed;\n \t}",
        "function_modified_lines": {
            "added": [
                "\t\tpr_warn_ratelimited(DRV_NAME \": %s: error enabling MSI for guest %u: err %d\\n\",",
                "\t\t\t\t    pci_name(dev), pdev->xdev->otherend_id,",
                "\t\t\t\t    status);"
            ],
            "deleted": [
                "\tint otherend = pdev->xdev->otherend_id;",
                "\t\tprintk(KERN_ERR \"error enable msi for guest %x status %x\\n\",",
                "\t\t\totherend, status);"
            ]
        },
        "cwe": [
            "CWE-119"
        ],
        "cve_description": "The pciback_enable_msi function in the PCI backend driver (drivers/xen/pciback/conf_space_capability_msi.c) in Xen for the Linux kernel 2.6.18 and 3.8 allows guest OS users with PCI device access to cause a denial of service via a large number of kernel log messages. NOTE: some of these details are obtained from third party information.",
        "id": 151
    },
    {
        "cve_id": "CVE-2013-0309",
        "code_before_change": "static inline int pmd_large(pmd_t pte)\n{\n\treturn (pmd_flags(pte) & (_PAGE_PSE | _PAGE_PRESENT)) ==\n\t\t(_PAGE_PSE | _PAGE_PRESENT);\n}",
        "code_after_change": "static inline int pmd_large(pmd_t pte)\n{\n\treturn pmd_flags(pte) & _PAGE_PSE;\n}",
        "patch": "--- code before\n+++ code after\n@@ -1,5 +1,4 @@\n static inline int pmd_large(pmd_t pte)\n {\n-\treturn (pmd_flags(pte) & (_PAGE_PSE | _PAGE_PRESENT)) ==\n-\t\t(_PAGE_PSE | _PAGE_PRESENT);\n+\treturn pmd_flags(pte) & _PAGE_PSE;\n }",
        "function_modified_lines": {
            "added": [
                "\treturn pmd_flags(pte) & _PAGE_PSE;"
            ],
            "deleted": [
                "\treturn (pmd_flags(pte) & (_PAGE_PSE | _PAGE_PRESENT)) ==",
                "\t\t(_PAGE_PSE | _PAGE_PRESENT);"
            ]
        },
        "cwe": [
            "CWE-119"
        ],
        "cve_description": "arch/x86/include/asm/pgtable.h in the Linux kernel before 3.6.2, when transparent huge pages are used, does not properly support PROT_NONE memory regions, which allows local users to cause a denial of service (system crash) via a crafted application.",
        "id": 156
    },
    {
        "cve_id": "CVE-2022-3625",
        "code_before_change": "static int devlink_param_set(struct devlink *devlink,\n\t\t\t     const struct devlink_param *param,\n\t\t\t     struct devlink_param_gset_ctx *ctx)\n{\n\tif (!param->set)\n\t\treturn -EOPNOTSUPP;\n\treturn param->set(devlink, param->id, ctx);\n}",
        "code_after_change": "static int devlink_param_set(struct devlink *devlink,\n\t\t\t     const struct devlink_param *param,\n\t\t\t     struct devlink_param_gset_ctx *ctx)\n{\n\tif (!param->set || devlink->reload_failed)\n\t\treturn -EOPNOTSUPP;\n\treturn param->set(devlink, param->id, ctx);\n}",
        "patch": "--- code before\n+++ code after\n@@ -2,7 +2,7 @@\n \t\t\t     const struct devlink_param *param,\n \t\t\t     struct devlink_param_gset_ctx *ctx)\n {\n-\tif (!param->set)\n+\tif (!param->set || devlink->reload_failed)\n \t\treturn -EOPNOTSUPP;\n \treturn param->set(devlink, param->id, ctx);\n }",
        "function_modified_lines": {
            "added": [
                "\tif (!param->set || devlink->reload_failed)"
            ],
            "deleted": [
                "\tif (!param->set)"
            ]
        },
        "cwe": [
            "CWE-119"
        ],
        "cve_description": "A vulnerability was found in Linux Kernel. It has been classified as critical. This affects the function devlink_param_set/devlink_param_get of the file net/core/devlink.c of the component IPsec. The manipulation leads to use after free. It is recommended to apply a patch to fix this issue. The identifier VDB-211929 was assigned to this vulnerability.",
        "id": 3661
    },
    {
        "cve_id": "CVE-2013-4514",
        "code_before_change": "int wvlan_uil_put_info(struct uilreq *urq, struct wl_private *lp)\n{\n\tint                     result = 0;\n\tltv_t                   *pLtv;\n\tbool_t                  ltvAllocated = FALSE;\n\tENCSTRCT                sEncryption;\n\n#ifdef USE_WDS\n\thcf_16                  hcfPort  = HCF_PORT_0;\n#endif  /* USE_WDS */\n\t/*------------------------------------------------------------------------*/\n\tDBG_FUNC(\"wvlan_uil_put_info\");\n\tDBG_ENTER(DbgInfo);\n\n\n\tif (urq->hcfCtx == &(lp->hcfCtx)) {\n\t\tif (capable(CAP_NET_ADMIN)) {\n\t\t\tif ((urq->data != NULL) && (urq->len != 0)) {\n\t\t\t\t/* Make sure that we have at least a command and length to send. */\n\t\t\t\tif (urq->len < (sizeof(hcf_16) * 2)) {\n\t\t\t\t\turq->len = sizeof(lp->ltvRecord);\n\t\t\t\t\turq->result = UIL_ERR_LEN;\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"No Length/Type in LTV!!!\\n\");\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"UIL_ERR_LEN\\n\");\n\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\t/* Verify the user buffer */\n\t\t\t\tresult = verify_area(VERIFY_READ, urq->data, urq->len);\n\t\t\t\tif (result != 0) {\n\t\t\t\t\turq->result = UIL_FAILURE;\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"verify_area(), VERIFY_READ FAILED\\n\");\n\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\t/* Get only the command and length information. */\n\t\t\t\tcopy_from_user(&(lp->ltvRecord), urq->data, sizeof(hcf_16) * 2);\n\n\t\t\t\t/* Make sure the incoming LTV record length is within the bounds of the\n\t\t\t\t   IOCTL length */\n\t\t\t\tif (((lp->ltvRecord.len + 1) * sizeof(hcf_16)) > urq->len) {\n\t\t\t\t\turq->len = sizeof(lp->ltvRecord);\n\t\t\t\t\turq->result = UIL_ERR_LEN;\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"UIL_ERR_LEN\\n\");\n\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\t/* If the requested length is greater than the size of our local\n\t\t\t\t   LTV record, try to allocate it from the kernel stack.\n\t\t\t\t   Otherwise, we just use our local LTV record. */\n\t\t\t\tif (urq->len > sizeof(lp->ltvRecord)) {\n\t\t\t\t\tpLtv = kmalloc(urq->len, GFP_KERNEL);\n\t\t\t\t\tif (pLtv != NULL) {\n\t\t\t\t\t\tltvAllocated = TRUE;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tDBG_ERROR(DbgInfo, \"Alloc FAILED\\n\");\n\t\t\t\t\t\turq->len = sizeof(lp->ltvRecord);\n\t\t\t\t\t\turq->result = UIL_ERR_LEN;\n\t\t\t\t\t\tresult = -ENOMEM;\n\t\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpLtv = &(lp->ltvRecord);\n\t\t\t\t}\n\n\t\t\t\t/* Copy the data from the user's buffer into the local LTV\n\t\t\t\t   record data area. */\n\t\t\t\tcopy_from_user(pLtv, urq->data, urq->len);\n\n\n\t\t\t\t/* We need to snoop the commands to see if there is anything we\n\t\t\t\t   need to store for the purposes of a reset or start/stop\n\t\t\t\t   sequence. Perform endian translation as needed */\n\t\t\t\tswitch (pLtv->typ) {\n\t\t\t\tcase CFG_CNF_PORT_TYPE:\n\t\t\t\t\tlp->PortType    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_OWN_MAC_ADDR:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_OWN_CHANNEL:\n\t\t\t\t\tlp->Channel     = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t/* CFG_CNF_OWN_SSID currently same as CNF_DESIRED_SSID. Do we\n\t\t\t\t   need separate storage for this? */\n\t\t\t\t/* case CFG_CNF_OWN_SSID: */\n\t\t\t\tcase CFG_CNF_OWN_ATIM_WINDOW:\n\t\t\t\t\tlp->atimWindow  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_SYSTEM_SCALE:\n\t\t\t\t\tlp->DistanceBetweenAPs  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\n\t\t\t\tcase CFG_CNF_MAX_DATA_LEN:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based\n\t\t\t\t\t   on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_PM_ENABLED:\n\t\t\t\t\tlp->PMEnabled   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_MCAST_RX:\n\t\t\t\t\tlp->MulticastReceive    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_MAX_SLEEP_DURATION:\n\t\t\t\t\tlp->MaxSleepDuration    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_HOLDOVER_DURATION:\n\t\t\t\t\tlp->holdoverDuration    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_OWN_NAME:\n\t\t\t\t\tmemset(lp->StationName, 0, sizeof(lp->StationName));\n\t\t\t\t\tmemcpy((void *)lp->StationName, (void *)&pLtv->u.u8[2], (size_t)pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_LOAD_BALANCING:\n\t\t\t\t\tlp->loadBalancing       = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_MEDIUM_DISTRIBUTION:\n\t\t\t\t\tlp->mediumDistribution  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef WARP\n\t\t\t\tcase CFG_CNF_TX_POW_LVL:\n\t\t\t\t\tlp->txPowLevel          = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t/* case CFG_CNF_SHORT_RETRY_LIMIT: */ /* Short Retry Limit */\n\t\t\t\t/* case 0xFC33: */   /* Long Retry Limit */\n\t\t\t\tcase CFG_SUPPORTED_RATE_SET_CNTL:        /* Supported Rate Set Control */\n\t\t\t\t\tlp->srsc[0]             = pLtv->u.u16[0];\n\t\t\t\t\tlp->srsc[1]             = pLtv->u.u16[1];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[1]          = CNV_INT_TO_LITTLE(pLtv->u.u16[1]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_BASIC_RATE_SET_CNTL:        /* Basic Rate Set Control */\n\t\t\t\t\tlp->brsc[0]             = pLtv->u.u16[0];\n\t\t\t\t\tlp->brsc[1]             = pLtv->u.u16[1];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[1]          = CNV_INT_TO_LITTLE(pLtv->u.u16[1]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_CONNECTION_CNTL:\n\t\t\t\t\tlp->connectionControl   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t/* case CFG_PROBE_DATA_RATE: */\n#endif  /* HERMES25 */\n\n#if 1 /* ;? (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/* ;?should we restore this to allow smaller memory footprint */\n\n\t\t\t\tcase CFG_CNF_OWN_DTIM_PERIOD:\n\t\t\t\t\tlp->DTIMPeriod  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef WARP\n\t\t\t\tcase CFG_CNF_OWN_BEACON_INTERVAL:        /* Own Beacon Interval */\n\t\t\t\t\tlp->ownBeaconInterval   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#endif /* WARP */\n\t\t\t\tcase CFG_COEXISTENSE_BEHAVIOUR:         /* Coexistence behavior */\n\t\t\t\t\tlp->coexistence         = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef USE_WDS\n\t\t\t\tcase CFG_CNF_WDS_ADDR1:\n\t\t\t\t\tmemcpy(&lp->wds_port[0].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR2:\n\t\t\t\t\tmemcpy(&lp->wds_port[1].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR3:\n\t\t\t\t\tmemcpy(&lp->wds_port[2].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR4:\n\t\t\t\t\tmemcpy(&lp->wds_port[3].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR5:\n\t\t\t\t\tmemcpy(&lp->wds_port[4].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR6:\n\t\t\t\t\tmemcpy(&lp->wds_port[5].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_6;\n\t\t\t\t\tbreak;\n#endif  /* USE_WDS */\n\n\t\t\t\tcase CFG_CNF_MCAST_PM_BUF:\n\t\t\t\t\tlp->multicastPMBuffering    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_REJECT_ANY:\n\t\t\t\t\tlp->RejectAny   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#endif\n\n\t\t\t\tcase CFG_CNF_ENCRYPTION:\n\t\t\t\t\tlp->EnableEncryption    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_AUTHENTICATION:\n\t\t\t\t\tlp->authentication  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#if 1 /* ;? (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/* ;?should we restore this to allow smaller memory footprint */\n\n\t\t\t\t/* case CFG_CNF_EXCL_UNENCRYPTED:\n\t\t\t\t\tlp->ExcludeUnencrypted  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak; */\n\t\t\t\tcase CFG_CNF_MCAST_RATE:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_INTRA_BSS_RELAY:\n\t\t\t\t\tlp->intraBSSRelay   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#endif\n\n\t\t\t\tcase CFG_CNF_MICRO_WAVE:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\t/*case CFG_CNF_LOAD_BALANCING:*/\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n\t\t\t\t/* case CFG_CNF_MEDIUM_DISTRIBUTION: */\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n\t\t\t\t/* case CFG_CNF_RX_ALL_GROUP_ADDRESS: */\n\t\t\t\t\t/*  TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n\t\t\t\t/* case CFG_CNF_COUNTRY_INFO: */\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n\t\t\t\tcase CFG_CNF_OWN_SSID:\n\t\t\t\t/* case CNF_DESIRED_SSID: */\n\t\t\t\tcase CFG_DESIRED_SSID:\n\t\t\t\t\tmemset(lp->NetworkName, 0, sizeof(lp->NetworkName));\n\t\t\t\t\tmemcpy((void *)lp->NetworkName, (void *)&pLtv->u.u8[2], (size_t)pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\n\t\t\t\t\t/* take care of the special network name \"ANY\" case */\n\t\t\t\t\tif ((strlen(&pLtv->u.u8[2]) == 0) ||\n\t\t\t\t\t   (strcmp(&pLtv->u.u8[2], \"ANY\") == 0) ||\n\t\t\t\t\t   (strcmp(&pLtv->u.u8[2], \"any\") == 0)) {\n\t\t\t\t\t\t/* set the SSID_STRCT llen field (u16[0]) to zero, and the\n\t\t\t\t\t\teffectually null the string u8[2] */\n\t\t\t\t\t\tpLtv->u.u16[0] = 0;\n\t\t\t\t\t\tpLtv->u.u8[2]  = 0;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_GROUP_ADDR:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CREATE_IBSS:\n\t\t\t\t\tlp->CreateIBSS  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH:\n\t\t\t\t\tlp->RTSThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL:\n\t\t\t\t\tlp->TxRateControl[0]    = pLtv->u.u16[0];\n\t\t\t\t\tlp->TxRateControl[1]    = pLtv->u.u16[1];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[1]          = CNV_INT_TO_LITTLE(pLtv->u.u16[1]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_PROMISCUOUS_MODE:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\t/* case CFG_WAKE_ON_LAN: */\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n#if 1 /* ;? #if (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/* ;?should we restore this to allow smaller memory footprint */\n\t\t\t\tcase CFG_RTS_THRH0:\n\t\t\t\t\tlp->RTSThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL0:\n/*;?no idea what this should be, get going so comment it out\t\t\t\t\tlp->TxRateControl   = pLtv->u.u16[0];*/\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef USE_WDS\n\t\t\t\tcase CFG_RTS_THRH1:\n\t\t\t\t\tlp->wds_port[0].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH2:\n\t\t\t\t\tlp->wds_port[1].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH3:\n\t\t\t\t\tlp->wds_port[2].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH4:\n\t\t\t\t\tlp->wds_port[3].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH5:\n\t\t\t\t\tlp->wds_port[4].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH6:\n\t\t\t\t\tlp->wds_port[5].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_6;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL1:\n\t\t\t\t\tlp->wds_port[0].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL2:\n\t\t\t\t\tlp->wds_port[1].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL3:\n\t\t\t\t\tlp->wds_port[2].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL4:\n\t\t\t\t\tlp->wds_port[3].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL5:\n\t\t\t\t\tlp->wds_port[4].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL6:\n\t\t\t\t\tlp->wds_port[5].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_6;\n\t\t\t\t\tbreak;\n#endif  /* USE_WDS */\n#endif  /* (HCF_TYPE) & HCF_TYPE_AP */\n\n\t\t\t\tcase CFG_DEFAULT_KEYS:\n\t\t\t\t\t{\n\t\t\t\t\t\tCFG_DEFAULT_KEYS_STRCT *pKeys = (CFG_DEFAULT_KEYS_STRCT *)pLtv;\n\n\t\t\t\t\t\tpKeys->key[0].len = CNV_INT_TO_LITTLE(pKeys->key[0].len);\n\t\t\t\t\t\tpKeys->key[1].len = CNV_INT_TO_LITTLE(pKeys->key[1].len);\n\t\t\t\t\t\tpKeys->key[2].len = CNV_INT_TO_LITTLE(pKeys->key[2].len);\n\t\t\t\t\t\tpKeys->key[3].len = CNV_INT_TO_LITTLE(pKeys->key[3].len);\n\n\t\t\t\t\t\tmemcpy((void *)&(lp->DefaultKeys), (void *)pKeys,\n\t\t\t\t\t\t\t\tsizeof(CFG_DEFAULT_KEYS_STRCT));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_KEY_ID:\n\t\t\t\t\tlp->TransmitKeyID   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_SCAN_SSID:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TICK_TIME:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\t/* these RIDS are Info RIDs, and should they be allowed for puts??? */\n\t\t\t\tcase CFG_MAX_LOAD_TIME:\n\t\t\t\tcase CFG_DL_BUF:\n\t\t\t\t/* case CFG_HSI_SUP_RANGE: */\n\t\t\t\tcase CFG_NIC_SERIAL_NUMBER:\n\t\t\t\tcase CFG_NIC_IDENTITY:\n\t\t\t\tcase CFG_NIC_MFI_SUP_RANGE:\n\t\t\t\tcase CFG_NIC_CFI_SUP_RANGE:\n\t\t\t\tcase CFG_NIC_TEMP_TYPE:\n\t\t\t\tcase CFG_NIC_PROFILE:\n\t\t\t\tcase CFG_FW_IDENTITY:\n\t\t\t\tcase CFG_FW_SUP_RANGE:\n\t\t\t\tcase CFG_MFI_ACT_RANGES_STA:\n\t\t\t\tcase CFG_CFI_ACT_RANGES_STA:\n\t\t\t\tcase CFG_PORT_STAT:\n\t\t\t\tcase CFG_CUR_SSID:\n\t\t\t\tcase CFG_CUR_BSSID:\n\t\t\t\tcase CFG_COMMS_QUALITY:\n\t\t\t\tcase CFG_CUR_TX_RATE:\n\t\t\t\tcase CFG_CUR_BEACON_INTERVAL:\n\t\t\t\tcase CFG_CUR_SCALE_THRH:\n\t\t\t\tcase CFG_PROTOCOL_RSP_TIME:\n\t\t\t\tcase CFG_CUR_SHORT_RETRY_LIMIT:\n\t\t\t\tcase CFG_CUR_LONG_RETRY_LIMIT:\n\t\t\t\tcase CFG_MAX_TX_LIFETIME:\n\t\t\t\tcase CFG_MAX_RX_LIFETIME:\n\t\t\t\tcase CFG_CF_POLLABLE:\n\t\t\t\tcase CFG_AUTHENTICATION_ALGORITHMS:\n\t\t\t\tcase CFG_PRIVACY_OPT_IMPLEMENTED:\n\t\t\t\t/* case CFG_CURRENT_REMOTE_RATES: */\n\t\t\t\t/* case CFG_CURRENT_USED_RATES: */\n\t\t\t\t/* case CFG_CURRENT_SYSTEM_SCALE: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE1: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE2: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE3: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE4: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE5: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE6: */\n\t\t\t\tcase CFG_NIC_MAC_ADDR:\n\t\t\t\tcase CFG_PCF_INFO:\n\t\t\t\t/* case CFG_CURRENT_COUNTRY_INFO: */\n\t\t\t\tcase CFG_PHY_TYPE:\n\t\t\t\tcase CFG_CUR_CHANNEL:\n\t\t\t\t/* case CFG_CURRENT_POWER_STATE: */\n\t\t\t\t/* case CFG_CCAMODE: */\n\t\t\t\tcase CFG_SUPPORTED_DATA_RATES:\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_AP_MODE:\n/*;?\t\t\t\tlp->DownloadFirmware = (pLtv->u.u16[0]) + 1; */\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"set CFG_AP_MODE no longer supported\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_ENCRYPT_STRING:\n\t\t\t\t\t/* TODO: ENDIAN TRANSLATION HERE??? */\n\t\t\t\t\tmemset(lp->szEncryption, 0, sizeof(lp->szEncryption));\n\t\t\t\t\tmemcpy((void *)lp->szEncryption,  (void *)&pLtv->u.u8[0],\n\t\t\t\t\t\t\t(pLtv->len * sizeof(hcf_16)));\n\t\t\t\t\twl_wep_decode(CRYPT_CODE, &sEncryption,\n\t\t\t\t\t\t\t\t    lp->szEncryption);\n\n\t\t\t\t\t/* the Linux driver likes to use 1-4 for the key IDs, and then\n\t\t\t\t\tconvert to 0-3 when sending to the card.  The Windows code\n\t\t\t\t\tbase used 0-3 in the API DLL, which was ported to Linux.  For\n\t\t\t\t\tthe sake of the user experience, we decided to keep 0-3 as the\n\t\t\t\t\tnumbers used in the DLL; and will perform the +1 conversion here.\n\t\t\t\t\tWe could have converted  the entire Linux driver, but this is\n\t\t\t\t\tless obtrusive.  This may be a \"todo\" to convert the whole driver */\n\t\t\t\t\tlp->TransmitKeyID    = sEncryption.wTxKeyID + 1;\n\t\t\t\t\tlp->EnableEncryption = sEncryption.wEnabled;\n\n\t\t\t\t\tmemcpy(&lp->DefaultKeys, &sEncryption.EncStr,\n\t\t\t\t\t\t\tsizeof(CFG_DEFAULT_KEYS_STRCT));\n\t\t\t\t\tbreak;\n\t\t\t\t/*case CFG_COUNTRY_STRING:\n\t\t\t\t\tmemset(lp->countryString, 0, sizeof(lp->countryString));\n\t\t\t\t\tmemcpy((void *)lp->countryString, (void *)&pLtv->u.u8[2], (size_t)pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t*/\n\n\t\t\t\tcase CFG_DRIVER_ENABLE:\n\t\t\t\t\tlp->driverEnable    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_WOLAS_ENABLE:\n\t\t\t\t\tlp->wolasEnable = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_SET_WPA_AUTH_KEY_MGMT_SUITE:\n\t\t\t\t\tlp->AuthKeyMgmtSuite = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_DISASSOCIATE_ADDR:\n\t\t\t\t\tpLtv->u.u16[ETH_ALEN / 2] = CNV_INT_TO_LITTLE(pLtv->u.u16[ETH_ALEN / 2]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_ADD_TKIP_DEFAULT_KEY:\n\t\t\t\tcase CFG_REMOVE_TKIP_DEFAULT_KEY:\n\t\t\t\t\t/* Endian convert the Tx Key Information */\n\t\t\t\t\tpLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_ADD_TKIP_MAPPED_KEY:\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_REMOVE_TKIP_MAPPED_KEY:\n\t\t\t\t\tbreak;\n\t\t\t\t/* some RIDs just can't be put */\n\t\t\t\tcase CFG_MB_INFO:\n\t\t\t\tcase CFG_IFB:\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* This code will prevent Static Configuration Entities from\n\t\t\t\t   being sent to the card, as they require a call to\n\t\t\t\t   UIL_ACT_APPLY to take effect. Dynamic Entities will be sent\n\t\t\t\t   immediately */\n\t\t\t\tswitch (pLtv->typ) {\n\t\t\t\tcase CFG_CNF_PORT_TYPE:\n\t\t\t\tcase CFG_CNF_OWN_MAC_ADDR:\n\t\t\t\tcase CFG_CNF_OWN_CHANNEL:\n\t\t\t\tcase CFG_CNF_OWN_SSID:\n\t\t\t\tcase CFG_CNF_OWN_ATIM_WINDOW:\n\t\t\t\tcase CFG_CNF_SYSTEM_SCALE:\n\t\t\t\tcase CFG_CNF_MAX_DATA_LEN:\n\t\t\t\tcase CFG_CNF_PM_ENABLED:\n\t\t\t\tcase CFG_CNF_MCAST_RX:\n\t\t\t\tcase CFG_CNF_MAX_SLEEP_DURATION:\n\t\t\t\tcase CFG_CNF_HOLDOVER_DURATION:\n\t\t\t\tcase CFG_CNF_OWN_NAME:\n\t\t\t\tcase CFG_CNF_LOAD_BALANCING:\n\t\t\t\tcase CFG_CNF_MEDIUM_DISTRIBUTION:\n#ifdef WARP\n\t\t\t\tcase CFG_CNF_TX_POW_LVL:\n\t\t\t\tcase CFG_CNF_CONNECTION_CNTL:\n\t\t\t\t/*case CFG_PROBE_DATA_RATE: */\n#endif /* HERMES25 */\n#if 1 /*;? (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/*;?should we restore this to allow smaller memory footprint */\n\t\t\t\tcase CFG_CNF_OWN_DTIM_PERIOD:\n#ifdef WARP\n\t\t\t\tcase CFG_CNF_OWN_BEACON_INTERVAL:                    /* Own Beacon Interval */\n#endif /* WARP */\n#ifdef USE_WDS\n\t\t\t\tcase CFG_CNF_WDS_ADDR1:\n\t\t\t\tcase CFG_CNF_WDS_ADDR2:\n\t\t\t\tcase CFG_CNF_WDS_ADDR3:\n\t\t\t\tcase CFG_CNF_WDS_ADDR4:\n\t\t\t\tcase CFG_CNF_WDS_ADDR5:\n\t\t\t\tcase CFG_CNF_WDS_ADDR6:\n#endif\n\t\t\t\tcase CFG_CNF_MCAST_PM_BUF:\n\t\t\t\tcase CFG_CNF_REJECT_ANY:\n#endif\n\n\t\t\t\tcase CFG_CNF_ENCRYPTION:\n\t\t\t\tcase CFG_CNF_AUTHENTICATION:\n#if 1 /* ;? (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/* ;?should we restore this to allow smaller memory footprint */\n\n\t\t\t\tcase CFG_CNF_EXCL_UNENCRYPTED:\n\t\t\t\tcase CFG_CNF_MCAST_RATE:\n\t\t\t\tcase CFG_CNF_INTRA_BSS_RELAY:\n#endif\n\n\t\t\t\tcase CFG_CNF_MICRO_WAVE:\n\t\t\t\t/* case CFG_CNF_LOAD_BALANCING: */\n\t\t\t\t/* case CFG_CNF_MEDIUM_DISTRIBUTION: */\n\t\t\t\t/* case CFG_CNF_RX_ALL_GROUP_ADDRESS: */\n\t\t\t\t/* case CFG_CNF_COUNTRY_INFO: */\n\t\t\t\t/* case CFG_COUNTRY_STRING: */\n\t\t\t\tcase CFG_AP_MODE:\n\t\t\t\tcase CFG_ENCRYPT_STRING:\n\t\t\t\t/* case CFG_DRIVER_ENABLE: */\n\t\t\t\tcase CFG_WOLAS_ENABLE:\n\t\t\t\tcase CFG_MB_INFO:\n\t\t\t\tcase CFG_IFB:\n\t\t\t\t\tbreak;\n\t\t\t\t/* Deal with this dynamic MSF RID, as it's required for WPA */\n\t\t\t\tcase CFG_DRIVER_ENABLE:\n\t\t\t\t\tif (lp->driverEnable) {\n\t\t\t\t\t\thcf_cntl(&(lp->hcfCtx), HCF_CNTL_ENABLE | HCF_PORT_0);\n\t\t\t\t\t\thcf_cntl(&(lp->hcfCtx), HCF_CNTL_CONNECT);\n\t\t\t\t\t} else {\n\t\t\t\t\t\thcf_cntl(&(lp->hcfCtx), HCF_CNTL_DISABLE | HCF_PORT_0);\n\t\t\t\t\t\thcf_cntl(&(lp->hcfCtx), HCF_CNTL_DISCONNECT);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\twl_act_int_off(lp);\n\t\t\t\t\turq->result = hcf_put_info(&(lp->hcfCtx), (LTVP) pLtv);\n\t\t\t\t\twl_act_int_on(lp);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (ltvAllocated)\n\t\t\t\t\tkfree(pLtv);\n\t\t\t} else {\n\t\t\t\turq->result = UIL_FAILURE;\n\t\t\t}\n\t\t} else {\n\t\t\tDBG_ERROR(DbgInfo, \"EPERM\\n\");\n\t\t\turq->result = UIL_FAILURE;\n\t\t\tresult = -EPERM;\n\t\t}\n\t} else {\n\t\tDBG_ERROR(DbgInfo, \"UIL_ERR_WRONG_IFB\\n\");\n\t\turq->result = UIL_ERR_WRONG_IFB;\n\t}\n\n\tDBG_LEAVE(DbgInfo);\n\treturn result;\n} /* wvlan_uil_put_info */",
        "code_after_change": "int wvlan_uil_put_info(struct uilreq *urq, struct wl_private *lp)\n{\n\tint                     result = 0;\n\tltv_t                   *pLtv;\n\tbool_t                  ltvAllocated = FALSE;\n\tENCSTRCT                sEncryption;\n\tsize_t\t\t\tlen;\n\n#ifdef USE_WDS\n\thcf_16                  hcfPort  = HCF_PORT_0;\n#endif  /* USE_WDS */\n\t/*------------------------------------------------------------------------*/\n\tDBG_FUNC(\"wvlan_uil_put_info\");\n\tDBG_ENTER(DbgInfo);\n\n\n\tif (urq->hcfCtx == &(lp->hcfCtx)) {\n\t\tif (capable(CAP_NET_ADMIN)) {\n\t\t\tif ((urq->data != NULL) && (urq->len != 0)) {\n\t\t\t\t/* Make sure that we have at least a command and length to send. */\n\t\t\t\tif (urq->len < (sizeof(hcf_16) * 2)) {\n\t\t\t\t\turq->len = sizeof(lp->ltvRecord);\n\t\t\t\t\turq->result = UIL_ERR_LEN;\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"No Length/Type in LTV!!!\\n\");\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"UIL_ERR_LEN\\n\");\n\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\t/* Verify the user buffer */\n\t\t\t\tresult = verify_area(VERIFY_READ, urq->data, urq->len);\n\t\t\t\tif (result != 0) {\n\t\t\t\t\turq->result = UIL_FAILURE;\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"verify_area(), VERIFY_READ FAILED\\n\");\n\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\t/* Get only the command and length information. */\n\t\t\t\tcopy_from_user(&(lp->ltvRecord), urq->data, sizeof(hcf_16) * 2);\n\n\t\t\t\t/* Make sure the incoming LTV record length is within the bounds of the\n\t\t\t\t   IOCTL length */\n\t\t\t\tif (((lp->ltvRecord.len + 1) * sizeof(hcf_16)) > urq->len) {\n\t\t\t\t\turq->len = sizeof(lp->ltvRecord);\n\t\t\t\t\turq->result = UIL_ERR_LEN;\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"UIL_ERR_LEN\\n\");\n\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\t/* If the requested length is greater than the size of our local\n\t\t\t\t   LTV record, try to allocate it from the kernel stack.\n\t\t\t\t   Otherwise, we just use our local LTV record. */\n\t\t\t\tif (urq->len > sizeof(lp->ltvRecord)) {\n\t\t\t\t\tpLtv = kmalloc(urq->len, GFP_KERNEL);\n\t\t\t\t\tif (pLtv != NULL) {\n\t\t\t\t\t\tltvAllocated = TRUE;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tDBG_ERROR(DbgInfo, \"Alloc FAILED\\n\");\n\t\t\t\t\t\turq->len = sizeof(lp->ltvRecord);\n\t\t\t\t\t\turq->result = UIL_ERR_LEN;\n\t\t\t\t\t\tresult = -ENOMEM;\n\t\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpLtv = &(lp->ltvRecord);\n\t\t\t\t}\n\n\t\t\t\t/* Copy the data from the user's buffer into the local LTV\n\t\t\t\t   record data area. */\n\t\t\t\tcopy_from_user(pLtv, urq->data, urq->len);\n\n\n\t\t\t\t/* We need to snoop the commands to see if there is anything we\n\t\t\t\t   need to store for the purposes of a reset or start/stop\n\t\t\t\t   sequence. Perform endian translation as needed */\n\t\t\t\tswitch (pLtv->typ) {\n\t\t\t\tcase CFG_CNF_PORT_TYPE:\n\t\t\t\t\tlp->PortType    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_OWN_MAC_ADDR:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_OWN_CHANNEL:\n\t\t\t\t\tlp->Channel     = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t/* CFG_CNF_OWN_SSID currently same as CNF_DESIRED_SSID. Do we\n\t\t\t\t   need separate storage for this? */\n\t\t\t\t/* case CFG_CNF_OWN_SSID: */\n\t\t\t\tcase CFG_CNF_OWN_ATIM_WINDOW:\n\t\t\t\t\tlp->atimWindow  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_SYSTEM_SCALE:\n\t\t\t\t\tlp->DistanceBetweenAPs  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\n\t\t\t\tcase CFG_CNF_MAX_DATA_LEN:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based\n\t\t\t\t\t   on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_PM_ENABLED:\n\t\t\t\t\tlp->PMEnabled   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_MCAST_RX:\n\t\t\t\t\tlp->MulticastReceive    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_MAX_SLEEP_DURATION:\n\t\t\t\t\tlp->MaxSleepDuration    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_HOLDOVER_DURATION:\n\t\t\t\t\tlp->holdoverDuration    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_OWN_NAME:\n\t\t\t\t\tmemset(lp->StationName, 0, sizeof(lp->StationName));\n\t\t\t\t\tlen = min_t(size_t, pLtv->u.u16[0], sizeof(lp->StationName));\n\t\t\t\t\tstrlcpy(lp->StationName, &pLtv->u.u8[2], len);\n\t\t\t\t\tpLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_LOAD_BALANCING:\n\t\t\t\t\tlp->loadBalancing       = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_MEDIUM_DISTRIBUTION:\n\t\t\t\t\tlp->mediumDistribution  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef WARP\n\t\t\t\tcase CFG_CNF_TX_POW_LVL:\n\t\t\t\t\tlp->txPowLevel          = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t/* case CFG_CNF_SHORT_RETRY_LIMIT: */ /* Short Retry Limit */\n\t\t\t\t/* case 0xFC33: */   /* Long Retry Limit */\n\t\t\t\tcase CFG_SUPPORTED_RATE_SET_CNTL:        /* Supported Rate Set Control */\n\t\t\t\t\tlp->srsc[0]             = pLtv->u.u16[0];\n\t\t\t\t\tlp->srsc[1]             = pLtv->u.u16[1];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[1]          = CNV_INT_TO_LITTLE(pLtv->u.u16[1]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_BASIC_RATE_SET_CNTL:        /* Basic Rate Set Control */\n\t\t\t\t\tlp->brsc[0]             = pLtv->u.u16[0];\n\t\t\t\t\tlp->brsc[1]             = pLtv->u.u16[1];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[1]          = CNV_INT_TO_LITTLE(pLtv->u.u16[1]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_CONNECTION_CNTL:\n\t\t\t\t\tlp->connectionControl   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t/* case CFG_PROBE_DATA_RATE: */\n#endif  /* HERMES25 */\n\n#if 1 /* ;? (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/* ;?should we restore this to allow smaller memory footprint */\n\n\t\t\t\tcase CFG_CNF_OWN_DTIM_PERIOD:\n\t\t\t\t\tlp->DTIMPeriod  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef WARP\n\t\t\t\tcase CFG_CNF_OWN_BEACON_INTERVAL:        /* Own Beacon Interval */\n\t\t\t\t\tlp->ownBeaconInterval   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#endif /* WARP */\n\t\t\t\tcase CFG_COEXISTENSE_BEHAVIOUR:         /* Coexistence behavior */\n\t\t\t\t\tlp->coexistence         = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef USE_WDS\n\t\t\t\tcase CFG_CNF_WDS_ADDR1:\n\t\t\t\t\tmemcpy(&lp->wds_port[0].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR2:\n\t\t\t\t\tmemcpy(&lp->wds_port[1].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR3:\n\t\t\t\t\tmemcpy(&lp->wds_port[2].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR4:\n\t\t\t\t\tmemcpy(&lp->wds_port[3].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR5:\n\t\t\t\t\tmemcpy(&lp->wds_port[4].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR6:\n\t\t\t\t\tmemcpy(&lp->wds_port[5].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_6;\n\t\t\t\t\tbreak;\n#endif  /* USE_WDS */\n\n\t\t\t\tcase CFG_CNF_MCAST_PM_BUF:\n\t\t\t\t\tlp->multicastPMBuffering    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_REJECT_ANY:\n\t\t\t\t\tlp->RejectAny   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#endif\n\n\t\t\t\tcase CFG_CNF_ENCRYPTION:\n\t\t\t\t\tlp->EnableEncryption    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_AUTHENTICATION:\n\t\t\t\t\tlp->authentication  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#if 1 /* ;? (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/* ;?should we restore this to allow smaller memory footprint */\n\n\t\t\t\t/* case CFG_CNF_EXCL_UNENCRYPTED:\n\t\t\t\t\tlp->ExcludeUnencrypted  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak; */\n\t\t\t\tcase CFG_CNF_MCAST_RATE:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_INTRA_BSS_RELAY:\n\t\t\t\t\tlp->intraBSSRelay   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#endif\n\n\t\t\t\tcase CFG_CNF_MICRO_WAVE:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\t/*case CFG_CNF_LOAD_BALANCING:*/\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n\t\t\t\t/* case CFG_CNF_MEDIUM_DISTRIBUTION: */\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n\t\t\t\t/* case CFG_CNF_RX_ALL_GROUP_ADDRESS: */\n\t\t\t\t\t/*  TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n\t\t\t\t/* case CFG_CNF_COUNTRY_INFO: */\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n\t\t\t\tcase CFG_CNF_OWN_SSID:\n\t\t\t\t/* case CNF_DESIRED_SSID: */\n\t\t\t\tcase CFG_DESIRED_SSID:\n\t\t\t\t\tmemset(lp->NetworkName, 0, sizeof(lp->NetworkName));\n\t\t\t\t\tmemcpy((void *)lp->NetworkName, (void *)&pLtv->u.u8[2], (size_t)pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\n\t\t\t\t\t/* take care of the special network name \"ANY\" case */\n\t\t\t\t\tif ((strlen(&pLtv->u.u8[2]) == 0) ||\n\t\t\t\t\t   (strcmp(&pLtv->u.u8[2], \"ANY\") == 0) ||\n\t\t\t\t\t   (strcmp(&pLtv->u.u8[2], \"any\") == 0)) {\n\t\t\t\t\t\t/* set the SSID_STRCT llen field (u16[0]) to zero, and the\n\t\t\t\t\t\teffectually null the string u8[2] */\n\t\t\t\t\t\tpLtv->u.u16[0] = 0;\n\t\t\t\t\t\tpLtv->u.u8[2]  = 0;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_GROUP_ADDR:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CREATE_IBSS:\n\t\t\t\t\tlp->CreateIBSS  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH:\n\t\t\t\t\tlp->RTSThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL:\n\t\t\t\t\tlp->TxRateControl[0]    = pLtv->u.u16[0];\n\t\t\t\t\tlp->TxRateControl[1]    = pLtv->u.u16[1];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[1]          = CNV_INT_TO_LITTLE(pLtv->u.u16[1]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_PROMISCUOUS_MODE:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\t/* case CFG_WAKE_ON_LAN: */\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n#if 1 /* ;? #if (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/* ;?should we restore this to allow smaller memory footprint */\n\t\t\t\tcase CFG_RTS_THRH0:\n\t\t\t\t\tlp->RTSThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL0:\n/*;?no idea what this should be, get going so comment it out\t\t\t\t\tlp->TxRateControl   = pLtv->u.u16[0];*/\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef USE_WDS\n\t\t\t\tcase CFG_RTS_THRH1:\n\t\t\t\t\tlp->wds_port[0].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH2:\n\t\t\t\t\tlp->wds_port[1].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH3:\n\t\t\t\t\tlp->wds_port[2].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH4:\n\t\t\t\t\tlp->wds_port[3].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH5:\n\t\t\t\t\tlp->wds_port[4].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH6:\n\t\t\t\t\tlp->wds_port[5].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_6;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL1:\n\t\t\t\t\tlp->wds_port[0].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL2:\n\t\t\t\t\tlp->wds_port[1].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL3:\n\t\t\t\t\tlp->wds_port[2].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL4:\n\t\t\t\t\tlp->wds_port[3].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL5:\n\t\t\t\t\tlp->wds_port[4].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL6:\n\t\t\t\t\tlp->wds_port[5].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_6;\n\t\t\t\t\tbreak;\n#endif  /* USE_WDS */\n#endif  /* (HCF_TYPE) & HCF_TYPE_AP */\n\n\t\t\t\tcase CFG_DEFAULT_KEYS:\n\t\t\t\t\t{\n\t\t\t\t\t\tCFG_DEFAULT_KEYS_STRCT *pKeys = (CFG_DEFAULT_KEYS_STRCT *)pLtv;\n\n\t\t\t\t\t\tpKeys->key[0].len = CNV_INT_TO_LITTLE(pKeys->key[0].len);\n\t\t\t\t\t\tpKeys->key[1].len = CNV_INT_TO_LITTLE(pKeys->key[1].len);\n\t\t\t\t\t\tpKeys->key[2].len = CNV_INT_TO_LITTLE(pKeys->key[2].len);\n\t\t\t\t\t\tpKeys->key[3].len = CNV_INT_TO_LITTLE(pKeys->key[3].len);\n\n\t\t\t\t\t\tmemcpy((void *)&(lp->DefaultKeys), (void *)pKeys,\n\t\t\t\t\t\t\t\tsizeof(CFG_DEFAULT_KEYS_STRCT));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_KEY_ID:\n\t\t\t\t\tlp->TransmitKeyID   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_SCAN_SSID:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TICK_TIME:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\t/* these RIDS are Info RIDs, and should they be allowed for puts??? */\n\t\t\t\tcase CFG_MAX_LOAD_TIME:\n\t\t\t\tcase CFG_DL_BUF:\n\t\t\t\t/* case CFG_HSI_SUP_RANGE: */\n\t\t\t\tcase CFG_NIC_SERIAL_NUMBER:\n\t\t\t\tcase CFG_NIC_IDENTITY:\n\t\t\t\tcase CFG_NIC_MFI_SUP_RANGE:\n\t\t\t\tcase CFG_NIC_CFI_SUP_RANGE:\n\t\t\t\tcase CFG_NIC_TEMP_TYPE:\n\t\t\t\tcase CFG_NIC_PROFILE:\n\t\t\t\tcase CFG_FW_IDENTITY:\n\t\t\t\tcase CFG_FW_SUP_RANGE:\n\t\t\t\tcase CFG_MFI_ACT_RANGES_STA:\n\t\t\t\tcase CFG_CFI_ACT_RANGES_STA:\n\t\t\t\tcase CFG_PORT_STAT:\n\t\t\t\tcase CFG_CUR_SSID:\n\t\t\t\tcase CFG_CUR_BSSID:\n\t\t\t\tcase CFG_COMMS_QUALITY:\n\t\t\t\tcase CFG_CUR_TX_RATE:\n\t\t\t\tcase CFG_CUR_BEACON_INTERVAL:\n\t\t\t\tcase CFG_CUR_SCALE_THRH:\n\t\t\t\tcase CFG_PROTOCOL_RSP_TIME:\n\t\t\t\tcase CFG_CUR_SHORT_RETRY_LIMIT:\n\t\t\t\tcase CFG_CUR_LONG_RETRY_LIMIT:\n\t\t\t\tcase CFG_MAX_TX_LIFETIME:\n\t\t\t\tcase CFG_MAX_RX_LIFETIME:\n\t\t\t\tcase CFG_CF_POLLABLE:\n\t\t\t\tcase CFG_AUTHENTICATION_ALGORITHMS:\n\t\t\t\tcase CFG_PRIVACY_OPT_IMPLEMENTED:\n\t\t\t\t/* case CFG_CURRENT_REMOTE_RATES: */\n\t\t\t\t/* case CFG_CURRENT_USED_RATES: */\n\t\t\t\t/* case CFG_CURRENT_SYSTEM_SCALE: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE1: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE2: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE3: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE4: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE5: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE6: */\n\t\t\t\tcase CFG_NIC_MAC_ADDR:\n\t\t\t\tcase CFG_PCF_INFO:\n\t\t\t\t/* case CFG_CURRENT_COUNTRY_INFO: */\n\t\t\t\tcase CFG_PHY_TYPE:\n\t\t\t\tcase CFG_CUR_CHANNEL:\n\t\t\t\t/* case CFG_CURRENT_POWER_STATE: */\n\t\t\t\t/* case CFG_CCAMODE: */\n\t\t\t\tcase CFG_SUPPORTED_DATA_RATES:\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_AP_MODE:\n/*;?\t\t\t\tlp->DownloadFirmware = (pLtv->u.u16[0]) + 1; */\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"set CFG_AP_MODE no longer supported\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_ENCRYPT_STRING:\n\t\t\t\t\t/* TODO: ENDIAN TRANSLATION HERE??? */\n\t\t\t\t\tmemset(lp->szEncryption, 0, sizeof(lp->szEncryption));\n\t\t\t\t\tmemcpy((void *)lp->szEncryption,  (void *)&pLtv->u.u8[0],\n\t\t\t\t\t\t\t(pLtv->len * sizeof(hcf_16)));\n\t\t\t\t\twl_wep_decode(CRYPT_CODE, &sEncryption,\n\t\t\t\t\t\t\t\t    lp->szEncryption);\n\n\t\t\t\t\t/* the Linux driver likes to use 1-4 for the key IDs, and then\n\t\t\t\t\tconvert to 0-3 when sending to the card.  The Windows code\n\t\t\t\t\tbase used 0-3 in the API DLL, which was ported to Linux.  For\n\t\t\t\t\tthe sake of the user experience, we decided to keep 0-3 as the\n\t\t\t\t\tnumbers used in the DLL; and will perform the +1 conversion here.\n\t\t\t\t\tWe could have converted  the entire Linux driver, but this is\n\t\t\t\t\tless obtrusive.  This may be a \"todo\" to convert the whole driver */\n\t\t\t\t\tlp->TransmitKeyID    = sEncryption.wTxKeyID + 1;\n\t\t\t\t\tlp->EnableEncryption = sEncryption.wEnabled;\n\n\t\t\t\t\tmemcpy(&lp->DefaultKeys, &sEncryption.EncStr,\n\t\t\t\t\t\t\tsizeof(CFG_DEFAULT_KEYS_STRCT));\n\t\t\t\t\tbreak;\n\t\t\t\t/*case CFG_COUNTRY_STRING:\n\t\t\t\t\tmemset(lp->countryString, 0, sizeof(lp->countryString));\n\t\t\t\t\tmemcpy((void *)lp->countryString, (void *)&pLtv->u.u8[2], (size_t)pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t*/\n\n\t\t\t\tcase CFG_DRIVER_ENABLE:\n\t\t\t\t\tlp->driverEnable    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_WOLAS_ENABLE:\n\t\t\t\t\tlp->wolasEnable = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_SET_WPA_AUTH_KEY_MGMT_SUITE:\n\t\t\t\t\tlp->AuthKeyMgmtSuite = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_DISASSOCIATE_ADDR:\n\t\t\t\t\tpLtv->u.u16[ETH_ALEN / 2] = CNV_INT_TO_LITTLE(pLtv->u.u16[ETH_ALEN / 2]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_ADD_TKIP_DEFAULT_KEY:\n\t\t\t\tcase CFG_REMOVE_TKIP_DEFAULT_KEY:\n\t\t\t\t\t/* Endian convert the Tx Key Information */\n\t\t\t\t\tpLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_ADD_TKIP_MAPPED_KEY:\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_REMOVE_TKIP_MAPPED_KEY:\n\t\t\t\t\tbreak;\n\t\t\t\t/* some RIDs just can't be put */\n\t\t\t\tcase CFG_MB_INFO:\n\t\t\t\tcase CFG_IFB:\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* This code will prevent Static Configuration Entities from\n\t\t\t\t   being sent to the card, as they require a call to\n\t\t\t\t   UIL_ACT_APPLY to take effect. Dynamic Entities will be sent\n\t\t\t\t   immediately */\n\t\t\t\tswitch (pLtv->typ) {\n\t\t\t\tcase CFG_CNF_PORT_TYPE:\n\t\t\t\tcase CFG_CNF_OWN_MAC_ADDR:\n\t\t\t\tcase CFG_CNF_OWN_CHANNEL:\n\t\t\t\tcase CFG_CNF_OWN_SSID:\n\t\t\t\tcase CFG_CNF_OWN_ATIM_WINDOW:\n\t\t\t\tcase CFG_CNF_SYSTEM_SCALE:\n\t\t\t\tcase CFG_CNF_MAX_DATA_LEN:\n\t\t\t\tcase CFG_CNF_PM_ENABLED:\n\t\t\t\tcase CFG_CNF_MCAST_RX:\n\t\t\t\tcase CFG_CNF_MAX_SLEEP_DURATION:\n\t\t\t\tcase CFG_CNF_HOLDOVER_DURATION:\n\t\t\t\tcase CFG_CNF_OWN_NAME:\n\t\t\t\tcase CFG_CNF_LOAD_BALANCING:\n\t\t\t\tcase CFG_CNF_MEDIUM_DISTRIBUTION:\n#ifdef WARP\n\t\t\t\tcase CFG_CNF_TX_POW_LVL:\n\t\t\t\tcase CFG_CNF_CONNECTION_CNTL:\n\t\t\t\t/*case CFG_PROBE_DATA_RATE: */\n#endif /* HERMES25 */\n#if 1 /*;? (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/*;?should we restore this to allow smaller memory footprint */\n\t\t\t\tcase CFG_CNF_OWN_DTIM_PERIOD:\n#ifdef WARP\n\t\t\t\tcase CFG_CNF_OWN_BEACON_INTERVAL:                    /* Own Beacon Interval */\n#endif /* WARP */\n#ifdef USE_WDS\n\t\t\t\tcase CFG_CNF_WDS_ADDR1:\n\t\t\t\tcase CFG_CNF_WDS_ADDR2:\n\t\t\t\tcase CFG_CNF_WDS_ADDR3:\n\t\t\t\tcase CFG_CNF_WDS_ADDR4:\n\t\t\t\tcase CFG_CNF_WDS_ADDR5:\n\t\t\t\tcase CFG_CNF_WDS_ADDR6:\n#endif\n\t\t\t\tcase CFG_CNF_MCAST_PM_BUF:\n\t\t\t\tcase CFG_CNF_REJECT_ANY:\n#endif\n\n\t\t\t\tcase CFG_CNF_ENCRYPTION:\n\t\t\t\tcase CFG_CNF_AUTHENTICATION:\n#if 1 /* ;? (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/* ;?should we restore this to allow smaller memory footprint */\n\n\t\t\t\tcase CFG_CNF_EXCL_UNENCRYPTED:\n\t\t\t\tcase CFG_CNF_MCAST_RATE:\n\t\t\t\tcase CFG_CNF_INTRA_BSS_RELAY:\n#endif\n\n\t\t\t\tcase CFG_CNF_MICRO_WAVE:\n\t\t\t\t/* case CFG_CNF_LOAD_BALANCING: */\n\t\t\t\t/* case CFG_CNF_MEDIUM_DISTRIBUTION: */\n\t\t\t\t/* case CFG_CNF_RX_ALL_GROUP_ADDRESS: */\n\t\t\t\t/* case CFG_CNF_COUNTRY_INFO: */\n\t\t\t\t/* case CFG_COUNTRY_STRING: */\n\t\t\t\tcase CFG_AP_MODE:\n\t\t\t\tcase CFG_ENCRYPT_STRING:\n\t\t\t\t/* case CFG_DRIVER_ENABLE: */\n\t\t\t\tcase CFG_WOLAS_ENABLE:\n\t\t\t\tcase CFG_MB_INFO:\n\t\t\t\tcase CFG_IFB:\n\t\t\t\t\tbreak;\n\t\t\t\t/* Deal with this dynamic MSF RID, as it's required for WPA */\n\t\t\t\tcase CFG_DRIVER_ENABLE:\n\t\t\t\t\tif (lp->driverEnable) {\n\t\t\t\t\t\thcf_cntl(&(lp->hcfCtx), HCF_CNTL_ENABLE | HCF_PORT_0);\n\t\t\t\t\t\thcf_cntl(&(lp->hcfCtx), HCF_CNTL_CONNECT);\n\t\t\t\t\t} else {\n\t\t\t\t\t\thcf_cntl(&(lp->hcfCtx), HCF_CNTL_DISABLE | HCF_PORT_0);\n\t\t\t\t\t\thcf_cntl(&(lp->hcfCtx), HCF_CNTL_DISCONNECT);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\twl_act_int_off(lp);\n\t\t\t\t\turq->result = hcf_put_info(&(lp->hcfCtx), (LTVP) pLtv);\n\t\t\t\t\twl_act_int_on(lp);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (ltvAllocated)\n\t\t\t\t\tkfree(pLtv);\n\t\t\t} else {\n\t\t\t\turq->result = UIL_FAILURE;\n\t\t\t}\n\t\t} else {\n\t\t\tDBG_ERROR(DbgInfo, \"EPERM\\n\");\n\t\t\turq->result = UIL_FAILURE;\n\t\t\tresult = -EPERM;\n\t\t}\n\t} else {\n\t\tDBG_ERROR(DbgInfo, \"UIL_ERR_WRONG_IFB\\n\");\n\t\turq->result = UIL_ERR_WRONG_IFB;\n\t}\n\n\tDBG_LEAVE(DbgInfo);\n\treturn result;\n} /* wvlan_uil_put_info */",
        "patch": "--- code before\n+++ code after\n@@ -4,6 +4,7 @@\n \tltv_t                   *pLtv;\n \tbool_t                  ltvAllocated = FALSE;\n \tENCSTRCT                sEncryption;\n+\tsize_t\t\t\tlen;\n \n #ifdef USE_WDS\n \thcf_16                  hcfPort  = HCF_PORT_0;\n@@ -120,7 +121,8 @@\n \t\t\t\t\tbreak;\n \t\t\t\tcase CFG_CNF_OWN_NAME:\n \t\t\t\t\tmemset(lp->StationName, 0, sizeof(lp->StationName));\n-\t\t\t\t\tmemcpy((void *)lp->StationName, (void *)&pLtv->u.u8[2], (size_t)pLtv->u.u16[0]);\n+\t\t\t\t\tlen = min_t(size_t, pLtv->u.u16[0], sizeof(lp->StationName));\n+\t\t\t\t\tstrlcpy(lp->StationName, &pLtv->u.u8[2], len);\n \t\t\t\t\tpLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n \t\t\t\t\tbreak;\n \t\t\t\tcase CFG_CNF_LOAD_BALANCING:",
        "function_modified_lines": {
            "added": [
                "\tsize_t\t\t\tlen;",
                "\t\t\t\t\tlen = min_t(size_t, pLtv->u.u16[0], sizeof(lp->StationName));",
                "\t\t\t\t\tstrlcpy(lp->StationName, &pLtv->u.u8[2], len);"
            ],
            "deleted": [
                "\t\t\t\t\tmemcpy((void *)lp->StationName, (void *)&pLtv->u.u8[2], (size_t)pLtv->u.u16[0]);"
            ]
        },
        "cwe": [
            "CWE-119"
        ],
        "cve_description": "Multiple buffer overflows in drivers/staging/wlags49_h2/wl_priv.c in the Linux kernel before 3.12 allow local users to cause a denial of service or possibly have unspecified other impact by leveraging the CAP_NET_ADMIN capability and providing a long station-name string, related to the (1) wvlan_uil_put_info and (2) wvlan_set_station_nickname functions.",
        "id": 324
    },
    {
        "cve_id": "CVE-2016-8633",
        "code_before_change": "static void fwnet_receive_broadcast(struct fw_iso_context *context,\n\t\tu32 cycle, size_t header_length, void *header, void *data)\n{\n\tstruct fwnet_device *dev;\n\tstruct fw_iso_packet packet;\n\t__be16 *hdr_ptr;\n\t__be32 *buf_ptr;\n\tint retval;\n\tu32 length;\n\tu16 source_node_id;\n\tu32 specifier_id;\n\tu32 ver;\n\tunsigned long offset;\n\tunsigned long flags;\n\n\tdev = data;\n\thdr_ptr = header;\n\tlength = be16_to_cpup(hdr_ptr);\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\toffset = dev->rcv_buffer_size * dev->broadcast_rcv_next_ptr;\n\tbuf_ptr = dev->broadcast_rcv_buffer_ptrs[dev->broadcast_rcv_next_ptr++];\n\tif (dev->broadcast_rcv_next_ptr == dev->num_broadcast_rcv_ptrs)\n\t\tdev->broadcast_rcv_next_ptr = 0;\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tspecifier_id =    (be32_to_cpu(buf_ptr[0]) & 0xffff) << 8\n\t\t\t| (be32_to_cpu(buf_ptr[1]) & 0xff000000) >> 24;\n\tver = be32_to_cpu(buf_ptr[1]) & 0xffffff;\n\tsource_node_id = be32_to_cpu(buf_ptr[0]) >> 16;\n\n\tif (specifier_id == IANA_SPECIFIER_ID &&\n\t    (ver == RFC2734_SW_VERSION\n#if IS_ENABLED(CONFIG_IPV6)\n\t     || ver == RFC3146_SW_VERSION\n#endif\n\t    )) {\n\t\tbuf_ptr += 2;\n\t\tlength -= IEEE1394_GASP_HDR_SIZE;\n\t\tfwnet_incoming_packet(dev, buf_ptr, length, source_node_id,\n\t\t\t\t      context->card->generation, true);\n\t}\n\n\tpacket.payload_length = dev->rcv_buffer_size;\n\tpacket.interrupt = 1;\n\tpacket.skip = 0;\n\tpacket.tag = 3;\n\tpacket.sy = 0;\n\tpacket.header_length = IEEE1394_GASP_HDR_SIZE;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\tretval = fw_iso_context_queue(dev->broadcast_rcv_context, &packet,\n\t\t\t\t      &dev->broadcast_rcv_buffer, offset);\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tif (retval >= 0)\n\t\tfw_iso_context_queue_flush(dev->broadcast_rcv_context);\n\telse\n\t\tdev_err(&dev->netdev->dev, \"requeue failed\\n\");\n}",
        "code_after_change": "static void fwnet_receive_broadcast(struct fw_iso_context *context,\n\t\tu32 cycle, size_t header_length, void *header, void *data)\n{\n\tstruct fwnet_device *dev;\n\tstruct fw_iso_packet packet;\n\t__be16 *hdr_ptr;\n\t__be32 *buf_ptr;\n\tint retval;\n\tu32 length;\n\tunsigned long offset;\n\tunsigned long flags;\n\n\tdev = data;\n\thdr_ptr = header;\n\tlength = be16_to_cpup(hdr_ptr);\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\toffset = dev->rcv_buffer_size * dev->broadcast_rcv_next_ptr;\n\tbuf_ptr = dev->broadcast_rcv_buffer_ptrs[dev->broadcast_rcv_next_ptr++];\n\tif (dev->broadcast_rcv_next_ptr == dev->num_broadcast_rcv_ptrs)\n\t\tdev->broadcast_rcv_next_ptr = 0;\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tif (length > IEEE1394_GASP_HDR_SIZE &&\n\t    gasp_specifier_id(buf_ptr) == IANA_SPECIFIER_ID &&\n\t    (gasp_version(buf_ptr) == RFC2734_SW_VERSION\n#if IS_ENABLED(CONFIG_IPV6)\n\t     || gasp_version(buf_ptr) == RFC3146_SW_VERSION\n#endif\n\t    ))\n\t\tfwnet_incoming_packet(dev, buf_ptr + 2,\n\t\t\t\t      length - IEEE1394_GASP_HDR_SIZE,\n\t\t\t\t      gasp_source_id(buf_ptr),\n\t\t\t\t      context->card->generation, true);\n\n\tpacket.payload_length = dev->rcv_buffer_size;\n\tpacket.interrupt = 1;\n\tpacket.skip = 0;\n\tpacket.tag = 3;\n\tpacket.sy = 0;\n\tpacket.header_length = IEEE1394_GASP_HDR_SIZE;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\tretval = fw_iso_context_queue(dev->broadcast_rcv_context, &packet,\n\t\t\t\t      &dev->broadcast_rcv_buffer, offset);\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tif (retval >= 0)\n\t\tfw_iso_context_queue_flush(dev->broadcast_rcv_context);\n\telse\n\t\tdev_err(&dev->netdev->dev, \"requeue failed\\n\");\n}",
        "patch": "--- code before\n+++ code after\n@@ -7,9 +7,6 @@\n \t__be32 *buf_ptr;\n \tint retval;\n \tu32 length;\n-\tu16 source_node_id;\n-\tu32 specifier_id;\n-\tu32 ver;\n \tunsigned long offset;\n \tunsigned long flags;\n \n@@ -26,22 +23,17 @@\n \n \tspin_unlock_irqrestore(&dev->lock, flags);\n \n-\tspecifier_id =    (be32_to_cpu(buf_ptr[0]) & 0xffff) << 8\n-\t\t\t| (be32_to_cpu(buf_ptr[1]) & 0xff000000) >> 24;\n-\tver = be32_to_cpu(buf_ptr[1]) & 0xffffff;\n-\tsource_node_id = be32_to_cpu(buf_ptr[0]) >> 16;\n-\n-\tif (specifier_id == IANA_SPECIFIER_ID &&\n-\t    (ver == RFC2734_SW_VERSION\n+\tif (length > IEEE1394_GASP_HDR_SIZE &&\n+\t    gasp_specifier_id(buf_ptr) == IANA_SPECIFIER_ID &&\n+\t    (gasp_version(buf_ptr) == RFC2734_SW_VERSION\n #if IS_ENABLED(CONFIG_IPV6)\n-\t     || ver == RFC3146_SW_VERSION\n+\t     || gasp_version(buf_ptr) == RFC3146_SW_VERSION\n #endif\n-\t    )) {\n-\t\tbuf_ptr += 2;\n-\t\tlength -= IEEE1394_GASP_HDR_SIZE;\n-\t\tfwnet_incoming_packet(dev, buf_ptr, length, source_node_id,\n+\t    ))\n+\t\tfwnet_incoming_packet(dev, buf_ptr + 2,\n+\t\t\t\t      length - IEEE1394_GASP_HDR_SIZE,\n+\t\t\t\t      gasp_source_id(buf_ptr),\n \t\t\t\t      context->card->generation, true);\n-\t}\n \n \tpacket.payload_length = dev->rcv_buffer_size;\n \tpacket.interrupt = 1;",
        "function_modified_lines": {
            "added": [
                "\tif (length > IEEE1394_GASP_HDR_SIZE &&",
                "\t    gasp_specifier_id(buf_ptr) == IANA_SPECIFIER_ID &&",
                "\t    (gasp_version(buf_ptr) == RFC2734_SW_VERSION",
                "\t     || gasp_version(buf_ptr) == RFC3146_SW_VERSION",
                "\t    ))",
                "\t\tfwnet_incoming_packet(dev, buf_ptr + 2,",
                "\t\t\t\t      length - IEEE1394_GASP_HDR_SIZE,",
                "\t\t\t\t      gasp_source_id(buf_ptr),"
            ],
            "deleted": [
                "\tu16 source_node_id;",
                "\tu32 specifier_id;",
                "\tu32 ver;",
                "\tspecifier_id =    (be32_to_cpu(buf_ptr[0]) & 0xffff) << 8",
                "\t\t\t| (be32_to_cpu(buf_ptr[1]) & 0xff000000) >> 24;",
                "\tver = be32_to_cpu(buf_ptr[1]) & 0xffffff;",
                "\tsource_node_id = be32_to_cpu(buf_ptr[0]) >> 16;",
                "",
                "\tif (specifier_id == IANA_SPECIFIER_ID &&",
                "\t    (ver == RFC2734_SW_VERSION",
                "\t     || ver == RFC3146_SW_VERSION",
                "\t    )) {",
                "\t\tbuf_ptr += 2;",
                "\t\tlength -= IEEE1394_GASP_HDR_SIZE;",
                "\t\tfwnet_incoming_packet(dev, buf_ptr, length, source_node_id,",
                "\t}"
            ]
        },
        "cwe": [
            "CWE-119",
            "CWE-284"
        ],
        "cve_description": "drivers/firewire/net.c in the Linux kernel before 4.8.7, in certain unusual hardware configurations, allows remote attackers to execute arbitrary code via crafted fragmented packets.",
        "id": 1124
    },
    {
        "cve_id": "CVE-2013-2895",
        "code_before_change": "static int logi_dj_recv_send_report(struct dj_receiver_dev *djrcv_dev,\n\t\t\t\t    struct dj_report *dj_report)\n{\n\tstruct hid_device *hdev = djrcv_dev->hdev;\n\tstruct hid_report *report;\n\tstruct hid_report_enum *output_report_enum;\n\tu8 *data = (u8 *)(&dj_report->device_index);\n\tint i;\n\n\toutput_report_enum = &hdev->report_enum[HID_OUTPUT_REPORT];\n\treport = output_report_enum->report_id_hash[REPORT_ID_DJ_SHORT];\n\n\tif (!report) {\n\t\tdev_err(&hdev->dev, \"%s: unable to find dj report\\n\", __func__);\n\t\treturn -ENODEV;\n\t}\n\n\tfor (i = 0; i < report->field[0]->report_count; i++)\n\t\treport->field[0]->value[i] = data[i];\n\n\thid_hw_request(hdev, report, HID_REQ_SET_REPORT);\n\n\treturn 0;\n}",
        "code_after_change": "static int logi_dj_recv_send_report(struct dj_receiver_dev *djrcv_dev,\n\t\t\t\t    struct dj_report *dj_report)\n{\n\tstruct hid_device *hdev = djrcv_dev->hdev;\n\tstruct hid_report *report;\n\tstruct hid_report_enum *output_report_enum;\n\tu8 *data = (u8 *)(&dj_report->device_index);\n\tunsigned int i;\n\n\toutput_report_enum = &hdev->report_enum[HID_OUTPUT_REPORT];\n\treport = output_report_enum->report_id_hash[REPORT_ID_DJ_SHORT];\n\n\tif (!report) {\n\t\tdev_err(&hdev->dev, \"%s: unable to find dj report\\n\", __func__);\n\t\treturn -ENODEV;\n\t}\n\n\tfor (i = 0; i < DJREPORT_SHORT_LENGTH - 1; i++)\n\t\treport->field[0]->value[i] = data[i];\n\n\thid_hw_request(hdev, report, HID_REQ_SET_REPORT);\n\n\treturn 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -5,7 +5,7 @@\n \tstruct hid_report *report;\n \tstruct hid_report_enum *output_report_enum;\n \tu8 *data = (u8 *)(&dj_report->device_index);\n-\tint i;\n+\tunsigned int i;\n \n \toutput_report_enum = &hdev->report_enum[HID_OUTPUT_REPORT];\n \treport = output_report_enum->report_id_hash[REPORT_ID_DJ_SHORT];\n@@ -15,7 +15,7 @@\n \t\treturn -ENODEV;\n \t}\n \n-\tfor (i = 0; i < report->field[0]->report_count; i++)\n+\tfor (i = 0; i < DJREPORT_SHORT_LENGTH - 1; i++)\n \t\treport->field[0]->value[i] = data[i];\n \n \thid_hw_request(hdev, report, HID_REQ_SET_REPORT);",
        "function_modified_lines": {
            "added": [
                "\tunsigned int i;",
                "\tfor (i = 0; i < DJREPORT_SHORT_LENGTH - 1; i++)"
            ],
            "deleted": [
                "\tint i;",
                "\tfor (i = 0; i < report->field[0]->report_count; i++)"
            ]
        },
        "cwe": [
            "CWE-119"
        ],
        "cve_description": "drivers/hid/hid-logitech-dj.c in the Human Interface Device (HID) subsystem in the Linux kernel through 3.11, when CONFIG_HID_LOGITECH_DJ is enabled, allows physically proximate attackers to cause a denial of service (NULL pointer dereference and OOPS) or obtain sensitive information from kernel memory via a crafted device.",
        "id": 254
    },
    {
        "cve_id": "CVE-2014-0205",
        "code_before_change": "static inline void\nqueue_unlock(struct futex_q *q, struct futex_hash_bucket *hb)\n{\n\tspin_unlock(&hb->lock);\n\tdrop_futex_key_refs(&q->key);\n}",
        "code_after_change": "static inline void\nqueue_unlock(struct futex_q *q, struct futex_hash_bucket *hb)\n{\n\tspin_unlock(&hb->lock);\n}",
        "patch": "--- code before\n+++ code after\n@@ -2,5 +2,4 @@\n queue_unlock(struct futex_q *q, struct futex_hash_bucket *hb)\n {\n \tspin_unlock(&hb->lock);\n-\tdrop_futex_key_refs(&q->key);\n }",
        "function_modified_lines": {
            "added": [],
            "deleted": [
                "\tdrop_futex_key_refs(&q->key);"
            ]
        },
        "cwe": [
            "CWE-119"
        ],
        "cve_description": "The futex_wait function in kernel/futex.c in the Linux kernel before 2.6.37 does not properly maintain a certain reference count during requeue operations, which allows local users to cause a denial of service (use-after-free and system crash) or possibly gain privileges via a crafted application that triggers a zero count.",
        "id": 464
    },
    {
        "cve_id": "CVE-2014-0205",
        "code_before_change": "static inline struct futex_hash_bucket *queue_lock(struct futex_q *q)\n{\n\tstruct futex_hash_bucket *hb;\n\n\tget_futex_key_refs(&q->key);\n\thb = hash_futex(&q->key);\n\tq->lock_ptr = &hb->lock;\n\n\tspin_lock(&hb->lock);\n\treturn hb;\n}",
        "code_after_change": "static inline struct futex_hash_bucket *queue_lock(struct futex_q *q)\n{\n\tstruct futex_hash_bucket *hb;\n\n\thb = hash_futex(&q->key);\n\tq->lock_ptr = &hb->lock;\n\n\tspin_lock(&hb->lock);\n\treturn hb;\n}",
        "patch": "--- code before\n+++ code after\n@@ -2,7 +2,6 @@\n {\n \tstruct futex_hash_bucket *hb;\n \n-\tget_futex_key_refs(&q->key);\n \thb = hash_futex(&q->key);\n \tq->lock_ptr = &hb->lock;\n ",
        "function_modified_lines": {
            "added": [],
            "deleted": [
                "\tget_futex_key_refs(&q->key);"
            ]
        },
        "cwe": [
            "CWE-119"
        ],
        "cve_description": "The futex_wait function in kernel/futex.c in the Linux kernel before 2.6.37 does not properly maintain a certain reference count during requeue operations, which allows local users to cause a denial of service (use-after-free and system crash) or possibly gain privileges via a crafted application that triggers a zero count.",
        "id": 467
    },
    {
        "cve_id": "CVE-2014-0205",
        "code_before_change": "static void unqueue_me_pi(struct futex_q *q)\n{\n\tWARN_ON(plist_node_empty(&q->list));\n\tplist_del(&q->list, &q->list.plist);\n\n\tBUG_ON(!q->pi_state);\n\tfree_pi_state(q->pi_state);\n\tq->pi_state = NULL;\n\n\tspin_unlock(q->lock_ptr);\n\n\tdrop_futex_key_refs(&q->key);\n}",
        "code_after_change": "static void unqueue_me_pi(struct futex_q *q)\n{\n\tWARN_ON(plist_node_empty(&q->list));\n\tplist_del(&q->list, &q->list.plist);\n\n\tBUG_ON(!q->pi_state);\n\tfree_pi_state(q->pi_state);\n\tq->pi_state = NULL;\n\n\tspin_unlock(q->lock_ptr);\n}",
        "patch": "--- code before\n+++ code after\n@@ -8,6 +8,4 @@\n \tq->pi_state = NULL;\n \n \tspin_unlock(q->lock_ptr);\n-\n-\tdrop_futex_key_refs(&q->key);\n }",
        "function_modified_lines": {
            "added": [],
            "deleted": [
                "",
                "\tdrop_futex_key_refs(&q->key);"
            ]
        },
        "cwe": [
            "CWE-119"
        ],
        "cve_description": "The futex_wait function in kernel/futex.c in the Linux kernel before 2.6.37 does not properly maintain a certain reference count during requeue operations, which allows local users to cause a denial of service (use-after-free and system crash) or possibly gain privileges via a crafted application that triggers a zero count.",
        "id": 468
    },
    {
        "cve_id": "CVE-2017-16526",
        "code_before_change": "void uwbd_start(struct uwb_rc *rc)\n{\n\trc->uwbd.task = kthread_run(uwbd, rc, \"uwbd\");\n\tif (rc->uwbd.task == NULL)\n\t\tprintk(KERN_ERR \"UWB: Cannot start management daemon; \"\n\t\t       \"UWB won't work\\n\");\n\telse\n\t\trc->uwbd.pid = rc->uwbd.task->pid;\n}",
        "code_after_change": "void uwbd_start(struct uwb_rc *rc)\n{\n\tstruct task_struct *task = kthread_run(uwbd, rc, \"uwbd\");\n\tif (IS_ERR(task)) {\n\t\trc->uwbd.task = NULL;\n\t\tprintk(KERN_ERR \"UWB: Cannot start management daemon; \"\n\t\t       \"UWB won't work\\n\");\n\t} else {\n\t\trc->uwbd.task = task;\n\t\trc->uwbd.pid = rc->uwbd.task->pid;\n\t}\n}",
        "patch": "--- code before\n+++ code after\n@@ -1,9 +1,12 @@\n void uwbd_start(struct uwb_rc *rc)\n {\n-\trc->uwbd.task = kthread_run(uwbd, rc, \"uwbd\");\n-\tif (rc->uwbd.task == NULL)\n+\tstruct task_struct *task = kthread_run(uwbd, rc, \"uwbd\");\n+\tif (IS_ERR(task)) {\n+\t\trc->uwbd.task = NULL;\n \t\tprintk(KERN_ERR \"UWB: Cannot start management daemon; \"\n \t\t       \"UWB won't work\\n\");\n-\telse\n+\t} else {\n+\t\trc->uwbd.task = task;\n \t\trc->uwbd.pid = rc->uwbd.task->pid;\n+\t}\n }",
        "function_modified_lines": {
            "added": [
                "\tstruct task_struct *task = kthread_run(uwbd, rc, \"uwbd\");",
                "\tif (IS_ERR(task)) {",
                "\t\trc->uwbd.task = NULL;",
                "\t} else {",
                "\t\trc->uwbd.task = task;",
                "\t}"
            ],
            "deleted": [
                "\trc->uwbd.task = kthread_run(uwbd, rc, \"uwbd\");",
                "\tif (rc->uwbd.task == NULL)",
                "\telse"
            ]
        },
        "cwe": [
            "CWE-119"
        ],
        "cve_description": "drivers/uwb/uwbd.c in the Linux kernel before 4.13.6 allows local users to cause a denial of service (general protection fault and system crash) or possibly have unspecified other impact via a crafted USB device.",
        "id": 1310
    },
    {
        "cve_id": "CVE-2015-5283",
        "code_before_change": "static __exit void sctp_exit(void)\n{\n\t/* BUG.  This should probably do something useful like clean\n\t * up all the remaining associations and all that memory.\n\t */\n\n\t/* Unregister with inet6/inet layers. */\n\tsctp_v6_del_protocol();\n\tsctp_v4_del_protocol();\n\n\tunregister_pernet_subsys(&sctp_net_ops);\n\n\t/* Free protosw registrations */\n\tsctp_v6_protosw_exit();\n\tsctp_v4_protosw_exit();\n\n\t/* Unregister with socket layer. */\n\tsctp_v6_pf_exit();\n\tsctp_v4_pf_exit();\n\n\tsctp_sysctl_unregister();\n\n\tfree_pages((unsigned long)sctp_assoc_hashtable,\n\t\t   get_order(sctp_assoc_hashsize *\n\t\t\t     sizeof(struct sctp_hashbucket)));\n\tkfree(sctp_ep_hashtable);\n\tfree_pages((unsigned long)sctp_port_hashtable,\n\t\t   get_order(sctp_port_hashsize *\n\t\t\t     sizeof(struct sctp_bind_hashbucket)));\n\n\tpercpu_counter_destroy(&sctp_sockets_allocated);\n\n\trcu_barrier(); /* Wait for completion of call_rcu()'s */\n\n\tkmem_cache_destroy(sctp_chunk_cachep);\n\tkmem_cache_destroy(sctp_bucket_cachep);\n}",
        "code_after_change": "static __exit void sctp_exit(void)\n{\n\t/* BUG.  This should probably do something useful like clean\n\t * up all the remaining associations and all that memory.\n\t */\n\n\t/* Unregister with inet6/inet layers. */\n\tsctp_v6_del_protocol();\n\tsctp_v4_del_protocol();\n\n\tunregister_pernet_subsys(&sctp_ctrlsock_ops);\n\n\t/* Free protosw registrations */\n\tsctp_v6_protosw_exit();\n\tsctp_v4_protosw_exit();\n\n\tunregister_pernet_subsys(&sctp_defaults_ops);\n\n\t/* Unregister with socket layer. */\n\tsctp_v6_pf_exit();\n\tsctp_v4_pf_exit();\n\n\tsctp_sysctl_unregister();\n\n\tfree_pages((unsigned long)sctp_assoc_hashtable,\n\t\t   get_order(sctp_assoc_hashsize *\n\t\t\t     sizeof(struct sctp_hashbucket)));\n\tkfree(sctp_ep_hashtable);\n\tfree_pages((unsigned long)sctp_port_hashtable,\n\t\t   get_order(sctp_port_hashsize *\n\t\t\t     sizeof(struct sctp_bind_hashbucket)));\n\n\tpercpu_counter_destroy(&sctp_sockets_allocated);\n\n\trcu_barrier(); /* Wait for completion of call_rcu()'s */\n\n\tkmem_cache_destroy(sctp_chunk_cachep);\n\tkmem_cache_destroy(sctp_bucket_cachep);\n}",
        "patch": "--- code before\n+++ code after\n@@ -8,11 +8,13 @@\n \tsctp_v6_del_protocol();\n \tsctp_v4_del_protocol();\n \n-\tunregister_pernet_subsys(&sctp_net_ops);\n+\tunregister_pernet_subsys(&sctp_ctrlsock_ops);\n \n \t/* Free protosw registrations */\n \tsctp_v6_protosw_exit();\n \tsctp_v4_protosw_exit();\n+\n+\tunregister_pernet_subsys(&sctp_defaults_ops);\n \n \t/* Unregister with socket layer. */\n \tsctp_v6_pf_exit();",
        "function_modified_lines": {
            "added": [
                "\tunregister_pernet_subsys(&sctp_ctrlsock_ops);",
                "",
                "\tunregister_pernet_subsys(&sctp_defaults_ops);"
            ],
            "deleted": [
                "\tunregister_pernet_subsys(&sctp_net_ops);"
            ]
        },
        "cwe": [
            "CWE-119"
        ],
        "cve_description": "The sctp_init function in net/sctp/protocol.c in the Linux kernel before 4.2.3 has an incorrect sequence of protocol-initialization steps, which allows local users to cause a denial of service (panic or memory corruption) by creating SCTP sockets before all of the steps have finished.",
        "id": 774
    },
    {
        "cve_id": "CVE-2013-1860",
        "code_before_change": "static ssize_t wdm_read\n(struct file *file, char __user *buffer, size_t count, loff_t *ppos)\n{\n\tint rv, cntr;\n\tint i = 0;\n\tstruct wdm_device *desc = file->private_data;\n\n\n\trv = mutex_lock_interruptible(&desc->rlock); /*concurrent reads */\n\tif (rv < 0)\n\t\treturn -ERESTARTSYS;\n\n\tcntr = ACCESS_ONCE(desc->length);\n\tif (cntr == 0) {\n\t\tdesc->read = 0;\nretry:\n\t\tif (test_bit(WDM_DISCONNECTING, &desc->flags)) {\n\t\t\trv = -ENODEV;\n\t\t\tgoto err;\n\t\t}\n\t\ti++;\n\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\tif (!test_bit(WDM_READ, &desc->flags)) {\n\t\t\t\trv = cntr ? cntr : -EAGAIN;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\trv = 0;\n\t\t} else {\n\t\t\trv = wait_event_interruptible(desc->wait,\n\t\t\t\ttest_bit(WDM_READ, &desc->flags));\n\t\t}\n\n\t\t/* may have happened while we slept */\n\t\tif (test_bit(WDM_DISCONNECTING, &desc->flags)) {\n\t\t\trv = -ENODEV;\n\t\t\tgoto err;\n\t\t}\n\t\tif (test_bit(WDM_RESETTING, &desc->flags)) {\n\t\t\trv = -EIO;\n\t\t\tgoto err;\n\t\t}\n\t\tusb_mark_last_busy(interface_to_usbdev(desc->intf));\n\t\tif (rv < 0) {\n\t\t\trv = -ERESTARTSYS;\n\t\t\tgoto err;\n\t\t}\n\n\t\tspin_lock_irq(&desc->iuspin);\n\n\t\tif (desc->rerr) { /* read completed, error happened */\n\t\t\tdesc->rerr = 0;\n\t\t\tspin_unlock_irq(&desc->iuspin);\n\t\t\trv = -EIO;\n\t\t\tgoto err;\n\t\t}\n\t\t/*\n\t\t * recheck whether we've lost the race\n\t\t * against the completion handler\n\t\t */\n\t\tif (!test_bit(WDM_READ, &desc->flags)) { /* lost race */\n\t\t\tspin_unlock_irq(&desc->iuspin);\n\t\t\tgoto retry;\n\t\t}\n\t\tif (!desc->reslength) { /* zero length read */\n\t\t\tdev_dbg(&desc->intf->dev, \"%s: zero length - clearing WDM_READ\\n\", __func__);\n\t\t\tclear_bit(WDM_READ, &desc->flags);\n\t\t\tspin_unlock_irq(&desc->iuspin);\n\t\t\tgoto retry;\n\t\t}\n\t\tcntr = desc->length;\n\t\tspin_unlock_irq(&desc->iuspin);\n\t}\n\n\tif (cntr > count)\n\t\tcntr = count;\n\trv = copy_to_user(buffer, desc->ubuf, cntr);\n\tif (rv > 0) {\n\t\trv = -EFAULT;\n\t\tgoto err;\n\t}\n\n\tspin_lock_irq(&desc->iuspin);\n\n\tfor (i = 0; i < desc->length - cntr; i++)\n\t\tdesc->ubuf[i] = desc->ubuf[i + cntr];\n\n\tdesc->length -= cntr;\n\t/* in case we had outstanding data */\n\tif (!desc->length)\n\t\tclear_bit(WDM_READ, &desc->flags);\n\n\tspin_unlock_irq(&desc->iuspin);\n\n\trv = cntr;\n\nerr:\n\tmutex_unlock(&desc->rlock);\n\treturn rv;\n}",
        "code_after_change": "static ssize_t wdm_read\n(struct file *file, char __user *buffer, size_t count, loff_t *ppos)\n{\n\tint rv, cntr;\n\tint i = 0;\n\tstruct wdm_device *desc = file->private_data;\n\n\n\trv = mutex_lock_interruptible(&desc->rlock); /*concurrent reads */\n\tif (rv < 0)\n\t\treturn -ERESTARTSYS;\n\n\tcntr = ACCESS_ONCE(desc->length);\n\tif (cntr == 0) {\n\t\tdesc->read = 0;\nretry:\n\t\tif (test_bit(WDM_DISCONNECTING, &desc->flags)) {\n\t\t\trv = -ENODEV;\n\t\t\tgoto err;\n\t\t}\n\t\tif (test_bit(WDM_OVERFLOW, &desc->flags)) {\n\t\t\tclear_bit(WDM_OVERFLOW, &desc->flags);\n\t\t\trv = -ENOBUFS;\n\t\t\tgoto err;\n\t\t}\n\t\ti++;\n\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\tif (!test_bit(WDM_READ, &desc->flags)) {\n\t\t\t\trv = cntr ? cntr : -EAGAIN;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\trv = 0;\n\t\t} else {\n\t\t\trv = wait_event_interruptible(desc->wait,\n\t\t\t\ttest_bit(WDM_READ, &desc->flags));\n\t\t}\n\n\t\t/* may have happened while we slept */\n\t\tif (test_bit(WDM_DISCONNECTING, &desc->flags)) {\n\t\t\trv = -ENODEV;\n\t\t\tgoto err;\n\t\t}\n\t\tif (test_bit(WDM_RESETTING, &desc->flags)) {\n\t\t\trv = -EIO;\n\t\t\tgoto err;\n\t\t}\n\t\tusb_mark_last_busy(interface_to_usbdev(desc->intf));\n\t\tif (rv < 0) {\n\t\t\trv = -ERESTARTSYS;\n\t\t\tgoto err;\n\t\t}\n\n\t\tspin_lock_irq(&desc->iuspin);\n\n\t\tif (desc->rerr) { /* read completed, error happened */\n\t\t\tdesc->rerr = 0;\n\t\t\tspin_unlock_irq(&desc->iuspin);\n\t\t\trv = -EIO;\n\t\t\tgoto err;\n\t\t}\n\t\t/*\n\t\t * recheck whether we've lost the race\n\t\t * against the completion handler\n\t\t */\n\t\tif (!test_bit(WDM_READ, &desc->flags)) { /* lost race */\n\t\t\tspin_unlock_irq(&desc->iuspin);\n\t\t\tgoto retry;\n\t\t}\n\n\t\tif (!desc->reslength) { /* zero length read */\n\t\t\tdev_dbg(&desc->intf->dev, \"%s: zero length - clearing WDM_READ\\n\", __func__);\n\t\t\tclear_bit(WDM_READ, &desc->flags);\n\t\t\tspin_unlock_irq(&desc->iuspin);\n\t\t\tgoto retry;\n\t\t}\n\t\tcntr = desc->length;\n\t\tspin_unlock_irq(&desc->iuspin);\n\t}\n\n\tif (cntr > count)\n\t\tcntr = count;\n\trv = copy_to_user(buffer, desc->ubuf, cntr);\n\tif (rv > 0) {\n\t\trv = -EFAULT;\n\t\tgoto err;\n\t}\n\n\tspin_lock_irq(&desc->iuspin);\n\n\tfor (i = 0; i < desc->length - cntr; i++)\n\t\tdesc->ubuf[i] = desc->ubuf[i + cntr];\n\n\tdesc->length -= cntr;\n\t/* in case we had outstanding data */\n\tif (!desc->length)\n\t\tclear_bit(WDM_READ, &desc->flags);\n\n\tspin_unlock_irq(&desc->iuspin);\n\n\trv = cntr;\n\nerr:\n\tmutex_unlock(&desc->rlock);\n\treturn rv;\n}",
        "patch": "--- code before\n+++ code after\n@@ -16,6 +16,11 @@\n retry:\n \t\tif (test_bit(WDM_DISCONNECTING, &desc->flags)) {\n \t\t\trv = -ENODEV;\n+\t\t\tgoto err;\n+\t\t}\n+\t\tif (test_bit(WDM_OVERFLOW, &desc->flags)) {\n+\t\t\tclear_bit(WDM_OVERFLOW, &desc->flags);\n+\t\t\trv = -ENOBUFS;\n \t\t\tgoto err;\n \t\t}\n \t\ti++;\n@@ -61,6 +66,7 @@\n \t\t\tspin_unlock_irq(&desc->iuspin);\n \t\t\tgoto retry;\n \t\t}\n+\n \t\tif (!desc->reslength) { /* zero length read */\n \t\t\tdev_dbg(&desc->intf->dev, \"%s: zero length - clearing WDM_READ\\n\", __func__);\n \t\t\tclear_bit(WDM_READ, &desc->flags);",
        "function_modified_lines": {
            "added": [
                "\t\t\tgoto err;",
                "\t\t}",
                "\t\tif (test_bit(WDM_OVERFLOW, &desc->flags)) {",
                "\t\t\tclear_bit(WDM_OVERFLOW, &desc->flags);",
                "\t\t\trv = -ENOBUFS;",
                ""
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-119"
        ],
        "cve_description": "Heap-based buffer overflow in the wdm_in_callback function in drivers/usb/class/cdc-wdm.c in the Linux kernel before 3.8.4 allows physically proximate attackers to cause a denial of service (system crash) or possibly execute arbitrary code via a crafted cdc-wdm USB device.",
        "id": 201
    },
    {
        "cve_id": "CVE-2013-2234",
        "code_before_change": "static int key_notify_sa_flush(const struct km_event *c)\n{\n\tstruct sk_buff *skb;\n\tstruct sadb_msg *hdr;\n\n\tskb = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn -ENOBUFS;\n\thdr = (struct sadb_msg *) skb_put(skb, sizeof(struct sadb_msg));\n\thdr->sadb_msg_satype = pfkey_proto2satype(c->data.proto);\n\thdr->sadb_msg_type = SADB_FLUSH;\n\thdr->sadb_msg_seq = c->seq;\n\thdr->sadb_msg_pid = c->portid;\n\thdr->sadb_msg_version = PF_KEY_V2;\n\thdr->sadb_msg_errno = (uint8_t) 0;\n\thdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));\n\n\tpfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);\n\n\treturn 0;\n}",
        "code_after_change": "static int key_notify_sa_flush(const struct km_event *c)\n{\n\tstruct sk_buff *skb;\n\tstruct sadb_msg *hdr;\n\n\tskb = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn -ENOBUFS;\n\thdr = (struct sadb_msg *) skb_put(skb, sizeof(struct sadb_msg));\n\thdr->sadb_msg_satype = pfkey_proto2satype(c->data.proto);\n\thdr->sadb_msg_type = SADB_FLUSH;\n\thdr->sadb_msg_seq = c->seq;\n\thdr->sadb_msg_pid = c->portid;\n\thdr->sadb_msg_version = PF_KEY_V2;\n\thdr->sadb_msg_errno = (uint8_t) 0;\n\thdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));\n\thdr->sadb_msg_reserved = 0;\n\n\tpfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);\n\n\treturn 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -14,6 +14,7 @@\n \thdr->sadb_msg_version = PF_KEY_V2;\n \thdr->sadb_msg_errno = (uint8_t) 0;\n \thdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));\n+\thdr->sadb_msg_reserved = 0;\n \n \tpfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);\n ",
        "function_modified_lines": {
            "added": [
                "\thdr->sadb_msg_reserved = 0;"
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-119"
        ],
        "cve_description": "The (1) key_notify_sa_flush and (2) key_notify_policy_flush functions in net/key/af_key.c in the Linux kernel before 3.10 do not initialize certain structure members, which allows local users to obtain sensitive information from kernel heap memory by reading a broadcast message from the notify interface of an IPSec key_socket.",
        "id": 224
    },
    {
        "cve_id": "CVE-2017-5547",
        "code_before_change": "static ssize_t k90_show_current_profile(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tint ret;\n\tstruct usb_interface *usbif = to_usb_interface(dev->parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n\tint current_profile;\n\tchar data[8];\n\n\tret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\n\t\t\t      K90_REQUEST_STATUS,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, 0, 0, data, 8,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_warn(dev, \"Failed to get K90 initial state (error %d).\\n\",\n\t\t\t ret);\n\t\treturn -EIO;\n\t}\n\tcurrent_profile = data[7];\n\tif (current_profile < 1 || current_profile > 3) {\n\t\tdev_warn(dev, \"Read invalid current profile: %02hhx.\\n\",\n\t\t\t data[7]);\n\t\treturn -EIO;\n\t}\n\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", current_profile);\n}",
        "code_after_change": "static ssize_t k90_show_current_profile(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tint ret;\n\tstruct usb_interface *usbif = to_usb_interface(dev->parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n\tint current_profile;\n\tchar *data;\n\n\tdata = kmalloc(8, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\n\t\t\t      K90_REQUEST_STATUS,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, 0, 0, data, 8,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_warn(dev, \"Failed to get K90 initial state (error %d).\\n\",\n\t\t\t ret);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\tcurrent_profile = data[7];\n\tif (current_profile < 1 || current_profile > 3) {\n\t\tdev_warn(dev, \"Read invalid current profile: %02hhx.\\n\",\n\t\t\t data[7]);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tret = snprintf(buf, PAGE_SIZE, \"%d\\n\", current_profile);\nout:\n\tkfree(data);\n\n\treturn ret;\n}",
        "patch": "--- code before\n+++ code after\n@@ -6,7 +6,11 @@\n \tstruct usb_interface *usbif = to_usb_interface(dev->parent);\n \tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n \tint current_profile;\n-\tchar data[8];\n+\tchar *data;\n+\n+\tdata = kmalloc(8, GFP_KERNEL);\n+\tif (!data)\n+\t\treturn -ENOMEM;\n \n \tret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\n \t\t\t      K90_REQUEST_STATUS,\n@@ -16,14 +20,20 @@\n \tif (ret < 0) {\n \t\tdev_warn(dev, \"Failed to get K90 initial state (error %d).\\n\",\n \t\t\t ret);\n-\t\treturn -EIO;\n+\t\tret = -EIO;\n+\t\tgoto out;\n \t}\n \tcurrent_profile = data[7];\n \tif (current_profile < 1 || current_profile > 3) {\n \t\tdev_warn(dev, \"Read invalid current profile: %02hhx.\\n\",\n \t\t\t data[7]);\n-\t\treturn -EIO;\n+\t\tret = -EIO;\n+\t\tgoto out;\n \t}\n \n-\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", current_profile);\n+\tret = snprintf(buf, PAGE_SIZE, \"%d\\n\", current_profile);\n+out:\n+\tkfree(data);\n+\n+\treturn ret;\n }",
        "function_modified_lines": {
            "added": [
                "\tchar *data;",
                "",
                "\tdata = kmalloc(8, GFP_KERNEL);",
                "\tif (!data)",
                "\t\treturn -ENOMEM;",
                "\t\tret = -EIO;",
                "\t\tgoto out;",
                "\t\tret = -EIO;",
                "\t\tgoto out;",
                "\tret = snprintf(buf, PAGE_SIZE, \"%d\\n\", current_profile);",
                "out:",
                "\tkfree(data);",
                "",
                "\treturn ret;"
            ],
            "deleted": [
                "\tchar data[8];",
                "\t\treturn -EIO;",
                "\t\treturn -EIO;",
                "\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", current_profile);"
            ]
        },
        "cwe": [
            "CWE-119"
        ],
        "cve_description": "drivers/hid/hid-corsair.c in the Linux kernel 4.9.x before 4.9.6 interacts incorrectly with the CONFIG_VMAP_STACK option, which allows local users to cause a denial of service (system crash or memory corruption) or possibly have unspecified other impact by leveraging use of more than one virtual page for a DMA scatterlist.",
        "id": 1462
    },
    {
        "cve_id": "CVE-2016-8632",
        "code_before_change": "static int tipc_udp_enable(struct net *net, struct tipc_bearer *b,\n\t\t\t   struct nlattr *attrs[])\n{\n\tint err = -EINVAL;\n\tstruct udp_bearer *ub;\n\tstruct udp_media_addr remote = {0};\n\tstruct udp_media_addr local = {0};\n\tstruct udp_port_cfg udp_conf = {0};\n\tstruct udp_tunnel_sock_cfg tuncfg = {NULL};\n\tstruct nlattr *opts[TIPC_NLA_UDP_MAX + 1];\n\n\tub = kzalloc(sizeof(*ub), GFP_ATOMIC);\n\tif (!ub)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&ub->rcast.list);\n\n\tif (!attrs[TIPC_NLA_BEARER_UDP_OPTS])\n\t\tgoto err;\n\n\tif (nla_parse_nested(opts, TIPC_NLA_UDP_MAX,\n\t\t\t     attrs[TIPC_NLA_BEARER_UDP_OPTS],\n\t\t\t     tipc_nl_udp_policy))\n\t\tgoto err;\n\n\tif (!opts[TIPC_NLA_UDP_LOCAL] || !opts[TIPC_NLA_UDP_REMOTE]) {\n\t\tpr_err(\"Invalid UDP bearer configuration\");\n\t\terr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\terr = tipc_parse_udp_addr(opts[TIPC_NLA_UDP_LOCAL], &local,\n\t\t\t\t  &ub->ifindex);\n\tif (err)\n\t\tgoto err;\n\n\terr = tipc_parse_udp_addr(opts[TIPC_NLA_UDP_REMOTE], &remote, NULL);\n\tif (err)\n\t\tgoto err;\n\n\tb->bcast_addr.media_id = TIPC_MEDIA_TYPE_UDP;\n\tb->bcast_addr.broadcast = 1;\n\trcu_assign_pointer(b->media_ptr, ub);\n\trcu_assign_pointer(ub->bearer, b);\n\ttipc_udp_media_addr_set(&b->addr, &local);\n\tif (local.proto == htons(ETH_P_IP)) {\n\t\tstruct net_device *dev;\n\n\t\tdev = __ip_dev_find(net, local.ipv4.s_addr, false);\n\t\tif (!dev) {\n\t\t\terr = -ENODEV;\n\t\t\tgoto err;\n\t\t}\n\t\tudp_conf.family = AF_INET;\n\t\tudp_conf.local_ip.s_addr = htonl(INADDR_ANY);\n\t\tudp_conf.use_udp_checksums = false;\n\t\tub->ifindex = dev->ifindex;\n\t\tb->mtu = dev->mtu - sizeof(struct iphdr)\n\t\t\t- sizeof(struct udphdr);\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else if (local.proto == htons(ETH_P_IPV6)) {\n\t\tudp_conf.family = AF_INET6;\n\t\tudp_conf.use_udp6_tx_checksums = true;\n\t\tudp_conf.use_udp6_rx_checksums = true;\n\t\tudp_conf.local_ip6 = in6addr_any;\n\t\tb->mtu = 1280;\n#endif\n\t} else {\n\t\terr = -EAFNOSUPPORT;\n\t\tgoto err;\n\t}\n\tudp_conf.local_udp_port = local.port;\n\terr = udp_sock_create(net, &udp_conf, &ub->ubsock);\n\tif (err)\n\t\tgoto err;\n\ttuncfg.sk_user_data = ub;\n\ttuncfg.encap_type = 1;\n\ttuncfg.encap_rcv = tipc_udp_recv;\n\ttuncfg.encap_destroy = NULL;\n\tsetup_udp_tunnel_sock(net, ub->ubsock, &tuncfg);\n\n\t/**\n\t * The bcast media address port is used for all peers and the ip\n\t * is used if it's a multicast address.\n\t */\n\tmemcpy(&b->bcast_addr.value, &remote, sizeof(remote));\n\tif (tipc_udp_is_mcast_addr(&remote))\n\t\terr = enable_mcast(ub, &remote);\n\telse\n\t\terr = tipc_udp_rcast_add(b, &remote);\n\tif (err)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tif (ub->ubsock)\n\t\tudp_tunnel_sock_release(ub->ubsock);\n\tkfree(ub);\n\treturn err;\n}",
        "code_after_change": "static int tipc_udp_enable(struct net *net, struct tipc_bearer *b,\n\t\t\t   struct nlattr *attrs[])\n{\n\tint err = -EINVAL;\n\tstruct udp_bearer *ub;\n\tstruct udp_media_addr remote = {0};\n\tstruct udp_media_addr local = {0};\n\tstruct udp_port_cfg udp_conf = {0};\n\tstruct udp_tunnel_sock_cfg tuncfg = {NULL};\n\tstruct nlattr *opts[TIPC_NLA_UDP_MAX + 1];\n\n\tub = kzalloc(sizeof(*ub), GFP_ATOMIC);\n\tif (!ub)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&ub->rcast.list);\n\n\tif (!attrs[TIPC_NLA_BEARER_UDP_OPTS])\n\t\tgoto err;\n\n\tif (nla_parse_nested(opts, TIPC_NLA_UDP_MAX,\n\t\t\t     attrs[TIPC_NLA_BEARER_UDP_OPTS],\n\t\t\t     tipc_nl_udp_policy))\n\t\tgoto err;\n\n\tif (!opts[TIPC_NLA_UDP_LOCAL] || !opts[TIPC_NLA_UDP_REMOTE]) {\n\t\tpr_err(\"Invalid UDP bearer configuration\");\n\t\terr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\terr = tipc_parse_udp_addr(opts[TIPC_NLA_UDP_LOCAL], &local,\n\t\t\t\t  &ub->ifindex);\n\tif (err)\n\t\tgoto err;\n\n\terr = tipc_parse_udp_addr(opts[TIPC_NLA_UDP_REMOTE], &remote, NULL);\n\tif (err)\n\t\tgoto err;\n\n\tb->bcast_addr.media_id = TIPC_MEDIA_TYPE_UDP;\n\tb->bcast_addr.broadcast = 1;\n\trcu_assign_pointer(b->media_ptr, ub);\n\trcu_assign_pointer(ub->bearer, b);\n\ttipc_udp_media_addr_set(&b->addr, &local);\n\tif (local.proto == htons(ETH_P_IP)) {\n\t\tstruct net_device *dev;\n\n\t\tdev = __ip_dev_find(net, local.ipv4.s_addr, false);\n\t\tif (!dev) {\n\t\t\terr = -ENODEV;\n\t\t\tgoto err;\n\t\t}\n\t\tudp_conf.family = AF_INET;\n\t\tudp_conf.local_ip.s_addr = htonl(INADDR_ANY);\n\t\tudp_conf.use_udp_checksums = false;\n\t\tub->ifindex = dev->ifindex;\n\t\tif (tipc_mtu_bad(dev, sizeof(struct iphdr) +\n\t\t\t\t      sizeof(struct udphdr))) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\t\tb->mtu = dev->mtu - sizeof(struct iphdr)\n\t\t\t- sizeof(struct udphdr);\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else if (local.proto == htons(ETH_P_IPV6)) {\n\t\tudp_conf.family = AF_INET6;\n\t\tudp_conf.use_udp6_tx_checksums = true;\n\t\tudp_conf.use_udp6_rx_checksums = true;\n\t\tudp_conf.local_ip6 = in6addr_any;\n\t\tb->mtu = 1280;\n#endif\n\t} else {\n\t\terr = -EAFNOSUPPORT;\n\t\tgoto err;\n\t}\n\tudp_conf.local_udp_port = local.port;\n\terr = udp_sock_create(net, &udp_conf, &ub->ubsock);\n\tif (err)\n\t\tgoto err;\n\ttuncfg.sk_user_data = ub;\n\ttuncfg.encap_type = 1;\n\ttuncfg.encap_rcv = tipc_udp_recv;\n\ttuncfg.encap_destroy = NULL;\n\tsetup_udp_tunnel_sock(net, ub->ubsock, &tuncfg);\n\n\t/**\n\t * The bcast media address port is used for all peers and the ip\n\t * is used if it's a multicast address.\n\t */\n\tmemcpy(&b->bcast_addr.value, &remote, sizeof(remote));\n\tif (tipc_udp_is_mcast_addr(&remote))\n\t\terr = enable_mcast(ub, &remote);\n\telse\n\t\terr = tipc_udp_rcast_add(b, &remote);\n\tif (err)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tif (ub->ubsock)\n\t\tudp_tunnel_sock_release(ub->ubsock);\n\tkfree(ub);\n\treturn err;\n}",
        "patch": "--- code before\n+++ code after\n@@ -55,6 +55,11 @@\n \t\tudp_conf.local_ip.s_addr = htonl(INADDR_ANY);\n \t\tudp_conf.use_udp_checksums = false;\n \t\tub->ifindex = dev->ifindex;\n+\t\tif (tipc_mtu_bad(dev, sizeof(struct iphdr) +\n+\t\t\t\t      sizeof(struct udphdr))) {\n+\t\t\terr = -EINVAL;\n+\t\t\tgoto err;\n+\t\t}\n \t\tb->mtu = dev->mtu - sizeof(struct iphdr)\n \t\t\t- sizeof(struct udphdr);\n #if IS_ENABLED(CONFIG_IPV6)",
        "function_modified_lines": {
            "added": [
                "\t\tif (tipc_mtu_bad(dev, sizeof(struct iphdr) +",
                "\t\t\t\t      sizeof(struct udphdr))) {",
                "\t\t\terr = -EINVAL;",
                "\t\t\tgoto err;",
                "\t\t}"
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-264",
            "CWE-119"
        ],
        "cve_description": "The tipc_msg_build function in net/tipc/msg.c in the Linux kernel through 4.8.11 does not validate the relationship between the minimum fragment length and the maximum packet size, which allows local users to gain privileges or cause a denial of service (heap-based buffer overflow) by leveraging the CAP_NET_ADMIN capability.",
        "id": 1122
    },
    {
        "cve_id": "CVE-2018-1120",
        "code_before_change": "static int check_vma_flags(struct vm_area_struct *vma, unsigned long gup_flags)\n{\n\tvm_flags_t vm_flags = vma->vm_flags;\n\tint write = (gup_flags & FOLL_WRITE);\n\tint foreign = (gup_flags & FOLL_REMOTE);\n\n\tif (vm_flags & (VM_IO | VM_PFNMAP))\n\t\treturn -EFAULT;\n\n\tif (write) {\n\t\tif (!(vm_flags & VM_WRITE)) {\n\t\t\tif (!(gup_flags & FOLL_FORCE))\n\t\t\t\treturn -EFAULT;\n\t\t\t/*\n\t\t\t * We used to let the write,force case do COW in a\n\t\t\t * VM_MAYWRITE VM_SHARED !VM_WRITE vma, so ptrace could\n\t\t\t * set a breakpoint in a read-only mapping of an\n\t\t\t * executable, without corrupting the file (yet only\n\t\t\t * when that file had been opened for writing!).\n\t\t\t * Anon pages in shared mappings are surprising: now\n\t\t\t * just reject it.\n\t\t\t */\n\t\t\tif (!is_cow_mapping(vm_flags))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t} else if (!(vm_flags & VM_READ)) {\n\t\tif (!(gup_flags & FOLL_FORCE))\n\t\t\treturn -EFAULT;\n\t\t/*\n\t\t * Is there actually any vma we can reach here which does not\n\t\t * have VM_MAYREAD set?\n\t\t */\n\t\tif (!(vm_flags & VM_MAYREAD))\n\t\t\treturn -EFAULT;\n\t}\n\t/*\n\t * gups are always data accesses, not instruction\n\t * fetches, so execute=false here\n\t */\n\tif (!arch_vma_access_permitted(vma, write, false, foreign))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
        "code_after_change": "static int check_vma_flags(struct vm_area_struct *vma, unsigned long gup_flags)\n{\n\tvm_flags_t vm_flags = vma->vm_flags;\n\tint write = (gup_flags & FOLL_WRITE);\n\tint foreign = (gup_flags & FOLL_REMOTE);\n\n\tif (vm_flags & (VM_IO | VM_PFNMAP))\n\t\treturn -EFAULT;\n\n\tif (gup_flags & FOLL_ANON && !vma_is_anonymous(vma))\n\t\treturn -EFAULT;\n\n\tif (write) {\n\t\tif (!(vm_flags & VM_WRITE)) {\n\t\t\tif (!(gup_flags & FOLL_FORCE))\n\t\t\t\treturn -EFAULT;\n\t\t\t/*\n\t\t\t * We used to let the write,force case do COW in a\n\t\t\t * VM_MAYWRITE VM_SHARED !VM_WRITE vma, so ptrace could\n\t\t\t * set a breakpoint in a read-only mapping of an\n\t\t\t * executable, without corrupting the file (yet only\n\t\t\t * when that file had been opened for writing!).\n\t\t\t * Anon pages in shared mappings are surprising: now\n\t\t\t * just reject it.\n\t\t\t */\n\t\t\tif (!is_cow_mapping(vm_flags))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t} else if (!(vm_flags & VM_READ)) {\n\t\tif (!(gup_flags & FOLL_FORCE))\n\t\t\treturn -EFAULT;\n\t\t/*\n\t\t * Is there actually any vma we can reach here which does not\n\t\t * have VM_MAYREAD set?\n\t\t */\n\t\tif (!(vm_flags & VM_MAYREAD))\n\t\t\treturn -EFAULT;\n\t}\n\t/*\n\t * gups are always data accesses, not instruction\n\t * fetches, so execute=false here\n\t */\n\tif (!arch_vma_access_permitted(vma, write, false, foreign))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -5,6 +5,9 @@\n \tint foreign = (gup_flags & FOLL_REMOTE);\n \n \tif (vm_flags & (VM_IO | VM_PFNMAP))\n+\t\treturn -EFAULT;\n+\n+\tif (gup_flags & FOLL_ANON && !vma_is_anonymous(vma))\n \t\treturn -EFAULT;\n \n \tif (write) {",
        "function_modified_lines": {
            "added": [
                "\t\treturn -EFAULT;",
                "",
                "\tif (gup_flags & FOLL_ANON && !vma_is_anonymous(vma))"
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-119"
        ],
        "cve_description": "A flaw was found affecting the Linux kernel before version 4.17. By mmap()ing a FUSE-backed file onto a process's memory containing command line arguments (or environment strings), an attacker can cause utilities from psutils or procps (such as ps, w) or any other program which makes a read() call to the /proc/<pid>/cmdline (or /proc/<pid>/environ) files to block indefinitely (denial of service) or for some controlled time (as a synchronization primitive for other attacks).",
        "id": 1637
    },
    {
        "cve_id": "CVE-2018-1120",
        "code_before_change": "static ssize_t environ_read(struct file *file, char __user *buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tchar *page;\n\tunsigned long src = *ppos;\n\tint ret = 0;\n\tstruct mm_struct *mm = file->private_data;\n\tunsigned long env_start, env_end;\n\n\t/* Ensure the process spawned far enough to have an environment. */\n\tif (!mm || !mm->env_end)\n\t\treturn 0;\n\n\tpage = (char *)__get_free_page(GFP_KERNEL);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tret = 0;\n\tif (!mmget_not_zero(mm))\n\t\tgoto free;\n\n\tdown_read(&mm->mmap_sem);\n\tenv_start = mm->env_start;\n\tenv_end = mm->env_end;\n\tup_read(&mm->mmap_sem);\n\n\twhile (count > 0) {\n\t\tsize_t this_len, max_len;\n\t\tint retval;\n\n\t\tif (src >= (env_end - env_start))\n\t\t\tbreak;\n\n\t\tthis_len = env_end - (env_start + src);\n\n\t\tmax_len = min_t(size_t, PAGE_SIZE, count);\n\t\tthis_len = min(max_len, this_len);\n\n\t\tretval = access_remote_vm(mm, (env_start + src), page, this_len, 0);\n\n\t\tif (retval <= 0) {\n\t\t\tret = retval;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (copy_to_user(buf, page, retval)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tret += retval;\n\t\tsrc += retval;\n\t\tbuf += retval;\n\t\tcount -= retval;\n\t}\n\t*ppos = src;\n\tmmput(mm);\n\nfree:\n\tfree_page((unsigned long) page);\n\treturn ret;\n}",
        "code_after_change": "static ssize_t environ_read(struct file *file, char __user *buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tchar *page;\n\tunsigned long src = *ppos;\n\tint ret = 0;\n\tstruct mm_struct *mm = file->private_data;\n\tunsigned long env_start, env_end;\n\n\t/* Ensure the process spawned far enough to have an environment. */\n\tif (!mm || !mm->env_end)\n\t\treturn 0;\n\n\tpage = (char *)__get_free_page(GFP_KERNEL);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tret = 0;\n\tif (!mmget_not_zero(mm))\n\t\tgoto free;\n\n\tdown_read(&mm->mmap_sem);\n\tenv_start = mm->env_start;\n\tenv_end = mm->env_end;\n\tup_read(&mm->mmap_sem);\n\n\twhile (count > 0) {\n\t\tsize_t this_len, max_len;\n\t\tint retval;\n\n\t\tif (src >= (env_end - env_start))\n\t\t\tbreak;\n\n\t\tthis_len = env_end - (env_start + src);\n\n\t\tmax_len = min_t(size_t, PAGE_SIZE, count);\n\t\tthis_len = min(max_len, this_len);\n\n\t\tretval = access_remote_vm(mm, (env_start + src), page, this_len, FOLL_ANON);\n\n\t\tif (retval <= 0) {\n\t\t\tret = retval;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (copy_to_user(buf, page, retval)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tret += retval;\n\t\tsrc += retval;\n\t\tbuf += retval;\n\t\tcount -= retval;\n\t}\n\t*ppos = src;\n\tmmput(mm);\n\nfree:\n\tfree_page((unsigned long) page);\n\treturn ret;\n}",
        "patch": "--- code before\n+++ code after\n@@ -36,7 +36,7 @@\n \t\tmax_len = min_t(size_t, PAGE_SIZE, count);\n \t\tthis_len = min(max_len, this_len);\n \n-\t\tretval = access_remote_vm(mm, (env_start + src), page, this_len, 0);\n+\t\tretval = access_remote_vm(mm, (env_start + src), page, this_len, FOLL_ANON);\n \n \t\tif (retval <= 0) {\n \t\t\tret = retval;",
        "function_modified_lines": {
            "added": [
                "\t\tretval = access_remote_vm(mm, (env_start + src), page, this_len, FOLL_ANON);"
            ],
            "deleted": [
                "\t\tretval = access_remote_vm(mm, (env_start + src), page, this_len, 0);"
            ]
        },
        "cwe": [
            "CWE-119"
        ],
        "cve_description": "A flaw was found affecting the Linux kernel before version 4.17. By mmap()ing a FUSE-backed file onto a process's memory containing command line arguments (or environment strings), an attacker can cause utilities from psutils or procps (such as ps, w) or any other program which makes a read() call to the /proc/<pid>/cmdline (or /proc/<pid>/environ) files to block indefinitely (denial of service) or for some controlled time (as a synchronization primitive for other attacks).",
        "id": 1636
    },
    {
        "cve_id": "CVE-2010-5332",
        "code_before_change": "int mlx4_register_vlan(struct mlx4_dev *dev, u8 port, u16 vlan, int *index)\n{\n\tstruct mlx4_vlan_table *table = &mlx4_priv(dev)->port[port].vlan_table;\n\tint i, err = 0;\n\tint free = -1;\n\n\tmutex_lock(&table->mutex);\n\tfor (i = MLX4_VLAN_REGULAR; i < MLX4_MAX_VLAN_NUM; i++) {\n\t\tif (free < 0 && (table->refs[i] == 0)) {\n\t\t\tfree = i;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (table->refs[i] &&\n\t\t    (vlan == (MLX4_VLAN_MASK &\n\t\t\t      be32_to_cpu(table->entries[i])))) {\n\t\t\t/* Vlan already registered, increase refernce count */\n\t\t\t*index = i;\n\t\t\t++table->refs[i];\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (table->total == table->max) {\n\t\t/* No free vlan entries */\n\t\terr = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t/* Register new MAC */\n\ttable->refs[free] = 1;\n\ttable->entries[free] = cpu_to_be32(vlan | MLX4_VLAN_VALID);\n\n\terr = mlx4_set_port_vlan_table(dev, port, table->entries);\n\tif (unlikely(err)) {\n\t\tmlx4_warn(dev, \"Failed adding vlan: %u\\n\", vlan);\n\t\ttable->refs[free] = 0;\n\t\ttable->entries[free] = 0;\n\t\tgoto out;\n\t}\n\n\t*index = free;\n\t++table->total;\nout:\n\tmutex_unlock(&table->mutex);\n\treturn err;\n}",
        "code_after_change": "int mlx4_register_vlan(struct mlx4_dev *dev, u8 port, u16 vlan, int *index)\n{\n\tstruct mlx4_vlan_table *table = &mlx4_priv(dev)->port[port].vlan_table;\n\tint i, err = 0;\n\tint free = -1;\n\n\tmutex_lock(&table->mutex);\n\tfor (i = MLX4_VLAN_REGULAR; i < MLX4_MAX_VLAN_NUM; i++) {\n\t\tif (free < 0 && (table->refs[i] == 0)) {\n\t\t\tfree = i;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (table->refs[i] &&\n\t\t    (vlan == (MLX4_VLAN_MASK &\n\t\t\t      be32_to_cpu(table->entries[i])))) {\n\t\t\t/* Vlan already registered, increase refernce count */\n\t\t\t*index = i;\n\t\t\t++table->refs[i];\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (free < 0) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (table->total == table->max) {\n\t\t/* No free vlan entries */\n\t\terr = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t/* Register new MAC */\n\ttable->refs[free] = 1;\n\ttable->entries[free] = cpu_to_be32(vlan | MLX4_VLAN_VALID);\n\n\terr = mlx4_set_port_vlan_table(dev, port, table->entries);\n\tif (unlikely(err)) {\n\t\tmlx4_warn(dev, \"Failed adding vlan: %u\\n\", vlan);\n\t\ttable->refs[free] = 0;\n\t\ttable->entries[free] = 0;\n\t\tgoto out;\n\t}\n\n\t*index = free;\n\t++table->total;\nout:\n\tmutex_unlock(&table->mutex);\n\treturn err;\n}",
        "patch": "--- code before\n+++ code after\n@@ -19,6 +19,11 @@\n \t\t\t++table->refs[i];\n \t\t\tgoto out;\n \t\t}\n+\t}\n+\n+\tif (free < 0) {\n+\t\terr = -ENOMEM;\n+\t\tgoto out;\n \t}\n \n \tif (table->total == table->max) {",
        "function_modified_lines": {
            "added": [
                "\t}",
                "",
                "\tif (free < 0) {",
                "\t\terr = -ENOMEM;",
                "\t\tgoto out;"
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-119"
        ],
        "cve_description": "In the Linux kernel before 2.6.37, an out of bounds array access happened in drivers/net/mlx4/port.c. When searching for a free entry in either mlx4_register_vlan() or mlx4_register_mac(), and there is no free entry, the loop terminates without updating the local variable free thus causing out of array bounds access.",
        "id": 29
    },
    {
        "cve_id": "CVE-2017-12762",
        "code_before_change": "char *\nisdn_net_newslave(char *parm)\n{\n\tchar *p = strchr(parm, ',');\n\tisdn_net_dev *n;\n\tchar newname[10];\n\n\tif (p) {\n\t\t/* Slave-Name MUST not be empty */\n\t\tif (!strlen(p + 1))\n\t\t\treturn NULL;\n\t\tstrcpy(newname, p + 1);\n\t\t*p = 0;\n\t\t/* Master must already exist */\n\t\tif (!(n = isdn_net_findif(parm)))\n\t\t\treturn NULL;\n\t\t/* Master must be a real interface, not a slave */\n\t\tif (n->local->master)\n\t\t\treturn NULL;\n\t\t/* Master must not be started yet */\n\t\tif (isdn_net_device_started(n))\n\t\t\treturn NULL;\n\t\treturn (isdn_net_new(newname, n->dev));\n\t}\n\treturn NULL;\n}",
        "code_after_change": "char *\nisdn_net_newslave(char *parm)\n{\n\tchar *p = strchr(parm, ',');\n\tisdn_net_dev *n;\n\tchar newname[10];\n\n\tif (p) {\n\t\t/* Slave-Name MUST not be empty or overflow 'newname' */\n\t\tif (strscpy(newname, p + 1, sizeof(newname)) <= 0)\n\t\t\treturn NULL;\n\t\t*p = 0;\n\t\t/* Master must already exist */\n\t\tif (!(n = isdn_net_findif(parm)))\n\t\t\treturn NULL;\n\t\t/* Master must be a real interface, not a slave */\n\t\tif (n->local->master)\n\t\t\treturn NULL;\n\t\t/* Master must not be started yet */\n\t\tif (isdn_net_device_started(n))\n\t\t\treturn NULL;\n\t\treturn (isdn_net_new(newname, n->dev));\n\t}\n\treturn NULL;\n}",
        "patch": "--- code before\n+++ code after\n@@ -6,10 +6,9 @@\n \tchar newname[10];\n \n \tif (p) {\n-\t\t/* Slave-Name MUST not be empty */\n-\t\tif (!strlen(p + 1))\n+\t\t/* Slave-Name MUST not be empty or overflow 'newname' */\n+\t\tif (strscpy(newname, p + 1, sizeof(newname)) <= 0)\n \t\t\treturn NULL;\n-\t\tstrcpy(newname, p + 1);\n \t\t*p = 0;\n \t\t/* Master must already exist */\n \t\tif (!(n = isdn_net_findif(parm)))",
        "function_modified_lines": {
            "added": [
                "\t\t/* Slave-Name MUST not be empty or overflow 'newname' */",
                "\t\tif (strscpy(newname, p + 1, sizeof(newname)) <= 0)"
            ],
            "deleted": [
                "\t\t/* Slave-Name MUST not be empty */",
                "\t\tif (!strlen(p + 1))",
                "\t\tstrcpy(newname, p + 1);"
            ]
        },
        "cwe": [
            "CWE-119"
        ],
        "cve_description": "In /drivers/isdn/i4l/isdn_net.c: A user-controlled buffer is copied into a local buffer of constant size using strcpy without a length check which can cause a buffer overflow. This affects the Linux kernel 4.9-stable tree, 4.12-stable tree, 3.18-stable tree, and 4.4-stable tree.",
        "id": 1264
    },
    {
        "cve_id": "CVE-2007-6761",
        "code_before_change": "static int __videobuf_mmap_mapper(struct videobuf_queue *q,\n\t\t\t struct vm_area_struct *vma)\n{\n\tstruct videbuf_vmalloc_memory *mem;\n\tstruct videobuf_mapping *map;\n\tunsigned int first;\n\tint retval;\n\tunsigned long offset = vma->vm_pgoff << PAGE_SHIFT;\n\n\tif (! (vma->vm_flags & VM_WRITE) || ! (vma->vm_flags & VM_SHARED))\n\t\treturn -EINVAL;\n\n\t/* look for first buffer to map */\n\tfor (first = 0; first < VIDEO_MAX_FRAME; first++) {\n\t\tif (NULL == q->bufs[first])\n\t\t\tcontinue;\n\n\t\tif (V4L2_MEMORY_MMAP != q->bufs[first]->memory)\n\t\t\tcontinue;\n\t\tif (q->bufs[first]->boff == offset)\n\t\t\tbreak;\n\t}\n\tif (VIDEO_MAX_FRAME == first) {\n\t\tdprintk(1,\"mmap app bug: offset invalid [offset=0x%lx]\\n\",\n\t\t\t(vma->vm_pgoff << PAGE_SHIFT));\n\t\treturn -EINVAL;\n\t}\n\n\t/* create mapping + update buffer list */\n\tmap = q->bufs[first]->map = kmalloc(sizeof(struct videobuf_mapping),GFP_KERNEL);\n\tif (NULL == map)\n\t\treturn -ENOMEM;\n\n\tmap->start = vma->vm_start;\n\tmap->end   = vma->vm_end;\n\tmap->q     = q;\n\n\tq->bufs[first]->baddr = vma->vm_start;\n\n\tvma->vm_ops          = &videobuf_vm_ops;\n\tvma->vm_flags       |= VM_DONTEXPAND | VM_RESERVED;\n\tvma->vm_private_data = map;\n\n\tmem=q->bufs[first]->priv;\n\tBUG_ON (!mem);\n\tMAGIC_CHECK(mem->magic,MAGIC_VMAL_MEM);\n\n\t/* Try to remap memory */\n\tretval=remap_vmalloc_range(vma, mem->vmalloc,0);\n\tif (retval<0) {\n\t\tdprintk(1,\"mmap: postponing remap_vmalloc_range\\n\");\n\n\t\tmem->vma=kmalloc(sizeof(*vma),GFP_KERNEL);\n\t\tif (!mem->vma) {\n\t\t\tkfree(map);\n\t\t\tq->bufs[first]->map=NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmemcpy(mem->vma,vma,sizeof(*vma));\n\t}\n\n\tdprintk(1,\"mmap %p: q=%p %08lx-%08lx (%lx) pgoff %08lx buf %d\\n\",\n\t\tmap,q,vma->vm_start,vma->vm_end,\n\t\t(long int) q->bufs[first]->bsize,\n\t\tvma->vm_pgoff,first);\n\n\tvideobuf_vm_open(vma);\n\n\treturn (0);\n}",
        "code_after_change": "static int __videobuf_mmap_mapper(struct videobuf_queue *q,\n\t\t\t struct vm_area_struct *vma)\n{\n\tstruct videbuf_vmalloc_memory *mem;\n\tstruct videobuf_mapping *map;\n\tunsigned int first;\n\tint retval;\n\tunsigned long offset = vma->vm_pgoff << PAGE_SHIFT;\n\n\tif (! (vma->vm_flags & VM_WRITE) || ! (vma->vm_flags & VM_SHARED))\n\t\treturn -EINVAL;\n\n\t/* look for first buffer to map */\n\tfor (first = 0; first < VIDEO_MAX_FRAME; first++) {\n\t\tif (NULL == q->bufs[first])\n\t\t\tcontinue;\n\n\t\tif (V4L2_MEMORY_MMAP != q->bufs[first]->memory)\n\t\t\tcontinue;\n\t\tif (q->bufs[first]->boff == offset)\n\t\t\tbreak;\n\t}\n\tif (VIDEO_MAX_FRAME == first) {\n\t\tdprintk(1,\"mmap app bug: offset invalid [offset=0x%lx]\\n\",\n\t\t\t(vma->vm_pgoff << PAGE_SHIFT));\n\t\treturn -EINVAL;\n\t}\n\n\t/* create mapping + update buffer list */\n\tmap = q->bufs[first]->map = kzalloc(sizeof(struct videobuf_mapping),GFP_KERNEL);\n\tif (NULL == map)\n\t\treturn -ENOMEM;\n\n\tmap->start = vma->vm_start;\n\tmap->end   = vma->vm_end;\n\tmap->q     = q;\n\n\tq->bufs[first]->baddr = vma->vm_start;\n\n\tvma->vm_ops          = &videobuf_vm_ops;\n\tvma->vm_flags       |= VM_DONTEXPAND | VM_RESERVED;\n\tvma->vm_private_data = map;\n\n\tmem=q->bufs[first]->priv;\n\tBUG_ON (!mem);\n\tMAGIC_CHECK(mem->magic,MAGIC_VMAL_MEM);\n\n\t/* Try to remap memory */\n\tretval=remap_vmalloc_range(vma, mem->vmalloc,0);\n\tif (retval<0) {\n\t\tdprintk(1,\"mmap: postponing remap_vmalloc_range\\n\");\n\n\t\tmem->vma=kmalloc(sizeof(*vma),GFP_KERNEL);\n\t\tif (!mem->vma) {\n\t\t\tkfree(map);\n\t\t\tq->bufs[first]->map=NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmemcpy(mem->vma,vma,sizeof(*vma));\n\t}\n\n\tdprintk(1,\"mmap %p: q=%p %08lx-%08lx (%lx) pgoff %08lx buf %d\\n\",\n\t\tmap,q,vma->vm_start,vma->vm_end,\n\t\t(long int) q->bufs[first]->bsize,\n\t\tvma->vm_pgoff,first);\n\n\tvideobuf_vm_open(vma);\n\n\treturn (0);\n}",
        "patch": "--- code before\n+++ code after\n@@ -27,7 +27,7 @@\n \t}\n \n \t/* create mapping + update buffer list */\n-\tmap = q->bufs[first]->map = kmalloc(sizeof(struct videobuf_mapping),GFP_KERNEL);\n+\tmap = q->bufs[first]->map = kzalloc(sizeof(struct videobuf_mapping),GFP_KERNEL);\n \tif (NULL == map)\n \t\treturn -ENOMEM;\n ",
        "function_modified_lines": {
            "added": [
                "\tmap = q->bufs[first]->map = kzalloc(sizeof(struct videobuf_mapping),GFP_KERNEL);"
            ],
            "deleted": [
                "\tmap = q->bufs[first]->map = kmalloc(sizeof(struct videobuf_mapping),GFP_KERNEL);"
            ]
        },
        "cwe": [
            "CWE-119"
        ],
        "cve_description": "drivers/media/video/videobuf-vmalloc.c in the Linux kernel before 2.6.24 does not initialize videobuf_mapping data structures, which allows local users to trigger an incorrect count value and videobuf leak via unspecified vectors, a different vulnerability than CVE-2010-5321.",
        "id": 4
    },
    {
        "cve_id": "CVE-2013-6382",
        "code_before_change": "STATIC int\nxfs_attrlist_by_handle(\n\tstruct file\t\t*parfilp,\n\tvoid\t\t\t__user *arg)\n{\n\tint\t\t\terror = -ENOMEM;\n\tattrlist_cursor_kern_t\t*cursor;\n\txfs_fsop_attrlist_handlereq_t al_hreq;\n\tstruct dentry\t\t*dentry;\n\tchar\t\t\t*kbuf;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -XFS_ERROR(EPERM);\n\tif (copy_from_user(&al_hreq, arg, sizeof(xfs_fsop_attrlist_handlereq_t)))\n\t\treturn -XFS_ERROR(EFAULT);\n\tif (al_hreq.buflen > XATTR_LIST_MAX)\n\t\treturn -XFS_ERROR(EINVAL);\n\n\t/*\n\t * Reject flags, only allow namespaces.\n\t */\n\tif (al_hreq.flags & ~(ATTR_ROOT | ATTR_SECURE))\n\t\treturn -XFS_ERROR(EINVAL);\n\n\tdentry = xfs_handlereq_to_dentry(parfilp, &al_hreq.hreq);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\tkbuf = kmem_zalloc_large(al_hreq.buflen, KM_SLEEP);\n\tif (!kbuf)\n\t\tgoto out_dput;\n\n\tcursor = (attrlist_cursor_kern_t *)&al_hreq.pos;\n\terror = -xfs_attr_list(XFS_I(dentry->d_inode), kbuf, al_hreq.buflen,\n\t\t\t\t\tal_hreq.flags, cursor);\n\tif (error)\n\t\tgoto out_kfree;\n\n\tif (copy_to_user(al_hreq.buffer, kbuf, al_hreq.buflen))\n\t\terror = -EFAULT;\n\nout_kfree:\n\tkmem_free(kbuf);\nout_dput:\n\tdput(dentry);\n\treturn error;\n}",
        "code_after_change": "STATIC int\nxfs_attrlist_by_handle(\n\tstruct file\t\t*parfilp,\n\tvoid\t\t\t__user *arg)\n{\n\tint\t\t\terror = -ENOMEM;\n\tattrlist_cursor_kern_t\t*cursor;\n\txfs_fsop_attrlist_handlereq_t al_hreq;\n\tstruct dentry\t\t*dentry;\n\tchar\t\t\t*kbuf;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -XFS_ERROR(EPERM);\n\tif (copy_from_user(&al_hreq, arg, sizeof(xfs_fsop_attrlist_handlereq_t)))\n\t\treturn -XFS_ERROR(EFAULT);\n\tif (al_hreq.buflen < sizeof(struct attrlist) ||\n\t    al_hreq.buflen > XATTR_LIST_MAX)\n\t\treturn -XFS_ERROR(EINVAL);\n\n\t/*\n\t * Reject flags, only allow namespaces.\n\t */\n\tif (al_hreq.flags & ~(ATTR_ROOT | ATTR_SECURE))\n\t\treturn -XFS_ERROR(EINVAL);\n\n\tdentry = xfs_handlereq_to_dentry(parfilp, &al_hreq.hreq);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\tkbuf = kmem_zalloc_large(al_hreq.buflen, KM_SLEEP);\n\tif (!kbuf)\n\t\tgoto out_dput;\n\n\tcursor = (attrlist_cursor_kern_t *)&al_hreq.pos;\n\terror = -xfs_attr_list(XFS_I(dentry->d_inode), kbuf, al_hreq.buflen,\n\t\t\t\t\tal_hreq.flags, cursor);\n\tif (error)\n\t\tgoto out_kfree;\n\n\tif (copy_to_user(al_hreq.buffer, kbuf, al_hreq.buflen))\n\t\terror = -EFAULT;\n\nout_kfree:\n\tkmem_free(kbuf);\nout_dput:\n\tdput(dentry);\n\treturn error;\n}",
        "patch": "--- code before\n+++ code after\n@@ -13,7 +13,8 @@\n \t\treturn -XFS_ERROR(EPERM);\n \tif (copy_from_user(&al_hreq, arg, sizeof(xfs_fsop_attrlist_handlereq_t)))\n \t\treturn -XFS_ERROR(EFAULT);\n-\tif (al_hreq.buflen > XATTR_LIST_MAX)\n+\tif (al_hreq.buflen < sizeof(struct attrlist) ||\n+\t    al_hreq.buflen > XATTR_LIST_MAX)\n \t\treturn -XFS_ERROR(EINVAL);\n \n \t/*",
        "function_modified_lines": {
            "added": [
                "\tif (al_hreq.buflen < sizeof(struct attrlist) ||",
                "\t    al_hreq.buflen > XATTR_LIST_MAX)"
            ],
            "deleted": [
                "\tif (al_hreq.buflen > XATTR_LIST_MAX)"
            ]
        },
        "cwe": [
            "CWE-119"
        ],
        "cve_description": "Multiple buffer underflows in the XFS implementation in the Linux kernel through 3.12.1 allow local users to cause a denial of service (memory corruption) or possibly have unspecified other impact by leveraging the CAP_SYS_ADMIN capability for a (1) XFS_IOC_ATTRLIST_BY_HANDLE or (2) XFS_IOC_ATTRLIST_BY_HANDLE_32 ioctl call with a crafted length value, related to the xfs_attrlist_by_handle function in fs/xfs/xfs_ioctl.c and the xfs_compat_attrlist_by_handle function in fs/xfs/xfs_ioctl32.c.",
        "id": 349
    }
]