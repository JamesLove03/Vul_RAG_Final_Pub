[
    {
        "cve_id": "CVE-2012-3552",
        "code_before_change": "static struct rtable *icmp_route_lookup(struct net *net, struct sk_buff *skb_in,\n\t\t\t\t\tconst struct iphdr *iph,\n\t\t\t\t\t__be32 saddr, u8 tos,\n\t\t\t\t\tint type, int code,\n\t\t\t\t\tstruct icmp_bxm *param)\n{\n\tstruct flowi4 fl4 = {\n\t\t.daddr = (param->replyopts.srr ?\n\t\t\t  param->replyopts.faddr : iph->saddr),\n\t\t.saddr = saddr,\n\t\t.flowi4_tos = RT_TOS(tos),\n\t\t.flowi4_proto = IPPROTO_ICMP,\n\t\t.fl4_icmp_type = type,\n\t\t.fl4_icmp_code = code,\n\t};\n\tstruct rtable *rt, *rt2;\n\tint err;\n\n\tsecurity_skb_classify_flow(skb_in, flowi4_to_flowi(&fl4));\n\trt = __ip_route_output_key(net, &fl4);\n\tif (IS_ERR(rt))\n\t\treturn rt;\n\n\t/* No need to clone since we're just using its address. */\n\trt2 = rt;\n\n\tif (!fl4.saddr)\n\t\tfl4.saddr = rt->rt_src;\n\n\trt = (struct rtable *) xfrm_lookup(net, &rt->dst,\n\t\t\t\t\t   flowi4_to_flowi(&fl4), NULL, 0);\n\tif (!IS_ERR(rt)) {\n\t\tif (rt != rt2)\n\t\t\treturn rt;\n\t} else if (PTR_ERR(rt) == -EPERM) {\n\t\trt = NULL;\n\t} else\n\t\treturn rt;\n\n\terr = xfrm_decode_session_reverse(skb_in, flowi4_to_flowi(&fl4), AF_INET);\n\tif (err)\n\t\tgoto relookup_failed;\n\n\tif (inet_addr_type(net, fl4.saddr) == RTN_LOCAL) {\n\t\trt2 = __ip_route_output_key(net, &fl4);\n\t\tif (IS_ERR(rt2))\n\t\t\terr = PTR_ERR(rt2);\n\t} else {\n\t\tstruct flowi4 fl4_2 = {};\n\t\tunsigned long orefdst;\n\n\t\tfl4_2.daddr = fl4.saddr;\n\t\trt2 = ip_route_output_key(net, &fl4_2);\n\t\tif (IS_ERR(rt2)) {\n\t\t\terr = PTR_ERR(rt2);\n\t\t\tgoto relookup_failed;\n\t\t}\n\t\t/* Ugh! */\n\t\torefdst = skb_in->_skb_refdst; /* save old refdst */\n\t\terr = ip_route_input(skb_in, fl4.daddr, fl4.saddr,\n\t\t\t\t     RT_TOS(tos), rt2->dst.dev);\n\n\t\tdst_release(&rt2->dst);\n\t\trt2 = skb_rtable(skb_in);\n\t\tskb_in->_skb_refdst = orefdst; /* restore old refdst */\n\t}\n\n\tif (err)\n\t\tgoto relookup_failed;\n\n\trt2 = (struct rtable *) xfrm_lookup(net, &rt2->dst,\n\t\t\t\t\t    flowi4_to_flowi(&fl4), NULL,\n\t\t\t\t\t    XFRM_LOOKUP_ICMP);\n\tif (!IS_ERR(rt2)) {\n\t\tdst_release(&rt->dst);\n\t\trt = rt2;\n\t} else if (PTR_ERR(rt2) == -EPERM) {\n\t\tif (rt)\n\t\t\tdst_release(&rt->dst);\n\t\treturn rt2;\n\t} else {\n\t\terr = PTR_ERR(rt2);\n\t\tgoto relookup_failed;\n\t}\n\treturn rt;\n\nrelookup_failed:\n\tif (rt)\n\t\treturn rt;\n\treturn ERR_PTR(err);\n}",
        "code_after_change": "static struct rtable *icmp_route_lookup(struct net *net, struct sk_buff *skb_in,\n\t\t\t\t\tconst struct iphdr *iph,\n\t\t\t\t\t__be32 saddr, u8 tos,\n\t\t\t\t\tint type, int code,\n\t\t\t\t\tstruct icmp_bxm *param)\n{\n\tstruct flowi4 fl4 = {\n\t\t.daddr = (param->replyopts.opt.opt.srr ?\n\t\t\t  param->replyopts.opt.opt.faddr : iph->saddr),\n\t\t.saddr = saddr,\n\t\t.flowi4_tos = RT_TOS(tos),\n\t\t.flowi4_proto = IPPROTO_ICMP,\n\t\t.fl4_icmp_type = type,\n\t\t.fl4_icmp_code = code,\n\t};\n\tstruct rtable *rt, *rt2;\n\tint err;\n\n\tsecurity_skb_classify_flow(skb_in, flowi4_to_flowi(&fl4));\n\trt = __ip_route_output_key(net, &fl4);\n\tif (IS_ERR(rt))\n\t\treturn rt;\n\n\t/* No need to clone since we're just using its address. */\n\trt2 = rt;\n\n\tif (!fl4.saddr)\n\t\tfl4.saddr = rt->rt_src;\n\n\trt = (struct rtable *) xfrm_lookup(net, &rt->dst,\n\t\t\t\t\t   flowi4_to_flowi(&fl4), NULL, 0);\n\tif (!IS_ERR(rt)) {\n\t\tif (rt != rt2)\n\t\t\treturn rt;\n\t} else if (PTR_ERR(rt) == -EPERM) {\n\t\trt = NULL;\n\t} else\n\t\treturn rt;\n\n\terr = xfrm_decode_session_reverse(skb_in, flowi4_to_flowi(&fl4), AF_INET);\n\tif (err)\n\t\tgoto relookup_failed;\n\n\tif (inet_addr_type(net, fl4.saddr) == RTN_LOCAL) {\n\t\trt2 = __ip_route_output_key(net, &fl4);\n\t\tif (IS_ERR(rt2))\n\t\t\terr = PTR_ERR(rt2);\n\t} else {\n\t\tstruct flowi4 fl4_2 = {};\n\t\tunsigned long orefdst;\n\n\t\tfl4_2.daddr = fl4.saddr;\n\t\trt2 = ip_route_output_key(net, &fl4_2);\n\t\tif (IS_ERR(rt2)) {\n\t\t\terr = PTR_ERR(rt2);\n\t\t\tgoto relookup_failed;\n\t\t}\n\t\t/* Ugh! */\n\t\torefdst = skb_in->_skb_refdst; /* save old refdst */\n\t\terr = ip_route_input(skb_in, fl4.daddr, fl4.saddr,\n\t\t\t\t     RT_TOS(tos), rt2->dst.dev);\n\n\t\tdst_release(&rt2->dst);\n\t\trt2 = skb_rtable(skb_in);\n\t\tskb_in->_skb_refdst = orefdst; /* restore old refdst */\n\t}\n\n\tif (err)\n\t\tgoto relookup_failed;\n\n\trt2 = (struct rtable *) xfrm_lookup(net, &rt2->dst,\n\t\t\t\t\t    flowi4_to_flowi(&fl4), NULL,\n\t\t\t\t\t    XFRM_LOOKUP_ICMP);\n\tif (!IS_ERR(rt2)) {\n\t\tdst_release(&rt->dst);\n\t\trt = rt2;\n\t} else if (PTR_ERR(rt2) == -EPERM) {\n\t\tif (rt)\n\t\t\tdst_release(&rt->dst);\n\t\treturn rt2;\n\t} else {\n\t\terr = PTR_ERR(rt2);\n\t\tgoto relookup_failed;\n\t}\n\treturn rt;\n\nrelookup_failed:\n\tif (rt)\n\t\treturn rt;\n\treturn ERR_PTR(err);\n}",
        "patch": "--- code before\n+++ code after\n@@ -5,8 +5,8 @@\n \t\t\t\t\tstruct icmp_bxm *param)\n {\n \tstruct flowi4 fl4 = {\n-\t\t.daddr = (param->replyopts.srr ?\n-\t\t\t  param->replyopts.faddr : iph->saddr),\n+\t\t.daddr = (param->replyopts.opt.opt.srr ?\n+\t\t\t  param->replyopts.opt.opt.faddr : iph->saddr),\n \t\t.saddr = saddr,\n \t\t.flowi4_tos = RT_TOS(tos),\n \t\t.flowi4_proto = IPPROTO_ICMP,",
        "function_modified_lines": {
            "added": [
                "\t\t.daddr = (param->replyopts.opt.opt.srr ?",
                "\t\t\t  param->replyopts.opt.opt.faddr : iph->saddr),"
            ],
            "deleted": [
                "\t\t.daddr = (param->replyopts.srr ?",
                "\t\t\t  param->replyopts.faddr : iph->saddr),"
            ]
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "Race condition in the IP implementation in the Linux kernel before 3.0 might allow remote attackers to cause a denial of service (slab corruption and system crash) by sending packets to an application that sets socket options during the handling of network traffic.",
        "id": 77
    },
    {
        "cve_id": "CVE-2012-3552",
        "code_before_change": "static struct sock * tcp_v6_syn_recv_sock(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t\t  struct request_sock *req,\n\t\t\t\t\t  struct dst_entry *dst)\n{\n\tstruct inet6_request_sock *treq;\n\tstruct ipv6_pinfo *newnp, *np = inet6_sk(sk);\n\tstruct tcp6_sock *newtcp6sk;\n\tstruct inet_sock *newinet;\n\tstruct tcp_sock *newtp;\n\tstruct sock *newsk;\n\tstruct ipv6_txoptions *opt;\n#ifdef CONFIG_TCP_MD5SIG\n\tstruct tcp_md5sig_key *key;\n#endif\n\n\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\t/*\n\t\t *\tv6 mapped\n\t\t */\n\n\t\tnewsk = tcp_v4_syn_recv_sock(sk, skb, req, dst);\n\n\t\tif (newsk == NULL)\n\t\t\treturn NULL;\n\n\t\tnewtcp6sk = (struct tcp6_sock *)newsk;\n\t\tinet_sk(newsk)->pinet6 = &newtcp6sk->inet6;\n\n\t\tnewinet = inet_sk(newsk);\n\t\tnewnp = inet6_sk(newsk);\n\t\tnewtp = tcp_sk(newsk);\n\n\t\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\t\tipv6_addr_set_v4mapped(newinet->inet_daddr, &newnp->daddr);\n\n\t\tipv6_addr_set_v4mapped(newinet->inet_saddr, &newnp->saddr);\n\n\t\tipv6_addr_copy(&newnp->rcv_saddr, &newnp->saddr);\n\n\t\tinet_csk(newsk)->icsk_af_ops = &ipv6_mapped;\n\t\tnewsk->sk_backlog_rcv = tcp_v4_do_rcv;\n#ifdef CONFIG_TCP_MD5SIG\n\t\tnewtp->af_specific = &tcp_sock_ipv6_mapped_specific;\n#endif\n\n\t\tnewnp->pktoptions  = NULL;\n\t\tnewnp->opt\t   = NULL;\n\t\tnewnp->mcast_oif   = inet6_iif(skb);\n\t\tnewnp->mcast_hops  = ipv6_hdr(skb)->hop_limit;\n\n\t\t/*\n\t\t * No need to charge this sock to the relevant IPv6 refcnt debug socks count\n\t\t * here, tcp_create_openreq_child now does this for us, see the comment in\n\t\t * that function for the gory details. -acme\n\t\t */\n\n\t\t/* It is tricky place. Until this moment IPv4 tcp\n\t\t   worked with IPv6 icsk.icsk_af_ops.\n\t\t   Sync it now.\n\t\t */\n\t\ttcp_sync_mss(newsk, inet_csk(newsk)->icsk_pmtu_cookie);\n\n\t\treturn newsk;\n\t}\n\n\ttreq = inet6_rsk(req);\n\topt = np->opt;\n\n\tif (sk_acceptq_is_full(sk))\n\t\tgoto out_overflow;\n\n\tif (!dst) {\n\t\tdst = inet6_csk_route_req(sk, req);\n\t\tif (!dst)\n\t\t\tgoto out;\n\t}\n\n\tnewsk = tcp_create_openreq_child(sk, req, skb);\n\tif (newsk == NULL)\n\t\tgoto out_nonewsk;\n\n\t/*\n\t * No need to charge this sock to the relevant IPv6 refcnt debug socks\n\t * count here, tcp_create_openreq_child now does this for us, see the\n\t * comment in that function for the gory details. -acme\n\t */\n\n\tnewsk->sk_gso_type = SKB_GSO_TCPV6;\n\t__ip6_dst_store(newsk, dst, NULL, NULL);\n\n\tnewtcp6sk = (struct tcp6_sock *)newsk;\n\tinet_sk(newsk)->pinet6 = &newtcp6sk->inet6;\n\n\tnewtp = tcp_sk(newsk);\n\tnewinet = inet_sk(newsk);\n\tnewnp = inet6_sk(newsk);\n\n\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\tipv6_addr_copy(&newnp->daddr, &treq->rmt_addr);\n\tipv6_addr_copy(&newnp->saddr, &treq->loc_addr);\n\tipv6_addr_copy(&newnp->rcv_saddr, &treq->loc_addr);\n\tnewsk->sk_bound_dev_if = treq->iif;\n\n\t/* Now IPv6 options...\n\n\t   First: no IPv4 options.\n\t */\n\tnewinet->opt = NULL;\n\tnewnp->ipv6_fl_list = NULL;\n\n\t/* Clone RX bits */\n\tnewnp->rxopt.all = np->rxopt.all;\n\n\t/* Clone pktoptions received with SYN */\n\tnewnp->pktoptions = NULL;\n\tif (treq->pktopts != NULL) {\n\t\tnewnp->pktoptions = skb_clone(treq->pktopts, GFP_ATOMIC);\n\t\tkfree_skb(treq->pktopts);\n\t\ttreq->pktopts = NULL;\n\t\tif (newnp->pktoptions)\n\t\t\tskb_set_owner_r(newnp->pktoptions, newsk);\n\t}\n\tnewnp->opt\t  = NULL;\n\tnewnp->mcast_oif  = inet6_iif(skb);\n\tnewnp->mcast_hops = ipv6_hdr(skb)->hop_limit;\n\n\t/* Clone native IPv6 options from listening socket (if any)\n\n\t   Yes, keeping reference count would be much more clever,\n\t   but we make one more one thing there: reattach optmem\n\t   to newsk.\n\t */\n\tif (opt) {\n\t\tnewnp->opt = ipv6_dup_options(newsk, opt);\n\t\tif (opt != np->opt)\n\t\t\tsock_kfree_s(sk, opt, opt->tot_len);\n\t}\n\n\tinet_csk(newsk)->icsk_ext_hdr_len = 0;\n\tif (newnp->opt)\n\t\tinet_csk(newsk)->icsk_ext_hdr_len = (newnp->opt->opt_nflen +\n\t\t\t\t\t\t     newnp->opt->opt_flen);\n\n\ttcp_mtup_init(newsk);\n\ttcp_sync_mss(newsk, dst_mtu(dst));\n\tnewtp->advmss = dst_metric_advmss(dst);\n\ttcp_initialize_rcv_mss(newsk);\n\n\tnewinet->inet_daddr = newinet->inet_saddr = LOOPBACK4_IPV6;\n\tnewinet->inet_rcv_saddr = LOOPBACK4_IPV6;\n\n#ifdef CONFIG_TCP_MD5SIG\n\t/* Copy over the MD5 key from the original socket */\n\tif ((key = tcp_v6_md5_do_lookup(sk, &newnp->daddr)) != NULL) {\n\t\t/* We're using one, so create a matching key\n\t\t * on the newsk structure. If we fail to get\n\t\t * memory, then we end up not copying the key\n\t\t * across. Shucks.\n\t\t */\n\t\tchar *newkey = kmemdup(key->key, key->keylen, GFP_ATOMIC);\n\t\tif (newkey != NULL)\n\t\t\ttcp_v6_md5_do_add(newsk, &newnp->daddr,\n\t\t\t\t\t  newkey, key->keylen);\n\t}\n#endif\n\n\tif (__inet_inherit_port(sk, newsk) < 0) {\n\t\tsock_put(newsk);\n\t\tgoto out;\n\t}\n\t__inet6_hash(newsk, NULL);\n\n\treturn newsk;\n\nout_overflow:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);\nout_nonewsk:\n\tif (opt && opt != np->opt)\n\t\tsock_kfree_s(sk, opt, opt->tot_len);\n\tdst_release(dst);\nout:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENDROPS);\n\treturn NULL;\n}",
        "code_after_change": "static struct sock * tcp_v6_syn_recv_sock(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t\t  struct request_sock *req,\n\t\t\t\t\t  struct dst_entry *dst)\n{\n\tstruct inet6_request_sock *treq;\n\tstruct ipv6_pinfo *newnp, *np = inet6_sk(sk);\n\tstruct tcp6_sock *newtcp6sk;\n\tstruct inet_sock *newinet;\n\tstruct tcp_sock *newtp;\n\tstruct sock *newsk;\n\tstruct ipv6_txoptions *opt;\n#ifdef CONFIG_TCP_MD5SIG\n\tstruct tcp_md5sig_key *key;\n#endif\n\n\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\t/*\n\t\t *\tv6 mapped\n\t\t */\n\n\t\tnewsk = tcp_v4_syn_recv_sock(sk, skb, req, dst);\n\n\t\tif (newsk == NULL)\n\t\t\treturn NULL;\n\n\t\tnewtcp6sk = (struct tcp6_sock *)newsk;\n\t\tinet_sk(newsk)->pinet6 = &newtcp6sk->inet6;\n\n\t\tnewinet = inet_sk(newsk);\n\t\tnewnp = inet6_sk(newsk);\n\t\tnewtp = tcp_sk(newsk);\n\n\t\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\t\tipv6_addr_set_v4mapped(newinet->inet_daddr, &newnp->daddr);\n\n\t\tipv6_addr_set_v4mapped(newinet->inet_saddr, &newnp->saddr);\n\n\t\tipv6_addr_copy(&newnp->rcv_saddr, &newnp->saddr);\n\n\t\tinet_csk(newsk)->icsk_af_ops = &ipv6_mapped;\n\t\tnewsk->sk_backlog_rcv = tcp_v4_do_rcv;\n#ifdef CONFIG_TCP_MD5SIG\n\t\tnewtp->af_specific = &tcp_sock_ipv6_mapped_specific;\n#endif\n\n\t\tnewnp->pktoptions  = NULL;\n\t\tnewnp->opt\t   = NULL;\n\t\tnewnp->mcast_oif   = inet6_iif(skb);\n\t\tnewnp->mcast_hops  = ipv6_hdr(skb)->hop_limit;\n\n\t\t/*\n\t\t * No need to charge this sock to the relevant IPv6 refcnt debug socks count\n\t\t * here, tcp_create_openreq_child now does this for us, see the comment in\n\t\t * that function for the gory details. -acme\n\t\t */\n\n\t\t/* It is tricky place. Until this moment IPv4 tcp\n\t\t   worked with IPv6 icsk.icsk_af_ops.\n\t\t   Sync it now.\n\t\t */\n\t\ttcp_sync_mss(newsk, inet_csk(newsk)->icsk_pmtu_cookie);\n\n\t\treturn newsk;\n\t}\n\n\ttreq = inet6_rsk(req);\n\topt = np->opt;\n\n\tif (sk_acceptq_is_full(sk))\n\t\tgoto out_overflow;\n\n\tif (!dst) {\n\t\tdst = inet6_csk_route_req(sk, req);\n\t\tif (!dst)\n\t\t\tgoto out;\n\t}\n\n\tnewsk = tcp_create_openreq_child(sk, req, skb);\n\tif (newsk == NULL)\n\t\tgoto out_nonewsk;\n\n\t/*\n\t * No need to charge this sock to the relevant IPv6 refcnt debug socks\n\t * count here, tcp_create_openreq_child now does this for us, see the\n\t * comment in that function for the gory details. -acme\n\t */\n\n\tnewsk->sk_gso_type = SKB_GSO_TCPV6;\n\t__ip6_dst_store(newsk, dst, NULL, NULL);\n\n\tnewtcp6sk = (struct tcp6_sock *)newsk;\n\tinet_sk(newsk)->pinet6 = &newtcp6sk->inet6;\n\n\tnewtp = tcp_sk(newsk);\n\tnewinet = inet_sk(newsk);\n\tnewnp = inet6_sk(newsk);\n\n\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\tipv6_addr_copy(&newnp->daddr, &treq->rmt_addr);\n\tipv6_addr_copy(&newnp->saddr, &treq->loc_addr);\n\tipv6_addr_copy(&newnp->rcv_saddr, &treq->loc_addr);\n\tnewsk->sk_bound_dev_if = treq->iif;\n\n\t/* Now IPv6 options...\n\n\t   First: no IPv4 options.\n\t */\n\tnewinet->inet_opt = NULL;\n\tnewnp->ipv6_fl_list = NULL;\n\n\t/* Clone RX bits */\n\tnewnp->rxopt.all = np->rxopt.all;\n\n\t/* Clone pktoptions received with SYN */\n\tnewnp->pktoptions = NULL;\n\tif (treq->pktopts != NULL) {\n\t\tnewnp->pktoptions = skb_clone(treq->pktopts, GFP_ATOMIC);\n\t\tkfree_skb(treq->pktopts);\n\t\ttreq->pktopts = NULL;\n\t\tif (newnp->pktoptions)\n\t\t\tskb_set_owner_r(newnp->pktoptions, newsk);\n\t}\n\tnewnp->opt\t  = NULL;\n\tnewnp->mcast_oif  = inet6_iif(skb);\n\tnewnp->mcast_hops = ipv6_hdr(skb)->hop_limit;\n\n\t/* Clone native IPv6 options from listening socket (if any)\n\n\t   Yes, keeping reference count would be much more clever,\n\t   but we make one more one thing there: reattach optmem\n\t   to newsk.\n\t */\n\tif (opt) {\n\t\tnewnp->opt = ipv6_dup_options(newsk, opt);\n\t\tif (opt != np->opt)\n\t\t\tsock_kfree_s(sk, opt, opt->tot_len);\n\t}\n\n\tinet_csk(newsk)->icsk_ext_hdr_len = 0;\n\tif (newnp->opt)\n\t\tinet_csk(newsk)->icsk_ext_hdr_len = (newnp->opt->opt_nflen +\n\t\t\t\t\t\t     newnp->opt->opt_flen);\n\n\ttcp_mtup_init(newsk);\n\ttcp_sync_mss(newsk, dst_mtu(dst));\n\tnewtp->advmss = dst_metric_advmss(dst);\n\ttcp_initialize_rcv_mss(newsk);\n\n\tnewinet->inet_daddr = newinet->inet_saddr = LOOPBACK4_IPV6;\n\tnewinet->inet_rcv_saddr = LOOPBACK4_IPV6;\n\n#ifdef CONFIG_TCP_MD5SIG\n\t/* Copy over the MD5 key from the original socket */\n\tif ((key = tcp_v6_md5_do_lookup(sk, &newnp->daddr)) != NULL) {\n\t\t/* We're using one, so create a matching key\n\t\t * on the newsk structure. If we fail to get\n\t\t * memory, then we end up not copying the key\n\t\t * across. Shucks.\n\t\t */\n\t\tchar *newkey = kmemdup(key->key, key->keylen, GFP_ATOMIC);\n\t\tif (newkey != NULL)\n\t\t\ttcp_v6_md5_do_add(newsk, &newnp->daddr,\n\t\t\t\t\t  newkey, key->keylen);\n\t}\n#endif\n\n\tif (__inet_inherit_port(sk, newsk) < 0) {\n\t\tsock_put(newsk);\n\t\tgoto out;\n\t}\n\t__inet6_hash(newsk, NULL);\n\n\treturn newsk;\n\nout_overflow:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);\nout_nonewsk:\n\tif (opt && opt != np->opt)\n\t\tsock_kfree_s(sk, opt, opt->tot_len);\n\tdst_release(dst);\nout:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENDROPS);\n\treturn NULL;\n}",
        "patch": "--- code before\n+++ code after\n@@ -107,7 +107,7 @@\n \n \t   First: no IPv4 options.\n \t */\n-\tnewinet->opt = NULL;\n+\tnewinet->inet_opt = NULL;\n \tnewnp->ipv6_fl_list = NULL;\n \n \t/* Clone RX bits */",
        "function_modified_lines": {
            "added": [
                "\tnewinet->inet_opt = NULL;"
            ],
            "deleted": [
                "\tnewinet->opt = NULL;"
            ]
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "Race condition in the IP implementation in the Linux kernel before 3.0 might allow remote attackers to cause a denial of service (slab corruption and system crash) by sending packets to an application that sets socket options during the handling of network traffic.",
        "id": 93
    },
    {
        "cve_id": "CVE-2012-3552",
        "code_before_change": "void ip_send_reply(struct sock *sk, struct sk_buff *skb, struct ip_reply_arg *arg,\n\t\t   unsigned int len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct {\n\t\tstruct ip_options\topt;\n\t\tchar\t\t\tdata[40];\n\t} replyopts;\n\tstruct ipcm_cookie ipc;\n\t__be32 daddr;\n\tstruct rtable *rt = skb_rtable(skb);\n\n\tif (ip_options_echo(&replyopts.opt, skb))\n\t\treturn;\n\n\tdaddr = ipc.addr = rt->rt_src;\n\tipc.opt = NULL;\n\tipc.tx_flags = 0;\n\n\tif (replyopts.opt.optlen) {\n\t\tipc.opt = &replyopts.opt;\n\n\t\tif (ipc.opt->srr)\n\t\t\tdaddr = replyopts.opt.faddr;\n\t}\n\n\t{\n\t\tstruct flowi4 fl4;\n\n\t\tflowi4_init_output(&fl4, arg->bound_dev_if, 0,\n\t\t\t\t   RT_TOS(ip_hdr(skb)->tos),\n\t\t\t\t   RT_SCOPE_UNIVERSE, sk->sk_protocol,\n\t\t\t\t   ip_reply_arg_flowi_flags(arg),\n\t\t\t\t   daddr, rt->rt_spec_dst,\n\t\t\t\t   tcp_hdr(skb)->source, tcp_hdr(skb)->dest);\n\t\tsecurity_skb_classify_flow(skb, flowi4_to_flowi(&fl4));\n\t\trt = ip_route_output_key(sock_net(sk), &fl4);\n\t\tif (IS_ERR(rt))\n\t\t\treturn;\n\t}\n\n\t/* And let IP do all the hard work.\n\n\t   This chunk is not reenterable, hence spinlock.\n\t   Note that it uses the fact, that this function is called\n\t   with locally disabled BH and that sk cannot be already spinlocked.\n\t */\n\tbh_lock_sock(sk);\n\tinet->tos = ip_hdr(skb)->tos;\n\tsk->sk_priority = skb->priority;\n\tsk->sk_protocol = ip_hdr(skb)->protocol;\n\tsk->sk_bound_dev_if = arg->bound_dev_if;\n\tip_append_data(sk, ip_reply_glue_bits, arg->iov->iov_base, len, 0,\n\t\t       &ipc, &rt, MSG_DONTWAIT);\n\tif ((skb = skb_peek(&sk->sk_write_queue)) != NULL) {\n\t\tif (arg->csumoffset >= 0)\n\t\t\t*((__sum16 *)skb_transport_header(skb) +\n\t\t\t  arg->csumoffset) = csum_fold(csum_add(skb->csum,\n\t\t\t\t\t\t\t\targ->csum));\n\t\tskb->ip_summed = CHECKSUM_NONE;\n\t\tip_push_pending_frames(sk);\n\t}\n\n\tbh_unlock_sock(sk);\n\n\tip_rt_put(rt);\n}",
        "code_after_change": "void ip_send_reply(struct sock *sk, struct sk_buff *skb, struct ip_reply_arg *arg,\n\t\t   unsigned int len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ip_options_data replyopts;\n\tstruct ipcm_cookie ipc;\n\t__be32 daddr;\n\tstruct rtable *rt = skb_rtable(skb);\n\n\tif (ip_options_echo(&replyopts.opt.opt, skb))\n\t\treturn;\n\n\tdaddr = ipc.addr = rt->rt_src;\n\tipc.opt = NULL;\n\tipc.tx_flags = 0;\n\n\tif (replyopts.opt.opt.optlen) {\n\t\tipc.opt = &replyopts.opt;\n\n\t\tif (replyopts.opt.opt.srr)\n\t\t\tdaddr = replyopts.opt.opt.faddr;\n\t}\n\n\t{\n\t\tstruct flowi4 fl4;\n\n\t\tflowi4_init_output(&fl4, arg->bound_dev_if, 0,\n\t\t\t\t   RT_TOS(ip_hdr(skb)->tos),\n\t\t\t\t   RT_SCOPE_UNIVERSE, sk->sk_protocol,\n\t\t\t\t   ip_reply_arg_flowi_flags(arg),\n\t\t\t\t   daddr, rt->rt_spec_dst,\n\t\t\t\t   tcp_hdr(skb)->source, tcp_hdr(skb)->dest);\n\t\tsecurity_skb_classify_flow(skb, flowi4_to_flowi(&fl4));\n\t\trt = ip_route_output_key(sock_net(sk), &fl4);\n\t\tif (IS_ERR(rt))\n\t\t\treturn;\n\t}\n\n\t/* And let IP do all the hard work.\n\n\t   This chunk is not reenterable, hence spinlock.\n\t   Note that it uses the fact, that this function is called\n\t   with locally disabled BH and that sk cannot be already spinlocked.\n\t */\n\tbh_lock_sock(sk);\n\tinet->tos = ip_hdr(skb)->tos;\n\tsk->sk_priority = skb->priority;\n\tsk->sk_protocol = ip_hdr(skb)->protocol;\n\tsk->sk_bound_dev_if = arg->bound_dev_if;\n\tip_append_data(sk, ip_reply_glue_bits, arg->iov->iov_base, len, 0,\n\t\t       &ipc, &rt, MSG_DONTWAIT);\n\tif ((skb = skb_peek(&sk->sk_write_queue)) != NULL) {\n\t\tif (arg->csumoffset >= 0)\n\t\t\t*((__sum16 *)skb_transport_header(skb) +\n\t\t\t  arg->csumoffset) = csum_fold(csum_add(skb->csum,\n\t\t\t\t\t\t\t\targ->csum));\n\t\tskb->ip_summed = CHECKSUM_NONE;\n\t\tip_push_pending_frames(sk);\n\t}\n\n\tbh_unlock_sock(sk);\n\n\tip_rt_put(rt);\n}",
        "patch": "--- code before\n+++ code after\n@@ -2,26 +2,23 @@\n \t\t   unsigned int len)\n {\n \tstruct inet_sock *inet = inet_sk(sk);\n-\tstruct {\n-\t\tstruct ip_options\topt;\n-\t\tchar\t\t\tdata[40];\n-\t} replyopts;\n+\tstruct ip_options_data replyopts;\n \tstruct ipcm_cookie ipc;\n \t__be32 daddr;\n \tstruct rtable *rt = skb_rtable(skb);\n \n-\tif (ip_options_echo(&replyopts.opt, skb))\n+\tif (ip_options_echo(&replyopts.opt.opt, skb))\n \t\treturn;\n \n \tdaddr = ipc.addr = rt->rt_src;\n \tipc.opt = NULL;\n \tipc.tx_flags = 0;\n \n-\tif (replyopts.opt.optlen) {\n+\tif (replyopts.opt.opt.optlen) {\n \t\tipc.opt = &replyopts.opt;\n \n-\t\tif (ipc.opt->srr)\n-\t\t\tdaddr = replyopts.opt.faddr;\n+\t\tif (replyopts.opt.opt.srr)\n+\t\t\tdaddr = replyopts.opt.opt.faddr;\n \t}\n \n \t{",
        "function_modified_lines": {
            "added": [
                "\tstruct ip_options_data replyopts;",
                "\tif (ip_options_echo(&replyopts.opt.opt, skb))",
                "\tif (replyopts.opt.opt.optlen) {",
                "\t\tif (replyopts.opt.opt.srr)",
                "\t\t\tdaddr = replyopts.opt.opt.faddr;"
            ],
            "deleted": [
                "\tstruct {",
                "\t\tstruct ip_options\topt;",
                "\t\tchar\t\t\tdata[40];",
                "\t} replyopts;",
                "\tif (ip_options_echo(&replyopts.opt, skb))",
                "\tif (replyopts.opt.optlen) {",
                "\t\tif (ipc.opt->srr)",
                "\t\t\tdaddr = replyopts.opt.faddr;"
            ]
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "Race condition in the IP implementation in the Linux kernel before 3.0 might allow remote attackers to cause a denial of service (slab corruption and system crash) by sending packets to an application that sets socket options during the handling of network traffic.",
        "id": 83
    },
    {
        "cve_id": "CVE-2012-3552",
        "code_before_change": "static struct sock *dccp_v6_request_recv_sock(struct sock *sk,\n\t\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t\t      struct request_sock *req,\n\t\t\t\t\t      struct dst_entry *dst)\n{\n\tstruct inet6_request_sock *ireq6 = inet6_rsk(req);\n\tstruct ipv6_pinfo *newnp, *np = inet6_sk(sk);\n\tstruct inet_sock *newinet;\n\tstruct dccp6_sock *newdp6;\n\tstruct sock *newsk;\n\tstruct ipv6_txoptions *opt;\n\n\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\t/*\n\t\t *\tv6 mapped\n\t\t */\n\t\tnewsk = dccp_v4_request_recv_sock(sk, skb, req, dst);\n\t\tif (newsk == NULL)\n\t\t\treturn NULL;\n\n\t\tnewdp6 = (struct dccp6_sock *)newsk;\n\t\tnewinet = inet_sk(newsk);\n\t\tnewinet->pinet6 = &newdp6->inet6;\n\t\tnewnp = inet6_sk(newsk);\n\n\t\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\t\tipv6_addr_set_v4mapped(newinet->inet_daddr, &newnp->daddr);\n\n\t\tipv6_addr_set_v4mapped(newinet->inet_saddr, &newnp->saddr);\n\n\t\tipv6_addr_copy(&newnp->rcv_saddr, &newnp->saddr);\n\n\t\tinet_csk(newsk)->icsk_af_ops = &dccp_ipv6_mapped;\n\t\tnewsk->sk_backlog_rcv = dccp_v4_do_rcv;\n\t\tnewnp->pktoptions  = NULL;\n\t\tnewnp->opt\t   = NULL;\n\t\tnewnp->mcast_oif   = inet6_iif(skb);\n\t\tnewnp->mcast_hops  = ipv6_hdr(skb)->hop_limit;\n\n\t\t/*\n\t\t * No need to charge this sock to the relevant IPv6 refcnt debug socks count\n\t\t * here, dccp_create_openreq_child now does this for us, see the comment in\n\t\t * that function for the gory details. -acme\n\t\t */\n\n\t\t/* It is tricky place. Until this moment IPv4 tcp\n\t\t   worked with IPv6 icsk.icsk_af_ops.\n\t\t   Sync it now.\n\t\t */\n\t\tdccp_sync_mss(newsk, inet_csk(newsk)->icsk_pmtu_cookie);\n\n\t\treturn newsk;\n\t}\n\n\topt = np->opt;\n\n\tif (sk_acceptq_is_full(sk))\n\t\tgoto out_overflow;\n\n\tif (dst == NULL) {\n\t\tstruct in6_addr *final_p, final;\n\t\tstruct flowi6 fl6;\n\n\t\tmemset(&fl6, 0, sizeof(fl6));\n\t\tfl6.flowi6_proto = IPPROTO_DCCP;\n\t\tipv6_addr_copy(&fl6.daddr, &ireq6->rmt_addr);\n\t\tfinal_p = fl6_update_dst(&fl6, opt, &final);\n\t\tipv6_addr_copy(&fl6.saddr, &ireq6->loc_addr);\n\t\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n\t\tfl6.fl6_dport = inet_rsk(req)->rmt_port;\n\t\tfl6.fl6_sport = inet_rsk(req)->loc_port;\n\t\tsecurity_sk_classify_flow(sk, flowi6_to_flowi(&fl6));\n\n\t\tdst = ip6_dst_lookup_flow(sk, &fl6, final_p, false);\n\t\tif (IS_ERR(dst))\n\t\t\tgoto out;\n\t}\n\n\tnewsk = dccp_create_openreq_child(sk, req, skb);\n\tif (newsk == NULL)\n\t\tgoto out_nonewsk;\n\n\t/*\n\t * No need to charge this sock to the relevant IPv6 refcnt debug socks\n\t * count here, dccp_create_openreq_child now does this for us, see the\n\t * comment in that function for the gory details. -acme\n\t */\n\n\t__ip6_dst_store(newsk, dst, NULL, NULL);\n\tnewsk->sk_route_caps = dst->dev->features & ~(NETIF_F_IP_CSUM |\n\t\t\t\t\t\t      NETIF_F_TSO);\n\tnewdp6 = (struct dccp6_sock *)newsk;\n\tnewinet = inet_sk(newsk);\n\tnewinet->pinet6 = &newdp6->inet6;\n\tnewnp = inet6_sk(newsk);\n\n\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\tipv6_addr_copy(&newnp->daddr, &ireq6->rmt_addr);\n\tipv6_addr_copy(&newnp->saddr, &ireq6->loc_addr);\n\tipv6_addr_copy(&newnp->rcv_saddr, &ireq6->loc_addr);\n\tnewsk->sk_bound_dev_if = ireq6->iif;\n\n\t/* Now IPv6 options...\n\n\t   First: no IPv4 options.\n\t */\n\tnewinet->opt = NULL;\n\n\t/* Clone RX bits */\n\tnewnp->rxopt.all = np->rxopt.all;\n\n\t/* Clone pktoptions received with SYN */\n\tnewnp->pktoptions = NULL;\n\tif (ireq6->pktopts != NULL) {\n\t\tnewnp->pktoptions = skb_clone(ireq6->pktopts, GFP_ATOMIC);\n\t\tkfree_skb(ireq6->pktopts);\n\t\tireq6->pktopts = NULL;\n\t\tif (newnp->pktoptions)\n\t\t\tskb_set_owner_r(newnp->pktoptions, newsk);\n\t}\n\tnewnp->opt\t  = NULL;\n\tnewnp->mcast_oif  = inet6_iif(skb);\n\tnewnp->mcast_hops = ipv6_hdr(skb)->hop_limit;\n\n\t/*\n\t * Clone native IPv6 options from listening socket (if any)\n\t *\n\t * Yes, keeping reference count would be much more clever, but we make\n\t * one more one thing there: reattach optmem to newsk.\n\t */\n\tif (opt != NULL) {\n\t\tnewnp->opt = ipv6_dup_options(newsk, opt);\n\t\tif (opt != np->opt)\n\t\t\tsock_kfree_s(sk, opt, opt->tot_len);\n\t}\n\n\tinet_csk(newsk)->icsk_ext_hdr_len = 0;\n\tif (newnp->opt != NULL)\n\t\tinet_csk(newsk)->icsk_ext_hdr_len = (newnp->opt->opt_nflen +\n\t\t\t\t\t\t     newnp->opt->opt_flen);\n\n\tdccp_sync_mss(newsk, dst_mtu(dst));\n\n\tnewinet->inet_daddr = newinet->inet_saddr = LOOPBACK4_IPV6;\n\tnewinet->inet_rcv_saddr = LOOPBACK4_IPV6;\n\n\tif (__inet_inherit_port(sk, newsk) < 0) {\n\t\tsock_put(newsk);\n\t\tgoto out;\n\t}\n\t__inet6_hash(newsk, NULL);\n\n\treturn newsk;\n\nout_overflow:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);\nout_nonewsk:\n\tdst_release(dst);\nout:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENDROPS);\n\tif (opt != NULL && opt != np->opt)\n\t\tsock_kfree_s(sk, opt, opt->tot_len);\n\treturn NULL;\n}",
        "code_after_change": "static struct sock *dccp_v6_request_recv_sock(struct sock *sk,\n\t\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t\t      struct request_sock *req,\n\t\t\t\t\t      struct dst_entry *dst)\n{\n\tstruct inet6_request_sock *ireq6 = inet6_rsk(req);\n\tstruct ipv6_pinfo *newnp, *np = inet6_sk(sk);\n\tstruct inet_sock *newinet;\n\tstruct dccp6_sock *newdp6;\n\tstruct sock *newsk;\n\tstruct ipv6_txoptions *opt;\n\n\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\t/*\n\t\t *\tv6 mapped\n\t\t */\n\t\tnewsk = dccp_v4_request_recv_sock(sk, skb, req, dst);\n\t\tif (newsk == NULL)\n\t\t\treturn NULL;\n\n\t\tnewdp6 = (struct dccp6_sock *)newsk;\n\t\tnewinet = inet_sk(newsk);\n\t\tnewinet->pinet6 = &newdp6->inet6;\n\t\tnewnp = inet6_sk(newsk);\n\n\t\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\t\tipv6_addr_set_v4mapped(newinet->inet_daddr, &newnp->daddr);\n\n\t\tipv6_addr_set_v4mapped(newinet->inet_saddr, &newnp->saddr);\n\n\t\tipv6_addr_copy(&newnp->rcv_saddr, &newnp->saddr);\n\n\t\tinet_csk(newsk)->icsk_af_ops = &dccp_ipv6_mapped;\n\t\tnewsk->sk_backlog_rcv = dccp_v4_do_rcv;\n\t\tnewnp->pktoptions  = NULL;\n\t\tnewnp->opt\t   = NULL;\n\t\tnewnp->mcast_oif   = inet6_iif(skb);\n\t\tnewnp->mcast_hops  = ipv6_hdr(skb)->hop_limit;\n\n\t\t/*\n\t\t * No need to charge this sock to the relevant IPv6 refcnt debug socks count\n\t\t * here, dccp_create_openreq_child now does this for us, see the comment in\n\t\t * that function for the gory details. -acme\n\t\t */\n\n\t\t/* It is tricky place. Until this moment IPv4 tcp\n\t\t   worked with IPv6 icsk.icsk_af_ops.\n\t\t   Sync it now.\n\t\t */\n\t\tdccp_sync_mss(newsk, inet_csk(newsk)->icsk_pmtu_cookie);\n\n\t\treturn newsk;\n\t}\n\n\topt = np->opt;\n\n\tif (sk_acceptq_is_full(sk))\n\t\tgoto out_overflow;\n\n\tif (dst == NULL) {\n\t\tstruct in6_addr *final_p, final;\n\t\tstruct flowi6 fl6;\n\n\t\tmemset(&fl6, 0, sizeof(fl6));\n\t\tfl6.flowi6_proto = IPPROTO_DCCP;\n\t\tipv6_addr_copy(&fl6.daddr, &ireq6->rmt_addr);\n\t\tfinal_p = fl6_update_dst(&fl6, opt, &final);\n\t\tipv6_addr_copy(&fl6.saddr, &ireq6->loc_addr);\n\t\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n\t\tfl6.fl6_dport = inet_rsk(req)->rmt_port;\n\t\tfl6.fl6_sport = inet_rsk(req)->loc_port;\n\t\tsecurity_sk_classify_flow(sk, flowi6_to_flowi(&fl6));\n\n\t\tdst = ip6_dst_lookup_flow(sk, &fl6, final_p, false);\n\t\tif (IS_ERR(dst))\n\t\t\tgoto out;\n\t}\n\n\tnewsk = dccp_create_openreq_child(sk, req, skb);\n\tif (newsk == NULL)\n\t\tgoto out_nonewsk;\n\n\t/*\n\t * No need to charge this sock to the relevant IPv6 refcnt debug socks\n\t * count here, dccp_create_openreq_child now does this for us, see the\n\t * comment in that function for the gory details. -acme\n\t */\n\n\t__ip6_dst_store(newsk, dst, NULL, NULL);\n\tnewsk->sk_route_caps = dst->dev->features & ~(NETIF_F_IP_CSUM |\n\t\t\t\t\t\t      NETIF_F_TSO);\n\tnewdp6 = (struct dccp6_sock *)newsk;\n\tnewinet = inet_sk(newsk);\n\tnewinet->pinet6 = &newdp6->inet6;\n\tnewnp = inet6_sk(newsk);\n\n\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\tipv6_addr_copy(&newnp->daddr, &ireq6->rmt_addr);\n\tipv6_addr_copy(&newnp->saddr, &ireq6->loc_addr);\n\tipv6_addr_copy(&newnp->rcv_saddr, &ireq6->loc_addr);\n\tnewsk->sk_bound_dev_if = ireq6->iif;\n\n\t/* Now IPv6 options...\n\n\t   First: no IPv4 options.\n\t */\n\tnewinet->inet_opt = NULL;\n\n\t/* Clone RX bits */\n\tnewnp->rxopt.all = np->rxopt.all;\n\n\t/* Clone pktoptions received with SYN */\n\tnewnp->pktoptions = NULL;\n\tif (ireq6->pktopts != NULL) {\n\t\tnewnp->pktoptions = skb_clone(ireq6->pktopts, GFP_ATOMIC);\n\t\tkfree_skb(ireq6->pktopts);\n\t\tireq6->pktopts = NULL;\n\t\tif (newnp->pktoptions)\n\t\t\tskb_set_owner_r(newnp->pktoptions, newsk);\n\t}\n\tnewnp->opt\t  = NULL;\n\tnewnp->mcast_oif  = inet6_iif(skb);\n\tnewnp->mcast_hops = ipv6_hdr(skb)->hop_limit;\n\n\t/*\n\t * Clone native IPv6 options from listening socket (if any)\n\t *\n\t * Yes, keeping reference count would be much more clever, but we make\n\t * one more one thing there: reattach optmem to newsk.\n\t */\n\tif (opt != NULL) {\n\t\tnewnp->opt = ipv6_dup_options(newsk, opt);\n\t\tif (opt != np->opt)\n\t\t\tsock_kfree_s(sk, opt, opt->tot_len);\n\t}\n\n\tinet_csk(newsk)->icsk_ext_hdr_len = 0;\n\tif (newnp->opt != NULL)\n\t\tinet_csk(newsk)->icsk_ext_hdr_len = (newnp->opt->opt_nflen +\n\t\t\t\t\t\t     newnp->opt->opt_flen);\n\n\tdccp_sync_mss(newsk, dst_mtu(dst));\n\n\tnewinet->inet_daddr = newinet->inet_saddr = LOOPBACK4_IPV6;\n\tnewinet->inet_rcv_saddr = LOOPBACK4_IPV6;\n\n\tif (__inet_inherit_port(sk, newsk) < 0) {\n\t\tsock_put(newsk);\n\t\tgoto out;\n\t}\n\t__inet6_hash(newsk, NULL);\n\n\treturn newsk;\n\nout_overflow:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);\nout_nonewsk:\n\tdst_release(dst);\nout:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENDROPS);\n\tif (opt != NULL && opt != np->opt)\n\t\tsock_kfree_s(sk, opt, opt->tot_len);\n\treturn NULL;\n}",
        "patch": "--- code before\n+++ code after\n@@ -106,7 +106,7 @@\n \n \t   First: no IPv4 options.\n \t */\n-\tnewinet->opt = NULL;\n+\tnewinet->inet_opt = NULL;\n \n \t/* Clone RX bits */\n \tnewnp->rxopt.all = np->rxopt.all;",
        "function_modified_lines": {
            "added": [
                "\tnewinet->inet_opt = NULL;"
            ],
            "deleted": [
                "\tnewinet->opt = NULL;"
            ]
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "Race condition in the IP implementation in the Linux kernel before 3.0 might allow remote attackers to cause a denial of service (slab corruption and system crash) by sending packets to an application that sets socket options during the handling of network traffic.",
        "id": 66
    },
    {
        "cve_id": "CVE-2012-3552",
        "code_before_change": "void icmp_send(struct sk_buff *skb_in, int type, int code, __be32 info)\n{\n\tstruct iphdr *iph;\n\tint room;\n\tstruct icmp_bxm icmp_param;\n\tstruct rtable *rt = skb_rtable(skb_in);\n\tstruct ipcm_cookie ipc;\n\t__be32 saddr;\n\tu8  tos;\n\tstruct net *net;\n\tstruct sock *sk;\n\n\tif (!rt)\n\t\tgoto out;\n\tnet = dev_net(rt->dst.dev);\n\n\t/*\n\t *\tFind the original header. It is expected to be valid, of course.\n\t *\tCheck this, icmp_send is called from the most obscure devices\n\t *\tsometimes.\n\t */\n\tiph = ip_hdr(skb_in);\n\n\tif ((u8 *)iph < skb_in->head ||\n\t    (skb_in->network_header + sizeof(*iph)) > skb_in->tail)\n\t\tgoto out;\n\n\t/*\n\t *\tNo replies to physical multicast/broadcast\n\t */\n\tif (skb_in->pkt_type != PACKET_HOST)\n\t\tgoto out;\n\n\t/*\n\t *\tNow check at the protocol level\n\t */\n\tif (rt->rt_flags & (RTCF_BROADCAST | RTCF_MULTICAST))\n\t\tgoto out;\n\n\t/*\n\t *\tOnly reply to fragment 0. We byte re-order the constant\n\t *\tmask for efficiency.\n\t */\n\tif (iph->frag_off & htons(IP_OFFSET))\n\t\tgoto out;\n\n\t/*\n\t *\tIf we send an ICMP error to an ICMP error a mess would result..\n\t */\n\tif (icmp_pointers[type].error) {\n\t\t/*\n\t\t *\tWe are an error, check if we are replying to an\n\t\t *\tICMP error\n\t\t */\n\t\tif (iph->protocol == IPPROTO_ICMP) {\n\t\t\tu8 _inner_type, *itp;\n\n\t\t\titp = skb_header_pointer(skb_in,\n\t\t\t\t\t\t skb_network_header(skb_in) +\n\t\t\t\t\t\t (iph->ihl << 2) +\n\t\t\t\t\t\t offsetof(struct icmphdr,\n\t\t\t\t\t\t\t  type) -\n\t\t\t\t\t\t skb_in->data,\n\t\t\t\t\t\t sizeof(_inner_type),\n\t\t\t\t\t\t &_inner_type);\n\t\t\tif (itp == NULL)\n\t\t\t\tgoto out;\n\n\t\t\t/*\n\t\t\t *\tAssume any unknown ICMP type is an error. This\n\t\t\t *\tisn't specified by the RFC, but think about it..\n\t\t\t */\n\t\t\tif (*itp > NR_ICMP_TYPES ||\n\t\t\t    icmp_pointers[*itp].error)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\tsk = icmp_xmit_lock(net);\n\tif (sk == NULL)\n\t\treturn;\n\n\t/*\n\t *\tConstruct source address and options.\n\t */\n\n\tsaddr = iph->daddr;\n\tif (!(rt->rt_flags & RTCF_LOCAL)) {\n\t\tstruct net_device *dev = NULL;\n\n\t\trcu_read_lock();\n\t\tif (rt_is_input_route(rt) &&\n\t\t    net->ipv4.sysctl_icmp_errors_use_inbound_ifaddr)\n\t\t\tdev = dev_get_by_index_rcu(net, rt->rt_iif);\n\n\t\tif (dev)\n\t\t\tsaddr = inet_select_addr(dev, 0, RT_SCOPE_LINK);\n\t\telse\n\t\t\tsaddr = 0;\n\t\trcu_read_unlock();\n\t}\n\n\ttos = icmp_pointers[type].error ? ((iph->tos & IPTOS_TOS_MASK) |\n\t\t\t\t\t   IPTOS_PREC_INTERNETCONTROL) :\n\t\t\t\t\t  iph->tos;\n\n\tif (ip_options_echo(&icmp_param.replyopts, skb_in))\n\t\tgoto out_unlock;\n\n\n\t/*\n\t *\tPrepare data for ICMP header.\n\t */\n\n\ticmp_param.data.icmph.type\t = type;\n\ticmp_param.data.icmph.code\t = code;\n\ticmp_param.data.icmph.un.gateway = info;\n\ticmp_param.data.icmph.checksum\t = 0;\n\ticmp_param.skb\t  = skb_in;\n\ticmp_param.offset = skb_network_offset(skb_in);\n\tinet_sk(sk)->tos = tos;\n\tipc.addr = iph->saddr;\n\tipc.opt = &icmp_param.replyopts;\n\tipc.tx_flags = 0;\n\n\trt = icmp_route_lookup(net, skb_in, iph, saddr, tos,\n\t\t\t       type, code, &icmp_param);\n\tif (IS_ERR(rt))\n\t\tgoto out_unlock;\n\n\tif (!icmpv4_xrlim_allow(net, rt, type, code))\n\t\tgoto ende;\n\n\t/* RFC says return as much as we can without exceeding 576 bytes. */\n\n\troom = dst_mtu(&rt->dst);\n\tif (room > 576)\n\t\troom = 576;\n\troom -= sizeof(struct iphdr) + icmp_param.replyopts.optlen;\n\troom -= sizeof(struct icmphdr);\n\n\ticmp_param.data_len = skb_in->len - icmp_param.offset;\n\tif (icmp_param.data_len > room)\n\t\ticmp_param.data_len = room;\n\ticmp_param.head_len = sizeof(struct icmphdr);\n\n\ticmp_push_reply(&icmp_param, &ipc, &rt);\nende:\n\tip_rt_put(rt);\nout_unlock:\n\ticmp_xmit_unlock(sk);\nout:;\n}",
        "code_after_change": "void icmp_send(struct sk_buff *skb_in, int type, int code, __be32 info)\n{\n\tstruct iphdr *iph;\n\tint room;\n\tstruct icmp_bxm icmp_param;\n\tstruct rtable *rt = skb_rtable(skb_in);\n\tstruct ipcm_cookie ipc;\n\t__be32 saddr;\n\tu8  tos;\n\tstruct net *net;\n\tstruct sock *sk;\n\n\tif (!rt)\n\t\tgoto out;\n\tnet = dev_net(rt->dst.dev);\n\n\t/*\n\t *\tFind the original header. It is expected to be valid, of course.\n\t *\tCheck this, icmp_send is called from the most obscure devices\n\t *\tsometimes.\n\t */\n\tiph = ip_hdr(skb_in);\n\n\tif ((u8 *)iph < skb_in->head ||\n\t    (skb_in->network_header + sizeof(*iph)) > skb_in->tail)\n\t\tgoto out;\n\n\t/*\n\t *\tNo replies to physical multicast/broadcast\n\t */\n\tif (skb_in->pkt_type != PACKET_HOST)\n\t\tgoto out;\n\n\t/*\n\t *\tNow check at the protocol level\n\t */\n\tif (rt->rt_flags & (RTCF_BROADCAST | RTCF_MULTICAST))\n\t\tgoto out;\n\n\t/*\n\t *\tOnly reply to fragment 0. We byte re-order the constant\n\t *\tmask for efficiency.\n\t */\n\tif (iph->frag_off & htons(IP_OFFSET))\n\t\tgoto out;\n\n\t/*\n\t *\tIf we send an ICMP error to an ICMP error a mess would result..\n\t */\n\tif (icmp_pointers[type].error) {\n\t\t/*\n\t\t *\tWe are an error, check if we are replying to an\n\t\t *\tICMP error\n\t\t */\n\t\tif (iph->protocol == IPPROTO_ICMP) {\n\t\t\tu8 _inner_type, *itp;\n\n\t\t\titp = skb_header_pointer(skb_in,\n\t\t\t\t\t\t skb_network_header(skb_in) +\n\t\t\t\t\t\t (iph->ihl << 2) +\n\t\t\t\t\t\t offsetof(struct icmphdr,\n\t\t\t\t\t\t\t  type) -\n\t\t\t\t\t\t skb_in->data,\n\t\t\t\t\t\t sizeof(_inner_type),\n\t\t\t\t\t\t &_inner_type);\n\t\t\tif (itp == NULL)\n\t\t\t\tgoto out;\n\n\t\t\t/*\n\t\t\t *\tAssume any unknown ICMP type is an error. This\n\t\t\t *\tisn't specified by the RFC, but think about it..\n\t\t\t */\n\t\t\tif (*itp > NR_ICMP_TYPES ||\n\t\t\t    icmp_pointers[*itp].error)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\tsk = icmp_xmit_lock(net);\n\tif (sk == NULL)\n\t\treturn;\n\n\t/*\n\t *\tConstruct source address and options.\n\t */\n\n\tsaddr = iph->daddr;\n\tif (!(rt->rt_flags & RTCF_LOCAL)) {\n\t\tstruct net_device *dev = NULL;\n\n\t\trcu_read_lock();\n\t\tif (rt_is_input_route(rt) &&\n\t\t    net->ipv4.sysctl_icmp_errors_use_inbound_ifaddr)\n\t\t\tdev = dev_get_by_index_rcu(net, rt->rt_iif);\n\n\t\tif (dev)\n\t\t\tsaddr = inet_select_addr(dev, 0, RT_SCOPE_LINK);\n\t\telse\n\t\t\tsaddr = 0;\n\t\trcu_read_unlock();\n\t}\n\n\ttos = icmp_pointers[type].error ? ((iph->tos & IPTOS_TOS_MASK) |\n\t\t\t\t\t   IPTOS_PREC_INTERNETCONTROL) :\n\t\t\t\t\t  iph->tos;\n\n\tif (ip_options_echo(&icmp_param.replyopts.opt.opt, skb_in))\n\t\tgoto out_unlock;\n\n\n\t/*\n\t *\tPrepare data for ICMP header.\n\t */\n\n\ticmp_param.data.icmph.type\t = type;\n\ticmp_param.data.icmph.code\t = code;\n\ticmp_param.data.icmph.un.gateway = info;\n\ticmp_param.data.icmph.checksum\t = 0;\n\ticmp_param.skb\t  = skb_in;\n\ticmp_param.offset = skb_network_offset(skb_in);\n\tinet_sk(sk)->tos = tos;\n\tipc.addr = iph->saddr;\n\tipc.opt = &icmp_param.replyopts.opt;\n\tipc.tx_flags = 0;\n\n\trt = icmp_route_lookup(net, skb_in, iph, saddr, tos,\n\t\t\t       type, code, &icmp_param);\n\tif (IS_ERR(rt))\n\t\tgoto out_unlock;\n\n\tif (!icmpv4_xrlim_allow(net, rt, type, code))\n\t\tgoto ende;\n\n\t/* RFC says return as much as we can without exceeding 576 bytes. */\n\n\troom = dst_mtu(&rt->dst);\n\tif (room > 576)\n\t\troom = 576;\n\troom -= sizeof(struct iphdr) + icmp_param.replyopts.opt.opt.optlen;\n\troom -= sizeof(struct icmphdr);\n\n\ticmp_param.data_len = skb_in->len - icmp_param.offset;\n\tif (icmp_param.data_len > room)\n\t\ticmp_param.data_len = room;\n\ticmp_param.head_len = sizeof(struct icmphdr);\n\n\ticmp_push_reply(&icmp_param, &ipc, &rt);\nende:\n\tip_rt_put(rt);\nout_unlock:\n\ticmp_xmit_unlock(sk);\nout:;\n}",
        "patch": "--- code before\n+++ code after\n@@ -104,7 +104,7 @@\n \t\t\t\t\t   IPTOS_PREC_INTERNETCONTROL) :\n \t\t\t\t\t  iph->tos;\n \n-\tif (ip_options_echo(&icmp_param.replyopts, skb_in))\n+\tif (ip_options_echo(&icmp_param.replyopts.opt.opt, skb_in))\n \t\tgoto out_unlock;\n \n \n@@ -120,7 +120,7 @@\n \ticmp_param.offset = skb_network_offset(skb_in);\n \tinet_sk(sk)->tos = tos;\n \tipc.addr = iph->saddr;\n-\tipc.opt = &icmp_param.replyopts;\n+\tipc.opt = &icmp_param.replyopts.opt;\n \tipc.tx_flags = 0;\n \n \trt = icmp_route_lookup(net, skb_in, iph, saddr, tos,\n@@ -136,7 +136,7 @@\n \troom = dst_mtu(&rt->dst);\n \tif (room > 576)\n \t\troom = 576;\n-\troom -= sizeof(struct iphdr) + icmp_param.replyopts.optlen;\n+\troom -= sizeof(struct iphdr) + icmp_param.replyopts.opt.opt.optlen;\n \troom -= sizeof(struct icmphdr);\n \n \ticmp_param.data_len = skb_in->len - icmp_param.offset;",
        "function_modified_lines": {
            "added": [
                "\tif (ip_options_echo(&icmp_param.replyopts.opt.opt, skb_in))",
                "\tipc.opt = &icmp_param.replyopts.opt;",
                "\troom -= sizeof(struct iphdr) + icmp_param.replyopts.opt.opt.optlen;"
            ],
            "deleted": [
                "\tif (ip_options_echo(&icmp_param.replyopts, skb_in))",
                "\tipc.opt = &icmp_param.replyopts;",
                "\troom -= sizeof(struct iphdr) + icmp_param.replyopts.optlen;"
            ]
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "Race condition in the IP implementation in the Linux kernel before 3.0 might allow remote attackers to cause a denial of service (slab corruption and system crash) by sending packets to an application that sets socket options during the handling of network traffic.",
        "id": 76
    },
    {
        "cve_id": "CVE-2012-3552",
        "code_before_change": "int ip_options_echo(struct ip_options * dopt, struct sk_buff * skb)\n{\n\tstruct ip_options *sopt;\n\tunsigned char *sptr, *dptr;\n\tint soffset, doffset;\n\tint\toptlen;\n\t__be32\tdaddr;\n\n\tmemset(dopt, 0, sizeof(struct ip_options));\n\n\tsopt = &(IPCB(skb)->opt);\n\n\tif (sopt->optlen == 0) {\n\t\tdopt->optlen = 0;\n\t\treturn 0;\n\t}\n\n\tsptr = skb_network_header(skb);\n\tdptr = dopt->__data;\n\n\tdaddr = skb_rtable(skb)->rt_spec_dst;\n\n\tif (sopt->rr) {\n\t\toptlen  = sptr[sopt->rr+1];\n\t\tsoffset = sptr[sopt->rr+2];\n\t\tdopt->rr = dopt->optlen + sizeof(struct iphdr);\n\t\tmemcpy(dptr, sptr+sopt->rr, optlen);\n\t\tif (sopt->rr_needaddr && soffset <= optlen) {\n\t\t\tif (soffset + 3 > optlen)\n\t\t\t\treturn -EINVAL;\n\t\t\tdptr[2] = soffset + 4;\n\t\t\tdopt->rr_needaddr = 1;\n\t\t}\n\t\tdptr += optlen;\n\t\tdopt->optlen += optlen;\n\t}\n\tif (sopt->ts) {\n\t\toptlen = sptr[sopt->ts+1];\n\t\tsoffset = sptr[sopt->ts+2];\n\t\tdopt->ts = dopt->optlen + sizeof(struct iphdr);\n\t\tmemcpy(dptr, sptr+sopt->ts, optlen);\n\t\tif (soffset <= optlen) {\n\t\t\tif (sopt->ts_needaddr) {\n\t\t\t\tif (soffset + 3 > optlen)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tdopt->ts_needaddr = 1;\n\t\t\t\tsoffset += 4;\n\t\t\t}\n\t\t\tif (sopt->ts_needtime) {\n\t\t\t\tif (soffset + 3 > optlen)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tif ((dptr[3]&0xF) != IPOPT_TS_PRESPEC) {\n\t\t\t\t\tdopt->ts_needtime = 1;\n\t\t\t\t\tsoffset += 4;\n\t\t\t\t} else {\n\t\t\t\t\tdopt->ts_needtime = 0;\n\n\t\t\t\t\tif (soffset + 7 <= optlen) {\n\t\t\t\t\t\t__be32 addr;\n\n\t\t\t\t\t\tmemcpy(&addr, dptr+soffset-1, 4);\n\t\t\t\t\t\tif (inet_addr_type(dev_net(skb_dst(skb)->dev), addr) != RTN_UNICAST) {\n\t\t\t\t\t\t\tdopt->ts_needtime = 1;\n\t\t\t\t\t\t\tsoffset += 8;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdptr[2] = soffset;\n\t\t}\n\t\tdptr += optlen;\n\t\tdopt->optlen += optlen;\n\t}\n\tif (sopt->srr) {\n\t\tunsigned char * start = sptr+sopt->srr;\n\t\t__be32 faddr;\n\n\t\toptlen  = start[1];\n\t\tsoffset = start[2];\n\t\tdoffset = 0;\n\t\tif (soffset > optlen)\n\t\t\tsoffset = optlen + 1;\n\t\tsoffset -= 4;\n\t\tif (soffset > 3) {\n\t\t\tmemcpy(&faddr, &start[soffset-1], 4);\n\t\t\tfor (soffset-=4, doffset=4; soffset > 3; soffset-=4, doffset+=4)\n\t\t\t\tmemcpy(&dptr[doffset-1], &start[soffset-1], 4);\n\t\t\t/*\n\t\t\t * RFC1812 requires to fix illegal source routes.\n\t\t\t */\n\t\t\tif (memcmp(&ip_hdr(skb)->saddr,\n\t\t\t\t   &start[soffset + 3], 4) == 0)\n\t\t\t\tdoffset -= 4;\n\t\t}\n\t\tif (doffset > 3) {\n\t\t\tmemcpy(&start[doffset-1], &daddr, 4);\n\t\t\tdopt->faddr = faddr;\n\t\t\tdptr[0] = start[0];\n\t\t\tdptr[1] = doffset+3;\n\t\t\tdptr[2] = 4;\n\t\t\tdptr += doffset+3;\n\t\t\tdopt->srr = dopt->optlen + sizeof(struct iphdr);\n\t\t\tdopt->optlen += doffset+3;\n\t\t\tdopt->is_strictroute = sopt->is_strictroute;\n\t\t}\n\t}\n\tif (sopt->cipso) {\n\t\toptlen  = sptr[sopt->cipso+1];\n\t\tdopt->cipso = dopt->optlen+sizeof(struct iphdr);\n\t\tmemcpy(dptr, sptr+sopt->cipso, optlen);\n\t\tdptr += optlen;\n\t\tdopt->optlen += optlen;\n\t}\n\twhile (dopt->optlen & 3) {\n\t\t*dptr++ = IPOPT_END;\n\t\tdopt->optlen++;\n\t}\n\treturn 0;\n}",
        "code_after_change": "int ip_options_echo(struct ip_options *dopt, struct sk_buff *skb)\n{\n\tconst struct ip_options *sopt;\n\tunsigned char *sptr, *dptr;\n\tint soffset, doffset;\n\tint\toptlen;\n\t__be32\tdaddr;\n\n\tmemset(dopt, 0, sizeof(struct ip_options));\n\n\tsopt = &(IPCB(skb)->opt);\n\n\tif (sopt->optlen == 0)\n\t\treturn 0;\n\n\tsptr = skb_network_header(skb);\n\tdptr = dopt->__data;\n\n\tdaddr = skb_rtable(skb)->rt_spec_dst;\n\n\tif (sopt->rr) {\n\t\toptlen  = sptr[sopt->rr+1];\n\t\tsoffset = sptr[sopt->rr+2];\n\t\tdopt->rr = dopt->optlen + sizeof(struct iphdr);\n\t\tmemcpy(dptr, sptr+sopt->rr, optlen);\n\t\tif (sopt->rr_needaddr && soffset <= optlen) {\n\t\t\tif (soffset + 3 > optlen)\n\t\t\t\treturn -EINVAL;\n\t\t\tdptr[2] = soffset + 4;\n\t\t\tdopt->rr_needaddr = 1;\n\t\t}\n\t\tdptr += optlen;\n\t\tdopt->optlen += optlen;\n\t}\n\tif (sopt->ts) {\n\t\toptlen = sptr[sopt->ts+1];\n\t\tsoffset = sptr[sopt->ts+2];\n\t\tdopt->ts = dopt->optlen + sizeof(struct iphdr);\n\t\tmemcpy(dptr, sptr+sopt->ts, optlen);\n\t\tif (soffset <= optlen) {\n\t\t\tif (sopt->ts_needaddr) {\n\t\t\t\tif (soffset + 3 > optlen)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tdopt->ts_needaddr = 1;\n\t\t\t\tsoffset += 4;\n\t\t\t}\n\t\t\tif (sopt->ts_needtime) {\n\t\t\t\tif (soffset + 3 > optlen)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tif ((dptr[3]&0xF) != IPOPT_TS_PRESPEC) {\n\t\t\t\t\tdopt->ts_needtime = 1;\n\t\t\t\t\tsoffset += 4;\n\t\t\t\t} else {\n\t\t\t\t\tdopt->ts_needtime = 0;\n\n\t\t\t\t\tif (soffset + 7 <= optlen) {\n\t\t\t\t\t\t__be32 addr;\n\n\t\t\t\t\t\tmemcpy(&addr, dptr+soffset-1, 4);\n\t\t\t\t\t\tif (inet_addr_type(dev_net(skb_dst(skb)->dev), addr) != RTN_UNICAST) {\n\t\t\t\t\t\t\tdopt->ts_needtime = 1;\n\t\t\t\t\t\t\tsoffset += 8;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdptr[2] = soffset;\n\t\t}\n\t\tdptr += optlen;\n\t\tdopt->optlen += optlen;\n\t}\n\tif (sopt->srr) {\n\t\tunsigned char *start = sptr+sopt->srr;\n\t\t__be32 faddr;\n\n\t\toptlen  = start[1];\n\t\tsoffset = start[2];\n\t\tdoffset = 0;\n\t\tif (soffset > optlen)\n\t\t\tsoffset = optlen + 1;\n\t\tsoffset -= 4;\n\t\tif (soffset > 3) {\n\t\t\tmemcpy(&faddr, &start[soffset-1], 4);\n\t\t\tfor (soffset-=4, doffset=4; soffset > 3; soffset-=4, doffset+=4)\n\t\t\t\tmemcpy(&dptr[doffset-1], &start[soffset-1], 4);\n\t\t\t/*\n\t\t\t * RFC1812 requires to fix illegal source routes.\n\t\t\t */\n\t\t\tif (memcmp(&ip_hdr(skb)->saddr,\n\t\t\t\t   &start[soffset + 3], 4) == 0)\n\t\t\t\tdoffset -= 4;\n\t\t}\n\t\tif (doffset > 3) {\n\t\t\tmemcpy(&start[doffset-1], &daddr, 4);\n\t\t\tdopt->faddr = faddr;\n\t\t\tdptr[0] = start[0];\n\t\t\tdptr[1] = doffset+3;\n\t\t\tdptr[2] = 4;\n\t\t\tdptr += doffset+3;\n\t\t\tdopt->srr = dopt->optlen + sizeof(struct iphdr);\n\t\t\tdopt->optlen += doffset+3;\n\t\t\tdopt->is_strictroute = sopt->is_strictroute;\n\t\t}\n\t}\n\tif (sopt->cipso) {\n\t\toptlen  = sptr[sopt->cipso+1];\n\t\tdopt->cipso = dopt->optlen+sizeof(struct iphdr);\n\t\tmemcpy(dptr, sptr+sopt->cipso, optlen);\n\t\tdptr += optlen;\n\t\tdopt->optlen += optlen;\n\t}\n\twhile (dopt->optlen & 3) {\n\t\t*dptr++ = IPOPT_END;\n\t\tdopt->optlen++;\n\t}\n\treturn 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -1,6 +1,6 @@\n-int ip_options_echo(struct ip_options * dopt, struct sk_buff * skb)\n+int ip_options_echo(struct ip_options *dopt, struct sk_buff *skb)\n {\n-\tstruct ip_options *sopt;\n+\tconst struct ip_options *sopt;\n \tunsigned char *sptr, *dptr;\n \tint soffset, doffset;\n \tint\toptlen;\n@@ -10,10 +10,8 @@\n \n \tsopt = &(IPCB(skb)->opt);\n \n-\tif (sopt->optlen == 0) {\n-\t\tdopt->optlen = 0;\n+\tif (sopt->optlen == 0)\n \t\treturn 0;\n-\t}\n \n \tsptr = skb_network_header(skb);\n \tdptr = dopt->__data;\n@@ -72,7 +70,7 @@\n \t\tdopt->optlen += optlen;\n \t}\n \tif (sopt->srr) {\n-\t\tunsigned char * start = sptr+sopt->srr;\n+\t\tunsigned char *start = sptr+sopt->srr;\n \t\t__be32 faddr;\n \n \t\toptlen  = start[1];",
        "function_modified_lines": {
            "added": [
                "int ip_options_echo(struct ip_options *dopt, struct sk_buff *skb)",
                "\tconst struct ip_options *sopt;",
                "\tif (sopt->optlen == 0)",
                "\t\tunsigned char *start = sptr+sopt->srr;"
            ],
            "deleted": [
                "int ip_options_echo(struct ip_options * dopt, struct sk_buff * skb)",
                "\tstruct ip_options *sopt;",
                "\tif (sopt->optlen == 0) {",
                "\t\tdopt->optlen = 0;",
                "\t}",
                "\t\tunsigned char * start = sptr+sopt->srr;"
            ]
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "Race condition in the IP implementation in the Linux kernel before 3.0 might allow remote attackers to cause a denial of service (slab corruption and system crash) by sending packets to an application that sets socket options during the handling of network traffic.",
        "id": 81
    },
    {
        "cve_id": "CVE-2012-3552",
        "code_before_change": "void inet_sock_destruct(struct sock *sk)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\n\t__skb_queue_purge(&sk->sk_receive_queue);\n\t__skb_queue_purge(&sk->sk_error_queue);\n\n\tsk_mem_reclaim(sk);\n\n\tif (sk->sk_type == SOCK_STREAM && sk->sk_state != TCP_CLOSE) {\n\t\tpr_err(\"Attempt to release TCP socket in state %d %p\\n\",\n\t\t       sk->sk_state, sk);\n\t\treturn;\n\t}\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tpr_err(\"Attempt to release alive inet socket %p\\n\", sk);\n\t\treturn;\n\t}\n\n\tWARN_ON(atomic_read(&sk->sk_rmem_alloc));\n\tWARN_ON(atomic_read(&sk->sk_wmem_alloc));\n\tWARN_ON(sk->sk_wmem_queued);\n\tWARN_ON(sk->sk_forward_alloc);\n\n\tkfree(inet->opt);\n\tdst_release(rcu_dereference_check(sk->sk_dst_cache, 1));\n\tsk_refcnt_debug_dec(sk);\n}",
        "code_after_change": "void inet_sock_destruct(struct sock *sk)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\n\t__skb_queue_purge(&sk->sk_receive_queue);\n\t__skb_queue_purge(&sk->sk_error_queue);\n\n\tsk_mem_reclaim(sk);\n\n\tif (sk->sk_type == SOCK_STREAM && sk->sk_state != TCP_CLOSE) {\n\t\tpr_err(\"Attempt to release TCP socket in state %d %p\\n\",\n\t\t       sk->sk_state, sk);\n\t\treturn;\n\t}\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tpr_err(\"Attempt to release alive inet socket %p\\n\", sk);\n\t\treturn;\n\t}\n\n\tWARN_ON(atomic_read(&sk->sk_rmem_alloc));\n\tWARN_ON(atomic_read(&sk->sk_wmem_alloc));\n\tWARN_ON(sk->sk_wmem_queued);\n\tWARN_ON(sk->sk_forward_alloc);\n\n\tkfree(rcu_dereference_protected(inet->inet_opt, 1));\n\tdst_release(rcu_dereference_check(sk->sk_dst_cache, 1));\n\tsk_refcnt_debug_dec(sk);\n}",
        "patch": "--- code before\n+++ code after\n@@ -22,7 +22,7 @@\n \tWARN_ON(sk->sk_wmem_queued);\n \tWARN_ON(sk->sk_forward_alloc);\n \n-\tkfree(inet->opt);\n+\tkfree(rcu_dereference_protected(inet->inet_opt, 1));\n \tdst_release(rcu_dereference_check(sk->sk_dst_cache, 1));\n \tsk_refcnt_debug_dec(sk);\n }",
        "function_modified_lines": {
            "added": [
                "\tkfree(rcu_dereference_protected(inet->inet_opt, 1));"
            ],
            "deleted": [
                "\tkfree(inet->opt);"
            ]
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "Race condition in the IP implementation in the Linux kernel before 3.0 might allow remote attackers to cause a denial of service (slab corruption and system crash) by sending packets to an application that sets socket options during the handling of network traffic.",
        "id": 68
    },
    {
        "cve_id": "CVE-2012-3552",
        "code_before_change": "static int l2tp_ip_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg, size_t len)\n{\n\tstruct sk_buff *skb;\n\tint rc;\n\tstruct l2tp_ip_sock *lsa = l2tp_ip_sk(sk);\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ip_options *opt = inet->opt;\n\tstruct rtable *rt = NULL;\n\tint connected = 0;\n\t__be32 daddr;\n\n\tif (sock_flag(sk, SOCK_DEAD))\n\t\treturn -ENOTCONN;\n\n\t/* Get and verify the address. */\n\tif (msg->msg_name) {\n\t\tstruct sockaddr_l2tpip *lip = (struct sockaddr_l2tpip *) msg->msg_name;\n\t\tif (msg->msg_namelen < sizeof(*lip))\n\t\t\treturn -EINVAL;\n\n\t\tif (lip->l2tp_family != AF_INET) {\n\t\t\tif (lip->l2tp_family != AF_UNSPEC)\n\t\t\t\treturn -EAFNOSUPPORT;\n\t\t}\n\n\t\tdaddr = lip->l2tp_addr.s_addr;\n\t} else {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -EDESTADDRREQ;\n\n\t\tdaddr = inet->inet_daddr;\n\t\tconnected = 1;\n\t}\n\n\t/* Allocate a socket buffer */\n\trc = -ENOMEM;\n\tskb = sock_wmalloc(sk, 2 + NET_SKB_PAD + sizeof(struct iphdr) +\n\t\t\t   4 + len, 0, GFP_KERNEL);\n\tif (!skb)\n\t\tgoto error;\n\n\t/* Reserve space for headers, putting IP header on 4-byte boundary. */\n\tskb_reserve(skb, 2 + NET_SKB_PAD);\n\tskb_reset_network_header(skb);\n\tskb_reserve(skb, sizeof(struct iphdr));\n\tskb_reset_transport_header(skb);\n\n\t/* Insert 0 session_id */\n\t*((__be32 *) skb_put(skb, 4)) = 0;\n\n\t/* Copy user data into skb */\n\trc = memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len);\n\tif (rc < 0) {\n\t\tkfree_skb(skb);\n\t\tgoto error;\n\t}\n\n\tif (connected)\n\t\trt = (struct rtable *) __sk_dst_check(sk, 0);\n\n\tif (rt == NULL) {\n\t\t/* Use correct destination address if we have options. */\n\t\tif (opt && opt->srr)\n\t\t\tdaddr = opt->faddr;\n\n\t\t/* If this fails, retransmit mechanism of transport layer will\n\t\t * keep trying until route appears or the connection times\n\t\t * itself out.\n\t\t */\n\t\trt = ip_route_output_ports(sock_net(sk), sk,\n\t\t\t\t\t   daddr, inet->inet_saddr,\n\t\t\t\t\t   inet->inet_dport, inet->inet_sport,\n\t\t\t\t\t   sk->sk_protocol, RT_CONN_FLAGS(sk),\n\t\t\t\t\t   sk->sk_bound_dev_if);\n\t\tif (IS_ERR(rt))\n\t\t\tgoto no_route;\n\t\tsk_setup_caps(sk, &rt->dst);\n\t}\n\tskb_dst_set(skb, dst_clone(&rt->dst));\n\n\t/* Queue the packet to IP for output */\n\trc = ip_queue_xmit(skb);\n\nerror:\n\t/* Update stats */\n\tif (rc >= 0) {\n\t\tlsa->tx_packets++;\n\t\tlsa->tx_bytes += len;\n\t\trc = len;\n\t} else {\n\t\tlsa->tx_errors++;\n\t}\n\n\treturn rc;\n\nno_route:\n\tIP_INC_STATS(sock_net(sk), IPSTATS_MIB_OUTNOROUTES);\n\tkfree_skb(skb);\n\treturn -EHOSTUNREACH;\n}",
        "code_after_change": "static int l2tp_ip_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg, size_t len)\n{\n\tstruct sk_buff *skb;\n\tint rc;\n\tstruct l2tp_ip_sock *lsa = l2tp_ip_sk(sk);\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct rtable *rt = NULL;\n\tint connected = 0;\n\t__be32 daddr;\n\n\tif (sock_flag(sk, SOCK_DEAD))\n\t\treturn -ENOTCONN;\n\n\t/* Get and verify the address. */\n\tif (msg->msg_name) {\n\t\tstruct sockaddr_l2tpip *lip = (struct sockaddr_l2tpip *) msg->msg_name;\n\t\tif (msg->msg_namelen < sizeof(*lip))\n\t\t\treturn -EINVAL;\n\n\t\tif (lip->l2tp_family != AF_INET) {\n\t\t\tif (lip->l2tp_family != AF_UNSPEC)\n\t\t\t\treturn -EAFNOSUPPORT;\n\t\t}\n\n\t\tdaddr = lip->l2tp_addr.s_addr;\n\t} else {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -EDESTADDRREQ;\n\n\t\tdaddr = inet->inet_daddr;\n\t\tconnected = 1;\n\t}\n\n\t/* Allocate a socket buffer */\n\trc = -ENOMEM;\n\tskb = sock_wmalloc(sk, 2 + NET_SKB_PAD + sizeof(struct iphdr) +\n\t\t\t   4 + len, 0, GFP_KERNEL);\n\tif (!skb)\n\t\tgoto error;\n\n\t/* Reserve space for headers, putting IP header on 4-byte boundary. */\n\tskb_reserve(skb, 2 + NET_SKB_PAD);\n\tskb_reset_network_header(skb);\n\tskb_reserve(skb, sizeof(struct iphdr));\n\tskb_reset_transport_header(skb);\n\n\t/* Insert 0 session_id */\n\t*((__be32 *) skb_put(skb, 4)) = 0;\n\n\t/* Copy user data into skb */\n\trc = memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len);\n\tif (rc < 0) {\n\t\tkfree_skb(skb);\n\t\tgoto error;\n\t}\n\n\tif (connected)\n\t\trt = (struct rtable *) __sk_dst_check(sk, 0);\n\n\tif (rt == NULL) {\n\t\tstruct ip_options_rcu *inet_opt;\n\n\t\tinet_opt = rcu_dereference_protected(inet->inet_opt,\n\t\t\t\t\t\t     sock_owned_by_user(sk));\n\n\t\t/* Use correct destination address if we have options. */\n\t\tif (inet_opt && inet_opt->opt.srr)\n\t\t\tdaddr = inet_opt->opt.faddr;\n\n\t\t/* If this fails, retransmit mechanism of transport layer will\n\t\t * keep trying until route appears or the connection times\n\t\t * itself out.\n\t\t */\n\t\trt = ip_route_output_ports(sock_net(sk), sk,\n\t\t\t\t\t   daddr, inet->inet_saddr,\n\t\t\t\t\t   inet->inet_dport, inet->inet_sport,\n\t\t\t\t\t   sk->sk_protocol, RT_CONN_FLAGS(sk),\n\t\t\t\t\t   sk->sk_bound_dev_if);\n\t\tif (IS_ERR(rt))\n\t\t\tgoto no_route;\n\t\tsk_setup_caps(sk, &rt->dst);\n\t}\n\tskb_dst_set(skb, dst_clone(&rt->dst));\n\n\t/* Queue the packet to IP for output */\n\trc = ip_queue_xmit(skb);\n\nerror:\n\t/* Update stats */\n\tif (rc >= 0) {\n\t\tlsa->tx_packets++;\n\t\tlsa->tx_bytes += len;\n\t\trc = len;\n\t} else {\n\t\tlsa->tx_errors++;\n\t}\n\n\treturn rc;\n\nno_route:\n\tIP_INC_STATS(sock_net(sk), IPSTATS_MIB_OUTNOROUTES);\n\tkfree_skb(skb);\n\treturn -EHOSTUNREACH;\n}",
        "patch": "--- code before\n+++ code after\n@@ -4,7 +4,6 @@\n \tint rc;\n \tstruct l2tp_ip_sock *lsa = l2tp_ip_sk(sk);\n \tstruct inet_sock *inet = inet_sk(sk);\n-\tstruct ip_options *opt = inet->opt;\n \tstruct rtable *rt = NULL;\n \tint connected = 0;\n \t__be32 daddr;\n@@ -59,9 +58,14 @@\n \t\trt = (struct rtable *) __sk_dst_check(sk, 0);\n \n \tif (rt == NULL) {\n+\t\tstruct ip_options_rcu *inet_opt;\n+\n+\t\tinet_opt = rcu_dereference_protected(inet->inet_opt,\n+\t\t\t\t\t\t     sock_owned_by_user(sk));\n+\n \t\t/* Use correct destination address if we have options. */\n-\t\tif (opt && opt->srr)\n-\t\t\tdaddr = opt->faddr;\n+\t\tif (inet_opt && inet_opt->opt.srr)\n+\t\t\tdaddr = inet_opt->opt.faddr;\n \n \t\t/* If this fails, retransmit mechanism of transport layer will\n \t\t * keep trying until route appears or the connection times",
        "function_modified_lines": {
            "added": [
                "\t\tstruct ip_options_rcu *inet_opt;",
                "",
                "\t\tinet_opt = rcu_dereference_protected(inet->inet_opt,",
                "\t\t\t\t\t\t     sock_owned_by_user(sk));",
                "",
                "\t\tif (inet_opt && inet_opt->opt.srr)",
                "\t\t\tdaddr = inet_opt->opt.faddr;"
            ],
            "deleted": [
                "\tstruct ip_options *opt = inet->opt;",
                "\t\tif (opt && opt->srr)",
                "\t\t\tdaddr = opt->faddr;"
            ]
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "Race condition in the IP implementation in the Linux kernel before 3.0 might allow remote attackers to cause a denial of service (slab corruption and system crash) by sending packets to an application that sets socket options during the handling of network traffic.",
        "id": 94
    },
    {
        "cve_id": "CVE-2019-19537",
        "code_before_change": "int usb_register_dev(struct usb_interface *intf,\n\t\t     struct usb_class_driver *class_driver)\n{\n\tint retval;\n\tint minor_base = class_driver->minor_base;\n\tint minor;\n\tchar name[20];\n\n#ifdef CONFIG_USB_DYNAMIC_MINORS\n\t/*\n\t * We don't care what the device tries to start at, we want to start\n\t * at zero to pack the devices into the smallest available space with\n\t * no holes in the minor range.\n\t */\n\tminor_base = 0;\n#endif\n\n\tif (class_driver->fops == NULL)\n\t\treturn -EINVAL;\n\tif (intf->minor >= 0)\n\t\treturn -EADDRINUSE;\n\n\tmutex_lock(&init_usb_class_mutex);\n\tretval = init_usb_class();\n\tmutex_unlock(&init_usb_class_mutex);\n\n\tif (retval)\n\t\treturn retval;\n\n\tdev_dbg(&intf->dev, \"looking for a minor, starting at %d\\n\", minor_base);\n\n\tdown_write(&minor_rwsem);\n\tfor (minor = minor_base; minor < MAX_USB_MINORS; ++minor) {\n\t\tif (usb_minors[minor])\n\t\t\tcontinue;\n\n\t\tusb_minors[minor] = class_driver->fops;\n\t\tintf->minor = minor;\n\t\tbreak;\n\t}\n\tup_write(&minor_rwsem);\n\tif (intf->minor < 0)\n\t\treturn -EXFULL;\n\n\t/* create a usb class device for this usb interface */\n\tsnprintf(name, sizeof(name), class_driver->name, minor - minor_base);\n\tintf->usb_dev = device_create(usb_class->class, &intf->dev,\n\t\t\t\t      MKDEV(USB_MAJOR, minor), class_driver,\n\t\t\t\t      \"%s\", kbasename(name));\n\tif (IS_ERR(intf->usb_dev)) {\n\t\tdown_write(&minor_rwsem);\n\t\tusb_minors[minor] = NULL;\n\t\tintf->minor = -1;\n\t\tup_write(&minor_rwsem);\n\t\tretval = PTR_ERR(intf->usb_dev);\n\t}\n\treturn retval;\n}",
        "code_after_change": "int usb_register_dev(struct usb_interface *intf,\n\t\t     struct usb_class_driver *class_driver)\n{\n\tint retval;\n\tint minor_base = class_driver->minor_base;\n\tint minor;\n\tchar name[20];\n\n#ifdef CONFIG_USB_DYNAMIC_MINORS\n\t/*\n\t * We don't care what the device tries to start at, we want to start\n\t * at zero to pack the devices into the smallest available space with\n\t * no holes in the minor range.\n\t */\n\tminor_base = 0;\n#endif\n\n\tif (class_driver->fops == NULL)\n\t\treturn -EINVAL;\n\tif (intf->minor >= 0)\n\t\treturn -EADDRINUSE;\n\n\tmutex_lock(&init_usb_class_mutex);\n\tretval = init_usb_class();\n\tmutex_unlock(&init_usb_class_mutex);\n\n\tif (retval)\n\t\treturn retval;\n\n\tdev_dbg(&intf->dev, \"looking for a minor, starting at %d\\n\", minor_base);\n\n\tdown_write(&minor_rwsem);\n\tfor (minor = minor_base; minor < MAX_USB_MINORS; ++minor) {\n\t\tif (usb_minors[minor])\n\t\t\tcontinue;\n\n\t\tusb_minors[minor] = class_driver->fops;\n\t\tintf->minor = minor;\n\t\tbreak;\n\t}\n\tif (intf->minor < 0) {\n\t\tup_write(&minor_rwsem);\n\t\treturn -EXFULL;\n\t}\n\n\t/* create a usb class device for this usb interface */\n\tsnprintf(name, sizeof(name), class_driver->name, minor - minor_base);\n\tintf->usb_dev = device_create(usb_class->class, &intf->dev,\n\t\t\t\t      MKDEV(USB_MAJOR, minor), class_driver,\n\t\t\t\t      \"%s\", kbasename(name));\n\tif (IS_ERR(intf->usb_dev)) {\n\t\tusb_minors[minor] = NULL;\n\t\tintf->minor = -1;\n\t\tretval = PTR_ERR(intf->usb_dev);\n\t}\n\tup_write(&minor_rwsem);\n\treturn retval;\n}",
        "patch": "--- code before\n+++ code after\n@@ -38,9 +38,10 @@\n \t\tintf->minor = minor;\n \t\tbreak;\n \t}\n-\tup_write(&minor_rwsem);\n-\tif (intf->minor < 0)\n+\tif (intf->minor < 0) {\n+\t\tup_write(&minor_rwsem);\n \t\treturn -EXFULL;\n+\t}\n \n \t/* create a usb class device for this usb interface */\n \tsnprintf(name, sizeof(name), class_driver->name, minor - minor_base);\n@@ -48,11 +49,10 @@\n \t\t\t\t      MKDEV(USB_MAJOR, minor), class_driver,\n \t\t\t\t      \"%s\", kbasename(name));\n \tif (IS_ERR(intf->usb_dev)) {\n-\t\tdown_write(&minor_rwsem);\n \t\tusb_minors[minor] = NULL;\n \t\tintf->minor = -1;\n-\t\tup_write(&minor_rwsem);\n \t\tretval = PTR_ERR(intf->usb_dev);\n \t}\n+\tup_write(&minor_rwsem);\n \treturn retval;\n }",
        "function_modified_lines": {
            "added": [
                "\tif (intf->minor < 0) {",
                "\t\tup_write(&minor_rwsem);",
                "\t}",
                "\tup_write(&minor_rwsem);"
            ],
            "deleted": [
                "\tup_write(&minor_rwsem);",
                "\tif (intf->minor < 0)",
                "\t\tdown_write(&minor_rwsem);",
                "\t\tup_write(&minor_rwsem);"
            ]
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "In the Linux kernel before 5.2.10, there is a race condition bug that can be caused by a malicious USB device in the USB character device driver layer, aka CID-303911cfc5b9. This affects drivers/usb/core/file.c.",
        "id": 2220
    },
    {
        "cve_id": "CVE-2020-29369",
        "code_before_change": "static void\ndetach_vmas_to_be_unmapped(struct mm_struct *mm, struct vm_area_struct *vma,\n\tstruct vm_area_struct *prev, unsigned long end)\n{\n\tstruct vm_area_struct **insertion_point;\n\tstruct vm_area_struct *tail_vma = NULL;\n\n\tinsertion_point = (prev ? &prev->vm_next : &mm->mmap);\n\tvma->vm_prev = NULL;\n\tdo {\n\t\tvma_rb_erase(vma, &mm->mm_rb);\n\t\tmm->map_count--;\n\t\ttail_vma = vma;\n\t\tvma = vma->vm_next;\n\t} while (vma && vma->vm_start < end);\n\t*insertion_point = vma;\n\tif (vma) {\n\t\tvma->vm_prev = prev;\n\t\tvma_gap_update(vma);\n\t} else\n\t\tmm->highest_vm_end = prev ? vm_end_gap(prev) : 0;\n\ttail_vma->vm_next = NULL;\n\n\t/* Kill the cache */\n\tvmacache_invalidate(mm);\n}",
        "code_after_change": "static bool\ndetach_vmas_to_be_unmapped(struct mm_struct *mm, struct vm_area_struct *vma,\n\tstruct vm_area_struct *prev, unsigned long end)\n{\n\tstruct vm_area_struct **insertion_point;\n\tstruct vm_area_struct *tail_vma = NULL;\n\n\tinsertion_point = (prev ? &prev->vm_next : &mm->mmap);\n\tvma->vm_prev = NULL;\n\tdo {\n\t\tvma_rb_erase(vma, &mm->mm_rb);\n\t\tmm->map_count--;\n\t\ttail_vma = vma;\n\t\tvma = vma->vm_next;\n\t} while (vma && vma->vm_start < end);\n\t*insertion_point = vma;\n\tif (vma) {\n\t\tvma->vm_prev = prev;\n\t\tvma_gap_update(vma);\n\t} else\n\t\tmm->highest_vm_end = prev ? vm_end_gap(prev) : 0;\n\ttail_vma->vm_next = NULL;\n\n\t/* Kill the cache */\n\tvmacache_invalidate(mm);\n\n\t/*\n\t * Do not downgrade mmap_lock if we are next to VM_GROWSDOWN or\n\t * VM_GROWSUP VMA. Such VMAs can change their size under\n\t * down_read(mmap_lock) and collide with the VMA we are about to unmap.\n\t */\n\tif (vma && (vma->vm_flags & VM_GROWSDOWN))\n\t\treturn false;\n\tif (prev && (prev->vm_flags & VM_GROWSUP))\n\t\treturn false;\n\treturn true;\n}",
        "patch": "--- code before\n+++ code after\n@@ -1,4 +1,4 @@\n-static void\n+static bool\n detach_vmas_to_be_unmapped(struct mm_struct *mm, struct vm_area_struct *vma,\n \tstruct vm_area_struct *prev, unsigned long end)\n {\n@@ -23,4 +23,15 @@\n \n \t/* Kill the cache */\n \tvmacache_invalidate(mm);\n+\n+\t/*\n+\t * Do not downgrade mmap_lock if we are next to VM_GROWSDOWN or\n+\t * VM_GROWSUP VMA. Such VMAs can change their size under\n+\t * down_read(mmap_lock) and collide with the VMA we are about to unmap.\n+\t */\n+\tif (vma && (vma->vm_flags & VM_GROWSDOWN))\n+\t\treturn false;\n+\tif (prev && (prev->vm_flags & VM_GROWSUP))\n+\t\treturn false;\n+\treturn true;\n }",
        "function_modified_lines": {
            "added": [
                "static bool",
                "",
                "\t/*",
                "\t * Do not downgrade mmap_lock if we are next to VM_GROWSDOWN or",
                "\t * VM_GROWSUP VMA. Such VMAs can change their size under",
                "\t * down_read(mmap_lock) and collide with the VMA we are about to unmap.",
                "\t */",
                "\tif (vma && (vma->vm_flags & VM_GROWSDOWN))",
                "\t\treturn false;",
                "\tif (prev && (prev->vm_flags & VM_GROWSUP))",
                "\t\treturn false;",
                "\treturn true;"
            ],
            "deleted": [
                "static void"
            ]
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "An issue was discovered in mm/mmap.c in the Linux kernel before 5.7.11. There is a race condition between certain expand functions (expand_downwards and expand_upwards) and page-table free operations from an munmap call, aka CID-246c320a8cfe.",
        "id": 2663
    },
    {
        "cve_id": "CVE-2021-4203",
        "code_before_change": "static void __sk_destruct(struct rcu_head *head)\n{\n\tstruct sock *sk = container_of(head, struct sock, sk_rcu);\n\tstruct sk_filter *filter;\n\n\tif (sk->sk_destruct)\n\t\tsk->sk_destruct(sk);\n\n\tfilter = rcu_dereference_check(sk->sk_filter,\n\t\t\t\t       refcount_read(&sk->sk_wmem_alloc) == 0);\n\tif (filter) {\n\t\tsk_filter_uncharge(sk, filter);\n\t\tRCU_INIT_POINTER(sk->sk_filter, NULL);\n\t}\n\n\tsock_disable_timestamp(sk, SK_FLAGS_TIMESTAMP);\n\n#ifdef CONFIG_BPF_SYSCALL\n\tbpf_sk_storage_free(sk);\n#endif\n\n\tif (atomic_read(&sk->sk_omem_alloc))\n\t\tpr_debug(\"%s: optmem leakage (%d bytes) detected\\n\",\n\t\t\t __func__, atomic_read(&sk->sk_omem_alloc));\n\n\tif (sk->sk_frag.page) {\n\t\tput_page(sk->sk_frag.page);\n\t\tsk->sk_frag.page = NULL;\n\t}\n\n\tif (sk->sk_peer_cred)\n\t\tput_cred(sk->sk_peer_cred);\n\tput_pid(sk->sk_peer_pid);\n\tif (likely(sk->sk_net_refcnt))\n\t\tput_net(sock_net(sk));\n\tsk_prot_free(sk->sk_prot_creator, sk);\n}",
        "code_after_change": "static void __sk_destruct(struct rcu_head *head)\n{\n\tstruct sock *sk = container_of(head, struct sock, sk_rcu);\n\tstruct sk_filter *filter;\n\n\tif (sk->sk_destruct)\n\t\tsk->sk_destruct(sk);\n\n\tfilter = rcu_dereference_check(sk->sk_filter,\n\t\t\t\t       refcount_read(&sk->sk_wmem_alloc) == 0);\n\tif (filter) {\n\t\tsk_filter_uncharge(sk, filter);\n\t\tRCU_INIT_POINTER(sk->sk_filter, NULL);\n\t}\n\n\tsock_disable_timestamp(sk, SK_FLAGS_TIMESTAMP);\n\n#ifdef CONFIG_BPF_SYSCALL\n\tbpf_sk_storage_free(sk);\n#endif\n\n\tif (atomic_read(&sk->sk_omem_alloc))\n\t\tpr_debug(\"%s: optmem leakage (%d bytes) detected\\n\",\n\t\t\t __func__, atomic_read(&sk->sk_omem_alloc));\n\n\tif (sk->sk_frag.page) {\n\t\tput_page(sk->sk_frag.page);\n\t\tsk->sk_frag.page = NULL;\n\t}\n\n\t/* We do not need to acquire sk->sk_peer_lock, we are the last user. */\n\tput_cred(sk->sk_peer_cred);\n\tput_pid(sk->sk_peer_pid);\n\n\tif (likely(sk->sk_net_refcnt))\n\t\tput_net(sock_net(sk));\n\tsk_prot_free(sk->sk_prot_creator, sk);\n}",
        "patch": "--- code before\n+++ code after\n@@ -28,9 +28,10 @@\n \t\tsk->sk_frag.page = NULL;\n \t}\n \n-\tif (sk->sk_peer_cred)\n-\t\tput_cred(sk->sk_peer_cred);\n+\t/* We do not need to acquire sk->sk_peer_lock, we are the last user. */\n+\tput_cred(sk->sk_peer_cred);\n \tput_pid(sk->sk_peer_pid);\n+\n \tif (likely(sk->sk_net_refcnt))\n \t\tput_net(sock_net(sk));\n \tsk_prot_free(sk->sk_prot_creator, sk);",
        "function_modified_lines": {
            "added": [
                "\t/* We do not need to acquire sk->sk_peer_lock, we are the last user. */",
                "\tput_cred(sk->sk_peer_cred);",
                ""
            ],
            "deleted": [
                "\tif (sk->sk_peer_cred)",
                "\t\tput_cred(sk->sk_peer_cred);"
            ]
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "A use-after-free read flaw was found in sock_getsockopt() in net/core/sock.c due to SO_PEERCRED and SO_PEERGROUPS race with listen() (and connect()) in the Linux kernel. In this flaw, an attacker with a user privileges may crash the system or leak internal kernel information.",
        "id": 3147
    },
    {
        "cve_id": "CVE-2022-41849",
        "code_before_change": "static int ufx_ops_open(struct fb_info *info, int user)\n{\n\tstruct ufx_data *dev = info->par;\n\n\t/* fbcon aggressively connects to first framebuffer it finds,\n\t * preventing other clients (X) from working properly. Usually\n\t * not what the user wants. Fail by default with option to enable. */\n\tif (user == 0 && !console)\n\t\treturn -EBUSY;\n\n\t/* If the USB device is gone, we don't accept new opens */\n\tif (dev->virtualized)\n\t\treturn -ENODEV;\n\n\tdev->fb_count++;\n\n\tkref_get(&dev->kref);\n\n\tif (fb_defio && (info->fbdefio == NULL)) {\n\t\t/* enable defio at last moment if not disabled by client */\n\n\t\tstruct fb_deferred_io *fbdefio;\n\n\t\tfbdefio = kzalloc(sizeof(*fbdefio), GFP_KERNEL);\n\t\tif (fbdefio) {\n\t\t\tfbdefio->delay = UFX_DEFIO_WRITE_DELAY;\n\t\t\tfbdefio->deferred_io = ufx_dpy_deferred_io;\n\t\t}\n\n\t\tinfo->fbdefio = fbdefio;\n\t\tfb_deferred_io_init(info);\n\t}\n\n\tpr_debug(\"open /dev/fb%d user=%d fb_info=%p count=%d\",\n\t\tinfo->node, user, info, dev->fb_count);\n\n\treturn 0;\n}",
        "code_after_change": "static int ufx_ops_open(struct fb_info *info, int user)\n{\n\tstruct ufx_data *dev = info->par;\n\n\t/* fbcon aggressively connects to first framebuffer it finds,\n\t * preventing other clients (X) from working properly. Usually\n\t * not what the user wants. Fail by default with option to enable. */\n\tif (user == 0 && !console)\n\t\treturn -EBUSY;\n\n\tmutex_lock(&disconnect_mutex);\n\n\t/* If the USB device is gone, we don't accept new opens */\n\tif (dev->virtualized) {\n\t\tmutex_unlock(&disconnect_mutex);\n\t\treturn -ENODEV;\n\t}\n\n\tdev->fb_count++;\n\n\tkref_get(&dev->kref);\n\n\tif (fb_defio && (info->fbdefio == NULL)) {\n\t\t/* enable defio at last moment if not disabled by client */\n\n\t\tstruct fb_deferred_io *fbdefio;\n\n\t\tfbdefio = kzalloc(sizeof(*fbdefio), GFP_KERNEL);\n\t\tif (fbdefio) {\n\t\t\tfbdefio->delay = UFX_DEFIO_WRITE_DELAY;\n\t\t\tfbdefio->deferred_io = ufx_dpy_deferred_io;\n\t\t}\n\n\t\tinfo->fbdefio = fbdefio;\n\t\tfb_deferred_io_init(info);\n\t}\n\n\tpr_debug(\"open /dev/fb%d user=%d fb_info=%p count=%d\",\n\t\tinfo->node, user, info, dev->fb_count);\n\n\tmutex_unlock(&disconnect_mutex);\n\n\treturn 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -8,9 +8,13 @@\n \tif (user == 0 && !console)\n \t\treturn -EBUSY;\n \n+\tmutex_lock(&disconnect_mutex);\n+\n \t/* If the USB device is gone, we don't accept new opens */\n-\tif (dev->virtualized)\n+\tif (dev->virtualized) {\n+\t\tmutex_unlock(&disconnect_mutex);\n \t\treturn -ENODEV;\n+\t}\n \n \tdev->fb_count++;\n \n@@ -34,5 +38,7 @@\n \tpr_debug(\"open /dev/fb%d user=%d fb_info=%p count=%d\",\n \t\tinfo->node, user, info, dev->fb_count);\n \n+\tmutex_unlock(&disconnect_mutex);\n+\n \treturn 0;\n }",
        "function_modified_lines": {
            "added": [
                "\tmutex_lock(&disconnect_mutex);",
                "",
                "\tif (dev->virtualized) {",
                "\t\tmutex_unlock(&disconnect_mutex);",
                "\t}",
                "\tmutex_unlock(&disconnect_mutex);",
                ""
            ],
            "deleted": [
                "\tif (dev->virtualized)"
            ]
        },
        "cwe": [
            "CWE-362",
            "CWE-416"
        ],
        "cve_description": "drivers/video/fbdev/smscufx.c in the Linux kernel through 5.19.12 has a race condition and resultant use-after-free if a physically proximate attacker removes a USB device while calling open(), aka a race condition between ufx_ops_open and ufx_usb_disconnect.",
        "id": 3721
    },
    {
        "cve_id": "CVE-2014-4652",
        "code_before_change": "int snd_card_new(struct device *parent, int idx, const char *xid,\n\t\t    struct module *module, int extra_size,\n\t\t    struct snd_card **card_ret)\n{\n\tstruct snd_card *card;\n\tint err;\n\n\tif (snd_BUG_ON(!card_ret))\n\t\treturn -EINVAL;\n\t*card_ret = NULL;\n\n\tif (extra_size < 0)\n\t\textra_size = 0;\n\tcard = kzalloc(sizeof(*card) + extra_size, GFP_KERNEL);\n\tif (!card)\n\t\treturn -ENOMEM;\n\tif (extra_size > 0)\n\t\tcard->private_data = (char *)card + sizeof(struct snd_card);\n\tif (xid)\n\t\tstrlcpy(card->id, xid, sizeof(card->id));\n\terr = 0;\n\tmutex_lock(&snd_card_mutex);\n\tif (idx < 0) /* first check the matching module-name slot */\n\t\tidx = get_slot_from_bitmask(idx, module_slot_match, module);\n\tif (idx < 0) /* if not matched, assign an empty slot */\n\t\tidx = get_slot_from_bitmask(idx, check_empty_slot, module);\n\tif (idx < 0)\n\t\terr = -ENODEV;\n\telse if (idx < snd_ecards_limit) {\n\t\tif (test_bit(idx, snd_cards_lock))\n\t\t\terr = -EBUSY;\t/* invalid */\n\t} else if (idx >= SNDRV_CARDS)\n\t\terr = -ENODEV;\n\tif (err < 0) {\n\t\tmutex_unlock(&snd_card_mutex);\n\t\tdev_err(parent, \"cannot find the slot for index %d (range 0-%i), error: %d\\n\",\n\t\t\t idx, snd_ecards_limit - 1, err);\n\t\tkfree(card);\n\t\treturn err;\n\t}\n\tset_bit(idx, snd_cards_lock);\t\t/* lock it */\n\tif (idx >= snd_ecards_limit)\n\t\tsnd_ecards_limit = idx + 1; /* increase the limit */\n\tmutex_unlock(&snd_card_mutex);\n\tcard->dev = parent;\n\tcard->number = idx;\n\tcard->module = module;\n\tINIT_LIST_HEAD(&card->devices);\n\tinit_rwsem(&card->controls_rwsem);\n\trwlock_init(&card->ctl_files_rwlock);\n\tINIT_LIST_HEAD(&card->controls);\n\tINIT_LIST_HEAD(&card->ctl_files);\n\tspin_lock_init(&card->files_lock);\n\tINIT_LIST_HEAD(&card->files_list);\n#ifdef CONFIG_PM\n\tmutex_init(&card->power_lock);\n\tinit_waitqueue_head(&card->power_sleep);\n#endif\n\n\tdevice_initialize(&card->card_dev);\n\tcard->card_dev.parent = parent;\n\tcard->card_dev.class = sound_class;\n\tcard->card_dev.release = release_card_device;\n\tcard->card_dev.groups = card_dev_attr_groups;\n\terr = kobject_set_name(&card->card_dev.kobj, \"card%d\", idx);\n\tif (err < 0)\n\t\tgoto __error;\n\n\t/* the control interface cannot be accessed from the user space until */\n\t/* snd_cards_bitmask and snd_cards are set with snd_card_register */\n\terr = snd_ctl_create(card);\n\tif (err < 0) {\n\t\tdev_err(parent, \"unable to register control minors\\n\");\n\t\tgoto __error;\n\t}\n\terr = snd_info_card_create(card);\n\tif (err < 0) {\n\t\tdev_err(parent, \"unable to create card info\\n\");\n\t\tgoto __error_ctl;\n\t}\n\t*card_ret = card;\n\treturn 0;\n\n      __error_ctl:\n\tsnd_device_free_all(card);\n      __error:\n\tput_device(&card->card_dev);\n  \treturn err;\n}",
        "code_after_change": "int snd_card_new(struct device *parent, int idx, const char *xid,\n\t\t    struct module *module, int extra_size,\n\t\t    struct snd_card **card_ret)\n{\n\tstruct snd_card *card;\n\tint err;\n\n\tif (snd_BUG_ON(!card_ret))\n\t\treturn -EINVAL;\n\t*card_ret = NULL;\n\n\tif (extra_size < 0)\n\t\textra_size = 0;\n\tcard = kzalloc(sizeof(*card) + extra_size, GFP_KERNEL);\n\tif (!card)\n\t\treturn -ENOMEM;\n\tif (extra_size > 0)\n\t\tcard->private_data = (char *)card + sizeof(struct snd_card);\n\tif (xid)\n\t\tstrlcpy(card->id, xid, sizeof(card->id));\n\terr = 0;\n\tmutex_lock(&snd_card_mutex);\n\tif (idx < 0) /* first check the matching module-name slot */\n\t\tidx = get_slot_from_bitmask(idx, module_slot_match, module);\n\tif (idx < 0) /* if not matched, assign an empty slot */\n\t\tidx = get_slot_from_bitmask(idx, check_empty_slot, module);\n\tif (idx < 0)\n\t\terr = -ENODEV;\n\telse if (idx < snd_ecards_limit) {\n\t\tif (test_bit(idx, snd_cards_lock))\n\t\t\terr = -EBUSY;\t/* invalid */\n\t} else if (idx >= SNDRV_CARDS)\n\t\terr = -ENODEV;\n\tif (err < 0) {\n\t\tmutex_unlock(&snd_card_mutex);\n\t\tdev_err(parent, \"cannot find the slot for index %d (range 0-%i), error: %d\\n\",\n\t\t\t idx, snd_ecards_limit - 1, err);\n\t\tkfree(card);\n\t\treturn err;\n\t}\n\tset_bit(idx, snd_cards_lock);\t\t/* lock it */\n\tif (idx >= snd_ecards_limit)\n\t\tsnd_ecards_limit = idx + 1; /* increase the limit */\n\tmutex_unlock(&snd_card_mutex);\n\tcard->dev = parent;\n\tcard->number = idx;\n\tcard->module = module;\n\tINIT_LIST_HEAD(&card->devices);\n\tinit_rwsem(&card->controls_rwsem);\n\trwlock_init(&card->ctl_files_rwlock);\n\tmutex_init(&card->user_ctl_lock);\n\tINIT_LIST_HEAD(&card->controls);\n\tINIT_LIST_HEAD(&card->ctl_files);\n\tspin_lock_init(&card->files_lock);\n\tINIT_LIST_HEAD(&card->files_list);\n#ifdef CONFIG_PM\n\tmutex_init(&card->power_lock);\n\tinit_waitqueue_head(&card->power_sleep);\n#endif\n\n\tdevice_initialize(&card->card_dev);\n\tcard->card_dev.parent = parent;\n\tcard->card_dev.class = sound_class;\n\tcard->card_dev.release = release_card_device;\n\tcard->card_dev.groups = card_dev_attr_groups;\n\terr = kobject_set_name(&card->card_dev.kobj, \"card%d\", idx);\n\tif (err < 0)\n\t\tgoto __error;\n\n\t/* the control interface cannot be accessed from the user space until */\n\t/* snd_cards_bitmask and snd_cards are set with snd_card_register */\n\terr = snd_ctl_create(card);\n\tif (err < 0) {\n\t\tdev_err(parent, \"unable to register control minors\\n\");\n\t\tgoto __error;\n\t}\n\terr = snd_info_card_create(card);\n\tif (err < 0) {\n\t\tdev_err(parent, \"unable to create card info\\n\");\n\t\tgoto __error_ctl;\n\t}\n\t*card_ret = card;\n\treturn 0;\n\n      __error_ctl:\n\tsnd_device_free_all(card);\n      __error:\n\tput_device(&card->card_dev);\n  \treturn err;\n}",
        "patch": "--- code before\n+++ code after\n@@ -48,6 +48,7 @@\n \tINIT_LIST_HEAD(&card->devices);\n \tinit_rwsem(&card->controls_rwsem);\n \trwlock_init(&card->ctl_files_rwlock);\n+\tmutex_init(&card->user_ctl_lock);\n \tINIT_LIST_HEAD(&card->controls);\n \tINIT_LIST_HEAD(&card->ctl_files);\n \tspin_lock_init(&card->files_lock);",
        "function_modified_lines": {
            "added": [
                "\tmutex_init(&card->user_ctl_lock);"
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "Race condition in the tlv handler functionality in the snd_ctl_elem_user_tlv function in sound/core/control.c in the ALSA control implementation in the Linux kernel before 3.15.2 allows local users to obtain sensitive information from kernel memory by leveraging /dev/snd/controlCX access.",
        "id": 566
    },
    {
        "cve_id": "CVE-2014-4652",
        "code_before_change": "static int snd_ctl_elem_user_tlv(struct snd_kcontrol *kcontrol,\n\t\t\t\t int op_flag,\n\t\t\t\t unsigned int size,\n\t\t\t\t unsigned int __user *tlv)\n{\n\tstruct user_element *ue = kcontrol->private_data;\n\tint change = 0;\n\tvoid *new_data;\n\n\tif (op_flag > 0) {\n\t\tif (size > 1024 * 128)\t/* sane value */\n\t\t\treturn -EINVAL;\n\n\t\tnew_data = memdup_user(tlv, size);\n\t\tif (IS_ERR(new_data))\n\t\t\treturn PTR_ERR(new_data);\n\t\tchange = ue->tlv_data_size != size;\n\t\tif (!change)\n\t\t\tchange = memcmp(ue->tlv_data, new_data, size);\n\t\tkfree(ue->tlv_data);\n\t\tue->tlv_data = new_data;\n\t\tue->tlv_data_size = size;\n\t} else {\n\t\tif (! ue->tlv_data_size || ! ue->tlv_data)\n\t\t\treturn -ENXIO;\n\t\tif (size < ue->tlv_data_size)\n\t\t\treturn -ENOSPC;\n\t\tif (copy_to_user(tlv, ue->tlv_data, ue->tlv_data_size))\n\t\t\treturn -EFAULT;\n\t}\n\treturn change;\n}",
        "code_after_change": "static int snd_ctl_elem_user_tlv(struct snd_kcontrol *kcontrol,\n\t\t\t\t int op_flag,\n\t\t\t\t unsigned int size,\n\t\t\t\t unsigned int __user *tlv)\n{\n\tstruct user_element *ue = kcontrol->private_data;\n\tint change = 0;\n\tvoid *new_data;\n\n\tif (op_flag > 0) {\n\t\tif (size > 1024 * 128)\t/* sane value */\n\t\t\treturn -EINVAL;\n\n\t\tnew_data = memdup_user(tlv, size);\n\t\tif (IS_ERR(new_data))\n\t\t\treturn PTR_ERR(new_data);\n\t\tmutex_lock(&ue->card->user_ctl_lock);\n\t\tchange = ue->tlv_data_size != size;\n\t\tif (!change)\n\t\t\tchange = memcmp(ue->tlv_data, new_data, size);\n\t\tkfree(ue->tlv_data);\n\t\tue->tlv_data = new_data;\n\t\tue->tlv_data_size = size;\n\t\tmutex_unlock(&ue->card->user_ctl_lock);\n\t} else {\n\t\tint ret = 0;\n\n\t\tmutex_lock(&ue->card->user_ctl_lock);\n\t\tif (!ue->tlv_data_size || !ue->tlv_data) {\n\t\t\tret = -ENXIO;\n\t\t\tgoto err_unlock;\n\t\t}\n\t\tif (size < ue->tlv_data_size) {\n\t\t\tret = -ENOSPC;\n\t\t\tgoto err_unlock;\n\t\t}\n\t\tif (copy_to_user(tlv, ue->tlv_data, ue->tlv_data_size))\n\t\t\tret = -EFAULT;\nerr_unlock:\n\t\tmutex_unlock(&ue->card->user_ctl_lock);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn change;\n}",
        "patch": "--- code before\n+++ code after\n@@ -14,19 +14,32 @@\n \t\tnew_data = memdup_user(tlv, size);\n \t\tif (IS_ERR(new_data))\n \t\t\treturn PTR_ERR(new_data);\n+\t\tmutex_lock(&ue->card->user_ctl_lock);\n \t\tchange = ue->tlv_data_size != size;\n \t\tif (!change)\n \t\t\tchange = memcmp(ue->tlv_data, new_data, size);\n \t\tkfree(ue->tlv_data);\n \t\tue->tlv_data = new_data;\n \t\tue->tlv_data_size = size;\n+\t\tmutex_unlock(&ue->card->user_ctl_lock);\n \t} else {\n-\t\tif (! ue->tlv_data_size || ! ue->tlv_data)\n-\t\t\treturn -ENXIO;\n-\t\tif (size < ue->tlv_data_size)\n-\t\t\treturn -ENOSPC;\n+\t\tint ret = 0;\n+\n+\t\tmutex_lock(&ue->card->user_ctl_lock);\n+\t\tif (!ue->tlv_data_size || !ue->tlv_data) {\n+\t\t\tret = -ENXIO;\n+\t\t\tgoto err_unlock;\n+\t\t}\n+\t\tif (size < ue->tlv_data_size) {\n+\t\t\tret = -ENOSPC;\n+\t\t\tgoto err_unlock;\n+\t\t}\n \t\tif (copy_to_user(tlv, ue->tlv_data, ue->tlv_data_size))\n-\t\t\treturn -EFAULT;\n+\t\t\tret = -EFAULT;\n+err_unlock:\n+\t\tmutex_unlock(&ue->card->user_ctl_lock);\n+\t\tif (ret)\n+\t\t\treturn ret;\n \t}\n \treturn change;\n }",
        "function_modified_lines": {
            "added": [
                "\t\tmutex_lock(&ue->card->user_ctl_lock);",
                "\t\tmutex_unlock(&ue->card->user_ctl_lock);",
                "\t\tint ret = 0;",
                "",
                "\t\tmutex_lock(&ue->card->user_ctl_lock);",
                "\t\tif (!ue->tlv_data_size || !ue->tlv_data) {",
                "\t\t\tret = -ENXIO;",
                "\t\t\tgoto err_unlock;",
                "\t\t}",
                "\t\tif (size < ue->tlv_data_size) {",
                "\t\t\tret = -ENOSPC;",
                "\t\t\tgoto err_unlock;",
                "\t\t}",
                "\t\t\tret = -EFAULT;",
                "err_unlock:",
                "\t\tmutex_unlock(&ue->card->user_ctl_lock);",
                "\t\tif (ret)",
                "\t\t\treturn ret;"
            ],
            "deleted": [
                "\t\tif (! ue->tlv_data_size || ! ue->tlv_data)",
                "\t\t\treturn -ENXIO;",
                "\t\tif (size < ue->tlv_data_size)",
                "\t\t\treturn -ENOSPC;",
                "\t\t\treturn -EFAULT;"
            ]
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "Race condition in the tlv handler functionality in the snd_ctl_elem_user_tlv function in sound/core/control.c in the ALSA control implementation in the Linux kernel before 3.15.2 allows local users to obtain sensitive information from kernel memory by leveraging /dev/snd/controlCX access.",
        "id": 565
    },
    {
        "cve_id": "CVE-2021-23133",
        "code_before_change": "static int sctp_init_sock(struct sock *sk)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct sctp_sock *sp;\n\n\tpr_debug(\"%s: sk:%p\\n\", __func__, sk);\n\n\tsp = sctp_sk(sk);\n\n\t/* Initialize the SCTP per socket area.  */\n\tswitch (sk->sk_type) {\n\tcase SOCK_SEQPACKET:\n\t\tsp->type = SCTP_SOCKET_UDP;\n\t\tbreak;\n\tcase SOCK_STREAM:\n\t\tsp->type = SCTP_SOCKET_TCP;\n\t\tbreak;\n\tdefault:\n\t\treturn -ESOCKTNOSUPPORT;\n\t}\n\n\tsk->sk_gso_type = SKB_GSO_SCTP;\n\n\t/* Initialize default send parameters. These parameters can be\n\t * modified with the SCTP_DEFAULT_SEND_PARAM socket option.\n\t */\n\tsp->default_stream = 0;\n\tsp->default_ppid = 0;\n\tsp->default_flags = 0;\n\tsp->default_context = 0;\n\tsp->default_timetolive = 0;\n\n\tsp->default_rcv_context = 0;\n\tsp->max_burst = net->sctp.max_burst;\n\n\tsp->sctp_hmac_alg = net->sctp.sctp_hmac_alg;\n\n\t/* Initialize default setup parameters. These parameters\n\t * can be modified with the SCTP_INITMSG socket option or\n\t * overridden by the SCTP_INIT CMSG.\n\t */\n\tsp->initmsg.sinit_num_ostreams   = sctp_max_outstreams;\n\tsp->initmsg.sinit_max_instreams  = sctp_max_instreams;\n\tsp->initmsg.sinit_max_attempts   = net->sctp.max_retrans_init;\n\tsp->initmsg.sinit_max_init_timeo = net->sctp.rto_max;\n\n\t/* Initialize default RTO related parameters.  These parameters can\n\t * be modified for with the SCTP_RTOINFO socket option.\n\t */\n\tsp->rtoinfo.srto_initial = net->sctp.rto_initial;\n\tsp->rtoinfo.srto_max     = net->sctp.rto_max;\n\tsp->rtoinfo.srto_min     = net->sctp.rto_min;\n\n\t/* Initialize default association related parameters. These parameters\n\t * can be modified with the SCTP_ASSOCINFO socket option.\n\t */\n\tsp->assocparams.sasoc_asocmaxrxt = net->sctp.max_retrans_association;\n\tsp->assocparams.sasoc_number_peer_destinations = 0;\n\tsp->assocparams.sasoc_peer_rwnd = 0;\n\tsp->assocparams.sasoc_local_rwnd = 0;\n\tsp->assocparams.sasoc_cookie_life = net->sctp.valid_cookie_life;\n\n\t/* Initialize default event subscriptions. By default, all the\n\t * options are off.\n\t */\n\tsp->subscribe = 0;\n\n\t/* Default Peer Address Parameters.  These defaults can\n\t * be modified via SCTP_PEER_ADDR_PARAMS\n\t */\n\tsp->hbinterval  = net->sctp.hb_interval;\n\tsp->udp_port    = htons(net->sctp.udp_port);\n\tsp->encap_port  = htons(net->sctp.encap_port);\n\tsp->pathmaxrxt  = net->sctp.max_retrans_path;\n\tsp->pf_retrans  = net->sctp.pf_retrans;\n\tsp->ps_retrans  = net->sctp.ps_retrans;\n\tsp->pf_expose   = net->sctp.pf_expose;\n\tsp->pathmtu     = 0; /* allow default discovery */\n\tsp->sackdelay   = net->sctp.sack_timeout;\n\tsp->sackfreq\t= 2;\n\tsp->param_flags = SPP_HB_ENABLE |\n\t\t\t  SPP_PMTUD_ENABLE |\n\t\t\t  SPP_SACKDELAY_ENABLE;\n\tsp->default_ss = SCTP_SS_DEFAULT;\n\n\t/* If enabled no SCTP message fragmentation will be performed.\n\t * Configure through SCTP_DISABLE_FRAGMENTS socket option.\n\t */\n\tsp->disable_fragments = 0;\n\n\t/* Enable Nagle algorithm by default.  */\n\tsp->nodelay           = 0;\n\n\tsp->recvrcvinfo = 0;\n\tsp->recvnxtinfo = 0;\n\n\t/* Enable by default. */\n\tsp->v4mapped          = 1;\n\n\t/* Auto-close idle associations after the configured\n\t * number of seconds.  A value of 0 disables this\n\t * feature.  Configure through the SCTP_AUTOCLOSE socket option,\n\t * for UDP-style sockets only.\n\t */\n\tsp->autoclose         = 0;\n\n\t/* User specified fragmentation limit. */\n\tsp->user_frag         = 0;\n\n\tsp->adaptation_ind = 0;\n\n\tsp->pf = sctp_get_pf_specific(sk->sk_family);\n\n\t/* Control variables for partial data delivery. */\n\tatomic_set(&sp->pd_mode, 0);\n\tskb_queue_head_init(&sp->pd_lobby);\n\tsp->frag_interleave = 0;\n\n\t/* Create a per socket endpoint structure.  Even if we\n\t * change the data structure relationships, this may still\n\t * be useful for storing pre-connect address information.\n\t */\n\tsp->ep = sctp_endpoint_new(sk, GFP_KERNEL);\n\tif (!sp->ep)\n\t\treturn -ENOMEM;\n\n\tsp->hmac = NULL;\n\n\tsk->sk_destruct = sctp_destruct_sock;\n\n\tSCTP_DBG_OBJCNT_INC(sock);\n\n\tlocal_bh_disable();\n\tsk_sockets_allocated_inc(sk);\n\tsock_prot_inuse_add(net, sk->sk_prot, 1);\n\n\t/* Nothing can fail after this block, otherwise\n\t * sctp_destroy_sock() will be called without addr_wq_lock held\n\t */\n\tif (net->sctp.default_auto_asconf) {\n\t\tspin_lock(&sock_net(sk)->sctp.addr_wq_lock);\n\t\tlist_add_tail(&sp->auto_asconf_list,\n\t\t    &net->sctp.auto_asconf_splist);\n\t\tsp->do_auto_asconf = 1;\n\t\tspin_unlock(&sock_net(sk)->sctp.addr_wq_lock);\n\t} else {\n\t\tsp->do_auto_asconf = 0;\n\t}\n\n\tlocal_bh_enable();\n\n\treturn 0;\n}",
        "code_after_change": "static int sctp_init_sock(struct sock *sk)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct sctp_sock *sp;\n\n\tpr_debug(\"%s: sk:%p\\n\", __func__, sk);\n\n\tsp = sctp_sk(sk);\n\n\t/* Initialize the SCTP per socket area.  */\n\tswitch (sk->sk_type) {\n\tcase SOCK_SEQPACKET:\n\t\tsp->type = SCTP_SOCKET_UDP;\n\t\tbreak;\n\tcase SOCK_STREAM:\n\t\tsp->type = SCTP_SOCKET_TCP;\n\t\tbreak;\n\tdefault:\n\t\treturn -ESOCKTNOSUPPORT;\n\t}\n\n\tsk->sk_gso_type = SKB_GSO_SCTP;\n\n\t/* Initialize default send parameters. These parameters can be\n\t * modified with the SCTP_DEFAULT_SEND_PARAM socket option.\n\t */\n\tsp->default_stream = 0;\n\tsp->default_ppid = 0;\n\tsp->default_flags = 0;\n\tsp->default_context = 0;\n\tsp->default_timetolive = 0;\n\n\tsp->default_rcv_context = 0;\n\tsp->max_burst = net->sctp.max_burst;\n\n\tsp->sctp_hmac_alg = net->sctp.sctp_hmac_alg;\n\n\t/* Initialize default setup parameters. These parameters\n\t * can be modified with the SCTP_INITMSG socket option or\n\t * overridden by the SCTP_INIT CMSG.\n\t */\n\tsp->initmsg.sinit_num_ostreams   = sctp_max_outstreams;\n\tsp->initmsg.sinit_max_instreams  = sctp_max_instreams;\n\tsp->initmsg.sinit_max_attempts   = net->sctp.max_retrans_init;\n\tsp->initmsg.sinit_max_init_timeo = net->sctp.rto_max;\n\n\t/* Initialize default RTO related parameters.  These parameters can\n\t * be modified for with the SCTP_RTOINFO socket option.\n\t */\n\tsp->rtoinfo.srto_initial = net->sctp.rto_initial;\n\tsp->rtoinfo.srto_max     = net->sctp.rto_max;\n\tsp->rtoinfo.srto_min     = net->sctp.rto_min;\n\n\t/* Initialize default association related parameters. These parameters\n\t * can be modified with the SCTP_ASSOCINFO socket option.\n\t */\n\tsp->assocparams.sasoc_asocmaxrxt = net->sctp.max_retrans_association;\n\tsp->assocparams.sasoc_number_peer_destinations = 0;\n\tsp->assocparams.sasoc_peer_rwnd = 0;\n\tsp->assocparams.sasoc_local_rwnd = 0;\n\tsp->assocparams.sasoc_cookie_life = net->sctp.valid_cookie_life;\n\n\t/* Initialize default event subscriptions. By default, all the\n\t * options are off.\n\t */\n\tsp->subscribe = 0;\n\n\t/* Default Peer Address Parameters.  These defaults can\n\t * be modified via SCTP_PEER_ADDR_PARAMS\n\t */\n\tsp->hbinterval  = net->sctp.hb_interval;\n\tsp->udp_port    = htons(net->sctp.udp_port);\n\tsp->encap_port  = htons(net->sctp.encap_port);\n\tsp->pathmaxrxt  = net->sctp.max_retrans_path;\n\tsp->pf_retrans  = net->sctp.pf_retrans;\n\tsp->ps_retrans  = net->sctp.ps_retrans;\n\tsp->pf_expose   = net->sctp.pf_expose;\n\tsp->pathmtu     = 0; /* allow default discovery */\n\tsp->sackdelay   = net->sctp.sack_timeout;\n\tsp->sackfreq\t= 2;\n\tsp->param_flags = SPP_HB_ENABLE |\n\t\t\t  SPP_PMTUD_ENABLE |\n\t\t\t  SPP_SACKDELAY_ENABLE;\n\tsp->default_ss = SCTP_SS_DEFAULT;\n\n\t/* If enabled no SCTP message fragmentation will be performed.\n\t * Configure through SCTP_DISABLE_FRAGMENTS socket option.\n\t */\n\tsp->disable_fragments = 0;\n\n\t/* Enable Nagle algorithm by default.  */\n\tsp->nodelay           = 0;\n\n\tsp->recvrcvinfo = 0;\n\tsp->recvnxtinfo = 0;\n\n\t/* Enable by default. */\n\tsp->v4mapped          = 1;\n\n\t/* Auto-close idle associations after the configured\n\t * number of seconds.  A value of 0 disables this\n\t * feature.  Configure through the SCTP_AUTOCLOSE socket option,\n\t * for UDP-style sockets only.\n\t */\n\tsp->autoclose         = 0;\n\n\t/* User specified fragmentation limit. */\n\tsp->user_frag         = 0;\n\n\tsp->adaptation_ind = 0;\n\n\tsp->pf = sctp_get_pf_specific(sk->sk_family);\n\n\t/* Control variables for partial data delivery. */\n\tatomic_set(&sp->pd_mode, 0);\n\tskb_queue_head_init(&sp->pd_lobby);\n\tsp->frag_interleave = 0;\n\n\t/* Create a per socket endpoint structure.  Even if we\n\t * change the data structure relationships, this may still\n\t * be useful for storing pre-connect address information.\n\t */\n\tsp->ep = sctp_endpoint_new(sk, GFP_KERNEL);\n\tif (!sp->ep)\n\t\treturn -ENOMEM;\n\n\tsp->hmac = NULL;\n\n\tsk->sk_destruct = sctp_destruct_sock;\n\n\tSCTP_DBG_OBJCNT_INC(sock);\n\n\tlocal_bh_disable();\n\tsk_sockets_allocated_inc(sk);\n\tsock_prot_inuse_add(net, sk->sk_prot, 1);\n\n\tif (net->sctp.default_auto_asconf) {\n\t\tspin_lock(&sock_net(sk)->sctp.addr_wq_lock);\n\t\tlist_add_tail(&sp->auto_asconf_list,\n\t\t    &net->sctp.auto_asconf_splist);\n\t\tsp->do_auto_asconf = 1;\n\t\tspin_unlock(&sock_net(sk)->sctp.addr_wq_lock);\n\t} else {\n\t\tsp->do_auto_asconf = 0;\n\t}\n\n\tlocal_bh_enable();\n\n\treturn 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -134,9 +134,6 @@\n \tsk_sockets_allocated_inc(sk);\n \tsock_prot_inuse_add(net, sk->sk_prot, 1);\n \n-\t/* Nothing can fail after this block, otherwise\n-\t * sctp_destroy_sock() will be called without addr_wq_lock held\n-\t */\n \tif (net->sctp.default_auto_asconf) {\n \t\tspin_lock(&sock_net(sk)->sctp.addr_wq_lock);\n \t\tlist_add_tail(&sp->auto_asconf_list,",
        "function_modified_lines": {
            "added": [],
            "deleted": [
                "\t/* Nothing can fail after this block, otherwise",
                "\t * sctp_destroy_sock() will be called without addr_wq_lock held",
                "\t */"
            ]
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "A race condition in Linux kernel SCTP sockets (net/sctp/socket.c) before 5.12-rc8 can lead to kernel privilege escalation from the context of a network service or an unprivileged process. If sctp_destroy_sock is called without sock_net(sk)->sctp.addr_wq_lock then an element is removed from the auto_asconf_splist list without any proper locking. This can be exploited by an attacker with network service privileges to escalate to root or from the context of an unprivileged user directly if a BPF_CGROUP_INET_SOCK_CREATE is attached which denies creation of some SCTP socket.",
        "id": 2888
    },
    {
        "cve_id": "CVE-2021-20261",
        "code_before_change": "static int floppy_revalidate(struct gendisk *disk)\n{\n\tint drive = (long)disk->private_data;\n\tint cf;\n\tint res = 0;\n\n\tif (test_bit(FD_DISK_CHANGED_BIT, &UDRS->flags) ||\n\t    test_bit(FD_VERIFY_BIT, &UDRS->flags) ||\n\t    test_bit(drive, &fake_change) ||\n\t    drive_no_geom(drive)) {\n\t\tif (WARN(atomic_read(&usage_count) == 0,\n\t\t\t \"VFS: revalidate called on non-open device.\\n\"))\n\t\t\treturn -EFAULT;\n\n\t\tlock_fdc(drive, false);\n\t\tcf = (test_bit(FD_DISK_CHANGED_BIT, &UDRS->flags) ||\n\t\t      test_bit(FD_VERIFY_BIT, &UDRS->flags));\n\t\tif (!(cf || test_bit(drive, &fake_change) || drive_no_geom(drive))) {\n\t\t\tprocess_fd_request();\t/*already done by another thread */\n\t\t\treturn 0;\n\t\t}\n\t\tUDRS->maxblock = 0;\n\t\tUDRS->maxtrack = 0;\n\t\tif (buffer_drive == drive)\n\t\t\tbuffer_track = -1;\n\t\tclear_bit(drive, &fake_change);\n\t\tclear_bit(FD_DISK_CHANGED_BIT, &UDRS->flags);\n\t\tif (cf)\n\t\t\tUDRS->generation++;\n\t\tif (drive_no_geom(drive)) {\n\t\t\t/* auto-sensing */\n\t\t\tres = __floppy_read_block_0(opened_bdev[drive], drive);\n\t\t} else {\n\t\t\tif (cf)\n\t\t\t\tpoll_drive(false, FD_RAW_NEED_DISK);\n\t\t\tprocess_fd_request();\n\t\t}\n\t}\n\tset_capacity(disk, floppy_sizes[UDRS->fd_device]);\n\treturn res;\n}",
        "code_after_change": "static int floppy_revalidate(struct gendisk *disk)\n{\n\tint drive = (long)disk->private_data;\n\tint cf;\n\tint res = 0;\n\n\tif (test_bit(FD_DISK_CHANGED_BIT, &UDRS->flags) ||\n\t    test_bit(FD_VERIFY_BIT, &UDRS->flags) ||\n\t    test_bit(drive, &fake_change) ||\n\t    drive_no_geom(drive)) {\n\t\tif (WARN(atomic_read(&usage_count) == 0,\n\t\t\t \"VFS: revalidate called on non-open device.\\n\"))\n\t\t\treturn -EFAULT;\n\n\t\tres = lock_fdc(drive);\n\t\tif (res)\n\t\t\treturn res;\n\t\tcf = (test_bit(FD_DISK_CHANGED_BIT, &UDRS->flags) ||\n\t\t      test_bit(FD_VERIFY_BIT, &UDRS->flags));\n\t\tif (!(cf || test_bit(drive, &fake_change) || drive_no_geom(drive))) {\n\t\t\tprocess_fd_request();\t/*already done by another thread */\n\t\t\treturn 0;\n\t\t}\n\t\tUDRS->maxblock = 0;\n\t\tUDRS->maxtrack = 0;\n\t\tif (buffer_drive == drive)\n\t\t\tbuffer_track = -1;\n\t\tclear_bit(drive, &fake_change);\n\t\tclear_bit(FD_DISK_CHANGED_BIT, &UDRS->flags);\n\t\tif (cf)\n\t\t\tUDRS->generation++;\n\t\tif (drive_no_geom(drive)) {\n\t\t\t/* auto-sensing */\n\t\t\tres = __floppy_read_block_0(opened_bdev[drive], drive);\n\t\t} else {\n\t\t\tif (cf)\n\t\t\t\tpoll_drive(false, FD_RAW_NEED_DISK);\n\t\t\tprocess_fd_request();\n\t\t}\n\t}\n\tset_capacity(disk, floppy_sizes[UDRS->fd_device]);\n\treturn res;\n}",
        "patch": "--- code before\n+++ code after\n@@ -12,7 +12,9 @@\n \t\t\t \"VFS: revalidate called on non-open device.\\n\"))\n \t\t\treturn -EFAULT;\n \n-\t\tlock_fdc(drive, false);\n+\t\tres = lock_fdc(drive);\n+\t\tif (res)\n+\t\t\treturn res;\n \t\tcf = (test_bit(FD_DISK_CHANGED_BIT, &UDRS->flags) ||\n \t\t      test_bit(FD_VERIFY_BIT, &UDRS->flags));\n \t\tif (!(cf || test_bit(drive, &fake_change) || drive_no_geom(drive))) {",
        "function_modified_lines": {
            "added": [
                "\t\tres = lock_fdc(drive);",
                "\t\tif (res)",
                "\t\t\treturn res;"
            ],
            "deleted": [
                "\t\tlock_fdc(drive, false);"
            ]
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "A race condition was found in the Linux kernels implementation of the floppy disk drive controller driver software. The impact of this issue is lessened by the fact that the default permissions on the floppy device (/dev/fd0) are restricted to root. If the permissions on the device have changed the impact changes greatly. In the default configuration root (or equivalent) permissions are required to attack this flaw.",
        "id": 2865
    },
    {
        "cve_id": "CVE-2022-45869",
        "code_before_change": "static bool __kvm_mmu_prepare_zap_page(struct kvm *kvm,\n\t\t\t\t       struct kvm_mmu_page *sp,\n\t\t\t\t       struct list_head *invalid_list,\n\t\t\t\t       int *nr_zapped)\n{\n\tbool list_unstable, zapped_root = false;\n\n\ttrace_kvm_mmu_prepare_zap_page(sp);\n\t++kvm->stat.mmu_shadow_zapped;\n\t*nr_zapped = mmu_zap_unsync_children(kvm, sp, invalid_list);\n\t*nr_zapped += kvm_mmu_page_unlink_children(kvm, sp, invalid_list);\n\tkvm_mmu_unlink_parents(sp);\n\n\t/* Zapping children means active_mmu_pages has become unstable. */\n\tlist_unstable = *nr_zapped;\n\n\tif (!sp->role.invalid && sp_has_gptes(sp))\n\t\tunaccount_shadowed(kvm, sp);\n\n\tif (sp->unsync)\n\t\tkvm_unlink_unsync_page(kvm, sp);\n\tif (!sp->root_count) {\n\t\t/* Count self */\n\t\t(*nr_zapped)++;\n\n\t\t/*\n\t\t * Already invalid pages (previously active roots) are not on\n\t\t * the active page list.  See list_del() in the \"else\" case of\n\t\t * !sp->root_count.\n\t\t */\n\t\tif (sp->role.invalid)\n\t\t\tlist_add(&sp->link, invalid_list);\n\t\telse\n\t\t\tlist_move(&sp->link, invalid_list);\n\t\tkvm_unaccount_mmu_page(kvm, sp);\n\t} else {\n\t\t/*\n\t\t * Remove the active root from the active page list, the root\n\t\t * will be explicitly freed when the root_count hits zero.\n\t\t */\n\t\tlist_del(&sp->link);\n\n\t\t/*\n\t\t * Obsolete pages cannot be used on any vCPUs, see the comment\n\t\t * in kvm_mmu_zap_all_fast().  Note, is_obsolete_sp() also\n\t\t * treats invalid shadow pages as being obsolete.\n\t\t */\n\t\tzapped_root = !is_obsolete_sp(kvm, sp);\n\t}\n\n\tif (sp->lpage_disallowed)\n\t\tunaccount_huge_nx_page(kvm, sp);\n\n\tsp->role.invalid = 1;\n\n\t/*\n\t * Make the request to free obsolete roots after marking the root\n\t * invalid, otherwise other vCPUs may not see it as invalid.\n\t */\n\tif (zapped_root)\n\t\tkvm_make_all_cpus_request(kvm, KVM_REQ_MMU_FREE_OBSOLETE_ROOTS);\n\treturn list_unstable;\n}",
        "code_after_change": "static bool __kvm_mmu_prepare_zap_page(struct kvm *kvm,\n\t\t\t\t       struct kvm_mmu_page *sp,\n\t\t\t\t       struct list_head *invalid_list,\n\t\t\t\t       int *nr_zapped)\n{\n\tbool list_unstable, zapped_root = false;\n\n\tlockdep_assert_held_write(&kvm->mmu_lock);\n\ttrace_kvm_mmu_prepare_zap_page(sp);\n\t++kvm->stat.mmu_shadow_zapped;\n\t*nr_zapped = mmu_zap_unsync_children(kvm, sp, invalid_list);\n\t*nr_zapped += kvm_mmu_page_unlink_children(kvm, sp, invalid_list);\n\tkvm_mmu_unlink_parents(sp);\n\n\t/* Zapping children means active_mmu_pages has become unstable. */\n\tlist_unstable = *nr_zapped;\n\n\tif (!sp->role.invalid && sp_has_gptes(sp))\n\t\tunaccount_shadowed(kvm, sp);\n\n\tif (sp->unsync)\n\t\tkvm_unlink_unsync_page(kvm, sp);\n\tif (!sp->root_count) {\n\t\t/* Count self */\n\t\t(*nr_zapped)++;\n\n\t\t/*\n\t\t * Already invalid pages (previously active roots) are not on\n\t\t * the active page list.  See list_del() in the \"else\" case of\n\t\t * !sp->root_count.\n\t\t */\n\t\tif (sp->role.invalid)\n\t\t\tlist_add(&sp->link, invalid_list);\n\t\telse\n\t\t\tlist_move(&sp->link, invalid_list);\n\t\tkvm_unaccount_mmu_page(kvm, sp);\n\t} else {\n\t\t/*\n\t\t * Remove the active root from the active page list, the root\n\t\t * will be explicitly freed when the root_count hits zero.\n\t\t */\n\t\tlist_del(&sp->link);\n\n\t\t/*\n\t\t * Obsolete pages cannot be used on any vCPUs, see the comment\n\t\t * in kvm_mmu_zap_all_fast().  Note, is_obsolete_sp() also\n\t\t * treats invalid shadow pages as being obsolete.\n\t\t */\n\t\tzapped_root = !is_obsolete_sp(kvm, sp);\n\t}\n\n\tif (sp->lpage_disallowed)\n\t\tunaccount_huge_nx_page(kvm, sp);\n\n\tsp->role.invalid = 1;\n\n\t/*\n\t * Make the request to free obsolete roots after marking the root\n\t * invalid, otherwise other vCPUs may not see it as invalid.\n\t */\n\tif (zapped_root)\n\t\tkvm_make_all_cpus_request(kvm, KVM_REQ_MMU_FREE_OBSOLETE_ROOTS);\n\treturn list_unstable;\n}",
        "patch": "--- code before\n+++ code after\n@@ -5,6 +5,7 @@\n {\n \tbool list_unstable, zapped_root = false;\n \n+\tlockdep_assert_held_write(&kvm->mmu_lock);\n \ttrace_kvm_mmu_prepare_zap_page(sp);\n \t++kvm->stat.mmu_shadow_zapped;\n \t*nr_zapped = mmu_zap_unsync_children(kvm, sp, invalid_list);",
        "function_modified_lines": {
            "added": [
                "\tlockdep_assert_held_write(&kvm->mmu_lock);"
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "A race condition in the x86 KVM subsystem in the Linux kernel through 6.1-rc6 allows guest OS users to cause a denial of service (host OS crash or host OS memory corruption) when nested virtualisation and the TDP MMU are enabled.",
        "id": 3750
    },
    {
        "cve_id": "CVE-2020-27067",
        "code_before_change": "static int l2tp_eth_create(struct net *net, struct l2tp_tunnel *tunnel,\n\t\t\t   u32 session_id, u32 peer_session_id,\n\t\t\t   struct l2tp_session_cfg *cfg)\n{\n\tunsigned char name_assign_type;\n\tstruct net_device *dev;\n\tchar name[IFNAMSIZ];\n\tstruct l2tp_session *session;\n\tstruct l2tp_eth *priv;\n\tstruct l2tp_eth_sess *spriv;\n\tint rc;\n\tstruct l2tp_eth_net *pn;\n\n\tif (cfg->ifname) {\n\t\tstrlcpy(name, cfg->ifname, IFNAMSIZ);\n\t\tname_assign_type = NET_NAME_USER;\n\t} else {\n\t\tstrcpy(name, L2TP_ETH_DEV_NAME);\n\t\tname_assign_type = NET_NAME_ENUM;\n\t}\n\n\tsession = l2tp_session_create(sizeof(*spriv), tunnel, session_id,\n\t\t\t\t      peer_session_id, cfg);\n\tif (IS_ERR(session)) {\n\t\trc = PTR_ERR(session);\n\t\tgoto out;\n\t}\n\n\tdev = alloc_netdev(sizeof(*priv), name, name_assign_type,\n\t\t\t   l2tp_eth_dev_setup);\n\tif (!dev) {\n\t\trc = -ENOMEM;\n\t\tgoto out_del_session;\n\t}\n\n\tdev_net_set(dev, net);\n\tdev->min_mtu = 0;\n\tdev->max_mtu = ETH_MAX_MTU;\n\tl2tp_eth_adjust_mtu(tunnel, session, dev);\n\n\tpriv = netdev_priv(dev);\n\tpriv->dev = dev;\n\tpriv->session = session;\n\tINIT_LIST_HEAD(&priv->list);\n\n\tpriv->tunnel_sock = tunnel->sock;\n\tsession->recv_skb = l2tp_eth_dev_recv;\n\tsession->session_close = l2tp_eth_delete;\n#if IS_ENABLED(CONFIG_L2TP_DEBUGFS)\n\tsession->show = l2tp_eth_show;\n#endif\n\n\tspriv = l2tp_session_priv(session);\n\tspriv->dev = dev;\n\n\trc = register_netdev(dev);\n\tif (rc < 0)\n\t\tgoto out_del_dev;\n\n\t__module_get(THIS_MODULE);\n\t/* Must be done after register_netdev() */\n\tstrlcpy(session->ifname, dev->name, IFNAMSIZ);\n\n\tdev_hold(dev);\n\tpn = l2tp_eth_pernet(dev_net(dev));\n\tspin_lock(&pn->l2tp_eth_lock);\n\tlist_add(&priv->list, &pn->l2tp_eth_dev_list);\n\tspin_unlock(&pn->l2tp_eth_lock);\n\n\treturn 0;\n\nout_del_dev:\n\tfree_netdev(dev);\n\tspriv->dev = NULL;\nout_del_session:\n\tl2tp_session_delete(session);\nout:\n\treturn rc;\n}",
        "code_after_change": "static int l2tp_eth_create(struct net *net, struct l2tp_tunnel *tunnel,\n\t\t\t   u32 session_id, u32 peer_session_id,\n\t\t\t   struct l2tp_session_cfg *cfg)\n{\n\tunsigned char name_assign_type;\n\tstruct net_device *dev;\n\tchar name[IFNAMSIZ];\n\tstruct l2tp_session *session;\n\tstruct l2tp_eth *priv;\n\tstruct l2tp_eth_sess *spriv;\n\tint rc;\n\n\tif (cfg->ifname) {\n\t\tstrlcpy(name, cfg->ifname, IFNAMSIZ);\n\t\tname_assign_type = NET_NAME_USER;\n\t} else {\n\t\tstrcpy(name, L2TP_ETH_DEV_NAME);\n\t\tname_assign_type = NET_NAME_ENUM;\n\t}\n\n\tsession = l2tp_session_create(sizeof(*spriv), tunnel, session_id,\n\t\t\t\t      peer_session_id, cfg);\n\tif (IS_ERR(session)) {\n\t\trc = PTR_ERR(session);\n\t\tgoto out;\n\t}\n\n\tdev = alloc_netdev(sizeof(*priv), name, name_assign_type,\n\t\t\t   l2tp_eth_dev_setup);\n\tif (!dev) {\n\t\trc = -ENOMEM;\n\t\tgoto out_del_session;\n\t}\n\n\tdev_net_set(dev, net);\n\tdev->min_mtu = 0;\n\tdev->max_mtu = ETH_MAX_MTU;\n\tl2tp_eth_adjust_mtu(tunnel, session, dev);\n\n\tpriv = netdev_priv(dev);\n\tpriv->dev = dev;\n\tpriv->session = session;\n\n\tpriv->tunnel_sock = tunnel->sock;\n\tsession->recv_skb = l2tp_eth_dev_recv;\n\tsession->session_close = l2tp_eth_delete;\n#if IS_ENABLED(CONFIG_L2TP_DEBUGFS)\n\tsession->show = l2tp_eth_show;\n#endif\n\n\tspriv = l2tp_session_priv(session);\n\tspriv->dev = dev;\n\n\trc = register_netdev(dev);\n\tif (rc < 0)\n\t\tgoto out_del_dev;\n\n\t__module_get(THIS_MODULE);\n\t/* Must be done after register_netdev() */\n\tstrlcpy(session->ifname, dev->name, IFNAMSIZ);\n\n\tdev_hold(dev);\n\n\treturn 0;\n\nout_del_dev:\n\tfree_netdev(dev);\n\tspriv->dev = NULL;\nout_del_session:\n\tl2tp_session_delete(session);\nout:\n\treturn rc;\n}",
        "patch": "--- code before\n+++ code after\n@@ -9,7 +9,6 @@\n \tstruct l2tp_eth *priv;\n \tstruct l2tp_eth_sess *spriv;\n \tint rc;\n-\tstruct l2tp_eth_net *pn;\n \n \tif (cfg->ifname) {\n \t\tstrlcpy(name, cfg->ifname, IFNAMSIZ);\n@@ -41,7 +40,6 @@\n \tpriv = netdev_priv(dev);\n \tpriv->dev = dev;\n \tpriv->session = session;\n-\tINIT_LIST_HEAD(&priv->list);\n \n \tpriv->tunnel_sock = tunnel->sock;\n \tsession->recv_skb = l2tp_eth_dev_recv;\n@@ -62,10 +60,6 @@\n \tstrlcpy(session->ifname, dev->name, IFNAMSIZ);\n \n \tdev_hold(dev);\n-\tpn = l2tp_eth_pernet(dev_net(dev));\n-\tspin_lock(&pn->l2tp_eth_lock);\n-\tlist_add(&priv->list, &pn->l2tp_eth_dev_list);\n-\tspin_unlock(&pn->l2tp_eth_lock);\n \n \treturn 0;\n ",
        "function_modified_lines": {
            "added": [],
            "deleted": [
                "\tstruct l2tp_eth_net *pn;",
                "\tINIT_LIST_HEAD(&priv->list);",
                "\tpn = l2tp_eth_pernet(dev_net(dev));",
                "\tspin_lock(&pn->l2tp_eth_lock);",
                "\tlist_add(&priv->list, &pn->l2tp_eth_dev_list);",
                "\tspin_unlock(&pn->l2tp_eth_lock);"
            ]
        },
        "cwe": [
            "CWE-362",
            "CWE-416"
        ],
        "cve_description": "In the l2tp subsystem, there is a possible use after free due to a race condition. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-152409173",
        "id": 2612
    },
    {
        "cve_id": "CVE-2021-44733",
        "code_before_change": "struct tee_shm *tee_shm_get_from_id(struct tee_context *ctx, int id)\n{\n\tstruct tee_device *teedev;\n\tstruct tee_shm *shm;\n\n\tif (!ctx)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tteedev = ctx->teedev;\n\tmutex_lock(&teedev->mutex);\n\tshm = idr_find(&teedev->idr, id);\n\tif (!shm || shm->ctx != ctx)\n\t\tshm = ERR_PTR(-EINVAL);\n\telse if (shm->flags & TEE_SHM_DMA_BUF)\n\t\tget_dma_buf(shm->dmabuf);\n\tmutex_unlock(&teedev->mutex);\n\treturn shm;\n}",
        "code_after_change": "struct tee_shm *tee_shm_get_from_id(struct tee_context *ctx, int id)\n{\n\tstruct tee_device *teedev;\n\tstruct tee_shm *shm;\n\n\tif (!ctx)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tteedev = ctx->teedev;\n\tmutex_lock(&teedev->mutex);\n\tshm = idr_find(&teedev->idr, id);\n\t/*\n\t * If the tee_shm was found in the IDR it must have a refcount\n\t * larger than 0 due to the guarantee in tee_shm_put() below. So\n\t * it's safe to use refcount_inc().\n\t */\n\tif (!shm || shm->ctx != ctx)\n\t\tshm = ERR_PTR(-EINVAL);\n\telse\n\t\trefcount_inc(&shm->refcount);\n\tmutex_unlock(&teedev->mutex);\n\treturn shm;\n}",
        "patch": "--- code before\n+++ code after\n@@ -9,10 +9,15 @@\n \tteedev = ctx->teedev;\n \tmutex_lock(&teedev->mutex);\n \tshm = idr_find(&teedev->idr, id);\n+\t/*\n+\t * If the tee_shm was found in the IDR it must have a refcount\n+\t * larger than 0 due to the guarantee in tee_shm_put() below. So\n+\t * it's safe to use refcount_inc().\n+\t */\n \tif (!shm || shm->ctx != ctx)\n \t\tshm = ERR_PTR(-EINVAL);\n-\telse if (shm->flags & TEE_SHM_DMA_BUF)\n-\t\tget_dma_buf(shm->dmabuf);\n+\telse\n+\t\trefcount_inc(&shm->refcount);\n \tmutex_unlock(&teedev->mutex);\n \treturn shm;\n }",
        "function_modified_lines": {
            "added": [
                "\t/*",
                "\t * If the tee_shm was found in the IDR it must have a refcount",
                "\t * larger than 0 due to the guarantee in tee_shm_put() below. So",
                "\t * it's safe to use refcount_inc().",
                "\t */",
                "\telse",
                "\t\trefcount_inc(&shm->refcount);"
            ],
            "deleted": [
                "\telse if (shm->flags & TEE_SHM_DMA_BUF)",
                "\t\tget_dma_buf(shm->dmabuf);"
            ]
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "A use-after-free exists in drivers/tee/tee_shm.c in the TEE subsystem in the Linux kernel through 5.15.11. This occurs because of a race condition in tee_shm_get_from_id during an attempt to free a shared memory object.",
        "id": 3168
    },
    {
        "cve_id": "CVE-2019-18683",
        "code_before_change": "static int vivid_thread_vid_out(void *data)\n{\n\tstruct vivid_dev *dev = data;\n\tu64 numerators_since_start;\n\tu64 buffers_since_start;\n\tu64 next_jiffies_since_start;\n\tunsigned long jiffies_since_start;\n\tunsigned long cur_jiffies;\n\tunsigned wait_jiffies;\n\tunsigned numerator;\n\tunsigned denominator;\n\n\tdprintk(dev, 1, \"Video Output Thread Start\\n\");\n\n\tset_freezable();\n\n\t/* Resets frame counters */\n\tdev->out_seq_offset = 0;\n\tif (dev->seq_wrap)\n\t\tdev->out_seq_count = 0xffffff80U;\n\tdev->jiffies_vid_out = jiffies;\n\tdev->vid_out_seq_start = dev->vbi_out_seq_start = 0;\n\tdev->meta_out_seq_start = 0;\n\tdev->out_seq_resync = false;\n\n\tfor (;;) {\n\t\ttry_to_freeze();\n\t\tif (kthread_should_stop())\n\t\t\tbreak;\n\n\t\tmutex_lock(&dev->mutex);\n\t\tcur_jiffies = jiffies;\n\t\tif (dev->out_seq_resync) {\n\t\t\tdev->jiffies_vid_out = cur_jiffies;\n\t\t\tdev->out_seq_offset = dev->out_seq_count + 1;\n\t\t\tdev->out_seq_count = 0;\n\t\t\tdev->out_seq_resync = false;\n\t\t}\n\t\tnumerator = dev->timeperframe_vid_out.numerator;\n\t\tdenominator = dev->timeperframe_vid_out.denominator;\n\n\t\tif (dev->field_out == V4L2_FIELD_ALTERNATE)\n\t\t\tdenominator *= 2;\n\n\t\t/* Calculate the number of jiffies since we started streaming */\n\t\tjiffies_since_start = cur_jiffies - dev->jiffies_vid_out;\n\t\t/* Get the number of buffers streamed since the start */\n\t\tbuffers_since_start = (u64)jiffies_since_start * denominator +\n\t\t\t\t      (HZ * numerator) / 2;\n\t\tdo_div(buffers_since_start, HZ * numerator);\n\n\t\t/*\n\t\t * After more than 0xf0000000 (rounded down to a multiple of\n\t\t * 'jiffies-per-day' to ease jiffies_to_msecs calculation)\n\t\t * jiffies have passed since we started streaming reset the\n\t\t * counters and keep track of the sequence offset.\n\t\t */\n\t\tif (jiffies_since_start > JIFFIES_RESYNC) {\n\t\t\tdev->jiffies_vid_out = cur_jiffies;\n\t\t\tdev->out_seq_offset = buffers_since_start;\n\t\t\tbuffers_since_start = 0;\n\t\t}\n\t\tdev->out_seq_count = buffers_since_start + dev->out_seq_offset;\n\t\tdev->vid_out_seq_count = dev->out_seq_count - dev->vid_out_seq_start;\n\t\tdev->vbi_out_seq_count = dev->out_seq_count - dev->vbi_out_seq_start;\n\t\tdev->meta_out_seq_count = dev->out_seq_count - dev->meta_out_seq_start;\n\n\t\tvivid_thread_vid_out_tick(dev);\n\t\tmutex_unlock(&dev->mutex);\n\n\t\t/*\n\t\t * Calculate the number of 'numerators' streamed since we started,\n\t\t * not including the current buffer.\n\t\t */\n\t\tnumerators_since_start = buffers_since_start * numerator;\n\n\t\t/* And the number of jiffies since we started */\n\t\tjiffies_since_start = jiffies - dev->jiffies_vid_out;\n\n\t\t/* Increase by the 'numerator' of one buffer */\n\t\tnumerators_since_start += numerator;\n\t\t/*\n\t\t * Calculate when that next buffer is supposed to start\n\t\t * in jiffies since we started streaming.\n\t\t */\n\t\tnext_jiffies_since_start = numerators_since_start * HZ +\n\t\t\t\t\t   denominator / 2;\n\t\tdo_div(next_jiffies_since_start, denominator);\n\t\t/* If it is in the past, then just schedule asap */\n\t\tif (next_jiffies_since_start < jiffies_since_start)\n\t\t\tnext_jiffies_since_start = jiffies_since_start;\n\n\t\twait_jiffies = next_jiffies_since_start - jiffies_since_start;\n\t\tschedule_timeout_interruptible(wait_jiffies ? wait_jiffies : 1);\n\t}\n\tdprintk(dev, 1, \"Video Output Thread End\\n\");\n\treturn 0;\n}",
        "code_after_change": "static int vivid_thread_vid_out(void *data)\n{\n\tstruct vivid_dev *dev = data;\n\tu64 numerators_since_start;\n\tu64 buffers_since_start;\n\tu64 next_jiffies_since_start;\n\tunsigned long jiffies_since_start;\n\tunsigned long cur_jiffies;\n\tunsigned wait_jiffies;\n\tunsigned numerator;\n\tunsigned denominator;\n\n\tdprintk(dev, 1, \"Video Output Thread Start\\n\");\n\n\tset_freezable();\n\n\t/* Resets frame counters */\n\tdev->out_seq_offset = 0;\n\tif (dev->seq_wrap)\n\t\tdev->out_seq_count = 0xffffff80U;\n\tdev->jiffies_vid_out = jiffies;\n\tdev->vid_out_seq_start = dev->vbi_out_seq_start = 0;\n\tdev->meta_out_seq_start = 0;\n\tdev->out_seq_resync = false;\n\n\tfor (;;) {\n\t\ttry_to_freeze();\n\t\tif (kthread_should_stop())\n\t\t\tbreak;\n\n\t\tif (!mutex_trylock(&dev->mutex)) {\n\t\t\tschedule_timeout_uninterruptible(1);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcur_jiffies = jiffies;\n\t\tif (dev->out_seq_resync) {\n\t\t\tdev->jiffies_vid_out = cur_jiffies;\n\t\t\tdev->out_seq_offset = dev->out_seq_count + 1;\n\t\t\tdev->out_seq_count = 0;\n\t\t\tdev->out_seq_resync = false;\n\t\t}\n\t\tnumerator = dev->timeperframe_vid_out.numerator;\n\t\tdenominator = dev->timeperframe_vid_out.denominator;\n\n\t\tif (dev->field_out == V4L2_FIELD_ALTERNATE)\n\t\t\tdenominator *= 2;\n\n\t\t/* Calculate the number of jiffies since we started streaming */\n\t\tjiffies_since_start = cur_jiffies - dev->jiffies_vid_out;\n\t\t/* Get the number of buffers streamed since the start */\n\t\tbuffers_since_start = (u64)jiffies_since_start * denominator +\n\t\t\t\t      (HZ * numerator) / 2;\n\t\tdo_div(buffers_since_start, HZ * numerator);\n\n\t\t/*\n\t\t * After more than 0xf0000000 (rounded down to a multiple of\n\t\t * 'jiffies-per-day' to ease jiffies_to_msecs calculation)\n\t\t * jiffies have passed since we started streaming reset the\n\t\t * counters and keep track of the sequence offset.\n\t\t */\n\t\tif (jiffies_since_start > JIFFIES_RESYNC) {\n\t\t\tdev->jiffies_vid_out = cur_jiffies;\n\t\t\tdev->out_seq_offset = buffers_since_start;\n\t\t\tbuffers_since_start = 0;\n\t\t}\n\t\tdev->out_seq_count = buffers_since_start + dev->out_seq_offset;\n\t\tdev->vid_out_seq_count = dev->out_seq_count - dev->vid_out_seq_start;\n\t\tdev->vbi_out_seq_count = dev->out_seq_count - dev->vbi_out_seq_start;\n\t\tdev->meta_out_seq_count = dev->out_seq_count - dev->meta_out_seq_start;\n\n\t\tvivid_thread_vid_out_tick(dev);\n\t\tmutex_unlock(&dev->mutex);\n\n\t\t/*\n\t\t * Calculate the number of 'numerators' streamed since we started,\n\t\t * not including the current buffer.\n\t\t */\n\t\tnumerators_since_start = buffers_since_start * numerator;\n\n\t\t/* And the number of jiffies since we started */\n\t\tjiffies_since_start = jiffies - dev->jiffies_vid_out;\n\n\t\t/* Increase by the 'numerator' of one buffer */\n\t\tnumerators_since_start += numerator;\n\t\t/*\n\t\t * Calculate when that next buffer is supposed to start\n\t\t * in jiffies since we started streaming.\n\t\t */\n\t\tnext_jiffies_since_start = numerators_since_start * HZ +\n\t\t\t\t\t   denominator / 2;\n\t\tdo_div(next_jiffies_since_start, denominator);\n\t\t/* If it is in the past, then just schedule asap */\n\t\tif (next_jiffies_since_start < jiffies_since_start)\n\t\t\tnext_jiffies_since_start = jiffies_since_start;\n\n\t\twait_jiffies = next_jiffies_since_start - jiffies_since_start;\n\t\tschedule_timeout_interruptible(wait_jiffies ? wait_jiffies : 1);\n\t}\n\tdprintk(dev, 1, \"Video Output Thread End\\n\");\n\treturn 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -28,7 +28,11 @@\n \t\tif (kthread_should_stop())\n \t\t\tbreak;\n \n-\t\tmutex_lock(&dev->mutex);\n+\t\tif (!mutex_trylock(&dev->mutex)) {\n+\t\t\tschedule_timeout_uninterruptible(1);\n+\t\t\tcontinue;\n+\t\t}\n+\n \t\tcur_jiffies = jiffies;\n \t\tif (dev->out_seq_resync) {\n \t\t\tdev->jiffies_vid_out = cur_jiffies;",
        "function_modified_lines": {
            "added": [
                "\t\tif (!mutex_trylock(&dev->mutex)) {",
                "\t\t\tschedule_timeout_uninterruptible(1);",
                "\t\t\tcontinue;",
                "\t\t}",
                ""
            ],
            "deleted": [
                "\t\tmutex_lock(&dev->mutex);"
            ]
        },
        "cwe": [
            "CWE-362",
            "CWE-416"
        ],
        "cve_description": "An issue was discovered in drivers/media/platform/vivid in the Linux kernel through 5.3.8. It is exploitable for privilege escalation on some Linux distributions where local users have /dev/video0 access, but only if the driver happens to be loaded. There are multiple race conditions during streaming stopping in this driver (part of the V4L2 subsystem). These issues are caused by wrong mutex locking in vivid_stop_generating_vid_cap(), vivid_stop_generating_vid_out(), sdr_cap_stop_streaming(), and the corresponding kthreads. At least one of these race conditions leads to a use-after-free.",
        "id": 2093
    },
    {
        "cve_id": "CVE-2019-18683",
        "code_before_change": "static int vivid_thread_vid_cap(void *data)\n{\n\tstruct vivid_dev *dev = data;\n\tu64 numerators_since_start;\n\tu64 buffers_since_start;\n\tu64 next_jiffies_since_start;\n\tunsigned long jiffies_since_start;\n\tunsigned long cur_jiffies;\n\tunsigned wait_jiffies;\n\tunsigned numerator;\n\tunsigned denominator;\n\tint dropped_bufs;\n\n\tdprintk(dev, 1, \"Video Capture Thread Start\\n\");\n\n\tset_freezable();\n\n\t/* Resets frame counters */\n\tdev->cap_seq_offset = 0;\n\tdev->cap_seq_count = 0;\n\tdev->cap_seq_resync = false;\n\tdev->jiffies_vid_cap = jiffies;\n\tdev->cap_stream_start = ktime_get_ns();\n\tvivid_cap_update_frame_period(dev);\n\n\tfor (;;) {\n\t\ttry_to_freeze();\n\t\tif (kthread_should_stop())\n\t\t\tbreak;\n\n\t\tmutex_lock(&dev->mutex);\n\t\tcur_jiffies = jiffies;\n\t\tif (dev->cap_seq_resync) {\n\t\t\tdev->jiffies_vid_cap = cur_jiffies;\n\t\t\tdev->cap_seq_offset = dev->cap_seq_count + 1;\n\t\t\tdev->cap_seq_count = 0;\n\t\t\tdev->cap_stream_start += dev->cap_frame_period *\n\t\t\t\t\t\t dev->cap_seq_offset;\n\t\t\tvivid_cap_update_frame_period(dev);\n\t\t\tdev->cap_seq_resync = false;\n\t\t}\n\t\tnumerator = dev->timeperframe_vid_cap.numerator;\n\t\tdenominator = dev->timeperframe_vid_cap.denominator;\n\n\t\tif (dev->field_cap == V4L2_FIELD_ALTERNATE)\n\t\t\tdenominator *= 2;\n\n\t\t/* Calculate the number of jiffies since we started streaming */\n\t\tjiffies_since_start = cur_jiffies - dev->jiffies_vid_cap;\n\t\t/* Get the number of buffers streamed since the start */\n\t\tbuffers_since_start = (u64)jiffies_since_start * denominator +\n\t\t\t\t      (HZ * numerator) / 2;\n\t\tdo_div(buffers_since_start, HZ * numerator);\n\n\t\t/*\n\t\t * After more than 0xf0000000 (rounded down to a multiple of\n\t\t * 'jiffies-per-day' to ease jiffies_to_msecs calculation)\n\t\t * jiffies have passed since we started streaming reset the\n\t\t * counters and keep track of the sequence offset.\n\t\t */\n\t\tif (jiffies_since_start > JIFFIES_RESYNC) {\n\t\t\tdev->jiffies_vid_cap = cur_jiffies;\n\t\t\tdev->cap_seq_offset = buffers_since_start;\n\t\t\tbuffers_since_start = 0;\n\t\t}\n\t\tdropped_bufs = buffers_since_start + dev->cap_seq_offset - dev->cap_seq_count;\n\t\tdev->cap_seq_count = buffers_since_start + dev->cap_seq_offset;\n\t\tdev->vid_cap_seq_count = dev->cap_seq_count - dev->vid_cap_seq_start;\n\t\tdev->vbi_cap_seq_count = dev->cap_seq_count - dev->vbi_cap_seq_start;\n\t\tdev->meta_cap_seq_count = dev->cap_seq_count - dev->meta_cap_seq_start;\n\n\t\tvivid_thread_vid_cap_tick(dev, dropped_bufs);\n\n\t\t/*\n\t\t * Calculate the number of 'numerators' streamed since we started,\n\t\t * including the current buffer.\n\t\t */\n\t\tnumerators_since_start = ++buffers_since_start * numerator;\n\n\t\t/* And the number of jiffies since we started */\n\t\tjiffies_since_start = jiffies - dev->jiffies_vid_cap;\n\n\t\tmutex_unlock(&dev->mutex);\n\n\t\t/*\n\t\t * Calculate when that next buffer is supposed to start\n\t\t * in jiffies since we started streaming.\n\t\t */\n\t\tnext_jiffies_since_start = numerators_since_start * HZ +\n\t\t\t\t\t   denominator / 2;\n\t\tdo_div(next_jiffies_since_start, denominator);\n\t\t/* If it is in the past, then just schedule asap */\n\t\tif (next_jiffies_since_start < jiffies_since_start)\n\t\t\tnext_jiffies_since_start = jiffies_since_start;\n\n\t\twait_jiffies = next_jiffies_since_start - jiffies_since_start;\n\t\tschedule_timeout_interruptible(wait_jiffies ? wait_jiffies : 1);\n\t}\n\tdprintk(dev, 1, \"Video Capture Thread End\\n\");\n\treturn 0;\n}",
        "code_after_change": "static int vivid_thread_vid_cap(void *data)\n{\n\tstruct vivid_dev *dev = data;\n\tu64 numerators_since_start;\n\tu64 buffers_since_start;\n\tu64 next_jiffies_since_start;\n\tunsigned long jiffies_since_start;\n\tunsigned long cur_jiffies;\n\tunsigned wait_jiffies;\n\tunsigned numerator;\n\tunsigned denominator;\n\tint dropped_bufs;\n\n\tdprintk(dev, 1, \"Video Capture Thread Start\\n\");\n\n\tset_freezable();\n\n\t/* Resets frame counters */\n\tdev->cap_seq_offset = 0;\n\tdev->cap_seq_count = 0;\n\tdev->cap_seq_resync = false;\n\tdev->jiffies_vid_cap = jiffies;\n\tdev->cap_stream_start = ktime_get_ns();\n\tvivid_cap_update_frame_period(dev);\n\n\tfor (;;) {\n\t\ttry_to_freeze();\n\t\tif (kthread_should_stop())\n\t\t\tbreak;\n\n\t\tif (!mutex_trylock(&dev->mutex)) {\n\t\t\tschedule_timeout_uninterruptible(1);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcur_jiffies = jiffies;\n\t\tif (dev->cap_seq_resync) {\n\t\t\tdev->jiffies_vid_cap = cur_jiffies;\n\t\t\tdev->cap_seq_offset = dev->cap_seq_count + 1;\n\t\t\tdev->cap_seq_count = 0;\n\t\t\tdev->cap_stream_start += dev->cap_frame_period *\n\t\t\t\t\t\t dev->cap_seq_offset;\n\t\t\tvivid_cap_update_frame_period(dev);\n\t\t\tdev->cap_seq_resync = false;\n\t\t}\n\t\tnumerator = dev->timeperframe_vid_cap.numerator;\n\t\tdenominator = dev->timeperframe_vid_cap.denominator;\n\n\t\tif (dev->field_cap == V4L2_FIELD_ALTERNATE)\n\t\t\tdenominator *= 2;\n\n\t\t/* Calculate the number of jiffies since we started streaming */\n\t\tjiffies_since_start = cur_jiffies - dev->jiffies_vid_cap;\n\t\t/* Get the number of buffers streamed since the start */\n\t\tbuffers_since_start = (u64)jiffies_since_start * denominator +\n\t\t\t\t      (HZ * numerator) / 2;\n\t\tdo_div(buffers_since_start, HZ * numerator);\n\n\t\t/*\n\t\t * After more than 0xf0000000 (rounded down to a multiple of\n\t\t * 'jiffies-per-day' to ease jiffies_to_msecs calculation)\n\t\t * jiffies have passed since we started streaming reset the\n\t\t * counters and keep track of the sequence offset.\n\t\t */\n\t\tif (jiffies_since_start > JIFFIES_RESYNC) {\n\t\t\tdev->jiffies_vid_cap = cur_jiffies;\n\t\t\tdev->cap_seq_offset = buffers_since_start;\n\t\t\tbuffers_since_start = 0;\n\t\t}\n\t\tdropped_bufs = buffers_since_start + dev->cap_seq_offset - dev->cap_seq_count;\n\t\tdev->cap_seq_count = buffers_since_start + dev->cap_seq_offset;\n\t\tdev->vid_cap_seq_count = dev->cap_seq_count - dev->vid_cap_seq_start;\n\t\tdev->vbi_cap_seq_count = dev->cap_seq_count - dev->vbi_cap_seq_start;\n\t\tdev->meta_cap_seq_count = dev->cap_seq_count - dev->meta_cap_seq_start;\n\n\t\tvivid_thread_vid_cap_tick(dev, dropped_bufs);\n\n\t\t/*\n\t\t * Calculate the number of 'numerators' streamed since we started,\n\t\t * including the current buffer.\n\t\t */\n\t\tnumerators_since_start = ++buffers_since_start * numerator;\n\n\t\t/* And the number of jiffies since we started */\n\t\tjiffies_since_start = jiffies - dev->jiffies_vid_cap;\n\n\t\tmutex_unlock(&dev->mutex);\n\n\t\t/*\n\t\t * Calculate when that next buffer is supposed to start\n\t\t * in jiffies since we started streaming.\n\t\t */\n\t\tnext_jiffies_since_start = numerators_since_start * HZ +\n\t\t\t\t\t   denominator / 2;\n\t\tdo_div(next_jiffies_since_start, denominator);\n\t\t/* If it is in the past, then just schedule asap */\n\t\tif (next_jiffies_since_start < jiffies_since_start)\n\t\t\tnext_jiffies_since_start = jiffies_since_start;\n\n\t\twait_jiffies = next_jiffies_since_start - jiffies_since_start;\n\t\tschedule_timeout_interruptible(wait_jiffies ? wait_jiffies : 1);\n\t}\n\tdprintk(dev, 1, \"Video Capture Thread End\\n\");\n\treturn 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -28,7 +28,11 @@\n \t\tif (kthread_should_stop())\n \t\t\tbreak;\n \n-\t\tmutex_lock(&dev->mutex);\n+\t\tif (!mutex_trylock(&dev->mutex)) {\n+\t\t\tschedule_timeout_uninterruptible(1);\n+\t\t\tcontinue;\n+\t\t}\n+\n \t\tcur_jiffies = jiffies;\n \t\tif (dev->cap_seq_resync) {\n \t\t\tdev->jiffies_vid_cap = cur_jiffies;",
        "function_modified_lines": {
            "added": [
                "\t\tif (!mutex_trylock(&dev->mutex)) {",
                "\t\t\tschedule_timeout_uninterruptible(1);",
                "\t\t\tcontinue;",
                "\t\t}",
                ""
            ],
            "deleted": [
                "\t\tmutex_lock(&dev->mutex);"
            ]
        },
        "cwe": [
            "CWE-362",
            "CWE-416"
        ],
        "cve_description": "An issue was discovered in drivers/media/platform/vivid in the Linux kernel through 5.3.8. It is exploitable for privilege escalation on some Linux distributions where local users have /dev/video0 access, but only if the driver happens to be loaded. There are multiple race conditions during streaming stopping in this driver (part of the V4L2 subsystem). These issues are caused by wrong mutex locking in vivid_stop_generating_vid_cap(), vivid_stop_generating_vid_out(), sdr_cap_stop_streaming(), and the corresponding kthreads. At least one of these race conditions leads to a use-after-free.",
        "id": 2092
    },
    {
        "cve_id": "CVE-2019-18683",
        "code_before_change": "static void sdr_cap_stop_streaming(struct vb2_queue *vq)\n{\n\tstruct vivid_dev *dev = vb2_get_drv_priv(vq);\n\n\tif (dev->kthread_sdr_cap == NULL)\n\t\treturn;\n\n\twhile (!list_empty(&dev->sdr_cap_active)) {\n\t\tstruct vivid_buffer *buf;\n\n\t\tbuf = list_entry(dev->sdr_cap_active.next,\n\t\t\t\tstruct vivid_buffer, list);\n\t\tlist_del(&buf->list);\n\t\tv4l2_ctrl_request_complete(buf->vb.vb2_buf.req_obj.req,\n\t\t\t\t\t   &dev->ctrl_hdl_sdr_cap);\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\n\t}\n\n\t/* shutdown control thread */\n\tmutex_unlock(&dev->mutex);\n\tkthread_stop(dev->kthread_sdr_cap);\n\tdev->kthread_sdr_cap = NULL;\n\tmutex_lock(&dev->mutex);\n}",
        "code_after_change": "static void sdr_cap_stop_streaming(struct vb2_queue *vq)\n{\n\tstruct vivid_dev *dev = vb2_get_drv_priv(vq);\n\n\tif (dev->kthread_sdr_cap == NULL)\n\t\treturn;\n\n\twhile (!list_empty(&dev->sdr_cap_active)) {\n\t\tstruct vivid_buffer *buf;\n\n\t\tbuf = list_entry(dev->sdr_cap_active.next,\n\t\t\t\tstruct vivid_buffer, list);\n\t\tlist_del(&buf->list);\n\t\tv4l2_ctrl_request_complete(buf->vb.vb2_buf.req_obj.req,\n\t\t\t\t\t   &dev->ctrl_hdl_sdr_cap);\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\n\t}\n\n\t/* shutdown control thread */\n\tkthread_stop(dev->kthread_sdr_cap);\n\tdev->kthread_sdr_cap = NULL;\n}",
        "patch": "--- code before\n+++ code after\n@@ -17,8 +17,6 @@\n \t}\n \n \t/* shutdown control thread */\n-\tmutex_unlock(&dev->mutex);\n \tkthread_stop(dev->kthread_sdr_cap);\n \tdev->kthread_sdr_cap = NULL;\n-\tmutex_lock(&dev->mutex);\n }",
        "function_modified_lines": {
            "added": [],
            "deleted": [
                "\tmutex_unlock(&dev->mutex);",
                "\tmutex_lock(&dev->mutex);"
            ]
        },
        "cwe": [
            "CWE-362",
            "CWE-416"
        ],
        "cve_description": "An issue was discovered in drivers/media/platform/vivid in the Linux kernel through 5.3.8. It is exploitable for privilege escalation on some Linux distributions where local users have /dev/video0 access, but only if the driver happens to be loaded. There are multiple race conditions during streaming stopping in this driver (part of the V4L2 subsystem). These issues are caused by wrong mutex locking in vivid_stop_generating_vid_cap(), vivid_stop_generating_vid_out(), sdr_cap_stop_streaming(), and the corresponding kthreads. At least one of these race conditions leads to a use-after-free.",
        "id": 2095
    },
    {
        "cve_id": "CVE-2016-2069",
        "code_before_change": "void flush_tlb_current_task(void)\n{\n\tstruct mm_struct *mm = current->mm;\n\n\tpreempt_disable();\n\n\tcount_vm_tlb_event(NR_TLB_LOCAL_FLUSH_ALL);\n\tlocal_flush_tlb();\n\ttrace_tlb_flush(TLB_LOCAL_SHOOTDOWN, TLB_FLUSH_ALL);\n\tif (cpumask_any_but(mm_cpumask(mm), smp_processor_id()) < nr_cpu_ids)\n\t\tflush_tlb_others(mm_cpumask(mm), mm, 0UL, TLB_FLUSH_ALL);\n\tpreempt_enable();\n}",
        "code_after_change": "void flush_tlb_current_task(void)\n{\n\tstruct mm_struct *mm = current->mm;\n\n\tpreempt_disable();\n\n\tcount_vm_tlb_event(NR_TLB_LOCAL_FLUSH_ALL);\n\n\t/* This is an implicit full barrier that synchronizes with switch_mm. */\n\tlocal_flush_tlb();\n\n\ttrace_tlb_flush(TLB_LOCAL_SHOOTDOWN, TLB_FLUSH_ALL);\n\tif (cpumask_any_but(mm_cpumask(mm), smp_processor_id()) < nr_cpu_ids)\n\t\tflush_tlb_others(mm_cpumask(mm), mm, 0UL, TLB_FLUSH_ALL);\n\tpreempt_enable();\n}",
        "patch": "--- code before\n+++ code after\n@@ -5,7 +5,10 @@\n \tpreempt_disable();\n \n \tcount_vm_tlb_event(NR_TLB_LOCAL_FLUSH_ALL);\n+\n+\t/* This is an implicit full barrier that synchronizes with switch_mm. */\n \tlocal_flush_tlb();\n+\n \ttrace_tlb_flush(TLB_LOCAL_SHOOTDOWN, TLB_FLUSH_ALL);\n \tif (cpumask_any_but(mm_cpumask(mm), smp_processor_id()) < nr_cpu_ids)\n \t\tflush_tlb_others(mm_cpumask(mm), mm, 0UL, TLB_FLUSH_ALL);",
        "function_modified_lines": {
            "added": [
                "",
                "\t/* This is an implicit full barrier that synchronizes with switch_mm. */",
                ""
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "Race condition in arch/x86/mm/tlb.c in the Linux kernel before 4.4.1 allows local users to gain privileges by triggering access to a paging structure by a different CPU.",
        "id": 917
    },
    {
        "cve_id": "CVE-2016-8655",
        "code_before_change": "static int\npacket_setsockopt(struct socket *sock, int level, int optname, char __user *optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct packet_sock *po = pkt_sk(sk);\n\tint ret;\n\n\tif (level != SOL_PACKET)\n\t\treturn -ENOPROTOOPT;\n\n\tswitch (optname) {\n\tcase PACKET_ADD_MEMBERSHIP:\n\tcase PACKET_DROP_MEMBERSHIP:\n\t{\n\t\tstruct packet_mreq_max mreq;\n\t\tint len = optlen;\n\t\tmemset(&mreq, 0, sizeof(mreq));\n\t\tif (len < sizeof(struct packet_mreq))\n\t\t\treturn -EINVAL;\n\t\tif (len > sizeof(mreq))\n\t\t\tlen = sizeof(mreq);\n\t\tif (copy_from_user(&mreq, optval, len))\n\t\t\treturn -EFAULT;\n\t\tif (len < (mreq.mr_alen + offsetof(struct packet_mreq, mr_address)))\n\t\t\treturn -EINVAL;\n\t\tif (optname == PACKET_ADD_MEMBERSHIP)\n\t\t\tret = packet_mc_add(sk, &mreq);\n\t\telse\n\t\t\tret = packet_mc_drop(sk, &mreq);\n\t\treturn ret;\n\t}\n\n\tcase PACKET_RX_RING:\n\tcase PACKET_TX_RING:\n\t{\n\t\tunion tpacket_req_u req_u;\n\t\tint len;\n\n\t\tswitch (po->tp_version) {\n\t\tcase TPACKET_V1:\n\t\tcase TPACKET_V2:\n\t\t\tlen = sizeof(req_u.req);\n\t\t\tbreak;\n\t\tcase TPACKET_V3:\n\t\tdefault:\n\t\t\tlen = sizeof(req_u.req3);\n\t\t\tbreak;\n\t\t}\n\t\tif (optlen < len)\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&req_u.req, optval, len))\n\t\t\treturn -EFAULT;\n\t\treturn packet_set_ring(sk, &req_u, 0,\n\t\t\toptname == PACKET_TX_RING);\n\t}\n\tcase PACKET_COPY_THRESH:\n\t{\n\t\tint val;\n\n\t\tif (optlen != sizeof(val))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&val, optval, sizeof(val)))\n\t\t\treturn -EFAULT;\n\n\t\tpkt_sk(sk)->copy_thresh = val;\n\t\treturn 0;\n\t}\n\tcase PACKET_VERSION:\n\t{\n\t\tint val;\n\n\t\tif (optlen != sizeof(val))\n\t\t\treturn -EINVAL;\n\t\tif (po->rx_ring.pg_vec || po->tx_ring.pg_vec)\n\t\t\treturn -EBUSY;\n\t\tif (copy_from_user(&val, optval, sizeof(val)))\n\t\t\treturn -EFAULT;\n\t\tswitch (val) {\n\t\tcase TPACKET_V1:\n\t\tcase TPACKET_V2:\n\t\tcase TPACKET_V3:\n\t\t\tpo->tp_version = val;\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tcase PACKET_RESERVE:\n\t{\n\t\tunsigned int val;\n\n\t\tif (optlen != sizeof(val))\n\t\t\treturn -EINVAL;\n\t\tif (po->rx_ring.pg_vec || po->tx_ring.pg_vec)\n\t\t\treturn -EBUSY;\n\t\tif (copy_from_user(&val, optval, sizeof(val)))\n\t\t\treturn -EFAULT;\n\t\tpo->tp_reserve = val;\n\t\treturn 0;\n\t}\n\tcase PACKET_LOSS:\n\t{\n\t\tunsigned int val;\n\n\t\tif (optlen != sizeof(val))\n\t\t\treturn -EINVAL;\n\t\tif (po->rx_ring.pg_vec || po->tx_ring.pg_vec)\n\t\t\treturn -EBUSY;\n\t\tif (copy_from_user(&val, optval, sizeof(val)))\n\t\t\treturn -EFAULT;\n\t\tpo->tp_loss = !!val;\n\t\treturn 0;\n\t}\n\tcase PACKET_AUXDATA:\n\t{\n\t\tint val;\n\n\t\tif (optlen < sizeof(val))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&val, optval, sizeof(val)))\n\t\t\treturn -EFAULT;\n\n\t\tpo->auxdata = !!val;\n\t\treturn 0;\n\t}\n\tcase PACKET_ORIGDEV:\n\t{\n\t\tint val;\n\n\t\tif (optlen < sizeof(val))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&val, optval, sizeof(val)))\n\t\t\treturn -EFAULT;\n\n\t\tpo->origdev = !!val;\n\t\treturn 0;\n\t}\n\tcase PACKET_VNET_HDR:\n\t{\n\t\tint val;\n\n\t\tif (sock->type != SOCK_RAW)\n\t\t\treturn -EINVAL;\n\t\tif (po->rx_ring.pg_vec || po->tx_ring.pg_vec)\n\t\t\treturn -EBUSY;\n\t\tif (optlen < sizeof(val))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&val, optval, sizeof(val)))\n\t\t\treturn -EFAULT;\n\n\t\tpo->has_vnet_hdr = !!val;\n\t\treturn 0;\n\t}\n\tcase PACKET_TIMESTAMP:\n\t{\n\t\tint val;\n\n\t\tif (optlen != sizeof(val))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&val, optval, sizeof(val)))\n\t\t\treturn -EFAULT;\n\n\t\tpo->tp_tstamp = val;\n\t\treturn 0;\n\t}\n\tcase PACKET_FANOUT:\n\t{\n\t\tint val;\n\n\t\tif (optlen != sizeof(val))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&val, optval, sizeof(val)))\n\t\t\treturn -EFAULT;\n\n\t\treturn fanout_add(sk, val & 0xffff, val >> 16);\n\t}\n\tcase PACKET_FANOUT_DATA:\n\t{\n\t\tif (!po->fanout)\n\t\t\treturn -EINVAL;\n\n\t\treturn fanout_set_data(po, optval, optlen);\n\t}\n\tcase PACKET_TX_HAS_OFF:\n\t{\n\t\tunsigned int val;\n\n\t\tif (optlen != sizeof(val))\n\t\t\treturn -EINVAL;\n\t\tif (po->rx_ring.pg_vec || po->tx_ring.pg_vec)\n\t\t\treturn -EBUSY;\n\t\tif (copy_from_user(&val, optval, sizeof(val)))\n\t\t\treturn -EFAULT;\n\t\tpo->tp_tx_has_off = !!val;\n\t\treturn 0;\n\t}\n\tcase PACKET_QDISC_BYPASS:\n\t{\n\t\tint val;\n\n\t\tif (optlen != sizeof(val))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&val, optval, sizeof(val)))\n\t\t\treturn -EFAULT;\n\n\t\tpo->xmit = val ? packet_direct_xmit : dev_queue_xmit;\n\t\treturn 0;\n\t}\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n}",
        "code_after_change": "static int\npacket_setsockopt(struct socket *sock, int level, int optname, char __user *optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct packet_sock *po = pkt_sk(sk);\n\tint ret;\n\n\tif (level != SOL_PACKET)\n\t\treturn -ENOPROTOOPT;\n\n\tswitch (optname) {\n\tcase PACKET_ADD_MEMBERSHIP:\n\tcase PACKET_DROP_MEMBERSHIP:\n\t{\n\t\tstruct packet_mreq_max mreq;\n\t\tint len = optlen;\n\t\tmemset(&mreq, 0, sizeof(mreq));\n\t\tif (len < sizeof(struct packet_mreq))\n\t\t\treturn -EINVAL;\n\t\tif (len > sizeof(mreq))\n\t\t\tlen = sizeof(mreq);\n\t\tif (copy_from_user(&mreq, optval, len))\n\t\t\treturn -EFAULT;\n\t\tif (len < (mreq.mr_alen + offsetof(struct packet_mreq, mr_address)))\n\t\t\treturn -EINVAL;\n\t\tif (optname == PACKET_ADD_MEMBERSHIP)\n\t\t\tret = packet_mc_add(sk, &mreq);\n\t\telse\n\t\t\tret = packet_mc_drop(sk, &mreq);\n\t\treturn ret;\n\t}\n\n\tcase PACKET_RX_RING:\n\tcase PACKET_TX_RING:\n\t{\n\t\tunion tpacket_req_u req_u;\n\t\tint len;\n\n\t\tswitch (po->tp_version) {\n\t\tcase TPACKET_V1:\n\t\tcase TPACKET_V2:\n\t\t\tlen = sizeof(req_u.req);\n\t\t\tbreak;\n\t\tcase TPACKET_V3:\n\t\tdefault:\n\t\t\tlen = sizeof(req_u.req3);\n\t\t\tbreak;\n\t\t}\n\t\tif (optlen < len)\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&req_u.req, optval, len))\n\t\t\treturn -EFAULT;\n\t\treturn packet_set_ring(sk, &req_u, 0,\n\t\t\toptname == PACKET_TX_RING);\n\t}\n\tcase PACKET_COPY_THRESH:\n\t{\n\t\tint val;\n\n\t\tif (optlen != sizeof(val))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&val, optval, sizeof(val)))\n\t\t\treturn -EFAULT;\n\n\t\tpkt_sk(sk)->copy_thresh = val;\n\t\treturn 0;\n\t}\n\tcase PACKET_VERSION:\n\t{\n\t\tint val;\n\n\t\tif (optlen != sizeof(val))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&val, optval, sizeof(val)))\n\t\t\treturn -EFAULT;\n\t\tswitch (val) {\n\t\tcase TPACKET_V1:\n\t\tcase TPACKET_V2:\n\t\tcase TPACKET_V3:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tlock_sock(sk);\n\t\tif (po->rx_ring.pg_vec || po->tx_ring.pg_vec) {\n\t\t\tret = -EBUSY;\n\t\t} else {\n\t\t\tpo->tp_version = val;\n\t\t\tret = 0;\n\t\t}\n\t\trelease_sock(sk);\n\t\treturn ret;\n\t}\n\tcase PACKET_RESERVE:\n\t{\n\t\tunsigned int val;\n\n\t\tif (optlen != sizeof(val))\n\t\t\treturn -EINVAL;\n\t\tif (po->rx_ring.pg_vec || po->tx_ring.pg_vec)\n\t\t\treturn -EBUSY;\n\t\tif (copy_from_user(&val, optval, sizeof(val)))\n\t\t\treturn -EFAULT;\n\t\tpo->tp_reserve = val;\n\t\treturn 0;\n\t}\n\tcase PACKET_LOSS:\n\t{\n\t\tunsigned int val;\n\n\t\tif (optlen != sizeof(val))\n\t\t\treturn -EINVAL;\n\t\tif (po->rx_ring.pg_vec || po->tx_ring.pg_vec)\n\t\t\treturn -EBUSY;\n\t\tif (copy_from_user(&val, optval, sizeof(val)))\n\t\t\treturn -EFAULT;\n\t\tpo->tp_loss = !!val;\n\t\treturn 0;\n\t}\n\tcase PACKET_AUXDATA:\n\t{\n\t\tint val;\n\n\t\tif (optlen < sizeof(val))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&val, optval, sizeof(val)))\n\t\t\treturn -EFAULT;\n\n\t\tpo->auxdata = !!val;\n\t\treturn 0;\n\t}\n\tcase PACKET_ORIGDEV:\n\t{\n\t\tint val;\n\n\t\tif (optlen < sizeof(val))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&val, optval, sizeof(val)))\n\t\t\treturn -EFAULT;\n\n\t\tpo->origdev = !!val;\n\t\treturn 0;\n\t}\n\tcase PACKET_VNET_HDR:\n\t{\n\t\tint val;\n\n\t\tif (sock->type != SOCK_RAW)\n\t\t\treturn -EINVAL;\n\t\tif (po->rx_ring.pg_vec || po->tx_ring.pg_vec)\n\t\t\treturn -EBUSY;\n\t\tif (optlen < sizeof(val))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&val, optval, sizeof(val)))\n\t\t\treturn -EFAULT;\n\n\t\tpo->has_vnet_hdr = !!val;\n\t\treturn 0;\n\t}\n\tcase PACKET_TIMESTAMP:\n\t{\n\t\tint val;\n\n\t\tif (optlen != sizeof(val))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&val, optval, sizeof(val)))\n\t\t\treturn -EFAULT;\n\n\t\tpo->tp_tstamp = val;\n\t\treturn 0;\n\t}\n\tcase PACKET_FANOUT:\n\t{\n\t\tint val;\n\n\t\tif (optlen != sizeof(val))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&val, optval, sizeof(val)))\n\t\t\treturn -EFAULT;\n\n\t\treturn fanout_add(sk, val & 0xffff, val >> 16);\n\t}\n\tcase PACKET_FANOUT_DATA:\n\t{\n\t\tif (!po->fanout)\n\t\t\treturn -EINVAL;\n\n\t\treturn fanout_set_data(po, optval, optlen);\n\t}\n\tcase PACKET_TX_HAS_OFF:\n\t{\n\t\tunsigned int val;\n\n\t\tif (optlen != sizeof(val))\n\t\t\treturn -EINVAL;\n\t\tif (po->rx_ring.pg_vec || po->tx_ring.pg_vec)\n\t\t\treturn -EBUSY;\n\t\tif (copy_from_user(&val, optval, sizeof(val)))\n\t\t\treturn -EFAULT;\n\t\tpo->tp_tx_has_off = !!val;\n\t\treturn 0;\n\t}\n\tcase PACKET_QDISC_BYPASS:\n\t{\n\t\tint val;\n\n\t\tif (optlen != sizeof(val))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&val, optval, sizeof(val)))\n\t\t\treturn -EFAULT;\n\n\t\tpo->xmit = val ? packet_direct_xmit : dev_queue_xmit;\n\t\treturn 0;\n\t}\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n}",
        "patch": "--- code before\n+++ code after\n@@ -71,19 +71,25 @@\n \n \t\tif (optlen != sizeof(val))\n \t\t\treturn -EINVAL;\n-\t\tif (po->rx_ring.pg_vec || po->tx_ring.pg_vec)\n-\t\t\treturn -EBUSY;\n \t\tif (copy_from_user(&val, optval, sizeof(val)))\n \t\t\treturn -EFAULT;\n \t\tswitch (val) {\n \t\tcase TPACKET_V1:\n \t\tcase TPACKET_V2:\n \t\tcase TPACKET_V3:\n+\t\t\tbreak;\n+\t\tdefault:\n+\t\t\treturn -EINVAL;\n+\t\t}\n+\t\tlock_sock(sk);\n+\t\tif (po->rx_ring.pg_vec || po->tx_ring.pg_vec) {\n+\t\t\tret = -EBUSY;\n+\t\t} else {\n \t\t\tpo->tp_version = val;\n-\t\t\treturn 0;\n-\t\tdefault:\n-\t\t\treturn -EINVAL;\n+\t\t\tret = 0;\n \t\t}\n+\t\trelease_sock(sk);\n+\t\treturn ret;\n \t}\n \tcase PACKET_RESERVE:\n \t{",
        "function_modified_lines": {
            "added": [
                "\t\t\tbreak;",
                "\t\tdefault:",
                "\t\t\treturn -EINVAL;",
                "\t\t}",
                "\t\tlock_sock(sk);",
                "\t\tif (po->rx_ring.pg_vec || po->tx_ring.pg_vec) {",
                "\t\t\tret = -EBUSY;",
                "\t\t} else {",
                "\t\t\tret = 0;",
                "\t\trelease_sock(sk);",
                "\t\treturn ret;"
            ],
            "deleted": [
                "\t\tif (po->rx_ring.pg_vec || po->tx_ring.pg_vec)",
                "\t\t\treturn -EBUSY;",
                "\t\t\treturn 0;",
                "\t\tdefault:",
                "\t\t\treturn -EINVAL;"
            ]
        },
        "cwe": [
            "CWE-362",
            "CWE-416"
        ],
        "cve_description": "Race condition in net/packet/af_packet.c in the Linux kernel through 4.8.12 allows local users to gain privileges or cause a denial of service (use-after-free) by leveraging the CAP_NET_RAW capability to change a socket version, related to the packet_set_ring and packet_setsockopt functions.",
        "id": 1132
    },
    {
        "cve_id": "CVE-2021-39686",
        "code_before_change": "static void binder_transaction(struct binder_proc *proc,\n\t\t\t       struct binder_thread *thread,\n\t\t\t       struct binder_transaction_data *tr, int reply,\n\t\t\t       binder_size_t extra_buffers_size)\n{\n\tint ret;\n\tstruct binder_transaction *t;\n\tstruct binder_work *w;\n\tstruct binder_work *tcomplete;\n\tbinder_size_t buffer_offset = 0;\n\tbinder_size_t off_start_offset, off_end_offset;\n\tbinder_size_t off_min;\n\tbinder_size_t sg_buf_offset, sg_buf_end_offset;\n\tstruct binder_proc *target_proc = NULL;\n\tstruct binder_thread *target_thread = NULL;\n\tstruct binder_node *target_node = NULL;\n\tstruct binder_transaction *in_reply_to = NULL;\n\tstruct binder_transaction_log_entry *e;\n\tuint32_t return_error = 0;\n\tuint32_t return_error_param = 0;\n\tuint32_t return_error_line = 0;\n\tbinder_size_t last_fixup_obj_off = 0;\n\tbinder_size_t last_fixup_min_off = 0;\n\tstruct binder_context *context = proc->context;\n\tint t_debug_id = atomic_inc_return(&binder_last_id);\n\tchar *secctx = NULL;\n\tu32 secctx_sz = 0;\n\n\te = binder_transaction_log_add(&binder_transaction_log);\n\te->debug_id = t_debug_id;\n\te->call_type = reply ? 2 : !!(tr->flags & TF_ONE_WAY);\n\te->from_proc = proc->pid;\n\te->from_thread = thread->pid;\n\te->target_handle = tr->target.handle;\n\te->data_size = tr->data_size;\n\te->offsets_size = tr->offsets_size;\n\tstrscpy(e->context_name, proc->context->name, BINDERFS_MAX_NAME);\n\n\tif (reply) {\n\t\tbinder_inner_proc_lock(proc);\n\t\tin_reply_to = thread->transaction_stack;\n\t\tif (in_reply_to == NULL) {\n\t\t\tbinder_inner_proc_unlock(proc);\n\t\t\tbinder_user_error(\"%d:%d got reply transaction with no transaction stack\\n\",\n\t\t\t\t\t  proc->pid, thread->pid);\n\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\treturn_error_param = -EPROTO;\n\t\t\treturn_error_line = __LINE__;\n\t\t\tgoto err_empty_call_stack;\n\t\t}\n\t\tif (in_reply_to->to_thread != thread) {\n\t\t\tspin_lock(&in_reply_to->lock);\n\t\t\tbinder_user_error(\"%d:%d got reply transaction with bad transaction stack, transaction %d has target %d:%d\\n\",\n\t\t\t\tproc->pid, thread->pid, in_reply_to->debug_id,\n\t\t\t\tin_reply_to->to_proc ?\n\t\t\t\tin_reply_to->to_proc->pid : 0,\n\t\t\t\tin_reply_to->to_thread ?\n\t\t\t\tin_reply_to->to_thread->pid : 0);\n\t\t\tspin_unlock(&in_reply_to->lock);\n\t\t\tbinder_inner_proc_unlock(proc);\n\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\treturn_error_param = -EPROTO;\n\t\t\treturn_error_line = __LINE__;\n\t\t\tin_reply_to = NULL;\n\t\t\tgoto err_bad_call_stack;\n\t\t}\n\t\tthread->transaction_stack = in_reply_to->to_parent;\n\t\tbinder_inner_proc_unlock(proc);\n\t\tbinder_set_nice(in_reply_to->saved_priority);\n\t\ttarget_thread = binder_get_txn_from_and_acq_inner(in_reply_to);\n\t\tif (target_thread == NULL) {\n\t\t\t/* annotation for sparse */\n\t\t\t__release(&target_thread->proc->inner_lock);\n\t\t\treturn_error = BR_DEAD_REPLY;\n\t\t\treturn_error_line = __LINE__;\n\t\t\tgoto err_dead_binder;\n\t\t}\n\t\tif (target_thread->transaction_stack != in_reply_to) {\n\t\t\tbinder_user_error(\"%d:%d got reply transaction with bad target transaction stack %d, expected %d\\n\",\n\t\t\t\tproc->pid, thread->pid,\n\t\t\t\ttarget_thread->transaction_stack ?\n\t\t\t\ttarget_thread->transaction_stack->debug_id : 0,\n\t\t\t\tin_reply_to->debug_id);\n\t\t\tbinder_inner_proc_unlock(target_thread->proc);\n\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\treturn_error_param = -EPROTO;\n\t\t\treturn_error_line = __LINE__;\n\t\t\tin_reply_to = NULL;\n\t\t\ttarget_thread = NULL;\n\t\t\tgoto err_dead_binder;\n\t\t}\n\t\ttarget_proc = target_thread->proc;\n\t\ttarget_proc->tmp_ref++;\n\t\tbinder_inner_proc_unlock(target_thread->proc);\n\t} else {\n\t\tif (tr->target.handle) {\n\t\t\tstruct binder_ref *ref;\n\n\t\t\t/*\n\t\t\t * There must already be a strong ref\n\t\t\t * on this node. If so, do a strong\n\t\t\t * increment on the node to ensure it\n\t\t\t * stays alive until the transaction is\n\t\t\t * done.\n\t\t\t */\n\t\t\tbinder_proc_lock(proc);\n\t\t\tref = binder_get_ref_olocked(proc, tr->target.handle,\n\t\t\t\t\t\t     true);\n\t\t\tif (ref) {\n\t\t\t\ttarget_node = binder_get_node_refs_for_txn(\n\t\t\t\t\t\tref->node, &target_proc,\n\t\t\t\t\t\t&return_error);\n\t\t\t} else {\n\t\t\t\tbinder_user_error(\"%d:%d got transaction to invalid handle, %u\\n\",\n\t\t\t\t\t\t  proc->pid, thread->pid, tr->target.handle);\n\t\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\t}\n\t\t\tbinder_proc_unlock(proc);\n\t\t} else {\n\t\t\tmutex_lock(&context->context_mgr_node_lock);\n\t\t\ttarget_node = context->binder_context_mgr_node;\n\t\t\tif (target_node)\n\t\t\t\ttarget_node = binder_get_node_refs_for_txn(\n\t\t\t\t\t\ttarget_node, &target_proc,\n\t\t\t\t\t\t&return_error);\n\t\t\telse\n\t\t\t\treturn_error = BR_DEAD_REPLY;\n\t\t\tmutex_unlock(&context->context_mgr_node_lock);\n\t\t\tif (target_node && target_proc->pid == proc->pid) {\n\t\t\t\tbinder_user_error(\"%d:%d got transaction to context manager from process owning it\\n\",\n\t\t\t\t\t\t  proc->pid, thread->pid);\n\t\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\t\treturn_error_param = -EINVAL;\n\t\t\t\treturn_error_line = __LINE__;\n\t\t\t\tgoto err_invalid_target_handle;\n\t\t\t}\n\t\t}\n\t\tif (!target_node) {\n\t\t\t/*\n\t\t\t * return_error is set above\n\t\t\t */\n\t\t\treturn_error_param = -EINVAL;\n\t\t\treturn_error_line = __LINE__;\n\t\t\tgoto err_dead_binder;\n\t\t}\n\t\te->to_node = target_node->debug_id;\n\t\tif (WARN_ON(proc == target_proc)) {\n\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\treturn_error_param = -EINVAL;\n\t\t\treturn_error_line = __LINE__;\n\t\t\tgoto err_invalid_target_handle;\n\t\t}\n\t\tif (security_binder_transaction(proc->tsk,\n\t\t\t\t\t\ttarget_proc->tsk) < 0) {\n\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\treturn_error_param = -EPERM;\n\t\t\treturn_error_line = __LINE__;\n\t\t\tgoto err_invalid_target_handle;\n\t\t}\n\t\tbinder_inner_proc_lock(proc);\n\n\t\tw = list_first_entry_or_null(&thread->todo,\n\t\t\t\t\t     struct binder_work, entry);\n\t\tif (!(tr->flags & TF_ONE_WAY) && w &&\n\t\t    w->type == BINDER_WORK_TRANSACTION) {\n\t\t\t/*\n\t\t\t * Do not allow new outgoing transaction from a\n\t\t\t * thread that has a transaction at the head of\n\t\t\t * its todo list. Only need to check the head\n\t\t\t * because binder_select_thread_ilocked picks a\n\t\t\t * thread from proc->waiting_threads to enqueue\n\t\t\t * the transaction, and nothing is queued to the\n\t\t\t * todo list while the thread is on waiting_threads.\n\t\t\t */\n\t\t\tbinder_user_error(\"%d:%d new transaction not allowed when there is a transaction on thread todo\\n\",\n\t\t\t\t\t  proc->pid, thread->pid);\n\t\t\tbinder_inner_proc_unlock(proc);\n\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\treturn_error_param = -EPROTO;\n\t\t\treturn_error_line = __LINE__;\n\t\t\tgoto err_bad_todo_list;\n\t\t}\n\n\t\tif (!(tr->flags & TF_ONE_WAY) && thread->transaction_stack) {\n\t\t\tstruct binder_transaction *tmp;\n\n\t\t\ttmp = thread->transaction_stack;\n\t\t\tif (tmp->to_thread != thread) {\n\t\t\t\tspin_lock(&tmp->lock);\n\t\t\t\tbinder_user_error(\"%d:%d got new transaction with bad transaction stack, transaction %d has target %d:%d\\n\",\n\t\t\t\t\tproc->pid, thread->pid, tmp->debug_id,\n\t\t\t\t\ttmp->to_proc ? tmp->to_proc->pid : 0,\n\t\t\t\t\ttmp->to_thread ?\n\t\t\t\t\ttmp->to_thread->pid : 0);\n\t\t\t\tspin_unlock(&tmp->lock);\n\t\t\t\tbinder_inner_proc_unlock(proc);\n\t\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\t\treturn_error_param = -EPROTO;\n\t\t\t\treturn_error_line = __LINE__;\n\t\t\t\tgoto err_bad_call_stack;\n\t\t\t}\n\t\t\twhile (tmp) {\n\t\t\t\tstruct binder_thread *from;\n\n\t\t\t\tspin_lock(&tmp->lock);\n\t\t\t\tfrom = tmp->from;\n\t\t\t\tif (from && from->proc == target_proc) {\n\t\t\t\t\tatomic_inc(&from->tmp_ref);\n\t\t\t\t\ttarget_thread = from;\n\t\t\t\t\tspin_unlock(&tmp->lock);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tspin_unlock(&tmp->lock);\n\t\t\t\ttmp = tmp->from_parent;\n\t\t\t}\n\t\t}\n\t\tbinder_inner_proc_unlock(proc);\n\t}\n\tif (target_thread)\n\t\te->to_thread = target_thread->pid;\n\te->to_proc = target_proc->pid;\n\n\t/* TODO: reuse incoming transaction for reply */\n\tt = kzalloc(sizeof(*t), GFP_KERNEL);\n\tif (t == NULL) {\n\t\treturn_error = BR_FAILED_REPLY;\n\t\treturn_error_param = -ENOMEM;\n\t\treturn_error_line = __LINE__;\n\t\tgoto err_alloc_t_failed;\n\t}\n\tINIT_LIST_HEAD(&t->fd_fixups);\n\tbinder_stats_created(BINDER_STAT_TRANSACTION);\n\tspin_lock_init(&t->lock);\n\n\ttcomplete = kzalloc(sizeof(*tcomplete), GFP_KERNEL);\n\tif (tcomplete == NULL) {\n\t\treturn_error = BR_FAILED_REPLY;\n\t\treturn_error_param = -ENOMEM;\n\t\treturn_error_line = __LINE__;\n\t\tgoto err_alloc_tcomplete_failed;\n\t}\n\tbinder_stats_created(BINDER_STAT_TRANSACTION_COMPLETE);\n\n\tt->debug_id = t_debug_id;\n\n\tif (reply)\n\t\tbinder_debug(BINDER_DEBUG_TRANSACTION,\n\t\t\t     \"%d:%d BC_REPLY %d -> %d:%d, data %016llx-%016llx size %lld-%lld-%lld\\n\",\n\t\t\t     proc->pid, thread->pid, t->debug_id,\n\t\t\t     target_proc->pid, target_thread->pid,\n\t\t\t     (u64)tr->data.ptr.buffer,\n\t\t\t     (u64)tr->data.ptr.offsets,\n\t\t\t     (u64)tr->data_size, (u64)tr->offsets_size,\n\t\t\t     (u64)extra_buffers_size);\n\telse\n\t\tbinder_debug(BINDER_DEBUG_TRANSACTION,\n\t\t\t     \"%d:%d BC_TRANSACTION %d -> %d - node %d, data %016llx-%016llx size %lld-%lld-%lld\\n\",\n\t\t\t     proc->pid, thread->pid, t->debug_id,\n\t\t\t     target_proc->pid, target_node->debug_id,\n\t\t\t     (u64)tr->data.ptr.buffer,\n\t\t\t     (u64)tr->data.ptr.offsets,\n\t\t\t     (u64)tr->data_size, (u64)tr->offsets_size,\n\t\t\t     (u64)extra_buffers_size);\n\n\tif (!reply && !(tr->flags & TF_ONE_WAY))\n\t\tt->from = thread;\n\telse\n\t\tt->from = NULL;\n\tt->sender_euid = task_euid(proc->tsk);\n\tt->to_proc = target_proc;\n\tt->to_thread = target_thread;\n\tt->code = tr->code;\n\tt->flags = tr->flags;\n\tt->priority = task_nice(current);\n\n\tif (target_node && target_node->txn_security_ctx) {\n\t\tu32 secid;\n\t\tsize_t added_size;\n\n\t\t/*\n\t\t * Arguably this should be the task's subjective LSM secid but\n\t\t * we can't reliably access the subjective creds of a task\n\t\t * other than our own so we must use the objective creds, which\n\t\t * are safe to access.  The downside is that if a task is\n\t\t * temporarily overriding it's creds it will not be reflected\n\t\t * here; however, it isn't clear that binder would handle that\n\t\t * case well anyway.\n\t\t */\n\t\tsecurity_task_getsecid_obj(proc->tsk, &secid);\n\t\tret = security_secid_to_secctx(secid, &secctx, &secctx_sz);\n\t\tif (ret) {\n\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\treturn_error_param = ret;\n\t\t\treturn_error_line = __LINE__;\n\t\t\tgoto err_get_secctx_failed;\n\t\t}\n\t\tadded_size = ALIGN(secctx_sz, sizeof(u64));\n\t\textra_buffers_size += added_size;\n\t\tif (extra_buffers_size < added_size) {\n\t\t\t/* integer overflow of extra_buffers_size */\n\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\treturn_error_param = -EINVAL;\n\t\t\treturn_error_line = __LINE__;\n\t\t\tgoto err_bad_extra_size;\n\t\t}\n\t}\n\n\ttrace_binder_transaction(reply, t, target_node);\n\n\tt->buffer = binder_alloc_new_buf(&target_proc->alloc, tr->data_size,\n\t\ttr->offsets_size, extra_buffers_size,\n\t\t!reply && (t->flags & TF_ONE_WAY), current->tgid);\n\tif (IS_ERR(t->buffer)) {\n\t\t/*\n\t\t * -ESRCH indicates VMA cleared. The target is dying.\n\t\t */\n\t\treturn_error_param = PTR_ERR(t->buffer);\n\t\treturn_error = return_error_param == -ESRCH ?\n\t\t\tBR_DEAD_REPLY : BR_FAILED_REPLY;\n\t\treturn_error_line = __LINE__;\n\t\tt->buffer = NULL;\n\t\tgoto err_binder_alloc_buf_failed;\n\t}\n\tif (secctx) {\n\t\tint err;\n\t\tsize_t buf_offset = ALIGN(tr->data_size, sizeof(void *)) +\n\t\t\t\t    ALIGN(tr->offsets_size, sizeof(void *)) +\n\t\t\t\t    ALIGN(extra_buffers_size, sizeof(void *)) -\n\t\t\t\t    ALIGN(secctx_sz, sizeof(u64));\n\n\t\tt->security_ctx = (uintptr_t)t->buffer->user_data + buf_offset;\n\t\terr = binder_alloc_copy_to_buffer(&target_proc->alloc,\n\t\t\t\t\t\t  t->buffer, buf_offset,\n\t\t\t\t\t\t  secctx, secctx_sz);\n\t\tif (err) {\n\t\t\tt->security_ctx = 0;\n\t\t\tWARN_ON(1);\n\t\t}\n\t\tsecurity_release_secctx(secctx, secctx_sz);\n\t\tsecctx = NULL;\n\t}\n\tt->buffer->debug_id = t->debug_id;\n\tt->buffer->transaction = t;\n\tt->buffer->target_node = target_node;\n\tt->buffer->clear_on_free = !!(t->flags & TF_CLEAR_BUF);\n\ttrace_binder_transaction_alloc_buf(t->buffer);\n\n\tif (binder_alloc_copy_user_to_buffer(\n\t\t\t\t&target_proc->alloc,\n\t\t\t\tt->buffer, 0,\n\t\t\t\t(const void __user *)\n\t\t\t\t\t(uintptr_t)tr->data.ptr.buffer,\n\t\t\t\ttr->data_size)) {\n\t\tbinder_user_error(\"%d:%d got transaction with invalid data ptr\\n\",\n\t\t\t\tproc->pid, thread->pid);\n\t\treturn_error = BR_FAILED_REPLY;\n\t\treturn_error_param = -EFAULT;\n\t\treturn_error_line = __LINE__;\n\t\tgoto err_copy_data_failed;\n\t}\n\tif (binder_alloc_copy_user_to_buffer(\n\t\t\t\t&target_proc->alloc,\n\t\t\t\tt->buffer,\n\t\t\t\tALIGN(tr->data_size, sizeof(void *)),\n\t\t\t\t(const void __user *)\n\t\t\t\t\t(uintptr_t)tr->data.ptr.offsets,\n\t\t\t\ttr->offsets_size)) {\n\t\tbinder_user_error(\"%d:%d got transaction with invalid offsets ptr\\n\",\n\t\t\t\tproc->pid, thread->pid);\n\t\treturn_error = BR_FAILED_REPLY;\n\t\treturn_error_param = -EFAULT;\n\t\treturn_error_line = __LINE__;\n\t\tgoto err_copy_data_failed;\n\t}\n\tif (!IS_ALIGNED(tr->offsets_size, sizeof(binder_size_t))) {\n\t\tbinder_user_error(\"%d:%d got transaction with invalid offsets size, %lld\\n\",\n\t\t\t\tproc->pid, thread->pid, (u64)tr->offsets_size);\n\t\treturn_error = BR_FAILED_REPLY;\n\t\treturn_error_param = -EINVAL;\n\t\treturn_error_line = __LINE__;\n\t\tgoto err_bad_offset;\n\t}\n\tif (!IS_ALIGNED(extra_buffers_size, sizeof(u64))) {\n\t\tbinder_user_error(\"%d:%d got transaction with unaligned buffers size, %lld\\n\",\n\t\t\t\t  proc->pid, thread->pid,\n\t\t\t\t  (u64)extra_buffers_size);\n\t\treturn_error = BR_FAILED_REPLY;\n\t\treturn_error_param = -EINVAL;\n\t\treturn_error_line = __LINE__;\n\t\tgoto err_bad_offset;\n\t}\n\toff_start_offset = ALIGN(tr->data_size, sizeof(void *));\n\tbuffer_offset = off_start_offset;\n\toff_end_offset = off_start_offset + tr->offsets_size;\n\tsg_buf_offset = ALIGN(off_end_offset, sizeof(void *));\n\tsg_buf_end_offset = sg_buf_offset + extra_buffers_size -\n\t\tALIGN(secctx_sz, sizeof(u64));\n\toff_min = 0;\n\tfor (buffer_offset = off_start_offset; buffer_offset < off_end_offset;\n\t     buffer_offset += sizeof(binder_size_t)) {\n\t\tstruct binder_object_header *hdr;\n\t\tsize_t object_size;\n\t\tstruct binder_object object;\n\t\tbinder_size_t object_offset;\n\n\t\tif (binder_alloc_copy_from_buffer(&target_proc->alloc,\n\t\t\t\t\t\t  &object_offset,\n\t\t\t\t\t\t  t->buffer,\n\t\t\t\t\t\t  buffer_offset,\n\t\t\t\t\t\t  sizeof(object_offset))) {\n\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\treturn_error_param = -EINVAL;\n\t\t\treturn_error_line = __LINE__;\n\t\t\tgoto err_bad_offset;\n\t\t}\n\t\tobject_size = binder_get_object(target_proc, t->buffer,\n\t\t\t\t\t\tobject_offset, &object);\n\t\tif (object_size == 0 || object_offset < off_min) {\n\t\t\tbinder_user_error(\"%d:%d got transaction with invalid offset (%lld, min %lld max %lld) or object.\\n\",\n\t\t\t\t\t  proc->pid, thread->pid,\n\t\t\t\t\t  (u64)object_offset,\n\t\t\t\t\t  (u64)off_min,\n\t\t\t\t\t  (u64)t->buffer->data_size);\n\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\treturn_error_param = -EINVAL;\n\t\t\treturn_error_line = __LINE__;\n\t\t\tgoto err_bad_offset;\n\t\t}\n\n\t\thdr = &object.hdr;\n\t\toff_min = object_offset + object_size;\n\t\tswitch (hdr->type) {\n\t\tcase BINDER_TYPE_BINDER:\n\t\tcase BINDER_TYPE_WEAK_BINDER: {\n\t\t\tstruct flat_binder_object *fp;\n\n\t\t\tfp = to_flat_binder_object(hdr);\n\t\t\tret = binder_translate_binder(fp, t, thread);\n\n\t\t\tif (ret < 0 ||\n\t\t\t    binder_alloc_copy_to_buffer(&target_proc->alloc,\n\t\t\t\t\t\t\tt->buffer,\n\t\t\t\t\t\t\tobject_offset,\n\t\t\t\t\t\t\tfp, sizeof(*fp))) {\n\t\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\t\treturn_error_param = ret;\n\t\t\t\treturn_error_line = __LINE__;\n\t\t\t\tgoto err_translate_failed;\n\t\t\t}\n\t\t} break;\n\t\tcase BINDER_TYPE_HANDLE:\n\t\tcase BINDER_TYPE_WEAK_HANDLE: {\n\t\t\tstruct flat_binder_object *fp;\n\n\t\t\tfp = to_flat_binder_object(hdr);\n\t\t\tret = binder_translate_handle(fp, t, thread);\n\t\t\tif (ret < 0 ||\n\t\t\t    binder_alloc_copy_to_buffer(&target_proc->alloc,\n\t\t\t\t\t\t\tt->buffer,\n\t\t\t\t\t\t\tobject_offset,\n\t\t\t\t\t\t\tfp, sizeof(*fp))) {\n\t\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\t\treturn_error_param = ret;\n\t\t\t\treturn_error_line = __LINE__;\n\t\t\t\tgoto err_translate_failed;\n\t\t\t}\n\t\t} break;\n\n\t\tcase BINDER_TYPE_FD: {\n\t\t\tstruct binder_fd_object *fp = to_binder_fd_object(hdr);\n\t\t\tbinder_size_t fd_offset = object_offset +\n\t\t\t\t(uintptr_t)&fp->fd - (uintptr_t)fp;\n\t\t\tint ret = binder_translate_fd(fp->fd, fd_offset, t,\n\t\t\t\t\t\t      thread, in_reply_to);\n\n\t\t\tfp->pad_binder = 0;\n\t\t\tif (ret < 0 ||\n\t\t\t    binder_alloc_copy_to_buffer(&target_proc->alloc,\n\t\t\t\t\t\t\tt->buffer,\n\t\t\t\t\t\t\tobject_offset,\n\t\t\t\t\t\t\tfp, sizeof(*fp))) {\n\t\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\t\treturn_error_param = ret;\n\t\t\t\treturn_error_line = __LINE__;\n\t\t\t\tgoto err_translate_failed;\n\t\t\t}\n\t\t} break;\n\t\tcase BINDER_TYPE_FDA: {\n\t\t\tstruct binder_object ptr_object;\n\t\t\tbinder_size_t parent_offset;\n\t\t\tstruct binder_fd_array_object *fda =\n\t\t\t\tto_binder_fd_array_object(hdr);\n\t\t\tsize_t num_valid = (buffer_offset - off_start_offset) /\n\t\t\t\t\t\tsizeof(binder_size_t);\n\t\t\tstruct binder_buffer_object *parent =\n\t\t\t\tbinder_validate_ptr(target_proc, t->buffer,\n\t\t\t\t\t\t    &ptr_object, fda->parent,\n\t\t\t\t\t\t    off_start_offset,\n\t\t\t\t\t\t    &parent_offset,\n\t\t\t\t\t\t    num_valid);\n\t\t\tif (!parent) {\n\t\t\t\tbinder_user_error(\"%d:%d got transaction with invalid parent offset or type\\n\",\n\t\t\t\t\t\t  proc->pid, thread->pid);\n\t\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\t\treturn_error_param = -EINVAL;\n\t\t\t\treturn_error_line = __LINE__;\n\t\t\t\tgoto err_bad_parent;\n\t\t\t}\n\t\t\tif (!binder_validate_fixup(target_proc, t->buffer,\n\t\t\t\t\t\t   off_start_offset,\n\t\t\t\t\t\t   parent_offset,\n\t\t\t\t\t\t   fda->parent_offset,\n\t\t\t\t\t\t   last_fixup_obj_off,\n\t\t\t\t\t\t   last_fixup_min_off)) {\n\t\t\t\tbinder_user_error(\"%d:%d got transaction with out-of-order buffer fixup\\n\",\n\t\t\t\t\t\t  proc->pid, thread->pid);\n\t\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\t\treturn_error_param = -EINVAL;\n\t\t\t\treturn_error_line = __LINE__;\n\t\t\t\tgoto err_bad_parent;\n\t\t\t}\n\t\t\tret = binder_translate_fd_array(fda, parent, t, thread,\n\t\t\t\t\t\t\tin_reply_to);\n\t\t\tif (ret < 0) {\n\t\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\t\treturn_error_param = ret;\n\t\t\t\treturn_error_line = __LINE__;\n\t\t\t\tgoto err_translate_failed;\n\t\t\t}\n\t\t\tlast_fixup_obj_off = parent_offset;\n\t\t\tlast_fixup_min_off =\n\t\t\t\tfda->parent_offset + sizeof(u32) * fda->num_fds;\n\t\t} break;\n\t\tcase BINDER_TYPE_PTR: {\n\t\t\tstruct binder_buffer_object *bp =\n\t\t\t\tto_binder_buffer_object(hdr);\n\t\t\tsize_t buf_left = sg_buf_end_offset - sg_buf_offset;\n\t\t\tsize_t num_valid;\n\n\t\t\tif (bp->length > buf_left) {\n\t\t\t\tbinder_user_error(\"%d:%d got transaction with too large buffer\\n\",\n\t\t\t\t\t\t  proc->pid, thread->pid);\n\t\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\t\treturn_error_param = -EINVAL;\n\t\t\t\treturn_error_line = __LINE__;\n\t\t\t\tgoto err_bad_offset;\n\t\t\t}\n\t\t\tif (binder_alloc_copy_user_to_buffer(\n\t\t\t\t\t\t&target_proc->alloc,\n\t\t\t\t\t\tt->buffer,\n\t\t\t\t\t\tsg_buf_offset,\n\t\t\t\t\t\t(const void __user *)\n\t\t\t\t\t\t\t(uintptr_t)bp->buffer,\n\t\t\t\t\t\tbp->length)) {\n\t\t\t\tbinder_user_error(\"%d:%d got transaction with invalid offsets ptr\\n\",\n\t\t\t\t\t\t  proc->pid, thread->pid);\n\t\t\t\treturn_error_param = -EFAULT;\n\t\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\t\treturn_error_line = __LINE__;\n\t\t\t\tgoto err_copy_data_failed;\n\t\t\t}\n\t\t\t/* Fixup buffer pointer to target proc address space */\n\t\t\tbp->buffer = (uintptr_t)\n\t\t\t\tt->buffer->user_data + sg_buf_offset;\n\t\t\tsg_buf_offset += ALIGN(bp->length, sizeof(u64));\n\n\t\t\tnum_valid = (buffer_offset - off_start_offset) /\n\t\t\t\t\tsizeof(binder_size_t);\n\t\t\tret = binder_fixup_parent(t, thread, bp,\n\t\t\t\t\t\t  off_start_offset,\n\t\t\t\t\t\t  num_valid,\n\t\t\t\t\t\t  last_fixup_obj_off,\n\t\t\t\t\t\t  last_fixup_min_off);\n\t\t\tif (ret < 0 ||\n\t\t\t    binder_alloc_copy_to_buffer(&target_proc->alloc,\n\t\t\t\t\t\t\tt->buffer,\n\t\t\t\t\t\t\tobject_offset,\n\t\t\t\t\t\t\tbp, sizeof(*bp))) {\n\t\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\t\treturn_error_param = ret;\n\t\t\t\treturn_error_line = __LINE__;\n\t\t\t\tgoto err_translate_failed;\n\t\t\t}\n\t\t\tlast_fixup_obj_off = object_offset;\n\t\t\tlast_fixup_min_off = 0;\n\t\t} break;\n\t\tdefault:\n\t\t\tbinder_user_error(\"%d:%d got transaction with invalid object type, %x\\n\",\n\t\t\t\tproc->pid, thread->pid, hdr->type);\n\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\treturn_error_param = -EINVAL;\n\t\t\treturn_error_line = __LINE__;\n\t\t\tgoto err_bad_object_type;\n\t\t}\n\t}\n\tif (t->buffer->oneway_spam_suspect)\n\t\ttcomplete->type = BINDER_WORK_TRANSACTION_ONEWAY_SPAM_SUSPECT;\n\telse\n\t\ttcomplete->type = BINDER_WORK_TRANSACTION_COMPLETE;\n\tt->work.type = BINDER_WORK_TRANSACTION;\n\n\tif (reply) {\n\t\tbinder_enqueue_thread_work(thread, tcomplete);\n\t\tbinder_inner_proc_lock(target_proc);\n\t\tif (target_thread->is_dead || target_proc->is_frozen) {\n\t\t\treturn_error = target_thread->is_dead ?\n\t\t\t\tBR_DEAD_REPLY : BR_FROZEN_REPLY;\n\t\t\tbinder_inner_proc_unlock(target_proc);\n\t\t\tgoto err_dead_proc_or_thread;\n\t\t}\n\t\tBUG_ON(t->buffer->async_transaction != 0);\n\t\tbinder_pop_transaction_ilocked(target_thread, in_reply_to);\n\t\tbinder_enqueue_thread_work_ilocked(target_thread, &t->work);\n\t\ttarget_proc->outstanding_txns++;\n\t\tbinder_inner_proc_unlock(target_proc);\n\t\twake_up_interruptible_sync(&target_thread->wait);\n\t\tbinder_free_transaction(in_reply_to);\n\t} else if (!(t->flags & TF_ONE_WAY)) {\n\t\tBUG_ON(t->buffer->async_transaction != 0);\n\t\tbinder_inner_proc_lock(proc);\n\t\t/*\n\t\t * Defer the TRANSACTION_COMPLETE, so we don't return to\n\t\t * userspace immediately; this allows the target process to\n\t\t * immediately start processing this transaction, reducing\n\t\t * latency. We will then return the TRANSACTION_COMPLETE when\n\t\t * the target replies (or there is an error).\n\t\t */\n\t\tbinder_enqueue_deferred_thread_work_ilocked(thread, tcomplete);\n\t\tt->need_reply = 1;\n\t\tt->from_parent = thread->transaction_stack;\n\t\tthread->transaction_stack = t;\n\t\tbinder_inner_proc_unlock(proc);\n\t\treturn_error = binder_proc_transaction(t,\n\t\t\t\ttarget_proc, target_thread);\n\t\tif (return_error) {\n\t\t\tbinder_inner_proc_lock(proc);\n\t\t\tbinder_pop_transaction_ilocked(thread, t);\n\t\t\tbinder_inner_proc_unlock(proc);\n\t\t\tgoto err_dead_proc_or_thread;\n\t\t}\n\t} else {\n\t\tBUG_ON(target_node == NULL);\n\t\tBUG_ON(t->buffer->async_transaction != 1);\n\t\tbinder_enqueue_thread_work(thread, tcomplete);\n\t\treturn_error = binder_proc_transaction(t, target_proc, NULL);\n\t\tif (return_error)\n\t\t\tgoto err_dead_proc_or_thread;\n\t}\n\tif (target_thread)\n\t\tbinder_thread_dec_tmpref(target_thread);\n\tbinder_proc_dec_tmpref(target_proc);\n\tif (target_node)\n\t\tbinder_dec_node_tmpref(target_node);\n\t/*\n\t * write barrier to synchronize with initialization\n\t * of log entry\n\t */\n\tsmp_wmb();\n\tWRITE_ONCE(e->debug_id_done, t_debug_id);\n\treturn;\n\nerr_dead_proc_or_thread:\n\treturn_error_line = __LINE__;\n\tbinder_dequeue_work(proc, tcomplete);\nerr_translate_failed:\nerr_bad_object_type:\nerr_bad_offset:\nerr_bad_parent:\nerr_copy_data_failed:\n\tbinder_free_txn_fixups(t);\n\ttrace_binder_transaction_failed_buffer_release(t->buffer);\n\tbinder_transaction_buffer_release(target_proc, t->buffer,\n\t\t\t\t\t  buffer_offset, true);\n\tif (target_node)\n\t\tbinder_dec_node_tmpref(target_node);\n\ttarget_node = NULL;\n\tt->buffer->transaction = NULL;\n\tbinder_alloc_free_buf(&target_proc->alloc, t->buffer);\nerr_binder_alloc_buf_failed:\nerr_bad_extra_size:\n\tif (secctx)\n\t\tsecurity_release_secctx(secctx, secctx_sz);\nerr_get_secctx_failed:\n\tkfree(tcomplete);\n\tbinder_stats_deleted(BINDER_STAT_TRANSACTION_COMPLETE);\nerr_alloc_tcomplete_failed:\n\tif (trace_binder_txn_latency_free_enabled())\n\t\tbinder_txn_latency_free(t);\n\tkfree(t);\n\tbinder_stats_deleted(BINDER_STAT_TRANSACTION);\nerr_alloc_t_failed:\nerr_bad_todo_list:\nerr_bad_call_stack:\nerr_empty_call_stack:\nerr_dead_binder:\nerr_invalid_target_handle:\n\tif (target_thread)\n\t\tbinder_thread_dec_tmpref(target_thread);\n\tif (target_proc)\n\t\tbinder_proc_dec_tmpref(target_proc);\n\tif (target_node) {\n\t\tbinder_dec_node(target_node, 1, 0);\n\t\tbinder_dec_node_tmpref(target_node);\n\t}\n\n\tbinder_debug(BINDER_DEBUG_FAILED_TRANSACTION,\n\t\t     \"%d:%d transaction failed %d/%d, size %lld-%lld line %d\\n\",\n\t\t     proc->pid, thread->pid, return_error, return_error_param,\n\t\t     (u64)tr->data_size, (u64)tr->offsets_size,\n\t\t     return_error_line);\n\n\t{\n\t\tstruct binder_transaction_log_entry *fe;\n\n\t\te->return_error = return_error;\n\t\te->return_error_param = return_error_param;\n\t\te->return_error_line = return_error_line;\n\t\tfe = binder_transaction_log_add(&binder_transaction_log_failed);\n\t\t*fe = *e;\n\t\t/*\n\t\t * write barrier to synchronize with initialization\n\t\t * of log entry\n\t\t */\n\t\tsmp_wmb();\n\t\tWRITE_ONCE(e->debug_id_done, t_debug_id);\n\t\tWRITE_ONCE(fe->debug_id_done, t_debug_id);\n\t}\n\n\tBUG_ON(thread->return_error.cmd != BR_OK);\n\tif (in_reply_to) {\n\t\tthread->return_error.cmd = BR_TRANSACTION_COMPLETE;\n\t\tbinder_enqueue_thread_work(thread, &thread->return_error.work);\n\t\tbinder_send_failed_reply(in_reply_to, return_error);\n\t} else {\n\t\tthread->return_error.cmd = return_error;\n\t\tbinder_enqueue_thread_work(thread, &thread->return_error.work);\n\t}\n}",
        "code_after_change": "static void binder_transaction(struct binder_proc *proc,\n\t\t\t       struct binder_thread *thread,\n\t\t\t       struct binder_transaction_data *tr, int reply,\n\t\t\t       binder_size_t extra_buffers_size)\n{\n\tint ret;\n\tstruct binder_transaction *t;\n\tstruct binder_work *w;\n\tstruct binder_work *tcomplete;\n\tbinder_size_t buffer_offset = 0;\n\tbinder_size_t off_start_offset, off_end_offset;\n\tbinder_size_t off_min;\n\tbinder_size_t sg_buf_offset, sg_buf_end_offset;\n\tstruct binder_proc *target_proc = NULL;\n\tstruct binder_thread *target_thread = NULL;\n\tstruct binder_node *target_node = NULL;\n\tstruct binder_transaction *in_reply_to = NULL;\n\tstruct binder_transaction_log_entry *e;\n\tuint32_t return_error = 0;\n\tuint32_t return_error_param = 0;\n\tuint32_t return_error_line = 0;\n\tbinder_size_t last_fixup_obj_off = 0;\n\tbinder_size_t last_fixup_min_off = 0;\n\tstruct binder_context *context = proc->context;\n\tint t_debug_id = atomic_inc_return(&binder_last_id);\n\tchar *secctx = NULL;\n\tu32 secctx_sz = 0;\n\n\te = binder_transaction_log_add(&binder_transaction_log);\n\te->debug_id = t_debug_id;\n\te->call_type = reply ? 2 : !!(tr->flags & TF_ONE_WAY);\n\te->from_proc = proc->pid;\n\te->from_thread = thread->pid;\n\te->target_handle = tr->target.handle;\n\te->data_size = tr->data_size;\n\te->offsets_size = tr->offsets_size;\n\tstrscpy(e->context_name, proc->context->name, BINDERFS_MAX_NAME);\n\n\tif (reply) {\n\t\tbinder_inner_proc_lock(proc);\n\t\tin_reply_to = thread->transaction_stack;\n\t\tif (in_reply_to == NULL) {\n\t\t\tbinder_inner_proc_unlock(proc);\n\t\t\tbinder_user_error(\"%d:%d got reply transaction with no transaction stack\\n\",\n\t\t\t\t\t  proc->pid, thread->pid);\n\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\treturn_error_param = -EPROTO;\n\t\t\treturn_error_line = __LINE__;\n\t\t\tgoto err_empty_call_stack;\n\t\t}\n\t\tif (in_reply_to->to_thread != thread) {\n\t\t\tspin_lock(&in_reply_to->lock);\n\t\t\tbinder_user_error(\"%d:%d got reply transaction with bad transaction stack, transaction %d has target %d:%d\\n\",\n\t\t\t\tproc->pid, thread->pid, in_reply_to->debug_id,\n\t\t\t\tin_reply_to->to_proc ?\n\t\t\t\tin_reply_to->to_proc->pid : 0,\n\t\t\t\tin_reply_to->to_thread ?\n\t\t\t\tin_reply_to->to_thread->pid : 0);\n\t\t\tspin_unlock(&in_reply_to->lock);\n\t\t\tbinder_inner_proc_unlock(proc);\n\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\treturn_error_param = -EPROTO;\n\t\t\treturn_error_line = __LINE__;\n\t\t\tin_reply_to = NULL;\n\t\t\tgoto err_bad_call_stack;\n\t\t}\n\t\tthread->transaction_stack = in_reply_to->to_parent;\n\t\tbinder_inner_proc_unlock(proc);\n\t\tbinder_set_nice(in_reply_to->saved_priority);\n\t\ttarget_thread = binder_get_txn_from_and_acq_inner(in_reply_to);\n\t\tif (target_thread == NULL) {\n\t\t\t/* annotation for sparse */\n\t\t\t__release(&target_thread->proc->inner_lock);\n\t\t\treturn_error = BR_DEAD_REPLY;\n\t\t\treturn_error_line = __LINE__;\n\t\t\tgoto err_dead_binder;\n\t\t}\n\t\tif (target_thread->transaction_stack != in_reply_to) {\n\t\t\tbinder_user_error(\"%d:%d got reply transaction with bad target transaction stack %d, expected %d\\n\",\n\t\t\t\tproc->pid, thread->pid,\n\t\t\t\ttarget_thread->transaction_stack ?\n\t\t\t\ttarget_thread->transaction_stack->debug_id : 0,\n\t\t\t\tin_reply_to->debug_id);\n\t\t\tbinder_inner_proc_unlock(target_thread->proc);\n\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\treturn_error_param = -EPROTO;\n\t\t\treturn_error_line = __LINE__;\n\t\t\tin_reply_to = NULL;\n\t\t\ttarget_thread = NULL;\n\t\t\tgoto err_dead_binder;\n\t\t}\n\t\ttarget_proc = target_thread->proc;\n\t\ttarget_proc->tmp_ref++;\n\t\tbinder_inner_proc_unlock(target_thread->proc);\n\t} else {\n\t\tif (tr->target.handle) {\n\t\t\tstruct binder_ref *ref;\n\n\t\t\t/*\n\t\t\t * There must already be a strong ref\n\t\t\t * on this node. If so, do a strong\n\t\t\t * increment on the node to ensure it\n\t\t\t * stays alive until the transaction is\n\t\t\t * done.\n\t\t\t */\n\t\t\tbinder_proc_lock(proc);\n\t\t\tref = binder_get_ref_olocked(proc, tr->target.handle,\n\t\t\t\t\t\t     true);\n\t\t\tif (ref) {\n\t\t\t\ttarget_node = binder_get_node_refs_for_txn(\n\t\t\t\t\t\tref->node, &target_proc,\n\t\t\t\t\t\t&return_error);\n\t\t\t} else {\n\t\t\t\tbinder_user_error(\"%d:%d got transaction to invalid handle, %u\\n\",\n\t\t\t\t\t\t  proc->pid, thread->pid, tr->target.handle);\n\t\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\t}\n\t\t\tbinder_proc_unlock(proc);\n\t\t} else {\n\t\t\tmutex_lock(&context->context_mgr_node_lock);\n\t\t\ttarget_node = context->binder_context_mgr_node;\n\t\t\tif (target_node)\n\t\t\t\ttarget_node = binder_get_node_refs_for_txn(\n\t\t\t\t\t\ttarget_node, &target_proc,\n\t\t\t\t\t\t&return_error);\n\t\t\telse\n\t\t\t\treturn_error = BR_DEAD_REPLY;\n\t\t\tmutex_unlock(&context->context_mgr_node_lock);\n\t\t\tif (target_node && target_proc->pid == proc->pid) {\n\t\t\t\tbinder_user_error(\"%d:%d got transaction to context manager from process owning it\\n\",\n\t\t\t\t\t\t  proc->pid, thread->pid);\n\t\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\t\treturn_error_param = -EINVAL;\n\t\t\t\treturn_error_line = __LINE__;\n\t\t\t\tgoto err_invalid_target_handle;\n\t\t\t}\n\t\t}\n\t\tif (!target_node) {\n\t\t\t/*\n\t\t\t * return_error is set above\n\t\t\t */\n\t\t\treturn_error_param = -EINVAL;\n\t\t\treturn_error_line = __LINE__;\n\t\t\tgoto err_dead_binder;\n\t\t}\n\t\te->to_node = target_node->debug_id;\n\t\tif (WARN_ON(proc == target_proc)) {\n\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\treturn_error_param = -EINVAL;\n\t\t\treturn_error_line = __LINE__;\n\t\t\tgoto err_invalid_target_handle;\n\t\t}\n\t\tif (security_binder_transaction(proc->tsk,\n\t\t\t\t\t\ttarget_proc->tsk) < 0) {\n\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\treturn_error_param = -EPERM;\n\t\t\treturn_error_line = __LINE__;\n\t\t\tgoto err_invalid_target_handle;\n\t\t}\n\t\tbinder_inner_proc_lock(proc);\n\n\t\tw = list_first_entry_or_null(&thread->todo,\n\t\t\t\t\t     struct binder_work, entry);\n\t\tif (!(tr->flags & TF_ONE_WAY) && w &&\n\t\t    w->type == BINDER_WORK_TRANSACTION) {\n\t\t\t/*\n\t\t\t * Do not allow new outgoing transaction from a\n\t\t\t * thread that has a transaction at the head of\n\t\t\t * its todo list. Only need to check the head\n\t\t\t * because binder_select_thread_ilocked picks a\n\t\t\t * thread from proc->waiting_threads to enqueue\n\t\t\t * the transaction, and nothing is queued to the\n\t\t\t * todo list while the thread is on waiting_threads.\n\t\t\t */\n\t\t\tbinder_user_error(\"%d:%d new transaction not allowed when there is a transaction on thread todo\\n\",\n\t\t\t\t\t  proc->pid, thread->pid);\n\t\t\tbinder_inner_proc_unlock(proc);\n\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\treturn_error_param = -EPROTO;\n\t\t\treturn_error_line = __LINE__;\n\t\t\tgoto err_bad_todo_list;\n\t\t}\n\n\t\tif (!(tr->flags & TF_ONE_WAY) && thread->transaction_stack) {\n\t\t\tstruct binder_transaction *tmp;\n\n\t\t\ttmp = thread->transaction_stack;\n\t\t\tif (tmp->to_thread != thread) {\n\t\t\t\tspin_lock(&tmp->lock);\n\t\t\t\tbinder_user_error(\"%d:%d got new transaction with bad transaction stack, transaction %d has target %d:%d\\n\",\n\t\t\t\t\tproc->pid, thread->pid, tmp->debug_id,\n\t\t\t\t\ttmp->to_proc ? tmp->to_proc->pid : 0,\n\t\t\t\t\ttmp->to_thread ?\n\t\t\t\t\ttmp->to_thread->pid : 0);\n\t\t\t\tspin_unlock(&tmp->lock);\n\t\t\t\tbinder_inner_proc_unlock(proc);\n\t\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\t\treturn_error_param = -EPROTO;\n\t\t\t\treturn_error_line = __LINE__;\n\t\t\t\tgoto err_bad_call_stack;\n\t\t\t}\n\t\t\twhile (tmp) {\n\t\t\t\tstruct binder_thread *from;\n\n\t\t\t\tspin_lock(&tmp->lock);\n\t\t\t\tfrom = tmp->from;\n\t\t\t\tif (from && from->proc == target_proc) {\n\t\t\t\t\tatomic_inc(&from->tmp_ref);\n\t\t\t\t\ttarget_thread = from;\n\t\t\t\t\tspin_unlock(&tmp->lock);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tspin_unlock(&tmp->lock);\n\t\t\t\ttmp = tmp->from_parent;\n\t\t\t}\n\t\t}\n\t\tbinder_inner_proc_unlock(proc);\n\t}\n\tif (target_thread)\n\t\te->to_thread = target_thread->pid;\n\te->to_proc = target_proc->pid;\n\n\t/* TODO: reuse incoming transaction for reply */\n\tt = kzalloc(sizeof(*t), GFP_KERNEL);\n\tif (t == NULL) {\n\t\treturn_error = BR_FAILED_REPLY;\n\t\treturn_error_param = -ENOMEM;\n\t\treturn_error_line = __LINE__;\n\t\tgoto err_alloc_t_failed;\n\t}\n\tINIT_LIST_HEAD(&t->fd_fixups);\n\tbinder_stats_created(BINDER_STAT_TRANSACTION);\n\tspin_lock_init(&t->lock);\n\n\ttcomplete = kzalloc(sizeof(*tcomplete), GFP_KERNEL);\n\tif (tcomplete == NULL) {\n\t\treturn_error = BR_FAILED_REPLY;\n\t\treturn_error_param = -ENOMEM;\n\t\treturn_error_line = __LINE__;\n\t\tgoto err_alloc_tcomplete_failed;\n\t}\n\tbinder_stats_created(BINDER_STAT_TRANSACTION_COMPLETE);\n\n\tt->debug_id = t_debug_id;\n\n\tif (reply)\n\t\tbinder_debug(BINDER_DEBUG_TRANSACTION,\n\t\t\t     \"%d:%d BC_REPLY %d -> %d:%d, data %016llx-%016llx size %lld-%lld-%lld\\n\",\n\t\t\t     proc->pid, thread->pid, t->debug_id,\n\t\t\t     target_proc->pid, target_thread->pid,\n\t\t\t     (u64)tr->data.ptr.buffer,\n\t\t\t     (u64)tr->data.ptr.offsets,\n\t\t\t     (u64)tr->data_size, (u64)tr->offsets_size,\n\t\t\t     (u64)extra_buffers_size);\n\telse\n\t\tbinder_debug(BINDER_DEBUG_TRANSACTION,\n\t\t\t     \"%d:%d BC_TRANSACTION %d -> %d - node %d, data %016llx-%016llx size %lld-%lld-%lld\\n\",\n\t\t\t     proc->pid, thread->pid, t->debug_id,\n\t\t\t     target_proc->pid, target_node->debug_id,\n\t\t\t     (u64)tr->data.ptr.buffer,\n\t\t\t     (u64)tr->data.ptr.offsets,\n\t\t\t     (u64)tr->data_size, (u64)tr->offsets_size,\n\t\t\t     (u64)extra_buffers_size);\n\n\tif (!reply && !(tr->flags & TF_ONE_WAY))\n\t\tt->from = thread;\n\telse\n\t\tt->from = NULL;\n\tt->sender_euid = proc->cred->euid;\n\tt->to_proc = target_proc;\n\tt->to_thread = target_thread;\n\tt->code = tr->code;\n\tt->flags = tr->flags;\n\tt->priority = task_nice(current);\n\n\tif (target_node && target_node->txn_security_ctx) {\n\t\tu32 secid;\n\t\tsize_t added_size;\n\n\t\t/*\n\t\t * Arguably this should be the task's subjective LSM secid but\n\t\t * we can't reliably access the subjective creds of a task\n\t\t * other than our own so we must use the objective creds, which\n\t\t * are safe to access.  The downside is that if a task is\n\t\t * temporarily overriding it's creds it will not be reflected\n\t\t * here; however, it isn't clear that binder would handle that\n\t\t * case well anyway.\n\t\t */\n\t\tsecurity_task_getsecid_obj(proc->tsk, &secid);\n\t\tret = security_secid_to_secctx(secid, &secctx, &secctx_sz);\n\t\tif (ret) {\n\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\treturn_error_param = ret;\n\t\t\treturn_error_line = __LINE__;\n\t\t\tgoto err_get_secctx_failed;\n\t\t}\n\t\tadded_size = ALIGN(secctx_sz, sizeof(u64));\n\t\textra_buffers_size += added_size;\n\t\tif (extra_buffers_size < added_size) {\n\t\t\t/* integer overflow of extra_buffers_size */\n\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\treturn_error_param = -EINVAL;\n\t\t\treturn_error_line = __LINE__;\n\t\t\tgoto err_bad_extra_size;\n\t\t}\n\t}\n\n\ttrace_binder_transaction(reply, t, target_node);\n\n\tt->buffer = binder_alloc_new_buf(&target_proc->alloc, tr->data_size,\n\t\ttr->offsets_size, extra_buffers_size,\n\t\t!reply && (t->flags & TF_ONE_WAY), current->tgid);\n\tif (IS_ERR(t->buffer)) {\n\t\t/*\n\t\t * -ESRCH indicates VMA cleared. The target is dying.\n\t\t */\n\t\treturn_error_param = PTR_ERR(t->buffer);\n\t\treturn_error = return_error_param == -ESRCH ?\n\t\t\tBR_DEAD_REPLY : BR_FAILED_REPLY;\n\t\treturn_error_line = __LINE__;\n\t\tt->buffer = NULL;\n\t\tgoto err_binder_alloc_buf_failed;\n\t}\n\tif (secctx) {\n\t\tint err;\n\t\tsize_t buf_offset = ALIGN(tr->data_size, sizeof(void *)) +\n\t\t\t\t    ALIGN(tr->offsets_size, sizeof(void *)) +\n\t\t\t\t    ALIGN(extra_buffers_size, sizeof(void *)) -\n\t\t\t\t    ALIGN(secctx_sz, sizeof(u64));\n\n\t\tt->security_ctx = (uintptr_t)t->buffer->user_data + buf_offset;\n\t\terr = binder_alloc_copy_to_buffer(&target_proc->alloc,\n\t\t\t\t\t\t  t->buffer, buf_offset,\n\t\t\t\t\t\t  secctx, secctx_sz);\n\t\tif (err) {\n\t\t\tt->security_ctx = 0;\n\t\t\tWARN_ON(1);\n\t\t}\n\t\tsecurity_release_secctx(secctx, secctx_sz);\n\t\tsecctx = NULL;\n\t}\n\tt->buffer->debug_id = t->debug_id;\n\tt->buffer->transaction = t;\n\tt->buffer->target_node = target_node;\n\tt->buffer->clear_on_free = !!(t->flags & TF_CLEAR_BUF);\n\ttrace_binder_transaction_alloc_buf(t->buffer);\n\n\tif (binder_alloc_copy_user_to_buffer(\n\t\t\t\t&target_proc->alloc,\n\t\t\t\tt->buffer, 0,\n\t\t\t\t(const void __user *)\n\t\t\t\t\t(uintptr_t)tr->data.ptr.buffer,\n\t\t\t\ttr->data_size)) {\n\t\tbinder_user_error(\"%d:%d got transaction with invalid data ptr\\n\",\n\t\t\t\tproc->pid, thread->pid);\n\t\treturn_error = BR_FAILED_REPLY;\n\t\treturn_error_param = -EFAULT;\n\t\treturn_error_line = __LINE__;\n\t\tgoto err_copy_data_failed;\n\t}\n\tif (binder_alloc_copy_user_to_buffer(\n\t\t\t\t&target_proc->alloc,\n\t\t\t\tt->buffer,\n\t\t\t\tALIGN(tr->data_size, sizeof(void *)),\n\t\t\t\t(const void __user *)\n\t\t\t\t\t(uintptr_t)tr->data.ptr.offsets,\n\t\t\t\ttr->offsets_size)) {\n\t\tbinder_user_error(\"%d:%d got transaction with invalid offsets ptr\\n\",\n\t\t\t\tproc->pid, thread->pid);\n\t\treturn_error = BR_FAILED_REPLY;\n\t\treturn_error_param = -EFAULT;\n\t\treturn_error_line = __LINE__;\n\t\tgoto err_copy_data_failed;\n\t}\n\tif (!IS_ALIGNED(tr->offsets_size, sizeof(binder_size_t))) {\n\t\tbinder_user_error(\"%d:%d got transaction with invalid offsets size, %lld\\n\",\n\t\t\t\tproc->pid, thread->pid, (u64)tr->offsets_size);\n\t\treturn_error = BR_FAILED_REPLY;\n\t\treturn_error_param = -EINVAL;\n\t\treturn_error_line = __LINE__;\n\t\tgoto err_bad_offset;\n\t}\n\tif (!IS_ALIGNED(extra_buffers_size, sizeof(u64))) {\n\t\tbinder_user_error(\"%d:%d got transaction with unaligned buffers size, %lld\\n\",\n\t\t\t\t  proc->pid, thread->pid,\n\t\t\t\t  (u64)extra_buffers_size);\n\t\treturn_error = BR_FAILED_REPLY;\n\t\treturn_error_param = -EINVAL;\n\t\treturn_error_line = __LINE__;\n\t\tgoto err_bad_offset;\n\t}\n\toff_start_offset = ALIGN(tr->data_size, sizeof(void *));\n\tbuffer_offset = off_start_offset;\n\toff_end_offset = off_start_offset + tr->offsets_size;\n\tsg_buf_offset = ALIGN(off_end_offset, sizeof(void *));\n\tsg_buf_end_offset = sg_buf_offset + extra_buffers_size -\n\t\tALIGN(secctx_sz, sizeof(u64));\n\toff_min = 0;\n\tfor (buffer_offset = off_start_offset; buffer_offset < off_end_offset;\n\t     buffer_offset += sizeof(binder_size_t)) {\n\t\tstruct binder_object_header *hdr;\n\t\tsize_t object_size;\n\t\tstruct binder_object object;\n\t\tbinder_size_t object_offset;\n\n\t\tif (binder_alloc_copy_from_buffer(&target_proc->alloc,\n\t\t\t\t\t\t  &object_offset,\n\t\t\t\t\t\t  t->buffer,\n\t\t\t\t\t\t  buffer_offset,\n\t\t\t\t\t\t  sizeof(object_offset))) {\n\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\treturn_error_param = -EINVAL;\n\t\t\treturn_error_line = __LINE__;\n\t\t\tgoto err_bad_offset;\n\t\t}\n\t\tobject_size = binder_get_object(target_proc, t->buffer,\n\t\t\t\t\t\tobject_offset, &object);\n\t\tif (object_size == 0 || object_offset < off_min) {\n\t\t\tbinder_user_error(\"%d:%d got transaction with invalid offset (%lld, min %lld max %lld) or object.\\n\",\n\t\t\t\t\t  proc->pid, thread->pid,\n\t\t\t\t\t  (u64)object_offset,\n\t\t\t\t\t  (u64)off_min,\n\t\t\t\t\t  (u64)t->buffer->data_size);\n\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\treturn_error_param = -EINVAL;\n\t\t\treturn_error_line = __LINE__;\n\t\t\tgoto err_bad_offset;\n\t\t}\n\n\t\thdr = &object.hdr;\n\t\toff_min = object_offset + object_size;\n\t\tswitch (hdr->type) {\n\t\tcase BINDER_TYPE_BINDER:\n\t\tcase BINDER_TYPE_WEAK_BINDER: {\n\t\t\tstruct flat_binder_object *fp;\n\n\t\t\tfp = to_flat_binder_object(hdr);\n\t\t\tret = binder_translate_binder(fp, t, thread);\n\n\t\t\tif (ret < 0 ||\n\t\t\t    binder_alloc_copy_to_buffer(&target_proc->alloc,\n\t\t\t\t\t\t\tt->buffer,\n\t\t\t\t\t\t\tobject_offset,\n\t\t\t\t\t\t\tfp, sizeof(*fp))) {\n\t\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\t\treturn_error_param = ret;\n\t\t\t\treturn_error_line = __LINE__;\n\t\t\t\tgoto err_translate_failed;\n\t\t\t}\n\t\t} break;\n\t\tcase BINDER_TYPE_HANDLE:\n\t\tcase BINDER_TYPE_WEAK_HANDLE: {\n\t\t\tstruct flat_binder_object *fp;\n\n\t\t\tfp = to_flat_binder_object(hdr);\n\t\t\tret = binder_translate_handle(fp, t, thread);\n\t\t\tif (ret < 0 ||\n\t\t\t    binder_alloc_copy_to_buffer(&target_proc->alloc,\n\t\t\t\t\t\t\tt->buffer,\n\t\t\t\t\t\t\tobject_offset,\n\t\t\t\t\t\t\tfp, sizeof(*fp))) {\n\t\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\t\treturn_error_param = ret;\n\t\t\t\treturn_error_line = __LINE__;\n\t\t\t\tgoto err_translate_failed;\n\t\t\t}\n\t\t} break;\n\n\t\tcase BINDER_TYPE_FD: {\n\t\t\tstruct binder_fd_object *fp = to_binder_fd_object(hdr);\n\t\t\tbinder_size_t fd_offset = object_offset +\n\t\t\t\t(uintptr_t)&fp->fd - (uintptr_t)fp;\n\t\t\tint ret = binder_translate_fd(fp->fd, fd_offset, t,\n\t\t\t\t\t\t      thread, in_reply_to);\n\n\t\t\tfp->pad_binder = 0;\n\t\t\tif (ret < 0 ||\n\t\t\t    binder_alloc_copy_to_buffer(&target_proc->alloc,\n\t\t\t\t\t\t\tt->buffer,\n\t\t\t\t\t\t\tobject_offset,\n\t\t\t\t\t\t\tfp, sizeof(*fp))) {\n\t\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\t\treturn_error_param = ret;\n\t\t\t\treturn_error_line = __LINE__;\n\t\t\t\tgoto err_translate_failed;\n\t\t\t}\n\t\t} break;\n\t\tcase BINDER_TYPE_FDA: {\n\t\t\tstruct binder_object ptr_object;\n\t\t\tbinder_size_t parent_offset;\n\t\t\tstruct binder_fd_array_object *fda =\n\t\t\t\tto_binder_fd_array_object(hdr);\n\t\t\tsize_t num_valid = (buffer_offset - off_start_offset) /\n\t\t\t\t\t\tsizeof(binder_size_t);\n\t\t\tstruct binder_buffer_object *parent =\n\t\t\t\tbinder_validate_ptr(target_proc, t->buffer,\n\t\t\t\t\t\t    &ptr_object, fda->parent,\n\t\t\t\t\t\t    off_start_offset,\n\t\t\t\t\t\t    &parent_offset,\n\t\t\t\t\t\t    num_valid);\n\t\t\tif (!parent) {\n\t\t\t\tbinder_user_error(\"%d:%d got transaction with invalid parent offset or type\\n\",\n\t\t\t\t\t\t  proc->pid, thread->pid);\n\t\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\t\treturn_error_param = -EINVAL;\n\t\t\t\treturn_error_line = __LINE__;\n\t\t\t\tgoto err_bad_parent;\n\t\t\t}\n\t\t\tif (!binder_validate_fixup(target_proc, t->buffer,\n\t\t\t\t\t\t   off_start_offset,\n\t\t\t\t\t\t   parent_offset,\n\t\t\t\t\t\t   fda->parent_offset,\n\t\t\t\t\t\t   last_fixup_obj_off,\n\t\t\t\t\t\t   last_fixup_min_off)) {\n\t\t\t\tbinder_user_error(\"%d:%d got transaction with out-of-order buffer fixup\\n\",\n\t\t\t\t\t\t  proc->pid, thread->pid);\n\t\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\t\treturn_error_param = -EINVAL;\n\t\t\t\treturn_error_line = __LINE__;\n\t\t\t\tgoto err_bad_parent;\n\t\t\t}\n\t\t\tret = binder_translate_fd_array(fda, parent, t, thread,\n\t\t\t\t\t\t\tin_reply_to);\n\t\t\tif (ret < 0) {\n\t\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\t\treturn_error_param = ret;\n\t\t\t\treturn_error_line = __LINE__;\n\t\t\t\tgoto err_translate_failed;\n\t\t\t}\n\t\t\tlast_fixup_obj_off = parent_offset;\n\t\t\tlast_fixup_min_off =\n\t\t\t\tfda->parent_offset + sizeof(u32) * fda->num_fds;\n\t\t} break;\n\t\tcase BINDER_TYPE_PTR: {\n\t\t\tstruct binder_buffer_object *bp =\n\t\t\t\tto_binder_buffer_object(hdr);\n\t\t\tsize_t buf_left = sg_buf_end_offset - sg_buf_offset;\n\t\t\tsize_t num_valid;\n\n\t\t\tif (bp->length > buf_left) {\n\t\t\t\tbinder_user_error(\"%d:%d got transaction with too large buffer\\n\",\n\t\t\t\t\t\t  proc->pid, thread->pid);\n\t\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\t\treturn_error_param = -EINVAL;\n\t\t\t\treturn_error_line = __LINE__;\n\t\t\t\tgoto err_bad_offset;\n\t\t\t}\n\t\t\tif (binder_alloc_copy_user_to_buffer(\n\t\t\t\t\t\t&target_proc->alloc,\n\t\t\t\t\t\tt->buffer,\n\t\t\t\t\t\tsg_buf_offset,\n\t\t\t\t\t\t(const void __user *)\n\t\t\t\t\t\t\t(uintptr_t)bp->buffer,\n\t\t\t\t\t\tbp->length)) {\n\t\t\t\tbinder_user_error(\"%d:%d got transaction with invalid offsets ptr\\n\",\n\t\t\t\t\t\t  proc->pid, thread->pid);\n\t\t\t\treturn_error_param = -EFAULT;\n\t\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\t\treturn_error_line = __LINE__;\n\t\t\t\tgoto err_copy_data_failed;\n\t\t\t}\n\t\t\t/* Fixup buffer pointer to target proc address space */\n\t\t\tbp->buffer = (uintptr_t)\n\t\t\t\tt->buffer->user_data + sg_buf_offset;\n\t\t\tsg_buf_offset += ALIGN(bp->length, sizeof(u64));\n\n\t\t\tnum_valid = (buffer_offset - off_start_offset) /\n\t\t\t\t\tsizeof(binder_size_t);\n\t\t\tret = binder_fixup_parent(t, thread, bp,\n\t\t\t\t\t\t  off_start_offset,\n\t\t\t\t\t\t  num_valid,\n\t\t\t\t\t\t  last_fixup_obj_off,\n\t\t\t\t\t\t  last_fixup_min_off);\n\t\t\tif (ret < 0 ||\n\t\t\t    binder_alloc_copy_to_buffer(&target_proc->alloc,\n\t\t\t\t\t\t\tt->buffer,\n\t\t\t\t\t\t\tobject_offset,\n\t\t\t\t\t\t\tbp, sizeof(*bp))) {\n\t\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\t\treturn_error_param = ret;\n\t\t\t\treturn_error_line = __LINE__;\n\t\t\t\tgoto err_translate_failed;\n\t\t\t}\n\t\t\tlast_fixup_obj_off = object_offset;\n\t\t\tlast_fixup_min_off = 0;\n\t\t} break;\n\t\tdefault:\n\t\t\tbinder_user_error(\"%d:%d got transaction with invalid object type, %x\\n\",\n\t\t\t\tproc->pid, thread->pid, hdr->type);\n\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\treturn_error_param = -EINVAL;\n\t\t\treturn_error_line = __LINE__;\n\t\t\tgoto err_bad_object_type;\n\t\t}\n\t}\n\tif (t->buffer->oneway_spam_suspect)\n\t\ttcomplete->type = BINDER_WORK_TRANSACTION_ONEWAY_SPAM_SUSPECT;\n\telse\n\t\ttcomplete->type = BINDER_WORK_TRANSACTION_COMPLETE;\n\tt->work.type = BINDER_WORK_TRANSACTION;\n\n\tif (reply) {\n\t\tbinder_enqueue_thread_work(thread, tcomplete);\n\t\tbinder_inner_proc_lock(target_proc);\n\t\tif (target_thread->is_dead || target_proc->is_frozen) {\n\t\t\treturn_error = target_thread->is_dead ?\n\t\t\t\tBR_DEAD_REPLY : BR_FROZEN_REPLY;\n\t\t\tbinder_inner_proc_unlock(target_proc);\n\t\t\tgoto err_dead_proc_or_thread;\n\t\t}\n\t\tBUG_ON(t->buffer->async_transaction != 0);\n\t\tbinder_pop_transaction_ilocked(target_thread, in_reply_to);\n\t\tbinder_enqueue_thread_work_ilocked(target_thread, &t->work);\n\t\ttarget_proc->outstanding_txns++;\n\t\tbinder_inner_proc_unlock(target_proc);\n\t\twake_up_interruptible_sync(&target_thread->wait);\n\t\tbinder_free_transaction(in_reply_to);\n\t} else if (!(t->flags & TF_ONE_WAY)) {\n\t\tBUG_ON(t->buffer->async_transaction != 0);\n\t\tbinder_inner_proc_lock(proc);\n\t\t/*\n\t\t * Defer the TRANSACTION_COMPLETE, so we don't return to\n\t\t * userspace immediately; this allows the target process to\n\t\t * immediately start processing this transaction, reducing\n\t\t * latency. We will then return the TRANSACTION_COMPLETE when\n\t\t * the target replies (or there is an error).\n\t\t */\n\t\tbinder_enqueue_deferred_thread_work_ilocked(thread, tcomplete);\n\t\tt->need_reply = 1;\n\t\tt->from_parent = thread->transaction_stack;\n\t\tthread->transaction_stack = t;\n\t\tbinder_inner_proc_unlock(proc);\n\t\treturn_error = binder_proc_transaction(t,\n\t\t\t\ttarget_proc, target_thread);\n\t\tif (return_error) {\n\t\t\tbinder_inner_proc_lock(proc);\n\t\t\tbinder_pop_transaction_ilocked(thread, t);\n\t\t\tbinder_inner_proc_unlock(proc);\n\t\t\tgoto err_dead_proc_or_thread;\n\t\t}\n\t} else {\n\t\tBUG_ON(target_node == NULL);\n\t\tBUG_ON(t->buffer->async_transaction != 1);\n\t\tbinder_enqueue_thread_work(thread, tcomplete);\n\t\treturn_error = binder_proc_transaction(t, target_proc, NULL);\n\t\tif (return_error)\n\t\t\tgoto err_dead_proc_or_thread;\n\t}\n\tif (target_thread)\n\t\tbinder_thread_dec_tmpref(target_thread);\n\tbinder_proc_dec_tmpref(target_proc);\n\tif (target_node)\n\t\tbinder_dec_node_tmpref(target_node);\n\t/*\n\t * write barrier to synchronize with initialization\n\t * of log entry\n\t */\n\tsmp_wmb();\n\tWRITE_ONCE(e->debug_id_done, t_debug_id);\n\treturn;\n\nerr_dead_proc_or_thread:\n\treturn_error_line = __LINE__;\n\tbinder_dequeue_work(proc, tcomplete);\nerr_translate_failed:\nerr_bad_object_type:\nerr_bad_offset:\nerr_bad_parent:\nerr_copy_data_failed:\n\tbinder_free_txn_fixups(t);\n\ttrace_binder_transaction_failed_buffer_release(t->buffer);\n\tbinder_transaction_buffer_release(target_proc, t->buffer,\n\t\t\t\t\t  buffer_offset, true);\n\tif (target_node)\n\t\tbinder_dec_node_tmpref(target_node);\n\ttarget_node = NULL;\n\tt->buffer->transaction = NULL;\n\tbinder_alloc_free_buf(&target_proc->alloc, t->buffer);\nerr_binder_alloc_buf_failed:\nerr_bad_extra_size:\n\tif (secctx)\n\t\tsecurity_release_secctx(secctx, secctx_sz);\nerr_get_secctx_failed:\n\tkfree(tcomplete);\n\tbinder_stats_deleted(BINDER_STAT_TRANSACTION_COMPLETE);\nerr_alloc_tcomplete_failed:\n\tif (trace_binder_txn_latency_free_enabled())\n\t\tbinder_txn_latency_free(t);\n\tkfree(t);\n\tbinder_stats_deleted(BINDER_STAT_TRANSACTION);\nerr_alloc_t_failed:\nerr_bad_todo_list:\nerr_bad_call_stack:\nerr_empty_call_stack:\nerr_dead_binder:\nerr_invalid_target_handle:\n\tif (target_thread)\n\t\tbinder_thread_dec_tmpref(target_thread);\n\tif (target_proc)\n\t\tbinder_proc_dec_tmpref(target_proc);\n\tif (target_node) {\n\t\tbinder_dec_node(target_node, 1, 0);\n\t\tbinder_dec_node_tmpref(target_node);\n\t}\n\n\tbinder_debug(BINDER_DEBUG_FAILED_TRANSACTION,\n\t\t     \"%d:%d transaction failed %d/%d, size %lld-%lld line %d\\n\",\n\t\t     proc->pid, thread->pid, return_error, return_error_param,\n\t\t     (u64)tr->data_size, (u64)tr->offsets_size,\n\t\t     return_error_line);\n\n\t{\n\t\tstruct binder_transaction_log_entry *fe;\n\n\t\te->return_error = return_error;\n\t\te->return_error_param = return_error_param;\n\t\te->return_error_line = return_error_line;\n\t\tfe = binder_transaction_log_add(&binder_transaction_log_failed);\n\t\t*fe = *e;\n\t\t/*\n\t\t * write barrier to synchronize with initialization\n\t\t * of log entry\n\t\t */\n\t\tsmp_wmb();\n\t\tWRITE_ONCE(e->debug_id_done, t_debug_id);\n\t\tWRITE_ONCE(fe->debug_id_done, t_debug_id);\n\t}\n\n\tBUG_ON(thread->return_error.cmd != BR_OK);\n\tif (in_reply_to) {\n\t\tthread->return_error.cmd = BR_TRANSACTION_COMPLETE;\n\t\tbinder_enqueue_thread_work(thread, &thread->return_error.work);\n\t\tbinder_send_failed_reply(in_reply_to, return_error);\n\t} else {\n\t\tthread->return_error.cmd = return_error;\n\t\tbinder_enqueue_thread_work(thread, &thread->return_error.work);\n\t}\n}",
        "patch": "--- code before\n+++ code after\n@@ -266,7 +266,7 @@\n \t\tt->from = thread;\n \telse\n \t\tt->from = NULL;\n-\tt->sender_euid = task_euid(proc->tsk);\n+\tt->sender_euid = proc->cred->euid;\n \tt->to_proc = target_proc;\n \tt->to_thread = target_thread;\n \tt->code = tr->code;",
        "function_modified_lines": {
            "added": [
                "\tt->sender_euid = proc->cred->euid;"
            ],
            "deleted": [
                "\tt->sender_euid = task_euid(proc->tsk);"
            ]
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "In several functions of binder.c, there is a possible way to represent the wrong domain to SELinux due to a race condition. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-200688826References: Upstream kernel",
        "id": 3100
    },
    {
        "cve_id": "CVE-2015-3212",
        "code_before_change": "static void sctp_sock_migrate(struct sock *oldsk, struct sock *newsk,\n\t\t\t      struct sctp_association *assoc,\n\t\t\t      sctp_socket_type_t type)\n{\n\tstruct sctp_sock *oldsp = sctp_sk(oldsk);\n\tstruct sctp_sock *newsp = sctp_sk(newsk);\n\tstruct sctp_bind_bucket *pp; /* hash list port iterator */\n\tstruct sctp_endpoint *newep = newsp->ep;\n\tstruct sk_buff *skb, *tmp;\n\tstruct sctp_ulpevent *event;\n\tstruct sctp_bind_hashbucket *head;\n\tstruct list_head tmplist;\n\n\t/* Migrate socket buffer sizes and all the socket level options to the\n\t * new socket.\n\t */\n\tnewsk->sk_sndbuf = oldsk->sk_sndbuf;\n\tnewsk->sk_rcvbuf = oldsk->sk_rcvbuf;\n\t/* Brute force copy old sctp opt. */\n\tif (oldsp->do_auto_asconf) {\n\t\tmemcpy(&tmplist, &newsp->auto_asconf_list, sizeof(tmplist));\n\t\tinet_sk_copy_descendant(newsk, oldsk);\n\t\tmemcpy(&newsp->auto_asconf_list, &tmplist, sizeof(tmplist));\n\t} else\n\t\tinet_sk_copy_descendant(newsk, oldsk);\n\n\t/* Restore the ep value that was overwritten with the above structure\n\t * copy.\n\t */\n\tnewsp->ep = newep;\n\tnewsp->hmac = NULL;\n\n\t/* Hook this new socket in to the bind_hash list. */\n\thead = &sctp_port_hashtable[sctp_phashfn(sock_net(oldsk),\n\t\t\t\t\t\t inet_sk(oldsk)->inet_num)];\n\tlocal_bh_disable();\n\tspin_lock(&head->lock);\n\tpp = sctp_sk(oldsk)->bind_hash;\n\tsk_add_bind_node(newsk, &pp->owner);\n\tsctp_sk(newsk)->bind_hash = pp;\n\tinet_sk(newsk)->inet_num = inet_sk(oldsk)->inet_num;\n\tspin_unlock(&head->lock);\n\tlocal_bh_enable();\n\n\t/* Copy the bind_addr list from the original endpoint to the new\n\t * endpoint so that we can handle restarts properly\n\t */\n\tsctp_bind_addr_dup(&newsp->ep->base.bind_addr,\n\t\t\t\t&oldsp->ep->base.bind_addr, GFP_KERNEL);\n\n\t/* Move any messages in the old socket's receive queue that are for the\n\t * peeled off association to the new socket's receive queue.\n\t */\n\tsctp_skb_for_each(skb, &oldsk->sk_receive_queue, tmp) {\n\t\tevent = sctp_skb2event(skb);\n\t\tif (event->asoc == assoc) {\n\t\t\t__skb_unlink(skb, &oldsk->sk_receive_queue);\n\t\t\t__skb_queue_tail(&newsk->sk_receive_queue, skb);\n\t\t\tsctp_skb_set_owner_r_frag(skb, newsk);\n\t\t}\n\t}\n\n\t/* Clean up any messages pending delivery due to partial\n\t * delivery.   Three cases:\n\t * 1) No partial deliver;  no work.\n\t * 2) Peeling off partial delivery; keep pd_lobby in new pd_lobby.\n\t * 3) Peeling off non-partial delivery; move pd_lobby to receive_queue.\n\t */\n\tskb_queue_head_init(&newsp->pd_lobby);\n\tatomic_set(&sctp_sk(newsk)->pd_mode, assoc->ulpq.pd_mode);\n\n\tif (atomic_read(&sctp_sk(oldsk)->pd_mode)) {\n\t\tstruct sk_buff_head *queue;\n\n\t\t/* Decide which queue to move pd_lobby skbs to. */\n\t\tif (assoc->ulpq.pd_mode) {\n\t\t\tqueue = &newsp->pd_lobby;\n\t\t} else\n\t\t\tqueue = &newsk->sk_receive_queue;\n\n\t\t/* Walk through the pd_lobby, looking for skbs that\n\t\t * need moved to the new socket.\n\t\t */\n\t\tsctp_skb_for_each(skb, &oldsp->pd_lobby, tmp) {\n\t\t\tevent = sctp_skb2event(skb);\n\t\t\tif (event->asoc == assoc) {\n\t\t\t\t__skb_unlink(skb, &oldsp->pd_lobby);\n\t\t\t\t__skb_queue_tail(queue, skb);\n\t\t\t\tsctp_skb_set_owner_r_frag(skb, newsk);\n\t\t\t}\n\t\t}\n\n\t\t/* Clear up any skbs waiting for the partial\n\t\t * delivery to finish.\n\t\t */\n\t\tif (assoc->ulpq.pd_mode)\n\t\t\tsctp_clear_pd(oldsk, NULL);\n\n\t}\n\n\tsctp_skb_for_each(skb, &assoc->ulpq.reasm, tmp)\n\t\tsctp_skb_set_owner_r_frag(skb, newsk);\n\n\tsctp_skb_for_each(skb, &assoc->ulpq.lobby, tmp)\n\t\tsctp_skb_set_owner_r_frag(skb, newsk);\n\n\t/* Set the type of socket to indicate that it is peeled off from the\n\t * original UDP-style socket or created with the accept() call on a\n\t * TCP-style socket..\n\t */\n\tnewsp->type = type;\n\n\t/* Mark the new socket \"in-use\" by the user so that any packets\n\t * that may arrive on the association after we've moved it are\n\t * queued to the backlog.  This prevents a potential race between\n\t * backlog processing on the old socket and new-packet processing\n\t * on the new socket.\n\t *\n\t * The caller has just allocated newsk so we can guarantee that other\n\t * paths won't try to lock it and then oldsk.\n\t */\n\tlock_sock_nested(newsk, SINGLE_DEPTH_NESTING);\n\tsctp_assoc_migrate(assoc, newsk);\n\n\t/* If the association on the newsk is already closed before accept()\n\t * is called, set RCV_SHUTDOWN flag.\n\t */\n\tif (sctp_state(assoc, CLOSED) && sctp_style(newsk, TCP))\n\t\tnewsk->sk_shutdown |= RCV_SHUTDOWN;\n\n\tnewsk->sk_state = SCTP_SS_ESTABLISHED;\n\trelease_sock(newsk);\n}",
        "code_after_change": "static void sctp_sock_migrate(struct sock *oldsk, struct sock *newsk,\n\t\t\t      struct sctp_association *assoc,\n\t\t\t      sctp_socket_type_t type)\n{\n\tstruct sctp_sock *oldsp = sctp_sk(oldsk);\n\tstruct sctp_sock *newsp = sctp_sk(newsk);\n\tstruct sctp_bind_bucket *pp; /* hash list port iterator */\n\tstruct sctp_endpoint *newep = newsp->ep;\n\tstruct sk_buff *skb, *tmp;\n\tstruct sctp_ulpevent *event;\n\tstruct sctp_bind_hashbucket *head;\n\n\t/* Migrate socket buffer sizes and all the socket level options to the\n\t * new socket.\n\t */\n\tnewsk->sk_sndbuf = oldsk->sk_sndbuf;\n\tnewsk->sk_rcvbuf = oldsk->sk_rcvbuf;\n\t/* Brute force copy old sctp opt. */\n\tsctp_copy_descendant(newsk, oldsk);\n\n\t/* Restore the ep value that was overwritten with the above structure\n\t * copy.\n\t */\n\tnewsp->ep = newep;\n\tnewsp->hmac = NULL;\n\n\t/* Hook this new socket in to the bind_hash list. */\n\thead = &sctp_port_hashtable[sctp_phashfn(sock_net(oldsk),\n\t\t\t\t\t\t inet_sk(oldsk)->inet_num)];\n\tlocal_bh_disable();\n\tspin_lock(&head->lock);\n\tpp = sctp_sk(oldsk)->bind_hash;\n\tsk_add_bind_node(newsk, &pp->owner);\n\tsctp_sk(newsk)->bind_hash = pp;\n\tinet_sk(newsk)->inet_num = inet_sk(oldsk)->inet_num;\n\tspin_unlock(&head->lock);\n\tlocal_bh_enable();\n\n\t/* Copy the bind_addr list from the original endpoint to the new\n\t * endpoint so that we can handle restarts properly\n\t */\n\tsctp_bind_addr_dup(&newsp->ep->base.bind_addr,\n\t\t\t\t&oldsp->ep->base.bind_addr, GFP_KERNEL);\n\n\t/* Move any messages in the old socket's receive queue that are for the\n\t * peeled off association to the new socket's receive queue.\n\t */\n\tsctp_skb_for_each(skb, &oldsk->sk_receive_queue, tmp) {\n\t\tevent = sctp_skb2event(skb);\n\t\tif (event->asoc == assoc) {\n\t\t\t__skb_unlink(skb, &oldsk->sk_receive_queue);\n\t\t\t__skb_queue_tail(&newsk->sk_receive_queue, skb);\n\t\t\tsctp_skb_set_owner_r_frag(skb, newsk);\n\t\t}\n\t}\n\n\t/* Clean up any messages pending delivery due to partial\n\t * delivery.   Three cases:\n\t * 1) No partial deliver;  no work.\n\t * 2) Peeling off partial delivery; keep pd_lobby in new pd_lobby.\n\t * 3) Peeling off non-partial delivery; move pd_lobby to receive_queue.\n\t */\n\tskb_queue_head_init(&newsp->pd_lobby);\n\tatomic_set(&sctp_sk(newsk)->pd_mode, assoc->ulpq.pd_mode);\n\n\tif (atomic_read(&sctp_sk(oldsk)->pd_mode)) {\n\t\tstruct sk_buff_head *queue;\n\n\t\t/* Decide which queue to move pd_lobby skbs to. */\n\t\tif (assoc->ulpq.pd_mode) {\n\t\t\tqueue = &newsp->pd_lobby;\n\t\t} else\n\t\t\tqueue = &newsk->sk_receive_queue;\n\n\t\t/* Walk through the pd_lobby, looking for skbs that\n\t\t * need moved to the new socket.\n\t\t */\n\t\tsctp_skb_for_each(skb, &oldsp->pd_lobby, tmp) {\n\t\t\tevent = sctp_skb2event(skb);\n\t\t\tif (event->asoc == assoc) {\n\t\t\t\t__skb_unlink(skb, &oldsp->pd_lobby);\n\t\t\t\t__skb_queue_tail(queue, skb);\n\t\t\t\tsctp_skb_set_owner_r_frag(skb, newsk);\n\t\t\t}\n\t\t}\n\n\t\t/* Clear up any skbs waiting for the partial\n\t\t * delivery to finish.\n\t\t */\n\t\tif (assoc->ulpq.pd_mode)\n\t\t\tsctp_clear_pd(oldsk, NULL);\n\n\t}\n\n\tsctp_skb_for_each(skb, &assoc->ulpq.reasm, tmp)\n\t\tsctp_skb_set_owner_r_frag(skb, newsk);\n\n\tsctp_skb_for_each(skb, &assoc->ulpq.lobby, tmp)\n\t\tsctp_skb_set_owner_r_frag(skb, newsk);\n\n\t/* Set the type of socket to indicate that it is peeled off from the\n\t * original UDP-style socket or created with the accept() call on a\n\t * TCP-style socket..\n\t */\n\tnewsp->type = type;\n\n\t/* Mark the new socket \"in-use\" by the user so that any packets\n\t * that may arrive on the association after we've moved it are\n\t * queued to the backlog.  This prevents a potential race between\n\t * backlog processing on the old socket and new-packet processing\n\t * on the new socket.\n\t *\n\t * The caller has just allocated newsk so we can guarantee that other\n\t * paths won't try to lock it and then oldsk.\n\t */\n\tlock_sock_nested(newsk, SINGLE_DEPTH_NESTING);\n\tsctp_assoc_migrate(assoc, newsk);\n\n\t/* If the association on the newsk is already closed before accept()\n\t * is called, set RCV_SHUTDOWN flag.\n\t */\n\tif (sctp_state(assoc, CLOSED) && sctp_style(newsk, TCP))\n\t\tnewsk->sk_shutdown |= RCV_SHUTDOWN;\n\n\tnewsk->sk_state = SCTP_SS_ESTABLISHED;\n\trelease_sock(newsk);\n}",
        "patch": "--- code before\n+++ code after\n@@ -9,7 +9,6 @@\n \tstruct sk_buff *skb, *tmp;\n \tstruct sctp_ulpevent *event;\n \tstruct sctp_bind_hashbucket *head;\n-\tstruct list_head tmplist;\n \n \t/* Migrate socket buffer sizes and all the socket level options to the\n \t * new socket.\n@@ -17,12 +16,7 @@\n \tnewsk->sk_sndbuf = oldsk->sk_sndbuf;\n \tnewsk->sk_rcvbuf = oldsk->sk_rcvbuf;\n \t/* Brute force copy old sctp opt. */\n-\tif (oldsp->do_auto_asconf) {\n-\t\tmemcpy(&tmplist, &newsp->auto_asconf_list, sizeof(tmplist));\n-\t\tinet_sk_copy_descendant(newsk, oldsk);\n-\t\tmemcpy(&newsp->auto_asconf_list, &tmplist, sizeof(tmplist));\n-\t} else\n-\t\tinet_sk_copy_descendant(newsk, oldsk);\n+\tsctp_copy_descendant(newsk, oldsk);\n \n \t/* Restore the ep value that was overwritten with the above structure\n \t * copy.",
        "function_modified_lines": {
            "added": [
                "\tsctp_copy_descendant(newsk, oldsk);"
            ],
            "deleted": [
                "\tstruct list_head tmplist;",
                "\tif (oldsp->do_auto_asconf) {",
                "\t\tmemcpy(&tmplist, &newsp->auto_asconf_list, sizeof(tmplist));",
                "\t\tinet_sk_copy_descendant(newsk, oldsk);",
                "\t\tmemcpy(&newsp->auto_asconf_list, &tmplist, sizeof(tmplist));",
                "\t} else",
                "\t\tinet_sk_copy_descendant(newsk, oldsk);"
            ]
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "Race condition in net/sctp/socket.c in the Linux kernel before 4.1.2 allows local users to cause a denial of service (list corruption and panic) via a rapid series of system calls related to sockets, as demonstrated by setsockopt calls.",
        "id": 749
    },
    {
        "cve_id": "CVE-2023-1582",
        "code_before_change": "static void smaps_pte_entry(pte_t *pte, unsigned long addr,\n\t\tstruct mm_walk *walk)\n{\n\tstruct mem_size_stats *mss = walk->private;\n\tstruct vm_area_struct *vma = walk->vma;\n\tbool locked = !!(vma->vm_flags & VM_LOCKED);\n\tstruct page *page = NULL;\n\n\tif (pte_present(*pte)) {\n\t\tpage = vm_normal_page(vma, addr, *pte);\n\t} else if (is_swap_pte(*pte)) {\n\t\tswp_entry_t swpent = pte_to_swp_entry(*pte);\n\n\t\tif (!non_swap_entry(swpent)) {\n\t\t\tint mapcount;\n\n\t\t\tmss->swap += PAGE_SIZE;\n\t\t\tmapcount = swp_swapcount(swpent);\n\t\t\tif (mapcount >= 2) {\n\t\t\t\tu64 pss_delta = (u64)PAGE_SIZE << PSS_SHIFT;\n\n\t\t\t\tdo_div(pss_delta, mapcount);\n\t\t\t\tmss->swap_pss += pss_delta;\n\t\t\t} else {\n\t\t\t\tmss->swap_pss += (u64)PAGE_SIZE << PSS_SHIFT;\n\t\t\t}\n\t\t} else if (is_pfn_swap_entry(swpent))\n\t\t\tpage = pfn_swap_entry_to_page(swpent);\n\t} else {\n\t\tsmaps_pte_hole_lookup(addr, walk);\n\t\treturn;\n\t}\n\n\tif (!page)\n\t\treturn;\n\n\tsmaps_account(mss, page, false, pte_young(*pte), pte_dirty(*pte), locked);\n}",
        "code_after_change": "static void smaps_pte_entry(pte_t *pte, unsigned long addr,\n\t\tstruct mm_walk *walk)\n{\n\tstruct mem_size_stats *mss = walk->private;\n\tstruct vm_area_struct *vma = walk->vma;\n\tbool locked = !!(vma->vm_flags & VM_LOCKED);\n\tstruct page *page = NULL;\n\tbool migration = false;\n\n\tif (pte_present(*pte)) {\n\t\tpage = vm_normal_page(vma, addr, *pte);\n\t} else if (is_swap_pte(*pte)) {\n\t\tswp_entry_t swpent = pte_to_swp_entry(*pte);\n\n\t\tif (!non_swap_entry(swpent)) {\n\t\t\tint mapcount;\n\n\t\t\tmss->swap += PAGE_SIZE;\n\t\t\tmapcount = swp_swapcount(swpent);\n\t\t\tif (mapcount >= 2) {\n\t\t\t\tu64 pss_delta = (u64)PAGE_SIZE << PSS_SHIFT;\n\n\t\t\t\tdo_div(pss_delta, mapcount);\n\t\t\t\tmss->swap_pss += pss_delta;\n\t\t\t} else {\n\t\t\t\tmss->swap_pss += (u64)PAGE_SIZE << PSS_SHIFT;\n\t\t\t}\n\t\t} else if (is_pfn_swap_entry(swpent)) {\n\t\t\tif (is_migration_entry(swpent))\n\t\t\t\tmigration = true;\n\t\t\tpage = pfn_swap_entry_to_page(swpent);\n\t\t}\n\t} else {\n\t\tsmaps_pte_hole_lookup(addr, walk);\n\t\treturn;\n\t}\n\n\tif (!page)\n\t\treturn;\n\n\tsmaps_account(mss, page, false, pte_young(*pte), pte_dirty(*pte),\n\t\t      locked, migration);\n}",
        "patch": "--- code before\n+++ code after\n@@ -5,6 +5,7 @@\n \tstruct vm_area_struct *vma = walk->vma;\n \tbool locked = !!(vma->vm_flags & VM_LOCKED);\n \tstruct page *page = NULL;\n+\tbool migration = false;\n \n \tif (pte_present(*pte)) {\n \t\tpage = vm_normal_page(vma, addr, *pte);\n@@ -24,8 +25,11 @@\n \t\t\t} else {\n \t\t\t\tmss->swap_pss += (u64)PAGE_SIZE << PSS_SHIFT;\n \t\t\t}\n-\t\t} else if (is_pfn_swap_entry(swpent))\n+\t\t} else if (is_pfn_swap_entry(swpent)) {\n+\t\t\tif (is_migration_entry(swpent))\n+\t\t\t\tmigration = true;\n \t\t\tpage = pfn_swap_entry_to_page(swpent);\n+\t\t}\n \t} else {\n \t\tsmaps_pte_hole_lookup(addr, walk);\n \t\treturn;\n@@ -34,5 +38,6 @@\n \tif (!page)\n \t\treturn;\n \n-\tsmaps_account(mss, page, false, pte_young(*pte), pte_dirty(*pte), locked);\n+\tsmaps_account(mss, page, false, pte_young(*pte), pte_dirty(*pte),\n+\t\t      locked, migration);\n }",
        "function_modified_lines": {
            "added": [
                "\tbool migration = false;",
                "\t\t} else if (is_pfn_swap_entry(swpent)) {",
                "\t\t\tif (is_migration_entry(swpent))",
                "\t\t\t\tmigration = true;",
                "\t\t}",
                "\tsmaps_account(mss, page, false, pte_young(*pte), pte_dirty(*pte),",
                "\t\t      locked, migration);"
            ],
            "deleted": [
                "\t\t} else if (is_pfn_swap_entry(swpent))",
                "\tsmaps_account(mss, page, false, pte_young(*pte), pte_dirty(*pte), locked);"
            ]
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "A race problem was found in fs/proc/task_mmu.c in the memory management sub-component in the Linux kernel. This issue may allow a local attacker with user privilege to cause a denial of service.",
        "id": 3870
    },
    {
        "cve_id": "CVE-2016-10906",
        "code_before_change": "static int arc_emac_tx(struct sk_buff *skb, struct net_device *ndev)\n{\n\tstruct arc_emac_priv *priv = netdev_priv(ndev);\n\tunsigned int len, *txbd_curr = &priv->txbd_curr;\n\tstruct net_device_stats *stats = &ndev->stats;\n\t__le32 *info = &priv->txbd[*txbd_curr].info;\n\tdma_addr_t addr;\n\n\tif (skb_padto(skb, ETH_ZLEN))\n\t\treturn NETDEV_TX_OK;\n\n\tlen = max_t(unsigned int, ETH_ZLEN, skb->len);\n\n\tif (unlikely(!arc_emac_tx_avail(priv))) {\n\t\tnetif_stop_queue(ndev);\n\t\tnetdev_err(ndev, \"BUG! Tx Ring full when queue awake!\\n\");\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\taddr = dma_map_single(&ndev->dev, (void *)skb->data, len,\n\t\t\t      DMA_TO_DEVICE);\n\n\tif (unlikely(dma_mapping_error(&ndev->dev, addr))) {\n\t\tstats->tx_dropped++;\n\t\tstats->tx_errors++;\n\t\tdev_kfree_skb(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\tdma_unmap_addr_set(&priv->tx_buff[*txbd_curr], addr, addr);\n\tdma_unmap_len_set(&priv->tx_buff[*txbd_curr], len, len);\n\n\tpriv->tx_buff[*txbd_curr].skb = skb;\n\tpriv->txbd[*txbd_curr].data = cpu_to_le32(addr);\n\n\t/* Make sure pointer to data buffer is set */\n\twmb();\n\n\tskb_tx_timestamp(skb);\n\n\t*info = cpu_to_le32(FOR_EMAC | FIRST_OR_LAST_MASK | len);\n\n\t/* Increment index to point to the next BD */\n\t*txbd_curr = (*txbd_curr + 1) % TX_BD_NUM;\n\n\t/* Ensure that tx_clean() sees the new txbd_curr before\n\t * checking the queue status. This prevents an unneeded wake\n\t * of the queue in tx_clean().\n\t */\n\tsmp_mb();\n\n\tif (!arc_emac_tx_avail(priv)) {\n\t\tnetif_stop_queue(ndev);\n\t\t/* Refresh tx_dirty */\n\t\tsmp_mb();\n\t\tif (arc_emac_tx_avail(priv))\n\t\t\tnetif_start_queue(ndev);\n\t}\n\n\tarc_reg_set(priv, R_STATUS, TXPL_MASK);\n\n\treturn NETDEV_TX_OK;\n}",
        "code_after_change": "static int arc_emac_tx(struct sk_buff *skb, struct net_device *ndev)\n{\n\tstruct arc_emac_priv *priv = netdev_priv(ndev);\n\tunsigned int len, *txbd_curr = &priv->txbd_curr;\n\tstruct net_device_stats *stats = &ndev->stats;\n\t__le32 *info = &priv->txbd[*txbd_curr].info;\n\tdma_addr_t addr;\n\n\tif (skb_padto(skb, ETH_ZLEN))\n\t\treturn NETDEV_TX_OK;\n\n\tlen = max_t(unsigned int, ETH_ZLEN, skb->len);\n\n\tif (unlikely(!arc_emac_tx_avail(priv))) {\n\t\tnetif_stop_queue(ndev);\n\t\tnetdev_err(ndev, \"BUG! Tx Ring full when queue awake!\\n\");\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\taddr = dma_map_single(&ndev->dev, (void *)skb->data, len,\n\t\t\t      DMA_TO_DEVICE);\n\n\tif (unlikely(dma_mapping_error(&ndev->dev, addr))) {\n\t\tstats->tx_dropped++;\n\t\tstats->tx_errors++;\n\t\tdev_kfree_skb(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\tdma_unmap_addr_set(&priv->tx_buff[*txbd_curr], addr, addr);\n\tdma_unmap_len_set(&priv->tx_buff[*txbd_curr], len, len);\n\n\tpriv->txbd[*txbd_curr].data = cpu_to_le32(addr);\n\n\t/* Make sure pointer to data buffer is set */\n\twmb();\n\n\tskb_tx_timestamp(skb);\n\n\t*info = cpu_to_le32(FOR_EMAC | FIRST_OR_LAST_MASK | len);\n\n\t/* Make sure info word is set */\n\twmb();\n\n\tpriv->tx_buff[*txbd_curr].skb = skb;\n\n\t/* Increment index to point to the next BD */\n\t*txbd_curr = (*txbd_curr + 1) % TX_BD_NUM;\n\n\t/* Ensure that tx_clean() sees the new txbd_curr before\n\t * checking the queue status. This prevents an unneeded wake\n\t * of the queue in tx_clean().\n\t */\n\tsmp_mb();\n\n\tif (!arc_emac_tx_avail(priv)) {\n\t\tnetif_stop_queue(ndev);\n\t\t/* Refresh tx_dirty */\n\t\tsmp_mb();\n\t\tif (arc_emac_tx_avail(priv))\n\t\t\tnetif_start_queue(ndev);\n\t}\n\n\tarc_reg_set(priv, R_STATUS, TXPL_MASK);\n\n\treturn NETDEV_TX_OK;\n}",
        "patch": "--- code before\n+++ code after\n@@ -29,7 +29,6 @@\n \tdma_unmap_addr_set(&priv->tx_buff[*txbd_curr], addr, addr);\n \tdma_unmap_len_set(&priv->tx_buff[*txbd_curr], len, len);\n \n-\tpriv->tx_buff[*txbd_curr].skb = skb;\n \tpriv->txbd[*txbd_curr].data = cpu_to_le32(addr);\n \n \t/* Make sure pointer to data buffer is set */\n@@ -38,6 +37,11 @@\n \tskb_tx_timestamp(skb);\n \n \t*info = cpu_to_le32(FOR_EMAC | FIRST_OR_LAST_MASK | len);\n+\n+\t/* Make sure info word is set */\n+\twmb();\n+\n+\tpriv->tx_buff[*txbd_curr].skb = skb;\n \n \t/* Increment index to point to the next BD */\n \t*txbd_curr = (*txbd_curr + 1) % TX_BD_NUM;",
        "function_modified_lines": {
            "added": [
                "",
                "\t/* Make sure info word is set */",
                "\twmb();",
                "",
                "\tpriv->tx_buff[*txbd_curr].skb = skb;"
            ],
            "deleted": [
                "\tpriv->tx_buff[*txbd_curr].skb = skb;"
            ]
        },
        "cwe": [
            "CWE-362",
            "CWE-416"
        ],
        "cve_description": "An issue was discovered in drivers/net/ethernet/arc/emac_main.c in the Linux kernel before 4.5. A use-after-free is caused by a race condition between the functions arc_emac_tx and arc_emac_tx_clean.",
        "id": 909
    },
    {
        "cve_id": "CVE-2022-20567",
        "code_before_change": "static void pppol2tp_session_close(struct l2tp_session *session)\n{\n}",
        "code_after_change": "static void pppol2tp_session_close(struct l2tp_session *session)\n{\n\tstruct pppol2tp_session *ps;\n\n\tps = l2tp_session_priv(session);\n\tmutex_lock(&ps->sk_lock);\n\tps->__sk = rcu_dereference_protected(ps->sk,\n\t\t\t\t\t     lockdep_is_held(&ps->sk_lock));\n\tRCU_INIT_POINTER(ps->sk, NULL);\n\tif (ps->__sk)\n\t\tcall_rcu(&ps->rcu, pppol2tp_put_sk);\n\tmutex_unlock(&ps->sk_lock);\n}",
        "patch": "--- code before\n+++ code after\n@@ -1,3 +1,13 @@\n static void pppol2tp_session_close(struct l2tp_session *session)\n {\n+\tstruct pppol2tp_session *ps;\n+\n+\tps = l2tp_session_priv(session);\n+\tmutex_lock(&ps->sk_lock);\n+\tps->__sk = rcu_dereference_protected(ps->sk,\n+\t\t\t\t\t     lockdep_is_held(&ps->sk_lock));\n+\tRCU_INIT_POINTER(ps->sk, NULL);\n+\tif (ps->__sk)\n+\t\tcall_rcu(&ps->rcu, pppol2tp_put_sk);\n+\tmutex_unlock(&ps->sk_lock);\n }",
        "function_modified_lines": {
            "added": [
                "\tstruct pppol2tp_session *ps;",
                "",
                "\tps = l2tp_session_priv(session);",
                "\tmutex_lock(&ps->sk_lock);",
                "\tps->__sk = rcu_dereference_protected(ps->sk,",
                "\t\t\t\t\t     lockdep_is_held(&ps->sk_lock));",
                "\tRCU_INIT_POINTER(ps->sk, NULL);",
                "\tif (ps->__sk)",
                "\t\tcall_rcu(&ps->rcu, pppol2tp_put_sk);",
                "\tmutex_unlock(&ps->sk_lock);"
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "In pppol2tp_create of l2tp_ppp.c, there is a possible use after free due to a race condition. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-186777253References: Upstream kernel",
        "id": 3397
    },
    {
        "cve_id": "CVE-2018-5814",
        "code_before_change": "static void stub_disconnect(struct usb_device *udev)\n{\n\tstruct stub_device *sdev;\n\tconst char *udev_busid = dev_name(&udev->dev);\n\tstruct bus_id_priv *busid_priv;\n\tint rc;\n\n\tdev_dbg(&udev->dev, \"Enter disconnect\\n\");\n\n\tbusid_priv = get_busid_priv(udev_busid);\n\tif (!busid_priv) {\n\t\tBUG();\n\t\treturn;\n\t}\n\n\tsdev = dev_get_drvdata(&udev->dev);\n\n\t/* get stub_device */\n\tif (!sdev) {\n\t\tdev_err(&udev->dev, \"could not get device\");\n\t\treturn;\n\t}\n\n\tdev_set_drvdata(&udev->dev, NULL);\n\n\t/*\n\t * NOTE: rx/tx threads are invoked for each usb_device.\n\t */\n\tstub_remove_files(&udev->dev);\n\n\t/* release port */\n\trc = usb_hub_release_port(udev->parent, udev->portnum,\n\t\t\t\t  (struct usb_dev_state *) udev);\n\tif (rc) {\n\t\tdev_dbg(&udev->dev, \"unable to release port\\n\");\n\t\treturn;\n\t}\n\n\t/* If usb reset is called from event handler */\n\tif (usbip_in_eh(current))\n\t\treturn;\n\n\t/* shutdown the current connection */\n\tshutdown_busid(busid_priv);\n\n\tusb_put_dev(sdev->udev);\n\n\t/* free sdev */\n\tbusid_priv->sdev = NULL;\n\tstub_device_free(sdev);\n\n\tif (busid_priv->status == STUB_BUSID_ALLOC)\n\t\tbusid_priv->status = STUB_BUSID_ADDED;\n}",
        "code_after_change": "static void stub_disconnect(struct usb_device *udev)\n{\n\tstruct stub_device *sdev;\n\tconst char *udev_busid = dev_name(&udev->dev);\n\tstruct bus_id_priv *busid_priv;\n\tint rc;\n\n\tdev_dbg(&udev->dev, \"Enter disconnect\\n\");\n\n\tbusid_priv = get_busid_priv(udev_busid);\n\tif (!busid_priv) {\n\t\tBUG();\n\t\treturn;\n\t}\n\n\tsdev = dev_get_drvdata(&udev->dev);\n\n\t/* get stub_device */\n\tif (!sdev) {\n\t\tdev_err(&udev->dev, \"could not get device\");\n\t\tgoto call_put_busid_priv;\n\t}\n\n\tdev_set_drvdata(&udev->dev, NULL);\n\n\t/*\n\t * NOTE: rx/tx threads are invoked for each usb_device.\n\t */\n\tstub_remove_files(&udev->dev);\n\n\t/* release port */\n\trc = usb_hub_release_port(udev->parent, udev->portnum,\n\t\t\t\t  (struct usb_dev_state *) udev);\n\tif (rc) {\n\t\tdev_dbg(&udev->dev, \"unable to release port\\n\");\n\t\tgoto call_put_busid_priv;\n\t}\n\n\t/* If usb reset is called from event handler */\n\tif (usbip_in_eh(current))\n\t\tgoto call_put_busid_priv;\n\n\t/* shutdown the current connection */\n\tshutdown_busid(busid_priv);\n\n\tusb_put_dev(sdev->udev);\n\n\t/* free sdev */\n\tbusid_priv->sdev = NULL;\n\tstub_device_free(sdev);\n\n\tif (busid_priv->status == STUB_BUSID_ALLOC)\n\t\tbusid_priv->status = STUB_BUSID_ADDED;\n\ncall_put_busid_priv:\n\tput_busid_priv(busid_priv);\n}",
        "patch": "--- code before\n+++ code after\n@@ -18,7 +18,7 @@\n \t/* get stub_device */\n \tif (!sdev) {\n \t\tdev_err(&udev->dev, \"could not get device\");\n-\t\treturn;\n+\t\tgoto call_put_busid_priv;\n \t}\n \n \tdev_set_drvdata(&udev->dev, NULL);\n@@ -33,12 +33,12 @@\n \t\t\t\t  (struct usb_dev_state *) udev);\n \tif (rc) {\n \t\tdev_dbg(&udev->dev, \"unable to release port\\n\");\n-\t\treturn;\n+\t\tgoto call_put_busid_priv;\n \t}\n \n \t/* If usb reset is called from event handler */\n \tif (usbip_in_eh(current))\n-\t\treturn;\n+\t\tgoto call_put_busid_priv;\n \n \t/* shutdown the current connection */\n \tshutdown_busid(busid_priv);\n@@ -51,4 +51,7 @@\n \n \tif (busid_priv->status == STUB_BUSID_ALLOC)\n \t\tbusid_priv->status = STUB_BUSID_ADDED;\n+\n+call_put_busid_priv:\n+\tput_busid_priv(busid_priv);\n }",
        "function_modified_lines": {
            "added": [
                "\t\tgoto call_put_busid_priv;",
                "\t\tgoto call_put_busid_priv;",
                "\t\tgoto call_put_busid_priv;",
                "",
                "call_put_busid_priv:",
                "\tput_busid_priv(busid_priv);"
            ],
            "deleted": [
                "\t\treturn;",
                "\t\treturn;",
                "\t\treturn;"
            ]
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "In the Linux Kernel before version 4.16.11, 4.14.43, 4.9.102, and 4.4.133, multiple race condition errors when handling probe, disconnect, and rebind operations can be exploited to trigger a use-after-free condition or a NULL pointer dereference by sending multiple USB over IP packets.",
        "id": 1830
    },
    {
        "cve_id": "CVE-2018-5814",
        "code_before_change": "static int add_match_busid(char *busid)\n{\n\tint i;\n\tint ret = -1;\n\n\tspin_lock(&busid_table_lock);\n\t/* already registered? */\n\tif (get_busid_idx(busid) >= 0) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < MAX_BUSID; i++)\n\t\tif (!busid_table[i].name[0]) {\n\t\t\tstrlcpy(busid_table[i].name, busid, BUSID_SIZE);\n\t\t\tif ((busid_table[i].status != STUB_BUSID_ALLOC) &&\n\t\t\t    (busid_table[i].status != STUB_BUSID_REMOV))\n\t\t\t\tbusid_table[i].status = STUB_BUSID_ADDED;\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\nout:\n\tspin_unlock(&busid_table_lock);\n\n\treturn ret;\n}",
        "code_after_change": "static int add_match_busid(char *busid)\n{\n\tint i;\n\tint ret = -1;\n\n\tspin_lock(&busid_table_lock);\n\t/* already registered? */\n\tif (get_busid_idx(busid) >= 0) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < MAX_BUSID; i++) {\n\t\tspin_lock(&busid_table[i].busid_lock);\n\t\tif (!busid_table[i].name[0]) {\n\t\t\tstrlcpy(busid_table[i].name, busid, BUSID_SIZE);\n\t\t\tif ((busid_table[i].status != STUB_BUSID_ALLOC) &&\n\t\t\t    (busid_table[i].status != STUB_BUSID_REMOV))\n\t\t\t\tbusid_table[i].status = STUB_BUSID_ADDED;\n\t\t\tret = 0;\n\t\t\tspin_unlock(&busid_table[i].busid_lock);\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&busid_table[i].busid_lock);\n\t}\n\nout:\n\tspin_unlock(&busid_table_lock);\n\n\treturn ret;\n}",
        "patch": "--- code before\n+++ code after\n@@ -10,15 +10,19 @@\n \t\tgoto out;\n \t}\n \n-\tfor (i = 0; i < MAX_BUSID; i++)\n+\tfor (i = 0; i < MAX_BUSID; i++) {\n+\t\tspin_lock(&busid_table[i].busid_lock);\n \t\tif (!busid_table[i].name[0]) {\n \t\t\tstrlcpy(busid_table[i].name, busid, BUSID_SIZE);\n \t\t\tif ((busid_table[i].status != STUB_BUSID_ALLOC) &&\n \t\t\t    (busid_table[i].status != STUB_BUSID_REMOV))\n \t\t\t\tbusid_table[i].status = STUB_BUSID_ADDED;\n \t\t\tret = 0;\n+\t\t\tspin_unlock(&busid_table[i].busid_lock);\n \t\t\tbreak;\n \t\t}\n+\t\tspin_unlock(&busid_table[i].busid_lock);\n+\t}\n \n out:\n \tspin_unlock(&busid_table_lock);",
        "function_modified_lines": {
            "added": [
                "\tfor (i = 0; i < MAX_BUSID; i++) {",
                "\t\tspin_lock(&busid_table[i].busid_lock);",
                "\t\t\tspin_unlock(&busid_table[i].busid_lock);",
                "\t\tspin_unlock(&busid_table[i].busid_lock);",
                "\t}"
            ],
            "deleted": [
                "\tfor (i = 0; i < MAX_BUSID; i++)"
            ]
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "In the Linux Kernel before version 4.16.11, 4.14.43, 4.9.102, and 4.4.133, multiple race condition errors when handling probe, disconnect, and rebind operations can be exploited to trigger a use-after-free condition or a NULL pointer dereference by sending multiple USB over IP packets.",
        "id": 1837
    },
    {
        "cve_id": "CVE-2017-1000112",
        "code_before_change": "static int udp_send_skb(struct sk_buff *skb, struct flowi4 *fl4)\n{\n\tstruct sock *sk = skb->sk;\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct udphdr *uh;\n\tint err = 0;\n\tint is_udplite = IS_UDPLITE(sk);\n\tint offset = skb_transport_offset(skb);\n\tint len = skb->len - offset;\n\t__wsum csum = 0;\n\n\t/*\n\t * Create a UDP header\n\t */\n\tuh = udp_hdr(skb);\n\tuh->source = inet->inet_sport;\n\tuh->dest = fl4->fl4_dport;\n\tuh->len = htons(len);\n\tuh->check = 0;\n\n\tif (is_udplite)  \t\t\t\t /*     UDP-Lite      */\n\t\tcsum = udplite_csum(skb);\n\n\telse if (sk->sk_no_check_tx) {   /* UDP csum disabled */\n\n\t\tskb->ip_summed = CHECKSUM_NONE;\n\t\tgoto send;\n\n\t} else if (skb->ip_summed == CHECKSUM_PARTIAL) { /* UDP hardware csum */\n\n\t\tudp4_hwcsum(skb, fl4->saddr, fl4->daddr);\n\t\tgoto send;\n\n\t} else\n\t\tcsum = udp_csum(skb);\n\n\t/* add protocol-dependent pseudo-header */\n\tuh->check = csum_tcpudp_magic(fl4->saddr, fl4->daddr, len,\n\t\t\t\t      sk->sk_protocol, csum);\n\tif (uh->check == 0)\n\t\tuh->check = CSUM_MANGLED_0;\n\nsend:\n\terr = ip_send_skb(sock_net(sk), skb);\n\tif (err) {\n\t\tif (err == -ENOBUFS && !inet->recverr) {\n\t\t\tUDP_INC_STATS(sock_net(sk),\n\t\t\t\t      UDP_MIB_SNDBUFERRORS, is_udplite);\n\t\t\terr = 0;\n\t\t}\n\t} else\n\t\tUDP_INC_STATS(sock_net(sk),\n\t\t\t      UDP_MIB_OUTDATAGRAMS, is_udplite);\n\treturn err;\n}",
        "code_after_change": "static int udp_send_skb(struct sk_buff *skb, struct flowi4 *fl4)\n{\n\tstruct sock *sk = skb->sk;\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct udphdr *uh;\n\tint err = 0;\n\tint is_udplite = IS_UDPLITE(sk);\n\tint offset = skb_transport_offset(skb);\n\tint len = skb->len - offset;\n\t__wsum csum = 0;\n\n\t/*\n\t * Create a UDP header\n\t */\n\tuh = udp_hdr(skb);\n\tuh->source = inet->inet_sport;\n\tuh->dest = fl4->fl4_dport;\n\tuh->len = htons(len);\n\tuh->check = 0;\n\n\tif (is_udplite)  \t\t\t\t /*     UDP-Lite      */\n\t\tcsum = udplite_csum(skb);\n\n\telse if (sk->sk_no_check_tx && !skb_is_gso(skb)) {   /* UDP csum off */\n\n\t\tskb->ip_summed = CHECKSUM_NONE;\n\t\tgoto send;\n\n\t} else if (skb->ip_summed == CHECKSUM_PARTIAL) { /* UDP hardware csum */\n\n\t\tudp4_hwcsum(skb, fl4->saddr, fl4->daddr);\n\t\tgoto send;\n\n\t} else\n\t\tcsum = udp_csum(skb);\n\n\t/* add protocol-dependent pseudo-header */\n\tuh->check = csum_tcpudp_magic(fl4->saddr, fl4->daddr, len,\n\t\t\t\t      sk->sk_protocol, csum);\n\tif (uh->check == 0)\n\t\tuh->check = CSUM_MANGLED_0;\n\nsend:\n\terr = ip_send_skb(sock_net(sk), skb);\n\tif (err) {\n\t\tif (err == -ENOBUFS && !inet->recverr) {\n\t\t\tUDP_INC_STATS(sock_net(sk),\n\t\t\t\t      UDP_MIB_SNDBUFERRORS, is_udplite);\n\t\t\terr = 0;\n\t\t}\n\t} else\n\t\tUDP_INC_STATS(sock_net(sk),\n\t\t\t      UDP_MIB_OUTDATAGRAMS, is_udplite);\n\treturn err;\n}",
        "patch": "--- code before\n+++ code after\n@@ -21,7 +21,7 @@\n \tif (is_udplite)  \t\t\t\t /*     UDP-Lite      */\n \t\tcsum = udplite_csum(skb);\n \n-\telse if (sk->sk_no_check_tx) {   /* UDP csum disabled */\n+\telse if (sk->sk_no_check_tx && !skb_is_gso(skb)) {   /* UDP csum off */\n \n \t\tskb->ip_summed = CHECKSUM_NONE;\n \t\tgoto send;",
        "function_modified_lines": {
            "added": [
                "\telse if (sk->sk_no_check_tx && !skb_is_gso(skb)) {   /* UDP csum off */"
            ],
            "deleted": [
                "\telse if (sk->sk_no_check_tx) {   /* UDP csum disabled */"
            ]
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "Linux kernel: Exploitable memory corruption due to UFO to non-UFO path switch. When building a UFO packet with MSG_MORE __ip_append_data() calls ip_ufo_append_data() to append. However in between two send() calls, the append path can be switched from UFO to non-UFO one, which leads to a memory corruption. In case UFO packet lengths exceeds MTU, copy = maxfraglen - skb->len becomes negative on the non-UFO path and the branch to allocate new skb is taken. This triggers fragmentation and computation of fraggap = skb_prev->len - maxfraglen. Fraggap can exceed MTU, causing copy = datalen - transhdrlen - fraggap to become negative. Subsequently skb_copy_and_csum_bits() writes out-of-bounds. A similar issue is present in IPv6 code. The bug was introduced in e89e9cf539a2 (\"[IPv4/IPv6]: UFO Scatter-gather approach\") on Oct 18 2005.",
        "id": 1183
    },
    {
        "cve_id": "CVE-2023-2006",
        "code_before_change": "static struct rxrpc_bundle *rxrpc_look_up_bundle(struct rxrpc_conn_parameters *cp,\n\t\t\t\t\t\t gfp_t gfp)\n{\n\tstatic atomic_t rxrpc_bundle_id;\n\tstruct rxrpc_bundle *bundle, *candidate;\n\tstruct rxrpc_local *local = cp->local;\n\tstruct rb_node *p, **pp, *parent;\n\tlong diff;\n\n\t_enter(\"{%px,%x,%u,%u}\",\n\t       cp->peer, key_serial(cp->key), cp->security_level, cp->upgrade);\n\n\tif (cp->exclusive)\n\t\treturn rxrpc_alloc_bundle(cp, gfp);\n\n\t/* First, see if the bundle is already there. */\n\t_debug(\"search 1\");\n\tspin_lock(&local->client_bundles_lock);\n\tp = local->client_bundles.rb_node;\n\twhile (p) {\n\t\tbundle = rb_entry(p, struct rxrpc_bundle, local_node);\n\n#define cmp(X) ((long)bundle->params.X - (long)cp->X)\n\t\tdiff = (cmp(peer) ?:\n\t\t\tcmp(key) ?:\n\t\t\tcmp(security_level) ?:\n\t\t\tcmp(upgrade));\n#undef cmp\n\t\tif (diff < 0)\n\t\t\tp = p->rb_left;\n\t\telse if (diff > 0)\n\t\t\tp = p->rb_right;\n\t\telse\n\t\t\tgoto found_bundle;\n\t}\n\tspin_unlock(&local->client_bundles_lock);\n\t_debug(\"not found\");\n\n\t/* It wasn't.  We need to add one. */\n\tcandidate = rxrpc_alloc_bundle(cp, gfp);\n\tif (!candidate)\n\t\treturn NULL;\n\n\t_debug(\"search 2\");\n\tspin_lock(&local->client_bundles_lock);\n\tpp = &local->client_bundles.rb_node;\n\tparent = NULL;\n\twhile (*pp) {\n\t\tparent = *pp;\n\t\tbundle = rb_entry(parent, struct rxrpc_bundle, local_node);\n\n#define cmp(X) ((long)bundle->params.X - (long)cp->X)\n\t\tdiff = (cmp(peer) ?:\n\t\t\tcmp(key) ?:\n\t\t\tcmp(security_level) ?:\n\t\t\tcmp(upgrade));\n#undef cmp\n\t\tif (diff < 0)\n\t\t\tpp = &(*pp)->rb_left;\n\t\telse if (diff > 0)\n\t\t\tpp = &(*pp)->rb_right;\n\t\telse\n\t\t\tgoto found_bundle_free;\n\t}\n\n\t_debug(\"new bundle\");\n\tcandidate->debug_id = atomic_inc_return(&rxrpc_bundle_id);\n\trb_link_node(&candidate->local_node, parent, pp);\n\trb_insert_color(&candidate->local_node, &local->client_bundles);\n\trxrpc_get_bundle(candidate);\n\tspin_unlock(&local->client_bundles_lock);\n\t_leave(\" = %u [new]\", candidate->debug_id);\n\treturn candidate;\n\nfound_bundle_free:\n\trxrpc_free_bundle(candidate);\nfound_bundle:\n\trxrpc_get_bundle(bundle);\n\tspin_unlock(&local->client_bundles_lock);\n\t_leave(\" = %u [found]\", bundle->debug_id);\n\treturn bundle;\n}",
        "code_after_change": "static struct rxrpc_bundle *rxrpc_look_up_bundle(struct rxrpc_conn_parameters *cp,\n\t\t\t\t\t\t gfp_t gfp)\n{\n\tstatic atomic_t rxrpc_bundle_id;\n\tstruct rxrpc_bundle *bundle, *candidate;\n\tstruct rxrpc_local *local = cp->local;\n\tstruct rb_node *p, **pp, *parent;\n\tlong diff;\n\n\t_enter(\"{%px,%x,%u,%u}\",\n\t       cp->peer, key_serial(cp->key), cp->security_level, cp->upgrade);\n\n\tif (cp->exclusive)\n\t\treturn rxrpc_alloc_bundle(cp, gfp);\n\n\t/* First, see if the bundle is already there. */\n\t_debug(\"search 1\");\n\tspin_lock(&local->client_bundles_lock);\n\tp = local->client_bundles.rb_node;\n\twhile (p) {\n\t\tbundle = rb_entry(p, struct rxrpc_bundle, local_node);\n\n#define cmp(X) ((long)bundle->params.X - (long)cp->X)\n\t\tdiff = (cmp(peer) ?:\n\t\t\tcmp(key) ?:\n\t\t\tcmp(security_level) ?:\n\t\t\tcmp(upgrade));\n#undef cmp\n\t\tif (diff < 0)\n\t\t\tp = p->rb_left;\n\t\telse if (diff > 0)\n\t\t\tp = p->rb_right;\n\t\telse\n\t\t\tgoto found_bundle;\n\t}\n\tspin_unlock(&local->client_bundles_lock);\n\t_debug(\"not found\");\n\n\t/* It wasn't.  We need to add one. */\n\tcandidate = rxrpc_alloc_bundle(cp, gfp);\n\tif (!candidate)\n\t\treturn NULL;\n\n\t_debug(\"search 2\");\n\tspin_lock(&local->client_bundles_lock);\n\tpp = &local->client_bundles.rb_node;\n\tparent = NULL;\n\twhile (*pp) {\n\t\tparent = *pp;\n\t\tbundle = rb_entry(parent, struct rxrpc_bundle, local_node);\n\n#define cmp(X) ((long)bundle->params.X - (long)cp->X)\n\t\tdiff = (cmp(peer) ?:\n\t\t\tcmp(key) ?:\n\t\t\tcmp(security_level) ?:\n\t\t\tcmp(upgrade));\n#undef cmp\n\t\tif (diff < 0)\n\t\t\tpp = &(*pp)->rb_left;\n\t\telse if (diff > 0)\n\t\t\tpp = &(*pp)->rb_right;\n\t\telse\n\t\t\tgoto found_bundle_free;\n\t}\n\n\t_debug(\"new bundle\");\n\tcandidate->debug_id = atomic_inc_return(&rxrpc_bundle_id);\n\trb_link_node(&candidate->local_node, parent, pp);\n\trb_insert_color(&candidate->local_node, &local->client_bundles);\n\trxrpc_get_bundle(candidate);\n\tspin_unlock(&local->client_bundles_lock);\n\t_leave(\" = %u [new]\", candidate->debug_id);\n\treturn candidate;\n\nfound_bundle_free:\n\trxrpc_free_bundle(candidate);\nfound_bundle:\n\trxrpc_get_bundle(bundle);\n\tatomic_inc(&bundle->active);\n\tspin_unlock(&local->client_bundles_lock);\n\t_leave(\" = %u [found]\", bundle->debug_id);\n\treturn bundle;\n}",
        "patch": "--- code before\n+++ code after\n@@ -76,6 +76,7 @@\n \trxrpc_free_bundle(candidate);\n found_bundle:\n \trxrpc_get_bundle(bundle);\n+\tatomic_inc(&bundle->active);\n \tspin_unlock(&local->client_bundles_lock);\n \t_leave(\" = %u [found]\", bundle->debug_id);\n \treturn bundle;",
        "function_modified_lines": {
            "added": [
                "\tatomic_inc(&bundle->active);"
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "A race condition was found in the Linux kernel's RxRPC network protocol, within the processing of RxRPC bundles. This issue results from the lack of proper locking when performing operations on an object. This may allow an attacker to escalate privileges and execute arbitrary code in the context of the kernel.",
        "id": 3897
    },
    {
        "cve_id": "CVE-2015-8839",
        "code_before_change": "int ext4_punch_hole(struct inode *inode, loff_t offset, loff_t length)\n{\n\tstruct super_block *sb = inode->i_sb;\n\text4_lblk_t first_block, stop_block;\n\tstruct address_space *mapping = inode->i_mapping;\n\tloff_t first_block_offset, last_block_offset;\n\thandle_t *handle;\n\tunsigned int credits;\n\tint ret = 0;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\n\ttrace_ext4_punch_hole(inode, offset, length, 0);\n\n\t/*\n\t * Write out all dirty pages to avoid race conditions\n\t * Then release them.\n\t */\n\tif (mapping->nrpages && mapping_tagged(mapping, PAGECACHE_TAG_DIRTY)) {\n\t\tret = filemap_write_and_wait_range(mapping, offset,\n\t\t\t\t\t\t   offset + length - 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tmutex_lock(&inode->i_mutex);\n\n\t/* No need to punch hole beyond i_size */\n\tif (offset >= inode->i_size)\n\t\tgoto out_mutex;\n\n\t/*\n\t * If the hole extends beyond i_size, set the hole\n\t * to end after the page that contains i_size\n\t */\n\tif (offset + length > inode->i_size) {\n\t\tlength = inode->i_size +\n\t\t   PAGE_CACHE_SIZE - (inode->i_size & (PAGE_CACHE_SIZE - 1)) -\n\t\t   offset;\n\t}\n\n\tif (offset & (sb->s_blocksize - 1) ||\n\t    (offset + length) & (sb->s_blocksize - 1)) {\n\t\t/*\n\t\t * Attach jinode to inode for jbd2 if we do any zeroing of\n\t\t * partial block\n\t\t */\n\t\tret = ext4_inode_attach_jinode(inode);\n\t\tif (ret < 0)\n\t\t\tgoto out_mutex;\n\n\t}\n\n\tfirst_block_offset = round_up(offset, sb->s_blocksize);\n\tlast_block_offset = round_down((offset + length), sb->s_blocksize) - 1;\n\n\t/* Now release the pages and zero block aligned part of pages*/\n\tif (last_block_offset > first_block_offset)\n\t\ttruncate_pagecache_range(inode, first_block_offset,\n\t\t\t\t\t last_block_offset);\n\n\t/* Wait all existing dio workers, newcomers will block on i_mutex */\n\text4_inode_block_unlocked_dio(inode);\n\tinode_dio_wait(inode);\n\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\tcredits = ext4_writepage_trans_blocks(inode);\n\telse\n\t\tcredits = ext4_blocks_for_truncate(inode);\n\thandle = ext4_journal_start(inode, EXT4_HT_TRUNCATE, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\text4_std_error(sb, ret);\n\t\tgoto out_dio;\n\t}\n\n\tret = ext4_zero_partial_blocks(handle, inode, offset,\n\t\t\t\t       length);\n\tif (ret)\n\t\tgoto out_stop;\n\n\tfirst_block = (offset + sb->s_blocksize - 1) >>\n\t\tEXT4_BLOCK_SIZE_BITS(sb);\n\tstop_block = (offset + length) >> EXT4_BLOCK_SIZE_BITS(sb);\n\n\t/* If there are no blocks to remove, return now */\n\tif (first_block >= stop_block)\n\t\tgoto out_stop;\n\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\text4_discard_preallocations(inode);\n\n\tret = ext4_es_remove_extent(inode, first_block,\n\t\t\t\t    stop_block - first_block);\n\tif (ret) {\n\t\tup_write(&EXT4_I(inode)->i_data_sem);\n\t\tgoto out_stop;\n\t}\n\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\tret = ext4_ext_remove_space(inode, first_block,\n\t\t\t\t\t    stop_block - 1);\n\telse\n\t\tret = ext4_ind_remove_space(handle, inode, first_block,\n\t\t\t\t\t    stop_block);\n\n\tup_write(&EXT4_I(inode)->i_data_sem);\n\tif (IS_SYNC(inode))\n\t\text4_handle_sync(handle);\n\n\t/* Now release the pages again to reduce race window */\n\tif (last_block_offset > first_block_offset)\n\t\ttruncate_pagecache_range(inode, first_block_offset,\n\t\t\t\t\t last_block_offset);\n\n\tinode->i_mtime = inode->i_ctime = ext4_current_time(inode);\n\text4_mark_inode_dirty(handle, inode);\nout_stop:\n\text4_journal_stop(handle);\nout_dio:\n\text4_inode_resume_unlocked_dio(inode);\nout_mutex:\n\tmutex_unlock(&inode->i_mutex);\n\treturn ret;\n}",
        "code_after_change": "int ext4_punch_hole(struct inode *inode, loff_t offset, loff_t length)\n{\n\tstruct super_block *sb = inode->i_sb;\n\text4_lblk_t first_block, stop_block;\n\tstruct address_space *mapping = inode->i_mapping;\n\tloff_t first_block_offset, last_block_offset;\n\thandle_t *handle;\n\tunsigned int credits;\n\tint ret = 0;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\n\ttrace_ext4_punch_hole(inode, offset, length, 0);\n\n\t/*\n\t * Write out all dirty pages to avoid race conditions\n\t * Then release them.\n\t */\n\tif (mapping->nrpages && mapping_tagged(mapping, PAGECACHE_TAG_DIRTY)) {\n\t\tret = filemap_write_and_wait_range(mapping, offset,\n\t\t\t\t\t\t   offset + length - 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tmutex_lock(&inode->i_mutex);\n\n\t/* No need to punch hole beyond i_size */\n\tif (offset >= inode->i_size)\n\t\tgoto out_mutex;\n\n\t/*\n\t * If the hole extends beyond i_size, set the hole\n\t * to end after the page that contains i_size\n\t */\n\tif (offset + length > inode->i_size) {\n\t\tlength = inode->i_size +\n\t\t   PAGE_CACHE_SIZE - (inode->i_size & (PAGE_CACHE_SIZE - 1)) -\n\t\t   offset;\n\t}\n\n\tif (offset & (sb->s_blocksize - 1) ||\n\t    (offset + length) & (sb->s_blocksize - 1)) {\n\t\t/*\n\t\t * Attach jinode to inode for jbd2 if we do any zeroing of\n\t\t * partial block\n\t\t */\n\t\tret = ext4_inode_attach_jinode(inode);\n\t\tif (ret < 0)\n\t\t\tgoto out_mutex;\n\n\t}\n\n\t/* Wait all existing dio workers, newcomers will block on i_mutex */\n\text4_inode_block_unlocked_dio(inode);\n\tinode_dio_wait(inode);\n\n\t/*\n\t * Prevent page faults from reinstantiating pages we have released from\n\t * page cache.\n\t */\n\tdown_write(&EXT4_I(inode)->i_mmap_sem);\n\tfirst_block_offset = round_up(offset, sb->s_blocksize);\n\tlast_block_offset = round_down((offset + length), sb->s_blocksize) - 1;\n\n\t/* Now release the pages and zero block aligned part of pages*/\n\tif (last_block_offset > first_block_offset)\n\t\ttruncate_pagecache_range(inode, first_block_offset,\n\t\t\t\t\t last_block_offset);\n\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\tcredits = ext4_writepage_trans_blocks(inode);\n\telse\n\t\tcredits = ext4_blocks_for_truncate(inode);\n\thandle = ext4_journal_start(inode, EXT4_HT_TRUNCATE, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\text4_std_error(sb, ret);\n\t\tgoto out_dio;\n\t}\n\n\tret = ext4_zero_partial_blocks(handle, inode, offset,\n\t\t\t\t       length);\n\tif (ret)\n\t\tgoto out_stop;\n\n\tfirst_block = (offset + sb->s_blocksize - 1) >>\n\t\tEXT4_BLOCK_SIZE_BITS(sb);\n\tstop_block = (offset + length) >> EXT4_BLOCK_SIZE_BITS(sb);\n\n\t/* If there are no blocks to remove, return now */\n\tif (first_block >= stop_block)\n\t\tgoto out_stop;\n\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\text4_discard_preallocations(inode);\n\n\tret = ext4_es_remove_extent(inode, first_block,\n\t\t\t\t    stop_block - first_block);\n\tif (ret) {\n\t\tup_write(&EXT4_I(inode)->i_data_sem);\n\t\tgoto out_stop;\n\t}\n\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\tret = ext4_ext_remove_space(inode, first_block,\n\t\t\t\t\t    stop_block - 1);\n\telse\n\t\tret = ext4_ind_remove_space(handle, inode, first_block,\n\t\t\t\t\t    stop_block);\n\n\tup_write(&EXT4_I(inode)->i_data_sem);\n\tif (IS_SYNC(inode))\n\t\text4_handle_sync(handle);\n\n\tinode->i_mtime = inode->i_ctime = ext4_current_time(inode);\n\text4_mark_inode_dirty(handle, inode);\nout_stop:\n\text4_journal_stop(handle);\nout_dio:\n\tup_write(&EXT4_I(inode)->i_mmap_sem);\n\text4_inode_resume_unlocked_dio(inode);\nout_mutex:\n\tmutex_unlock(&inode->i_mutex);\n\treturn ret;\n}",
        "patch": "--- code before\n+++ code after\n@@ -52,6 +52,15 @@\n \n \t}\n \n+\t/* Wait all existing dio workers, newcomers will block on i_mutex */\n+\text4_inode_block_unlocked_dio(inode);\n+\tinode_dio_wait(inode);\n+\n+\t/*\n+\t * Prevent page faults from reinstantiating pages we have released from\n+\t * page cache.\n+\t */\n+\tdown_write(&EXT4_I(inode)->i_mmap_sem);\n \tfirst_block_offset = round_up(offset, sb->s_blocksize);\n \tlast_block_offset = round_down((offset + length), sb->s_blocksize) - 1;\n \n@@ -59,10 +68,6 @@\n \tif (last_block_offset > first_block_offset)\n \t\ttruncate_pagecache_range(inode, first_block_offset,\n \t\t\t\t\t last_block_offset);\n-\n-\t/* Wait all existing dio workers, newcomers will block on i_mutex */\n-\text4_inode_block_unlocked_dio(inode);\n-\tinode_dio_wait(inode);\n \n \tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n \t\tcredits = ext4_writepage_trans_blocks(inode);\n@@ -109,16 +114,12 @@\n \tif (IS_SYNC(inode))\n \t\text4_handle_sync(handle);\n \n-\t/* Now release the pages again to reduce race window */\n-\tif (last_block_offset > first_block_offset)\n-\t\ttruncate_pagecache_range(inode, first_block_offset,\n-\t\t\t\t\t last_block_offset);\n-\n \tinode->i_mtime = inode->i_ctime = ext4_current_time(inode);\n \text4_mark_inode_dirty(handle, inode);\n out_stop:\n \text4_journal_stop(handle);\n out_dio:\n+\tup_write(&EXT4_I(inode)->i_mmap_sem);\n \text4_inode_resume_unlocked_dio(inode);\n out_mutex:\n \tmutex_unlock(&inode->i_mutex);",
        "function_modified_lines": {
            "added": [
                "\t/* Wait all existing dio workers, newcomers will block on i_mutex */",
                "\text4_inode_block_unlocked_dio(inode);",
                "\tinode_dio_wait(inode);",
                "",
                "\t/*",
                "\t * Prevent page faults from reinstantiating pages we have released from",
                "\t * page cache.",
                "\t */",
                "\tdown_write(&EXT4_I(inode)->i_mmap_sem);",
                "\tup_write(&EXT4_I(inode)->i_mmap_sem);"
            ],
            "deleted": [
                "",
                "\t/* Wait all existing dio workers, newcomers will block on i_mutex */",
                "\text4_inode_block_unlocked_dio(inode);",
                "\tinode_dio_wait(inode);",
                "\t/* Now release the pages again to reduce race window */",
                "\tif (last_block_offset > first_block_offset)",
                "\t\ttruncate_pagecache_range(inode, first_block_offset,",
                "\t\t\t\t\t last_block_offset);",
                ""
            ]
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "Multiple race conditions in the ext4 filesystem implementation in the Linux kernel before 4.5 allow local users to cause a denial of service (disk corruption) by writing to a page that is associated with a different user's file after unsynchronized hole punching and page-fault handling.",
        "id": 856
    },
    {
        "cve_id": "CVE-2015-8839",
        "code_before_change": "static inline void ext4_truncate_failed_write(struct inode *inode)\n{\n\ttruncate_inode_pages(inode->i_mapping, inode->i_size);\n\text4_truncate(inode);\n}",
        "code_after_change": "static inline void ext4_truncate_failed_write(struct inode *inode)\n{\n\tdown_write(&EXT4_I(inode)->i_mmap_sem);\n\ttruncate_inode_pages(inode->i_mapping, inode->i_size);\n\text4_truncate(inode);\n\tup_write(&EXT4_I(inode)->i_mmap_sem);\n}",
        "patch": "--- code before\n+++ code after\n@@ -1,5 +1,7 @@\n static inline void ext4_truncate_failed_write(struct inode *inode)\n {\n+\tdown_write(&EXT4_I(inode)->i_mmap_sem);\n \ttruncate_inode_pages(inode->i_mapping, inode->i_size);\n \text4_truncate(inode);\n+\tup_write(&EXT4_I(inode)->i_mmap_sem);\n }",
        "function_modified_lines": {
            "added": [
                "\tdown_write(&EXT4_I(inode)->i_mmap_sem);",
                "\tup_write(&EXT4_I(inode)->i_mmap_sem);"
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "Multiple race conditions in the ext4 filesystem implementation in the Linux kernel before 4.5 allow local users to cause a denial of service (disk corruption) by writing to a page that is associated with a different user's file after unsynchronized hole punching and page-fault handling.",
        "id": 860
    },
    {
        "cve_id": "CVE-2015-8839",
        "code_before_change": "static long ext4_zero_range(struct file *file, loff_t offset,\n\t\t\t    loff_t len, int mode)\n{\n\tstruct inode *inode = file_inode(file);\n\thandle_t *handle = NULL;\n\tunsigned int max_blocks;\n\tloff_t new_size = 0;\n\tint ret = 0;\n\tint flags;\n\tint credits;\n\tint partial_begin, partial_end;\n\tloff_t start, end;\n\text4_lblk_t lblk;\n\tstruct address_space *mapping = inode->i_mapping;\n\tunsigned int blkbits = inode->i_blkbits;\n\n\ttrace_ext4_zero_range(inode, offset, len, mode);\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\n\t/* Call ext4_force_commit to flush all data in case of data=journal. */\n\tif (ext4_should_journal_data(inode)) {\n\t\tret = ext4_force_commit(inode->i_sb);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/*\n\t * Write out all dirty pages to avoid race conditions\n\t * Then release them.\n\t */\n\tif (mapping->nrpages && mapping_tagged(mapping, PAGECACHE_TAG_DIRTY)) {\n\t\tret = filemap_write_and_wait_range(mapping, offset,\n\t\t\t\t\t\t   offset + len - 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/*\n\t * Round up offset. This is not fallocate, we neet to zero out\n\t * blocks, so convert interior block aligned part of the range to\n\t * unwritten and possibly manually zero out unaligned parts of the\n\t * range.\n\t */\n\tstart = round_up(offset, 1 << blkbits);\n\tend = round_down((offset + len), 1 << blkbits);\n\n\tif (start < offset || end > offset + len)\n\t\treturn -EINVAL;\n\tpartial_begin = offset & ((1 << blkbits) - 1);\n\tpartial_end = (offset + len) & ((1 << blkbits) - 1);\n\n\tlblk = start >> blkbits;\n\tmax_blocks = (end >> blkbits);\n\tif (max_blocks < lblk)\n\t\tmax_blocks = 0;\n\telse\n\t\tmax_blocks -= lblk;\n\n\tmutex_lock(&inode->i_mutex);\n\n\t/*\n\t * Indirect files do not support unwritten extnets\n\t */\n\tif (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out_mutex;\n\t}\n\n\tif (!(mode & FALLOC_FL_KEEP_SIZE) &&\n\t     offset + len > i_size_read(inode)) {\n\t\tnew_size = offset + len;\n\t\tret = inode_newsize_ok(inode, new_size);\n\t\tif (ret)\n\t\t\tgoto out_mutex;\n\t}\n\n\tflags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT;\n\tif (mode & FALLOC_FL_KEEP_SIZE)\n\t\tflags |= EXT4_GET_BLOCKS_KEEP_SIZE;\n\n\t/* Preallocate the range including the unaligned edges */\n\tif (partial_begin || partial_end) {\n\t\tret = ext4_alloc_file_blocks(file,\n\t\t\t\tround_down(offset, 1 << blkbits) >> blkbits,\n\t\t\t\t(round_up((offset + len), 1 << blkbits) -\n\t\t\t\t round_down(offset, 1 << blkbits)) >> blkbits,\n\t\t\t\tnew_size, flags, mode);\n\t\tif (ret)\n\t\t\tgoto out_mutex;\n\n\t}\n\n\t/* Zero range excluding the unaligned edges */\n\tif (max_blocks > 0) {\n\t\tflags |= (EXT4_GET_BLOCKS_CONVERT_UNWRITTEN |\n\t\t\t  EXT4_EX_NOCACHE);\n\n\t\t/* Now release the pages and zero block aligned part of pages*/\n\t\ttruncate_pagecache_range(inode, start, end - 1);\n\t\tinode->i_mtime = inode->i_ctime = ext4_current_time(inode);\n\n\t\t/* Wait all existing dio workers, newcomers will block on i_mutex */\n\t\text4_inode_block_unlocked_dio(inode);\n\t\tinode_dio_wait(inode);\n\n\t\tret = ext4_alloc_file_blocks(file, lblk, max_blocks, new_size,\n\t\t\t\t\t     flags, mode);\n\t\tif (ret)\n\t\t\tgoto out_dio;\n\t}\n\tif (!partial_begin && !partial_end)\n\t\tgoto out_dio;\n\n\t/*\n\t * In worst case we have to writeout two nonadjacent unwritten\n\t * blocks and update the inode\n\t */\n\tcredits = (2 * ext4_ext_index_trans_blocks(inode, 2)) + 1;\n\tif (ext4_should_journal_data(inode))\n\t\tcredits += 2;\n\thandle = ext4_journal_start(inode, EXT4_HT_MISC, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\text4_std_error(inode->i_sb, ret);\n\t\tgoto out_dio;\n\t}\n\n\tinode->i_mtime = inode->i_ctime = ext4_current_time(inode);\n\tif (new_size) {\n\t\text4_update_inode_size(inode, new_size);\n\t} else {\n\t\t/*\n\t\t* Mark that we allocate beyond EOF so the subsequent truncate\n\t\t* can proceed even if the new size is the same as i_size.\n\t\t*/\n\t\tif ((offset + len) > i_size_read(inode))\n\t\t\text4_set_inode_flag(inode, EXT4_INODE_EOFBLOCKS);\n\t}\n\text4_mark_inode_dirty(handle, inode);\n\n\t/* Zero out partial block at the edges of the range */\n\tret = ext4_zero_partial_blocks(handle, inode, offset, len);\n\n\tif (file->f_flags & O_SYNC)\n\t\text4_handle_sync(handle);\n\n\text4_journal_stop(handle);\nout_dio:\n\text4_inode_resume_unlocked_dio(inode);\nout_mutex:\n\tmutex_unlock(&inode->i_mutex);\n\treturn ret;\n}",
        "code_after_change": "static long ext4_zero_range(struct file *file, loff_t offset,\n\t\t\t    loff_t len, int mode)\n{\n\tstruct inode *inode = file_inode(file);\n\thandle_t *handle = NULL;\n\tunsigned int max_blocks;\n\tloff_t new_size = 0;\n\tint ret = 0;\n\tint flags;\n\tint credits;\n\tint partial_begin, partial_end;\n\tloff_t start, end;\n\text4_lblk_t lblk;\n\tunsigned int blkbits = inode->i_blkbits;\n\n\ttrace_ext4_zero_range(inode, offset, len, mode);\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\n\t/* Call ext4_force_commit to flush all data in case of data=journal. */\n\tif (ext4_should_journal_data(inode)) {\n\t\tret = ext4_force_commit(inode->i_sb);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/*\n\t * Round up offset. This is not fallocate, we neet to zero out\n\t * blocks, so convert interior block aligned part of the range to\n\t * unwritten and possibly manually zero out unaligned parts of the\n\t * range.\n\t */\n\tstart = round_up(offset, 1 << blkbits);\n\tend = round_down((offset + len), 1 << blkbits);\n\n\tif (start < offset || end > offset + len)\n\t\treturn -EINVAL;\n\tpartial_begin = offset & ((1 << blkbits) - 1);\n\tpartial_end = (offset + len) & ((1 << blkbits) - 1);\n\n\tlblk = start >> blkbits;\n\tmax_blocks = (end >> blkbits);\n\tif (max_blocks < lblk)\n\t\tmax_blocks = 0;\n\telse\n\t\tmax_blocks -= lblk;\n\n\tmutex_lock(&inode->i_mutex);\n\n\t/*\n\t * Indirect files do not support unwritten extnets\n\t */\n\tif (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out_mutex;\n\t}\n\n\tif (!(mode & FALLOC_FL_KEEP_SIZE) &&\n\t     offset + len > i_size_read(inode)) {\n\t\tnew_size = offset + len;\n\t\tret = inode_newsize_ok(inode, new_size);\n\t\tif (ret)\n\t\t\tgoto out_mutex;\n\t}\n\n\tflags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT;\n\tif (mode & FALLOC_FL_KEEP_SIZE)\n\t\tflags |= EXT4_GET_BLOCKS_KEEP_SIZE;\n\n\t/* Preallocate the range including the unaligned edges */\n\tif (partial_begin || partial_end) {\n\t\tret = ext4_alloc_file_blocks(file,\n\t\t\t\tround_down(offset, 1 << blkbits) >> blkbits,\n\t\t\t\t(round_up((offset + len), 1 << blkbits) -\n\t\t\t\t round_down(offset, 1 << blkbits)) >> blkbits,\n\t\t\t\tnew_size, flags, mode);\n\t\tif (ret)\n\t\t\tgoto out_mutex;\n\n\t}\n\n\t/* Zero range excluding the unaligned edges */\n\tif (max_blocks > 0) {\n\t\tflags |= (EXT4_GET_BLOCKS_CONVERT_UNWRITTEN |\n\t\t\t  EXT4_EX_NOCACHE);\n\n\t\t/* Wait all existing dio workers, newcomers will block on i_mutex */\n\t\text4_inode_block_unlocked_dio(inode);\n\t\tinode_dio_wait(inode);\n\n\t\t/*\n\t\t * Prevent page faults from reinstantiating pages we have\n\t\t * released from page cache.\n\t\t */\n\t\tdown_write(&EXT4_I(inode)->i_mmap_sem);\n\t\t/* Now release the pages and zero block aligned part of pages */\n\t\ttruncate_pagecache_range(inode, start, end - 1);\n\t\tinode->i_mtime = inode->i_ctime = ext4_current_time(inode);\n\n\t\tret = ext4_alloc_file_blocks(file, lblk, max_blocks, new_size,\n\t\t\t\t\t     flags, mode);\n\t\tup_write(&EXT4_I(inode)->i_mmap_sem);\n\t\tif (ret)\n\t\t\tgoto out_dio;\n\t}\n\tif (!partial_begin && !partial_end)\n\t\tgoto out_dio;\n\n\t/*\n\t * In worst case we have to writeout two nonadjacent unwritten\n\t * blocks and update the inode\n\t */\n\tcredits = (2 * ext4_ext_index_trans_blocks(inode, 2)) + 1;\n\tif (ext4_should_journal_data(inode))\n\t\tcredits += 2;\n\thandle = ext4_journal_start(inode, EXT4_HT_MISC, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\text4_std_error(inode->i_sb, ret);\n\t\tgoto out_dio;\n\t}\n\n\tinode->i_mtime = inode->i_ctime = ext4_current_time(inode);\n\tif (new_size) {\n\t\text4_update_inode_size(inode, new_size);\n\t} else {\n\t\t/*\n\t\t* Mark that we allocate beyond EOF so the subsequent truncate\n\t\t* can proceed even if the new size is the same as i_size.\n\t\t*/\n\t\tif ((offset + len) > i_size_read(inode))\n\t\t\text4_set_inode_flag(inode, EXT4_INODE_EOFBLOCKS);\n\t}\n\text4_mark_inode_dirty(handle, inode);\n\n\t/* Zero out partial block at the edges of the range */\n\tret = ext4_zero_partial_blocks(handle, inode, offset, len);\n\n\tif (file->f_flags & O_SYNC)\n\t\text4_handle_sync(handle);\n\n\text4_journal_stop(handle);\nout_dio:\n\text4_inode_resume_unlocked_dio(inode);\nout_mutex:\n\tmutex_unlock(&inode->i_mutex);\n\treturn ret;\n}",
        "patch": "--- code before\n+++ code after\n@@ -11,7 +11,6 @@\n \tint partial_begin, partial_end;\n \tloff_t start, end;\n \text4_lblk_t lblk;\n-\tstruct address_space *mapping = inode->i_mapping;\n \tunsigned int blkbits = inode->i_blkbits;\n \n \ttrace_ext4_zero_range(inode, offset, len, mode);\n@@ -22,17 +21,6 @@\n \t/* Call ext4_force_commit to flush all data in case of data=journal. */\n \tif (ext4_should_journal_data(inode)) {\n \t\tret = ext4_force_commit(inode->i_sb);\n-\t\tif (ret)\n-\t\t\treturn ret;\n-\t}\n-\n-\t/*\n-\t * Write out all dirty pages to avoid race conditions\n-\t * Then release them.\n-\t */\n-\tif (mapping->nrpages && mapping_tagged(mapping, PAGECACHE_TAG_DIRTY)) {\n-\t\tret = filemap_write_and_wait_range(mapping, offset,\n-\t\t\t\t\t\t   offset + len - 1);\n \t\tif (ret)\n \t\t\treturn ret;\n \t}\n@@ -97,16 +85,22 @@\n \t\tflags |= (EXT4_GET_BLOCKS_CONVERT_UNWRITTEN |\n \t\t\t  EXT4_EX_NOCACHE);\n \n-\t\t/* Now release the pages and zero block aligned part of pages*/\n-\t\ttruncate_pagecache_range(inode, start, end - 1);\n-\t\tinode->i_mtime = inode->i_ctime = ext4_current_time(inode);\n-\n \t\t/* Wait all existing dio workers, newcomers will block on i_mutex */\n \t\text4_inode_block_unlocked_dio(inode);\n \t\tinode_dio_wait(inode);\n \n+\t\t/*\n+\t\t * Prevent page faults from reinstantiating pages we have\n+\t\t * released from page cache.\n+\t\t */\n+\t\tdown_write(&EXT4_I(inode)->i_mmap_sem);\n+\t\t/* Now release the pages and zero block aligned part of pages */\n+\t\ttruncate_pagecache_range(inode, start, end - 1);\n+\t\tinode->i_mtime = inode->i_ctime = ext4_current_time(inode);\n+\n \t\tret = ext4_alloc_file_blocks(file, lblk, max_blocks, new_size,\n \t\t\t\t\t     flags, mode);\n+\t\tup_write(&EXT4_I(inode)->i_mmap_sem);\n \t\tif (ret)\n \t\t\tgoto out_dio;\n \t}",
        "function_modified_lines": {
            "added": [
                "\t\t/*",
                "\t\t * Prevent page faults from reinstantiating pages we have",
                "\t\t * released from page cache.",
                "\t\t */",
                "\t\tdown_write(&EXT4_I(inode)->i_mmap_sem);",
                "\t\t/* Now release the pages and zero block aligned part of pages */",
                "\t\ttruncate_pagecache_range(inode, start, end - 1);",
                "\t\tinode->i_mtime = inode->i_ctime = ext4_current_time(inode);",
                "",
                "\t\tup_write(&EXT4_I(inode)->i_mmap_sem);"
            ],
            "deleted": [
                "\tstruct address_space *mapping = inode->i_mapping;",
                "\t\tif (ret)",
                "\t\t\treturn ret;",
                "\t}",
                "",
                "\t/*",
                "\t * Write out all dirty pages to avoid race conditions",
                "\t * Then release them.",
                "\t */",
                "\tif (mapping->nrpages && mapping_tagged(mapping, PAGECACHE_TAG_DIRTY)) {",
                "\t\tret = filemap_write_and_wait_range(mapping, offset,",
                "\t\t\t\t\t\t   offset + len - 1);",
                "\t\t/* Now release the pages and zero block aligned part of pages*/",
                "\t\ttruncate_pagecache_range(inode, start, end - 1);",
                "\t\tinode->i_mtime = inode->i_ctime = ext4_current_time(inode);",
                ""
            ]
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "Multiple race conditions in the ext4 filesystem implementation in the Linux kernel before 4.5 allow local users to cause a denial of service (disk corruption) by writing to a page that is associated with a different user's file after unsynchronized hole punching and page-fault handling.",
        "id": 850
    },
    {
        "cve_id": "CVE-2012-4508",
        "code_before_change": "static int ext4_split_extent_at(handle_t *handle,\n\t\t\t     struct inode *inode,\n\t\t\t     struct ext4_ext_path *path,\n\t\t\t     ext4_lblk_t split,\n\t\t\t     int split_flag,\n\t\t\t     int flags)\n{\n\text4_fsblk_t newblock;\n\text4_lblk_t ee_block;\n\tstruct ext4_extent *ex, newex, orig_ex;\n\tstruct ext4_extent *ex2 = NULL;\n\tunsigned int ee_len, depth;\n\tint err = 0;\n\n\text_debug(\"ext4_split_extents_at: inode %lu, logical\"\n\t\t\"block %llu\\n\", inode->i_ino, (unsigned long long)split);\n\n\text4_ext_show_leaf(inode, path);\n\n\tdepth = ext_depth(inode);\n\tex = path[depth].p_ext;\n\tee_block = le32_to_cpu(ex->ee_block);\n\tee_len = ext4_ext_get_actual_len(ex);\n\tnewblock = split - ee_block + ext4_ext_pblock(ex);\n\n\tBUG_ON(split < ee_block || split >= (ee_block + ee_len));\n\n\terr = ext4_ext_get_access(handle, inode, path + depth);\n\tif (err)\n\t\tgoto out;\n\n\tif (split == ee_block) {\n\t\t/*\n\t\t * case b: block @split is the block that the extent begins with\n\t\t * then we just change the state of the extent, and splitting\n\t\t * is not needed.\n\t\t */\n\t\tif (split_flag & EXT4_EXT_MARK_UNINIT2)\n\t\t\text4_ext_mark_uninitialized(ex);\n\t\telse\n\t\t\text4_ext_mark_initialized(ex);\n\n\t\tif (!(flags & EXT4_GET_BLOCKS_PRE_IO))\n\t\t\text4_ext_try_to_merge(handle, inode, path, ex);\n\n\t\terr = ext4_ext_dirty(handle, inode, path + path->p_depth);\n\t\tgoto out;\n\t}\n\n\t/* case a */\n\tmemcpy(&orig_ex, ex, sizeof(orig_ex));\n\tex->ee_len = cpu_to_le16(split - ee_block);\n\tif (split_flag & EXT4_EXT_MARK_UNINIT1)\n\t\text4_ext_mark_uninitialized(ex);\n\n\t/*\n\t * path may lead to new leaf, not to original leaf any more\n\t * after ext4_ext_insert_extent() returns,\n\t */\n\terr = ext4_ext_dirty(handle, inode, path + depth);\n\tif (err)\n\t\tgoto fix_extent_len;\n\n\tex2 = &newex;\n\tex2->ee_block = cpu_to_le32(split);\n\tex2->ee_len   = cpu_to_le16(ee_len - (split - ee_block));\n\text4_ext_store_pblock(ex2, newblock);\n\tif (split_flag & EXT4_EXT_MARK_UNINIT2)\n\t\text4_ext_mark_uninitialized(ex2);\n\n\terr = ext4_ext_insert_extent(handle, inode, path, &newex, flags);\n\tif (err == -ENOSPC && (EXT4_EXT_MAY_ZEROOUT & split_flag)) {\n\t\terr = ext4_ext_zeroout(inode, &orig_ex);\n\t\tif (err)\n\t\t\tgoto fix_extent_len;\n\t\t/* update the extent length and mark as initialized */\n\t\tex->ee_len = cpu_to_le16(ee_len);\n\t\text4_ext_try_to_merge(handle, inode, path, ex);\n\t\terr = ext4_ext_dirty(handle, inode, path + path->p_depth);\n\t\tgoto out;\n\t} else if (err)\n\t\tgoto fix_extent_len;\n\nout:\n\text4_ext_show_leaf(inode, path);\n\treturn err;\n\nfix_extent_len:\n\tex->ee_len = orig_ex.ee_len;\n\text4_ext_dirty(handle, inode, path + depth);\n\treturn err;\n}",
        "code_after_change": "static int ext4_split_extent_at(handle_t *handle,\n\t\t\t     struct inode *inode,\n\t\t\t     struct ext4_ext_path *path,\n\t\t\t     ext4_lblk_t split,\n\t\t\t     int split_flag,\n\t\t\t     int flags)\n{\n\text4_fsblk_t newblock;\n\text4_lblk_t ee_block;\n\tstruct ext4_extent *ex, newex, orig_ex;\n\tstruct ext4_extent *ex2 = NULL;\n\tunsigned int ee_len, depth;\n\tint err = 0;\n\n\tBUG_ON((split_flag & (EXT4_EXT_DATA_VALID1 | EXT4_EXT_DATA_VALID2)) ==\n\t       (EXT4_EXT_DATA_VALID1 | EXT4_EXT_DATA_VALID2));\n\n\text_debug(\"ext4_split_extents_at: inode %lu, logical\"\n\t\t\"block %llu\\n\", inode->i_ino, (unsigned long long)split);\n\n\text4_ext_show_leaf(inode, path);\n\n\tdepth = ext_depth(inode);\n\tex = path[depth].p_ext;\n\tee_block = le32_to_cpu(ex->ee_block);\n\tee_len = ext4_ext_get_actual_len(ex);\n\tnewblock = split - ee_block + ext4_ext_pblock(ex);\n\n\tBUG_ON(split < ee_block || split >= (ee_block + ee_len));\n\n\terr = ext4_ext_get_access(handle, inode, path + depth);\n\tif (err)\n\t\tgoto out;\n\n\tif (split == ee_block) {\n\t\t/*\n\t\t * case b: block @split is the block that the extent begins with\n\t\t * then we just change the state of the extent, and splitting\n\t\t * is not needed.\n\t\t */\n\t\tif (split_flag & EXT4_EXT_MARK_UNINIT2)\n\t\t\text4_ext_mark_uninitialized(ex);\n\t\telse\n\t\t\text4_ext_mark_initialized(ex);\n\n\t\tif (!(flags & EXT4_GET_BLOCKS_PRE_IO))\n\t\t\text4_ext_try_to_merge(handle, inode, path, ex);\n\n\t\terr = ext4_ext_dirty(handle, inode, path + path->p_depth);\n\t\tgoto out;\n\t}\n\n\t/* case a */\n\tmemcpy(&orig_ex, ex, sizeof(orig_ex));\n\tex->ee_len = cpu_to_le16(split - ee_block);\n\tif (split_flag & EXT4_EXT_MARK_UNINIT1)\n\t\text4_ext_mark_uninitialized(ex);\n\n\t/*\n\t * path may lead to new leaf, not to original leaf any more\n\t * after ext4_ext_insert_extent() returns,\n\t */\n\terr = ext4_ext_dirty(handle, inode, path + depth);\n\tif (err)\n\t\tgoto fix_extent_len;\n\n\tex2 = &newex;\n\tex2->ee_block = cpu_to_le32(split);\n\tex2->ee_len   = cpu_to_le16(ee_len - (split - ee_block));\n\text4_ext_store_pblock(ex2, newblock);\n\tif (split_flag & EXT4_EXT_MARK_UNINIT2)\n\t\text4_ext_mark_uninitialized(ex2);\n\n\terr = ext4_ext_insert_extent(handle, inode, path, &newex, flags);\n\tif (err == -ENOSPC && (EXT4_EXT_MAY_ZEROOUT & split_flag)) {\n\t\tif (split_flag & (EXT4_EXT_DATA_VALID1|EXT4_EXT_DATA_VALID2)) {\n\t\t\tif (split_flag & EXT4_EXT_DATA_VALID1)\n\t\t\t\terr = ext4_ext_zeroout(inode, ex2);\n\t\t\telse\n\t\t\t\terr = ext4_ext_zeroout(inode, ex);\n\t\t} else\n\t\t\terr = ext4_ext_zeroout(inode, &orig_ex);\n\n\t\tif (err)\n\t\t\tgoto fix_extent_len;\n\t\t/* update the extent length and mark as initialized */\n\t\tex->ee_len = cpu_to_le16(ee_len);\n\t\text4_ext_try_to_merge(handle, inode, path, ex);\n\t\terr = ext4_ext_dirty(handle, inode, path + path->p_depth);\n\t\tgoto out;\n\t} else if (err)\n\t\tgoto fix_extent_len;\n\nout:\n\text4_ext_show_leaf(inode, path);\n\treturn err;\n\nfix_extent_len:\n\tex->ee_len = orig_ex.ee_len;\n\text4_ext_dirty(handle, inode, path + depth);\n\treturn err;\n}",
        "patch": "--- code before\n+++ code after\n@@ -11,6 +11,9 @@\n \tstruct ext4_extent *ex2 = NULL;\n \tunsigned int ee_len, depth;\n \tint err = 0;\n+\n+\tBUG_ON((split_flag & (EXT4_EXT_DATA_VALID1 | EXT4_EXT_DATA_VALID2)) ==\n+\t       (EXT4_EXT_DATA_VALID1 | EXT4_EXT_DATA_VALID2));\n \n \text_debug(\"ext4_split_extents_at: inode %lu, logical\"\n \t\t\"block %llu\\n\", inode->i_ino, (unsigned long long)split);\n@@ -70,7 +73,14 @@\n \n \terr = ext4_ext_insert_extent(handle, inode, path, &newex, flags);\n \tif (err == -ENOSPC && (EXT4_EXT_MAY_ZEROOUT & split_flag)) {\n-\t\terr = ext4_ext_zeroout(inode, &orig_ex);\n+\t\tif (split_flag & (EXT4_EXT_DATA_VALID1|EXT4_EXT_DATA_VALID2)) {\n+\t\t\tif (split_flag & EXT4_EXT_DATA_VALID1)\n+\t\t\t\terr = ext4_ext_zeroout(inode, ex2);\n+\t\t\telse\n+\t\t\t\terr = ext4_ext_zeroout(inode, ex);\n+\t\t} else\n+\t\t\terr = ext4_ext_zeroout(inode, &orig_ex);\n+\n \t\tif (err)\n \t\t\tgoto fix_extent_len;\n \t\t/* update the extent length and mark as initialized */",
        "function_modified_lines": {
            "added": [
                "",
                "\tBUG_ON((split_flag & (EXT4_EXT_DATA_VALID1 | EXT4_EXT_DATA_VALID2)) ==",
                "\t       (EXT4_EXT_DATA_VALID1 | EXT4_EXT_DATA_VALID2));",
                "\t\tif (split_flag & (EXT4_EXT_DATA_VALID1|EXT4_EXT_DATA_VALID2)) {",
                "\t\t\tif (split_flag & EXT4_EXT_DATA_VALID1)",
                "\t\t\t\terr = ext4_ext_zeroout(inode, ex2);",
                "\t\t\telse",
                "\t\t\t\terr = ext4_ext_zeroout(inode, ex);",
                "\t\t} else",
                "\t\t\terr = ext4_ext_zeroout(inode, &orig_ex);",
                ""
            ],
            "deleted": [
                "\t\terr = ext4_ext_zeroout(inode, &orig_ex);"
            ]
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "Race condition in fs/ext4/extents.c in the Linux kernel before 3.4.16 allows local users to obtain sensitive information from a deleted file by reading an extent that was not properly marked as uninitialized.",
        "id": 107
    },
    {
        "cve_id": "CVE-2020-25285",
        "code_before_change": "int hugetlb_overcommit_handler(struct ctl_table *table, int write,\n\t\tvoid *buffer, size_t *length, loff_t *ppos)\n{\n\tstruct hstate *h = &default_hstate;\n\tunsigned long tmp;\n\tint ret;\n\n\tif (!hugepages_supported())\n\t\treturn -EOPNOTSUPP;\n\n\ttmp = h->nr_overcommit_huge_pages;\n\n\tif (write && hstate_is_gigantic(h))\n\t\treturn -EINVAL;\n\n\ttable->data = &tmp;\n\ttable->maxlen = sizeof(unsigned long);\n\tret = proc_doulongvec_minmax(table, write, buffer, length, ppos);\n\tif (ret)\n\t\tgoto out;\n\n\tif (write) {\n\t\tspin_lock(&hugetlb_lock);\n\t\th->nr_overcommit_huge_pages = tmp;\n\t\tspin_unlock(&hugetlb_lock);\n\t}\nout:\n\treturn ret;\n}",
        "code_after_change": "int hugetlb_overcommit_handler(struct ctl_table *table, int write,\n\t\tvoid *buffer, size_t *length, loff_t *ppos)\n{\n\tstruct hstate *h = &default_hstate;\n\tunsigned long tmp;\n\tint ret;\n\n\tif (!hugepages_supported())\n\t\treturn -EOPNOTSUPP;\n\n\ttmp = h->nr_overcommit_huge_pages;\n\n\tif (write && hstate_is_gigantic(h))\n\t\treturn -EINVAL;\n\n\tret = proc_hugetlb_doulongvec_minmax(table, write, buffer, length, ppos,\n\t\t\t\t\t     &tmp);\n\tif (ret)\n\t\tgoto out;\n\n\tif (write) {\n\t\tspin_lock(&hugetlb_lock);\n\t\th->nr_overcommit_huge_pages = tmp;\n\t\tspin_unlock(&hugetlb_lock);\n\t}\nout:\n\treturn ret;\n}",
        "patch": "--- code before\n+++ code after\n@@ -13,9 +13,8 @@\n \tif (write && hstate_is_gigantic(h))\n \t\treturn -EINVAL;\n \n-\ttable->data = &tmp;\n-\ttable->maxlen = sizeof(unsigned long);\n-\tret = proc_doulongvec_minmax(table, write, buffer, length, ppos);\n+\tret = proc_hugetlb_doulongvec_minmax(table, write, buffer, length, ppos,\n+\t\t\t\t\t     &tmp);\n \tif (ret)\n \t\tgoto out;\n ",
        "function_modified_lines": {
            "added": [
                "\tret = proc_hugetlb_doulongvec_minmax(table, write, buffer, length, ppos,",
                "\t\t\t\t\t     &tmp);"
            ],
            "deleted": [
                "\ttable->data = &tmp;",
                "\ttable->maxlen = sizeof(unsigned long);",
                "\tret = proc_doulongvec_minmax(table, write, buffer, length, ppos);"
            ]
        },
        "cwe": [
            "CWE-362",
            "CWE-787",
            "CWE-476"
        ],
        "cve_description": "A race condition between hugetlb sysctl handlers in mm/hugetlb.c in the Linux kernel before 5.8.8 could be used by local attackers to corrupt memory, cause a NULL pointer dereference, or possibly have unspecified other impact, aka CID-17743798d812.",
        "id": 2586
    },
    {
        "cve_id": "CVE-2022-3567",
        "code_before_change": "ssize_t inet_sendpage(struct socket *sock, struct page *page, int offset,\n\t\t      size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\n\tif (unlikely(inet_send_prepare(sk)))\n\t\treturn -EAGAIN;\n\n\tif (sk->sk_prot->sendpage)\n\t\treturn sk->sk_prot->sendpage(sk, page, offset, size, flags);\n\treturn sock_no_sendpage(sock, page, offset, size, flags);\n}",
        "code_after_change": "ssize_t inet_sendpage(struct socket *sock, struct page *page, int offset,\n\t\t      size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tconst struct proto *prot;\n\n\tif (unlikely(inet_send_prepare(sk)))\n\t\treturn -EAGAIN;\n\n\t/* IPV6_ADDRFORM can change sk->sk_prot under us. */\n\tprot = READ_ONCE(sk->sk_prot);\n\tif (prot->sendpage)\n\t\treturn prot->sendpage(sk, page, offset, size, flags);\n\treturn sock_no_sendpage(sock, page, offset, size, flags);\n}",
        "patch": "--- code before\n+++ code after\n@@ -2,11 +2,14 @@\n \t\t      size_t size, int flags)\n {\n \tstruct sock *sk = sock->sk;\n+\tconst struct proto *prot;\n \n \tif (unlikely(inet_send_prepare(sk)))\n \t\treturn -EAGAIN;\n \n-\tif (sk->sk_prot->sendpage)\n-\t\treturn sk->sk_prot->sendpage(sk, page, offset, size, flags);\n+\t/* IPV6_ADDRFORM can change sk->sk_prot under us. */\n+\tprot = READ_ONCE(sk->sk_prot);\n+\tif (prot->sendpage)\n+\t\treturn prot->sendpage(sk, page, offset, size, flags);\n \treturn sock_no_sendpage(sock, page, offset, size, flags);\n }",
        "function_modified_lines": {
            "added": [
                "\tconst struct proto *prot;",
                "\t/* IPV6_ADDRFORM can change sk->sk_prot under us. */",
                "\tprot = READ_ONCE(sk->sk_prot);",
                "\tif (prot->sendpage)",
                "\t\treturn prot->sendpage(sk, page, offset, size, flags);"
            ],
            "deleted": [
                "\tif (sk->sk_prot->sendpage)",
                "\t\treturn sk->sk_prot->sendpage(sk, page, offset, size, flags);"
            ]
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "A vulnerability has been found in Linux Kernel and classified as problematic. This vulnerability affects the function inet6_stream_ops/inet6_dgram_ops of the component IPv6 Handler. The manipulation leads to race condition. It is recommended to apply a patch to fix this issue. VDB-211090 is the identifier assigned to this vulnerability.",
        "id": 3648
    },
    {
        "cve_id": "CVE-2017-15265",
        "code_before_change": "struct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client,\n\t\t\t\t\t\tint port)\n{\n\tunsigned long flags;\n\tstruct snd_seq_client_port *new_port, *p;\n\tint num = -1;\n\t\n\t/* sanity check */\n\tif (snd_BUG_ON(!client))\n\t\treturn NULL;\n\n\tif (client->num_ports >= SNDRV_SEQ_MAX_PORTS) {\n\t\tpr_warn(\"ALSA: seq: too many ports for client %d\\n\", client->number);\n\t\treturn NULL;\n\t}\n\n\t/* create a new port */\n\tnew_port = kzalloc(sizeof(*new_port), GFP_KERNEL);\n\tif (!new_port)\n\t\treturn NULL;\t/* failure, out of memory */\n\t/* init port data */\n\tnew_port->addr.client = client->number;\n\tnew_port->addr.port = -1;\n\tnew_port->owner = THIS_MODULE;\n\tsprintf(new_port->name, \"port-%d\", num);\n\tsnd_use_lock_init(&new_port->use_lock);\n\tport_subs_info_init(&new_port->c_src);\n\tport_subs_info_init(&new_port->c_dest);\n\n\tnum = port >= 0 ? port : 0;\n\tmutex_lock(&client->ports_mutex);\n\twrite_lock_irqsave(&client->ports_lock, flags);\n\tlist_for_each_entry(p, &client->ports_list_head, list) {\n\t\tif (p->addr.port > num)\n\t\t\tbreak;\n\t\tif (port < 0) /* auto-probe mode */\n\t\t\tnum = p->addr.port + 1;\n\t}\n\t/* insert the new port */\n\tlist_add_tail(&new_port->list, &p->list);\n\tclient->num_ports++;\n\tnew_port->addr.port = num;\t/* store the port number in the port */\n\twrite_unlock_irqrestore(&client->ports_lock, flags);\n\tmutex_unlock(&client->ports_mutex);\n\tsprintf(new_port->name, \"port-%d\", num);\n\n\treturn new_port;\n}",
        "code_after_change": "struct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client,\n\t\t\t\t\t\tint port)\n{\n\tunsigned long flags;\n\tstruct snd_seq_client_port *new_port, *p;\n\tint num = -1;\n\t\n\t/* sanity check */\n\tif (snd_BUG_ON(!client))\n\t\treturn NULL;\n\n\tif (client->num_ports >= SNDRV_SEQ_MAX_PORTS) {\n\t\tpr_warn(\"ALSA: seq: too many ports for client %d\\n\", client->number);\n\t\treturn NULL;\n\t}\n\n\t/* create a new port */\n\tnew_port = kzalloc(sizeof(*new_port), GFP_KERNEL);\n\tif (!new_port)\n\t\treturn NULL;\t/* failure, out of memory */\n\t/* init port data */\n\tnew_port->addr.client = client->number;\n\tnew_port->addr.port = -1;\n\tnew_port->owner = THIS_MODULE;\n\tsprintf(new_port->name, \"port-%d\", num);\n\tsnd_use_lock_init(&new_port->use_lock);\n\tport_subs_info_init(&new_port->c_src);\n\tport_subs_info_init(&new_port->c_dest);\n\tsnd_use_lock_use(&new_port->use_lock);\n\n\tnum = port >= 0 ? port : 0;\n\tmutex_lock(&client->ports_mutex);\n\twrite_lock_irqsave(&client->ports_lock, flags);\n\tlist_for_each_entry(p, &client->ports_list_head, list) {\n\t\tif (p->addr.port > num)\n\t\t\tbreak;\n\t\tif (port < 0) /* auto-probe mode */\n\t\t\tnum = p->addr.port + 1;\n\t}\n\t/* insert the new port */\n\tlist_add_tail(&new_port->list, &p->list);\n\tclient->num_ports++;\n\tnew_port->addr.port = num;\t/* store the port number in the port */\n\tsprintf(new_port->name, \"port-%d\", num);\n\twrite_unlock_irqrestore(&client->ports_lock, flags);\n\tmutex_unlock(&client->ports_mutex);\n\n\treturn new_port;\n}",
        "patch": "--- code before\n+++ code after\n@@ -26,6 +26,7 @@\n \tsnd_use_lock_init(&new_port->use_lock);\n \tport_subs_info_init(&new_port->c_src);\n \tport_subs_info_init(&new_port->c_dest);\n+\tsnd_use_lock_use(&new_port->use_lock);\n \n \tnum = port >= 0 ? port : 0;\n \tmutex_lock(&client->ports_mutex);\n@@ -40,9 +41,9 @@\n \tlist_add_tail(&new_port->list, &p->list);\n \tclient->num_ports++;\n \tnew_port->addr.port = num;\t/* store the port number in the port */\n+\tsprintf(new_port->name, \"port-%d\", num);\n \twrite_unlock_irqrestore(&client->ports_lock, flags);\n \tmutex_unlock(&client->ports_mutex);\n-\tsprintf(new_port->name, \"port-%d\", num);\n \n \treturn new_port;\n }",
        "function_modified_lines": {
            "added": [
                "\tsnd_use_lock_use(&new_port->use_lock);",
                "\tsprintf(new_port->name, \"port-%d\", num);"
            ],
            "deleted": [
                "\tsprintf(new_port->name, \"port-%d\", num);"
            ]
        },
        "cwe": [
            "CWE-362",
            "CWE-416"
        ],
        "cve_description": "Race condition in the ALSA subsystem in the Linux kernel before 4.13.8 allows local users to cause a denial of service (use-after-free) or possibly have unspecified other impact via crafted /dev/snd/seq ioctl calls, related to sound/core/seq/seq_clientmgr.c and sound/core/seq/seq_ports.c.",
        "id": 1301
    },
    {
        "cve_id": "CVE-2022-3566",
        "code_before_change": "int tcp_getsockopt(struct sock *sk, int level, int optname, char __user *optval,\n\t\t   int __user *optlen)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\n\tif (level != SOL_TCP)\n\t\treturn icsk->icsk_af_ops->getsockopt(sk, level, optname,\n\t\t\t\t\t\t     optval, optlen);\n\treturn do_tcp_getsockopt(sk, level, optname, USER_SOCKPTR(optval),\n\t\t\t\t USER_SOCKPTR(optlen));\n}",
        "code_after_change": "int tcp_getsockopt(struct sock *sk, int level, int optname, char __user *optval,\n\t\t   int __user *optlen)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\n\tif (level != SOL_TCP)\n\t\t/* Paired with WRITE_ONCE() in do_ipv6_setsockopt() and tcp_v6_connect() */\n\t\treturn READ_ONCE(icsk->icsk_af_ops)->getsockopt(sk, level, optname,\n\t\t\t\t\t\t\t\toptval, optlen);\n\treturn do_tcp_getsockopt(sk, level, optname, USER_SOCKPTR(optval),\n\t\t\t\t USER_SOCKPTR(optlen));\n}",
        "patch": "--- code before\n+++ code after\n@@ -4,8 +4,9 @@\n \tstruct inet_connection_sock *icsk = inet_csk(sk);\n \n \tif (level != SOL_TCP)\n-\t\treturn icsk->icsk_af_ops->getsockopt(sk, level, optname,\n-\t\t\t\t\t\t     optval, optlen);\n+\t\t/* Paired with WRITE_ONCE() in do_ipv6_setsockopt() and tcp_v6_connect() */\n+\t\treturn READ_ONCE(icsk->icsk_af_ops)->getsockopt(sk, level, optname,\n+\t\t\t\t\t\t\t\toptval, optlen);\n \treturn do_tcp_getsockopt(sk, level, optname, USER_SOCKPTR(optval),\n \t\t\t\t USER_SOCKPTR(optlen));\n }",
        "function_modified_lines": {
            "added": [
                "\t\t/* Paired with WRITE_ONCE() in do_ipv6_setsockopt() and tcp_v6_connect() */",
                "\t\treturn READ_ONCE(icsk->icsk_af_ops)->getsockopt(sk, level, optname,",
                "\t\t\t\t\t\t\t\toptval, optlen);"
            ],
            "deleted": [
                "\t\treturn icsk->icsk_af_ops->getsockopt(sk, level, optname,",
                "\t\t\t\t\t\t     optval, optlen);"
            ]
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "A vulnerability, which was classified as problematic, was found in Linux Kernel. This affects the function tcp_getsockopt/tcp_setsockopt of the component TCP Handler. The manipulation leads to race condition. It is recommended to apply a patch to fix this issue. The identifier VDB-211089 was assigned to this vulnerability.",
        "id": 3641
    },
    {
        "cve_id": "CVE-2023-4732",
        "code_before_change": "static inline int\ncopy_pmd_range(struct vm_area_struct *dst_vma, struct vm_area_struct *src_vma,\n\t       pud_t *dst_pud, pud_t *src_pud, unsigned long addr,\n\t       unsigned long end)\n{\n\tstruct mm_struct *dst_mm = dst_vma->vm_mm;\n\tstruct mm_struct *src_mm = src_vma->vm_mm;\n\tpmd_t *src_pmd, *dst_pmd;\n\tunsigned long next;\n\n\tdst_pmd = pmd_alloc(dst_mm, dst_pud, addr);\n\tif (!dst_pmd)\n\t\treturn -ENOMEM;\n\tsrc_pmd = pmd_offset(src_pud, addr);\n\tdo {\n\t\tnext = pmd_addr_end(addr, end);\n\t\tif (is_swap_pmd(*src_pmd) || pmd_trans_huge(*src_pmd)\n\t\t\t|| pmd_devmap(*src_pmd)) {\n\t\t\tint err;\n\t\t\tVM_BUG_ON_VMA(next-addr != HPAGE_PMD_SIZE, src_vma);\n\t\t\terr = copy_huge_pmd(dst_mm, src_mm,\n\t\t\t\t\t    dst_pmd, src_pmd, addr, src_vma);\n\t\t\tif (err == -ENOMEM)\n\t\t\t\treturn -ENOMEM;\n\t\t\tif (!err)\n\t\t\t\tcontinue;\n\t\t\t/* fall through */\n\t\t}\n\t\tif (pmd_none_or_clear_bad(src_pmd))\n\t\t\tcontinue;\n\t\tif (copy_pte_range(dst_vma, src_vma, dst_pmd, src_pmd,\n\t\t\t\t   addr, next))\n\t\t\treturn -ENOMEM;\n\t} while (dst_pmd++, src_pmd++, addr = next, addr != end);\n\treturn 0;\n}",
        "code_after_change": "static inline int\ncopy_pmd_range(struct vm_area_struct *dst_vma, struct vm_area_struct *src_vma,\n\t       pud_t *dst_pud, pud_t *src_pud, unsigned long addr,\n\t       unsigned long end)\n{\n\tstruct mm_struct *dst_mm = dst_vma->vm_mm;\n\tstruct mm_struct *src_mm = src_vma->vm_mm;\n\tpmd_t *src_pmd, *dst_pmd;\n\tunsigned long next;\n\n\tdst_pmd = pmd_alloc(dst_mm, dst_pud, addr);\n\tif (!dst_pmd)\n\t\treturn -ENOMEM;\n\tsrc_pmd = pmd_offset(src_pud, addr);\n\tdo {\n\t\tnext = pmd_addr_end(addr, end);\n\t\tif (is_swap_pmd(*src_pmd) || pmd_trans_huge(*src_pmd)\n\t\t\t|| pmd_devmap(*src_pmd)) {\n\t\t\tint err;\n\t\t\tVM_BUG_ON_VMA(next-addr != HPAGE_PMD_SIZE, src_vma);\n\t\t\terr = copy_huge_pmd(dst_mm, src_mm, dst_pmd, src_pmd,\n\t\t\t\t\t    addr, dst_vma, src_vma);\n\t\t\tif (err == -ENOMEM)\n\t\t\t\treturn -ENOMEM;\n\t\t\tif (!err)\n\t\t\t\tcontinue;\n\t\t\t/* fall through */\n\t\t}\n\t\tif (pmd_none_or_clear_bad(src_pmd))\n\t\t\tcontinue;\n\t\tif (copy_pte_range(dst_vma, src_vma, dst_pmd, src_pmd,\n\t\t\t\t   addr, next))\n\t\t\treturn -ENOMEM;\n\t} while (dst_pmd++, src_pmd++, addr = next, addr != end);\n\treturn 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -18,8 +18,8 @@\n \t\t\t|| pmd_devmap(*src_pmd)) {\n \t\t\tint err;\n \t\t\tVM_BUG_ON_VMA(next-addr != HPAGE_PMD_SIZE, src_vma);\n-\t\t\terr = copy_huge_pmd(dst_mm, src_mm,\n-\t\t\t\t\t    dst_pmd, src_pmd, addr, src_vma);\n+\t\t\terr = copy_huge_pmd(dst_mm, src_mm, dst_pmd, src_pmd,\n+\t\t\t\t\t    addr, dst_vma, src_vma);\n \t\t\tif (err == -ENOMEM)\n \t\t\t\treturn -ENOMEM;\n \t\t\tif (!err)",
        "function_modified_lines": {
            "added": [
                "\t\t\terr = copy_huge_pmd(dst_mm, src_mm, dst_pmd, src_pmd,",
                "\t\t\t\t\t    addr, dst_vma, src_vma);"
            ],
            "deleted": [
                "\t\t\terr = copy_huge_pmd(dst_mm, src_mm,",
                "\t\t\t\t\t    dst_pmd, src_pmd, addr, src_vma);"
            ]
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "A flaw was found in pfn_swap_entry_to_page in memory management subsystem in the Linux Kernel. In this flaw, an attacker with a local user privilege may cause a denial of service problem due to a BUG statement referencing pmd_t x.",
        "id": 4246
    },
    {
        "cve_id": "CVE-2021-39713",
        "code_before_change": "static struct tcf_block *tcf_block_find(struct net *net, struct Qdisc **q,\n\t\t\t\t\tu32 *parent, unsigned long *cl,\n\t\t\t\t\tint ifindex, u32 block_index,\n\t\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct tcf_block *block;\n\n\tif (ifindex == TCM_IFINDEX_MAGIC_BLOCK) {\n\t\tblock = tcf_block_lookup(net, block_index);\n\t\tif (!block) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Block of given index was not found\");\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t} else {\n\t\tconst struct Qdisc_class_ops *cops;\n\t\tstruct net_device *dev;\n\n\t\t/* Find link */\n\t\tdev = __dev_get_by_index(net, ifindex);\n\t\tif (!dev)\n\t\t\treturn ERR_PTR(-ENODEV);\n\n\t\t/* Find qdisc */\n\t\tif (!*parent) {\n\t\t\t*q = dev->qdisc;\n\t\t\t*parent = (*q)->handle;\n\t\t} else {\n\t\t\t*q = qdisc_lookup(dev, TC_H_MAJ(*parent));\n\t\t\tif (!*q) {\n\t\t\t\tNL_SET_ERR_MSG(extack, \"Parent Qdisc doesn't exists\");\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t\t}\n\t\t}\n\n\t\t/* Is it classful? */\n\t\tcops = (*q)->ops->cl_ops;\n\t\tif (!cops) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Qdisc not classful\");\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\n\t\tif (!cops->tcf_block) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Class doesn't support blocks\");\n\t\t\treturn ERR_PTR(-EOPNOTSUPP);\n\t\t}\n\n\t\t/* Do we search for filter, attached to class? */\n\t\tif (TC_H_MIN(*parent)) {\n\t\t\t*cl = cops->find(*q, *parent);\n\t\t\tif (*cl == 0) {\n\t\t\t\tNL_SET_ERR_MSG(extack, \"Specified class doesn't exist\");\n\t\t\t\treturn ERR_PTR(-ENOENT);\n\t\t\t}\n\t\t}\n\n\t\t/* And the last stroke */\n\t\tblock = cops->tcf_block(*q, *cl, extack);\n\t\tif (!block)\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\tif (tcf_block_shared(block)) {\n\t\t\tNL_SET_ERR_MSG(extack, \"This filter block is shared. Please use the block index to manipulate the filters\");\n\t\t\treturn ERR_PTR(-EOPNOTSUPP);\n\t\t}\n\t}\n\n\treturn block;\n}",
        "code_after_change": "static struct tcf_block *tcf_block_find(struct net *net, struct Qdisc **q,\n\t\t\t\t\tu32 *parent, unsigned long *cl,\n\t\t\t\t\tint ifindex, u32 block_index,\n\t\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct tcf_block *block;\n\tint err = 0;\n\n\tif (ifindex == TCM_IFINDEX_MAGIC_BLOCK) {\n\t\tblock = tcf_block_lookup(net, block_index);\n\t\tif (!block) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Block of given index was not found\");\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t} else {\n\t\tconst struct Qdisc_class_ops *cops;\n\t\tstruct net_device *dev;\n\n\t\trcu_read_lock();\n\n\t\t/* Find link */\n\t\tdev = dev_get_by_index_rcu(net, ifindex);\n\t\tif (!dev) {\n\t\t\trcu_read_unlock();\n\t\t\treturn ERR_PTR(-ENODEV);\n\t\t}\n\n\t\t/* Find qdisc */\n\t\tif (!*parent) {\n\t\t\t*q = dev->qdisc;\n\t\t\t*parent = (*q)->handle;\n\t\t} else {\n\t\t\t*q = qdisc_lookup_rcu(dev, TC_H_MAJ(*parent));\n\t\t\tif (!*q) {\n\t\t\t\tNL_SET_ERR_MSG(extack, \"Parent Qdisc doesn't exists\");\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto errout_rcu;\n\t\t\t}\n\t\t}\n\n\t\t*q = qdisc_refcount_inc_nz(*q);\n\t\tif (!*q) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Parent Qdisc doesn't exists\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto errout_rcu;\n\t\t}\n\n\t\t/* Is it classful? */\n\t\tcops = (*q)->ops->cl_ops;\n\t\tif (!cops) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Qdisc not classful\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto errout_rcu;\n\t\t}\n\n\t\tif (!cops->tcf_block) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Class doesn't support blocks\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto errout_rcu;\n\t\t}\n\n\t\t/* At this point we know that qdisc is not noop_qdisc,\n\t\t * which means that qdisc holds a reference to net_device\n\t\t * and we hold a reference to qdisc, so it is safe to release\n\t\t * rcu read lock.\n\t\t */\n\t\trcu_read_unlock();\n\n\t\t/* Do we search for filter, attached to class? */\n\t\tif (TC_H_MIN(*parent)) {\n\t\t\t*cl = cops->find(*q, *parent);\n\t\t\tif (*cl == 0) {\n\t\t\t\tNL_SET_ERR_MSG(extack, \"Specified class doesn't exist\");\n\t\t\t\terr = -ENOENT;\n\t\t\t\tgoto errout_qdisc;\n\t\t\t}\n\t\t}\n\n\t\t/* And the last stroke */\n\t\tblock = cops->tcf_block(*q, *cl, extack);\n\t\tif (!block) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto errout_qdisc;\n\t\t}\n\t\tif (tcf_block_shared(block)) {\n\t\t\tNL_SET_ERR_MSG(extack, \"This filter block is shared. Please use the block index to manipulate the filters\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto errout_qdisc;\n\t\t}\n\t}\n\n\treturn block;\n\nerrout_rcu:\n\trcu_read_unlock();\nerrout_qdisc:\n\tif (*q)\n\t\tqdisc_put(*q);\n\treturn ERR_PTR(err);\n}",
        "patch": "--- code before\n+++ code after\n@@ -4,6 +4,7 @@\n \t\t\t\t\tstruct netlink_ext_ack *extack)\n {\n \tstruct tcf_block *block;\n+\tint err = 0;\n \n \tif (ifindex == TCM_IFINDEX_MAGIC_BLOCK) {\n \t\tblock = tcf_block_lookup(net, block_index);\n@@ -15,53 +16,85 @@\n \t\tconst struct Qdisc_class_ops *cops;\n \t\tstruct net_device *dev;\n \n+\t\trcu_read_lock();\n+\n \t\t/* Find link */\n-\t\tdev = __dev_get_by_index(net, ifindex);\n-\t\tif (!dev)\n+\t\tdev = dev_get_by_index_rcu(net, ifindex);\n+\t\tif (!dev) {\n+\t\t\trcu_read_unlock();\n \t\t\treturn ERR_PTR(-ENODEV);\n+\t\t}\n \n \t\t/* Find qdisc */\n \t\tif (!*parent) {\n \t\t\t*q = dev->qdisc;\n \t\t\t*parent = (*q)->handle;\n \t\t} else {\n-\t\t\t*q = qdisc_lookup(dev, TC_H_MAJ(*parent));\n+\t\t\t*q = qdisc_lookup_rcu(dev, TC_H_MAJ(*parent));\n \t\t\tif (!*q) {\n \t\t\t\tNL_SET_ERR_MSG(extack, \"Parent Qdisc doesn't exists\");\n-\t\t\t\treturn ERR_PTR(-EINVAL);\n+\t\t\t\terr = -EINVAL;\n+\t\t\t\tgoto errout_rcu;\n \t\t\t}\n+\t\t}\n+\n+\t\t*q = qdisc_refcount_inc_nz(*q);\n+\t\tif (!*q) {\n+\t\t\tNL_SET_ERR_MSG(extack, \"Parent Qdisc doesn't exists\");\n+\t\t\terr = -EINVAL;\n+\t\t\tgoto errout_rcu;\n \t\t}\n \n \t\t/* Is it classful? */\n \t\tcops = (*q)->ops->cl_ops;\n \t\tif (!cops) {\n \t\t\tNL_SET_ERR_MSG(extack, \"Qdisc not classful\");\n-\t\t\treturn ERR_PTR(-EINVAL);\n+\t\t\terr = -EINVAL;\n+\t\t\tgoto errout_rcu;\n \t\t}\n \n \t\tif (!cops->tcf_block) {\n \t\t\tNL_SET_ERR_MSG(extack, \"Class doesn't support blocks\");\n-\t\t\treturn ERR_PTR(-EOPNOTSUPP);\n+\t\t\terr = -EOPNOTSUPP;\n+\t\t\tgoto errout_rcu;\n \t\t}\n+\n+\t\t/* At this point we know that qdisc is not noop_qdisc,\n+\t\t * which means that qdisc holds a reference to net_device\n+\t\t * and we hold a reference to qdisc, so it is safe to release\n+\t\t * rcu read lock.\n+\t\t */\n+\t\trcu_read_unlock();\n \n \t\t/* Do we search for filter, attached to class? */\n \t\tif (TC_H_MIN(*parent)) {\n \t\t\t*cl = cops->find(*q, *parent);\n \t\t\tif (*cl == 0) {\n \t\t\t\tNL_SET_ERR_MSG(extack, \"Specified class doesn't exist\");\n-\t\t\t\treturn ERR_PTR(-ENOENT);\n+\t\t\t\terr = -ENOENT;\n+\t\t\t\tgoto errout_qdisc;\n \t\t\t}\n \t\t}\n \n \t\t/* And the last stroke */\n \t\tblock = cops->tcf_block(*q, *cl, extack);\n-\t\tif (!block)\n-\t\t\treturn ERR_PTR(-EINVAL);\n+\t\tif (!block) {\n+\t\t\terr = -EINVAL;\n+\t\t\tgoto errout_qdisc;\n+\t\t}\n \t\tif (tcf_block_shared(block)) {\n \t\t\tNL_SET_ERR_MSG(extack, \"This filter block is shared. Please use the block index to manipulate the filters\");\n-\t\t\treturn ERR_PTR(-EOPNOTSUPP);\n+\t\t\terr = -EOPNOTSUPP;\n+\t\t\tgoto errout_qdisc;\n \t\t}\n \t}\n \n \treturn block;\n+\n+errout_rcu:\n+\trcu_read_unlock();\n+errout_qdisc:\n+\tif (*q)\n+\t\tqdisc_put(*q);\n+\treturn ERR_PTR(err);\n }",
        "function_modified_lines": {
            "added": [
                "\tint err = 0;",
                "\t\trcu_read_lock();",
                "",
                "\t\tdev = dev_get_by_index_rcu(net, ifindex);",
                "\t\tif (!dev) {",
                "\t\t\trcu_read_unlock();",
                "\t\t}",
                "\t\t\t*q = qdisc_lookup_rcu(dev, TC_H_MAJ(*parent));",
                "\t\t\t\terr = -EINVAL;",
                "\t\t\t\tgoto errout_rcu;",
                "\t\t}",
                "",
                "\t\t*q = qdisc_refcount_inc_nz(*q);",
                "\t\tif (!*q) {",
                "\t\t\tNL_SET_ERR_MSG(extack, \"Parent Qdisc doesn't exists\");",
                "\t\t\terr = -EINVAL;",
                "\t\t\tgoto errout_rcu;",
                "\t\t\terr = -EINVAL;",
                "\t\t\tgoto errout_rcu;",
                "\t\t\terr = -EOPNOTSUPP;",
                "\t\t\tgoto errout_rcu;",
                "",
                "\t\t/* At this point we know that qdisc is not noop_qdisc,",
                "\t\t * which means that qdisc holds a reference to net_device",
                "\t\t * and we hold a reference to qdisc, so it is safe to release",
                "\t\t * rcu read lock.",
                "\t\t */",
                "\t\trcu_read_unlock();",
                "\t\t\t\terr = -ENOENT;",
                "\t\t\t\tgoto errout_qdisc;",
                "\t\tif (!block) {",
                "\t\t\terr = -EINVAL;",
                "\t\t\tgoto errout_qdisc;",
                "\t\t}",
                "\t\t\terr = -EOPNOTSUPP;",
                "\t\t\tgoto errout_qdisc;",
                "",
                "errout_rcu:",
                "\trcu_read_unlock();",
                "errout_qdisc:",
                "\tif (*q)",
                "\t\tqdisc_put(*q);",
                "\treturn ERR_PTR(err);"
            ],
            "deleted": [
                "\t\tdev = __dev_get_by_index(net, ifindex);",
                "\t\tif (!dev)",
                "\t\t\t*q = qdisc_lookup(dev, TC_H_MAJ(*parent));",
                "\t\t\t\treturn ERR_PTR(-EINVAL);",
                "\t\t\treturn ERR_PTR(-EINVAL);",
                "\t\t\treturn ERR_PTR(-EOPNOTSUPP);",
                "\t\t\t\treturn ERR_PTR(-ENOENT);",
                "\t\tif (!block)",
                "\t\t\treturn ERR_PTR(-EINVAL);",
                "\t\t\treturn ERR_PTR(-EOPNOTSUPP);"
            ]
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "Product: AndroidVersions: Android kernelAndroid ID: A-173788806References: Upstream kernel",
        "id": 3104
    },
    {
        "cve_id": "CVE-2020-12114",
        "code_before_change": "static void namespace_unlock(void)\n{\n\tstruct hlist_head head;\n\n\thlist_move_list(&unmounted, &head);\n\n\tup_write(&namespace_sem);\n\n\tif (likely(hlist_empty(&head)))\n\t\treturn;\n\n\tsynchronize_rcu_expedited();\n\n\tgroup_pin_kill(&head);\n}",
        "code_after_change": "static void namespace_unlock(void)\n{\n\tstruct hlist_head head;\n\tLIST_HEAD(list);\n\n\thlist_move_list(&unmounted, &head);\n\tlist_splice_init(&ex_mountpoints, &list);\n\n\tup_write(&namespace_sem);\n\n\tshrink_dentry_list(&list);\n\n\tif (likely(hlist_empty(&head)))\n\t\treturn;\n\n\tsynchronize_rcu_expedited();\n\n\tgroup_pin_kill(&head);\n}",
        "patch": "--- code before\n+++ code after\n@@ -1,10 +1,14 @@\n static void namespace_unlock(void)\n {\n \tstruct hlist_head head;\n+\tLIST_HEAD(list);\n \n \thlist_move_list(&unmounted, &head);\n+\tlist_splice_init(&ex_mountpoints, &list);\n \n \tup_write(&namespace_sem);\n+\n+\tshrink_dentry_list(&list);\n \n \tif (likely(hlist_empty(&head)))\n \t\treturn;",
        "function_modified_lines": {
            "added": [
                "\tLIST_HEAD(list);",
                "\tlist_splice_init(&ex_mountpoints, &list);",
                "",
                "\tshrink_dentry_list(&list);"
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "A pivot_root race condition in fs/namespace.c in the Linux kernel 4.4.x before 4.4.221, 4.9.x before 4.9.221, 4.14.x before 4.14.178, 4.19.x before 4.19.119, and 5.x before 5.3 allows local users to cause a denial of service (panic) by corrupting a mountpoint reference counter.",
        "id": 2445
    },
    {
        "cve_id": "CVE-2020-12114",
        "code_before_change": "static void detach_mnt(struct mount *mnt, struct path *old_path)\n{\n\told_path->dentry = mnt->mnt_mountpoint;\n\told_path->mnt = &mnt->mnt_parent->mnt;\n\tput_mountpoint(unhash_mnt(mnt));\n}",
        "code_after_change": "static void detach_mnt(struct mount *mnt, struct path *old_path)\n{\n\told_path->dentry = dget(mnt->mnt_mountpoint);\n\told_path->mnt = &mnt->mnt_parent->mnt;\n\tput_mountpoint(unhash_mnt(mnt));\n}",
        "patch": "--- code before\n+++ code after\n@@ -1,6 +1,6 @@\n static void detach_mnt(struct mount *mnt, struct path *old_path)\n {\n-\told_path->dentry = mnt->mnt_mountpoint;\n+\told_path->dentry = dget(mnt->mnt_mountpoint);\n \told_path->mnt = &mnt->mnt_parent->mnt;\n \tput_mountpoint(unhash_mnt(mnt));\n }",
        "function_modified_lines": {
            "added": [
                "\told_path->dentry = dget(mnt->mnt_mountpoint);"
            ],
            "deleted": [
                "\told_path->dentry = mnt->mnt_mountpoint;"
            ]
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "A pivot_root race condition in fs/namespace.c in the Linux kernel 4.4.x before 4.4.221, 4.9.x before 4.9.221, 4.14.x before 4.14.178, 4.19.x before 4.19.119, and 5.x before 5.3 allows local users to cause a denial of service (panic) by corrupting a mountpoint reference counter.",
        "id": 2438
    },
    {
        "cve_id": "CVE-2020-12114",
        "code_before_change": "void mnt_change_mountpoint(struct mount *parent, struct mountpoint *mp, struct mount *mnt)\n{\n\tstruct mountpoint *old_mp = mnt->mnt_mp;\n\tstruct dentry *old_mountpoint = mnt->mnt_mountpoint;\n\tstruct mount *old_parent = mnt->mnt_parent;\n\n\tlist_del_init(&mnt->mnt_child);\n\thlist_del_init(&mnt->mnt_mp_list);\n\thlist_del_init_rcu(&mnt->mnt_hash);\n\n\tattach_mnt(mnt, parent, mp);\n\n\tput_mountpoint(old_mp);\n\n\t/*\n\t * Safely avoid even the suggestion this code might sleep or\n\t * lock the mount hash by taking advantage of the knowledge that\n\t * mnt_change_mountpoint will not release the final reference\n\t * to a mountpoint.\n\t *\n\t * During mounting, the mount passed in as the parent mount will\n\t * continue to use the old mountpoint and during unmounting, the\n\t * old mountpoint will continue to exist until namespace_unlock,\n\t * which happens well after mnt_change_mountpoint.\n\t */\n\tspin_lock(&old_mountpoint->d_lock);\n\told_mountpoint->d_lockref.count--;\n\tspin_unlock(&old_mountpoint->d_lock);\n\n\tmnt_add_count(old_parent, -1);\n}",
        "code_after_change": "void mnt_change_mountpoint(struct mount *parent, struct mountpoint *mp, struct mount *mnt)\n{\n\tstruct mountpoint *old_mp = mnt->mnt_mp;\n\tstruct mount *old_parent = mnt->mnt_parent;\n\n\tlist_del_init(&mnt->mnt_child);\n\thlist_del_init(&mnt->mnt_mp_list);\n\thlist_del_init_rcu(&mnt->mnt_hash);\n\n\tattach_mnt(mnt, parent, mp);\n\n\tput_mountpoint(old_mp);\n\tmnt_add_count(old_parent, -1);\n}",
        "patch": "--- code before\n+++ code after\n@@ -1,7 +1,6 @@\n void mnt_change_mountpoint(struct mount *parent, struct mountpoint *mp, struct mount *mnt)\n {\n \tstruct mountpoint *old_mp = mnt->mnt_mp;\n-\tstruct dentry *old_mountpoint = mnt->mnt_mountpoint;\n \tstruct mount *old_parent = mnt->mnt_parent;\n \n \tlist_del_init(&mnt->mnt_child);\n@@ -11,21 +10,5 @@\n \tattach_mnt(mnt, parent, mp);\n \n \tput_mountpoint(old_mp);\n-\n-\t/*\n-\t * Safely avoid even the suggestion this code might sleep or\n-\t * lock the mount hash by taking advantage of the knowledge that\n-\t * mnt_change_mountpoint will not release the final reference\n-\t * to a mountpoint.\n-\t *\n-\t * During mounting, the mount passed in as the parent mount will\n-\t * continue to use the old mountpoint and during unmounting, the\n-\t * old mountpoint will continue to exist until namespace_unlock,\n-\t * which happens well after mnt_change_mountpoint.\n-\t */\n-\tspin_lock(&old_mountpoint->d_lock);\n-\told_mountpoint->d_lockref.count--;\n-\tspin_unlock(&old_mountpoint->d_lock);\n-\n \tmnt_add_count(old_parent, -1);\n }",
        "function_modified_lines": {
            "added": [],
            "deleted": [
                "\tstruct dentry *old_mountpoint = mnt->mnt_mountpoint;",
                "",
                "\t/*",
                "\t * Safely avoid even the suggestion this code might sleep or",
                "\t * lock the mount hash by taking advantage of the knowledge that",
                "\t * mnt_change_mountpoint will not release the final reference",
                "\t * to a mountpoint.",
                "\t *",
                "\t * During mounting, the mount passed in as the parent mount will",
                "\t * continue to use the old mountpoint and during unmounting, the",
                "\t * old mountpoint will continue to exist until namespace_unlock,",
                "\t * which happens well after mnt_change_mountpoint.",
                "\t */",
                "\tspin_lock(&old_mountpoint->d_lock);",
                "\told_mountpoint->d_lockref.count--;",
                "\tspin_unlock(&old_mountpoint->d_lock);",
                ""
            ]
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "A pivot_root race condition in fs/namespace.c in the Linux kernel 4.4.x before 4.4.221, 4.9.x before 4.9.221, 4.14.x before 4.14.178, 4.19.x before 4.19.119, and 5.x before 5.3 allows local users to cause a denial of service (panic) by corrupting a mountpoint reference counter.",
        "id": 2446
    },
    {
        "cve_id": "CVE-2020-11884",
        "code_before_change": "mm_segment_t enable_sacf_uaccess(void)\n{\n\tmm_segment_t old_fs;\n\tunsigned long asce, cr;\n\n\told_fs = current->thread.mm_segment;\n\tif (old_fs & 1)\n\t\treturn old_fs;\n\tcurrent->thread.mm_segment |= 1;\n\tasce = S390_lowcore.kernel_asce;\n\tif (likely(old_fs == USER_DS)) {\n\t\t__ctl_store(cr, 1, 1);\n\t\tif (cr != S390_lowcore.kernel_asce) {\n\t\t\t__ctl_load(S390_lowcore.kernel_asce, 1, 1);\n\t\t\tset_cpu_flag(CIF_ASCE_PRIMARY);\n\t\t}\n\t\tasce = S390_lowcore.user_asce;\n\t}\n\t__ctl_store(cr, 7, 7);\n\tif (cr != asce) {\n\t\t__ctl_load(asce, 7, 7);\n\t\tset_cpu_flag(CIF_ASCE_SECONDARY);\n\t}\n\treturn old_fs;\n}",
        "code_after_change": "mm_segment_t enable_sacf_uaccess(void)\n{\n\tmm_segment_t old_fs;\n\tunsigned long asce, cr;\n\tunsigned long flags;\n\n\told_fs = current->thread.mm_segment;\n\tif (old_fs & 1)\n\t\treturn old_fs;\n\t/* protect against a concurrent page table upgrade */\n\tlocal_irq_save(flags);\n\tcurrent->thread.mm_segment |= 1;\n\tasce = S390_lowcore.kernel_asce;\n\tif (likely(old_fs == USER_DS)) {\n\t\t__ctl_store(cr, 1, 1);\n\t\tif (cr != S390_lowcore.kernel_asce) {\n\t\t\t__ctl_load(S390_lowcore.kernel_asce, 1, 1);\n\t\t\tset_cpu_flag(CIF_ASCE_PRIMARY);\n\t\t}\n\t\tasce = S390_lowcore.user_asce;\n\t}\n\t__ctl_store(cr, 7, 7);\n\tif (cr != asce) {\n\t\t__ctl_load(asce, 7, 7);\n\t\tset_cpu_flag(CIF_ASCE_SECONDARY);\n\t}\n\tlocal_irq_restore(flags);\n\treturn old_fs;\n}",
        "patch": "--- code before\n+++ code after\n@@ -2,10 +2,13 @@\n {\n \tmm_segment_t old_fs;\n \tunsigned long asce, cr;\n+\tunsigned long flags;\n \n \told_fs = current->thread.mm_segment;\n \tif (old_fs & 1)\n \t\treturn old_fs;\n+\t/* protect against a concurrent page table upgrade */\n+\tlocal_irq_save(flags);\n \tcurrent->thread.mm_segment |= 1;\n \tasce = S390_lowcore.kernel_asce;\n \tif (likely(old_fs == USER_DS)) {\n@@ -21,5 +24,6 @@\n \t\t__ctl_load(asce, 7, 7);\n \t\tset_cpu_flag(CIF_ASCE_SECONDARY);\n \t}\n+\tlocal_irq_restore(flags);\n \treturn old_fs;\n }",
        "function_modified_lines": {
            "added": [
                "\tunsigned long flags;",
                "\t/* protect against a concurrent page table upgrade */",
                "\tlocal_irq_save(flags);",
                "\tlocal_irq_restore(flags);"
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "In the Linux kernel 4.19 through 5.6.7 on the s390 platform, code execution may occur because of a race condition, as demonstrated by code in enable_sacf_uaccess in arch/s390/lib/uaccess.c that fails to protect against a concurrent page table upgrade, aka CID-3f777e19d171. A crash could also occur.",
        "id": 2436
    },
    {
        "cve_id": "CVE-2016-2547",
        "code_before_change": "int snd_timer_close(struct snd_timer_instance *timeri)\n{\n\tstruct snd_timer *timer = NULL;\n\tstruct snd_timer_instance *slave, *tmp;\n\n\tif (snd_BUG_ON(!timeri))\n\t\treturn -ENXIO;\n\n\t/* force to stop the timer */\n\tsnd_timer_stop(timeri);\n\n\tif (timeri->flags & SNDRV_TIMER_IFLG_SLAVE) {\n\t\t/* wait, until the active callback is finished */\n\t\tspin_lock_irq(&slave_active_lock);\n\t\twhile (timeri->flags & SNDRV_TIMER_IFLG_CALLBACK) {\n\t\t\tspin_unlock_irq(&slave_active_lock);\n\t\t\tudelay(10);\n\t\t\tspin_lock_irq(&slave_active_lock);\n\t\t}\n\t\tspin_unlock_irq(&slave_active_lock);\n\t\tmutex_lock(&register_mutex);\n\t\tlist_del(&timeri->open_list);\n\t\tmutex_unlock(&register_mutex);\n\t} else {\n\t\ttimer = timeri->timer;\n\t\tif (snd_BUG_ON(!timer))\n\t\t\tgoto out;\n\t\t/* wait, until the active callback is finished */\n\t\tspin_lock_irq(&timer->lock);\n\t\twhile (timeri->flags & SNDRV_TIMER_IFLG_CALLBACK) {\n\t\t\tspin_unlock_irq(&timer->lock);\n\t\t\tudelay(10);\n\t\t\tspin_lock_irq(&timer->lock);\n\t\t}\n\t\tspin_unlock_irq(&timer->lock);\n\t\tmutex_lock(&register_mutex);\n\t\tlist_del(&timeri->open_list);\n\t\tif (timer && list_empty(&timer->open_list_head) &&\n\t\t    timer->hw.close)\n\t\t\ttimer->hw.close(timer);\n\t\t/* remove slave links */\n\t\tlist_for_each_entry_safe(slave, tmp, &timeri->slave_list_head,\n\t\t\t\t\t open_list) {\n\t\t\tspin_lock_irq(&slave_active_lock);\n\t\t\t_snd_timer_stop(slave, 1, SNDRV_TIMER_EVENT_RESOLUTION);\n\t\t\tlist_move_tail(&slave->open_list, &snd_timer_slave_list);\n\t\t\tslave->master = NULL;\n\t\t\tslave->timer = NULL;\n\t\t\tspin_unlock_irq(&slave_active_lock);\n\t\t}\n\t\tmutex_unlock(&register_mutex);\n\t}\n out:\n\tif (timeri->private_free)\n\t\ttimeri->private_free(timeri);\n\tkfree(timeri->owner);\n\tkfree(timeri);\n\tif (timer)\n\t\tmodule_put(timer->module);\n\treturn 0;\n}",
        "code_after_change": "int snd_timer_close(struct snd_timer_instance *timeri)\n{\n\tstruct snd_timer *timer = NULL;\n\tstruct snd_timer_instance *slave, *tmp;\n\n\tif (snd_BUG_ON(!timeri))\n\t\treturn -ENXIO;\n\n\t/* force to stop the timer */\n\tsnd_timer_stop(timeri);\n\n\tif (timeri->flags & SNDRV_TIMER_IFLG_SLAVE) {\n\t\t/* wait, until the active callback is finished */\n\t\tspin_lock_irq(&slave_active_lock);\n\t\twhile (timeri->flags & SNDRV_TIMER_IFLG_CALLBACK) {\n\t\t\tspin_unlock_irq(&slave_active_lock);\n\t\t\tudelay(10);\n\t\t\tspin_lock_irq(&slave_active_lock);\n\t\t}\n\t\tspin_unlock_irq(&slave_active_lock);\n\t\tmutex_lock(&register_mutex);\n\t\tlist_del(&timeri->open_list);\n\t\tmutex_unlock(&register_mutex);\n\t} else {\n\t\ttimer = timeri->timer;\n\t\tif (snd_BUG_ON(!timer))\n\t\t\tgoto out;\n\t\t/* wait, until the active callback is finished */\n\t\tspin_lock_irq(&timer->lock);\n\t\twhile (timeri->flags & SNDRV_TIMER_IFLG_CALLBACK) {\n\t\t\tspin_unlock_irq(&timer->lock);\n\t\t\tudelay(10);\n\t\t\tspin_lock_irq(&timer->lock);\n\t\t}\n\t\tspin_unlock_irq(&timer->lock);\n\t\tmutex_lock(&register_mutex);\n\t\tlist_del(&timeri->open_list);\n\t\tif (timer && list_empty(&timer->open_list_head) &&\n\t\t    timer->hw.close)\n\t\t\ttimer->hw.close(timer);\n\t\t/* remove slave links */\n\t\tspin_lock_irq(&slave_active_lock);\n\t\tspin_lock(&timer->lock);\n\t\tlist_for_each_entry_safe(slave, tmp, &timeri->slave_list_head,\n\t\t\t\t\t open_list) {\n\t\t\tlist_move_tail(&slave->open_list, &snd_timer_slave_list);\n\t\t\tslave->master = NULL;\n\t\t\tslave->timer = NULL;\n\t\t\tlist_del_init(&slave->ack_list);\n\t\t\tlist_del_init(&slave->active_list);\n\t\t}\n\t\tspin_unlock(&timer->lock);\n\t\tspin_unlock_irq(&slave_active_lock);\n\t\tmutex_unlock(&register_mutex);\n\t}\n out:\n\tif (timeri->private_free)\n\t\ttimeri->private_free(timeri);\n\tkfree(timeri->owner);\n\tkfree(timeri);\n\tif (timer)\n\t\tmodule_put(timer->module);\n\treturn 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -39,15 +39,18 @@\n \t\t    timer->hw.close)\n \t\t\ttimer->hw.close(timer);\n \t\t/* remove slave links */\n+\t\tspin_lock_irq(&slave_active_lock);\n+\t\tspin_lock(&timer->lock);\n \t\tlist_for_each_entry_safe(slave, tmp, &timeri->slave_list_head,\n \t\t\t\t\t open_list) {\n-\t\t\tspin_lock_irq(&slave_active_lock);\n-\t\t\t_snd_timer_stop(slave, 1, SNDRV_TIMER_EVENT_RESOLUTION);\n \t\t\tlist_move_tail(&slave->open_list, &snd_timer_slave_list);\n \t\t\tslave->master = NULL;\n \t\t\tslave->timer = NULL;\n-\t\t\tspin_unlock_irq(&slave_active_lock);\n+\t\t\tlist_del_init(&slave->ack_list);\n+\t\t\tlist_del_init(&slave->active_list);\n \t\t}\n+\t\tspin_unlock(&timer->lock);\n+\t\tspin_unlock_irq(&slave_active_lock);\n \t\tmutex_unlock(&register_mutex);\n \t}\n  out:",
        "function_modified_lines": {
            "added": [
                "\t\tspin_lock_irq(&slave_active_lock);",
                "\t\tspin_lock(&timer->lock);",
                "\t\t\tlist_del_init(&slave->ack_list);",
                "\t\t\tlist_del_init(&slave->active_list);",
                "\t\tspin_unlock(&timer->lock);",
                "\t\tspin_unlock_irq(&slave_active_lock);"
            ],
            "deleted": [
                "\t\t\tspin_lock_irq(&slave_active_lock);",
                "\t\t\t_snd_timer_stop(slave, 1, SNDRV_TIMER_EVENT_RESOLUTION);",
                "\t\t\tspin_unlock_irq(&slave_active_lock);"
            ]
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "sound/core/timer.c in the Linux kernel before 4.4.1 employs a locking approach that does not consider slave timer instances, which allows local users to cause a denial of service (race condition, use-after-free, and system crash) via a crafted ioctl call.",
        "id": 943
    },
    {
        "cve_id": "CVE-2016-2547",
        "code_before_change": "static void snd_timer_check_master(struct snd_timer_instance *master)\n{\n\tstruct snd_timer_instance *slave, *tmp;\n\n\t/* check all pending slaves */\n\tlist_for_each_entry_safe(slave, tmp, &snd_timer_slave_list, open_list) {\n\t\tif (slave->slave_class == master->slave_class &&\n\t\t    slave->slave_id == master->slave_id) {\n\t\t\tlist_move_tail(&slave->open_list, &master->slave_list_head);\n\t\t\tspin_lock_irq(&slave_active_lock);\n\t\t\tslave->master = master;\n\t\t\tslave->timer = master->timer;\n\t\t\tif (slave->flags & SNDRV_TIMER_IFLG_RUNNING)\n\t\t\t\tlist_add_tail(&slave->active_list,\n\t\t\t\t\t      &master->slave_active_head);\n\t\t\tspin_unlock_irq(&slave_active_lock);\n\t\t}\n\t}\n}",
        "code_after_change": "static void snd_timer_check_master(struct snd_timer_instance *master)\n{\n\tstruct snd_timer_instance *slave, *tmp;\n\n\t/* check all pending slaves */\n\tlist_for_each_entry_safe(slave, tmp, &snd_timer_slave_list, open_list) {\n\t\tif (slave->slave_class == master->slave_class &&\n\t\t    slave->slave_id == master->slave_id) {\n\t\t\tlist_move_tail(&slave->open_list, &master->slave_list_head);\n\t\t\tspin_lock_irq(&slave_active_lock);\n\t\t\tspin_lock(&master->timer->lock);\n\t\t\tslave->master = master;\n\t\t\tslave->timer = master->timer;\n\t\t\tif (slave->flags & SNDRV_TIMER_IFLG_RUNNING)\n\t\t\t\tlist_add_tail(&slave->active_list,\n\t\t\t\t\t      &master->slave_active_head);\n\t\t\tspin_unlock(&master->timer->lock);\n\t\t\tspin_unlock_irq(&slave_active_lock);\n\t\t}\n\t}\n}",
        "patch": "--- code before\n+++ code after\n@@ -8,11 +8,13 @@\n \t\t    slave->slave_id == master->slave_id) {\n \t\t\tlist_move_tail(&slave->open_list, &master->slave_list_head);\n \t\t\tspin_lock_irq(&slave_active_lock);\n+\t\t\tspin_lock(&master->timer->lock);\n \t\t\tslave->master = master;\n \t\t\tslave->timer = master->timer;\n \t\t\tif (slave->flags & SNDRV_TIMER_IFLG_RUNNING)\n \t\t\t\tlist_add_tail(&slave->active_list,\n \t\t\t\t\t      &master->slave_active_head);\n+\t\t\tspin_unlock(&master->timer->lock);\n \t\t\tspin_unlock_irq(&slave_active_lock);\n \t\t}\n \t}",
        "function_modified_lines": {
            "added": [
                "\t\t\tspin_lock(&master->timer->lock);",
                "\t\t\tspin_unlock(&master->timer->lock);"
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "sound/core/timer.c in the Linux kernel before 4.4.1 employs a locking approach that does not consider slave timer instances, which allows local users to cause a denial of service (race condition, use-after-free, and system crash) via a crafted ioctl call.",
        "id": 940
    },
    {
        "cve_id": "CVE-2016-2547",
        "code_before_change": "static int snd_timer_start_slave(struct snd_timer_instance *timeri)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&slave_active_lock, flags);\n\ttimeri->flags |= SNDRV_TIMER_IFLG_RUNNING;\n\tif (timeri->master)\n\t\tlist_add_tail(&timeri->active_list,\n\t\t\t      &timeri->master->slave_active_head);\n\tspin_unlock_irqrestore(&slave_active_lock, flags);\n\treturn 1; /* delayed start */\n}",
        "code_after_change": "static int snd_timer_start_slave(struct snd_timer_instance *timeri)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&slave_active_lock, flags);\n\ttimeri->flags |= SNDRV_TIMER_IFLG_RUNNING;\n\tif (timeri->master && timeri->timer) {\n\t\tspin_lock(&timeri->timer->lock);\n\t\tlist_add_tail(&timeri->active_list,\n\t\t\t      &timeri->master->slave_active_head);\n\t\tspin_unlock(&timeri->timer->lock);\n\t}\n\tspin_unlock_irqrestore(&slave_active_lock, flags);\n\treturn 1; /* delayed start */\n}",
        "patch": "--- code before\n+++ code after\n@@ -4,9 +4,12 @@\n \n \tspin_lock_irqsave(&slave_active_lock, flags);\n \ttimeri->flags |= SNDRV_TIMER_IFLG_RUNNING;\n-\tif (timeri->master)\n+\tif (timeri->master && timeri->timer) {\n+\t\tspin_lock(&timeri->timer->lock);\n \t\tlist_add_tail(&timeri->active_list,\n \t\t\t      &timeri->master->slave_active_head);\n+\t\tspin_unlock(&timeri->timer->lock);\n+\t}\n \tspin_unlock_irqrestore(&slave_active_lock, flags);\n \treturn 1; /* delayed start */\n }",
        "function_modified_lines": {
            "added": [
                "\tif (timeri->master && timeri->timer) {",
                "\t\tspin_lock(&timeri->timer->lock);",
                "\t\tspin_unlock(&timeri->timer->lock);",
                "\t}"
            ],
            "deleted": [
                "\tif (timeri->master)"
            ]
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "sound/core/timer.c in the Linux kernel before 4.4.1 employs a locking approach that does not consider slave timer instances, which allows local users to cause a denial of service (race condition, use-after-free, and system crash) via a crafted ioctl call.",
        "id": 941
    },
    {
        "cve_id": "CVE-2016-2546",
        "code_before_change": "static int snd_timer_user_tselect(struct file *file,\n\t\t\t\t  struct snd_timer_select __user *_tselect)\n{\n\tstruct snd_timer_user *tu;\n\tstruct snd_timer_select tselect;\n\tchar str[32];\n\tint err = 0;\n\n\ttu = file->private_data;\n\tmutex_lock(&tu->tread_sem);\n\tif (tu->timeri) {\n\t\tsnd_timer_close(tu->timeri);\n\t\ttu->timeri = NULL;\n\t}\n\tif (copy_from_user(&tselect, _tselect, sizeof(tselect))) {\n\t\terr = -EFAULT;\n\t\tgoto __err;\n\t}\n\tsprintf(str, \"application %i\", current->pid);\n\tif (tselect.id.dev_class != SNDRV_TIMER_CLASS_SLAVE)\n\t\ttselect.id.dev_sclass = SNDRV_TIMER_SCLASS_APPLICATION;\n\terr = snd_timer_open(&tu->timeri, str, &tselect.id, current->pid);\n\tif (err < 0)\n\t\tgoto __err;\n\n\tkfree(tu->queue);\n\ttu->queue = NULL;\n\tkfree(tu->tqueue);\n\ttu->tqueue = NULL;\n\tif (tu->tread) {\n\t\ttu->tqueue = kmalloc(tu->queue_size * sizeof(struct snd_timer_tread),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (tu->tqueue == NULL)\n\t\t\terr = -ENOMEM;\n\t} else {\n\t\ttu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),\n\t\t\t\t    GFP_KERNEL);\n\t\tif (tu->queue == NULL)\n\t\t\terr = -ENOMEM;\n\t}\n\n      \tif (err < 0) {\n\t\tsnd_timer_close(tu->timeri);\n      \t\ttu->timeri = NULL;\n      \t} else {\n\t\ttu->timeri->flags |= SNDRV_TIMER_IFLG_FAST;\n\t\ttu->timeri->callback = tu->tread\n\t\t\t? snd_timer_user_tinterrupt : snd_timer_user_interrupt;\n\t\ttu->timeri->ccallback = snd_timer_user_ccallback;\n\t\ttu->timeri->callback_data = (void *)tu;\n\t}\n\n      __err:\n      \tmutex_unlock(&tu->tread_sem);\n\treturn err;\n}",
        "code_after_change": "static int snd_timer_user_tselect(struct file *file,\n\t\t\t\t  struct snd_timer_select __user *_tselect)\n{\n\tstruct snd_timer_user *tu;\n\tstruct snd_timer_select tselect;\n\tchar str[32];\n\tint err = 0;\n\n\ttu = file->private_data;\n\tif (tu->timeri) {\n\t\tsnd_timer_close(tu->timeri);\n\t\ttu->timeri = NULL;\n\t}\n\tif (copy_from_user(&tselect, _tselect, sizeof(tselect))) {\n\t\terr = -EFAULT;\n\t\tgoto __err;\n\t}\n\tsprintf(str, \"application %i\", current->pid);\n\tif (tselect.id.dev_class != SNDRV_TIMER_CLASS_SLAVE)\n\t\ttselect.id.dev_sclass = SNDRV_TIMER_SCLASS_APPLICATION;\n\terr = snd_timer_open(&tu->timeri, str, &tselect.id, current->pid);\n\tif (err < 0)\n\t\tgoto __err;\n\n\tkfree(tu->queue);\n\ttu->queue = NULL;\n\tkfree(tu->tqueue);\n\ttu->tqueue = NULL;\n\tif (tu->tread) {\n\t\ttu->tqueue = kmalloc(tu->queue_size * sizeof(struct snd_timer_tread),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (tu->tqueue == NULL)\n\t\t\terr = -ENOMEM;\n\t} else {\n\t\ttu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),\n\t\t\t\t    GFP_KERNEL);\n\t\tif (tu->queue == NULL)\n\t\t\terr = -ENOMEM;\n\t}\n\n      \tif (err < 0) {\n\t\tsnd_timer_close(tu->timeri);\n      \t\ttu->timeri = NULL;\n      \t} else {\n\t\ttu->timeri->flags |= SNDRV_TIMER_IFLG_FAST;\n\t\ttu->timeri->callback = tu->tread\n\t\t\t? snd_timer_user_tinterrupt : snd_timer_user_interrupt;\n\t\ttu->timeri->ccallback = snd_timer_user_ccallback;\n\t\ttu->timeri->callback_data = (void *)tu;\n\t}\n\n      __err:\n\treturn err;\n}",
        "patch": "--- code before\n+++ code after\n@@ -7,7 +7,6 @@\n \tint err = 0;\n \n \ttu = file->private_data;\n-\tmutex_lock(&tu->tread_sem);\n \tif (tu->timeri) {\n \t\tsnd_timer_close(tu->timeri);\n \t\ttu->timeri = NULL;\n@@ -51,6 +50,5 @@\n \t}\n \n       __err:\n-      \tmutex_unlock(&tu->tread_sem);\n \treturn err;\n }",
        "function_modified_lines": {
            "added": [],
            "deleted": [
                "\tmutex_lock(&tu->tread_sem);",
                "      \tmutex_unlock(&tu->tread_sem);"
            ]
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "sound/core/timer.c in the Linux kernel before 4.4.1 uses an incorrect type of mutex, which allows local users to cause a denial of service (race condition, use-after-free, and system crash) via a crafted ioctl call.",
        "id": 936
    },
    {
        "cve_id": "CVE-2014-2706",
        "code_before_change": "void ieee80211_sta_ps_deliver_wakeup(struct sta_info *sta)\n{\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sk_buff_head pending;\n\tint filtered = 0, buffered = 0, ac;\n\tunsigned long flags;\n\n\tclear_sta_flag(sta, WLAN_STA_SP);\n\n\tBUILD_BUG_ON(BITS_TO_LONGS(IEEE80211_NUM_TIDS) > 1);\n\tsta->driver_buffered_tids = 0;\n\n\tif (!(local->hw.flags & IEEE80211_HW_AP_LINK_PS))\n\t\tdrv_sta_notify(local, sdata, STA_NOTIFY_AWAKE, &sta->sta);\n\n\tskb_queue_head_init(&pending);\n\n\t/* Send all buffered frames to the station */\n\tfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {\n\t\tint count = skb_queue_len(&pending), tmp;\n\n\t\tspin_lock_irqsave(&sta->tx_filtered[ac].lock, flags);\n\t\tskb_queue_splice_tail_init(&sta->tx_filtered[ac], &pending);\n\t\tspin_unlock_irqrestore(&sta->tx_filtered[ac].lock, flags);\n\t\ttmp = skb_queue_len(&pending);\n\t\tfiltered += tmp - count;\n\t\tcount = tmp;\n\n\t\tspin_lock_irqsave(&sta->ps_tx_buf[ac].lock, flags);\n\t\tskb_queue_splice_tail_init(&sta->ps_tx_buf[ac], &pending);\n\t\tspin_unlock_irqrestore(&sta->ps_tx_buf[ac].lock, flags);\n\t\ttmp = skb_queue_len(&pending);\n\t\tbuffered += tmp - count;\n\t}\n\n\tieee80211_add_pending_skbs_fn(local, &pending, clear_sta_ps_flags, sta);\n\n\t/* This station just woke up and isn't aware of our SMPS state */\n\tif (!ieee80211_smps_is_restrictive(sta->known_smps_mode,\n\t\t\t\t\t   sdata->smps_mode) &&\n\t    sta->known_smps_mode != sdata->bss->req_smps &&\n\t    sta_info_tx_streams(sta) != 1) {\n\t\tht_dbg(sdata,\n\t\t       \"%pM just woke up and MIMO capable - update SMPS\\n\",\n\t\t       sta->sta.addr);\n\t\tieee80211_send_smps_action(sdata, sdata->bss->req_smps,\n\t\t\t\t\t   sta->sta.addr,\n\t\t\t\t\t   sdata->vif.bss_conf.bssid);\n\t}\n\n\tlocal->total_ps_buffered -= buffered;\n\n\tsta_info_recalc_tim(sta);\n\n\tps_dbg(sdata,\n\t       \"STA %pM aid %d sending %d filtered/%d PS frames since STA not sleeping anymore\\n\",\n\t       sta->sta.addr, sta->sta.aid, filtered, buffered);\n}",
        "code_after_change": "void ieee80211_sta_ps_deliver_wakeup(struct sta_info *sta)\n{\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sk_buff_head pending;\n\tint filtered = 0, buffered = 0, ac;\n\tunsigned long flags;\n\n\tclear_sta_flag(sta, WLAN_STA_SP);\n\n\tBUILD_BUG_ON(BITS_TO_LONGS(IEEE80211_NUM_TIDS) > 1);\n\tsta->driver_buffered_tids = 0;\n\n\tif (!(local->hw.flags & IEEE80211_HW_AP_LINK_PS))\n\t\tdrv_sta_notify(local, sdata, STA_NOTIFY_AWAKE, &sta->sta);\n\n\tskb_queue_head_init(&pending);\n\n\t/* sync with ieee80211_tx_h_unicast_ps_buf */\n\tspin_lock(&sta->ps_lock);\n\t/* Send all buffered frames to the station */\n\tfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {\n\t\tint count = skb_queue_len(&pending), tmp;\n\n\t\tspin_lock_irqsave(&sta->tx_filtered[ac].lock, flags);\n\t\tskb_queue_splice_tail_init(&sta->tx_filtered[ac], &pending);\n\t\tspin_unlock_irqrestore(&sta->tx_filtered[ac].lock, flags);\n\t\ttmp = skb_queue_len(&pending);\n\t\tfiltered += tmp - count;\n\t\tcount = tmp;\n\n\t\tspin_lock_irqsave(&sta->ps_tx_buf[ac].lock, flags);\n\t\tskb_queue_splice_tail_init(&sta->ps_tx_buf[ac], &pending);\n\t\tspin_unlock_irqrestore(&sta->ps_tx_buf[ac].lock, flags);\n\t\ttmp = skb_queue_len(&pending);\n\t\tbuffered += tmp - count;\n\t}\n\n\tieee80211_add_pending_skbs_fn(local, &pending, clear_sta_ps_flags, sta);\n\tspin_unlock(&sta->ps_lock);\n\n\t/* This station just woke up and isn't aware of our SMPS state */\n\tif (!ieee80211_smps_is_restrictive(sta->known_smps_mode,\n\t\t\t\t\t   sdata->smps_mode) &&\n\t    sta->known_smps_mode != sdata->bss->req_smps &&\n\t    sta_info_tx_streams(sta) != 1) {\n\t\tht_dbg(sdata,\n\t\t       \"%pM just woke up and MIMO capable - update SMPS\\n\",\n\t\t       sta->sta.addr);\n\t\tieee80211_send_smps_action(sdata, sdata->bss->req_smps,\n\t\t\t\t\t   sta->sta.addr,\n\t\t\t\t\t   sdata->vif.bss_conf.bssid);\n\t}\n\n\tlocal->total_ps_buffered -= buffered;\n\n\tsta_info_recalc_tim(sta);\n\n\tps_dbg(sdata,\n\t       \"STA %pM aid %d sending %d filtered/%d PS frames since STA not sleeping anymore\\n\",\n\t       sta->sta.addr, sta->sta.aid, filtered, buffered);\n}",
        "patch": "--- code before\n+++ code after\n@@ -16,6 +16,8 @@\n \n \tskb_queue_head_init(&pending);\n \n+\t/* sync with ieee80211_tx_h_unicast_ps_buf */\n+\tspin_lock(&sta->ps_lock);\n \t/* Send all buffered frames to the station */\n \tfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {\n \t\tint count = skb_queue_len(&pending), tmp;\n@@ -35,6 +37,7 @@\n \t}\n \n \tieee80211_add_pending_skbs_fn(local, &pending, clear_sta_ps_flags, sta);\n+\tspin_unlock(&sta->ps_lock);\n \n \t/* This station just woke up and isn't aware of our SMPS state */\n \tif (!ieee80211_smps_is_restrictive(sta->known_smps_mode,",
        "function_modified_lines": {
            "added": [
                "\t/* sync with ieee80211_tx_h_unicast_ps_buf */",
                "\tspin_lock(&sta->ps_lock);",
                "\tspin_unlock(&sta->ps_lock);"
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "Race condition in the mac80211 subsystem in the Linux kernel before 3.13.7 allows remote attackers to cause a denial of service (system crash) via network traffic that improperly interacts with the WLAN_STA_PS_STA state (aka power-save mode), related to sta_info.c and tx.c.",
        "id": 495
    },
    {
        "cve_id": "CVE-2013-0871",
        "code_before_change": "int ptrace_request(struct task_struct *child, long request,\n\t\t   unsigned long addr, unsigned long data)\n{\n\tbool seized = child->ptrace & PT_SEIZED;\n\tint ret = -EIO;\n\tsiginfo_t siginfo, *si;\n\tvoid __user *datavp = (void __user *) data;\n\tunsigned long __user *datalp = datavp;\n\tunsigned long flags;\n\n\tswitch (request) {\n\tcase PTRACE_PEEKTEXT:\n\tcase PTRACE_PEEKDATA:\n\t\treturn generic_ptrace_peekdata(child, addr, data);\n\tcase PTRACE_POKETEXT:\n\tcase PTRACE_POKEDATA:\n\t\treturn generic_ptrace_pokedata(child, addr, data);\n\n#ifdef PTRACE_OLDSETOPTIONS\n\tcase PTRACE_OLDSETOPTIONS:\n#endif\n\tcase PTRACE_SETOPTIONS:\n\t\tret = ptrace_setoptions(child, data);\n\t\tbreak;\n\tcase PTRACE_GETEVENTMSG:\n\t\tret = put_user(child->ptrace_message, datalp);\n\t\tbreak;\n\n\tcase PTRACE_GETSIGINFO:\n\t\tret = ptrace_getsiginfo(child, &siginfo);\n\t\tif (!ret)\n\t\t\tret = copy_siginfo_to_user(datavp, &siginfo);\n\t\tbreak;\n\n\tcase PTRACE_SETSIGINFO:\n\t\tif (copy_from_user(&siginfo, datavp, sizeof siginfo))\n\t\t\tret = -EFAULT;\n\t\telse\n\t\t\tret = ptrace_setsiginfo(child, &siginfo);\n\t\tbreak;\n\n\tcase PTRACE_INTERRUPT:\n\t\t/*\n\t\t * Stop tracee without any side-effect on signal or job\n\t\t * control.  At least one trap is guaranteed to happen\n\t\t * after this request.  If @child is already trapped, the\n\t\t * current trap is not disturbed and another trap will\n\t\t * happen after the current trap is ended with PTRACE_CONT.\n\t\t *\n\t\t * The actual trap might not be PTRACE_EVENT_STOP trap but\n\t\t * the pending condition is cleared regardless.\n\t\t */\n\t\tif (unlikely(!seized || !lock_task_sighand(child, &flags)))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * INTERRUPT doesn't disturb existing trap sans one\n\t\t * exception.  If ptracer issued LISTEN for the current\n\t\t * STOP, this INTERRUPT should clear LISTEN and re-trap\n\t\t * tracee into STOP.\n\t\t */\n\t\tif (likely(task_set_jobctl_pending(child, JOBCTL_TRAP_STOP)))\n\t\t\tsignal_wake_up(child, child->jobctl & JOBCTL_LISTENING);\n\n\t\tunlock_task_sighand(child, &flags);\n\t\tret = 0;\n\t\tbreak;\n\n\tcase PTRACE_LISTEN:\n\t\t/*\n\t\t * Listen for events.  Tracee must be in STOP.  It's not\n\t\t * resumed per-se but is not considered to be in TRACED by\n\t\t * wait(2) or ptrace(2).  If an async event (e.g. group\n\t\t * stop state change) happens, tracee will enter STOP trap\n\t\t * again.  Alternatively, ptracer can issue INTERRUPT to\n\t\t * finish listening and re-trap tracee into STOP.\n\t\t */\n\t\tif (unlikely(!seized || !lock_task_sighand(child, &flags)))\n\t\t\tbreak;\n\n\t\tsi = child->last_siginfo;\n\t\tif (likely(si && (si->si_code >> 8) == PTRACE_EVENT_STOP)) {\n\t\t\tchild->jobctl |= JOBCTL_LISTENING;\n\t\t\t/*\n\t\t\t * If NOTIFY is set, it means event happened between\n\t\t\t * start of this trap and now.  Trigger re-trap.\n\t\t\t */\n\t\t\tif (child->jobctl & JOBCTL_TRAP_NOTIFY)\n\t\t\t\tsignal_wake_up(child, true);\n\t\t\tret = 0;\n\t\t}\n\t\tunlock_task_sighand(child, &flags);\n\t\tbreak;\n\n\tcase PTRACE_DETACH:\t /* detach a process that was attached. */\n\t\tret = ptrace_detach(child, data);\n\t\tbreak;\n\n#ifdef CONFIG_BINFMT_ELF_FDPIC\n\tcase PTRACE_GETFDPIC: {\n\t\tstruct mm_struct *mm = get_task_mm(child);\n\t\tunsigned long tmp = 0;\n\n\t\tret = -ESRCH;\n\t\tif (!mm)\n\t\t\tbreak;\n\n\t\tswitch (addr) {\n\t\tcase PTRACE_GETFDPIC_EXEC:\n\t\t\ttmp = mm->context.exec_fdpic_loadmap;\n\t\t\tbreak;\n\t\tcase PTRACE_GETFDPIC_INTERP:\n\t\t\ttmp = mm->context.interp_fdpic_loadmap;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tmmput(mm);\n\n\t\tret = put_user(tmp, datalp);\n\t\tbreak;\n\t}\n#endif\n\n#ifdef PTRACE_SINGLESTEP\n\tcase PTRACE_SINGLESTEP:\n#endif\n#ifdef PTRACE_SINGLEBLOCK\n\tcase PTRACE_SINGLEBLOCK:\n#endif\n#ifdef PTRACE_SYSEMU\n\tcase PTRACE_SYSEMU:\n\tcase PTRACE_SYSEMU_SINGLESTEP:\n#endif\n\tcase PTRACE_SYSCALL:\n\tcase PTRACE_CONT:\n\t\treturn ptrace_resume(child, request, data);\n\n\tcase PTRACE_KILL:\n\t\tif (child->exit_state)\t/* already dead */\n\t\t\treturn 0;\n\t\treturn ptrace_resume(child, request, SIGKILL);\n\n#ifdef CONFIG_HAVE_ARCH_TRACEHOOK\n\tcase PTRACE_GETREGSET:\n\tcase PTRACE_SETREGSET:\n\t{\n\t\tstruct iovec kiov;\n\t\tstruct iovec __user *uiov = datavp;\n\n\t\tif (!access_ok(VERIFY_WRITE, uiov, sizeof(*uiov)))\n\t\t\treturn -EFAULT;\n\n\t\tif (__get_user(kiov.iov_base, &uiov->iov_base) ||\n\t\t    __get_user(kiov.iov_len, &uiov->iov_len))\n\t\t\treturn -EFAULT;\n\n\t\tret = ptrace_regset(child, request, addr, &kiov);\n\t\tif (!ret)\n\t\t\tret = __put_user(kiov.iov_len, &uiov->iov_len);\n\t\tbreak;\n\t}\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}",
        "code_after_change": "int ptrace_request(struct task_struct *child, long request,\n\t\t   unsigned long addr, unsigned long data)\n{\n\tbool seized = child->ptrace & PT_SEIZED;\n\tint ret = -EIO;\n\tsiginfo_t siginfo, *si;\n\tvoid __user *datavp = (void __user *) data;\n\tunsigned long __user *datalp = datavp;\n\tunsigned long flags;\n\n\tswitch (request) {\n\tcase PTRACE_PEEKTEXT:\n\tcase PTRACE_PEEKDATA:\n\t\treturn generic_ptrace_peekdata(child, addr, data);\n\tcase PTRACE_POKETEXT:\n\tcase PTRACE_POKEDATA:\n\t\treturn generic_ptrace_pokedata(child, addr, data);\n\n#ifdef PTRACE_OLDSETOPTIONS\n\tcase PTRACE_OLDSETOPTIONS:\n#endif\n\tcase PTRACE_SETOPTIONS:\n\t\tret = ptrace_setoptions(child, data);\n\t\tbreak;\n\tcase PTRACE_GETEVENTMSG:\n\t\tret = put_user(child->ptrace_message, datalp);\n\t\tbreak;\n\n\tcase PTRACE_GETSIGINFO:\n\t\tret = ptrace_getsiginfo(child, &siginfo);\n\t\tif (!ret)\n\t\t\tret = copy_siginfo_to_user(datavp, &siginfo);\n\t\tbreak;\n\n\tcase PTRACE_SETSIGINFO:\n\t\tif (copy_from_user(&siginfo, datavp, sizeof siginfo))\n\t\t\tret = -EFAULT;\n\t\telse\n\t\t\tret = ptrace_setsiginfo(child, &siginfo);\n\t\tbreak;\n\n\tcase PTRACE_INTERRUPT:\n\t\t/*\n\t\t * Stop tracee without any side-effect on signal or job\n\t\t * control.  At least one trap is guaranteed to happen\n\t\t * after this request.  If @child is already trapped, the\n\t\t * current trap is not disturbed and another trap will\n\t\t * happen after the current trap is ended with PTRACE_CONT.\n\t\t *\n\t\t * The actual trap might not be PTRACE_EVENT_STOP trap but\n\t\t * the pending condition is cleared regardless.\n\t\t */\n\t\tif (unlikely(!seized || !lock_task_sighand(child, &flags)))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * INTERRUPT doesn't disturb existing trap sans one\n\t\t * exception.  If ptracer issued LISTEN for the current\n\t\t * STOP, this INTERRUPT should clear LISTEN and re-trap\n\t\t * tracee into STOP.\n\t\t */\n\t\tif (likely(task_set_jobctl_pending(child, JOBCTL_TRAP_STOP)))\n\t\t\tptrace_signal_wake_up(child, child->jobctl & JOBCTL_LISTENING);\n\n\t\tunlock_task_sighand(child, &flags);\n\t\tret = 0;\n\t\tbreak;\n\n\tcase PTRACE_LISTEN:\n\t\t/*\n\t\t * Listen for events.  Tracee must be in STOP.  It's not\n\t\t * resumed per-se but is not considered to be in TRACED by\n\t\t * wait(2) or ptrace(2).  If an async event (e.g. group\n\t\t * stop state change) happens, tracee will enter STOP trap\n\t\t * again.  Alternatively, ptracer can issue INTERRUPT to\n\t\t * finish listening and re-trap tracee into STOP.\n\t\t */\n\t\tif (unlikely(!seized || !lock_task_sighand(child, &flags)))\n\t\t\tbreak;\n\n\t\tsi = child->last_siginfo;\n\t\tif (likely(si && (si->si_code >> 8) == PTRACE_EVENT_STOP)) {\n\t\t\tchild->jobctl |= JOBCTL_LISTENING;\n\t\t\t/*\n\t\t\t * If NOTIFY is set, it means event happened between\n\t\t\t * start of this trap and now.  Trigger re-trap.\n\t\t\t */\n\t\t\tif (child->jobctl & JOBCTL_TRAP_NOTIFY)\n\t\t\t\tptrace_signal_wake_up(child, true);\n\t\t\tret = 0;\n\t\t}\n\t\tunlock_task_sighand(child, &flags);\n\t\tbreak;\n\n\tcase PTRACE_DETACH:\t /* detach a process that was attached. */\n\t\tret = ptrace_detach(child, data);\n\t\tbreak;\n\n#ifdef CONFIG_BINFMT_ELF_FDPIC\n\tcase PTRACE_GETFDPIC: {\n\t\tstruct mm_struct *mm = get_task_mm(child);\n\t\tunsigned long tmp = 0;\n\n\t\tret = -ESRCH;\n\t\tif (!mm)\n\t\t\tbreak;\n\n\t\tswitch (addr) {\n\t\tcase PTRACE_GETFDPIC_EXEC:\n\t\t\ttmp = mm->context.exec_fdpic_loadmap;\n\t\t\tbreak;\n\t\tcase PTRACE_GETFDPIC_INTERP:\n\t\t\ttmp = mm->context.interp_fdpic_loadmap;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tmmput(mm);\n\n\t\tret = put_user(tmp, datalp);\n\t\tbreak;\n\t}\n#endif\n\n#ifdef PTRACE_SINGLESTEP\n\tcase PTRACE_SINGLESTEP:\n#endif\n#ifdef PTRACE_SINGLEBLOCK\n\tcase PTRACE_SINGLEBLOCK:\n#endif\n#ifdef PTRACE_SYSEMU\n\tcase PTRACE_SYSEMU:\n\tcase PTRACE_SYSEMU_SINGLESTEP:\n#endif\n\tcase PTRACE_SYSCALL:\n\tcase PTRACE_CONT:\n\t\treturn ptrace_resume(child, request, data);\n\n\tcase PTRACE_KILL:\n\t\tif (child->exit_state)\t/* already dead */\n\t\t\treturn 0;\n\t\treturn ptrace_resume(child, request, SIGKILL);\n\n#ifdef CONFIG_HAVE_ARCH_TRACEHOOK\n\tcase PTRACE_GETREGSET:\n\tcase PTRACE_SETREGSET:\n\t{\n\t\tstruct iovec kiov;\n\t\tstruct iovec __user *uiov = datavp;\n\n\t\tif (!access_ok(VERIFY_WRITE, uiov, sizeof(*uiov)))\n\t\t\treturn -EFAULT;\n\n\t\tif (__get_user(kiov.iov_base, &uiov->iov_base) ||\n\t\t    __get_user(kiov.iov_len, &uiov->iov_len))\n\t\t\treturn -EFAULT;\n\n\t\tret = ptrace_regset(child, request, addr, &kiov);\n\t\tif (!ret)\n\t\t\tret = __put_user(kiov.iov_len, &uiov->iov_len);\n\t\tbreak;\n\t}\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}",
        "patch": "--- code before\n+++ code after\n@@ -60,7 +60,7 @@\n \t\t * tracee into STOP.\n \t\t */\n \t\tif (likely(task_set_jobctl_pending(child, JOBCTL_TRAP_STOP)))\n-\t\t\tsignal_wake_up(child, child->jobctl & JOBCTL_LISTENING);\n+\t\t\tptrace_signal_wake_up(child, child->jobctl & JOBCTL_LISTENING);\n \n \t\tunlock_task_sighand(child, &flags);\n \t\tret = 0;\n@@ -86,7 +86,7 @@\n \t\t\t * start of this trap and now.  Trigger re-trap.\n \t\t\t */\n \t\t\tif (child->jobctl & JOBCTL_TRAP_NOTIFY)\n-\t\t\t\tsignal_wake_up(child, true);\n+\t\t\t\tptrace_signal_wake_up(child, true);\n \t\t\tret = 0;\n \t\t}\n \t\tunlock_task_sighand(child, &flags);",
        "function_modified_lines": {
            "added": [
                "\t\t\tptrace_signal_wake_up(child, child->jobctl & JOBCTL_LISTENING);",
                "\t\t\t\tptrace_signal_wake_up(child, true);"
            ],
            "deleted": [
                "\t\t\tsignal_wake_up(child, child->jobctl & JOBCTL_LISTENING);",
                "\t\t\t\tsignal_wake_up(child, true);"
            ]
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "Race condition in the ptrace functionality in the Linux kernel before 3.7.5 allows local users to gain privileges via a PTRACE_SETREGS ptrace system call in a crafted application, as demonstrated by ptrace_death.",
        "id": 162
    },
    {
        "cve_id": "CVE-2019-2213",
        "code_before_change": "static void\nbinder_free_buf(struct binder_proc *proc, struct binder_buffer *buffer)\n{\n\tif (buffer->transaction) {\n\t\tbuffer->transaction->buffer = NULL;\n\t\tbuffer->transaction = NULL;\n\t}\n\tif (buffer->async_transaction && buffer->target_node) {\n\t\tstruct binder_node *buf_node;\n\t\tstruct binder_work *w;\n\n\t\tbuf_node = buffer->target_node;\n\t\tbinder_node_inner_lock(buf_node);\n\t\tBUG_ON(!buf_node->has_async_transaction);\n\t\tBUG_ON(buf_node->proc != proc);\n\t\tw = binder_dequeue_work_head_ilocked(\n\t\t\t\t&buf_node->async_todo);\n\t\tif (!w) {\n\t\t\tbuf_node->has_async_transaction = false;\n\t\t} else {\n\t\t\tbinder_enqueue_work_ilocked(\n\t\t\t\t\tw, &proc->todo);\n\t\t\tbinder_wakeup_proc_ilocked(proc);\n\t\t}\n\t\tbinder_node_inner_unlock(buf_node);\n\t}\n\ttrace_binder_transaction_buffer_release(buffer);\n\tbinder_transaction_buffer_release(proc, buffer, 0, false);\n\tbinder_alloc_free_buf(&proc->alloc, buffer);\n}",
        "code_after_change": "static void\nbinder_free_buf(struct binder_proc *proc, struct binder_buffer *buffer)\n{\n\tbinder_inner_proc_lock(proc);\n\tif (buffer->transaction) {\n\t\tbuffer->transaction->buffer = NULL;\n\t\tbuffer->transaction = NULL;\n\t}\n\tbinder_inner_proc_unlock(proc);\n\tif (buffer->async_transaction && buffer->target_node) {\n\t\tstruct binder_node *buf_node;\n\t\tstruct binder_work *w;\n\n\t\tbuf_node = buffer->target_node;\n\t\tbinder_node_inner_lock(buf_node);\n\t\tBUG_ON(!buf_node->has_async_transaction);\n\t\tBUG_ON(buf_node->proc != proc);\n\t\tw = binder_dequeue_work_head_ilocked(\n\t\t\t\t&buf_node->async_todo);\n\t\tif (!w) {\n\t\t\tbuf_node->has_async_transaction = false;\n\t\t} else {\n\t\t\tbinder_enqueue_work_ilocked(\n\t\t\t\t\tw, &proc->todo);\n\t\t\tbinder_wakeup_proc_ilocked(proc);\n\t\t}\n\t\tbinder_node_inner_unlock(buf_node);\n\t}\n\ttrace_binder_transaction_buffer_release(buffer);\n\tbinder_transaction_buffer_release(proc, buffer, 0, false);\n\tbinder_alloc_free_buf(&proc->alloc, buffer);\n}",
        "patch": "--- code before\n+++ code after\n@@ -1,10 +1,12 @@\n static void\n binder_free_buf(struct binder_proc *proc, struct binder_buffer *buffer)\n {\n+\tbinder_inner_proc_lock(proc);\n \tif (buffer->transaction) {\n \t\tbuffer->transaction->buffer = NULL;\n \t\tbuffer->transaction = NULL;\n \t}\n+\tbinder_inner_proc_unlock(proc);\n \tif (buffer->async_transaction && buffer->target_node) {\n \t\tstruct binder_node *buf_node;\n \t\tstruct binder_work *w;",
        "function_modified_lines": {
            "added": [
                "\tbinder_inner_proc_lock(proc);",
                "\tbinder_inner_proc_unlock(proc);"
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-362",
            "CWE-416"
        ],
        "cve_description": "In binder_free_transaction of binder.c, there is a possible use-after-free due to a race condition. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-133758011References: Upstream kernel",
        "id": 2295
    },
    {
        "cve_id": "CVE-2018-12232",
        "code_before_change": "static int sockfs_setattr(struct dentry *dentry, struct iattr *iattr)\n{\n\tint err = simple_setattr(dentry, iattr);\n\n\tif (!err && (iattr->ia_valid & ATTR_UID)) {\n\t\tstruct socket *sock = SOCKET_I(d_inode(dentry));\n\n\t\tsock->sk->sk_uid = iattr->ia_uid;\n\t}\n\n\treturn err;\n}",
        "code_after_change": "static int sockfs_setattr(struct dentry *dentry, struct iattr *iattr)\n{\n\tint err = simple_setattr(dentry, iattr);\n\n\tif (!err && (iattr->ia_valid & ATTR_UID)) {\n\t\tstruct socket *sock = SOCKET_I(d_inode(dentry));\n\n\t\tif (sock->sk)\n\t\t\tsock->sk->sk_uid = iattr->ia_uid;\n\t\telse\n\t\t\terr = -ENOENT;\n\t}\n\n\treturn err;\n}",
        "patch": "--- code before\n+++ code after\n@@ -5,7 +5,10 @@\n \tif (!err && (iattr->ia_valid & ATTR_UID)) {\n \t\tstruct socket *sock = SOCKET_I(d_inode(dentry));\n \n-\t\tsock->sk->sk_uid = iattr->ia_uid;\n+\t\tif (sock->sk)\n+\t\t\tsock->sk->sk_uid = iattr->ia_uid;\n+\t\telse\n+\t\t\terr = -ENOENT;\n \t}\n \n \treturn err;",
        "function_modified_lines": {
            "added": [
                "\t\tif (sock->sk)",
                "\t\t\tsock->sk->sk_uid = iattr->ia_uid;",
                "\t\telse",
                "\t\t\terr = -ENOENT;"
            ],
            "deleted": [
                "\t\tsock->sk->sk_uid = iattr->ia_uid;"
            ]
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "In net/socket.c in the Linux kernel through 4.17.1, there is a race condition between fchownat and close in cases where they target the same socket file descriptor, related to the sock_close and sockfs_setattr functions. fchownat does not increment the file descriptor reference count, which allows close to set the socket to NULL during fchownat's execution, leading to a NULL pointer dereference and system crash.",
        "id": 1649
    },
    {
        "cve_id": "CVE-2016-10200",
        "code_before_change": "static int l2tp_ip6_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sockaddr_l2tpip6 *addr = (struct sockaddr_l2tpip6 *) uaddr;\n\tstruct net *net = sock_net(sk);\n\t__be32 v4addr = 0;\n\tint addr_type;\n\tint err;\n\n\tif (!sock_flag(sk, SOCK_ZAPPED))\n\t\treturn -EINVAL;\n\tif (addr->l2tp_family != AF_INET6)\n\t\treturn -EINVAL;\n\tif (addr_len < sizeof(*addr))\n\t\treturn -EINVAL;\n\n\taddr_type = ipv6_addr_type(&addr->l2tp_addr);\n\n\t/* l2tp_ip6 sockets are IPv6 only */\n\tif (addr_type == IPV6_ADDR_MAPPED)\n\t\treturn -EADDRNOTAVAIL;\n\n\t/* L2TP is point-point, not multicast */\n\tif (addr_type & IPV6_ADDR_MULTICAST)\n\t\treturn -EADDRNOTAVAIL;\n\n\terr = -EADDRINUSE;\n\tread_lock_bh(&l2tp_ip6_lock);\n\tif (__l2tp_ip6_bind_lookup(net, &addr->l2tp_addr,\n\t\t\t\t   sk->sk_bound_dev_if, addr->l2tp_conn_id))\n\t\tgoto out_in_use;\n\tread_unlock_bh(&l2tp_ip6_lock);\n\n\tlock_sock(sk);\n\n\terr = -EINVAL;\n\tif (sk->sk_state != TCP_CLOSE)\n\t\tgoto out_unlock;\n\n\t/* Check if the address belongs to the host. */\n\trcu_read_lock();\n\tif (addr_type != IPV6_ADDR_ANY) {\n\t\tstruct net_device *dev = NULL;\n\n\t\tif (addr_type & IPV6_ADDR_LINKLOCAL) {\n\t\t\tif (addr_len >= sizeof(struct sockaddr_in6) &&\n\t\t\t    addr->l2tp_scope_id) {\n\t\t\t\t/* Override any existing binding, if another\n\t\t\t\t * one is supplied by user.\n\t\t\t\t */\n\t\t\t\tsk->sk_bound_dev_if = addr->l2tp_scope_id;\n\t\t\t}\n\n\t\t\t/* Binding to link-local address requires an\n\t\t\t   interface */\n\t\t\tif (!sk->sk_bound_dev_if)\n\t\t\t\tgoto out_unlock_rcu;\n\n\t\t\terr = -ENODEV;\n\t\t\tdev = dev_get_by_index_rcu(sock_net(sk),\n\t\t\t\t\t\t   sk->sk_bound_dev_if);\n\t\t\tif (!dev)\n\t\t\t\tgoto out_unlock_rcu;\n\t\t}\n\n\t\t/* ipv4 addr of the socket is invalid.  Only the\n\t\t * unspecified and mapped address have a v4 equivalent.\n\t\t */\n\t\tv4addr = LOOPBACK4_IPV6;\n\t\terr = -EADDRNOTAVAIL;\n\t\tif (!ipv6_chk_addr(sock_net(sk), &addr->l2tp_addr, dev, 0))\n\t\t\tgoto out_unlock_rcu;\n\t}\n\trcu_read_unlock();\n\n\tinet->inet_rcv_saddr = inet->inet_saddr = v4addr;\n\tsk->sk_v6_rcv_saddr = addr->l2tp_addr;\n\tnp->saddr = addr->l2tp_addr;\n\n\tl2tp_ip6_sk(sk)->conn_id = addr->l2tp_conn_id;\n\n\twrite_lock_bh(&l2tp_ip6_lock);\n\tsk_add_bind_node(sk, &l2tp_ip6_bind_table);\n\tsk_del_node_init(sk);\n\twrite_unlock_bh(&l2tp_ip6_lock);\n\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\trelease_sock(sk);\n\treturn 0;\n\nout_unlock_rcu:\n\trcu_read_unlock();\nout_unlock:\n\trelease_sock(sk);\n\treturn err;\n\nout_in_use:\n\tread_unlock_bh(&l2tp_ip6_lock);\n\treturn err;\n}",
        "code_after_change": "static int l2tp_ip6_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sockaddr_l2tpip6 *addr = (struct sockaddr_l2tpip6 *) uaddr;\n\tstruct net *net = sock_net(sk);\n\t__be32 v4addr = 0;\n\tint addr_type;\n\tint err;\n\n\tif (addr->l2tp_family != AF_INET6)\n\t\treturn -EINVAL;\n\tif (addr_len < sizeof(*addr))\n\t\treturn -EINVAL;\n\n\taddr_type = ipv6_addr_type(&addr->l2tp_addr);\n\n\t/* l2tp_ip6 sockets are IPv6 only */\n\tif (addr_type == IPV6_ADDR_MAPPED)\n\t\treturn -EADDRNOTAVAIL;\n\n\t/* L2TP is point-point, not multicast */\n\tif (addr_type & IPV6_ADDR_MULTICAST)\n\t\treturn -EADDRNOTAVAIL;\n\n\terr = -EADDRINUSE;\n\tread_lock_bh(&l2tp_ip6_lock);\n\tif (__l2tp_ip6_bind_lookup(net, &addr->l2tp_addr,\n\t\t\t\t   sk->sk_bound_dev_if, addr->l2tp_conn_id))\n\t\tgoto out_in_use;\n\tread_unlock_bh(&l2tp_ip6_lock);\n\n\tlock_sock(sk);\n\n\terr = -EINVAL;\n\tif (!sock_flag(sk, SOCK_ZAPPED))\n\t\tgoto out_unlock;\n\n\tif (sk->sk_state != TCP_CLOSE)\n\t\tgoto out_unlock;\n\n\t/* Check if the address belongs to the host. */\n\trcu_read_lock();\n\tif (addr_type != IPV6_ADDR_ANY) {\n\t\tstruct net_device *dev = NULL;\n\n\t\tif (addr_type & IPV6_ADDR_LINKLOCAL) {\n\t\t\tif (addr_len >= sizeof(struct sockaddr_in6) &&\n\t\t\t    addr->l2tp_scope_id) {\n\t\t\t\t/* Override any existing binding, if another\n\t\t\t\t * one is supplied by user.\n\t\t\t\t */\n\t\t\t\tsk->sk_bound_dev_if = addr->l2tp_scope_id;\n\t\t\t}\n\n\t\t\t/* Binding to link-local address requires an\n\t\t\t   interface */\n\t\t\tif (!sk->sk_bound_dev_if)\n\t\t\t\tgoto out_unlock_rcu;\n\n\t\t\terr = -ENODEV;\n\t\t\tdev = dev_get_by_index_rcu(sock_net(sk),\n\t\t\t\t\t\t   sk->sk_bound_dev_if);\n\t\t\tif (!dev)\n\t\t\t\tgoto out_unlock_rcu;\n\t\t}\n\n\t\t/* ipv4 addr of the socket is invalid.  Only the\n\t\t * unspecified and mapped address have a v4 equivalent.\n\t\t */\n\t\tv4addr = LOOPBACK4_IPV6;\n\t\terr = -EADDRNOTAVAIL;\n\t\tif (!ipv6_chk_addr(sock_net(sk), &addr->l2tp_addr, dev, 0))\n\t\t\tgoto out_unlock_rcu;\n\t}\n\trcu_read_unlock();\n\n\tinet->inet_rcv_saddr = inet->inet_saddr = v4addr;\n\tsk->sk_v6_rcv_saddr = addr->l2tp_addr;\n\tnp->saddr = addr->l2tp_addr;\n\n\tl2tp_ip6_sk(sk)->conn_id = addr->l2tp_conn_id;\n\n\twrite_lock_bh(&l2tp_ip6_lock);\n\tsk_add_bind_node(sk, &l2tp_ip6_bind_table);\n\tsk_del_node_init(sk);\n\twrite_unlock_bh(&l2tp_ip6_lock);\n\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\trelease_sock(sk);\n\treturn 0;\n\nout_unlock_rcu:\n\trcu_read_unlock();\nout_unlock:\n\trelease_sock(sk);\n\treturn err;\n\nout_in_use:\n\tread_unlock_bh(&l2tp_ip6_lock);\n\treturn err;\n}",
        "patch": "--- code before\n+++ code after\n@@ -8,8 +8,6 @@\n \tint addr_type;\n \tint err;\n \n-\tif (!sock_flag(sk, SOCK_ZAPPED))\n-\t\treturn -EINVAL;\n \tif (addr->l2tp_family != AF_INET6)\n \t\treturn -EINVAL;\n \tif (addr_len < sizeof(*addr))\n@@ -35,6 +33,9 @@\n \tlock_sock(sk);\n \n \terr = -EINVAL;\n+\tif (!sock_flag(sk, SOCK_ZAPPED))\n+\t\tgoto out_unlock;\n+\n \tif (sk->sk_state != TCP_CLOSE)\n \t\tgoto out_unlock;\n ",
        "function_modified_lines": {
            "added": [
                "\tif (!sock_flag(sk, SOCK_ZAPPED))",
                "\t\tgoto out_unlock;",
                ""
            ],
            "deleted": [
                "\tif (!sock_flag(sk, SOCK_ZAPPED))",
                "\t\treturn -EINVAL;"
            ]
        },
        "cwe": [
            "CWE-264",
            "CWE-362",
            "CWE-416"
        ],
        "cve_description": "Race condition in the L2TPv3 IP Encapsulation feature in the Linux kernel before 4.8.14 allows local users to gain privileges or cause a denial of service (use-after-free) by making multiple bind system calls without properly ascertaining whether a socket has the SOCK_ZAPPED status, related to net/l2tp/l2tp_ip.c and net/l2tp/l2tp_ip6.c.",
        "id": 899
    },
    {
        "cve_id": "CVE-2022-28796",
        "code_before_change": "void jbd2_journal_lock_updates(journal_t *journal)\n{\n\tDEFINE_WAIT(wait);\n\n\tjbd2_might_wait_for_commit(journal);\n\n\twrite_lock(&journal->j_state_lock);\n\t++journal->j_barrier_count;\n\n\t/* Wait until there are no reserved handles */\n\tif (atomic_read(&journal->j_reserved_credits)) {\n\t\twrite_unlock(&journal->j_state_lock);\n\t\twait_event(journal->j_wait_reserved,\n\t\t\t   atomic_read(&journal->j_reserved_credits) == 0);\n\t\twrite_lock(&journal->j_state_lock);\n\t}\n\n\t/* Wait until there are no running t_updates */\n\tjbd2_journal_wait_updates(journal);\n\n\twrite_unlock(&journal->j_state_lock);\n\n\t/*\n\t * We have now established a barrier against other normal updates, but\n\t * we also need to barrier against other jbd2_journal_lock_updates() calls\n\t * to make sure that we serialise special journal-locked operations\n\t * too.\n\t */\n\tmutex_lock(&journal->j_barrier);\n}",
        "code_after_change": "void jbd2_journal_lock_updates(journal_t *journal)\n{\n\tjbd2_might_wait_for_commit(journal);\n\n\twrite_lock(&journal->j_state_lock);\n\t++journal->j_barrier_count;\n\n\t/* Wait until there are no reserved handles */\n\tif (atomic_read(&journal->j_reserved_credits)) {\n\t\twrite_unlock(&journal->j_state_lock);\n\t\twait_event(journal->j_wait_reserved,\n\t\t\t   atomic_read(&journal->j_reserved_credits) == 0);\n\t\twrite_lock(&journal->j_state_lock);\n\t}\n\n\t/* Wait until there are no running t_updates */\n\tjbd2_journal_wait_updates(journal);\n\n\twrite_unlock(&journal->j_state_lock);\n\n\t/*\n\t * We have now established a barrier against other normal updates, but\n\t * we also need to barrier against other jbd2_journal_lock_updates() calls\n\t * to make sure that we serialise special journal-locked operations\n\t * too.\n\t */\n\tmutex_lock(&journal->j_barrier);\n}",
        "patch": "--- code before\n+++ code after\n@@ -1,7 +1,5 @@\n void jbd2_journal_lock_updates(journal_t *journal)\n {\n-\tDEFINE_WAIT(wait);\n-\n \tjbd2_might_wait_for_commit(journal);\n \n \twrite_lock(&journal->j_state_lock);",
        "function_modified_lines": {
            "added": [],
            "deleted": [
                "\tDEFINE_WAIT(wait);",
                ""
            ]
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "jbd2_journal_wait_updates in fs/jbd2/transaction.c in the Linux kernel before 5.17.1 has a use-after-free caused by a transaction_t race condition.",
        "id": 3505
    },
    {
        "cve_id": "CVE-2020-29374",
        "code_before_change": "static inline bool can_follow_write_pmd(pmd_t pmd, unsigned int flags)\n{\n\treturn pmd_write(pmd) ||\n\t       ((flags & FOLL_FORCE) && (flags & FOLL_COW) && pmd_dirty(pmd));\n}",
        "code_after_change": "static inline bool can_follow_write_pmd(pmd_t pmd, unsigned int flags)\n{\n\treturn pmd_write(pmd) || ((flags & FOLL_COW) && pmd_dirty(pmd));\n}",
        "patch": "--- code before\n+++ code after\n@@ -1,5 +1,4 @@\n static inline bool can_follow_write_pmd(pmd_t pmd, unsigned int flags)\n {\n-\treturn pmd_write(pmd) ||\n-\t       ((flags & FOLL_FORCE) && (flags & FOLL_COW) && pmd_dirty(pmd));\n+\treturn pmd_write(pmd) || ((flags & FOLL_COW) && pmd_dirty(pmd));\n }",
        "function_modified_lines": {
            "added": [
                "\treturn pmd_write(pmd) || ((flags & FOLL_COW) && pmd_dirty(pmd));"
            ],
            "deleted": [
                "\treturn pmd_write(pmd) ||",
                "\t       ((flags & FOLL_FORCE) && (flags & FOLL_COW) && pmd_dirty(pmd));"
            ]
        },
        "cwe": [
            "CWE-362",
            "CWE-863"
        ],
        "cve_description": "An issue was discovered in the Linux kernel before 5.7.3, related to mm/gup.c and mm/huge_memory.c. The get_user_pages (aka gup) implementation, when used for a copy-on-write page, does not properly consider the semantics of read operations and therefore can grant unintended write access, aka CID-17839856fd58.",
        "id": 2675
    },
    {
        "cve_id": "CVE-2021-3752",
        "code_before_change": "static void l2cap_sock_destruct(struct sock *sk)\n{\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (l2cap_pi(sk)->chan)\n\t\tl2cap_chan_put(l2cap_pi(sk)->chan);\n\n\tif (l2cap_pi(sk)->rx_busy_skb) {\n\t\tkfree_skb(l2cap_pi(sk)->rx_busy_skb);\n\t\tl2cap_pi(sk)->rx_busy_skb = NULL;\n\t}\n\n\tskb_queue_purge(&sk->sk_receive_queue);\n\tskb_queue_purge(&sk->sk_write_queue);\n}",
        "code_after_change": "static void l2cap_sock_destruct(struct sock *sk)\n{\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (l2cap_pi(sk)->chan) {\n\t\tl2cap_pi(sk)->chan->data = NULL;\n\t\tl2cap_chan_put(l2cap_pi(sk)->chan);\n\t}\n\n\tif (l2cap_pi(sk)->rx_busy_skb) {\n\t\tkfree_skb(l2cap_pi(sk)->rx_busy_skb);\n\t\tl2cap_pi(sk)->rx_busy_skb = NULL;\n\t}\n\n\tskb_queue_purge(&sk->sk_receive_queue);\n\tskb_queue_purge(&sk->sk_write_queue);\n}",
        "patch": "--- code before\n+++ code after\n@@ -2,8 +2,10 @@\n {\n \tBT_DBG(\"sk %p\", sk);\n \n-\tif (l2cap_pi(sk)->chan)\n+\tif (l2cap_pi(sk)->chan) {\n+\t\tl2cap_pi(sk)->chan->data = NULL;\n \t\tl2cap_chan_put(l2cap_pi(sk)->chan);\n+\t}\n \n \tif (l2cap_pi(sk)->rx_busy_skb) {\n \t\tkfree_skb(l2cap_pi(sk)->rx_busy_skb);",
        "function_modified_lines": {
            "added": [
                "\tif (l2cap_pi(sk)->chan) {",
                "\t\tl2cap_pi(sk)->chan->data = NULL;",
                "\t}"
            ],
            "deleted": [
                "\tif (l2cap_pi(sk)->chan)"
            ]
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "A use-after-free flaw was found in the Linux kernel\u2019s Bluetooth subsystem in the way user calls connect to the socket and disconnect simultaneously due to a race condition. This flaw allows a user to crash the system or escalate their privileges. The highest threat from this vulnerability is to confidentiality, integrity, as well as system availability.",
        "id": 3054
    },
    {
        "cve_id": "CVE-2021-3752",
        "code_before_change": "static void l2cap_sock_teardown_cb(struct l2cap_chan *chan, int err)\n{\n\tstruct sock *sk = chan->data;\n\tstruct sock *parent;\n\n\tBT_DBG(\"chan %p state %s\", chan, state_to_string(chan->state));\n\n\t/* This callback can be called both for server (BT_LISTEN)\n\t * sockets as well as \"normal\" ones. To avoid lockdep warnings\n\t * with child socket locking (through l2cap_sock_cleanup_listen)\n\t * we need separation into separate nesting levels. The simplest\n\t * way to accomplish this is to inherit the nesting level used\n\t * for the channel.\n\t */\n\tlock_sock_nested(sk, atomic_read(&chan->nesting));\n\n\tparent = bt_sk(sk)->parent;\n\n\tswitch (chan->state) {\n\tcase BT_OPEN:\n\tcase BT_BOUND:\n\tcase BT_CLOSED:\n\t\tbreak;\n\tcase BT_LISTEN:\n\t\tl2cap_sock_cleanup_listen(sk);\n\t\tsk->sk_state = BT_CLOSED;\n\t\tchan->state = BT_CLOSED;\n\n\t\tbreak;\n\tdefault:\n\t\tsk->sk_state = BT_CLOSED;\n\t\tchan->state = BT_CLOSED;\n\n\t\tsk->sk_err = err;\n\n\t\tif (parent) {\n\t\t\tbt_accept_unlink(sk);\n\t\t\tparent->sk_data_ready(parent);\n\t\t} else {\n\t\t\tsk->sk_state_change(sk);\n\t\t}\n\n\t\tbreak;\n\t}\n\trelease_sock(sk);\n\n\t/* Only zap after cleanup to avoid use after free race */\n\tsock_set_flag(sk, SOCK_ZAPPED);\n\n}",
        "code_after_change": "static void l2cap_sock_teardown_cb(struct l2cap_chan *chan, int err)\n{\n\tstruct sock *sk = chan->data;\n\tstruct sock *parent;\n\n\tif (!sk)\n\t\treturn;\n\n\tBT_DBG(\"chan %p state %s\", chan, state_to_string(chan->state));\n\n\t/* This callback can be called both for server (BT_LISTEN)\n\t * sockets as well as \"normal\" ones. To avoid lockdep warnings\n\t * with child socket locking (through l2cap_sock_cleanup_listen)\n\t * we need separation into separate nesting levels. The simplest\n\t * way to accomplish this is to inherit the nesting level used\n\t * for the channel.\n\t */\n\tlock_sock_nested(sk, atomic_read(&chan->nesting));\n\n\tparent = bt_sk(sk)->parent;\n\n\tswitch (chan->state) {\n\tcase BT_OPEN:\n\tcase BT_BOUND:\n\tcase BT_CLOSED:\n\t\tbreak;\n\tcase BT_LISTEN:\n\t\tl2cap_sock_cleanup_listen(sk);\n\t\tsk->sk_state = BT_CLOSED;\n\t\tchan->state = BT_CLOSED;\n\n\t\tbreak;\n\tdefault:\n\t\tsk->sk_state = BT_CLOSED;\n\t\tchan->state = BT_CLOSED;\n\n\t\tsk->sk_err = err;\n\n\t\tif (parent) {\n\t\t\tbt_accept_unlink(sk);\n\t\t\tparent->sk_data_ready(parent);\n\t\t} else {\n\t\t\tsk->sk_state_change(sk);\n\t\t}\n\n\t\tbreak;\n\t}\n\trelease_sock(sk);\n\n\t/* Only zap after cleanup to avoid use after free race */\n\tsock_set_flag(sk, SOCK_ZAPPED);\n\n}",
        "patch": "--- code before\n+++ code after\n@@ -2,6 +2,9 @@\n {\n \tstruct sock *sk = chan->data;\n \tstruct sock *parent;\n+\n+\tif (!sk)\n+\t\treturn;\n \n \tBT_DBG(\"chan %p state %s\", chan, state_to_string(chan->state));\n ",
        "function_modified_lines": {
            "added": [
                "",
                "\tif (!sk)",
                "\t\treturn;"
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "A use-after-free flaw was found in the Linux kernel\u2019s Bluetooth subsystem in the way user calls connect to the socket and disconnect simultaneously due to a race condition. This flaw allows a user to crash the system or escalate their privileges. The highest threat from this vulnerability is to confidentiality, integrity, as well as system availability.",
        "id": 3055
    },
    {
        "cve_id": "CVE-2023-32250",
        "code_before_change": "int init_smb2_neg_rsp(struct ksmbd_work *work)\n{\n\tstruct smb2_hdr *rsp_hdr;\n\tstruct smb2_negotiate_rsp *rsp;\n\tstruct ksmbd_conn *conn = work->conn;\n\n\t*(__be32 *)work->response_buf =\n\t\tcpu_to_be32(conn->vals->header_size);\n\n\trsp_hdr = smb2_get_msg(work->response_buf);\n\tmemset(rsp_hdr, 0, sizeof(struct smb2_hdr) + 2);\n\trsp_hdr->ProtocolId = SMB2_PROTO_NUMBER;\n\trsp_hdr->StructureSize = SMB2_HEADER_STRUCTURE_SIZE;\n\trsp_hdr->CreditRequest = cpu_to_le16(2);\n\trsp_hdr->Command = SMB2_NEGOTIATE;\n\trsp_hdr->Flags = (SMB2_FLAGS_SERVER_TO_REDIR);\n\trsp_hdr->NextCommand = 0;\n\trsp_hdr->MessageId = 0;\n\trsp_hdr->Id.SyncId.ProcessId = 0;\n\trsp_hdr->Id.SyncId.TreeId = 0;\n\trsp_hdr->SessionId = 0;\n\tmemset(rsp_hdr->Signature, 0, 16);\n\n\trsp = smb2_get_msg(work->response_buf);\n\n\tWARN_ON(ksmbd_conn_good(work));\n\n\trsp->StructureSize = cpu_to_le16(65);\n\tksmbd_debug(SMB, \"conn->dialect 0x%x\\n\", conn->dialect);\n\trsp->DialectRevision = cpu_to_le16(conn->dialect);\n\t/* Not setting conn guid rsp->ServerGUID, as it\n\t * not used by client for identifying connection\n\t */\n\trsp->Capabilities = cpu_to_le32(conn->vals->capabilities);\n\t/* Default Max Message Size till SMB2.0, 64K*/\n\trsp->MaxTransactSize = cpu_to_le32(conn->vals->max_trans_size);\n\trsp->MaxReadSize = cpu_to_le32(conn->vals->max_read_size);\n\trsp->MaxWriteSize = cpu_to_le32(conn->vals->max_write_size);\n\n\trsp->SystemTime = cpu_to_le64(ksmbd_systime());\n\trsp->ServerStartTime = 0;\n\n\trsp->SecurityBufferOffset = cpu_to_le16(128);\n\trsp->SecurityBufferLength = cpu_to_le16(AUTH_GSS_LENGTH);\n\tksmbd_copy_gss_neg_header((char *)(&rsp->hdr) +\n\t\tle16_to_cpu(rsp->SecurityBufferOffset));\n\tinc_rfc1001_len(work->response_buf,\n\t\t\tsizeof(struct smb2_negotiate_rsp) -\n\t\t\tsizeof(struct smb2_hdr) + AUTH_GSS_LENGTH);\n\trsp->SecurityMode = SMB2_NEGOTIATE_SIGNING_ENABLED_LE;\n\tif (server_conf.signing == KSMBD_CONFIG_OPT_MANDATORY)\n\t\trsp->SecurityMode |= SMB2_NEGOTIATE_SIGNING_REQUIRED_LE;\n\tconn->use_spnego = true;\n\n\tksmbd_conn_set_need_negotiate(work);\n\treturn 0;\n}",
        "code_after_change": "int init_smb2_neg_rsp(struct ksmbd_work *work)\n{\n\tstruct smb2_hdr *rsp_hdr;\n\tstruct smb2_negotiate_rsp *rsp;\n\tstruct ksmbd_conn *conn = work->conn;\n\n\t*(__be32 *)work->response_buf =\n\t\tcpu_to_be32(conn->vals->header_size);\n\n\trsp_hdr = smb2_get_msg(work->response_buf);\n\tmemset(rsp_hdr, 0, sizeof(struct smb2_hdr) + 2);\n\trsp_hdr->ProtocolId = SMB2_PROTO_NUMBER;\n\trsp_hdr->StructureSize = SMB2_HEADER_STRUCTURE_SIZE;\n\trsp_hdr->CreditRequest = cpu_to_le16(2);\n\trsp_hdr->Command = SMB2_NEGOTIATE;\n\trsp_hdr->Flags = (SMB2_FLAGS_SERVER_TO_REDIR);\n\trsp_hdr->NextCommand = 0;\n\trsp_hdr->MessageId = 0;\n\trsp_hdr->Id.SyncId.ProcessId = 0;\n\trsp_hdr->Id.SyncId.TreeId = 0;\n\trsp_hdr->SessionId = 0;\n\tmemset(rsp_hdr->Signature, 0, 16);\n\n\trsp = smb2_get_msg(work->response_buf);\n\n\tWARN_ON(ksmbd_conn_good(conn));\n\n\trsp->StructureSize = cpu_to_le16(65);\n\tksmbd_debug(SMB, \"conn->dialect 0x%x\\n\", conn->dialect);\n\trsp->DialectRevision = cpu_to_le16(conn->dialect);\n\t/* Not setting conn guid rsp->ServerGUID, as it\n\t * not used by client for identifying connection\n\t */\n\trsp->Capabilities = cpu_to_le32(conn->vals->capabilities);\n\t/* Default Max Message Size till SMB2.0, 64K*/\n\trsp->MaxTransactSize = cpu_to_le32(conn->vals->max_trans_size);\n\trsp->MaxReadSize = cpu_to_le32(conn->vals->max_read_size);\n\trsp->MaxWriteSize = cpu_to_le32(conn->vals->max_write_size);\n\n\trsp->SystemTime = cpu_to_le64(ksmbd_systime());\n\trsp->ServerStartTime = 0;\n\n\trsp->SecurityBufferOffset = cpu_to_le16(128);\n\trsp->SecurityBufferLength = cpu_to_le16(AUTH_GSS_LENGTH);\n\tksmbd_copy_gss_neg_header((char *)(&rsp->hdr) +\n\t\tle16_to_cpu(rsp->SecurityBufferOffset));\n\tinc_rfc1001_len(work->response_buf,\n\t\t\tsizeof(struct smb2_negotiate_rsp) -\n\t\t\tsizeof(struct smb2_hdr) + AUTH_GSS_LENGTH);\n\trsp->SecurityMode = SMB2_NEGOTIATE_SIGNING_ENABLED_LE;\n\tif (server_conf.signing == KSMBD_CONFIG_OPT_MANDATORY)\n\t\trsp->SecurityMode |= SMB2_NEGOTIATE_SIGNING_REQUIRED_LE;\n\tconn->use_spnego = true;\n\n\tksmbd_conn_set_need_negotiate(conn);\n\treturn 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -23,7 +23,7 @@\n \n \trsp = smb2_get_msg(work->response_buf);\n \n-\tWARN_ON(ksmbd_conn_good(work));\n+\tWARN_ON(ksmbd_conn_good(conn));\n \n \trsp->StructureSize = cpu_to_le16(65);\n \tksmbd_debug(SMB, \"conn->dialect 0x%x\\n\", conn->dialect);\n@@ -52,6 +52,6 @@\n \t\trsp->SecurityMode |= SMB2_NEGOTIATE_SIGNING_REQUIRED_LE;\n \tconn->use_spnego = true;\n \n-\tksmbd_conn_set_need_negotiate(work);\n+\tksmbd_conn_set_need_negotiate(conn);\n \treturn 0;\n }",
        "function_modified_lines": {
            "added": [
                "\tWARN_ON(ksmbd_conn_good(conn));",
                "\tksmbd_conn_set_need_negotiate(conn);"
            ],
            "deleted": [
                "\tWARN_ON(ksmbd_conn_good(work));",
                "\tksmbd_conn_set_need_negotiate(work);"
            ]
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "A flaw was found in the Linux kernel's ksmbd, a high-performance in-kernel SMB server. The specific flaw exists within the processing of SMB2_SESSION_SETUP commands. The issue results from the lack of proper locking when performing operations on an object. An attacker can leverage this vulnerability to execute code in the context of the kernel.",
        "id": 4023
    },
    {
        "cve_id": "CVE-2023-32250",
        "code_before_change": "static void destroy_previous_session(struct ksmbd_conn *conn,\n\t\t\t\t     struct ksmbd_user *user, u64 id)\n{\n\tstruct ksmbd_session *prev_sess = ksmbd_session_lookup_slowpath(id);\n\tstruct ksmbd_user *prev_user;\n\tstruct channel *chann;\n\tlong index;\n\n\tif (!prev_sess)\n\t\treturn;\n\n\tprev_user = prev_sess->user;\n\n\tif (!prev_user ||\n\t    strcmp(user->name, prev_user->name) ||\n\t    user->passkey_sz != prev_user->passkey_sz ||\n\t    memcmp(user->passkey, prev_user->passkey, user->passkey_sz))\n\t\treturn;\n\n\tprev_sess->state = SMB2_SESSION_EXPIRED;\n\txa_for_each(&prev_sess->ksmbd_chann_list, index, chann)\n\t\tchann->conn->status = KSMBD_SESS_EXITING;\n}",
        "code_after_change": "static void destroy_previous_session(struct ksmbd_conn *conn,\n\t\t\t\t     struct ksmbd_user *user, u64 id)\n{\n\tstruct ksmbd_session *prev_sess = ksmbd_session_lookup_slowpath(id);\n\tstruct ksmbd_user *prev_user;\n\tstruct channel *chann;\n\tlong index;\n\n\tif (!prev_sess)\n\t\treturn;\n\n\tprev_user = prev_sess->user;\n\n\tif (!prev_user ||\n\t    strcmp(user->name, prev_user->name) ||\n\t    user->passkey_sz != prev_user->passkey_sz ||\n\t    memcmp(user->passkey, prev_user->passkey, user->passkey_sz))\n\t\treturn;\n\n\tprev_sess->state = SMB2_SESSION_EXPIRED;\n\txa_for_each(&prev_sess->ksmbd_chann_list, index, chann)\n\t\tksmbd_conn_set_exiting(chann->conn);\n}",
        "patch": "--- code before\n+++ code after\n@@ -19,5 +19,5 @@\n \n \tprev_sess->state = SMB2_SESSION_EXPIRED;\n \txa_for_each(&prev_sess->ksmbd_chann_list, index, chann)\n-\t\tchann->conn->status = KSMBD_SESS_EXITING;\n+\t\tksmbd_conn_set_exiting(chann->conn);\n }",
        "function_modified_lines": {
            "added": [
                "\t\tksmbd_conn_set_exiting(chann->conn);"
            ],
            "deleted": [
                "\t\tchann->conn->status = KSMBD_SESS_EXITING;"
            ]
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "A flaw was found in the Linux kernel's ksmbd, a high-performance in-kernel SMB server. The specific flaw exists within the processing of SMB2_SESSION_SETUP commands. The issue results from the lack of proper locking when performing operations on an object. An attacker can leverage this vulnerability to execute code in the context of the kernel.",
        "id": 4022
    },
    {
        "cve_id": "CVE-2015-7613",
        "code_before_change": "static int newque(struct ipc_namespace *ns, struct ipc_params *params)\n{\n\tstruct msg_queue *msq;\n\tint id, retval;\n\tkey_t key = params->key;\n\tint msgflg = params->flg;\n\n\tmsq = ipc_rcu_alloc(sizeof(*msq));\n\tif (!msq)\n\t\treturn -ENOMEM;\n\n\tmsq->q_perm.mode = msgflg & S_IRWXUGO;\n\tmsq->q_perm.key = key;\n\n\tmsq->q_perm.security = NULL;\n\tretval = security_msg_queue_alloc(msq);\n\tif (retval) {\n\t\tipc_rcu_putref(msq, ipc_rcu_free);\n\t\treturn retval;\n\t}\n\n\t/* ipc_addid() locks msq upon success. */\n\tid = ipc_addid(&msg_ids(ns), &msq->q_perm, ns->msg_ctlmni);\n\tif (id < 0) {\n\t\tipc_rcu_putref(msq, msg_rcu_free);\n\t\treturn id;\n\t}\n\n\tmsq->q_stime = msq->q_rtime = 0;\n\tmsq->q_ctime = get_seconds();\n\tmsq->q_cbytes = msq->q_qnum = 0;\n\tmsq->q_qbytes = ns->msg_ctlmnb;\n\tmsq->q_lspid = msq->q_lrpid = 0;\n\tINIT_LIST_HEAD(&msq->q_messages);\n\tINIT_LIST_HEAD(&msq->q_receivers);\n\tINIT_LIST_HEAD(&msq->q_senders);\n\n\tipc_unlock_object(&msq->q_perm);\n\trcu_read_unlock();\n\n\treturn msq->q_perm.id;\n}",
        "code_after_change": "static int newque(struct ipc_namespace *ns, struct ipc_params *params)\n{\n\tstruct msg_queue *msq;\n\tint id, retval;\n\tkey_t key = params->key;\n\tint msgflg = params->flg;\n\n\tmsq = ipc_rcu_alloc(sizeof(*msq));\n\tif (!msq)\n\t\treturn -ENOMEM;\n\n\tmsq->q_perm.mode = msgflg & S_IRWXUGO;\n\tmsq->q_perm.key = key;\n\n\tmsq->q_perm.security = NULL;\n\tretval = security_msg_queue_alloc(msq);\n\tif (retval) {\n\t\tipc_rcu_putref(msq, ipc_rcu_free);\n\t\treturn retval;\n\t}\n\n\tmsq->q_stime = msq->q_rtime = 0;\n\tmsq->q_ctime = get_seconds();\n\tmsq->q_cbytes = msq->q_qnum = 0;\n\tmsq->q_qbytes = ns->msg_ctlmnb;\n\tmsq->q_lspid = msq->q_lrpid = 0;\n\tINIT_LIST_HEAD(&msq->q_messages);\n\tINIT_LIST_HEAD(&msq->q_receivers);\n\tINIT_LIST_HEAD(&msq->q_senders);\n\n\t/* ipc_addid() locks msq upon success. */\n\tid = ipc_addid(&msg_ids(ns), &msq->q_perm, ns->msg_ctlmni);\n\tif (id < 0) {\n\t\tipc_rcu_putref(msq, msg_rcu_free);\n\t\treturn id;\n\t}\n\n\tipc_unlock_object(&msq->q_perm);\n\trcu_read_unlock();\n\n\treturn msq->q_perm.id;\n}",
        "patch": "--- code before\n+++ code after\n@@ -19,13 +19,6 @@\n \t\treturn retval;\n \t}\n \n-\t/* ipc_addid() locks msq upon success. */\n-\tid = ipc_addid(&msg_ids(ns), &msq->q_perm, ns->msg_ctlmni);\n-\tif (id < 0) {\n-\t\tipc_rcu_putref(msq, msg_rcu_free);\n-\t\treturn id;\n-\t}\n-\n \tmsq->q_stime = msq->q_rtime = 0;\n \tmsq->q_ctime = get_seconds();\n \tmsq->q_cbytes = msq->q_qnum = 0;\n@@ -35,6 +28,13 @@\n \tINIT_LIST_HEAD(&msq->q_receivers);\n \tINIT_LIST_HEAD(&msq->q_senders);\n \n+\t/* ipc_addid() locks msq upon success. */\n+\tid = ipc_addid(&msg_ids(ns), &msq->q_perm, ns->msg_ctlmni);\n+\tif (id < 0) {\n+\t\tipc_rcu_putref(msq, msg_rcu_free);\n+\t\treturn id;\n+\t}\n+\n \tipc_unlock_object(&msq->q_perm);\n \trcu_read_unlock();\n ",
        "function_modified_lines": {
            "added": [
                "\t/* ipc_addid() locks msq upon success. */",
                "\tid = ipc_addid(&msg_ids(ns), &msq->q_perm, ns->msg_ctlmni);",
                "\tif (id < 0) {",
                "\t\tipc_rcu_putref(msq, msg_rcu_free);",
                "\t\treturn id;",
                "\t}",
                ""
            ],
            "deleted": [
                "\t/* ipc_addid() locks msq upon success. */",
                "\tid = ipc_addid(&msg_ids(ns), &msq->q_perm, ns->msg_ctlmni);",
                "\tif (id < 0) {",
                "\t\tipc_rcu_putref(msq, msg_rcu_free);",
                "\t\treturn id;",
                "\t}",
                ""
            ]
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "Race condition in the IPC object implementation in the Linux kernel through 4.2.3 allows local users to gain privileges by triggering an ipc_addid call that leads to uid and gid comparisons against uninitialized data, related to msg.c, shm.c, and util.c.",
        "id": 788
    },
    {
        "cve_id": "CVE-2017-7533",
        "code_before_change": "int vfs_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t       struct inode *new_dir, struct dentry *new_dentry,\n\t       struct inode **delegated_inode, unsigned int flags)\n{\n\tint error;\n\tbool is_dir = d_is_dir(old_dentry);\n\tconst unsigned char *old_name;\n\tstruct inode *source = old_dentry->d_inode;\n\tstruct inode *target = new_dentry->d_inode;\n\tbool new_is_dir = false;\n\tunsigned max_links = new_dir->i_sb->s_max_links;\n\n\tif (source == target)\n\t\treturn 0;\n\n\terror = may_delete(old_dir, old_dentry, is_dir);\n\tif (error)\n\t\treturn error;\n\n\tif (!target) {\n\t\terror = may_create(new_dir, new_dentry);\n\t} else {\n\t\tnew_is_dir = d_is_dir(new_dentry);\n\n\t\tif (!(flags & RENAME_EXCHANGE))\n\t\t\terror = may_delete(new_dir, new_dentry, is_dir);\n\t\telse\n\t\t\terror = may_delete(new_dir, new_dentry, new_is_dir);\n\t}\n\tif (error)\n\t\treturn error;\n\n\tif (!old_dir->i_op->rename)\n\t\treturn -EPERM;\n\n\t/*\n\t * If we are going to change the parent - check write permissions,\n\t * we'll need to flip '..'.\n\t */\n\tif (new_dir != old_dir) {\n\t\tif (is_dir) {\n\t\t\terror = inode_permission(source, MAY_WRITE);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\tif ((flags & RENAME_EXCHANGE) && new_is_dir) {\n\t\t\terror = inode_permission(target, MAY_WRITE);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\n\terror = security_inode_rename(old_dir, old_dentry, new_dir, new_dentry,\n\t\t\t\t      flags);\n\tif (error)\n\t\treturn error;\n\n\told_name = fsnotify_oldname_init(old_dentry->d_name.name);\n\tdget(new_dentry);\n\tif (!is_dir || (flags & RENAME_EXCHANGE))\n\t\tlock_two_nondirectories(source, target);\n\telse if (target)\n\t\tinode_lock(target);\n\n\terror = -EBUSY;\n\tif (is_local_mountpoint(old_dentry) || is_local_mountpoint(new_dentry))\n\t\tgoto out;\n\n\tif (max_links && new_dir != old_dir) {\n\t\terror = -EMLINK;\n\t\tif (is_dir && !new_is_dir && new_dir->i_nlink >= max_links)\n\t\t\tgoto out;\n\t\tif ((flags & RENAME_EXCHANGE) && !is_dir && new_is_dir &&\n\t\t    old_dir->i_nlink >= max_links)\n\t\t\tgoto out;\n\t}\n\tif (is_dir && !(flags & RENAME_EXCHANGE) && target)\n\t\tshrink_dcache_parent(new_dentry);\n\tif (!is_dir) {\n\t\terror = try_break_deleg(source, delegated_inode);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tif (target && !new_is_dir) {\n\t\terror = try_break_deleg(target, delegated_inode);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\terror = old_dir->i_op->rename(old_dir, old_dentry,\n\t\t\t\t       new_dir, new_dentry, flags);\n\tif (error)\n\t\tgoto out;\n\n\tif (!(flags & RENAME_EXCHANGE) && target) {\n\t\tif (is_dir)\n\t\t\ttarget->i_flags |= S_DEAD;\n\t\tdont_mount(new_dentry);\n\t\tdetach_mounts(new_dentry);\n\t}\n\tif (!(old_dir->i_sb->s_type->fs_flags & FS_RENAME_DOES_D_MOVE)) {\n\t\tif (!(flags & RENAME_EXCHANGE))\n\t\t\td_move(old_dentry, new_dentry);\n\t\telse\n\t\t\td_exchange(old_dentry, new_dentry);\n\t}\nout:\n\tif (!is_dir || (flags & RENAME_EXCHANGE))\n\t\tunlock_two_nondirectories(source, target);\n\telse if (target)\n\t\tinode_unlock(target);\n\tdput(new_dentry);\n\tif (!error) {\n\t\tfsnotify_move(old_dir, new_dir, old_name, is_dir,\n\t\t\t      !(flags & RENAME_EXCHANGE) ? target : NULL, old_dentry);\n\t\tif (flags & RENAME_EXCHANGE) {\n\t\t\tfsnotify_move(new_dir, old_dir, old_dentry->d_name.name,\n\t\t\t\t      new_is_dir, NULL, new_dentry);\n\t\t}\n\t}\n\tfsnotify_oldname_free(old_name);\n\n\treturn error;\n}",
        "code_after_change": "int vfs_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t       struct inode *new_dir, struct dentry *new_dentry,\n\t       struct inode **delegated_inode, unsigned int flags)\n{\n\tint error;\n\tbool is_dir = d_is_dir(old_dentry);\n\tstruct inode *source = old_dentry->d_inode;\n\tstruct inode *target = new_dentry->d_inode;\n\tbool new_is_dir = false;\n\tunsigned max_links = new_dir->i_sb->s_max_links;\n\tstruct name_snapshot old_name;\n\n\tif (source == target)\n\t\treturn 0;\n\n\terror = may_delete(old_dir, old_dentry, is_dir);\n\tif (error)\n\t\treturn error;\n\n\tif (!target) {\n\t\terror = may_create(new_dir, new_dentry);\n\t} else {\n\t\tnew_is_dir = d_is_dir(new_dentry);\n\n\t\tif (!(flags & RENAME_EXCHANGE))\n\t\t\terror = may_delete(new_dir, new_dentry, is_dir);\n\t\telse\n\t\t\terror = may_delete(new_dir, new_dentry, new_is_dir);\n\t}\n\tif (error)\n\t\treturn error;\n\n\tif (!old_dir->i_op->rename)\n\t\treturn -EPERM;\n\n\t/*\n\t * If we are going to change the parent - check write permissions,\n\t * we'll need to flip '..'.\n\t */\n\tif (new_dir != old_dir) {\n\t\tif (is_dir) {\n\t\t\terror = inode_permission(source, MAY_WRITE);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\tif ((flags & RENAME_EXCHANGE) && new_is_dir) {\n\t\t\terror = inode_permission(target, MAY_WRITE);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\n\terror = security_inode_rename(old_dir, old_dentry, new_dir, new_dentry,\n\t\t\t\t      flags);\n\tif (error)\n\t\treturn error;\n\n\ttake_dentry_name_snapshot(&old_name, old_dentry);\n\tdget(new_dentry);\n\tif (!is_dir || (flags & RENAME_EXCHANGE))\n\t\tlock_two_nondirectories(source, target);\n\telse if (target)\n\t\tinode_lock(target);\n\n\terror = -EBUSY;\n\tif (is_local_mountpoint(old_dentry) || is_local_mountpoint(new_dentry))\n\t\tgoto out;\n\n\tif (max_links && new_dir != old_dir) {\n\t\terror = -EMLINK;\n\t\tif (is_dir && !new_is_dir && new_dir->i_nlink >= max_links)\n\t\t\tgoto out;\n\t\tif ((flags & RENAME_EXCHANGE) && !is_dir && new_is_dir &&\n\t\t    old_dir->i_nlink >= max_links)\n\t\t\tgoto out;\n\t}\n\tif (is_dir && !(flags & RENAME_EXCHANGE) && target)\n\t\tshrink_dcache_parent(new_dentry);\n\tif (!is_dir) {\n\t\terror = try_break_deleg(source, delegated_inode);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tif (target && !new_is_dir) {\n\t\terror = try_break_deleg(target, delegated_inode);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\terror = old_dir->i_op->rename(old_dir, old_dentry,\n\t\t\t\t       new_dir, new_dentry, flags);\n\tif (error)\n\t\tgoto out;\n\n\tif (!(flags & RENAME_EXCHANGE) && target) {\n\t\tif (is_dir)\n\t\t\ttarget->i_flags |= S_DEAD;\n\t\tdont_mount(new_dentry);\n\t\tdetach_mounts(new_dentry);\n\t}\n\tif (!(old_dir->i_sb->s_type->fs_flags & FS_RENAME_DOES_D_MOVE)) {\n\t\tif (!(flags & RENAME_EXCHANGE))\n\t\t\td_move(old_dentry, new_dentry);\n\t\telse\n\t\t\td_exchange(old_dentry, new_dentry);\n\t}\nout:\n\tif (!is_dir || (flags & RENAME_EXCHANGE))\n\t\tunlock_two_nondirectories(source, target);\n\telse if (target)\n\t\tinode_unlock(target);\n\tdput(new_dentry);\n\tif (!error) {\n\t\tfsnotify_move(old_dir, new_dir, old_name.name, is_dir,\n\t\t\t      !(flags & RENAME_EXCHANGE) ? target : NULL, old_dentry);\n\t\tif (flags & RENAME_EXCHANGE) {\n\t\t\tfsnotify_move(new_dir, old_dir, old_dentry->d_name.name,\n\t\t\t\t      new_is_dir, NULL, new_dentry);\n\t\t}\n\t}\n\trelease_dentry_name_snapshot(&old_name);\n\n\treturn error;\n}",
        "patch": "--- code before\n+++ code after\n@@ -4,11 +4,11 @@\n {\n \tint error;\n \tbool is_dir = d_is_dir(old_dentry);\n-\tconst unsigned char *old_name;\n \tstruct inode *source = old_dentry->d_inode;\n \tstruct inode *target = new_dentry->d_inode;\n \tbool new_is_dir = false;\n \tunsigned max_links = new_dir->i_sb->s_max_links;\n+\tstruct name_snapshot old_name;\n \n \tif (source == target)\n \t\treturn 0;\n@@ -55,7 +55,7 @@\n \tif (error)\n \t\treturn error;\n \n-\told_name = fsnotify_oldname_init(old_dentry->d_name.name);\n+\ttake_dentry_name_snapshot(&old_name, old_dentry);\n \tdget(new_dentry);\n \tif (!is_dir || (flags & RENAME_EXCHANGE))\n \t\tlock_two_nondirectories(source, target);\n@@ -110,14 +110,14 @@\n \t\tinode_unlock(target);\n \tdput(new_dentry);\n \tif (!error) {\n-\t\tfsnotify_move(old_dir, new_dir, old_name, is_dir,\n+\t\tfsnotify_move(old_dir, new_dir, old_name.name, is_dir,\n \t\t\t      !(flags & RENAME_EXCHANGE) ? target : NULL, old_dentry);\n \t\tif (flags & RENAME_EXCHANGE) {\n \t\t\tfsnotify_move(new_dir, old_dir, old_dentry->d_name.name,\n \t\t\t\t      new_is_dir, NULL, new_dentry);\n \t\t}\n \t}\n-\tfsnotify_oldname_free(old_name);\n+\trelease_dentry_name_snapshot(&old_name);\n \n \treturn error;\n }",
        "function_modified_lines": {
            "added": [
                "\tstruct name_snapshot old_name;",
                "\ttake_dentry_name_snapshot(&old_name, old_dentry);",
                "\t\tfsnotify_move(old_dir, new_dir, old_name.name, is_dir,",
                "\trelease_dentry_name_snapshot(&old_name);"
            ],
            "deleted": [
                "\tconst unsigned char *old_name;",
                "\told_name = fsnotify_oldname_init(old_dentry->d_name.name);",
                "\t\tfsnotify_move(old_dir, new_dir, old_name, is_dir,",
                "\tfsnotify_oldname_free(old_name);"
            ]
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "Race condition in the fsnotify implementation in the Linux kernel through 4.12.4 allows local users to gain privileges or cause a denial of service (memory corruption) via a crafted application that leverages simultaneous execution of the inotify_handle_event and vfs_rename functions.",
        "id": 1511
    },
    {
        "cve_id": "CVE-2013-7026",
        "code_before_change": "long do_shmat(int shmid, char __user *shmaddr, int shmflg, ulong *raddr,\n\t      unsigned long shmlba)\n{\n\tstruct shmid_kernel *shp;\n\tunsigned long addr;\n\tunsigned long size;\n\tstruct file * file;\n\tint    err;\n\tunsigned long flags;\n\tunsigned long prot;\n\tint acc_mode;\n\tstruct ipc_namespace *ns;\n\tstruct shm_file_data *sfd;\n\tstruct path path;\n\tfmode_t f_mode;\n\tunsigned long populate = 0;\n\n\terr = -EINVAL;\n\tif (shmid < 0)\n\t\tgoto out;\n\telse if ((addr = (ulong)shmaddr)) {\n\t\tif (addr & (shmlba - 1)) {\n\t\t\tif (shmflg & SHM_RND)\n\t\t\t\taddr &= ~(shmlba - 1);\t   /* round down */\n\t\t\telse\n#ifndef __ARCH_FORCE_SHMLBA\n\t\t\t\tif (addr & ~PAGE_MASK)\n#endif\n\t\t\t\t\tgoto out;\n\t\t}\n\t\tflags = MAP_SHARED | MAP_FIXED;\n\t} else {\n\t\tif ((shmflg & SHM_REMAP))\n\t\t\tgoto out;\n\n\t\tflags = MAP_SHARED;\n\t}\n\n\tif (shmflg & SHM_RDONLY) {\n\t\tprot = PROT_READ;\n\t\tacc_mode = S_IRUGO;\n\t\tf_mode = FMODE_READ;\n\t} else {\n\t\tprot = PROT_READ | PROT_WRITE;\n\t\tacc_mode = S_IRUGO | S_IWUGO;\n\t\tf_mode = FMODE_READ | FMODE_WRITE;\n\t}\n\tif (shmflg & SHM_EXEC) {\n\t\tprot |= PROT_EXEC;\n\t\tacc_mode |= S_IXUGO;\n\t}\n\n\t/*\n\t * We cannot rely on the fs check since SYSV IPC does have an\n\t * additional creator id...\n\t */\n\tns = current->nsproxy->ipc_ns;\n\trcu_read_lock();\n\tshp = shm_obtain_object_check(ns, shmid);\n\tif (IS_ERR(shp)) {\n\t\terr = PTR_ERR(shp);\n\t\tgoto out_unlock;\n\t}\n\n\terr = -EACCES;\n\tif (ipcperms(ns, &shp->shm_perm, acc_mode))\n\t\tgoto out_unlock;\n\n\terr = security_shm_shmat(shp, shmaddr, shmflg);\n\tif (err)\n\t\tgoto out_unlock;\n\n\tipc_lock_object(&shp->shm_perm);\n\tpath = shp->shm_file->f_path;\n\tpath_get(&path);\n\tshp->shm_nattch++;\n\tsize = i_size_read(path.dentry->d_inode);\n\tipc_unlock_object(&shp->shm_perm);\n\trcu_read_unlock();\n\n\terr = -ENOMEM;\n\tsfd = kzalloc(sizeof(*sfd), GFP_KERNEL);\n\tif (!sfd) {\n\t\tpath_put(&path);\n\t\tgoto out_nattch;\n\t}\n\n\tfile = alloc_file(&path, f_mode,\n\t\t\t  is_file_hugepages(shp->shm_file) ?\n\t\t\t\t&shm_file_operations_huge :\n\t\t\t\t&shm_file_operations);\n\terr = PTR_ERR(file);\n\tif (IS_ERR(file)) {\n\t\tkfree(sfd);\n\t\tpath_put(&path);\n\t\tgoto out_nattch;\n\t}\n\n\tfile->private_data = sfd;\n\tfile->f_mapping = shp->shm_file->f_mapping;\n\tsfd->id = shp->shm_perm.id;\n\tsfd->ns = get_ipc_ns(ns);\n\tsfd->file = shp->shm_file;\n\tsfd->vm_ops = NULL;\n\n\terr = security_mmap_file(file, prot, flags);\n\tif (err)\n\t\tgoto out_fput;\n\n\tdown_write(&current->mm->mmap_sem);\n\tif (addr && !(shmflg & SHM_REMAP)) {\n\t\terr = -EINVAL;\n\t\tif (find_vma_intersection(current->mm, addr, addr + size))\n\t\t\tgoto invalid;\n\t\t/*\n\t\t * If shm segment goes below stack, make sure there is some\n\t\t * space left for the stack to grow (at least 4 pages).\n\t\t */\n\t\tif (addr < current->mm->start_stack &&\n\t\t    addr > current->mm->start_stack - size - PAGE_SIZE * 5)\n\t\t\tgoto invalid;\n\t}\n\n\taddr = do_mmap_pgoff(file, addr, size, prot, flags, 0, &populate);\n\t*raddr = addr;\n\terr = 0;\n\tif (IS_ERR_VALUE(addr))\n\t\terr = (long)addr;\ninvalid:\n\tup_write(&current->mm->mmap_sem);\n\tif (populate)\n\t\tmm_populate(addr, populate);\n\nout_fput:\n\tfput(file);\n\nout_nattch:\n\tdown_write(&shm_ids(ns).rwsem);\n\tshp = shm_lock(ns, shmid);\n\tBUG_ON(IS_ERR(shp));\n\tshp->shm_nattch--;\n\tif (shm_may_destroy(ns, shp))\n\t\tshm_destroy(ns, shp);\n\telse\n\t\tshm_unlock(shp);\n\tup_write(&shm_ids(ns).rwsem);\n\treturn err;\n\nout_unlock:\n\trcu_read_unlock();\nout:\n\treturn err;\n}",
        "code_after_change": "long do_shmat(int shmid, char __user *shmaddr, int shmflg, ulong *raddr,\n\t      unsigned long shmlba)\n{\n\tstruct shmid_kernel *shp;\n\tunsigned long addr;\n\tunsigned long size;\n\tstruct file * file;\n\tint    err;\n\tunsigned long flags;\n\tunsigned long prot;\n\tint acc_mode;\n\tstruct ipc_namespace *ns;\n\tstruct shm_file_data *sfd;\n\tstruct path path;\n\tfmode_t f_mode;\n\tunsigned long populate = 0;\n\n\terr = -EINVAL;\n\tif (shmid < 0)\n\t\tgoto out;\n\telse if ((addr = (ulong)shmaddr)) {\n\t\tif (addr & (shmlba - 1)) {\n\t\t\tif (shmflg & SHM_RND)\n\t\t\t\taddr &= ~(shmlba - 1);\t   /* round down */\n\t\t\telse\n#ifndef __ARCH_FORCE_SHMLBA\n\t\t\t\tif (addr & ~PAGE_MASK)\n#endif\n\t\t\t\t\tgoto out;\n\t\t}\n\t\tflags = MAP_SHARED | MAP_FIXED;\n\t} else {\n\t\tif ((shmflg & SHM_REMAP))\n\t\t\tgoto out;\n\n\t\tflags = MAP_SHARED;\n\t}\n\n\tif (shmflg & SHM_RDONLY) {\n\t\tprot = PROT_READ;\n\t\tacc_mode = S_IRUGO;\n\t\tf_mode = FMODE_READ;\n\t} else {\n\t\tprot = PROT_READ | PROT_WRITE;\n\t\tacc_mode = S_IRUGO | S_IWUGO;\n\t\tf_mode = FMODE_READ | FMODE_WRITE;\n\t}\n\tif (shmflg & SHM_EXEC) {\n\t\tprot |= PROT_EXEC;\n\t\tacc_mode |= S_IXUGO;\n\t}\n\n\t/*\n\t * We cannot rely on the fs check since SYSV IPC does have an\n\t * additional creator id...\n\t */\n\tns = current->nsproxy->ipc_ns;\n\trcu_read_lock();\n\tshp = shm_obtain_object_check(ns, shmid);\n\tif (IS_ERR(shp)) {\n\t\terr = PTR_ERR(shp);\n\t\tgoto out_unlock;\n\t}\n\n\terr = -EACCES;\n\tif (ipcperms(ns, &shp->shm_perm, acc_mode))\n\t\tgoto out_unlock;\n\n\terr = security_shm_shmat(shp, shmaddr, shmflg);\n\tif (err)\n\t\tgoto out_unlock;\n\n\tipc_lock_object(&shp->shm_perm);\n\n\t/* check if shm_destroy() is tearing down shp */\n\tif (shp->shm_file == NULL) {\n\t\tipc_unlock_object(&shp->shm_perm);\n\t\terr = -EIDRM;\n\t\tgoto out_unlock;\n\t}\n\n\tpath = shp->shm_file->f_path;\n\tpath_get(&path);\n\tshp->shm_nattch++;\n\tsize = i_size_read(path.dentry->d_inode);\n\tipc_unlock_object(&shp->shm_perm);\n\trcu_read_unlock();\n\n\terr = -ENOMEM;\n\tsfd = kzalloc(sizeof(*sfd), GFP_KERNEL);\n\tif (!sfd) {\n\t\tpath_put(&path);\n\t\tgoto out_nattch;\n\t}\n\n\tfile = alloc_file(&path, f_mode,\n\t\t\t  is_file_hugepages(shp->shm_file) ?\n\t\t\t\t&shm_file_operations_huge :\n\t\t\t\t&shm_file_operations);\n\terr = PTR_ERR(file);\n\tif (IS_ERR(file)) {\n\t\tkfree(sfd);\n\t\tpath_put(&path);\n\t\tgoto out_nattch;\n\t}\n\n\tfile->private_data = sfd;\n\tfile->f_mapping = shp->shm_file->f_mapping;\n\tsfd->id = shp->shm_perm.id;\n\tsfd->ns = get_ipc_ns(ns);\n\tsfd->file = shp->shm_file;\n\tsfd->vm_ops = NULL;\n\n\terr = security_mmap_file(file, prot, flags);\n\tif (err)\n\t\tgoto out_fput;\n\n\tdown_write(&current->mm->mmap_sem);\n\tif (addr && !(shmflg & SHM_REMAP)) {\n\t\terr = -EINVAL;\n\t\tif (find_vma_intersection(current->mm, addr, addr + size))\n\t\t\tgoto invalid;\n\t\t/*\n\t\t * If shm segment goes below stack, make sure there is some\n\t\t * space left for the stack to grow (at least 4 pages).\n\t\t */\n\t\tif (addr < current->mm->start_stack &&\n\t\t    addr > current->mm->start_stack - size - PAGE_SIZE * 5)\n\t\t\tgoto invalid;\n\t}\n\n\taddr = do_mmap_pgoff(file, addr, size, prot, flags, 0, &populate);\n\t*raddr = addr;\n\terr = 0;\n\tif (IS_ERR_VALUE(addr))\n\t\terr = (long)addr;\ninvalid:\n\tup_write(&current->mm->mmap_sem);\n\tif (populate)\n\t\tmm_populate(addr, populate);\n\nout_fput:\n\tfput(file);\n\nout_nattch:\n\tdown_write(&shm_ids(ns).rwsem);\n\tshp = shm_lock(ns, shmid);\n\tBUG_ON(IS_ERR(shp));\n\tshp->shm_nattch--;\n\tif (shm_may_destroy(ns, shp))\n\t\tshm_destroy(ns, shp);\n\telse\n\t\tshm_unlock(shp);\n\tup_write(&shm_ids(ns).rwsem);\n\treturn err;\n\nout_unlock:\n\trcu_read_unlock();\nout:\n\treturn err;\n}",
        "patch": "--- code before\n+++ code after\n@@ -71,6 +71,14 @@\n \t\tgoto out_unlock;\n \n \tipc_lock_object(&shp->shm_perm);\n+\n+\t/* check if shm_destroy() is tearing down shp */\n+\tif (shp->shm_file == NULL) {\n+\t\tipc_unlock_object(&shp->shm_perm);\n+\t\terr = -EIDRM;\n+\t\tgoto out_unlock;\n+\t}\n+\n \tpath = shp->shm_file->f_path;\n \tpath_get(&path);\n \tshp->shm_nattch++;",
        "function_modified_lines": {
            "added": [
                "",
                "\t/* check if shm_destroy() is tearing down shp */",
                "\tif (shp->shm_file == NULL) {",
                "\t\tipc_unlock_object(&shp->shm_perm);",
                "\t\terr = -EIDRM;",
                "\t\tgoto out_unlock;",
                "\t}",
                ""
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "Multiple race conditions in ipc/shm.c in the Linux kernel before 3.12.2 allow local users to cause a denial of service (use-after-free and system crash) or possibly have unspecified other impact via a crafted application that uses shmctl IPC_RMID operations in conjunction with other shm system calls.",
        "id": 357
    },
    {
        "cve_id": "CVE-2016-5195",
        "code_before_change": "static int faultin_page(struct task_struct *tsk, struct vm_area_struct *vma,\n\t\tunsigned long address, unsigned int *flags, int *nonblocking)\n{\n\tunsigned int fault_flags = 0;\n\tint ret;\n\n\t/* mlock all present pages, but do not fault in new pages */\n\tif ((*flags & (FOLL_POPULATE | FOLL_MLOCK)) == FOLL_MLOCK)\n\t\treturn -ENOENT;\n\t/* For mm_populate(), just skip the stack guard page. */\n\tif ((*flags & FOLL_POPULATE) &&\n\t\t\t(stack_guard_page_start(vma, address) ||\n\t\t\t stack_guard_page_end(vma, address + PAGE_SIZE)))\n\t\treturn -ENOENT;\n\tif (*flags & FOLL_WRITE)\n\t\tfault_flags |= FAULT_FLAG_WRITE;\n\tif (*flags & FOLL_REMOTE)\n\t\tfault_flags |= FAULT_FLAG_REMOTE;\n\tif (nonblocking)\n\t\tfault_flags |= FAULT_FLAG_ALLOW_RETRY;\n\tif (*flags & FOLL_NOWAIT)\n\t\tfault_flags |= FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_RETRY_NOWAIT;\n\tif (*flags & FOLL_TRIED) {\n\t\tVM_WARN_ON_ONCE(fault_flags & FAULT_FLAG_ALLOW_RETRY);\n\t\tfault_flags |= FAULT_FLAG_TRIED;\n\t}\n\n\tret = handle_mm_fault(vma, address, fault_flags);\n\tif (ret & VM_FAULT_ERROR) {\n\t\tif (ret & VM_FAULT_OOM)\n\t\t\treturn -ENOMEM;\n\t\tif (ret & (VM_FAULT_HWPOISON | VM_FAULT_HWPOISON_LARGE))\n\t\t\treturn *flags & FOLL_HWPOISON ? -EHWPOISON : -EFAULT;\n\t\tif (ret & (VM_FAULT_SIGBUS | VM_FAULT_SIGSEGV))\n\t\t\treturn -EFAULT;\n\t\tBUG();\n\t}\n\n\tif (tsk) {\n\t\tif (ret & VM_FAULT_MAJOR)\n\t\t\ttsk->maj_flt++;\n\t\telse\n\t\t\ttsk->min_flt++;\n\t}\n\n\tif (ret & VM_FAULT_RETRY) {\n\t\tif (nonblocking)\n\t\t\t*nonblocking = 0;\n\t\treturn -EBUSY;\n\t}\n\n\t/*\n\t * The VM_FAULT_WRITE bit tells us that do_wp_page has broken COW when\n\t * necessary, even if maybe_mkwrite decided not to set pte_write. We\n\t * can thus safely do subsequent page lookups as if they were reads.\n\t * But only do so when looping for pte_write is futile: in some cases\n\t * userspace may also be wanting to write to the gotten user page,\n\t * which a read fault here might prevent (a readonly page might get\n\t * reCOWed by userspace write).\n\t */\n\tif ((ret & VM_FAULT_WRITE) && !(vma->vm_flags & VM_WRITE))\n\t\t*flags &= ~FOLL_WRITE;\n\treturn 0;\n}",
        "code_after_change": "static int faultin_page(struct task_struct *tsk, struct vm_area_struct *vma,\n\t\tunsigned long address, unsigned int *flags, int *nonblocking)\n{\n\tunsigned int fault_flags = 0;\n\tint ret;\n\n\t/* mlock all present pages, but do not fault in new pages */\n\tif ((*flags & (FOLL_POPULATE | FOLL_MLOCK)) == FOLL_MLOCK)\n\t\treturn -ENOENT;\n\t/* For mm_populate(), just skip the stack guard page. */\n\tif ((*flags & FOLL_POPULATE) &&\n\t\t\t(stack_guard_page_start(vma, address) ||\n\t\t\t stack_guard_page_end(vma, address + PAGE_SIZE)))\n\t\treturn -ENOENT;\n\tif (*flags & FOLL_WRITE)\n\t\tfault_flags |= FAULT_FLAG_WRITE;\n\tif (*flags & FOLL_REMOTE)\n\t\tfault_flags |= FAULT_FLAG_REMOTE;\n\tif (nonblocking)\n\t\tfault_flags |= FAULT_FLAG_ALLOW_RETRY;\n\tif (*flags & FOLL_NOWAIT)\n\t\tfault_flags |= FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_RETRY_NOWAIT;\n\tif (*flags & FOLL_TRIED) {\n\t\tVM_WARN_ON_ONCE(fault_flags & FAULT_FLAG_ALLOW_RETRY);\n\t\tfault_flags |= FAULT_FLAG_TRIED;\n\t}\n\n\tret = handle_mm_fault(vma, address, fault_flags);\n\tif (ret & VM_FAULT_ERROR) {\n\t\tif (ret & VM_FAULT_OOM)\n\t\t\treturn -ENOMEM;\n\t\tif (ret & (VM_FAULT_HWPOISON | VM_FAULT_HWPOISON_LARGE))\n\t\t\treturn *flags & FOLL_HWPOISON ? -EHWPOISON : -EFAULT;\n\t\tif (ret & (VM_FAULT_SIGBUS | VM_FAULT_SIGSEGV))\n\t\t\treturn -EFAULT;\n\t\tBUG();\n\t}\n\n\tif (tsk) {\n\t\tif (ret & VM_FAULT_MAJOR)\n\t\t\ttsk->maj_flt++;\n\t\telse\n\t\t\ttsk->min_flt++;\n\t}\n\n\tif (ret & VM_FAULT_RETRY) {\n\t\tif (nonblocking)\n\t\t\t*nonblocking = 0;\n\t\treturn -EBUSY;\n\t}\n\n\t/*\n\t * The VM_FAULT_WRITE bit tells us that do_wp_page has broken COW when\n\t * necessary, even if maybe_mkwrite decided not to set pte_write. We\n\t * can thus safely do subsequent page lookups as if they were reads.\n\t * But only do so when looping for pte_write is futile: in some cases\n\t * userspace may also be wanting to write to the gotten user page,\n\t * which a read fault here might prevent (a readonly page might get\n\t * reCOWed by userspace write).\n\t */\n\tif ((ret & VM_FAULT_WRITE) && !(vma->vm_flags & VM_WRITE))\n\t        *flags |= FOLL_COW;\n\treturn 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -59,6 +59,6 @@\n \t * reCOWed by userspace write).\n \t */\n \tif ((ret & VM_FAULT_WRITE) && !(vma->vm_flags & VM_WRITE))\n-\t\t*flags &= ~FOLL_WRITE;\n+\t        *flags |= FOLL_COW;\n \treturn 0;\n }",
        "function_modified_lines": {
            "added": [
                "\t        *flags |= FOLL_COW;"
            ],
            "deleted": [
                "\t\t*flags &= ~FOLL_WRITE;"
            ]
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "Race condition in mm/gup.c in the Linux kernel 2.x through 4.x before 4.8.3 allows local users to gain privileges by leveraging incorrect handling of a copy-on-write (COW) feature to write to a read-only memory mapping, as exploited in the wild in October 2016, aka \"Dirty COW.\"",
        "id": 1051
    },
    {
        "cve_id": "CVE-2022-20154",
        "code_before_change": "static void sctp_endpoint_destroy(struct sctp_endpoint *ep)\n{\n\tstruct sock *sk;\n\n\tif (unlikely(!ep->base.dead)) {\n\t\tWARN(1, \"Attempt to destroy undead endpoint %p!\\n\", ep);\n\t\treturn;\n\t}\n\n\t/* Free the digest buffer */\n\tkfree(ep->digest);\n\n\t/* SCTP-AUTH: Free up AUTH releated data such as shared keys\n\t * chunks and hmacs arrays that were allocated\n\t */\n\tsctp_auth_destroy_keys(&ep->endpoint_shared_keys);\n\tsctp_auth_free(ep);\n\n\t/* Cleanup. */\n\tsctp_inq_free(&ep->base.inqueue);\n\tsctp_bind_addr_free(&ep->base.bind_addr);\n\n\tmemset(ep->secret_key, 0, sizeof(ep->secret_key));\n\n\tsk = ep->base.sk;\n\t/* Remove and free the port */\n\tif (sctp_sk(sk)->bind_hash)\n\t\tsctp_put_port(sk);\n\n\tsctp_sk(sk)->ep = NULL;\n\t/* Give up our hold on the sock */\n\tsock_put(sk);\n\n\tkfree(ep);\n\tSCTP_DBG_OBJCNT_DEC(ep);\n}",
        "code_after_change": "static void sctp_endpoint_destroy(struct sctp_endpoint *ep)\n{\n\tstruct sock *sk;\n\n\tif (unlikely(!ep->base.dead)) {\n\t\tWARN(1, \"Attempt to destroy undead endpoint %p!\\n\", ep);\n\t\treturn;\n\t}\n\n\t/* Free the digest buffer */\n\tkfree(ep->digest);\n\n\t/* SCTP-AUTH: Free up AUTH releated data such as shared keys\n\t * chunks and hmacs arrays that were allocated\n\t */\n\tsctp_auth_destroy_keys(&ep->endpoint_shared_keys);\n\tsctp_auth_free(ep);\n\n\t/* Cleanup. */\n\tsctp_inq_free(&ep->base.inqueue);\n\tsctp_bind_addr_free(&ep->base.bind_addr);\n\n\tmemset(ep->secret_key, 0, sizeof(ep->secret_key));\n\n\tsk = ep->base.sk;\n\t/* Remove and free the port */\n\tif (sctp_sk(sk)->bind_hash)\n\t\tsctp_put_port(sk);\n\n\tcall_rcu(&ep->rcu, sctp_endpoint_destroy_rcu);\n}",
        "patch": "--- code before\n+++ code after\n@@ -27,10 +27,5 @@\n \tif (sctp_sk(sk)->bind_hash)\n \t\tsctp_put_port(sk);\n \n-\tsctp_sk(sk)->ep = NULL;\n-\t/* Give up our hold on the sock */\n-\tsock_put(sk);\n-\n-\tkfree(ep);\n-\tSCTP_DBG_OBJCNT_DEC(ep);\n+\tcall_rcu(&ep->rcu, sctp_endpoint_destroy_rcu);\n }",
        "function_modified_lines": {
            "added": [
                "\tcall_rcu(&ep->rcu, sctp_endpoint_destroy_rcu);"
            ],
            "deleted": [
                "\tsctp_sk(sk)->ep = NULL;",
                "\t/* Give up our hold on the sock */",
                "\tsock_put(sk);",
                "",
                "\tkfree(ep);",
                "\tSCTP_DBG_OBJCNT_DEC(ep);"
            ]
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "In lock_sock_nested of sock.c, there is a possible use after free due to a race condition. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-174846563References: Upstream kernel",
        "id": 3342
    },
    {
        "cve_id": "CVE-2017-6346",
        "code_before_change": "static int fanout_add(struct sock *sk, u16 id, u16 type_flags)\n{\n\tstruct packet_sock *po = pkt_sk(sk);\n\tstruct packet_fanout *f, *match;\n\tu8 type = type_flags & 0xff;\n\tu8 flags = type_flags >> 8;\n\tint err;\n\n\tswitch (type) {\n\tcase PACKET_FANOUT_ROLLOVER:\n\t\tif (type_flags & PACKET_FANOUT_FLAG_ROLLOVER)\n\t\t\treturn -EINVAL;\n\tcase PACKET_FANOUT_HASH:\n\tcase PACKET_FANOUT_LB:\n\tcase PACKET_FANOUT_CPU:\n\tcase PACKET_FANOUT_RND:\n\tcase PACKET_FANOUT_QM:\n\tcase PACKET_FANOUT_CBPF:\n\tcase PACKET_FANOUT_EBPF:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (!po->running)\n\t\treturn -EINVAL;\n\n\tif (po->fanout)\n\t\treturn -EALREADY;\n\n\tif (type == PACKET_FANOUT_ROLLOVER ||\n\t    (type_flags & PACKET_FANOUT_FLAG_ROLLOVER)) {\n\t\tpo->rollover = kzalloc(sizeof(*po->rollover), GFP_KERNEL);\n\t\tif (!po->rollover)\n\t\t\treturn -ENOMEM;\n\t\tatomic_long_set(&po->rollover->num, 0);\n\t\tatomic_long_set(&po->rollover->num_huge, 0);\n\t\tatomic_long_set(&po->rollover->num_failed, 0);\n\t}\n\n\tmutex_lock(&fanout_mutex);\n\tmatch = NULL;\n\tlist_for_each_entry(f, &fanout_list, list) {\n\t\tif (f->id == id &&\n\t\t    read_pnet(&f->net) == sock_net(sk)) {\n\t\t\tmatch = f;\n\t\t\tbreak;\n\t\t}\n\t}\n\terr = -EINVAL;\n\tif (match && match->flags != flags)\n\t\tgoto out;\n\tif (!match) {\n\t\terr = -ENOMEM;\n\t\tmatch = kzalloc(sizeof(*match), GFP_KERNEL);\n\t\tif (!match)\n\t\t\tgoto out;\n\t\twrite_pnet(&match->net, sock_net(sk));\n\t\tmatch->id = id;\n\t\tmatch->type = type;\n\t\tmatch->flags = flags;\n\t\tINIT_LIST_HEAD(&match->list);\n\t\tspin_lock_init(&match->lock);\n\t\tatomic_set(&match->sk_ref, 0);\n\t\tfanout_init_data(match);\n\t\tmatch->prot_hook.type = po->prot_hook.type;\n\t\tmatch->prot_hook.dev = po->prot_hook.dev;\n\t\tmatch->prot_hook.func = packet_rcv_fanout;\n\t\tmatch->prot_hook.af_packet_priv = match;\n\t\tmatch->prot_hook.id_match = match_fanout_group;\n\t\tdev_add_pack(&match->prot_hook);\n\t\tlist_add(&match->list, &fanout_list);\n\t}\n\terr = -EINVAL;\n\tif (match->type == type &&\n\t    match->prot_hook.type == po->prot_hook.type &&\n\t    match->prot_hook.dev == po->prot_hook.dev) {\n\t\terr = -ENOSPC;\n\t\tif (atomic_read(&match->sk_ref) < PACKET_FANOUT_MAX) {\n\t\t\t__dev_remove_pack(&po->prot_hook);\n\t\t\tpo->fanout = match;\n\t\t\tatomic_inc(&match->sk_ref);\n\t\t\t__fanout_link(sk, po);\n\t\t\terr = 0;\n\t\t}\n\t}\nout:\n\tmutex_unlock(&fanout_mutex);\n\tif (err) {\n\t\tkfree(po->rollover);\n\t\tpo->rollover = NULL;\n\t}\n\treturn err;\n}",
        "code_after_change": "static int fanout_add(struct sock *sk, u16 id, u16 type_flags)\n{\n\tstruct packet_rollover *rollover = NULL;\n\tstruct packet_sock *po = pkt_sk(sk);\n\tstruct packet_fanout *f, *match;\n\tu8 type = type_flags & 0xff;\n\tu8 flags = type_flags >> 8;\n\tint err;\n\n\tswitch (type) {\n\tcase PACKET_FANOUT_ROLLOVER:\n\t\tif (type_flags & PACKET_FANOUT_FLAG_ROLLOVER)\n\t\t\treturn -EINVAL;\n\tcase PACKET_FANOUT_HASH:\n\tcase PACKET_FANOUT_LB:\n\tcase PACKET_FANOUT_CPU:\n\tcase PACKET_FANOUT_RND:\n\tcase PACKET_FANOUT_QM:\n\tcase PACKET_FANOUT_CBPF:\n\tcase PACKET_FANOUT_EBPF:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&fanout_mutex);\n\n\terr = -EINVAL;\n\tif (!po->running)\n\t\tgoto out;\n\n\terr = -EALREADY;\n\tif (po->fanout)\n\t\tgoto out;\n\n\tif (type == PACKET_FANOUT_ROLLOVER ||\n\t    (type_flags & PACKET_FANOUT_FLAG_ROLLOVER)) {\n\t\terr = -ENOMEM;\n\t\trollover = kzalloc(sizeof(*rollover), GFP_KERNEL);\n\t\tif (!rollover)\n\t\t\tgoto out;\n\t\tatomic_long_set(&rollover->num, 0);\n\t\tatomic_long_set(&rollover->num_huge, 0);\n\t\tatomic_long_set(&rollover->num_failed, 0);\n\t\tpo->rollover = rollover;\n\t}\n\n\tmatch = NULL;\n\tlist_for_each_entry(f, &fanout_list, list) {\n\t\tif (f->id == id &&\n\t\t    read_pnet(&f->net) == sock_net(sk)) {\n\t\t\tmatch = f;\n\t\t\tbreak;\n\t\t}\n\t}\n\terr = -EINVAL;\n\tif (match && match->flags != flags)\n\t\tgoto out;\n\tif (!match) {\n\t\terr = -ENOMEM;\n\t\tmatch = kzalloc(sizeof(*match), GFP_KERNEL);\n\t\tif (!match)\n\t\t\tgoto out;\n\t\twrite_pnet(&match->net, sock_net(sk));\n\t\tmatch->id = id;\n\t\tmatch->type = type;\n\t\tmatch->flags = flags;\n\t\tINIT_LIST_HEAD(&match->list);\n\t\tspin_lock_init(&match->lock);\n\t\tatomic_set(&match->sk_ref, 0);\n\t\tfanout_init_data(match);\n\t\tmatch->prot_hook.type = po->prot_hook.type;\n\t\tmatch->prot_hook.dev = po->prot_hook.dev;\n\t\tmatch->prot_hook.func = packet_rcv_fanout;\n\t\tmatch->prot_hook.af_packet_priv = match;\n\t\tmatch->prot_hook.id_match = match_fanout_group;\n\t\tdev_add_pack(&match->prot_hook);\n\t\tlist_add(&match->list, &fanout_list);\n\t}\n\terr = -EINVAL;\n\tif (match->type == type &&\n\t    match->prot_hook.type == po->prot_hook.type &&\n\t    match->prot_hook.dev == po->prot_hook.dev) {\n\t\terr = -ENOSPC;\n\t\tif (atomic_read(&match->sk_ref) < PACKET_FANOUT_MAX) {\n\t\t\t__dev_remove_pack(&po->prot_hook);\n\t\t\tpo->fanout = match;\n\t\t\tatomic_inc(&match->sk_ref);\n\t\t\t__fanout_link(sk, po);\n\t\t\terr = 0;\n\t\t}\n\t}\nout:\n\tif (err && rollover) {\n\t\tkfree(rollover);\n\t\tpo->rollover = NULL;\n\t}\n\tmutex_unlock(&fanout_mutex);\n\treturn err;\n}",
        "patch": "--- code before\n+++ code after\n@@ -1,5 +1,6 @@\n static int fanout_add(struct sock *sk, u16 id, u16 type_flags)\n {\n+\tstruct packet_rollover *rollover = NULL;\n \tstruct packet_sock *po = pkt_sk(sk);\n \tstruct packet_fanout *f, *match;\n \tu8 type = type_flags & 0xff;\n@@ -22,23 +23,28 @@\n \t\treturn -EINVAL;\n \t}\n \n+\tmutex_lock(&fanout_mutex);\n+\n+\terr = -EINVAL;\n \tif (!po->running)\n-\t\treturn -EINVAL;\n+\t\tgoto out;\n \n+\terr = -EALREADY;\n \tif (po->fanout)\n-\t\treturn -EALREADY;\n+\t\tgoto out;\n \n \tif (type == PACKET_FANOUT_ROLLOVER ||\n \t    (type_flags & PACKET_FANOUT_FLAG_ROLLOVER)) {\n-\t\tpo->rollover = kzalloc(sizeof(*po->rollover), GFP_KERNEL);\n-\t\tif (!po->rollover)\n-\t\t\treturn -ENOMEM;\n-\t\tatomic_long_set(&po->rollover->num, 0);\n-\t\tatomic_long_set(&po->rollover->num_huge, 0);\n-\t\tatomic_long_set(&po->rollover->num_failed, 0);\n+\t\terr = -ENOMEM;\n+\t\trollover = kzalloc(sizeof(*rollover), GFP_KERNEL);\n+\t\tif (!rollover)\n+\t\t\tgoto out;\n+\t\tatomic_long_set(&rollover->num, 0);\n+\t\tatomic_long_set(&rollover->num_huge, 0);\n+\t\tatomic_long_set(&rollover->num_failed, 0);\n+\t\tpo->rollover = rollover;\n \t}\n \n-\tmutex_lock(&fanout_mutex);\n \tmatch = NULL;\n \tlist_for_each_entry(f, &fanout_list, list) {\n \t\tif (f->id == id &&\n@@ -85,10 +91,10 @@\n \t\t}\n \t}\n out:\n-\tmutex_unlock(&fanout_mutex);\n-\tif (err) {\n-\t\tkfree(po->rollover);\n+\tif (err && rollover) {\n+\t\tkfree(rollover);\n \t\tpo->rollover = NULL;\n \t}\n+\tmutex_unlock(&fanout_mutex);\n \treturn err;\n }",
        "function_modified_lines": {
            "added": [
                "\tstruct packet_rollover *rollover = NULL;",
                "\tmutex_lock(&fanout_mutex);",
                "",
                "\terr = -EINVAL;",
                "\t\tgoto out;",
                "\terr = -EALREADY;",
                "\t\tgoto out;",
                "\t\terr = -ENOMEM;",
                "\t\trollover = kzalloc(sizeof(*rollover), GFP_KERNEL);",
                "\t\tif (!rollover)",
                "\t\t\tgoto out;",
                "\t\tatomic_long_set(&rollover->num, 0);",
                "\t\tatomic_long_set(&rollover->num_huge, 0);",
                "\t\tatomic_long_set(&rollover->num_failed, 0);",
                "\t\tpo->rollover = rollover;",
                "\tif (err && rollover) {",
                "\t\tkfree(rollover);",
                "\tmutex_unlock(&fanout_mutex);"
            ],
            "deleted": [
                "\t\treturn -EINVAL;",
                "\t\treturn -EALREADY;",
                "\t\tpo->rollover = kzalloc(sizeof(*po->rollover), GFP_KERNEL);",
                "\t\tif (!po->rollover)",
                "\t\t\treturn -ENOMEM;",
                "\t\tatomic_long_set(&po->rollover->num, 0);",
                "\t\tatomic_long_set(&po->rollover->num_huge, 0);",
                "\t\tatomic_long_set(&po->rollover->num_failed, 0);",
                "\tmutex_lock(&fanout_mutex);",
                "\tmutex_unlock(&fanout_mutex);",
                "\tif (err) {",
                "\t\tkfree(po->rollover);"
            ]
        },
        "cwe": [
            "CWE-362",
            "CWE-416"
        ],
        "cve_description": "Race condition in net/packet/af_packet.c in the Linux kernel before 4.9.13 allows local users to cause a denial of service (use-after-free) or possibly have unspecified other impact via a multithreaded application that makes PACKET_FANOUT setsockopt system calls.",
        "id": 1482
    },
    {
        "cve_id": "CVE-2020-27675",
        "code_before_change": "evtchn_port_t evtchn_from_irq(unsigned irq)\n{\n\tif (WARN(irq >= nr_irqs, \"Invalid irq %d!\\n\", irq))\n\t\treturn 0;\n\n\treturn info_for_irq(irq)->evtchn;\n}",
        "code_after_change": "evtchn_port_t evtchn_from_irq(unsigned irq)\n{\n\tconst struct irq_info *info = NULL;\n\n\tif (likely(irq < nr_irqs))\n\t\tinfo = info_for_irq(irq);\n\tif (!info)\n\t\treturn 0;\n\n\treturn info->evtchn;\n}",
        "patch": "--- code before\n+++ code after\n@@ -1,7 +1,11 @@\n evtchn_port_t evtchn_from_irq(unsigned irq)\n {\n-\tif (WARN(irq >= nr_irqs, \"Invalid irq %d!\\n\", irq))\n+\tconst struct irq_info *info = NULL;\n+\n+\tif (likely(irq < nr_irqs))\n+\t\tinfo = info_for_irq(irq);\n+\tif (!info)\n \t\treturn 0;\n \n-\treturn info_for_irq(irq)->evtchn;\n+\treturn info->evtchn;\n }",
        "function_modified_lines": {
            "added": [
                "\tconst struct irq_info *info = NULL;",
                "",
                "\tif (likely(irq < nr_irqs))",
                "\t\tinfo = info_for_irq(irq);",
                "\tif (!info)",
                "\treturn info->evtchn;"
            ],
            "deleted": [
                "\tif (WARN(irq >= nr_irqs, \"Invalid irq %d!\\n\", irq))",
                "\treturn info_for_irq(irq)->evtchn;"
            ]
        },
        "cwe": [
            "CWE-362",
            "CWE-476",
            "CWE-416"
        ],
        "cve_description": "An issue was discovered in the Linux kernel through 5.9.1, as used with Xen through 4.14.x. drivers/xen/events/events_base.c allows event-channel removal during the event-handling loop (a race condition). This can cause a use-after-free or NULL pointer dereference, as demonstrated by a dom0 crash via events for an in-reconfiguration paravirtualized device, aka CID-073d0552ead5.",
        "id": 2626
    },
    {
        "cve_id": "CVE-2023-35823",
        "code_before_change": "void saa7134_video_fini(struct saa7134_dev *dev)\n{\n\t/* free stuff */\n\tsaa7134_pgtable_free(dev->pci, &dev->video_q.pt);\n\tsaa7134_pgtable_free(dev->pci, &dev->vbi_q.pt);\n\tv4l2_ctrl_handler_free(&dev->ctrl_handler);\n\tif (card_has_radio(dev))\n\t\tv4l2_ctrl_handler_free(&dev->radio_ctrl_handler);\n}",
        "code_after_change": "void saa7134_video_fini(struct saa7134_dev *dev)\n{\n\tdel_timer_sync(&dev->video_q.timeout);\n\t/* free stuff */\n\tsaa7134_pgtable_free(dev->pci, &dev->video_q.pt);\n\tsaa7134_pgtable_free(dev->pci, &dev->vbi_q.pt);\n\tv4l2_ctrl_handler_free(&dev->ctrl_handler);\n\tif (card_has_radio(dev))\n\t\tv4l2_ctrl_handler_free(&dev->radio_ctrl_handler);\n}",
        "patch": "--- code before\n+++ code after\n@@ -1,5 +1,6 @@\n void saa7134_video_fini(struct saa7134_dev *dev)\n {\n+\tdel_timer_sync(&dev->video_q.timeout);\n \t/* free stuff */\n \tsaa7134_pgtable_free(dev->pci, &dev->video_q.pt);\n \tsaa7134_pgtable_free(dev->pci, &dev->vbi_q.pt);",
        "function_modified_lines": {
            "added": [
                "\tdel_timer_sync(&dev->video_q.timeout);"
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-362",
            "CWE-416"
        ],
        "cve_description": "An issue was discovered in the Linux kernel before 6.3.2. A use-after-free was found in saa7134_finidev in drivers/media/pci/saa7134/saa7134-core.c.",
        "id": 4111
    },
    {
        "cve_id": "CVE-2023-35823",
        "code_before_change": "int saa7134_vbi_fini(struct saa7134_dev *dev)\n{\n\t/* nothing */\n\treturn 0;\n}",
        "code_after_change": "int saa7134_vbi_fini(struct saa7134_dev *dev)\n{\n\t/* nothing */\n\tdel_timer_sync(&dev->vbi_q.timeout);\n\treturn 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -1,5 +1,6 @@\n int saa7134_vbi_fini(struct saa7134_dev *dev)\n {\n \t/* nothing */\n+\tdel_timer_sync(&dev->vbi_q.timeout);\n \treturn 0;\n }",
        "function_modified_lines": {
            "added": [
                "\tdel_timer_sync(&dev->vbi_q.timeout);"
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-362",
            "CWE-416"
        ],
        "cve_description": "An issue was discovered in the Linux kernel before 6.3.2. A use-after-free was found in saa7134_finidev in drivers/media/pci/saa7134/saa7134-core.c.",
        "id": 4110
    },
    {
        "cve_id": "CVE-2023-3108",
        "code_before_change": "int af_alg_make_sg(struct af_alg_sgl *sgl, struct iov_iter *iter, int len)\n{\n\tsize_t off;\n\tssize_t n;\n\tint npages, i;\n\n\tn = iov_iter_get_pages(iter, sgl->pages, len, ALG_MAX_PAGES, &off);\n\tif (n < 0)\n\t\treturn n;\n\n\tnpages = PAGE_ALIGN(off + n);\n\tif (WARN_ON(npages == 0))\n\t\treturn -EINVAL;\n\n\tsg_init_table(sgl->sg, npages);\n\n\tfor (i = 0, len = n; i < npages; i++) {\n\t\tint plen = min_t(int, len, PAGE_SIZE - off);\n\n\t\tsg_set_page(sgl->sg + i, sgl->pages[i], plen, off);\n\n\t\toff = 0;\n\t\tlen -= plen;\n\t}\n\treturn n;\n}",
        "code_after_change": "int af_alg_make_sg(struct af_alg_sgl *sgl, struct iov_iter *iter, int len)\n{\n\tsize_t off;\n\tssize_t n;\n\tint npages, i;\n\n\tn = iov_iter_get_pages(iter, sgl->pages, len, ALG_MAX_PAGES, &off);\n\tif (n < 0)\n\t\treturn n;\n\n\tnpages = (off + n + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tif (WARN_ON(npages == 0))\n\t\treturn -EINVAL;\n\n\tsg_init_table(sgl->sg, npages);\n\n\tfor (i = 0, len = n; i < npages; i++) {\n\t\tint plen = min_t(int, len, PAGE_SIZE - off);\n\n\t\tsg_set_page(sgl->sg + i, sgl->pages[i], plen, off);\n\n\t\toff = 0;\n\t\tlen -= plen;\n\t}\n\treturn n;\n}",
        "patch": "--- code before\n+++ code after\n@@ -8,7 +8,7 @@\n \tif (n < 0)\n \t\treturn n;\n \n-\tnpages = PAGE_ALIGN(off + n);\n+\tnpages = (off + n + PAGE_SIZE - 1) >> PAGE_SHIFT;\n \tif (WARN_ON(npages == 0))\n \t\treturn -EINVAL;\n ",
        "function_modified_lines": {
            "added": [
                "\tnpages = (off + n + PAGE_SIZE - 1) >> PAGE_SHIFT;"
            ],
            "deleted": [
                "\tnpages = PAGE_ALIGN(off + n);"
            ]
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "A flaw was found in the subsequent get_user_pages_fast in the Linux kernel\u2019s interface for symmetric key cipher algorithms in the skcipher_recvmsg of crypto/algif_skcipher.c function. This flaw allows a local user to crash the system.",
        "id": 3993
    },
    {
        "cve_id": "CVE-2017-12146",
        "code_before_change": "static ssize_t driver_override_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\n\treturn sprintf(buf, \"%s\\n\", pdev->driver_override);\n}",
        "code_after_change": "static ssize_t driver_override_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tssize_t len;\n\n\tdevice_lock(dev);\n\tlen = sprintf(buf, \"%s\\n\", pdev->driver_override);\n\tdevice_unlock(dev);\n\treturn len;\n}",
        "patch": "--- code before\n+++ code after\n@@ -2,6 +2,10 @@\n \t\t\t\t    struct device_attribute *attr, char *buf)\n {\n \tstruct platform_device *pdev = to_platform_device(dev);\n+\tssize_t len;\n \n-\treturn sprintf(buf, \"%s\\n\", pdev->driver_override);\n+\tdevice_lock(dev);\n+\tlen = sprintf(buf, \"%s\\n\", pdev->driver_override);\n+\tdevice_unlock(dev);\n+\treturn len;\n }",
        "function_modified_lines": {
            "added": [
                "\tssize_t len;",
                "\tdevice_lock(dev);",
                "\tlen = sprintf(buf, \"%s\\n\", pdev->driver_override);",
                "\tdevice_unlock(dev);",
                "\treturn len;"
            ],
            "deleted": [
                "\treturn sprintf(buf, \"%s\\n\", pdev->driver_override);"
            ]
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "The driver_override implementation in drivers/base/platform.c in the Linux kernel before 4.12.1 allows local users to gain privileges by leveraging a race condition between a read operation and a store operation that involve different overrides.",
        "id": 1255
    },
    {
        "cve_id": "CVE-2014-9710",
        "code_before_change": "static struct btrfs_dir_item *btrfs_match_dir_item_name(struct btrfs_root *root,\n\t\t\t      struct btrfs_path *path,\n\t\t\t      const char *name, int name_len)\n{\n\tstruct btrfs_dir_item *dir_item;\n\tunsigned long name_ptr;\n\tu32 total_len;\n\tu32 cur = 0;\n\tu32 this_len;\n\tstruct extent_buffer *leaf;\n\n\tleaf = path->nodes[0];\n\tdir_item = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_dir_item);\n\tif (verify_dir_item(root, leaf, dir_item))\n\t\treturn NULL;\n\n\ttotal_len = btrfs_item_size_nr(leaf, path->slots[0]);\n\twhile (cur < total_len) {\n\t\tthis_len = sizeof(*dir_item) +\n\t\t\tbtrfs_dir_name_len(leaf, dir_item) +\n\t\t\tbtrfs_dir_data_len(leaf, dir_item);\n\t\tname_ptr = (unsigned long)(dir_item + 1);\n\n\t\tif (btrfs_dir_name_len(leaf, dir_item) == name_len &&\n\t\t    memcmp_extent_buffer(leaf, name, name_ptr, name_len) == 0)\n\t\t\treturn dir_item;\n\n\t\tcur += this_len;\n\t\tdir_item = (struct btrfs_dir_item *)((char *)dir_item +\n\t\t\t\t\t\t     this_len);\n\t}\n\treturn NULL;\n}",
        "code_after_change": "struct btrfs_dir_item *btrfs_match_dir_item_name(struct btrfs_root *root,\n\t\t\t\t\t\t struct btrfs_path *path,\n\t\t\t\t\t\t const char *name, int name_len)\n{\n\tstruct btrfs_dir_item *dir_item;\n\tunsigned long name_ptr;\n\tu32 total_len;\n\tu32 cur = 0;\n\tu32 this_len;\n\tstruct extent_buffer *leaf;\n\n\tleaf = path->nodes[0];\n\tdir_item = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_dir_item);\n\tif (verify_dir_item(root, leaf, dir_item))\n\t\treturn NULL;\n\n\ttotal_len = btrfs_item_size_nr(leaf, path->slots[0]);\n\twhile (cur < total_len) {\n\t\tthis_len = sizeof(*dir_item) +\n\t\t\tbtrfs_dir_name_len(leaf, dir_item) +\n\t\t\tbtrfs_dir_data_len(leaf, dir_item);\n\t\tname_ptr = (unsigned long)(dir_item + 1);\n\n\t\tif (btrfs_dir_name_len(leaf, dir_item) == name_len &&\n\t\t    memcmp_extent_buffer(leaf, name, name_ptr, name_len) == 0)\n\t\t\treturn dir_item;\n\n\t\tcur += this_len;\n\t\tdir_item = (struct btrfs_dir_item *)((char *)dir_item +\n\t\t\t\t\t\t     this_len);\n\t}\n\treturn NULL;\n}",
        "patch": "--- code before\n+++ code after\n@@ -1,6 +1,6 @@\n-static struct btrfs_dir_item *btrfs_match_dir_item_name(struct btrfs_root *root,\n-\t\t\t      struct btrfs_path *path,\n-\t\t\t      const char *name, int name_len)\n+struct btrfs_dir_item *btrfs_match_dir_item_name(struct btrfs_root *root,\n+\t\t\t\t\t\t struct btrfs_path *path,\n+\t\t\t\t\t\t const char *name, int name_len)\n {\n \tstruct btrfs_dir_item *dir_item;\n \tunsigned long name_ptr;",
        "function_modified_lines": {
            "added": [
                "struct btrfs_dir_item *btrfs_match_dir_item_name(struct btrfs_root *root,",
                "\t\t\t\t\t\t struct btrfs_path *path,",
                "\t\t\t\t\t\t const char *name, int name_len)"
            ],
            "deleted": [
                "static struct btrfs_dir_item *btrfs_match_dir_item_name(struct btrfs_root *root,",
                "\t\t\t      struct btrfs_path *path,",
                "\t\t\t      const char *name, int name_len)"
            ]
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "The Btrfs implementation in the Linux kernel before 3.19 does not ensure that the visible xattr state is consistent with a requested replacement, which allows local users to bypass intended ACL settings and gain privileges via standard filesystem operations (1) during an xattr-replacement time window, related to a race condition, or (2) after an xattr-replacement attempt that fails because the data does not fit.",
        "id": 689
    },
    {
        "cve_id": "CVE-2015-8767",
        "code_before_change": "void sctp_generate_proto_unreach_event(unsigned long data)\n{\n\tstruct sctp_transport *transport = (struct sctp_transport *) data;\n\tstruct sctp_association *asoc = transport->asoc;\n\tstruct net *net = sock_net(asoc->base.sk);\n\n\tbh_lock_sock(asoc->base.sk);\n\tif (sock_owned_by_user(asoc->base.sk)) {\n\t\tpr_debug(\"%s: sock is busy\\n\", __func__);\n\n\t\t/* Try again later.  */\n\t\tif (!mod_timer(&transport->proto_unreach_timer,\n\t\t\t\tjiffies + (HZ/20)))\n\t\t\tsctp_association_hold(asoc);\n\t\tgoto out_unlock;\n\t}\n\n\t/* Is this structure just waiting around for us to actually\n\t * get destroyed?\n\t */\n\tif (asoc->base.dead)\n\t\tgoto out_unlock;\n\n\tsctp_do_sm(net, SCTP_EVENT_T_OTHER,\n\t\t   SCTP_ST_OTHER(SCTP_EVENT_ICMP_PROTO_UNREACH),\n\t\t   asoc->state, asoc->ep, asoc, transport, GFP_ATOMIC);\n\nout_unlock:\n\tbh_unlock_sock(asoc->base.sk);\n\tsctp_association_put(asoc);\n}",
        "code_after_change": "void sctp_generate_proto_unreach_event(unsigned long data)\n{\n\tstruct sctp_transport *transport = (struct sctp_transport *) data;\n\tstruct sctp_association *asoc = transport->asoc;\n\tstruct sock *sk = asoc->base.sk;\n\tstruct net *net = sock_net(sk);\n\n\tbh_lock_sock(sk);\n\tif (sock_owned_by_user(sk)) {\n\t\tpr_debug(\"%s: sock is busy\\n\", __func__);\n\n\t\t/* Try again later.  */\n\t\tif (!mod_timer(&transport->proto_unreach_timer,\n\t\t\t\tjiffies + (HZ/20)))\n\t\t\tsctp_association_hold(asoc);\n\t\tgoto out_unlock;\n\t}\n\n\t/* Is this structure just waiting around for us to actually\n\t * get destroyed?\n\t */\n\tif (asoc->base.dead)\n\t\tgoto out_unlock;\n\n\tsctp_do_sm(net, SCTP_EVENT_T_OTHER,\n\t\t   SCTP_ST_OTHER(SCTP_EVENT_ICMP_PROTO_UNREACH),\n\t\t   asoc->state, asoc->ep, asoc, transport, GFP_ATOMIC);\n\nout_unlock:\n\tbh_unlock_sock(sk);\n\tsctp_association_put(asoc);\n}",
        "patch": "--- code before\n+++ code after\n@@ -2,10 +2,11 @@\n {\n \tstruct sctp_transport *transport = (struct sctp_transport *) data;\n \tstruct sctp_association *asoc = transport->asoc;\n-\tstruct net *net = sock_net(asoc->base.sk);\n+\tstruct sock *sk = asoc->base.sk;\n+\tstruct net *net = sock_net(sk);\n \n-\tbh_lock_sock(asoc->base.sk);\n-\tif (sock_owned_by_user(asoc->base.sk)) {\n+\tbh_lock_sock(sk);\n+\tif (sock_owned_by_user(sk)) {\n \t\tpr_debug(\"%s: sock is busy\\n\", __func__);\n \n \t\t/* Try again later.  */\n@@ -26,6 +27,6 @@\n \t\t   asoc->state, asoc->ep, asoc, transport, GFP_ATOMIC);\n \n out_unlock:\n-\tbh_unlock_sock(asoc->base.sk);\n+\tbh_unlock_sock(sk);\n \tsctp_association_put(asoc);\n }",
        "function_modified_lines": {
            "added": [
                "\tstruct sock *sk = asoc->base.sk;",
                "\tstruct net *net = sock_net(sk);",
                "\tbh_lock_sock(sk);",
                "\tif (sock_owned_by_user(sk)) {",
                "\tbh_unlock_sock(sk);"
            ],
            "deleted": [
                "\tstruct net *net = sock_net(asoc->base.sk);",
                "\tbh_lock_sock(asoc->base.sk);",
                "\tif (sock_owned_by_user(asoc->base.sk)) {",
                "\tbh_unlock_sock(asoc->base.sk);"
            ]
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "net/sctp/sm_sideeffect.c in the Linux kernel before 4.3 does not properly manage the relationship between a lock and a socket, which allows local users to cause a denial of service (deadlock) via a crafted sctp_accept call.",
        "id": 841
    },
    {
        "cve_id": "CVE-2015-8767",
        "code_before_change": "void sctp_generate_t3_rtx_event(unsigned long peer)\n{\n\tint error;\n\tstruct sctp_transport *transport = (struct sctp_transport *) peer;\n\tstruct sctp_association *asoc = transport->asoc;\n\tstruct net *net = sock_net(asoc->base.sk);\n\n\t/* Check whether a task is in the sock.  */\n\n\tbh_lock_sock(asoc->base.sk);\n\tif (sock_owned_by_user(asoc->base.sk)) {\n\t\tpr_debug(\"%s: sock is busy\\n\", __func__);\n\n\t\t/* Try again later.  */\n\t\tif (!mod_timer(&transport->T3_rtx_timer, jiffies + (HZ/20)))\n\t\t\tsctp_transport_hold(transport);\n\t\tgoto out_unlock;\n\t}\n\n\t/* Is this transport really dead and just waiting around for\n\t * the timer to let go of the reference?\n\t */\n\tif (transport->dead)\n\t\tgoto out_unlock;\n\n\t/* Run through the state machine.  */\n\terror = sctp_do_sm(net, SCTP_EVENT_T_TIMEOUT,\n\t\t\t   SCTP_ST_TIMEOUT(SCTP_EVENT_TIMEOUT_T3_RTX),\n\t\t\t   asoc->state,\n\t\t\t   asoc->ep, asoc,\n\t\t\t   transport, GFP_ATOMIC);\n\n\tif (error)\n\t\tasoc->base.sk->sk_err = -error;\n\nout_unlock:\n\tbh_unlock_sock(asoc->base.sk);\n\tsctp_transport_put(transport);\n}",
        "code_after_change": "void sctp_generate_t3_rtx_event(unsigned long peer)\n{\n\tint error;\n\tstruct sctp_transport *transport = (struct sctp_transport *) peer;\n\tstruct sctp_association *asoc = transport->asoc;\n\tstruct sock *sk = asoc->base.sk;\n\tstruct net *net = sock_net(sk);\n\n\t/* Check whether a task is in the sock.  */\n\n\tbh_lock_sock(sk);\n\tif (sock_owned_by_user(sk)) {\n\t\tpr_debug(\"%s: sock is busy\\n\", __func__);\n\n\t\t/* Try again later.  */\n\t\tif (!mod_timer(&transport->T3_rtx_timer, jiffies + (HZ/20)))\n\t\t\tsctp_transport_hold(transport);\n\t\tgoto out_unlock;\n\t}\n\n\t/* Is this transport really dead and just waiting around for\n\t * the timer to let go of the reference?\n\t */\n\tif (transport->dead)\n\t\tgoto out_unlock;\n\n\t/* Run through the state machine.  */\n\terror = sctp_do_sm(net, SCTP_EVENT_T_TIMEOUT,\n\t\t\t   SCTP_ST_TIMEOUT(SCTP_EVENT_TIMEOUT_T3_RTX),\n\t\t\t   asoc->state,\n\t\t\t   asoc->ep, asoc,\n\t\t\t   transport, GFP_ATOMIC);\n\n\tif (error)\n\t\tsk->sk_err = -error;\n\nout_unlock:\n\tbh_unlock_sock(sk);\n\tsctp_transport_put(transport);\n}",
        "patch": "--- code before\n+++ code after\n@@ -3,12 +3,13 @@\n \tint error;\n \tstruct sctp_transport *transport = (struct sctp_transport *) peer;\n \tstruct sctp_association *asoc = transport->asoc;\n-\tstruct net *net = sock_net(asoc->base.sk);\n+\tstruct sock *sk = asoc->base.sk;\n+\tstruct net *net = sock_net(sk);\n \n \t/* Check whether a task is in the sock.  */\n \n-\tbh_lock_sock(asoc->base.sk);\n-\tif (sock_owned_by_user(asoc->base.sk)) {\n+\tbh_lock_sock(sk);\n+\tif (sock_owned_by_user(sk)) {\n \t\tpr_debug(\"%s: sock is busy\\n\", __func__);\n \n \t\t/* Try again later.  */\n@@ -31,9 +32,9 @@\n \t\t\t   transport, GFP_ATOMIC);\n \n \tif (error)\n-\t\tasoc->base.sk->sk_err = -error;\n+\t\tsk->sk_err = -error;\n \n out_unlock:\n-\tbh_unlock_sock(asoc->base.sk);\n+\tbh_unlock_sock(sk);\n \tsctp_transport_put(transport);\n }",
        "function_modified_lines": {
            "added": [
                "\tstruct sock *sk = asoc->base.sk;",
                "\tstruct net *net = sock_net(sk);",
                "\tbh_lock_sock(sk);",
                "\tif (sock_owned_by_user(sk)) {",
                "\t\tsk->sk_err = -error;",
                "\tbh_unlock_sock(sk);"
            ],
            "deleted": [
                "\tstruct net *net = sock_net(asoc->base.sk);",
                "\tbh_lock_sock(asoc->base.sk);",
                "\tif (sock_owned_by_user(asoc->base.sk)) {",
                "\t\tasoc->base.sk->sk_err = -error;",
                "\tbh_unlock_sock(asoc->base.sk);"
            ]
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "net/sctp/sm_sideeffect.c in the Linux kernel before 4.3 does not properly manage the relationship between a lock and a socket, which allows local users to cause a denial of service (deadlock) via a crafted sctp_accept call.",
        "id": 840
    },
    {
        "cve_id": "CVE-2020-12652",
        "code_before_change": "static int\ncompat_mptfwxfer_ioctl(struct file *filp, unsigned int cmd,\n\t\t\tunsigned long arg)\n{\n\tstruct mpt_fw_xfer32 kfw32;\n\tstruct mpt_fw_xfer kfw;\n\tMPT_ADAPTER *iocp = NULL;\n\tint iocnum, iocnumX;\n\tint nonblock = (filp->f_flags & O_NONBLOCK);\n\tint ret;\n\n\n\tif (copy_from_user(&kfw32, (char __user *)arg, sizeof(kfw32)))\n\t\treturn -EFAULT;\n\n\t/* Verify intended MPT adapter */\n\tiocnumX = kfw32.iocnum & 0xFF;\n\tif (((iocnum = mpt_verify_adapter(iocnumX, &iocp)) < 0) ||\n\t    (iocp == NULL)) {\n\t\tprintk(KERN_DEBUG MYNAM \"::compat_mptfwxfer_ioctl @%d - ioc%d not found!\\n\",\n\t\t\t__LINE__, iocnumX);\n\t\treturn -ENODEV;\n\t}\n\n\tif ((ret = mptctl_syscall_down(iocp, nonblock)) != 0)\n\t\treturn ret;\n\n\tdctlprintk(iocp, printk(MYIOC_s_DEBUG_FMT \"compat_mptfwxfer_ioctl() called\\n\",\n\t    iocp->name));\n\tkfw.iocnum = iocnum;\n\tkfw.fwlen = kfw32.fwlen;\n\tkfw.bufp = compat_ptr(kfw32.bufp);\n\n\tret = mptctl_do_fw_download(kfw.iocnum, kfw.bufp, kfw.fwlen);\n\n\tmutex_unlock(&iocp->ioctl_cmds.mutex);\n\n\treturn ret;\n}",
        "code_after_change": "static int\ncompat_mptfwxfer_ioctl(struct file *filp, unsigned int cmd,\n\t\t\tunsigned long arg)\n{\n\tstruct mpt_fw_xfer32 kfw32;\n\tstruct mpt_fw_xfer kfw;\n\tMPT_ADAPTER *iocp = NULL;\n\tint iocnum, iocnumX;\n\tint nonblock = (filp->f_flags & O_NONBLOCK);\n\tint ret;\n\n\n\tif (copy_from_user(&kfw32, (char __user *)arg, sizeof(kfw32)))\n\t\treturn -EFAULT;\n\n\t/* Verify intended MPT adapter */\n\tiocnumX = kfw32.iocnum & 0xFF;\n\tif (((iocnum = mpt_verify_adapter(iocnumX, &iocp)) < 0) ||\n\t    (iocp == NULL)) {\n\t\tprintk(KERN_DEBUG MYNAM \"::compat_mptfwxfer_ioctl @%d - ioc%d not found!\\n\",\n\t\t\t__LINE__, iocnumX);\n\t\treturn -ENODEV;\n\t}\n\n\tif ((ret = mptctl_syscall_down(iocp, nonblock)) != 0)\n\t\treturn ret;\n\n\tdctlprintk(iocp, printk(MYIOC_s_DEBUG_FMT \"compat_mptfwxfer_ioctl() called\\n\",\n\t    iocp->name));\n\tkfw.iocnum = iocnum;\n\tkfw.fwlen = kfw32.fwlen;\n\tkfw.bufp = compat_ptr(kfw32.bufp);\n\n\tret = mptctl_do_fw_download(iocp, kfw.bufp, kfw.fwlen);\n\n\tmutex_unlock(&iocp->ioctl_cmds.mutex);\n\n\treturn ret;\n}",
        "patch": "--- code before\n+++ code after\n@@ -31,7 +31,7 @@\n \tkfw.fwlen = kfw32.fwlen;\n \tkfw.bufp = compat_ptr(kfw32.bufp);\n \n-\tret = mptctl_do_fw_download(kfw.iocnum, kfw.bufp, kfw.fwlen);\n+\tret = mptctl_do_fw_download(iocp, kfw.bufp, kfw.fwlen);\n \n \tmutex_unlock(&iocp->ioctl_cmds.mutex);\n ",
        "function_modified_lines": {
            "added": [
                "\tret = mptctl_do_fw_download(iocp, kfw.bufp, kfw.fwlen);"
            ],
            "deleted": [
                "\tret = mptctl_do_fw_download(kfw.iocnum, kfw.bufp, kfw.fwlen);"
            ]
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "The __mptctl_ioctl function in drivers/message/fusion/mptctl.c in the Linux kernel before 5.4.14 allows local users to hold an incorrect lock during the ioctl operation and trigger a race condition, i.e., a \"double fetch\" vulnerability, aka CID-28d76df18f0a. NOTE: the vendor states \"The security impact of this bug is not as bad as it could have been because these operations are all privileged and root already has enormous destructive power.\"",
        "id": 2474
    },
    {
        "cve_id": "CVE-2020-36557",
        "code_before_change": "static int vt_disallocate(unsigned int vc_num)\n{\n\tstruct vc_data *vc = NULL;\n\tint ret = 0;\n\n\tconsole_lock();\n\tif (vt_busy(vc_num))\n\t\tret = -EBUSY;\n\telse if (vc_num)\n\t\tvc = vc_deallocate(vc_num);\n\tconsole_unlock();\n\n\tif (vc && vc_num >= MIN_NR_CONSOLES) {\n\t\ttty_port_destroy(&vc->port);\n\t\tkfree(vc);\n\t}\n\n\treturn ret;\n}",
        "code_after_change": "static int vt_disallocate(unsigned int vc_num)\n{\n\tstruct vc_data *vc = NULL;\n\tint ret = 0;\n\n\tconsole_lock();\n\tif (vt_busy(vc_num))\n\t\tret = -EBUSY;\n\telse if (vc_num)\n\t\tvc = vc_deallocate(vc_num);\n\tconsole_unlock();\n\n\tif (vc && vc_num >= MIN_NR_CONSOLES)\n\t\ttty_port_put(&vc->port);\n\n\treturn ret;\n}",
        "patch": "--- code before\n+++ code after\n@@ -10,10 +10,8 @@\n \t\tvc = vc_deallocate(vc_num);\n \tconsole_unlock();\n \n-\tif (vc && vc_num >= MIN_NR_CONSOLES) {\n-\t\ttty_port_destroy(&vc->port);\n-\t\tkfree(vc);\n-\t}\n+\tif (vc && vc_num >= MIN_NR_CONSOLES)\n+\t\ttty_port_put(&vc->port);\n \n \treturn ret;\n }",
        "function_modified_lines": {
            "added": [
                "\tif (vc && vc_num >= MIN_NR_CONSOLES)",
                "\t\ttty_port_put(&vc->port);"
            ],
            "deleted": [
                "\tif (vc && vc_num >= MIN_NR_CONSOLES) {",
                "\t\ttty_port_destroy(&vc->port);",
                "\t\tkfree(vc);",
                "\t}"
            ]
        },
        "cwe": [
            "CWE-362",
            "CWE-416"
        ],
        "cve_description": "A race condition in the Linux kernel before 5.6.2 between the VT_DISALLOCATE ioctl and closing/opening of ttys could lead to a use-after-free.",
        "id": 2765
    },
    {
        "cve_id": "CVE-2022-1048",
        "code_before_change": "static int snd_pcm_hw_free(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime;\n\tint result;\n\n\tif (PCM_RUNTIME_CHECK(substream))\n\t\treturn -ENXIO;\n\truntime = substream->runtime;\n\tsnd_pcm_stream_lock_irq(substream);\n\tswitch (runtime->status->state) {\n\tcase SNDRV_PCM_STATE_SETUP:\n\tcase SNDRV_PCM_STATE_PREPARED:\n\t\tbreak;\n\tdefault:\n\t\tsnd_pcm_stream_unlock_irq(substream);\n\t\treturn -EBADFD;\n\t}\n\tsnd_pcm_stream_unlock_irq(substream);\n\tif (atomic_read(&substream->mmap_count))\n\t\treturn -EBADFD;\n\tresult = do_hw_free(substream);\n\tsnd_pcm_set_state(substream, SNDRV_PCM_STATE_OPEN);\n\tcpu_latency_qos_remove_request(&substream->latency_pm_qos_req);\n\treturn result;\n}",
        "code_after_change": "static int snd_pcm_hw_free(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime;\n\tint result = 0;\n\n\tif (PCM_RUNTIME_CHECK(substream))\n\t\treturn -ENXIO;\n\truntime = substream->runtime;\n\tmutex_lock(&runtime->buffer_mutex);\n\tsnd_pcm_stream_lock_irq(substream);\n\tswitch (runtime->status->state) {\n\tcase SNDRV_PCM_STATE_SETUP:\n\tcase SNDRV_PCM_STATE_PREPARED:\n\t\tif (atomic_read(&substream->mmap_count))\n\t\t\tresult = -EBADFD;\n\t\tbreak;\n\tdefault:\n\t\tresult = -EBADFD;\n\t\tbreak;\n\t}\n\tsnd_pcm_stream_unlock_irq(substream);\n\tif (result)\n\t\tgoto unlock;\n\tresult = do_hw_free(substream);\n\tsnd_pcm_set_state(substream, SNDRV_PCM_STATE_OPEN);\n\tcpu_latency_qos_remove_request(&substream->latency_pm_qos_req);\n unlock:\n\tmutex_unlock(&runtime->buffer_mutex);\n\treturn result;\n}",
        "patch": "--- code before\n+++ code after\n@@ -1,25 +1,30 @@\n static int snd_pcm_hw_free(struct snd_pcm_substream *substream)\n {\n \tstruct snd_pcm_runtime *runtime;\n-\tint result;\n+\tint result = 0;\n \n \tif (PCM_RUNTIME_CHECK(substream))\n \t\treturn -ENXIO;\n \truntime = substream->runtime;\n+\tmutex_lock(&runtime->buffer_mutex);\n \tsnd_pcm_stream_lock_irq(substream);\n \tswitch (runtime->status->state) {\n \tcase SNDRV_PCM_STATE_SETUP:\n \tcase SNDRV_PCM_STATE_PREPARED:\n+\t\tif (atomic_read(&substream->mmap_count))\n+\t\t\tresult = -EBADFD;\n \t\tbreak;\n \tdefault:\n-\t\tsnd_pcm_stream_unlock_irq(substream);\n-\t\treturn -EBADFD;\n+\t\tresult = -EBADFD;\n+\t\tbreak;\n \t}\n \tsnd_pcm_stream_unlock_irq(substream);\n-\tif (atomic_read(&substream->mmap_count))\n-\t\treturn -EBADFD;\n+\tif (result)\n+\t\tgoto unlock;\n \tresult = do_hw_free(substream);\n \tsnd_pcm_set_state(substream, SNDRV_PCM_STATE_OPEN);\n \tcpu_latency_qos_remove_request(&substream->latency_pm_qos_req);\n+ unlock:\n+\tmutex_unlock(&runtime->buffer_mutex);\n \treturn result;\n }",
        "function_modified_lines": {
            "added": [
                "\tint result = 0;",
                "\tmutex_lock(&runtime->buffer_mutex);",
                "\t\tif (atomic_read(&substream->mmap_count))",
                "\t\t\tresult = -EBADFD;",
                "\t\tresult = -EBADFD;",
                "\t\tbreak;",
                "\tif (result)",
                "\t\tgoto unlock;",
                " unlock:",
                "\tmutex_unlock(&runtime->buffer_mutex);"
            ],
            "deleted": [
                "\tint result;",
                "\t\tsnd_pcm_stream_unlock_irq(substream);",
                "\t\treturn -EBADFD;",
                "\tif (atomic_read(&substream->mmap_count))",
                "\t\treturn -EBADFD;"
            ]
        },
        "cwe": [
            "CWE-362",
            "CWE-416"
        ],
        "cve_description": "A use-after-free flaw was found in the Linux kernel\u2019s sound subsystem in the way a user triggers concurrent calls of PCM hw_params. The hw_free ioctls or similar race condition happens inside ALSA PCM for other ioctls. This flaw allows a local user to crash or potentially escalate their privileges on the system.",
        "id": 3244
    },
    {
        "cve_id": "CVE-2018-7995",
        "code_before_change": "static ssize_t set_cmci_disabled(struct device *s,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t const char *buf, size_t size)\n{\n\tu64 new;\n\n\tif (kstrtou64(buf, 0, &new) < 0)\n\t\treturn -EINVAL;\n\n\tif (mca_cfg.cmci_disabled ^ !!new) {\n\t\tif (new) {\n\t\t\t/* disable cmci */\n\t\t\ton_each_cpu(mce_disable_cmci, NULL, 1);\n\t\t\tmca_cfg.cmci_disabled = true;\n\t\t} else {\n\t\t\t/* enable cmci */\n\t\t\tmca_cfg.cmci_disabled = false;\n\t\t\ton_each_cpu(mce_enable_ce, NULL, 1);\n\t\t}\n\t}\n\treturn size;\n}",
        "code_after_change": "static ssize_t set_cmci_disabled(struct device *s,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t const char *buf, size_t size)\n{\n\tu64 new;\n\n\tif (kstrtou64(buf, 0, &new) < 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&mce_sysfs_mutex);\n\tif (mca_cfg.cmci_disabled ^ !!new) {\n\t\tif (new) {\n\t\t\t/* disable cmci */\n\t\t\ton_each_cpu(mce_disable_cmci, NULL, 1);\n\t\t\tmca_cfg.cmci_disabled = true;\n\t\t} else {\n\t\t\t/* enable cmci */\n\t\t\tmca_cfg.cmci_disabled = false;\n\t\t\ton_each_cpu(mce_enable_ce, NULL, 1);\n\t\t}\n\t}\n\tmutex_unlock(&mce_sysfs_mutex);\n\n\treturn size;\n}",
        "patch": "--- code before\n+++ code after\n@@ -7,6 +7,7 @@\n \tif (kstrtou64(buf, 0, &new) < 0)\n \t\treturn -EINVAL;\n \n+\tmutex_lock(&mce_sysfs_mutex);\n \tif (mca_cfg.cmci_disabled ^ !!new) {\n \t\tif (new) {\n \t\t\t/* disable cmci */\n@@ -18,5 +19,7 @@\n \t\t\ton_each_cpu(mce_enable_ce, NULL, 1);\n \t\t}\n \t}\n+\tmutex_unlock(&mce_sysfs_mutex);\n+\n \treturn size;\n }",
        "function_modified_lines": {
            "added": [
                "\tmutex_lock(&mce_sysfs_mutex);",
                "\tmutex_unlock(&mce_sysfs_mutex);",
                ""
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "Race condition in the store_int_with_restart() function in arch/x86/kernel/cpu/mcheck/mce.c in the Linux kernel through 4.15.7 allows local users to cause a denial of service (panic) by leveraging root access to write to the check_interval file in a /sys/devices/system/machinecheck/machinecheck<cpu number> directory. NOTE: a third party has indicated that this report is not security relevant",
        "id": 1856
    },
    {
        "cve_id": "CVE-2022-23042",
        "code_before_change": "static int setup_netfront(struct xenbus_device *dev,\n\t\t\tstruct netfront_queue *queue, unsigned int feature_split_evtchn)\n{\n\tstruct xen_netif_tx_sring *txs;\n\tstruct xen_netif_rx_sring *rxs;\n\tgrant_ref_t gref;\n\tint err;\n\n\tqueue->tx_ring_ref = GRANT_INVALID_REF;\n\tqueue->rx_ring_ref = GRANT_INVALID_REF;\n\tqueue->rx.sring = NULL;\n\tqueue->tx.sring = NULL;\n\n\ttxs = (struct xen_netif_tx_sring *)get_zeroed_page(GFP_NOIO | __GFP_HIGH);\n\tif (!txs) {\n\t\terr = -ENOMEM;\n\t\txenbus_dev_fatal(dev, err, \"allocating tx ring page\");\n\t\tgoto fail;\n\t}\n\tSHARED_RING_INIT(txs);\n\tFRONT_RING_INIT(&queue->tx, txs, XEN_PAGE_SIZE);\n\n\terr = xenbus_grant_ring(dev, txs, 1, &gref);\n\tif (err < 0)\n\t\tgoto grant_tx_ring_fail;\n\tqueue->tx_ring_ref = gref;\n\n\trxs = (struct xen_netif_rx_sring *)get_zeroed_page(GFP_NOIO | __GFP_HIGH);\n\tif (!rxs) {\n\t\terr = -ENOMEM;\n\t\txenbus_dev_fatal(dev, err, \"allocating rx ring page\");\n\t\tgoto alloc_rx_ring_fail;\n\t}\n\tSHARED_RING_INIT(rxs);\n\tFRONT_RING_INIT(&queue->rx, rxs, XEN_PAGE_SIZE);\n\n\terr = xenbus_grant_ring(dev, rxs, 1, &gref);\n\tif (err < 0)\n\t\tgoto grant_rx_ring_fail;\n\tqueue->rx_ring_ref = gref;\n\n\tif (feature_split_evtchn)\n\t\terr = setup_netfront_split(queue);\n\t/* setup single event channel if\n\t *  a) feature-split-event-channels == 0\n\t *  b) feature-split-event-channels == 1 but failed to setup\n\t */\n\tif (!feature_split_evtchn || err)\n\t\terr = setup_netfront_single(queue);\n\n\tif (err)\n\t\tgoto alloc_evtchn_fail;\n\n\treturn 0;\n\n\t/* If we fail to setup netfront, it is safe to just revoke access to\n\t * granted pages because backend is not accessing it at this point.\n\t */\nalloc_evtchn_fail:\n\tgnttab_end_foreign_access_ref(queue->rx_ring_ref, 0);\ngrant_rx_ring_fail:\n\tfree_page((unsigned long)rxs);\nalloc_rx_ring_fail:\n\tgnttab_end_foreign_access_ref(queue->tx_ring_ref, 0);\ngrant_tx_ring_fail:\n\tfree_page((unsigned long)txs);\nfail:\n\treturn err;\n}",
        "code_after_change": "static int setup_netfront(struct xenbus_device *dev,\n\t\t\tstruct netfront_queue *queue, unsigned int feature_split_evtchn)\n{\n\tstruct xen_netif_tx_sring *txs;\n\tstruct xen_netif_rx_sring *rxs = NULL;\n\tgrant_ref_t gref;\n\tint err;\n\n\tqueue->tx_ring_ref = GRANT_INVALID_REF;\n\tqueue->rx_ring_ref = GRANT_INVALID_REF;\n\tqueue->rx.sring = NULL;\n\tqueue->tx.sring = NULL;\n\n\ttxs = (struct xen_netif_tx_sring *)get_zeroed_page(GFP_NOIO | __GFP_HIGH);\n\tif (!txs) {\n\t\terr = -ENOMEM;\n\t\txenbus_dev_fatal(dev, err, \"allocating tx ring page\");\n\t\tgoto fail;\n\t}\n\tSHARED_RING_INIT(txs);\n\tFRONT_RING_INIT(&queue->tx, txs, XEN_PAGE_SIZE);\n\n\terr = xenbus_grant_ring(dev, txs, 1, &gref);\n\tif (err < 0)\n\t\tgoto fail;\n\tqueue->tx_ring_ref = gref;\n\n\trxs = (struct xen_netif_rx_sring *)get_zeroed_page(GFP_NOIO | __GFP_HIGH);\n\tif (!rxs) {\n\t\terr = -ENOMEM;\n\t\txenbus_dev_fatal(dev, err, \"allocating rx ring page\");\n\t\tgoto fail;\n\t}\n\tSHARED_RING_INIT(rxs);\n\tFRONT_RING_INIT(&queue->rx, rxs, XEN_PAGE_SIZE);\n\n\terr = xenbus_grant_ring(dev, rxs, 1, &gref);\n\tif (err < 0)\n\t\tgoto fail;\n\tqueue->rx_ring_ref = gref;\n\n\tif (feature_split_evtchn)\n\t\terr = setup_netfront_split(queue);\n\t/* setup single event channel if\n\t *  a) feature-split-event-channels == 0\n\t *  b) feature-split-event-channels == 1 but failed to setup\n\t */\n\tif (!feature_split_evtchn || err)\n\t\terr = setup_netfront_single(queue);\n\n\tif (err)\n\t\tgoto fail;\n\n\treturn 0;\n\n\t/* If we fail to setup netfront, it is safe to just revoke access to\n\t * granted pages because backend is not accessing it at this point.\n\t */\n fail:\n\tif (queue->rx_ring_ref != GRANT_INVALID_REF) {\n\t\tgnttab_end_foreign_access(queue->rx_ring_ref, 0,\n\t\t\t\t\t  (unsigned long)rxs);\n\t\tqueue->rx_ring_ref = GRANT_INVALID_REF;\n\t} else {\n\t\tfree_page((unsigned long)rxs);\n\t}\n\tif (queue->tx_ring_ref != GRANT_INVALID_REF) {\n\t\tgnttab_end_foreign_access(queue->tx_ring_ref, 0,\n\t\t\t\t\t  (unsigned long)txs);\n\t\tqueue->tx_ring_ref = GRANT_INVALID_REF;\n\t} else {\n\t\tfree_page((unsigned long)txs);\n\t}\n\treturn err;\n}",
        "patch": "--- code before\n+++ code after\n@@ -2,7 +2,7 @@\n \t\t\tstruct netfront_queue *queue, unsigned int feature_split_evtchn)\n {\n \tstruct xen_netif_tx_sring *txs;\n-\tstruct xen_netif_rx_sring *rxs;\n+\tstruct xen_netif_rx_sring *rxs = NULL;\n \tgrant_ref_t gref;\n \tint err;\n \n@@ -22,21 +22,21 @@\n \n \terr = xenbus_grant_ring(dev, txs, 1, &gref);\n \tif (err < 0)\n-\t\tgoto grant_tx_ring_fail;\n+\t\tgoto fail;\n \tqueue->tx_ring_ref = gref;\n \n \trxs = (struct xen_netif_rx_sring *)get_zeroed_page(GFP_NOIO | __GFP_HIGH);\n \tif (!rxs) {\n \t\terr = -ENOMEM;\n \t\txenbus_dev_fatal(dev, err, \"allocating rx ring page\");\n-\t\tgoto alloc_rx_ring_fail;\n+\t\tgoto fail;\n \t}\n \tSHARED_RING_INIT(rxs);\n \tFRONT_RING_INIT(&queue->rx, rxs, XEN_PAGE_SIZE);\n \n \terr = xenbus_grant_ring(dev, rxs, 1, &gref);\n \tif (err < 0)\n-\t\tgoto grant_rx_ring_fail;\n+\t\tgoto fail;\n \tqueue->rx_ring_ref = gref;\n \n \tif (feature_split_evtchn)\n@@ -49,21 +49,27 @@\n \t\terr = setup_netfront_single(queue);\n \n \tif (err)\n-\t\tgoto alloc_evtchn_fail;\n+\t\tgoto fail;\n \n \treturn 0;\n \n \t/* If we fail to setup netfront, it is safe to just revoke access to\n \t * granted pages because backend is not accessing it at this point.\n \t */\n-alloc_evtchn_fail:\n-\tgnttab_end_foreign_access_ref(queue->rx_ring_ref, 0);\n-grant_rx_ring_fail:\n-\tfree_page((unsigned long)rxs);\n-alloc_rx_ring_fail:\n-\tgnttab_end_foreign_access_ref(queue->tx_ring_ref, 0);\n-grant_tx_ring_fail:\n-\tfree_page((unsigned long)txs);\n-fail:\n+ fail:\n+\tif (queue->rx_ring_ref != GRANT_INVALID_REF) {\n+\t\tgnttab_end_foreign_access(queue->rx_ring_ref, 0,\n+\t\t\t\t\t  (unsigned long)rxs);\n+\t\tqueue->rx_ring_ref = GRANT_INVALID_REF;\n+\t} else {\n+\t\tfree_page((unsigned long)rxs);\n+\t}\n+\tif (queue->tx_ring_ref != GRANT_INVALID_REF) {\n+\t\tgnttab_end_foreign_access(queue->tx_ring_ref, 0,\n+\t\t\t\t\t  (unsigned long)txs);\n+\t\tqueue->tx_ring_ref = GRANT_INVALID_REF;\n+\t} else {\n+\t\tfree_page((unsigned long)txs);\n+\t}\n \treturn err;\n }",
        "function_modified_lines": {
            "added": [
                "\tstruct xen_netif_rx_sring *rxs = NULL;",
                "\t\tgoto fail;",
                "\t\tgoto fail;",
                "\t\tgoto fail;",
                "\t\tgoto fail;",
                " fail:",
                "\tif (queue->rx_ring_ref != GRANT_INVALID_REF) {",
                "\t\tgnttab_end_foreign_access(queue->rx_ring_ref, 0,",
                "\t\t\t\t\t  (unsigned long)rxs);",
                "\t\tqueue->rx_ring_ref = GRANT_INVALID_REF;",
                "\t} else {",
                "\t\tfree_page((unsigned long)rxs);",
                "\t}",
                "\tif (queue->tx_ring_ref != GRANT_INVALID_REF) {",
                "\t\tgnttab_end_foreign_access(queue->tx_ring_ref, 0,",
                "\t\t\t\t\t  (unsigned long)txs);",
                "\t\tqueue->tx_ring_ref = GRANT_INVALID_REF;",
                "\t} else {",
                "\t\tfree_page((unsigned long)txs);",
                "\t}"
            ],
            "deleted": [
                "\tstruct xen_netif_rx_sring *rxs;",
                "\t\tgoto grant_tx_ring_fail;",
                "\t\tgoto alloc_rx_ring_fail;",
                "\t\tgoto grant_rx_ring_fail;",
                "\t\tgoto alloc_evtchn_fail;",
                "alloc_evtchn_fail:",
                "\tgnttab_end_foreign_access_ref(queue->rx_ring_ref, 0);",
                "grant_rx_ring_fail:",
                "\tfree_page((unsigned long)rxs);",
                "alloc_rx_ring_fail:",
                "\tgnttab_end_foreign_access_ref(queue->tx_ring_ref, 0);",
                "grant_tx_ring_fail:",
                "\tfree_page((unsigned long)txs);",
                "fail:"
            ]
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "Linux PV device frontends vulnerable to attacks by backends T[his CNA information record relates to multiple CVEs; the text explains which aspects/vulnerabilities correspond to which CVE.] Several Linux PV device frontends are using the grant table interfaces for removing access rights of the backends in ways being subject to race conditions, resulting in potential data leaks, data corruption by malicious backends, and denial of service triggered by malicious backends: blkfront, netfront, scsifront and the gntalloc driver are testing whether a grant reference is still in use. If this is not the case, they assume that a following removal of the granted access will always succeed, which is not true in case the backend has mapped the granted page between those two operations. As a result the backend can keep access to the memory page of the guest no matter how the page will be used after the frontend I/O has finished. The xenbus driver has a similar problem, as it doesn't check the success of removing the granted access of a shared ring buffer. blkfront: CVE-2022-23036 netfront: CVE-2022-23037 scsifront: CVE-2022-23038 gntalloc: CVE-2022-23039 xenbus: CVE-2022-23040 blkfront, netfront, scsifront, usbfront, dmabuf, xenbus, 9p, kbdfront, and pvcalls are using a functionality to delay freeing a grant reference until it is no longer in use, but the freeing of the related data page is not synchronized with dropping the granted access. As a result the backend can keep access to the memory page even after it has been freed and then re-used for a different purpose. CVE-2022-23041 netfront will fail a BUG_ON() assertion if it fails to revoke access in the rx path. This will result in a Denial of Service (DoS) situation of the guest which can be triggered by the backend. CVE-2022-23042",
        "id": 3426
    },
    {
        "cve_id": "CVE-2022-23042",
        "code_before_change": "static int xennet_get_responses(struct netfront_queue *queue,\n\t\t\t\tstruct netfront_rx_info *rinfo, RING_IDX rp,\n\t\t\t\tstruct sk_buff_head *list,\n\t\t\t\tbool *need_xdp_flush)\n{\n\tstruct xen_netif_rx_response *rx = &rinfo->rx, rx_local;\n\tint max = XEN_NETIF_NR_SLOTS_MIN + (rx->status <= RX_COPY_THRESHOLD);\n\tRING_IDX cons = queue->rx.rsp_cons;\n\tstruct sk_buff *skb = xennet_get_rx_skb(queue, cons);\n\tstruct xen_netif_extra_info *extras = rinfo->extras;\n\tgrant_ref_t ref = xennet_get_rx_ref(queue, cons);\n\tstruct device *dev = &queue->info->netdev->dev;\n\tstruct bpf_prog *xdp_prog;\n\tstruct xdp_buff xdp;\n\tunsigned long ret;\n\tint slots = 1;\n\tint err = 0;\n\tu32 verdict;\n\n\tif (rx->flags & XEN_NETRXF_extra_info) {\n\t\terr = xennet_get_extras(queue, extras, rp);\n\t\tif (!err) {\n\t\t\tif (extras[XEN_NETIF_EXTRA_TYPE_XDP - 1].type) {\n\t\t\t\tstruct xen_netif_extra_info *xdp;\n\n\t\t\t\txdp = &extras[XEN_NETIF_EXTRA_TYPE_XDP - 1];\n\t\t\t\trx->offset = xdp->u.xdp.headroom;\n\t\t\t}\n\t\t}\n\t\tcons = queue->rx.rsp_cons;\n\t}\n\n\tfor (;;) {\n\t\tif (unlikely(rx->status < 0 ||\n\t\t\t     rx->offset + rx->status > XEN_PAGE_SIZE)) {\n\t\t\tif (net_ratelimit())\n\t\t\t\tdev_warn(dev, \"rx->offset: %u, size: %d\\n\",\n\t\t\t\t\t rx->offset, rx->status);\n\t\t\txennet_move_rx_slot(queue, skb, ref);\n\t\t\terr = -EINVAL;\n\t\t\tgoto next;\n\t\t}\n\n\t\t/*\n\t\t * This definitely indicates a bug, either in this driver or in\n\t\t * the backend driver. In future this should flag the bad\n\t\t * situation to the system controller to reboot the backend.\n\t\t */\n\t\tif (ref == GRANT_INVALID_REF) {\n\t\t\tif (net_ratelimit())\n\t\t\t\tdev_warn(dev, \"Bad rx response id %d.\\n\",\n\t\t\t\t\t rx->id);\n\t\t\terr = -EINVAL;\n\t\t\tgoto next;\n\t\t}\n\n\t\tret = gnttab_end_foreign_access_ref(ref, 0);\n\t\tBUG_ON(!ret);\n\n\t\tgnttab_release_grant_reference(&queue->gref_rx_head, ref);\n\n\t\trcu_read_lock();\n\t\txdp_prog = rcu_dereference(queue->xdp_prog);\n\t\tif (xdp_prog) {\n\t\t\tif (!(rx->flags & XEN_NETRXF_more_data)) {\n\t\t\t\t/* currently only a single page contains data */\n\t\t\t\tverdict = xennet_run_xdp(queue,\n\t\t\t\t\t\t\t skb_frag_page(&skb_shinfo(skb)->frags[0]),\n\t\t\t\t\t\t\t rx, xdp_prog, &xdp, need_xdp_flush);\n\t\t\t\tif (verdict != XDP_PASS)\n\t\t\t\t\terr = -EINVAL;\n\t\t\t} else {\n\t\t\t\t/* drop the frame */\n\t\t\t\terr = -EINVAL;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\nnext:\n\t\t__skb_queue_tail(list, skb);\n\t\tif (!(rx->flags & XEN_NETRXF_more_data))\n\t\t\tbreak;\n\n\t\tif (cons + slots == rp) {\n\t\t\tif (net_ratelimit())\n\t\t\t\tdev_warn(dev, \"Need more slots\\n\");\n\t\t\terr = -ENOENT;\n\t\t\tbreak;\n\t\t}\n\n\t\tRING_COPY_RESPONSE(&queue->rx, cons + slots, &rx_local);\n\t\trx = &rx_local;\n\t\tskb = xennet_get_rx_skb(queue, cons + slots);\n\t\tref = xennet_get_rx_ref(queue, cons + slots);\n\t\tslots++;\n\t}\n\n\tif (unlikely(slots > max)) {\n\t\tif (net_ratelimit())\n\t\t\tdev_warn(dev, \"Too many slots\\n\");\n\t\terr = -E2BIG;\n\t}\n\n\tif (unlikely(err))\n\t\txennet_set_rx_rsp_cons(queue, cons + slots);\n\n\treturn err;\n}",
        "code_after_change": "static int xennet_get_responses(struct netfront_queue *queue,\n\t\t\t\tstruct netfront_rx_info *rinfo, RING_IDX rp,\n\t\t\t\tstruct sk_buff_head *list,\n\t\t\t\tbool *need_xdp_flush)\n{\n\tstruct xen_netif_rx_response *rx = &rinfo->rx, rx_local;\n\tint max = XEN_NETIF_NR_SLOTS_MIN + (rx->status <= RX_COPY_THRESHOLD);\n\tRING_IDX cons = queue->rx.rsp_cons;\n\tstruct sk_buff *skb = xennet_get_rx_skb(queue, cons);\n\tstruct xen_netif_extra_info *extras = rinfo->extras;\n\tgrant_ref_t ref = xennet_get_rx_ref(queue, cons);\n\tstruct device *dev = &queue->info->netdev->dev;\n\tstruct bpf_prog *xdp_prog;\n\tstruct xdp_buff xdp;\n\tint slots = 1;\n\tint err = 0;\n\tu32 verdict;\n\n\tif (rx->flags & XEN_NETRXF_extra_info) {\n\t\terr = xennet_get_extras(queue, extras, rp);\n\t\tif (!err) {\n\t\t\tif (extras[XEN_NETIF_EXTRA_TYPE_XDP - 1].type) {\n\t\t\t\tstruct xen_netif_extra_info *xdp;\n\n\t\t\t\txdp = &extras[XEN_NETIF_EXTRA_TYPE_XDP - 1];\n\t\t\t\trx->offset = xdp->u.xdp.headroom;\n\t\t\t}\n\t\t}\n\t\tcons = queue->rx.rsp_cons;\n\t}\n\n\tfor (;;) {\n\t\tif (unlikely(rx->status < 0 ||\n\t\t\t     rx->offset + rx->status > XEN_PAGE_SIZE)) {\n\t\t\tif (net_ratelimit())\n\t\t\t\tdev_warn(dev, \"rx->offset: %u, size: %d\\n\",\n\t\t\t\t\t rx->offset, rx->status);\n\t\t\txennet_move_rx_slot(queue, skb, ref);\n\t\t\terr = -EINVAL;\n\t\t\tgoto next;\n\t\t}\n\n\t\t/*\n\t\t * This definitely indicates a bug, either in this driver or in\n\t\t * the backend driver. In future this should flag the bad\n\t\t * situation to the system controller to reboot the backend.\n\t\t */\n\t\tif (ref == GRANT_INVALID_REF) {\n\t\t\tif (net_ratelimit())\n\t\t\t\tdev_warn(dev, \"Bad rx response id %d.\\n\",\n\t\t\t\t\t rx->id);\n\t\t\terr = -EINVAL;\n\t\t\tgoto next;\n\t\t}\n\n\t\tif (!gnttab_end_foreign_access_ref(ref, 0)) {\n\t\t\tdev_alert(dev,\n\t\t\t\t  \"Grant still in use by backend domain\\n\");\n\t\t\tqueue->info->broken = true;\n\t\t\tdev_alert(dev, \"Disabled for further use\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tgnttab_release_grant_reference(&queue->gref_rx_head, ref);\n\n\t\trcu_read_lock();\n\t\txdp_prog = rcu_dereference(queue->xdp_prog);\n\t\tif (xdp_prog) {\n\t\t\tif (!(rx->flags & XEN_NETRXF_more_data)) {\n\t\t\t\t/* currently only a single page contains data */\n\t\t\t\tverdict = xennet_run_xdp(queue,\n\t\t\t\t\t\t\t skb_frag_page(&skb_shinfo(skb)->frags[0]),\n\t\t\t\t\t\t\t rx, xdp_prog, &xdp, need_xdp_flush);\n\t\t\t\tif (verdict != XDP_PASS)\n\t\t\t\t\terr = -EINVAL;\n\t\t\t} else {\n\t\t\t\t/* drop the frame */\n\t\t\t\terr = -EINVAL;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\nnext:\n\t\t__skb_queue_tail(list, skb);\n\t\tif (!(rx->flags & XEN_NETRXF_more_data))\n\t\t\tbreak;\n\n\t\tif (cons + slots == rp) {\n\t\t\tif (net_ratelimit())\n\t\t\t\tdev_warn(dev, \"Need more slots\\n\");\n\t\t\terr = -ENOENT;\n\t\t\tbreak;\n\t\t}\n\n\t\tRING_COPY_RESPONSE(&queue->rx, cons + slots, &rx_local);\n\t\trx = &rx_local;\n\t\tskb = xennet_get_rx_skb(queue, cons + slots);\n\t\tref = xennet_get_rx_ref(queue, cons + slots);\n\t\tslots++;\n\t}\n\n\tif (unlikely(slots > max)) {\n\t\tif (net_ratelimit())\n\t\t\tdev_warn(dev, \"Too many slots\\n\");\n\t\terr = -E2BIG;\n\t}\n\n\tif (unlikely(err))\n\t\txennet_set_rx_rsp_cons(queue, cons + slots);\n\n\treturn err;\n}",
        "patch": "--- code before\n+++ code after\n@@ -12,7 +12,6 @@\n \tstruct device *dev = &queue->info->netdev->dev;\n \tstruct bpf_prog *xdp_prog;\n \tstruct xdp_buff xdp;\n-\tunsigned long ret;\n \tint slots = 1;\n \tint err = 0;\n \tu32 verdict;\n@@ -54,8 +53,13 @@\n \t\t\tgoto next;\n \t\t}\n \n-\t\tret = gnttab_end_foreign_access_ref(ref, 0);\n-\t\tBUG_ON(!ret);\n+\t\tif (!gnttab_end_foreign_access_ref(ref, 0)) {\n+\t\t\tdev_alert(dev,\n+\t\t\t\t  \"Grant still in use by backend domain\\n\");\n+\t\t\tqueue->info->broken = true;\n+\t\t\tdev_alert(dev, \"Disabled for further use\\n\");\n+\t\t\treturn -EINVAL;\n+\t\t}\n \n \t\tgnttab_release_grant_reference(&queue->gref_rx_head, ref);\n ",
        "function_modified_lines": {
            "added": [
                "\t\tif (!gnttab_end_foreign_access_ref(ref, 0)) {",
                "\t\t\tdev_alert(dev,",
                "\t\t\t\t  \"Grant still in use by backend domain\\n\");",
                "\t\t\tqueue->info->broken = true;",
                "\t\t\tdev_alert(dev, \"Disabled for further use\\n\");",
                "\t\t\treturn -EINVAL;",
                "\t\t}"
            ],
            "deleted": [
                "\tunsigned long ret;",
                "\t\tret = gnttab_end_foreign_access_ref(ref, 0);",
                "\t\tBUG_ON(!ret);"
            ]
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "Linux PV device frontends vulnerable to attacks by backends T[his CNA information record relates to multiple CVEs; the text explains which aspects/vulnerabilities correspond to which CVE.] Several Linux PV device frontends are using the grant table interfaces for removing access rights of the backends in ways being subject to race conditions, resulting in potential data leaks, data corruption by malicious backends, and denial of service triggered by malicious backends: blkfront, netfront, scsifront and the gntalloc driver are testing whether a grant reference is still in use. If this is not the case, they assume that a following removal of the granted access will always succeed, which is not true in case the backend has mapped the granted page between those two operations. As a result the backend can keep access to the memory page of the guest no matter how the page will be used after the frontend I/O has finished. The xenbus driver has a similar problem, as it doesn't check the success of removing the granted access of a shared ring buffer. blkfront: CVE-2022-23036 netfront: CVE-2022-23037 scsifront: CVE-2022-23038 gntalloc: CVE-2022-23039 xenbus: CVE-2022-23040 blkfront, netfront, scsifront, usbfront, dmabuf, xenbus, 9p, kbdfront, and pvcalls are using a functionality to delay freeing a grant reference until it is no longer in use, but the freeing of the related data page is not synchronized with dropping the granted access. As a result the backend can keep access to the memory page even after it has been freed and then re-used for a different purpose. CVE-2022-23041 netfront will fail a BUG_ON() assertion if it fails to revoke access in the rx path. This will result in a Denial of Service (DoS) situation of the guest which can be triggered by the backend. CVE-2022-23042",
        "id": 3425
    },
    {
        "cve_id": "CVE-2015-7990",
        "code_before_change": "int rds_sendmsg(struct socket *sock, struct msghdr *msg, size_t payload_len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rds_sock *rs = rds_sk_to_rs(sk);\n\tDECLARE_SOCKADDR(struct sockaddr_in *, usin, msg->msg_name);\n\t__be32 daddr;\n\t__be16 dport;\n\tstruct rds_message *rm = NULL;\n\tstruct rds_connection *conn;\n\tint ret = 0;\n\tint queued = 0, allocated_mr = 0;\n\tint nonblock = msg->msg_flags & MSG_DONTWAIT;\n\tlong timeo = sock_sndtimeo(sk, nonblock);\n\n\t/* Mirror Linux UDP mirror of BSD error message compatibility */\n\t/* XXX: Perhaps MSG_MORE someday */\n\tif (msg->msg_flags & ~(MSG_DONTWAIT | MSG_CMSG_COMPAT)) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tif (msg->msg_namelen) {\n\t\t/* XXX fail non-unicast destination IPs? */\n\t\tif (msg->msg_namelen < sizeof(*usin) || usin->sin_family != AF_INET) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tdaddr = usin->sin_addr.s_addr;\n\t\tdport = usin->sin_port;\n\t} else {\n\t\t/* We only care about consistency with ->connect() */\n\t\tlock_sock(sk);\n\t\tdaddr = rs->rs_conn_addr;\n\t\tdport = rs->rs_conn_port;\n\t\trelease_sock(sk);\n\t}\n\n\t/* racing with another thread binding seems ok here */\n\tif (daddr == 0 || rs->rs_bound_addr == 0) {\n\t\tret = -ENOTCONN; /* XXX not a great errno */\n\t\tgoto out;\n\t}\n\n\tif (payload_len > rds_sk_sndbuf(rs)) {\n\t\tret = -EMSGSIZE;\n\t\tgoto out;\n\t}\n\n\t/* size of rm including all sgs */\n\tret = rds_rm_size(msg, payload_len);\n\tif (ret < 0)\n\t\tgoto out;\n\n\trm = rds_message_alloc(ret, GFP_KERNEL);\n\tif (!rm) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/* Attach data to the rm */\n\tif (payload_len) {\n\t\trm->data.op_sg = rds_message_alloc_sgs(rm, ceil(payload_len, PAGE_SIZE));\n\t\tif (!rm->data.op_sg) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = rds_message_copy_from_user(rm, &msg->msg_iter);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\trm->data.op_active = 1;\n\n\trm->m_daddr = daddr;\n\n\t/* rds_conn_create has a spinlock that runs with IRQ off.\n\t * Caching the conn in the socket helps a lot. */\n\tif (rs->rs_conn && rs->rs_conn->c_faddr == daddr)\n\t\tconn = rs->rs_conn;\n\telse {\n\t\tconn = rds_conn_create_outgoing(sock_net(sock->sk),\n\t\t\t\t\t\trs->rs_bound_addr, daddr,\n\t\t\t\t\trs->rs_transport,\n\t\t\t\t\tsock->sk->sk_allocation);\n\t\tif (IS_ERR(conn)) {\n\t\t\tret = PTR_ERR(conn);\n\t\t\tgoto out;\n\t\t}\n\t\trs->rs_conn = conn;\n\t}\n\n\t/* Parse any control messages the user may have included. */\n\tret = rds_cmsg_send(rs, rm, msg, &allocated_mr);\n\tif (ret)\n\t\tgoto out;\n\n\tif (rm->rdma.op_active && !conn->c_trans->xmit_rdma) {\n\t\tprintk_ratelimited(KERN_NOTICE \"rdma_op %p conn xmit_rdma %p\\n\",\n\t\t\t       &rm->rdma, conn->c_trans->xmit_rdma);\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tif (rm->atomic.op_active && !conn->c_trans->xmit_atomic) {\n\t\tprintk_ratelimited(KERN_NOTICE \"atomic_op %p conn xmit_atomic %p\\n\",\n\t\t\t       &rm->atomic, conn->c_trans->xmit_atomic);\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\trds_conn_connect_if_down(conn);\n\n\tret = rds_cong_wait(conn->c_fcong, dport, nonblock, rs);\n\tif (ret) {\n\t\trs->rs_seen_congestion = 1;\n\t\tgoto out;\n\t}\n\n\twhile (!rds_send_queue_rm(rs, conn, rm, rs->rs_bound_port,\n\t\t\t\t  dport, &queued)) {\n\t\trds_stats_inc(s_send_queue_full);\n\n\t\tif (nonblock) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\n\t\ttimeo = wait_event_interruptible_timeout(*sk_sleep(sk),\n\t\t\t\t\trds_send_queue_rm(rs, conn, rm,\n\t\t\t\t\t\t\t  rs->rs_bound_port,\n\t\t\t\t\t\t\t  dport,\n\t\t\t\t\t\t\t  &queued),\n\t\t\t\t\ttimeo);\n\t\trdsdebug(\"sendmsg woke queued %d timeo %ld\\n\", queued, timeo);\n\t\tif (timeo > 0 || timeo == MAX_SCHEDULE_TIMEOUT)\n\t\t\tcontinue;\n\n\t\tret = timeo;\n\t\tif (ret == 0)\n\t\t\tret = -ETIMEDOUT;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * By now we've committed to the send.  We reuse rds_send_worker()\n\t * to retry sends in the rds thread if the transport asks us to.\n\t */\n\trds_stats_inc(s_send_queued);\n\n\tret = rds_send_xmit(conn);\n\tif (ret == -ENOMEM || ret == -EAGAIN)\n\t\tqueue_delayed_work(rds_wq, &conn->c_send_w, 1);\n\n\trds_message_put(rm);\n\treturn payload_len;\n\nout:\n\t/* If the user included a RDMA_MAP cmsg, we allocated a MR on the fly.\n\t * If the sendmsg goes through, we keep the MR. If it fails with EAGAIN\n\t * or in any other way, we need to destroy the MR again */\n\tif (allocated_mr)\n\t\trds_rdma_unuse(rs, rds_rdma_cookie_key(rm->m_rdma_cookie), 1);\n\n\tif (rm)\n\t\trds_message_put(rm);\n\treturn ret;\n}",
        "code_after_change": "int rds_sendmsg(struct socket *sock, struct msghdr *msg, size_t payload_len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rds_sock *rs = rds_sk_to_rs(sk);\n\tDECLARE_SOCKADDR(struct sockaddr_in *, usin, msg->msg_name);\n\t__be32 daddr;\n\t__be16 dport;\n\tstruct rds_message *rm = NULL;\n\tstruct rds_connection *conn;\n\tint ret = 0;\n\tint queued = 0, allocated_mr = 0;\n\tint nonblock = msg->msg_flags & MSG_DONTWAIT;\n\tlong timeo = sock_sndtimeo(sk, nonblock);\n\n\t/* Mirror Linux UDP mirror of BSD error message compatibility */\n\t/* XXX: Perhaps MSG_MORE someday */\n\tif (msg->msg_flags & ~(MSG_DONTWAIT | MSG_CMSG_COMPAT)) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tif (msg->msg_namelen) {\n\t\t/* XXX fail non-unicast destination IPs? */\n\t\tif (msg->msg_namelen < sizeof(*usin) || usin->sin_family != AF_INET) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tdaddr = usin->sin_addr.s_addr;\n\t\tdport = usin->sin_port;\n\t} else {\n\t\t/* We only care about consistency with ->connect() */\n\t\tlock_sock(sk);\n\t\tdaddr = rs->rs_conn_addr;\n\t\tdport = rs->rs_conn_port;\n\t\trelease_sock(sk);\n\t}\n\n\tlock_sock(sk);\n\tif (daddr == 0 || rs->rs_bound_addr == 0) {\n\t\trelease_sock(sk);\n\t\tret = -ENOTCONN; /* XXX not a great errno */\n\t\tgoto out;\n\t}\n\trelease_sock(sk);\n\n\tif (payload_len > rds_sk_sndbuf(rs)) {\n\t\tret = -EMSGSIZE;\n\t\tgoto out;\n\t}\n\n\t/* size of rm including all sgs */\n\tret = rds_rm_size(msg, payload_len);\n\tif (ret < 0)\n\t\tgoto out;\n\n\trm = rds_message_alloc(ret, GFP_KERNEL);\n\tif (!rm) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/* Attach data to the rm */\n\tif (payload_len) {\n\t\trm->data.op_sg = rds_message_alloc_sgs(rm, ceil(payload_len, PAGE_SIZE));\n\t\tif (!rm->data.op_sg) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = rds_message_copy_from_user(rm, &msg->msg_iter);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\trm->data.op_active = 1;\n\n\trm->m_daddr = daddr;\n\n\t/* rds_conn_create has a spinlock that runs with IRQ off.\n\t * Caching the conn in the socket helps a lot. */\n\tif (rs->rs_conn && rs->rs_conn->c_faddr == daddr)\n\t\tconn = rs->rs_conn;\n\telse {\n\t\tconn = rds_conn_create_outgoing(sock_net(sock->sk),\n\t\t\t\t\t\trs->rs_bound_addr, daddr,\n\t\t\t\t\trs->rs_transport,\n\t\t\t\t\tsock->sk->sk_allocation);\n\t\tif (IS_ERR(conn)) {\n\t\t\tret = PTR_ERR(conn);\n\t\t\tgoto out;\n\t\t}\n\t\trs->rs_conn = conn;\n\t}\n\n\t/* Parse any control messages the user may have included. */\n\tret = rds_cmsg_send(rs, rm, msg, &allocated_mr);\n\tif (ret)\n\t\tgoto out;\n\n\tif (rm->rdma.op_active && !conn->c_trans->xmit_rdma) {\n\t\tprintk_ratelimited(KERN_NOTICE \"rdma_op %p conn xmit_rdma %p\\n\",\n\t\t\t       &rm->rdma, conn->c_trans->xmit_rdma);\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tif (rm->atomic.op_active && !conn->c_trans->xmit_atomic) {\n\t\tprintk_ratelimited(KERN_NOTICE \"atomic_op %p conn xmit_atomic %p\\n\",\n\t\t\t       &rm->atomic, conn->c_trans->xmit_atomic);\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\trds_conn_connect_if_down(conn);\n\n\tret = rds_cong_wait(conn->c_fcong, dport, nonblock, rs);\n\tif (ret) {\n\t\trs->rs_seen_congestion = 1;\n\t\tgoto out;\n\t}\n\n\twhile (!rds_send_queue_rm(rs, conn, rm, rs->rs_bound_port,\n\t\t\t\t  dport, &queued)) {\n\t\trds_stats_inc(s_send_queue_full);\n\n\t\tif (nonblock) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\n\t\ttimeo = wait_event_interruptible_timeout(*sk_sleep(sk),\n\t\t\t\t\trds_send_queue_rm(rs, conn, rm,\n\t\t\t\t\t\t\t  rs->rs_bound_port,\n\t\t\t\t\t\t\t  dport,\n\t\t\t\t\t\t\t  &queued),\n\t\t\t\t\ttimeo);\n\t\trdsdebug(\"sendmsg woke queued %d timeo %ld\\n\", queued, timeo);\n\t\tif (timeo > 0 || timeo == MAX_SCHEDULE_TIMEOUT)\n\t\t\tcontinue;\n\n\t\tret = timeo;\n\t\tif (ret == 0)\n\t\t\tret = -ETIMEDOUT;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * By now we've committed to the send.  We reuse rds_send_worker()\n\t * to retry sends in the rds thread if the transport asks us to.\n\t */\n\trds_stats_inc(s_send_queued);\n\n\tret = rds_send_xmit(conn);\n\tif (ret == -ENOMEM || ret == -EAGAIN)\n\t\tqueue_delayed_work(rds_wq, &conn->c_send_w, 1);\n\n\trds_message_put(rm);\n\treturn payload_len;\n\nout:\n\t/* If the user included a RDMA_MAP cmsg, we allocated a MR on the fly.\n\t * If the sendmsg goes through, we keep the MR. If it fails with EAGAIN\n\t * or in any other way, we need to destroy the MR again */\n\tif (allocated_mr)\n\t\trds_rdma_unuse(rs, rds_rdma_cookie_key(rm->m_rdma_cookie), 1);\n\n\tif (rm)\n\t\trds_message_put(rm);\n\treturn ret;\n}",
        "patch": "--- code before\n+++ code after\n@@ -35,11 +35,13 @@\n \t\trelease_sock(sk);\n \t}\n \n-\t/* racing with another thread binding seems ok here */\n+\tlock_sock(sk);\n \tif (daddr == 0 || rs->rs_bound_addr == 0) {\n+\t\trelease_sock(sk);\n \t\tret = -ENOTCONN; /* XXX not a great errno */\n \t\tgoto out;\n \t}\n+\trelease_sock(sk);\n \n \tif (payload_len > rds_sk_sndbuf(rs)) {\n \t\tret = -EMSGSIZE;",
        "function_modified_lines": {
            "added": [
                "\tlock_sock(sk);",
                "\t\trelease_sock(sk);",
                "\trelease_sock(sk);"
            ],
            "deleted": [
                "\t/* racing with another thread binding seems ok here */"
            ]
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "Race condition in the rds_sendmsg function in net/rds/sendmsg.c in the Linux kernel before 4.3.3 allows local users to cause a denial of service (NULL pointer dereference and system crash) or possibly have unspecified other impact by using a socket that was not properly bound.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2015-6937.",
        "id": 797
    },
    {
        "cve_id": "CVE-2022-39188",
        "code_before_change": "static inline void tlb_end_vma(struct mmu_gather *tlb, struct vm_area_struct *vma)\n{\n\tif (tlb->fullmm || IS_ENABLED(CONFIG_MMU_GATHER_MERGE_VMAS))\n\t\treturn;\n\n\t/*\n\t * Do a TLB flush and reset the range at VMA boundaries; this avoids\n\t * the ranges growing with the unused space between consecutive VMAs,\n\t * but also the mmu_gather::vma_* flags from tlb_start_vma() rely on\n\t * this.\n\t */\n\ttlb_flush_mmu_tlbonly(tlb);\n}",
        "code_after_change": "static inline void tlb_end_vma(struct mmu_gather *tlb, struct vm_area_struct *vma)\n{\n\tif (tlb->fullmm)\n\t\treturn;\n\n\t/*\n\t * VM_PFNMAP is more fragile because the core mm will not track the\n\t * page mapcount -- there might not be page-frames for these PFNs after\n\t * all. Force flush TLBs for such ranges to avoid munmap() vs\n\t * unmap_mapping_range() races.\n\t */\n\tif (tlb->vma_pfn || !IS_ENABLED(CONFIG_MMU_GATHER_MERGE_VMAS)) {\n\t\t/*\n\t\t * Do a TLB flush and reset the range at VMA boundaries; this avoids\n\t\t * the ranges growing with the unused space between consecutive VMAs.\n\t\t */\n\t\ttlb_flush_mmu_tlbonly(tlb);\n\t}\n}",
        "patch": "--- code before\n+++ code after\n@@ -1,13 +1,19 @@\n static inline void tlb_end_vma(struct mmu_gather *tlb, struct vm_area_struct *vma)\n {\n-\tif (tlb->fullmm || IS_ENABLED(CONFIG_MMU_GATHER_MERGE_VMAS))\n+\tif (tlb->fullmm)\n \t\treturn;\n \n \t/*\n-\t * Do a TLB flush and reset the range at VMA boundaries; this avoids\n-\t * the ranges growing with the unused space between consecutive VMAs,\n-\t * but also the mmu_gather::vma_* flags from tlb_start_vma() rely on\n-\t * this.\n+\t * VM_PFNMAP is more fragile because the core mm will not track the\n+\t * page mapcount -- there might not be page-frames for these PFNs after\n+\t * all. Force flush TLBs for such ranges to avoid munmap() vs\n+\t * unmap_mapping_range() races.\n \t */\n-\ttlb_flush_mmu_tlbonly(tlb);\n+\tif (tlb->vma_pfn || !IS_ENABLED(CONFIG_MMU_GATHER_MERGE_VMAS)) {\n+\t\t/*\n+\t\t * Do a TLB flush and reset the range at VMA boundaries; this avoids\n+\t\t * the ranges growing with the unused space between consecutive VMAs.\n+\t\t */\n+\t\ttlb_flush_mmu_tlbonly(tlb);\n+\t}\n }",
        "function_modified_lines": {
            "added": [
                "\tif (tlb->fullmm)",
                "\t * VM_PFNMAP is more fragile because the core mm will not track the",
                "\t * page mapcount -- there might not be page-frames for these PFNs after",
                "\t * all. Force flush TLBs for such ranges to avoid munmap() vs",
                "\t * unmap_mapping_range() races.",
                "\tif (tlb->vma_pfn || !IS_ENABLED(CONFIG_MMU_GATHER_MERGE_VMAS)) {",
                "\t\t/*",
                "\t\t * Do a TLB flush and reset the range at VMA boundaries; this avoids",
                "\t\t * the ranges growing with the unused space between consecutive VMAs.",
                "\t\t */",
                "\t\ttlb_flush_mmu_tlbonly(tlb);",
                "\t}"
            ],
            "deleted": [
                "\tif (tlb->fullmm || IS_ENABLED(CONFIG_MMU_GATHER_MERGE_VMAS))",
                "\t * Do a TLB flush and reset the range at VMA boundaries; this avoids",
                "\t * the ranges growing with the unused space between consecutive VMAs,",
                "\t * but also the mmu_gather::vma_* flags from tlb_start_vma() rely on",
                "\t * this.",
                "\ttlb_flush_mmu_tlbonly(tlb);"
            ]
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "An issue was discovered in include/asm-generic/tlb.h in the Linux kernel before 5.19. Because of a race condition (unmap_mapping_range versus munmap), a device driver can free a page while it still has stale TLB entries. This only occurs in situations with VM_PFNMAP VMAs.",
        "id": 3692
    },
    {
        "cve_id": "CVE-2017-1000405",
        "code_before_change": "struct page *follow_trans_huge_pmd(struct vm_area_struct *vma,\n\t\t\t\t   unsigned long addr,\n\t\t\t\t   pmd_t *pmd,\n\t\t\t\t   unsigned int flags)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct page *page = NULL;\n\n\tassert_spin_locked(pmd_lockptr(mm, pmd));\n\n\tif (flags & FOLL_WRITE && !can_follow_write_pmd(*pmd, flags))\n\t\tgoto out;\n\n\t/* Avoid dumping huge zero page */\n\tif ((flags & FOLL_DUMP) && is_huge_zero_pmd(*pmd))\n\t\treturn ERR_PTR(-EFAULT);\n\n\t/* Full NUMA hinting faults to serialise migration in fault paths */\n\tif ((flags & FOLL_NUMA) && pmd_protnone(*pmd))\n\t\tgoto out;\n\n\tpage = pmd_page(*pmd);\n\tVM_BUG_ON_PAGE(!PageHead(page) && !is_zone_device_page(page), page);\n\tif (flags & FOLL_TOUCH)\n\t\ttouch_pmd(vma, addr, pmd);\n\tif ((flags & FOLL_MLOCK) && (vma->vm_flags & VM_LOCKED)) {\n\t\t/*\n\t\t * We don't mlock() pte-mapped THPs. This way we can avoid\n\t\t * leaking mlocked pages into non-VM_LOCKED VMAs.\n\t\t *\n\t\t * For anon THP:\n\t\t *\n\t\t * In most cases the pmd is the only mapping of the page as we\n\t\t * break COW for the mlock() -- see gup_flags |= FOLL_WRITE for\n\t\t * writable private mappings in populate_vma_page_range().\n\t\t *\n\t\t * The only scenario when we have the page shared here is if we\n\t\t * mlocking read-only mapping shared over fork(). We skip\n\t\t * mlocking such pages.\n\t\t *\n\t\t * For file THP:\n\t\t *\n\t\t * We can expect PageDoubleMap() to be stable under page lock:\n\t\t * for file pages we set it in page_add_file_rmap(), which\n\t\t * requires page to be locked.\n\t\t */\n\n\t\tif (PageAnon(page) && compound_mapcount(page) != 1)\n\t\t\tgoto skip_mlock;\n\t\tif (PageDoubleMap(page) || !page->mapping)\n\t\t\tgoto skip_mlock;\n\t\tif (!trylock_page(page))\n\t\t\tgoto skip_mlock;\n\t\tlru_add_drain();\n\t\tif (page->mapping && !PageDoubleMap(page))\n\t\t\tmlock_vma_page(page);\n\t\tunlock_page(page);\n\t}\nskip_mlock:\n\tpage += (addr & ~HPAGE_PMD_MASK) >> PAGE_SHIFT;\n\tVM_BUG_ON_PAGE(!PageCompound(page) && !is_zone_device_page(page), page);\n\tif (flags & FOLL_GET)\n\t\tget_page(page);\n\nout:\n\treturn page;\n}",
        "code_after_change": "struct page *follow_trans_huge_pmd(struct vm_area_struct *vma,\n\t\t\t\t   unsigned long addr,\n\t\t\t\t   pmd_t *pmd,\n\t\t\t\t   unsigned int flags)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct page *page = NULL;\n\n\tassert_spin_locked(pmd_lockptr(mm, pmd));\n\n\tif (flags & FOLL_WRITE && !can_follow_write_pmd(*pmd, flags))\n\t\tgoto out;\n\n\t/* Avoid dumping huge zero page */\n\tif ((flags & FOLL_DUMP) && is_huge_zero_pmd(*pmd))\n\t\treturn ERR_PTR(-EFAULT);\n\n\t/* Full NUMA hinting faults to serialise migration in fault paths */\n\tif ((flags & FOLL_NUMA) && pmd_protnone(*pmd))\n\t\tgoto out;\n\n\tpage = pmd_page(*pmd);\n\tVM_BUG_ON_PAGE(!PageHead(page) && !is_zone_device_page(page), page);\n\tif (flags & FOLL_TOUCH)\n\t\ttouch_pmd(vma, addr, pmd, flags);\n\tif ((flags & FOLL_MLOCK) && (vma->vm_flags & VM_LOCKED)) {\n\t\t/*\n\t\t * We don't mlock() pte-mapped THPs. This way we can avoid\n\t\t * leaking mlocked pages into non-VM_LOCKED VMAs.\n\t\t *\n\t\t * For anon THP:\n\t\t *\n\t\t * In most cases the pmd is the only mapping of the page as we\n\t\t * break COW for the mlock() -- see gup_flags |= FOLL_WRITE for\n\t\t * writable private mappings in populate_vma_page_range().\n\t\t *\n\t\t * The only scenario when we have the page shared here is if we\n\t\t * mlocking read-only mapping shared over fork(). We skip\n\t\t * mlocking such pages.\n\t\t *\n\t\t * For file THP:\n\t\t *\n\t\t * We can expect PageDoubleMap() to be stable under page lock:\n\t\t * for file pages we set it in page_add_file_rmap(), which\n\t\t * requires page to be locked.\n\t\t */\n\n\t\tif (PageAnon(page) && compound_mapcount(page) != 1)\n\t\t\tgoto skip_mlock;\n\t\tif (PageDoubleMap(page) || !page->mapping)\n\t\t\tgoto skip_mlock;\n\t\tif (!trylock_page(page))\n\t\t\tgoto skip_mlock;\n\t\tlru_add_drain();\n\t\tif (page->mapping && !PageDoubleMap(page))\n\t\t\tmlock_vma_page(page);\n\t\tunlock_page(page);\n\t}\nskip_mlock:\n\tpage += (addr & ~HPAGE_PMD_MASK) >> PAGE_SHIFT;\n\tVM_BUG_ON_PAGE(!PageCompound(page) && !is_zone_device_page(page), page);\n\tif (flags & FOLL_GET)\n\t\tget_page(page);\n\nout:\n\treturn page;\n}",
        "patch": "--- code before\n+++ code after\n@@ -22,7 +22,7 @@\n \tpage = pmd_page(*pmd);\n \tVM_BUG_ON_PAGE(!PageHead(page) && !is_zone_device_page(page), page);\n \tif (flags & FOLL_TOUCH)\n-\t\ttouch_pmd(vma, addr, pmd);\n+\t\ttouch_pmd(vma, addr, pmd, flags);\n \tif ((flags & FOLL_MLOCK) && (vma->vm_flags & VM_LOCKED)) {\n \t\t/*\n \t\t * We don't mlock() pte-mapped THPs. This way we can avoid",
        "function_modified_lines": {
            "added": [
                "\t\ttouch_pmd(vma, addr, pmd, flags);"
            ],
            "deleted": [
                "\t\ttouch_pmd(vma, addr, pmd);"
            ]
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "The Linux Kernel versions 2.6.38 through 4.14 have a problematic use of pmd_mkdirty() in the touch_pmd() function inside the THP implementation. touch_pmd() can be reached by get_user_pages(). In such case, the pmd will become dirty. This scenario breaks the new can_follow_write_pmd()'s logic - pmd can become dirty without going through a COW cycle. This bug is not as severe as the original \"Dirty cow\" because an ext4 file (or any other regular file) cannot be mapped using THP. Nevertheless, it does allow us to overwrite read-only huge pages. For example, the zero huge page and sealed shmem files can be overwritten (since their mapping can be populated using THP). Note that after the first write page-fault to the zero page, it will be replaced with a new fresh (and zeroed) thp.",
        "id": 1240
    },
    {
        "cve_id": "CVE-2023-33951",
        "code_before_change": "int vmw_gem_object_create_ioctl(struct drm_device *dev, void *data,\n\t\t\t\tstruct drm_file *filp)\n{\n\tstruct vmw_private *dev_priv = vmw_priv(dev);\n\tunion drm_vmw_alloc_dmabuf_arg *arg =\n\t    (union drm_vmw_alloc_dmabuf_arg *)data;\n\tstruct drm_vmw_alloc_dmabuf_req *req = &arg->req;\n\tstruct drm_vmw_dmabuf_rep *rep = &arg->rep;\n\tstruct vmw_bo *vbo;\n\tuint32_t handle;\n\tint ret;\n\n\tret = vmw_gem_object_create_with_handle(dev_priv, filp,\n\t\t\t\t\t\treq->size, &handle, &vbo);\n\tif (ret)\n\t\tgoto out_no_bo;\n\n\trep->handle = handle;\n\trep->map_handle = drm_vma_node_offset_addr(&vbo->tbo.base.vma_node);\n\trep->cur_gmr_id = handle;\n\trep->cur_gmr_offset = 0;\nout_no_bo:\n\treturn ret;\n}",
        "code_after_change": "int vmw_gem_object_create_ioctl(struct drm_device *dev, void *data,\n\t\t\t\tstruct drm_file *filp)\n{\n\tstruct vmw_private *dev_priv = vmw_priv(dev);\n\tunion drm_vmw_alloc_dmabuf_arg *arg =\n\t    (union drm_vmw_alloc_dmabuf_arg *)data;\n\tstruct drm_vmw_alloc_dmabuf_req *req = &arg->req;\n\tstruct drm_vmw_dmabuf_rep *rep = &arg->rep;\n\tstruct vmw_bo *vbo;\n\tuint32_t handle;\n\tint ret;\n\n\tret = vmw_gem_object_create_with_handle(dev_priv, filp,\n\t\t\t\t\t\treq->size, &handle, &vbo);\n\tif (ret)\n\t\tgoto out_no_bo;\n\n\trep->handle = handle;\n\trep->map_handle = drm_vma_node_offset_addr(&vbo->tbo.base.vma_node);\n\trep->cur_gmr_id = handle;\n\trep->cur_gmr_offset = 0;\n\t/* drop reference from allocate - handle holds it now */\n\tdrm_gem_object_put(&vbo->tbo.base);\nout_no_bo:\n\treturn ret;\n}",
        "patch": "--- code before\n+++ code after\n@@ -19,6 +19,8 @@\n \trep->map_handle = drm_vma_node_offset_addr(&vbo->tbo.base.vma_node);\n \trep->cur_gmr_id = handle;\n \trep->cur_gmr_offset = 0;\n+\t/* drop reference from allocate - handle holds it now */\n+\tdrm_gem_object_put(&vbo->tbo.base);\n out_no_bo:\n \treturn ret;\n }",
        "function_modified_lines": {
            "added": [
                "\t/* drop reference from allocate - handle holds it now */",
                "\tdrm_gem_object_put(&vbo->tbo.base);"
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-362",
            "CWE-667"
        ],
        "cve_description": "A race condition vulnerability was found in the vmwgfx driver in the Linux kernel. The flaw exists within the handling of GEM objects. The issue results from improper locking when performing operations on an object. This flaw allows a local privileged user to disclose information in the context of the kernel.",
        "id": 4083
    },
    {
        "cve_id": "CVE-2023-33951",
        "code_before_change": "int vmw_overlay_ioctl(struct drm_device *dev, void *data,\n\t\t      struct drm_file *file_priv)\n{\n\tstruct ttm_object_file *tfile = vmw_fpriv(file_priv)->tfile;\n\tstruct vmw_private *dev_priv = vmw_priv(dev);\n\tstruct vmw_overlay *overlay = dev_priv->overlay_priv;\n\tstruct drm_vmw_control_stream_arg *arg =\n\t    (struct drm_vmw_control_stream_arg *)data;\n\tstruct vmw_bo *buf;\n\tstruct vmw_resource *res;\n\tint ret;\n\n\tif (!vmw_overlay_available(dev_priv))\n\t\treturn -ENOSYS;\n\n\tret = vmw_user_stream_lookup(dev_priv, tfile, &arg->stream_id, &res);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&overlay->mutex);\n\n\tif (!arg->enabled) {\n\t\tret = vmw_overlay_stop(dev_priv, arg->stream_id, false, true);\n\t\tgoto out_unlock;\n\t}\n\n\tret = vmw_user_bo_lookup(file_priv, arg->handle, &buf);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = vmw_overlay_update_stream(dev_priv, buf, arg, true);\n\n\tvmw_bo_unreference(&buf);\n\nout_unlock:\n\tmutex_unlock(&overlay->mutex);\n\tvmw_resource_unreference(&res);\n\n\treturn ret;\n}",
        "code_after_change": "int vmw_overlay_ioctl(struct drm_device *dev, void *data,\n\t\t      struct drm_file *file_priv)\n{\n\tstruct ttm_object_file *tfile = vmw_fpriv(file_priv)->tfile;\n\tstruct vmw_private *dev_priv = vmw_priv(dev);\n\tstruct vmw_overlay *overlay = dev_priv->overlay_priv;\n\tstruct drm_vmw_control_stream_arg *arg =\n\t    (struct drm_vmw_control_stream_arg *)data;\n\tstruct vmw_bo *buf;\n\tstruct vmw_resource *res;\n\tint ret;\n\n\tif (!vmw_overlay_available(dev_priv))\n\t\treturn -ENOSYS;\n\n\tret = vmw_user_stream_lookup(dev_priv, tfile, &arg->stream_id, &res);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&overlay->mutex);\n\n\tif (!arg->enabled) {\n\t\tret = vmw_overlay_stop(dev_priv, arg->stream_id, false, true);\n\t\tgoto out_unlock;\n\t}\n\n\tret = vmw_user_bo_lookup(file_priv, arg->handle, &buf);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = vmw_overlay_update_stream(dev_priv, buf, arg, true);\n\n\tvmw_bo_unreference(&buf);\n\tdrm_gem_object_put(&buf->tbo.base);\n\nout_unlock:\n\tmutex_unlock(&overlay->mutex);\n\tvmw_resource_unreference(&res);\n\n\treturn ret;\n}",
        "patch": "--- code before\n+++ code after\n@@ -31,6 +31,7 @@\n \tret = vmw_overlay_update_stream(dev_priv, buf, arg, true);\n \n \tvmw_bo_unreference(&buf);\n+\tdrm_gem_object_put(&buf->tbo.base);\n \n out_unlock:\n \tmutex_unlock(&overlay->mutex);",
        "function_modified_lines": {
            "added": [
                "\tdrm_gem_object_put(&buf->tbo.base);"
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-362",
            "CWE-667"
        ],
        "cve_description": "A race condition vulnerability was found in the vmwgfx driver in the Linux kernel. The flaw exists within the handling of GEM objects. The issue results from improper locking when performing operations on an object. This flaw allows a local privileged user to disclose information in the context of the kernel.",
        "id": 4085
    },
    {
        "cve_id": "CVE-2020-14416",
        "code_before_change": "static void slcan_write_wakeup(struct tty_struct *tty)\n{\n\tstruct slcan *sl = tty->disc_data;\n\n\tschedule_work(&sl->tx_work);\n}",
        "code_after_change": "static void slcan_write_wakeup(struct tty_struct *tty)\n{\n\tstruct slcan *sl;\n\n\trcu_read_lock();\n\tsl = rcu_dereference(tty->disc_data);\n\tif (!sl)\n\t\tgoto out;\n\n\tschedule_work(&sl->tx_work);\nout:\n\trcu_read_unlock();\n}",
        "patch": "--- code before\n+++ code after\n@@ -1,6 +1,13 @@\n static void slcan_write_wakeup(struct tty_struct *tty)\n {\n-\tstruct slcan *sl = tty->disc_data;\n+\tstruct slcan *sl;\n+\n+\trcu_read_lock();\n+\tsl = rcu_dereference(tty->disc_data);\n+\tif (!sl)\n+\t\tgoto out;\n \n \tschedule_work(&sl->tx_work);\n+out:\n+\trcu_read_unlock();\n }",
        "function_modified_lines": {
            "added": [
                "\tstruct slcan *sl;",
                "",
                "\trcu_read_lock();",
                "\tsl = rcu_dereference(tty->disc_data);",
                "\tif (!sl)",
                "\t\tgoto out;",
                "out:",
                "\trcu_read_unlock();"
            ],
            "deleted": [
                "\tstruct slcan *sl = tty->disc_data;"
            ]
        },
        "cwe": [
            "CWE-362",
            "CWE-416"
        ],
        "cve_description": "In the Linux kernel before 5.4.16, a race condition in tty->disc_data handling in the slip and slcan line discipline could lead to a use-after-free, aka CID-0ace17d56824. This affects drivers/net/slip/slip.c and drivers/net/can/slcan.c.",
        "id": 2541
    },
    {
        "cve_id": "CVE-2013-3302",
        "code_before_change": "static int\nsmb_send_kvec(struct TCP_Server_Info *server, struct kvec *iov, size_t n_vec,\n\t\tsize_t *sent)\n{\n\tint rc = 0;\n\tint i = 0;\n\tstruct msghdr smb_msg;\n\tunsigned int remaining;\n\tsize_t first_vec = 0;\n\tstruct socket *ssocket = server->ssocket;\n\n\t*sent = 0;\n\n\tif (ssocket == NULL)\n\t\treturn -ENOTSOCK; /* BB eventually add reconnect code here */\n\n\tsmb_msg.msg_name = (struct sockaddr *) &server->dstaddr;\n\tsmb_msg.msg_namelen = sizeof(struct sockaddr);\n\tsmb_msg.msg_control = NULL;\n\tsmb_msg.msg_controllen = 0;\n\tif (server->noblocksnd)\n\t\tsmb_msg.msg_flags = MSG_DONTWAIT + MSG_NOSIGNAL;\n\telse\n\t\tsmb_msg.msg_flags = MSG_NOSIGNAL;\n\n\tremaining = 0;\n\tfor (i = 0; i < n_vec; i++)\n\t\tremaining += iov[i].iov_len;\n\n\ti = 0;\n\twhile (remaining) {\n\t\t/*\n\t\t * If blocking send, we try 3 times, since each can block\n\t\t * for 5 seconds. For nonblocking  we have to try more\n\t\t * but wait increasing amounts of time allowing time for\n\t\t * socket to clear.  The overall time we wait in either\n\t\t * case to send on the socket is about 15 seconds.\n\t\t * Similarly we wait for 15 seconds for a response from\n\t\t * the server in SendReceive[2] for the server to send\n\t\t * a response back for most types of requests (except\n\t\t * SMB Write past end of file which can be slow, and\n\t\t * blocking lock operations). NFS waits slightly longer\n\t\t * than CIFS, but this can make it take longer for\n\t\t * nonresponsive servers to be detected and 15 seconds\n\t\t * is more than enough time for modern networks to\n\t\t * send a packet.  In most cases if we fail to send\n\t\t * after the retries we will kill the socket and\n\t\t * reconnect which may clear the network problem.\n\t\t */\n\t\trc = kernel_sendmsg(ssocket, &smb_msg, &iov[first_vec],\n\t\t\t\t    n_vec - first_vec, remaining);\n\t\tif (rc == -ENOSPC || rc == -EAGAIN) {\n\t\t\t/*\n\t\t\t * Catch if a low level driver returns -ENOSPC. This\n\t\t\t * WARN_ON will be removed by 3.10 if no one reports\n\t\t\t * seeing this.\n\t\t\t */\n\t\t\tWARN_ON_ONCE(rc == -ENOSPC);\n\t\t\ti++;\n\t\t\tif (i >= 14 || (!server->noblocksnd && (i > 2))) {\n\t\t\t\tcERROR(1, \"sends on sock %p stuck for 15 \"\n\t\t\t\t\t  \"seconds\", ssocket);\n\t\t\t\trc = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmsleep(1 << i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (rc < 0)\n\t\t\tbreak;\n\n\t\t/* send was at least partially successful */\n\t\t*sent += rc;\n\n\t\tif (rc == remaining) {\n\t\t\tremaining = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rc > remaining) {\n\t\t\tcERROR(1, \"sent %d requested %d\", rc, remaining);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rc == 0) {\n\t\t\t/* should never happen, letting socket clear before\n\t\t\t   retrying is our only obvious option here */\n\t\t\tcERROR(1, \"tcp sent no data\");\n\t\t\tmsleep(500);\n\t\t\tcontinue;\n\t\t}\n\n\t\tremaining -= rc;\n\n\t\t/* the line below resets i */\n\t\tfor (i = first_vec; i < n_vec; i++) {\n\t\t\tif (iov[i].iov_len) {\n\t\t\t\tif (rc > iov[i].iov_len) {\n\t\t\t\t\trc -= iov[i].iov_len;\n\t\t\t\t\tiov[i].iov_len = 0;\n\t\t\t\t} else {\n\t\t\t\t\tiov[i].iov_base += rc;\n\t\t\t\t\tiov[i].iov_len -= rc;\n\t\t\t\t\tfirst_vec = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ti = 0; /* in case we get ENOSPC on the next send */\n\t\trc = 0;\n\t}\n\treturn rc;\n}",
        "code_after_change": "static int\nsmb_send_kvec(struct TCP_Server_Info *server, struct kvec *iov, size_t n_vec,\n\t\tsize_t *sent)\n{\n\tint rc = 0;\n\tint i = 0;\n\tstruct msghdr smb_msg;\n\tunsigned int remaining;\n\tsize_t first_vec = 0;\n\tstruct socket *ssocket = server->ssocket;\n\n\t*sent = 0;\n\n\tsmb_msg.msg_name = (struct sockaddr *) &server->dstaddr;\n\tsmb_msg.msg_namelen = sizeof(struct sockaddr);\n\tsmb_msg.msg_control = NULL;\n\tsmb_msg.msg_controllen = 0;\n\tif (server->noblocksnd)\n\t\tsmb_msg.msg_flags = MSG_DONTWAIT + MSG_NOSIGNAL;\n\telse\n\t\tsmb_msg.msg_flags = MSG_NOSIGNAL;\n\n\tremaining = 0;\n\tfor (i = 0; i < n_vec; i++)\n\t\tremaining += iov[i].iov_len;\n\n\ti = 0;\n\twhile (remaining) {\n\t\t/*\n\t\t * If blocking send, we try 3 times, since each can block\n\t\t * for 5 seconds. For nonblocking  we have to try more\n\t\t * but wait increasing amounts of time allowing time for\n\t\t * socket to clear.  The overall time we wait in either\n\t\t * case to send on the socket is about 15 seconds.\n\t\t * Similarly we wait for 15 seconds for a response from\n\t\t * the server in SendReceive[2] for the server to send\n\t\t * a response back for most types of requests (except\n\t\t * SMB Write past end of file which can be slow, and\n\t\t * blocking lock operations). NFS waits slightly longer\n\t\t * than CIFS, but this can make it take longer for\n\t\t * nonresponsive servers to be detected and 15 seconds\n\t\t * is more than enough time for modern networks to\n\t\t * send a packet.  In most cases if we fail to send\n\t\t * after the retries we will kill the socket and\n\t\t * reconnect which may clear the network problem.\n\t\t */\n\t\trc = kernel_sendmsg(ssocket, &smb_msg, &iov[first_vec],\n\t\t\t\t    n_vec - first_vec, remaining);\n\t\tif (rc == -ENOSPC || rc == -EAGAIN) {\n\t\t\t/*\n\t\t\t * Catch if a low level driver returns -ENOSPC. This\n\t\t\t * WARN_ON will be removed by 3.10 if no one reports\n\t\t\t * seeing this.\n\t\t\t */\n\t\t\tWARN_ON_ONCE(rc == -ENOSPC);\n\t\t\ti++;\n\t\t\tif (i >= 14 || (!server->noblocksnd && (i > 2))) {\n\t\t\t\tcERROR(1, \"sends on sock %p stuck for 15 \"\n\t\t\t\t\t  \"seconds\", ssocket);\n\t\t\t\trc = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmsleep(1 << i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (rc < 0)\n\t\t\tbreak;\n\n\t\t/* send was at least partially successful */\n\t\t*sent += rc;\n\n\t\tif (rc == remaining) {\n\t\t\tremaining = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rc > remaining) {\n\t\t\tcERROR(1, \"sent %d requested %d\", rc, remaining);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rc == 0) {\n\t\t\t/* should never happen, letting socket clear before\n\t\t\t   retrying is our only obvious option here */\n\t\t\tcERROR(1, \"tcp sent no data\");\n\t\t\tmsleep(500);\n\t\t\tcontinue;\n\t\t}\n\n\t\tremaining -= rc;\n\n\t\t/* the line below resets i */\n\t\tfor (i = first_vec; i < n_vec; i++) {\n\t\t\tif (iov[i].iov_len) {\n\t\t\t\tif (rc > iov[i].iov_len) {\n\t\t\t\t\trc -= iov[i].iov_len;\n\t\t\t\t\tiov[i].iov_len = 0;\n\t\t\t\t} else {\n\t\t\t\t\tiov[i].iov_base += rc;\n\t\t\t\t\tiov[i].iov_len -= rc;\n\t\t\t\t\tfirst_vec = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ti = 0; /* in case we get ENOSPC on the next send */\n\t\trc = 0;\n\t}\n\treturn rc;\n}",
        "patch": "--- code before\n+++ code after\n@@ -10,9 +10,6 @@\n \tstruct socket *ssocket = server->ssocket;\n \n \t*sent = 0;\n-\n-\tif (ssocket == NULL)\n-\t\treturn -ENOTSOCK; /* BB eventually add reconnect code here */\n \n \tsmb_msg.msg_name = (struct sockaddr *) &server->dstaddr;\n \tsmb_msg.msg_namelen = sizeof(struct sockaddr);",
        "function_modified_lines": {
            "added": [],
            "deleted": [
                "",
                "\tif (ssocket == NULL)",
                "\t\treturn -ENOTSOCK; /* BB eventually add reconnect code here */"
            ]
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "Race condition in the smb_send_rqst function in fs/cifs/transport.c in the Linux kernel before 3.7.2 allows local users to cause a denial of service (NULL pointer dereference and OOPS) or possibly have unspecified other impact via vectors involving a reconnection event.",
        "id": 278
    },
    {
        "cve_id": "CVE-2015-9016",
        "code_before_change": "static void flush_end_io(struct request *flush_rq, int error)\n{\n\tstruct request_queue *q = flush_rq->q;\n\tstruct list_head *running;\n\tbool queued = false;\n\tstruct request *rq, *n;\n\tunsigned long flags = 0;\n\tstruct blk_flush_queue *fq = blk_get_flush_queue(q, flush_rq->mq_ctx);\n\n\tif (q->mq_ops) {\n\t\tspin_lock_irqsave(&fq->mq_flush_lock, flags);\n\t\tflush_rq->tag = -1;\n\t}\n\n\trunning = &fq->flush_queue[fq->flush_running_idx];\n\tBUG_ON(fq->flush_pending_idx == fq->flush_running_idx);\n\n\t/* account completion of the flush request */\n\tfq->flush_running_idx ^= 1;\n\n\tif (!q->mq_ops)\n\t\telv_completed_request(q, flush_rq);\n\n\t/* and push the waiting requests to the next stage */\n\tlist_for_each_entry_safe(rq, n, running, flush.list) {\n\t\tunsigned int seq = blk_flush_cur_seq(rq);\n\n\t\tBUG_ON(seq != REQ_FSEQ_PREFLUSH && seq != REQ_FSEQ_POSTFLUSH);\n\t\tqueued |= blk_flush_complete_seq(rq, fq, seq, error);\n\t}\n\n\t/*\n\t * Kick the queue to avoid stall for two cases:\n\t * 1. Moving a request silently to empty queue_head may stall the\n\t * queue.\n\t * 2. When flush request is running in non-queueable queue, the\n\t * queue is hold. Restart the queue after flush request is finished\n\t * to avoid stall.\n\t * This function is called from request completion path and calling\n\t * directly into request_fn may confuse the driver.  Always use\n\t * kblockd.\n\t */\n\tif (queued || fq->flush_queue_delayed) {\n\t\tWARN_ON(q->mq_ops);\n\t\tblk_run_queue_async(q);\n\t}\n\tfq->flush_queue_delayed = 0;\n\tif (q->mq_ops)\n\t\tspin_unlock_irqrestore(&fq->mq_flush_lock, flags);\n}",
        "code_after_change": "static void flush_end_io(struct request *flush_rq, int error)\n{\n\tstruct request_queue *q = flush_rq->q;\n\tstruct list_head *running;\n\tbool queued = false;\n\tstruct request *rq, *n;\n\tunsigned long flags = 0;\n\tstruct blk_flush_queue *fq = blk_get_flush_queue(q, flush_rq->mq_ctx);\n\n\tif (q->mq_ops) {\n\t\tstruct blk_mq_hw_ctx *hctx;\n\n\t\t/* release the tag's ownership to the req cloned from */\n\t\tspin_lock_irqsave(&fq->mq_flush_lock, flags);\n\t\thctx = q->mq_ops->map_queue(q, flush_rq->mq_ctx->cpu);\n\t\tblk_mq_tag_set_rq(hctx, flush_rq->tag, fq->orig_rq);\n\t\tflush_rq->tag = -1;\n\t}\n\n\trunning = &fq->flush_queue[fq->flush_running_idx];\n\tBUG_ON(fq->flush_pending_idx == fq->flush_running_idx);\n\n\t/* account completion of the flush request */\n\tfq->flush_running_idx ^= 1;\n\n\tif (!q->mq_ops)\n\t\telv_completed_request(q, flush_rq);\n\n\t/* and push the waiting requests to the next stage */\n\tlist_for_each_entry_safe(rq, n, running, flush.list) {\n\t\tunsigned int seq = blk_flush_cur_seq(rq);\n\n\t\tBUG_ON(seq != REQ_FSEQ_PREFLUSH && seq != REQ_FSEQ_POSTFLUSH);\n\t\tqueued |= blk_flush_complete_seq(rq, fq, seq, error);\n\t}\n\n\t/*\n\t * Kick the queue to avoid stall for two cases:\n\t * 1. Moving a request silently to empty queue_head may stall the\n\t * queue.\n\t * 2. When flush request is running in non-queueable queue, the\n\t * queue is hold. Restart the queue after flush request is finished\n\t * to avoid stall.\n\t * This function is called from request completion path and calling\n\t * directly into request_fn may confuse the driver.  Always use\n\t * kblockd.\n\t */\n\tif (queued || fq->flush_queue_delayed) {\n\t\tWARN_ON(q->mq_ops);\n\t\tblk_run_queue_async(q);\n\t}\n\tfq->flush_queue_delayed = 0;\n\tif (q->mq_ops)\n\t\tspin_unlock_irqrestore(&fq->mq_flush_lock, flags);\n}",
        "patch": "--- code before\n+++ code after\n@@ -8,7 +8,12 @@\n \tstruct blk_flush_queue *fq = blk_get_flush_queue(q, flush_rq->mq_ctx);\n \n \tif (q->mq_ops) {\n+\t\tstruct blk_mq_hw_ctx *hctx;\n+\n+\t\t/* release the tag's ownership to the req cloned from */\n \t\tspin_lock_irqsave(&fq->mq_flush_lock, flags);\n+\t\thctx = q->mq_ops->map_queue(q, flush_rq->mq_ctx->cpu);\n+\t\tblk_mq_tag_set_rq(hctx, flush_rq->tag, fq->orig_rq);\n \t\tflush_rq->tag = -1;\n \t}\n ",
        "function_modified_lines": {
            "added": [
                "\t\tstruct blk_mq_hw_ctx *hctx;",
                "",
                "\t\t/* release the tag's ownership to the req cloned from */",
                "\t\thctx = q->mq_ops->map_queue(q, flush_rq->mq_ctx->cpu);",
                "\t\tblk_mq_tag_set_rq(hctx, flush_rq->tag, fq->orig_rq);"
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-264",
            "CWE-362"
        ],
        "cve_description": "In blk_mq_tag_to_rq in blk-mq.c in the upstream kernel, there is a possible use after free due to a race condition when a request has been previously freed by blk_mq_complete_request. This could lead to local escalation of privilege. Product: Android. Versions: Android kernel. Android ID: A-63083046.",
        "id": 881
    },
    {
        "cve_id": "CVE-2015-9016",
        "code_before_change": "static bool blk_kick_flush(struct request_queue *q, struct blk_flush_queue *fq)\n{\n\tstruct list_head *pending = &fq->flush_queue[fq->flush_pending_idx];\n\tstruct request *first_rq =\n\t\tlist_first_entry(pending, struct request, flush.list);\n\tstruct request *flush_rq = fq->flush_rq;\n\n\t/* C1 described at the top of this file */\n\tif (fq->flush_pending_idx != fq->flush_running_idx || list_empty(pending))\n\t\treturn false;\n\n\t/* C2 and C3 */\n\tif (!list_empty(&fq->flush_data_in_flight) &&\n\t    time_before(jiffies,\n\t\t\tfq->flush_pending_since + FLUSH_PENDING_TIMEOUT))\n\t\treturn false;\n\n\t/*\n\t * Issue flush and toggle pending_idx.  This makes pending_idx\n\t * different from running_idx, which means flush is in flight.\n\t */\n\tfq->flush_pending_idx ^= 1;\n\n\tblk_rq_init(q, flush_rq);\n\n\t/*\n\t * Borrow tag from the first request since they can't\n\t * be in flight at the same time.\n\t */\n\tif (q->mq_ops) {\n\t\tflush_rq->mq_ctx = first_rq->mq_ctx;\n\t\tflush_rq->tag = first_rq->tag;\n\t}\n\n\tflush_rq->cmd_type = REQ_TYPE_FS;\n\tflush_rq->cmd_flags = WRITE_FLUSH | REQ_FLUSH_SEQ;\n\tflush_rq->rq_disk = first_rq->rq_disk;\n\tflush_rq->end_io = flush_end_io;\n\n\treturn blk_flush_queue_rq(flush_rq, false);\n}",
        "code_after_change": "static bool blk_kick_flush(struct request_queue *q, struct blk_flush_queue *fq)\n{\n\tstruct list_head *pending = &fq->flush_queue[fq->flush_pending_idx];\n\tstruct request *first_rq =\n\t\tlist_first_entry(pending, struct request, flush.list);\n\tstruct request *flush_rq = fq->flush_rq;\n\n\t/* C1 described at the top of this file */\n\tif (fq->flush_pending_idx != fq->flush_running_idx || list_empty(pending))\n\t\treturn false;\n\n\t/* C2 and C3 */\n\tif (!list_empty(&fq->flush_data_in_flight) &&\n\t    time_before(jiffies,\n\t\t\tfq->flush_pending_since + FLUSH_PENDING_TIMEOUT))\n\t\treturn false;\n\n\t/*\n\t * Issue flush and toggle pending_idx.  This makes pending_idx\n\t * different from running_idx, which means flush is in flight.\n\t */\n\tfq->flush_pending_idx ^= 1;\n\n\tblk_rq_init(q, flush_rq);\n\n\t/*\n\t * Borrow tag from the first request since they can't\n\t * be in flight at the same time. And acquire the tag's\n\t * ownership for flush req.\n\t */\n\tif (q->mq_ops) {\n\t\tstruct blk_mq_hw_ctx *hctx;\n\n\t\tflush_rq->mq_ctx = first_rq->mq_ctx;\n\t\tflush_rq->tag = first_rq->tag;\n\t\tfq->orig_rq = first_rq;\n\n\t\thctx = q->mq_ops->map_queue(q, first_rq->mq_ctx->cpu);\n\t\tblk_mq_tag_set_rq(hctx, first_rq->tag, flush_rq);\n\t}\n\n\tflush_rq->cmd_type = REQ_TYPE_FS;\n\tflush_rq->cmd_flags = WRITE_FLUSH | REQ_FLUSH_SEQ;\n\tflush_rq->rq_disk = first_rq->rq_disk;\n\tflush_rq->end_io = flush_end_io;\n\n\treturn blk_flush_queue_rq(flush_rq, false);\n}",
        "patch": "--- code before\n+++ code after\n@@ -25,11 +25,18 @@\n \n \t/*\n \t * Borrow tag from the first request since they can't\n-\t * be in flight at the same time.\n+\t * be in flight at the same time. And acquire the tag's\n+\t * ownership for flush req.\n \t */\n \tif (q->mq_ops) {\n+\t\tstruct blk_mq_hw_ctx *hctx;\n+\n \t\tflush_rq->mq_ctx = first_rq->mq_ctx;\n \t\tflush_rq->tag = first_rq->tag;\n+\t\tfq->orig_rq = first_rq;\n+\n+\t\thctx = q->mq_ops->map_queue(q, first_rq->mq_ctx->cpu);\n+\t\tblk_mq_tag_set_rq(hctx, first_rq->tag, flush_rq);\n \t}\n \n \tflush_rq->cmd_type = REQ_TYPE_FS;",
        "function_modified_lines": {
            "added": [
                "\t * be in flight at the same time. And acquire the tag's",
                "\t * ownership for flush req.",
                "\t\tstruct blk_mq_hw_ctx *hctx;",
                "",
                "\t\tfq->orig_rq = first_rq;",
                "",
                "\t\thctx = q->mq_ops->map_queue(q, first_rq->mq_ctx->cpu);",
                "\t\tblk_mq_tag_set_rq(hctx, first_rq->tag, flush_rq);"
            ],
            "deleted": [
                "\t * be in flight at the same time."
            ]
        },
        "cwe": [
            "CWE-264",
            "CWE-362"
        ],
        "cve_description": "In blk_mq_tag_to_rq in blk-mq.c in the upstream kernel, there is a possible use after free due to a race condition when a request has been previously freed by blk_mq_complete_request. This could lead to local escalation of privilege. Product: Android. Versions: Android kernel. Android ID: A-63083046.",
        "id": 882
    },
    {
        "cve_id": "CVE-2018-20836",
        "code_before_change": "static void smp_task_done(struct sas_task *task)\n{\n\tif (!del_timer(&task->slow_task->timer))\n\t\treturn;\n\tcomplete(&task->slow_task->completion);\n}",
        "code_after_change": "static void smp_task_done(struct sas_task *task)\n{\n\tdel_timer(&task->slow_task->timer);\n\tcomplete(&task->slow_task->completion);\n}",
        "patch": "--- code before\n+++ code after\n@@ -1,6 +1,5 @@\n static void smp_task_done(struct sas_task *task)\n {\n-\tif (!del_timer(&task->slow_task->timer))\n-\t\treturn;\n+\tdel_timer(&task->slow_task->timer);\n \tcomplete(&task->slow_task->completion);\n }",
        "function_modified_lines": {
            "added": [
                "\tdel_timer(&task->slow_task->timer);"
            ],
            "deleted": [
                "\tif (!del_timer(&task->slow_task->timer))",
                "\t\treturn;"
            ]
        },
        "cwe": [
            "CWE-362",
            "CWE-416"
        ],
        "cve_description": "An issue was discovered in the Linux kernel before 4.20. There is a race condition in smp_task_timedout() and smp_task_done() in drivers/scsi/libsas/sas_expander.c, leading to a use-after-free.",
        "id": 1783
    },
    {
        "cve_id": "CVE-2022-3564",
        "code_before_change": "static int l2cap_rx_state_recv(struct l2cap_chan *chan,\n\t\t\t       struct l2cap_ctrl *control,\n\t\t\t       struct sk_buff *skb, u8 event)\n{\n\tint err = 0;\n\tbool skb_in_use = false;\n\n\tBT_DBG(\"chan %p, control %p, skb %p, event %d\", chan, control, skb,\n\t       event);\n\n\tswitch (event) {\n\tcase L2CAP_EV_RECV_IFRAME:\n\t\tswitch (l2cap_classify_txseq(chan, control->txseq)) {\n\t\tcase L2CAP_TXSEQ_EXPECTED:\n\t\t\tl2cap_pass_to_tx(chan, control);\n\n\t\t\tif (test_bit(CONN_LOCAL_BUSY, &chan->conn_state)) {\n\t\t\t\tBT_DBG(\"Busy, discarding expected seq %d\",\n\t\t\t\t       control->txseq);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tchan->expected_tx_seq = __next_seq(chan,\n\t\t\t\t\t\t\t   control->txseq);\n\n\t\t\tchan->buffer_seq = chan->expected_tx_seq;\n\t\t\tskb_in_use = true;\n\n\t\t\terr = l2cap_reassemble_sdu(chan, skb, control);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\n\t\t\tif (control->final) {\n\t\t\t\tif (!test_and_clear_bit(CONN_REJ_ACT,\n\t\t\t\t\t\t\t&chan->conn_state)) {\n\t\t\t\t\tcontrol->final = 0;\n\t\t\t\t\tl2cap_retransmit_all(chan, control);\n\t\t\t\t\tl2cap_ertm_send(chan);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!test_bit(CONN_LOCAL_BUSY, &chan->conn_state))\n\t\t\t\tl2cap_send_ack(chan);\n\t\t\tbreak;\n\t\tcase L2CAP_TXSEQ_UNEXPECTED:\n\t\t\tl2cap_pass_to_tx(chan, control);\n\n\t\t\t/* Can't issue SREJ frames in the local busy state.\n\t\t\t * Drop this frame, it will be seen as missing\n\t\t\t * when local busy is exited.\n\t\t\t */\n\t\t\tif (test_bit(CONN_LOCAL_BUSY, &chan->conn_state)) {\n\t\t\t\tBT_DBG(\"Busy, discarding unexpected seq %d\",\n\t\t\t\t       control->txseq);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* There was a gap in the sequence, so an SREJ\n\t\t\t * must be sent for each missing frame.  The\n\t\t\t * current frame is stored for later use.\n\t\t\t */\n\t\t\tskb_queue_tail(&chan->srej_q, skb);\n\t\t\tskb_in_use = true;\n\t\t\tBT_DBG(\"Queued %p (queue len %d)\", skb,\n\t\t\t       skb_queue_len(&chan->srej_q));\n\n\t\t\tclear_bit(CONN_SREJ_ACT, &chan->conn_state);\n\t\t\tl2cap_seq_list_clear(&chan->srej_list);\n\t\t\tl2cap_send_srej(chan, control->txseq);\n\n\t\t\tchan->rx_state = L2CAP_RX_STATE_SREJ_SENT;\n\t\t\tbreak;\n\t\tcase L2CAP_TXSEQ_DUPLICATE:\n\t\t\tl2cap_pass_to_tx(chan, control);\n\t\t\tbreak;\n\t\tcase L2CAP_TXSEQ_INVALID_IGNORE:\n\t\t\tbreak;\n\t\tcase L2CAP_TXSEQ_INVALID:\n\t\tdefault:\n\t\t\tl2cap_send_disconn_req(chan, ECONNRESET);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase L2CAP_EV_RECV_RR:\n\t\tl2cap_pass_to_tx(chan, control);\n\t\tif (control->final) {\n\t\t\tclear_bit(CONN_REMOTE_BUSY, &chan->conn_state);\n\n\t\t\tif (!test_and_clear_bit(CONN_REJ_ACT, &chan->conn_state) &&\n\t\t\t    !__chan_is_moving(chan)) {\n\t\t\t\tcontrol->final = 0;\n\t\t\t\tl2cap_retransmit_all(chan, control);\n\t\t\t}\n\n\t\t\tl2cap_ertm_send(chan);\n\t\t} else if (control->poll) {\n\t\t\tl2cap_send_i_or_rr_or_rnr(chan);\n\t\t} else {\n\t\t\tif (test_and_clear_bit(CONN_REMOTE_BUSY,\n\t\t\t\t\t       &chan->conn_state) &&\n\t\t\t    chan->unacked_frames)\n\t\t\t\t__set_retrans_timer(chan);\n\n\t\t\tl2cap_ertm_send(chan);\n\t\t}\n\t\tbreak;\n\tcase L2CAP_EV_RECV_RNR:\n\t\tset_bit(CONN_REMOTE_BUSY, &chan->conn_state);\n\t\tl2cap_pass_to_tx(chan, control);\n\t\tif (control && control->poll) {\n\t\t\tset_bit(CONN_SEND_FBIT, &chan->conn_state);\n\t\t\tl2cap_send_rr_or_rnr(chan, 0);\n\t\t}\n\t\t__clear_retrans_timer(chan);\n\t\tl2cap_seq_list_clear(&chan->retrans_list);\n\t\tbreak;\n\tcase L2CAP_EV_RECV_REJ:\n\t\tl2cap_handle_rej(chan, control);\n\t\tbreak;\n\tcase L2CAP_EV_RECV_SREJ:\n\t\tl2cap_handle_srej(chan, control);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (skb && !skb_in_use) {\n\t\tBT_DBG(\"Freeing %p\", skb);\n\t\tkfree_skb(skb);\n\t}\n\n\treturn err;\n}",
        "code_after_change": "static int l2cap_rx_state_recv(struct l2cap_chan *chan,\n\t\t\t       struct l2cap_ctrl *control,\n\t\t\t       struct sk_buff *skb, u8 event)\n{\n\tstruct l2cap_ctrl local_control;\n\tint err = 0;\n\tbool skb_in_use = false;\n\n\tBT_DBG(\"chan %p, control %p, skb %p, event %d\", chan, control, skb,\n\t       event);\n\n\tswitch (event) {\n\tcase L2CAP_EV_RECV_IFRAME:\n\t\tswitch (l2cap_classify_txseq(chan, control->txseq)) {\n\t\tcase L2CAP_TXSEQ_EXPECTED:\n\t\t\tl2cap_pass_to_tx(chan, control);\n\n\t\t\tif (test_bit(CONN_LOCAL_BUSY, &chan->conn_state)) {\n\t\t\t\tBT_DBG(\"Busy, discarding expected seq %d\",\n\t\t\t\t       control->txseq);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tchan->expected_tx_seq = __next_seq(chan,\n\t\t\t\t\t\t\t   control->txseq);\n\n\t\t\tchan->buffer_seq = chan->expected_tx_seq;\n\t\t\tskb_in_use = true;\n\n\t\t\t/* l2cap_reassemble_sdu may free skb, hence invalidate\n\t\t\t * control, so make a copy in advance to use it after\n\t\t\t * l2cap_reassemble_sdu returns and to avoid the race\n\t\t\t * condition, for example:\n\t\t\t *\n\t\t\t * The current thread calls:\n\t\t\t *   l2cap_reassemble_sdu\n\t\t\t *     chan->ops->recv == l2cap_sock_recv_cb\n\t\t\t *       __sock_queue_rcv_skb\n\t\t\t * Another thread calls:\n\t\t\t *   bt_sock_recvmsg\n\t\t\t *     skb_recv_datagram\n\t\t\t *     skb_free_datagram\n\t\t\t * Then the current thread tries to access control, but\n\t\t\t * it was freed by skb_free_datagram.\n\t\t\t */\n\t\t\tlocal_control = *control;\n\t\t\terr = l2cap_reassemble_sdu(chan, skb, control);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\n\t\t\tif (local_control.final) {\n\t\t\t\tif (!test_and_clear_bit(CONN_REJ_ACT,\n\t\t\t\t\t\t\t&chan->conn_state)) {\n\t\t\t\t\tlocal_control.final = 0;\n\t\t\t\t\tl2cap_retransmit_all(chan, &local_control);\n\t\t\t\t\tl2cap_ertm_send(chan);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!test_bit(CONN_LOCAL_BUSY, &chan->conn_state))\n\t\t\t\tl2cap_send_ack(chan);\n\t\t\tbreak;\n\t\tcase L2CAP_TXSEQ_UNEXPECTED:\n\t\t\tl2cap_pass_to_tx(chan, control);\n\n\t\t\t/* Can't issue SREJ frames in the local busy state.\n\t\t\t * Drop this frame, it will be seen as missing\n\t\t\t * when local busy is exited.\n\t\t\t */\n\t\t\tif (test_bit(CONN_LOCAL_BUSY, &chan->conn_state)) {\n\t\t\t\tBT_DBG(\"Busy, discarding unexpected seq %d\",\n\t\t\t\t       control->txseq);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* There was a gap in the sequence, so an SREJ\n\t\t\t * must be sent for each missing frame.  The\n\t\t\t * current frame is stored for later use.\n\t\t\t */\n\t\t\tskb_queue_tail(&chan->srej_q, skb);\n\t\t\tskb_in_use = true;\n\t\t\tBT_DBG(\"Queued %p (queue len %d)\", skb,\n\t\t\t       skb_queue_len(&chan->srej_q));\n\n\t\t\tclear_bit(CONN_SREJ_ACT, &chan->conn_state);\n\t\t\tl2cap_seq_list_clear(&chan->srej_list);\n\t\t\tl2cap_send_srej(chan, control->txseq);\n\n\t\t\tchan->rx_state = L2CAP_RX_STATE_SREJ_SENT;\n\t\t\tbreak;\n\t\tcase L2CAP_TXSEQ_DUPLICATE:\n\t\t\tl2cap_pass_to_tx(chan, control);\n\t\t\tbreak;\n\t\tcase L2CAP_TXSEQ_INVALID_IGNORE:\n\t\t\tbreak;\n\t\tcase L2CAP_TXSEQ_INVALID:\n\t\tdefault:\n\t\t\tl2cap_send_disconn_req(chan, ECONNRESET);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase L2CAP_EV_RECV_RR:\n\t\tl2cap_pass_to_tx(chan, control);\n\t\tif (control->final) {\n\t\t\tclear_bit(CONN_REMOTE_BUSY, &chan->conn_state);\n\n\t\t\tif (!test_and_clear_bit(CONN_REJ_ACT, &chan->conn_state) &&\n\t\t\t    !__chan_is_moving(chan)) {\n\t\t\t\tcontrol->final = 0;\n\t\t\t\tl2cap_retransmit_all(chan, control);\n\t\t\t}\n\n\t\t\tl2cap_ertm_send(chan);\n\t\t} else if (control->poll) {\n\t\t\tl2cap_send_i_or_rr_or_rnr(chan);\n\t\t} else {\n\t\t\tif (test_and_clear_bit(CONN_REMOTE_BUSY,\n\t\t\t\t\t       &chan->conn_state) &&\n\t\t\t    chan->unacked_frames)\n\t\t\t\t__set_retrans_timer(chan);\n\n\t\t\tl2cap_ertm_send(chan);\n\t\t}\n\t\tbreak;\n\tcase L2CAP_EV_RECV_RNR:\n\t\tset_bit(CONN_REMOTE_BUSY, &chan->conn_state);\n\t\tl2cap_pass_to_tx(chan, control);\n\t\tif (control && control->poll) {\n\t\t\tset_bit(CONN_SEND_FBIT, &chan->conn_state);\n\t\t\tl2cap_send_rr_or_rnr(chan, 0);\n\t\t}\n\t\t__clear_retrans_timer(chan);\n\t\tl2cap_seq_list_clear(&chan->retrans_list);\n\t\tbreak;\n\tcase L2CAP_EV_RECV_REJ:\n\t\tl2cap_handle_rej(chan, control);\n\t\tbreak;\n\tcase L2CAP_EV_RECV_SREJ:\n\t\tl2cap_handle_srej(chan, control);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (skb && !skb_in_use) {\n\t\tBT_DBG(\"Freeing %p\", skb);\n\t\tkfree_skb(skb);\n\t}\n\n\treturn err;\n}",
        "patch": "--- code before\n+++ code after\n@@ -2,6 +2,7 @@\n \t\t\t       struct l2cap_ctrl *control,\n \t\t\t       struct sk_buff *skb, u8 event)\n {\n+\tstruct l2cap_ctrl local_control;\n \tint err = 0;\n \tbool skb_in_use = false;\n \n@@ -26,15 +27,32 @@\n \t\t\tchan->buffer_seq = chan->expected_tx_seq;\n \t\t\tskb_in_use = true;\n \n+\t\t\t/* l2cap_reassemble_sdu may free skb, hence invalidate\n+\t\t\t * control, so make a copy in advance to use it after\n+\t\t\t * l2cap_reassemble_sdu returns and to avoid the race\n+\t\t\t * condition, for example:\n+\t\t\t *\n+\t\t\t * The current thread calls:\n+\t\t\t *   l2cap_reassemble_sdu\n+\t\t\t *     chan->ops->recv == l2cap_sock_recv_cb\n+\t\t\t *       __sock_queue_rcv_skb\n+\t\t\t * Another thread calls:\n+\t\t\t *   bt_sock_recvmsg\n+\t\t\t *     skb_recv_datagram\n+\t\t\t *     skb_free_datagram\n+\t\t\t * Then the current thread tries to access control, but\n+\t\t\t * it was freed by skb_free_datagram.\n+\t\t\t */\n+\t\t\tlocal_control = *control;\n \t\t\terr = l2cap_reassemble_sdu(chan, skb, control);\n \t\t\tif (err)\n \t\t\t\tbreak;\n \n-\t\t\tif (control->final) {\n+\t\t\tif (local_control.final) {\n \t\t\t\tif (!test_and_clear_bit(CONN_REJ_ACT,\n \t\t\t\t\t\t\t&chan->conn_state)) {\n-\t\t\t\t\tcontrol->final = 0;\n-\t\t\t\t\tl2cap_retransmit_all(chan, control);\n+\t\t\t\t\tlocal_control.final = 0;\n+\t\t\t\t\tl2cap_retransmit_all(chan, &local_control);\n \t\t\t\t\tl2cap_ertm_send(chan);\n \t\t\t\t}\n \t\t\t}",
        "function_modified_lines": {
            "added": [
                "\tstruct l2cap_ctrl local_control;",
                "\t\t\t/* l2cap_reassemble_sdu may free skb, hence invalidate",
                "\t\t\t * control, so make a copy in advance to use it after",
                "\t\t\t * l2cap_reassemble_sdu returns and to avoid the race",
                "\t\t\t * condition, for example:",
                "\t\t\t *",
                "\t\t\t * The current thread calls:",
                "\t\t\t *   l2cap_reassemble_sdu",
                "\t\t\t *     chan->ops->recv == l2cap_sock_recv_cb",
                "\t\t\t *       __sock_queue_rcv_skb",
                "\t\t\t * Another thread calls:",
                "\t\t\t *   bt_sock_recvmsg",
                "\t\t\t *     skb_recv_datagram",
                "\t\t\t *     skb_free_datagram",
                "\t\t\t * Then the current thread tries to access control, but",
                "\t\t\t * it was freed by skb_free_datagram.",
                "\t\t\t */",
                "\t\t\tlocal_control = *control;",
                "\t\t\tif (local_control.final) {",
                "\t\t\t\t\tlocal_control.final = 0;",
                "\t\t\t\t\tl2cap_retransmit_all(chan, &local_control);"
            ],
            "deleted": [
                "\t\t\tif (control->final) {",
                "\t\t\t\t\tcontrol->final = 0;",
                "\t\t\t\t\tl2cap_retransmit_all(chan, control);"
            ]
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "A vulnerability classified as critical was found in Linux Kernel. Affected by this vulnerability is the function l2cap_reassemble_sdu of the file net/bluetooth/l2cap_core.c of the component Bluetooth. The manipulation leads to use after free. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-211087.",
        "id": 3636
    },
    {
        "cve_id": "CVE-2022-2590",
        "code_before_change": "static int faultin_page(struct vm_area_struct *vma,\n\t\tunsigned long address, unsigned int *flags, bool unshare,\n\t\tint *locked)\n{\n\tunsigned int fault_flags = 0;\n\tvm_fault_t ret;\n\n\tif (*flags & FOLL_NOFAULT)\n\t\treturn -EFAULT;\n\tif (*flags & FOLL_WRITE)\n\t\tfault_flags |= FAULT_FLAG_WRITE;\n\tif (*flags & FOLL_REMOTE)\n\t\tfault_flags |= FAULT_FLAG_REMOTE;\n\tif (locked)\n\t\tfault_flags |= FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_KILLABLE;\n\tif (*flags & FOLL_NOWAIT)\n\t\tfault_flags |= FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_RETRY_NOWAIT;\n\tif (*flags & FOLL_TRIED) {\n\t\t/*\n\t\t * Note: FAULT_FLAG_ALLOW_RETRY and FAULT_FLAG_TRIED\n\t\t * can co-exist\n\t\t */\n\t\tfault_flags |= FAULT_FLAG_TRIED;\n\t}\n\tif (unshare) {\n\t\tfault_flags |= FAULT_FLAG_UNSHARE;\n\t\t/* FAULT_FLAG_WRITE and FAULT_FLAG_UNSHARE are incompatible */\n\t\tVM_BUG_ON(fault_flags & FAULT_FLAG_WRITE);\n\t}\n\n\tret = handle_mm_fault(vma, address, fault_flags, NULL);\n\n\tif (ret & VM_FAULT_COMPLETED) {\n\t\t/*\n\t\t * With FAULT_FLAG_RETRY_NOWAIT we'll never release the\n\t\t * mmap lock in the page fault handler. Sanity check this.\n\t\t */\n\t\tWARN_ON_ONCE(fault_flags & FAULT_FLAG_RETRY_NOWAIT);\n\t\tif (locked)\n\t\t\t*locked = 0;\n\t\t/*\n\t\t * We should do the same as VM_FAULT_RETRY, but let's not\n\t\t * return -EBUSY since that's not reflecting the reality of\n\t\t * what has happened - we've just fully completed a page\n\t\t * fault, with the mmap lock released.  Use -EAGAIN to show\n\t\t * that we want to take the mmap lock _again_.\n\t\t */\n\t\treturn -EAGAIN;\n\t}\n\n\tif (ret & VM_FAULT_ERROR) {\n\t\tint err = vm_fault_to_errno(ret, *flags);\n\n\t\tif (err)\n\t\t\treturn err;\n\t\tBUG();\n\t}\n\n\tif (ret & VM_FAULT_RETRY) {\n\t\tif (locked && !(fault_flags & FAULT_FLAG_RETRY_NOWAIT))\n\t\t\t*locked = 0;\n\t\treturn -EBUSY;\n\t}\n\n\t/*\n\t * The VM_FAULT_WRITE bit tells us that do_wp_page has broken COW when\n\t * necessary, even if maybe_mkwrite decided not to set pte_write. We\n\t * can thus safely do subsequent page lookups as if they were reads.\n\t * But only do so when looping for pte_write is futile: in some cases\n\t * userspace may also be wanting to write to the gotten user page,\n\t * which a read fault here might prevent (a readonly page might get\n\t * reCOWed by userspace write).\n\t */\n\tif ((ret & VM_FAULT_WRITE) && !(vma->vm_flags & VM_WRITE))\n\t\t*flags |= FOLL_COW;\n\treturn 0;\n}",
        "code_after_change": "static int faultin_page(struct vm_area_struct *vma,\n\t\tunsigned long address, unsigned int *flags, bool unshare,\n\t\tint *locked)\n{\n\tunsigned int fault_flags = 0;\n\tvm_fault_t ret;\n\n\tif (*flags & FOLL_NOFAULT)\n\t\treturn -EFAULT;\n\tif (*flags & FOLL_WRITE)\n\t\tfault_flags |= FAULT_FLAG_WRITE;\n\tif (*flags & FOLL_REMOTE)\n\t\tfault_flags |= FAULT_FLAG_REMOTE;\n\tif (locked)\n\t\tfault_flags |= FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_KILLABLE;\n\tif (*flags & FOLL_NOWAIT)\n\t\tfault_flags |= FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_RETRY_NOWAIT;\n\tif (*flags & FOLL_TRIED) {\n\t\t/*\n\t\t * Note: FAULT_FLAG_ALLOW_RETRY and FAULT_FLAG_TRIED\n\t\t * can co-exist\n\t\t */\n\t\tfault_flags |= FAULT_FLAG_TRIED;\n\t}\n\tif (unshare) {\n\t\tfault_flags |= FAULT_FLAG_UNSHARE;\n\t\t/* FAULT_FLAG_WRITE and FAULT_FLAG_UNSHARE are incompatible */\n\t\tVM_BUG_ON(fault_flags & FAULT_FLAG_WRITE);\n\t}\n\n\tret = handle_mm_fault(vma, address, fault_flags, NULL);\n\n\tif (ret & VM_FAULT_COMPLETED) {\n\t\t/*\n\t\t * With FAULT_FLAG_RETRY_NOWAIT we'll never release the\n\t\t * mmap lock in the page fault handler. Sanity check this.\n\t\t */\n\t\tWARN_ON_ONCE(fault_flags & FAULT_FLAG_RETRY_NOWAIT);\n\t\tif (locked)\n\t\t\t*locked = 0;\n\t\t/*\n\t\t * We should do the same as VM_FAULT_RETRY, but let's not\n\t\t * return -EBUSY since that's not reflecting the reality of\n\t\t * what has happened - we've just fully completed a page\n\t\t * fault, with the mmap lock released.  Use -EAGAIN to show\n\t\t * that we want to take the mmap lock _again_.\n\t\t */\n\t\treturn -EAGAIN;\n\t}\n\n\tif (ret & VM_FAULT_ERROR) {\n\t\tint err = vm_fault_to_errno(ret, *flags);\n\n\t\tif (err)\n\t\t\treturn err;\n\t\tBUG();\n\t}\n\n\tif (ret & VM_FAULT_RETRY) {\n\t\tif (locked && !(fault_flags & FAULT_FLAG_RETRY_NOWAIT))\n\t\t\t*locked = 0;\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -62,16 +62,5 @@\n \t\treturn -EBUSY;\n \t}\n \n-\t/*\n-\t * The VM_FAULT_WRITE bit tells us that do_wp_page has broken COW when\n-\t * necessary, even if maybe_mkwrite decided not to set pte_write. We\n-\t * can thus safely do subsequent page lookups as if they were reads.\n-\t * But only do so when looping for pte_write is futile: in some cases\n-\t * userspace may also be wanting to write to the gotten user page,\n-\t * which a read fault here might prevent (a readonly page might get\n-\t * reCOWed by userspace write).\n-\t */\n-\tif ((ret & VM_FAULT_WRITE) && !(vma->vm_flags & VM_WRITE))\n-\t\t*flags |= FOLL_COW;\n \treturn 0;\n }",
        "function_modified_lines": {
            "added": [],
            "deleted": [
                "\t/*",
                "\t * The VM_FAULT_WRITE bit tells us that do_wp_page has broken COW when",
                "\t * necessary, even if maybe_mkwrite decided not to set pte_write. We",
                "\t * can thus safely do subsequent page lookups as if they were reads.",
                "\t * But only do so when looping for pte_write is futile: in some cases",
                "\t * userspace may also be wanting to write to the gotten user page,",
                "\t * which a read fault here might prevent (a readonly page might get",
                "\t * reCOWed by userspace write).",
                "\t */",
                "\tif ((ret & VM_FAULT_WRITE) && !(vma->vm_flags & VM_WRITE))",
                "\t\t*flags |= FOLL_COW;"
            ]
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "A race condition was found in the way the Linux kernel's memory subsystem handled the copy-on-write (COW) breakage of private read-only shared memory mappings. This flaw allows an unprivileged, local user to gain write access to read-only memory mappings, increasing their privileges on the system.",
        "id": 3480
    },
    {
        "cve_id": "CVE-2022-2590",
        "code_before_change": "struct page *follow_devmap_pmd(struct vm_area_struct *vma, unsigned long addr,\n\t\tpmd_t *pmd, int flags, struct dev_pagemap **pgmap)\n{\n\tunsigned long pfn = pmd_pfn(*pmd);\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct page *page;\n\n\tassert_spin_locked(pmd_lockptr(mm, pmd));\n\n\t/*\n\t * When we COW a devmap PMD entry, we split it into PTEs, so we should\n\t * not be in this function with `flags & FOLL_COW` set.\n\t */\n\tWARN_ONCE(flags & FOLL_COW, \"mm: In follow_devmap_pmd with FOLL_COW set\");\n\n\t/* FOLL_GET and FOLL_PIN are mutually exclusive. */\n\tif (WARN_ON_ONCE((flags & (FOLL_PIN | FOLL_GET)) ==\n\t\t\t (FOLL_PIN | FOLL_GET)))\n\t\treturn NULL;\n\n\tif (flags & FOLL_WRITE && !pmd_write(*pmd))\n\t\treturn NULL;\n\n\tif (pmd_present(*pmd) && pmd_devmap(*pmd))\n\t\t/* pass */;\n\telse\n\t\treturn NULL;\n\n\tif (flags & FOLL_TOUCH)\n\t\ttouch_pmd(vma, addr, pmd, flags & FOLL_WRITE);\n\n\t/*\n\t * device mapped pages can only be returned if the\n\t * caller will manage the page reference count.\n\t */\n\tif (!(flags & (FOLL_GET | FOLL_PIN)))\n\t\treturn ERR_PTR(-EEXIST);\n\n\tpfn += (addr & ~PMD_MASK) >> PAGE_SHIFT;\n\t*pgmap = get_dev_pagemap(pfn, *pgmap);\n\tif (!*pgmap)\n\t\treturn ERR_PTR(-EFAULT);\n\tpage = pfn_to_page(pfn);\n\tif (!try_grab_page(page, flags))\n\t\tpage = ERR_PTR(-ENOMEM);\n\n\treturn page;\n}",
        "code_after_change": "struct page *follow_devmap_pmd(struct vm_area_struct *vma, unsigned long addr,\n\t\tpmd_t *pmd, int flags, struct dev_pagemap **pgmap)\n{\n\tunsigned long pfn = pmd_pfn(*pmd);\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct page *page;\n\n\tassert_spin_locked(pmd_lockptr(mm, pmd));\n\n\t/* FOLL_GET and FOLL_PIN are mutually exclusive. */\n\tif (WARN_ON_ONCE((flags & (FOLL_PIN | FOLL_GET)) ==\n\t\t\t (FOLL_PIN | FOLL_GET)))\n\t\treturn NULL;\n\n\tif (flags & FOLL_WRITE && !pmd_write(*pmd))\n\t\treturn NULL;\n\n\tif (pmd_present(*pmd) && pmd_devmap(*pmd))\n\t\t/* pass */;\n\telse\n\t\treturn NULL;\n\n\tif (flags & FOLL_TOUCH)\n\t\ttouch_pmd(vma, addr, pmd, flags & FOLL_WRITE);\n\n\t/*\n\t * device mapped pages can only be returned if the\n\t * caller will manage the page reference count.\n\t */\n\tif (!(flags & (FOLL_GET | FOLL_PIN)))\n\t\treturn ERR_PTR(-EEXIST);\n\n\tpfn += (addr & ~PMD_MASK) >> PAGE_SHIFT;\n\t*pgmap = get_dev_pagemap(pfn, *pgmap);\n\tif (!*pgmap)\n\t\treturn ERR_PTR(-EFAULT);\n\tpage = pfn_to_page(pfn);\n\tif (!try_grab_page(page, flags))\n\t\tpage = ERR_PTR(-ENOMEM);\n\n\treturn page;\n}",
        "patch": "--- code before\n+++ code after\n@@ -6,12 +6,6 @@\n \tstruct page *page;\n \n \tassert_spin_locked(pmd_lockptr(mm, pmd));\n-\n-\t/*\n-\t * When we COW a devmap PMD entry, we split it into PTEs, so we should\n-\t * not be in this function with `flags & FOLL_COW` set.\n-\t */\n-\tWARN_ONCE(flags & FOLL_COW, \"mm: In follow_devmap_pmd with FOLL_COW set\");\n \n \t/* FOLL_GET and FOLL_PIN are mutually exclusive. */\n \tif (WARN_ON_ONCE((flags & (FOLL_PIN | FOLL_GET)) ==",
        "function_modified_lines": {
            "added": [],
            "deleted": [
                "",
                "\t/*",
                "\t * When we COW a devmap PMD entry, we split it into PTEs, so we should",
                "\t * not be in this function with `flags & FOLL_COW` set.",
                "\t */",
                "\tWARN_ONCE(flags & FOLL_COW, \"mm: In follow_devmap_pmd with FOLL_COW set\");"
            ]
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "A race condition was found in the way the Linux kernel's memory subsystem handled the copy-on-write (COW) breakage of private read-only shared memory mappings. This flaw allows an unprivileged, local user to gain write access to read-only memory mappings, increasing their privileges on the system.",
        "id": 3481
    },
    {
        "cve_id": "CVE-2022-3623",
        "code_before_change": "static struct page *follow_page_pte(struct vm_area_struct *vma,\n\t\tunsigned long address, pmd_t *pmd, unsigned int flags,\n\t\tstruct dev_pagemap **pgmap)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct page *page;\n\tspinlock_t *ptl;\n\tpte_t *ptep, pte;\n\tint ret;\n\n\t/* FOLL_GET and FOLL_PIN are mutually exclusive. */\n\tif (WARN_ON_ONCE((flags & (FOLL_PIN | FOLL_GET)) ==\n\t\t\t (FOLL_PIN | FOLL_GET)))\n\t\treturn ERR_PTR(-EINVAL);\nretry:\n\tif (unlikely(pmd_bad(*pmd)))\n\t\treturn no_page_table(vma, flags);\n\n\tptep = pte_offset_map_lock(mm, pmd, address, &ptl);\n\tpte = *ptep;\n\tif (!pte_present(pte)) {\n\t\tswp_entry_t entry;\n\t\t/*\n\t\t * KSM's break_ksm() relies upon recognizing a ksm page\n\t\t * even while it is being migrated, so for that case we\n\t\t * need migration_entry_wait().\n\t\t */\n\t\tif (likely(!(flags & FOLL_MIGRATION)))\n\t\t\tgoto no_page;\n\t\tif (pte_none(pte))\n\t\t\tgoto no_page;\n\t\tentry = pte_to_swp_entry(pte);\n\t\tif (!is_migration_entry(entry))\n\t\t\tgoto no_page;\n\t\tpte_unmap_unlock(ptep, ptl);\n\t\tmigration_entry_wait(mm, pmd, address);\n\t\tgoto retry;\n\t}\n\tif ((flags & FOLL_NUMA) && pte_protnone(pte))\n\t\tgoto no_page;\n\n\tpage = vm_normal_page(vma, address, pte);\n\n\t/*\n\t * We only care about anon pages in can_follow_write_pte() and don't\n\t * have to worry about pte_devmap() because they are never anon.\n\t */\n\tif ((flags & FOLL_WRITE) &&\n\t    !can_follow_write_pte(pte, page, vma, flags)) {\n\t\tpage = NULL;\n\t\tgoto out;\n\t}\n\n\tif (!page && pte_devmap(pte) && (flags & (FOLL_GET | FOLL_PIN))) {\n\t\t/*\n\t\t * Only return device mapping pages in the FOLL_GET or FOLL_PIN\n\t\t * case since they are only valid while holding the pgmap\n\t\t * reference.\n\t\t */\n\t\t*pgmap = get_dev_pagemap(pte_pfn(pte), *pgmap);\n\t\tif (*pgmap)\n\t\t\tpage = pte_page(pte);\n\t\telse\n\t\t\tgoto no_page;\n\t} else if (unlikely(!page)) {\n\t\tif (flags & FOLL_DUMP) {\n\t\t\t/* Avoid special (like zero) pages in core dumps */\n\t\t\tpage = ERR_PTR(-EFAULT);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (is_zero_pfn(pte_pfn(pte))) {\n\t\t\tpage = pte_page(pte);\n\t\t} else {\n\t\t\tret = follow_pfn_pte(vma, address, ptep, flags);\n\t\t\tpage = ERR_PTR(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!pte_write(pte) && gup_must_unshare(flags, page)) {\n\t\tpage = ERR_PTR(-EMLINK);\n\t\tgoto out;\n\t}\n\n\tVM_BUG_ON_PAGE((flags & FOLL_PIN) && PageAnon(page) &&\n\t\t       !PageAnonExclusive(page), page);\n\n\t/* try_grab_page() does nothing unless FOLL_GET or FOLL_PIN is set. */\n\tif (unlikely(!try_grab_page(page, flags))) {\n\t\tpage = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\t/*\n\t * We need to make the page accessible if and only if we are going\n\t * to access its content (the FOLL_PIN case).  Please see\n\t * Documentation/core-api/pin_user_pages.rst for details.\n\t */\n\tif (flags & FOLL_PIN) {\n\t\tret = arch_make_page_accessible(page);\n\t\tif (ret) {\n\t\t\tunpin_user_page(page);\n\t\t\tpage = ERR_PTR(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (flags & FOLL_TOUCH) {\n\t\tif ((flags & FOLL_WRITE) &&\n\t\t    !pte_dirty(pte) && !PageDirty(page))\n\t\t\tset_page_dirty(page);\n\t\t/*\n\t\t * pte_mkyoung() would be more correct here, but atomic care\n\t\t * is needed to avoid losing the dirty bit: it is easier to use\n\t\t * mark_page_accessed().\n\t\t */\n\t\tmark_page_accessed(page);\n\t}\nout:\n\tpte_unmap_unlock(ptep, ptl);\n\treturn page;\nno_page:\n\tpte_unmap_unlock(ptep, ptl);\n\tif (!pte_none(pte))\n\t\treturn NULL;\n\treturn no_page_table(vma, flags);\n}",
        "code_after_change": "static struct page *follow_page_pte(struct vm_area_struct *vma,\n\t\tunsigned long address, pmd_t *pmd, unsigned int flags,\n\t\tstruct dev_pagemap **pgmap)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct page *page;\n\tspinlock_t *ptl;\n\tpte_t *ptep, pte;\n\tint ret;\n\n\t/* FOLL_GET and FOLL_PIN are mutually exclusive. */\n\tif (WARN_ON_ONCE((flags & (FOLL_PIN | FOLL_GET)) ==\n\t\t\t (FOLL_PIN | FOLL_GET)))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/*\n\t * Considering PTE level hugetlb, like continuous-PTE hugetlb on\n\t * ARM64 architecture.\n\t */\n\tif (is_vm_hugetlb_page(vma)) {\n\t\tpage = follow_huge_pmd_pte(vma, address, flags);\n\t\tif (page)\n\t\t\treturn page;\n\t\treturn no_page_table(vma, flags);\n\t}\n\nretry:\n\tif (unlikely(pmd_bad(*pmd)))\n\t\treturn no_page_table(vma, flags);\n\n\tptep = pte_offset_map_lock(mm, pmd, address, &ptl);\n\tpte = *ptep;\n\tif (!pte_present(pte)) {\n\t\tswp_entry_t entry;\n\t\t/*\n\t\t * KSM's break_ksm() relies upon recognizing a ksm page\n\t\t * even while it is being migrated, so for that case we\n\t\t * need migration_entry_wait().\n\t\t */\n\t\tif (likely(!(flags & FOLL_MIGRATION)))\n\t\t\tgoto no_page;\n\t\tif (pte_none(pte))\n\t\t\tgoto no_page;\n\t\tentry = pte_to_swp_entry(pte);\n\t\tif (!is_migration_entry(entry))\n\t\t\tgoto no_page;\n\t\tpte_unmap_unlock(ptep, ptl);\n\t\tmigration_entry_wait(mm, pmd, address);\n\t\tgoto retry;\n\t}\n\tif ((flags & FOLL_NUMA) && pte_protnone(pte))\n\t\tgoto no_page;\n\n\tpage = vm_normal_page(vma, address, pte);\n\n\t/*\n\t * We only care about anon pages in can_follow_write_pte() and don't\n\t * have to worry about pte_devmap() because they are never anon.\n\t */\n\tif ((flags & FOLL_WRITE) &&\n\t    !can_follow_write_pte(pte, page, vma, flags)) {\n\t\tpage = NULL;\n\t\tgoto out;\n\t}\n\n\tif (!page && pte_devmap(pte) && (flags & (FOLL_GET | FOLL_PIN))) {\n\t\t/*\n\t\t * Only return device mapping pages in the FOLL_GET or FOLL_PIN\n\t\t * case since they are only valid while holding the pgmap\n\t\t * reference.\n\t\t */\n\t\t*pgmap = get_dev_pagemap(pte_pfn(pte), *pgmap);\n\t\tif (*pgmap)\n\t\t\tpage = pte_page(pte);\n\t\telse\n\t\t\tgoto no_page;\n\t} else if (unlikely(!page)) {\n\t\tif (flags & FOLL_DUMP) {\n\t\t\t/* Avoid special (like zero) pages in core dumps */\n\t\t\tpage = ERR_PTR(-EFAULT);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (is_zero_pfn(pte_pfn(pte))) {\n\t\t\tpage = pte_page(pte);\n\t\t} else {\n\t\t\tret = follow_pfn_pte(vma, address, ptep, flags);\n\t\t\tpage = ERR_PTR(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!pte_write(pte) && gup_must_unshare(flags, page)) {\n\t\tpage = ERR_PTR(-EMLINK);\n\t\tgoto out;\n\t}\n\n\tVM_BUG_ON_PAGE((flags & FOLL_PIN) && PageAnon(page) &&\n\t\t       !PageAnonExclusive(page), page);\n\n\t/* try_grab_page() does nothing unless FOLL_GET or FOLL_PIN is set. */\n\tif (unlikely(!try_grab_page(page, flags))) {\n\t\tpage = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\t/*\n\t * We need to make the page accessible if and only if we are going\n\t * to access its content (the FOLL_PIN case).  Please see\n\t * Documentation/core-api/pin_user_pages.rst for details.\n\t */\n\tif (flags & FOLL_PIN) {\n\t\tret = arch_make_page_accessible(page);\n\t\tif (ret) {\n\t\t\tunpin_user_page(page);\n\t\t\tpage = ERR_PTR(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (flags & FOLL_TOUCH) {\n\t\tif ((flags & FOLL_WRITE) &&\n\t\t    !pte_dirty(pte) && !PageDirty(page))\n\t\t\tset_page_dirty(page);\n\t\t/*\n\t\t * pte_mkyoung() would be more correct here, but atomic care\n\t\t * is needed to avoid losing the dirty bit: it is easier to use\n\t\t * mark_page_accessed().\n\t\t */\n\t\tmark_page_accessed(page);\n\t}\nout:\n\tpte_unmap_unlock(ptep, ptl);\n\treturn page;\nno_page:\n\tpte_unmap_unlock(ptep, ptl);\n\tif (!pte_none(pte))\n\t\treturn NULL;\n\treturn no_page_table(vma, flags);\n}",
        "patch": "--- code before\n+++ code after\n@@ -12,6 +12,18 @@\n \tif (WARN_ON_ONCE((flags & (FOLL_PIN | FOLL_GET)) ==\n \t\t\t (FOLL_PIN | FOLL_GET)))\n \t\treturn ERR_PTR(-EINVAL);\n+\n+\t/*\n+\t * Considering PTE level hugetlb, like continuous-PTE hugetlb on\n+\t * ARM64 architecture.\n+\t */\n+\tif (is_vm_hugetlb_page(vma)) {\n+\t\tpage = follow_huge_pmd_pte(vma, address, flags);\n+\t\tif (page)\n+\t\t\treturn page;\n+\t\treturn no_page_table(vma, flags);\n+\t}\n+\n retry:\n \tif (unlikely(pmd_bad(*pmd)))\n \t\treturn no_page_table(vma, flags);",
        "function_modified_lines": {
            "added": [
                "",
                "\t/*",
                "\t * Considering PTE level hugetlb, like continuous-PTE hugetlb on",
                "\t * ARM64 architecture.",
                "\t */",
                "\tif (is_vm_hugetlb_page(vma)) {",
                "\t\tpage = follow_huge_pmd_pte(vma, address, flags);",
                "\t\tif (page)",
                "\t\t\treturn page;",
                "\t\treturn no_page_table(vma, flags);",
                "\t}",
                ""
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "A vulnerability was found in Linux Kernel. It has been declared as problematic. Affected by this vulnerability is the function follow_page_pte of the file mm/gup.c of the component BPF. The manipulation leads to race condition. The attack can be launched remotely. It is recommended to apply a patch to fix this issue. The identifier VDB-211921 was assigned to this vulnerability.",
        "id": 3657
    },
    {
        "cve_id": "CVE-2021-0920",
        "code_before_change": "static int unix_dgram_recvmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t      size_t size, int flags)\n{\n\tstruct scm_cookie scm;\n\tstruct sock *sk = sock->sk;\n\tstruct unix_sock *u = unix_sk(sk);\n\tstruct sk_buff *skb, *last;\n\tlong timeo;\n\tint skip;\n\tint err;\n\n\terr = -EOPNOTSUPP;\n\tif (flags&MSG_OOB)\n\t\tgoto out;\n\n\ttimeo = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);\n\n\tdo {\n\t\tmutex_lock(&u->iolock);\n\n\t\tskip = sk_peek_offset(sk, flags);\n\t\tskb = __skb_try_recv_datagram(sk, &sk->sk_receive_queue, flags,\n\t\t\t\t\t      &skip, &err, &last);\n\t\tif (skb) {\n\t\t\tif (!(flags & MSG_PEEK))\n\t\t\t\tscm_stat_del(sk, skb);\n\t\t\tbreak;\n\t\t}\n\n\t\tmutex_unlock(&u->iolock);\n\n\t\tif (err != -EAGAIN)\n\t\t\tbreak;\n\t} while (timeo &&\n\t\t !__skb_wait_for_more_packets(sk, &sk->sk_receive_queue,\n\t\t\t\t\t      &err, &timeo, last));\n\n\tif (!skb) { /* implies iolock unlocked */\n\t\tunix_state_lock(sk);\n\t\t/* Signal EOF on disconnected non-blocking SEQPACKET socket. */\n\t\tif (sk->sk_type == SOCK_SEQPACKET && err == -EAGAIN &&\n\t\t    (sk->sk_shutdown & RCV_SHUTDOWN))\n\t\t\terr = 0;\n\t\tunix_state_unlock(sk);\n\t\tgoto out;\n\t}\n\n\tif (wq_has_sleeper(&u->peer_wait))\n\t\twake_up_interruptible_sync_poll(&u->peer_wait,\n\t\t\t\t\t\tEPOLLOUT | EPOLLWRNORM |\n\t\t\t\t\t\tEPOLLWRBAND);\n\n\tif (msg->msg_name)\n\t\tunix_copy_addr(msg, skb->sk);\n\n\tif (size > skb->len - skip)\n\t\tsize = skb->len - skip;\n\telse if (size < skb->len - skip)\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\n\terr = skb_copy_datagram_msg(skb, skip, msg, size);\n\tif (err)\n\t\tgoto out_free;\n\n\tif (sock_flag(sk, SOCK_RCVTSTAMP))\n\t\t__sock_recv_timestamp(msg, sk, skb);\n\n\tmemset(&scm, 0, sizeof(scm));\n\n\tscm_set_cred(&scm, UNIXCB(skb).pid, UNIXCB(skb).uid, UNIXCB(skb).gid);\n\tunix_set_secdata(&scm, skb);\n\n\tif (!(flags & MSG_PEEK)) {\n\t\tif (UNIXCB(skb).fp)\n\t\t\tunix_detach_fds(&scm, skb);\n\n\t\tsk_peek_offset_bwd(sk, skb->len);\n\t} else {\n\t\t/* It is questionable: on PEEK we could:\n\t\t   - do not return fds - good, but too simple 8)\n\t\t   - return fds, and do not return them on read (old strategy,\n\t\t     apparently wrong)\n\t\t   - clone fds (I chose it for now, it is the most universal\n\t\t     solution)\n\n\t\t   POSIX 1003.1g does not actually define this clearly\n\t\t   at all. POSIX 1003.1g doesn't define a lot of things\n\t\t   clearly however!\n\n\t\t*/\n\n\t\tsk_peek_offset_fwd(sk, size);\n\n\t\tif (UNIXCB(skb).fp)\n\t\t\tscm.fp = scm_fp_dup(UNIXCB(skb).fp);\n\t}\n\terr = (flags & MSG_TRUNC) ? skb->len - skip : size;\n\n\tscm_recv(sock, msg, &scm, flags);\n\nout_free:\n\tskb_free_datagram(sk, skb);\n\tmutex_unlock(&u->iolock);\nout:\n\treturn err;\n}",
        "code_after_change": "static int unix_dgram_recvmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t      size_t size, int flags)\n{\n\tstruct scm_cookie scm;\n\tstruct sock *sk = sock->sk;\n\tstruct unix_sock *u = unix_sk(sk);\n\tstruct sk_buff *skb, *last;\n\tlong timeo;\n\tint skip;\n\tint err;\n\n\terr = -EOPNOTSUPP;\n\tif (flags&MSG_OOB)\n\t\tgoto out;\n\n\ttimeo = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);\n\n\tdo {\n\t\tmutex_lock(&u->iolock);\n\n\t\tskip = sk_peek_offset(sk, flags);\n\t\tskb = __skb_try_recv_datagram(sk, &sk->sk_receive_queue, flags,\n\t\t\t\t\t      &skip, &err, &last);\n\t\tif (skb) {\n\t\t\tif (!(flags & MSG_PEEK))\n\t\t\t\tscm_stat_del(sk, skb);\n\t\t\tbreak;\n\t\t}\n\n\t\tmutex_unlock(&u->iolock);\n\n\t\tif (err != -EAGAIN)\n\t\t\tbreak;\n\t} while (timeo &&\n\t\t !__skb_wait_for_more_packets(sk, &sk->sk_receive_queue,\n\t\t\t\t\t      &err, &timeo, last));\n\n\tif (!skb) { /* implies iolock unlocked */\n\t\tunix_state_lock(sk);\n\t\t/* Signal EOF on disconnected non-blocking SEQPACKET socket. */\n\t\tif (sk->sk_type == SOCK_SEQPACKET && err == -EAGAIN &&\n\t\t    (sk->sk_shutdown & RCV_SHUTDOWN))\n\t\t\terr = 0;\n\t\tunix_state_unlock(sk);\n\t\tgoto out;\n\t}\n\n\tif (wq_has_sleeper(&u->peer_wait))\n\t\twake_up_interruptible_sync_poll(&u->peer_wait,\n\t\t\t\t\t\tEPOLLOUT | EPOLLWRNORM |\n\t\t\t\t\t\tEPOLLWRBAND);\n\n\tif (msg->msg_name)\n\t\tunix_copy_addr(msg, skb->sk);\n\n\tif (size > skb->len - skip)\n\t\tsize = skb->len - skip;\n\telse if (size < skb->len - skip)\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\n\terr = skb_copy_datagram_msg(skb, skip, msg, size);\n\tif (err)\n\t\tgoto out_free;\n\n\tif (sock_flag(sk, SOCK_RCVTSTAMP))\n\t\t__sock_recv_timestamp(msg, sk, skb);\n\n\tmemset(&scm, 0, sizeof(scm));\n\n\tscm_set_cred(&scm, UNIXCB(skb).pid, UNIXCB(skb).uid, UNIXCB(skb).gid);\n\tunix_set_secdata(&scm, skb);\n\n\tif (!(flags & MSG_PEEK)) {\n\t\tif (UNIXCB(skb).fp)\n\t\t\tunix_detach_fds(&scm, skb);\n\n\t\tsk_peek_offset_bwd(sk, skb->len);\n\t} else {\n\t\t/* It is questionable: on PEEK we could:\n\t\t   - do not return fds - good, but too simple 8)\n\t\t   - return fds, and do not return them on read (old strategy,\n\t\t     apparently wrong)\n\t\t   - clone fds (I chose it for now, it is the most universal\n\t\t     solution)\n\n\t\t   POSIX 1003.1g does not actually define this clearly\n\t\t   at all. POSIX 1003.1g doesn't define a lot of things\n\t\t   clearly however!\n\n\t\t*/\n\n\t\tsk_peek_offset_fwd(sk, size);\n\n\t\tif (UNIXCB(skb).fp)\n\t\t\tunix_peek_fds(&scm, skb);\n\t}\n\terr = (flags & MSG_TRUNC) ? skb->len - skip : size;\n\n\tscm_recv(sock, msg, &scm, flags);\n\nout_free:\n\tskb_free_datagram(sk, skb);\n\tmutex_unlock(&u->iolock);\nout:\n\treturn err;\n}",
        "patch": "--- code before\n+++ code after\n@@ -92,7 +92,7 @@\n \t\tsk_peek_offset_fwd(sk, size);\n \n \t\tif (UNIXCB(skb).fp)\n-\t\t\tscm.fp = scm_fp_dup(UNIXCB(skb).fp);\n+\t\t\tunix_peek_fds(&scm, skb);\n \t}\n \terr = (flags & MSG_TRUNC) ? skb->len - skip : size;\n ",
        "function_modified_lines": {
            "added": [
                "\t\t\tunix_peek_fds(&scm, skb);"
            ],
            "deleted": [
                "\t\t\tscm.fp = scm_fp_dup(UNIXCB(skb).fp);"
            ]
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "In unix_scm_to_skb of af_unix.c, there is a possible use after free bug due to a race condition. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-196926917References: Upstream kernel",
        "id": 2831
    },
    {
        "cve_id": "CVE-2015-8963",
        "code_before_change": "static int swevent_hlist_get_cpu(struct perf_event *event, int cpu)\n{\n\tstruct swevent_htable *swhash = &per_cpu(swevent_htable, cpu);\n\tint err = 0;\n\n\tmutex_lock(&swhash->hlist_mutex);\n\n\tif (!swevent_hlist_deref(swhash) && cpu_online(cpu)) {\n\t\tstruct swevent_hlist *hlist;\n\n\t\thlist = kzalloc(sizeof(*hlist), GFP_KERNEL);\n\t\tif (!hlist) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto exit;\n\t\t}\n\t\trcu_assign_pointer(swhash->swevent_hlist, hlist);\n\t}\n\tswhash->hlist_refcount++;\nexit:\n\tmutex_unlock(&swhash->hlist_mutex);\n\n\treturn err;\n}",
        "code_after_change": "static int swevent_hlist_get_cpu(struct perf_event *event, int cpu)\n{\n\tstruct swevent_htable *swhash = &per_cpu(swevent_htable, cpu);\n\tint err = 0;\n\n\tmutex_lock(&swhash->hlist_mutex);\n\tif (!swevent_hlist_deref(swhash) && cpu_online(cpu)) {\n\t\tstruct swevent_hlist *hlist;\n\n\t\thlist = kzalloc(sizeof(*hlist), GFP_KERNEL);\n\t\tif (!hlist) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto exit;\n\t\t}\n\t\trcu_assign_pointer(swhash->swevent_hlist, hlist);\n\t}\n\tswhash->hlist_refcount++;\nexit:\n\tmutex_unlock(&swhash->hlist_mutex);\n\n\treturn err;\n}",
        "patch": "--- code before\n+++ code after\n@@ -4,7 +4,6 @@\n \tint err = 0;\n \n \tmutex_lock(&swhash->hlist_mutex);\n-\n \tif (!swevent_hlist_deref(swhash) && cpu_online(cpu)) {\n \t\tstruct swevent_hlist *hlist;\n ",
        "function_modified_lines": {
            "added": [],
            "deleted": [
                ""
            ]
        },
        "cwe": [
            "CWE-362",
            "CWE-416"
        ],
        "cve_description": "Race condition in kernel/events/core.c in the Linux kernel before 4.4 allows local users to gain privileges or cause a denial of service (use-after-free) by leveraging incorrect handling of an swevent data structure during a CPU unplug operation.",
        "id": 873
    },
    {
        "cve_id": "CVE-2019-13233",
        "code_before_change": "int insn_get_code_seg_params(struct pt_regs *regs)\n{\n\tstruct desc_struct *desc;\n\tshort sel;\n\n\tif (v8086_mode(regs))\n\t\t/* Address and operand size are both 16-bit. */\n\t\treturn INSN_CODE_SEG_PARAMS(2, 2);\n\n\tsel = get_segment_selector(regs, INAT_SEG_REG_CS);\n\tif (sel < 0)\n\t\treturn sel;\n\n\tdesc = get_desc(sel);\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\t/*\n\t * The most significant byte of the Type field of the segment descriptor\n\t * determines whether a segment contains data or code. If this is a data\n\t * segment, return error.\n\t */\n\tif (!(desc->type & BIT(3)))\n\t\treturn -EINVAL;\n\n\tswitch ((desc->l << 1) | desc->d) {\n\tcase 0: /*\n\t\t * Legacy mode. CS.L=0, CS.D=0. Address and operand size are\n\t\t * both 16-bit.\n\t\t */\n\t\treturn INSN_CODE_SEG_PARAMS(2, 2);\n\tcase 1: /*\n\t\t * Legacy mode. CS.L=0, CS.D=1. Address and operand size are\n\t\t * both 32-bit.\n\t\t */\n\t\treturn INSN_CODE_SEG_PARAMS(4, 4);\n\tcase 2: /*\n\t\t * IA-32e 64-bit mode. CS.L=1, CS.D=0. Address size is 64-bit;\n\t\t * operand size is 32-bit.\n\t\t */\n\t\treturn INSN_CODE_SEG_PARAMS(4, 8);\n\tcase 3: /* Invalid setting. CS.L=1, CS.D=1 */\n\t\t/* fall through */\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}",
        "code_after_change": "int insn_get_code_seg_params(struct pt_regs *regs)\n{\n\tstruct desc_struct desc;\n\tshort sel;\n\n\tif (v8086_mode(regs))\n\t\t/* Address and operand size are both 16-bit. */\n\t\treturn INSN_CODE_SEG_PARAMS(2, 2);\n\n\tsel = get_segment_selector(regs, INAT_SEG_REG_CS);\n\tif (sel < 0)\n\t\treturn sel;\n\n\tif (!get_desc(&desc, sel))\n\t\treturn -EINVAL;\n\n\t/*\n\t * The most significant byte of the Type field of the segment descriptor\n\t * determines whether a segment contains data or code. If this is a data\n\t * segment, return error.\n\t */\n\tif (!(desc.type & BIT(3)))\n\t\treturn -EINVAL;\n\n\tswitch ((desc.l << 1) | desc.d) {\n\tcase 0: /*\n\t\t * Legacy mode. CS.L=0, CS.D=0. Address and operand size are\n\t\t * both 16-bit.\n\t\t */\n\t\treturn INSN_CODE_SEG_PARAMS(2, 2);\n\tcase 1: /*\n\t\t * Legacy mode. CS.L=0, CS.D=1. Address and operand size are\n\t\t * both 32-bit.\n\t\t */\n\t\treturn INSN_CODE_SEG_PARAMS(4, 4);\n\tcase 2: /*\n\t\t * IA-32e 64-bit mode. CS.L=1, CS.D=0. Address size is 64-bit;\n\t\t * operand size is 32-bit.\n\t\t */\n\t\treturn INSN_CODE_SEG_PARAMS(4, 8);\n\tcase 3: /* Invalid setting. CS.L=1, CS.D=1 */\n\t\t/* fall through */\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}",
        "patch": "--- code before\n+++ code after\n@@ -1,6 +1,6 @@\n int insn_get_code_seg_params(struct pt_regs *regs)\n {\n-\tstruct desc_struct *desc;\n+\tstruct desc_struct desc;\n \tshort sel;\n \n \tif (v8086_mode(regs))\n@@ -11,8 +11,7 @@\n \tif (sel < 0)\n \t\treturn sel;\n \n-\tdesc = get_desc(sel);\n-\tif (!desc)\n+\tif (!get_desc(&desc, sel))\n \t\treturn -EINVAL;\n \n \t/*\n@@ -20,10 +19,10 @@\n \t * determines whether a segment contains data or code. If this is a data\n \t * segment, return error.\n \t */\n-\tif (!(desc->type & BIT(3)))\n+\tif (!(desc.type & BIT(3)))\n \t\treturn -EINVAL;\n \n-\tswitch ((desc->l << 1) | desc->d) {\n+\tswitch ((desc.l << 1) | desc.d) {\n \tcase 0: /*\n \t\t * Legacy mode. CS.L=0, CS.D=0. Address and operand size are\n \t\t * both 16-bit.",
        "function_modified_lines": {
            "added": [
                "\tstruct desc_struct desc;",
                "\tif (!get_desc(&desc, sel))",
                "\tif (!(desc.type & BIT(3)))",
                "\tswitch ((desc.l << 1) | desc.d) {"
            ],
            "deleted": [
                "\tstruct desc_struct *desc;",
                "\tdesc = get_desc(sel);",
                "\tif (!desc)",
                "\tif (!(desc->type & BIT(3)))",
                "\tswitch ((desc->l << 1) | desc->d) {"
            ]
        },
        "cwe": [
            "CWE-362",
            "CWE-416"
        ],
        "cve_description": "In arch/x86/lib/insn-eval.c in the Linux kernel before 5.1.9, there is a use-after-free for access to an LDT entry because of a race condition between modify_ldt() and a #BR exception for an MPX bounds violation.",
        "id": 1958
    },
    {
        "cve_id": "CVE-2019-13233",
        "code_before_change": "unsigned long insn_get_seg_base(struct pt_regs *regs, int seg_reg_idx)\n{\n\tstruct desc_struct *desc;\n\tshort sel;\n\n\tsel = get_segment_selector(regs, seg_reg_idx);\n\tif (sel < 0)\n\t\treturn -1L;\n\n\tif (v8086_mode(regs))\n\t\t/*\n\t\t * Base is simply the segment selector shifted 4\n\t\t * bits to the right.\n\t\t */\n\t\treturn (unsigned long)(sel << 4);\n\n\tif (user_64bit_mode(regs)) {\n\t\t/*\n\t\t * Only FS or GS will have a base address, the rest of\n\t\t * the segments' bases are forced to 0.\n\t\t */\n\t\tunsigned long base;\n\n\t\tif (seg_reg_idx == INAT_SEG_REG_FS)\n\t\t\trdmsrl(MSR_FS_BASE, base);\n\t\telse if (seg_reg_idx == INAT_SEG_REG_GS)\n\t\t\t/*\n\t\t\t * swapgs was called at the kernel entry point. Thus,\n\t\t\t * MSR_KERNEL_GS_BASE will have the user-space GS base.\n\t\t\t */\n\t\t\trdmsrl(MSR_KERNEL_GS_BASE, base);\n\t\telse\n\t\t\tbase = 0;\n\t\treturn base;\n\t}\n\n\t/* In protected mode the segment selector cannot be null. */\n\tif (!sel)\n\t\treturn -1L;\n\n\tdesc = get_desc(sel);\n\tif (!desc)\n\t\treturn -1L;\n\n\treturn get_desc_base(desc);\n}",
        "code_after_change": "unsigned long insn_get_seg_base(struct pt_regs *regs, int seg_reg_idx)\n{\n\tstruct desc_struct desc;\n\tshort sel;\n\n\tsel = get_segment_selector(regs, seg_reg_idx);\n\tif (sel < 0)\n\t\treturn -1L;\n\n\tif (v8086_mode(regs))\n\t\t/*\n\t\t * Base is simply the segment selector shifted 4\n\t\t * bits to the right.\n\t\t */\n\t\treturn (unsigned long)(sel << 4);\n\n\tif (user_64bit_mode(regs)) {\n\t\t/*\n\t\t * Only FS or GS will have a base address, the rest of\n\t\t * the segments' bases are forced to 0.\n\t\t */\n\t\tunsigned long base;\n\n\t\tif (seg_reg_idx == INAT_SEG_REG_FS)\n\t\t\trdmsrl(MSR_FS_BASE, base);\n\t\telse if (seg_reg_idx == INAT_SEG_REG_GS)\n\t\t\t/*\n\t\t\t * swapgs was called at the kernel entry point. Thus,\n\t\t\t * MSR_KERNEL_GS_BASE will have the user-space GS base.\n\t\t\t */\n\t\t\trdmsrl(MSR_KERNEL_GS_BASE, base);\n\t\telse\n\t\t\tbase = 0;\n\t\treturn base;\n\t}\n\n\t/* In protected mode the segment selector cannot be null. */\n\tif (!sel)\n\t\treturn -1L;\n\n\tif (!get_desc(&desc, sel))\n\t\treturn -1L;\n\n\treturn get_desc_base(&desc);\n}",
        "patch": "--- code before\n+++ code after\n@@ -1,6 +1,6 @@\n unsigned long insn_get_seg_base(struct pt_regs *regs, int seg_reg_idx)\n {\n-\tstruct desc_struct *desc;\n+\tstruct desc_struct desc;\n \tshort sel;\n \n \tsel = get_segment_selector(regs, seg_reg_idx);\n@@ -38,9 +38,8 @@\n \tif (!sel)\n \t\treturn -1L;\n \n-\tdesc = get_desc(sel);\n-\tif (!desc)\n+\tif (!get_desc(&desc, sel))\n \t\treturn -1L;\n \n-\treturn get_desc_base(desc);\n+\treturn get_desc_base(&desc);\n }",
        "function_modified_lines": {
            "added": [
                "\tstruct desc_struct desc;",
                "\tif (!get_desc(&desc, sel))",
                "\treturn get_desc_base(&desc);"
            ],
            "deleted": [
                "\tstruct desc_struct *desc;",
                "\tdesc = get_desc(sel);",
                "\tif (!desc)",
                "\treturn get_desc_base(desc);"
            ]
        },
        "cwe": [
            "CWE-362",
            "CWE-416"
        ],
        "cve_description": "In arch/x86/lib/insn-eval.c in the Linux kernel before 5.1.9, there is a use-after-free for access to an LDT entry because of a race condition between modify_ldt() and a #BR exception for an MPX bounds violation.",
        "id": 1959
    },
    {
        "cve_id": "CVE-2021-3609",
        "code_before_change": "static int bcm_delete_rx_op(struct list_head *ops, struct bcm_msg_head *mh,\n\t\t\t    int ifindex)\n{\n\tstruct bcm_op *op, *n;\n\n\tlist_for_each_entry_safe(op, n, ops, list) {\n\t\tif ((op->can_id == mh->can_id) && (op->ifindex == ifindex) &&\n\t\t    (op->flags & CAN_FD_FRAME) == (mh->flags & CAN_FD_FRAME)) {\n\n\t\t\t/*\n\t\t\t * Don't care if we're bound or not (due to netdev\n\t\t\t * problems) can_rx_unregister() is always a save\n\t\t\t * thing to do here.\n\t\t\t */\n\t\t\tif (op->ifindex) {\n\t\t\t\t/*\n\t\t\t\t * Only remove subscriptions that had not\n\t\t\t\t * been removed due to NETDEV_UNREGISTER\n\t\t\t\t * in bcm_notifier()\n\t\t\t\t */\n\t\t\t\tif (op->rx_reg_dev) {\n\t\t\t\t\tstruct net_device *dev;\n\n\t\t\t\t\tdev = dev_get_by_index(sock_net(op->sk),\n\t\t\t\t\t\t\t       op->ifindex);\n\t\t\t\t\tif (dev) {\n\t\t\t\t\t\tbcm_rx_unreg(dev, op);\n\t\t\t\t\t\tdev_put(dev);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tcan_rx_unregister(sock_net(op->sk), NULL,\n\t\t\t\t\t\t  op->can_id,\n\t\t\t\t\t\t  REGMASK(op->can_id),\n\t\t\t\t\t\t  bcm_rx_handler, op);\n\n\t\t\tlist_del(&op->list);\n\t\t\tbcm_remove_op(op);\n\t\t\treturn 1; /* done */\n\t\t}\n\t}\n\n\treturn 0; /* not found */\n}",
        "code_after_change": "static int bcm_delete_rx_op(struct list_head *ops, struct bcm_msg_head *mh,\n\t\t\t    int ifindex)\n{\n\tstruct bcm_op *op, *n;\n\n\tlist_for_each_entry_safe(op, n, ops, list) {\n\t\tif ((op->can_id == mh->can_id) && (op->ifindex == ifindex) &&\n\t\t    (op->flags & CAN_FD_FRAME) == (mh->flags & CAN_FD_FRAME)) {\n\n\t\t\t/*\n\t\t\t * Don't care if we're bound or not (due to netdev\n\t\t\t * problems) can_rx_unregister() is always a save\n\t\t\t * thing to do here.\n\t\t\t */\n\t\t\tif (op->ifindex) {\n\t\t\t\t/*\n\t\t\t\t * Only remove subscriptions that had not\n\t\t\t\t * been removed due to NETDEV_UNREGISTER\n\t\t\t\t * in bcm_notifier()\n\t\t\t\t */\n\t\t\t\tif (op->rx_reg_dev) {\n\t\t\t\t\tstruct net_device *dev;\n\n\t\t\t\t\tdev = dev_get_by_index(sock_net(op->sk),\n\t\t\t\t\t\t\t       op->ifindex);\n\t\t\t\t\tif (dev) {\n\t\t\t\t\t\tbcm_rx_unreg(dev, op);\n\t\t\t\t\t\tdev_put(dev);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tcan_rx_unregister(sock_net(op->sk), NULL,\n\t\t\t\t\t\t  op->can_id,\n\t\t\t\t\t\t  REGMASK(op->can_id),\n\t\t\t\t\t\t  bcm_rx_handler, op);\n\n\t\t\tlist_del(&op->list);\n\t\t\tsynchronize_rcu();\n\t\t\tbcm_remove_op(op);\n\t\t\treturn 1; /* done */\n\t\t}\n\t}\n\n\treturn 0; /* not found */\n}",
        "patch": "--- code before\n+++ code after\n@@ -35,6 +35,7 @@\n \t\t\t\t\t\t  bcm_rx_handler, op);\n \n \t\t\tlist_del(&op->list);\n+\t\t\tsynchronize_rcu();\n \t\t\tbcm_remove_op(op);\n \t\t\treturn 1; /* done */\n \t\t}",
        "function_modified_lines": {
            "added": [
                "\t\t\tsynchronize_rcu();"
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": ".A flaw was found in the CAN BCM networking protocol in the Linux kernel, where a local attacker can abuse a flaw in the CAN subsystem to corrupt memory, crash the system or escalate privileges. This race condition in net/can/bcm.c in the Linux kernel allows for local privilege escalation to root.",
        "id": 3022
    },
    {
        "cve_id": "CVE-2022-23039",
        "code_before_change": "static void __del_gref(struct gntalloc_gref *gref)\n{\n\tif (gref->notify.flags & UNMAP_NOTIFY_CLEAR_BYTE) {\n\t\tuint8_t *tmp = kmap(gref->page);\n\t\ttmp[gref->notify.pgoff] = 0;\n\t\tkunmap(gref->page);\n\t}\n\tif (gref->notify.flags & UNMAP_NOTIFY_SEND_EVENT) {\n\t\tnotify_remote_via_evtchn(gref->notify.event);\n\t\tevtchn_put(gref->notify.event);\n\t}\n\n\tgref->notify.flags = 0;\n\n\tif (gref->gref_id) {\n\t\tif (gnttab_query_foreign_access(gref->gref_id))\n\t\t\treturn;\n\n\t\tif (!gnttab_end_foreign_access_ref(gref->gref_id, 0))\n\t\t\treturn;\n\n\t\tgnttab_free_grant_reference(gref->gref_id);\n\t}\n\n\tgref_size--;\n\tlist_del(&gref->next_gref);\n\n\tif (gref->page)\n\t\t__free_page(gref->page);\n\n\tkfree(gref);\n}",
        "code_after_change": "static void __del_gref(struct gntalloc_gref *gref)\n{\n\tunsigned long addr;\n\n\tif (gref->notify.flags & UNMAP_NOTIFY_CLEAR_BYTE) {\n\t\tuint8_t *tmp = kmap(gref->page);\n\t\ttmp[gref->notify.pgoff] = 0;\n\t\tkunmap(gref->page);\n\t}\n\tif (gref->notify.flags & UNMAP_NOTIFY_SEND_EVENT) {\n\t\tnotify_remote_via_evtchn(gref->notify.event);\n\t\tevtchn_put(gref->notify.event);\n\t}\n\n\tgref->notify.flags = 0;\n\n\tif (gref->gref_id) {\n\t\tif (gref->page) {\n\t\t\taddr = (unsigned long)page_to_virt(gref->page);\n\t\t\tgnttab_end_foreign_access(gref->gref_id, 0, addr);\n\t\t} else\n\t\t\tgnttab_free_grant_reference(gref->gref_id);\n\t}\n\n\tgref_size--;\n\tlist_del(&gref->next_gref);\n\n\tkfree(gref);\n}",
        "patch": "--- code before\n+++ code after\n@@ -1,5 +1,7 @@\n static void __del_gref(struct gntalloc_gref *gref)\n {\n+\tunsigned long addr;\n+\n \tif (gref->notify.flags & UNMAP_NOTIFY_CLEAR_BYTE) {\n \t\tuint8_t *tmp = kmap(gref->page);\n \t\ttmp[gref->notify.pgoff] = 0;\n@@ -13,20 +15,15 @@\n \tgref->notify.flags = 0;\n \n \tif (gref->gref_id) {\n-\t\tif (gnttab_query_foreign_access(gref->gref_id))\n-\t\t\treturn;\n-\n-\t\tif (!gnttab_end_foreign_access_ref(gref->gref_id, 0))\n-\t\t\treturn;\n-\n-\t\tgnttab_free_grant_reference(gref->gref_id);\n+\t\tif (gref->page) {\n+\t\t\taddr = (unsigned long)page_to_virt(gref->page);\n+\t\t\tgnttab_end_foreign_access(gref->gref_id, 0, addr);\n+\t\t} else\n+\t\t\tgnttab_free_grant_reference(gref->gref_id);\n \t}\n \n \tgref_size--;\n \tlist_del(&gref->next_gref);\n \n-\tif (gref->page)\n-\t\t__free_page(gref->page);\n-\n \tkfree(gref);\n }",
        "function_modified_lines": {
            "added": [
                "\tunsigned long addr;",
                "",
                "\t\tif (gref->page) {",
                "\t\t\taddr = (unsigned long)page_to_virt(gref->page);",
                "\t\t\tgnttab_end_foreign_access(gref->gref_id, 0, addr);",
                "\t\t} else",
                "\t\t\tgnttab_free_grant_reference(gref->gref_id);"
            ],
            "deleted": [
                "\t\tif (gnttab_query_foreign_access(gref->gref_id))",
                "\t\t\treturn;",
                "",
                "\t\tif (!gnttab_end_foreign_access_ref(gref->gref_id, 0))",
                "\t\t\treturn;",
                "",
                "\t\tgnttab_free_grant_reference(gref->gref_id);",
                "\tif (gref->page)",
                "\t\t__free_page(gref->page);",
                ""
            ]
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "Linux PV device frontends vulnerable to attacks by backends T[his CNA information record relates to multiple CVEs; the text explains which aspects/vulnerabilities correspond to which CVE.] Several Linux PV device frontends are using the grant table interfaces for removing access rights of the backends in ways being subject to race conditions, resulting in potential data leaks, data corruption by malicious backends, and denial of service triggered by malicious backends: blkfront, netfront, scsifront and the gntalloc driver are testing whether a grant reference is still in use. If this is not the case, they assume that a following removal of the granted access will always succeed, which is not true in case the backend has mapped the granted page between those two operations. As a result the backend can keep access to the memory page of the guest no matter how the page will be used after the frontend I/O has finished. The xenbus driver has a similar problem, as it doesn't check the success of removing the granted access of a shared ring buffer. blkfront: CVE-2022-23036 netfront: CVE-2022-23037 scsifront: CVE-2022-23038 gntalloc: CVE-2022-23039 xenbus: CVE-2022-23040 blkfront, netfront, scsifront, usbfront, dmabuf, xenbus, 9p, kbdfront, and pvcalls are using a functionality to delay freeing a grant reference until it is no longer in use, but the freeing of the related data page is not synchronized with dropping the granted access. As a result the backend can keep access to the memory page even after it has been freed and then re-used for a different purpose. CVE-2022-23041 netfront will fail a BUG_ON() assertion if it fails to revoke access in the rx path. This will result in a Denial of Service (DoS) situation of the guest which can be triggered by the backend. CVE-2022-23042",
        "id": 3422
    },
    {
        "cve_id": "CVE-2022-29582",
        "code_before_change": "static int io_timeout_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe,\n\t\t\t   bool is_timeout_link)\n{\n\tstruct io_timeout_data *data;\n\tunsigned flags;\n\tu32 off = READ_ONCE(sqe->off);\n\n\tif (unlikely(req->ctx->flags & IORING_SETUP_IOPOLL))\n\t\treturn -EINVAL;\n\tif (sqe->ioprio || sqe->buf_index || sqe->len != 1 ||\n\t    sqe->splice_fd_in)\n\t\treturn -EINVAL;\n\tif (off && is_timeout_link)\n\t\treturn -EINVAL;\n\tflags = READ_ONCE(sqe->timeout_flags);\n\tif (flags & ~(IORING_TIMEOUT_ABS | IORING_TIMEOUT_CLOCK_MASK |\n\t\t      IORING_TIMEOUT_ETIME_SUCCESS))\n\t\treturn -EINVAL;\n\t/* more than one clock specified is invalid, obviously */\n\tif (hweight32(flags & IORING_TIMEOUT_CLOCK_MASK) > 1)\n\t\treturn -EINVAL;\n\n\tINIT_LIST_HEAD(&req->timeout.list);\n\treq->timeout.off = off;\n\tif (unlikely(off && !req->ctx->off_timeout_used))\n\t\treq->ctx->off_timeout_used = true;\n\n\tif (WARN_ON_ONCE(req_has_async_data(req)))\n\t\treturn -EFAULT;\n\tif (io_alloc_async_data(req))\n\t\treturn -ENOMEM;\n\n\tdata = req->async_data;\n\tdata->req = req;\n\tdata->flags = flags;\n\n\tif (get_timespec64(&data->ts, u64_to_user_ptr(sqe->addr)))\n\t\treturn -EFAULT;\n\n\tif (data->ts.tv_sec < 0 || data->ts.tv_nsec < 0)\n\t\treturn -EINVAL;\n\n\tdata->mode = io_translate_timeout_mode(flags);\n\thrtimer_init(&data->timer, io_timeout_get_clock(data), data->mode);\n\n\tif (is_timeout_link) {\n\t\tstruct io_submit_link *link = &req->ctx->submit_state.link;\n\n\t\tif (!link->head)\n\t\t\treturn -EINVAL;\n\t\tif (link->last->opcode == IORING_OP_LINK_TIMEOUT)\n\t\t\treturn -EINVAL;\n\t\treq->timeout.head = link->last;\n\t\tlink->last->flags |= REQ_F_ARM_LTIMEOUT;\n\t}\n\treturn 0;\n}",
        "code_after_change": "static int io_timeout_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe,\n\t\t\t   bool is_timeout_link)\n{\n\tstruct io_timeout_data *data;\n\tunsigned flags;\n\tu32 off = READ_ONCE(sqe->off);\n\n\tif (unlikely(req->ctx->flags & IORING_SETUP_IOPOLL))\n\t\treturn -EINVAL;\n\tif (sqe->ioprio || sqe->buf_index || sqe->len != 1 ||\n\t    sqe->splice_fd_in)\n\t\treturn -EINVAL;\n\tif (off && is_timeout_link)\n\t\treturn -EINVAL;\n\tflags = READ_ONCE(sqe->timeout_flags);\n\tif (flags & ~(IORING_TIMEOUT_ABS | IORING_TIMEOUT_CLOCK_MASK |\n\t\t      IORING_TIMEOUT_ETIME_SUCCESS))\n\t\treturn -EINVAL;\n\t/* more than one clock specified is invalid, obviously */\n\tif (hweight32(flags & IORING_TIMEOUT_CLOCK_MASK) > 1)\n\t\treturn -EINVAL;\n\n\tINIT_LIST_HEAD(&req->timeout.list);\n\treq->timeout.off = off;\n\tif (unlikely(off && !req->ctx->off_timeout_used))\n\t\treq->ctx->off_timeout_used = true;\n\n\tif (WARN_ON_ONCE(req_has_async_data(req)))\n\t\treturn -EFAULT;\n\tif (io_alloc_async_data(req))\n\t\treturn -ENOMEM;\n\n\tdata = req->async_data;\n\tdata->req = req;\n\tdata->flags = flags;\n\n\tif (get_timespec64(&data->ts, u64_to_user_ptr(sqe->addr)))\n\t\treturn -EFAULT;\n\n\tif (data->ts.tv_sec < 0 || data->ts.tv_nsec < 0)\n\t\treturn -EINVAL;\n\n\tINIT_LIST_HEAD(&req->timeout.list);\n\tdata->mode = io_translate_timeout_mode(flags);\n\thrtimer_init(&data->timer, io_timeout_get_clock(data), data->mode);\n\n\tif (is_timeout_link) {\n\t\tstruct io_submit_link *link = &req->ctx->submit_state.link;\n\n\t\tif (!link->head)\n\t\t\treturn -EINVAL;\n\t\tif (link->last->opcode == IORING_OP_LINK_TIMEOUT)\n\t\t\treturn -EINVAL;\n\t\treq->timeout.head = link->last;\n\t\tlink->last->flags |= REQ_F_ARM_LTIMEOUT;\n\t}\n\treturn 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -40,6 +40,7 @@\n \tif (data->ts.tv_sec < 0 || data->ts.tv_nsec < 0)\n \t\treturn -EINVAL;\n \n+\tINIT_LIST_HEAD(&req->timeout.list);\n \tdata->mode = io_translate_timeout_mode(flags);\n \thrtimer_init(&data->timer, io_timeout_get_clock(data), data->mode);\n ",
        "function_modified_lines": {
            "added": [
                "\tINIT_LIST_HEAD(&req->timeout.list);"
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "In the Linux kernel before 5.17.3, fs/io_uring.c has a use-after-free due to a race condition in io_uring timeouts. This can be triggered by a local user who has no access to any user namespace; however, the race condition perhaps can only be exploited infrequently.",
        "id": 3523
    },
    {
        "cve_id": "CVE-2022-45888",
        "code_before_change": "static void xillyusb_disconnect(struct usb_interface *interface)\n{\n\tstruct xillyusb_dev *xdev = usb_get_intfdata(interface);\n\tstruct xillyusb_endpoint *msg_ep = xdev->msg_ep;\n\tstruct xillyfifo *fifo = &msg_ep->fifo;\n\tint rc;\n\tint i;\n\n\txillybus_cleanup_chrdev(xdev, &interface->dev);\n\n\t/*\n\t * Try to send OPCODE_QUIESCE, which will fail silently if the device\n\t * was disconnected, but makes sense on module unload.\n\t */\n\n\tmsg_ep->wake_on_drain = true;\n\txillyusb_send_opcode(xdev, ~0, OPCODE_QUIESCE, 0);\n\n\t/*\n\t * If the device has been disconnected, sending the opcode causes\n\t * a global device error with xdev->error, if such error didn't\n\t * occur earlier. Hence timing out means that the USB link is fine,\n\t * but somehow the message wasn't sent. Should never happen.\n\t */\n\n\trc = wait_event_interruptible_timeout(fifo->waitq,\n\t\t\t\t\t      msg_ep->drained || xdev->error,\n\t\t\t\t\t      XILLY_RESPONSE_TIMEOUT);\n\n\tif (!rc)\n\t\tdev_err(&interface->dev,\n\t\t\t\"Weird timeout condition on sending quiesce request.\\n\");\n\n\treport_io_error(xdev, -ENODEV); /* Discourage further activity */\n\n\t/*\n\t * This device driver is declared with soft_unbind set, or else\n\t * sending OPCODE_QUIESCE above would always fail. The price is\n\t * that the USB framework didn't kill outstanding URBs, so it has\n\t * to be done explicitly before returning from this call.\n\t */\n\n\tfor (i = 0; i < xdev->num_channels; i++) {\n\t\tstruct xillyusb_channel *chan = &xdev->channels[i];\n\n\t\t/*\n\t\t * Lock taken to prevent chan->out_ep from changing. It also\n\t\t * ensures xillyusb_open() and xillyusb_flush() don't access\n\t\t * xdev->dev after being nullified below.\n\t\t */\n\t\tmutex_lock(&chan->lock);\n\t\tif (chan->out_ep)\n\t\t\tendpoint_quiesce(chan->out_ep);\n\t\tmutex_unlock(&chan->lock);\n\t}\n\n\tendpoint_quiesce(xdev->in_ep);\n\tendpoint_quiesce(xdev->msg_ep);\n\n\tusb_set_intfdata(interface, NULL);\n\n\txdev->dev = NULL;\n\n\tkref_put(&xdev->kref, cleanup_dev);\n}",
        "code_after_change": "static void xillyusb_disconnect(struct usb_interface *interface)\n{\n\tstruct xillyusb_dev *xdev = usb_get_intfdata(interface);\n\tstruct xillyusb_endpoint *msg_ep = xdev->msg_ep;\n\tstruct xillyfifo *fifo = &msg_ep->fifo;\n\tint rc;\n\tint i;\n\n\txillybus_cleanup_chrdev(xdev, &interface->dev);\n\n\t/*\n\t * Try to send OPCODE_QUIESCE, which will fail silently if the device\n\t * was disconnected, but makes sense on module unload.\n\t */\n\n\tmsg_ep->wake_on_drain = true;\n\txillyusb_send_opcode(xdev, ~0, OPCODE_QUIESCE, 0);\n\n\t/*\n\t * If the device has been disconnected, sending the opcode causes\n\t * a global device error with xdev->error, if such error didn't\n\t * occur earlier. Hence timing out means that the USB link is fine,\n\t * but somehow the message wasn't sent. Should never happen.\n\t */\n\n\trc = wait_event_interruptible_timeout(fifo->waitq,\n\t\t\t\t\t      msg_ep->drained || xdev->error,\n\t\t\t\t\t      XILLY_RESPONSE_TIMEOUT);\n\n\tif (!rc)\n\t\tdev_err(&interface->dev,\n\t\t\t\"Weird timeout condition on sending quiesce request.\\n\");\n\n\treport_io_error(xdev, -ENODEV); /* Discourage further activity */\n\n\t/*\n\t * This device driver is declared with soft_unbind set, or else\n\t * sending OPCODE_QUIESCE above would always fail. The price is\n\t * that the USB framework didn't kill outstanding URBs, so it has\n\t * to be done explicitly before returning from this call.\n\t */\n\n\tfor (i = 0; i < xdev->num_channels; i++) {\n\t\tstruct xillyusb_channel *chan = &xdev->channels[i];\n\n\t\t/*\n\t\t * Lock taken to prevent chan->out_ep from changing. It also\n\t\t * ensures xillyusb_open() and xillyusb_flush() don't access\n\t\t * xdev->dev after being nullified below.\n\t\t */\n\t\tmutex_lock(&chan->lock);\n\t\tif (chan->out_ep)\n\t\t\tendpoint_quiesce(chan->out_ep);\n\t\tmutex_unlock(&chan->lock);\n\t}\n\n\tendpoint_quiesce(xdev->in_ep);\n\tendpoint_quiesce(xdev->msg_ep);\n\n\tusb_set_intfdata(interface, NULL);\n\n\txdev->dev = NULL;\n\n\tmutex_lock(&kref_mutex);\n\tkref_put(&xdev->kref, cleanup_dev);\n\tmutex_unlock(&kref_mutex);\n}",
        "patch": "--- code before\n+++ code after\n@@ -61,5 +61,7 @@\n \n \txdev->dev = NULL;\n \n+\tmutex_lock(&kref_mutex);\n \tkref_put(&xdev->kref, cleanup_dev);\n+\tmutex_unlock(&kref_mutex);\n }",
        "function_modified_lines": {
            "added": [
                "\tmutex_lock(&kref_mutex);",
                "\tmutex_unlock(&kref_mutex);"
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-362",
            "CWE-416"
        ],
        "cve_description": "An issue was discovered in the Linux kernel through 6.0.9. drivers/char/xillybus/xillyusb.c has a race condition and use-after-free during physical removal of a USB device.",
        "id": 3754
    },
    {
        "cve_id": "CVE-2018-1000004",
        "code_before_change": "static struct snd_seq_client *seq_create_client1(int client_index, int poolsize)\n{\n\tunsigned long flags;\n\tint c;\n\tstruct snd_seq_client *client;\n\n\t/* init client data */\n\tclient = kzalloc(sizeof(*client), GFP_KERNEL);\n\tif (client == NULL)\n\t\treturn NULL;\n\tclient->pool = snd_seq_pool_new(poolsize);\n\tif (client->pool == NULL) {\n\t\tkfree(client);\n\t\treturn NULL;\n\t}\n\tclient->type = NO_CLIENT;\n\tsnd_use_lock_init(&client->use_lock);\n\trwlock_init(&client->ports_lock);\n\tmutex_init(&client->ports_mutex);\n\tINIT_LIST_HEAD(&client->ports_list_head);\n\n\t/* find free slot in the client table */\n\tspin_lock_irqsave(&clients_lock, flags);\n\tif (client_index < 0) {\n\t\tfor (c = SNDRV_SEQ_DYNAMIC_CLIENTS_BEGIN;\n\t\t     c < SNDRV_SEQ_MAX_CLIENTS;\n\t\t     c++) {\n\t\t\tif (clienttab[c] || clienttablock[c])\n\t\t\t\tcontinue;\n\t\t\tclienttab[client->number = c] = client;\n\t\t\tspin_unlock_irqrestore(&clients_lock, flags);\n\t\t\treturn client;\n\t\t}\n\t} else {\n\t\tif (clienttab[client_index] == NULL && !clienttablock[client_index]) {\n\t\t\tclienttab[client->number = client_index] = client;\n\t\t\tspin_unlock_irqrestore(&clients_lock, flags);\n\t\t\treturn client;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&clients_lock, flags);\n\tsnd_seq_pool_delete(&client->pool);\n\tkfree(client);\n\treturn NULL;\t/* no free slot found or busy, return failure code */\n}",
        "code_after_change": "static struct snd_seq_client *seq_create_client1(int client_index, int poolsize)\n{\n\tunsigned long flags;\n\tint c;\n\tstruct snd_seq_client *client;\n\n\t/* init client data */\n\tclient = kzalloc(sizeof(*client), GFP_KERNEL);\n\tif (client == NULL)\n\t\treturn NULL;\n\tclient->pool = snd_seq_pool_new(poolsize);\n\tif (client->pool == NULL) {\n\t\tkfree(client);\n\t\treturn NULL;\n\t}\n\tclient->type = NO_CLIENT;\n\tsnd_use_lock_init(&client->use_lock);\n\trwlock_init(&client->ports_lock);\n\tmutex_init(&client->ports_mutex);\n\tINIT_LIST_HEAD(&client->ports_list_head);\n\tmutex_init(&client->ioctl_mutex);\n\n\t/* find free slot in the client table */\n\tspin_lock_irqsave(&clients_lock, flags);\n\tif (client_index < 0) {\n\t\tfor (c = SNDRV_SEQ_DYNAMIC_CLIENTS_BEGIN;\n\t\t     c < SNDRV_SEQ_MAX_CLIENTS;\n\t\t     c++) {\n\t\t\tif (clienttab[c] || clienttablock[c])\n\t\t\t\tcontinue;\n\t\t\tclienttab[client->number = c] = client;\n\t\t\tspin_unlock_irqrestore(&clients_lock, flags);\n\t\t\treturn client;\n\t\t}\n\t} else {\n\t\tif (clienttab[client_index] == NULL && !clienttablock[client_index]) {\n\t\t\tclienttab[client->number = client_index] = client;\n\t\t\tspin_unlock_irqrestore(&clients_lock, flags);\n\t\t\treturn client;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&clients_lock, flags);\n\tsnd_seq_pool_delete(&client->pool);\n\tkfree(client);\n\treturn NULL;\t/* no free slot found or busy, return failure code */\n}",
        "patch": "--- code before\n+++ code after\n@@ -18,6 +18,7 @@\n \trwlock_init(&client->ports_lock);\n \tmutex_init(&client->ports_mutex);\n \tINIT_LIST_HEAD(&client->ports_list_head);\n+\tmutex_init(&client->ioctl_mutex);\n \n \t/* find free slot in the client table */\n \tspin_lock_irqsave(&clients_lock, flags);",
        "function_modified_lines": {
            "added": [
                "\tmutex_init(&client->ioctl_mutex);"
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "In the Linux kernel 4.12, 3.10, 2.6 and possibly earlier versions a race condition vulnerability exists in the sound system, this can lead to a deadlock and denial of service condition.",
        "id": 1574
    },
    {
        "cve_id": "CVE-2017-6874",
        "code_before_change": "static void put_ucounts(struct ucounts *ucounts)\n{\n\tunsigned long flags;\n\n\tif (atomic_dec_and_test(&ucounts->count)) {\n\t\tspin_lock_irqsave(&ucounts_lock, flags);\n\t\thlist_del_init(&ucounts->node);\n\t\tspin_unlock_irqrestore(&ucounts_lock, flags);\n\n\t\tkfree(ucounts);\n\t}\n}",
        "code_after_change": "static void put_ucounts(struct ucounts *ucounts)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ucounts_lock, flags);\n\tucounts->count -= 1;\n\tif (!ucounts->count)\n\t\thlist_del_init(&ucounts->node);\n\telse\n\t\tucounts = NULL;\n\tspin_unlock_irqrestore(&ucounts_lock, flags);\n\n\tkfree(ucounts);\n}",
        "patch": "--- code before\n+++ code after\n@@ -2,11 +2,13 @@\n {\n \tunsigned long flags;\n \n-\tif (atomic_dec_and_test(&ucounts->count)) {\n-\t\tspin_lock_irqsave(&ucounts_lock, flags);\n+\tspin_lock_irqsave(&ucounts_lock, flags);\n+\tucounts->count -= 1;\n+\tif (!ucounts->count)\n \t\thlist_del_init(&ucounts->node);\n-\t\tspin_unlock_irqrestore(&ucounts_lock, flags);\n+\telse\n+\t\tucounts = NULL;\n+\tspin_unlock_irqrestore(&ucounts_lock, flags);\n \n-\t\tkfree(ucounts);\n-\t}\n+\tkfree(ucounts);\n }",
        "function_modified_lines": {
            "added": [
                "\tspin_lock_irqsave(&ucounts_lock, flags);",
                "\tucounts->count -= 1;",
                "\tif (!ucounts->count)",
                "\telse",
                "\t\tucounts = NULL;",
                "\tspin_unlock_irqrestore(&ucounts_lock, flags);",
                "\tkfree(ucounts);"
            ],
            "deleted": [
                "\tif (atomic_dec_and_test(&ucounts->count)) {",
                "\t\tspin_lock_irqsave(&ucounts_lock, flags);",
                "\t\tspin_unlock_irqrestore(&ucounts_lock, flags);",
                "\t\tkfree(ucounts);",
                "\t}"
            ]
        },
        "cwe": [
            "CWE-362",
            "CWE-416"
        ],
        "cve_description": "Race condition in kernel/ucount.c in the Linux kernel through 4.10.2 allows local users to cause a denial of service (use-after-free and system crash) or possibly have unspecified other impact via crafted system calls that leverage certain decrement behavior that causes incorrect interaction between put_ucounts and get_ucounts.",
        "id": 1487
    },
    {
        "cve_id": "CVE-2020-27825",
        "code_before_change": "void ring_buffer_reset_cpu(struct trace_buffer *buffer, int cpu)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer = buffer->buffers[cpu];\n\n\tif (!cpumask_test_cpu(cpu, buffer->cpumask))\n\t\treturn;\n\n\tatomic_inc(&cpu_buffer->resize_disabled);\n\tatomic_inc(&cpu_buffer->record_disabled);\n\n\t/* Make sure all commits have finished */\n\tsynchronize_rcu();\n\n\treset_disabled_cpu_buffer(cpu_buffer);\n\n\tatomic_dec(&cpu_buffer->record_disabled);\n\tatomic_dec(&cpu_buffer->resize_disabled);\n}",
        "code_after_change": "void ring_buffer_reset_cpu(struct trace_buffer *buffer, int cpu)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer = buffer->buffers[cpu];\n\n\tif (!cpumask_test_cpu(cpu, buffer->cpumask))\n\t\treturn;\n\n\t/* prevent another thread from changing buffer sizes */\n\tmutex_lock(&buffer->mutex);\n\n\tatomic_inc(&cpu_buffer->resize_disabled);\n\tatomic_inc(&cpu_buffer->record_disabled);\n\n\t/* Make sure all commits have finished */\n\tsynchronize_rcu();\n\n\treset_disabled_cpu_buffer(cpu_buffer);\n\n\tatomic_dec(&cpu_buffer->record_disabled);\n\tatomic_dec(&cpu_buffer->resize_disabled);\n\n\tmutex_unlock(&buffer->mutex);\n}",
        "patch": "--- code before\n+++ code after\n@@ -4,6 +4,9 @@\n \n \tif (!cpumask_test_cpu(cpu, buffer->cpumask))\n \t\treturn;\n+\n+\t/* prevent another thread from changing buffer sizes */\n+\tmutex_lock(&buffer->mutex);\n \n \tatomic_inc(&cpu_buffer->resize_disabled);\n \tatomic_inc(&cpu_buffer->record_disabled);\n@@ -15,4 +18,6 @@\n \n \tatomic_dec(&cpu_buffer->record_disabled);\n \tatomic_dec(&cpu_buffer->resize_disabled);\n+\n+\tmutex_unlock(&buffer->mutex);\n }",
        "function_modified_lines": {
            "added": [
                "",
                "\t/* prevent another thread from changing buffer sizes */",
                "\tmutex_lock(&buffer->mutex);",
                "",
                "\tmutex_unlock(&buffer->mutex);"
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-362"
        ],
        "cve_description": "A use-after-free flaw was found in kernel/trace/ring_buffer.c in Linux kernel (before 5.10-rc1). There was a race problem in trace_open and resize of cpu buffer running parallely on different cpus, may cause a denial of service problem (DOS). This flaw could even allow a local attacker with special user privilege to a kernel information leak threat.",
        "id": 2637
    }
]