[
    {
        "cve_id": "CVE-2020-9391",
        "code_before_change": "unsigned long ksys_mmap_pgoff(unsigned long addr, unsigned long len,\n\t\t\t      unsigned long prot, unsigned long flags,\n\t\t\t      unsigned long fd, unsigned long pgoff)\n{\n\tstruct file *file = NULL;\n\tunsigned long retval;\n\n\taddr = untagged_addr(addr);\n\n\tif (!(flags & MAP_ANONYMOUS)) {\n\t\taudit_mmap_fd(fd, flags);\n\t\tfile = fget(fd);\n\t\tif (!file)\n\t\t\treturn -EBADF;\n\t\tif (is_file_hugepages(file))\n\t\t\tlen = ALIGN(len, huge_page_size(hstate_file(file)));\n\t\tretval = -EINVAL;\n\t\tif (unlikely(flags & MAP_HUGETLB && !is_file_hugepages(file)))\n\t\t\tgoto out_fput;\n\t} else if (flags & MAP_HUGETLB) {\n\t\tstruct user_struct *user = NULL;\n\t\tstruct hstate *hs;\n\n\t\ths = hstate_sizelog((flags >> MAP_HUGE_SHIFT) & MAP_HUGE_MASK);\n\t\tif (!hs)\n\t\t\treturn -EINVAL;\n\n\t\tlen = ALIGN(len, huge_page_size(hs));\n\t\t/*\n\t\t * VM_NORESERVE is used because the reservations will be\n\t\t * taken when vm_ops->mmap() is called\n\t\t * A dummy user value is used because we are not locking\n\t\t * memory so no accounting is necessary\n\t\t */\n\t\tfile = hugetlb_file_setup(HUGETLB_ANON_FILE, len,\n\t\t\t\tVM_NORESERVE,\n\t\t\t\t&user, HUGETLB_ANONHUGE_INODE,\n\t\t\t\t(flags >> MAP_HUGE_SHIFT) & MAP_HUGE_MASK);\n\t\tif (IS_ERR(file))\n\t\t\treturn PTR_ERR(file);\n\t}\n\n\tflags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);\n\n\tretval = vm_mmap_pgoff(file, addr, len, prot, flags, pgoff);\nout_fput:\n\tif (file)\n\t\tfput(file);\n\treturn retval;\n}",
        "code_after_change": "unsigned long ksys_mmap_pgoff(unsigned long addr, unsigned long len,\n\t\t\t      unsigned long prot, unsigned long flags,\n\t\t\t      unsigned long fd, unsigned long pgoff)\n{\n\tstruct file *file = NULL;\n\tunsigned long retval;\n\n\tif (!(flags & MAP_ANONYMOUS)) {\n\t\taudit_mmap_fd(fd, flags);\n\t\tfile = fget(fd);\n\t\tif (!file)\n\t\t\treturn -EBADF;\n\t\tif (is_file_hugepages(file))\n\t\t\tlen = ALIGN(len, huge_page_size(hstate_file(file)));\n\t\tretval = -EINVAL;\n\t\tif (unlikely(flags & MAP_HUGETLB && !is_file_hugepages(file)))\n\t\t\tgoto out_fput;\n\t} else if (flags & MAP_HUGETLB) {\n\t\tstruct user_struct *user = NULL;\n\t\tstruct hstate *hs;\n\n\t\ths = hstate_sizelog((flags >> MAP_HUGE_SHIFT) & MAP_HUGE_MASK);\n\t\tif (!hs)\n\t\t\treturn -EINVAL;\n\n\t\tlen = ALIGN(len, huge_page_size(hs));\n\t\t/*\n\t\t * VM_NORESERVE is used because the reservations will be\n\t\t * taken when vm_ops->mmap() is called\n\t\t * A dummy user value is used because we are not locking\n\t\t * memory so no accounting is necessary\n\t\t */\n\t\tfile = hugetlb_file_setup(HUGETLB_ANON_FILE, len,\n\t\t\t\tVM_NORESERVE,\n\t\t\t\t&user, HUGETLB_ANONHUGE_INODE,\n\t\t\t\t(flags >> MAP_HUGE_SHIFT) & MAP_HUGE_MASK);\n\t\tif (IS_ERR(file))\n\t\t\treturn PTR_ERR(file);\n\t}\n\n\tflags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);\n\n\tretval = vm_mmap_pgoff(file, addr, len, prot, flags, pgoff);\nout_fput:\n\tif (file)\n\t\tfput(file);\n\treturn retval;\n}",
        "patch": "--- code before\n+++ code after\n@@ -4,8 +4,6 @@\n {\n \tstruct file *file = NULL;\n \tunsigned long retval;\n-\n-\taddr = untagged_addr(addr);\n \n \tif (!(flags & MAP_ANONYMOUS)) {\n \t\taudit_mmap_fd(fd, flags);",
        "function_modified_lines": {
            "added": [],
            "deleted": [
                "",
                "\taddr = untagged_addr(addr);"
            ]
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "An issue was discovered in the Linux kernel 5.4 and 5.5 through 5.5.6 on the AArch64 architecture. It ignores the top byte in the address passed to the brk system call, potentially moving the memory break downwards when the application expects it to move upwards, aka CID-dcde237319e6. This has been observed to cause heap corruption with the GNU C Library malloc implementation.",
        "id": 2812
    },
    {
        "cve_id": "CVE-2019-19816",
        "code_before_change": "struct extent_map *btrfs_get_extent(struct btrfs_inode *inode,\n\t\t\t\t    struct page *page,\n\t\t\t\t    size_t pg_offset, u64 start, u64 len,\n\t\t\t\t    int create)\n{\n\tstruct btrfs_fs_info *fs_info = inode->root->fs_info;\n\tint ret;\n\tint err = 0;\n\tu64 extent_start = 0;\n\tu64 extent_end = 0;\n\tu64 objectid = btrfs_ino(inode);\n\tu8 extent_type;\n\tstruct btrfs_path *path = NULL;\n\tstruct btrfs_root *root = inode->root;\n\tstruct btrfs_file_extent_item *item;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key found_key;\n\tstruct extent_map *em = NULL;\n\tstruct extent_map_tree *em_tree = &inode->extent_tree;\n\tstruct extent_io_tree *io_tree = &inode->io_tree;\n\tconst bool new_inline = !page || create;\n\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree, start, len);\n\tif (em)\n\t\tem->bdev = fs_info->fs_devices->latest_bdev;\n\tread_unlock(&em_tree->lock);\n\n\tif (em) {\n\t\tif (em->start > start || em->start + em->len <= start)\n\t\t\tfree_extent_map(em);\n\t\telse if (em->block_start == EXTENT_MAP_INLINE && page)\n\t\t\tfree_extent_map(em);\n\t\telse\n\t\t\tgoto out;\n\t}\n\tem = alloc_extent_map();\n\tif (!em) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\tem->bdev = fs_info->fs_devices->latest_bdev;\n\tem->start = EXTENT_MAP_HOLE;\n\tem->orig_start = EXTENT_MAP_HOLE;\n\tem->len = (u64)-1;\n\tem->block_len = (u64)-1;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/* Chances are we'll be called again, so go ahead and do readahead */\n\tpath->reada = READA_FORWARD;\n\n\t/*\n\t * Unless we're going to uncompress the inline extent, no sleep would\n\t * happen.\n\t */\n\tpath->leave_spinning = 1;\n\n\tret = btrfs_lookup_file_extent(NULL, root, path, objectid, start, 0);\n\tif (ret < 0) {\n\t\terr = ret;\n\t\tgoto out;\n\t} else if (ret > 0) {\n\t\tif (path->slots[0] == 0)\n\t\t\tgoto not_found;\n\t\tpath->slots[0]--;\n\t}\n\n\tleaf = path->nodes[0];\n\titem = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t      struct btrfs_file_extent_item);\n\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\tif (found_key.objectid != objectid ||\n\t    found_key.type != BTRFS_EXTENT_DATA_KEY) {\n\t\t/*\n\t\t * If we backup past the first extent we want to move forward\n\t\t * and see if there is an extent in front of us, otherwise we'll\n\t\t * say there is a hole for our whole search range which can\n\t\t * cause problems.\n\t\t */\n\t\textent_end = start;\n\t\tgoto next;\n\t}\n\n\textent_type = btrfs_file_extent_type(leaf, item);\n\textent_start = found_key.offset;\n\tif (extent_type == BTRFS_FILE_EXTENT_REG ||\n\t    extent_type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\textent_end = extent_start +\n\t\t       btrfs_file_extent_num_bytes(leaf, item);\n\n\t\ttrace_btrfs_get_extent_show_fi_regular(inode, leaf, item,\n\t\t\t\t\t\t       extent_start);\n\t} else if (extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\tsize_t size;\n\n\t\tsize = btrfs_file_extent_ram_bytes(leaf, item);\n\t\textent_end = ALIGN(extent_start + size,\n\t\t\t\t   fs_info->sectorsize);\n\n\t\ttrace_btrfs_get_extent_show_fi_inline(inode, leaf, item,\n\t\t\t\t\t\t      path->slots[0],\n\t\t\t\t\t\t      extent_start);\n\t}\nnext:\n\tif (start >= extent_end) {\n\t\tpath->slots[0]++;\n\t\tif (path->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0) {\n\t\t\t\terr = ret;\n\t\t\t\tgoto out;\n\t\t\t} else if (ret > 0) {\n\t\t\t\tgoto not_found;\n\t\t\t}\n\t\t\tleaf = path->nodes[0];\n\t\t}\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\t\tif (found_key.objectid != objectid ||\n\t\t    found_key.type != BTRFS_EXTENT_DATA_KEY)\n\t\t\tgoto not_found;\n\t\tif (start + len <= found_key.offset)\n\t\t\tgoto not_found;\n\t\tif (start > found_key.offset)\n\t\t\tgoto next;\n\n\t\t/* New extent overlaps with existing one */\n\t\tem->start = start;\n\t\tem->orig_start = start;\n\t\tem->len = found_key.offset - start;\n\t\tem->block_start = EXTENT_MAP_HOLE;\n\t\tgoto insert;\n\t}\n\n\tbtrfs_extent_item_to_extent_map(inode, path, item,\n\t\t\tnew_inline, em);\n\n\tif (extent_type == BTRFS_FILE_EXTENT_REG ||\n\t    extent_type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\tgoto insert;\n\t} else if (extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\tunsigned long ptr;\n\t\tchar *map;\n\t\tsize_t size;\n\t\tsize_t extent_offset;\n\t\tsize_t copy_size;\n\n\t\tif (new_inline)\n\t\t\tgoto out;\n\n\t\tsize = btrfs_file_extent_ram_bytes(leaf, item);\n\t\textent_offset = page_offset(page) + pg_offset - extent_start;\n\t\tcopy_size = min_t(u64, PAGE_SIZE - pg_offset,\n\t\t\t\t  size - extent_offset);\n\t\tem->start = extent_start + extent_offset;\n\t\tem->len = ALIGN(copy_size, fs_info->sectorsize);\n\t\tem->orig_block_len = em->len;\n\t\tem->orig_start = em->start;\n\t\tptr = btrfs_file_extent_inline_start(item) + extent_offset;\n\n\t\tbtrfs_set_path_blocking(path);\n\t\tif (!PageUptodate(page)) {\n\t\t\tif (btrfs_file_extent_compression(leaf, item) !=\n\t\t\t    BTRFS_COMPRESS_NONE) {\n\t\t\t\tret = uncompress_inline(path, page, pg_offset,\n\t\t\t\t\t\t\textent_offset, item);\n\t\t\t\tif (ret) {\n\t\t\t\t\terr = ret;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmap = kmap(page);\n\t\t\t\tread_extent_buffer(leaf, map + pg_offset, ptr,\n\t\t\t\t\t\t   copy_size);\n\t\t\t\tif (pg_offset + copy_size < PAGE_SIZE) {\n\t\t\t\t\tmemset(map + pg_offset + copy_size, 0,\n\t\t\t\t\t       PAGE_SIZE - pg_offset -\n\t\t\t\t\t       copy_size);\n\t\t\t\t}\n\t\t\t\tkunmap(page);\n\t\t\t}\n\t\t\tflush_dcache_page(page);\n\t\t}\n\t\tset_extent_uptodate(io_tree, em->start,\n\t\t\t\t    extent_map_end(em) - 1, NULL, GFP_NOFS);\n\t\tgoto insert;\n\t}\nnot_found:\n\tem->start = start;\n\tem->orig_start = start;\n\tem->len = len;\n\tem->block_start = EXTENT_MAP_HOLE;\ninsert:\n\tbtrfs_release_path(path);\n\tif (em->start > start || extent_map_end(em) <= start) {\n\t\tbtrfs_err(fs_info,\n\t\t\t  \"bad extent! em: [%llu %llu] passed [%llu %llu]\",\n\t\t\t  em->start, em->len, start, len);\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\n\terr = 0;\n\twrite_lock(&em_tree->lock);\n\terr = btrfs_add_extent_mapping(fs_info, em_tree, &em, start, len);\n\twrite_unlock(&em_tree->lock);\nout:\n\tbtrfs_free_path(path);\n\n\ttrace_btrfs_get_extent(root, inode, em);\n\n\tif (err) {\n\t\tfree_extent_map(em);\n\t\treturn ERR_PTR(err);\n\t}\n\tBUG_ON(!em); /* Error is always set */\n\treturn em;\n}",
        "code_after_change": "struct extent_map *btrfs_get_extent(struct btrfs_inode *inode,\n\t\t\t\t    struct page *page,\n\t\t\t\t    size_t pg_offset, u64 start, u64 len,\n\t\t\t\t    int create)\n{\n\tstruct btrfs_fs_info *fs_info = inode->root->fs_info;\n\tint ret;\n\tint err = 0;\n\tu64 extent_start = 0;\n\tu64 extent_end = 0;\n\tu64 objectid = btrfs_ino(inode);\n\tu8 extent_type;\n\tstruct btrfs_path *path = NULL;\n\tstruct btrfs_root *root = inode->root;\n\tstruct btrfs_file_extent_item *item;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key found_key;\n\tstruct extent_map *em = NULL;\n\tstruct extent_map_tree *em_tree = &inode->extent_tree;\n\tstruct extent_io_tree *io_tree = &inode->io_tree;\n\tconst bool new_inline = !page || create;\n\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree, start, len);\n\tif (em)\n\t\tem->bdev = fs_info->fs_devices->latest_bdev;\n\tread_unlock(&em_tree->lock);\n\n\tif (em) {\n\t\tif (em->start > start || em->start + em->len <= start)\n\t\t\tfree_extent_map(em);\n\t\telse if (em->block_start == EXTENT_MAP_INLINE && page)\n\t\t\tfree_extent_map(em);\n\t\telse\n\t\t\tgoto out;\n\t}\n\tem = alloc_extent_map();\n\tif (!em) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\tem->bdev = fs_info->fs_devices->latest_bdev;\n\tem->start = EXTENT_MAP_HOLE;\n\tem->orig_start = EXTENT_MAP_HOLE;\n\tem->len = (u64)-1;\n\tem->block_len = (u64)-1;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/* Chances are we'll be called again, so go ahead and do readahead */\n\tpath->reada = READA_FORWARD;\n\n\t/*\n\t * Unless we're going to uncompress the inline extent, no sleep would\n\t * happen.\n\t */\n\tpath->leave_spinning = 1;\n\n\tret = btrfs_lookup_file_extent(NULL, root, path, objectid, start, 0);\n\tif (ret < 0) {\n\t\terr = ret;\n\t\tgoto out;\n\t} else if (ret > 0) {\n\t\tif (path->slots[0] == 0)\n\t\t\tgoto not_found;\n\t\tpath->slots[0]--;\n\t}\n\n\tleaf = path->nodes[0];\n\titem = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t      struct btrfs_file_extent_item);\n\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\tif (found_key.objectid != objectid ||\n\t    found_key.type != BTRFS_EXTENT_DATA_KEY) {\n\t\t/*\n\t\t * If we backup past the first extent we want to move forward\n\t\t * and see if there is an extent in front of us, otherwise we'll\n\t\t * say there is a hole for our whole search range which can\n\t\t * cause problems.\n\t\t */\n\t\textent_end = start;\n\t\tgoto next;\n\t}\n\n\textent_type = btrfs_file_extent_type(leaf, item);\n\textent_start = found_key.offset;\n\tif (extent_type == BTRFS_FILE_EXTENT_REG ||\n\t    extent_type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\t/* Only regular file could have regular/prealloc extent */\n\t\tif (!S_ISREG(inode->vfs_inode.i_mode)) {\n\t\t\tret = -EUCLEAN;\n\t\t\tbtrfs_crit(fs_info,\n\t\t\"regular/prealloc extent found for non-regular inode %llu\",\n\t\t\t\t   btrfs_ino(inode));\n\t\t\tgoto out;\n\t\t}\n\t\textent_end = extent_start +\n\t\t       btrfs_file_extent_num_bytes(leaf, item);\n\n\t\ttrace_btrfs_get_extent_show_fi_regular(inode, leaf, item,\n\t\t\t\t\t\t       extent_start);\n\t} else if (extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\tsize_t size;\n\n\t\tsize = btrfs_file_extent_ram_bytes(leaf, item);\n\t\textent_end = ALIGN(extent_start + size,\n\t\t\t\t   fs_info->sectorsize);\n\n\t\ttrace_btrfs_get_extent_show_fi_inline(inode, leaf, item,\n\t\t\t\t\t\t      path->slots[0],\n\t\t\t\t\t\t      extent_start);\n\t}\nnext:\n\tif (start >= extent_end) {\n\t\tpath->slots[0]++;\n\t\tif (path->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0) {\n\t\t\t\terr = ret;\n\t\t\t\tgoto out;\n\t\t\t} else if (ret > 0) {\n\t\t\t\tgoto not_found;\n\t\t\t}\n\t\t\tleaf = path->nodes[0];\n\t\t}\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\t\tif (found_key.objectid != objectid ||\n\t\t    found_key.type != BTRFS_EXTENT_DATA_KEY)\n\t\t\tgoto not_found;\n\t\tif (start + len <= found_key.offset)\n\t\t\tgoto not_found;\n\t\tif (start > found_key.offset)\n\t\t\tgoto next;\n\n\t\t/* New extent overlaps with existing one */\n\t\tem->start = start;\n\t\tem->orig_start = start;\n\t\tem->len = found_key.offset - start;\n\t\tem->block_start = EXTENT_MAP_HOLE;\n\t\tgoto insert;\n\t}\n\n\tbtrfs_extent_item_to_extent_map(inode, path, item,\n\t\t\tnew_inline, em);\n\n\tif (extent_type == BTRFS_FILE_EXTENT_REG ||\n\t    extent_type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\tgoto insert;\n\t} else if (extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\tunsigned long ptr;\n\t\tchar *map;\n\t\tsize_t size;\n\t\tsize_t extent_offset;\n\t\tsize_t copy_size;\n\n\t\tif (new_inline)\n\t\t\tgoto out;\n\n\t\tsize = btrfs_file_extent_ram_bytes(leaf, item);\n\t\textent_offset = page_offset(page) + pg_offset - extent_start;\n\t\tcopy_size = min_t(u64, PAGE_SIZE - pg_offset,\n\t\t\t\t  size - extent_offset);\n\t\tem->start = extent_start + extent_offset;\n\t\tem->len = ALIGN(copy_size, fs_info->sectorsize);\n\t\tem->orig_block_len = em->len;\n\t\tem->orig_start = em->start;\n\t\tptr = btrfs_file_extent_inline_start(item) + extent_offset;\n\n\t\tbtrfs_set_path_blocking(path);\n\t\tif (!PageUptodate(page)) {\n\t\t\tif (btrfs_file_extent_compression(leaf, item) !=\n\t\t\t    BTRFS_COMPRESS_NONE) {\n\t\t\t\tret = uncompress_inline(path, page, pg_offset,\n\t\t\t\t\t\t\textent_offset, item);\n\t\t\t\tif (ret) {\n\t\t\t\t\terr = ret;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmap = kmap(page);\n\t\t\t\tread_extent_buffer(leaf, map + pg_offset, ptr,\n\t\t\t\t\t\t   copy_size);\n\t\t\t\tif (pg_offset + copy_size < PAGE_SIZE) {\n\t\t\t\t\tmemset(map + pg_offset + copy_size, 0,\n\t\t\t\t\t       PAGE_SIZE - pg_offset -\n\t\t\t\t\t       copy_size);\n\t\t\t\t}\n\t\t\t\tkunmap(page);\n\t\t\t}\n\t\t\tflush_dcache_page(page);\n\t\t}\n\t\tset_extent_uptodate(io_tree, em->start,\n\t\t\t\t    extent_map_end(em) - 1, NULL, GFP_NOFS);\n\t\tgoto insert;\n\t}\nnot_found:\n\tem->start = start;\n\tem->orig_start = start;\n\tem->len = len;\n\tem->block_start = EXTENT_MAP_HOLE;\ninsert:\n\tbtrfs_release_path(path);\n\tif (em->start > start || extent_map_end(em) <= start) {\n\t\tbtrfs_err(fs_info,\n\t\t\t  \"bad extent! em: [%llu %llu] passed [%llu %llu]\",\n\t\t\t  em->start, em->len, start, len);\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\n\terr = 0;\n\twrite_lock(&em_tree->lock);\n\terr = btrfs_add_extent_mapping(fs_info, em_tree, &em, start, len);\n\twrite_unlock(&em_tree->lock);\nout:\n\tbtrfs_free_path(path);\n\n\ttrace_btrfs_get_extent(root, inode, em);\n\n\tif (err) {\n\t\tfree_extent_map(em);\n\t\treturn ERR_PTR(err);\n\t}\n\tBUG_ON(!em); /* Error is always set */\n\treturn em;\n}",
        "patch": "--- code before\n+++ code after\n@@ -90,6 +90,14 @@\n \textent_start = found_key.offset;\n \tif (extent_type == BTRFS_FILE_EXTENT_REG ||\n \t    extent_type == BTRFS_FILE_EXTENT_PREALLOC) {\n+\t\t/* Only regular file could have regular/prealloc extent */\n+\t\tif (!S_ISREG(inode->vfs_inode.i_mode)) {\n+\t\t\tret = -EUCLEAN;\n+\t\t\tbtrfs_crit(fs_info,\n+\t\t\"regular/prealloc extent found for non-regular inode %llu\",\n+\t\t\t\t   btrfs_ino(inode));\n+\t\t\tgoto out;\n+\t\t}\n \t\textent_end = extent_start +\n \t\t       btrfs_file_extent_num_bytes(leaf, item);\n ",
        "function_modified_lines": {
            "added": [
                "\t\t/* Only regular file could have regular/prealloc extent */",
                "\t\tif (!S_ISREG(inode->vfs_inode.i_mode)) {",
                "\t\t\tret = -EUCLEAN;",
                "\t\t\tbtrfs_crit(fs_info,",
                "\t\t\"regular/prealloc extent found for non-regular inode %llu\",",
                "\t\t\t\t   btrfs_ino(inode));",
                "\t\t\tgoto out;",
                "\t\t}"
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "In the Linux kernel 5.0.21, mounting a crafted btrfs filesystem image and performing some operations can cause slab-out-of-bounds write access in __btrfs_map_block in fs/btrfs/volumes.c, because a value of 1 for the number of data stripes is mishandled.",
        "id": 2256
    },
    {
        "cve_id": "CVE-2019-19816",
        "code_before_change": "static noinline int test_btrfs_get_extent(u32 sectorsize, u32 nodesize)\n{\n\tstruct btrfs_fs_info *fs_info = NULL;\n\tstruct inode *inode = NULL;\n\tstruct btrfs_root *root = NULL;\n\tstruct extent_map *em = NULL;\n\tu64 orig_start;\n\tu64 disk_bytenr;\n\tu64 offset;\n\tint ret = -ENOMEM;\n\n\ttest_msg(\"running btrfs_get_extent tests\");\n\n\tinode = btrfs_new_test_inode();\n\tif (!inode) {\n\t\ttest_std_err(TEST_ALLOC_INODE);\n\t\treturn ret;\n\t}\n\n\tBTRFS_I(inode)->location.type = BTRFS_INODE_ITEM_KEY;\n\tBTRFS_I(inode)->location.objectid = BTRFS_FIRST_FREE_OBJECTID;\n\tBTRFS_I(inode)->location.offset = 0;\n\n\tfs_info = btrfs_alloc_dummy_fs_info(nodesize, sectorsize);\n\tif (!fs_info) {\n\t\ttest_std_err(TEST_ALLOC_FS_INFO);\n\t\tgoto out;\n\t}\n\n\troot = btrfs_alloc_dummy_root(fs_info);\n\tif (IS_ERR(root)) {\n\t\ttest_std_err(TEST_ALLOC_ROOT);\n\t\tgoto out;\n\t}\n\n\troot->node = alloc_dummy_extent_buffer(fs_info, nodesize);\n\tif (!root->node) {\n\t\ttest_std_err(TEST_ALLOC_ROOT);\n\t\tgoto out;\n\t}\n\n\tbtrfs_set_header_nritems(root->node, 0);\n\tbtrfs_set_header_level(root->node, 0);\n\tret = -EINVAL;\n\n\t/* First with no extents */\n\tBTRFS_I(inode)->root = root;\n\tem = btrfs_get_extent(BTRFS_I(inode), NULL, 0, 0, sectorsize, 0);\n\tif (IS_ERR(em)) {\n\t\tem = NULL;\n\t\ttest_err(\"got an error when we shouldn't have\");\n\t\tgoto out;\n\t}\n\tif (em->block_start != EXTENT_MAP_HOLE) {\n\t\ttest_err(\"expected a hole, got %llu\", em->block_start);\n\t\tgoto out;\n\t}\n\tfree_extent_map(em);\n\tbtrfs_drop_extent_cache(BTRFS_I(inode), 0, (u64)-1, 0);\n\n\t/*\n\t * All of the magic numbers are based on the mapping setup in\n\t * setup_file_extents, so if you change anything there you need to\n\t * update the comment and update the expected values below.\n\t */\n\tsetup_file_extents(root, sectorsize);\n\n\tem = btrfs_get_extent(BTRFS_I(inode), NULL, 0, 0, (u64)-1, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_err(\"got an error when we shouldn't have\");\n\t\tgoto out;\n\t}\n\tif (em->block_start != EXTENT_MAP_HOLE) {\n\t\ttest_err(\"expected a hole, got %llu\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != 0 || em->len != 5) {\n\t\ttest_err(\n\t\t\"unexpected extent wanted start 0 len 5, got start %llu len %llu\",\n\t\t\tem->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_err(\"unexpected flags set, want 0 have %lu\", em->flags);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\tem = btrfs_get_extent(BTRFS_I(inode), NULL, 0, offset, sectorsize, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_err(\"got an error when we shouldn't have\");\n\t\tgoto out;\n\t}\n\tif (em->block_start != EXTENT_MAP_INLINE) {\n\t\ttest_err(\"expected an inline, got %llu\", em->block_start);\n\t\tgoto out;\n\t}\n\n\tif (em->start != offset || em->len != (sectorsize - 5)) {\n\t\ttest_err(\n\t\"unexpected extent wanted start %llu len 1, got start %llu len %llu\",\n\t\t\toffset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_err(\"unexpected flags set, want 0 have %lu\", em->flags);\n\t\tgoto out;\n\t}\n\t/*\n\t * We don't test anything else for inline since it doesn't get set\n\t * unless we have a page for it to write into.  Maybe we should change\n\t * this?\n\t */\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\tem = btrfs_get_extent(BTRFS_I(inode), NULL, 0, offset, sectorsize, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_err(\"got an error when we shouldn't have\");\n\t\tgoto out;\n\t}\n\tif (em->block_start != EXTENT_MAP_HOLE) {\n\t\ttest_err(\"expected a hole, got %llu\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 4) {\n\t\ttest_err(\n\t\"unexpected extent wanted start %llu len 4, got start %llu len %llu\",\n\t\t\toffset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_err(\"unexpected flags set, want 0 have %lu\", em->flags);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\t/* Regular extent */\n\tem = btrfs_get_extent(BTRFS_I(inode), NULL, 0, offset, sectorsize, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_err(\"got an error when we shouldn't have\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\ttest_err(\"expected a real extent, got %llu\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != sectorsize - 1) {\n\t\ttest_err(\n\t\"unexpected extent wanted start %llu len 4095, got start %llu len %llu\",\n\t\t\toffset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_err(\"unexpected flags set, want 0 have %lu\", em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != em->start) {\n\t\ttest_err(\"wrong orig offset, want %llu, have %llu\", em->start,\n\t\t\t em->orig_start);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\t/* The next 3 are split extents */\n\tem = btrfs_get_extent(BTRFS_I(inode), NULL, 0, offset, sectorsize, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_err(\"got an error when we shouldn't have\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\ttest_err(\"expected a real extent, got %llu\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != sectorsize) {\n\t\ttest_err(\n\t\t\"unexpected extent start %llu len %u, got start %llu len %llu\",\n\t\t\toffset, sectorsize, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_err(\"unexpected flags set, want 0 have %lu\", em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != em->start) {\n\t\ttest_err(\"wrong orig offset, want %llu, have %llu\", em->start,\n\t\t\t em->orig_start);\n\t\tgoto out;\n\t}\n\tdisk_bytenr = em->block_start;\n\torig_start = em->start;\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\tem = btrfs_get_extent(BTRFS_I(inode), NULL, 0, offset, sectorsize, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_err(\"got an error when we shouldn't have\");\n\t\tgoto out;\n\t}\n\tif (em->block_start != EXTENT_MAP_HOLE) {\n\t\ttest_err(\"expected a hole, got %llu\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != sectorsize) {\n\t\ttest_err(\n\t\"unexpected extent wanted start %llu len %u, got start %llu len %llu\",\n\t\t\toffset, sectorsize, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_err(\"unexpected flags set, want 0 have %lu\", em->flags);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\tem = btrfs_get_extent(BTRFS_I(inode), NULL, 0, offset, sectorsize, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_err(\"got an error when we shouldn't have\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\ttest_err(\"expected a real extent, got %llu\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 2 * sectorsize) {\n\t\ttest_err(\n\t\"unexpected extent wanted start %llu len %u, got start %llu len %llu\",\n\t\t\toffset, 2 * sectorsize, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_err(\"unexpected flags set, want 0 have %lu\", em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != orig_start) {\n\t\ttest_err(\"wrong orig offset, want %llu, have %llu\",\n\t\t\t orig_start, em->orig_start);\n\t\tgoto out;\n\t}\n\tdisk_bytenr += (em->start - orig_start);\n\tif (em->block_start != disk_bytenr) {\n\t\ttest_err(\"wrong block start, want %llu, have %llu\",\n\t\t\t disk_bytenr, em->block_start);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\t/* Prealloc extent */\n\tem = btrfs_get_extent(BTRFS_I(inode), NULL, 0, offset, sectorsize, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_err(\"got an error when we shouldn't have\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\ttest_err(\"expected a real extent, got %llu\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != sectorsize) {\n\t\ttest_err(\n\t\"unexpected extent wanted start %llu len %u, got start %llu len %llu\",\n\t\t\toffset, sectorsize, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != prealloc_only) {\n\t\ttest_err(\"unexpected flags set, want %lu have %lu\",\n\t\t\t prealloc_only, em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != em->start) {\n\t\ttest_err(\"wrong orig offset, want %llu, have %llu\", em->start,\n\t\t\t em->orig_start);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\t/* The next 3 are a half written prealloc extent */\n\tem = btrfs_get_extent(BTRFS_I(inode), NULL, 0, offset, sectorsize, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_err(\"got an error when we shouldn't have\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\ttest_err(\"expected a real extent, got %llu\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != sectorsize) {\n\t\ttest_err(\n\t\"unexpected extent wanted start %llu len %u, got start %llu len %llu\",\n\t\t\toffset, sectorsize, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != prealloc_only) {\n\t\ttest_err(\"unexpected flags set, want %lu have %lu\",\n\t\t\t prealloc_only, em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != em->start) {\n\t\ttest_err(\"wrong orig offset, want %llu, have %llu\", em->start,\n\t\t\t em->orig_start);\n\t\tgoto out;\n\t}\n\tdisk_bytenr = em->block_start;\n\torig_start = em->start;\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\tem = btrfs_get_extent(BTRFS_I(inode), NULL, 0, offset, sectorsize, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_err(\"got an error when we shouldn't have\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_HOLE) {\n\t\ttest_err(\"expected a real extent, got %llu\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != sectorsize) {\n\t\ttest_err(\n\t\"unexpected extent wanted start %llu len %u, got start %llu len %llu\",\n\t\t\toffset, sectorsize, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_err(\"unexpected flags set, want 0 have %lu\", em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != orig_start) {\n\t\ttest_err(\"unexpected orig offset, wanted %llu, have %llu\",\n\t\t\t orig_start, em->orig_start);\n\t\tgoto out;\n\t}\n\tif (em->block_start != (disk_bytenr + (em->start - em->orig_start))) {\n\t\ttest_err(\"unexpected block start, wanted %llu, have %llu\",\n\t\t\t disk_bytenr + (em->start - em->orig_start),\n\t\t\t em->block_start);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\tem = btrfs_get_extent(BTRFS_I(inode), NULL, 0, offset, sectorsize, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_err(\"got an error when we shouldn't have\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\ttest_err(\"expected a real extent, got %llu\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 2 * sectorsize) {\n\t\ttest_err(\n\t\"unexpected extent wanted start %llu len %u, got start %llu len %llu\",\n\t\t\toffset, 2 * sectorsize, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != prealloc_only) {\n\t\ttest_err(\"unexpected flags set, want %lu have %lu\",\n\t\t\t prealloc_only, em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != orig_start) {\n\t\ttest_err(\"wrong orig offset, want %llu, have %llu\", orig_start,\n\t\t\t em->orig_start);\n\t\tgoto out;\n\t}\n\tif (em->block_start != (disk_bytenr + (em->start - em->orig_start))) {\n\t\ttest_err(\"unexpected block start, wanted %llu, have %llu\",\n\t\t\t disk_bytenr + (em->start - em->orig_start),\n\t\t\t em->block_start);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\t/* Now for the compressed extent */\n\tem = btrfs_get_extent(BTRFS_I(inode), NULL, 0, offset, sectorsize, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_err(\"got an error when we shouldn't have\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\ttest_err(\"expected a real extent, got %llu\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 2 * sectorsize) {\n\t\ttest_err(\n\t\"unexpected extent wanted start %llu len %u, got start %llu len %llu\",\n\t\t\toffset, 2 * sectorsize, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != compressed_only) {\n\t\ttest_err(\"unexpected flags set, want %lu have %lu\",\n\t\t\t compressed_only, em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != em->start) {\n\t\ttest_err(\"wrong orig offset, want %llu, have %llu\",\n\t\t\t em->start, em->orig_start);\n\t\tgoto out;\n\t}\n\tif (em->compress_type != BTRFS_COMPRESS_ZLIB) {\n\t\ttest_err(\"unexpected compress type, wanted %d, got %d\",\n\t\t\t BTRFS_COMPRESS_ZLIB, em->compress_type);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\t/* Split compressed extent */\n\tem = btrfs_get_extent(BTRFS_I(inode), NULL, 0, offset, sectorsize, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_err(\"got an error when we shouldn't have\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\ttest_err(\"expected a real extent, got %llu\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != sectorsize) {\n\t\ttest_err(\n\t\"unexpected extent wanted start %llu len %u, got start %llu len %llu\",\n\t\t\toffset, sectorsize, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != compressed_only) {\n\t\ttest_err(\"unexpected flags set, want %lu have %lu\",\n\t\t\t compressed_only, em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != em->start) {\n\t\ttest_err(\"wrong orig offset, want %llu, have %llu\",\n\t\t\t em->start, em->orig_start);\n\t\tgoto out;\n\t}\n\tif (em->compress_type != BTRFS_COMPRESS_ZLIB) {\n\t\ttest_err(\"unexpected compress type, wanted %d, got %d\",\n\t\t\t BTRFS_COMPRESS_ZLIB, em->compress_type);\n\t\tgoto out;\n\t}\n\tdisk_bytenr = em->block_start;\n\torig_start = em->start;\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\tem = btrfs_get_extent(BTRFS_I(inode), NULL, 0, offset, sectorsize, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_err(\"got an error when we shouldn't have\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\ttest_err(\"expected a real extent, got %llu\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != sectorsize) {\n\t\ttest_err(\n\t\"unexpected extent wanted start %llu len %u, got start %llu len %llu\",\n\t\t\toffset, sectorsize, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_err(\"unexpected flags set, want 0 have %lu\", em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != em->start) {\n\t\ttest_err(\"wrong orig offset, want %llu, have %llu\", em->start,\n\t\t\t em->orig_start);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\tem = btrfs_get_extent(BTRFS_I(inode), NULL, 0, offset, sectorsize, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_err(\"got an error when we shouldn't have\");\n\t\tgoto out;\n\t}\n\tif (em->block_start != disk_bytenr) {\n\t\ttest_err(\"block start does not match, want %llu got %llu\",\n\t\t\t disk_bytenr, em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 2 * sectorsize) {\n\t\ttest_err(\n\t\"unexpected extent wanted start %llu len %u, got start %llu len %llu\",\n\t\t\toffset, 2 * sectorsize, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != compressed_only) {\n\t\ttest_err(\"unexpected flags set, want %lu have %lu\",\n\t\t\t compressed_only, em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != orig_start) {\n\t\ttest_err(\"wrong orig offset, want %llu, have %llu\",\n\t\t\t em->start, orig_start);\n\t\tgoto out;\n\t}\n\tif (em->compress_type != BTRFS_COMPRESS_ZLIB) {\n\t\ttest_err(\"unexpected compress type, wanted %d, got %d\",\n\t\t\t BTRFS_COMPRESS_ZLIB, em->compress_type);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\t/* A hole between regular extents but no hole extent */\n\tem = btrfs_get_extent(BTRFS_I(inode), NULL, 0, offset + 6,\n\t\t\tsectorsize, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_err(\"got an error when we shouldn't have\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\ttest_err(\"expected a real extent, got %llu\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != sectorsize) {\n\t\ttest_err(\n\t\"unexpected extent wanted start %llu len %u, got start %llu len %llu\",\n\t\t\toffset, sectorsize, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_err(\"unexpected flags set, want 0 have %lu\", em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != em->start) {\n\t\ttest_err(\"wrong orig offset, want %llu, have %llu\", em->start,\n\t\t\t em->orig_start);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\tem = btrfs_get_extent(BTRFS_I(inode), NULL, 0, offset, SZ_4M, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_err(\"got an error when we shouldn't have\");\n\t\tgoto out;\n\t}\n\tif (em->block_start != EXTENT_MAP_HOLE) {\n\t\ttest_err(\"expected a hole extent, got %llu\", em->block_start);\n\t\tgoto out;\n\t}\n\t/*\n\t * Currently we just return a length that we requested rather than the\n\t * length of the actual hole, if this changes we'll have to change this\n\t * test.\n\t */\n\tif (em->start != offset || em->len != 3 * sectorsize) {\n\t\ttest_err(\n\t\"unexpected extent wanted start %llu len %u, got start %llu len %llu\",\n\t\t\toffset, 3 * sectorsize, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != vacancy_only) {\n\t\ttest_err(\"unexpected flags set, want %lu have %lu\",\n\t\t\t vacancy_only, em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != em->start) {\n\t\ttest_err(\"wrong orig offset, want %llu, have %llu\", em->start,\n\t\t\t em->orig_start);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\tem = btrfs_get_extent(BTRFS_I(inode), NULL, 0, offset, sectorsize, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_err(\"got an error when we shouldn't have\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\ttest_err(\"expected a real extent, got %llu\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != sectorsize) {\n\t\ttest_err(\n\t\"unexpected extent wanted start %llu len %u, got start %llu len %llu\",\n\t\t\toffset, sectorsize, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_err(\"unexpected flags set, want 0 have %lu\", em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != em->start) {\n\t\ttest_err(\"wrong orig offset, want %llu, have %llu\", em->start,\n\t\t\t em->orig_start);\n\t\tgoto out;\n\t}\n\tret = 0;\nout:\n\tif (!IS_ERR(em))\n\t\tfree_extent_map(em);\n\tiput(inode);\n\tbtrfs_free_dummy_root(root);\n\tbtrfs_free_dummy_fs_info(fs_info);\n\treturn ret;\n}",
        "code_after_change": "static noinline int test_btrfs_get_extent(u32 sectorsize, u32 nodesize)\n{\n\tstruct btrfs_fs_info *fs_info = NULL;\n\tstruct inode *inode = NULL;\n\tstruct btrfs_root *root = NULL;\n\tstruct extent_map *em = NULL;\n\tu64 orig_start;\n\tu64 disk_bytenr;\n\tu64 offset;\n\tint ret = -ENOMEM;\n\n\ttest_msg(\"running btrfs_get_extent tests\");\n\n\tinode = btrfs_new_test_inode();\n\tif (!inode) {\n\t\ttest_std_err(TEST_ALLOC_INODE);\n\t\treturn ret;\n\t}\n\n\tinode->i_mode = S_IFREG;\n\tBTRFS_I(inode)->location.type = BTRFS_INODE_ITEM_KEY;\n\tBTRFS_I(inode)->location.objectid = BTRFS_FIRST_FREE_OBJECTID;\n\tBTRFS_I(inode)->location.offset = 0;\n\n\tfs_info = btrfs_alloc_dummy_fs_info(nodesize, sectorsize);\n\tif (!fs_info) {\n\t\ttest_std_err(TEST_ALLOC_FS_INFO);\n\t\tgoto out;\n\t}\n\n\troot = btrfs_alloc_dummy_root(fs_info);\n\tif (IS_ERR(root)) {\n\t\ttest_std_err(TEST_ALLOC_ROOT);\n\t\tgoto out;\n\t}\n\n\troot->node = alloc_dummy_extent_buffer(fs_info, nodesize);\n\tif (!root->node) {\n\t\ttest_std_err(TEST_ALLOC_ROOT);\n\t\tgoto out;\n\t}\n\n\tbtrfs_set_header_nritems(root->node, 0);\n\tbtrfs_set_header_level(root->node, 0);\n\tret = -EINVAL;\n\n\t/* First with no extents */\n\tBTRFS_I(inode)->root = root;\n\tem = btrfs_get_extent(BTRFS_I(inode), NULL, 0, 0, sectorsize, 0);\n\tif (IS_ERR(em)) {\n\t\tem = NULL;\n\t\ttest_err(\"got an error when we shouldn't have\");\n\t\tgoto out;\n\t}\n\tif (em->block_start != EXTENT_MAP_HOLE) {\n\t\ttest_err(\"expected a hole, got %llu\", em->block_start);\n\t\tgoto out;\n\t}\n\tfree_extent_map(em);\n\tbtrfs_drop_extent_cache(BTRFS_I(inode), 0, (u64)-1, 0);\n\n\t/*\n\t * All of the magic numbers are based on the mapping setup in\n\t * setup_file_extents, so if you change anything there you need to\n\t * update the comment and update the expected values below.\n\t */\n\tsetup_file_extents(root, sectorsize);\n\n\tem = btrfs_get_extent(BTRFS_I(inode), NULL, 0, 0, (u64)-1, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_err(\"got an error when we shouldn't have\");\n\t\tgoto out;\n\t}\n\tif (em->block_start != EXTENT_MAP_HOLE) {\n\t\ttest_err(\"expected a hole, got %llu\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != 0 || em->len != 5) {\n\t\ttest_err(\n\t\t\"unexpected extent wanted start 0 len 5, got start %llu len %llu\",\n\t\t\tem->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_err(\"unexpected flags set, want 0 have %lu\", em->flags);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\tem = btrfs_get_extent(BTRFS_I(inode), NULL, 0, offset, sectorsize, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_err(\"got an error when we shouldn't have\");\n\t\tgoto out;\n\t}\n\tif (em->block_start != EXTENT_MAP_INLINE) {\n\t\ttest_err(\"expected an inline, got %llu\", em->block_start);\n\t\tgoto out;\n\t}\n\n\tif (em->start != offset || em->len != (sectorsize - 5)) {\n\t\ttest_err(\n\t\"unexpected extent wanted start %llu len 1, got start %llu len %llu\",\n\t\t\toffset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_err(\"unexpected flags set, want 0 have %lu\", em->flags);\n\t\tgoto out;\n\t}\n\t/*\n\t * We don't test anything else for inline since it doesn't get set\n\t * unless we have a page for it to write into.  Maybe we should change\n\t * this?\n\t */\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\tem = btrfs_get_extent(BTRFS_I(inode), NULL, 0, offset, sectorsize, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_err(\"got an error when we shouldn't have\");\n\t\tgoto out;\n\t}\n\tif (em->block_start != EXTENT_MAP_HOLE) {\n\t\ttest_err(\"expected a hole, got %llu\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 4) {\n\t\ttest_err(\n\t\"unexpected extent wanted start %llu len 4, got start %llu len %llu\",\n\t\t\toffset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_err(\"unexpected flags set, want 0 have %lu\", em->flags);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\t/* Regular extent */\n\tem = btrfs_get_extent(BTRFS_I(inode), NULL, 0, offset, sectorsize, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_err(\"got an error when we shouldn't have\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\ttest_err(\"expected a real extent, got %llu\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != sectorsize - 1) {\n\t\ttest_err(\n\t\"unexpected extent wanted start %llu len 4095, got start %llu len %llu\",\n\t\t\toffset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_err(\"unexpected flags set, want 0 have %lu\", em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != em->start) {\n\t\ttest_err(\"wrong orig offset, want %llu, have %llu\", em->start,\n\t\t\t em->orig_start);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\t/* The next 3 are split extents */\n\tem = btrfs_get_extent(BTRFS_I(inode), NULL, 0, offset, sectorsize, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_err(\"got an error when we shouldn't have\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\ttest_err(\"expected a real extent, got %llu\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != sectorsize) {\n\t\ttest_err(\n\t\t\"unexpected extent start %llu len %u, got start %llu len %llu\",\n\t\t\toffset, sectorsize, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_err(\"unexpected flags set, want 0 have %lu\", em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != em->start) {\n\t\ttest_err(\"wrong orig offset, want %llu, have %llu\", em->start,\n\t\t\t em->orig_start);\n\t\tgoto out;\n\t}\n\tdisk_bytenr = em->block_start;\n\torig_start = em->start;\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\tem = btrfs_get_extent(BTRFS_I(inode), NULL, 0, offset, sectorsize, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_err(\"got an error when we shouldn't have\");\n\t\tgoto out;\n\t}\n\tif (em->block_start != EXTENT_MAP_HOLE) {\n\t\ttest_err(\"expected a hole, got %llu\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != sectorsize) {\n\t\ttest_err(\n\t\"unexpected extent wanted start %llu len %u, got start %llu len %llu\",\n\t\t\toffset, sectorsize, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_err(\"unexpected flags set, want 0 have %lu\", em->flags);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\tem = btrfs_get_extent(BTRFS_I(inode), NULL, 0, offset, sectorsize, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_err(\"got an error when we shouldn't have\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\ttest_err(\"expected a real extent, got %llu\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 2 * sectorsize) {\n\t\ttest_err(\n\t\"unexpected extent wanted start %llu len %u, got start %llu len %llu\",\n\t\t\toffset, 2 * sectorsize, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_err(\"unexpected flags set, want 0 have %lu\", em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != orig_start) {\n\t\ttest_err(\"wrong orig offset, want %llu, have %llu\",\n\t\t\t orig_start, em->orig_start);\n\t\tgoto out;\n\t}\n\tdisk_bytenr += (em->start - orig_start);\n\tif (em->block_start != disk_bytenr) {\n\t\ttest_err(\"wrong block start, want %llu, have %llu\",\n\t\t\t disk_bytenr, em->block_start);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\t/* Prealloc extent */\n\tem = btrfs_get_extent(BTRFS_I(inode), NULL, 0, offset, sectorsize, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_err(\"got an error when we shouldn't have\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\ttest_err(\"expected a real extent, got %llu\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != sectorsize) {\n\t\ttest_err(\n\t\"unexpected extent wanted start %llu len %u, got start %llu len %llu\",\n\t\t\toffset, sectorsize, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != prealloc_only) {\n\t\ttest_err(\"unexpected flags set, want %lu have %lu\",\n\t\t\t prealloc_only, em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != em->start) {\n\t\ttest_err(\"wrong orig offset, want %llu, have %llu\", em->start,\n\t\t\t em->orig_start);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\t/* The next 3 are a half written prealloc extent */\n\tem = btrfs_get_extent(BTRFS_I(inode), NULL, 0, offset, sectorsize, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_err(\"got an error when we shouldn't have\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\ttest_err(\"expected a real extent, got %llu\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != sectorsize) {\n\t\ttest_err(\n\t\"unexpected extent wanted start %llu len %u, got start %llu len %llu\",\n\t\t\toffset, sectorsize, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != prealloc_only) {\n\t\ttest_err(\"unexpected flags set, want %lu have %lu\",\n\t\t\t prealloc_only, em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != em->start) {\n\t\ttest_err(\"wrong orig offset, want %llu, have %llu\", em->start,\n\t\t\t em->orig_start);\n\t\tgoto out;\n\t}\n\tdisk_bytenr = em->block_start;\n\torig_start = em->start;\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\tem = btrfs_get_extent(BTRFS_I(inode), NULL, 0, offset, sectorsize, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_err(\"got an error when we shouldn't have\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_HOLE) {\n\t\ttest_err(\"expected a real extent, got %llu\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != sectorsize) {\n\t\ttest_err(\n\t\"unexpected extent wanted start %llu len %u, got start %llu len %llu\",\n\t\t\toffset, sectorsize, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_err(\"unexpected flags set, want 0 have %lu\", em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != orig_start) {\n\t\ttest_err(\"unexpected orig offset, wanted %llu, have %llu\",\n\t\t\t orig_start, em->orig_start);\n\t\tgoto out;\n\t}\n\tif (em->block_start != (disk_bytenr + (em->start - em->orig_start))) {\n\t\ttest_err(\"unexpected block start, wanted %llu, have %llu\",\n\t\t\t disk_bytenr + (em->start - em->orig_start),\n\t\t\t em->block_start);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\tem = btrfs_get_extent(BTRFS_I(inode), NULL, 0, offset, sectorsize, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_err(\"got an error when we shouldn't have\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\ttest_err(\"expected a real extent, got %llu\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 2 * sectorsize) {\n\t\ttest_err(\n\t\"unexpected extent wanted start %llu len %u, got start %llu len %llu\",\n\t\t\toffset, 2 * sectorsize, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != prealloc_only) {\n\t\ttest_err(\"unexpected flags set, want %lu have %lu\",\n\t\t\t prealloc_only, em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != orig_start) {\n\t\ttest_err(\"wrong orig offset, want %llu, have %llu\", orig_start,\n\t\t\t em->orig_start);\n\t\tgoto out;\n\t}\n\tif (em->block_start != (disk_bytenr + (em->start - em->orig_start))) {\n\t\ttest_err(\"unexpected block start, wanted %llu, have %llu\",\n\t\t\t disk_bytenr + (em->start - em->orig_start),\n\t\t\t em->block_start);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\t/* Now for the compressed extent */\n\tem = btrfs_get_extent(BTRFS_I(inode), NULL, 0, offset, sectorsize, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_err(\"got an error when we shouldn't have\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\ttest_err(\"expected a real extent, got %llu\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 2 * sectorsize) {\n\t\ttest_err(\n\t\"unexpected extent wanted start %llu len %u, got start %llu len %llu\",\n\t\t\toffset, 2 * sectorsize, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != compressed_only) {\n\t\ttest_err(\"unexpected flags set, want %lu have %lu\",\n\t\t\t compressed_only, em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != em->start) {\n\t\ttest_err(\"wrong orig offset, want %llu, have %llu\",\n\t\t\t em->start, em->orig_start);\n\t\tgoto out;\n\t}\n\tif (em->compress_type != BTRFS_COMPRESS_ZLIB) {\n\t\ttest_err(\"unexpected compress type, wanted %d, got %d\",\n\t\t\t BTRFS_COMPRESS_ZLIB, em->compress_type);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\t/* Split compressed extent */\n\tem = btrfs_get_extent(BTRFS_I(inode), NULL, 0, offset, sectorsize, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_err(\"got an error when we shouldn't have\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\ttest_err(\"expected a real extent, got %llu\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != sectorsize) {\n\t\ttest_err(\n\t\"unexpected extent wanted start %llu len %u, got start %llu len %llu\",\n\t\t\toffset, sectorsize, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != compressed_only) {\n\t\ttest_err(\"unexpected flags set, want %lu have %lu\",\n\t\t\t compressed_only, em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != em->start) {\n\t\ttest_err(\"wrong orig offset, want %llu, have %llu\",\n\t\t\t em->start, em->orig_start);\n\t\tgoto out;\n\t}\n\tif (em->compress_type != BTRFS_COMPRESS_ZLIB) {\n\t\ttest_err(\"unexpected compress type, wanted %d, got %d\",\n\t\t\t BTRFS_COMPRESS_ZLIB, em->compress_type);\n\t\tgoto out;\n\t}\n\tdisk_bytenr = em->block_start;\n\torig_start = em->start;\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\tem = btrfs_get_extent(BTRFS_I(inode), NULL, 0, offset, sectorsize, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_err(\"got an error when we shouldn't have\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\ttest_err(\"expected a real extent, got %llu\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != sectorsize) {\n\t\ttest_err(\n\t\"unexpected extent wanted start %llu len %u, got start %llu len %llu\",\n\t\t\toffset, sectorsize, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_err(\"unexpected flags set, want 0 have %lu\", em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != em->start) {\n\t\ttest_err(\"wrong orig offset, want %llu, have %llu\", em->start,\n\t\t\t em->orig_start);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\tem = btrfs_get_extent(BTRFS_I(inode), NULL, 0, offset, sectorsize, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_err(\"got an error when we shouldn't have\");\n\t\tgoto out;\n\t}\n\tif (em->block_start != disk_bytenr) {\n\t\ttest_err(\"block start does not match, want %llu got %llu\",\n\t\t\t disk_bytenr, em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 2 * sectorsize) {\n\t\ttest_err(\n\t\"unexpected extent wanted start %llu len %u, got start %llu len %llu\",\n\t\t\toffset, 2 * sectorsize, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != compressed_only) {\n\t\ttest_err(\"unexpected flags set, want %lu have %lu\",\n\t\t\t compressed_only, em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != orig_start) {\n\t\ttest_err(\"wrong orig offset, want %llu, have %llu\",\n\t\t\t em->start, orig_start);\n\t\tgoto out;\n\t}\n\tif (em->compress_type != BTRFS_COMPRESS_ZLIB) {\n\t\ttest_err(\"unexpected compress type, wanted %d, got %d\",\n\t\t\t BTRFS_COMPRESS_ZLIB, em->compress_type);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\t/* A hole between regular extents but no hole extent */\n\tem = btrfs_get_extent(BTRFS_I(inode), NULL, 0, offset + 6,\n\t\t\tsectorsize, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_err(\"got an error when we shouldn't have\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\ttest_err(\"expected a real extent, got %llu\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != sectorsize) {\n\t\ttest_err(\n\t\"unexpected extent wanted start %llu len %u, got start %llu len %llu\",\n\t\t\toffset, sectorsize, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_err(\"unexpected flags set, want 0 have %lu\", em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != em->start) {\n\t\ttest_err(\"wrong orig offset, want %llu, have %llu\", em->start,\n\t\t\t em->orig_start);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\tem = btrfs_get_extent(BTRFS_I(inode), NULL, 0, offset, SZ_4M, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_err(\"got an error when we shouldn't have\");\n\t\tgoto out;\n\t}\n\tif (em->block_start != EXTENT_MAP_HOLE) {\n\t\ttest_err(\"expected a hole extent, got %llu\", em->block_start);\n\t\tgoto out;\n\t}\n\t/*\n\t * Currently we just return a length that we requested rather than the\n\t * length of the actual hole, if this changes we'll have to change this\n\t * test.\n\t */\n\tif (em->start != offset || em->len != 3 * sectorsize) {\n\t\ttest_err(\n\t\"unexpected extent wanted start %llu len %u, got start %llu len %llu\",\n\t\t\toffset, 3 * sectorsize, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != vacancy_only) {\n\t\ttest_err(\"unexpected flags set, want %lu have %lu\",\n\t\t\t vacancy_only, em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != em->start) {\n\t\ttest_err(\"wrong orig offset, want %llu, have %llu\", em->start,\n\t\t\t em->orig_start);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\tem = btrfs_get_extent(BTRFS_I(inode), NULL, 0, offset, sectorsize, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_err(\"got an error when we shouldn't have\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\ttest_err(\"expected a real extent, got %llu\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != sectorsize) {\n\t\ttest_err(\n\t\"unexpected extent wanted start %llu len %u, got start %llu len %llu\",\n\t\t\toffset, sectorsize, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_err(\"unexpected flags set, want 0 have %lu\", em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != em->start) {\n\t\ttest_err(\"wrong orig offset, want %llu, have %llu\", em->start,\n\t\t\t em->orig_start);\n\t\tgoto out;\n\t}\n\tret = 0;\nout:\n\tif (!IS_ERR(em))\n\t\tfree_extent_map(em);\n\tiput(inode);\n\tbtrfs_free_dummy_root(root);\n\tbtrfs_free_dummy_fs_info(fs_info);\n\treturn ret;\n}",
        "patch": "--- code before\n+++ code after\n@@ -17,6 +17,7 @@\n \t\treturn ret;\n \t}\n \n+\tinode->i_mode = S_IFREG;\n \tBTRFS_I(inode)->location.type = BTRFS_INODE_ITEM_KEY;\n \tBTRFS_I(inode)->location.objectid = BTRFS_FIRST_FREE_OBJECTID;\n \tBTRFS_I(inode)->location.offset = 0;",
        "function_modified_lines": {
            "added": [
                "\tinode->i_mode = S_IFREG;"
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "In the Linux kernel 5.0.21, mounting a crafted btrfs filesystem image and performing some operations can cause slab-out-of-bounds write access in __btrfs_map_block in fs/btrfs/volumes.c, because a value of 1 for the number of data stripes is mishandled.",
        "id": 2257
    },
    {
        "cve_id": "CVE-2019-19532",
        "code_before_change": "static int emsff_init(struct hid_device *hid)\n{\n\tstruct emsff_device *emsff;\n\tstruct hid_report *report;\n\tstruct hid_input *hidinput = list_first_entry(&hid->inputs,\n\t\t\t\t\t\tstruct hid_input, list);\n\tstruct list_head *report_list =\n\t\t\t&hid->report_enum[HID_OUTPUT_REPORT].report_list;\n\tstruct input_dev *dev = hidinput->input;\n\tint error;\n\n\tif (list_empty(report_list)) {\n\t\thid_err(hid, \"no output reports found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treport = list_first_entry(report_list, struct hid_report, list);\n\tif (report->maxfield < 1) {\n\t\thid_err(hid, \"no fields in the report\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (report->field[0]->report_count < 7) {\n\t\thid_err(hid, \"not enough values in the field\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\temsff = kzalloc(sizeof(struct emsff_device), GFP_KERNEL);\n\tif (!emsff)\n\t\treturn -ENOMEM;\n\n\tset_bit(FF_RUMBLE, dev->ffbit);\n\n\terror = input_ff_create_memless(dev, emsff, emsff_play);\n\tif (error) {\n\t\tkfree(emsff);\n\t\treturn error;\n\t}\n\n\temsff->report = report;\n\temsff->report->field[0]->value[0] = 0x01;\n\temsff->report->field[0]->value[1] = 0x00;\n\temsff->report->field[0]->value[2] = 0x00;\n\temsff->report->field[0]->value[3] = 0x00;\n\temsff->report->field[0]->value[4] = 0x00;\n\temsff->report->field[0]->value[5] = 0x00;\n\temsff->report->field[0]->value[6] = 0x00;\n\thid_hw_request(hid, emsff->report, HID_REQ_SET_REPORT);\n\n\thid_info(hid, \"force feedback for EMS based devices by Ignaz Forster <ignaz.forster@gmx.de>\\n\");\n\n\treturn 0;\n}",
        "code_after_change": "static int emsff_init(struct hid_device *hid)\n{\n\tstruct emsff_device *emsff;\n\tstruct hid_report *report;\n\tstruct hid_input *hidinput;\n\tstruct list_head *report_list =\n\t\t\t&hid->report_enum[HID_OUTPUT_REPORT].report_list;\n\tstruct input_dev *dev;\n\tint error;\n\n\tif (list_empty(&hid->inputs)) {\n\t\thid_err(hid, \"no inputs found\\n\");\n\t\treturn -ENODEV;\n\t}\n\thidinput = list_first_entry(&hid->inputs, struct hid_input, list);\n\tdev = hidinput->input;\n\n\tif (list_empty(report_list)) {\n\t\thid_err(hid, \"no output reports found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treport = list_first_entry(report_list, struct hid_report, list);\n\tif (report->maxfield < 1) {\n\t\thid_err(hid, \"no fields in the report\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (report->field[0]->report_count < 7) {\n\t\thid_err(hid, \"not enough values in the field\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\temsff = kzalloc(sizeof(struct emsff_device), GFP_KERNEL);\n\tif (!emsff)\n\t\treturn -ENOMEM;\n\n\tset_bit(FF_RUMBLE, dev->ffbit);\n\n\terror = input_ff_create_memless(dev, emsff, emsff_play);\n\tif (error) {\n\t\tkfree(emsff);\n\t\treturn error;\n\t}\n\n\temsff->report = report;\n\temsff->report->field[0]->value[0] = 0x01;\n\temsff->report->field[0]->value[1] = 0x00;\n\temsff->report->field[0]->value[2] = 0x00;\n\temsff->report->field[0]->value[3] = 0x00;\n\temsff->report->field[0]->value[4] = 0x00;\n\temsff->report->field[0]->value[5] = 0x00;\n\temsff->report->field[0]->value[6] = 0x00;\n\thid_hw_request(hid, emsff->report, HID_REQ_SET_REPORT);\n\n\thid_info(hid, \"force feedback for EMS based devices by Ignaz Forster <ignaz.forster@gmx.de>\\n\");\n\n\treturn 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -2,12 +2,18 @@\n {\n \tstruct emsff_device *emsff;\n \tstruct hid_report *report;\n-\tstruct hid_input *hidinput = list_first_entry(&hid->inputs,\n-\t\t\t\t\t\tstruct hid_input, list);\n+\tstruct hid_input *hidinput;\n \tstruct list_head *report_list =\n \t\t\t&hid->report_enum[HID_OUTPUT_REPORT].report_list;\n-\tstruct input_dev *dev = hidinput->input;\n+\tstruct input_dev *dev;\n \tint error;\n+\n+\tif (list_empty(&hid->inputs)) {\n+\t\thid_err(hid, \"no inputs found\\n\");\n+\t\treturn -ENODEV;\n+\t}\n+\thidinput = list_first_entry(&hid->inputs, struct hid_input, list);\n+\tdev = hidinput->input;\n \n \tif (list_empty(report_list)) {\n \t\thid_err(hid, \"no output reports found\\n\");",
        "function_modified_lines": {
            "added": [
                "\tstruct hid_input *hidinput;",
                "\tstruct input_dev *dev;",
                "",
                "\tif (list_empty(&hid->inputs)) {",
                "\t\thid_err(hid, \"no inputs found\\n\");",
                "\t\treturn -ENODEV;",
                "\t}",
                "\thidinput = list_first_entry(&hid->inputs, struct hid_input, list);",
                "\tdev = hidinput->input;"
            ],
            "deleted": [
                "\tstruct hid_input *hidinput = list_first_entry(&hid->inputs,",
                "\t\t\t\t\t\tstruct hid_input, list);",
                "\tstruct input_dev *dev = hidinput->input;"
            ]
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "In the Linux kernel before 5.3.9, there are multiple out-of-bounds write bugs that can be caused by a malicious USB device in the Linux kernel HID drivers, aka CID-d9d4b1e46d95. This affects drivers/hid/hid-axff.c, drivers/hid/hid-dr.c, drivers/hid/hid-emsff.c, drivers/hid/hid-gaff.c, drivers/hid/hid-holtekff.c, drivers/hid/hid-lg2ff.c, drivers/hid/hid-lg3ff.c, drivers/hid/hid-lg4ff.c, drivers/hid/hid-lgff.c, drivers/hid/hid-logitech-hidpp.c, drivers/hid/hid-microsoft.c, drivers/hid/hid-sony.c, drivers/hid/hid-tmff.c, and drivers/hid/hid-zpff.c.",
        "id": 2207
    },
    {
        "cve_id": "CVE-2021-39685",
        "code_before_change": "static int dbgp_setup(struct usb_gadget *gadget,\n\t\t      const struct usb_ctrlrequest *ctrl)\n{\n\tstruct usb_request *req = dbgp.req;\n\tu8 request = ctrl->bRequest;\n\tu16 value = le16_to_cpu(ctrl->wValue);\n\tu16 length = le16_to_cpu(ctrl->wLength);\n\tint err = -EOPNOTSUPP;\n\tvoid *data = NULL;\n\tu16 len = 0;\n\n\tif (request == USB_REQ_GET_DESCRIPTOR) {\n\t\tswitch (value>>8) {\n\t\tcase USB_DT_DEVICE:\n\t\t\tdev_dbg(&dbgp.gadget->dev, \"setup: desc device\\n\");\n\t\t\tlen = sizeof device_desc;\n\t\t\tdata = &device_desc;\n\t\t\tdevice_desc.bMaxPacketSize0 = gadget->ep0->maxpacket;\n\t\t\tbreak;\n\t\tcase USB_DT_DEBUG:\n\t\t\tdev_dbg(&dbgp.gadget->dev, \"setup: desc debug\\n\");\n\t\t\tlen = sizeof dbg_desc;\n\t\t\tdata = &dbg_desc;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t\terr = 0;\n\t} else if (request == USB_REQ_SET_FEATURE &&\n\t\t   value == USB_DEVICE_DEBUG_MODE) {\n\t\tdev_dbg(&dbgp.gadget->dev, \"setup: feat debug\\n\");\n#ifdef CONFIG_USB_G_DBGP_PRINTK\n\t\terr = dbgp_enable_ep();\n#else\n\t\terr = dbgp_configure_endpoints(gadget);\n\t\tif (err < 0) {\n\t\t\tgoto fail;\n\t\t}\n\t\terr = gserial_connect(dbgp.serial, tty_line);\n#endif\n\t\tif (err < 0)\n\t\t\tgoto fail;\n\t} else\n\t\tgoto fail;\n\n\treq->length = min(length, len);\n\treq->zero = len < req->length;\n\tif (data && req->length)\n\t\tmemcpy(req->buf, data, req->length);\n\n\treq->complete = dbgp_setup_complete;\n\treturn usb_ep_queue(gadget->ep0, req, GFP_ATOMIC);\n\nfail:\n\tdev_dbg(&dbgp.gadget->dev,\n\t\t\"setup: failure req %x v %x\\n\", request, value);\n\treturn err;\n}",
        "code_after_change": "static int dbgp_setup(struct usb_gadget *gadget,\n\t\t      const struct usb_ctrlrequest *ctrl)\n{\n\tstruct usb_request *req = dbgp.req;\n\tu8 request = ctrl->bRequest;\n\tu16 value = le16_to_cpu(ctrl->wValue);\n\tu16 length = le16_to_cpu(ctrl->wLength);\n\tint err = -EOPNOTSUPP;\n\tvoid *data = NULL;\n\tu16 len = 0;\n\n\tif (length > DBGP_REQ_LEN) {\n\t\tif (ctrl->bRequestType == USB_DIR_OUT) {\n\t\t\treturn err;\n\t\t} else {\n\t\t\t/* Cast away the const, we are going to overwrite on purpose. */\n\t\t\t__le16 *temp = (__le16 *)&ctrl->wLength;\n\n\t\t\t*temp = cpu_to_le16(DBGP_REQ_LEN);\n\t\t\tlength = DBGP_REQ_LEN;\n\t\t}\n\t}\n\n\n\tif (request == USB_REQ_GET_DESCRIPTOR) {\n\t\tswitch (value>>8) {\n\t\tcase USB_DT_DEVICE:\n\t\t\tdev_dbg(&dbgp.gadget->dev, \"setup: desc device\\n\");\n\t\t\tlen = sizeof device_desc;\n\t\t\tdata = &device_desc;\n\t\t\tdevice_desc.bMaxPacketSize0 = gadget->ep0->maxpacket;\n\t\t\tbreak;\n\t\tcase USB_DT_DEBUG:\n\t\t\tdev_dbg(&dbgp.gadget->dev, \"setup: desc debug\\n\");\n\t\t\tlen = sizeof dbg_desc;\n\t\t\tdata = &dbg_desc;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t\terr = 0;\n\t} else if (request == USB_REQ_SET_FEATURE &&\n\t\t   value == USB_DEVICE_DEBUG_MODE) {\n\t\tdev_dbg(&dbgp.gadget->dev, \"setup: feat debug\\n\");\n#ifdef CONFIG_USB_G_DBGP_PRINTK\n\t\terr = dbgp_enable_ep();\n#else\n\t\terr = dbgp_configure_endpoints(gadget);\n\t\tif (err < 0) {\n\t\t\tgoto fail;\n\t\t}\n\t\terr = gserial_connect(dbgp.serial, tty_line);\n#endif\n\t\tif (err < 0)\n\t\t\tgoto fail;\n\t} else\n\t\tgoto fail;\n\n\treq->length = min(length, len);\n\treq->zero = len < req->length;\n\tif (data && req->length)\n\t\tmemcpy(req->buf, data, req->length);\n\n\treq->complete = dbgp_setup_complete;\n\treturn usb_ep_queue(gadget->ep0, req, GFP_ATOMIC);\n\nfail:\n\tdev_dbg(&dbgp.gadget->dev,\n\t\t\"setup: failure req %x v %x\\n\", request, value);\n\treturn err;\n}",
        "patch": "--- code before\n+++ code after\n@@ -8,6 +8,19 @@\n \tint err = -EOPNOTSUPP;\n \tvoid *data = NULL;\n \tu16 len = 0;\n+\n+\tif (length > DBGP_REQ_LEN) {\n+\t\tif (ctrl->bRequestType == USB_DIR_OUT) {\n+\t\t\treturn err;\n+\t\t} else {\n+\t\t\t/* Cast away the const, we are going to overwrite on purpose. */\n+\t\t\t__le16 *temp = (__le16 *)&ctrl->wLength;\n+\n+\t\t\t*temp = cpu_to_le16(DBGP_REQ_LEN);\n+\t\t\tlength = DBGP_REQ_LEN;\n+\t\t}\n+\t}\n+\n \n \tif (request == USB_REQ_GET_DESCRIPTOR) {\n \t\tswitch (value>>8) {",
        "function_modified_lines": {
            "added": [
                "",
                "\tif (length > DBGP_REQ_LEN) {",
                "\t\tif (ctrl->bRequestType == USB_DIR_OUT) {",
                "\t\t\treturn err;",
                "\t\t} else {",
                "\t\t\t/* Cast away the const, we are going to overwrite on purpose. */",
                "\t\t\t__le16 *temp = (__le16 *)&ctrl->wLength;",
                "",
                "\t\t\t*temp = cpu_to_le16(DBGP_REQ_LEN);",
                "\t\t\tlength = DBGP_REQ_LEN;",
                "\t\t}",
                "\t}",
                ""
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "In various setup methods of the USB gadget subsystem, there is a possible out of bounds write due to an incorrect flag check. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-210292376References: Upstream kernel",
        "id": 3097
    },
    {
        "cve_id": "CVE-2017-1000251",
        "code_before_change": "static int l2cap_connect_create_rsp(struct l2cap_conn *conn,\n\t\t\t\t    struct l2cap_cmd_hdr *cmd, u16 cmd_len,\n\t\t\t\t    u8 *data)\n{\n\tstruct l2cap_conn_rsp *rsp = (struct l2cap_conn_rsp *) data;\n\tu16 scid, dcid, result, status;\n\tstruct l2cap_chan *chan;\n\tu8 req[128];\n\tint err;\n\n\tif (cmd_len < sizeof(*rsp))\n\t\treturn -EPROTO;\n\n\tscid   = __le16_to_cpu(rsp->scid);\n\tdcid   = __le16_to_cpu(rsp->dcid);\n\tresult = __le16_to_cpu(rsp->result);\n\tstatus = __le16_to_cpu(rsp->status);\n\n\tBT_DBG(\"dcid 0x%4.4x scid 0x%4.4x result 0x%2.2x status 0x%2.2x\",\n\t       dcid, scid, result, status);\n\n\tmutex_lock(&conn->chan_lock);\n\n\tif (scid) {\n\t\tchan = __l2cap_get_chan_by_scid(conn, scid);\n\t\tif (!chan) {\n\t\t\terr = -EBADSLT;\n\t\t\tgoto unlock;\n\t\t}\n\t} else {\n\t\tchan = __l2cap_get_chan_by_ident(conn, cmd->ident);\n\t\tif (!chan) {\n\t\t\terr = -EBADSLT;\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\terr = 0;\n\n\tl2cap_chan_lock(chan);\n\n\tswitch (result) {\n\tcase L2CAP_CR_SUCCESS:\n\t\tl2cap_state_change(chan, BT_CONFIG);\n\t\tchan->ident = 0;\n\t\tchan->dcid = dcid;\n\t\tclear_bit(CONF_CONNECT_PEND, &chan->conf_state);\n\n\t\tif (test_and_set_bit(CONF_REQ_SENT, &chan->conf_state))\n\t\t\tbreak;\n\n\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,\n\t\t\t       l2cap_build_conf_req(chan, req), req);\n\t\tchan->num_conf_req++;\n\t\tbreak;\n\n\tcase L2CAP_CR_PEND:\n\t\tset_bit(CONF_CONNECT_PEND, &chan->conf_state);\n\t\tbreak;\n\n\tdefault:\n\t\tl2cap_chan_del(chan, ECONNREFUSED);\n\t\tbreak;\n\t}\n\n\tl2cap_chan_unlock(chan);\n\nunlock:\n\tmutex_unlock(&conn->chan_lock);\n\n\treturn err;\n}",
        "code_after_change": "static int l2cap_connect_create_rsp(struct l2cap_conn *conn,\n\t\t\t\t    struct l2cap_cmd_hdr *cmd, u16 cmd_len,\n\t\t\t\t    u8 *data)\n{\n\tstruct l2cap_conn_rsp *rsp = (struct l2cap_conn_rsp *) data;\n\tu16 scid, dcid, result, status;\n\tstruct l2cap_chan *chan;\n\tu8 req[128];\n\tint err;\n\n\tif (cmd_len < sizeof(*rsp))\n\t\treturn -EPROTO;\n\n\tscid   = __le16_to_cpu(rsp->scid);\n\tdcid   = __le16_to_cpu(rsp->dcid);\n\tresult = __le16_to_cpu(rsp->result);\n\tstatus = __le16_to_cpu(rsp->status);\n\n\tBT_DBG(\"dcid 0x%4.4x scid 0x%4.4x result 0x%2.2x status 0x%2.2x\",\n\t       dcid, scid, result, status);\n\n\tmutex_lock(&conn->chan_lock);\n\n\tif (scid) {\n\t\tchan = __l2cap_get_chan_by_scid(conn, scid);\n\t\tif (!chan) {\n\t\t\terr = -EBADSLT;\n\t\t\tgoto unlock;\n\t\t}\n\t} else {\n\t\tchan = __l2cap_get_chan_by_ident(conn, cmd->ident);\n\t\tif (!chan) {\n\t\t\terr = -EBADSLT;\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\terr = 0;\n\n\tl2cap_chan_lock(chan);\n\n\tswitch (result) {\n\tcase L2CAP_CR_SUCCESS:\n\t\tl2cap_state_change(chan, BT_CONFIG);\n\t\tchan->ident = 0;\n\t\tchan->dcid = dcid;\n\t\tclear_bit(CONF_CONNECT_PEND, &chan->conf_state);\n\n\t\tif (test_and_set_bit(CONF_REQ_SENT, &chan->conf_state))\n\t\t\tbreak;\n\n\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,\n\t\t\t       l2cap_build_conf_req(chan, req, sizeof(req)), req);\n\t\tchan->num_conf_req++;\n\t\tbreak;\n\n\tcase L2CAP_CR_PEND:\n\t\tset_bit(CONF_CONNECT_PEND, &chan->conf_state);\n\t\tbreak;\n\n\tdefault:\n\t\tl2cap_chan_del(chan, ECONNREFUSED);\n\t\tbreak;\n\t}\n\n\tl2cap_chan_unlock(chan);\n\nunlock:\n\tmutex_unlock(&conn->chan_lock);\n\n\treturn err;\n}",
        "patch": "--- code before\n+++ code after\n@@ -50,7 +50,7 @@\n \t\t\tbreak;\n \n \t\tl2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,\n-\t\t\t       l2cap_build_conf_req(chan, req), req);\n+\t\t\t       l2cap_build_conf_req(chan, req, sizeof(req)), req);\n \t\tchan->num_conf_req++;\n \t\tbreak;\n ",
        "function_modified_lines": {
            "added": [
                "\t\t\t       l2cap_build_conf_req(chan, req, sizeof(req)), req);"
            ],
            "deleted": [
                "\t\t\t       l2cap_build_conf_req(chan, req), req);"
            ]
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "The native Bluetooth stack in the Linux Kernel (BlueZ), starting at the Linux kernel version 2.6.32 and up to and including 4.13.1, are vulnerable to a stack overflow vulnerability in the processing of L2CAP configuration responses resulting in Remote code execution in kernel space.",
        "id": 1185
    },
    {
        "cve_id": "CVE-2017-1000251",
        "code_before_change": "static inline int l2cap_config_req(struct l2cap_conn *conn,\n\t\t\t\t   struct l2cap_cmd_hdr *cmd, u16 cmd_len,\n\t\t\t\t   u8 *data)\n{\n\tstruct l2cap_conf_req *req = (struct l2cap_conf_req *) data;\n\tu16 dcid, flags;\n\tu8 rsp[64];\n\tstruct l2cap_chan *chan;\n\tint len, err = 0;\n\n\tif (cmd_len < sizeof(*req))\n\t\treturn -EPROTO;\n\n\tdcid  = __le16_to_cpu(req->dcid);\n\tflags = __le16_to_cpu(req->flags);\n\n\tBT_DBG(\"dcid 0x%4.4x flags 0x%2.2x\", dcid, flags);\n\n\tchan = l2cap_get_chan_by_scid(conn, dcid);\n\tif (!chan) {\n\t\tcmd_reject_invalid_cid(conn, cmd->ident, dcid, 0);\n\t\treturn 0;\n\t}\n\n\tif (chan->state != BT_CONFIG && chan->state != BT_CONNECT2) {\n\t\tcmd_reject_invalid_cid(conn, cmd->ident, chan->scid,\n\t\t\t\t       chan->dcid);\n\t\tgoto unlock;\n\t}\n\n\t/* Reject if config buffer is too small. */\n\tlen = cmd_len - sizeof(*req);\n\tif (chan->conf_len + len > sizeof(chan->conf_req)) {\n\t\tl2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP,\n\t\t\t       l2cap_build_conf_rsp(chan, rsp,\n\t\t\t       L2CAP_CONF_REJECT, flags), rsp);\n\t\tgoto unlock;\n\t}\n\n\t/* Store config. */\n\tmemcpy(chan->conf_req + chan->conf_len, req->data, len);\n\tchan->conf_len += len;\n\n\tif (flags & L2CAP_CONF_FLAG_CONTINUATION) {\n\t\t/* Incomplete config. Send empty response. */\n\t\tl2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP,\n\t\t\t       l2cap_build_conf_rsp(chan, rsp,\n\t\t\t       L2CAP_CONF_SUCCESS, flags), rsp);\n\t\tgoto unlock;\n\t}\n\n\t/* Complete config. */\n\tlen = l2cap_parse_conf_req(chan, rsp);\n\tif (len < 0) {\n\t\tl2cap_send_disconn_req(chan, ECONNRESET);\n\t\tgoto unlock;\n\t}\n\n\tchan->ident = cmd->ident;\n\tl2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP, len, rsp);\n\tchan->num_conf_rsp++;\n\n\t/* Reset config buffer. */\n\tchan->conf_len = 0;\n\n\tif (!test_bit(CONF_OUTPUT_DONE, &chan->conf_state))\n\t\tgoto unlock;\n\n\tif (test_bit(CONF_INPUT_DONE, &chan->conf_state)) {\n\t\tset_default_fcs(chan);\n\n\t\tif (chan->mode == L2CAP_MODE_ERTM ||\n\t\t    chan->mode == L2CAP_MODE_STREAMING)\n\t\t\terr = l2cap_ertm_init(chan);\n\n\t\tif (err < 0)\n\t\t\tl2cap_send_disconn_req(chan, -err);\n\t\telse\n\t\t\tl2cap_chan_ready(chan);\n\n\t\tgoto unlock;\n\t}\n\n\tif (!test_and_set_bit(CONF_REQ_SENT, &chan->conf_state)) {\n\t\tu8 buf[64];\n\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,\n\t\t\t       l2cap_build_conf_req(chan, buf), buf);\n\t\tchan->num_conf_req++;\n\t}\n\n\t/* Got Conf Rsp PENDING from remote side and assume we sent\n\t   Conf Rsp PENDING in the code above */\n\tif (test_bit(CONF_REM_CONF_PEND, &chan->conf_state) &&\n\t    test_bit(CONF_LOC_CONF_PEND, &chan->conf_state)) {\n\n\t\t/* check compatibility */\n\n\t\t/* Send rsp for BR/EDR channel */\n\t\tif (!chan->hs_hcon)\n\t\t\tl2cap_send_efs_conf_rsp(chan, rsp, cmd->ident, flags);\n\t\telse\n\t\t\tchan->ident = cmd->ident;\n\t}\n\nunlock:\n\tl2cap_chan_unlock(chan);\n\treturn err;\n}",
        "code_after_change": "static inline int l2cap_config_req(struct l2cap_conn *conn,\n\t\t\t\t   struct l2cap_cmd_hdr *cmd, u16 cmd_len,\n\t\t\t\t   u8 *data)\n{\n\tstruct l2cap_conf_req *req = (struct l2cap_conf_req *) data;\n\tu16 dcid, flags;\n\tu8 rsp[64];\n\tstruct l2cap_chan *chan;\n\tint len, err = 0;\n\n\tif (cmd_len < sizeof(*req))\n\t\treturn -EPROTO;\n\n\tdcid  = __le16_to_cpu(req->dcid);\n\tflags = __le16_to_cpu(req->flags);\n\n\tBT_DBG(\"dcid 0x%4.4x flags 0x%2.2x\", dcid, flags);\n\n\tchan = l2cap_get_chan_by_scid(conn, dcid);\n\tif (!chan) {\n\t\tcmd_reject_invalid_cid(conn, cmd->ident, dcid, 0);\n\t\treturn 0;\n\t}\n\n\tif (chan->state != BT_CONFIG && chan->state != BT_CONNECT2) {\n\t\tcmd_reject_invalid_cid(conn, cmd->ident, chan->scid,\n\t\t\t\t       chan->dcid);\n\t\tgoto unlock;\n\t}\n\n\t/* Reject if config buffer is too small. */\n\tlen = cmd_len - sizeof(*req);\n\tif (chan->conf_len + len > sizeof(chan->conf_req)) {\n\t\tl2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP,\n\t\t\t       l2cap_build_conf_rsp(chan, rsp,\n\t\t\t       L2CAP_CONF_REJECT, flags), rsp);\n\t\tgoto unlock;\n\t}\n\n\t/* Store config. */\n\tmemcpy(chan->conf_req + chan->conf_len, req->data, len);\n\tchan->conf_len += len;\n\n\tif (flags & L2CAP_CONF_FLAG_CONTINUATION) {\n\t\t/* Incomplete config. Send empty response. */\n\t\tl2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP,\n\t\t\t       l2cap_build_conf_rsp(chan, rsp,\n\t\t\t       L2CAP_CONF_SUCCESS, flags), rsp);\n\t\tgoto unlock;\n\t}\n\n\t/* Complete config. */\n\tlen = l2cap_parse_conf_req(chan, rsp, sizeof(rsp));\n\tif (len < 0) {\n\t\tl2cap_send_disconn_req(chan, ECONNRESET);\n\t\tgoto unlock;\n\t}\n\n\tchan->ident = cmd->ident;\n\tl2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP, len, rsp);\n\tchan->num_conf_rsp++;\n\n\t/* Reset config buffer. */\n\tchan->conf_len = 0;\n\n\tif (!test_bit(CONF_OUTPUT_DONE, &chan->conf_state))\n\t\tgoto unlock;\n\n\tif (test_bit(CONF_INPUT_DONE, &chan->conf_state)) {\n\t\tset_default_fcs(chan);\n\n\t\tif (chan->mode == L2CAP_MODE_ERTM ||\n\t\t    chan->mode == L2CAP_MODE_STREAMING)\n\t\t\terr = l2cap_ertm_init(chan);\n\n\t\tif (err < 0)\n\t\t\tl2cap_send_disconn_req(chan, -err);\n\t\telse\n\t\t\tl2cap_chan_ready(chan);\n\n\t\tgoto unlock;\n\t}\n\n\tif (!test_and_set_bit(CONF_REQ_SENT, &chan->conf_state)) {\n\t\tu8 buf[64];\n\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,\n\t\t\t       l2cap_build_conf_req(chan, buf, sizeof(buf)), buf);\n\t\tchan->num_conf_req++;\n\t}\n\n\t/* Got Conf Rsp PENDING from remote side and assume we sent\n\t   Conf Rsp PENDING in the code above */\n\tif (test_bit(CONF_REM_CONF_PEND, &chan->conf_state) &&\n\t    test_bit(CONF_LOC_CONF_PEND, &chan->conf_state)) {\n\n\t\t/* check compatibility */\n\n\t\t/* Send rsp for BR/EDR channel */\n\t\tif (!chan->hs_hcon)\n\t\t\tl2cap_send_efs_conf_rsp(chan, rsp, cmd->ident, flags);\n\t\telse\n\t\t\tchan->ident = cmd->ident;\n\t}\n\nunlock:\n\tl2cap_chan_unlock(chan);\n\treturn err;\n}",
        "patch": "--- code before\n+++ code after\n@@ -50,7 +50,7 @@\n \t}\n \n \t/* Complete config. */\n-\tlen = l2cap_parse_conf_req(chan, rsp);\n+\tlen = l2cap_parse_conf_req(chan, rsp, sizeof(rsp));\n \tif (len < 0) {\n \t\tl2cap_send_disconn_req(chan, ECONNRESET);\n \t\tgoto unlock;\n@@ -84,7 +84,7 @@\n \tif (!test_and_set_bit(CONF_REQ_SENT, &chan->conf_state)) {\n \t\tu8 buf[64];\n \t\tl2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,\n-\t\t\t       l2cap_build_conf_req(chan, buf), buf);\n+\t\t\t       l2cap_build_conf_req(chan, buf, sizeof(buf)), buf);\n \t\tchan->num_conf_req++;\n \t}\n ",
        "function_modified_lines": {
            "added": [
                "\tlen = l2cap_parse_conf_req(chan, rsp, sizeof(rsp));",
                "\t\t\t       l2cap_build_conf_req(chan, buf, sizeof(buf)), buf);"
            ],
            "deleted": [
                "\tlen = l2cap_parse_conf_req(chan, rsp);",
                "\t\t\t       l2cap_build_conf_req(chan, buf), buf);"
            ]
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "The native Bluetooth stack in the Linux Kernel (BlueZ), starting at the Linux kernel version 2.6.32 and up to and including 4.13.1, are vulnerable to a stack overflow vulnerability in the processing of L2CAP configuration responses resulting in Remote code execution in kernel space.",
        "id": 1189
    },
    {
        "cve_id": "CVE-2021-27365",
        "code_before_change": "static int\niscsi_set_host_param(struct iscsi_transport *transport,\n\t\t     struct iscsi_uevent *ev)\n{\n\tchar *data = (char*)ev + sizeof(*ev);\n\tstruct Scsi_Host *shost;\n\tint err;\n\n\tif (!transport->set_host_param)\n\t\treturn -ENOSYS;\n\n\tshost = scsi_host_lookup(ev->u.set_host_param.host_no);\n\tif (!shost) {\n\t\tprintk(KERN_ERR \"set_host_param could not find host no %u\\n\",\n\t\t       ev->u.set_host_param.host_no);\n\t\treturn -ENODEV;\n\t}\n\n\terr = transport->set_host_param(shost, ev->u.set_host_param.param,\n\t\t\t\t\tdata, ev->u.set_host_param.len);\n\tscsi_host_put(shost);\n\treturn err;\n}",
        "code_after_change": "static int\niscsi_set_host_param(struct iscsi_transport *transport,\n\t\t     struct iscsi_uevent *ev)\n{\n\tchar *data = (char*)ev + sizeof(*ev);\n\tstruct Scsi_Host *shost;\n\tint err;\n\n\tif (!transport->set_host_param)\n\t\treturn -ENOSYS;\n\n\tif (ev->u.set_host_param.len > PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\tshost = scsi_host_lookup(ev->u.set_host_param.host_no);\n\tif (!shost) {\n\t\tprintk(KERN_ERR \"set_host_param could not find host no %u\\n\",\n\t\t       ev->u.set_host_param.host_no);\n\t\treturn -ENODEV;\n\t}\n\n\terr = transport->set_host_param(shost, ev->u.set_host_param.param,\n\t\t\t\t\tdata, ev->u.set_host_param.len);\n\tscsi_host_put(shost);\n\treturn err;\n}",
        "patch": "--- code before\n+++ code after\n@@ -8,6 +8,9 @@\n \n \tif (!transport->set_host_param)\n \t\treturn -ENOSYS;\n+\n+\tif (ev->u.set_host_param.len > PAGE_SIZE)\n+\t\treturn -EINVAL;\n \n \tshost = scsi_host_lookup(ev->u.set_host_param.host_no);\n \tif (!shost) {",
        "function_modified_lines": {
            "added": [
                "",
                "\tif (ev->u.set_host_param.len > PAGE_SIZE)",
                "\t\treturn -EINVAL;"
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "An issue was discovered in the Linux kernel through 5.11.3. Certain iSCSI data structures do not have appropriate length constraints or checks, and can exceed the PAGE_SIZE value. An unprivileged user can send a Netlink message that is associated with iSCSI, and has a length up to the maximum length of a Netlink message.",
        "id": 2905
    },
    {
        "cve_id": "CVE-2021-27365",
        "code_before_change": "int iscsi_conn_get_addr_param(struct sockaddr_storage *addr,\n\t\t\t      enum iscsi_param param, char *buf)\n{\n\tstruct sockaddr_in6 *sin6 = NULL;\n\tstruct sockaddr_in *sin = NULL;\n\tint len;\n\n\tswitch (addr->ss_family) {\n\tcase AF_INET:\n\t\tsin = (struct sockaddr_in *)addr;\n\t\tbreak;\n\tcase AF_INET6:\n\t\tsin6 = (struct sockaddr_in6 *)addr;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (param) {\n\tcase ISCSI_PARAM_CONN_ADDRESS:\n\tcase ISCSI_HOST_PARAM_IPADDRESS:\n\t\tif (sin)\n\t\t\tlen = sprintf(buf, \"%pI4\\n\", &sin->sin_addr.s_addr);\n\t\telse\n\t\t\tlen = sprintf(buf, \"%pI6\\n\", &sin6->sin6_addr);\n\t\tbreak;\n\tcase ISCSI_PARAM_CONN_PORT:\n\tcase ISCSI_PARAM_LOCAL_PORT:\n\t\tif (sin)\n\t\t\tlen = sprintf(buf, \"%hu\\n\", be16_to_cpu(sin->sin_port));\n\t\telse\n\t\t\tlen = sprintf(buf, \"%hu\\n\",\n\t\t\t\t      be16_to_cpu(sin6->sin6_port));\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn len;\n}",
        "code_after_change": "int iscsi_conn_get_addr_param(struct sockaddr_storage *addr,\n\t\t\t      enum iscsi_param param, char *buf)\n{\n\tstruct sockaddr_in6 *sin6 = NULL;\n\tstruct sockaddr_in *sin = NULL;\n\tint len;\n\n\tswitch (addr->ss_family) {\n\tcase AF_INET:\n\t\tsin = (struct sockaddr_in *)addr;\n\t\tbreak;\n\tcase AF_INET6:\n\t\tsin6 = (struct sockaddr_in6 *)addr;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (param) {\n\tcase ISCSI_PARAM_CONN_ADDRESS:\n\tcase ISCSI_HOST_PARAM_IPADDRESS:\n\t\tif (sin)\n\t\t\tlen = sysfs_emit(buf, \"%pI4\\n\", &sin->sin_addr.s_addr);\n\t\telse\n\t\t\tlen = sysfs_emit(buf, \"%pI6\\n\", &sin6->sin6_addr);\n\t\tbreak;\n\tcase ISCSI_PARAM_CONN_PORT:\n\tcase ISCSI_PARAM_LOCAL_PORT:\n\t\tif (sin)\n\t\t\tlen = sysfs_emit(buf, \"%hu\\n\", be16_to_cpu(sin->sin_port));\n\t\telse\n\t\t\tlen = sysfs_emit(buf, \"%hu\\n\",\n\t\t\t\t      be16_to_cpu(sin6->sin6_port));\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn len;\n}",
        "patch": "--- code before\n+++ code after\n@@ -20,16 +20,16 @@\n \tcase ISCSI_PARAM_CONN_ADDRESS:\n \tcase ISCSI_HOST_PARAM_IPADDRESS:\n \t\tif (sin)\n-\t\t\tlen = sprintf(buf, \"%pI4\\n\", &sin->sin_addr.s_addr);\n+\t\t\tlen = sysfs_emit(buf, \"%pI4\\n\", &sin->sin_addr.s_addr);\n \t\telse\n-\t\t\tlen = sprintf(buf, \"%pI6\\n\", &sin6->sin6_addr);\n+\t\t\tlen = sysfs_emit(buf, \"%pI6\\n\", &sin6->sin6_addr);\n \t\tbreak;\n \tcase ISCSI_PARAM_CONN_PORT:\n \tcase ISCSI_PARAM_LOCAL_PORT:\n \t\tif (sin)\n-\t\t\tlen = sprintf(buf, \"%hu\\n\", be16_to_cpu(sin->sin_port));\n+\t\t\tlen = sysfs_emit(buf, \"%hu\\n\", be16_to_cpu(sin->sin_port));\n \t\telse\n-\t\t\tlen = sprintf(buf, \"%hu\\n\",\n+\t\t\tlen = sysfs_emit(buf, \"%hu\\n\",\n \t\t\t\t      be16_to_cpu(sin6->sin6_port));\n \t\tbreak;\n \tdefault:",
        "function_modified_lines": {
            "added": [
                "\t\t\tlen = sysfs_emit(buf, \"%pI4\\n\", &sin->sin_addr.s_addr);",
                "\t\t\tlen = sysfs_emit(buf, \"%pI6\\n\", &sin6->sin6_addr);",
                "\t\t\tlen = sysfs_emit(buf, \"%hu\\n\", be16_to_cpu(sin->sin_port));",
                "\t\t\tlen = sysfs_emit(buf, \"%hu\\n\","
            ],
            "deleted": [
                "\t\t\tlen = sprintf(buf, \"%pI4\\n\", &sin->sin_addr.s_addr);",
                "\t\t\tlen = sprintf(buf, \"%pI6\\n\", &sin6->sin6_addr);",
                "\t\t\tlen = sprintf(buf, \"%hu\\n\", be16_to_cpu(sin->sin_port));",
                "\t\t\tlen = sprintf(buf, \"%hu\\n\","
            ]
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "An issue was discovered in the Linux kernel through 5.11.3. Certain iSCSI data structures do not have appropriate length constraints or checks, and can exceed the PAGE_SIZE value. An unprivileged user can send a Netlink message that is associated with iSCSI, and has a length up to the maximum length of a Netlink message.",
        "id": 2900
    },
    {
        "cve_id": "CVE-2021-27365",
        "code_before_change": "static int\niscsi_set_param(struct iscsi_transport *transport, struct iscsi_uevent *ev)\n{\n\tchar *data = (char*)ev + sizeof(*ev);\n\tstruct iscsi_cls_conn *conn;\n\tstruct iscsi_cls_session *session;\n\tint err = 0, value = 0;\n\n\tsession = iscsi_session_lookup(ev->u.set_param.sid);\n\tconn = iscsi_conn_lookup(ev->u.set_param.sid, ev->u.set_param.cid);\n\tif (!conn || !session)\n\t\treturn -EINVAL;\n\n\tswitch (ev->u.set_param.param) {\n\tcase ISCSI_PARAM_SESS_RECOVERY_TMO:\n\t\tsscanf(data, \"%d\", &value);\n\t\tif (!session->recovery_tmo_sysfs_override)\n\t\t\tsession->recovery_tmo = value;\n\t\tbreak;\n\tdefault:\n\t\terr = transport->set_param(conn, ev->u.set_param.param,\n\t\t\t\t\t   data, ev->u.set_param.len);\n\t}\n\n\treturn err;\n}",
        "code_after_change": "static int\niscsi_set_param(struct iscsi_transport *transport, struct iscsi_uevent *ev)\n{\n\tchar *data = (char*)ev + sizeof(*ev);\n\tstruct iscsi_cls_conn *conn;\n\tstruct iscsi_cls_session *session;\n\tint err = 0, value = 0;\n\n\tif (ev->u.set_param.len > PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\tsession = iscsi_session_lookup(ev->u.set_param.sid);\n\tconn = iscsi_conn_lookup(ev->u.set_param.sid, ev->u.set_param.cid);\n\tif (!conn || !session)\n\t\treturn -EINVAL;\n\n\tswitch (ev->u.set_param.param) {\n\tcase ISCSI_PARAM_SESS_RECOVERY_TMO:\n\t\tsscanf(data, \"%d\", &value);\n\t\tif (!session->recovery_tmo_sysfs_override)\n\t\t\tsession->recovery_tmo = value;\n\t\tbreak;\n\tdefault:\n\t\terr = transport->set_param(conn, ev->u.set_param.param,\n\t\t\t\t\t   data, ev->u.set_param.len);\n\t}\n\n\treturn err;\n}",
        "patch": "--- code before\n+++ code after\n@@ -5,6 +5,9 @@\n \tstruct iscsi_cls_conn *conn;\n \tstruct iscsi_cls_session *session;\n \tint err = 0, value = 0;\n+\n+\tif (ev->u.set_param.len > PAGE_SIZE)\n+\t\treturn -EINVAL;\n \n \tsession = iscsi_session_lookup(ev->u.set_param.sid);\n \tconn = iscsi_conn_lookup(ev->u.set_param.sid, ev->u.set_param.cid);",
        "function_modified_lines": {
            "added": [
                "",
                "\tif (ev->u.set_param.len > PAGE_SIZE)",
                "\t\treturn -EINVAL;"
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "An issue was discovered in the Linux kernel through 5.11.3. Certain iSCSI data structures do not have appropriate length constraints or checks, and can exceed the PAGE_SIZE value. An unprivileged user can send a Netlink message that is associated with iSCSI, and has a length up to the maximum length of a Netlink message.",
        "id": 2904
    },
    {
        "cve_id": "CVE-2020-25212",
        "code_before_change": "static int decode_attr_security_label(struct xdr_stream *xdr, uint32_t *bitmap,\n\t\t\t\t\tstruct nfs4_label *label)\n{\n\tuint32_t pi = 0;\n\tuint32_t lfs = 0;\n\t__u32 len;\n\t__be32 *p;\n\tint status = 0;\n\n\tif (unlikely(bitmap[2] & (FATTR4_WORD2_SECURITY_LABEL - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[2] & FATTR4_WORD2_SECURITY_LABEL)) {\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\tlfs = be32_to_cpup(p++);\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\tpi = be32_to_cpup(p++);\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\tlen = be32_to_cpup(p++);\n\t\tp = xdr_inline_decode(xdr, len);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\tif (len < NFS4_MAXLABELLEN) {\n\t\t\tif (label) {\n\t\t\t\tmemcpy(label->label, p, len);\n\t\t\t\tlabel->len = len;\n\t\t\t\tlabel->pi = pi;\n\t\t\t\tlabel->lfs = lfs;\n\t\t\t\tstatus = NFS_ATTR_FATTR_V4_SECURITY_LABEL;\n\t\t\t}\n\t\t\tbitmap[2] &= ~FATTR4_WORD2_SECURITY_LABEL;\n\t\t} else\n\t\t\tprintk(KERN_WARNING \"%s: label too long (%u)!\\n\",\n\t\t\t\t\t__func__, len);\n\t}\n\tif (label && label->label)\n\t\tdprintk(\"%s: label=%s, len=%d, PI=%d, LFS=%d\\n\", __func__,\n\t\t\t(char *)label->label, label->len, label->pi, label->lfs);\n\treturn status;\n}",
        "code_after_change": "static int decode_attr_security_label(struct xdr_stream *xdr, uint32_t *bitmap,\n\t\t\t\t\tstruct nfs4_label *label)\n{\n\tuint32_t pi = 0;\n\tuint32_t lfs = 0;\n\t__u32 len;\n\t__be32 *p;\n\tint status = 0;\n\n\tif (unlikely(bitmap[2] & (FATTR4_WORD2_SECURITY_LABEL - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[2] & FATTR4_WORD2_SECURITY_LABEL)) {\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\tlfs = be32_to_cpup(p++);\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\tpi = be32_to_cpup(p++);\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\tlen = be32_to_cpup(p++);\n\t\tp = xdr_inline_decode(xdr, len);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\tif (len < NFS4_MAXLABELLEN) {\n\t\t\tif (label) {\n\t\t\t\tif (label->len) {\n\t\t\t\t\tif (label->len < len)\n\t\t\t\t\t\treturn -ERANGE;\n\t\t\t\t\tmemcpy(label->label, p, len);\n\t\t\t\t}\n\t\t\t\tlabel->len = len;\n\t\t\t\tlabel->pi = pi;\n\t\t\t\tlabel->lfs = lfs;\n\t\t\t\tstatus = NFS_ATTR_FATTR_V4_SECURITY_LABEL;\n\t\t\t}\n\t\t\tbitmap[2] &= ~FATTR4_WORD2_SECURITY_LABEL;\n\t\t} else\n\t\t\tprintk(KERN_WARNING \"%s: label too long (%u)!\\n\",\n\t\t\t\t\t__func__, len);\n\t}\n\tif (label && label->label)\n\t\tdprintk(\"%s: label=%s, len=%d, PI=%d, LFS=%d\\n\", __func__,\n\t\t\t(char *)label->label, label->len, label->pi, label->lfs);\n\treturn status;\n}",
        "patch": "--- code before\n+++ code after\n@@ -27,7 +27,11 @@\n \t\t\treturn -EIO;\n \t\tif (len < NFS4_MAXLABELLEN) {\n \t\t\tif (label) {\n-\t\t\t\tmemcpy(label->label, p, len);\n+\t\t\t\tif (label->len) {\n+\t\t\t\t\tif (label->len < len)\n+\t\t\t\t\t\treturn -ERANGE;\n+\t\t\t\t\tmemcpy(label->label, p, len);\n+\t\t\t\t}\n \t\t\t\tlabel->len = len;\n \t\t\t\tlabel->pi = pi;\n \t\t\t\tlabel->lfs = lfs;",
        "function_modified_lines": {
            "added": [
                "\t\t\t\tif (label->len) {",
                "\t\t\t\t\tif (label->len < len)",
                "\t\t\t\t\t\treturn -ERANGE;",
                "\t\t\t\t\tmemcpy(label->label, p, len);",
                "\t\t\t\t}"
            ],
            "deleted": [
                "\t\t\t\tmemcpy(label->label, p, len);"
            ]
        },
        "cwe": [
            "CWE-787",
            "CWE-367"
        ],
        "cve_description": "A TOCTOU mismatch in the NFS client code in the Linux kernel before 5.8.3 could be used by local attackers to corrupt memory or possibly have unspecified other impact because a size check is in fs/nfs/nfs4proc.c instead of fs/nfs/nfs4xdr.c, aka CID-b4487b935452.",
        "id": 2579
    },
    {
        "cve_id": "CVE-2022-20369",
        "code_before_change": "int v4l2_m2m_dqbuf(struct file *file, struct v4l2_m2m_ctx *m2m_ctx,\n\t\t   struct v4l2_buffer *buf)\n{\n\tstruct vb2_queue *vq;\n\n\tvq = v4l2_m2m_get_vq(m2m_ctx, buf->type);\n\treturn vb2_dqbuf(vq, buf, file->f_flags & O_NONBLOCK);\n}",
        "code_after_change": "int v4l2_m2m_dqbuf(struct file *file, struct v4l2_m2m_ctx *m2m_ctx,\n\t\t   struct v4l2_buffer *buf)\n{\n\tstruct vb2_queue *vq;\n\tint ret;\n\n\tvq = v4l2_m2m_get_vq(m2m_ctx, buf->type);\n\tret = vb2_dqbuf(vq, buf, file->f_flags & O_NONBLOCK);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Adjust MMAP memory offsets for the CAPTURE queue */\n\tv4l2_m2m_adjust_mem_offset(vq, buf);\n\n\treturn 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -2,7 +2,15 @@\n \t\t   struct v4l2_buffer *buf)\n {\n \tstruct vb2_queue *vq;\n+\tint ret;\n \n \tvq = v4l2_m2m_get_vq(m2m_ctx, buf->type);\n-\treturn vb2_dqbuf(vq, buf, file->f_flags & O_NONBLOCK);\n+\tret = vb2_dqbuf(vq, buf, file->f_flags & O_NONBLOCK);\n+\tif (ret)\n+\t\treturn ret;\n+\n+\t/* Adjust MMAP memory offsets for the CAPTURE queue */\n+\tv4l2_m2m_adjust_mem_offset(vq, buf);\n+\n+\treturn 0;\n }",
        "function_modified_lines": {
            "added": [
                "\tint ret;",
                "\tret = vb2_dqbuf(vq, buf, file->f_flags & O_NONBLOCK);",
                "\tif (ret)",
                "\t\treturn ret;",
                "",
                "\t/* Adjust MMAP memory offsets for the CAPTURE queue */",
                "\tv4l2_m2m_adjust_mem_offset(vq, buf);",
                "",
                "\treturn 0;"
            ],
            "deleted": [
                "\treturn vb2_dqbuf(vq, buf, file->f_flags & O_NONBLOCK);"
            ]
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "In v4l2_m2m_querybuf of v4l2-mem2mem.c, there is a possible out of bounds write due to improper input validation. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-223375145References: Upstream kernel",
        "id": 3349
    },
    {
        "cve_id": "CVE-2020-0465",
        "code_before_change": "static int mt_touch_input_mapping(struct hid_device *hdev, struct hid_input *hi,\n\t\tstruct hid_field *field, struct hid_usage *usage,\n\t\tunsigned long **bit, int *max, struct mt_application *app)\n{\n\tstruct mt_device *td = hid_get_drvdata(hdev);\n\tstruct mt_class *cls = &td->mtclass;\n\tint code;\n\tstruct hid_usage *prev_usage = NULL;\n\n\t/*\n\t * Model touchscreens providing buttons as touchpads.\n\t */\n\tif (field->application == HID_DG_TOUCHSCREEN &&\n\t    (usage->hid & HID_USAGE_PAGE) == HID_UP_BUTTON) {\n\t\tapp->mt_flags |= INPUT_MT_POINTER;\n\t\ttd->inputmode_value = MT_INPUTMODE_TOUCHPAD;\n\t}\n\n\t/* count the buttons on touchpads */\n\tif ((usage->hid & HID_USAGE_PAGE) == HID_UP_BUTTON)\n\t\tapp->buttons_count++;\n\n\tif (usage->usage_index)\n\t\tprev_usage = &field->usage[usage->usage_index - 1];\n\n\tswitch (usage->hid & HID_USAGE_PAGE) {\n\n\tcase HID_UP_GENDESK:\n\t\tswitch (usage->hid) {\n\t\tcase HID_GD_X:\n\t\t\tif (prev_usage && (prev_usage->hid == usage->hid)) {\n\t\t\t\tcode = ABS_MT_TOOL_X;\n\t\t\t\tMT_STORE_FIELD(cx);\n\t\t\t} else {\n\t\t\t\tcode = ABS_MT_POSITION_X;\n\t\t\t\tMT_STORE_FIELD(x);\n\t\t\t}\n\n\t\t\tset_abs(hi->input, code, field, cls->sn_move);\n\n\t\t\t/*\n\t\t\t * A system multi-axis that exports X and Y has a high\n\t\t\t * chance of being used directly on a surface\n\t\t\t */\n\t\t\tif (field->application == HID_GD_SYSTEM_MULTIAXIS) {\n\t\t\t\t__set_bit(INPUT_PROP_DIRECT,\n\t\t\t\t\t  hi->input->propbit);\n\t\t\t\tinput_set_abs_params(hi->input,\n\t\t\t\t\t\t     ABS_MT_TOOL_TYPE,\n\t\t\t\t\t\t     MT_TOOL_DIAL,\n\t\t\t\t\t\t     MT_TOOL_DIAL, 0, 0);\n\t\t\t}\n\n\t\t\treturn 1;\n\t\tcase HID_GD_Y:\n\t\t\tif (prev_usage && (prev_usage->hid == usage->hid)) {\n\t\t\t\tcode = ABS_MT_TOOL_Y;\n\t\t\t\tMT_STORE_FIELD(cy);\n\t\t\t} else {\n\t\t\t\tcode = ABS_MT_POSITION_Y;\n\t\t\t\tMT_STORE_FIELD(y);\n\t\t\t}\n\n\t\t\tset_abs(hi->input, code, field, cls->sn_move);\n\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\n\tcase HID_UP_DIGITIZER:\n\t\tswitch (usage->hid) {\n\t\tcase HID_DG_INRANGE:\n\t\t\tif (app->quirks & MT_QUIRK_HOVERING) {\n\t\t\t\tinput_set_abs_params(hi->input,\n\t\t\t\t\tABS_MT_DISTANCE, 0, 1, 0, 0);\n\t\t\t}\n\t\t\tMT_STORE_FIELD(inrange_state);\n\t\t\treturn 1;\n\t\tcase HID_DG_CONFIDENCE:\n\t\t\tif (cls->name == MT_CLS_WIN_8 &&\n\t\t\t\t(field->application == HID_DG_TOUCHPAD ||\n\t\t\t\t field->application == HID_DG_TOUCHSCREEN))\n\t\t\t\tapp->quirks |= MT_QUIRK_CONFIDENCE;\n\n\t\t\tif (app->quirks & MT_QUIRK_CONFIDENCE)\n\t\t\t\tinput_set_abs_params(hi->input,\n\t\t\t\t\t\t     ABS_MT_TOOL_TYPE,\n\t\t\t\t\t\t     MT_TOOL_FINGER,\n\t\t\t\t\t\t     MT_TOOL_PALM, 0, 0);\n\n\t\t\tMT_STORE_FIELD(confidence_state);\n\t\t\treturn 1;\n\t\tcase HID_DG_TIPSWITCH:\n\t\t\tif (field->application != HID_GD_SYSTEM_MULTIAXIS)\n\t\t\t\tinput_set_capability(hi->input,\n\t\t\t\t\t\t     EV_KEY, BTN_TOUCH);\n\t\t\tMT_STORE_FIELD(tip_state);\n\t\t\treturn 1;\n\t\tcase HID_DG_CONTACTID:\n\t\t\tMT_STORE_FIELD(contactid);\n\t\t\tapp->touches_by_report++;\n\t\t\treturn 1;\n\t\tcase HID_DG_WIDTH:\n\t\t\tif (!(app->quirks & MT_QUIRK_NO_AREA))\n\t\t\t\tset_abs(hi->input, ABS_MT_TOUCH_MAJOR, field,\n\t\t\t\t\tcls->sn_width);\n\t\t\tMT_STORE_FIELD(w);\n\t\t\treturn 1;\n\t\tcase HID_DG_HEIGHT:\n\t\t\tif (!(app->quirks & MT_QUIRK_NO_AREA)) {\n\t\t\t\tset_abs(hi->input, ABS_MT_TOUCH_MINOR, field,\n\t\t\t\t\tcls->sn_height);\n\n\t\t\t\t/*\n\t\t\t\t * Only set ABS_MT_ORIENTATION if it is not\n\t\t\t\t * already set by the HID_DG_AZIMUTH usage.\n\t\t\t\t */\n\t\t\t\tif (!test_bit(ABS_MT_ORIENTATION,\n\t\t\t\t\t\thi->input->absbit))\n\t\t\t\t\tinput_set_abs_params(hi->input,\n\t\t\t\t\t\tABS_MT_ORIENTATION, 0, 1, 0, 0);\n\t\t\t}\n\t\t\tMT_STORE_FIELD(h);\n\t\t\treturn 1;\n\t\tcase HID_DG_TIPPRESSURE:\n\t\t\tset_abs(hi->input, ABS_MT_PRESSURE, field,\n\t\t\t\tcls->sn_pressure);\n\t\t\tMT_STORE_FIELD(p);\n\t\t\treturn 1;\n\t\tcase HID_DG_SCANTIME:\n\t\t\tinput_set_capability(hi->input, EV_MSC, MSC_TIMESTAMP);\n\t\t\tapp->scantime = &field->value[usage->usage_index];\n\t\t\tapp->scantime_logical_max = field->logical_maximum;\n\t\t\treturn 1;\n\t\tcase HID_DG_CONTACTCOUNT:\n\t\t\tapp->have_contact_count = true;\n\t\t\tapp->raw_cc = &field->value[usage->usage_index];\n\t\t\treturn 1;\n\t\tcase HID_DG_AZIMUTH:\n\t\t\t/*\n\t\t\t * Azimuth has the range of [0, MAX) representing a full\n\t\t\t * revolution. Set ABS_MT_ORIENTATION to a quarter of\n\t\t\t * MAX according the definition of ABS_MT_ORIENTATION\n\t\t\t */\n\t\t\tinput_set_abs_params(hi->input, ABS_MT_ORIENTATION,\n\t\t\t\t-field->logical_maximum / 4,\n\t\t\t\tfield->logical_maximum / 4,\n\t\t\t\tcls->sn_move ?\n\t\t\t\tfield->logical_maximum / cls->sn_move : 0, 0);\n\t\t\tMT_STORE_FIELD(a);\n\t\t\treturn 1;\n\t\tcase HID_DG_CONTACTMAX:\n\t\t\t/* contact max are global to the report */\n\t\t\treturn -1;\n\t\tcase HID_DG_TOUCH:\n\t\t\t/* Legacy devices use TIPSWITCH and not TOUCH.\n\t\t\t * Let's just ignore this field. */\n\t\t\treturn -1;\n\t\t}\n\t\t/* let hid-input decide for the others */\n\t\treturn 0;\n\n\tcase HID_UP_BUTTON:\n\t\tcode = BTN_MOUSE + ((usage->hid - 1) & HID_USAGE);\n\t\t/*\n\t\t * MS PTP spec says that external buttons left and right have\n\t\t * usages 2 and 3.\n\t\t */\n\t\tif ((app->quirks & MT_QUIRK_WIN8_PTP_BUTTONS) &&\n\t\t    field->application == HID_DG_TOUCHPAD &&\n\t\t    (usage->hid & HID_USAGE) > 1)\n\t\t\tcode--;\n\n\t\tif (field->application == HID_GD_SYSTEM_MULTIAXIS)\n\t\t\tcode = BTN_0  + ((usage->hid - 1) & HID_USAGE);\n\n\t\thid_map_usage(hi, usage, bit, max, EV_KEY, code);\n\t\tinput_set_capability(hi->input, EV_KEY, code);\n\t\treturn 1;\n\n\tcase 0xff000000:\n\t\t/* we do not want to map these: no input-oriented meaning */\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
        "code_after_change": "static int mt_touch_input_mapping(struct hid_device *hdev, struct hid_input *hi,\n\t\tstruct hid_field *field, struct hid_usage *usage,\n\t\tunsigned long **bit, int *max, struct mt_application *app)\n{\n\tstruct mt_device *td = hid_get_drvdata(hdev);\n\tstruct mt_class *cls = &td->mtclass;\n\tint code;\n\tstruct hid_usage *prev_usage = NULL;\n\n\t/*\n\t * Model touchscreens providing buttons as touchpads.\n\t */\n\tif (field->application == HID_DG_TOUCHSCREEN &&\n\t    (usage->hid & HID_USAGE_PAGE) == HID_UP_BUTTON) {\n\t\tapp->mt_flags |= INPUT_MT_POINTER;\n\t\ttd->inputmode_value = MT_INPUTMODE_TOUCHPAD;\n\t}\n\n\t/* count the buttons on touchpads */\n\tif ((usage->hid & HID_USAGE_PAGE) == HID_UP_BUTTON)\n\t\tapp->buttons_count++;\n\n\tif (usage->usage_index)\n\t\tprev_usage = &field->usage[usage->usage_index - 1];\n\n\tswitch (usage->hid & HID_USAGE_PAGE) {\n\n\tcase HID_UP_GENDESK:\n\t\tswitch (usage->hid) {\n\t\tcase HID_GD_X:\n\t\t\tif (prev_usage && (prev_usage->hid == usage->hid)) {\n\t\t\t\tcode = ABS_MT_TOOL_X;\n\t\t\t\tMT_STORE_FIELD(cx);\n\t\t\t} else {\n\t\t\t\tcode = ABS_MT_POSITION_X;\n\t\t\t\tMT_STORE_FIELD(x);\n\t\t\t}\n\n\t\t\tset_abs(hi->input, code, field, cls->sn_move);\n\n\t\t\t/*\n\t\t\t * A system multi-axis that exports X and Y has a high\n\t\t\t * chance of being used directly on a surface\n\t\t\t */\n\t\t\tif (field->application == HID_GD_SYSTEM_MULTIAXIS) {\n\t\t\t\t__set_bit(INPUT_PROP_DIRECT,\n\t\t\t\t\t  hi->input->propbit);\n\t\t\t\tinput_set_abs_params(hi->input,\n\t\t\t\t\t\t     ABS_MT_TOOL_TYPE,\n\t\t\t\t\t\t     MT_TOOL_DIAL,\n\t\t\t\t\t\t     MT_TOOL_DIAL, 0, 0);\n\t\t\t}\n\n\t\t\treturn 1;\n\t\tcase HID_GD_Y:\n\t\t\tif (prev_usage && (prev_usage->hid == usage->hid)) {\n\t\t\t\tcode = ABS_MT_TOOL_Y;\n\t\t\t\tMT_STORE_FIELD(cy);\n\t\t\t} else {\n\t\t\t\tcode = ABS_MT_POSITION_Y;\n\t\t\t\tMT_STORE_FIELD(y);\n\t\t\t}\n\n\t\t\tset_abs(hi->input, code, field, cls->sn_move);\n\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\n\tcase HID_UP_DIGITIZER:\n\t\tswitch (usage->hid) {\n\t\tcase HID_DG_INRANGE:\n\t\t\tif (app->quirks & MT_QUIRK_HOVERING) {\n\t\t\t\tinput_set_abs_params(hi->input,\n\t\t\t\t\tABS_MT_DISTANCE, 0, 1, 0, 0);\n\t\t\t}\n\t\t\tMT_STORE_FIELD(inrange_state);\n\t\t\treturn 1;\n\t\tcase HID_DG_CONFIDENCE:\n\t\t\tif (cls->name == MT_CLS_WIN_8 &&\n\t\t\t\t(field->application == HID_DG_TOUCHPAD ||\n\t\t\t\t field->application == HID_DG_TOUCHSCREEN))\n\t\t\t\tapp->quirks |= MT_QUIRK_CONFIDENCE;\n\n\t\t\tif (app->quirks & MT_QUIRK_CONFIDENCE)\n\t\t\t\tinput_set_abs_params(hi->input,\n\t\t\t\t\t\t     ABS_MT_TOOL_TYPE,\n\t\t\t\t\t\t     MT_TOOL_FINGER,\n\t\t\t\t\t\t     MT_TOOL_PALM, 0, 0);\n\n\t\t\tMT_STORE_FIELD(confidence_state);\n\t\t\treturn 1;\n\t\tcase HID_DG_TIPSWITCH:\n\t\t\tif (field->application != HID_GD_SYSTEM_MULTIAXIS)\n\t\t\t\tinput_set_capability(hi->input,\n\t\t\t\t\t\t     EV_KEY, BTN_TOUCH);\n\t\t\tMT_STORE_FIELD(tip_state);\n\t\t\treturn 1;\n\t\tcase HID_DG_CONTACTID:\n\t\t\tMT_STORE_FIELD(contactid);\n\t\t\tapp->touches_by_report++;\n\t\t\treturn 1;\n\t\tcase HID_DG_WIDTH:\n\t\t\tif (!(app->quirks & MT_QUIRK_NO_AREA))\n\t\t\t\tset_abs(hi->input, ABS_MT_TOUCH_MAJOR, field,\n\t\t\t\t\tcls->sn_width);\n\t\t\tMT_STORE_FIELD(w);\n\t\t\treturn 1;\n\t\tcase HID_DG_HEIGHT:\n\t\t\tif (!(app->quirks & MT_QUIRK_NO_AREA)) {\n\t\t\t\tset_abs(hi->input, ABS_MT_TOUCH_MINOR, field,\n\t\t\t\t\tcls->sn_height);\n\n\t\t\t\t/*\n\t\t\t\t * Only set ABS_MT_ORIENTATION if it is not\n\t\t\t\t * already set by the HID_DG_AZIMUTH usage.\n\t\t\t\t */\n\t\t\t\tif (!test_bit(ABS_MT_ORIENTATION,\n\t\t\t\t\t\thi->input->absbit))\n\t\t\t\t\tinput_set_abs_params(hi->input,\n\t\t\t\t\t\tABS_MT_ORIENTATION, 0, 1, 0, 0);\n\t\t\t}\n\t\t\tMT_STORE_FIELD(h);\n\t\t\treturn 1;\n\t\tcase HID_DG_TIPPRESSURE:\n\t\t\tset_abs(hi->input, ABS_MT_PRESSURE, field,\n\t\t\t\tcls->sn_pressure);\n\t\t\tMT_STORE_FIELD(p);\n\t\t\treturn 1;\n\t\tcase HID_DG_SCANTIME:\n\t\t\tinput_set_capability(hi->input, EV_MSC, MSC_TIMESTAMP);\n\t\t\tapp->scantime = &field->value[usage->usage_index];\n\t\t\tapp->scantime_logical_max = field->logical_maximum;\n\t\t\treturn 1;\n\t\tcase HID_DG_CONTACTCOUNT:\n\t\t\tapp->have_contact_count = true;\n\t\t\tapp->raw_cc = &field->value[usage->usage_index];\n\t\t\treturn 1;\n\t\tcase HID_DG_AZIMUTH:\n\t\t\t/*\n\t\t\t * Azimuth has the range of [0, MAX) representing a full\n\t\t\t * revolution. Set ABS_MT_ORIENTATION to a quarter of\n\t\t\t * MAX according the definition of ABS_MT_ORIENTATION\n\t\t\t */\n\t\t\tinput_set_abs_params(hi->input, ABS_MT_ORIENTATION,\n\t\t\t\t-field->logical_maximum / 4,\n\t\t\t\tfield->logical_maximum / 4,\n\t\t\t\tcls->sn_move ?\n\t\t\t\tfield->logical_maximum / cls->sn_move : 0, 0);\n\t\t\tMT_STORE_FIELD(a);\n\t\t\treturn 1;\n\t\tcase HID_DG_CONTACTMAX:\n\t\t\t/* contact max are global to the report */\n\t\t\treturn -1;\n\t\tcase HID_DG_TOUCH:\n\t\t\t/* Legacy devices use TIPSWITCH and not TOUCH.\n\t\t\t * Let's just ignore this field. */\n\t\t\treturn -1;\n\t\t}\n\t\t/* let hid-input decide for the others */\n\t\treturn 0;\n\n\tcase HID_UP_BUTTON:\n\t\tcode = BTN_MOUSE + ((usage->hid - 1) & HID_USAGE);\n\t\t/*\n\t\t * MS PTP spec says that external buttons left and right have\n\t\t * usages 2 and 3.\n\t\t */\n\t\tif ((app->quirks & MT_QUIRK_WIN8_PTP_BUTTONS) &&\n\t\t    field->application == HID_DG_TOUCHPAD &&\n\t\t    (usage->hid & HID_USAGE) > 1)\n\t\t\tcode--;\n\n\t\tif (field->application == HID_GD_SYSTEM_MULTIAXIS)\n\t\t\tcode = BTN_0  + ((usage->hid - 1) & HID_USAGE);\n\n\t\thid_map_usage(hi, usage, bit, max, EV_KEY, code);\n\t\tif (!*bit)\n\t\t\treturn -1;\n\t\tinput_set_capability(hi->input, EV_KEY, code);\n\t\treturn 1;\n\n\tcase 0xff000000:\n\t\t/* we do not want to map these: no input-oriented meaning */\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -175,6 +175,8 @@\n \t\t\tcode = BTN_0  + ((usage->hid - 1) & HID_USAGE);\n \n \t\thid_map_usage(hi, usage, bit, max, EV_KEY, code);\n+\t\tif (!*bit)\n+\t\t\treturn -1;\n \t\tinput_set_capability(hi->input, EV_KEY, code);\n \t\treturn 1;\n ",
        "function_modified_lines": {
            "added": [
                "\t\tif (!*bit)",
                "\t\t\treturn -1;"
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "In various methods of hid-multitouch.c, there is a possible out of bounds write due to a missing bounds check. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-162844689References: Upstream kernel",
        "id": 2392
    },
    {
        "cve_id": "CVE-2020-0465",
        "code_before_change": "static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_field *field,\n\t\t\t\t     struct hid_usage *usage)\n{\n\tstruct input_dev *input = hidinput->input;\n\tstruct hid_device *device = input_get_drvdata(input);\n\tint max = 0, code;\n\tunsigned long *bit = NULL;\n\n\tfield->hidinput = hidinput;\n\n\tif (field->flags & HID_MAIN_ITEM_CONSTANT)\n\t\tgoto ignore;\n\n\t/* Ignore if report count is out of bounds. */\n\tif (field->report_count < 1)\n\t\tgoto ignore;\n\n\t/* only LED usages are supported in output fields */\n\tif (field->report_type == HID_OUTPUT_REPORT &&\n\t\t\t(usage->hid & HID_USAGE_PAGE) != HID_UP_LED) {\n\t\tgoto ignore;\n\t}\n\n\tif (device->driver->input_mapping) {\n\t\tint ret = device->driver->input_mapping(device, hidinput, field,\n\t\t\t\tusage, &bit, &max);\n\t\tif (ret > 0)\n\t\t\tgoto mapped;\n\t\tif (ret < 0)\n\t\t\tgoto ignore;\n\t}\n\n\tswitch (usage->hid & HID_USAGE_PAGE) {\n\tcase HID_UP_UNDEFINED:\n\t\tgoto ignore;\n\n\tcase HID_UP_KEYBOARD:\n\t\tset_bit(EV_REP, input->evbit);\n\n\t\tif ((usage->hid & HID_USAGE) < 256) {\n\t\t\tif (!hid_keyboard[usage->hid & HID_USAGE]) goto ignore;\n\t\t\tmap_key_clear(hid_keyboard[usage->hid & HID_USAGE]);\n\t\t} else\n\t\t\tmap_key(KEY_UNKNOWN);\n\n\t\tbreak;\n\n\tcase HID_UP_BUTTON:\n\t\tcode = ((usage->hid - 1) & HID_USAGE);\n\n\t\tswitch (field->application) {\n\t\tcase HID_GD_MOUSE:\n\t\tcase HID_GD_POINTER:  code += BTN_MOUSE; break;\n\t\tcase HID_GD_JOYSTICK:\n\t\t\t\tif (code <= 0xf)\n\t\t\t\t\tcode += BTN_JOYSTICK;\n\t\t\t\telse\n\t\t\t\t\tcode += BTN_TRIGGER_HAPPY - 0x10;\n\t\t\t\tbreak;\n\t\tcase HID_GD_GAMEPAD:\n\t\t\t\tif (code <= 0xf)\n\t\t\t\t\tcode += BTN_GAMEPAD;\n\t\t\t\telse\n\t\t\t\t\tcode += BTN_TRIGGER_HAPPY - 0x10;\n\t\t\t\tbreak;\n\t\tdefault:\n\t\t\tswitch (field->physical) {\n\t\t\tcase HID_GD_MOUSE:\n\t\t\tcase HID_GD_POINTER:  code += BTN_MOUSE; break;\n\t\t\tcase HID_GD_JOYSTICK: code += BTN_JOYSTICK; break;\n\t\t\tcase HID_GD_GAMEPAD:  code += BTN_GAMEPAD; break;\n\t\t\tdefault:              code += BTN_MISC;\n\t\t\t}\n\t\t}\n\n\t\tmap_key(code);\n\t\tbreak;\n\n\tcase HID_UP_SIMULATION:\n\t\tswitch (usage->hid & 0xffff) {\n\t\tcase 0xba: map_abs(ABS_RUDDER);   break;\n\t\tcase 0xbb: map_abs(ABS_THROTTLE); break;\n\t\tcase 0xc4: map_abs(ABS_GAS);      break;\n\t\tcase 0xc5: map_abs(ABS_BRAKE);    break;\n\t\tcase 0xc8: map_abs(ABS_WHEEL);    break;\n\t\tdefault:   goto ignore;\n\t\t}\n\t\tbreak;\n\n\tcase HID_UP_GENDESK:\n\t\tif ((usage->hid & 0xf0) == 0x80) {\t/* SystemControl */\n\t\t\tswitch (usage->hid & 0xf) {\n\t\t\tcase 0x1: map_key_clear(KEY_POWER);  break;\n\t\t\tcase 0x2: map_key_clear(KEY_SLEEP);  break;\n\t\t\tcase 0x3: map_key_clear(KEY_WAKEUP); break;\n\t\t\tcase 0x4: map_key_clear(KEY_CONTEXT_MENU); break;\n\t\t\tcase 0x5: map_key_clear(KEY_MENU); break;\n\t\t\tcase 0x6: map_key_clear(KEY_PROG1); break;\n\t\t\tcase 0x7: map_key_clear(KEY_HELP); break;\n\t\t\tcase 0x8: map_key_clear(KEY_EXIT); break;\n\t\t\tcase 0x9: map_key_clear(KEY_SELECT); break;\n\t\t\tcase 0xa: map_key_clear(KEY_RIGHT); break;\n\t\t\tcase 0xb: map_key_clear(KEY_LEFT); break;\n\t\t\tcase 0xc: map_key_clear(KEY_UP); break;\n\t\t\tcase 0xd: map_key_clear(KEY_DOWN); break;\n\t\t\tcase 0xe: map_key_clear(KEY_POWER2); break;\n\t\t\tcase 0xf: map_key_clear(KEY_RESTART); break;\n\t\t\tdefault: goto unknown;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((usage->hid & 0xf0) == 0xb0) {\t/* SC - Display */\n\t\t\tswitch (usage->hid & 0xf) {\n\t\t\tcase 0x05: map_key_clear(KEY_SWITCHVIDEOMODE); break;\n\t\t\tdefault: goto ignore;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Some lazy vendors declare 255 usages for System Control,\n\t\t * leading to the creation of ABS_X|Y axis and too many others.\n\t\t * It wouldn't be a problem if joydev doesn't consider the\n\t\t * device as a joystick then.\n\t\t */\n\t\tif (field->application == HID_GD_SYSTEM_CONTROL)\n\t\t\tgoto ignore;\n\n\t\tif ((usage->hid & 0xf0) == 0x90) {\t/* D-pad */\n\t\t\tswitch (usage->hid) {\n\t\t\tcase HID_GD_UP:\t   usage->hat_dir = 1; break;\n\t\t\tcase HID_GD_DOWN:  usage->hat_dir = 5; break;\n\t\t\tcase HID_GD_RIGHT: usage->hat_dir = 3; break;\n\t\t\tcase HID_GD_LEFT:  usage->hat_dir = 7; break;\n\t\t\tdefault: goto unknown;\n\t\t\t}\n\t\t\tif (field->dpad) {\n\t\t\t\tmap_abs(field->dpad);\n\t\t\t\tgoto ignore;\n\t\t\t}\n\t\t\tmap_abs(ABS_HAT0X);\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (usage->hid) {\n\t\t/* These usage IDs map directly to the usage codes. */\n\t\tcase HID_GD_X: case HID_GD_Y: case HID_GD_Z:\n\t\tcase HID_GD_RX: case HID_GD_RY: case HID_GD_RZ:\n\t\t\tif (field->flags & HID_MAIN_ITEM_RELATIVE)\n\t\t\t\tmap_rel(usage->hid & 0xf);\n\t\t\telse\n\t\t\t\tmap_abs_clear(usage->hid & 0xf);\n\t\t\tbreak;\n\n\t\tcase HID_GD_WHEEL:\n\t\t\tif (field->flags & HID_MAIN_ITEM_RELATIVE) {\n\t\t\t\tset_bit(REL_WHEEL, input->relbit);\n\t\t\t\tmap_rel(REL_WHEEL_HI_RES);\n\t\t\t} else {\n\t\t\t\tmap_abs(usage->hid & 0xf);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase HID_GD_SLIDER: case HID_GD_DIAL:\n\t\t\tif (field->flags & HID_MAIN_ITEM_RELATIVE)\n\t\t\t\tmap_rel(usage->hid & 0xf);\n\t\t\telse\n\t\t\t\tmap_abs(usage->hid & 0xf);\n\t\t\tbreak;\n\n\t\tcase HID_GD_HATSWITCH:\n\t\t\tusage->hat_min = field->logical_minimum;\n\t\t\tusage->hat_max = field->logical_maximum;\n\t\t\tmap_abs(ABS_HAT0X);\n\t\t\tbreak;\n\n\t\tcase HID_GD_START:\tmap_key_clear(BTN_START);\tbreak;\n\t\tcase HID_GD_SELECT:\tmap_key_clear(BTN_SELECT);\tbreak;\n\n\t\tcase HID_GD_RFKILL_BTN:\n\t\t\t/* MS wireless radio ctl extension, also check CA */\n\t\t\tif (field->application == HID_GD_WIRELESS_RADIO_CTLS) {\n\t\t\t\tmap_key_clear(KEY_RFKILL);\n\t\t\t\t/* We need to simulate the btn release */\n\t\t\t\tfield->flags |= HID_MAIN_ITEM_RELATIVE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tdefault: goto unknown;\n\t\t}\n\n\t\tbreak;\n\n\tcase HID_UP_LED:\n\t\tswitch (usage->hid & 0xffff) {\t\t      /* HID-Value:                   */\n\t\tcase 0x01:  map_led (LED_NUML);     break;    /*   \"Num Lock\"                 */\n\t\tcase 0x02:  map_led (LED_CAPSL);    break;    /*   \"Caps Lock\"                */\n\t\tcase 0x03:  map_led (LED_SCROLLL);  break;    /*   \"Scroll Lock\"              */\n\t\tcase 0x04:  map_led (LED_COMPOSE);  break;    /*   \"Compose\"                  */\n\t\tcase 0x05:  map_led (LED_KANA);     break;    /*   \"Kana\"                     */\n\t\tcase 0x27:  map_led (LED_SLEEP);    break;    /*   \"Stand-By\"                 */\n\t\tcase 0x4c:  map_led (LED_SUSPEND);  break;    /*   \"System Suspend\"           */\n\t\tcase 0x09:  map_led (LED_MUTE);     break;    /*   \"Mute\"                     */\n\t\tcase 0x4b:  map_led (LED_MISC);     break;    /*   \"Generic Indicator\"        */\n\t\tcase 0x19:  map_led (LED_MAIL);     break;    /*   \"Message Waiting\"          */\n\t\tcase 0x4d:  map_led (LED_CHARGING); break;    /*   \"External Power Connected\" */\n\n\t\tdefault: goto ignore;\n\t\t}\n\t\tbreak;\n\n\tcase HID_UP_DIGITIZER:\n\t\tif ((field->application & 0xff) == 0x01) /* Digitizer */\n\t\t\t__set_bit(INPUT_PROP_POINTER, input->propbit);\n\t\telse if ((field->application & 0xff) == 0x02) /* Pen */\n\t\t\t__set_bit(INPUT_PROP_DIRECT, input->propbit);\n\n\t\tswitch (usage->hid & 0xff) {\n\t\tcase 0x00: /* Undefined */\n\t\t\tgoto ignore;\n\n\t\tcase 0x30: /* TipPressure */\n\t\t\tif (!test_bit(BTN_TOUCH, input->keybit)) {\n\t\t\t\tdevice->quirks |= HID_QUIRK_NOTOUCH;\n\t\t\t\tset_bit(EV_KEY, input->evbit);\n\t\t\t\tset_bit(BTN_TOUCH, input->keybit);\n\t\t\t}\n\t\t\tmap_abs_clear(ABS_PRESSURE);\n\t\t\tbreak;\n\n\t\tcase 0x32: /* InRange */\n\t\t\tswitch (field->physical & 0xff) {\n\t\t\tcase 0x21: map_key(BTN_TOOL_MOUSE); break;\n\t\t\tcase 0x22: map_key(BTN_TOOL_FINGER); break;\n\t\t\tdefault: map_key(BTN_TOOL_PEN); break;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 0x3b: /* Battery Strength */\n\t\t\thidinput_setup_battery(device, HID_INPUT_REPORT, field);\n\t\t\tusage->type = EV_PWR;\n\t\t\tgoto ignore;\n\n\t\tcase 0x3c: /* Invert */\n\t\t\tmap_key_clear(BTN_TOOL_RUBBER);\n\t\t\tbreak;\n\n\t\tcase 0x3d: /* X Tilt */\n\t\t\tmap_abs_clear(ABS_TILT_X);\n\t\t\tbreak;\n\n\t\tcase 0x3e: /* Y Tilt */\n\t\t\tmap_abs_clear(ABS_TILT_Y);\n\t\t\tbreak;\n\n\t\tcase 0x33: /* Touch */\n\t\tcase 0x42: /* TipSwitch */\n\t\tcase 0x43: /* TipSwitch2 */\n\t\t\tdevice->quirks &= ~HID_QUIRK_NOTOUCH;\n\t\t\tmap_key_clear(BTN_TOUCH);\n\t\t\tbreak;\n\n\t\tcase 0x44: /* BarrelSwitch */\n\t\t\tmap_key_clear(BTN_STYLUS);\n\t\t\tbreak;\n\n\t\tcase 0x45: /* ERASER */\n\t\t\t/*\n\t\t\t * This event is reported when eraser tip touches the surface.\n\t\t\t * Actual eraser (BTN_TOOL_RUBBER) is set by Invert usage when\n\t\t\t * tool gets in proximity.\n\t\t\t */\n\t\t\tmap_key_clear(BTN_TOUCH);\n\t\t\tbreak;\n\n\t\tcase 0x46: /* TabletPick */\n\t\tcase 0x5a: /* SecondaryBarrelSwitch */\n\t\t\tmap_key_clear(BTN_STYLUS2);\n\t\t\tbreak;\n\n\t\tcase 0x5b: /* TransducerSerialNumber */\n\t\t\tusage->type = EV_MSC;\n\t\t\tusage->code = MSC_SERIAL;\n\t\t\tbit = input->mscbit;\n\t\t\tmax = MSC_MAX;\n\t\t\tbreak;\n\n\t\tdefault:  goto unknown;\n\t\t}\n\t\tbreak;\n\n\tcase HID_UP_TELEPHONY:\n\t\tswitch (usage->hid & HID_USAGE) {\n\t\tcase 0x2f: map_key_clear(KEY_MICMUTE);\t\tbreak;\n\t\tcase 0xb0: map_key_clear(KEY_NUMERIC_0);\tbreak;\n\t\tcase 0xb1: map_key_clear(KEY_NUMERIC_1);\tbreak;\n\t\tcase 0xb2: map_key_clear(KEY_NUMERIC_2);\tbreak;\n\t\tcase 0xb3: map_key_clear(KEY_NUMERIC_3);\tbreak;\n\t\tcase 0xb4: map_key_clear(KEY_NUMERIC_4);\tbreak;\n\t\tcase 0xb5: map_key_clear(KEY_NUMERIC_5);\tbreak;\n\t\tcase 0xb6: map_key_clear(KEY_NUMERIC_6);\tbreak;\n\t\tcase 0xb7: map_key_clear(KEY_NUMERIC_7);\tbreak;\n\t\tcase 0xb8: map_key_clear(KEY_NUMERIC_8);\tbreak;\n\t\tcase 0xb9: map_key_clear(KEY_NUMERIC_9);\tbreak;\n\t\tcase 0xba: map_key_clear(KEY_NUMERIC_STAR);\tbreak;\n\t\tcase 0xbb: map_key_clear(KEY_NUMERIC_POUND);\tbreak;\n\t\tcase 0xbc: map_key_clear(KEY_NUMERIC_A);\tbreak;\n\t\tcase 0xbd: map_key_clear(KEY_NUMERIC_B);\tbreak;\n\t\tcase 0xbe: map_key_clear(KEY_NUMERIC_C);\tbreak;\n\t\tcase 0xbf: map_key_clear(KEY_NUMERIC_D);\tbreak;\n\t\tdefault: goto ignore;\n\t\t}\n\t\tbreak;\n\n\tcase HID_UP_CONSUMER:\t/* USB HUT v1.12, pages 75-84 */\n\t\tswitch (usage->hid & HID_USAGE) {\n\t\tcase 0x000: goto ignore;\n\t\tcase 0x030: map_key_clear(KEY_POWER);\t\tbreak;\n\t\tcase 0x031: map_key_clear(KEY_RESTART);\t\tbreak;\n\t\tcase 0x032: map_key_clear(KEY_SLEEP);\t\tbreak;\n\t\tcase 0x034: map_key_clear(KEY_SLEEP);\t\tbreak;\n\t\tcase 0x035: map_key_clear(KEY_KBDILLUMTOGGLE);\tbreak;\n\t\tcase 0x036: map_key_clear(BTN_MISC);\t\tbreak;\n\n\t\tcase 0x040: map_key_clear(KEY_MENU);\t\tbreak; /* Menu */\n\t\tcase 0x041: map_key_clear(KEY_SELECT);\t\tbreak; /* Menu Pick */\n\t\tcase 0x042: map_key_clear(KEY_UP);\t\tbreak; /* Menu Up */\n\t\tcase 0x043: map_key_clear(KEY_DOWN);\t\tbreak; /* Menu Down */\n\t\tcase 0x044: map_key_clear(KEY_LEFT);\t\tbreak; /* Menu Left */\n\t\tcase 0x045: map_key_clear(KEY_RIGHT);\t\tbreak; /* Menu Right */\n\t\tcase 0x046: map_key_clear(KEY_ESC);\t\tbreak; /* Menu Escape */\n\t\tcase 0x047: map_key_clear(KEY_KPPLUS);\t\tbreak; /* Menu Value Increase */\n\t\tcase 0x048: map_key_clear(KEY_KPMINUS);\t\tbreak; /* Menu Value Decrease */\n\n\t\tcase 0x060: map_key_clear(KEY_INFO);\t\tbreak; /* Data On Screen */\n\t\tcase 0x061: map_key_clear(KEY_SUBTITLE);\tbreak; /* Closed Caption */\n\t\tcase 0x063: map_key_clear(KEY_VCR);\t\tbreak; /* VCR/TV */\n\t\tcase 0x065: map_key_clear(KEY_CAMERA);\t\tbreak; /* Snapshot */\n\t\tcase 0x069: map_key_clear(KEY_RED);\t\tbreak;\n\t\tcase 0x06a: map_key_clear(KEY_GREEN);\t\tbreak;\n\t\tcase 0x06b: map_key_clear(KEY_BLUE);\t\tbreak;\n\t\tcase 0x06c: map_key_clear(KEY_YELLOW);\t\tbreak;\n\t\tcase 0x06d: map_key_clear(KEY_ASPECT_RATIO);\tbreak;\n\n\t\tcase 0x06f: map_key_clear(KEY_BRIGHTNESSUP);\t\tbreak;\n\t\tcase 0x070: map_key_clear(KEY_BRIGHTNESSDOWN);\t\tbreak;\n\t\tcase 0x072: map_key_clear(KEY_BRIGHTNESS_TOGGLE);\tbreak;\n\t\tcase 0x073: map_key_clear(KEY_BRIGHTNESS_MIN);\t\tbreak;\n\t\tcase 0x074: map_key_clear(KEY_BRIGHTNESS_MAX);\t\tbreak;\n\t\tcase 0x075: map_key_clear(KEY_BRIGHTNESS_AUTO);\t\tbreak;\n\n\t\tcase 0x079: map_key_clear(KEY_KBDILLUMUP);\tbreak;\n\t\tcase 0x07a: map_key_clear(KEY_KBDILLUMDOWN);\tbreak;\n\t\tcase 0x07c: map_key_clear(KEY_KBDILLUMTOGGLE);\tbreak;\n\n\t\tcase 0x082: map_key_clear(KEY_VIDEO_NEXT);\tbreak;\n\t\tcase 0x083: map_key_clear(KEY_LAST);\t\tbreak;\n\t\tcase 0x084: map_key_clear(KEY_ENTER);\t\tbreak;\n\t\tcase 0x088: map_key_clear(KEY_PC);\t\tbreak;\n\t\tcase 0x089: map_key_clear(KEY_TV);\t\tbreak;\n\t\tcase 0x08a: map_key_clear(KEY_WWW);\t\tbreak;\n\t\tcase 0x08b: map_key_clear(KEY_DVD);\t\tbreak;\n\t\tcase 0x08c: map_key_clear(KEY_PHONE);\t\tbreak;\n\t\tcase 0x08d: map_key_clear(KEY_PROGRAM);\t\tbreak;\n\t\tcase 0x08e: map_key_clear(KEY_VIDEOPHONE);\tbreak;\n\t\tcase 0x08f: map_key_clear(KEY_GAMES);\t\tbreak;\n\t\tcase 0x090: map_key_clear(KEY_MEMO);\t\tbreak;\n\t\tcase 0x091: map_key_clear(KEY_CD);\t\tbreak;\n\t\tcase 0x092: map_key_clear(KEY_VCR);\t\tbreak;\n\t\tcase 0x093: map_key_clear(KEY_TUNER);\t\tbreak;\n\t\tcase 0x094: map_key_clear(KEY_EXIT);\t\tbreak;\n\t\tcase 0x095: map_key_clear(KEY_HELP);\t\tbreak;\n\t\tcase 0x096: map_key_clear(KEY_TAPE);\t\tbreak;\n\t\tcase 0x097: map_key_clear(KEY_TV2);\t\tbreak;\n\t\tcase 0x098: map_key_clear(KEY_SAT);\t\tbreak;\n\t\tcase 0x09a: map_key_clear(KEY_PVR);\t\tbreak;\n\n\t\tcase 0x09c: map_key_clear(KEY_CHANNELUP);\tbreak;\n\t\tcase 0x09d: map_key_clear(KEY_CHANNELDOWN);\tbreak;\n\t\tcase 0x0a0: map_key_clear(KEY_VCR2);\t\tbreak;\n\n\t\tcase 0x0b0: map_key_clear(KEY_PLAY);\t\tbreak;\n\t\tcase 0x0b1: map_key_clear(KEY_PAUSE);\t\tbreak;\n\t\tcase 0x0b2: map_key_clear(KEY_RECORD);\t\tbreak;\n\t\tcase 0x0b3: map_key_clear(KEY_FASTFORWARD);\tbreak;\n\t\tcase 0x0b4: map_key_clear(KEY_REWIND);\t\tbreak;\n\t\tcase 0x0b5: map_key_clear(KEY_NEXTSONG);\tbreak;\n\t\tcase 0x0b6: map_key_clear(KEY_PREVIOUSSONG);\tbreak;\n\t\tcase 0x0b7: map_key_clear(KEY_STOPCD);\t\tbreak;\n\t\tcase 0x0b8: map_key_clear(KEY_EJECTCD);\t\tbreak;\n\t\tcase 0x0bc: map_key_clear(KEY_MEDIA_REPEAT);\tbreak;\n\t\tcase 0x0b9: map_key_clear(KEY_SHUFFLE);\t\tbreak;\n\t\tcase 0x0bf: map_key_clear(KEY_SLOW);\t\tbreak;\n\n\t\tcase 0x0cd: map_key_clear(KEY_PLAYPAUSE);\tbreak;\n\t\tcase 0x0cf: map_key_clear(KEY_VOICECOMMAND);\tbreak;\n\t\tcase 0x0e0: map_abs_clear(ABS_VOLUME);\t\tbreak;\n\t\tcase 0x0e2: map_key_clear(KEY_MUTE);\t\tbreak;\n\t\tcase 0x0e5: map_key_clear(KEY_BASSBOOST);\tbreak;\n\t\tcase 0x0e9: map_key_clear(KEY_VOLUMEUP);\tbreak;\n\t\tcase 0x0ea: map_key_clear(KEY_VOLUMEDOWN);\tbreak;\n\t\tcase 0x0f5: map_key_clear(KEY_SLOW);\t\tbreak;\n\n\t\tcase 0x181: map_key_clear(KEY_BUTTONCONFIG);\tbreak;\n\t\tcase 0x182: map_key_clear(KEY_BOOKMARKS);\tbreak;\n\t\tcase 0x183: map_key_clear(KEY_CONFIG);\t\tbreak;\n\t\tcase 0x184: map_key_clear(KEY_WORDPROCESSOR);\tbreak;\n\t\tcase 0x185: map_key_clear(KEY_EDITOR);\t\tbreak;\n\t\tcase 0x186: map_key_clear(KEY_SPREADSHEET);\tbreak;\n\t\tcase 0x187: map_key_clear(KEY_GRAPHICSEDITOR);\tbreak;\n\t\tcase 0x188: map_key_clear(KEY_PRESENTATION);\tbreak;\n\t\tcase 0x189: map_key_clear(KEY_DATABASE);\tbreak;\n\t\tcase 0x18a: map_key_clear(KEY_MAIL);\t\tbreak;\n\t\tcase 0x18b: map_key_clear(KEY_NEWS);\t\tbreak;\n\t\tcase 0x18c: map_key_clear(KEY_VOICEMAIL);\tbreak;\n\t\tcase 0x18d: map_key_clear(KEY_ADDRESSBOOK);\tbreak;\n\t\tcase 0x18e: map_key_clear(KEY_CALENDAR);\tbreak;\n\t\tcase 0x18f: map_key_clear(KEY_TASKMANAGER);\tbreak;\n\t\tcase 0x190: map_key_clear(KEY_JOURNAL);\t\tbreak;\n\t\tcase 0x191: map_key_clear(KEY_FINANCE);\t\tbreak;\n\t\tcase 0x192: map_key_clear(KEY_CALC);\t\tbreak;\n\t\tcase 0x193: map_key_clear(KEY_PLAYER);\t\tbreak;\n\t\tcase 0x194: map_key_clear(KEY_FILE);\t\tbreak;\n\t\tcase 0x196: map_key_clear(KEY_WWW);\t\tbreak;\n\t\tcase 0x199: map_key_clear(KEY_CHAT);\t\tbreak;\n\t\tcase 0x19c: map_key_clear(KEY_LOGOFF);\t\tbreak;\n\t\tcase 0x19e: map_key_clear(KEY_COFFEE);\t\tbreak;\n\t\tcase 0x19f: map_key_clear(KEY_CONTROLPANEL);\t\tbreak;\n\t\tcase 0x1a2: map_key_clear(KEY_APPSELECT);\t\tbreak;\n\t\tcase 0x1a3: map_key_clear(KEY_NEXT);\t\tbreak;\n\t\tcase 0x1a4: map_key_clear(KEY_PREVIOUS);\tbreak;\n\t\tcase 0x1a6: map_key_clear(KEY_HELP);\t\tbreak;\n\t\tcase 0x1a7: map_key_clear(KEY_DOCUMENTS);\tbreak;\n\t\tcase 0x1ab: map_key_clear(KEY_SPELLCHECK);\tbreak;\n\t\tcase 0x1ae: map_key_clear(KEY_KEYBOARD);\tbreak;\n\t\tcase 0x1b1: map_key_clear(KEY_SCREENSAVER);\t\tbreak;\n\t\tcase 0x1b4: map_key_clear(KEY_FILE);\t\tbreak;\n\t\tcase 0x1b6: map_key_clear(KEY_IMAGES);\t\tbreak;\n\t\tcase 0x1b7: map_key_clear(KEY_AUDIO);\t\tbreak;\n\t\tcase 0x1b8: map_key_clear(KEY_VIDEO);\t\tbreak;\n\t\tcase 0x1bc: map_key_clear(KEY_MESSENGER);\tbreak;\n\t\tcase 0x1bd: map_key_clear(KEY_INFO);\t\tbreak;\n\t\tcase 0x1cb: map_key_clear(KEY_ASSISTANT);\tbreak;\n\t\tcase 0x201: map_key_clear(KEY_NEW);\t\tbreak;\n\t\tcase 0x202: map_key_clear(KEY_OPEN);\t\tbreak;\n\t\tcase 0x203: map_key_clear(KEY_CLOSE);\t\tbreak;\n\t\tcase 0x204: map_key_clear(KEY_EXIT);\t\tbreak;\n\t\tcase 0x207: map_key_clear(KEY_SAVE);\t\tbreak;\n\t\tcase 0x208: map_key_clear(KEY_PRINT);\t\tbreak;\n\t\tcase 0x209: map_key_clear(KEY_PROPS);\t\tbreak;\n\t\tcase 0x21a: map_key_clear(KEY_UNDO);\t\tbreak;\n\t\tcase 0x21b: map_key_clear(KEY_COPY);\t\tbreak;\n\t\tcase 0x21c: map_key_clear(KEY_CUT);\t\tbreak;\n\t\tcase 0x21d: map_key_clear(KEY_PASTE);\t\tbreak;\n\t\tcase 0x21f: map_key_clear(KEY_FIND);\t\tbreak;\n\t\tcase 0x221: map_key_clear(KEY_SEARCH);\t\tbreak;\n\t\tcase 0x222: map_key_clear(KEY_GOTO);\t\tbreak;\n\t\tcase 0x223: map_key_clear(KEY_HOMEPAGE);\tbreak;\n\t\tcase 0x224: map_key_clear(KEY_BACK);\t\tbreak;\n\t\tcase 0x225: map_key_clear(KEY_FORWARD);\t\tbreak;\n\t\tcase 0x226: map_key_clear(KEY_STOP);\t\tbreak;\n\t\tcase 0x227: map_key_clear(KEY_REFRESH);\t\tbreak;\n\t\tcase 0x22a: map_key_clear(KEY_BOOKMARKS);\tbreak;\n\t\tcase 0x22d: map_key_clear(KEY_ZOOMIN);\t\tbreak;\n\t\tcase 0x22e: map_key_clear(KEY_ZOOMOUT);\t\tbreak;\n\t\tcase 0x22f: map_key_clear(KEY_ZOOMRESET);\tbreak;\n\t\tcase 0x232: map_key_clear(KEY_FULL_SCREEN);\tbreak;\n\t\tcase 0x233: map_key_clear(KEY_SCROLLUP);\tbreak;\n\t\tcase 0x234: map_key_clear(KEY_SCROLLDOWN);\tbreak;\n\t\tcase 0x238: /* AC Pan */\n\t\t\tset_bit(REL_HWHEEL, input->relbit);\n\t\t\tmap_rel(REL_HWHEEL_HI_RES);\n\t\t\tbreak;\n\t\tcase 0x23d: map_key_clear(KEY_EDIT);\t\tbreak;\n\t\tcase 0x25f: map_key_clear(KEY_CANCEL);\t\tbreak;\n\t\tcase 0x269: map_key_clear(KEY_INSERT);\t\tbreak;\n\t\tcase 0x26a: map_key_clear(KEY_DELETE);\t\tbreak;\n\t\tcase 0x279: map_key_clear(KEY_REDO);\t\tbreak;\n\n\t\tcase 0x289: map_key_clear(KEY_REPLY);\t\tbreak;\n\t\tcase 0x28b: map_key_clear(KEY_FORWARDMAIL);\tbreak;\n\t\tcase 0x28c: map_key_clear(KEY_SEND);\t\tbreak;\n\n\t\tcase 0x29d: map_key_clear(KEY_KBD_LAYOUT_NEXT);\tbreak;\n\n\t\tcase 0x2c7: map_key_clear(KEY_KBDINPUTASSIST_PREV);\t\tbreak;\n\t\tcase 0x2c8: map_key_clear(KEY_KBDINPUTASSIST_NEXT);\t\tbreak;\n\t\tcase 0x2c9: map_key_clear(KEY_KBDINPUTASSIST_PREVGROUP);\t\tbreak;\n\t\tcase 0x2ca: map_key_clear(KEY_KBDINPUTASSIST_NEXTGROUP);\t\tbreak;\n\t\tcase 0x2cb: map_key_clear(KEY_KBDINPUTASSIST_ACCEPT);\tbreak;\n\t\tcase 0x2cc: map_key_clear(KEY_KBDINPUTASSIST_CANCEL);\tbreak;\n\n\t\tcase 0x29f: map_key_clear(KEY_SCALE);\t\tbreak;\n\n\t\tdefault: map_key_clear(KEY_UNKNOWN);\n\t\t}\n\t\tbreak;\n\n\tcase HID_UP_GENDEVCTRLS:\n\t\tswitch (usage->hid) {\n\t\tcase HID_DC_BATTERYSTRENGTH:\n\t\t\thidinput_setup_battery(device, HID_INPUT_REPORT, field);\n\t\t\tusage->type = EV_PWR;\n\t\t\tgoto ignore;\n\t\t}\n\t\tgoto unknown;\n\n\tcase HID_UP_HPVENDOR:\t/* Reported on a Dutch layout HP5308 */\n\t\tset_bit(EV_REP, input->evbit);\n\t\tswitch (usage->hid & HID_USAGE) {\n\t\tcase 0x021: map_key_clear(KEY_PRINT);           break;\n\t\tcase 0x070: map_key_clear(KEY_HP);\t\tbreak;\n\t\tcase 0x071: map_key_clear(KEY_CAMERA);\t\tbreak;\n\t\tcase 0x072: map_key_clear(KEY_SOUND);\t\tbreak;\n\t\tcase 0x073: map_key_clear(KEY_QUESTION);\tbreak;\n\t\tcase 0x080: map_key_clear(KEY_EMAIL);\t\tbreak;\n\t\tcase 0x081: map_key_clear(KEY_CHAT);\t\tbreak;\n\t\tcase 0x082: map_key_clear(KEY_SEARCH);\t\tbreak;\n\t\tcase 0x083: map_key_clear(KEY_CONNECT);\t        break;\n\t\tcase 0x084: map_key_clear(KEY_FINANCE);\t\tbreak;\n\t\tcase 0x085: map_key_clear(KEY_SPORT);\t\tbreak;\n\t\tcase 0x086: map_key_clear(KEY_SHOP);\t        break;\n\t\tdefault:    goto ignore;\n\t\t}\n\t\tbreak;\n\n\tcase HID_UP_HPVENDOR2:\n\t\tset_bit(EV_REP, input->evbit);\n\t\tswitch (usage->hid & HID_USAGE) {\n\t\tcase 0x001: map_key_clear(KEY_MICMUTE);\t\tbreak;\n\t\tcase 0x003: map_key_clear(KEY_BRIGHTNESSDOWN);\tbreak;\n\t\tcase 0x004: map_key_clear(KEY_BRIGHTNESSUP);\tbreak;\n\t\tdefault:    goto ignore;\n\t\t}\n\t\tbreak;\n\n\tcase HID_UP_MSVENDOR:\n\t\tgoto ignore;\n\n\tcase HID_UP_CUSTOM: /* Reported on Logitech and Apple USB keyboards */\n\t\tset_bit(EV_REP, input->evbit);\n\t\tgoto ignore;\n\n\tcase HID_UP_LOGIVENDOR:\n\t\t/* intentional fallback */\n\tcase HID_UP_LOGIVENDOR2:\n\t\t/* intentional fallback */\n\tcase HID_UP_LOGIVENDOR3:\n\t\tgoto ignore;\n\n\tcase HID_UP_PID:\n\t\tswitch (usage->hid & HID_USAGE) {\n\t\tcase 0xa4: map_key_clear(BTN_DEAD);\tbreak;\n\t\tdefault: goto ignore;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\tunknown:\n\t\tif (field->report_size == 1) {\n\t\t\tif (field->report->type == HID_OUTPUT_REPORT) {\n\t\t\t\tmap_led(LED_MISC);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmap_key(BTN_MISC);\n\t\t\tbreak;\n\t\t}\n\t\tif (field->flags & HID_MAIN_ITEM_RELATIVE) {\n\t\t\tmap_rel(REL_MISC);\n\t\t\tbreak;\n\t\t}\n\t\tmap_abs(ABS_MISC);\n\t\tbreak;\n\t}\n\nmapped:\n\tif (device->driver->input_mapped &&\n\t    device->driver->input_mapped(device, hidinput, field, usage,\n\t\t\t\t\t &bit, &max) < 0) {\n\t\t/*\n\t\t * The driver indicated that no further generic handling\n\t\t * of the usage is desired.\n\t\t */\n\t\treturn;\n\t}\n\n\tset_bit(usage->type, input->evbit);\n\n\t/*\n\t * This part is *really* controversial:\n\t * - HID aims at being generic so we should do our best to export\n\t *   all incoming events\n\t * - HID describes what events are, so there is no reason for ABS_X\n\t *   to be mapped to ABS_Y\n\t * - HID is using *_MISC+N as a default value, but nothing prevents\n\t *   *_MISC+N to overwrite a legitimate even, which confuses userspace\n\t *   (for instance ABS_MISC + 7 is ABS_MT_SLOT, which has a different\n\t *   processing)\n\t *\n\t * If devices still want to use this (at their own risk), they will\n\t * have to use the quirk HID_QUIRK_INCREMENT_USAGE_ON_DUPLICATE, but\n\t * the default should be a reliable mapping.\n\t */\n\twhile (usage->code <= max && test_and_set_bit(usage->code, bit)) {\n\t\tif (device->quirks & HID_QUIRK_INCREMENT_USAGE_ON_DUPLICATE) {\n\t\t\tusage->code = find_next_zero_bit(bit,\n\t\t\t\t\t\t\t max + 1,\n\t\t\t\t\t\t\t usage->code);\n\t\t} else {\n\t\t\tdevice->status |= HID_STAT_DUP_DETECTED;\n\t\t\tgoto ignore;\n\t\t}\n\t}\n\n\tif (usage->code > max)\n\t\tgoto ignore;\n\n\tif (usage->type == EV_ABS) {\n\n\t\tint a = field->logical_minimum;\n\t\tint b = field->logical_maximum;\n\n\t\tif ((device->quirks & HID_QUIRK_BADPAD) && (usage->code == ABS_X || usage->code == ABS_Y)) {\n\t\t\ta = field->logical_minimum = 0;\n\t\t\tb = field->logical_maximum = 255;\n\t\t}\n\n\t\tif (field->application == HID_GD_GAMEPAD || field->application == HID_GD_JOYSTICK)\n\t\t\tinput_set_abs_params(input, usage->code, a, b, (b - a) >> 8, (b - a) >> 4);\n\t\telse\tinput_set_abs_params(input, usage->code, a, b, 0, 0);\n\n\t\tinput_abs_set_res(input, usage->code,\n\t\t\t\t  hidinput_calc_abs_res(field, usage->code));\n\n\t\t/* use a larger default input buffer for MT devices */\n\t\tif (usage->code == ABS_MT_POSITION_X && input->hint_events_per_packet == 0)\n\t\t\tinput_set_events_per_packet(input, 60);\n\t}\n\n\tif (usage->type == EV_ABS &&\n\t    (usage->hat_min < usage->hat_max || usage->hat_dir)) {\n\t\tint i;\n\t\tfor (i = usage->code; i < usage->code + 2 && i <= max; i++) {\n\t\t\tinput_set_abs_params(input, i, -1, 1, 0, 0);\n\t\t\tset_bit(i, input->absbit);\n\t\t}\n\t\tif (usage->hat_dir && !field->dpad)\n\t\t\tfield->dpad = usage->code;\n\t}\n\n\t/* for those devices which produce Consumer volume usage as relative,\n\t * we emulate pressing volumeup/volumedown appropriate number of times\n\t * in hidinput_hid_event()\n\t */\n\tif ((usage->type == EV_ABS) && (field->flags & HID_MAIN_ITEM_RELATIVE) &&\n\t\t\t(usage->code == ABS_VOLUME)) {\n\t\tset_bit(KEY_VOLUMEUP, input->keybit);\n\t\tset_bit(KEY_VOLUMEDOWN, input->keybit);\n\t}\n\n\tif (usage->type == EV_KEY) {\n\t\tset_bit(EV_MSC, input->evbit);\n\t\tset_bit(MSC_SCAN, input->mscbit);\n\t}\n\n\treturn;\n\nignore:\n\tusage->type = 0;\n\tusage->code = 0;\n}",
        "code_after_change": "static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_field *field,\n\t\t\t\t     struct hid_usage *usage)\n{\n\tstruct input_dev *input = hidinput->input;\n\tstruct hid_device *device = input_get_drvdata(input);\n\tint max = 0, code;\n\tunsigned long *bit = NULL;\n\n\tfield->hidinput = hidinput;\n\n\tif (field->flags & HID_MAIN_ITEM_CONSTANT)\n\t\tgoto ignore;\n\n\t/* Ignore if report count is out of bounds. */\n\tif (field->report_count < 1)\n\t\tgoto ignore;\n\n\t/* only LED usages are supported in output fields */\n\tif (field->report_type == HID_OUTPUT_REPORT &&\n\t\t\t(usage->hid & HID_USAGE_PAGE) != HID_UP_LED) {\n\t\tgoto ignore;\n\t}\n\n\tif (device->driver->input_mapping) {\n\t\tint ret = device->driver->input_mapping(device, hidinput, field,\n\t\t\t\tusage, &bit, &max);\n\t\tif (ret > 0)\n\t\t\tgoto mapped;\n\t\tif (ret < 0)\n\t\t\tgoto ignore;\n\t}\n\n\tswitch (usage->hid & HID_USAGE_PAGE) {\n\tcase HID_UP_UNDEFINED:\n\t\tgoto ignore;\n\n\tcase HID_UP_KEYBOARD:\n\t\tset_bit(EV_REP, input->evbit);\n\n\t\tif ((usage->hid & HID_USAGE) < 256) {\n\t\t\tif (!hid_keyboard[usage->hid & HID_USAGE]) goto ignore;\n\t\t\tmap_key_clear(hid_keyboard[usage->hid & HID_USAGE]);\n\t\t} else\n\t\t\tmap_key(KEY_UNKNOWN);\n\n\t\tbreak;\n\n\tcase HID_UP_BUTTON:\n\t\tcode = ((usage->hid - 1) & HID_USAGE);\n\n\t\tswitch (field->application) {\n\t\tcase HID_GD_MOUSE:\n\t\tcase HID_GD_POINTER:  code += BTN_MOUSE; break;\n\t\tcase HID_GD_JOYSTICK:\n\t\t\t\tif (code <= 0xf)\n\t\t\t\t\tcode += BTN_JOYSTICK;\n\t\t\t\telse\n\t\t\t\t\tcode += BTN_TRIGGER_HAPPY - 0x10;\n\t\t\t\tbreak;\n\t\tcase HID_GD_GAMEPAD:\n\t\t\t\tif (code <= 0xf)\n\t\t\t\t\tcode += BTN_GAMEPAD;\n\t\t\t\telse\n\t\t\t\t\tcode += BTN_TRIGGER_HAPPY - 0x10;\n\t\t\t\tbreak;\n\t\tdefault:\n\t\t\tswitch (field->physical) {\n\t\t\tcase HID_GD_MOUSE:\n\t\t\tcase HID_GD_POINTER:  code += BTN_MOUSE; break;\n\t\t\tcase HID_GD_JOYSTICK: code += BTN_JOYSTICK; break;\n\t\t\tcase HID_GD_GAMEPAD:  code += BTN_GAMEPAD; break;\n\t\t\tdefault:              code += BTN_MISC;\n\t\t\t}\n\t\t}\n\n\t\tmap_key(code);\n\t\tbreak;\n\n\tcase HID_UP_SIMULATION:\n\t\tswitch (usage->hid & 0xffff) {\n\t\tcase 0xba: map_abs(ABS_RUDDER);   break;\n\t\tcase 0xbb: map_abs(ABS_THROTTLE); break;\n\t\tcase 0xc4: map_abs(ABS_GAS);      break;\n\t\tcase 0xc5: map_abs(ABS_BRAKE);    break;\n\t\tcase 0xc8: map_abs(ABS_WHEEL);    break;\n\t\tdefault:   goto ignore;\n\t\t}\n\t\tbreak;\n\n\tcase HID_UP_GENDESK:\n\t\tif ((usage->hid & 0xf0) == 0x80) {\t/* SystemControl */\n\t\t\tswitch (usage->hid & 0xf) {\n\t\t\tcase 0x1: map_key_clear(KEY_POWER);  break;\n\t\t\tcase 0x2: map_key_clear(KEY_SLEEP);  break;\n\t\t\tcase 0x3: map_key_clear(KEY_WAKEUP); break;\n\t\t\tcase 0x4: map_key_clear(KEY_CONTEXT_MENU); break;\n\t\t\tcase 0x5: map_key_clear(KEY_MENU); break;\n\t\t\tcase 0x6: map_key_clear(KEY_PROG1); break;\n\t\t\tcase 0x7: map_key_clear(KEY_HELP); break;\n\t\t\tcase 0x8: map_key_clear(KEY_EXIT); break;\n\t\t\tcase 0x9: map_key_clear(KEY_SELECT); break;\n\t\t\tcase 0xa: map_key_clear(KEY_RIGHT); break;\n\t\t\tcase 0xb: map_key_clear(KEY_LEFT); break;\n\t\t\tcase 0xc: map_key_clear(KEY_UP); break;\n\t\t\tcase 0xd: map_key_clear(KEY_DOWN); break;\n\t\t\tcase 0xe: map_key_clear(KEY_POWER2); break;\n\t\t\tcase 0xf: map_key_clear(KEY_RESTART); break;\n\t\t\tdefault: goto unknown;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((usage->hid & 0xf0) == 0xb0) {\t/* SC - Display */\n\t\t\tswitch (usage->hid & 0xf) {\n\t\t\tcase 0x05: map_key_clear(KEY_SWITCHVIDEOMODE); break;\n\t\t\tdefault: goto ignore;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Some lazy vendors declare 255 usages for System Control,\n\t\t * leading to the creation of ABS_X|Y axis and too many others.\n\t\t * It wouldn't be a problem if joydev doesn't consider the\n\t\t * device as a joystick then.\n\t\t */\n\t\tif (field->application == HID_GD_SYSTEM_CONTROL)\n\t\t\tgoto ignore;\n\n\t\tif ((usage->hid & 0xf0) == 0x90) {\t/* D-pad */\n\t\t\tswitch (usage->hid) {\n\t\t\tcase HID_GD_UP:\t   usage->hat_dir = 1; break;\n\t\t\tcase HID_GD_DOWN:  usage->hat_dir = 5; break;\n\t\t\tcase HID_GD_RIGHT: usage->hat_dir = 3; break;\n\t\t\tcase HID_GD_LEFT:  usage->hat_dir = 7; break;\n\t\t\tdefault: goto unknown;\n\t\t\t}\n\t\t\tif (field->dpad) {\n\t\t\t\tmap_abs(field->dpad);\n\t\t\t\tgoto ignore;\n\t\t\t}\n\t\t\tmap_abs(ABS_HAT0X);\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (usage->hid) {\n\t\t/* These usage IDs map directly to the usage codes. */\n\t\tcase HID_GD_X: case HID_GD_Y: case HID_GD_Z:\n\t\tcase HID_GD_RX: case HID_GD_RY: case HID_GD_RZ:\n\t\t\tif (field->flags & HID_MAIN_ITEM_RELATIVE)\n\t\t\t\tmap_rel(usage->hid & 0xf);\n\t\t\telse\n\t\t\t\tmap_abs_clear(usage->hid & 0xf);\n\t\t\tbreak;\n\n\t\tcase HID_GD_WHEEL:\n\t\t\tif (field->flags & HID_MAIN_ITEM_RELATIVE) {\n\t\t\t\tset_bit(REL_WHEEL, input->relbit);\n\t\t\t\tmap_rel(REL_WHEEL_HI_RES);\n\t\t\t} else {\n\t\t\t\tmap_abs(usage->hid & 0xf);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase HID_GD_SLIDER: case HID_GD_DIAL:\n\t\t\tif (field->flags & HID_MAIN_ITEM_RELATIVE)\n\t\t\t\tmap_rel(usage->hid & 0xf);\n\t\t\telse\n\t\t\t\tmap_abs(usage->hid & 0xf);\n\t\t\tbreak;\n\n\t\tcase HID_GD_HATSWITCH:\n\t\t\tusage->hat_min = field->logical_minimum;\n\t\t\tusage->hat_max = field->logical_maximum;\n\t\t\tmap_abs(ABS_HAT0X);\n\t\t\tbreak;\n\n\t\tcase HID_GD_START:\tmap_key_clear(BTN_START);\tbreak;\n\t\tcase HID_GD_SELECT:\tmap_key_clear(BTN_SELECT);\tbreak;\n\n\t\tcase HID_GD_RFKILL_BTN:\n\t\t\t/* MS wireless radio ctl extension, also check CA */\n\t\t\tif (field->application == HID_GD_WIRELESS_RADIO_CTLS) {\n\t\t\t\tmap_key_clear(KEY_RFKILL);\n\t\t\t\t/* We need to simulate the btn release */\n\t\t\t\tfield->flags |= HID_MAIN_ITEM_RELATIVE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tdefault: goto unknown;\n\t\t}\n\n\t\tbreak;\n\n\tcase HID_UP_LED:\n\t\tswitch (usage->hid & 0xffff) {\t\t      /* HID-Value:                   */\n\t\tcase 0x01:  map_led (LED_NUML);     break;    /*   \"Num Lock\"                 */\n\t\tcase 0x02:  map_led (LED_CAPSL);    break;    /*   \"Caps Lock\"                */\n\t\tcase 0x03:  map_led (LED_SCROLLL);  break;    /*   \"Scroll Lock\"              */\n\t\tcase 0x04:  map_led (LED_COMPOSE);  break;    /*   \"Compose\"                  */\n\t\tcase 0x05:  map_led (LED_KANA);     break;    /*   \"Kana\"                     */\n\t\tcase 0x27:  map_led (LED_SLEEP);    break;    /*   \"Stand-By\"                 */\n\t\tcase 0x4c:  map_led (LED_SUSPEND);  break;    /*   \"System Suspend\"           */\n\t\tcase 0x09:  map_led (LED_MUTE);     break;    /*   \"Mute\"                     */\n\t\tcase 0x4b:  map_led (LED_MISC);     break;    /*   \"Generic Indicator\"        */\n\t\tcase 0x19:  map_led (LED_MAIL);     break;    /*   \"Message Waiting\"          */\n\t\tcase 0x4d:  map_led (LED_CHARGING); break;    /*   \"External Power Connected\" */\n\n\t\tdefault: goto ignore;\n\t\t}\n\t\tbreak;\n\n\tcase HID_UP_DIGITIZER:\n\t\tif ((field->application & 0xff) == 0x01) /* Digitizer */\n\t\t\t__set_bit(INPUT_PROP_POINTER, input->propbit);\n\t\telse if ((field->application & 0xff) == 0x02) /* Pen */\n\t\t\t__set_bit(INPUT_PROP_DIRECT, input->propbit);\n\n\t\tswitch (usage->hid & 0xff) {\n\t\tcase 0x00: /* Undefined */\n\t\t\tgoto ignore;\n\n\t\tcase 0x30: /* TipPressure */\n\t\t\tif (!test_bit(BTN_TOUCH, input->keybit)) {\n\t\t\t\tdevice->quirks |= HID_QUIRK_NOTOUCH;\n\t\t\t\tset_bit(EV_KEY, input->evbit);\n\t\t\t\tset_bit(BTN_TOUCH, input->keybit);\n\t\t\t}\n\t\t\tmap_abs_clear(ABS_PRESSURE);\n\t\t\tbreak;\n\n\t\tcase 0x32: /* InRange */\n\t\t\tswitch (field->physical & 0xff) {\n\t\t\tcase 0x21: map_key(BTN_TOOL_MOUSE); break;\n\t\t\tcase 0x22: map_key(BTN_TOOL_FINGER); break;\n\t\t\tdefault: map_key(BTN_TOOL_PEN); break;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 0x3b: /* Battery Strength */\n\t\t\thidinput_setup_battery(device, HID_INPUT_REPORT, field);\n\t\t\tusage->type = EV_PWR;\n\t\t\tgoto ignore;\n\n\t\tcase 0x3c: /* Invert */\n\t\t\tmap_key_clear(BTN_TOOL_RUBBER);\n\t\t\tbreak;\n\n\t\tcase 0x3d: /* X Tilt */\n\t\t\tmap_abs_clear(ABS_TILT_X);\n\t\t\tbreak;\n\n\t\tcase 0x3e: /* Y Tilt */\n\t\t\tmap_abs_clear(ABS_TILT_Y);\n\t\t\tbreak;\n\n\t\tcase 0x33: /* Touch */\n\t\tcase 0x42: /* TipSwitch */\n\t\tcase 0x43: /* TipSwitch2 */\n\t\t\tdevice->quirks &= ~HID_QUIRK_NOTOUCH;\n\t\t\tmap_key_clear(BTN_TOUCH);\n\t\t\tbreak;\n\n\t\tcase 0x44: /* BarrelSwitch */\n\t\t\tmap_key_clear(BTN_STYLUS);\n\t\t\tbreak;\n\n\t\tcase 0x45: /* ERASER */\n\t\t\t/*\n\t\t\t * This event is reported when eraser tip touches the surface.\n\t\t\t * Actual eraser (BTN_TOOL_RUBBER) is set by Invert usage when\n\t\t\t * tool gets in proximity.\n\t\t\t */\n\t\t\tmap_key_clear(BTN_TOUCH);\n\t\t\tbreak;\n\n\t\tcase 0x46: /* TabletPick */\n\t\tcase 0x5a: /* SecondaryBarrelSwitch */\n\t\t\tmap_key_clear(BTN_STYLUS2);\n\t\t\tbreak;\n\n\t\tcase 0x5b: /* TransducerSerialNumber */\n\t\t\tusage->type = EV_MSC;\n\t\t\tusage->code = MSC_SERIAL;\n\t\t\tbit = input->mscbit;\n\t\t\tmax = MSC_MAX;\n\t\t\tbreak;\n\n\t\tdefault:  goto unknown;\n\t\t}\n\t\tbreak;\n\n\tcase HID_UP_TELEPHONY:\n\t\tswitch (usage->hid & HID_USAGE) {\n\t\tcase 0x2f: map_key_clear(KEY_MICMUTE);\t\tbreak;\n\t\tcase 0xb0: map_key_clear(KEY_NUMERIC_0);\tbreak;\n\t\tcase 0xb1: map_key_clear(KEY_NUMERIC_1);\tbreak;\n\t\tcase 0xb2: map_key_clear(KEY_NUMERIC_2);\tbreak;\n\t\tcase 0xb3: map_key_clear(KEY_NUMERIC_3);\tbreak;\n\t\tcase 0xb4: map_key_clear(KEY_NUMERIC_4);\tbreak;\n\t\tcase 0xb5: map_key_clear(KEY_NUMERIC_5);\tbreak;\n\t\tcase 0xb6: map_key_clear(KEY_NUMERIC_6);\tbreak;\n\t\tcase 0xb7: map_key_clear(KEY_NUMERIC_7);\tbreak;\n\t\tcase 0xb8: map_key_clear(KEY_NUMERIC_8);\tbreak;\n\t\tcase 0xb9: map_key_clear(KEY_NUMERIC_9);\tbreak;\n\t\tcase 0xba: map_key_clear(KEY_NUMERIC_STAR);\tbreak;\n\t\tcase 0xbb: map_key_clear(KEY_NUMERIC_POUND);\tbreak;\n\t\tcase 0xbc: map_key_clear(KEY_NUMERIC_A);\tbreak;\n\t\tcase 0xbd: map_key_clear(KEY_NUMERIC_B);\tbreak;\n\t\tcase 0xbe: map_key_clear(KEY_NUMERIC_C);\tbreak;\n\t\tcase 0xbf: map_key_clear(KEY_NUMERIC_D);\tbreak;\n\t\tdefault: goto ignore;\n\t\t}\n\t\tbreak;\n\n\tcase HID_UP_CONSUMER:\t/* USB HUT v1.12, pages 75-84 */\n\t\tswitch (usage->hid & HID_USAGE) {\n\t\tcase 0x000: goto ignore;\n\t\tcase 0x030: map_key_clear(KEY_POWER);\t\tbreak;\n\t\tcase 0x031: map_key_clear(KEY_RESTART);\t\tbreak;\n\t\tcase 0x032: map_key_clear(KEY_SLEEP);\t\tbreak;\n\t\tcase 0x034: map_key_clear(KEY_SLEEP);\t\tbreak;\n\t\tcase 0x035: map_key_clear(KEY_KBDILLUMTOGGLE);\tbreak;\n\t\tcase 0x036: map_key_clear(BTN_MISC);\t\tbreak;\n\n\t\tcase 0x040: map_key_clear(KEY_MENU);\t\tbreak; /* Menu */\n\t\tcase 0x041: map_key_clear(KEY_SELECT);\t\tbreak; /* Menu Pick */\n\t\tcase 0x042: map_key_clear(KEY_UP);\t\tbreak; /* Menu Up */\n\t\tcase 0x043: map_key_clear(KEY_DOWN);\t\tbreak; /* Menu Down */\n\t\tcase 0x044: map_key_clear(KEY_LEFT);\t\tbreak; /* Menu Left */\n\t\tcase 0x045: map_key_clear(KEY_RIGHT);\t\tbreak; /* Menu Right */\n\t\tcase 0x046: map_key_clear(KEY_ESC);\t\tbreak; /* Menu Escape */\n\t\tcase 0x047: map_key_clear(KEY_KPPLUS);\t\tbreak; /* Menu Value Increase */\n\t\tcase 0x048: map_key_clear(KEY_KPMINUS);\t\tbreak; /* Menu Value Decrease */\n\n\t\tcase 0x060: map_key_clear(KEY_INFO);\t\tbreak; /* Data On Screen */\n\t\tcase 0x061: map_key_clear(KEY_SUBTITLE);\tbreak; /* Closed Caption */\n\t\tcase 0x063: map_key_clear(KEY_VCR);\t\tbreak; /* VCR/TV */\n\t\tcase 0x065: map_key_clear(KEY_CAMERA);\t\tbreak; /* Snapshot */\n\t\tcase 0x069: map_key_clear(KEY_RED);\t\tbreak;\n\t\tcase 0x06a: map_key_clear(KEY_GREEN);\t\tbreak;\n\t\tcase 0x06b: map_key_clear(KEY_BLUE);\t\tbreak;\n\t\tcase 0x06c: map_key_clear(KEY_YELLOW);\t\tbreak;\n\t\tcase 0x06d: map_key_clear(KEY_ASPECT_RATIO);\tbreak;\n\n\t\tcase 0x06f: map_key_clear(KEY_BRIGHTNESSUP);\t\tbreak;\n\t\tcase 0x070: map_key_clear(KEY_BRIGHTNESSDOWN);\t\tbreak;\n\t\tcase 0x072: map_key_clear(KEY_BRIGHTNESS_TOGGLE);\tbreak;\n\t\tcase 0x073: map_key_clear(KEY_BRIGHTNESS_MIN);\t\tbreak;\n\t\tcase 0x074: map_key_clear(KEY_BRIGHTNESS_MAX);\t\tbreak;\n\t\tcase 0x075: map_key_clear(KEY_BRIGHTNESS_AUTO);\t\tbreak;\n\n\t\tcase 0x079: map_key_clear(KEY_KBDILLUMUP);\tbreak;\n\t\tcase 0x07a: map_key_clear(KEY_KBDILLUMDOWN);\tbreak;\n\t\tcase 0x07c: map_key_clear(KEY_KBDILLUMTOGGLE);\tbreak;\n\n\t\tcase 0x082: map_key_clear(KEY_VIDEO_NEXT);\tbreak;\n\t\tcase 0x083: map_key_clear(KEY_LAST);\t\tbreak;\n\t\tcase 0x084: map_key_clear(KEY_ENTER);\t\tbreak;\n\t\tcase 0x088: map_key_clear(KEY_PC);\t\tbreak;\n\t\tcase 0x089: map_key_clear(KEY_TV);\t\tbreak;\n\t\tcase 0x08a: map_key_clear(KEY_WWW);\t\tbreak;\n\t\tcase 0x08b: map_key_clear(KEY_DVD);\t\tbreak;\n\t\tcase 0x08c: map_key_clear(KEY_PHONE);\t\tbreak;\n\t\tcase 0x08d: map_key_clear(KEY_PROGRAM);\t\tbreak;\n\t\tcase 0x08e: map_key_clear(KEY_VIDEOPHONE);\tbreak;\n\t\tcase 0x08f: map_key_clear(KEY_GAMES);\t\tbreak;\n\t\tcase 0x090: map_key_clear(KEY_MEMO);\t\tbreak;\n\t\tcase 0x091: map_key_clear(KEY_CD);\t\tbreak;\n\t\tcase 0x092: map_key_clear(KEY_VCR);\t\tbreak;\n\t\tcase 0x093: map_key_clear(KEY_TUNER);\t\tbreak;\n\t\tcase 0x094: map_key_clear(KEY_EXIT);\t\tbreak;\n\t\tcase 0x095: map_key_clear(KEY_HELP);\t\tbreak;\n\t\tcase 0x096: map_key_clear(KEY_TAPE);\t\tbreak;\n\t\tcase 0x097: map_key_clear(KEY_TV2);\t\tbreak;\n\t\tcase 0x098: map_key_clear(KEY_SAT);\t\tbreak;\n\t\tcase 0x09a: map_key_clear(KEY_PVR);\t\tbreak;\n\n\t\tcase 0x09c: map_key_clear(KEY_CHANNELUP);\tbreak;\n\t\tcase 0x09d: map_key_clear(KEY_CHANNELDOWN);\tbreak;\n\t\tcase 0x0a0: map_key_clear(KEY_VCR2);\t\tbreak;\n\n\t\tcase 0x0b0: map_key_clear(KEY_PLAY);\t\tbreak;\n\t\tcase 0x0b1: map_key_clear(KEY_PAUSE);\t\tbreak;\n\t\tcase 0x0b2: map_key_clear(KEY_RECORD);\t\tbreak;\n\t\tcase 0x0b3: map_key_clear(KEY_FASTFORWARD);\tbreak;\n\t\tcase 0x0b4: map_key_clear(KEY_REWIND);\t\tbreak;\n\t\tcase 0x0b5: map_key_clear(KEY_NEXTSONG);\tbreak;\n\t\tcase 0x0b6: map_key_clear(KEY_PREVIOUSSONG);\tbreak;\n\t\tcase 0x0b7: map_key_clear(KEY_STOPCD);\t\tbreak;\n\t\tcase 0x0b8: map_key_clear(KEY_EJECTCD);\t\tbreak;\n\t\tcase 0x0bc: map_key_clear(KEY_MEDIA_REPEAT);\tbreak;\n\t\tcase 0x0b9: map_key_clear(KEY_SHUFFLE);\t\tbreak;\n\t\tcase 0x0bf: map_key_clear(KEY_SLOW);\t\tbreak;\n\n\t\tcase 0x0cd: map_key_clear(KEY_PLAYPAUSE);\tbreak;\n\t\tcase 0x0cf: map_key_clear(KEY_VOICECOMMAND);\tbreak;\n\t\tcase 0x0e0: map_abs_clear(ABS_VOLUME);\t\tbreak;\n\t\tcase 0x0e2: map_key_clear(KEY_MUTE);\t\tbreak;\n\t\tcase 0x0e5: map_key_clear(KEY_BASSBOOST);\tbreak;\n\t\tcase 0x0e9: map_key_clear(KEY_VOLUMEUP);\tbreak;\n\t\tcase 0x0ea: map_key_clear(KEY_VOLUMEDOWN);\tbreak;\n\t\tcase 0x0f5: map_key_clear(KEY_SLOW);\t\tbreak;\n\n\t\tcase 0x181: map_key_clear(KEY_BUTTONCONFIG);\tbreak;\n\t\tcase 0x182: map_key_clear(KEY_BOOKMARKS);\tbreak;\n\t\tcase 0x183: map_key_clear(KEY_CONFIG);\t\tbreak;\n\t\tcase 0x184: map_key_clear(KEY_WORDPROCESSOR);\tbreak;\n\t\tcase 0x185: map_key_clear(KEY_EDITOR);\t\tbreak;\n\t\tcase 0x186: map_key_clear(KEY_SPREADSHEET);\tbreak;\n\t\tcase 0x187: map_key_clear(KEY_GRAPHICSEDITOR);\tbreak;\n\t\tcase 0x188: map_key_clear(KEY_PRESENTATION);\tbreak;\n\t\tcase 0x189: map_key_clear(KEY_DATABASE);\tbreak;\n\t\tcase 0x18a: map_key_clear(KEY_MAIL);\t\tbreak;\n\t\tcase 0x18b: map_key_clear(KEY_NEWS);\t\tbreak;\n\t\tcase 0x18c: map_key_clear(KEY_VOICEMAIL);\tbreak;\n\t\tcase 0x18d: map_key_clear(KEY_ADDRESSBOOK);\tbreak;\n\t\tcase 0x18e: map_key_clear(KEY_CALENDAR);\tbreak;\n\t\tcase 0x18f: map_key_clear(KEY_TASKMANAGER);\tbreak;\n\t\tcase 0x190: map_key_clear(KEY_JOURNAL);\t\tbreak;\n\t\tcase 0x191: map_key_clear(KEY_FINANCE);\t\tbreak;\n\t\tcase 0x192: map_key_clear(KEY_CALC);\t\tbreak;\n\t\tcase 0x193: map_key_clear(KEY_PLAYER);\t\tbreak;\n\t\tcase 0x194: map_key_clear(KEY_FILE);\t\tbreak;\n\t\tcase 0x196: map_key_clear(KEY_WWW);\t\tbreak;\n\t\tcase 0x199: map_key_clear(KEY_CHAT);\t\tbreak;\n\t\tcase 0x19c: map_key_clear(KEY_LOGOFF);\t\tbreak;\n\t\tcase 0x19e: map_key_clear(KEY_COFFEE);\t\tbreak;\n\t\tcase 0x19f: map_key_clear(KEY_CONTROLPANEL);\t\tbreak;\n\t\tcase 0x1a2: map_key_clear(KEY_APPSELECT);\t\tbreak;\n\t\tcase 0x1a3: map_key_clear(KEY_NEXT);\t\tbreak;\n\t\tcase 0x1a4: map_key_clear(KEY_PREVIOUS);\tbreak;\n\t\tcase 0x1a6: map_key_clear(KEY_HELP);\t\tbreak;\n\t\tcase 0x1a7: map_key_clear(KEY_DOCUMENTS);\tbreak;\n\t\tcase 0x1ab: map_key_clear(KEY_SPELLCHECK);\tbreak;\n\t\tcase 0x1ae: map_key_clear(KEY_KEYBOARD);\tbreak;\n\t\tcase 0x1b1: map_key_clear(KEY_SCREENSAVER);\t\tbreak;\n\t\tcase 0x1b4: map_key_clear(KEY_FILE);\t\tbreak;\n\t\tcase 0x1b6: map_key_clear(KEY_IMAGES);\t\tbreak;\n\t\tcase 0x1b7: map_key_clear(KEY_AUDIO);\t\tbreak;\n\t\tcase 0x1b8: map_key_clear(KEY_VIDEO);\t\tbreak;\n\t\tcase 0x1bc: map_key_clear(KEY_MESSENGER);\tbreak;\n\t\tcase 0x1bd: map_key_clear(KEY_INFO);\t\tbreak;\n\t\tcase 0x1cb: map_key_clear(KEY_ASSISTANT);\tbreak;\n\t\tcase 0x201: map_key_clear(KEY_NEW);\t\tbreak;\n\t\tcase 0x202: map_key_clear(KEY_OPEN);\t\tbreak;\n\t\tcase 0x203: map_key_clear(KEY_CLOSE);\t\tbreak;\n\t\tcase 0x204: map_key_clear(KEY_EXIT);\t\tbreak;\n\t\tcase 0x207: map_key_clear(KEY_SAVE);\t\tbreak;\n\t\tcase 0x208: map_key_clear(KEY_PRINT);\t\tbreak;\n\t\tcase 0x209: map_key_clear(KEY_PROPS);\t\tbreak;\n\t\tcase 0x21a: map_key_clear(KEY_UNDO);\t\tbreak;\n\t\tcase 0x21b: map_key_clear(KEY_COPY);\t\tbreak;\n\t\tcase 0x21c: map_key_clear(KEY_CUT);\t\tbreak;\n\t\tcase 0x21d: map_key_clear(KEY_PASTE);\t\tbreak;\n\t\tcase 0x21f: map_key_clear(KEY_FIND);\t\tbreak;\n\t\tcase 0x221: map_key_clear(KEY_SEARCH);\t\tbreak;\n\t\tcase 0x222: map_key_clear(KEY_GOTO);\t\tbreak;\n\t\tcase 0x223: map_key_clear(KEY_HOMEPAGE);\tbreak;\n\t\tcase 0x224: map_key_clear(KEY_BACK);\t\tbreak;\n\t\tcase 0x225: map_key_clear(KEY_FORWARD);\t\tbreak;\n\t\tcase 0x226: map_key_clear(KEY_STOP);\t\tbreak;\n\t\tcase 0x227: map_key_clear(KEY_REFRESH);\t\tbreak;\n\t\tcase 0x22a: map_key_clear(KEY_BOOKMARKS);\tbreak;\n\t\tcase 0x22d: map_key_clear(KEY_ZOOMIN);\t\tbreak;\n\t\tcase 0x22e: map_key_clear(KEY_ZOOMOUT);\t\tbreak;\n\t\tcase 0x22f: map_key_clear(KEY_ZOOMRESET);\tbreak;\n\t\tcase 0x232: map_key_clear(KEY_FULL_SCREEN);\tbreak;\n\t\tcase 0x233: map_key_clear(KEY_SCROLLUP);\tbreak;\n\t\tcase 0x234: map_key_clear(KEY_SCROLLDOWN);\tbreak;\n\t\tcase 0x238: /* AC Pan */\n\t\t\tset_bit(REL_HWHEEL, input->relbit);\n\t\t\tmap_rel(REL_HWHEEL_HI_RES);\n\t\t\tbreak;\n\t\tcase 0x23d: map_key_clear(KEY_EDIT);\t\tbreak;\n\t\tcase 0x25f: map_key_clear(KEY_CANCEL);\t\tbreak;\n\t\tcase 0x269: map_key_clear(KEY_INSERT);\t\tbreak;\n\t\tcase 0x26a: map_key_clear(KEY_DELETE);\t\tbreak;\n\t\tcase 0x279: map_key_clear(KEY_REDO);\t\tbreak;\n\n\t\tcase 0x289: map_key_clear(KEY_REPLY);\t\tbreak;\n\t\tcase 0x28b: map_key_clear(KEY_FORWARDMAIL);\tbreak;\n\t\tcase 0x28c: map_key_clear(KEY_SEND);\t\tbreak;\n\n\t\tcase 0x29d: map_key_clear(KEY_KBD_LAYOUT_NEXT);\tbreak;\n\n\t\tcase 0x2c7: map_key_clear(KEY_KBDINPUTASSIST_PREV);\t\tbreak;\n\t\tcase 0x2c8: map_key_clear(KEY_KBDINPUTASSIST_NEXT);\t\tbreak;\n\t\tcase 0x2c9: map_key_clear(KEY_KBDINPUTASSIST_PREVGROUP);\t\tbreak;\n\t\tcase 0x2ca: map_key_clear(KEY_KBDINPUTASSIST_NEXTGROUP);\t\tbreak;\n\t\tcase 0x2cb: map_key_clear(KEY_KBDINPUTASSIST_ACCEPT);\tbreak;\n\t\tcase 0x2cc: map_key_clear(KEY_KBDINPUTASSIST_CANCEL);\tbreak;\n\n\t\tcase 0x29f: map_key_clear(KEY_SCALE);\t\tbreak;\n\n\t\tdefault: map_key_clear(KEY_UNKNOWN);\n\t\t}\n\t\tbreak;\n\n\tcase HID_UP_GENDEVCTRLS:\n\t\tswitch (usage->hid) {\n\t\tcase HID_DC_BATTERYSTRENGTH:\n\t\t\thidinput_setup_battery(device, HID_INPUT_REPORT, field);\n\t\t\tusage->type = EV_PWR;\n\t\t\tgoto ignore;\n\t\t}\n\t\tgoto unknown;\n\n\tcase HID_UP_HPVENDOR:\t/* Reported on a Dutch layout HP5308 */\n\t\tset_bit(EV_REP, input->evbit);\n\t\tswitch (usage->hid & HID_USAGE) {\n\t\tcase 0x021: map_key_clear(KEY_PRINT);           break;\n\t\tcase 0x070: map_key_clear(KEY_HP);\t\tbreak;\n\t\tcase 0x071: map_key_clear(KEY_CAMERA);\t\tbreak;\n\t\tcase 0x072: map_key_clear(KEY_SOUND);\t\tbreak;\n\t\tcase 0x073: map_key_clear(KEY_QUESTION);\tbreak;\n\t\tcase 0x080: map_key_clear(KEY_EMAIL);\t\tbreak;\n\t\tcase 0x081: map_key_clear(KEY_CHAT);\t\tbreak;\n\t\tcase 0x082: map_key_clear(KEY_SEARCH);\t\tbreak;\n\t\tcase 0x083: map_key_clear(KEY_CONNECT);\t        break;\n\t\tcase 0x084: map_key_clear(KEY_FINANCE);\t\tbreak;\n\t\tcase 0x085: map_key_clear(KEY_SPORT);\t\tbreak;\n\t\tcase 0x086: map_key_clear(KEY_SHOP);\t        break;\n\t\tdefault:    goto ignore;\n\t\t}\n\t\tbreak;\n\n\tcase HID_UP_HPVENDOR2:\n\t\tset_bit(EV_REP, input->evbit);\n\t\tswitch (usage->hid & HID_USAGE) {\n\t\tcase 0x001: map_key_clear(KEY_MICMUTE);\t\tbreak;\n\t\tcase 0x003: map_key_clear(KEY_BRIGHTNESSDOWN);\tbreak;\n\t\tcase 0x004: map_key_clear(KEY_BRIGHTNESSUP);\tbreak;\n\t\tdefault:    goto ignore;\n\t\t}\n\t\tbreak;\n\n\tcase HID_UP_MSVENDOR:\n\t\tgoto ignore;\n\n\tcase HID_UP_CUSTOM: /* Reported on Logitech and Apple USB keyboards */\n\t\tset_bit(EV_REP, input->evbit);\n\t\tgoto ignore;\n\n\tcase HID_UP_LOGIVENDOR:\n\t\t/* intentional fallback */\n\tcase HID_UP_LOGIVENDOR2:\n\t\t/* intentional fallback */\n\tcase HID_UP_LOGIVENDOR3:\n\t\tgoto ignore;\n\n\tcase HID_UP_PID:\n\t\tswitch (usage->hid & HID_USAGE) {\n\t\tcase 0xa4: map_key_clear(BTN_DEAD);\tbreak;\n\t\tdefault: goto ignore;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\tunknown:\n\t\tif (field->report_size == 1) {\n\t\t\tif (field->report->type == HID_OUTPUT_REPORT) {\n\t\t\t\tmap_led(LED_MISC);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmap_key(BTN_MISC);\n\t\t\tbreak;\n\t\t}\n\t\tif (field->flags & HID_MAIN_ITEM_RELATIVE) {\n\t\t\tmap_rel(REL_MISC);\n\t\t\tbreak;\n\t\t}\n\t\tmap_abs(ABS_MISC);\n\t\tbreak;\n\t}\n\nmapped:\n\t/* Mapping failed, bail out */\n\tif (!bit)\n\t\treturn;\n\n\tif (device->driver->input_mapped &&\n\t    device->driver->input_mapped(device, hidinput, field, usage,\n\t\t\t\t\t &bit, &max) < 0) {\n\t\t/*\n\t\t * The driver indicated that no further generic handling\n\t\t * of the usage is desired.\n\t\t */\n\t\treturn;\n\t}\n\n\tset_bit(usage->type, input->evbit);\n\n\t/*\n\t * This part is *really* controversial:\n\t * - HID aims at being generic so we should do our best to export\n\t *   all incoming events\n\t * - HID describes what events are, so there is no reason for ABS_X\n\t *   to be mapped to ABS_Y\n\t * - HID is using *_MISC+N as a default value, but nothing prevents\n\t *   *_MISC+N to overwrite a legitimate even, which confuses userspace\n\t *   (for instance ABS_MISC + 7 is ABS_MT_SLOT, which has a different\n\t *   processing)\n\t *\n\t * If devices still want to use this (at their own risk), they will\n\t * have to use the quirk HID_QUIRK_INCREMENT_USAGE_ON_DUPLICATE, but\n\t * the default should be a reliable mapping.\n\t */\n\twhile (usage->code <= max && test_and_set_bit(usage->code, bit)) {\n\t\tif (device->quirks & HID_QUIRK_INCREMENT_USAGE_ON_DUPLICATE) {\n\t\t\tusage->code = find_next_zero_bit(bit,\n\t\t\t\t\t\t\t max + 1,\n\t\t\t\t\t\t\t usage->code);\n\t\t} else {\n\t\t\tdevice->status |= HID_STAT_DUP_DETECTED;\n\t\t\tgoto ignore;\n\t\t}\n\t}\n\n\tif (usage->code > max)\n\t\tgoto ignore;\n\n\tif (usage->type == EV_ABS) {\n\n\t\tint a = field->logical_minimum;\n\t\tint b = field->logical_maximum;\n\n\t\tif ((device->quirks & HID_QUIRK_BADPAD) && (usage->code == ABS_X || usage->code == ABS_Y)) {\n\t\t\ta = field->logical_minimum = 0;\n\t\t\tb = field->logical_maximum = 255;\n\t\t}\n\n\t\tif (field->application == HID_GD_GAMEPAD || field->application == HID_GD_JOYSTICK)\n\t\t\tinput_set_abs_params(input, usage->code, a, b, (b - a) >> 8, (b - a) >> 4);\n\t\telse\tinput_set_abs_params(input, usage->code, a, b, 0, 0);\n\n\t\tinput_abs_set_res(input, usage->code,\n\t\t\t\t  hidinput_calc_abs_res(field, usage->code));\n\n\t\t/* use a larger default input buffer for MT devices */\n\t\tif (usage->code == ABS_MT_POSITION_X && input->hint_events_per_packet == 0)\n\t\t\tinput_set_events_per_packet(input, 60);\n\t}\n\n\tif (usage->type == EV_ABS &&\n\t    (usage->hat_min < usage->hat_max || usage->hat_dir)) {\n\t\tint i;\n\t\tfor (i = usage->code; i < usage->code + 2 && i <= max; i++) {\n\t\t\tinput_set_abs_params(input, i, -1, 1, 0, 0);\n\t\t\tset_bit(i, input->absbit);\n\t\t}\n\t\tif (usage->hat_dir && !field->dpad)\n\t\t\tfield->dpad = usage->code;\n\t}\n\n\t/* for those devices which produce Consumer volume usage as relative,\n\t * we emulate pressing volumeup/volumedown appropriate number of times\n\t * in hidinput_hid_event()\n\t */\n\tif ((usage->type == EV_ABS) && (field->flags & HID_MAIN_ITEM_RELATIVE) &&\n\t\t\t(usage->code == ABS_VOLUME)) {\n\t\tset_bit(KEY_VOLUMEUP, input->keybit);\n\t\tset_bit(KEY_VOLUMEDOWN, input->keybit);\n\t}\n\n\tif (usage->type == EV_KEY) {\n\t\tset_bit(EV_MSC, input->evbit);\n\t\tset_bit(MSC_SCAN, input->mscbit);\n\t}\n\n\treturn;\n\nignore:\n\tusage->type = 0;\n\tusage->code = 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -574,6 +574,10 @@\n \t}\n \n mapped:\n+\t/* Mapping failed, bail out */\n+\tif (!bit)\n+\t\treturn;\n+\n \tif (device->driver->input_mapped &&\n \t    device->driver->input_mapped(device, hidinput, field, usage,\n \t\t\t\t\t &bit, &max) < 0) {",
        "function_modified_lines": {
            "added": [
                "\t/* Mapping failed, bail out */",
                "\tif (!bit)",
                "\t\treturn;",
                ""
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "In various methods of hid-multitouch.c, there is a possible out of bounds write due to a missing bounds check. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-162844689References: Upstream kernel",
        "id": 2391
    },
    {
        "cve_id": "CVE-2019-9456",
        "code_before_change": "static ssize_t mon_text_read_u(struct file *file, char __user *buf,\n\t\t\t\tsize_t nbytes, loff_t *ppos)\n{\n\tstruct mon_reader_text *rp = file->private_data;\n\tstruct mon_event_text *ep;\n\tstruct mon_text_ptr ptr;\n\n\tep = mon_text_read_wait(rp, file);\n\tif (IS_ERR(ep))\n\t\treturn PTR_ERR(ep);\n\tmutex_lock(&rp->printf_lock);\n\tptr.cnt = 0;\n\tptr.pbuf = rp->printf_buf;\n\tptr.limit = rp->printf_size;\n\n\tmon_text_read_head_u(rp, &ptr, ep);\n\tif (ep->type == 'E') {\n\t\tmon_text_read_statset(rp, &ptr, ep);\n\t} else if (ep->xfertype == USB_ENDPOINT_XFER_ISOC) {\n\t\tmon_text_read_isostat(rp, &ptr, ep);\n\t\tmon_text_read_isodesc(rp, &ptr, ep);\n\t} else if (ep->xfertype == USB_ENDPOINT_XFER_INT) {\n\t\tmon_text_read_intstat(rp, &ptr, ep);\n\t} else {\n\t\tmon_text_read_statset(rp, &ptr, ep);\n\t}\n\tptr.cnt += snprintf(ptr.pbuf + ptr.cnt, ptr.limit - ptr.cnt,\n\t    \" %d\", ep->length);\n\tmon_text_read_data(rp, &ptr, ep);\n\n\tif (copy_to_user(buf, rp->printf_buf, ptr.cnt))\n\t\tptr.cnt = -EFAULT;\n\tmutex_unlock(&rp->printf_lock);\n\tkmem_cache_free(rp->e_slab, ep);\n\treturn ptr.cnt;\n}",
        "code_after_change": "static ssize_t mon_text_read_u(struct file *file, char __user *buf,\n    size_t nbytes, loff_t *ppos)\n{\n\tstruct mon_reader_text *rp = file->private_data;\n\tstruct mon_event_text *ep;\n\tstruct mon_text_ptr ptr;\n\tssize_t ret;\n\n\tmutex_lock(&rp->printf_lock);\n\n\tif (rp->printf_togo == 0) {\n\n\t\tep = mon_text_read_wait(rp, file);\n\t\tif (IS_ERR(ep)) {\n\t\t\tmutex_unlock(&rp->printf_lock);\n\t\t\treturn PTR_ERR(ep);\n\t\t}\n\t\tptr.cnt = 0;\n\t\tptr.pbuf = rp->printf_buf;\n\t\tptr.limit = rp->printf_size;\n\n\t\tmon_text_read_head_u(rp, &ptr, ep);\n\t\tif (ep->type == 'E') {\n\t\t\tmon_text_read_statset(rp, &ptr, ep);\n\t\t} else if (ep->xfertype == USB_ENDPOINT_XFER_ISOC) {\n\t\t\tmon_text_read_isostat(rp, &ptr, ep);\n\t\t\tmon_text_read_isodesc(rp, &ptr, ep);\n\t\t} else if (ep->xfertype == USB_ENDPOINT_XFER_INT) {\n\t\t\tmon_text_read_intstat(rp, &ptr, ep);\n\t\t} else {\n\t\t\tmon_text_read_statset(rp, &ptr, ep);\n\t\t}\n\t\tptr.cnt += snprintf(ptr.pbuf + ptr.cnt, ptr.limit - ptr.cnt,\n\t\t    \" %d\", ep->length);\n\t\tmon_text_read_data(rp, &ptr, ep);\n\n\t\trp->printf_togo = ptr.cnt;\n\t\trp->printf_offset = 0;\n\n\t\tkmem_cache_free(rp->e_slab, ep);\n\t}\n\n\tret = mon_text_copy_to_user(rp, buf, nbytes);\n\tmutex_unlock(&rp->printf_lock);\n\treturn ret;\n}",
        "patch": "--- code before\n+++ code after\n@@ -1,36 +1,46 @@\n static ssize_t mon_text_read_u(struct file *file, char __user *buf,\n-\t\t\t\tsize_t nbytes, loff_t *ppos)\n+    size_t nbytes, loff_t *ppos)\n {\n \tstruct mon_reader_text *rp = file->private_data;\n \tstruct mon_event_text *ep;\n \tstruct mon_text_ptr ptr;\n+\tssize_t ret;\n \n-\tep = mon_text_read_wait(rp, file);\n-\tif (IS_ERR(ep))\n-\t\treturn PTR_ERR(ep);\n \tmutex_lock(&rp->printf_lock);\n-\tptr.cnt = 0;\n-\tptr.pbuf = rp->printf_buf;\n-\tptr.limit = rp->printf_size;\n \n-\tmon_text_read_head_u(rp, &ptr, ep);\n-\tif (ep->type == 'E') {\n-\t\tmon_text_read_statset(rp, &ptr, ep);\n-\t} else if (ep->xfertype == USB_ENDPOINT_XFER_ISOC) {\n-\t\tmon_text_read_isostat(rp, &ptr, ep);\n-\t\tmon_text_read_isodesc(rp, &ptr, ep);\n-\t} else if (ep->xfertype == USB_ENDPOINT_XFER_INT) {\n-\t\tmon_text_read_intstat(rp, &ptr, ep);\n-\t} else {\n-\t\tmon_text_read_statset(rp, &ptr, ep);\n+\tif (rp->printf_togo == 0) {\n+\n+\t\tep = mon_text_read_wait(rp, file);\n+\t\tif (IS_ERR(ep)) {\n+\t\t\tmutex_unlock(&rp->printf_lock);\n+\t\t\treturn PTR_ERR(ep);\n+\t\t}\n+\t\tptr.cnt = 0;\n+\t\tptr.pbuf = rp->printf_buf;\n+\t\tptr.limit = rp->printf_size;\n+\n+\t\tmon_text_read_head_u(rp, &ptr, ep);\n+\t\tif (ep->type == 'E') {\n+\t\t\tmon_text_read_statset(rp, &ptr, ep);\n+\t\t} else if (ep->xfertype == USB_ENDPOINT_XFER_ISOC) {\n+\t\t\tmon_text_read_isostat(rp, &ptr, ep);\n+\t\t\tmon_text_read_isodesc(rp, &ptr, ep);\n+\t\t} else if (ep->xfertype == USB_ENDPOINT_XFER_INT) {\n+\t\t\tmon_text_read_intstat(rp, &ptr, ep);\n+\t\t} else {\n+\t\t\tmon_text_read_statset(rp, &ptr, ep);\n+\t\t}\n+\t\tptr.cnt += snprintf(ptr.pbuf + ptr.cnt, ptr.limit - ptr.cnt,\n+\t\t    \" %d\", ep->length);\n+\t\tmon_text_read_data(rp, &ptr, ep);\n+\n+\t\trp->printf_togo = ptr.cnt;\n+\t\trp->printf_offset = 0;\n+\n+\t\tkmem_cache_free(rp->e_slab, ep);\n \t}\n-\tptr.cnt += snprintf(ptr.pbuf + ptr.cnt, ptr.limit - ptr.cnt,\n-\t    \" %d\", ep->length);\n-\tmon_text_read_data(rp, &ptr, ep);\n \n-\tif (copy_to_user(buf, rp->printf_buf, ptr.cnt))\n-\t\tptr.cnt = -EFAULT;\n+\tret = mon_text_copy_to_user(rp, buf, nbytes);\n \tmutex_unlock(&rp->printf_lock);\n-\tkmem_cache_free(rp->e_slab, ep);\n-\treturn ptr.cnt;\n+\treturn ret;\n }",
        "function_modified_lines": {
            "added": [
                "    size_t nbytes, loff_t *ppos)",
                "\tssize_t ret;",
                "\tif (rp->printf_togo == 0) {",
                "",
                "\t\tep = mon_text_read_wait(rp, file);",
                "\t\tif (IS_ERR(ep)) {",
                "\t\t\tmutex_unlock(&rp->printf_lock);",
                "\t\t\treturn PTR_ERR(ep);",
                "\t\t}",
                "\t\tptr.cnt = 0;",
                "\t\tptr.pbuf = rp->printf_buf;",
                "\t\tptr.limit = rp->printf_size;",
                "",
                "\t\tmon_text_read_head_u(rp, &ptr, ep);",
                "\t\tif (ep->type == 'E') {",
                "\t\t\tmon_text_read_statset(rp, &ptr, ep);",
                "\t\t} else if (ep->xfertype == USB_ENDPOINT_XFER_ISOC) {",
                "\t\t\tmon_text_read_isostat(rp, &ptr, ep);",
                "\t\t\tmon_text_read_isodesc(rp, &ptr, ep);",
                "\t\t} else if (ep->xfertype == USB_ENDPOINT_XFER_INT) {",
                "\t\t\tmon_text_read_intstat(rp, &ptr, ep);",
                "\t\t} else {",
                "\t\t\tmon_text_read_statset(rp, &ptr, ep);",
                "\t\t}",
                "\t\tptr.cnt += snprintf(ptr.pbuf + ptr.cnt, ptr.limit - ptr.cnt,",
                "\t\t    \" %d\", ep->length);",
                "\t\tmon_text_read_data(rp, &ptr, ep);",
                "",
                "\t\trp->printf_togo = ptr.cnt;",
                "\t\trp->printf_offset = 0;",
                "",
                "\t\tkmem_cache_free(rp->e_slab, ep);",
                "\tret = mon_text_copy_to_user(rp, buf, nbytes);",
                "\treturn ret;"
            ],
            "deleted": [
                "\t\t\t\tsize_t nbytes, loff_t *ppos)",
                "\tep = mon_text_read_wait(rp, file);",
                "\tif (IS_ERR(ep))",
                "\t\treturn PTR_ERR(ep);",
                "\tptr.cnt = 0;",
                "\tptr.pbuf = rp->printf_buf;",
                "\tptr.limit = rp->printf_size;",
                "\tmon_text_read_head_u(rp, &ptr, ep);",
                "\tif (ep->type == 'E') {",
                "\t\tmon_text_read_statset(rp, &ptr, ep);",
                "\t} else if (ep->xfertype == USB_ENDPOINT_XFER_ISOC) {",
                "\t\tmon_text_read_isostat(rp, &ptr, ep);",
                "\t\tmon_text_read_isodesc(rp, &ptr, ep);",
                "\t} else if (ep->xfertype == USB_ENDPOINT_XFER_INT) {",
                "\t\tmon_text_read_intstat(rp, &ptr, ep);",
                "\t} else {",
                "\t\tmon_text_read_statset(rp, &ptr, ep);",
                "\tptr.cnt += snprintf(ptr.pbuf + ptr.cnt, ptr.limit - ptr.cnt,",
                "\t    \" %d\", ep->length);",
                "\tmon_text_read_data(rp, &ptr, ep);",
                "\tif (copy_to_user(buf, rp->printf_buf, ptr.cnt))",
                "\t\tptr.cnt = -EFAULT;",
                "\tkmem_cache_free(rp->e_slab, ep);",
                "\treturn ptr.cnt;"
            ]
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "In the Android kernel in Pixel C USB monitor driver there is a possible OOB write due to a missing bounds check. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation.",
        "id": 2360
    },
    {
        "cve_id": "CVE-2022-4378",
        "code_before_change": "static int __do_proc_doulongvec_minmax(void *data, struct ctl_table *table,\n\t\tint write, void *buffer, size_t *lenp, loff_t *ppos,\n\t\tunsigned long convmul, unsigned long convdiv)\n{\n\tunsigned long *i, *min, *max;\n\tint vleft, first = 1, err = 0;\n\tsize_t left;\n\tchar *p;\n\n\tif (!data || !table->maxlen || !*lenp || (*ppos && !write)) {\n\t\t*lenp = 0;\n\t\treturn 0;\n\t}\n\n\ti = data;\n\tmin = table->extra1;\n\tmax = table->extra2;\n\tvleft = table->maxlen / sizeof(unsigned long);\n\tleft = *lenp;\n\n\tif (write) {\n\t\tif (proc_first_pos_non_zero_ignore(ppos, table))\n\t\t\tgoto out;\n\n\t\tif (left > PAGE_SIZE - 1)\n\t\t\tleft = PAGE_SIZE - 1;\n\t\tp = buffer;\n\t}\n\n\tfor (; left && vleft--; i++, first = 0) {\n\t\tunsigned long val;\n\n\t\tif (write) {\n\t\t\tbool neg;\n\n\t\t\tleft -= proc_skip_spaces(&p);\n\t\t\tif (!left)\n\t\t\t\tbreak;\n\n\t\t\terr = proc_get_long(&p, &left, &val, &neg,\n\t\t\t\t\t     proc_wspace_sep,\n\t\t\t\t\t     sizeof(proc_wspace_sep), NULL);\n\t\t\tif (err || neg) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tval = convmul * val / convdiv;\n\t\t\tif ((min && val < *min) || (max && val > *max)) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tWRITE_ONCE(*i, val);\n\t\t} else {\n\t\t\tval = convdiv * READ_ONCE(*i) / convmul;\n\t\t\tif (!first)\n\t\t\t\tproc_put_char(&buffer, &left, '\\t');\n\t\t\tproc_put_long(&buffer, &left, val, false);\n\t\t}\n\t}\n\n\tif (!write && !first && left && !err)\n\t\tproc_put_char(&buffer, &left, '\\n');\n\tif (write && !err)\n\t\tleft -= proc_skip_spaces(&p);\n\tif (write && first)\n\t\treturn err ? : -EINVAL;\n\t*lenp -= left;\nout:\n\t*ppos += *lenp;\n\treturn err;\n}",
        "code_after_change": "static int __do_proc_doulongvec_minmax(void *data, struct ctl_table *table,\n\t\tint write, void *buffer, size_t *lenp, loff_t *ppos,\n\t\tunsigned long convmul, unsigned long convdiv)\n{\n\tunsigned long *i, *min, *max;\n\tint vleft, first = 1, err = 0;\n\tsize_t left;\n\tchar *p;\n\n\tif (!data || !table->maxlen || !*lenp || (*ppos && !write)) {\n\t\t*lenp = 0;\n\t\treturn 0;\n\t}\n\n\ti = data;\n\tmin = table->extra1;\n\tmax = table->extra2;\n\tvleft = table->maxlen / sizeof(unsigned long);\n\tleft = *lenp;\n\n\tif (write) {\n\t\tif (proc_first_pos_non_zero_ignore(ppos, table))\n\t\t\tgoto out;\n\n\t\tif (left > PAGE_SIZE - 1)\n\t\t\tleft = PAGE_SIZE - 1;\n\t\tp = buffer;\n\t}\n\n\tfor (; left && vleft--; i++, first = 0) {\n\t\tunsigned long val;\n\n\t\tif (write) {\n\t\t\tbool neg;\n\n\t\t\tproc_skip_spaces(&p, &left);\n\t\t\tif (!left)\n\t\t\t\tbreak;\n\n\t\t\terr = proc_get_long(&p, &left, &val, &neg,\n\t\t\t\t\t     proc_wspace_sep,\n\t\t\t\t\t     sizeof(proc_wspace_sep), NULL);\n\t\t\tif (err || neg) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tval = convmul * val / convdiv;\n\t\t\tif ((min && val < *min) || (max && val > *max)) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tWRITE_ONCE(*i, val);\n\t\t} else {\n\t\t\tval = convdiv * READ_ONCE(*i) / convmul;\n\t\t\tif (!first)\n\t\t\t\tproc_put_char(&buffer, &left, '\\t');\n\t\t\tproc_put_long(&buffer, &left, val, false);\n\t\t}\n\t}\n\n\tif (!write && !first && left && !err)\n\t\tproc_put_char(&buffer, &left, '\\n');\n\tif (write && !err)\n\t\tproc_skip_spaces(&p, &left);\n\tif (write && first)\n\t\treturn err ? : -EINVAL;\n\t*lenp -= left;\nout:\n\t*ppos += *lenp;\n\treturn err;\n}",
        "patch": "--- code before\n+++ code after\n@@ -33,7 +33,7 @@\n \t\tif (write) {\n \t\t\tbool neg;\n \n-\t\t\tleft -= proc_skip_spaces(&p);\n+\t\t\tproc_skip_spaces(&p, &left);\n \t\t\tif (!left)\n \t\t\t\tbreak;\n \n@@ -62,7 +62,7 @@\n \tif (!write && !first && left && !err)\n \t\tproc_put_char(&buffer, &left, '\\n');\n \tif (write && !err)\n-\t\tleft -= proc_skip_spaces(&p);\n+\t\tproc_skip_spaces(&p, &left);\n \tif (write && first)\n \t\treturn err ? : -EINVAL;\n \t*lenp -= left;",
        "function_modified_lines": {
            "added": [
                "\t\t\tproc_skip_spaces(&p, &left);",
                "\t\tproc_skip_spaces(&p, &left);"
            ],
            "deleted": [
                "\t\t\tleft -= proc_skip_spaces(&p);",
                "\t\tleft -= proc_skip_spaces(&p);"
            ]
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "A stack overflow flaw was found in the Linux kernel's SYSCTL subsystem in how a user changes certain kernel parameters and variables. This flaw allows a local user to crash or potentially escalate their privileges on the system.",
        "id": 3742
    },
    {
        "cve_id": "CVE-2021-33656",
        "code_before_change": "static int vt_io_ioctl(struct vc_data *vc, unsigned int cmd, void __user *up,\n\t\tbool perm)\n{\n\tstruct console_font_op op;\t/* used in multiple places here */\n\n\tswitch (cmd) {\n\tcase PIO_FONT:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\top.op = KD_FONT_OP_SET;\n\t\top.flags = KD_FONT_FLAG_OLD | KD_FONT_FLAG_DONT_RECALC;\t/* Compatibility */\n\t\top.width = 8;\n\t\top.height = 0;\n\t\top.charcount = 256;\n\t\top.data = up;\n\t\treturn con_font_op(vc, &op);\n\n\tcase GIO_FONT:\n\t\top.op = KD_FONT_OP_GET;\n\t\top.flags = KD_FONT_FLAG_OLD;\n\t\top.width = 8;\n\t\top.height = 32;\n\t\top.charcount = 256;\n\t\top.data = up;\n\t\treturn con_font_op(vc, &op);\n\n\tcase PIO_CMAP:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\treturn con_set_cmap(up);\n\n\tcase GIO_CMAP:\n\t\treturn con_get_cmap(up);\n\n\tcase PIO_FONTX:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\n\t\tfallthrough;\n\tcase GIO_FONTX:\n\t\treturn do_fontx_ioctl(vc, cmd, up, &op);\n\n\tcase PIO_FONTRESET:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\n\t\treturn vt_io_fontreset(vc, &op);\n\n\tcase PIO_SCRNMAP:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\treturn con_set_trans_old(up);\n\n\tcase GIO_SCRNMAP:\n\t\treturn con_get_trans_old(up);\n\n\tcase PIO_UNISCRNMAP:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\treturn con_set_trans_new(up);\n\n\tcase GIO_UNISCRNMAP:\n\t\treturn con_get_trans_new(up);\n\n\tcase PIO_UNIMAPCLR:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\tcon_clear_unimap(vc);\n\t\tbreak;\n\n\tcase PIO_UNIMAP:\n\tcase GIO_UNIMAP:\n\t\treturn do_unimap_ioctl(cmd, up, perm, vc);\n\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\n\treturn 0;\n}",
        "code_after_change": "static int vt_io_ioctl(struct vc_data *vc, unsigned int cmd, void __user *up,\n\t\tbool perm)\n{\n\tswitch (cmd) {\n\tcase PIO_CMAP:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\treturn con_set_cmap(up);\n\n\tcase GIO_CMAP:\n\t\treturn con_get_cmap(up);\n\n\tcase PIO_SCRNMAP:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\treturn con_set_trans_old(up);\n\n\tcase GIO_SCRNMAP:\n\t\treturn con_get_trans_old(up);\n\n\tcase PIO_UNISCRNMAP:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\treturn con_set_trans_new(up);\n\n\tcase GIO_UNISCRNMAP:\n\t\treturn con_get_trans_new(up);\n\n\tcase PIO_UNIMAPCLR:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\tcon_clear_unimap(vc);\n\t\tbreak;\n\n\tcase PIO_UNIMAP:\n\tcase GIO_UNIMAP:\n\t\treturn do_unimap_ioctl(cmd, up, perm, vc);\n\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\n\treturn 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -1,29 +1,7 @@\n static int vt_io_ioctl(struct vc_data *vc, unsigned int cmd, void __user *up,\n \t\tbool perm)\n {\n-\tstruct console_font_op op;\t/* used in multiple places here */\n-\n \tswitch (cmd) {\n-\tcase PIO_FONT:\n-\t\tif (!perm)\n-\t\t\treturn -EPERM;\n-\t\top.op = KD_FONT_OP_SET;\n-\t\top.flags = KD_FONT_FLAG_OLD | KD_FONT_FLAG_DONT_RECALC;\t/* Compatibility */\n-\t\top.width = 8;\n-\t\top.height = 0;\n-\t\top.charcount = 256;\n-\t\top.data = up;\n-\t\treturn con_font_op(vc, &op);\n-\n-\tcase GIO_FONT:\n-\t\top.op = KD_FONT_OP_GET;\n-\t\top.flags = KD_FONT_FLAG_OLD;\n-\t\top.width = 8;\n-\t\top.height = 32;\n-\t\top.charcount = 256;\n-\t\top.data = up;\n-\t\treturn con_font_op(vc, &op);\n-\n \tcase PIO_CMAP:\n \t\tif (!perm)\n \t\t\treturn -EPERM;\n@@ -31,20 +9,6 @@\n \n \tcase GIO_CMAP:\n \t\treturn con_get_cmap(up);\n-\n-\tcase PIO_FONTX:\n-\t\tif (!perm)\n-\t\t\treturn -EPERM;\n-\n-\t\tfallthrough;\n-\tcase GIO_FONTX:\n-\t\treturn do_fontx_ioctl(vc, cmd, up, &op);\n-\n-\tcase PIO_FONTRESET:\n-\t\tif (!perm)\n-\t\t\treturn -EPERM;\n-\n-\t\treturn vt_io_fontreset(vc, &op);\n \n \tcase PIO_SCRNMAP:\n \t\tif (!perm)",
        "function_modified_lines": {
            "added": [],
            "deleted": [
                "\tstruct console_font_op op;\t/* used in multiple places here */",
                "",
                "\tcase PIO_FONT:",
                "\t\tif (!perm)",
                "\t\t\treturn -EPERM;",
                "\t\top.op = KD_FONT_OP_SET;",
                "\t\top.flags = KD_FONT_FLAG_OLD | KD_FONT_FLAG_DONT_RECALC;\t/* Compatibility */",
                "\t\top.width = 8;",
                "\t\top.height = 0;",
                "\t\top.charcount = 256;",
                "\t\top.data = up;",
                "\t\treturn con_font_op(vc, &op);",
                "",
                "\tcase GIO_FONT:",
                "\t\top.op = KD_FONT_OP_GET;",
                "\t\top.flags = KD_FONT_FLAG_OLD;",
                "\t\top.width = 8;",
                "\t\top.height = 32;",
                "\t\top.charcount = 256;",
                "\t\top.data = up;",
                "\t\treturn con_font_op(vc, &op);",
                "",
                "",
                "\tcase PIO_FONTX:",
                "\t\tif (!perm)",
                "\t\t\treturn -EPERM;",
                "",
                "\t\tfallthrough;",
                "\tcase GIO_FONTX:",
                "\t\treturn do_fontx_ioctl(vc, cmd, up, &op);",
                "",
                "\tcase PIO_FONTRESET:",
                "\t\tif (!perm)",
                "\t\t\treturn -EPERM;",
                "",
                "\t\treturn vt_io_fontreset(vc, &op);"
            ]
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "When setting font with malicous data by ioctl cmd PIO_FONT,kernel will write memory out of bounds.",
        "id": 2985
    },
    {
        "cve_id": "CVE-2020-14390",
        "code_before_change": "static int fbcon_do_set_font(struct vc_data *vc, int w, int h,\n\t\t\t     const u8 * data, int userfont)\n{\n\tstruct fb_info *info = registered_fb[con2fb_map[vc->vc_num]];\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\tstruct fbcon_display *p = &fb_display[vc->vc_num];\n\tint resize;\n\tint cnt;\n\tchar *old_data = NULL;\n\n\tif (con_is_visible(vc) && softback_lines)\n\t\tfbcon_set_origin(vc);\n\n\tresize = (w != vc->vc_font.width) || (h != vc->vc_font.height);\n\tif (p->userfont)\n\t\told_data = vc->vc_font.data;\n\tif (userfont)\n\t\tcnt = FNTCHARCNT(data);\n\telse\n\t\tcnt = 256;\n\tvc->vc_font.data = (void *)(p->fontdata = data);\n\tif ((p->userfont = userfont))\n\t\tREFCOUNT(data)++;\n\tvc->vc_font.width = w;\n\tvc->vc_font.height = h;\n\tif (vc->vc_hi_font_mask && cnt == 256)\n\t\tset_vc_hi_font(vc, false);\n\telse if (!vc->vc_hi_font_mask && cnt == 512)\n\t\tset_vc_hi_font(vc, true);\n\n\tif (resize) {\n\t\tint cols, rows;\n\n\t\tcols = FBCON_SWAP(ops->rotate, info->var.xres, info->var.yres);\n\t\trows = FBCON_SWAP(ops->rotate, info->var.yres, info->var.xres);\n\t\tcols /= w;\n\t\trows /= h;\n\t\tvc_resize(vc, cols, rows);\n\t\tif (con_is_visible(vc) && softback_buf)\n\t\t\tfbcon_update_softback(vc);\n\t} else if (con_is_visible(vc)\n\t\t   && vc->vc_mode == KD_TEXT) {\n\t\tfbcon_clear_margins(vc, 0);\n\t\tupdate_screen(vc);\n\t}\n\n\tif (old_data && (--REFCOUNT(old_data) == 0))\n\t\tkfree(old_data - FONT_EXTRA_WORDS * sizeof(int));\n\treturn 0;\n}",
        "code_after_change": "static int fbcon_do_set_font(struct vc_data *vc, int w, int h,\n\t\t\t     const u8 * data, int userfont)\n{\n\tstruct fb_info *info = registered_fb[con2fb_map[vc->vc_num]];\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\tstruct fbcon_display *p = &fb_display[vc->vc_num];\n\tint resize;\n\tint cnt;\n\tchar *old_data = NULL;\n\n\tresize = (w != vc->vc_font.width) || (h != vc->vc_font.height);\n\tif (p->userfont)\n\t\told_data = vc->vc_font.data;\n\tif (userfont)\n\t\tcnt = FNTCHARCNT(data);\n\telse\n\t\tcnt = 256;\n\tvc->vc_font.data = (void *)(p->fontdata = data);\n\tif ((p->userfont = userfont))\n\t\tREFCOUNT(data)++;\n\tvc->vc_font.width = w;\n\tvc->vc_font.height = h;\n\tif (vc->vc_hi_font_mask && cnt == 256)\n\t\tset_vc_hi_font(vc, false);\n\telse if (!vc->vc_hi_font_mask && cnt == 512)\n\t\tset_vc_hi_font(vc, true);\n\n\tif (resize) {\n\t\tint cols, rows;\n\n\t\tcols = FBCON_SWAP(ops->rotate, info->var.xres, info->var.yres);\n\t\trows = FBCON_SWAP(ops->rotate, info->var.yres, info->var.xres);\n\t\tcols /= w;\n\t\trows /= h;\n\t\tvc_resize(vc, cols, rows);\n\t} else if (con_is_visible(vc)\n\t\t   && vc->vc_mode == KD_TEXT) {\n\t\tfbcon_clear_margins(vc, 0);\n\t\tupdate_screen(vc);\n\t}\n\n\tif (old_data && (--REFCOUNT(old_data) == 0))\n\t\tkfree(old_data - FONT_EXTRA_WORDS * sizeof(int));\n\treturn 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -7,9 +7,6 @@\n \tint resize;\n \tint cnt;\n \tchar *old_data = NULL;\n-\n-\tif (con_is_visible(vc) && softback_lines)\n-\t\tfbcon_set_origin(vc);\n \n \tresize = (w != vc->vc_font.width) || (h != vc->vc_font.height);\n \tif (p->userfont)\n@@ -36,8 +33,6 @@\n \t\tcols /= w;\n \t\trows /= h;\n \t\tvc_resize(vc, cols, rows);\n-\t\tif (con_is_visible(vc) && softback_buf)\n-\t\t\tfbcon_update_softback(vc);\n \t} else if (con_is_visible(vc)\n \t\t   && vc->vc_mode == KD_TEXT) {\n \t\tfbcon_clear_margins(vc, 0);",
        "function_modified_lines": {
            "added": [],
            "deleted": [
                "",
                "\tif (con_is_visible(vc) && softback_lines)",
                "\t\tfbcon_set_origin(vc);",
                "\t\tif (con_is_visible(vc) && softback_buf)",
                "\t\t\tfbcon_update_softback(vc);"
            ]
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "A flaw was found in the Linux kernel in versions before 5.9-rc6. When changing screen size, an out-of-bounds memory write can occur leading to memory corruption or a denial of service. Due to the nature of the flaw, privilege escalation cannot be fully ruled out.",
        "id": 2533
    },
    {
        "cve_id": "CVE-2020-14390",
        "code_before_change": "static void fbcon_set_disp(struct fb_info *info, struct fb_var_screeninfo *var,\n\t\t\t   int unit)\n{\n\tstruct fbcon_display *p, *t;\n\tstruct vc_data **default_mode, *vc;\n\tstruct vc_data *svc;\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\tint rows, cols, charcnt = 256;\n\n\tp = &fb_display[unit];\n\n\tif (var_to_display(p, var, info))\n\t\treturn;\n\n\tvc = vc_cons[unit].d;\n\n\tif (!vc)\n\t\treturn;\n\n\tdefault_mode = vc->vc_display_fg;\n\tsvc = *default_mode;\n\tt = &fb_display[svc->vc_num];\n\n\tif (!vc->vc_font.data) {\n\t\tvc->vc_font.data = (void *)(p->fontdata = t->fontdata);\n\t\tvc->vc_font.width = (*default_mode)->vc_font.width;\n\t\tvc->vc_font.height = (*default_mode)->vc_font.height;\n\t\tp->userfont = t->userfont;\n\t\tif (p->userfont)\n\t\t\tREFCOUNT(p->fontdata)++;\n\t}\n\tif (p->userfont)\n\t\tcharcnt = FNTCHARCNT(p->fontdata);\n\n\tvar->activate = FB_ACTIVATE_NOW;\n\tinfo->var.activate = var->activate;\n\tvar->yoffset = info->var.yoffset;\n\tvar->xoffset = info->var.xoffset;\n\tfb_set_var(info, var);\n\tops->var = info->var;\n\tvc->vc_can_do_color = (fb_get_color_depth(&info->var, &info->fix)!=1);\n\tvc->vc_complement_mask = vc->vc_can_do_color ? 0x7700 : 0x0800;\n\tif (charcnt == 256) {\n\t\tvc->vc_hi_font_mask = 0;\n\t} else {\n\t\tvc->vc_hi_font_mask = 0x100;\n\t\tif (vc->vc_can_do_color)\n\t\t\tvc->vc_complement_mask <<= 1;\n\t}\n\n\tif (!*svc->vc_uni_pagedir_loc)\n\t\tcon_set_default_unimap(svc);\n\tif (!*vc->vc_uni_pagedir_loc)\n\t\tcon_copy_unimap(vc, svc);\n\n\tcols = FBCON_SWAP(ops->rotate, info->var.xres, info->var.yres);\n\trows = FBCON_SWAP(ops->rotate, info->var.yres, info->var.xres);\n\tcols /= vc->vc_font.width;\n\trows /= vc->vc_font.height;\n\tvc_resize(vc, cols, rows);\n\n\tif (con_is_visible(vc)) {\n\t\tupdate_screen(vc);\n\t\tif (softback_buf)\n\t\t\tfbcon_update_softback(vc);\n\t}\n}",
        "code_after_change": "static void fbcon_set_disp(struct fb_info *info, struct fb_var_screeninfo *var,\n\t\t\t   int unit)\n{\n\tstruct fbcon_display *p, *t;\n\tstruct vc_data **default_mode, *vc;\n\tstruct vc_data *svc;\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\tint rows, cols, charcnt = 256;\n\n\tp = &fb_display[unit];\n\n\tif (var_to_display(p, var, info))\n\t\treturn;\n\n\tvc = vc_cons[unit].d;\n\n\tif (!vc)\n\t\treturn;\n\n\tdefault_mode = vc->vc_display_fg;\n\tsvc = *default_mode;\n\tt = &fb_display[svc->vc_num];\n\n\tif (!vc->vc_font.data) {\n\t\tvc->vc_font.data = (void *)(p->fontdata = t->fontdata);\n\t\tvc->vc_font.width = (*default_mode)->vc_font.width;\n\t\tvc->vc_font.height = (*default_mode)->vc_font.height;\n\t\tp->userfont = t->userfont;\n\t\tif (p->userfont)\n\t\t\tREFCOUNT(p->fontdata)++;\n\t}\n\tif (p->userfont)\n\t\tcharcnt = FNTCHARCNT(p->fontdata);\n\n\tvar->activate = FB_ACTIVATE_NOW;\n\tinfo->var.activate = var->activate;\n\tvar->yoffset = info->var.yoffset;\n\tvar->xoffset = info->var.xoffset;\n\tfb_set_var(info, var);\n\tops->var = info->var;\n\tvc->vc_can_do_color = (fb_get_color_depth(&info->var, &info->fix)!=1);\n\tvc->vc_complement_mask = vc->vc_can_do_color ? 0x7700 : 0x0800;\n\tif (charcnt == 256) {\n\t\tvc->vc_hi_font_mask = 0;\n\t} else {\n\t\tvc->vc_hi_font_mask = 0x100;\n\t\tif (vc->vc_can_do_color)\n\t\t\tvc->vc_complement_mask <<= 1;\n\t}\n\n\tif (!*svc->vc_uni_pagedir_loc)\n\t\tcon_set_default_unimap(svc);\n\tif (!*vc->vc_uni_pagedir_loc)\n\t\tcon_copy_unimap(vc, svc);\n\n\tcols = FBCON_SWAP(ops->rotate, info->var.xres, info->var.yres);\n\trows = FBCON_SWAP(ops->rotate, info->var.yres, info->var.xres);\n\tcols /= vc->vc_font.width;\n\trows /= vc->vc_font.height;\n\tvc_resize(vc, cols, rows);\n\n\tif (con_is_visible(vc)) {\n\t\tupdate_screen(vc);\n\t}\n}",
        "patch": "--- code before\n+++ code after\n@@ -61,7 +61,5 @@\n \n \tif (con_is_visible(vc)) {\n \t\tupdate_screen(vc);\n-\t\tif (softback_buf)\n-\t\t\tfbcon_update_softback(vc);\n \t}\n }",
        "function_modified_lines": {
            "added": [],
            "deleted": [
                "\t\tif (softback_buf)",
                "\t\t\tfbcon_update_softback(vc);"
            ]
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "A flaw was found in the Linux kernel in versions before 5.9-rc6. When changing screen size, an out-of-bounds memory write can occur leading to memory corruption or a denial of service. Due to the nature of the flaw, privilege escalation cannot be fully ruled out.",
        "id": 2530
    },
    {
        "cve_id": "CVE-2020-14390",
        "code_before_change": "static void fbcon_invert_region(struct vc_data *vc, u16 * p, int cnt)\n{\n\twhile (cnt--) {\n\t\tu16 a = scr_readw(p);\n\t\tif (!vc->vc_can_do_color)\n\t\t\ta ^= 0x0800;\n\t\telse if (vc->vc_hi_font_mask == 0x100)\n\t\t\ta = ((a) & 0x11ff) | (((a) & 0xe000) >> 4) |\n\t\t\t    (((a) & 0x0e00) << 4);\n\t\telse\n\t\t\ta = ((a) & 0x88ff) | (((a) & 0x7000) >> 4) |\n\t\t\t    (((a) & 0x0700) << 4);\n\t\tscr_writew(a, p++);\n\t\tif (p == (u16 *) softback_end)\n\t\t\tp = (u16 *) softback_buf;\n\t\tif (p == (u16 *) softback_in)\n\t\t\tp = (u16 *) vc->vc_origin;\n\t}\n}",
        "code_after_change": "static void fbcon_invert_region(struct vc_data *vc, u16 * p, int cnt)\n{\n\twhile (cnt--) {\n\t\tu16 a = scr_readw(p);\n\t\tif (!vc->vc_can_do_color)\n\t\t\ta ^= 0x0800;\n\t\telse if (vc->vc_hi_font_mask == 0x100)\n\t\t\ta = ((a) & 0x11ff) | (((a) & 0xe000) >> 4) |\n\t\t\t    (((a) & 0x0e00) << 4);\n\t\telse\n\t\t\ta = ((a) & 0x88ff) | (((a) & 0x7000) >> 4) |\n\t\t\t    (((a) & 0x0700) << 4);\n\t\tscr_writew(a, p++);\n\t}\n}",
        "patch": "--- code before\n+++ code after\n@@ -11,9 +11,5 @@\n \t\t\ta = ((a) & 0x88ff) | (((a) & 0x7000) >> 4) |\n \t\t\t    (((a) & 0x0700) << 4);\n \t\tscr_writew(a, p++);\n-\t\tif (p == (u16 *) softback_end)\n-\t\t\tp = (u16 *) softback_buf;\n-\t\tif (p == (u16 *) softback_in)\n-\t\t\tp = (u16 *) vc->vc_origin;\n \t}\n }",
        "function_modified_lines": {
            "added": [],
            "deleted": [
                "\t\tif (p == (u16 *) softback_end)",
                "\t\t\tp = (u16 *) softback_buf;",
                "\t\tif (p == (u16 *) softback_in)",
                "\t\t\tp = (u16 *) vc->vc_origin;"
            ]
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "A flaw was found in the Linux kernel in versions before 5.9-rc6. When changing screen size, an out-of-bounds memory write can occur leading to memory corruption or a denial of service. Due to the nature of the flaw, privilege escalation cannot be fully ruled out.",
        "id": 2527
    },
    {
        "cve_id": "CVE-2022-47942",
        "code_before_change": "int smb_inherit_dacl(struct ksmbd_conn *conn,\n\t\t     struct path *path,\n\t\t     unsigned int uid, unsigned int gid)\n{\n\tconst struct smb_sid *psid, *creator = NULL;\n\tstruct smb_ace *parent_aces, *aces;\n\tstruct smb_acl *parent_pdacl;\n\tstruct smb_ntsd *parent_pntsd = NULL;\n\tstruct smb_sid owner_sid, group_sid;\n\tstruct dentry *parent = path->dentry->d_parent;\n\tstruct user_namespace *user_ns = mnt_user_ns(path->mnt);\n\tint inherited_flags = 0, flags = 0, i, ace_cnt = 0, nt_size = 0;\n\tint rc = 0, num_aces, dacloffset, pntsd_type, acl_len;\n\tchar *aces_base;\n\tbool is_dir = S_ISDIR(d_inode(path->dentry)->i_mode);\n\n\tacl_len = ksmbd_vfs_get_sd_xattr(conn, user_ns,\n\t\t\t\t\t parent, &parent_pntsd);\n\tif (acl_len <= 0)\n\t\treturn -ENOENT;\n\tdacloffset = le32_to_cpu(parent_pntsd->dacloffset);\n\tif (!dacloffset) {\n\t\trc = -EINVAL;\n\t\tgoto free_parent_pntsd;\n\t}\n\n\tparent_pdacl = (struct smb_acl *)((char *)parent_pntsd + dacloffset);\n\tnum_aces = le32_to_cpu(parent_pdacl->num_aces);\n\tpntsd_type = le16_to_cpu(parent_pntsd->type);\n\n\taces_base = kmalloc(sizeof(struct smb_ace) * num_aces * 2, GFP_KERNEL);\n\tif (!aces_base) {\n\t\trc = -ENOMEM;\n\t\tgoto free_parent_pntsd;\n\t}\n\n\taces = (struct smb_ace *)aces_base;\n\tparent_aces = (struct smb_ace *)((char *)parent_pdacl +\n\t\t\tsizeof(struct smb_acl));\n\n\tif (pntsd_type & DACL_AUTO_INHERITED)\n\t\tinherited_flags = INHERITED_ACE;\n\n\tfor (i = 0; i < num_aces; i++) {\n\t\tflags = parent_aces->flags;\n\t\tif (!smb_inherit_flags(flags, is_dir))\n\t\t\tgoto pass;\n\t\tif (is_dir) {\n\t\t\tflags &= ~(INHERIT_ONLY_ACE | INHERITED_ACE);\n\t\t\tif (!(flags & CONTAINER_INHERIT_ACE))\n\t\t\t\tflags |= INHERIT_ONLY_ACE;\n\t\t\tif (flags & NO_PROPAGATE_INHERIT_ACE)\n\t\t\t\tflags = 0;\n\t\t} else {\n\t\t\tflags = 0;\n\t\t}\n\n\t\tif (!compare_sids(&creator_owner, &parent_aces->sid)) {\n\t\t\tcreator = &creator_owner;\n\t\t\tid_to_sid(uid, SIDOWNER, &owner_sid);\n\t\t\tpsid = &owner_sid;\n\t\t} else if (!compare_sids(&creator_group, &parent_aces->sid)) {\n\t\t\tcreator = &creator_group;\n\t\t\tid_to_sid(gid, SIDUNIX_GROUP, &group_sid);\n\t\t\tpsid = &group_sid;\n\t\t} else {\n\t\t\tcreator = NULL;\n\t\t\tpsid = &parent_aces->sid;\n\t\t}\n\n\t\tif (is_dir && creator && flags & CONTAINER_INHERIT_ACE) {\n\t\t\tsmb_set_ace(aces, psid, parent_aces->type, inherited_flags,\n\t\t\t\t    parent_aces->access_req);\n\t\t\tnt_size += le16_to_cpu(aces->size);\n\t\t\tace_cnt++;\n\t\t\taces = (struct smb_ace *)((char *)aces + le16_to_cpu(aces->size));\n\t\t\tflags |= INHERIT_ONLY_ACE;\n\t\t\tpsid = creator;\n\t\t} else if (is_dir && !(parent_aces->flags & NO_PROPAGATE_INHERIT_ACE)) {\n\t\t\tpsid = &parent_aces->sid;\n\t\t}\n\n\t\tsmb_set_ace(aces, psid, parent_aces->type, flags | inherited_flags,\n\t\t\t    parent_aces->access_req);\n\t\tnt_size += le16_to_cpu(aces->size);\n\t\taces = (struct smb_ace *)((char *)aces + le16_to_cpu(aces->size));\n\t\tace_cnt++;\npass:\n\t\tparent_aces =\n\t\t\t(struct smb_ace *)((char *)parent_aces + le16_to_cpu(parent_aces->size));\n\t}\n\n\tif (nt_size > 0) {\n\t\tstruct smb_ntsd *pntsd;\n\t\tstruct smb_acl *pdacl;\n\t\tstruct smb_sid *powner_sid = NULL, *pgroup_sid = NULL;\n\t\tint powner_sid_size = 0, pgroup_sid_size = 0, pntsd_size;\n\n\t\tif (parent_pntsd->osidoffset) {\n\t\t\tpowner_sid = (struct smb_sid *)((char *)parent_pntsd +\n\t\t\t\t\tle32_to_cpu(parent_pntsd->osidoffset));\n\t\t\tpowner_sid_size = 1 + 1 + 6 + (powner_sid->num_subauth * 4);\n\t\t}\n\t\tif (parent_pntsd->gsidoffset) {\n\t\t\tpgroup_sid = (struct smb_sid *)((char *)parent_pntsd +\n\t\t\t\t\tle32_to_cpu(parent_pntsd->gsidoffset));\n\t\t\tpgroup_sid_size = 1 + 1 + 6 + (pgroup_sid->num_subauth * 4);\n\t\t}\n\n\t\tpntsd = kzalloc(sizeof(struct smb_ntsd) + powner_sid_size +\n\t\t\t\tpgroup_sid_size + sizeof(struct smb_acl) +\n\t\t\t\tnt_size, GFP_KERNEL);\n\t\tif (!pntsd) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto free_aces_base;\n\t\t}\n\n\t\tpntsd->revision = cpu_to_le16(1);\n\t\tpntsd->type = cpu_to_le16(SELF_RELATIVE | DACL_PRESENT);\n\t\tif (le16_to_cpu(parent_pntsd->type) & DACL_AUTO_INHERITED)\n\t\t\tpntsd->type |= cpu_to_le16(DACL_AUTO_INHERITED);\n\t\tpntsd_size = sizeof(struct smb_ntsd);\n\t\tpntsd->osidoffset = parent_pntsd->osidoffset;\n\t\tpntsd->gsidoffset = parent_pntsd->gsidoffset;\n\t\tpntsd->dacloffset = parent_pntsd->dacloffset;\n\n\t\tif (pntsd->osidoffset) {\n\t\t\tstruct smb_sid *owner_sid = (struct smb_sid *)((char *)pntsd +\n\t\t\t\t\tle32_to_cpu(pntsd->osidoffset));\n\t\t\tmemcpy(owner_sid, powner_sid, powner_sid_size);\n\t\t\tpntsd_size += powner_sid_size;\n\t\t}\n\n\t\tif (pntsd->gsidoffset) {\n\t\t\tstruct smb_sid *group_sid = (struct smb_sid *)((char *)pntsd +\n\t\t\t\t\tle32_to_cpu(pntsd->gsidoffset));\n\t\t\tmemcpy(group_sid, pgroup_sid, pgroup_sid_size);\n\t\t\tpntsd_size += pgroup_sid_size;\n\t\t}\n\n\t\tif (pntsd->dacloffset) {\n\t\t\tstruct smb_ace *pace;\n\n\t\t\tpdacl = (struct smb_acl *)((char *)pntsd + le32_to_cpu(pntsd->dacloffset));\n\t\t\tpdacl->revision = cpu_to_le16(2);\n\t\t\tpdacl->size = cpu_to_le16(sizeof(struct smb_acl) + nt_size);\n\t\t\tpdacl->num_aces = cpu_to_le32(ace_cnt);\n\t\t\tpace = (struct smb_ace *)((char *)pdacl + sizeof(struct smb_acl));\n\t\t\tmemcpy(pace, aces_base, nt_size);\n\t\t\tpntsd_size += sizeof(struct smb_acl) + nt_size;\n\t\t}\n\n\t\tksmbd_vfs_set_sd_xattr(conn, user_ns,\n\t\t\t\t       path->dentry, pntsd, pntsd_size);\n\t\tkfree(pntsd);\n\t}\n\nfree_aces_base:\n\tkfree(aces_base);\nfree_parent_pntsd:\n\tkfree(parent_pntsd);\n\treturn rc;\n}",
        "code_after_change": "int smb_inherit_dacl(struct ksmbd_conn *conn,\n\t\t     struct path *path,\n\t\t     unsigned int uid, unsigned int gid)\n{\n\tconst struct smb_sid *psid, *creator = NULL;\n\tstruct smb_ace *parent_aces, *aces;\n\tstruct smb_acl *parent_pdacl;\n\tstruct smb_ntsd *parent_pntsd = NULL;\n\tstruct smb_sid owner_sid, group_sid;\n\tstruct dentry *parent = path->dentry->d_parent;\n\tstruct user_namespace *user_ns = mnt_user_ns(path->mnt);\n\tint inherited_flags = 0, flags = 0, i, ace_cnt = 0, nt_size = 0, pdacl_size;\n\tint rc = 0, num_aces, dacloffset, pntsd_type, pntsd_size, acl_len, aces_size;\n\tchar *aces_base;\n\tbool is_dir = S_ISDIR(d_inode(path->dentry)->i_mode);\n\n\tpntsd_size = ksmbd_vfs_get_sd_xattr(conn, user_ns,\n\t\t\t\t\t    parent, &parent_pntsd);\n\tif (pntsd_size <= 0)\n\t\treturn -ENOENT;\n\tdacloffset = le32_to_cpu(parent_pntsd->dacloffset);\n\tif (!dacloffset || (dacloffset + sizeof(struct smb_acl) > pntsd_size)) {\n\t\trc = -EINVAL;\n\t\tgoto free_parent_pntsd;\n\t}\n\n\tparent_pdacl = (struct smb_acl *)((char *)parent_pntsd + dacloffset);\n\tacl_len = pntsd_size - dacloffset;\n\tnum_aces = le32_to_cpu(parent_pdacl->num_aces);\n\tpntsd_type = le16_to_cpu(parent_pntsd->type);\n\tpdacl_size = le16_to_cpu(parent_pdacl->size);\n\n\tif (pdacl_size > acl_len || pdacl_size < sizeof(struct smb_acl)) {\n\t\trc = -EINVAL;\n\t\tgoto free_parent_pntsd;\n\t}\n\n\taces_base = kmalloc(sizeof(struct smb_ace) * num_aces * 2, GFP_KERNEL);\n\tif (!aces_base) {\n\t\trc = -ENOMEM;\n\t\tgoto free_parent_pntsd;\n\t}\n\n\taces = (struct smb_ace *)aces_base;\n\tparent_aces = (struct smb_ace *)((char *)parent_pdacl +\n\t\t\tsizeof(struct smb_acl));\n\taces_size = acl_len - sizeof(struct smb_acl);\n\n\tif (pntsd_type & DACL_AUTO_INHERITED)\n\t\tinherited_flags = INHERITED_ACE;\n\n\tfor (i = 0; i < num_aces; i++) {\n\t\tint pace_size;\n\n\t\tif (offsetof(struct smb_ace, access_req) > aces_size)\n\t\t\tbreak;\n\n\t\tpace_size = le16_to_cpu(parent_aces->size);\n\t\tif (pace_size > aces_size)\n\t\t\tbreak;\n\n\t\taces_size -= pace_size;\n\n\t\tflags = parent_aces->flags;\n\t\tif (!smb_inherit_flags(flags, is_dir))\n\t\t\tgoto pass;\n\t\tif (is_dir) {\n\t\t\tflags &= ~(INHERIT_ONLY_ACE | INHERITED_ACE);\n\t\t\tif (!(flags & CONTAINER_INHERIT_ACE))\n\t\t\t\tflags |= INHERIT_ONLY_ACE;\n\t\t\tif (flags & NO_PROPAGATE_INHERIT_ACE)\n\t\t\t\tflags = 0;\n\t\t} else {\n\t\t\tflags = 0;\n\t\t}\n\n\t\tif (!compare_sids(&creator_owner, &parent_aces->sid)) {\n\t\t\tcreator = &creator_owner;\n\t\t\tid_to_sid(uid, SIDOWNER, &owner_sid);\n\t\t\tpsid = &owner_sid;\n\t\t} else if (!compare_sids(&creator_group, &parent_aces->sid)) {\n\t\t\tcreator = &creator_group;\n\t\t\tid_to_sid(gid, SIDUNIX_GROUP, &group_sid);\n\t\t\tpsid = &group_sid;\n\t\t} else {\n\t\t\tcreator = NULL;\n\t\t\tpsid = &parent_aces->sid;\n\t\t}\n\n\t\tif (is_dir && creator && flags & CONTAINER_INHERIT_ACE) {\n\t\t\tsmb_set_ace(aces, psid, parent_aces->type, inherited_flags,\n\t\t\t\t    parent_aces->access_req);\n\t\t\tnt_size += le16_to_cpu(aces->size);\n\t\t\tace_cnt++;\n\t\t\taces = (struct smb_ace *)((char *)aces + le16_to_cpu(aces->size));\n\t\t\tflags |= INHERIT_ONLY_ACE;\n\t\t\tpsid = creator;\n\t\t} else if (is_dir && !(parent_aces->flags & NO_PROPAGATE_INHERIT_ACE)) {\n\t\t\tpsid = &parent_aces->sid;\n\t\t}\n\n\t\tsmb_set_ace(aces, psid, parent_aces->type, flags | inherited_flags,\n\t\t\t    parent_aces->access_req);\n\t\tnt_size += le16_to_cpu(aces->size);\n\t\taces = (struct smb_ace *)((char *)aces + le16_to_cpu(aces->size));\n\t\tace_cnt++;\npass:\n\t\tparent_aces = (struct smb_ace *)((char *)parent_aces + pace_size);\n\t}\n\n\tif (nt_size > 0) {\n\t\tstruct smb_ntsd *pntsd;\n\t\tstruct smb_acl *pdacl;\n\t\tstruct smb_sid *powner_sid = NULL, *pgroup_sid = NULL;\n\t\tint powner_sid_size = 0, pgroup_sid_size = 0, pntsd_size;\n\n\t\tif (parent_pntsd->osidoffset) {\n\t\t\tpowner_sid = (struct smb_sid *)((char *)parent_pntsd +\n\t\t\t\t\tle32_to_cpu(parent_pntsd->osidoffset));\n\t\t\tpowner_sid_size = 1 + 1 + 6 + (powner_sid->num_subauth * 4);\n\t\t}\n\t\tif (parent_pntsd->gsidoffset) {\n\t\t\tpgroup_sid = (struct smb_sid *)((char *)parent_pntsd +\n\t\t\t\t\tle32_to_cpu(parent_pntsd->gsidoffset));\n\t\t\tpgroup_sid_size = 1 + 1 + 6 + (pgroup_sid->num_subauth * 4);\n\t\t}\n\n\t\tpntsd = kzalloc(sizeof(struct smb_ntsd) + powner_sid_size +\n\t\t\t\tpgroup_sid_size + sizeof(struct smb_acl) +\n\t\t\t\tnt_size, GFP_KERNEL);\n\t\tif (!pntsd) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto free_aces_base;\n\t\t}\n\n\t\tpntsd->revision = cpu_to_le16(1);\n\t\tpntsd->type = cpu_to_le16(SELF_RELATIVE | DACL_PRESENT);\n\t\tif (le16_to_cpu(parent_pntsd->type) & DACL_AUTO_INHERITED)\n\t\t\tpntsd->type |= cpu_to_le16(DACL_AUTO_INHERITED);\n\t\tpntsd_size = sizeof(struct smb_ntsd);\n\t\tpntsd->osidoffset = parent_pntsd->osidoffset;\n\t\tpntsd->gsidoffset = parent_pntsd->gsidoffset;\n\t\tpntsd->dacloffset = parent_pntsd->dacloffset;\n\n\t\tif (pntsd->osidoffset) {\n\t\t\tstruct smb_sid *owner_sid = (struct smb_sid *)((char *)pntsd +\n\t\t\t\t\tle32_to_cpu(pntsd->osidoffset));\n\t\t\tmemcpy(owner_sid, powner_sid, powner_sid_size);\n\t\t\tpntsd_size += powner_sid_size;\n\t\t}\n\n\t\tif (pntsd->gsidoffset) {\n\t\t\tstruct smb_sid *group_sid = (struct smb_sid *)((char *)pntsd +\n\t\t\t\t\tle32_to_cpu(pntsd->gsidoffset));\n\t\t\tmemcpy(group_sid, pgroup_sid, pgroup_sid_size);\n\t\t\tpntsd_size += pgroup_sid_size;\n\t\t}\n\n\t\tif (pntsd->dacloffset) {\n\t\t\tstruct smb_ace *pace;\n\n\t\t\tpdacl = (struct smb_acl *)((char *)pntsd + le32_to_cpu(pntsd->dacloffset));\n\t\t\tpdacl->revision = cpu_to_le16(2);\n\t\t\tpdacl->size = cpu_to_le16(sizeof(struct smb_acl) + nt_size);\n\t\t\tpdacl->num_aces = cpu_to_le32(ace_cnt);\n\t\t\tpace = (struct smb_ace *)((char *)pdacl + sizeof(struct smb_acl));\n\t\t\tmemcpy(pace, aces_base, nt_size);\n\t\t\tpntsd_size += sizeof(struct smb_acl) + nt_size;\n\t\t}\n\n\t\tksmbd_vfs_set_sd_xattr(conn, user_ns,\n\t\t\t\t       path->dentry, pntsd, pntsd_size);\n\t\tkfree(pntsd);\n\t}\n\nfree_aces_base:\n\tkfree(aces_base);\nfree_parent_pntsd:\n\tkfree(parent_pntsd);\n\treturn rc;\n}",
        "patch": "--- code before\n+++ code after\n@@ -9,24 +9,31 @@\n \tstruct smb_sid owner_sid, group_sid;\n \tstruct dentry *parent = path->dentry->d_parent;\n \tstruct user_namespace *user_ns = mnt_user_ns(path->mnt);\n-\tint inherited_flags = 0, flags = 0, i, ace_cnt = 0, nt_size = 0;\n-\tint rc = 0, num_aces, dacloffset, pntsd_type, acl_len;\n+\tint inherited_flags = 0, flags = 0, i, ace_cnt = 0, nt_size = 0, pdacl_size;\n+\tint rc = 0, num_aces, dacloffset, pntsd_type, pntsd_size, acl_len, aces_size;\n \tchar *aces_base;\n \tbool is_dir = S_ISDIR(d_inode(path->dentry)->i_mode);\n \n-\tacl_len = ksmbd_vfs_get_sd_xattr(conn, user_ns,\n-\t\t\t\t\t parent, &parent_pntsd);\n-\tif (acl_len <= 0)\n+\tpntsd_size = ksmbd_vfs_get_sd_xattr(conn, user_ns,\n+\t\t\t\t\t    parent, &parent_pntsd);\n+\tif (pntsd_size <= 0)\n \t\treturn -ENOENT;\n \tdacloffset = le32_to_cpu(parent_pntsd->dacloffset);\n-\tif (!dacloffset) {\n+\tif (!dacloffset || (dacloffset + sizeof(struct smb_acl) > pntsd_size)) {\n \t\trc = -EINVAL;\n \t\tgoto free_parent_pntsd;\n \t}\n \n \tparent_pdacl = (struct smb_acl *)((char *)parent_pntsd + dacloffset);\n+\tacl_len = pntsd_size - dacloffset;\n \tnum_aces = le32_to_cpu(parent_pdacl->num_aces);\n \tpntsd_type = le16_to_cpu(parent_pntsd->type);\n+\tpdacl_size = le16_to_cpu(parent_pdacl->size);\n+\n+\tif (pdacl_size > acl_len || pdacl_size < sizeof(struct smb_acl)) {\n+\t\trc = -EINVAL;\n+\t\tgoto free_parent_pntsd;\n+\t}\n \n \taces_base = kmalloc(sizeof(struct smb_ace) * num_aces * 2, GFP_KERNEL);\n \tif (!aces_base) {\n@@ -37,11 +44,23 @@\n \taces = (struct smb_ace *)aces_base;\n \tparent_aces = (struct smb_ace *)((char *)parent_pdacl +\n \t\t\tsizeof(struct smb_acl));\n+\taces_size = acl_len - sizeof(struct smb_acl);\n \n \tif (pntsd_type & DACL_AUTO_INHERITED)\n \t\tinherited_flags = INHERITED_ACE;\n \n \tfor (i = 0; i < num_aces; i++) {\n+\t\tint pace_size;\n+\n+\t\tif (offsetof(struct smb_ace, access_req) > aces_size)\n+\t\t\tbreak;\n+\n+\t\tpace_size = le16_to_cpu(parent_aces->size);\n+\t\tif (pace_size > aces_size)\n+\t\t\tbreak;\n+\n+\t\taces_size -= pace_size;\n+\n \t\tflags = parent_aces->flags;\n \t\tif (!smb_inherit_flags(flags, is_dir))\n \t\t\tgoto pass;\n@@ -86,8 +105,7 @@\n \t\taces = (struct smb_ace *)((char *)aces + le16_to_cpu(aces->size));\n \t\tace_cnt++;\n pass:\n-\t\tparent_aces =\n-\t\t\t(struct smb_ace *)((char *)parent_aces + le16_to_cpu(parent_aces->size));\n+\t\tparent_aces = (struct smb_ace *)((char *)parent_aces + pace_size);\n \t}\n \n \tif (nt_size > 0) {",
        "function_modified_lines": {
            "added": [
                "\tint inherited_flags = 0, flags = 0, i, ace_cnt = 0, nt_size = 0, pdacl_size;",
                "\tint rc = 0, num_aces, dacloffset, pntsd_type, pntsd_size, acl_len, aces_size;",
                "\tpntsd_size = ksmbd_vfs_get_sd_xattr(conn, user_ns,",
                "\t\t\t\t\t    parent, &parent_pntsd);",
                "\tif (pntsd_size <= 0)",
                "\tif (!dacloffset || (dacloffset + sizeof(struct smb_acl) > pntsd_size)) {",
                "\tacl_len = pntsd_size - dacloffset;",
                "\tpdacl_size = le16_to_cpu(parent_pdacl->size);",
                "",
                "\tif (pdacl_size > acl_len || pdacl_size < sizeof(struct smb_acl)) {",
                "\t\trc = -EINVAL;",
                "\t\tgoto free_parent_pntsd;",
                "\t}",
                "\taces_size = acl_len - sizeof(struct smb_acl);",
                "\t\tint pace_size;",
                "",
                "\t\tif (offsetof(struct smb_ace, access_req) > aces_size)",
                "\t\t\tbreak;",
                "",
                "\t\tpace_size = le16_to_cpu(parent_aces->size);",
                "\t\tif (pace_size > aces_size)",
                "\t\t\tbreak;",
                "",
                "\t\taces_size -= pace_size;",
                "",
                "\t\tparent_aces = (struct smb_ace *)((char *)parent_aces + pace_size);"
            ],
            "deleted": [
                "\tint inherited_flags = 0, flags = 0, i, ace_cnt = 0, nt_size = 0;",
                "\tint rc = 0, num_aces, dacloffset, pntsd_type, acl_len;",
                "\tacl_len = ksmbd_vfs_get_sd_xattr(conn, user_ns,",
                "\t\t\t\t\t parent, &parent_pntsd);",
                "\tif (acl_len <= 0)",
                "\tif (!dacloffset) {",
                "\t\tparent_aces =",
                "\t\t\t(struct smb_ace *)((char *)parent_aces + le16_to_cpu(parent_aces->size));"
            ]
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "An issue was discovered in ksmbd in the Linux kernel 5.15 through 5.19 before 5.19.2. There is a heap-based buffer overflow in set_ntacl_dacl, related to use of SMB2_QUERY_INFO_HE after a malformed SMB2_SET_INFO_HE command.",
        "id": 3774
    },
    {
        "cve_id": "CVE-2018-5703",
        "code_before_change": "static int __init tls_register(void)\n{\n\tbuild_protos(tls_prots, &tcp_prot);\n\n\ttcp_register_ulp(&tcp_tls_ulp_ops);\n\n\treturn 0;\n}",
        "code_after_change": "static int __init tls_register(void)\n{\n\tbuild_protos(tls_prots[TLSV4], &tcp_prot);\n\n\ttcp_register_ulp(&tcp_tls_ulp_ops);\n\n\treturn 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -1,6 +1,6 @@\n static int __init tls_register(void)\n {\n-\tbuild_protos(tls_prots, &tcp_prot);\n+\tbuild_protos(tls_prots[TLSV4], &tcp_prot);\n \n \ttcp_register_ulp(&tcp_tls_ulp_ops);\n ",
        "function_modified_lines": {
            "added": [
                "\tbuild_protos(tls_prots[TLSV4], &tcp_prot);"
            ],
            "deleted": [
                "\tbuild_protos(tls_prots, &tcp_prot);"
            ]
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "The tcp_v6_syn_recv_sock function in net/ipv6/tcp_ipv6.c in the Linux kernel through 4.14.11 allows attackers to cause a denial of service (slab out-of-bounds write) or possibly have unspecified other impact via vectors involving TLS.",
        "id": 1825
    },
    {
        "cve_id": "CVE-2023-4273",
        "code_before_change": "int exfat_find_dir_entry(struct super_block *sb, struct exfat_inode_info *ei,\n\t\tstruct exfat_chain *p_dir, struct exfat_uni_name *p_uniname,\n\t\tstruct exfat_hint *hint_opt)\n{\n\tint i, rewind = 0, dentry = 0, end_eidx = 0, num_ext = 0, len;\n\tint order, step, name_len = 0;\n\tint dentries_per_clu;\n\tunsigned int entry_type;\n\tunsigned short *uniname = NULL;\n\tstruct exfat_chain clu;\n\tstruct exfat_hint *hint_stat = &ei->hint_stat;\n\tstruct exfat_hint_femp candi_empty;\n\tstruct exfat_sb_info *sbi = EXFAT_SB(sb);\n\tint num_entries = exfat_calc_num_entries(p_uniname);\n\n\tif (num_entries < 0)\n\t\treturn num_entries;\n\n\tdentries_per_clu = sbi->dentries_per_clu;\n\n\texfat_chain_dup(&clu, p_dir);\n\n\tif (hint_stat->eidx) {\n\t\tclu.dir = hint_stat->clu;\n\t\tdentry = hint_stat->eidx;\n\t\tend_eidx = dentry;\n\t}\n\n\texfat_reset_empty_hint(&ei->hint_femp);\n\nrewind:\n\torder = 0;\n\tstep = DIRENT_STEP_FILE;\n\texfat_reset_empty_hint(&candi_empty);\n\n\twhile (clu.dir != EXFAT_EOF_CLUSTER) {\n\t\ti = dentry & (dentries_per_clu - 1);\n\t\tfor (; i < dentries_per_clu; i++, dentry++) {\n\t\t\tstruct exfat_dentry *ep;\n\t\t\tstruct buffer_head *bh;\n\n\t\t\tif (rewind && dentry == end_eidx)\n\t\t\t\tgoto not_found;\n\n\t\t\tep = exfat_get_dentry(sb, &clu, i, &bh);\n\t\t\tif (!ep)\n\t\t\t\treturn -EIO;\n\n\t\t\tentry_type = exfat_get_entry_type(ep);\n\n\t\t\tif (entry_type == TYPE_UNUSED ||\n\t\t\t    entry_type == TYPE_DELETED) {\n\t\t\t\tstep = DIRENT_STEP_FILE;\n\n\t\t\t\texfat_set_empty_hint(ei, &candi_empty, &clu,\n\t\t\t\t\t\tdentry, num_entries,\n\t\t\t\t\t\tentry_type);\n\n\t\t\t\tbrelse(bh);\n\t\t\t\tif (entry_type == TYPE_UNUSED)\n\t\t\t\t\tgoto not_found;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\texfat_reset_empty_hint(&candi_empty);\n\n\t\t\tif (entry_type == TYPE_FILE || entry_type == TYPE_DIR) {\n\t\t\t\tstep = DIRENT_STEP_FILE;\n\t\t\t\thint_opt->clu = clu.dir;\n\t\t\t\thint_opt->eidx = i;\n\t\t\t\tnum_ext = ep->dentry.file.num_ext;\n\t\t\t\tstep = DIRENT_STEP_STRM;\n\t\t\t\tbrelse(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (entry_type == TYPE_STREAM) {\n\t\t\t\tu16 name_hash;\n\n\t\t\t\tif (step != DIRENT_STEP_STRM) {\n\t\t\t\t\tstep = DIRENT_STEP_FILE;\n\t\t\t\t\tbrelse(bh);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tstep = DIRENT_STEP_FILE;\n\t\t\t\tname_hash = le16_to_cpu(\n\t\t\t\t\t\tep->dentry.stream.name_hash);\n\t\t\t\tif (p_uniname->name_hash == name_hash &&\n\t\t\t\t    p_uniname->name_len ==\n\t\t\t\t\t\tep->dentry.stream.name_len) {\n\t\t\t\t\tstep = DIRENT_STEP_NAME;\n\t\t\t\t\torder = 1;\n\t\t\t\t\tname_len = 0;\n\t\t\t\t}\n\t\t\t\tbrelse(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tbrelse(bh);\n\t\t\tif (entry_type == TYPE_EXTEND) {\n\t\t\t\tunsigned short entry_uniname[16], unichar;\n\n\t\t\t\tif (step != DIRENT_STEP_NAME) {\n\t\t\t\t\tstep = DIRENT_STEP_FILE;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (++order == 2)\n\t\t\t\t\tuniname = p_uniname->name;\n\t\t\t\telse\n\t\t\t\t\tuniname += EXFAT_FILE_NAME_LEN;\n\n\t\t\t\tlen = exfat_extract_uni_name(ep, entry_uniname);\n\t\t\t\tname_len += len;\n\n\t\t\t\tunichar = *(uniname+len);\n\t\t\t\t*(uniname+len) = 0x0;\n\n\t\t\t\tif (exfat_uniname_ncmp(sb, uniname,\n\t\t\t\t\tentry_uniname, len)) {\n\t\t\t\t\tstep = DIRENT_STEP_FILE;\n\t\t\t\t} else if (p_uniname->name_len == name_len) {\n\t\t\t\t\tif (order == num_ext)\n\t\t\t\t\t\tgoto found;\n\t\t\t\t\tstep = DIRENT_STEP_SECD;\n\t\t\t\t}\n\n\t\t\t\t*(uniname+len) = unichar;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (entry_type &\n\t\t\t\t\t(TYPE_CRITICAL_SEC | TYPE_BENIGN_SEC)) {\n\t\t\t\tif (step == DIRENT_STEP_SECD) {\n\t\t\t\t\tif (++order == num_ext)\n\t\t\t\t\t\tgoto found;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstep = DIRENT_STEP_FILE;\n\t\t}\n\n\t\tif (clu.flags == ALLOC_NO_FAT_CHAIN) {\n\t\t\tif (--clu.size > 0)\n\t\t\t\tclu.dir++;\n\t\t\telse\n\t\t\t\tclu.dir = EXFAT_EOF_CLUSTER;\n\t\t} else {\n\t\t\tif (exfat_get_next_cluster(sb, &clu.dir))\n\t\t\t\treturn -EIO;\n\t\t}\n\t}\n\nnot_found:\n\t/*\n\t * We started at not 0 index,so we should try to find target\n\t * from 0 index to the index we started at.\n\t */\n\tif (!rewind && end_eidx) {\n\t\trewind = 1;\n\t\tdentry = 0;\n\t\tclu.dir = p_dir->dir;\n\t\tgoto rewind;\n\t}\n\n\t/*\n\t * set the EXFAT_EOF_CLUSTER flag to avoid search\n\t * from the beginning again when allocated a new cluster\n\t */\n\tif (ei->hint_femp.eidx == EXFAT_HINT_NONE) {\n\t\tei->hint_femp.cur.dir = EXFAT_EOF_CLUSTER;\n\t\tei->hint_femp.eidx = p_dir->size * dentries_per_clu;\n\t\tei->hint_femp.count = 0;\n\t}\n\n\t/* initialized hint_stat */\n\thint_stat->clu = p_dir->dir;\n\thint_stat->eidx = 0;\n\treturn -ENOENT;\n\nfound:\n\t/* next dentry we'll find is out of this cluster */\n\tif (!((dentry + 1) & (dentries_per_clu - 1))) {\n\t\tint ret = 0;\n\n\t\tif (clu.flags == ALLOC_NO_FAT_CHAIN) {\n\t\t\tif (--clu.size > 0)\n\t\t\t\tclu.dir++;\n\t\t\telse\n\t\t\t\tclu.dir = EXFAT_EOF_CLUSTER;\n\t\t} else {\n\t\t\tret = exfat_get_next_cluster(sb, &clu.dir);\n\t\t}\n\n\t\tif (ret || clu.dir == EXFAT_EOF_CLUSTER) {\n\t\t\t/* just initialized hint_stat */\n\t\t\thint_stat->clu = p_dir->dir;\n\t\t\thint_stat->eidx = 0;\n\t\t\treturn (dentry - num_ext);\n\t\t}\n\t}\n\n\thint_stat->clu = clu.dir;\n\thint_stat->eidx = dentry + 1;\n\treturn dentry - num_ext;\n}",
        "code_after_change": "int exfat_find_dir_entry(struct super_block *sb, struct exfat_inode_info *ei,\n\t\tstruct exfat_chain *p_dir, struct exfat_uni_name *p_uniname,\n\t\tstruct exfat_hint *hint_opt)\n{\n\tint i, rewind = 0, dentry = 0, end_eidx = 0, num_ext = 0, len;\n\tint order, step, name_len = 0;\n\tint dentries_per_clu;\n\tunsigned int entry_type;\n\tunsigned short *uniname = NULL;\n\tstruct exfat_chain clu;\n\tstruct exfat_hint *hint_stat = &ei->hint_stat;\n\tstruct exfat_hint_femp candi_empty;\n\tstruct exfat_sb_info *sbi = EXFAT_SB(sb);\n\tint num_entries = exfat_calc_num_entries(p_uniname);\n\n\tif (num_entries < 0)\n\t\treturn num_entries;\n\n\tdentries_per_clu = sbi->dentries_per_clu;\n\n\texfat_chain_dup(&clu, p_dir);\n\n\tif (hint_stat->eidx) {\n\t\tclu.dir = hint_stat->clu;\n\t\tdentry = hint_stat->eidx;\n\t\tend_eidx = dentry;\n\t}\n\n\texfat_reset_empty_hint(&ei->hint_femp);\n\nrewind:\n\torder = 0;\n\tstep = DIRENT_STEP_FILE;\n\texfat_reset_empty_hint(&candi_empty);\n\n\twhile (clu.dir != EXFAT_EOF_CLUSTER) {\n\t\ti = dentry & (dentries_per_clu - 1);\n\t\tfor (; i < dentries_per_clu; i++, dentry++) {\n\t\t\tstruct exfat_dentry *ep;\n\t\t\tstruct buffer_head *bh;\n\n\t\t\tif (rewind && dentry == end_eidx)\n\t\t\t\tgoto not_found;\n\n\t\t\tep = exfat_get_dentry(sb, &clu, i, &bh);\n\t\t\tif (!ep)\n\t\t\t\treturn -EIO;\n\n\t\t\tentry_type = exfat_get_entry_type(ep);\n\n\t\t\tif (entry_type == TYPE_UNUSED ||\n\t\t\t    entry_type == TYPE_DELETED) {\n\t\t\t\tstep = DIRENT_STEP_FILE;\n\n\t\t\t\texfat_set_empty_hint(ei, &candi_empty, &clu,\n\t\t\t\t\t\tdentry, num_entries,\n\t\t\t\t\t\tentry_type);\n\n\t\t\t\tbrelse(bh);\n\t\t\t\tif (entry_type == TYPE_UNUSED)\n\t\t\t\t\tgoto not_found;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\texfat_reset_empty_hint(&candi_empty);\n\n\t\t\tif (entry_type == TYPE_FILE || entry_type == TYPE_DIR) {\n\t\t\t\tstep = DIRENT_STEP_FILE;\n\t\t\t\thint_opt->clu = clu.dir;\n\t\t\t\thint_opt->eidx = i;\n\t\t\t\tnum_ext = ep->dentry.file.num_ext;\n\t\t\t\tstep = DIRENT_STEP_STRM;\n\t\t\t\tbrelse(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (entry_type == TYPE_STREAM) {\n\t\t\t\tu16 name_hash;\n\n\t\t\t\tif (step != DIRENT_STEP_STRM) {\n\t\t\t\t\tstep = DIRENT_STEP_FILE;\n\t\t\t\t\tbrelse(bh);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tstep = DIRENT_STEP_FILE;\n\t\t\t\tname_hash = le16_to_cpu(\n\t\t\t\t\t\tep->dentry.stream.name_hash);\n\t\t\t\tif (p_uniname->name_hash == name_hash &&\n\t\t\t\t    p_uniname->name_len ==\n\t\t\t\t\t\tep->dentry.stream.name_len) {\n\t\t\t\t\tstep = DIRENT_STEP_NAME;\n\t\t\t\t\torder = 1;\n\t\t\t\t\tname_len = 0;\n\t\t\t\t}\n\t\t\t\tbrelse(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tbrelse(bh);\n\t\t\tif (entry_type == TYPE_EXTEND) {\n\t\t\t\tunsigned short entry_uniname[16], unichar;\n\n\t\t\t\tif (step != DIRENT_STEP_NAME ||\n\t\t\t\t    name_len >= MAX_NAME_LENGTH) {\n\t\t\t\t\tstep = DIRENT_STEP_FILE;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (++order == 2)\n\t\t\t\t\tuniname = p_uniname->name;\n\t\t\t\telse\n\t\t\t\t\tuniname += EXFAT_FILE_NAME_LEN;\n\n\t\t\t\tlen = exfat_extract_uni_name(ep, entry_uniname);\n\t\t\t\tname_len += len;\n\n\t\t\t\tunichar = *(uniname+len);\n\t\t\t\t*(uniname+len) = 0x0;\n\n\t\t\t\tif (exfat_uniname_ncmp(sb, uniname,\n\t\t\t\t\tentry_uniname, len)) {\n\t\t\t\t\tstep = DIRENT_STEP_FILE;\n\t\t\t\t} else if (p_uniname->name_len == name_len) {\n\t\t\t\t\tif (order == num_ext)\n\t\t\t\t\t\tgoto found;\n\t\t\t\t\tstep = DIRENT_STEP_SECD;\n\t\t\t\t}\n\n\t\t\t\t*(uniname+len) = unichar;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (entry_type &\n\t\t\t\t\t(TYPE_CRITICAL_SEC | TYPE_BENIGN_SEC)) {\n\t\t\t\tif (step == DIRENT_STEP_SECD) {\n\t\t\t\t\tif (++order == num_ext)\n\t\t\t\t\t\tgoto found;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstep = DIRENT_STEP_FILE;\n\t\t}\n\n\t\tif (clu.flags == ALLOC_NO_FAT_CHAIN) {\n\t\t\tif (--clu.size > 0)\n\t\t\t\tclu.dir++;\n\t\t\telse\n\t\t\t\tclu.dir = EXFAT_EOF_CLUSTER;\n\t\t} else {\n\t\t\tif (exfat_get_next_cluster(sb, &clu.dir))\n\t\t\t\treturn -EIO;\n\t\t}\n\t}\n\nnot_found:\n\t/*\n\t * We started at not 0 index,so we should try to find target\n\t * from 0 index to the index we started at.\n\t */\n\tif (!rewind && end_eidx) {\n\t\trewind = 1;\n\t\tdentry = 0;\n\t\tclu.dir = p_dir->dir;\n\t\tgoto rewind;\n\t}\n\n\t/*\n\t * set the EXFAT_EOF_CLUSTER flag to avoid search\n\t * from the beginning again when allocated a new cluster\n\t */\n\tif (ei->hint_femp.eidx == EXFAT_HINT_NONE) {\n\t\tei->hint_femp.cur.dir = EXFAT_EOF_CLUSTER;\n\t\tei->hint_femp.eidx = p_dir->size * dentries_per_clu;\n\t\tei->hint_femp.count = 0;\n\t}\n\n\t/* initialized hint_stat */\n\thint_stat->clu = p_dir->dir;\n\thint_stat->eidx = 0;\n\treturn -ENOENT;\n\nfound:\n\t/* next dentry we'll find is out of this cluster */\n\tif (!((dentry + 1) & (dentries_per_clu - 1))) {\n\t\tint ret = 0;\n\n\t\tif (clu.flags == ALLOC_NO_FAT_CHAIN) {\n\t\t\tif (--clu.size > 0)\n\t\t\t\tclu.dir++;\n\t\t\telse\n\t\t\t\tclu.dir = EXFAT_EOF_CLUSTER;\n\t\t} else {\n\t\t\tret = exfat_get_next_cluster(sb, &clu.dir);\n\t\t}\n\n\t\tif (ret || clu.dir == EXFAT_EOF_CLUSTER) {\n\t\t\t/* just initialized hint_stat */\n\t\t\thint_stat->clu = p_dir->dir;\n\t\t\thint_stat->eidx = 0;\n\t\t\treturn (dentry - num_ext);\n\t\t}\n\t}\n\n\thint_stat->clu = clu.dir;\n\thint_stat->eidx = dentry + 1;\n\treturn dentry - num_ext;\n}",
        "patch": "--- code before\n+++ code after\n@@ -100,7 +100,8 @@\n \t\t\tif (entry_type == TYPE_EXTEND) {\n \t\t\t\tunsigned short entry_uniname[16], unichar;\n \n-\t\t\t\tif (step != DIRENT_STEP_NAME) {\n+\t\t\t\tif (step != DIRENT_STEP_NAME ||\n+\t\t\t\t    name_len >= MAX_NAME_LENGTH) {\n \t\t\t\t\tstep = DIRENT_STEP_FILE;\n \t\t\t\t\tcontinue;\n \t\t\t\t}",
        "function_modified_lines": {
            "added": [
                "\t\t\t\tif (step != DIRENT_STEP_NAME ||",
                "\t\t\t\t    name_len >= MAX_NAME_LENGTH) {"
            ],
            "deleted": [
                "\t\t\t\tif (step != DIRENT_STEP_NAME) {"
            ]
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "A flaw was found in the exFAT driver of the Linux kernel. The vulnerability exists in the implementation of the file name reconstruction function, which is responsible for reading file name entries from a directory index and merging file name parts belonging to one file into a single long file name. Since the file name characters are copied into a stack variable, a local privileged attacker could use this flaw to overflow the kernel stack.",
        "id": 4205
    },
    {
        "cve_id": "CVE-2022-2991",
        "code_before_change": "static int nvme_ns_ioctl(struct nvme_ns *ns, unsigned int cmd,\n\t\tvoid __user *argp)\n{\n\tswitch (cmd) {\n\tcase NVME_IOCTL_ID:\n\t\tforce_successful_syscall_return();\n\t\treturn ns->head->ns_id;\n\tcase NVME_IOCTL_IO_CMD:\n\t\treturn nvme_user_cmd(ns->ctrl, ns, argp);\n\t/*\n\t * struct nvme_user_io can have different padding on some 32-bit ABIs.\n\t * Just accept the compat version as all fields that are used are the\n\t * same size and at the same offset.\n\t */\n#ifdef COMPAT_FOR_U64_ALIGNMENT\n\tcase NVME_IOCTL_SUBMIT_IO32:\n#endif\n\tcase NVME_IOCTL_SUBMIT_IO:\n\t\treturn nvme_submit_io(ns, argp);\n\tcase NVME_IOCTL_IO64_CMD:\n\t\treturn nvme_user_cmd64(ns->ctrl, ns, argp);\n\tdefault:\n\t\tif (!ns->ndev)\n\t\t\treturn -ENOTTY;\n\t\treturn nvme_nvm_ioctl(ns, cmd, argp);\n\t}\n}",
        "code_after_change": "static int nvme_ns_ioctl(struct nvme_ns *ns, unsigned int cmd,\n\t\tvoid __user *argp)\n{\n\tswitch (cmd) {\n\tcase NVME_IOCTL_ID:\n\t\tforce_successful_syscall_return();\n\t\treturn ns->head->ns_id;\n\tcase NVME_IOCTL_IO_CMD:\n\t\treturn nvme_user_cmd(ns->ctrl, ns, argp);\n\t/*\n\t * struct nvme_user_io can have different padding on some 32-bit ABIs.\n\t * Just accept the compat version as all fields that are used are the\n\t * same size and at the same offset.\n\t */\n#ifdef COMPAT_FOR_U64_ALIGNMENT\n\tcase NVME_IOCTL_SUBMIT_IO32:\n#endif\n\tcase NVME_IOCTL_SUBMIT_IO:\n\t\treturn nvme_submit_io(ns, argp);\n\tcase NVME_IOCTL_IO64_CMD:\n\t\treturn nvme_user_cmd64(ns->ctrl, ns, argp);\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}",
        "patch": "--- code before\n+++ code after\n@@ -20,8 +20,6 @@\n \tcase NVME_IOCTL_IO64_CMD:\n \t\treturn nvme_user_cmd64(ns->ctrl, ns, argp);\n \tdefault:\n-\t\tif (!ns->ndev)\n-\t\t\treturn -ENOTTY;\n-\t\treturn nvme_nvm_ioctl(ns, cmd, argp);\n+\t\treturn -ENOTTY;\n \t}\n }",
        "function_modified_lines": {
            "added": [
                "\t\treturn -ENOTTY;"
            ],
            "deleted": [
                "\t\tif (!ns->ndev)",
                "\t\t\treturn -ENOTTY;",
                "\t\treturn nvme_nvm_ioctl(ns, cmd, argp);"
            ]
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "A heap-based buffer overflow was found in the Linux kernel's LightNVM subsystem. The issue results from the lack of proper validation of the length of user-supplied data prior to copying it to a fixed-length heap-based buffer. This vulnerability allows a local attacker to escalate privileges and execute arbitrary code in the context of the kernel. The attacker must first obtain the ability to execute high-privileged code on the target system to exploit this vulnerability.",
        "id": 3540
    },
    {
        "cve_id": "CVE-2020-14305",
        "code_before_change": "static int __init nf_conntrack_sane_init(void)\n{\n\tint i, ret = 0;\n\n\tNF_CT_HELPER_BUILD_BUG_ON(sizeof(struct nf_ct_sane_master));\n\n\tsane_buffer = kmalloc(65536, GFP_KERNEL);\n\tif (!sane_buffer)\n\t\treturn -ENOMEM;\n\n\tif (ports_c == 0)\n\t\tports[ports_c++] = SANE_PORT;\n\n\t/* FIXME should be configurable whether IPv4 and IPv6 connections\n\t\t are tracked or not - YK */\n\tfor (i = 0; i < ports_c; i++) {\n\t\tnf_ct_helper_init(&sane[2 * i], AF_INET, IPPROTO_TCP, \"sane\",\n\t\t\t\t  SANE_PORT, ports[i], ports[i],\n\t\t\t\t  &sane_exp_policy, 0,\n\t\t\t\t  sizeof(struct nf_ct_sane_master), help, NULL,\n\t\t\t\t  THIS_MODULE);\n\t\tnf_ct_helper_init(&sane[2 * i + 1], AF_INET6, IPPROTO_TCP, \"sane\",\n\t\t\t\t  SANE_PORT, ports[i], ports[i],\n\t\t\t\t  &sane_exp_policy, 0,\n\t\t\t\t  sizeof(struct nf_ct_sane_master), help, NULL,\n\t\t\t\t  THIS_MODULE);\n\t}\n\n\tret = nf_conntrack_helpers_register(sane, ports_c * 2);\n\tif (ret < 0) {\n\t\tpr_err(\"failed to register helpers\\n\");\n\t\tkfree(sane_buffer);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
        "code_after_change": "static int __init nf_conntrack_sane_init(void)\n{\n\tint i, ret = 0;\n\n\tNF_CT_HELPER_BUILD_BUG_ON(sizeof(struct nf_ct_sane_master));\n\n\tsane_buffer = kmalloc(65536, GFP_KERNEL);\n\tif (!sane_buffer)\n\t\treturn -ENOMEM;\n\n\tif (ports_c == 0)\n\t\tports[ports_c++] = SANE_PORT;\n\n\t/* FIXME should be configurable whether IPv4 and IPv6 connections\n\t\t are tracked or not - YK */\n\tfor (i = 0; i < ports_c; i++) {\n\t\tnf_ct_helper_init(&sane[2 * i], AF_INET, IPPROTO_TCP, \"sane\",\n\t\t\t\t  SANE_PORT, ports[i], ports[i],\n\t\t\t\t  &sane_exp_policy, 0, help, NULL,\n\t\t\t\t  THIS_MODULE);\n\t\tnf_ct_helper_init(&sane[2 * i + 1], AF_INET6, IPPROTO_TCP, \"sane\",\n\t\t\t\t  SANE_PORT, ports[i], ports[i],\n\t\t\t\t  &sane_exp_policy, 0, help, NULL,\n\t\t\t\t  THIS_MODULE);\n\t}\n\n\tret = nf_conntrack_helpers_register(sane, ports_c * 2);\n\tif (ret < 0) {\n\t\tpr_err(\"failed to register helpers\\n\");\n\t\tkfree(sane_buffer);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -16,13 +16,11 @@\n \tfor (i = 0; i < ports_c; i++) {\n \t\tnf_ct_helper_init(&sane[2 * i], AF_INET, IPPROTO_TCP, \"sane\",\n \t\t\t\t  SANE_PORT, ports[i], ports[i],\n-\t\t\t\t  &sane_exp_policy, 0,\n-\t\t\t\t  sizeof(struct nf_ct_sane_master), help, NULL,\n+\t\t\t\t  &sane_exp_policy, 0, help, NULL,\n \t\t\t\t  THIS_MODULE);\n \t\tnf_ct_helper_init(&sane[2 * i + 1], AF_INET6, IPPROTO_TCP, \"sane\",\n \t\t\t\t  SANE_PORT, ports[i], ports[i],\n-\t\t\t\t  &sane_exp_policy, 0,\n-\t\t\t\t  sizeof(struct nf_ct_sane_master), help, NULL,\n+\t\t\t\t  &sane_exp_policy, 0, help, NULL,\n \t\t\t\t  THIS_MODULE);\n \t}\n ",
        "function_modified_lines": {
            "added": [
                "\t\t\t\t  &sane_exp_policy, 0, help, NULL,",
                "\t\t\t\t  &sane_exp_policy, 0, help, NULL,"
            ],
            "deleted": [
                "\t\t\t\t  &sane_exp_policy, 0,",
                "\t\t\t\t  sizeof(struct nf_ct_sane_master), help, NULL,",
                "\t\t\t\t  &sane_exp_policy, 0,",
                "\t\t\t\t  sizeof(struct nf_ct_sane_master), help, NULL,"
            ]
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "An out-of-bounds memory write flaw was found in how the Linux kernel\u2019s Voice Over IP H.323 connection tracking functionality handled connections on ipv6 port 1720. This flaw allows an unauthenticated remote user to crash the system, causing a denial of service. The highest threat from this vulnerability is to confidentiality, integrity, as well as system availability.",
        "id": 2507
    },
    {
        "cve_id": "CVE-2020-14305",
        "code_before_change": "static int __init nf_conntrack_sip_init(void)\n{\n\tint i, ret;\n\n\tNF_CT_HELPER_BUILD_BUG_ON(sizeof(struct nf_ct_sip_master));\n\n\tif (ports_c == 0)\n\t\tports[ports_c++] = SIP_PORT;\n\n\tfor (i = 0; i < ports_c; i++) {\n\t\tnf_ct_helper_init(&sip[4 * i], AF_INET, IPPROTO_UDP, \"sip\",\n\t\t\t\t  SIP_PORT, ports[i], i, sip_exp_policy,\n\t\t\t\t  SIP_EXPECT_MAX,\n\t\t\t\t  sizeof(struct nf_ct_sip_master), sip_help_udp,\n\t\t\t\t  NULL, THIS_MODULE);\n\t\tnf_ct_helper_init(&sip[4 * i + 1], AF_INET, IPPROTO_TCP, \"sip\",\n\t\t\t\t  SIP_PORT, ports[i], i, sip_exp_policy,\n\t\t\t\t  SIP_EXPECT_MAX,\n\t\t\t\t  sizeof(struct nf_ct_sip_master), sip_help_tcp,\n\t\t\t\t  NULL, THIS_MODULE);\n\t\tnf_ct_helper_init(&sip[4 * i + 2], AF_INET6, IPPROTO_UDP, \"sip\",\n\t\t\t\t  SIP_PORT, ports[i], i, sip_exp_policy,\n\t\t\t\t  SIP_EXPECT_MAX,\n\t\t\t\t  sizeof(struct nf_ct_sip_master), sip_help_udp,\n\t\t\t\t  NULL, THIS_MODULE);\n\t\tnf_ct_helper_init(&sip[4 * i + 3], AF_INET6, IPPROTO_TCP, \"sip\",\n\t\t\t\t  SIP_PORT, ports[i], i, sip_exp_policy,\n\t\t\t\t  SIP_EXPECT_MAX,\n\t\t\t\t  sizeof(struct nf_ct_sip_master), sip_help_tcp,\n\t\t\t\t  NULL, THIS_MODULE);\n\t}\n\n\tret = nf_conntrack_helpers_register(sip, ports_c * 4);\n\tif (ret < 0) {\n\t\tpr_err(\"failed to register helpers\\n\");\n\t\treturn ret;\n\t}\n\treturn 0;\n}",
        "code_after_change": "static int __init nf_conntrack_sip_init(void)\n{\n\tint i, ret;\n\n\tNF_CT_HELPER_BUILD_BUG_ON(sizeof(struct nf_ct_sip_master));\n\n\tif (ports_c == 0)\n\t\tports[ports_c++] = SIP_PORT;\n\n\tfor (i = 0; i < ports_c; i++) {\n\t\tnf_ct_helper_init(&sip[4 * i], AF_INET, IPPROTO_UDP, \"sip\",\n\t\t\t\t  SIP_PORT, ports[i], i, sip_exp_policy,\n\t\t\t\t  SIP_EXPECT_MAX, sip_help_udp,\n\t\t\t\t  NULL, THIS_MODULE);\n\t\tnf_ct_helper_init(&sip[4 * i + 1], AF_INET, IPPROTO_TCP, \"sip\",\n\t\t\t\t  SIP_PORT, ports[i], i, sip_exp_policy,\n\t\t\t\t  SIP_EXPECT_MAX, sip_help_tcp,\n\t\t\t\t  NULL, THIS_MODULE);\n\t\tnf_ct_helper_init(&sip[4 * i + 2], AF_INET6, IPPROTO_UDP, \"sip\",\n\t\t\t\t  SIP_PORT, ports[i], i, sip_exp_policy,\n\t\t\t\t  SIP_EXPECT_MAX, sip_help_udp,\n\t\t\t\t  NULL, THIS_MODULE);\n\t\tnf_ct_helper_init(&sip[4 * i + 3], AF_INET6, IPPROTO_TCP, \"sip\",\n\t\t\t\t  SIP_PORT, ports[i], i, sip_exp_policy,\n\t\t\t\t  SIP_EXPECT_MAX, sip_help_tcp,\n\t\t\t\t  NULL, THIS_MODULE);\n\t}\n\n\tret = nf_conntrack_helpers_register(sip, ports_c * 4);\n\tif (ret < 0) {\n\t\tpr_err(\"failed to register helpers\\n\");\n\t\treturn ret;\n\t}\n\treturn 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -10,23 +10,19 @@\n \tfor (i = 0; i < ports_c; i++) {\n \t\tnf_ct_helper_init(&sip[4 * i], AF_INET, IPPROTO_UDP, \"sip\",\n \t\t\t\t  SIP_PORT, ports[i], i, sip_exp_policy,\n-\t\t\t\t  SIP_EXPECT_MAX,\n-\t\t\t\t  sizeof(struct nf_ct_sip_master), sip_help_udp,\n+\t\t\t\t  SIP_EXPECT_MAX, sip_help_udp,\n \t\t\t\t  NULL, THIS_MODULE);\n \t\tnf_ct_helper_init(&sip[4 * i + 1], AF_INET, IPPROTO_TCP, \"sip\",\n \t\t\t\t  SIP_PORT, ports[i], i, sip_exp_policy,\n-\t\t\t\t  SIP_EXPECT_MAX,\n-\t\t\t\t  sizeof(struct nf_ct_sip_master), sip_help_tcp,\n+\t\t\t\t  SIP_EXPECT_MAX, sip_help_tcp,\n \t\t\t\t  NULL, THIS_MODULE);\n \t\tnf_ct_helper_init(&sip[4 * i + 2], AF_INET6, IPPROTO_UDP, \"sip\",\n \t\t\t\t  SIP_PORT, ports[i], i, sip_exp_policy,\n-\t\t\t\t  SIP_EXPECT_MAX,\n-\t\t\t\t  sizeof(struct nf_ct_sip_master), sip_help_udp,\n+\t\t\t\t  SIP_EXPECT_MAX, sip_help_udp,\n \t\t\t\t  NULL, THIS_MODULE);\n \t\tnf_ct_helper_init(&sip[4 * i + 3], AF_INET6, IPPROTO_TCP, \"sip\",\n \t\t\t\t  SIP_PORT, ports[i], i, sip_exp_policy,\n-\t\t\t\t  SIP_EXPECT_MAX,\n-\t\t\t\t  sizeof(struct nf_ct_sip_master), sip_help_tcp,\n+\t\t\t\t  SIP_EXPECT_MAX, sip_help_tcp,\n \t\t\t\t  NULL, THIS_MODULE);\n \t}\n ",
        "function_modified_lines": {
            "added": [
                "\t\t\t\t  SIP_EXPECT_MAX, sip_help_udp,",
                "\t\t\t\t  SIP_EXPECT_MAX, sip_help_tcp,",
                "\t\t\t\t  SIP_EXPECT_MAX, sip_help_udp,",
                "\t\t\t\t  SIP_EXPECT_MAX, sip_help_tcp,"
            ],
            "deleted": [
                "\t\t\t\t  SIP_EXPECT_MAX,",
                "\t\t\t\t  sizeof(struct nf_ct_sip_master), sip_help_udp,",
                "\t\t\t\t  SIP_EXPECT_MAX,",
                "\t\t\t\t  sizeof(struct nf_ct_sip_master), sip_help_tcp,",
                "\t\t\t\t  SIP_EXPECT_MAX,",
                "\t\t\t\t  sizeof(struct nf_ct_sip_master), sip_help_udp,",
                "\t\t\t\t  SIP_EXPECT_MAX,",
                "\t\t\t\t  sizeof(struct nf_ct_sip_master), sip_help_tcp,"
            ]
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "An out-of-bounds memory write flaw was found in how the Linux kernel\u2019s Voice Over IP H.323 connection tracking functionality handled connections on ipv6 port 1720. This flaw allows an unauthenticated remote user to crash the system, causing a denial of service. The highest threat from this vulnerability is to confidentiality, integrity, as well as system availability.",
        "id": 2508
    },
    {
        "cve_id": "CVE-2020-14305",
        "code_before_change": "struct nf_conn_help *\nnf_ct_helper_ext_add(struct nf_conn *ct,\n\t\t     struct nf_conntrack_helper *helper, gfp_t gfp)\n{\n\tstruct nf_conn_help *help;\n\n\thelp = nf_ct_ext_add_length(ct, NF_CT_EXT_HELPER,\n\t\t\t\t    helper->data_len, gfp);\n\tif (help)\n\t\tINIT_HLIST_HEAD(&help->expectations);\n\telse\n\t\tpr_debug(\"failed to add helper extension area\");\n\treturn help;\n}",
        "code_after_change": "struct nf_conn_help *\nnf_ct_helper_ext_add(struct nf_conn *ct,\n\t\t     struct nf_conntrack_helper *helper, gfp_t gfp)\n{\n\tstruct nf_conn_help *help;\n\n\thelp = nf_ct_ext_add(ct, NF_CT_EXT_HELPER, gfp);\n\tif (help)\n\t\tINIT_HLIST_HEAD(&help->expectations);\n\telse\n\t\tpr_debug(\"failed to add helper extension area\");\n\treturn help;\n}",
        "patch": "--- code before\n+++ code after\n@@ -4,8 +4,7 @@\n {\n \tstruct nf_conn_help *help;\n \n-\thelp = nf_ct_ext_add_length(ct, NF_CT_EXT_HELPER,\n-\t\t\t\t    helper->data_len, gfp);\n+\thelp = nf_ct_ext_add(ct, NF_CT_EXT_HELPER, gfp);\n \tif (help)\n \t\tINIT_HLIST_HEAD(&help->expectations);\n \telse",
        "function_modified_lines": {
            "added": [
                "\thelp = nf_ct_ext_add(ct, NF_CT_EXT_HELPER, gfp);"
            ],
            "deleted": [
                "\thelp = nf_ct_ext_add_length(ct, NF_CT_EXT_HELPER,",
                "\t\t\t\t    helper->data_len, gfp);"
            ]
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "An out-of-bounds memory write flaw was found in how the Linux kernel\u2019s Voice Over IP H.323 connection tracking functionality handled connections on ipv6 port 1720. This flaw allows an unauthenticated remote user to crash the system, causing a denial of service. The highest threat from this vulnerability is to confidentiality, integrity, as well as system availability.",
        "id": 2505
    },
    {
        "cve_id": "CVE-2022-21499",
        "code_before_change": "static inline bool kdb_check_flags(kdb_cmdflags_t flags, int permissions,\n\t\t\t\t   bool no_args)\n{\n\t/* permissions comes from userspace so needs massaging slightly */\n\tpermissions &= KDB_ENABLE_MASK;\n\tpermissions |= KDB_ENABLE_ALWAYS_SAFE;\n\n\t/* some commands change group when launched with no arguments */\n\tif (no_args)\n\t\tpermissions |= permissions << KDB_ENABLE_NO_ARGS_SHIFT;\n\n\tflags |= KDB_ENABLE_ALL;\n\n\treturn permissions & flags;\n}",
        "code_after_change": "static bool kdb_check_flags(kdb_cmdflags_t flags, int permissions,\n\t\t\t\t   bool no_args)\n{\n\t/* permissions comes from userspace so needs massaging slightly */\n\tpermissions &= KDB_ENABLE_MASK;\n\tpermissions |= KDB_ENABLE_ALWAYS_SAFE;\n\n\t/* some commands change group when launched with no arguments */\n\tif (no_args)\n\t\tpermissions |= permissions << KDB_ENABLE_NO_ARGS_SHIFT;\n\n\tflags |= KDB_ENABLE_ALL;\n\n\treturn permissions & flags;\n}",
        "patch": "--- code before\n+++ code after\n@@ -1,4 +1,4 @@\n-static inline bool kdb_check_flags(kdb_cmdflags_t flags, int permissions,\n+static bool kdb_check_flags(kdb_cmdflags_t flags, int permissions,\n \t\t\t\t   bool no_args)\n {\n \t/* permissions comes from userspace so needs massaging slightly */",
        "function_modified_lines": {
            "added": [
                "static bool kdb_check_flags(kdb_cmdflags_t flags, int permissions,"
            ],
            "deleted": [
                "static inline bool kdb_check_flags(kdb_cmdflags_t flags, int permissions,"
            ]
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "KGDB and KDB allow read and write access to kernel memory, and thus should be restricted during lockdown. An attacker with access to a serial port could trigger the debugger so it is important that the debugger respect the lockdown mode when/if it is triggered. CVSS 3.1 Base Score 6.7 (Confidentiality, Integrity and Availability impacts). CVSS Vector: (CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H).",
        "id": 3410
    },
    {
        "cve_id": "CVE-2018-10882",
        "code_before_change": "static int __ext4_get_inode_loc(struct inode *inode,\n\t\t\t\tstruct ext4_iloc *iloc, int in_mem)\n{\n\tstruct ext4_group_desc\t*gdp;\n\tstruct buffer_head\t*bh;\n\tstruct super_block\t*sb = inode->i_sb;\n\text4_fsblk_t\t\tblock;\n\tint\t\t\tinodes_per_block, inode_offset;\n\n\tiloc->bh = NULL;\n\tif (!ext4_valid_inum(sb, inode->i_ino))\n\t\treturn -EFSCORRUPTED;\n\n\tiloc->block_group = (inode->i_ino - 1) / EXT4_INODES_PER_GROUP(sb);\n\tgdp = ext4_get_group_desc(sb, iloc->block_group, NULL);\n\tif (!gdp)\n\t\treturn -EIO;\n\n\t/*\n\t * Figure out the offset within the block group inode table\n\t */\n\tinodes_per_block = EXT4_SB(sb)->s_inodes_per_block;\n\tinode_offset = ((inode->i_ino - 1) %\n\t\t\tEXT4_INODES_PER_GROUP(sb));\n\tblock = ext4_inode_table(sb, gdp) + (inode_offset / inodes_per_block);\n\tiloc->offset = (inode_offset % inodes_per_block) * EXT4_INODE_SIZE(sb);\n\n\tbh = sb_getblk(sb, block);\n\tif (unlikely(!bh))\n\t\treturn -ENOMEM;\n\tif (!buffer_uptodate(bh)) {\n\t\tlock_buffer(bh);\n\n\t\t/*\n\t\t * If the buffer has the write error flag, we have failed\n\t\t * to write out another inode in the same block.  In this\n\t\t * case, we don't have to read the block because we may\n\t\t * read the old inode data successfully.\n\t\t */\n\t\tif (buffer_write_io_error(bh) && !buffer_uptodate(bh))\n\t\t\tset_buffer_uptodate(bh);\n\n\t\tif (buffer_uptodate(bh)) {\n\t\t\t/* someone brought it uptodate while we waited */\n\t\t\tunlock_buffer(bh);\n\t\t\tgoto has_buffer;\n\t\t}\n\n\t\t/*\n\t\t * If we have all information of the inode in memory and this\n\t\t * is the only valid inode in the block, we need not read the\n\t\t * block.\n\t\t */\n\t\tif (in_mem) {\n\t\t\tstruct buffer_head *bitmap_bh;\n\t\t\tint i, start;\n\n\t\t\tstart = inode_offset & ~(inodes_per_block - 1);\n\n\t\t\t/* Is the inode bitmap in cache? */\n\t\t\tbitmap_bh = sb_getblk(sb, ext4_inode_bitmap(sb, gdp));\n\t\t\tif (unlikely(!bitmap_bh))\n\t\t\t\tgoto make_io;\n\n\t\t\t/*\n\t\t\t * If the inode bitmap isn't in cache then the\n\t\t\t * optimisation may end up performing two reads instead\n\t\t\t * of one, so skip it.\n\t\t\t */\n\t\t\tif (!buffer_uptodate(bitmap_bh)) {\n\t\t\t\tbrelse(bitmap_bh);\n\t\t\t\tgoto make_io;\n\t\t\t}\n\t\t\tfor (i = start; i < start + inodes_per_block; i++) {\n\t\t\t\tif (i == inode_offset)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (ext4_test_bit(i, bitmap_bh->b_data))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbrelse(bitmap_bh);\n\t\t\tif (i == start + inodes_per_block) {\n\t\t\t\t/* all other inodes are free, so skip I/O */\n\t\t\t\tmemset(bh->b_data, 0, bh->b_size);\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tunlock_buffer(bh);\n\t\t\t\tgoto has_buffer;\n\t\t\t}\n\t\t}\n\nmake_io:\n\t\t/*\n\t\t * If we need to do any I/O, try to pre-readahead extra\n\t\t * blocks from the inode table.\n\t\t */\n\t\tif (EXT4_SB(sb)->s_inode_readahead_blks) {\n\t\t\text4_fsblk_t b, end, table;\n\t\t\tunsigned num;\n\t\t\t__u32 ra_blks = EXT4_SB(sb)->s_inode_readahead_blks;\n\n\t\t\ttable = ext4_inode_table(sb, gdp);\n\t\t\t/* s_inode_readahead_blks is always a power of 2 */\n\t\t\tb = block & ~((ext4_fsblk_t) ra_blks - 1);\n\t\t\tif (table > b)\n\t\t\t\tb = table;\n\t\t\tend = b + ra_blks;\n\t\t\tnum = EXT4_INODES_PER_GROUP(sb);\n\t\t\tif (ext4_has_group_desc_csum(sb))\n\t\t\t\tnum -= ext4_itable_unused_count(sb, gdp);\n\t\t\ttable += num / inodes_per_block;\n\t\t\tif (end > table)\n\t\t\t\tend = table;\n\t\t\twhile (b <= end)\n\t\t\t\tsb_breadahead(sb, b++);\n\t\t}\n\n\t\t/*\n\t\t * There are other valid inodes in the buffer, this inode\n\t\t * has in-inode xattrs, or we don't have this inode in memory.\n\t\t * Read the block from disk.\n\t\t */\n\t\ttrace_ext4_load_inode(inode);\n\t\tget_bh(bh);\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(REQ_OP_READ, REQ_META | REQ_PRIO, bh);\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\tEXT4_ERROR_INODE_BLOCK(inode, block,\n\t\t\t\t\t       \"unable to read itable block\");\n\t\t\tbrelse(bh);\n\t\t\treturn -EIO;\n\t\t}\n\t}\nhas_buffer:\n\tiloc->bh = bh;\n\treturn 0;\n}",
        "code_after_change": "static int __ext4_get_inode_loc(struct inode *inode,\n\t\t\t\tstruct ext4_iloc *iloc, int in_mem)\n{\n\tstruct ext4_group_desc\t*gdp;\n\tstruct buffer_head\t*bh;\n\tstruct super_block\t*sb = inode->i_sb;\n\text4_fsblk_t\t\tblock;\n\tint\t\t\tinodes_per_block, inode_offset;\n\n\tiloc->bh = NULL;\n\tif (inode->i_ino < EXT4_ROOT_INO ||\n\t    inode->i_ino > le32_to_cpu(EXT4_SB(sb)->s_es->s_inodes_count))\n\t\treturn -EFSCORRUPTED;\n\n\tiloc->block_group = (inode->i_ino - 1) / EXT4_INODES_PER_GROUP(sb);\n\tgdp = ext4_get_group_desc(sb, iloc->block_group, NULL);\n\tif (!gdp)\n\t\treturn -EIO;\n\n\t/*\n\t * Figure out the offset within the block group inode table\n\t */\n\tinodes_per_block = EXT4_SB(sb)->s_inodes_per_block;\n\tinode_offset = ((inode->i_ino - 1) %\n\t\t\tEXT4_INODES_PER_GROUP(sb));\n\tblock = ext4_inode_table(sb, gdp) + (inode_offset / inodes_per_block);\n\tiloc->offset = (inode_offset % inodes_per_block) * EXT4_INODE_SIZE(sb);\n\n\tbh = sb_getblk(sb, block);\n\tif (unlikely(!bh))\n\t\treturn -ENOMEM;\n\tif (!buffer_uptodate(bh)) {\n\t\tlock_buffer(bh);\n\n\t\t/*\n\t\t * If the buffer has the write error flag, we have failed\n\t\t * to write out another inode in the same block.  In this\n\t\t * case, we don't have to read the block because we may\n\t\t * read the old inode data successfully.\n\t\t */\n\t\tif (buffer_write_io_error(bh) && !buffer_uptodate(bh))\n\t\t\tset_buffer_uptodate(bh);\n\n\t\tif (buffer_uptodate(bh)) {\n\t\t\t/* someone brought it uptodate while we waited */\n\t\t\tunlock_buffer(bh);\n\t\t\tgoto has_buffer;\n\t\t}\n\n\t\t/*\n\t\t * If we have all information of the inode in memory and this\n\t\t * is the only valid inode in the block, we need not read the\n\t\t * block.\n\t\t */\n\t\tif (in_mem) {\n\t\t\tstruct buffer_head *bitmap_bh;\n\t\t\tint i, start;\n\n\t\t\tstart = inode_offset & ~(inodes_per_block - 1);\n\n\t\t\t/* Is the inode bitmap in cache? */\n\t\t\tbitmap_bh = sb_getblk(sb, ext4_inode_bitmap(sb, gdp));\n\t\t\tif (unlikely(!bitmap_bh))\n\t\t\t\tgoto make_io;\n\n\t\t\t/*\n\t\t\t * If the inode bitmap isn't in cache then the\n\t\t\t * optimisation may end up performing two reads instead\n\t\t\t * of one, so skip it.\n\t\t\t */\n\t\t\tif (!buffer_uptodate(bitmap_bh)) {\n\t\t\t\tbrelse(bitmap_bh);\n\t\t\t\tgoto make_io;\n\t\t\t}\n\t\t\tfor (i = start; i < start + inodes_per_block; i++) {\n\t\t\t\tif (i == inode_offset)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (ext4_test_bit(i, bitmap_bh->b_data))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbrelse(bitmap_bh);\n\t\t\tif (i == start + inodes_per_block) {\n\t\t\t\t/* all other inodes are free, so skip I/O */\n\t\t\t\tmemset(bh->b_data, 0, bh->b_size);\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tunlock_buffer(bh);\n\t\t\t\tgoto has_buffer;\n\t\t\t}\n\t\t}\n\nmake_io:\n\t\t/*\n\t\t * If we need to do any I/O, try to pre-readahead extra\n\t\t * blocks from the inode table.\n\t\t */\n\t\tif (EXT4_SB(sb)->s_inode_readahead_blks) {\n\t\t\text4_fsblk_t b, end, table;\n\t\t\tunsigned num;\n\t\t\t__u32 ra_blks = EXT4_SB(sb)->s_inode_readahead_blks;\n\n\t\t\ttable = ext4_inode_table(sb, gdp);\n\t\t\t/* s_inode_readahead_blks is always a power of 2 */\n\t\t\tb = block & ~((ext4_fsblk_t) ra_blks - 1);\n\t\t\tif (table > b)\n\t\t\t\tb = table;\n\t\t\tend = b + ra_blks;\n\t\t\tnum = EXT4_INODES_PER_GROUP(sb);\n\t\t\tif (ext4_has_group_desc_csum(sb))\n\t\t\t\tnum -= ext4_itable_unused_count(sb, gdp);\n\t\t\ttable += num / inodes_per_block;\n\t\t\tif (end > table)\n\t\t\t\tend = table;\n\t\t\twhile (b <= end)\n\t\t\t\tsb_breadahead(sb, b++);\n\t\t}\n\n\t\t/*\n\t\t * There are other valid inodes in the buffer, this inode\n\t\t * has in-inode xattrs, or we don't have this inode in memory.\n\t\t * Read the block from disk.\n\t\t */\n\t\ttrace_ext4_load_inode(inode);\n\t\tget_bh(bh);\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(REQ_OP_READ, REQ_META | REQ_PRIO, bh);\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\tEXT4_ERROR_INODE_BLOCK(inode, block,\n\t\t\t\t\t       \"unable to read itable block\");\n\t\t\tbrelse(bh);\n\t\t\treturn -EIO;\n\t\t}\n\t}\nhas_buffer:\n\tiloc->bh = bh;\n\treturn 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -8,7 +8,8 @@\n \tint\t\t\tinodes_per_block, inode_offset;\n \n \tiloc->bh = NULL;\n-\tif (!ext4_valid_inum(sb, inode->i_ino))\n+\tif (inode->i_ino < EXT4_ROOT_INO ||\n+\t    inode->i_ino > le32_to_cpu(EXT4_SB(sb)->s_es->s_inodes_count))\n \t\treturn -EFSCORRUPTED;\n \n \tiloc->block_group = (inode->i_ino - 1) / EXT4_INODES_PER_GROUP(sb);",
        "function_modified_lines": {
            "added": [
                "\tif (inode->i_ino < EXT4_ROOT_INO ||",
                "\t    inode->i_ino > le32_to_cpu(EXT4_SB(sb)->s_es->s_inodes_count))"
            ],
            "deleted": [
                "\tif (!ext4_valid_inum(sb, inode->i_ino))"
            ]
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "A flaw was found in the Linux kernel's ext4 filesystem. A local user can cause an out-of-bound write in in fs/jbd2/transaction.c code, a denial of service, and a system crash by unmounting a crafted ext4 filesystem image.",
        "id": 1616
    },
    {
        "cve_id": "CVE-2017-13166",
        "code_before_change": "static int v4l_s_fmt(const struct v4l2_ioctl_ops *ops,\n\t\t\t\tstruct file *file, void *fh, void *arg)\n{\n\tstruct v4l2_format *p = arg;\n\tstruct video_device *vfd = video_devdata(file);\n\tbool is_vid = vfd->vfl_type == VFL_TYPE_GRABBER;\n\tbool is_sdr = vfd->vfl_type == VFL_TYPE_SDR;\n\tbool is_tch = vfd->vfl_type == VFL_TYPE_TOUCH;\n\tbool is_rx = vfd->vfl_dir != VFL_DIR_TX;\n\tbool is_tx = vfd->vfl_dir != VFL_DIR_RX;\n\tint ret;\n\n\tret = v4l_enable_media_source(vfd);\n\tif (ret)\n\t\treturn ret;\n\tv4l_sanitize_format(p);\n\n\tswitch (p->type) {\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE:\n\t\tif (unlikely(!is_rx || (!is_vid && !is_tch) || !ops->vidioc_s_fmt_vid_cap))\n\t\t\tbreak;\n\t\tCLEAR_AFTER_FIELD(p, fmt.pix);\n\t\tret = ops->vidioc_s_fmt_vid_cap(file, fh, arg);\n\t\t/* just in case the driver zeroed it again */\n\t\tp->fmt.pix.priv = V4L2_PIX_FMT_PRIV_MAGIC;\n\t\tif (is_tch)\n\t\t\tv4l_pix_format_touch(&p->fmt.pix);\n\t\treturn ret;\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:\n\t\tif (unlikely(!is_rx || !is_vid || !ops->vidioc_s_fmt_vid_cap_mplane))\n\t\t\tbreak;\n\t\tCLEAR_AFTER_FIELD(p, fmt.pix_mp.xfer_func);\n\t\treturn ops->vidioc_s_fmt_vid_cap_mplane(file, fh, arg);\n\tcase V4L2_BUF_TYPE_VIDEO_OVERLAY:\n\t\tif (unlikely(!is_rx || !is_vid || !ops->vidioc_s_fmt_vid_overlay))\n\t\t\tbreak;\n\t\tCLEAR_AFTER_FIELD(p, fmt.win);\n\t\treturn ops->vidioc_s_fmt_vid_overlay(file, fh, arg);\n\tcase V4L2_BUF_TYPE_VBI_CAPTURE:\n\t\tif (unlikely(!is_rx || is_vid || !ops->vidioc_s_fmt_vbi_cap))\n\t\t\tbreak;\n\t\tCLEAR_AFTER_FIELD(p, fmt.vbi);\n\t\treturn ops->vidioc_s_fmt_vbi_cap(file, fh, arg);\n\tcase V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:\n\t\tif (unlikely(!is_rx || is_vid || !ops->vidioc_s_fmt_sliced_vbi_cap))\n\t\t\tbreak;\n\t\tCLEAR_AFTER_FIELD(p, fmt.sliced);\n\t\treturn ops->vidioc_s_fmt_sliced_vbi_cap(file, fh, arg);\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT:\n\t\tif (unlikely(!is_tx || !is_vid || !ops->vidioc_s_fmt_vid_out))\n\t\t\tbreak;\n\t\tCLEAR_AFTER_FIELD(p, fmt.pix);\n\t\tret = ops->vidioc_s_fmt_vid_out(file, fh, arg);\n\t\t/* just in case the driver zeroed it again */\n\t\tp->fmt.pix.priv = V4L2_PIX_FMT_PRIV_MAGIC;\n\t\treturn ret;\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:\n\t\tif (unlikely(!is_tx || !is_vid || !ops->vidioc_s_fmt_vid_out_mplane))\n\t\t\tbreak;\n\t\tCLEAR_AFTER_FIELD(p, fmt.pix_mp.xfer_func);\n\t\treturn ops->vidioc_s_fmt_vid_out_mplane(file, fh, arg);\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY:\n\t\tif (unlikely(!is_tx || !is_vid || !ops->vidioc_s_fmt_vid_out_overlay))\n\t\t\tbreak;\n\t\tCLEAR_AFTER_FIELD(p, fmt.win);\n\t\treturn ops->vidioc_s_fmt_vid_out_overlay(file, fh, arg);\n\tcase V4L2_BUF_TYPE_VBI_OUTPUT:\n\t\tif (unlikely(!is_tx || is_vid || !ops->vidioc_s_fmt_vbi_out))\n\t\t\tbreak;\n\t\tCLEAR_AFTER_FIELD(p, fmt.vbi);\n\t\treturn ops->vidioc_s_fmt_vbi_out(file, fh, arg);\n\tcase V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:\n\t\tif (unlikely(!is_tx || is_vid || !ops->vidioc_s_fmt_sliced_vbi_out))\n\t\t\tbreak;\n\t\tCLEAR_AFTER_FIELD(p, fmt.sliced);\n\t\treturn ops->vidioc_s_fmt_sliced_vbi_out(file, fh, arg);\n\tcase V4L2_BUF_TYPE_SDR_CAPTURE:\n\t\tif (unlikely(!is_rx || !is_sdr || !ops->vidioc_s_fmt_sdr_cap))\n\t\t\tbreak;\n\t\tCLEAR_AFTER_FIELD(p, fmt.sdr);\n\t\treturn ops->vidioc_s_fmt_sdr_cap(file, fh, arg);\n\tcase V4L2_BUF_TYPE_SDR_OUTPUT:\n\t\tif (unlikely(!is_tx || !is_sdr || !ops->vidioc_s_fmt_sdr_out))\n\t\t\tbreak;\n\t\tCLEAR_AFTER_FIELD(p, fmt.sdr);\n\t\treturn ops->vidioc_s_fmt_sdr_out(file, fh, arg);\n\tcase V4L2_BUF_TYPE_META_CAPTURE:\n\t\tif (unlikely(!is_rx || !is_vid || !ops->vidioc_s_fmt_meta_cap))\n\t\t\tbreak;\n\t\tCLEAR_AFTER_FIELD(p, fmt.meta);\n\t\treturn ops->vidioc_s_fmt_meta_cap(file, fh, arg);\n\t}\n\treturn -EINVAL;\n}",
        "code_after_change": "static int v4l_s_fmt(const struct v4l2_ioctl_ops *ops,\n\t\t\t\tstruct file *file, void *fh, void *arg)\n{\n\tstruct v4l2_format *p = arg;\n\tstruct video_device *vfd = video_devdata(file);\n\tint ret = check_fmt(file, p->type);\n\n\tif (ret)\n\t\treturn ret;\n\n\tret = v4l_enable_media_source(vfd);\n\tif (ret)\n\t\treturn ret;\n\tv4l_sanitize_format(p);\n\n\tswitch (p->type) {\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE:\n\t\tif (unlikely(!ops->vidioc_s_fmt_vid_cap))\n\t\t\tbreak;\n\t\tCLEAR_AFTER_FIELD(p, fmt.pix);\n\t\tret = ops->vidioc_s_fmt_vid_cap(file, fh, arg);\n\t\t/* just in case the driver zeroed it again */\n\t\tp->fmt.pix.priv = V4L2_PIX_FMT_PRIV_MAGIC;\n\t\tif (vfd->vfl_type == VFL_TYPE_TOUCH)\n\t\t\tv4l_pix_format_touch(&p->fmt.pix);\n\t\treturn ret;\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:\n\t\tif (unlikely(!ops->vidioc_s_fmt_vid_cap_mplane))\n\t\t\tbreak;\n\t\tCLEAR_AFTER_FIELD(p, fmt.pix_mp.xfer_func);\n\t\treturn ops->vidioc_s_fmt_vid_cap_mplane(file, fh, arg);\n\tcase V4L2_BUF_TYPE_VIDEO_OVERLAY:\n\t\tif (unlikely(!ops->vidioc_s_fmt_vid_overlay))\n\t\t\tbreak;\n\t\tCLEAR_AFTER_FIELD(p, fmt.win);\n\t\treturn ops->vidioc_s_fmt_vid_overlay(file, fh, arg);\n\tcase V4L2_BUF_TYPE_VBI_CAPTURE:\n\t\tif (unlikely(!ops->vidioc_s_fmt_vbi_cap))\n\t\t\tbreak;\n\t\tCLEAR_AFTER_FIELD(p, fmt.vbi);\n\t\treturn ops->vidioc_s_fmt_vbi_cap(file, fh, arg);\n\tcase V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:\n\t\tif (unlikely(!ops->vidioc_s_fmt_sliced_vbi_cap))\n\t\t\tbreak;\n\t\tCLEAR_AFTER_FIELD(p, fmt.sliced);\n\t\treturn ops->vidioc_s_fmt_sliced_vbi_cap(file, fh, arg);\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT:\n\t\tif (unlikely(!ops->vidioc_s_fmt_vid_out))\n\t\t\tbreak;\n\t\tCLEAR_AFTER_FIELD(p, fmt.pix);\n\t\tret = ops->vidioc_s_fmt_vid_out(file, fh, arg);\n\t\t/* just in case the driver zeroed it again */\n\t\tp->fmt.pix.priv = V4L2_PIX_FMT_PRIV_MAGIC;\n\t\treturn ret;\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:\n\t\tif (unlikely(!ops->vidioc_s_fmt_vid_out_mplane))\n\t\t\tbreak;\n\t\tCLEAR_AFTER_FIELD(p, fmt.pix_mp.xfer_func);\n\t\treturn ops->vidioc_s_fmt_vid_out_mplane(file, fh, arg);\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY:\n\t\tif (unlikely(!ops->vidioc_s_fmt_vid_out_overlay))\n\t\t\tbreak;\n\t\tCLEAR_AFTER_FIELD(p, fmt.win);\n\t\treturn ops->vidioc_s_fmt_vid_out_overlay(file, fh, arg);\n\tcase V4L2_BUF_TYPE_VBI_OUTPUT:\n\t\tif (unlikely(!ops->vidioc_s_fmt_vbi_out))\n\t\t\tbreak;\n\t\tCLEAR_AFTER_FIELD(p, fmt.vbi);\n\t\treturn ops->vidioc_s_fmt_vbi_out(file, fh, arg);\n\tcase V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:\n\t\tif (unlikely(!ops->vidioc_s_fmt_sliced_vbi_out))\n\t\t\tbreak;\n\t\tCLEAR_AFTER_FIELD(p, fmt.sliced);\n\t\treturn ops->vidioc_s_fmt_sliced_vbi_out(file, fh, arg);\n\tcase V4L2_BUF_TYPE_SDR_CAPTURE:\n\t\tif (unlikely(!ops->vidioc_s_fmt_sdr_cap))\n\t\t\tbreak;\n\t\tCLEAR_AFTER_FIELD(p, fmt.sdr);\n\t\treturn ops->vidioc_s_fmt_sdr_cap(file, fh, arg);\n\tcase V4L2_BUF_TYPE_SDR_OUTPUT:\n\t\tif (unlikely(!ops->vidioc_s_fmt_sdr_out))\n\t\t\tbreak;\n\t\tCLEAR_AFTER_FIELD(p, fmt.sdr);\n\t\treturn ops->vidioc_s_fmt_sdr_out(file, fh, arg);\n\tcase V4L2_BUF_TYPE_META_CAPTURE:\n\t\tif (unlikely(!ops->vidioc_s_fmt_meta_cap))\n\t\t\tbreak;\n\t\tCLEAR_AFTER_FIELD(p, fmt.meta);\n\t\treturn ops->vidioc_s_fmt_meta_cap(file, fh, arg);\n\t}\n\treturn -EINVAL;\n}",
        "patch": "--- code before\n+++ code after\n@@ -3,12 +3,10 @@\n {\n \tstruct v4l2_format *p = arg;\n \tstruct video_device *vfd = video_devdata(file);\n-\tbool is_vid = vfd->vfl_type == VFL_TYPE_GRABBER;\n-\tbool is_sdr = vfd->vfl_type == VFL_TYPE_SDR;\n-\tbool is_tch = vfd->vfl_type == VFL_TYPE_TOUCH;\n-\tbool is_rx = vfd->vfl_dir != VFL_DIR_TX;\n-\tbool is_tx = vfd->vfl_dir != VFL_DIR_RX;\n-\tint ret;\n+\tint ret = check_fmt(file, p->type);\n+\n+\tif (ret)\n+\t\treturn ret;\n \n \tret = v4l_enable_media_source(vfd);\n \tif (ret)\n@@ -17,37 +15,37 @@\n \n \tswitch (p->type) {\n \tcase V4L2_BUF_TYPE_VIDEO_CAPTURE:\n-\t\tif (unlikely(!is_rx || (!is_vid && !is_tch) || !ops->vidioc_s_fmt_vid_cap))\n+\t\tif (unlikely(!ops->vidioc_s_fmt_vid_cap))\n \t\t\tbreak;\n \t\tCLEAR_AFTER_FIELD(p, fmt.pix);\n \t\tret = ops->vidioc_s_fmt_vid_cap(file, fh, arg);\n \t\t/* just in case the driver zeroed it again */\n \t\tp->fmt.pix.priv = V4L2_PIX_FMT_PRIV_MAGIC;\n-\t\tif (is_tch)\n+\t\tif (vfd->vfl_type == VFL_TYPE_TOUCH)\n \t\t\tv4l_pix_format_touch(&p->fmt.pix);\n \t\treturn ret;\n \tcase V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:\n-\t\tif (unlikely(!is_rx || !is_vid || !ops->vidioc_s_fmt_vid_cap_mplane))\n+\t\tif (unlikely(!ops->vidioc_s_fmt_vid_cap_mplane))\n \t\t\tbreak;\n \t\tCLEAR_AFTER_FIELD(p, fmt.pix_mp.xfer_func);\n \t\treturn ops->vidioc_s_fmt_vid_cap_mplane(file, fh, arg);\n \tcase V4L2_BUF_TYPE_VIDEO_OVERLAY:\n-\t\tif (unlikely(!is_rx || !is_vid || !ops->vidioc_s_fmt_vid_overlay))\n+\t\tif (unlikely(!ops->vidioc_s_fmt_vid_overlay))\n \t\t\tbreak;\n \t\tCLEAR_AFTER_FIELD(p, fmt.win);\n \t\treturn ops->vidioc_s_fmt_vid_overlay(file, fh, arg);\n \tcase V4L2_BUF_TYPE_VBI_CAPTURE:\n-\t\tif (unlikely(!is_rx || is_vid || !ops->vidioc_s_fmt_vbi_cap))\n+\t\tif (unlikely(!ops->vidioc_s_fmt_vbi_cap))\n \t\t\tbreak;\n \t\tCLEAR_AFTER_FIELD(p, fmt.vbi);\n \t\treturn ops->vidioc_s_fmt_vbi_cap(file, fh, arg);\n \tcase V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:\n-\t\tif (unlikely(!is_rx || is_vid || !ops->vidioc_s_fmt_sliced_vbi_cap))\n+\t\tif (unlikely(!ops->vidioc_s_fmt_sliced_vbi_cap))\n \t\t\tbreak;\n \t\tCLEAR_AFTER_FIELD(p, fmt.sliced);\n \t\treturn ops->vidioc_s_fmt_sliced_vbi_cap(file, fh, arg);\n \tcase V4L2_BUF_TYPE_VIDEO_OUTPUT:\n-\t\tif (unlikely(!is_tx || !is_vid || !ops->vidioc_s_fmt_vid_out))\n+\t\tif (unlikely(!ops->vidioc_s_fmt_vid_out))\n \t\t\tbreak;\n \t\tCLEAR_AFTER_FIELD(p, fmt.pix);\n \t\tret = ops->vidioc_s_fmt_vid_out(file, fh, arg);\n@@ -55,37 +53,37 @@\n \t\tp->fmt.pix.priv = V4L2_PIX_FMT_PRIV_MAGIC;\n \t\treturn ret;\n \tcase V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:\n-\t\tif (unlikely(!is_tx || !is_vid || !ops->vidioc_s_fmt_vid_out_mplane))\n+\t\tif (unlikely(!ops->vidioc_s_fmt_vid_out_mplane))\n \t\t\tbreak;\n \t\tCLEAR_AFTER_FIELD(p, fmt.pix_mp.xfer_func);\n \t\treturn ops->vidioc_s_fmt_vid_out_mplane(file, fh, arg);\n \tcase V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY:\n-\t\tif (unlikely(!is_tx || !is_vid || !ops->vidioc_s_fmt_vid_out_overlay))\n+\t\tif (unlikely(!ops->vidioc_s_fmt_vid_out_overlay))\n \t\t\tbreak;\n \t\tCLEAR_AFTER_FIELD(p, fmt.win);\n \t\treturn ops->vidioc_s_fmt_vid_out_overlay(file, fh, arg);\n \tcase V4L2_BUF_TYPE_VBI_OUTPUT:\n-\t\tif (unlikely(!is_tx || is_vid || !ops->vidioc_s_fmt_vbi_out))\n+\t\tif (unlikely(!ops->vidioc_s_fmt_vbi_out))\n \t\t\tbreak;\n \t\tCLEAR_AFTER_FIELD(p, fmt.vbi);\n \t\treturn ops->vidioc_s_fmt_vbi_out(file, fh, arg);\n \tcase V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:\n-\t\tif (unlikely(!is_tx || is_vid || !ops->vidioc_s_fmt_sliced_vbi_out))\n+\t\tif (unlikely(!ops->vidioc_s_fmt_sliced_vbi_out))\n \t\t\tbreak;\n \t\tCLEAR_AFTER_FIELD(p, fmt.sliced);\n \t\treturn ops->vidioc_s_fmt_sliced_vbi_out(file, fh, arg);\n \tcase V4L2_BUF_TYPE_SDR_CAPTURE:\n-\t\tif (unlikely(!is_rx || !is_sdr || !ops->vidioc_s_fmt_sdr_cap))\n+\t\tif (unlikely(!ops->vidioc_s_fmt_sdr_cap))\n \t\t\tbreak;\n \t\tCLEAR_AFTER_FIELD(p, fmt.sdr);\n \t\treturn ops->vidioc_s_fmt_sdr_cap(file, fh, arg);\n \tcase V4L2_BUF_TYPE_SDR_OUTPUT:\n-\t\tif (unlikely(!is_tx || !is_sdr || !ops->vidioc_s_fmt_sdr_out))\n+\t\tif (unlikely(!ops->vidioc_s_fmt_sdr_out))\n \t\t\tbreak;\n \t\tCLEAR_AFTER_FIELD(p, fmt.sdr);\n \t\treturn ops->vidioc_s_fmt_sdr_out(file, fh, arg);\n \tcase V4L2_BUF_TYPE_META_CAPTURE:\n-\t\tif (unlikely(!is_rx || !is_vid || !ops->vidioc_s_fmt_meta_cap))\n+\t\tif (unlikely(!ops->vidioc_s_fmt_meta_cap))\n \t\t\tbreak;\n \t\tCLEAR_AFTER_FIELD(p, fmt.meta);\n \t\treturn ops->vidioc_s_fmt_meta_cap(file, fh, arg);",
        "function_modified_lines": {
            "added": [
                "\tint ret = check_fmt(file, p->type);",
                "",
                "\tif (ret)",
                "\t\treturn ret;",
                "\t\tif (unlikely(!ops->vidioc_s_fmt_vid_cap))",
                "\t\tif (vfd->vfl_type == VFL_TYPE_TOUCH)",
                "\t\tif (unlikely(!ops->vidioc_s_fmt_vid_cap_mplane))",
                "\t\tif (unlikely(!ops->vidioc_s_fmt_vid_overlay))",
                "\t\tif (unlikely(!ops->vidioc_s_fmt_vbi_cap))",
                "\t\tif (unlikely(!ops->vidioc_s_fmt_sliced_vbi_cap))",
                "\t\tif (unlikely(!ops->vidioc_s_fmt_vid_out))",
                "\t\tif (unlikely(!ops->vidioc_s_fmt_vid_out_mplane))",
                "\t\tif (unlikely(!ops->vidioc_s_fmt_vid_out_overlay))",
                "\t\tif (unlikely(!ops->vidioc_s_fmt_vbi_out))",
                "\t\tif (unlikely(!ops->vidioc_s_fmt_sliced_vbi_out))",
                "\t\tif (unlikely(!ops->vidioc_s_fmt_sdr_cap))",
                "\t\tif (unlikely(!ops->vidioc_s_fmt_sdr_out))",
                "\t\tif (unlikely(!ops->vidioc_s_fmt_meta_cap))"
            ],
            "deleted": [
                "\tbool is_vid = vfd->vfl_type == VFL_TYPE_GRABBER;",
                "\tbool is_sdr = vfd->vfl_type == VFL_TYPE_SDR;",
                "\tbool is_tch = vfd->vfl_type == VFL_TYPE_TOUCH;",
                "\tbool is_rx = vfd->vfl_dir != VFL_DIR_TX;",
                "\tbool is_tx = vfd->vfl_dir != VFL_DIR_RX;",
                "\tint ret;",
                "\t\tif (unlikely(!is_rx || (!is_vid && !is_tch) || !ops->vidioc_s_fmt_vid_cap))",
                "\t\tif (is_tch)",
                "\t\tif (unlikely(!is_rx || !is_vid || !ops->vidioc_s_fmt_vid_cap_mplane))",
                "\t\tif (unlikely(!is_rx || !is_vid || !ops->vidioc_s_fmt_vid_overlay))",
                "\t\tif (unlikely(!is_rx || is_vid || !ops->vidioc_s_fmt_vbi_cap))",
                "\t\tif (unlikely(!is_rx || is_vid || !ops->vidioc_s_fmt_sliced_vbi_cap))",
                "\t\tif (unlikely(!is_tx || !is_vid || !ops->vidioc_s_fmt_vid_out))",
                "\t\tif (unlikely(!is_tx || !is_vid || !ops->vidioc_s_fmt_vid_out_mplane))",
                "\t\tif (unlikely(!is_tx || !is_vid || !ops->vidioc_s_fmt_vid_out_overlay))",
                "\t\tif (unlikely(!is_tx || is_vid || !ops->vidioc_s_fmt_vbi_out))",
                "\t\tif (unlikely(!is_tx || is_vid || !ops->vidioc_s_fmt_sliced_vbi_out))",
                "\t\tif (unlikely(!is_rx || !is_sdr || !ops->vidioc_s_fmt_sdr_cap))",
                "\t\tif (unlikely(!is_tx || !is_sdr || !ops->vidioc_s_fmt_sdr_out))",
                "\t\tif (unlikely(!is_rx || !is_vid || !ops->vidioc_s_fmt_meta_cap))"
            ]
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "An elevation of privilege vulnerability in the kernel v4l2 video driver. Product: Android. Versions: Android kernel. Android ID A-34624167.",
        "id": 1268
    },
    {
        "cve_id": "CVE-2020-10742",
        "code_before_change": "ssize_t nfs_file_direct_write(struct kiocb *iocb, struct iov_iter *iter,\n\t\t\t\tloff_t pos, bool uio)\n{\n\tssize_t result = -EINVAL;\n\tstruct file *file = iocb->ki_filp;\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tstruct nfs_direct_req *dreq;\n\tstruct nfs_lock_context *l_ctx;\n\tloff_t end;\n\tsize_t count = iov_iter_count(iter);\n\tend = (pos + count - 1) >> PAGE_CACHE_SHIFT;\n\n\tnfs_add_stats(mapping->host, NFSIOS_DIRECTWRITTENBYTES, count);\n\n\tdfprintk(FILE, \"NFS: direct write(%pD2, %zd@%Ld)\\n\",\n\t\tfile, count, (long long) pos);\n\n\tresult = generic_write_checks(file, &pos, &count, 0);\n\tif (result)\n\t\tgoto out;\n\n\tresult = -EINVAL;\n\tif ((ssize_t) count < 0)\n\t\tgoto out;\n\tresult = 0;\n\tif (!count)\n\t\tgoto out;\n\n\tmutex_lock(&inode->i_mutex);\n\n\tresult = nfs_sync_mapping(mapping);\n\tif (result)\n\t\tgoto out_unlock;\n\n\tif (mapping->nrpages) {\n\t\tresult = invalidate_inode_pages2_range(mapping,\n\t\t\t\t\tpos >> PAGE_CACHE_SHIFT, end);\n\t\tif (result)\n\t\t\tgoto out_unlock;\n\t}\n\n\ttask_io_account_write(count);\n\n\tresult = -ENOMEM;\n\tdreq = nfs_direct_req_alloc();\n\tif (!dreq)\n\t\tgoto out_unlock;\n\n\tdreq->inode = inode;\n\tdreq->bytes_left = count;\n\tdreq->ctx = get_nfs_open_context(nfs_file_open_context(iocb->ki_filp));\n\tl_ctx = nfs_get_lock_context(dreq->ctx);\n\tif (IS_ERR(l_ctx)) {\n\t\tresult = PTR_ERR(l_ctx);\n\t\tgoto out_release;\n\t}\n\tdreq->l_ctx = l_ctx;\n\tif (!is_sync_kiocb(iocb))\n\t\tdreq->iocb = iocb;\n\n\tresult = nfs_direct_write_schedule_iovec(dreq, iter, pos, uio);\n\n\tif (mapping->nrpages) {\n\t\tinvalidate_inode_pages2_range(mapping,\n\t\t\t\t\t      pos >> PAGE_CACHE_SHIFT, end);\n\t}\n\n\tmutex_unlock(&inode->i_mutex);\n\n\tif (!result) {\n\t\tresult = nfs_direct_wait(dreq);\n\t\tif (result > 0) {\n\t\t\tstruct inode *inode = mapping->host;\n\n\t\t\tiocb->ki_pos = pos + result;\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tif (i_size_read(inode) < iocb->ki_pos)\n\t\t\t\ti_size_write(inode, iocb->ki_pos);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t}\n\t}\n\tnfs_direct_req_release(dreq);\n\treturn result;\n\nout_release:\n\tnfs_direct_req_release(dreq);\nout_unlock:\n\tmutex_unlock(&inode->i_mutex);\nout:\n\treturn result;\n}",
        "code_after_change": "ssize_t nfs_file_direct_write(struct kiocb *iocb, struct iov_iter *iter,\n\t\t\t\tloff_t pos, bool uio)\n{\n\tssize_t result = -EINVAL;\n\tstruct file *file = iocb->ki_filp;\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tstruct nfs_direct_req *dreq;\n\tstruct nfs_lock_context *l_ctx;\n\tloff_t end;\n\tsize_t count = iov_iter_count(iter);\n\tend = (pos + count - 1) >> PAGE_CACHE_SHIFT;\n\n\tnfs_add_stats(mapping->host, NFSIOS_DIRECTWRITTENBYTES, count);\n\n\tdfprintk(FILE, \"NFS: direct write(%pD2, %zd@%Ld)\\n\",\n\t\tfile, count, (long long) pos);\n\n\tresult = generic_write_checks(file, &pos, &count, 0);\n\tif (result)\n\t\tgoto out;\n\n\tresult = -EINVAL;\n\tif ((ssize_t) count < 0)\n\t\tgoto out;\n\tresult = 0;\n\tif (!count)\n\t\tgoto out;\n\n\tmutex_lock(&inode->i_mutex);\n\n\tresult = nfs_sync_mapping(mapping);\n\tif (result)\n\t\tgoto out_unlock;\n\n\tif (mapping->nrpages) {\n\t\tresult = invalidate_inode_pages2_range(mapping,\n\t\t\t\t\tpos >> PAGE_CACHE_SHIFT, end);\n\t\tif (result)\n\t\t\tgoto out_unlock;\n\t}\n\n\ttask_io_account_write(count);\n\n\tresult = -ENOMEM;\n\tdreq = nfs_direct_req_alloc();\n\tif (!dreq)\n\t\tgoto out_unlock;\n\n\tdreq->inode = inode;\n\tdreq->bytes_left = count;\n\tdreq->ctx = get_nfs_open_context(nfs_file_open_context(iocb->ki_filp));\n\tl_ctx = nfs_get_lock_context(dreq->ctx);\n\tif (IS_ERR(l_ctx)) {\n\t\tresult = PTR_ERR(l_ctx);\n\t\tgoto out_release;\n\t}\n\tdreq->l_ctx = l_ctx;\n\tif (!is_sync_kiocb(iocb))\n\t\tdreq->iocb = iocb;\n\n\tresult = nfs_direct_write_schedule_iovec(dreq, iter, pos);\n\n\tif (mapping->nrpages) {\n\t\tinvalidate_inode_pages2_range(mapping,\n\t\t\t\t\t      pos >> PAGE_CACHE_SHIFT, end);\n\t}\n\n\tmutex_unlock(&inode->i_mutex);\n\n\tif (!result) {\n\t\tresult = nfs_direct_wait(dreq);\n\t\tif (result > 0) {\n\t\t\tstruct inode *inode = mapping->host;\n\n\t\t\tiocb->ki_pos = pos + result;\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tif (i_size_read(inode) < iocb->ki_pos)\n\t\t\t\ti_size_write(inode, iocb->ki_pos);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t}\n\t}\n\tnfs_direct_req_release(dreq);\n\treturn result;\n\nout_release:\n\tnfs_direct_req_release(dreq);\nout_unlock:\n\tmutex_unlock(&inode->i_mutex);\nout:\n\treturn result;\n}",
        "patch": "--- code before\n+++ code after\n@@ -59,7 +59,7 @@\n \tif (!is_sync_kiocb(iocb))\n \t\tdreq->iocb = iocb;\n \n-\tresult = nfs_direct_write_schedule_iovec(dreq, iter, pos, uio);\n+\tresult = nfs_direct_write_schedule_iovec(dreq, iter, pos);\n \n \tif (mapping->nrpages) {\n \t\tinvalidate_inode_pages2_range(mapping,",
        "function_modified_lines": {
            "added": [
                "\tresult = nfs_direct_write_schedule_iovec(dreq, iter, pos);"
            ],
            "deleted": [
                "\tresult = nfs_direct_write_schedule_iovec(dreq, iter, pos, uio);"
            ]
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "A flaw was found in the Linux kernel. An index buffer overflow during Direct IO write leading to the NFS client to crash. In some cases, a reach out of the index after one memory allocation by kmalloc will cause a kernel panic. The highest threat from this vulnerability is to data confidentiality and system availability.",
        "id": 2412
    },
    {
        "cve_id": "CVE-2017-17806",
        "code_before_change": "static int shash_no_setkey(struct crypto_shash *tfm, const u8 *key,\n\t\t\t   unsigned int keylen)\n{\n\treturn -ENOSYS;\n}",
        "code_after_change": "int shash_no_setkey(struct crypto_shash *tfm, const u8 *key,\n\t\t    unsigned int keylen)\n{\n\treturn -ENOSYS;\n}",
        "patch": "--- code before\n+++ code after\n@@ -1,5 +1,5 @@\n-static int shash_no_setkey(struct crypto_shash *tfm, const u8 *key,\n-\t\t\t   unsigned int keylen)\n+int shash_no_setkey(struct crypto_shash *tfm, const u8 *key,\n+\t\t    unsigned int keylen)\n {\n \treturn -ENOSYS;\n }",
        "function_modified_lines": {
            "added": [
                "int shash_no_setkey(struct crypto_shash *tfm, const u8 *key,",
                "\t\t    unsigned int keylen)"
            ],
            "deleted": [
                "static int shash_no_setkey(struct crypto_shash *tfm, const u8 *key,",
                "\t\t\t   unsigned int keylen)"
            ]
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "The HMAC implementation (crypto/hmac.c) in the Linux kernel before 4.14.8 does not validate that the underlying cryptographic hash algorithm is unkeyed, allowing a local attacker able to use the AF_ALG-based hash interface (CONFIG_CRYPTO_USER_API_HASH) and the SHA-3 hash algorithm (CONFIG_CRYPTO_SHA3) to cause a kernel stack buffer overflow by executing a crafted sequence of system calls that encounter a missing SHA-3 initialization.",
        "id": 1376
    },
    {
        "cve_id": "CVE-2019-19332",
        "code_before_change": "static int do_cpuid_func(struct kvm_cpuid_entry2 *entry, u32 func,\n\t\t\t int *nent, int maxnent, unsigned int type)\n{\n\tif (type == KVM_GET_EMULATED_CPUID)\n\t\treturn __do_cpuid_func_emulated(entry, func, nent, maxnent);\n\n\treturn __do_cpuid_func(entry, func, nent, maxnent);\n}",
        "code_after_change": "static int do_cpuid_func(struct kvm_cpuid_entry2 *entry, u32 func,\n\t\t\t int *nent, int maxnent, unsigned int type)\n{\n\tif (*nent >= maxnent)\n\t\treturn -E2BIG;\n\n\tif (type == KVM_GET_EMULATED_CPUID)\n\t\treturn __do_cpuid_func_emulated(entry, func, nent, maxnent);\n\n\treturn __do_cpuid_func(entry, func, nent, maxnent);\n}",
        "patch": "--- code before\n+++ code after\n@@ -1,6 +1,9 @@\n static int do_cpuid_func(struct kvm_cpuid_entry2 *entry, u32 func,\n \t\t\t int *nent, int maxnent, unsigned int type)\n {\n+\tif (*nent >= maxnent)\n+\t\treturn -E2BIG;\n+\n \tif (type == KVM_GET_EMULATED_CPUID)\n \t\treturn __do_cpuid_func_emulated(entry, func, nent, maxnent);\n ",
        "function_modified_lines": {
            "added": [
                "\tif (*nent >= maxnent)",
                "\t\treturn -E2BIG;",
                ""
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "An out-of-bounds memory write issue was found in the Linux Kernel, version 3.13 through 5.4, in the way the Linux kernel's KVM hypervisor handled the 'KVM_GET_EMULATED_CPUID' ioctl(2) request to get CPUID features emulated by the KVM hypervisor. A user or process able to access the '/dev/kvm' device could use this flaw to crash the system, resulting in a denial of service.",
        "id": 2191
    },
    {
        "cve_id": "CVE-2023-5717",
        "code_before_change": "static int inherit_group(struct perf_event *parent_event,\n\t      struct task_struct *parent,\n\t      struct perf_event_context *parent_ctx,\n\t      struct task_struct *child,\n\t      struct perf_event_context *child_ctx)\n{\n\tstruct perf_event *leader;\n\tstruct perf_event *sub;\n\tstruct perf_event *child_ctr;\n\n\tleader = inherit_event(parent_event, parent, parent_ctx,\n\t\t\t\t child, NULL, child_ctx);\n\tif (IS_ERR(leader))\n\t\treturn PTR_ERR(leader);\n\t/*\n\t * @leader can be NULL here because of is_orphaned_event(). In this\n\t * case inherit_event() will create individual events, similar to what\n\t * perf_group_detach() would do anyway.\n\t */\n\tfor_each_sibling_event(sub, parent_event) {\n\t\tchild_ctr = inherit_event(sub, parent, parent_ctx,\n\t\t\t\t\t    child, leader, child_ctx);\n\t\tif (IS_ERR(child_ctr))\n\t\t\treturn PTR_ERR(child_ctr);\n\n\t\tif (sub->aux_event == parent_event && child_ctr &&\n\t\t    !perf_get_aux_event(child_ctr, leader))\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}",
        "code_after_change": "static int inherit_group(struct perf_event *parent_event,\n\t      struct task_struct *parent,\n\t      struct perf_event_context *parent_ctx,\n\t      struct task_struct *child,\n\t      struct perf_event_context *child_ctx)\n{\n\tstruct perf_event *leader;\n\tstruct perf_event *sub;\n\tstruct perf_event *child_ctr;\n\n\tleader = inherit_event(parent_event, parent, parent_ctx,\n\t\t\t\t child, NULL, child_ctx);\n\tif (IS_ERR(leader))\n\t\treturn PTR_ERR(leader);\n\t/*\n\t * @leader can be NULL here because of is_orphaned_event(). In this\n\t * case inherit_event() will create individual events, similar to what\n\t * perf_group_detach() would do anyway.\n\t */\n\tfor_each_sibling_event(sub, parent_event) {\n\t\tchild_ctr = inherit_event(sub, parent, parent_ctx,\n\t\t\t\t\t    child, leader, child_ctx);\n\t\tif (IS_ERR(child_ctr))\n\t\t\treturn PTR_ERR(child_ctr);\n\n\t\tif (sub->aux_event == parent_event && child_ctr &&\n\t\t    !perf_get_aux_event(child_ctr, leader))\n\t\t\treturn -EINVAL;\n\t}\n\tleader->group_generation = parent_event->group_generation;\n\treturn 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -27,5 +27,6 @@\n \t\t    !perf_get_aux_event(child_ctr, leader))\n \t\t\treturn -EINVAL;\n \t}\n+\tleader->group_generation = parent_event->group_generation;\n \treturn 0;\n }",
        "function_modified_lines": {
            "added": [
                "\tleader->group_generation = parent_event->group_generation;"
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "A heap out-of-bounds write vulnerability in the Linux kernel's Linux Kernel Performance Events (perf) component can be exploited to achieve local privilege escalation.\n\nIf perf_read_group() is called while an event's sibling_list is smaller than its child's sibling_list, it can increment or write to memory locations outside of the allocated buffer.\n\nWe recommend upgrading past commit 32671e3799ca2e4590773fd0e63aaa4229e50c06.\n\n",
        "id": 4291
    },
    {
        "cve_id": "CVE-2023-5717",
        "code_before_change": "static int perf_read_group(struct perf_event *event,\n\t\t\t\t   u64 read_format, char __user *buf)\n{\n\tstruct perf_event *leader = event->group_leader, *child;\n\tstruct perf_event_context *ctx = leader->ctx;\n\tint ret;\n\tu64 *values;\n\n\tlockdep_assert_held(&ctx->mutex);\n\n\tvalues = kzalloc(event->read_size, GFP_KERNEL);\n\tif (!values)\n\t\treturn -ENOMEM;\n\n\tvalues[0] = 1 + leader->nr_siblings;\n\n\t/*\n\t * By locking the child_mutex of the leader we effectively\n\t * lock the child list of all siblings.. XXX explain how.\n\t */\n\tmutex_lock(&leader->child_mutex);\n\n\tret = __perf_read_group_add(leader, read_format, values);\n\tif (ret)\n\t\tgoto unlock;\n\n\tlist_for_each_entry(child, &leader->child_list, child_list) {\n\t\tret = __perf_read_group_add(child, read_format, values);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\t}\n\n\tmutex_unlock(&leader->child_mutex);\n\n\tret = event->read_size;\n\tif (copy_to_user(buf, values, event->read_size))\n\t\tret = -EFAULT;\n\tgoto out;\n\nunlock:\n\tmutex_unlock(&leader->child_mutex);\nout:\n\tkfree(values);\n\treturn ret;\n}",
        "code_after_change": "static int perf_read_group(struct perf_event *event,\n\t\t\t\t   u64 read_format, char __user *buf)\n{\n\tstruct perf_event *leader = event->group_leader, *child;\n\tstruct perf_event_context *ctx = leader->ctx;\n\tint ret;\n\tu64 *values;\n\n\tlockdep_assert_held(&ctx->mutex);\n\n\tvalues = kzalloc(event->read_size, GFP_KERNEL);\n\tif (!values)\n\t\treturn -ENOMEM;\n\n\tvalues[0] = 1 + leader->nr_siblings;\n\n\tmutex_lock(&leader->child_mutex);\n\n\tret = __perf_read_group_add(leader, read_format, values);\n\tif (ret)\n\t\tgoto unlock;\n\n\tlist_for_each_entry(child, &leader->child_list, child_list) {\n\t\tret = __perf_read_group_add(child, read_format, values);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\t}\n\n\tmutex_unlock(&leader->child_mutex);\n\n\tret = event->read_size;\n\tif (copy_to_user(buf, values, event->read_size))\n\t\tret = -EFAULT;\n\tgoto out;\n\nunlock:\n\tmutex_unlock(&leader->child_mutex);\nout:\n\tkfree(values);\n\treturn ret;\n}",
        "patch": "--- code before\n+++ code after\n@@ -14,10 +14,6 @@\n \n \tvalues[0] = 1 + leader->nr_siblings;\n \n-\t/*\n-\t * By locking the child_mutex of the leader we effectively\n-\t * lock the child list of all siblings.. XXX explain how.\n-\t */\n \tmutex_lock(&leader->child_mutex);\n \n \tret = __perf_read_group_add(leader, read_format, values);",
        "function_modified_lines": {
            "added": [],
            "deleted": [
                "\t/*",
                "\t * By locking the child_mutex of the leader we effectively",
                "\t * lock the child list of all siblings.. XXX explain how.",
                "\t */"
            ]
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "A heap out-of-bounds write vulnerability in the Linux kernel's Linux Kernel Performance Events (perf) component can be exploited to achieve local privilege escalation.\n\nIf perf_read_group() is called while an event's sibling_list is smaller than its child's sibling_list, it can increment or write to memory locations outside of the allocated buffer.\n\nWe recommend upgrading past commit 32671e3799ca2e4590773fd0e63aaa4229e50c06.\n\n",
        "id": 4290
    },
    {
        "cve_id": "CVE-2019-20636",
        "code_before_change": "static int input_default_setkeycode(struct input_dev *dev,\n\t\t\t\t    const struct input_keymap_entry *ke,\n\t\t\t\t    unsigned int *old_keycode)\n{\n\tunsigned int index;\n\tint error;\n\tint i;\n\n\tif (!dev->keycodesize)\n\t\treturn -EINVAL;\n\n\tif (ke->flags & INPUT_KEYMAP_BY_INDEX) {\n\t\tindex = ke->index;\n\t} else {\n\t\terror = input_scancode_to_scalar(ke, &index);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tif (index >= dev->keycodemax)\n\t\treturn -EINVAL;\n\n\tif (dev->keycodesize < sizeof(ke->keycode) &&\n\t\t\t(ke->keycode >> (dev->keycodesize * 8)))\n\t\treturn -EINVAL;\n\n\tswitch (dev->keycodesize) {\n\t\tcase 1: {\n\t\t\tu8 *k = (u8 *)dev->keycode;\n\t\t\t*old_keycode = k[index];\n\t\t\tk[index] = ke->keycode;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2: {\n\t\t\tu16 *k = (u16 *)dev->keycode;\n\t\t\t*old_keycode = k[index];\n\t\t\tk[index] = ke->keycode;\n\t\t\tbreak;\n\t\t}\n\t\tdefault: {\n\t\t\tu32 *k = (u32 *)dev->keycode;\n\t\t\t*old_keycode = k[index];\n\t\t\tk[index] = ke->keycode;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t__clear_bit(*old_keycode, dev->keybit);\n\t__set_bit(ke->keycode, dev->keybit);\n\n\tfor (i = 0; i < dev->keycodemax; i++) {\n\t\tif (input_fetch_keycode(dev, i) == *old_keycode) {\n\t\t\t__set_bit(*old_keycode, dev->keybit);\n\t\t\tbreak; /* Setting the bit twice is useless, so break */\n\t\t}\n\t}\n\n\treturn 0;\n}",
        "code_after_change": "static int input_default_setkeycode(struct input_dev *dev,\n\t\t\t\t    const struct input_keymap_entry *ke,\n\t\t\t\t    unsigned int *old_keycode)\n{\n\tunsigned int index;\n\tint error;\n\tint i;\n\n\tif (!dev->keycodesize)\n\t\treturn -EINVAL;\n\n\tif (ke->flags & INPUT_KEYMAP_BY_INDEX) {\n\t\tindex = ke->index;\n\t} else {\n\t\terror = input_scancode_to_scalar(ke, &index);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tif (index >= dev->keycodemax)\n\t\treturn -EINVAL;\n\n\tif (dev->keycodesize < sizeof(ke->keycode) &&\n\t\t\t(ke->keycode >> (dev->keycodesize * 8)))\n\t\treturn -EINVAL;\n\n\tswitch (dev->keycodesize) {\n\t\tcase 1: {\n\t\t\tu8 *k = (u8 *)dev->keycode;\n\t\t\t*old_keycode = k[index];\n\t\t\tk[index] = ke->keycode;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2: {\n\t\t\tu16 *k = (u16 *)dev->keycode;\n\t\t\t*old_keycode = k[index];\n\t\t\tk[index] = ke->keycode;\n\t\t\tbreak;\n\t\t}\n\t\tdefault: {\n\t\t\tu32 *k = (u32 *)dev->keycode;\n\t\t\t*old_keycode = k[index];\n\t\t\tk[index] = ke->keycode;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (*old_keycode <= KEY_MAX) {\n\t\t__clear_bit(*old_keycode, dev->keybit);\n\t\tfor (i = 0; i < dev->keycodemax; i++) {\n\t\t\tif (input_fetch_keycode(dev, i) == *old_keycode) {\n\t\t\t\t__set_bit(*old_keycode, dev->keybit);\n\t\t\t\t/* Setting the bit twice is useless, so break */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t__set_bit(ke->keycode, dev->keybit);\n\treturn 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -45,15 +45,17 @@\n \t\t}\n \t}\n \n-\t__clear_bit(*old_keycode, dev->keybit);\n-\t__set_bit(ke->keycode, dev->keybit);\n-\n-\tfor (i = 0; i < dev->keycodemax; i++) {\n-\t\tif (input_fetch_keycode(dev, i) == *old_keycode) {\n-\t\t\t__set_bit(*old_keycode, dev->keybit);\n-\t\t\tbreak; /* Setting the bit twice is useless, so break */\n+\tif (*old_keycode <= KEY_MAX) {\n+\t\t__clear_bit(*old_keycode, dev->keybit);\n+\t\tfor (i = 0; i < dev->keycodemax; i++) {\n+\t\t\tif (input_fetch_keycode(dev, i) == *old_keycode) {\n+\t\t\t\t__set_bit(*old_keycode, dev->keybit);\n+\t\t\t\t/* Setting the bit twice is useless, so break */\n+\t\t\t\tbreak;\n+\t\t\t}\n \t\t}\n \t}\n \n+\t__set_bit(ke->keycode, dev->keybit);\n \treturn 0;\n }",
        "function_modified_lines": {
            "added": [
                "\tif (*old_keycode <= KEY_MAX) {",
                "\t\t__clear_bit(*old_keycode, dev->keybit);",
                "\t\tfor (i = 0; i < dev->keycodemax; i++) {",
                "\t\t\tif (input_fetch_keycode(dev, i) == *old_keycode) {",
                "\t\t\t\t__set_bit(*old_keycode, dev->keybit);",
                "\t\t\t\t/* Setting the bit twice is useless, so break */",
                "\t\t\t\tbreak;",
                "\t\t\t}",
                "\t__set_bit(ke->keycode, dev->keybit);"
            ],
            "deleted": [
                "\t__clear_bit(*old_keycode, dev->keybit);",
                "\t__set_bit(ke->keycode, dev->keybit);",
                "",
                "\tfor (i = 0; i < dev->keycodemax; i++) {",
                "\t\tif (input_fetch_keycode(dev, i) == *old_keycode) {",
                "\t\t\t__set_bit(*old_keycode, dev->keybit);",
                "\t\t\tbreak; /* Setting the bit twice is useless, so break */"
            ]
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "In the Linux kernel before 5.4.12, drivers/input/input.c has out-of-bounds writes via a crafted keycode table, as demonstrated by input_set_keycode, aka CID-cb222aed03d7.",
        "id": 2282
    },
    {
        "cve_id": "CVE-2023-45863",
        "code_before_change": "static void fill_kobj_path(const struct kobject *kobj, char *path, int length)\n{\n\tconst struct kobject *parent;\n\n\t--length;\n\tfor (parent = kobj; parent; parent = parent->parent) {\n\t\tint cur = strlen(kobject_name(parent));\n\t\t/* back up enough to print this name with '/' */\n\t\tlength -= cur;\n\t\tmemcpy(path + length, kobject_name(parent), cur);\n\t\t*(path + --length) = '/';\n\t}\n\n\tpr_debug(\"kobject: '%s' (%p): %s: path = '%s'\\n\", kobject_name(kobj),\n\t\t kobj, __func__, path);\n}",
        "code_after_change": "static int fill_kobj_path(const struct kobject *kobj, char *path, int length)\n{\n\tconst struct kobject *parent;\n\n\t--length;\n\tfor (parent = kobj; parent; parent = parent->parent) {\n\t\tint cur = strlen(kobject_name(parent));\n\t\t/* back up enough to print this name with '/' */\n\t\tlength -= cur;\n\t\tif (length <= 0)\n\t\t\treturn -EINVAL;\n\t\tmemcpy(path + length, kobject_name(parent), cur);\n\t\t*(path + --length) = '/';\n\t}\n\n\tpr_debug(\"kobject: '%s' (%p): %s: path = '%s'\\n\", kobject_name(kobj),\n\t\t kobj, __func__, path);\n\n\treturn 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -1,4 +1,4 @@\n-static void fill_kobj_path(const struct kobject *kobj, char *path, int length)\n+static int fill_kobj_path(const struct kobject *kobj, char *path, int length)\n {\n \tconst struct kobject *parent;\n \n@@ -7,10 +7,14 @@\n \t\tint cur = strlen(kobject_name(parent));\n \t\t/* back up enough to print this name with '/' */\n \t\tlength -= cur;\n+\t\tif (length <= 0)\n+\t\t\treturn -EINVAL;\n \t\tmemcpy(path + length, kobject_name(parent), cur);\n \t\t*(path + --length) = '/';\n \t}\n \n \tpr_debug(\"kobject: '%s' (%p): %s: path = '%s'\\n\", kobject_name(kobj),\n \t\t kobj, __func__, path);\n+\n+\treturn 0;\n }",
        "function_modified_lines": {
            "added": [
                "static int fill_kobj_path(const struct kobject *kobj, char *path, int length)",
                "\t\tif (length <= 0)",
                "\t\t\treturn -EINVAL;",
                "",
                "\treturn 0;"
            ],
            "deleted": [
                "static void fill_kobj_path(const struct kobject *kobj, char *path, int length)"
            ]
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "An issue was discovered in lib/kobject.c in the Linux kernel before 6.2.3. With root access, an attacker can trigger a race condition that results in a fill_kobj_path out-of-bounds write.",
        "id": 4225
    },
    {
        "cve_id": "CVE-2018-16880",
        "code_before_change": "static long vhost_dev_alloc_iovecs(struct vhost_dev *dev)\n{\n\tstruct vhost_virtqueue *vq;\n\tint i;\n\n\tfor (i = 0; i < dev->nvqs; ++i) {\n\t\tvq = dev->vqs[i];\n\t\tvq->indirect = kmalloc_array(UIO_MAXIOV,\n\t\t\t\t\t     sizeof(*vq->indirect),\n\t\t\t\t\t     GFP_KERNEL);\n\t\tvq->log = kmalloc_array(UIO_MAXIOV, sizeof(*vq->log),\n\t\t\t\t\tGFP_KERNEL);\n\t\tvq->heads = kmalloc_array(UIO_MAXIOV, sizeof(*vq->heads),\n\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!vq->indirect || !vq->log || !vq->heads)\n\t\t\tgoto err_nomem;\n\t}\n\treturn 0;\n\nerr_nomem:\n\tfor (; i >= 0; --i)\n\t\tvhost_vq_free_iovecs(dev->vqs[i]);\n\treturn -ENOMEM;\n}",
        "code_after_change": "static long vhost_dev_alloc_iovecs(struct vhost_dev *dev)\n{\n\tstruct vhost_virtqueue *vq;\n\tint i;\n\n\tfor (i = 0; i < dev->nvqs; ++i) {\n\t\tvq = dev->vqs[i];\n\t\tvq->indirect = kmalloc_array(UIO_MAXIOV,\n\t\t\t\t\t     sizeof(*vq->indirect),\n\t\t\t\t\t     GFP_KERNEL);\n\t\tvq->log = kmalloc_array(dev->iov_limit, sizeof(*vq->log),\n\t\t\t\t\tGFP_KERNEL);\n\t\tvq->heads = kmalloc_array(dev->iov_limit, sizeof(*vq->heads),\n\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!vq->indirect || !vq->log || !vq->heads)\n\t\t\tgoto err_nomem;\n\t}\n\treturn 0;\n\nerr_nomem:\n\tfor (; i >= 0; --i)\n\t\tvhost_vq_free_iovecs(dev->vqs[i]);\n\treturn -ENOMEM;\n}",
        "patch": "--- code before\n+++ code after\n@@ -8,9 +8,9 @@\n \t\tvq->indirect = kmalloc_array(UIO_MAXIOV,\n \t\t\t\t\t     sizeof(*vq->indirect),\n \t\t\t\t\t     GFP_KERNEL);\n-\t\tvq->log = kmalloc_array(UIO_MAXIOV, sizeof(*vq->log),\n+\t\tvq->log = kmalloc_array(dev->iov_limit, sizeof(*vq->log),\n \t\t\t\t\tGFP_KERNEL);\n-\t\tvq->heads = kmalloc_array(UIO_MAXIOV, sizeof(*vq->heads),\n+\t\tvq->heads = kmalloc_array(dev->iov_limit, sizeof(*vq->heads),\n \t\t\t\t\t  GFP_KERNEL);\n \t\tif (!vq->indirect || !vq->log || !vq->heads)\n \t\t\tgoto err_nomem;",
        "function_modified_lines": {
            "added": [
                "\t\tvq->log = kmalloc_array(dev->iov_limit, sizeof(*vq->log),",
                "\t\tvq->heads = kmalloc_array(dev->iov_limit, sizeof(*vq->heads),"
            ],
            "deleted": [
                "\t\tvq->log = kmalloc_array(UIO_MAXIOV, sizeof(*vq->log),",
                "\t\tvq->heads = kmalloc_array(UIO_MAXIOV, sizeof(*vq->heads),"
            ]
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "A flaw was found in the Linux kernel's handle_rx() function in the [vhost_net] driver. A malicious virtual guest, under specific conditions, can trigger an out-of-bounds write in a kmalloc-8 slab on a virtual host which may lead to a kernel memory corruption and a system panic. Due to the nature of the flaw, privilege escalation cannot be fully ruled out. Versions from v4.16 and newer are vulnerable.",
        "id": 1719
    },
    {
        "cve_id": "CVE-2018-16880",
        "code_before_change": "static int vhost_vsock_dev_open(struct inode *inode, struct file *file)\n{\n\tstruct vhost_virtqueue **vqs;\n\tstruct vhost_vsock *vsock;\n\tint ret;\n\n\t/* This struct is large and allocation could fail, fall back to vmalloc\n\t * if there is no other way.\n\t */\n\tvsock = kvmalloc(sizeof(*vsock), GFP_KERNEL | __GFP_RETRY_MAYFAIL);\n\tif (!vsock)\n\t\treturn -ENOMEM;\n\n\tvqs = kmalloc_array(ARRAY_SIZE(vsock->vqs), sizeof(*vqs), GFP_KERNEL);\n\tif (!vqs) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tvsock->guest_cid = 0; /* no CID assigned yet */\n\n\tatomic_set(&vsock->queued_replies, 0);\n\n\tvqs[VSOCK_VQ_TX] = &vsock->vqs[VSOCK_VQ_TX];\n\tvqs[VSOCK_VQ_RX] = &vsock->vqs[VSOCK_VQ_RX];\n\tvsock->vqs[VSOCK_VQ_TX].handle_kick = vhost_vsock_handle_tx_kick;\n\tvsock->vqs[VSOCK_VQ_RX].handle_kick = vhost_vsock_handle_rx_kick;\n\n\tvhost_dev_init(&vsock->dev, vqs, ARRAY_SIZE(vsock->vqs));\n\n\tfile->private_data = vsock;\n\tspin_lock_init(&vsock->send_pkt_list_lock);\n\tINIT_LIST_HEAD(&vsock->send_pkt_list);\n\tvhost_work_init(&vsock->send_pkt_work, vhost_transport_send_pkt_work);\n\treturn 0;\n\nout:\n\tvhost_vsock_free(vsock);\n\treturn ret;\n}",
        "code_after_change": "static int vhost_vsock_dev_open(struct inode *inode, struct file *file)\n{\n\tstruct vhost_virtqueue **vqs;\n\tstruct vhost_vsock *vsock;\n\tint ret;\n\n\t/* This struct is large and allocation could fail, fall back to vmalloc\n\t * if there is no other way.\n\t */\n\tvsock = kvmalloc(sizeof(*vsock), GFP_KERNEL | __GFP_RETRY_MAYFAIL);\n\tif (!vsock)\n\t\treturn -ENOMEM;\n\n\tvqs = kmalloc_array(ARRAY_SIZE(vsock->vqs), sizeof(*vqs), GFP_KERNEL);\n\tif (!vqs) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tvsock->guest_cid = 0; /* no CID assigned yet */\n\n\tatomic_set(&vsock->queued_replies, 0);\n\n\tvqs[VSOCK_VQ_TX] = &vsock->vqs[VSOCK_VQ_TX];\n\tvqs[VSOCK_VQ_RX] = &vsock->vqs[VSOCK_VQ_RX];\n\tvsock->vqs[VSOCK_VQ_TX].handle_kick = vhost_vsock_handle_tx_kick;\n\tvsock->vqs[VSOCK_VQ_RX].handle_kick = vhost_vsock_handle_rx_kick;\n\n\tvhost_dev_init(&vsock->dev, vqs, ARRAY_SIZE(vsock->vqs), UIO_MAXIOV);\n\n\tfile->private_data = vsock;\n\tspin_lock_init(&vsock->send_pkt_list_lock);\n\tINIT_LIST_HEAD(&vsock->send_pkt_list);\n\tvhost_work_init(&vsock->send_pkt_work, vhost_transport_send_pkt_work);\n\treturn 0;\n\nout:\n\tvhost_vsock_free(vsock);\n\treturn ret;\n}",
        "patch": "--- code before\n+++ code after\n@@ -26,7 +26,7 @@\n \tvsock->vqs[VSOCK_VQ_TX].handle_kick = vhost_vsock_handle_tx_kick;\n \tvsock->vqs[VSOCK_VQ_RX].handle_kick = vhost_vsock_handle_rx_kick;\n \n-\tvhost_dev_init(&vsock->dev, vqs, ARRAY_SIZE(vsock->vqs));\n+\tvhost_dev_init(&vsock->dev, vqs, ARRAY_SIZE(vsock->vqs), UIO_MAXIOV);\n \n \tfile->private_data = vsock;\n \tspin_lock_init(&vsock->send_pkt_list_lock);",
        "function_modified_lines": {
            "added": [
                "\tvhost_dev_init(&vsock->dev, vqs, ARRAY_SIZE(vsock->vqs), UIO_MAXIOV);"
            ],
            "deleted": [
                "\tvhost_dev_init(&vsock->dev, vqs, ARRAY_SIZE(vsock->vqs));"
            ]
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "A flaw was found in the Linux kernel's handle_rx() function in the [vhost_net] driver. A malicious virtual guest, under specific conditions, can trigger an out-of-bounds write in a kmalloc-8 slab on a virtual host which may lead to a kernel memory corruption and a system panic. Due to the nature of the flaw, privilege escalation cannot be fully ruled out. Versions from v4.16 and newer are vulnerable.",
        "id": 1720
    },
    {
        "cve_id": "CVE-2020-0432",
        "code_before_change": "static int skb_to_mep(const struct sk_buff *skb, struct mbo *mbo)\n{\n\tu8 *buff = mbo->virt_address;\n\tunsigned int mep_len = skb->len + MEP_HDR_LEN;\n\n\tif (mbo->buffer_length < mep_len) {\n\t\tpr_err(\"drop: too small buffer! (%d for %d)\\n\",\n\t\t       mbo->buffer_length, mep_len);\n\t\treturn -EINVAL;\n\t}\n\n\t*buff++ = HB(mep_len - 2);\n\t*buff++ = LB(mep_len - 2);\n\n\t*buff++ = PMHL;\n\t*buff++ = (PMS_FIFONO_MEP << PMS_FIFONO_SHIFT) | PMS_MSGTYPE_DATA;\n\t*buff++ = (MEP_DEF_RETRY << PMS_RETRY_SHIFT) | PMS_DEF_PRIO;\n\t*buff++ = 0;\n\t*buff++ = 0;\n\t*buff++ = 0;\n\n\tmemcpy(buff, skb->data, skb->len);\n\tmbo->buffer_length = mep_len;\n\treturn 0;\n}",
        "code_after_change": "static int skb_to_mep(const struct sk_buff *skb, struct mbo *mbo)\n{\n\tu8 *buff = mbo->virt_address;\n\tunsigned int mep_len = skb->len + MEP_HDR_LEN;\n\n\tif (mep_len < skb->len) {\n\t\tpr_err(\"drop: too large packet! (%u)\\n\", skb->len);\n\t\treturn -EINVAL;\n\t}\n\n\tif (mbo->buffer_length < mep_len) {\n\t\tpr_err(\"drop: too small buffer! (%d for %d)\\n\",\n\t\t       mbo->buffer_length, mep_len);\n\t\treturn -EINVAL;\n\t}\n\n\t*buff++ = HB(mep_len - 2);\n\t*buff++ = LB(mep_len - 2);\n\n\t*buff++ = PMHL;\n\t*buff++ = (PMS_FIFONO_MEP << PMS_FIFONO_SHIFT) | PMS_MSGTYPE_DATA;\n\t*buff++ = (MEP_DEF_RETRY << PMS_RETRY_SHIFT) | PMS_DEF_PRIO;\n\t*buff++ = 0;\n\t*buff++ = 0;\n\t*buff++ = 0;\n\n\tmemcpy(buff, skb->data, skb->len);\n\tmbo->buffer_length = mep_len;\n\treturn 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -2,6 +2,11 @@\n {\n \tu8 *buff = mbo->virt_address;\n \tunsigned int mep_len = skb->len + MEP_HDR_LEN;\n+\n+\tif (mep_len < skb->len) {\n+\t\tpr_err(\"drop: too large packet! (%u)\\n\", skb->len);\n+\t\treturn -EINVAL;\n+\t}\n \n \tif (mbo->buffer_length < mep_len) {\n \t\tpr_err(\"drop: too small buffer! (%d for %d)\\n\",",
        "function_modified_lines": {
            "added": [
                "",
                "\tif (mep_len < skb->len) {",
                "\t\tpr_err(\"drop: too large packet! (%u)\\n\", skb->len);",
                "\t\treturn -EINVAL;",
                "\t}"
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-787",
            "CWE-190"
        ],
        "cve_description": "In skb_to_mamac of networking.c, there is a possible out of bounds write due to an integer overflow. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-143560807",
        "id": 2385
    },
    {
        "cve_id": "CVE-2019-9162",
        "code_before_change": "int snmp_helper(void *context, size_t hdrlen, unsigned char tag,\n\t\tconst void *data, size_t datalen)\n{\n\tstruct snmp_ctx *ctx = (struct snmp_ctx *)context;\n\t__be32 *pdata = (__be32 *)data;\n\n\tif (*pdata == ctx->from) {\n\t\tpr_debug(\"%s: %pI4 to %pI4\\n\", __func__,\n\t\t\t (void *)&ctx->from, (void *)&ctx->to);\n\n\t\tif (*ctx->check)\n\t\t\tfast_csum(ctx, (unsigned char *)data - ctx->begin);\n\t\t*pdata = ctx->to;\n\t}\n\n\treturn 1;\n}",
        "code_after_change": "int snmp_helper(void *context, size_t hdrlen, unsigned char tag,\n\t\tconst void *data, size_t datalen)\n{\n\tstruct snmp_ctx *ctx = (struct snmp_ctx *)context;\n\t__be32 *pdata;\n\n\tif (datalen != 4)\n\t\treturn -EINVAL;\n\tpdata = (__be32 *)data;\n\tif (*pdata == ctx->from) {\n\t\tpr_debug(\"%s: %pI4 to %pI4\\n\", __func__,\n\t\t\t (void *)&ctx->from, (void *)&ctx->to);\n\n\t\tif (*ctx->check)\n\t\t\tfast_csum(ctx, (unsigned char *)data - ctx->begin);\n\t\t*pdata = ctx->to;\n\t}\n\n\treturn 1;\n}",
        "patch": "--- code before\n+++ code after\n@@ -2,8 +2,11 @@\n \t\tconst void *data, size_t datalen)\n {\n \tstruct snmp_ctx *ctx = (struct snmp_ctx *)context;\n-\t__be32 *pdata = (__be32 *)data;\n+\t__be32 *pdata;\n \n+\tif (datalen != 4)\n+\t\treturn -EINVAL;\n+\tpdata = (__be32 *)data;\n \tif (*pdata == ctx->from) {\n \t\tpr_debug(\"%s: %pI4 to %pI4\\n\", __func__,\n \t\t\t (void *)&ctx->from, (void *)&ctx->to);",
        "function_modified_lines": {
            "added": [
                "\t__be32 *pdata;",
                "\tif (datalen != 4)",
                "\t\treturn -EINVAL;",
                "\tpdata = (__be32 *)data;"
            ],
            "deleted": [
                "\t__be32 *pdata = (__be32 *)data;"
            ]
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "In the Linux kernel before 4.20.12, net/ipv4/netfilter/nf_nat_snmp_basic_main.c in the SNMP NAT module has insufficient ASN.1 length checks (aka an array index error), making out-of-bounds read and write operations possible, leading to an OOPS or local privilege escalation. This affects snmp_version and snmp_helper.",
        "id": 2353
    },
    {
        "cve_id": "CVE-2022-0435",
        "code_before_change": "static int tipc_link_proto_rcv(struct tipc_link *l, struct sk_buff *skb,\n\t\t\t       struct sk_buff_head *xmitq)\n{\n\tstruct tipc_msg *hdr = buf_msg(skb);\n\tstruct tipc_gap_ack_blks *ga = NULL;\n\tbool reply = msg_probe(hdr), retransmitted = false;\n\tu16 dlen = msg_data_sz(hdr), glen = 0;\n\tu16 peers_snd_nxt =  msg_next_sent(hdr);\n\tu16 peers_tol = msg_link_tolerance(hdr);\n\tu16 peers_prio = msg_linkprio(hdr);\n\tu16 gap = msg_seq_gap(hdr);\n\tu16 ack = msg_ack(hdr);\n\tu16 rcv_nxt = l->rcv_nxt;\n\tu16 rcvgap = 0;\n\tint mtyp = msg_type(hdr);\n\tint rc = 0, released;\n\tchar *if_name;\n\tvoid *data;\n\n\ttrace_tipc_proto_rcv(skb, false, l->name);\n\tif (tipc_link_is_blocked(l) || !xmitq)\n\t\tgoto exit;\n\n\tif (tipc_own_addr(l->net) > msg_prevnode(hdr))\n\t\tl->net_plane = msg_net_plane(hdr);\n\n\tskb_linearize(skb);\n\thdr = buf_msg(skb);\n\tdata = msg_data(hdr);\n\n\tif (!tipc_link_validate_msg(l, hdr)) {\n\t\ttrace_tipc_skb_dump(skb, false, \"PROTO invalid (1)!\");\n\t\ttrace_tipc_link_dump(l, TIPC_DUMP_NONE, \"PROTO invalid (1)!\");\n\t\tgoto exit;\n\t}\n\n\tswitch (mtyp) {\n\tcase RESET_MSG:\n\tcase ACTIVATE_MSG:\n\t\t/* Complete own link name with peer's interface name */\n\t\tif_name =  strrchr(l->name, ':') + 1;\n\t\tif (sizeof(l->name) - (if_name - l->name) <= TIPC_MAX_IF_NAME)\n\t\t\tbreak;\n\t\tif (msg_data_sz(hdr) < TIPC_MAX_IF_NAME)\n\t\t\tbreak;\n\t\tstrncpy(if_name, data, TIPC_MAX_IF_NAME);\n\n\t\t/* Update own tolerance if peer indicates a non-zero value */\n\t\tif (in_range(peers_tol, TIPC_MIN_LINK_TOL, TIPC_MAX_LINK_TOL)) {\n\t\t\tl->tolerance = peers_tol;\n\t\t\tl->bc_rcvlink->tolerance = peers_tol;\n\t\t}\n\t\t/* Update own priority if peer's priority is higher */\n\t\tif (in_range(peers_prio, l->priority + 1, TIPC_MAX_LINK_PRI))\n\t\t\tl->priority = peers_prio;\n\n\t\t/* If peer is going down we want full re-establish cycle */\n\t\tif (msg_peer_stopping(hdr)) {\n\t\t\trc = tipc_link_fsm_evt(l, LINK_FAILURE_EVT);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* If this endpoint was re-created while peer was ESTABLISHING\n\t\t * it doesn't know current session number. Force re-synch.\n\t\t */\n\t\tif (mtyp == ACTIVATE_MSG && msg_dest_session_valid(hdr) &&\n\t\t    l->session != msg_dest_session(hdr)) {\n\t\t\tif (less(l->session, msg_dest_session(hdr)))\n\t\t\t\tl->session = msg_dest_session(hdr) + 1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* ACTIVATE_MSG serves as PEER_RESET if link is already down */\n\t\tif (mtyp == RESET_MSG || !link_is_up(l))\n\t\t\trc = tipc_link_fsm_evt(l, LINK_PEER_RESET_EVT);\n\n\t\t/* ACTIVATE_MSG takes up link if it was already locally reset */\n\t\tif (mtyp == ACTIVATE_MSG && l->state == LINK_ESTABLISHING)\n\t\t\trc = TIPC_LINK_UP_EVT;\n\n\t\tl->peer_session = msg_session(hdr);\n\t\tl->in_session = true;\n\t\tl->peer_bearer_id = msg_bearer_id(hdr);\n\t\tif (l->mtu > msg_max_pkt(hdr))\n\t\t\tl->mtu = msg_max_pkt(hdr);\n\t\tbreak;\n\n\tcase STATE_MSG:\n\t\tl->rcv_nxt_state = msg_seqno(hdr) + 1;\n\n\t\t/* Update own tolerance if peer indicates a non-zero value */\n\t\tif (in_range(peers_tol, TIPC_MIN_LINK_TOL, TIPC_MAX_LINK_TOL)) {\n\t\t\tl->tolerance = peers_tol;\n\t\t\tl->bc_rcvlink->tolerance = peers_tol;\n\t\t}\n\t\t/* Update own prio if peer indicates a different value */\n\t\tif ((peers_prio != l->priority) &&\n\t\t    in_range(peers_prio, 1, TIPC_MAX_LINK_PRI)) {\n\t\t\tl->priority = peers_prio;\n\t\t\trc = tipc_link_fsm_evt(l, LINK_FAILURE_EVT);\n\t\t}\n\n\t\tl->silent_intv_cnt = 0;\n\t\tl->stats.recv_states++;\n\t\tif (msg_probe(hdr))\n\t\t\tl->stats.recv_probes++;\n\n\t\tif (!link_is_up(l)) {\n\t\t\tif (l->state == LINK_ESTABLISHING)\n\t\t\t\trc = TIPC_LINK_UP_EVT;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Receive Gap ACK blocks from peer if any */\n\t\tglen = tipc_get_gap_ack_blks(&ga, l, hdr, true);\n\n\t\ttipc_mon_rcv(l->net, data + glen, dlen - glen, l->addr,\n\t\t\t     &l->mon_state, l->bearer_id);\n\n\t\t/* Send NACK if peer has sent pkts we haven't received yet */\n\t\tif ((reply || msg_is_keepalive(hdr)) &&\n\t\t    more(peers_snd_nxt, rcv_nxt) &&\n\t\t    !tipc_link_is_synching(l) &&\n\t\t    skb_queue_empty(&l->deferdq))\n\t\t\trcvgap = peers_snd_nxt - l->rcv_nxt;\n\t\tif (rcvgap || reply)\n\t\t\ttipc_link_build_proto_msg(l, STATE_MSG, 0, reply,\n\t\t\t\t\t\t  rcvgap, 0, 0, xmitq);\n\n\t\treleased = tipc_link_advance_transmq(l, l, ack, gap, ga, xmitq,\n\t\t\t\t\t\t     &retransmitted, &rc);\n\t\tif (gap)\n\t\t\tl->stats.recv_nacks++;\n\t\tif (released || retransmitted)\n\t\t\ttipc_link_update_cwin(l, released, retransmitted);\n\t\tif (released)\n\t\t\ttipc_link_advance_backlog(l, xmitq);\n\t\tif (unlikely(!skb_queue_empty(&l->wakeupq)))\n\t\t\tlink_prepare_wakeup(l);\n\t}\nexit:\n\tkfree_skb(skb);\n\treturn rc;\n}",
        "code_after_change": "static int tipc_link_proto_rcv(struct tipc_link *l, struct sk_buff *skb,\n\t\t\t       struct sk_buff_head *xmitq)\n{\n\tstruct tipc_msg *hdr = buf_msg(skb);\n\tstruct tipc_gap_ack_blks *ga = NULL;\n\tbool reply = msg_probe(hdr), retransmitted = false;\n\tu32 dlen = msg_data_sz(hdr), glen = 0;\n\tu16 peers_snd_nxt =  msg_next_sent(hdr);\n\tu16 peers_tol = msg_link_tolerance(hdr);\n\tu16 peers_prio = msg_linkprio(hdr);\n\tu16 gap = msg_seq_gap(hdr);\n\tu16 ack = msg_ack(hdr);\n\tu16 rcv_nxt = l->rcv_nxt;\n\tu16 rcvgap = 0;\n\tint mtyp = msg_type(hdr);\n\tint rc = 0, released;\n\tchar *if_name;\n\tvoid *data;\n\n\ttrace_tipc_proto_rcv(skb, false, l->name);\n\n\tif (dlen > U16_MAX)\n\t\tgoto exit;\n\n\tif (tipc_link_is_blocked(l) || !xmitq)\n\t\tgoto exit;\n\n\tif (tipc_own_addr(l->net) > msg_prevnode(hdr))\n\t\tl->net_plane = msg_net_plane(hdr);\n\n\tskb_linearize(skb);\n\thdr = buf_msg(skb);\n\tdata = msg_data(hdr);\n\n\tif (!tipc_link_validate_msg(l, hdr)) {\n\t\ttrace_tipc_skb_dump(skb, false, \"PROTO invalid (1)!\");\n\t\ttrace_tipc_link_dump(l, TIPC_DUMP_NONE, \"PROTO invalid (1)!\");\n\t\tgoto exit;\n\t}\n\n\tswitch (mtyp) {\n\tcase RESET_MSG:\n\tcase ACTIVATE_MSG:\n\t\t/* Complete own link name with peer's interface name */\n\t\tif_name =  strrchr(l->name, ':') + 1;\n\t\tif (sizeof(l->name) - (if_name - l->name) <= TIPC_MAX_IF_NAME)\n\t\t\tbreak;\n\t\tif (msg_data_sz(hdr) < TIPC_MAX_IF_NAME)\n\t\t\tbreak;\n\t\tstrncpy(if_name, data, TIPC_MAX_IF_NAME);\n\n\t\t/* Update own tolerance if peer indicates a non-zero value */\n\t\tif (in_range(peers_tol, TIPC_MIN_LINK_TOL, TIPC_MAX_LINK_TOL)) {\n\t\t\tl->tolerance = peers_tol;\n\t\t\tl->bc_rcvlink->tolerance = peers_tol;\n\t\t}\n\t\t/* Update own priority if peer's priority is higher */\n\t\tif (in_range(peers_prio, l->priority + 1, TIPC_MAX_LINK_PRI))\n\t\t\tl->priority = peers_prio;\n\n\t\t/* If peer is going down we want full re-establish cycle */\n\t\tif (msg_peer_stopping(hdr)) {\n\t\t\trc = tipc_link_fsm_evt(l, LINK_FAILURE_EVT);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* If this endpoint was re-created while peer was ESTABLISHING\n\t\t * it doesn't know current session number. Force re-synch.\n\t\t */\n\t\tif (mtyp == ACTIVATE_MSG && msg_dest_session_valid(hdr) &&\n\t\t    l->session != msg_dest_session(hdr)) {\n\t\t\tif (less(l->session, msg_dest_session(hdr)))\n\t\t\t\tl->session = msg_dest_session(hdr) + 1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* ACTIVATE_MSG serves as PEER_RESET if link is already down */\n\t\tif (mtyp == RESET_MSG || !link_is_up(l))\n\t\t\trc = tipc_link_fsm_evt(l, LINK_PEER_RESET_EVT);\n\n\t\t/* ACTIVATE_MSG takes up link if it was already locally reset */\n\t\tif (mtyp == ACTIVATE_MSG && l->state == LINK_ESTABLISHING)\n\t\t\trc = TIPC_LINK_UP_EVT;\n\n\t\tl->peer_session = msg_session(hdr);\n\t\tl->in_session = true;\n\t\tl->peer_bearer_id = msg_bearer_id(hdr);\n\t\tif (l->mtu > msg_max_pkt(hdr))\n\t\t\tl->mtu = msg_max_pkt(hdr);\n\t\tbreak;\n\n\tcase STATE_MSG:\n\t\tl->rcv_nxt_state = msg_seqno(hdr) + 1;\n\n\t\t/* Update own tolerance if peer indicates a non-zero value */\n\t\tif (in_range(peers_tol, TIPC_MIN_LINK_TOL, TIPC_MAX_LINK_TOL)) {\n\t\t\tl->tolerance = peers_tol;\n\t\t\tl->bc_rcvlink->tolerance = peers_tol;\n\t\t}\n\t\t/* Update own prio if peer indicates a different value */\n\t\tif ((peers_prio != l->priority) &&\n\t\t    in_range(peers_prio, 1, TIPC_MAX_LINK_PRI)) {\n\t\t\tl->priority = peers_prio;\n\t\t\trc = tipc_link_fsm_evt(l, LINK_FAILURE_EVT);\n\t\t}\n\n\t\tl->silent_intv_cnt = 0;\n\t\tl->stats.recv_states++;\n\t\tif (msg_probe(hdr))\n\t\t\tl->stats.recv_probes++;\n\n\t\tif (!link_is_up(l)) {\n\t\t\tif (l->state == LINK_ESTABLISHING)\n\t\t\t\trc = TIPC_LINK_UP_EVT;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Receive Gap ACK blocks from peer if any */\n\t\tglen = tipc_get_gap_ack_blks(&ga, l, hdr, true);\n\t\tif(glen > dlen)\n\t\t\tbreak;\n\t\ttipc_mon_rcv(l->net, data + glen, dlen - glen, l->addr,\n\t\t\t     &l->mon_state, l->bearer_id);\n\n\t\t/* Send NACK if peer has sent pkts we haven't received yet */\n\t\tif ((reply || msg_is_keepalive(hdr)) &&\n\t\t    more(peers_snd_nxt, rcv_nxt) &&\n\t\t    !tipc_link_is_synching(l) &&\n\t\t    skb_queue_empty(&l->deferdq))\n\t\t\trcvgap = peers_snd_nxt - l->rcv_nxt;\n\t\tif (rcvgap || reply)\n\t\t\ttipc_link_build_proto_msg(l, STATE_MSG, 0, reply,\n\t\t\t\t\t\t  rcvgap, 0, 0, xmitq);\n\n\t\treleased = tipc_link_advance_transmq(l, l, ack, gap, ga, xmitq,\n\t\t\t\t\t\t     &retransmitted, &rc);\n\t\tif (gap)\n\t\t\tl->stats.recv_nacks++;\n\t\tif (released || retransmitted)\n\t\t\ttipc_link_update_cwin(l, released, retransmitted);\n\t\tif (released)\n\t\t\ttipc_link_advance_backlog(l, xmitq);\n\t\tif (unlikely(!skb_queue_empty(&l->wakeupq)))\n\t\t\tlink_prepare_wakeup(l);\n\t}\nexit:\n\tkfree_skb(skb);\n\treturn rc;\n}",
        "patch": "--- code before\n+++ code after\n@@ -4,7 +4,7 @@\n \tstruct tipc_msg *hdr = buf_msg(skb);\n \tstruct tipc_gap_ack_blks *ga = NULL;\n \tbool reply = msg_probe(hdr), retransmitted = false;\n-\tu16 dlen = msg_data_sz(hdr), glen = 0;\n+\tu32 dlen = msg_data_sz(hdr), glen = 0;\n \tu16 peers_snd_nxt =  msg_next_sent(hdr);\n \tu16 peers_tol = msg_link_tolerance(hdr);\n \tu16 peers_prio = msg_linkprio(hdr);\n@@ -18,6 +18,10 @@\n \tvoid *data;\n \n \ttrace_tipc_proto_rcv(skb, false, l->name);\n+\n+\tif (dlen > U16_MAX)\n+\t\tgoto exit;\n+\n \tif (tipc_link_is_blocked(l) || !xmitq)\n \t\tgoto exit;\n \n@@ -113,7 +117,8 @@\n \n \t\t/* Receive Gap ACK blocks from peer if any */\n \t\tglen = tipc_get_gap_ack_blks(&ga, l, hdr, true);\n-\n+\t\tif(glen > dlen)\n+\t\t\tbreak;\n \t\ttipc_mon_rcv(l->net, data + glen, dlen - glen, l->addr,\n \t\t\t     &l->mon_state, l->bearer_id);\n ",
        "function_modified_lines": {
            "added": [
                "\tu32 dlen = msg_data_sz(hdr), glen = 0;",
                "",
                "\tif (dlen > U16_MAX)",
                "\t\tgoto exit;",
                "",
                "\t\tif(glen > dlen)",
                "\t\t\tbreak;"
            ],
            "deleted": [
                "\tu16 dlen = msg_data_sz(hdr), glen = 0;",
                ""
            ]
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "A stack overflow flaw was found in the Linux kernel's TIPC protocol functionality in the way a user sends a packet with malicious content where the number of domain member nodes is higher than the 64 allowed. This flaw allows a remote user to crash the system or possibly escalate their privileges if they have access to the TIPC network.",
        "id": 3207
    },
    {
        "cve_id": "CVE-2020-0429",
        "code_before_change": "void l2tp_tunnel_closeall(struct l2tp_tunnel *tunnel)\n{\n\tint hash;\n\tstruct hlist_node *walk;\n\tstruct hlist_node *tmp;\n\tstruct l2tp_session *session;\n\n\tBUG_ON(tunnel == NULL);\n\n\tl2tp_info(tunnel, L2TP_MSG_CONTROL, \"%s: closing all sessions...\\n\",\n\t\t  tunnel->name);\n\n\twrite_lock_bh(&tunnel->hlist_lock);\n\ttunnel->acpt_newsess = false;\n\tfor (hash = 0; hash < L2TP_HASH_SIZE; hash++) {\nagain:\n\t\thlist_for_each_safe(walk, tmp, &tunnel->session_hlist[hash]) {\n\t\t\tsession = hlist_entry(walk, struct l2tp_session, hlist);\n\n\t\t\tl2tp_info(session, L2TP_MSG_CONTROL,\n\t\t\t\t  \"%s: closing session\\n\", session->name);\n\n\t\t\thlist_del_init(&session->hlist);\n\n\t\t\tif (session->ref != NULL)\n\t\t\t\t(*session->ref)(session);\n\n\t\t\twrite_unlock_bh(&tunnel->hlist_lock);\n\n\t\t\t__l2tp_session_unhash(session);\n\t\t\tl2tp_session_queue_purge(session);\n\n\t\t\tif (session->session_close != NULL)\n\t\t\t\t(*session->session_close)(session);\n\n\t\t\tif (session->deref != NULL)\n\t\t\t\t(*session->deref)(session);\n\n\t\t\tl2tp_session_dec_refcount(session);\n\n\t\t\twrite_lock_bh(&tunnel->hlist_lock);\n\n\t\t\t/* Now restart from the beginning of this hash\n\t\t\t * chain.  We always remove a session from the\n\t\t\t * list so we are guaranteed to make forward\n\t\t\t * progress.\n\t\t\t */\n\t\t\tgoto again;\n\t\t}\n\t}\n\twrite_unlock_bh(&tunnel->hlist_lock);\n}",
        "code_after_change": "void l2tp_tunnel_closeall(struct l2tp_tunnel *tunnel)\n{\n\tint hash;\n\tstruct hlist_node *walk;\n\tstruct hlist_node *tmp;\n\tstruct l2tp_session *session;\n\n\tBUG_ON(tunnel == NULL);\n\n\tl2tp_info(tunnel, L2TP_MSG_CONTROL, \"%s: closing all sessions...\\n\",\n\t\t  tunnel->name);\n\n\twrite_lock_bh(&tunnel->hlist_lock);\n\ttunnel->acpt_newsess = false;\n\tfor (hash = 0; hash < L2TP_HASH_SIZE; hash++) {\nagain:\n\t\thlist_for_each_safe(walk, tmp, &tunnel->session_hlist[hash]) {\n\t\t\tsession = hlist_entry(walk, struct l2tp_session, hlist);\n\n\t\t\tl2tp_info(session, L2TP_MSG_CONTROL,\n\t\t\t\t  \"%s: closing session\\n\", session->name);\n\n\t\t\thlist_del_init(&session->hlist);\n\n\t\t\tif (test_and_set_bit(0, &session->dead))\n\t\t\t\tgoto again;\n\n\t\t\tif (session->ref != NULL)\n\t\t\t\t(*session->ref)(session);\n\n\t\t\twrite_unlock_bh(&tunnel->hlist_lock);\n\n\t\t\t__l2tp_session_unhash(session);\n\t\t\tl2tp_session_queue_purge(session);\n\n\t\t\tif (session->session_close != NULL)\n\t\t\t\t(*session->session_close)(session);\n\n\t\t\tif (session->deref != NULL)\n\t\t\t\t(*session->deref)(session);\n\n\t\t\tl2tp_session_dec_refcount(session);\n\n\t\t\twrite_lock_bh(&tunnel->hlist_lock);\n\n\t\t\t/* Now restart from the beginning of this hash\n\t\t\t * chain.  We always remove a session from the\n\t\t\t * list so we are guaranteed to make forward\n\t\t\t * progress.\n\t\t\t */\n\t\t\tgoto again;\n\t\t}\n\t}\n\twrite_unlock_bh(&tunnel->hlist_lock);\n}",
        "patch": "--- code before\n+++ code after\n@@ -21,6 +21,9 @@\n \t\t\t\t  \"%s: closing session\\n\", session->name);\n \n \t\t\thlist_del_init(&session->hlist);\n+\n+\t\t\tif (test_and_set_bit(0, &session->dead))\n+\t\t\t\tgoto again;\n \n \t\t\tif (session->ref != NULL)\n \t\t\t\t(*session->ref)(session);",
        "function_modified_lines": {
            "added": [
                "",
                "\t\t\tif (test_and_set_bit(0, &session->dead))",
                "\t\t\t\tgoto again;"
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-787",
            "CWE-416"
        ],
        "cve_description": "In l2tp_session_delete and related functions of l2tp_core.c, there is possible memory corruption due to a use after free. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-152735806",
        "id": 2381
    },
    {
        "cve_id": "CVE-2021-3490",
        "code_before_change": "static void scalar32_min_max_and(struct bpf_reg_state *dst_reg,\n\t\t\t\t struct bpf_reg_state *src_reg)\n{\n\tbool src_known = tnum_subreg_is_const(src_reg->var_off);\n\tbool dst_known = tnum_subreg_is_const(dst_reg->var_off);\n\tstruct tnum var32_off = tnum_subreg(dst_reg->var_off);\n\ts32 smin_val = src_reg->s32_min_value;\n\tu32 umax_val = src_reg->u32_max_value;\n\n\t/* Assuming scalar64_min_max_and will be called so its safe\n\t * to skip updating register for known 32-bit case.\n\t */\n\tif (src_known && dst_known)\n\t\treturn;\n\n\t/* We get our minimum from the var_off, since that's inherently\n\t * bitwise.  Our maximum is the minimum of the operands' maxima.\n\t */\n\tdst_reg->u32_min_value = var32_off.value;\n\tdst_reg->u32_max_value = min(dst_reg->u32_max_value, umax_val);\n\tif (dst_reg->s32_min_value < 0 || smin_val < 0) {\n\t\t/* Lose signed bounds when ANDing negative numbers,\n\t\t * ain't nobody got time for that.\n\t\t */\n\t\tdst_reg->s32_min_value = S32_MIN;\n\t\tdst_reg->s32_max_value = S32_MAX;\n\t} else {\n\t\t/* ANDing two positives gives a positive, so safe to\n\t\t * cast result into s64.\n\t\t */\n\t\tdst_reg->s32_min_value = dst_reg->u32_min_value;\n\t\tdst_reg->s32_max_value = dst_reg->u32_max_value;\n\t}\n\n}",
        "code_after_change": "static void scalar32_min_max_and(struct bpf_reg_state *dst_reg,\n\t\t\t\t struct bpf_reg_state *src_reg)\n{\n\tbool src_known = tnum_subreg_is_const(src_reg->var_off);\n\tbool dst_known = tnum_subreg_is_const(dst_reg->var_off);\n\tstruct tnum var32_off = tnum_subreg(dst_reg->var_off);\n\ts32 smin_val = src_reg->s32_min_value;\n\tu32 umax_val = src_reg->u32_max_value;\n\n\tif (src_known && dst_known) {\n\t\t__mark_reg32_known(dst_reg, var32_off.value);\n\t\treturn;\n\t}\n\n\t/* We get our minimum from the var_off, since that's inherently\n\t * bitwise.  Our maximum is the minimum of the operands' maxima.\n\t */\n\tdst_reg->u32_min_value = var32_off.value;\n\tdst_reg->u32_max_value = min(dst_reg->u32_max_value, umax_val);\n\tif (dst_reg->s32_min_value < 0 || smin_val < 0) {\n\t\t/* Lose signed bounds when ANDing negative numbers,\n\t\t * ain't nobody got time for that.\n\t\t */\n\t\tdst_reg->s32_min_value = S32_MIN;\n\t\tdst_reg->s32_max_value = S32_MAX;\n\t} else {\n\t\t/* ANDing two positives gives a positive, so safe to\n\t\t * cast result into s64.\n\t\t */\n\t\tdst_reg->s32_min_value = dst_reg->u32_min_value;\n\t\tdst_reg->s32_max_value = dst_reg->u32_max_value;\n\t}\n}",
        "patch": "--- code before\n+++ code after\n@@ -7,11 +7,10 @@\n \ts32 smin_val = src_reg->s32_min_value;\n \tu32 umax_val = src_reg->u32_max_value;\n \n-\t/* Assuming scalar64_min_max_and will be called so its safe\n-\t * to skip updating register for known 32-bit case.\n-\t */\n-\tif (src_known && dst_known)\n+\tif (src_known && dst_known) {\n+\t\t__mark_reg32_known(dst_reg, var32_off.value);\n \t\treturn;\n+\t}\n \n \t/* We get our minimum from the var_off, since that's inherently\n \t * bitwise.  Our maximum is the minimum of the operands' maxima.\n@@ -31,5 +30,4 @@\n \t\tdst_reg->s32_min_value = dst_reg->u32_min_value;\n \t\tdst_reg->s32_max_value = dst_reg->u32_max_value;\n \t}\n-\n }",
        "function_modified_lines": {
            "added": [
                "\tif (src_known && dst_known) {",
                "\t\t__mark_reg32_known(dst_reg, var32_off.value);",
                "\t}"
            ],
            "deleted": [
                "\t/* Assuming scalar64_min_max_and will be called so its safe",
                "\t * to skip updating register for known 32-bit case.",
                "\t */",
                "\tif (src_known && dst_known)",
                ""
            ]
        },
        "cwe": [
            "CWE-125",
            "CWE-787"
        ],
        "cve_description": "The eBPF ALU32 bounds tracking for bitwise ops (AND, OR and XOR) in the Linux kernel did not properly update 32-bit bounds, which could be turned into out of bounds reads and writes in the Linux kernel and therefore, arbitrary code execution. This issue was fixed via commit 049c4e13714e (\"bpf: Fix alu32 const subreg bound tracking on bitwise operations\") (v5.13-rc4) and backported to the stable kernels in v5.12.4, v5.11.21, and v5.10.37. The AND/OR issues were introduced by commit 3f50f132d840 (\"bpf: Verifier, do explicit ALU32 bounds tracking\") (5.7-rc1) and the XOR variant was introduced by 2921c90d4718 (\"bpf:Fix a verifier failure with xor\") ( 5.10-rc1).",
        "id": 3011
    },
    {
        "cve_id": "CVE-2021-22555",
        "code_before_change": "static int translate_compat_table(struct net *net,\n\t\t\t\t  struct xt_table_info **pinfo,\n\t\t\t\t  void **pentry0,\n\t\t\t\t  const struct compat_arpt_replace *compatr)\n{\n\tunsigned int i, j;\n\tstruct xt_table_info *newinfo, *info;\n\tvoid *pos, *entry0, *entry1;\n\tstruct compat_arpt_entry *iter0;\n\tstruct arpt_replace repl;\n\tunsigned int size;\n\tint ret;\n\n\tinfo = *pinfo;\n\tentry0 = *pentry0;\n\tsize = compatr->size;\n\tinfo->number = compatr->num_entries;\n\n\tj = 0;\n\txt_compat_lock(NFPROTO_ARP);\n\tret = xt_compat_init_offsets(NFPROTO_ARP, compatr->num_entries);\n\tif (ret)\n\t\tgoto out_unlock;\n\t/* Walk through entries, checking offsets. */\n\txt_entry_foreach(iter0, entry0, compatr->size) {\n\t\tret = check_compat_entry_size_and_hooks(iter0, info, &size,\n\t\t\t\t\t\t\tentry0,\n\t\t\t\t\t\t\tentry0 + compatr->size);\n\t\tif (ret != 0)\n\t\t\tgoto out_unlock;\n\t\t++j;\n\t}\n\n\tret = -EINVAL;\n\tif (j != compatr->num_entries)\n\t\tgoto out_unlock;\n\n\tret = -ENOMEM;\n\tnewinfo = xt_alloc_table_info(size);\n\tif (!newinfo)\n\t\tgoto out_unlock;\n\n\tnewinfo->number = compatr->num_entries;\n\tfor (i = 0; i < NF_ARP_NUMHOOKS; i++) {\n\t\tnewinfo->hook_entry[i] = compatr->hook_entry[i];\n\t\tnewinfo->underflow[i] = compatr->underflow[i];\n\t}\n\tentry1 = newinfo->entries;\n\tpos = entry1;\n\tsize = compatr->size;\n\txt_entry_foreach(iter0, entry0, compatr->size)\n\t\tcompat_copy_entry_from_user(iter0, &pos, &size,\n\t\t\t\t\t    newinfo, entry1);\n\n\t/* all module references in entry0 are now gone */\n\n\txt_compat_flush_offsets(NFPROTO_ARP);\n\txt_compat_unlock(NFPROTO_ARP);\n\n\tmemcpy(&repl, compatr, sizeof(*compatr));\n\n\tfor (i = 0; i < NF_ARP_NUMHOOKS; i++) {\n\t\trepl.hook_entry[i] = newinfo->hook_entry[i];\n\t\trepl.underflow[i] = newinfo->underflow[i];\n\t}\n\n\trepl.num_counters = 0;\n\trepl.counters = NULL;\n\trepl.size = newinfo->size;\n\tret = translate_table(net, newinfo, entry1, &repl);\n\tif (ret)\n\t\tgoto free_newinfo;\n\n\t*pinfo = newinfo;\n\t*pentry0 = entry1;\n\txt_free_table_info(info);\n\treturn 0;\n\nfree_newinfo:\n\txt_free_table_info(newinfo);\n\treturn ret;\nout_unlock:\n\txt_compat_flush_offsets(NFPROTO_ARP);\n\txt_compat_unlock(NFPROTO_ARP);\n\txt_entry_foreach(iter0, entry0, compatr->size) {\n\t\tif (j-- == 0)\n\t\t\tbreak;\n\t\tcompat_release_entry(iter0);\n\t}\n\treturn ret;\n}",
        "code_after_change": "static int translate_compat_table(struct net *net,\n\t\t\t\t  struct xt_table_info **pinfo,\n\t\t\t\t  void **pentry0,\n\t\t\t\t  const struct compat_arpt_replace *compatr)\n{\n\tunsigned int i, j;\n\tstruct xt_table_info *newinfo, *info;\n\tvoid *pos, *entry0, *entry1;\n\tstruct compat_arpt_entry *iter0;\n\tstruct arpt_replace repl;\n\tunsigned int size;\n\tint ret;\n\n\tinfo = *pinfo;\n\tentry0 = *pentry0;\n\tsize = compatr->size;\n\tinfo->number = compatr->num_entries;\n\n\tj = 0;\n\txt_compat_lock(NFPROTO_ARP);\n\tret = xt_compat_init_offsets(NFPROTO_ARP, compatr->num_entries);\n\tif (ret)\n\t\tgoto out_unlock;\n\t/* Walk through entries, checking offsets. */\n\txt_entry_foreach(iter0, entry0, compatr->size) {\n\t\tret = check_compat_entry_size_and_hooks(iter0, info, &size,\n\t\t\t\t\t\t\tentry0,\n\t\t\t\t\t\t\tentry0 + compatr->size);\n\t\tif (ret != 0)\n\t\t\tgoto out_unlock;\n\t\t++j;\n\t}\n\n\tret = -EINVAL;\n\tif (j != compatr->num_entries)\n\t\tgoto out_unlock;\n\n\tret = -ENOMEM;\n\tnewinfo = xt_alloc_table_info(size);\n\tif (!newinfo)\n\t\tgoto out_unlock;\n\n\tmemset(newinfo->entries, 0, size);\n\n\tnewinfo->number = compatr->num_entries;\n\tfor (i = 0; i < NF_ARP_NUMHOOKS; i++) {\n\t\tnewinfo->hook_entry[i] = compatr->hook_entry[i];\n\t\tnewinfo->underflow[i] = compatr->underflow[i];\n\t}\n\tentry1 = newinfo->entries;\n\tpos = entry1;\n\tsize = compatr->size;\n\txt_entry_foreach(iter0, entry0, compatr->size)\n\t\tcompat_copy_entry_from_user(iter0, &pos, &size,\n\t\t\t\t\t    newinfo, entry1);\n\n\t/* all module references in entry0 are now gone */\n\n\txt_compat_flush_offsets(NFPROTO_ARP);\n\txt_compat_unlock(NFPROTO_ARP);\n\n\tmemcpy(&repl, compatr, sizeof(*compatr));\n\n\tfor (i = 0; i < NF_ARP_NUMHOOKS; i++) {\n\t\trepl.hook_entry[i] = newinfo->hook_entry[i];\n\t\trepl.underflow[i] = newinfo->underflow[i];\n\t}\n\n\trepl.num_counters = 0;\n\trepl.counters = NULL;\n\trepl.size = newinfo->size;\n\tret = translate_table(net, newinfo, entry1, &repl);\n\tif (ret)\n\t\tgoto free_newinfo;\n\n\t*pinfo = newinfo;\n\t*pentry0 = entry1;\n\txt_free_table_info(info);\n\treturn 0;\n\nfree_newinfo:\n\txt_free_table_info(newinfo);\n\treturn ret;\nout_unlock:\n\txt_compat_flush_offsets(NFPROTO_ARP);\n\txt_compat_unlock(NFPROTO_ARP);\n\txt_entry_foreach(iter0, entry0, compatr->size) {\n\t\tif (j-- == 0)\n\t\t\tbreak;\n\t\tcompat_release_entry(iter0);\n\t}\n\treturn ret;\n}",
        "patch": "--- code before\n+++ code after\n@@ -39,6 +39,8 @@\n \tnewinfo = xt_alloc_table_info(size);\n \tif (!newinfo)\n \t\tgoto out_unlock;\n+\n+\tmemset(newinfo->entries, 0, size);\n \n \tnewinfo->number = compatr->num_entries;\n \tfor (i = 0; i < NF_ARP_NUMHOOKS; i++) {",
        "function_modified_lines": {
            "added": [
                "",
                "\tmemset(newinfo->entries, 0, size);"
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "A heap out-of-bounds write affecting Linux since v2.6.19-rc1 was discovered in net/netfilter/x_tables.c. This allows an attacker to gain privileges or cause a DoS (via heap memory corruption) through user name space",
        "id": 2881
    },
    {
        "cve_id": "CVE-2021-22555",
        "code_before_change": "void xt_compat_target_from_user(struct xt_entry_target *t, void **dstptr,\n\t\t\t\tunsigned int *size)\n{\n\tconst struct xt_target *target = t->u.kernel.target;\n\tstruct compat_xt_entry_target *ct = (struct compat_xt_entry_target *)t;\n\tint pad, off = xt_compat_target_offset(target);\n\tu_int16_t tsize = ct->u.user.target_size;\n\tchar name[sizeof(t->u.user.name)];\n\n\tt = *dstptr;\n\tmemcpy(t, ct, sizeof(*ct));\n\tif (target->compat_from_user)\n\t\ttarget->compat_from_user(t->data, ct->data);\n\telse\n\t\tmemcpy(t->data, ct->data, tsize - sizeof(*ct));\n\tpad = XT_ALIGN(target->targetsize) - target->targetsize;\n\tif (pad > 0)\n\t\tmemset(t->data + target->targetsize, 0, pad);\n\n\ttsize += off;\n\tt->u.user.target_size = tsize;\n\tstrlcpy(name, target->name, sizeof(name));\n\tmodule_put(target->me);\n\tstrncpy(t->u.user.name, name, sizeof(t->u.user.name));\n\n\t*size += off;\n\t*dstptr += tsize;\n}",
        "code_after_change": "void xt_compat_target_from_user(struct xt_entry_target *t, void **dstptr,\n\t\t\t\tunsigned int *size)\n{\n\tconst struct xt_target *target = t->u.kernel.target;\n\tstruct compat_xt_entry_target *ct = (struct compat_xt_entry_target *)t;\n\tint off = xt_compat_target_offset(target);\n\tu_int16_t tsize = ct->u.user.target_size;\n\tchar name[sizeof(t->u.user.name)];\n\n\tt = *dstptr;\n\tmemcpy(t, ct, sizeof(*ct));\n\tif (target->compat_from_user)\n\t\ttarget->compat_from_user(t->data, ct->data);\n\telse\n\t\tmemcpy(t->data, ct->data, tsize - sizeof(*ct));\n\n\ttsize += off;\n\tt->u.user.target_size = tsize;\n\tstrlcpy(name, target->name, sizeof(name));\n\tmodule_put(target->me);\n\tstrncpy(t->u.user.name, name, sizeof(t->u.user.name));\n\n\t*size += off;\n\t*dstptr += tsize;\n}",
        "patch": "--- code before\n+++ code after\n@@ -3,7 +3,7 @@\n {\n \tconst struct xt_target *target = t->u.kernel.target;\n \tstruct compat_xt_entry_target *ct = (struct compat_xt_entry_target *)t;\n-\tint pad, off = xt_compat_target_offset(target);\n+\tint off = xt_compat_target_offset(target);\n \tu_int16_t tsize = ct->u.user.target_size;\n \tchar name[sizeof(t->u.user.name)];\n \n@@ -13,9 +13,6 @@\n \t\ttarget->compat_from_user(t->data, ct->data);\n \telse\n \t\tmemcpy(t->data, ct->data, tsize - sizeof(*ct));\n-\tpad = XT_ALIGN(target->targetsize) - target->targetsize;\n-\tif (pad > 0)\n-\t\tmemset(t->data + target->targetsize, 0, pad);\n \n \ttsize += off;\n \tt->u.user.target_size = tsize;",
        "function_modified_lines": {
            "added": [
                "\tint off = xt_compat_target_offset(target);"
            ],
            "deleted": [
                "\tint pad, off = xt_compat_target_offset(target);",
                "\tpad = XT_ALIGN(target->targetsize) - target->targetsize;",
                "\tif (pad > 0)",
                "\t\tmemset(t->data + target->targetsize, 0, pad);"
            ]
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "A heap out-of-bounds write affecting Linux since v2.6.19-rc1 was discovered in net/netfilter/x_tables.c. This allows an attacker to gain privileges or cause a DoS (via heap memory corruption) through user name space",
        "id": 2885
    },
    {
        "cve_id": "CVE-2021-22555",
        "code_before_change": "static int\ntranslate_compat_table(struct net *net,\n\t\t       struct xt_table_info **pinfo,\n\t\t       void **pentry0,\n\t\t       const struct compat_ip6t_replace *compatr)\n{\n\tunsigned int i, j;\n\tstruct xt_table_info *newinfo, *info;\n\tvoid *pos, *entry0, *entry1;\n\tstruct compat_ip6t_entry *iter0;\n\tstruct ip6t_replace repl;\n\tunsigned int size;\n\tint ret;\n\n\tinfo = *pinfo;\n\tentry0 = *pentry0;\n\tsize = compatr->size;\n\tinfo->number = compatr->num_entries;\n\n\tj = 0;\n\txt_compat_lock(AF_INET6);\n\tret = xt_compat_init_offsets(AF_INET6, compatr->num_entries);\n\tif (ret)\n\t\tgoto out_unlock;\n\t/* Walk through entries, checking offsets. */\n\txt_entry_foreach(iter0, entry0, compatr->size) {\n\t\tret = check_compat_entry_size_and_hooks(iter0, info, &size,\n\t\t\t\t\t\t\tentry0,\n\t\t\t\t\t\t\tentry0 + compatr->size);\n\t\tif (ret != 0)\n\t\t\tgoto out_unlock;\n\t\t++j;\n\t}\n\n\tret = -EINVAL;\n\tif (j != compatr->num_entries)\n\t\tgoto out_unlock;\n\n\tret = -ENOMEM;\n\tnewinfo = xt_alloc_table_info(size);\n\tif (!newinfo)\n\t\tgoto out_unlock;\n\n\tnewinfo->number = compatr->num_entries;\n\tfor (i = 0; i < NF_INET_NUMHOOKS; i++) {\n\t\tnewinfo->hook_entry[i] = compatr->hook_entry[i];\n\t\tnewinfo->underflow[i] = compatr->underflow[i];\n\t}\n\tentry1 = newinfo->entries;\n\tpos = entry1;\n\tsize = compatr->size;\n\txt_entry_foreach(iter0, entry0, compatr->size)\n\t\tcompat_copy_entry_from_user(iter0, &pos, &size,\n\t\t\t\t\t    newinfo, entry1);\n\n\t/* all module references in entry0 are now gone. */\n\txt_compat_flush_offsets(AF_INET6);\n\txt_compat_unlock(AF_INET6);\n\n\tmemcpy(&repl, compatr, sizeof(*compatr));\n\n\tfor (i = 0; i < NF_INET_NUMHOOKS; i++) {\n\t\trepl.hook_entry[i] = newinfo->hook_entry[i];\n\t\trepl.underflow[i] = newinfo->underflow[i];\n\t}\n\n\trepl.num_counters = 0;\n\trepl.counters = NULL;\n\trepl.size = newinfo->size;\n\tret = translate_table(net, newinfo, entry1, &repl);\n\tif (ret)\n\t\tgoto free_newinfo;\n\n\t*pinfo = newinfo;\n\t*pentry0 = entry1;\n\txt_free_table_info(info);\n\treturn 0;\n\nfree_newinfo:\n\txt_free_table_info(newinfo);\n\treturn ret;\nout_unlock:\n\txt_compat_flush_offsets(AF_INET6);\n\txt_compat_unlock(AF_INET6);\n\txt_entry_foreach(iter0, entry0, compatr->size) {\n\t\tif (j-- == 0)\n\t\t\tbreak;\n\t\tcompat_release_entry(iter0);\n\t}\n\treturn ret;\n}",
        "code_after_change": "static int\ntranslate_compat_table(struct net *net,\n\t\t       struct xt_table_info **pinfo,\n\t\t       void **pentry0,\n\t\t       const struct compat_ip6t_replace *compatr)\n{\n\tunsigned int i, j;\n\tstruct xt_table_info *newinfo, *info;\n\tvoid *pos, *entry0, *entry1;\n\tstruct compat_ip6t_entry *iter0;\n\tstruct ip6t_replace repl;\n\tunsigned int size;\n\tint ret;\n\n\tinfo = *pinfo;\n\tentry0 = *pentry0;\n\tsize = compatr->size;\n\tinfo->number = compatr->num_entries;\n\n\tj = 0;\n\txt_compat_lock(AF_INET6);\n\tret = xt_compat_init_offsets(AF_INET6, compatr->num_entries);\n\tif (ret)\n\t\tgoto out_unlock;\n\t/* Walk through entries, checking offsets. */\n\txt_entry_foreach(iter0, entry0, compatr->size) {\n\t\tret = check_compat_entry_size_and_hooks(iter0, info, &size,\n\t\t\t\t\t\t\tentry0,\n\t\t\t\t\t\t\tentry0 + compatr->size);\n\t\tif (ret != 0)\n\t\t\tgoto out_unlock;\n\t\t++j;\n\t}\n\n\tret = -EINVAL;\n\tif (j != compatr->num_entries)\n\t\tgoto out_unlock;\n\n\tret = -ENOMEM;\n\tnewinfo = xt_alloc_table_info(size);\n\tif (!newinfo)\n\t\tgoto out_unlock;\n\n\tmemset(newinfo->entries, 0, size);\n\n\tnewinfo->number = compatr->num_entries;\n\tfor (i = 0; i < NF_INET_NUMHOOKS; i++) {\n\t\tnewinfo->hook_entry[i] = compatr->hook_entry[i];\n\t\tnewinfo->underflow[i] = compatr->underflow[i];\n\t}\n\tentry1 = newinfo->entries;\n\tpos = entry1;\n\tsize = compatr->size;\n\txt_entry_foreach(iter0, entry0, compatr->size)\n\t\tcompat_copy_entry_from_user(iter0, &pos, &size,\n\t\t\t\t\t    newinfo, entry1);\n\n\t/* all module references in entry0 are now gone. */\n\txt_compat_flush_offsets(AF_INET6);\n\txt_compat_unlock(AF_INET6);\n\n\tmemcpy(&repl, compatr, sizeof(*compatr));\n\n\tfor (i = 0; i < NF_INET_NUMHOOKS; i++) {\n\t\trepl.hook_entry[i] = newinfo->hook_entry[i];\n\t\trepl.underflow[i] = newinfo->underflow[i];\n\t}\n\n\trepl.num_counters = 0;\n\trepl.counters = NULL;\n\trepl.size = newinfo->size;\n\tret = translate_table(net, newinfo, entry1, &repl);\n\tif (ret)\n\t\tgoto free_newinfo;\n\n\t*pinfo = newinfo;\n\t*pentry0 = entry1;\n\txt_free_table_info(info);\n\treturn 0;\n\nfree_newinfo:\n\txt_free_table_info(newinfo);\n\treturn ret;\nout_unlock:\n\txt_compat_flush_offsets(AF_INET6);\n\txt_compat_unlock(AF_INET6);\n\txt_entry_foreach(iter0, entry0, compatr->size) {\n\t\tif (j-- == 0)\n\t\t\tbreak;\n\t\tcompat_release_entry(iter0);\n\t}\n\treturn ret;\n}",
        "patch": "--- code before\n+++ code after\n@@ -40,6 +40,8 @@\n \tnewinfo = xt_alloc_table_info(size);\n \tif (!newinfo)\n \t\tgoto out_unlock;\n+\n+\tmemset(newinfo->entries, 0, size);\n \n \tnewinfo->number = compatr->num_entries;\n \tfor (i = 0; i < NF_INET_NUMHOOKS; i++) {",
        "function_modified_lines": {
            "added": [
                "",
                "\tmemset(newinfo->entries, 0, size);"
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "A heap out-of-bounds write affecting Linux since v2.6.19-rc1 was discovered in net/netfilter/x_tables.c. This allows an attacker to gain privileges or cause a DoS (via heap memory corruption) through user name space",
        "id": 2883
    },
    {
        "cve_id": "CVE-2020-25285",
        "code_before_change": "static int hugetlb_sysctl_handler_common(bool obey_mempolicy,\n\t\t\t struct ctl_table *table, int write,\n\t\t\t void *buffer, size_t *length, loff_t *ppos)\n{\n\tstruct hstate *h = &default_hstate;\n\tunsigned long tmp = h->max_huge_pages;\n\tint ret;\n\n\tif (!hugepages_supported())\n\t\treturn -EOPNOTSUPP;\n\n\ttable->data = &tmp;\n\ttable->maxlen = sizeof(unsigned long);\n\tret = proc_doulongvec_minmax(table, write, buffer, length, ppos);\n\tif (ret)\n\t\tgoto out;\n\n\tif (write)\n\t\tret = __nr_hugepages_store_common(obey_mempolicy, h,\n\t\t\t\t\t\t  NUMA_NO_NODE, tmp, *length);\nout:\n\treturn ret;\n}",
        "code_after_change": "static int hugetlb_sysctl_handler_common(bool obey_mempolicy,\n\t\t\t struct ctl_table *table, int write,\n\t\t\t void *buffer, size_t *length, loff_t *ppos)\n{\n\tstruct hstate *h = &default_hstate;\n\tunsigned long tmp = h->max_huge_pages;\n\tint ret;\n\n\tif (!hugepages_supported())\n\t\treturn -EOPNOTSUPP;\n\n\tret = proc_hugetlb_doulongvec_minmax(table, write, buffer, length, ppos,\n\t\t\t\t\t     &tmp);\n\tif (ret)\n\t\tgoto out;\n\n\tif (write)\n\t\tret = __nr_hugepages_store_common(obey_mempolicy, h,\n\t\t\t\t\t\t  NUMA_NO_NODE, tmp, *length);\nout:\n\treturn ret;\n}",
        "patch": "--- code before\n+++ code after\n@@ -9,9 +9,8 @@\n \tif (!hugepages_supported())\n \t\treturn -EOPNOTSUPP;\n \n-\ttable->data = &tmp;\n-\ttable->maxlen = sizeof(unsigned long);\n-\tret = proc_doulongvec_minmax(table, write, buffer, length, ppos);\n+\tret = proc_hugetlb_doulongvec_minmax(table, write, buffer, length, ppos,\n+\t\t\t\t\t     &tmp);\n \tif (ret)\n \t\tgoto out;\n ",
        "function_modified_lines": {
            "added": [
                "\tret = proc_hugetlb_doulongvec_minmax(table, write, buffer, length, ppos,",
                "\t\t\t\t\t     &tmp);"
            ],
            "deleted": [
                "\ttable->data = &tmp;",
                "\ttable->maxlen = sizeof(unsigned long);",
                "\tret = proc_doulongvec_minmax(table, write, buffer, length, ppos);"
            ]
        },
        "cwe": [
            "CWE-362",
            "CWE-787",
            "CWE-476"
        ],
        "cve_description": "A race condition between hugetlb sysctl handlers in mm/hugetlb.c in the Linux kernel before 5.8.8 could be used by local attackers to corrupt memory, cause a NULL pointer dereference, or possibly have unspecified other impact, aka CID-17743798d812.",
        "id": 2587
    },
    {
        "cve_id": "CVE-2018-1068",
        "code_before_change": "static int size_entry_mwt(struct ebt_entry *entry, const unsigned char *base,\n\t\t\t  unsigned int *total,\n\t\t\t  struct ebt_entries_buf_state *state)\n{\n\tunsigned int i, j, startoff, new_offset = 0;\n\t/* stores match/watchers/targets & offset of next struct ebt_entry: */\n\tunsigned int offsets[4];\n\tunsigned int *offsets_update = NULL;\n\tint ret;\n\tchar *buf_start;\n\n\tif (*total < sizeof(struct ebt_entries))\n\t\treturn -EINVAL;\n\n\tif (!entry->bitmask) {\n\t\t*total -= sizeof(struct ebt_entries);\n\t\treturn ebt_buf_add(state, entry, sizeof(struct ebt_entries));\n\t}\n\tif (*total < sizeof(*entry) || entry->next_offset < sizeof(*entry))\n\t\treturn -EINVAL;\n\n\tstartoff = state->buf_user_offset;\n\t/* pull in most part of ebt_entry, it does not need to be changed. */\n\tret = ebt_buf_add(state, entry,\n\t\t\toffsetof(struct ebt_entry, watchers_offset));\n\tif (ret < 0)\n\t\treturn ret;\n\n\toffsets[0] = sizeof(struct ebt_entry); /* matches come first */\n\tmemcpy(&offsets[1], &entry->watchers_offset,\n\t\t\tsizeof(offsets) - sizeof(offsets[0]));\n\n\tif (state->buf_kern_start) {\n\t\tbuf_start = state->buf_kern_start + state->buf_kern_offset;\n\t\toffsets_update = (unsigned int *) buf_start;\n\t}\n\tret = ebt_buf_add(state, &offsets[1],\n\t\t\tsizeof(offsets) - sizeof(offsets[0]));\n\tif (ret < 0)\n\t\treturn ret;\n\tbuf_start = (char *) entry;\n\t/* 0: matches offset, always follows ebt_entry.\n\t * 1: watchers offset, from ebt_entry structure\n\t * 2: target offset, from ebt_entry structure\n\t * 3: next ebt_entry offset, from ebt_entry structure\n\t *\n\t * offsets are relative to beginning of struct ebt_entry (i.e., 0).\n\t */\n\tfor (i = 0, j = 1 ; j < 4 ; j++, i++) {\n\t\tstruct compat_ebt_entry_mwt *match32;\n\t\tunsigned int size;\n\t\tchar *buf = buf_start + offsets[i];\n\n\t\tif (offsets[i] > offsets[j])\n\t\t\treturn -EINVAL;\n\n\t\tmatch32 = (struct compat_ebt_entry_mwt *) buf;\n\t\tsize = offsets[j] - offsets[i];\n\t\tret = ebt_size_mwt(match32, size, i, state, base);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tnew_offset += ret;\n\t\tif (offsets_update && new_offset) {\n\t\t\tpr_debug(\"change offset %d to %d\\n\",\n\t\t\t\toffsets_update[i], offsets[j] + new_offset);\n\t\t\toffsets_update[i] = offsets[j] + new_offset;\n\t\t}\n\t}\n\n\tif (state->buf_kern_start == NULL) {\n\t\tunsigned int offset = buf_start - (char *) base;\n\n\t\tret = xt_compat_add_offset(NFPROTO_BRIDGE, offset, new_offset);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tstartoff = state->buf_user_offset - startoff;\n\n\tif (WARN_ON(*total < startoff))\n\t\treturn -EINVAL;\n\t*total -= startoff;\n\treturn 0;\n}",
        "code_after_change": "static int size_entry_mwt(struct ebt_entry *entry, const unsigned char *base,\n\t\t\t  unsigned int *total,\n\t\t\t  struct ebt_entries_buf_state *state)\n{\n\tunsigned int i, j, startoff, new_offset = 0;\n\t/* stores match/watchers/targets & offset of next struct ebt_entry: */\n\tunsigned int offsets[4];\n\tunsigned int *offsets_update = NULL;\n\tint ret;\n\tchar *buf_start;\n\n\tif (*total < sizeof(struct ebt_entries))\n\t\treturn -EINVAL;\n\n\tif (!entry->bitmask) {\n\t\t*total -= sizeof(struct ebt_entries);\n\t\treturn ebt_buf_add(state, entry, sizeof(struct ebt_entries));\n\t}\n\tif (*total < sizeof(*entry) || entry->next_offset < sizeof(*entry))\n\t\treturn -EINVAL;\n\n\tstartoff = state->buf_user_offset;\n\t/* pull in most part of ebt_entry, it does not need to be changed. */\n\tret = ebt_buf_add(state, entry,\n\t\t\toffsetof(struct ebt_entry, watchers_offset));\n\tif (ret < 0)\n\t\treturn ret;\n\n\toffsets[0] = sizeof(struct ebt_entry); /* matches come first */\n\tmemcpy(&offsets[1], &entry->watchers_offset,\n\t\t\tsizeof(offsets) - sizeof(offsets[0]));\n\n\tif (state->buf_kern_start) {\n\t\tbuf_start = state->buf_kern_start + state->buf_kern_offset;\n\t\toffsets_update = (unsigned int *) buf_start;\n\t}\n\tret = ebt_buf_add(state, &offsets[1],\n\t\t\tsizeof(offsets) - sizeof(offsets[0]));\n\tif (ret < 0)\n\t\treturn ret;\n\tbuf_start = (char *) entry;\n\t/* 0: matches offset, always follows ebt_entry.\n\t * 1: watchers offset, from ebt_entry structure\n\t * 2: target offset, from ebt_entry structure\n\t * 3: next ebt_entry offset, from ebt_entry structure\n\t *\n\t * offsets are relative to beginning of struct ebt_entry (i.e., 0).\n\t */\n\tfor (i = 0; i < 4 ; ++i) {\n\t\tif (offsets[i] >= *total)\n\t\t\treturn -EINVAL;\n\t\tif (i == 0)\n\t\t\tcontinue;\n\t\tif (offsets[i-1] > offsets[i])\n\t\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0, j = 1 ; j < 4 ; j++, i++) {\n\t\tstruct compat_ebt_entry_mwt *match32;\n\t\tunsigned int size;\n\t\tchar *buf = buf_start + offsets[i];\n\n\t\tif (offsets[i] > offsets[j])\n\t\t\treturn -EINVAL;\n\n\t\tmatch32 = (struct compat_ebt_entry_mwt *) buf;\n\t\tsize = offsets[j] - offsets[i];\n\t\tret = ebt_size_mwt(match32, size, i, state, base);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tnew_offset += ret;\n\t\tif (offsets_update && new_offset) {\n\t\t\tpr_debug(\"change offset %d to %d\\n\",\n\t\t\t\toffsets_update[i], offsets[j] + new_offset);\n\t\t\toffsets_update[i] = offsets[j] + new_offset;\n\t\t}\n\t}\n\n\tif (state->buf_kern_start == NULL) {\n\t\tunsigned int offset = buf_start - (char *) base;\n\n\t\tret = xt_compat_add_offset(NFPROTO_BRIDGE, offset, new_offset);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tstartoff = state->buf_user_offset - startoff;\n\n\tif (WARN_ON(*total < startoff))\n\t\treturn -EINVAL;\n\t*total -= startoff;\n\treturn 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -46,6 +46,15 @@\n \t *\n \t * offsets are relative to beginning of struct ebt_entry (i.e., 0).\n \t */\n+\tfor (i = 0; i < 4 ; ++i) {\n+\t\tif (offsets[i] >= *total)\n+\t\t\treturn -EINVAL;\n+\t\tif (i == 0)\n+\t\t\tcontinue;\n+\t\tif (offsets[i-1] > offsets[i])\n+\t\t\treturn -EINVAL;\n+\t}\n+\n \tfor (i = 0, j = 1 ; j < 4 ; j++, i++) {\n \t\tstruct compat_ebt_entry_mwt *match32;\n \t\tunsigned int size;",
        "function_modified_lines": {
            "added": [
                "\tfor (i = 0; i < 4 ; ++i) {",
                "\t\tif (offsets[i] >= *total)",
                "\t\t\treturn -EINVAL;",
                "\t\tif (i == 0)",
                "\t\t\tcontinue;",
                "\t\tif (offsets[i-1] > offsets[i])",
                "\t\t\treturn -EINVAL;",
                "\t}",
                ""
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "A flaw was found in the Linux 4.x kernel's implementation of 32-bit syscall interface for bridging. This allowed a privileged user to arbitrarily write to a limited range of kernel memory.",
        "id": 1594
    },
    {
        "cve_id": "CVE-2023-6931",
        "code_before_change": "static void perf_event__header_size(struct perf_event *event)\n{\n\t__perf_event_read_size(event,\n\t\t\t       event->group_leader->nr_siblings);\n\t__perf_event_header_size(event, event->attr.sample_type);\n}",
        "code_after_change": "static void perf_event__header_size(struct perf_event *event)\n{\n\tevent->read_size =\n\t\t__perf_event_read_size(event->attr.read_format,\n\t\t\t\t       event->group_leader->nr_siblings);\n\t__perf_event_header_size(event, event->attr.sample_type);\n}",
        "patch": "--- code before\n+++ code after\n@@ -1,6 +1,7 @@\n static void perf_event__header_size(struct perf_event *event)\n {\n-\t__perf_event_read_size(event,\n-\t\t\t       event->group_leader->nr_siblings);\n+\tevent->read_size =\n+\t\t__perf_event_read_size(event->attr.read_format,\n+\t\t\t\t       event->group_leader->nr_siblings);\n \t__perf_event_header_size(event, event->attr.sample_type);\n }",
        "function_modified_lines": {
            "added": [
                "\tevent->read_size =",
                "\t\t__perf_event_read_size(event->attr.read_format,",
                "\t\t\t\t       event->group_leader->nr_siblings);"
            ],
            "deleted": [
                "\t__perf_event_read_size(event,",
                "\t\t\t       event->group_leader->nr_siblings);"
            ]
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "A heap out-of-bounds write vulnerability in the Linux kernel's Performance Events system component can be exploited to achieve local privilege escalation.\n\nA perf_event's read_size can overflow, leading to an heap out-of-bounds increment or write in perf_read_group().\n\nWe recommend upgrading past commit 382c27f4ed28f803b1f1473ac2d8db0afc795a1b.\n\n",
        "id": 4310
    },
    {
        "cve_id": "CVE-2022-1015",
        "code_before_change": "int nft_parse_register_store(const struct nft_ctx *ctx,\n\t\t\t     const struct nlattr *attr, u8 *dreg,\n\t\t\t     const struct nft_data *data,\n\t\t\t     enum nft_data_types type, unsigned int len)\n{\n\tint err;\n\tu32 reg;\n\n\treg = nft_parse_register(attr);\n\terr = nft_validate_register_store(ctx, reg, data, type, len);\n\tif (err < 0)\n\t\treturn err;\n\n\t*dreg = reg;\n\treturn 0;\n}",
        "code_after_change": "int nft_parse_register_store(const struct nft_ctx *ctx,\n\t\t\t     const struct nlattr *attr, u8 *dreg,\n\t\t\t     const struct nft_data *data,\n\t\t\t     enum nft_data_types type, unsigned int len)\n{\n\tint err;\n\tu32 reg;\n\n\terr = nft_parse_register(attr, &reg);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = nft_validate_register_store(ctx, reg, data, type, len);\n\tif (err < 0)\n\t\treturn err;\n\n\t*dreg = reg;\n\treturn 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -6,7 +6,10 @@\n \tint err;\n \tu32 reg;\n \n-\treg = nft_parse_register(attr);\n+\terr = nft_parse_register(attr, &reg);\n+\tif (err < 0)\n+\t\treturn err;\n+\n \terr = nft_validate_register_store(ctx, reg, data, type, len);\n \tif (err < 0)\n \t\treturn err;",
        "function_modified_lines": {
            "added": [
                "\terr = nft_parse_register(attr, &reg);",
                "\tif (err < 0)",
                "\t\treturn err;",
                ""
            ],
            "deleted": [
                "\treg = nft_parse_register(attr);"
            ]
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "A flaw was found in the Linux kernel in linux/net/netfilter/nf_tables_api.c of the netfilter subsystem. This flaw allows a local user to cause an out-of-bounds write issue.",
        "id": 3239
    },
    {
        "cve_id": "CVE-2021-42739",
        "code_before_change": "int avc_ca_pmt(struct firedtv *fdtv, char *msg, int length)\n{\n\tstruct avc_command_frame *c = (void *)fdtv->avc_data;\n\tstruct avc_response_frame *r = (void *)fdtv->avc_data;\n\tint list_management;\n\tint program_info_length;\n\tint pmt_cmd_id;\n\tint read_pos;\n\tint write_pos;\n\tint es_info_length;\n\tint crc32_csum;\n\tint ret;\n\n\tif (unlikely(avc_debug & AVC_DEBUG_APPLICATION_PMT))\n\t\tdebug_pmt(msg, length);\n\n\tmutex_lock(&fdtv->avc_mutex);\n\n\tc->ctype   = AVC_CTYPE_CONTROL;\n\tc->subunit = AVC_SUBUNIT_TYPE_TUNER | fdtv->subunit;\n\tc->opcode  = AVC_OPCODE_VENDOR;\n\n\tif (msg[0] != EN50221_LIST_MANAGEMENT_ONLY) {\n\t\tdev_info(fdtv->device, \"forcing list_management to ONLY\\n\");\n\t\tmsg[0] = EN50221_LIST_MANAGEMENT_ONLY;\n\t}\n\t/* We take the cmd_id from the programme level only! */\n\tlist_management = msg[0];\n\tprogram_info_length = ((msg[4] & 0x0f) << 8) + msg[5];\n\tif (program_info_length > 0)\n\t\tprogram_info_length--; /* Remove pmt_cmd_id */\n\tpmt_cmd_id = msg[6];\n\n\tc->operand[0] = SFE_VENDOR_DE_COMPANYID_0;\n\tc->operand[1] = SFE_VENDOR_DE_COMPANYID_1;\n\tc->operand[2] = SFE_VENDOR_DE_COMPANYID_2;\n\tc->operand[3] = SFE_VENDOR_OPCODE_HOST2CA;\n\tc->operand[4] = 0; /* slot */\n\tc->operand[5] = SFE_VENDOR_TAG_CA_PMT; /* ca tag */\n\tc->operand[6] = 0; /* more/last */\n\t/* Use three bytes for length field in case length > 127 */\n\tc->operand[10] = list_management;\n\tc->operand[11] = 0x01; /* pmt_cmd=OK_descramble */\n\n\t/* TS program map table */\n\n\tc->operand[12] = 0x02; /* Table id=2 */\n\tc->operand[13] = 0x80; /* Section syntax + length */\n\n\tc->operand[15] = msg[1]; /* Program number */\n\tc->operand[16] = msg[2];\n\tc->operand[17] = msg[3]; /* Version number and current/next */\n\tc->operand[18] = 0x00; /* Section number=0 */\n\tc->operand[19] = 0x00; /* Last section number=0 */\n\tc->operand[20] = 0x1f; /* PCR_PID=1FFF */\n\tc->operand[21] = 0xff;\n\tc->operand[22] = (program_info_length >> 8); /* Program info length */\n\tc->operand[23] = (program_info_length & 0xff);\n\n\t/* CA descriptors at programme level */\n\tread_pos = 6;\n\twrite_pos = 24;\n\tif (program_info_length > 0) {\n\t\tpmt_cmd_id = msg[read_pos++];\n\t\tif (pmt_cmd_id != 1 && pmt_cmd_id != 4)\n\t\t\tdev_err(fdtv->device,\n\t\t\t\t\"invalid pmt_cmd_id %d\\n\", pmt_cmd_id);\n\t\tif (program_info_length > sizeof(c->operand) - 4 - write_pos) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tmemcpy(&c->operand[write_pos], &msg[read_pos],\n\t\t       program_info_length);\n\t\tread_pos += program_info_length;\n\t\twrite_pos += program_info_length;\n\t}\n\twhile (read_pos < length) {\n\t\tc->operand[write_pos++] = msg[read_pos++];\n\t\tc->operand[write_pos++] = msg[read_pos++];\n\t\tc->operand[write_pos++] = msg[read_pos++];\n\t\tes_info_length =\n\t\t\t((msg[read_pos] & 0x0f) << 8) + msg[read_pos + 1];\n\t\tread_pos += 2;\n\t\tif (es_info_length > 0)\n\t\t\tes_info_length--; /* Remove pmt_cmd_id */\n\t\tc->operand[write_pos++] = es_info_length >> 8;\n\t\tc->operand[write_pos++] = es_info_length & 0xff;\n\t\tif (es_info_length > 0) {\n\t\t\tpmt_cmd_id = msg[read_pos++];\n\t\t\tif (pmt_cmd_id != 1 && pmt_cmd_id != 4)\n\t\t\t\tdev_err(fdtv->device, \"invalid pmt_cmd_id %d at stream level\\n\",\n\t\t\t\t\tpmt_cmd_id);\n\n\t\t\tif (es_info_length > sizeof(c->operand) - 4 -\n\t\t\t\t\t     write_pos) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tmemcpy(&c->operand[write_pos], &msg[read_pos],\n\t\t\t       es_info_length);\n\t\t\tread_pos += es_info_length;\n\t\t\twrite_pos += es_info_length;\n\t\t}\n\t}\n\twrite_pos += 4; /* CRC */\n\n\tc->operand[7] = 0x82;\n\tc->operand[8] = (write_pos - 10) >> 8;\n\tc->operand[9] = (write_pos - 10) & 0xff;\n\tc->operand[14] = write_pos - 15;\n\n\tcrc32_csum = crc32_be(0, &c->operand[10], c->operand[12] - 1);\n\tc->operand[write_pos - 4] = (crc32_csum >> 24) & 0xff;\n\tc->operand[write_pos - 3] = (crc32_csum >> 16) & 0xff;\n\tc->operand[write_pos - 2] = (crc32_csum >>  8) & 0xff;\n\tc->operand[write_pos - 1] = (crc32_csum >>  0) & 0xff;\n\tpad_operands(c, write_pos);\n\n\tfdtv->avc_data_length = ALIGN(3 + write_pos, 4);\n\tret = avc_write(fdtv);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (r->response != AVC_RESPONSE_ACCEPTED) {\n\t\tdev_err(fdtv->device,\n\t\t\t\"CA PMT failed with response 0x%x\\n\", r->response);\n\t\tret = -EACCES;\n\t}\nout:\n\tmutex_unlock(&fdtv->avc_mutex);\n\n\treturn ret;\n}",
        "code_after_change": "int avc_ca_pmt(struct firedtv *fdtv, char *msg, int length)\n{\n\tstruct avc_command_frame *c = (void *)fdtv->avc_data;\n\tstruct avc_response_frame *r = (void *)fdtv->avc_data;\n\tint list_management;\n\tint program_info_length;\n\tint pmt_cmd_id;\n\tint read_pos;\n\tint write_pos;\n\tint es_info_length;\n\tint crc32_csum;\n\tint ret;\n\n\tif (unlikely(avc_debug & AVC_DEBUG_APPLICATION_PMT))\n\t\tdebug_pmt(msg, length);\n\n\tmutex_lock(&fdtv->avc_mutex);\n\n\tc->ctype   = AVC_CTYPE_CONTROL;\n\tc->subunit = AVC_SUBUNIT_TYPE_TUNER | fdtv->subunit;\n\tc->opcode  = AVC_OPCODE_VENDOR;\n\n\tif (msg[0] != EN50221_LIST_MANAGEMENT_ONLY) {\n\t\tdev_info(fdtv->device, \"forcing list_management to ONLY\\n\");\n\t\tmsg[0] = EN50221_LIST_MANAGEMENT_ONLY;\n\t}\n\t/* We take the cmd_id from the programme level only! */\n\tlist_management = msg[0];\n\tprogram_info_length = ((msg[4] & 0x0f) << 8) + msg[5];\n\tif (program_info_length > 0)\n\t\tprogram_info_length--; /* Remove pmt_cmd_id */\n\tpmt_cmd_id = msg[6];\n\n\tc->operand[0] = SFE_VENDOR_DE_COMPANYID_0;\n\tc->operand[1] = SFE_VENDOR_DE_COMPANYID_1;\n\tc->operand[2] = SFE_VENDOR_DE_COMPANYID_2;\n\tc->operand[3] = SFE_VENDOR_OPCODE_HOST2CA;\n\tc->operand[4] = 0; /* slot */\n\tc->operand[5] = SFE_VENDOR_TAG_CA_PMT; /* ca tag */\n\tc->operand[6] = 0; /* more/last */\n\t/* Use three bytes for length field in case length > 127 */\n\tc->operand[10] = list_management;\n\tc->operand[11] = 0x01; /* pmt_cmd=OK_descramble */\n\n\t/* TS program map table */\n\n\tc->operand[12] = 0x02; /* Table id=2 */\n\tc->operand[13] = 0x80; /* Section syntax + length */\n\n\tc->operand[15] = msg[1]; /* Program number */\n\tc->operand[16] = msg[2];\n\tc->operand[17] = msg[3]; /* Version number and current/next */\n\tc->operand[18] = 0x00; /* Section number=0 */\n\tc->operand[19] = 0x00; /* Last section number=0 */\n\tc->operand[20] = 0x1f; /* PCR_PID=1FFF */\n\tc->operand[21] = 0xff;\n\tc->operand[22] = (program_info_length >> 8); /* Program info length */\n\tc->operand[23] = (program_info_length & 0xff);\n\n\t/* CA descriptors at programme level */\n\tread_pos = 6;\n\twrite_pos = 24;\n\tif (program_info_length > 0) {\n\t\tpmt_cmd_id = msg[read_pos++];\n\t\tif (pmt_cmd_id != 1 && pmt_cmd_id != 4)\n\t\t\tdev_err(fdtv->device,\n\t\t\t\t\"invalid pmt_cmd_id %d\\n\", pmt_cmd_id);\n\t\tif (program_info_length > sizeof(c->operand) - 4 - write_pos) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tmemcpy(&c->operand[write_pos], &msg[read_pos],\n\t\t       program_info_length);\n\t\tread_pos += program_info_length;\n\t\twrite_pos += program_info_length;\n\t}\n\twhile (read_pos + 4 < length) {\n\t\tif (write_pos + 4 >= sizeof(c->operand) - 4) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tc->operand[write_pos++] = msg[read_pos++];\n\t\tc->operand[write_pos++] = msg[read_pos++];\n\t\tc->operand[write_pos++] = msg[read_pos++];\n\t\tes_info_length =\n\t\t\t((msg[read_pos] & 0x0f) << 8) + msg[read_pos + 1];\n\t\tread_pos += 2;\n\t\tif (es_info_length > 0)\n\t\t\tes_info_length--; /* Remove pmt_cmd_id */\n\t\tc->operand[write_pos++] = es_info_length >> 8;\n\t\tc->operand[write_pos++] = es_info_length & 0xff;\n\t\tif (es_info_length > 0) {\n\t\t\tif (read_pos >= length) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tpmt_cmd_id = msg[read_pos++];\n\t\t\tif (pmt_cmd_id != 1 && pmt_cmd_id != 4)\n\t\t\t\tdev_err(fdtv->device, \"invalid pmt_cmd_id %d at stream level\\n\",\n\t\t\t\t\tpmt_cmd_id);\n\n\t\t\tif (es_info_length > sizeof(c->operand) - 4 - write_pos ||\n\t\t\t    es_info_length > length - read_pos) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tmemcpy(&c->operand[write_pos], &msg[read_pos],\n\t\t\t       es_info_length);\n\t\t\tread_pos += es_info_length;\n\t\t\twrite_pos += es_info_length;\n\t\t}\n\t}\n\twrite_pos += 4; /* CRC */\n\n\tc->operand[7] = 0x82;\n\tc->operand[8] = (write_pos - 10) >> 8;\n\tc->operand[9] = (write_pos - 10) & 0xff;\n\tc->operand[14] = write_pos - 15;\n\n\tcrc32_csum = crc32_be(0, &c->operand[10], c->operand[12] - 1);\n\tc->operand[write_pos - 4] = (crc32_csum >> 24) & 0xff;\n\tc->operand[write_pos - 3] = (crc32_csum >> 16) & 0xff;\n\tc->operand[write_pos - 2] = (crc32_csum >>  8) & 0xff;\n\tc->operand[write_pos - 1] = (crc32_csum >>  0) & 0xff;\n\tpad_operands(c, write_pos);\n\n\tfdtv->avc_data_length = ALIGN(3 + write_pos, 4);\n\tret = avc_write(fdtv);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (r->response != AVC_RESPONSE_ACCEPTED) {\n\t\tdev_err(fdtv->device,\n\t\t\t\"CA PMT failed with response 0x%x\\n\", r->response);\n\t\tret = -EACCES;\n\t}\nout:\n\tmutex_unlock(&fdtv->avc_mutex);\n\n\treturn ret;\n}",
        "patch": "--- code before\n+++ code after\n@@ -75,7 +75,11 @@\n \t\tread_pos += program_info_length;\n \t\twrite_pos += program_info_length;\n \t}\n-\twhile (read_pos < length) {\n+\twhile (read_pos + 4 < length) {\n+\t\tif (write_pos + 4 >= sizeof(c->operand) - 4) {\n+\t\t\tret = -EINVAL;\n+\t\t\tgoto out;\n+\t\t}\n \t\tc->operand[write_pos++] = msg[read_pos++];\n \t\tc->operand[write_pos++] = msg[read_pos++];\n \t\tc->operand[write_pos++] = msg[read_pos++];\n@@ -87,13 +91,17 @@\n \t\tc->operand[write_pos++] = es_info_length >> 8;\n \t\tc->operand[write_pos++] = es_info_length & 0xff;\n \t\tif (es_info_length > 0) {\n+\t\t\tif (read_pos >= length) {\n+\t\t\t\tret = -EINVAL;\n+\t\t\t\tgoto out;\n+\t\t\t}\n \t\t\tpmt_cmd_id = msg[read_pos++];\n \t\t\tif (pmt_cmd_id != 1 && pmt_cmd_id != 4)\n \t\t\t\tdev_err(fdtv->device, \"invalid pmt_cmd_id %d at stream level\\n\",\n \t\t\t\t\tpmt_cmd_id);\n \n-\t\t\tif (es_info_length > sizeof(c->operand) - 4 -\n-\t\t\t\t\t     write_pos) {\n+\t\t\tif (es_info_length > sizeof(c->operand) - 4 - write_pos ||\n+\t\t\t    es_info_length > length - read_pos) {\n \t\t\t\tret = -EINVAL;\n \t\t\t\tgoto out;\n \t\t\t}",
        "function_modified_lines": {
            "added": [
                "\twhile (read_pos + 4 < length) {",
                "\t\tif (write_pos + 4 >= sizeof(c->operand) - 4) {",
                "\t\t\tret = -EINVAL;",
                "\t\t\tgoto out;",
                "\t\t}",
                "\t\t\tif (read_pos >= length) {",
                "\t\t\t\tret = -EINVAL;",
                "\t\t\t\tgoto out;",
                "\t\t\t}",
                "\t\t\tif (es_info_length > sizeof(c->operand) - 4 - write_pos ||",
                "\t\t\t    es_info_length > length - read_pos) {"
            ],
            "deleted": [
                "\twhile (read_pos < length) {",
                "\t\t\tif (es_info_length > sizeof(c->operand) - 4 -",
                "\t\t\t\t\t     write_pos) {"
            ]
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "A heap-based buffer overflow flaw was found in the Linux kernel FireDTV media card driver, where the user calls the CA_SEND_MSG ioctl. This flaw allows a local user of the host machine to crash the system or escalate privileges on the system. The highest threat from this vulnerability is to confidentiality, integrity, as well as system availability.",
        "id": 3157
    },
    {
        "cve_id": "CVE-2020-8835",
        "code_before_change": "static void reg_set_min_max_inv(struct bpf_reg_state *true_reg,\n\t\t\t\tstruct bpf_reg_state *false_reg, u64 val,\n\t\t\t\tu8 opcode, bool is_jmp32)\n{\n\ts64 sval;\n\n\tif (__is_pointer_value(false, false_reg))\n\t\treturn;\n\n\tval = is_jmp32 ? (u32)val : val;\n\tsval = is_jmp32 ? (s64)(s32)val : (s64)val;\n\n\tswitch (opcode) {\n\tcase BPF_JEQ:\n\tcase BPF_JNE:\n\t{\n\t\tstruct bpf_reg_state *reg =\n\t\t\topcode == BPF_JEQ ? true_reg : false_reg;\n\n\t\tif (is_jmp32) {\n\t\t\tu64 old_v = reg->var_off.value;\n\t\t\tu64 hi_mask = ~0xffffffffULL;\n\n\t\t\treg->var_off.value = (old_v & hi_mask) | val;\n\t\t\treg->var_off.mask &= hi_mask;\n\t\t} else {\n\t\t\t__mark_reg_known(reg, val);\n\t\t}\n\t\tbreak;\n\t}\n\tcase BPF_JSET:\n\t\tfalse_reg->var_off = tnum_and(false_reg->var_off,\n\t\t\t\t\t      tnum_const(~val));\n\t\tif (is_power_of_2(val))\n\t\t\ttrue_reg->var_off = tnum_or(true_reg->var_off,\n\t\t\t\t\t\t    tnum_const(val));\n\t\tbreak;\n\tcase BPF_JGE:\n\tcase BPF_JGT:\n\t{\n\t\tu64 false_umin = opcode == BPF_JGT ? val    : val + 1;\n\t\tu64 true_umax = opcode == BPF_JGT ? val - 1 : val;\n\n\t\tif (is_jmp32) {\n\t\t\tfalse_umin += gen_hi_min(false_reg->var_off);\n\t\t\ttrue_umax += gen_hi_max(true_reg->var_off);\n\t\t}\n\t\tfalse_reg->umin_value = max(false_reg->umin_value, false_umin);\n\t\ttrue_reg->umax_value = min(true_reg->umax_value, true_umax);\n\t\tbreak;\n\t}\n\tcase BPF_JSGE:\n\tcase BPF_JSGT:\n\t{\n\t\ts64 false_smin = opcode == BPF_JSGT ? sval    : sval + 1;\n\t\ts64 true_smax = opcode == BPF_JSGT ? sval - 1 : sval;\n\n\t\tif (is_jmp32 && !cmp_val_with_extended_s64(sval, false_reg))\n\t\t\tbreak;\n\t\tfalse_reg->smin_value = max(false_reg->smin_value, false_smin);\n\t\ttrue_reg->smax_value = min(true_reg->smax_value, true_smax);\n\t\tbreak;\n\t}\n\tcase BPF_JLE:\n\tcase BPF_JLT:\n\t{\n\t\tu64 false_umax = opcode == BPF_JLT ? val    : val - 1;\n\t\tu64 true_umin = opcode == BPF_JLT ? val + 1 : val;\n\n\t\tif (is_jmp32) {\n\t\t\tfalse_umax += gen_hi_max(false_reg->var_off);\n\t\t\ttrue_umin += gen_hi_min(true_reg->var_off);\n\t\t}\n\t\tfalse_reg->umax_value = min(false_reg->umax_value, false_umax);\n\t\ttrue_reg->umin_value = max(true_reg->umin_value, true_umin);\n\t\tbreak;\n\t}\n\tcase BPF_JSLE:\n\tcase BPF_JSLT:\n\t{\n\t\ts64 false_smax = opcode == BPF_JSLT ? sval    : sval - 1;\n\t\ts64 true_smin = opcode == BPF_JSLT ? sval + 1 : sval;\n\n\t\tif (is_jmp32 && !cmp_val_with_extended_s64(sval, false_reg))\n\t\t\tbreak;\n\t\tfalse_reg->smax_value = min(false_reg->smax_value, false_smax);\n\t\ttrue_reg->smin_value = max(true_reg->smin_value, true_smin);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n\n\t__reg_deduce_bounds(false_reg);\n\t__reg_deduce_bounds(true_reg);\n\t/* We might have learned some bits from the bounds. */\n\t__reg_bound_offset(false_reg);\n\t__reg_bound_offset(true_reg);\n\tif (is_jmp32) {\n\t\t__reg_bound_offset32(false_reg);\n\t\t__reg_bound_offset32(true_reg);\n\t}\n\t/* Intersecting with the old var_off might have improved our bounds\n\t * slightly.  e.g. if umax was 0x7f...f and var_off was (0; 0xf...fc),\n\t * then new var_off is (0; 0x7f...fc) which improves our umax.\n\t */\n\t__update_reg_bounds(false_reg);\n\t__update_reg_bounds(true_reg);\n}",
        "code_after_change": "static void reg_set_min_max_inv(struct bpf_reg_state *true_reg,\n\t\t\t\tstruct bpf_reg_state *false_reg, u64 val,\n\t\t\t\tu8 opcode, bool is_jmp32)\n{\n\ts64 sval;\n\n\tif (__is_pointer_value(false, false_reg))\n\t\treturn;\n\n\tval = is_jmp32 ? (u32)val : val;\n\tsval = is_jmp32 ? (s64)(s32)val : (s64)val;\n\n\tswitch (opcode) {\n\tcase BPF_JEQ:\n\tcase BPF_JNE:\n\t{\n\t\tstruct bpf_reg_state *reg =\n\t\t\topcode == BPF_JEQ ? true_reg : false_reg;\n\n\t\tif (is_jmp32) {\n\t\t\tu64 old_v = reg->var_off.value;\n\t\t\tu64 hi_mask = ~0xffffffffULL;\n\n\t\t\treg->var_off.value = (old_v & hi_mask) | val;\n\t\t\treg->var_off.mask &= hi_mask;\n\t\t} else {\n\t\t\t__mark_reg_known(reg, val);\n\t\t}\n\t\tbreak;\n\t}\n\tcase BPF_JSET:\n\t\tfalse_reg->var_off = tnum_and(false_reg->var_off,\n\t\t\t\t\t      tnum_const(~val));\n\t\tif (is_power_of_2(val))\n\t\t\ttrue_reg->var_off = tnum_or(true_reg->var_off,\n\t\t\t\t\t\t    tnum_const(val));\n\t\tbreak;\n\tcase BPF_JGE:\n\tcase BPF_JGT:\n\t{\n\t\tu64 false_umin = opcode == BPF_JGT ? val    : val + 1;\n\t\tu64 true_umax = opcode == BPF_JGT ? val - 1 : val;\n\n\t\tif (is_jmp32) {\n\t\t\tfalse_umin += gen_hi_min(false_reg->var_off);\n\t\t\ttrue_umax += gen_hi_max(true_reg->var_off);\n\t\t}\n\t\tfalse_reg->umin_value = max(false_reg->umin_value, false_umin);\n\t\ttrue_reg->umax_value = min(true_reg->umax_value, true_umax);\n\t\tbreak;\n\t}\n\tcase BPF_JSGE:\n\tcase BPF_JSGT:\n\t{\n\t\ts64 false_smin = opcode == BPF_JSGT ? sval    : sval + 1;\n\t\ts64 true_smax = opcode == BPF_JSGT ? sval - 1 : sval;\n\n\t\tif (is_jmp32 && !cmp_val_with_extended_s64(sval, false_reg))\n\t\t\tbreak;\n\t\tfalse_reg->smin_value = max(false_reg->smin_value, false_smin);\n\t\ttrue_reg->smax_value = min(true_reg->smax_value, true_smax);\n\t\tbreak;\n\t}\n\tcase BPF_JLE:\n\tcase BPF_JLT:\n\t{\n\t\tu64 false_umax = opcode == BPF_JLT ? val    : val - 1;\n\t\tu64 true_umin = opcode == BPF_JLT ? val + 1 : val;\n\n\t\tif (is_jmp32) {\n\t\t\tfalse_umax += gen_hi_max(false_reg->var_off);\n\t\t\ttrue_umin += gen_hi_min(true_reg->var_off);\n\t\t}\n\t\tfalse_reg->umax_value = min(false_reg->umax_value, false_umax);\n\t\ttrue_reg->umin_value = max(true_reg->umin_value, true_umin);\n\t\tbreak;\n\t}\n\tcase BPF_JSLE:\n\tcase BPF_JSLT:\n\t{\n\t\ts64 false_smax = opcode == BPF_JSLT ? sval    : sval - 1;\n\t\ts64 true_smin = opcode == BPF_JSLT ? sval + 1 : sval;\n\n\t\tif (is_jmp32 && !cmp_val_with_extended_s64(sval, false_reg))\n\t\t\tbreak;\n\t\tfalse_reg->smax_value = min(false_reg->smax_value, false_smax);\n\t\ttrue_reg->smin_value = max(true_reg->smin_value, true_smin);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n\n\t__reg_deduce_bounds(false_reg);\n\t__reg_deduce_bounds(true_reg);\n\t/* We might have learned some bits from the bounds. */\n\t__reg_bound_offset(false_reg);\n\t__reg_bound_offset(true_reg);\n\t/* Intersecting with the old var_off might have improved our bounds\n\t * slightly.  e.g. if umax was 0x7f...f and var_off was (0; 0xf...fc),\n\t * then new var_off is (0; 0x7f...fc) which improves our umax.\n\t */\n\t__update_reg_bounds(false_reg);\n\t__update_reg_bounds(true_reg);\n}",
        "patch": "--- code before\n+++ code after\n@@ -96,10 +96,6 @@\n \t/* We might have learned some bits from the bounds. */\n \t__reg_bound_offset(false_reg);\n \t__reg_bound_offset(true_reg);\n-\tif (is_jmp32) {\n-\t\t__reg_bound_offset32(false_reg);\n-\t\t__reg_bound_offset32(true_reg);\n-\t}\n \t/* Intersecting with the old var_off might have improved our bounds\n \t * slightly.  e.g. if umax was 0x7f...f and var_off was (0; 0xf...fc),\n \t * then new var_off is (0; 0x7f...fc) which improves our umax.",
        "function_modified_lines": {
            "added": [],
            "deleted": [
                "\tif (is_jmp32) {",
                "\t\t__reg_bound_offset32(false_reg);",
                "\t\t__reg_bound_offset32(true_reg);",
                "\t}"
            ]
        },
        "cwe": [
            "CWE-125",
            "CWE-787"
        ],
        "cve_description": "In the Linux kernel 5.5.0 and newer, the bpf verifier (kernel/bpf/verifier.c) did not properly restrict the register bounds for 32-bit operations, leading to out-of-bounds reads and writes in kernel memory. The vulnerability also affects the Linux 5.4 stable series, starting with v5.4.7, as the introducing commit was backported to that branch. This vulnerability was fixed in 5.6.1, 5.5.14, and 5.4.29. (issue is aka ZDI-CAN-10780)",
        "id": 2808
    },
    {
        "cve_id": "CVE-2016-9755",
        "code_before_change": "int nf_ct_frag6_gather(struct net *net, struct sk_buff *skb, u32 user)\n{\n\tstruct net_device *dev = skb->dev;\n\tint fhoff, nhoff, ret;\n\tstruct frag_hdr *fhdr;\n\tstruct frag_queue *fq;\n\tstruct ipv6hdr *hdr;\n\tu8 prevhdr;\n\n\t/* Jumbo payload inhibits frag. header */\n\tif (ipv6_hdr(skb)->payload_len == 0) {\n\t\tpr_debug(\"payload len = 0\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (find_prev_fhdr(skb, &prevhdr, &nhoff, &fhoff) < 0)\n\t\treturn -EINVAL;\n\n\tif (!pskb_may_pull(skb, fhoff + sizeof(*fhdr)))\n\t\treturn -ENOMEM;\n\n\tskb_set_transport_header(skb, fhoff);\n\thdr = ipv6_hdr(skb);\n\tfhdr = (struct frag_hdr *)skb_transport_header(skb);\n\n\tfq = fq_find(net, fhdr->identification, user, &hdr->saddr, &hdr->daddr,\n\t\t     skb->dev ? skb->dev->ifindex : 0, ip6_frag_ecn(hdr));\n\tif (fq == NULL) {\n\t\tpr_debug(\"Can't find and can't create new queue\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock_bh(&fq->q.lock);\n\n\tif (nf_ct_frag6_queue(fq, skb, fhdr, nhoff) < 0) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\t/* after queue has assumed skb ownership, only 0 or -EINPROGRESS\n\t * must be returned.\n\t */\n\tret = -EINPROGRESS;\n\tif (fq->q.flags == (INET_FRAG_FIRST_IN | INET_FRAG_LAST_IN) &&\n\t    fq->q.meat == fq->q.len &&\n\t    nf_ct_frag6_reasm(fq, skb, dev))\n\t\tret = 0;\n\nout_unlock:\n\tspin_unlock_bh(&fq->q.lock);\n\tinet_frag_put(&fq->q, &nf_frags);\n\treturn ret;\n}",
        "code_after_change": "int nf_ct_frag6_gather(struct net *net, struct sk_buff *skb, u32 user)\n{\n\tstruct net_device *dev = skb->dev;\n\tint fhoff, nhoff, ret;\n\tstruct frag_hdr *fhdr;\n\tstruct frag_queue *fq;\n\tstruct ipv6hdr *hdr;\n\tu8 prevhdr;\n\n\t/* Jumbo payload inhibits frag. header */\n\tif (ipv6_hdr(skb)->payload_len == 0) {\n\t\tpr_debug(\"payload len = 0\\n\");\n\t\treturn 0;\n\t}\n\n\tif (find_prev_fhdr(skb, &prevhdr, &nhoff, &fhoff) < 0)\n\t\treturn 0;\n\n\tif (!pskb_may_pull(skb, fhoff + sizeof(*fhdr)))\n\t\treturn -ENOMEM;\n\n\tskb_set_transport_header(skb, fhoff);\n\thdr = ipv6_hdr(skb);\n\tfhdr = (struct frag_hdr *)skb_transport_header(skb);\n\n\tfq = fq_find(net, fhdr->identification, user, &hdr->saddr, &hdr->daddr,\n\t\t     skb->dev ? skb->dev->ifindex : 0, ip6_frag_ecn(hdr));\n\tif (fq == NULL) {\n\t\tpr_debug(\"Can't find and can't create new queue\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock_bh(&fq->q.lock);\n\n\tif (nf_ct_frag6_queue(fq, skb, fhdr, nhoff) < 0) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\t/* after queue has assumed skb ownership, only 0 or -EINPROGRESS\n\t * must be returned.\n\t */\n\tret = -EINPROGRESS;\n\tif (fq->q.flags == (INET_FRAG_FIRST_IN | INET_FRAG_LAST_IN) &&\n\t    fq->q.meat == fq->q.len &&\n\t    nf_ct_frag6_reasm(fq, skb, dev))\n\t\tret = 0;\n\nout_unlock:\n\tspin_unlock_bh(&fq->q.lock);\n\tinet_frag_put(&fq->q, &nf_frags);\n\treturn ret;\n}",
        "patch": "--- code before\n+++ code after\n@@ -10,11 +10,11 @@\n \t/* Jumbo payload inhibits frag. header */\n \tif (ipv6_hdr(skb)->payload_len == 0) {\n \t\tpr_debug(\"payload len = 0\\n\");\n-\t\treturn -EINVAL;\n+\t\treturn 0;\n \t}\n \n \tif (find_prev_fhdr(skb, &prevhdr, &nhoff, &fhoff) < 0)\n-\t\treturn -EINVAL;\n+\t\treturn 0;\n \n \tif (!pskb_may_pull(skb, fhoff + sizeof(*fhdr)))\n \t\treturn -ENOMEM;",
        "function_modified_lines": {
            "added": [
                "\t\treturn 0;",
                "\t\treturn 0;"
            ],
            "deleted": [
                "\t\treturn -EINVAL;",
                "\t\treturn -EINVAL;"
            ]
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "The netfilter subsystem in the Linux kernel before 4.9 mishandles IPv6 reassembly, which allows local users to cause a denial of service (integer overflow, out-of-bounds write, and GPF) or possibly have unspecified other impact via a crafted application that makes socket, connect, and writev system calls, related to net/ipv6/netfilter/nf_conntrack_reasm.c and net/ipv6/netfilter/nf_defrag_ipv6_hooks.c.",
        "id": 1162
    },
    {
        "cve_id": "CVE-2019-19319",
        "code_before_change": "static int __check_block_validity(struct inode *inode, const char *func,\n\t\t\t\tunsigned int line,\n\t\t\t\tstruct ext4_map_blocks *map)\n{\n\tif (!ext4_data_block_valid(EXT4_SB(inode->i_sb), map->m_pblk,\n\t\t\t\t   map->m_len)) {\n\t\text4_error_inode(inode, func, line, map->m_pblk,\n\t\t\t\t \"lblock %lu mapped to illegal pblock %llu \"\n\t\t\t\t \"(length %d)\", (unsigned long) map->m_lblk,\n\t\t\t\t map->m_pblk, map->m_len);\n\t\treturn -EFSCORRUPTED;\n\t}\n\treturn 0;\n}",
        "code_after_change": "static int __check_block_validity(struct inode *inode, const char *func,\n\t\t\t\tunsigned int line,\n\t\t\t\tstruct ext4_map_blocks *map)\n{\n\tif (ext4_has_feature_journal(inode->i_sb) &&\n\t    (inode->i_ino ==\n\t     le32_to_cpu(EXT4_SB(inode->i_sb)->s_es->s_journal_inum)))\n\t\treturn 0;\n\tif (!ext4_data_block_valid(EXT4_SB(inode->i_sb), map->m_pblk,\n\t\t\t\t   map->m_len)) {\n\t\text4_error_inode(inode, func, line, map->m_pblk,\n\t\t\t\t \"lblock %lu mapped to illegal pblock %llu \"\n\t\t\t\t \"(length %d)\", (unsigned long) map->m_lblk,\n\t\t\t\t map->m_pblk, map->m_len);\n\t\treturn -EFSCORRUPTED;\n\t}\n\treturn 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -2,6 +2,10 @@\n \t\t\t\tunsigned int line,\n \t\t\t\tstruct ext4_map_blocks *map)\n {\n+\tif (ext4_has_feature_journal(inode->i_sb) &&\n+\t    (inode->i_ino ==\n+\t     le32_to_cpu(EXT4_SB(inode->i_sb)->s_es->s_journal_inum)))\n+\t\treturn 0;\n \tif (!ext4_data_block_valid(EXT4_SB(inode->i_sb), map->m_pblk,\n \t\t\t\t   map->m_len)) {\n \t\text4_error_inode(inode, func, line, map->m_pblk,",
        "function_modified_lines": {
            "added": [
                "\tif (ext4_has_feature_journal(inode->i_sb) &&",
                "\t    (inode->i_ino ==",
                "\t     le32_to_cpu(EXT4_SB(inode->i_sb)->s_es->s_journal_inum)))",
                "\t\treturn 0;"
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-787",
            "CWE-416"
        ],
        "cve_description": "In the Linux kernel before 5.2, a setxattr operation, after a mount of a crafted ext4 image, can cause a slab-out-of-bounds write access because of an ext4_xattr_set_entry use-after-free in fs/ext4/xattr.c when a large old_size value is used in a memset call, aka CID-345c0dbf3a30.",
        "id": 2189
    },
    {
        "cve_id": "CVE-2021-3612",
        "code_before_change": "static int joydev_handle_JSIOCSBTNMAP(struct joydev *joydev,\n\t\t\t\t      void __user *argp, size_t len)\n{\n\t__u16 *keypam;\n\tint i;\n\tint retval = 0;\n\n\tlen = min(len, sizeof(joydev->keypam));\n\n\t/* Validate the map. */\n\tkeypam = memdup_user(argp, len);\n\tif (IS_ERR(keypam))\n\t\treturn PTR_ERR(keypam);\n\n\tfor (i = 0; i < joydev->nkey; i++) {\n\t\tif (keypam[i] > KEY_MAX || keypam[i] < BTN_MISC) {\n\t\t\tretval = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tmemcpy(joydev->keypam, keypam, len);\n\n\tfor (i = 0; i < joydev->nkey; i++)\n\t\tjoydev->keymap[keypam[i] - BTN_MISC] = i;\n\n out:\n\tkfree(keypam);\n\treturn retval;\n}",
        "code_after_change": "static int joydev_handle_JSIOCSBTNMAP(struct joydev *joydev,\n\t\t\t\t      void __user *argp, size_t len)\n{\n\t__u16 *keypam;\n\tint i;\n\tint retval = 0;\n\n\tif (len % sizeof(*keypam))\n\t\treturn -EINVAL;\n\n\tlen = min(len, sizeof(joydev->keypam));\n\n\t/* Validate the map. */\n\tkeypam = memdup_user(argp, len);\n\tif (IS_ERR(keypam))\n\t\treturn PTR_ERR(keypam);\n\n\tfor (i = 0; i < (len / 2) && i < joydev->nkey; i++) {\n\t\tif (keypam[i] > KEY_MAX || keypam[i] < BTN_MISC) {\n\t\t\tretval = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tmemcpy(joydev->keypam, keypam, len);\n\n\tfor (i = 0; i < joydev->nkey; i++)\n\t\tjoydev->keymap[keypam[i] - BTN_MISC] = i;\n\n out:\n\tkfree(keypam);\n\treturn retval;\n}",
        "patch": "--- code before\n+++ code after\n@@ -4,6 +4,9 @@\n \t__u16 *keypam;\n \tint i;\n \tint retval = 0;\n+\n+\tif (len % sizeof(*keypam))\n+\t\treturn -EINVAL;\n \n \tlen = min(len, sizeof(joydev->keypam));\n \n@@ -12,7 +15,7 @@\n \tif (IS_ERR(keypam))\n \t\treturn PTR_ERR(keypam);\n \n-\tfor (i = 0; i < joydev->nkey; i++) {\n+\tfor (i = 0; i < (len / 2) && i < joydev->nkey; i++) {\n \t\tif (keypam[i] > KEY_MAX || keypam[i] < BTN_MISC) {\n \t\t\tretval = -EINVAL;\n \t\t\tgoto out;",
        "function_modified_lines": {
            "added": [
                "",
                "\tif (len % sizeof(*keypam))",
                "\t\treturn -EINVAL;",
                "\tfor (i = 0; i < (len / 2) && i < joydev->nkey; i++) {"
            ],
            "deleted": [
                "\tfor (i = 0; i < joydev->nkey; i++) {"
            ]
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "An out-of-bounds memory write flaw was found in the Linux kernel's joystick devices subsystem in versions before 5.9-rc1, in the way the user calls ioctl JSIOCSBTNMAP. This flaw allows a local user to crash the system or possibly escalate their privileges on the system. The highest threat from this vulnerability is to confidentiality, integrity, as well as system availability.",
        "id": 3023
    },
    {
        "cve_id": "CVE-2021-4093",
        "code_before_change": "static int complete_sev_es_emulated_ins(struct kvm_vcpu *vcpu)\n{\n\tmemcpy(vcpu->arch.sev_pio_data, vcpu->arch.pio_data,\n\t       vcpu->arch.pio.count * vcpu->arch.pio.size);\n\tvcpu->arch.pio.count = 0;\n\n\treturn 1;\n}",
        "code_after_change": "static int complete_sev_es_emulated_ins(struct kvm_vcpu *vcpu)\n{\n\tint size = vcpu->arch.pio.size;\n\tint port = vcpu->arch.pio.port;\n\n\tadvance_sev_es_emulated_ins(vcpu);\n\tif (vcpu->arch.sev_pio_count)\n\t\treturn kvm_sev_es_ins(vcpu, size, port);\n\treturn 1;\n}",
        "patch": "--- code before\n+++ code after\n@@ -1,8 +1,10 @@\n static int complete_sev_es_emulated_ins(struct kvm_vcpu *vcpu)\n {\n-\tmemcpy(vcpu->arch.sev_pio_data, vcpu->arch.pio_data,\n-\t       vcpu->arch.pio.count * vcpu->arch.pio.size);\n-\tvcpu->arch.pio.count = 0;\n+\tint size = vcpu->arch.pio.size;\n+\tint port = vcpu->arch.pio.port;\n \n+\tadvance_sev_es_emulated_ins(vcpu);\n+\tif (vcpu->arch.sev_pio_count)\n+\t\treturn kvm_sev_es_ins(vcpu, size, port);\n \treturn 1;\n }",
        "function_modified_lines": {
            "added": [
                "\tint size = vcpu->arch.pio.size;",
                "\tint port = vcpu->arch.pio.port;",
                "\tadvance_sev_es_emulated_ins(vcpu);",
                "\tif (vcpu->arch.sev_pio_count)",
                "\t\treturn kvm_sev_es_ins(vcpu, size, port);"
            ],
            "deleted": [
                "\tmemcpy(vcpu->arch.sev_pio_data, vcpu->arch.pio_data,",
                "\t       vcpu->arch.pio.count * vcpu->arch.pio.size);",
                "\tvcpu->arch.pio.count = 0;"
            ]
        },
        "cwe": [
            "CWE-125",
            "CWE-787"
        ],
        "cve_description": "A flaw was found in the KVM's AMD code for supporting the Secure Encrypted Virtualization-Encrypted State (SEV-ES). A KVM guest using SEV-ES can trigger out-of-bounds reads and writes in the host kernel via a malicious VMGEXIT for a string I/O instruction (for example, outs or ins) using the exit reason SVM_EXIT_IOIO. This issue results in a crash of the entire system or a potential guest-to-host escape scenario.",
        "id": 3130
    },
    {
        "cve_id": "CVE-2023-21255",
        "code_before_change": "static int binder_proc_transaction(struct binder_transaction *t,\n\t\t\t\t    struct binder_proc *proc,\n\t\t\t\t    struct binder_thread *thread)\n{\n\tstruct binder_node *node = t->buffer->target_node;\n\tbool oneway = !!(t->flags & TF_ONE_WAY);\n\tbool pending_async = false;\n\tstruct binder_transaction *t_outdated = NULL;\n\tbool frozen = false;\n\n\tBUG_ON(!node);\n\tbinder_node_lock(node);\n\tif (oneway) {\n\t\tBUG_ON(thread);\n\t\tif (node->has_async_transaction)\n\t\t\tpending_async = true;\n\t\telse\n\t\t\tnode->has_async_transaction = true;\n\t}\n\n\tbinder_inner_proc_lock(proc);\n\tif (proc->is_frozen) {\n\t\tfrozen = true;\n\t\tproc->sync_recv |= !oneway;\n\t\tproc->async_recv |= oneway;\n\t}\n\n\tif ((frozen && !oneway) || proc->is_dead ||\n\t\t\t(thread && thread->is_dead)) {\n\t\tbinder_inner_proc_unlock(proc);\n\t\tbinder_node_unlock(node);\n\t\treturn frozen ? BR_FROZEN_REPLY : BR_DEAD_REPLY;\n\t}\n\n\tif (!thread && !pending_async)\n\t\tthread = binder_select_thread_ilocked(proc);\n\n\tif (thread) {\n\t\tbinder_enqueue_thread_work_ilocked(thread, &t->work);\n\t} else if (!pending_async) {\n\t\tbinder_enqueue_work_ilocked(&t->work, &proc->todo);\n\t} else {\n\t\tif ((t->flags & TF_UPDATE_TXN) && frozen) {\n\t\t\tt_outdated = binder_find_outdated_transaction_ilocked(t,\n\t\t\t\t\t\t\t\t\t      &node->async_todo);\n\t\t\tif (t_outdated) {\n\t\t\t\tbinder_debug(BINDER_DEBUG_TRANSACTION,\n\t\t\t\t\t     \"txn %d supersedes %d\\n\",\n\t\t\t\t\t     t->debug_id, t_outdated->debug_id);\n\t\t\t\tlist_del_init(&t_outdated->work.entry);\n\t\t\t\tproc->outstanding_txns--;\n\t\t\t}\n\t\t}\n\t\tbinder_enqueue_work_ilocked(&t->work, &node->async_todo);\n\t}\n\n\tif (!pending_async)\n\t\tbinder_wakeup_thread_ilocked(proc, thread, !oneway /* sync */);\n\n\tproc->outstanding_txns++;\n\tbinder_inner_proc_unlock(proc);\n\tbinder_node_unlock(node);\n\n\t/*\n\t * To reduce potential contention, free the outdated transaction and\n\t * buffer after releasing the locks.\n\t */\n\tif (t_outdated) {\n\t\tstruct binder_buffer *buffer = t_outdated->buffer;\n\n\t\tt_outdated->buffer = NULL;\n\t\tbuffer->transaction = NULL;\n\t\ttrace_binder_transaction_update_buffer_release(buffer);\n\t\tbinder_transaction_buffer_release(proc, NULL, buffer, 0, 0);\n\t\tbinder_alloc_free_buf(&proc->alloc, buffer);\n\t\tkfree(t_outdated);\n\t\tbinder_stats_deleted(BINDER_STAT_TRANSACTION);\n\t}\n\n\tif (oneway && frozen)\n\t\treturn BR_TRANSACTION_PENDING_FROZEN;\n\n\treturn 0;\n}",
        "code_after_change": "static int binder_proc_transaction(struct binder_transaction *t,\n\t\t\t\t    struct binder_proc *proc,\n\t\t\t\t    struct binder_thread *thread)\n{\n\tstruct binder_node *node = t->buffer->target_node;\n\tbool oneway = !!(t->flags & TF_ONE_WAY);\n\tbool pending_async = false;\n\tstruct binder_transaction *t_outdated = NULL;\n\tbool frozen = false;\n\n\tBUG_ON(!node);\n\tbinder_node_lock(node);\n\tif (oneway) {\n\t\tBUG_ON(thread);\n\t\tif (node->has_async_transaction)\n\t\t\tpending_async = true;\n\t\telse\n\t\t\tnode->has_async_transaction = true;\n\t}\n\n\tbinder_inner_proc_lock(proc);\n\tif (proc->is_frozen) {\n\t\tfrozen = true;\n\t\tproc->sync_recv |= !oneway;\n\t\tproc->async_recv |= oneway;\n\t}\n\n\tif ((frozen && !oneway) || proc->is_dead ||\n\t\t\t(thread && thread->is_dead)) {\n\t\tbinder_inner_proc_unlock(proc);\n\t\tbinder_node_unlock(node);\n\t\treturn frozen ? BR_FROZEN_REPLY : BR_DEAD_REPLY;\n\t}\n\n\tif (!thread && !pending_async)\n\t\tthread = binder_select_thread_ilocked(proc);\n\n\tif (thread) {\n\t\tbinder_enqueue_thread_work_ilocked(thread, &t->work);\n\t} else if (!pending_async) {\n\t\tbinder_enqueue_work_ilocked(&t->work, &proc->todo);\n\t} else {\n\t\tif ((t->flags & TF_UPDATE_TXN) && frozen) {\n\t\t\tt_outdated = binder_find_outdated_transaction_ilocked(t,\n\t\t\t\t\t\t\t\t\t      &node->async_todo);\n\t\t\tif (t_outdated) {\n\t\t\t\tbinder_debug(BINDER_DEBUG_TRANSACTION,\n\t\t\t\t\t     \"txn %d supersedes %d\\n\",\n\t\t\t\t\t     t->debug_id, t_outdated->debug_id);\n\t\t\t\tlist_del_init(&t_outdated->work.entry);\n\t\t\t\tproc->outstanding_txns--;\n\t\t\t}\n\t\t}\n\t\tbinder_enqueue_work_ilocked(&t->work, &node->async_todo);\n\t}\n\n\tif (!pending_async)\n\t\tbinder_wakeup_thread_ilocked(proc, thread, !oneway /* sync */);\n\n\tproc->outstanding_txns++;\n\tbinder_inner_proc_unlock(proc);\n\tbinder_node_unlock(node);\n\n\t/*\n\t * To reduce potential contention, free the outdated transaction and\n\t * buffer after releasing the locks.\n\t */\n\tif (t_outdated) {\n\t\tstruct binder_buffer *buffer = t_outdated->buffer;\n\n\t\tt_outdated->buffer = NULL;\n\t\tbuffer->transaction = NULL;\n\t\ttrace_binder_transaction_update_buffer_release(buffer);\n\t\tbinder_release_entire_buffer(proc, NULL, buffer, false);\n\t\tbinder_alloc_free_buf(&proc->alloc, buffer);\n\t\tkfree(t_outdated);\n\t\tbinder_stats_deleted(BINDER_STAT_TRANSACTION);\n\t}\n\n\tif (oneway && frozen)\n\t\treturn BR_TRANSACTION_PENDING_FROZEN;\n\n\treturn 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -71,7 +71,7 @@\n \t\tt_outdated->buffer = NULL;\n \t\tbuffer->transaction = NULL;\n \t\ttrace_binder_transaction_update_buffer_release(buffer);\n-\t\tbinder_transaction_buffer_release(proc, NULL, buffer, 0, 0);\n+\t\tbinder_release_entire_buffer(proc, NULL, buffer, false);\n \t\tbinder_alloc_free_buf(&proc->alloc, buffer);\n \t\tkfree(t_outdated);\n \t\tbinder_stats_deleted(BINDER_STAT_TRANSACTION);",
        "function_modified_lines": {
            "added": [
                "\t\tbinder_release_entire_buffer(proc, NULL, buffer, false);"
            ],
            "deleted": [
                "\t\tbinder_transaction_buffer_release(proc, NULL, buffer, 0, 0);"
            ]
        },
        "cwe": [
            "CWE-787",
            "CWE-416"
        ],
        "cve_description": "In multiple functions of binder.c, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.\n\n",
        "id": 3917
    }
]