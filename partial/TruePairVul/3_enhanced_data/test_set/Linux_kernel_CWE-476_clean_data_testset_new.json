[
    {
        "cve_id": "CVE-2017-15116",
        "code_before_change": "static int crypto_rng_init_tfm(struct crypto_tfm *tfm)\n{\n\tstruct crypto_rng *rng = __crypto_rng_cast(tfm);\n\tstruct rng_alg *alg = crypto_rng_alg(rng);\n\tstruct old_rng_alg *oalg = crypto_old_rng_alg(rng);\n\n\tif (oalg->rng_make_random) {\n\t\trng->generate = generate;\n\t\trng->seed = rngapi_reset;\n\t\trng->seedsize = oalg->seedsize;\n\t\treturn 0;\n\t}\n\n\trng->generate = alg->generate;\n\trng->seed = alg->seed;\n\trng->seedsize = alg->seedsize;\n\n\treturn 0;\n}",
        "code_after_change": "static int crypto_rng_init_tfm(struct crypto_tfm *tfm)\n{\n\treturn 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -1,19 +1,4 @@\n static int crypto_rng_init_tfm(struct crypto_tfm *tfm)\n {\n-\tstruct crypto_rng *rng = __crypto_rng_cast(tfm);\n-\tstruct rng_alg *alg = crypto_rng_alg(rng);\n-\tstruct old_rng_alg *oalg = crypto_old_rng_alg(rng);\n-\n-\tif (oalg->rng_make_random) {\n-\t\trng->generate = generate;\n-\t\trng->seed = rngapi_reset;\n-\t\trng->seedsize = oalg->seedsize;\n-\t\treturn 0;\n-\t}\n-\n-\trng->generate = alg->generate;\n-\trng->seed = alg->seed;\n-\trng->seedsize = alg->seedsize;\n-\n \treturn 0;\n }",
        "function_modified_lines": {
            "added": [],
            "deleted": [
                "\tstruct crypto_rng *rng = __crypto_rng_cast(tfm);",
                "\tstruct rng_alg *alg = crypto_rng_alg(rng);",
                "\tstruct old_rng_alg *oalg = crypto_old_rng_alg(rng);",
                "",
                "\tif (oalg->rng_make_random) {",
                "\t\trng->generate = generate;",
                "\t\trng->seed = rngapi_reset;",
                "\t\trng->seedsize = oalg->seedsize;",
                "\t\treturn 0;",
                "\t}",
                "",
                "\trng->generate = alg->generate;",
                "\trng->seed = alg->seed;",
                "\trng->seedsize = alg->seedsize;",
                ""
            ]
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "The rngapi_reset function in crypto/rng.c in the Linux kernel before 4.2 allows attackers to cause a denial of service (NULL pointer dereference).",
        "id": 1291
    },
    {
        "cve_id": "CVE-2023-32252",
        "code_before_change": "static void destroy_previous_session(struct ksmbd_conn *conn,\n\t\t\t\t     struct ksmbd_user *user, u64 id)\n{\n\tstruct ksmbd_session *prev_sess = ksmbd_session_lookup_slowpath(id);\n\tstruct ksmbd_user *prev_user;\n\tstruct channel *chann;\n\tlong index;\n\n\tif (!prev_sess)\n\t\treturn;\n\n\tprev_user = prev_sess->user;\n\n\tif (!prev_user ||\n\t    strcmp(user->name, prev_user->name) ||\n\t    user->passkey_sz != prev_user->passkey_sz ||\n\t    memcmp(user->passkey, prev_user->passkey, user->passkey_sz))\n\t\treturn;\n\n\tprev_sess->state = SMB2_SESSION_EXPIRED;\n\txa_for_each(&prev_sess->ksmbd_chann_list, index, chann)\n\t\tchann->conn->status = KSMBD_SESS_EXITING;\n}",
        "code_after_change": "static void destroy_previous_session(struct ksmbd_conn *conn,\n\t\t\t\t     struct ksmbd_user *user, u64 id)\n{\n\tstruct ksmbd_session *prev_sess = ksmbd_session_lookup_slowpath(id);\n\tstruct ksmbd_user *prev_user;\n\tstruct channel *chann;\n\tlong index;\n\n\tif (!prev_sess)\n\t\treturn;\n\n\tprev_user = prev_sess->user;\n\n\tif (!prev_user ||\n\t    strcmp(user->name, prev_user->name) ||\n\t    user->passkey_sz != prev_user->passkey_sz ||\n\t    memcmp(user->passkey, prev_user->passkey, user->passkey_sz))\n\t\treturn;\n\n\tprev_sess->state = SMB2_SESSION_EXPIRED;\n\txa_for_each(&prev_sess->ksmbd_chann_list, index, chann)\n\t\tksmbd_conn_set_exiting(chann->conn);\n}",
        "patch": "--- code before\n+++ code after\n@@ -19,5 +19,5 @@\n \n \tprev_sess->state = SMB2_SESSION_EXPIRED;\n \txa_for_each(&prev_sess->ksmbd_chann_list, index, chann)\n-\t\tchann->conn->status = KSMBD_SESS_EXITING;\n+\t\tksmbd_conn_set_exiting(chann->conn);\n }",
        "function_modified_lines": {
            "added": [
                "\t\tksmbd_conn_set_exiting(chann->conn);"
            ],
            "deleted": [
                "\t\tchann->conn->status = KSMBD_SESS_EXITING;"
            ]
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "A flaw was found in the Linux kernel's ksmbd, a high-performance in-kernel SMB server. The specific flaw exists within the handling of SMB2_LOGOFF commands. The issue results from the lack of proper validation of a pointer prior to accessing it. An attacker can leverage this vulnerability to create a denial-of-service condition on the system.",
        "id": 4030
    },
    {
        "cve_id": "CVE-2023-32252",
        "code_before_change": "static void ksmbd_conn_lock(struct ksmbd_conn *conn)\n{\n\tmutex_lock(&conn->srv_mutex);\n}",
        "code_after_change": "void ksmbd_conn_lock(struct ksmbd_conn *conn)\n{\n\tmutex_lock(&conn->srv_mutex);\n}",
        "patch": "--- code before\n+++ code after\n@@ -1,4 +1,4 @@\n-static void ksmbd_conn_lock(struct ksmbd_conn *conn)\n+void ksmbd_conn_lock(struct ksmbd_conn *conn)\n {\n \tmutex_lock(&conn->srv_mutex);\n }",
        "function_modified_lines": {
            "added": [
                "void ksmbd_conn_lock(struct ksmbd_conn *conn)"
            ],
            "deleted": [
                "static void ksmbd_conn_lock(struct ksmbd_conn *conn)"
            ]
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "A flaw was found in the Linux kernel's ksmbd, a high-performance in-kernel SMB server. The specific flaw exists within the handling of SMB2_LOGOFF commands. The issue results from the lack of proper validation of a pointer prior to accessing it. An attacker can leverage this vulnerability to create a denial-of-service condition on the system.",
        "id": 4026
    },
    {
        "cve_id": "CVE-2023-28466",
        "code_before_change": "static int do_tls_getsockopt_conf(struct sock *sk, char __user *optval,\n\t\t\t\t  int __user *optlen, int tx)\n{\n\tint rc = 0;\n\tstruct tls_context *ctx = tls_get_ctx(sk);\n\tstruct tls_crypto_info *crypto_info;\n\tstruct cipher_context *cctx;\n\tint len;\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tif (!optval || (len < sizeof(*crypto_info))) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!ctx) {\n\t\trc = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t/* get user crypto info */\n\tif (tx) {\n\t\tcrypto_info = &ctx->crypto_send.info;\n\t\tcctx = &ctx->tx;\n\t} else {\n\t\tcrypto_info = &ctx->crypto_recv.info;\n\t\tcctx = &ctx->rx;\n\t}\n\n\tif (!TLS_CRYPTO_INFO_READY(crypto_info)) {\n\t\trc = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tif (len == sizeof(*crypto_info)) {\n\t\tif (copy_to_user(optval, crypto_info, sizeof(*crypto_info)))\n\t\t\trc = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tswitch (crypto_info->cipher_type) {\n\tcase TLS_CIPHER_AES_GCM_128: {\n\t\tstruct tls12_crypto_info_aes_gcm_128 *\n\t\t  crypto_info_aes_gcm_128 =\n\t\t  container_of(crypto_info,\n\t\t\t       struct tls12_crypto_info_aes_gcm_128,\n\t\t\t       info);\n\n\t\tif (len != sizeof(*crypto_info_aes_gcm_128)) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tlock_sock(sk);\n\t\tmemcpy(crypto_info_aes_gcm_128->iv,\n\t\t       cctx->iv + TLS_CIPHER_AES_GCM_128_SALT_SIZE,\n\t\t       TLS_CIPHER_AES_GCM_128_IV_SIZE);\n\t\tmemcpy(crypto_info_aes_gcm_128->rec_seq, cctx->rec_seq,\n\t\t       TLS_CIPHER_AES_GCM_128_REC_SEQ_SIZE);\n\t\trelease_sock(sk);\n\t\tif (copy_to_user(optval,\n\t\t\t\t crypto_info_aes_gcm_128,\n\t\t\t\t sizeof(*crypto_info_aes_gcm_128)))\n\t\t\trc = -EFAULT;\n\t\tbreak;\n\t}\n\tcase TLS_CIPHER_AES_GCM_256: {\n\t\tstruct tls12_crypto_info_aes_gcm_256 *\n\t\t  crypto_info_aes_gcm_256 =\n\t\t  container_of(crypto_info,\n\t\t\t       struct tls12_crypto_info_aes_gcm_256,\n\t\t\t       info);\n\n\t\tif (len != sizeof(*crypto_info_aes_gcm_256)) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tlock_sock(sk);\n\t\tmemcpy(crypto_info_aes_gcm_256->iv,\n\t\t       cctx->iv + TLS_CIPHER_AES_GCM_256_SALT_SIZE,\n\t\t       TLS_CIPHER_AES_GCM_256_IV_SIZE);\n\t\tmemcpy(crypto_info_aes_gcm_256->rec_seq, cctx->rec_seq,\n\t\t       TLS_CIPHER_AES_GCM_256_REC_SEQ_SIZE);\n\t\trelease_sock(sk);\n\t\tif (copy_to_user(optval,\n\t\t\t\t crypto_info_aes_gcm_256,\n\t\t\t\t sizeof(*crypto_info_aes_gcm_256)))\n\t\t\trc = -EFAULT;\n\t\tbreak;\n\t}\n\tcase TLS_CIPHER_AES_CCM_128: {\n\t\tstruct tls12_crypto_info_aes_ccm_128 *aes_ccm_128 =\n\t\t\tcontainer_of(crypto_info,\n\t\t\t\tstruct tls12_crypto_info_aes_ccm_128, info);\n\n\t\tif (len != sizeof(*aes_ccm_128)) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tlock_sock(sk);\n\t\tmemcpy(aes_ccm_128->iv,\n\t\t       cctx->iv + TLS_CIPHER_AES_CCM_128_SALT_SIZE,\n\t\t       TLS_CIPHER_AES_CCM_128_IV_SIZE);\n\t\tmemcpy(aes_ccm_128->rec_seq, cctx->rec_seq,\n\t\t       TLS_CIPHER_AES_CCM_128_REC_SEQ_SIZE);\n\t\trelease_sock(sk);\n\t\tif (copy_to_user(optval, aes_ccm_128, sizeof(*aes_ccm_128)))\n\t\t\trc = -EFAULT;\n\t\tbreak;\n\t}\n\tcase TLS_CIPHER_CHACHA20_POLY1305: {\n\t\tstruct tls12_crypto_info_chacha20_poly1305 *chacha20_poly1305 =\n\t\t\tcontainer_of(crypto_info,\n\t\t\t\tstruct tls12_crypto_info_chacha20_poly1305,\n\t\t\t\tinfo);\n\n\t\tif (len != sizeof(*chacha20_poly1305)) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tlock_sock(sk);\n\t\tmemcpy(chacha20_poly1305->iv,\n\t\t       cctx->iv + TLS_CIPHER_CHACHA20_POLY1305_SALT_SIZE,\n\t\t       TLS_CIPHER_CHACHA20_POLY1305_IV_SIZE);\n\t\tmemcpy(chacha20_poly1305->rec_seq, cctx->rec_seq,\n\t\t       TLS_CIPHER_CHACHA20_POLY1305_REC_SEQ_SIZE);\n\t\trelease_sock(sk);\n\t\tif (copy_to_user(optval, chacha20_poly1305,\n\t\t\t\tsizeof(*chacha20_poly1305)))\n\t\t\trc = -EFAULT;\n\t\tbreak;\n\t}\n\tcase TLS_CIPHER_SM4_GCM: {\n\t\tstruct tls12_crypto_info_sm4_gcm *sm4_gcm_info =\n\t\t\tcontainer_of(crypto_info,\n\t\t\t\tstruct tls12_crypto_info_sm4_gcm, info);\n\n\t\tif (len != sizeof(*sm4_gcm_info)) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tlock_sock(sk);\n\t\tmemcpy(sm4_gcm_info->iv,\n\t\t       cctx->iv + TLS_CIPHER_SM4_GCM_SALT_SIZE,\n\t\t       TLS_CIPHER_SM4_GCM_IV_SIZE);\n\t\tmemcpy(sm4_gcm_info->rec_seq, cctx->rec_seq,\n\t\t       TLS_CIPHER_SM4_GCM_REC_SEQ_SIZE);\n\t\trelease_sock(sk);\n\t\tif (copy_to_user(optval, sm4_gcm_info, sizeof(*sm4_gcm_info)))\n\t\t\trc = -EFAULT;\n\t\tbreak;\n\t}\n\tcase TLS_CIPHER_SM4_CCM: {\n\t\tstruct tls12_crypto_info_sm4_ccm *sm4_ccm_info =\n\t\t\tcontainer_of(crypto_info,\n\t\t\t\tstruct tls12_crypto_info_sm4_ccm, info);\n\n\t\tif (len != sizeof(*sm4_ccm_info)) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tlock_sock(sk);\n\t\tmemcpy(sm4_ccm_info->iv,\n\t\t       cctx->iv + TLS_CIPHER_SM4_CCM_SALT_SIZE,\n\t\t       TLS_CIPHER_SM4_CCM_IV_SIZE);\n\t\tmemcpy(sm4_ccm_info->rec_seq, cctx->rec_seq,\n\t\t       TLS_CIPHER_SM4_CCM_REC_SEQ_SIZE);\n\t\trelease_sock(sk);\n\t\tif (copy_to_user(optval, sm4_ccm_info, sizeof(*sm4_ccm_info)))\n\t\t\trc = -EFAULT;\n\t\tbreak;\n\t}\n\tcase TLS_CIPHER_ARIA_GCM_128: {\n\t\tstruct tls12_crypto_info_aria_gcm_128 *\n\t\t  crypto_info_aria_gcm_128 =\n\t\t  container_of(crypto_info,\n\t\t\t       struct tls12_crypto_info_aria_gcm_128,\n\t\t\t       info);\n\n\t\tif (len != sizeof(*crypto_info_aria_gcm_128)) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tlock_sock(sk);\n\t\tmemcpy(crypto_info_aria_gcm_128->iv,\n\t\t       cctx->iv + TLS_CIPHER_ARIA_GCM_128_SALT_SIZE,\n\t\t       TLS_CIPHER_ARIA_GCM_128_IV_SIZE);\n\t\tmemcpy(crypto_info_aria_gcm_128->rec_seq, cctx->rec_seq,\n\t\t       TLS_CIPHER_ARIA_GCM_128_REC_SEQ_SIZE);\n\t\trelease_sock(sk);\n\t\tif (copy_to_user(optval,\n\t\t\t\t crypto_info_aria_gcm_128,\n\t\t\t\t sizeof(*crypto_info_aria_gcm_128)))\n\t\t\trc = -EFAULT;\n\t\tbreak;\n\t}\n\tcase TLS_CIPHER_ARIA_GCM_256: {\n\t\tstruct tls12_crypto_info_aria_gcm_256 *\n\t\t  crypto_info_aria_gcm_256 =\n\t\t  container_of(crypto_info,\n\t\t\t       struct tls12_crypto_info_aria_gcm_256,\n\t\t\t       info);\n\n\t\tif (len != sizeof(*crypto_info_aria_gcm_256)) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tlock_sock(sk);\n\t\tmemcpy(crypto_info_aria_gcm_256->iv,\n\t\t       cctx->iv + TLS_CIPHER_ARIA_GCM_256_SALT_SIZE,\n\t\t       TLS_CIPHER_ARIA_GCM_256_IV_SIZE);\n\t\tmemcpy(crypto_info_aria_gcm_256->rec_seq, cctx->rec_seq,\n\t\t       TLS_CIPHER_ARIA_GCM_256_REC_SEQ_SIZE);\n\t\trelease_sock(sk);\n\t\tif (copy_to_user(optval,\n\t\t\t\t crypto_info_aria_gcm_256,\n\t\t\t\t sizeof(*crypto_info_aria_gcm_256)))\n\t\t\trc = -EFAULT;\n\t\tbreak;\n\t}\n\tdefault:\n\t\trc = -EINVAL;\n\t}\n\nout:\n\treturn rc;\n}",
        "code_after_change": "static int do_tls_getsockopt_conf(struct sock *sk, char __user *optval,\n\t\t\t\t  int __user *optlen, int tx)\n{\n\tint rc = 0;\n\tstruct tls_context *ctx = tls_get_ctx(sk);\n\tstruct tls_crypto_info *crypto_info;\n\tstruct cipher_context *cctx;\n\tint len;\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tif (!optval || (len < sizeof(*crypto_info))) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!ctx) {\n\t\trc = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t/* get user crypto info */\n\tif (tx) {\n\t\tcrypto_info = &ctx->crypto_send.info;\n\t\tcctx = &ctx->tx;\n\t} else {\n\t\tcrypto_info = &ctx->crypto_recv.info;\n\t\tcctx = &ctx->rx;\n\t}\n\n\tif (!TLS_CRYPTO_INFO_READY(crypto_info)) {\n\t\trc = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tif (len == sizeof(*crypto_info)) {\n\t\tif (copy_to_user(optval, crypto_info, sizeof(*crypto_info)))\n\t\t\trc = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tswitch (crypto_info->cipher_type) {\n\tcase TLS_CIPHER_AES_GCM_128: {\n\t\tstruct tls12_crypto_info_aes_gcm_128 *\n\t\t  crypto_info_aes_gcm_128 =\n\t\t  container_of(crypto_info,\n\t\t\t       struct tls12_crypto_info_aes_gcm_128,\n\t\t\t       info);\n\n\t\tif (len != sizeof(*crypto_info_aes_gcm_128)) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(crypto_info_aes_gcm_128->iv,\n\t\t       cctx->iv + TLS_CIPHER_AES_GCM_128_SALT_SIZE,\n\t\t       TLS_CIPHER_AES_GCM_128_IV_SIZE);\n\t\tmemcpy(crypto_info_aes_gcm_128->rec_seq, cctx->rec_seq,\n\t\t       TLS_CIPHER_AES_GCM_128_REC_SEQ_SIZE);\n\t\tif (copy_to_user(optval,\n\t\t\t\t crypto_info_aes_gcm_128,\n\t\t\t\t sizeof(*crypto_info_aes_gcm_128)))\n\t\t\trc = -EFAULT;\n\t\tbreak;\n\t}\n\tcase TLS_CIPHER_AES_GCM_256: {\n\t\tstruct tls12_crypto_info_aes_gcm_256 *\n\t\t  crypto_info_aes_gcm_256 =\n\t\t  container_of(crypto_info,\n\t\t\t       struct tls12_crypto_info_aes_gcm_256,\n\t\t\t       info);\n\n\t\tif (len != sizeof(*crypto_info_aes_gcm_256)) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(crypto_info_aes_gcm_256->iv,\n\t\t       cctx->iv + TLS_CIPHER_AES_GCM_256_SALT_SIZE,\n\t\t       TLS_CIPHER_AES_GCM_256_IV_SIZE);\n\t\tmemcpy(crypto_info_aes_gcm_256->rec_seq, cctx->rec_seq,\n\t\t       TLS_CIPHER_AES_GCM_256_REC_SEQ_SIZE);\n\t\tif (copy_to_user(optval,\n\t\t\t\t crypto_info_aes_gcm_256,\n\t\t\t\t sizeof(*crypto_info_aes_gcm_256)))\n\t\t\trc = -EFAULT;\n\t\tbreak;\n\t}\n\tcase TLS_CIPHER_AES_CCM_128: {\n\t\tstruct tls12_crypto_info_aes_ccm_128 *aes_ccm_128 =\n\t\t\tcontainer_of(crypto_info,\n\t\t\t\tstruct tls12_crypto_info_aes_ccm_128, info);\n\n\t\tif (len != sizeof(*aes_ccm_128)) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(aes_ccm_128->iv,\n\t\t       cctx->iv + TLS_CIPHER_AES_CCM_128_SALT_SIZE,\n\t\t       TLS_CIPHER_AES_CCM_128_IV_SIZE);\n\t\tmemcpy(aes_ccm_128->rec_seq, cctx->rec_seq,\n\t\t       TLS_CIPHER_AES_CCM_128_REC_SEQ_SIZE);\n\t\tif (copy_to_user(optval, aes_ccm_128, sizeof(*aes_ccm_128)))\n\t\t\trc = -EFAULT;\n\t\tbreak;\n\t}\n\tcase TLS_CIPHER_CHACHA20_POLY1305: {\n\t\tstruct tls12_crypto_info_chacha20_poly1305 *chacha20_poly1305 =\n\t\t\tcontainer_of(crypto_info,\n\t\t\t\tstruct tls12_crypto_info_chacha20_poly1305,\n\t\t\t\tinfo);\n\n\t\tif (len != sizeof(*chacha20_poly1305)) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(chacha20_poly1305->iv,\n\t\t       cctx->iv + TLS_CIPHER_CHACHA20_POLY1305_SALT_SIZE,\n\t\t       TLS_CIPHER_CHACHA20_POLY1305_IV_SIZE);\n\t\tmemcpy(chacha20_poly1305->rec_seq, cctx->rec_seq,\n\t\t       TLS_CIPHER_CHACHA20_POLY1305_REC_SEQ_SIZE);\n\t\tif (copy_to_user(optval, chacha20_poly1305,\n\t\t\t\tsizeof(*chacha20_poly1305)))\n\t\t\trc = -EFAULT;\n\t\tbreak;\n\t}\n\tcase TLS_CIPHER_SM4_GCM: {\n\t\tstruct tls12_crypto_info_sm4_gcm *sm4_gcm_info =\n\t\t\tcontainer_of(crypto_info,\n\t\t\t\tstruct tls12_crypto_info_sm4_gcm, info);\n\n\t\tif (len != sizeof(*sm4_gcm_info)) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(sm4_gcm_info->iv,\n\t\t       cctx->iv + TLS_CIPHER_SM4_GCM_SALT_SIZE,\n\t\t       TLS_CIPHER_SM4_GCM_IV_SIZE);\n\t\tmemcpy(sm4_gcm_info->rec_seq, cctx->rec_seq,\n\t\t       TLS_CIPHER_SM4_GCM_REC_SEQ_SIZE);\n\t\tif (copy_to_user(optval, sm4_gcm_info, sizeof(*sm4_gcm_info)))\n\t\t\trc = -EFAULT;\n\t\tbreak;\n\t}\n\tcase TLS_CIPHER_SM4_CCM: {\n\t\tstruct tls12_crypto_info_sm4_ccm *sm4_ccm_info =\n\t\t\tcontainer_of(crypto_info,\n\t\t\t\tstruct tls12_crypto_info_sm4_ccm, info);\n\n\t\tif (len != sizeof(*sm4_ccm_info)) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(sm4_ccm_info->iv,\n\t\t       cctx->iv + TLS_CIPHER_SM4_CCM_SALT_SIZE,\n\t\t       TLS_CIPHER_SM4_CCM_IV_SIZE);\n\t\tmemcpy(sm4_ccm_info->rec_seq, cctx->rec_seq,\n\t\t       TLS_CIPHER_SM4_CCM_REC_SEQ_SIZE);\n\t\tif (copy_to_user(optval, sm4_ccm_info, sizeof(*sm4_ccm_info)))\n\t\t\trc = -EFAULT;\n\t\tbreak;\n\t}\n\tcase TLS_CIPHER_ARIA_GCM_128: {\n\t\tstruct tls12_crypto_info_aria_gcm_128 *\n\t\t  crypto_info_aria_gcm_128 =\n\t\t  container_of(crypto_info,\n\t\t\t       struct tls12_crypto_info_aria_gcm_128,\n\t\t\t       info);\n\n\t\tif (len != sizeof(*crypto_info_aria_gcm_128)) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(crypto_info_aria_gcm_128->iv,\n\t\t       cctx->iv + TLS_CIPHER_ARIA_GCM_128_SALT_SIZE,\n\t\t       TLS_CIPHER_ARIA_GCM_128_IV_SIZE);\n\t\tmemcpy(crypto_info_aria_gcm_128->rec_seq, cctx->rec_seq,\n\t\t       TLS_CIPHER_ARIA_GCM_128_REC_SEQ_SIZE);\n\t\tif (copy_to_user(optval,\n\t\t\t\t crypto_info_aria_gcm_128,\n\t\t\t\t sizeof(*crypto_info_aria_gcm_128)))\n\t\t\trc = -EFAULT;\n\t\tbreak;\n\t}\n\tcase TLS_CIPHER_ARIA_GCM_256: {\n\t\tstruct tls12_crypto_info_aria_gcm_256 *\n\t\t  crypto_info_aria_gcm_256 =\n\t\t  container_of(crypto_info,\n\t\t\t       struct tls12_crypto_info_aria_gcm_256,\n\t\t\t       info);\n\n\t\tif (len != sizeof(*crypto_info_aria_gcm_256)) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(crypto_info_aria_gcm_256->iv,\n\t\t       cctx->iv + TLS_CIPHER_ARIA_GCM_256_SALT_SIZE,\n\t\t       TLS_CIPHER_ARIA_GCM_256_IV_SIZE);\n\t\tmemcpy(crypto_info_aria_gcm_256->rec_seq, cctx->rec_seq,\n\t\t       TLS_CIPHER_ARIA_GCM_256_REC_SEQ_SIZE);\n\t\tif (copy_to_user(optval,\n\t\t\t\t crypto_info_aria_gcm_256,\n\t\t\t\t sizeof(*crypto_info_aria_gcm_256)))\n\t\t\trc = -EFAULT;\n\t\tbreak;\n\t}\n\tdefault:\n\t\trc = -EINVAL;\n\t}\n\nout:\n\treturn rc;\n}",
        "patch": "--- code before\n+++ code after\n@@ -52,13 +52,11 @@\n \t\t\trc = -EINVAL;\n \t\t\tgoto out;\n \t\t}\n-\t\tlock_sock(sk);\n \t\tmemcpy(crypto_info_aes_gcm_128->iv,\n \t\t       cctx->iv + TLS_CIPHER_AES_GCM_128_SALT_SIZE,\n \t\t       TLS_CIPHER_AES_GCM_128_IV_SIZE);\n \t\tmemcpy(crypto_info_aes_gcm_128->rec_seq, cctx->rec_seq,\n \t\t       TLS_CIPHER_AES_GCM_128_REC_SEQ_SIZE);\n-\t\trelease_sock(sk);\n \t\tif (copy_to_user(optval,\n \t\t\t\t crypto_info_aes_gcm_128,\n \t\t\t\t sizeof(*crypto_info_aes_gcm_128)))\n@@ -76,13 +74,11 @@\n \t\t\trc = -EINVAL;\n \t\t\tgoto out;\n \t\t}\n-\t\tlock_sock(sk);\n \t\tmemcpy(crypto_info_aes_gcm_256->iv,\n \t\t       cctx->iv + TLS_CIPHER_AES_GCM_256_SALT_SIZE,\n \t\t       TLS_CIPHER_AES_GCM_256_IV_SIZE);\n \t\tmemcpy(crypto_info_aes_gcm_256->rec_seq, cctx->rec_seq,\n \t\t       TLS_CIPHER_AES_GCM_256_REC_SEQ_SIZE);\n-\t\trelease_sock(sk);\n \t\tif (copy_to_user(optval,\n \t\t\t\t crypto_info_aes_gcm_256,\n \t\t\t\t sizeof(*crypto_info_aes_gcm_256)))\n@@ -98,13 +94,11 @@\n \t\t\trc = -EINVAL;\n \t\t\tgoto out;\n \t\t}\n-\t\tlock_sock(sk);\n \t\tmemcpy(aes_ccm_128->iv,\n \t\t       cctx->iv + TLS_CIPHER_AES_CCM_128_SALT_SIZE,\n \t\t       TLS_CIPHER_AES_CCM_128_IV_SIZE);\n \t\tmemcpy(aes_ccm_128->rec_seq, cctx->rec_seq,\n \t\t       TLS_CIPHER_AES_CCM_128_REC_SEQ_SIZE);\n-\t\trelease_sock(sk);\n \t\tif (copy_to_user(optval, aes_ccm_128, sizeof(*aes_ccm_128)))\n \t\t\trc = -EFAULT;\n \t\tbreak;\n@@ -119,13 +113,11 @@\n \t\t\trc = -EINVAL;\n \t\t\tgoto out;\n \t\t}\n-\t\tlock_sock(sk);\n \t\tmemcpy(chacha20_poly1305->iv,\n \t\t       cctx->iv + TLS_CIPHER_CHACHA20_POLY1305_SALT_SIZE,\n \t\t       TLS_CIPHER_CHACHA20_POLY1305_IV_SIZE);\n \t\tmemcpy(chacha20_poly1305->rec_seq, cctx->rec_seq,\n \t\t       TLS_CIPHER_CHACHA20_POLY1305_REC_SEQ_SIZE);\n-\t\trelease_sock(sk);\n \t\tif (copy_to_user(optval, chacha20_poly1305,\n \t\t\t\tsizeof(*chacha20_poly1305)))\n \t\t\trc = -EFAULT;\n@@ -140,13 +132,11 @@\n \t\t\trc = -EINVAL;\n \t\t\tgoto out;\n \t\t}\n-\t\tlock_sock(sk);\n \t\tmemcpy(sm4_gcm_info->iv,\n \t\t       cctx->iv + TLS_CIPHER_SM4_GCM_SALT_SIZE,\n \t\t       TLS_CIPHER_SM4_GCM_IV_SIZE);\n \t\tmemcpy(sm4_gcm_info->rec_seq, cctx->rec_seq,\n \t\t       TLS_CIPHER_SM4_GCM_REC_SEQ_SIZE);\n-\t\trelease_sock(sk);\n \t\tif (copy_to_user(optval, sm4_gcm_info, sizeof(*sm4_gcm_info)))\n \t\t\trc = -EFAULT;\n \t\tbreak;\n@@ -160,13 +150,11 @@\n \t\t\trc = -EINVAL;\n \t\t\tgoto out;\n \t\t}\n-\t\tlock_sock(sk);\n \t\tmemcpy(sm4_ccm_info->iv,\n \t\t       cctx->iv + TLS_CIPHER_SM4_CCM_SALT_SIZE,\n \t\t       TLS_CIPHER_SM4_CCM_IV_SIZE);\n \t\tmemcpy(sm4_ccm_info->rec_seq, cctx->rec_seq,\n \t\t       TLS_CIPHER_SM4_CCM_REC_SEQ_SIZE);\n-\t\trelease_sock(sk);\n \t\tif (copy_to_user(optval, sm4_ccm_info, sizeof(*sm4_ccm_info)))\n \t\t\trc = -EFAULT;\n \t\tbreak;\n@@ -182,13 +170,11 @@\n \t\t\trc = -EINVAL;\n \t\t\tgoto out;\n \t\t}\n-\t\tlock_sock(sk);\n \t\tmemcpy(crypto_info_aria_gcm_128->iv,\n \t\t       cctx->iv + TLS_CIPHER_ARIA_GCM_128_SALT_SIZE,\n \t\t       TLS_CIPHER_ARIA_GCM_128_IV_SIZE);\n \t\tmemcpy(crypto_info_aria_gcm_128->rec_seq, cctx->rec_seq,\n \t\t       TLS_CIPHER_ARIA_GCM_128_REC_SEQ_SIZE);\n-\t\trelease_sock(sk);\n \t\tif (copy_to_user(optval,\n \t\t\t\t crypto_info_aria_gcm_128,\n \t\t\t\t sizeof(*crypto_info_aria_gcm_128)))\n@@ -206,13 +192,11 @@\n \t\t\trc = -EINVAL;\n \t\t\tgoto out;\n \t\t}\n-\t\tlock_sock(sk);\n \t\tmemcpy(crypto_info_aria_gcm_256->iv,\n \t\t       cctx->iv + TLS_CIPHER_ARIA_GCM_256_SALT_SIZE,\n \t\t       TLS_CIPHER_ARIA_GCM_256_IV_SIZE);\n \t\tmemcpy(crypto_info_aria_gcm_256->rec_seq, cctx->rec_seq,\n \t\t       TLS_CIPHER_ARIA_GCM_256_REC_SEQ_SIZE);\n-\t\trelease_sock(sk);\n \t\tif (copy_to_user(optval,\n \t\t\t\t crypto_info_aria_gcm_256,\n \t\t\t\t sizeof(*crypto_info_aria_gcm_256)))",
        "function_modified_lines": {
            "added": [],
            "deleted": [
                "\t\tlock_sock(sk);",
                "\t\trelease_sock(sk);",
                "\t\tlock_sock(sk);",
                "\t\trelease_sock(sk);",
                "\t\tlock_sock(sk);",
                "\t\trelease_sock(sk);",
                "\t\tlock_sock(sk);",
                "\t\trelease_sock(sk);",
                "\t\tlock_sock(sk);",
                "\t\trelease_sock(sk);",
                "\t\tlock_sock(sk);",
                "\t\trelease_sock(sk);",
                "\t\tlock_sock(sk);",
                "\t\trelease_sock(sk);",
                "\t\tlock_sock(sk);",
                "\t\trelease_sock(sk);"
            ]
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "do_tls_getsockopt in net/tls/tls_main.c in the Linux kernel through 6.2.6 lacks a lock_sock call, leading to a race condition (with a resultant use-after-free or NULL pointer dereference).",
        "id": 3982
    },
    {
        "cve_id": "CVE-2019-12818",
        "code_before_change": "int nfc_llcp_send_cc(struct nfc_llcp_sock *sock)\n{\n\tstruct nfc_llcp_local *local;\n\tstruct sk_buff *skb;\n\tu8 *miux_tlv = NULL, miux_tlv_length;\n\tu8 *rw_tlv = NULL, rw_tlv_length, rw;\n\tint err;\n\tu16 size = 0;\n\t__be16 miux;\n\n\tpr_debug(\"Sending CC\\n\");\n\n\tlocal = sock->local;\n\tif (local == NULL)\n\t\treturn -ENODEV;\n\n\t/* If the socket parameters are not set, use the local ones */\n\tmiux = be16_to_cpu(sock->miux) > LLCP_MAX_MIUX ?\n\t\tlocal->miux : sock->miux;\n\trw = sock->rw > LLCP_MAX_RW ? local->rw : sock->rw;\n\n\tmiux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&miux, 0,\n\t\t\t\t      &miux_tlv_length);\n\tsize += miux_tlv_length;\n\n\trw_tlv = nfc_llcp_build_tlv(LLCP_TLV_RW, &rw, 0, &rw_tlv_length);\n\tsize += rw_tlv_length;\n\n\tskb = llcp_allocate_pdu(sock, LLCP_PDU_CC, size);\n\tif (skb == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto error_tlv;\n\t}\n\n\tllcp_add_tlv(skb, miux_tlv, miux_tlv_length);\n\tllcp_add_tlv(skb, rw_tlv, rw_tlv_length);\n\n\tskb_queue_tail(&local->tx_queue, skb);\n\n\terr = 0;\n\nerror_tlv:\n\tif (err)\n\t\tpr_err(\"error %d\\n\", err);\n\n\tkfree(miux_tlv);\n\tkfree(rw_tlv);\n\n\treturn err;\n}",
        "code_after_change": "int nfc_llcp_send_cc(struct nfc_llcp_sock *sock)\n{\n\tstruct nfc_llcp_local *local;\n\tstruct sk_buff *skb;\n\tu8 *miux_tlv = NULL, miux_tlv_length;\n\tu8 *rw_tlv = NULL, rw_tlv_length, rw;\n\tint err;\n\tu16 size = 0;\n\t__be16 miux;\n\n\tpr_debug(\"Sending CC\\n\");\n\n\tlocal = sock->local;\n\tif (local == NULL)\n\t\treturn -ENODEV;\n\n\t/* If the socket parameters are not set, use the local ones */\n\tmiux = be16_to_cpu(sock->miux) > LLCP_MAX_MIUX ?\n\t\tlocal->miux : sock->miux;\n\trw = sock->rw > LLCP_MAX_RW ? local->rw : sock->rw;\n\n\tmiux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&miux, 0,\n\t\t\t\t      &miux_tlv_length);\n\tif (!miux_tlv) {\n\t\terr = -ENOMEM;\n\t\tgoto error_tlv;\n\t}\n\tsize += miux_tlv_length;\n\n\trw_tlv = nfc_llcp_build_tlv(LLCP_TLV_RW, &rw, 0, &rw_tlv_length);\n\tif (!rw_tlv) {\n\t\terr = -ENOMEM;\n\t\tgoto error_tlv;\n\t}\n\tsize += rw_tlv_length;\n\n\tskb = llcp_allocate_pdu(sock, LLCP_PDU_CC, size);\n\tif (skb == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto error_tlv;\n\t}\n\n\tllcp_add_tlv(skb, miux_tlv, miux_tlv_length);\n\tllcp_add_tlv(skb, rw_tlv, rw_tlv_length);\n\n\tskb_queue_tail(&local->tx_queue, skb);\n\n\terr = 0;\n\nerror_tlv:\n\tif (err)\n\t\tpr_err(\"error %d\\n\", err);\n\n\tkfree(miux_tlv);\n\tkfree(rw_tlv);\n\n\treturn err;\n}",
        "patch": "--- code before\n+++ code after\n@@ -21,9 +21,17 @@\n \n \tmiux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&miux, 0,\n \t\t\t\t      &miux_tlv_length);\n+\tif (!miux_tlv) {\n+\t\terr = -ENOMEM;\n+\t\tgoto error_tlv;\n+\t}\n \tsize += miux_tlv_length;\n \n \trw_tlv = nfc_llcp_build_tlv(LLCP_TLV_RW, &rw, 0, &rw_tlv_length);\n+\tif (!rw_tlv) {\n+\t\terr = -ENOMEM;\n+\t\tgoto error_tlv;\n+\t}\n \tsize += rw_tlv_length;\n \n \tskb = llcp_allocate_pdu(sock, LLCP_PDU_CC, size);",
        "function_modified_lines": {
            "added": [
                "\tif (!miux_tlv) {",
                "\t\terr = -ENOMEM;",
                "\t\tgoto error_tlv;",
                "\t}",
                "\tif (!rw_tlv) {",
                "\t\terr = -ENOMEM;",
                "\t\tgoto error_tlv;",
                "\t}"
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "An issue was discovered in the Linux kernel before 4.20.15. The nfc_llcp_build_tlv function in net/nfc/llcp_commands.c may return NULL. If the caller does not check for this, it will trigger a NULL pointer dereference. This will cause denial of service. This affects nfc_llcp_build_gb in net/nfc/llcp_core.c.",
        "id": 1951
    },
    {
        "cve_id": "CVE-2019-12818",
        "code_before_change": "static int nfc_llcp_build_gb(struct nfc_llcp_local *local)\n{\n\tu8 *gb_cur, *version_tlv, version, version_length;\n\tu8 *lto_tlv, lto_length;\n\tu8 *wks_tlv, wks_length;\n\tu8 *miux_tlv, miux_length;\n\t__be16 wks = cpu_to_be16(local->local_wks);\n\tu8 gb_len = 0;\n\tint ret = 0;\n\n\tversion = LLCP_VERSION_11;\n\tversion_tlv = nfc_llcp_build_tlv(LLCP_TLV_VERSION, &version,\n\t\t\t\t\t 1, &version_length);\n\tgb_len += version_length;\n\n\tlto_tlv = nfc_llcp_build_tlv(LLCP_TLV_LTO, &local->lto, 1, &lto_length);\n\tgb_len += lto_length;\n\n\tpr_debug(\"Local wks 0x%lx\\n\", local->local_wks);\n\twks_tlv = nfc_llcp_build_tlv(LLCP_TLV_WKS, (u8 *)&wks, 2, &wks_length);\n\tgb_len += wks_length;\n\n\tmiux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&local->miux, 0,\n\t\t\t\t      &miux_length);\n\tgb_len += miux_length;\n\n\tgb_len += ARRAY_SIZE(llcp_magic);\n\n\tif (gb_len > NFC_MAX_GT_LEN) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tgb_cur = local->gb;\n\n\tmemcpy(gb_cur, llcp_magic, ARRAY_SIZE(llcp_magic));\n\tgb_cur += ARRAY_SIZE(llcp_magic);\n\n\tmemcpy(gb_cur, version_tlv, version_length);\n\tgb_cur += version_length;\n\n\tmemcpy(gb_cur, lto_tlv, lto_length);\n\tgb_cur += lto_length;\n\n\tmemcpy(gb_cur, wks_tlv, wks_length);\n\tgb_cur += wks_length;\n\n\tmemcpy(gb_cur, miux_tlv, miux_length);\n\tgb_cur += miux_length;\n\n\tlocal->gb_len = gb_len;\n\nout:\n\tkfree(version_tlv);\n\tkfree(lto_tlv);\n\tkfree(wks_tlv);\n\tkfree(miux_tlv);\n\n\treturn ret;\n}",
        "code_after_change": "static int nfc_llcp_build_gb(struct nfc_llcp_local *local)\n{\n\tu8 *gb_cur, version, version_length;\n\tu8 lto_length, wks_length, miux_length;\n\tu8 *version_tlv = NULL, *lto_tlv = NULL,\n\t   *wks_tlv = NULL, *miux_tlv = NULL;\n\t__be16 wks = cpu_to_be16(local->local_wks);\n\tu8 gb_len = 0;\n\tint ret = 0;\n\n\tversion = LLCP_VERSION_11;\n\tversion_tlv = nfc_llcp_build_tlv(LLCP_TLV_VERSION, &version,\n\t\t\t\t\t 1, &version_length);\n\tif (!version_tlv) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tgb_len += version_length;\n\n\tlto_tlv = nfc_llcp_build_tlv(LLCP_TLV_LTO, &local->lto, 1, &lto_length);\n\tif (!lto_tlv) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tgb_len += lto_length;\n\n\tpr_debug(\"Local wks 0x%lx\\n\", local->local_wks);\n\twks_tlv = nfc_llcp_build_tlv(LLCP_TLV_WKS, (u8 *)&wks, 2, &wks_length);\n\tif (!wks_tlv) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tgb_len += wks_length;\n\n\tmiux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&local->miux, 0,\n\t\t\t\t      &miux_length);\n\tif (!miux_tlv) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tgb_len += miux_length;\n\n\tgb_len += ARRAY_SIZE(llcp_magic);\n\n\tif (gb_len > NFC_MAX_GT_LEN) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tgb_cur = local->gb;\n\n\tmemcpy(gb_cur, llcp_magic, ARRAY_SIZE(llcp_magic));\n\tgb_cur += ARRAY_SIZE(llcp_magic);\n\n\tmemcpy(gb_cur, version_tlv, version_length);\n\tgb_cur += version_length;\n\n\tmemcpy(gb_cur, lto_tlv, lto_length);\n\tgb_cur += lto_length;\n\n\tmemcpy(gb_cur, wks_tlv, wks_length);\n\tgb_cur += wks_length;\n\n\tmemcpy(gb_cur, miux_tlv, miux_length);\n\tgb_cur += miux_length;\n\n\tlocal->gb_len = gb_len;\n\nout:\n\tkfree(version_tlv);\n\tkfree(lto_tlv);\n\tkfree(wks_tlv);\n\tkfree(miux_tlv);\n\n\treturn ret;\n}",
        "patch": "--- code before\n+++ code after\n@@ -1,9 +1,9 @@\n static int nfc_llcp_build_gb(struct nfc_llcp_local *local)\n {\n-\tu8 *gb_cur, *version_tlv, version, version_length;\n-\tu8 *lto_tlv, lto_length;\n-\tu8 *wks_tlv, wks_length;\n-\tu8 *miux_tlv, miux_length;\n+\tu8 *gb_cur, version, version_length;\n+\tu8 lto_length, wks_length, miux_length;\n+\tu8 *version_tlv = NULL, *lto_tlv = NULL,\n+\t   *wks_tlv = NULL, *miux_tlv = NULL;\n \t__be16 wks = cpu_to_be16(local->local_wks);\n \tu8 gb_len = 0;\n \tint ret = 0;\n@@ -11,17 +11,33 @@\n \tversion = LLCP_VERSION_11;\n \tversion_tlv = nfc_llcp_build_tlv(LLCP_TLV_VERSION, &version,\n \t\t\t\t\t 1, &version_length);\n+\tif (!version_tlv) {\n+\t\tret = -ENOMEM;\n+\t\tgoto out;\n+\t}\n \tgb_len += version_length;\n \n \tlto_tlv = nfc_llcp_build_tlv(LLCP_TLV_LTO, &local->lto, 1, &lto_length);\n+\tif (!lto_tlv) {\n+\t\tret = -ENOMEM;\n+\t\tgoto out;\n+\t}\n \tgb_len += lto_length;\n \n \tpr_debug(\"Local wks 0x%lx\\n\", local->local_wks);\n \twks_tlv = nfc_llcp_build_tlv(LLCP_TLV_WKS, (u8 *)&wks, 2, &wks_length);\n+\tif (!wks_tlv) {\n+\t\tret = -ENOMEM;\n+\t\tgoto out;\n+\t}\n \tgb_len += wks_length;\n \n \tmiux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&local->miux, 0,\n \t\t\t\t      &miux_length);\n+\tif (!miux_tlv) {\n+\t\tret = -ENOMEM;\n+\t\tgoto out;\n+\t}\n \tgb_len += miux_length;\n \n \tgb_len += ARRAY_SIZE(llcp_magic);",
        "function_modified_lines": {
            "added": [
                "\tu8 *gb_cur, version, version_length;",
                "\tu8 lto_length, wks_length, miux_length;",
                "\tu8 *version_tlv = NULL, *lto_tlv = NULL,",
                "\t   *wks_tlv = NULL, *miux_tlv = NULL;",
                "\tif (!version_tlv) {",
                "\t\tret = -ENOMEM;",
                "\t\tgoto out;",
                "\t}",
                "\tif (!lto_tlv) {",
                "\t\tret = -ENOMEM;",
                "\t\tgoto out;",
                "\t}",
                "\tif (!wks_tlv) {",
                "\t\tret = -ENOMEM;",
                "\t\tgoto out;",
                "\t}",
                "\tif (!miux_tlv) {",
                "\t\tret = -ENOMEM;",
                "\t\tgoto out;",
                "\t}"
            ],
            "deleted": [
                "\tu8 *gb_cur, *version_tlv, version, version_length;",
                "\tu8 *lto_tlv, lto_length;",
                "\tu8 *wks_tlv, wks_length;",
                "\tu8 *miux_tlv, miux_length;"
            ]
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "An issue was discovered in the Linux kernel before 4.20.15. The nfc_llcp_build_tlv function in net/nfc/llcp_commands.c may return NULL. If the caller does not check for this, it will trigger a NULL pointer dereference. This will cause denial of service. This affects nfc_llcp_build_gb in net/nfc/llcp_core.c.",
        "id": 1953
    },
    {
        "cve_id": "CVE-2017-18079",
        "code_before_change": "static int i8042_start(struct serio *serio)\n{\n\tstruct i8042_port *port = serio->port_data;\n\n\tport->exists = true;\n\tmb();\n\treturn 0;\n}",
        "code_after_change": "static int i8042_start(struct serio *serio)\n{\n\tstruct i8042_port *port = serio->port_data;\n\n\tspin_lock_irq(&i8042_lock);\n\tport->exists = true;\n\tspin_unlock_irq(&i8042_lock);\n\n\treturn 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -2,7 +2,9 @@\n {\n \tstruct i8042_port *port = serio->port_data;\n \n+\tspin_lock_irq(&i8042_lock);\n \tport->exists = true;\n-\tmb();\n+\tspin_unlock_irq(&i8042_lock);\n+\n \treturn 0;\n }",
        "function_modified_lines": {
            "added": [
                "\tspin_lock_irq(&i8042_lock);",
                "\tspin_unlock_irq(&i8042_lock);",
                ""
            ],
            "deleted": [
                "\tmb();"
            ]
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "drivers/input/serio/i8042.c in the Linux kernel before 4.12.4 allows attackers to cause a denial of service (NULL pointer dereference and system crash) or possibly have unspecified other impact because the port->exists value can change after it is validated.",
        "id": 1391
    },
    {
        "cve_id": "CVE-2017-18079",
        "code_before_change": "static irqreturn_t i8042_interrupt(int irq, void *dev_id)\n{\n\tstruct i8042_port *port;\n\tstruct serio *serio;\n\tunsigned long flags;\n\tunsigned char str, data;\n\tunsigned int dfl;\n\tunsigned int port_no;\n\tbool filtered;\n\tint ret = 1;\n\n\tspin_lock_irqsave(&i8042_lock, flags);\n\n\tstr = i8042_read_status();\n\tif (unlikely(~str & I8042_STR_OBF)) {\n\t\tspin_unlock_irqrestore(&i8042_lock, flags);\n\t\tif (irq)\n\t\t\tdbg(\"Interrupt %d, without any data\\n\", irq);\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tdata = i8042_read_data();\n\n\tif (i8042_mux_present && (str & I8042_STR_AUXDATA)) {\n\t\tstatic unsigned long last_transmit;\n\t\tstatic unsigned char last_str;\n\n\t\tdfl = 0;\n\t\tif (str & I8042_STR_MUXERR) {\n\t\t\tdbg(\"MUX error, status is %02x, data is %02x\\n\",\n\t\t\t    str, data);\n/*\n * When MUXERR condition is signalled the data register can only contain\n * 0xfd, 0xfe or 0xff if implementation follows the spec. Unfortunately\n * it is not always the case. Some KBCs also report 0xfc when there is\n * nothing connected to the port while others sometimes get confused which\n * port the data came from and signal error leaving the data intact. They\n * _do not_ revert to legacy mode (actually I've never seen KBC reverting\n * to legacy mode yet, when we see one we'll add proper handling).\n * Anyway, we process 0xfc, 0xfd, 0xfe and 0xff as timeouts, and for the\n * rest assume that the data came from the same serio last byte\n * was transmitted (if transmission happened not too long ago).\n */\n\n\t\t\tswitch (data) {\n\t\t\t\tdefault:\n\t\t\t\t\tif (time_before(jiffies, last_transmit + HZ/10)) {\n\t\t\t\t\t\tstr = last_str;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t/* fall through - report timeout */\n\t\t\t\tcase 0xfc:\n\t\t\t\tcase 0xfd:\n\t\t\t\tcase 0xfe: dfl = SERIO_TIMEOUT; data = 0xfe; break;\n\t\t\t\tcase 0xff: dfl = SERIO_PARITY;  data = 0xfe; break;\n\t\t\t}\n\t\t}\n\n\t\tport_no = I8042_MUX_PORT_NO + ((str >> 6) & 3);\n\t\tlast_str = str;\n\t\tlast_transmit = jiffies;\n\t} else {\n\n\t\tdfl = ((str & I8042_STR_PARITY) ? SERIO_PARITY : 0) |\n\t\t      ((str & I8042_STR_TIMEOUT && !i8042_notimeout) ? SERIO_TIMEOUT : 0);\n\n\t\tport_no = (str & I8042_STR_AUXDATA) ?\n\t\t\t\tI8042_AUX_PORT_NO : I8042_KBD_PORT_NO;\n\t}\n\n\tport = &i8042_ports[port_no];\n\tserio = port->exists ? port->serio : NULL;\n\n\tfilter_dbg(port->driver_bound, data, \"<- i8042 (interrupt, %d, %d%s%s)\\n\",\n\t\t   port_no, irq,\n\t\t   dfl & SERIO_PARITY ? \", bad parity\" : \"\",\n\t\t   dfl & SERIO_TIMEOUT ? \", timeout\" : \"\");\n\n\tfiltered = i8042_filter(data, str, serio);\n\n\tspin_unlock_irqrestore(&i8042_lock, flags);\n\n\tif (likely(port->exists && !filtered))\n\t\tserio_interrupt(serio, data, dfl);\n\n out:\n\treturn IRQ_RETVAL(ret);\n}",
        "code_after_change": "static irqreturn_t i8042_interrupt(int irq, void *dev_id)\n{\n\tstruct i8042_port *port;\n\tstruct serio *serio;\n\tunsigned long flags;\n\tunsigned char str, data;\n\tunsigned int dfl;\n\tunsigned int port_no;\n\tbool filtered;\n\tint ret = 1;\n\n\tspin_lock_irqsave(&i8042_lock, flags);\n\n\tstr = i8042_read_status();\n\tif (unlikely(~str & I8042_STR_OBF)) {\n\t\tspin_unlock_irqrestore(&i8042_lock, flags);\n\t\tif (irq)\n\t\t\tdbg(\"Interrupt %d, without any data\\n\", irq);\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tdata = i8042_read_data();\n\n\tif (i8042_mux_present && (str & I8042_STR_AUXDATA)) {\n\t\tstatic unsigned long last_transmit;\n\t\tstatic unsigned char last_str;\n\n\t\tdfl = 0;\n\t\tif (str & I8042_STR_MUXERR) {\n\t\t\tdbg(\"MUX error, status is %02x, data is %02x\\n\",\n\t\t\t    str, data);\n/*\n * When MUXERR condition is signalled the data register can only contain\n * 0xfd, 0xfe or 0xff if implementation follows the spec. Unfortunately\n * it is not always the case. Some KBCs also report 0xfc when there is\n * nothing connected to the port while others sometimes get confused which\n * port the data came from and signal error leaving the data intact. They\n * _do not_ revert to legacy mode (actually I've never seen KBC reverting\n * to legacy mode yet, when we see one we'll add proper handling).\n * Anyway, we process 0xfc, 0xfd, 0xfe and 0xff as timeouts, and for the\n * rest assume that the data came from the same serio last byte\n * was transmitted (if transmission happened not too long ago).\n */\n\n\t\t\tswitch (data) {\n\t\t\t\tdefault:\n\t\t\t\t\tif (time_before(jiffies, last_transmit + HZ/10)) {\n\t\t\t\t\t\tstr = last_str;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t/* fall through - report timeout */\n\t\t\t\tcase 0xfc:\n\t\t\t\tcase 0xfd:\n\t\t\t\tcase 0xfe: dfl = SERIO_TIMEOUT; data = 0xfe; break;\n\t\t\t\tcase 0xff: dfl = SERIO_PARITY;  data = 0xfe; break;\n\t\t\t}\n\t\t}\n\n\t\tport_no = I8042_MUX_PORT_NO + ((str >> 6) & 3);\n\t\tlast_str = str;\n\t\tlast_transmit = jiffies;\n\t} else {\n\n\t\tdfl = ((str & I8042_STR_PARITY) ? SERIO_PARITY : 0) |\n\t\t      ((str & I8042_STR_TIMEOUT && !i8042_notimeout) ? SERIO_TIMEOUT : 0);\n\n\t\tport_no = (str & I8042_STR_AUXDATA) ?\n\t\t\t\tI8042_AUX_PORT_NO : I8042_KBD_PORT_NO;\n\t}\n\n\tport = &i8042_ports[port_no];\n\tserio = port->exists ? port->serio : NULL;\n\n\tfilter_dbg(port->driver_bound, data, \"<- i8042 (interrupt, %d, %d%s%s)\\n\",\n\t\t   port_no, irq,\n\t\t   dfl & SERIO_PARITY ? \", bad parity\" : \"\",\n\t\t   dfl & SERIO_TIMEOUT ? \", timeout\" : \"\");\n\n\tfiltered = i8042_filter(data, str, serio);\n\n\tspin_unlock_irqrestore(&i8042_lock, flags);\n\n\tif (likely(serio && !filtered))\n\t\tserio_interrupt(serio, data, dfl);\n\n out:\n\treturn IRQ_RETVAL(ret);\n}",
        "patch": "--- code before\n+++ code after\n@@ -81,7 +81,7 @@\n \n \tspin_unlock_irqrestore(&i8042_lock, flags);\n \n-\tif (likely(port->exists && !filtered))\n+\tif (likely(serio && !filtered))\n \t\tserio_interrupt(serio, data, dfl);\n \n  out:",
        "function_modified_lines": {
            "added": [
                "\tif (likely(serio && !filtered))"
            ],
            "deleted": [
                "\tif (likely(port->exists && !filtered))"
            ]
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "drivers/input/serio/i8042.c in the Linux kernel before 4.12.4 allows attackers to cause a denial of service (NULL pointer dereference and system crash) or possibly have unspecified other impact because the port->exists value can change after it is validated.",
        "id": 1389
    },
    {
        "cve_id": "CVE-2019-15923",
        "code_before_change": "static void __exit pcd_exit(void)\n{\n\tstruct pcd_unit *cd;\n\tint unit;\n\n\tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\n\t\tif (cd->present) {\n\t\t\tdel_gendisk(cd->disk);\n\t\t\tpi_release(cd->pi);\n\t\t\tunregister_cdrom(&cd->info);\n\t\t}\n\t\tblk_cleanup_queue(cd->disk->queue);\n\t\tblk_mq_free_tag_set(&cd->tag_set);\n\t\tput_disk(cd->disk);\n\t}\n\tunregister_blkdev(major, name);\n\tpi_unregister_driver(par_drv);\n}",
        "code_after_change": "static void __exit pcd_exit(void)\n{\n\tstruct pcd_unit *cd;\n\tint unit;\n\n\tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\n\t\tif (!cd->disk)\n\t\t\tcontinue;\n\n\t\tif (cd->present) {\n\t\t\tdel_gendisk(cd->disk);\n\t\t\tpi_release(cd->pi);\n\t\t\tunregister_cdrom(&cd->info);\n\t\t}\n\t\tblk_cleanup_queue(cd->disk->queue);\n\t\tblk_mq_free_tag_set(&cd->tag_set);\n\t\tput_disk(cd->disk);\n\t}\n\tunregister_blkdev(major, name);\n\tpi_unregister_driver(par_drv);\n}",
        "patch": "--- code before\n+++ code after\n@@ -4,6 +4,9 @@\n \tint unit;\n \n \tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\n+\t\tif (!cd->disk)\n+\t\t\tcontinue;\n+\n \t\tif (cd->present) {\n \t\t\tdel_gendisk(cd->disk);\n \t\t\tpi_release(cd->pi);",
        "function_modified_lines": {
            "added": [
                "\t\tif (!cd->disk)",
                "\t\t\tcontinue;",
                ""
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "An issue was discovered in the Linux kernel before 5.0.9. There is a NULL pointer dereference for a cd data structure if alloc_disk fails in drivers/block/paride/pf.c.",
        "id": 2032
    },
    {
        "cve_id": "CVE-2023-3358",
        "code_before_change": "void *ishtp_cl_get_dma_send_buf(struct ishtp_device *dev,\n\t\t\t\tuint32_t size)\n{\n\tunsigned long\tflags;\n\tint i, j, free;\n\t/* additional slot is needed if there is rem */\n\tint required_slots = (size / DMA_SLOT_SIZE)\n\t\t+ 1 * (size % DMA_SLOT_SIZE != 0);\n\n\tspin_lock_irqsave(&dev->ishtp_dma_tx_lock, flags);\n\tfor (i = 0; i <= (dev->ishtp_dma_num_slots - required_slots); i++) {\n\t\tfree = 1;\n\t\tfor (j = 0; j < required_slots; j++)\n\t\t\tif (dev->ishtp_dma_tx_map[i+j]) {\n\t\t\t\tfree = 0;\n\t\t\t\ti += j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (free) {\n\t\t\t/* mark memory as \"caught\" */\n\t\t\tfor (j = 0; j < required_slots; j++)\n\t\t\t\tdev->ishtp_dma_tx_map[i+j] = 1;\n\t\t\tspin_unlock_irqrestore(&dev->ishtp_dma_tx_lock, flags);\n\t\t\treturn (i * DMA_SLOT_SIZE) +\n\t\t\t\t(unsigned char *)dev->ishtp_host_dma_tx_buf;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&dev->ishtp_dma_tx_lock, flags);\n\tdev_err(dev->devc, \"No free DMA buffer to send msg\\n\");\n\treturn NULL;\n}",
        "code_after_change": "void *ishtp_cl_get_dma_send_buf(struct ishtp_device *dev,\n\t\t\t\tuint32_t size)\n{\n\tunsigned long\tflags;\n\tint i, j, free;\n\t/* additional slot is needed if there is rem */\n\tint required_slots = (size / DMA_SLOT_SIZE)\n\t\t+ 1 * (size % DMA_SLOT_SIZE != 0);\n\n\tif (!dev->ishtp_dma_tx_map) {\n\t\tdev_err(dev->devc, \"Fail to allocate Tx map\\n\");\n\t\treturn NULL;\n\t}\n\n\tspin_lock_irqsave(&dev->ishtp_dma_tx_lock, flags);\n\tfor (i = 0; i <= (dev->ishtp_dma_num_slots - required_slots); i++) {\n\t\tfree = 1;\n\t\tfor (j = 0; j < required_slots; j++)\n\t\t\tif (dev->ishtp_dma_tx_map[i+j]) {\n\t\t\t\tfree = 0;\n\t\t\t\ti += j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (free) {\n\t\t\t/* mark memory as \"caught\" */\n\t\t\tfor (j = 0; j < required_slots; j++)\n\t\t\t\tdev->ishtp_dma_tx_map[i+j] = 1;\n\t\t\tspin_unlock_irqrestore(&dev->ishtp_dma_tx_lock, flags);\n\t\t\treturn (i * DMA_SLOT_SIZE) +\n\t\t\t\t(unsigned char *)dev->ishtp_host_dma_tx_buf;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&dev->ishtp_dma_tx_lock, flags);\n\tdev_err(dev->devc, \"No free DMA buffer to send msg\\n\");\n\treturn NULL;\n}",
        "patch": "--- code before\n+++ code after\n@@ -6,6 +6,11 @@\n \t/* additional slot is needed if there is rem */\n \tint required_slots = (size / DMA_SLOT_SIZE)\n \t\t+ 1 * (size % DMA_SLOT_SIZE != 0);\n+\n+\tif (!dev->ishtp_dma_tx_map) {\n+\t\tdev_err(dev->devc, \"Fail to allocate Tx map\\n\");\n+\t\treturn NULL;\n+\t}\n \n \tspin_lock_irqsave(&dev->ishtp_dma_tx_lock, flags);\n \tfor (i = 0; i <= (dev->ishtp_dma_num_slots - required_slots); i++) {",
        "function_modified_lines": {
            "added": [
                "",
                "\tif (!dev->ishtp_dma_tx_map) {",
                "\t\tdev_err(dev->devc, \"Fail to allocate Tx map\\n\");",
                "\t\treturn NULL;",
                "\t}"
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "A null pointer dereference was found in the Linux kernel's Integrated Sensor Hub (ISH) driver. This issue could allow a local user to crash the system.",
        "id": 4062
    },
    {
        "cve_id": "CVE-2017-16646",
        "code_before_change": "static int pctv340e_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dib0700_state *st = adap->dev->priv;\n\tstruct dib0700_adapter_state *state = adap->priv;\n\n\tif (!dvb_attach(dib7000p_attach, &state->dib7000p_ops))\n\t\treturn -ENODEV;\n\n\t/* Power Supply on */\n\tdib0700_set_gpio(adap->dev, GPIO6,  GPIO_OUT, 0);\n\tmsleep(50);\n\tdib0700_set_gpio(adap->dev, GPIO6,  GPIO_OUT, 1);\n\tmsleep(100); /* Allow power supply to settle before probing */\n\n\t/* cx25843 reset */\n\tdib0700_set_gpio(adap->dev, GPIO10,  GPIO_OUT, 0);\n\tmsleep(1); /* cx25843 datasheet say 350us required */\n\tdib0700_set_gpio(adap->dev, GPIO10,  GPIO_OUT, 1);\n\n\t/* LNA off for now */\n\tdib0700_set_gpio(adap->dev, GPIO8,  GPIO_OUT, 1);\n\n\t/* Put the CX25843 to sleep for now since we're in digital mode */\n\tdib0700_set_gpio(adap->dev, GPIO2, GPIO_OUT, 1);\n\n\t/* FIXME: not verified yet */\n\tdib0700_ctrl_clock(adap->dev, 72, 1);\n\n\tmsleep(500);\n\n\tif (state->dib7000p_ops.dib7000pc_detection(&adap->dev->i2c_adap) == 0) {\n\t\t/* Demodulator not found for some reason? */\n\t\tdvb_detach(&state->dib7000p_ops);\n\t\treturn -ENODEV;\n\t}\n\n\tadap->fe_adap[0].fe = state->dib7000p_ops.init(&adap->dev->i2c_adap, 0x12,\n\t\t\t      &pctv_340e_config);\n\tst->is_dib7000pc = 1;\n\n\treturn adap->fe_adap[0].fe == NULL ? -ENODEV : 0;\n}",
        "code_after_change": "static int pctv340e_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dib0700_state *st = adap->dev->priv;\n\tstruct dib0700_adapter_state *state = adap->priv;\n\n\tif (!dvb_attach(dib7000p_attach, &state->dib7000p_ops))\n\t\treturn -ENODEV;\n\n\t/* Power Supply on */\n\tdib0700_set_gpio(adap->dev, GPIO6,  GPIO_OUT, 0);\n\tmsleep(50);\n\tdib0700_set_gpio(adap->dev, GPIO6,  GPIO_OUT, 1);\n\tmsleep(100); /* Allow power supply to settle before probing */\n\n\t/* cx25843 reset */\n\tdib0700_set_gpio(adap->dev, GPIO10,  GPIO_OUT, 0);\n\tmsleep(1); /* cx25843 datasheet say 350us required */\n\tdib0700_set_gpio(adap->dev, GPIO10,  GPIO_OUT, 1);\n\n\t/* LNA off for now */\n\tdib0700_set_gpio(adap->dev, GPIO8,  GPIO_OUT, 1);\n\n\t/* Put the CX25843 to sleep for now since we're in digital mode */\n\tdib0700_set_gpio(adap->dev, GPIO2, GPIO_OUT, 1);\n\n\t/* FIXME: not verified yet */\n\tdib0700_ctrl_clock(adap->dev, 72, 1);\n\n\tmsleep(500);\n\n\tif (state->dib7000p_ops.dib7000pc_detection(&adap->dev->i2c_adap) == 0) {\n\t\t/* Demodulator not found for some reason? */\n\t\tdvb_detach(state->dib7000p_ops.set_wbd_ref);\n\t\treturn -ENODEV;\n\t}\n\n\tadap->fe_adap[0].fe = state->dib7000p_ops.init(&adap->dev->i2c_adap, 0x12,\n\t\t\t      &pctv_340e_config);\n\tst->is_dib7000pc = 1;\n\n\treturn adap->fe_adap[0].fe == NULL ? -ENODEV : 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -30,7 +30,7 @@\n \n \tif (state->dib7000p_ops.dib7000pc_detection(&adap->dev->i2c_adap) == 0) {\n \t\t/* Demodulator not found for some reason? */\n-\t\tdvb_detach(&state->dib7000p_ops);\n+\t\tdvb_detach(state->dib7000p_ops.set_wbd_ref);\n \t\treturn -ENODEV;\n \t}\n ",
        "function_modified_lines": {
            "added": [
                "\t\tdvb_detach(state->dib7000p_ops.set_wbd_ref);"
            ],
            "deleted": [
                "\t\tdvb_detach(&state->dib7000p_ops);"
            ]
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "drivers/media/usb/dvb-usb/dib0700_devices.c in the Linux kernel through 4.13.11 allows local users to cause a denial of service (BUG and system crash) or possibly have unspecified other impact via a crafted USB device.",
        "id": 1330
    },
    {
        "cve_id": "CVE-2017-16646",
        "code_before_change": "static int stk7770p_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct usb_device_descriptor *p = &adap->dev->udev->descriptor;\n\tstruct dib0700_adapter_state *state = adap->priv;\n\n\tif (!dvb_attach(dib7000p_attach, &state->dib7000p_ops))\n\t\treturn -ENODEV;\n\n\tif (p->idVendor  == cpu_to_le16(USB_VID_PINNACLE) &&\n\t    p->idProduct == cpu_to_le16(USB_PID_PINNACLE_PCTV72E))\n\t\tdib0700_set_gpio(adap->dev, GPIO6, GPIO_OUT, 0);\n\telse\n\t\tdib0700_set_gpio(adap->dev, GPIO6, GPIO_OUT, 1);\n\tmsleep(10);\n\tdib0700_set_gpio(adap->dev, GPIO9, GPIO_OUT, 1);\n\tdib0700_set_gpio(adap->dev, GPIO4, GPIO_OUT, 1);\n\tdib0700_set_gpio(adap->dev, GPIO7, GPIO_OUT, 1);\n\tdib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 0);\n\n\tdib0700_ctrl_clock(adap->dev, 72, 1);\n\n\tmsleep(10);\n\tdib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 1);\n\tmsleep(10);\n\tdib0700_set_gpio(adap->dev, GPIO0, GPIO_OUT, 1);\n\n\tif (state->dib7000p_ops.i2c_enumeration(&adap->dev->i2c_adap, 1, 18,\n\t\t\t\t     &dib7770p_dib7000p_config) != 0) {\n\t\terr(\"%s: state->dib7000p_ops.i2c_enumeration failed.  Cannot continue\\n\",\n\t\t    __func__);\n\t\tdvb_detach(&state->dib7000p_ops);\n\t\treturn -ENODEV;\n\t}\n\n\tadap->fe_adap[0].fe = state->dib7000p_ops.init(&adap->dev->i2c_adap, 0x80,\n\t\t&dib7770p_dib7000p_config);\n\treturn adap->fe_adap[0].fe == NULL ? -ENODEV : 0;\n}",
        "code_after_change": "static int stk7770p_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct usb_device_descriptor *p = &adap->dev->udev->descriptor;\n\tstruct dib0700_adapter_state *state = adap->priv;\n\n\tif (!dvb_attach(dib7000p_attach, &state->dib7000p_ops))\n\t\treturn -ENODEV;\n\n\tif (p->idVendor  == cpu_to_le16(USB_VID_PINNACLE) &&\n\t    p->idProduct == cpu_to_le16(USB_PID_PINNACLE_PCTV72E))\n\t\tdib0700_set_gpio(adap->dev, GPIO6, GPIO_OUT, 0);\n\telse\n\t\tdib0700_set_gpio(adap->dev, GPIO6, GPIO_OUT, 1);\n\tmsleep(10);\n\tdib0700_set_gpio(adap->dev, GPIO9, GPIO_OUT, 1);\n\tdib0700_set_gpio(adap->dev, GPIO4, GPIO_OUT, 1);\n\tdib0700_set_gpio(adap->dev, GPIO7, GPIO_OUT, 1);\n\tdib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 0);\n\n\tdib0700_ctrl_clock(adap->dev, 72, 1);\n\n\tmsleep(10);\n\tdib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 1);\n\tmsleep(10);\n\tdib0700_set_gpio(adap->dev, GPIO0, GPIO_OUT, 1);\n\n\tif (state->dib7000p_ops.i2c_enumeration(&adap->dev->i2c_adap, 1, 18,\n\t\t\t\t     &dib7770p_dib7000p_config) != 0) {\n\t\terr(\"%s: state->dib7000p_ops.i2c_enumeration failed.  Cannot continue\\n\",\n\t\t    __func__);\n\t\tdvb_detach(state->dib7000p_ops.set_wbd_ref);\n\t\treturn -ENODEV;\n\t}\n\n\tadap->fe_adap[0].fe = state->dib7000p_ops.init(&adap->dev->i2c_adap, 0x80,\n\t\t&dib7770p_dib7000p_config);\n\treturn adap->fe_adap[0].fe == NULL ? -ENODEV : 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -28,7 +28,7 @@\n \t\t\t\t     &dib7770p_dib7000p_config) != 0) {\n \t\terr(\"%s: state->dib7000p_ops.i2c_enumeration failed.  Cannot continue\\n\",\n \t\t    __func__);\n-\t\tdvb_detach(&state->dib7000p_ops);\n+\t\tdvb_detach(state->dib7000p_ops.set_wbd_ref);\n \t\treturn -ENODEV;\n \t}\n ",
        "function_modified_lines": {
            "added": [
                "\t\tdvb_detach(state->dib7000p_ops.set_wbd_ref);"
            ],
            "deleted": [
                "\t\tdvb_detach(&state->dib7000p_ops);"
            ]
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "drivers/media/usb/dvb-usb/dib0700_devices.c in the Linux kernel through 4.13.11 allows local users to cause a denial of service (BUG and system crash) or possibly have unspecified other impact via a crafted USB device.",
        "id": 1336
    },
    {
        "cve_id": "CVE-2017-16646",
        "code_before_change": "static int tfe7090pvr_frontend0_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dib0700_state *st = adap->dev->priv;\n\tstruct dib0700_adapter_state *state = adap->priv;\n\n\tif (!dvb_attach(dib7000p_attach, &state->dib7000p_ops))\n\t\treturn -ENODEV;\n\n\t/* The TFE7090 requires the dib0700 to not be in master mode */\n\tst->disable_streaming_master_mode = 1;\n\n\tdib0700_set_gpio(adap->dev, GPIO6, GPIO_OUT, 1);\n\tmsleep(20);\n\tdib0700_set_gpio(adap->dev, GPIO9, GPIO_OUT, 1);\n\tdib0700_set_gpio(adap->dev, GPIO4, GPIO_OUT, 1);\n\tdib0700_set_gpio(adap->dev, GPIO7, GPIO_OUT, 1);\n\tdib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 0);\n\n\tmsleep(20);\n\tdib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 1);\n\tmsleep(20);\n\tdib0700_set_gpio(adap->dev, GPIO0, GPIO_OUT, 1);\n\n\t/* initialize IC 0 */\n\tif (state->dib7000p_ops.i2c_enumeration(&adap->dev->i2c_adap, 1, 0x20, &tfe7090pvr_dib7000p_config[0]) != 0) {\n\t\terr(\"%s: state->dib7000p_ops.i2c_enumeration failed.  Cannot continue\\n\", __func__);\n\t\tdvb_detach(&state->dib7000p_ops);\n\t\treturn -ENODEV;\n\t}\n\n\tdib0700_set_i2c_speed(adap->dev, 340);\n\tadap->fe_adap[0].fe = state->dib7000p_ops.init(&adap->dev->i2c_adap, 0x90, &tfe7090pvr_dib7000p_config[0]);\n\tif (adap->fe_adap[0].fe == NULL)\n\t\treturn -ENODEV;\n\n\tstate->dib7000p_ops.slave_reset(adap->fe_adap[0].fe);\n\n\treturn 0;\n}",
        "code_after_change": "static int tfe7090pvr_frontend0_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dib0700_state *st = adap->dev->priv;\n\tstruct dib0700_adapter_state *state = adap->priv;\n\n\tif (!dvb_attach(dib7000p_attach, &state->dib7000p_ops))\n\t\treturn -ENODEV;\n\n\t/* The TFE7090 requires the dib0700 to not be in master mode */\n\tst->disable_streaming_master_mode = 1;\n\n\tdib0700_set_gpio(adap->dev, GPIO6, GPIO_OUT, 1);\n\tmsleep(20);\n\tdib0700_set_gpio(adap->dev, GPIO9, GPIO_OUT, 1);\n\tdib0700_set_gpio(adap->dev, GPIO4, GPIO_OUT, 1);\n\tdib0700_set_gpio(adap->dev, GPIO7, GPIO_OUT, 1);\n\tdib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 0);\n\n\tmsleep(20);\n\tdib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 1);\n\tmsleep(20);\n\tdib0700_set_gpio(adap->dev, GPIO0, GPIO_OUT, 1);\n\n\t/* initialize IC 0 */\n\tif (state->dib7000p_ops.i2c_enumeration(&adap->dev->i2c_adap, 1, 0x20, &tfe7090pvr_dib7000p_config[0]) != 0) {\n\t\terr(\"%s: state->dib7000p_ops.i2c_enumeration failed.  Cannot continue\\n\", __func__);\n\t\tdvb_detach(state->dib7000p_ops.set_wbd_ref);\n\t\treturn -ENODEV;\n\t}\n\n\tdib0700_set_i2c_speed(adap->dev, 340);\n\tadap->fe_adap[0].fe = state->dib7000p_ops.init(&adap->dev->i2c_adap, 0x90, &tfe7090pvr_dib7000p_config[0]);\n\tif (adap->fe_adap[0].fe == NULL)\n\t\treturn -ENODEV;\n\n\tstate->dib7000p_ops.slave_reset(adap->fe_adap[0].fe);\n\n\treturn 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -24,7 +24,7 @@\n \t/* initialize IC 0 */\n \tif (state->dib7000p_ops.i2c_enumeration(&adap->dev->i2c_adap, 1, 0x20, &tfe7090pvr_dib7000p_config[0]) != 0) {\n \t\terr(\"%s: state->dib7000p_ops.i2c_enumeration failed.  Cannot continue\\n\", __func__);\n-\t\tdvb_detach(&state->dib7000p_ops);\n+\t\tdvb_detach(state->dib7000p_ops.set_wbd_ref);\n \t\treturn -ENODEV;\n \t}\n ",
        "function_modified_lines": {
            "added": [
                "\t\tdvb_detach(state->dib7000p_ops.set_wbd_ref);"
            ],
            "deleted": [
                "\t\tdvb_detach(&state->dib7000p_ops);"
            ]
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "drivers/media/usb/dvb-usb/dib0700_devices.c in the Linux kernel through 4.13.11 allows local users to cause a denial of service (BUG and system crash) or possibly have unspecified other impact via a crafted USB device.",
        "id": 1335
    },
    {
        "cve_id": "CVE-2020-27675",
        "code_before_change": "evtchn_port_t evtchn_from_irq(unsigned irq)\n{\n\tif (WARN(irq >= nr_irqs, \"Invalid irq %d!\\n\", irq))\n\t\treturn 0;\n\n\treturn info_for_irq(irq)->evtchn;\n}",
        "code_after_change": "evtchn_port_t evtchn_from_irq(unsigned irq)\n{\n\tconst struct irq_info *info = NULL;\n\n\tif (likely(irq < nr_irqs))\n\t\tinfo = info_for_irq(irq);\n\tif (!info)\n\t\treturn 0;\n\n\treturn info->evtchn;\n}",
        "patch": "--- code before\n+++ code after\n@@ -1,7 +1,11 @@\n evtchn_port_t evtchn_from_irq(unsigned irq)\n {\n-\tif (WARN(irq >= nr_irqs, \"Invalid irq %d!\\n\", irq))\n+\tconst struct irq_info *info = NULL;\n+\n+\tif (likely(irq < nr_irqs))\n+\t\tinfo = info_for_irq(irq);\n+\tif (!info)\n \t\treturn 0;\n \n-\treturn info_for_irq(irq)->evtchn;\n+\treturn info->evtchn;\n }",
        "function_modified_lines": {
            "added": [
                "\tconst struct irq_info *info = NULL;",
                "",
                "\tif (likely(irq < nr_irqs))",
                "\t\tinfo = info_for_irq(irq);",
                "\tif (!info)",
                "\treturn info->evtchn;"
            ],
            "deleted": [
                "\tif (WARN(irq >= nr_irqs, \"Invalid irq %d!\\n\", irq))",
                "\treturn info_for_irq(irq)->evtchn;"
            ]
        },
        "cwe": [
            "CWE-362",
            "CWE-476",
            "CWE-416"
        ],
        "cve_description": "An issue was discovered in the Linux kernel through 5.9.1, as used with Xen through 4.14.x. drivers/xen/events/events_base.c allows event-channel removal during the event-handling loop (a race condition). This can cause a use-after-free or NULL pointer dereference, as demonstrated by a dom0 crash via events for an in-reconfiguration paravirtualized device, aka CID-073d0552ead5.",
        "id": 2626
    },
    {
        "cve_id": "CVE-2019-19815",
        "code_before_change": "static inline struct f2fs_sb_info *F2FS_P_SB(struct page *page)\n{\n\treturn F2FS_M_SB(page->mapping);\n}",
        "code_after_change": "static inline struct f2fs_sb_info *F2FS_P_SB(struct page *page)\n{\n\treturn F2FS_M_SB(page_file_mapping(page));\n}",
        "patch": "--- code before\n+++ code after\n@@ -1,4 +1,4 @@\n static inline struct f2fs_sb_info *F2FS_P_SB(struct page *page)\n {\n-\treturn F2FS_M_SB(page->mapping);\n+\treturn F2FS_M_SB(page_file_mapping(page));\n }",
        "function_modified_lines": {
            "added": [
                "\treturn F2FS_M_SB(page_file_mapping(page));"
            ],
            "deleted": [
                "\treturn F2FS_M_SB(page->mapping);"
            ]
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "In the Linux kernel 5.0.21, mounting a crafted f2fs filesystem image can cause a NULL pointer dereference in f2fs_recover_fsync_data in fs/f2fs/recovery.c. This is related to F2FS_P_SB in fs/f2fs/f2fs.h.",
        "id": 2253
    },
    {
        "cve_id": "CVE-2019-19815",
        "code_before_change": "static int f2fs_mpage_readpages(struct address_space *mapping,\n\t\t\tstruct list_head *pages, struct page *page,\n\t\t\tunsigned nr_pages, bool is_readahead)\n{\n\tstruct bio *bio = NULL;\n\tsector_t last_block_in_bio = 0;\n\tstruct inode *inode = mapping->host;\n\tstruct f2fs_map_blocks map;\n\tint ret = 0;\n\n\tmap.m_pblk = 0;\n\tmap.m_lblk = 0;\n\tmap.m_len = 0;\n\tmap.m_flags = 0;\n\tmap.m_next_pgofs = NULL;\n\tmap.m_next_extent = NULL;\n\tmap.m_seg_type = NO_CHECK_TYPE;\n\tmap.m_may_create = false;\n\n\tfor (; nr_pages; nr_pages--) {\n\t\tif (pages) {\n\t\t\tpage = list_last_entry(pages, struct page, lru);\n\n\t\t\tprefetchw(&page->flags);\n\t\t\tlist_del(&page->lru);\n\t\t\tif (add_to_page_cache_lru(page, mapping,\n\t\t\t\t\t\t  page->index,\n\t\t\t\t\t\t  readahead_gfp_mask(mapping)))\n\t\t\t\tgoto next_page;\n\t\t}\n\n\t\tret = f2fs_read_single_page(inode, page, nr_pages, &map, &bio,\n\t\t\t\t\t&last_block_in_bio, is_readahead);\n\t\tif (ret) {\n\t\t\tSetPageError(page);\n\t\t\tzero_user_segment(page, 0, PAGE_SIZE);\n\t\t\tunlock_page(page);\n\t\t}\nnext_page:\n\t\tif (pages)\n\t\t\tput_page(page);\n\t}\n\tBUG_ON(pages && !list_empty(pages));\n\tif (bio)\n\t\t__submit_bio(F2FS_I_SB(inode), bio, DATA);\n\treturn pages ? 0 : ret;\n}",
        "code_after_change": "static int f2fs_mpage_readpages(struct address_space *mapping,\n\t\t\tstruct list_head *pages, struct page *page,\n\t\t\tunsigned nr_pages, bool is_readahead)\n{\n\tstruct bio *bio = NULL;\n\tsector_t last_block_in_bio = 0;\n\tstruct inode *inode = mapping->host;\n\tstruct f2fs_map_blocks map;\n\tint ret = 0;\n\n\tmap.m_pblk = 0;\n\tmap.m_lblk = 0;\n\tmap.m_len = 0;\n\tmap.m_flags = 0;\n\tmap.m_next_pgofs = NULL;\n\tmap.m_next_extent = NULL;\n\tmap.m_seg_type = NO_CHECK_TYPE;\n\tmap.m_may_create = false;\n\n\tfor (; nr_pages; nr_pages--) {\n\t\tif (pages) {\n\t\t\tpage = list_last_entry(pages, struct page, lru);\n\n\t\t\tprefetchw(&page->flags);\n\t\t\tlist_del(&page->lru);\n\t\t\tif (add_to_page_cache_lru(page, mapping,\n\t\t\t\t\t\t  page_index(page),\n\t\t\t\t\t\t  readahead_gfp_mask(mapping)))\n\t\t\t\tgoto next_page;\n\t\t}\n\n\t\tret = f2fs_read_single_page(inode, page, nr_pages, &map, &bio,\n\t\t\t\t\t&last_block_in_bio, is_readahead);\n\t\tif (ret) {\n\t\t\tSetPageError(page);\n\t\t\tzero_user_segment(page, 0, PAGE_SIZE);\n\t\t\tunlock_page(page);\n\t\t}\nnext_page:\n\t\tif (pages)\n\t\t\tput_page(page);\n\t}\n\tBUG_ON(pages && !list_empty(pages));\n\tif (bio)\n\t\t__submit_bio(F2FS_I_SB(inode), bio, DATA);\n\treturn pages ? 0 : ret;\n}",
        "patch": "--- code before\n+++ code after\n@@ -24,7 +24,7 @@\n \t\t\tprefetchw(&page->flags);\n \t\t\tlist_del(&page->lru);\n \t\t\tif (add_to_page_cache_lru(page, mapping,\n-\t\t\t\t\t\t  page->index,\n+\t\t\t\t\t\t  page_index(page),\n \t\t\t\t\t\t  readahead_gfp_mask(mapping)))\n \t\t\t\tgoto next_page;\n \t\t}",
        "function_modified_lines": {
            "added": [
                "\t\t\t\t\t\t  page_index(page),"
            ],
            "deleted": [
                "\t\t\t\t\t\t  page->index,"
            ]
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "In the Linux kernel 5.0.21, mounting a crafted f2fs filesystem image can cause a NULL pointer dereference in f2fs_recover_fsync_data in fs/f2fs/recovery.c. This is related to F2FS_P_SB in fs/f2fs/f2fs.h.",
        "id": 2251
    },
    {
        "cve_id": "CVE-2022-1671",
        "code_before_change": "static void rxrpc_free_preparse_s(struct key_preparsed_payload *prep)\n{\n\tconst struct rxrpc_security *sec = prep->payload.data[1];\n\n\tif (sec)\n\t\tsec->free_preparse_server_key(prep);\n}",
        "code_after_change": "static void rxrpc_free_preparse_s(struct key_preparsed_payload *prep)\n{\n\tconst struct rxrpc_security *sec = prep->payload.data[1];\n\n\tif (sec && sec->free_preparse_server_key)\n\t\tsec->free_preparse_server_key(prep);\n}",
        "patch": "--- code before\n+++ code after\n@@ -2,6 +2,6 @@\n {\n \tconst struct rxrpc_security *sec = prep->payload.data[1];\n \n-\tif (sec)\n+\tif (sec && sec->free_preparse_server_key)\n \t\tsec->free_preparse_server_key(prep);\n }",
        "function_modified_lines": {
            "added": [
                "\tif (sec && sec->free_preparse_server_key)"
            ],
            "deleted": [
                "\tif (sec)"
            ]
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "A NULL pointer dereference flaw was found in rxrpc_preparse_s in net/rxrpc/server_key.c in the Linux kernel. This flaw allows a local attacker to crash the system or leak internal kernel information.",
        "id": 3273
    },
    {
        "cve_id": "CVE-2022-23222",
        "code_before_change": "static void print_verifier_state(struct bpf_verifier_env *env,\n\t\t\t\t const struct bpf_func_state *state,\n\t\t\t\t bool print_all)\n{\n\tconst struct bpf_reg_state *reg;\n\tenum bpf_reg_type t;\n\tint i;\n\n\tif (state->frameno)\n\t\tverbose(env, \" frame%d:\", state->frameno);\n\tfor (i = 0; i < MAX_BPF_REG; i++) {\n\t\treg = &state->regs[i];\n\t\tt = reg->type;\n\t\tif (t == NOT_INIT)\n\t\t\tcontinue;\n\t\tif (!print_all && !reg_scratched(env, i))\n\t\t\tcontinue;\n\t\tverbose(env, \" R%d\", i);\n\t\tprint_liveness(env, reg->live);\n\t\tverbose(env, \"=%s\", reg_type_str[t]);\n\t\tif (t == SCALAR_VALUE && reg->precise)\n\t\t\tverbose(env, \"P\");\n\t\tif ((t == SCALAR_VALUE || t == PTR_TO_STACK) &&\n\t\t    tnum_is_const(reg->var_off)) {\n\t\t\t/* reg->off should be 0 for SCALAR_VALUE */\n\t\t\tverbose(env, \"%lld\", reg->var_off.value + reg->off);\n\t\t} else {\n\t\t\tif (t == PTR_TO_BTF_ID ||\n\t\t\t    t == PTR_TO_BTF_ID_OR_NULL ||\n\t\t\t    t == PTR_TO_PERCPU_BTF_ID)\n\t\t\t\tverbose(env, \"%s\", kernel_type_name(reg->btf, reg->btf_id));\n\t\t\tverbose(env, \"(id=%d\", reg->id);\n\t\t\tif (reg_type_may_be_refcounted_or_null(t))\n\t\t\t\tverbose(env, \",ref_obj_id=%d\", reg->ref_obj_id);\n\t\t\tif (t != SCALAR_VALUE)\n\t\t\t\tverbose(env, \",off=%d\", reg->off);\n\t\t\tif (type_is_pkt_pointer(t))\n\t\t\t\tverbose(env, \",r=%d\", reg->range);\n\t\t\telse if (t == CONST_PTR_TO_MAP ||\n\t\t\t\t t == PTR_TO_MAP_KEY ||\n\t\t\t\t t == PTR_TO_MAP_VALUE ||\n\t\t\t\t t == PTR_TO_MAP_VALUE_OR_NULL)\n\t\t\t\tverbose(env, \",ks=%d,vs=%d\",\n\t\t\t\t\treg->map_ptr->key_size,\n\t\t\t\t\treg->map_ptr->value_size);\n\t\t\tif (tnum_is_const(reg->var_off)) {\n\t\t\t\t/* Typically an immediate SCALAR_VALUE, but\n\t\t\t\t * could be a pointer whose offset is too big\n\t\t\t\t * for reg->off\n\t\t\t\t */\n\t\t\t\tverbose(env, \",imm=%llx\", reg->var_off.value);\n\t\t\t} else {\n\t\t\t\tif (reg->smin_value != reg->umin_value &&\n\t\t\t\t    reg->smin_value != S64_MIN)\n\t\t\t\t\tverbose(env, \",smin_value=%lld\",\n\t\t\t\t\t\t(long long)reg->smin_value);\n\t\t\t\tif (reg->smax_value != reg->umax_value &&\n\t\t\t\t    reg->smax_value != S64_MAX)\n\t\t\t\t\tverbose(env, \",smax_value=%lld\",\n\t\t\t\t\t\t(long long)reg->smax_value);\n\t\t\t\tif (reg->umin_value != 0)\n\t\t\t\t\tverbose(env, \",umin_value=%llu\",\n\t\t\t\t\t\t(unsigned long long)reg->umin_value);\n\t\t\t\tif (reg->umax_value != U64_MAX)\n\t\t\t\t\tverbose(env, \",umax_value=%llu\",\n\t\t\t\t\t\t(unsigned long long)reg->umax_value);\n\t\t\t\tif (!tnum_is_unknown(reg->var_off)) {\n\t\t\t\t\tchar tn_buf[48];\n\n\t\t\t\t\ttnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);\n\t\t\t\t\tverbose(env, \",var_off=%s\", tn_buf);\n\t\t\t\t}\n\t\t\t\tif (reg->s32_min_value != reg->smin_value &&\n\t\t\t\t    reg->s32_min_value != S32_MIN)\n\t\t\t\t\tverbose(env, \",s32_min_value=%d\",\n\t\t\t\t\t\t(int)(reg->s32_min_value));\n\t\t\t\tif (reg->s32_max_value != reg->smax_value &&\n\t\t\t\t    reg->s32_max_value != S32_MAX)\n\t\t\t\t\tverbose(env, \",s32_max_value=%d\",\n\t\t\t\t\t\t(int)(reg->s32_max_value));\n\t\t\t\tif (reg->u32_min_value != reg->umin_value &&\n\t\t\t\t    reg->u32_min_value != U32_MIN)\n\t\t\t\t\tverbose(env, \",u32_min_value=%d\",\n\t\t\t\t\t\t(int)(reg->u32_min_value));\n\t\t\t\tif (reg->u32_max_value != reg->umax_value &&\n\t\t\t\t    reg->u32_max_value != U32_MAX)\n\t\t\t\t\tverbose(env, \",u32_max_value=%d\",\n\t\t\t\t\t\t(int)(reg->u32_max_value));\n\t\t\t}\n\t\t\tverbose(env, \")\");\n\t\t}\n\t}\n\tfor (i = 0; i < state->allocated_stack / BPF_REG_SIZE; i++) {\n\t\tchar types_buf[BPF_REG_SIZE + 1];\n\t\tbool valid = false;\n\t\tint j;\n\n\t\tfor (j = 0; j < BPF_REG_SIZE; j++) {\n\t\t\tif (state->stack[i].slot_type[j] != STACK_INVALID)\n\t\t\t\tvalid = true;\n\t\t\ttypes_buf[j] = slot_type_char[\n\t\t\t\t\tstate->stack[i].slot_type[j]];\n\t\t}\n\t\ttypes_buf[BPF_REG_SIZE] = 0;\n\t\tif (!valid)\n\t\t\tcontinue;\n\t\tif (!print_all && !stack_slot_scratched(env, i))\n\t\t\tcontinue;\n\t\tverbose(env, \" fp%d\", (-i - 1) * BPF_REG_SIZE);\n\t\tprint_liveness(env, state->stack[i].spilled_ptr.live);\n\t\tif (is_spilled_reg(&state->stack[i])) {\n\t\t\treg = &state->stack[i].spilled_ptr;\n\t\t\tt = reg->type;\n\t\t\tverbose(env, \"=%s\", reg_type_str[t]);\n\t\t\tif (t == SCALAR_VALUE && reg->precise)\n\t\t\t\tverbose(env, \"P\");\n\t\t\tif (t == SCALAR_VALUE && tnum_is_const(reg->var_off))\n\t\t\t\tverbose(env, \"%lld\", reg->var_off.value + reg->off);\n\t\t} else {\n\t\t\tverbose(env, \"=%s\", types_buf);\n\t\t}\n\t}\n\tif (state->acquired_refs && state->refs[0].id) {\n\t\tverbose(env, \" refs=%d\", state->refs[0].id);\n\t\tfor (i = 1; i < state->acquired_refs; i++)\n\t\t\tif (state->refs[i].id)\n\t\t\t\tverbose(env, \",%d\", state->refs[i].id);\n\t}\n\tif (state->in_callback_fn)\n\t\tverbose(env, \" cb\");\n\tif (state->in_async_callback_fn)\n\t\tverbose(env, \" async_cb\");\n\tverbose(env, \"\\n\");\n\tmark_verifier_state_clean(env);\n}",
        "code_after_change": "static void print_verifier_state(struct bpf_verifier_env *env,\n\t\t\t\t const struct bpf_func_state *state,\n\t\t\t\t bool print_all)\n{\n\tconst struct bpf_reg_state *reg;\n\tenum bpf_reg_type t;\n\tint i;\n\n\tif (state->frameno)\n\t\tverbose(env, \" frame%d:\", state->frameno);\n\tfor (i = 0; i < MAX_BPF_REG; i++) {\n\t\treg = &state->regs[i];\n\t\tt = reg->type;\n\t\tif (t == NOT_INIT)\n\t\t\tcontinue;\n\t\tif (!print_all && !reg_scratched(env, i))\n\t\t\tcontinue;\n\t\tverbose(env, \" R%d\", i);\n\t\tprint_liveness(env, reg->live);\n\t\tverbose(env, \"=%s\", reg_type_str(env, t));\n\t\tif (t == SCALAR_VALUE && reg->precise)\n\t\t\tverbose(env, \"P\");\n\t\tif ((t == SCALAR_VALUE || t == PTR_TO_STACK) &&\n\t\t    tnum_is_const(reg->var_off)) {\n\t\t\t/* reg->off should be 0 for SCALAR_VALUE */\n\t\t\tverbose(env, \"%lld\", reg->var_off.value + reg->off);\n\t\t} else {\n\t\t\tif (base_type(t) == PTR_TO_BTF_ID ||\n\t\t\t    base_type(t) == PTR_TO_PERCPU_BTF_ID)\n\t\t\t\tverbose(env, \"%s\", kernel_type_name(reg->btf, reg->btf_id));\n\t\t\tverbose(env, \"(id=%d\", reg->id);\n\t\t\tif (reg_type_may_be_refcounted_or_null(t))\n\t\t\t\tverbose(env, \",ref_obj_id=%d\", reg->ref_obj_id);\n\t\t\tif (t != SCALAR_VALUE)\n\t\t\t\tverbose(env, \",off=%d\", reg->off);\n\t\t\tif (type_is_pkt_pointer(t))\n\t\t\t\tverbose(env, \",r=%d\", reg->range);\n\t\t\telse if (base_type(t) == CONST_PTR_TO_MAP ||\n\t\t\t\t base_type(t) == PTR_TO_MAP_KEY ||\n\t\t\t\t base_type(t) == PTR_TO_MAP_VALUE)\n\t\t\t\tverbose(env, \",ks=%d,vs=%d\",\n\t\t\t\t\treg->map_ptr->key_size,\n\t\t\t\t\treg->map_ptr->value_size);\n\t\t\tif (tnum_is_const(reg->var_off)) {\n\t\t\t\t/* Typically an immediate SCALAR_VALUE, but\n\t\t\t\t * could be a pointer whose offset is too big\n\t\t\t\t * for reg->off\n\t\t\t\t */\n\t\t\t\tverbose(env, \",imm=%llx\", reg->var_off.value);\n\t\t\t} else {\n\t\t\t\tif (reg->smin_value != reg->umin_value &&\n\t\t\t\t    reg->smin_value != S64_MIN)\n\t\t\t\t\tverbose(env, \",smin_value=%lld\",\n\t\t\t\t\t\t(long long)reg->smin_value);\n\t\t\t\tif (reg->smax_value != reg->umax_value &&\n\t\t\t\t    reg->smax_value != S64_MAX)\n\t\t\t\t\tverbose(env, \",smax_value=%lld\",\n\t\t\t\t\t\t(long long)reg->smax_value);\n\t\t\t\tif (reg->umin_value != 0)\n\t\t\t\t\tverbose(env, \",umin_value=%llu\",\n\t\t\t\t\t\t(unsigned long long)reg->umin_value);\n\t\t\t\tif (reg->umax_value != U64_MAX)\n\t\t\t\t\tverbose(env, \",umax_value=%llu\",\n\t\t\t\t\t\t(unsigned long long)reg->umax_value);\n\t\t\t\tif (!tnum_is_unknown(reg->var_off)) {\n\t\t\t\t\tchar tn_buf[48];\n\n\t\t\t\t\ttnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);\n\t\t\t\t\tverbose(env, \",var_off=%s\", tn_buf);\n\t\t\t\t}\n\t\t\t\tif (reg->s32_min_value != reg->smin_value &&\n\t\t\t\t    reg->s32_min_value != S32_MIN)\n\t\t\t\t\tverbose(env, \",s32_min_value=%d\",\n\t\t\t\t\t\t(int)(reg->s32_min_value));\n\t\t\t\tif (reg->s32_max_value != reg->smax_value &&\n\t\t\t\t    reg->s32_max_value != S32_MAX)\n\t\t\t\t\tverbose(env, \",s32_max_value=%d\",\n\t\t\t\t\t\t(int)(reg->s32_max_value));\n\t\t\t\tif (reg->u32_min_value != reg->umin_value &&\n\t\t\t\t    reg->u32_min_value != U32_MIN)\n\t\t\t\t\tverbose(env, \",u32_min_value=%d\",\n\t\t\t\t\t\t(int)(reg->u32_min_value));\n\t\t\t\tif (reg->u32_max_value != reg->umax_value &&\n\t\t\t\t    reg->u32_max_value != U32_MAX)\n\t\t\t\t\tverbose(env, \",u32_max_value=%d\",\n\t\t\t\t\t\t(int)(reg->u32_max_value));\n\t\t\t}\n\t\t\tverbose(env, \")\");\n\t\t}\n\t}\n\tfor (i = 0; i < state->allocated_stack / BPF_REG_SIZE; i++) {\n\t\tchar types_buf[BPF_REG_SIZE + 1];\n\t\tbool valid = false;\n\t\tint j;\n\n\t\tfor (j = 0; j < BPF_REG_SIZE; j++) {\n\t\t\tif (state->stack[i].slot_type[j] != STACK_INVALID)\n\t\t\t\tvalid = true;\n\t\t\ttypes_buf[j] = slot_type_char[\n\t\t\t\t\tstate->stack[i].slot_type[j]];\n\t\t}\n\t\ttypes_buf[BPF_REG_SIZE] = 0;\n\t\tif (!valid)\n\t\t\tcontinue;\n\t\tif (!print_all && !stack_slot_scratched(env, i))\n\t\t\tcontinue;\n\t\tverbose(env, \" fp%d\", (-i - 1) * BPF_REG_SIZE);\n\t\tprint_liveness(env, state->stack[i].spilled_ptr.live);\n\t\tif (is_spilled_reg(&state->stack[i])) {\n\t\t\treg = &state->stack[i].spilled_ptr;\n\t\t\tt = reg->type;\n\t\t\tverbose(env, \"=%s\", reg_type_str(env, t));\n\t\t\tif (t == SCALAR_VALUE && reg->precise)\n\t\t\t\tverbose(env, \"P\");\n\t\t\tif (t == SCALAR_VALUE && tnum_is_const(reg->var_off))\n\t\t\t\tverbose(env, \"%lld\", reg->var_off.value + reg->off);\n\t\t} else {\n\t\t\tverbose(env, \"=%s\", types_buf);\n\t\t}\n\t}\n\tif (state->acquired_refs && state->refs[0].id) {\n\t\tverbose(env, \" refs=%d\", state->refs[0].id);\n\t\tfor (i = 1; i < state->acquired_refs; i++)\n\t\t\tif (state->refs[i].id)\n\t\t\t\tverbose(env, \",%d\", state->refs[i].id);\n\t}\n\tif (state->in_callback_fn)\n\t\tverbose(env, \" cb\");\n\tif (state->in_async_callback_fn)\n\t\tverbose(env, \" async_cb\");\n\tverbose(env, \"\\n\");\n\tmark_verifier_state_clean(env);\n}",
        "patch": "--- code before\n+++ code after\n@@ -17,7 +17,7 @@\n \t\t\tcontinue;\n \t\tverbose(env, \" R%d\", i);\n \t\tprint_liveness(env, reg->live);\n-\t\tverbose(env, \"=%s\", reg_type_str[t]);\n+\t\tverbose(env, \"=%s\", reg_type_str(env, t));\n \t\tif (t == SCALAR_VALUE && reg->precise)\n \t\t\tverbose(env, \"P\");\n \t\tif ((t == SCALAR_VALUE || t == PTR_TO_STACK) &&\n@@ -25,9 +25,8 @@\n \t\t\t/* reg->off should be 0 for SCALAR_VALUE */\n \t\t\tverbose(env, \"%lld\", reg->var_off.value + reg->off);\n \t\t} else {\n-\t\t\tif (t == PTR_TO_BTF_ID ||\n-\t\t\t    t == PTR_TO_BTF_ID_OR_NULL ||\n-\t\t\t    t == PTR_TO_PERCPU_BTF_ID)\n+\t\t\tif (base_type(t) == PTR_TO_BTF_ID ||\n+\t\t\t    base_type(t) == PTR_TO_PERCPU_BTF_ID)\n \t\t\t\tverbose(env, \"%s\", kernel_type_name(reg->btf, reg->btf_id));\n \t\t\tverbose(env, \"(id=%d\", reg->id);\n \t\t\tif (reg_type_may_be_refcounted_or_null(t))\n@@ -36,10 +35,9 @@\n \t\t\t\tverbose(env, \",off=%d\", reg->off);\n \t\t\tif (type_is_pkt_pointer(t))\n \t\t\t\tverbose(env, \",r=%d\", reg->range);\n-\t\t\telse if (t == CONST_PTR_TO_MAP ||\n-\t\t\t\t t == PTR_TO_MAP_KEY ||\n-\t\t\t\t t == PTR_TO_MAP_VALUE ||\n-\t\t\t\t t == PTR_TO_MAP_VALUE_OR_NULL)\n+\t\t\telse if (base_type(t) == CONST_PTR_TO_MAP ||\n+\t\t\t\t base_type(t) == PTR_TO_MAP_KEY ||\n+\t\t\t\t base_type(t) == PTR_TO_MAP_VALUE)\n \t\t\t\tverbose(env, \",ks=%d,vs=%d\",\n \t\t\t\t\treg->map_ptr->key_size,\n \t\t\t\t\treg->map_ptr->value_size);\n@@ -111,7 +109,7 @@\n \t\tif (is_spilled_reg(&state->stack[i])) {\n \t\t\treg = &state->stack[i].spilled_ptr;\n \t\t\tt = reg->type;\n-\t\t\tverbose(env, \"=%s\", reg_type_str[t]);\n+\t\t\tverbose(env, \"=%s\", reg_type_str(env, t));\n \t\t\tif (t == SCALAR_VALUE && reg->precise)\n \t\t\t\tverbose(env, \"P\");\n \t\t\tif (t == SCALAR_VALUE && tnum_is_const(reg->var_off))",
        "function_modified_lines": {
            "added": [
                "\t\tverbose(env, \"=%s\", reg_type_str(env, t));",
                "\t\t\tif (base_type(t) == PTR_TO_BTF_ID ||",
                "\t\t\t    base_type(t) == PTR_TO_PERCPU_BTF_ID)",
                "\t\t\telse if (base_type(t) == CONST_PTR_TO_MAP ||",
                "\t\t\t\t base_type(t) == PTR_TO_MAP_KEY ||",
                "\t\t\t\t base_type(t) == PTR_TO_MAP_VALUE)",
                "\t\t\tverbose(env, \"=%s\", reg_type_str(env, t));"
            ],
            "deleted": [
                "\t\tverbose(env, \"=%s\", reg_type_str[t]);",
                "\t\t\tif (t == PTR_TO_BTF_ID ||",
                "\t\t\t    t == PTR_TO_BTF_ID_OR_NULL ||",
                "\t\t\t    t == PTR_TO_PERCPU_BTF_ID)",
                "\t\t\telse if (t == CONST_PTR_TO_MAP ||",
                "\t\t\t\t t == PTR_TO_MAP_KEY ||",
                "\t\t\t\t t == PTR_TO_MAP_VALUE ||",
                "\t\t\t\t t == PTR_TO_MAP_VALUE_OR_NULL)",
                "\t\t\tverbose(env, \"=%s\", reg_type_str[t]);"
            ]
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "kernel/bpf/verifier.c in the Linux kernel through 5.15.14 allows local users to gain privileges because of the availability of pointer arithmetic via certain *_OR_NULL pointer types.",
        "id": 3455
    },
    {
        "cve_id": "CVE-2022-23222",
        "code_before_change": "static int adjust_ptr_min_max_vals(struct bpf_verifier_env *env,\n\t\t\t\t   struct bpf_insn *insn,\n\t\t\t\t   const struct bpf_reg_state *ptr_reg,\n\t\t\t\t   const struct bpf_reg_state *off_reg)\n{\n\tstruct bpf_verifier_state *vstate = env->cur_state;\n\tstruct bpf_func_state *state = vstate->frame[vstate->curframe];\n\tstruct bpf_reg_state *regs = state->regs, *dst_reg;\n\tbool known = tnum_is_const(off_reg->var_off);\n\ts64 smin_val = off_reg->smin_value, smax_val = off_reg->smax_value,\n\t    smin_ptr = ptr_reg->smin_value, smax_ptr = ptr_reg->smax_value;\n\tu64 umin_val = off_reg->umin_value, umax_val = off_reg->umax_value,\n\t    umin_ptr = ptr_reg->umin_value, umax_ptr = ptr_reg->umax_value;\n\tstruct bpf_sanitize_info info = {};\n\tu8 opcode = BPF_OP(insn->code);\n\tu32 dst = insn->dst_reg;\n\tint ret;\n\n\tdst_reg = &regs[dst];\n\n\tif ((known && (smin_val != smax_val || umin_val != umax_val)) ||\n\t    smin_val > smax_val || umin_val > umax_val) {\n\t\t/* Taint dst register if offset had invalid bounds derived from\n\t\t * e.g. dead branches.\n\t\t */\n\t\t__mark_reg_unknown(env, dst_reg);\n\t\treturn 0;\n\t}\n\n\tif (BPF_CLASS(insn->code) != BPF_ALU64) {\n\t\t/* 32-bit ALU ops on pointers produce (meaningless) scalars */\n\t\tif (opcode == BPF_SUB && env->allow_ptr_leaks) {\n\t\t\t__mark_reg_unknown(env, dst_reg);\n\t\t\treturn 0;\n\t\t}\n\n\t\tverbose(env,\n\t\t\t\"R%d 32-bit pointer arithmetic prohibited\\n\",\n\t\t\tdst);\n\t\treturn -EACCES;\n\t}\n\n\tswitch (ptr_reg->type) {\n\tcase PTR_TO_MAP_VALUE_OR_NULL:\n\t\tverbose(env, \"R%d pointer arithmetic on %s prohibited, null-check it first\\n\",\n\t\t\tdst, reg_type_str[ptr_reg->type]);\n\t\treturn -EACCES;\n\tcase CONST_PTR_TO_MAP:\n\t\t/* smin_val represents the known value */\n\t\tif (known && smin_val == 0 && opcode == BPF_ADD)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase PTR_TO_PACKET_END:\n\tcase PTR_TO_SOCKET:\n\tcase PTR_TO_SOCKET_OR_NULL:\n\tcase PTR_TO_SOCK_COMMON:\n\tcase PTR_TO_SOCK_COMMON_OR_NULL:\n\tcase PTR_TO_TCP_SOCK:\n\tcase PTR_TO_TCP_SOCK_OR_NULL:\n\tcase PTR_TO_XDP_SOCK:\n\t\tverbose(env, \"R%d pointer arithmetic on %s prohibited\\n\",\n\t\t\tdst, reg_type_str[ptr_reg->type]);\n\t\treturn -EACCES;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/* In case of 'scalar += pointer', dst_reg inherits pointer type and id.\n\t * The id may be overwritten later if we create a new variable offset.\n\t */\n\tdst_reg->type = ptr_reg->type;\n\tdst_reg->id = ptr_reg->id;\n\n\tif (!check_reg_sane_offset(env, off_reg, ptr_reg->type) ||\n\t    !check_reg_sane_offset(env, ptr_reg, ptr_reg->type))\n\t\treturn -EINVAL;\n\n\t/* pointer types do not carry 32-bit bounds at the moment. */\n\t__mark_reg32_unbounded(dst_reg);\n\n\tif (sanitize_needed(opcode)) {\n\t\tret = sanitize_ptr_alu(env, insn, ptr_reg, off_reg, dst_reg,\n\t\t\t\t       &info, false);\n\t\tif (ret < 0)\n\t\t\treturn sanitize_err(env, insn, ret, off_reg, dst_reg);\n\t}\n\n\tswitch (opcode) {\n\tcase BPF_ADD:\n\t\t/* We can take a fixed offset as long as it doesn't overflow\n\t\t * the s32 'off' field\n\t\t */\n\t\tif (known && (ptr_reg->off + smin_val ==\n\t\t\t      (s64)(s32)(ptr_reg->off + smin_val))) {\n\t\t\t/* pointer += K.  Accumulate it into fixed offset */\n\t\t\tdst_reg->smin_value = smin_ptr;\n\t\t\tdst_reg->smax_value = smax_ptr;\n\t\t\tdst_reg->umin_value = umin_ptr;\n\t\t\tdst_reg->umax_value = umax_ptr;\n\t\t\tdst_reg->var_off = ptr_reg->var_off;\n\t\t\tdst_reg->off = ptr_reg->off + smin_val;\n\t\t\tdst_reg->raw = ptr_reg->raw;\n\t\t\tbreak;\n\t\t}\n\t\t/* A new variable offset is created.  Note that off_reg->off\n\t\t * == 0, since it's a scalar.\n\t\t * dst_reg gets the pointer type and since some positive\n\t\t * integer value was added to the pointer, give it a new 'id'\n\t\t * if it's a PTR_TO_PACKET.\n\t\t * this creates a new 'base' pointer, off_reg (variable) gets\n\t\t * added into the variable offset, and we copy the fixed offset\n\t\t * from ptr_reg.\n\t\t */\n\t\tif (signed_add_overflows(smin_ptr, smin_val) ||\n\t\t    signed_add_overflows(smax_ptr, smax_val)) {\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value = smin_ptr + smin_val;\n\t\t\tdst_reg->smax_value = smax_ptr + smax_val;\n\t\t}\n\t\tif (umin_ptr + umin_val < umin_ptr ||\n\t\t    umax_ptr + umax_val < umax_ptr) {\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\tdst_reg->umin_value = umin_ptr + umin_val;\n\t\t\tdst_reg->umax_value = umax_ptr + umax_val;\n\t\t}\n\t\tdst_reg->var_off = tnum_add(ptr_reg->var_off, off_reg->var_off);\n\t\tdst_reg->off = ptr_reg->off;\n\t\tdst_reg->raw = ptr_reg->raw;\n\t\tif (reg_is_pkt_pointer(ptr_reg)) {\n\t\t\tdst_reg->id = ++env->id_gen;\n\t\t\t/* something was added to pkt_ptr, set range to zero */\n\t\t\tmemset(&dst_reg->raw, 0, sizeof(dst_reg->raw));\n\t\t}\n\t\tbreak;\n\tcase BPF_SUB:\n\t\tif (dst_reg == off_reg) {\n\t\t\t/* scalar -= pointer.  Creates an unknown scalar */\n\t\t\tverbose(env, \"R%d tried to subtract pointer from scalar\\n\",\n\t\t\t\tdst);\n\t\t\treturn -EACCES;\n\t\t}\n\t\t/* We don't allow subtraction from FP, because (according to\n\t\t * test_verifier.c test \"invalid fp arithmetic\", JITs might not\n\t\t * be able to deal with it.\n\t\t */\n\t\tif (ptr_reg->type == PTR_TO_STACK) {\n\t\t\tverbose(env, \"R%d subtraction from stack pointer prohibited\\n\",\n\t\t\t\tdst);\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (known && (ptr_reg->off - smin_val ==\n\t\t\t      (s64)(s32)(ptr_reg->off - smin_val))) {\n\t\t\t/* pointer -= K.  Subtract it from fixed offset */\n\t\t\tdst_reg->smin_value = smin_ptr;\n\t\t\tdst_reg->smax_value = smax_ptr;\n\t\t\tdst_reg->umin_value = umin_ptr;\n\t\t\tdst_reg->umax_value = umax_ptr;\n\t\t\tdst_reg->var_off = ptr_reg->var_off;\n\t\t\tdst_reg->id = ptr_reg->id;\n\t\t\tdst_reg->off = ptr_reg->off - smin_val;\n\t\t\tdst_reg->raw = ptr_reg->raw;\n\t\t\tbreak;\n\t\t}\n\t\t/* A new variable offset is created.  If the subtrahend is known\n\t\t * nonnegative, then any reg->range we had before is still good.\n\t\t */\n\t\tif (signed_sub_overflows(smin_ptr, smax_val) ||\n\t\t    signed_sub_overflows(smax_ptr, smin_val)) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value = smin_ptr - smax_val;\n\t\t\tdst_reg->smax_value = smax_ptr - smin_val;\n\t\t}\n\t\tif (umin_ptr < umax_val) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\t/* Cannot overflow (as long as bounds are consistent) */\n\t\t\tdst_reg->umin_value = umin_ptr - umax_val;\n\t\t\tdst_reg->umax_value = umax_ptr - umin_val;\n\t\t}\n\t\tdst_reg->var_off = tnum_sub(ptr_reg->var_off, off_reg->var_off);\n\t\tdst_reg->off = ptr_reg->off;\n\t\tdst_reg->raw = ptr_reg->raw;\n\t\tif (reg_is_pkt_pointer(ptr_reg)) {\n\t\t\tdst_reg->id = ++env->id_gen;\n\t\t\t/* something was added to pkt_ptr, set range to zero */\n\t\t\tif (smin_val < 0)\n\t\t\t\tmemset(&dst_reg->raw, 0, sizeof(dst_reg->raw));\n\t\t}\n\t\tbreak;\n\tcase BPF_AND:\n\tcase BPF_OR:\n\tcase BPF_XOR:\n\t\t/* bitwise ops on pointers are troublesome, prohibit. */\n\t\tverbose(env, \"R%d bitwise operator %s on pointer prohibited\\n\",\n\t\t\tdst, bpf_alu_string[opcode >> 4]);\n\t\treturn -EACCES;\n\tdefault:\n\t\t/* other operators (e.g. MUL,LSH) produce non-pointer results */\n\t\tverbose(env, \"R%d pointer arithmetic with %s operator prohibited\\n\",\n\t\t\tdst, bpf_alu_string[opcode >> 4]);\n\t\treturn -EACCES;\n\t}\n\n\tif (!check_reg_sane_offset(env, dst_reg, ptr_reg->type))\n\t\treturn -EINVAL;\n\n\t__update_reg_bounds(dst_reg);\n\t__reg_deduce_bounds(dst_reg);\n\t__reg_bound_offset(dst_reg);\n\n\tif (sanitize_check_bounds(env, insn, dst_reg) < 0)\n\t\treturn -EACCES;\n\tif (sanitize_needed(opcode)) {\n\t\tret = sanitize_ptr_alu(env, insn, dst_reg, off_reg, dst_reg,\n\t\t\t\t       &info, true);\n\t\tif (ret < 0)\n\t\t\treturn sanitize_err(env, insn, ret, off_reg, dst_reg);\n\t}\n\n\treturn 0;\n}",
        "code_after_change": "static int adjust_ptr_min_max_vals(struct bpf_verifier_env *env,\n\t\t\t\t   struct bpf_insn *insn,\n\t\t\t\t   const struct bpf_reg_state *ptr_reg,\n\t\t\t\t   const struct bpf_reg_state *off_reg)\n{\n\tstruct bpf_verifier_state *vstate = env->cur_state;\n\tstruct bpf_func_state *state = vstate->frame[vstate->curframe];\n\tstruct bpf_reg_state *regs = state->regs, *dst_reg;\n\tbool known = tnum_is_const(off_reg->var_off);\n\ts64 smin_val = off_reg->smin_value, smax_val = off_reg->smax_value,\n\t    smin_ptr = ptr_reg->smin_value, smax_ptr = ptr_reg->smax_value;\n\tu64 umin_val = off_reg->umin_value, umax_val = off_reg->umax_value,\n\t    umin_ptr = ptr_reg->umin_value, umax_ptr = ptr_reg->umax_value;\n\tstruct bpf_sanitize_info info = {};\n\tu8 opcode = BPF_OP(insn->code);\n\tu32 dst = insn->dst_reg;\n\tint ret;\n\n\tdst_reg = &regs[dst];\n\n\tif ((known && (smin_val != smax_val || umin_val != umax_val)) ||\n\t    smin_val > smax_val || umin_val > umax_val) {\n\t\t/* Taint dst register if offset had invalid bounds derived from\n\t\t * e.g. dead branches.\n\t\t */\n\t\t__mark_reg_unknown(env, dst_reg);\n\t\treturn 0;\n\t}\n\n\tif (BPF_CLASS(insn->code) != BPF_ALU64) {\n\t\t/* 32-bit ALU ops on pointers produce (meaningless) scalars */\n\t\tif (opcode == BPF_SUB && env->allow_ptr_leaks) {\n\t\t\t__mark_reg_unknown(env, dst_reg);\n\t\t\treturn 0;\n\t\t}\n\n\t\tverbose(env,\n\t\t\t\"R%d 32-bit pointer arithmetic prohibited\\n\",\n\t\t\tdst);\n\t\treturn -EACCES;\n\t}\n\n\tif (ptr_reg->type & PTR_MAYBE_NULL) {\n\t\tverbose(env, \"R%d pointer arithmetic on %s prohibited, null-check it first\\n\",\n\t\t\tdst, reg_type_str(env, ptr_reg->type));\n\t\treturn -EACCES;\n\t}\n\n\tswitch (base_type(ptr_reg->type)) {\n\tcase CONST_PTR_TO_MAP:\n\t\t/* smin_val represents the known value */\n\t\tif (known && smin_val == 0 && opcode == BPF_ADD)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase PTR_TO_PACKET_END:\n\tcase PTR_TO_SOCKET:\n\tcase PTR_TO_SOCK_COMMON:\n\tcase PTR_TO_TCP_SOCK:\n\tcase PTR_TO_XDP_SOCK:\n\t\tverbose(env, \"R%d pointer arithmetic on %s prohibited\\n\",\n\t\t\tdst, reg_type_str(env, ptr_reg->type));\n\t\treturn -EACCES;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/* In case of 'scalar += pointer', dst_reg inherits pointer type and id.\n\t * The id may be overwritten later if we create a new variable offset.\n\t */\n\tdst_reg->type = ptr_reg->type;\n\tdst_reg->id = ptr_reg->id;\n\n\tif (!check_reg_sane_offset(env, off_reg, ptr_reg->type) ||\n\t    !check_reg_sane_offset(env, ptr_reg, ptr_reg->type))\n\t\treturn -EINVAL;\n\n\t/* pointer types do not carry 32-bit bounds at the moment. */\n\t__mark_reg32_unbounded(dst_reg);\n\n\tif (sanitize_needed(opcode)) {\n\t\tret = sanitize_ptr_alu(env, insn, ptr_reg, off_reg, dst_reg,\n\t\t\t\t       &info, false);\n\t\tif (ret < 0)\n\t\t\treturn sanitize_err(env, insn, ret, off_reg, dst_reg);\n\t}\n\n\tswitch (opcode) {\n\tcase BPF_ADD:\n\t\t/* We can take a fixed offset as long as it doesn't overflow\n\t\t * the s32 'off' field\n\t\t */\n\t\tif (known && (ptr_reg->off + smin_val ==\n\t\t\t      (s64)(s32)(ptr_reg->off + smin_val))) {\n\t\t\t/* pointer += K.  Accumulate it into fixed offset */\n\t\t\tdst_reg->smin_value = smin_ptr;\n\t\t\tdst_reg->smax_value = smax_ptr;\n\t\t\tdst_reg->umin_value = umin_ptr;\n\t\t\tdst_reg->umax_value = umax_ptr;\n\t\t\tdst_reg->var_off = ptr_reg->var_off;\n\t\t\tdst_reg->off = ptr_reg->off + smin_val;\n\t\t\tdst_reg->raw = ptr_reg->raw;\n\t\t\tbreak;\n\t\t}\n\t\t/* A new variable offset is created.  Note that off_reg->off\n\t\t * == 0, since it's a scalar.\n\t\t * dst_reg gets the pointer type and since some positive\n\t\t * integer value was added to the pointer, give it a new 'id'\n\t\t * if it's a PTR_TO_PACKET.\n\t\t * this creates a new 'base' pointer, off_reg (variable) gets\n\t\t * added into the variable offset, and we copy the fixed offset\n\t\t * from ptr_reg.\n\t\t */\n\t\tif (signed_add_overflows(smin_ptr, smin_val) ||\n\t\t    signed_add_overflows(smax_ptr, smax_val)) {\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value = smin_ptr + smin_val;\n\t\t\tdst_reg->smax_value = smax_ptr + smax_val;\n\t\t}\n\t\tif (umin_ptr + umin_val < umin_ptr ||\n\t\t    umax_ptr + umax_val < umax_ptr) {\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\tdst_reg->umin_value = umin_ptr + umin_val;\n\t\t\tdst_reg->umax_value = umax_ptr + umax_val;\n\t\t}\n\t\tdst_reg->var_off = tnum_add(ptr_reg->var_off, off_reg->var_off);\n\t\tdst_reg->off = ptr_reg->off;\n\t\tdst_reg->raw = ptr_reg->raw;\n\t\tif (reg_is_pkt_pointer(ptr_reg)) {\n\t\t\tdst_reg->id = ++env->id_gen;\n\t\t\t/* something was added to pkt_ptr, set range to zero */\n\t\t\tmemset(&dst_reg->raw, 0, sizeof(dst_reg->raw));\n\t\t}\n\t\tbreak;\n\tcase BPF_SUB:\n\t\tif (dst_reg == off_reg) {\n\t\t\t/* scalar -= pointer.  Creates an unknown scalar */\n\t\t\tverbose(env, \"R%d tried to subtract pointer from scalar\\n\",\n\t\t\t\tdst);\n\t\t\treturn -EACCES;\n\t\t}\n\t\t/* We don't allow subtraction from FP, because (according to\n\t\t * test_verifier.c test \"invalid fp arithmetic\", JITs might not\n\t\t * be able to deal with it.\n\t\t */\n\t\tif (ptr_reg->type == PTR_TO_STACK) {\n\t\t\tverbose(env, \"R%d subtraction from stack pointer prohibited\\n\",\n\t\t\t\tdst);\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (known && (ptr_reg->off - smin_val ==\n\t\t\t      (s64)(s32)(ptr_reg->off - smin_val))) {\n\t\t\t/* pointer -= K.  Subtract it from fixed offset */\n\t\t\tdst_reg->smin_value = smin_ptr;\n\t\t\tdst_reg->smax_value = smax_ptr;\n\t\t\tdst_reg->umin_value = umin_ptr;\n\t\t\tdst_reg->umax_value = umax_ptr;\n\t\t\tdst_reg->var_off = ptr_reg->var_off;\n\t\t\tdst_reg->id = ptr_reg->id;\n\t\t\tdst_reg->off = ptr_reg->off - smin_val;\n\t\t\tdst_reg->raw = ptr_reg->raw;\n\t\t\tbreak;\n\t\t}\n\t\t/* A new variable offset is created.  If the subtrahend is known\n\t\t * nonnegative, then any reg->range we had before is still good.\n\t\t */\n\t\tif (signed_sub_overflows(smin_ptr, smax_val) ||\n\t\t    signed_sub_overflows(smax_ptr, smin_val)) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value = smin_ptr - smax_val;\n\t\t\tdst_reg->smax_value = smax_ptr - smin_val;\n\t\t}\n\t\tif (umin_ptr < umax_val) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\t/* Cannot overflow (as long as bounds are consistent) */\n\t\t\tdst_reg->umin_value = umin_ptr - umax_val;\n\t\t\tdst_reg->umax_value = umax_ptr - umin_val;\n\t\t}\n\t\tdst_reg->var_off = tnum_sub(ptr_reg->var_off, off_reg->var_off);\n\t\tdst_reg->off = ptr_reg->off;\n\t\tdst_reg->raw = ptr_reg->raw;\n\t\tif (reg_is_pkt_pointer(ptr_reg)) {\n\t\t\tdst_reg->id = ++env->id_gen;\n\t\t\t/* something was added to pkt_ptr, set range to zero */\n\t\t\tif (smin_val < 0)\n\t\t\t\tmemset(&dst_reg->raw, 0, sizeof(dst_reg->raw));\n\t\t}\n\t\tbreak;\n\tcase BPF_AND:\n\tcase BPF_OR:\n\tcase BPF_XOR:\n\t\t/* bitwise ops on pointers are troublesome, prohibit. */\n\t\tverbose(env, \"R%d bitwise operator %s on pointer prohibited\\n\",\n\t\t\tdst, bpf_alu_string[opcode >> 4]);\n\t\treturn -EACCES;\n\tdefault:\n\t\t/* other operators (e.g. MUL,LSH) produce non-pointer results */\n\t\tverbose(env, \"R%d pointer arithmetic with %s operator prohibited\\n\",\n\t\t\tdst, bpf_alu_string[opcode >> 4]);\n\t\treturn -EACCES;\n\t}\n\n\tif (!check_reg_sane_offset(env, dst_reg, ptr_reg->type))\n\t\treturn -EINVAL;\n\n\t__update_reg_bounds(dst_reg);\n\t__reg_deduce_bounds(dst_reg);\n\t__reg_bound_offset(dst_reg);\n\n\tif (sanitize_check_bounds(env, insn, dst_reg) < 0)\n\t\treturn -EACCES;\n\tif (sanitize_needed(opcode)) {\n\t\tret = sanitize_ptr_alu(env, insn, dst_reg, off_reg, dst_reg,\n\t\t\t\t       &info, true);\n\t\tif (ret < 0)\n\t\t\treturn sanitize_err(env, insn, ret, off_reg, dst_reg);\n\t}\n\n\treturn 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -40,11 +40,13 @@\n \t\treturn -EACCES;\n \t}\n \n-\tswitch (ptr_reg->type) {\n-\tcase PTR_TO_MAP_VALUE_OR_NULL:\n+\tif (ptr_reg->type & PTR_MAYBE_NULL) {\n \t\tverbose(env, \"R%d pointer arithmetic on %s prohibited, null-check it first\\n\",\n-\t\t\tdst, reg_type_str[ptr_reg->type]);\n-\t\treturn -EACCES;\n+\t\t\tdst, reg_type_str(env, ptr_reg->type));\n+\t\treturn -EACCES;\n+\t}\n+\n+\tswitch (base_type(ptr_reg->type)) {\n \tcase CONST_PTR_TO_MAP:\n \t\t/* smin_val represents the known value */\n \t\tif (known && smin_val == 0 && opcode == BPF_ADD)\n@@ -52,14 +54,11 @@\n \t\tfallthrough;\n \tcase PTR_TO_PACKET_END:\n \tcase PTR_TO_SOCKET:\n-\tcase PTR_TO_SOCKET_OR_NULL:\n \tcase PTR_TO_SOCK_COMMON:\n-\tcase PTR_TO_SOCK_COMMON_OR_NULL:\n \tcase PTR_TO_TCP_SOCK:\n-\tcase PTR_TO_TCP_SOCK_OR_NULL:\n \tcase PTR_TO_XDP_SOCK:\n \t\tverbose(env, \"R%d pointer arithmetic on %s prohibited\\n\",\n-\t\t\tdst, reg_type_str[ptr_reg->type]);\n+\t\t\tdst, reg_type_str(env, ptr_reg->type));\n \t\treturn -EACCES;\n \tdefault:\n \t\tbreak;",
        "function_modified_lines": {
            "added": [
                "\tif (ptr_reg->type & PTR_MAYBE_NULL) {",
                "\t\t\tdst, reg_type_str(env, ptr_reg->type));",
                "\t\treturn -EACCES;",
                "\t}",
                "",
                "\tswitch (base_type(ptr_reg->type)) {",
                "\t\t\tdst, reg_type_str(env, ptr_reg->type));"
            ],
            "deleted": [
                "\tswitch (ptr_reg->type) {",
                "\tcase PTR_TO_MAP_VALUE_OR_NULL:",
                "\t\t\tdst, reg_type_str[ptr_reg->type]);",
                "\t\treturn -EACCES;",
                "\tcase PTR_TO_SOCKET_OR_NULL:",
                "\tcase PTR_TO_SOCK_COMMON_OR_NULL:",
                "\tcase PTR_TO_TCP_SOCK_OR_NULL:",
                "\t\t\tdst, reg_type_str[ptr_reg->type]);"
            ]
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "kernel/bpf/verifier.c in the Linux kernel through 5.15.14 allows local users to gain privileges because of the availability of pointer arithmetic via certain *_OR_NULL pointer types.",
        "id": 3457
    },
    {
        "cve_id": "CVE-2022-23222",
        "code_before_change": "static bool reg_type_may_be_refcounted_or_null(enum bpf_reg_type type)\n{\n\treturn type == PTR_TO_SOCKET ||\n\t\ttype == PTR_TO_SOCKET_OR_NULL ||\n\t\ttype == PTR_TO_TCP_SOCK ||\n\t\ttype == PTR_TO_TCP_SOCK_OR_NULL ||\n\t\ttype == PTR_TO_MEM ||\n\t\ttype == PTR_TO_MEM_OR_NULL;\n}",
        "code_after_change": "static bool reg_type_may_be_refcounted_or_null(enum bpf_reg_type type)\n{\n\treturn base_type(type) == PTR_TO_SOCKET ||\n\t\tbase_type(type) == PTR_TO_TCP_SOCK ||\n\t\tbase_type(type) == PTR_TO_MEM;\n}",
        "patch": "--- code before\n+++ code after\n@@ -1,9 +1,6 @@\n static bool reg_type_may_be_refcounted_or_null(enum bpf_reg_type type)\n {\n-\treturn type == PTR_TO_SOCKET ||\n-\t\ttype == PTR_TO_SOCKET_OR_NULL ||\n-\t\ttype == PTR_TO_TCP_SOCK ||\n-\t\ttype == PTR_TO_TCP_SOCK_OR_NULL ||\n-\t\ttype == PTR_TO_MEM ||\n-\t\ttype == PTR_TO_MEM_OR_NULL;\n+\treturn base_type(type) == PTR_TO_SOCKET ||\n+\t\tbase_type(type) == PTR_TO_TCP_SOCK ||\n+\t\tbase_type(type) == PTR_TO_MEM;\n }",
        "function_modified_lines": {
            "added": [
                "\treturn base_type(type) == PTR_TO_SOCKET ||",
                "\t\tbase_type(type) == PTR_TO_TCP_SOCK ||",
                "\t\tbase_type(type) == PTR_TO_MEM;"
            ],
            "deleted": [
                "\treturn type == PTR_TO_SOCKET ||",
                "\t\ttype == PTR_TO_SOCKET_OR_NULL ||",
                "\t\ttype == PTR_TO_TCP_SOCK ||",
                "\t\ttype == PTR_TO_TCP_SOCK_OR_NULL ||",
                "\t\ttype == PTR_TO_MEM ||",
                "\t\ttype == PTR_TO_MEM_OR_NULL;"
            ]
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "kernel/bpf/verifier.c in the Linux kernel through 5.15.14 allows local users to gain privileges because of the availability of pointer arithmetic via certain *_OR_NULL pointer types.",
        "id": 3445
    },
    {
        "cve_id": "CVE-2022-23222",
        "code_before_change": "static int check_ctx_access(struct bpf_verifier_env *env, int insn_idx, int off, int size,\n\t\t\t    enum bpf_access_type t, enum bpf_reg_type *reg_type,\n\t\t\t    struct btf **btf, u32 *btf_id)\n{\n\tstruct bpf_insn_access_aux info = {\n\t\t.reg_type = *reg_type,\n\t\t.log = &env->log,\n\t};\n\n\tif (env->ops->is_valid_access &&\n\t    env->ops->is_valid_access(off, size, t, env->prog, &info)) {\n\t\t/* A non zero info.ctx_field_size indicates that this field is a\n\t\t * candidate for later verifier transformation to load the whole\n\t\t * field and then apply a mask when accessed with a narrower\n\t\t * access than actual ctx access size. A zero info.ctx_field_size\n\t\t * will only allow for whole field access and rejects any other\n\t\t * type of narrower access.\n\t\t */\n\t\t*reg_type = info.reg_type;\n\n\t\tif (*reg_type == PTR_TO_BTF_ID || *reg_type == PTR_TO_BTF_ID_OR_NULL) {\n\t\t\t*btf = info.btf;\n\t\t\t*btf_id = info.btf_id;\n\t\t} else {\n\t\t\tenv->insn_aux_data[insn_idx].ctx_field_size = info.ctx_field_size;\n\t\t}\n\t\t/* remember the offset of last byte accessed in ctx */\n\t\tif (env->prog->aux->max_ctx_offset < off + size)\n\t\t\tenv->prog->aux->max_ctx_offset = off + size;\n\t\treturn 0;\n\t}\n\n\tverbose(env, \"invalid bpf_context access off=%d size=%d\\n\", off, size);\n\treturn -EACCES;\n}",
        "code_after_change": "static int check_ctx_access(struct bpf_verifier_env *env, int insn_idx, int off, int size,\n\t\t\t    enum bpf_access_type t, enum bpf_reg_type *reg_type,\n\t\t\t    struct btf **btf, u32 *btf_id)\n{\n\tstruct bpf_insn_access_aux info = {\n\t\t.reg_type = *reg_type,\n\t\t.log = &env->log,\n\t};\n\n\tif (env->ops->is_valid_access &&\n\t    env->ops->is_valid_access(off, size, t, env->prog, &info)) {\n\t\t/* A non zero info.ctx_field_size indicates that this field is a\n\t\t * candidate for later verifier transformation to load the whole\n\t\t * field and then apply a mask when accessed with a narrower\n\t\t * access than actual ctx access size. A zero info.ctx_field_size\n\t\t * will only allow for whole field access and rejects any other\n\t\t * type of narrower access.\n\t\t */\n\t\t*reg_type = info.reg_type;\n\n\t\tif (base_type(*reg_type) == PTR_TO_BTF_ID) {\n\t\t\t*btf = info.btf;\n\t\t\t*btf_id = info.btf_id;\n\t\t} else {\n\t\t\tenv->insn_aux_data[insn_idx].ctx_field_size = info.ctx_field_size;\n\t\t}\n\t\t/* remember the offset of last byte accessed in ctx */\n\t\tif (env->prog->aux->max_ctx_offset < off + size)\n\t\t\tenv->prog->aux->max_ctx_offset = off + size;\n\t\treturn 0;\n\t}\n\n\tverbose(env, \"invalid bpf_context access off=%d size=%d\\n\", off, size);\n\treturn -EACCES;\n}",
        "patch": "--- code before\n+++ code after\n@@ -18,7 +18,7 @@\n \t\t */\n \t\t*reg_type = info.reg_type;\n \n-\t\tif (*reg_type == PTR_TO_BTF_ID || *reg_type == PTR_TO_BTF_ID_OR_NULL) {\n+\t\tif (base_type(*reg_type) == PTR_TO_BTF_ID) {\n \t\t\t*btf = info.btf;\n \t\t\t*btf_id = info.btf_id;\n \t\t} else {",
        "function_modified_lines": {
            "added": [
                "\t\tif (base_type(*reg_type) == PTR_TO_BTF_ID) {"
            ],
            "deleted": [
                "\t\tif (*reg_type == PTR_TO_BTF_ID || *reg_type == PTR_TO_BTF_ID_OR_NULL) {"
            ]
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "kernel/bpf/verifier.c in the Linux kernel through 5.15.14 allows local users to gain privileges because of the availability of pointer arithmetic via certain *_OR_NULL pointer types.",
        "id": 3449
    },
    {
        "cve_id": "CVE-2022-23222",
        "code_before_change": "static int check_cond_jmp_op(struct bpf_verifier_env *env,\n\t\t\t     struct bpf_insn *insn, int *insn_idx)\n{\n\tstruct bpf_verifier_state *this_branch = env->cur_state;\n\tstruct bpf_verifier_state *other_branch;\n\tstruct bpf_reg_state *regs = this_branch->frame[this_branch->curframe]->regs;\n\tstruct bpf_reg_state *dst_reg, *other_branch_regs, *src_reg = NULL;\n\tu8 opcode = BPF_OP(insn->code);\n\tbool is_jmp32;\n\tint pred = -1;\n\tint err;\n\n\t/* Only conditional jumps are expected to reach here. */\n\tif (opcode == BPF_JA || opcode > BPF_JSLE) {\n\t\tverbose(env, \"invalid BPF_JMP/JMP32 opcode %x\\n\", opcode);\n\t\treturn -EINVAL;\n\t}\n\n\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\tif (insn->imm != 0) {\n\t\t\tverbose(env, \"BPF_JMP/JMP32 uses reserved fields\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* check src1 operand */\n\t\terr = check_reg_arg(env, insn->src_reg, SRC_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (is_pointer_value(env, insn->src_reg)) {\n\t\t\tverbose(env, \"R%d pointer comparison prohibited\\n\",\n\t\t\t\tinsn->src_reg);\n\t\t\treturn -EACCES;\n\t\t}\n\t\tsrc_reg = &regs[insn->src_reg];\n\t} else {\n\t\tif (insn->src_reg != BPF_REG_0) {\n\t\t\tverbose(env, \"BPF_JMP/JMP32 uses reserved fields\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* check src2 operand */\n\terr = check_reg_arg(env, insn->dst_reg, SRC_OP);\n\tif (err)\n\t\treturn err;\n\n\tdst_reg = &regs[insn->dst_reg];\n\tis_jmp32 = BPF_CLASS(insn->code) == BPF_JMP32;\n\n\tif (BPF_SRC(insn->code) == BPF_K) {\n\t\tpred = is_branch_taken(dst_reg, insn->imm, opcode, is_jmp32);\n\t} else if (src_reg->type == SCALAR_VALUE &&\n\t\t   is_jmp32 && tnum_is_const(tnum_subreg(src_reg->var_off))) {\n\t\tpred = is_branch_taken(dst_reg,\n\t\t\t\t       tnum_subreg(src_reg->var_off).value,\n\t\t\t\t       opcode,\n\t\t\t\t       is_jmp32);\n\t} else if (src_reg->type == SCALAR_VALUE &&\n\t\t   !is_jmp32 && tnum_is_const(src_reg->var_off)) {\n\t\tpred = is_branch_taken(dst_reg,\n\t\t\t\t       src_reg->var_off.value,\n\t\t\t\t       opcode,\n\t\t\t\t       is_jmp32);\n\t} else if (reg_is_pkt_pointer_any(dst_reg) &&\n\t\t   reg_is_pkt_pointer_any(src_reg) &&\n\t\t   !is_jmp32) {\n\t\tpred = is_pkt_ptr_branch_taken(dst_reg, src_reg, opcode);\n\t}\n\n\tif (pred >= 0) {\n\t\t/* If we get here with a dst_reg pointer type it is because\n\t\t * above is_branch_taken() special cased the 0 comparison.\n\t\t */\n\t\tif (!__is_pointer_value(false, dst_reg))\n\t\t\terr = mark_chain_precision(env, insn->dst_reg);\n\t\tif (BPF_SRC(insn->code) == BPF_X && !err &&\n\t\t    !__is_pointer_value(false, src_reg))\n\t\t\terr = mark_chain_precision(env, insn->src_reg);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (pred == 1) {\n\t\t/* Only follow the goto, ignore fall-through. If needed, push\n\t\t * the fall-through branch for simulation under speculative\n\t\t * execution.\n\t\t */\n\t\tif (!env->bypass_spec_v1 &&\n\t\t    !sanitize_speculative_path(env, insn, *insn_idx + 1,\n\t\t\t\t\t       *insn_idx))\n\t\t\treturn -EFAULT;\n\t\t*insn_idx += insn->off;\n\t\treturn 0;\n\t} else if (pred == 0) {\n\t\t/* Only follow the fall-through branch, since that's where the\n\t\t * program will go. If needed, push the goto branch for\n\t\t * simulation under speculative execution.\n\t\t */\n\t\tif (!env->bypass_spec_v1 &&\n\t\t    !sanitize_speculative_path(env, insn,\n\t\t\t\t\t       *insn_idx + insn->off + 1,\n\t\t\t\t\t       *insn_idx))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\n\tother_branch = push_stack(env, *insn_idx + insn->off + 1, *insn_idx,\n\t\t\t\t  false);\n\tif (!other_branch)\n\t\treturn -EFAULT;\n\tother_branch_regs = other_branch->frame[other_branch->curframe]->regs;\n\n\t/* detect if we are comparing against a constant value so we can adjust\n\t * our min/max values for our dst register.\n\t * this is only legit if both are scalars (or pointers to the same\n\t * object, I suppose, but we don't support that right now), because\n\t * otherwise the different base pointers mean the offsets aren't\n\t * comparable.\n\t */\n\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\tstruct bpf_reg_state *src_reg = &regs[insn->src_reg];\n\n\t\tif (dst_reg->type == SCALAR_VALUE &&\n\t\t    src_reg->type == SCALAR_VALUE) {\n\t\t\tif (tnum_is_const(src_reg->var_off) ||\n\t\t\t    (is_jmp32 &&\n\t\t\t     tnum_is_const(tnum_subreg(src_reg->var_off))))\n\t\t\t\treg_set_min_max(&other_branch_regs[insn->dst_reg],\n\t\t\t\t\t\tdst_reg,\n\t\t\t\t\t\tsrc_reg->var_off.value,\n\t\t\t\t\t\ttnum_subreg(src_reg->var_off).value,\n\t\t\t\t\t\topcode, is_jmp32);\n\t\t\telse if (tnum_is_const(dst_reg->var_off) ||\n\t\t\t\t (is_jmp32 &&\n\t\t\t\t  tnum_is_const(tnum_subreg(dst_reg->var_off))))\n\t\t\t\treg_set_min_max_inv(&other_branch_regs[insn->src_reg],\n\t\t\t\t\t\t    src_reg,\n\t\t\t\t\t\t    dst_reg->var_off.value,\n\t\t\t\t\t\t    tnum_subreg(dst_reg->var_off).value,\n\t\t\t\t\t\t    opcode, is_jmp32);\n\t\t\telse if (!is_jmp32 &&\n\t\t\t\t (opcode == BPF_JEQ || opcode == BPF_JNE))\n\t\t\t\t/* Comparing for equality, we can combine knowledge */\n\t\t\t\treg_combine_min_max(&other_branch_regs[insn->src_reg],\n\t\t\t\t\t\t    &other_branch_regs[insn->dst_reg],\n\t\t\t\t\t\t    src_reg, dst_reg, opcode);\n\t\t\tif (src_reg->id &&\n\t\t\t    !WARN_ON_ONCE(src_reg->id != other_branch_regs[insn->src_reg].id)) {\n\t\t\t\tfind_equal_scalars(this_branch, src_reg);\n\t\t\t\tfind_equal_scalars(other_branch, &other_branch_regs[insn->src_reg]);\n\t\t\t}\n\n\t\t}\n\t} else if (dst_reg->type == SCALAR_VALUE) {\n\t\treg_set_min_max(&other_branch_regs[insn->dst_reg],\n\t\t\t\t\tdst_reg, insn->imm, (u32)insn->imm,\n\t\t\t\t\topcode, is_jmp32);\n\t}\n\n\tif (dst_reg->type == SCALAR_VALUE && dst_reg->id &&\n\t    !WARN_ON_ONCE(dst_reg->id != other_branch_regs[insn->dst_reg].id)) {\n\t\tfind_equal_scalars(this_branch, dst_reg);\n\t\tfind_equal_scalars(other_branch, &other_branch_regs[insn->dst_reg]);\n\t}\n\n\t/* detect if R == 0 where R is returned from bpf_map_lookup_elem().\n\t * NOTE: these optimizations below are related with pointer comparison\n\t *       which will never be JMP32.\n\t */\n\tif (!is_jmp32 && BPF_SRC(insn->code) == BPF_K &&\n\t    insn->imm == 0 && (opcode == BPF_JEQ || opcode == BPF_JNE) &&\n\t    reg_type_may_be_null(dst_reg->type)) {\n\t\t/* Mark all identical registers in each branch as either\n\t\t * safe or unknown depending R == 0 or R != 0 conditional.\n\t\t */\n\t\tmark_ptr_or_null_regs(this_branch, insn->dst_reg,\n\t\t\t\t      opcode == BPF_JNE);\n\t\tmark_ptr_or_null_regs(other_branch, insn->dst_reg,\n\t\t\t\t      opcode == BPF_JEQ);\n\t} else if (!try_match_pkt_pointers(insn, dst_reg, &regs[insn->src_reg],\n\t\t\t\t\t   this_branch, other_branch) &&\n\t\t   is_pointer_value(env, insn->dst_reg)) {\n\t\tverbose(env, \"R%d pointer comparison prohibited\\n\",\n\t\t\tinsn->dst_reg);\n\t\treturn -EACCES;\n\t}\n\tif (env->log.level & BPF_LOG_LEVEL)\n\t\tprint_insn_state(env, this_branch->frame[this_branch->curframe]);\n\treturn 0;\n}",
        "code_after_change": "static int check_cond_jmp_op(struct bpf_verifier_env *env,\n\t\t\t     struct bpf_insn *insn, int *insn_idx)\n{\n\tstruct bpf_verifier_state *this_branch = env->cur_state;\n\tstruct bpf_verifier_state *other_branch;\n\tstruct bpf_reg_state *regs = this_branch->frame[this_branch->curframe]->regs;\n\tstruct bpf_reg_state *dst_reg, *other_branch_regs, *src_reg = NULL;\n\tu8 opcode = BPF_OP(insn->code);\n\tbool is_jmp32;\n\tint pred = -1;\n\tint err;\n\n\t/* Only conditional jumps are expected to reach here. */\n\tif (opcode == BPF_JA || opcode > BPF_JSLE) {\n\t\tverbose(env, \"invalid BPF_JMP/JMP32 opcode %x\\n\", opcode);\n\t\treturn -EINVAL;\n\t}\n\n\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\tif (insn->imm != 0) {\n\t\t\tverbose(env, \"BPF_JMP/JMP32 uses reserved fields\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* check src1 operand */\n\t\terr = check_reg_arg(env, insn->src_reg, SRC_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (is_pointer_value(env, insn->src_reg)) {\n\t\t\tverbose(env, \"R%d pointer comparison prohibited\\n\",\n\t\t\t\tinsn->src_reg);\n\t\t\treturn -EACCES;\n\t\t}\n\t\tsrc_reg = &regs[insn->src_reg];\n\t} else {\n\t\tif (insn->src_reg != BPF_REG_0) {\n\t\t\tverbose(env, \"BPF_JMP/JMP32 uses reserved fields\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* check src2 operand */\n\terr = check_reg_arg(env, insn->dst_reg, SRC_OP);\n\tif (err)\n\t\treturn err;\n\n\tdst_reg = &regs[insn->dst_reg];\n\tis_jmp32 = BPF_CLASS(insn->code) == BPF_JMP32;\n\n\tif (BPF_SRC(insn->code) == BPF_K) {\n\t\tpred = is_branch_taken(dst_reg, insn->imm, opcode, is_jmp32);\n\t} else if (src_reg->type == SCALAR_VALUE &&\n\t\t   is_jmp32 && tnum_is_const(tnum_subreg(src_reg->var_off))) {\n\t\tpred = is_branch_taken(dst_reg,\n\t\t\t\t       tnum_subreg(src_reg->var_off).value,\n\t\t\t\t       opcode,\n\t\t\t\t       is_jmp32);\n\t} else if (src_reg->type == SCALAR_VALUE &&\n\t\t   !is_jmp32 && tnum_is_const(src_reg->var_off)) {\n\t\tpred = is_branch_taken(dst_reg,\n\t\t\t\t       src_reg->var_off.value,\n\t\t\t\t       opcode,\n\t\t\t\t       is_jmp32);\n\t} else if (reg_is_pkt_pointer_any(dst_reg) &&\n\t\t   reg_is_pkt_pointer_any(src_reg) &&\n\t\t   !is_jmp32) {\n\t\tpred = is_pkt_ptr_branch_taken(dst_reg, src_reg, opcode);\n\t}\n\n\tif (pred >= 0) {\n\t\t/* If we get here with a dst_reg pointer type it is because\n\t\t * above is_branch_taken() special cased the 0 comparison.\n\t\t */\n\t\tif (!__is_pointer_value(false, dst_reg))\n\t\t\terr = mark_chain_precision(env, insn->dst_reg);\n\t\tif (BPF_SRC(insn->code) == BPF_X && !err &&\n\t\t    !__is_pointer_value(false, src_reg))\n\t\t\terr = mark_chain_precision(env, insn->src_reg);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (pred == 1) {\n\t\t/* Only follow the goto, ignore fall-through. If needed, push\n\t\t * the fall-through branch for simulation under speculative\n\t\t * execution.\n\t\t */\n\t\tif (!env->bypass_spec_v1 &&\n\t\t    !sanitize_speculative_path(env, insn, *insn_idx + 1,\n\t\t\t\t\t       *insn_idx))\n\t\t\treturn -EFAULT;\n\t\t*insn_idx += insn->off;\n\t\treturn 0;\n\t} else if (pred == 0) {\n\t\t/* Only follow the fall-through branch, since that's where the\n\t\t * program will go. If needed, push the goto branch for\n\t\t * simulation under speculative execution.\n\t\t */\n\t\tif (!env->bypass_spec_v1 &&\n\t\t    !sanitize_speculative_path(env, insn,\n\t\t\t\t\t       *insn_idx + insn->off + 1,\n\t\t\t\t\t       *insn_idx))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\n\tother_branch = push_stack(env, *insn_idx + insn->off + 1, *insn_idx,\n\t\t\t\t  false);\n\tif (!other_branch)\n\t\treturn -EFAULT;\n\tother_branch_regs = other_branch->frame[other_branch->curframe]->regs;\n\n\t/* detect if we are comparing against a constant value so we can adjust\n\t * our min/max values for our dst register.\n\t * this is only legit if both are scalars (or pointers to the same\n\t * object, I suppose, but we don't support that right now), because\n\t * otherwise the different base pointers mean the offsets aren't\n\t * comparable.\n\t */\n\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\tstruct bpf_reg_state *src_reg = &regs[insn->src_reg];\n\n\t\tif (dst_reg->type == SCALAR_VALUE &&\n\t\t    src_reg->type == SCALAR_VALUE) {\n\t\t\tif (tnum_is_const(src_reg->var_off) ||\n\t\t\t    (is_jmp32 &&\n\t\t\t     tnum_is_const(tnum_subreg(src_reg->var_off))))\n\t\t\t\treg_set_min_max(&other_branch_regs[insn->dst_reg],\n\t\t\t\t\t\tdst_reg,\n\t\t\t\t\t\tsrc_reg->var_off.value,\n\t\t\t\t\t\ttnum_subreg(src_reg->var_off).value,\n\t\t\t\t\t\topcode, is_jmp32);\n\t\t\telse if (tnum_is_const(dst_reg->var_off) ||\n\t\t\t\t (is_jmp32 &&\n\t\t\t\t  tnum_is_const(tnum_subreg(dst_reg->var_off))))\n\t\t\t\treg_set_min_max_inv(&other_branch_regs[insn->src_reg],\n\t\t\t\t\t\t    src_reg,\n\t\t\t\t\t\t    dst_reg->var_off.value,\n\t\t\t\t\t\t    tnum_subreg(dst_reg->var_off).value,\n\t\t\t\t\t\t    opcode, is_jmp32);\n\t\t\telse if (!is_jmp32 &&\n\t\t\t\t (opcode == BPF_JEQ || opcode == BPF_JNE))\n\t\t\t\t/* Comparing for equality, we can combine knowledge */\n\t\t\t\treg_combine_min_max(&other_branch_regs[insn->src_reg],\n\t\t\t\t\t\t    &other_branch_regs[insn->dst_reg],\n\t\t\t\t\t\t    src_reg, dst_reg, opcode);\n\t\t\tif (src_reg->id &&\n\t\t\t    !WARN_ON_ONCE(src_reg->id != other_branch_regs[insn->src_reg].id)) {\n\t\t\t\tfind_equal_scalars(this_branch, src_reg);\n\t\t\t\tfind_equal_scalars(other_branch, &other_branch_regs[insn->src_reg]);\n\t\t\t}\n\n\t\t}\n\t} else if (dst_reg->type == SCALAR_VALUE) {\n\t\treg_set_min_max(&other_branch_regs[insn->dst_reg],\n\t\t\t\t\tdst_reg, insn->imm, (u32)insn->imm,\n\t\t\t\t\topcode, is_jmp32);\n\t}\n\n\tif (dst_reg->type == SCALAR_VALUE && dst_reg->id &&\n\t    !WARN_ON_ONCE(dst_reg->id != other_branch_regs[insn->dst_reg].id)) {\n\t\tfind_equal_scalars(this_branch, dst_reg);\n\t\tfind_equal_scalars(other_branch, &other_branch_regs[insn->dst_reg]);\n\t}\n\n\t/* detect if R == 0 where R is returned from bpf_map_lookup_elem().\n\t * NOTE: these optimizations below are related with pointer comparison\n\t *       which will never be JMP32.\n\t */\n\tif (!is_jmp32 && BPF_SRC(insn->code) == BPF_K &&\n\t    insn->imm == 0 && (opcode == BPF_JEQ || opcode == BPF_JNE) &&\n\t    type_may_be_null(dst_reg->type)) {\n\t\t/* Mark all identical registers in each branch as either\n\t\t * safe or unknown depending R == 0 or R != 0 conditional.\n\t\t */\n\t\tmark_ptr_or_null_regs(this_branch, insn->dst_reg,\n\t\t\t\t      opcode == BPF_JNE);\n\t\tmark_ptr_or_null_regs(other_branch, insn->dst_reg,\n\t\t\t\t      opcode == BPF_JEQ);\n\t} else if (!try_match_pkt_pointers(insn, dst_reg, &regs[insn->src_reg],\n\t\t\t\t\t   this_branch, other_branch) &&\n\t\t   is_pointer_value(env, insn->dst_reg)) {\n\t\tverbose(env, \"R%d pointer comparison prohibited\\n\",\n\t\t\tinsn->dst_reg);\n\t\treturn -EACCES;\n\t}\n\tif (env->log.level & BPF_LOG_LEVEL)\n\t\tprint_insn_state(env, this_branch->frame[this_branch->curframe]);\n\treturn 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -170,7 +170,7 @@\n \t */\n \tif (!is_jmp32 && BPF_SRC(insn->code) == BPF_K &&\n \t    insn->imm == 0 && (opcode == BPF_JEQ || opcode == BPF_JNE) &&\n-\t    reg_type_may_be_null(dst_reg->type)) {\n+\t    type_may_be_null(dst_reg->type)) {\n \t\t/* Mark all identical registers in each branch as either\n \t\t * safe or unknown depending R == 0 or R != 0 conditional.\n \t\t */",
        "function_modified_lines": {
            "added": [
                "\t    type_may_be_null(dst_reg->type)) {"
            ],
            "deleted": [
                "\t    reg_type_may_be_null(dst_reg->type)) {"
            ]
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "kernel/bpf/verifier.c in the Linux kernel through 5.15.14 allows local users to gain privileges because of the availability of pointer arithmetic via certain *_OR_NULL pointer types.",
        "id": 3441
    },
    {
        "cve_id": "CVE-2022-23222",
        "code_before_change": "static int check_reg_type(struct bpf_verifier_env *env, u32 regno,\n\t\t\t  enum bpf_arg_type arg_type,\n\t\t\t  const u32 *arg_btf_id)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env), *reg = &regs[regno];\n\tenum bpf_reg_type expected, type = reg->type;\n\tconst struct bpf_reg_types *compatible;\n\tint i, j;\n\n\tcompatible = compatible_reg_types[base_type(arg_type)];\n\tif (!compatible) {\n\t\tverbose(env, \"verifier internal error: unsupported arg type %d\\n\", arg_type);\n\t\treturn -EFAULT;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(compatible->types); i++) {\n\t\texpected = compatible->types[i];\n\t\tif (expected == NOT_INIT)\n\t\t\tbreak;\n\n\t\tif (type == expected)\n\t\t\tgoto found;\n\t}\n\n\tverbose(env, \"R%d type=%s expected=\", regno, reg_type_str[type]);\n\tfor (j = 0; j + 1 < i; j++)\n\t\tverbose(env, \"%s, \", reg_type_str[compatible->types[j]]);\n\tverbose(env, \"%s\\n\", reg_type_str[compatible->types[j]]);\n\treturn -EACCES;\n\nfound:\n\tif (type == PTR_TO_BTF_ID) {\n\t\tif (!arg_btf_id) {\n\t\t\tif (!compatible->btf_id) {\n\t\t\t\tverbose(env, \"verifier internal error: missing arg compatible BTF ID\\n\");\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t\targ_btf_id = compatible->btf_id;\n\t\t}\n\n\t\tif (!btf_struct_ids_match(&env->log, reg->btf, reg->btf_id, reg->off,\n\t\t\t\t\t  btf_vmlinux, *arg_btf_id)) {\n\t\t\tverbose(env, \"R%d is of type %s but %s is expected\\n\",\n\t\t\t\tregno, kernel_type_name(reg->btf, reg->btf_id),\n\t\t\t\tkernel_type_name(btf_vmlinux, *arg_btf_id));\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (!tnum_is_const(reg->var_off) || reg->var_off.value) {\n\t\t\tverbose(env, \"R%d is a pointer to in-kernel struct with non-zero offset\\n\",\n\t\t\t\tregno);\n\t\t\treturn -EACCES;\n\t\t}\n\t}\n\n\treturn 0;\n}",
        "code_after_change": "static int check_reg_type(struct bpf_verifier_env *env, u32 regno,\n\t\t\t  enum bpf_arg_type arg_type,\n\t\t\t  const u32 *arg_btf_id)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env), *reg = &regs[regno];\n\tenum bpf_reg_type expected, type = reg->type;\n\tconst struct bpf_reg_types *compatible;\n\tint i, j;\n\n\tcompatible = compatible_reg_types[base_type(arg_type)];\n\tif (!compatible) {\n\t\tverbose(env, \"verifier internal error: unsupported arg type %d\\n\", arg_type);\n\t\treturn -EFAULT;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(compatible->types); i++) {\n\t\texpected = compatible->types[i];\n\t\tif (expected == NOT_INIT)\n\t\t\tbreak;\n\n\t\tif (type == expected)\n\t\t\tgoto found;\n\t}\n\n\tverbose(env, \"R%d type=%s expected=\", regno, reg_type_str(env, type));\n\tfor (j = 0; j + 1 < i; j++)\n\t\tverbose(env, \"%s, \", reg_type_str(env, compatible->types[j]));\n\tverbose(env, \"%s\\n\", reg_type_str(env, compatible->types[j]));\n\treturn -EACCES;\n\nfound:\n\tif (type == PTR_TO_BTF_ID) {\n\t\tif (!arg_btf_id) {\n\t\t\tif (!compatible->btf_id) {\n\t\t\t\tverbose(env, \"verifier internal error: missing arg compatible BTF ID\\n\");\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t\targ_btf_id = compatible->btf_id;\n\t\t}\n\n\t\tif (!btf_struct_ids_match(&env->log, reg->btf, reg->btf_id, reg->off,\n\t\t\t\t\t  btf_vmlinux, *arg_btf_id)) {\n\t\t\tverbose(env, \"R%d is of type %s but %s is expected\\n\",\n\t\t\t\tregno, kernel_type_name(reg->btf, reg->btf_id),\n\t\t\t\tkernel_type_name(btf_vmlinux, *arg_btf_id));\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (!tnum_is_const(reg->var_off) || reg->var_off.value) {\n\t\t\tverbose(env, \"R%d is a pointer to in-kernel struct with non-zero offset\\n\",\n\t\t\t\tregno);\n\t\t\treturn -EACCES;\n\t\t}\n\t}\n\n\treturn 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -22,10 +22,10 @@\n \t\t\tgoto found;\n \t}\n \n-\tverbose(env, \"R%d type=%s expected=\", regno, reg_type_str[type]);\n+\tverbose(env, \"R%d type=%s expected=\", regno, reg_type_str(env, type));\n \tfor (j = 0; j + 1 < i; j++)\n-\t\tverbose(env, \"%s, \", reg_type_str[compatible->types[j]]);\n-\tverbose(env, \"%s\\n\", reg_type_str[compatible->types[j]]);\n+\t\tverbose(env, \"%s, \", reg_type_str(env, compatible->types[j]));\n+\tverbose(env, \"%s\\n\", reg_type_str(env, compatible->types[j]));\n \treturn -EACCES;\n \n found:",
        "function_modified_lines": {
            "added": [
                "\tverbose(env, \"R%d type=%s expected=\", regno, reg_type_str(env, type));",
                "\t\tverbose(env, \"%s, \", reg_type_str(env, compatible->types[j]));",
                "\tverbose(env, \"%s\\n\", reg_type_str(env, compatible->types[j]));"
            ],
            "deleted": [
                "\tverbose(env, \"R%d type=%s expected=\", regno, reg_type_str[type]);",
                "\t\tverbose(env, \"%s, \", reg_type_str[compatible->types[j]]);",
                "\tverbose(env, \"%s\\n\", reg_type_str[compatible->types[j]]);"
            ]
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "kernel/bpf/verifier.c in the Linux kernel through 5.15.14 allows local users to gain privileges because of the availability of pointer arithmetic via certain *_OR_NULL pointer types.",
        "id": 3450
    },
    {
        "cve_id": "CVE-2022-23222",
        "code_before_change": "static int check_helper_call(struct bpf_verifier_env *env, struct bpf_insn *insn,\n\t\t\t     int *insn_idx_p)\n{\n\tconst struct bpf_func_proto *fn = NULL;\n\tenum bpf_return_type ret_type;\n\tstruct bpf_reg_state *regs;\n\tstruct bpf_call_arg_meta meta;\n\tint insn_idx = *insn_idx_p;\n\tbool changes_data;\n\tint i, err, func_id;\n\n\t/* find function prototype */\n\tfunc_id = insn->imm;\n\tif (func_id < 0 || func_id >= __BPF_FUNC_MAX_ID) {\n\t\tverbose(env, \"invalid func %s#%d\\n\", func_id_name(func_id),\n\t\t\tfunc_id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (env->ops->get_func_proto)\n\t\tfn = env->ops->get_func_proto(func_id, env->prog);\n\tif (!fn) {\n\t\tverbose(env, \"unknown func %s#%d\\n\", func_id_name(func_id),\n\t\t\tfunc_id);\n\t\treturn -EINVAL;\n\t}\n\n\t/* eBPF programs must be GPL compatible to use GPL-ed functions */\n\tif (!env->prog->gpl_compatible && fn->gpl_only) {\n\t\tverbose(env, \"cannot call GPL-restricted function from non-GPL compatible program\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (fn->allowed && !fn->allowed(env->prog)) {\n\t\tverbose(env, \"helper call is not allowed in probe\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* With LD_ABS/IND some JITs save/restore skb from r1. */\n\tchanges_data = bpf_helper_changes_pkt_data(fn->func);\n\tif (changes_data && fn->arg1_type != ARG_PTR_TO_CTX) {\n\t\tverbose(env, \"kernel subsystem misconfigured func %s#%d: r1 != ctx\\n\",\n\t\t\tfunc_id_name(func_id), func_id);\n\t\treturn -EINVAL;\n\t}\n\n\tmemset(&meta, 0, sizeof(meta));\n\tmeta.pkt_access = fn->pkt_access;\n\n\terr = check_func_proto(fn, func_id);\n\tif (err) {\n\t\tverbose(env, \"kernel subsystem misconfigured func %s#%d\\n\",\n\t\t\tfunc_id_name(func_id), func_id);\n\t\treturn err;\n\t}\n\n\tmeta.func_id = func_id;\n\t/* check args */\n\tfor (i = 0; i < MAX_BPF_FUNC_REG_ARGS; i++) {\n\t\terr = check_func_arg(env, i, &meta, fn);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = record_func_map(env, &meta, func_id, insn_idx);\n\tif (err)\n\t\treturn err;\n\n\terr = record_func_key(env, &meta, func_id, insn_idx);\n\tif (err)\n\t\treturn err;\n\n\t/* Mark slots with STACK_MISC in case of raw mode, stack offset\n\t * is inferred from register state.\n\t */\n\tfor (i = 0; i < meta.access_size; i++) {\n\t\terr = check_mem_access(env, insn_idx, meta.regno, i, BPF_B,\n\t\t\t\t       BPF_WRITE, -1, false);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (is_release_function(func_id)) {\n\t\terr = release_reference(env, meta.ref_obj_id);\n\t\tif (err) {\n\t\t\tverbose(env, \"func %s#%d reference has not been acquired before\\n\",\n\t\t\t\tfunc_id_name(func_id), func_id);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tregs = cur_regs(env);\n\n\tswitch (func_id) {\n\tcase BPF_FUNC_tail_call:\n\t\terr = check_reference_leak(env);\n\t\tif (err) {\n\t\t\tverbose(env, \"tail_call would lead to reference leak\\n\");\n\t\t\treturn err;\n\t\t}\n\t\tbreak;\n\tcase BPF_FUNC_get_local_storage:\n\t\t/* check that flags argument in get_local_storage(map, flags) is 0,\n\t\t * this is required because get_local_storage() can't return an error.\n\t\t */\n\t\tif (!register_is_null(&regs[BPF_REG_2])) {\n\t\t\tverbose(env, \"get_local_storage() doesn't support non-zero flags\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase BPF_FUNC_for_each_map_elem:\n\t\terr = __check_func_call(env, insn, insn_idx_p, meta.subprogno,\n\t\t\t\t\tset_map_elem_callback_state);\n\t\tbreak;\n\tcase BPF_FUNC_timer_set_callback:\n\t\terr = __check_func_call(env, insn, insn_idx_p, meta.subprogno,\n\t\t\t\t\tset_timer_callback_state);\n\t\tbreak;\n\tcase BPF_FUNC_find_vma:\n\t\terr = __check_func_call(env, insn, insn_idx_p, meta.subprogno,\n\t\t\t\t\tset_find_vma_callback_state);\n\t\tbreak;\n\tcase BPF_FUNC_snprintf:\n\t\terr = check_bpf_snprintf_call(env, regs);\n\t\tbreak;\n\tcase BPF_FUNC_loop:\n\t\terr = __check_func_call(env, insn, insn_idx_p, meta.subprogno,\n\t\t\t\t\tset_loop_callback_state);\n\t\tbreak;\n\t}\n\n\tif (err)\n\t\treturn err;\n\n\t/* reset caller saved regs */\n\tfor (i = 0; i < CALLER_SAVED_REGS; i++) {\n\t\tmark_reg_not_init(env, regs, caller_saved[i]);\n\t\tcheck_reg_arg(env, caller_saved[i], DST_OP_NO_MARK);\n\t}\n\n\t/* helper call returns 64-bit value. */\n\tregs[BPF_REG_0].subreg_def = DEF_NOT_SUBREG;\n\n\t/* update return register (already marked as written above) */\n\tret_type = fn->ret_type;\n\tif (ret_type == RET_INTEGER) {\n\t\t/* sets type to SCALAR_VALUE */\n\t\tmark_reg_unknown(env, regs, BPF_REG_0);\n\t} else if (ret_type == RET_VOID) {\n\t\tregs[BPF_REG_0].type = NOT_INIT;\n\t} else if (base_type(ret_type) == RET_PTR_TO_MAP_VALUE) {\n\t\t/* There is no offset yet applied, variable or fixed */\n\t\tmark_reg_known_zero(env, regs, BPF_REG_0);\n\t\t/* remember map_ptr, so that check_map_access()\n\t\t * can check 'value_size' boundary of memory access\n\t\t * to map element returned from bpf_map_lookup_elem()\n\t\t */\n\t\tif (meta.map_ptr == NULL) {\n\t\t\tverbose(env,\n\t\t\t\t\"kernel subsystem misconfigured verifier\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tregs[BPF_REG_0].map_ptr = meta.map_ptr;\n\t\tregs[BPF_REG_0].map_uid = meta.map_uid;\n\t\tif (type_may_be_null(ret_type)) {\n\t\t\tregs[BPF_REG_0].type = PTR_TO_MAP_VALUE_OR_NULL;\n\t\t} else {\n\t\t\tregs[BPF_REG_0].type = PTR_TO_MAP_VALUE;\n\t\t\tif (map_value_has_spin_lock(meta.map_ptr))\n\t\t\t\tregs[BPF_REG_0].id = ++env->id_gen;\n\t\t}\n\t} else if (base_type(ret_type) == RET_PTR_TO_SOCKET) {\n\t\tmark_reg_known_zero(env, regs, BPF_REG_0);\n\t\tregs[BPF_REG_0].type = PTR_TO_SOCKET_OR_NULL;\n\t} else if (base_type(ret_type) == RET_PTR_TO_SOCK_COMMON) {\n\t\tmark_reg_known_zero(env, regs, BPF_REG_0);\n\t\tregs[BPF_REG_0].type = PTR_TO_SOCK_COMMON_OR_NULL;\n\t} else if (base_type(ret_type) == RET_PTR_TO_TCP_SOCK) {\n\t\tmark_reg_known_zero(env, regs, BPF_REG_0);\n\t\tregs[BPF_REG_0].type = PTR_TO_TCP_SOCK_OR_NULL;\n\t} else if (base_type(ret_type) == RET_PTR_TO_ALLOC_MEM) {\n\t\tmark_reg_known_zero(env, regs, BPF_REG_0);\n\t\tregs[BPF_REG_0].type = PTR_TO_MEM_OR_NULL;\n\t\tregs[BPF_REG_0].mem_size = meta.mem_size;\n\t} else if (base_type(ret_type) == RET_PTR_TO_MEM_OR_BTF_ID) {\n\t\tconst struct btf_type *t;\n\n\t\tmark_reg_known_zero(env, regs, BPF_REG_0);\n\t\tt = btf_type_skip_modifiers(meta.ret_btf, meta.ret_btf_id, NULL);\n\t\tif (!btf_type_is_struct(t)) {\n\t\t\tu32 tsize;\n\t\t\tconst struct btf_type *ret;\n\t\t\tconst char *tname;\n\n\t\t\t/* resolve the type size of ksym. */\n\t\t\tret = btf_resolve_size(meta.ret_btf, t, &tsize);\n\t\t\tif (IS_ERR(ret)) {\n\t\t\t\ttname = btf_name_by_offset(meta.ret_btf, t->name_off);\n\t\t\t\tverbose(env, \"unable to resolve the size of type '%s': %ld\\n\",\n\t\t\t\t\ttname, PTR_ERR(ret));\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tregs[BPF_REG_0].type =\n\t\t\t\t(ret_type & PTR_MAYBE_NULL) ?\n\t\t\t\tPTR_TO_MEM_OR_NULL : PTR_TO_MEM;\n\t\t\tregs[BPF_REG_0].mem_size = tsize;\n\t\t} else {\n\t\t\tregs[BPF_REG_0].type =\n\t\t\t\t(ret_type & PTR_MAYBE_NULL) ?\n\t\t\t\tPTR_TO_BTF_ID_OR_NULL : PTR_TO_BTF_ID;\n\t\t\tregs[BPF_REG_0].btf = meta.ret_btf;\n\t\t\tregs[BPF_REG_0].btf_id = meta.ret_btf_id;\n\t\t}\n\t} else if (base_type(ret_type) == RET_PTR_TO_BTF_ID) {\n\t\tint ret_btf_id;\n\n\t\tmark_reg_known_zero(env, regs, BPF_REG_0);\n\t\tregs[BPF_REG_0].type = (ret_type & PTR_MAYBE_NULL) ?\n\t\t\t\t\t\t     PTR_TO_BTF_ID_OR_NULL :\n\t\t\t\t\t\t     PTR_TO_BTF_ID;\n\t\tret_btf_id = *fn->ret_btf_id;\n\t\tif (ret_btf_id == 0) {\n\t\t\tverbose(env, \"invalid return type %u of func %s#%d\\n\",\n\t\t\t\tbase_type(ret_type), func_id_name(func_id),\n\t\t\t\tfunc_id);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t/* current BPF helper definitions are only coming from\n\t\t * built-in code with type IDs from  vmlinux BTF\n\t\t */\n\t\tregs[BPF_REG_0].btf = btf_vmlinux;\n\t\tregs[BPF_REG_0].btf_id = ret_btf_id;\n\t} else {\n\t\tverbose(env, \"unknown return type %u of func %s#%d\\n\",\n\t\t\tbase_type(ret_type), func_id_name(func_id), func_id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (reg_type_may_be_null(regs[BPF_REG_0].type))\n\t\tregs[BPF_REG_0].id = ++env->id_gen;\n\n\tif (is_ptr_cast_function(func_id)) {\n\t\t/* For release_reference() */\n\t\tregs[BPF_REG_0].ref_obj_id = meta.ref_obj_id;\n\t} else if (is_acquire_function(func_id, meta.map_ptr)) {\n\t\tint id = acquire_reference_state(env, insn_idx);\n\n\t\tif (id < 0)\n\t\t\treturn id;\n\t\t/* For mark_ptr_or_null_reg() */\n\t\tregs[BPF_REG_0].id = id;\n\t\t/* For release_reference() */\n\t\tregs[BPF_REG_0].ref_obj_id = id;\n\t}\n\n\tdo_refine_retval_range(regs, fn->ret_type, func_id, &meta);\n\n\terr = check_map_func_compatibility(env, meta.map_ptr, func_id);\n\tif (err)\n\t\treturn err;\n\n\tif ((func_id == BPF_FUNC_get_stack ||\n\t     func_id == BPF_FUNC_get_task_stack) &&\n\t    !env->prog->has_callchain_buf) {\n\t\tconst char *err_str;\n\n#ifdef CONFIG_PERF_EVENTS\n\t\terr = get_callchain_buffers(sysctl_perf_event_max_stack);\n\t\terr_str = \"cannot get callchain buffer for func %s#%d\\n\";\n#else\n\t\terr = -ENOTSUPP;\n\t\terr_str = \"func %s#%d not supported without CONFIG_PERF_EVENTS\\n\";\n#endif\n\t\tif (err) {\n\t\t\tverbose(env, err_str, func_id_name(func_id), func_id);\n\t\t\treturn err;\n\t\t}\n\n\t\tenv->prog->has_callchain_buf = true;\n\t}\n\n\tif (func_id == BPF_FUNC_get_stackid || func_id == BPF_FUNC_get_stack)\n\t\tenv->prog->call_get_stack = true;\n\n\tif (func_id == BPF_FUNC_get_func_ip) {\n\t\tif (check_get_func_ip(env))\n\t\t\treturn -ENOTSUPP;\n\t\tenv->prog->call_get_func_ip = true;\n\t}\n\n\tif (changes_data)\n\t\tclear_all_pkt_pointers(env);\n\treturn 0;\n}",
        "code_after_change": "static int check_helper_call(struct bpf_verifier_env *env, struct bpf_insn *insn,\n\t\t\t     int *insn_idx_p)\n{\n\tconst struct bpf_func_proto *fn = NULL;\n\tenum bpf_return_type ret_type;\n\tenum bpf_type_flag ret_flag;\n\tstruct bpf_reg_state *regs;\n\tstruct bpf_call_arg_meta meta;\n\tint insn_idx = *insn_idx_p;\n\tbool changes_data;\n\tint i, err, func_id;\n\n\t/* find function prototype */\n\tfunc_id = insn->imm;\n\tif (func_id < 0 || func_id >= __BPF_FUNC_MAX_ID) {\n\t\tverbose(env, \"invalid func %s#%d\\n\", func_id_name(func_id),\n\t\t\tfunc_id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (env->ops->get_func_proto)\n\t\tfn = env->ops->get_func_proto(func_id, env->prog);\n\tif (!fn) {\n\t\tverbose(env, \"unknown func %s#%d\\n\", func_id_name(func_id),\n\t\t\tfunc_id);\n\t\treturn -EINVAL;\n\t}\n\n\t/* eBPF programs must be GPL compatible to use GPL-ed functions */\n\tif (!env->prog->gpl_compatible && fn->gpl_only) {\n\t\tverbose(env, \"cannot call GPL-restricted function from non-GPL compatible program\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (fn->allowed && !fn->allowed(env->prog)) {\n\t\tverbose(env, \"helper call is not allowed in probe\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* With LD_ABS/IND some JITs save/restore skb from r1. */\n\tchanges_data = bpf_helper_changes_pkt_data(fn->func);\n\tif (changes_data && fn->arg1_type != ARG_PTR_TO_CTX) {\n\t\tverbose(env, \"kernel subsystem misconfigured func %s#%d: r1 != ctx\\n\",\n\t\t\tfunc_id_name(func_id), func_id);\n\t\treturn -EINVAL;\n\t}\n\n\tmemset(&meta, 0, sizeof(meta));\n\tmeta.pkt_access = fn->pkt_access;\n\n\terr = check_func_proto(fn, func_id);\n\tif (err) {\n\t\tverbose(env, \"kernel subsystem misconfigured func %s#%d\\n\",\n\t\t\tfunc_id_name(func_id), func_id);\n\t\treturn err;\n\t}\n\n\tmeta.func_id = func_id;\n\t/* check args */\n\tfor (i = 0; i < MAX_BPF_FUNC_REG_ARGS; i++) {\n\t\terr = check_func_arg(env, i, &meta, fn);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = record_func_map(env, &meta, func_id, insn_idx);\n\tif (err)\n\t\treturn err;\n\n\terr = record_func_key(env, &meta, func_id, insn_idx);\n\tif (err)\n\t\treturn err;\n\n\t/* Mark slots with STACK_MISC in case of raw mode, stack offset\n\t * is inferred from register state.\n\t */\n\tfor (i = 0; i < meta.access_size; i++) {\n\t\terr = check_mem_access(env, insn_idx, meta.regno, i, BPF_B,\n\t\t\t\t       BPF_WRITE, -1, false);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (is_release_function(func_id)) {\n\t\terr = release_reference(env, meta.ref_obj_id);\n\t\tif (err) {\n\t\t\tverbose(env, \"func %s#%d reference has not been acquired before\\n\",\n\t\t\t\tfunc_id_name(func_id), func_id);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tregs = cur_regs(env);\n\n\tswitch (func_id) {\n\tcase BPF_FUNC_tail_call:\n\t\terr = check_reference_leak(env);\n\t\tif (err) {\n\t\t\tverbose(env, \"tail_call would lead to reference leak\\n\");\n\t\t\treturn err;\n\t\t}\n\t\tbreak;\n\tcase BPF_FUNC_get_local_storage:\n\t\t/* check that flags argument in get_local_storage(map, flags) is 0,\n\t\t * this is required because get_local_storage() can't return an error.\n\t\t */\n\t\tif (!register_is_null(&regs[BPF_REG_2])) {\n\t\t\tverbose(env, \"get_local_storage() doesn't support non-zero flags\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase BPF_FUNC_for_each_map_elem:\n\t\terr = __check_func_call(env, insn, insn_idx_p, meta.subprogno,\n\t\t\t\t\tset_map_elem_callback_state);\n\t\tbreak;\n\tcase BPF_FUNC_timer_set_callback:\n\t\terr = __check_func_call(env, insn, insn_idx_p, meta.subprogno,\n\t\t\t\t\tset_timer_callback_state);\n\t\tbreak;\n\tcase BPF_FUNC_find_vma:\n\t\terr = __check_func_call(env, insn, insn_idx_p, meta.subprogno,\n\t\t\t\t\tset_find_vma_callback_state);\n\t\tbreak;\n\tcase BPF_FUNC_snprintf:\n\t\terr = check_bpf_snprintf_call(env, regs);\n\t\tbreak;\n\tcase BPF_FUNC_loop:\n\t\terr = __check_func_call(env, insn, insn_idx_p, meta.subprogno,\n\t\t\t\t\tset_loop_callback_state);\n\t\tbreak;\n\t}\n\n\tif (err)\n\t\treturn err;\n\n\t/* reset caller saved regs */\n\tfor (i = 0; i < CALLER_SAVED_REGS; i++) {\n\t\tmark_reg_not_init(env, regs, caller_saved[i]);\n\t\tcheck_reg_arg(env, caller_saved[i], DST_OP_NO_MARK);\n\t}\n\n\t/* helper call returns 64-bit value. */\n\tregs[BPF_REG_0].subreg_def = DEF_NOT_SUBREG;\n\n\t/* update return register (already marked as written above) */\n\tret_type = fn->ret_type;\n\tret_flag = type_flag(fn->ret_type);\n\tif (ret_type == RET_INTEGER) {\n\t\t/* sets type to SCALAR_VALUE */\n\t\tmark_reg_unknown(env, regs, BPF_REG_0);\n\t} else if (ret_type == RET_VOID) {\n\t\tregs[BPF_REG_0].type = NOT_INIT;\n\t} else if (base_type(ret_type) == RET_PTR_TO_MAP_VALUE) {\n\t\t/* There is no offset yet applied, variable or fixed */\n\t\tmark_reg_known_zero(env, regs, BPF_REG_0);\n\t\t/* remember map_ptr, so that check_map_access()\n\t\t * can check 'value_size' boundary of memory access\n\t\t * to map element returned from bpf_map_lookup_elem()\n\t\t */\n\t\tif (meta.map_ptr == NULL) {\n\t\t\tverbose(env,\n\t\t\t\t\"kernel subsystem misconfigured verifier\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tregs[BPF_REG_0].map_ptr = meta.map_ptr;\n\t\tregs[BPF_REG_0].map_uid = meta.map_uid;\n\t\tregs[BPF_REG_0].type = PTR_TO_MAP_VALUE | ret_flag;\n\t\tif (!type_may_be_null(ret_type) &&\n\t\t    map_value_has_spin_lock(meta.map_ptr)) {\n\t\t\tregs[BPF_REG_0].id = ++env->id_gen;\n\t\t}\n\t} else if (base_type(ret_type) == RET_PTR_TO_SOCKET) {\n\t\tmark_reg_known_zero(env, regs, BPF_REG_0);\n\t\tregs[BPF_REG_0].type = PTR_TO_SOCKET | ret_flag;\n\t} else if (base_type(ret_type) == RET_PTR_TO_SOCK_COMMON) {\n\t\tmark_reg_known_zero(env, regs, BPF_REG_0);\n\t\tregs[BPF_REG_0].type = PTR_TO_SOCK_COMMON | ret_flag;\n\t} else if (base_type(ret_type) == RET_PTR_TO_TCP_SOCK) {\n\t\tmark_reg_known_zero(env, regs, BPF_REG_0);\n\t\tregs[BPF_REG_0].type = PTR_TO_TCP_SOCK | ret_flag;\n\t} else if (base_type(ret_type) == RET_PTR_TO_ALLOC_MEM) {\n\t\tmark_reg_known_zero(env, regs, BPF_REG_0);\n\t\tregs[BPF_REG_0].type = PTR_TO_MEM | ret_flag;\n\t\tregs[BPF_REG_0].mem_size = meta.mem_size;\n\t} else if (base_type(ret_type) == RET_PTR_TO_MEM_OR_BTF_ID) {\n\t\tconst struct btf_type *t;\n\n\t\tmark_reg_known_zero(env, regs, BPF_REG_0);\n\t\tt = btf_type_skip_modifiers(meta.ret_btf, meta.ret_btf_id, NULL);\n\t\tif (!btf_type_is_struct(t)) {\n\t\t\tu32 tsize;\n\t\t\tconst struct btf_type *ret;\n\t\t\tconst char *tname;\n\n\t\t\t/* resolve the type size of ksym. */\n\t\t\tret = btf_resolve_size(meta.ret_btf, t, &tsize);\n\t\t\tif (IS_ERR(ret)) {\n\t\t\t\ttname = btf_name_by_offset(meta.ret_btf, t->name_off);\n\t\t\t\tverbose(env, \"unable to resolve the size of type '%s': %ld\\n\",\n\t\t\t\t\ttname, PTR_ERR(ret));\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tregs[BPF_REG_0].type = PTR_TO_MEM | ret_flag;\n\t\t\tregs[BPF_REG_0].mem_size = tsize;\n\t\t} else {\n\t\t\tregs[BPF_REG_0].type = PTR_TO_BTF_ID | ret_flag;\n\t\t\tregs[BPF_REG_0].btf = meta.ret_btf;\n\t\t\tregs[BPF_REG_0].btf_id = meta.ret_btf_id;\n\t\t}\n\t} else if (base_type(ret_type) == RET_PTR_TO_BTF_ID) {\n\t\tint ret_btf_id;\n\n\t\tmark_reg_known_zero(env, regs, BPF_REG_0);\n\t\tregs[BPF_REG_0].type = PTR_TO_BTF_ID | ret_flag;\n\t\tret_btf_id = *fn->ret_btf_id;\n\t\tif (ret_btf_id == 0) {\n\t\t\tverbose(env, \"invalid return type %u of func %s#%d\\n\",\n\t\t\t\tbase_type(ret_type), func_id_name(func_id),\n\t\t\t\tfunc_id);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t/* current BPF helper definitions are only coming from\n\t\t * built-in code with type IDs from  vmlinux BTF\n\t\t */\n\t\tregs[BPF_REG_0].btf = btf_vmlinux;\n\t\tregs[BPF_REG_0].btf_id = ret_btf_id;\n\t} else {\n\t\tverbose(env, \"unknown return type %u of func %s#%d\\n\",\n\t\t\tbase_type(ret_type), func_id_name(func_id), func_id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (type_may_be_null(regs[BPF_REG_0].type))\n\t\tregs[BPF_REG_0].id = ++env->id_gen;\n\n\tif (is_ptr_cast_function(func_id)) {\n\t\t/* For release_reference() */\n\t\tregs[BPF_REG_0].ref_obj_id = meta.ref_obj_id;\n\t} else if (is_acquire_function(func_id, meta.map_ptr)) {\n\t\tint id = acquire_reference_state(env, insn_idx);\n\n\t\tif (id < 0)\n\t\t\treturn id;\n\t\t/* For mark_ptr_or_null_reg() */\n\t\tregs[BPF_REG_0].id = id;\n\t\t/* For release_reference() */\n\t\tregs[BPF_REG_0].ref_obj_id = id;\n\t}\n\n\tdo_refine_retval_range(regs, fn->ret_type, func_id, &meta);\n\n\terr = check_map_func_compatibility(env, meta.map_ptr, func_id);\n\tif (err)\n\t\treturn err;\n\n\tif ((func_id == BPF_FUNC_get_stack ||\n\t     func_id == BPF_FUNC_get_task_stack) &&\n\t    !env->prog->has_callchain_buf) {\n\t\tconst char *err_str;\n\n#ifdef CONFIG_PERF_EVENTS\n\t\terr = get_callchain_buffers(sysctl_perf_event_max_stack);\n\t\terr_str = \"cannot get callchain buffer for func %s#%d\\n\";\n#else\n\t\terr = -ENOTSUPP;\n\t\terr_str = \"func %s#%d not supported without CONFIG_PERF_EVENTS\\n\";\n#endif\n\t\tif (err) {\n\t\t\tverbose(env, err_str, func_id_name(func_id), func_id);\n\t\t\treturn err;\n\t\t}\n\n\t\tenv->prog->has_callchain_buf = true;\n\t}\n\n\tif (func_id == BPF_FUNC_get_stackid || func_id == BPF_FUNC_get_stack)\n\t\tenv->prog->call_get_stack = true;\n\n\tif (func_id == BPF_FUNC_get_func_ip) {\n\t\tif (check_get_func_ip(env))\n\t\t\treturn -ENOTSUPP;\n\t\tenv->prog->call_get_func_ip = true;\n\t}\n\n\tif (changes_data)\n\t\tclear_all_pkt_pointers(env);\n\treturn 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -3,6 +3,7 @@\n {\n \tconst struct bpf_func_proto *fn = NULL;\n \tenum bpf_return_type ret_type;\n+\tenum bpf_type_flag ret_flag;\n \tstruct bpf_reg_state *regs;\n \tstruct bpf_call_arg_meta meta;\n \tint insn_idx = *insn_idx_p;\n@@ -143,6 +144,7 @@\n \n \t/* update return register (already marked as written above) */\n \tret_type = fn->ret_type;\n+\tret_flag = type_flag(fn->ret_type);\n \tif (ret_type == RET_INTEGER) {\n \t\t/* sets type to SCALAR_VALUE */\n \t\tmark_reg_unknown(env, regs, BPF_REG_0);\n@@ -162,25 +164,23 @@\n \t\t}\n \t\tregs[BPF_REG_0].map_ptr = meta.map_ptr;\n \t\tregs[BPF_REG_0].map_uid = meta.map_uid;\n-\t\tif (type_may_be_null(ret_type)) {\n-\t\t\tregs[BPF_REG_0].type = PTR_TO_MAP_VALUE_OR_NULL;\n-\t\t} else {\n-\t\t\tregs[BPF_REG_0].type = PTR_TO_MAP_VALUE;\n-\t\t\tif (map_value_has_spin_lock(meta.map_ptr))\n-\t\t\t\tregs[BPF_REG_0].id = ++env->id_gen;\n+\t\tregs[BPF_REG_0].type = PTR_TO_MAP_VALUE | ret_flag;\n+\t\tif (!type_may_be_null(ret_type) &&\n+\t\t    map_value_has_spin_lock(meta.map_ptr)) {\n+\t\t\tregs[BPF_REG_0].id = ++env->id_gen;\n \t\t}\n \t} else if (base_type(ret_type) == RET_PTR_TO_SOCKET) {\n \t\tmark_reg_known_zero(env, regs, BPF_REG_0);\n-\t\tregs[BPF_REG_0].type = PTR_TO_SOCKET_OR_NULL;\n+\t\tregs[BPF_REG_0].type = PTR_TO_SOCKET | ret_flag;\n \t} else if (base_type(ret_type) == RET_PTR_TO_SOCK_COMMON) {\n \t\tmark_reg_known_zero(env, regs, BPF_REG_0);\n-\t\tregs[BPF_REG_0].type = PTR_TO_SOCK_COMMON_OR_NULL;\n+\t\tregs[BPF_REG_0].type = PTR_TO_SOCK_COMMON | ret_flag;\n \t} else if (base_type(ret_type) == RET_PTR_TO_TCP_SOCK) {\n \t\tmark_reg_known_zero(env, regs, BPF_REG_0);\n-\t\tregs[BPF_REG_0].type = PTR_TO_TCP_SOCK_OR_NULL;\n+\t\tregs[BPF_REG_0].type = PTR_TO_TCP_SOCK | ret_flag;\n \t} else if (base_type(ret_type) == RET_PTR_TO_ALLOC_MEM) {\n \t\tmark_reg_known_zero(env, regs, BPF_REG_0);\n-\t\tregs[BPF_REG_0].type = PTR_TO_MEM_OR_NULL;\n+\t\tregs[BPF_REG_0].type = PTR_TO_MEM | ret_flag;\n \t\tregs[BPF_REG_0].mem_size = meta.mem_size;\n \t} else if (base_type(ret_type) == RET_PTR_TO_MEM_OR_BTF_ID) {\n \t\tconst struct btf_type *t;\n@@ -200,14 +200,10 @@\n \t\t\t\t\ttname, PTR_ERR(ret));\n \t\t\t\treturn -EINVAL;\n \t\t\t}\n-\t\t\tregs[BPF_REG_0].type =\n-\t\t\t\t(ret_type & PTR_MAYBE_NULL) ?\n-\t\t\t\tPTR_TO_MEM_OR_NULL : PTR_TO_MEM;\n+\t\t\tregs[BPF_REG_0].type = PTR_TO_MEM | ret_flag;\n \t\t\tregs[BPF_REG_0].mem_size = tsize;\n \t\t} else {\n-\t\t\tregs[BPF_REG_0].type =\n-\t\t\t\t(ret_type & PTR_MAYBE_NULL) ?\n-\t\t\t\tPTR_TO_BTF_ID_OR_NULL : PTR_TO_BTF_ID;\n+\t\t\tregs[BPF_REG_0].type = PTR_TO_BTF_ID | ret_flag;\n \t\t\tregs[BPF_REG_0].btf = meta.ret_btf;\n \t\t\tregs[BPF_REG_0].btf_id = meta.ret_btf_id;\n \t\t}\n@@ -215,9 +211,7 @@\n \t\tint ret_btf_id;\n \n \t\tmark_reg_known_zero(env, regs, BPF_REG_0);\n-\t\tregs[BPF_REG_0].type = (ret_type & PTR_MAYBE_NULL) ?\n-\t\t\t\t\t\t     PTR_TO_BTF_ID_OR_NULL :\n-\t\t\t\t\t\t     PTR_TO_BTF_ID;\n+\t\tregs[BPF_REG_0].type = PTR_TO_BTF_ID | ret_flag;\n \t\tret_btf_id = *fn->ret_btf_id;\n \t\tif (ret_btf_id == 0) {\n \t\t\tverbose(env, \"invalid return type %u of func %s#%d\\n\",\n@@ -236,7 +230,7 @@\n \t\treturn -EINVAL;\n \t}\n \n-\tif (reg_type_may_be_null(regs[BPF_REG_0].type))\n+\tif (type_may_be_null(regs[BPF_REG_0].type))\n \t\tregs[BPF_REG_0].id = ++env->id_gen;\n \n \tif (is_ptr_cast_function(func_id)) {",
        "function_modified_lines": {
            "added": [
                "\tenum bpf_type_flag ret_flag;",
                "\tret_flag = type_flag(fn->ret_type);",
                "\t\tregs[BPF_REG_0].type = PTR_TO_MAP_VALUE | ret_flag;",
                "\t\tif (!type_may_be_null(ret_type) &&",
                "\t\t    map_value_has_spin_lock(meta.map_ptr)) {",
                "\t\t\tregs[BPF_REG_0].id = ++env->id_gen;",
                "\t\tregs[BPF_REG_0].type = PTR_TO_SOCKET | ret_flag;",
                "\t\tregs[BPF_REG_0].type = PTR_TO_SOCK_COMMON | ret_flag;",
                "\t\tregs[BPF_REG_0].type = PTR_TO_TCP_SOCK | ret_flag;",
                "\t\tregs[BPF_REG_0].type = PTR_TO_MEM | ret_flag;",
                "\t\t\tregs[BPF_REG_0].type = PTR_TO_MEM | ret_flag;",
                "\t\t\tregs[BPF_REG_0].type = PTR_TO_BTF_ID | ret_flag;",
                "\t\tregs[BPF_REG_0].type = PTR_TO_BTF_ID | ret_flag;",
                "\tif (type_may_be_null(regs[BPF_REG_0].type))"
            ],
            "deleted": [
                "\t\tif (type_may_be_null(ret_type)) {",
                "\t\t\tregs[BPF_REG_0].type = PTR_TO_MAP_VALUE_OR_NULL;",
                "\t\t} else {",
                "\t\t\tregs[BPF_REG_0].type = PTR_TO_MAP_VALUE;",
                "\t\t\tif (map_value_has_spin_lock(meta.map_ptr))",
                "\t\t\t\tregs[BPF_REG_0].id = ++env->id_gen;",
                "\t\tregs[BPF_REG_0].type = PTR_TO_SOCKET_OR_NULL;",
                "\t\tregs[BPF_REG_0].type = PTR_TO_SOCK_COMMON_OR_NULL;",
                "\t\tregs[BPF_REG_0].type = PTR_TO_TCP_SOCK_OR_NULL;",
                "\t\tregs[BPF_REG_0].type = PTR_TO_MEM_OR_NULL;",
                "\t\t\tregs[BPF_REG_0].type =",
                "\t\t\t\t(ret_type & PTR_MAYBE_NULL) ?",
                "\t\t\t\tPTR_TO_MEM_OR_NULL : PTR_TO_MEM;",
                "\t\t\tregs[BPF_REG_0].type =",
                "\t\t\t\t(ret_type & PTR_MAYBE_NULL) ?",
                "\t\t\t\tPTR_TO_BTF_ID_OR_NULL : PTR_TO_BTF_ID;",
                "\t\tregs[BPF_REG_0].type = (ret_type & PTR_MAYBE_NULL) ?",
                "\t\t\t\t\t\t     PTR_TO_BTF_ID_OR_NULL :",
                "\t\t\t\t\t\t     PTR_TO_BTF_ID;",
                "\tif (reg_type_may_be_null(regs[BPF_REG_0].type))"
            ]
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "kernel/bpf/verifier.c in the Linux kernel through 5.15.14 allows local users to gain privileges because of the availability of pointer arithmetic via certain *_OR_NULL pointer types.",
        "id": 3443
    },
    {
        "cve_id": "CVE-2022-23222",
        "code_before_change": "static int check_helper_mem_access(struct bpf_verifier_env *env, int regno,\n\t\t\t\t   int access_size, bool zero_size_allowed,\n\t\t\t\t   struct bpf_call_arg_meta *meta)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env), *reg = &regs[regno];\n\n\tswitch (reg->type) {\n\tcase PTR_TO_PACKET:\n\tcase PTR_TO_PACKET_META:\n\t\treturn check_packet_access(env, regno, reg->off, access_size,\n\t\t\t\t\t   zero_size_allowed);\n\tcase PTR_TO_MAP_KEY:\n\t\treturn check_mem_region_access(env, regno, reg->off, access_size,\n\t\t\t\t\t       reg->map_ptr->key_size, false);\n\tcase PTR_TO_MAP_VALUE:\n\t\tif (check_map_access_type(env, regno, reg->off, access_size,\n\t\t\t\t\t  meta && meta->raw_mode ? BPF_WRITE :\n\t\t\t\t\t  BPF_READ))\n\t\t\treturn -EACCES;\n\t\treturn check_map_access(env, regno, reg->off, access_size,\n\t\t\t\t\tzero_size_allowed);\n\tcase PTR_TO_MEM:\n\t\treturn check_mem_region_access(env, regno, reg->off,\n\t\t\t\t\t       access_size, reg->mem_size,\n\t\t\t\t\t       zero_size_allowed);\n\tcase PTR_TO_RDONLY_BUF:\n\t\tif (meta && meta->raw_mode)\n\t\t\treturn -EACCES;\n\t\treturn check_buffer_access(env, reg, regno, reg->off,\n\t\t\t\t\t   access_size, zero_size_allowed,\n\t\t\t\t\t   \"rdonly\",\n\t\t\t\t\t   &env->prog->aux->max_rdonly_access);\n\tcase PTR_TO_RDWR_BUF:\n\t\treturn check_buffer_access(env, reg, regno, reg->off,\n\t\t\t\t\t   access_size, zero_size_allowed,\n\t\t\t\t\t   \"rdwr\",\n\t\t\t\t\t   &env->prog->aux->max_rdwr_access);\n\tcase PTR_TO_STACK:\n\t\treturn check_stack_range_initialized(\n\t\t\t\tenv,\n\t\t\t\tregno, reg->off, access_size,\n\t\t\t\tzero_size_allowed, ACCESS_HELPER, meta);\n\tdefault: /* scalar_value or invalid ptr */\n\t\t/* Allow zero-byte read from NULL, regardless of pointer type */\n\t\tif (zero_size_allowed && access_size == 0 &&\n\t\t    register_is_null(reg))\n\t\t\treturn 0;\n\n\t\tverbose(env, \"R%d type=%s expected=%s\\n\", regno,\n\t\t\treg_type_str[reg->type],\n\t\t\treg_type_str[PTR_TO_STACK]);\n\t\treturn -EACCES;\n\t}\n}",
        "code_after_change": "static int check_helper_mem_access(struct bpf_verifier_env *env, int regno,\n\t\t\t\t   int access_size, bool zero_size_allowed,\n\t\t\t\t   struct bpf_call_arg_meta *meta)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env), *reg = &regs[regno];\n\n\tswitch (reg->type) {\n\tcase PTR_TO_PACKET:\n\tcase PTR_TO_PACKET_META:\n\t\treturn check_packet_access(env, regno, reg->off, access_size,\n\t\t\t\t\t   zero_size_allowed);\n\tcase PTR_TO_MAP_KEY:\n\t\treturn check_mem_region_access(env, regno, reg->off, access_size,\n\t\t\t\t\t       reg->map_ptr->key_size, false);\n\tcase PTR_TO_MAP_VALUE:\n\t\tif (check_map_access_type(env, regno, reg->off, access_size,\n\t\t\t\t\t  meta && meta->raw_mode ? BPF_WRITE :\n\t\t\t\t\t  BPF_READ))\n\t\t\treturn -EACCES;\n\t\treturn check_map_access(env, regno, reg->off, access_size,\n\t\t\t\t\tzero_size_allowed);\n\tcase PTR_TO_MEM:\n\t\treturn check_mem_region_access(env, regno, reg->off,\n\t\t\t\t\t       access_size, reg->mem_size,\n\t\t\t\t\t       zero_size_allowed);\n\tcase PTR_TO_RDONLY_BUF:\n\t\tif (meta && meta->raw_mode)\n\t\t\treturn -EACCES;\n\t\treturn check_buffer_access(env, reg, regno, reg->off,\n\t\t\t\t\t   access_size, zero_size_allowed,\n\t\t\t\t\t   \"rdonly\",\n\t\t\t\t\t   &env->prog->aux->max_rdonly_access);\n\tcase PTR_TO_RDWR_BUF:\n\t\treturn check_buffer_access(env, reg, regno, reg->off,\n\t\t\t\t\t   access_size, zero_size_allowed,\n\t\t\t\t\t   \"rdwr\",\n\t\t\t\t\t   &env->prog->aux->max_rdwr_access);\n\tcase PTR_TO_STACK:\n\t\treturn check_stack_range_initialized(\n\t\t\t\tenv,\n\t\t\t\tregno, reg->off, access_size,\n\t\t\t\tzero_size_allowed, ACCESS_HELPER, meta);\n\tdefault: /* scalar_value or invalid ptr */\n\t\t/* Allow zero-byte read from NULL, regardless of pointer type */\n\t\tif (zero_size_allowed && access_size == 0 &&\n\t\t    register_is_null(reg))\n\t\t\treturn 0;\n\n\t\tverbose(env, \"R%d type=%s \", regno,\n\t\t\treg_type_str(env, reg->type));\n\t\tverbose(env, \"expected=%s\\n\", reg_type_str(env, PTR_TO_STACK));\n\t\treturn -EACCES;\n\t}\n}",
        "patch": "--- code before\n+++ code after\n@@ -46,9 +46,9 @@\n \t\t    register_is_null(reg))\n \t\t\treturn 0;\n \n-\t\tverbose(env, \"R%d type=%s expected=%s\\n\", regno,\n-\t\t\treg_type_str[reg->type],\n-\t\t\treg_type_str[PTR_TO_STACK]);\n+\t\tverbose(env, \"R%d type=%s \", regno,\n+\t\t\treg_type_str(env, reg->type));\n+\t\tverbose(env, \"expected=%s\\n\", reg_type_str(env, PTR_TO_STACK));\n \t\treturn -EACCES;\n \t}\n }",
        "function_modified_lines": {
            "added": [
                "\t\tverbose(env, \"R%d type=%s \", regno,",
                "\t\t\treg_type_str(env, reg->type));",
                "\t\tverbose(env, \"expected=%s\\n\", reg_type_str(env, PTR_TO_STACK));"
            ],
            "deleted": [
                "\t\tverbose(env, \"R%d type=%s expected=%s\\n\", regno,",
                "\t\t\treg_type_str[reg->type],",
                "\t\t\treg_type_str[PTR_TO_STACK]);"
            ]
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "kernel/bpf/verifier.c in the Linux kernel through 5.15.14 allows local users to gain privileges because of the availability of pointer arithmetic via certain *_OR_NULL pointer types.",
        "id": 3456
    },
    {
        "cve_id": "CVE-2020-27830",
        "code_before_change": "static int spk_ttyio_ldisc_open(struct tty_struct *tty)\n{\n\tstruct spk_ldisc_data *ldisc_data;\n\n\tif (!tty->ops->write)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&speakup_tty_mutex);\n\tif (speakup_tty) {\n\t\tmutex_unlock(&speakup_tty_mutex);\n\t\treturn -EBUSY;\n\t}\n\tspeakup_tty = tty;\n\n\tldisc_data = kmalloc(sizeof(*ldisc_data), GFP_KERNEL);\n\tif (!ldisc_data) {\n\t\tspeakup_tty = NULL;\n\t\tmutex_unlock(&speakup_tty_mutex);\n\t\treturn -ENOMEM;\n\t}\n\n\tinit_completion(&ldisc_data->completion);\n\tldisc_data->buf_free = true;\n\tspeakup_tty->disc_data = ldisc_data;\n\tmutex_unlock(&speakup_tty_mutex);\n\n\treturn 0;\n}",
        "code_after_change": "static int spk_ttyio_ldisc_open(struct tty_struct *tty)\n{\n\tstruct spk_ldisc_data *ldisc_data;\n\n\tif (tty != speakup_tty)\n\t\t/* Somebody tried to use this line discipline outside speakup */\n\t\treturn -ENODEV;\n\n\tif (!tty->ops->write)\n\t\treturn -EOPNOTSUPP;\n\n\tldisc_data = kmalloc(sizeof(*ldisc_data), GFP_KERNEL);\n\tif (!ldisc_data)\n\t\treturn -ENOMEM;\n\n\tinit_completion(&ldisc_data->completion);\n\tldisc_data->buf_free = true;\n\ttty->disc_data = ldisc_data;\n\n\treturn 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -2,27 +2,20 @@\n {\n \tstruct spk_ldisc_data *ldisc_data;\n \n+\tif (tty != speakup_tty)\n+\t\t/* Somebody tried to use this line discipline outside speakup */\n+\t\treturn -ENODEV;\n+\n \tif (!tty->ops->write)\n \t\treturn -EOPNOTSUPP;\n \n-\tmutex_lock(&speakup_tty_mutex);\n-\tif (speakup_tty) {\n-\t\tmutex_unlock(&speakup_tty_mutex);\n-\t\treturn -EBUSY;\n-\t}\n-\tspeakup_tty = tty;\n-\n \tldisc_data = kmalloc(sizeof(*ldisc_data), GFP_KERNEL);\n-\tif (!ldisc_data) {\n-\t\tspeakup_tty = NULL;\n-\t\tmutex_unlock(&speakup_tty_mutex);\n+\tif (!ldisc_data)\n \t\treturn -ENOMEM;\n-\t}\n \n \tinit_completion(&ldisc_data->completion);\n \tldisc_data->buf_free = true;\n-\tspeakup_tty->disc_data = ldisc_data;\n-\tmutex_unlock(&speakup_tty_mutex);\n+\ttty->disc_data = ldisc_data;\n \n \treturn 0;\n }",
        "function_modified_lines": {
            "added": [
                "\tif (tty != speakup_tty)",
                "\t\t/* Somebody tried to use this line discipline outside speakup */",
                "\t\treturn -ENODEV;",
                "",
                "\tif (!ldisc_data)",
                "\ttty->disc_data = ldisc_data;"
            ],
            "deleted": [
                "\tmutex_lock(&speakup_tty_mutex);",
                "\tif (speakup_tty) {",
                "\t\tmutex_unlock(&speakup_tty_mutex);",
                "\t\treturn -EBUSY;",
                "\t}",
                "\tspeakup_tty = tty;",
                "",
                "\tif (!ldisc_data) {",
                "\t\tspeakup_tty = NULL;",
                "\t\tmutex_unlock(&speakup_tty_mutex);",
                "\t}",
                "\tspeakup_tty->disc_data = ldisc_data;",
                "\tmutex_unlock(&speakup_tty_mutex);"
            ]
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "A vulnerability was found in Linux Kernel where in the spk_ttyio_receive_buf2() function, it would dereference spk_ttyio_synth without checking whether it is NULL or not, and may lead to a NULL-ptr deref crash.",
        "id": 2639
    },
    {
        "cve_id": "CVE-2020-10711",
        "code_before_change": "static int cipso_v4_parsetag_rbm(const struct cipso_v4_doi *doi_def,\n\t\t\t\t const unsigned char *tag,\n\t\t\t\t struct netlbl_lsm_secattr *secattr)\n{\n\tint ret_val;\n\tu8 tag_len = tag[1];\n\tu32 level;\n\n\tret_val = cipso_v4_map_lvl_ntoh(doi_def, tag[3], &level);\n\tif (ret_val != 0)\n\t\treturn ret_val;\n\tsecattr->attr.mls.lvl = level;\n\tsecattr->flags |= NETLBL_SECATTR_MLS_LVL;\n\n\tif (tag_len > 4) {\n\t\tret_val = cipso_v4_map_cat_rbm_ntoh(doi_def,\n\t\t\t\t\t\t    &tag[4],\n\t\t\t\t\t\t    tag_len - 4,\n\t\t\t\t\t\t    secattr);\n\t\tif (ret_val != 0) {\n\t\t\tnetlbl_catmap_free(secattr->attr.mls.cat);\n\t\t\treturn ret_val;\n\t\t}\n\n\t\tsecattr->flags |= NETLBL_SECATTR_MLS_CAT;\n\t}\n\n\treturn 0;\n}",
        "code_after_change": "static int cipso_v4_parsetag_rbm(const struct cipso_v4_doi *doi_def,\n\t\t\t\t const unsigned char *tag,\n\t\t\t\t struct netlbl_lsm_secattr *secattr)\n{\n\tint ret_val;\n\tu8 tag_len = tag[1];\n\tu32 level;\n\n\tret_val = cipso_v4_map_lvl_ntoh(doi_def, tag[3], &level);\n\tif (ret_val != 0)\n\t\treturn ret_val;\n\tsecattr->attr.mls.lvl = level;\n\tsecattr->flags |= NETLBL_SECATTR_MLS_LVL;\n\n\tif (tag_len > 4) {\n\t\tret_val = cipso_v4_map_cat_rbm_ntoh(doi_def,\n\t\t\t\t\t\t    &tag[4],\n\t\t\t\t\t\t    tag_len - 4,\n\t\t\t\t\t\t    secattr);\n\t\tif (ret_val != 0) {\n\t\t\tnetlbl_catmap_free(secattr->attr.mls.cat);\n\t\t\treturn ret_val;\n\t\t}\n\n\t\tif (secattr->attr.mls.cat)\n\t\t\tsecattr->flags |= NETLBL_SECATTR_MLS_CAT;\n\t}\n\n\treturn 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -22,7 +22,8 @@\n \t\t\treturn ret_val;\n \t\t}\n \n-\t\tsecattr->flags |= NETLBL_SECATTR_MLS_CAT;\n+\t\tif (secattr->attr.mls.cat)\n+\t\t\tsecattr->flags |= NETLBL_SECATTR_MLS_CAT;\n \t}\n \n \treturn 0;",
        "function_modified_lines": {
            "added": [
                "\t\tif (secattr->attr.mls.cat)",
                "\t\t\tsecattr->flags |= NETLBL_SECATTR_MLS_CAT;"
            ],
            "deleted": [
                "\t\tsecattr->flags |= NETLBL_SECATTR_MLS_CAT;"
            ]
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "A NULL pointer dereference flaw was found in the Linux kernel's SELinux subsystem in versions before 5.7. This flaw occurs while importing the Commercial IP Security Option (CIPSO) protocol's category bitmap into the SELinux extensible bitmap via the' ebitmap_netlbl_import' routine. While processing the CIPSO restricted bitmap tag in the 'cipso_v4_parsetag_rbm' routine, it sets the security attribute to indicate that the category bitmap is present, even if it has not been allocated. This issue leads to a NULL pointer dereference issue while importing the same category bitmap into SELinux. This flaw allows a remote network user to crash the system kernel, resulting in a denial of service.",
        "id": 2404
    },
    {
        "cve_id": "CVE-2019-18885",
        "code_before_change": "static int verify_one_dev_extent(struct btrfs_fs_info *fs_info,\n\t\t\t\t u64 chunk_offset, u64 devid,\n\t\t\t\t u64 physical_offset, u64 physical_len)\n{\n\tstruct extent_map_tree *em_tree = &fs_info->mapping_tree.map_tree;\n\tstruct extent_map *em;\n\tstruct map_lookup *map;\n\tstruct btrfs_device *dev;\n\tu64 stripe_len;\n\tbool found = false;\n\tint ret = 0;\n\tint i;\n\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree, chunk_offset, 1);\n\tread_unlock(&em_tree->lock);\n\n\tif (!em) {\n\t\tbtrfs_err(fs_info,\n\"dev extent physical offset %llu on devid %llu doesn't have corresponding chunk\",\n\t\t\t  physical_offset, devid);\n\t\tret = -EUCLEAN;\n\t\tgoto out;\n\t}\n\n\tmap = em->map_lookup;\n\tstripe_len = calc_stripe_length(map->type, em->len, map->num_stripes);\n\tif (physical_len != stripe_len) {\n\t\tbtrfs_err(fs_info,\n\"dev extent physical offset %llu on devid %llu length doesn't match chunk %llu, have %llu expect %llu\",\n\t\t\t  physical_offset, devid, em->start, physical_len,\n\t\t\t  stripe_len);\n\t\tret = -EUCLEAN;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < map->num_stripes; i++) {\n\t\tif (map->stripes[i].dev->devid == devid &&\n\t\t    map->stripes[i].physical == physical_offset) {\n\t\t\tfound = true;\n\t\t\tif (map->verified_stripes >= map->num_stripes) {\n\t\t\t\tbtrfs_err(fs_info,\n\t\t\t\t\"too many dev extents for chunk %llu found\",\n\t\t\t\t\t  em->start);\n\t\t\t\tret = -EUCLEAN;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmap->verified_stripes++;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found) {\n\t\tbtrfs_err(fs_info,\n\t\"dev extent physical offset %llu devid %llu has no corresponding chunk\",\n\t\t\tphysical_offset, devid);\n\t\tret = -EUCLEAN;\n\t}\n\n\t/* Make sure no dev extent is beyond device bondary */\n\tdev = btrfs_find_device(fs_info->fs_devices, devid, NULL, NULL);\n\tif (!dev) {\n\t\tbtrfs_err(fs_info, \"failed to find devid %llu\", devid);\n\t\tret = -EUCLEAN;\n\t\tgoto out;\n\t}\n\n\t/* It's possible this device is a dummy for seed device */\n\tif (dev->disk_total_bytes == 0) {\n\t\tdev = find_device(fs_info->fs_devices->seed, devid, NULL);\n\t\tif (!dev) {\n\t\t\tbtrfs_err(fs_info, \"failed to find seed devid %llu\",\n\t\t\t\t  devid);\n\t\t\tret = -EUCLEAN;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (physical_offset + physical_len > dev->disk_total_bytes) {\n\t\tbtrfs_err(fs_info,\n\"dev extent devid %llu physical offset %llu len %llu is beyond device boundary %llu\",\n\t\t\t  devid, physical_offset, physical_len,\n\t\t\t  dev->disk_total_bytes);\n\t\tret = -EUCLEAN;\n\t\tgoto out;\n\t}\nout:\n\tfree_extent_map(em);\n\treturn ret;\n}",
        "code_after_change": "static int verify_one_dev_extent(struct btrfs_fs_info *fs_info,\n\t\t\t\t u64 chunk_offset, u64 devid,\n\t\t\t\t u64 physical_offset, u64 physical_len)\n{\n\tstruct extent_map_tree *em_tree = &fs_info->mapping_tree.map_tree;\n\tstruct extent_map *em;\n\tstruct map_lookup *map;\n\tstruct btrfs_device *dev;\n\tu64 stripe_len;\n\tbool found = false;\n\tint ret = 0;\n\tint i;\n\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree, chunk_offset, 1);\n\tread_unlock(&em_tree->lock);\n\n\tif (!em) {\n\t\tbtrfs_err(fs_info,\n\"dev extent physical offset %llu on devid %llu doesn't have corresponding chunk\",\n\t\t\t  physical_offset, devid);\n\t\tret = -EUCLEAN;\n\t\tgoto out;\n\t}\n\n\tmap = em->map_lookup;\n\tstripe_len = calc_stripe_length(map->type, em->len, map->num_stripes);\n\tif (physical_len != stripe_len) {\n\t\tbtrfs_err(fs_info,\n\"dev extent physical offset %llu on devid %llu length doesn't match chunk %llu, have %llu expect %llu\",\n\t\t\t  physical_offset, devid, em->start, physical_len,\n\t\t\t  stripe_len);\n\t\tret = -EUCLEAN;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < map->num_stripes; i++) {\n\t\tif (map->stripes[i].dev->devid == devid &&\n\t\t    map->stripes[i].physical == physical_offset) {\n\t\t\tfound = true;\n\t\t\tif (map->verified_stripes >= map->num_stripes) {\n\t\t\t\tbtrfs_err(fs_info,\n\t\t\t\t\"too many dev extents for chunk %llu found\",\n\t\t\t\t\t  em->start);\n\t\t\t\tret = -EUCLEAN;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmap->verified_stripes++;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found) {\n\t\tbtrfs_err(fs_info,\n\t\"dev extent physical offset %llu devid %llu has no corresponding chunk\",\n\t\t\tphysical_offset, devid);\n\t\tret = -EUCLEAN;\n\t}\n\n\t/* Make sure no dev extent is beyond device bondary */\n\tdev = btrfs_find_device(fs_info->fs_devices, devid, NULL, NULL, true);\n\tif (!dev) {\n\t\tbtrfs_err(fs_info, \"failed to find devid %llu\", devid);\n\t\tret = -EUCLEAN;\n\t\tgoto out;\n\t}\n\n\t/* It's possible this device is a dummy for seed device */\n\tif (dev->disk_total_bytes == 0) {\n\t\tdev = btrfs_find_device(fs_info->fs_devices->seed, devid, NULL,\n\t\t\t\t\tNULL, false);\n\t\tif (!dev) {\n\t\t\tbtrfs_err(fs_info, \"failed to find seed devid %llu\",\n\t\t\t\t  devid);\n\t\t\tret = -EUCLEAN;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (physical_offset + physical_len > dev->disk_total_bytes) {\n\t\tbtrfs_err(fs_info,\n\"dev extent devid %llu physical offset %llu len %llu is beyond device boundary %llu\",\n\t\t\t  devid, physical_offset, physical_len,\n\t\t\t  dev->disk_total_bytes);\n\t\tret = -EUCLEAN;\n\t\tgoto out;\n\t}\nout:\n\tfree_extent_map(em);\n\treturn ret;\n}",
        "patch": "--- code before\n+++ code after\n@@ -57,7 +57,7 @@\n \t}\n \n \t/* Make sure no dev extent is beyond device bondary */\n-\tdev = btrfs_find_device(fs_info->fs_devices, devid, NULL, NULL);\n+\tdev = btrfs_find_device(fs_info->fs_devices, devid, NULL, NULL, true);\n \tif (!dev) {\n \t\tbtrfs_err(fs_info, \"failed to find devid %llu\", devid);\n \t\tret = -EUCLEAN;\n@@ -66,7 +66,8 @@\n \n \t/* It's possible this device is a dummy for seed device */\n \tif (dev->disk_total_bytes == 0) {\n-\t\tdev = find_device(fs_info->fs_devices->seed, devid, NULL);\n+\t\tdev = btrfs_find_device(fs_info->fs_devices->seed, devid, NULL,\n+\t\t\t\t\tNULL, false);\n \t\tif (!dev) {\n \t\t\tbtrfs_err(fs_info, \"failed to find seed devid %llu\",\n \t\t\t\t  devid);",
        "function_modified_lines": {
            "added": [
                "\tdev = btrfs_find_device(fs_info->fs_devices, devid, NULL, NULL, true);",
                "\t\tdev = btrfs_find_device(fs_info->fs_devices->seed, devid, NULL,",
                "\t\t\t\t\tNULL, false);"
            ],
            "deleted": [
                "\tdev = btrfs_find_device(fs_info->fs_devices, devid, NULL, NULL);",
                "\t\tdev = find_device(fs_info->fs_devices->seed, devid, NULL);"
            ]
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "fs/btrfs/volumes.c in the Linux kernel before 5.1 allows a btrfs_verify_dev_extents NULL pointer dereference via a crafted btrfs image because fs_devices->devices is mishandled within find_device, aka CID-09ba3bc9dd15.",
        "id": 2119
    },
    {
        "cve_id": "CVE-2019-18885",
        "code_before_change": "int btrfs_scrub_progress(struct btrfs_fs_info *fs_info, u64 devid,\n\t\t\t struct btrfs_scrub_progress *progress)\n{\n\tstruct btrfs_device *dev;\n\tstruct scrub_ctx *sctx = NULL;\n\n\tmutex_lock(&fs_info->fs_devices->device_list_mutex);\n\tdev = btrfs_find_device(fs_info->fs_devices, devid, NULL, NULL);\n\tif (dev)\n\t\tsctx = dev->scrub_ctx;\n\tif (sctx)\n\t\tmemcpy(progress, &sctx->stat, sizeof(*progress));\n\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\n\treturn dev ? (sctx ? 0 : -ENOTCONN) : -ENODEV;\n}",
        "code_after_change": "int btrfs_scrub_progress(struct btrfs_fs_info *fs_info, u64 devid,\n\t\t\t struct btrfs_scrub_progress *progress)\n{\n\tstruct btrfs_device *dev;\n\tstruct scrub_ctx *sctx = NULL;\n\n\tmutex_lock(&fs_info->fs_devices->device_list_mutex);\n\tdev = btrfs_find_device(fs_info->fs_devices, devid, NULL, NULL, true);\n\tif (dev)\n\t\tsctx = dev->scrub_ctx;\n\tif (sctx)\n\t\tmemcpy(progress, &sctx->stat, sizeof(*progress));\n\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\n\treturn dev ? (sctx ? 0 : -ENOTCONN) : -ENODEV;\n}",
        "patch": "--- code before\n+++ code after\n@@ -5,7 +5,7 @@\n \tstruct scrub_ctx *sctx = NULL;\n \n \tmutex_lock(&fs_info->fs_devices->device_list_mutex);\n-\tdev = btrfs_find_device(fs_info->fs_devices, devid, NULL, NULL);\n+\tdev = btrfs_find_device(fs_info->fs_devices, devid, NULL, NULL, true);\n \tif (dev)\n \t\tsctx = dev->scrub_ctx;\n \tif (sctx)",
        "function_modified_lines": {
            "added": [
                "\tdev = btrfs_find_device(fs_info->fs_devices, devid, NULL, NULL, true);"
            ],
            "deleted": [
                "\tdev = btrfs_find_device(fs_info->fs_devices, devid, NULL, NULL);"
            ]
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "fs/btrfs/volumes.c in the Linux kernel before 5.1 allows a btrfs_verify_dev_extents NULL pointer dereference via a crafted btrfs image because fs_devices->devices is mishandled within find_device, aka CID-09ba3bc9dd15.",
        "id": 2111
    },
    {
        "cve_id": "CVE-2015-8970",
        "code_before_change": "static void skcipher_release(void *private)\n{\n\tcrypto_free_skcipher(private);\n}",
        "code_after_change": "static void skcipher_release(void *private)\n{\n\tstruct skcipher_tfm *tfm = private;\n\n\tcrypto_free_skcipher(tfm->skcipher);\n\tkfree(tfm);\n}",
        "patch": "--- code before\n+++ code after\n@@ -1,4 +1,7 @@\n static void skcipher_release(void *private)\n {\n-\tcrypto_free_skcipher(private);\n+\tstruct skcipher_tfm *tfm = private;\n+\n+\tcrypto_free_skcipher(tfm->skcipher);\n+\tkfree(tfm);\n }",
        "function_modified_lines": {
            "added": [
                "\tstruct skcipher_tfm *tfm = private;",
                "",
                "\tcrypto_free_skcipher(tfm->skcipher);",
                "\tkfree(tfm);"
            ],
            "deleted": [
                "\tcrypto_free_skcipher(private);"
            ]
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "crypto/algif_skcipher.c in the Linux kernel before 4.4.2 does not verify that a setkey operation has been performed on an AF_ALG socket before an accept system call is processed, which allows local users to cause a denial of service (NULL pointer dereference and system crash) via a crafted application that does not supply a key, related to the lrw_crypt function in crypto/lrw.c.",
        "id": 877
    },
    {
        "cve_id": "CVE-2015-8970",
        "code_before_change": "static int skcipher_setkey(void *private, const u8 *key, unsigned int keylen)\n{\n\treturn crypto_skcipher_setkey(private, key, keylen);\n}",
        "code_after_change": "static int skcipher_setkey(void *private, const u8 *key, unsigned int keylen)\n{\n\tstruct skcipher_tfm *tfm = private;\n\tint err;\n\n\terr = crypto_skcipher_setkey(tfm->skcipher, key, keylen);\n\ttfm->has_key = !err;\n\n\treturn err;\n}",
        "patch": "--- code before\n+++ code after\n@@ -1,4 +1,10 @@\n static int skcipher_setkey(void *private, const u8 *key, unsigned int keylen)\n {\n-\treturn crypto_skcipher_setkey(private, key, keylen);\n+\tstruct skcipher_tfm *tfm = private;\n+\tint err;\n+\n+\terr = crypto_skcipher_setkey(tfm->skcipher, key, keylen);\n+\ttfm->has_key = !err;\n+\n+\treturn err;\n }",
        "function_modified_lines": {
            "added": [
                "\tstruct skcipher_tfm *tfm = private;",
                "\tint err;",
                "",
                "\terr = crypto_skcipher_setkey(tfm->skcipher, key, keylen);",
                "\ttfm->has_key = !err;",
                "",
                "\treturn err;"
            ],
            "deleted": [
                "\treturn crypto_skcipher_setkey(private, key, keylen);"
            ]
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "crypto/algif_skcipher.c in the Linux kernel before 4.4.2 does not verify that a setkey operation has been performed on an AF_ALG socket before an accept system call is processed, which allows local users to cause a denial of service (NULL pointer dereference and system crash) via a crafted application that does not supply a key, related to the lrw_crypt function in crypto/lrw.c.",
        "id": 878
    },
    {
        "cve_id": "CVE-2020-11609",
        "code_before_change": "static int stv06xx_start(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstruct usb_host_interface *alt;\n\tstruct usb_interface *intf;\n\tint err, packet_size;\n\n\tintf = usb_ifnum_to_if(sd->gspca_dev.dev, sd->gspca_dev.iface);\n\talt = usb_altnum_to_altsetting(intf, sd->gspca_dev.alt);\n\tif (!alt) {\n\t\tgspca_err(gspca_dev, \"Couldn't get altsetting\\n\");\n\t\treturn -EIO;\n\t}\n\n\tpacket_size = le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);\n\terr = stv06xx_write_bridge(sd, STV_ISO_SIZE_L, packet_size);\n\tif (err < 0)\n\t\treturn err;\n\n\t/* Prepare the sensor for start */\n\terr = sd->sensor->start(sd);\n\tif (err < 0)\n\t\tgoto out;\n\n\t/* Start isochronous streaming */\n\terr = stv06xx_write_bridge(sd, STV_ISO_ENABLE, 1);\n\nout:\n\tif (err < 0)\n\t\tgspca_dbg(gspca_dev, D_STREAM, \"Starting stream failed\\n\");\n\telse\n\t\tgspca_dbg(gspca_dev, D_STREAM, \"Started streaming\\n\");\n\n\treturn (err < 0) ? err : 0;\n}",
        "code_after_change": "static int stv06xx_start(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstruct usb_host_interface *alt;\n\tstruct usb_interface *intf;\n\tint err, packet_size;\n\n\tintf = usb_ifnum_to_if(sd->gspca_dev.dev, sd->gspca_dev.iface);\n\talt = usb_altnum_to_altsetting(intf, sd->gspca_dev.alt);\n\tif (!alt) {\n\t\tgspca_err(gspca_dev, \"Couldn't get altsetting\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (alt->desc.bNumEndpoints < 1)\n\t\treturn -ENODEV;\n\n\tpacket_size = le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);\n\terr = stv06xx_write_bridge(sd, STV_ISO_SIZE_L, packet_size);\n\tif (err < 0)\n\t\treturn err;\n\n\t/* Prepare the sensor for start */\n\terr = sd->sensor->start(sd);\n\tif (err < 0)\n\t\tgoto out;\n\n\t/* Start isochronous streaming */\n\terr = stv06xx_write_bridge(sd, STV_ISO_ENABLE, 1);\n\nout:\n\tif (err < 0)\n\t\tgspca_dbg(gspca_dev, D_STREAM, \"Starting stream failed\\n\");\n\telse\n\t\tgspca_dbg(gspca_dev, D_STREAM, \"Started streaming\\n\");\n\n\treturn (err < 0) ? err : 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -11,6 +11,9 @@\n \t\tgspca_err(gspca_dev, \"Couldn't get altsetting\\n\");\n \t\treturn -EIO;\n \t}\n+\n+\tif (alt->desc.bNumEndpoints < 1)\n+\t\treturn -ENODEV;\n \n \tpacket_size = le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);\n \terr = stv06xx_write_bridge(sd, STV_ISO_SIZE_L, packet_size);",
        "function_modified_lines": {
            "added": [
                "",
                "\tif (alt->desc.bNumEndpoints < 1)",
                "\t\treturn -ENODEV;"
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "An issue was discovered in the stv06xx subsystem in the Linux kernel before 5.6.1. drivers/media/usb/gspca/stv06xx/stv06xx.c and drivers/media/usb/gspca/stv06xx/stv06xx_pb0100.c mishandle invalid descriptors, as demonstrated by a NULL pointer dereference, aka CID-485b06aadb93.",
        "id": 2431
    },
    {
        "cve_id": "CVE-2017-2647",
        "code_before_change": "key_ref_t keyring_search(key_ref_t keyring,\n\t\t\t struct key_type *type,\n\t\t\t const char *description)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= type,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= type->match,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_DO_STATE_CHECK,\n\t};\n\tkey_ref_t key;\n\tint ret;\n\n\tif (!ctx.match_data.cmp)\n\t\treturn ERR_PTR(-ENOKEY);\n\n\tif (type->match_preparse) {\n\t\tret = type->match_preparse(&ctx.match_data);\n\t\tif (ret < 0)\n\t\t\treturn ERR_PTR(ret);\n\t}\n\n\tkey = keyring_search_aux(keyring, &ctx);\n\n\tif (type->match_free)\n\t\ttype->match_free(&ctx.match_data);\n\treturn key;\n}",
        "code_after_change": "key_ref_t keyring_search(key_ref_t keyring,\n\t\t\t struct key_type *type,\n\t\t\t const char *description)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= type,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= key_default_cmp,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_DO_STATE_CHECK,\n\t};\n\tkey_ref_t key;\n\tint ret;\n\n\tif (type->match_preparse) {\n\t\tret = type->match_preparse(&ctx.match_data);\n\t\tif (ret < 0)\n\t\t\treturn ERR_PTR(ret);\n\t}\n\n\tkey = keyring_search_aux(keyring, &ctx);\n\n\tif (type->match_free)\n\t\ttype->match_free(&ctx.match_data);\n\treturn key;\n}",
        "patch": "--- code before\n+++ code after\n@@ -6,16 +6,13 @@\n \t\t.index_key.type\t\t= type,\n \t\t.index_key.description\t= description,\n \t\t.cred\t\t\t= current_cred(),\n-\t\t.match_data.cmp\t\t= type->match,\n+\t\t.match_data.cmp\t\t= key_default_cmp,\n \t\t.match_data.raw_data\t= description,\n \t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n \t\t.flags\t\t\t= KEYRING_SEARCH_DO_STATE_CHECK,\n \t};\n \tkey_ref_t key;\n \tint ret;\n-\n-\tif (!ctx.match_data.cmp)\n-\t\treturn ERR_PTR(-ENOKEY);\n \n \tif (type->match_preparse) {\n \t\tret = type->match_preparse(&ctx.match_data);",
        "function_modified_lines": {
            "added": [
                "\t\t.match_data.cmp\t\t= key_default_cmp,"
            ],
            "deleted": [
                "\t\t.match_data.cmp\t\t= type->match,",
                "",
                "\tif (!ctx.match_data.cmp)",
                "\t\treturn ERR_PTR(-ENOKEY);"
            ]
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "The KEYS subsystem in the Linux kernel before 3.18 allows local users to gain privileges or cause a denial of service (NULL pointer dereference and system crash) via vectors involving a NULL value for a certain match field, related to the keyring_search_iterator function in keyring.c.",
        "id": 1452
    },
    {
        "cve_id": "CVE-2014-7826",
        "code_before_change": "static void ftrace_syscall_exit(void *data, struct pt_regs *regs, long ret)\n{\n\tstruct trace_array *tr = data;\n\tstruct ftrace_event_file *ftrace_file;\n\tstruct syscall_trace_exit *entry;\n\tstruct syscall_metadata *sys_data;\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer *buffer;\n\tunsigned long irq_flags;\n\tint pc;\n\tint syscall_nr;\n\n\tsyscall_nr = trace_get_syscall_nr(current, regs);\n\tif (syscall_nr < 0)\n\t\treturn;\n\n\t/* Here we're inside tp handler's rcu_read_lock_sched (__DO_TRACE()) */\n\tftrace_file = rcu_dereference_sched(tr->exit_syscall_files[syscall_nr]);\n\tif (!ftrace_file)\n\t\treturn;\n\n\tif (ftrace_trigger_soft_disabled(ftrace_file))\n\t\treturn;\n\n\tsys_data = syscall_nr_to_meta(syscall_nr);\n\tif (!sys_data)\n\t\treturn;\n\n\tlocal_save_flags(irq_flags);\n\tpc = preempt_count();\n\n\tbuffer = tr->trace_buffer.buffer;\n\tevent = trace_buffer_lock_reserve(buffer,\n\t\t\tsys_data->exit_event->event.type, sizeof(*entry),\n\t\t\tirq_flags, pc);\n\tif (!event)\n\t\treturn;\n\n\tentry = ring_buffer_event_data(event);\n\tentry->nr = syscall_nr;\n\tentry->ret = syscall_get_return_value(current, regs);\n\n\tevent_trigger_unlock_commit(ftrace_file, buffer, event, entry,\n\t\t\t\t    irq_flags, pc);\n}",
        "code_after_change": "static void ftrace_syscall_exit(void *data, struct pt_regs *regs, long ret)\n{\n\tstruct trace_array *tr = data;\n\tstruct ftrace_event_file *ftrace_file;\n\tstruct syscall_trace_exit *entry;\n\tstruct syscall_metadata *sys_data;\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer *buffer;\n\tunsigned long irq_flags;\n\tint pc;\n\tint syscall_nr;\n\n\tsyscall_nr = trace_get_syscall_nr(current, regs);\n\tif (syscall_nr < 0 || syscall_nr >= NR_syscalls)\n\t\treturn;\n\n\t/* Here we're inside tp handler's rcu_read_lock_sched (__DO_TRACE()) */\n\tftrace_file = rcu_dereference_sched(tr->exit_syscall_files[syscall_nr]);\n\tif (!ftrace_file)\n\t\treturn;\n\n\tif (ftrace_trigger_soft_disabled(ftrace_file))\n\t\treturn;\n\n\tsys_data = syscall_nr_to_meta(syscall_nr);\n\tif (!sys_data)\n\t\treturn;\n\n\tlocal_save_flags(irq_flags);\n\tpc = preempt_count();\n\n\tbuffer = tr->trace_buffer.buffer;\n\tevent = trace_buffer_lock_reserve(buffer,\n\t\t\tsys_data->exit_event->event.type, sizeof(*entry),\n\t\t\tirq_flags, pc);\n\tif (!event)\n\t\treturn;\n\n\tentry = ring_buffer_event_data(event);\n\tentry->nr = syscall_nr;\n\tentry->ret = syscall_get_return_value(current, regs);\n\n\tevent_trigger_unlock_commit(ftrace_file, buffer, event, entry,\n\t\t\t\t    irq_flags, pc);\n}",
        "patch": "--- code before\n+++ code after\n@@ -11,7 +11,7 @@\n \tint syscall_nr;\n \n \tsyscall_nr = trace_get_syscall_nr(current, regs);\n-\tif (syscall_nr < 0)\n+\tif (syscall_nr < 0 || syscall_nr >= NR_syscalls)\n \t\treturn;\n \n \t/* Here we're inside tp handler's rcu_read_lock_sched (__DO_TRACE()) */",
        "function_modified_lines": {
            "added": [
                "\tif (syscall_nr < 0 || syscall_nr >= NR_syscalls)"
            ],
            "deleted": [
                "\tif (syscall_nr < 0)"
            ]
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "kernel/trace/trace_syscalls.c in the Linux kernel through 3.17.2 does not properly handle private syscall numbers during use of the ftrace subsystem, which allows local users to gain privileges or cause a denial of service (invalid pointer dereference) via a crafted application.",
        "id": 593
    },
    {
        "cve_id": "CVE-2014-7826",
        "code_before_change": "static void perf_syscall_enter(void *ignore, struct pt_regs *regs, long id)\n{\n\tstruct syscall_metadata *sys_data;\n\tstruct syscall_trace_enter *rec;\n\tstruct hlist_head *head;\n\tint syscall_nr;\n\tint rctx;\n\tint size;\n\n\tsyscall_nr = trace_get_syscall_nr(current, regs);\n\tif (syscall_nr < 0)\n\t\treturn;\n\tif (!test_bit(syscall_nr, enabled_perf_enter_syscalls))\n\t\treturn;\n\n\tsys_data = syscall_nr_to_meta(syscall_nr);\n\tif (!sys_data)\n\t\treturn;\n\n\thead = this_cpu_ptr(sys_data->enter_event->perf_events);\n\tif (hlist_empty(head))\n\t\treturn;\n\n\t/* get the size after alignment with the u32 buffer size field */\n\tsize = sizeof(unsigned long) * sys_data->nb_args + sizeof(*rec);\n\tsize = ALIGN(size + sizeof(u32), sizeof(u64));\n\tsize -= sizeof(u32);\n\n\trec = (struct syscall_trace_enter *)perf_trace_buf_prepare(size,\n\t\t\t\tsys_data->enter_event->event.type, regs, &rctx);\n\tif (!rec)\n\t\treturn;\n\n\trec->nr = syscall_nr;\n\tsyscall_get_arguments(current, regs, 0, sys_data->nb_args,\n\t\t\t       (unsigned long *)&rec->args);\n\tperf_trace_buf_submit(rec, size, rctx, 0, 1, regs, head, NULL);\n}",
        "code_after_change": "static void perf_syscall_enter(void *ignore, struct pt_regs *regs, long id)\n{\n\tstruct syscall_metadata *sys_data;\n\tstruct syscall_trace_enter *rec;\n\tstruct hlist_head *head;\n\tint syscall_nr;\n\tint rctx;\n\tint size;\n\n\tsyscall_nr = trace_get_syscall_nr(current, regs);\n\tif (syscall_nr < 0 || syscall_nr >= NR_syscalls)\n\t\treturn;\n\tif (!test_bit(syscall_nr, enabled_perf_enter_syscalls))\n\t\treturn;\n\n\tsys_data = syscall_nr_to_meta(syscall_nr);\n\tif (!sys_data)\n\t\treturn;\n\n\thead = this_cpu_ptr(sys_data->enter_event->perf_events);\n\tif (hlist_empty(head))\n\t\treturn;\n\n\t/* get the size after alignment with the u32 buffer size field */\n\tsize = sizeof(unsigned long) * sys_data->nb_args + sizeof(*rec);\n\tsize = ALIGN(size + sizeof(u32), sizeof(u64));\n\tsize -= sizeof(u32);\n\n\trec = (struct syscall_trace_enter *)perf_trace_buf_prepare(size,\n\t\t\t\tsys_data->enter_event->event.type, regs, &rctx);\n\tif (!rec)\n\t\treturn;\n\n\trec->nr = syscall_nr;\n\tsyscall_get_arguments(current, regs, 0, sys_data->nb_args,\n\t\t\t       (unsigned long *)&rec->args);\n\tperf_trace_buf_submit(rec, size, rctx, 0, 1, regs, head, NULL);\n}",
        "patch": "--- code before\n+++ code after\n@@ -8,7 +8,7 @@\n \tint size;\n \n \tsyscall_nr = trace_get_syscall_nr(current, regs);\n-\tif (syscall_nr < 0)\n+\tif (syscall_nr < 0 || syscall_nr >= NR_syscalls)\n \t\treturn;\n \tif (!test_bit(syscall_nr, enabled_perf_enter_syscalls))\n \t\treturn;",
        "function_modified_lines": {
            "added": [
                "\tif (syscall_nr < 0 || syscall_nr >= NR_syscalls)"
            ],
            "deleted": [
                "\tif (syscall_nr < 0)"
            ]
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "kernel/trace/trace_syscalls.c in the Linux kernel through 3.17.2 does not properly handle private syscall numbers during use of the ftrace subsystem, which allows local users to gain privileges or cause a denial of service (invalid pointer dereference) via a crafted application.",
        "id": 596
    },
    {
        "cve_id": "CVE-2022-3110",
        "code_before_change": "void rtw_alloc_hwxmits(struct adapter *padapter)\n{\n\tstruct hw_xmit *hwxmits;\n\tstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\n\n\tpxmitpriv->hwxmit_entry = HWXMIT_ENTRY;\n\n\tpxmitpriv->hwxmits = kzalloc(sizeof(struct hw_xmit) * pxmitpriv->hwxmit_entry, GFP_KERNEL);\n\n\thwxmits = pxmitpriv->hwxmits;\n\n\tif (pxmitpriv->hwxmit_entry == 5) {\n\t\thwxmits[0] .sta_queue = &pxmitpriv->bm_pending;\n\t\thwxmits[1] .sta_queue = &pxmitpriv->vo_pending;\n\t\thwxmits[2] .sta_queue = &pxmitpriv->vi_pending;\n\t\thwxmits[3] .sta_queue = &pxmitpriv->bk_pending;\n\t\thwxmits[4] .sta_queue = &pxmitpriv->be_pending;\n\t} else if (pxmitpriv->hwxmit_entry == 4) {\n\t\thwxmits[0] .sta_queue = &pxmitpriv->vo_pending;\n\t\thwxmits[1] .sta_queue = &pxmitpriv->vi_pending;\n\t\thwxmits[2] .sta_queue = &pxmitpriv->be_pending;\n\t\thwxmits[3] .sta_queue = &pxmitpriv->bk_pending;\n\t} else {\n\t}\n}",
        "code_after_change": "int rtw_alloc_hwxmits(struct adapter *padapter)\n{\n\tstruct hw_xmit *hwxmits;\n\tstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\n\n\tpxmitpriv->hwxmit_entry = HWXMIT_ENTRY;\n\n\tpxmitpriv->hwxmits = kzalloc(sizeof(struct hw_xmit) * pxmitpriv->hwxmit_entry, GFP_KERNEL);\n\tif (!pxmitpriv->hwxmits)\n\t\treturn -ENOMEM;\n\n\thwxmits = pxmitpriv->hwxmits;\n\n\tif (pxmitpriv->hwxmit_entry == 5) {\n\t\thwxmits[0] .sta_queue = &pxmitpriv->bm_pending;\n\t\thwxmits[1] .sta_queue = &pxmitpriv->vo_pending;\n\t\thwxmits[2] .sta_queue = &pxmitpriv->vi_pending;\n\t\thwxmits[3] .sta_queue = &pxmitpriv->bk_pending;\n\t\thwxmits[4] .sta_queue = &pxmitpriv->be_pending;\n\t} else if (pxmitpriv->hwxmit_entry == 4) {\n\t\thwxmits[0] .sta_queue = &pxmitpriv->vo_pending;\n\t\thwxmits[1] .sta_queue = &pxmitpriv->vi_pending;\n\t\thwxmits[2] .sta_queue = &pxmitpriv->be_pending;\n\t\thwxmits[3] .sta_queue = &pxmitpriv->bk_pending;\n\t} else {\n\t}\n\n\treturn 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -1,4 +1,4 @@\n-void rtw_alloc_hwxmits(struct adapter *padapter)\n+int rtw_alloc_hwxmits(struct adapter *padapter)\n {\n \tstruct hw_xmit *hwxmits;\n \tstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\n@@ -6,6 +6,8 @@\n \tpxmitpriv->hwxmit_entry = HWXMIT_ENTRY;\n \n \tpxmitpriv->hwxmits = kzalloc(sizeof(struct hw_xmit) * pxmitpriv->hwxmit_entry, GFP_KERNEL);\n+\tif (!pxmitpriv->hwxmits)\n+\t\treturn -ENOMEM;\n \n \thwxmits = pxmitpriv->hwxmits;\n \n@@ -22,4 +24,6 @@\n \t\thwxmits[3] .sta_queue = &pxmitpriv->bk_pending;\n \t} else {\n \t}\n+\n+\treturn 0;\n }",
        "function_modified_lines": {
            "added": [
                "int rtw_alloc_hwxmits(struct adapter *padapter)",
                "\tif (!pxmitpriv->hwxmits)",
                "\t\treturn -ENOMEM;",
                "",
                "\treturn 0;"
            ],
            "deleted": [
                "void rtw_alloc_hwxmits(struct adapter *padapter)"
            ]
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "An issue was discovered in the Linux kernel through 5.16-rc6. _rtw_init_xmit_priv in drivers/staging/r8188eu/core/rtw_xmit.c lacks check of the return value of rtw_alloc_hwxmits() and will cause the null pointer dereference.",
        "id": 3554
    },
    {
        "cve_id": "CVE-2019-15223",
        "code_before_change": "int line6_probe(struct usb_interface *interface,\n\t\tconst struct usb_device_id *id,\n\t\tconst char *driver_name,\n\t\tconst struct line6_properties *properties,\n\t\tint (*private_init)(struct usb_line6 *, const struct usb_device_id *id),\n\t\tsize_t data_size)\n{\n\tstruct usb_device *usbdev = interface_to_usbdev(interface);\n\tstruct snd_card *card;\n\tstruct usb_line6 *line6;\n\tint interface_number;\n\tint ret;\n\n\tif (WARN_ON(data_size < sizeof(*line6)))\n\t\treturn -EINVAL;\n\n\t/* we don't handle multiple configurations */\n\tif (usbdev->descriptor.bNumConfigurations != 1)\n\t\treturn -ENODEV;\n\n\tret = snd_card_new(&interface->dev,\n\t\t\t   SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1,\n\t\t\t   THIS_MODULE, data_size, &card);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* store basic data: */\n\tline6 = card->private_data;\n\tline6->card = card;\n\tline6->properties = properties;\n\tline6->usbdev = usbdev;\n\tline6->ifcdev = &interface->dev;\n\n\tstrcpy(card->id, properties->id);\n\tstrcpy(card->driver, driver_name);\n\tstrcpy(card->shortname, properties->name);\n\tsprintf(card->longname, \"Line 6 %s at USB %s\", properties->name,\n\t\tdev_name(line6->ifcdev));\n\tcard->private_free = line6_destruct;\n\n\tusb_set_intfdata(interface, line6);\n\n\t/* increment reference counters: */\n\tusb_get_dev(usbdev);\n\n\t/* initialize device info: */\n\tdev_info(&interface->dev, \"Line 6 %s found\\n\", properties->name);\n\n\t/* query interface number */\n\tinterface_number = interface->cur_altsetting->desc.bInterfaceNumber;\n\n\t/* TODO reserves the bus bandwidth even without actual transfer */\n\tret = usb_set_interface(usbdev, interface_number,\n\t\t\t\tproperties->altsetting);\n\tif (ret < 0) {\n\t\tdev_err(&interface->dev, \"set_interface failed\\n\");\n\t\tgoto error;\n\t}\n\n\tline6_get_usb_properties(line6);\n\n\tif (properties->capabilities & LINE6_CAP_CONTROL) {\n\t\tret = line6_init_cap_control(line6);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t}\n\n\t/* initialize device data based on device: */\n\tret = private_init(line6, id);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t/* creation of additional special files should go here */\n\n\tdev_info(&interface->dev, \"Line 6 %s now attached\\n\",\n\t\t properties->name);\n\n\treturn 0;\n\n error:\n\t/* we can call disconnect callback here because no close-sync is\n\t * needed yet at this point\n\t */\n\tline6_disconnect(interface);\n\treturn ret;\n}",
        "code_after_change": "int line6_probe(struct usb_interface *interface,\n\t\tconst struct usb_device_id *id,\n\t\tconst char *driver_name,\n\t\tconst struct line6_properties *properties,\n\t\tint (*private_init)(struct usb_line6 *, const struct usb_device_id *id),\n\t\tsize_t data_size)\n{\n\tstruct usb_device *usbdev = interface_to_usbdev(interface);\n\tstruct snd_card *card;\n\tstruct usb_line6 *line6;\n\tint interface_number;\n\tint ret;\n\n\tif (WARN_ON(data_size < sizeof(*line6)))\n\t\treturn -EINVAL;\n\n\t/* we don't handle multiple configurations */\n\tif (usbdev->descriptor.bNumConfigurations != 1)\n\t\treturn -ENODEV;\n\n\tret = snd_card_new(&interface->dev,\n\t\t\t   SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1,\n\t\t\t   THIS_MODULE, data_size, &card);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* store basic data: */\n\tline6 = card->private_data;\n\tline6->card = card;\n\tline6->properties = properties;\n\tline6->usbdev = usbdev;\n\tline6->ifcdev = &interface->dev;\n\tINIT_DELAYED_WORK(&line6->startup_work, line6_startup_work);\n\n\tstrcpy(card->id, properties->id);\n\tstrcpy(card->driver, driver_name);\n\tstrcpy(card->shortname, properties->name);\n\tsprintf(card->longname, \"Line 6 %s at USB %s\", properties->name,\n\t\tdev_name(line6->ifcdev));\n\tcard->private_free = line6_destruct;\n\n\tusb_set_intfdata(interface, line6);\n\n\t/* increment reference counters: */\n\tusb_get_dev(usbdev);\n\n\t/* initialize device info: */\n\tdev_info(&interface->dev, \"Line 6 %s found\\n\", properties->name);\n\n\t/* query interface number */\n\tinterface_number = interface->cur_altsetting->desc.bInterfaceNumber;\n\n\t/* TODO reserves the bus bandwidth even without actual transfer */\n\tret = usb_set_interface(usbdev, interface_number,\n\t\t\t\tproperties->altsetting);\n\tif (ret < 0) {\n\t\tdev_err(&interface->dev, \"set_interface failed\\n\");\n\t\tgoto error;\n\t}\n\n\tline6_get_usb_properties(line6);\n\n\tif (properties->capabilities & LINE6_CAP_CONTROL) {\n\t\tret = line6_init_cap_control(line6);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t}\n\n\t/* initialize device data based on device: */\n\tret = private_init(line6, id);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t/* creation of additional special files should go here */\n\n\tdev_info(&interface->dev, \"Line 6 %s now attached\\n\",\n\t\t properties->name);\n\n\treturn 0;\n\n error:\n\t/* we can call disconnect callback here because no close-sync is\n\t * needed yet at this point\n\t */\n\tline6_disconnect(interface);\n\treturn ret;\n}",
        "patch": "--- code before\n+++ code after\n@@ -30,6 +30,7 @@\n \tline6->properties = properties;\n \tline6->usbdev = usbdev;\n \tline6->ifcdev = &interface->dev;\n+\tINIT_DELAYED_WORK(&line6->startup_work, line6_startup_work);\n \n \tstrcpy(card->id, properties->id);\n \tstrcpy(card->driver, driver_name);",
        "function_modified_lines": {
            "added": [
                "\tINIT_DELAYED_WORK(&line6->startup_work, line6_startup_work);"
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "An issue was discovered in the Linux kernel before 5.1.8. There is a NULL pointer dereference caused by a malicious USB device in the sound/usb/line6/driver.c driver.",
        "id": 2009
    },
    {
        "cve_id": "CVE-2019-15223",
        "code_before_change": "static int toneport_init(struct usb_line6 *line6,\n\t\t\t const struct usb_device_id *id)\n{\n\tint err;\n\tstruct usb_line6_toneport *toneport =  (struct usb_line6_toneport *) line6;\n\n\ttoneport->type = id->driver_info;\n\tINIT_DELAYED_WORK(&toneport->pcm_work, toneport_start_pcm);\n\n\tline6->disconnect = line6_toneport_disconnect;\n\n\t/* initialize PCM subsystem: */\n\terr = line6_init_pcm(line6, &toneport_pcm_properties);\n\tif (err < 0)\n\t\treturn err;\n\n\t/* register monitor control: */\n\terr = snd_ctl_add(line6->card,\n\t\t\t  snd_ctl_new1(&toneport_control_monitor,\n\t\t\t\t       line6->line6pcm));\n\tif (err < 0)\n\t\treturn err;\n\n\t/* register source select control: */\n\tif (toneport_has_source_select(toneport)) {\n\t\terr =\n\t\t    snd_ctl_add(line6->card,\n\t\t\t\tsnd_ctl_new1(&toneport_control_source,\n\t\t\t\t\t     line6->line6pcm));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tline6_read_serial_number(line6, &toneport->serial_number);\n\tline6_read_data(line6, 0x80c2, &toneport->firmware_version, 1);\n\n\tif (toneport_has_led(toneport)) {\n\t\terr = toneport_init_leds(toneport);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\terr = toneport_setup(toneport);\n\tif (err)\n\t\treturn err;\n\n\t/* register audio system: */\n\treturn snd_card_register(line6->card);\n}",
        "code_after_change": "static int toneport_init(struct usb_line6 *line6,\n\t\t\t const struct usb_device_id *id)\n{\n\tint err;\n\tstruct usb_line6_toneport *toneport =  (struct usb_line6_toneport *) line6;\n\n\ttoneport->type = id->driver_info;\n\n\tline6->disconnect = line6_toneport_disconnect;\n\tline6->startup = toneport_startup;\n\n\t/* initialize PCM subsystem: */\n\terr = line6_init_pcm(line6, &toneport_pcm_properties);\n\tif (err < 0)\n\t\treturn err;\n\n\t/* register monitor control: */\n\terr = snd_ctl_add(line6->card,\n\t\t\t  snd_ctl_new1(&toneport_control_monitor,\n\t\t\t\t       line6->line6pcm));\n\tif (err < 0)\n\t\treturn err;\n\n\t/* register source select control: */\n\tif (toneport_has_source_select(toneport)) {\n\t\terr =\n\t\t    snd_ctl_add(line6->card,\n\t\t\t\tsnd_ctl_new1(&toneport_control_source,\n\t\t\t\t\t     line6->line6pcm));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tline6_read_serial_number(line6, &toneport->serial_number);\n\tline6_read_data(line6, 0x80c2, &toneport->firmware_version, 1);\n\n\tif (toneport_has_led(toneport)) {\n\t\terr = toneport_init_leds(toneport);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\terr = toneport_setup(toneport);\n\tif (err)\n\t\treturn err;\n\n\t/* register audio system: */\n\treturn snd_card_register(line6->card);\n}",
        "patch": "--- code before\n+++ code after\n@@ -5,9 +5,9 @@\n \tstruct usb_line6_toneport *toneport =  (struct usb_line6_toneport *) line6;\n \n \ttoneport->type = id->driver_info;\n-\tINIT_DELAYED_WORK(&toneport->pcm_work, toneport_start_pcm);\n \n \tline6->disconnect = line6_toneport_disconnect;\n+\tline6->startup = toneport_startup;\n \n \t/* initialize PCM subsystem: */\n \terr = line6_init_pcm(line6, &toneport_pcm_properties);",
        "function_modified_lines": {
            "added": [
                "\tline6->startup = toneport_startup;"
            ],
            "deleted": [
                "\tINIT_DELAYED_WORK(&toneport->pcm_work, toneport_start_pcm);"
            ]
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "An issue was discovered in the Linux kernel before 5.1.8. There is a NULL pointer dereference caused by a malicious USB device in the sound/usb/line6/driver.c driver.",
        "id": 2011
    },
    {
        "cve_id": "CVE-2019-15223",
        "code_before_change": "static int toneport_setup(struct usb_line6_toneport *toneport)\n{\n\tu32 *ticks;\n\tstruct usb_line6 *line6 = &toneport->line6;\n\tstruct usb_device *usbdev = line6->usbdev;\n\n\tticks = kmalloc(sizeof(*ticks), GFP_KERNEL);\n\tif (!ticks)\n\t\treturn -ENOMEM;\n\n\t/* sync time on device with host: */\n\t/* note: 32-bit timestamps overflow in year 2106 */\n\t*ticks = (u32)ktime_get_real_seconds();\n\tline6_write_data(line6, 0x80c6, ticks, 4);\n\tkfree(ticks);\n\n\t/* enable device: */\n\ttoneport_send_cmd(usbdev, 0x0301, 0x0000);\n\n\t/* initialize source select: */\n\tif (toneport_has_source_select(toneport))\n\t\ttoneport_send_cmd(usbdev,\n\t\t\t\t  toneport_source_info[toneport->source].code,\n\t\t\t\t  0x0000);\n\n\tif (toneport_has_led(toneport))\n\t\ttoneport_update_led(toneport);\n\n\tschedule_delayed_work(&toneport->pcm_work,\n\t\t\t      msecs_to_jiffies(TONEPORT_PCM_DELAY * 1000));\n\treturn 0;\n}",
        "code_after_change": "static int toneport_setup(struct usb_line6_toneport *toneport)\n{\n\tu32 *ticks;\n\tstruct usb_line6 *line6 = &toneport->line6;\n\tstruct usb_device *usbdev = line6->usbdev;\n\n\tticks = kmalloc(sizeof(*ticks), GFP_KERNEL);\n\tif (!ticks)\n\t\treturn -ENOMEM;\n\n\t/* sync time on device with host: */\n\t/* note: 32-bit timestamps overflow in year 2106 */\n\t*ticks = (u32)ktime_get_real_seconds();\n\tline6_write_data(line6, 0x80c6, ticks, 4);\n\tkfree(ticks);\n\n\t/* enable device: */\n\ttoneport_send_cmd(usbdev, 0x0301, 0x0000);\n\n\t/* initialize source select: */\n\tif (toneport_has_source_select(toneport))\n\t\ttoneport_send_cmd(usbdev,\n\t\t\t\t  toneport_source_info[toneport->source].code,\n\t\t\t\t  0x0000);\n\n\tif (toneport_has_led(toneport))\n\t\ttoneport_update_led(toneport);\n\n\tschedule_delayed_work(&toneport->line6.startup_work,\n\t\t\t      msecs_to_jiffies(TONEPORT_PCM_DELAY * 1000));\n\treturn 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -26,7 +26,7 @@\n \tif (toneport_has_led(toneport))\n \t\ttoneport_update_led(toneport);\n \n-\tschedule_delayed_work(&toneport->pcm_work,\n+\tschedule_delayed_work(&toneport->line6.startup_work,\n \t\t\t      msecs_to_jiffies(TONEPORT_PCM_DELAY * 1000));\n \treturn 0;\n }",
        "function_modified_lines": {
            "added": [
                "\tschedule_delayed_work(&toneport->line6.startup_work,"
            ],
            "deleted": [
                "\tschedule_delayed_work(&toneport->pcm_work,"
            ]
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "An issue was discovered in the Linux kernel before 5.1.8. There is a NULL pointer dereference caused by a malicious USB device in the sound/usb/line6/driver.c driver.",
        "id": 2012
    },
    {
        "cve_id": "CVE-2020-11668",
        "code_before_change": "static int cit_get_packet_size(struct gspca_dev *gspca_dev)\n{\n\tstruct usb_host_interface *alt;\n\tstruct usb_interface *intf;\n\n\tintf = usb_ifnum_to_if(gspca_dev->dev, gspca_dev->iface);\n\talt = usb_altnum_to_altsetting(intf, gspca_dev->alt);\n\tif (!alt) {\n\t\tpr_err(\"Couldn't get altsetting\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);\n}",
        "code_after_change": "static int cit_get_packet_size(struct gspca_dev *gspca_dev)\n{\n\tstruct usb_host_interface *alt;\n\tstruct usb_interface *intf;\n\n\tintf = usb_ifnum_to_if(gspca_dev->dev, gspca_dev->iface);\n\talt = usb_altnum_to_altsetting(intf, gspca_dev->alt);\n\tif (!alt) {\n\t\tpr_err(\"Couldn't get altsetting\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (alt->desc.bNumEndpoints < 1)\n\t\treturn -ENODEV;\n\n\treturn le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);\n}",
        "patch": "--- code before\n+++ code after\n@@ -10,5 +10,8 @@\n \t\treturn -EIO;\n \t}\n \n+\tif (alt->desc.bNumEndpoints < 1)\n+\t\treturn -ENODEV;\n+\n \treturn le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);\n }",
        "function_modified_lines": {
            "added": [
                "\tif (alt->desc.bNumEndpoints < 1)",
                "\t\treturn -ENODEV;",
                ""
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "In the Linux kernel before 5.6.1, drivers/media/usb/gspca/xirlink_cit.c (aka the Xirlink camera USB driver) mishandles invalid descriptors, aka CID-a246b4d54770.",
        "id": 2434
    },
    {
        "cve_id": "CVE-2023-2177",
        "code_before_change": "static struct sctp_association *sctp_association_init(\n\t\t\t\t\tstruct sctp_association *asoc,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sock *sk,\n\t\t\t\t\tenum sctp_scope scope, gfp_t gfp)\n{\n\tstruct sctp_sock *sp;\n\tstruct sctp_paramhdr *p;\n\tint i;\n\n\t/* Retrieve the SCTP per socket area.  */\n\tsp = sctp_sk((struct sock *)sk);\n\n\t/* Discarding const is appropriate here.  */\n\tasoc->ep = (struct sctp_endpoint *)ep;\n\tasoc->base.sk = (struct sock *)sk;\n\tasoc->base.net = sock_net(sk);\n\n\tsctp_endpoint_hold(asoc->ep);\n\tsock_hold(asoc->base.sk);\n\n\t/* Initialize the common base substructure.  */\n\tasoc->base.type = SCTP_EP_TYPE_ASSOCIATION;\n\n\t/* Initialize the object handling fields.  */\n\trefcount_set(&asoc->base.refcnt, 1);\n\n\t/* Initialize the bind addr area.  */\n\tsctp_bind_addr_init(&asoc->base.bind_addr, ep->base.bind_addr.port);\n\n\tasoc->state = SCTP_STATE_CLOSED;\n\tasoc->cookie_life = ms_to_ktime(sp->assocparams.sasoc_cookie_life);\n\tasoc->user_frag = sp->user_frag;\n\n\t/* Set the association max_retrans and RTO values from the\n\t * socket values.\n\t */\n\tasoc->max_retrans = sp->assocparams.sasoc_asocmaxrxt;\n\tasoc->pf_retrans  = sp->pf_retrans;\n\tasoc->ps_retrans  = sp->ps_retrans;\n\tasoc->pf_expose   = sp->pf_expose;\n\n\tasoc->rto_initial = msecs_to_jiffies(sp->rtoinfo.srto_initial);\n\tasoc->rto_max = msecs_to_jiffies(sp->rtoinfo.srto_max);\n\tasoc->rto_min = msecs_to_jiffies(sp->rtoinfo.srto_min);\n\n\t/* Initialize the association's heartbeat interval based on the\n\t * sock configured value.\n\t */\n\tasoc->hbinterval = msecs_to_jiffies(sp->hbinterval);\n\tasoc->probe_interval = msecs_to_jiffies(sp->probe_interval);\n\n\tasoc->encap_port = sp->encap_port;\n\n\t/* Initialize path max retrans value. */\n\tasoc->pathmaxrxt = sp->pathmaxrxt;\n\n\tasoc->flowlabel = sp->flowlabel;\n\tasoc->dscp = sp->dscp;\n\n\t/* Set association default SACK delay */\n\tasoc->sackdelay = msecs_to_jiffies(sp->sackdelay);\n\tasoc->sackfreq = sp->sackfreq;\n\n\t/* Set the association default flags controlling\n\t * Heartbeat, SACK delay, and Path MTU Discovery.\n\t */\n\tasoc->param_flags = sp->param_flags;\n\n\t/* Initialize the maximum number of new data packets that can be sent\n\t * in a burst.\n\t */\n\tasoc->max_burst = sp->max_burst;\n\n\tasoc->subscribe = sp->subscribe;\n\n\t/* initialize association timers */\n\tasoc->timeouts[SCTP_EVENT_TIMEOUT_T1_COOKIE] = asoc->rto_initial;\n\tasoc->timeouts[SCTP_EVENT_TIMEOUT_T1_INIT] = asoc->rto_initial;\n\tasoc->timeouts[SCTP_EVENT_TIMEOUT_T2_SHUTDOWN] = asoc->rto_initial;\n\n\t/* sctpimpguide Section 2.12.2\n\t * If the 'T5-shutdown-guard' timer is used, it SHOULD be set to the\n\t * recommended value of 5 times 'RTO.Max'.\n\t */\n\tasoc->timeouts[SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD]\n\t\t= 5 * asoc->rto_max;\n\n\tasoc->timeouts[SCTP_EVENT_TIMEOUT_SACK] = asoc->sackdelay;\n\tasoc->timeouts[SCTP_EVENT_TIMEOUT_AUTOCLOSE] = sp->autoclose * HZ;\n\n\t/* Initializes the timers */\n\tfor (i = SCTP_EVENT_TIMEOUT_NONE; i < SCTP_NUM_TIMEOUT_TYPES; ++i)\n\t\ttimer_setup(&asoc->timers[i], sctp_timer_events[i], 0);\n\n\t/* Pull default initialization values from the sock options.\n\t * Note: This assumes that the values have already been\n\t * validated in the sock.\n\t */\n\tasoc->c.sinit_max_instreams = sp->initmsg.sinit_max_instreams;\n\tasoc->c.sinit_num_ostreams  = sp->initmsg.sinit_num_ostreams;\n\tasoc->max_init_attempts\t= sp->initmsg.sinit_max_attempts;\n\n\tasoc->max_init_timeo =\n\t\t msecs_to_jiffies(sp->initmsg.sinit_max_init_timeo);\n\n\t/* Set the local window size for receive.\n\t * This is also the rcvbuf space per association.\n\t * RFC 6 - A SCTP receiver MUST be able to receive a minimum of\n\t * 1500 bytes in one SCTP packet.\n\t */\n\tif ((sk->sk_rcvbuf/2) < SCTP_DEFAULT_MINWINDOW)\n\t\tasoc->rwnd = SCTP_DEFAULT_MINWINDOW;\n\telse\n\t\tasoc->rwnd = sk->sk_rcvbuf/2;\n\n\tasoc->a_rwnd = asoc->rwnd;\n\n\t/* Use my own max window until I learn something better.  */\n\tasoc->peer.rwnd = SCTP_DEFAULT_MAXWINDOW;\n\n\t/* Initialize the receive memory counter */\n\tatomic_set(&asoc->rmem_alloc, 0);\n\n\tinit_waitqueue_head(&asoc->wait);\n\n\tasoc->c.my_vtag = sctp_generate_tag(ep);\n\tasoc->c.my_port = ep->base.bind_addr.port;\n\n\tasoc->c.initial_tsn = sctp_generate_tsn(ep);\n\n\tasoc->next_tsn = asoc->c.initial_tsn;\n\n\tasoc->ctsn_ack_point = asoc->next_tsn - 1;\n\tasoc->adv_peer_ack_point = asoc->ctsn_ack_point;\n\tasoc->highest_sacked = asoc->ctsn_ack_point;\n\tasoc->last_cwr_tsn = asoc->ctsn_ack_point;\n\n\t/* ADDIP Section 4.1 Asconf Chunk Procedures\n\t *\n\t * When an endpoint has an ASCONF signaled change to be sent to the\n\t * remote endpoint it should do the following:\n\t * ...\n\t * A2) a serial number should be assigned to the chunk. The serial\n\t * number SHOULD be a monotonically increasing number. The serial\n\t * numbers SHOULD be initialized at the start of the\n\t * association to the same value as the initial TSN.\n\t */\n\tasoc->addip_serial = asoc->c.initial_tsn;\n\tasoc->strreset_outseq = asoc->c.initial_tsn;\n\n\tINIT_LIST_HEAD(&asoc->addip_chunk_list);\n\tINIT_LIST_HEAD(&asoc->asconf_ack_list);\n\n\t/* Make an empty list of remote transport addresses.  */\n\tINIT_LIST_HEAD(&asoc->peer.transport_addr_list);\n\n\t/* RFC 2960 5.1 Normal Establishment of an Association\n\t *\n\t * After the reception of the first data chunk in an\n\t * association the endpoint must immediately respond with a\n\t * sack to acknowledge the data chunk.  Subsequent\n\t * acknowledgements should be done as described in Section\n\t * 6.2.\n\t *\n\t * [We implement this by telling a new association that it\n\t * already received one packet.]\n\t */\n\tasoc->peer.sack_needed = 1;\n\tasoc->peer.sack_generation = 1;\n\n\t/* Create an input queue.  */\n\tsctp_inq_init(&asoc->base.inqueue);\n\tsctp_inq_set_th_handler(&asoc->base.inqueue, sctp_assoc_bh_rcv);\n\n\t/* Create an output queue.  */\n\tsctp_outq_init(asoc, &asoc->outqueue);\n\n\tif (!sctp_ulpq_init(&asoc->ulpq, asoc))\n\t\tgoto fail_init;\n\n\tif (sctp_stream_init(&asoc->stream, asoc->c.sinit_num_ostreams,\n\t\t\t     0, gfp))\n\t\tgoto fail_init;\n\n\t/* Initialize default path MTU. */\n\tasoc->pathmtu = sp->pathmtu;\n\tsctp_assoc_update_frag_point(asoc);\n\n\t/* Assume that peer would support both address types unless we are\n\t * told otherwise.\n\t */\n\tasoc->peer.ipv4_address = 1;\n\tif (asoc->base.sk->sk_family == PF_INET6)\n\t\tasoc->peer.ipv6_address = 1;\n\tINIT_LIST_HEAD(&asoc->asocs);\n\n\tasoc->default_stream = sp->default_stream;\n\tasoc->default_ppid = sp->default_ppid;\n\tasoc->default_flags = sp->default_flags;\n\tasoc->default_context = sp->default_context;\n\tasoc->default_timetolive = sp->default_timetolive;\n\tasoc->default_rcv_context = sp->default_rcv_context;\n\n\t/* AUTH related initializations */\n\tINIT_LIST_HEAD(&asoc->endpoint_shared_keys);\n\tif (sctp_auth_asoc_copy_shkeys(ep, asoc, gfp))\n\t\tgoto stream_free;\n\n\tasoc->active_key_id = ep->active_key_id;\n\tasoc->strreset_enable = ep->strreset_enable;\n\n\t/* Save the hmacs and chunks list into this association */\n\tif (ep->auth_hmacs_list)\n\t\tmemcpy(asoc->c.auth_hmacs, ep->auth_hmacs_list,\n\t\t\tntohs(ep->auth_hmacs_list->param_hdr.length));\n\tif (ep->auth_chunk_list)\n\t\tmemcpy(asoc->c.auth_chunks, ep->auth_chunk_list,\n\t\t\tntohs(ep->auth_chunk_list->param_hdr.length));\n\n\t/* Get the AUTH random number for this association */\n\tp = (struct sctp_paramhdr *)asoc->c.auth_random;\n\tp->type = SCTP_PARAM_RANDOM;\n\tp->length = htons(sizeof(*p) + SCTP_AUTH_RANDOM_LENGTH);\n\tget_random_bytes(p+1, SCTP_AUTH_RANDOM_LENGTH);\n\n\treturn asoc;\n\nstream_free:\n\tsctp_stream_free(&asoc->stream);\nfail_init:\n\tsock_put(asoc->base.sk);\n\tsctp_endpoint_put(asoc->ep);\n\treturn NULL;\n}",
        "code_after_change": "static struct sctp_association *sctp_association_init(\n\t\t\t\t\tstruct sctp_association *asoc,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sock *sk,\n\t\t\t\t\tenum sctp_scope scope, gfp_t gfp)\n{\n\tstruct sctp_sock *sp;\n\tstruct sctp_paramhdr *p;\n\tint i;\n\n\t/* Retrieve the SCTP per socket area.  */\n\tsp = sctp_sk((struct sock *)sk);\n\n\t/* Discarding const is appropriate here.  */\n\tasoc->ep = (struct sctp_endpoint *)ep;\n\tasoc->base.sk = (struct sock *)sk;\n\tasoc->base.net = sock_net(sk);\n\n\tsctp_endpoint_hold(asoc->ep);\n\tsock_hold(asoc->base.sk);\n\n\t/* Initialize the common base substructure.  */\n\tasoc->base.type = SCTP_EP_TYPE_ASSOCIATION;\n\n\t/* Initialize the object handling fields.  */\n\trefcount_set(&asoc->base.refcnt, 1);\n\n\t/* Initialize the bind addr area.  */\n\tsctp_bind_addr_init(&asoc->base.bind_addr, ep->base.bind_addr.port);\n\n\tasoc->state = SCTP_STATE_CLOSED;\n\tasoc->cookie_life = ms_to_ktime(sp->assocparams.sasoc_cookie_life);\n\tasoc->user_frag = sp->user_frag;\n\n\t/* Set the association max_retrans and RTO values from the\n\t * socket values.\n\t */\n\tasoc->max_retrans = sp->assocparams.sasoc_asocmaxrxt;\n\tasoc->pf_retrans  = sp->pf_retrans;\n\tasoc->ps_retrans  = sp->ps_retrans;\n\tasoc->pf_expose   = sp->pf_expose;\n\n\tasoc->rto_initial = msecs_to_jiffies(sp->rtoinfo.srto_initial);\n\tasoc->rto_max = msecs_to_jiffies(sp->rtoinfo.srto_max);\n\tasoc->rto_min = msecs_to_jiffies(sp->rtoinfo.srto_min);\n\n\t/* Initialize the association's heartbeat interval based on the\n\t * sock configured value.\n\t */\n\tasoc->hbinterval = msecs_to_jiffies(sp->hbinterval);\n\tasoc->probe_interval = msecs_to_jiffies(sp->probe_interval);\n\n\tasoc->encap_port = sp->encap_port;\n\n\t/* Initialize path max retrans value. */\n\tasoc->pathmaxrxt = sp->pathmaxrxt;\n\n\tasoc->flowlabel = sp->flowlabel;\n\tasoc->dscp = sp->dscp;\n\n\t/* Set association default SACK delay */\n\tasoc->sackdelay = msecs_to_jiffies(sp->sackdelay);\n\tasoc->sackfreq = sp->sackfreq;\n\n\t/* Set the association default flags controlling\n\t * Heartbeat, SACK delay, and Path MTU Discovery.\n\t */\n\tasoc->param_flags = sp->param_flags;\n\n\t/* Initialize the maximum number of new data packets that can be sent\n\t * in a burst.\n\t */\n\tasoc->max_burst = sp->max_burst;\n\n\tasoc->subscribe = sp->subscribe;\n\n\t/* initialize association timers */\n\tasoc->timeouts[SCTP_EVENT_TIMEOUT_T1_COOKIE] = asoc->rto_initial;\n\tasoc->timeouts[SCTP_EVENT_TIMEOUT_T1_INIT] = asoc->rto_initial;\n\tasoc->timeouts[SCTP_EVENT_TIMEOUT_T2_SHUTDOWN] = asoc->rto_initial;\n\n\t/* sctpimpguide Section 2.12.2\n\t * If the 'T5-shutdown-guard' timer is used, it SHOULD be set to the\n\t * recommended value of 5 times 'RTO.Max'.\n\t */\n\tasoc->timeouts[SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD]\n\t\t= 5 * asoc->rto_max;\n\n\tasoc->timeouts[SCTP_EVENT_TIMEOUT_SACK] = asoc->sackdelay;\n\tasoc->timeouts[SCTP_EVENT_TIMEOUT_AUTOCLOSE] = sp->autoclose * HZ;\n\n\t/* Initializes the timers */\n\tfor (i = SCTP_EVENT_TIMEOUT_NONE; i < SCTP_NUM_TIMEOUT_TYPES; ++i)\n\t\ttimer_setup(&asoc->timers[i], sctp_timer_events[i], 0);\n\n\t/* Pull default initialization values from the sock options.\n\t * Note: This assumes that the values have already been\n\t * validated in the sock.\n\t */\n\tasoc->c.sinit_max_instreams = sp->initmsg.sinit_max_instreams;\n\tasoc->c.sinit_num_ostreams  = sp->initmsg.sinit_num_ostreams;\n\tasoc->max_init_attempts\t= sp->initmsg.sinit_max_attempts;\n\n\tasoc->max_init_timeo =\n\t\t msecs_to_jiffies(sp->initmsg.sinit_max_init_timeo);\n\n\t/* Set the local window size for receive.\n\t * This is also the rcvbuf space per association.\n\t * RFC 6 - A SCTP receiver MUST be able to receive a minimum of\n\t * 1500 bytes in one SCTP packet.\n\t */\n\tif ((sk->sk_rcvbuf/2) < SCTP_DEFAULT_MINWINDOW)\n\t\tasoc->rwnd = SCTP_DEFAULT_MINWINDOW;\n\telse\n\t\tasoc->rwnd = sk->sk_rcvbuf/2;\n\n\tasoc->a_rwnd = asoc->rwnd;\n\n\t/* Use my own max window until I learn something better.  */\n\tasoc->peer.rwnd = SCTP_DEFAULT_MAXWINDOW;\n\n\t/* Initialize the receive memory counter */\n\tatomic_set(&asoc->rmem_alloc, 0);\n\n\tinit_waitqueue_head(&asoc->wait);\n\n\tasoc->c.my_vtag = sctp_generate_tag(ep);\n\tasoc->c.my_port = ep->base.bind_addr.port;\n\n\tasoc->c.initial_tsn = sctp_generate_tsn(ep);\n\n\tasoc->next_tsn = asoc->c.initial_tsn;\n\n\tasoc->ctsn_ack_point = asoc->next_tsn - 1;\n\tasoc->adv_peer_ack_point = asoc->ctsn_ack_point;\n\tasoc->highest_sacked = asoc->ctsn_ack_point;\n\tasoc->last_cwr_tsn = asoc->ctsn_ack_point;\n\n\t/* ADDIP Section 4.1 Asconf Chunk Procedures\n\t *\n\t * When an endpoint has an ASCONF signaled change to be sent to the\n\t * remote endpoint it should do the following:\n\t * ...\n\t * A2) a serial number should be assigned to the chunk. The serial\n\t * number SHOULD be a monotonically increasing number. The serial\n\t * numbers SHOULD be initialized at the start of the\n\t * association to the same value as the initial TSN.\n\t */\n\tasoc->addip_serial = asoc->c.initial_tsn;\n\tasoc->strreset_outseq = asoc->c.initial_tsn;\n\n\tINIT_LIST_HEAD(&asoc->addip_chunk_list);\n\tINIT_LIST_HEAD(&asoc->asconf_ack_list);\n\n\t/* Make an empty list of remote transport addresses.  */\n\tINIT_LIST_HEAD(&asoc->peer.transport_addr_list);\n\n\t/* RFC 2960 5.1 Normal Establishment of an Association\n\t *\n\t * After the reception of the first data chunk in an\n\t * association the endpoint must immediately respond with a\n\t * sack to acknowledge the data chunk.  Subsequent\n\t * acknowledgements should be done as described in Section\n\t * 6.2.\n\t *\n\t * [We implement this by telling a new association that it\n\t * already received one packet.]\n\t */\n\tasoc->peer.sack_needed = 1;\n\tasoc->peer.sack_generation = 1;\n\n\t/* Create an input queue.  */\n\tsctp_inq_init(&asoc->base.inqueue);\n\tsctp_inq_set_th_handler(&asoc->base.inqueue, sctp_assoc_bh_rcv);\n\n\t/* Create an output queue.  */\n\tsctp_outq_init(asoc, &asoc->outqueue);\n\n\tif (!sctp_ulpq_init(&asoc->ulpq, asoc))\n\t\tgoto fail_init;\n\n\tif (sctp_stream_init(&asoc->stream, asoc->c.sinit_num_ostreams, 0, gfp))\n\t\tgoto stream_free;\n\n\t/* Initialize default path MTU. */\n\tasoc->pathmtu = sp->pathmtu;\n\tsctp_assoc_update_frag_point(asoc);\n\n\t/* Assume that peer would support both address types unless we are\n\t * told otherwise.\n\t */\n\tasoc->peer.ipv4_address = 1;\n\tif (asoc->base.sk->sk_family == PF_INET6)\n\t\tasoc->peer.ipv6_address = 1;\n\tINIT_LIST_HEAD(&asoc->asocs);\n\n\tasoc->default_stream = sp->default_stream;\n\tasoc->default_ppid = sp->default_ppid;\n\tasoc->default_flags = sp->default_flags;\n\tasoc->default_context = sp->default_context;\n\tasoc->default_timetolive = sp->default_timetolive;\n\tasoc->default_rcv_context = sp->default_rcv_context;\n\n\t/* AUTH related initializations */\n\tINIT_LIST_HEAD(&asoc->endpoint_shared_keys);\n\tif (sctp_auth_asoc_copy_shkeys(ep, asoc, gfp))\n\t\tgoto stream_free;\n\n\tasoc->active_key_id = ep->active_key_id;\n\tasoc->strreset_enable = ep->strreset_enable;\n\n\t/* Save the hmacs and chunks list into this association */\n\tif (ep->auth_hmacs_list)\n\t\tmemcpy(asoc->c.auth_hmacs, ep->auth_hmacs_list,\n\t\t\tntohs(ep->auth_hmacs_list->param_hdr.length));\n\tif (ep->auth_chunk_list)\n\t\tmemcpy(asoc->c.auth_chunks, ep->auth_chunk_list,\n\t\t\tntohs(ep->auth_chunk_list->param_hdr.length));\n\n\t/* Get the AUTH random number for this association */\n\tp = (struct sctp_paramhdr *)asoc->c.auth_random;\n\tp->type = SCTP_PARAM_RANDOM;\n\tp->length = htons(sizeof(*p) + SCTP_AUTH_RANDOM_LENGTH);\n\tget_random_bytes(p+1, SCTP_AUTH_RANDOM_LENGTH);\n\n\treturn asoc;\n\nstream_free:\n\tsctp_stream_free(&asoc->stream);\nfail_init:\n\tsock_put(asoc->base.sk);\n\tsctp_endpoint_put(asoc->ep);\n\treturn NULL;\n}",
        "patch": "--- code before\n+++ code after\n@@ -179,9 +179,8 @@\n \tif (!sctp_ulpq_init(&asoc->ulpq, asoc))\n \t\tgoto fail_init;\n \n-\tif (sctp_stream_init(&asoc->stream, asoc->c.sinit_num_ostreams,\n-\t\t\t     0, gfp))\n-\t\tgoto fail_init;\n+\tif (sctp_stream_init(&asoc->stream, asoc->c.sinit_num_ostreams, 0, gfp))\n+\t\tgoto stream_free;\n \n \t/* Initialize default path MTU. */\n \tasoc->pathmtu = sp->pathmtu;",
        "function_modified_lines": {
            "added": [
                "\tif (sctp_stream_init(&asoc->stream, asoc->c.sinit_num_ostreams, 0, gfp))",
                "\t\tgoto stream_free;"
            ],
            "deleted": [
                "\tif (sctp_stream_init(&asoc->stream, asoc->c.sinit_num_ostreams,",
                "\t\t\t     0, gfp))",
                "\t\tgoto fail_init;"
            ]
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "A null pointer dereference issue was found in the sctp network protocol in net/sctp/stream_sched.c in Linux Kernel. If stream_in allocation is failed, stream_out is freed which would further be accessed. A local user could use this flaw to crash the system or potentially cause a denial of service.",
        "id": 3932
    },
    {
        "cve_id": "CVE-2022-1852",
        "code_before_change": "int x86_decode_emulated_instruction(struct kvm_vcpu *vcpu, int emulation_type,\n\t\t\t\t    void *insn, int insn_len)\n{\n\tint r = EMULATION_OK;\n\tstruct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;\n\n\tinit_emulate_ctxt(vcpu);\n\n\t/*\n\t * We will reenter on the same instruction since we do not set\n\t * complete_userspace_io. This does not handle watchpoints yet,\n\t * those would be handled in the emulate_ops.\n\t */\n\tif (!(emulation_type & EMULTYPE_SKIP) &&\n\t    kvm_vcpu_check_breakpoint(vcpu, &r))\n\t\treturn r;\n\n\tr = x86_decode_insn(ctxt, insn, insn_len, emulation_type);\n\n\ttrace_kvm_emulate_insn_start(vcpu);\n\t++vcpu->stat.insn_emulation;\n\n\treturn r;\n}",
        "code_after_change": "int x86_decode_emulated_instruction(struct kvm_vcpu *vcpu, int emulation_type,\n\t\t\t\t    void *insn, int insn_len)\n{\n\tstruct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;\n\tint r;\n\n\tinit_emulate_ctxt(vcpu);\n\n\tr = x86_decode_insn(ctxt, insn, insn_len, emulation_type);\n\n\ttrace_kvm_emulate_insn_start(vcpu);\n\t++vcpu->stat.insn_emulation;\n\n\treturn r;\n}",
        "patch": "--- code before\n+++ code after\n@@ -1,19 +1,10 @@\n int x86_decode_emulated_instruction(struct kvm_vcpu *vcpu, int emulation_type,\n \t\t\t\t    void *insn, int insn_len)\n {\n-\tint r = EMULATION_OK;\n \tstruct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;\n+\tint r;\n \n \tinit_emulate_ctxt(vcpu);\n-\n-\t/*\n-\t * We will reenter on the same instruction since we do not set\n-\t * complete_userspace_io. This does not handle watchpoints yet,\n-\t * those would be handled in the emulate_ops.\n-\t */\n-\tif (!(emulation_type & EMULTYPE_SKIP) &&\n-\t    kvm_vcpu_check_breakpoint(vcpu, &r))\n-\t\treturn r;\n \n \tr = x86_decode_insn(ctxt, insn, insn_len, emulation_type);\n ",
        "function_modified_lines": {
            "added": [
                "\tint r;"
            ],
            "deleted": [
                "\tint r = EMULATION_OK;",
                "",
                "\t/*",
                "\t * We will reenter on the same instruction since we do not set",
                "\t * complete_userspace_io. This does not handle watchpoints yet,",
                "\t * those would be handled in the emulate_ops.",
                "\t */",
                "\tif (!(emulation_type & EMULTYPE_SKIP) &&",
                "\t    kvm_vcpu_check_breakpoint(vcpu, &r))",
                "\t\treturn r;"
            ]
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "A NULL pointer dereference flaw was found in the Linux kernel\u2019s KVM module, which can lead to a denial of service in the x86_emulate_insn in arch/x86/kvm/emulate.c. This flaw occurs while executing an illegal instruction in guest in the Intel CPU.",
        "id": 3295
    },
    {
        "cve_id": "CVE-2020-12364",
        "code_before_change": "int intel_guc_ads_create(struct intel_guc *guc)\n{\n\tconst u32 size = PAGE_ALIGN(sizeof(struct __guc_ads_blob));\n\tint ret;\n\n\tGEM_BUG_ON(guc->ads_vma);\n\n\tret = intel_guc_allocate_and_map_vma(guc, size, &guc->ads_vma,\n\t\t\t\t\t     (void **)&guc->ads_blob);\n\n\tif (ret)\n\t\treturn ret;\n\n\t__guc_ads_init(guc);\n\n\treturn 0;\n}",
        "code_after_change": "int intel_guc_ads_create(struct intel_guc *guc)\n{\n\tu32 size;\n\tint ret;\n\n\tGEM_BUG_ON(guc->ads_vma);\n\n\tsize = guc_ads_blob_size(guc);\n\n\tret = intel_guc_allocate_and_map_vma(guc, size, &guc->ads_vma,\n\t\t\t\t\t     (void **)&guc->ads_blob);\n\tif (ret)\n\t\treturn ret;\n\n\t__guc_ads_init(guc);\n\n\treturn 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -1,13 +1,14 @@\n int intel_guc_ads_create(struct intel_guc *guc)\n {\n-\tconst u32 size = PAGE_ALIGN(sizeof(struct __guc_ads_blob));\n+\tu32 size;\n \tint ret;\n \n \tGEM_BUG_ON(guc->ads_vma);\n \n+\tsize = guc_ads_blob_size(guc);\n+\n \tret = intel_guc_allocate_and_map_vma(guc, size, &guc->ads_vma,\n \t\t\t\t\t     (void **)&guc->ads_blob);\n-\n \tif (ret)\n \t\treturn ret;\n ",
        "function_modified_lines": {
            "added": [
                "\tu32 size;",
                "\tsize = guc_ads_blob_size(guc);",
                ""
            ],
            "deleted": [
                "\tconst u32 size = PAGE_ALIGN(sizeof(struct __guc_ads_blob));",
                ""
            ]
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "Null pointer reference in some Intel(R) Graphics Drivers for Windows* before version 26.20.100.7212 and before version Linux kernel version 5.5 may allow a privileged user to potentially enable a denial of service via local access.",
        "id": 2467
    },
    {
        "cve_id": "CVE-2020-12364",
        "code_before_change": "static void guc_init_params(struct intel_guc *guc)\n{\n\tu32 *params = guc->params;\n\tint i;\n\n\tBUILD_BUG_ON(sizeof(guc->params) != GUC_CTL_MAX_DWORDS * sizeof(u32));\n\n\tparams[GUC_CTL_CTXINFO] = guc_ctl_ctxinfo_flags(guc);\n\tparams[GUC_CTL_LOG_PARAMS] = guc_ctl_log_params_flags(guc);\n\tparams[GUC_CTL_FEATURE] = guc_ctl_feature_flags(guc);\n\tparams[GUC_CTL_DEBUG] = guc_ctl_debug_flags(guc);\n\tparams[GUC_CTL_ADS] = guc_ctl_ads_flags(guc);\n\n\tfor (i = 0; i < GUC_CTL_MAX_DWORDS; i++)\n\t\tDRM_DEBUG_DRIVER(\"param[%2d] = %#x\\n\", i, params[i]);\n}",
        "code_after_change": "static void guc_init_params(struct intel_guc *guc)\n{\n\tu32 *params = guc->params;\n\tint i;\n\n\tBUILD_BUG_ON(sizeof(guc->params) != GUC_CTL_MAX_DWORDS * sizeof(u32));\n\n\tparams[GUC_CTL_LOG_PARAMS] = guc_ctl_log_params_flags(guc);\n\tparams[GUC_CTL_FEATURE] = guc_ctl_feature_flags(guc);\n\tparams[GUC_CTL_DEBUG] = guc_ctl_debug_flags(guc);\n\tparams[GUC_CTL_ADS] = guc_ctl_ads_flags(guc);\n\n\tfor (i = 0; i < GUC_CTL_MAX_DWORDS; i++)\n\t\tDRM_DEBUG_DRIVER(\"param[%2d] = %#x\\n\", i, params[i]);\n}",
        "patch": "--- code before\n+++ code after\n@@ -5,7 +5,6 @@\n \n \tBUILD_BUG_ON(sizeof(guc->params) != GUC_CTL_MAX_DWORDS * sizeof(u32));\n \n-\tparams[GUC_CTL_CTXINFO] = guc_ctl_ctxinfo_flags(guc);\n \tparams[GUC_CTL_LOG_PARAMS] = guc_ctl_log_params_flags(guc);\n \tparams[GUC_CTL_FEATURE] = guc_ctl_feature_flags(guc);\n \tparams[GUC_CTL_DEBUG] = guc_ctl_debug_flags(guc);",
        "function_modified_lines": {
            "added": [],
            "deleted": [
                "\tparams[GUC_CTL_CTXINFO] = guc_ctl_ctxinfo_flags(guc);"
            ]
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "Null pointer reference in some Intel(R) Graphics Drivers for Windows* before version 26.20.100.7212 and before version Linux kernel version 5.5 may allow a privileged user to potentially enable a denial of service via local access.",
        "id": 2465
    },
    {
        "cve_id": "CVE-2022-1205",
        "code_before_change": "void ax25_disconnect(ax25_cb *ax25, int reason)\n{\n\tax25_clear_queues(ax25);\n\n\tif (!ax25->sk || !sock_flag(ax25->sk, SOCK_DESTROY))\n\t\tax25_stop_heartbeat(ax25);\n\tax25_stop_t1timer(ax25);\n\tax25_stop_t2timer(ax25);\n\tax25_stop_t3timer(ax25);\n\tax25_stop_idletimer(ax25);\n\n\tax25->state = AX25_STATE_0;\n\n\tax25_link_failed(ax25, reason);\n\n\tif (ax25->sk != NULL) {\n\t\tlocal_bh_disable();\n\t\tbh_lock_sock(ax25->sk);\n\t\tax25->sk->sk_state     = TCP_CLOSE;\n\t\tax25->sk->sk_err       = reason;\n\t\tax25->sk->sk_shutdown |= SEND_SHUTDOWN;\n\t\tif (!sock_flag(ax25->sk, SOCK_DEAD)) {\n\t\t\tax25->sk->sk_state_change(ax25->sk);\n\t\t\tsock_set_flag(ax25->sk, SOCK_DEAD);\n\t\t}\n\t\tbh_unlock_sock(ax25->sk);\n\t\tlocal_bh_enable();\n\t}\n}",
        "code_after_change": "void ax25_disconnect(ax25_cb *ax25, int reason)\n{\n\tax25_clear_queues(ax25);\n\n\tif (reason == ENETUNREACH) {\n\t\tdel_timer_sync(&ax25->timer);\n\t\tdel_timer_sync(&ax25->t1timer);\n\t\tdel_timer_sync(&ax25->t2timer);\n\t\tdel_timer_sync(&ax25->t3timer);\n\t\tdel_timer_sync(&ax25->idletimer);\n\t} else {\n\t\tif (!ax25->sk || !sock_flag(ax25->sk, SOCK_DESTROY))\n\t\t\tax25_stop_heartbeat(ax25);\n\t\tax25_stop_t1timer(ax25);\n\t\tax25_stop_t2timer(ax25);\n\t\tax25_stop_t3timer(ax25);\n\t\tax25_stop_idletimer(ax25);\n\t}\n\n\tax25->state = AX25_STATE_0;\n\n\tax25_link_failed(ax25, reason);\n\n\tif (ax25->sk != NULL) {\n\t\tlocal_bh_disable();\n\t\tbh_lock_sock(ax25->sk);\n\t\tax25->sk->sk_state     = TCP_CLOSE;\n\t\tax25->sk->sk_err       = reason;\n\t\tax25->sk->sk_shutdown |= SEND_SHUTDOWN;\n\t\tif (!sock_flag(ax25->sk, SOCK_DEAD)) {\n\t\t\tax25->sk->sk_state_change(ax25->sk);\n\t\t\tsock_set_flag(ax25->sk, SOCK_DEAD);\n\t\t}\n\t\tbh_unlock_sock(ax25->sk);\n\t\tlocal_bh_enable();\n\t}\n}",
        "patch": "--- code before\n+++ code after\n@@ -2,12 +2,20 @@\n {\n \tax25_clear_queues(ax25);\n \n-\tif (!ax25->sk || !sock_flag(ax25->sk, SOCK_DESTROY))\n-\t\tax25_stop_heartbeat(ax25);\n-\tax25_stop_t1timer(ax25);\n-\tax25_stop_t2timer(ax25);\n-\tax25_stop_t3timer(ax25);\n-\tax25_stop_idletimer(ax25);\n+\tif (reason == ENETUNREACH) {\n+\t\tdel_timer_sync(&ax25->timer);\n+\t\tdel_timer_sync(&ax25->t1timer);\n+\t\tdel_timer_sync(&ax25->t2timer);\n+\t\tdel_timer_sync(&ax25->t3timer);\n+\t\tdel_timer_sync(&ax25->idletimer);\n+\t} else {\n+\t\tif (!ax25->sk || !sock_flag(ax25->sk, SOCK_DESTROY))\n+\t\t\tax25_stop_heartbeat(ax25);\n+\t\tax25_stop_t1timer(ax25);\n+\t\tax25_stop_t2timer(ax25);\n+\t\tax25_stop_t3timer(ax25);\n+\t\tax25_stop_idletimer(ax25);\n+\t}\n \n \tax25->state = AX25_STATE_0;\n ",
        "function_modified_lines": {
            "added": [
                "\tif (reason == ENETUNREACH) {",
                "\t\tdel_timer_sync(&ax25->timer);",
                "\t\tdel_timer_sync(&ax25->t1timer);",
                "\t\tdel_timer_sync(&ax25->t2timer);",
                "\t\tdel_timer_sync(&ax25->t3timer);",
                "\t\tdel_timer_sync(&ax25->idletimer);",
                "\t} else {",
                "\t\tif (!ax25->sk || !sock_flag(ax25->sk, SOCK_DESTROY))",
                "\t\t\tax25_stop_heartbeat(ax25);",
                "\t\tax25_stop_t1timer(ax25);",
                "\t\tax25_stop_t2timer(ax25);",
                "\t\tax25_stop_t3timer(ax25);",
                "\t\tax25_stop_idletimer(ax25);",
                "\t}"
            ],
            "deleted": [
                "\tif (!ax25->sk || !sock_flag(ax25->sk, SOCK_DESTROY))",
                "\t\tax25_stop_heartbeat(ax25);",
                "\tax25_stop_t1timer(ax25);",
                "\tax25_stop_t2timer(ax25);",
                "\tax25_stop_t3timer(ax25);",
                "\tax25_stop_idletimer(ax25);"
            ]
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "A NULL pointer dereference flaw was found in the Linux kernel\u2019s Amateur Radio AX.25 protocol functionality in the way a user connects with the protocol. This flaw allows a local user to crash the system.",
        "id": 3256
    },
    {
        "cve_id": "CVE-2016-10147",
        "code_before_change": "static int mcryptd_create_hash(struct crypto_template *tmpl, struct rtattr **tb,\n\t\t\t      struct mcryptd_queue *queue)\n{\n\tstruct hashd_instance_ctx *ctx;\n\tstruct ahash_instance *inst;\n\tstruct hash_alg_common *halg;\n\tstruct crypto_alg *alg;\n\tu32 type = 0;\n\tu32 mask = 0;\n\tint err;\n\n\tmcryptd_check_internal(tb, &type, &mask);\n\n\thalg = ahash_attr_alg(tb[1], type, mask);\n\tif (IS_ERR(halg))\n\t\treturn PTR_ERR(halg);\n\n\talg = &halg->base;\n\tpr_debug(\"crypto: mcryptd hash alg: %s\\n\", alg->cra_name);\n\tinst = mcryptd_alloc_instance(alg, ahash_instance_headroom(),\n\t\t\t\t\tsizeof(*ctx));\n\terr = PTR_ERR(inst);\n\tif (IS_ERR(inst))\n\t\tgoto out_put_alg;\n\n\tctx = ahash_instance_ctx(inst);\n\tctx->queue = queue;\n\n\terr = crypto_init_ahash_spawn(&ctx->spawn, halg,\n\t\t\t\t      ahash_crypto_instance(inst));\n\tif (err)\n\t\tgoto out_free_inst;\n\n\ttype = CRYPTO_ALG_ASYNC;\n\tif (alg->cra_flags & CRYPTO_ALG_INTERNAL)\n\t\ttype |= CRYPTO_ALG_INTERNAL;\n\tinst->alg.halg.base.cra_flags = type;\n\n\tinst->alg.halg.digestsize = halg->digestsize;\n\tinst->alg.halg.statesize = halg->statesize;\n\tinst->alg.halg.base.cra_ctxsize = sizeof(struct mcryptd_hash_ctx);\n\n\tinst->alg.halg.base.cra_init = mcryptd_hash_init_tfm;\n\tinst->alg.halg.base.cra_exit = mcryptd_hash_exit_tfm;\n\n\tinst->alg.init   = mcryptd_hash_init_enqueue;\n\tinst->alg.update = mcryptd_hash_update_enqueue;\n\tinst->alg.final  = mcryptd_hash_final_enqueue;\n\tinst->alg.finup  = mcryptd_hash_finup_enqueue;\n\tinst->alg.export = mcryptd_hash_export;\n\tinst->alg.import = mcryptd_hash_import;\n\tinst->alg.setkey = mcryptd_hash_setkey;\n\tinst->alg.digest = mcryptd_hash_digest_enqueue;\n\n\terr = ahash_register_instance(tmpl, inst);\n\tif (err) {\n\t\tcrypto_drop_ahash(&ctx->spawn);\nout_free_inst:\n\t\tkfree(inst);\n\t}\n\nout_put_alg:\n\tcrypto_mod_put(alg);\n\treturn err;\n}",
        "code_after_change": "static int mcryptd_create_hash(struct crypto_template *tmpl, struct rtattr **tb,\n\t\t\t      struct mcryptd_queue *queue)\n{\n\tstruct hashd_instance_ctx *ctx;\n\tstruct ahash_instance *inst;\n\tstruct hash_alg_common *halg;\n\tstruct crypto_alg *alg;\n\tu32 type = 0;\n\tu32 mask = 0;\n\tint err;\n\n\tif (!mcryptd_check_internal(tb, &type, &mask))\n\t\treturn -EINVAL;\n\n\thalg = ahash_attr_alg(tb[1], type, mask);\n\tif (IS_ERR(halg))\n\t\treturn PTR_ERR(halg);\n\n\talg = &halg->base;\n\tpr_debug(\"crypto: mcryptd hash alg: %s\\n\", alg->cra_name);\n\tinst = mcryptd_alloc_instance(alg, ahash_instance_headroom(),\n\t\t\t\t\tsizeof(*ctx));\n\terr = PTR_ERR(inst);\n\tif (IS_ERR(inst))\n\t\tgoto out_put_alg;\n\n\tctx = ahash_instance_ctx(inst);\n\tctx->queue = queue;\n\n\terr = crypto_init_ahash_spawn(&ctx->spawn, halg,\n\t\t\t\t      ahash_crypto_instance(inst));\n\tif (err)\n\t\tgoto out_free_inst;\n\n\ttype = CRYPTO_ALG_ASYNC;\n\tif (alg->cra_flags & CRYPTO_ALG_INTERNAL)\n\t\ttype |= CRYPTO_ALG_INTERNAL;\n\tinst->alg.halg.base.cra_flags = type;\n\n\tinst->alg.halg.digestsize = halg->digestsize;\n\tinst->alg.halg.statesize = halg->statesize;\n\tinst->alg.halg.base.cra_ctxsize = sizeof(struct mcryptd_hash_ctx);\n\n\tinst->alg.halg.base.cra_init = mcryptd_hash_init_tfm;\n\tinst->alg.halg.base.cra_exit = mcryptd_hash_exit_tfm;\n\n\tinst->alg.init   = mcryptd_hash_init_enqueue;\n\tinst->alg.update = mcryptd_hash_update_enqueue;\n\tinst->alg.final  = mcryptd_hash_final_enqueue;\n\tinst->alg.finup  = mcryptd_hash_finup_enqueue;\n\tinst->alg.export = mcryptd_hash_export;\n\tinst->alg.import = mcryptd_hash_import;\n\tinst->alg.setkey = mcryptd_hash_setkey;\n\tinst->alg.digest = mcryptd_hash_digest_enqueue;\n\n\terr = ahash_register_instance(tmpl, inst);\n\tif (err) {\n\t\tcrypto_drop_ahash(&ctx->spawn);\nout_free_inst:\n\t\tkfree(inst);\n\t}\n\nout_put_alg:\n\tcrypto_mod_put(alg);\n\treturn err;\n}",
        "patch": "--- code before\n+++ code after\n@@ -9,7 +9,8 @@\n \tu32 mask = 0;\n \tint err;\n \n-\tmcryptd_check_internal(tb, &type, &mask);\n+\tif (!mcryptd_check_internal(tb, &type, &mask))\n+\t\treturn -EINVAL;\n \n \thalg = ahash_attr_alg(tb[1], type, mask);\n \tif (IS_ERR(halg))",
        "function_modified_lines": {
            "added": [
                "\tif (!mcryptd_check_internal(tb, &type, &mask))",
                "\t\treturn -EINVAL;"
            ],
            "deleted": [
                "\tmcryptd_check_internal(tb, &type, &mask);"
            ]
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "crypto/mcryptd.c in the Linux kernel before 4.8.15 allows local users to cause a denial of service (NULL pointer dereference and system crash) by using an AF_ALG socket with an incompatible algorithm, as demonstrated by mcryptd(md5).",
        "id": 895
    },
    {
        "cve_id": "CVE-2023-3106",
        "code_before_change": "static int xfrm_dump_sa_done(struct netlink_callback *cb)\n{\n\tstruct xfrm_state_walk *walk = (struct xfrm_state_walk *) &cb->args[1];\n\tstruct sock *sk = cb->skb->sk;\n\tstruct net *net = sock_net(sk);\n\n\txfrm_state_walk_done(walk, net);\n\treturn 0;\n}",
        "code_after_change": "static int xfrm_dump_sa_done(struct netlink_callback *cb)\n{\n\tstruct xfrm_state_walk *walk = (struct xfrm_state_walk *) &cb->args[1];\n\tstruct sock *sk = cb->skb->sk;\n\tstruct net *net = sock_net(sk);\n\n\tif (cb->args[0])\n\t\txfrm_state_walk_done(walk, net);\n\treturn 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -4,6 +4,7 @@\n \tstruct sock *sk = cb->skb->sk;\n \tstruct net *net = sock_net(sk);\n \n-\txfrm_state_walk_done(walk, net);\n+\tif (cb->args[0])\n+\t\txfrm_state_walk_done(walk, net);\n \treturn 0;\n }",
        "function_modified_lines": {
            "added": [
                "\tif (cb->args[0])",
                "\t\txfrm_state_walk_done(walk, net);"
            ],
            "deleted": [
                "\txfrm_state_walk_done(walk, net);"
            ]
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "A NULL pointer dereference vulnerability was found in netlink_dump. This issue can occur when the Netlink socket receives the message(sendmsg) for the XFRM_MSG_GETSA, XFRM_MSG_GETPOLICY type message, and the DUMP flag is set and can cause a denial of service or possibly another unspecified impact. Due to the nature of the flaw, privilege escalation cannot be fully ruled out, although it is unlikely.",
        "id": 3991
    },
    {
        "cve_id": "CVE-2021-4095",
        "code_before_change": "static int kvm_xen_shared_info_init(struct kvm *kvm, gfn_t gfn)\n{\n\tstruct gfn_to_pfn_cache *gpc = &kvm->arch.xen.shinfo_cache;\n\tgpa_t gpa = gfn_to_gpa(gfn);\n\tint wc_ofs, sec_hi_ofs;\n\tint ret = 0;\n\tint idx = srcu_read_lock(&kvm->srcu);\n\n\tif (gfn == GPA_INVALID) {\n\t\tkvm_gfn_to_pfn_cache_destroy(kvm, gpc);\n\t\tgoto out;\n\t}\n\n\tret = kvm_gfn_to_pfn_cache_init(kvm, gpc, NULL, false, true, gpa,\n\t\t\t\t\tPAGE_SIZE, false);\n\tif (ret)\n\t\tgoto out;\n\n\t/* Paranoia checks on the 32-bit struct layout */\n\tBUILD_BUG_ON(offsetof(struct compat_shared_info, wc) != 0x900);\n\tBUILD_BUG_ON(offsetof(struct compat_shared_info, arch.wc_sec_hi) != 0x924);\n\tBUILD_BUG_ON(offsetof(struct pvclock_vcpu_time_info, version) != 0);\n\n\t/* 32-bit location by default */\n\twc_ofs = offsetof(struct compat_shared_info, wc);\n\tsec_hi_ofs = offsetof(struct compat_shared_info, arch.wc_sec_hi);\n\n#ifdef CONFIG_X86_64\n\t/* Paranoia checks on the 64-bit struct layout */\n\tBUILD_BUG_ON(offsetof(struct shared_info, wc) != 0xc00);\n\tBUILD_BUG_ON(offsetof(struct shared_info, wc_sec_hi) != 0xc0c);\n\n\tif (kvm->arch.xen.long_mode) {\n\t\twc_ofs = offsetof(struct shared_info, wc);\n\t\tsec_hi_ofs = offsetof(struct shared_info, wc_sec_hi);\n\t}\n#endif\n\n\tkvm_write_wall_clock(kvm, gpa + wc_ofs, sec_hi_ofs - wc_ofs);\n\tkvm_make_all_cpus_request(kvm, KVM_REQ_MASTERCLOCK_UPDATE);\n\nout:\n\tsrcu_read_unlock(&kvm->srcu, idx);\n\treturn ret;\n}",
        "code_after_change": "static int kvm_xen_shared_info_init(struct kvm *kvm, gfn_t gfn)\n{\n\tstruct gfn_to_pfn_cache *gpc = &kvm->arch.xen.shinfo_cache;\n\tstruct pvclock_wall_clock *wc;\n\tgpa_t gpa = gfn_to_gpa(gfn);\n\tu32 *wc_sec_hi;\n\tu32 wc_version;\n\tu64 wall_nsec;\n\tint ret = 0;\n\tint idx = srcu_read_lock(&kvm->srcu);\n\n\tif (gfn == GPA_INVALID) {\n\t\tkvm_gfn_to_pfn_cache_destroy(kvm, gpc);\n\t\tgoto out;\n\t}\n\n\tdo {\n\t\tret = kvm_gfn_to_pfn_cache_init(kvm, gpc, NULL, false, true,\n\t\t\t\t\t\tgpa, PAGE_SIZE, false);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * This code mirrors kvm_write_wall_clock() except that it writes\n\t\t * directly through the pfn cache and doesn't mark the page dirty.\n\t\t */\n\t\twall_nsec = ktime_get_real_ns() - get_kvmclock_ns(kvm);\n\n\t\t/* It could be invalid again already, so we need to check */\n\t\tread_lock_irq(&gpc->lock);\n\n\t\tif (gpc->valid)\n\t\t\tbreak;\n\n\t\tread_unlock_irq(&gpc->lock);\n\t} while (1);\n\n\t/* Paranoia checks on the 32-bit struct layout */\n\tBUILD_BUG_ON(offsetof(struct compat_shared_info, wc) != 0x900);\n\tBUILD_BUG_ON(offsetof(struct compat_shared_info, arch.wc_sec_hi) != 0x924);\n\tBUILD_BUG_ON(offsetof(struct pvclock_vcpu_time_info, version) != 0);\n\n#ifdef CONFIG_X86_64\n\t/* Paranoia checks on the 64-bit struct layout */\n\tBUILD_BUG_ON(offsetof(struct shared_info, wc) != 0xc00);\n\tBUILD_BUG_ON(offsetof(struct shared_info, wc_sec_hi) != 0xc0c);\n\n\tif (IS_ENABLED(CONFIG_64BIT) && kvm->arch.xen.long_mode) {\n\t\tstruct shared_info *shinfo = gpc->khva;\n\n\t\twc_sec_hi = &shinfo->wc_sec_hi;\n\t\twc = &shinfo->wc;\n\t} else\n#endif\n\t{\n\t\tstruct compat_shared_info *shinfo = gpc->khva;\n\n\t\twc_sec_hi = &shinfo->arch.wc_sec_hi;\n\t\twc = &shinfo->wc;\n\t}\n\n\t/* Increment and ensure an odd value */\n\twc_version = wc->version = (wc->version + 1) | 1;\n\tsmp_wmb();\n\n\twc->nsec = do_div(wall_nsec,  1000000000);\n\twc->sec = (u32)wall_nsec;\n\t*wc_sec_hi = wall_nsec >> 32;\n\tsmp_wmb();\n\n\twc->version = wc_version + 1;\n\tread_unlock_irq(&gpc->lock);\n\n\tkvm_make_all_cpus_request(kvm, KVM_REQ_MASTERCLOCK_UPDATE);\n\nout:\n\tsrcu_read_unlock(&kvm->srcu, idx);\n\treturn ret;\n}",
        "patch": "--- code before\n+++ code after\n@@ -1,8 +1,11 @@\n static int kvm_xen_shared_info_init(struct kvm *kvm, gfn_t gfn)\n {\n \tstruct gfn_to_pfn_cache *gpc = &kvm->arch.xen.shinfo_cache;\n+\tstruct pvclock_wall_clock *wc;\n \tgpa_t gpa = gfn_to_gpa(gfn);\n-\tint wc_ofs, sec_hi_ofs;\n+\tu32 *wc_sec_hi;\n+\tu32 wc_version;\n+\tu64 wall_nsec;\n \tint ret = 0;\n \tint idx = srcu_read_lock(&kvm->srcu);\n \n@@ -11,32 +14,63 @@\n \t\tgoto out;\n \t}\n \n-\tret = kvm_gfn_to_pfn_cache_init(kvm, gpc, NULL, false, true, gpa,\n-\t\t\t\t\tPAGE_SIZE, false);\n-\tif (ret)\n-\t\tgoto out;\n+\tdo {\n+\t\tret = kvm_gfn_to_pfn_cache_init(kvm, gpc, NULL, false, true,\n+\t\t\t\t\t\tgpa, PAGE_SIZE, false);\n+\t\tif (ret)\n+\t\t\tgoto out;\n+\n+\t\t/*\n+\t\t * This code mirrors kvm_write_wall_clock() except that it writes\n+\t\t * directly through the pfn cache and doesn't mark the page dirty.\n+\t\t */\n+\t\twall_nsec = ktime_get_real_ns() - get_kvmclock_ns(kvm);\n+\n+\t\t/* It could be invalid again already, so we need to check */\n+\t\tread_lock_irq(&gpc->lock);\n+\n+\t\tif (gpc->valid)\n+\t\t\tbreak;\n+\n+\t\tread_unlock_irq(&gpc->lock);\n+\t} while (1);\n \n \t/* Paranoia checks on the 32-bit struct layout */\n \tBUILD_BUG_ON(offsetof(struct compat_shared_info, wc) != 0x900);\n \tBUILD_BUG_ON(offsetof(struct compat_shared_info, arch.wc_sec_hi) != 0x924);\n \tBUILD_BUG_ON(offsetof(struct pvclock_vcpu_time_info, version) != 0);\n \n-\t/* 32-bit location by default */\n-\twc_ofs = offsetof(struct compat_shared_info, wc);\n-\tsec_hi_ofs = offsetof(struct compat_shared_info, arch.wc_sec_hi);\n-\n #ifdef CONFIG_X86_64\n \t/* Paranoia checks on the 64-bit struct layout */\n \tBUILD_BUG_ON(offsetof(struct shared_info, wc) != 0xc00);\n \tBUILD_BUG_ON(offsetof(struct shared_info, wc_sec_hi) != 0xc0c);\n \n-\tif (kvm->arch.xen.long_mode) {\n-\t\twc_ofs = offsetof(struct shared_info, wc);\n-\t\tsec_hi_ofs = offsetof(struct shared_info, wc_sec_hi);\n+\tif (IS_ENABLED(CONFIG_64BIT) && kvm->arch.xen.long_mode) {\n+\t\tstruct shared_info *shinfo = gpc->khva;\n+\n+\t\twc_sec_hi = &shinfo->wc_sec_hi;\n+\t\twc = &shinfo->wc;\n+\t} else\n+#endif\n+\t{\n+\t\tstruct compat_shared_info *shinfo = gpc->khva;\n+\n+\t\twc_sec_hi = &shinfo->arch.wc_sec_hi;\n+\t\twc = &shinfo->wc;\n \t}\n-#endif\n \n-\tkvm_write_wall_clock(kvm, gpa + wc_ofs, sec_hi_ofs - wc_ofs);\n+\t/* Increment and ensure an odd value */\n+\twc_version = wc->version = (wc->version + 1) | 1;\n+\tsmp_wmb();\n+\n+\twc->nsec = do_div(wall_nsec,  1000000000);\n+\twc->sec = (u32)wall_nsec;\n+\t*wc_sec_hi = wall_nsec >> 32;\n+\tsmp_wmb();\n+\n+\twc->version = wc_version + 1;\n+\tread_unlock_irq(&gpc->lock);\n+\n \tkvm_make_all_cpus_request(kvm, KVM_REQ_MASTERCLOCK_UPDATE);\n \n out:",
        "function_modified_lines": {
            "added": [
                "\tstruct pvclock_wall_clock *wc;",
                "\tu32 *wc_sec_hi;",
                "\tu32 wc_version;",
                "\tu64 wall_nsec;",
                "\tdo {",
                "\t\tret = kvm_gfn_to_pfn_cache_init(kvm, gpc, NULL, false, true,",
                "\t\t\t\t\t\tgpa, PAGE_SIZE, false);",
                "\t\tif (ret)",
                "\t\t\tgoto out;",
                "",
                "\t\t/*",
                "\t\t * This code mirrors kvm_write_wall_clock() except that it writes",
                "\t\t * directly through the pfn cache and doesn't mark the page dirty.",
                "\t\t */",
                "\t\twall_nsec = ktime_get_real_ns() - get_kvmclock_ns(kvm);",
                "",
                "\t\t/* It could be invalid again already, so we need to check */",
                "\t\tread_lock_irq(&gpc->lock);",
                "",
                "\t\tif (gpc->valid)",
                "\t\t\tbreak;",
                "",
                "\t\tread_unlock_irq(&gpc->lock);",
                "\t} while (1);",
                "\tif (IS_ENABLED(CONFIG_64BIT) && kvm->arch.xen.long_mode) {",
                "\t\tstruct shared_info *shinfo = gpc->khva;",
                "",
                "\t\twc_sec_hi = &shinfo->wc_sec_hi;",
                "\t\twc = &shinfo->wc;",
                "\t} else",
                "#endif",
                "\t{",
                "\t\tstruct compat_shared_info *shinfo = gpc->khva;",
                "",
                "\t\twc_sec_hi = &shinfo->arch.wc_sec_hi;",
                "\t\twc = &shinfo->wc;",
                "\t/* Increment and ensure an odd value */",
                "\twc_version = wc->version = (wc->version + 1) | 1;",
                "\tsmp_wmb();",
                "",
                "\twc->nsec = do_div(wall_nsec,  1000000000);",
                "\twc->sec = (u32)wall_nsec;",
                "\t*wc_sec_hi = wall_nsec >> 32;",
                "\tsmp_wmb();",
                "",
                "\twc->version = wc_version + 1;",
                "\tread_unlock_irq(&gpc->lock);",
                ""
            ],
            "deleted": [
                "\tint wc_ofs, sec_hi_ofs;",
                "\tret = kvm_gfn_to_pfn_cache_init(kvm, gpc, NULL, false, true, gpa,",
                "\t\t\t\t\tPAGE_SIZE, false);",
                "\tif (ret)",
                "\t\tgoto out;",
                "\t/* 32-bit location by default */",
                "\twc_ofs = offsetof(struct compat_shared_info, wc);",
                "\tsec_hi_ofs = offsetof(struct compat_shared_info, arch.wc_sec_hi);",
                "",
                "\tif (kvm->arch.xen.long_mode) {",
                "\t\twc_ofs = offsetof(struct shared_info, wc);",
                "\t\tsec_hi_ofs = offsetof(struct shared_info, wc_sec_hi);",
                "#endif",
                "\tkvm_write_wall_clock(kvm, gpa + wc_ofs, sec_hi_ofs - wc_ofs);"
            ]
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "A NULL pointer dereference was found in the Linux kernel's KVM when dirty ring logging is enabled without an active vCPU context. An unprivileged local attacker on the host may use this flaw to cause a kernel oops condition and thus a denial of service by issuing a KVM_XEN_HVM_SET_ATTR ioctl. This flaw affects Linux kernel versions prior to 5.17-rc1.",
        "id": 3133
    },
    {
        "cve_id": "CVE-2017-16647",
        "code_before_change": "static int asix_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\tstruct usbnet *dev = usb_get_intfdata(intf);\n\tstruct asix_common_private *priv = dev->driver_priv;\n\n\tif (priv->suspend)\n\t\tpriv->suspend(dev);\n\n\treturn usbnet_suspend(intf, message);\n}",
        "code_after_change": "static int asix_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\tstruct usbnet *dev = usb_get_intfdata(intf);\n\tstruct asix_common_private *priv = dev->driver_priv;\n\n\tif (priv && priv->suspend)\n\t\tpriv->suspend(dev);\n\n\treturn usbnet_suspend(intf, message);\n}",
        "patch": "--- code before\n+++ code after\n@@ -3,7 +3,7 @@\n \tstruct usbnet *dev = usb_get_intfdata(intf);\n \tstruct asix_common_private *priv = dev->driver_priv;\n \n-\tif (priv->suspend)\n+\tif (priv && priv->suspend)\n \t\tpriv->suspend(dev);\n \n \treturn usbnet_suspend(intf, message);",
        "function_modified_lines": {
            "added": [
                "\tif (priv && priv->suspend)"
            ],
            "deleted": [
                "\tif (priv->suspend)"
            ]
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "drivers/net/usb/asix_devices.c in the Linux kernel through 4.13.11 allows local users to cause a denial of service (NULL pointer dereference and system crash) or possibly have unspecified other impact via a crafted USB device.",
        "id": 1340
    },
    {
        "cve_id": "CVE-2017-18216",
        "code_before_change": "static struct o2nm_cluster *to_o2nm_cluster_from_node(struct o2nm_node *node)\n{\n\t/* through the first node_set .parent\n\t * mycluster/nodes/mynode == o2nm_cluster->o2nm_node_group->o2nm_node */\n\treturn to_o2nm_cluster(node->nd_item.ci_parent->ci_parent);\n}",
        "code_after_change": "static struct o2nm_cluster *to_o2nm_cluster_from_node(struct o2nm_node *node)\n{\n\t/* through the first node_set .parent\n\t * mycluster/nodes/mynode == o2nm_cluster->o2nm_node_group->o2nm_node */\n\tif (node->nd_item.ci_parent)\n\t\treturn to_o2nm_cluster(node->nd_item.ci_parent->ci_parent);\n\telse\n\t\treturn NULL;\n}",
        "patch": "--- code before\n+++ code after\n@@ -2,5 +2,8 @@\n {\n \t/* through the first node_set .parent\n \t * mycluster/nodes/mynode == o2nm_cluster->o2nm_node_group->o2nm_node */\n-\treturn to_o2nm_cluster(node->nd_item.ci_parent->ci_parent);\n+\tif (node->nd_item.ci_parent)\n+\t\treturn to_o2nm_cluster(node->nd_item.ci_parent->ci_parent);\n+\telse\n+\t\treturn NULL;\n }",
        "function_modified_lines": {
            "added": [
                "\tif (node->nd_item.ci_parent)",
                "\t\treturn to_o2nm_cluster(node->nd_item.ci_parent->ci_parent);",
                "\telse",
                "\t\treturn NULL;"
            ],
            "deleted": [
                "\treturn to_o2nm_cluster(node->nd_item.ci_parent->ci_parent);"
            ]
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "In fs/ocfs2/cluster/nodemanager.c in the Linux kernel before 4.15, local users can cause a denial of service (NULL pointer dereference and BUG) because a required mutex is not used.",
        "id": 1403
    },
    {
        "cve_id": "CVE-2017-7374",
        "code_before_change": "static int validate_user_key(struct fscrypt_info *crypt_info,\n\t\t\tstruct fscrypt_context *ctx, u8 *raw_key,\n\t\t\tconst char *prefix)\n{\n\tchar *description;\n\tstruct key *keyring_key;\n\tstruct fscrypt_key *master_key;\n\tconst struct user_key_payload *ukp;\n\tint res;\n\n\tdescription = kasprintf(GFP_NOFS, \"%s%*phN\", prefix,\n\t\t\t\tFS_KEY_DESCRIPTOR_SIZE,\n\t\t\t\tctx->master_key_descriptor);\n\tif (!description)\n\t\treturn -ENOMEM;\n\n\tkeyring_key = request_key(&key_type_logon, description, NULL);\n\tkfree(description);\n\tif (IS_ERR(keyring_key))\n\t\treturn PTR_ERR(keyring_key);\n\n\tif (keyring_key->type != &key_type_logon) {\n\t\tprintk_once(KERN_WARNING\n\t\t\t\t\"%s: key type must be logon\\n\", __func__);\n\t\tres = -ENOKEY;\n\t\tgoto out;\n\t}\n\tdown_read(&keyring_key->sem);\n\tukp = user_key_payload(keyring_key);\n\tif (ukp->datalen != sizeof(struct fscrypt_key)) {\n\t\tres = -EINVAL;\n\t\tup_read(&keyring_key->sem);\n\t\tgoto out;\n\t}\n\tmaster_key = (struct fscrypt_key *)ukp->data;\n\tBUILD_BUG_ON(FS_AES_128_ECB_KEY_SIZE != FS_KEY_DERIVATION_NONCE_SIZE);\n\n\tif (master_key->size != FS_AES_256_XTS_KEY_SIZE) {\n\t\tprintk_once(KERN_WARNING\n\t\t\t\t\"%s: key size incorrect: %d\\n\",\n\t\t\t\t__func__, master_key->size);\n\t\tres = -ENOKEY;\n\t\tup_read(&keyring_key->sem);\n\t\tgoto out;\n\t}\n\tres = derive_key_aes(ctx->nonce, master_key->raw, raw_key);\n\tup_read(&keyring_key->sem);\n\tif (res)\n\t\tgoto out;\n\n\tcrypt_info->ci_keyring_key = keyring_key;\n\treturn 0;\nout:\n\tkey_put(keyring_key);\n\treturn res;\n}",
        "code_after_change": "static int validate_user_key(struct fscrypt_info *crypt_info,\n\t\t\tstruct fscrypt_context *ctx, u8 *raw_key,\n\t\t\tconst char *prefix)\n{\n\tchar *description;\n\tstruct key *keyring_key;\n\tstruct fscrypt_key *master_key;\n\tconst struct user_key_payload *ukp;\n\tint res;\n\n\tdescription = kasprintf(GFP_NOFS, \"%s%*phN\", prefix,\n\t\t\t\tFS_KEY_DESCRIPTOR_SIZE,\n\t\t\t\tctx->master_key_descriptor);\n\tif (!description)\n\t\treturn -ENOMEM;\n\n\tkeyring_key = request_key(&key_type_logon, description, NULL);\n\tkfree(description);\n\tif (IS_ERR(keyring_key))\n\t\treturn PTR_ERR(keyring_key);\n\tdown_read(&keyring_key->sem);\n\n\tif (keyring_key->type != &key_type_logon) {\n\t\tprintk_once(KERN_WARNING\n\t\t\t\t\"%s: key type must be logon\\n\", __func__);\n\t\tres = -ENOKEY;\n\t\tgoto out;\n\t}\n\tukp = user_key_payload(keyring_key);\n\tif (ukp->datalen != sizeof(struct fscrypt_key)) {\n\t\tres = -EINVAL;\n\t\tgoto out;\n\t}\n\tmaster_key = (struct fscrypt_key *)ukp->data;\n\tBUILD_BUG_ON(FS_AES_128_ECB_KEY_SIZE != FS_KEY_DERIVATION_NONCE_SIZE);\n\n\tif (master_key->size != FS_AES_256_XTS_KEY_SIZE) {\n\t\tprintk_once(KERN_WARNING\n\t\t\t\t\"%s: key size incorrect: %d\\n\",\n\t\t\t\t__func__, master_key->size);\n\t\tres = -ENOKEY;\n\t\tgoto out;\n\t}\n\tres = derive_key_aes(ctx->nonce, master_key->raw, raw_key);\nout:\n\tup_read(&keyring_key->sem);\n\tkey_put(keyring_key);\n\treturn res;\n}",
        "patch": "--- code before\n+++ code after\n@@ -18,6 +18,7 @@\n \tkfree(description);\n \tif (IS_ERR(keyring_key))\n \t\treturn PTR_ERR(keyring_key);\n+\tdown_read(&keyring_key->sem);\n \n \tif (keyring_key->type != &key_type_logon) {\n \t\tprintk_once(KERN_WARNING\n@@ -25,11 +26,9 @@\n \t\tres = -ENOKEY;\n \t\tgoto out;\n \t}\n-\tdown_read(&keyring_key->sem);\n \tukp = user_key_payload(keyring_key);\n \tif (ukp->datalen != sizeof(struct fscrypt_key)) {\n \t\tres = -EINVAL;\n-\t\tup_read(&keyring_key->sem);\n \t\tgoto out;\n \t}\n \tmaster_key = (struct fscrypt_key *)ukp->data;\n@@ -40,17 +39,11 @@\n \t\t\t\t\"%s: key size incorrect: %d\\n\",\n \t\t\t\t__func__, master_key->size);\n \t\tres = -ENOKEY;\n-\t\tup_read(&keyring_key->sem);\n \t\tgoto out;\n \t}\n \tres = derive_key_aes(ctx->nonce, master_key->raw, raw_key);\n+out:\n \tup_read(&keyring_key->sem);\n-\tif (res)\n-\t\tgoto out;\n-\n-\tcrypt_info->ci_keyring_key = keyring_key;\n-\treturn 0;\n-out:\n \tkey_put(keyring_key);\n \treturn res;\n }",
        "function_modified_lines": {
            "added": [
                "\tdown_read(&keyring_key->sem);",
                "out:"
            ],
            "deleted": [
                "\tdown_read(&keyring_key->sem);",
                "\t\tup_read(&keyring_key->sem);",
                "\t\tup_read(&keyring_key->sem);",
                "\tif (res)",
                "\t\tgoto out;",
                "",
                "\tcrypt_info->ci_keyring_key = keyring_key;",
                "\treturn 0;",
                "out:"
            ]
        },
        "cwe": [
            "CWE-476",
            "CWE-416"
        ],
        "cve_description": "Use-after-free vulnerability in fs/crypto/ in the Linux kernel before 4.10.7 allows local users to cause a denial of service (NULL pointer dereference) or possibly gain privileges by revoking keyring keys being used for ext4, f2fs, or ubifs encryption, causing cryptographic transform objects to be freed prematurely.",
        "id": 1500
    },
    {
        "cve_id": "CVE-2017-7374",
        "code_before_change": "static int fscrypt_d_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tstruct dentry *dir;\n\tstruct fscrypt_info *ci;\n\tint dir_has_key, cached_with_key;\n\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\tdir = dget_parent(dentry);\n\tif (!d_inode(dir)->i_sb->s_cop->is_encrypted(d_inode(dir))) {\n\t\tdput(dir);\n\t\treturn 0;\n\t}\n\n\tci = d_inode(dir)->i_crypt_info;\n\tif (ci && ci->ci_keyring_key &&\n\t    (ci->ci_keyring_key->flags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t\t\t  (1 << KEY_FLAG_REVOKED) |\n\t\t\t\t\t  (1 << KEY_FLAG_DEAD))))\n\t\tci = NULL;\n\n\t/* this should eventually be an flag in d_flags */\n\tspin_lock(&dentry->d_lock);\n\tcached_with_key = dentry->d_flags & DCACHE_ENCRYPTED_WITH_KEY;\n\tspin_unlock(&dentry->d_lock);\n\tdir_has_key = (ci != NULL);\n\tdput(dir);\n\n\t/*\n\t * If the dentry was cached without the key, and it is a\n\t * negative dentry, it might be a valid name.  We can't check\n\t * if the key has since been made available due to locking\n\t * reasons, so we fail the validation so ext4_lookup() can do\n\t * this check.\n\t *\n\t * We also fail the validation if the dentry was created with\n\t * the key present, but we no longer have the key, or vice versa.\n\t */\n\tif ((!cached_with_key && d_is_negative(dentry)) ||\n\t\t\t(!cached_with_key && dir_has_key) ||\n\t\t\t(cached_with_key && !dir_has_key))\n\t\treturn 0;\n\treturn 1;\n}",
        "code_after_change": "static int fscrypt_d_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tstruct dentry *dir;\n\tint dir_has_key, cached_with_key;\n\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\tdir = dget_parent(dentry);\n\tif (!d_inode(dir)->i_sb->s_cop->is_encrypted(d_inode(dir))) {\n\t\tdput(dir);\n\t\treturn 0;\n\t}\n\n\t/* this should eventually be an flag in d_flags */\n\tspin_lock(&dentry->d_lock);\n\tcached_with_key = dentry->d_flags & DCACHE_ENCRYPTED_WITH_KEY;\n\tspin_unlock(&dentry->d_lock);\n\tdir_has_key = (d_inode(dir)->i_crypt_info != NULL);\n\tdput(dir);\n\n\t/*\n\t * If the dentry was cached without the key, and it is a\n\t * negative dentry, it might be a valid name.  We can't check\n\t * if the key has since been made available due to locking\n\t * reasons, so we fail the validation so ext4_lookup() can do\n\t * this check.\n\t *\n\t * We also fail the validation if the dentry was created with\n\t * the key present, but we no longer have the key, or vice versa.\n\t */\n\tif ((!cached_with_key && d_is_negative(dentry)) ||\n\t\t\t(!cached_with_key && dir_has_key) ||\n\t\t\t(cached_with_key && !dir_has_key))\n\t\treturn 0;\n\treturn 1;\n}",
        "patch": "--- code before\n+++ code after\n@@ -1,7 +1,6 @@\n static int fscrypt_d_revalidate(struct dentry *dentry, unsigned int flags)\n {\n \tstruct dentry *dir;\n-\tstruct fscrypt_info *ci;\n \tint dir_has_key, cached_with_key;\n \n \tif (flags & LOOKUP_RCU)\n@@ -13,18 +12,11 @@\n \t\treturn 0;\n \t}\n \n-\tci = d_inode(dir)->i_crypt_info;\n-\tif (ci && ci->ci_keyring_key &&\n-\t    (ci->ci_keyring_key->flags & ((1 << KEY_FLAG_INVALIDATED) |\n-\t\t\t\t\t  (1 << KEY_FLAG_REVOKED) |\n-\t\t\t\t\t  (1 << KEY_FLAG_DEAD))))\n-\t\tci = NULL;\n-\n \t/* this should eventually be an flag in d_flags */\n \tspin_lock(&dentry->d_lock);\n \tcached_with_key = dentry->d_flags & DCACHE_ENCRYPTED_WITH_KEY;\n \tspin_unlock(&dentry->d_lock);\n-\tdir_has_key = (ci != NULL);\n+\tdir_has_key = (d_inode(dir)->i_crypt_info != NULL);\n \tdput(dir);\n \n \t/*",
        "function_modified_lines": {
            "added": [
                "\tdir_has_key = (d_inode(dir)->i_crypt_info != NULL);"
            ],
            "deleted": [
                "\tstruct fscrypt_info *ci;",
                "\tci = d_inode(dir)->i_crypt_info;",
                "\tif (ci && ci->ci_keyring_key &&",
                "\t    (ci->ci_keyring_key->flags & ((1 << KEY_FLAG_INVALIDATED) |",
                "\t\t\t\t\t  (1 << KEY_FLAG_REVOKED) |",
                "\t\t\t\t\t  (1 << KEY_FLAG_DEAD))))",
                "\t\tci = NULL;",
                "",
                "\tdir_has_key = (ci != NULL);"
            ]
        },
        "cwe": [
            "CWE-476",
            "CWE-416"
        ],
        "cve_description": "Use-after-free vulnerability in fs/crypto/ in the Linux kernel before 4.10.7 allows local users to cause a denial of service (NULL pointer dereference) or possibly gain privileges by revoking keyring keys being used for ext4, f2fs, or ubifs encryption, causing cryptographic transform objects to be freed prematurely.",
        "id": 1497
    },
    {
        "cve_id": "CVE-2017-7374",
        "code_before_change": "int fscrypt_setup_filename(struct inode *dir, const struct qstr *iname,\n\t\t\t      int lookup, struct fscrypt_name *fname)\n{\n\tint ret = 0, bigname = 0;\n\n\tmemset(fname, 0, sizeof(struct fscrypt_name));\n\tfname->usr_fname = iname;\n\n\tif (!dir->i_sb->s_cop->is_encrypted(dir) ||\n\t\t\t\tfscrypt_is_dot_dotdot(iname)) {\n\t\tfname->disk_name.name = (unsigned char *)iname->name;\n\t\tfname->disk_name.len = iname->len;\n\t\treturn 0;\n\t}\n\tret = fscrypt_get_crypt_info(dir);\n\tif (ret && ret != -EOPNOTSUPP)\n\t\treturn ret;\n\n\tif (dir->i_crypt_info) {\n\t\tret = fscrypt_fname_alloc_buffer(dir, iname->len,\n\t\t\t\t\t\t\t&fname->crypto_buf);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = fname_encrypt(dir, iname, &fname->crypto_buf);\n\t\tif (ret)\n\t\t\tgoto errout;\n\t\tfname->disk_name.name = fname->crypto_buf.name;\n\t\tfname->disk_name.len = fname->crypto_buf.len;\n\t\treturn 0;\n\t}\n\tif (!lookup)\n\t\treturn -ENOKEY;\n\n\t/*\n\t * We don't have the key and we are doing a lookup; decode the\n\t * user-supplied name\n\t */\n\tif (iname->name[0] == '_')\n\t\tbigname = 1;\n\tif ((bigname && (iname->len != 33)) || (!bigname && (iname->len > 43)))\n\t\treturn -ENOENT;\n\n\tfname->crypto_buf.name = kmalloc(32, GFP_KERNEL);\n\tif (fname->crypto_buf.name == NULL)\n\t\treturn -ENOMEM;\n\n\tret = digest_decode(iname->name + bigname, iname->len - bigname,\n\t\t\t\tfname->crypto_buf.name);\n\tif (ret < 0) {\n\t\tret = -ENOENT;\n\t\tgoto errout;\n\t}\n\tfname->crypto_buf.len = ret;\n\tif (bigname) {\n\t\tmemcpy(&fname->hash, fname->crypto_buf.name, 4);\n\t\tmemcpy(&fname->minor_hash, fname->crypto_buf.name + 4, 4);\n\t} else {\n\t\tfname->disk_name.name = fname->crypto_buf.name;\n\t\tfname->disk_name.len = fname->crypto_buf.len;\n\t}\n\treturn 0;\n\nerrout:\n\tfscrypt_fname_free_buffer(&fname->crypto_buf);\n\treturn ret;\n}",
        "code_after_change": "int fscrypt_setup_filename(struct inode *dir, const struct qstr *iname,\n\t\t\t      int lookup, struct fscrypt_name *fname)\n{\n\tint ret = 0, bigname = 0;\n\n\tmemset(fname, 0, sizeof(struct fscrypt_name));\n\tfname->usr_fname = iname;\n\n\tif (!dir->i_sb->s_cop->is_encrypted(dir) ||\n\t\t\t\tfscrypt_is_dot_dotdot(iname)) {\n\t\tfname->disk_name.name = (unsigned char *)iname->name;\n\t\tfname->disk_name.len = iname->len;\n\t\treturn 0;\n\t}\n\tret = fscrypt_get_encryption_info(dir);\n\tif (ret && ret != -EOPNOTSUPP)\n\t\treturn ret;\n\n\tif (dir->i_crypt_info) {\n\t\tret = fscrypt_fname_alloc_buffer(dir, iname->len,\n\t\t\t\t\t\t\t&fname->crypto_buf);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = fname_encrypt(dir, iname, &fname->crypto_buf);\n\t\tif (ret)\n\t\t\tgoto errout;\n\t\tfname->disk_name.name = fname->crypto_buf.name;\n\t\tfname->disk_name.len = fname->crypto_buf.len;\n\t\treturn 0;\n\t}\n\tif (!lookup)\n\t\treturn -ENOKEY;\n\n\t/*\n\t * We don't have the key and we are doing a lookup; decode the\n\t * user-supplied name\n\t */\n\tif (iname->name[0] == '_')\n\t\tbigname = 1;\n\tif ((bigname && (iname->len != 33)) || (!bigname && (iname->len > 43)))\n\t\treturn -ENOENT;\n\n\tfname->crypto_buf.name = kmalloc(32, GFP_KERNEL);\n\tif (fname->crypto_buf.name == NULL)\n\t\treturn -ENOMEM;\n\n\tret = digest_decode(iname->name + bigname, iname->len - bigname,\n\t\t\t\tfname->crypto_buf.name);\n\tif (ret < 0) {\n\t\tret = -ENOENT;\n\t\tgoto errout;\n\t}\n\tfname->crypto_buf.len = ret;\n\tif (bigname) {\n\t\tmemcpy(&fname->hash, fname->crypto_buf.name, 4);\n\t\tmemcpy(&fname->minor_hash, fname->crypto_buf.name + 4, 4);\n\t} else {\n\t\tfname->disk_name.name = fname->crypto_buf.name;\n\t\tfname->disk_name.len = fname->crypto_buf.len;\n\t}\n\treturn 0;\n\nerrout:\n\tfscrypt_fname_free_buffer(&fname->crypto_buf);\n\treturn ret;\n}",
        "patch": "--- code before\n+++ code after\n@@ -12,7 +12,7 @@\n \t\tfname->disk_name.len = iname->len;\n \t\treturn 0;\n \t}\n-\tret = fscrypt_get_crypt_info(dir);\n+\tret = fscrypt_get_encryption_info(dir);\n \tif (ret && ret != -EOPNOTSUPP)\n \t\treturn ret;\n ",
        "function_modified_lines": {
            "added": [
                "\tret = fscrypt_get_encryption_info(dir);"
            ],
            "deleted": [
                "\tret = fscrypt_get_crypt_info(dir);"
            ]
        },
        "cwe": [
            "CWE-476",
            "CWE-416"
        ],
        "cve_description": "Use-after-free vulnerability in fs/crypto/ in the Linux kernel before 4.10.7 allows local users to cause a denial of service (NULL pointer dereference) or possibly gain privileges by revoking keyring keys being used for ext4, f2fs, or ubifs encryption, causing cryptographic transform objects to be freed prematurely.",
        "id": 1498
    },
    {
        "cve_id": "CVE-2023-22997",
        "code_before_change": "static ssize_t module_gzip_decompress(struct load_info *info,\n\t\t\t\t      const void *buf, size_t size)\n{\n\tstruct z_stream_s s = { 0 };\n\tsize_t new_size = 0;\n\tsize_t gzip_hdr_len;\n\tssize_t retval;\n\tint rc;\n\n\tgzip_hdr_len = module_gzip_header_len(buf, size);\n\tif (!gzip_hdr_len) {\n\t\tpr_err(\"not a gzip compressed module\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ts.next_in = buf + gzip_hdr_len;\n\ts.avail_in = size - gzip_hdr_len;\n\n\ts.workspace = kmalloc(zlib_inflate_workspacesize(), GFP_KERNEL);\n\tif (!s.workspace)\n\t\treturn -ENOMEM;\n\n\trc = zlib_inflateInit2(&s, -MAX_WBITS);\n\tif (rc != Z_OK) {\n\t\tpr_err(\"failed to initialize decompressor: %d\\n\", rc);\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tdo {\n\t\tstruct page *page = module_get_next_page(info);\n\n\t\tif (!page) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto out_inflate_end;\n\t\t}\n\n\t\ts.next_out = kmap_local_page(page);\n\t\ts.avail_out = PAGE_SIZE;\n\t\trc = zlib_inflate(&s, 0);\n\t\tkunmap_local(s.next_out);\n\n\t\tnew_size += PAGE_SIZE - s.avail_out;\n\t} while (rc == Z_OK);\n\n\tif (rc != Z_STREAM_END) {\n\t\tpr_err(\"decompression failed with status %d\\n\", rc);\n\t\tretval = -EINVAL;\n\t\tgoto out_inflate_end;\n\t}\n\n\tretval = new_size;\n\nout_inflate_end:\n\tzlib_inflateEnd(&s);\nout:\n\tkfree(s.workspace);\n\treturn retval;\n}",
        "code_after_change": "static ssize_t module_gzip_decompress(struct load_info *info,\n\t\t\t\t      const void *buf, size_t size)\n{\n\tstruct z_stream_s s = { 0 };\n\tsize_t new_size = 0;\n\tsize_t gzip_hdr_len;\n\tssize_t retval;\n\tint rc;\n\n\tgzip_hdr_len = module_gzip_header_len(buf, size);\n\tif (!gzip_hdr_len) {\n\t\tpr_err(\"not a gzip compressed module\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ts.next_in = buf + gzip_hdr_len;\n\ts.avail_in = size - gzip_hdr_len;\n\n\ts.workspace = kmalloc(zlib_inflate_workspacesize(), GFP_KERNEL);\n\tif (!s.workspace)\n\t\treturn -ENOMEM;\n\n\trc = zlib_inflateInit2(&s, -MAX_WBITS);\n\tif (rc != Z_OK) {\n\t\tpr_err(\"failed to initialize decompressor: %d\\n\", rc);\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tdo {\n\t\tstruct page *page = module_get_next_page(info);\n\n\t\tif (IS_ERR(page)) {\n\t\t\tretval = PTR_ERR(page);\n\t\t\tgoto out_inflate_end;\n\t\t}\n\n\t\ts.next_out = kmap_local_page(page);\n\t\ts.avail_out = PAGE_SIZE;\n\t\trc = zlib_inflate(&s, 0);\n\t\tkunmap_local(s.next_out);\n\n\t\tnew_size += PAGE_SIZE - s.avail_out;\n\t} while (rc == Z_OK);\n\n\tif (rc != Z_STREAM_END) {\n\t\tpr_err(\"decompression failed with status %d\\n\", rc);\n\t\tretval = -EINVAL;\n\t\tgoto out_inflate_end;\n\t}\n\n\tretval = new_size;\n\nout_inflate_end:\n\tzlib_inflateEnd(&s);\nout:\n\tkfree(s.workspace);\n\treturn retval;\n}",
        "patch": "--- code before\n+++ code after\n@@ -30,8 +30,8 @@\n \tdo {\n \t\tstruct page *page = module_get_next_page(info);\n \n-\t\tif (!page) {\n-\t\t\tretval = -ENOMEM;\n+\t\tif (IS_ERR(page)) {\n+\t\t\tretval = PTR_ERR(page);\n \t\t\tgoto out_inflate_end;\n \t\t}\n ",
        "function_modified_lines": {
            "added": [
                "\t\tif (IS_ERR(page)) {",
                "\t\t\tretval = PTR_ERR(page);"
            ],
            "deleted": [
                "\t\tif (!page) {",
                "\t\t\tretval = -ENOMEM;"
            ]
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "In the Linux kernel before 6.1.2, kernel/module/decompress.c misinterprets the module_get_next_page return value (expects it to be NULL in the error case, whereas it is actually an error pointer).",
        "id": 3939
    },
    {
        "cve_id": "CVE-2018-14616",
        "code_before_change": "static struct bio *f2fs_grab_read_bio(struct inode *inode, block_t blkaddr,\n\t\t\t\t\tunsigned nr_pages, unsigned op_flag)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct bio *bio;\n\tstruct bio_post_read_ctx *ctx;\n\tunsigned int post_read_steps = 0;\n\n\tbio = f2fs_bio_alloc(sbi, min_t(int, nr_pages, BIO_MAX_PAGES), false);\n\tif (!bio)\n\t\treturn ERR_PTR(-ENOMEM);\n\tf2fs_target_device(sbi, blkaddr, bio);\n\tbio->bi_end_io = f2fs_read_end_io;\n\tbio_set_op_attrs(bio, REQ_OP_READ, op_flag);\n\n\tif (f2fs_encrypted_file(inode))\n\t\tpost_read_steps |= 1 << STEP_DECRYPT;\n\tif (post_read_steps) {\n\t\tctx = mempool_alloc(bio_post_read_ctx_pool, GFP_NOFS);\n\t\tif (!ctx) {\n\t\t\tbio_put(bio);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t\tctx->bio = bio;\n\t\tctx->enabled_steps = post_read_steps;\n\t\tbio->bi_private = ctx;\n\n\t\t/* wait the page to be moved by cleaning */\n\t\tf2fs_wait_on_block_writeback(sbi, blkaddr);\n\t}\n\n\treturn bio;\n}",
        "code_after_change": "static struct bio *f2fs_grab_read_bio(struct inode *inode, block_t blkaddr,\n\t\t\t\t\tunsigned nr_pages, unsigned op_flag)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct bio *bio;\n\tstruct bio_post_read_ctx *ctx;\n\tunsigned int post_read_steps = 0;\n\n\tif (!f2fs_is_valid_blkaddr(sbi, blkaddr, DATA_GENERIC))\n\t\treturn ERR_PTR(-EFAULT);\n\n\tbio = f2fs_bio_alloc(sbi, min_t(int, nr_pages, BIO_MAX_PAGES), false);\n\tif (!bio)\n\t\treturn ERR_PTR(-ENOMEM);\n\tf2fs_target_device(sbi, blkaddr, bio);\n\tbio->bi_end_io = f2fs_read_end_io;\n\tbio_set_op_attrs(bio, REQ_OP_READ, op_flag);\n\n\tif (f2fs_encrypted_file(inode))\n\t\tpost_read_steps |= 1 << STEP_DECRYPT;\n\tif (post_read_steps) {\n\t\tctx = mempool_alloc(bio_post_read_ctx_pool, GFP_NOFS);\n\t\tif (!ctx) {\n\t\t\tbio_put(bio);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t\tctx->bio = bio;\n\t\tctx->enabled_steps = post_read_steps;\n\t\tbio->bi_private = ctx;\n\n\t\t/* wait the page to be moved by cleaning */\n\t\tf2fs_wait_on_block_writeback(sbi, blkaddr);\n\t}\n\n\treturn bio;\n}",
        "patch": "--- code before\n+++ code after\n@@ -5,6 +5,9 @@\n \tstruct bio *bio;\n \tstruct bio_post_read_ctx *ctx;\n \tunsigned int post_read_steps = 0;\n+\n+\tif (!f2fs_is_valid_blkaddr(sbi, blkaddr, DATA_GENERIC))\n+\t\treturn ERR_PTR(-EFAULT);\n \n \tbio = f2fs_bio_alloc(sbi, min_t(int, nr_pages, BIO_MAX_PAGES), false);\n \tif (!bio)",
        "function_modified_lines": {
            "added": [
                "",
                "\tif (!f2fs_is_valid_blkaddr(sbi, blkaddr, DATA_GENERIC))",
                "\t\treturn ERR_PTR(-EFAULT);"
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "An issue was discovered in the Linux kernel through 4.17.10. There is a NULL pointer dereference in fscrypt_do_page_crypto() in fs/crypto/crypto.c when operating on a file in a corrupted f2fs image.",
        "id": 1687
    },
    {
        "cve_id": "CVE-2018-14616",
        "code_before_change": "static bool __written_first_block(struct f2fs_sb_info *sbi,\n\t\t\t\t\tstruct f2fs_inode *ri)\n{\n\tblock_t addr = le32_to_cpu(ri->i_addr[offset_in_addr(ri)]);\n\n\tif (is_valid_data_blkaddr(sbi, addr))\n\t\treturn true;\n\treturn false;\n}",
        "code_after_change": "static int __written_first_block(struct f2fs_sb_info *sbi,\n\t\t\t\t\tstruct f2fs_inode *ri)\n{\n\tblock_t addr = le32_to_cpu(ri->i_addr[offset_in_addr(ri)]);\n\n\tif (!__is_valid_data_blkaddr(addr))\n\t\treturn 1;\n\tif (!f2fs_is_valid_blkaddr(sbi, addr, DATA_GENERIC))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -1,9 +1,11 @@\n-static bool __written_first_block(struct f2fs_sb_info *sbi,\n+static int __written_first_block(struct f2fs_sb_info *sbi,\n \t\t\t\t\tstruct f2fs_inode *ri)\n {\n \tblock_t addr = le32_to_cpu(ri->i_addr[offset_in_addr(ri)]);\n \n-\tif (is_valid_data_blkaddr(sbi, addr))\n-\t\treturn true;\n-\treturn false;\n+\tif (!__is_valid_data_blkaddr(addr))\n+\t\treturn 1;\n+\tif (!f2fs_is_valid_blkaddr(sbi, addr, DATA_GENERIC))\n+\t\treturn -EFAULT;\n+\treturn 0;\n }",
        "function_modified_lines": {
            "added": [
                "static int __written_first_block(struct f2fs_sb_info *sbi,",
                "\tif (!__is_valid_data_blkaddr(addr))",
                "\t\treturn 1;",
                "\tif (!f2fs_is_valid_blkaddr(sbi, addr, DATA_GENERIC))",
                "\t\treturn -EFAULT;",
                "\treturn 0;"
            ],
            "deleted": [
                "static bool __written_first_block(struct f2fs_sb_info *sbi,",
                "\tif (is_valid_data_blkaddr(sbi, addr))",
                "\t\treturn true;",
                "\treturn false;"
            ]
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "An issue was discovered in the Linux kernel through 4.17.10. There is a NULL pointer dereference in fscrypt_do_page_crypto() in fs/crypto/crypto.c when operating on a file in a corrupted f2fs image.",
        "id": 1689
    },
    {
        "cve_id": "CVE-2019-19227",
        "code_before_change": "void __init aarp_proto_init(void)\n{\n\taarp_dl = register_snap_client(aarp_snap_id, aarp_rcv);\n\tif (!aarp_dl)\n\t\tprintk(KERN_CRIT \"Unable to register AARP with SNAP.\\n\");\n\ttimer_setup(&aarp_timer, aarp_expire_timeout, 0);\n\taarp_timer.expires  = jiffies + sysctl_aarp_expiry_time;\n\tadd_timer(&aarp_timer);\n\tregister_netdevice_notifier(&aarp_notifier);\n}",
        "code_after_change": "int __init aarp_proto_init(void)\n{\n\tint rc;\n\n\taarp_dl = register_snap_client(aarp_snap_id, aarp_rcv);\n\tif (!aarp_dl) {\n\t\tprintk(KERN_CRIT \"Unable to register AARP with SNAP.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\ttimer_setup(&aarp_timer, aarp_expire_timeout, 0);\n\taarp_timer.expires  = jiffies + sysctl_aarp_expiry_time;\n\tadd_timer(&aarp_timer);\n\trc = register_netdevice_notifier(&aarp_notifier);\n\tif (rc) {\n\t\tdel_timer_sync(&aarp_timer);\n\t\tunregister_snap_client(aarp_dl);\n\t}\n\treturn rc;\n}",
        "patch": "--- code before\n+++ code after\n@@ -1,10 +1,19 @@\n-void __init aarp_proto_init(void)\n+int __init aarp_proto_init(void)\n {\n+\tint rc;\n+\n \taarp_dl = register_snap_client(aarp_snap_id, aarp_rcv);\n-\tif (!aarp_dl)\n+\tif (!aarp_dl) {\n \t\tprintk(KERN_CRIT \"Unable to register AARP with SNAP.\\n\");\n+\t\treturn -ENOMEM;\n+\t}\n \ttimer_setup(&aarp_timer, aarp_expire_timeout, 0);\n \taarp_timer.expires  = jiffies + sysctl_aarp_expiry_time;\n \tadd_timer(&aarp_timer);\n-\tregister_netdevice_notifier(&aarp_notifier);\n+\trc = register_netdevice_notifier(&aarp_notifier);\n+\tif (rc) {\n+\t\tdel_timer_sync(&aarp_timer);\n+\t\tunregister_snap_client(aarp_dl);\n+\t}\n+\treturn rc;\n }",
        "function_modified_lines": {
            "added": [
                "int __init aarp_proto_init(void)",
                "\tint rc;",
                "",
                "\tif (!aarp_dl) {",
                "\t\treturn -ENOMEM;",
                "\t}",
                "\trc = register_netdevice_notifier(&aarp_notifier);",
                "\tif (rc) {",
                "\t\tdel_timer_sync(&aarp_timer);",
                "\t\tunregister_snap_client(aarp_dl);",
                "\t}",
                "\treturn rc;"
            ],
            "deleted": [
                "void __init aarp_proto_init(void)",
                "\tif (!aarp_dl)",
                "\tregister_netdevice_notifier(&aarp_notifier);"
            ]
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "In the AppleTalk subsystem in the Linux kernel before 5.1, there is a potential NULL pointer dereference because register_snap_client may return NULL. This will lead to denial of service in net/appletalk/aarp.c and net/appletalk/ddp.c, as demonstrated by unregister_snap_client, aka CID-9804501fa122.",
        "id": 2177
    },
    {
        "cve_id": "CVE-2020-25285",
        "code_before_change": "int hugetlb_overcommit_handler(struct ctl_table *table, int write,\n\t\tvoid *buffer, size_t *length, loff_t *ppos)\n{\n\tstruct hstate *h = &default_hstate;\n\tunsigned long tmp;\n\tint ret;\n\n\tif (!hugepages_supported())\n\t\treturn -EOPNOTSUPP;\n\n\ttmp = h->nr_overcommit_huge_pages;\n\n\tif (write && hstate_is_gigantic(h))\n\t\treturn -EINVAL;\n\n\ttable->data = &tmp;\n\ttable->maxlen = sizeof(unsigned long);\n\tret = proc_doulongvec_minmax(table, write, buffer, length, ppos);\n\tif (ret)\n\t\tgoto out;\n\n\tif (write) {\n\t\tspin_lock(&hugetlb_lock);\n\t\th->nr_overcommit_huge_pages = tmp;\n\t\tspin_unlock(&hugetlb_lock);\n\t}\nout:\n\treturn ret;\n}",
        "code_after_change": "int hugetlb_overcommit_handler(struct ctl_table *table, int write,\n\t\tvoid *buffer, size_t *length, loff_t *ppos)\n{\n\tstruct hstate *h = &default_hstate;\n\tunsigned long tmp;\n\tint ret;\n\n\tif (!hugepages_supported())\n\t\treturn -EOPNOTSUPP;\n\n\ttmp = h->nr_overcommit_huge_pages;\n\n\tif (write && hstate_is_gigantic(h))\n\t\treturn -EINVAL;\n\n\tret = proc_hugetlb_doulongvec_minmax(table, write, buffer, length, ppos,\n\t\t\t\t\t     &tmp);\n\tif (ret)\n\t\tgoto out;\n\n\tif (write) {\n\t\tspin_lock(&hugetlb_lock);\n\t\th->nr_overcommit_huge_pages = tmp;\n\t\tspin_unlock(&hugetlb_lock);\n\t}\nout:\n\treturn ret;\n}",
        "patch": "--- code before\n+++ code after\n@@ -13,9 +13,8 @@\n \tif (write && hstate_is_gigantic(h))\n \t\treturn -EINVAL;\n \n-\ttable->data = &tmp;\n-\ttable->maxlen = sizeof(unsigned long);\n-\tret = proc_doulongvec_minmax(table, write, buffer, length, ppos);\n+\tret = proc_hugetlb_doulongvec_minmax(table, write, buffer, length, ppos,\n+\t\t\t\t\t     &tmp);\n \tif (ret)\n \t\tgoto out;\n ",
        "function_modified_lines": {
            "added": [
                "\tret = proc_hugetlb_doulongvec_minmax(table, write, buffer, length, ppos,",
                "\t\t\t\t\t     &tmp);"
            ],
            "deleted": [
                "\ttable->data = &tmp;",
                "\ttable->maxlen = sizeof(unsigned long);",
                "\tret = proc_doulongvec_minmax(table, write, buffer, length, ppos);"
            ]
        },
        "cwe": [
            "CWE-362",
            "CWE-787",
            "CWE-476"
        ],
        "cve_description": "A race condition between hugetlb sysctl handlers in mm/hugetlb.c in the Linux kernel before 5.8.8 could be used by local attackers to corrupt memory, cause a NULL pointer dereference, or possibly have unspecified other impact, aka CID-17743798d812.",
        "id": 2586
    },
    {
        "cve_id": "CVE-2023-28327",
        "code_before_change": "static int unix_diag_get_exact(struct sk_buff *in_skb,\n\t\t\t       const struct nlmsghdr *nlh,\n\t\t\t       struct unix_diag_req *req)\n{\n\tstruct net *net = sock_net(in_skb->sk);\n\tunsigned int extra_len;\n\tstruct sk_buff *rep;\n\tstruct sock *sk;\n\tint err;\n\n\terr = -EINVAL;\n\tif (req->udiag_ino == 0)\n\t\tgoto out_nosk;\n\n\tsk = unix_lookup_by_ino(net, req->udiag_ino);\n\terr = -ENOENT;\n\tif (sk == NULL)\n\t\tgoto out_nosk;\n\n\terr = sock_diag_check_cookie(sk, req->udiag_cookie);\n\tif (err)\n\t\tgoto out;\n\n\textra_len = 256;\nagain:\n\terr = -ENOMEM;\n\trep = nlmsg_new(sizeof(struct unix_diag_msg) + extra_len, GFP_KERNEL);\n\tif (!rep)\n\t\tgoto out;\n\n\terr = sk_diag_fill(sk, rep, req, NETLINK_CB(in_skb).portid,\n\t\t\t   nlh->nlmsg_seq, 0, req->udiag_ino);\n\tif (err < 0) {\n\t\tnlmsg_free(rep);\n\t\textra_len += 256;\n\t\tif (extra_len >= PAGE_SIZE)\n\t\t\tgoto out;\n\n\t\tgoto again;\n\t}\n\terr = nlmsg_unicast(net->diag_nlsk, rep, NETLINK_CB(in_skb).portid);\n\nout:\n\tif (sk)\n\t\tsock_put(sk);\nout_nosk:\n\treturn err;\n}",
        "code_after_change": "static int unix_diag_get_exact(struct sk_buff *in_skb,\n\t\t\t       const struct nlmsghdr *nlh,\n\t\t\t       struct unix_diag_req *req)\n{\n\tstruct net *net = sock_net(in_skb->sk);\n\tunsigned int extra_len;\n\tstruct sk_buff *rep;\n\tstruct sock *sk;\n\tint err;\n\n\terr = -EINVAL;\n\tif (req->udiag_ino == 0)\n\t\tgoto out_nosk;\n\n\tsk = unix_lookup_by_ino(net, req->udiag_ino);\n\terr = -ENOENT;\n\tif (sk == NULL)\n\t\tgoto out_nosk;\n\n\terr = sock_diag_check_cookie(sk, req->udiag_cookie);\n\tif (err)\n\t\tgoto out;\n\n\textra_len = 256;\nagain:\n\terr = -ENOMEM;\n\trep = nlmsg_new(sizeof(struct unix_diag_msg) + extra_len, GFP_KERNEL);\n\tif (!rep)\n\t\tgoto out;\n\n\terr = sk_diag_fill(sk, rep, req, sk_user_ns(NETLINK_CB(in_skb).sk),\n\t\t\t   NETLINK_CB(in_skb).portid,\n\t\t\t   nlh->nlmsg_seq, 0, req->udiag_ino);\n\tif (err < 0) {\n\t\tnlmsg_free(rep);\n\t\textra_len += 256;\n\t\tif (extra_len >= PAGE_SIZE)\n\t\t\tgoto out;\n\n\t\tgoto again;\n\t}\n\terr = nlmsg_unicast(net->diag_nlsk, rep, NETLINK_CB(in_skb).portid);\n\nout:\n\tif (sk)\n\t\tsock_put(sk);\nout_nosk:\n\treturn err;\n}",
        "patch": "--- code before\n+++ code after\n@@ -28,7 +28,8 @@\n \tif (!rep)\n \t\tgoto out;\n \n-\terr = sk_diag_fill(sk, rep, req, NETLINK_CB(in_skb).portid,\n+\terr = sk_diag_fill(sk, rep, req, sk_user_ns(NETLINK_CB(in_skb).sk),\n+\t\t\t   NETLINK_CB(in_skb).portid,\n \t\t\t   nlh->nlmsg_seq, 0, req->udiag_ino);\n \tif (err < 0) {\n \t\tnlmsg_free(rep);",
        "function_modified_lines": {
            "added": [
                "\terr = sk_diag_fill(sk, rep, req, sk_user_ns(NETLINK_CB(in_skb).sk),",
                "\t\t\t   NETLINK_CB(in_skb).portid,"
            ],
            "deleted": [
                "\terr = sk_diag_fill(sk, rep, req, NETLINK_CB(in_skb).portid,"
            ]
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "A NULL pointer dereference flaw was found in the UNIX protocol in net/unix/diag.c In unix_diag_get_exact in the Linux Kernel. The newly allocated skb does not have sk, leading to a NULL pointer. This flaw allows a local user to crash or potentially cause a denial of service.",
        "id": 3975
    },
    {
        "cve_id": "CVE-2023-1382",
        "code_before_change": "static void tipc_topsrv_accept(struct work_struct *work)\n{\n\tstruct tipc_topsrv *srv = container_of(work, struct tipc_topsrv, awork);\n\tstruct socket *newsock, *lsock;\n\tstruct tipc_conn *con;\n\tstruct sock *newsk;\n\tint ret;\n\n\tspin_lock_bh(&srv->idr_lock);\n\tif (!srv->listener) {\n\t\tspin_unlock_bh(&srv->idr_lock);\n\t\treturn;\n\t}\n\tlsock = srv->listener;\n\tspin_unlock_bh(&srv->idr_lock);\n\n\twhile (1) {\n\t\tret = kernel_accept(lsock, &newsock, O_NONBLOCK);\n\t\tif (ret < 0)\n\t\t\treturn;\n\t\tcon = tipc_conn_alloc(srv);\n\t\tif (IS_ERR(con)) {\n\t\t\tret = PTR_ERR(con);\n\t\t\tsock_release(newsock);\n\t\t\treturn;\n\t\t}\n\t\t/* Register callbacks */\n\t\tnewsk = newsock->sk;\n\t\twrite_lock_bh(&newsk->sk_callback_lock);\n\t\tnewsk->sk_data_ready = tipc_conn_data_ready;\n\t\tnewsk->sk_write_space = tipc_conn_write_space;\n\t\tnewsk->sk_user_data = con;\n\t\tcon->sock = newsock;\n\t\twrite_unlock_bh(&newsk->sk_callback_lock);\n\n\t\t/* Wake up receive process in case of 'SYN+' message */\n\t\tnewsk->sk_data_ready(newsk);\n\t}\n}",
        "code_after_change": "static void tipc_topsrv_accept(struct work_struct *work)\n{\n\tstruct tipc_topsrv *srv = container_of(work, struct tipc_topsrv, awork);\n\tstruct socket *newsock, *lsock;\n\tstruct tipc_conn *con;\n\tstruct sock *newsk;\n\tint ret;\n\n\tspin_lock_bh(&srv->idr_lock);\n\tif (!srv->listener) {\n\t\tspin_unlock_bh(&srv->idr_lock);\n\t\treturn;\n\t}\n\tlsock = srv->listener;\n\tspin_unlock_bh(&srv->idr_lock);\n\n\twhile (1) {\n\t\tret = kernel_accept(lsock, &newsock, O_NONBLOCK);\n\t\tif (ret < 0)\n\t\t\treturn;\n\t\tcon = tipc_conn_alloc(srv, newsock);\n\t\tif (IS_ERR(con)) {\n\t\t\tret = PTR_ERR(con);\n\t\t\tsock_release(newsock);\n\t\t\treturn;\n\t\t}\n\t\t/* Register callbacks */\n\t\tnewsk = newsock->sk;\n\t\twrite_lock_bh(&newsk->sk_callback_lock);\n\t\tnewsk->sk_data_ready = tipc_conn_data_ready;\n\t\tnewsk->sk_write_space = tipc_conn_write_space;\n\t\tnewsk->sk_user_data = con;\n\t\twrite_unlock_bh(&newsk->sk_callback_lock);\n\n\t\t/* Wake up receive process in case of 'SYN+' message */\n\t\tnewsk->sk_data_ready(newsk);\n\t}\n}",
        "patch": "--- code before\n+++ code after\n@@ -18,7 +18,7 @@\n \t\tret = kernel_accept(lsock, &newsock, O_NONBLOCK);\n \t\tif (ret < 0)\n \t\t\treturn;\n-\t\tcon = tipc_conn_alloc(srv);\n+\t\tcon = tipc_conn_alloc(srv, newsock);\n \t\tif (IS_ERR(con)) {\n \t\t\tret = PTR_ERR(con);\n \t\t\tsock_release(newsock);\n@@ -30,7 +30,6 @@\n \t\tnewsk->sk_data_ready = tipc_conn_data_ready;\n \t\tnewsk->sk_write_space = tipc_conn_write_space;\n \t\tnewsk->sk_user_data = con;\n-\t\tcon->sock = newsock;\n \t\twrite_unlock_bh(&newsk->sk_callback_lock);\n \n \t\t/* Wake up receive process in case of 'SYN+' message */",
        "function_modified_lines": {
            "added": [
                "\t\tcon = tipc_conn_alloc(srv, newsock);"
            ],
            "deleted": [
                "\t\tcon = tipc_conn_alloc(srv);",
                "\t\tcon->sock = newsock;"
            ]
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "A data race flaw was found in the Linux kernel, between where con is allocated and con->sock is set. This issue leads to a NULL pointer dereference when accessing con->sock->sk in net/tipc/topsrv.c in the tipc protocol in the Linux kernel.",
        "id": 3866
    },
    {
        "cve_id": "CVE-2018-1066",
        "code_before_change": "static int\nSMB2_sess_establish_session(struct SMB2_sess_data *sess_data)\n{\n\tint rc = 0;\n\tstruct cifs_ses *ses = sess_data->ses;\n\n\tmutex_lock(&ses->server->srv_mutex);\n\tif (ses->server->sign && ses->server->ops->generate_signingkey) {\n\t\trc = ses->server->ops->generate_signingkey(ses);\n\t\tkfree(ses->auth_key.response);\n\t\tses->auth_key.response = NULL;\n\t\tif (rc) {\n\t\t\tcifs_dbg(FYI,\n\t\t\t\t\"SMB3 session key generation failed\\n\");\n\t\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t\tgoto keygen_exit;\n\t\t}\n\t}\n\tif (!ses->server->session_estab) {\n\t\tses->server->sequence_number = 0x2;\n\t\tses->server->session_estab = true;\n\t}\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tcifs_dbg(FYI, \"SMB2/3 session established successfully\\n\");\n\tspin_lock(&GlobalMid_Lock);\n\tses->status = CifsGood;\n\tses->need_reconnect = false;\n\tspin_unlock(&GlobalMid_Lock);\n\nkeygen_exit:\n\tif (!ses->server->sign) {\n\t\tkfree(ses->auth_key.response);\n\t\tses->auth_key.response = NULL;\n\t}\n\treturn rc;\n}",
        "code_after_change": "static int\nSMB2_sess_establish_session(struct SMB2_sess_data *sess_data)\n{\n\tint rc = 0;\n\tstruct cifs_ses *ses = sess_data->ses;\n\n\tmutex_lock(&ses->server->srv_mutex);\n\tif (ses->server->ops->generate_signingkey) {\n\t\trc = ses->server->ops->generate_signingkey(ses);\n\t\tif (rc) {\n\t\t\tcifs_dbg(FYI,\n\t\t\t\t\"SMB3 session key generation failed\\n\");\n\t\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t\treturn rc;\n\t\t}\n\t}\n\tif (!ses->server->session_estab) {\n\t\tses->server->sequence_number = 0x2;\n\t\tses->server->session_estab = true;\n\t}\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tcifs_dbg(FYI, \"SMB2/3 session established successfully\\n\");\n\tspin_lock(&GlobalMid_Lock);\n\tses->status = CifsGood;\n\tses->need_reconnect = false;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn rc;\n}",
        "patch": "--- code before\n+++ code after\n@@ -5,15 +5,13 @@\n \tstruct cifs_ses *ses = sess_data->ses;\n \n \tmutex_lock(&ses->server->srv_mutex);\n-\tif (ses->server->sign && ses->server->ops->generate_signingkey) {\n+\tif (ses->server->ops->generate_signingkey) {\n \t\trc = ses->server->ops->generate_signingkey(ses);\n-\t\tkfree(ses->auth_key.response);\n-\t\tses->auth_key.response = NULL;\n \t\tif (rc) {\n \t\t\tcifs_dbg(FYI,\n \t\t\t\t\"SMB3 session key generation failed\\n\");\n \t\t\tmutex_unlock(&ses->server->srv_mutex);\n-\t\t\tgoto keygen_exit;\n+\t\t\treturn rc;\n \t\t}\n \t}\n \tif (!ses->server->session_estab) {\n@@ -27,11 +25,5 @@\n \tses->status = CifsGood;\n \tses->need_reconnect = false;\n \tspin_unlock(&GlobalMid_Lock);\n-\n-keygen_exit:\n-\tif (!ses->server->sign) {\n-\t\tkfree(ses->auth_key.response);\n-\t\tses->auth_key.response = NULL;\n-\t}\n \treturn rc;\n }",
        "function_modified_lines": {
            "added": [
                "\tif (ses->server->ops->generate_signingkey) {",
                "\t\t\treturn rc;"
            ],
            "deleted": [
                "\tif (ses->server->sign && ses->server->ops->generate_signingkey) {",
                "\t\tkfree(ses->auth_key.response);",
                "\t\tses->auth_key.response = NULL;",
                "\t\t\tgoto keygen_exit;",
                "",
                "keygen_exit:",
                "\tif (!ses->server->sign) {",
                "\t\tkfree(ses->auth_key.response);",
                "\t\tses->auth_key.response = NULL;",
                "\t}"
            ]
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "The Linux kernel before version 4.11 is vulnerable to a NULL pointer dereference in fs/cifs/cifsencrypt.c:setup_ntlmv2_rsp() that allows an attacker controlling a CIFS server to kernel panic a client that has this server mounted, because an empty TargetInfo field in an NTLMSSP setup negotiation response is mishandled during session recovery.",
        "id": 1592
    },
    {
        "cve_id": "CVE-2018-1066",
        "code_before_change": "void build_ntlmssp_negotiate_blob(unsigned char *pbuffer,\n\t\t\t\t\t struct cifs_ses *ses)\n{\n\tNEGOTIATE_MESSAGE *sec_blob = (NEGOTIATE_MESSAGE *)pbuffer;\n\t__u32 flags;\n\n\tmemset(pbuffer, 0, sizeof(NEGOTIATE_MESSAGE));\n\tmemcpy(sec_blob->Signature, NTLMSSP_SIGNATURE, 8);\n\tsec_blob->MessageType = NtLmNegotiate;\n\n\t/* BB is NTLMV2 session security format easier to use here? */\n\tflags = NTLMSSP_NEGOTIATE_56 |\tNTLMSSP_REQUEST_TARGET |\n\t\tNTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE |\n\t\tNTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC;\n\tif (ses->server->sign) {\n\t\tflags |= NTLMSSP_NEGOTIATE_SIGN;\n\t\tif (!ses->server->session_estab ||\n\t\t\t\tses->ntlmssp->sesskey_per_smbsess)\n\t\t\tflags |= NTLMSSP_NEGOTIATE_KEY_XCH;\n\t}\n\n\tsec_blob->NegotiateFlags = cpu_to_le32(flags);\n\n\tsec_blob->WorkstationName.BufferOffset = 0;\n\tsec_blob->WorkstationName.Length = 0;\n\tsec_blob->WorkstationName.MaximumLength = 0;\n\n\t/* Domain name is sent on the Challenge not Negotiate NTLMSSP request */\n\tsec_blob->DomainName.BufferOffset = 0;\n\tsec_blob->DomainName.Length = 0;\n\tsec_blob->DomainName.MaximumLength = 0;\n}",
        "code_after_change": "void build_ntlmssp_negotiate_blob(unsigned char *pbuffer,\n\t\t\t\t\t struct cifs_ses *ses)\n{\n\tNEGOTIATE_MESSAGE *sec_blob = (NEGOTIATE_MESSAGE *)pbuffer;\n\t__u32 flags;\n\n\tmemset(pbuffer, 0, sizeof(NEGOTIATE_MESSAGE));\n\tmemcpy(sec_blob->Signature, NTLMSSP_SIGNATURE, 8);\n\tsec_blob->MessageType = NtLmNegotiate;\n\n\t/* BB is NTLMV2 session security format easier to use here? */\n\tflags = NTLMSSP_NEGOTIATE_56 |\tNTLMSSP_REQUEST_TARGET |\n\t\tNTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE |\n\t\tNTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC |\n\t\tNTLMSSP_NEGOTIATE_SEAL;\n\tif (ses->server->sign)\n\t\tflags |= NTLMSSP_NEGOTIATE_SIGN;\n\tif (!ses->server->session_estab || ses->ntlmssp->sesskey_per_smbsess)\n\t\tflags |= NTLMSSP_NEGOTIATE_KEY_XCH;\n\n\tsec_blob->NegotiateFlags = cpu_to_le32(flags);\n\n\tsec_blob->WorkstationName.BufferOffset = 0;\n\tsec_blob->WorkstationName.Length = 0;\n\tsec_blob->WorkstationName.MaximumLength = 0;\n\n\t/* Domain name is sent on the Challenge not Negotiate NTLMSSP request */\n\tsec_blob->DomainName.BufferOffset = 0;\n\tsec_blob->DomainName.Length = 0;\n\tsec_blob->DomainName.MaximumLength = 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -11,13 +11,12 @@\n \t/* BB is NTLMV2 session security format easier to use here? */\n \tflags = NTLMSSP_NEGOTIATE_56 |\tNTLMSSP_REQUEST_TARGET |\n \t\tNTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE |\n-\t\tNTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC;\n-\tif (ses->server->sign) {\n+\t\tNTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC |\n+\t\tNTLMSSP_NEGOTIATE_SEAL;\n+\tif (ses->server->sign)\n \t\tflags |= NTLMSSP_NEGOTIATE_SIGN;\n-\t\tif (!ses->server->session_estab ||\n-\t\t\t\tses->ntlmssp->sesskey_per_smbsess)\n-\t\t\tflags |= NTLMSSP_NEGOTIATE_KEY_XCH;\n-\t}\n+\tif (!ses->server->session_estab || ses->ntlmssp->sesskey_per_smbsess)\n+\t\tflags |= NTLMSSP_NEGOTIATE_KEY_XCH;\n \n \tsec_blob->NegotiateFlags = cpu_to_le32(flags);\n ",
        "function_modified_lines": {
            "added": [
                "\t\tNTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC |",
                "\t\tNTLMSSP_NEGOTIATE_SEAL;",
                "\tif (ses->server->sign)",
                "\tif (!ses->server->session_estab || ses->ntlmssp->sesskey_per_smbsess)",
                "\t\tflags |= NTLMSSP_NEGOTIATE_KEY_XCH;"
            ],
            "deleted": [
                "\t\tNTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC;",
                "\tif (ses->server->sign) {",
                "\t\tif (!ses->server->session_estab ||",
                "\t\t\t\tses->ntlmssp->sesskey_per_smbsess)",
                "\t\t\tflags |= NTLMSSP_NEGOTIATE_KEY_XCH;",
                "\t}"
            ]
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "The Linux kernel before version 4.11 is vulnerable to a NULL pointer dereference in fs/cifs/cifsencrypt.c:setup_ntlmv2_rsp() that allows an attacker controlling a CIFS server to kernel panic a client that has this server mounted, because an empty TargetInfo field in an NTLMSSP setup negotiation response is mishandled during session recovery.",
        "id": 1591
    },
    {
        "cve_id": "CVE-2018-14614",
        "code_before_change": "int f2fs_get_valid_checkpoint(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_checkpoint *cp_block;\n\tstruct f2fs_super_block *fsb = sbi->raw_super;\n\tstruct page *cp1, *cp2, *cur_page;\n\tunsigned long blk_size = sbi->blocksize;\n\tunsigned long long cp1_version = 0, cp2_version = 0;\n\tunsigned long long cp_start_blk_no;\n\tunsigned int cp_blks = 1 + __cp_payload(sbi);\n\tblock_t cp_blk_no;\n\tint i;\n\n\tsbi->ckpt = f2fs_kzalloc(sbi, array_size(blk_size, cp_blks),\n\t\t\t\t GFP_KERNEL);\n\tif (!sbi->ckpt)\n\t\treturn -ENOMEM;\n\t/*\n\t * Finding out valid cp block involves read both\n\t * sets( cp pack1 and cp pack 2)\n\t */\n\tcp_start_blk_no = le32_to_cpu(fsb->cp_blkaddr);\n\tcp1 = validate_checkpoint(sbi, cp_start_blk_no, &cp1_version);\n\n\t/* The second checkpoint pack should start at the next segment */\n\tcp_start_blk_no += ((unsigned long long)1) <<\n\t\t\t\tle32_to_cpu(fsb->log_blocks_per_seg);\n\tcp2 = validate_checkpoint(sbi, cp_start_blk_no, &cp2_version);\n\n\tif (cp1 && cp2) {\n\t\tif (ver_after(cp2_version, cp1_version))\n\t\t\tcur_page = cp2;\n\t\telse\n\t\t\tcur_page = cp1;\n\t} else if (cp1) {\n\t\tcur_page = cp1;\n\t} else if (cp2) {\n\t\tcur_page = cp2;\n\t} else {\n\t\tgoto fail_no_cp;\n\t}\n\n\tcp_block = (struct f2fs_checkpoint *)page_address(cur_page);\n\tmemcpy(sbi->ckpt, cp_block, blk_size);\n\n\t/* Sanity checking of checkpoint */\n\tif (f2fs_sanity_check_ckpt(sbi))\n\t\tgoto free_fail_no_cp;\n\n\tif (cur_page == cp1)\n\t\tsbi->cur_cp_pack = 1;\n\telse\n\t\tsbi->cur_cp_pack = 2;\n\n\tif (cp_blks <= 1)\n\t\tgoto done;\n\n\tcp_blk_no = le32_to_cpu(fsb->cp_blkaddr);\n\tif (cur_page == cp2)\n\t\tcp_blk_no += 1 << le32_to_cpu(fsb->log_blocks_per_seg);\n\n\tfor (i = 1; i < cp_blks; i++) {\n\t\tvoid *sit_bitmap_ptr;\n\t\tunsigned char *ckpt = (unsigned char *)sbi->ckpt;\n\n\t\tcur_page = f2fs_get_meta_page(sbi, cp_blk_no + i);\n\t\tif (IS_ERR(cur_page))\n\t\t\tgoto free_fail_no_cp;\n\t\tsit_bitmap_ptr = page_address(cur_page);\n\t\tmemcpy(ckpt + i * blk_size, sit_bitmap_ptr, blk_size);\n\t\tf2fs_put_page(cur_page, 1);\n\t}\ndone:\n\tf2fs_put_page(cp1, 1);\n\tf2fs_put_page(cp2, 1);\n\treturn 0;\n\nfree_fail_no_cp:\n\tf2fs_put_page(cp1, 1);\n\tf2fs_put_page(cp2, 1);\nfail_no_cp:\n\tkfree(sbi->ckpt);\n\treturn -EINVAL;\n}",
        "code_after_change": "int f2fs_get_valid_checkpoint(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_checkpoint *cp_block;\n\tstruct f2fs_super_block *fsb = sbi->raw_super;\n\tstruct page *cp1, *cp2, *cur_page;\n\tunsigned long blk_size = sbi->blocksize;\n\tunsigned long long cp1_version = 0, cp2_version = 0;\n\tunsigned long long cp_start_blk_no;\n\tunsigned int cp_blks = 1 + __cp_payload(sbi);\n\tblock_t cp_blk_no;\n\tint i;\n\n\tsbi->ckpt = f2fs_kzalloc(sbi, array_size(blk_size, cp_blks),\n\t\t\t\t GFP_KERNEL);\n\tif (!sbi->ckpt)\n\t\treturn -ENOMEM;\n\t/*\n\t * Finding out valid cp block involves read both\n\t * sets( cp pack1 and cp pack 2)\n\t */\n\tcp_start_blk_no = le32_to_cpu(fsb->cp_blkaddr);\n\tcp1 = validate_checkpoint(sbi, cp_start_blk_no, &cp1_version);\n\n\t/* The second checkpoint pack should start at the next segment */\n\tcp_start_blk_no += ((unsigned long long)1) <<\n\t\t\t\tle32_to_cpu(fsb->log_blocks_per_seg);\n\tcp2 = validate_checkpoint(sbi, cp_start_blk_no, &cp2_version);\n\n\tif (cp1 && cp2) {\n\t\tif (ver_after(cp2_version, cp1_version))\n\t\t\tcur_page = cp2;\n\t\telse\n\t\t\tcur_page = cp1;\n\t} else if (cp1) {\n\t\tcur_page = cp1;\n\t} else if (cp2) {\n\t\tcur_page = cp2;\n\t} else {\n\t\tgoto fail_no_cp;\n\t}\n\n\tcp_block = (struct f2fs_checkpoint *)page_address(cur_page);\n\tmemcpy(sbi->ckpt, cp_block, blk_size);\n\n\tif (cur_page == cp1)\n\t\tsbi->cur_cp_pack = 1;\n\telse\n\t\tsbi->cur_cp_pack = 2;\n\n\t/* Sanity checking of checkpoint */\n\tif (f2fs_sanity_check_ckpt(sbi))\n\t\tgoto free_fail_no_cp;\n\n\tif (cp_blks <= 1)\n\t\tgoto done;\n\n\tcp_blk_no = le32_to_cpu(fsb->cp_blkaddr);\n\tif (cur_page == cp2)\n\t\tcp_blk_no += 1 << le32_to_cpu(fsb->log_blocks_per_seg);\n\n\tfor (i = 1; i < cp_blks; i++) {\n\t\tvoid *sit_bitmap_ptr;\n\t\tunsigned char *ckpt = (unsigned char *)sbi->ckpt;\n\n\t\tcur_page = f2fs_get_meta_page(sbi, cp_blk_no + i);\n\t\tif (IS_ERR(cur_page))\n\t\t\tgoto free_fail_no_cp;\n\t\tsit_bitmap_ptr = page_address(cur_page);\n\t\tmemcpy(ckpt + i * blk_size, sit_bitmap_ptr, blk_size);\n\t\tf2fs_put_page(cur_page, 1);\n\t}\ndone:\n\tf2fs_put_page(cp1, 1);\n\tf2fs_put_page(cp2, 1);\n\treturn 0;\n\nfree_fail_no_cp:\n\tf2fs_put_page(cp1, 1);\n\tf2fs_put_page(cp2, 1);\nfail_no_cp:\n\tkfree(sbi->ckpt);\n\treturn -EINVAL;\n}",
        "patch": "--- code before\n+++ code after\n@@ -42,14 +42,14 @@\n \tcp_block = (struct f2fs_checkpoint *)page_address(cur_page);\n \tmemcpy(sbi->ckpt, cp_block, blk_size);\n \n-\t/* Sanity checking of checkpoint */\n-\tif (f2fs_sanity_check_ckpt(sbi))\n-\t\tgoto free_fail_no_cp;\n-\n \tif (cur_page == cp1)\n \t\tsbi->cur_cp_pack = 1;\n \telse\n \t\tsbi->cur_cp_pack = 2;\n+\n+\t/* Sanity checking of checkpoint */\n+\tif (f2fs_sanity_check_ckpt(sbi))\n+\t\tgoto free_fail_no_cp;\n \n \tif (cp_blks <= 1)\n \t\tgoto done;",
        "function_modified_lines": {
            "added": [
                "",
                "\t/* Sanity checking of checkpoint */",
                "\tif (f2fs_sanity_check_ckpt(sbi))",
                "\t\tgoto free_fail_no_cp;"
            ],
            "deleted": [
                "\t/* Sanity checking of checkpoint */",
                "\tif (f2fs_sanity_check_ckpt(sbi))",
                "\t\tgoto free_fail_no_cp;",
                ""
            ]
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "An issue was discovered in the Linux kernel through 4.17.10. There is an out-of-bounds access in __remove_dirty_segment() in fs/f2fs/segment.c when mounting an f2fs image.",
        "id": 1684
    },
    {
        "cve_id": "CVE-2019-10207",
        "code_before_change": "static int bcm_open(struct hci_uart *hu)\n{\n\tstruct bcm_data *bcm;\n\tstruct list_head *p;\n\tint err;\n\n\tbt_dev_dbg(hu->hdev, \"hu %p\", hu);\n\n\tbcm = kzalloc(sizeof(*bcm), GFP_KERNEL);\n\tif (!bcm)\n\t\treturn -ENOMEM;\n\n\tskb_queue_head_init(&bcm->txq);\n\n\thu->priv = bcm;\n\n\tmutex_lock(&bcm_device_lock);\n\n\tif (hu->serdev) {\n\t\tbcm->dev = serdev_device_get_drvdata(hu->serdev);\n\t\tgoto out;\n\t}\n\n\tif (!hu->tty->dev)\n\t\tgoto out;\n\n\tlist_for_each(p, &bcm_device_list) {\n\t\tstruct bcm_device *dev = list_entry(p, struct bcm_device, list);\n\n\t\t/* Retrieve saved bcm_device based on parent of the\n\t\t * platform device (saved during device probe) and\n\t\t * parent of tty device used by hci_uart\n\t\t */\n\t\tif (hu->tty->dev->parent == dev->dev->parent) {\n\t\t\tbcm->dev = dev;\n#ifdef CONFIG_PM\n\t\t\tdev->hu = hu;\n#endif\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\tif (bcm->dev) {\n\t\thu->init_speed = bcm->dev->init_speed;\n\t\thu->oper_speed = bcm->dev->oper_speed;\n\t\terr = bcm_gpio_set_power(bcm->dev, true);\n\t\tif (err)\n\t\t\tgoto err_unset_hu;\n\t}\n\n\tmutex_unlock(&bcm_device_lock);\n\treturn 0;\n\nerr_unset_hu:\n#ifdef CONFIG_PM\n\tif (!hu->serdev)\n\t\tbcm->dev->hu = NULL;\n#endif\n\tmutex_unlock(&bcm_device_lock);\n\thu->priv = NULL;\n\tkfree(bcm);\n\treturn err;\n}",
        "code_after_change": "static int bcm_open(struct hci_uart *hu)\n{\n\tstruct bcm_data *bcm;\n\tstruct list_head *p;\n\tint err;\n\n\tbt_dev_dbg(hu->hdev, \"hu %p\", hu);\n\n\tif (!hci_uart_has_flow_control(hu))\n\t\treturn -EOPNOTSUPP;\n\n\tbcm = kzalloc(sizeof(*bcm), GFP_KERNEL);\n\tif (!bcm)\n\t\treturn -ENOMEM;\n\n\tskb_queue_head_init(&bcm->txq);\n\n\thu->priv = bcm;\n\n\tmutex_lock(&bcm_device_lock);\n\n\tif (hu->serdev) {\n\t\tbcm->dev = serdev_device_get_drvdata(hu->serdev);\n\t\tgoto out;\n\t}\n\n\tif (!hu->tty->dev)\n\t\tgoto out;\n\n\tlist_for_each(p, &bcm_device_list) {\n\t\tstruct bcm_device *dev = list_entry(p, struct bcm_device, list);\n\n\t\t/* Retrieve saved bcm_device based on parent of the\n\t\t * platform device (saved during device probe) and\n\t\t * parent of tty device used by hci_uart\n\t\t */\n\t\tif (hu->tty->dev->parent == dev->dev->parent) {\n\t\t\tbcm->dev = dev;\n#ifdef CONFIG_PM\n\t\t\tdev->hu = hu;\n#endif\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\tif (bcm->dev) {\n\t\thu->init_speed = bcm->dev->init_speed;\n\t\thu->oper_speed = bcm->dev->oper_speed;\n\t\terr = bcm_gpio_set_power(bcm->dev, true);\n\t\tif (err)\n\t\t\tgoto err_unset_hu;\n\t}\n\n\tmutex_unlock(&bcm_device_lock);\n\treturn 0;\n\nerr_unset_hu:\n#ifdef CONFIG_PM\n\tif (!hu->serdev)\n\t\tbcm->dev->hu = NULL;\n#endif\n\tmutex_unlock(&bcm_device_lock);\n\thu->priv = NULL;\n\tkfree(bcm);\n\treturn err;\n}",
        "patch": "--- code before\n+++ code after\n@@ -5,6 +5,9 @@\n \tint err;\n \n \tbt_dev_dbg(hu->hdev, \"hu %p\", hu);\n+\n+\tif (!hci_uart_has_flow_control(hu))\n+\t\treturn -EOPNOTSUPP;\n \n \tbcm = kzalloc(sizeof(*bcm), GFP_KERNEL);\n \tif (!bcm)",
        "function_modified_lines": {
            "added": [
                "",
                "\tif (!hci_uart_has_flow_control(hu))",
                "\t\treturn -EOPNOTSUPP;"
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "A flaw was found in the Linux kernel's Bluetooth implementation of UART, all versions kernel 3.x.x before 4.18.0 and kernel 5.x.x. An attacker with local access and write permissions to the Bluetooth hardware could use this flaw to issue a specially crafted ioctl function call and cause the system to crash.",
        "id": 1897
    },
    {
        "cve_id": "CVE-2020-14356",
        "code_before_change": "static inline struct cgroup *sock_cgroup_ptr(struct sock_cgroup_data *skcd)\n{\n#if defined(CONFIG_CGROUP_NET_PRIO) || defined(CONFIG_CGROUP_NET_CLASSID)\n\tunsigned long v;\n\n\t/*\n\t * @skcd->val is 64bit but the following is safe on 32bit too as we\n\t * just need the lower ulong to be written and read atomically.\n\t */\n\tv = READ_ONCE(skcd->val);\n\n\tif (v & 1)\n\t\treturn &cgrp_dfl_root.cgrp;\n\n\treturn (struct cgroup *)(unsigned long)v ?: &cgrp_dfl_root.cgrp;\n#else\n\treturn (struct cgroup *)(unsigned long)skcd->val;\n#endif\n}",
        "code_after_change": "static inline struct cgroup *sock_cgroup_ptr(struct sock_cgroup_data *skcd)\n{\n#if defined(CONFIG_CGROUP_NET_PRIO) || defined(CONFIG_CGROUP_NET_CLASSID)\n\tunsigned long v;\n\n\t/*\n\t * @skcd->val is 64bit but the following is safe on 32bit too as we\n\t * just need the lower ulong to be written and read atomically.\n\t */\n\tv = READ_ONCE(skcd->val);\n\n\tif (v & 3)\n\t\treturn &cgrp_dfl_root.cgrp;\n\n\treturn (struct cgroup *)(unsigned long)v ?: &cgrp_dfl_root.cgrp;\n#else\n\treturn (struct cgroup *)(unsigned long)skcd->val;\n#endif\n}",
        "patch": "--- code before\n+++ code after\n@@ -9,7 +9,7 @@\n \t */\n \tv = READ_ONCE(skcd->val);\n \n-\tif (v & 1)\n+\tif (v & 3)\n \t\treturn &cgrp_dfl_root.cgrp;\n \n \treturn (struct cgroup *)(unsigned long)v ?: &cgrp_dfl_root.cgrp;",
        "function_modified_lines": {
            "added": [
                "\tif (v & 3)"
            ],
            "deleted": [
                "\tif (v & 1)"
            ]
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "A flaw null pointer dereference in the Linux kernel cgroupv2 subsystem in versions before 5.7.10 was found in the way when reboot the system. A local user could use this flaw to crash the system or escalate their privileges on the system.",
        "id": 2515
    },
    {
        "cve_id": "CVE-2020-14356",
        "code_before_change": "void cgroup_sk_alloc(struct sock_cgroup_data *skcd)\n{\n\tif (cgroup_sk_alloc_disabled)\n\t\treturn;\n\n\t/* Socket clone path */\n\tif (skcd->val) {\n\t\t/*\n\t\t * We might be cloning a socket which is left in an empty\n\t\t * cgroup and the cgroup might have already been rmdir'd.\n\t\t * Don't use cgroup_get_live().\n\t\t */\n\t\tcgroup_get(sock_cgroup_ptr(skcd));\n\t\tcgroup_bpf_get(sock_cgroup_ptr(skcd));\n\t\treturn;\n\t}\n\n\t/* Don't associate the sock with unrelated interrupted task's cgroup. */\n\tif (in_interrupt())\n\t\treturn;\n\n\trcu_read_lock();\n\n\twhile (true) {\n\t\tstruct css_set *cset;\n\n\t\tcset = task_css_set(current);\n\t\tif (likely(cgroup_tryget(cset->dfl_cgrp))) {\n\t\t\tskcd->val = (unsigned long)cset->dfl_cgrp;\n\t\t\tcgroup_bpf_get(cset->dfl_cgrp);\n\t\t\tbreak;\n\t\t}\n\t\tcpu_relax();\n\t}\n\n\trcu_read_unlock();\n}",
        "code_after_change": "void cgroup_sk_alloc(struct sock_cgroup_data *skcd)\n{\n\tif (cgroup_sk_alloc_disabled) {\n\t\tskcd->no_refcnt = 1;\n\t\treturn;\n\t}\n\n\t/* Don't associate the sock with unrelated interrupted task's cgroup. */\n\tif (in_interrupt())\n\t\treturn;\n\n\trcu_read_lock();\n\n\twhile (true) {\n\t\tstruct css_set *cset;\n\n\t\tcset = task_css_set(current);\n\t\tif (likely(cgroup_tryget(cset->dfl_cgrp))) {\n\t\t\tskcd->val = (unsigned long)cset->dfl_cgrp;\n\t\t\tcgroup_bpf_get(cset->dfl_cgrp);\n\t\t\tbreak;\n\t\t}\n\t\tcpu_relax();\n\t}\n\n\trcu_read_unlock();\n}",
        "patch": "--- code before\n+++ code after\n@@ -1,17 +1,7 @@\n void cgroup_sk_alloc(struct sock_cgroup_data *skcd)\n {\n-\tif (cgroup_sk_alloc_disabled)\n-\t\treturn;\n-\n-\t/* Socket clone path */\n-\tif (skcd->val) {\n-\t\t/*\n-\t\t * We might be cloning a socket which is left in an empty\n-\t\t * cgroup and the cgroup might have already been rmdir'd.\n-\t\t * Don't use cgroup_get_live().\n-\t\t */\n-\t\tcgroup_get(sock_cgroup_ptr(skcd));\n-\t\tcgroup_bpf_get(sock_cgroup_ptr(skcd));\n+\tif (cgroup_sk_alloc_disabled) {\n+\t\tskcd->no_refcnt = 1;\n \t\treturn;\n \t}\n ",
        "function_modified_lines": {
            "added": [
                "\tif (cgroup_sk_alloc_disabled) {",
                "\t\tskcd->no_refcnt = 1;"
            ],
            "deleted": [
                "\tif (cgroup_sk_alloc_disabled)",
                "\t\treturn;",
                "",
                "\t/* Socket clone path */",
                "\tif (skcd->val) {",
                "\t\t/*",
                "\t\t * We might be cloning a socket which is left in an empty",
                "\t\t * cgroup and the cgroup might have already been rmdir'd.",
                "\t\t * Don't use cgroup_get_live().",
                "\t\t */",
                "\t\tcgroup_get(sock_cgroup_ptr(skcd));",
                "\t\tcgroup_bpf_get(sock_cgroup_ptr(skcd));"
            ]
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "A flaw null pointer dereference in the Linux kernel cgroupv2 subsystem in versions before 5.7.10 was found in the way when reboot the system. A local user could use this flaw to crash the system or escalate their privileges on the system.",
        "id": 2517
    },
    {
        "cve_id": "CVE-2020-14356",
        "code_before_change": "struct sock *sk_clone_lock(const struct sock *sk, const gfp_t priority)\n{\n\tstruct proto *prot = READ_ONCE(sk->sk_prot);\n\tstruct sock *newsk;\n\tbool is_charged = true;\n\n\tnewsk = sk_prot_alloc(prot, priority, sk->sk_family);\n\tif (newsk != NULL) {\n\t\tstruct sk_filter *filter;\n\n\t\tsock_copy(newsk, sk);\n\n\t\tnewsk->sk_prot_creator = prot;\n\n\t\t/* SANITY */\n\t\tif (likely(newsk->sk_net_refcnt))\n\t\t\tget_net(sock_net(newsk));\n\t\tsk_node_init(&newsk->sk_node);\n\t\tsock_lock_init(newsk);\n\t\tbh_lock_sock(newsk);\n\t\tnewsk->sk_backlog.head\t= newsk->sk_backlog.tail = NULL;\n\t\tnewsk->sk_backlog.len = 0;\n\n\t\tatomic_set(&newsk->sk_rmem_alloc, 0);\n\t\t/*\n\t\t * sk_wmem_alloc set to one (see sk_free() and sock_wfree())\n\t\t */\n\t\trefcount_set(&newsk->sk_wmem_alloc, 1);\n\t\tatomic_set(&newsk->sk_omem_alloc, 0);\n\t\tsk_init_common(newsk);\n\n\t\tnewsk->sk_dst_cache\t= NULL;\n\t\tnewsk->sk_dst_pending_confirm = 0;\n\t\tnewsk->sk_wmem_queued\t= 0;\n\t\tnewsk->sk_forward_alloc = 0;\n\t\tatomic_set(&newsk->sk_drops, 0);\n\t\tnewsk->sk_send_head\t= NULL;\n\t\tnewsk->sk_userlocks\t= sk->sk_userlocks & ~SOCK_BINDPORT_LOCK;\n\t\tatomic_set(&newsk->sk_zckey, 0);\n\n\t\tsock_reset_flag(newsk, SOCK_DONE);\n\n\t\t/* sk->sk_memcg will be populated at accept() time */\n\t\tnewsk->sk_memcg = NULL;\n\n\t\tcgroup_sk_alloc(&newsk->sk_cgrp_data);\n\n\t\trcu_read_lock();\n\t\tfilter = rcu_dereference(sk->sk_filter);\n\t\tif (filter != NULL)\n\t\t\t/* though it's an empty new sock, the charging may fail\n\t\t\t * if sysctl_optmem_max was changed between creation of\n\t\t\t * original socket and cloning\n\t\t\t */\n\t\t\tis_charged = sk_filter_charge(newsk, filter);\n\t\tRCU_INIT_POINTER(newsk->sk_filter, filter);\n\t\trcu_read_unlock();\n\n\t\tif (unlikely(!is_charged || xfrm_sk_clone_policy(newsk, sk))) {\n\t\t\t/* We need to make sure that we don't uncharge the new\n\t\t\t * socket if we couldn't charge it in the first place\n\t\t\t * as otherwise we uncharge the parent's filter.\n\t\t\t */\n\t\t\tif (!is_charged)\n\t\t\t\tRCU_INIT_POINTER(newsk->sk_filter, NULL);\n\t\t\tsk_free_unlock_clone(newsk);\n\t\t\tnewsk = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tRCU_INIT_POINTER(newsk->sk_reuseport_cb, NULL);\n\n\t\tif (bpf_sk_storage_clone(sk, newsk)) {\n\t\t\tsk_free_unlock_clone(newsk);\n\t\t\tnewsk = NULL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Clear sk_user_data if parent had the pointer tagged\n\t\t * as not suitable for copying when cloning.\n\t\t */\n\t\tif (sk_user_data_is_nocopy(newsk))\n\t\t\tnewsk->sk_user_data = NULL;\n\n\t\tnewsk->sk_err\t   = 0;\n\t\tnewsk->sk_err_soft = 0;\n\t\tnewsk->sk_priority = 0;\n\t\tnewsk->sk_incoming_cpu = raw_smp_processor_id();\n\t\tif (likely(newsk->sk_net_refcnt))\n\t\t\tsock_inuse_add(sock_net(newsk), 1);\n\n\t\t/*\n\t\t * Before updating sk_refcnt, we must commit prior changes to memory\n\t\t * (Documentation/RCU/rculist_nulls.txt for details)\n\t\t */\n\t\tsmp_wmb();\n\t\trefcount_set(&newsk->sk_refcnt, 2);\n\n\t\t/*\n\t\t * Increment the counter in the same struct proto as the master\n\t\t * sock (sk_refcnt_debug_inc uses newsk->sk_prot->socks, that\n\t\t * is the same as sk->sk_prot->socks, as this field was copied\n\t\t * with memcpy).\n\t\t *\n\t\t * This _changes_ the previous behaviour, where\n\t\t * tcp_create_openreq_child always was incrementing the\n\t\t * equivalent to tcp_prot->socks (inet_sock_nr), so this have\n\t\t * to be taken into account in all callers. -acme\n\t\t */\n\t\tsk_refcnt_debug_inc(newsk);\n\t\tsk_set_socket(newsk, NULL);\n\t\tsk_tx_queue_clear(newsk);\n\t\tRCU_INIT_POINTER(newsk->sk_wq, NULL);\n\n\t\tif (newsk->sk_prot->sockets_allocated)\n\t\t\tsk_sockets_allocated_inc(newsk);\n\n\t\tif (sock_needs_netstamp(sk) &&\n\t\t    newsk->sk_flags & SK_FLAGS_TIMESTAMP)\n\t\t\tnet_enable_timestamp();\n\t}\nout:\n\treturn newsk;\n}",
        "code_after_change": "struct sock *sk_clone_lock(const struct sock *sk, const gfp_t priority)\n{\n\tstruct proto *prot = READ_ONCE(sk->sk_prot);\n\tstruct sock *newsk;\n\tbool is_charged = true;\n\n\tnewsk = sk_prot_alloc(prot, priority, sk->sk_family);\n\tif (newsk != NULL) {\n\t\tstruct sk_filter *filter;\n\n\t\tsock_copy(newsk, sk);\n\n\t\tnewsk->sk_prot_creator = prot;\n\n\t\t/* SANITY */\n\t\tif (likely(newsk->sk_net_refcnt))\n\t\t\tget_net(sock_net(newsk));\n\t\tsk_node_init(&newsk->sk_node);\n\t\tsock_lock_init(newsk);\n\t\tbh_lock_sock(newsk);\n\t\tnewsk->sk_backlog.head\t= newsk->sk_backlog.tail = NULL;\n\t\tnewsk->sk_backlog.len = 0;\n\n\t\tatomic_set(&newsk->sk_rmem_alloc, 0);\n\t\t/*\n\t\t * sk_wmem_alloc set to one (see sk_free() and sock_wfree())\n\t\t */\n\t\trefcount_set(&newsk->sk_wmem_alloc, 1);\n\t\tatomic_set(&newsk->sk_omem_alloc, 0);\n\t\tsk_init_common(newsk);\n\n\t\tnewsk->sk_dst_cache\t= NULL;\n\t\tnewsk->sk_dst_pending_confirm = 0;\n\t\tnewsk->sk_wmem_queued\t= 0;\n\t\tnewsk->sk_forward_alloc = 0;\n\t\tatomic_set(&newsk->sk_drops, 0);\n\t\tnewsk->sk_send_head\t= NULL;\n\t\tnewsk->sk_userlocks\t= sk->sk_userlocks & ~SOCK_BINDPORT_LOCK;\n\t\tatomic_set(&newsk->sk_zckey, 0);\n\n\t\tsock_reset_flag(newsk, SOCK_DONE);\n\n\t\t/* sk->sk_memcg will be populated at accept() time */\n\t\tnewsk->sk_memcg = NULL;\n\n\t\tcgroup_sk_clone(&newsk->sk_cgrp_data);\n\n\t\trcu_read_lock();\n\t\tfilter = rcu_dereference(sk->sk_filter);\n\t\tif (filter != NULL)\n\t\t\t/* though it's an empty new sock, the charging may fail\n\t\t\t * if sysctl_optmem_max was changed between creation of\n\t\t\t * original socket and cloning\n\t\t\t */\n\t\t\tis_charged = sk_filter_charge(newsk, filter);\n\t\tRCU_INIT_POINTER(newsk->sk_filter, filter);\n\t\trcu_read_unlock();\n\n\t\tif (unlikely(!is_charged || xfrm_sk_clone_policy(newsk, sk))) {\n\t\t\t/* We need to make sure that we don't uncharge the new\n\t\t\t * socket if we couldn't charge it in the first place\n\t\t\t * as otherwise we uncharge the parent's filter.\n\t\t\t */\n\t\t\tif (!is_charged)\n\t\t\t\tRCU_INIT_POINTER(newsk->sk_filter, NULL);\n\t\t\tsk_free_unlock_clone(newsk);\n\t\t\tnewsk = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tRCU_INIT_POINTER(newsk->sk_reuseport_cb, NULL);\n\n\t\tif (bpf_sk_storage_clone(sk, newsk)) {\n\t\t\tsk_free_unlock_clone(newsk);\n\t\t\tnewsk = NULL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Clear sk_user_data if parent had the pointer tagged\n\t\t * as not suitable for copying when cloning.\n\t\t */\n\t\tif (sk_user_data_is_nocopy(newsk))\n\t\t\tnewsk->sk_user_data = NULL;\n\n\t\tnewsk->sk_err\t   = 0;\n\t\tnewsk->sk_err_soft = 0;\n\t\tnewsk->sk_priority = 0;\n\t\tnewsk->sk_incoming_cpu = raw_smp_processor_id();\n\t\tif (likely(newsk->sk_net_refcnt))\n\t\t\tsock_inuse_add(sock_net(newsk), 1);\n\n\t\t/*\n\t\t * Before updating sk_refcnt, we must commit prior changes to memory\n\t\t * (Documentation/RCU/rculist_nulls.txt for details)\n\t\t */\n\t\tsmp_wmb();\n\t\trefcount_set(&newsk->sk_refcnt, 2);\n\n\t\t/*\n\t\t * Increment the counter in the same struct proto as the master\n\t\t * sock (sk_refcnt_debug_inc uses newsk->sk_prot->socks, that\n\t\t * is the same as sk->sk_prot->socks, as this field was copied\n\t\t * with memcpy).\n\t\t *\n\t\t * This _changes_ the previous behaviour, where\n\t\t * tcp_create_openreq_child always was incrementing the\n\t\t * equivalent to tcp_prot->socks (inet_sock_nr), so this have\n\t\t * to be taken into account in all callers. -acme\n\t\t */\n\t\tsk_refcnt_debug_inc(newsk);\n\t\tsk_set_socket(newsk, NULL);\n\t\tsk_tx_queue_clear(newsk);\n\t\tRCU_INIT_POINTER(newsk->sk_wq, NULL);\n\n\t\tif (newsk->sk_prot->sockets_allocated)\n\t\t\tsk_sockets_allocated_inc(newsk);\n\n\t\tif (sock_needs_netstamp(sk) &&\n\t\t    newsk->sk_flags & SK_FLAGS_TIMESTAMP)\n\t\t\tnet_enable_timestamp();\n\t}\nout:\n\treturn newsk;\n}",
        "patch": "--- code before\n+++ code after\n@@ -43,7 +43,7 @@\n \t\t/* sk->sk_memcg will be populated at accept() time */\n \t\tnewsk->sk_memcg = NULL;\n \n-\t\tcgroup_sk_alloc(&newsk->sk_cgrp_data);\n+\t\tcgroup_sk_clone(&newsk->sk_cgrp_data);\n \n \t\trcu_read_lock();\n \t\tfilter = rcu_dereference(sk->sk_filter);",
        "function_modified_lines": {
            "added": [
                "\t\tcgroup_sk_clone(&newsk->sk_cgrp_data);"
            ],
            "deleted": [
                "\t\tcgroup_sk_alloc(&newsk->sk_cgrp_data);"
            ]
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "A flaw null pointer dereference in the Linux kernel cgroupv2 subsystem in versions before 5.7.10 was found in the way when reboot the system. A local user could use this flaw to crash the system or escalate their privileges on the system.",
        "id": 2518
    },
    {
        "cve_id": "CVE-2023-2166",
        "code_before_change": "static int can_rcv(struct sk_buff *skb, struct net_device *dev,\n\t\t   struct packet_type *pt, struct net_device *orig_dev)\n{\n\tif (unlikely(dev->type != ARPHRD_CAN || (!can_is_can_skb(skb)))) {\n\t\tpr_warn_once(\"PF_CAN: dropped non conform CAN skbuff: dev type %d, len %d\\n\",\n\t\t\t     dev->type, skb->len);\n\n\t\tkfree_skb(skb);\n\t\treturn NET_RX_DROP;\n\t}\n\n\tcan_receive(skb, dev);\n\treturn NET_RX_SUCCESS;\n}",
        "code_after_change": "static int can_rcv(struct sk_buff *skb, struct net_device *dev,\n\t\t   struct packet_type *pt, struct net_device *orig_dev)\n{\n\tif (unlikely(dev->type != ARPHRD_CAN || !can_get_ml_priv(dev) || !can_is_can_skb(skb))) {\n\t\tpr_warn_once(\"PF_CAN: dropped non conform CAN skbuff: dev type %d, len %d\\n\",\n\t\t\t     dev->type, skb->len);\n\n\t\tkfree_skb(skb);\n\t\treturn NET_RX_DROP;\n\t}\n\n\tcan_receive(skb, dev);\n\treturn NET_RX_SUCCESS;\n}",
        "patch": "--- code before\n+++ code after\n@@ -1,7 +1,7 @@\n static int can_rcv(struct sk_buff *skb, struct net_device *dev,\n \t\t   struct packet_type *pt, struct net_device *orig_dev)\n {\n-\tif (unlikely(dev->type != ARPHRD_CAN || (!can_is_can_skb(skb)))) {\n+\tif (unlikely(dev->type != ARPHRD_CAN || !can_get_ml_priv(dev) || !can_is_can_skb(skb))) {\n \t\tpr_warn_once(\"PF_CAN: dropped non conform CAN skbuff: dev type %d, len %d\\n\",\n \t\t\t     dev->type, skb->len);\n ",
        "function_modified_lines": {
            "added": [
                "\tif (unlikely(dev->type != ARPHRD_CAN || !can_get_ml_priv(dev) || !can_is_can_skb(skb))) {"
            ],
            "deleted": [
                "\tif (unlikely(dev->type != ARPHRD_CAN || (!can_is_can_skb(skb)))) {"
            ]
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "A null pointer dereference issue was found in can protocol in net/can/af_can.c in the Linux before Linux. ml_priv may not be initialized in the receive path of CAN frames. A local user could use this flaw to crash the system or potentially cause a denial of service.",
        "id": 3926
    },
    {
        "cve_id": "CVE-2022-3112",
        "code_before_change": "static int\nesparser_queue(struct amvdec_session *sess, struct vb2_v4l2_buffer *vbuf)\n{\n\tint ret;\n\tstruct vb2_buffer *vb = &vbuf->vb2_buf;\n\tstruct amvdec_core *core = sess->core;\n\tstruct amvdec_codec_ops *codec_ops = sess->fmt_out->codec_ops;\n\tu32 payload_size = vb2_get_plane_payload(vb, 0);\n\tdma_addr_t phy = vb2_dma_contig_plane_dma_addr(vb, 0);\n\tu32 num_dst_bufs = 0;\n\tu32 offset;\n\tu32 pad_size;\n\n\t/*\n\t * When max ref frame is held by VP9, this should be -= 3 to prevent a\n\t * shortage of CAPTURE buffers on the decoder side.\n\t * For the future, a good enhancement of the way this is handled could\n\t * be to notify new capture buffers to the decoding modules, so that\n\t * they could pause when there is no capture buffer available and\n\t * resume on this notification.\n\t */\n\tif (sess->fmt_out->pixfmt == V4L2_PIX_FMT_VP9) {\n\t\tif (codec_ops->num_pending_bufs)\n\t\t\tnum_dst_bufs = codec_ops->num_pending_bufs(sess);\n\n\t\tnum_dst_bufs += v4l2_m2m_num_dst_bufs_ready(sess->m2m_ctx);\n\t\tif (sess->fmt_out->pixfmt == V4L2_PIX_FMT_VP9)\n\t\t\tnum_dst_bufs -= 3;\n\n\t\tif (esparser_vififo_get_free_space(sess) < payload_size ||\n\t\t    atomic_read(&sess->esparser_queued_bufs) >= num_dst_bufs)\n\t\t\treturn -EAGAIN;\n\t} else if (esparser_vififo_get_free_space(sess) < payload_size) {\n\t\treturn -EAGAIN;\n\t}\n\n\tv4l2_m2m_src_buf_remove_by_buf(sess->m2m_ctx, vbuf);\n\n\toffset = esparser_get_offset(sess);\n\n\tamvdec_add_ts(sess, vb->timestamp, vbuf->timecode, offset, vbuf->flags);\n\tdev_dbg(core->dev, \"esparser: ts = %llu pld_size = %u offset = %08X flags = %08X\\n\",\n\t\tvb->timestamp, payload_size, offset, vbuf->flags);\n\n\tvbuf->flags = 0;\n\tvbuf->field = V4L2_FIELD_NONE;\n\tvbuf->sequence = sess->sequence_out++;\n\n\tif (sess->fmt_out->pixfmt == V4L2_PIX_FMT_VP9) {\n\t\tpayload_size = vp9_update_header(core, vb);\n\n\t\t/* If unable to alter buffer to add headers */\n\t\tif (payload_size == 0) {\n\t\t\tamvdec_remove_ts(sess, vb->timestamp);\n\t\t\tv4l2_m2m_buf_done(vbuf, VB2_BUF_STATE_ERROR);\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tpad_size = esparser_pad_start_code(core, vb, payload_size);\n\tret = esparser_write_data(core, phy, payload_size + pad_size);\n\n\tif (ret <= 0) {\n\t\tdev_warn(core->dev, \"esparser: input parsing error\\n\");\n\t\tamvdec_remove_ts(sess, vb->timestamp);\n\t\tv4l2_m2m_buf_done(vbuf, VB2_BUF_STATE_ERROR);\n\t\tamvdec_write_parser(core, PARSER_FETCH_CMD, 0);\n\n\t\treturn 0;\n\t}\n\n\tatomic_inc(&sess->esparser_queued_bufs);\n\tv4l2_m2m_buf_done(vbuf, VB2_BUF_STATE_DONE);\n\n\treturn 0;\n}",
        "code_after_change": "static int\nesparser_queue(struct amvdec_session *sess, struct vb2_v4l2_buffer *vbuf)\n{\n\tint ret;\n\tstruct vb2_buffer *vb = &vbuf->vb2_buf;\n\tstruct amvdec_core *core = sess->core;\n\tstruct amvdec_codec_ops *codec_ops = sess->fmt_out->codec_ops;\n\tu32 payload_size = vb2_get_plane_payload(vb, 0);\n\tdma_addr_t phy = vb2_dma_contig_plane_dma_addr(vb, 0);\n\tu32 num_dst_bufs = 0;\n\tu32 offset;\n\tu32 pad_size;\n\n\t/*\n\t * When max ref frame is held by VP9, this should be -= 3 to prevent a\n\t * shortage of CAPTURE buffers on the decoder side.\n\t * For the future, a good enhancement of the way this is handled could\n\t * be to notify new capture buffers to the decoding modules, so that\n\t * they could pause when there is no capture buffer available and\n\t * resume on this notification.\n\t */\n\tif (sess->fmt_out->pixfmt == V4L2_PIX_FMT_VP9) {\n\t\tif (codec_ops->num_pending_bufs)\n\t\t\tnum_dst_bufs = codec_ops->num_pending_bufs(sess);\n\n\t\tnum_dst_bufs += v4l2_m2m_num_dst_bufs_ready(sess->m2m_ctx);\n\t\tif (sess->fmt_out->pixfmt == V4L2_PIX_FMT_VP9)\n\t\t\tnum_dst_bufs -= 3;\n\n\t\tif (esparser_vififo_get_free_space(sess) < payload_size ||\n\t\t    atomic_read(&sess->esparser_queued_bufs) >= num_dst_bufs)\n\t\t\treturn -EAGAIN;\n\t} else if (esparser_vififo_get_free_space(sess) < payload_size) {\n\t\treturn -EAGAIN;\n\t}\n\n\tv4l2_m2m_src_buf_remove_by_buf(sess->m2m_ctx, vbuf);\n\n\toffset = esparser_get_offset(sess);\n\n\tret = amvdec_add_ts(sess, vb->timestamp, vbuf->timecode, offset, vbuf->flags);\n\tif (ret) {\n\t\tv4l2_m2m_buf_done(vbuf, VB2_BUF_STATE_ERROR);\n\t\treturn ret;\n\t}\n\n\tdev_dbg(core->dev, \"esparser: ts = %llu pld_size = %u offset = %08X flags = %08X\\n\",\n\t\tvb->timestamp, payload_size, offset, vbuf->flags);\n\n\tvbuf->flags = 0;\n\tvbuf->field = V4L2_FIELD_NONE;\n\tvbuf->sequence = sess->sequence_out++;\n\n\tif (sess->fmt_out->pixfmt == V4L2_PIX_FMT_VP9) {\n\t\tpayload_size = vp9_update_header(core, vb);\n\n\t\t/* If unable to alter buffer to add headers */\n\t\tif (payload_size == 0) {\n\t\t\tamvdec_remove_ts(sess, vb->timestamp);\n\t\t\tv4l2_m2m_buf_done(vbuf, VB2_BUF_STATE_ERROR);\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tpad_size = esparser_pad_start_code(core, vb, payload_size);\n\tret = esparser_write_data(core, phy, payload_size + pad_size);\n\n\tif (ret <= 0) {\n\t\tdev_warn(core->dev, \"esparser: input parsing error\\n\");\n\t\tamvdec_remove_ts(sess, vb->timestamp);\n\t\tv4l2_m2m_buf_done(vbuf, VB2_BUF_STATE_ERROR);\n\t\tamvdec_write_parser(core, PARSER_FETCH_CMD, 0);\n\n\t\treturn 0;\n\t}\n\n\tatomic_inc(&sess->esparser_queued_bufs);\n\tv4l2_m2m_buf_done(vbuf, VB2_BUF_STATE_DONE);\n\n\treturn 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -38,7 +38,12 @@\n \n \toffset = esparser_get_offset(sess);\n \n-\tamvdec_add_ts(sess, vb->timestamp, vbuf->timecode, offset, vbuf->flags);\n+\tret = amvdec_add_ts(sess, vb->timestamp, vbuf->timecode, offset, vbuf->flags);\n+\tif (ret) {\n+\t\tv4l2_m2m_buf_done(vbuf, VB2_BUF_STATE_ERROR);\n+\t\treturn ret;\n+\t}\n+\n \tdev_dbg(core->dev, \"esparser: ts = %llu pld_size = %u offset = %08X flags = %08X\\n\",\n \t\tvb->timestamp, payload_size, offset, vbuf->flags);\n ",
        "function_modified_lines": {
            "added": [
                "\tret = amvdec_add_ts(sess, vb->timestamp, vbuf->timecode, offset, vbuf->flags);",
                "\tif (ret) {",
                "\t\tv4l2_m2m_buf_done(vbuf, VB2_BUF_STATE_ERROR);",
                "\t\treturn ret;",
                "\t}",
                ""
            ],
            "deleted": [
                "\tamvdec_add_ts(sess, vb->timestamp, vbuf->timecode, offset, vbuf->flags);"
            ]
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "An issue was discovered in the Linux kernel through 5.16-rc6. amvdec_set_canvases in drivers/staging/media/meson/vdec/vdec_helpers.c lacks check of the return value of kzalloc() and will cause the null pointer dereference.",
        "id": 3557
    },
    {
        "cve_id": "CVE-2016-3070",
        "code_before_change": "int migrate_page_move_mapping(struct address_space *mapping,\n\t\tstruct page *newpage, struct page *page,\n\t\tstruct buffer_head *head, enum migrate_mode mode,\n\t\tint extra_count)\n{\n\tint expected_count = 1 + extra_count;\n\tvoid **pslot;\n\n\tif (!mapping) {\n\t\t/* Anonymous page without mapping */\n\t\tif (page_count(page) != expected_count)\n\t\t\treturn -EAGAIN;\n\n\t\t/* No turning back from here */\n\t\tset_page_memcg(newpage, page_memcg(page));\n\t\tnewpage->index = page->index;\n\t\tnewpage->mapping = page->mapping;\n\t\tif (PageSwapBacked(page))\n\t\t\tSetPageSwapBacked(newpage);\n\n\t\treturn MIGRATEPAGE_SUCCESS;\n\t}\n\n\tspin_lock_irq(&mapping->tree_lock);\n\n\tpslot = radix_tree_lookup_slot(&mapping->page_tree,\n \t\t\t\t\tpage_index(page));\n\n\texpected_count += 1 + page_has_private(page);\n\tif (page_count(page) != expected_count ||\n\t\tradix_tree_deref_slot_protected(pslot, &mapping->tree_lock) != page) {\n\t\tspin_unlock_irq(&mapping->tree_lock);\n\t\treturn -EAGAIN;\n\t}\n\n\tif (!page_freeze_refs(page, expected_count)) {\n\t\tspin_unlock_irq(&mapping->tree_lock);\n\t\treturn -EAGAIN;\n\t}\n\n\t/*\n\t * In the async migration case of moving a page with buffers, lock the\n\t * buffers using trylock before the mapping is moved. If the mapping\n\t * was moved, we later failed to lock the buffers and could not move\n\t * the mapping back due to an elevated page count, we would have to\n\t * block waiting on other references to be dropped.\n\t */\n\tif (mode == MIGRATE_ASYNC && head &&\n\t\t\t!buffer_migrate_lock_buffers(head, mode)) {\n\t\tpage_unfreeze_refs(page, expected_count);\n\t\tspin_unlock_irq(&mapping->tree_lock);\n\t\treturn -EAGAIN;\n\t}\n\n\t/*\n\t * Now we know that no one else is looking at the page:\n\t * no turning back from here.\n\t */\n\tset_page_memcg(newpage, page_memcg(page));\n\tnewpage->index = page->index;\n\tnewpage->mapping = page->mapping;\n\tif (PageSwapBacked(page))\n\t\tSetPageSwapBacked(newpage);\n\n\tget_page(newpage);\t/* add cache reference */\n\tif (PageSwapCache(page)) {\n\t\tSetPageSwapCache(newpage);\n\t\tset_page_private(newpage, page_private(page));\n\t}\n\n\tradix_tree_replace_slot(pslot, newpage);\n\n\t/*\n\t * Drop cache reference from old page by unfreezing\n\t * to one less reference.\n\t * We know this isn't the last reference.\n\t */\n\tpage_unfreeze_refs(page, expected_count - 1);\n\n\t/*\n\t * If moved to a different zone then also account\n\t * the page for that zone. Other VM counters will be\n\t * taken care of when we establish references to the\n\t * new page and drop references to the old page.\n\t *\n\t * Note that anonymous pages are accounted for\n\t * via NR_FILE_PAGES and NR_ANON_PAGES if they\n\t * are mapped to swap space.\n\t */\n\t__dec_zone_page_state(page, NR_FILE_PAGES);\n\t__inc_zone_page_state(newpage, NR_FILE_PAGES);\n\tif (!PageSwapCache(page) && PageSwapBacked(page)) {\n\t\t__dec_zone_page_state(page, NR_SHMEM);\n\t\t__inc_zone_page_state(newpage, NR_SHMEM);\n\t}\n\tspin_unlock_irq(&mapping->tree_lock);\n\n\treturn MIGRATEPAGE_SUCCESS;\n}",
        "code_after_change": "int migrate_page_move_mapping(struct address_space *mapping,\n\t\tstruct page *newpage, struct page *page,\n\t\tstruct buffer_head *head, enum migrate_mode mode,\n\t\tint extra_count)\n{\n\tstruct zone *oldzone, *newzone;\n\tint dirty;\n\tint expected_count = 1 + extra_count;\n\tvoid **pslot;\n\n\tif (!mapping) {\n\t\t/* Anonymous page without mapping */\n\t\tif (page_count(page) != expected_count)\n\t\t\treturn -EAGAIN;\n\n\t\t/* No turning back from here */\n\t\tset_page_memcg(newpage, page_memcg(page));\n\t\tnewpage->index = page->index;\n\t\tnewpage->mapping = page->mapping;\n\t\tif (PageSwapBacked(page))\n\t\t\tSetPageSwapBacked(newpage);\n\n\t\treturn MIGRATEPAGE_SUCCESS;\n\t}\n\n\toldzone = page_zone(page);\n\tnewzone = page_zone(newpage);\n\n\tspin_lock_irq(&mapping->tree_lock);\n\n\tpslot = radix_tree_lookup_slot(&mapping->page_tree,\n \t\t\t\t\tpage_index(page));\n\n\texpected_count += 1 + page_has_private(page);\n\tif (page_count(page) != expected_count ||\n\t\tradix_tree_deref_slot_protected(pslot, &mapping->tree_lock) != page) {\n\t\tspin_unlock_irq(&mapping->tree_lock);\n\t\treturn -EAGAIN;\n\t}\n\n\tif (!page_freeze_refs(page, expected_count)) {\n\t\tspin_unlock_irq(&mapping->tree_lock);\n\t\treturn -EAGAIN;\n\t}\n\n\t/*\n\t * In the async migration case of moving a page with buffers, lock the\n\t * buffers using trylock before the mapping is moved. If the mapping\n\t * was moved, we later failed to lock the buffers and could not move\n\t * the mapping back due to an elevated page count, we would have to\n\t * block waiting on other references to be dropped.\n\t */\n\tif (mode == MIGRATE_ASYNC && head &&\n\t\t\t!buffer_migrate_lock_buffers(head, mode)) {\n\t\tpage_unfreeze_refs(page, expected_count);\n\t\tspin_unlock_irq(&mapping->tree_lock);\n\t\treturn -EAGAIN;\n\t}\n\n\t/*\n\t * Now we know that no one else is looking at the page:\n\t * no turning back from here.\n\t */\n\tset_page_memcg(newpage, page_memcg(page));\n\tnewpage->index = page->index;\n\tnewpage->mapping = page->mapping;\n\tif (PageSwapBacked(page))\n\t\tSetPageSwapBacked(newpage);\n\n\tget_page(newpage);\t/* add cache reference */\n\tif (PageSwapCache(page)) {\n\t\tSetPageSwapCache(newpage);\n\t\tset_page_private(newpage, page_private(page));\n\t}\n\n\t/* Move dirty while page refs frozen and newpage not yet exposed */\n\tdirty = PageDirty(page);\n\tif (dirty) {\n\t\tClearPageDirty(page);\n\t\tSetPageDirty(newpage);\n\t}\n\n\tradix_tree_replace_slot(pslot, newpage);\n\n\t/*\n\t * Drop cache reference from old page by unfreezing\n\t * to one less reference.\n\t * We know this isn't the last reference.\n\t */\n\tpage_unfreeze_refs(page, expected_count - 1);\n\n\tspin_unlock(&mapping->tree_lock);\n\t/* Leave irq disabled to prevent preemption while updating stats */\n\n\t/*\n\t * If moved to a different zone then also account\n\t * the page for that zone. Other VM counters will be\n\t * taken care of when we establish references to the\n\t * new page and drop references to the old page.\n\t *\n\t * Note that anonymous pages are accounted for\n\t * via NR_FILE_PAGES and NR_ANON_PAGES if they\n\t * are mapped to swap space.\n\t */\n\tif (newzone != oldzone) {\n\t\t__dec_zone_state(oldzone, NR_FILE_PAGES);\n\t\t__inc_zone_state(newzone, NR_FILE_PAGES);\n\t\tif (PageSwapBacked(page) && !PageSwapCache(page)) {\n\t\t\t__dec_zone_state(oldzone, NR_SHMEM);\n\t\t\t__inc_zone_state(newzone, NR_SHMEM);\n\t\t}\n\t\tif (dirty && mapping_cap_account_dirty(mapping)) {\n\t\t\t__dec_zone_state(oldzone, NR_FILE_DIRTY);\n\t\t\t__inc_zone_state(newzone, NR_FILE_DIRTY);\n\t\t}\n\t}\n\tlocal_irq_enable();\n\n\treturn MIGRATEPAGE_SUCCESS;\n}",
        "patch": "--- code before\n+++ code after\n@@ -3,6 +3,8 @@\n \t\tstruct buffer_head *head, enum migrate_mode mode,\n \t\tint extra_count)\n {\n+\tstruct zone *oldzone, *newzone;\n+\tint dirty;\n \tint expected_count = 1 + extra_count;\n \tvoid **pslot;\n \n@@ -20,6 +22,9 @@\n \n \t\treturn MIGRATEPAGE_SUCCESS;\n \t}\n+\n+\toldzone = page_zone(page);\n+\tnewzone = page_zone(newpage);\n \n \tspin_lock_irq(&mapping->tree_lock);\n \n@@ -68,6 +73,13 @@\n \t\tset_page_private(newpage, page_private(page));\n \t}\n \n+\t/* Move dirty while page refs frozen and newpage not yet exposed */\n+\tdirty = PageDirty(page);\n+\tif (dirty) {\n+\t\tClearPageDirty(page);\n+\t\tSetPageDirty(newpage);\n+\t}\n+\n \tradix_tree_replace_slot(pslot, newpage);\n \n \t/*\n@@ -76,6 +88,9 @@\n \t * We know this isn't the last reference.\n \t */\n \tpage_unfreeze_refs(page, expected_count - 1);\n+\n+\tspin_unlock(&mapping->tree_lock);\n+\t/* Leave irq disabled to prevent preemption while updating stats */\n \n \t/*\n \t * If moved to a different zone then also account\n@@ -87,13 +102,19 @@\n \t * via NR_FILE_PAGES and NR_ANON_PAGES if they\n \t * are mapped to swap space.\n \t */\n-\t__dec_zone_page_state(page, NR_FILE_PAGES);\n-\t__inc_zone_page_state(newpage, NR_FILE_PAGES);\n-\tif (!PageSwapCache(page) && PageSwapBacked(page)) {\n-\t\t__dec_zone_page_state(page, NR_SHMEM);\n-\t\t__inc_zone_page_state(newpage, NR_SHMEM);\n+\tif (newzone != oldzone) {\n+\t\t__dec_zone_state(oldzone, NR_FILE_PAGES);\n+\t\t__inc_zone_state(newzone, NR_FILE_PAGES);\n+\t\tif (PageSwapBacked(page) && !PageSwapCache(page)) {\n+\t\t\t__dec_zone_state(oldzone, NR_SHMEM);\n+\t\t\t__inc_zone_state(newzone, NR_SHMEM);\n+\t\t}\n+\t\tif (dirty && mapping_cap_account_dirty(mapping)) {\n+\t\t\t__dec_zone_state(oldzone, NR_FILE_DIRTY);\n+\t\t\t__inc_zone_state(newzone, NR_FILE_DIRTY);\n+\t\t}\n \t}\n-\tspin_unlock_irq(&mapping->tree_lock);\n+\tlocal_irq_enable();\n \n \treturn MIGRATEPAGE_SUCCESS;\n }",
        "function_modified_lines": {
            "added": [
                "\tstruct zone *oldzone, *newzone;",
                "\tint dirty;",
                "",
                "\toldzone = page_zone(page);",
                "\tnewzone = page_zone(newpage);",
                "\t/* Move dirty while page refs frozen and newpage not yet exposed */",
                "\tdirty = PageDirty(page);",
                "\tif (dirty) {",
                "\t\tClearPageDirty(page);",
                "\t\tSetPageDirty(newpage);",
                "\t}",
                "",
                "",
                "\tspin_unlock(&mapping->tree_lock);",
                "\t/* Leave irq disabled to prevent preemption while updating stats */",
                "\tif (newzone != oldzone) {",
                "\t\t__dec_zone_state(oldzone, NR_FILE_PAGES);",
                "\t\t__inc_zone_state(newzone, NR_FILE_PAGES);",
                "\t\tif (PageSwapBacked(page) && !PageSwapCache(page)) {",
                "\t\t\t__dec_zone_state(oldzone, NR_SHMEM);",
                "\t\t\t__inc_zone_state(newzone, NR_SHMEM);",
                "\t\t}",
                "\t\tif (dirty && mapping_cap_account_dirty(mapping)) {",
                "\t\t\t__dec_zone_state(oldzone, NR_FILE_DIRTY);",
                "\t\t\t__inc_zone_state(newzone, NR_FILE_DIRTY);",
                "\t\t}",
                "\tlocal_irq_enable();"
            ],
            "deleted": [
                "\t__dec_zone_page_state(page, NR_FILE_PAGES);",
                "\t__inc_zone_page_state(newpage, NR_FILE_PAGES);",
                "\tif (!PageSwapCache(page) && PageSwapBacked(page)) {",
                "\t\t__dec_zone_page_state(page, NR_SHMEM);",
                "\t\t__inc_zone_page_state(newpage, NR_SHMEM);",
                "\tspin_unlock_irq(&mapping->tree_lock);"
            ]
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "The trace_writeback_dirty_page implementation in include/trace/events/writeback.h in the Linux kernel before 4.4 improperly interacts with mm/migrate.c, which allows local users to cause a denial of service (NULL pointer dereference and system crash) or possibly have unspecified other impact by triggering a certain page move.",
        "id": 960
    },
    {
        "cve_id": "CVE-2019-19036",
        "code_before_change": "static int check_leaf(struct extent_buffer *leaf, bool check_item_data)\n{\n\tstruct btrfs_fs_info *fs_info = leaf->fs_info;\n\t/* No valid key type is 0, so all key should be larger than this key */\n\tstruct btrfs_key prev_key = {0, 0, 0};\n\tstruct btrfs_key key;\n\tu32 nritems = btrfs_header_nritems(leaf);\n\tint slot;\n\n\tif (btrfs_header_level(leaf) != 0) {\n\t\tgeneric_err(leaf, 0,\n\t\t\t\"invalid level for leaf, have %d expect 0\",\n\t\t\tbtrfs_header_level(leaf));\n\t\treturn -EUCLEAN;\n\t}\n\n\t/*\n\t * Extent buffers from a relocation tree have a owner field that\n\t * corresponds to the subvolume tree they are based on. So just from an\n\t * extent buffer alone we can not find out what is the id of the\n\t * corresponding subvolume tree, so we can not figure out if the extent\n\t * buffer corresponds to the root of the relocation tree or not. So\n\t * skip this check for relocation trees.\n\t */\n\tif (nritems == 0 && !btrfs_header_flag(leaf, BTRFS_HEADER_FLAG_RELOC)) {\n\t\tu64 owner = btrfs_header_owner(leaf);\n\n\t\t/* These trees must never be empty */\n\t\tif (owner == BTRFS_ROOT_TREE_OBJECTID ||\n\t\t    owner == BTRFS_CHUNK_TREE_OBJECTID ||\n\t\t    owner == BTRFS_EXTENT_TREE_OBJECTID ||\n\t\t    owner == BTRFS_DEV_TREE_OBJECTID ||\n\t\t    owner == BTRFS_FS_TREE_OBJECTID ||\n\t\t    owner == BTRFS_DATA_RELOC_TREE_OBJECTID) {\n\t\t\tgeneric_err(leaf, 0,\n\t\t\t\"invalid root, root %llu must never be empty\",\n\t\t\t\t    owner);\n\t\t\treturn -EUCLEAN;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (nritems == 0)\n\t\treturn 0;\n\n\t/*\n\t * Check the following things to make sure this is a good leaf, and\n\t * leaf users won't need to bother with similar sanity checks:\n\t *\n\t * 1) key ordering\n\t * 2) item offset and size\n\t *    No overlap, no hole, all inside the leaf.\n\t * 3) item content\n\t *    If possible, do comprehensive sanity check.\n\t *    NOTE: All checks must only rely on the item data itself.\n\t */\n\tfor (slot = 0; slot < nritems; slot++) {\n\t\tu32 item_end_expected;\n\t\tint ret;\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\n\t\t/* Make sure the keys are in the right order */\n\t\tif (btrfs_comp_cpu_keys(&prev_key, &key) >= 0) {\n\t\t\tgeneric_err(leaf, slot,\n\t\"bad key order, prev (%llu %u %llu) current (%llu %u %llu)\",\n\t\t\t\tprev_key.objectid, prev_key.type,\n\t\t\t\tprev_key.offset, key.objectid, key.type,\n\t\t\t\tkey.offset);\n\t\t\treturn -EUCLEAN;\n\t\t}\n\n\t\t/*\n\t\t * Make sure the offset and ends are right, remember that the\n\t\t * item data starts at the end of the leaf and grows towards the\n\t\t * front.\n\t\t */\n\t\tif (slot == 0)\n\t\t\titem_end_expected = BTRFS_LEAF_DATA_SIZE(fs_info);\n\t\telse\n\t\t\titem_end_expected = btrfs_item_offset_nr(leaf,\n\t\t\t\t\t\t\t\t slot - 1);\n\t\tif (btrfs_item_end_nr(leaf, slot) != item_end_expected) {\n\t\t\tgeneric_err(leaf, slot,\n\t\t\t\t\"unexpected item end, have %u expect %u\",\n\t\t\t\tbtrfs_item_end_nr(leaf, slot),\n\t\t\t\titem_end_expected);\n\t\t\treturn -EUCLEAN;\n\t\t}\n\n\t\t/*\n\t\t * Check to make sure that we don't point outside of the leaf,\n\t\t * just in case all the items are consistent to each other, but\n\t\t * all point outside of the leaf.\n\t\t */\n\t\tif (btrfs_item_end_nr(leaf, slot) >\n\t\t    BTRFS_LEAF_DATA_SIZE(fs_info)) {\n\t\t\tgeneric_err(leaf, slot,\n\t\t\t\"slot end outside of leaf, have %u expect range [0, %u]\",\n\t\t\t\tbtrfs_item_end_nr(leaf, slot),\n\t\t\t\tBTRFS_LEAF_DATA_SIZE(fs_info));\n\t\t\treturn -EUCLEAN;\n\t\t}\n\n\t\t/* Also check if the item pointer overlaps with btrfs item. */\n\t\tif (btrfs_item_nr_offset(slot) + sizeof(struct btrfs_item) >\n\t\t    btrfs_item_ptr_offset(leaf, slot)) {\n\t\t\tgeneric_err(leaf, slot,\n\t\t\"slot overlaps with its data, item end %lu data start %lu\",\n\t\t\t\tbtrfs_item_nr_offset(slot) +\n\t\t\t\tsizeof(struct btrfs_item),\n\t\t\t\tbtrfs_item_ptr_offset(leaf, slot));\n\t\t\treturn -EUCLEAN;\n\t\t}\n\n\t\tif (check_item_data) {\n\t\t\t/*\n\t\t\t * Check if the item size and content meet other\n\t\t\t * criteria\n\t\t\t */\n\t\t\tret = check_leaf_item(leaf, &key, slot, &prev_key);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tprev_key.objectid = key.objectid;\n\t\tprev_key.type = key.type;\n\t\tprev_key.offset = key.offset;\n\t}\n\n\treturn 0;\n}",
        "code_after_change": "static int check_leaf(struct extent_buffer *leaf, bool check_item_data)\n{\n\tstruct btrfs_fs_info *fs_info = leaf->fs_info;\n\t/* No valid key type is 0, so all key should be larger than this key */\n\tstruct btrfs_key prev_key = {0, 0, 0};\n\tstruct btrfs_key key;\n\tu32 nritems = btrfs_header_nritems(leaf);\n\tint slot;\n\n\tif (btrfs_header_level(leaf) != 0) {\n\t\tgeneric_err(leaf, 0,\n\t\t\t\"invalid level for leaf, have %d expect 0\",\n\t\t\tbtrfs_header_level(leaf));\n\t\treturn -EUCLEAN;\n\t}\n\n\t/*\n\t * Extent buffers from a relocation tree have a owner field that\n\t * corresponds to the subvolume tree they are based on. So just from an\n\t * extent buffer alone we can not find out what is the id of the\n\t * corresponding subvolume tree, so we can not figure out if the extent\n\t * buffer corresponds to the root of the relocation tree or not. So\n\t * skip this check for relocation trees.\n\t */\n\tif (nritems == 0 && !btrfs_header_flag(leaf, BTRFS_HEADER_FLAG_RELOC)) {\n\t\tu64 owner = btrfs_header_owner(leaf);\n\n\t\t/* These trees must never be empty */\n\t\tif (owner == BTRFS_ROOT_TREE_OBJECTID ||\n\t\t    owner == BTRFS_CHUNK_TREE_OBJECTID ||\n\t\t    owner == BTRFS_EXTENT_TREE_OBJECTID ||\n\t\t    owner == BTRFS_DEV_TREE_OBJECTID ||\n\t\t    owner == BTRFS_FS_TREE_OBJECTID ||\n\t\t    owner == BTRFS_DATA_RELOC_TREE_OBJECTID) {\n\t\t\tgeneric_err(leaf, 0,\n\t\t\t\"invalid root, root %llu must never be empty\",\n\t\t\t\t    owner);\n\t\t\treturn -EUCLEAN;\n\t\t}\n\t\t/* Unknown tree */\n\t\tif (owner == 0) {\n\t\t\tgeneric_err(leaf, 0,\n\t\t\t\t\"invalid owner, root 0 is not defined\");\n\t\t\treturn -EUCLEAN;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (nritems == 0)\n\t\treturn 0;\n\n\t/*\n\t * Check the following things to make sure this is a good leaf, and\n\t * leaf users won't need to bother with similar sanity checks:\n\t *\n\t * 1) key ordering\n\t * 2) item offset and size\n\t *    No overlap, no hole, all inside the leaf.\n\t * 3) item content\n\t *    If possible, do comprehensive sanity check.\n\t *    NOTE: All checks must only rely on the item data itself.\n\t */\n\tfor (slot = 0; slot < nritems; slot++) {\n\t\tu32 item_end_expected;\n\t\tint ret;\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\n\t\t/* Make sure the keys are in the right order */\n\t\tif (btrfs_comp_cpu_keys(&prev_key, &key) >= 0) {\n\t\t\tgeneric_err(leaf, slot,\n\t\"bad key order, prev (%llu %u %llu) current (%llu %u %llu)\",\n\t\t\t\tprev_key.objectid, prev_key.type,\n\t\t\t\tprev_key.offset, key.objectid, key.type,\n\t\t\t\tkey.offset);\n\t\t\treturn -EUCLEAN;\n\t\t}\n\n\t\t/*\n\t\t * Make sure the offset and ends are right, remember that the\n\t\t * item data starts at the end of the leaf and grows towards the\n\t\t * front.\n\t\t */\n\t\tif (slot == 0)\n\t\t\titem_end_expected = BTRFS_LEAF_DATA_SIZE(fs_info);\n\t\telse\n\t\t\titem_end_expected = btrfs_item_offset_nr(leaf,\n\t\t\t\t\t\t\t\t slot - 1);\n\t\tif (btrfs_item_end_nr(leaf, slot) != item_end_expected) {\n\t\t\tgeneric_err(leaf, slot,\n\t\t\t\t\"unexpected item end, have %u expect %u\",\n\t\t\t\tbtrfs_item_end_nr(leaf, slot),\n\t\t\t\titem_end_expected);\n\t\t\treturn -EUCLEAN;\n\t\t}\n\n\t\t/*\n\t\t * Check to make sure that we don't point outside of the leaf,\n\t\t * just in case all the items are consistent to each other, but\n\t\t * all point outside of the leaf.\n\t\t */\n\t\tif (btrfs_item_end_nr(leaf, slot) >\n\t\t    BTRFS_LEAF_DATA_SIZE(fs_info)) {\n\t\t\tgeneric_err(leaf, slot,\n\t\t\t\"slot end outside of leaf, have %u expect range [0, %u]\",\n\t\t\t\tbtrfs_item_end_nr(leaf, slot),\n\t\t\t\tBTRFS_LEAF_DATA_SIZE(fs_info));\n\t\t\treturn -EUCLEAN;\n\t\t}\n\n\t\t/* Also check if the item pointer overlaps with btrfs item. */\n\t\tif (btrfs_item_nr_offset(slot) + sizeof(struct btrfs_item) >\n\t\t    btrfs_item_ptr_offset(leaf, slot)) {\n\t\t\tgeneric_err(leaf, slot,\n\t\t\"slot overlaps with its data, item end %lu data start %lu\",\n\t\t\t\tbtrfs_item_nr_offset(slot) +\n\t\t\t\tsizeof(struct btrfs_item),\n\t\t\t\tbtrfs_item_ptr_offset(leaf, slot));\n\t\t\treturn -EUCLEAN;\n\t\t}\n\n\t\tif (check_item_data) {\n\t\t\t/*\n\t\t\t * Check if the item size and content meet other\n\t\t\t * criteria\n\t\t\t */\n\t\t\tret = check_leaf_item(leaf, &key, slot, &prev_key);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tprev_key.objectid = key.objectid;\n\t\tprev_key.type = key.type;\n\t\tprev_key.offset = key.offset;\n\t}\n\n\treturn 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -35,6 +35,12 @@\n \t\t\tgeneric_err(leaf, 0,\n \t\t\t\"invalid root, root %llu must never be empty\",\n \t\t\t\t    owner);\n+\t\t\treturn -EUCLEAN;\n+\t\t}\n+\t\t/* Unknown tree */\n+\t\tif (owner == 0) {\n+\t\t\tgeneric_err(leaf, 0,\n+\t\t\t\t\"invalid owner, root 0 is not defined\");\n \t\t\treturn -EUCLEAN;\n \t\t}\n \t\treturn 0;",
        "function_modified_lines": {
            "added": [
                "\t\t\treturn -EUCLEAN;",
                "\t\t}",
                "\t\t/* Unknown tree */",
                "\t\tif (owner == 0) {",
                "\t\t\tgeneric_err(leaf, 0,",
                "\t\t\t\t\"invalid owner, root 0 is not defined\");"
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "btrfs_root_node in fs/btrfs/ctree.c in the Linux kernel through 5.3.12 allows a NULL pointer dereference because rcu_dereference(root->node) can be zero.",
        "id": 2121
    },
    {
        "cve_id": "CVE-2017-15274",
        "code_before_change": " */\nSYSCALL_DEFINE5(add_key, const char __user *, _type,\n\t\tconst char __user *, _description,\n\t\tconst void __user *, _payload,\n\t\tsize_t, plen,\n\t\tkey_serial_t, ringid)\n{\n\tkey_ref_t keyring_ref, key_ref;\n\tchar type[32], *description;\n\tvoid *payload;\n\tlong ret;\n\n\tret = -EINVAL;\n\tif (plen > 1024 * 1024 - 1)\n\t\tgoto error;\n\n\t/* draw all the data into kernel space */\n\tret = key_get_type_from_user(type, _type, sizeof(type));\n\tif (ret < 0)\n\t\tgoto error;\n\n\tdescription = NULL;\n\tif (_description) {\n\t\tdescription = strndup_user(_description, KEY_MAX_DESC_SIZE);\n\t\tif (IS_ERR(description)) {\n\t\t\tret = PTR_ERR(description);\n\t\t\tgoto error;\n\t\t}\n\t\tif (!*description) {\n\t\t\tkfree(description);\n\t\t\tdescription = NULL;\n\t\t} else if ((description[0] == '.') &&\n\t\t\t   (strncmp(type, \"keyring\", 7) == 0)) {\n\t\t\tret = -EPERM;\n\t\t\tgoto error2;\n\t\t}\n\t}\n\n\t/* pull the payload in if one was supplied */\n\tpayload = NULL;\n\n\tif (_payload) {\n\t\tret = -ENOMEM;\n\t\tpayload = kvmalloc(plen, GFP_KERNEL);\n\t\tif (!payload)\n\t\t\tgoto error2;\n\n\t\tret = -EFAULT;\n\t\tif (copy_from_user(payload, _payload, plen) != 0)\n\t\t\tgoto error3;\n\t}\n\n\t/* find the target keyring (which must be writable) */\n\tkeyring_ref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_NEED_WRITE);\n\tif (IS_ERR(keyring_ref)) {\n\t\tret = PTR_ERR(keyring_ref);\n\t\tgoto error3;\n\t}\n\n\t/* create or update the requested key and add it to the target\n\t * keyring */\n\tkey_ref = key_create_or_update(keyring_ref, type, description,\n\t\t\t\t       payload, plen, KEY_PERM_UNDEF,\n\t\t\t\t       KEY_ALLOC_IN_QUOTA);\n\tif (!IS_ERR(key_ref)) {\n\t\tret = key_ref_to_ptr(key_ref)->serial;\n\t\tkey_ref_put(key_ref);\n\t}\n\telse {\n\t\tret = PTR_ERR(key_ref);\n\t}\n\n\tkey_ref_put(keyring_ref);\n error3:\n\tkvfree(payload);\n error2:\n\tkfree(description);\n error:\n\treturn ret;\n}",
        "code_after_change": " */\nSYSCALL_DEFINE5(add_key, const char __user *, _type,\n\t\tconst char __user *, _description,\n\t\tconst void __user *, _payload,\n\t\tsize_t, plen,\n\t\tkey_serial_t, ringid)\n{\n\tkey_ref_t keyring_ref, key_ref;\n\tchar type[32], *description;\n\tvoid *payload;\n\tlong ret;\n\n\tret = -EINVAL;\n\tif (plen > 1024 * 1024 - 1)\n\t\tgoto error;\n\n\t/* draw all the data into kernel space */\n\tret = key_get_type_from_user(type, _type, sizeof(type));\n\tif (ret < 0)\n\t\tgoto error;\n\n\tdescription = NULL;\n\tif (_description) {\n\t\tdescription = strndup_user(_description, KEY_MAX_DESC_SIZE);\n\t\tif (IS_ERR(description)) {\n\t\t\tret = PTR_ERR(description);\n\t\t\tgoto error;\n\t\t}\n\t\tif (!*description) {\n\t\t\tkfree(description);\n\t\t\tdescription = NULL;\n\t\t} else if ((description[0] == '.') &&\n\t\t\t   (strncmp(type, \"keyring\", 7) == 0)) {\n\t\t\tret = -EPERM;\n\t\t\tgoto error2;\n\t\t}\n\t}\n\n\t/* pull the payload in if one was supplied */\n\tpayload = NULL;\n\n\tif (plen) {\n\t\tret = -ENOMEM;\n\t\tpayload = kvmalloc(plen, GFP_KERNEL);\n\t\tif (!payload)\n\t\t\tgoto error2;\n\n\t\tret = -EFAULT;\n\t\tif (copy_from_user(payload, _payload, plen) != 0)\n\t\t\tgoto error3;\n\t}\n\n\t/* find the target keyring (which must be writable) */\n\tkeyring_ref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_NEED_WRITE);\n\tif (IS_ERR(keyring_ref)) {\n\t\tret = PTR_ERR(keyring_ref);\n\t\tgoto error3;\n\t}\n\n\t/* create or update the requested key and add it to the target\n\t * keyring */\n\tkey_ref = key_create_or_update(keyring_ref, type, description,\n\t\t\t\t       payload, plen, KEY_PERM_UNDEF,\n\t\t\t\t       KEY_ALLOC_IN_QUOTA);\n\tif (!IS_ERR(key_ref)) {\n\t\tret = key_ref_to_ptr(key_ref)->serial;\n\t\tkey_ref_put(key_ref);\n\t}\n\telse {\n\t\tret = PTR_ERR(key_ref);\n\t}\n\n\tkey_ref_put(keyring_ref);\n error3:\n\tkvfree(payload);\n error2:\n\tkfree(description);\n error:\n\treturn ret;\n}",
        "patch": "--- code before\n+++ code after\n@@ -39,7 +39,7 @@\n \t/* pull the payload in if one was supplied */\n \tpayload = NULL;\n \n-\tif (_payload) {\n+\tif (plen) {\n \t\tret = -ENOMEM;\n \t\tpayload = kvmalloc(plen, GFP_KERNEL);\n \t\tif (!payload)",
        "function_modified_lines": {
            "added": [
                "\tif (plen) {"
            ],
            "deleted": [
                "\tif (_payload) {"
            ]
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "security/keys/keyctl.c in the Linux kernel before 4.11.5 does not consider the case of a NULL payload in conjunction with a nonzero length value, which allows local users to cause a denial of service (NULL pointer dereference and OOPS) via a crafted add_key or keyctl system call, a different vulnerability than CVE-2017-12192.",
        "id": 1303
    },
    {
        "cve_id": "CVE-2023-1583",
        "code_before_change": "static int io_file_bitmap_get(struct io_ring_ctx *ctx)\n{\n\tstruct io_file_table *table = &ctx->file_table;\n\tunsigned long nr = ctx->file_alloc_end;\n\tint ret;\n\n\tdo {\n\t\tret = find_next_zero_bit(table->bitmap, nr, table->alloc_hint);\n\t\tif (ret != nr)\n\t\t\treturn ret;\n\n\t\tif (table->alloc_hint == ctx->file_alloc_start)\n\t\t\tbreak;\n\t\tnr = table->alloc_hint;\n\t\ttable->alloc_hint = ctx->file_alloc_start;\n\t} while (1);\n\n\treturn -ENFILE;\n}",
        "code_after_change": "static int io_file_bitmap_get(struct io_ring_ctx *ctx)\n{\n\tstruct io_file_table *table = &ctx->file_table;\n\tunsigned long nr = ctx->file_alloc_end;\n\tint ret;\n\n\tif (!table->bitmap)\n\t\treturn -ENFILE;\n\n\tdo {\n\t\tret = find_next_zero_bit(table->bitmap, nr, table->alloc_hint);\n\t\tif (ret != nr)\n\t\t\treturn ret;\n\n\t\tif (table->alloc_hint == ctx->file_alloc_start)\n\t\t\tbreak;\n\t\tnr = table->alloc_hint;\n\t\ttable->alloc_hint = ctx->file_alloc_start;\n\t} while (1);\n\n\treturn -ENFILE;\n}",
        "patch": "--- code before\n+++ code after\n@@ -3,6 +3,9 @@\n \tstruct io_file_table *table = &ctx->file_table;\n \tunsigned long nr = ctx->file_alloc_end;\n \tint ret;\n+\n+\tif (!table->bitmap)\n+\t\treturn -ENFILE;\n \n \tdo {\n \t\tret = find_next_zero_bit(table->bitmap, nr, table->alloc_hint);",
        "function_modified_lines": {
            "added": [
                "",
                "\tif (!table->bitmap)",
                "\t\treturn -ENFILE;"
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "A NULL pointer dereference was found in io_file_bitmap_get in io_uring/filetable.c in the io_uring sub-component in the Linux Kernel. When fixed files are unregistered, some context information (file_alloc_{start,end} and alloc_hint) is not cleared. A subsequent request that has auto index selection enabled via IORING_FILE_INDEX_ALLOC can cause a NULL pointer dereference. An unprivileged user can use the flaw to cause a system crash.",
        "id": 3872
    },
    {
        "cve_id": "CVE-2018-1000200",
        "code_before_change": "static void oom_reap_task(struct task_struct *tsk)\n{\n\tint attempts = 0;\n\tstruct mm_struct *mm = tsk->signal->oom_mm;\n\n\t/* Retry the down_read_trylock(mmap_sem) a few times */\n\twhile (attempts++ < MAX_OOM_REAP_RETRIES && !__oom_reap_task_mm(tsk, mm))\n\t\tschedule_timeout_idle(HZ/10);\n\n\tif (attempts <= MAX_OOM_REAP_RETRIES ||\n\t    test_bit(MMF_OOM_SKIP, &mm->flags))\n\t\tgoto done;\n\n\n\tpr_info(\"oom_reaper: unable to reap pid:%d (%s)\\n\",\n\t\ttask_pid_nr(tsk), tsk->comm);\n\tdebug_show_all_locks();\n\ndone:\n\ttsk->oom_reaper_list = NULL;\n\n\t/*\n\t * Hide this mm from OOM killer because it has been either reaped or\n\t * somebody can't call up_write(mmap_sem).\n\t */\n\tset_bit(MMF_OOM_SKIP, &mm->flags);\n\n\t/* Drop a reference taken by wake_oom_reaper */\n\tput_task_struct(tsk);\n}",
        "code_after_change": "static void oom_reap_task(struct task_struct *tsk)\n{\n\tint attempts = 0;\n\tstruct mm_struct *mm = tsk->signal->oom_mm;\n\n\t/* Retry the down_read_trylock(mmap_sem) a few times */\n\twhile (attempts++ < MAX_OOM_REAP_RETRIES && !oom_reap_task_mm(tsk, mm))\n\t\tschedule_timeout_idle(HZ/10);\n\n\tif (attempts <= MAX_OOM_REAP_RETRIES ||\n\t    test_bit(MMF_OOM_SKIP, &mm->flags))\n\t\tgoto done;\n\n\tpr_info(\"oom_reaper: unable to reap pid:%d (%s)\\n\",\n\t\ttask_pid_nr(tsk), tsk->comm);\n\tdebug_show_all_locks();\n\ndone:\n\ttsk->oom_reaper_list = NULL;\n\n\t/*\n\t * Hide this mm from OOM killer because it has been either reaped or\n\t * somebody can't call up_write(mmap_sem).\n\t */\n\tset_bit(MMF_OOM_SKIP, &mm->flags);\n\n\t/* Drop a reference taken by wake_oom_reaper */\n\tput_task_struct(tsk);\n}",
        "patch": "--- code before\n+++ code after\n@@ -4,13 +4,12 @@\n \tstruct mm_struct *mm = tsk->signal->oom_mm;\n \n \t/* Retry the down_read_trylock(mmap_sem) a few times */\n-\twhile (attempts++ < MAX_OOM_REAP_RETRIES && !__oom_reap_task_mm(tsk, mm))\n+\twhile (attempts++ < MAX_OOM_REAP_RETRIES && !oom_reap_task_mm(tsk, mm))\n \t\tschedule_timeout_idle(HZ/10);\n \n \tif (attempts <= MAX_OOM_REAP_RETRIES ||\n \t    test_bit(MMF_OOM_SKIP, &mm->flags))\n \t\tgoto done;\n-\n \n \tpr_info(\"oom_reaper: unable to reap pid:%d (%s)\\n\",\n \t\ttask_pid_nr(tsk), tsk->comm);",
        "function_modified_lines": {
            "added": [
                "\twhile (attempts++ < MAX_OOM_REAP_RETRIES && !oom_reap_task_mm(tsk, mm))"
            ],
            "deleted": [
                "\twhile (attempts++ < MAX_OOM_REAP_RETRIES && !__oom_reap_task_mm(tsk, mm))",
                ""
            ]
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "The Linux Kernel versions 4.14, 4.15, and 4.16 has a null pointer dereference which can result in an out of memory (OOM) killing of large mlocked processes. The issue arises from an oom killed process's final thread calling exit_mmap(), which calls munlock_vma_pages_all() for mlocked vmas.This can happen synchronously with the oom reaper's unmap_page_range() since the vma's VM_LOCKED bit is cleared before munlocking (to determine if any other vmas share the memory and are mlocked).",
        "id": 1579
    },
    {
        "cve_id": "CVE-2019-15099",
        "code_before_change": "static void ath10k_usb_free_urb_to_pipe(struct ath10k_usb_pipe *pipe,\n\t\t\t\t\tstruct ath10k_urb_context *urb_context)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pipe->ar_usb->cs_lock, flags);\n\n\tpipe->urb_cnt++;\n\tlist_add(&urb_context->link, &pipe->urb_list_head);\n\n\tspin_unlock_irqrestore(&pipe->ar_usb->cs_lock, flags);\n}",
        "code_after_change": "static void ath10k_usb_free_urb_to_pipe(struct ath10k_usb_pipe *pipe,\n\t\t\t\t\tstruct ath10k_urb_context *urb_context)\n{\n\tunsigned long flags;\n\n\t/* bail if this pipe is not initialized */\n\tif (!pipe->ar_usb)\n\t\treturn;\n\n\tspin_lock_irqsave(&pipe->ar_usb->cs_lock, flags);\n\n\tpipe->urb_cnt++;\n\tlist_add(&urb_context->link, &pipe->urb_list_head);\n\n\tspin_unlock_irqrestore(&pipe->ar_usb->cs_lock, flags);\n}",
        "patch": "--- code before\n+++ code after\n@@ -2,6 +2,10 @@\n \t\t\t\t\tstruct ath10k_urb_context *urb_context)\n {\n \tunsigned long flags;\n+\n+\t/* bail if this pipe is not initialized */\n+\tif (!pipe->ar_usb)\n+\t\treturn;\n \n \tspin_lock_irqsave(&pipe->ar_usb->cs_lock, flags);\n ",
        "function_modified_lines": {
            "added": [
                "",
                "\t/* bail if this pipe is not initialized */",
                "\tif (!pipe->ar_usb)",
                "\t\treturn;"
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "drivers/net/wireless/ath/ath10k/usb.c in the Linux kernel through 5.2.8 has a NULL pointer dereference via an incomplete address in an endpoint descriptor.",
        "id": 1990
    },
    {
        "cve_id": "CVE-2021-38206",
        "code_before_change": "netdev_tx_t ieee80211_monitor_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t struct net_device *dev)\n{\n\tstruct ieee80211_local *local = wdev_priv(dev->ieee80211_ptr);\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_hdr *hdr;\n\tstruct ieee80211_sub_if_data *tmp_sdata, *sdata;\n\tstruct cfg80211_chan_def *chandef;\n\tu16 len_rthdr;\n\tint hdrlen;\n\n\tmemset(info, 0, sizeof(*info));\n\tinfo->flags = IEEE80211_TX_CTL_REQ_TX_STATUS |\n\t\t      IEEE80211_TX_CTL_INJECTED;\n\n\t/* Sanity-check and process the injection radiotap header */\n\tif (!ieee80211_parse_tx_radiotap(skb, dev))\n\t\tgoto fail;\n\n\t/* we now know there is a radiotap header with a length we can use */\n\tlen_rthdr = ieee80211_get_radiotap_len(skb->data);\n\n\t/*\n\t * fix up the pointers accounting for the radiotap\n\t * header still being in there.  We are being given\n\t * a precooked IEEE80211 header so no need for\n\t * normal processing\n\t */\n\tskb_set_mac_header(skb, len_rthdr);\n\t/*\n\t * these are just fixed to the end of the rt area since we\n\t * don't have any better information and at this point, nobody cares\n\t */\n\tskb_set_network_header(skb, len_rthdr);\n\tskb_set_transport_header(skb, len_rthdr);\n\n\tif (skb->len < len_rthdr + 2)\n\t\tgoto fail;\n\n\thdr = (struct ieee80211_hdr *)(skb->data + len_rthdr);\n\thdrlen = ieee80211_hdrlen(hdr->frame_control);\n\n\tif (skb->len < len_rthdr + hdrlen)\n\t\tgoto fail;\n\n\t/*\n\t * Initialize skb->protocol if the injected frame is a data frame\n\t * carrying a rfc1042 header\n\t */\n\tif (ieee80211_is_data(hdr->frame_control) &&\n\t    skb->len >= len_rthdr + hdrlen + sizeof(rfc1042_header) + 2) {\n\t\tu8 *payload = (u8 *)hdr + hdrlen;\n\n\t\tif (ether_addr_equal(payload, rfc1042_header))\n\t\t\tskb->protocol = cpu_to_be16((payload[6] << 8) |\n\t\t\t\t\t\t    payload[7]);\n\t}\n\n\trcu_read_lock();\n\n\t/*\n\t * We process outgoing injected frames that have a local address\n\t * we handle as though they are non-injected frames.\n\t * This code here isn't entirely correct, the local MAC address\n\t * isn't always enough to find the interface to use; for proper\n\t * VLAN support we have an nl80211-based mechanism.\n\t *\n\t * This is necessary, for example, for old hostapd versions that\n\t * don't use nl80211-based management TX/RX.\n\t */\n\tsdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\n\tlist_for_each_entry_rcu(tmp_sdata, &local->interfaces, list) {\n\t\tif (!ieee80211_sdata_running(tmp_sdata))\n\t\t\tcontinue;\n\t\tif (tmp_sdata->vif.type == NL80211_IFTYPE_MONITOR ||\n\t\t    tmp_sdata->vif.type == NL80211_IFTYPE_AP_VLAN)\n\t\t\tcontinue;\n\t\tif (ether_addr_equal(tmp_sdata->vif.addr, hdr->addr2)) {\n\t\t\tsdata = tmp_sdata;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tchanctx_conf = rcu_dereference(sdata->vif.chanctx_conf);\n\tif (!chanctx_conf) {\n\t\ttmp_sdata = rcu_dereference(local->monitor_sdata);\n\t\tif (tmp_sdata)\n\t\t\tchanctx_conf =\n\t\t\t\trcu_dereference(tmp_sdata->vif.chanctx_conf);\n\t}\n\n\tif (chanctx_conf)\n\t\tchandef = &chanctx_conf->def;\n\telse if (!local->use_chanctx)\n\t\tchandef = &local->_oper_chandef;\n\telse\n\t\tgoto fail_rcu;\n\n\t/*\n\t * Frame injection is not allowed if beaconing is not allowed\n\t * or if we need radar detection. Beaconing is usually not allowed when\n\t * the mode or operation (Adhoc, AP, Mesh) does not support DFS.\n\t * Passive scan is also used in world regulatory domains where\n\t * your country is not known and as such it should be treated as\n\t * NO TX unless the channel is explicitly allowed in which case\n\t * your current regulatory domain would not have the passive scan\n\t * flag.\n\t *\n\t * Since AP mode uses monitor interfaces to inject/TX management\n\t * frames we can make AP mode the exception to this rule once it\n\t * supports radar detection as its implementation can deal with\n\t * radar detection by itself. We can do that later by adding a\n\t * monitor flag interfaces used for AP support.\n\t */\n\tif (!cfg80211_reg_can_beacon(local->hw.wiphy, chandef,\n\t\t\t\t     sdata->vif.type))\n\t\tgoto fail_rcu;\n\n\tinfo->band = chandef->chan->band;\n\n\t/* Initialize skb->priority according to frame type and TID class,\n\t * with respect to the sub interface that the frame will actually\n\t * be transmitted on. If the DONT_REORDER flag is set, the original\n\t * skb-priority is preserved to assure frames injected with this\n\t * flag are not reordered relative to each other.\n\t */\n\tieee80211_select_queue_80211(sdata, skb, hdr);\n\tskb_set_queue_mapping(skb, ieee80211_ac_from_tid(skb->priority));\n\n\t/* remove the injection radiotap header */\n\tskb_pull(skb, len_rthdr);\n\n\tieee80211_xmit(sdata, NULL, skb);\n\trcu_read_unlock();\n\n\treturn NETDEV_TX_OK;\n\nfail_rcu:\n\trcu_read_unlock();\nfail:\n\tdev_kfree_skb(skb);\n\treturn NETDEV_TX_OK; /* meaning, we dealt with the skb */\n}",
        "code_after_change": "netdev_tx_t ieee80211_monitor_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t struct net_device *dev)\n{\n\tstruct ieee80211_local *local = wdev_priv(dev->ieee80211_ptr);\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_hdr *hdr;\n\tstruct ieee80211_sub_if_data *tmp_sdata, *sdata;\n\tstruct cfg80211_chan_def *chandef;\n\tu16 len_rthdr;\n\tint hdrlen;\n\n\tmemset(info, 0, sizeof(*info));\n\tinfo->flags = IEEE80211_TX_CTL_REQ_TX_STATUS |\n\t\t      IEEE80211_TX_CTL_INJECTED;\n\n\t/* Sanity-check the length of the radiotap header */\n\tif (!ieee80211_validate_radiotap_len(skb))\n\t\tgoto fail;\n\n\t/* we now know there is a radiotap header with a length we can use */\n\tlen_rthdr = ieee80211_get_radiotap_len(skb->data);\n\n\t/*\n\t * fix up the pointers accounting for the radiotap\n\t * header still being in there.  We are being given\n\t * a precooked IEEE80211 header so no need for\n\t * normal processing\n\t */\n\tskb_set_mac_header(skb, len_rthdr);\n\t/*\n\t * these are just fixed to the end of the rt area since we\n\t * don't have any better information and at this point, nobody cares\n\t */\n\tskb_set_network_header(skb, len_rthdr);\n\tskb_set_transport_header(skb, len_rthdr);\n\n\tif (skb->len < len_rthdr + 2)\n\t\tgoto fail;\n\n\thdr = (struct ieee80211_hdr *)(skb->data + len_rthdr);\n\thdrlen = ieee80211_hdrlen(hdr->frame_control);\n\n\tif (skb->len < len_rthdr + hdrlen)\n\t\tgoto fail;\n\n\t/*\n\t * Initialize skb->protocol if the injected frame is a data frame\n\t * carrying a rfc1042 header\n\t */\n\tif (ieee80211_is_data(hdr->frame_control) &&\n\t    skb->len >= len_rthdr + hdrlen + sizeof(rfc1042_header) + 2) {\n\t\tu8 *payload = (u8 *)hdr + hdrlen;\n\n\t\tif (ether_addr_equal(payload, rfc1042_header))\n\t\t\tskb->protocol = cpu_to_be16((payload[6] << 8) |\n\t\t\t\t\t\t    payload[7]);\n\t}\n\n\trcu_read_lock();\n\n\t/*\n\t * We process outgoing injected frames that have a local address\n\t * we handle as though they are non-injected frames.\n\t * This code here isn't entirely correct, the local MAC address\n\t * isn't always enough to find the interface to use; for proper\n\t * VLAN support we have an nl80211-based mechanism.\n\t *\n\t * This is necessary, for example, for old hostapd versions that\n\t * don't use nl80211-based management TX/RX.\n\t */\n\tsdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\n\tlist_for_each_entry_rcu(tmp_sdata, &local->interfaces, list) {\n\t\tif (!ieee80211_sdata_running(tmp_sdata))\n\t\t\tcontinue;\n\t\tif (tmp_sdata->vif.type == NL80211_IFTYPE_MONITOR ||\n\t\t    tmp_sdata->vif.type == NL80211_IFTYPE_AP_VLAN)\n\t\t\tcontinue;\n\t\tif (ether_addr_equal(tmp_sdata->vif.addr, hdr->addr2)) {\n\t\t\tsdata = tmp_sdata;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tchanctx_conf = rcu_dereference(sdata->vif.chanctx_conf);\n\tif (!chanctx_conf) {\n\t\ttmp_sdata = rcu_dereference(local->monitor_sdata);\n\t\tif (tmp_sdata)\n\t\t\tchanctx_conf =\n\t\t\t\trcu_dereference(tmp_sdata->vif.chanctx_conf);\n\t}\n\n\tif (chanctx_conf)\n\t\tchandef = &chanctx_conf->def;\n\telse if (!local->use_chanctx)\n\t\tchandef = &local->_oper_chandef;\n\telse\n\t\tgoto fail_rcu;\n\n\t/*\n\t * Frame injection is not allowed if beaconing is not allowed\n\t * or if we need radar detection. Beaconing is usually not allowed when\n\t * the mode or operation (Adhoc, AP, Mesh) does not support DFS.\n\t * Passive scan is also used in world regulatory domains where\n\t * your country is not known and as such it should be treated as\n\t * NO TX unless the channel is explicitly allowed in which case\n\t * your current regulatory domain would not have the passive scan\n\t * flag.\n\t *\n\t * Since AP mode uses monitor interfaces to inject/TX management\n\t * frames we can make AP mode the exception to this rule once it\n\t * supports radar detection as its implementation can deal with\n\t * radar detection by itself. We can do that later by adding a\n\t * monitor flag interfaces used for AP support.\n\t */\n\tif (!cfg80211_reg_can_beacon(local->hw.wiphy, chandef,\n\t\t\t\t     sdata->vif.type))\n\t\tgoto fail_rcu;\n\n\tinfo->band = chandef->chan->band;\n\n\t/* Initialize skb->priority according to frame type and TID class,\n\t * with respect to the sub interface that the frame will actually\n\t * be transmitted on. If the DONT_REORDER flag is set, the original\n\t * skb-priority is preserved to assure frames injected with this\n\t * flag are not reordered relative to each other.\n\t */\n\tieee80211_select_queue_80211(sdata, skb, hdr);\n\tskb_set_queue_mapping(skb, ieee80211_ac_from_tid(skb->priority));\n\n\t/*\n\t * Process the radiotap header. This will now take into account the\n\t * selected chandef above to accurately set injection rates and\n\t * retransmissions.\n\t */\n\tif (!ieee80211_parse_tx_radiotap(skb, dev))\n\t\tgoto fail_rcu;\n\n\t/* remove the injection radiotap header */\n\tskb_pull(skb, len_rthdr);\n\n\tieee80211_xmit(sdata, NULL, skb);\n\trcu_read_unlock();\n\n\treturn NETDEV_TX_OK;\n\nfail_rcu:\n\trcu_read_unlock();\nfail:\n\tdev_kfree_skb(skb);\n\treturn NETDEV_TX_OK; /* meaning, we dealt with the skb */\n}",
        "patch": "--- code before\n+++ code after\n@@ -14,8 +14,8 @@\n \tinfo->flags = IEEE80211_TX_CTL_REQ_TX_STATUS |\n \t\t      IEEE80211_TX_CTL_INJECTED;\n \n-\t/* Sanity-check and process the injection radiotap header */\n-\tif (!ieee80211_parse_tx_radiotap(skb, dev))\n+\t/* Sanity-check the length of the radiotap header */\n+\tif (!ieee80211_validate_radiotap_len(skb))\n \t\tgoto fail;\n \n \t/* we now know there is a radiotap header with a length we can use */\n@@ -129,6 +129,14 @@\n \tieee80211_select_queue_80211(sdata, skb, hdr);\n \tskb_set_queue_mapping(skb, ieee80211_ac_from_tid(skb->priority));\n \n+\t/*\n+\t * Process the radiotap header. This will now take into account the\n+\t * selected chandef above to accurately set injection rates and\n+\t * retransmissions.\n+\t */\n+\tif (!ieee80211_parse_tx_radiotap(skb, dev))\n+\t\tgoto fail_rcu;\n+\n \t/* remove the injection radiotap header */\n \tskb_pull(skb, len_rthdr);\n ",
        "function_modified_lines": {
            "added": [
                "\t/* Sanity-check the length of the radiotap header */",
                "\tif (!ieee80211_validate_radiotap_len(skb))",
                "\t/*",
                "\t * Process the radiotap header. This will now take into account the",
                "\t * selected chandef above to accurately set injection rates and",
                "\t * retransmissions.",
                "\t */",
                "\tif (!ieee80211_parse_tx_radiotap(skb, dev))",
                "\t\tgoto fail_rcu;",
                ""
            ],
            "deleted": [
                "\t/* Sanity-check and process the injection radiotap header */",
                "\tif (!ieee80211_parse_tx_radiotap(skb, dev))"
            ]
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "The mac80211 subsystem in the Linux kernel before 5.12.13, when a device supporting only 5 GHz is used, allows attackers to cause a denial of service (NULL pointer dereference in the radiotap parser) by injecting a frame with 802.11a rates.",
        "id": 3083
    },
    {
        "cve_id": "CVE-2017-18241",
        "code_before_change": "int create_flush_cmd_control(struct f2fs_sb_info *sbi)\n{\n\tdev_t dev = sbi->sb->s_bdev->bd_dev;\n\tstruct flush_cmd_control *fcc;\n\tint err = 0;\n\n\tif (SM_I(sbi)->fcc_info) {\n\t\tfcc = SM_I(sbi)->fcc_info;\n\t\tgoto init_thread;\n\t}\n\n\tfcc = kzalloc(sizeof(struct flush_cmd_control), GFP_KERNEL);\n\tif (!fcc)\n\t\treturn -ENOMEM;\n\tatomic_set(&fcc->issued_flush, 0);\n\tatomic_set(&fcc->issing_flush, 0);\n\tinit_waitqueue_head(&fcc->flush_wait_queue);\n\tinit_llist_head(&fcc->issue_list);\n\tSM_I(sbi)->fcc_info = fcc;\ninit_thread:\n\tfcc->f2fs_issue_flush = kthread_run(issue_flush_thread, sbi,\n\t\t\t\t\"f2fs_flush-%u:%u\", MAJOR(dev), MINOR(dev));\n\tif (IS_ERR(fcc->f2fs_issue_flush)) {\n\t\terr = PTR_ERR(fcc->f2fs_issue_flush);\n\t\tkfree(fcc);\n\t\tSM_I(sbi)->fcc_info = NULL;\n\t\treturn err;\n\t}\n\n\treturn err;\n}",
        "code_after_change": "int create_flush_cmd_control(struct f2fs_sb_info *sbi)\n{\n\tdev_t dev = sbi->sb->s_bdev->bd_dev;\n\tstruct flush_cmd_control *fcc;\n\tint err = 0;\n\n\tif (SM_I(sbi)->fcc_info) {\n\t\tfcc = SM_I(sbi)->fcc_info;\n\t\tgoto init_thread;\n\t}\n\n\tfcc = kzalloc(sizeof(struct flush_cmd_control), GFP_KERNEL);\n\tif (!fcc)\n\t\treturn -ENOMEM;\n\tatomic_set(&fcc->issued_flush, 0);\n\tatomic_set(&fcc->issing_flush, 0);\n\tinit_waitqueue_head(&fcc->flush_wait_queue);\n\tinit_llist_head(&fcc->issue_list);\n\tSM_I(sbi)->fcc_info = fcc;\n\tif (!test_opt(sbi, FLUSH_MERGE))\n\t\treturn err;\n\ninit_thread:\n\tfcc->f2fs_issue_flush = kthread_run(issue_flush_thread, sbi,\n\t\t\t\t\"f2fs_flush-%u:%u\", MAJOR(dev), MINOR(dev));\n\tif (IS_ERR(fcc->f2fs_issue_flush)) {\n\t\terr = PTR_ERR(fcc->f2fs_issue_flush);\n\t\tkfree(fcc);\n\t\tSM_I(sbi)->fcc_info = NULL;\n\t\treturn err;\n\t}\n\n\treturn err;\n}",
        "patch": "--- code before\n+++ code after\n@@ -17,6 +17,9 @@\n \tinit_waitqueue_head(&fcc->flush_wait_queue);\n \tinit_llist_head(&fcc->issue_list);\n \tSM_I(sbi)->fcc_info = fcc;\n+\tif (!test_opt(sbi, FLUSH_MERGE))\n+\t\treturn err;\n+\n init_thread:\n \tfcc->f2fs_issue_flush = kthread_run(issue_flush_thread, sbi,\n \t\t\t\t\"f2fs_flush-%u:%u\", MAJOR(dev), MINOR(dev));",
        "function_modified_lines": {
            "added": [
                "\tif (!test_opt(sbi, FLUSH_MERGE))",
                "\t\treturn err;",
                ""
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "fs/f2fs/segment.c in the Linux kernel before 4.13 allows local users to cause a denial of service (NULL pointer dereference and panic) by using a noflush_merge option that triggers a NULL value for a flush_cmd_control data structure.",
        "id": 1423
    },
    {
        "cve_id": "CVE-2018-7191",
        "code_before_change": "static int tun_set_iff(struct net *net, struct file *file, struct ifreq *ifr)\n{\n\tstruct tun_struct *tun;\n\tstruct tun_file *tfile = file->private_data;\n\tstruct net_device *dev;\n\tint err;\n\n\tif (tfile->detached)\n\t\treturn -EINVAL;\n\n\tdev = __dev_get_by_name(net, ifr->ifr_name);\n\tif (dev) {\n\t\tif (ifr->ifr_flags & IFF_TUN_EXCL)\n\t\t\treturn -EBUSY;\n\t\tif ((ifr->ifr_flags & IFF_TUN) && dev->netdev_ops == &tun_netdev_ops)\n\t\t\ttun = netdev_priv(dev);\n\t\telse if ((ifr->ifr_flags & IFF_TAP) && dev->netdev_ops == &tap_netdev_ops)\n\t\t\ttun = netdev_priv(dev);\n\t\telse\n\t\t\treturn -EINVAL;\n\n\t\tif (!!(ifr->ifr_flags & IFF_MULTI_QUEUE) !=\n\t\t    !!(tun->flags & IFF_MULTI_QUEUE))\n\t\t\treturn -EINVAL;\n\n\t\tif (tun_not_capable(tun))\n\t\t\treturn -EPERM;\n\t\terr = security_tun_dev_open(tun->security);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = tun_attach(tun, file, ifr->ifr_flags & IFF_NOFILTER);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (tun->flags & IFF_MULTI_QUEUE &&\n\t\t    (tun->numqueues + tun->numdisabled > 1)) {\n\t\t\t/* One or more queue has already been attached, no need\n\t\t\t * to initialize the device again.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\telse {\n\t\tchar *name;\n\t\tunsigned long flags = 0;\n\t\tint queues = ifr->ifr_flags & IFF_MULTI_QUEUE ?\n\t\t\t     MAX_TAP_QUEUES : 1;\n\n\t\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\terr = security_tun_dev_create();\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t/* Set dev type */\n\t\tif (ifr->ifr_flags & IFF_TUN) {\n\t\t\t/* TUN device */\n\t\t\tflags |= IFF_TUN;\n\t\t\tname = \"tun%d\";\n\t\t} else if (ifr->ifr_flags & IFF_TAP) {\n\t\t\t/* TAP device */\n\t\t\tflags |= IFF_TAP;\n\t\t\tname = \"tap%d\";\n\t\t} else\n\t\t\treturn -EINVAL;\n\n\t\tif (*ifr->ifr_name)\n\t\t\tname = ifr->ifr_name;\n\n\t\tdev = alloc_netdev_mqs(sizeof(struct tun_struct), name,\n\t\t\t\t       NET_NAME_UNKNOWN, tun_setup, queues,\n\t\t\t\t       queues);\n\n\t\tif (!dev)\n\t\t\treturn -ENOMEM;\n\n\t\tdev_net_set(dev, net);\n\t\tdev->rtnl_link_ops = &tun_link_ops;\n\t\tdev->ifindex = tfile->ifindex;\n\t\tdev->sysfs_groups[0] = &tun_attr_group;\n\n\t\ttun = netdev_priv(dev);\n\t\ttun->dev = dev;\n\t\ttun->flags = flags;\n\t\ttun->txflt.count = 0;\n\t\ttun->vnet_hdr_sz = sizeof(struct virtio_net_hdr);\n\n\t\ttun->align = NET_SKB_PAD;\n\t\ttun->filter_attached = false;\n\t\ttun->sndbuf = tfile->socket.sk->sk_sndbuf;\n\t\ttun->rx_batched = 0;\n\n\t\ttun->pcpu_stats = netdev_alloc_pcpu_stats(struct tun_pcpu_stats);\n\t\tif (!tun->pcpu_stats) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_free_dev;\n\t\t}\n\n\t\tspin_lock_init(&tun->lock);\n\n\t\terr = security_tun_dev_alloc_security(&tun->security);\n\t\tif (err < 0)\n\t\t\tgoto err_free_stat;\n\n\t\ttun_net_init(dev);\n\t\ttun_flow_init(tun);\n\n\t\tdev->hw_features = NETIF_F_SG | NETIF_F_FRAGLIST |\n\t\t\t\t   TUN_USER_FEATURES | NETIF_F_HW_VLAN_CTAG_TX |\n\t\t\t\t   NETIF_F_HW_VLAN_STAG_TX;\n\t\tdev->features = dev->hw_features | NETIF_F_LLTX;\n\t\tdev->vlan_features = dev->features &\n\t\t\t\t     ~(NETIF_F_HW_VLAN_CTAG_TX |\n\t\t\t\t       NETIF_F_HW_VLAN_STAG_TX);\n\n\t\tINIT_LIST_HEAD(&tun->disabled);\n\t\terr = tun_attach(tun, file, false);\n\t\tif (err < 0)\n\t\t\tgoto err_free_flow;\n\n\t\terr = register_netdevice(tun->dev);\n\t\tif (err < 0)\n\t\t\tgoto err_detach;\n\t}\n\n\tnetif_carrier_on(tun->dev);\n\n\ttun_debug(KERN_INFO, tun, \"tun_set_iff\\n\");\n\n\ttun->flags = (tun->flags & ~TUN_FEATURES) |\n\t\t(ifr->ifr_flags & TUN_FEATURES);\n\n\t/* Make sure persistent devices do not get stuck in\n\t * xoff state.\n\t */\n\tif (netif_running(tun->dev))\n\t\tnetif_tx_wake_all_queues(tun->dev);\n\n\tstrcpy(ifr->ifr_name, tun->dev->name);\n\treturn 0;\n\nerr_detach:\n\ttun_detach_all(dev);\n\t/* register_netdevice() already called tun_free_netdev() */\n\tgoto err_free_dev;\n\nerr_free_flow:\n\ttun_flow_uninit(tun);\n\tsecurity_tun_dev_free_security(tun->security);\nerr_free_stat:\n\tfree_percpu(tun->pcpu_stats);\nerr_free_dev:\n\tfree_netdev(dev);\n\treturn err;\n}",
        "code_after_change": "static int tun_set_iff(struct net *net, struct file *file, struct ifreq *ifr)\n{\n\tstruct tun_struct *tun;\n\tstruct tun_file *tfile = file->private_data;\n\tstruct net_device *dev;\n\tint err;\n\n\tif (tfile->detached)\n\t\treturn -EINVAL;\n\n\tdev = __dev_get_by_name(net, ifr->ifr_name);\n\tif (dev) {\n\t\tif (ifr->ifr_flags & IFF_TUN_EXCL)\n\t\t\treturn -EBUSY;\n\t\tif ((ifr->ifr_flags & IFF_TUN) && dev->netdev_ops == &tun_netdev_ops)\n\t\t\ttun = netdev_priv(dev);\n\t\telse if ((ifr->ifr_flags & IFF_TAP) && dev->netdev_ops == &tap_netdev_ops)\n\t\t\ttun = netdev_priv(dev);\n\t\telse\n\t\t\treturn -EINVAL;\n\n\t\tif (!!(ifr->ifr_flags & IFF_MULTI_QUEUE) !=\n\t\t    !!(tun->flags & IFF_MULTI_QUEUE))\n\t\t\treturn -EINVAL;\n\n\t\tif (tun_not_capable(tun))\n\t\t\treturn -EPERM;\n\t\terr = security_tun_dev_open(tun->security);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = tun_attach(tun, file, ifr->ifr_flags & IFF_NOFILTER);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (tun->flags & IFF_MULTI_QUEUE &&\n\t\t    (tun->numqueues + tun->numdisabled > 1)) {\n\t\t\t/* One or more queue has already been attached, no need\n\t\t\t * to initialize the device again.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\telse {\n\t\tchar *name;\n\t\tunsigned long flags = 0;\n\t\tint queues = ifr->ifr_flags & IFF_MULTI_QUEUE ?\n\t\t\t     MAX_TAP_QUEUES : 1;\n\n\t\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\terr = security_tun_dev_create();\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t/* Set dev type */\n\t\tif (ifr->ifr_flags & IFF_TUN) {\n\t\t\t/* TUN device */\n\t\t\tflags |= IFF_TUN;\n\t\t\tname = \"tun%d\";\n\t\t} else if (ifr->ifr_flags & IFF_TAP) {\n\t\t\t/* TAP device */\n\t\t\tflags |= IFF_TAP;\n\t\t\tname = \"tap%d\";\n\t\t} else\n\t\t\treturn -EINVAL;\n\n\t\tif (*ifr->ifr_name)\n\t\t\tname = ifr->ifr_name;\n\n\t\tdev = alloc_netdev_mqs(sizeof(struct tun_struct), name,\n\t\t\t\t       NET_NAME_UNKNOWN, tun_setup, queues,\n\t\t\t\t       queues);\n\n\t\tif (!dev)\n\t\t\treturn -ENOMEM;\n\t\terr = dev_get_valid_name(net, dev, name);\n\t\tif (err)\n\t\t\tgoto err_free_dev;\n\n\t\tdev_net_set(dev, net);\n\t\tdev->rtnl_link_ops = &tun_link_ops;\n\t\tdev->ifindex = tfile->ifindex;\n\t\tdev->sysfs_groups[0] = &tun_attr_group;\n\n\t\ttun = netdev_priv(dev);\n\t\ttun->dev = dev;\n\t\ttun->flags = flags;\n\t\ttun->txflt.count = 0;\n\t\ttun->vnet_hdr_sz = sizeof(struct virtio_net_hdr);\n\n\t\ttun->align = NET_SKB_PAD;\n\t\ttun->filter_attached = false;\n\t\ttun->sndbuf = tfile->socket.sk->sk_sndbuf;\n\t\ttun->rx_batched = 0;\n\n\t\ttun->pcpu_stats = netdev_alloc_pcpu_stats(struct tun_pcpu_stats);\n\t\tif (!tun->pcpu_stats) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_free_dev;\n\t\t}\n\n\t\tspin_lock_init(&tun->lock);\n\n\t\terr = security_tun_dev_alloc_security(&tun->security);\n\t\tif (err < 0)\n\t\t\tgoto err_free_stat;\n\n\t\ttun_net_init(dev);\n\t\ttun_flow_init(tun);\n\n\t\tdev->hw_features = NETIF_F_SG | NETIF_F_FRAGLIST |\n\t\t\t\t   TUN_USER_FEATURES | NETIF_F_HW_VLAN_CTAG_TX |\n\t\t\t\t   NETIF_F_HW_VLAN_STAG_TX;\n\t\tdev->features = dev->hw_features | NETIF_F_LLTX;\n\t\tdev->vlan_features = dev->features &\n\t\t\t\t     ~(NETIF_F_HW_VLAN_CTAG_TX |\n\t\t\t\t       NETIF_F_HW_VLAN_STAG_TX);\n\n\t\tINIT_LIST_HEAD(&tun->disabled);\n\t\terr = tun_attach(tun, file, false);\n\t\tif (err < 0)\n\t\t\tgoto err_free_flow;\n\n\t\terr = register_netdevice(tun->dev);\n\t\tif (err < 0)\n\t\t\tgoto err_detach;\n\t}\n\n\tnetif_carrier_on(tun->dev);\n\n\ttun_debug(KERN_INFO, tun, \"tun_set_iff\\n\");\n\n\ttun->flags = (tun->flags & ~TUN_FEATURES) |\n\t\t(ifr->ifr_flags & TUN_FEATURES);\n\n\t/* Make sure persistent devices do not get stuck in\n\t * xoff state.\n\t */\n\tif (netif_running(tun->dev))\n\t\tnetif_tx_wake_all_queues(tun->dev);\n\n\tstrcpy(ifr->ifr_name, tun->dev->name);\n\treturn 0;\n\nerr_detach:\n\ttun_detach_all(dev);\n\t/* register_netdevice() already called tun_free_netdev() */\n\tgoto err_free_dev;\n\nerr_free_flow:\n\ttun_flow_uninit(tun);\n\tsecurity_tun_dev_free_security(tun->security);\nerr_free_stat:\n\tfree_percpu(tun->pcpu_stats);\nerr_free_dev:\n\tfree_netdev(dev);\n\treturn err;\n}",
        "patch": "--- code before\n+++ code after\n@@ -74,6 +74,9 @@\n \n \t\tif (!dev)\n \t\t\treturn -ENOMEM;\n+\t\terr = dev_get_valid_name(net, dev, name);\n+\t\tif (err)\n+\t\t\tgoto err_free_dev;\n \n \t\tdev_net_set(dev, net);\n \t\tdev->rtnl_link_ops = &tun_link_ops;",
        "function_modified_lines": {
            "added": [
                "\t\terr = dev_get_valid_name(net, dev, name);",
                "\t\tif (err)",
                "\t\t\tgoto err_free_dev;"
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "In the tun subsystem in the Linux kernel before 4.13.14, dev_get_valid_name is not called before register_netdevice. This allows local users to cause a denial of service (NULL pointer dereference and panic) via an ioctl(TUNSETIFF) call with a dev name containing a / character. This is similar to CVE-2013-4343.",
        "id": 1843
    },
    {
        "cve_id": "CVE-2019-15922",
        "code_before_change": "static int __init pf_init(void)\n{\t\t\t\t/* preliminary initialisation */\n\tstruct pf_unit *pf;\n\tint unit;\n\n\tif (disable)\n\t\treturn -EINVAL;\n\n\tpf_init_units();\n\n\tif (pf_detect())\n\t\treturn -ENODEV;\n\tpf_busy = 0;\n\n\tif (register_blkdev(major, name)) {\n\t\tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++)\n\t\t\tput_disk(pf->disk);\n\t\treturn -EBUSY;\n\t}\n\n\tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {\n\t\tstruct gendisk *disk = pf->disk;\n\n\t\tif (!pf->present)\n\t\t\tcontinue;\n\t\tdisk->private_data = pf;\n\t\tadd_disk(disk);\n\t}\n\treturn 0;\n}",
        "code_after_change": "static int __init pf_init(void)\n{\t\t\t\t/* preliminary initialisation */\n\tstruct pf_unit *pf;\n\tint unit;\n\n\tif (disable)\n\t\treturn -EINVAL;\n\n\tpf_init_units();\n\n\tif (pf_detect())\n\t\treturn -ENODEV;\n\tpf_busy = 0;\n\n\tif (register_blkdev(major, name)) {\n\t\tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {\n\t\t\tif (!pf->disk)\n\t\t\t\tcontinue;\n\t\t\tblk_cleanup_queue(pf->disk->queue);\n\t\t\tblk_mq_free_tag_set(&pf->tag_set);\n\t\t\tput_disk(pf->disk);\n\t\t}\n\t\treturn -EBUSY;\n\t}\n\n\tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {\n\t\tstruct gendisk *disk = pf->disk;\n\n\t\tif (!pf->present)\n\t\t\tcontinue;\n\t\tdisk->private_data = pf;\n\t\tadd_disk(disk);\n\t}\n\treturn 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -13,8 +13,13 @@\n \tpf_busy = 0;\n \n \tif (register_blkdev(major, name)) {\n-\t\tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++)\n+\t\tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {\n+\t\t\tif (!pf->disk)\n+\t\t\t\tcontinue;\n+\t\t\tblk_cleanup_queue(pf->disk->queue);\n+\t\t\tblk_mq_free_tag_set(&pf->tag_set);\n \t\t\tput_disk(pf->disk);\n+\t\t}\n \t\treturn -EBUSY;\n \t}\n ",
        "function_modified_lines": {
            "added": [
                "\t\tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {",
                "\t\t\tif (!pf->disk)",
                "\t\t\t\tcontinue;",
                "\t\t\tblk_cleanup_queue(pf->disk->queue);",
                "\t\t\tblk_mq_free_tag_set(&pf->tag_set);",
                "\t\t}"
            ],
            "deleted": [
                "\t\tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++)"
            ]
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "An issue was discovered in the Linux kernel before 5.0.9. There is a NULL pointer dereference for a pf data structure if alloc_disk fails in drivers/block/paride/pf.c.",
        "id": 2031
    },
    {
        "cve_id": "CVE-2017-8106",
        "code_before_change": "static __init void nested_vmx_setup_ctls_msrs(void)\n{\n\t/*\n\t * Note that as a general rule, the high half of the MSRs (bits in\n\t * the control fields which may be 1) should be initialized by the\n\t * intersection of the underlying hardware's MSR (i.e., features which\n\t * can be supported) and the list of features we want to expose -\n\t * because they are known to be properly supported in our code.\n\t * Also, usually, the low half of the MSRs (bits which must be 1) can\n\t * be set to 0, meaning that L1 may turn off any of these bits. The\n\t * reason is that if one of these bits is necessary, it will appear\n\t * in vmcs01 and prepare_vmcs02, when it bitwise-or's the control\n\t * fields of vmcs01 and vmcs02, will turn these bits off - and\n\t * nested_vmx_exit_handled() will not pass related exits to L1.\n\t * These rules have exceptions below.\n\t */\n\n\t/* pin-based controls */\n\trdmsr(MSR_IA32_VMX_PINBASED_CTLS,\n\t      nested_vmx_pinbased_ctls_low, nested_vmx_pinbased_ctls_high);\n\t/*\n\t * According to the Intel spec, if bit 55 of VMX_BASIC is off (as it is\n\t * in our case), bits 1, 2 and 4 (i.e., 0x16) must be 1 in this MSR.\n\t */\n\tnested_vmx_pinbased_ctls_low |= PIN_BASED_ALWAYSON_WITHOUT_TRUE_MSR;\n\tnested_vmx_pinbased_ctls_high &= PIN_BASED_EXT_INTR_MASK |\n\t\tPIN_BASED_NMI_EXITING | PIN_BASED_VIRTUAL_NMIS;\n\tnested_vmx_pinbased_ctls_high |= PIN_BASED_ALWAYSON_WITHOUT_TRUE_MSR |\n\t\tPIN_BASED_VMX_PREEMPTION_TIMER;\n\n\t/*\n\t * Exit controls\n\t * If bit 55 of VMX_BASIC is off, bits 0-8 and 10, 11, 13, 14, 16 and\n\t * 17 must be 1.\n\t */\n\trdmsr(MSR_IA32_VMX_EXIT_CTLS,\n\t\tnested_vmx_exit_ctls_low, nested_vmx_exit_ctls_high);\n\tnested_vmx_exit_ctls_low = VM_EXIT_ALWAYSON_WITHOUT_TRUE_MSR;\n\t/* Note that guest use of VM_EXIT_ACK_INTR_ON_EXIT is not supported. */\n\tnested_vmx_exit_ctls_high &=\n#ifdef CONFIG_X86_64\n\t\tVM_EXIT_HOST_ADDR_SPACE_SIZE |\n#endif\n\t\tVM_EXIT_LOAD_IA32_PAT | VM_EXIT_SAVE_IA32_PAT;\n\tnested_vmx_exit_ctls_high |= VM_EXIT_ALWAYSON_WITHOUT_TRUE_MSR |\n\t\tVM_EXIT_LOAD_IA32_EFER | VM_EXIT_SAVE_IA32_EFER |\n\t\tVM_EXIT_SAVE_VMX_PREEMPTION_TIMER;\n\tif (vmx_mpx_supported())\n\t\tnested_vmx_exit_ctls_high |= VM_EXIT_CLEAR_BNDCFGS;\n\n\t/* entry controls */\n\trdmsr(MSR_IA32_VMX_ENTRY_CTLS,\n\t\tnested_vmx_entry_ctls_low, nested_vmx_entry_ctls_high);\n\t/* If bit 55 of VMX_BASIC is off, bits 0-8 and 12 must be 1. */\n\tnested_vmx_entry_ctls_low = VM_ENTRY_ALWAYSON_WITHOUT_TRUE_MSR;\n\tnested_vmx_entry_ctls_high &=\n#ifdef CONFIG_X86_64\n\t\tVM_ENTRY_IA32E_MODE |\n#endif\n\t\tVM_ENTRY_LOAD_IA32_PAT;\n\tnested_vmx_entry_ctls_high |= (VM_ENTRY_ALWAYSON_WITHOUT_TRUE_MSR |\n\t\t\t\t       VM_ENTRY_LOAD_IA32_EFER);\n\tif (vmx_mpx_supported())\n\t\tnested_vmx_entry_ctls_high |= VM_ENTRY_LOAD_BNDCFGS;\n\n\t/* cpu-based controls */\n\trdmsr(MSR_IA32_VMX_PROCBASED_CTLS,\n\t\tnested_vmx_procbased_ctls_low, nested_vmx_procbased_ctls_high);\n\tnested_vmx_procbased_ctls_low = 0;\n\tnested_vmx_procbased_ctls_high &=\n\t\tCPU_BASED_VIRTUAL_INTR_PENDING |\n\t\tCPU_BASED_VIRTUAL_NMI_PENDING | CPU_BASED_USE_TSC_OFFSETING |\n\t\tCPU_BASED_HLT_EXITING | CPU_BASED_INVLPG_EXITING |\n\t\tCPU_BASED_MWAIT_EXITING | CPU_BASED_CR3_LOAD_EXITING |\n\t\tCPU_BASED_CR3_STORE_EXITING |\n#ifdef CONFIG_X86_64\n\t\tCPU_BASED_CR8_LOAD_EXITING | CPU_BASED_CR8_STORE_EXITING |\n#endif\n\t\tCPU_BASED_MOV_DR_EXITING | CPU_BASED_UNCOND_IO_EXITING |\n\t\tCPU_BASED_USE_IO_BITMAPS | CPU_BASED_MONITOR_EXITING |\n\t\tCPU_BASED_RDPMC_EXITING | CPU_BASED_RDTSC_EXITING |\n\t\tCPU_BASED_PAUSE_EXITING |\n\t\tCPU_BASED_ACTIVATE_SECONDARY_CONTROLS;\n\t/*\n\t * We can allow some features even when not supported by the\n\t * hardware. For example, L1 can specify an MSR bitmap - and we\n\t * can use it to avoid exits to L1 - even when L0 runs L2\n\t * without MSR bitmaps.\n\t */\n\tnested_vmx_procbased_ctls_high |= CPU_BASED_USE_MSR_BITMAPS;\n\n\t/* secondary cpu-based controls */\n\trdmsr(MSR_IA32_VMX_PROCBASED_CTLS2,\n\t\tnested_vmx_secondary_ctls_low, nested_vmx_secondary_ctls_high);\n\tnested_vmx_secondary_ctls_low = 0;\n\tnested_vmx_secondary_ctls_high &=\n\t\tSECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES |\n\t\tSECONDARY_EXEC_UNRESTRICTED_GUEST |\n\t\tSECONDARY_EXEC_WBINVD_EXITING;\n\n\tif (enable_ept) {\n\t\t/* nested EPT: emulate EPT also to L1 */\n\t\tnested_vmx_secondary_ctls_high |= SECONDARY_EXEC_ENABLE_EPT;\n\t\tnested_vmx_ept_caps = VMX_EPT_PAGE_WALK_4_BIT |\n\t\t\t VMX_EPTP_WB_BIT | VMX_EPT_2MB_PAGE_BIT |\n\t\t\t VMX_EPT_INVEPT_BIT;\n\t\tnested_vmx_ept_caps &= vmx_capability.ept;\n\t\t/*\n\t\t * Since invept is completely emulated we support both global\n\t\t * and context invalidation independent of what host cpu\n\t\t * supports\n\t\t */\n\t\tnested_vmx_ept_caps |= VMX_EPT_EXTENT_GLOBAL_BIT |\n\t\t\tVMX_EPT_EXTENT_CONTEXT_BIT;\n\t} else\n\t\tnested_vmx_ept_caps = 0;\n\n\t/* miscellaneous data */\n\trdmsr(MSR_IA32_VMX_MISC, nested_vmx_misc_low, nested_vmx_misc_high);\n\tnested_vmx_misc_low &= VMX_MISC_SAVE_EFER_LMA;\n\tnested_vmx_misc_low |= VMX_MISC_EMULATED_PREEMPTION_TIMER_RATE |\n\t\tVMX_MISC_ACTIVITY_HLT;\n\tnested_vmx_misc_high = 0;\n}",
        "code_after_change": "static __init void nested_vmx_setup_ctls_msrs(void)\n{\n\t/*\n\t * Note that as a general rule, the high half of the MSRs (bits in\n\t * the control fields which may be 1) should be initialized by the\n\t * intersection of the underlying hardware's MSR (i.e., features which\n\t * can be supported) and the list of features we want to expose -\n\t * because they are known to be properly supported in our code.\n\t * Also, usually, the low half of the MSRs (bits which must be 1) can\n\t * be set to 0, meaning that L1 may turn off any of these bits. The\n\t * reason is that if one of these bits is necessary, it will appear\n\t * in vmcs01 and prepare_vmcs02, when it bitwise-or's the control\n\t * fields of vmcs01 and vmcs02, will turn these bits off - and\n\t * nested_vmx_exit_handled() will not pass related exits to L1.\n\t * These rules have exceptions below.\n\t */\n\n\t/* pin-based controls */\n\trdmsr(MSR_IA32_VMX_PINBASED_CTLS,\n\t      nested_vmx_pinbased_ctls_low, nested_vmx_pinbased_ctls_high);\n\t/*\n\t * According to the Intel spec, if bit 55 of VMX_BASIC is off (as it is\n\t * in our case), bits 1, 2 and 4 (i.e., 0x16) must be 1 in this MSR.\n\t */\n\tnested_vmx_pinbased_ctls_low |= PIN_BASED_ALWAYSON_WITHOUT_TRUE_MSR;\n\tnested_vmx_pinbased_ctls_high &= PIN_BASED_EXT_INTR_MASK |\n\t\tPIN_BASED_NMI_EXITING | PIN_BASED_VIRTUAL_NMIS;\n\tnested_vmx_pinbased_ctls_high |= PIN_BASED_ALWAYSON_WITHOUT_TRUE_MSR |\n\t\tPIN_BASED_VMX_PREEMPTION_TIMER;\n\n\t/*\n\t * Exit controls\n\t * If bit 55 of VMX_BASIC is off, bits 0-8 and 10, 11, 13, 14, 16 and\n\t * 17 must be 1.\n\t */\n\trdmsr(MSR_IA32_VMX_EXIT_CTLS,\n\t\tnested_vmx_exit_ctls_low, nested_vmx_exit_ctls_high);\n\tnested_vmx_exit_ctls_low = VM_EXIT_ALWAYSON_WITHOUT_TRUE_MSR;\n\t/* Note that guest use of VM_EXIT_ACK_INTR_ON_EXIT is not supported. */\n\tnested_vmx_exit_ctls_high &=\n#ifdef CONFIG_X86_64\n\t\tVM_EXIT_HOST_ADDR_SPACE_SIZE |\n#endif\n\t\tVM_EXIT_LOAD_IA32_PAT | VM_EXIT_SAVE_IA32_PAT;\n\tnested_vmx_exit_ctls_high |= VM_EXIT_ALWAYSON_WITHOUT_TRUE_MSR |\n\t\tVM_EXIT_LOAD_IA32_EFER | VM_EXIT_SAVE_IA32_EFER |\n\t\tVM_EXIT_SAVE_VMX_PREEMPTION_TIMER;\n\tif (vmx_mpx_supported())\n\t\tnested_vmx_exit_ctls_high |= VM_EXIT_CLEAR_BNDCFGS;\n\n\t/* entry controls */\n\trdmsr(MSR_IA32_VMX_ENTRY_CTLS,\n\t\tnested_vmx_entry_ctls_low, nested_vmx_entry_ctls_high);\n\t/* If bit 55 of VMX_BASIC is off, bits 0-8 and 12 must be 1. */\n\tnested_vmx_entry_ctls_low = VM_ENTRY_ALWAYSON_WITHOUT_TRUE_MSR;\n\tnested_vmx_entry_ctls_high &=\n#ifdef CONFIG_X86_64\n\t\tVM_ENTRY_IA32E_MODE |\n#endif\n\t\tVM_ENTRY_LOAD_IA32_PAT;\n\tnested_vmx_entry_ctls_high |= (VM_ENTRY_ALWAYSON_WITHOUT_TRUE_MSR |\n\t\t\t\t       VM_ENTRY_LOAD_IA32_EFER);\n\tif (vmx_mpx_supported())\n\t\tnested_vmx_entry_ctls_high |= VM_ENTRY_LOAD_BNDCFGS;\n\n\t/* cpu-based controls */\n\trdmsr(MSR_IA32_VMX_PROCBASED_CTLS,\n\t\tnested_vmx_procbased_ctls_low, nested_vmx_procbased_ctls_high);\n\tnested_vmx_procbased_ctls_low = 0;\n\tnested_vmx_procbased_ctls_high &=\n\t\tCPU_BASED_VIRTUAL_INTR_PENDING |\n\t\tCPU_BASED_VIRTUAL_NMI_PENDING | CPU_BASED_USE_TSC_OFFSETING |\n\t\tCPU_BASED_HLT_EXITING | CPU_BASED_INVLPG_EXITING |\n\t\tCPU_BASED_MWAIT_EXITING | CPU_BASED_CR3_LOAD_EXITING |\n\t\tCPU_BASED_CR3_STORE_EXITING |\n#ifdef CONFIG_X86_64\n\t\tCPU_BASED_CR8_LOAD_EXITING | CPU_BASED_CR8_STORE_EXITING |\n#endif\n\t\tCPU_BASED_MOV_DR_EXITING | CPU_BASED_UNCOND_IO_EXITING |\n\t\tCPU_BASED_USE_IO_BITMAPS | CPU_BASED_MONITOR_EXITING |\n\t\tCPU_BASED_RDPMC_EXITING | CPU_BASED_RDTSC_EXITING |\n\t\tCPU_BASED_PAUSE_EXITING |\n\t\tCPU_BASED_ACTIVATE_SECONDARY_CONTROLS;\n\t/*\n\t * We can allow some features even when not supported by the\n\t * hardware. For example, L1 can specify an MSR bitmap - and we\n\t * can use it to avoid exits to L1 - even when L0 runs L2\n\t * without MSR bitmaps.\n\t */\n\tnested_vmx_procbased_ctls_high |= CPU_BASED_USE_MSR_BITMAPS;\n\n\t/* secondary cpu-based controls */\n\trdmsr(MSR_IA32_VMX_PROCBASED_CTLS2,\n\t\tnested_vmx_secondary_ctls_low, nested_vmx_secondary_ctls_high);\n\tnested_vmx_secondary_ctls_low = 0;\n\tnested_vmx_secondary_ctls_high &=\n\t\tSECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES |\n\t\tSECONDARY_EXEC_UNRESTRICTED_GUEST |\n\t\tSECONDARY_EXEC_WBINVD_EXITING;\n\n\tif (enable_ept) {\n\t\t/* nested EPT: emulate EPT also to L1 */\n\t\tnested_vmx_secondary_ctls_high |= SECONDARY_EXEC_ENABLE_EPT;\n\t\tnested_vmx_ept_caps = VMX_EPT_PAGE_WALK_4_BIT |\n\t\t\t VMX_EPTP_WB_BIT | VMX_EPT_2MB_PAGE_BIT |\n\t\t\t VMX_EPT_INVEPT_BIT;\n\t\tnested_vmx_ept_caps &= vmx_capability.ept;\n\t\t/*\n\t\t * For nested guests, we don't do anything specific\n\t\t * for single context invalidation. Hence, only advertise\n\t\t * support for global context invalidation.\n\t\t */\n\t\tnested_vmx_ept_caps |= VMX_EPT_EXTENT_GLOBAL_BIT;\n\t} else\n\t\tnested_vmx_ept_caps = 0;\n\n\t/* miscellaneous data */\n\trdmsr(MSR_IA32_VMX_MISC, nested_vmx_misc_low, nested_vmx_misc_high);\n\tnested_vmx_misc_low &= VMX_MISC_SAVE_EFER_LMA;\n\tnested_vmx_misc_low |= VMX_MISC_EMULATED_PREEMPTION_TIMER_RATE |\n\t\tVMX_MISC_ACTIVITY_HLT;\n\tnested_vmx_misc_high = 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -106,12 +106,11 @@\n \t\t\t VMX_EPT_INVEPT_BIT;\n \t\tnested_vmx_ept_caps &= vmx_capability.ept;\n \t\t/*\n-\t\t * Since invept is completely emulated we support both global\n-\t\t * and context invalidation independent of what host cpu\n-\t\t * supports\n+\t\t * For nested guests, we don't do anything specific\n+\t\t * for single context invalidation. Hence, only advertise\n+\t\t * support for global context invalidation.\n \t\t */\n-\t\tnested_vmx_ept_caps |= VMX_EPT_EXTENT_GLOBAL_BIT |\n-\t\t\tVMX_EPT_EXTENT_CONTEXT_BIT;\n+\t\tnested_vmx_ept_caps |= VMX_EPT_EXTENT_GLOBAL_BIT;\n \t} else\n \t\tnested_vmx_ept_caps = 0;\n ",
        "function_modified_lines": {
            "added": [
                "\t\t * For nested guests, we don't do anything specific",
                "\t\t * for single context invalidation. Hence, only advertise",
                "\t\t * support for global context invalidation.",
                "\t\tnested_vmx_ept_caps |= VMX_EPT_EXTENT_GLOBAL_BIT;"
            ],
            "deleted": [
                "\t\t * Since invept is completely emulated we support both global",
                "\t\t * and context invalidation independent of what host cpu",
                "\t\t * supports",
                "\t\tnested_vmx_ept_caps |= VMX_EPT_EXTENT_GLOBAL_BIT |",
                "\t\t\tVMX_EPT_EXTENT_CONTEXT_BIT;"
            ]
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "The handle_invept function in arch/x86/kvm/vmx.c in the Linux kernel 3.12 through 3.15 allows privileged KVM guest OS users to cause a denial of service (NULL pointer dereference and host OS crash) via a single-context INVEPT instruction with a NULL EPT pointer.",
        "id": 1550
    },
    {
        "cve_id": "CVE-2018-14646",
        "code_before_change": "static int rtnl_getlink(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct net *tgt_net = net;\n\tstruct ifinfomsg *ifm;\n\tchar ifname[IFNAMSIZ];\n\tstruct nlattr *tb[IFLA_MAX+1];\n\tstruct net_device *dev = NULL;\n\tstruct sk_buff *nskb;\n\tint netnsid = -1;\n\tint err;\n\tu32 ext_filter_mask = 0;\n\n\terr = nlmsg_parse(nlh, sizeof(*ifm), tb, IFLA_MAX, ifla_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (tb[IFLA_IF_NETNSID]) {\n\t\tnetnsid = nla_get_s32(tb[IFLA_IF_NETNSID]);\n\t\ttgt_net = get_target_net(skb, netnsid);\n\t\tif (IS_ERR(tgt_net))\n\t\t\treturn PTR_ERR(tgt_net);\n\t}\n\n\tif (tb[IFLA_IFNAME])\n\t\tnla_strlcpy(ifname, tb[IFLA_IFNAME], IFNAMSIZ);\n\n\tif (tb[IFLA_EXT_MASK])\n\t\text_filter_mask = nla_get_u32(tb[IFLA_EXT_MASK]);\n\n\terr = -EINVAL;\n\tifm = nlmsg_data(nlh);\n\tif (ifm->ifi_index > 0)\n\t\tdev = __dev_get_by_index(tgt_net, ifm->ifi_index);\n\telse if (tb[IFLA_IFNAME])\n\t\tdev = __dev_get_by_name(tgt_net, ifname);\n\telse\n\t\tgoto out;\n\n\terr = -ENODEV;\n\tif (dev == NULL)\n\t\tgoto out;\n\n\terr = -ENOBUFS;\n\tnskb = nlmsg_new(if_nlmsg_size(dev, ext_filter_mask), GFP_KERNEL);\n\tif (nskb == NULL)\n\t\tgoto out;\n\n\terr = rtnl_fill_ifinfo(nskb, dev, net,\n\t\t\t       RTM_NEWLINK, NETLINK_CB(skb).portid,\n\t\t\t       nlh->nlmsg_seq, 0, 0, ext_filter_mask,\n\t\t\t       0, NULL, netnsid);\n\tif (err < 0) {\n\t\t/* -EMSGSIZE implies BUG in if_nlmsg_size */\n\t\tWARN_ON(err == -EMSGSIZE);\n\t\tkfree_skb(nskb);\n\t} else\n\t\terr = rtnl_unicast(nskb, net, NETLINK_CB(skb).portid);\nout:\n\tif (netnsid >= 0)\n\t\tput_net(tgt_net);\n\n\treturn err;\n}",
        "code_after_change": "static int rtnl_getlink(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct net *tgt_net = net;\n\tstruct ifinfomsg *ifm;\n\tchar ifname[IFNAMSIZ];\n\tstruct nlattr *tb[IFLA_MAX+1];\n\tstruct net_device *dev = NULL;\n\tstruct sk_buff *nskb;\n\tint netnsid = -1;\n\tint err;\n\tu32 ext_filter_mask = 0;\n\n\terr = nlmsg_parse(nlh, sizeof(*ifm), tb, IFLA_MAX, ifla_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (tb[IFLA_IF_NETNSID]) {\n\t\tnetnsid = nla_get_s32(tb[IFLA_IF_NETNSID]);\n\t\ttgt_net = get_target_net(NETLINK_CB(skb).sk, netnsid);\n\t\tif (IS_ERR(tgt_net))\n\t\t\treturn PTR_ERR(tgt_net);\n\t}\n\n\tif (tb[IFLA_IFNAME])\n\t\tnla_strlcpy(ifname, tb[IFLA_IFNAME], IFNAMSIZ);\n\n\tif (tb[IFLA_EXT_MASK])\n\t\text_filter_mask = nla_get_u32(tb[IFLA_EXT_MASK]);\n\n\terr = -EINVAL;\n\tifm = nlmsg_data(nlh);\n\tif (ifm->ifi_index > 0)\n\t\tdev = __dev_get_by_index(tgt_net, ifm->ifi_index);\n\telse if (tb[IFLA_IFNAME])\n\t\tdev = __dev_get_by_name(tgt_net, ifname);\n\telse\n\t\tgoto out;\n\n\terr = -ENODEV;\n\tif (dev == NULL)\n\t\tgoto out;\n\n\terr = -ENOBUFS;\n\tnskb = nlmsg_new(if_nlmsg_size(dev, ext_filter_mask), GFP_KERNEL);\n\tif (nskb == NULL)\n\t\tgoto out;\n\n\terr = rtnl_fill_ifinfo(nskb, dev, net,\n\t\t\t       RTM_NEWLINK, NETLINK_CB(skb).portid,\n\t\t\t       nlh->nlmsg_seq, 0, 0, ext_filter_mask,\n\t\t\t       0, NULL, netnsid);\n\tif (err < 0) {\n\t\t/* -EMSGSIZE implies BUG in if_nlmsg_size */\n\t\tWARN_ON(err == -EMSGSIZE);\n\t\tkfree_skb(nskb);\n\t} else\n\t\terr = rtnl_unicast(nskb, net, NETLINK_CB(skb).portid);\nout:\n\tif (netnsid >= 0)\n\t\tput_net(tgt_net);\n\n\treturn err;\n}",
        "patch": "--- code before\n+++ code after\n@@ -18,7 +18,7 @@\n \n \tif (tb[IFLA_IF_NETNSID]) {\n \t\tnetnsid = nla_get_s32(tb[IFLA_IF_NETNSID]);\n-\t\ttgt_net = get_target_net(skb, netnsid);\n+\t\ttgt_net = get_target_net(NETLINK_CB(skb).sk, netnsid);\n \t\tif (IS_ERR(tgt_net))\n \t\t\treturn PTR_ERR(tgt_net);\n \t}",
        "function_modified_lines": {
            "added": [
                "\t\ttgt_net = get_target_net(NETLINK_CB(skb).sk, netnsid);"
            ],
            "deleted": [
                "\t\ttgt_net = get_target_net(skb, netnsid);"
            ]
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "The Linux kernel before 4.15-rc8 was found to be vulnerable to a NULL pointer dereference bug in the __netlink_ns_capable() function in the net/netlink/af_netlink.c file. A local attacker could exploit this when a net namespace with a netnsid is assigned to cause a kernel panic and a denial of service.",
        "id": 1701
    },
    {
        "cve_id": "CVE-2020-11608",
        "code_before_change": "static void ov518_mode_init_regs(struct sd *sd)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tint hsegs, vsegs, packet_size;\n\tstruct usb_host_interface *alt;\n\tstruct usb_interface *intf;\n\n\tintf = usb_ifnum_to_if(sd->gspca_dev.dev, sd->gspca_dev.iface);\n\talt = usb_altnum_to_altsetting(intf, sd->gspca_dev.alt);\n\tif (!alt) {\n\t\tgspca_err(gspca_dev, \"Couldn't get altsetting\\n\");\n\t\tsd->gspca_dev.usb_err = -EIO;\n\t\treturn;\n\t}\n\n\tpacket_size = le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);\n\tov518_reg_w32(sd, R51x_FIFO_PSIZE, packet_size & ~7, 2);\n\n\t/******** Set the mode ********/\n\treg_w(sd, 0x2b, 0);\n\treg_w(sd, 0x2c, 0);\n\treg_w(sd, 0x2d, 0);\n\treg_w(sd, 0x2e, 0);\n\treg_w(sd, 0x3b, 0);\n\treg_w(sd, 0x3c, 0);\n\treg_w(sd, 0x3d, 0);\n\treg_w(sd, 0x3e, 0);\n\n\tif (sd->bridge == BRIDGE_OV518) {\n\t\t/* Set 8-bit (YVYU) input format */\n\t\treg_w_mask(sd, 0x20, 0x08, 0x08);\n\n\t\t/* Set 12-bit (4:2:0) output format */\n\t\treg_w_mask(sd, 0x28, 0x80, 0xf0);\n\t\treg_w_mask(sd, 0x38, 0x80, 0xf0);\n\t} else {\n\t\treg_w(sd, 0x28, 0x80);\n\t\treg_w(sd, 0x38, 0x80);\n\t}\n\n\thsegs = sd->gspca_dev.pixfmt.width / 16;\n\tvsegs = sd->gspca_dev.pixfmt.height / 4;\n\n\treg_w(sd, 0x29, hsegs);\n\treg_w(sd, 0x2a, vsegs);\n\n\treg_w(sd, 0x39, hsegs);\n\treg_w(sd, 0x3a, vsegs);\n\n\t/* Windows driver does this here; who knows why */\n\treg_w(sd, 0x2f, 0x80);\n\n\t/******** Set the framerate ********/\n\tif (sd->bridge == BRIDGE_OV518PLUS && sd->revision == 0 &&\n\t\t\t\t\t      sd->sensor == SEN_OV7620AE)\n\t\tsd->clockdiv = 0;\n\telse\n\t\tsd->clockdiv = 1;\n\n\t/* Mode independent, but framerate dependent, regs */\n\t/* 0x51: Clock divider; Only works on some cams which use 2 crystals */\n\treg_w(sd, 0x51, 0x04);\n\treg_w(sd, 0x22, 0x18);\n\treg_w(sd, 0x23, 0xff);\n\n\tif (sd->bridge == BRIDGE_OV518PLUS) {\n\t\tswitch (sd->sensor) {\n\t\tcase SEN_OV7620AE:\n\t\t\t/*\n\t\t\t * HdG: 640x480 needs special handling on device\n\t\t\t * revision 2, we check for device revision > 0 to\n\t\t\t * avoid regressions, as we don't know the correct\n\t\t\t * thing todo for revision 1.\n\t\t\t *\n\t\t\t * Also this likely means we don't need to\n\t\t\t * differentiate between the OV7620 and OV7620AE,\n\t\t\t * earlier testing hitting this same problem likely\n\t\t\t * happened to be with revision < 2 cams using an\n\t\t\t * OV7620 and revision 2 cams using an OV7620AE.\n\t\t\t */\n\t\t\tif (sd->revision > 0 &&\n\t\t\t\t\tsd->gspca_dev.pixfmt.width == 640) {\n\t\t\t\treg_w(sd, 0x20, 0x60);\n\t\t\t\treg_w(sd, 0x21, 0x1f);\n\t\t\t} else {\n\t\t\t\treg_w(sd, 0x20, 0x00);\n\t\t\t\treg_w(sd, 0x21, 0x19);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SEN_OV7620:\n\t\t\treg_w(sd, 0x20, 0x00);\n\t\t\treg_w(sd, 0x21, 0x19);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treg_w(sd, 0x21, 0x19);\n\t\t}\n\t} else\n\t\treg_w(sd, 0x71, 0x17);\t/* Compression-related? */\n\n\t/* FIXME: Sensor-specific */\n\t/* Bit 5 is what matters here. Of course, it is \"reserved\" */\n\ti2c_w(sd, 0x54, 0x23);\n\n\treg_w(sd, 0x2f, 0x80);\n\n\tif (sd->bridge == BRIDGE_OV518PLUS) {\n\t\treg_w(sd, 0x24, 0x94);\n\t\treg_w(sd, 0x25, 0x90);\n\t\tov518_reg_w32(sd, 0xc4,    400, 2);\t/* 190h   */\n\t\tov518_reg_w32(sd, 0xc6,    540, 2);\t/* 21ch   */\n\t\tov518_reg_w32(sd, 0xc7,    540, 2);\t/* 21ch   */\n\t\tov518_reg_w32(sd, 0xc8,    108, 2);\t/* 6ch    */\n\t\tov518_reg_w32(sd, 0xca, 131098, 3);\t/* 2001ah */\n\t\tov518_reg_w32(sd, 0xcb,    532, 2);\t/* 214h   */\n\t\tov518_reg_w32(sd, 0xcc,   2400, 2);\t/* 960h   */\n\t\tov518_reg_w32(sd, 0xcd,     32, 2);\t/* 20h    */\n\t\tov518_reg_w32(sd, 0xce,    608, 2);\t/* 260h   */\n\t} else {\n\t\treg_w(sd, 0x24, 0x9f);\n\t\treg_w(sd, 0x25, 0x90);\n\t\tov518_reg_w32(sd, 0xc4,    400, 2);\t/* 190h   */\n\t\tov518_reg_w32(sd, 0xc6,    381, 2);\t/* 17dh   */\n\t\tov518_reg_w32(sd, 0xc7,    381, 2);\t/* 17dh   */\n\t\tov518_reg_w32(sd, 0xc8,    128, 2);\t/* 80h    */\n\t\tov518_reg_w32(sd, 0xca, 183331, 3);\t/* 2cc23h */\n\t\tov518_reg_w32(sd, 0xcb,    746, 2);\t/* 2eah   */\n\t\tov518_reg_w32(sd, 0xcc,   1750, 2);\t/* 6d6h   */\n\t\tov518_reg_w32(sd, 0xcd,     45, 2);\t/* 2dh    */\n\t\tov518_reg_w32(sd, 0xce,    851, 2);\t/* 353h   */\n\t}\n\n\treg_w(sd, 0x2f, 0x80);\n}",
        "code_after_change": "static void ov518_mode_init_regs(struct sd *sd)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tint hsegs, vsegs, packet_size;\n\tstruct usb_host_interface *alt;\n\tstruct usb_interface *intf;\n\n\tintf = usb_ifnum_to_if(sd->gspca_dev.dev, sd->gspca_dev.iface);\n\talt = usb_altnum_to_altsetting(intf, sd->gspca_dev.alt);\n\tif (!alt) {\n\t\tgspca_err(gspca_dev, \"Couldn't get altsetting\\n\");\n\t\tsd->gspca_dev.usb_err = -EIO;\n\t\treturn;\n\t}\n\n\tif (alt->desc.bNumEndpoints < 1) {\n\t\tsd->gspca_dev.usb_err = -ENODEV;\n\t\treturn;\n\t}\n\n\tpacket_size = le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);\n\tov518_reg_w32(sd, R51x_FIFO_PSIZE, packet_size & ~7, 2);\n\n\t/******** Set the mode ********/\n\treg_w(sd, 0x2b, 0);\n\treg_w(sd, 0x2c, 0);\n\treg_w(sd, 0x2d, 0);\n\treg_w(sd, 0x2e, 0);\n\treg_w(sd, 0x3b, 0);\n\treg_w(sd, 0x3c, 0);\n\treg_w(sd, 0x3d, 0);\n\treg_w(sd, 0x3e, 0);\n\n\tif (sd->bridge == BRIDGE_OV518) {\n\t\t/* Set 8-bit (YVYU) input format */\n\t\treg_w_mask(sd, 0x20, 0x08, 0x08);\n\n\t\t/* Set 12-bit (4:2:0) output format */\n\t\treg_w_mask(sd, 0x28, 0x80, 0xf0);\n\t\treg_w_mask(sd, 0x38, 0x80, 0xf0);\n\t} else {\n\t\treg_w(sd, 0x28, 0x80);\n\t\treg_w(sd, 0x38, 0x80);\n\t}\n\n\thsegs = sd->gspca_dev.pixfmt.width / 16;\n\tvsegs = sd->gspca_dev.pixfmt.height / 4;\n\n\treg_w(sd, 0x29, hsegs);\n\treg_w(sd, 0x2a, vsegs);\n\n\treg_w(sd, 0x39, hsegs);\n\treg_w(sd, 0x3a, vsegs);\n\n\t/* Windows driver does this here; who knows why */\n\treg_w(sd, 0x2f, 0x80);\n\n\t/******** Set the framerate ********/\n\tif (sd->bridge == BRIDGE_OV518PLUS && sd->revision == 0 &&\n\t\t\t\t\t      sd->sensor == SEN_OV7620AE)\n\t\tsd->clockdiv = 0;\n\telse\n\t\tsd->clockdiv = 1;\n\n\t/* Mode independent, but framerate dependent, regs */\n\t/* 0x51: Clock divider; Only works on some cams which use 2 crystals */\n\treg_w(sd, 0x51, 0x04);\n\treg_w(sd, 0x22, 0x18);\n\treg_w(sd, 0x23, 0xff);\n\n\tif (sd->bridge == BRIDGE_OV518PLUS) {\n\t\tswitch (sd->sensor) {\n\t\tcase SEN_OV7620AE:\n\t\t\t/*\n\t\t\t * HdG: 640x480 needs special handling on device\n\t\t\t * revision 2, we check for device revision > 0 to\n\t\t\t * avoid regressions, as we don't know the correct\n\t\t\t * thing todo for revision 1.\n\t\t\t *\n\t\t\t * Also this likely means we don't need to\n\t\t\t * differentiate between the OV7620 and OV7620AE,\n\t\t\t * earlier testing hitting this same problem likely\n\t\t\t * happened to be with revision < 2 cams using an\n\t\t\t * OV7620 and revision 2 cams using an OV7620AE.\n\t\t\t */\n\t\t\tif (sd->revision > 0 &&\n\t\t\t\t\tsd->gspca_dev.pixfmt.width == 640) {\n\t\t\t\treg_w(sd, 0x20, 0x60);\n\t\t\t\treg_w(sd, 0x21, 0x1f);\n\t\t\t} else {\n\t\t\t\treg_w(sd, 0x20, 0x00);\n\t\t\t\treg_w(sd, 0x21, 0x19);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SEN_OV7620:\n\t\t\treg_w(sd, 0x20, 0x00);\n\t\t\treg_w(sd, 0x21, 0x19);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treg_w(sd, 0x21, 0x19);\n\t\t}\n\t} else\n\t\treg_w(sd, 0x71, 0x17);\t/* Compression-related? */\n\n\t/* FIXME: Sensor-specific */\n\t/* Bit 5 is what matters here. Of course, it is \"reserved\" */\n\ti2c_w(sd, 0x54, 0x23);\n\n\treg_w(sd, 0x2f, 0x80);\n\n\tif (sd->bridge == BRIDGE_OV518PLUS) {\n\t\treg_w(sd, 0x24, 0x94);\n\t\treg_w(sd, 0x25, 0x90);\n\t\tov518_reg_w32(sd, 0xc4,    400, 2);\t/* 190h   */\n\t\tov518_reg_w32(sd, 0xc6,    540, 2);\t/* 21ch   */\n\t\tov518_reg_w32(sd, 0xc7,    540, 2);\t/* 21ch   */\n\t\tov518_reg_w32(sd, 0xc8,    108, 2);\t/* 6ch    */\n\t\tov518_reg_w32(sd, 0xca, 131098, 3);\t/* 2001ah */\n\t\tov518_reg_w32(sd, 0xcb,    532, 2);\t/* 214h   */\n\t\tov518_reg_w32(sd, 0xcc,   2400, 2);\t/* 960h   */\n\t\tov518_reg_w32(sd, 0xcd,     32, 2);\t/* 20h    */\n\t\tov518_reg_w32(sd, 0xce,    608, 2);\t/* 260h   */\n\t} else {\n\t\treg_w(sd, 0x24, 0x9f);\n\t\treg_w(sd, 0x25, 0x90);\n\t\tov518_reg_w32(sd, 0xc4,    400, 2);\t/* 190h   */\n\t\tov518_reg_w32(sd, 0xc6,    381, 2);\t/* 17dh   */\n\t\tov518_reg_w32(sd, 0xc7,    381, 2);\t/* 17dh   */\n\t\tov518_reg_w32(sd, 0xc8,    128, 2);\t/* 80h    */\n\t\tov518_reg_w32(sd, 0xca, 183331, 3);\t/* 2cc23h */\n\t\tov518_reg_w32(sd, 0xcb,    746, 2);\t/* 2eah   */\n\t\tov518_reg_w32(sd, 0xcc,   1750, 2);\t/* 6d6h   */\n\t\tov518_reg_w32(sd, 0xcd,     45, 2);\t/* 2dh    */\n\t\tov518_reg_w32(sd, 0xce,    851, 2);\t/* 353h   */\n\t}\n\n\treg_w(sd, 0x2f, 0x80);\n}",
        "patch": "--- code before\n+++ code after\n@@ -10,6 +10,11 @@\n \tif (!alt) {\n \t\tgspca_err(gspca_dev, \"Couldn't get altsetting\\n\");\n \t\tsd->gspca_dev.usb_err = -EIO;\n+\t\treturn;\n+\t}\n+\n+\tif (alt->desc.bNumEndpoints < 1) {\n+\t\tsd->gspca_dev.usb_err = -ENODEV;\n \t\treturn;\n \t}\n ",
        "function_modified_lines": {
            "added": [
                "\t\treturn;",
                "\t}",
                "",
                "\tif (alt->desc.bNumEndpoints < 1) {",
                "\t\tsd->gspca_dev.usb_err = -ENODEV;"
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "An issue was discovered in the Linux kernel before 5.6.1. drivers/media/usb/gspca/ov519.c allows NULL pointer dereferences in ov511_mode_init_regs and ov518_mode_init_regs when there are zero endpoints, aka CID-998912346c0d.",
        "id": 2427
    },
    {
        "cve_id": "CVE-2018-14613",
        "code_before_change": "static int check_leaf_item(struct btrfs_fs_info *fs_info,\n\t\t\t   struct extent_buffer *leaf,\n\t\t\t   struct btrfs_key *key, int slot)\n{\n\tint ret = 0;\n\n\tswitch (key->type) {\n\tcase BTRFS_EXTENT_DATA_KEY:\n\t\tret = check_extent_data_item(fs_info, leaf, key, slot);\n\t\tbreak;\n\tcase BTRFS_EXTENT_CSUM_KEY:\n\t\tret = check_csum_item(fs_info, leaf, key, slot);\n\t\tbreak;\n\tcase BTRFS_DIR_ITEM_KEY:\n\tcase BTRFS_DIR_INDEX_KEY:\n\tcase BTRFS_XATTR_ITEM_KEY:\n\t\tret = check_dir_item(fs_info, leaf, key, slot);\n\t\tbreak;\n\t}\n\treturn ret;\n}",
        "code_after_change": "static int check_leaf_item(struct btrfs_fs_info *fs_info,\n\t\t\t   struct extent_buffer *leaf,\n\t\t\t   struct btrfs_key *key, int slot)\n{\n\tint ret = 0;\n\n\tswitch (key->type) {\n\tcase BTRFS_EXTENT_DATA_KEY:\n\t\tret = check_extent_data_item(fs_info, leaf, key, slot);\n\t\tbreak;\n\tcase BTRFS_EXTENT_CSUM_KEY:\n\t\tret = check_csum_item(fs_info, leaf, key, slot);\n\t\tbreak;\n\tcase BTRFS_DIR_ITEM_KEY:\n\tcase BTRFS_DIR_INDEX_KEY:\n\tcase BTRFS_XATTR_ITEM_KEY:\n\t\tret = check_dir_item(fs_info, leaf, key, slot);\n\t\tbreak;\n\tcase BTRFS_BLOCK_GROUP_ITEM_KEY:\n\t\tret = check_block_group_item(fs_info, leaf, key, slot);\n\t\tbreak;\n\t}\n\treturn ret;\n}",
        "patch": "--- code before\n+++ code after\n@@ -16,6 +16,9 @@\n \tcase BTRFS_XATTR_ITEM_KEY:\n \t\tret = check_dir_item(fs_info, leaf, key, slot);\n \t\tbreak;\n+\tcase BTRFS_BLOCK_GROUP_ITEM_KEY:\n+\t\tret = check_block_group_item(fs_info, leaf, key, slot);\n+\t\tbreak;\n \t}\n \treturn ret;\n }",
        "function_modified_lines": {
            "added": [
                "\tcase BTRFS_BLOCK_GROUP_ITEM_KEY:",
                "\t\tret = check_block_group_item(fs_info, leaf, key, slot);",
                "\t\tbreak;"
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "An issue was discovered in the Linux kernel through 4.17.10. There is an invalid pointer dereference in io_ctl_map_page() when mounting and operating a crafted btrfs image, because of a lack of block group item validation in check_leaf_item in fs/btrfs/tree-checker.c.",
        "id": 1682
    },
    {
        "cve_id": "CVE-2018-13093",
        "code_before_change": "static int\nxfs_iget_cache_miss(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_perag\t*pag,\n\txfs_trans_t\t\t*tp,\n\txfs_ino_t\t\tino,\n\tstruct xfs_inode\t**ipp,\n\tint\t\t\tflags,\n\tint\t\t\tlock_flags)\n{\n\tstruct xfs_inode\t*ip;\n\tint\t\t\terror;\n\txfs_agino_t\t\tagino = XFS_INO_TO_AGINO(mp, ino);\n\tint\t\t\tiflags;\n\n\tip = xfs_inode_alloc(mp, ino);\n\tif (!ip)\n\t\treturn -ENOMEM;\n\n\terror = xfs_iread(mp, tp, ip, flags);\n\tif (error)\n\t\tgoto out_destroy;\n\n\tif (!xfs_inode_verify_forks(ip)) {\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out_destroy;\n\t}\n\n\ttrace_xfs_iget_miss(ip);\n\n\n\t/*\n\t * If we are allocating a new inode, then check what was returned is\n\t * actually a free, empty inode. If we are not allocating an inode,\n\t * the check we didn't find a free inode.\n\t */\n\tif (flags & XFS_IGET_CREATE) {\n\t\tif (VFS_I(ip)->i_mode != 0) {\n\t\t\txfs_warn(mp,\n\"Corruption detected! Free inode 0x%llx not marked free on disk\",\n\t\t\t\tino);\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto out_destroy;\n\t\t}\n\t\tif (ip->i_d.di_nblocks != 0) {\n\t\t\txfs_warn(mp,\n\"Corruption detected! Free inode 0x%llx has blocks allocated!\",\n\t\t\t\tino);\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto out_destroy;\n\t\t}\n\t} else if (VFS_I(ip)->i_mode == 0) {\n\t\terror = -ENOENT;\n\t\tgoto out_destroy;\n\t}\n\n\t/*\n\t * Preload the radix tree so we can insert safely under the\n\t * write spinlock. Note that we cannot sleep inside the preload\n\t * region. Since we can be called from transaction context, don't\n\t * recurse into the file system.\n\t */\n\tif (radix_tree_preload(GFP_NOFS)) {\n\t\terror = -EAGAIN;\n\t\tgoto out_destroy;\n\t}\n\n\t/*\n\t * Because the inode hasn't been added to the radix-tree yet it can't\n\t * be found by another thread, so we can do the non-sleeping lock here.\n\t */\n\tif (lock_flags) {\n\t\tif (!xfs_ilock_nowait(ip, lock_flags))\n\t\t\tBUG();\n\t}\n\n\t/*\n\t * These values must be set before inserting the inode into the radix\n\t * tree as the moment it is inserted a concurrent lookup (allowed by the\n\t * RCU locking mechanism) can find it and that lookup must see that this\n\t * is an inode currently under construction (i.e. that XFS_INEW is set).\n\t * The ip->i_flags_lock that protects the XFS_INEW flag forms the\n\t * memory barrier that ensures this detection works correctly at lookup\n\t * time.\n\t */\n\tiflags = XFS_INEW;\n\tif (flags & XFS_IGET_DONTCACHE)\n\t\tiflags |= XFS_IDONTCACHE;\n\tip->i_udquot = NULL;\n\tip->i_gdquot = NULL;\n\tip->i_pdquot = NULL;\n\txfs_iflags_set(ip, iflags);\n\n\t/* insert the new inode */\n\tspin_lock(&pag->pag_ici_lock);\n\terror = radix_tree_insert(&pag->pag_ici_root, agino, ip);\n\tif (unlikely(error)) {\n\t\tWARN_ON(error != -EEXIST);\n\t\tXFS_STATS_INC(mp, xs_ig_dup);\n\t\terror = -EAGAIN;\n\t\tgoto out_preload_end;\n\t}\n\tspin_unlock(&pag->pag_ici_lock);\n\tradix_tree_preload_end();\n\n\t*ipp = ip;\n\treturn 0;\n\nout_preload_end:\n\tspin_unlock(&pag->pag_ici_lock);\n\tradix_tree_preload_end();\n\tif (lock_flags)\n\t\txfs_iunlock(ip, lock_flags);\nout_destroy:\n\t__destroy_inode(VFS_I(ip));\n\txfs_inode_free(ip);\n\treturn error;\n}",
        "code_after_change": "static int\nxfs_iget_cache_miss(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_perag\t*pag,\n\txfs_trans_t\t\t*tp,\n\txfs_ino_t\t\tino,\n\tstruct xfs_inode\t**ipp,\n\tint\t\t\tflags,\n\tint\t\t\tlock_flags)\n{\n\tstruct xfs_inode\t*ip;\n\tint\t\t\terror;\n\txfs_agino_t\t\tagino = XFS_INO_TO_AGINO(mp, ino);\n\tint\t\t\tiflags;\n\n\tip = xfs_inode_alloc(mp, ino);\n\tif (!ip)\n\t\treturn -ENOMEM;\n\n\terror = xfs_iread(mp, tp, ip, flags);\n\tif (error)\n\t\tgoto out_destroy;\n\n\tif (!xfs_inode_verify_forks(ip)) {\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out_destroy;\n\t}\n\n\ttrace_xfs_iget_miss(ip);\n\n\n\t/*\n\t * Check the inode free state is valid. This also detects lookup\n\t * racing with unlinks.\n\t */\n\terror = xfs_iget_check_free_state(ip, flags);\n\tif (error)\n\t\tgoto out_destroy;\n\n\t/*\n\t * Preload the radix tree so we can insert safely under the\n\t * write spinlock. Note that we cannot sleep inside the preload\n\t * region. Since we can be called from transaction context, don't\n\t * recurse into the file system.\n\t */\n\tif (radix_tree_preload(GFP_NOFS)) {\n\t\terror = -EAGAIN;\n\t\tgoto out_destroy;\n\t}\n\n\t/*\n\t * Because the inode hasn't been added to the radix-tree yet it can't\n\t * be found by another thread, so we can do the non-sleeping lock here.\n\t */\n\tif (lock_flags) {\n\t\tif (!xfs_ilock_nowait(ip, lock_flags))\n\t\t\tBUG();\n\t}\n\n\t/*\n\t * These values must be set before inserting the inode into the radix\n\t * tree as the moment it is inserted a concurrent lookup (allowed by the\n\t * RCU locking mechanism) can find it and that lookup must see that this\n\t * is an inode currently under construction (i.e. that XFS_INEW is set).\n\t * The ip->i_flags_lock that protects the XFS_INEW flag forms the\n\t * memory barrier that ensures this detection works correctly at lookup\n\t * time.\n\t */\n\tiflags = XFS_INEW;\n\tif (flags & XFS_IGET_DONTCACHE)\n\t\tiflags |= XFS_IDONTCACHE;\n\tip->i_udquot = NULL;\n\tip->i_gdquot = NULL;\n\tip->i_pdquot = NULL;\n\txfs_iflags_set(ip, iflags);\n\n\t/* insert the new inode */\n\tspin_lock(&pag->pag_ici_lock);\n\terror = radix_tree_insert(&pag->pag_ici_root, agino, ip);\n\tif (unlikely(error)) {\n\t\tWARN_ON(error != -EEXIST);\n\t\tXFS_STATS_INC(mp, xs_ig_dup);\n\t\terror = -EAGAIN;\n\t\tgoto out_preload_end;\n\t}\n\tspin_unlock(&pag->pag_ici_lock);\n\tradix_tree_preload_end();\n\n\t*ipp = ip;\n\treturn 0;\n\nout_preload_end:\n\tspin_unlock(&pag->pag_ici_lock);\n\tradix_tree_preload_end();\n\tif (lock_flags)\n\t\txfs_iunlock(ip, lock_flags);\nout_destroy:\n\t__destroy_inode(VFS_I(ip));\n\txfs_inode_free(ip);\n\treturn error;\n}",
        "patch": "--- code before\n+++ code after\n@@ -30,29 +30,12 @@\n \n \n \t/*\n-\t * If we are allocating a new inode, then check what was returned is\n-\t * actually a free, empty inode. If we are not allocating an inode,\n-\t * the check we didn't find a free inode.\n+\t * Check the inode free state is valid. This also detects lookup\n+\t * racing with unlinks.\n \t */\n-\tif (flags & XFS_IGET_CREATE) {\n-\t\tif (VFS_I(ip)->i_mode != 0) {\n-\t\t\txfs_warn(mp,\n-\"Corruption detected! Free inode 0x%llx not marked free on disk\",\n-\t\t\t\tino);\n-\t\t\terror = -EFSCORRUPTED;\n-\t\t\tgoto out_destroy;\n-\t\t}\n-\t\tif (ip->i_d.di_nblocks != 0) {\n-\t\t\txfs_warn(mp,\n-\"Corruption detected! Free inode 0x%llx has blocks allocated!\",\n-\t\t\t\tino);\n-\t\t\terror = -EFSCORRUPTED;\n-\t\t\tgoto out_destroy;\n-\t\t}\n-\t} else if (VFS_I(ip)->i_mode == 0) {\n-\t\terror = -ENOENT;\n+\terror = xfs_iget_check_free_state(ip, flags);\n+\tif (error)\n \t\tgoto out_destroy;\n-\t}\n \n \t/*\n \t * Preload the radix tree so we can insert safely under the",
        "function_modified_lines": {
            "added": [
                "\t * Check the inode free state is valid. This also detects lookup",
                "\t * racing with unlinks.",
                "\terror = xfs_iget_check_free_state(ip, flags);",
                "\tif (error)"
            ],
            "deleted": [
                "\t * If we are allocating a new inode, then check what was returned is",
                "\t * actually a free, empty inode. If we are not allocating an inode,",
                "\t * the check we didn't find a free inode.",
                "\tif (flags & XFS_IGET_CREATE) {",
                "\t\tif (VFS_I(ip)->i_mode != 0) {",
                "\t\t\txfs_warn(mp,",
                "\"Corruption detected! Free inode 0x%llx not marked free on disk\",",
                "\t\t\t\tino);",
                "\t\t\terror = -EFSCORRUPTED;",
                "\t\t\tgoto out_destroy;",
                "\t\t}",
                "\t\tif (ip->i_d.di_nblocks != 0) {",
                "\t\t\txfs_warn(mp,",
                "\"Corruption detected! Free inode 0x%llx has blocks allocated!\",",
                "\t\t\t\tino);",
                "\t\t\terror = -EFSCORRUPTED;",
                "\t\t\tgoto out_destroy;",
                "\t\t}",
                "\t} else if (VFS_I(ip)->i_mode == 0) {",
                "\t\terror = -ENOENT;",
                "\t}"
            ]
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "An issue was discovered in fs/xfs/xfs_icache.c in the Linux kernel through 4.17.3. There is a NULL pointer dereference and panic in lookup_slow() on a NULL inode->i_ops pointer when doing pathwalks on a corrupted xfs image. This occurs because of a lack of proper validation that cached inodes are free during allocation.",
        "id": 1667
    },
    {
        "cve_id": "CVE-2019-15098",
        "code_before_change": "static void ath6kl_usb_free_urb_to_pipe(struct ath6kl_usb_pipe *pipe,\n\t\t\t\t\tstruct ath6kl_urb_context *urb_context)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pipe->ar_usb->cs_lock, flags);\n\tpipe->urb_cnt++;\n\n\tlist_add(&urb_context->link, &pipe->urb_list_head);\n\tspin_unlock_irqrestore(&pipe->ar_usb->cs_lock, flags);\n}",
        "code_after_change": "static void ath6kl_usb_free_urb_to_pipe(struct ath6kl_usb_pipe *pipe,\n\t\t\t\t\tstruct ath6kl_urb_context *urb_context)\n{\n\tunsigned long flags;\n\n\t/* bail if this pipe is not initialized */\n\tif (!pipe->ar_usb)\n\t\treturn;\n\n\tspin_lock_irqsave(&pipe->ar_usb->cs_lock, flags);\n\tpipe->urb_cnt++;\n\n\tlist_add(&urb_context->link, &pipe->urb_list_head);\n\tspin_unlock_irqrestore(&pipe->ar_usb->cs_lock, flags);\n}",
        "patch": "--- code before\n+++ code after\n@@ -2,6 +2,10 @@\n \t\t\t\t\tstruct ath6kl_urb_context *urb_context)\n {\n \tunsigned long flags;\n+\n+\t/* bail if this pipe is not initialized */\n+\tif (!pipe->ar_usb)\n+\t\treturn;\n \n \tspin_lock_irqsave(&pipe->ar_usb->cs_lock, flags);\n \tpipe->urb_cnt++;",
        "function_modified_lines": {
            "added": [
                "",
                "\t/* bail if this pipe is not initialized */",
                "\tif (!pipe->ar_usb)",
                "\t\treturn;"
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-476"
        ],
        "cve_description": "drivers/net/wireless/ath/ath6kl/usb.c in the Linux kernel through 5.2.9 has a NULL pointer dereference via an incomplete address in an endpoint descriptor.",
        "id": 1987
    }
]