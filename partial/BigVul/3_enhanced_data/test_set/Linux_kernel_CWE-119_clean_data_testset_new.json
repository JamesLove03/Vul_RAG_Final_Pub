[
  {
    "cve_id": "CVE-2016-6254",
    "code_before_change": "static int parse_packet (sockent_t *se, /* {{{ */\n\t\tvoid *buffer, size_t buffer_size, int flags,\n\t\tconst char *username)\n{\n\tint status;\n\n\tvalue_list_t vl = VALUE_LIST_INIT;\n\tnotification_t n;\n\n#if HAVE_LIBGCRYPT\n\tint packet_was_signed = (flags & PP_SIGNED);\n        int packet_was_encrypted = (flags & PP_ENCRYPTED);\n\tint printed_ignore_warning = 0;\n#endif /* HAVE_LIBGCRYPT */\n\n\n\tmemset (&vl, '\\0', sizeof (vl));\n\tmemset (&n, '\\0', sizeof (n));\n\tstatus = 0;\n\n\twhile ((status == 0) && (0 < buffer_size)\n\t\t\t&& ((unsigned int) buffer_size > sizeof (part_header_t)))\n\t{\n\t\tuint16_t pkg_length;\n\t\tuint16_t pkg_type;\n\n\t\tmemcpy ((void *) &pkg_type,\n\t\t\t\t(void *) buffer,\n\t\t\t\tsizeof (pkg_type));\n\t\tmemcpy ((void *) &pkg_length,\n\t\t\t\t(void *) (buffer + sizeof (pkg_type)),\n\t\t\t\tsizeof (pkg_length));\n\n\t\tpkg_length = ntohs (pkg_length);\n\t\tpkg_type = ntohs (pkg_type);\n\n\t\tif (pkg_length > buffer_size)\n\t\t\tbreak;\n\t\t/* Ensure that this loop terminates eventually */\n\t\tif (pkg_length < (2 * sizeof (uint16_t)))\n\t\t\tbreak;\n\n\t\tif (pkg_type == TYPE_ENCR_AES256)\n\t\t{\n\t\t\tstatus = parse_part_encr_aes256 (se,\n\t\t\t\t\t&buffer, &buffer_size, flags);\n\t\t\tif (status != 0)\n\t\t\t{\n\t\t\t\tERROR (\"network plugin: Decrypting AES256 \"\n\t\t\t\t\t\t\"part failed \"\n\t\t\t\t\t\t\"with status %i.\", status);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n#if HAVE_LIBGCRYPT\n\t\telse if ((se->data.server.security_level == SECURITY_LEVEL_ENCRYPT)\n\t\t\t\t&& (packet_was_encrypted == 0))\n\t\t{\n\t\t\tif (printed_ignore_warning == 0)\n\t\t\t{\n\t\t\t\tINFO (\"network plugin: Unencrypted packet or \"\n\t\t\t\t\t\t\"part has been ignored.\");\n \t\t\t\tprinted_ignore_warning = 1;\n \t\t\t}\n \t\t\tbuffer = ((char *) buffer) + pkg_length;\n \t\t\tcontinue;\n \t\t}\n #endif /* HAVE_LIBGCRYPT */\n\t\telse if (pkg_type == TYPE_SIGN_SHA256)\n\t\t{\n\t\t\tstatus = parse_part_sign_sha256 (se,\n                                        &buffer, &buffer_size, flags);\n\t\t\tif (status != 0)\n\t\t\t{\n\t\t\t\tERROR (\"network plugin: Verifying HMAC-SHA-256 \"\n\t\t\t\t\t\t\"signature failed \"\n\t\t\t\t\t\t\"with status %i.\", status);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n#if HAVE_LIBGCRYPT\n\t\telse if ((se->data.server.security_level == SECURITY_LEVEL_SIGN)\n\t\t\t\t&& (packet_was_encrypted == 0)\n\t\t\t\t&& (packet_was_signed == 0))\n\t\t{\n\t\t\tif (printed_ignore_warning == 0)\n\t\t\t{\n\t\t\t\tINFO (\"network plugin: Unsigned packet or \"\n\t\t\t\t\t\t\"part has been ignored.\");\n \t\t\t\tprinted_ignore_warning = 1;\n \t\t\t}\n \t\t\tbuffer = ((char *) buffer) + pkg_length;\n \t\t\tcontinue;\n \t\t}\n #endif /* HAVE_LIBGCRYPT */\n\t\telse if (pkg_type == TYPE_VALUES)\n\t\t{\n\t\t\tstatus = parse_part_values (&buffer, &buffer_size,\n\t\t\t\t\t&vl.values, &vl.values_len);\n\t\t\tif (status != 0)\n\t\t\t\tbreak;\n\n\t\t\tnetwork_dispatch_values (&vl, username);\n\n\t\t\tsfree (vl.values);\n\t\t}\n\t\telse if (pkg_type == TYPE_TIME)\n\t\t{\n\t\t\tuint64_t tmp = 0;\n\t\t\tstatus = parse_part_number (&buffer, &buffer_size,\n\t\t\t\t\t&tmp);\n\t\t\tif (status == 0)\n\t\t\t{\n\t\t\t\tvl.time = TIME_T_TO_CDTIME_T (tmp);\n\t\t\t\tn.time  = TIME_T_TO_CDTIME_T (tmp);\n\t\t\t}\n\t\t}\n\t\telse if (pkg_type == TYPE_TIME_HR)\n\t\t{\n\t\t\tuint64_t tmp = 0;\n\t\t\tstatus = parse_part_number (&buffer, &buffer_size,\n\t\t\t\t\t&tmp);\n\t\t\tif (status == 0)\n\t\t\t{\n\t\t\t\tvl.time = (cdtime_t) tmp;\n\t\t\t\tn.time  = (cdtime_t) tmp;\n\t\t\t}\n\t\t}\n\t\telse if (pkg_type == TYPE_INTERVAL)\n\t\t{\n\t\t\tuint64_t tmp = 0;\n\t\t\tstatus = parse_part_number (&buffer, &buffer_size,\n\t\t\t\t\t&tmp);\n\t\t\tif (status == 0)\n\t\t\t\tvl.interval = TIME_T_TO_CDTIME_T (tmp);\n\t\t}\n\t\telse if (pkg_type == TYPE_INTERVAL_HR)\n\t\t{\n\t\t\tuint64_t tmp = 0;\n\t\t\tstatus = parse_part_number (&buffer, &buffer_size,\n\t\t\t\t\t&tmp);\n\t\t\tif (status == 0)\n\t\t\t\tvl.interval = (cdtime_t) tmp;\n\t\t}\n\t\telse if (pkg_type == TYPE_HOST)\n\t\t{\n\t\t\tstatus = parse_part_string (&buffer, &buffer_size,\n\t\t\t\t\tvl.host, sizeof (vl.host));\n\t\t\tif (status == 0)\n\t\t\t\tsstrncpy (n.host, vl.host, sizeof (n.host));\n\t\t}\n\t\telse if (pkg_type == TYPE_PLUGIN)\n\t\t{\n\t\t\tstatus = parse_part_string (&buffer, &buffer_size,\n\t\t\t\t\tvl.plugin, sizeof (vl.plugin));\n\t\t\tif (status == 0)\n\t\t\t\tsstrncpy (n.plugin, vl.plugin,\n\t\t\t\t\t\tsizeof (n.plugin));\n\t\t}\n\t\telse if (pkg_type == TYPE_PLUGIN_INSTANCE)\n\t\t{\n\t\t\tstatus = parse_part_string (&buffer, &buffer_size,\n\t\t\t\t\tvl.plugin_instance,\n\t\t\t\t\tsizeof (vl.plugin_instance));\n\t\t\tif (status == 0)\n\t\t\t\tsstrncpy (n.plugin_instance,\n\t\t\t\t\t\tvl.plugin_instance,\n\t\t\t\t\t\tsizeof (n.plugin_instance));\n\t\t}\n\t\telse if (pkg_type == TYPE_TYPE)\n\t\t{\n\t\t\tstatus = parse_part_string (&buffer, &buffer_size,\n\t\t\t\t\tvl.type, sizeof (vl.type));\n\t\t\tif (status == 0)\n\t\t\t\tsstrncpy (n.type, vl.type, sizeof (n.type));\n\t\t}\n\t\telse if (pkg_type == TYPE_TYPE_INSTANCE)\n\t\t{\n\t\t\tstatus = parse_part_string (&buffer, &buffer_size,\n\t\t\t\t\tvl.type_instance,\n\t\t\t\t\tsizeof (vl.type_instance));\n\t\t\tif (status == 0)\n\t\t\t\tsstrncpy (n.type_instance, vl.type_instance,\n\t\t\t\t\t\tsizeof (n.type_instance));\n\t\t}\n\t\telse if (pkg_type == TYPE_MESSAGE)\n\t\t{\n\t\t\tstatus = parse_part_string (&buffer, &buffer_size,\n\t\t\t\t\tn.message, sizeof (n.message));\n\n\t\t\tif (status != 0)\n\t\t\t{\n\t\t\t\t/* do nothing */\n\t\t\t}\n\t\t\telse if ((n.severity != NOTIF_FAILURE)\n\t\t\t\t\t&& (n.severity != NOTIF_WARNING)\n\t\t\t\t\t&& (n.severity != NOTIF_OKAY))\n\t\t\t{\n\t\t\t\tINFO (\"network plugin: \"\n\t\t\t\t\t\t\"Ignoring notification with \"\n\t\t\t\t\t\t\"unknown severity %i.\",\n\t\t\t\t\t\tn.severity);\n\t\t\t}\n\t\t\telse if (n.time <= 0)\n\t\t\t{\n\t\t\t\tINFO (\"network plugin: \"\n\t\t\t\t\t\t\"Ignoring notification with \"\n\t\t\t\t\t\t\"time == 0.\");\n\t\t\t}\n\t\t\telse if (strlen (n.message) <= 0)\n\t\t\t{\n\t\t\t\tINFO (\"network plugin: \"\n\t\t\t\t\t\t\"Ignoring notification with \"\n\t\t\t\t\t\t\"an empty message.\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnetwork_dispatch_notification (&n);\n\t\t\t}\n\t\t}\n\t\telse if (pkg_type == TYPE_SEVERITY)\n\t\t{\n\t\t\tuint64_t tmp = 0;\n\t\t\tstatus = parse_part_number (&buffer, &buffer_size,\n\t\t\t\t\t&tmp);\n\t\t\tif (status == 0)\n\t\t\t\tn.severity = (int) tmp;\n\t\t}\n\t\telse\n\t\t{\n \t\t\tDEBUG (\"network plugin: parse_packet: Unknown part\"\n \t\t\t\t\t\" type: 0x%04hx\", pkg_type);\n \t\t\tbuffer = ((char *) buffer) + pkg_length;\n \t\t}\n \t} /* while (buffer_size > sizeof (part_header_t)) */\n \n\tif (status == 0 && buffer_size > 0)\n\t\tWARNING (\"network plugin: parse_packet: Received truncated \"\n\t\t\t\t\"packet, try increasing `MaxPacketSize'\");\n\n\treturn (status);\n} /* }}} int parse_packet */\n",
    "code_after_change": "static int parse_packet (sockent_t *se, /* {{{ */\n\t\tvoid *buffer, size_t buffer_size, int flags,\n\t\tconst char *username)\n{\n\tint status;\n\n\tvalue_list_t vl = VALUE_LIST_INIT;\n\tnotification_t n;\n\n#if HAVE_LIBGCRYPT\n\tint packet_was_signed = (flags & PP_SIGNED);\n        int packet_was_encrypted = (flags & PP_ENCRYPTED);\n\tint printed_ignore_warning = 0;\n#endif /* HAVE_LIBGCRYPT */\n\n\n\tmemset (&vl, '\\0', sizeof (vl));\n\tmemset (&n, '\\0', sizeof (n));\n\tstatus = 0;\n\n\twhile ((status == 0) && (0 < buffer_size)\n\t\t\t&& ((unsigned int) buffer_size > sizeof (part_header_t)))\n\t{\n\t\tuint16_t pkg_length;\n\t\tuint16_t pkg_type;\n\n\t\tmemcpy ((void *) &pkg_type,\n\t\t\t\t(void *) buffer,\n\t\t\t\tsizeof (pkg_type));\n\t\tmemcpy ((void *) &pkg_length,\n\t\t\t\t(void *) (buffer + sizeof (pkg_type)),\n\t\t\t\tsizeof (pkg_length));\n\n\t\tpkg_length = ntohs (pkg_length);\n\t\tpkg_type = ntohs (pkg_type);\n\n\t\tif (pkg_length > buffer_size)\n\t\t\tbreak;\n\t\t/* Ensure that this loop terminates eventually */\n\t\tif (pkg_length < (2 * sizeof (uint16_t)))\n\t\t\tbreak;\n\n\t\tif (pkg_type == TYPE_ENCR_AES256)\n\t\t{\n\t\t\tstatus = parse_part_encr_aes256 (se,\n\t\t\t\t\t&buffer, &buffer_size, flags);\n\t\t\tif (status != 0)\n\t\t\t{\n\t\t\t\tERROR (\"network plugin: Decrypting AES256 \"\n\t\t\t\t\t\t\"part failed \"\n\t\t\t\t\t\t\"with status %i.\", status);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n#if HAVE_LIBGCRYPT\n\t\telse if ((se->data.server.security_level == SECURITY_LEVEL_ENCRYPT)\n\t\t\t\t&& (packet_was_encrypted == 0))\n\t\t{\n\t\t\tif (printed_ignore_warning == 0)\n\t\t\t{\n\t\t\t\tINFO (\"network plugin: Unencrypted packet or \"\n\t\t\t\t\t\t\"part has been ignored.\");\n \t\t\t\tprinted_ignore_warning = 1;\n \t\t\t}\n \t\t\tbuffer = ((char *) buffer) + pkg_length;\n\t\t\tbuffer_size -= (size_t) pkg_length;\n \t\t\tcontinue;\n \t\t}\n #endif /* HAVE_LIBGCRYPT */\n\t\telse if (pkg_type == TYPE_SIGN_SHA256)\n\t\t{\n\t\t\tstatus = parse_part_sign_sha256 (se,\n                                        &buffer, &buffer_size, flags);\n\t\t\tif (status != 0)\n\t\t\t{\n\t\t\t\tERROR (\"network plugin: Verifying HMAC-SHA-256 \"\n\t\t\t\t\t\t\"signature failed \"\n\t\t\t\t\t\t\"with status %i.\", status);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n#if HAVE_LIBGCRYPT\n\t\telse if ((se->data.server.security_level == SECURITY_LEVEL_SIGN)\n\t\t\t\t&& (packet_was_encrypted == 0)\n\t\t\t\t&& (packet_was_signed == 0))\n\t\t{\n\t\t\tif (printed_ignore_warning == 0)\n\t\t\t{\n\t\t\t\tINFO (\"network plugin: Unsigned packet or \"\n\t\t\t\t\t\t\"part has been ignored.\");\n \t\t\t\tprinted_ignore_warning = 1;\n \t\t\t}\n \t\t\tbuffer = ((char *) buffer) + pkg_length;\n\t\t\tbuffer_size -= (size_t) pkg_length;\n \t\t\tcontinue;\n \t\t}\n #endif /* HAVE_LIBGCRYPT */\n\t\telse if (pkg_type == TYPE_VALUES)\n\t\t{\n\t\t\tstatus = parse_part_values (&buffer, &buffer_size,\n\t\t\t\t\t&vl.values, &vl.values_len);\n\t\t\tif (status != 0)\n\t\t\t\tbreak;\n\n\t\t\tnetwork_dispatch_values (&vl, username);\n\n\t\t\tsfree (vl.values);\n\t\t}\n\t\telse if (pkg_type == TYPE_TIME)\n\t\t{\n\t\t\tuint64_t tmp = 0;\n\t\t\tstatus = parse_part_number (&buffer, &buffer_size,\n\t\t\t\t\t&tmp);\n\t\t\tif (status == 0)\n\t\t\t{\n\t\t\t\tvl.time = TIME_T_TO_CDTIME_T (tmp);\n\t\t\t\tn.time  = TIME_T_TO_CDTIME_T (tmp);\n\t\t\t}\n\t\t}\n\t\telse if (pkg_type == TYPE_TIME_HR)\n\t\t{\n\t\t\tuint64_t tmp = 0;\n\t\t\tstatus = parse_part_number (&buffer, &buffer_size,\n\t\t\t\t\t&tmp);\n\t\t\tif (status == 0)\n\t\t\t{\n\t\t\t\tvl.time = (cdtime_t) tmp;\n\t\t\t\tn.time  = (cdtime_t) tmp;\n\t\t\t}\n\t\t}\n\t\telse if (pkg_type == TYPE_INTERVAL)\n\t\t{\n\t\t\tuint64_t tmp = 0;\n\t\t\tstatus = parse_part_number (&buffer, &buffer_size,\n\t\t\t\t\t&tmp);\n\t\t\tif (status == 0)\n\t\t\t\tvl.interval = TIME_T_TO_CDTIME_T (tmp);\n\t\t}\n\t\telse if (pkg_type == TYPE_INTERVAL_HR)\n\t\t{\n\t\t\tuint64_t tmp = 0;\n\t\t\tstatus = parse_part_number (&buffer, &buffer_size,\n\t\t\t\t\t&tmp);\n\t\t\tif (status == 0)\n\t\t\t\tvl.interval = (cdtime_t) tmp;\n\t\t}\n\t\telse if (pkg_type == TYPE_HOST)\n\t\t{\n\t\t\tstatus = parse_part_string (&buffer, &buffer_size,\n\t\t\t\t\tvl.host, sizeof (vl.host));\n\t\t\tif (status == 0)\n\t\t\t\tsstrncpy (n.host, vl.host, sizeof (n.host));\n\t\t}\n\t\telse if (pkg_type == TYPE_PLUGIN)\n\t\t{\n\t\t\tstatus = parse_part_string (&buffer, &buffer_size,\n\t\t\t\t\tvl.plugin, sizeof (vl.plugin));\n\t\t\tif (status == 0)\n\t\t\t\tsstrncpy (n.plugin, vl.plugin,\n\t\t\t\t\t\tsizeof (n.plugin));\n\t\t}\n\t\telse if (pkg_type == TYPE_PLUGIN_INSTANCE)\n\t\t{\n\t\t\tstatus = parse_part_string (&buffer, &buffer_size,\n\t\t\t\t\tvl.plugin_instance,\n\t\t\t\t\tsizeof (vl.plugin_instance));\n\t\t\tif (status == 0)\n\t\t\t\tsstrncpy (n.plugin_instance,\n\t\t\t\t\t\tvl.plugin_instance,\n\t\t\t\t\t\tsizeof (n.plugin_instance));\n\t\t}\n\t\telse if (pkg_type == TYPE_TYPE)\n\t\t{\n\t\t\tstatus = parse_part_string (&buffer, &buffer_size,\n\t\t\t\t\tvl.type, sizeof (vl.type));\n\t\t\tif (status == 0)\n\t\t\t\tsstrncpy (n.type, vl.type, sizeof (n.type));\n\t\t}\n\t\telse if (pkg_type == TYPE_TYPE_INSTANCE)\n\t\t{\n\t\t\tstatus = parse_part_string (&buffer, &buffer_size,\n\t\t\t\t\tvl.type_instance,\n\t\t\t\t\tsizeof (vl.type_instance));\n\t\t\tif (status == 0)\n\t\t\t\tsstrncpy (n.type_instance, vl.type_instance,\n\t\t\t\t\t\tsizeof (n.type_instance));\n\t\t}\n\t\telse if (pkg_type == TYPE_MESSAGE)\n\t\t{\n\t\t\tstatus = parse_part_string (&buffer, &buffer_size,\n\t\t\t\t\tn.message, sizeof (n.message));\n\n\t\t\tif (status != 0)\n\t\t\t{\n\t\t\t\t/* do nothing */\n\t\t\t}\n\t\t\telse if ((n.severity != NOTIF_FAILURE)\n\t\t\t\t\t&& (n.severity != NOTIF_WARNING)\n\t\t\t\t\t&& (n.severity != NOTIF_OKAY))\n\t\t\t{\n\t\t\t\tINFO (\"network plugin: \"\n\t\t\t\t\t\t\"Ignoring notification with \"\n\t\t\t\t\t\t\"unknown severity %i.\",\n\t\t\t\t\t\tn.severity);\n\t\t\t}\n\t\t\telse if (n.time <= 0)\n\t\t\t{\n\t\t\t\tINFO (\"network plugin: \"\n\t\t\t\t\t\t\"Ignoring notification with \"\n\t\t\t\t\t\t\"time == 0.\");\n\t\t\t}\n\t\t\telse if (strlen (n.message) <= 0)\n\t\t\t{\n\t\t\t\tINFO (\"network plugin: \"\n\t\t\t\t\t\t\"Ignoring notification with \"\n\t\t\t\t\t\t\"an empty message.\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnetwork_dispatch_notification (&n);\n\t\t\t}\n\t\t}\n\t\telse if (pkg_type == TYPE_SEVERITY)\n\t\t{\n\t\t\tuint64_t tmp = 0;\n\t\t\tstatus = parse_part_number (&buffer, &buffer_size,\n\t\t\t\t\t&tmp);\n\t\t\tif (status == 0)\n\t\t\t\tn.severity = (int) tmp;\n\t\t}\n\t\telse\n\t\t{\n \t\t\tDEBUG (\"network plugin: parse_packet: Unknown part\"\n \t\t\t\t\t\" type: 0x%04hx\", pkg_type);\n \t\t\tbuffer = ((char *) buffer) + pkg_length;\n\t\t\tbuffer_size -= (size_t) pkg_length;\n \t\t}\n \t} /* while (buffer_size > sizeof (part_header_t)) */\n \n\tif (status == 0 && buffer_size > 0)\n\t\tWARNING (\"network plugin: parse_packet: Received truncated \"\n\t\t\t\t\"packet, try increasing `MaxPacketSize'\");\n\n\treturn (status);\n} /* }}} int parse_packet */\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 0,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-1621",
    "code_before_change": " vpx_codec_err_t Decoder::DecodeFrame(const uint8_t *cxdata, size_t size) {\n   vpx_codec_err_t res_dec;\n   InitOnce();\n  REGISTER_STATE_CHECK(\n       res_dec = vpx_codec_decode(&decoder_,\n                                  cxdata, static_cast<unsigned int>(size),\n                                 NULL, 0));\n   return res_dec;\n }\n",
    "code_after_change": " vpx_codec_err_t Decoder::DecodeFrame(const uint8_t *cxdata, size_t size) {\n  return DecodeFrame(cxdata, size, NULL);\n}\n\nvpx_codec_err_t Decoder::DecodeFrame(const uint8_t *cxdata, size_t size,\n                                     void *user_priv) {\n   vpx_codec_err_t res_dec;\n   InitOnce();\n  API_REGISTER_STATE_CHECK(\n       res_dec = vpx_codec_decode(&decoder_,\n                                  cxdata, static_cast<unsigned int>(size),\n                                 user_priv, 0));\n   return res_dec;\n }\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 2,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-1621",
    "code_before_change": "double VideoTrack::GetFrameRate() const\n{\n    return m_rate;\n}\n",
    "code_after_change": "double VideoTrack::GetFrameRate() const\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 5,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-1621",
    "code_before_change": "bool Block::IsInvisible() const\n{\n    return bool(int(m_flags & 0x08) != 0);\n }\n",
    "code_after_change": "bool Block::IsInvisible() const\nconst Block::Frame& Block::GetFrame(int idx) const {\n  assert(idx >= 0);\n  assert(idx < m_frame_count);\n\n  const Frame& f = m_frames[idx];\n  assert(f.pos > 0);\n  assert(f.len > 0);\n\n  return f;\n }\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 24,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2017-7476",
    "code_before_change": "main (int argc _GL_UNUSED, char **argv)\n{\n  struct timespec result;\n  struct timespec result2;\n  struct timespec expected;\n  struct timespec now;\n  const char *p;\n  int i;\n  long gmtoff;\n  time_t ref_time = 1304250918;\n\n  /* Set the time zone to US Eastern time with the 2012 rules.  This\n     should disable any leap second support.  Otherwise, there will be\n     a problem with glibc on sites that default to leap seconds; see\n     <http://bugs.gnu.org/12206>.  */\n  setenv (\"TZ\", \"EST5EDT,M3.2.0,M11.1.0\", 1);\n\n  gmtoff = gmt_offset (ref_time);\n\n\n  /* ISO 8601 extended date and time of day representation,\n     'T' separator, local time zone */\n  p = \"2011-05-01T11:55:18\";\n  expected.tv_sec = ref_time - gmtoff;\n  expected.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, 0));\n  LOG (p, expected, result);\n  ASSERT (expected.tv_sec == result.tv_sec\n          && expected.tv_nsec == result.tv_nsec);\n\n  /* ISO 8601 extended date and time of day representation,\n     ' ' separator, local time zone */\n  p = \"2011-05-01 11:55:18\";\n  expected.tv_sec = ref_time - gmtoff;\n  expected.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, 0));\n  LOG (p, expected, result);\n  ASSERT (expected.tv_sec == result.tv_sec\n          && expected.tv_nsec == result.tv_nsec);\n\n\n  /* ISO 8601, extended date and time of day representation,\n     'T' separator, UTC */\n  p = \"2011-05-01T11:55:18Z\";\n  expected.tv_sec = ref_time;\n  expected.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, 0));\n  LOG (p, expected, result);\n  ASSERT (expected.tv_sec == result.tv_sec\n          && expected.tv_nsec == result.tv_nsec);\n\n  /* ISO 8601, extended date and time of day representation,\n     ' ' separator, UTC */\n  p = \"2011-05-01 11:55:18Z\";\n  expected.tv_sec = ref_time;\n  expected.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, 0));\n  LOG (p, expected, result);\n  ASSERT (expected.tv_sec == result.tv_sec\n          && expected.tv_nsec == result.tv_nsec);\n\n\n  /* ISO 8601 extended date and time of day representation,\n     'T' separator, w/UTC offset */\n  p = \"2011-05-01T11:55:18-07:00\";\n  expected.tv_sec = 1304276118;\n  expected.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, 0));\n  LOG (p, expected, result);\n  ASSERT (expected.tv_sec == result.tv_sec\n          && expected.tv_nsec == result.tv_nsec);\n\n  /* ISO 8601 extended date and time of day representation,\n     ' ' separator, w/UTC offset */\n  p = \"2011-05-01 11:55:18-07:00\";\n  expected.tv_sec = 1304276118;\n  expected.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, 0));\n  LOG (p, expected, result);\n  ASSERT (expected.tv_sec == result.tv_sec\n          && expected.tv_nsec == result.tv_nsec);\n\n\n  /* ISO 8601 extended date and time of day representation,\n     'T' separator, w/hour only UTC offset */\n  p = \"2011-05-01T11:55:18-07\";\n  expected.tv_sec = 1304276118;\n  expected.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, 0));\n  LOG (p, expected, result);\n  ASSERT (expected.tv_sec == result.tv_sec\n          && expected.tv_nsec == result.tv_nsec);\n\n  /* ISO 8601 extended date and time of day representation,\n     ' ' separator, w/hour only UTC offset */\n  p = \"2011-05-01 11:55:18-07\";\n  expected.tv_sec = 1304276118;\n  expected.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, 0));\n  LOG (p, expected, result);\n  ASSERT (expected.tv_sec == result.tv_sec\n          && expected.tv_nsec == result.tv_nsec);\n\n\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"now\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  ASSERT (now.tv_sec == result.tv_sec && now.tv_nsec == result.tv_nsec);\n\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"tomorrow\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  ASSERT (now.tv_sec + 24 * 60 * 60 == result.tv_sec\n          && now.tv_nsec == result.tv_nsec);\n\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"yesterday\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  ASSERT (now.tv_sec - 24 * 60 * 60 == result.tv_sec\n          && now.tv_nsec == result.tv_nsec);\n\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"4 hours\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  ASSERT (now.tv_sec + 4 * 60 * 60 == result.tv_sec\n          && now.tv_nsec == result.tv_nsec);\n\n  /* test if timezone is not being ignored for day offset */\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC+400 +24 hours\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  p = \"UTC+400 +1 day\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n\n  /* test if several time zones formats are handled same way */\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC+14:00\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  p = \"UTC+14\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n  p = \"UTC+1400\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC-14:00\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  p = \"UTC-14\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n  p = \"UTC-1400\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC+0:15\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  p = \"UTC+0015\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC-1:30\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  p = \"UTC-130\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n\n\n  /* TZ out of range should cause parse_datetime failure */\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC+25:00\";\n  ASSERT (!parse_datetime (&result, p, &now));\n\n        /* Check for several invalid countable dayshifts */\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC+4:00 +40 yesterday\";\n  ASSERT (!parse_datetime (&result, p, &now));\n  p = \"UTC+4:00 next yesterday\";\n  ASSERT (!parse_datetime (&result, p, &now));\n  p = \"UTC+4:00 tomorrow ago\";\n  ASSERT (!parse_datetime (&result, p, &now));\n  p = \"UTC+4:00 tomorrow hence\";\n  ASSERT (!parse_datetime (&result, p, &now));\n  p = \"UTC+4:00 40 now ago\";\n  ASSERT (!parse_datetime (&result, p, &now));\n  p = \"UTC+4:00 last tomorrow\";\n  ASSERT (!parse_datetime (&result, p, &now));\n  p = \"UTC+4:00 -4 today\";\n  ASSERT (!parse_datetime (&result, p, &now));\n\n  /* And check correct usage of dayshifts */\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC+400 tomorrow\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  p = \"UTC+400 +1 day\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n  p = \"UTC+400 1 day hence\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC+400 yesterday\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  p = \"UTC+400 1 day ago\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC+400 now\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  p = \"UTC+400 +0 minutes\"; /* silly, but simple \"UTC+400\" is different*/\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n\n  /* Check that some \"next Monday\", \"last Wednesday\", etc. are correct.  */\n  setenv (\"TZ\", \"UTC0\", 1);\n  for (i = 0; day_table[i]; i++)\n    {\n      unsigned int thur2 = 7 * 24 * 3600; /* 2nd thursday */\n      char tmp[32];\n      sprintf (tmp, \"NEXT %s\", day_table[i]);\n      now.tv_sec = thur2 + 4711;\n      now.tv_nsec = 1267;\n      ASSERT (parse_datetime (&result, tmp, &now));\n      LOG (tmp, now, result);\n      ASSERT (result.tv_nsec == 0);\n      ASSERT (result.tv_sec == thur2 + (i == 4 ? 7 : (i + 3) % 7) * 24 * 3600);\n\n      sprintf (tmp, \"LAST %s\", day_table[i]);\n      now.tv_sec = thur2 + 4711;\n      now.tv_nsec = 1267;\n      ASSERT (parse_datetime (&result, tmp, &now));\n      LOG (tmp, now, result);\n      ASSERT (result.tv_nsec == 0);\n      ASSERT (result.tv_sec == thur2 + ((i + 3) % 7 - 7) * 24 * 3600);\n    }\n\n  p = \"THURSDAY UTC+00\";  /* The epoch was on Thursday.  */\n  now.tv_sec = 0;\n  now.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  ASSERT (result.tv_sec == now.tv_sec\n          && result.tv_nsec == now.tv_nsec);\n\n  p = \"FRIDAY UTC+00\";\n  now.tv_sec = 0;\n  now.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  ASSERT (result.tv_sec == 24 * 3600\n          && result.tv_nsec == now.tv_nsec);\n\n  /* Exercise a sign-extension bug.  Before July 2012, an input\n     starting with a high-bit-set byte would be treated like \"0\".  */\n  ASSERT ( ! parse_datetime (&result, \"\\xb0\", &now));\n\n  /* Exercise TZ=\"\" parsing code.  */\n  /* These two would infloop or segfault before Feb 2014.  */\n  ASSERT ( ! parse_datetime (&result, \"TZ=\\\"\\\"\\\"\", &now));\n  ASSERT ( ! parse_datetime (&result, \"TZ=\\\"\\\" \\\"\", &now));\n  /* Exercise invalid patterns.  */\n  ASSERT ( ! parse_datetime (&result, \"TZ=\\\"\", &now));\n  ASSERT ( ! parse_datetime (&result, \"TZ=\\\"\\\\\\\"\", &now));\n  ASSERT ( ! parse_datetime (&result, \"TZ=\\\"\\\\n\", &now));\n  ASSERT ( ! parse_datetime (&result, \"TZ=\\\"\\\\n\\\"\", &now));\n  /* Exercise valid patterns.  */\n  ASSERT (   parse_datetime (&result, \"TZ=\\\"\\\"\", &now));\n  ASSERT (   parse_datetime (&result, \"TZ=\\\"\\\" \", &now));\n  ASSERT (   parse_datetime (&result, \" TZ=\\\"\\\"\", &now));\n   ASSERT (   parse_datetime (&result, \"TZ=\\\"\\\\\\\\\\\"\", &now));\n   ASSERT (   parse_datetime (&result, \"TZ=\\\"\\\\\\\"\\\"\", &now));\n \n   return 0;\n }\n",
    "code_after_change": "main (int argc _GL_UNUSED, char **argv)\n{\n  struct timespec result;\n  struct timespec result2;\n  struct timespec expected;\n  struct timespec now;\n  const char *p;\n  int i;\n  long gmtoff;\n  time_t ref_time = 1304250918;\n\n  /* Set the time zone to US Eastern time with the 2012 rules.  This\n     should disable any leap second support.  Otherwise, there will be\n     a problem with glibc on sites that default to leap seconds; see\n     <http://bugs.gnu.org/12206>.  */\n  setenv (\"TZ\", \"EST5EDT,M3.2.0,M11.1.0\", 1);\n\n  gmtoff = gmt_offset (ref_time);\n\n\n  /* ISO 8601 extended date and time of day representation,\n     'T' separator, local time zone */\n  p = \"2011-05-01T11:55:18\";\n  expected.tv_sec = ref_time - gmtoff;\n  expected.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, 0));\n  LOG (p, expected, result);\n  ASSERT (expected.tv_sec == result.tv_sec\n          && expected.tv_nsec == result.tv_nsec);\n\n  /* ISO 8601 extended date and time of day representation,\n     ' ' separator, local time zone */\n  p = \"2011-05-01 11:55:18\";\n  expected.tv_sec = ref_time - gmtoff;\n  expected.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, 0));\n  LOG (p, expected, result);\n  ASSERT (expected.tv_sec == result.tv_sec\n          && expected.tv_nsec == result.tv_nsec);\n\n\n  /* ISO 8601, extended date and time of day representation,\n     'T' separator, UTC */\n  p = \"2011-05-01T11:55:18Z\";\n  expected.tv_sec = ref_time;\n  expected.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, 0));\n  LOG (p, expected, result);\n  ASSERT (expected.tv_sec == result.tv_sec\n          && expected.tv_nsec == result.tv_nsec);\n\n  /* ISO 8601, extended date and time of day representation,\n     ' ' separator, UTC */\n  p = \"2011-05-01 11:55:18Z\";\n  expected.tv_sec = ref_time;\n  expected.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, 0));\n  LOG (p, expected, result);\n  ASSERT (expected.tv_sec == result.tv_sec\n          && expected.tv_nsec == result.tv_nsec);\n\n\n  /* ISO 8601 extended date and time of day representation,\n     'T' separator, w/UTC offset */\n  p = \"2011-05-01T11:55:18-07:00\";\n  expected.tv_sec = 1304276118;\n  expected.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, 0));\n  LOG (p, expected, result);\n  ASSERT (expected.tv_sec == result.tv_sec\n          && expected.tv_nsec == result.tv_nsec);\n\n  /* ISO 8601 extended date and time of day representation,\n     ' ' separator, w/UTC offset */\n  p = \"2011-05-01 11:55:18-07:00\";\n  expected.tv_sec = 1304276118;\n  expected.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, 0));\n  LOG (p, expected, result);\n  ASSERT (expected.tv_sec == result.tv_sec\n          && expected.tv_nsec == result.tv_nsec);\n\n\n  /* ISO 8601 extended date and time of day representation,\n     'T' separator, w/hour only UTC offset */\n  p = \"2011-05-01T11:55:18-07\";\n  expected.tv_sec = 1304276118;\n  expected.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, 0));\n  LOG (p, expected, result);\n  ASSERT (expected.tv_sec == result.tv_sec\n          && expected.tv_nsec == result.tv_nsec);\n\n  /* ISO 8601 extended date and time of day representation,\n     ' ' separator, w/hour only UTC offset */\n  p = \"2011-05-01 11:55:18-07\";\n  expected.tv_sec = 1304276118;\n  expected.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, 0));\n  LOG (p, expected, result);\n  ASSERT (expected.tv_sec == result.tv_sec\n          && expected.tv_nsec == result.tv_nsec);\n\n\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"now\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  ASSERT (now.tv_sec == result.tv_sec && now.tv_nsec == result.tv_nsec);\n\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"tomorrow\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  ASSERT (now.tv_sec + 24 * 60 * 60 == result.tv_sec\n          && now.tv_nsec == result.tv_nsec);\n\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"yesterday\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  ASSERT (now.tv_sec - 24 * 60 * 60 == result.tv_sec\n          && now.tv_nsec == result.tv_nsec);\n\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"4 hours\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  ASSERT (now.tv_sec + 4 * 60 * 60 == result.tv_sec\n          && now.tv_nsec == result.tv_nsec);\n\n  /* test if timezone is not being ignored for day offset */\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC+400 +24 hours\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  p = \"UTC+400 +1 day\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n\n  /* test if several time zones formats are handled same way */\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC+14:00\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  p = \"UTC+14\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n  p = \"UTC+1400\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC-14:00\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  p = \"UTC-14\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n  p = \"UTC-1400\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC+0:15\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  p = \"UTC+0015\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC-1:30\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  p = \"UTC-130\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n\n\n  /* TZ out of range should cause parse_datetime failure */\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC+25:00\";\n  ASSERT (!parse_datetime (&result, p, &now));\n\n        /* Check for several invalid countable dayshifts */\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC+4:00 +40 yesterday\";\n  ASSERT (!parse_datetime (&result, p, &now));\n  p = \"UTC+4:00 next yesterday\";\n  ASSERT (!parse_datetime (&result, p, &now));\n  p = \"UTC+4:00 tomorrow ago\";\n  ASSERT (!parse_datetime (&result, p, &now));\n  p = \"UTC+4:00 tomorrow hence\";\n  ASSERT (!parse_datetime (&result, p, &now));\n  p = \"UTC+4:00 40 now ago\";\n  ASSERT (!parse_datetime (&result, p, &now));\n  p = \"UTC+4:00 last tomorrow\";\n  ASSERT (!parse_datetime (&result, p, &now));\n  p = \"UTC+4:00 -4 today\";\n  ASSERT (!parse_datetime (&result, p, &now));\n\n  /* And check correct usage of dayshifts */\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC+400 tomorrow\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  p = \"UTC+400 +1 day\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n  p = \"UTC+400 1 day hence\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC+400 yesterday\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  p = \"UTC+400 1 day ago\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC+400 now\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  p = \"UTC+400 +0 minutes\"; /* silly, but simple \"UTC+400\" is different*/\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n\n  /* Check that some \"next Monday\", \"last Wednesday\", etc. are correct.  */\n  setenv (\"TZ\", \"UTC0\", 1);\n  for (i = 0; day_table[i]; i++)\n    {\n      unsigned int thur2 = 7 * 24 * 3600; /* 2nd thursday */\n      char tmp[32];\n      sprintf (tmp, \"NEXT %s\", day_table[i]);\n      now.tv_sec = thur2 + 4711;\n      now.tv_nsec = 1267;\n      ASSERT (parse_datetime (&result, tmp, &now));\n      LOG (tmp, now, result);\n      ASSERT (result.tv_nsec == 0);\n      ASSERT (result.tv_sec == thur2 + (i == 4 ? 7 : (i + 3) % 7) * 24 * 3600);\n\n      sprintf (tmp, \"LAST %s\", day_table[i]);\n      now.tv_sec = thur2 + 4711;\n      now.tv_nsec = 1267;\n      ASSERT (parse_datetime (&result, tmp, &now));\n      LOG (tmp, now, result);\n      ASSERT (result.tv_nsec == 0);\n      ASSERT (result.tv_sec == thur2 + ((i + 3) % 7 - 7) * 24 * 3600);\n    }\n\n  p = \"THURSDAY UTC+00\";  /* The epoch was on Thursday.  */\n  now.tv_sec = 0;\n  now.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  ASSERT (result.tv_sec == now.tv_sec\n          && result.tv_nsec == now.tv_nsec);\n\n  p = \"FRIDAY UTC+00\";\n  now.tv_sec = 0;\n  now.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  ASSERT (result.tv_sec == 24 * 3600\n          && result.tv_nsec == now.tv_nsec);\n\n  /* Exercise a sign-extension bug.  Before July 2012, an input\n     starting with a high-bit-set byte would be treated like \"0\".  */\n  ASSERT ( ! parse_datetime (&result, \"\\xb0\", &now));\n\n  /* Exercise TZ=\"\" parsing code.  */\n  /* These two would infloop or segfault before Feb 2014.  */\n  ASSERT ( ! parse_datetime (&result, \"TZ=\\\"\\\"\\\"\", &now));\n  ASSERT ( ! parse_datetime (&result, \"TZ=\\\"\\\" \\\"\", &now));\n  /* Exercise invalid patterns.  */\n  ASSERT ( ! parse_datetime (&result, \"TZ=\\\"\", &now));\n  ASSERT ( ! parse_datetime (&result, \"TZ=\\\"\\\\\\\"\", &now));\n  ASSERT ( ! parse_datetime (&result, \"TZ=\\\"\\\\n\", &now));\n  ASSERT ( ! parse_datetime (&result, \"TZ=\\\"\\\\n\\\"\", &now));\n  /* Exercise valid patterns.  */\n  ASSERT (   parse_datetime (&result, \"TZ=\\\"\\\"\", &now));\n  ASSERT (   parse_datetime (&result, \"TZ=\\\"\\\" \", &now));\n  ASSERT (   parse_datetime (&result, \" TZ=\\\"\\\"\", &now));\n   ASSERT (   parse_datetime (&result, \"TZ=\\\"\\\\\\\\\\\"\", &now));\n   ASSERT (   parse_datetime (&result, \"TZ=\\\"\\\\\\\"\\\"\", &now));\n \n  /* Outlandishly-long time zone abbreviations should not cause problems.  */\n  {\n    static char const bufprefix[] = \"TZ=\\\"\";\n    enum { tzname_len = 2000 };\n    static char const bufsuffix[] = \"0\\\" 1970-01-01 01:02:03.123456789\";\n    enum { bufsize = sizeof bufprefix - 1 + tzname_len + sizeof bufsuffix };\n    char buf[bufsize];\n    memcpy (buf, bufprefix, sizeof bufprefix - 1);\n    memset (buf + sizeof bufprefix - 1, 'X', tzname_len);\n    strcpy (buf + bufsize - sizeof bufsuffix, bufsuffix);\n    ASSERT (parse_datetime (&result, buf, &now));\n    LOG (buf, now, result);\n    ASSERT (result.tv_sec == 1 * 60 * 60 + 2 * 60 + 3\n            && result.tv_nsec == 123456789);\n  }\n\n   return 0;\n }\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 27,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2018-9988",
    "code_before_change": "static int ssl_parse_server_key_exchange( mbedtls_ssl_context *ssl )\n{\n    int ret;\n    const mbedtls_ssl_ciphersuite_t *ciphersuite_info =\n        ssl->transform_negotiate->ciphersuite_info;\n    unsigned char *p = NULL, *end = NULL;\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=> parse server key exchange\" ) );\n\n#if defined(MBEDTLS_KEY_EXCHANGE_RSA_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= skip parse server key exchange\" ) );\n        ssl->state++;\n        return( 0 );\n    }\n    ((void) p);\n    ((void) end);\n#endif\n\n#if defined(MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED) || \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDH_RSA ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA )\n    {\n        if( ( ret = ssl_get_ecdh_params_from_cert( ssl ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"ssl_get_ecdh_params_from_cert\", ret );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );\n            return( ret );\n        }\n\n        MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= skip parse server key exchange\" ) );\n        ssl->state++;\n        return( 0 );\n    }\n    ((void) p);\n    ((void) end);\n#endif /* MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED ||\n          MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED */\n\n    if( ( ret = mbedtls_ssl_read_record( ssl ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_read_record\", ret );\n        return( ret );\n    }\n\n    if( ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_UNEXPECTED_MESSAGE );\n        return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );\n    }\n\n    /*\n     * ServerKeyExchange may be skipped with PSK and RSA-PSK when the server\n     * doesn't use a psk_identity_hint\n     */\n    if( ssl->in_msg[0] != MBEDTLS_SSL_HS_SERVER_KEY_EXCHANGE )\n    {\n        if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||\n            ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK )\n        {\n            /* Current message is probably either\n             * CertificateRequest or ServerHelloDone */\n            ssl->keep_current_message = 1;\n            goto exit;\n        }\n\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"server key exchange message must \"\n                                    \"not be skipped\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_UNEXPECTED_MESSAGE );\n\n        return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );\n    }\n\n    p   = ssl->in_msg + mbedtls_ssl_hs_hdr_len( ssl );\n    end = ssl->in_msg + ssl->in_hslen;\n    MBEDTLS_SSL_DEBUG_BUF( 3,   \"server key exchange\", p, end - p );\n\n#if defined(MBEDTLS_KEY_EXCHANGE__SOME__PSK_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK )\n    {\n        if( ssl_parse_server_psk_hint( ssl, &p, end ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\n            return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n        }\n    } /* FALLTROUGH */\n#endif /* MBEDTLS_KEY_EXCHANGE__SOME__PSK_ENABLED */\n\n#if defined(MBEDTLS_KEY_EXCHANGE_PSK_ENABLED) ||                       \\\n    defined(MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK )\n        ; /* nothing more to do */\n    else\n#endif /* MBEDTLS_KEY_EXCHANGE_PSK_ENABLED ||\n          MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED */\n#if defined(MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED) ||                       \\\n    defined(MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_RSA ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK )\n    {\n        if( ssl_parse_server_dh_params( ssl, &p, end ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\n            return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n        }\n    }\n    else\n#endif /* MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED ||\n          MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED */\n#if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED) ||                     \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED) ||                     \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_RSA ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA )\n    {\n        if( ssl_parse_server_ecdh_params( ssl, &p, end ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\n            return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n        }\n    }\n    else\n#endif /* MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED ||\n          MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED ||\n          MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED */\n#if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE )\n    {\n        ret = mbedtls_ecjpake_read_round_two( &ssl->handshake->ecjpake_ctx,\n                                              p, end - p );\n        if( ret != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ecjpake_read_round_two\", ret );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\n            return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n        }\n    }\n    else\n#endif /* MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n        return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n    }\n\n#if defined(MBEDTLS_KEY_EXCHANGE__WITH_SERVER_SIGNATURE__ENABLED)\n    if( mbedtls_ssl_ciphersuite_uses_server_signature( ciphersuite_info ) )\n    {\n        size_t sig_len, hashlen;\n        unsigned char hash[64];\n        mbedtls_md_type_t md_alg = MBEDTLS_MD_NONE;\n        mbedtls_pk_type_t pk_alg = MBEDTLS_PK_NONE;\n        unsigned char *params = ssl->in_msg + mbedtls_ssl_hs_hdr_len( ssl );\n        size_t params_len = p - params;\n\n        /*\n         * Handle the digitally-signed structure\n         */\n#if defined(MBEDTLS_SSL_PROTO_TLS1_2)\n        if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_3 )\n        {\n            if( ssl_parse_signature_algorithm( ssl, &p, end,\n                                               &md_alg, &pk_alg ) != 0 )\n            {\n                MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\n                mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                                MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\n                return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n            }\n\n            if( pk_alg != mbedtls_ssl_get_ciphersuite_sig_pk_alg( ciphersuite_info ) )\n            {\n                MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\n                mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                                MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\n                return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n            }\n        }\n        else\n#endif /* MBEDTLS_SSL_PROTO_TLS1_2 */\n#if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1) || \\\n    defined(MBEDTLS_SSL_PROTO_TLS1_1)\n        if( ssl->minor_ver < MBEDTLS_SSL_MINOR_VERSION_3 )\n        {\n            pk_alg = mbedtls_ssl_get_ciphersuite_sig_pk_alg( ciphersuite_info );\n\n            /* Default hash for ECDSA is SHA-1 */\n            if( pk_alg == MBEDTLS_PK_ECDSA && md_alg == MBEDTLS_MD_NONE )\n                md_alg = MBEDTLS_MD_SHA1;\n        }\n        else\n#endif\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n            return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n        }\n\n         /*\n          * Read signature\n          */\n         sig_len = ( p[0] << 8 ) | p[1];\n         p += 2;\n \n        if( end != p + sig_len )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n            return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n        }\n\n        MBEDTLS_SSL_DEBUG_BUF( 3, \"signature\", p, sig_len );\n\n        /*\n         * Compute the hash that has been signed\n         */\n#if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1) || \\\n    defined(MBEDTLS_SSL_PROTO_TLS1_1)\n        if( md_alg == MBEDTLS_MD_NONE )\n        {\n            hashlen = 36;\n            ret = mbedtls_ssl_get_key_exchange_md_ssl_tls( ssl, hash, params,\n                                                           params_len );\n            if( ret != 0 )\n                return( ret );\n        }\n        else\n#endif /* MBEDTLS_SSL_PROTO_SSL3 || MBEDTLS_SSL_PROTO_TLS1 || \\\n          MBEDTLS_SSL_PROTO_TLS1_1 */\n#if defined(MBEDTLS_SSL_PROTO_TLS1) || defined(MBEDTLS_SSL_PROTO_TLS1_1) || \\\n    defined(MBEDTLS_SSL_PROTO_TLS1_2)\n        if( md_alg != MBEDTLS_MD_NONE )\n        {\n            /* Info from md_alg will be used instead */\n            hashlen = 0;\n            ret = mbedtls_ssl_get_key_exchange_md_tls1_2( ssl, hash, params,\n                                                          params_len, md_alg );\n            if( ret != 0 )\n                return( ret );\n        }\n        else\n#endif /* MBEDTLS_SSL_PROTO_TLS1 || MBEDTLS_SSL_PROTO_TLS1_1 || \\\n          MBEDTLS_SSL_PROTO_TLS1_2 */\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n            return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n        }\n\n        MBEDTLS_SSL_DEBUG_BUF( 3, \"parameters hash\", hash, hashlen != 0 ? hashlen :\n            (unsigned int) ( mbedtls_md_get_size( mbedtls_md_info_from_type( md_alg ) ) ) );\n\n        if( ssl->session_negotiate->peer_cert == NULL )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 2, ( \"certificate required\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );\n            return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );\n        }\n\n        /*\n         * Verify signature\n         */\n        if( ! mbedtls_pk_can_do( &ssl->session_negotiate->peer_cert->pk, pk_alg ) )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );\n            return( MBEDTLS_ERR_SSL_PK_TYPE_MISMATCH );\n        }\n\n        if( ( ret = mbedtls_pk_verify( &ssl->session_negotiate->peer_cert->pk,\n                               md_alg, hash, hashlen, p, sig_len ) ) != 0 )\n        {\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_DECRYPT_ERROR );\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_pk_verify\", ret );\n            return( ret );\n        }\n    }\n#endif /* MBEDTLS_KEY_EXCHANGE__WITH_SERVER_SIGNATURE__ENABLED */\n\nexit:\n    ssl->state++;\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= parse server key exchange\" ) );\n\n    return( 0 );\n}\n",
    "code_after_change": "static int ssl_parse_server_key_exchange( mbedtls_ssl_context *ssl )\n{\n    int ret;\n    const mbedtls_ssl_ciphersuite_t *ciphersuite_info =\n        ssl->transform_negotiate->ciphersuite_info;\n    unsigned char *p = NULL, *end = NULL;\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=> parse server key exchange\" ) );\n\n#if defined(MBEDTLS_KEY_EXCHANGE_RSA_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= skip parse server key exchange\" ) );\n        ssl->state++;\n        return( 0 );\n    }\n    ((void) p);\n    ((void) end);\n#endif\n\n#if defined(MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED) || \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDH_RSA ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA )\n    {\n        if( ( ret = ssl_get_ecdh_params_from_cert( ssl ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"ssl_get_ecdh_params_from_cert\", ret );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );\n            return( ret );\n        }\n\n        MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= skip parse server key exchange\" ) );\n        ssl->state++;\n        return( 0 );\n    }\n    ((void) p);\n    ((void) end);\n#endif /* MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED ||\n          MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED */\n\n    if( ( ret = mbedtls_ssl_read_record( ssl ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_read_record\", ret );\n        return( ret );\n    }\n\n    if( ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_UNEXPECTED_MESSAGE );\n        return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );\n    }\n\n    /*\n     * ServerKeyExchange may be skipped with PSK and RSA-PSK when the server\n     * doesn't use a psk_identity_hint\n     */\n    if( ssl->in_msg[0] != MBEDTLS_SSL_HS_SERVER_KEY_EXCHANGE )\n    {\n        if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||\n            ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK )\n        {\n            /* Current message is probably either\n             * CertificateRequest or ServerHelloDone */\n            ssl->keep_current_message = 1;\n            goto exit;\n        }\n\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"server key exchange message must \"\n                                    \"not be skipped\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_UNEXPECTED_MESSAGE );\n\n        return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );\n    }\n\n    p   = ssl->in_msg + mbedtls_ssl_hs_hdr_len( ssl );\n    end = ssl->in_msg + ssl->in_hslen;\n    MBEDTLS_SSL_DEBUG_BUF( 3,   \"server key exchange\", p, end - p );\n\n#if defined(MBEDTLS_KEY_EXCHANGE__SOME__PSK_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK )\n    {\n        if( ssl_parse_server_psk_hint( ssl, &p, end ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\n            return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n        }\n    } /* FALLTROUGH */\n#endif /* MBEDTLS_KEY_EXCHANGE__SOME__PSK_ENABLED */\n\n#if defined(MBEDTLS_KEY_EXCHANGE_PSK_ENABLED) ||                       \\\n    defined(MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK )\n        ; /* nothing more to do */\n    else\n#endif /* MBEDTLS_KEY_EXCHANGE_PSK_ENABLED ||\n          MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED */\n#if defined(MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED) ||                       \\\n    defined(MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_RSA ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK )\n    {\n        if( ssl_parse_server_dh_params( ssl, &p, end ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\n            return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n        }\n    }\n    else\n#endif /* MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED ||\n          MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED */\n#if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED) ||                     \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED) ||                     \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_RSA ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA )\n    {\n        if( ssl_parse_server_ecdh_params( ssl, &p, end ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\n            return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n        }\n    }\n    else\n#endif /* MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED ||\n          MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED ||\n          MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED */\n#if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE )\n    {\n        ret = mbedtls_ecjpake_read_round_two( &ssl->handshake->ecjpake_ctx,\n                                              p, end - p );\n        if( ret != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ecjpake_read_round_two\", ret );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\n            return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n        }\n    }\n    else\n#endif /* MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n        return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n    }\n\n#if defined(MBEDTLS_KEY_EXCHANGE__WITH_SERVER_SIGNATURE__ENABLED)\n    if( mbedtls_ssl_ciphersuite_uses_server_signature( ciphersuite_info ) )\n    {\n        size_t sig_len, hashlen;\n        unsigned char hash[64];\n        mbedtls_md_type_t md_alg = MBEDTLS_MD_NONE;\n        mbedtls_pk_type_t pk_alg = MBEDTLS_PK_NONE;\n        unsigned char *params = ssl->in_msg + mbedtls_ssl_hs_hdr_len( ssl );\n        size_t params_len = p - params;\n\n        /*\n         * Handle the digitally-signed structure\n         */\n#if defined(MBEDTLS_SSL_PROTO_TLS1_2)\n        if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_3 )\n        {\n            if( ssl_parse_signature_algorithm( ssl, &p, end,\n                                               &md_alg, &pk_alg ) != 0 )\n            {\n                MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\n                mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                                MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\n                return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n            }\n\n            if( pk_alg != mbedtls_ssl_get_ciphersuite_sig_pk_alg( ciphersuite_info ) )\n            {\n                MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\n                mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                                MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\n                return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n            }\n        }\n        else\n#endif /* MBEDTLS_SSL_PROTO_TLS1_2 */\n#if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1) || \\\n    defined(MBEDTLS_SSL_PROTO_TLS1_1)\n        if( ssl->minor_ver < MBEDTLS_SSL_MINOR_VERSION_3 )\n        {\n            pk_alg = mbedtls_ssl_get_ciphersuite_sig_pk_alg( ciphersuite_info );\n\n            /* Default hash for ECDSA is SHA-1 */\n            if( pk_alg == MBEDTLS_PK_ECDSA && md_alg == MBEDTLS_MD_NONE )\n                md_alg = MBEDTLS_MD_SHA1;\n        }\n        else\n#endif\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n            return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n        }\n\n         /*\n          * Read signature\n          */\n\n        if( p > end - 2 )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n            return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n        }\n         sig_len = ( p[0] << 8 ) | p[1];\n         p += 2;\n \n        if( end != p + sig_len )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n            return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n        }\n\n        MBEDTLS_SSL_DEBUG_BUF( 3, \"signature\", p, sig_len );\n\n        /*\n         * Compute the hash that has been signed\n         */\n#if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1) || \\\n    defined(MBEDTLS_SSL_PROTO_TLS1_1)\n        if( md_alg == MBEDTLS_MD_NONE )\n        {\n            hashlen = 36;\n            ret = mbedtls_ssl_get_key_exchange_md_ssl_tls( ssl, hash, params,\n                                                           params_len );\n            if( ret != 0 )\n                return( ret );\n        }\n        else\n#endif /* MBEDTLS_SSL_PROTO_SSL3 || MBEDTLS_SSL_PROTO_TLS1 || \\\n          MBEDTLS_SSL_PROTO_TLS1_1 */\n#if defined(MBEDTLS_SSL_PROTO_TLS1) || defined(MBEDTLS_SSL_PROTO_TLS1_1) || \\\n    defined(MBEDTLS_SSL_PROTO_TLS1_2)\n        if( md_alg != MBEDTLS_MD_NONE )\n        {\n            /* Info from md_alg will be used instead */\n            hashlen = 0;\n            ret = mbedtls_ssl_get_key_exchange_md_tls1_2( ssl, hash, params,\n                                                          params_len, md_alg );\n            if( ret != 0 )\n                return( ret );\n        }\n        else\n#endif /* MBEDTLS_SSL_PROTO_TLS1 || MBEDTLS_SSL_PROTO_TLS1_1 || \\\n          MBEDTLS_SSL_PROTO_TLS1_2 */\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n            return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n        }\n\n        MBEDTLS_SSL_DEBUG_BUF( 3, \"parameters hash\", hash, hashlen != 0 ? hashlen :\n            (unsigned int) ( mbedtls_md_get_size( mbedtls_md_info_from_type( md_alg ) ) ) );\n\n        if( ssl->session_negotiate->peer_cert == NULL )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 2, ( \"certificate required\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );\n            return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );\n        }\n\n        /*\n         * Verify signature\n         */\n        if( ! mbedtls_pk_can_do( &ssl->session_negotiate->peer_cert->pk, pk_alg ) )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );\n            return( MBEDTLS_ERR_SSL_PK_TYPE_MISMATCH );\n        }\n\n        if( ( ret = mbedtls_pk_verify( &ssl->session_negotiate->peer_cert->pk,\n                               md_alg, hash, hashlen, p, sig_len ) ) != 0 )\n        {\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_DECRYPT_ERROR );\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_pk_verify\", ret );\n            return( ret );\n        }\n    }\n#endif /* MBEDTLS_KEY_EXCHANGE__WITH_SERVER_SIGNATURE__ENABLED */\n\nexit:\n    ssl->state++;\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= parse server key exchange\" ) );\n\n    return( 0 );\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 41,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-2506",
    "code_before_change": "status_t DRMSource::read(MediaBuffer **buffer, const ReadOptions *options) {\n Mutex::Autolock autoLock(mDRMLock);\n status_t err;\n if ((err = mOriginalMediaSource->read(buffer, options)) != OK) {\n return err;\n }\n\n size_t len = (*buffer)->range_length();\n\n char *src = (char *)(*buffer)->data() + (*buffer)->range_offset();\n\n DrmBuffer encryptedDrmBuffer(src, len);\n DrmBuffer decryptedDrmBuffer;\n    decryptedDrmBuffer.length = len;\n    decryptedDrmBuffer.data = new char[len];\n DrmBuffer *pDecryptedDrmBuffer = &decryptedDrmBuffer;\n\n if ((err = mDrmManagerClient->decrypt(mDecryptHandle, mTrackId,\n &encryptedDrmBuffer, &pDecryptedDrmBuffer)) != NO_ERROR) {\n\n if (decryptedDrmBuffer.data) {\n delete [] decryptedDrmBuffer.data;\n            decryptedDrmBuffer.data = NULL;\n }\n\n return err;\n }\n    CHECK(pDecryptedDrmBuffer == &decryptedDrmBuffer);\n\n const char *mime;\n    CHECK(getFormat()->findCString(kKeyMIMEType, &mime));\n\n if (!strcasecmp(mime, MEDIA_MIMETYPE_VIDEO_AVC) && !mWantsNALFragments) {\n uint8_t *dstData = (uint8_t*)src;\n size_t srcOffset = 0;\n size_t dstOffset = 0;\n\n        len = decryptedDrmBuffer.length;\n while (srcOffset < len) {\n            CHECK(srcOffset + mNALLengthSize <= len);\n size_t nalLength = 0;\n const uint8_t* data = (const uint8_t*)(&decryptedDrmBuffer.data[srcOffset]);\n\n switch (mNALLengthSize) {\n case 1:\n                    nalLength = *data;\n break;\n case 2:\n                    nalLength = U16_AT(data);\n break;\n case 3:\n                    nalLength = ((size_t)data[0] << 16) | U16_AT(&data[1]);\n break;\n case 4:\n                    nalLength = U32_AT(data);\n break;\n default:\n                    CHECK(!\"Should not be here.\");\n break;\n }\n\n            srcOffset += mNALLengthSize;\n\n size_t end = srcOffset + nalLength;\n if (end > len || end < srcOffset) {\n if (decryptedDrmBuffer.data) {\n delete [] decryptedDrmBuffer.data;\n                    decryptedDrmBuffer.data = NULL;\n }\n\n return ERROR_MALFORMED;\n }\n\n if (nalLength == 0) {\n\n                 continue;\n             }\n \n            CHECK(dstOffset + 4 <= (*buffer)->size());\n \n             dstData[dstOffset++] = 0;\n             dstData[dstOffset++] = 0;\n            dstData[dstOffset++] = 0;\n            dstData[dstOffset++] = 1;\n            memcpy(&dstData[dstOffset], &decryptedDrmBuffer.data[srcOffset], nalLength);\n            srcOffset += nalLength;\n            dstOffset += nalLength;\n }\n\n        CHECK_EQ(srcOffset, len);\n (*buffer)->set_range((*buffer)->range_offset(), dstOffset);\n\n } else {\n        memcpy(src, decryptedDrmBuffer.data, decryptedDrmBuffer.length);\n (*buffer)->set_range((*buffer)->range_offset(), decryptedDrmBuffer.length);\n }\n\n if (decryptedDrmBuffer.data) {\n delete [] decryptedDrmBuffer.data;\n        decryptedDrmBuffer.data = NULL;\n }\n\n return OK;\n}\n",
    "code_after_change": "status_t DRMSource::read(MediaBuffer **buffer, const ReadOptions *options) {\n Mutex::Autolock autoLock(mDRMLock);\n status_t err;\n if ((err = mOriginalMediaSource->read(buffer, options)) != OK) {\n return err;\n }\n\n size_t len = (*buffer)->range_length();\n\n char *src = (char *)(*buffer)->data() + (*buffer)->range_offset();\n\n DrmBuffer encryptedDrmBuffer(src, len);\n DrmBuffer decryptedDrmBuffer;\n    decryptedDrmBuffer.length = len;\n    decryptedDrmBuffer.data = new char[len];\n DrmBuffer *pDecryptedDrmBuffer = &decryptedDrmBuffer;\n\n if ((err = mDrmManagerClient->decrypt(mDecryptHandle, mTrackId,\n &encryptedDrmBuffer, &pDecryptedDrmBuffer)) != NO_ERROR) {\n\n if (decryptedDrmBuffer.data) {\n delete [] decryptedDrmBuffer.data;\n            decryptedDrmBuffer.data = NULL;\n }\n\n return err;\n }\n    CHECK(pDecryptedDrmBuffer == &decryptedDrmBuffer);\n\n const char *mime;\n    CHECK(getFormat()->findCString(kKeyMIMEType, &mime));\n\n if (!strcasecmp(mime, MEDIA_MIMETYPE_VIDEO_AVC) && !mWantsNALFragments) {\n uint8_t *dstData = (uint8_t*)src;\n size_t srcOffset = 0;\n size_t dstOffset = 0;\n\n        len = decryptedDrmBuffer.length;\n while (srcOffset < len) {\n            CHECK(srcOffset + mNALLengthSize <= len);\n size_t nalLength = 0;\n const uint8_t* data = (const uint8_t*)(&decryptedDrmBuffer.data[srcOffset]);\n\n switch (mNALLengthSize) {\n case 1:\n                    nalLength = *data;\n break;\n case 2:\n                    nalLength = U16_AT(data);\n break;\n case 3:\n                    nalLength = ((size_t)data[0] << 16) | U16_AT(&data[1]);\n break;\n case 4:\n                    nalLength = U32_AT(data);\n break;\n default:\n                    CHECK(!\"Should not be here.\");\n break;\n }\n\n            srcOffset += mNALLengthSize;\n\n size_t end = srcOffset + nalLength;\n if (end > len || end < srcOffset) {\n if (decryptedDrmBuffer.data) {\n delete [] decryptedDrmBuffer.data;\n                    decryptedDrmBuffer.data = NULL;\n }\n\n return ERROR_MALFORMED;\n }\n\n if (nalLength == 0) {\n\n                 continue;\n             }\n \n            if (dstOffset > SIZE_MAX - 4 ||\n                dstOffset + 4 > SIZE_MAX - nalLength ||\n                dstOffset + 4 + nalLength > (*buffer)->size()) {\n                (*buffer)->release();\n                (*buffer) = NULL;\n                if (decryptedDrmBuffer.data) {\n                    delete [] decryptedDrmBuffer.data;\n                    decryptedDrmBuffer.data = NULL;\n                }\n                return ERROR_MALFORMED;\n            }\n \n             dstData[dstOffset++] = 0;\n             dstData[dstOffset++] = 0;\n            dstData[dstOffset++] = 0;\n            dstData[dstOffset++] = 1;\n            memcpy(&dstData[dstOffset], &decryptedDrmBuffer.data[srcOffset], nalLength);\n            srcOffset += nalLength;\n            dstOffset += nalLength;\n }\n\n        CHECK_EQ(srcOffset, len);\n (*buffer)->set_range((*buffer)->range_offset(), dstOffset);\n\n } else {\n        memcpy(src, decryptedDrmBuffer.data, decryptedDrmBuffer.length);\n (*buffer)->set_range((*buffer)->range_offset(), decryptedDrmBuffer.length);\n }\n\n if (decryptedDrmBuffer.data) {\n delete [] decryptedDrmBuffer.data;\n        decryptedDrmBuffer.data = NULL;\n }\n\n return OK;\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 42,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-2090",
    "code_before_change": "fgetwln(FILE *stream, size_t *lenp)\n{\n\tstruct filewbuf *fb;\n\twint_t wc;\n\tsize_t wused = 0;\n\n\t/* Try to diminish the possibility of several fgetwln() calls being\n\t * used on different streams, by using a pool of buffers per file. */\n\tfb = &fb_pool[fb_pool_cur];\n\tif (fb->fp != stream && fb->fp != NULL) {\n\t\tfb_pool_cur++;\n\t\tfb_pool_cur %= FILEWBUF_POOL_ITEMS;\n\t\tfb = &fb_pool[fb_pool_cur];\n\t}\n \tfb->fp = stream;\n \n \twhile ((wc = fgetwc(stream)) != WEOF) {\n\t\tif (!fb->len || wused > fb->len) {\n \t\t\twchar_t *wp;\n \n \t\t\tif (fb->len)\n\t\t\t\tfb->len *= 2;\n\t\t\telse\n\t\t\t\tfb->len = FILEWBUF_INIT_LEN;\n\n\t\t\twp = reallocarray(fb->wbuf, fb->len, sizeof(wchar_t));\n\t\t\tif (wp == NULL) {\n\t\t\t\twused = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfb->wbuf = wp;\n\t\t}\n\n\t\tfb->wbuf[wused++] = wc;\n\n\t\tif (wc == L'\\n')\n\t\t\tbreak;\n\t}\n\n\t*lenp = wused;\n\treturn wused ? fb->wbuf : NULL;\n}\n",
    "code_after_change": "fgetwln(FILE *stream, size_t *lenp)\n{\n\tstruct filewbuf *fb;\n\twint_t wc;\n\tsize_t wused = 0;\n\n\t/* Try to diminish the possibility of several fgetwln() calls being\n\t * used on different streams, by using a pool of buffers per file. */\n\tfb = &fb_pool[fb_pool_cur];\n\tif (fb->fp != stream && fb->fp != NULL) {\n\t\tfb_pool_cur++;\n\t\tfb_pool_cur %= FILEWBUF_POOL_ITEMS;\n\t\tfb = &fb_pool[fb_pool_cur];\n\t}\n \tfb->fp = stream;\n \n \twhile ((wc = fgetwc(stream)) != WEOF) {\n\t\tif (!fb->len || wused >= fb->len) {\n \t\t\twchar_t *wp;\n \n \t\t\tif (fb->len)\n\t\t\t\tfb->len *= 2;\n\t\t\telse\n\t\t\t\tfb->len = FILEWBUF_INIT_LEN;\n\n\t\t\twp = reallocarray(fb->wbuf, fb->len, sizeof(wchar_t));\n\t\t\tif (wp == NULL) {\n\t\t\t\twused = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfb->wbuf = wp;\n\t\t}\n\n\t\tfb->wbuf[wused++] = wc;\n\n\t\tif (wc == L'\\n')\n\t\t\tbreak;\n\t}\n\n\t*lenp = wused;\n\treturn wused ? fb->wbuf : NULL;\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 61,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-4303",
    "code_before_change": "send_parameters(struct iperf_test *test)\n{\n    int r = 0;\n    cJSON *j;\n\n    j = cJSON_CreateObject();\n    if (j == NULL) {\n\ti_errno = IESENDPARAMS;\n\tr = -1;\n    } else {\n\tif (test->protocol->id == Ptcp)\n \t    cJSON_AddTrueToObject(j, \"tcp\");\n \telse if (test->protocol->id == Pudp)\n \t    cJSON_AddTrueToObject(j, \"udp\");\n\tcJSON_AddIntToObject(j, \"omit\", test->omit);\n \tif (test->server_affinity != -1)\n\t    cJSON_AddIntToObject(j, \"server_affinity\", test->server_affinity);\n \tif (test->duration)\n\t    cJSON_AddIntToObject(j, \"time\", test->duration);\n \tif (test->settings->bytes)\n\t    cJSON_AddIntToObject(j, \"num\", test->settings->bytes);\n \tif (test->settings->blocks)\n\t    cJSON_AddIntToObject(j, \"blockcount\", test->settings->blocks);\n \tif (test->settings->mss)\n\t    cJSON_AddIntToObject(j, \"MSS\", test->settings->mss);\n \tif (test->no_delay)\n \t    cJSON_AddTrueToObject(j, \"nodelay\");\n\tcJSON_AddIntToObject(j, \"parallel\", test->num_streams);\n \tif (test->reverse)\n \t    cJSON_AddTrueToObject(j, \"reverse\");\n \tif (test->settings->socket_bufsize)\n\t    cJSON_AddIntToObject(j, \"window\", test->settings->socket_bufsize);\n \tif (test->settings->blksize)\n\t    cJSON_AddIntToObject(j, \"len\", test->settings->blksize);\n \tif (test->settings->rate)\n\t    cJSON_AddIntToObject(j, \"bandwidth\", test->settings->rate);\n \tif (test->settings->burst)\n\t    cJSON_AddIntToObject(j, \"burst\", test->settings->burst);\n \tif (test->settings->tos)\n\t    cJSON_AddIntToObject(j, \"TOS\", test->settings->tos);\n \tif (test->settings->flowlabel)\n\t    cJSON_AddIntToObject(j, \"flowlabel\", test->settings->flowlabel);\n \tif (test->title)\n \t    cJSON_AddStringToObject(j, \"title\", test->title);\n \tif (test->congestion)\n \t    cJSON_AddStringToObject(j, \"congestion\", test->congestion);\n \tif (test->get_server_output)\n \t    cJSON_AddIntToObject(j, \"get_server_output\", iperf_get_test_get_server_output(test));\n \n \tif (test->debug) {\n \t    printf(\"send_parameters:\\n%s\\n\", cJSON_Print(j));\n\t}\n\n\tif (JSON_write(test->ctrl_sck, j) < 0) {\n\t    i_errno = IESENDPARAMS;\n\t    r = -1;\n\t}\n\tcJSON_Delete(j);\n    }\n    return r;\n}\n",
    "code_after_change": "send_parameters(struct iperf_test *test)\n{\n    int r = 0;\n    cJSON *j;\n\n    j = cJSON_CreateObject();\n    if (j == NULL) {\n\ti_errno = IESENDPARAMS;\n\tr = -1;\n    } else {\n\tif (test->protocol->id == Ptcp)\n \t    cJSON_AddTrueToObject(j, \"tcp\");\n \telse if (test->protocol->id == Pudp)\n \t    cJSON_AddTrueToObject(j, \"udp\");\n\tcJSON_AddNumberToObject(j, \"omit\", test->omit);\n \tif (test->server_affinity != -1)\n\t    cJSON_AddNumberToObject(j, \"server_affinity\", test->server_affinity);\n \tif (test->duration)\n\t    cJSON_AddNumberToObject(j, \"time\", test->duration);\n \tif (test->settings->bytes)\n\t    cJSON_AddNumberToObject(j, \"num\", test->settings->bytes);\n \tif (test->settings->blocks)\n\t    cJSON_AddNumberToObject(j, \"blockcount\", test->settings->blocks);\n \tif (test->settings->mss)\n\t    cJSON_AddNumberToObject(j, \"MSS\", test->settings->mss);\n \tif (test->no_delay)\n \t    cJSON_AddTrueToObject(j, \"nodelay\");\n\tcJSON_AddNumberToObject(j, \"parallel\", test->num_streams);\n \tif (test->reverse)\n \t    cJSON_AddTrueToObject(j, \"reverse\");\n \tif (test->settings->socket_bufsize)\n\t    cJSON_AddNumberToObject(j, \"window\", test->settings->socket_bufsize);\n \tif (test->settings->blksize)\n\t    cJSON_AddNumberToObject(j, \"len\", test->settings->blksize);\n \tif (test->settings->rate)\n\t    cJSON_AddNumberToObject(j, \"bandwidth\", test->settings->rate);\n \tif (test->settings->burst)\n\t    cJSON_AddNumberToObject(j, \"burst\", test->settings->burst);\n \tif (test->settings->tos)\n\t    cJSON_AddNumberToObject(j, \"TOS\", test->settings->tos);\n \tif (test->settings->flowlabel)\n\t    cJSON_AddNumberToObject(j, \"flowlabel\", test->settings->flowlabel);\n \tif (test->title)\n \t    cJSON_AddStringToObject(j, \"title\", test->title);\n \tif (test->congestion)\n \t    cJSON_AddStringToObject(j, \"congestion\", test->congestion);\n \tif (test->get_server_output)\n<<<<<<< HEAD\n \t    cJSON_AddIntToObject(j, \"get_server_output\", iperf_get_test_get_server_output(test));\n=======\n\t    cJSON_AddNumberToObject(j, \"get_server_output\", iperf_get_test_get_server_output(test));\n\tif (test->udp_counters_64bit)\n\t    cJSON_AddNumberToObject(j, \"udp_counters_64bit\", iperf_get_test_udp_counters_64bit(test));\n\tif (test->no_fq_socket_pacing)\n\t    cJSON_AddNumberToObject(j, \"no_fq_socket_pacing\", iperf_get_no_fq_socket_pacing(test));\n\n\tcJSON_AddStringToObject(j, \"client_version\", IPERF_VERSION);\n>>>>>>> ed94082... Fix a buffer overflow / heap corruption issue that could occur if a\n \n \tif (test->debug) {\n \t    printf(\"send_parameters:\\n%s\\n\", cJSON_Print(j));\n\t}\n\n\tif (JSON_write(test->ctrl_sck, j) < 0) {\n\t    i_errno = IESENDPARAMS;\n\t    r = -1;\n\t}\n\tcJSON_Delete(j);\n    }\n    return r;\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 71,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2011-3963",
    "code_before_change": "void BluetoothOptionsHandler::DeviceNotification(\n    const DictionaryValue& device) {\n   web_ui_->CallJavascriptFunction(\n      \"options.SystemOptions.addBluetoothDevice\", device);\n }\n",
    "code_after_change": "void BluetoothOptionsHandler::DeviceNotification(\nvoid BluetoothOptionsHandler::SendDeviceNotification(\n    chromeos::BluetoothDevice* device,\n    base::DictionaryValue* params) {\n  // Retrieve properties of the bluetooth device.  The properties names are\n  // in title case.  Convert to camel case in accordance with our Javascript\n  // naming convention.\n  const DictionaryValue& properties = device->AsDictionary();\n  base::DictionaryValue js_properties;\n  for (DictionaryValue::key_iterator it = properties.begin_keys();\n      it != properties.end_keys(); ++it) {\n    base::Value* child = NULL;\n    properties.GetWithoutPathExpansion(*it, &child);\n    if (child) {\n      std::string js_key = *it;\n      js_key[0] = tolower(js_key[0]);\n      js_properties.SetWithoutPathExpansion(js_key, child->DeepCopy());\n    }\n  }\n  if (params) {\n    js_properties.MergeDictionary(params);\n  }\n   web_ui_->CallJavascriptFunction(\n      \"options.SystemOptions.addBluetoothDevice\",\n      js_properties);\n }\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 74,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2018-14015",
    "code_before_change": "static const ut8 *r_bin_dwarf_parse_comp_unit(Sdb *s, const ut8 *obuf,\n\t\tRBinDwarfCompUnit *cu, const RBinDwarfDebugAbbrev *da,\n\t\tsize_t offset, const ut8 *debug_str, size_t debug_str_len) {\n\tconst ut8 *buf = obuf, *buf_end = obuf + (cu->hdr.length - 7);\n\tut64 abbr_code;\n\tsize_t i;\n\t\n\tif (cu->hdr.length > debug_str_len) {\n\t\treturn NULL;\n\t}\n\twhile (buf && buf < buf_end && buf >= obuf) {\n\t\tif (cu->length && cu->capacity == cu->length) {\n\t\t\tr_bin_dwarf_expand_cu (cu);\n\t\t}\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &abbr_code);\n\t\tif (abbr_code > da->length || !buf) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tr_bin_dwarf_init_die (&cu->dies[cu->length]);\n\t\tif (!abbr_code) {\n\t\t\tcu->dies[cu->length].abbrev_code = 0;\n\t\t\tcu->length++;\n\t\t\tbuf++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcu->dies[cu->length].abbrev_code = abbr_code;\n\t\tcu->dies[cu->length].tag = da->decls[abbr_code - 1].tag;\n\t\tabbr_code += offset;\n\n\t\tif (da->capacity < abbr_code) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tfor (i = 0; i < da->decls[abbr_code - 1].length; i++) {\n\t\t\tif (cu->dies[cu->length].length == cu->dies[cu->length].capacity) {\n\t\t\t\tr_bin_dwarf_expand_die (&cu->dies[cu->length]);\n\t\t\t}\n\t\t\tif (i >= cu->dies[cu->length].capacity || i >= da->decls[abbr_code - 1].capacity) {\n\t\t\t\teprintf (\"Warning: malformed dwarf attribute capacity doesn't match length\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemset (&cu->dies[cu->length].attr_values[i], 0, sizeof (cu->dies[cu->length].attr_values[i]));\n\t\t\tbuf = r_bin_dwarf_parse_attr_value (buf, buf_end - buf,\n\t\t\t\t\t&da->decls[abbr_code - 1].specs[i],\n\t\t\t\t\t&cu->dies[cu->length].attr_values[i],\n \t\t\t\t\t&cu->hdr, debug_str, debug_str_len);\n \t\t\tif (cu->dies[cu->length].attr_values[i].name == DW_AT_comp_dir) {\n \t\t\t\tconst char *name = cu->dies[cu->length].attr_values[i].encoding.str_struct.string;\n\t\t\t\tsdb_set (s, \"DW_AT_comp_dir\", name, 0);\n \t\t\t}\n \t\t\tcu->dies[cu->length].length++;\n \t\t}\n\t\tcu->length++;\n\t}\n\treturn buf;\n}\n",
    "code_after_change": "static const ut8 *r_bin_dwarf_parse_comp_unit(Sdb *s, const ut8 *obuf,\n\t\tRBinDwarfCompUnit *cu, const RBinDwarfDebugAbbrev *da,\n\t\tsize_t offset, const ut8 *debug_str, size_t debug_str_len) {\n\tconst ut8 *buf = obuf, *buf_end = obuf + (cu->hdr.length - 7);\n\tut64 abbr_code;\n\tsize_t i;\n\t\n\tif (cu->hdr.length > debug_str_len) {\n\t\treturn NULL;\n\t}\n\twhile (buf && buf < buf_end && buf >= obuf) {\n\t\tif (cu->length && cu->capacity == cu->length) {\n\t\t\tr_bin_dwarf_expand_cu (cu);\n\t\t}\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &abbr_code);\n\t\tif (abbr_code > da->length || !buf) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tr_bin_dwarf_init_die (&cu->dies[cu->length]);\n\t\tif (!abbr_code) {\n\t\t\tcu->dies[cu->length].abbrev_code = 0;\n\t\t\tcu->length++;\n\t\t\tbuf++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcu->dies[cu->length].abbrev_code = abbr_code;\n\t\tcu->dies[cu->length].tag = da->decls[abbr_code - 1].tag;\n\t\tabbr_code += offset;\n\n\t\tif (da->capacity < abbr_code) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tfor (i = 0; i < da->decls[abbr_code - 1].length; i++) {\n\t\t\tif (cu->dies[cu->length].length == cu->dies[cu->length].capacity) {\n\t\t\t\tr_bin_dwarf_expand_die (&cu->dies[cu->length]);\n\t\t\t}\n\t\t\tif (i >= cu->dies[cu->length].capacity || i >= da->decls[abbr_code - 1].capacity) {\n\t\t\t\teprintf (\"Warning: malformed dwarf attribute capacity doesn't match length\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemset (&cu->dies[cu->length].attr_values[i], 0, sizeof (cu->dies[cu->length].attr_values[i]));\n\t\t\tbuf = r_bin_dwarf_parse_attr_value (buf, buf_end - buf,\n\t\t\t\t\t&da->decls[abbr_code - 1].specs[i],\n\t\t\t\t\t&cu->dies[cu->length].attr_values[i],\n \t\t\t\t\t&cu->hdr, debug_str, debug_str_len);\n \t\t\tif (cu->dies[cu->length].attr_values[i].name == DW_AT_comp_dir) {\n \t\t\t\tconst char *name = cu->dies[cu->length].attr_values[i].encoding.str_struct.string;\n\t\t\t\tif (name > 1024) { // solve some null derefs\n\t\t\t\t\tsdb_set (s, \"DW_AT_comp_dir\", name, 0);\n\t\t\t\t} else {\n\t\t\t\t\teprintf (\"Invalid string pointer at %p\\n\", name);\n\t\t\t\t}\n \t\t\t}\n \t\t\tcu->dies[cu->length].length++;\n \t\t}\n\t\tcu->length++;\n\t}\n\treturn buf;\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 75,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2013-2877",
    "code_before_change": "xmlParseElementChildrenContentDeclPriv(xmlParserCtxtPtr ctxt, int inputchk,\n                                       int depth) {\n    xmlElementContentPtr ret = NULL, cur = NULL, last = NULL, op = NULL;\n    const xmlChar *elem;\n    xmlChar type = 0;\n\n    if (((depth > 128) && ((ctxt->options & XML_PARSE_HUGE) == 0)) ||\n        (depth >  2048)) {\n        xmlFatalErrMsgInt(ctxt, XML_ERR_ELEMCONTENT_NOT_FINISHED,\n\"xmlParseElementChildrenContentDecl : depth %d too deep, use XML_PARSE_HUGE\\n\",\n                          depth);\n\treturn(NULL);\n    }\n    SKIP_BLANKS;\n    GROW;\n    if (RAW == '(') {\n\tint inputid = ctxt->input->id;\n\n        /* Recurse on first child */\n\tNEXT;\n\tSKIP_BLANKS;\n        cur = ret = xmlParseElementChildrenContentDeclPriv(ctxt, inputid,\n                                                           depth + 1);\n\tSKIP_BLANKS;\n\tGROW;\n    } else {\n\telem = xmlParseName(ctxt);\n\tif (elem == NULL) {\n\t    xmlFatalErr(ctxt, XML_ERR_ELEMCONTENT_NOT_STARTED, NULL);\n\t    return(NULL);\n\t}\n        cur = ret = xmlNewDocElementContent(ctxt->myDoc, elem, XML_ELEMENT_CONTENT_ELEMENT);\n\tif (cur == NULL) {\n\t    xmlErrMemory(ctxt, NULL);\n\t    return(NULL);\n\t}\n\tGROW;\n\tif (RAW == '?') {\n\t    cur->ocur = XML_ELEMENT_CONTENT_OPT;\n\t    NEXT;\n\t} else if (RAW == '*') {\n\t    cur->ocur = XML_ELEMENT_CONTENT_MULT;\n\t    NEXT;\n\t} else if (RAW == '+') {\n\t    cur->ocur = XML_ELEMENT_CONTENT_PLUS;\n\t    NEXT;\n\t} else {\n\t    cur->ocur = XML_ELEMENT_CONTENT_ONCE;\n\t}\n\tGROW;\n     }\n     SKIP_BLANKS;\n     SHRINK;\n    while (RAW != ')') {\n         /*\n \t * Each loop we parse one separator and one element.\n \t */\n        if (RAW == ',') {\n\t    if (type == 0) type = CUR;\n\n\t    /*\n\t     * Detect \"Name | Name , Name\" error\n\t     */\n\t    else if (type != CUR) {\n\t\txmlFatalErrMsgInt(ctxt, XML_ERR_SEPARATOR_REQUIRED,\n\t\t    \"xmlParseElementChildrenContentDecl : '%c' expected\\n\",\n\t\t                  type);\n\t\tif ((last != NULL) && (last != ret))\n\t\t    xmlFreeDocElementContent(ctxt->myDoc, last);\n\t\tif (ret != NULL)\n\t\t    xmlFreeDocElementContent(ctxt->myDoc, ret);\n\t\treturn(NULL);\n\t    }\n\t    NEXT;\n\n\t    op = xmlNewDocElementContent(ctxt->myDoc, NULL, XML_ELEMENT_CONTENT_SEQ);\n\t    if (op == NULL) {\n\t\tif ((last != NULL) && (last != ret))\n\t\t    xmlFreeDocElementContent(ctxt->myDoc, last);\n\t        xmlFreeDocElementContent(ctxt->myDoc, ret);\n\t\treturn(NULL);\n\t    }\n\t    if (last == NULL) {\n\t\top->c1 = ret;\n\t\tif (ret != NULL)\n\t\t    ret->parent = op;\n\t\tret = cur = op;\n\t    } else {\n\t        cur->c2 = op;\n\t\tif (op != NULL)\n\t\t    op->parent = cur;\n\t\top->c1 = last;\n\t\tif (last != NULL)\n\t\t    last->parent = op;\n\t\tcur =op;\n\t\tlast = NULL;\n\t    }\n\t} else if (RAW == '|') {\n\t    if (type == 0) type = CUR;\n\n\t    /*\n\t     * Detect \"Name , Name | Name\" error\n\t     */\n\t    else if (type != CUR) {\n\t\txmlFatalErrMsgInt(ctxt, XML_ERR_SEPARATOR_REQUIRED,\n\t\t    \"xmlParseElementChildrenContentDecl : '%c' expected\\n\",\n\t\t\t\t  type);\n\t\tif ((last != NULL) && (last != ret))\n\t\t    xmlFreeDocElementContent(ctxt->myDoc, last);\n\t\tif (ret != NULL)\n\t\t    xmlFreeDocElementContent(ctxt->myDoc, ret);\n\t\treturn(NULL);\n\t    }\n\t    NEXT;\n\n\t    op = xmlNewDocElementContent(ctxt->myDoc, NULL, XML_ELEMENT_CONTENT_OR);\n\t    if (op == NULL) {\n\t\tif ((last != NULL) && (last != ret))\n\t\t    xmlFreeDocElementContent(ctxt->myDoc, last);\n\t\tif (ret != NULL)\n\t\t    xmlFreeDocElementContent(ctxt->myDoc, ret);\n\t\treturn(NULL);\n\t    }\n\t    if (last == NULL) {\n\t\top->c1 = ret;\n\t\tif (ret != NULL)\n\t\t    ret->parent = op;\n\t\tret = cur = op;\n\t    } else {\n\t        cur->c2 = op;\n\t\tif (op != NULL)\n\t\t    op->parent = cur;\n\t\top->c1 = last;\n\t\tif (last != NULL)\n\t\t    last->parent = op;\n\t\tcur =op;\n\t\tlast = NULL;\n\t    }\n\t} else {\n\t    xmlFatalErr(ctxt, XML_ERR_ELEMCONTENT_NOT_FINISHED, NULL);\n\t    if ((last != NULL) && (last != ret))\n\t        xmlFreeDocElementContent(ctxt->myDoc, last);\n\t    if (ret != NULL)\n\t\txmlFreeDocElementContent(ctxt->myDoc, ret);\n\t    return(NULL);\n\t}\n\tGROW;\n\tSKIP_BLANKS;\n\tGROW;\n\tif (RAW == '(') {\n\t    int inputid = ctxt->input->id;\n\t    /* Recurse on second child */\n\t    NEXT;\n\t    SKIP_BLANKS;\n\t    last = xmlParseElementChildrenContentDeclPriv(ctxt, inputid,\n                                                          depth + 1);\n\t    SKIP_BLANKS;\n\t} else {\n\t    elem = xmlParseName(ctxt);\n\t    if (elem == NULL) {\n\t\txmlFatalErr(ctxt, XML_ERR_ELEMCONTENT_NOT_STARTED, NULL);\n\t\tif (ret != NULL)\n\t\t    xmlFreeDocElementContent(ctxt->myDoc, ret);\n\t\treturn(NULL);\n\t    }\n\t    last = xmlNewDocElementContent(ctxt->myDoc, elem, XML_ELEMENT_CONTENT_ELEMENT);\n\t    if (last == NULL) {\n\t\tif (ret != NULL)\n\t\t    xmlFreeDocElementContent(ctxt->myDoc, ret);\n\t\treturn(NULL);\n\t    }\n\t    if (RAW == '?') {\n\t\tlast->ocur = XML_ELEMENT_CONTENT_OPT;\n\t\tNEXT;\n\t    } else if (RAW == '*') {\n\t\tlast->ocur = XML_ELEMENT_CONTENT_MULT;\n\t\tNEXT;\n\t    } else if (RAW == '+') {\n\t\tlast->ocur = XML_ELEMENT_CONTENT_PLUS;\n\t\tNEXT;\n\t    } else {\n\t\tlast->ocur = XML_ELEMENT_CONTENT_ONCE;\n\t    }\n\t}\n\tSKIP_BLANKS;\n\tGROW;\n    }\n    if ((cur != NULL) && (last != NULL)) {\n        cur->c2 = last;\n\tif (last != NULL)\n\t    last->parent = cur;\n    }\n    if ((ctxt->validate) && (ctxt->input->id != inputchk)) {\n\txmlValidityError(ctxt, XML_ERR_ENTITY_BOUNDARY,\n\"Element content declaration doesn't start and stop in the same entity\\n\",\n\t\t\t NULL, NULL);\n    }\n    NEXT;\n    if (RAW == '?') {\n\tif (ret != NULL) {\n\t    if ((ret->ocur == XML_ELEMENT_CONTENT_PLUS) ||\n\t        (ret->ocur == XML_ELEMENT_CONTENT_MULT))\n\t        ret->ocur = XML_ELEMENT_CONTENT_MULT;\n\t    else\n\t        ret->ocur = XML_ELEMENT_CONTENT_OPT;\n\t}\n\tNEXT;\n    } else if (RAW == '*') {\n\tif (ret != NULL) {\n\t    ret->ocur = XML_ELEMENT_CONTENT_MULT;\n\t    cur = ret;\n\t    /*\n\t     * Some normalization:\n\t     * (a | b* | c?)* == (a | b | c)*\n\t     */\n\t    while ((cur != NULL) && (cur->type == XML_ELEMENT_CONTENT_OR)) {\n\t\tif ((cur->c1 != NULL) &&\n\t            ((cur->c1->ocur == XML_ELEMENT_CONTENT_OPT) ||\n\t\t     (cur->c1->ocur == XML_ELEMENT_CONTENT_MULT)))\n\t\t    cur->c1->ocur = XML_ELEMENT_CONTENT_ONCE;\n\t\tif ((cur->c2 != NULL) &&\n\t            ((cur->c2->ocur == XML_ELEMENT_CONTENT_OPT) ||\n\t\t     (cur->c2->ocur == XML_ELEMENT_CONTENT_MULT)))\n\t\t    cur->c2->ocur = XML_ELEMENT_CONTENT_ONCE;\n\t\tcur = cur->c2;\n\t    }\n\t}\n\tNEXT;\n    } else if (RAW == '+') {\n\tif (ret != NULL) {\n\t    int found = 0;\n\n\t    if ((ret->ocur == XML_ELEMENT_CONTENT_OPT) ||\n\t        (ret->ocur == XML_ELEMENT_CONTENT_MULT))\n\t        ret->ocur = XML_ELEMENT_CONTENT_MULT;\n\t    else\n\t        ret->ocur = XML_ELEMENT_CONTENT_PLUS;\n\t    /*\n\t     * Some normalization:\n\t     * (a | b*)+ == (a | b)*\n\t     * (a | b?)+ == (a | b)*\n\t     */\n\t    while ((cur != NULL) && (cur->type == XML_ELEMENT_CONTENT_OR)) {\n\t\tif ((cur->c1 != NULL) &&\n\t            ((cur->c1->ocur == XML_ELEMENT_CONTENT_OPT) ||\n\t\t     (cur->c1->ocur == XML_ELEMENT_CONTENT_MULT))) {\n\t\t    cur->c1->ocur = XML_ELEMENT_CONTENT_ONCE;\n\t\t    found = 1;\n\t\t}\n\t\tif ((cur->c2 != NULL) &&\n\t            ((cur->c2->ocur == XML_ELEMENT_CONTENT_OPT) ||\n\t\t     (cur->c2->ocur == XML_ELEMENT_CONTENT_MULT))) {\n\t\t    cur->c2->ocur = XML_ELEMENT_CONTENT_ONCE;\n\t\t    found = 1;\n\t\t}\n\t\tcur = cur->c2;\n\t    }\n\t    if (found)\n\t\tret->ocur = XML_ELEMENT_CONTENT_MULT;\n\t}\n\tNEXT;\n    }\n    return(ret);\n}\n",
    "code_after_change": "xmlParseElementChildrenContentDeclPriv(xmlParserCtxtPtr ctxt, int inputchk,\n                                       int depth) {\n    xmlElementContentPtr ret = NULL, cur = NULL, last = NULL, op = NULL;\n    const xmlChar *elem;\n    xmlChar type = 0;\n\n    if (((depth > 128) && ((ctxt->options & XML_PARSE_HUGE) == 0)) ||\n        (depth >  2048)) {\n        xmlFatalErrMsgInt(ctxt, XML_ERR_ELEMCONTENT_NOT_FINISHED,\n\"xmlParseElementChildrenContentDecl : depth %d too deep, use XML_PARSE_HUGE\\n\",\n                          depth);\n\treturn(NULL);\n    }\n    SKIP_BLANKS;\n    GROW;\n    if (RAW == '(') {\n\tint inputid = ctxt->input->id;\n\n        /* Recurse on first child */\n\tNEXT;\n\tSKIP_BLANKS;\n        cur = ret = xmlParseElementChildrenContentDeclPriv(ctxt, inputid,\n                                                           depth + 1);\n\tSKIP_BLANKS;\n\tGROW;\n    } else {\n\telem = xmlParseName(ctxt);\n\tif (elem == NULL) {\n\t    xmlFatalErr(ctxt, XML_ERR_ELEMCONTENT_NOT_STARTED, NULL);\n\t    return(NULL);\n\t}\n        cur = ret = xmlNewDocElementContent(ctxt->myDoc, elem, XML_ELEMENT_CONTENT_ELEMENT);\n\tif (cur == NULL) {\n\t    xmlErrMemory(ctxt, NULL);\n\t    return(NULL);\n\t}\n\tGROW;\n\tif (RAW == '?') {\n\t    cur->ocur = XML_ELEMENT_CONTENT_OPT;\n\t    NEXT;\n\t} else if (RAW == '*') {\n\t    cur->ocur = XML_ELEMENT_CONTENT_MULT;\n\t    NEXT;\n\t} else if (RAW == '+') {\n\t    cur->ocur = XML_ELEMENT_CONTENT_PLUS;\n\t    NEXT;\n\t} else {\n\t    cur->ocur = XML_ELEMENT_CONTENT_ONCE;\n\t}\n\tGROW;\n     }\n     SKIP_BLANKS;\n     SHRINK;\n    while ((RAW != ')') && (ctxt->instate != XML_PARSER_EOF)) {\n         /*\n \t * Each loop we parse one separator and one element.\n \t */\n        if (RAW == ',') {\n\t    if (type == 0) type = CUR;\n\n\t    /*\n\t     * Detect \"Name | Name , Name\" error\n\t     */\n\t    else if (type != CUR) {\n\t\txmlFatalErrMsgInt(ctxt, XML_ERR_SEPARATOR_REQUIRED,\n\t\t    \"xmlParseElementChildrenContentDecl : '%c' expected\\n\",\n\t\t                  type);\n\t\tif ((last != NULL) && (last != ret))\n\t\t    xmlFreeDocElementContent(ctxt->myDoc, last);\n\t\tif (ret != NULL)\n\t\t    xmlFreeDocElementContent(ctxt->myDoc, ret);\n\t\treturn(NULL);\n\t    }\n\t    NEXT;\n\n\t    op = xmlNewDocElementContent(ctxt->myDoc, NULL, XML_ELEMENT_CONTENT_SEQ);\n\t    if (op == NULL) {\n\t\tif ((last != NULL) && (last != ret))\n\t\t    xmlFreeDocElementContent(ctxt->myDoc, last);\n\t        xmlFreeDocElementContent(ctxt->myDoc, ret);\n\t\treturn(NULL);\n\t    }\n\t    if (last == NULL) {\n\t\top->c1 = ret;\n\t\tif (ret != NULL)\n\t\t    ret->parent = op;\n\t\tret = cur = op;\n\t    } else {\n\t        cur->c2 = op;\n\t\tif (op != NULL)\n\t\t    op->parent = cur;\n\t\top->c1 = last;\n\t\tif (last != NULL)\n\t\t    last->parent = op;\n\t\tcur =op;\n\t\tlast = NULL;\n\t    }\n\t} else if (RAW == '|') {\n\t    if (type == 0) type = CUR;\n\n\t    /*\n\t     * Detect \"Name , Name | Name\" error\n\t     */\n\t    else if (type != CUR) {\n\t\txmlFatalErrMsgInt(ctxt, XML_ERR_SEPARATOR_REQUIRED,\n\t\t    \"xmlParseElementChildrenContentDecl : '%c' expected\\n\",\n\t\t\t\t  type);\n\t\tif ((last != NULL) && (last != ret))\n\t\t    xmlFreeDocElementContent(ctxt->myDoc, last);\n\t\tif (ret != NULL)\n\t\t    xmlFreeDocElementContent(ctxt->myDoc, ret);\n\t\treturn(NULL);\n\t    }\n\t    NEXT;\n\n\t    op = xmlNewDocElementContent(ctxt->myDoc, NULL, XML_ELEMENT_CONTENT_OR);\n\t    if (op == NULL) {\n\t\tif ((last != NULL) && (last != ret))\n\t\t    xmlFreeDocElementContent(ctxt->myDoc, last);\n\t\tif (ret != NULL)\n\t\t    xmlFreeDocElementContent(ctxt->myDoc, ret);\n\t\treturn(NULL);\n\t    }\n\t    if (last == NULL) {\n\t\top->c1 = ret;\n\t\tif (ret != NULL)\n\t\t    ret->parent = op;\n\t\tret = cur = op;\n\t    } else {\n\t        cur->c2 = op;\n\t\tif (op != NULL)\n\t\t    op->parent = cur;\n\t\top->c1 = last;\n\t\tif (last != NULL)\n\t\t    last->parent = op;\n\t\tcur =op;\n\t\tlast = NULL;\n\t    }\n\t} else {\n\t    xmlFatalErr(ctxt, XML_ERR_ELEMCONTENT_NOT_FINISHED, NULL);\n\t    if ((last != NULL) && (last != ret))\n\t        xmlFreeDocElementContent(ctxt->myDoc, last);\n\t    if (ret != NULL)\n\t\txmlFreeDocElementContent(ctxt->myDoc, ret);\n\t    return(NULL);\n\t}\n\tGROW;\n\tSKIP_BLANKS;\n\tGROW;\n\tif (RAW == '(') {\n\t    int inputid = ctxt->input->id;\n\t    /* Recurse on second child */\n\t    NEXT;\n\t    SKIP_BLANKS;\n\t    last = xmlParseElementChildrenContentDeclPriv(ctxt, inputid,\n                                                          depth + 1);\n\t    SKIP_BLANKS;\n\t} else {\n\t    elem = xmlParseName(ctxt);\n\t    if (elem == NULL) {\n\t\txmlFatalErr(ctxt, XML_ERR_ELEMCONTENT_NOT_STARTED, NULL);\n\t\tif (ret != NULL)\n\t\t    xmlFreeDocElementContent(ctxt->myDoc, ret);\n\t\treturn(NULL);\n\t    }\n\t    last = xmlNewDocElementContent(ctxt->myDoc, elem, XML_ELEMENT_CONTENT_ELEMENT);\n\t    if (last == NULL) {\n\t\tif (ret != NULL)\n\t\t    xmlFreeDocElementContent(ctxt->myDoc, ret);\n\t\treturn(NULL);\n\t    }\n\t    if (RAW == '?') {\n\t\tlast->ocur = XML_ELEMENT_CONTENT_OPT;\n\t\tNEXT;\n\t    } else if (RAW == '*') {\n\t\tlast->ocur = XML_ELEMENT_CONTENT_MULT;\n\t\tNEXT;\n\t    } else if (RAW == '+') {\n\t\tlast->ocur = XML_ELEMENT_CONTENT_PLUS;\n\t\tNEXT;\n\t    } else {\n\t\tlast->ocur = XML_ELEMENT_CONTENT_ONCE;\n\t    }\n\t}\n\tSKIP_BLANKS;\n\tGROW;\n    }\n    if ((cur != NULL) && (last != NULL)) {\n        cur->c2 = last;\n\tif (last != NULL)\n\t    last->parent = cur;\n    }\n    if ((ctxt->validate) && (ctxt->input->id != inputchk)) {\n\txmlValidityError(ctxt, XML_ERR_ENTITY_BOUNDARY,\n\"Element content declaration doesn't start and stop in the same entity\\n\",\n\t\t\t NULL, NULL);\n    }\n    NEXT;\n    if (RAW == '?') {\n\tif (ret != NULL) {\n\t    if ((ret->ocur == XML_ELEMENT_CONTENT_PLUS) ||\n\t        (ret->ocur == XML_ELEMENT_CONTENT_MULT))\n\t        ret->ocur = XML_ELEMENT_CONTENT_MULT;\n\t    else\n\t        ret->ocur = XML_ELEMENT_CONTENT_OPT;\n\t}\n\tNEXT;\n    } else if (RAW == '*') {\n\tif (ret != NULL) {\n\t    ret->ocur = XML_ELEMENT_CONTENT_MULT;\n\t    cur = ret;\n\t    /*\n\t     * Some normalization:\n\t     * (a | b* | c?)* == (a | b | c)*\n\t     */\n\t    while ((cur != NULL) && (cur->type == XML_ELEMENT_CONTENT_OR)) {\n\t\tif ((cur->c1 != NULL) &&\n\t            ((cur->c1->ocur == XML_ELEMENT_CONTENT_OPT) ||\n\t\t     (cur->c1->ocur == XML_ELEMENT_CONTENT_MULT)))\n\t\t    cur->c1->ocur = XML_ELEMENT_CONTENT_ONCE;\n\t\tif ((cur->c2 != NULL) &&\n\t            ((cur->c2->ocur == XML_ELEMENT_CONTENT_OPT) ||\n\t\t     (cur->c2->ocur == XML_ELEMENT_CONTENT_MULT)))\n\t\t    cur->c2->ocur = XML_ELEMENT_CONTENT_ONCE;\n\t\tcur = cur->c2;\n\t    }\n\t}\n\tNEXT;\n    } else if (RAW == '+') {\n\tif (ret != NULL) {\n\t    int found = 0;\n\n\t    if ((ret->ocur == XML_ELEMENT_CONTENT_OPT) ||\n\t        (ret->ocur == XML_ELEMENT_CONTENT_MULT))\n\t        ret->ocur = XML_ELEMENT_CONTENT_MULT;\n\t    else\n\t        ret->ocur = XML_ELEMENT_CONTENT_PLUS;\n\t    /*\n\t     * Some normalization:\n\t     * (a | b*)+ == (a | b)*\n\t     * (a | b?)+ == (a | b)*\n\t     */\n\t    while ((cur != NULL) && (cur->type == XML_ELEMENT_CONTENT_OR)) {\n\t\tif ((cur->c1 != NULL) &&\n\t            ((cur->c1->ocur == XML_ELEMENT_CONTENT_OPT) ||\n\t\t     (cur->c1->ocur == XML_ELEMENT_CONTENT_MULT))) {\n\t\t    cur->c1->ocur = XML_ELEMENT_CONTENT_ONCE;\n\t\t    found = 1;\n\t\t}\n\t\tif ((cur->c2 != NULL) &&\n\t            ((cur->c2->ocur == XML_ELEMENT_CONTENT_OPT) ||\n\t\t     (cur->c2->ocur == XML_ELEMENT_CONTENT_MULT))) {\n\t\t    cur->c2->ocur = XML_ELEMENT_CONTENT_ONCE;\n\t\t    found = 1;\n\t\t}\n\t\tcur = cur->c2;\n\t    }\n\t    if (found)\n\t\tret->ocur = XML_ELEMENT_CONTENT_MULT;\n\t}\n\tNEXT;\n    }\n    return(ret);\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 81,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-5199",
    "code_before_change": "PrefService* DataReductionProxySettings::GetOriginalProfilePrefs() {\n   DCHECK(thread_checker_.CalledOnValidThread());\n   return prefs_;\n }\n",
    "code_after_change": "PrefService* DataReductionProxySettings::GetOriginalProfilePrefs() {\nPrefService* DataReductionProxySettings::GetOriginalProfilePrefs() const {\n   DCHECK(thread_checker_.CalledOnValidThread());\n   return prefs_;\n }\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 82,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2012-5152",
    "code_before_change": "  void WriteFakeData(uint8* audio_data, size_t length) {\n    Type* output = reinterpret_cast<Type*>(audio_data);\n    for (size_t i = 0; i < length; i++) {\n      output[i] = i % 5 + 10;\n    }\n  }\n",
    "code_after_change": "  void WriteFakeData(uint8* audio_data, size_t length) {\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 84,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-1621",
    "code_before_change": "   static void SetUpTestCase() {\n    source_data_ = reinterpret_cast<uint8_t*>(\n         vpx_memalign(kDataAlignment, kDataBlockSize));\n    reference_data_ = reinterpret_cast<uint8_t*>(\n         vpx_memalign(kDataAlignment, kDataBufferSize));\n   }\n",
    "code_after_change": "   static void SetUpTestCase() {\n    source_data8_ = reinterpret_cast<uint8_t*>(\n         vpx_memalign(kDataAlignment, kDataBlockSize));\n    reference_data8_ = reinterpret_cast<uint8_t*>(\n         vpx_memalign(kDataAlignment, kDataBufferSize));\n    second_pred8_ = reinterpret_cast<uint8_t*>(\n        vpx_memalign(kDataAlignment, 64*64));\n    source_data16_ = reinterpret_cast<uint16_t*>(\n        vpx_memalign(kDataAlignment, kDataBlockSize*sizeof(uint16_t)));\n    reference_data16_ = reinterpret_cast<uint16_t*>(\n        vpx_memalign(kDataAlignment, kDataBufferSize*sizeof(uint16_t)));\n    second_pred16_ = reinterpret_cast<uint16_t*>(\n        vpx_memalign(kDataAlignment, 64*64*sizeof(uint16_t)));\n   }\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 89,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2018-18338",
    "code_before_change": " UnacceleratedStaticBitmapImage::MakeAccelerated(\n     base::WeakPtr<WebGraphicsContext3DProviderWrapper> context_wrapper) {\n   if (!context_wrapper)\n     return nullptr;  // Can happen if the context is lost.\n \n  GrContext* grcontext = context_wrapper->ContextProvider()->GetGrContext();\n  if (!grcontext)\n    return nullptr;  // Can happen if the context is lost.\n\n  sk_sp<SkImage> sk_image = paint_image_.GetSkImage();\n  sk_sp<SkImage> gpu_skimage =\n      sk_image->makeTextureImage(grcontext, sk_image->colorSpace());\n  if (!gpu_skimage)\n    return nullptr;\n\n  return AcceleratedStaticBitmapImage::CreateFromSkImage(\n      std::move(gpu_skimage), std::move(context_wrapper));\n}\n",
    "code_after_change": " UnacceleratedStaticBitmapImage::MakeAccelerated(\n     base::WeakPtr<WebGraphicsContext3DProviderWrapper> context_wrapper) {\n  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n\n   if (!context_wrapper)\n     return nullptr;  // Can happen if the context is lost.\n \n  GrContext* grcontext = context_wrapper->ContextProvider()->GetGrContext();\n  if (!grcontext)\n    return nullptr;  // Can happen if the context is lost.\n\n  sk_sp<SkImage> sk_image = paint_image_.GetSkImage();\n  sk_sp<SkImage> gpu_skimage =\n      sk_image->makeTextureImage(grcontext, sk_image->colorSpace());\n  if (!gpu_skimage)\n    return nullptr;\n\n  return AcceleratedStaticBitmapImage::CreateFromSkImage(\n      std::move(gpu_skimage), std::move(context_wrapper));\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 94,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-1621",
    "code_before_change": " void VarianceTest<VarianceFunctionType>::ZeroTest() {\n   for (int i = 0; i <= 255; ++i) {\n    memset(src_, i, block_size_);\n     for (int j = 0; j <= 255; ++j) {\n      memset(ref_, j, block_size_);\n       unsigned int sse;\n       unsigned int var;\n      REGISTER_STATE_CHECK(var = variance_(src_, width_, ref_, width_, &sse));\n      EXPECT_EQ(0u, var) << \"src values: \" << i << \"ref values: \" << j;\n     }\n   }\n }\n",
    "code_after_change": " void VarianceTest<VarianceFunctionType>::ZeroTest() {\n   for (int i = 0; i <= 255; ++i) {\n    if (!use_high_bit_depth_) {\n      memset(src_, i, block_size_);\n#if CONFIG_VP9_HIGHBITDEPTH\n    } else {\n      vpx_memset16(CONVERT_TO_SHORTPTR(src_), i << (bit_depth_ - 8),\n                   block_size_);\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n    }\n     for (int j = 0; j <= 255; ++j) {\n      if (!use_high_bit_depth_) {\n        memset(ref_, j, block_size_);\n#if CONFIG_VP9_HIGHBITDEPTH\n      } else {\n        vpx_memset16(CONVERT_TO_SHORTPTR(ref_), j  << (bit_depth_ - 8),\n                     block_size_);\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n      }\n       unsigned int sse;\n       unsigned int var;\n      ASM_REGISTER_STATE_CHECK(\n          var = variance_(src_, width_, ref_, width_, &sse));\n      EXPECT_EQ(0u, var) << \"src values: \" << i << \" ref values: \" << j;\n     }\n   }\n }\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 96,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2014-1690",
    "code_before_change": "static unsigned int help(struct sk_buff *skb,\n\t\t\t enum ip_conntrack_info ctinfo,\n\t\t\t unsigned int protoff,\n\t\t\t unsigned int matchoff,\n\t\t\t unsigned int matchlen,\n \t\t\t struct nf_conntrack_expect *exp)\n {\n \tchar buffer[sizeof(\"4294967296 65635\")];\n \tu_int16_t port;\n \tunsigned int ret;\n \n \t/* Reply comes from server. */\n \texp->saved_proto.tcp.port = exp->tuple.dst.u.tcp.port;\n \texp->dir = IP_CT_DIR_REPLY;\n \texp->expectfn = nf_nat_follow_master;\n\n\t/* Try to get same port: if not, try to change it. */\n\tfor (port = ntohs(exp->saved_proto.tcp.port); port != 0; port++) {\n\t\tint ret;\n\n\t\texp->tuple.dst.u.tcp.port = htons(port);\n\t\tret = nf_ct_expect_related(exp);\n\t\tif (ret == 0)\n\t\t\tbreak;\n\t\telse if (ret != -EBUSY) {\n\t\t\tport = 0;\n\t\t\tbreak;\n\t\t}\n \t}\n \n \tif (port == 0) {\n\t\tnf_ct_helper_log(skb, exp->master, \"all ports in use\");\n \t\treturn NF_DROP;\n \t}\n \n\tret = nf_nat_mangle_tcp_packet(skb, exp->master, ctinfo,\n\t\t\t\t       protoff, matchoff, matchlen, buffer,\n\t\t\t\t       strlen(buffer));\n \tif (ret != NF_ACCEPT) {\n\t\tnf_ct_helper_log(skb, exp->master, \"cannot mangle packet\");\n \t\tnf_ct_unexpect_related(exp);\n \t}\n \treturn ret;\n }\n",
    "code_after_change": "static unsigned int help(struct sk_buff *skb,\n\t\t\t enum ip_conntrack_info ctinfo,\n\t\t\t unsigned int protoff,\n\t\t\t unsigned int matchoff,\n\t\t\t unsigned int matchlen,\n \t\t\t struct nf_conntrack_expect *exp)\n {\n \tchar buffer[sizeof(\"4294967296 65635\")];\n\tstruct nf_conn *ct = exp->master;\n\tunion nf_inet_addr newaddr;\n \tu_int16_t port;\n \tunsigned int ret;\n \n \t/* Reply comes from server. */\n\tnewaddr = ct->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u3;\n\n \texp->saved_proto.tcp.port = exp->tuple.dst.u.tcp.port;\n \texp->dir = IP_CT_DIR_REPLY;\n \texp->expectfn = nf_nat_follow_master;\n\n\t/* Try to get same port: if not, try to change it. */\n\tfor (port = ntohs(exp->saved_proto.tcp.port); port != 0; port++) {\n\t\tint ret;\n\n\t\texp->tuple.dst.u.tcp.port = htons(port);\n\t\tret = nf_ct_expect_related(exp);\n\t\tif (ret == 0)\n\t\t\tbreak;\n\t\telse if (ret != -EBUSY) {\n\t\t\tport = 0;\n\t\t\tbreak;\n\t\t}\n \t}\n \n \tif (port == 0) {\n\t\tnf_ct_helper_log(skb, ct, \"all ports in use\");\n \t\treturn NF_DROP;\n \t}\n \n\t/* strlen(\"\\1DCC CHAT chat AAAAAAAA P\\1\\n\")=27\n\t * strlen(\"\\1DCC SCHAT chat AAAAAAAA P\\1\\n\")=28\n\t * strlen(\"\\1DCC SEND F AAAAAAAA P S\\1\\n\")=26\n\t * strlen(\"\\1DCC MOVE F AAAAAAAA P S\\1\\n\")=26\n\t * strlen(\"\\1DCC TSEND F AAAAAAAA P S\\1\\n\")=27\n\t *\n\t * AAAAAAAAA: bound addr (1.0.0.0==16777216, min 8 digits,\n\t *                        255.255.255.255==4294967296, 10 digits)\n\t * P:         bound port (min 1 d, max 5d (65635))\n\t * F:         filename   (min 1 d )\n\t * S:         size       (min 1 d )\n\t * 0x01, \\n:  terminators\n\t */\n\t/* AAA = \"us\", ie. where server normally talks to. */\n\tsnprintf(buffer, sizeof(buffer), \"%u %u\", ntohl(newaddr.ip), port);\n\tpr_debug(\"nf_nat_irc: inserting '%s' == %pI4, port %u\\n\",\n\t\t buffer, &newaddr.ip, port);\n\n\tret = nf_nat_mangle_tcp_packet(skb, ct, ctinfo, protoff, matchoff,\n\t\t\t\t       matchlen, buffer, strlen(buffer));\n \tif (ret != NF_ACCEPT) {\n\t\tnf_ct_helper_log(skb, ct, \"cannot mangle packet\");\n \t\tnf_ct_unexpect_related(exp);\n \t}\n\n \treturn ret;\n }\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 102,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-1621",
    "code_before_change": "void EncoderTest::MismatchHook(const vpx_image_t *img1,\n                               const vpx_image_t *img2) {\n   ASSERT_TRUE(0) << \"Encode/Decode mismatch found\";\n }\n",
    "code_after_change": "void EncoderTest::MismatchHook(const vpx_image_t *img1,\nvoid EncoderTest::MismatchHook(const vpx_image_t* /*img1*/,\n                               const vpx_image_t* /*img2*/) {\n   ASSERT_TRUE(0) << \"Encode/Decode mismatch found\";\n }\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 104,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-4303",
    "code_before_change": "void cJSON_AddItemToArray( cJSON *array, cJSON *item )\n{\n\tcJSON *c = array->child;\n\tif ( ! item )\n\t\treturn;\n\tif ( ! c ) {\n\t\tarray->child = item;\n\t} else {\n\t\twhile ( c && c->next )\n\t\t\tc = c->next;\n\t\tsuffix_object( c, item );\n\t}\n}\n",
    "code_after_change": "void cJSON_AddItemToArray( cJSON *array, cJSON *item )\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 110,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-1621",
    "code_before_change": "long mkvparser::UnserializeInt(\n    IMkvReader* pReader,\n    long long pos,\n    long size,\n    long long& result)\n{\n    assert(pReader);\n    assert(pos >= 0);\n    assert(size > 0);\n    assert(size <= 8);\n \n    {\n        signed char b;\n \n        const long status = pReader->Read(pos, 1, (unsigned char*)&b);\n \n        if (status < 0)\n            return status;\n \n        result = b;\n \n        ++pos;\n    }\n \n    for (long i = 1; i < size; ++i)\n    {\n        unsigned char b;\n        const long status = pReader->Read(pos, 1, &b);\n        if (status < 0)\n            return status;\n        result <<= 8;\n        result |= b;\n        ++pos;\n    }\n    return 0;  //success\n}\n",
    "code_after_change": "long mkvparser::UnserializeInt(\n  if (size_ >= LONG_MAX)  // we need (size+1) chars\n    return E_FILE_FORMAT_INVALID;\n \n  const long size = static_cast<long>(size_);\n \n  str = new (std::nothrow) char[size + 1];\n \n  if (str == NULL)\n    return -1;\n \n  unsigned char* const buf = reinterpret_cast<unsigned char*>(str);\n \n  const long status = pReader->Read(pos, size, buf);\n \n",
    "cwe": [
      "CWE-119"
    ],
    "id": 116,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-1621",
    "code_before_change": "static void encode_frame(vpx_codec_ctx_t *codec,\n                         vpx_image_t *img,\n                         int frame_index,\n                         VpxVideoWriter *writer) {\n   vpx_codec_iter_t iter = NULL;\n   const vpx_codec_cx_pkt_t *pkt = NULL;\n   const vpx_codec_err_t res = vpx_codec_encode(codec, img, frame_index, 1, 0,\n                                               VPX_DL_GOOD_QUALITY);\n if (res != VPX_CODEC_OK)\n\n     die_codec(codec, \"Failed to encode frame\");\n \n   while ((pkt = vpx_codec_get_cx_data(codec, &iter)) != NULL) {\n     if (pkt->kind == VPX_CODEC_CX_FRAME_PKT) {\n       const int keyframe = (pkt->data.frame.flags & VPX_FRAME_IS_KEY) != 0;\n       if (!vpx_video_writer_write_frame(writer,\n                                        pkt->data.frame.buf,\n                                        pkt->data.frame.sz,\n                                        pkt->data.frame.pts)) {\n        die_codec(codec, \"Failed to write compressed frame\");\n }\n\n      printf(keyframe ? \"K\" : \".\");\n\n       fflush(stdout);\n     }\n   }\n }\n",
    "code_after_change": "static void encode_frame(vpx_codec_ctx_t *codec,\nstatic int encode_frame(vpx_codec_ctx_t *codec,\n                        vpx_image_t *img,\n                        int frame_index,\n                        VpxVideoWriter *writer) {\n  int got_pkts = 0;\n   vpx_codec_iter_t iter = NULL;\n   const vpx_codec_cx_pkt_t *pkt = NULL;\n   const vpx_codec_err_t res = vpx_codec_encode(codec, img, frame_index, 1, 0,\n                                               VPX_DL_GOOD_QUALITY);\n if (res != VPX_CODEC_OK)\n\n     die_codec(codec, \"Failed to encode frame\");\n \n   while ((pkt = vpx_codec_get_cx_data(codec, &iter)) != NULL) {\n    got_pkts = 1;\n\n     if (pkt->kind == VPX_CODEC_CX_FRAME_PKT) {\n       const int keyframe = (pkt->data.frame.flags & VPX_FRAME_IS_KEY) != 0;\n       if (!vpx_video_writer_write_frame(writer,\n                                        pkt->data.frame.buf,\n                                        pkt->data.frame.sz,\n                                        pkt->data.frame.pts)) {\n        die_codec(codec, \"Failed to write compressed frame\");\n }\n\n      printf(keyframe ? \"K\" : \".\");\n\n       fflush(stdout);\n     }\n   }\n\n  return got_pkts;\n }\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 122,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-4303",
    "code_before_change": "cJSON *cJSON_CreateFloat( double num )\n{\n\tcJSON *item = cJSON_New_Item();\n\tif ( item ) {\n\t\titem->type = cJSON_Number;\n\t\titem->valuefloat = num;\n\t\titem->valueint = num;\n\t}\n\treturn item;\n}\n",
    "code_after_change": "cJSON *cJSON_CreateFloat( double num )\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 126,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2015-8126",
    "code_before_change": "png_inflate(png_structp png_ptr, const png_byte *data, png_size_t size,\n        png_bytep output, png_size_t output_size)\n{\n   png_size_t count = 0;\n\n   png_ptr->zstream.next_in = (png_bytep)data; /* const_cast: VALID */\n   png_ptr->zstream.avail_in = size;\n\n   while (1)\n   {\n      int ret, avail;\n\n      /* Reset the output buffer each time round - we empty it\n       * after every inflate call.\n       */\n      png_ptr->zstream.next_out = png_ptr->zbuf;\n      png_ptr->zstream.avail_out = png_ptr->zbuf_size;\n\n      ret = inflate(&png_ptr->zstream, Z_NO_FLUSH);\n      avail = png_ptr->zbuf_size - png_ptr->zstream.avail_out;\n\n      /* First copy/count any new output - but only if we didn't\n       * get an error code.\n       */\n      if ((ret == Z_OK || ret == Z_STREAM_END) && avail > 0)\n      {\n         if (output != 0 && output_size > count)\n         {\n            png_size_t copy = output_size - count;\n            if ((png_size_t) avail < copy) copy = (png_size_t) avail;\n            png_memcpy(output + count, png_ptr->zbuf, copy);\n         }\n         count += avail;\n      }\n\n      if (ret == Z_OK)\n         continue;\n\n      /* Termination conditions - always reset the zstream, it\n       * must be left in inflateInit state.\n       */\n      png_ptr->zstream.avail_in = 0;\n      inflateReset(&png_ptr->zstream);\n\n      if (ret == Z_STREAM_END)\n         return count; /* NOTE: may be zero. */\n\n      /* Now handle the error codes - the API always returns 0\n       * and the error message is dumped into the uncompressed\n       * buffer if available.\n       */\n      {\n         PNG_CONST char *msg;\n         if (png_ptr->zstream.msg != 0)\n            msg = png_ptr->zstream.msg;\n         else\n         {\n#if defined(PNG_STDIO_SUPPORTED) && !defined(_WIN32_WCE)\n            char umsg[52];\n\n            switch (ret)\n            {\n               case Z_BUF_ERROR:\n                  msg = \"Buffer error in compressed datastream in %s chunk\";\n                  break;\n               case Z_DATA_ERROR:\n                  msg = \"Data error in compressed datastream in %s chunk\";\n                  break;\n               default:\n                  msg = \"Incomplete compressed datastream in %s chunk\";\n                  break;\n            }\n \n             png_snprintf(umsg, sizeof umsg, msg, png_ptr->chunk_name);\n             msg = umsg;\n #else\n             msg = \"Damaged compressed datastream in chunk other than IDAT\";\n #endif\n          }\n \n          png_warning(png_ptr, msg);\n       }\n \n       /* 0 means an error - notice that this code simple ignores\n       * zero length compressed chunks as a result.\n       */\n      return 0;\n   }\n}\n",
    "code_after_change": "png_inflate(png_structp png_ptr, const png_byte *data, png_size_t size,\n        png_bytep output, png_size_t output_size)\n{\n   png_size_t count = 0;\n\n   png_ptr->zstream.next_in = (png_bytep)data; /* const_cast: VALID */\n   png_ptr->zstream.avail_in = size;\n\n   while (1)\n   {\n      int ret, avail;\n\n      /* Reset the output buffer each time round - we empty it\n       * after every inflate call.\n       */\n      png_ptr->zstream.next_out = png_ptr->zbuf;\n      png_ptr->zstream.avail_out = png_ptr->zbuf_size;\n\n      ret = inflate(&png_ptr->zstream, Z_NO_FLUSH);\n      avail = png_ptr->zbuf_size - png_ptr->zstream.avail_out;\n\n      /* First copy/count any new output - but only if we didn't\n       * get an error code.\n       */\n      if ((ret == Z_OK || ret == Z_STREAM_END) && avail > 0)\n      {\n         if (output != 0 && output_size > count)\n         {\n            png_size_t copy = output_size - count;\n            if ((png_size_t) avail < copy) copy = (png_size_t) avail;\n            png_memcpy(output + count, png_ptr->zbuf, copy);\n         }\n         count += avail;\n      }\n\n      if (ret == Z_OK)\n         continue;\n\n      /* Termination conditions - always reset the zstream, it\n       * must be left in inflateInit state.\n       */\n      png_ptr->zstream.avail_in = 0;\n      inflateReset(&png_ptr->zstream);\n\n      if (ret == Z_STREAM_END)\n         return count; /* NOTE: may be zero. */\n\n      /* Now handle the error codes - the API always returns 0\n       * and the error message is dumped into the uncompressed\n       * buffer if available.\n       */\n      {\n         PNG_CONST char *msg;\n         if (png_ptr->zstream.msg != 0)\n            msg = png_ptr->zstream.msg;\n         else\n         {\n#if defined(PNG_STDIO_SUPPORTED) && !defined(_WIN32_WCE)\n            char umsg[52];\n\n            switch (ret)\n            {\n               case Z_BUF_ERROR:\n                  msg = \"Buffer error in compressed datastream in %s chunk\";\n                  break;\n               case Z_DATA_ERROR:\n                  msg = \"Data error in compressed datastream in %s chunk\";\n                  break;\n               default:\n                  msg = \"Incomplete compressed datastream in %s chunk\";\n                  break;\n            }\n \n             png_snprintf(umsg, sizeof umsg, msg, png_ptr->chunk_name);\n             msg = umsg;\n            png_warning(png_ptr, msg);\n #else\n             msg = \"Damaged compressed datastream in chunk other than IDAT\";\n #endif\n          }\n \n#ifndef PNG_STDIO_SUPPORTED\n          png_warning(png_ptr, msg);\n#endif\n       }\n \n       /* 0 means an error - notice that this code simple ignores\n       * zero length compressed chunks as a result.\n       */\n      return 0;\n   }\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 128,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2013-0917",
    "code_before_change": " FileEntrySync* DirectoryEntrySync::getFile(const String& path, const Dictionary& options, ExceptionState& exceptionState)\n {\n     FileSystemFlags flags(options);\n    RefPtr<EntrySyncCallbackHelper> helper = EntrySyncCallbackHelper::create();\n     m_fileSystem->getFile(this, path, flags, helper->successCallback(), helper->errorCallback(), DOMFileSystemBase::Synchronous);\n     return static_cast<FileEntrySync*>(helper->getResult(exceptionState));\n }\n",
    "code_after_change": " FileEntrySync* DirectoryEntrySync::getFile(const String& path, const Dictionary& options, ExceptionState& exceptionState)\n {\n     FileSystemFlags flags(options);\n    EntrySyncCallbackHelper* helper = EntrySyncCallbackHelper::create();\n     m_fileSystem->getFile(this, path, flags, helper->successCallback(), helper->errorCallback(), DOMFileSystemBase::Synchronous);\n     return static_cast<FileEntrySync*>(helper->getResult(exceptionState));\n }\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 134,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-1621",
    "code_before_change": "BlockEntry::~BlockEntry()\n{\n}\n",
    "code_after_change": "BlockEntry::~BlockEntry()\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 138,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-1621",
    "code_before_change": "Cluster* Cluster::Create(\n    Segment* pSegment,\n    long idx,\n    long long off)\n{\n    assert(pSegment);\n    assert(off >= 0);\n    const long long element_start = pSegment->m_start + off;\n    Cluster* const pCluster = new Cluster(pSegment,\n                                          idx,\n                                          element_start);\n    assert(pCluster);\n    return pCluster;\n}\n",
    "code_after_change": "Cluster* Cluster::Create(\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 140,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2011-3052",
    "code_before_change": "void WebGraphicsContext3DCommandBufferImpl::reshape(int width, int height) {\n  cached_width_ = width;\n   cached_height_ = height;\n \n   gl_->ResizeCHROMIUM(width, height);\n#ifdef FLIP_FRAMEBUFFER_VERTICALLY\n  scanline_.reset(new uint8[width * 4]);\n#endif  // FLIP_FRAMEBUFFER_VERTICALLY\n }\n",
    "code_after_change": "void WebGraphicsContext3DCommandBufferImpl::reshape(int width, int height) {\n  cached_width_ = width;\n   cached_height_ = height;\n \n   gl_->ResizeCHROMIUM(width, height);\n }\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 142,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-3824",
    "code_before_change": "    BufferMeta(size_t size)\n         : mSize(size),\n          mIsBackup(false) {\n     }\n",
    "code_after_change": "    BufferMeta(size_t size)\n    BufferMeta(size_t size, OMX_U32 portIndex)\n         : mSize(size),\n          mIsBackup(false),\n          mPortIndex(portIndex) {\n     }\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 174,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2014-5388",
    "code_before_change": "static uint64_t pci_read(void *opaque, hwaddr addr, unsigned int size)\n{\n    AcpiPciHpState *s = opaque;\n     uint32_t val = 0;\n     int bsel = s->hotplug_select;\n \n    if (bsel < 0 || bsel > ACPI_PCIHP_MAX_HOTPLUG_BUS) {\n         return 0;\n     }\n    switch (addr) {\n    case PCI_UP_BASE:\n        val = s->acpi_pcihp_pci_status[bsel].up;\n        if (!s->legacy_piix) {\n            s->acpi_pcihp_pci_status[bsel].up = 0;\n        }\n        ACPI_PCIHP_DPRINTF(\"pci_up_read %\" PRIu32 \"\\n\", val);\n        break;\n    case PCI_DOWN_BASE:\n        val = s->acpi_pcihp_pci_status[bsel].down;\n        ACPI_PCIHP_DPRINTF(\"pci_down_read %\" PRIu32 \"\\n\", val);\n        break;\n    case PCI_EJ_BASE:\n        /* No feature defined yet */\n        ACPI_PCIHP_DPRINTF(\"pci_features_read %\" PRIu32 \"\\n\", val);\n        break;\n    case PCI_RMV_BASE:\n        val = s->acpi_pcihp_pci_status[bsel].hotplug_enable;\n        ACPI_PCIHP_DPRINTF(\"pci_rmv_read %\" PRIu32 \"\\n\", val);\n        break;\n    case PCI_SEL_BASE:\n        val = s->hotplug_select;\n        ACPI_PCIHP_DPRINTF(\"pci_sel_read %\" PRIu32 \"\\n\", val);\n    default:\n        break;\n    }\n\n    return val;\n}\n",
    "code_after_change": "static uint64_t pci_read(void *opaque, hwaddr addr, unsigned int size)\n{\n    AcpiPciHpState *s = opaque;\n     uint32_t val = 0;\n     int bsel = s->hotplug_select;\n \n    if (bsel < 0 || bsel >= ACPI_PCIHP_MAX_HOTPLUG_BUS) {\n         return 0;\n     }\n    switch (addr) {\n    case PCI_UP_BASE:\n        val = s->acpi_pcihp_pci_status[bsel].up;\n        if (!s->legacy_piix) {\n            s->acpi_pcihp_pci_status[bsel].up = 0;\n        }\n        ACPI_PCIHP_DPRINTF(\"pci_up_read %\" PRIu32 \"\\n\", val);\n        break;\n    case PCI_DOWN_BASE:\n        val = s->acpi_pcihp_pci_status[bsel].down;\n        ACPI_PCIHP_DPRINTF(\"pci_down_read %\" PRIu32 \"\\n\", val);\n        break;\n    case PCI_EJ_BASE:\n        /* No feature defined yet */\n        ACPI_PCIHP_DPRINTF(\"pci_features_read %\" PRIu32 \"\\n\", val);\n        break;\n    case PCI_RMV_BASE:\n        val = s->acpi_pcihp_pci_status[bsel].hotplug_enable;\n        ACPI_PCIHP_DPRINTF(\"pci_rmv_read %\" PRIu32 \"\\n\", val);\n        break;\n    case PCI_SEL_BASE:\n        val = s->hotplug_select;\n        ACPI_PCIHP_DPRINTF(\"pci_sel_read %\" PRIu32 \"\\n\", val);\n    default:\n        break;\n    }\n\n    return val;\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 179,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-1621",
    "code_before_change": "void usage_exit() {\n   fprintf(stderr,\n           \"Usage: %s <codec> <width> <height> <infile> <outfile> \"\n               \"<keyframe-interval> [<error-resilient>]\\nSee comments in \"\n \"simple_encoder.c for more information.\\n\",\n          exec_name);\n\n   exit(EXIT_FAILURE);\n }\n",
    "code_after_change": "void usage_exit() {\nvoid usage_exit(void) {\n   fprintf(stderr,\n           \"Usage: %s <codec> <width> <height> <infile> <outfile> \"\n               \"<keyframe-interval> [<error-resilient>]\\nSee comments in \"\n \"simple_encoder.c for more information.\\n\",\n          exec_name);\n\n   exit(EXIT_FAILURE);\n }\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 182,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2015-5289",
    "code_before_change": "datum_to_json(Datum val, bool is_null, StringInfo result,\n\t\t\t  JsonTypeCategory tcategory, Oid outfuncoid,\n\t\t\t  bool key_scalar)\n{\n\tchar\t   *outputstr;\n\ttext\t   *jsontext;\n\n\t/* callers are expected to ensure that null keys are not passed in */\n    char       *outputstr;\n    text       *jsontext;\n \n    /* callers are expected to ensure that null keys are not passed in */\n    Assert(!(key_scalar && is_null));\n \n\tif (key_scalar &&\n\t\t(tcategory == JSONTYPE_ARRAY ||\n\t\t tcategory == JSONTYPE_COMPOSITE ||\n\t\t tcategory == JSONTYPE_JSON ||\n\t\t tcategory == JSONTYPE_CAST))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t errmsg(\"key value must be scalar, not array, composite, or json\")));\n\n\tswitch (tcategory)\n\t{\n\t\tcase JSONTYPE_ARRAY:\n\t\t\tarray_to_json_internal(val, result, false);\n\t\t\tbreak;\n\t\tcase JSONTYPE_COMPOSITE:\n\t\t\tcomposite_to_json(val, result, false);\n\t\t\tbreak;\n\t\tcase JSONTYPE_BOOL:\n\t\t\toutputstr = DatumGetBool(val) ? \"true\" : \"false\";\n\t\t\tif (key_scalar)\n\t\t\t\tescape_json(result, outputstr);\n\t\t\telse\n\t\t\t\tappendStringInfoString(result, outputstr);\n\t\t\tbreak;\n\t\tcase JSONTYPE_NUMERIC:\n\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\n\t\t\t/*\n\t\t\t * Don't call escape_json for a non-key if it's a valid JSON\n\t\t\t * number.\n\t\t\t */\n\t\t\tif (!key_scalar && IsValidJsonNumber(outputstr, strlen(outputstr)))\n\t\t\t\tappendStringInfoString(result, outputstr);\n\t\t\telse\n\t\t\t\tescape_json(result, outputstr);\n\t\t\tpfree(outputstr);\n\t\t\tbreak;\n\t\tcase JSONTYPE_DATE:\n\t\t\t{\n\t\t\t\tDateADT\t\tdate;\n\t\t\t\tstruct pg_tm tm;\n\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\tdate = DatumGetDateADT(val);\n\n\t\t\t\tif (DATE_NOT_FINITE(date))\n\t\t\t\t{\n\t\t\t\t\t/* we have to format infinity ourselves */\n\t\t\t\t\tappendStringInfoString(result, DT_INFINITY);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tj2date(date + POSTGRES_EPOCH_JDATE,\n\t\t\t\t\t\t   &(tm.tm_year), &(tm.tm_mon), &(tm.tm_mday));\n\t\t\t\t\tEncodeDateOnly(&tm, USE_XSD_DATES, buf);\n\t\t\t\t\tappendStringInfo(result, \"\\\"%s\\\"\", buf);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JSONTYPE_TIMESTAMP:\n\t\t\t{\n\t\t\t\tTimestamp\ttimestamp;\n\t\t\t\tstruct pg_tm tm;\n\t\t\t\tfsec_t\t\tfsec;\n\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\ttimestamp = DatumGetTimestamp(val);\n\n\t\t\t\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\t\t\t{\n\t\t\t\t\t/* we have to format infinity ourselves */\n\t\t\t\t\tappendStringInfoString(result, DT_INFINITY);\n\t\t\t\t}\n\t\t\t\telse if (timestamp2tm(timestamp, NULL, &tm, &fsec, NULL, NULL) == 0)\n\t\t\t\t{\n\t\t\t\t\tEncodeDateTime(&tm, fsec, false, 0, NULL, USE_XSD_DATES, buf);\n\t\t\t\t\tappendStringInfo(result, \"\\\"%s\\\"\", buf);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JSONTYPE_TIMESTAMPTZ:\n\t\t\t{\n\t\t\t\tTimestampTz timestamp;\n\t\t\t\tstruct pg_tm tm;\n\t\t\t\tint\t\t\ttz;\n\t\t\t\tfsec_t\t\tfsec;\n\t\t\t\tconst char *tzn = NULL;\n\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\ttimestamp = DatumGetTimestamp(val);\n\n\t\t\t\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\t\t\t{\n\t\t\t\t\t/* we have to format infinity ourselves */\n\t\t\t\t\tappendStringInfoString(result, DT_INFINITY);\n\t\t\t\t}\n\t\t\t\telse if (timestamp2tm(timestamp, &tz, &tm, &fsec, &tzn, NULL) == 0)\n\t\t\t\t{\n\t\t\t\t\tEncodeDateTime(&tm, fsec, true, tz, tzn, USE_XSD_DATES, buf);\n\t\t\t\t\tappendStringInfo(result, \"\\\"%s\\\"\", buf);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JSONTYPE_JSON:\n\t\t\t/* JSON and JSONB output will already be escaped */\n\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\t\t\tappendStringInfoString(result, outputstr);\n\t\t\tpfree(outputstr);\n\t\t\tbreak;\n\t\tcase JSONTYPE_CAST:\n\t\t\t/* outfuncoid refers to a cast function, not an output function */\n\t\t\tjsontext = DatumGetTextP(OidFunctionCall1(outfuncoid, val));\n\t\t\toutputstr = text_to_cstring(jsontext);\n\t\t\tappendStringInfoString(result, outputstr);\n\t\t\tpfree(outputstr);\n\t\t\tpfree(jsontext);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\t\t\tescape_json(result, outputstr);\n\t\t\tpfree(outputstr);\n\t\t\tbreak;\n\t}\n}\n",
    "code_after_change": "datum_to_json(Datum val, bool is_null, StringInfo result,\n\t\t\t  JsonTypeCategory tcategory, Oid outfuncoid,\n\t\t\t  bool key_scalar)\n{\n\tchar\t   *outputstr;\n\ttext\t   *jsontext;\n\n\t/* callers are expected to ensure that null keys are not passed in */\n    char       *outputstr;\n    text       *jsontext;\n \n   check_stack_depth();\n\n    /* callers are expected to ensure that null keys are not passed in */\n    Assert(!(key_scalar && is_null));\n \n\tif (key_scalar &&\n\t\t(tcategory == JSONTYPE_ARRAY ||\n\t\t tcategory == JSONTYPE_COMPOSITE ||\n\t\t tcategory == JSONTYPE_JSON ||\n\t\t tcategory == JSONTYPE_CAST))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t errmsg(\"key value must be scalar, not array, composite, or json\")));\n\n\tswitch (tcategory)\n\t{\n\t\tcase JSONTYPE_ARRAY:\n\t\t\tarray_to_json_internal(val, result, false);\n\t\t\tbreak;\n\t\tcase JSONTYPE_COMPOSITE:\n\t\t\tcomposite_to_json(val, result, false);\n\t\t\tbreak;\n\t\tcase JSONTYPE_BOOL:\n\t\t\toutputstr = DatumGetBool(val) ? \"true\" : \"false\";\n\t\t\tif (key_scalar)\n\t\t\t\tescape_json(result, outputstr);\n\t\t\telse\n\t\t\t\tappendStringInfoString(result, outputstr);\n\t\t\tbreak;\n\t\tcase JSONTYPE_NUMERIC:\n\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\n\t\t\t/*\n\t\t\t * Don't call escape_json for a non-key if it's a valid JSON\n\t\t\t * number.\n\t\t\t */\n\t\t\tif (!key_scalar && IsValidJsonNumber(outputstr, strlen(outputstr)))\n\t\t\t\tappendStringInfoString(result, outputstr);\n\t\t\telse\n\t\t\t\tescape_json(result, outputstr);\n\t\t\tpfree(outputstr);\n\t\t\tbreak;\n\t\tcase JSONTYPE_DATE:\n\t\t\t{\n\t\t\t\tDateADT\t\tdate;\n\t\t\t\tstruct pg_tm tm;\n\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\tdate = DatumGetDateADT(val);\n\n\t\t\t\tif (DATE_NOT_FINITE(date))\n\t\t\t\t{\n\t\t\t\t\t/* we have to format infinity ourselves */\n\t\t\t\t\tappendStringInfoString(result, DT_INFINITY);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tj2date(date + POSTGRES_EPOCH_JDATE,\n\t\t\t\t\t\t   &(tm.tm_year), &(tm.tm_mon), &(tm.tm_mday));\n\t\t\t\t\tEncodeDateOnly(&tm, USE_XSD_DATES, buf);\n\t\t\t\t\tappendStringInfo(result, \"\\\"%s\\\"\", buf);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JSONTYPE_TIMESTAMP:\n\t\t\t{\n\t\t\t\tTimestamp\ttimestamp;\n\t\t\t\tstruct pg_tm tm;\n\t\t\t\tfsec_t\t\tfsec;\n\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\ttimestamp = DatumGetTimestamp(val);\n\n\t\t\t\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\t\t\t{\n\t\t\t\t\t/* we have to format infinity ourselves */\n\t\t\t\t\tappendStringInfoString(result, DT_INFINITY);\n\t\t\t\t}\n\t\t\t\telse if (timestamp2tm(timestamp, NULL, &tm, &fsec, NULL, NULL) == 0)\n\t\t\t\t{\n\t\t\t\t\tEncodeDateTime(&tm, fsec, false, 0, NULL, USE_XSD_DATES, buf);\n\t\t\t\t\tappendStringInfo(result, \"\\\"%s\\\"\", buf);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JSONTYPE_TIMESTAMPTZ:\n\t\t\t{\n\t\t\t\tTimestampTz timestamp;\n\t\t\t\tstruct pg_tm tm;\n\t\t\t\tint\t\t\ttz;\n\t\t\t\tfsec_t\t\tfsec;\n\t\t\t\tconst char *tzn = NULL;\n\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\ttimestamp = DatumGetTimestamp(val);\n\n\t\t\t\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\t\t\t{\n\t\t\t\t\t/* we have to format infinity ourselves */\n\t\t\t\t\tappendStringInfoString(result, DT_INFINITY);\n\t\t\t\t}\n\t\t\t\telse if (timestamp2tm(timestamp, &tz, &tm, &fsec, &tzn, NULL) == 0)\n\t\t\t\t{\n\t\t\t\t\tEncodeDateTime(&tm, fsec, true, tz, tzn, USE_XSD_DATES, buf);\n\t\t\t\t\tappendStringInfo(result, \"\\\"%s\\\"\", buf);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JSONTYPE_JSON:\n\t\t\t/* JSON and JSONB output will already be escaped */\n\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\t\t\tappendStringInfoString(result, outputstr);\n\t\t\tpfree(outputstr);\n\t\t\tbreak;\n\t\tcase JSONTYPE_CAST:\n\t\t\t/* outfuncoid refers to a cast function, not an output function */\n\t\t\tjsontext = DatumGetTextP(OidFunctionCall1(outfuncoid, val));\n\t\t\toutputstr = text_to_cstring(jsontext);\n\t\t\tappendStringInfoString(result, outputstr);\n\t\t\tpfree(outputstr);\n\t\t\tpfree(jsontext);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\t\t\tescape_json(result, outputstr);\n\t\t\tpfree(outputstr);\n\t\t\tbreak;\n\t}\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 191,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-10066",
    "code_before_change": "static Image *ReadRLEImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define SkipLinesOp  0x01\n#define SetColorOp  0x02\n#define SkipPixelsOp  0x03\n#define ByteDataOp  0x05\n#define RunDataOp  0x06\n#define EOFOp  0x07\n\n  char\n    magick[12];\n\n  Image\n    *image;\n\n  int\n    opcode,\n    operand,\n    status;\n\n  MagickStatusType\n    flags;\n\n  MagickSizeType\n    number_pixels;\n\n  MemoryInfo\n    *pixel_info;\n\n  register IndexPacket\n    *indexes;\n\n  register ssize_t\n    x;\n\n  register PixelPacket\n    *q;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bits_per_pixel,\n    map_length,\n    number_colormaps,\n    number_planes,\n    one;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    background_color[256],\n    *colormap,\n    pixel,\n    plane,\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Determine if this a RLE file.\n  */\n  count=ReadBlob(image,2,(unsigned char *) magick);\n  if ((count == 0) || (memcmp(magick,\"\\122\\314\",2) != 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  do\n  {\n    /*\n      Read image header.\n    */\n    (void) ReadBlobLSBShort(image);\n    (void) ReadBlobLSBShort(image);\n    image->columns=ReadBlobLSBShort(image);\n    image->rows=ReadBlobLSBShort(image);\n    flags=(MagickStatusType) ReadBlobByte(image);\n    image->matte=flags & 0x04 ? MagickTrue : MagickFalse;\n    number_planes=1UL*ReadBlobByte(image);\n    bits_per_pixel=1UL*ReadBlobByte(image);\n    number_colormaps=1UL*ReadBlobByte(image);\n    map_length=(unsigned char) ReadBlobByte(image);\n    if (map_length >= 64)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    one=1;\n    map_length=one << map_length;\n    if ((number_planes == 0) || (number_planes == 2) || (bits_per_pixel != 8) ||\n        (image->columns == 0))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if (flags & 0x02)\n      {\n        /*\n          No background color-- initialize to black.\n        */\n        for (i=0; i < (ssize_t) number_planes; i++)\n          background_color[i]=0;\n        (void) ReadBlobByte(image);\n      }\n    else\n      {\n        /*\n          Initialize background color.\n        */\n        p=background_color;\n        for (i=0; i < (ssize_t) number_planes; i++)\n          *p++=(unsigned char) ReadBlobByte(image);\n      }\n    if ((number_planes & 0x01) == 0)\n      (void) ReadBlobByte(image);\n    colormap=(unsigned char *) NULL;\n    if (number_colormaps != 0)\n      {\n        /*\n          Read image colormaps.\n        */\n        colormap=(unsigned char *) AcquireQuantumMemory(number_colormaps,\n          map_length*sizeof(*colormap));\n        if (colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        p=colormap;\n        for (i=0; i < (ssize_t) number_colormaps; i++)\n          for (x=0; x < (ssize_t) map_length; x++)\n            *p++=(unsigned char) ScaleShortToQuantum(ReadBlobLSBShort(image));\n      }\n    if ((flags & 0x08) != 0)\n      {\n        char\n          *comment;\n\n        size_t\n          length;\n\n        /*\n          Read image comment.\n        */\n        length=ReadBlobLSBShort(image);\n        if (length != 0)\n          {\n            comment=(char *) AcquireQuantumMemory(length,sizeof(*comment));\n            if (comment == (char *) NULL)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n            count=ReadBlob(image,length-1,(unsigned char *) comment);\n            comment[length-1]='\\0';\n            (void) SetImageProperty(image,\"comment\",comment);\n            comment=DestroyString(comment);\n            if ((length & 0x01) == 0)\n              (void) ReadBlobByte(image);\n          }\n      }\n     if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n       if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n         break;\n     /*\n       Allocate RLE pixels.\n     */\n    if (image->matte != MagickFalse)\n      number_planes++;\n    number_pixels=(MagickSizeType) image->columns*image->rows;\n    if ((number_pixels*number_planes) != (size_t) (number_pixels*number_planes))\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixel_info=AcquireVirtualMemory(image->columns,image->rows*number_planes*\n      sizeof(*pixels));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    if ((flags & 0x01) && !(flags & 0x02))\n      {\n        ssize_t\n          j;\n\n        /*\n          Set background color.\n        */\n        p=pixels;\n        for (i=0; i < (ssize_t) number_pixels; i++)\n        {\n          if (image->matte == MagickFalse)\n            for (j=0; j < (ssize_t) number_planes; j++)\n              *p++=background_color[j];\n          else\n            {\n              for (j=0; j < (ssize_t) (number_planes-1); j++)\n                *p++=background_color[j];\n              *p++=0;  /* initialize matte channel */\n            }\n        }\n      }\n    /*\n      Read runlength-encoded image.\n    */\n    plane=0;\n    x=0;\n    y=0;\n    opcode=ReadBlobByte(image);\n    do\n    {\n      switch (opcode & 0x3f)\n      {\n        case SkipLinesOp:\n        {\n          operand=ReadBlobByte(image);\n          if (opcode & 0x40)\n            operand=(int) ReadBlobLSBShort(image);\n          x=0;\n          y+=operand;\n          break;\n        }\n        case SetColorOp:\n        {\n          operand=ReadBlobByte(image);\n          plane=(unsigned char) operand;\n          if (plane == 255)\n            plane=(unsigned char) (number_planes-1);\n          x=0;\n          break;\n        }\n        case SkipPixelsOp:\n        {\n          operand=ReadBlobByte(image);\n          if (opcode & 0x40)\n            operand=(int) ReadBlobLSBShort(image);\n          x+=operand;\n          break;\n        }\n        case ByteDataOp:\n        {\n          operand=ReadBlobByte(image);\n          if (opcode & 0x40)\n            operand=(int) ReadBlobLSBShort(image);\n          p=pixels+((image->rows-y-1)*image->columns*number_planes)+\n            x*number_planes+plane;\n          operand++;\n          for (i=0; i < (ssize_t) operand; i++)\n          {\n            pixel=(unsigned char) ReadBlobByte(image);\n            if ((y < (ssize_t) image->rows) &&\n                ((x+i) < (ssize_t) image->columns))\n              *p=pixel;\n            p+=number_planes;\n          }\n          if (operand & 0x01)\n            (void) ReadBlobByte(image);\n          x+=operand;\n          break;\n        }\n        case RunDataOp:\n        {\n          operand=ReadBlobByte(image);\n          if (opcode & 0x40)\n            operand=(int) ReadBlobLSBShort(image);\n          pixel=(unsigned char) ReadBlobByte(image);\n          (void) ReadBlobByte(image);\n          operand++;\n          p=pixels+((image->rows-y-1)*image->columns*number_planes)+\n            x*number_planes+plane;\n          for (i=0; i < (ssize_t) operand; i++)\n          {\n            if ((y < (ssize_t) image->rows) &&\n                ((x+i) < (ssize_t) image->columns))\n              *p=pixel;\n            p+=number_planes;\n          }\n          x+=operand;\n          break;\n        }\n        default:\n          break;\n      }\n      opcode=ReadBlobByte(image);\n    } while (((opcode & 0x3f) != EOFOp) && (opcode != EOF));\n    if (number_colormaps != 0)\n      {\n        MagickStatusType\n          mask;\n\n        /*\n          Apply colormap affineation to image.\n        */\n        mask=(MagickStatusType) (map_length-1);\n        p=pixels;\n        if (number_colormaps == 1)\n          for (i=0; i < (ssize_t) number_pixels; i++)\n          {\n            *p=colormap[*p & mask];\n            p++;\n          }\n        else\n          if ((number_planes >= 3) && (number_colormaps >= 3))\n            for (i=0; i < (ssize_t) number_pixels; i++)\n              for (x=0; x < (ssize_t) number_planes; x++)\n              {\n                *p=colormap[x*map_length+(*p & mask)];\n                p++;\n              }\n      }\n    /*\n      Initialize image structure.\n    */\n    if (number_planes >= 3)\n      {\n        /*\n          Convert raster image to DirectClass pixel packets.\n        */\n        p=pixels;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelRed(q,ScaleCharToQuantum(*p++));\n            SetPixelGreen(q,ScaleCharToQuantum(*p++));\n            SetPixelBlue(q,ScaleCharToQuantum(*p++));\n            if (image->matte != MagickFalse)\n              SetPixelAlpha(q,ScaleCharToQuantum(*p++));\n            q++;\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      }\n    else\n      {\n        /*\n          Create colormap.\n        */\n        if (number_colormaps == 0)\n          map_length=256;\n        if (AcquireImageColormap(image,map_length) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        p=colormap;\n        if (number_colormaps == 1)\n          for (i=0; i < (ssize_t) image->colors; i++)\n          {\n            /*\n              Pseudocolor.\n            */\n            image->colormap[i].red=ScaleCharToQuantum((unsigned char) i);\n            image->colormap[i].green=ScaleCharToQuantum((unsigned char) i);\n            image->colormap[i].blue=ScaleCharToQuantum((unsigned char) i);\n          }\n        else\n          if (number_colormaps > 1)\n            for (i=0; i < (ssize_t) image->colors; i++)\n            {\n              image->colormap[i].red=ScaleCharToQuantum(*p);\n              image->colormap[i].green=ScaleCharToQuantum(*(p+map_length));\n              image->colormap[i].blue=ScaleCharToQuantum(*(p+map_length*2));\n              p++;\n            }\n        p=pixels;\n        if (image->matte == MagickFalse)\n          {\n            /*\n              Convert raster image to PseudoClass pixel packets.\n            */\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (PixelPacket *) NULL)\n                break;\n              indexes=GetAuthenticIndexQueue(image);\n              for (x=0; x < (ssize_t) image->columns; x++)\n                SetPixelIndex(indexes+x,*p++);\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            (void) SyncImage(image);\n          }\n        else\n          {\n            /*\n              Image has a matte channel-- promote to DirectClass.\n            */\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (PixelPacket *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                SetPixelRed(q,image->colormap[*p++].red);\n                SetPixelGreen(q,image->colormap[*p++].green);\n                SetPixelBlue(q,image->colormap[*p++].blue);\n                SetPixelAlpha(q,ScaleCharToQuantum(*p++));\n                q++;\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            image->colormap=(PixelPacket *) RelinquishMagickMemory(\n              image->colormap);\n            image->storage_class=DirectClass;\n            image->colors=0;\n          }\n      }\n    if (number_colormaps != 0)\n      colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    (void) ReadBlobByte(image);\n    count=ReadBlob(image,2,(unsigned char *) magick);\n    if ((count != 0) && (memcmp(magick,\"\\122\\314\",2) == 0))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while ((count != 0) && (memcmp(magick,\"\\122\\314\",2) == 0));\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n",
    "code_after_change": "static Image *ReadRLEImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define SkipLinesOp  0x01\n#define SetColorOp  0x02\n#define SkipPixelsOp  0x03\n#define ByteDataOp  0x05\n#define RunDataOp  0x06\n#define EOFOp  0x07\n\n  char\n    magick[12];\n\n  Image\n    *image;\n\n  int\n    opcode,\n    operand,\n    status;\n\n  MagickStatusType\n    flags;\n\n  MagickSizeType\n    number_pixels;\n\n  MemoryInfo\n    *pixel_info;\n\n  register IndexPacket\n    *indexes;\n\n  register ssize_t\n    x;\n\n  register PixelPacket\n    *q;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bits_per_pixel,\n    map_length,\n    number_colormaps,\n    number_planes,\n    one;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    background_color[256],\n    *colormap,\n    pixel,\n    plane,\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Determine if this a RLE file.\n  */\n  count=ReadBlob(image,2,(unsigned char *) magick);\n  if ((count == 0) || (memcmp(magick,\"\\122\\314\",2) != 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  do\n  {\n    /*\n      Read image header.\n    */\n    (void) ReadBlobLSBShort(image);\n    (void) ReadBlobLSBShort(image);\n    image->columns=ReadBlobLSBShort(image);\n    image->rows=ReadBlobLSBShort(image);\n    flags=(MagickStatusType) ReadBlobByte(image);\n    image->matte=flags & 0x04 ? MagickTrue : MagickFalse;\n    number_planes=1UL*ReadBlobByte(image);\n    bits_per_pixel=1UL*ReadBlobByte(image);\n    number_colormaps=1UL*ReadBlobByte(image);\n    map_length=(unsigned char) ReadBlobByte(image);\n    if (map_length >= 64)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    one=1;\n    map_length=one << map_length;\n    if ((number_planes == 0) || (number_planes == 2) || (bits_per_pixel != 8) ||\n        (image->columns == 0))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if (flags & 0x02)\n      {\n        /*\n          No background color-- initialize to black.\n        */\n        for (i=0; i < (ssize_t) number_planes; i++)\n          background_color[i]=0;\n        (void) ReadBlobByte(image);\n      }\n    else\n      {\n        /*\n          Initialize background color.\n        */\n        p=background_color;\n        for (i=0; i < (ssize_t) number_planes; i++)\n          *p++=(unsigned char) ReadBlobByte(image);\n      }\n    if ((number_planes & 0x01) == 0)\n      (void) ReadBlobByte(image);\n    colormap=(unsigned char *) NULL;\n    if (number_colormaps != 0)\n      {\n        /*\n          Read image colormaps.\n        */\n        colormap=(unsigned char *) AcquireQuantumMemory(number_colormaps,\n          map_length*sizeof(*colormap));\n        if (colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        p=colormap;\n        for (i=0; i < (ssize_t) number_colormaps; i++)\n          for (x=0; x < (ssize_t) map_length; x++)\n            *p++=(unsigned char) ScaleShortToQuantum(ReadBlobLSBShort(image));\n      }\n    if ((flags & 0x08) != 0)\n      {\n        char\n          *comment;\n\n        size_t\n          length;\n\n        /*\n          Read image comment.\n        */\n        length=ReadBlobLSBShort(image);\n        if (length != 0)\n          {\n            comment=(char *) AcquireQuantumMemory(length,sizeof(*comment));\n            if (comment == (char *) NULL)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n            count=ReadBlob(image,length-1,(unsigned char *) comment);\n            comment[length-1]='\\0';\n            (void) SetImageProperty(image,\"comment\",comment);\n            comment=DestroyString(comment);\n            if ((length & 0x01) == 0)\n              (void) ReadBlobByte(image);\n          }\n      }\n     if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n       if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n         break;\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n     /*\n       Allocate RLE pixels.\n     */\n    if (image->matte != MagickFalse)\n      number_planes++;\n    number_pixels=(MagickSizeType) image->columns*image->rows;\n    if ((number_pixels*number_planes) != (size_t) (number_pixels*number_planes))\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixel_info=AcquireVirtualMemory(image->columns,image->rows*number_planes*\n      sizeof(*pixels));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    if ((flags & 0x01) && !(flags & 0x02))\n      {\n        ssize_t\n          j;\n\n        /*\n          Set background color.\n        */\n        p=pixels;\n        for (i=0; i < (ssize_t) number_pixels; i++)\n        {\n          if (image->matte == MagickFalse)\n            for (j=0; j < (ssize_t) number_planes; j++)\n              *p++=background_color[j];\n          else\n            {\n              for (j=0; j < (ssize_t) (number_planes-1); j++)\n                *p++=background_color[j];\n              *p++=0;  /* initialize matte channel */\n            }\n        }\n      }\n    /*\n      Read runlength-encoded image.\n    */\n    plane=0;\n    x=0;\n    y=0;\n    opcode=ReadBlobByte(image);\n    do\n    {\n      switch (opcode & 0x3f)\n      {\n        case SkipLinesOp:\n        {\n          operand=ReadBlobByte(image);\n          if (opcode & 0x40)\n            operand=(int) ReadBlobLSBShort(image);\n          x=0;\n          y+=operand;\n          break;\n        }\n        case SetColorOp:\n        {\n          operand=ReadBlobByte(image);\n          plane=(unsigned char) operand;\n          if (plane == 255)\n            plane=(unsigned char) (number_planes-1);\n          x=0;\n          break;\n        }\n        case SkipPixelsOp:\n        {\n          operand=ReadBlobByte(image);\n          if (opcode & 0x40)\n            operand=(int) ReadBlobLSBShort(image);\n          x+=operand;\n          break;\n        }\n        case ByteDataOp:\n        {\n          operand=ReadBlobByte(image);\n          if (opcode & 0x40)\n            operand=(int) ReadBlobLSBShort(image);\n          p=pixels+((image->rows-y-1)*image->columns*number_planes)+\n            x*number_planes+plane;\n          operand++;\n          for (i=0; i < (ssize_t) operand; i++)\n          {\n            pixel=(unsigned char) ReadBlobByte(image);\n            if ((y < (ssize_t) image->rows) &&\n                ((x+i) < (ssize_t) image->columns))\n              *p=pixel;\n            p+=number_planes;\n          }\n          if (operand & 0x01)\n            (void) ReadBlobByte(image);\n          x+=operand;\n          break;\n        }\n        case RunDataOp:\n        {\n          operand=ReadBlobByte(image);\n          if (opcode & 0x40)\n            operand=(int) ReadBlobLSBShort(image);\n          pixel=(unsigned char) ReadBlobByte(image);\n          (void) ReadBlobByte(image);\n          operand++;\n          p=pixels+((image->rows-y-1)*image->columns*number_planes)+\n            x*number_planes+plane;\n          for (i=0; i < (ssize_t) operand; i++)\n          {\n            if ((y < (ssize_t) image->rows) &&\n                ((x+i) < (ssize_t) image->columns))\n              *p=pixel;\n            p+=number_planes;\n          }\n          x+=operand;\n          break;\n        }\n        default:\n          break;\n      }\n      opcode=ReadBlobByte(image);\n    } while (((opcode & 0x3f) != EOFOp) && (opcode != EOF));\n    if (number_colormaps != 0)\n      {\n        MagickStatusType\n          mask;\n\n        /*\n          Apply colormap affineation to image.\n        */\n        mask=(MagickStatusType) (map_length-1);\n        p=pixels;\n        if (number_colormaps == 1)\n          for (i=0; i < (ssize_t) number_pixels; i++)\n          {\n            *p=colormap[*p & mask];\n            p++;\n          }\n        else\n          if ((number_planes >= 3) && (number_colormaps >= 3))\n            for (i=0; i < (ssize_t) number_pixels; i++)\n              for (x=0; x < (ssize_t) number_planes; x++)\n              {\n                *p=colormap[x*map_length+(*p & mask)];\n                p++;\n              }\n      }\n    /*\n      Initialize image structure.\n    */\n    if (number_planes >= 3)\n      {\n        /*\n          Convert raster image to DirectClass pixel packets.\n        */\n        p=pixels;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelRed(q,ScaleCharToQuantum(*p++));\n            SetPixelGreen(q,ScaleCharToQuantum(*p++));\n            SetPixelBlue(q,ScaleCharToQuantum(*p++));\n            if (image->matte != MagickFalse)\n              SetPixelAlpha(q,ScaleCharToQuantum(*p++));\n            q++;\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      }\n    else\n      {\n        /*\n          Create colormap.\n        */\n        if (number_colormaps == 0)\n          map_length=256;\n        if (AcquireImageColormap(image,map_length) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        p=colormap;\n        if (number_colormaps == 1)\n          for (i=0; i < (ssize_t) image->colors; i++)\n          {\n            /*\n              Pseudocolor.\n            */\n            image->colormap[i].red=ScaleCharToQuantum((unsigned char) i);\n            image->colormap[i].green=ScaleCharToQuantum((unsigned char) i);\n            image->colormap[i].blue=ScaleCharToQuantum((unsigned char) i);\n          }\n        else\n          if (number_colormaps > 1)\n            for (i=0; i < (ssize_t) image->colors; i++)\n            {\n              image->colormap[i].red=ScaleCharToQuantum(*p);\n              image->colormap[i].green=ScaleCharToQuantum(*(p+map_length));\n              image->colormap[i].blue=ScaleCharToQuantum(*(p+map_length*2));\n              p++;\n            }\n        p=pixels;\n        if (image->matte == MagickFalse)\n          {\n            /*\n              Convert raster image to PseudoClass pixel packets.\n            */\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (PixelPacket *) NULL)\n                break;\n              indexes=GetAuthenticIndexQueue(image);\n              for (x=0; x < (ssize_t) image->columns; x++)\n                SetPixelIndex(indexes+x,*p++);\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            (void) SyncImage(image);\n          }\n        else\n          {\n            /*\n              Image has a matte channel-- promote to DirectClass.\n            */\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (PixelPacket *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                SetPixelRed(q,image->colormap[*p++].red);\n                SetPixelGreen(q,image->colormap[*p++].green);\n                SetPixelBlue(q,image->colormap[*p++].blue);\n                SetPixelAlpha(q,ScaleCharToQuantum(*p++));\n                q++;\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            image->colormap=(PixelPacket *) RelinquishMagickMemory(\n              image->colormap);\n            image->storage_class=DirectClass;\n            image->colors=0;\n          }\n      }\n    if (number_colormaps != 0)\n      colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    (void) ReadBlobByte(image);\n    count=ReadBlob(image,2,(unsigned char *) magick);\n    if ((count != 0) && (memcmp(magick,\"\\122\\314\",2) == 0))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while ((count != 0) && (memcmp(magick,\"\\122\\314\",2) == 0));\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 193,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2014-9665",
    "code_before_change": "  ftc_snode_load( FTC_SNode    snode,\n                  FTC_Manager  manager,\n                  FT_UInt      gindex,\n                  FT_ULong    *asize )\n  {\n    FT_Error          error;\n    FTC_GNode         gnode  = FTC_GNODE( snode );\n    FTC_Family        family = gnode->family;\n    FT_Memory         memory = manager->memory;\n    FT_Face           face;\n    FTC_SBit          sbit;\n    FTC_SFamilyClass  clazz;\n\n\n    if ( (FT_UInt)(gindex - gnode->gindex) >= snode->count )\n    {\n      FT_ERROR(( \"ftc_snode_load: invalid glyph index\" ));\n      return FT_THROW( Invalid_Argument );\n    }\n\n    sbit  = snode->sbits + ( gindex - gnode->gindex );\n    clazz = (FTC_SFamilyClass)family->clazz;\n\n    sbit->buffer = 0;\n\n    error = clazz->family_load_glyph( family, gindex, manager, &face );\n    if ( error )\n      goto BadGlyph;\n\n    {\n      FT_Int        temp;\n      FT_GlyphSlot  slot   = face->glyph;\n      FT_Bitmap*    bitmap = &slot->bitmap;\n      FT_Pos        xadvance, yadvance; /* FT_GlyphSlot->advance.{x|y} */\n\n\n      if ( slot->format != FT_GLYPH_FORMAT_BITMAP )\n      {\n        FT_TRACE0(( \"ftc_snode_load:\"\n                    \" glyph loaded didn't return a bitmap\\n\" ));\n         goto BadGlyph;\n       }\n \n      /* Check that our values fit into 8-bit containers!       */\n       /* If this is not the case, our bitmap is too large       */\n       /* and we will leave it as `missing' with sbit.buffer = 0 */\n \n#define CHECK_CHAR( d )  ( temp = (FT_Char)d, temp == d )\n#define CHECK_BYTE( d )  ( temp = (FT_Byte)d, temp == d )\n \n       /* horizontal advance in pixels */\n       xadvance = ( slot->advance.x + 32 ) >> 6;\n      yadvance = ( slot->advance.y + 32 ) >> 6;\n\n      if ( !CHECK_BYTE( bitmap->rows  )     ||\n           !CHECK_BYTE( bitmap->width )     ||\n           !CHECK_CHAR( bitmap->pitch )     ||\n           !CHECK_CHAR( slot->bitmap_left ) ||\n           !CHECK_CHAR( slot->bitmap_top  ) ||\n           !CHECK_CHAR( xadvance )          ||\n           !CHECK_CHAR( yadvance )          )\n      {\n        FT_TRACE2(( \"ftc_snode_load:\"\n                    \" glyph too large for small bitmap cache\\n\"));\n        goto BadGlyph;\n      }\n\n      sbit->width     = (FT_Byte)bitmap->width;\n      sbit->height    = (FT_Byte)bitmap->rows;\n      sbit->pitch     = (FT_Char)bitmap->pitch;\n      sbit->left      = (FT_Char)slot->bitmap_left;\n      sbit->top       = (FT_Char)slot->bitmap_top;\n      sbit->xadvance  = (FT_Char)xadvance;\n      sbit->yadvance  = (FT_Char)yadvance;\n      sbit->format    = (FT_Byte)bitmap->pixel_mode;\n      sbit->max_grays = (FT_Byte)(bitmap->num_grays - 1);\n\n      /* copy the bitmap into a new buffer -- ignore error */\n      error = ftc_sbit_copy_bitmap( sbit, bitmap, memory );\n\n      /* now, compute size */\n      if ( asize )\n        *asize = FT_ABS( sbit->pitch ) * sbit->height;\n\n    } /* glyph loading successful */\n\n    /* ignore the errors that might have occurred --   */\n    /* we mark unloaded glyphs with `sbit.buffer == 0' */\n    /* and `width == 255', `height == 0'               */\n    /*                                                 */\n    if ( error && FT_ERR_NEQ( error, Out_Of_Memory ) )\n    {\n    BadGlyph:\n      sbit->width  = 255;\n      sbit->height = 0;\n      sbit->buffer = NULL;\n      error        = FT_Err_Ok;\n      if ( asize )\n        *asize = 0;\n    }\n\n    return error;\n  }\n",
    "code_after_change": "  ftc_snode_load( FTC_SNode    snode,\n                  FTC_Manager  manager,\n                  FT_UInt      gindex,\n                  FT_ULong    *asize )\n  {\n    FT_Error          error;\n    FTC_GNode         gnode  = FTC_GNODE( snode );\n    FTC_Family        family = gnode->family;\n    FT_Memory         memory = manager->memory;\n    FT_Face           face;\n    FTC_SBit          sbit;\n    FTC_SFamilyClass  clazz;\n\n\n    if ( (FT_UInt)(gindex - gnode->gindex) >= snode->count )\n    {\n      FT_ERROR(( \"ftc_snode_load: invalid glyph index\" ));\n      return FT_THROW( Invalid_Argument );\n    }\n\n    sbit  = snode->sbits + ( gindex - gnode->gindex );\n    clazz = (FTC_SFamilyClass)family->clazz;\n\n    sbit->buffer = 0;\n\n    error = clazz->family_load_glyph( family, gindex, manager, &face );\n    if ( error )\n      goto BadGlyph;\n\n    {\n      FT_Int        temp;\n      FT_GlyphSlot  slot   = face->glyph;\n      FT_Bitmap*    bitmap = &slot->bitmap;\n      FT_Pos        xadvance, yadvance; /* FT_GlyphSlot->advance.{x|y} */\n\n\n      if ( slot->format != FT_GLYPH_FORMAT_BITMAP )\n      {\n        FT_TRACE0(( \"ftc_snode_load:\"\n                    \" glyph loaded didn't return a bitmap\\n\" ));\n         goto BadGlyph;\n       }\n \n      /* Check whether our values fit into 8-bit containers!    */\n       /* If this is not the case, our bitmap is too large       */\n       /* and we will leave it as `missing' with sbit.buffer = 0 */\n \n#define CHECK_CHAR( d )  ( temp = (FT_Char)d, (FT_Int) temp == (FT_Int) d )\n#define CHECK_BYTE( d )  ( temp = (FT_Byte)d, (FT_UInt)temp == (FT_UInt)d )\n \n       /* horizontal advance in pixels */\n       xadvance = ( slot->advance.x + 32 ) >> 6;\n      yadvance = ( slot->advance.y + 32 ) >> 6;\n\n      if ( !CHECK_BYTE( bitmap->rows  )     ||\n           !CHECK_BYTE( bitmap->width )     ||\n           !CHECK_CHAR( bitmap->pitch )     ||\n           !CHECK_CHAR( slot->bitmap_left ) ||\n           !CHECK_CHAR( slot->bitmap_top  ) ||\n           !CHECK_CHAR( xadvance )          ||\n           !CHECK_CHAR( yadvance )          )\n      {\n        FT_TRACE2(( \"ftc_snode_load:\"\n                    \" glyph too large for small bitmap cache\\n\"));\n        goto BadGlyph;\n      }\n\n      sbit->width     = (FT_Byte)bitmap->width;\n      sbit->height    = (FT_Byte)bitmap->rows;\n      sbit->pitch     = (FT_Char)bitmap->pitch;\n      sbit->left      = (FT_Char)slot->bitmap_left;\n      sbit->top       = (FT_Char)slot->bitmap_top;\n      sbit->xadvance  = (FT_Char)xadvance;\n      sbit->yadvance  = (FT_Char)yadvance;\n      sbit->format    = (FT_Byte)bitmap->pixel_mode;\n      sbit->max_grays = (FT_Byte)(bitmap->num_grays - 1);\n\n      /* copy the bitmap into a new buffer -- ignore error */\n      error = ftc_sbit_copy_bitmap( sbit, bitmap, memory );\n\n      /* now, compute size */\n      if ( asize )\n        *asize = FT_ABS( sbit->pitch ) * sbit->height;\n\n    } /* glyph loading successful */\n\n    /* ignore the errors that might have occurred --   */\n    /* we mark unloaded glyphs with `sbit.buffer == 0' */\n    /* and `width == 255', `height == 0'               */\n    /*                                                 */\n    if ( error && FT_ERR_NEQ( error, Out_Of_Memory ) )\n    {\n    BadGlyph:\n      sbit->width  = 255;\n      sbit->height = 0;\n      sbit->buffer = NULL;\n      error        = FT_Err_Ok;\n      if ( asize )\n        *asize = 0;\n    }\n\n    return error;\n  }\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 200,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2017-6194",
    "code_before_change": "static void *load_bytes(RBinFile *arch, const ut8 *buf, ut64 sz, ut64 loaddr, Sdb *sdb) {\n\tif (!buf || !sz || sz == UT64_MAX) {\n \t\treturn NULL;\n \t}\n \tRBuffer *tbuf = r_buf_new ();\n \tr_buf_set_bytes (tbuf, buf, sz);\n \tstruct r_bin_bflt_obj *res = r_bin_bflt_new_buf (tbuf);\n \tr_buf_free (tbuf);\n\treturn res ? res : NULL;\n}\n",
    "code_after_change": "static void *load_bytes(RBinFile *arch, const ut8 *buf, ut64 sz, ut64 loaddr, Sdb *sdb) {\n\tif (!buf || !sz || sz == UT64_MAX) {\n \t\treturn NULL;\n \t}\n \tRBuffer *tbuf = r_buf_new ();\n\tif (!tbuf) {\n\t\treturn NULL;\n\t}\n \tr_buf_set_bytes (tbuf, buf, sz);\n \tstruct r_bin_bflt_obj *res = r_bin_bflt_new_buf (tbuf);\n \tr_buf_free (tbuf);\n\treturn res ? res : NULL;\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 205,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-10057",
    "code_before_change": "static MagickBooleanType WriteGROUP4Image(const ImageInfo *image_info,\n  Image *image)\n{\n  char\n    filename[MaxTextExtent];\n\n  FILE\n    *file;\n\n  Image\n    *huffman_image;\n\n  ImageInfo\n    *write_info;\n\n  int\n    unique_file;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count;\n\n  TIFF\n    *tiff;\n\n  toff_t\n    *byte_count,\n    strip_size;\n\n  unsigned char\n    *buffer;\n\n  /*\n    Write image as CCITT Group4 TIFF image to a temporary file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);\n  if (status == MagickFalse)\n    return(status);\n  huffman_image=CloneImage(image,0,0,MagickTrue,&image->exception);\n  if (huffman_image == (Image *) NULL)\n    {\n      (void) CloseBlob(image);\n      return(MagickFalse);\n    }\n  huffman_image->endian=MSBEndian;\n  file=(FILE *) NULL;\n  unique_file=AcquireUniqueFileResource(filename);\n  if (unique_file != -1)\n    file=fdopen(unique_file,\"wb\");\n  if ((unique_file == -1) || (file == (FILE *) NULL))\n    {\n      ThrowFileException(&image->exception,FileOpenError,\n        \"UnableToCreateTemporaryFile\",filename);\n      return(MagickFalse);\n    }\n  (void) FormatLocaleString(huffman_image->filename,MaxTextExtent,\"tiff:%s\",\n    filename);\n   (void) SetImageType(huffman_image,BilevelType);\n   write_info=CloneImageInfo((ImageInfo *) NULL);\n   SetImageInfoFile(write_info,file);\n  (void) SetImageType(image,BilevelType);\n   (void) SetImageDepth(image,1);\n   write_info->compression=Group4Compression;\n   write_info->type=BilevelType;\n   (void) SetImageOption(write_info,\"quantum:polarity\",\"min-is-white\");\n  status=WriteTIFFImage(write_info,huffman_image);\n  (void) fflush(file);\n  write_info=DestroyImageInfo(write_info);\n  if (status == MagickFalse)\n    {\n      InheritException(&image->exception,&huffman_image->exception);\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);\n      (void) RelinquishUniqueFileResource(filename);\n      return(MagickFalse);\n    }\n  tiff=TIFFOpen(filename,\"rb\");\n  if (tiff == (TIFF *) NULL)\n    {\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);\n      (void) RelinquishUniqueFileResource(filename);\n      ThrowFileException(&image->exception,FileOpenError,\"UnableToOpenFile\",\n        image_info->filename);\n      return(MagickFalse);\n    }\n  /*\n    Allocate raw strip buffer.\n  */\n  if (TIFFGetField(tiff,TIFFTAG_STRIPBYTECOUNTS,&byte_count) != 1)\n    {\n      TIFFClose(tiff);\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);\n      (void) RelinquishUniqueFileResource(filename);\n      return(MagickFalse);\n    }\n  strip_size=byte_count[0];\n  for (i=1; i < (ssize_t) TIFFNumberOfStrips(tiff); i++)\n    if (byte_count[i] > strip_size)\n      strip_size=byte_count[i];\n  buffer=(unsigned char *) AcquireQuantumMemory((size_t) strip_size,\n    sizeof(*buffer));\n  if (buffer == (unsigned char *) NULL)\n    {\n      TIFFClose(tiff);\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);\n      (void) RelinquishUniqueFileResource(filename);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image_info->filename);\n    }\n  /*\n    Compress runlength encoded to 2D Huffman pixels.\n  */\n  for (i=0; i < (ssize_t) TIFFNumberOfStrips(tiff); i++)\n  {\n    count=(ssize_t) TIFFReadRawStrip(tiff,(uint32) i,buffer,strip_size);\n    if (WriteBlob(image,(size_t) count,buffer) != count)\n      status=MagickFalse;\n  }\n  buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n  TIFFClose(tiff);\n  huffman_image=DestroyImage(huffman_image);\n  (void) fclose(file);\n  (void) RelinquishUniqueFileResource(filename);\n  (void) CloseBlob(image);\n  return(status);\n}\n",
    "code_after_change": "static MagickBooleanType WriteGROUP4Image(const ImageInfo *image_info,\n  Image *image)\n{\n  char\n    filename[MaxTextExtent];\n\n  FILE\n    *file;\n\n  Image\n    *huffman_image;\n\n  ImageInfo\n    *write_info;\n\n  int\n    unique_file;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count;\n\n  TIFF\n    *tiff;\n\n  toff_t\n    *byte_count,\n    strip_size;\n\n  unsigned char\n    *buffer;\n\n  /*\n    Write image as CCITT Group4 TIFF image to a temporary file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);\n  if (status == MagickFalse)\n    return(status);\n  huffman_image=CloneImage(image,0,0,MagickTrue,&image->exception);\n  if (huffman_image == (Image *) NULL)\n    {\n      (void) CloseBlob(image);\n      return(MagickFalse);\n    }\n  huffman_image->endian=MSBEndian;\n  file=(FILE *) NULL;\n  unique_file=AcquireUniqueFileResource(filename);\n  if (unique_file != -1)\n    file=fdopen(unique_file,\"wb\");\n  if ((unique_file == -1) || (file == (FILE *) NULL))\n    {\n      ThrowFileException(&image->exception,FileOpenError,\n        \"UnableToCreateTemporaryFile\",filename);\n      return(MagickFalse);\n    }\n  (void) FormatLocaleString(huffman_image->filename,MaxTextExtent,\"tiff:%s\",\n    filename);\n   (void) SetImageType(huffman_image,BilevelType);\n   write_info=CloneImageInfo((ImageInfo *) NULL);\n   SetImageInfoFile(write_info,file);\n   (void) SetImageDepth(image,1);\n  (void) SetImageType(image,BilevelType);\n   write_info->compression=Group4Compression;\n   write_info->type=BilevelType;\n   (void) SetImageOption(write_info,\"quantum:polarity\",\"min-is-white\");\n  status=WriteTIFFImage(write_info,huffman_image);\n  (void) fflush(file);\n  write_info=DestroyImageInfo(write_info);\n  if (status == MagickFalse)\n    {\n      InheritException(&image->exception,&huffman_image->exception);\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);\n      (void) RelinquishUniqueFileResource(filename);\n      return(MagickFalse);\n    }\n  tiff=TIFFOpen(filename,\"rb\");\n  if (tiff == (TIFF *) NULL)\n    {\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);\n      (void) RelinquishUniqueFileResource(filename);\n      ThrowFileException(&image->exception,FileOpenError,\"UnableToOpenFile\",\n        image_info->filename);\n      return(MagickFalse);\n    }\n  /*\n    Allocate raw strip buffer.\n  */\n  if (TIFFGetField(tiff,TIFFTAG_STRIPBYTECOUNTS,&byte_count) != 1)\n    {\n      TIFFClose(tiff);\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);\n      (void) RelinquishUniqueFileResource(filename);\n      return(MagickFalse);\n    }\n  strip_size=byte_count[0];\n  for (i=1; i < (ssize_t) TIFFNumberOfStrips(tiff); i++)\n    if (byte_count[i] > strip_size)\n      strip_size=byte_count[i];\n  buffer=(unsigned char *) AcquireQuantumMemory((size_t) strip_size,\n    sizeof(*buffer));\n  if (buffer == (unsigned char *) NULL)\n    {\n      TIFFClose(tiff);\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);\n      (void) RelinquishUniqueFileResource(filename);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image_info->filename);\n    }\n  /*\n    Compress runlength encoded to 2D Huffman pixels.\n  */\n  for (i=0; i < (ssize_t) TIFFNumberOfStrips(tiff); i++)\n  {\n    count=(ssize_t) TIFFReadRawStrip(tiff,(uint32) i,buffer,strip_size);\n    if (WriteBlob(image,(size_t) count,buffer) != count)\n      status=MagickFalse;\n  }\n  buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n  TIFFClose(tiff);\n  huffman_image=DestroyImage(huffman_image);\n  (void) fclose(file);\n  (void) RelinquishUniqueFileResource(filename);\n  (void) CloseBlob(image);\n  return(status);\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 207,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2013-1788",
    "code_before_change": "void Splash::vertFlipImage(SplashBitmap *img, int width, int height,\n\t\t\t   int nComps) {\n  Guchar *lineBuf;\n  Guchar *p0, *p1;\n  int w;\n\n  w = width * nComps;\n   Guchar *lineBuf;\n   Guchar *p0, *p1;\n   int w;\n \n   w = width * nComps;\n   lineBuf = (Guchar *)gmalloc(w);\n\t p0 += width, p1 -= width) {\n      memcpy(lineBuf, p0, width);\n      memcpy(p0, p1, width);\n      memcpy(p1, lineBuf, width);\n    }\n  }\n",
    "code_after_change": "void Splash::vertFlipImage(SplashBitmap *img, int width, int height,\n\t\t\t   int nComps) {\n  Guchar *lineBuf;\n  Guchar *p0, *p1;\n  int w;\n\n  w = width * nComps;\n   Guchar *lineBuf;\n   Guchar *p0, *p1;\n   int w;\n  \n  if (unlikely(img->data == NULL)) {\n    error(errInternal, -1, \"img->data is NULL in Splash::vertFlipImage\");\n    return;\n  }\n \n   w = width * nComps;\n   lineBuf = (Guchar *)gmalloc(w);\n\t p0 += width, p1 -= width) {\n      memcpy(lineBuf, p0, width);\n      memcpy(p0, p1, width);\n      memcpy(p1, lineBuf, width);\n    }\n  }\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 214,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2018-6094",
    "code_before_change": "bool HeapAllocator::backingExpand(void* address, size_t newSize) {\n  if (!address)\n    return false;\n\n  ThreadState* state = ThreadState::current();\n  if (state->sweepForbidden())\n    return false;\n  ASSERT(!state->isInGC());\n  ASSERT(state->isAllocationAllowed());\n  DCHECK_EQ(&state->heap(), &ThreadState::fromObject(address)->heap());\n\n  BasePage* page = pageFromObject(address);\n  if (page->isLargeObjectPage() || page->arena()->getThreadState() != state)\n     return false;\n \n   HeapObjectHeader* header = HeapObjectHeader::fromPayload(address);\n  ASSERT(header->checkHeader());\n   NormalPageArena* arena = static_cast<NormalPage*>(page)->arenaForNormalPage();\n   bool succeed = arena->expandObject(header, newSize);\n   if (succeed)\n    state->allocationPointAdjusted(arena->arenaIndex());\n  return succeed;\n}\n",
    "code_after_change": "bool HeapAllocator::backingExpand(void* address, size_t newSize) {\n  if (!address)\n    return false;\n\n  ThreadState* state = ThreadState::current();\n  if (state->sweepForbidden())\n    return false;\n  ASSERT(!state->isInGC());\n  ASSERT(state->isAllocationAllowed());\n  DCHECK_EQ(&state->heap(), &ThreadState::fromObject(address)->heap());\n\n  BasePage* page = pageFromObject(address);\n  if (page->isLargeObjectPage() || page->arena()->getThreadState() != state)\n     return false;\n \n   HeapObjectHeader* header = HeapObjectHeader::fromPayload(address);\n  header->checkHeader();\n   NormalPageArena* arena = static_cast<NormalPage*>(page)->arenaForNormalPage();\n   bool succeed = arena->expandObject(header, newSize);\n   if (succeed)\n    state->allocationPointAdjusted(arena->arenaIndex());\n  return succeed;\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 229,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-10066",
    "code_before_change": "static Image *ReadFITSImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  typedef struct _FITSInfo\n  {\n    MagickBooleanType\n      extend,\n      simple;\n\n    int\n      bits_per_pixel,\n      columns,\n      rows,\n      number_axes,\n      number_planes;\n\n    double\n      min_data,\n      max_data,\n      zero,\n      scale;\n\n    EndianType\n      endian;\n  } FITSInfo;\n\n  char\n    *comment,\n    keyword[9],\n    property[MaxTextExtent],\n    value[73];\n\n  double\n    pixel,\n    scale;\n\n  FITSInfo\n    fits_info;\n\n  Image\n    *image;\n\n  int\n    c;\n\n  MagickBooleanType\n    status;\n\n  MagickSizeType\n    number_pixels;\n\n  register ssize_t\n    i,\n    x;\n\n  register PixelPacket\n    *q;\n\n  ssize_t\n    count,\n    scene,\n    y;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Initialize image header.\n  */\n  (void) ResetMagickMemory(&fits_info,0,sizeof(fits_info));\n  fits_info.extend=MagickFalse;\n  fits_info.simple=MagickFalse;\n  fits_info.bits_per_pixel=8;\n  fits_info.columns=1;\n  fits_info.rows=1;\n  fits_info.rows=1;\n  fits_info.number_planes=1;\n  fits_info.min_data=0.0;\n  fits_info.max_data=0.0;\n  fits_info.zero=0.0;\n  fits_info.scale=1.0;\n  fits_info.endian=MSBEndian;\n  /*\n    Decode image header.\n  */\n  for (comment=(char *) NULL; EOFBlob(image) == MagickFalse; )\n  {\n    for ( ; EOFBlob(image) == MagickFalse; )\n    {\n      register char\n        *p;\n\n      count=ReadBlob(image,8,(unsigned char *) keyword);\n      if (count != 8)\n        break;\n      for (i=0; i < 8; i++)\n      {\n        if (isspace((int) ((unsigned char) keyword[i])) != 0)\n          break;\n        keyword[i]=tolower((int) ((unsigned char) keyword[i]));\n      }\n      keyword[i]='\\0';\n      count=ReadBlob(image,72,(unsigned char *) value);\n      value[72]='\\0';\n      if (count != 72)\n        break;\n      p=value;\n      if (*p == '=')\n        {\n          p+=2;\n          while (isspace((int) ((unsigned char) *p)) != 0)\n            p++;\n        }\n      if (LocaleCompare(keyword,\"end\") == 0)\n        break;\n      if (LocaleCompare(keyword,\"extend\") == 0)\n        fits_info.extend=(*p == 'T') || (*p == 't') ? MagickTrue : MagickFalse;\n      if (LocaleCompare(keyword,\"simple\") == 0)\n        fits_info.simple=(*p == 'T') || (*p == 't') ? MagickTrue : MagickFalse;\n      if (LocaleCompare(keyword,\"bitpix\") == 0)\n        fits_info.bits_per_pixel=StringToLong(p);\n      if (LocaleCompare(keyword,\"naxis\") == 0)\n        fits_info.number_axes=StringToLong(p);\n      if (LocaleCompare(keyword,\"naxis1\") == 0)\n        fits_info.columns=StringToLong(p);\n      if (LocaleCompare(keyword,\"naxis2\") == 0)\n        fits_info.rows=StringToLong(p);\n      if (LocaleCompare(keyword,\"naxis3\") == 0)\n        fits_info.number_planes=StringToLong(p);\n      if (LocaleCompare(keyword,\"datamax\") == 0)\n        fits_info.max_data=StringToDouble(p,(char **) NULL);\n      if (LocaleCompare(keyword,\"datamin\") == 0)\n        fits_info.min_data=StringToDouble(p,(char **) NULL);\n      if (LocaleCompare(keyword,\"bzero\") == 0)\n        fits_info.zero=StringToDouble(p,(char **) NULL);\n      if (LocaleCompare(keyword,\"bscale\") == 0)\n        fits_info.scale=StringToDouble(p,(char **) NULL);\n      if (LocaleCompare(keyword,\"comment\") == 0)\n        {\n          if (comment == (char *) NULL)\n            comment=ConstantString(p);\n          else\n            (void) ConcatenateString(&comment,p);\n        }\n      if (LocaleCompare(keyword,\"xendian\") == 0)\n        {\n          if (LocaleNCompare(p,\"big\",3) == 0)\n            fits_info.endian=MSBEndian;\n          else\n            fits_info.endian=LSBEndian;\n        }\n      (void) FormatLocaleString(property,MaxTextExtent,\"fits:%s\",keyword);\n      (void) SetImageProperty(image,property,p);\n    }\n    c=0;\n    while (((TellBlob(image) % FITSBlocksize) != 0) && (c != EOF))\n      c=ReadBlobByte(image);\n    if (fits_info.extend == MagickFalse)\n      break;\n    number_pixels=(MagickSizeType) fits_info.columns*fits_info.rows;\n    if ((fits_info.simple != MagickFalse) && (fits_info.number_axes >= 1) &&\n        (fits_info.number_axes <= 4) && (number_pixels != 0))\n      break;\n  }\n  /*\n    Verify that required image information is defined.\n  */\n  if (comment != (char *) NULL)\n    {\n      (void) SetImageProperty(image,\"comment\",comment);\n      comment=DestroyString(comment);\n    }\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  number_pixels=(MagickSizeType) fits_info.columns*fits_info.rows;\n  if ((fits_info.simple == MagickFalse) || (fits_info.number_axes < 1) ||\n      (fits_info.number_axes > 4) || (number_pixels == 0))\n    ThrowReaderException(CorruptImageError,\"ImageTypeNotSupported\");\n  for (scene=0; scene < (ssize_t) fits_info.number_planes; scene++)\n  {\n    image->columns=(size_t) fits_info.columns;\n    image->rows=(size_t) fits_info.rows;\n    image->depth=(size_t) (fits_info.bits_per_pixel < 0 ? -1 : 1)*\n      fits_info.bits_per_pixel;\n    image->endian=fits_info.endian;\n    image->scene=(size_t) scene;\n     if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n       if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n         break;\n     /*\n       Initialize image structure.\n     */\n    (void) SetImageColorspace(image,GRAYColorspace);\n    if ((fits_info.min_data == 0.0) && (fits_info.max_data == 0.0))\n      {\n        if (fits_info.zero == 0.0)\n          (void) GetFITSPixelExtrema(image,fits_info.bits_per_pixel,\n            &fits_info.min_data,&fits_info.max_data);\n        else\n          fits_info.max_data=GetFITSPixelRange((size_t)\n            fits_info.bits_per_pixel);\n      }\n    else\n      fits_info.max_data=GetFITSPixelRange((size_t) fits_info.bits_per_pixel);\n    /*\n      Convert FITS pixels to pixel packets.\n    */\n    scale=QuantumRange/(fits_info.max_data-fits_info.min_data);\n    for (y=(ssize_t) image->rows-1; y >= 0; y--)\n    {\n      q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n      if (q == (PixelPacket *) NULL)\n        break;\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        pixel=GetFITSPixel(image,fits_info.bits_per_pixel);\n        if ((image->depth == 16) || (image->depth == 32) ||\n            (image->depth == 64))\n          SetFITSUnsignedPixels(1,image->depth,image->endian,(unsigned char *)\n            &pixel);\n        SetPixelRed(q,ClampToQuantum(scale*(fits_info.scale*(pixel-\n          fits_info.min_data)+fits_info.zero)));\n        SetPixelGreen(q,GetPixelRed(q));\n        SetPixelBlue(q,GetPixelRed(q));\n        q++;\n      }\n      if (SyncAuthenticPixels(image,exception) == MagickFalse)\n        break;\n      if (image->previous == (Image *) NULL)\n        {\n          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n    }\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if (scene < (ssize_t) (fits_info.number_planes-1))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n",
    "code_after_change": "static Image *ReadFITSImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  typedef struct _FITSInfo\n  {\n    MagickBooleanType\n      extend,\n      simple;\n\n    int\n      bits_per_pixel,\n      columns,\n      rows,\n      number_axes,\n      number_planes;\n\n    double\n      min_data,\n      max_data,\n      zero,\n      scale;\n\n    EndianType\n      endian;\n  } FITSInfo;\n\n  char\n    *comment,\n    keyword[9],\n    property[MaxTextExtent],\n    value[73];\n\n  double\n    pixel,\n    scale;\n\n  FITSInfo\n    fits_info;\n\n  Image\n    *image;\n\n  int\n    c;\n\n  MagickBooleanType\n    status;\n\n  MagickSizeType\n    number_pixels;\n\n  register ssize_t\n    i,\n    x;\n\n  register PixelPacket\n    *q;\n\n  ssize_t\n    count,\n    scene,\n    y;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Initialize image header.\n  */\n  (void) ResetMagickMemory(&fits_info,0,sizeof(fits_info));\n  fits_info.extend=MagickFalse;\n  fits_info.simple=MagickFalse;\n  fits_info.bits_per_pixel=8;\n  fits_info.columns=1;\n  fits_info.rows=1;\n  fits_info.rows=1;\n  fits_info.number_planes=1;\n  fits_info.min_data=0.0;\n  fits_info.max_data=0.0;\n  fits_info.zero=0.0;\n  fits_info.scale=1.0;\n  fits_info.endian=MSBEndian;\n  /*\n    Decode image header.\n  */\n  for (comment=(char *) NULL; EOFBlob(image) == MagickFalse; )\n  {\n    for ( ; EOFBlob(image) == MagickFalse; )\n    {\n      register char\n        *p;\n\n      count=ReadBlob(image,8,(unsigned char *) keyword);\n      if (count != 8)\n        break;\n      for (i=0; i < 8; i++)\n      {\n        if (isspace((int) ((unsigned char) keyword[i])) != 0)\n          break;\n        keyword[i]=tolower((int) ((unsigned char) keyword[i]));\n      }\n      keyword[i]='\\0';\n      count=ReadBlob(image,72,(unsigned char *) value);\n      value[72]='\\0';\n      if (count != 72)\n        break;\n      p=value;\n      if (*p == '=')\n        {\n          p+=2;\n          while (isspace((int) ((unsigned char) *p)) != 0)\n            p++;\n        }\n      if (LocaleCompare(keyword,\"end\") == 0)\n        break;\n      if (LocaleCompare(keyword,\"extend\") == 0)\n        fits_info.extend=(*p == 'T') || (*p == 't') ? MagickTrue : MagickFalse;\n      if (LocaleCompare(keyword,\"simple\") == 0)\n        fits_info.simple=(*p == 'T') || (*p == 't') ? MagickTrue : MagickFalse;\n      if (LocaleCompare(keyword,\"bitpix\") == 0)\n        fits_info.bits_per_pixel=StringToLong(p);\n      if (LocaleCompare(keyword,\"naxis\") == 0)\n        fits_info.number_axes=StringToLong(p);\n      if (LocaleCompare(keyword,\"naxis1\") == 0)\n        fits_info.columns=StringToLong(p);\n      if (LocaleCompare(keyword,\"naxis2\") == 0)\n        fits_info.rows=StringToLong(p);\n      if (LocaleCompare(keyword,\"naxis3\") == 0)\n        fits_info.number_planes=StringToLong(p);\n      if (LocaleCompare(keyword,\"datamax\") == 0)\n        fits_info.max_data=StringToDouble(p,(char **) NULL);\n      if (LocaleCompare(keyword,\"datamin\") == 0)\n        fits_info.min_data=StringToDouble(p,(char **) NULL);\n      if (LocaleCompare(keyword,\"bzero\") == 0)\n        fits_info.zero=StringToDouble(p,(char **) NULL);\n      if (LocaleCompare(keyword,\"bscale\") == 0)\n        fits_info.scale=StringToDouble(p,(char **) NULL);\n      if (LocaleCompare(keyword,\"comment\") == 0)\n        {\n          if (comment == (char *) NULL)\n            comment=ConstantString(p);\n          else\n            (void) ConcatenateString(&comment,p);\n        }\n      if (LocaleCompare(keyword,\"xendian\") == 0)\n        {\n          if (LocaleNCompare(p,\"big\",3) == 0)\n            fits_info.endian=MSBEndian;\n          else\n            fits_info.endian=LSBEndian;\n        }\n      (void) FormatLocaleString(property,MaxTextExtent,\"fits:%s\",keyword);\n      (void) SetImageProperty(image,property,p);\n    }\n    c=0;\n    while (((TellBlob(image) % FITSBlocksize) != 0) && (c != EOF))\n      c=ReadBlobByte(image);\n    if (fits_info.extend == MagickFalse)\n      break;\n    number_pixels=(MagickSizeType) fits_info.columns*fits_info.rows;\n    if ((fits_info.simple != MagickFalse) && (fits_info.number_axes >= 1) &&\n        (fits_info.number_axes <= 4) && (number_pixels != 0))\n      break;\n  }\n  /*\n    Verify that required image information is defined.\n  */\n  if (comment != (char *) NULL)\n    {\n      (void) SetImageProperty(image,\"comment\",comment);\n      comment=DestroyString(comment);\n    }\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  number_pixels=(MagickSizeType) fits_info.columns*fits_info.rows;\n  if ((fits_info.simple == MagickFalse) || (fits_info.number_axes < 1) ||\n      (fits_info.number_axes > 4) || (number_pixels == 0))\n    ThrowReaderException(CorruptImageError,\"ImageTypeNotSupported\");\n  for (scene=0; scene < (ssize_t) fits_info.number_planes; scene++)\n  {\n    image->columns=(size_t) fits_info.columns;\n    image->rows=(size_t) fits_info.rows;\n    image->depth=(size_t) (fits_info.bits_per_pixel < 0 ? -1 : 1)*\n      fits_info.bits_per_pixel;\n    image->endian=fits_info.endian;\n    image->scene=(size_t) scene;\n     if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n       if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n         break;\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n     /*\n       Initialize image structure.\n     */\n    (void) SetImageColorspace(image,GRAYColorspace);\n    if ((fits_info.min_data == 0.0) && (fits_info.max_data == 0.0))\n      {\n        if (fits_info.zero == 0.0)\n          (void) GetFITSPixelExtrema(image,fits_info.bits_per_pixel,\n            &fits_info.min_data,&fits_info.max_data);\n        else\n          fits_info.max_data=GetFITSPixelRange((size_t)\n            fits_info.bits_per_pixel);\n      }\n    else\n      fits_info.max_data=GetFITSPixelRange((size_t) fits_info.bits_per_pixel);\n    /*\n      Convert FITS pixels to pixel packets.\n    */\n    scale=QuantumRange/(fits_info.max_data-fits_info.min_data);\n    for (y=(ssize_t) image->rows-1; y >= 0; y--)\n    {\n      q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n      if (q == (PixelPacket *) NULL)\n        break;\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        pixel=GetFITSPixel(image,fits_info.bits_per_pixel);\n        if ((image->depth == 16) || (image->depth == 32) ||\n            (image->depth == 64))\n          SetFITSUnsignedPixels(1,image->depth,image->endian,(unsigned char *)\n            &pixel);\n        SetPixelRed(q,ClampToQuantum(scale*(fits_info.scale*(pixel-\n          fits_info.min_data)+fits_info.zero)));\n        SetPixelGreen(q,GetPixelRed(q));\n        SetPixelBlue(q,GetPixelRed(q));\n        q++;\n      }\n      if (SyncAuthenticPixels(image,exception) == MagickFalse)\n        break;\n      if (image->previous == (Image *) NULL)\n        {\n          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n    }\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if (scene < (ssize_t) (fits_info.number_planes-1))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 238,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2018-7186",
    "code_before_change": " gplotRead(const char  *filename)\n {\nchar     buf[L_BUF_SIZE];\n char    *rootname, *title, *xlabel, *ylabel, *ignores;\n l_int32  outformat, ret, version, ignore;\n FILE    *fp;\nGPLOT   *gplot;\n\n    PROCNAME(\"gplotRead\");\n\n    if (!filename)\n        return (GPLOT *)ERROR_PTR(\"filename not defined\", procName, NULL);\n\n    if ((fp = fopenReadStream(filename)) == NULL)\n        return (GPLOT *)ERROR_PTR(\"stream not opened\", procName, NULL);\n\n    ret = fscanf(fp, \"Gplot Version %d\\n\", &version);\n    if (ret != 1) {\n        fclose(fp);\n        return (GPLOT *)ERROR_PTR(\"not a gplot file\", procName, NULL);\n    }\n    if (version != GPLOT_VERSION_NUMBER) {\n        fclose(fp);\n         return (GPLOT *)ERROR_PTR(\"invalid gplot version\", procName, NULL);\n     }\n \n    ignore = fscanf(fp, \"Rootname: %s\\n\", buf);\n     rootname = stringNew(buf);\n     ignore = fscanf(fp, \"Output format: %d\\n\", &outformat);\n    ignores = fgets(buf, L_BUF_SIZE, fp);   /* Title: ... */\n     title = stringNew(buf + 7);\n     title[strlen(title) - 1] = '\\0';\n    ignores = fgets(buf, L_BUF_SIZE, fp);   /* X axis label: ... */\n     xlabel = stringNew(buf + 14);\n     xlabel[strlen(xlabel) - 1] = '\\0';\n    ignores = fgets(buf, L_BUF_SIZE, fp);   /* Y axis label: ... */\n     ylabel = stringNew(buf + 14);\n     ylabel[strlen(ylabel) - 1] = '\\0';\n \n    gplot = gplotCreate(rootname, outformat, title, xlabel, ylabel);\n    LEPT_FREE(rootname);\n    LEPT_FREE(title);\n    LEPT_FREE(xlabel);\n    LEPT_FREE(ylabel);\n    if (!gplot) {\n        fclose(fp);\n        return (GPLOT *)ERROR_PTR(\"gplot not made\", procName, NULL);\n    }\n    sarrayDestroy(&gplot->cmddata);\n    sarrayDestroy(&gplot->datanames);\n    sarrayDestroy(&gplot->plotdata);\n     sarrayDestroy(&gplot->plottitles);\n     numaDestroy(&gplot->plotstyles);\n \n    ignore = fscanf(fp, \"Commandfile name: %s\\n\", buf);\n     stringReplace(&gplot->cmdname, buf);\n     ignore = fscanf(fp, \"\\nCommandfile data:\");\n     gplot->cmddata = sarrayReadStream(fp);\n    ignore = fscanf(fp, \"\\nDatafile names:\");\n    gplot->datanames = sarrayReadStream(fp);\n    ignore = fscanf(fp, \"\\nPlot data:\");\n    gplot->plotdata = sarrayReadStream(fp);\n    ignore = fscanf(fp, \"\\nPlot titles:\");\n    gplot->plottitles = sarrayReadStream(fp);\n    ignore = fscanf(fp, \"\\nPlot styles:\");\n     gplot->plotstyles = numaReadStream(fp);\n \n     ignore = fscanf(fp, \"Number of plots: %d\\n\", &gplot->nplots);\n    ignore = fscanf(fp, \"Output file name: %s\\n\", buf);\n     stringReplace(&gplot->outname, buf);\n     ignore = fscanf(fp, \"Axis scaling: %d\\n\", &gplot->scaling);\n \n    fclose(fp);\n    return gplot;\n}\n",
    "code_after_change": " gplotRead(const char  *filename)\n {\nchar     buf[L_BUFSIZE];\n char    *rootname, *title, *xlabel, *ylabel, *ignores;\n l_int32  outformat, ret, version, ignore;\n FILE    *fp;\nGPLOT   *gplot;\n\n    PROCNAME(\"gplotRead\");\n\n    if (!filename)\n        return (GPLOT *)ERROR_PTR(\"filename not defined\", procName, NULL);\n\n    if ((fp = fopenReadStream(filename)) == NULL)\n        return (GPLOT *)ERROR_PTR(\"stream not opened\", procName, NULL);\n\n    ret = fscanf(fp, \"Gplot Version %d\\n\", &version);\n    if (ret != 1) {\n        fclose(fp);\n        return (GPLOT *)ERROR_PTR(\"not a gplot file\", procName, NULL);\n    }\n    if (version != GPLOT_VERSION_NUMBER) {\n        fclose(fp);\n         return (GPLOT *)ERROR_PTR(\"invalid gplot version\", procName, NULL);\n     }\n \n    ignore = fscanf(fp, \"Rootname: %511s\\n\", buf);  /* L_BUFSIZE - 1 */\n     rootname = stringNew(buf);\n     ignore = fscanf(fp, \"Output format: %d\\n\", &outformat);\n    ignores = fgets(buf, L_BUFSIZE, fp);   /* Title: ... */\n     title = stringNew(buf + 7);\n     title[strlen(title) - 1] = '\\0';\n    ignores = fgets(buf, L_BUFSIZE, fp);   /* X axis label: ... */\n     xlabel = stringNew(buf + 14);\n     xlabel[strlen(xlabel) - 1] = '\\0';\n    ignores = fgets(buf, L_BUFSIZE, fp);   /* Y axis label: ... */\n     ylabel = stringNew(buf + 14);\n     ylabel[strlen(ylabel) - 1] = '\\0';\n \n    gplot = gplotCreate(rootname, outformat, title, xlabel, ylabel);\n    LEPT_FREE(rootname);\n    LEPT_FREE(title);\n    LEPT_FREE(xlabel);\n    LEPT_FREE(ylabel);\n    if (!gplot) {\n        fclose(fp);\n        return (GPLOT *)ERROR_PTR(\"gplot not made\", procName, NULL);\n    }\n    sarrayDestroy(&gplot->cmddata);\n    sarrayDestroy(&gplot->datanames);\n    sarrayDestroy(&gplot->plotdata);\n     sarrayDestroy(&gplot->plottitles);\n     numaDestroy(&gplot->plotstyles);\n \n    ignore = fscanf(fp, \"Commandfile name: %511s\\n\", buf);  /* L_BUFSIZE - 1 */\n     stringReplace(&gplot->cmdname, buf);\n     ignore = fscanf(fp, \"\\nCommandfile data:\");\n     gplot->cmddata = sarrayReadStream(fp);\n    ignore = fscanf(fp, \"\\nDatafile names:\");\n    gplot->datanames = sarrayReadStream(fp);\n    ignore = fscanf(fp, \"\\nPlot data:\");\n    gplot->plotdata = sarrayReadStream(fp);\n    ignore = fscanf(fp, \"\\nPlot titles:\");\n    gplot->plottitles = sarrayReadStream(fp);\n    ignore = fscanf(fp, \"\\nPlot styles:\");\n     gplot->plotstyles = numaReadStream(fp);\n \n     ignore = fscanf(fp, \"Number of plots: %d\\n\", &gplot->nplots);\n    ignore = fscanf(fp, \"Output file name: %511s\\n\", buf);\n     stringReplace(&gplot->outname, buf);\n     ignore = fscanf(fp, \"Axis scaling: %d\\n\", &gplot->scaling);\n \n    fclose(fp);\n    return gplot;\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 240,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2017-15398",
    "code_before_change": "void QuicClientPromisedInfo::OnPromiseHeaders(const SpdyHeaderBlock& headers) {\n   SpdyHeaderBlock::const_iterator it = headers.find(kHttp2MethodHeader);\n  DCHECK(it != headers.end());\n   if (!(it->second == \"GET\" || it->second == \"HEAD\")) {\n     QUIC_DVLOG(1) << \"Promise for stream \" << id_ << \" has invalid method \"\n                   << it->second;\n    Reset(QUIC_INVALID_PROMISE_METHOD);\n    return;\n  }\n  if (!SpdyUtils::UrlIsValid(headers)) {\n    QUIC_DVLOG(1) << \"Promise for stream \" << id_ << \" has invalid URL \"\n                  << url_;\n    Reset(QUIC_INVALID_PROMISE_URL);\n    return;\n  }\n  if (!session_->IsAuthorized(SpdyUtils::GetHostNameFromHeaderBlock(headers))) {\n    Reset(QUIC_UNAUTHORIZED_PROMISE_URL);\n    return;\n  }\n  request_headers_.reset(new SpdyHeaderBlock(headers.Clone()));\n}\n",
    "code_after_change": "void QuicClientPromisedInfo::OnPromiseHeaders(const SpdyHeaderBlock& headers) {\n   SpdyHeaderBlock::const_iterator it = headers.find(kHttp2MethodHeader);\n  if (it == headers.end()) {\n    QUIC_DVLOG(1) << \"Promise for stream \" << id_ << \" has no method\";\n    Reset(QUIC_INVALID_PROMISE_METHOD);\n    return;\n  }\n   if (!(it->second == \"GET\" || it->second == \"HEAD\")) {\n     QUIC_DVLOG(1) << \"Promise for stream \" << id_ << \" has invalid method \"\n                   << it->second;\n    Reset(QUIC_INVALID_PROMISE_METHOD);\n    return;\n  }\n  if (!SpdyUtils::UrlIsValid(headers)) {\n    QUIC_DVLOG(1) << \"Promise for stream \" << id_ << \" has invalid URL \"\n                  << url_;\n    Reset(QUIC_INVALID_PROMISE_URL);\n    return;\n  }\n  if (!session_->IsAuthorized(SpdyUtils::GetHostNameFromHeaderBlock(headers))) {\n    Reset(QUIC_UNAUTHORIZED_PROMISE_URL);\n    return;\n  }\n  request_headers_.reset(new SpdyHeaderBlock(headers.Clone()));\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 242,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2015-8631",
    "code_before_change": " getprivs_ret * get_privs_2_svc(krb5_ui_4 *arg, struct svc_req *rqstp)\n {\n     static getprivs_ret            ret;\n    gss_buffer_desc                client_name, service_name;\n     OM_uint32                      minor_stat;\n     kadm5_server_handle_t          handle;\n     const char                     *errmsg = NULL;\n\n    xdr_free(xdr_getprivs_ret, &ret);\n\n    if ((ret.code = new_server_handle(*arg, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n\n    ret.code = kadm5_get_privs((void *)handle, &ret.privs);\n    if( ret.code != 0 )\n        errmsg = krb5_get_error_message(handle->context, ret.code);\n\n    log_done(\"kadm5_get_privs\", client_name.value, errmsg,\n             &client_name, &service_name, rqstp);\n\n     if (errmsg != NULL)\n         krb5_free_error_message(handle->context, errmsg);\n \n     gss_release_buffer(&minor_stat, &client_name);\n     gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n     free_server_handle(handle);\n     return &ret;\n }\n",
    "code_after_change": " getprivs_ret * get_privs_2_svc(krb5_ui_4 *arg, struct svc_req *rqstp)\n {\n     static getprivs_ret            ret;\n    gss_buffer_desc                client_name = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc                service_name = GSS_C_EMPTY_BUFFER;\n     OM_uint32                      minor_stat;\n     kadm5_server_handle_t          handle;\n     const char                     *errmsg = NULL;\n\n    xdr_free(xdr_getprivs_ret, &ret);\n\n    if ((ret.code = new_server_handle(*arg, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n\n    ret.code = kadm5_get_privs((void *)handle, &ret.privs);\n    if( ret.code != 0 )\n        errmsg = krb5_get_error_message(handle->context, ret.code);\n\n    log_done(\"kadm5_get_privs\", client_name.value, errmsg,\n             &client_name, &service_name, rqstp);\n\n     if (errmsg != NULL)\n         krb5_free_error_message(handle->context, errmsg);\n \nexit_func:\n     gss_release_buffer(&minor_stat, &client_name);\n     gss_release_buffer(&minor_stat, &service_name);\n     free_server_handle(handle);\n     return &ret;\n }\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 250,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2011-2850",
    "code_before_change": " void P2PSocketDispatcherHost::OnAcceptIncomingTcpConnection(\n     const IPC::Message& msg, int listen_socket_id,\n    net::IPEndPoint remote_address, int connected_socket_id) {\n   P2PSocketHost* socket = LookupSocket(msg.routing_id(), listen_socket_id);\n   if (!socket) {\n     LOG(ERROR) << \"Received P2PHostMsg_AcceptIncomingTcpConnection \"\n        \"for invalid socket_id.\";\n    return;\n  }\n  P2PSocketHost* accepted_connection =\n      socket->AcceptIncomingTcpConnection(remote_address, connected_socket_id);\n  if (accepted_connection) {\n    sockets_.insert(std::pair<ExtendedSocketId, P2PSocketHost*>(\n        ExtendedSocketId(msg.routing_id(), connected_socket_id),\n        accepted_connection));\n  }\n}\n",
    "code_after_change": " void P2PSocketDispatcherHost::OnAcceptIncomingTcpConnection(\n     const IPC::Message& msg, int listen_socket_id,\n    const net::IPEndPoint& remote_address, int connected_socket_id) {\n   P2PSocketHost* socket = LookupSocket(msg.routing_id(), listen_socket_id);\n   if (!socket) {\n     LOG(ERROR) << \"Received P2PHostMsg_AcceptIncomingTcpConnection \"\n        \"for invalid socket_id.\";\n    return;\n  }\n  P2PSocketHost* accepted_connection =\n      socket->AcceptIncomingTcpConnection(remote_address, connected_socket_id);\n  if (accepted_connection) {\n    sockets_.insert(std::pair<ExtendedSocketId, P2PSocketHost*>(\n        ExtendedSocketId(msg.routing_id(), connected_socket_id),\n        accepted_connection));\n  }\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 254,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-1621",
    "code_before_change": "const Cluster* Segment::FindOrPreloadCluster(long long requested_pos)\n{\n    if (requested_pos < 0)\n        return 0;\n \n    Cluster** const ii = m_clusters;\n    Cluster** i = ii;\n \n    const long count = m_clusterCount + m_clusterPreloadCount;\n \n    Cluster** const jj = ii + count;\n    Cluster** j = jj;\n \n    while (i < j)\n    {\n \n        Cluster** const k = i + (j - i) / 2;\n        assert(k < jj);\n        Cluster* const pCluster = *k;\n        assert(pCluster);\n        const long long pos = pCluster->GetPosition();\n        assert(pos >= 0);\n        if (pos < requested_pos)\n            i = k + 1;\n        else if (pos > requested_pos)\n            j = k;\n        else\n            return pCluster;\n    }\n    assert(i == j);\n    Cluster* const pCluster = Cluster::Create(\n                                this,\n                                -1,\n                                requested_pos);\n     assert(pCluster);\n \n    const ptrdiff_t idx = i - m_clusters;\n \n    PreloadCluster(pCluster, idx);\n    assert(m_clusters);\n    assert(m_clusterPreloadCount > 0);\n    assert(m_clusters[idx] == pCluster);\n \n    return pCluster;\n }\n",
    "code_after_change": "const Cluster* Segment::FindOrPreloadCluster(long long requested_pos)\n  Cluster** const ii = m_clusters;\n  Cluster** i = ii;\n \n  const long count = m_clusterCount + m_clusterPreloadCount;\n \n  Cluster** const jj = ii + count;\n  Cluster** j = jj;\n \n  while (i < j) {\n    // INVARIANT:\n    //[ii, i) < pTP->m_pos\n    //[i, j) ?\n    //[j, jj)  > pTP->m_pos\n \n    Cluster** const k = i + (j - i) / 2;\n    assert(k < jj);\n \n    Cluster* const pCluster = *k;\n     assert(pCluster);\n \n    // const long long pos_ = pCluster->m_pos;\n    // assert(pos_);\n    // const long long pos = pos_ * ((pos_ < 0) ? -1 : 1);\n \n    const long long pos = pCluster->GetPosition();\n    assert(pos >= 0);\n \n    if (pos < requested_pos)\n      i = k + 1;\n    else if (pos > requested_pos)\n      j = k;\n    else\n      return pCluster;\n  }\n\n  assert(i == j);\n  // assert(Cluster::HasBlockEntries(this, tp.m_pos));\n\n  Cluster* const pCluster = Cluster::Create(this, -1, requested_pos);\n  //-1);\n  assert(pCluster);\n\n  const ptrdiff_t idx = i - m_clusters;\n\n  PreloadCluster(pCluster, idx);\n  assert(m_clusters);\n  assert(m_clusterPreloadCount > 0);\n  assert(m_clusters[idx] == pCluster);\n\n  return pCluster;\n }\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 256,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-10067",
    "code_before_change": "MagickExport MemoryInfo *AcquireVirtualMemory(const size_t count,\n  const size_t quantum)\n{\n  MemoryInfo\n    *memory_info;\n\n   size_t\n     extent;\n \n  if (CheckMemoryOverflow(count,quantum) != MagickFalse)\n     return((MemoryInfo *) NULL);\n   memory_info=(MemoryInfo *) MagickAssumeAligned(AcquireAlignedMemory(1,\n     sizeof(*memory_info)));\n  if (memory_info == (MemoryInfo *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  (void) ResetMagickMemory(memory_info,0,sizeof(*memory_info));\n  extent=count*quantum;\n  memory_info->length=extent;\n  memory_info->signature=MagickSignature;\n  if (AcquireMagickResource(MemoryResource,extent) != MagickFalse)\n    {\n      memory_info->blob=AcquireAlignedMemory(1,extent);\n      if (memory_info->blob != NULL)\n        {\n          memory_info->type=AlignedVirtualMemory;\n          return(memory_info);\n        }\n    }\n  RelinquishMagickResource(MemoryResource,extent);\n  if (AcquireMagickResource(MapResource,extent) != MagickFalse)\n    {\n      /*\n        Heap memory failed, try anonymous memory mapping.\n      */\n      memory_info->blob=MapBlob(-1,IOMode,0,extent);\n      if (memory_info->blob != NULL)\n        {\n          memory_info->type=MapVirtualMemory;\n          return(memory_info);\n        }\n      if (AcquireMagickResource(DiskResource,extent) != MagickFalse)\n        {\n          int\n            file;\n\n          /*\n            Anonymous memory mapping failed, try file-backed memory mapping.\n            If the MapResource request failed, there is no point in trying\n            file-backed memory mapping.\n          */\n          file=AcquireUniqueFileResource(memory_info->filename);\n          if (file != -1)\n            {\n              MagickOffsetType\n                offset;\n\n              offset=(MagickOffsetType) lseek(file,extent-1,SEEK_SET);\n              if ((offset == (MagickOffsetType) (extent-1)) &&\n                  (write(file,\"\",1) == 1))\n                {\n                  memory_info->blob=MapBlob(file,IOMode,0,extent);\n                  if (memory_info->blob != NULL)\n                    {\n                      (void) close(file);\n                      memory_info->type=MapVirtualMemory;\n                      return(memory_info);\n                    }\n                }\n              /*\n                File-backed memory mapping failed, delete the temporary file.\n              */\n              (void) close(file);\n              (void) RelinquishUniqueFileResource(memory_info->filename);\n              *memory_info->filename='\\0';\n            }\n        }\n      RelinquishMagickResource(DiskResource,extent);\n    }\n  RelinquishMagickResource(MapResource,extent);\n  if (memory_info->blob == NULL)\n    {\n      memory_info->blob=AcquireMagickMemory(extent);\n      if (memory_info->blob != NULL)\n        memory_info->type=UnalignedVirtualMemory;\n    }\n  if (memory_info->blob == NULL)\n    memory_info=RelinquishVirtualMemory(memory_info);\n  return(memory_info);\n}\n",
    "code_after_change": "MagickExport MemoryInfo *AcquireVirtualMemory(const size_t count,\n  const size_t quantum)\n{\n  MemoryInfo\n    *memory_info;\n\n   size_t\n     extent;\n \n  if (HeapOverflowSanityCheck(count,quantum) != MagickFalse)\n     return((MemoryInfo *) NULL);\n   memory_info=(MemoryInfo *) MagickAssumeAligned(AcquireAlignedMemory(1,\n     sizeof(*memory_info)));\n  if (memory_info == (MemoryInfo *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  (void) ResetMagickMemory(memory_info,0,sizeof(*memory_info));\n  extent=count*quantum;\n  memory_info->length=extent;\n  memory_info->signature=MagickSignature;\n  if (AcquireMagickResource(MemoryResource,extent) != MagickFalse)\n    {\n      memory_info->blob=AcquireAlignedMemory(1,extent);\n      if (memory_info->blob != NULL)\n        {\n          memory_info->type=AlignedVirtualMemory;\n          return(memory_info);\n        }\n    }\n  RelinquishMagickResource(MemoryResource,extent);\n  if (AcquireMagickResource(MapResource,extent) != MagickFalse)\n    {\n      /*\n        Heap memory failed, try anonymous memory mapping.\n      */\n      memory_info->blob=MapBlob(-1,IOMode,0,extent);\n      if (memory_info->blob != NULL)\n        {\n          memory_info->type=MapVirtualMemory;\n          return(memory_info);\n        }\n      if (AcquireMagickResource(DiskResource,extent) != MagickFalse)\n        {\n          int\n            file;\n\n          /*\n            Anonymous memory mapping failed, try file-backed memory mapping.\n            If the MapResource request failed, there is no point in trying\n            file-backed memory mapping.\n          */\n          file=AcquireUniqueFileResource(memory_info->filename);\n          if (file != -1)\n            {\n              MagickOffsetType\n                offset;\n\n              offset=(MagickOffsetType) lseek(file,extent-1,SEEK_SET);\n              if ((offset == (MagickOffsetType) (extent-1)) &&\n                  (write(file,\"\",1) == 1))\n                {\n                  memory_info->blob=MapBlob(file,IOMode,0,extent);\n                  if (memory_info->blob != NULL)\n                    {\n                      (void) close(file);\n                      memory_info->type=MapVirtualMemory;\n                      return(memory_info);\n                    }\n                }\n              /*\n                File-backed memory mapping failed, delete the temporary file.\n              */\n              (void) close(file);\n              (void) RelinquishUniqueFileResource(memory_info->filename);\n              *memory_info->filename='\\0';\n            }\n        }\n      RelinquishMagickResource(DiskResource,extent);\n    }\n  RelinquishMagickResource(MapResource,extent);\n  if (memory_info->blob == NULL)\n    {\n      memory_info->blob=AcquireMagickMemory(extent);\n      if (memory_info->blob != NULL)\n        memory_info->type=UnalignedVirtualMemory;\n    }\n  if (memory_info->blob == NULL)\n    memory_info=RelinquishVirtualMemory(memory_info);\n  return(memory_info);\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 263,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2013-4263",
    "code_before_change": "static int filter_frame(AVFilterLink *inlink, AVFrame *frame)\n{\n    AVFilterContext *ctx = inlink->dst;\n    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(inlink->format);\n     uint32_t plane_checksum[4] = {0}, checksum = 0;\n     int i, plane, vsub = desc->log2_chroma_h;\n \n    for (plane = 0; plane < 4 && frame->data[plane]; plane++) {\n         int64_t linesize = av_image_get_linesize(frame->format, frame->width, plane);\n         uint8_t *data = frame->data[plane];\n         int h = plane == 1 || plane == 2 ? FF_CEIL_RSHIFT(inlink->h, vsub) : inlink->h;\n\n        if (linesize < 0)\n            return linesize;\n\n        for (i = 0; i < h; i++) {\n            plane_checksum[plane] = av_adler32_update(plane_checksum[plane], data, linesize);\n            checksum = av_adler32_update(checksum, data, linesize);\n            data += frame->linesize[plane];\n        }\n    }\n\n    av_log(ctx, AV_LOG_INFO,\n           \"n:%\"PRId64\" pts:%s pts_time:%s pos:%\"PRId64\" \"\n           \"fmt:%s sar:%d/%d s:%dx%d i:%c iskey:%d type:%c \"\n           \"checksum:%08X plane_checksum:[%08X\",\n           inlink->frame_count,\n           av_ts2str(frame->pts), av_ts2timestr(frame->pts, &inlink->time_base), av_frame_get_pkt_pos(frame),\n           desc->name,\n           frame->sample_aspect_ratio.num, frame->sample_aspect_ratio.den,\n           frame->width, frame->height,\n           !frame->interlaced_frame ? 'P' :         /* Progressive  */\n           frame->top_field_first   ? 'T' : 'B',    /* Top / Bottom */\n           frame->key_frame,\n            av_get_picture_type_char(frame->pict_type),\n            checksum, plane_checksum[0]);\n \n    for (plane = 1; plane < 4 && frame->data[plane]; plane++)\n         av_log(ctx, AV_LOG_INFO, \" %08X\", plane_checksum[plane]);\n     av_log(ctx, AV_LOG_INFO, \"]\\n\");\n \n    return ff_filter_frame(inlink->dst->outputs[0], frame);\n}\n",
    "code_after_change": "static int filter_frame(AVFilterLink *inlink, AVFrame *frame)\n{\n    AVFilterContext *ctx = inlink->dst;\n    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(inlink->format);\n     uint32_t plane_checksum[4] = {0}, checksum = 0;\n     int i, plane, vsub = desc->log2_chroma_h;\n \n    for (plane = 0; plane < 4 && frame->data[plane] && frame->linesize[plane]; plane++) {\n         int64_t linesize = av_image_get_linesize(frame->format, frame->width, plane);\n         uint8_t *data = frame->data[plane];\n         int h = plane == 1 || plane == 2 ? FF_CEIL_RSHIFT(inlink->h, vsub) : inlink->h;\n\n        if (linesize < 0)\n            return linesize;\n\n        for (i = 0; i < h; i++) {\n            plane_checksum[plane] = av_adler32_update(plane_checksum[plane], data, linesize);\n            checksum = av_adler32_update(checksum, data, linesize);\n            data += frame->linesize[plane];\n        }\n    }\n\n    av_log(ctx, AV_LOG_INFO,\n           \"n:%\"PRId64\" pts:%s pts_time:%s pos:%\"PRId64\" \"\n           \"fmt:%s sar:%d/%d s:%dx%d i:%c iskey:%d type:%c \"\n           \"checksum:%08X plane_checksum:[%08X\",\n           inlink->frame_count,\n           av_ts2str(frame->pts), av_ts2timestr(frame->pts, &inlink->time_base), av_frame_get_pkt_pos(frame),\n           desc->name,\n           frame->sample_aspect_ratio.num, frame->sample_aspect_ratio.den,\n           frame->width, frame->height,\n           !frame->interlaced_frame ? 'P' :         /* Progressive  */\n           frame->top_field_first   ? 'T' : 'B',    /* Top / Bottom */\n           frame->key_frame,\n            av_get_picture_type_char(frame->pict_type),\n            checksum, plane_checksum[0]);\n \n    for (plane = 1; plane < 4 && frame->data[plane] && frame->linesize[plane]; plane++)\n         av_log(ctx, AV_LOG_INFO, \" %08X\", plane_checksum[plane]);\n     av_log(ctx, AV_LOG_INFO, \"]\\n\");\n \n    return ff_filter_frame(inlink->dst->outputs[0], frame);\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 267,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-4544",
    "code_before_change": "static int exif_process_IFD_in_JPEG(image_info_type *ImageInfo, char *dir_start, char *offset_base, size_t IFDlength, size_t displacement, int section_index TSRMLS_DC)\n{\n\tint de;\n\tint NumDirEntries;\n\tint NextDirOffset;\n\n#ifdef EXIF_DEBUG\n\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Process %s (x%04X(=%d))\", exif_get_sectionname(section_index), IFDlength, IFDlength);\n#endif\n \n        ImageInfo->sections_found |= FOUND_IFD0;\n \n        NumDirEntries = php_ifd_get16u(dir_start, ImageInfo->motorola_intel);\n \n        if ((dir_start+2+NumDirEntries*12) > (offset_base+IFDlength)) {\n\t\tif (!exif_process_IFD_TAG(ImageInfo, dir_start + 2 + 12 * de,\n\t\t\t\t\t\t\t\t  offset_base, IFDlength, displacement, section_index, 1, exif_get_tag_table(section_index) TSRMLS_CC)) {\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\t/*\n\t * Ignore IFD2 if it purportedly exists\n\t */\n\tif (section_index == SECTION_THUMBNAIL) {\n\t\treturn TRUE;\n\t}\n\t/*\n\t * Hack to make it process IDF1 I hope\n\t * There are 2 IDFs, the second one holds the keys (0x0201 and 0x0202) to the thumbnail\n\t */\n\tNextDirOffset = php_ifd_get32u(dir_start+2+12*de, ImageInfo->motorola_intel);\n\tif (NextDirOffset) {\n         * Hack to make it process IDF1 I hope\n         * There are 2 IDFs, the second one holds the keys (0x0201 and 0x0202) to the thumbnail\n         */\n        NextDirOffset = php_ifd_get32u(dir_start+2+12*de, ImageInfo->motorola_intel);\n        if (NextDirOffset) {\n                /* the next line seems false but here IFDlength means length of all IFDs */\n#ifdef EXIF_DEBUG\n\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Thumbnail size: 0x%04X\", ImageInfo->Thumbnail.size);\n#endif\n\t\t\tif (ImageInfo->Thumbnail.filetype != IMAGE_FILETYPE_UNKNOWN\n\t\t\t&&  ImageInfo->Thumbnail.size\n\t\t\t&&  ImageInfo->Thumbnail.offset\n\t\t\t&&  ImageInfo->read_thumbnail\n\t\t\t) {\n\t\t\t\texif_thumbnail_extract(ImageInfo, offset_base, IFDlength TSRMLS_CC);\n\t\t\t}\n\t\t\treturn TRUE;\n\t\t} else {\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\treturn TRUE;\n}\n",
    "code_after_change": "static int exif_process_IFD_in_JPEG(image_info_type *ImageInfo, char *dir_start, char *offset_base, size_t IFDlength, size_t displacement, int section_index TSRMLS_DC)\n{\n\tint de;\n\tint NumDirEntries;\n\tint NextDirOffset;\n\n#ifdef EXIF_DEBUG\n\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Process %s (x%04X(=%d))\", exif_get_sectionname(section_index), IFDlength, IFDlength);\n#endif\n \n        ImageInfo->sections_found |= FOUND_IFD0;\n \n       if ((dir_start + 2) >= (offset_base+IFDlength)) {\n               exif_error_docref(\"exif_read_data#error_ifd\" EXIFERR_CC, ImageInfo, E_WARNING, \"Illegal IFD size\");\n               return FALSE;\n       }\n\n        NumDirEntries = php_ifd_get16u(dir_start, ImageInfo->motorola_intel);\n \n        if ((dir_start+2+NumDirEntries*12) > (offset_base+IFDlength)) {\n\t\tif (!exif_process_IFD_TAG(ImageInfo, dir_start + 2 + 12 * de,\n\t\t\t\t\t\t\t\t  offset_base, IFDlength, displacement, section_index, 1, exif_get_tag_table(section_index) TSRMLS_CC)) {\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\t/*\n\t * Ignore IFD2 if it purportedly exists\n\t */\n\tif (section_index == SECTION_THUMBNAIL) {\n\t\treturn TRUE;\n\t}\n\t/*\n\t * Hack to make it process IDF1 I hope\n\t * There are 2 IDFs, the second one holds the keys (0x0201 and 0x0202) to the thumbnail\n\t */\n\tNextDirOffset = php_ifd_get32u(dir_start+2+12*de, ImageInfo->motorola_intel);\n\tif (NextDirOffset) {\n         * Hack to make it process IDF1 I hope\n         * There are 2 IDFs, the second one holds the keys (0x0201 and 0x0202) to the thumbnail\n         */\n       if ((dir_start+2+12*de + 4) >= (offset_base+IFDlength)) {\n               exif_error_docref(\"exif_read_data#error_ifd\" EXIFERR_CC, ImageInfo, E_WARNING, \"Illegal IFD size\");\n               return FALSE;\n       }\n        NextDirOffset = php_ifd_get32u(dir_start+2+12*de, ImageInfo->motorola_intel);\n        if (NextDirOffset) {\n                /* the next line seems false but here IFDlength means length of all IFDs */\n#ifdef EXIF_DEBUG\n\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Thumbnail size: 0x%04X\", ImageInfo->Thumbnail.size);\n#endif\n\t\t\tif (ImageInfo->Thumbnail.filetype != IMAGE_FILETYPE_UNKNOWN\n\t\t\t&&  ImageInfo->Thumbnail.size\n\t\t\t&&  ImageInfo->Thumbnail.offset\n\t\t\t&&  ImageInfo->read_thumbnail\n\t\t\t) {\n\t\t\t\texif_thumbnail_extract(ImageInfo, offset_base, IFDlength TSRMLS_CC);\n\t\t\t}\n\t\t\treturn TRUE;\n\t\t} else {\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\treturn TRUE;\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 287,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-1621",
    "code_before_change": "unsigned long long Track::GetDefaultDuration() const\n{\n    return m_info.defaultDuration;\n}\n",
    "code_after_change": "unsigned long long Track::GetDefaultDuration() const\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 290,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-2508",
    "code_before_change": "sp<MediaSource> MPEG4Extractor::getTrack(size_t index) {\n status_t err;\n if ((err = readMetaData()) != OK) {\n return NULL;\n }\n\n Track *track = mFirstTrack;\n while (index > 0) {\n if (track == NULL) {\n return NULL;\n }\n\n        track = track->next;\n --index;\n }\n\n if (track == NULL) {\n return NULL;\n }\n\n\n Trex *trex = NULL;\n int32_t trackId;\n if (track->meta->findInt32(kKeyTrackID, &trackId)) {\n for (size_t i = 0; i < mTrex.size(); i++) {\n Trex *t = &mTrex.editItemAt(index);\n if (t->track_ID == (uint32_t) trackId) {\n                trex = t;\n\n                 break;\n             }\n         }\n     }\n \n     ALOGV(\"getTrack called, pssh: %zu\", mPssh.size());\n\n return new MPEG4Source(this,\n            track->meta, mDataSource, track->timescale, track->sampleTable,\n            mSidxEntries, trex, mMoofOffset);\n}\n",
    "code_after_change": "sp<MediaSource> MPEG4Extractor::getTrack(size_t index) {\n status_t err;\n if ((err = readMetaData()) != OK) {\n return NULL;\n }\n\n Track *track = mFirstTrack;\n while (index > 0) {\n if (track == NULL) {\n return NULL;\n }\n\n        track = track->next;\n --index;\n }\n\n if (track == NULL) {\n return NULL;\n }\n\n\n Trex *trex = NULL;\n int32_t trackId;\n if (track->meta->findInt32(kKeyTrackID, &trackId)) {\n for (size_t i = 0; i < mTrex.size(); i++) {\n Trex *t = &mTrex.editItemAt(index);\n if (t->track_ID == (uint32_t) trackId) {\n                trex = t;\n\n                 break;\n             }\n         }\n    } else {\n        ALOGE(\"b/21657957\");\n        return NULL;\n     }\n \n     ALOGV(\"getTrack called, pssh: %zu\", mPssh.size());\n\n return new MPEG4Source(this,\n            track->meta, mDataSource, track->timescale, track->sampleTable,\n            mSidxEntries, trex, mMoofOffset);\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 299,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-2476",
    "code_before_change": "OMX_ERRORTYPE SoftFlacEncoder::internalSetParameter(\n        OMX_INDEXTYPE index, const OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamAudioPcm:\n {\n\n             ALOGV(\"SoftFlacEncoder::internalSetParameter(OMX_IndexParamAudioPcm)\");\n             OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams = (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n             if (pcmParams->nPortIndex != 0 && pcmParams->nPortIndex != 1) {\n                 ALOGE(\"SoftFlacEncoder::internalSetParameter() Error #1\");\n                 return OMX_ErrorUndefined;\n }\n\n if (pcmParams->nChannels < 1 || pcmParams->nChannels > 2) {\n return OMX_ErrorUndefined;\n }\n\n            mNumChannels = pcmParams->nChannels;\n            mSampleRate = pcmParams->nSamplingRate;\n            ALOGV(\"will encode %d channels at %dHz\", mNumChannels, mSampleRate);\n\n return configureEncoder();\n }\n\n case OMX_IndexParamStandardComponentRole:\n {\n            ALOGV(\"SoftFlacEncoder::internalSetParameter(OMX_IndexParamStandardComponentRole)\");\n\n             const OMX_PARAM_COMPONENTROLETYPE *roleParams =\n                 (const OMX_PARAM_COMPONENTROLETYPE *)params;\n \n             if (strncmp((const char *)roleParams->cRole,\n                     \"audio_encoder.flac\",\n                     OMX_MAX_STRINGNAME_SIZE - 1)) {\n                ALOGE(\"SoftFlacEncoder::internalSetParameter(OMX_IndexParamStandardComponentRole)\"\n \"error\");\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioFlac:\n\n         {\n             OMX_AUDIO_PARAM_FLACTYPE *flacParams = (OMX_AUDIO_PARAM_FLACTYPE *)params;\n             mCompressionLevel = flacParams->nCompressionLevel; // range clamping done inside encoder\n             return OMX_ErrorNone;\n         }\n\n case OMX_IndexParamPortDefinition:\n {\n\n             OMX_PARAM_PORTDEFINITIONTYPE *defParams =\n                 (OMX_PARAM_PORTDEFINITIONTYPE *)params;\n \n             if (defParams->nPortIndex == 0) {\n                 if (defParams->nBufferSize > kMaxInputBufferSize) {\n                     ALOGE(\"Input buffer size must be at most %d bytes\",\n                        kMaxInputBufferSize);\n return OMX_ErrorUnsupportedSetting;\n }\n }\n\n }\n\n default:\n            ALOGV(\"SoftFlacEncoder::internalSetParameter(default)\");\n return SimpleSoftOMXComponent::internalSetParameter(index, params);\n }\n}\n",
    "code_after_change": "OMX_ERRORTYPE SoftFlacEncoder::internalSetParameter(\n        OMX_INDEXTYPE index, const OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamAudioPcm:\n {\n\n             ALOGV(\"SoftFlacEncoder::internalSetParameter(OMX_IndexParamAudioPcm)\");\n             OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams = (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n            if (!isValidOMXParam(pcmParams)) {\n                return OMX_ErrorBadParameter;\n            }\n\n             if (pcmParams->nPortIndex != 0 && pcmParams->nPortIndex != 1) {\n                 ALOGE(\"SoftFlacEncoder::internalSetParameter() Error #1\");\n                 return OMX_ErrorUndefined;\n }\n\n if (pcmParams->nChannels < 1 || pcmParams->nChannels > 2) {\n return OMX_ErrorUndefined;\n }\n\n            mNumChannels = pcmParams->nChannels;\n            mSampleRate = pcmParams->nSamplingRate;\n            ALOGV(\"will encode %d channels at %dHz\", mNumChannels, mSampleRate);\n\n return configureEncoder();\n }\n\n case OMX_IndexParamStandardComponentRole:\n {\n            ALOGV(\"SoftFlacEncoder::internalSetParameter(OMX_IndexParamStandardComponentRole)\");\n\n             const OMX_PARAM_COMPONENTROLETYPE *roleParams =\n                 (const OMX_PARAM_COMPONENTROLETYPE *)params;\n \n            if (!isValidOMXParam(roleParams)) {\n                return OMX_ErrorBadParameter;\n            }\n\n             if (strncmp((const char *)roleParams->cRole,\n                     \"audio_encoder.flac\",\n                     OMX_MAX_STRINGNAME_SIZE - 1)) {\n                ALOGE(\"SoftFlacEncoder::internalSetParameter(OMX_IndexParamStandardComponentRole)\"\n \"error\");\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioFlac:\n\n         {\n             OMX_AUDIO_PARAM_FLACTYPE *flacParams = (OMX_AUDIO_PARAM_FLACTYPE *)params;\n\n            if (!isValidOMXParam(flacParams)) {\n                return OMX_ErrorBadParameter;\n            }\n\n             mCompressionLevel = flacParams->nCompressionLevel; // range clamping done inside encoder\n             return OMX_ErrorNone;\n         }\n\n case OMX_IndexParamPortDefinition:\n {\n\n             OMX_PARAM_PORTDEFINITIONTYPE *defParams =\n                 (OMX_PARAM_PORTDEFINITIONTYPE *)params;\n \n            if (!isValidOMXParam(defParams)) {\n                return OMX_ErrorBadParameter;\n            }\n\n             if (defParams->nPortIndex == 0) {\n                 if (defParams->nBufferSize > kMaxInputBufferSize) {\n                     ALOGE(\"Input buffer size must be at most %d bytes\",\n                        kMaxInputBufferSize);\n return OMX_ErrorUnsupportedSetting;\n }\n }\n\n }\n\n default:\n            ALOGV(\"SoftFlacEncoder::internalSetParameter(default)\");\n return SimpleSoftOMXComponent::internalSetParameter(index, params);\n }\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 303,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-1621",
    "code_before_change": "const SeekHead::Entry* SeekHead::GetEntry(int idx) const\n{\n    if (idx < 0)\n        return 0;\n    if (idx >= m_entry_count)\n        return 0;\n    return m_entries + idx;\n}\n",
    "code_after_change": "const SeekHead::Entry* SeekHead::GetEntry(int idx) const\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 306,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2018-6094",
    "code_before_change": " bool NormalPageArena::shrinkObject(HeapObjectHeader* header, size_t newSize) {\n  ASSERT(header->checkHeader());\n   ASSERT(header->payloadSize() > newSize);\n   size_t allocationSize = ThreadHeap::allocationSizeFromSize(newSize);\n   ASSERT(header->size() > allocationSize);\n  size_t shrinkSize = header->size() - allocationSize;\n  if (isObjectAllocatedAtAllocationPoint(header)) {\n    m_currentAllocationPoint -= shrinkSize;\n    setRemainingAllocationSize(m_remainingAllocationSize + shrinkSize);\n    SET_MEMORY_INACCESSIBLE(m_currentAllocationPoint, shrinkSize);\n    header->setSize(allocationSize);\n    return true;\n  }\n  ASSERT(shrinkSize >= sizeof(HeapObjectHeader));\n  ASSERT(header->gcInfoIndex() > 0);\n  Address shrinkAddress = header->payloadEnd() - shrinkSize;\n  HeapObjectHeader* freedHeader = new (NotNull, shrinkAddress)\n      HeapObjectHeader(shrinkSize, header->gcInfoIndex());\n  freedHeader->markPromptlyFreed();\n  ASSERT(pageFromObject(reinterpret_cast<Address>(header)) ==\n         findPageFromAddress(reinterpret_cast<Address>(header)));\n  m_promptlyFreedSize += shrinkSize;\n  header->setSize(allocationSize);\n  SET_MEMORY_INACCESSIBLE(shrinkAddress + sizeof(HeapObjectHeader),\n                          shrinkSize - sizeof(HeapObjectHeader));\n  return false;\n}\n",
    "code_after_change": " bool NormalPageArena::shrinkObject(HeapObjectHeader* header, size_t newSize) {\n  header->checkHeader();\n   ASSERT(header->payloadSize() > newSize);\n   size_t allocationSize = ThreadHeap::allocationSizeFromSize(newSize);\n   ASSERT(header->size() > allocationSize);\n  size_t shrinkSize = header->size() - allocationSize;\n  if (isObjectAllocatedAtAllocationPoint(header)) {\n    m_currentAllocationPoint -= shrinkSize;\n    setRemainingAllocationSize(m_remainingAllocationSize + shrinkSize);\n    SET_MEMORY_INACCESSIBLE(m_currentAllocationPoint, shrinkSize);\n    header->setSize(allocationSize);\n    return true;\n  }\n  ASSERT(shrinkSize >= sizeof(HeapObjectHeader));\n  ASSERT(header->gcInfoIndex() > 0);\n  Address shrinkAddress = header->payloadEnd() - shrinkSize;\n  HeapObjectHeader* freedHeader = new (NotNull, shrinkAddress)\n      HeapObjectHeader(shrinkSize, header->gcInfoIndex());\n  freedHeader->markPromptlyFreed();\n  ASSERT(pageFromObject(reinterpret_cast<Address>(header)) ==\n         findPageFromAddress(reinterpret_cast<Address>(header)));\n  m_promptlyFreedSize += shrinkSize;\n  header->setSize(allocationSize);\n  SET_MEMORY_INACCESSIBLE(shrinkAddress + sizeof(HeapObjectHeader),\n                          shrinkSize - sizeof(HeapObjectHeader));\n  return false;\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 324,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2018-11218",
    "code_before_change": "int mp_pack(lua_State *L) {\n    int nargs = lua_gettop(L);\n    int i;\n    mp_buf *buf;\n\n     if (nargs == 0)\n         return luaL_argerror(L, 0, \"MessagePack pack needs input.\");\n \n     buf = mp_buf_new(L);\n     for(i = 1; i <= nargs; i++) {\n         /* Copy argument i to top of stack for _encode processing;\n         * the encode function pops it from the stack when complete. */\n        lua_pushvalue(L, i);\n\n        mp_encode_lua_type(L,buf,0);\n\n        lua_pushlstring(L,(char*)buf->b,buf->len);\n\n        /* Reuse the buffer for the next operation by\n         * setting its free count to the total buffer size\n         * and the current position to zero. */\n        buf->free += buf->len;\n        buf->len = 0;\n    }\n    mp_buf_free(L, buf);\n\n    /* Concatenate all nargs buffers together */\n    lua_concat(L, nargs);\n    return 1;\n}\n",
    "code_after_change": "int mp_pack(lua_State *L) {\n    int nargs = lua_gettop(L);\n    int i;\n    mp_buf *buf;\n\n     if (nargs == 0)\n         return luaL_argerror(L, 0, \"MessagePack pack needs input.\");\n \n    if (!lua_checkstack(L, nargs))\n        return luaL_argerror(L, 0, \"Too many arguments for MessagePack pack.\");\n\n     buf = mp_buf_new(L);\n     for(i = 1; i <= nargs; i++) {\n         /* Copy argument i to top of stack for _encode processing;\n         * the encode function pops it from the stack when complete. */\n        lua_pushvalue(L, i);\n\n        mp_encode_lua_type(L,buf,0);\n\n        lua_pushlstring(L,(char*)buf->b,buf->len);\n\n        /* Reuse the buffer for the next operation by\n         * setting its free count to the total buffer size\n         * and the current position to zero. */\n        buf->free += buf->len;\n        buf->len = 0;\n    }\n    mp_buf_free(L, buf);\n\n    /* Concatenate all nargs buffers together */\n    lua_concat(L, nargs);\n    return 1;\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 330,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-1621",
    "code_before_change": "long Chapters::Edition::Parse(\n    IMkvReader* pReader,\n    long long pos,\n    long long size)\n{\n    const long long stop = pos + size;\n \n    while (pos < stop)\n    {\n        long long id, size;\n \n        long status = ParseElementHeader(\n                        pReader,\n                        pos,\n                        stop,\n                        id,\n                        size);\n \n        if (status < 0)  // error\n            return status;\n \n        if (size == 0)  // weird\n            continue;\n \n        if (id == 0x36)  // Atom ID\n        {\n            status = ParseAtom(pReader, pos, size);\n \n            if (status < 0)  // error\n                return status;\n        }\n \n        pos += size;\n        assert(pos <= stop);\n     }\n \n    assert(pos == stop);\n    return 0;\n }\n",
    "code_after_change": "long Chapters::Edition::Parse(\n  Segment* const pSegment = pChapters->m_pSegment;\n \n  if (pSegment == NULL)  // weird\n    return -1;\n \n  const SegmentInfo* const pInfo = pSegment->GetInfo();\n \n  if (pInfo == NULL)\n    return -1;\n \n  const long long timecode_scale = pInfo->GetTimeCodeScale();\n \n  if (timecode_scale < 1)  // weird\n    return -1;\n \n  if (timecode < 0)\n    return -1;\n \n  const long long result = timecode_scale * timecode;\n\n  return result;\n}\n\nlong Chapters::Atom::ParseDisplay(IMkvReader* pReader, long long pos,\n                                  long long size) {\n  if (!ExpandDisplaysArray())\n    return -1;\n\n  Display& d = m_displays[m_displays_count++];\n  d.Init();\n\n  return d.Parse(pReader, pos, size);\n}\n\nbool Chapters::Atom::ExpandDisplaysArray() {\n  if (m_displays_size > m_displays_count)\n    return true;  // nothing else to do\n\n  const int size = (m_displays_size == 0) ? 1 : 2 * m_displays_size;\n\n  Display* const displays = new (std::nothrow) Display[size];\n\n  if (displays == NULL)\n    return false;\n\n  for (int idx = 0; idx < m_displays_count; ++idx) {\n    m_displays[idx].ShallowCopy(displays[idx]);\n  }\n\n  delete[] m_displays;\n  m_displays = displays;\n\n  m_displays_size = size;\n  return true;\n}\n\nChapters::Display::Display() {}\n\nChapters::Display::~Display() {}\n\nconst char* Chapters::Display::GetString() const { return m_string; }\n\nconst char* Chapters::Display::GetLanguage() const { return m_language; }\n\nconst char* Chapters::Display::GetCountry() const { return m_country; }\n\nvoid Chapters::Display::Init() {\n  m_string = NULL;\n  m_language = NULL;\n  m_country = NULL;\n}\n\nvoid Chapters::Display::ShallowCopy(Display& rhs) const {\n  rhs.m_string = m_string;\n  rhs.m_language = m_language;\n  rhs.m_country = m_country;\n}\n\nvoid Chapters::Display::Clear() {\n  delete[] m_string;\n  m_string = NULL;\n\n  delete[] m_language;\n  m_language = NULL;\n\n  delete[] m_country;\n  m_country = NULL;\n}\n\nlong Chapters::Display::Parse(IMkvReader* pReader, long long pos,\n                              long long size) {\n  const long long stop = pos + size;\n\n  while (pos < stop) {\n    long long id, size;\n\n    long status = ParseElementHeader(pReader, pos, stop, id, size);\n\n    if (status < 0)  // error\n      return status;\n\n    if (size == 0)  // weird\n      continue;\n\n    if (id == 0x05) {  // ChapterString ID\n      status = UnserializeString(pReader, pos, size, m_string);\n\n      if (status)\n        return status;\n    } else if (id == 0x037C) {  // ChapterLanguage ID\n      status = UnserializeString(pReader, pos, size, m_language);\n\n      if (status)\n        return status;\n    } else if (id == 0x037E) {  // ChapterCountry ID\n      status = UnserializeString(pReader, pos, size, m_country);\n\n      if (status)\n        return status;\n     }\n \n    pos += size;\n    assert(pos <= stop);\n  }\n\n  assert(pos == stop);\n  return 0;\n }\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 335,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-2324",
    "code_before_change": "static void show_object(struct object *object, struct strbuf *path,\n\t\t\tconst char *last, void *data)\n {\n \tstruct bitmap *base = data;\n \tint bitmap_pos;\n \n \tbitmap_pos = bitmap_position(object->oid.hash);\n \n\tif (bitmap_pos < 0) {\n\t\tchar *name = path_name(path, last);\n \t\tbitmap_pos = ext_index_add_object(object, name);\n\t\tfree(name);\n\t}\n \n \tbitmap_set(base, bitmap_pos);\n }\n",
    "code_after_change": "static void show_object(struct object *object, struct strbuf *path,\nstatic void show_object(struct object *object, const char *name, void *data)\n {\n \tstruct bitmap *base = data;\n \tint bitmap_pos;\n \n \tbitmap_pos = bitmap_position(object->oid.hash);\n \n\tif (bitmap_pos < 0)\n \t\tbitmap_pos = ext_index_add_object(object, name);\n \n \tbitmap_set(base, bitmap_pos);\n }\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 336,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-10066",
    "code_before_change": "static Image *ReadGRAYImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  Image\n    *canvas_image,\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    scene;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  size_t\n    length;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  if ((image->columns == 0) || (image->rows == 0))\n    ThrowReaderException(OptionError,\"MustSpecifyImageSize\");\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (DiscardBlobBytes(image,(size_t) image->offset) == MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  /*\n    Create virtual canvas to support cropping (i.e. image.gray[100x100+10+20]).\n  */\n  SetImageColorspace(image,GRAYColorspace);\n  canvas_image=CloneImage(image,image->extract_info.width,1,MagickFalse,\n    exception);\n  (void) SetImageVirtualPixelMethod(canvas_image,BlackVirtualPixelMethod);\n  quantum_type=GrayQuantum;\n  quantum_info=AcquireQuantumInfo(image_info,canvas_image);\n  if (quantum_info == (QuantumInfo *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  pixels=GetQuantumPixels(quantum_info);\n  if (image_info->number_scenes != 0)\n    while (image->scene < image_info->scene)\n    {\n      /*\n        Skip to next image.\n      */\n      image->scene++;\n      length=GetQuantumExtent(canvas_image,quantum_info,quantum_type);\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        count=ReadBlob(image,length,pixels);\n        if (count != (ssize_t) length)\n          break;\n      }\n    }\n  scene=0;\n  count=0;\n  length=0;\n  do\n  {\n    /*\n      Read pixels to virtual canvas image then push to image.\n    */\n     if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n       if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n         break;\n     SetImageColorspace(image,GRAYColorspace);\n     if (scene == 0)\n       {\n        length=GetQuantumExtent(canvas_image,quantum_info,quantum_type);\n        count=ReadBlob(image,length,pixels);\n      }\n    for (y=0; y < (ssize_t) image->extract_info.height; y++)\n    {\n      register const PixelPacket\n        *restrict p;\n\n      register ssize_t\n        x;\n\n      register PixelPacket\n        *restrict q;\n\n      if (count != (ssize_t) length)\n        {\n          ThrowFileException(exception,CorruptImageError,\n            \"UnexpectedEndOfFile\",image->filename);\n          break;\n        }\n      q=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,exception);\n      if (q == (PixelPacket *) NULL)\n        break;\n      length=ImportQuantumPixels(canvas_image,(CacheView *) NULL,quantum_info,\n        quantum_type,pixels,exception);\n      if (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)\n        break;\n      if (((y-image->extract_info.y) >= 0) &&\n          ((y-image->extract_info.y) < (ssize_t) image->rows))\n        {\n          p=GetVirtualPixels(canvas_image,canvas_image->extract_info.x,0,\n            image->columns,1,exception);\n          q=QueueAuthenticPixels(image,0,y-image->extract_info.y,image->columns,\n            1,exception);\n          if ((p == (const PixelPacket *) NULL) || (q == (PixelPacket *) NULL))\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelRed(q,GetPixelRed(p));\n            SetPixelGreen(q,GetPixelGreen(p));\n            SetPixelBlue(q,GetPixelBlue(p));\n            p++;\n            q++;\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n        }\n      if (image->previous == (Image *) NULL)\n        {\n          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n      count=ReadBlob(image,length,pixels);\n    }\n    SetQuantumImageType(image,quantum_type);\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if (count == (ssize_t) length)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n    scene++;\n  } while (count == (ssize_t) length);\n  quantum_info=DestroyQuantumInfo(quantum_info);\n  InheritException(&image->exception,&canvas_image->exception);\n  canvas_image=DestroyImage(canvas_image);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n",
    "code_after_change": "static Image *ReadGRAYImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  Image\n    *canvas_image,\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    scene;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  size_t\n    length;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  if ((image->columns == 0) || (image->rows == 0))\n    ThrowReaderException(OptionError,\"MustSpecifyImageSize\");\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (DiscardBlobBytes(image,(size_t) image->offset) == MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  /*\n    Create virtual canvas to support cropping (i.e. image.gray[100x100+10+20]).\n  */\n  SetImageColorspace(image,GRAYColorspace);\n  canvas_image=CloneImage(image,image->extract_info.width,1,MagickFalse,\n    exception);\n  (void) SetImageVirtualPixelMethod(canvas_image,BlackVirtualPixelMethod);\n  quantum_type=GrayQuantum;\n  quantum_info=AcquireQuantumInfo(image_info,canvas_image);\n  if (quantum_info == (QuantumInfo *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  pixels=GetQuantumPixels(quantum_info);\n  if (image_info->number_scenes != 0)\n    while (image->scene < image_info->scene)\n    {\n      /*\n        Skip to next image.\n      */\n      image->scene++;\n      length=GetQuantumExtent(canvas_image,quantum_info,quantum_type);\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        count=ReadBlob(image,length,pixels);\n        if (count != (ssize_t) length)\n          break;\n      }\n    }\n  scene=0;\n  count=0;\n  length=0;\n  do\n  {\n    /*\n      Read pixels to virtual canvas image then push to image.\n    */\n     if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n       if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n         break;\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n     SetImageColorspace(image,GRAYColorspace);\n     if (scene == 0)\n       {\n        length=GetQuantumExtent(canvas_image,quantum_info,quantum_type);\n        count=ReadBlob(image,length,pixels);\n      }\n    for (y=0; y < (ssize_t) image->extract_info.height; y++)\n    {\n      register const PixelPacket\n        *restrict p;\n\n      register ssize_t\n        x;\n\n      register PixelPacket\n        *restrict q;\n\n      if (count != (ssize_t) length)\n        {\n          ThrowFileException(exception,CorruptImageError,\n            \"UnexpectedEndOfFile\",image->filename);\n          break;\n        }\n      q=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,exception);\n      if (q == (PixelPacket *) NULL)\n        break;\n      length=ImportQuantumPixels(canvas_image,(CacheView *) NULL,quantum_info,\n        quantum_type,pixels,exception);\n      if (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)\n        break;\n      if (((y-image->extract_info.y) >= 0) &&\n          ((y-image->extract_info.y) < (ssize_t) image->rows))\n        {\n          p=GetVirtualPixels(canvas_image,canvas_image->extract_info.x,0,\n            image->columns,1,exception);\n          q=QueueAuthenticPixels(image,0,y-image->extract_info.y,image->columns,\n            1,exception);\n          if ((p == (const PixelPacket *) NULL) || (q == (PixelPacket *) NULL))\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelRed(q,GetPixelRed(p));\n            SetPixelGreen(q,GetPixelGreen(p));\n            SetPixelBlue(q,GetPixelBlue(p));\n            p++;\n            q++;\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n        }\n      if (image->previous == (Image *) NULL)\n        {\n          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n      count=ReadBlob(image,length,pixels);\n    }\n    SetQuantumImageType(image,quantum_type);\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if (count == (ssize_t) length)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n    scene++;\n  } while (count == (ssize_t) length);\n  quantum_info=DestroyQuantumInfo(quantum_info);\n  InheritException(&image->exception,&canvas_image->exception);\n  canvas_image=DestroyImage(canvas_image);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 338,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2017-5009",
    "code_before_change": "void FrameFetchContext::DispatchWillSendRequest(\n     unsigned long identifier,\n     ResourceRequest& request,\n     const ResourceResponse& redirect_response,\n     const FetchInitiatorInfo& initiator_info) {\n   if (IsDetached())\n     return;\n\n  if (redirect_response.IsNull()) {\n    GetFrame()->Loader().Progress().WillStartLoading(identifier,\n                                                     request.Priority());\n   }\n   probe::willSendRequest(GetFrame()->GetDocument(), identifier,\n                          MasterDocumentLoader(), request, redirect_response,\n                         initiator_info);\n   if (IdlenessDetector* idleness_detector = GetFrame()->GetIdlenessDetector())\n     idleness_detector->OnWillSendRequest();\n   if (GetFrame()->FrameScheduler())\n    GetFrame()->FrameScheduler()->DidStartLoading(identifier);\n}\n",
    "code_after_change": "void FrameFetchContext::DispatchWillSendRequest(\n     unsigned long identifier,\n     ResourceRequest& request,\n     const ResourceResponse& redirect_response,\n    Resource::Type resource_type,\n     const FetchInitiatorInfo& initiator_info) {\n   if (IsDetached())\n     return;\n\n  if (redirect_response.IsNull()) {\n    GetFrame()->Loader().Progress().WillStartLoading(identifier,\n                                                     request.Priority());\n   }\n   probe::willSendRequest(GetFrame()->GetDocument(), identifier,\n                          MasterDocumentLoader(), request, redirect_response,\n                         initiator_info, resource_type);\n   if (IdlenessDetector* idleness_detector = GetFrame()->GetIdlenessDetector())\n     idleness_detector->OnWillSendRequest();\n   if (GetFrame()->FrameScheduler())\n    GetFrame()->FrameScheduler()->DidStartLoading(identifier);\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 342,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2012-2895",
    "code_before_change": "std::vector<FilePath> GDataCache::GetCachePaths(\n    const FilePath& cache_root_path) {\n  std::vector<FilePath> cache_paths;\n  cache_paths.push_back(cache_root_path.Append(kGDataCacheMetaDir));\n  cache_paths.push_back(cache_root_path.Append(kGDataCachePinnedDir));\n  cache_paths.push_back(cache_root_path.Append(kGDataCacheOutgoingDir));\n  cache_paths.push_back(cache_root_path.Append(kGDataCachePersistentDir));\n  cache_paths.push_back(cache_root_path.Append(kGDataCacheTmpDir));\n  cache_paths.push_back(cache_root_path.Append(kGDataCacheTmpDownloadsDir));\n  cache_paths.push_back(cache_root_path.Append(kGDataCacheTmpDocumentsDir));\n  return cache_paths;\n}\n",
    "code_after_change": "std::vector<FilePath> GDataCache::GetCachePaths(\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 344,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2013-2877",
    "code_before_change": "xmlPushInput(xmlParserCtxtPtr ctxt, xmlParserInputPtr input) {\n    int ret;\n    if (input == NULL) return(-1);\n\n    if (xmlParserDebugEntities) {\n\tif ((ctxt->input != NULL) && (ctxt->input->filename))\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"%s(%d): \", ctxt->input->filename,\n\t\t    ctxt->input->line);\n\txmlGenericError(xmlGenericErrorContext,\n \t\t\"Pushing input %d : %.30s\\n\", ctxt->inputNr+1, input->cur);\n     }\n     ret = inputPush(ctxt, input);\n     GROW;\n     return(ret);\n }\n",
    "code_after_change": "xmlPushInput(xmlParserCtxtPtr ctxt, xmlParserInputPtr input) {\n    int ret;\n    if (input == NULL) return(-1);\n\n    if (xmlParserDebugEntities) {\n\tif ((ctxt->input != NULL) && (ctxt->input->filename))\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"%s(%d): \", ctxt->input->filename,\n\t\t    ctxt->input->line);\n\txmlGenericError(xmlGenericErrorContext,\n \t\t\"Pushing input %d : %.30s\\n\", ctxt->inputNr+1, input->cur);\n     }\n     ret = inputPush(ctxt, input);\n    if (ctxt->instate == XML_PARSER_EOF)\n        return(-1);\n     GROW;\n     return(ret);\n }\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 354,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2013-2877",
    "code_before_change": "xmlParseCharDataComplex(xmlParserCtxtPtr ctxt, int cdata) {\n    xmlChar buf[XML_PARSER_BIG_BUFFER_SIZE + 5];\n    int nbchar = 0;\n    int cur, l;\n    int count = 0;\n\n    SHRINK;\n    GROW;\n    cur = CUR_CHAR(l);\n    while ((cur != '<') && /* checked */\n           (cur != '&') && \n\t   (IS_CHAR(cur))) /* test also done in xmlCurrentChar() */ {\n\tif ((cur == ']') && (NXT(1) == ']') &&\n\t    (NXT(2) == '>')) {\n\t    if (cdata) break;\n\t    else {\n\t\txmlFatalErr(ctxt, XML_ERR_MISPLACED_CDATA_END, NULL);\n\t    }\n\t}\n\tCOPY_BUF(l,buf,nbchar,cur);\n\tif (nbchar >= XML_PARSER_BIG_BUFFER_SIZE) {\n\t    buf[nbchar] = 0;\n\n\t    /*\n\t     * OK the segment is to be consumed as chars.\n\t     */\n\t    if ((ctxt->sax != NULL) && (!ctxt->disableSAX)) {\n\t\tif (areBlanks(ctxt, buf, nbchar, 0)) {\n\t\t    if (ctxt->sax->ignorableWhitespace != NULL)\n\t\t\tctxt->sax->ignorableWhitespace(ctxt->userData,\n\t\t\t                               buf, nbchar);\n\t\t} else {\n\t\t    if (ctxt->sax->characters != NULL)\n\t\t\tctxt->sax->characters(ctxt->userData, buf, nbchar);\n\t\t    if ((ctxt->sax->characters !=\n\t\t         ctxt->sax->ignorableWhitespace) &&\n\t\t\t(*ctxt->space == -1))\n\t\t\t*ctxt->space = -2;\n\t\t}\n\t    }\n\t    nbchar = 0;\n            /* something really bad happened in the SAX callback */\n            if (ctxt->instate != XML_PARSER_CONTENT)\n                return;\n\t}\n\tcount++;\n \tif (count > 50) {\n \t    GROW;\n \t    count = 0;\n \t}\n \tNEXTL(l);\n \tcur = CUR_CHAR(l);\n    }\n    if (nbchar != 0) {\n        buf[nbchar] = 0;\n\t/*\n\t * OK the segment is to be consumed as chars.\n\t */\n\tif ((ctxt->sax != NULL) && (!ctxt->disableSAX)) {\n\t    if (areBlanks(ctxt, buf, nbchar, 0)) {\n\t\tif (ctxt->sax->ignorableWhitespace != NULL)\n\t\t    ctxt->sax->ignorableWhitespace(ctxt->userData, buf, nbchar);\n\t    } else {\n\t\tif (ctxt->sax->characters != NULL)\n\t\t    ctxt->sax->characters(ctxt->userData, buf, nbchar);\n\t\tif ((ctxt->sax->characters != ctxt->sax->ignorableWhitespace) &&\n\t\t    (*ctxt->space == -1))\n\t\t    *ctxt->space = -2;\n\t    }\n\t}\n    }\n    if ((cur != 0) && (!IS_CHAR(cur))) {\n\t/* Generate the error and skip the offending character */\n        xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,\n                          \"PCDATA invalid Char value %d\\n\",\n\t                  cur);\n\tNEXTL(l);\n    }\n}\n",
    "code_after_change": "xmlParseCharDataComplex(xmlParserCtxtPtr ctxt, int cdata) {\n    xmlChar buf[XML_PARSER_BIG_BUFFER_SIZE + 5];\n    int nbchar = 0;\n    int cur, l;\n    int count = 0;\n\n    SHRINK;\n    GROW;\n    cur = CUR_CHAR(l);\n    while ((cur != '<') && /* checked */\n           (cur != '&') && \n\t   (IS_CHAR(cur))) /* test also done in xmlCurrentChar() */ {\n\tif ((cur == ']') && (NXT(1) == ']') &&\n\t    (NXT(2) == '>')) {\n\t    if (cdata) break;\n\t    else {\n\t\txmlFatalErr(ctxt, XML_ERR_MISPLACED_CDATA_END, NULL);\n\t    }\n\t}\n\tCOPY_BUF(l,buf,nbchar,cur);\n\tif (nbchar >= XML_PARSER_BIG_BUFFER_SIZE) {\n\t    buf[nbchar] = 0;\n\n\t    /*\n\t     * OK the segment is to be consumed as chars.\n\t     */\n\t    if ((ctxt->sax != NULL) && (!ctxt->disableSAX)) {\n\t\tif (areBlanks(ctxt, buf, nbchar, 0)) {\n\t\t    if (ctxt->sax->ignorableWhitespace != NULL)\n\t\t\tctxt->sax->ignorableWhitespace(ctxt->userData,\n\t\t\t                               buf, nbchar);\n\t\t} else {\n\t\t    if (ctxt->sax->characters != NULL)\n\t\t\tctxt->sax->characters(ctxt->userData, buf, nbchar);\n\t\t    if ((ctxt->sax->characters !=\n\t\t         ctxt->sax->ignorableWhitespace) &&\n\t\t\t(*ctxt->space == -1))\n\t\t\t*ctxt->space = -2;\n\t\t}\n\t    }\n\t    nbchar = 0;\n            /* something really bad happened in the SAX callback */\n            if (ctxt->instate != XML_PARSER_CONTENT)\n                return;\n\t}\n\tcount++;\n \tif (count > 50) {\n \t    GROW;\n \t    count = 0;\n            if (ctxt->instate == XML_PARSER_EOF)\n\t\treturn;\n \t}\n \tNEXTL(l);\n \tcur = CUR_CHAR(l);\n    }\n    if (nbchar != 0) {\n        buf[nbchar] = 0;\n\t/*\n\t * OK the segment is to be consumed as chars.\n\t */\n\tif ((ctxt->sax != NULL) && (!ctxt->disableSAX)) {\n\t    if (areBlanks(ctxt, buf, nbchar, 0)) {\n\t\tif (ctxt->sax->ignorableWhitespace != NULL)\n\t\t    ctxt->sax->ignorableWhitespace(ctxt->userData, buf, nbchar);\n\t    } else {\n\t\tif (ctxt->sax->characters != NULL)\n\t\t    ctxt->sax->characters(ctxt->userData, buf, nbchar);\n\t\tif ((ctxt->sax->characters != ctxt->sax->ignorableWhitespace) &&\n\t\t    (*ctxt->space == -1))\n\t\t    *ctxt->space = -2;\n\t    }\n\t}\n    }\n    if ((cur != 0) && (!IS_CHAR(cur))) {\n\t/* Generate the error and skip the offending character */\n        xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,\n                          \"PCDATA invalid Char value %d\\n\",\n\t                  cur);\n\tNEXTL(l);\n    }\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 357,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2018-14358",
    "code_before_change": "static int msg_parse_fetch(struct ImapHeader *h, char *s)\n{\n  char tmp[SHORT_STRING];\n  char *ptmp = NULL;\n\n  if (!s)\n    return -1;\n\n  while (*s)\n  {\n    SKIPWS(s);\n\n    if (mutt_str_strncasecmp(\"FLAGS\", s, 5) == 0)\n    {\n      s = msg_parse_flags(h, s);\n      if (!s)\n        return -1;\n    }\n    else if (mutt_str_strncasecmp(\"UID\", s, 3) == 0)\n    {\n      s += 3;\n      SKIPWS(s);\n      if (mutt_str_atoui(s, &h->data->uid) < 0)\n        return -1;\n\n      s = imap_next_word(s);\n    }\n    else if (mutt_str_strncasecmp(\"INTERNALDATE\", s, 12) == 0)\n    {\n      s += 12;\n      SKIPWS(s);\n      if (*s != '\\\"')\n      {\n        mutt_debug(1, \"bogus INTERNALDATE entry: %s\\n\", s);\n        return -1;\n       }\n       s++;\n       ptmp = tmp;\n      while (*s && *s != '\\\"')\n         *ptmp++ = *s++;\n       if (*s != '\\\"')\n         return -1;\n      s++; /* skip past the trailing \" */\n      *ptmp = '\\0';\n      h->received = mutt_date_parse_imap(tmp);\n    }\n    else if (mutt_str_strncasecmp(\"RFC822.SIZE\", s, 11) == 0)\n    {\n       s += 11;\n       SKIPWS(s);\n       ptmp = tmp;\n      while (isdigit((unsigned char) *s))\n         *ptmp++ = *s++;\n       *ptmp = '\\0';\n       if (mutt_str_atol(tmp, &h->content_length) < 0)\n        return -1;\n    }\n    else if ((mutt_str_strncasecmp(\"BODY\", s, 4) == 0) ||\n             (mutt_str_strncasecmp(\"RFC822.HEADER\", s, 13) == 0))\n    {\n      /* handle above, in msg_fetch_header */\n      return -2;\n    }\n    else if (*s == ')')\n      s++; /* end of request */\n    else if (*s)\n    {\n      /* got something i don't understand */\n      imap_error(\"msg_parse_fetch\", s);\n      return -1;\n    }\n  }\n\n  return 0;\n}\n",
    "code_after_change": "static int msg_parse_fetch(struct ImapHeader *h, char *s)\n{\n  char tmp[SHORT_STRING];\n  char *ptmp = NULL;\n\n  if (!s)\n    return -1;\n\n  while (*s)\n  {\n    SKIPWS(s);\n\n    if (mutt_str_strncasecmp(\"FLAGS\", s, 5) == 0)\n    {\n      s = msg_parse_flags(h, s);\n      if (!s)\n        return -1;\n    }\n    else if (mutt_str_strncasecmp(\"UID\", s, 3) == 0)\n    {\n      s += 3;\n      SKIPWS(s);\n      if (mutt_str_atoui(s, &h->data->uid) < 0)\n        return -1;\n\n      s = imap_next_word(s);\n    }\n    else if (mutt_str_strncasecmp(\"INTERNALDATE\", s, 12) == 0)\n    {\n      s += 12;\n      SKIPWS(s);\n      if (*s != '\\\"')\n      {\n        mutt_debug(1, \"bogus INTERNALDATE entry: %s\\n\", s);\n        return -1;\n       }\n       s++;\n       ptmp = tmp;\n      while (*s && (*s != '\\\"') && (ptmp != (tmp + sizeof(tmp) - 1)))\n         *ptmp++ = *s++;\n       if (*s != '\\\"')\n         return -1;\n      s++; /* skip past the trailing \" */\n      *ptmp = '\\0';\n      h->received = mutt_date_parse_imap(tmp);\n    }\n    else if (mutt_str_strncasecmp(\"RFC822.SIZE\", s, 11) == 0)\n    {\n       s += 11;\n       SKIPWS(s);\n       ptmp = tmp;\n      while (isdigit((unsigned char) *s) && (ptmp != (tmp + sizeof(tmp) - 1)))\n         *ptmp++ = *s++;\n       *ptmp = '\\0';\n       if (mutt_str_atol(tmp, &h->content_length) < 0)\n        return -1;\n    }\n    else if ((mutt_str_strncasecmp(\"BODY\", s, 4) == 0) ||\n             (mutt_str_strncasecmp(\"RFC822.HEADER\", s, 13) == 0))\n    {\n      /* handle above, in msg_fetch_header */\n      return -2;\n    }\n    else if (*s == ')')\n      s++; /* end of request */\n    else if (*s)\n    {\n      /* got something i don't understand */\n      imap_error(\"msg_parse_fetch\", s);\n      return -1;\n    }\n  }\n\n  return 0;\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 362,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2011-3353",
    "code_before_change": "static int fuse_notify_inval_entry(struct fuse_conn *fc, unsigned int size,\n\t\t\t\t   struct fuse_copy_state *cs)\n{\n\tstruct fuse_notify_inval_entry_out outarg;\n\tint err = -ENOMEM;\n\tchar *buf;\n\tstruct qstr name;\n\n\tbuf = kzalloc(FUSE_NAME_MAX + 1, GFP_KERNEL);\n\tif (!buf)\n\t\tgoto err;\n\n\terr = -EINVAL;\n\tif (size < sizeof(outarg))\n\t\tgoto err;\n\n\terr = fuse_copy_one(cs, &outarg, sizeof(outarg));\n\tif (err)\n\t\tgoto err;\n\n\terr = -ENAMETOOLONG;\n \tif (outarg.namelen > FUSE_NAME_MAX)\n \t\tgoto err;\n \n \tname.name = buf;\n \tname.len = outarg.namelen;\n \terr = fuse_copy_one(cs, buf, outarg.namelen + 1);\n\tif (err)\n\t\tgoto err;\n\tfuse_copy_finish(cs);\n\tbuf[outarg.namelen] = 0;\n\tname.hash = full_name_hash(name.name, name.len);\n\n\tdown_read(&fc->killsb);\n\terr = -ENOENT;\n\tif (fc->sb)\n\t\terr = fuse_reverse_inval_entry(fc->sb, outarg.parent, &name);\n\tup_read(&fc->killsb);\n\tkfree(buf);\n\treturn err;\n\nerr:\n\tkfree(buf);\n\tfuse_copy_finish(cs);\n\treturn err;\n}\n",
    "code_after_change": "static int fuse_notify_inval_entry(struct fuse_conn *fc, unsigned int size,\n\t\t\t\t   struct fuse_copy_state *cs)\n{\n\tstruct fuse_notify_inval_entry_out outarg;\n\tint err = -ENOMEM;\n\tchar *buf;\n\tstruct qstr name;\n\n\tbuf = kzalloc(FUSE_NAME_MAX + 1, GFP_KERNEL);\n\tif (!buf)\n\t\tgoto err;\n\n\terr = -EINVAL;\n\tif (size < sizeof(outarg))\n\t\tgoto err;\n\n\terr = fuse_copy_one(cs, &outarg, sizeof(outarg));\n\tif (err)\n\t\tgoto err;\n\n\terr = -ENAMETOOLONG;\n \tif (outarg.namelen > FUSE_NAME_MAX)\n \t\tgoto err;\n \n\terr = -EINVAL;\n\tif (size != sizeof(outarg) + outarg.namelen + 1)\n\t\tgoto err;\n\n \tname.name = buf;\n \tname.len = outarg.namelen;\n \terr = fuse_copy_one(cs, buf, outarg.namelen + 1);\n\tif (err)\n\t\tgoto err;\n\tfuse_copy_finish(cs);\n\tbuf[outarg.namelen] = 0;\n\tname.hash = full_name_hash(name.name, name.len);\n\n\tdown_read(&fc->killsb);\n\terr = -ENOENT;\n\tif (fc->sb)\n\t\terr = fuse_reverse_inval_entry(fc->sb, outarg.parent, &name);\n\tup_read(&fc->killsb);\n\tkfree(buf);\n\treturn err;\n\nerr:\n\tkfree(buf);\n\tfuse_copy_finish(cs);\n\treturn err;\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 365,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-7115",
    "code_before_change": "static void handle_data_packet(struct mt_connection *curconn, struct mt_mactelnet_hdr *pkthdr, int data_len) {\n\tstruct mt_mactelnet_control_hdr cpkt;\n\tstruct mt_packet pdata;\n\tunsigned char *data = pkthdr->data;\n\tunsigned int act_size = 0;\n\tint got_user_packet = 0;\n\tint got_pass_packet = 0;\n\tint got_width_packet = 0;\n\tint got_height_packet = 0;\n\tint success;\n\n\t/* Parse first control packet */\n\tsuccess = parse_control_packet(data, data_len - MT_HEADER_LEN, &cpkt);\n\n\twhile (success) {\n\t\tif (cpkt.cptype == MT_CPTYPE_BEGINAUTH) {\n\t\t\tint plen,i;\n\t\t\tif (!curconn->have_pass_salt) {\n\t\t\t\tfor (i = 0; i < 16; ++i) {\n\t\t\t\t\tcurconn->pass_salt[i] = rand() % 256;\n\t\t\t\t}\n\t\t\t\tcurconn->have_pass_salt = 1;\n\n\t\t\t\tmemset(curconn->trypassword, 0, sizeof(curconn->trypassword));\n\t\t\t}\n\t\t\tinit_packet(&pdata, MT_PTYPE_DATA, pkthdr->dstaddr, pkthdr->srcaddr, pkthdr->seskey, curconn->outcounter);\n\t\t\tplen = add_control_packet(&pdata, MT_CPTYPE_PASSSALT, (curconn->pass_salt), 16);\n\t\t\tcurconn->outcounter += plen;\n\n\t\t\tsend_udp(curconn, &pdata);\n\t\t\n\t\t/* Don't change the username after the state is active */\n\t\t} else if (cpkt.cptype == MT_CPTYPE_USERNAME && curconn->state != STATE_ACTIVE) {\n\t\t\tmemcpy(curconn->username, cpkt.data, act_size = (cpkt.length > MT_MNDP_MAX_STRING_SIZE - 1 ? MT_MNDP_MAX_STRING_SIZE - 1 : cpkt.length));\n\t\t\tcurconn->username[act_size] = 0;\n\t\t\tgot_user_packet = 1;\n\n\t\t} else if (cpkt.cptype == MT_CPTYPE_TERM_WIDTH && cpkt.length >= 2) {\n\t\t\tunsigned short width;\n\n\t\t\tmemcpy(&width, cpkt.data, 2);\n\t\t\tcurconn->terminal_width = le16toh(width);\n\t\t\tgot_width_packet = 1;\n\n\t\t} else if (cpkt.cptype == MT_CPTYPE_TERM_HEIGHT && cpkt.length >= 2) {\n\t\t\tunsigned short height;\n\n\t\t\tmemcpy(&height, cpkt.data, 2);\n\t\t\tcurconn->terminal_height = le16toh(height);\n\t\t\tgot_height_packet = 1;\n\n\t\t} else if (cpkt.cptype == MT_CPTYPE_TERM_TYPE) {\n\n \t\t\tmemcpy(curconn->terminal_type, cpkt.data, act_size = (cpkt.length > 30 - 1 ? 30 - 1 : cpkt.length));\n \t\t\tcurconn->terminal_type[act_size] = 0;\n \n\t\t} else if (cpkt.cptype == MT_CPTYPE_PASSWORD) {\n \n #if defined(__linux__) && defined(_POSIX_MEMLOCK_RANGE)\n \t\t\tmlock(curconn->trypassword, 17);\n#endif\n\t\t\tmemcpy(curconn->trypassword, cpkt.data, 17);\n\t\t\tgot_pass_packet = 1;\n\n\t\t} else if (cpkt.cptype == MT_CPTYPE_PLAINDATA) {\n\n\t\t\t/* relay data from client to shell */\n\t\t\tif (curconn->state == STATE_ACTIVE && curconn->ptsfd != -1) {\n\t\t\t\twrite(curconn->ptsfd, cpkt.data, cpkt.length);\n \t\t\t}\n \n \t\t} else {\n\t\t\tsyslog(LOG_WARNING, _(\"(%d) Unhandeled control packet type: %d\"), curconn->seskey, cpkt.cptype);\n \t\t}\n \n \t\t/* Parse next control packet */\n\t\tsuccess = parse_control_packet(NULL, 0, &cpkt);\n\t}\n\n\tif (got_user_packet && got_pass_packet) {\n\t\tuser_login(curconn, pkthdr);\n\t}\n\n\tif (curconn->state == STATE_ACTIVE && (got_width_packet || got_height_packet)) {\n\t\tset_terminal_size(curconn->ptsfd, curconn->terminal_width, curconn->terminal_height);\n\n\t}\n}\n",
    "code_after_change": "static void handle_data_packet(struct mt_connection *curconn, struct mt_mactelnet_hdr *pkthdr, int data_len) {\n\tstruct mt_mactelnet_control_hdr cpkt;\n\tstruct mt_packet pdata;\n\tunsigned char *data = pkthdr->data;\n\tunsigned int act_size = 0;\n\tint got_user_packet = 0;\n\tint got_pass_packet = 0;\n\tint got_width_packet = 0;\n\tint got_height_packet = 0;\n\tint success;\n\n\t/* Parse first control packet */\n\tsuccess = parse_control_packet(data, data_len - MT_HEADER_LEN, &cpkt);\n\n\twhile (success) {\n\t\tif (cpkt.cptype == MT_CPTYPE_BEGINAUTH) {\n\t\t\tint plen,i;\n\t\t\tif (!curconn->have_pass_salt) {\n\t\t\t\tfor (i = 0; i < 16; ++i) {\n\t\t\t\t\tcurconn->pass_salt[i] = rand() % 256;\n\t\t\t\t}\n\t\t\t\tcurconn->have_pass_salt = 1;\n\n\t\t\t\tmemset(curconn->trypassword, 0, sizeof(curconn->trypassword));\n\t\t\t}\n\t\t\tinit_packet(&pdata, MT_PTYPE_DATA, pkthdr->dstaddr, pkthdr->srcaddr, pkthdr->seskey, curconn->outcounter);\n\t\t\tplen = add_control_packet(&pdata, MT_CPTYPE_PASSSALT, (curconn->pass_salt), 16);\n\t\t\tcurconn->outcounter += plen;\n\n\t\t\tsend_udp(curconn, &pdata);\n\t\t\n\t\t/* Don't change the username after the state is active */\n\t\t} else if (cpkt.cptype == MT_CPTYPE_USERNAME && curconn->state != STATE_ACTIVE) {\n\t\t\tmemcpy(curconn->username, cpkt.data, act_size = (cpkt.length > MT_MNDP_MAX_STRING_SIZE - 1 ? MT_MNDP_MAX_STRING_SIZE - 1 : cpkt.length));\n\t\t\tcurconn->username[act_size] = 0;\n\t\t\tgot_user_packet = 1;\n\n\t\t} else if (cpkt.cptype == MT_CPTYPE_TERM_WIDTH && cpkt.length >= 2) {\n\t\t\tunsigned short width;\n\n\t\t\tmemcpy(&width, cpkt.data, 2);\n\t\t\tcurconn->terminal_width = le16toh(width);\n\t\t\tgot_width_packet = 1;\n\n\t\t} else if (cpkt.cptype == MT_CPTYPE_TERM_HEIGHT && cpkt.length >= 2) {\n\t\t\tunsigned short height;\n\n\t\t\tmemcpy(&height, cpkt.data, 2);\n\t\t\tcurconn->terminal_height = le16toh(height);\n\t\t\tgot_height_packet = 1;\n\n\t\t} else if (cpkt.cptype == MT_CPTYPE_TERM_TYPE) {\n\n \t\t\tmemcpy(curconn->terminal_type, cpkt.data, act_size = (cpkt.length > 30 - 1 ? 30 - 1 : cpkt.length));\n \t\t\tcurconn->terminal_type[act_size] = 0;\n \n\t\t} else if (cpkt.cptype == MT_CPTYPE_PASSWORD && cpkt.length == 17) {\n \n #if defined(__linux__) && defined(_POSIX_MEMLOCK_RANGE)\n \t\t\tmlock(curconn->trypassword, 17);\n#endif\n\t\t\tmemcpy(curconn->trypassword, cpkt.data, 17);\n\t\t\tgot_pass_packet = 1;\n\n\t\t} else if (cpkt.cptype == MT_CPTYPE_PLAINDATA) {\n\n\t\t\t/* relay data from client to shell */\n\t\t\tif (curconn->state == STATE_ACTIVE && curconn->ptsfd != -1) {\n\t\t\t\twrite(curconn->ptsfd, cpkt.data, cpkt.length);\n \t\t\t}\n \n \t\t} else {\n\t\t\tsyslog(LOG_WARNING, _(\"(%d) Unhandeled control packet type: %d, length: %d\"), curconn->seskey, cpkt.cptype, cpkt.length);\n \t\t}\n \n \t\t/* Parse next control packet */\n\t\tsuccess = parse_control_packet(NULL, 0, &cpkt);\n\t}\n\n\tif (got_user_packet && got_pass_packet) {\n\t\tuser_login(curconn, pkthdr);\n\t}\n\n\tif (curconn->state == STATE_ACTIVE && (got_width_packet || got_height_packet)) {\n\t\tset_terminal_size(curconn->ptsfd, curconn->terminal_width, curconn->terminal_height);\n\n\t}\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 379,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2012-1571",
    "code_before_change": "cdf_read_short_sector_chain(const cdf_header_t *h,\n     const cdf_sat_t *ssat, const cdf_stream_t *sst,\n     cdf_secid_t sid, size_t len, cdf_stream_t *scn)\n {\n\tsize_t ss = CDF_SEC_SIZE(h), i, j;\n \tscn->sst_len = cdf_count_chain(ssat, sid, CDF_SEC_SIZE(h));\n \tscn->sst_dirlen = len;\n \n\tif (sst->sst_tab == NULL || scn->sst_len == (size_t)-1)\n\t\treturn -1;\n\n\tscn->sst_tab = calloc(scn->sst_len, ss);\n\tif (scn->sst_tab == NULL)\n\t\treturn -1;\n\n\tfor (j = i = 0; sid >= 0; i++, j++) {\n\t\tif (j >= CDF_LOOP_LIMIT) {\n\t\t\tDPRINTF((\"Read short sector chain loop limit\"));\n\t\t\terrno = EFTYPE;\n\t\t\tgoto out;\n\t\t}\n\t\tif (i >= scn->sst_len) {\n\t\t\tDPRINTF((\"Out of bounds reading short sector chain \"\n\t\t\t    \"%\" SIZE_T_FORMAT \"u > %\" SIZE_T_FORMAT \"u\\n\",\n\t\t\t    i, scn->sst_len));\n\t\t\terrno = EFTYPE;\n\t\t\tgoto out;\n\t\t}\n\t\tif (cdf_read_short_sector(sst, scn->sst_tab, i * ss, ss, h,\n\t\t    sid) != (ssize_t)ss) {\n\t\t\tDPRINTF((\"Reading short sector chain %d\", sid));\n\t\t\tgoto out;\n\t\t}\n\t\tsid = CDF_TOLE4((uint32_t)ssat->sat_tab[sid]);\n\t}\n\treturn 0;\nout:\n\tfree(scn->sst_tab);\n\treturn -1;\n}\n",
    "code_after_change": "cdf_read_short_sector_chain(const cdf_header_t *h,\n     const cdf_sat_t *ssat, const cdf_stream_t *sst,\n     cdf_secid_t sid, size_t len, cdf_stream_t *scn)\n {\n\tsize_t ss = CDF_SHORT_SEC_SIZE(h), i, j;\n \tscn->sst_len = cdf_count_chain(ssat, sid, CDF_SEC_SIZE(h));\n \tscn->sst_dirlen = len;\n \n\tif (sst->sst_tab == NULL || scn->sst_len == (size_t)-1)\n\t\treturn -1;\n\n\tscn->sst_tab = calloc(scn->sst_len, ss);\n\tif (scn->sst_tab == NULL)\n\t\treturn -1;\n\n\tfor (j = i = 0; sid >= 0; i++, j++) {\n\t\tif (j >= CDF_LOOP_LIMIT) {\n\t\t\tDPRINTF((\"Read short sector chain loop limit\"));\n\t\t\terrno = EFTYPE;\n\t\t\tgoto out;\n\t\t}\n\t\tif (i >= scn->sst_len) {\n\t\t\tDPRINTF((\"Out of bounds reading short sector chain \"\n\t\t\t    \"%\" SIZE_T_FORMAT \"u > %\" SIZE_T_FORMAT \"u\\n\",\n\t\t\t    i, scn->sst_len));\n\t\t\terrno = EFTYPE;\n\t\t\tgoto out;\n\t\t}\n\t\tif (cdf_read_short_sector(sst, scn->sst_tab, i * ss, ss, h,\n\t\t    sid) != (ssize_t)ss) {\n\t\t\tDPRINTF((\"Reading short sector chain %d\", sid));\n\t\t\tgoto out;\n\t\t}\n\t\tsid = CDF_TOLE4((uint32_t)ssat->sat_tab[sid]);\n\t}\n\treturn 0;\nout:\n\tfree(scn->sst_tab);\n\treturn -1;\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 392,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2018-10184",
    "code_before_change": "static void h2_process_demux(struct h2c *h2c)\n{\n\tstruct h2s *h2s;\n\n\tif (h2c->st0 >= H2_CS_ERROR)\n\t\treturn;\n\n\tif (unlikely(h2c->st0 < H2_CS_FRAME_H)) {\n\t\tif (h2c->st0 == H2_CS_PREFACE) {\n\t\t\tif (unlikely(h2c_frt_recv_preface(h2c) <= 0)) {\n\t\t\t\t/* RFC7540#3.5: a GOAWAY frame MAY be omitted */\n\t\t\t\tif (h2c->st0 == H2_CS_ERROR)\n\t\t\t\t\th2c->st0 = H2_CS_ERROR2;\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\th2c->max_id = 0;\n\t\t\th2c->st0 = H2_CS_SETTINGS1;\n\t\t}\n\n\t\tif (h2c->st0 == H2_CS_SETTINGS1) {\n\t\t\tstruct h2_fh hdr;\n\n\t\t\t/* ensure that what is pending is a valid SETTINGS frame\n\t\t\t * without an ACK.\n\t\t\t */\n\t\t\tif (!h2_get_frame_hdr(h2c->dbuf, &hdr)) {\n\t\t\t\t/* RFC7540#3.5: a GOAWAY frame MAY be omitted */\n\t\t\t\tif (h2c->st0 == H2_CS_ERROR)\n\t\t\t\t\th2c->st0 = H2_CS_ERROR2;\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tif (hdr.sid || hdr.ft != H2_FT_SETTINGS || hdr.ff & H2_F_SETTINGS_ACK) {\n\t\t\t\t/* RFC7540#3.5: a GOAWAY frame MAY be omitted */\n\t\t\t\th2c_error(h2c, H2_ERR_PROTOCOL_ERROR);\n\t\t\t\th2c->st0 = H2_CS_ERROR2;\n                                goto fail;\n                        }\n \n                       if ((int)hdr.len < 0 || (int)hdr.len > h2c->mfs) {\n                                /* RFC7540#3.5: a GOAWAY frame MAY be omitted */\n                                h2c_error(h2c, H2_ERR_FRAME_SIZE_ERROR);\n                                h2c->st0 = H2_CS_ERROR2;\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\t/* that's OK, switch to FRAME_P to process it */\n\t\t\th2c->dfl = hdr.len;\n\t\t\th2c->dsi = hdr.sid;\n\t\t\th2c->dft = hdr.ft;\n\t\t\th2c->dff = hdr.ff;\n\t\t\th2c->dpl = 0;\n\t\t\th2c->st0 = H2_CS_FRAME_P;\n\t\t}\n\t}\n\n\t/* process as many incoming frames as possible below */\n\twhile (h2c->dbuf->i) {\n\t\tint ret = 0;\n\n\t\tif (h2c->st0 >= H2_CS_ERROR)\n\t\t\tbreak;\n\n\t\tif (h2c->st0 == H2_CS_FRAME_H) {\n\t\t\tstruct h2_fh hdr;\n\n                        if (!h2_peek_frame_hdr(h2c->dbuf, &hdr))\n                                break;\n \n                       if ((int)hdr.len < 0 || (int)hdr.len > h2c->mfs) {\n                                h2c_error(h2c, H2_ERR_FRAME_SIZE_ERROR);\n                                h2c->st0 = H2_CS_ERROR;\n                                break;\n\t\t\t}\n\n\t\t\th2c->dfl = hdr.len;\n\t\t\th2c->dsi = hdr.sid;\n\t\t\th2c->dft = hdr.ft;\n\t\t\th2c->dff = hdr.ff;\n\t\t\th2c->dpl = 0;\n\t\t\th2c->st0 = H2_CS_FRAME_P;\n\t\t\th2_skip_frame_hdr(h2c->dbuf);\n\t\t}\n\n\t\t/* Only H2_CS_FRAME_P and H2_CS_FRAME_A here */\n\t\th2s = h2c_st_by_id(h2c, h2c->dsi);\n\n\t\tif (h2c->st0 == H2_CS_FRAME_E)\n\t\t\tgoto strm_err;\n\n\t\tif (h2s->st == H2_SS_IDLE &&\n\t\t    h2c->dft != H2_FT_HEADERS && h2c->dft != H2_FT_PRIORITY) {\n\t\t\t/* RFC7540#5.1: any frame other than HEADERS or PRIORITY in\n\t\t\t * this state MUST be treated as a connection error\n\t\t\t */\n\t\t\th2c_error(h2c, H2_ERR_PROTOCOL_ERROR);\n\t\t\th2c->st0 = H2_CS_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (h2s->st == H2_SS_HREM && h2c->dft != H2_FT_WINDOW_UPDATE &&\n\t\t    h2c->dft != H2_FT_RST_STREAM && h2c->dft != H2_FT_PRIORITY) {\n\t\t\t/* RFC7540#5.1: any frame other than WU/PRIO/RST in\n\t\t\t * this state MUST be treated as a stream error\n\t\t\t */\n\t\t\th2s_error(h2s, H2_ERR_STREAM_CLOSED);\n\t\t\th2c->st0 = H2_CS_FRAME_E;\n\t\t\tgoto strm_err;\n\t\t}\n\n\t\t/* Below the management of frames received in closed state is a\n\t\t * bit hackish because the spec makes strong differences between\n\t\t * streams closed by receiving RST, sending RST, and seeing ES\n\t\t * in both directions. In addition to this, the creation of a\n\t\t * new stream reusing the identifier of a closed one will be\n\t\t * detected here. Given that we cannot keep track of all closed\n\t\t * streams forever, we consider that unknown closed streams were\n\t\t * closed on RST received, which allows us to respond with an\n\t\t * RST without breaking the connection (eg: to abort a transfer).\n\t\t * Some frames have to be silently ignored as well.\n\t\t */\n\t\tif (h2s->st == H2_SS_CLOSED && h2c->dsi) {\n\t\t\tif (h2c->dft == H2_FT_HEADERS || h2c->dft == H2_FT_PUSH_PROMISE) {\n\t\t\t\t/* #5.1.1: The identifier of a newly\n\t\t\t\t * established stream MUST be numerically\n\t\t\t\t * greater than all streams that the initiating\n\t\t\t\t * endpoint has opened or reserved. This\n\t\t\t\t * governs streams that are opened using a\n\t\t\t\t * HEADERS frame and streams that are reserved\n\t\t\t\t * using PUSH_PROMISE. An endpoint that\n\t\t\t\t * receives an unexpected stream identifier\n\t\t\t\t * MUST respond with a connection error.\n\t\t\t\t */\n\t\t\t\th2c_error(h2c, H2_ERR_STREAM_CLOSED);\n\t\t\t\tgoto strm_err;\n\t\t\t}\n\n\t\t\tif (h2s->flags & H2_SF_RST_RCVD) {\n\t\t\t\t/* RFC7540#5.1:closed: an endpoint that\n\t\t\t\t * receives any frame other than PRIORITY after\n\t\t\t\t * receiving a RST_STREAM MUST treat that as a\n\t\t\t\t * stream error of type STREAM_CLOSED.\n\t\t\t\t *\n\t\t\t\t * Note that old streams fall into this category\n\t\t\t\t * and will lead to an RST being sent.\n\t\t\t\t */\n\t\t\t\th2s_error(h2s, H2_ERR_STREAM_CLOSED);\n\t\t\t\th2c->st0 = H2_CS_FRAME_E;\n\t\t\t\tgoto strm_err;\n\t\t\t}\n\n\t\t\t/* RFC7540#5.1:closed: if this state is reached as a\n\t\t\t * result of sending a RST_STREAM frame, the peer that\n\t\t\t * receives the RST_STREAM might have already sent\n\t\t\t * frames on the stream that cannot be withdrawn. An\n\t\t\t * endpoint MUST ignore frames that it receives on\n\t\t\t * closed streams after it has sent a RST_STREAM\n\t\t\t * frame. An endpoint MAY choose to limit the period\n\t\t\t * over which it ignores frames and treat frames that\n\t\t\t * arrive after this time as being in error.\n\t\t\t */\n\t\t\tif (!(h2s->flags & H2_SF_RST_SENT)) {\n\t\t\t\t/* RFC7540#5.1:closed: any frame other than\n\t\t\t\t * PRIO/WU/RST in this state MUST be treated as\n\t\t\t\t * a connection error\n\t\t\t\t */\n\t\t\t\tif (h2c->dft != H2_FT_RST_STREAM &&\n\t\t\t\t    h2c->dft != H2_FT_PRIORITY &&\n\t\t\t\t    h2c->dft != H2_FT_WINDOW_UPDATE) {\n\t\t\t\t\th2c_error(h2c, H2_ERR_STREAM_CLOSED);\n\t\t\t\t\tgoto strm_err;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n#if 0\n\n\t\t/* graceful shutdown, ignore streams whose ID is higher than\n\t\t * the one advertised in GOAWAY. RFC7540#6.8.\n\t\t */\n\t\tif (unlikely(h2c->last_sid >= 0) && h2c->dsi > h2c->last_sid) {\n\t\t\tret = MIN(h2c->dbuf->i, h2c->dfl);\n\t\t\tbi_del(h2c->dbuf, ret);\n\t\t\th2c->dfl -= ret;\n\t\t\tret = h2c->dfl == 0;\n\t\t\tgoto strm_err;\n\t\t}\n#endif\n\n\t\tswitch (h2c->dft) {\n\t\tcase H2_FT_SETTINGS:\n\t\t\tif (h2c->st0 == H2_CS_FRAME_P)\n\t\t\t\tret = h2c_handle_settings(h2c);\n\n\t\t\tif (h2c->st0 == H2_CS_FRAME_A)\n\t\t\t\tret = h2c_ack_settings(h2c);\n\t\t\tbreak;\n\n\t\tcase H2_FT_PING:\n\t\t\tif (h2c->st0 == H2_CS_FRAME_P)\n\t\t\t\tret = h2c_handle_ping(h2c);\n\n\t\t\tif (h2c->st0 == H2_CS_FRAME_A)\n\t\t\t\tret = h2c_ack_ping(h2c);\n\t\t\tbreak;\n\n\t\tcase H2_FT_WINDOW_UPDATE:\n\t\t\tif (h2c->st0 == H2_CS_FRAME_P)\n\t\t\t\tret = h2c_handle_window_update(h2c, h2s);\n\t\t\tbreak;\n\n\t\tcase H2_FT_CONTINUATION:\n\t\t\t/* we currently don't support CONTINUATION frames since\n\t\t\t * we have nowhere to store the partial HEADERS frame.\n\t\t\t * Let's abort the stream on an INTERNAL_ERROR here.\n\t\t\t */\n\t\t\tif (h2c->st0 == H2_CS_FRAME_P) {\n\t\t\t\th2s_error(h2s, H2_ERR_INTERNAL_ERROR);\n\t\t\t\th2c->st0 = H2_CS_FRAME_E;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase H2_FT_HEADERS:\n\t\t\tif (h2c->st0 == H2_CS_FRAME_P)\n\t\t\t\tret = h2c_frt_handle_headers(h2c, h2s);\n\t\t\tbreak;\n\n\t\tcase H2_FT_DATA:\n\t\t\tif (h2c->st0 == H2_CS_FRAME_P)\n\t\t\t\tret = h2c_frt_handle_data(h2c, h2s);\n\n\t\t\tif (h2c->st0 == H2_CS_FRAME_A)\n\t\t\t\tret = h2c_send_strm_wu(h2c);\n\t\t\tbreak;\n\n\t\tcase H2_FT_PRIORITY:\n\t\t\tif (h2c->st0 == H2_CS_FRAME_P)\n\t\t\t\tret = h2c_handle_priority(h2c);\n\t\t\tbreak;\n\n\t\tcase H2_FT_RST_STREAM:\n\t\t\tif (h2c->st0 == H2_CS_FRAME_P)\n\t\t\t\tret = h2c_handle_rst_stream(h2c, h2s);\n\t\t\tbreak;\n\n\t\tcase H2_FT_GOAWAY:\n\t\t\tif (h2c->st0 == H2_CS_FRAME_P)\n\t\t\t\tret = h2c_handle_goaway(h2c);\n\t\t\tbreak;\n\n\t\tcase H2_FT_PUSH_PROMISE:\n\t\t\t/* not permitted here, RFC7540#5.1 */\n\t\t\th2c_error(h2c, H2_ERR_PROTOCOL_ERROR);\n\t\t\tbreak;\n\n\t\t\t/* implement all extra frame types here */\n\t\tdefault:\n\t\t\t/* drop frames that we ignore. They may be larger than\n\t\t\t * the buffer so we drain all of their contents until\n\t\t\t * we reach the end.\n\t\t\t */\n\t\t\tret = MIN(h2c->dbuf->i, h2c->dfl);\n\t\t\tbi_del(h2c->dbuf, ret);\n\t\t\th2c->dfl -= ret;\n\t\t\tret = h2c->dfl == 0;\n\t\t}\n\n\tstrm_err:\n\t\t/* We may have to send an RST if not done yet */\n\t\tif (h2s->st == H2_SS_ERROR)\n\t\t\th2c->st0 = H2_CS_FRAME_E;\n\n\t\tif (h2c->st0 == H2_CS_FRAME_E)\n\t\t\tret = h2c_send_rst_stream(h2c, h2s);\n\n\t\t/* error or missing data condition met above ? */\n\t\tif (ret <= 0)\n\t\t\tbreak;\n\n\t\tif (h2c->st0 != H2_CS_FRAME_H) {\n\t\t\tbi_del(h2c->dbuf, h2c->dfl);\n\t\t\th2c->st0 = H2_CS_FRAME_H;\n\t\t}\n\t}\n\n\tif (h2c->rcvd_c > 0 &&\n\t    !(h2c->flags & (H2_CF_MUX_MFULL | H2_CF_DEM_MBUSY | H2_CF_DEM_MROOM)))\n\t\th2c_send_conn_wu(h2c);\n\n fail:\n\t/* we can go here on missing data, blocked response or error */\n\treturn;\n}\n",
    "code_after_change": "static void h2_process_demux(struct h2c *h2c)\n{\n\tstruct h2s *h2s;\n\n\tif (h2c->st0 >= H2_CS_ERROR)\n\t\treturn;\n\n\tif (unlikely(h2c->st0 < H2_CS_FRAME_H)) {\n\t\tif (h2c->st0 == H2_CS_PREFACE) {\n\t\t\tif (unlikely(h2c_frt_recv_preface(h2c) <= 0)) {\n\t\t\t\t/* RFC7540#3.5: a GOAWAY frame MAY be omitted */\n\t\t\t\tif (h2c->st0 == H2_CS_ERROR)\n\t\t\t\t\th2c->st0 = H2_CS_ERROR2;\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\th2c->max_id = 0;\n\t\t\th2c->st0 = H2_CS_SETTINGS1;\n\t\t}\n\n\t\tif (h2c->st0 == H2_CS_SETTINGS1) {\n\t\t\tstruct h2_fh hdr;\n\n\t\t\t/* ensure that what is pending is a valid SETTINGS frame\n\t\t\t * without an ACK.\n\t\t\t */\n\t\t\tif (!h2_get_frame_hdr(h2c->dbuf, &hdr)) {\n\t\t\t\t/* RFC7540#3.5: a GOAWAY frame MAY be omitted */\n\t\t\t\tif (h2c->st0 == H2_CS_ERROR)\n\t\t\t\t\th2c->st0 = H2_CS_ERROR2;\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tif (hdr.sid || hdr.ft != H2_FT_SETTINGS || hdr.ff & H2_F_SETTINGS_ACK) {\n\t\t\t\t/* RFC7540#3.5: a GOAWAY frame MAY be omitted */\n\t\t\t\th2c_error(h2c, H2_ERR_PROTOCOL_ERROR);\n\t\t\t\th2c->st0 = H2_CS_ERROR2;\n                                goto fail;\n                        }\n \n                       if ((int)hdr.len < 0 || (int)hdr.len > global.tune.bufsize) {\n                                /* RFC7540#3.5: a GOAWAY frame MAY be omitted */\n                                h2c_error(h2c, H2_ERR_FRAME_SIZE_ERROR);\n                                h2c->st0 = H2_CS_ERROR2;\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\t/* that's OK, switch to FRAME_P to process it */\n\t\t\th2c->dfl = hdr.len;\n\t\t\th2c->dsi = hdr.sid;\n\t\t\th2c->dft = hdr.ft;\n\t\t\th2c->dff = hdr.ff;\n\t\t\th2c->dpl = 0;\n\t\t\th2c->st0 = H2_CS_FRAME_P;\n\t\t}\n\t}\n\n\t/* process as many incoming frames as possible below */\n\twhile (h2c->dbuf->i) {\n\t\tint ret = 0;\n\n\t\tif (h2c->st0 >= H2_CS_ERROR)\n\t\t\tbreak;\n\n\t\tif (h2c->st0 == H2_CS_FRAME_H) {\n\t\t\tstruct h2_fh hdr;\n\n                        if (!h2_peek_frame_hdr(h2c->dbuf, &hdr))\n                                break;\n \n                       if ((int)hdr.len < 0 || (int)hdr.len > global.tune.bufsize) {\n                                h2c_error(h2c, H2_ERR_FRAME_SIZE_ERROR);\n                                h2c->st0 = H2_CS_ERROR;\n                                break;\n\t\t\t}\n\n\t\t\th2c->dfl = hdr.len;\n\t\t\th2c->dsi = hdr.sid;\n\t\t\th2c->dft = hdr.ft;\n\t\t\th2c->dff = hdr.ff;\n\t\t\th2c->dpl = 0;\n\t\t\th2c->st0 = H2_CS_FRAME_P;\n\t\t\th2_skip_frame_hdr(h2c->dbuf);\n\t\t}\n\n\t\t/* Only H2_CS_FRAME_P and H2_CS_FRAME_A here */\n\t\th2s = h2c_st_by_id(h2c, h2c->dsi);\n\n\t\tif (h2c->st0 == H2_CS_FRAME_E)\n\t\t\tgoto strm_err;\n\n\t\tif (h2s->st == H2_SS_IDLE &&\n\t\t    h2c->dft != H2_FT_HEADERS && h2c->dft != H2_FT_PRIORITY) {\n\t\t\t/* RFC7540#5.1: any frame other than HEADERS or PRIORITY in\n\t\t\t * this state MUST be treated as a connection error\n\t\t\t */\n\t\t\th2c_error(h2c, H2_ERR_PROTOCOL_ERROR);\n\t\t\th2c->st0 = H2_CS_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (h2s->st == H2_SS_HREM && h2c->dft != H2_FT_WINDOW_UPDATE &&\n\t\t    h2c->dft != H2_FT_RST_STREAM && h2c->dft != H2_FT_PRIORITY) {\n\t\t\t/* RFC7540#5.1: any frame other than WU/PRIO/RST in\n\t\t\t * this state MUST be treated as a stream error\n\t\t\t */\n\t\t\th2s_error(h2s, H2_ERR_STREAM_CLOSED);\n\t\t\th2c->st0 = H2_CS_FRAME_E;\n\t\t\tgoto strm_err;\n\t\t}\n\n\t\t/* Below the management of frames received in closed state is a\n\t\t * bit hackish because the spec makes strong differences between\n\t\t * streams closed by receiving RST, sending RST, and seeing ES\n\t\t * in both directions. In addition to this, the creation of a\n\t\t * new stream reusing the identifier of a closed one will be\n\t\t * detected here. Given that we cannot keep track of all closed\n\t\t * streams forever, we consider that unknown closed streams were\n\t\t * closed on RST received, which allows us to respond with an\n\t\t * RST without breaking the connection (eg: to abort a transfer).\n\t\t * Some frames have to be silently ignored as well.\n\t\t */\n\t\tif (h2s->st == H2_SS_CLOSED && h2c->dsi) {\n\t\t\tif (h2c->dft == H2_FT_HEADERS || h2c->dft == H2_FT_PUSH_PROMISE) {\n\t\t\t\t/* #5.1.1: The identifier of a newly\n\t\t\t\t * established stream MUST be numerically\n\t\t\t\t * greater than all streams that the initiating\n\t\t\t\t * endpoint has opened or reserved. This\n\t\t\t\t * governs streams that are opened using a\n\t\t\t\t * HEADERS frame and streams that are reserved\n\t\t\t\t * using PUSH_PROMISE. An endpoint that\n\t\t\t\t * receives an unexpected stream identifier\n\t\t\t\t * MUST respond with a connection error.\n\t\t\t\t */\n\t\t\t\th2c_error(h2c, H2_ERR_STREAM_CLOSED);\n\t\t\t\tgoto strm_err;\n\t\t\t}\n\n\t\t\tif (h2s->flags & H2_SF_RST_RCVD) {\n\t\t\t\t/* RFC7540#5.1:closed: an endpoint that\n\t\t\t\t * receives any frame other than PRIORITY after\n\t\t\t\t * receiving a RST_STREAM MUST treat that as a\n\t\t\t\t * stream error of type STREAM_CLOSED.\n\t\t\t\t *\n\t\t\t\t * Note that old streams fall into this category\n\t\t\t\t * and will lead to an RST being sent.\n\t\t\t\t */\n\t\t\t\th2s_error(h2s, H2_ERR_STREAM_CLOSED);\n\t\t\t\th2c->st0 = H2_CS_FRAME_E;\n\t\t\t\tgoto strm_err;\n\t\t\t}\n\n\t\t\t/* RFC7540#5.1:closed: if this state is reached as a\n\t\t\t * result of sending a RST_STREAM frame, the peer that\n\t\t\t * receives the RST_STREAM might have already sent\n\t\t\t * frames on the stream that cannot be withdrawn. An\n\t\t\t * endpoint MUST ignore frames that it receives on\n\t\t\t * closed streams after it has sent a RST_STREAM\n\t\t\t * frame. An endpoint MAY choose to limit the period\n\t\t\t * over which it ignores frames and treat frames that\n\t\t\t * arrive after this time as being in error.\n\t\t\t */\n\t\t\tif (!(h2s->flags & H2_SF_RST_SENT)) {\n\t\t\t\t/* RFC7540#5.1:closed: any frame other than\n\t\t\t\t * PRIO/WU/RST in this state MUST be treated as\n\t\t\t\t * a connection error\n\t\t\t\t */\n\t\t\t\tif (h2c->dft != H2_FT_RST_STREAM &&\n\t\t\t\t    h2c->dft != H2_FT_PRIORITY &&\n\t\t\t\t    h2c->dft != H2_FT_WINDOW_UPDATE) {\n\t\t\t\t\th2c_error(h2c, H2_ERR_STREAM_CLOSED);\n\t\t\t\t\tgoto strm_err;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n#if 0\n\n\t\t/* graceful shutdown, ignore streams whose ID is higher than\n\t\t * the one advertised in GOAWAY. RFC7540#6.8.\n\t\t */\n\t\tif (unlikely(h2c->last_sid >= 0) && h2c->dsi > h2c->last_sid) {\n\t\t\tret = MIN(h2c->dbuf->i, h2c->dfl);\n\t\t\tbi_del(h2c->dbuf, ret);\n\t\t\th2c->dfl -= ret;\n\t\t\tret = h2c->dfl == 0;\n\t\t\tgoto strm_err;\n\t\t}\n#endif\n\n\t\tswitch (h2c->dft) {\n\t\tcase H2_FT_SETTINGS:\n\t\t\tif (h2c->st0 == H2_CS_FRAME_P)\n\t\t\t\tret = h2c_handle_settings(h2c);\n\n\t\t\tif (h2c->st0 == H2_CS_FRAME_A)\n\t\t\t\tret = h2c_ack_settings(h2c);\n\t\t\tbreak;\n\n\t\tcase H2_FT_PING:\n\t\t\tif (h2c->st0 == H2_CS_FRAME_P)\n\t\t\t\tret = h2c_handle_ping(h2c);\n\n\t\t\tif (h2c->st0 == H2_CS_FRAME_A)\n\t\t\t\tret = h2c_ack_ping(h2c);\n\t\t\tbreak;\n\n\t\tcase H2_FT_WINDOW_UPDATE:\n\t\t\tif (h2c->st0 == H2_CS_FRAME_P)\n\t\t\t\tret = h2c_handle_window_update(h2c, h2s);\n\t\t\tbreak;\n\n\t\tcase H2_FT_CONTINUATION:\n\t\t\t/* we currently don't support CONTINUATION frames since\n\t\t\t * we have nowhere to store the partial HEADERS frame.\n\t\t\t * Let's abort the stream on an INTERNAL_ERROR here.\n\t\t\t */\n\t\t\tif (h2c->st0 == H2_CS_FRAME_P) {\n\t\t\t\th2s_error(h2s, H2_ERR_INTERNAL_ERROR);\n\t\t\t\th2c->st0 = H2_CS_FRAME_E;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase H2_FT_HEADERS:\n\t\t\tif (h2c->st0 == H2_CS_FRAME_P)\n\t\t\t\tret = h2c_frt_handle_headers(h2c, h2s);\n\t\t\tbreak;\n\n\t\tcase H2_FT_DATA:\n\t\t\tif (h2c->st0 == H2_CS_FRAME_P)\n\t\t\t\tret = h2c_frt_handle_data(h2c, h2s);\n\n\t\t\tif (h2c->st0 == H2_CS_FRAME_A)\n\t\t\t\tret = h2c_send_strm_wu(h2c);\n\t\t\tbreak;\n\n\t\tcase H2_FT_PRIORITY:\n\t\t\tif (h2c->st0 == H2_CS_FRAME_P)\n\t\t\t\tret = h2c_handle_priority(h2c);\n\t\t\tbreak;\n\n\t\tcase H2_FT_RST_STREAM:\n\t\t\tif (h2c->st0 == H2_CS_FRAME_P)\n\t\t\t\tret = h2c_handle_rst_stream(h2c, h2s);\n\t\t\tbreak;\n\n\t\tcase H2_FT_GOAWAY:\n\t\t\tif (h2c->st0 == H2_CS_FRAME_P)\n\t\t\t\tret = h2c_handle_goaway(h2c);\n\t\t\tbreak;\n\n\t\tcase H2_FT_PUSH_PROMISE:\n\t\t\t/* not permitted here, RFC7540#5.1 */\n\t\t\th2c_error(h2c, H2_ERR_PROTOCOL_ERROR);\n\t\t\tbreak;\n\n\t\t\t/* implement all extra frame types here */\n\t\tdefault:\n\t\t\t/* drop frames that we ignore. They may be larger than\n\t\t\t * the buffer so we drain all of their contents until\n\t\t\t * we reach the end.\n\t\t\t */\n\t\t\tret = MIN(h2c->dbuf->i, h2c->dfl);\n\t\t\tbi_del(h2c->dbuf, ret);\n\t\t\th2c->dfl -= ret;\n\t\t\tret = h2c->dfl == 0;\n\t\t}\n\n\tstrm_err:\n\t\t/* We may have to send an RST if not done yet */\n\t\tif (h2s->st == H2_SS_ERROR)\n\t\t\th2c->st0 = H2_CS_FRAME_E;\n\n\t\tif (h2c->st0 == H2_CS_FRAME_E)\n\t\t\tret = h2c_send_rst_stream(h2c, h2s);\n\n\t\t/* error or missing data condition met above ? */\n\t\tif (ret <= 0)\n\t\t\tbreak;\n\n\t\tif (h2c->st0 != H2_CS_FRAME_H) {\n\t\t\tbi_del(h2c->dbuf, h2c->dfl);\n\t\t\th2c->st0 = H2_CS_FRAME_H;\n\t\t}\n\t}\n\n\tif (h2c->rcvd_c > 0 &&\n\t    !(h2c->flags & (H2_CF_MUX_MFULL | H2_CF_DEM_MBUSY | H2_CF_DEM_MROOM)))\n\t\th2c_send_conn_wu(h2c);\n\n fail:\n\t/* we can go here on missing data, blocked response or error */\n\treturn;\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 398,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2011-2182",
    "code_before_change": "static bool ldm_frag_add (const u8 *data, int size, struct list_head *frags)\n{\n\tstruct frag *f;\n\tstruct list_head *item;\n\tint rec, num, group;\n\n\tBUG_ON (!data || !frags);\n\n\tif (size < 2 * VBLK_SIZE_HEAD) {\n\t\tldm_error(\"Value of size is to small.\");\n\t\treturn false;\n\t}\n\n\tgroup = get_unaligned_be32(data + 0x08);\n\trec   = get_unaligned_be16(data + 0x0C);\n\tnum   = get_unaligned_be16(data + 0x0E);\n\tif ((num < 1) || (num > 4)) {\n\t\tldm_error (\"A VBLK claims to have %d parts.\", num);\n\t\treturn false;\n\t}\n\tif (rec >= num) {\n\t\tldm_error(\"REC value (%d) exceeds NUM value (%d)\", rec, num);\n\t\treturn false;\n\t}\n\n\tlist_for_each (item, frags) {\n\t\tf = list_entry (item, struct frag, list);\n\t\tif (f->group == group)\n\t\t\tgoto found;\n\t}\n\n\tf = kmalloc (sizeof (*f) + size*num, GFP_KERNEL);\n\tif (!f) {\n\t\tldm_crit (\"Out of memory.\");\n\t\treturn false;\n\t}\n\n\tf->group = group;\n\tf->num   = num;\n\tf->rec   = rec;\n\tf->map   = 0xFF << num;\n \n \tlist_add_tail (&f->list, frags);\n found:\n \tif (f->map & (1 << rec)) {\n \t\tldm_error (\"Duplicate VBLK, part %d.\", rec);\n \t\tf->map &= 0x7F;\t\t\t/* Mark the group as broken */\n\t\treturn false;\n\t}\n\n\tf->map |= (1 << rec);\n\n\tdata += VBLK_SIZE_HEAD;\n\tsize -= VBLK_SIZE_HEAD;\n\n\tmemcpy (f->data+rec*(size-VBLK_SIZE_HEAD)+VBLK_SIZE_HEAD, data, size);\n\n\treturn true;\n}\n",
    "code_after_change": "static bool ldm_frag_add (const u8 *data, int size, struct list_head *frags)\n{\n\tstruct frag *f;\n\tstruct list_head *item;\n\tint rec, num, group;\n\n\tBUG_ON (!data || !frags);\n\n\tif (size < 2 * VBLK_SIZE_HEAD) {\n\t\tldm_error(\"Value of size is to small.\");\n\t\treturn false;\n\t}\n\n\tgroup = get_unaligned_be32(data + 0x08);\n\trec   = get_unaligned_be16(data + 0x0C);\n\tnum   = get_unaligned_be16(data + 0x0E);\n\tif ((num < 1) || (num > 4)) {\n\t\tldm_error (\"A VBLK claims to have %d parts.\", num);\n\t\treturn false;\n\t}\n\tif (rec >= num) {\n\t\tldm_error(\"REC value (%d) exceeds NUM value (%d)\", rec, num);\n\t\treturn false;\n\t}\n\n\tlist_for_each (item, frags) {\n\t\tf = list_entry (item, struct frag, list);\n\t\tif (f->group == group)\n\t\t\tgoto found;\n\t}\n\n\tf = kmalloc (sizeof (*f) + size*num, GFP_KERNEL);\n\tif (!f) {\n\t\tldm_crit (\"Out of memory.\");\n\t\treturn false;\n\t}\n\n\tf->group = group;\n\tf->num   = num;\n\tf->rec   = rec;\n\tf->map   = 0xFF << num;\n \n \tlist_add_tail (&f->list, frags);\n found:\n\tif (rec >= f->num) {\n\t\tldm_error(\"REC value (%d) exceeds NUM value (%d)\", rec, f->num);\n\t\treturn false;\n\t}\n\n \tif (f->map & (1 << rec)) {\n \t\tldm_error (\"Duplicate VBLK, part %d.\", rec);\n \t\tf->map &= 0x7F;\t\t\t/* Mark the group as broken */\n\t\treturn false;\n\t}\n\n\tf->map |= (1 << rec);\n\n\tdata += VBLK_SIZE_HEAD;\n\tsize -= VBLK_SIZE_HEAD;\n\n\tmemcpy (f->data+rec*(size-VBLK_SIZE_HEAD)+VBLK_SIZE_HEAD, data, size);\n\n\treturn true;\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 400,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-1621",
    "code_before_change": "   void RunSignBiasCheck() {\n     ACMRandom rnd(ACMRandom::DeterministicSeed());\n    DECLARE_ALIGNED_ARRAY(16, int16_t, test_input_block, 64);\n    DECLARE_ALIGNED_ARRAY(16, int16_t, test_output_block, 64);\n     int count_sign_block[64][2];\n     const int count_test_block = 100000;\n \n    memset(count_sign_block, 0, sizeof(count_sign_block));\n\n\n     for (int i = 0; i < count_test_block; ++i) {\n       for (int j = 0; j < 64; ++j)\n        test_input_block[j] = rnd.Rand8() - rnd.Rand8();\n      REGISTER_STATE_CHECK(\n           RunFwdTxfm(test_input_block, test_output_block, pitch_));\n \n       for (int j = 0; j < 64; ++j) {\n if (test_output_block[j] < 0)\n ++count_sign_block[j][0];\n else if (test_output_block[j] > 0)\n ++count_sign_block[j][1];\n }\n }\n\n \n     for (int j = 0; j < 64; ++j) {\n       const int diff = abs(count_sign_block[j][0] - count_sign_block[j][1]);\n      const int max_diff = 1125;\n      EXPECT_LT(diff, max_diff)\n           << \"Error: 8x8 FDCT/FHT has a sign bias > \"\n           << 1. * max_diff / count_test_block * 100 << \"%\"\n           << \" for input range [-255, 255] at index \" << j\n << \" count0: \" << count_sign_block[j][0]\n << \" count1: \" << count_sign_block[j][1]\n << \" diff: \" << diff;\n }\n\n\n     memset(count_sign_block, 0, sizeof(count_sign_block));\n \n     for (int i = 0; i < count_test_block; ++i) {\n       for (int j = 0; j < 64; ++j)\n        test_input_block[j] = (rnd.Rand8() >> 4) - (rnd.Rand8() >> 4);\n      REGISTER_STATE_CHECK(\n           RunFwdTxfm(test_input_block, test_output_block, pitch_));\n \n       for (int j = 0; j < 64; ++j) {\n if (test_output_block[j] < 0)\n ++count_sign_block[j][0];\n else if (test_output_block[j] > 0)\n ++count_sign_block[j][1];\n }\n }\n\n \n     for (int j = 0; j < 64; ++j) {\n       const int diff = abs(count_sign_block[j][0] - count_sign_block[j][1]);\n      const int max_diff = 10000;\n      EXPECT_LT(diff, max_diff)\n          << \"Error: 4x4 FDCT/FHT has a sign bias > \"\n           << 1. * max_diff / count_test_block * 100 << \"%\"\n           << \" for input range [-15, 15] at index \" << j\n           << \" count0: \" << count_sign_block[j][0]\n << \" count1: \" << count_sign_block[j][1]\n << \" diff: \" << diff;\n }\n }\n",
    "code_after_change": "   void RunSignBiasCheck() {\n     ACMRandom rnd(ACMRandom::DeterministicSeed());\n    DECLARE_ALIGNED(16, int16_t, test_input_block[64]);\n    DECLARE_ALIGNED(16, tran_low_t, test_output_block[64]);\n     int count_sign_block[64][2];\n     const int count_test_block = 100000;\n \n    memset(count_sign_block, 0, sizeof(count_sign_block));\n\n\n     for (int i = 0; i < count_test_block; ++i) {\n       for (int j = 0; j < 64; ++j)\n        test_input_block[j] = ((rnd.Rand16() >> (16 - bit_depth_)) & mask_) -\n                              ((rnd.Rand16() >> (16 - bit_depth_)) & mask_);\n      ASM_REGISTER_STATE_CHECK(\n           RunFwdTxfm(test_input_block, test_output_block, pitch_));\n \n       for (int j = 0; j < 64; ++j) {\n if (test_output_block[j] < 0)\n ++count_sign_block[j][0];\n else if (test_output_block[j] > 0)\n ++count_sign_block[j][1];\n }\n }\n\n \n     for (int j = 0; j < 64; ++j) {\n       const int diff = abs(count_sign_block[j][0] - count_sign_block[j][1]);\n      const int max_diff = kSignBiasMaxDiff255;\n      EXPECT_LT(diff, max_diff << (bit_depth_ - 8))\n           << \"Error: 8x8 FDCT/FHT has a sign bias > \"\n           << 1. * max_diff / count_test_block * 100 << \"%\"\n           << \" for input range [-255, 255] at index \" << j\n << \" count0: \" << count_sign_block[j][0]\n << \" count1: \" << count_sign_block[j][1]\n << \" diff: \" << diff;\n }\n\n\n     memset(count_sign_block, 0, sizeof(count_sign_block));\n \n     for (int i = 0; i < count_test_block; ++i) {\n      // Initialize a test block with input range [-mask_ / 16, mask_ / 16].\n       for (int j = 0; j < 64; ++j)\n        test_input_block[j] = ((rnd.Rand16() & mask_) >> 4) -\n                              ((rnd.Rand16() & mask_) >> 4);\n      ASM_REGISTER_STATE_CHECK(\n           RunFwdTxfm(test_input_block, test_output_block, pitch_));\n \n       for (int j = 0; j < 64; ++j) {\n if (test_output_block[j] < 0)\n ++count_sign_block[j][0];\n else if (test_output_block[j] > 0)\n ++count_sign_block[j][1];\n }\n }\n\n \n     for (int j = 0; j < 64; ++j) {\n       const int diff = abs(count_sign_block[j][0] - count_sign_block[j][1]);\n      const int max_diff = kSignBiasMaxDiff15;\n      EXPECT_LT(diff, max_diff << (bit_depth_ - 8))\n          << \"Error: 8x8 FDCT/FHT has a sign bias > \"\n           << 1. * max_diff / count_test_block * 100 << \"%\"\n           << \" for input range [-15, 15] at index \" << j\n           << \" count0: \" << count_sign_block[j][0]\n << \" count1: \" << count_sign_block[j][1]\n << \" diff: \" << diff;\n }\n }\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 402,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2015-1232",
    "code_before_change": "void MidiManagerUsb::DispatchSendMidiData(MidiManagerClient* client,\n                                           uint32_t port_index,\n                                           const std::vector<uint8>& data,\n                                           double timestamp) {\n  DCHECK_LT(port_index, output_streams_.size());\n   output_streams_[port_index]->Send(data);\n   client->AccumulateMidiBytesSent(data.size());\n }\n",
    "code_after_change": "void MidiManagerUsb::DispatchSendMidiData(MidiManagerClient* client,\n                                           uint32_t port_index,\n                                           const std::vector<uint8>& data,\n                                           double timestamp) {\n  if (port_index >= output_streams_.size()) {\n    // |port_index| is provided by a renderer so we can't believe that it is\n    // in the valid range.\n    // TODO(toyoshim): Move this check to MidiHost and kill the renderer when\n    // it fails.\n    return;\n  }\n   output_streams_[port_index]->Send(data);\n   client->AccumulateMidiBytesSent(data.size());\n }\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 403,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-10066",
    "code_before_change": "static Image *ReadCUTImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image,*palette;\n  ImageInfo *clone_info;\n  MagickBooleanType status;\n\n  MagickOffsetType\n    offset;\n\n  size_t EncodedByte;\n  unsigned char RunCount,RunValue,RunCountMasked;\n  CUTHeader  Header;\n  CUTPalHeader PalHeader;\n  ssize_t depth;\n  ssize_t i,j;\n  ssize_t ldblk;\n  unsigned char *BImgBuff=NULL,*ptrB;\n  PixelPacket *q;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read CUT image.\n  */\n  palette=NULL;\n  clone_info=NULL;\n  Header.Width=ReadBlobLSBShort(image);\n  Header.Height=ReadBlobLSBShort(image);\n  Header.Reserved=ReadBlobLSBShort(image);\n\n  if (Header.Width==0 || Header.Height==0 || Header.Reserved!=0)\n    CUT_KO:  ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  /*---This code checks first line of image---*/\n  EncodedByte=ReadBlobLSBShort(image);\n  RunCount=(unsigned char) ReadBlobByte(image);\n  RunCountMasked=RunCount & 0x7F;\n  ldblk=0;\n  while((int) RunCountMasked!=0)  /*end of line?*/\n    {\n      i=1;\n      if((int) RunCount<0x80) i=(ssize_t) RunCountMasked;\n      offset=SeekBlob(image,TellBlob(image)+i,SEEK_SET);\n      if (offset < 0)\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      if(EOFBlob(image) != MagickFalse) goto CUT_KO;  /*wrong data*/\n      EncodedByte-=i+1;\n      ldblk+=(ssize_t) RunCountMasked;\n\n      RunCount=(unsigned char) ReadBlobByte(image);\n      if(EOFBlob(image) != MagickFalse)  goto CUT_KO;  /*wrong data: unexpected eof in line*/\n      RunCountMasked=RunCount & 0x7F;\n    }\n  if(EncodedByte!=1) goto CUT_KO;  /*wrong data: size incorrect*/\n  i=0;        /*guess a number of bit planes*/\n  if(ldblk==(int) Header.Width)   i=8;\n  if(2*ldblk==(int) Header.Width) i=4;\n  if(8*ldblk==(int) Header.Width) i=1;\n  if(i==0) goto CUT_KO;    /*wrong data: incorrect bit planes*/\n  depth=i;\n\n  image->columns=Header.Width;\n  image->rows=Header.Height;\n   image->depth=8;\n   image->colors=(size_t) (GetQuantumRange(1UL*i)+1);\n \n  if (image_info->ping) goto Finish;\n \n   /* ----- Do something with palette ----- */\n   if ((clone_info=CloneImageInfo(image_info)) == NULL) goto NoPalette;\n\n\n  i=(ssize_t) strlen(clone_info->filename);\n  j=i;\n  while(--i>0)\n    {\n      if(clone_info->filename[i]=='.')\n        {\n          break;\n        }\n      if(clone_info->filename[i]=='/' || clone_info->filename[i]=='\\\\' ||\n         clone_info->filename[i]==':' )\n        {\n          i=j;\n          break;\n        }\n    }\n\n  (void) CopyMagickString(clone_info->filename+i,\".PAL\",(size_t)\n    (MaxTextExtent-i));\n  if((clone_info->file=fopen_utf8(clone_info->filename,\"rb\"))==NULL)\n    {\n      (void) CopyMagickString(clone_info->filename+i,\".pal\",(size_t)\n        (MaxTextExtent-i));\n      if((clone_info->file=fopen_utf8(clone_info->filename,\"rb\"))==NULL)\n        {\n          clone_info->filename[i]='\\0';\n          if((clone_info->file=fopen_utf8(clone_info->filename,\"rb\"))==NULL)\n            {\n              clone_info=DestroyImageInfo(clone_info);\n              clone_info=NULL;\n              goto NoPalette;\n            }\n        }\n    }\n\n  if( (palette=AcquireImage(clone_info))==NULL ) goto NoPalette;\n  status=OpenBlob(clone_info,palette,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n    ErasePalette:\n      palette=DestroyImage(palette);\n      palette=NULL;\n      goto NoPalette;\n    }\n\n\n  if(palette!=NULL)\n    {\n      (void) ReadBlob(palette,2,(unsigned char *) PalHeader.FileId);\n      if(strncmp(PalHeader.FileId,\"AH\",2) != 0) goto ErasePalette;\n      PalHeader.Version=ReadBlobLSBShort(palette);\n      PalHeader.Size=ReadBlobLSBShort(palette);\n      PalHeader.FileType=(char) ReadBlobByte(palette);\n      PalHeader.SubType=(char) ReadBlobByte(palette);\n      PalHeader.BoardID=ReadBlobLSBShort(palette);\n      PalHeader.GraphicsMode=ReadBlobLSBShort(palette);\n      PalHeader.MaxIndex=ReadBlobLSBShort(palette);\n      PalHeader.MaxRed=ReadBlobLSBShort(palette);\n      PalHeader.MaxGreen=ReadBlobLSBShort(palette);\n      PalHeader.MaxBlue=ReadBlobLSBShort(palette);\n      (void) ReadBlob(palette,20,(unsigned char *) PalHeader.PaletteId);\n\n      if(PalHeader.MaxIndex<1) goto ErasePalette;\n      image->colors=PalHeader.MaxIndex+1;\n      if (AcquireImageColormap(image,image->colors) == MagickFalse) goto NoMemory;\n\n      if(PalHeader.MaxRed==0) PalHeader.MaxRed=(unsigned int) QuantumRange;  /*avoid division by 0*/\n      if(PalHeader.MaxGreen==0) PalHeader.MaxGreen=(unsigned int) QuantumRange;\n      if(PalHeader.MaxBlue==0) PalHeader.MaxBlue=(unsigned int) QuantumRange;\n\n      for(i=0;i<=(int) PalHeader.MaxIndex;i++)\n        {      /*this may be wrong- I don't know why is palette such strange*/\n          j=(ssize_t) TellBlob(palette);\n          if((j % 512)>512-6)\n            {\n              j=((j / 512)+1)*512;\n              offset=SeekBlob(palette,j,SEEK_SET);\n              if (offset < 0)\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n            }\n          image->colormap[i].red=(Quantum) ReadBlobLSBShort(palette);\n          if (QuantumRange != (Quantum) PalHeader.MaxRed)\n            {\n              image->colormap[i].red=ClampToQuantum(((double)\n                image->colormap[i].red*QuantumRange+(PalHeader.MaxRed>>1))/\n                PalHeader.MaxRed);\n            }\n          image->colormap[i].green=(Quantum) ReadBlobLSBShort(palette);\n          if (QuantumRange != (Quantum) PalHeader.MaxGreen)\n            {\n              image->colormap[i].green=ClampToQuantum\n                (((double) image->colormap[i].green*QuantumRange+(PalHeader.MaxGreen>>1))/PalHeader.MaxGreen);\n            }\n          image->colormap[i].blue=(Quantum) ReadBlobLSBShort(palette);\n          if (QuantumRange != (Quantum) PalHeader.MaxBlue)\n            {\n              image->colormap[i].blue=ClampToQuantum\n                (((double)image->colormap[i].blue*QuantumRange+(PalHeader.MaxBlue>>1))/PalHeader.MaxBlue);\n            }\n\n        }\n    }\n\n\n\n NoPalette:\n  if(palette==NULL)\n    {\n\n      image->colors=256;\n      if (AcquireImageColormap(image,image->colors) == MagickFalse)\n        {\n        NoMemory:\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n            }\n\n      for (i=0; i < (ssize_t)image->colors; i++)\n        {\n          image->colormap[i].red=ScaleCharToQuantum((unsigned char) i);\n          image->colormap[i].green=ScaleCharToQuantum((unsigned char) i);\n          image->colormap[i].blue=ScaleCharToQuantum((unsigned char) i);\n        }\n    }\n\n\n  /* ----- Load RLE compressed raster ----- */\n  BImgBuff=(unsigned char *) AcquireQuantumMemory((size_t) ldblk,\n    sizeof(*BImgBuff));  /*Ldblk was set in the check phase*/\n  if(BImgBuff==NULL) goto NoMemory;\n\n  offset=SeekBlob(image,6 /*sizeof(Header)*/,SEEK_SET);\n  if (offset < 0)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  for (i=0; i < (int) Header.Height; i++)\n  {\n      EncodedByte=ReadBlobLSBShort(image);\n\n      ptrB=BImgBuff;\n      j=ldblk;\n\n      RunCount=(unsigned char) ReadBlobByte(image);\n      RunCountMasked=RunCount & 0x7F;\n\n      while ((int) RunCountMasked != 0)\n      {\n          if((ssize_t) RunCountMasked>j)\n            {    /*Wrong Data*/\n              RunCountMasked=(unsigned char) j;\n              if(j==0)\n                {\n                  break;\n                }\n            }\n\n          if((int) RunCount>0x80)\n            {\n              RunValue=(unsigned char) ReadBlobByte(image);\n              (void) ResetMagickMemory(ptrB,(int) RunValue,(size_t) RunCountMasked);\n            }\n          else {\n            (void) ReadBlob(image,(size_t) RunCountMasked,ptrB);\n          }\n\n          ptrB+=(int) RunCountMasked;\n          j-=(int) RunCountMasked;\n\n          if (EOFBlob(image) != MagickFalse) goto Finish;  /* wrong data: unexpected eof in line */\n          RunCount=(unsigned char) ReadBlobByte(image);\n          RunCountMasked=RunCount & 0x7F;\n        }\n\n      InsertRow(depth,BImgBuff,i,image);\n    }\n  (void) SyncImage(image);\n\n\n  /*detect monochrome image*/\n\n  if(palette==NULL)\n    {    /*attempt to detect binary (black&white) images*/\n      if ((image->storage_class == PseudoClass) &&\n          (IsGrayImage(image,&image->exception) != MagickFalse))\n        {\n          if(GetCutColors(image)==2)\n            {\n              for (i=0; i < (ssize_t)image->colors; i++)\n                {\n                  register Quantum\n                    sample;\n                  sample=ScaleCharToQuantum((unsigned char) i);\n                  if(image->colormap[i].red!=sample) goto Finish;\n                  if(image->colormap[i].green!=sample) goto Finish;\n                  if(image->colormap[i].blue!=sample) goto Finish;\n                }\n\n              image->colormap[1].red=image->colormap[1].green=\n                image->colormap[1].blue=QuantumRange;\n              for (i=0; i < (ssize_t)image->rows; i++)\n                {\n                  q=QueueAuthenticPixels(image,0,i,image->columns,1,exception);\n                  for (j=0; j < (ssize_t)image->columns; j++)\n                    {\n                      if (GetPixelRed(q) == ScaleCharToQuantum(1))\n                        {\n                          SetPixelRed(q,QuantumRange);\n                          SetPixelGreen(q,QuantumRange);\n                          SetPixelBlue(q,QuantumRange);\n                        }\n                      q++;\n                    }\n                  if (SyncAuthenticPixels(image,exception) == MagickFalse) goto Finish;\n                }\n            }\n        }\n    }\n\n Finish:\n  if (BImgBuff != NULL)\n    BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);\n  if (palette != NULL)\n    palette=DestroyImage(palette);\n  if (clone_info != NULL)\n    clone_info=DestroyImageInfo(clone_info);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n",
    "code_after_change": "static Image *ReadCUTImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image,*palette;\n  ImageInfo *clone_info;\n  MagickBooleanType status;\n\n  MagickOffsetType\n    offset;\n\n  size_t EncodedByte;\n  unsigned char RunCount,RunValue,RunCountMasked;\n  CUTHeader  Header;\n  CUTPalHeader PalHeader;\n  ssize_t depth;\n  ssize_t i,j;\n  ssize_t ldblk;\n  unsigned char *BImgBuff=NULL,*ptrB;\n  PixelPacket *q;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read CUT image.\n  */\n  palette=NULL;\n  clone_info=NULL;\n  Header.Width=ReadBlobLSBShort(image);\n  Header.Height=ReadBlobLSBShort(image);\n  Header.Reserved=ReadBlobLSBShort(image);\n\n  if (Header.Width==0 || Header.Height==0 || Header.Reserved!=0)\n    CUT_KO:  ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  /*---This code checks first line of image---*/\n  EncodedByte=ReadBlobLSBShort(image);\n  RunCount=(unsigned char) ReadBlobByte(image);\n  RunCountMasked=RunCount & 0x7F;\n  ldblk=0;\n  while((int) RunCountMasked!=0)  /*end of line?*/\n    {\n      i=1;\n      if((int) RunCount<0x80) i=(ssize_t) RunCountMasked;\n      offset=SeekBlob(image,TellBlob(image)+i,SEEK_SET);\n      if (offset < 0)\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      if(EOFBlob(image) != MagickFalse) goto CUT_KO;  /*wrong data*/\n      EncodedByte-=i+1;\n      ldblk+=(ssize_t) RunCountMasked;\n\n      RunCount=(unsigned char) ReadBlobByte(image);\n      if(EOFBlob(image) != MagickFalse)  goto CUT_KO;  /*wrong data: unexpected eof in line*/\n      RunCountMasked=RunCount & 0x7F;\n    }\n  if(EncodedByte!=1) goto CUT_KO;  /*wrong data: size incorrect*/\n  i=0;        /*guess a number of bit planes*/\n  if(ldblk==(int) Header.Width)   i=8;\n  if(2*ldblk==(int) Header.Width) i=4;\n  if(8*ldblk==(int) Header.Width) i=1;\n  if(i==0) goto CUT_KO;    /*wrong data: incorrect bit planes*/\n  depth=i;\n\n  image->columns=Header.Width;\n  image->rows=Header.Height;\n   image->depth=8;\n   image->colors=(size_t) (GetQuantumRange(1UL*i)+1);\n \n  if (image_info->ping != MagickFalse) goto Finish;\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n \n   /* ----- Do something with palette ----- */\n   if ((clone_info=CloneImageInfo(image_info)) == NULL) goto NoPalette;\n\n\n  i=(ssize_t) strlen(clone_info->filename);\n  j=i;\n  while(--i>0)\n    {\n      if(clone_info->filename[i]=='.')\n        {\n          break;\n        }\n      if(clone_info->filename[i]=='/' || clone_info->filename[i]=='\\\\' ||\n         clone_info->filename[i]==':' )\n        {\n          i=j;\n          break;\n        }\n    }\n\n  (void) CopyMagickString(clone_info->filename+i,\".PAL\",(size_t)\n    (MaxTextExtent-i));\n  if((clone_info->file=fopen_utf8(clone_info->filename,\"rb\"))==NULL)\n    {\n      (void) CopyMagickString(clone_info->filename+i,\".pal\",(size_t)\n        (MaxTextExtent-i));\n      if((clone_info->file=fopen_utf8(clone_info->filename,\"rb\"))==NULL)\n        {\n          clone_info->filename[i]='\\0';\n          if((clone_info->file=fopen_utf8(clone_info->filename,\"rb\"))==NULL)\n            {\n              clone_info=DestroyImageInfo(clone_info);\n              clone_info=NULL;\n              goto NoPalette;\n            }\n        }\n    }\n\n  if( (palette=AcquireImage(clone_info))==NULL ) goto NoPalette;\n  status=OpenBlob(clone_info,palette,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n    ErasePalette:\n      palette=DestroyImage(palette);\n      palette=NULL;\n      goto NoPalette;\n    }\n\n\n  if(palette!=NULL)\n    {\n      (void) ReadBlob(palette,2,(unsigned char *) PalHeader.FileId);\n      if(strncmp(PalHeader.FileId,\"AH\",2) != 0) goto ErasePalette;\n      PalHeader.Version=ReadBlobLSBShort(palette);\n      PalHeader.Size=ReadBlobLSBShort(palette);\n      PalHeader.FileType=(char) ReadBlobByte(palette);\n      PalHeader.SubType=(char) ReadBlobByte(palette);\n      PalHeader.BoardID=ReadBlobLSBShort(palette);\n      PalHeader.GraphicsMode=ReadBlobLSBShort(palette);\n      PalHeader.MaxIndex=ReadBlobLSBShort(palette);\n      PalHeader.MaxRed=ReadBlobLSBShort(palette);\n      PalHeader.MaxGreen=ReadBlobLSBShort(palette);\n      PalHeader.MaxBlue=ReadBlobLSBShort(palette);\n      (void) ReadBlob(palette,20,(unsigned char *) PalHeader.PaletteId);\n\n      if(PalHeader.MaxIndex<1) goto ErasePalette;\n      image->colors=PalHeader.MaxIndex+1;\n      if (AcquireImageColormap(image,image->colors) == MagickFalse) goto NoMemory;\n\n      if(PalHeader.MaxRed==0) PalHeader.MaxRed=(unsigned int) QuantumRange;  /*avoid division by 0*/\n      if(PalHeader.MaxGreen==0) PalHeader.MaxGreen=(unsigned int) QuantumRange;\n      if(PalHeader.MaxBlue==0) PalHeader.MaxBlue=(unsigned int) QuantumRange;\n\n      for(i=0;i<=(int) PalHeader.MaxIndex;i++)\n        {      /*this may be wrong- I don't know why is palette such strange*/\n          j=(ssize_t) TellBlob(palette);\n          if((j % 512)>512-6)\n            {\n              j=((j / 512)+1)*512;\n              offset=SeekBlob(palette,j,SEEK_SET);\n              if (offset < 0)\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n            }\n          image->colormap[i].red=(Quantum) ReadBlobLSBShort(palette);\n          if (QuantumRange != (Quantum) PalHeader.MaxRed)\n            {\n              image->colormap[i].red=ClampToQuantum(((double)\n                image->colormap[i].red*QuantumRange+(PalHeader.MaxRed>>1))/\n                PalHeader.MaxRed);\n            }\n          image->colormap[i].green=(Quantum) ReadBlobLSBShort(palette);\n          if (QuantumRange != (Quantum) PalHeader.MaxGreen)\n            {\n              image->colormap[i].green=ClampToQuantum\n                (((double) image->colormap[i].green*QuantumRange+(PalHeader.MaxGreen>>1))/PalHeader.MaxGreen);\n            }\n          image->colormap[i].blue=(Quantum) ReadBlobLSBShort(palette);\n          if (QuantumRange != (Quantum) PalHeader.MaxBlue)\n            {\n              image->colormap[i].blue=ClampToQuantum\n                (((double)image->colormap[i].blue*QuantumRange+(PalHeader.MaxBlue>>1))/PalHeader.MaxBlue);\n            }\n\n        }\n    }\n\n\n\n NoPalette:\n  if(palette==NULL)\n    {\n\n      image->colors=256;\n      if (AcquireImageColormap(image,image->colors) == MagickFalse)\n        {\n        NoMemory:\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n            }\n\n      for (i=0; i < (ssize_t)image->colors; i++)\n        {\n          image->colormap[i].red=ScaleCharToQuantum((unsigned char) i);\n          image->colormap[i].green=ScaleCharToQuantum((unsigned char) i);\n          image->colormap[i].blue=ScaleCharToQuantum((unsigned char) i);\n        }\n    }\n\n\n  /* ----- Load RLE compressed raster ----- */\n  BImgBuff=(unsigned char *) AcquireQuantumMemory((size_t) ldblk,\n    sizeof(*BImgBuff));  /*Ldblk was set in the check phase*/\n  if(BImgBuff==NULL) goto NoMemory;\n\n  offset=SeekBlob(image,6 /*sizeof(Header)*/,SEEK_SET);\n  if (offset < 0)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  for (i=0; i < (int) Header.Height; i++)\n  {\n      EncodedByte=ReadBlobLSBShort(image);\n\n      ptrB=BImgBuff;\n      j=ldblk;\n\n      RunCount=(unsigned char) ReadBlobByte(image);\n      RunCountMasked=RunCount & 0x7F;\n\n      while ((int) RunCountMasked != 0)\n      {\n          if((ssize_t) RunCountMasked>j)\n            {    /*Wrong Data*/\n              RunCountMasked=(unsigned char) j;\n              if(j==0)\n                {\n                  break;\n                }\n            }\n\n          if((int) RunCount>0x80)\n            {\n              RunValue=(unsigned char) ReadBlobByte(image);\n              (void) ResetMagickMemory(ptrB,(int) RunValue,(size_t) RunCountMasked);\n            }\n          else {\n            (void) ReadBlob(image,(size_t) RunCountMasked,ptrB);\n          }\n\n          ptrB+=(int) RunCountMasked;\n          j-=(int) RunCountMasked;\n\n          if (EOFBlob(image) != MagickFalse) goto Finish;  /* wrong data: unexpected eof in line */\n          RunCount=(unsigned char) ReadBlobByte(image);\n          RunCountMasked=RunCount & 0x7F;\n        }\n\n      InsertRow(depth,BImgBuff,i,image);\n    }\n  (void) SyncImage(image);\n\n\n  /*detect monochrome image*/\n\n  if(palette==NULL)\n    {    /*attempt to detect binary (black&white) images*/\n      if ((image->storage_class == PseudoClass) &&\n          (IsGrayImage(image,&image->exception) != MagickFalse))\n        {\n          if(GetCutColors(image)==2)\n            {\n              for (i=0; i < (ssize_t)image->colors; i++)\n                {\n                  register Quantum\n                    sample;\n                  sample=ScaleCharToQuantum((unsigned char) i);\n                  if(image->colormap[i].red!=sample) goto Finish;\n                  if(image->colormap[i].green!=sample) goto Finish;\n                  if(image->colormap[i].blue!=sample) goto Finish;\n                }\n\n              image->colormap[1].red=image->colormap[1].green=\n                image->colormap[1].blue=QuantumRange;\n              for (i=0; i < (ssize_t)image->rows; i++)\n                {\n                  q=QueueAuthenticPixels(image,0,i,image->columns,1,exception);\n                  for (j=0; j < (ssize_t)image->columns; j++)\n                    {\n                      if (GetPixelRed(q) == ScaleCharToQuantum(1))\n                        {\n                          SetPixelRed(q,QuantumRange);\n                          SetPixelGreen(q,QuantumRange);\n                          SetPixelBlue(q,QuantumRange);\n                        }\n                      q++;\n                    }\n                  if (SyncAuthenticPixels(image,exception) == MagickFalse) goto Finish;\n                }\n            }\n        }\n    }\n\n Finish:\n  if (BImgBuff != NULL)\n    BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);\n  if (palette != NULL)\n    palette=DestroyImage(palette);\n  if (clone_info != NULL)\n    clone_info=DestroyImageInfo(clone_info);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 404,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-1691",
    "code_before_change": "UsbChooserContext::UsbChooserContext(Profile* profile)\n    : ChooserContextBase(profile,\n                         CONTENT_SETTINGS_TYPE_USB_GUARD,\n                          CONTENT_SETTINGS_TYPE_USB_CHOOSER_DATA),\n       is_incognito_(profile->IsOffTheRecord()),\n       client_binding_(this),\n      weak_factory_(this) {}\n",
    "code_after_change": "UsbChooserContext::UsbChooserContext(Profile* profile)\n    : ChooserContextBase(profile,\n                         CONTENT_SETTINGS_TYPE_USB_GUARD,\n                          CONTENT_SETTINGS_TYPE_USB_CHOOSER_DATA),\n       is_incognito_(profile->IsOffTheRecord()),\n       client_binding_(this),\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 409,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-2476",
    "code_before_change": "OMX_ERRORTYPE SoftAVC::internalSetParameter(OMX_INDEXTYPE index, const OMX_PTR params) {\n int32_t indexFull = index;\n\n\n     switch (indexFull) {\n         case OMX_IndexParamVideoBitrate:\n         {\n            return internalSetBitrateParams(\n                    (const OMX_VIDEO_PARAM_BITRATETYPE *)params);\n         }\n \n         case OMX_IndexParamVideoAvc:\n         {\n             OMX_VIDEO_PARAM_AVCTYPE *avcType = (OMX_VIDEO_PARAM_AVCTYPE *)params;\n \n             if (avcType->nPortIndex != 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n            mEntropyMode = 0;\n\n if (OMX_TRUE == avcType->bEntropyCodingCABAC)\n                mEntropyMode = 1;\n\n if ((avcType->nAllowedPictureTypes & OMX_VIDEO_PictureTypeB) &&\n                    avcType->nPFrames) {\n                mBframes = avcType->nBFrames / avcType->nPFrames;\n }\n\n            mIInterval = avcType->nPFrames + avcType->nBFrames;\n\n if (OMX_VIDEO_AVCLoopFilterDisable == avcType->eLoopFilterMode)\n                mDisableDeblkLevel = 4;\n\n if (avcType->nRefFrames != 1\n || avcType->bUseHadamard != OMX_TRUE\n || avcType->nRefIdx10ActiveMinus1 != 0\n || avcType->nRefIdx11ActiveMinus1 != 0\n || avcType->bWeightedPPrediction != OMX_FALSE\n || avcType->bconstIpred != OMX_FALSE\n || avcType->bDirect8x8Inference != OMX_FALSE\n || avcType->bDirectSpatialTemporal != OMX_FALSE\n || avcType->nCabacInitIdc != 0) {\n return OMX_ErrorUndefined;\n }\n\n if (OK != ConvertOmxAvcLevelToAvcSpecLevel(avcType->eLevel, &mAVCEncLevel)) {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n default:\n return SoftVideoEncoderOMXComponent::internalSetParameter(index, params);\n }\n}\n",
    "code_after_change": "OMX_ERRORTYPE SoftAVC::internalSetParameter(OMX_INDEXTYPE index, const OMX_PTR params) {\n int32_t indexFull = index;\n\n\n     switch (indexFull) {\n         case OMX_IndexParamVideoBitrate:\n         {\n            OMX_VIDEO_PARAM_BITRATETYPE *bitRate =\n                (OMX_VIDEO_PARAM_BITRATETYPE *)params;\n\n            if (!isValidOMXParam(bitRate)) {\n                return OMX_ErrorBadParameter;\n            }\n\n            return internalSetBitrateParams(bitRate);\n         }\n \n         case OMX_IndexParamVideoAvc:\n         {\n             OMX_VIDEO_PARAM_AVCTYPE *avcType = (OMX_VIDEO_PARAM_AVCTYPE *)params;\n \n            if (!isValidOMXParam(avcType)) {\n                return OMX_ErrorBadParameter;\n            }\n\n             if (avcType->nPortIndex != 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n            mEntropyMode = 0;\n\n if (OMX_TRUE == avcType->bEntropyCodingCABAC)\n                mEntropyMode = 1;\n\n if ((avcType->nAllowedPictureTypes & OMX_VIDEO_PictureTypeB) &&\n                    avcType->nPFrames) {\n                mBframes = avcType->nBFrames / avcType->nPFrames;\n }\n\n            mIInterval = avcType->nPFrames + avcType->nBFrames;\n\n if (OMX_VIDEO_AVCLoopFilterDisable == avcType->eLoopFilterMode)\n                mDisableDeblkLevel = 4;\n\n if (avcType->nRefFrames != 1\n || avcType->bUseHadamard != OMX_TRUE\n || avcType->nRefIdx10ActiveMinus1 != 0\n || avcType->nRefIdx11ActiveMinus1 != 0\n || avcType->bWeightedPPrediction != OMX_FALSE\n || avcType->bconstIpred != OMX_FALSE\n || avcType->bDirect8x8Inference != OMX_FALSE\n || avcType->bDirectSpatialTemporal != OMX_FALSE\n || avcType->nCabacInitIdc != 0) {\n return OMX_ErrorUndefined;\n }\n\n if (OK != ConvertOmxAvcLevelToAvcSpecLevel(avcType->eLevel, &mAVCEncLevel)) {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n default:\n return SoftVideoEncoderOMXComponent::internalSetParameter(index, params);\n }\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 411,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2012-2883",
    "code_before_change": "void DateTimeFieldElement::updateVisibleValue(EventBehavior eventBehavior)\n{\n    Text* const textNode = toText(firstChild());\n    const String newVisibleValue = visibleValue();\n    ASSERT(newVisibleValue.length() > 0);\n\n    if (textNode->wholeText() == newVisibleValue)\n         return;\n \n     textNode->replaceWholeText(newVisibleValue, ASSERT_NO_EXCEPTION);\n    setAttribute(aria_valuetextAttr, hasValue() ? newVisibleValue : AXDateTimeFieldEmptyValueText());\n    setAttribute(aria_valuenowAttr, newVisibleValue);\n \n     if (eventBehavior == DispatchEvent && m_fieldOwner)\n         m_fieldOwner->fieldValueChanged();\n }\n",
    "code_after_change": "void DateTimeFieldElement::updateVisibleValue(EventBehavior eventBehavior)\n{\n    Text* const textNode = toText(firstChild());\n    const String newVisibleValue = visibleValue();\n    ASSERT(newVisibleValue.length() > 0);\n\n    if (textNode->wholeText() == newVisibleValue)\n         return;\n \n     textNode->replaceWholeText(newVisibleValue, ASSERT_NO_EXCEPTION);\n    if (hasValue()) {\n        setAttribute(aria_valuetextAttr, newVisibleValue);\n        setAttribute(aria_valuenowAttr, String::number(valueForARIAValueNow()));\n    } else {\n        setAttribute(aria_valuetextAttr, AXDateTimeFieldEmptyValueText());\n        removeAttribute(aria_valuenowAttr);\n    }\n \n     if (eventBehavior == DispatchEvent && m_fieldOwner)\n         m_fieldOwner->fieldValueChanged();\n }\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 412,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-10133",
    "code_before_change": "static void jsR_calllwfunction(js_State *J, int n, js_Function *F, js_Environment *scope)\n{\n\tjs_Value v;\n\tint i;\n\n        jsR_savescope(J, scope);\n \n        if (n > F->numparams) {\n               js_pop(J, F->numparams - n);\n                n = F->numparams;\n        }\n        for (i = n; i < F->varlen; ++i)\n\t\tjs_pushundefined(J);\n\n\tjsR_run(J, F);\n\tv = *stackidx(J, -1);\n\tTOP = --BOT; /* clear stack */\n\tjs_pushvalue(J, v);\n\n\tjsR_restorescope(J);\n}\n",
    "code_after_change": "static void jsR_calllwfunction(js_State *J, int n, js_Function *F, js_Environment *scope)\n{\n\tjs_Value v;\n\tint i;\n\n        jsR_savescope(J, scope);\n \n        if (n > F->numparams) {\n               js_pop(J, n - F->numparams);\n                n = F->numparams;\n        }\n        for (i = n; i < F->varlen; ++i)\n\t\tjs_pushundefined(J);\n\n\tjsR_run(J, F);\n\tv = *stackidx(J, -1);\n\tTOP = --BOT; /* clear stack */\n\tjs_pushvalue(J, v);\n\n\tjsR_restorescope(J);\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 420,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2018-18338",
    "code_before_change": "AcceleratedStaticBitmapImage::AcceleratedStaticBitmapImage(\n    sk_sp<SkImage> image,\n    base::WeakPtr<WebGraphicsContext3DProviderWrapper>&&\n        context_provider_wrapper)\n    : paint_image_content_id_(cc::PaintImage::GetNextContentId()) {\n   CHECK(image && image->isTextureBacked());\n   texture_holder_ = std::make_unique<SkiaTextureHolder>(\n       std::move(image), std::move(context_provider_wrapper));\n  thread_checker_.DetachFromThread();\n }\n",
    "code_after_change": "AcceleratedStaticBitmapImage::AcceleratedStaticBitmapImage(\n    sk_sp<SkImage> image,\n    base::WeakPtr<WebGraphicsContext3DProviderWrapper>&&\n        context_provider_wrapper)\n    : paint_image_content_id_(cc::PaintImage::GetNextContentId()) {\n   CHECK(image && image->isTextureBacked());\n   texture_holder_ = std::make_unique<SkiaTextureHolder>(\n       std::move(image), std::move(context_provider_wrapper));\n }\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 424,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2018-7485",
    "code_before_change": "SQLRETURN SQLSetDescField( SQLHDESC descriptor_handle,\n           SQLSMALLINT rec_number, \n           SQLSMALLINT field_identifier,\n           SQLPOINTER value, \n           SQLINTEGER buffer_length )\n{\n    /*\n     * not quite sure how the descriptor can be\n     * allocated to a statement, all the documentation talks\n     * about state transitions on statement states, but the\n     * descriptor may be allocated with more than one statement\n     * at one time. Which one should I check ?\n     */\n    DMHDESC descriptor = (DMHDESC) descriptor_handle;\n    SQLRETURN ret;\n    SQLCHAR s1[ 100 + LOG_MESSAGE_LEN ];\n    int isStrField = 0;\n\n    /*\n     * check descriptor\n     */\n\n    if ( !__validate_desc( descriptor ))\n    {\n        dm_log_write( __FILE__, \n                    __LINE__, \n                    LOG_INFO, \n                    LOG_INFO, \n                    \"Error: SQL_INVALID_HANDLE\" );\n\n        return SQL_INVALID_HANDLE;\n    }\n\n    function_entry( descriptor );\n\n    if ( log_info.log_flag )\n    {\n        sprintf( descriptor -> msg, \"\\n\\t\\tEntry:\\\n\\n\\t\\t\\tDescriptor = %p\\\n\\n\\t\\t\\tRec Number = %d\\\n\\n\\t\\t\\tField Ident = %s\\\n\\n\\t\\t\\tValue = %p\\\n\\n\\t\\t\\tBuffer Length = %d\",\n                descriptor,\n                rec_number,\n                __desc_attr_as_string( s1, field_identifier ),\n                value, \n                (int)buffer_length );\n\n        dm_log_write( __FILE__, \n                __LINE__, \n                LOG_INFO, \n                LOG_INFO, \n                descriptor -> msg );\n    }\n\n    thread_protect( SQL_HANDLE_DESC, descriptor );\n\n    if ( descriptor -> connection -> state < STATE_C4 )\n    {\n        dm_log_write( __FILE__, \n                __LINE__, \n                LOG_INFO, \n                LOG_INFO, \n                \"Error: HY010\" );\n\n        __post_internal_error( &descriptor -> error,\n                ERROR_HY010, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n    /*\n     * check status of statements associated with this descriptor\n     */\n\n    if( __check_stmt_from_desc( descriptor, STATE_S8 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S9 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S10 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S11 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S12 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S13 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S14 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S15 )) {\n\n        dm_log_write( __FILE__, \n                __LINE__, \n                LOG_INFO, \n                LOG_INFO, \n                \"Error: HY010\" );\n\n        __post_internal_error( &descriptor -> error,\n                ERROR_HY010, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n\n    if ( rec_number < 0 )\n    {\n        __post_internal_error( &descriptor -> error,\n                ERROR_07009, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n    switch ( field_identifier )\n    {\n    /* Fixed-length fields: buffer_length is ignored */\n    case SQL_DESC_ALLOC_TYPE:\n    case SQL_DESC_ARRAY_SIZE:\n    case SQL_DESC_ARRAY_STATUS_PTR:\n    case SQL_DESC_BIND_OFFSET_PTR:\n    case SQL_DESC_BIND_TYPE:\n    case SQL_DESC_COUNT:\n    case SQL_DESC_ROWS_PROCESSED_PTR:\n    case SQL_DESC_AUTO_UNIQUE_VALUE:\n    case SQL_DESC_CASE_SENSITIVE:\n    case SQL_DESC_CONCISE_TYPE:\n    case SQL_DESC_DATA_PTR:\n    case SQL_DESC_DATETIME_INTERVAL_CODE:\n    case SQL_DESC_DATETIME_INTERVAL_PRECISION:\n    case SQL_DESC_DISPLAY_SIZE:\n    case SQL_DESC_FIXED_PREC_SCALE:\n    case SQL_DESC_INDICATOR_PTR:\n    case SQL_DESC_LENGTH:\n    case SQL_DESC_NULLABLE:\n    case SQL_DESC_NUM_PREC_RADIX:\n    case SQL_DESC_OCTET_LENGTH:\n    case SQL_DESC_OCTET_LENGTH_PTR:\n    case SQL_DESC_PARAMETER_TYPE:\n    case SQL_DESC_PRECISION:\n    case SQL_DESC_ROWVER:\n    case SQL_DESC_SCALE:\n    case SQL_DESC_SEARCHABLE:\n    case SQL_DESC_TYPE:\n    case SQL_DESC_UNNAMED:\n    case SQL_DESC_UNSIGNED:\n    case SQL_DESC_UPDATABLE:\n        isStrField = 0;\n        break;\n    /* Pointer to data: buffer_length must be valid */\n    case SQL_DESC_BASE_COLUMN_NAME:\n    case SQL_DESC_BASE_TABLE_NAME:\n    case SQL_DESC_CATALOG_NAME:\n    case SQL_DESC_LABEL:\n    case SQL_DESC_LITERAL_PREFIX:\n    case SQL_DESC_LITERAL_SUFFIX:\n    case SQL_DESC_LOCAL_TYPE_NAME:\n    case SQL_DESC_NAME:\n    case SQL_DESC_SCHEMA_NAME:\n    case SQL_DESC_TABLE_NAME:\n    case SQL_DESC_TYPE_NAME:\n        isStrField = 1;\n        break;\n    default:\n        isStrField = buffer_length != SQL_IS_POINTER && buffer_length != SQL_IS_INTEGER\n            && buffer_length != SQL_IS_UINTEGER && buffer_length != SQL_IS_SMALLINT &&\n            buffer_length != SQL_IS_USMALLINT;\n    }\n    \n    if ( isStrField && buffer_length < 0 && buffer_length != SQL_NTS)\n    {\n        __post_internal_error( &descriptor -> error,\n            ERROR_HY090, NULL,\n            descriptor -> connection -> environment -> requested_version );\n\n         return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n     }\n \n    if ( field_identifier == SQL_DESC_COUNT && (SQLINTEGER)value < 0 )\n     {\n         __post_internal_error( &descriptor -> error,\n                 ERROR_07009, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n         return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n     }\n     \n    if ( field_identifier == SQL_DESC_PARAMETER_TYPE && value != SQL_PARAM_INPUT\n        && value != SQL_PARAM_OUTPUT && value != SQL_PARAM_INPUT_OUTPUT &&\n        value != SQL_PARAM_INPUT_OUTPUT_STREAM && value != SQL_PARAM_OUTPUT_STREAM )\n     {\n         __post_internal_error( &descriptor -> error,\n                 ERROR_HY105, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n    if ( CHECK_SQLSETDESCFIELD( descriptor -> connection ))\n    {\n      ret = SQLSETDESCFIELD( descriptor -> connection,\n              descriptor -> driver_desc,\n              rec_number, \n              field_identifier,\n              value, \n              buffer_length );\n    }\n    else if ( CHECK_SQLSETDESCFIELDW( descriptor -> connection ))\n    {\n      SQLWCHAR *s1 = NULL;\n\n        if (isStrField)\n      {\n        s1 = ansi_to_unicode_alloc( value, buffer_length, descriptor -> connection, NULL );\n            if (SQL_NTS != buffer_length)\n            {\n                buffer_length *= sizeof(SQLWCHAR);\n            }\n      }\n      else\n      {\n              s1 = value;\n      }\n      ret = SQLSETDESCFIELDW( descriptor -> connection,\n                descriptor -> driver_desc,\n                rec_number, \n                field_identifier,\n                s1, \n                buffer_length );\n       \n        if (isStrField)\n       {\n        if (s1)\n          free(s1); \n       }\n    }\n    else \n\t{\n        dm_log_write( __FILE__, \n                __LINE__, \n                LOG_INFO, \n                LOG_INFO, \n                \"Error: IM001\" );\n\n        __post_internal_error( &descriptor -> error,\n                ERROR_IM001, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n    if ( log_info.log_flag )\n    {\n        sprintf( descriptor -> msg, \n                \"\\n\\t\\tExit:[%s]\",\n                    __get_return_status( ret, s1 ));\n\n        dm_log_write( __FILE__, \n                __LINE__, \n                LOG_INFO, \n                LOG_INFO, \n                descriptor -> msg );\n    }\n\n    return function_return( SQL_HANDLE_DESC, descriptor, ret );\n}\n",
    "code_after_change": "SQLRETURN SQLSetDescField( SQLHDESC descriptor_handle,\n           SQLSMALLINT rec_number, \n           SQLSMALLINT field_identifier,\n           SQLPOINTER value, \n           SQLINTEGER buffer_length )\n{\n    /*\n     * not quite sure how the descriptor can be\n     * allocated to a statement, all the documentation talks\n     * about state transitions on statement states, but the\n     * descriptor may be allocated with more than one statement\n     * at one time. Which one should I check ?\n     */\n    DMHDESC descriptor = (DMHDESC) descriptor_handle;\n    SQLRETURN ret;\n    SQLCHAR s1[ 100 + LOG_MESSAGE_LEN ];\n    int isStrField = 0;\n\n    /*\n     * check descriptor\n     */\n\n    if ( !__validate_desc( descriptor ))\n    {\n        dm_log_write( __FILE__, \n                    __LINE__, \n                    LOG_INFO, \n                    LOG_INFO, \n                    \"Error: SQL_INVALID_HANDLE\" );\n\n        return SQL_INVALID_HANDLE;\n    }\n\n    function_entry( descriptor );\n\n    if ( log_info.log_flag )\n    {\n        sprintf( descriptor -> msg, \"\\n\\t\\tEntry:\\\n\\n\\t\\t\\tDescriptor = %p\\\n\\n\\t\\t\\tRec Number = %d\\\n\\n\\t\\t\\tField Ident = %s\\\n\\n\\t\\t\\tValue = %p\\\n\\n\\t\\t\\tBuffer Length = %d\",\n                descriptor,\n                rec_number,\n                __desc_attr_as_string( s1, field_identifier ),\n                value, \n                (int)buffer_length );\n\n        dm_log_write( __FILE__, \n                __LINE__, \n                LOG_INFO, \n                LOG_INFO, \n                descriptor -> msg );\n    }\n\n    thread_protect( SQL_HANDLE_DESC, descriptor );\n\n    if ( descriptor -> connection -> state < STATE_C4 )\n    {\n        dm_log_write( __FILE__, \n                __LINE__, \n                LOG_INFO, \n                LOG_INFO, \n                \"Error: HY010\" );\n\n        __post_internal_error( &descriptor -> error,\n                ERROR_HY010, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n    /*\n     * check status of statements associated with this descriptor\n     */\n\n    if( __check_stmt_from_desc( descriptor, STATE_S8 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S9 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S10 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S11 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S12 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S13 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S14 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S15 )) {\n\n        dm_log_write( __FILE__, \n                __LINE__, \n                LOG_INFO, \n                LOG_INFO, \n                \"Error: HY010\" );\n\n        __post_internal_error( &descriptor -> error,\n                ERROR_HY010, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n\n    if ( rec_number < 0 )\n    {\n        __post_internal_error( &descriptor -> error,\n                ERROR_07009, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n    switch ( field_identifier )\n    {\n    /* Fixed-length fields: buffer_length is ignored */\n    case SQL_DESC_ALLOC_TYPE:\n    case SQL_DESC_ARRAY_SIZE:\n    case SQL_DESC_ARRAY_STATUS_PTR:\n    case SQL_DESC_BIND_OFFSET_PTR:\n    case SQL_DESC_BIND_TYPE:\n    case SQL_DESC_COUNT:\n    case SQL_DESC_ROWS_PROCESSED_PTR:\n    case SQL_DESC_AUTO_UNIQUE_VALUE:\n    case SQL_DESC_CASE_SENSITIVE:\n    case SQL_DESC_CONCISE_TYPE:\n    case SQL_DESC_DATA_PTR:\n    case SQL_DESC_DATETIME_INTERVAL_CODE:\n    case SQL_DESC_DATETIME_INTERVAL_PRECISION:\n    case SQL_DESC_DISPLAY_SIZE:\n    case SQL_DESC_FIXED_PREC_SCALE:\n    case SQL_DESC_INDICATOR_PTR:\n    case SQL_DESC_LENGTH:\n    case SQL_DESC_NULLABLE:\n    case SQL_DESC_NUM_PREC_RADIX:\n    case SQL_DESC_OCTET_LENGTH:\n    case SQL_DESC_OCTET_LENGTH_PTR:\n    case SQL_DESC_PARAMETER_TYPE:\n    case SQL_DESC_PRECISION:\n    case SQL_DESC_ROWVER:\n    case SQL_DESC_SCALE:\n    case SQL_DESC_SEARCHABLE:\n    case SQL_DESC_TYPE:\n    case SQL_DESC_UNNAMED:\n    case SQL_DESC_UNSIGNED:\n    case SQL_DESC_UPDATABLE:\n        isStrField = 0;\n        break;\n    /* Pointer to data: buffer_length must be valid */\n    case SQL_DESC_BASE_COLUMN_NAME:\n    case SQL_DESC_BASE_TABLE_NAME:\n    case SQL_DESC_CATALOG_NAME:\n    case SQL_DESC_LABEL:\n    case SQL_DESC_LITERAL_PREFIX:\n    case SQL_DESC_LITERAL_SUFFIX:\n    case SQL_DESC_LOCAL_TYPE_NAME:\n    case SQL_DESC_NAME:\n    case SQL_DESC_SCHEMA_NAME:\n    case SQL_DESC_TABLE_NAME:\n    case SQL_DESC_TYPE_NAME:\n        isStrField = 1;\n        break;\n    default:\n        isStrField = buffer_length != SQL_IS_POINTER && buffer_length != SQL_IS_INTEGER\n            && buffer_length != SQL_IS_UINTEGER && buffer_length != SQL_IS_SMALLINT &&\n            buffer_length != SQL_IS_USMALLINT;\n    }\n    \n    if ( isStrField && buffer_length < 0 && buffer_length != SQL_NTS)\n    {\n        __post_internal_error( &descriptor -> error,\n            ERROR_HY090, NULL,\n            descriptor -> connection -> environment -> requested_version );\n\n         return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n     }\n \n    if ( field_identifier == SQL_DESC_COUNT && (intptr_t)value < 0 )\n     {\n         __post_internal_error( &descriptor -> error,\n                 ERROR_07009, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n         return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n     }\n     \n    if ( field_identifier == SQL_DESC_PARAMETER_TYPE && (intptr_t)value != SQL_PARAM_INPUT\n        && (intptr_t)value != SQL_PARAM_OUTPUT && (intptr_t)value != SQL_PARAM_INPUT_OUTPUT &&\n        (intptr_t)value != SQL_PARAM_INPUT_OUTPUT_STREAM && (intptr_t)value != SQL_PARAM_OUTPUT_STREAM )\n     {\n         __post_internal_error( &descriptor -> error,\n                 ERROR_HY105, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n    if ( CHECK_SQLSETDESCFIELD( descriptor -> connection ))\n    {\n      ret = SQLSETDESCFIELD( descriptor -> connection,\n              descriptor -> driver_desc,\n              rec_number, \n              field_identifier,\n              value, \n              buffer_length );\n    }\n    else if ( CHECK_SQLSETDESCFIELDW( descriptor -> connection ))\n    {\n      SQLWCHAR *s1 = NULL;\n\n        if (isStrField)\n      {\n        s1 = ansi_to_unicode_alloc( value, buffer_length, descriptor -> connection, NULL );\n            if (SQL_NTS != buffer_length)\n            {\n                buffer_length *= sizeof(SQLWCHAR);\n            }\n      }\n      else\n      {\n              s1 = value;\n      }\n      ret = SQLSETDESCFIELDW( descriptor -> connection,\n                descriptor -> driver_desc,\n                rec_number, \n                field_identifier,\n                s1, \n                buffer_length );\n       \n        if (isStrField)\n       {\n        if (s1)\n          free(s1); \n       }\n    }\n    else \n\t{\n        dm_log_write( __FILE__, \n                __LINE__, \n                LOG_INFO, \n                LOG_INFO, \n                \"Error: IM001\" );\n\n        __post_internal_error( &descriptor -> error,\n                ERROR_IM001, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n    if ( log_info.log_flag )\n    {\n        sprintf( descriptor -> msg, \n                \"\\n\\t\\tExit:[%s]\",\n                    __get_return_status( ret, s1 ));\n\n        dm_log_write( __FILE__, \n                __LINE__, \n                LOG_INFO, \n                LOG_INFO, \n                descriptor -> msg );\n    }\n\n    return function_return( SQL_HANDLE_DESC, descriptor, ret );\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 426,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2017-5225",
    "code_before_change": "DECLAREcpFunc(cpSeparate2ContigByRow)\n{\n\ttsize_t scanlinesizein = TIFFScanlineSize(in);\n\ttsize_t scanlinesizeout = TIFFScanlineSize(out);\n\ttdata_t inbuf;\n\ttdata_t outbuf;\n\tregister uint8 *inp, *outp;\n \tregister uint32 n;\n \tuint32 row;\n \ttsample_t s;\n \n \tinbuf = _TIFFmalloc(scanlinesizein);\n \toutbuf = _TIFFmalloc(scanlinesizeout);\n\tif (!inbuf || !outbuf)\n                goto bad;\n\t_TIFFmemset(inbuf, 0, scanlinesizein);\n\t_TIFFmemset(outbuf, 0, scanlinesizeout);\n\tfor (row = 0; row < imagelength; row++) {\n\t\t/* merge channels */\n\t\tfor (s = 0; s < spp; s++) {\n\t\t\tif (TIFFReadScanline(in, inbuf, row, s) < 0\n\t\t\t    && !ignore) {\n\t\t\t\tTIFFError(TIFFFileName(in),\n\t\t\t\t    \"Error, can't read scanline %lu\",\n\t\t\t\t    (unsigned long) row);\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tinp = (uint8*)inbuf;\n\t\t\toutp = ((uint8*)outbuf) + s;\n\t\t\tfor (n = imagewidth; n-- > 0;) {\n\t\t\t\t*outp = *inp++;\n\t\t\t\toutp += spp;\n\t\t\t}\n\t\t}\n\t\tif (TIFFWriteScanline(out, outbuf, row, 0) < 0) {\n\t\t\tTIFFError(TIFFFileName(out),\n\t\t\t    \"Error, can't write scanline %lu\",\n\t\t\t    (unsigned long) row);\n\t\t\tgoto bad;\n\t\t}\n\t}\n\tif (inbuf) _TIFFfree(inbuf);\n\tif (outbuf) _TIFFfree(outbuf);\n\treturn 1;\nbad:\n\tif (inbuf) _TIFFfree(inbuf);\n\tif (outbuf) _TIFFfree(outbuf);\n\treturn 0;\n}\n",
    "code_after_change": "DECLAREcpFunc(cpSeparate2ContigByRow)\n{\n\ttsize_t scanlinesizein = TIFFScanlineSize(in);\n\ttsize_t scanlinesizeout = TIFFScanlineSize(out);\n\ttdata_t inbuf;\n\ttdata_t outbuf;\n\tregister uint8 *inp, *outp;\n \tregister uint32 n;\n \tuint32 row;\n \ttsample_t s;\n        uint16 bps = 0;\n\n        (void) TIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bps);\n        if( bps != 8 )\n        {\n            TIFFError(TIFFFileName(in),\n                      \"Error, can only handle BitsPerSample=8 in %s\",\n                      \"cpSeparate2ContigByRow\");\n            return 0;\n        }\n \n \tinbuf = _TIFFmalloc(scanlinesizein);\n \toutbuf = _TIFFmalloc(scanlinesizeout);\n\tif (!inbuf || !outbuf)\n                goto bad;\n\t_TIFFmemset(inbuf, 0, scanlinesizein);\n\t_TIFFmemset(outbuf, 0, scanlinesizeout);\n\tfor (row = 0; row < imagelength; row++) {\n\t\t/* merge channels */\n\t\tfor (s = 0; s < spp; s++) {\n\t\t\tif (TIFFReadScanline(in, inbuf, row, s) < 0\n\t\t\t    && !ignore) {\n\t\t\t\tTIFFError(TIFFFileName(in),\n\t\t\t\t    \"Error, can't read scanline %lu\",\n\t\t\t\t    (unsigned long) row);\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tinp = (uint8*)inbuf;\n\t\t\toutp = ((uint8*)outbuf) + s;\n\t\t\tfor (n = imagewidth; n-- > 0;) {\n\t\t\t\t*outp = *inp++;\n\t\t\t\toutp += spp;\n\t\t\t}\n\t\t}\n\t\tif (TIFFWriteScanline(out, outbuf, row, 0) < 0) {\n\t\t\tTIFFError(TIFFFileName(out),\n\t\t\t    \"Error, can't write scanline %lu\",\n\t\t\t    (unsigned long) row);\n\t\t\tgoto bad;\n\t\t}\n\t}\n\tif (inbuf) _TIFFfree(inbuf);\n\tif (outbuf) _TIFFfree(outbuf);\n\treturn 1;\nbad:\n\tif (inbuf) _TIFFfree(inbuf);\n\tif (outbuf) _TIFFfree(outbuf);\n\treturn 0;\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 429,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2014-4502",
    "code_before_change": "bool initiate_stratum(struct pool *pool)\n{\n\tbool ret = false, recvd = false, noresume = false, sockd = false;\n\tchar s[RBUFSIZE], *sret = NULL, *nonce1, *sessionid;\n\tjson_t *val = NULL, *res_val, *err_val;\n\tjson_error_t err;\n\tint n2size;\n\nresend:\n\tif (!setup_stratum_socket(pool)) {\n\t\t/* FIXME: change to LOG_DEBUG when issue #88 resolved */\n\t\tapplog(LOG_INFO, \"setup_stratum_socket() on %s failed\", get_pool_name(pool));\n\t\tsockd = false;\n\t\tgoto out;\n\t}\n\n\tsockd = true;\n\n\tif (recvd) {\n\t\t/* Get rid of any crap lying around if we're resending */\n\t\tclear_sock(pool);\n\t\tsprintf(s, \"{\\\"id\\\": %d, \\\"method\\\": \\\"mining.subscribe\\\", \\\"params\\\": []}\", swork_id++);\n\t} else {\n\t\tif (pool->sessionid)\n\t\t\tsprintf(s, \"{\\\"id\\\": %d, \\\"method\\\": \\\"mining.subscribe\\\", \\\"params\\\": [\\\"\"PACKAGE\"/\"VERSION\"\\\", \\\"%s\\\"]}\", swork_id++, pool->sessionid);\n\t\telse\n\t\t\tsprintf(s, \"{\\\"id\\\": %d, \\\"method\\\": \\\"mining.subscribe\\\", \\\"params\\\": [\\\"\"PACKAGE\"/\"VERSION\"\\\"]}\", swork_id++);\n\t}\n\n\tif (__stratum_send(pool, s, strlen(s)) != SEND_OK) {\n\t\tapplog(LOG_DEBUG, \"Failed to send s in initiate_stratum\");\n\t\tgoto out;\n\t}\n\n\tif (!socket_full(pool, DEFAULT_SOCKWAIT)) {\n\t\tapplog(LOG_DEBUG, \"Timed out waiting for response in initiate_stratum\");\n\t\tgoto out;\n\t}\n\n\tsret = recv_line(pool);\n\tif (!sret)\n\t\tgoto out;\n\n\trecvd = true;\n\n\tval = JSON_LOADS(sret, &err);\n\tfree(sret);\n\tif (!val) {\n\t\tapplog(LOG_INFO, \"JSON decode failed(%d): %s\", err.line, err.text);\n\t\tgoto out;\n\t}\n\n\tres_val = json_object_get(val, \"result\");\n\terr_val = json_object_get(val, \"error\");\n\n\tif (!res_val || json_is_null(res_val) ||\n\t    (err_val && !json_is_null(err_val))) {\n\t\tchar *ss;\n\n\t\tif (err_val)\n\t\t\tss = json_dumps(err_val, JSON_INDENT(3));\n\t\telse\n\t\t\tss = strdup(\"(unknown reason)\");\n\n\t\tapplog(LOG_INFO, \"JSON-RPC decode failed: %s\", ss);\n\n\t\tfree(ss);\n\n\t\tgoto out;\n\t}\n\n\tsessionid = get_sessionid(res_val);\n\tif (!sessionid)\n\t\tapplog(LOG_DEBUG, \"Failed to get sessionid in initiate_stratum\");\n\tnonce1 = json_array_string(res_val, 1);\n\tif (!nonce1) {\n\t\tapplog(LOG_INFO, \"Failed to get nonce1 in initiate_stratum\");\n\t\tfree(sessionid);\n \t\tgoto out;\n \t}\n \tn2size = json_integer_value(json_array_get(res_val, 2));\n\tif (!n2size) {\n \t\tapplog(LOG_INFO, \"Failed to get n2size in initiate_stratum\");\n \t\tfree(sessionid);\n \t\tfree(nonce1);\n\t\tgoto out;\n\t}\n\n\tcg_wlock(&pool->data_lock);\n\tpool->sessionid = sessionid;\n\tpool->nonce1 = nonce1;\n\tpool->n1_len = strlen(nonce1) / 2;\n\tfree(pool->nonce1bin);\n\tpool->nonce1bin = (unsigned char *)calloc(pool->n1_len, 1);\n\tif (unlikely(!pool->nonce1bin))\n\t\tquithere(1, \"Failed to calloc pool->nonce1bin\");\n\thex2bin(pool->nonce1bin, pool->nonce1, pool->n1_len);\n\tpool->n2size = n2size;\n\tcg_wunlock(&pool->data_lock);\n\n\tif (sessionid)\n\t\tapplog(LOG_DEBUG, \"%s stratum session id: %s\", get_pool_name(pool), pool->sessionid);\n\n\tret = true;\nout:\n\tif (ret) {\n\t\tif (!pool->stratum_url)\n\t\t\tpool->stratum_url = pool->sockaddr_url;\n\t\tpool->stratum_active = true;\n\t\tpool->swork.diff = 1;\n\t\tif (opt_protocol) {\n\t\t\tapplog(LOG_DEBUG, \"%s confirmed mining.subscribe with extranonce1 %s extran2size %d\",\n\t\t\t       get_pool_name(pool), pool->nonce1, pool->n2size);\n\t\t}\n\t} else {\n\t\tif (recvd && !noresume) {\n\t\t\t/* Reset the sessionid used for stratum resuming in case the pool\n\t\t\t* does not support it, or does not know how to respond to the\n\t\t\t* presence of the sessionid parameter. */\n\t\t\tcg_wlock(&pool->data_lock);\n\t\t\tfree(pool->sessionid);\n\t\t\tfree(pool->nonce1);\n\t\t\tpool->sessionid = pool->nonce1 = NULL;\n\t\t\tcg_wunlock(&pool->data_lock);\n\n\t\t\tapplog(LOG_DEBUG, \"Failed to resume stratum, trying afresh\");\n\t\t\tnoresume = true;\n\t\t\tjson_decref(val);\n\t\t\tgoto resend;\n\t\t}\n\t\tapplog(LOG_DEBUG, \"Initiating stratum failed on %s\", get_pool_name(pool));\n\t\tif (sockd) {\n\t\t  applog(LOG_DEBUG, \"Suspending stratum on %s\", get_pool_name(pool));\n\t\t\tsuspend_stratum(pool);\n\t\t}\n\t}\n\n\tjson_decref(val);\n\treturn ret;\n}\n",
    "code_after_change": "bool initiate_stratum(struct pool *pool)\n{\n\tbool ret = false, recvd = false, noresume = false, sockd = false;\n\tchar s[RBUFSIZE], *sret = NULL, *nonce1, *sessionid;\n\tjson_t *val = NULL, *res_val, *err_val;\n\tjson_error_t err;\n\tint n2size;\n\nresend:\n\tif (!setup_stratum_socket(pool)) {\n\t\t/* FIXME: change to LOG_DEBUG when issue #88 resolved */\n\t\tapplog(LOG_INFO, \"setup_stratum_socket() on %s failed\", get_pool_name(pool));\n\t\tsockd = false;\n\t\tgoto out;\n\t}\n\n\tsockd = true;\n\n\tif (recvd) {\n\t\t/* Get rid of any crap lying around if we're resending */\n\t\tclear_sock(pool);\n\t\tsprintf(s, \"{\\\"id\\\": %d, \\\"method\\\": \\\"mining.subscribe\\\", \\\"params\\\": []}\", swork_id++);\n\t} else {\n\t\tif (pool->sessionid)\n\t\t\tsprintf(s, \"{\\\"id\\\": %d, \\\"method\\\": \\\"mining.subscribe\\\", \\\"params\\\": [\\\"\"PACKAGE\"/\"VERSION\"\\\", \\\"%s\\\"]}\", swork_id++, pool->sessionid);\n\t\telse\n\t\t\tsprintf(s, \"{\\\"id\\\": %d, \\\"method\\\": \\\"mining.subscribe\\\", \\\"params\\\": [\\\"\"PACKAGE\"/\"VERSION\"\\\"]}\", swork_id++);\n\t}\n\n\tif (__stratum_send(pool, s, strlen(s)) != SEND_OK) {\n\t\tapplog(LOG_DEBUG, \"Failed to send s in initiate_stratum\");\n\t\tgoto out;\n\t}\n\n\tif (!socket_full(pool, DEFAULT_SOCKWAIT)) {\n\t\tapplog(LOG_DEBUG, \"Timed out waiting for response in initiate_stratum\");\n\t\tgoto out;\n\t}\n\n\tsret = recv_line(pool);\n\tif (!sret)\n\t\tgoto out;\n\n\trecvd = true;\n\n\tval = JSON_LOADS(sret, &err);\n\tfree(sret);\n\tif (!val) {\n\t\tapplog(LOG_INFO, \"JSON decode failed(%d): %s\", err.line, err.text);\n\t\tgoto out;\n\t}\n\n\tres_val = json_object_get(val, \"result\");\n\terr_val = json_object_get(val, \"error\");\n\n\tif (!res_val || json_is_null(res_val) ||\n\t    (err_val && !json_is_null(err_val))) {\n\t\tchar *ss;\n\n\t\tif (err_val)\n\t\t\tss = json_dumps(err_val, JSON_INDENT(3));\n\t\telse\n\t\t\tss = strdup(\"(unknown reason)\");\n\n\t\tapplog(LOG_INFO, \"JSON-RPC decode failed: %s\", ss);\n\n\t\tfree(ss);\n\n\t\tgoto out;\n\t}\n\n\tsessionid = get_sessionid(res_val);\n\tif (!sessionid)\n\t\tapplog(LOG_DEBUG, \"Failed to get sessionid in initiate_stratum\");\n\tnonce1 = json_array_string(res_val, 1);\n\tif (!nonce1) {\n\t\tapplog(LOG_INFO, \"Failed to get nonce1 in initiate_stratum\");\n\t\tfree(sessionid);\n \t\tgoto out;\n \t}\n \tn2size = json_integer_value(json_array_get(res_val, 2));\n\tif (n2size < 1)\n\t{\n \t\tapplog(LOG_INFO, \"Failed to get n2size in initiate_stratum\");\n \t\tfree(sessionid);\n \t\tfree(nonce1);\n\t\tgoto out;\n\t}\n\n\tcg_wlock(&pool->data_lock);\n\tpool->sessionid = sessionid;\n\tpool->nonce1 = nonce1;\n\tpool->n1_len = strlen(nonce1) / 2;\n\tfree(pool->nonce1bin);\n\tpool->nonce1bin = (unsigned char *)calloc(pool->n1_len, 1);\n\tif (unlikely(!pool->nonce1bin))\n\t\tquithere(1, \"Failed to calloc pool->nonce1bin\");\n\thex2bin(pool->nonce1bin, pool->nonce1, pool->n1_len);\n\tpool->n2size = n2size;\n\tcg_wunlock(&pool->data_lock);\n\n\tif (sessionid)\n\t\tapplog(LOG_DEBUG, \"%s stratum session id: %s\", get_pool_name(pool), pool->sessionid);\n\n\tret = true;\nout:\n\tif (ret) {\n\t\tif (!pool->stratum_url)\n\t\t\tpool->stratum_url = pool->sockaddr_url;\n\t\tpool->stratum_active = true;\n\t\tpool->swork.diff = 1;\n\t\tif (opt_protocol) {\n\t\t\tapplog(LOG_DEBUG, \"%s confirmed mining.subscribe with extranonce1 %s extran2size %d\",\n\t\t\t       get_pool_name(pool), pool->nonce1, pool->n2size);\n\t\t}\n\t} else {\n\t\tif (recvd && !noresume) {\n\t\t\t/* Reset the sessionid used for stratum resuming in case the pool\n\t\t\t* does not support it, or does not know how to respond to the\n\t\t\t* presence of the sessionid parameter. */\n\t\t\tcg_wlock(&pool->data_lock);\n\t\t\tfree(pool->sessionid);\n\t\t\tfree(pool->nonce1);\n\t\t\tpool->sessionid = pool->nonce1 = NULL;\n\t\t\tcg_wunlock(&pool->data_lock);\n\n\t\t\tapplog(LOG_DEBUG, \"Failed to resume stratum, trying afresh\");\n\t\t\tnoresume = true;\n\t\t\tjson_decref(val);\n\t\t\tgoto resend;\n\t\t}\n\t\tapplog(LOG_DEBUG, \"Initiating stratum failed on %s\", get_pool_name(pool));\n\t\tif (sockd) {\n\t\t  applog(LOG_DEBUG, \"Suspending stratum on %s\", get_pool_name(pool));\n\t\t\tsuspend_stratum(pool);\n\t\t}\n\t}\n\n\tjson_decref(val);\n\treturn ret;\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 430,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2015-1290",
    "code_before_change": "void LogoService::SetClockForTests(std::unique_ptr<base::Clock> clock) {\n  clock_for_test_ = std::move(clock);\n}\n",
    "code_after_change": "void LogoService::SetClockForTests(std::unique_ptr<base::Clock> clock) {\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 435,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2019-16058",
    "code_before_change": "static int key_verify(pam_handle_t *pamh, int flags, PKCS11_KEY *authkey)\n {\n \tint ok = 0;\n \tunsigned char challenge[30];\n\tunsigned char signature[256];\n\tunsigned int siglen = sizeof signature;\n \tconst EVP_MD *md = EVP_sha1();\n \tEVP_MD_CTX *md_ctx = EVP_MD_CTX_new();\n \tEVP_PKEY *privkey = PKCS11_get_private_key(authkey);\n \tEVP_PKEY *pubkey = PKCS11_get_public_key(authkey);\n \n \t/* Verify a SHA-1 hash of random data, signed by the key.\n \t *\n \t * Note that this will not work keys that aren't eligible for signing.\n\t * Unfortunately, libp11 currently has no way of checking\n\t * C_GetAttributeValue(CKA_SIGN), see\n\t * https://github.com/OpenSC/libp11/issues/219. Since we don't want to\n\t * implement try and error, we live with this limitation */\n\tif (1 != randomize(pamh, challenge, sizeof challenge)) {\n\t\tgoto err;\n\t}\n\tif (NULL == pubkey || NULL == privkey || NULL == md_ctx || NULL == md\n\t\t\t|| !EVP_SignInit(md_ctx, md)\n\t\t\t|| !EVP_SignUpdate(md_ctx, challenge, sizeof challenge)\n\t\t\t|| !EVP_SignFinal(md_ctx, signature, &siglen, privkey)\n\t\t\t|| !EVP_MD_CTX_reset(md_ctx)\n\t\t\t|| !EVP_VerifyInit(md_ctx, md)\n\t\t\t|| !EVP_VerifyUpdate(md_ctx, challenge, sizeof challenge)\n\t\t\t|| 1 != EVP_VerifyFinal(md_ctx, signature, siglen, pubkey)) {\n\t\tpam_syslog(pamh, LOG_DEBUG, \"Error verifying key: %s\\n\",\n\t\t\t\tERR_reason_error_string(ERR_get_error()));\n\t\tprompt(flags, pamh, PAM_ERROR_MSG, NULL, _(\"Error verifying key\"));\n\t\tgoto err;\n\t}\n \tok = 1;\n \n err:\n \tif (NULL != pubkey)\n \t\tEVP_PKEY_free(pubkey);\n \tif (NULL != privkey)\n\t\tEVP_PKEY_free(privkey);\n\tif (NULL != md_ctx) {\n\t\tEVP_MD_CTX_free(md_ctx);\n\t}\n\treturn ok;\n}\n",
    "code_after_change": "static int key_verify(pam_handle_t *pamh, int flags, PKCS11_KEY *authkey)\n {\n \tint ok = 0;\n \tunsigned char challenge[30];\n\tunsigned char *signature = NULL;\n\tunsigned int siglen;\n \tconst EVP_MD *md = EVP_sha1();\n \tEVP_MD_CTX *md_ctx = EVP_MD_CTX_new();\n \tEVP_PKEY *privkey = PKCS11_get_private_key(authkey);\n \tEVP_PKEY *pubkey = PKCS11_get_public_key(authkey);\n \n\tif (NULL == privkey)\n\t\tgoto err;\n\tsiglen = EVP_PKEY_size(privkey);\n\tif (siglen <= 0)\n\t\tgoto err;\n\tsignature = malloc(siglen);\n\tif (NULL == signature)\n\t\tgoto err;\n\n \t/* Verify a SHA-1 hash of random data, signed by the key.\n \t *\n \t * Note that this will not work keys that aren't eligible for signing.\n\t * Unfortunately, libp11 currently has no way of checking\n\t * C_GetAttributeValue(CKA_SIGN), see\n\t * https://github.com/OpenSC/libp11/issues/219. Since we don't want to\n\t * implement try and error, we live with this limitation */\n\tif (1 != randomize(pamh, challenge, sizeof challenge)) {\n\t\tgoto err;\n\t}\n\tif (NULL == pubkey || NULL == privkey || NULL == md_ctx || NULL == md\n\t\t\t|| !EVP_SignInit(md_ctx, md)\n\t\t\t|| !EVP_SignUpdate(md_ctx, challenge, sizeof challenge)\n\t\t\t|| !EVP_SignFinal(md_ctx, signature, &siglen, privkey)\n\t\t\t|| !EVP_MD_CTX_reset(md_ctx)\n\t\t\t|| !EVP_VerifyInit(md_ctx, md)\n\t\t\t|| !EVP_VerifyUpdate(md_ctx, challenge, sizeof challenge)\n\t\t\t|| 1 != EVP_VerifyFinal(md_ctx, signature, siglen, pubkey)) {\n\t\tpam_syslog(pamh, LOG_DEBUG, \"Error verifying key: %s\\n\",\n\t\t\t\tERR_reason_error_string(ERR_get_error()));\n\t\tprompt(flags, pamh, PAM_ERROR_MSG, NULL, _(\"Error verifying key\"));\n\t\tgoto err;\n\t}\n \tok = 1;\n \n err:\n\tfree(signature);\n \tif (NULL != pubkey)\n \t\tEVP_PKEY_free(pubkey);\n \tif (NULL != privkey)\n\t\tEVP_PKEY_free(privkey);\n\tif (NULL != md_ctx) {\n\t\tEVP_MD_CTX_free(md_ctx);\n\t}\n\treturn ok;\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 442,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2018-14359",
    "code_before_change": "int mutt_b64_decode(char *out, const char *in)\n {\n   int len = 0;\n   unsigned char digit4;\n\n  do\n  {\n    const unsigned char digit1 = in[0];\n    if ((digit1 > 127) || (base64val(digit1) == BAD))\n      return -1;\n    const unsigned char digit2 = in[1];\n    if ((digit2 > 127) || (base64val(digit2) == BAD))\n      return -1;\n    const unsigned char digit3 = in[2];\n    if ((digit3 > 127) || ((digit3 != '=') && (base64val(digit3) == BAD)))\n      return -1;\n    digit4 = in[3];\n    if ((digit4 > 127) || ((digit4 != '=') && (base64val(digit4) == BAD)))\n      return -1;\n     in += 4;\n \n     /* digits are already sanity-checked */\n     *out++ = (base64val(digit1) << 2) | (base64val(digit2) >> 4);\n     len++;\n     if (digit3 != '=')\n     {\n       *out++ = ((base64val(digit2) << 4) & 0xf0) | (base64val(digit3) >> 2);\n       len++;\n       if (digit4 != '=')\n       {\n         *out++ = ((base64val(digit3) << 6) & 0xc0) | base64val(digit4);\n         len++;\n       }\n    }\n  } while (*in && digit4 != '=');\n\n  return len;\n}\n",
    "code_after_change": "int mutt_b64_decode(char *out, const char *in)\nint mutt_b64_decode(char *out, const char *in, size_t olen)\n {\n   int len = 0;\n   unsigned char digit4;\n\n  do\n  {\n    const unsigned char digit1 = in[0];\n    if ((digit1 > 127) || (base64val(digit1) == BAD))\n      return -1;\n    const unsigned char digit2 = in[1];\n    if ((digit2 > 127) || (base64val(digit2) == BAD))\n      return -1;\n    const unsigned char digit3 = in[2];\n    if ((digit3 > 127) || ((digit3 != '=') && (base64val(digit3) == BAD)))\n      return -1;\n    digit4 = in[3];\n    if ((digit4 > 127) || ((digit4 != '=') && (base64val(digit4) == BAD)))\n      return -1;\n     in += 4;\n \n     /* digits are already sanity-checked */\n    if (len == olen)\n      return len;\n     *out++ = (base64val(digit1) << 2) | (base64val(digit2) >> 4);\n     len++;\n     if (digit3 != '=')\n     {\n      if (len == olen)\n        return len;\n       *out++ = ((base64val(digit2) << 4) & 0xf0) | (base64val(digit3) >> 2);\n       len++;\n       if (digit4 != '=')\n       {\n        if (len == olen)\n          return len;\n         *out++ = ((base64val(digit3) << 6) & 0xc0) | base64val(digit4);\n         len++;\n       }\n    }\n  } while (*in && digit4 != '=');\n\n  return len;\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 453,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-0835",
    "code_before_change": "void impeg2d_dec_p_mb_params(dec_state_t *ps_dec)\n {\n     stream_t *ps_stream = &ps_dec->s_bit_stream;\n     UWORD16 u2_mb_addr_incr;\n    UWORD16 u2_total_len;\n    UWORD16 u2_len;\n    UWORD16 u2_mb_type;\n    UWORD32 u4_next_word;\n const dec_mb_params_t *ps_dec_mb_params;\n if(impeg2d_bit_stream_nxt(ps_stream,1) == 1)\n {\n        impeg2d_bit_stream_flush(ps_stream,1);\n\n }\n else\n {\n        u2_mb_addr_incr = impeg2d_get_mb_addr_incr(ps_stream);\n if(0 == ps_dec->u2_first_mb)\n {\n /****************************************************************/\n /* If the 2nd member of a field picture pair is a P picture and */\n /* the first one was an I picture, there cannot be any skipped  */\n /* MBs in the second field picture                              */\n /****************************************************************/\n /*\n            if((dec->picture_structure != FRAME_PICTURE) &&\n                (dec->f->FieldFuncCall != 0) &&\n                (dec->las->u1_last_coded_vop_type == I))\n            {\n                core0_err_handler((void *)(VOLParams),\n                    ITTMPEG2_ERR_INVALID_MB_SKIP);\n            }\n            */\n /****************************************************************/\n /* In MPEG-2, the last MB of the row cannot be skipped and the  */\n /* MBAddrIncr cannot be such that it will take the current MB   */\n /* beyond the current row                                       */\n /* In MPEG-1, the slice could start and end anywhere and is not */\n /* restricted to a row like in MPEG-2. Hence this check should  */\n /* not be done for MPEG-1 streams.                              */\n /****************************************************************/\n if(ps_dec->u2_is_mpeg2 && ((ps_dec->u2_mb_x + u2_mb_addr_incr) > ps_dec->u2_num_horiz_mb) )\n {\n                u2_mb_addr_incr    = ps_dec->u2_num_horiz_mb - ps_dec->u2_mb_x;\n }\n\n            impeg2d_dec_skip_mbs(ps_dec, (UWORD16)(u2_mb_addr_incr - 1));\n }\n\n }\n    u4_next_word = (UWORD16)impeg2d_bit_stream_nxt(ps_stream,16);\n /*-----------------------------------------------------------------------*/\n /* MB type                                                               */\n /*-----------------------------------------------------------------------*/\n {\n        u2_mb_type   = ps_dec->pu2_mb_type[BITS((UWORD16)u4_next_word,15,10)];\n        u2_len      = BITS(u2_mb_type,15,8);\n        u2_total_len = u2_len;\n        u4_next_word = (UWORD16)LSW((UWORD16)u4_next_word << u2_len);\n }\n /*-----------------------------------------------------------------------*/\n /* motion type                                                           */\n /*-----------------------------------------------------------------------*/\n {\n if((u2_mb_type & MB_FORW_OR_BACK) &&  ps_dec->u2_read_motion_type)\n {\n            WORD32 i4_motion_type;\n            ps_dec->u2_motion_type = BITS((UWORD16)u4_next_word,15,14);\n            u2_total_len        += MB_MOTION_TYPE_LEN;\n            u4_next_word        = (UWORD16)LSW((UWORD16)u4_next_word << MB_MOTION_TYPE_LEN);\n            i4_motion_type     = ps_dec->u2_motion_type;\n\n if((i4_motion_type == 0) ||\n (i4_motion_type == 4) ||\n (i4_motion_type > 7))\n {\n                i4_motion_type = 1;\n }\n\n }\n }\n /*-----------------------------------------------------------------------*/\n /* dct type                                                              */\n /*-----------------------------------------------------------------------*/\n {\n if((u2_mb_type & MB_CODED) && ps_dec->u2_read_dct_type)\n {\n            ps_dec->u2_field_dct = BIT((UWORD16)u4_next_word,15);\n            u2_total_len += MB_DCT_TYPE_LEN;\n            u4_next_word = (UWORD16)LSW((UWORD16)u4_next_word << MB_DCT_TYPE_LEN);\n }\n }\n /*-----------------------------------------------------------------------*/\n /* Quant scale code                                                      */\n /*-----------------------------------------------------------------------*/\n if(u2_mb_type & MB_QUANT)\n {\n        UWORD16 u2_quant_scale_code;\n        u2_quant_scale_code = BITS((UWORD16)u4_next_word,15,11);\n\n        ps_dec->u1_quant_scale = (ps_dec->u2_q_scale_type) ?\n            gau1_impeg2_non_linear_quant_scale[u2_quant_scale_code] : (u2_quant_scale_code << 1);\n        u2_total_len += MB_QUANT_SCALE_CODE_LEN;\n }\n    impeg2d_bit_stream_flush(ps_stream,u2_total_len);\n /*-----------------------------------------------------------------------*/\n /* Set the function pointers                                             */\n /*-----------------------------------------------------------------------*/\n    ps_dec->u2_coded_mb    = (UWORD16)(u2_mb_type & MB_CODED);\n\n if(u2_mb_type & MB_FORW_OR_BACK)\n {\n\n        UWORD16 refPic      = !(u2_mb_type & MB_MV_FORW);\n        UWORD16 index       = (ps_dec->u2_motion_type);\n        ps_dec->u2_prev_intra_mb    = 0;\n\n         ps_dec->e_mb_pred         = (e_pred_direction_t)refPic;\n         ps_dec_mb_params = &ps_dec->ps_func_forw_or_back[index];\n         ps_dec->s_mb_type = ps_dec_mb_params->s_mb_type;\n         ps_dec_mb_params->pf_func_mb_params(ps_dec);\n \n     }\n else if(u2_mb_type & MB_TYPE_INTRA)\n {\n        ps_dec->u2_prev_intra_mb    = 1;\n        impeg2d_dec_intra_mb(ps_dec);\n\n }\n else\n {\n        ps_dec->u2_prev_intra_mb    = 0;\n        ps_dec->e_mb_pred = FORW;\n        ps_dec->u2_motion_type = 0;\n        impeg2d_dec_0mv_coded_mb(ps_dec);\n }\n\n /*-----------------------------------------------------------------------*/\n /* decode cbp                                                            */\n /*-----------------------------------------------------------------------*/\n if((u2_mb_type & MB_TYPE_INTRA))\n {\n        ps_dec->u2_cbp  = 0x3f;\n        ps_dec->u2_prev_intra_mb    = 1;\n }\n else\n {\n        ps_dec->u2_prev_intra_mb  = 0;\n        ps_dec->u2_def_dc_pred[Y_LUMA] = 128 << ps_dec->u2_intra_dc_precision;\n        ps_dec->u2_def_dc_pred[U_CHROMA] = 128 << ps_dec->u2_intra_dc_precision;\n        ps_dec->u2_def_dc_pred[V_CHROMA] = 128 << ps_dec->u2_intra_dc_precision;\n if((ps_dec->u2_coded_mb))\n {\n            UWORD16 cbpValue;\n            cbpValue  = gau2_impeg2d_cbp_code[impeg2d_bit_stream_nxt(ps_stream,MB_CBP_LEN)];\n            ps_dec->u2_cbp  = cbpValue & 0xFF;\n            impeg2d_bit_stream_flush(ps_stream,(cbpValue >> 8) & 0x0FF);\n }\n else\n {\n\n             ps_dec->u2_cbp  = 0;\n         }\n     }\n }\n",
    "code_after_change": "void impeg2d_dec_p_mb_params(dec_state_t *ps_dec)\nWORD32  impeg2d_dec_p_mb_params(dec_state_t *ps_dec)\n {\n     stream_t *ps_stream = &ps_dec->s_bit_stream;\n     UWORD16 u2_mb_addr_incr;\n    UWORD16 u2_total_len;\n    UWORD16 u2_len;\n    UWORD16 u2_mb_type;\n    UWORD32 u4_next_word;\n const dec_mb_params_t *ps_dec_mb_params;\n if(impeg2d_bit_stream_nxt(ps_stream,1) == 1)\n {\n        impeg2d_bit_stream_flush(ps_stream,1);\n\n }\n else\n {\n        u2_mb_addr_incr = impeg2d_get_mb_addr_incr(ps_stream);\n if(0 == ps_dec->u2_first_mb)\n {\n /****************************************************************/\n /* If the 2nd member of a field picture pair is a P picture and */\n /* the first one was an I picture, there cannot be any skipped  */\n /* MBs in the second field picture                              */\n /****************************************************************/\n /*\n            if((dec->picture_structure != FRAME_PICTURE) &&\n                (dec->f->FieldFuncCall != 0) &&\n                (dec->las->u1_last_coded_vop_type == I))\n            {\n                core0_err_handler((void *)(VOLParams),\n                    ITTMPEG2_ERR_INVALID_MB_SKIP);\n            }\n            */\n /****************************************************************/\n /* In MPEG-2, the last MB of the row cannot be skipped and the  */\n /* MBAddrIncr cannot be such that it will take the current MB   */\n /* beyond the current row                                       */\n /* In MPEG-1, the slice could start and end anywhere and is not */\n /* restricted to a row like in MPEG-2. Hence this check should  */\n /* not be done for MPEG-1 streams.                              */\n /****************************************************************/\n if(ps_dec->u2_is_mpeg2 && ((ps_dec->u2_mb_x + u2_mb_addr_incr) > ps_dec->u2_num_horiz_mb) )\n {\n                u2_mb_addr_incr    = ps_dec->u2_num_horiz_mb - ps_dec->u2_mb_x;\n }\n\n            impeg2d_dec_skip_mbs(ps_dec, (UWORD16)(u2_mb_addr_incr - 1));\n }\n\n }\n    u4_next_word = (UWORD16)impeg2d_bit_stream_nxt(ps_stream,16);\n /*-----------------------------------------------------------------------*/\n /* MB type                                                               */\n /*-----------------------------------------------------------------------*/\n {\n        u2_mb_type   = ps_dec->pu2_mb_type[BITS((UWORD16)u4_next_word,15,10)];\n        u2_len      = BITS(u2_mb_type,15,8);\n        u2_total_len = u2_len;\n        u4_next_word = (UWORD16)LSW((UWORD16)u4_next_word << u2_len);\n }\n /*-----------------------------------------------------------------------*/\n /* motion type                                                           */\n /*-----------------------------------------------------------------------*/\n {\n if((u2_mb_type & MB_FORW_OR_BACK) &&  ps_dec->u2_read_motion_type)\n {\n            WORD32 i4_motion_type;\n            ps_dec->u2_motion_type = BITS((UWORD16)u4_next_word,15,14);\n            u2_total_len        += MB_MOTION_TYPE_LEN;\n            u4_next_word        = (UWORD16)LSW((UWORD16)u4_next_word << MB_MOTION_TYPE_LEN);\n            i4_motion_type     = ps_dec->u2_motion_type;\n\n if((i4_motion_type == 0) ||\n (i4_motion_type == 4) ||\n (i4_motion_type > 7))\n {\n                i4_motion_type = 1;\n }\n\n }\n }\n /*-----------------------------------------------------------------------*/\n /* dct type                                                              */\n /*-----------------------------------------------------------------------*/\n {\n if((u2_mb_type & MB_CODED) && ps_dec->u2_read_dct_type)\n {\n            ps_dec->u2_field_dct = BIT((UWORD16)u4_next_word,15);\n            u2_total_len += MB_DCT_TYPE_LEN;\n            u4_next_word = (UWORD16)LSW((UWORD16)u4_next_word << MB_DCT_TYPE_LEN);\n }\n }\n /*-----------------------------------------------------------------------*/\n /* Quant scale code                                                      */\n /*-----------------------------------------------------------------------*/\n if(u2_mb_type & MB_QUANT)\n {\n        UWORD16 u2_quant_scale_code;\n        u2_quant_scale_code = BITS((UWORD16)u4_next_word,15,11);\n\n        ps_dec->u1_quant_scale = (ps_dec->u2_q_scale_type) ?\n            gau1_impeg2_non_linear_quant_scale[u2_quant_scale_code] : (u2_quant_scale_code << 1);\n        u2_total_len += MB_QUANT_SCALE_CODE_LEN;\n }\n    impeg2d_bit_stream_flush(ps_stream,u2_total_len);\n /*-----------------------------------------------------------------------*/\n /* Set the function pointers                                             */\n /*-----------------------------------------------------------------------*/\n    ps_dec->u2_coded_mb    = (UWORD16)(u2_mb_type & MB_CODED);\n\n if(u2_mb_type & MB_FORW_OR_BACK)\n {\n\n        UWORD16 refPic      = !(u2_mb_type & MB_MV_FORW);\n        UWORD16 index       = (ps_dec->u2_motion_type);\n        ps_dec->u2_prev_intra_mb    = 0;\n\n         ps_dec->e_mb_pred         = (e_pred_direction_t)refPic;\n         ps_dec_mb_params = &ps_dec->ps_func_forw_or_back[index];\n         ps_dec->s_mb_type = ps_dec_mb_params->s_mb_type;\n        if(NULL == ps_dec_mb_params->pf_func_mb_params)\n            return -1;\n         ps_dec_mb_params->pf_func_mb_params(ps_dec);\n \n     }\n else if(u2_mb_type & MB_TYPE_INTRA)\n {\n        ps_dec->u2_prev_intra_mb    = 1;\n        impeg2d_dec_intra_mb(ps_dec);\n\n }\n else\n {\n        ps_dec->u2_prev_intra_mb    = 0;\n        ps_dec->e_mb_pred = FORW;\n        ps_dec->u2_motion_type = 0;\n        impeg2d_dec_0mv_coded_mb(ps_dec);\n }\n\n /*-----------------------------------------------------------------------*/\n /* decode cbp                                                            */\n /*-----------------------------------------------------------------------*/\n if((u2_mb_type & MB_TYPE_INTRA))\n {\n        ps_dec->u2_cbp  = 0x3f;\n        ps_dec->u2_prev_intra_mb    = 1;\n }\n else\n {\n        ps_dec->u2_prev_intra_mb  = 0;\n        ps_dec->u2_def_dc_pred[Y_LUMA] = 128 << ps_dec->u2_intra_dc_precision;\n        ps_dec->u2_def_dc_pred[U_CHROMA] = 128 << ps_dec->u2_intra_dc_precision;\n        ps_dec->u2_def_dc_pred[V_CHROMA] = 128 << ps_dec->u2_intra_dc_precision;\n if((ps_dec->u2_coded_mb))\n {\n            UWORD16 cbpValue;\n            cbpValue  = gau2_impeg2d_cbp_code[impeg2d_bit_stream_nxt(ps_stream,MB_CBP_LEN)];\n            ps_dec->u2_cbp  = cbpValue & 0xFF;\n            impeg2d_bit_stream_flush(ps_stream,(cbpValue >> 8) & 0x0FF);\n }\n else\n {\n\n             ps_dec->u2_cbp  = 0;\n         }\n     }\n    return 0;\n }\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 454,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-10066",
    "code_before_change": "static Image *ReadBMPImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  BMPInfo\n    bmp_info;\n\n  Image\n    *image;\n\n  IndexPacket\n    index;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset,\n    start_position;\n\n  MemoryInfo\n    *pixel_info;\n\n  register IndexPacket\n    *indexes;\n\n  register PixelPacket\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bit,\n    blue,\n    bytes_per_line,\n    green,\n    length,\n    red;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    magick[12],\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Determine if this a BMP file.\n  */\n  (void) ResetMagickMemory(&bmp_info,0,sizeof(bmp_info));\n  bmp_info.ba_offset=0;\n  start_position=0;\n  count=ReadBlob(image,2,magick);\n  do\n  {\n    LongPixelPacket\n      shift;\n\n    PixelPacket\n      quantum_bits;\n\n    size_t\n      profile_data,\n      profile_size;\n\n    /*\n      Verify BMP identifier.\n    */\n    if (bmp_info.ba_offset == 0)\n      start_position=TellBlob(image)-2;\n    bmp_info.ba_offset=0;\n    while (LocaleNCompare((char *) magick,\"BA\",2) == 0)\n    {\n      bmp_info.file_size=ReadBlobLSBLong(image);\n      bmp_info.ba_offset=ReadBlobLSBLong(image);\n      bmp_info.offset_bits=ReadBlobLSBLong(image);\n      count=ReadBlob(image,2,magick);\n      if (count != 2)\n        break;\n    }\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  Magick: %c%c\",\n        magick[0],magick[1]);\n    if ((count == 0) || ((LocaleNCompare((char *) magick,\"BM\",2) != 0) &&\n        (LocaleNCompare((char *) magick,\"CI\",2) != 0)))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    bmp_info.file_size=ReadBlobLSBLong(image);\n    (void) ReadBlobLSBLong(image);\n\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n         \"  File_size in header:  %u bytes\",bmp_info.file_size);\n\n    bmp_info.offset_bits=ReadBlobLSBLong(image);\n    bmp_info.size=ReadBlobLSBLong(image);\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  BMP size: %u\",\n        bmp_info.size);\n    if (bmp_info.size == 12)\n      {\n        /*\n          OS/2 BMP image file.\n        */\n        (void) CopyMagickString(image->magick,\"BMP2\",MaxTextExtent);\n        bmp_info.width=(ssize_t) ((short) ReadBlobLSBShort(image));\n        bmp_info.height=(ssize_t) ((short) ReadBlobLSBShort(image));\n        bmp_info.planes=ReadBlobLSBShort(image);\n        bmp_info.bits_per_pixel=ReadBlobLSBShort(image);\n        bmp_info.x_pixels=0;\n        bmp_info.y_pixels=0;\n        bmp_info.number_colors=0;\n        bmp_info.compression=BI_RGB;\n        bmp_info.image_size=0;\n        bmp_info.alpha_mask=0;\n        if (image->debug != MagickFalse)\n          {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Format: OS/2 Bitmap\");\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Geometry: %.20gx%.20g\",(double) bmp_info.width,(double)\n              bmp_info.height);\n          }\n      }\n    else\n      {\n        /*\n          Microsoft Windows BMP image file.\n        */\n        if (bmp_info.size < 40)\n          ThrowReaderException(CorruptImageError,\"NonOS2HeaderSizeError\");\n        bmp_info.width=(ssize_t) ((int) ReadBlobLSBLong(image));\n        bmp_info.height=(ssize_t) ((int) ReadBlobLSBLong(image));\n        bmp_info.planes=ReadBlobLSBShort(image);\n        bmp_info.bits_per_pixel=ReadBlobLSBShort(image);\n        bmp_info.compression=ReadBlobLSBLong(image);\n        bmp_info.image_size=ReadBlobLSBLong(image);\n        bmp_info.x_pixels=ReadBlobLSBLong(image);\n        bmp_info.y_pixels=ReadBlobLSBLong(image);\n        bmp_info.number_colors=ReadBlobLSBLong(image);\n        bmp_info.colors_important=ReadBlobLSBLong(image);\n        profile_data=0;\n        profile_size=0;\n        if (image->debug != MagickFalse)\n          {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Format: MS Windows bitmap\");\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Geometry: %.20gx%.20g\",(double) bmp_info.width,(double)\n              bmp_info.height);\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Bits per pixel: %.20g\",(double) bmp_info.bits_per_pixel);\n            switch ((int) bmp_info.compression)\n            {\n              case BI_RGB:\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Compression: BI_RGB\");\n                break;\n              }\n              case BI_RLE4:\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Compression: BI_RLE4\");\n                break;\n              }\n              case BI_RLE8:\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Compression: BI_RLE8\");\n                break;\n              }\n              case BI_BITFIELDS:\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Compression: BI_BITFIELDS\");\n                break;\n              }\n              case BI_PNG:\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Compression: BI_PNG\");\n                break;\n              }\n              case BI_JPEG:\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Compression: BI_JPEG\");\n                break;\n              }\n              default:\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Compression: UNKNOWN (%u)\",bmp_info.compression);\n              }\n            }\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Number of colors: %u\",bmp_info.number_colors);\n          }\n        bmp_info.red_mask=ReadBlobLSBLong(image);\n        bmp_info.green_mask=ReadBlobLSBLong(image);\n        bmp_info.blue_mask=ReadBlobLSBLong(image);\n        if (bmp_info.size > 40)\n          {\n\n            double\n              sum;\n\n            /*\n              Read color management information.\n            */\n            bmp_info.alpha_mask=ReadBlobLSBLong(image);\n            bmp_info.colorspace=(int) ReadBlobLSBLong(image);\n            /*\n              Decode 2^30 fixed point formatted CIE primaries.\n            */\n#           define BMP_DENOM ((double) 0x40000000)\n            bmp_info.red_primary.x=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n            bmp_info.red_primary.y=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n            bmp_info.red_primary.z=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n            bmp_info.green_primary.x=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n            bmp_info.green_primary.y=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n            bmp_info.green_primary.z=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n            bmp_info.blue_primary.x=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n            bmp_info.blue_primary.y=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n            bmp_info.blue_primary.z=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n\n            sum=bmp_info.red_primary.x+bmp_info.red_primary.y+\n              bmp_info.red_primary.z;\n            bmp_info.red_primary.x/=sum;\n            bmp_info.red_primary.y/=sum;\n            image->chromaticity.red_primary.x=bmp_info.red_primary.x;\n            image->chromaticity.red_primary.y=bmp_info.red_primary.y;\n\n            sum=bmp_info.green_primary.x+bmp_info.green_primary.y+\n              bmp_info.green_primary.z;\n            bmp_info.green_primary.x/=sum;\n            bmp_info.green_primary.y/=sum;\n            image->chromaticity.green_primary.x=bmp_info.green_primary.x;\n            image->chromaticity.green_primary.y=bmp_info.green_primary.y;\n\n            sum=bmp_info.blue_primary.x+bmp_info.blue_primary.y+\n              bmp_info.blue_primary.z;\n            bmp_info.blue_primary.x/=sum;\n            bmp_info.blue_primary.y/=sum;\n            image->chromaticity.blue_primary.x=bmp_info.blue_primary.x;\n            image->chromaticity.blue_primary.y=bmp_info.blue_primary.y;\n\n            /*\n              Decode 16^16 fixed point formatted gamma_scales.\n            */\n            bmp_info.gamma_scale.x=(double) ReadBlobLSBLong(image)/0x10000;\n            bmp_info.gamma_scale.y=(double) ReadBlobLSBLong(image)/0x10000;\n            bmp_info.gamma_scale.z=(double) ReadBlobLSBLong(image)/0x10000;\n            /*\n              Compute a single gamma from the BMP 3-channel gamma.\n            */\n            image->gamma=(bmp_info.gamma_scale.x+bmp_info.gamma_scale.y+\n              bmp_info.gamma_scale.z)/3.0;\n          }\n        else\n          (void) CopyMagickString(image->magick,\"BMP3\",MaxTextExtent);\n\n        if (bmp_info.size > 108)\n          {\n            size_t\n              intent;\n\n            /*\n              Read BMP Version 5 color management information.\n            */\n            intent=ReadBlobLSBLong(image);\n            switch ((int) intent)\n            {\n              case LCS_GM_BUSINESS:\n              {\n                image->rendering_intent=SaturationIntent;\n                break;\n              }\n              case LCS_GM_GRAPHICS:\n              {\n                image->rendering_intent=RelativeIntent;\n                break;\n              }\n              case LCS_GM_IMAGES:\n              {\n                image->rendering_intent=PerceptualIntent;\n                break;\n              }\n              case LCS_GM_ABS_COLORIMETRIC:\n              {\n                image->rendering_intent=AbsoluteIntent;\n                break;\n              }\n            }\n            profile_data=ReadBlobLSBLong(image);\n            profile_size=ReadBlobLSBLong(image);\n            (void) profile_data;\n            (void) profile_size;\n            (void) ReadBlobLSBLong(image);  /* Reserved byte */\n          }\n      }\n    if ((MagickSizeType) bmp_info.file_size > GetBlobSize(image))\n      (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,\n        \"LengthAndFilesizeDoNotMatch\",\"`%s'\",image->filename);\n    else\n      if ((MagickSizeType) bmp_info.file_size < GetBlobSize(image))\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          CorruptImageWarning,\"LengthAndFilesizeDoNotMatch\",\"`%s'\",\n          image->filename);\n    if (bmp_info.width <= 0)\n      ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\");\n    if (bmp_info.height == 0)\n      ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\");\n    if (bmp_info.planes != 1)\n      ThrowReaderException(CorruptImageError,\"StaticPlanesValueNotEqualToOne\");\n    if ((bmp_info.bits_per_pixel != 1) && (bmp_info.bits_per_pixel != 4) &&\n        (bmp_info.bits_per_pixel != 8) && (bmp_info.bits_per_pixel != 16) &&\n        (bmp_info.bits_per_pixel != 24) && (bmp_info.bits_per_pixel != 32))\n      ThrowReaderException(CorruptImageError,\"UnrecognizedBitsPerPixel\");\n    if (bmp_info.bits_per_pixel < 16 &&\n        bmp_info.number_colors > (1U << bmp_info.bits_per_pixel))\n      {\n        ThrowReaderException(CorruptImageError,\n            \"UnrecognizedNumberOfColors\");\n      }\n    if ((bmp_info.compression == 1) && (bmp_info.bits_per_pixel != 8))\n      ThrowReaderException(CorruptImageError,\"UnrecognizedBitsPerPixel\");\n    if ((bmp_info.compression == 2) && (bmp_info.bits_per_pixel != 4))\n      ThrowReaderException(CorruptImageError,\"UnrecognizedBitsPerPixel\");\n    if ((bmp_info.compression == 3) && (bmp_info.bits_per_pixel < 16))\n      ThrowReaderException(CorruptImageError,\"UnrecognizedBitsPerPixel\");\n    switch (bmp_info.compression)\n    {\n      case BI_RGB:\n      case BI_RLE8:\n      case BI_RLE4:\n      case BI_BITFIELDS:\n        break;\n      case BI_JPEG:\n        ThrowReaderException(CoderError,\"JPEGCompressNotSupported\");\n      case BI_PNG:\n        ThrowReaderException(CoderError,\"PNGCompressNotSupported\");\n      default:\n        ThrowReaderException(CorruptImageError,\"UnrecognizedImageCompression\");\n    }\n    image->columns=(size_t) MagickAbsoluteValue(bmp_info.width);\n    image->rows=(size_t) MagickAbsoluteValue(bmp_info.height);\n    image->depth=bmp_info.bits_per_pixel <= 8 ? bmp_info.bits_per_pixel : 8;\n    image->matte=((bmp_info.alpha_mask != 0) &&\n      (bmp_info.compression == BI_BITFIELDS)) || \n       (bmp_info.bits_per_pixel == 32) ? MagickTrue : MagickFalse;\n    if (bmp_info.bits_per_pixel < 16)\n      {\n        size_t\n          one;\n\n        image->storage_class=PseudoClass;\n        image->colors=bmp_info.number_colors;\n        one=1;\n        if (image->colors == 0)\n          image->colors=one << bmp_info.bits_per_pixel;\n      }\n    if (image->storage_class == PseudoClass)\n      {\n        unsigned char\n          *bmp_colormap;\n\n        size_t\n          packet_size;\n\n        /*\n          Read BMP raster colormap.\n        */\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Reading colormap of %.20g colors\",(double) image->colors);\n        if (AcquireImageColormap(image,image->colors) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        bmp_colormap=(unsigned char *) AcquireQuantumMemory((size_t)\n          image->colors,4*sizeof(*bmp_colormap));\n        if (bmp_colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        if ((bmp_info.size == 12) || (bmp_info.size == 64))\n          packet_size=3;\n        else\n          packet_size=4;\n        offset=SeekBlob(image,start_position+14+bmp_info.size,SEEK_SET);\n        if (offset < 0)\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        count=ReadBlob(image,packet_size*image->colors,bmp_colormap);\n        if (count != (ssize_t) (packet_size*image->colors))\n          ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n        p=bmp_colormap;\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          image->colormap[i].blue=ScaleCharToQuantum(*p++);\n          image->colormap[i].green=ScaleCharToQuantum(*p++);\n          image->colormap[i].red=ScaleCharToQuantum(*p++);\n          if (packet_size == 4)\n            p++;\n        }\n        bmp_colormap=(unsigned char *) RelinquishMagickMemory(bmp_colormap);\n      }\n    image->x_resolution=(double) bmp_info.x_pixels/100.0;\n    image->y_resolution=(double) bmp_info.y_pixels/100.0;\n    image->units=PixelsPerCentimeterResolution;\n     if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n       if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n         break;\n     /*\n       Read image data.\n     */\n    offset=SeekBlob(image,start_position+bmp_info.offset_bits,SEEK_SET);\n    if (offset < 0)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if (bmp_info.compression == BI_RLE4)\n      bmp_info.bits_per_pixel<<=1;\n    bytes_per_line=4*((image->columns*bmp_info.bits_per_pixel+31)/32);\n    length=(size_t) bytes_per_line*image->rows;\n    pixel_info=AcquireVirtualMemory((size_t) image->rows,\n      MagickMax(bytes_per_line,image->columns+256UL)*sizeof(*pixels));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    if ((bmp_info.compression == BI_RGB) ||\n        (bmp_info.compression == BI_BITFIELDS))\n      {\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Reading pixels (%.20g bytes)\",(double) length);\n        count=ReadBlob(image,length,pixels);\n        if (count != (ssize_t) length)\n          {\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            ThrowReaderException(CorruptImageError,\n              \"InsufficientImageDataInFile\");\n          }\n      }\n    else\n      {\n        /*\n          Convert run-length encoded raster pixels.\n        */\n        status=DecodeImage(image,bmp_info.compression,pixels);\n        if (status == MagickFalse)\n          {\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            ThrowReaderException(CorruptImageError,\n              \"UnableToRunlengthDecodeImage\");\n          }\n      }\n    /*\n      Convert BMP raster image to pixel packets.\n    */\n    if (bmp_info.compression == BI_RGB)\n      {\n        bmp_info.alpha_mask=image->matte != MagickFalse ? 0xff000000U : 0U;\n        bmp_info.red_mask=0x00ff0000U;\n        bmp_info.green_mask=0x0000ff00U;\n        bmp_info.blue_mask=0x000000ffU;\n        if (bmp_info.bits_per_pixel == 16)\n          {\n            /*\n              RGB555.\n            */\n            bmp_info.red_mask=0x00007c00U;\n            bmp_info.green_mask=0x000003e0U;\n            bmp_info.blue_mask=0x0000001fU;\n          }\n      }\n    if ((bmp_info.bits_per_pixel == 16) || (bmp_info.bits_per_pixel == 32))\n      {\n        register size_t\n          sample;\n\n        /*\n          Get shift and quantum bits info from bitfield masks.\n        */\n        (void) ResetMagickMemory(&shift,0,sizeof(shift));\n        (void) ResetMagickMemory(&quantum_bits,0,sizeof(quantum_bits));\n        if (bmp_info.red_mask != 0)\n          while (((bmp_info.red_mask << shift.red) & 0x80000000UL) == 0)\n            shift.red++;\n        if (bmp_info.green_mask != 0)\n          while (((bmp_info.green_mask << shift.green) & 0x80000000UL) == 0)\n            shift.green++;\n        if (bmp_info.blue_mask != 0)\n          while (((bmp_info.blue_mask << shift.blue) & 0x80000000UL) == 0)\n            shift.blue++;\n        if (bmp_info.alpha_mask != 0)\n          while (((bmp_info.alpha_mask << shift.opacity) & 0x80000000UL) == 0)\n            shift.opacity++;\n        sample=shift.red;\n        while (((bmp_info.red_mask << sample) & 0x80000000UL) != 0)\n          sample++;\n        quantum_bits.red=ClampToQuantum((MagickRealType) sample-shift.red);\n        sample=shift.green;\n        while (((bmp_info.green_mask << sample) & 0x80000000UL) != 0)\n          sample++;\n        quantum_bits.green=ClampToQuantum((MagickRealType) sample-shift.green);\n        sample=shift.blue;\n        while (((bmp_info.blue_mask << sample) & 0x80000000UL) != 0)\n          sample++;\n        quantum_bits.blue=ClampToQuantum((MagickRealType) sample-shift.blue);\n        sample=shift.opacity;\n        while (((bmp_info.alpha_mask << sample) & 0x80000000UL) != 0)\n          sample++;\n        quantum_bits.opacity=ClampToQuantum((MagickRealType) sample-\n          shift.opacity);\n      }\n    switch (bmp_info.bits_per_pixel)\n    {\n      case 1:\n      {\n        /*\n          Convert bitmap scanline.\n        */\n        for (y=(ssize_t) image->rows-1; y >= 0; y--)\n        {\n          p=pixels+(image->rows-y-1)*bytes_per_line;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          indexes=GetAuthenticIndexQueue(image);\n          for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n          {\n            for (bit=0; bit < 8; bit++)\n            {\n              index=(IndexPacket) (((*p) & (0x80 >> bit)) != 0 ? 0x01 : 0x00);\n              SetPixelIndex(indexes+x+bit,index);\n              q++;\n            }\n            p++;\n          }\n          if ((image->columns % 8) != 0)\n            {\n              for (bit=0; bit < (image->columns % 8); bit++)\n              {\n                index=(IndexPacket) (((*p) & (0x80 >> bit)) != 0 ? 0x01 : 0x00);\n                SetPixelIndex(indexes+x+bit,index);\n              }\n              p++;\n            }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                (image->rows-y),image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        (void) SyncImage(image);\n        break;\n      }\n      case 4:\n      {\n        /*\n          Convert PseudoColor scanline.\n        */\n        for (y=(ssize_t) image->rows-1; y >= 0; y--)\n        {\n          p=pixels+(image->rows-y-1)*bytes_per_line;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          indexes=GetAuthenticIndexQueue(image);\n          for (x=0; x < ((ssize_t) image->columns-1); x+=2)\n          {\n            index=ConstrainColormapIndex(image,(*p >> 4) & 0x0f);\n            SetPixelIndex(indexes+x,index);\n            index=ConstrainColormapIndex(image,*p & 0x0f);\n            SetPixelIndex(indexes+x+1,index);\n            p++;\n          }\n          if ((image->columns % 2) != 0)\n            {\n              index=ConstrainColormapIndex(image,(*p >> 4) & 0xf);\n              SetPixelIndex(indexes+x,index);\n              p++;\n            }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                (image->rows-y),image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        (void) SyncImage(image);\n        break;\n      }\n      case 8:\n      {\n        /*\n          Convert PseudoColor scanline.\n        */\n        if ((bmp_info.compression == BI_RLE8) ||\n            (bmp_info.compression == BI_RLE4))\n          bytes_per_line=image->columns;\n        for (y=(ssize_t) image->rows-1; y >= 0; y--)\n        {\n          p=pixels+(image->rows-y-1)*bytes_per_line;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          indexes=GetAuthenticIndexQueue(image);\n          for (x=(ssize_t) image->columns; x != 0; --x)\n          {\n            index=ConstrainColormapIndex(image,*p);\n            SetPixelIndex(indexes,index);\n            indexes++;\n            p++;\n            q++;\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          offset=(MagickOffsetType) (image->rows-y-1);\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                (image->rows-y),image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        (void) SyncImage(image);\n        break;\n      }\n      case 16:\n      {\n        size_t\n          alpha,\n          pixel;\n\n        /*\n          Convert bitfield encoded 16-bit PseudoColor scanline.\n        */\n        if (bmp_info.compression != BI_RGB &&\n            bmp_info.compression != BI_BITFIELDS)\n          {\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            ThrowReaderException(CorruptImageError,\n              \"UnrecognizedImageCompression\");\n          }\n        bytes_per_line=2*(image->columns+image->columns % 2);\n        image->storage_class=DirectClass;\n        for (y=(ssize_t) image->rows-1; y >= 0; y--)\n        {\n          p=pixels+(image->rows-y-1)*bytes_per_line;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            pixel=(size_t) (*p++);\n            pixel|=(*p++) << 8;\n            red=((pixel & bmp_info.red_mask) << shift.red) >> 16;\n            if (quantum_bits.red == 5)\n              red|=((red & 0xe000) >> 5);\n            if (quantum_bits.red <= 8)\n              red|=((red & 0xff00) >> 8);\n            green=((pixel & bmp_info.green_mask) << shift.green) >> 16;\n            if (quantum_bits.green == 5)\n              green|=((green & 0xe000) >> 5);\n            if (quantum_bits.green == 6)\n              green|=((green & 0xc000) >> 6);\n            if (quantum_bits.green <= 8)\n              green|=((green & 0xff00) >> 8);\n            blue=((pixel & bmp_info.blue_mask) << shift.blue) >> 16;\n            if (quantum_bits.blue == 5)\n              blue|=((blue & 0xe000) >> 5);\n            if (quantum_bits.blue <= 8)\n              blue|=((blue & 0xff00) >> 8);\n            alpha=((pixel & bmp_info.alpha_mask) << shift.opacity) >> 16;\n            if (quantum_bits.opacity <= 8)\n              alpha|=((alpha & 0xff00) >> 8);\n            SetPixelRed(q,ScaleShortToQuantum((unsigned short) red));\n            SetPixelGreen(q,ScaleShortToQuantum((unsigned short) green));\n            SetPixelBlue(q,ScaleShortToQuantum((unsigned short) blue));\n            SetPixelOpacity(q,OpaqueOpacity);\n            if (image->matte != MagickFalse)\n              SetPixelAlpha(q,ScaleShortToQuantum((unsigned short) alpha));\n            q++;\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          offset=(MagickOffsetType) (image->rows-y-1);\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                (image->rows-y),image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case 24:\n      {\n        /*\n          Convert DirectColor scanline.\n        */\n        bytes_per_line=4*((image->columns*24+31)/32);\n        for (y=(ssize_t) image->rows-1; y >= 0; y--)\n        {\n          p=pixels+(image->rows-y-1)*bytes_per_line;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelBlue(q,ScaleCharToQuantum(*p++));\n            SetPixelGreen(q,ScaleCharToQuantum(*p++));\n            SetPixelRed(q,ScaleCharToQuantum(*p++));\n            SetPixelOpacity(q,OpaqueOpacity);\n            q++;\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          offset=(MagickOffsetType) (image->rows-y-1);\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                (image->rows-y),image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case 32:\n      {\n        /*\n          Convert bitfield encoded DirectColor scanline.\n        */\n        if ((bmp_info.compression != BI_RGB) &&\n            (bmp_info.compression != BI_BITFIELDS))\n          {\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            ThrowReaderException(CorruptImageError,\n              \"UnrecognizedImageCompression\");\n          }\n        bytes_per_line=4*(image->columns);\n        for (y=(ssize_t) image->rows-1; y >= 0; y--)\n        {\n          size_t\n            alpha,\n            pixel;\n\n          p=pixels+(image->rows-y-1)*bytes_per_line;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            pixel=(size_t) (*p++);\n            pixel|=((size_t) *p++ << 8);\n            pixel|=((size_t) *p++ << 16);\n            pixel|=((size_t) *p++ << 24);\n            red=((pixel & bmp_info.red_mask) << shift.red) >> 16;\n            if (quantum_bits.red == 8)\n              red|=(red >> 8);\n            green=((pixel & bmp_info.green_mask) << shift.green) >> 16;\n            if (quantum_bits.green == 8)\n              green|=(green >> 8);\n            blue=((pixel & bmp_info.blue_mask) << shift.blue) >> 16;\n            if (quantum_bits.blue == 8)\n              blue|=(blue >> 8);\n            alpha=((pixel & bmp_info.alpha_mask) << shift.opacity) >> 16;\n            if (quantum_bits.opacity == 8)\n              alpha|=(alpha >> 8);\n            SetPixelRed(q,ScaleShortToQuantum((unsigned short) red));\n            SetPixelGreen(q,ScaleShortToQuantum((unsigned short) green));\n            SetPixelBlue(q,ScaleShortToQuantum((unsigned short) blue));\n            SetPixelAlpha(q,OpaqueOpacity);\n            if (image->matte != MagickFalse)\n              SetPixelAlpha(q,ScaleShortToQuantum((unsigned short) alpha));\n            q++;\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          offset=(MagickOffsetType) (image->rows-y-1);\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                (image->rows-y),image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      default:\n      {\n        pixel_info=RelinquishVirtualMemory(pixel_info);\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n    }\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    if (bmp_info.height < 0)\n      {\n        Image\n          *flipped_image;\n\n        /*\n          Correct image orientation.\n        */\n        flipped_image=FlipImage(image,exception);\n        if (flipped_image != (Image *) NULL)\n          {\n            DuplicateBlob(flipped_image,image);\n            image=DestroyImage(image);\n            image=flipped_image;\n          }\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    *magick='\\0';\n    if (bmp_info.ba_offset != 0)\n      {\n        offset=SeekBlob(image,(MagickOffsetType) bmp_info.ba_offset,SEEK_SET);\n        if (offset < 0)\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n    count=ReadBlob(image,2,magick);\n    if ((count == 2) && (IsBMP(magick,2) != MagickFalse))\n      {\n        /*\n          Acquire next image structure.\n        */\n        AcquireNextImage(image_info,image);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (IsBMP(magick,2) != MagickFalse);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n",
    "code_after_change": "static Image *ReadBMPImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  BMPInfo\n    bmp_info;\n\n  Image\n    *image;\n\n  IndexPacket\n    index;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset,\n    start_position;\n\n  MemoryInfo\n    *pixel_info;\n\n  register IndexPacket\n    *indexes;\n\n  register PixelPacket\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bit,\n    blue,\n    bytes_per_line,\n    green,\n    length,\n    red;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    magick[12],\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Determine if this a BMP file.\n  */\n  (void) ResetMagickMemory(&bmp_info,0,sizeof(bmp_info));\n  bmp_info.ba_offset=0;\n  start_position=0;\n  count=ReadBlob(image,2,magick);\n  do\n  {\n    LongPixelPacket\n      shift;\n\n    PixelPacket\n      quantum_bits;\n\n    size_t\n      profile_data,\n      profile_size;\n\n    /*\n      Verify BMP identifier.\n    */\n    if (bmp_info.ba_offset == 0)\n      start_position=TellBlob(image)-2;\n    bmp_info.ba_offset=0;\n    while (LocaleNCompare((char *) magick,\"BA\",2) == 0)\n    {\n      bmp_info.file_size=ReadBlobLSBLong(image);\n      bmp_info.ba_offset=ReadBlobLSBLong(image);\n      bmp_info.offset_bits=ReadBlobLSBLong(image);\n      count=ReadBlob(image,2,magick);\n      if (count != 2)\n        break;\n    }\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  Magick: %c%c\",\n        magick[0],magick[1]);\n    if ((count == 0) || ((LocaleNCompare((char *) magick,\"BM\",2) != 0) &&\n        (LocaleNCompare((char *) magick,\"CI\",2) != 0)))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    bmp_info.file_size=ReadBlobLSBLong(image);\n    (void) ReadBlobLSBLong(image);\n\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n         \"  File_size in header:  %u bytes\",bmp_info.file_size);\n\n    bmp_info.offset_bits=ReadBlobLSBLong(image);\n    bmp_info.size=ReadBlobLSBLong(image);\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  BMP size: %u\",\n        bmp_info.size);\n    if (bmp_info.size == 12)\n      {\n        /*\n          OS/2 BMP image file.\n        */\n        (void) CopyMagickString(image->magick,\"BMP2\",MaxTextExtent);\n        bmp_info.width=(ssize_t) ((short) ReadBlobLSBShort(image));\n        bmp_info.height=(ssize_t) ((short) ReadBlobLSBShort(image));\n        bmp_info.planes=ReadBlobLSBShort(image);\n        bmp_info.bits_per_pixel=ReadBlobLSBShort(image);\n        bmp_info.x_pixels=0;\n        bmp_info.y_pixels=0;\n        bmp_info.number_colors=0;\n        bmp_info.compression=BI_RGB;\n        bmp_info.image_size=0;\n        bmp_info.alpha_mask=0;\n        if (image->debug != MagickFalse)\n          {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Format: OS/2 Bitmap\");\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Geometry: %.20gx%.20g\",(double) bmp_info.width,(double)\n              bmp_info.height);\n          }\n      }\n    else\n      {\n        /*\n          Microsoft Windows BMP image file.\n        */\n        if (bmp_info.size < 40)\n          ThrowReaderException(CorruptImageError,\"NonOS2HeaderSizeError\");\n        bmp_info.width=(ssize_t) ((int) ReadBlobLSBLong(image));\n        bmp_info.height=(ssize_t) ((int) ReadBlobLSBLong(image));\n        bmp_info.planes=ReadBlobLSBShort(image);\n        bmp_info.bits_per_pixel=ReadBlobLSBShort(image);\n        bmp_info.compression=ReadBlobLSBLong(image);\n        bmp_info.image_size=ReadBlobLSBLong(image);\n        bmp_info.x_pixels=ReadBlobLSBLong(image);\n        bmp_info.y_pixels=ReadBlobLSBLong(image);\n        bmp_info.number_colors=ReadBlobLSBLong(image);\n        bmp_info.colors_important=ReadBlobLSBLong(image);\n        profile_data=0;\n        profile_size=0;\n        if (image->debug != MagickFalse)\n          {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Format: MS Windows bitmap\");\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Geometry: %.20gx%.20g\",(double) bmp_info.width,(double)\n              bmp_info.height);\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Bits per pixel: %.20g\",(double) bmp_info.bits_per_pixel);\n            switch ((int) bmp_info.compression)\n            {\n              case BI_RGB:\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Compression: BI_RGB\");\n                break;\n              }\n              case BI_RLE4:\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Compression: BI_RLE4\");\n                break;\n              }\n              case BI_RLE8:\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Compression: BI_RLE8\");\n                break;\n              }\n              case BI_BITFIELDS:\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Compression: BI_BITFIELDS\");\n                break;\n              }\n              case BI_PNG:\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Compression: BI_PNG\");\n                break;\n              }\n              case BI_JPEG:\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Compression: BI_JPEG\");\n                break;\n              }\n              default:\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Compression: UNKNOWN (%u)\",bmp_info.compression);\n              }\n            }\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Number of colors: %u\",bmp_info.number_colors);\n          }\n        bmp_info.red_mask=ReadBlobLSBLong(image);\n        bmp_info.green_mask=ReadBlobLSBLong(image);\n        bmp_info.blue_mask=ReadBlobLSBLong(image);\n        if (bmp_info.size > 40)\n          {\n\n            double\n              sum;\n\n            /*\n              Read color management information.\n            */\n            bmp_info.alpha_mask=ReadBlobLSBLong(image);\n            bmp_info.colorspace=(int) ReadBlobLSBLong(image);\n            /*\n              Decode 2^30 fixed point formatted CIE primaries.\n            */\n#           define BMP_DENOM ((double) 0x40000000)\n            bmp_info.red_primary.x=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n            bmp_info.red_primary.y=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n            bmp_info.red_primary.z=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n            bmp_info.green_primary.x=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n            bmp_info.green_primary.y=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n            bmp_info.green_primary.z=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n            bmp_info.blue_primary.x=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n            bmp_info.blue_primary.y=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n            bmp_info.blue_primary.z=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n\n            sum=bmp_info.red_primary.x+bmp_info.red_primary.y+\n              bmp_info.red_primary.z;\n            bmp_info.red_primary.x/=sum;\n            bmp_info.red_primary.y/=sum;\n            image->chromaticity.red_primary.x=bmp_info.red_primary.x;\n            image->chromaticity.red_primary.y=bmp_info.red_primary.y;\n\n            sum=bmp_info.green_primary.x+bmp_info.green_primary.y+\n              bmp_info.green_primary.z;\n            bmp_info.green_primary.x/=sum;\n            bmp_info.green_primary.y/=sum;\n            image->chromaticity.green_primary.x=bmp_info.green_primary.x;\n            image->chromaticity.green_primary.y=bmp_info.green_primary.y;\n\n            sum=bmp_info.blue_primary.x+bmp_info.blue_primary.y+\n              bmp_info.blue_primary.z;\n            bmp_info.blue_primary.x/=sum;\n            bmp_info.blue_primary.y/=sum;\n            image->chromaticity.blue_primary.x=bmp_info.blue_primary.x;\n            image->chromaticity.blue_primary.y=bmp_info.blue_primary.y;\n\n            /*\n              Decode 16^16 fixed point formatted gamma_scales.\n            */\n            bmp_info.gamma_scale.x=(double) ReadBlobLSBLong(image)/0x10000;\n            bmp_info.gamma_scale.y=(double) ReadBlobLSBLong(image)/0x10000;\n            bmp_info.gamma_scale.z=(double) ReadBlobLSBLong(image)/0x10000;\n            /*\n              Compute a single gamma from the BMP 3-channel gamma.\n            */\n            image->gamma=(bmp_info.gamma_scale.x+bmp_info.gamma_scale.y+\n              bmp_info.gamma_scale.z)/3.0;\n          }\n        else\n          (void) CopyMagickString(image->magick,\"BMP3\",MaxTextExtent);\n\n        if (bmp_info.size > 108)\n          {\n            size_t\n              intent;\n\n            /*\n              Read BMP Version 5 color management information.\n            */\n            intent=ReadBlobLSBLong(image);\n            switch ((int) intent)\n            {\n              case LCS_GM_BUSINESS:\n              {\n                image->rendering_intent=SaturationIntent;\n                break;\n              }\n              case LCS_GM_GRAPHICS:\n              {\n                image->rendering_intent=RelativeIntent;\n                break;\n              }\n              case LCS_GM_IMAGES:\n              {\n                image->rendering_intent=PerceptualIntent;\n                break;\n              }\n              case LCS_GM_ABS_COLORIMETRIC:\n              {\n                image->rendering_intent=AbsoluteIntent;\n                break;\n              }\n            }\n            profile_data=ReadBlobLSBLong(image);\n            profile_size=ReadBlobLSBLong(image);\n            (void) profile_data;\n            (void) profile_size;\n            (void) ReadBlobLSBLong(image);  /* Reserved byte */\n          }\n      }\n    if ((MagickSizeType) bmp_info.file_size > GetBlobSize(image))\n      (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,\n        \"LengthAndFilesizeDoNotMatch\",\"`%s'\",image->filename);\n    else\n      if ((MagickSizeType) bmp_info.file_size < GetBlobSize(image))\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          CorruptImageWarning,\"LengthAndFilesizeDoNotMatch\",\"`%s'\",\n          image->filename);\n    if (bmp_info.width <= 0)\n      ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\");\n    if (bmp_info.height == 0)\n      ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\");\n    if (bmp_info.planes != 1)\n      ThrowReaderException(CorruptImageError,\"StaticPlanesValueNotEqualToOne\");\n    if ((bmp_info.bits_per_pixel != 1) && (bmp_info.bits_per_pixel != 4) &&\n        (bmp_info.bits_per_pixel != 8) && (bmp_info.bits_per_pixel != 16) &&\n        (bmp_info.bits_per_pixel != 24) && (bmp_info.bits_per_pixel != 32))\n      ThrowReaderException(CorruptImageError,\"UnrecognizedBitsPerPixel\");\n    if (bmp_info.bits_per_pixel < 16 &&\n        bmp_info.number_colors > (1U << bmp_info.bits_per_pixel))\n      {\n        ThrowReaderException(CorruptImageError,\n            \"UnrecognizedNumberOfColors\");\n      }\n    if ((bmp_info.compression == 1) && (bmp_info.bits_per_pixel != 8))\n      ThrowReaderException(CorruptImageError,\"UnrecognizedBitsPerPixel\");\n    if ((bmp_info.compression == 2) && (bmp_info.bits_per_pixel != 4))\n      ThrowReaderException(CorruptImageError,\"UnrecognizedBitsPerPixel\");\n    if ((bmp_info.compression == 3) && (bmp_info.bits_per_pixel < 16))\n      ThrowReaderException(CorruptImageError,\"UnrecognizedBitsPerPixel\");\n    switch (bmp_info.compression)\n    {\n      case BI_RGB:\n      case BI_RLE8:\n      case BI_RLE4:\n      case BI_BITFIELDS:\n        break;\n      case BI_JPEG:\n        ThrowReaderException(CoderError,\"JPEGCompressNotSupported\");\n      case BI_PNG:\n        ThrowReaderException(CoderError,\"PNGCompressNotSupported\");\n      default:\n        ThrowReaderException(CorruptImageError,\"UnrecognizedImageCompression\");\n    }\n    image->columns=(size_t) MagickAbsoluteValue(bmp_info.width);\n    image->rows=(size_t) MagickAbsoluteValue(bmp_info.height);\n    image->depth=bmp_info.bits_per_pixel <= 8 ? bmp_info.bits_per_pixel : 8;\n    image->matte=((bmp_info.alpha_mask != 0) &&\n      (bmp_info.compression == BI_BITFIELDS)) || \n       (bmp_info.bits_per_pixel == 32) ? MagickTrue : MagickFalse;\n    if (bmp_info.bits_per_pixel < 16)\n      {\n        size_t\n          one;\n\n        image->storage_class=PseudoClass;\n        image->colors=bmp_info.number_colors;\n        one=1;\n        if (image->colors == 0)\n          image->colors=one << bmp_info.bits_per_pixel;\n      }\n    if (image->storage_class == PseudoClass)\n      {\n        unsigned char\n          *bmp_colormap;\n\n        size_t\n          packet_size;\n\n        /*\n          Read BMP raster colormap.\n        */\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Reading colormap of %.20g colors\",(double) image->colors);\n        if (AcquireImageColormap(image,image->colors) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        bmp_colormap=(unsigned char *) AcquireQuantumMemory((size_t)\n          image->colors,4*sizeof(*bmp_colormap));\n        if (bmp_colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        if ((bmp_info.size == 12) || (bmp_info.size == 64))\n          packet_size=3;\n        else\n          packet_size=4;\n        offset=SeekBlob(image,start_position+14+bmp_info.size,SEEK_SET);\n        if (offset < 0)\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        count=ReadBlob(image,packet_size*image->colors,bmp_colormap);\n        if (count != (ssize_t) (packet_size*image->colors))\n          ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n        p=bmp_colormap;\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          image->colormap[i].blue=ScaleCharToQuantum(*p++);\n          image->colormap[i].green=ScaleCharToQuantum(*p++);\n          image->colormap[i].red=ScaleCharToQuantum(*p++);\n          if (packet_size == 4)\n            p++;\n        }\n        bmp_colormap=(unsigned char *) RelinquishMagickMemory(bmp_colormap);\n      }\n    image->x_resolution=(double) bmp_info.x_pixels/100.0;\n    image->y_resolution=(double) bmp_info.y_pixels/100.0;\n    image->units=PixelsPerCentimeterResolution;\n     if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n       if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n         break;\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n     /*\n       Read image data.\n     */\n    offset=SeekBlob(image,start_position+bmp_info.offset_bits,SEEK_SET);\n    if (offset < 0)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if (bmp_info.compression == BI_RLE4)\n      bmp_info.bits_per_pixel<<=1;\n    bytes_per_line=4*((image->columns*bmp_info.bits_per_pixel+31)/32);\n    length=(size_t) bytes_per_line*image->rows;\n    pixel_info=AcquireVirtualMemory((size_t) image->rows,\n      MagickMax(bytes_per_line,image->columns+256UL)*sizeof(*pixels));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    if ((bmp_info.compression == BI_RGB) ||\n        (bmp_info.compression == BI_BITFIELDS))\n      {\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Reading pixels (%.20g bytes)\",(double) length);\n        count=ReadBlob(image,length,pixels);\n        if (count != (ssize_t) length)\n          {\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            ThrowReaderException(CorruptImageError,\n              \"InsufficientImageDataInFile\");\n          }\n      }\n    else\n      {\n        /*\n          Convert run-length encoded raster pixels.\n        */\n        status=DecodeImage(image,bmp_info.compression,pixels);\n        if (status == MagickFalse)\n          {\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            ThrowReaderException(CorruptImageError,\n              \"UnableToRunlengthDecodeImage\");\n          }\n      }\n    /*\n      Convert BMP raster image to pixel packets.\n    */\n    if (bmp_info.compression == BI_RGB)\n      {\n        bmp_info.alpha_mask=image->matte != MagickFalse ? 0xff000000U : 0U;\n        bmp_info.red_mask=0x00ff0000U;\n        bmp_info.green_mask=0x0000ff00U;\n        bmp_info.blue_mask=0x000000ffU;\n        if (bmp_info.bits_per_pixel == 16)\n          {\n            /*\n              RGB555.\n            */\n            bmp_info.red_mask=0x00007c00U;\n            bmp_info.green_mask=0x000003e0U;\n            bmp_info.blue_mask=0x0000001fU;\n          }\n      }\n    if ((bmp_info.bits_per_pixel == 16) || (bmp_info.bits_per_pixel == 32))\n      {\n        register size_t\n          sample;\n\n        /*\n          Get shift and quantum bits info from bitfield masks.\n        */\n        (void) ResetMagickMemory(&shift,0,sizeof(shift));\n        (void) ResetMagickMemory(&quantum_bits,0,sizeof(quantum_bits));\n        if (bmp_info.red_mask != 0)\n          while (((bmp_info.red_mask << shift.red) & 0x80000000UL) == 0)\n            shift.red++;\n        if (bmp_info.green_mask != 0)\n          while (((bmp_info.green_mask << shift.green) & 0x80000000UL) == 0)\n            shift.green++;\n        if (bmp_info.blue_mask != 0)\n          while (((bmp_info.blue_mask << shift.blue) & 0x80000000UL) == 0)\n            shift.blue++;\n        if (bmp_info.alpha_mask != 0)\n          while (((bmp_info.alpha_mask << shift.opacity) & 0x80000000UL) == 0)\n            shift.opacity++;\n        sample=shift.red;\n        while (((bmp_info.red_mask << sample) & 0x80000000UL) != 0)\n          sample++;\n        quantum_bits.red=ClampToQuantum((MagickRealType) sample-shift.red);\n        sample=shift.green;\n        while (((bmp_info.green_mask << sample) & 0x80000000UL) != 0)\n          sample++;\n        quantum_bits.green=ClampToQuantum((MagickRealType) sample-shift.green);\n        sample=shift.blue;\n        while (((bmp_info.blue_mask << sample) & 0x80000000UL) != 0)\n          sample++;\n        quantum_bits.blue=ClampToQuantum((MagickRealType) sample-shift.blue);\n        sample=shift.opacity;\n        while (((bmp_info.alpha_mask << sample) & 0x80000000UL) != 0)\n          sample++;\n        quantum_bits.opacity=ClampToQuantum((MagickRealType) sample-\n          shift.opacity);\n      }\n    switch (bmp_info.bits_per_pixel)\n    {\n      case 1:\n      {\n        /*\n          Convert bitmap scanline.\n        */\n        for (y=(ssize_t) image->rows-1; y >= 0; y--)\n        {\n          p=pixels+(image->rows-y-1)*bytes_per_line;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          indexes=GetAuthenticIndexQueue(image);\n          for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n          {\n            for (bit=0; bit < 8; bit++)\n            {\n              index=(IndexPacket) (((*p) & (0x80 >> bit)) != 0 ? 0x01 : 0x00);\n              SetPixelIndex(indexes+x+bit,index);\n              q++;\n            }\n            p++;\n          }\n          if ((image->columns % 8) != 0)\n            {\n              for (bit=0; bit < (image->columns % 8); bit++)\n              {\n                index=(IndexPacket) (((*p) & (0x80 >> bit)) != 0 ? 0x01 : 0x00);\n                SetPixelIndex(indexes+x+bit,index);\n              }\n              p++;\n            }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                (image->rows-y),image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        (void) SyncImage(image);\n        break;\n      }\n      case 4:\n      {\n        /*\n          Convert PseudoColor scanline.\n        */\n        for (y=(ssize_t) image->rows-1; y >= 0; y--)\n        {\n          p=pixels+(image->rows-y-1)*bytes_per_line;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          indexes=GetAuthenticIndexQueue(image);\n          for (x=0; x < ((ssize_t) image->columns-1); x+=2)\n          {\n            index=ConstrainColormapIndex(image,(*p >> 4) & 0x0f);\n            SetPixelIndex(indexes+x,index);\n            index=ConstrainColormapIndex(image,*p & 0x0f);\n            SetPixelIndex(indexes+x+1,index);\n            p++;\n          }\n          if ((image->columns % 2) != 0)\n            {\n              index=ConstrainColormapIndex(image,(*p >> 4) & 0xf);\n              SetPixelIndex(indexes+x,index);\n              p++;\n            }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                (image->rows-y),image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        (void) SyncImage(image);\n        break;\n      }\n      case 8:\n      {\n        /*\n          Convert PseudoColor scanline.\n        */\n        if ((bmp_info.compression == BI_RLE8) ||\n            (bmp_info.compression == BI_RLE4))\n          bytes_per_line=image->columns;\n        for (y=(ssize_t) image->rows-1; y >= 0; y--)\n        {\n          p=pixels+(image->rows-y-1)*bytes_per_line;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          indexes=GetAuthenticIndexQueue(image);\n          for (x=(ssize_t) image->columns; x != 0; --x)\n          {\n            index=ConstrainColormapIndex(image,*p);\n            SetPixelIndex(indexes,index);\n            indexes++;\n            p++;\n            q++;\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          offset=(MagickOffsetType) (image->rows-y-1);\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                (image->rows-y),image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        (void) SyncImage(image);\n        break;\n      }\n      case 16:\n      {\n        size_t\n          alpha,\n          pixel;\n\n        /*\n          Convert bitfield encoded 16-bit PseudoColor scanline.\n        */\n        if (bmp_info.compression != BI_RGB &&\n            bmp_info.compression != BI_BITFIELDS)\n          {\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            ThrowReaderException(CorruptImageError,\n              \"UnrecognizedImageCompression\");\n          }\n        bytes_per_line=2*(image->columns+image->columns % 2);\n        image->storage_class=DirectClass;\n        for (y=(ssize_t) image->rows-1; y >= 0; y--)\n        {\n          p=pixels+(image->rows-y-1)*bytes_per_line;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            pixel=(size_t) (*p++);\n            pixel|=(*p++) << 8;\n            red=((pixel & bmp_info.red_mask) << shift.red) >> 16;\n            if (quantum_bits.red == 5)\n              red|=((red & 0xe000) >> 5);\n            if (quantum_bits.red <= 8)\n              red|=((red & 0xff00) >> 8);\n            green=((pixel & bmp_info.green_mask) << shift.green) >> 16;\n            if (quantum_bits.green == 5)\n              green|=((green & 0xe000) >> 5);\n            if (quantum_bits.green == 6)\n              green|=((green & 0xc000) >> 6);\n            if (quantum_bits.green <= 8)\n              green|=((green & 0xff00) >> 8);\n            blue=((pixel & bmp_info.blue_mask) << shift.blue) >> 16;\n            if (quantum_bits.blue == 5)\n              blue|=((blue & 0xe000) >> 5);\n            if (quantum_bits.blue <= 8)\n              blue|=((blue & 0xff00) >> 8);\n            alpha=((pixel & bmp_info.alpha_mask) << shift.opacity) >> 16;\n            if (quantum_bits.opacity <= 8)\n              alpha|=((alpha & 0xff00) >> 8);\n            SetPixelRed(q,ScaleShortToQuantum((unsigned short) red));\n            SetPixelGreen(q,ScaleShortToQuantum((unsigned short) green));\n            SetPixelBlue(q,ScaleShortToQuantum((unsigned short) blue));\n            SetPixelOpacity(q,OpaqueOpacity);\n            if (image->matte != MagickFalse)\n              SetPixelAlpha(q,ScaleShortToQuantum((unsigned short) alpha));\n            q++;\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          offset=(MagickOffsetType) (image->rows-y-1);\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                (image->rows-y),image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case 24:\n      {\n        /*\n          Convert DirectColor scanline.\n        */\n        bytes_per_line=4*((image->columns*24+31)/32);\n        for (y=(ssize_t) image->rows-1; y >= 0; y--)\n        {\n          p=pixels+(image->rows-y-1)*bytes_per_line;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelBlue(q,ScaleCharToQuantum(*p++));\n            SetPixelGreen(q,ScaleCharToQuantum(*p++));\n            SetPixelRed(q,ScaleCharToQuantum(*p++));\n            SetPixelOpacity(q,OpaqueOpacity);\n            q++;\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          offset=(MagickOffsetType) (image->rows-y-1);\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                (image->rows-y),image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case 32:\n      {\n        /*\n          Convert bitfield encoded DirectColor scanline.\n        */\n        if ((bmp_info.compression != BI_RGB) &&\n            (bmp_info.compression != BI_BITFIELDS))\n          {\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            ThrowReaderException(CorruptImageError,\n              \"UnrecognizedImageCompression\");\n          }\n        bytes_per_line=4*(image->columns);\n        for (y=(ssize_t) image->rows-1; y >= 0; y--)\n        {\n          size_t\n            alpha,\n            pixel;\n\n          p=pixels+(image->rows-y-1)*bytes_per_line;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            pixel=(size_t) (*p++);\n            pixel|=((size_t) *p++ << 8);\n            pixel|=((size_t) *p++ << 16);\n            pixel|=((size_t) *p++ << 24);\n            red=((pixel & bmp_info.red_mask) << shift.red) >> 16;\n            if (quantum_bits.red == 8)\n              red|=(red >> 8);\n            green=((pixel & bmp_info.green_mask) << shift.green) >> 16;\n            if (quantum_bits.green == 8)\n              green|=(green >> 8);\n            blue=((pixel & bmp_info.blue_mask) << shift.blue) >> 16;\n            if (quantum_bits.blue == 8)\n              blue|=(blue >> 8);\n            alpha=((pixel & bmp_info.alpha_mask) << shift.opacity) >> 16;\n            if (quantum_bits.opacity == 8)\n              alpha|=(alpha >> 8);\n            SetPixelRed(q,ScaleShortToQuantum((unsigned short) red));\n            SetPixelGreen(q,ScaleShortToQuantum((unsigned short) green));\n            SetPixelBlue(q,ScaleShortToQuantum((unsigned short) blue));\n            SetPixelAlpha(q,OpaqueOpacity);\n            if (image->matte != MagickFalse)\n              SetPixelAlpha(q,ScaleShortToQuantum((unsigned short) alpha));\n            q++;\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          offset=(MagickOffsetType) (image->rows-y-1);\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                (image->rows-y),image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      default:\n      {\n        pixel_info=RelinquishVirtualMemory(pixel_info);\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n    }\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    if (bmp_info.height < 0)\n      {\n        Image\n          *flipped_image;\n\n        /*\n          Correct image orientation.\n        */\n        flipped_image=FlipImage(image,exception);\n        if (flipped_image != (Image *) NULL)\n          {\n            DuplicateBlob(flipped_image,image);\n            image=DestroyImage(image);\n            image=flipped_image;\n          }\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    *magick='\\0';\n    if (bmp_info.ba_offset != 0)\n      {\n        offset=SeekBlob(image,(MagickOffsetType) bmp_info.ba_offset,SEEK_SET);\n        if (offset < 0)\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n    count=ReadBlob(image,2,magick);\n    if ((count == 2) && (IsBMP(magick,2) != MagickFalse))\n      {\n        /*\n          Acquire next image structure.\n        */\n        AcquireNextImage(image_info,image);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (IsBMP(magick,2) != MagickFalse);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 462,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2013-2877",
    "code_before_change": "xmlParseEntityRef(xmlParserCtxtPtr ctxt) {\n    const xmlChar *name;\n     xmlEntityPtr ent = NULL;\n \n     GROW;\n \n     if (RAW != '&')\n         return(NULL);\n    NEXT;\n    name = xmlParseName(ctxt);\n    if (name == NULL) {\n\txmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n\t\t       \"xmlParseEntityRef: no name\\n\");\n        return(NULL);\n    }\n    if (RAW != ';') {\n\txmlFatalErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING, NULL);\n\treturn(NULL);\n    }\n    NEXT;\n\n    /*\n     * Predefined entites override any extra definition\n     */\n    if ((ctxt->options & XML_PARSE_OLDSAX) == 0) {\n        ent = xmlGetPredefinedEntity(name);\n        if (ent != NULL)\n            return(ent);\n    }\n\n    /*\n     * Increate the number of entity references parsed\n     */\n    ctxt->nbentities++;\n\n    /*\n     * Ask first SAX for entity resolution, otherwise try the\n     * entities which may have stored in the parser context.\n     */\n    if (ctxt->sax != NULL) {\n\tif (ctxt->sax->getEntity != NULL)\n\t    ent = ctxt->sax->getEntity(ctxt->userData, name);\n\tif ((ctxt->wellFormed == 1 ) && (ent == NULL) && \n\t    (ctxt->options & XML_PARSE_OLDSAX))\n\t    ent = xmlGetPredefinedEntity(name);\n\tif ((ctxt->wellFormed == 1 ) && (ent == NULL) &&\n\t    (ctxt->userData==ctxt)) {\n \t    ent = xmlSAX2GetEntity(ctxt, name);\n \t}\n     }\n     /*\n      * [ WFC: Entity Declared ]\n      * In a document without any DTD, a document with only an\n     * internal DTD subset which contains no parameter entity\n     * references, or a document with \"standalone='yes'\", the\n     * Name given in the entity reference must match that in an\n     * entity declaration, except that well-formed documents\n     * need not declare any of the following entities: amp, lt,\n     * gt, apos, quot.\n     * The declaration of a parameter entity must precede any\n     * reference to it.\n     * Similarly, the declaration of a general entity must\n     * precede any reference to it which appears in a default\n     * value in an attribute-list declaration. Note that if\n     * entities are declared in the external subset or in\n     * external parameter entities, a non-validating processor\n     * is not obligated to read and process their declarations;\n     * for such documents, the rule that an entity must be\n     * declared is a well-formedness constraint only if\n     * standalone='yes'.\n     */\n    if (ent == NULL) {\n\tif ((ctxt->standalone == 1) ||\n\t    ((ctxt->hasExternalSubset == 0) &&\n\t     (ctxt->hasPErefs == 0))) {\n\t    xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,\n\t\t     \"Entity '%s' not defined\\n\", name);\n\t} else {\n\t    xmlErrMsgStr(ctxt, XML_WAR_UNDECLARED_ENTITY,\n\t\t     \"Entity '%s' not defined\\n\", name);\n\t    if ((ctxt->inSubset == 0) &&\n\t\t(ctxt->sax != NULL) &&\n\t\t(ctxt->sax->reference != NULL)) {\n\t\tctxt->sax->reference(ctxt->userData, name);\n\t    }\n\t}\n\tctxt->valid = 0;\n    }\n\n    /*\n     * [ WFC: Parsed Entity ]\n     * An entity reference must not contain the name of an\n     * unparsed entity\n     */\n    else if (ent->etype == XML_EXTERNAL_GENERAL_UNPARSED_ENTITY) {\n\txmlFatalErrMsgStr(ctxt, XML_ERR_UNPARSED_ENTITY,\n\t\t \"Entity reference to unparsed entity %s\\n\", name);\n    }\n\n    /*\n     * [ WFC: No External Entity References ]\n     * Attribute values cannot contain direct or indirect\n     * entity references to external entities.\n     */\n    else if ((ctxt->instate == XML_PARSER_ATTRIBUTE_VALUE) &&\n\t     (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)) {\n\txmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_IS_EXTERNAL,\n\t     \"Attribute references external entity '%s'\\n\", name);\n    }\n    /*\n     * [ WFC: No < in Attribute Values ]\n     * The replacement text of any entity referred to directly or\n     * indirectly in an attribute value (other than \"&lt;\") must\n     * not contain a <. \n     */\n    else if ((ctxt->instate == XML_PARSER_ATTRIBUTE_VALUE) &&\n\t     (ent != NULL) && (ent->content != NULL) &&\n\t     (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n\t     (xmlStrchr(ent->content, '<'))) {\n\txmlFatalErrMsgStr(ctxt, XML_ERR_LT_IN_ATTRIBUTE,\n    \"'<' in entity '%s' is not allowed in attributes values\\n\", name);\n    }\n\n    /*\n     * Internal check, no parameter entities here ...\n     */\n    else {\n\tswitch (ent->etype) {\n\t    case XML_INTERNAL_PARAMETER_ENTITY:\n\t    case XML_EXTERNAL_PARAMETER_ENTITY:\n\t    xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_IS_PARAMETER,\n\t     \"Attempt to reference the parameter entity '%s'\\n\",\n\t\t\t      name);\n\t    break;\n\t    default:\n\t    break;\n\t}\n    }\n\n    /*\n     * [ WFC: No Recursion ]\n     * A parsed entity must not contain a recursive reference\n     * to itself, either directly or indirectly. \n     * Done somewhere else\n     */\n    return(ent);\n}\n",
    "code_after_change": "xmlParseEntityRef(xmlParserCtxtPtr ctxt) {\n    const xmlChar *name;\n     xmlEntityPtr ent = NULL;\n \n     GROW;\n    if (ctxt->instate == XML_PARSER_EOF)\n        return(NULL);\n \n     if (RAW != '&')\n         return(NULL);\n    NEXT;\n    name = xmlParseName(ctxt);\n    if (name == NULL) {\n\txmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n\t\t       \"xmlParseEntityRef: no name\\n\");\n        return(NULL);\n    }\n    if (RAW != ';') {\n\txmlFatalErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING, NULL);\n\treturn(NULL);\n    }\n    NEXT;\n\n    /*\n     * Predefined entites override any extra definition\n     */\n    if ((ctxt->options & XML_PARSE_OLDSAX) == 0) {\n        ent = xmlGetPredefinedEntity(name);\n        if (ent != NULL)\n            return(ent);\n    }\n\n    /*\n     * Increate the number of entity references parsed\n     */\n    ctxt->nbentities++;\n\n    /*\n     * Ask first SAX for entity resolution, otherwise try the\n     * entities which may have stored in the parser context.\n     */\n    if (ctxt->sax != NULL) {\n\tif (ctxt->sax->getEntity != NULL)\n\t    ent = ctxt->sax->getEntity(ctxt->userData, name);\n\tif ((ctxt->wellFormed == 1 ) && (ent == NULL) && \n\t    (ctxt->options & XML_PARSE_OLDSAX))\n\t    ent = xmlGetPredefinedEntity(name);\n\tif ((ctxt->wellFormed == 1 ) && (ent == NULL) &&\n\t    (ctxt->userData==ctxt)) {\n \t    ent = xmlSAX2GetEntity(ctxt, name);\n \t}\n     }\n    if (ctxt->instate == XML_PARSER_EOF)\n\treturn(NULL);\n     /*\n      * [ WFC: Entity Declared ]\n      * In a document without any DTD, a document with only an\n     * internal DTD subset which contains no parameter entity\n     * references, or a document with \"standalone='yes'\", the\n     * Name given in the entity reference must match that in an\n     * entity declaration, except that well-formed documents\n     * need not declare any of the following entities: amp, lt,\n     * gt, apos, quot.\n     * The declaration of a parameter entity must precede any\n     * reference to it.\n     * Similarly, the declaration of a general entity must\n     * precede any reference to it which appears in a default\n     * value in an attribute-list declaration. Note that if\n     * entities are declared in the external subset or in\n     * external parameter entities, a non-validating processor\n     * is not obligated to read and process their declarations;\n     * for such documents, the rule that an entity must be\n     * declared is a well-formedness constraint only if\n     * standalone='yes'.\n     */\n    if (ent == NULL) {\n\tif ((ctxt->standalone == 1) ||\n\t    ((ctxt->hasExternalSubset == 0) &&\n\t     (ctxt->hasPErefs == 0))) {\n\t    xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,\n\t\t     \"Entity '%s' not defined\\n\", name);\n\t} else {\n\t    xmlErrMsgStr(ctxt, XML_WAR_UNDECLARED_ENTITY,\n\t\t     \"Entity '%s' not defined\\n\", name);\n\t    if ((ctxt->inSubset == 0) &&\n\t\t(ctxt->sax != NULL) &&\n\t\t(ctxt->sax->reference != NULL)) {\n\t\tctxt->sax->reference(ctxt->userData, name);\n\t    }\n\t}\n\tctxt->valid = 0;\n    }\n\n    /*\n     * [ WFC: Parsed Entity ]\n     * An entity reference must not contain the name of an\n     * unparsed entity\n     */\n    else if (ent->etype == XML_EXTERNAL_GENERAL_UNPARSED_ENTITY) {\n\txmlFatalErrMsgStr(ctxt, XML_ERR_UNPARSED_ENTITY,\n\t\t \"Entity reference to unparsed entity %s\\n\", name);\n    }\n\n    /*\n     * [ WFC: No External Entity References ]\n     * Attribute values cannot contain direct or indirect\n     * entity references to external entities.\n     */\n    else if ((ctxt->instate == XML_PARSER_ATTRIBUTE_VALUE) &&\n\t     (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)) {\n\txmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_IS_EXTERNAL,\n\t     \"Attribute references external entity '%s'\\n\", name);\n    }\n    /*\n     * [ WFC: No < in Attribute Values ]\n     * The replacement text of any entity referred to directly or\n     * indirectly in an attribute value (other than \"&lt;\") must\n     * not contain a <. \n     */\n    else if ((ctxt->instate == XML_PARSER_ATTRIBUTE_VALUE) &&\n\t     (ent != NULL) && (ent->content != NULL) &&\n\t     (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n\t     (xmlStrchr(ent->content, '<'))) {\n\txmlFatalErrMsgStr(ctxt, XML_ERR_LT_IN_ATTRIBUTE,\n    \"'<' in entity '%s' is not allowed in attributes values\\n\", name);\n    }\n\n    /*\n     * Internal check, no parameter entities here ...\n     */\n    else {\n\tswitch (ent->etype) {\n\t    case XML_INTERNAL_PARAMETER_ENTITY:\n\t    case XML_EXTERNAL_PARAMETER_ENTITY:\n\t    xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_IS_PARAMETER,\n\t     \"Attempt to reference the parameter entity '%s'\\n\",\n\t\t\t      name);\n\t    break;\n\t    default:\n\t    break;\n\t}\n    }\n\n    /*\n     * [ WFC: No Recursion ]\n     * A parsed entity must not contain a recursive reference\n     * to itself, either directly or indirectly. \n     * Done somewhere else\n     */\n    return(ent);\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 474,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2013-7296",
    "code_before_change": "void JBIG2Stream::readSegments() {\n  Guint segNum, segFlags, segType, page, segLength;\n  Guint refFlags, nRefSegs;\n  Guint *refSegs;\n  Goffset segDataPos;\n  int c1, c2, c3;\n  Guint i;\n\n  while (readULong(&segNum)) {\n\n    if (!readUByte(&segFlags)) {\n      goto eofError1;\n    }\n    segType = segFlags & 0x3f;\n\n    if (!readUByte(&refFlags)) {\n      goto eofError1;\n    }\n    nRefSegs = refFlags >> 5;\n    if (nRefSegs == 7) {\n      if ((c1 = curStr->getChar()) == EOF ||\n\t  (c2 = curStr->getChar()) == EOF ||\n\t  (c3 = curStr->getChar()) == EOF) {\n\tgoto eofError1;\n      }\n      refFlags = (refFlags << 24) | (c1 << 16) | (c2 << 8) | c3;\n      nRefSegs = refFlags & 0x1fffffff;\n      for (i = 0; i < (nRefSegs + 9) >> 3; ++i) {\n\tif ((c1 = curStr->getChar()) == EOF) {\n\t  goto eofError1;\n\t}\n      }\n    }\n\n    refSegs = (Guint *)gmallocn(nRefSegs, sizeof(Guint));\n    if (segNum <= 256) {\n      for (i = 0; i < nRefSegs; ++i) {\n\tif (!readUByte(&refSegs[i])) {\n\t  goto eofError2;\n\t}\n      }\n    } else if (segNum <= 65536) {\n      for (i = 0; i < nRefSegs; ++i) {\n\tif (!readUWord(&refSegs[i])) {\n\t  goto eofError2;\n\t}\n      }\n    } else {\n      for (i = 0; i < nRefSegs; ++i) {\n\tif (!readULong(&refSegs[i])) {\n\t  goto eofError2;\n\t}\n      }\n    }\n\n    if (segFlags & 0x40) {\n      if (!readULong(&page)) {\n\tgoto eofError2;\n      }\n    } else {\n      if (!readUByte(&page)) {\n\tgoto eofError2;\n      }\n    }\n\n    if (!readULong(&segLength)) {\n      goto eofError2;\n    }\n\n    segDataPos = curStr->getPos();\n\n    if (!pageBitmap && ((segType >= 4 && segType <= 7) ||\n\t\t\t(segType >= 20 && segType <= 43))) {\n      error(errSyntaxError, curStr->getPos(), \"First JBIG2 segment associated with a page must be a page information segment\");\n      goto syntaxError;\n    }\n\n    switch (segType) {\n    case 0:\n      if (!readSymbolDictSeg(segNum, segLength, refSegs, nRefSegs)) {\n\tgoto syntaxError;\n      }\n      break;\n    case 4:\n      readTextRegionSeg(segNum, gFalse, gFalse, segLength, refSegs, nRefSegs);\n      break;\n    case 6:\n      readTextRegionSeg(segNum, gTrue, gFalse, segLength, refSegs, nRefSegs);\n      break;\n    case 7:\n      readTextRegionSeg(segNum, gTrue, gTrue, segLength, refSegs, nRefSegs);\n      break;\n    case 16:\n      readPatternDictSeg(segNum, segLength);\n      break;\n    case 20:\n      readHalftoneRegionSeg(segNum, gFalse, gFalse, segLength,\n\t\t\t    refSegs, nRefSegs);\n      break;\n    case 22:\n      readHalftoneRegionSeg(segNum, gTrue, gFalse, segLength,\n\t\t\t    refSegs, nRefSegs);\n      break;\n    case 23:\n      readHalftoneRegionSeg(segNum, gTrue, gTrue, segLength,\n\t\t\t    refSegs, nRefSegs);\n      break;\n    case 36:\n      readGenericRegionSeg(segNum, gFalse, gFalse, segLength);\n      break;\n    case 38:\n      readGenericRegionSeg(segNum, gTrue, gFalse, segLength);\n      break;\n    case 39:\n      readGenericRegionSeg(segNum, gTrue, gTrue, segLength);\n      break;\n    case 40:\n      readGenericRefinementRegionSeg(segNum, gFalse, gFalse, segLength,\n\t\t\t\t     refSegs, nRefSegs);\n      break;\n    case 42:\n      readGenericRefinementRegionSeg(segNum, gTrue, gFalse, segLength,\n\t\t\t\t     refSegs, nRefSegs);\n      break;\n    case 43:\n      readGenericRefinementRegionSeg(segNum, gTrue, gTrue, segLength,\n\t\t\t\t     refSegs, nRefSegs);\n      break;\n    case 48:\n      readPageInfoSeg(segLength);\n      break;\n    case 50:\n      readEndOfStripeSeg(segLength);\n      break;\n    case 52:\n      readProfilesSeg(segLength);\n      break;\n    case 53:\n      readCodeTableSeg(segNum, segLength);\n      break;\n    case 62:\n      readExtensionSeg(segLength);\n      break;\n    default:\n      error(errSyntaxError, curStr->getPos(), \"Unknown segment type in JBIG2 stream\");\n      for (i = 0; i < segLength; ++i) {\n\tif ((c1 = curStr->getChar()) == EOF) {\n\t  goto eofError2;\n\t}\n      }\n      break;\n    }\n\n\n    if (segLength != 0xffffffff) {\n\n      Goffset segExtraBytes = segDataPos + segLength - curStr->getPos();\n      if (segExtraBytes > 0) {\n\n\t\n \t\n\terror(errSyntaxError, curStr->getPos(), \"{0:d} extraneous byte{1:s} after segment\",\n \t      segExtraBytes, (segExtraBytes > 1) ? \"s\" : \"\");\n \t\n\t\n\tint trash;\n\tfor (Goffset i = segExtraBytes; i > 0; i--) {\n\t  readByte(&trash);\n\t}\n\t\n      } else if (segExtraBytes < 0) {\n\t\n\t\n\terror(errSyntaxError, curStr->getPos(), \"Previous segment handler read too many bytes\");\n\t\n      }\n\n    }\n    \n    gfree(refSegs);\n  }\n\n  return;\n\n syntaxError:\n  gfree(refSegs);\n  return;\n\n eofError2:\n  gfree(refSegs);\n eofError1:\n  error(errSyntaxError, curStr->getPos(), \"Unexpected EOF in JBIG2 stream\");\n}\n",
    "code_after_change": "void JBIG2Stream::readSegments() {\n  Guint segNum, segFlags, segType, page, segLength;\n  Guint refFlags, nRefSegs;\n  Guint *refSegs;\n  Goffset segDataPos;\n  int c1, c2, c3;\n  Guint i;\n\n  while (readULong(&segNum)) {\n\n    if (!readUByte(&segFlags)) {\n      goto eofError1;\n    }\n    segType = segFlags & 0x3f;\n\n    if (!readUByte(&refFlags)) {\n      goto eofError1;\n    }\n    nRefSegs = refFlags >> 5;\n    if (nRefSegs == 7) {\n      if ((c1 = curStr->getChar()) == EOF ||\n\t  (c2 = curStr->getChar()) == EOF ||\n\t  (c3 = curStr->getChar()) == EOF) {\n\tgoto eofError1;\n      }\n      refFlags = (refFlags << 24) | (c1 << 16) | (c2 << 8) | c3;\n      nRefSegs = refFlags & 0x1fffffff;\n      for (i = 0; i < (nRefSegs + 9) >> 3; ++i) {\n\tif ((c1 = curStr->getChar()) == EOF) {\n\t  goto eofError1;\n\t}\n      }\n    }\n\n    refSegs = (Guint *)gmallocn(nRefSegs, sizeof(Guint));\n    if (segNum <= 256) {\n      for (i = 0; i < nRefSegs; ++i) {\n\tif (!readUByte(&refSegs[i])) {\n\t  goto eofError2;\n\t}\n      }\n    } else if (segNum <= 65536) {\n      for (i = 0; i < nRefSegs; ++i) {\n\tif (!readUWord(&refSegs[i])) {\n\t  goto eofError2;\n\t}\n      }\n    } else {\n      for (i = 0; i < nRefSegs; ++i) {\n\tif (!readULong(&refSegs[i])) {\n\t  goto eofError2;\n\t}\n      }\n    }\n\n    if (segFlags & 0x40) {\n      if (!readULong(&page)) {\n\tgoto eofError2;\n      }\n    } else {\n      if (!readUByte(&page)) {\n\tgoto eofError2;\n      }\n    }\n\n    if (!readULong(&segLength)) {\n      goto eofError2;\n    }\n\n    segDataPos = curStr->getPos();\n\n    if (!pageBitmap && ((segType >= 4 && segType <= 7) ||\n\t\t\t(segType >= 20 && segType <= 43))) {\n      error(errSyntaxError, curStr->getPos(), \"First JBIG2 segment associated with a page must be a page information segment\");\n      goto syntaxError;\n    }\n\n    switch (segType) {\n    case 0:\n      if (!readSymbolDictSeg(segNum, segLength, refSegs, nRefSegs)) {\n\tgoto syntaxError;\n      }\n      break;\n    case 4:\n      readTextRegionSeg(segNum, gFalse, gFalse, segLength, refSegs, nRefSegs);\n      break;\n    case 6:\n      readTextRegionSeg(segNum, gTrue, gFalse, segLength, refSegs, nRefSegs);\n      break;\n    case 7:\n      readTextRegionSeg(segNum, gTrue, gTrue, segLength, refSegs, nRefSegs);\n      break;\n    case 16:\n      readPatternDictSeg(segNum, segLength);\n      break;\n    case 20:\n      readHalftoneRegionSeg(segNum, gFalse, gFalse, segLength,\n\t\t\t    refSegs, nRefSegs);\n      break;\n    case 22:\n      readHalftoneRegionSeg(segNum, gTrue, gFalse, segLength,\n\t\t\t    refSegs, nRefSegs);\n      break;\n    case 23:\n      readHalftoneRegionSeg(segNum, gTrue, gTrue, segLength,\n\t\t\t    refSegs, nRefSegs);\n      break;\n    case 36:\n      readGenericRegionSeg(segNum, gFalse, gFalse, segLength);\n      break;\n    case 38:\n      readGenericRegionSeg(segNum, gTrue, gFalse, segLength);\n      break;\n    case 39:\n      readGenericRegionSeg(segNum, gTrue, gTrue, segLength);\n      break;\n    case 40:\n      readGenericRefinementRegionSeg(segNum, gFalse, gFalse, segLength,\n\t\t\t\t     refSegs, nRefSegs);\n      break;\n    case 42:\n      readGenericRefinementRegionSeg(segNum, gTrue, gFalse, segLength,\n\t\t\t\t     refSegs, nRefSegs);\n      break;\n    case 43:\n      readGenericRefinementRegionSeg(segNum, gTrue, gTrue, segLength,\n\t\t\t\t     refSegs, nRefSegs);\n      break;\n    case 48:\n      readPageInfoSeg(segLength);\n      break;\n    case 50:\n      readEndOfStripeSeg(segLength);\n      break;\n    case 52:\n      readProfilesSeg(segLength);\n      break;\n    case 53:\n      readCodeTableSeg(segNum, segLength);\n      break;\n    case 62:\n      readExtensionSeg(segLength);\n      break;\n    default:\n      error(errSyntaxError, curStr->getPos(), \"Unknown segment type in JBIG2 stream\");\n      for (i = 0; i < segLength; ++i) {\n\tif ((c1 = curStr->getChar()) == EOF) {\n\t  goto eofError2;\n\t}\n      }\n      break;\n    }\n\n\n    if (segLength != 0xffffffff) {\n\n      Goffset segExtraBytes = segDataPos + segLength - curStr->getPos();\n      if (segExtraBytes > 0) {\n\n\t\n \t\n\terror(errSyntaxError, curStr->getPos(), \"{0:lld} extraneous byte{1:s} after segment\",\n \t      segExtraBytes, (segExtraBytes > 1) ? \"s\" : \"\");\n \t\n\t\n\tint trash;\n\tfor (Goffset i = segExtraBytes; i > 0; i--) {\n\t  readByte(&trash);\n\t}\n\t\n      } else if (segExtraBytes < 0) {\n\t\n\t\n\terror(errSyntaxError, curStr->getPos(), \"Previous segment handler read too many bytes\");\n\t\n      }\n\n    }\n    \n    gfree(refSegs);\n  }\n\n  return;\n\n syntaxError:\n  gfree(refSegs);\n  return;\n\n eofError2:\n  gfree(refSegs);\n eofError1:\n  error(errSyntaxError, curStr->getPos(), \"Unexpected EOF in JBIG2 stream\");\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 486,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-6297",
    "code_before_change": "php_stream *php_stream_zip_open(char *filename, char *path, char *mode STREAMS_DC TSRMLS_DC)\n{\n\tstruct zip_file *zf = NULL;\n\tint err = 0;\n\n\tphp_stream *stream = NULL;\n\tstruct php_zip_stream_data_t *self;\n\tstruct zip *stream_za;\n\n\tif (strncmp(mode,\"r\", strlen(\"r\")) != 0) {\n\t\treturn NULL;\n\t}\n\n\tif (filename) {\n\t\tif (ZIP_OPENBASEDIR_CHECKPATH(filename)) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/* duplicate to make the stream za independent (esp. for MSHUTDOWN) */\n\t\tstream_za = zip_open(filename, ZIP_CREATE, &err);\n\t\tif (!stream_za) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tzf = zip_fopen(stream_za, path, 0);\n\t\tif (zf) {\n                        self = emalloc(sizeof(*self));\n \n                        self->za = stream_za;\n                       self->zf = zf; \n                        self->stream = NULL;\n                        self->cursor = 0;\n                        stream = php_stream_alloc(&php_stream_zipio_ops, self, NULL, mode);\n\t\t\tstream->orig_path = estrdup(path);\n\t\t} else {\n\t\t\tzip_close(stream_za);\n\t\t}\n\t}\n\n\tif (!stream) {\n\t\treturn NULL;\n\t} else {\n\t\treturn stream;\n\t}\n\n}\n",
    "code_after_change": "php_stream *php_stream_zip_open(char *filename, char *path, char *mode STREAMS_DC TSRMLS_DC)\n{\n\tstruct zip_file *zf = NULL;\n\tint err = 0;\n\n\tphp_stream *stream = NULL;\n\tstruct php_zip_stream_data_t *self;\n\tstruct zip *stream_za;\n\n\tif (strncmp(mode,\"r\", strlen(\"r\")) != 0) {\n\t\treturn NULL;\n\t}\n\n\tif (filename) {\n\t\tif (ZIP_OPENBASEDIR_CHECKPATH(filename)) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/* duplicate to make the stream za independent (esp. for MSHUTDOWN) */\n\t\tstream_za = zip_open(filename, ZIP_CREATE, &err);\n\t\tif (!stream_za) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tzf = zip_fopen(stream_za, path, 0);\n\t\tif (zf) {\n                        self = emalloc(sizeof(*self));\n \n                        self->za = stream_za;\n                       self->zf = zf;\n                        self->stream = NULL;\n                        self->cursor = 0;\n                        stream = php_stream_alloc(&php_stream_zipio_ops, self, NULL, mode);\n\t\t\tstream->orig_path = estrdup(path);\n\t\t} else {\n\t\t\tzip_close(stream_za);\n\t\t}\n\t}\n\n\tif (!stream) {\n\t\treturn NULL;\n\t} else {\n\t\treturn stream;\n\t}\n\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 487,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-2476",
    "code_before_change": "OMX_ERRORTYPE SoftFlacEncoder::internalGetParameter(\n        OMX_INDEXTYPE index, OMX_PTR params) {\n    ALOGV(\"SoftFlacEncoder::internalGetParameter(index=0x%x)\", index);\n\n switch (index) {\n case OMX_IndexParamAudioPcm:\n {\n\n             OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =\n                 (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n             if (pcmParams->nPortIndex > 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n            pcmParams->eNumData = OMX_NumericalDataSigned;\n            pcmParams->eEndian = OMX_EndianBig;\n            pcmParams->bInterleaved = OMX_TRUE;\n            pcmParams->nBitPerSample = 16;\n            pcmParams->ePCMMode = OMX_AUDIO_PCMModeLinear;\n            pcmParams->eChannelMapping[0] = OMX_AUDIO_ChannelLF;\n            pcmParams->eChannelMapping[1] = OMX_AUDIO_ChannelRF;\n\n            pcmParams->nChannels = mNumChannels;\n            pcmParams->nSamplingRate = mSampleRate;\n\n return OMX_ErrorNone;\n }\n\n\n         case OMX_IndexParamAudioFlac:\n         {\n             OMX_AUDIO_PARAM_FLACTYPE *flacParams = (OMX_AUDIO_PARAM_FLACTYPE *)params;\n             flacParams->nCompressionLevel = mCompressionLevel;\n             flacParams->nChannels = mNumChannels;\n             flacParams->nSampleRate = mSampleRate;\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::internalGetParameter(index, params);\n }\n}\n",
    "code_after_change": "OMX_ERRORTYPE SoftFlacEncoder::internalGetParameter(\n        OMX_INDEXTYPE index, OMX_PTR params) {\n    ALOGV(\"SoftFlacEncoder::internalGetParameter(index=0x%x)\", index);\n\n switch (index) {\n case OMX_IndexParamAudioPcm:\n {\n\n             OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =\n                 (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n            if (!isValidOMXParam(pcmParams)) {\n                return OMX_ErrorBadParameter;\n            }\n\n             if (pcmParams->nPortIndex > 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n            pcmParams->eNumData = OMX_NumericalDataSigned;\n            pcmParams->eEndian = OMX_EndianBig;\n            pcmParams->bInterleaved = OMX_TRUE;\n            pcmParams->nBitPerSample = 16;\n            pcmParams->ePCMMode = OMX_AUDIO_PCMModeLinear;\n            pcmParams->eChannelMapping[0] = OMX_AUDIO_ChannelLF;\n            pcmParams->eChannelMapping[1] = OMX_AUDIO_ChannelRF;\n\n            pcmParams->nChannels = mNumChannels;\n            pcmParams->nSamplingRate = mSampleRate;\n\n return OMX_ErrorNone;\n }\n\n\n         case OMX_IndexParamAudioFlac:\n         {\n             OMX_AUDIO_PARAM_FLACTYPE *flacParams = (OMX_AUDIO_PARAM_FLACTYPE *)params;\n\n            if (!isValidOMXParam(flacParams)) {\n                return OMX_ErrorBadParameter;\n            }\n\n             flacParams->nCompressionLevel = mCompressionLevel;\n             flacParams->nChannels = mNumChannels;\n             flacParams->nSampleRate = mSampleRate;\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::internalGetParameter(index, params);\n }\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 489,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-3824",
    "code_before_change": "status_t OMXNodeInstance::useGraphicBuffer2_l(\n        OMX_U32 portIndex, const sp<GraphicBuffer>& graphicBuffer,\n        OMX::buffer_id *buffer) {\n\n    OMX_PARAM_PORTDEFINITIONTYPE def;\n InitOMXParams(&def);\n    def.nPortIndex = portIndex;\n    OMX_ERRORTYPE err = OMX_GetParameter(mHandle, OMX_IndexParamPortDefinition, &def);\n if (err != OMX_ErrorNone) {\n        OMX_INDEXTYPE index = OMX_IndexParamPortDefinition;\n        CLOG_ERROR(getParameter, err, \"%s(%#x): %s:%u\",\n                asString(index), index, portString(portIndex), portIndex);\n\n         return UNKNOWN_ERROR;\n     }\n \n    BufferMeta *bufferMeta = new BufferMeta(graphicBuffer);\n \n     OMX_BUFFERHEADERTYPE *header = NULL;\n     OMX_U8* bufferHandle = const_cast<OMX_U8*>(\n reinterpret_cast<const OMX_U8*>(graphicBuffer->handle));\n\n    err = OMX_UseBuffer(\n            mHandle,\n &header,\n            portIndex,\n            bufferMeta,\n            def.nBufferSize,\n            bufferHandle);\n\n if (err != OMX_ErrorNone) {\n        CLOG_ERROR(useBuffer, err, BUFFER_FMT(portIndex, \"%u@%p\", def.nBufferSize, bufferHandle));\n delete bufferMeta;\n        bufferMeta = NULL;\n *buffer = 0;\n return StatusFromOMXError(err);\n }\n\n    CHECK_EQ(header->pBuffer, bufferHandle);\n    CHECK_EQ(header->pAppPrivate, bufferMeta);\n\n *buffer = makeBufferID(header);\n\n    addActiveBuffer(portIndex, *buffer);\n    CLOG_BUFFER(useGraphicBuffer2, NEW_BUFFER_FMT(\n *buffer, portIndex, \"%u@%p\", def.nBufferSize, bufferHandle));\n return OK;\n}\n",
    "code_after_change": "status_t OMXNodeInstance::useGraphicBuffer2_l(\n        OMX_U32 portIndex, const sp<GraphicBuffer>& graphicBuffer,\n        OMX::buffer_id *buffer) {\n\n    OMX_PARAM_PORTDEFINITIONTYPE def;\n InitOMXParams(&def);\n    def.nPortIndex = portIndex;\n    OMX_ERRORTYPE err = OMX_GetParameter(mHandle, OMX_IndexParamPortDefinition, &def);\n if (err != OMX_ErrorNone) {\n        OMX_INDEXTYPE index = OMX_IndexParamPortDefinition;\n        CLOG_ERROR(getParameter, err, \"%s(%#x): %s:%u\",\n                asString(index), index, portString(portIndex), portIndex);\n\n         return UNKNOWN_ERROR;\n     }\n \n    BufferMeta *bufferMeta = new BufferMeta(graphicBuffer, portIndex);\n \n     OMX_BUFFERHEADERTYPE *header = NULL;\n     OMX_U8* bufferHandle = const_cast<OMX_U8*>(\n reinterpret_cast<const OMX_U8*>(graphicBuffer->handle));\n\n    err = OMX_UseBuffer(\n            mHandle,\n &header,\n            portIndex,\n            bufferMeta,\n            def.nBufferSize,\n            bufferHandle);\n\n if (err != OMX_ErrorNone) {\n        CLOG_ERROR(useBuffer, err, BUFFER_FMT(portIndex, \"%u@%p\", def.nBufferSize, bufferHandle));\n delete bufferMeta;\n        bufferMeta = NULL;\n *buffer = 0;\n return StatusFromOMXError(err);\n }\n\n    CHECK_EQ(header->pBuffer, bufferHandle);\n    CHECK_EQ(header->pAppPrivate, bufferMeta);\n\n *buffer = makeBufferID(header);\n\n    addActiveBuffer(portIndex, *buffer);\n    CLOG_BUFFER(useGraphicBuffer2, NEW_BUFFER_FMT(\n *buffer, portIndex, \"%u@%p\", def.nBufferSize, bufferHandle));\n return OK;\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 490,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2017-16546",
    "code_before_change": "static Image *ReadWPGImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  typedef struct\n  {\n    size_t FileId;\n    MagickOffsetType DataOffset;\n    unsigned int ProductType;\n    unsigned int FileType;\n    unsigned char MajorVersion;\n    unsigned char MinorVersion;\n    unsigned int EncryptKey;\n    unsigned int Reserved;\n  } WPGHeader;\n\n  typedef struct\n  {\n    unsigned char RecType;\n    size_t RecordLength;\n  } WPGRecord;\n\n  typedef struct\n  {\n    unsigned char Class;\n    unsigned char RecType;\n    size_t Extension;\n    size_t RecordLength;\n  } WPG2Record;\n\n  typedef struct\n  {\n    unsigned  HorizontalUnits;\n    unsigned  VerticalUnits;\n    unsigned char PosSizePrecision;\n  } WPG2Start;\n\n  typedef struct\n  {\n    unsigned int Width;\n    unsigned int Height;\n    unsigned int Depth;\n    unsigned int HorzRes;\n    unsigned int VertRes;\n  } WPGBitmapType1;\n\n  typedef struct\n  {\n    unsigned int Width;\n    unsigned int Height;\n    unsigned char Depth;\n    unsigned char Compression;\n  } WPG2BitmapType1;\n\n  typedef struct\n  {\n    unsigned int RotAngle;\n    unsigned int LowLeftX;\n    unsigned int LowLeftY;\n    unsigned int UpRightX;\n    unsigned int UpRightY;\n    unsigned int Width;\n    unsigned int Height;\n    unsigned int Depth;\n    unsigned int HorzRes;\n    unsigned int VertRes;\n  } WPGBitmapType2;\n\n  typedef struct\n  {\n    unsigned int StartIndex;\n    unsigned int NumOfEntries;\n  } WPGColorMapRec;\n\n  /*\n  typedef struct {\n    size_t PS_unknown1;\n    unsigned int PS_unknown2;\n    unsigned int PS_unknown3;\n  } WPGPSl1Record;\n  */\n\n  Image\n    *image;\n\n  unsigned int\n    status;\n\n  WPGHeader\n    Header;\n\n  WPGRecord\n    Rec;\n\n  WPG2Record\n    Rec2;\n\n  WPG2Start StartWPG;\n\n  WPGBitmapType1\n    BitmapHeader1;\n\n  WPG2BitmapType1\n    Bitmap2Header1;\n\n  WPGBitmapType2\n    BitmapHeader2;\n\n  WPGColorMapRec\n    WPG_Palette;\n\n  int\n    i,\n    bpp,\n    WPG2Flags;\n\n  ssize_t\n    ldblk;\n\n  size_t\n    one;\n\n  unsigned char\n    *BImgBuff;\n\n  tCTM CTM;         /*current transform matrix*/\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  one=1;\n  image=AcquireImage(image_info);\n  image->depth=8;\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read WPG image.\n  */\n  Header.FileId=ReadBlobLSBLong(image);\n  Header.DataOffset=(MagickOffsetType) ReadBlobLSBLong(image);\n  Header.ProductType=ReadBlobLSBShort(image);\n  Header.FileType=ReadBlobLSBShort(image);\n  Header.MajorVersion=ReadBlobByte(image);\n  Header.MinorVersion=ReadBlobByte(image);\n  Header.EncryptKey=ReadBlobLSBShort(image);\n  Header.Reserved=ReadBlobLSBShort(image);\n\n  if (Header.FileId!=0x435057FF || (Header.ProductType>>8)!=0x16)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (Header.EncryptKey!=0)\n    ThrowReaderException(CoderError,\"EncryptedWPGImageFileNotSupported\");\n\n  image->columns = 1;\n  image->rows = 1;\n  image->colors = 0;\n  bpp=0;\n  BitmapHeader2.RotAngle=0;\n  Rec2.RecordLength = 0;\n\n  switch(Header.FileType)\n    {\n    case 1:     /* WPG level 1 */\n      while(!EOFBlob(image)) /* object parser loop */\n        {\n          (void) SeekBlob(image,Header.DataOffset,SEEK_SET);\n          if(EOFBlob(image))\n            break;\n\n          Rec.RecType=(i=ReadBlobByte(image));\n          if(i==EOF)\n            break;\n          Rd_WP_DWORD(image,&Rec.RecordLength);\n          if (Rec.RecordLength > GetBlobSize(image))\n            ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n          if(EOFBlob(image))\n            break;\n\n          Header.DataOffset=TellBlob(image)+Rec.RecordLength;\n\n          switch(Rec.RecType)\n            {\n            case 0x0B: /* bitmap type 1 */\n              BitmapHeader1.Width=ReadBlobLSBShort(image);\n              BitmapHeader1.Height=ReadBlobLSBShort(image);\n              if ((BitmapHeader1.Width == 0) || (BitmapHeader1.Height == 0))\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              BitmapHeader1.Depth=ReadBlobLSBShort(image);\n              BitmapHeader1.HorzRes=ReadBlobLSBShort(image);\n              BitmapHeader1.VertRes=ReadBlobLSBShort(image);\n\n              if(BitmapHeader1.HorzRes && BitmapHeader1.VertRes)\n                {\n                  image->units=PixelsPerCentimeterResolution;\n                  image->x_resolution=BitmapHeader1.HorzRes/470.0;\n                  image->y_resolution=BitmapHeader1.VertRes/470.0;\n                }\n              image->columns=BitmapHeader1.Width;\n              image->rows=BitmapHeader1.Height;\n              bpp=BitmapHeader1.Depth;\n\n              goto UnpackRaster;\n\n            case 0x0E:  /*Color palette */\n              WPG_Palette.StartIndex=ReadBlobLSBShort(image);\n              WPG_Palette.NumOfEntries=ReadBlobLSBShort(image);\n               if ((WPG_Palette.NumOfEntries-WPG_Palette.StartIndex) >\n                   (Rec2.RecordLength-2-2) / 3)\n                 ThrowReaderException(CorruptImageError,\"InvalidColormapIndex\");\n               image->colors=WPG_Palette.NumOfEntries;\n               if (!AcquireImageColormap(image,image->colors))\n                 goto NoMemory;\n              for (i=WPG_Palette.StartIndex;\n                   i < (int)WPG_Palette.NumOfEntries; i++)\n                {\n                  image->colormap[i].red=ScaleCharToQuantum((unsigned char)\n                    ReadBlobByte(image));\n                  image->colormap[i].green=ScaleCharToQuantum((unsigned char)\n                    ReadBlobByte(image));\n                  image->colormap[i].blue=ScaleCharToQuantum((unsigned char)\n                    ReadBlobByte(image));\n                }\n              break;\n\n            case 0x11:  /* Start PS l1 */\n              if(Rec.RecordLength > 8)\n                image=ExtractPostscript(image,image_info,\n                  TellBlob(image)+8,   /* skip PS header in the wpg */\n                  (ssize_t) Rec.RecordLength-8,exception);\n              break;\n\n            case 0x14:  /* bitmap type 2 */\n              BitmapHeader2.RotAngle=ReadBlobLSBShort(image);\n              BitmapHeader2.LowLeftX=ReadBlobLSBShort(image);\n              BitmapHeader2.LowLeftY=ReadBlobLSBShort(image);\n              BitmapHeader2.UpRightX=ReadBlobLSBShort(image);\n              BitmapHeader2.UpRightY=ReadBlobLSBShort(image);\n              BitmapHeader2.Width=ReadBlobLSBShort(image);\n              BitmapHeader2.Height=ReadBlobLSBShort(image);\n              if ((BitmapHeader2.Width == 0) || (BitmapHeader2.Height == 0))\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              BitmapHeader2.Depth=ReadBlobLSBShort(image);\n              BitmapHeader2.HorzRes=ReadBlobLSBShort(image);\n              BitmapHeader2.VertRes=ReadBlobLSBShort(image);\n\n              image->units=PixelsPerCentimeterResolution;\n              image->page.width=(unsigned int)\n                ((BitmapHeader2.LowLeftX-BitmapHeader2.UpRightX)/470.0);\n              image->page.height=(unsigned int)\n                ((BitmapHeader2.LowLeftX-BitmapHeader2.UpRightY)/470.0);\n              image->page.x=(int) (BitmapHeader2.LowLeftX/470.0);\n              image->page.y=(int) (BitmapHeader2.LowLeftX/470.0);\n              if(BitmapHeader2.HorzRes && BitmapHeader2.VertRes)\n                {\n                  image->x_resolution=BitmapHeader2.HorzRes/470.0;\n                  image->y_resolution=BitmapHeader2.VertRes/470.0;\n                }\n              image->columns=BitmapHeader2.Width;\n              image->rows=BitmapHeader2.Height;\n              bpp=BitmapHeader2.Depth;\n\n            UnpackRaster:\n              status=SetImageExtent(image,image->columns,image->rows);\n              if (status == MagickFalse)\n                break;\n              if ((image->colors == 0) && (bpp <= 16))\n                {\n                  image->colors=one << bpp;\n                  if (!AcquireImageColormap(image,image->colors))\n                    {\n                    NoMemory:\n                      ThrowReaderException(ResourceLimitError,\n                        \"MemoryAllocationFailed\");\n                    }\n                  /* printf(\"Load default colormap \\n\"); */\n                  for (i=0; (i < (int) image->colors) && (i < 256); i++)\n                    {\n                      image->colormap[i].red=ScaleCharToQuantum(WPG1_Palette[i].Red);\n                      image->colormap[i].green=ScaleCharToQuantum(WPG1_Palette[i].Green);\n                      image->colormap[i].blue=ScaleCharToQuantum(WPG1_Palette[i].Blue);\n                    }\n                }\n              else\n                {\n                  if (bpp < 24)\n                    if ( (image->colors < (one << bpp)) && (bpp != 24) )\n                      image->colormap=(PixelPacket *) ResizeQuantumMemory(\n                        image->colormap,(size_t) (one << bpp),\n                        sizeof(*image->colormap));\n                }\n\n              if (bpp == 1)\n                {\n                  if(image->colormap[0].red==0 &&\n                     image->colormap[0].green==0 &&\n                     image->colormap[0].blue==0 &&\n                     image->colormap[1].red==0 &&\n                     image->colormap[1].green==0 &&\n                     image->colormap[1].blue==0)\n                    {  /* fix crippled monochrome palette */\n                      image->colormap[1].red =\n                        image->colormap[1].green =\n                        image->colormap[1].blue = QuantumRange;\n                    }\n                }\n\n              if(UnpackWPGRaster(image,bpp) < 0)\n                /* The raster cannot be unpacked */\n                {\n                DecompressionFailed:\n                  ThrowReaderException(CoderError,\"UnableToDecompressImage\");\n                    }\n\n              if(Rec.RecType==0x14 && BitmapHeader2.RotAngle!=0 && !image_info->ping)\n                {\n                  /* flop command */\n                  if(BitmapHeader2.RotAngle & 0x8000)\n                    {\n                      Image\n                        *flop_image;\n\n                      flop_image = FlopImage(image, exception);\n                      if (flop_image != (Image *) NULL) {\n                        DuplicateBlob(flop_image,image);\n                        ReplaceImageInList(&image,flop_image);\n                      }\n                    }\n                  /* flip command */\n                  if(BitmapHeader2.RotAngle & 0x2000)\n                    {\n                      Image\n                        *flip_image;\n\n                      flip_image = FlipImage(image, exception);\n                      if (flip_image != (Image *) NULL) {\n                        DuplicateBlob(flip_image,image);\n                        ReplaceImageInList(&image,flip_image);\n                      }\n                    }\n                  /* rotate command */\n                  if(BitmapHeader2.RotAngle & 0x0FFF)\n                    {\n                      Image\n                        *rotate_image;\n\n                      rotate_image=RotateImage(image,(BitmapHeader2.RotAngle &\n                        0x0FFF), exception);\n                      if (rotate_image != (Image *) NULL) {\n                        DuplicateBlob(rotate_image,image);\n                        ReplaceImageInList(&image,rotate_image);\n                      }\n                    }\n                }\n\n              /* Allocate next image structure. */\n              AcquireNextImage(image_info,image);\n              image->depth=8;\n              if (image->next == (Image *) NULL)\n                goto Finish;\n              image=SyncNextImageInList(image);\n              image->columns=image->rows=1;\n              image->colors=0;\n              break;\n\n            case 0x1B:  /* Postscript l2 */\n              if(Rec.RecordLength>0x3C)\n                image=ExtractPostscript(image,image_info,\n                  TellBlob(image)+0x3C,   /* skip PS l2 header in the wpg */\n                  (ssize_t) Rec.RecordLength-0x3C,exception);\n              break;\n            }\n        }\n      break;\n\n    case 2:  /* WPG level 2 */\n      (void) memset(CTM,0,sizeof(CTM));\n      StartWPG.PosSizePrecision = 0;\n      while(!EOFBlob(image)) /* object parser loop */\n        {\n          (void) SeekBlob(image,Header.DataOffset,SEEK_SET);\n          if(EOFBlob(image))\n            break;\n\n          Rec2.Class=(i=ReadBlobByte(image));\n          if(i==EOF)\n            break;\n          Rec2.RecType=(i=ReadBlobByte(image));\n          if(i==EOF)\n            break;\n          Rd_WP_DWORD(image,&Rec2.Extension);\n          Rd_WP_DWORD(image,&Rec2.RecordLength);\n          if(EOFBlob(image))\n            break;\n\n          Header.DataOffset=TellBlob(image)+Rec2.RecordLength;\n\n          switch(Rec2.RecType)\n            {\n      case 1:\n              StartWPG.HorizontalUnits=ReadBlobLSBShort(image);\n              StartWPG.VerticalUnits=ReadBlobLSBShort(image);\n              StartWPG.PosSizePrecision=ReadBlobByte(image);\n              break;\n            case 0x0C:    /* Color palette */\n              WPG_Palette.StartIndex=ReadBlobLSBShort(image);\n              WPG_Palette.NumOfEntries=ReadBlobLSBShort(image);\n              if ((WPG_Palette.NumOfEntries-WPG_Palette.StartIndex) >\n                  (Rec2.RecordLength-2-2) / 3)\n                ThrowReaderException(CorruptImageError,\"InvalidColormapIndex\");\n              image->colors=WPG_Palette.NumOfEntries;\n              if (AcquireImageColormap(image,image->colors) == MagickFalse)\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              for (i=WPG_Palette.StartIndex;\n                   i < (int)WPG_Palette.NumOfEntries; i++)\n                {\n                  image->colormap[i].red=ScaleCharToQuantum((char)\n                    ReadBlobByte(image));\n                  image->colormap[i].green=ScaleCharToQuantum((char)\n                    ReadBlobByte(image));\n                  image->colormap[i].blue=ScaleCharToQuantum((char)\n                    ReadBlobByte(image));\n                  (void) ReadBlobByte(image);   /*Opacity??*/\n                }\n              break;\n            case 0x0E:\n              Bitmap2Header1.Width=ReadBlobLSBShort(image);\n              Bitmap2Header1.Height=ReadBlobLSBShort(image);\n              if ((Bitmap2Header1.Width == 0) || (Bitmap2Header1.Height == 0))\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              Bitmap2Header1.Depth=ReadBlobByte(image);\n              Bitmap2Header1.Compression=ReadBlobByte(image);\n\n              if(Bitmap2Header1.Compression > 1)\n                continue; /*Unknown compression method */\n              switch(Bitmap2Header1.Depth)\n                {\n                case 1:\n                  bpp=1;\n                  break;\n                case 2:\n                  bpp=2;\n                  break;\n                case 3:\n                  bpp=4;\n                  break;\n                case 4:\n                  bpp=8;\n                  break;\n                case 8:\n                  bpp=24;\n                  break;\n                default:\n                  continue;  /*Ignore raster with unknown depth*/\n                }\n              image->columns=Bitmap2Header1.Width;\n              image->rows=Bitmap2Header1.Height;\n              status=SetImageExtent(image,image->columns,image->rows);\n              if (status == MagickFalse)\n                break;\n              if ((image->colors == 0) && (bpp != 24))\n                {\n                  size_t\n                    one;\n\n                  one=1;\n                  image->colors=one << bpp;\n                  if (!AcquireImageColormap(image,image->colors))\n                    goto NoMemory;\n                }\n              else\n                {\n                  if(bpp < 24)\n                    if( image->colors<(one << bpp) && bpp!=24 )\n                      image->colormap=(PixelPacket *) ResizeQuantumMemory(\n                       image->colormap,(size_t) (one << bpp),\n                       sizeof(*image->colormap));\n                }\n\n\n              switch(Bitmap2Header1.Compression)\n                {\n                case 0:    /*Uncompressed raster*/\n                  {\n                    ldblk=(ssize_t) ((bpp*image->columns+7)/8);\n                    BImgBuff=(unsigned char *) AcquireQuantumMemory((size_t)\n                      ldblk+1,sizeof(*BImgBuff));\n                    if (BImgBuff == (unsigned char *) NULL)\n                      goto NoMemory;\n\n                    for(i=0; i< (ssize_t) image->rows; i++)\n                      {\n                        (void) ReadBlob(image,ldblk,BImgBuff);\n                        InsertRow(BImgBuff,i,image,bpp);\n                      }\n\n                    if(BImgBuff)\n                      BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);\n                    break;\n                  }\n                case 1:    /*RLE for WPG2 */\n                  {\n                    if( UnpackWPG2Raster(image,bpp) < 0)\n                      goto DecompressionFailed;\n                    break;\n                  }\n                }\n\n              if(CTM[0][0]<0 && !image_info->ping)\n                {    /*?? RotAngle=360-RotAngle;*/\n                  Image\n                    *flop_image;\n\n                  flop_image = FlopImage(image, exception);\n                  if (flop_image != (Image *) NULL) {\n                    DuplicateBlob(flop_image,image);\n                    ReplaceImageInList(&image,flop_image);\n                  }\n                  /* Try to change CTM according to Flip - I am not sure, must be checked.\n                     Tx(0,0)=-1;      Tx(1,0)=0;   Tx(2,0)=0;\n                     Tx(0,1)= 0;      Tx(1,1)=1;   Tx(2,1)=0;\n                     Tx(0,2)=(WPG._2Rect.X_ur+WPG._2Rect.X_ll);\n                     Tx(1,2)=0;   Tx(2,2)=1; */\n                }\n              if(CTM[1][1]<0 && !image_info->ping)\n                {    /*?? RotAngle=360-RotAngle;*/\n                  Image\n                    *flip_image;\n\n                  flip_image = FlipImage(image, exception);\n                  if (flip_image != (Image *) NULL) {\n                    DuplicateBlob(flip_image,image);\n                    ReplaceImageInList(&image,flip_image);\n                  }\n                  /* Try to change CTM according to Flip - I am not sure, must be checked.\n                     float_matrix Tx(3,3);\n                     Tx(0,0)= 1;   Tx(1,0)= 0;   Tx(2,0)=0;\n                     Tx(0,1)= 0;   Tx(1,1)=-1;   Tx(2,1)=0;\n                     Tx(0,2)= 0;   Tx(1,2)=(WPG._2Rect.Y_ur+WPG._2Rect.Y_ll);\n                     Tx(2,2)=1; */\n                }\n\n\n              /* Allocate next image structure. */\n              AcquireNextImage(image_info,image);\n              image->depth=8;\n              if (image->next == (Image *) NULL)\n                goto Finish;\n              image=SyncNextImageInList(image);\n              image->columns=image->rows=1;\n              image->colors=0;\n              break;\n\n            case 0x12:  /* Postscript WPG2*/\n        i=ReadBlobLSBShort(image);\n              if(Rec2.RecordLength > (unsigned int) i)\n                image=ExtractPostscript(image,image_info,\n                  TellBlob(image)+i,    /*skip PS header in the wpg2*/\n                  (ssize_t) (Rec2.RecordLength-i-2),exception);\n              break;\n\n      case 0x1B:          /*bitmap rectangle*/\n              WPG2Flags = LoadWPG2Flags(image,StartWPG.PosSizePrecision,NULL,&CTM);\n              (void) WPG2Flags;\n              break;\n            }\n        }\n\n      break;\n\n    default:\n      {\n         ThrowReaderException(CoderError,\"DataEncodingSchemeIsNotSupported\");\n      }\n   }\n\n Finish:\n  (void) CloseBlob(image);\n\n  {\n    Image\n      *p;\n\n    ssize_t\n      scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n    /*\n      Fix scene numbers.\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=(size_t) scene++;\n  }\n  if (image == (Image *) NULL)\n    ThrowReaderException(CorruptImageError,\n      \"ImageFileDoesNotContainAnyImageData\");\n  return(image);\n}\n",
    "code_after_change": "static Image *ReadWPGImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  typedef struct\n  {\n    size_t FileId;\n    MagickOffsetType DataOffset;\n    unsigned int ProductType;\n    unsigned int FileType;\n    unsigned char MajorVersion;\n    unsigned char MinorVersion;\n    unsigned int EncryptKey;\n    unsigned int Reserved;\n  } WPGHeader;\n\n  typedef struct\n  {\n    unsigned char RecType;\n    size_t RecordLength;\n  } WPGRecord;\n\n  typedef struct\n  {\n    unsigned char Class;\n    unsigned char RecType;\n    size_t Extension;\n    size_t RecordLength;\n  } WPG2Record;\n\n  typedef struct\n  {\n    unsigned  HorizontalUnits;\n    unsigned  VerticalUnits;\n    unsigned char PosSizePrecision;\n  } WPG2Start;\n\n  typedef struct\n  {\n    unsigned int Width;\n    unsigned int Height;\n    unsigned int Depth;\n    unsigned int HorzRes;\n    unsigned int VertRes;\n  } WPGBitmapType1;\n\n  typedef struct\n  {\n    unsigned int Width;\n    unsigned int Height;\n    unsigned char Depth;\n    unsigned char Compression;\n  } WPG2BitmapType1;\n\n  typedef struct\n  {\n    unsigned int RotAngle;\n    unsigned int LowLeftX;\n    unsigned int LowLeftY;\n    unsigned int UpRightX;\n    unsigned int UpRightY;\n    unsigned int Width;\n    unsigned int Height;\n    unsigned int Depth;\n    unsigned int HorzRes;\n    unsigned int VertRes;\n  } WPGBitmapType2;\n\n  typedef struct\n  {\n    unsigned int StartIndex;\n    unsigned int NumOfEntries;\n  } WPGColorMapRec;\n\n  /*\n  typedef struct {\n    size_t PS_unknown1;\n    unsigned int PS_unknown2;\n    unsigned int PS_unknown3;\n  } WPGPSl1Record;\n  */\n\n  Image\n    *image;\n\n  unsigned int\n    status;\n\n  WPGHeader\n    Header;\n\n  WPGRecord\n    Rec;\n\n  WPG2Record\n    Rec2;\n\n  WPG2Start StartWPG;\n\n  WPGBitmapType1\n    BitmapHeader1;\n\n  WPG2BitmapType1\n    Bitmap2Header1;\n\n  WPGBitmapType2\n    BitmapHeader2;\n\n  WPGColorMapRec\n    WPG_Palette;\n\n  int\n    i,\n    bpp,\n    WPG2Flags;\n\n  ssize_t\n    ldblk;\n\n  size_t\n    one;\n\n  unsigned char\n    *BImgBuff;\n\n  tCTM CTM;         /*current transform matrix*/\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  one=1;\n  image=AcquireImage(image_info);\n  image->depth=8;\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read WPG image.\n  */\n  Header.FileId=ReadBlobLSBLong(image);\n  Header.DataOffset=(MagickOffsetType) ReadBlobLSBLong(image);\n  Header.ProductType=ReadBlobLSBShort(image);\n  Header.FileType=ReadBlobLSBShort(image);\n  Header.MajorVersion=ReadBlobByte(image);\n  Header.MinorVersion=ReadBlobByte(image);\n  Header.EncryptKey=ReadBlobLSBShort(image);\n  Header.Reserved=ReadBlobLSBShort(image);\n\n  if (Header.FileId!=0x435057FF || (Header.ProductType>>8)!=0x16)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (Header.EncryptKey!=0)\n    ThrowReaderException(CoderError,\"EncryptedWPGImageFileNotSupported\");\n\n  image->columns = 1;\n  image->rows = 1;\n  image->colors = 0;\n  bpp=0;\n  BitmapHeader2.RotAngle=0;\n  Rec2.RecordLength = 0;\n\n  switch(Header.FileType)\n    {\n    case 1:     /* WPG level 1 */\n      while(!EOFBlob(image)) /* object parser loop */\n        {\n          (void) SeekBlob(image,Header.DataOffset,SEEK_SET);\n          if(EOFBlob(image))\n            break;\n\n          Rec.RecType=(i=ReadBlobByte(image));\n          if(i==EOF)\n            break;\n          Rd_WP_DWORD(image,&Rec.RecordLength);\n          if (Rec.RecordLength > GetBlobSize(image))\n            ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n          if(EOFBlob(image))\n            break;\n\n          Header.DataOffset=TellBlob(image)+Rec.RecordLength;\n\n          switch(Rec.RecType)\n            {\n            case 0x0B: /* bitmap type 1 */\n              BitmapHeader1.Width=ReadBlobLSBShort(image);\n              BitmapHeader1.Height=ReadBlobLSBShort(image);\n              if ((BitmapHeader1.Width == 0) || (BitmapHeader1.Height == 0))\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              BitmapHeader1.Depth=ReadBlobLSBShort(image);\n              BitmapHeader1.HorzRes=ReadBlobLSBShort(image);\n              BitmapHeader1.VertRes=ReadBlobLSBShort(image);\n\n              if(BitmapHeader1.HorzRes && BitmapHeader1.VertRes)\n                {\n                  image->units=PixelsPerCentimeterResolution;\n                  image->x_resolution=BitmapHeader1.HorzRes/470.0;\n                  image->y_resolution=BitmapHeader1.VertRes/470.0;\n                }\n              image->columns=BitmapHeader1.Width;\n              image->rows=BitmapHeader1.Height;\n              bpp=BitmapHeader1.Depth;\n\n              goto UnpackRaster;\n\n            case 0x0E:  /*Color palette */\n              WPG_Palette.StartIndex=ReadBlobLSBShort(image);\n              WPG_Palette.NumOfEntries=ReadBlobLSBShort(image);\n               if ((WPG_Palette.NumOfEntries-WPG_Palette.StartIndex) >\n                   (Rec2.RecordLength-2-2) / 3)\n                 ThrowReaderException(CorruptImageError,\"InvalidColormapIndex\");\n              if (WPG_Palette.StartIndex > WPG_Palette.NumOfEntries)\n                ThrowReaderException(CorruptImageError,\"InvalidColormapIndex\");\n               image->colors=WPG_Palette.NumOfEntries;\n               if (!AcquireImageColormap(image,image->colors))\n                 goto NoMemory;\n              for (i=WPG_Palette.StartIndex;\n                   i < (int)WPG_Palette.NumOfEntries; i++)\n                {\n                  image->colormap[i].red=ScaleCharToQuantum((unsigned char)\n                    ReadBlobByte(image));\n                  image->colormap[i].green=ScaleCharToQuantum((unsigned char)\n                    ReadBlobByte(image));\n                  image->colormap[i].blue=ScaleCharToQuantum((unsigned char)\n                    ReadBlobByte(image));\n                }\n              break;\n\n            case 0x11:  /* Start PS l1 */\n              if(Rec.RecordLength > 8)\n                image=ExtractPostscript(image,image_info,\n                  TellBlob(image)+8,   /* skip PS header in the wpg */\n                  (ssize_t) Rec.RecordLength-8,exception);\n              break;\n\n            case 0x14:  /* bitmap type 2 */\n              BitmapHeader2.RotAngle=ReadBlobLSBShort(image);\n              BitmapHeader2.LowLeftX=ReadBlobLSBShort(image);\n              BitmapHeader2.LowLeftY=ReadBlobLSBShort(image);\n              BitmapHeader2.UpRightX=ReadBlobLSBShort(image);\n              BitmapHeader2.UpRightY=ReadBlobLSBShort(image);\n              BitmapHeader2.Width=ReadBlobLSBShort(image);\n              BitmapHeader2.Height=ReadBlobLSBShort(image);\n              if ((BitmapHeader2.Width == 0) || (BitmapHeader2.Height == 0))\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              BitmapHeader2.Depth=ReadBlobLSBShort(image);\n              BitmapHeader2.HorzRes=ReadBlobLSBShort(image);\n              BitmapHeader2.VertRes=ReadBlobLSBShort(image);\n\n              image->units=PixelsPerCentimeterResolution;\n              image->page.width=(unsigned int)\n                ((BitmapHeader2.LowLeftX-BitmapHeader2.UpRightX)/470.0);\n              image->page.height=(unsigned int)\n                ((BitmapHeader2.LowLeftX-BitmapHeader2.UpRightY)/470.0);\n              image->page.x=(int) (BitmapHeader2.LowLeftX/470.0);\n              image->page.y=(int) (BitmapHeader2.LowLeftX/470.0);\n              if(BitmapHeader2.HorzRes && BitmapHeader2.VertRes)\n                {\n                  image->x_resolution=BitmapHeader2.HorzRes/470.0;\n                  image->y_resolution=BitmapHeader2.VertRes/470.0;\n                }\n              image->columns=BitmapHeader2.Width;\n              image->rows=BitmapHeader2.Height;\n              bpp=BitmapHeader2.Depth;\n\n            UnpackRaster:\n              status=SetImageExtent(image,image->columns,image->rows);\n              if (status == MagickFalse)\n                break;\n              if ((image->colors == 0) && (bpp <= 16))\n                {\n                  image->colors=one << bpp;\n                  if (!AcquireImageColormap(image,image->colors))\n                    {\n                    NoMemory:\n                      ThrowReaderException(ResourceLimitError,\n                        \"MemoryAllocationFailed\");\n                    }\n                  /* printf(\"Load default colormap \\n\"); */\n                  for (i=0; (i < (int) image->colors) && (i < 256); i++)\n                    {\n                      image->colormap[i].red=ScaleCharToQuantum(WPG1_Palette[i].Red);\n                      image->colormap[i].green=ScaleCharToQuantum(WPG1_Palette[i].Green);\n                      image->colormap[i].blue=ScaleCharToQuantum(WPG1_Palette[i].Blue);\n                    }\n                }\n              else\n                {\n                  if (bpp < 24)\n                    if ( (image->colors < (one << bpp)) && (bpp != 24) )\n                      image->colormap=(PixelPacket *) ResizeQuantumMemory(\n                        image->colormap,(size_t) (one << bpp),\n                        sizeof(*image->colormap));\n                }\n\n              if (bpp == 1)\n                {\n                  if(image->colormap[0].red==0 &&\n                     image->colormap[0].green==0 &&\n                     image->colormap[0].blue==0 &&\n                     image->colormap[1].red==0 &&\n                     image->colormap[1].green==0 &&\n                     image->colormap[1].blue==0)\n                    {  /* fix crippled monochrome palette */\n                      image->colormap[1].red =\n                        image->colormap[1].green =\n                        image->colormap[1].blue = QuantumRange;\n                    }\n                }\n\n              if(UnpackWPGRaster(image,bpp) < 0)\n                /* The raster cannot be unpacked */\n                {\n                DecompressionFailed:\n                  ThrowReaderException(CoderError,\"UnableToDecompressImage\");\n                    }\n\n              if(Rec.RecType==0x14 && BitmapHeader2.RotAngle!=0 && !image_info->ping)\n                {\n                  /* flop command */\n                  if(BitmapHeader2.RotAngle & 0x8000)\n                    {\n                      Image\n                        *flop_image;\n\n                      flop_image = FlopImage(image, exception);\n                      if (flop_image != (Image *) NULL) {\n                        DuplicateBlob(flop_image,image);\n                        ReplaceImageInList(&image,flop_image);\n                      }\n                    }\n                  /* flip command */\n                  if(BitmapHeader2.RotAngle & 0x2000)\n                    {\n                      Image\n                        *flip_image;\n\n                      flip_image = FlipImage(image, exception);\n                      if (flip_image != (Image *) NULL) {\n                        DuplicateBlob(flip_image,image);\n                        ReplaceImageInList(&image,flip_image);\n                      }\n                    }\n                  /* rotate command */\n                  if(BitmapHeader2.RotAngle & 0x0FFF)\n                    {\n                      Image\n                        *rotate_image;\n\n                      rotate_image=RotateImage(image,(BitmapHeader2.RotAngle &\n                        0x0FFF), exception);\n                      if (rotate_image != (Image *) NULL) {\n                        DuplicateBlob(rotate_image,image);\n                        ReplaceImageInList(&image,rotate_image);\n                      }\n                    }\n                }\n\n              /* Allocate next image structure. */\n              AcquireNextImage(image_info,image);\n              image->depth=8;\n              if (image->next == (Image *) NULL)\n                goto Finish;\n              image=SyncNextImageInList(image);\n              image->columns=image->rows=1;\n              image->colors=0;\n              break;\n\n            case 0x1B:  /* Postscript l2 */\n              if(Rec.RecordLength>0x3C)\n                image=ExtractPostscript(image,image_info,\n                  TellBlob(image)+0x3C,   /* skip PS l2 header in the wpg */\n                  (ssize_t) Rec.RecordLength-0x3C,exception);\n              break;\n            }\n        }\n      break;\n\n    case 2:  /* WPG level 2 */\n      (void) memset(CTM,0,sizeof(CTM));\n      StartWPG.PosSizePrecision = 0;\n      while(!EOFBlob(image)) /* object parser loop */\n        {\n          (void) SeekBlob(image,Header.DataOffset,SEEK_SET);\n          if(EOFBlob(image))\n            break;\n\n          Rec2.Class=(i=ReadBlobByte(image));\n          if(i==EOF)\n            break;\n          Rec2.RecType=(i=ReadBlobByte(image));\n          if(i==EOF)\n            break;\n          Rd_WP_DWORD(image,&Rec2.Extension);\n          Rd_WP_DWORD(image,&Rec2.RecordLength);\n          if(EOFBlob(image))\n            break;\n\n          Header.DataOffset=TellBlob(image)+Rec2.RecordLength;\n\n          switch(Rec2.RecType)\n            {\n      case 1:\n              StartWPG.HorizontalUnits=ReadBlobLSBShort(image);\n              StartWPG.VerticalUnits=ReadBlobLSBShort(image);\n              StartWPG.PosSizePrecision=ReadBlobByte(image);\n              break;\n            case 0x0C:    /* Color palette */\n              WPG_Palette.StartIndex=ReadBlobLSBShort(image);\n              WPG_Palette.NumOfEntries=ReadBlobLSBShort(image);\n              if ((WPG_Palette.NumOfEntries-WPG_Palette.StartIndex) >\n                  (Rec2.RecordLength-2-2) / 3)\n                ThrowReaderException(CorruptImageError,\"InvalidColormapIndex\");\n              image->colors=WPG_Palette.NumOfEntries;\n              if (AcquireImageColormap(image,image->colors) == MagickFalse)\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              for (i=WPG_Palette.StartIndex;\n                   i < (int)WPG_Palette.NumOfEntries; i++)\n                {\n                  image->colormap[i].red=ScaleCharToQuantum((char)\n                    ReadBlobByte(image));\n                  image->colormap[i].green=ScaleCharToQuantum((char)\n                    ReadBlobByte(image));\n                  image->colormap[i].blue=ScaleCharToQuantum((char)\n                    ReadBlobByte(image));\n                  (void) ReadBlobByte(image);   /*Opacity??*/\n                }\n              break;\n            case 0x0E:\n              Bitmap2Header1.Width=ReadBlobLSBShort(image);\n              Bitmap2Header1.Height=ReadBlobLSBShort(image);\n              if ((Bitmap2Header1.Width == 0) || (Bitmap2Header1.Height == 0))\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              Bitmap2Header1.Depth=ReadBlobByte(image);\n              Bitmap2Header1.Compression=ReadBlobByte(image);\n\n              if(Bitmap2Header1.Compression > 1)\n                continue; /*Unknown compression method */\n              switch(Bitmap2Header1.Depth)\n                {\n                case 1:\n                  bpp=1;\n                  break;\n                case 2:\n                  bpp=2;\n                  break;\n                case 3:\n                  bpp=4;\n                  break;\n                case 4:\n                  bpp=8;\n                  break;\n                case 8:\n                  bpp=24;\n                  break;\n                default:\n                  continue;  /*Ignore raster with unknown depth*/\n                }\n              image->columns=Bitmap2Header1.Width;\n              image->rows=Bitmap2Header1.Height;\n              status=SetImageExtent(image,image->columns,image->rows);\n              if (status == MagickFalse)\n                break;\n              if ((image->colors == 0) && (bpp != 24))\n                {\n                  size_t\n                    one;\n\n                  one=1;\n                  image->colors=one << bpp;\n                  if (!AcquireImageColormap(image,image->colors))\n                    goto NoMemory;\n                }\n              else\n                {\n                  if(bpp < 24)\n                    if( image->colors<(one << bpp) && bpp!=24 )\n                      image->colormap=(PixelPacket *) ResizeQuantumMemory(\n                       image->colormap,(size_t) (one << bpp),\n                       sizeof(*image->colormap));\n                }\n\n\n              switch(Bitmap2Header1.Compression)\n                {\n                case 0:    /*Uncompressed raster*/\n                  {\n                    ldblk=(ssize_t) ((bpp*image->columns+7)/8);\n                    BImgBuff=(unsigned char *) AcquireQuantumMemory((size_t)\n                      ldblk+1,sizeof(*BImgBuff));\n                    if (BImgBuff == (unsigned char *) NULL)\n                      goto NoMemory;\n\n                    for(i=0; i< (ssize_t) image->rows; i++)\n                      {\n                        (void) ReadBlob(image,ldblk,BImgBuff);\n                        InsertRow(BImgBuff,i,image,bpp);\n                      }\n\n                    if(BImgBuff)\n                      BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);\n                    break;\n                  }\n                case 1:    /*RLE for WPG2 */\n                  {\n                    if( UnpackWPG2Raster(image,bpp) < 0)\n                      goto DecompressionFailed;\n                    break;\n                  }\n                }\n\n              if(CTM[0][0]<0 && !image_info->ping)\n                {    /*?? RotAngle=360-RotAngle;*/\n                  Image\n                    *flop_image;\n\n                  flop_image = FlopImage(image, exception);\n                  if (flop_image != (Image *) NULL) {\n                    DuplicateBlob(flop_image,image);\n                    ReplaceImageInList(&image,flop_image);\n                  }\n                  /* Try to change CTM according to Flip - I am not sure, must be checked.\n                     Tx(0,0)=-1;      Tx(1,0)=0;   Tx(2,0)=0;\n                     Tx(0,1)= 0;      Tx(1,1)=1;   Tx(2,1)=0;\n                     Tx(0,2)=(WPG._2Rect.X_ur+WPG._2Rect.X_ll);\n                     Tx(1,2)=0;   Tx(2,2)=1; */\n                }\n              if(CTM[1][1]<0 && !image_info->ping)\n                {    /*?? RotAngle=360-RotAngle;*/\n                  Image\n                    *flip_image;\n\n                  flip_image = FlipImage(image, exception);\n                  if (flip_image != (Image *) NULL) {\n                    DuplicateBlob(flip_image,image);\n                    ReplaceImageInList(&image,flip_image);\n                  }\n                  /* Try to change CTM according to Flip - I am not sure, must be checked.\n                     float_matrix Tx(3,3);\n                     Tx(0,0)= 1;   Tx(1,0)= 0;   Tx(2,0)=0;\n                     Tx(0,1)= 0;   Tx(1,1)=-1;   Tx(2,1)=0;\n                     Tx(0,2)= 0;   Tx(1,2)=(WPG._2Rect.Y_ur+WPG._2Rect.Y_ll);\n                     Tx(2,2)=1; */\n                }\n\n\n              /* Allocate next image structure. */\n              AcquireNextImage(image_info,image);\n              image->depth=8;\n              if (image->next == (Image *) NULL)\n                goto Finish;\n              image=SyncNextImageInList(image);\n              image->columns=image->rows=1;\n              image->colors=0;\n              break;\n\n            case 0x12:  /* Postscript WPG2*/\n        i=ReadBlobLSBShort(image);\n              if(Rec2.RecordLength > (unsigned int) i)\n                image=ExtractPostscript(image,image_info,\n                  TellBlob(image)+i,    /*skip PS header in the wpg2*/\n                  (ssize_t) (Rec2.RecordLength-i-2),exception);\n              break;\n\n      case 0x1B:          /*bitmap rectangle*/\n              WPG2Flags = LoadWPG2Flags(image,StartWPG.PosSizePrecision,NULL,&CTM);\n              (void) WPG2Flags;\n              break;\n            }\n        }\n\n      break;\n\n    default:\n      {\n         ThrowReaderException(CoderError,\"DataEncodingSchemeIsNotSupported\");\n      }\n   }\n\n Finish:\n  (void) CloseBlob(image);\n\n  {\n    Image\n      *p;\n\n    ssize_t\n      scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n    /*\n      Fix scene numbers.\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=(size_t) scene++;\n  }\n  if (image == (Image *) NULL)\n    ThrowReaderException(CorruptImageError,\n      \"ImageFileDoesNotContainAnyImageData\");\n  return(image);\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 501,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-1621",
    "code_before_change": "long Cluster::CreateBlockGroup(\n    long long start_offset,\n    long long size,\n    long long discard_padding)\n{\n    assert(m_entries);\n    assert(m_entries_size > 0);\n    assert(m_entries_count >= 0);\n    assert(m_entries_count < m_entries_size);\n \n    IMkvReader* const pReader = m_pSegment->m_pReader;\n    long long pos = start_offset;\n    const long long stop = start_offset + size;\n    long long prev = 1;  //nonce\n    long long next = 0;  //nonce\n    long long duration = -1;  //really, this is unsigned\n    long long bpos = -1;\n    long long bsize = -1;\n    while (pos < stop)\n    {\n        long len;\n        const long long id = ReadUInt(pReader, pos, len);\n        assert(id >= 0);  //TODO\n        assert((pos + len) <= stop);\n        pos += len;  //consume ID\n        const long long size = ReadUInt(pReader, pos, len);\n        assert(size >= 0);  //TODO\n        assert((pos + len) <= stop);\n        pos += len;  //consume size\n        if (id == 0x21) //Block ID\n        {\n            if (bpos < 0) //Block ID\n            {\n                bpos = pos;\n                bsize = size;\n            }\n        }\n        else if (id == 0x1B)  //Duration ID\n        {\n            assert(size <= 8);\n            duration = UnserializeUInt(pReader, pos, size);\n            assert(duration >= 0);  //TODO\n        }\n        else if (id == 0x7B)  //ReferenceBlock\n        {\n            assert(size <= 8);\n            const long size_ = static_cast<long>(size);\n            long long time;\n            long status = UnserializeInt(pReader, pos, size_, time);\n            assert(status == 0);\n            if (status != 0)\n                return -1;\n            if (time <= 0)  //see note above\n                prev = time;\n            else  //weird\n                next = time;\n        }\n        pos += size;  //consume payload\n        assert(pos <= stop);\n     }\n \n    assert(pos == stop);\n    assert(bpos >= 0);\n    assert(bsize >= 0);\n \n    const long idx = m_entries_count;\n    BlockEntry** const ppEntry = m_entries + idx;\n    BlockEntry*& pEntry = *ppEntry;\n    pEntry = new (std::nothrow) BlockGroup(\n                                  this,\n                                  idx,\n                                  bpos,\n                                  bsize,\n                                  prev,\n                                  next,\n                                  duration,\n                                  discard_padding);\n    if (pEntry == NULL)\n        return -1;  //generic error\n    BlockGroup* const p = static_cast<BlockGroup*>(pEntry);\n    const long status = p->Parse();\n    if (status == 0)  //success\n    {\n        ++m_entries_count;\n        return 0;\n    }\n    delete pEntry;\n    pEntry = 0;\n    return status;\n}\n",
    "code_after_change": "long Cluster::CreateBlockGroup(\n    const long status = Parse(pos, len);\n \n    if (status < 0) {  // error\n      pLast = NULL;\n      return status;\n     }\n \n    if (status > 0)  // no new block\n      break;\n  }\n \n",
    "cwe": [
      "CWE-119"
    ],
    "id": 502,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-2482",
    "code_before_change": "OMX_ERRORTYPE  omx_vdec::component_deinit(OMX_IN OMX_HANDLETYPE hComp)\n{\n (void) hComp;\n#ifdef _ANDROID_\n if (iDivXDrmDecrypt) {\n delete iDivXDrmDecrypt;\n        iDivXDrmDecrypt=NULL;\n }\n#endif //_ANDROID_\n\n unsigned i = 0;\n if (OMX_StateLoaded != m_state) {\n        DEBUG_PRINT_ERROR(\"WARNING:Rxd DeInit,OMX not in LOADED state %d\",\\\n                m_state);\n        DEBUG_PRINT_ERROR(\"Playback Ended - FAILED\");\n } else {\n        DEBUG_PRINT_HIGH(\"Playback Ended - PASSED\");\n }\n\n /*Check if the output buffers have to be cleaned up*/\n\n     if (m_out_mem_ptr) {\n         DEBUG_PRINT_LOW(\"Freeing the Output Memory\");\n         for (i = 0; i < drv_ctx.op_buf.actualcount; i++ ) {\n            free_output_buffer (&m_out_mem_ptr[i]);\n         }\n #ifdef _ANDROID_ICS_\n         memset(&native_buffer, 0, (sizeof(nativebuffer) * MAX_NUM_INPUT_OUTPUT_BUFFERS));\n#endif\n }\n\n /*Check if the input buffers have to be cleaned up*/\n\n     if (m_inp_mem_ptr || m_inp_heap_ptr) {\n         DEBUG_PRINT_LOW(\"Freeing the Input Memory\");\n         for (i = 0; i<drv_ctx.ip_buf.actualcount; i++ ) {\n            if (m_inp_mem_ptr)\n                free_input_buffer (i,&m_inp_mem_ptr[i]);\n            else\n                free_input_buffer (i,NULL);\n        }\n     }\n     free_input_buffer_header();\n     free_output_buffer_header();\n if (h264_scratch.pBuffer) {\n        free(h264_scratch.pBuffer);\n        h264_scratch.pBuffer = NULL;\n }\n\n if (h264_parser) {\n delete h264_parser;\n        h264_parser = NULL;\n }\n\n if (m_frame_parser.mutils) {\n        DEBUG_PRINT_LOW(\"Free utils parser\");\n delete (m_frame_parser.mutils);\n        m_frame_parser.mutils = NULL;\n }\n\n if (m_platform_list) {\n        free(m_platform_list);\n        m_platform_list = NULL;\n }\n if (m_vendor_config.pData) {\n        free(m_vendor_config.pData);\n        m_vendor_config.pData = NULL;\n }\n\n    m_ftb_q.m_size=0;\n    m_cmd_q.m_size=0;\n    m_etb_q.m_size=0;\n    m_ftb_q.m_read = m_ftb_q.m_write =0;\n    m_cmd_q.m_read = m_cmd_q.m_write =0;\n    m_etb_q.m_read = m_etb_q.m_write =0;\n#ifdef _ANDROID_\n if (m_debug_timestamp) {\n        m_timestamp_list.reset_ts_list();\n }\n#endif\n\n    DEBUG_PRINT_LOW(\"Calling VDEC_IOCTL_STOP_NEXT_MSG\");\n    DEBUG_PRINT_HIGH(\"Close the driver instance\");\n\n if (m_debug.infile) {\n        fclose(m_debug.infile);\n        m_debug.infile = NULL;\n }\n if (m_debug.outfile) {\n        fclose(m_debug.outfile);\n        m_debug.outfile = NULL;\n }\n#ifdef OUTPUT_EXTRADATA_LOG\n if (outputExtradataFile)\n        fclose (outputExtradataFile);\n#endif\n    DEBUG_PRINT_INFO(\"omx_vdec::component_deinit() complete\");\n return OMX_ErrorNone;\n}\n",
    "code_after_change": "OMX_ERRORTYPE  omx_vdec::component_deinit(OMX_IN OMX_HANDLETYPE hComp)\n{\n (void) hComp;\n#ifdef _ANDROID_\n if (iDivXDrmDecrypt) {\n delete iDivXDrmDecrypt;\n        iDivXDrmDecrypt=NULL;\n }\n#endif //_ANDROID_\n\n unsigned i = 0;\n if (OMX_StateLoaded != m_state) {\n        DEBUG_PRINT_ERROR(\"WARNING:Rxd DeInit,OMX not in LOADED state %d\",\\\n                m_state);\n        DEBUG_PRINT_ERROR(\"Playback Ended - FAILED\");\n } else {\n        DEBUG_PRINT_HIGH(\"Playback Ended - PASSED\");\n }\n\n /*Check if the output buffers have to be cleaned up*/\n\n     if (m_out_mem_ptr) {\n         DEBUG_PRINT_LOW(\"Freeing the Output Memory\");\n         for (i = 0; i < drv_ctx.op_buf.actualcount; i++ ) {\n            if (BITMASK_PRESENT(&m_out_bm_count, i)) {\n                BITMASK_CLEAR(&m_out_bm_count, i);\n                client_buffers.free_output_buffer (&m_out_mem_ptr[i]);\n            }\n\n            if (release_output_done()) {\n                break;\n            }\n         }\n #ifdef _ANDROID_ICS_\n         memset(&native_buffer, 0, (sizeof(nativebuffer) * MAX_NUM_INPUT_OUTPUT_BUFFERS));\n#endif\n }\n\n /*Check if the input buffers have to be cleaned up*/\n\n     if (m_inp_mem_ptr || m_inp_heap_ptr) {\n         DEBUG_PRINT_LOW(\"Freeing the Input Memory\");\n         for (i = 0; i<drv_ctx.ip_buf.actualcount; i++ ) {\n\n            if (BITMASK_PRESENT(&m_inp_bm_count, i)) {\n                BITMASK_CLEAR(&m_inp_bm_count, i);\n                if (m_inp_mem_ptr)\n                    free_input_buffer (i,&m_inp_mem_ptr[i]);\n                else\n                    free_input_buffer (i,NULL);\n            }\n\n            if (release_input_done()) {\n                break;\n            }\n       }\n     }\n     free_input_buffer_header();\n     free_output_buffer_header();\n if (h264_scratch.pBuffer) {\n        free(h264_scratch.pBuffer);\n        h264_scratch.pBuffer = NULL;\n }\n\n if (h264_parser) {\n delete h264_parser;\n        h264_parser = NULL;\n }\n\n if (m_frame_parser.mutils) {\n        DEBUG_PRINT_LOW(\"Free utils parser\");\n delete (m_frame_parser.mutils);\n        m_frame_parser.mutils = NULL;\n }\n\n if (m_platform_list) {\n        free(m_platform_list);\n        m_platform_list = NULL;\n }\n if (m_vendor_config.pData) {\n        free(m_vendor_config.pData);\n        m_vendor_config.pData = NULL;\n }\n\n    m_ftb_q.m_size=0;\n    m_cmd_q.m_size=0;\n    m_etb_q.m_size=0;\n    m_ftb_q.m_read = m_ftb_q.m_write =0;\n    m_cmd_q.m_read = m_cmd_q.m_write =0;\n    m_etb_q.m_read = m_etb_q.m_write =0;\n#ifdef _ANDROID_\n if (m_debug_timestamp) {\n        m_timestamp_list.reset_ts_list();\n }\n#endif\n\n    DEBUG_PRINT_LOW(\"Calling VDEC_IOCTL_STOP_NEXT_MSG\");\n    DEBUG_PRINT_HIGH(\"Close the driver instance\");\n\n if (m_debug.infile) {\n        fclose(m_debug.infile);\n        m_debug.infile = NULL;\n }\n if (m_debug.outfile) {\n        fclose(m_debug.outfile);\n        m_debug.outfile = NULL;\n }\n#ifdef OUTPUT_EXTRADATA_LOG\n if (outputExtradataFile)\n        fclose (outputExtradataFile);\n#endif\n    DEBUG_PRINT_INFO(\"omx_vdec::component_deinit() complete\");\n return OMX_ErrorNone;\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 504,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-2476",
    "code_before_change": "OMX_ERRORTYPE SoftAACEncoder2::internalSetParameter(\n        OMX_INDEXTYPE index, const OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamStandardComponentRole:\n {\n\n             const OMX_PARAM_COMPONENTROLETYPE *roleParams =\n                 (const OMX_PARAM_COMPONENTROLETYPE *)params;\n \n             if (strncmp((const char *)roleParams->cRole,\n                         \"audio_encoder.aac\",\n                         OMX_MAX_STRINGNAME_SIZE - 1)) {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioPortFormat:\n {\n\n             const OMX_AUDIO_PARAM_PORTFORMATTYPE *formatParams =\n                 (const OMX_AUDIO_PARAM_PORTFORMATTYPE *)params;\n \n             if (formatParams->nPortIndex > 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n if (formatParams->nIndex > 0) {\n return OMX_ErrorNoMore;\n }\n\n if ((formatParams->nPortIndex == 0\n && formatParams->eEncoding != OMX_AUDIO_CodingPCM)\n || (formatParams->nPortIndex == 1\n && formatParams->eEncoding != OMX_AUDIO_CodingAAC)) {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioAac:\n {\n\n             OMX_AUDIO_PARAM_AACPROFILETYPE *aacParams =\n                 (OMX_AUDIO_PARAM_AACPROFILETYPE *)params;\n \n             if (aacParams->nPortIndex != 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n            mBitRate = aacParams->nBitRate;\n            mNumChannels = aacParams->nChannels;\n            mSampleRate = aacParams->nSampleRate;\n if (aacParams->eAACProfile != OMX_AUDIO_AACObjectNull) {\n                mAACProfile = aacParams->eAACProfile;\n }\n\n if (!(aacParams->nAACtools & OMX_AUDIO_AACToolAndroidSSBR)\n && !(aacParams->nAACtools & OMX_AUDIO_AACToolAndroidDSBR)) {\n                mSBRMode = 0;\n                mSBRRatio = 0;\n } else if ((aacParams->nAACtools & OMX_AUDIO_AACToolAndroidSSBR)\n && !(aacParams->nAACtools & OMX_AUDIO_AACToolAndroidDSBR)) {\n                mSBRMode = 1;\n                mSBRRatio = 1;\n } else if (!(aacParams->nAACtools & OMX_AUDIO_AACToolAndroidSSBR)\n && (aacParams->nAACtools & OMX_AUDIO_AACToolAndroidDSBR)) {\n                mSBRMode = 1;\n                mSBRRatio = 2;\n } else {\n                mSBRMode = -1; // codec default sbr mode\n                mSBRRatio = 0;\n }\n\n if (setAudioParams() != OK) {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioPcm:\n {\n\n             OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =\n                 (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n             if (pcmParams->nPortIndex != 0) {\n                 return OMX_ErrorUndefined;\n             }\n\n            mNumChannels = pcmParams->nChannels;\n            mSampleRate = pcmParams->nSamplingRate;\n if (setAudioParams() != OK) {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::internalSetParameter(index, params);\n }\n}\n",
    "code_after_change": "OMX_ERRORTYPE SoftAACEncoder2::internalSetParameter(\n        OMX_INDEXTYPE index, const OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamStandardComponentRole:\n {\n\n             const OMX_PARAM_COMPONENTROLETYPE *roleParams =\n                 (const OMX_PARAM_COMPONENTROLETYPE *)params;\n \n            if (!isValidOMXParam(roleParams)) {\n                return OMX_ErrorBadParameter;\n            }\n\n             if (strncmp((const char *)roleParams->cRole,\n                         \"audio_encoder.aac\",\n                         OMX_MAX_STRINGNAME_SIZE - 1)) {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioPortFormat:\n {\n\n             const OMX_AUDIO_PARAM_PORTFORMATTYPE *formatParams =\n                 (const OMX_AUDIO_PARAM_PORTFORMATTYPE *)params;\n \n            if (!isValidOMXParam(formatParams)) {\n                return OMX_ErrorBadParameter;\n            }\n\n             if (formatParams->nPortIndex > 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n if (formatParams->nIndex > 0) {\n return OMX_ErrorNoMore;\n }\n\n if ((formatParams->nPortIndex == 0\n && formatParams->eEncoding != OMX_AUDIO_CodingPCM)\n || (formatParams->nPortIndex == 1\n && formatParams->eEncoding != OMX_AUDIO_CodingAAC)) {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioAac:\n {\n\n             OMX_AUDIO_PARAM_AACPROFILETYPE *aacParams =\n                 (OMX_AUDIO_PARAM_AACPROFILETYPE *)params;\n \n            if (!isValidOMXParam(aacParams)) {\n                return OMX_ErrorBadParameter;\n            }\n\n             if (aacParams->nPortIndex != 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n            mBitRate = aacParams->nBitRate;\n            mNumChannels = aacParams->nChannels;\n            mSampleRate = aacParams->nSampleRate;\n if (aacParams->eAACProfile != OMX_AUDIO_AACObjectNull) {\n                mAACProfile = aacParams->eAACProfile;\n }\n\n if (!(aacParams->nAACtools & OMX_AUDIO_AACToolAndroidSSBR)\n && !(aacParams->nAACtools & OMX_AUDIO_AACToolAndroidDSBR)) {\n                mSBRMode = 0;\n                mSBRRatio = 0;\n } else if ((aacParams->nAACtools & OMX_AUDIO_AACToolAndroidSSBR)\n && !(aacParams->nAACtools & OMX_AUDIO_AACToolAndroidDSBR)) {\n                mSBRMode = 1;\n                mSBRRatio = 1;\n } else if (!(aacParams->nAACtools & OMX_AUDIO_AACToolAndroidSSBR)\n && (aacParams->nAACtools & OMX_AUDIO_AACToolAndroidDSBR)) {\n                mSBRMode = 1;\n                mSBRRatio = 2;\n } else {\n                mSBRMode = -1; // codec default sbr mode\n                mSBRRatio = 0;\n }\n\n if (setAudioParams() != OK) {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioPcm:\n {\n\n             OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =\n                 (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n            if (!isValidOMXParam(pcmParams)) {\n                return OMX_ErrorBadParameter;\n            }\n\n             if (pcmParams->nPortIndex != 0) {\n                 return OMX_ErrorUndefined;\n             }\n\n            mNumChannels = pcmParams->nChannels;\n            mSampleRate = pcmParams->nSamplingRate;\n if (setAudioParams() != OK) {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::internalSetParameter(index, params);\n }\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 506,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2017-1000494",
    "code_before_change": "ParseNameValue(const char * buffer, int bufsize,\n                struct NameValueParserData * data)\n {\n \tstruct xmlparser parser;\n\tdata->l_head = NULL;\n\tdata->portListing = NULL;\n\tdata->portListingLength = 0;\n \t/* init xmlparser object */\n \tparser.xmlstart = buffer;\n \tparser.xmlsize = bufsize;\n\tparser.data = data;\n\tparser.starteltfunc = NameValueParserStartElt;\n\tparser.endeltfunc = NameValueParserEndElt;\n\tparser.datafunc = NameValueParserGetData;\n\tparser.attfunc = 0;\n\tparsexml(&parser);\n}\n",
    "code_after_change": "ParseNameValue(const char * buffer, int bufsize,\n                struct NameValueParserData * data)\n {\n \tstruct xmlparser parser;\n\tmemset(data, 0, sizeof(struct NameValueParserData));\n \t/* init xmlparser object */\n \tparser.xmlstart = buffer;\n \tparser.xmlsize = bufsize;\n\tparser.data = data;\n\tparser.starteltfunc = NameValueParserStartElt;\n\tparser.endeltfunc = NameValueParserEndElt;\n\tparser.datafunc = NameValueParserGetData;\n\tparser.attfunc = 0;\n\tparsexml(&parser);\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 508,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-1683",
    "code_before_change": "exsltFuncRegisterImportFunc (exsltFuncFunctionData *data,\n\t\t\t     exsltFuncImportRegData *ch,\n\t\t\t     const xmlChar *URI, const xmlChar *name,\n\t\t\t     ATTRIBUTE_UNUSED const xmlChar *ignored) {\n    exsltFuncFunctionData *func=NULL;\n\n    if ((data == NULL) || (ch == NULL) || (URI == NULL) || (name == NULL))\n            return;\n\n    if (ch->ctxt == NULL || ch->hash == NULL)\n\treturn;\n\n    /* Check if already present */\n     func = (exsltFuncFunctionData*)xmlHashLookup2(ch->hash, URI, name);\n     if (func == NULL) {\t\t/* Not yet present - copy it in */\n \tfunc = exsltFuncNewFunctionData();\n \tmemcpy(func, data, sizeof(exsltFuncFunctionData));\n \tif (xmlHashAddEntry2(ch->hash, URI, name, func) < 0) {\n \t    xsltGenericError(xsltGenericErrorContext,\n\t\t    \"Failed to register function {%s}%s\\n\",\n\t\t    URI, name);\n\t} else {\t\t/* Do the registration */\n\t    xsltGenericDebug(xsltGenericDebugContext,\n\t            \"exsltFuncRegisterImportFunc: register {%s}%s\\n\",\n\t\t    URI, name);\n\t    xsltRegisterExtFunction(ch->ctxt, name, URI,\n\t\t    exsltFuncFunctionFunction);\n\t}\n    }\n}\n",
    "code_after_change": "exsltFuncRegisterImportFunc (exsltFuncFunctionData *data,\n\t\t\t     exsltFuncImportRegData *ch,\n\t\t\t     const xmlChar *URI, const xmlChar *name,\n\t\t\t     ATTRIBUTE_UNUSED const xmlChar *ignored) {\n    exsltFuncFunctionData *func=NULL;\n\n    if ((data == NULL) || (ch == NULL) || (URI == NULL) || (name == NULL))\n            return;\n\n    if (ch->ctxt == NULL || ch->hash == NULL)\n\treturn;\n\n    /* Check if already present */\n     func = (exsltFuncFunctionData*)xmlHashLookup2(ch->hash, URI, name);\n     if (func == NULL) {\t\t/* Not yet present - copy it in */\n \tfunc = exsltFuncNewFunctionData();\n        if (func == NULL)\n            return;\n \tmemcpy(func, data, sizeof(exsltFuncFunctionData));\n \tif (xmlHashAddEntry2(ch->hash, URI, name, func) < 0) {\n \t    xsltGenericError(xsltGenericErrorContext,\n\t\t    \"Failed to register function {%s}%s\\n\",\n\t\t    URI, name);\n\t} else {\t\t/* Do the registration */\n\t    xsltGenericDebug(xsltGenericDebugContext,\n\t            \"exsltFuncRegisterImportFunc: register {%s}%s\\n\",\n\t\t    URI, name);\n\t    xsltRegisterExtFunction(ch->ctxt, name, URI,\n\t\t    exsltFuncFunctionFunction);\n\t}\n    }\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 509,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-4564",
    "code_before_change": "MagickExport void GetDrawInfo(const ImageInfo *image_info,DrawInfo *draw_info)\n{\n  const char\n    *option;\n\n  ExceptionInfo\n    *exception;\n\n  ImageInfo\n    *clone_info;\n\n  /*\n    Initialize draw attributes.\n  */\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(draw_info != (DrawInfo *) NULL);\n  (void) ResetMagickMemory(draw_info,0,sizeof(*draw_info));\n  clone_info=CloneImageInfo(image_info);\n  GetAffineMatrix(&draw_info->affine);\n  exception=AcquireExceptionInfo();\n  (void) QueryColorCompliance(\"#000F\",AllCompliance,&draw_info->fill,\n    exception);\n  (void) QueryColorCompliance(\"#0000\",AllCompliance,&draw_info->stroke,\n    exception);\n  draw_info->stroke_width=1.0;\n  draw_info->alpha=OpaqueAlpha;\n  draw_info->fill_rule=EvenOddRule;\n  draw_info->linecap=ButtCap;\n  draw_info->linejoin=MiterJoin;\n   draw_info->miterlimit=10;\n   draw_info->decorate=NoDecoration;\n   draw_info->pointsize=12.0;\n  draw_info->undercolor.alpha=(Quantum) TransparentAlpha;\n   draw_info->compose=OverCompositeOp;\n   draw_info->render=MagickTrue;\n   draw_info->debug=IsEventLogging();\n  draw_info->stroke_antialias=clone_info->antialias;\n  if (clone_info->font != (char *) NULL)\n    draw_info->font=AcquireString(clone_info->font);\n  if (clone_info->density != (char *) NULL)\n    draw_info->density=AcquireString(clone_info->density);\n  draw_info->text_antialias=clone_info->antialias;\n  if (clone_info->pointsize != 0.0)\n    draw_info->pointsize=clone_info->pointsize;\n  draw_info->border_color=clone_info->border_color;\n  if (clone_info->server_name != (char *) NULL)\n    draw_info->server_name=AcquireString(clone_info->server_name);\n  option=GetImageOption(clone_info,\"direction\");\n  if (option != (const char *) NULL)\n    draw_info->direction=(DirectionType) ParseCommandOption(\n      MagickDirectionOptions,MagickFalse,option);\n  else\n    draw_info->direction=UndefinedDirection;\n  option=GetImageOption(clone_info,\"encoding\");\n  if (option != (const char *) NULL)\n    (void) CloneString(&draw_info->encoding,option);\n  option=GetImageOption(clone_info,\"family\");\n  if (option != (const char *) NULL)\n    (void) CloneString(&draw_info->family,option);\n  option=GetImageOption(clone_info,\"fill\");\n  if (option != (const char *) NULL)\n    (void) QueryColorCompliance(option,AllCompliance,&draw_info->fill,\n      exception);\n  option=GetImageOption(clone_info,\"gravity\");\n  if (option != (const char *) NULL)\n    draw_info->gravity=(GravityType) ParseCommandOption(MagickGravityOptions,\n      MagickFalse,option);\n  option=GetImageOption(clone_info,\"interline-spacing\");\n  if (option != (const char *) NULL)\n    draw_info->interline_spacing=StringToDouble(option,(char **) NULL);\n  option=GetImageOption(clone_info,\"interword-spacing\");\n  if (option != (const char *) NULL)\n    draw_info->interword_spacing=StringToDouble(option,(char **) NULL);\n  option=GetImageOption(clone_info,\"kerning\");\n  if (option != (const char *) NULL)\n    draw_info->kerning=StringToDouble(option,(char **) NULL);\n  option=GetImageOption(clone_info,\"stroke\");\n  if (option != (const char *) NULL)\n    (void) QueryColorCompliance(option,AllCompliance,&draw_info->stroke,\n      exception);\n  option=GetImageOption(clone_info,\"strokewidth\");\n  if (option != (const char *) NULL)\n    draw_info->stroke_width=StringToDouble(option,(char **) NULL);\n  option=GetImageOption(clone_info,\"style\");\n  if (option != (const char *) NULL)\n    draw_info->style=(StyleType) ParseCommandOption(MagickStyleOptions,\n      MagickFalse,option);\n  option=GetImageOption(clone_info,\"undercolor\");\n  if (option != (const char *) NULL)\n    (void) QueryColorCompliance(option,AllCompliance,&draw_info->undercolor,\n      exception);\n  option=GetImageOption(clone_info,\"weight\");\n  if (option != (const char *) NULL)\n    {\n      ssize_t\n        weight;\n \n       weight=ParseCommandOption(MagickWeightOptions,MagickFalse,option);\n       if (weight == -1)\n        weight=StringToUnsignedLong(option);\n       draw_info->weight=(size_t) weight;\n     }\n   exception=DestroyExceptionInfo(exception);\n  draw_info->signature=MagickCoreSignature;\n  clone_info=DestroyImageInfo(clone_info);\n}\n",
    "code_after_change": "MagickExport void GetDrawInfo(const ImageInfo *image_info,DrawInfo *draw_info)\n{\n  const char\n    *option;\n\n  ExceptionInfo\n    *exception;\n\n  ImageInfo\n    *clone_info;\n\n  /*\n    Initialize draw attributes.\n  */\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(draw_info != (DrawInfo *) NULL);\n  (void) ResetMagickMemory(draw_info,0,sizeof(*draw_info));\n  clone_info=CloneImageInfo(image_info);\n  GetAffineMatrix(&draw_info->affine);\n  exception=AcquireExceptionInfo();\n  (void) QueryColorCompliance(\"#000F\",AllCompliance,&draw_info->fill,\n    exception);\n  (void) QueryColorCompliance(\"#0000\",AllCompliance,&draw_info->stroke,\n    exception);\n  draw_info->stroke_width=1.0;\n  draw_info->alpha=OpaqueAlpha;\n  draw_info->fill_rule=EvenOddRule;\n  draw_info->linecap=ButtCap;\n  draw_info->linejoin=MiterJoin;\n   draw_info->miterlimit=10;\n   draw_info->decorate=NoDecoration;\n   draw_info->pointsize=12.0;\n  draw_info->undercolor.alpha=(MagickRealType) TransparentAlpha;\n   draw_info->compose=OverCompositeOp;\n   draw_info->render=MagickTrue;\n   draw_info->debug=IsEventLogging();\n  draw_info->stroke_antialias=clone_info->antialias;\n  if (clone_info->font != (char *) NULL)\n    draw_info->font=AcquireString(clone_info->font);\n  if (clone_info->density != (char *) NULL)\n    draw_info->density=AcquireString(clone_info->density);\n  draw_info->text_antialias=clone_info->antialias;\n  if (clone_info->pointsize != 0.0)\n    draw_info->pointsize=clone_info->pointsize;\n  draw_info->border_color=clone_info->border_color;\n  if (clone_info->server_name != (char *) NULL)\n    draw_info->server_name=AcquireString(clone_info->server_name);\n  option=GetImageOption(clone_info,\"direction\");\n  if (option != (const char *) NULL)\n    draw_info->direction=(DirectionType) ParseCommandOption(\n      MagickDirectionOptions,MagickFalse,option);\n  else\n    draw_info->direction=UndefinedDirection;\n  option=GetImageOption(clone_info,\"encoding\");\n  if (option != (const char *) NULL)\n    (void) CloneString(&draw_info->encoding,option);\n  option=GetImageOption(clone_info,\"family\");\n  if (option != (const char *) NULL)\n    (void) CloneString(&draw_info->family,option);\n  option=GetImageOption(clone_info,\"fill\");\n  if (option != (const char *) NULL)\n    (void) QueryColorCompliance(option,AllCompliance,&draw_info->fill,\n      exception);\n  option=GetImageOption(clone_info,\"gravity\");\n  if (option != (const char *) NULL)\n    draw_info->gravity=(GravityType) ParseCommandOption(MagickGravityOptions,\n      MagickFalse,option);\n  option=GetImageOption(clone_info,\"interline-spacing\");\n  if (option != (const char *) NULL)\n    draw_info->interline_spacing=StringToDouble(option,(char **) NULL);\n  option=GetImageOption(clone_info,\"interword-spacing\");\n  if (option != (const char *) NULL)\n    draw_info->interword_spacing=StringToDouble(option,(char **) NULL);\n  option=GetImageOption(clone_info,\"kerning\");\n  if (option != (const char *) NULL)\n    draw_info->kerning=StringToDouble(option,(char **) NULL);\n  option=GetImageOption(clone_info,\"stroke\");\n  if (option != (const char *) NULL)\n    (void) QueryColorCompliance(option,AllCompliance,&draw_info->stroke,\n      exception);\n  option=GetImageOption(clone_info,\"strokewidth\");\n  if (option != (const char *) NULL)\n    draw_info->stroke_width=StringToDouble(option,(char **) NULL);\n  option=GetImageOption(clone_info,\"style\");\n  if (option != (const char *) NULL)\n    draw_info->style=(StyleType) ParseCommandOption(MagickStyleOptions,\n      MagickFalse,option);\n  option=GetImageOption(clone_info,\"undercolor\");\n  if (option != (const char *) NULL)\n    (void) QueryColorCompliance(option,AllCompliance,&draw_info->undercolor,\n      exception);\n  option=GetImageOption(clone_info,\"weight\");\n  if (option != (const char *) NULL)\n    {\n      ssize_t\n        weight;\n \n       weight=ParseCommandOption(MagickWeightOptions,MagickFalse,option);\n       if (weight == -1)\n        weight=(ssize_t) StringToUnsignedLong(option);\n       draw_info->weight=(size_t) weight;\n     }\n   exception=DestroyExceptionInfo(exception);\n  draw_info->signature=MagickCoreSignature;\n  clone_info=DestroyImageInfo(clone_info);\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 515,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-1621",
    "code_before_change": "CuePoint::~CuePoint()\n{\n    delete[] m_track_positions;\n}\n",
    "code_after_change": "CuePoint::~CuePoint()\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 516,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2011-3088",
    "code_before_change": "  SessionRestoreImpl(Profile* profile,\n                     Browser* browser,\n                     bool synchronous,\n                     bool clobber_existing_tab,\n                     bool always_create_tabbed_browser,\n                     const std::vector<GURL>& urls_to_open)\n      : profile_(profile),\n        browser_(browser),\n        synchronous_(synchronous),\n        clobber_existing_tab_(clobber_existing_tab),\n        always_create_tabbed_browser_(always_create_tabbed_browser),\n         urls_to_open_(urls_to_open),\n         restore_started_(base::TimeTicks::Now()),\n         browser_shown_(false) {\n    if (profiles_getting_restored == NULL)\n      profiles_getting_restored = new std::set<const Profile*>();\n \n    CHECK(profiles_getting_restored->find(profile) ==\n          profiles_getting_restored->end());\n \n    profiles_getting_restored->insert(profile);\n    g_browser_process->AddRefModule();\n  }\n",
    "code_after_change": "  SessionRestoreImpl(Profile* profile,\n                     Browser* browser,\n                     bool synchronous,\n                     bool clobber_existing_tab,\n                     bool always_create_tabbed_browser,\n                     const std::vector<GURL>& urls_to_open)\n      : profile_(profile),\n        browser_(browser),\n        synchronous_(synchronous),\n        clobber_existing_tab_(clobber_existing_tab),\n        always_create_tabbed_browser_(always_create_tabbed_browser),\n         urls_to_open_(urls_to_open),\n         restore_started_(base::TimeTicks::Now()),\n         browser_shown_(false) {\n \n    // Iterate the active session restorers to find if there is a\n    // SessionRestoreImpl referring the same profile. This should not happen but\n    // for some reason it happens still. TODO(marja): figure out why.\n    if (active_session_restorers == NULL)\n      active_session_restorers = new std::set<SessionRestoreImpl*>();\n\n    std::set<SessionRestoreImpl*>::const_iterator it;\n    for (it = active_session_restorers->begin();\n         it != active_session_restorers->end(); ++it) {\n      if ((*it)->profile_ == profile)\n        break;\n    }\n    DCHECK(it == active_session_restorers->end());\n\n    active_session_restorers->insert(this);\n \n    g_browser_process->AddRefModule();\n  }\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 519,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-5199",
    "code_before_change": "  void InitPrefMembers() {\n    settings_->InitPrefMembers();\n  }\n",
    "code_after_change": "  void InitPrefMembers() {\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 520,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2017-14727",
    "code_before_change": " logger_get_mask_expanded (struct t_gui_buffer *buffer, const char *mask)\n {\n    char *mask2, *mask_decoded, *mask_decoded2, *mask_decoded3, *mask_decoded4;\n    char *mask_decoded5;\n     const char *dir_separator;\n     int length;\n     time_t seconds;\n     struct tm *date_tmp;\n \n     mask2 = NULL;\n    mask_decoded = NULL;\n    mask_decoded2 = NULL;\n    mask_decoded3 = NULL;\n    mask_decoded4 = NULL;\n    mask_decoded5 = NULL;\n \n     dir_separator = weechat_info_get (\"dir_separator\", \"\");\n     if (!dir_separator)\n         return NULL;\n \n     /*\n      * we first replace directory separator (commonly '/') by \\01 because\n      * buffer mask can contain this char, and will be replaced by replacement\n      * char ('_' by default)\n      */\n    mask2 = weechat_string_replace (mask, dir_separator, \"\\01\");\n    if (!mask2)\n         goto end;\n \n    mask_decoded = weechat_buffer_string_replace_local_var (buffer, mask2);\n    if (!mask_decoded)\n         goto end;\n \n    mask_decoded2 = weechat_string_replace (mask_decoded,\n                                            dir_separator,\n                                            weechat_config_string (logger_config_file_replacement_char));\n    if (!mask_decoded2)\n         goto end;\n \n #ifdef __CYGWIN__\n    mask_decoded3 = weechat_string_replace (mask_decoded2, \"\\\\\",\n                                            weechat_config_string (logger_config_file_replacement_char));\n #else\n    mask_decoded3 = strdup (mask_decoded2);\n #endif /* __CYGWIN__ */\n    if (!mask_decoded3)\n         goto end;\n \n     /* restore directory separator */\n    mask_decoded4 = weechat_string_replace (mask_decoded3,\n                                            \"\\01\", dir_separator);\n    if (!mask_decoded4)\n        goto end;\n    /* replace date/time specifiers in mask */\n    length = strlen (mask_decoded4) + 256 + 1;\n    mask_decoded5 = malloc (length);\n    if (!mask_decoded5)\n         goto end;\n    seconds = time (NULL);\n    date_tmp = localtime (&seconds);\n    mask_decoded5[0] = '\\0';\n    strftime (mask_decoded5, length - 1, mask_decoded4, date_tmp);\n \n     /* convert to lower case? */\n     if (weechat_config_boolean (logger_config_file_name_lower_case))\n        weechat_string_tolower (mask_decoded5);\n \n     if (weechat_logger_plugin->debug)\n     {\n        weechat_printf_date_tags (NULL, 0, \"no_log\",\n                                  \"%s: buffer = \\\"%s\\\", mask = \\\"%s\\\", \"\n                                   \"decoded mask = \\\"%s\\\"\",\n                                   LOGGER_PLUGIN_NAME,\n                                   weechat_buffer_get_string (buffer, \"name\"),\n                                  mask, mask_decoded5);\n     }\n \n end:\n     if (mask2)\n         free (mask2);\n    if (mask_decoded)\n        free (mask_decoded);\n    if (mask_decoded2)\n        free (mask_decoded2);\n    if (mask_decoded3)\n        free (mask_decoded3);\n    if (mask_decoded4)\n        free (mask_decoded4);\n    return mask_decoded5;\n }\n",
    "code_after_change": " logger_get_mask_expanded (struct t_gui_buffer *buffer, const char *mask)\n {\n    char *mask2, *mask3, *mask4, *mask5, *mask6, *mask7;\n     const char *dir_separator;\n     int length;\n     time_t seconds;\n     struct tm *date_tmp;\n \n     mask2 = NULL;\n    mask3 = NULL;\n    mask4 = NULL;\n    mask5 = NULL;\n    mask6 = NULL;\n    mask7 = NULL;\n \n     dir_separator = weechat_info_get (\"dir_separator\", \"\");\n     if (!dir_separator)\n         return NULL;\n \n    /* replace date/time specifiers in mask */\n    length = strlen (mask) + 256 + 1;\n    mask2 = malloc (length);\n    if (!mask2)\n        goto end;\n    seconds = time (NULL);\n    date_tmp = localtime (&seconds);\n    mask2[0] = '\\0';\n    if (strftime (mask2, length - 1, mask, date_tmp) == 0)\n        mask2[0] = '\\0';\n\n     /*\n      * we first replace directory separator (commonly '/') by \\01 because\n      * buffer mask can contain this char, and will be replaced by replacement\n      * char ('_' by default)\n      */\n    mask3 = weechat_string_replace (mask2, dir_separator, \"\\01\");\n    if (!mask3)\n         goto end;\n \n    mask4 = weechat_buffer_string_replace_local_var (buffer, mask3);\n    if (!mask4)\n         goto end;\n \n    mask5 = weechat_string_replace (mask4,\n                                    dir_separator,\n                                    weechat_config_string (logger_config_file_replacement_char));\n    if (!mask5)\n         goto end;\n \n #ifdef __CYGWIN__\n    mask6 = weechat_string_replace (mask5, \"\\\\\",\n                                    weechat_config_string (logger_config_file_replacement_char));\n #else\n    mask6 = strdup (mask5);\n #endif /* __CYGWIN__ */\n    if (!mask6)\n         goto end;\n \n     /* restore directory separator */\n    mask7 = weechat_string_replace (mask6,\n                                    \"\\01\", dir_separator);\n    if (!mask7)\n         goto end;\n \n     /* convert to lower case? */\n     if (weechat_config_boolean (logger_config_file_name_lower_case))\n        weechat_string_tolower (mask7);\n \n     if (weechat_logger_plugin->debug)\n     {\n        weechat_printf_date_tags (NULL, 0, \"no_log\",\n                                  \"%s: buffer = \\\"%s\\\", mask = \\\"%s\\\", \"\n                                   \"decoded mask = \\\"%s\\\"\",\n                                   LOGGER_PLUGIN_NAME,\n                                   weechat_buffer_get_string (buffer, \"name\"),\n                                  mask, mask7);\n     }\n \n end:\n     if (mask2)\n         free (mask2);\n    if (mask3)\n        free (mask3);\n    if (mask4)\n        free (mask4);\n    if (mask5)\n        free (mask5);\n    if (mask6)\n        free (mask6);\n\n    return mask7;\n }\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 532,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2017-0543",
    "code_before_change": "WORD32 ih264d_start_of_pic(dec_struct_t *ps_dec,\n                         WORD32 i4_poc,\n pocstruct_t *ps_temp_poc,\n                         UWORD16 u2_frame_num,\n dec_pic_params_t *ps_pps)\n{\n pocstruct_t *ps_prev_poc = &ps_dec->s_cur_pic_poc;\n pocstruct_t *ps_cur_poc = ps_temp_poc;\n\n pic_buffer_t *pic_buf;\n\n ivd_video_decode_op_t * ps_dec_output =\n (ivd_video_decode_op_t *)ps_dec->pv_dec_out;\n dec_slice_params_t *ps_cur_slice = ps_dec->ps_cur_slice;\n dec_seq_params_t *ps_seq = ps_pps->ps_sps;\n    UWORD8 u1_bottom_field_flag = ps_cur_slice->u1_bottom_field_flag;\n    UWORD8 u1_field_pic_flag = ps_cur_slice->u1_field_pic_flag;\n /* high profile related declarations */\n high_profile_tools_t s_high_profile;\n    WORD32 ret;\n\n    H264_MUTEX_LOCK(&ps_dec->process_disp_mutex);\n\n    ps_prev_poc->i4_pic_order_cnt_lsb = ps_cur_poc->i4_pic_order_cnt_lsb;\n    ps_prev_poc->i4_pic_order_cnt_msb = ps_cur_poc->i4_pic_order_cnt_msb;\n    ps_prev_poc->i4_delta_pic_order_cnt_bottom =\n                    ps_cur_poc->i4_delta_pic_order_cnt_bottom;\n    ps_prev_poc->i4_delta_pic_order_cnt[0] =\n                    ps_cur_poc->i4_delta_pic_order_cnt[0];\n    ps_prev_poc->i4_delta_pic_order_cnt[1] =\n                    ps_cur_poc->i4_delta_pic_order_cnt[1];\n    ps_prev_poc->u1_bot_field = ps_dec->ps_cur_slice->u1_bottom_field_flag;\n    ps_prev_poc->i4_prev_frame_num_ofst = ps_cur_poc->i4_prev_frame_num_ofst;\n    ps_prev_poc->u2_frame_num = u2_frame_num;\n    ps_dec->i1_prev_mb_qp_delta = 0;\n    ps_dec->i1_next_ctxt_idx = 0;\n\n\n    ps_dec->u4_nmb_deblk = 0;\n if(ps_dec->u4_num_cores == 1)\n       ps_dec->u4_nmb_deblk = 1;\n\n\n\n if(ps_seq->u1_mb_aff_flag == 1)\n {\n        ps_dec->u4_nmb_deblk = 0;\n if(ps_dec->u4_num_cores > 2)\n            ps_dec->u4_num_cores = 2;\n }\n\n        ps_dec->u4_use_intrapred_line_copy = 0;\n\n\n\n if (ps_seq->u1_mb_aff_flag == 0)\n {\n        ps_dec->u4_use_intrapred_line_copy = 1;\n }\n\n    ps_dec->u4_app_disable_deblk_frm = 0;\n /* If degrade is enabled, set the degrade flags appropriately */\n if(ps_dec->i4_degrade_type && ps_dec->i4_degrade_pics)\n {\n        WORD32 degrade_pic;\n        ps_dec->i4_degrade_pic_cnt++;\n        degrade_pic = 0;\n\n /* If degrade is to be done in all frames, then do not check further */\n switch(ps_dec->i4_degrade_pics)\n {\n case 4:\n {\n                degrade_pic = 1;\n break;\n }\n case 3:\n {\n if(ps_cur_slice->u1_slice_type != I_SLICE)\n                    degrade_pic = 1;\n\n break;\n }\n case 2:\n {\n\n /* If pic count hits non-degrade interval or it is an islice, then do not degrade */\n if((ps_cur_slice->u1_slice_type != I_SLICE)\n && (ps_dec->i4_degrade_pic_cnt\n != ps_dec->i4_nondegrade_interval))\n                    degrade_pic = 1;\n\n break;\n }\n case 1:\n {\n /* Check if the current picture is non-ref */\n if(0 == ps_cur_slice->u1_nal_ref_idc)\n {\n                    degrade_pic = 1;\n }\n break;\n }\n\n }\n if(degrade_pic)\n {\n if(ps_dec->i4_degrade_type & 0x2)\n                ps_dec->u4_app_disable_deblk_frm = 1;\n\n /* MC degrading is done only for non-ref pictures */\n if(0 == ps_cur_slice->u1_nal_ref_idc)\n {\n if(ps_dec->i4_degrade_type & 0x4)\n                    ps_dec->i4_mv_frac_mask = 0;\n\n if(ps_dec->i4_degrade_type & 0x8)\n                    ps_dec->i4_mv_frac_mask = 0;\n }\n }\n else\n            ps_dec->i4_degrade_pic_cnt = 0;\n }\n\n {\n dec_err_status_t * ps_err = ps_dec->ps_dec_err_status;\n if(ps_dec->u1_sl_typ_5_9\n && ((ps_cur_slice->u1_slice_type == I_SLICE)\n || (ps_cur_slice->u1_slice_type\n == SI_SLICE)))\n            ps_err->u1_cur_pic_type = PIC_TYPE_I;\n else\n            ps_err->u1_cur_pic_type = PIC_TYPE_UNKNOWN;\n\n if(ps_err->u1_pic_aud_i == PIC_TYPE_I)\n {\n            ps_err->u1_cur_pic_type = PIC_TYPE_I;\n            ps_err->u1_pic_aud_i = PIC_TYPE_UNKNOWN;\n }\n\n if(ps_cur_slice->u1_nal_unit_type == IDR_SLICE_NAL)\n {\n if(ps_err->u1_err_flag)\n                ih264d_reset_ref_bufs(ps_dec->ps_dpb_mgr);\n            ps_err->u1_err_flag = ACCEPT_ALL_PICS;\n }\n }\n\n if(ps_dec->u1_init_dec_flag && ps_dec->s_prev_seq_params.u1_eoseq_pending)\n {\n /* Reset the decoder picture buffers */\n        WORD32 j;\n for(j = 0; j < MAX_DISP_BUFS_NEW; j++)\n {\n\n            ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n                                  j,\n                                  BUF_MGR_REF);\n            ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_mv_buf_mgr,\n                                  ps_dec->au1_pic_buf_id_mv_buf_id_map[j],\n                                  BUF_MGR_REF);\n            ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n                                  j,\n                                  BUF_MGR_IO);\n }\n\n /* reset the decoder structure parameters related to buffer handling */\n        ps_dec->u1_second_field = 0;\n        ps_dec->i4_cur_display_seq = 0;\n\n /********************************************************************/\n /* indicate in the decoder output i4_status that some frames are being */\n /* dropped, so that it resets timestamp and wait for a new sequence */\n /********************************************************************/\n\n        ps_dec->s_prev_seq_params.u1_eoseq_pending = 0;\n }\n    ret = ih264d_init_pic(ps_dec, u2_frame_num, i4_poc, ps_pps);\n if(ret != OK)\n return ret;\n\n    ps_dec->pv_parse_tu_coeff_data = ps_dec->pv_pic_tu_coeff_data;\n    ps_dec->pv_proc_tu_coeff_data  = ps_dec->pv_pic_tu_coeff_data;\n    ps_dec->ps_nmb_info = ps_dec->ps_frm_mb_info;\n if(ps_dec->u1_separate_parse)\n {\n        UWORD16 pic_wd = ps_dec->u4_width_at_init;\n        UWORD16 pic_ht = ps_dec->u4_height_at_init;\n        UWORD32 num_mbs;\n\n if((NULL != ps_dec->ps_cur_sps) && (1 == (ps_dec->ps_cur_sps->u1_is_valid)))\n {\n            pic_wd = ps_dec->u2_pic_wd;\n            pic_ht = ps_dec->u2_pic_ht;\n }\n        num_mbs = (pic_wd * pic_ht) >> 8;\n\n if(ps_dec->pu1_dec_mb_map)\n {\n            memset((void *)ps_dec->pu1_dec_mb_map, 0, num_mbs);\n }\n\n if(ps_dec->pu1_recon_mb_map)\n {\n\n            memset((void *)ps_dec->pu1_recon_mb_map, 0, num_mbs);\n }\n\n if(ps_dec->pu2_slice_num_map)\n {\n            memset((void *)ps_dec->pu2_slice_num_map, 0,\n (num_mbs * sizeof(UWORD16)));\n }\n\n }\n\n    ps_dec->ps_parse_cur_slice = &(ps_dec->ps_dec_slice_buf[0]);\n    ps_dec->ps_decode_cur_slice = &(ps_dec->ps_dec_slice_buf[0]);\n    ps_dec->ps_computebs_cur_slice = &(ps_dec->ps_dec_slice_buf[0]);\n    ps_dec->u2_cur_slice_num = 0;\n\n /* Initialize all the HP toolsets to zero */\n    ps_dec->s_high_profile.u1_scaling_present = 0;\n    ps_dec->s_high_profile.u1_transform8x8_present = 0;\n\n /* Get Next Free Picture */\n if(1 == ps_dec->u4_share_disp_buf)\n {\n        UWORD32 i;\n /* Free any buffer that is in the queue to be freed */\n for(i = 0; i < MAX_DISP_BUFS_NEW; i++)\n {\n if(0 == ps_dec->u4_disp_buf_to_be_freed[i])\n continue;\n            ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr, i,\n            BUF_MGR_IO);\n            ps_dec->u4_disp_buf_to_be_freed[i] = 0;\n            ps_dec->u4_disp_buf_mapping[i] = 0;\n\n }\n }\n if(!(u1_field_pic_flag && 0 != ps_dec->u1_top_bottom_decoded)) //ps_dec->u1_second_field))\n {\n pic_buffer_t *ps_cur_pic;\n        WORD32 cur_pic_buf_id, cur_mv_buf_id;\n col_mv_buf_t *ps_col_mv;\n while(1)\n {\n            ps_cur_pic = (pic_buffer_t *)ih264_buf_mgr_get_next_free(\n (buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n &cur_pic_buf_id);\n if(ps_cur_pic == NULL)\n {\n                ps_dec->i4_error_code = ERROR_UNAVAIL_PICBUF_T;\n return ERROR_UNAVAIL_PICBUF_T;\n }\n if(0 == ps_dec->u4_disp_buf_mapping[cur_pic_buf_id])\n {\n break;\n }\n\n }\n        ps_col_mv = (col_mv_buf_t *)ih264_buf_mgr_get_next_free((buf_mgr_t *)ps_dec->pv_mv_buf_mgr,\n &cur_mv_buf_id);\n if(ps_col_mv == NULL)\n {\n            ps_dec->i4_error_code = ERROR_UNAVAIL_MVBUF_T;\n return ERROR_UNAVAIL_MVBUF_T;\n }\n\n        ps_dec->ps_cur_pic = ps_cur_pic;\n        ps_dec->u1_pic_buf_id = cur_pic_buf_id;\n        ps_cur_pic->u4_ts = ps_dec->u4_ts;\n\n\n        ps_cur_pic->u1_mv_buf_id = cur_mv_buf_id;\n        ps_dec->au1_pic_buf_id_mv_buf_id_map[cur_pic_buf_id] = cur_mv_buf_id;\n\n\n         ps_cur_pic->pu1_col_zero_flag = (UWORD8 *)ps_col_mv->pv_col_zero_flag;\n         ps_cur_pic->ps_mv = (mv_pred_t *)ps_col_mv->pv_mv;\n         ps_dec->au1_pic_buf_ref_flag[cur_pic_buf_id] = 0;\n        if(ps_dec->u1_first_slice_in_stream)\n         {\n             /*make first entry of list0 point to cur pic,so that if first Islice is in error, ref pic struct will have valid entries*/\n             ps_dec->ps_ref_pic_buf_lx[0] = ps_dec->ps_dpb_mgr->ps_init_dpb[0];\n *(ps_dec->ps_dpb_mgr->ps_init_dpb[0][0]) = *ps_cur_pic;\n /* Initialize for field reference as well */\n *(ps_dec->ps_dpb_mgr->ps_init_dpb[0][MAX_REF_BUFS]) = *ps_cur_pic;\n }\n\n if(!ps_dec->ps_cur_pic)\n {\n            WORD32 j;\n            H264_DEC_DEBUG_PRINT(\"------- Display Buffers Reset --------\\n\");\n for(j = 0; j < MAX_DISP_BUFS_NEW; j++)\n {\n\n                ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n                                      j,\n                                      BUF_MGR_REF);\n                ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_mv_buf_mgr,\n                                      ps_dec->au1_pic_buf_id_mv_buf_id_map[j],\n                                      BUF_MGR_REF);\n                ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n                                      j,\n                                      BUF_MGR_IO);\n }\n\n            ps_dec->i4_cur_display_seq = 0;\n            ps_dec->i4_prev_max_display_seq = 0;\n            ps_dec->i4_max_poc = 0;\n\n            ps_cur_pic = (pic_buffer_t *)ih264_buf_mgr_get_next_free(\n (buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n &cur_pic_buf_id);\n if(ps_cur_pic == NULL)\n {\n                ps_dec->i4_error_code = ERROR_UNAVAIL_PICBUF_T;\n return ERROR_UNAVAIL_PICBUF_T;\n }\n\n            ps_col_mv = (col_mv_buf_t *)ih264_buf_mgr_get_next_free((buf_mgr_t *)ps_dec->pv_mv_buf_mgr,\n &cur_mv_buf_id);\n if(ps_col_mv == NULL)\n {\n                ps_dec->i4_error_code = ERROR_UNAVAIL_MVBUF_T;\n return ERROR_UNAVAIL_MVBUF_T;\n }\n\n            ps_dec->ps_cur_pic = ps_cur_pic;\n            ps_dec->u1_pic_buf_id = cur_pic_buf_id;\n            ps_cur_pic->u4_ts = ps_dec->u4_ts;\n            ps_dec->apv_buf_id_pic_buf_map[cur_pic_buf_id] = (void *)ps_cur_pic;\n\n            ps_cur_pic->u1_mv_buf_id = cur_mv_buf_id;\n            ps_dec->au1_pic_buf_id_mv_buf_id_map[cur_pic_buf_id] = cur_mv_buf_id;\n\n            ps_cur_pic->pu1_col_zero_flag = (UWORD8 *)ps_col_mv->pv_col_zero_flag;\n            ps_cur_pic->ps_mv = (mv_pred_t *)ps_col_mv->pv_mv;\n            ps_dec->au1_pic_buf_ref_flag[cur_pic_buf_id] = 0;\n\n }\n\n        ps_dec->ps_cur_pic->u1_picturetype = u1_field_pic_flag;\n        ps_dec->ps_cur_pic->u4_pack_slc_typ = SKIP_NONE;\n        H264_DEC_DEBUG_PRINT(\"got a buffer\\n\");\n }\n else\n {\n        H264_DEC_DEBUG_PRINT(\"did not get a buffer\\n\");\n }\n\n    ps_dec->u4_pic_buf_got = 1;\n\n    ps_dec->ps_cur_pic->i4_poc = i4_poc;\n    ps_dec->ps_cur_pic->i4_frame_num = u2_frame_num;\n    ps_dec->ps_cur_pic->i4_pic_num = u2_frame_num;\n    ps_dec->ps_cur_pic->i4_top_field_order_cnt = ps_pps->i4_top_field_order_cnt;\n    ps_dec->ps_cur_pic->i4_bottom_field_order_cnt =\n                    ps_pps->i4_bottom_field_order_cnt;\n    ps_dec->ps_cur_pic->i4_avg_poc = ps_pps->i4_avg_poc;\n    ps_dec->ps_cur_pic->u4_time_stamp = ps_dec->u4_pts;\n\n    ps_dec->s_cur_pic = *(ps_dec->ps_cur_pic);\n if(u1_field_pic_flag && u1_bottom_field_flag)\n {\n        WORD32 i4_temp_poc;\n        WORD32 i4_top_field_order_poc, i4_bot_field_order_poc;\n /* Point to odd lines, since it's bottom field */\n        ps_dec->s_cur_pic.pu1_buf1 += ps_dec->s_cur_pic.u2_frm_wd_y;\n        ps_dec->s_cur_pic.pu1_buf2 += ps_dec->s_cur_pic.u2_frm_wd_uv;\n        ps_dec->s_cur_pic.pu1_buf3 += ps_dec->s_cur_pic.u2_frm_wd_uv;\n        ps_dec->s_cur_pic.ps_mv +=\n ((ps_dec->u2_pic_ht * ps_dec->u2_pic_wd) >> 5);\n        ps_dec->s_cur_pic.pu1_col_zero_flag += ((ps_dec->u2_pic_ht\n * ps_dec->u2_pic_wd) >> 5);\n        ps_dec->ps_cur_pic->u1_picturetype |= BOT_FLD;\n        i4_top_field_order_poc = ps_dec->ps_cur_pic->i4_top_field_order_cnt;\n        i4_bot_field_order_poc = ps_dec->ps_cur_pic->i4_bottom_field_order_cnt;\n        i4_temp_poc = MIN(i4_top_field_order_poc,\n                                 i4_bot_field_order_poc);\n        ps_dec->ps_cur_pic->i4_avg_poc = i4_temp_poc;\n }\n\n    ps_cur_slice->u1_mbaff_frame_flag = ps_seq->u1_mb_aff_flag\n && (!u1_field_pic_flag);\n\n    ps_dec->ps_cur_pic->u1_picturetype |= (ps_cur_slice->u1_mbaff_frame_flag\n << 2);\n\n    ps_dec->ps_cur_mb_row = ps_dec->ps_nbr_mb_row; //[0];\n    ps_dec->ps_cur_mb_row++; //Increment by 1 ,so that left mb will always be valid\n    ps_dec->ps_top_mb_row =\n                    ps_dec->ps_nbr_mb_row\n + ((ps_dec->u2_frm_wd_in_mbs + 1)\n << (1\n - ps_dec->ps_cur_sps->u1_frame_mbs_only_flag));\n    ps_dec->ps_top_mb_row++; //Increment by 1 ,so that left mb will always be valid\n\n    ps_dec->pu1_y = ps_dec->pu1_y_scratch[0];\n    ps_dec->pu1_u = ps_dec->pu1_u_scratch[0];\n    ps_dec->pu1_v = ps_dec->pu1_v_scratch[0];\n    ps_dec->u1_yuv_scratch_idx = 0;\n /* CHANGED CODE */\n    ps_dec->ps_mv_cur = ps_dec->s_cur_pic.ps_mv;\n    ps_dec->ps_mv_top = ps_dec->ps_mv_top_p[0];\n /* CHANGED CODE */\n    ps_dec->u1_mv_top_p = 0;\n    ps_dec->u1_mb_idx = 0;\n /* CHANGED CODE */\n    ps_dec->ps_mv_left = ps_dec->s_cur_pic.ps_mv;\n    ps_dec->pu1_yleft = 0;\n    ps_dec->pu1_uleft = 0;\n    ps_dec->pu1_vleft = 0;\n    ps_dec->u1_not_wait_rec = 2;\n    ps_dec->u2_total_mbs_coded = 0;\n    ps_dec->i4_submb_ofst = -(SUB_BLK_SIZE);\n    ps_dec->u4_pred_info_idx = 0;\n    ps_dec->u4_pred_info_pkd_idx = 0;\n    ps_dec->u4_dma_buf_idx = 0;\n    ps_dec->ps_mv = ps_dec->s_cur_pic.ps_mv;\n    ps_dec->ps_mv_bank_cur = ps_dec->s_cur_pic.ps_mv;\n    ps_dec->pu1_col_zero_flag = ps_dec->s_cur_pic.pu1_col_zero_flag;\n    ps_dec->ps_part = ps_dec->ps_parse_part_params;\n    ps_dec->i2_prev_slice_mbx = -1;\n    ps_dec->i2_prev_slice_mby = 0;\n    ps_dec->u2_mv_2mb[0] = 0;\n    ps_dec->u2_mv_2mb[1] = 0;\n    ps_dec->u1_last_pic_not_decoded = 0;\n\n    ps_dec->u2_cur_slice_num_dec_thread = 0;\n    ps_dec->u2_cur_slice_num_bs = 0;\n    ps_dec->u4_intra_pred_line_ofst = 0;\n    ps_dec->pu1_cur_y_intra_pred_line = ps_dec->pu1_y_intra_pred_line;\n    ps_dec->pu1_cur_u_intra_pred_line = ps_dec->pu1_u_intra_pred_line;\n    ps_dec->pu1_cur_v_intra_pred_line = ps_dec->pu1_v_intra_pred_line;\n\n    ps_dec->pu1_cur_y_intra_pred_line_base = ps_dec->pu1_y_intra_pred_line;\n    ps_dec->pu1_cur_u_intra_pred_line_base = ps_dec->pu1_u_intra_pred_line;\n    ps_dec->pu1_cur_v_intra_pred_line_base = ps_dec->pu1_v_intra_pred_line;\n\n\n\n\n\n    ps_dec->pu1_prev_y_intra_pred_line = ps_dec->pu1_y_intra_pred_line\n + (ps_dec->u2_frm_wd_in_mbs * MB_SIZE);\n\n    ps_dec->pu1_prev_u_intra_pred_line = ps_dec->pu1_u_intra_pred_line\n + ps_dec->u2_frm_wd_in_mbs * BLK8x8SIZE * YUV420SP_FACTOR;\n    ps_dec->pu1_prev_v_intra_pred_line = ps_dec->pu1_v_intra_pred_line\n + ps_dec->u2_frm_wd_in_mbs * BLK8x8SIZE;\n\n    ps_dec->ps_deblk_mbn = ps_dec->ps_deblk_pic;\n    ps_dec->ps_deblk_mbn_curr = ps_dec->ps_deblk_mbn;\n    ps_dec->ps_deblk_mbn_prev = ps_dec->ps_deblk_mbn + ps_dec->u1_recon_mb_grp;\n /* Initialize The Function Pointer Depending Upon the Entropy and MbAff Flag */\n {\n if(ps_cur_slice->u1_mbaff_frame_flag)\n {\n            ps_dec->pf_compute_bs = ih264d_compute_bs_mbaff;\n            ps_dec->pf_mvpred = ih264d_mvpred_mbaff;\n }\n else\n {\n            ps_dec->pf_compute_bs = ih264d_compute_bs_non_mbaff;\n            ps_dec->u1_cur_mb_fld_dec_flag = ps_cur_slice->u1_field_pic_flag;\n }\n }\n /* Set up the Parameter for DMA transfer */\n {\n        UWORD8 u1_field_pic_flag = ps_dec->ps_cur_slice->u1_field_pic_flag;\n\n        UWORD8 u1_mbaff = ps_cur_slice->u1_mbaff_frame_flag;\n\n        UWORD8 uc_lastmbs = (((ps_dec->u2_pic_wd) >> 4)\n % (ps_dec->u1_recon_mb_grp >> u1_mbaff));\n        UWORD16 ui16_lastmbs_widthY =\n (uc_lastmbs ? (uc_lastmbs << 4) : ((ps_dec->u1_recon_mb_grp\n >> u1_mbaff) << 4));\n        UWORD16 ui16_lastmbs_widthUV =\n                        uc_lastmbs ? (uc_lastmbs << 3) : ((ps_dec->u1_recon_mb_grp\n >> u1_mbaff) << 3);\n\n        ps_dec->s_tran_addrecon.pu1_dest_y = ps_dec->s_cur_pic.pu1_buf1;\n        ps_dec->s_tran_addrecon.pu1_dest_u = ps_dec->s_cur_pic.pu1_buf2;\n        ps_dec->s_tran_addrecon.pu1_dest_v = ps_dec->s_cur_pic.pu1_buf3;\n\n        ps_dec->s_tran_addrecon.u2_frm_wd_y = ps_dec->u2_frm_wd_y\n << u1_field_pic_flag;\n        ps_dec->s_tran_addrecon.u2_frm_wd_uv = ps_dec->u2_frm_wd_uv\n << u1_field_pic_flag;\n\n if(u1_field_pic_flag)\n {\n            ui16_lastmbs_widthY += ps_dec->u2_frm_wd_y;\n            ui16_lastmbs_widthUV += ps_dec->u2_frm_wd_uv;\n }\n\n /* Normal Increment of Pointer */\n        ps_dec->s_tran_addrecon.u4_inc_y[0] = ((ps_dec->u1_recon_mb_grp << 4)\n >> u1_mbaff);\n        ps_dec->s_tran_addrecon.u4_inc_uv[0] = ((ps_dec->u1_recon_mb_grp << 4)\n >> u1_mbaff);\n\n /* End of Row Increment */\n        ps_dec->s_tran_addrecon.u4_inc_y[1] = (ui16_lastmbs_widthY\n + (PAD_LEN_Y_H << 1)\n + ps_dec->s_tran_addrecon.u2_frm_wd_y\n * ((15 << u1_mbaff) + u1_mbaff));\n        ps_dec->s_tran_addrecon.u4_inc_uv[1] = (ui16_lastmbs_widthUV\n + (PAD_LEN_UV_H << 2)\n + ps_dec->s_tran_addrecon.u2_frm_wd_uv\n * ((15 << u1_mbaff) + u1_mbaff));\n\n /* Assign picture numbers to each frame/field  */\n /* only once per picture.                      */\n        ih264d_assign_pic_num(ps_dec);\n        ps_dec->s_tran_addrecon.u2_mv_top_left_inc = (ps_dec->u1_recon_mb_grp\n << 2) - 1 - (u1_mbaff << 2);\n        ps_dec->s_tran_addrecon.u2_mv_left_inc = ((ps_dec->u1_recon_mb_grp\n >> u1_mbaff) - 1) << (4 + u1_mbaff);\n }\n /**********************************************************************/\n /* High profile related initialization at pictrue level               */\n /**********************************************************************/\n if(ps_seq->u1_profile_idc == HIGH_PROFILE_IDC)\n {\n if((ps_seq->i4_seq_scaling_matrix_present_flag)\n || (ps_pps->i4_pic_scaling_matrix_present_flag))\n {\n            ih264d_form_scaling_matrix_picture(ps_seq, ps_pps, ps_dec);\n            ps_dec->s_high_profile.u1_scaling_present = 1;\n }\n else\n {\n            ih264d_form_default_scaling_matrix(ps_dec);\n }\n\n if(ps_pps->i4_transform_8x8_mode_flag)\n {\n            ps_dec->s_high_profile.u1_transform8x8_present = 1;\n }\n }\n else\n {\n        ih264d_form_default_scaling_matrix(ps_dec);\n }\n\n /* required while reading the transform_size_8x8 u4_flag */\n    ps_dec->s_high_profile.u1_direct_8x8_inference_flag =\n                    ps_seq->u1_direct_8x8_inference_flag;\n    ps_dec->s_high_profile.s_cavlc_ctxt = ps_dec->s_cavlc_ctxt;\n\n    ps_dec->i1_recon_in_thread3_flag = 1;\n    ps_dec->ps_frame_buf_ip_recon = &ps_dec->s_tran_addrecon;\n if(ps_dec->u1_separate_parse)\n {\n        memcpy(&ps_dec->s_tran_addrecon_parse, &ps_dec->s_tran_addrecon,\n sizeof(tfr_ctxt_t));\n if(ps_dec->u4_num_cores >= 3 && ps_dec->i1_recon_in_thread3_flag)\n {\n            memcpy(&ps_dec->s_tran_iprecon, &ps_dec->s_tran_addrecon,\n sizeof(tfr_ctxt_t));\n            ps_dec->ps_frame_buf_ip_recon = &ps_dec->s_tran_iprecon;\n }\n }\n\n\n    ih264d_init_deblk_tfr_ctxt(ps_dec,&(ps_dec->s_pad_mgr), &(ps_dec->s_tran_addrecon),\n                               ps_dec->u2_frm_wd_in_mbs, 0);\n\n    ps_dec->ps_cur_deblk_mb = ps_dec->ps_deblk_pic;\n    ps_dec->u4_cur_deblk_mb_num = 0;\n\n    ps_dec->u4_deblk_mb_x = 0;\n    ps_dec->u4_deblk_mb_y = 0;\n    ps_dec->pu4_wt_ofsts = ps_dec->pu4_wts_ofsts_mat;\n\n    H264_MUTEX_UNLOCK(&ps_dec->process_disp_mutex);\n return OK;\n}\n",
    "code_after_change": "WORD32 ih264d_start_of_pic(dec_struct_t *ps_dec,\n                         WORD32 i4_poc,\n pocstruct_t *ps_temp_poc,\n                         UWORD16 u2_frame_num,\n dec_pic_params_t *ps_pps)\n{\n pocstruct_t *ps_prev_poc = &ps_dec->s_cur_pic_poc;\n pocstruct_t *ps_cur_poc = ps_temp_poc;\n\n pic_buffer_t *pic_buf;\n\n ivd_video_decode_op_t * ps_dec_output =\n (ivd_video_decode_op_t *)ps_dec->pv_dec_out;\n dec_slice_params_t *ps_cur_slice = ps_dec->ps_cur_slice;\n dec_seq_params_t *ps_seq = ps_pps->ps_sps;\n    UWORD8 u1_bottom_field_flag = ps_cur_slice->u1_bottom_field_flag;\n    UWORD8 u1_field_pic_flag = ps_cur_slice->u1_field_pic_flag;\n /* high profile related declarations */\n high_profile_tools_t s_high_profile;\n    WORD32 ret;\n\n    H264_MUTEX_LOCK(&ps_dec->process_disp_mutex);\n\n    ps_prev_poc->i4_pic_order_cnt_lsb = ps_cur_poc->i4_pic_order_cnt_lsb;\n    ps_prev_poc->i4_pic_order_cnt_msb = ps_cur_poc->i4_pic_order_cnt_msb;\n    ps_prev_poc->i4_delta_pic_order_cnt_bottom =\n                    ps_cur_poc->i4_delta_pic_order_cnt_bottom;\n    ps_prev_poc->i4_delta_pic_order_cnt[0] =\n                    ps_cur_poc->i4_delta_pic_order_cnt[0];\n    ps_prev_poc->i4_delta_pic_order_cnt[1] =\n                    ps_cur_poc->i4_delta_pic_order_cnt[1];\n    ps_prev_poc->u1_bot_field = ps_dec->ps_cur_slice->u1_bottom_field_flag;\n    ps_prev_poc->i4_prev_frame_num_ofst = ps_cur_poc->i4_prev_frame_num_ofst;\n    ps_prev_poc->u2_frame_num = u2_frame_num;\n    ps_dec->i1_prev_mb_qp_delta = 0;\n    ps_dec->i1_next_ctxt_idx = 0;\n\n\n    ps_dec->u4_nmb_deblk = 0;\n if(ps_dec->u4_num_cores == 1)\n       ps_dec->u4_nmb_deblk = 1;\n\n\n\n if(ps_seq->u1_mb_aff_flag == 1)\n {\n        ps_dec->u4_nmb_deblk = 0;\n if(ps_dec->u4_num_cores > 2)\n            ps_dec->u4_num_cores = 2;\n }\n\n        ps_dec->u4_use_intrapred_line_copy = 0;\n\n\n\n if (ps_seq->u1_mb_aff_flag == 0)\n {\n        ps_dec->u4_use_intrapred_line_copy = 1;\n }\n\n    ps_dec->u4_app_disable_deblk_frm = 0;\n /* If degrade is enabled, set the degrade flags appropriately */\n if(ps_dec->i4_degrade_type && ps_dec->i4_degrade_pics)\n {\n        WORD32 degrade_pic;\n        ps_dec->i4_degrade_pic_cnt++;\n        degrade_pic = 0;\n\n /* If degrade is to be done in all frames, then do not check further */\n switch(ps_dec->i4_degrade_pics)\n {\n case 4:\n {\n                degrade_pic = 1;\n break;\n }\n case 3:\n {\n if(ps_cur_slice->u1_slice_type != I_SLICE)\n                    degrade_pic = 1;\n\n break;\n }\n case 2:\n {\n\n /* If pic count hits non-degrade interval or it is an islice, then do not degrade */\n if((ps_cur_slice->u1_slice_type != I_SLICE)\n && (ps_dec->i4_degrade_pic_cnt\n != ps_dec->i4_nondegrade_interval))\n                    degrade_pic = 1;\n\n break;\n }\n case 1:\n {\n /* Check if the current picture is non-ref */\n if(0 == ps_cur_slice->u1_nal_ref_idc)\n {\n                    degrade_pic = 1;\n }\n break;\n }\n\n }\n if(degrade_pic)\n {\n if(ps_dec->i4_degrade_type & 0x2)\n                ps_dec->u4_app_disable_deblk_frm = 1;\n\n /* MC degrading is done only for non-ref pictures */\n if(0 == ps_cur_slice->u1_nal_ref_idc)\n {\n if(ps_dec->i4_degrade_type & 0x4)\n                    ps_dec->i4_mv_frac_mask = 0;\n\n if(ps_dec->i4_degrade_type & 0x8)\n                    ps_dec->i4_mv_frac_mask = 0;\n }\n }\n else\n            ps_dec->i4_degrade_pic_cnt = 0;\n }\n\n {\n dec_err_status_t * ps_err = ps_dec->ps_dec_err_status;\n if(ps_dec->u1_sl_typ_5_9\n && ((ps_cur_slice->u1_slice_type == I_SLICE)\n || (ps_cur_slice->u1_slice_type\n == SI_SLICE)))\n            ps_err->u1_cur_pic_type = PIC_TYPE_I;\n else\n            ps_err->u1_cur_pic_type = PIC_TYPE_UNKNOWN;\n\n if(ps_err->u1_pic_aud_i == PIC_TYPE_I)\n {\n            ps_err->u1_cur_pic_type = PIC_TYPE_I;\n            ps_err->u1_pic_aud_i = PIC_TYPE_UNKNOWN;\n }\n\n if(ps_cur_slice->u1_nal_unit_type == IDR_SLICE_NAL)\n {\n if(ps_err->u1_err_flag)\n                ih264d_reset_ref_bufs(ps_dec->ps_dpb_mgr);\n            ps_err->u1_err_flag = ACCEPT_ALL_PICS;\n }\n }\n\n if(ps_dec->u1_init_dec_flag && ps_dec->s_prev_seq_params.u1_eoseq_pending)\n {\n /* Reset the decoder picture buffers */\n        WORD32 j;\n for(j = 0; j < MAX_DISP_BUFS_NEW; j++)\n {\n\n            ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n                                  j,\n                                  BUF_MGR_REF);\n            ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_mv_buf_mgr,\n                                  ps_dec->au1_pic_buf_id_mv_buf_id_map[j],\n                                  BUF_MGR_REF);\n            ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n                                  j,\n                                  BUF_MGR_IO);\n }\n\n /* reset the decoder structure parameters related to buffer handling */\n        ps_dec->u1_second_field = 0;\n        ps_dec->i4_cur_display_seq = 0;\n\n /********************************************************************/\n /* indicate in the decoder output i4_status that some frames are being */\n /* dropped, so that it resets timestamp and wait for a new sequence */\n /********************************************************************/\n\n        ps_dec->s_prev_seq_params.u1_eoseq_pending = 0;\n }\n    ret = ih264d_init_pic(ps_dec, u2_frame_num, i4_poc, ps_pps);\n if(ret != OK)\n return ret;\n\n    ps_dec->pv_parse_tu_coeff_data = ps_dec->pv_pic_tu_coeff_data;\n    ps_dec->pv_proc_tu_coeff_data  = ps_dec->pv_pic_tu_coeff_data;\n    ps_dec->ps_nmb_info = ps_dec->ps_frm_mb_info;\n if(ps_dec->u1_separate_parse)\n {\n        UWORD16 pic_wd = ps_dec->u4_width_at_init;\n        UWORD16 pic_ht = ps_dec->u4_height_at_init;\n        UWORD32 num_mbs;\n\n if((NULL != ps_dec->ps_cur_sps) && (1 == (ps_dec->ps_cur_sps->u1_is_valid)))\n {\n            pic_wd = ps_dec->u2_pic_wd;\n            pic_ht = ps_dec->u2_pic_ht;\n }\n        num_mbs = (pic_wd * pic_ht) >> 8;\n\n if(ps_dec->pu1_dec_mb_map)\n {\n            memset((void *)ps_dec->pu1_dec_mb_map, 0, num_mbs);\n }\n\n if(ps_dec->pu1_recon_mb_map)\n {\n\n            memset((void *)ps_dec->pu1_recon_mb_map, 0, num_mbs);\n }\n\n if(ps_dec->pu2_slice_num_map)\n {\n            memset((void *)ps_dec->pu2_slice_num_map, 0,\n (num_mbs * sizeof(UWORD16)));\n }\n\n }\n\n    ps_dec->ps_parse_cur_slice = &(ps_dec->ps_dec_slice_buf[0]);\n    ps_dec->ps_decode_cur_slice = &(ps_dec->ps_dec_slice_buf[0]);\n    ps_dec->ps_computebs_cur_slice = &(ps_dec->ps_dec_slice_buf[0]);\n    ps_dec->u2_cur_slice_num = 0;\n\n /* Initialize all the HP toolsets to zero */\n    ps_dec->s_high_profile.u1_scaling_present = 0;\n    ps_dec->s_high_profile.u1_transform8x8_present = 0;\n\n /* Get Next Free Picture */\n if(1 == ps_dec->u4_share_disp_buf)\n {\n        UWORD32 i;\n /* Free any buffer that is in the queue to be freed */\n for(i = 0; i < MAX_DISP_BUFS_NEW; i++)\n {\n if(0 == ps_dec->u4_disp_buf_to_be_freed[i])\n continue;\n            ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr, i,\n            BUF_MGR_IO);\n            ps_dec->u4_disp_buf_to_be_freed[i] = 0;\n            ps_dec->u4_disp_buf_mapping[i] = 0;\n\n }\n }\n if(!(u1_field_pic_flag && 0 != ps_dec->u1_top_bottom_decoded)) //ps_dec->u1_second_field))\n {\n pic_buffer_t *ps_cur_pic;\n        WORD32 cur_pic_buf_id, cur_mv_buf_id;\n col_mv_buf_t *ps_col_mv;\n while(1)\n {\n            ps_cur_pic = (pic_buffer_t *)ih264_buf_mgr_get_next_free(\n (buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n &cur_pic_buf_id);\n if(ps_cur_pic == NULL)\n {\n                ps_dec->i4_error_code = ERROR_UNAVAIL_PICBUF_T;\n return ERROR_UNAVAIL_PICBUF_T;\n }\n if(0 == ps_dec->u4_disp_buf_mapping[cur_pic_buf_id])\n {\n break;\n }\n\n }\n        ps_col_mv = (col_mv_buf_t *)ih264_buf_mgr_get_next_free((buf_mgr_t *)ps_dec->pv_mv_buf_mgr,\n &cur_mv_buf_id);\n if(ps_col_mv == NULL)\n {\n            ps_dec->i4_error_code = ERROR_UNAVAIL_MVBUF_T;\n return ERROR_UNAVAIL_MVBUF_T;\n }\n\n        ps_dec->ps_cur_pic = ps_cur_pic;\n        ps_dec->u1_pic_buf_id = cur_pic_buf_id;\n        ps_cur_pic->u4_ts = ps_dec->u4_ts;\n\n\n        ps_cur_pic->u1_mv_buf_id = cur_mv_buf_id;\n        ps_dec->au1_pic_buf_id_mv_buf_id_map[cur_pic_buf_id] = cur_mv_buf_id;\n\n\n         ps_cur_pic->pu1_col_zero_flag = (UWORD8 *)ps_col_mv->pv_col_zero_flag;\n         ps_cur_pic->ps_mv = (mv_pred_t *)ps_col_mv->pv_mv;\n         ps_dec->au1_pic_buf_ref_flag[cur_pic_buf_id] = 0;\n\n         {\n             /*make first entry of list0 point to cur pic,so that if first Islice is in error, ref pic struct will have valid entries*/\n             ps_dec->ps_ref_pic_buf_lx[0] = ps_dec->ps_dpb_mgr->ps_init_dpb[0];\n *(ps_dec->ps_dpb_mgr->ps_init_dpb[0][0]) = *ps_cur_pic;\n /* Initialize for field reference as well */\n *(ps_dec->ps_dpb_mgr->ps_init_dpb[0][MAX_REF_BUFS]) = *ps_cur_pic;\n }\n\n if(!ps_dec->ps_cur_pic)\n {\n            WORD32 j;\n            H264_DEC_DEBUG_PRINT(\"------- Display Buffers Reset --------\\n\");\n for(j = 0; j < MAX_DISP_BUFS_NEW; j++)\n {\n\n                ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n                                      j,\n                                      BUF_MGR_REF);\n                ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_mv_buf_mgr,\n                                      ps_dec->au1_pic_buf_id_mv_buf_id_map[j],\n                                      BUF_MGR_REF);\n                ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n                                      j,\n                                      BUF_MGR_IO);\n }\n\n            ps_dec->i4_cur_display_seq = 0;\n            ps_dec->i4_prev_max_display_seq = 0;\n            ps_dec->i4_max_poc = 0;\n\n            ps_cur_pic = (pic_buffer_t *)ih264_buf_mgr_get_next_free(\n (buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n &cur_pic_buf_id);\n if(ps_cur_pic == NULL)\n {\n                ps_dec->i4_error_code = ERROR_UNAVAIL_PICBUF_T;\n return ERROR_UNAVAIL_PICBUF_T;\n }\n\n            ps_col_mv = (col_mv_buf_t *)ih264_buf_mgr_get_next_free((buf_mgr_t *)ps_dec->pv_mv_buf_mgr,\n &cur_mv_buf_id);\n if(ps_col_mv == NULL)\n {\n                ps_dec->i4_error_code = ERROR_UNAVAIL_MVBUF_T;\n return ERROR_UNAVAIL_MVBUF_T;\n }\n\n            ps_dec->ps_cur_pic = ps_cur_pic;\n            ps_dec->u1_pic_buf_id = cur_pic_buf_id;\n            ps_cur_pic->u4_ts = ps_dec->u4_ts;\n            ps_dec->apv_buf_id_pic_buf_map[cur_pic_buf_id] = (void *)ps_cur_pic;\n\n            ps_cur_pic->u1_mv_buf_id = cur_mv_buf_id;\n            ps_dec->au1_pic_buf_id_mv_buf_id_map[cur_pic_buf_id] = cur_mv_buf_id;\n\n            ps_cur_pic->pu1_col_zero_flag = (UWORD8 *)ps_col_mv->pv_col_zero_flag;\n            ps_cur_pic->ps_mv = (mv_pred_t *)ps_col_mv->pv_mv;\n            ps_dec->au1_pic_buf_ref_flag[cur_pic_buf_id] = 0;\n\n }\n\n        ps_dec->ps_cur_pic->u1_picturetype = u1_field_pic_flag;\n        ps_dec->ps_cur_pic->u4_pack_slc_typ = SKIP_NONE;\n        H264_DEC_DEBUG_PRINT(\"got a buffer\\n\");\n }\n else\n {\n        H264_DEC_DEBUG_PRINT(\"did not get a buffer\\n\");\n }\n\n    ps_dec->u4_pic_buf_got = 1;\n\n    ps_dec->ps_cur_pic->i4_poc = i4_poc;\n    ps_dec->ps_cur_pic->i4_frame_num = u2_frame_num;\n    ps_dec->ps_cur_pic->i4_pic_num = u2_frame_num;\n    ps_dec->ps_cur_pic->i4_top_field_order_cnt = ps_pps->i4_top_field_order_cnt;\n    ps_dec->ps_cur_pic->i4_bottom_field_order_cnt =\n                    ps_pps->i4_bottom_field_order_cnt;\n    ps_dec->ps_cur_pic->i4_avg_poc = ps_pps->i4_avg_poc;\n    ps_dec->ps_cur_pic->u4_time_stamp = ps_dec->u4_pts;\n\n    ps_dec->s_cur_pic = *(ps_dec->ps_cur_pic);\n if(u1_field_pic_flag && u1_bottom_field_flag)\n {\n        WORD32 i4_temp_poc;\n        WORD32 i4_top_field_order_poc, i4_bot_field_order_poc;\n /* Point to odd lines, since it's bottom field */\n        ps_dec->s_cur_pic.pu1_buf1 += ps_dec->s_cur_pic.u2_frm_wd_y;\n        ps_dec->s_cur_pic.pu1_buf2 += ps_dec->s_cur_pic.u2_frm_wd_uv;\n        ps_dec->s_cur_pic.pu1_buf3 += ps_dec->s_cur_pic.u2_frm_wd_uv;\n        ps_dec->s_cur_pic.ps_mv +=\n ((ps_dec->u2_pic_ht * ps_dec->u2_pic_wd) >> 5);\n        ps_dec->s_cur_pic.pu1_col_zero_flag += ((ps_dec->u2_pic_ht\n * ps_dec->u2_pic_wd) >> 5);\n        ps_dec->ps_cur_pic->u1_picturetype |= BOT_FLD;\n        i4_top_field_order_poc = ps_dec->ps_cur_pic->i4_top_field_order_cnt;\n        i4_bot_field_order_poc = ps_dec->ps_cur_pic->i4_bottom_field_order_cnt;\n        i4_temp_poc = MIN(i4_top_field_order_poc,\n                                 i4_bot_field_order_poc);\n        ps_dec->ps_cur_pic->i4_avg_poc = i4_temp_poc;\n }\n\n    ps_cur_slice->u1_mbaff_frame_flag = ps_seq->u1_mb_aff_flag\n && (!u1_field_pic_flag);\n\n    ps_dec->ps_cur_pic->u1_picturetype |= (ps_cur_slice->u1_mbaff_frame_flag\n << 2);\n\n    ps_dec->ps_cur_mb_row = ps_dec->ps_nbr_mb_row; //[0];\n    ps_dec->ps_cur_mb_row++; //Increment by 1 ,so that left mb will always be valid\n    ps_dec->ps_top_mb_row =\n                    ps_dec->ps_nbr_mb_row\n + ((ps_dec->u2_frm_wd_in_mbs + 1)\n << (1\n - ps_dec->ps_cur_sps->u1_frame_mbs_only_flag));\n    ps_dec->ps_top_mb_row++; //Increment by 1 ,so that left mb will always be valid\n\n    ps_dec->pu1_y = ps_dec->pu1_y_scratch[0];\n    ps_dec->pu1_u = ps_dec->pu1_u_scratch[0];\n    ps_dec->pu1_v = ps_dec->pu1_v_scratch[0];\n    ps_dec->u1_yuv_scratch_idx = 0;\n /* CHANGED CODE */\n    ps_dec->ps_mv_cur = ps_dec->s_cur_pic.ps_mv;\n    ps_dec->ps_mv_top = ps_dec->ps_mv_top_p[0];\n /* CHANGED CODE */\n    ps_dec->u1_mv_top_p = 0;\n    ps_dec->u1_mb_idx = 0;\n /* CHANGED CODE */\n    ps_dec->ps_mv_left = ps_dec->s_cur_pic.ps_mv;\n    ps_dec->pu1_yleft = 0;\n    ps_dec->pu1_uleft = 0;\n    ps_dec->pu1_vleft = 0;\n    ps_dec->u1_not_wait_rec = 2;\n    ps_dec->u2_total_mbs_coded = 0;\n    ps_dec->i4_submb_ofst = -(SUB_BLK_SIZE);\n    ps_dec->u4_pred_info_idx = 0;\n    ps_dec->u4_pred_info_pkd_idx = 0;\n    ps_dec->u4_dma_buf_idx = 0;\n    ps_dec->ps_mv = ps_dec->s_cur_pic.ps_mv;\n    ps_dec->ps_mv_bank_cur = ps_dec->s_cur_pic.ps_mv;\n    ps_dec->pu1_col_zero_flag = ps_dec->s_cur_pic.pu1_col_zero_flag;\n    ps_dec->ps_part = ps_dec->ps_parse_part_params;\n    ps_dec->i2_prev_slice_mbx = -1;\n    ps_dec->i2_prev_slice_mby = 0;\n    ps_dec->u2_mv_2mb[0] = 0;\n    ps_dec->u2_mv_2mb[1] = 0;\n    ps_dec->u1_last_pic_not_decoded = 0;\n\n    ps_dec->u2_cur_slice_num_dec_thread = 0;\n    ps_dec->u2_cur_slice_num_bs = 0;\n    ps_dec->u4_intra_pred_line_ofst = 0;\n    ps_dec->pu1_cur_y_intra_pred_line = ps_dec->pu1_y_intra_pred_line;\n    ps_dec->pu1_cur_u_intra_pred_line = ps_dec->pu1_u_intra_pred_line;\n    ps_dec->pu1_cur_v_intra_pred_line = ps_dec->pu1_v_intra_pred_line;\n\n    ps_dec->pu1_cur_y_intra_pred_line_base = ps_dec->pu1_y_intra_pred_line;\n    ps_dec->pu1_cur_u_intra_pred_line_base = ps_dec->pu1_u_intra_pred_line;\n    ps_dec->pu1_cur_v_intra_pred_line_base = ps_dec->pu1_v_intra_pred_line;\n\n\n\n\n\n    ps_dec->pu1_prev_y_intra_pred_line = ps_dec->pu1_y_intra_pred_line\n + (ps_dec->u2_frm_wd_in_mbs * MB_SIZE);\n\n    ps_dec->pu1_prev_u_intra_pred_line = ps_dec->pu1_u_intra_pred_line\n + ps_dec->u2_frm_wd_in_mbs * BLK8x8SIZE * YUV420SP_FACTOR;\n    ps_dec->pu1_prev_v_intra_pred_line = ps_dec->pu1_v_intra_pred_line\n + ps_dec->u2_frm_wd_in_mbs * BLK8x8SIZE;\n\n    ps_dec->ps_deblk_mbn = ps_dec->ps_deblk_pic;\n    ps_dec->ps_deblk_mbn_curr = ps_dec->ps_deblk_mbn;\n    ps_dec->ps_deblk_mbn_prev = ps_dec->ps_deblk_mbn + ps_dec->u1_recon_mb_grp;\n /* Initialize The Function Pointer Depending Upon the Entropy and MbAff Flag */\n {\n if(ps_cur_slice->u1_mbaff_frame_flag)\n {\n            ps_dec->pf_compute_bs = ih264d_compute_bs_mbaff;\n            ps_dec->pf_mvpred = ih264d_mvpred_mbaff;\n }\n else\n {\n            ps_dec->pf_compute_bs = ih264d_compute_bs_non_mbaff;\n            ps_dec->u1_cur_mb_fld_dec_flag = ps_cur_slice->u1_field_pic_flag;\n }\n }\n /* Set up the Parameter for DMA transfer */\n {\n        UWORD8 u1_field_pic_flag = ps_dec->ps_cur_slice->u1_field_pic_flag;\n\n        UWORD8 u1_mbaff = ps_cur_slice->u1_mbaff_frame_flag;\n\n        UWORD8 uc_lastmbs = (((ps_dec->u2_pic_wd) >> 4)\n % (ps_dec->u1_recon_mb_grp >> u1_mbaff));\n        UWORD16 ui16_lastmbs_widthY =\n (uc_lastmbs ? (uc_lastmbs << 4) : ((ps_dec->u1_recon_mb_grp\n >> u1_mbaff) << 4));\n        UWORD16 ui16_lastmbs_widthUV =\n                        uc_lastmbs ? (uc_lastmbs << 3) : ((ps_dec->u1_recon_mb_grp\n >> u1_mbaff) << 3);\n\n        ps_dec->s_tran_addrecon.pu1_dest_y = ps_dec->s_cur_pic.pu1_buf1;\n        ps_dec->s_tran_addrecon.pu1_dest_u = ps_dec->s_cur_pic.pu1_buf2;\n        ps_dec->s_tran_addrecon.pu1_dest_v = ps_dec->s_cur_pic.pu1_buf3;\n\n        ps_dec->s_tran_addrecon.u2_frm_wd_y = ps_dec->u2_frm_wd_y\n << u1_field_pic_flag;\n        ps_dec->s_tran_addrecon.u2_frm_wd_uv = ps_dec->u2_frm_wd_uv\n << u1_field_pic_flag;\n\n if(u1_field_pic_flag)\n {\n            ui16_lastmbs_widthY += ps_dec->u2_frm_wd_y;\n            ui16_lastmbs_widthUV += ps_dec->u2_frm_wd_uv;\n }\n\n /* Normal Increment of Pointer */\n        ps_dec->s_tran_addrecon.u4_inc_y[0] = ((ps_dec->u1_recon_mb_grp << 4)\n >> u1_mbaff);\n        ps_dec->s_tran_addrecon.u4_inc_uv[0] = ((ps_dec->u1_recon_mb_grp << 4)\n >> u1_mbaff);\n\n /* End of Row Increment */\n        ps_dec->s_tran_addrecon.u4_inc_y[1] = (ui16_lastmbs_widthY\n + (PAD_LEN_Y_H << 1)\n + ps_dec->s_tran_addrecon.u2_frm_wd_y\n * ((15 << u1_mbaff) + u1_mbaff));\n        ps_dec->s_tran_addrecon.u4_inc_uv[1] = (ui16_lastmbs_widthUV\n + (PAD_LEN_UV_H << 2)\n + ps_dec->s_tran_addrecon.u2_frm_wd_uv\n * ((15 << u1_mbaff) + u1_mbaff));\n\n /* Assign picture numbers to each frame/field  */\n /* only once per picture.                      */\n        ih264d_assign_pic_num(ps_dec);\n        ps_dec->s_tran_addrecon.u2_mv_top_left_inc = (ps_dec->u1_recon_mb_grp\n << 2) - 1 - (u1_mbaff << 2);\n        ps_dec->s_tran_addrecon.u2_mv_left_inc = ((ps_dec->u1_recon_mb_grp\n >> u1_mbaff) - 1) << (4 + u1_mbaff);\n }\n /**********************************************************************/\n /* High profile related initialization at pictrue level               */\n /**********************************************************************/\n if(ps_seq->u1_profile_idc == HIGH_PROFILE_IDC)\n {\n if((ps_seq->i4_seq_scaling_matrix_present_flag)\n || (ps_pps->i4_pic_scaling_matrix_present_flag))\n {\n            ih264d_form_scaling_matrix_picture(ps_seq, ps_pps, ps_dec);\n            ps_dec->s_high_profile.u1_scaling_present = 1;\n }\n else\n {\n            ih264d_form_default_scaling_matrix(ps_dec);\n }\n\n if(ps_pps->i4_transform_8x8_mode_flag)\n {\n            ps_dec->s_high_profile.u1_transform8x8_present = 1;\n }\n }\n else\n {\n        ih264d_form_default_scaling_matrix(ps_dec);\n }\n\n /* required while reading the transform_size_8x8 u4_flag */\n    ps_dec->s_high_profile.u1_direct_8x8_inference_flag =\n                    ps_seq->u1_direct_8x8_inference_flag;\n    ps_dec->s_high_profile.s_cavlc_ctxt = ps_dec->s_cavlc_ctxt;\n\n    ps_dec->i1_recon_in_thread3_flag = 1;\n    ps_dec->ps_frame_buf_ip_recon = &ps_dec->s_tran_addrecon;\n if(ps_dec->u1_separate_parse)\n {\n        memcpy(&ps_dec->s_tran_addrecon_parse, &ps_dec->s_tran_addrecon,\n sizeof(tfr_ctxt_t));\n if(ps_dec->u4_num_cores >= 3 && ps_dec->i1_recon_in_thread3_flag)\n {\n            memcpy(&ps_dec->s_tran_iprecon, &ps_dec->s_tran_addrecon,\n sizeof(tfr_ctxt_t));\n            ps_dec->ps_frame_buf_ip_recon = &ps_dec->s_tran_iprecon;\n }\n }\n\n\n    ih264d_init_deblk_tfr_ctxt(ps_dec,&(ps_dec->s_pad_mgr), &(ps_dec->s_tran_addrecon),\n                               ps_dec->u2_frm_wd_in_mbs, 0);\n\n    ps_dec->ps_cur_deblk_mb = ps_dec->ps_deblk_pic;\n    ps_dec->u4_cur_deblk_mb_num = 0;\n\n    ps_dec->u4_deblk_mb_x = 0;\n    ps_dec->u4_deblk_mb_y = 0;\n    ps_dec->pu4_wt_ofsts = ps_dec->pu4_wts_ofsts_mat;\n\n    H264_MUTEX_UNLOCK(&ps_dec->process_disp_mutex);\n return OK;\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 533,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-1621",
    "code_before_change": "   void FillRandom(uint8_t *data, int stride) {\n     for (int h = 0; h < height_; ++h) {\n       for (int w = 0; w < width_; ++w) {\n        data[h * stride + w] = rnd_.Rand8();\n       }\n     }\n   }\n",
    "code_after_change": "   void FillRandom(uint8_t *data, int stride) {\n    uint8_t *data8 = data;\n#if CONFIG_VP9_HIGHBITDEPTH\n    uint16_t *data16 = CONVERT_TO_SHORTPTR(data);\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n     for (int h = 0; h < height_; ++h) {\n       for (int w = 0; w < width_; ++w) {\n        if (!use_high_bit_depth_) {\n          data8[h * stride + w] = rnd_.Rand8();\n#if CONFIG_VP9_HIGHBITDEPTH\n        } else {\n          data16[h * stride + w] = rnd_.Rand16() & mask_;\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n        }\n       }\n     }\n   }\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 547,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-1683",
    "code_before_change": "exsltStrXpathCtxtRegister (xmlXPathContextPtr ctxt, const xmlChar *prefix)\n{\n    if (ctxt\n        && prefix\n        && !xmlXPathRegisterNs(ctxt,\n                               prefix,\n                               (const xmlChar *) EXSLT_STRINGS_NAMESPACE)\n        && !xmlXPathRegisterFuncNS(ctxt,\n                                   (const xmlChar *) \"encode-uri\",\n                                   (const xmlChar *) EXSLT_STRINGS_NAMESPACE,\n                                   exsltStrEncodeUriFunction)\n        && !xmlXPathRegisterFuncNS(ctxt,\n                                   (const xmlChar *) \"decode-uri\",\n                                   (const xmlChar *) EXSLT_STRINGS_NAMESPACE,\n                                   exsltStrDecodeUriFunction)\n        && !xmlXPathRegisterFuncNS(ctxt,\n                                   (const xmlChar *) \"padding\",\n                                   (const xmlChar *) EXSLT_STRINGS_NAMESPACE,\n                                   exsltStrPaddingFunction)\n        && !xmlXPathRegisterFuncNS(ctxt,\n                                   (const xmlChar *) \"align\",\n                                   (const xmlChar *) EXSLT_STRINGS_NAMESPACE,\n                                   exsltStrAlignFunction)\n         && !xmlXPathRegisterFuncNS(ctxt,\n                                    (const xmlChar *) \"concat\",\n                                    (const xmlChar *) EXSLT_STRINGS_NAMESPACE,\n                                   exsltStrConcatFunction)\n        && !xmlXPathRegisterFuncNS(ctxt,\n                                   (const xmlChar *) \"replace\",\n                                   (const xmlChar *) EXSLT_STRINGS_NAMESPACE,\n                                   exsltStrReplaceFunction)) {\n         return 0;\n     }\n     return -1;\n}\n",
    "code_after_change": "exsltStrXpathCtxtRegister (xmlXPathContextPtr ctxt, const xmlChar *prefix)\n{\n    if (ctxt\n        && prefix\n        && !xmlXPathRegisterNs(ctxt,\n                               prefix,\n                               (const xmlChar *) EXSLT_STRINGS_NAMESPACE)\n        && !xmlXPathRegisterFuncNS(ctxt,\n                                   (const xmlChar *) \"encode-uri\",\n                                   (const xmlChar *) EXSLT_STRINGS_NAMESPACE,\n                                   exsltStrEncodeUriFunction)\n        && !xmlXPathRegisterFuncNS(ctxt,\n                                   (const xmlChar *) \"decode-uri\",\n                                   (const xmlChar *) EXSLT_STRINGS_NAMESPACE,\n                                   exsltStrDecodeUriFunction)\n        && !xmlXPathRegisterFuncNS(ctxt,\n                                   (const xmlChar *) \"padding\",\n                                   (const xmlChar *) EXSLT_STRINGS_NAMESPACE,\n                                   exsltStrPaddingFunction)\n        && !xmlXPathRegisterFuncNS(ctxt,\n                                   (const xmlChar *) \"align\",\n                                   (const xmlChar *) EXSLT_STRINGS_NAMESPACE,\n                                   exsltStrAlignFunction)\n         && !xmlXPathRegisterFuncNS(ctxt,\n                                    (const xmlChar *) \"concat\",\n                                    (const xmlChar *) EXSLT_STRINGS_NAMESPACE,\n                                   exsltStrConcatFunction)) {\n         return 0;\n     }\n     return -1;\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 560,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2013-6627",
    "code_before_change": " void EnsureInitializeForAndroidLayoutTests() {\n  CHECK(CommandLine::ForCurrentProcess()->HasSwitch(switches::kDumpRenderTree));\n   JNIEnv* env = base::android::AttachCurrentThread();\n   content::NestedMessagePumpAndroid::RegisterJni(env);\n   content::RegisterNativesImpl(env);\n\n  bool success = base::MessageLoop::InitMessagePumpForUIFactory(\n      &CreateMessagePumpForUI);\n  CHECK(success) << \"Unable to initialize the message pump for Android.\";\n\n  base::FilePath files_dir(GetTestFilesDirectory(env));\n\n  base::FilePath stdout_fifo(files_dir.Append(FILE_PATH_LITERAL(\"test.fifo\")));\n  EnsureCreateFIFO(stdout_fifo);\n\n  base::FilePath stderr_fifo(\n      files_dir.Append(FILE_PATH_LITERAL(\"stderr.fifo\")));\n  EnsureCreateFIFO(stderr_fifo);\n\n  base::FilePath stdin_fifo(files_dir.Append(FILE_PATH_LITERAL(\"stdin.fifo\")));\n  EnsureCreateFIFO(stdin_fifo);\n\n  success = base::android::RedirectStream(stdout, stdout_fifo, \"w\") &&\n            base::android::RedirectStream(stdin, stdin_fifo, \"r\") &&\n            base::android::RedirectStream(stderr, stderr_fifo, \"w\");\n\n  CHECK(success) << \"Unable to initialize the Android FIFOs.\";\n}\n",
    "code_after_change": " void EnsureInitializeForAndroidLayoutTests() {\n   JNIEnv* env = base::android::AttachCurrentThread();\n   content::NestedMessagePumpAndroid::RegisterJni(env);\n   content::RegisterNativesImpl(env);\n\n  bool success = base::MessageLoop::InitMessagePumpForUIFactory(\n      &CreateMessagePumpForUI);\n  CHECK(success) << \"Unable to initialize the message pump for Android.\";\n\n  base::FilePath files_dir(GetTestFilesDirectory(env));\n\n  base::FilePath stdout_fifo(files_dir.Append(FILE_PATH_LITERAL(\"test.fifo\")));\n  EnsureCreateFIFO(stdout_fifo);\n\n  base::FilePath stderr_fifo(\n      files_dir.Append(FILE_PATH_LITERAL(\"stderr.fifo\")));\n  EnsureCreateFIFO(stderr_fifo);\n\n  base::FilePath stdin_fifo(files_dir.Append(FILE_PATH_LITERAL(\"stdin.fifo\")));\n  EnsureCreateFIFO(stdin_fifo);\n\n  success = base::android::RedirectStream(stdout, stdout_fifo, \"w\") &&\n            base::android::RedirectStream(stdin, stdin_fifo, \"r\") &&\n            base::android::RedirectStream(stderr, stderr_fifo, \"w\");\n\n  CHECK(success) << \"Unable to initialize the Android FIFOs.\";\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 583,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2012-2895",
    "code_before_change": " void LauncherView::OnBoundsAnimatorProgressed(views::BoundsAnimator* animator) {\n   FOR_EACH_OBSERVER(LauncherIconObserver, observers_,\n                     OnLauncherIconPositionsChanged());\n }\n",
    "code_after_change": " void LauncherView::OnBoundsAnimatorProgressed(views::BoundsAnimator* animator) {\n   FOR_EACH_OBSERVER(LauncherIconObserver, observers_,\n                     OnLauncherIconPositionsChanged());\n  PreferredSizeChanged();\n }\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 594,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2019-1010298",
    "code_before_change": "TEE_Result syscall_asymm_operate(unsigned long state,\n\t\t\tconst struct utee_attribute *usr_params,\n\t\t\tsize_t num_params, const void *src_data, size_t src_len,\n\t\t\tvoid *dst_data, uint64_t *dst_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tuint64_t dlen64;\n\tsize_t dlen;\n\tstruct tee_obj *o;\n\tvoid *label = NULL;\n\tsize_t label_len = 0;\n\tsize_t n;\n\tint salt_len;\n\tTEE_Attribute *params = NULL;\n\tstruct user_ta_ctx *utc;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tutc = to_user_ta_ctx(sess->ctx);\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(\n\t\tutc,\n\t\tTEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t(uaddr_t) src_data, src_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_copy_from_user(&dlen64, dst_len, sizeof(dlen64));\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tdlen = dlen64;\n\n\tres = tee_mmu_check_access_rights(\n\t\tutc,\n\t\tTEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_WRITE |\n\t\t\tTEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t(uaddr_t) dst_data, dlen);\n \tif (res != TEE_SUCCESS)\n \t\treturn res;\n \n\tparams = malloc(sizeof(TEE_Attribute) * num_params);\n \tif (!params)\n \t\treturn TEE_ERROR_OUT_OF_MEMORY;\n \tres = copy_in_attrs(utc, usr_params, num_params, params);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_obj_get(utc, cs->key1, &o);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0) {\n\t\tres = TEE_ERROR_GENERIC;\n\t\tgoto out;\n\t}\n\n\tswitch (cs->algo) {\n\tcase TEE_ALG_RSA_NOPAD:\n\t\tif (cs->mode == TEE_MODE_ENCRYPT) {\n\t\t\tres = crypto_acipher_rsanopad_encrypt(o->attr, src_data,\n\t\t\t\t\t\t\t      src_len, dst_data,\n\t\t\t\t\t\t\t      &dlen);\n\t\t} else if (cs->mode == TEE_MODE_DECRYPT) {\n\t\t\tres = crypto_acipher_rsanopad_decrypt(o->attr, src_data,\n\t\t\t\t\t\t\t      src_len, dst_data,\n\t\t\t\t\t\t\t      &dlen);\n\t\t} else {\n\t\t\t/*\n\t\t\t * We will panic because \"the mode is not compatible\n\t\t\t * with the function\"\n\t\t\t */\n\t\t\tres = TEE_ERROR_GENERIC;\n\t\t}\n\t\tbreak;\n\n\tcase TEE_ALG_RSAES_PKCS1_V1_5:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA1:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA224:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA256:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA384:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA512:\n\t\tfor (n = 0; n < num_params; n++) {\n\t\t\tif (params[n].attributeID == TEE_ATTR_RSA_OAEP_LABEL) {\n\t\t\t\tlabel = params[n].content.ref.buffer;\n\t\t\t\tlabel_len = params[n].content.ref.length;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (cs->mode == TEE_MODE_ENCRYPT) {\n\t\t\tres = crypto_acipher_rsaes_encrypt(cs->algo, o->attr,\n\t\t\t\t\t\t\t   label, label_len,\n\t\t\t\t\t\t\t   src_data, src_len,\n\t\t\t\t\t\t\t   dst_data, &dlen);\n\t\t} else if (cs->mode == TEE_MODE_DECRYPT) {\n\t\t\tres = crypto_acipher_rsaes_decrypt(\n\t\t\t\t\tcs->algo, o->attr, label, label_len,\n\t\t\t\t\tsrc_data, src_len, dst_data, &dlen);\n\t\t} else {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t}\n\t\tbreak;\n\n#if defined(CFG_CRYPTO_RSASSA_NA1)\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5:\n#endif\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_MD5:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA1:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA224:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA256:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA384:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA512:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA224:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA256:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA384:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA512:\n\t\tif (cs->mode != TEE_MODE_SIGN) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\tbreak;\n\t\t}\n\t\tsalt_len = pkcs1_get_salt_len(params, num_params, src_len);\n\t\tres = crypto_acipher_rsassa_sign(cs->algo, o->attr, salt_len,\n\t\t\t\t\t\t src_data, src_len, dst_data,\n\t\t\t\t\t\t &dlen);\n\t\tbreak;\n\n\tcase TEE_ALG_DSA_SHA1:\n\tcase TEE_ALG_DSA_SHA224:\n\tcase TEE_ALG_DSA_SHA256:\n\t\tres = crypto_acipher_dsa_sign(cs->algo, o->attr, src_data,\n\t\t\t\t\t      src_len, dst_data, &dlen);\n\t\tbreak;\n\tcase TEE_ALG_ECDSA_P192:\n\tcase TEE_ALG_ECDSA_P224:\n\tcase TEE_ALG_ECDSA_P256:\n\tcase TEE_ALG_ECDSA_P384:\n\tcase TEE_ALG_ECDSA_P521:\n\t\tres = crypto_acipher_ecc_sign(cs->algo, o->attr, src_data,\n\t\t\t\t\t      src_len, dst_data, &dlen);\n\t\tbreak;\n\n\tdefault:\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tbreak;\n\t}\n\nout:\n\tfree(params);\n\n\tif (res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER) {\n\t\tTEE_Result res2;\n\n\t\tdlen64 = dlen;\n\t\tres2 = tee_svc_copy_to_user(dst_len, &dlen64, sizeof(*dst_len));\n\t\tif (res2 != TEE_SUCCESS)\n\t\t\treturn res2;\n\t}\n\n\treturn res;\n}\n",
    "code_after_change": "TEE_Result syscall_asymm_operate(unsigned long state,\n\t\t\tconst struct utee_attribute *usr_params,\n\t\t\tsize_t num_params, const void *src_data, size_t src_len,\n\t\t\tvoid *dst_data, uint64_t *dst_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tuint64_t dlen64;\n\tsize_t dlen;\n\tstruct tee_obj *o;\n\tvoid *label = NULL;\n\tsize_t label_len = 0;\n\tsize_t n;\n\tint salt_len;\n\tTEE_Attribute *params = NULL;\n\tstruct user_ta_ctx *utc;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tutc = to_user_ta_ctx(sess->ctx);\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(\n\t\tutc,\n\t\tTEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t(uaddr_t) src_data, src_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_copy_from_user(&dlen64, dst_len, sizeof(dlen64));\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tdlen = dlen64;\n\n\tres = tee_mmu_check_access_rights(\n\t\tutc,\n\t\tTEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_WRITE |\n\t\t\tTEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t(uaddr_t) dst_data, dlen);\n \tif (res != TEE_SUCCESS)\n \t\treturn res;\n \n\tsize_t alloc_size = 0;\n\n\tif (MUL_OVERFLOW(sizeof(TEE_Attribute), num_params, &alloc_size))\n\t\treturn TEE_ERROR_OVERFLOW;\n\n\tparams = malloc(alloc_size);\n \tif (!params)\n \t\treturn TEE_ERROR_OUT_OF_MEMORY;\n \tres = copy_in_attrs(utc, usr_params, num_params, params);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_obj_get(utc, cs->key1, &o);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0) {\n\t\tres = TEE_ERROR_GENERIC;\n\t\tgoto out;\n\t}\n\n\tswitch (cs->algo) {\n\tcase TEE_ALG_RSA_NOPAD:\n\t\tif (cs->mode == TEE_MODE_ENCRYPT) {\n\t\t\tres = crypto_acipher_rsanopad_encrypt(o->attr, src_data,\n\t\t\t\t\t\t\t      src_len, dst_data,\n\t\t\t\t\t\t\t      &dlen);\n\t\t} else if (cs->mode == TEE_MODE_DECRYPT) {\n\t\t\tres = crypto_acipher_rsanopad_decrypt(o->attr, src_data,\n\t\t\t\t\t\t\t      src_len, dst_data,\n\t\t\t\t\t\t\t      &dlen);\n\t\t} else {\n\t\t\t/*\n\t\t\t * We will panic because \"the mode is not compatible\n\t\t\t * with the function\"\n\t\t\t */\n\t\t\tres = TEE_ERROR_GENERIC;\n\t\t}\n\t\tbreak;\n\n\tcase TEE_ALG_RSAES_PKCS1_V1_5:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA1:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA224:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA256:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA384:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA512:\n\t\tfor (n = 0; n < num_params; n++) {\n\t\t\tif (params[n].attributeID == TEE_ATTR_RSA_OAEP_LABEL) {\n\t\t\t\tlabel = params[n].content.ref.buffer;\n\t\t\t\tlabel_len = params[n].content.ref.length;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (cs->mode == TEE_MODE_ENCRYPT) {\n\t\t\tres = crypto_acipher_rsaes_encrypt(cs->algo, o->attr,\n\t\t\t\t\t\t\t   label, label_len,\n\t\t\t\t\t\t\t   src_data, src_len,\n\t\t\t\t\t\t\t   dst_data, &dlen);\n\t\t} else if (cs->mode == TEE_MODE_DECRYPT) {\n\t\t\tres = crypto_acipher_rsaes_decrypt(\n\t\t\t\t\tcs->algo, o->attr, label, label_len,\n\t\t\t\t\tsrc_data, src_len, dst_data, &dlen);\n\t\t} else {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t}\n\t\tbreak;\n\n#if defined(CFG_CRYPTO_RSASSA_NA1)\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5:\n#endif\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_MD5:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA1:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA224:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA256:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA384:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA512:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA224:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA256:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA384:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA512:\n\t\tif (cs->mode != TEE_MODE_SIGN) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\tbreak;\n\t\t}\n\t\tsalt_len = pkcs1_get_salt_len(params, num_params, src_len);\n\t\tres = crypto_acipher_rsassa_sign(cs->algo, o->attr, salt_len,\n\t\t\t\t\t\t src_data, src_len, dst_data,\n\t\t\t\t\t\t &dlen);\n\t\tbreak;\n\n\tcase TEE_ALG_DSA_SHA1:\n\tcase TEE_ALG_DSA_SHA224:\n\tcase TEE_ALG_DSA_SHA256:\n\t\tres = crypto_acipher_dsa_sign(cs->algo, o->attr, src_data,\n\t\t\t\t\t      src_len, dst_data, &dlen);\n\t\tbreak;\n\tcase TEE_ALG_ECDSA_P192:\n\tcase TEE_ALG_ECDSA_P224:\n\tcase TEE_ALG_ECDSA_P256:\n\tcase TEE_ALG_ECDSA_P384:\n\tcase TEE_ALG_ECDSA_P521:\n\t\tres = crypto_acipher_ecc_sign(cs->algo, o->attr, src_data,\n\t\t\t\t\t      src_len, dst_data, &dlen);\n\t\tbreak;\n\n\tdefault:\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tbreak;\n\t}\n\nout:\n\tfree(params);\n\n\tif (res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER) {\n\t\tTEE_Result res2;\n\n\t\tdlen64 = dlen;\n\t\tres2 = tee_svc_copy_to_user(dst_len, &dlen64, sizeof(*dst_len));\n\t\tif (res2 != TEE_SUCCESS)\n\t\t\treturn res2;\n\t}\n\n\treturn res;\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 603,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-0839",
    "code_before_change": "static int vol_prc_lib_release(effect_handle_t handle)\n{\n\n     struct listnode *node, *temp_node_next;\n     vol_listener_context_t *context = NULL;\n     vol_listener_context_t *recv_contex = (vol_listener_context_t *)handle;\n    int status = -1;\n     bool recompute_flag = false;\n     int active_stream_count = 0;\n     ALOGV(\"%s context %p\", __func__, handle);\n     pthread_mutex_lock(&vol_listner_init_lock);\n \n     list_for_each_safe(node, temp_node_next, &vol_effect_list) {\n         context = node_to_item(node, struct vol_listener_context_s, effect_list_node);\n        if ((memcmp(&(context->desc->uuid), &(recv_contex->desc->uuid), sizeof(effect_uuid_t)) == 0)\n            && (context->session_id == recv_contex->session_id)\n            && (context->stream_type == recv_contex->stream_type)) {\n             ALOGV(\"--- Found something to remove ---\");\n            list_remove(&context->effect_list_node);\n             PRINT_STREAM_TYPE(context->stream_type);\n             if (context->dev_id && AUDIO_DEVICE_OUT_SPEAKER) {\n                 recompute_flag = true;\n }\n            free(context);\n            status = 0;\n } else {\n ++active_stream_count;\n }\n }\n\n \n     if (status != 0) {\n         ALOGE(\"something wrong ... <<<--- Found NOTHING to remove ... ???? --->>>>>\");\n     }\n \n if (active_stream_count == 0) {\n        current_gain_dep_cal_level = -1;\n        current_vol = 0.0;\n }\n\n if (recompute_flag) {\n        check_and_set_gain_dep_cal();\n }\n\n if (dumping_enabled) {\n        dump_list_l();\n }\n    pthread_mutex_unlock(&vol_listner_init_lock);\n return status;\n}\n",
    "code_after_change": "static int vol_prc_lib_release(effect_handle_t handle)\n{\n\n     struct listnode *node, *temp_node_next;\n     vol_listener_context_t *context = NULL;\n     vol_listener_context_t *recv_contex = (vol_listener_context_t *)handle;\n    int status = -EINVAL;\n     bool recompute_flag = false;\n     int active_stream_count = 0;\n    uint32_t session_id;\n    uint32_t stream_type;\n    effect_uuid_t uuid;\n\n     ALOGV(\"%s context %p\", __func__, handle);\n\n    if (recv_contex == NULL) {\n        return status;\n    }\n     pthread_mutex_lock(&vol_listner_init_lock);\n    session_id = recv_contex->session_id;\n    stream_type = recv_contex->stream_type;\n    uuid = recv_contex->desc->uuid;\n \n     list_for_each_safe(node, temp_node_next, &vol_effect_list) {\n         context = node_to_item(node, struct vol_listener_context_s, effect_list_node);\n        if ((memcmp(&(context->desc->uuid), &uuid, sizeof(effect_uuid_t)) == 0)\n            && (context->session_id == session_id)\n            && (context->stream_type == stream_type)) {\n             ALOGV(\"--- Found something to remove ---\");\n            list_remove(node);\n             PRINT_STREAM_TYPE(context->stream_type);\n             if (context->dev_id && AUDIO_DEVICE_OUT_SPEAKER) {\n                 recompute_flag = true;\n }\n            free(context);\n            status = 0;\n } else {\n ++active_stream_count;\n }\n }\n\n \n     if (status != 0) {\n         ALOGE(\"something wrong ... <<<--- Found NOTHING to remove ... ???? --->>>>>\");\n        pthread_mutex_unlock(&vol_listner_init_lock);\n        return status;\n     }\n \n if (active_stream_count == 0) {\n        current_gain_dep_cal_level = -1;\n        current_vol = 0.0;\n }\n\n if (recompute_flag) {\n        check_and_set_gain_dep_cal();\n }\n\n if (dumping_enabled) {\n        dump_list_l();\n }\n    pthread_mutex_unlock(&vol_listner_init_lock);\n return status;\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 608,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2015-6773",
    "code_before_change": "void FrameSelection::MoveRangeSelection(const VisiblePosition& base_position,\n                                        const VisiblePosition& extent_position,\n                                        TextGranularity granularity) {\n  SelectionInDOMTree new_selection =\n      SelectionInDOMTree::Builder()\n           .SetBaseAndExtentDeprecated(base_position.DeepEquivalent(),\n                                       extent_position.DeepEquivalent())\n           .SetAffinity(base_position.Affinity())\n          .SetIsHandleVisible(IsHandleVisible())\n           .Build();\n \n   if (new_selection.IsNone())\n    return;\n\n  const VisibleSelection& visible_selection =\n      CreateVisibleSelectionWithGranularity(new_selection, granularity);\n  if (visible_selection.IsNone())\n    return;\n\n  SelectionInDOMTree::Builder builder;\n  if (visible_selection.IsBaseFirst()) {\n    builder.SetBaseAndExtent(visible_selection.Start(),\n                             visible_selection.End());\n  } else {\n    builder.SetBaseAndExtent(visible_selection.End(),\n                              visible_selection.Start());\n   }\n   builder.SetAffinity(visible_selection.Affinity());\n  builder.SetIsHandleVisible(IsHandleVisible());\n   SetSelection(builder.Build(), SetSelectionData::Builder()\n                                     .SetShouldCloseTyping(true)\n                                     .SetShouldClearTypingStyle(true)\n                                     .SetGranularity(granularity)\n                                     .Build());\n }\n",
    "code_after_change": "void FrameSelection::MoveRangeSelection(const VisiblePosition& base_position,\n                                        const VisiblePosition& extent_position,\n                                        TextGranularity granularity) {\n  SelectionInDOMTree new_selection =\n      SelectionInDOMTree::Builder()\n           .SetBaseAndExtentDeprecated(base_position.DeepEquivalent(),\n                                       extent_position.DeepEquivalent())\n           .SetAffinity(base_position.Affinity())\n           .Build();\n \n   if (new_selection.IsNone())\n    return;\n\n  const VisibleSelection& visible_selection =\n      CreateVisibleSelectionWithGranularity(new_selection, granularity);\n  if (visible_selection.IsNone())\n    return;\n\n  SelectionInDOMTree::Builder builder;\n  if (visible_selection.IsBaseFirst()) {\n    builder.SetBaseAndExtent(visible_selection.Start(),\n                             visible_selection.End());\n  } else {\n    builder.SetBaseAndExtent(visible_selection.End(),\n                              visible_selection.Start());\n   }\n   builder.SetAffinity(visible_selection.Affinity());\n   SetSelection(builder.Build(), SetSelectionData::Builder()\n                                     .SetShouldCloseTyping(true)\n                                     .SetShouldClearTypingStyle(true)\n                                     .SetGranularity(granularity)\n                                    .SetShouldShowHandle(IsHandleVisible())\n                                     .Build());\n }\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 615,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-5199",
    "code_before_change": "bool DataReductionProxySettings::IsDataSaverEnabledByUser() const {\n//// static\n   if (params::ShouldForceEnableDataReductionProxy())\n     return true;\n \n  if (spdy_proxy_auth_enabled_.GetPrefName().empty())\n    return false;\n  return spdy_proxy_auth_enabled_.GetValue();\n }\n",
    "code_after_change": "bool DataReductionProxySettings::IsDataSaverEnabledByUser() const {\n//// static\nbool DataReductionProxySettings::IsDataSaverEnabledByUser(PrefService* prefs) {\n   if (params::ShouldForceEnableDataReductionProxy())\n     return true;\n \n  return prefs && prefs->GetBoolean(prefs::kDataSaverEnabled);\n }\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 620,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2011-2864",
    "code_before_change": "bool SubsetterImpl::ResolveCompositeGlyphs(const unsigned int* glyph_ids,\n                                           size_t glyph_count,\n                                           IntegerSet* glyph_id_processed) {\n  if (glyph_ids == NULL || glyph_count == 0 || glyph_id_processed == NULL) {\n    return false;\n  }\n\n  GlyphTablePtr glyph_table =\n      down_cast<GlyphTable*>(font_->GetTable(Tag::glyf));\n  LocaTablePtr loca_table = down_cast<LocaTable*>(font_->GetTable(Tag::loca));\n  if (glyph_table == NULL || loca_table == NULL) {\n    return false;\n  }\n\n  IntegerSet glyph_id_remaining;\n  glyph_id_remaining.insert(0);  // Always include glyph id 0.\n  for (size_t i = 0; i < glyph_count; ++i) {\n    glyph_id_remaining.insert(glyph_ids[i]);\n  }\n\n  while (!glyph_id_remaining.empty()) {\n    IntegerSet comp_glyph_id;\n    for (IntegerSet::iterator i = glyph_id_remaining.begin(),\n                              e = glyph_id_remaining.end(); i != e; ++i) {\n      if (*i < 0 || *i >= loca_table->NumGlyphs()) {\n        continue;\n      }\n\n      int32_t length = loca_table->GlyphLength(*i);\n      if (length == 0) {\n        continue;\n      }\n      int32_t offset = loca_table->GlyphOffset(*i);\n\n      GlyphPtr glyph;\n      glyph.Attach(glyph_table->GetGlyph(offset, length));\n      if (glyph == NULL) {\n        continue;\n      }\n\n      if (glyph->GlyphType() == GlyphType::kComposite) {\n        Ptr<GlyphTable::CompositeGlyph> comp_glyph =\n            down_cast<GlyphTable::CompositeGlyph*>(glyph.p_);\n        for (int32_t j = 0; j < comp_glyph->NumGlyphs(); ++j) {\n          int32_t glyph_id = comp_glyph->GlyphIndex(j);\n          if (glyph_id_processed->find(glyph_id) == glyph_id_processed->end() &&\n              glyph_id_remaining.find(glyph_id) == glyph_id_remaining.end()) {\n            comp_glyph_id.insert(comp_glyph->GlyphIndex(j));\n          }\n        }\n      }\n\n      glyph_id_processed->insert(*i);\n    }\n\n     glyph_id_remaining.clear();\n     glyph_id_remaining = comp_glyph_id;\n   }\n }\n",
    "code_after_change": "bool SubsetterImpl::ResolveCompositeGlyphs(const unsigned int* glyph_ids,\n                                           size_t glyph_count,\n                                           IntegerSet* glyph_id_processed) {\n  if (glyph_ids == NULL || glyph_count == 0 || glyph_id_processed == NULL) {\n    return false;\n  }\n\n  GlyphTablePtr glyph_table =\n      down_cast<GlyphTable*>(font_->GetTable(Tag::glyf));\n  LocaTablePtr loca_table = down_cast<LocaTable*>(font_->GetTable(Tag::loca));\n  if (glyph_table == NULL || loca_table == NULL) {\n    return false;\n  }\n\n  IntegerSet glyph_id_remaining;\n  glyph_id_remaining.insert(0);  // Always include glyph id 0.\n  for (size_t i = 0; i < glyph_count; ++i) {\n    glyph_id_remaining.insert(glyph_ids[i]);\n  }\n\n  while (!glyph_id_remaining.empty()) {\n    IntegerSet comp_glyph_id;\n    for (IntegerSet::iterator i = glyph_id_remaining.begin(),\n                              e = glyph_id_remaining.end(); i != e; ++i) {\n      if (*i < 0 || *i >= loca_table->NumGlyphs()) {\n        continue;\n      }\n\n      int32_t length = loca_table->GlyphLength(*i);\n      if (length == 0) {\n        continue;\n      }\n      int32_t offset = loca_table->GlyphOffset(*i);\n\n      GlyphPtr glyph;\n      glyph.Attach(glyph_table->GetGlyph(offset, length));\n      if (glyph == NULL) {\n        continue;\n      }\n\n      if (glyph->GlyphType() == GlyphType::kComposite) {\n        Ptr<GlyphTable::CompositeGlyph> comp_glyph =\n            down_cast<GlyphTable::CompositeGlyph*>(glyph.p_);\n        for (int32_t j = 0; j < comp_glyph->NumGlyphs(); ++j) {\n          int32_t glyph_id = comp_glyph->GlyphIndex(j);\n          if (glyph_id_processed->find(glyph_id) == glyph_id_processed->end() &&\n              glyph_id_remaining.find(glyph_id) == glyph_id_remaining.end()) {\n            comp_glyph_id.insert(comp_glyph->GlyphIndex(j));\n          }\n        }\n      }\n\n      glyph_id_processed->insert(*i);\n    }\n\n     glyph_id_remaining.clear();\n     glyph_id_remaining = comp_glyph_id;\n   }\n\n  return true;\n }\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 623,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2017-5009",
    "code_before_change": " String InspectorPageAgent::CachedResourceTypeJson(\n     const Resource& cached_resource) {\n  return ResourceTypeJson(CachedResourceType(cached_resource));\n }\n",
    "code_after_change": " String InspectorPageAgent::CachedResourceTypeJson(\n     const Resource& cached_resource) {\n  return ResourceTypeJson(ToResourceType(cached_resource.GetType()));\n }\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 624,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2012-5157",
    "code_before_change": "     void registerURL(const char* file, const char* mimeType)\n     {\n        registerURL(file, file, mimeType);\n     }\n",
    "code_after_change": "     void registerURL(const char* file, const char* mimeType)\n     {\n        registerMockedURLLoad(KURL(m_baseUrl, file), WebString::fromUTF8(file), m_folder, WebString::fromUTF8(mimeType));\n     }\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 627,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-7416",
    "code_before_change": "PHP_FUNCTION( msgfmt_format_message )\n{\n\tzval       *args;\n\tUChar      *spattern = NULL;\n\tint         spattern_len = 0;\n\tchar       *pattern = NULL;\n\tint         pattern_len = 0;\n\tconst char *slocale = NULL;\n\tint         slocale_len = 0;\n\tMessageFormatter_object mf = {0};\n\tMessageFormatter_object *mfo = &mf;\n\n\t/* Parse parameters. */\n\tif( zend_parse_method_parameters( ZEND_NUM_ARGS() TSRMLS_CC, getThis(), \"ssa\",\n\t\t  &slocale, &slocale_len, &pattern, &pattern_len, &args ) == FAILURE )\n\t{\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n\t\t\t\"msgfmt_format_message: unable to parse input params\", 0 TSRMLS_CC );\n\n \t\tRETURN_FALSE;\n \t}\n \n \tmsgformat_data_init(&mfo->mf_data TSRMLS_CC);\n \n \tif(pattern && pattern_len) {\n\t\tintl_convert_utf8_to_utf16(&spattern, &spattern_len, pattern, pattern_len, &INTL_DATA_ERROR_CODE(mfo));\n\t\tif( U_FAILURE(INTL_DATA_ERROR_CODE((mfo))) )\n\t\t{\n\t\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n\t\t\t\t\"msgfmt_format_message: error converting pattern to UTF-16\", 0 TSRMLS_CC );\n\t\t\tRETURN_FALSE;\n\t\t}\n\t} else {\n\t\tspattern_len = 0;\n\t\tspattern = NULL;\n\t}\n\n\tif(slocale_len == 0) {\n\t\tslocale = intl_locale_get_default(TSRMLS_C);\n\t}\n\n#ifdef MSG_FORMAT_QUOTE_APOS\n\tif(msgformat_fix_quotes(&spattern, &spattern_len, &INTL_DATA_ERROR_CODE(mfo)) != SUCCESS) {\n\t\tintl_error_set( NULL, U_INVALID_FORMAT_ERROR,\n\t\t\t\"msgfmt_format_message: error converting pattern to quote-friendly format\", 0 TSRMLS_CC );\n\t\tRETURN_FALSE;\n\t}\n#endif\n\n\t/* Create an ICU message formatter. */\n\tMSG_FORMAT_OBJECT(mfo) = umsg_open(spattern, spattern_len, slocale, NULL, &INTL_DATA_ERROR_CODE(mfo));\n\tif(spattern && spattern_len) {\n\t\tefree(spattern);\n\t}\n\tINTL_METHOD_CHECK_STATUS(mfo, \"Creating message formatter failed\");\n\n\tmsgfmt_do_format(mfo, args, return_value TSRMLS_CC);\n\n\t/* drop the temporary formatter */\n\tmsgformat_data_free(&mfo->mf_data TSRMLS_CC);\n}\n",
    "code_after_change": "PHP_FUNCTION( msgfmt_format_message )\n{\n\tzval       *args;\n\tUChar      *spattern = NULL;\n\tint         spattern_len = 0;\n\tchar       *pattern = NULL;\n\tint         pattern_len = 0;\n\tconst char *slocale = NULL;\n\tint         slocale_len = 0;\n\tMessageFormatter_object mf = {0};\n\tMessageFormatter_object *mfo = &mf;\n\n\t/* Parse parameters. */\n\tif( zend_parse_method_parameters( ZEND_NUM_ARGS() TSRMLS_CC, getThis(), \"ssa\",\n\t\t  &slocale, &slocale_len, &pattern, &pattern_len, &args ) == FAILURE )\n\t{\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n\t\t\t\"msgfmt_format_message: unable to parse input params\", 0 TSRMLS_CC );\n\n \t\tRETURN_FALSE;\n \t}\n \n\tINTL_CHECK_LOCALE_LEN(slocale_len);\n\n \tmsgformat_data_init(&mfo->mf_data TSRMLS_CC);\n \n \tif(pattern && pattern_len) {\n\t\tintl_convert_utf8_to_utf16(&spattern, &spattern_len, pattern, pattern_len, &INTL_DATA_ERROR_CODE(mfo));\n\t\tif( U_FAILURE(INTL_DATA_ERROR_CODE((mfo))) )\n\t\t{\n\t\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n\t\t\t\t\"msgfmt_format_message: error converting pattern to UTF-16\", 0 TSRMLS_CC );\n\t\t\tRETURN_FALSE;\n\t\t}\n\t} else {\n\t\tspattern_len = 0;\n\t\tspattern = NULL;\n\t}\n\n\tif(slocale_len == 0) {\n\t\tslocale = intl_locale_get_default(TSRMLS_C);\n\t}\n\n#ifdef MSG_FORMAT_QUOTE_APOS\n\tif(msgformat_fix_quotes(&spattern, &spattern_len, &INTL_DATA_ERROR_CODE(mfo)) != SUCCESS) {\n\t\tintl_error_set( NULL, U_INVALID_FORMAT_ERROR,\n\t\t\t\"msgfmt_format_message: error converting pattern to quote-friendly format\", 0 TSRMLS_CC );\n\t\tRETURN_FALSE;\n\t}\n#endif\n\n\t/* Create an ICU message formatter. */\n\tMSG_FORMAT_OBJECT(mfo) = umsg_open(spattern, spattern_len, slocale, NULL, &INTL_DATA_ERROR_CODE(mfo));\n\tif(spattern && spattern_len) {\n\t\tefree(spattern);\n\t}\n\tINTL_METHOD_CHECK_STATUS(mfo, \"Creating message formatter failed\");\n\n\tmsgfmt_do_format(mfo, args, return_value TSRMLS_CC);\n\n\t/* drop the temporary formatter */\n\tmsgformat_data_free(&mfo->mf_data TSRMLS_CC);\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 634,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-5199",
    "code_before_change": "DataReductionProxySettings::~DataReductionProxySettings() {\n  spdy_proxy_auth_enabled_.Destroy();\n}\n",
    "code_after_change": "DataReductionProxySettings::~DataReductionProxySettings() {\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 635,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-1683",
    "code_before_change": "xsltCopyTreeInternal(xsltTransformContextPtr ctxt,\n\t\t     xmlNodePtr invocNode,\n\t\t     xmlNodePtr node,\n\t\t     xmlNodePtr insert, int isLRE, int topElemVisited)\n{\n    xmlNodePtr copy;\n\n    if (node == NULL)\n\treturn(NULL);\n    switch (node->type) {\n        case XML_ELEMENT_NODE:\n        case XML_ENTITY_REF_NODE:\n        case XML_ENTITY_NODE:\n        case XML_PI_NODE:\n        case XML_COMMENT_NODE:\n        case XML_DOCUMENT_NODE:\n        case XML_HTML_DOCUMENT_NODE:\n#ifdef LIBXML_DOCB_ENABLED\n        case XML_DOCB_DOCUMENT_NODE:\n#endif\n\t    break;\n        case XML_TEXT_NODE: {\n\t    int noenc = (node->name == xmlStringTextNoenc);\n\t    return(xsltCopyTextString(ctxt, insert, node->content, noenc));\n\t    }\n        case XML_CDATA_SECTION_NODE:\n\t    return(xsltCopyTextString(ctxt, insert, node->content, 0));\n        case XML_ATTRIBUTE_NODE:\n\t    return((xmlNodePtr)\n\t\txsltShallowCopyAttr(ctxt, invocNode, insert, (xmlAttrPtr) node));\n        case XML_NAMESPACE_DECL:\n\t    return((xmlNodePtr) xsltShallowCopyNsNode(ctxt, invocNode,\n\t\tinsert, (xmlNsPtr) node));\n\n        case XML_DOCUMENT_TYPE_NODE:\n        case XML_DOCUMENT_FRAG_NODE:\n        case XML_NOTATION_NODE:\n        case XML_DTD_NODE:\n        case XML_ELEMENT_DECL:\n        case XML_ATTRIBUTE_DECL:\n        case XML_ENTITY_DECL:\n        case XML_XINCLUDE_START:\n        case XML_XINCLUDE_END:\n            return(NULL);\n    }\n    if (XSLT_IS_RES_TREE_FRAG(node)) {\n\tif (node->children != NULL)\n\t    copy = xsltCopyTreeList(ctxt, invocNode,\n\t\tnode->children, insert, 0, 0);\n\telse\n\t    copy = NULL;\n\treturn(copy);\n    }\n    copy = xmlDocCopyNode(node, insert->doc, 0);\n     if (copy != NULL) {\n \tcopy->doc = ctxt->output;\n \tcopy = xsltAddChild(insert, copy);\n \t/*\n \t * The node may have been coalesced into another text node.\n \t */\n\tif (insert->last != copy)\n\t    return(insert->last);\n\tcopy->next = NULL;\n\n\tif (node->type == XML_ELEMENT_NODE) {\n\t    /*\n\t    * Copy in-scope namespace nodes.\n\t    *\n\t    * REVISIT: Since we try to reuse existing in-scope ns-decls by\n\t    *  using xmlSearchNsByHref(), this will eventually change\n\t    *  the prefix of an original ns-binding; thus it might\n\t    *  break QNames in element/attribute content.\n\t    * OPTIMIZE TODO: If we had a xmlNsPtr * on the transformation\n\t    *  context, plus a ns-lookup function, which writes directly\n\t    *  to a given list, then we wouldn't need to create/free the\n\t    *  nsList every time.\n\t    */\n\t    if ((topElemVisited == 0) &&\n\t\t(node->parent != NULL) &&\n\t\t(node->parent->type != XML_DOCUMENT_NODE) &&\n\t\t(node->parent->type != XML_HTML_DOCUMENT_NODE))\n\t    {\n\t\txmlNsPtr *nsList, *curns, ns;\n\n\t\t/*\n\t\t* If this is a top-most element in a tree to be\n\t\t* copied, then we need to ensure that all in-scope\n\t\t* namespaces are copied over. For nodes deeper in the\n\t\t* tree, it is sufficient to reconcile only the ns-decls\n\t\t* (node->nsDef entries).\n\t\t*/\n\n\t\tnsList = xmlGetNsList(node->doc, node);\n\t\tif (nsList != NULL) {\n\t\t    curns = nsList;\n\t\t    do {\n\t\t\t/*\n\t\t\t* Search by prefix first in order to break as less\n\t\t\t* QNames in element/attribute content as possible.\n\t\t\t*/\n\t\t\tns = xmlSearchNs(insert->doc, insert,\n\t\t\t    (*curns)->prefix);\n\n\t\t\tif ((ns == NULL) ||\n\t\t\t    (! xmlStrEqual(ns->href, (*curns)->href)))\n\t\t\t{\n\t\t\t    ns = NULL;\n\t\t\t    /*\n\t\t\t    * Search by namespace name.\n\t\t\t    * REVISIT TODO: Currently disabled.\n\t\t\t    */\n#if 0\n\t\t\t    ns = xmlSearchNsByHref(insert->doc,\n\t\t\t\tinsert, (*curns)->href);\n#endif\n\t\t\t}\n\t\t\tif (ns == NULL) {\n\t\t\t    /*\n\t\t\t    * Declare a new namespace on the copied element.\n\t\t\t    */\n\t\t\t    ns = xmlNewNs(copy, (*curns)->href,\n\t\t\t\t(*curns)->prefix);\n\t\t\t    /* TODO: Handle errors */\n\t\t\t}\n\t\t\tif (node->ns == *curns) {\n\t\t\t    /*\n\t\t\t    * If this was the original's namespace then set\n\t\t\t    * the generated counterpart on the copy.\n\t\t\t    */\n\t\t\t    copy->ns = ns;\n\t\t\t}\n\t\t\tcurns++;\n\t\t    } while (*curns != NULL);\n\t\t    xmlFree(nsList);\n\t\t}\n\t    } else if (node->nsDef != NULL) {\n\t\t/*\n\t\t* Copy over all namespace declaration attributes.\n\t\t*/\n\t\tif (node->nsDef != NULL) {\n\t\t    if (isLRE)\n\t\t\txsltCopyNamespaceList(ctxt, copy, node->nsDef);\n\t\t    else\n\t\t\txsltCopyNamespaceListInternal(copy, node->nsDef);\n\t\t}\n\t    }\n\t    /*\n\t    * Set the namespace.\n\t    */\n\t    if (node->ns != NULL) {\n\t\tif (copy->ns == NULL) {\n\t\t    /*\n\t\t    * This will map copy->ns to one of the newly created\n\t\t    * in-scope ns-decls, OR create a new ns-decl on @copy.\n\t\t    */\n\t\t    copy->ns = xsltGetSpecialNamespace(ctxt, invocNode,\n\t\t\tnode->ns->href, node->ns->prefix, copy);\n\t\t}\n\t    } else if ((insert->type == XML_ELEMENT_NODE) &&\n\t\t(insert->ns != NULL))\n\t    {\n\t\t/*\n\t\t* \"Undeclare\" the default namespace on @copy with xmlns=\"\".\n\t\t*/\n\t\txsltGetSpecialNamespace(ctxt, invocNode, NULL, NULL, copy);\n\t    }\n\t    /*\n\t    * Copy attribute nodes.\n\t    */\n\t    if (node->properties != NULL) {\n\t\txsltCopyAttrListNoOverwrite(ctxt, invocNode,\n\t\t    copy, node->properties);\n\t    }\n\t    if (topElemVisited == 0)\n\t\ttopElemVisited = 1;\n\t}\n\t/*\n\t* Copy the subtree.\n\t*/\n\tif (node->children != NULL) {\n\t    xsltCopyTreeList(ctxt, invocNode,\n\t\tnode->children, copy, isLRE, topElemVisited);\n\t}\n    } else {\n\txsltTransformError(ctxt, NULL, invocNode,\n\t    \"xsltCopyTreeInternal: Copying of '%s' failed.\\n\", node->name);\n    }\n    return(copy);\n}\n",
    "code_after_change": "xsltCopyTreeInternal(xsltTransformContextPtr ctxt,\n\t\t     xmlNodePtr invocNode,\n\t\t     xmlNodePtr node,\n\t\t     xmlNodePtr insert, int isLRE, int topElemVisited)\n{\n    xmlNodePtr copy;\n\n    if (node == NULL)\n\treturn(NULL);\n    switch (node->type) {\n        case XML_ELEMENT_NODE:\n        case XML_ENTITY_REF_NODE:\n        case XML_ENTITY_NODE:\n        case XML_PI_NODE:\n        case XML_COMMENT_NODE:\n        case XML_DOCUMENT_NODE:\n        case XML_HTML_DOCUMENT_NODE:\n#ifdef LIBXML_DOCB_ENABLED\n        case XML_DOCB_DOCUMENT_NODE:\n#endif\n\t    break;\n        case XML_TEXT_NODE: {\n\t    int noenc = (node->name == xmlStringTextNoenc);\n\t    return(xsltCopyTextString(ctxt, insert, node->content, noenc));\n\t    }\n        case XML_CDATA_SECTION_NODE:\n\t    return(xsltCopyTextString(ctxt, insert, node->content, 0));\n        case XML_ATTRIBUTE_NODE:\n\t    return((xmlNodePtr)\n\t\txsltShallowCopyAttr(ctxt, invocNode, insert, (xmlAttrPtr) node));\n        case XML_NAMESPACE_DECL:\n\t    return((xmlNodePtr) xsltShallowCopyNsNode(ctxt, invocNode,\n\t\tinsert, (xmlNsPtr) node));\n\n        case XML_DOCUMENT_TYPE_NODE:\n        case XML_DOCUMENT_FRAG_NODE:\n        case XML_NOTATION_NODE:\n        case XML_DTD_NODE:\n        case XML_ELEMENT_DECL:\n        case XML_ATTRIBUTE_DECL:\n        case XML_ENTITY_DECL:\n        case XML_XINCLUDE_START:\n        case XML_XINCLUDE_END:\n            return(NULL);\n    }\n    if (XSLT_IS_RES_TREE_FRAG(node)) {\n\tif (node->children != NULL)\n\t    copy = xsltCopyTreeList(ctxt, invocNode,\n\t\tnode->children, insert, 0, 0);\n\telse\n\t    copy = NULL;\n\treturn(copy);\n    }\n    copy = xmlDocCopyNode(node, insert->doc, 0);\n     if (copy != NULL) {\n \tcopy->doc = ctxt->output;\n \tcopy = xsltAddChild(insert, copy);\n        if (copy == NULL) {\n            xsltTransformError(ctxt, NULL, invocNode,\n            \"xsltCopyTreeInternal: Copying of '%s' failed.\\n\", node->name);\n            return (copy);\n        }\n \t/*\n \t * The node may have been coalesced into another text node.\n \t */\n\tif (insert->last != copy)\n\t    return(insert->last);\n\tcopy->next = NULL;\n\n\tif (node->type == XML_ELEMENT_NODE) {\n\t    /*\n\t    * Copy in-scope namespace nodes.\n\t    *\n\t    * REVISIT: Since we try to reuse existing in-scope ns-decls by\n\t    *  using xmlSearchNsByHref(), this will eventually change\n\t    *  the prefix of an original ns-binding; thus it might\n\t    *  break QNames in element/attribute content.\n\t    * OPTIMIZE TODO: If we had a xmlNsPtr * on the transformation\n\t    *  context, plus a ns-lookup function, which writes directly\n\t    *  to a given list, then we wouldn't need to create/free the\n\t    *  nsList every time.\n\t    */\n\t    if ((topElemVisited == 0) &&\n\t\t(node->parent != NULL) &&\n\t\t(node->parent->type != XML_DOCUMENT_NODE) &&\n\t\t(node->parent->type != XML_HTML_DOCUMENT_NODE))\n\t    {\n\t\txmlNsPtr *nsList, *curns, ns;\n\n\t\t/*\n\t\t* If this is a top-most element in a tree to be\n\t\t* copied, then we need to ensure that all in-scope\n\t\t* namespaces are copied over. For nodes deeper in the\n\t\t* tree, it is sufficient to reconcile only the ns-decls\n\t\t* (node->nsDef entries).\n\t\t*/\n\n\t\tnsList = xmlGetNsList(node->doc, node);\n\t\tif (nsList != NULL) {\n\t\t    curns = nsList;\n\t\t    do {\n\t\t\t/*\n\t\t\t* Search by prefix first in order to break as less\n\t\t\t* QNames in element/attribute content as possible.\n\t\t\t*/\n\t\t\tns = xmlSearchNs(insert->doc, insert,\n\t\t\t    (*curns)->prefix);\n\n\t\t\tif ((ns == NULL) ||\n\t\t\t    (! xmlStrEqual(ns->href, (*curns)->href)))\n\t\t\t{\n\t\t\t    ns = NULL;\n\t\t\t    /*\n\t\t\t    * Search by namespace name.\n\t\t\t    * REVISIT TODO: Currently disabled.\n\t\t\t    */\n#if 0\n\t\t\t    ns = xmlSearchNsByHref(insert->doc,\n\t\t\t\tinsert, (*curns)->href);\n#endif\n\t\t\t}\n\t\t\tif (ns == NULL) {\n\t\t\t    /*\n\t\t\t    * Declare a new namespace on the copied element.\n\t\t\t    */\n\t\t\t    ns = xmlNewNs(copy, (*curns)->href,\n\t\t\t\t(*curns)->prefix);\n\t\t\t    /* TODO: Handle errors */\n\t\t\t}\n\t\t\tif (node->ns == *curns) {\n\t\t\t    /*\n\t\t\t    * If this was the original's namespace then set\n\t\t\t    * the generated counterpart on the copy.\n\t\t\t    */\n\t\t\t    copy->ns = ns;\n\t\t\t}\n\t\t\tcurns++;\n\t\t    } while (*curns != NULL);\n\t\t    xmlFree(nsList);\n\t\t}\n\t    } else if (node->nsDef != NULL) {\n\t\t/*\n\t\t* Copy over all namespace declaration attributes.\n\t\t*/\n\t\tif (node->nsDef != NULL) {\n\t\t    if (isLRE)\n\t\t\txsltCopyNamespaceList(ctxt, copy, node->nsDef);\n\t\t    else\n\t\t\txsltCopyNamespaceListInternal(copy, node->nsDef);\n\t\t}\n\t    }\n\t    /*\n\t    * Set the namespace.\n\t    */\n\t    if (node->ns != NULL) {\n\t\tif (copy->ns == NULL) {\n\t\t    /*\n\t\t    * This will map copy->ns to one of the newly created\n\t\t    * in-scope ns-decls, OR create a new ns-decl on @copy.\n\t\t    */\n\t\t    copy->ns = xsltGetSpecialNamespace(ctxt, invocNode,\n\t\t\tnode->ns->href, node->ns->prefix, copy);\n\t\t}\n\t    } else if ((insert->type == XML_ELEMENT_NODE) &&\n\t\t(insert->ns != NULL))\n\t    {\n\t\t/*\n\t\t* \"Undeclare\" the default namespace on @copy with xmlns=\"\".\n\t\t*/\n\t\txsltGetSpecialNamespace(ctxt, invocNode, NULL, NULL, copy);\n\t    }\n\t    /*\n\t    * Copy attribute nodes.\n\t    */\n\t    if (node->properties != NULL) {\n\t\txsltCopyAttrListNoOverwrite(ctxt, invocNode,\n\t\t    copy, node->properties);\n\t    }\n\t    if (topElemVisited == 0)\n\t\ttopElemVisited = 1;\n\t}\n\t/*\n\t* Copy the subtree.\n\t*/\n\tif (node->children != NULL) {\n\t    xsltCopyTreeList(ctxt, invocNode,\n\t\tnode->children, copy, isLRE, topElemVisited);\n\t}\n    } else {\n\txsltTransformError(ctxt, NULL, invocNode,\n\t    \"xsltCopyTreeInternal: Copying of '%s' failed.\\n\", node->name);\n    }\n    return(copy);\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 642,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-1683",
    "code_before_change": "xsltNumberFormat(xsltTransformContextPtr ctxt,\n\t\t xsltNumberDataPtr data,\n\t\t xmlNodePtr node)\n{\n    xmlBufferPtr output = NULL;\n     int amount, i;\n     double number;\n     xsltFormat tokens;\n    int tempformat = 0;\n \n    if ((data->format == NULL) && (data->has_format != 0)) {\n\tdata->format = xsltEvalAttrValueTemplate(ctxt, data->node,\n \t\t\t\t\t     (const xmlChar *) \"format\",\n \t\t\t\t\t     XSLT_NAMESPACE);\n\ttempformat = 1;\n    }\n    if (data->format == NULL) {\n\treturn;\n     }\n \n     output = xmlBufferCreate();\n     if (output == NULL)\n \tgoto XSLT_NUMBER_FORMAT_END;\n \n    xsltNumberFormatTokenize(data->format, &tokens);\n     /*\n      * Evaluate the XPath expression to find the value(s)\n      */\n    if (data->value) {\n\tamount = xsltNumberFormatGetValue(ctxt->xpathCtxt,\n\t\t\t\t\t  node,\n\t\t\t\t\t  data->value,\n\t\t\t\t\t  &number);\n\tif (amount == 1) {\n\t    xsltNumberFormatInsertNumbers(data,\n\t\t\t\t\t  &number,\n\t\t\t\t\t  1,\n\t\t\t\t\t  &tokens,\n\t\t\t\t\t  output);\n\t}\n\n    } else if (data->level) {\n\n\tif (xmlStrEqual(data->level, (const xmlChar *) \"single\")) {\n\t    amount = xsltNumberFormatGetMultipleLevel(ctxt,\n\t\t\t\t\t\t      node,\n \t\t\t\t\t\t      data->countPat,\n \t\t\t\t\t\t      data->fromPat,\n \t\t\t\t\t\t      &number,\n\t\t\t\t\t\t      1,\n\t\t\t\t\t\t      data->doc,\n\t\t\t\t\t\t      data->node);\n \t    if (amount == 1) {\n \t\txsltNumberFormatInsertNumbers(data,\n \t\t\t\t\t      &number,\n\t\t\t\t\t      1,\n\t\t\t\t\t      &tokens,\n\t\t\t\t\t      output);\n\t    }\n\t} else if (xmlStrEqual(data->level, (const xmlChar *) \"multiple\")) {\n\t    double numarray[1024];\n\t    int max = sizeof(numarray)/sizeof(numarray[0]);\n\t    amount = xsltNumberFormatGetMultipleLevel(ctxt,\n\t\t\t\t\t\t      node,\n \t\t\t\t\t\t      data->countPat,\n \t\t\t\t\t\t      data->fromPat,\n \t\t\t\t\t\t      numarray,\n\t\t\t\t\t\t      max,\n\t\t\t\t\t\t      data->doc,\n\t\t\t\t\t\t      data->node);\n \t    if (amount > 0) {\n \t\txsltNumberFormatInsertNumbers(data,\n \t\t\t\t\t      numarray,\n\t\t\t\t\t      amount,\n\t\t\t\t\t      &tokens,\n\t\t\t\t\t      output);\n\t    }\n\t} else if (xmlStrEqual(data->level, (const xmlChar *) \"any\")) {\n\t    amount = xsltNumberFormatGetAnyLevel(ctxt,\n \t\t\t\t\t\t node,\n \t\t\t\t\t\t data->countPat,\n \t\t\t\t\t\t data->fromPat,\n\t\t\t\t\t\t &number,\n\t\t\t\t\t\t data->doc,\n\t\t\t\t\t\t data->node);\n \t    if (amount > 0) {\n \t\txsltNumberFormatInsertNumbers(data,\n \t\t\t\t\t      &number,\n\t\t\t\t\t      1,\n\t\t\t\t\t      &tokens,\n\t\t\t\t\t      output);\n\t    }\n\t}\n    }\n     /* Insert number as text node */\n     xsltCopyTextString(ctxt, ctxt->insert, xmlBufferContent(output), 0);\n \n     if (tokens.start != NULL)\n \txmlFree(tokens.start);\n     if (tokens.end != NULL)\n\txmlFree(tokens.end);\n    for (i = 0;i < tokens.nTokens;i++) {\n \tif (tokens.tokens[i].separator != NULL)\n \t    xmlFree(tokens.tokens[i].separator);\n     }\nXSLT_NUMBER_FORMAT_END:\n    if (tempformat == 1) {\n\t/* The format need to be recomputed each time */\n\tdata->format = NULL;\n    }\n    if (output != NULL)\n\txmlBufferFree(output);\n }\n",
    "code_after_change": "xsltNumberFormat(xsltTransformContextPtr ctxt,\n\t\t xsltNumberDataPtr data,\n\t\t xmlNodePtr node)\n{\n    xmlBufferPtr output = NULL;\n     int amount, i;\n     double number;\n     xsltFormat tokens;\n \n    if (data->format != NULL) {\n        xsltNumberFormatTokenize(data->format, &tokens);\n    }\n    else {\n        xmlChar *format;\n\n\t/* The format needs to be recomputed each time */\n        if (data->has_format == 0)\n            return;\n\tformat = xsltEvalAttrValueTemplate(ctxt, data->node,\n \t\t\t\t\t     (const xmlChar *) \"format\",\n \t\t\t\t\t     XSLT_NAMESPACE);\n        if (format == NULL)\n            return;\n        xsltNumberFormatTokenize(format, &tokens);\n\txmlFree(format);\n     }\n \n     output = xmlBufferCreate();\n     if (output == NULL)\n \tgoto XSLT_NUMBER_FORMAT_END;\n \n     /*\n      * Evaluate the XPath expression to find the value(s)\n      */\n    if (data->value) {\n\tamount = xsltNumberFormatGetValue(ctxt->xpathCtxt,\n\t\t\t\t\t  node,\n\t\t\t\t\t  data->value,\n\t\t\t\t\t  &number);\n\tif (amount == 1) {\n\t    xsltNumberFormatInsertNumbers(data,\n\t\t\t\t\t  &number,\n\t\t\t\t\t  1,\n\t\t\t\t\t  &tokens,\n\t\t\t\t\t  output);\n\t}\n\n    } else if (data->level) {\n\n\tif (xmlStrEqual(data->level, (const xmlChar *) \"single\")) {\n\t    amount = xsltNumberFormatGetMultipleLevel(ctxt,\n\t\t\t\t\t\t      node,\n \t\t\t\t\t\t      data->countPat,\n \t\t\t\t\t\t      data->fromPat,\n \t\t\t\t\t\t      &number,\n\t\t\t\t\t\t      1);\n \t    if (amount == 1) {\n \t\txsltNumberFormatInsertNumbers(data,\n \t\t\t\t\t      &number,\n\t\t\t\t\t      1,\n\t\t\t\t\t      &tokens,\n\t\t\t\t\t      output);\n\t    }\n\t} else if (xmlStrEqual(data->level, (const xmlChar *) \"multiple\")) {\n\t    double numarray[1024];\n\t    int max = sizeof(numarray)/sizeof(numarray[0]);\n\t    amount = xsltNumberFormatGetMultipleLevel(ctxt,\n\t\t\t\t\t\t      node,\n \t\t\t\t\t\t      data->countPat,\n \t\t\t\t\t\t      data->fromPat,\n \t\t\t\t\t\t      numarray,\n\t\t\t\t\t\t      max);\n \t    if (amount > 0) {\n \t\txsltNumberFormatInsertNumbers(data,\n \t\t\t\t\t      numarray,\n\t\t\t\t\t      amount,\n\t\t\t\t\t      &tokens,\n\t\t\t\t\t      output);\n\t    }\n\t} else if (xmlStrEqual(data->level, (const xmlChar *) \"any\")) {\n\t    amount = xsltNumberFormatGetAnyLevel(ctxt,\n \t\t\t\t\t\t node,\n \t\t\t\t\t\t data->countPat,\n \t\t\t\t\t\t data->fromPat,\n\t\t\t\t\t\t &number);\n \t    if (amount > 0) {\n \t\txsltNumberFormatInsertNumbers(data,\n \t\t\t\t\t      &number,\n\t\t\t\t\t      1,\n\t\t\t\t\t      &tokens,\n\t\t\t\t\t      output);\n\t    }\n\t}\n    }\n     /* Insert number as text node */\n     xsltCopyTextString(ctxt, ctxt->insert, xmlBufferContent(output), 0);\n \n    xmlBufferFree(output);\n\nXSLT_NUMBER_FORMAT_END:\n     if (tokens.start != NULL)\n \txmlFree(tokens.start);\n     if (tokens.end != NULL)\n\txmlFree(tokens.end);\n    for (i = 0;i < tokens.nTokens;i++) {\n \tif (tokens.tokens[i].separator != NULL)\n \t    xmlFree(tokens.tokens[i].separator);\n     }\n }\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 647,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2014-9672",
    "code_before_change": "  parse_fond( char*   fond_data,\n              short*  have_sfnt,\n              ResID*  sfnt_id,\n              Str255  lwfn_file_name,\n              short   face_index )\n  {\n    AsscEntry*  assoc;\n    AsscEntry*  base_assoc;\n    FamRec*     fond;\n\n\n    *sfnt_id          = 0;\n    *have_sfnt        = 0;\n    lwfn_file_name[0] = 0;\n\n    fond       = (FamRec*)fond_data;\n    assoc      = (AsscEntry*)( fond_data + sizeof ( FamRec ) + 2 );\n    base_assoc = assoc;\n\n    /* the maximum faces in a FOND is 48, size of StyleTable.indexes[] */\n    if ( 47 < face_index )\n      return;\n\n    /* Let's do a little range checking before we get too excited here */\n    if ( face_index < count_faces_sfnt( fond_data ) )\n    {\n      assoc += face_index;        /* add on the face_index! */\n\n      /* if the face at this index is not scalable,\n         fall back to the first one (old behavior) */\n      if ( EndianS16_BtoN( assoc->fontSize ) == 0 )\n      {\n        *have_sfnt = 1;\n        *sfnt_id   = EndianS16_BtoN( assoc->fontID );\n      }\n      else if ( base_assoc->fontSize == 0 )\n      {\n        *have_sfnt = 1;\n        *sfnt_id   = EndianS16_BtoN( base_assoc->fontID );\n      }\n    }\n\n    if ( EndianS32_BtoN( fond->ffStylOff ) )\n    {\n      unsigned char*  p = (unsigned char*)fond_data;\n      StyleTable*     style;\n      unsigned short  string_count;\n      char            ps_name[256];\n      unsigned char*  names[64];\n      int             i;\n\n\n      p += EndianS32_BtoN( fond->ffStylOff );\n       style = (StyleTable*)p;\n       p += sizeof ( StyleTable );\n       string_count = EndianS16_BtoN( *(short*)(p) );\n       p += sizeof ( short );\n \n      for ( i = 0; i < string_count && i < 64; i++ )\n       {\n         names[i] = p;\n         p       += names[i][0];\n      }\n\n      {\n        size_t  ps_name_len = (size_t)names[0][0];\n\n\n        if ( ps_name_len != 0 )\n        {\n          ft_memcpy(ps_name, names[0] + 1, ps_name_len);\n          ps_name[ps_name_len] = 0;\n           ps_name[ps_name_len] = 0;\n         }\n         if ( style->indexes[face_index] > 1 &&\n             style->indexes[face_index] <= FT_MIN( string_count, 64 ) )\n         {\n           unsigned char*  suffixes = names[style->indexes[face_index] - 1];\n          for ( i = 1; i <= suffixes[0]; i++ )\n          {\n            unsigned char*  s;\n            size_t          j = suffixes[i] - 1;\n\n\n            if ( j < string_count && ( s = names[j] ) != NULL )\n            {\n              size_t  s_len = (size_t)s[0];\n\n\n              if ( s_len != 0 && ps_name_len + s_len < sizeof ( ps_name ) )\n              {\n                ft_memcpy( ps_name + ps_name_len, s + 1, s_len );\n                ps_name_len += s_len;\n                ps_name[ps_name_len] = 0;\n              }\n            }\n          }\n        }\n      }\n\n      create_lwfn_name( ps_name, lwfn_file_name );\n    }\n  }\n",
    "code_after_change": "  parse_fond( char*   fond_data,\n              short*  have_sfnt,\n              ResID*  sfnt_id,\n              Str255  lwfn_file_name,\n              short   face_index )\n  {\n    AsscEntry*  assoc;\n    AsscEntry*  base_assoc;\n    FamRec*     fond;\n\n\n    *sfnt_id          = 0;\n    *have_sfnt        = 0;\n    lwfn_file_name[0] = 0;\n\n    fond       = (FamRec*)fond_data;\n    assoc      = (AsscEntry*)( fond_data + sizeof ( FamRec ) + 2 );\n    base_assoc = assoc;\n\n    /* the maximum faces in a FOND is 48, size of StyleTable.indexes[] */\n    if ( 47 < face_index )\n      return;\n\n    /* Let's do a little range checking before we get too excited here */\n    if ( face_index < count_faces_sfnt( fond_data ) )\n    {\n      assoc += face_index;        /* add on the face_index! */\n\n      /* if the face at this index is not scalable,\n         fall back to the first one (old behavior) */\n      if ( EndianS16_BtoN( assoc->fontSize ) == 0 )\n      {\n        *have_sfnt = 1;\n        *sfnt_id   = EndianS16_BtoN( assoc->fontID );\n      }\n      else if ( base_assoc->fontSize == 0 )\n      {\n        *have_sfnt = 1;\n        *sfnt_id   = EndianS16_BtoN( base_assoc->fontID );\n      }\n    }\n\n    if ( EndianS32_BtoN( fond->ffStylOff ) )\n    {\n      unsigned char*  p = (unsigned char*)fond_data;\n      StyleTable*     style;\n      unsigned short  string_count;\n      char            ps_name[256];\n      unsigned char*  names[64];\n      int             i;\n\n\n      p += EndianS32_BtoN( fond->ffStylOff );\n       style = (StyleTable*)p;\n       p += sizeof ( StyleTable );\n       string_count = EndianS16_BtoN( *(short*)(p) );\n      string_count = FT_MIN( 64, string_count );\n       p += sizeof ( short );\n \n      for ( i = 0; i < string_count; i++ )\n       {\n         names[i] = p;\n         p       += names[i][0];\n      }\n\n      {\n        size_t  ps_name_len = (size_t)names[0][0];\n\n\n        if ( ps_name_len != 0 )\n        {\n          ft_memcpy(ps_name, names[0] + 1, ps_name_len);\n          ps_name[ps_name_len] = 0;\n           ps_name[ps_name_len] = 0;\n         }\n         if ( style->indexes[face_index] > 1 &&\n             style->indexes[face_index] <= string_count )\n         {\n           unsigned char*  suffixes = names[style->indexes[face_index] - 1];\n          for ( i = 1; i <= suffixes[0]; i++ )\n          {\n            unsigned char*  s;\n            size_t          j = suffixes[i] - 1;\n\n\n            if ( j < string_count && ( s = names[j] ) != NULL )\n            {\n              size_t  s_len = (size_t)s[0];\n\n\n              if ( s_len != 0 && ps_name_len + s_len < sizeof ( ps_name ) )\n              {\n                ft_memcpy( ps_name + ps_name_len, s + 1, s_len );\n                ps_name_len += s_len;\n                ps_name[ps_name_len] = 0;\n              }\n            }\n          }\n        }\n      }\n\n      create_lwfn_name( ps_name, lwfn_file_name );\n    }\n  }\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 651,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2015-1271",
    "code_before_change": " void MediaControlVolumeSliderElement::defaultEventHandler(Event* event) {\n  if (event->isMouseEvent() &&\n      toMouseEvent(event)->button() !=\n          static_cast<short>(WebPointerProperties::Button::Left))\n    return;\n   if (!isConnected() || !document().isActive())\n     return;\n \n   MediaControlInputElement::defaultEventHandler(event);\n \n  if (event->type() == EventTypeNames::mouseover ||\n      event->type() == EventTypeNames::mouseout ||\n      event->type() == EventTypeNames::mousemove)\n    return;\n   if (event->type() == EventTypeNames::mousedown)\n     Platform::current()->recordAction(\n         UserMetricsAction(\"Media.Controls.VolumeChangeBegin\"));\n\n  if (event->type() == EventTypeNames::mouseup)\n     Platform::current()->recordAction(\n         UserMetricsAction(\"Media.Controls.VolumeChangeEnd\"));\n \n  double volume = value().toDouble();\n  mediaElement().setVolume(volume);\n  mediaElement().setMuted(false);\n }\n",
    "code_after_change": " void MediaControlVolumeSliderElement::defaultEventHandler(Event* event) {\n   if (!isConnected() || !document().isActive())\n     return;\n \n   MediaControlInputElement::defaultEventHandler(event);\n \n   if (event->type() == EventTypeNames::mousedown)\n     Platform::current()->recordAction(\n         UserMetricsAction(\"Media.Controls.VolumeChangeBegin\"));\n\n  if (event->type() == EventTypeNames::mouseup)\n     Platform::current()->recordAction(\n         UserMetricsAction(\"Media.Controls.VolumeChangeEnd\"));\n \n  if (event->type() == EventTypeNames::input) {\n    double volume = value().toDouble();\n    mediaElement().setVolume(volume);\n    mediaElement().setMuted(false);\n  }\n }\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 654,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-9601",
    "code_before_change": "huff_get_next_word(Jbig2HuffmanState *hs, int offset)\n {\n     uint32_t word = 0;\n     Jbig2WordStream *ws = hs->ws;\n\n    if ((ws->get_next_word(ws, offset, &word)) && ((hs->offset_limit == 0) || (offset < hs->offset_limit)))\n        hs->offset_limit = offset;\n    return word;\n}\n",
    "code_after_change": "huff_get_next_word(Jbig2HuffmanState *hs, int offset)\nhuff_get_next_word(Jbig2HuffmanState *hs, uint32_t offset)\n {\n     uint32_t word = 0;\n     Jbig2WordStream *ws = hs->ws;\n\n    if ((ws->get_next_word(ws, offset, &word)) && ((hs->offset_limit == 0) || (offset < hs->offset_limit)))\n        hs->offset_limit = offset;\n    return word;\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 657,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2015-1280",
    "code_before_change": "ServiceManagerContext::ServiceManagerContext() {\n  service_manager::mojom::ServiceRequest packaged_services_request;\n  if (service_manager::ServiceManagerIsRemote()) {\n    auto invitation =\n        mojo::edk::IncomingBrokerClientInvitation::AcceptFromCommandLine(\n            mojo::edk::TransportProtocol::kLegacy);\n    packaged_services_request =\n        service_manager::GetServiceRequestFromCommandLine(invitation.get());\n  } else {\n    std::unique_ptr<BuiltinManifestProvider> manifest_provider =\n        base::MakeUnique<BuiltinManifestProvider>();\n\n    static const struct ManifestInfo {\n      const char* name;\n      int resource_id;\n    } kManifests[] = {\n        {mojom::kBrowserServiceName, IDR_MOJO_CONTENT_BROWSER_MANIFEST},\n        {mojom::kGpuServiceName, IDR_MOJO_CONTENT_GPU_MANIFEST},\n        {mojom::kPackagedServicesServiceName,\n         IDR_MOJO_CONTENT_PACKAGED_SERVICES_MANIFEST},\n        {mojom::kPluginServiceName, IDR_MOJO_CONTENT_PLUGIN_MANIFEST},\n        {mojom::kRendererServiceName, IDR_MOJO_CONTENT_RENDERER_MANIFEST},\n        {mojom::kUtilityServiceName, IDR_MOJO_CONTENT_UTILITY_MANIFEST},\n        {catalog::mojom::kServiceName, IDR_MOJO_CATALOG_MANIFEST},\n    };\n\n    for (size_t i = 0; i < arraysize(kManifests); ++i) {\n      manifest_provider->AddServiceManifest(kManifests[i].name,\n                                            kManifests[i].resource_id);\n    }\n    for (const auto& manifest :\n         GetContentClient()->browser()->GetExtraServiceManifests()) {\n      manifest_provider->AddServiceManifest(manifest.name,\n                                            manifest.resource_id);\n    }\n    in_process_context_ = new InProcessServiceManagerContext;\n\n    service_manager::mojom::ServicePtr packaged_services_service;\n    packaged_services_request = mojo::MakeRequest(&packaged_services_service);\n    in_process_context_->Start(packaged_services_service.PassInterface(),\n                               std::move(manifest_provider));\n  }\n\n  packaged_services_connection_ = ServiceManagerConnection::Create(\n      std::move(packaged_services_request),\n      BrowserThread::GetTaskRunnerForThread(BrowserThread::IO));\n\n  service_manager::mojom::ServicePtr root_browser_service;\n  ServiceManagerConnection::SetForProcess(ServiceManagerConnection::Create(\n      mojo::MakeRequest(&root_browser_service),\n      BrowserThread::GetTaskRunnerForThread(BrowserThread::IO)));\n  auto* browser_connection = ServiceManagerConnection::GetForProcess();\n\n  service_manager::mojom::PIDReceiverPtr pid_receiver;\n  packaged_services_connection_->GetConnector()->StartService(\n      service_manager::Identity(mojom::kBrowserServiceName,\n                                service_manager::mojom::kRootUserID),\n      std::move(root_browser_service), mojo::MakeRequest(&pid_receiver));\n  pid_receiver->SetPID(base::GetCurrentProcId());\n\n  service_manager::EmbeddedServiceInfo device_info;\n#if defined(OS_ANDROID)\n  JNIEnv* env = base::android::AttachCurrentThread();\n  base::android::ScopedJavaGlobalRef<jobject> java_nfc_delegate;\n  java_nfc_delegate.Reset(Java_ContentNfcDelegate_create(env));\n  DCHECK(!java_nfc_delegate.is_null());\n\n  device_info.factory =\n      base::Bind(&device::CreateDeviceService,\n                 BrowserThread::GetTaskRunnerForThread(BrowserThread::FILE),\n                 BrowserThread::GetTaskRunnerForThread(BrowserThread::IO),\n                 base::Bind(&WakeLockContextHost::GetNativeViewForContext),\n                 std::move(java_nfc_delegate));\n#else\n  device_info.factory =\n      base::Bind(&device::CreateDeviceService,\n                 BrowserThread::GetTaskRunnerForThread(BrowserThread::FILE),\n                 BrowserThread::GetTaskRunnerForThread(BrowserThread::IO));\n#endif\n  device_info.task_runner = base::ThreadTaskRunnerHandle::Get();\n  packaged_services_connection_->AddEmbeddedService(device::mojom::kServiceName,\n                                                    device_info);\n\n  if (base::FeatureList::IsEnabled(features::kGlobalResourceCoordinator)) {\n    service_manager::EmbeddedServiceInfo resource_coordinator_info;\n    resource_coordinator_info.factory =\n        base::Bind(&resource_coordinator::ResourceCoordinatorService::Create);\n    packaged_services_connection_->AddEmbeddedService(\n        resource_coordinator::mojom::kServiceName, resource_coordinator_info);\n  }\n\n  ContentBrowserClient::StaticServiceMap services;\n  GetContentClient()->browser()->RegisterInProcessServices(&services);\n  for (const auto& entry : services) {\n    packaged_services_connection_->AddEmbeddedService(entry.first,\n                                                      entry.second);\n  }\n\n  g_io_thread_connector.Get() = browser_connection->GetConnector()->Clone();\n\n  ContentBrowserClient::OutOfProcessServiceMap out_of_process_services;\n  GetContentClient()->browser()->RegisterOutOfProcessServices(\n      &out_of_process_services);\n\n  out_of_process_services[data_decoder::mojom::kServiceName] = {\n      base::ASCIIToUTF16(\"Data Decoder Service\"), SANDBOX_TYPE_UTILITY};\n\n  bool network_service_enabled =\n      base::FeatureList::IsEnabled(features::kNetworkService);\n  if (network_service_enabled) {\n    out_of_process_services[content::mojom::kNetworkServiceName] = {\n        base::ASCIIToUTF16(\"Network Service\"), SANDBOX_TYPE_NETWORK};\n  }\n\n  if (base::FeatureList::IsEnabled(video_capture::kMojoVideoCapture)) {\n    out_of_process_services[video_capture::mojom::kServiceName] = {\n        base::ASCIIToUTF16(\"Video Capture Service\"), SANDBOX_TYPE_NO_SANDBOX};\n   }\n \n #if BUILDFLAG(ENABLE_MOJO_MEDIA_IN_UTILITY_PROCESS)\n  out_of_process_services[media::mojom::kMediaServiceName] = {\n      base::ASCIIToUTF16(\"Media Service\"), SANDBOX_TYPE_NO_SANDBOX};\n #endif\n \n   for (const auto& service : out_of_process_services) {\n    packaged_services_connection_->AddServiceRequestHandler(\n        service.first, base::Bind(&StartServiceInUtilityProcess, service.first,\n                                  service.second.first, service.second.second));\n  }\n\n#if BUILDFLAG(ENABLE_MOJO_MEDIA_IN_GPU_PROCESS)\n  packaged_services_connection_->AddServiceRequestHandler(\n      media::mojom::kMediaServiceName,\n      base::Bind(&StartServiceInGpuProcess, media::mojom::kMediaServiceName));\n#endif\n\n  packaged_services_connection_->AddServiceRequestHandler(\n      shape_detection::mojom::kServiceName,\n      base::Bind(&StartServiceInGpuProcess,\n                 shape_detection::mojom::kServiceName));\n\n  packaged_services_connection_->Start();\n\n  RegisterCommonBrowserInterfaces(browser_connection);\n  browser_connection->Start();\n\n  if (network_service_enabled) {\n    browser_connection->GetConnector()->StartService(\n        mojom::kNetworkServiceName);\n  }\n}\n",
    "code_after_change": "ServiceManagerContext::ServiceManagerContext() {\n  service_manager::mojom::ServiceRequest packaged_services_request;\n  if (service_manager::ServiceManagerIsRemote()) {\n    auto invitation =\n        mojo::edk::IncomingBrokerClientInvitation::AcceptFromCommandLine(\n            mojo::edk::TransportProtocol::kLegacy);\n    packaged_services_request =\n        service_manager::GetServiceRequestFromCommandLine(invitation.get());\n  } else {\n    std::unique_ptr<BuiltinManifestProvider> manifest_provider =\n        base::MakeUnique<BuiltinManifestProvider>();\n\n    static const struct ManifestInfo {\n      const char* name;\n      int resource_id;\n    } kManifests[] = {\n        {mojom::kBrowserServiceName, IDR_MOJO_CONTENT_BROWSER_MANIFEST},\n        {mojom::kGpuServiceName, IDR_MOJO_CONTENT_GPU_MANIFEST},\n        {mojom::kPackagedServicesServiceName,\n         IDR_MOJO_CONTENT_PACKAGED_SERVICES_MANIFEST},\n        {mojom::kPluginServiceName, IDR_MOJO_CONTENT_PLUGIN_MANIFEST},\n        {mojom::kRendererServiceName, IDR_MOJO_CONTENT_RENDERER_MANIFEST},\n        {mojom::kUtilityServiceName, IDR_MOJO_CONTENT_UTILITY_MANIFEST},\n        {catalog::mojom::kServiceName, IDR_MOJO_CATALOG_MANIFEST},\n    };\n\n    for (size_t i = 0; i < arraysize(kManifests); ++i) {\n      manifest_provider->AddServiceManifest(kManifests[i].name,\n                                            kManifests[i].resource_id);\n    }\n    for (const auto& manifest :\n         GetContentClient()->browser()->GetExtraServiceManifests()) {\n      manifest_provider->AddServiceManifest(manifest.name,\n                                            manifest.resource_id);\n    }\n    in_process_context_ = new InProcessServiceManagerContext;\n\n    service_manager::mojom::ServicePtr packaged_services_service;\n    packaged_services_request = mojo::MakeRequest(&packaged_services_service);\n    in_process_context_->Start(packaged_services_service.PassInterface(),\n                               std::move(manifest_provider));\n  }\n\n  packaged_services_connection_ = ServiceManagerConnection::Create(\n      std::move(packaged_services_request),\n      BrowserThread::GetTaskRunnerForThread(BrowserThread::IO));\n\n  service_manager::mojom::ServicePtr root_browser_service;\n  ServiceManagerConnection::SetForProcess(ServiceManagerConnection::Create(\n      mojo::MakeRequest(&root_browser_service),\n      BrowserThread::GetTaskRunnerForThread(BrowserThread::IO)));\n  auto* browser_connection = ServiceManagerConnection::GetForProcess();\n\n  service_manager::mojom::PIDReceiverPtr pid_receiver;\n  packaged_services_connection_->GetConnector()->StartService(\n      service_manager::Identity(mojom::kBrowserServiceName,\n                                service_manager::mojom::kRootUserID),\n      std::move(root_browser_service), mojo::MakeRequest(&pid_receiver));\n  pid_receiver->SetPID(base::GetCurrentProcId());\n\n  service_manager::EmbeddedServiceInfo device_info;\n#if defined(OS_ANDROID)\n  JNIEnv* env = base::android::AttachCurrentThread();\n  base::android::ScopedJavaGlobalRef<jobject> java_nfc_delegate;\n  java_nfc_delegate.Reset(Java_ContentNfcDelegate_create(env));\n  DCHECK(!java_nfc_delegate.is_null());\n\n  device_info.factory =\n      base::Bind(&device::CreateDeviceService,\n                 BrowserThread::GetTaskRunnerForThread(BrowserThread::FILE),\n                 BrowserThread::GetTaskRunnerForThread(BrowserThread::IO),\n                 base::Bind(&WakeLockContextHost::GetNativeViewForContext),\n                 std::move(java_nfc_delegate));\n#else\n  device_info.factory =\n      base::Bind(&device::CreateDeviceService,\n                 BrowserThread::GetTaskRunnerForThread(BrowserThread::FILE),\n                 BrowserThread::GetTaskRunnerForThread(BrowserThread::IO));\n#endif\n  device_info.task_runner = base::ThreadTaskRunnerHandle::Get();\n  packaged_services_connection_->AddEmbeddedService(device::mojom::kServiceName,\n                                                    device_info);\n\n  if (base::FeatureList::IsEnabled(features::kGlobalResourceCoordinator)) {\n    service_manager::EmbeddedServiceInfo resource_coordinator_info;\n    resource_coordinator_info.factory =\n        base::Bind(&resource_coordinator::ResourceCoordinatorService::Create);\n    packaged_services_connection_->AddEmbeddedService(\n        resource_coordinator::mojom::kServiceName, resource_coordinator_info);\n  }\n\n  ContentBrowserClient::StaticServiceMap services;\n  GetContentClient()->browser()->RegisterInProcessServices(&services);\n  for (const auto& entry : services) {\n    packaged_services_connection_->AddEmbeddedService(entry.first,\n                                                      entry.second);\n  }\n\n  g_io_thread_connector.Get() = browser_connection->GetConnector()->Clone();\n\n  ContentBrowserClient::OutOfProcessServiceMap out_of_process_services;\n  GetContentClient()->browser()->RegisterOutOfProcessServices(\n      &out_of_process_services);\n\n  out_of_process_services[data_decoder::mojom::kServiceName] = {\n      base::ASCIIToUTF16(\"Data Decoder Service\"), SANDBOX_TYPE_UTILITY};\n\n  bool network_service_enabled =\n      base::FeatureList::IsEnabled(features::kNetworkService);\n  if (network_service_enabled) {\n    out_of_process_services[content::mojom::kNetworkServiceName] = {\n        base::ASCIIToUTF16(\"Network Service\"), SANDBOX_TYPE_NETWORK};\n  }\n\n  if (base::FeatureList::IsEnabled(video_capture::kMojoVideoCapture)) {\n    out_of_process_services[video_capture::mojom::kServiceName] = {\n        base::ASCIIToUTF16(\"Video Capture Service\"), SANDBOX_TYPE_NO_SANDBOX};\n   }\n \n #if BUILDFLAG(ENABLE_MOJO_MEDIA_IN_UTILITY_PROCESS)\n  out_of_process_services[media::mojom::kMediaServiceName] = {\n      base::ASCIIToUTF16(\"Media Service\"), SANDBOX_TYPE_UTILITY};\n#endif\n\n#if BUILDFLAG(ENABLE_STANDALONE_CDM_SERVICE)\n  out_of_process_services[media::mojom::kCdmServiceName] = {\n      base::ASCIIToUTF16(\"Content Decryption Module Service\"),\n      SANDBOX_TYPE_NO_SANDBOX};\n #endif\n \n   for (const auto& service : out_of_process_services) {\n    packaged_services_connection_->AddServiceRequestHandler(\n        service.first, base::Bind(&StartServiceInUtilityProcess, service.first,\n                                  service.second.first, service.second.second));\n  }\n\n#if BUILDFLAG(ENABLE_MOJO_MEDIA_IN_GPU_PROCESS)\n  packaged_services_connection_->AddServiceRequestHandler(\n      media::mojom::kMediaServiceName,\n      base::Bind(&StartServiceInGpuProcess, media::mojom::kMediaServiceName));\n#endif\n\n  packaged_services_connection_->AddServiceRequestHandler(\n      shape_detection::mojom::kServiceName,\n      base::Bind(&StartServiceInGpuProcess,\n                 shape_detection::mojom::kServiceName));\n\n  packaged_services_connection_->Start();\n\n  RegisterCommonBrowserInterfaces(browser_connection);\n  browser_connection->Start();\n\n  if (network_service_enabled) {\n    browser_connection->GetConnector()->StartService(\n        mojom::kNetworkServiceName);\n  }\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 658,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-5356",
    "code_before_change": "parse_cosine_hex_dump(FILE_T fh, struct wtap_pkthdr *phdr, int pkt_len,\n    Buffer* buf, int *err, gchar **err_info)\n{\n\tguint8 *pd;\n\tgchar\tline[COSINE_LINE_LENGTH];\n\tint\ti, hex_lines, n, caplen = 0;\n \t/* Make sure we have enough room for the packet */\n\tws_buffer_assure_space(buf, COSINE_MAX_PACKET_LEN);\n \tpd = ws_buffer_start_ptr(buf);\n \n \t/* Calculate the number of hex dump lines, each\n\t * containing 16 bytes of data */\n\thex_lines = pkt_len / 16 + ((pkt_len % 16) ? 1 : 0);\n\n\tfor (i = 0; i < hex_lines; i++) {\n\t\tif (file_gets(line, COSINE_LINE_LENGTH, fh) == NULL) {\n\t\t\t*err = file_error(fh, err_info);\n\t\t\tif (*err == 0) {\n\t\t\t\t*err = WTAP_ERR_SHORT_READ;\n\t\t\t}\n\t\t\treturn FALSE;\n\t\t}\n\t\tif (empty_line(line)) {\n\t\t\tbreak;\n\t\t}\n\t\tif ((n = parse_single_hex_dump_line(line, pd, i*16)) == -1) {\n\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t*err_info = g_strdup(\"cosine: hex dump line doesn't have 16 numbers\");\n\t\t\treturn FALSE;\n\t\t}\n\t\tcaplen += n;\n\t}\n\tphdr->caplen = caplen;\n \treturn TRUE;\n }\n",
    "code_after_change": "parse_cosine_hex_dump(FILE_T fh, struct wtap_pkthdr *phdr, int pkt_len,\n \t/* Make sure we have enough room for the packet */\n\tws_buffer_assure_space(buf, pkt_len);\n \tpd = ws_buffer_start_ptr(buf);\n \n \t/* Calculate the number of hex dump lines, each\n\t * containing 16 bytes of data */\n\thex_lines = pkt_len / 16 + ((pkt_len % 16) ? 1 : 0);\n\n\tfor (i = 0; i < hex_lines; i++) {\n\t\tif (file_gets(line, COSINE_LINE_LENGTH, fh) == NULL) {\n\t\t\t*err = file_error(fh, err_info);\n\t\t\tif (*err == 0) {\n\t\t\t\t*err = WTAP_ERR_SHORT_READ;\n\t\t\t}\n\t\t\treturn FALSE;\n\t\t}\n\t\tif (empty_line(line)) {\n\t\t\tbreak;\n\t\t}\n\t\tif ((n = parse_single_hex_dump_line(line, pd, i*16)) == -1) {\n\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t*err_info = g_strdup(\"cosine: hex dump line doesn't have 16 numbers\");\n\t\t\treturn FALSE;\n\t\t}\n\t\tcaplen += n;\n\t}\n\tphdr->caplen = caplen;\n \treturn TRUE;\n }\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 671,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-5359",
    "code_before_change": "parse_wbxml_tag_defined (proto_tree *tree, tvbuff_t *tvb, guint32 offset,\n\t\t\t guint32 str_tbl, guint8 *level, guint8 *codepage_stag, guint8 *codepage_attr,\n \t\t\t const wbxml_decoding *map)\n {\n \tguint32     tvb_len  = tvb_reported_length (tvb);\n\tguint32     off      = offset;\n \tguint32     len;\n \tguint       str_len;\n \tguint32     ent;\n\tguint32     idx;\n\tguint8      peek;\n\tguint32     tag_len;                     /* Length of the index (uintvar) from a LITERAL tag */\n\tguint8      tag_save_known      = 0;     /* Will contain peek & 0x3F (tag identity) */\n\tguint8      tag_new_known       = 0;     /* Will contain peek & 0x3F (tag identity) */\n\tconst char *tag_save_literal;            /* Will contain the LITERAL tag identity */\n\tconst char *tag_new_literal;             /* Will contain the LITERAL tag identity */\n\tguint8      parsing_tag_content = FALSE; /* Are we parsing content from a\n\t\t\t\t\t            tag with content: <x>Content</x>\n\n\t\t\t\t\t            The initial state is FALSE.\n\t\t\t\t\t            This state will trigger recursion. */\n \ttag_save_literal = NULL;                 /* Prevents compiler warning */\n \n \tDebugLog((\"parse_wbxml_tag_defined (level = %u, offset = %u)\\n\", *level, offset));\n \twhile (off < tvb_len) {\n \t\tpeek = tvb_get_guint8 (tvb, off);\n \t\tDebugLog((\"STAG: (top of while) level = %3u, peek = 0x%02X, off = %u, tvb_len = %u\\n\", *level, peek, off, tvb_len));\n\t\tif ((peek & 0x3F) < 4) switch (peek) { /* Global tokens in state = STAG\n\t\t\t\t\t\t\t  but not the LITERAL tokens */\n\t\tcase 0x00: /* SWITCH_PAGE */\n\t\t\t*codepage_stag = tvb_get_guint8 (tvb, off+1);\n\t\t\tproto_tree_add_text (tree, tvb, off, 2,\n\t\t\t\t\t     \"      | Tag   | T -->%3d \"\n\t\t\t\t\t     \"| SWITCH_PAGE (Tag code page)     \"\n\t\t\t\t\t     \"|\",\n\t\t\t\t\t     *codepage_stag);\n\t\t\toff += 2;\n\t\t\tbreak;\n\t\tcase 0x01: /* END: only possible for Tag with Content */\n\t\t\tif (tag_save_known) { /* Known TAG */\n\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t     \"| END (Known Tag 0x%02X)            \"\n\t\t\t\t\t\t     \"| %s</%s>\",\n\t\t\t\t\t\t     *level, *codepage_stag,\n\t\t\t\t\t\t     tag_save_known, Indent (*level),\n\t\t\t\t\t\t     tag_save_literal); /* We already looked it up! */\n\t\t\t} else { /* Literal TAG */\n\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t     \"| END (Literal Tag)               \"\n\t\t\t\t\t\t     \"| %s</%s>\",\n\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level),\n\t\t\t\t\t\t     tag_save_literal ? tag_save_literal : \"\");\n\t\t\t}\n\t\t\t(*level)--;\n\t\t\toff++;\n\t\t\t/* Reset code page: not needed as return from recursion */\n\t\t\tDebugLog((\"STAG: level = %u, Return: len = %u\\n\", *level, off - offset));\n\t\t\treturn (off - offset);\n\t\tcase 0x02: /* ENTITY */\n\t\t\tent = tvb_get_guintvar (tvb, off+1, &len);\n\t\t\tproto_tree_add_text (tree, tvb, off, 1+len,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t     \"| ENTITY                          \"\n\t\t\t\t\t     \"| %s'&#%u;'\",\n\t\t\t\t\t     *level, *codepage_stag, Indent (*level), ent);\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x03: /* STR_I */\n\t\t\tlen = tvb_strsize (tvb, off+1);\n\t\t\tproto_tree_add_text (tree, tvb, off, 1+len,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t     \"| STR_I (Inline string)           \"\n\t\t\t\t\t     \"| %s\\'%s\\'\",\n\t\t\t\t\t     *level, *codepage_stag, Indent(*level),\n\t\t\t\t\t     tvb_format_text (tvb, off+1, len-1));\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x40: /* EXT_I_0 */\n\t\tcase 0x41: /* EXT_I_1 */\n\t\tcase 0x42: /* EXT_I_2 */\n\t\t\t/* Extension tokens */\n\t\t\tlen = tvb_strsize (tvb, off+1);\n\t\t\tproto_tree_add_text (tree, tvb, off, 1+len,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t     \"| EXT_I_%1x    (Extension Token)    \"\n\t\t\t\t\t     \"| %s(%s: \\'%s\\')\",\n\t\t\t\t\t     *level, *codepage_stag,\n\t\t\t\t\t     peek & 0x0f, Indent (*level),\n\t\t\t\t\t     map_token (map->global, 0, peek),\n\t\t\t\t\t     tvb_format_text (tvb, off+1, len-1));\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x43: /* PI */\n\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t     \"| PI (XML Processing Instruction) \"\n\t\t\t\t\t     \"| %s<?xml\",\n\t\t\t\t\t     *level, *codepage_stag, Indent (*level));\n\t\t\tlen = parse_wbxml_attribute_list_defined (tree, tvb, off,\n\t\t\t\t\t\t\t\t  str_tbl, *level, codepage_attr, map);\n\t\t\t/* Check that there is still room in packet */\n\t\t\toff += len;\n\t\t\tif (off >= tvb_len) {\n\t\t\t\tDebugLog((\"STAG: level = %u, ThrowException: len = %u (short frame)\\n\", *level, off - offset));\n\t\t\t\t/*\n\t\t\t\t * TODO - Do we need to free g_malloc()ed memory?\n\t\t\t\t */\n\t\t\t\tTHROW(ReportedBoundsError);\n\t\t\t}\n\t\t\tproto_tree_add_text (tree, tvb, off-1, 1,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t     \"| END (PI)                        \"\n\t\t\t\t\t     \"| %s?>\",\n\t\t\t\t\t     *level, *codepage_stag, Indent (*level));\n\t\t\tbreak;\n\t\tcase 0x80: /* EXT_T_0 */\n\t\tcase 0x81: /* EXT_T_1 */\n\t\tcase 0x82: /* EXT_T_2 */\n\t\t\t/* Extension tokens */\n\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len);\n\t\t\t{   char *s;\n\t\t\t\tif (map->ext_t[peek & 0x03])\n\t\t\t\t\ts = (map->ext_t[peek & 0x03])(tvb, idx, str_tbl);\n\t\t\t\telse\n\t\t\t\t\ts = wmem_strdup_printf(wmem_packet_scope(), \"EXT_T_%1x (%s)\", peek & 0x03,\n\t\t\t\t\t\t\t    map_token (map->global, 0, peek));\n\t\t\t\tproto_tree_add_text (tree, tvb, off, 1+len,\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t     \"| EXT_T_%1x    (Extension Token)    \"\n\t\t\t\t\t\t     \"| %s%s\",\n\t\t\t\t\t\t     *level, *codepage_stag, peek & 0x0f, Indent (*level),\n\t\t\t\t\t\t     s);\n\t\t\t}\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x83: /* STR_T */\n\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len);\n\t\t\tstr_len = tvb_strsize (tvb, str_tbl+idx);\n\t\t\tproto_tree_add_text (tree, tvb, off, 1+len,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t     \"| STR_T (Tableref string)         \"\n\t\t\t\t\t     \"| %s\\'%s\\'\",\n\t\t\t\t\t     *level, *codepage_stag, Indent (*level),\n\t\t\t\t\t     tvb_format_text (tvb, str_tbl+idx, str_len-1));\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0xC0: /* EXT_0 */\n\t\tcase 0xC1: /* EXT_1 */\n\t\tcase 0xC2: /* EXT_2 */\n\t\t\t/* Extension tokens */\n\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t     \"| EXT_%1x      (Extension Token)    \"\n\t\t\t\t\t     \"| %s(%s)\",\n\t\t\t\t\t     *level, *codepage_stag, peek & 0x0f, Indent (*level),\n\t\t\t\t\t     map_token (map->global, 0, peek));\n\t\t\toff++;\n\t\t\tbreak;\n\t\tcase 0xC3: /* OPAQUE - WBXML 1.1 and newer */\n\t\t\tif (tvb_get_guint8 (tvb, 0)) { /* WBXML 1.x (x > 0) */\n\t\t\t\tchar *str;\n\t\t\t\tif (tag_save_known) { /* Knwon tag */\n\t\t\t\t\tif (map->opaque_binary_tag) {\n\t\t\t\t\t\tstr = map->opaque_binary_tag(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t     tag_save_known, *codepage_stag, &len);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstr = default_opaque_binary_tag(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t\ttag_save_known, *codepage_stag, &len);\n\t\t\t\t\t}\n\t\t\t\t} else { /* lITERAL tag */\n\t\t\t\t\tif (map->opaque_literal_tag) {\n\t\t\t\t\t\tstr = map->opaque_literal_tag(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t      tag_save_literal, *codepage_stag, &len);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstr = default_opaque_literal_tag(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t\t tag_save_literal, *codepage_stag, &len);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tproto_tree_add_text (tree, tvb, off, 1 + len,\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t     \"| OPAQUE (Opaque data)            \"\n\t\t\t\t\t\t     \"| %s%s\",\n\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level), str);\n\t\t\t\toff += 1 + len;\n\t\t\t} else { /* WBXML 1.0 - RESERVED_2 token (invalid) */\n\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t     \"| RESERVED_2     (Invalid Token!) \"\n\t\t\t\t\t\t     \"| WBXML 1.0 parsing stops here.\",\n\t\t\t\t\t\t     *level, *codepage_stag);\n\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\toff = tvb_len;\n\t\t\t\tDebugLog((\"STAG: level = %u, Return: len = %u\\n\", *level, off - offset));\n\t\t\t\treturn (off - offset);\n\t\t\t}\n\t\t\tbreak;\n\n\t\t\t/* No default clause, as all cases have been treated */\n\t\t} else { /* LITERAL or Known TAG */\n\t\t\t/* We must store the initial tag, and also retrieve the new tag.\n\t\t\t * For efficiency reasons, we store the literal tag representation\n\t\t\t * for known tags too, so we can easily close the tag without the\n\t\t\t * need of a new lookup and avoiding storage of token codepage.\n\t\t\t *\n\t\t\t * There are 4 possibilities:\n\t\t\t *\n\t\t\t *  1. Known tag followed by a known tag\n\t\t\t *  2. Known tag followed by a LITERAL tag\n\t\t\t *  3. LITERAL tag followed by Known tag\n\t\t\t *  4. LITERAL tag followed by LITERAL tag\n\t\t\t */\n\n\t\t\t/* Store the new tag */\n\t\t\ttag_len = 0;\n\t\t\tif ((peek & 0x3F) == 4) { /* LITERAL */\n\t\t\t\tDebugLog((\"STAG: LITERAL tag (peek = 0x%02X, off = %u) - TableRef follows!\\n\", peek, off));\n\t\t\t\tidx = tvb_get_guintvar (tvb, off+1, &tag_len);\n\t\t\t\tstr_len = tvb_strsize (tvb, str_tbl+idx);\n\t\t\t\ttag_new_literal = (const gchar*)tvb_get_ptr (tvb, str_tbl+idx, str_len);\n\t\t\t\ttag_new_known = 0; /* invalidate known tag_new */\n\t\t\t} else { /* Known tag */\n\t\t\t\ttag_new_known = peek & 0x3F;\n\t\t\t\ttag_new_literal = map_token (map->tags, *codepage_stag,\n\t\t\t\t\t\t\t     tag_new_known);\n\t\t\t\t/* Stored looked up tag name string */\n\t\t\t}\n\n\t\t\t/* Parsing of TAG starts HERE */\n\t\t\tif (peek & 0x40) { /* Content present */\n\t\t\t\t/* Content follows\n\t\t\t\t * [!] An explicit END token is expected in these cases!\n\t\t\t\t * ==> Recursion possible if we encounter a tag with content;\n\t\t\t\t *     recursion will return at the explicit END token.\n\t\t\t\t */\n\t\t\t\tif (parsing_tag_content) { /* Recurse */\n\t\t\t\t\tDebugLog((\"STAG: Tag in Tag - RECURSE! (off = %u)\\n\", off));\n\t\t\t\t\t/* Do not process the attribute list:\n\t\t\t\t\t * recursion will take care of it */\n\t\t\t\t\t(*level)++;\n\t\t\t\t\tlen = parse_wbxml_tag_defined (tree, tvb, off, str_tbl,\n\t\t\t\t\t\t\t\t       level, codepage_stag, codepage_attr, map);\n\t\t\t\t\toff += len;\n\t\t\t\t} else { /* Now we will have content to parse */\n\t\t\t\t\t/* Save the start tag so we can properly close it later. */\n\t\t\t\t\tif ((peek & 0x3F) == 4) { /* Literal tag */\n\t\t\t\t\t\ttag_save_literal = tag_new_literal;\n\t\t\t\t\t\ttag_save_known = 0;\n\t\t\t\t\t} else { /* Known tag */\n\t\t\t\t\t\ttag_save_known = tag_new_known;\n\t\t\t\t\t\ttag_save_literal = tag_new_literal;\n\t\t\t\t\t\t/* The last statement avoids needless lookups */\n\t\t\t\t\t}\n\t\t\t\t\t/* Process the attribute list if present */\n\t\t\t\t\tif (peek & 0x80) { /* Content and Attribute list present */\n\t\t\t\t\t\tif (tag_new_known) { /* Known tag */\n\t\t\t\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t\t\t\t     \"|   Known Tag 0x%02X           (AC) \"\n\t\t\t\t\t\t\t\t\t     \"| %s<%s\",\n\t\t\t\t\t\t\t\t\t     *level, *codepage_stag, tag_new_known,\n\t\t\t\t\t\t\t\t\t     Indent (*level), tag_new_literal);\n\t\t\t\t\t\t\t/* Tag string already looked up earlier! */\n\t\t\t\t\t\t\toff++;\n\t\t\t\t\t\t} else { /* LITERAL tag */\n\t\t\t\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t\t\t\t     \"| LITERAL_AC (Literal tag)   (AC) \"\n\t\t\t\t\t\t\t\t\t     \"| %s<%s\",\n\t\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level), tag_new_literal);\n\t\t\t\t\t\t\toff += 1 + tag_len;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlen = parse_wbxml_attribute_list_defined (tree, tvb,\n\t\t\t\t\t\t\t\t\t\t\t  off, str_tbl, *level, codepage_attr, map);\n\t\t\t\t\t\t/* Check that there is still room in packet */\n\t\t\t\t\t\toff += len;\n\t\t\t\t\t\tif (off >= tvb_len) {\n\t\t\t\t\t\t\tDebugLog((\"STAG: level = %u, ThrowException: len = %u (short frame)\\n\",\n\t\t\t\t\t\t\t\t  *level, off - offset));\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * TODO - Do we need to free g_malloc()ed memory?\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tTHROW(ReportedBoundsError);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tproto_tree_add_text (tree, tvb, off-1, 1,\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t\t\t     \"| END (attribute list)            \"\n\t\t\t\t\t\t\t\t     \"| %s>\",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level));\n\t\t\t\t\t} else { /* Content, no Attribute list */\n\t\t\t\t\t\tif (tag_new_known) { /* Known tag */\n\t\t\t\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t\t\t\t     \"|   Known Tag 0x%02X           (.C) \"\n\t\t\t\t\t\t\t\t\t     \"| %s<%s>\",\n\t\t\t\t\t\t\t\t\t     *level, *codepage_stag, tag_new_known,\n\t\t\t\t\t\t\t\t\t     Indent (*level), tag_new_literal);\n\t\t\t\t\t\t\t/* Tag string already looked up earlier! */\n\t\t\t\t\t\t\toff++;\n\t\t\t\t\t\t} else { /* LITERAL tag */\n\t\t\t\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t\t\t\t     \"| LITERAL_C  (Literal Tag)   (.C) \"\n\t\t\t\t\t\t\t\t\t     \"| %s<%s>\",\n\t\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level),\n\t\t\t\t\t\t\t\t\t     tag_new_literal);\n\t\t\t\t\t\t\toff += 1 + tag_len;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/* The data that follows in the parsing process\n\t\t\t\t\t * represents content for the opening tag\n\t\t\t\t\t * we've just processed in the lines above.\n\t\t\t\t\t * Next time we encounter a tag with content: recurse\n\t\t\t\t\t */\n\t\t\t\t\tparsing_tag_content = TRUE;\n\t\t\t\t\tDebugLog((\"Tag in Tag - No recursion this time! (off = %u)\\n\", off));\n\t\t\t\t}\n\t\t\t} else { /* No Content */\n\t\t\t\tDebugLog((\"<Tag/> in Tag - No recursion! (off = %u)\\n\", off));\n\t\t\t\t(*level)++;\n\t\t\t\tif (peek & 0x80) { /* No Content, Attribute list present */\n\t\t\t\t\tif (tag_new_known) { /* Known tag */\n\t\t\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t\t\t     \"|   Known Tag 0x%02X           (A.) \"\n\t\t\t\t\t\t\t\t     \"| %s<%s\",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, tag_new_known,\n\t\t\t\t\t\t\t\t     Indent (*level), tag_new_literal);\n\t\t\t\t\t\t/* Tag string already looked up earlier! */\n\t\t\t\t\t\toff++;\n\t\t\t\t\t\tlen = parse_wbxml_attribute_list_defined (tree, tvb,\n\t\t\t\t\t\t\t\t\t\t\t  off, str_tbl, *level, codepage_attr, map);\n\t\t\t\t\t\t/* Check that there is still room in packet */\n\t\t\t\t\t\toff += len;\n\t\t\t\t\t\tif (off > tvb_len) {\n\t\t\t\t\t\t\tDebugLog((\"STAG: level = %u, ThrowException: len = %u (short frame)\\n\", *level, off - offset));\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * TODO - Do we need to free g_malloc()ed memory?\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tTHROW(ReportedBoundsError);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tproto_tree_add_text (tree, tvb, off-1, 1,\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t\t\t     \"| END (Known Tag)                 \"\n\t\t\t\t\t\t\t\t     \"| %s/>\",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level));\n\t\t\t\t\t} else { /* LITERAL tag */\n\t\t\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t\t\t     \"| LITERAL_A  (Literal Tag)   (A.) \"\n\t\t\t\t\t\t\t\t     \"| %s<%s\",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level), tag_new_literal);\n\t\t\t\t\t\toff += 1 + tag_len;\n\t\t\t\t\t\tlen = parse_wbxml_attribute_list_defined (tree, tvb,\n\t\t\t\t\t\t\t\t\t\t\t  off, str_tbl, *level, codepage_attr, map);\n\t\t\t\t\t\t/* Check that there is still room in packet */\n\t\t\t\t\t\toff += len;\n\t\t\t\t\t\tif (off >= tvb_len) {\n\t\t\t\t\t\t\tDebugLog((\"STAG: level = %u, ThrowException: len = %u (short frame)\\n\", *level, off - offset));\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * TODO - Do we need to free g_malloc()ed memory?\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tTHROW(ReportedBoundsError);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tproto_tree_add_text (tree, tvb, off-1, 1,\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t\t\t     \"| END (Literal Tag)               \"\n\t\t\t\t\t\t\t\t     \"| %s/>\",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level));\n\t\t\t\t\t}\n\t\t\t\t} else { /* No Content, No Attribute list */\n\t\t\t\t\tif (tag_new_known) { /* Known tag */\n\t\t\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t\t\t     \"|   Known Tag 0x%02x           (..) \"\n\t\t\t\t\t\t\t\t     \"| %s<%s />\",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, tag_new_known,\n\t\t\t\t\t\t\t\t     Indent (*level), tag_new_literal);\n\t\t\t\t\t\t/* Tag string already looked up earlier! */\n\t\t\t\t\t\toff++;\n\t\t\t\t\t} else { /* LITERAL tag */\n\t\t\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t\t\t     \"| LITERAL    (Literal Tag)   (..) \"\n\t\t\t\t\t\t\t\t     \"| %s<%s />\",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level),\n\t\t\t\t\t\t\t\t     tag_new_literal);\n\t\t\t\t\t\toff += 1 + tag_len;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t(*level)--;\n \t\t\t\t/* TODO: Do I have to reset code page here? */\n \t\t\t}\n \t\t} /* if (tag & 0x3F) >= 5 */\n \t} /* while */\n \tDebugLog((\"STAG: level = %u, Return: len = %u (end of function body)\\n\", *level, off - offset));\n \treturn (off - offset);\n}\n",
    "code_after_change": "parse_wbxml_tag_defined (proto_tree *tree, tvbuff_t *tvb, guint32 offset,\n\t\t\t guint32 str_tbl, guint8 *level, guint8 *codepage_stag, guint8 *codepage_attr,\n \t\t\t const wbxml_decoding *map)\n {\n \tguint32     tvb_len  = tvb_reported_length (tvb);\n\tguint32     off      = offset, last_off;\n \tguint32     len;\n \tguint       str_len;\n \tguint32     ent;\n\tguint32     idx;\n\tguint8      peek;\n\tguint32     tag_len;                     /* Length of the index (uintvar) from a LITERAL tag */\n\tguint8      tag_save_known      = 0;     /* Will contain peek & 0x3F (tag identity) */\n\tguint8      tag_new_known       = 0;     /* Will contain peek & 0x3F (tag identity) */\n\tconst char *tag_save_literal;            /* Will contain the LITERAL tag identity */\n\tconst char *tag_new_literal;             /* Will contain the LITERAL tag identity */\n\tguint8      parsing_tag_content = FALSE; /* Are we parsing content from a\n\t\t\t\t\t            tag with content: <x>Content</x>\n\n\t\t\t\t\t            The initial state is FALSE.\n\t\t\t\t\t            This state will trigger recursion. */\n \ttag_save_literal = NULL;                 /* Prevents compiler warning */\n \n \tDebugLog((\"parse_wbxml_tag_defined (level = %u, offset = %u)\\n\", *level, offset));\n\tlast_off = off;\n \twhile (off < tvb_len) {\n \t\tpeek = tvb_get_guint8 (tvb, off);\n \t\tDebugLog((\"STAG: (top of while) level = %3u, peek = 0x%02X, off = %u, tvb_len = %u\\n\", *level, peek, off, tvb_len));\n\t\tif ((peek & 0x3F) < 4) switch (peek) { /* Global tokens in state = STAG\n\t\t\t\t\t\t\t  but not the LITERAL tokens */\n\t\tcase 0x00: /* SWITCH_PAGE */\n\t\t\t*codepage_stag = tvb_get_guint8 (tvb, off+1);\n\t\t\tproto_tree_add_text (tree, tvb, off, 2,\n\t\t\t\t\t     \"      | Tag   | T -->%3d \"\n\t\t\t\t\t     \"| SWITCH_PAGE (Tag code page)     \"\n\t\t\t\t\t     \"|\",\n\t\t\t\t\t     *codepage_stag);\n\t\t\toff += 2;\n\t\t\tbreak;\n\t\tcase 0x01: /* END: only possible for Tag with Content */\n\t\t\tif (tag_save_known) { /* Known TAG */\n\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t     \"| END (Known Tag 0x%02X)            \"\n\t\t\t\t\t\t     \"| %s</%s>\",\n\t\t\t\t\t\t     *level, *codepage_stag,\n\t\t\t\t\t\t     tag_save_known, Indent (*level),\n\t\t\t\t\t\t     tag_save_literal); /* We already looked it up! */\n\t\t\t} else { /* Literal TAG */\n\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t     \"| END (Literal Tag)               \"\n\t\t\t\t\t\t     \"| %s</%s>\",\n\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level),\n\t\t\t\t\t\t     tag_save_literal ? tag_save_literal : \"\");\n\t\t\t}\n\t\t\t(*level)--;\n\t\t\toff++;\n\t\t\t/* Reset code page: not needed as return from recursion */\n\t\t\tDebugLog((\"STAG: level = %u, Return: len = %u\\n\", *level, off - offset));\n\t\t\treturn (off - offset);\n\t\tcase 0x02: /* ENTITY */\n\t\t\tent = tvb_get_guintvar (tvb, off+1, &len);\n\t\t\tproto_tree_add_text (tree, tvb, off, 1+len,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t     \"| ENTITY                          \"\n\t\t\t\t\t     \"| %s'&#%u;'\",\n\t\t\t\t\t     *level, *codepage_stag, Indent (*level), ent);\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x03: /* STR_I */\n\t\t\tlen = tvb_strsize (tvb, off+1);\n\t\t\tproto_tree_add_text (tree, tvb, off, 1+len,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t     \"| STR_I (Inline string)           \"\n\t\t\t\t\t     \"| %s\\'%s\\'\",\n\t\t\t\t\t     *level, *codepage_stag, Indent(*level),\n\t\t\t\t\t     tvb_format_text (tvb, off+1, len-1));\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x40: /* EXT_I_0 */\n\t\tcase 0x41: /* EXT_I_1 */\n\t\tcase 0x42: /* EXT_I_2 */\n\t\t\t/* Extension tokens */\n\t\t\tlen = tvb_strsize (tvb, off+1);\n\t\t\tproto_tree_add_text (tree, tvb, off, 1+len,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t     \"| EXT_I_%1x    (Extension Token)    \"\n\t\t\t\t\t     \"| %s(%s: \\'%s\\')\",\n\t\t\t\t\t     *level, *codepage_stag,\n\t\t\t\t\t     peek & 0x0f, Indent (*level),\n\t\t\t\t\t     map_token (map->global, 0, peek),\n\t\t\t\t\t     tvb_format_text (tvb, off+1, len-1));\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x43: /* PI */\n\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t     \"| PI (XML Processing Instruction) \"\n\t\t\t\t\t     \"| %s<?xml\",\n\t\t\t\t\t     *level, *codepage_stag, Indent (*level));\n\t\t\tlen = parse_wbxml_attribute_list_defined (tree, tvb, off,\n\t\t\t\t\t\t\t\t  str_tbl, *level, codepage_attr, map);\n\t\t\t/* Check that there is still room in packet */\n\t\t\toff += len;\n\t\t\tif (off >= tvb_len) {\n\t\t\t\tDebugLog((\"STAG: level = %u, ThrowException: len = %u (short frame)\\n\", *level, off - offset));\n\t\t\t\t/*\n\t\t\t\t * TODO - Do we need to free g_malloc()ed memory?\n\t\t\t\t */\n\t\t\t\tTHROW(ReportedBoundsError);\n\t\t\t}\n\t\t\tproto_tree_add_text (tree, tvb, off-1, 1,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t     \"| END (PI)                        \"\n\t\t\t\t\t     \"| %s?>\",\n\t\t\t\t\t     *level, *codepage_stag, Indent (*level));\n\t\t\tbreak;\n\t\tcase 0x80: /* EXT_T_0 */\n\t\tcase 0x81: /* EXT_T_1 */\n\t\tcase 0x82: /* EXT_T_2 */\n\t\t\t/* Extension tokens */\n\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len);\n\t\t\t{   char *s;\n\t\t\t\tif (map->ext_t[peek & 0x03])\n\t\t\t\t\ts = (map->ext_t[peek & 0x03])(tvb, idx, str_tbl);\n\t\t\t\telse\n\t\t\t\t\ts = wmem_strdup_printf(wmem_packet_scope(), \"EXT_T_%1x (%s)\", peek & 0x03,\n\t\t\t\t\t\t\t    map_token (map->global, 0, peek));\n\t\t\t\tproto_tree_add_text (tree, tvb, off, 1+len,\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t     \"| EXT_T_%1x    (Extension Token)    \"\n\t\t\t\t\t\t     \"| %s%s\",\n\t\t\t\t\t\t     *level, *codepage_stag, peek & 0x0f, Indent (*level),\n\t\t\t\t\t\t     s);\n\t\t\t}\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x83: /* STR_T */\n\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len);\n\t\t\tstr_len = tvb_strsize (tvb, str_tbl+idx);\n\t\t\tproto_tree_add_text (tree, tvb, off, 1+len,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t     \"| STR_T (Tableref string)         \"\n\t\t\t\t\t     \"| %s\\'%s\\'\",\n\t\t\t\t\t     *level, *codepage_stag, Indent (*level),\n\t\t\t\t\t     tvb_format_text (tvb, str_tbl+idx, str_len-1));\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0xC0: /* EXT_0 */\n\t\tcase 0xC1: /* EXT_1 */\n\t\tcase 0xC2: /* EXT_2 */\n\t\t\t/* Extension tokens */\n\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t     \"| EXT_%1x      (Extension Token)    \"\n\t\t\t\t\t     \"| %s(%s)\",\n\t\t\t\t\t     *level, *codepage_stag, peek & 0x0f, Indent (*level),\n\t\t\t\t\t     map_token (map->global, 0, peek));\n\t\t\toff++;\n\t\t\tbreak;\n\t\tcase 0xC3: /* OPAQUE - WBXML 1.1 and newer */\n\t\t\tif (tvb_get_guint8 (tvb, 0)) { /* WBXML 1.x (x > 0) */\n\t\t\t\tchar *str;\n\t\t\t\tif (tag_save_known) { /* Knwon tag */\n\t\t\t\t\tif (map->opaque_binary_tag) {\n\t\t\t\t\t\tstr = map->opaque_binary_tag(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t     tag_save_known, *codepage_stag, &len);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstr = default_opaque_binary_tag(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t\ttag_save_known, *codepage_stag, &len);\n\t\t\t\t\t}\n\t\t\t\t} else { /* lITERAL tag */\n\t\t\t\t\tif (map->opaque_literal_tag) {\n\t\t\t\t\t\tstr = map->opaque_literal_tag(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t      tag_save_literal, *codepage_stag, &len);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstr = default_opaque_literal_tag(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t\t tag_save_literal, *codepage_stag, &len);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tproto_tree_add_text (tree, tvb, off, 1 + len,\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t     \"| OPAQUE (Opaque data)            \"\n\t\t\t\t\t\t     \"| %s%s\",\n\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level), str);\n\t\t\t\toff += 1 + len;\n\t\t\t} else { /* WBXML 1.0 - RESERVED_2 token (invalid) */\n\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t     \"| RESERVED_2     (Invalid Token!) \"\n\t\t\t\t\t\t     \"| WBXML 1.0 parsing stops here.\",\n\t\t\t\t\t\t     *level, *codepage_stag);\n\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\toff = tvb_len;\n\t\t\t\tDebugLog((\"STAG: level = %u, Return: len = %u\\n\", *level, off - offset));\n\t\t\t\treturn (off - offset);\n\t\t\t}\n\t\t\tbreak;\n\n\t\t\t/* No default clause, as all cases have been treated */\n\t\t} else { /* LITERAL or Known TAG */\n\t\t\t/* We must store the initial tag, and also retrieve the new tag.\n\t\t\t * For efficiency reasons, we store the literal tag representation\n\t\t\t * for known tags too, so we can easily close the tag without the\n\t\t\t * need of a new lookup and avoiding storage of token codepage.\n\t\t\t *\n\t\t\t * There are 4 possibilities:\n\t\t\t *\n\t\t\t *  1. Known tag followed by a known tag\n\t\t\t *  2. Known tag followed by a LITERAL tag\n\t\t\t *  3. LITERAL tag followed by Known tag\n\t\t\t *  4. LITERAL tag followed by LITERAL tag\n\t\t\t */\n\n\t\t\t/* Store the new tag */\n\t\t\ttag_len = 0;\n\t\t\tif ((peek & 0x3F) == 4) { /* LITERAL */\n\t\t\t\tDebugLog((\"STAG: LITERAL tag (peek = 0x%02X, off = %u) - TableRef follows!\\n\", peek, off));\n\t\t\t\tidx = tvb_get_guintvar (tvb, off+1, &tag_len);\n\t\t\t\tstr_len = tvb_strsize (tvb, str_tbl+idx);\n\t\t\t\ttag_new_literal = (const gchar*)tvb_get_ptr (tvb, str_tbl+idx, str_len);\n\t\t\t\ttag_new_known = 0; /* invalidate known tag_new */\n\t\t\t} else { /* Known tag */\n\t\t\t\ttag_new_known = peek & 0x3F;\n\t\t\t\ttag_new_literal = map_token (map->tags, *codepage_stag,\n\t\t\t\t\t\t\t     tag_new_known);\n\t\t\t\t/* Stored looked up tag name string */\n\t\t\t}\n\n\t\t\t/* Parsing of TAG starts HERE */\n\t\t\tif (peek & 0x40) { /* Content present */\n\t\t\t\t/* Content follows\n\t\t\t\t * [!] An explicit END token is expected in these cases!\n\t\t\t\t * ==> Recursion possible if we encounter a tag with content;\n\t\t\t\t *     recursion will return at the explicit END token.\n\t\t\t\t */\n\t\t\t\tif (parsing_tag_content) { /* Recurse */\n\t\t\t\t\tDebugLog((\"STAG: Tag in Tag - RECURSE! (off = %u)\\n\", off));\n\t\t\t\t\t/* Do not process the attribute list:\n\t\t\t\t\t * recursion will take care of it */\n\t\t\t\t\t(*level)++;\n\t\t\t\t\tlen = parse_wbxml_tag_defined (tree, tvb, off, str_tbl,\n\t\t\t\t\t\t\t\t       level, codepage_stag, codepage_attr, map);\n\t\t\t\t\toff += len;\n\t\t\t\t} else { /* Now we will have content to parse */\n\t\t\t\t\t/* Save the start tag so we can properly close it later. */\n\t\t\t\t\tif ((peek & 0x3F) == 4) { /* Literal tag */\n\t\t\t\t\t\ttag_save_literal = tag_new_literal;\n\t\t\t\t\t\ttag_save_known = 0;\n\t\t\t\t\t} else { /* Known tag */\n\t\t\t\t\t\ttag_save_known = tag_new_known;\n\t\t\t\t\t\ttag_save_literal = tag_new_literal;\n\t\t\t\t\t\t/* The last statement avoids needless lookups */\n\t\t\t\t\t}\n\t\t\t\t\t/* Process the attribute list if present */\n\t\t\t\t\tif (peek & 0x80) { /* Content and Attribute list present */\n\t\t\t\t\t\tif (tag_new_known) { /* Known tag */\n\t\t\t\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t\t\t\t     \"|   Known Tag 0x%02X           (AC) \"\n\t\t\t\t\t\t\t\t\t     \"| %s<%s\",\n\t\t\t\t\t\t\t\t\t     *level, *codepage_stag, tag_new_known,\n\t\t\t\t\t\t\t\t\t     Indent (*level), tag_new_literal);\n\t\t\t\t\t\t\t/* Tag string already looked up earlier! */\n\t\t\t\t\t\t\toff++;\n\t\t\t\t\t\t} else { /* LITERAL tag */\n\t\t\t\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t\t\t\t     \"| LITERAL_AC (Literal tag)   (AC) \"\n\t\t\t\t\t\t\t\t\t     \"| %s<%s\",\n\t\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level), tag_new_literal);\n\t\t\t\t\t\t\toff += 1 + tag_len;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlen = parse_wbxml_attribute_list_defined (tree, tvb,\n\t\t\t\t\t\t\t\t\t\t\t  off, str_tbl, *level, codepage_attr, map);\n\t\t\t\t\t\t/* Check that there is still room in packet */\n\t\t\t\t\t\toff += len;\n\t\t\t\t\t\tif (off >= tvb_len) {\n\t\t\t\t\t\t\tDebugLog((\"STAG: level = %u, ThrowException: len = %u (short frame)\\n\",\n\t\t\t\t\t\t\t\t  *level, off - offset));\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * TODO - Do we need to free g_malloc()ed memory?\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tTHROW(ReportedBoundsError);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tproto_tree_add_text (tree, tvb, off-1, 1,\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t\t\t     \"| END (attribute list)            \"\n\t\t\t\t\t\t\t\t     \"| %s>\",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level));\n\t\t\t\t\t} else { /* Content, no Attribute list */\n\t\t\t\t\t\tif (tag_new_known) { /* Known tag */\n\t\t\t\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t\t\t\t     \"|   Known Tag 0x%02X           (.C) \"\n\t\t\t\t\t\t\t\t\t     \"| %s<%s>\",\n\t\t\t\t\t\t\t\t\t     *level, *codepage_stag, tag_new_known,\n\t\t\t\t\t\t\t\t\t     Indent (*level), tag_new_literal);\n\t\t\t\t\t\t\t/* Tag string already looked up earlier! */\n\t\t\t\t\t\t\toff++;\n\t\t\t\t\t\t} else { /* LITERAL tag */\n\t\t\t\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t\t\t\t     \"| LITERAL_C  (Literal Tag)   (.C) \"\n\t\t\t\t\t\t\t\t\t     \"| %s<%s>\",\n\t\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level),\n\t\t\t\t\t\t\t\t\t     tag_new_literal);\n\t\t\t\t\t\t\toff += 1 + tag_len;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/* The data that follows in the parsing process\n\t\t\t\t\t * represents content for the opening tag\n\t\t\t\t\t * we've just processed in the lines above.\n\t\t\t\t\t * Next time we encounter a tag with content: recurse\n\t\t\t\t\t */\n\t\t\t\t\tparsing_tag_content = TRUE;\n\t\t\t\t\tDebugLog((\"Tag in Tag - No recursion this time! (off = %u)\\n\", off));\n\t\t\t\t}\n\t\t\t} else { /* No Content */\n\t\t\t\tDebugLog((\"<Tag/> in Tag - No recursion! (off = %u)\\n\", off));\n\t\t\t\t(*level)++;\n\t\t\t\tif (peek & 0x80) { /* No Content, Attribute list present */\n\t\t\t\t\tif (tag_new_known) { /* Known tag */\n\t\t\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t\t\t     \"|   Known Tag 0x%02X           (A.) \"\n\t\t\t\t\t\t\t\t     \"| %s<%s\",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, tag_new_known,\n\t\t\t\t\t\t\t\t     Indent (*level), tag_new_literal);\n\t\t\t\t\t\t/* Tag string already looked up earlier! */\n\t\t\t\t\t\toff++;\n\t\t\t\t\t\tlen = parse_wbxml_attribute_list_defined (tree, tvb,\n\t\t\t\t\t\t\t\t\t\t\t  off, str_tbl, *level, codepage_attr, map);\n\t\t\t\t\t\t/* Check that there is still room in packet */\n\t\t\t\t\t\toff += len;\n\t\t\t\t\t\tif (off > tvb_len) {\n\t\t\t\t\t\t\tDebugLog((\"STAG: level = %u, ThrowException: len = %u (short frame)\\n\", *level, off - offset));\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * TODO - Do we need to free g_malloc()ed memory?\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tTHROW(ReportedBoundsError);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tproto_tree_add_text (tree, tvb, off-1, 1,\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t\t\t     \"| END (Known Tag)                 \"\n\t\t\t\t\t\t\t\t     \"| %s/>\",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level));\n\t\t\t\t\t} else { /* LITERAL tag */\n\t\t\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t\t\t     \"| LITERAL_A  (Literal Tag)   (A.) \"\n\t\t\t\t\t\t\t\t     \"| %s<%s\",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level), tag_new_literal);\n\t\t\t\t\t\toff += 1 + tag_len;\n\t\t\t\t\t\tlen = parse_wbxml_attribute_list_defined (tree, tvb,\n\t\t\t\t\t\t\t\t\t\t\t  off, str_tbl, *level, codepage_attr, map);\n\t\t\t\t\t\t/* Check that there is still room in packet */\n\t\t\t\t\t\toff += len;\n\t\t\t\t\t\tif (off >= tvb_len) {\n\t\t\t\t\t\t\tDebugLog((\"STAG: level = %u, ThrowException: len = %u (short frame)\\n\", *level, off - offset));\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * TODO - Do we need to free g_malloc()ed memory?\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tTHROW(ReportedBoundsError);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tproto_tree_add_text (tree, tvb, off-1, 1,\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t\t\t     \"| END (Literal Tag)               \"\n\t\t\t\t\t\t\t\t     \"| %s/>\",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level));\n\t\t\t\t\t}\n\t\t\t\t} else { /* No Content, No Attribute list */\n\t\t\t\t\tif (tag_new_known) { /* Known tag */\n\t\t\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t\t\t     \"|   Known Tag 0x%02x           (..) \"\n\t\t\t\t\t\t\t\t     \"| %s<%s />\",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, tag_new_known,\n\t\t\t\t\t\t\t\t     Indent (*level), tag_new_literal);\n\t\t\t\t\t\t/* Tag string already looked up earlier! */\n\t\t\t\t\t\toff++;\n\t\t\t\t\t} else { /* LITERAL tag */\n\t\t\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t\t\t     \"| LITERAL    (Literal Tag)   (..) \"\n\t\t\t\t\t\t\t\t     \"| %s<%s />\",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level),\n\t\t\t\t\t\t\t\t     tag_new_literal);\n\t\t\t\t\t\toff += 1 + tag_len;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t(*level)--;\n \t\t\t\t/* TODO: Do I have to reset code page here? */\n \t\t\t}\n \t\t} /* if (tag & 0x3F) >= 5 */\n\t\tif (off < last_off) {\n\t\t\tTHROW(ReportedBoundsError);\n\t\t}\n\t\tlast_off = off;\n \t} /* while */\n \tDebugLog((\"STAG: level = %u, Return: len = %u (end of function body)\\n\", *level, off - offset));\n \treturn (off - offset);\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 672,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-10057",
    "code_before_change": "static MagickBooleanType WritePDBImage(const ImageInfo *image_info,Image *image)\n{\n  const char\n    *comment;\n\n  int\n    bits;\n\n  MagickBooleanType\n    status;\n\n  PDBImage\n    pdb_image;\n\n  PDBInfo\n    pdb_info;\n\n  QuantumInfo\n    *quantum_info;\n\n  register const PixelPacket\n    *p;\n\n  register ssize_t\n    x;\n\n  register unsigned char\n    *q;\n\n  size_t\n    bits_per_pixel,\n    literal,\n    packets,\n    packet_size,\n    repeat;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *buffer,\n    *runlength,\n    *scanline;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) TransformImageColorspace(image,sRGBColorspace);\n  if ((image -> colors <= 2 ) ||\n      (GetImageType(image,&image->exception ) == BilevelType)) {\n    bits_per_pixel=1;\n  } else if (image->colors <= 4) {\n    bits_per_pixel=2;\n  } else if (image->colors <= 8) {\n    bits_per_pixel=3;\n  } else {\n    bits_per_pixel=4;\n  }\n  (void) ResetMagickMemory(&pdb_info,0,sizeof(pdb_info));\n  (void) CopyMagickString(pdb_info.name,image_info->filename,\n    sizeof(pdb_info.name));\n  pdb_info.attributes=0;\n  pdb_info.version=0;\n  pdb_info.create_time=time(NULL);\n  pdb_info.modify_time=pdb_info.create_time;\n  pdb_info.archive_time=0;\n  pdb_info.modify_number=0;\n  pdb_info.application_info=0;\n  pdb_info.sort_info=0;\n  (void) CopyMagickMemory(pdb_info.type,\"vIMG\",4);\n  (void) CopyMagickMemory(pdb_info.id,\"View\",4);\n  pdb_info.seed=0;\n  pdb_info.next_record=0;\n  comment=GetImageProperty(image,\"comment\");\n  pdb_info.number_records=(comment == (const char *) NULL ? 1 : 2);\n  (void) WriteBlob(image,sizeof(pdb_info.name),(unsigned char *) pdb_info.name);\n  (void) WriteBlobMSBShort(image,(unsigned short) pdb_info.attributes);\n  (void) WriteBlobMSBShort(image,(unsigned short) pdb_info.version);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.create_time);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.modify_time);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.archive_time);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.modify_number);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.application_info);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.sort_info);\n  (void) WriteBlob(image,4,(unsigned char *) pdb_info.type);\n  (void) WriteBlob(image,4,(unsigned char *) pdb_info.id);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.seed);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.next_record);\n  (void) WriteBlobMSBShort(image,(unsigned short) pdb_info.number_records);\n  (void) CopyMagickString(pdb_image.name,pdb_info.name,sizeof(pdb_image.name));\n  pdb_image.version=1;  /* RLE Compressed */\n  switch (bits_per_pixel)\n  {\n    case 1: pdb_image.type=(unsigned char) 0xff; break;  /* monochrome */\n    case 2: pdb_image.type=(unsigned char) 0x00; break;  /* 2 bit gray */\n    default: pdb_image.type=(unsigned char) 0x02;  /* 4 bit gray */\n  }\n  pdb_image.reserved_1=0;\n  pdb_image.note=0;\n  pdb_image.x_last=0;\n  pdb_image.y_last=0;\n  pdb_image.reserved_2=0;\n  pdb_image.x_anchor=(unsigned short) 0xffff;\n  pdb_image.y_anchor=(unsigned short) 0xffff;\n  pdb_image.width=(short) image->columns;\n  if (image->columns % 16)\n    pdb_image.width=(short) (16*(image->columns/16+1));\n  pdb_image.height=(short) image->rows;\n  packets=((bits_per_pixel*image->columns+7)/8);\n  runlength=(unsigned char *) AcquireQuantumMemory(9UL*packets,\n    image->rows*sizeof(*runlength));\n  if (runlength == (unsigned char *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n   buffer=(unsigned char *) AcquireQuantumMemory(512,sizeof(*buffer));\n   if (buffer == (unsigned char *) NULL)\n     ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  packet_size=(size_t) (image->depth > 8 ? 2: 1);\n   scanline=(unsigned char *) AcquireQuantumMemory(image->columns,packet_size*\n     sizeof(*scanline));\n   if (scanline == (unsigned char *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n    (void) TransformImageColorspace(image,sRGBColorspace);\n  /*\n    Convert to GRAY raster scanline.\n  */\n   quantum_info=AcquireQuantumInfo(image_info,image);\n   if (quantum_info == (QuantumInfo *) NULL)\n     ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n   bits=8/(int) bits_per_pixel-1;  /* start at most significant bits */\n   literal=0;\n   repeat=0;\n  q=runlength;\n  buffer[0]=0x00;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n    if (p == (const PixelPacket *) NULL)\n      break;\n    (void) ExportQuantumPixels(image,(const CacheView *) NULL,quantum_info,\n      GrayQuantum,scanline,&image->exception);\n    for (x=0; x < (ssize_t) pdb_image.width; x++)\n    {\n      if (x < (ssize_t) image->columns)\n        buffer[literal+repeat]|=(0xff-scanline[x*packet_size]) >>\n          (8-bits_per_pixel) << bits*bits_per_pixel;\n      bits--;\n      if (bits < 0)\n        {\n          if (((literal+repeat) > 0) &&\n              (buffer[literal+repeat] == buffer[literal+repeat-1]))\n            {\n              if (repeat == 0)\n                {\n                  literal--;\n                  repeat++;\n                }\n              repeat++;\n              if (0x7f < repeat)\n                {\n                  q=EncodeRLE(q,buffer,literal,repeat);\n                  literal=0;\n                  repeat=0;\n                }\n            }\n          else\n            {\n              if (repeat >= 2)\n                literal+=repeat;\n              else\n                {\n                  q=EncodeRLE(q,buffer,literal,repeat);\n                  buffer[0]=buffer[literal+repeat];\n                  literal=0;\n                }\n              literal++;\n              repeat=0;\n              if (0x7f < literal)\n                {\n                  q=EncodeRLE(q,buffer,(literal < 0x80 ? literal : 0x80),0);\n                  (void) CopyMagickMemory(buffer,buffer+literal+repeat,0x80);\n                  literal-=0x80;\n                }\n            }\n        bits=8/(int) bits_per_pixel-1;\n        buffer[literal+repeat]=0x00;\n      }\n    }\n    status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  q=EncodeRLE(q,buffer,literal,repeat);\n  scanline=(unsigned char *) RelinquishMagickMemory(scanline);\n  buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n  quantum_info=DestroyQuantumInfo(quantum_info);\n  /*\n    Write the Image record header.\n  */\n  (void) WriteBlobMSBLong(image,(unsigned int) (TellBlob(image)+8*\n    pdb_info.number_records));\n  (void) WriteBlobByte(image,0x40);\n  (void) WriteBlobByte(image,0x6f);\n  (void) WriteBlobByte(image,0x80);\n  (void) WriteBlobByte(image,0);\n  if (pdb_info.number_records > 1)\n    {\n      /*\n        Write the comment record header.\n      */\n      (void) WriteBlobMSBLong(image,(unsigned int) (TellBlob(image)+8+58+q-\n        runlength));\n      (void) WriteBlobByte(image,0x40);\n      (void) WriteBlobByte(image,0x6f);\n      (void) WriteBlobByte(image,0x80);\n      (void) WriteBlobByte(image,1);\n    }\n  /*\n    Write the Image data.\n  */\n  (void) WriteBlob(image,sizeof(pdb_image.name),(unsigned char *)\n    pdb_image.name);\n  (void) WriteBlobByte(image,(unsigned char) pdb_image.version);\n  (void) WriteBlobByte(image,pdb_image.type);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_image.reserved_1);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_image.note);\n  (void) WriteBlobMSBShort(image,(unsigned short) pdb_image.x_last);\n  (void) WriteBlobMSBShort(image,(unsigned short) pdb_image.y_last);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_image.reserved_2);\n  (void) WriteBlobMSBShort(image,pdb_image.x_anchor);\n  (void) WriteBlobMSBShort(image,pdb_image.y_anchor);\n  (void) WriteBlobMSBShort(image,(unsigned short) pdb_image.width);\n  (void) WriteBlobMSBShort(image,(unsigned short) pdb_image.height);\n  (void) WriteBlob(image,(size_t) (q-runlength),runlength);\n  runlength=(unsigned char *) RelinquishMagickMemory(runlength);\n  if (pdb_info.number_records > 1)\n    (void) WriteBlobString(image,comment);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n",
    "code_after_change": "static MagickBooleanType WritePDBImage(const ImageInfo *image_info,Image *image)\n{\n  const char\n    *comment;\n\n  int\n    bits;\n\n  MagickBooleanType\n    status;\n\n  PDBImage\n    pdb_image;\n\n  PDBInfo\n    pdb_info;\n\n  QuantumInfo\n    *quantum_info;\n\n  register const PixelPacket\n    *p;\n\n  register ssize_t\n    x;\n\n  register unsigned char\n    *q;\n\n  size_t\n    bits_per_pixel,\n    literal,\n    packets,\n    packet_size,\n    repeat;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *buffer,\n    *runlength,\n    *scanline;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) TransformImageColorspace(image,sRGBColorspace);\n  if ((image -> colors <= 2 ) ||\n      (GetImageType(image,&image->exception ) == BilevelType)) {\n    bits_per_pixel=1;\n  } else if (image->colors <= 4) {\n    bits_per_pixel=2;\n  } else if (image->colors <= 8) {\n    bits_per_pixel=3;\n  } else {\n    bits_per_pixel=4;\n  }\n  (void) ResetMagickMemory(&pdb_info,0,sizeof(pdb_info));\n  (void) CopyMagickString(pdb_info.name,image_info->filename,\n    sizeof(pdb_info.name));\n  pdb_info.attributes=0;\n  pdb_info.version=0;\n  pdb_info.create_time=time(NULL);\n  pdb_info.modify_time=pdb_info.create_time;\n  pdb_info.archive_time=0;\n  pdb_info.modify_number=0;\n  pdb_info.application_info=0;\n  pdb_info.sort_info=0;\n  (void) CopyMagickMemory(pdb_info.type,\"vIMG\",4);\n  (void) CopyMagickMemory(pdb_info.id,\"View\",4);\n  pdb_info.seed=0;\n  pdb_info.next_record=0;\n  comment=GetImageProperty(image,\"comment\");\n  pdb_info.number_records=(comment == (const char *) NULL ? 1 : 2);\n  (void) WriteBlob(image,sizeof(pdb_info.name),(unsigned char *) pdb_info.name);\n  (void) WriteBlobMSBShort(image,(unsigned short) pdb_info.attributes);\n  (void) WriteBlobMSBShort(image,(unsigned short) pdb_info.version);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.create_time);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.modify_time);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.archive_time);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.modify_number);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.application_info);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.sort_info);\n  (void) WriteBlob(image,4,(unsigned char *) pdb_info.type);\n  (void) WriteBlob(image,4,(unsigned char *) pdb_info.id);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.seed);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.next_record);\n  (void) WriteBlobMSBShort(image,(unsigned short) pdb_info.number_records);\n  (void) CopyMagickString(pdb_image.name,pdb_info.name,sizeof(pdb_image.name));\n  pdb_image.version=1;  /* RLE Compressed */\n  switch (bits_per_pixel)\n  {\n    case 1: pdb_image.type=(unsigned char) 0xff; break;  /* monochrome */\n    case 2: pdb_image.type=(unsigned char) 0x00; break;  /* 2 bit gray */\n    default: pdb_image.type=(unsigned char) 0x02;  /* 4 bit gray */\n  }\n  pdb_image.reserved_1=0;\n  pdb_image.note=0;\n  pdb_image.x_last=0;\n  pdb_image.y_last=0;\n  pdb_image.reserved_2=0;\n  pdb_image.x_anchor=(unsigned short) 0xffff;\n  pdb_image.y_anchor=(unsigned short) 0xffff;\n  pdb_image.width=(short) image->columns;\n  if (image->columns % 16)\n    pdb_image.width=(short) (16*(image->columns/16+1));\n  pdb_image.height=(short) image->rows;\n  packets=((bits_per_pixel*image->columns+7)/8);\n  runlength=(unsigned char *) AcquireQuantumMemory(9UL*packets,\n    image->rows*sizeof(*runlength));\n  if (runlength == (unsigned char *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n   buffer=(unsigned char *) AcquireQuantumMemory(512,sizeof(*buffer));\n   if (buffer == (unsigned char *) NULL)\n     ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  packet_size=(size_t) (image->depth > 8 ? 2 : 1);\n   scanline=(unsigned char *) AcquireQuantumMemory(image->columns,packet_size*\n     sizeof(*scanline));\n   if (scanline == (unsigned char *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n    (void) TransformImageColorspace(image,sRGBColorspace);\n  /*\n    Convert to GRAY raster scanline.\n  */\n   quantum_info=AcquireQuantumInfo(image_info,image);\n   if (quantum_info == (QuantumInfo *) NULL)\n     ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  status=SetQuantumDepth(image,quantum_info,image->depth > 8 ? 16 : 8);\n   bits=8/(int) bits_per_pixel-1;  /* start at most significant bits */\n   literal=0;\n   repeat=0;\n  q=runlength;\n  buffer[0]=0x00;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n    if (p == (const PixelPacket *) NULL)\n      break;\n    (void) ExportQuantumPixels(image,(const CacheView *) NULL,quantum_info,\n      GrayQuantum,scanline,&image->exception);\n    for (x=0; x < (ssize_t) pdb_image.width; x++)\n    {\n      if (x < (ssize_t) image->columns)\n        buffer[literal+repeat]|=(0xff-scanline[x*packet_size]) >>\n          (8-bits_per_pixel) << bits*bits_per_pixel;\n      bits--;\n      if (bits < 0)\n        {\n          if (((literal+repeat) > 0) &&\n              (buffer[literal+repeat] == buffer[literal+repeat-1]))\n            {\n              if (repeat == 0)\n                {\n                  literal--;\n                  repeat++;\n                }\n              repeat++;\n              if (0x7f < repeat)\n                {\n                  q=EncodeRLE(q,buffer,literal,repeat);\n                  literal=0;\n                  repeat=0;\n                }\n            }\n          else\n            {\n              if (repeat >= 2)\n                literal+=repeat;\n              else\n                {\n                  q=EncodeRLE(q,buffer,literal,repeat);\n                  buffer[0]=buffer[literal+repeat];\n                  literal=0;\n                }\n              literal++;\n              repeat=0;\n              if (0x7f < literal)\n                {\n                  q=EncodeRLE(q,buffer,(literal < 0x80 ? literal : 0x80),0);\n                  (void) CopyMagickMemory(buffer,buffer+literal+repeat,0x80);\n                  literal-=0x80;\n                }\n            }\n        bits=8/(int) bits_per_pixel-1;\n        buffer[literal+repeat]=0x00;\n      }\n    }\n    status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  q=EncodeRLE(q,buffer,literal,repeat);\n  scanline=(unsigned char *) RelinquishMagickMemory(scanline);\n  buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n  quantum_info=DestroyQuantumInfo(quantum_info);\n  /*\n    Write the Image record header.\n  */\n  (void) WriteBlobMSBLong(image,(unsigned int) (TellBlob(image)+8*\n    pdb_info.number_records));\n  (void) WriteBlobByte(image,0x40);\n  (void) WriteBlobByte(image,0x6f);\n  (void) WriteBlobByte(image,0x80);\n  (void) WriteBlobByte(image,0);\n  if (pdb_info.number_records > 1)\n    {\n      /*\n        Write the comment record header.\n      */\n      (void) WriteBlobMSBLong(image,(unsigned int) (TellBlob(image)+8+58+q-\n        runlength));\n      (void) WriteBlobByte(image,0x40);\n      (void) WriteBlobByte(image,0x6f);\n      (void) WriteBlobByte(image,0x80);\n      (void) WriteBlobByte(image,1);\n    }\n  /*\n    Write the Image data.\n  */\n  (void) WriteBlob(image,sizeof(pdb_image.name),(unsigned char *)\n    pdb_image.name);\n  (void) WriteBlobByte(image,(unsigned char) pdb_image.version);\n  (void) WriteBlobByte(image,pdb_image.type);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_image.reserved_1);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_image.note);\n  (void) WriteBlobMSBShort(image,(unsigned short) pdb_image.x_last);\n  (void) WriteBlobMSBShort(image,(unsigned short) pdb_image.y_last);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_image.reserved_2);\n  (void) WriteBlobMSBShort(image,pdb_image.x_anchor);\n  (void) WriteBlobMSBShort(image,pdb_image.y_anchor);\n  (void) WriteBlobMSBShort(image,(unsigned short) pdb_image.width);\n  (void) WriteBlobMSBShort(image,(unsigned short) pdb_image.height);\n  (void) WriteBlob(image,(size_t) (q-runlength),runlength);\n  runlength=(unsigned char *) RelinquishMagickMemory(runlength);\n  if (pdb_info.number_records > 1)\n    (void) WriteBlobString(image,comment);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 682,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2018-6094",
    "code_before_change": " void HeapObjectHeader::zapMagic() {\n  ASSERT(checkHeader());\n   m_magic = zappedMagic;\n }\n",
    "code_after_change": " void HeapObjectHeader::zapMagic() {\n  checkHeader();\n   m_magic = zappedMagic;\n }\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 698,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-2176",
    "code_before_change": "char *X509_NAME_oneline(X509_NAME *a, char *buf, int len)\n{\n    X509_NAME_ENTRY *ne;\n    int i;\n    int n, lold, l, l1, l2, num, j, type;\n    const char *s;\n    char *p;\n    unsigned char *q;\n    BUF_MEM *b = NULL;\n    static const char hex[17] = \"0123456789ABCDEF\";\n    int gs_doit[4];\n    char tmp_buf[80];\n#ifdef CHARSET_EBCDIC\n    char ebcdic_buf[1024];\n#endif\n\n    if (buf == NULL) {\n        if ((b = BUF_MEM_new()) == NULL)\n            goto err;\n        if (!BUF_MEM_grow(b, 200))\n            goto err;\n        b->data[0] = '\\0';\n        len = 200;\n    } else if (len == 0) {\n        return NULL;\n    }\n    if (a == NULL) {\n        if (b) {\n            buf = b->data;\n            OPENSSL_free(b);\n        }\n        strncpy(buf, \"NO X509_NAME\", len);\n        buf[len - 1] = '\\0';\n        return buf;\n    }\n\n    len--;                      /* space for '\\0' */\n    l = 0;\n    for (i = 0; i < sk_X509_NAME_ENTRY_num(a->entries); i++) {\n        ne = sk_X509_NAME_ENTRY_value(a->entries, i);\n        n = OBJ_obj2nid(ne->object);\n        if ((n == NID_undef) || ((s = OBJ_nid2sn(n)) == NULL)) {\n            i2t_ASN1_OBJECT(tmp_buf, sizeof(tmp_buf), ne->object);\n            s = tmp_buf;\n        }\n        l1 = strlen(s);\n\n        type = ne->value->type;\n        num = ne->value->length;\n        if (num > NAME_ONELINE_MAX) {\n            X509err(X509_F_X509_NAME_ONELINE, X509_R_NAME_TOO_LONG);\n            goto end;\n        }\n        q = ne->value->data;\n#ifdef CHARSET_EBCDIC\n        if (type == V_ASN1_GENERALSTRING ||\n            type == V_ASN1_VISIBLESTRING ||\n             type == V_ASN1_PRINTABLESTRING ||\n             type == V_ASN1_TELETEXSTRING ||\n             type == V_ASN1_VISIBLESTRING || type == V_ASN1_IA5STRING) {\n            ascii2ebcdic(ebcdic_buf, q, (num > sizeof ebcdic_buf)\n                         ? sizeof ebcdic_buf : num);\n             q = ebcdic_buf;\n         }\n #endif\n        if ((type == V_ASN1_GENERALSTRING) && ((num % 4) == 0)) {\n            gs_doit[0] = gs_doit[1] = gs_doit[2] = gs_doit[3] = 0;\n            for (j = 0; j < num; j++)\n                if (q[j] != 0)\n                    gs_doit[j & 3] = 1;\n\n            if (gs_doit[0] | gs_doit[1] | gs_doit[2])\n                gs_doit[0] = gs_doit[1] = gs_doit[2] = gs_doit[3] = 1;\n            else {\n                gs_doit[0] = gs_doit[1] = gs_doit[2] = 0;\n                gs_doit[3] = 1;\n            }\n        } else\n            gs_doit[0] = gs_doit[1] = gs_doit[2] = gs_doit[3] = 1;\n\n        for (l2 = j = 0; j < num; j++) {\n            if (!gs_doit[j & 3])\n                continue;\n            l2++;\n#ifndef CHARSET_EBCDIC\n            if ((q[j] < ' ') || (q[j] > '~'))\n                l2 += 3;\n#else\n            if ((os_toascii[q[j]] < os_toascii[' ']) ||\n                (os_toascii[q[j]] > os_toascii['~']))\n                l2 += 3;\n#endif\n        }\n\n        lold = l;\n        l += 1 + l1 + 1 + l2;\n        if (l > NAME_ONELINE_MAX) {\n            X509err(X509_F_X509_NAME_ONELINE, X509_R_NAME_TOO_LONG);\n            goto end;\n        }\n        if (b != NULL) {\n            if (!BUF_MEM_grow(b, l + 1))\n                goto err;\n            p = &(b->data[lold]);\n        } else if (l > len) {\n            break;\n        } else\n            p = &(buf[lold]);\n        *(p++) = '/';\n        memcpy(p, s, (unsigned int)l1);\n        p += l1;\n        *(p++) = '=';\n\n#ifndef CHARSET_EBCDIC          /* q was assigned above already. */\n        q = ne->value->data;\n#endif\n\n        for (j = 0; j < num; j++) {\n            if (!gs_doit[j & 3])\n                continue;\n#ifndef CHARSET_EBCDIC\n            n = q[j];\n            if ((n < ' ') || (n > '~')) {\n                *(p++) = '\\\\';\n                *(p++) = 'x';\n                *(p++) = hex[(n >> 4) & 0x0f];\n                *(p++) = hex[n & 0x0f];\n            } else\n                *(p++) = n;\n#else\n            n = os_toascii[q[j]];\n            if ((n < os_toascii[' ']) || (n > os_toascii['~'])) {\n                *(p++) = '\\\\';\n                *(p++) = 'x';\n                *(p++) = hex[(n >> 4) & 0x0f];\n                *(p++) = hex[n & 0x0f];\n            } else\n                *(p++) = q[j];\n#endif\n        }\n        *p = '\\0';\n    }\n    if (b != NULL) {\n        p = b->data;\n        OPENSSL_free(b);\n    } else\n        p = buf;\n    if (i == 0)\n        *p = '\\0';\n    return (p);\n err:\n    X509err(X509_F_X509_NAME_ONELINE, ERR_R_MALLOC_FAILURE);\n end:\n    BUF_MEM_free(b);\n    return (NULL);\n}\n",
    "code_after_change": "char *X509_NAME_oneline(X509_NAME *a, char *buf, int len)\n{\n    X509_NAME_ENTRY *ne;\n    int i;\n    int n, lold, l, l1, l2, num, j, type;\n    const char *s;\n    char *p;\n    unsigned char *q;\n    BUF_MEM *b = NULL;\n    static const char hex[17] = \"0123456789ABCDEF\";\n    int gs_doit[4];\n    char tmp_buf[80];\n#ifdef CHARSET_EBCDIC\n    char ebcdic_buf[1024];\n#endif\n\n    if (buf == NULL) {\n        if ((b = BUF_MEM_new()) == NULL)\n            goto err;\n        if (!BUF_MEM_grow(b, 200))\n            goto err;\n        b->data[0] = '\\0';\n        len = 200;\n    } else if (len == 0) {\n        return NULL;\n    }\n    if (a == NULL) {\n        if (b) {\n            buf = b->data;\n            OPENSSL_free(b);\n        }\n        strncpy(buf, \"NO X509_NAME\", len);\n        buf[len - 1] = '\\0';\n        return buf;\n    }\n\n    len--;                      /* space for '\\0' */\n    l = 0;\n    for (i = 0; i < sk_X509_NAME_ENTRY_num(a->entries); i++) {\n        ne = sk_X509_NAME_ENTRY_value(a->entries, i);\n        n = OBJ_obj2nid(ne->object);\n        if ((n == NID_undef) || ((s = OBJ_nid2sn(n)) == NULL)) {\n            i2t_ASN1_OBJECT(tmp_buf, sizeof(tmp_buf), ne->object);\n            s = tmp_buf;\n        }\n        l1 = strlen(s);\n\n        type = ne->value->type;\n        num = ne->value->length;\n        if (num > NAME_ONELINE_MAX) {\n            X509err(X509_F_X509_NAME_ONELINE, X509_R_NAME_TOO_LONG);\n            goto end;\n        }\n        q = ne->value->data;\n#ifdef CHARSET_EBCDIC\n        if (type == V_ASN1_GENERALSTRING ||\n            type == V_ASN1_VISIBLESTRING ||\n             type == V_ASN1_PRINTABLESTRING ||\n             type == V_ASN1_TELETEXSTRING ||\n             type == V_ASN1_VISIBLESTRING || type == V_ASN1_IA5STRING) {\n            if (num > (int)sizeof(ebcdic_buf))\n                num = sizeof(ebcdic_buf);\n            ascii2ebcdic(ebcdic_buf, q, num);\n             q = ebcdic_buf;\n         }\n #endif\n        if ((type == V_ASN1_GENERALSTRING) && ((num % 4) == 0)) {\n            gs_doit[0] = gs_doit[1] = gs_doit[2] = gs_doit[3] = 0;\n            for (j = 0; j < num; j++)\n                if (q[j] != 0)\n                    gs_doit[j & 3] = 1;\n\n            if (gs_doit[0] | gs_doit[1] | gs_doit[2])\n                gs_doit[0] = gs_doit[1] = gs_doit[2] = gs_doit[3] = 1;\n            else {\n                gs_doit[0] = gs_doit[1] = gs_doit[2] = 0;\n                gs_doit[3] = 1;\n            }\n        } else\n            gs_doit[0] = gs_doit[1] = gs_doit[2] = gs_doit[3] = 1;\n\n        for (l2 = j = 0; j < num; j++) {\n            if (!gs_doit[j & 3])\n                continue;\n            l2++;\n#ifndef CHARSET_EBCDIC\n            if ((q[j] < ' ') || (q[j] > '~'))\n                l2 += 3;\n#else\n            if ((os_toascii[q[j]] < os_toascii[' ']) ||\n                (os_toascii[q[j]] > os_toascii['~']))\n                l2 += 3;\n#endif\n        }\n\n        lold = l;\n        l += 1 + l1 + 1 + l2;\n        if (l > NAME_ONELINE_MAX) {\n            X509err(X509_F_X509_NAME_ONELINE, X509_R_NAME_TOO_LONG);\n            goto end;\n        }\n        if (b != NULL) {\n            if (!BUF_MEM_grow(b, l + 1))\n                goto err;\n            p = &(b->data[lold]);\n        } else if (l > len) {\n            break;\n        } else\n            p = &(buf[lold]);\n        *(p++) = '/';\n        memcpy(p, s, (unsigned int)l1);\n        p += l1;\n        *(p++) = '=';\n\n#ifndef CHARSET_EBCDIC          /* q was assigned above already. */\n        q = ne->value->data;\n#endif\n\n        for (j = 0; j < num; j++) {\n            if (!gs_doit[j & 3])\n                continue;\n#ifndef CHARSET_EBCDIC\n            n = q[j];\n            if ((n < ' ') || (n > '~')) {\n                *(p++) = '\\\\';\n                *(p++) = 'x';\n                *(p++) = hex[(n >> 4) & 0x0f];\n                *(p++) = hex[n & 0x0f];\n            } else\n                *(p++) = n;\n#else\n            n = os_toascii[q[j]];\n            if ((n < os_toascii[' ']) || (n > os_toascii['~'])) {\n                *(p++) = '\\\\';\n                *(p++) = 'x';\n                *(p++) = hex[(n >> 4) & 0x0f];\n                *(p++) = hex[n & 0x0f];\n            } else\n                *(p++) = q[j];\n#endif\n        }\n        *p = '\\0';\n    }\n    if (b != NULL) {\n        p = b->data;\n        OPENSSL_free(b);\n    } else\n        p = buf;\n    if (i == 0)\n        *p = '\\0';\n    return (p);\n err:\n    X509err(X509_F_X509_NAME_ONELINE, ERR_R_MALLOC_FAILURE);\n end:\n    BUF_MEM_free(b);\n    return (NULL);\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 702,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2014-4502",
    "code_before_change": "bool extract_sockaddr(char *url, char **sockaddr_url, char **sockaddr_port)\n{\n\tchar *url_begin, *url_end, *ipv6_begin, *ipv6_end, *port_start = NULL;\n\tchar url_address[256], port[6];\n\tint url_len, port_len = 0;\n\n\t*sockaddr_url = url;\n\turl_begin = strstr(url, \"//\");\n\tif (!url_begin)\n\t\turl_begin = url;\n\telse\n\t\turl_begin += 2;\n\n\t/* Look for numeric ipv6 entries */\n\tipv6_begin = strstr(url_begin, \"[\");\n\tipv6_end = strstr(url_begin, \"]\");\n\tif (ipv6_begin && ipv6_end && ipv6_end > ipv6_begin)\n\t\turl_end = strstr(ipv6_end, \":\");\n\telse\n\t\turl_end = strstr(url_begin, \":\");\n\tif (url_end) {\n\t\turl_len = url_end - url_begin;\n\t\tport_len = strlen(url_begin) - url_len - 1;\n\t\tif (port_len < 1)\n\t\t\treturn false;\n\t\tport_start = url_end + 1;\n\t} else\n\t\turl_len = strlen(url_begin);\n\n \tif (url_len < 1)\n \t\treturn false;\n \n\tsprintf(url_address, \"%.*s\", url_len, url_begin);\n \n \tif (port_len) {\n \t\tchar *slash;\n\n\t\tsnprintf(port, 6, \"%.*s\", port_len, port_start);\n\t\tslash = strchr(port, '/');\n\t\tif (slash)\n\t\t\t*slash = '\\0';\n\t} else\n\t\tstrcpy(port, \"80\");\n\n\t*sockaddr_port = strdup(port);\n\t*sockaddr_url = strdup(url_address);\n\n\treturn true;\n}\n",
    "code_after_change": "bool extract_sockaddr(char *url, char **sockaddr_url, char **sockaddr_port)\n{\n\tchar *url_begin, *url_end, *ipv6_begin, *ipv6_end, *port_start = NULL;\n\tchar url_address[256], port[6];\n\tint url_len, port_len = 0;\n\n\t*sockaddr_url = url;\n\turl_begin = strstr(url, \"//\");\n\tif (!url_begin)\n\t\turl_begin = url;\n\telse\n\t\turl_begin += 2;\n\n\t/* Look for numeric ipv6 entries */\n\tipv6_begin = strstr(url_begin, \"[\");\n\tipv6_end = strstr(url_begin, \"]\");\n\tif (ipv6_begin && ipv6_end && ipv6_end > ipv6_begin)\n\t\turl_end = strstr(ipv6_end, \":\");\n\telse\n\t\turl_end = strstr(url_begin, \":\");\n\tif (url_end) {\n\t\turl_len = url_end - url_begin;\n\t\tport_len = strlen(url_begin) - url_len - 1;\n\t\tif (port_len < 1)\n\t\t\treturn false;\n\t\tport_start = url_end + 1;\n\t} else\n\t\turl_len = strlen(url_begin);\n\n \tif (url_len < 1)\n \t\treturn false;\n \n\tsnprintf(url_address, 254, \"%.*s\", url_len, url_begin);\n \n \tif (port_len) {\n \t\tchar *slash;\n\n\t\tsnprintf(port, 6, \"%.*s\", port_len, port_start);\n\t\tslash = strchr(port, '/');\n\t\tif (slash)\n\t\t\t*slash = '\\0';\n\t} else\n\t\tstrcpy(port, \"80\");\n\n\t*sockaddr_port = strdup(port);\n\t*sockaddr_url = strdup(url_address);\n\n\treturn true;\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 716,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-4539",
    "code_before_change": "static zval *_xml_xmlchar_zval(const XML_Char *s, int len, const XML_Char *encoding)\n {\n        zval *ret;\n        MAKE_STD_ZVAL(ret);\n        if (s == NULL) {\n                ZVAL_FALSE(ret);\n                return ret;\n\t}\n\tif (len == 0) {\n\t\tlen = _xml_xmlcharlen(s);\n\t}\n\tZ_TYPE_P(ret) = IS_STRING;\n\tZ_STRVAL_P(ret) = xml_utf8_decode(s, len, &Z_STRLEN_P(ret), encoding);\n\treturn ret;\n}\n",
    "code_after_change": "static zval *_xml_xmlchar_zval(const XML_Char *s, int len, const XML_Char *encoding)\n {\n        zval *ret;\n        MAKE_STD_ZVAL(ret);\n\n        if (s == NULL) {\n                ZVAL_FALSE(ret);\n                return ret;\n\t}\n\tif (len == 0) {\n\t\tlen = _xml_xmlcharlen(s);\n\t}\n\tZ_TYPE_P(ret) = IS_STRING;\n\tZ_STRVAL_P(ret) = xml_utf8_decode(s, len, &Z_STRLEN_P(ret), encoding);\n\treturn ret;\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 732,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-1621",
    "code_before_change": "const Cluster* Segment::GetLast() const\n{\n    if ((m_clusters == NULL) || (m_clusterCount <= 0))\n        return &m_eos;\n \n    const long idx = m_clusterCount - 1;\n \n    Cluster* const pCluster = m_clusters[idx];\n    assert(pCluster);\n    return pCluster;\n }\n",
    "code_after_change": "const Cluster* Segment::GetLast() const\n  const long idx = m_clusterCount - 1;\n \n  Cluster* const pCluster = m_clusters[idx];\n  assert(pCluster);\n \n  return pCluster;\n }\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 737,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-1621",
    "code_before_change": "bool Block::IsKey() const\n{\n    return ((m_flags & static_cast<unsigned char>(1 << 7)) != 0);\n }\n",
    "code_after_change": "bool Block::IsKey() const\nvoid Block::SetKey(bool bKey) {\n  if (bKey)\n    m_flags |= static_cast<unsigned char>(1 << 7);\n  else\n    m_flags &= 0x7F;\n }\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 738,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2019-1010296",
    "code_before_change": "TEE_Result syscall_cryp_obj_populate(unsigned long obj,\n\t\t\tstruct utee_attribute *usr_attrs,\n\t\t\tunsigned long attr_count)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *sess;\n\tstruct tee_obj *o;\n\tconst struct tee_cryp_obj_type_props *type_props;\n\tTEE_Attribute *attrs = NULL;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx),\n\t\t\t  tee_svc_uref_to_vaddr(obj), &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\t/* Must be a transient object */\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_PERSISTENT) != 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\t/* Must not be initialized already */\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) != 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\ttype_props = tee_svc_find_type_props(o->info.objectType);\n \tif (!type_props)\n \t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n \n\tattrs = malloc(sizeof(TEE_Attribute) * attr_count);\n \tif (!attrs)\n \t\treturn TEE_ERROR_OUT_OF_MEMORY;\n \tres = copy_in_attrs(to_user_ta_ctx(sess->ctx), usr_attrs, attr_count,\n \t\t\t    attrs);\n \tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_svc_cryp_check_attr(ATTR_USAGE_POPULATE, type_props,\n\t\t\t\t      attrs, attr_count);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_svc_cryp_obj_populate_type(o, type_props, attrs, attr_count);\n\tif (res == TEE_SUCCESS)\n\t\to->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\n\nout:\n\tfree(attrs);\n\treturn res;\n}\n",
    "code_after_change": "TEE_Result syscall_cryp_obj_populate(unsigned long obj,\n\t\t\tstruct utee_attribute *usr_attrs,\n\t\t\tunsigned long attr_count)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *sess;\n\tstruct tee_obj *o;\n\tconst struct tee_cryp_obj_type_props *type_props;\n\tTEE_Attribute *attrs = NULL;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx),\n\t\t\t  tee_svc_uref_to_vaddr(obj), &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\t/* Must be a transient object */\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_PERSISTENT) != 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\t/* Must not be initialized already */\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) != 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\ttype_props = tee_svc_find_type_props(o->info.objectType);\n \tif (!type_props)\n \t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n \n\tsize_t alloc_size = 0;\n\n\tif (MUL_OVERFLOW(sizeof(TEE_Attribute), attr_count, &alloc_size))\n\t\treturn TEE_ERROR_OVERFLOW;\n\n\tattrs = malloc(alloc_size);\n \tif (!attrs)\n \t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\n \tres = copy_in_attrs(to_user_ta_ctx(sess->ctx), usr_attrs, attr_count,\n \t\t\t    attrs);\n \tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_svc_cryp_check_attr(ATTR_USAGE_POPULATE, type_props,\n\t\t\t\t      attrs, attr_count);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_svc_cryp_obj_populate_type(o, type_props, attrs, attr_count);\n\tif (res == TEE_SUCCESS)\n\t\to->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\n\nout:\n\tfree(attrs);\n\treturn res;\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 744,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2015-8126",
    "code_before_change": "png_set_filter(png_structp png_ptr, int method, int filters)\n{\n   png_debug(1, \"in png_set_filter\");\n\n   if (png_ptr == NULL)\n      return;\n#ifdef PNG_MNG_FEATURES_SUPPORTED\n   if ((png_ptr->mng_features_permitted & PNG_FLAG_MNG_FILTER_64) &&\n      (method == PNG_INTRAPIXEL_DIFFERENCING))\n         method = PNG_FILTER_TYPE_BASE;\n#endif\n   if (method == PNG_FILTER_TYPE_BASE)\n    {\n       switch (filters & (PNG_ALL_FILTERS | 0x07))\n       {\n #ifdef PNG_WRITE_FILTER_SUPPORTED\n          case 5:\n          case 6:\n          case 7: png_warning(png_ptr, \"Unknown row filter for method 0\");\n#endif /* PNG_WRITE_FILTER_SUPPORTED */\n         case PNG_FILTER_VALUE_NONE:\n              png_ptr->do_filter = PNG_FILTER_NONE; break;\n#ifdef PNG_WRITE_FILTER_SUPPORTED\n          case PNG_FILTER_VALUE_SUB:\n               png_ptr->do_filter = PNG_FILTER_SUB; break;\n          case PNG_FILTER_VALUE_UP:\n              png_ptr->do_filter = PNG_FILTER_UP; break;\n         case PNG_FILTER_VALUE_AVG:\n              png_ptr->do_filter = PNG_FILTER_AVG; break;\n         case PNG_FILTER_VALUE_PAETH:\n              png_ptr->do_filter = PNG_FILTER_PAETH; break;\n          default: png_ptr->do_filter = (png_byte)filters; break;\n #else\n          default: png_warning(png_ptr, \"Unknown row filter for method 0\");\n #endif /* PNG_WRITE_FILTER_SUPPORTED */\n       }\n \n      /* If we have allocated the row_buf, this means we have already started\n       * with the image and we should have allocated all of the filter buffers\n       * that have been selected.  If prev_row isn't already allocated, then\n       * it is too late to start using the filters that need it, since we\n       * will be missing the data in the previous row.  If an application\n       * wants to start and stop using particular filters during compression,\n       * it should start out with all of the filters, and then add and\n       * remove them after the start of compression.\n       */\n      if (png_ptr->row_buf != NULL)\n      {\n#ifdef PNG_WRITE_FILTER_SUPPORTED\n         if ((png_ptr->do_filter & PNG_FILTER_SUB) && png_ptr->sub_row == NULL)\n         {\n            png_ptr->sub_row = (png_bytep)png_malloc(png_ptr,\n              (png_ptr->rowbytes + 1));\n            png_ptr->sub_row[0] = PNG_FILTER_VALUE_SUB;\n         }\n\n         if ((png_ptr->do_filter & PNG_FILTER_UP) && png_ptr->up_row == NULL)\n         {\n            if (png_ptr->prev_row == NULL)\n            {\n               png_warning(png_ptr, \"Can't add Up filter after starting\");\n               png_ptr->do_filter &= ~PNG_FILTER_UP;\n            }\n            else\n            {\n               png_ptr->up_row = (png_bytep)png_malloc(png_ptr,\n                  (png_ptr->rowbytes + 1));\n               png_ptr->up_row[0] = PNG_FILTER_VALUE_UP;\n            }\n         }\n\n         if ((png_ptr->do_filter & PNG_FILTER_AVG) && png_ptr->avg_row == NULL)\n         {\n            if (png_ptr->prev_row == NULL)\n            {\n               png_warning(png_ptr, \"Can't add Average filter after starting\");\n               png_ptr->do_filter &= ~PNG_FILTER_AVG;\n            }\n            else\n            {\n               png_ptr->avg_row = (png_bytep)png_malloc(png_ptr,\n                  (png_ptr->rowbytes + 1));\n               png_ptr->avg_row[0] = PNG_FILTER_VALUE_AVG;\n            }\n         }\n\n         if ((png_ptr->do_filter & PNG_FILTER_PAETH) &&\n             png_ptr->paeth_row == NULL)\n         {\n            if (png_ptr->prev_row == NULL)\n            {\n               png_warning(png_ptr, \"Can't add Paeth filter after starting\");\n               png_ptr->do_filter &= (png_byte)(~PNG_FILTER_PAETH);\n            }\n            else\n            {\n               png_ptr->paeth_row = (png_bytep)png_malloc(png_ptr,\n                  (png_ptr->rowbytes + 1));\n               png_ptr->paeth_row[0] = PNG_FILTER_VALUE_PAETH;\n            }\n         }\n\n         if (png_ptr->do_filter == PNG_NO_FILTERS)\n#endif /* PNG_WRITE_FILTER_SUPPORTED */\n            png_ptr->do_filter = PNG_FILTER_NONE;\n      }\n   }\n   else\n      png_error(png_ptr, \"Unknown custom filter method\");\n}\n",
    "code_after_change": "png_set_filter(png_structp png_ptr, int method, int filters)\n{\n   png_debug(1, \"in png_set_filter\");\n\n   if (png_ptr == NULL)\n      return;\n#ifdef PNG_MNG_FEATURES_SUPPORTED\n   if ((png_ptr->mng_features_permitted & PNG_FLAG_MNG_FILTER_64) &&\n      (method == PNG_INTRAPIXEL_DIFFERENCING))\n         method = PNG_FILTER_TYPE_BASE;\n#endif\n   if (method == PNG_FILTER_TYPE_BASE)\n    {\n       switch (filters & (PNG_ALL_FILTERS | 0x07))\n       {\n         case PNG_FILTER_VALUE_NONE:\n              png_ptr->do_filter = PNG_FILTER_NONE; break;\n #ifdef PNG_WRITE_FILTER_SUPPORTED\n          case 5:\n          case 6:\n          case 7: png_warning(png_ptr, \"Unknown row filter for method 0\");\n                 break;\n          case PNG_FILTER_VALUE_SUB:\n               png_ptr->do_filter = PNG_FILTER_SUB; break;\n          case PNG_FILTER_VALUE_UP:\n              png_ptr->do_filter = PNG_FILTER_UP; break;\n         case PNG_FILTER_VALUE_AVG:\n              png_ptr->do_filter = PNG_FILTER_AVG; break;\n         case PNG_FILTER_VALUE_PAETH:\n              png_ptr->do_filter = PNG_FILTER_PAETH; break;\n          default: png_ptr->do_filter = (png_byte)filters; break;\n #else\n          default: png_warning(png_ptr, \"Unknown row filter for method 0\");\n                 break;\n #endif /* PNG_WRITE_FILTER_SUPPORTED */\n       }\n \n      /* If we have allocated the row_buf, this means we have already started\n       * with the image and we should have allocated all of the filter buffers\n       * that have been selected.  If prev_row isn't already allocated, then\n       * it is too late to start using the filters that need it, since we\n       * will be missing the data in the previous row.  If an application\n       * wants to start and stop using particular filters during compression,\n       * it should start out with all of the filters, and then add and\n       * remove them after the start of compression.\n       */\n      if (png_ptr->row_buf != NULL)\n      {\n#ifdef PNG_WRITE_FILTER_SUPPORTED\n         if ((png_ptr->do_filter & PNG_FILTER_SUB) && png_ptr->sub_row == NULL)\n         {\n            png_ptr->sub_row = (png_bytep)png_malloc(png_ptr,\n              (png_ptr->rowbytes + 1));\n            png_ptr->sub_row[0] = PNG_FILTER_VALUE_SUB;\n         }\n\n         if ((png_ptr->do_filter & PNG_FILTER_UP) && png_ptr->up_row == NULL)\n         {\n            if (png_ptr->prev_row == NULL)\n            {\n               png_warning(png_ptr, \"Can't add Up filter after starting\");\n               png_ptr->do_filter &= ~PNG_FILTER_UP;\n            }\n            else\n            {\n               png_ptr->up_row = (png_bytep)png_malloc(png_ptr,\n                  (png_ptr->rowbytes + 1));\n               png_ptr->up_row[0] = PNG_FILTER_VALUE_UP;\n            }\n         }\n\n         if ((png_ptr->do_filter & PNG_FILTER_AVG) && png_ptr->avg_row == NULL)\n         {\n            if (png_ptr->prev_row == NULL)\n            {\n               png_warning(png_ptr, \"Can't add Average filter after starting\");\n               png_ptr->do_filter &= ~PNG_FILTER_AVG;\n            }\n            else\n            {\n               png_ptr->avg_row = (png_bytep)png_malloc(png_ptr,\n                  (png_ptr->rowbytes + 1));\n               png_ptr->avg_row[0] = PNG_FILTER_VALUE_AVG;\n            }\n         }\n\n         if ((png_ptr->do_filter & PNG_FILTER_PAETH) &&\n             png_ptr->paeth_row == NULL)\n         {\n            if (png_ptr->prev_row == NULL)\n            {\n               png_warning(png_ptr, \"Can't add Paeth filter after starting\");\n               png_ptr->do_filter &= (png_byte)(~PNG_FILTER_PAETH);\n            }\n            else\n            {\n               png_ptr->paeth_row = (png_bytep)png_malloc(png_ptr,\n                  (png_ptr->rowbytes + 1));\n               png_ptr->paeth_row[0] = PNG_FILTER_VALUE_PAETH;\n            }\n         }\n\n         if (png_ptr->do_filter == PNG_NO_FILTERS)\n#endif /* PNG_WRITE_FILTER_SUPPORTED */\n            png_ptr->do_filter = PNG_FILTER_NONE;\n      }\n   }\n   else\n      png_error(png_ptr, \"Unknown custom filter method\");\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 748,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-5200",
    "code_before_change": "base::string16 GetRelyingPartyIdString(\n    AuthenticatorRequestDialogModel* dialog_model) {\n  static constexpr char kRpIdUrlPrefix[] = \"https://\";\n  static constexpr int kDialogWidth = 300;\n   const auto& rp_id = dialog_model->relying_party_id();\n   DCHECK(!rp_id.empty());\n   GURL rp_id_url(kRpIdUrlPrefix + rp_id);\n  auto max_static_string_length = gfx::GetStringWidthF(\n      l10n_util::GetStringUTF16(IDS_WEBAUTHN_GENERIC_TITLE), gfx::FontList(),\n      gfx::Typesetter::DEFAULT);\n  return url_formatter::ElideHost(rp_id_url, gfx::FontList(),\n                                  kDialogWidth - max_static_string_length);\n }\n",
    "code_after_change": "base::string16 GetRelyingPartyIdString(\n    AuthenticatorRequestDialogModel* dialog_model) {\n  static constexpr char kRpIdUrlPrefix[] = \"https://\";\n  static constexpr int kDialogWidth = 300;\n   const auto& rp_id = dialog_model->relying_party_id();\n   DCHECK(!rp_id.empty());\n   GURL rp_id_url(kRpIdUrlPrefix + rp_id);\n  return url_formatter::ElideHost(rp_id_url, gfx::FontList(), kDialogWidth);\n }\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 762,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2012-2895",
    "code_before_change": "bool DeleteSymlink(const FilePath& file_path) {\n  const bool deleted = HANDLE_EINTR(unlink(file_path.value().c_str())) == 0;\n  return deleted;\n}\n",
    "code_after_change": "bool DeleteSymlink(const FilePath& file_path) {\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 765,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2013-4263",
    "code_before_change": "static int filter_frame(AVFilterLink *inlink, AVFrame *in)\n{\n    DelogoContext *s = inlink->dst->priv;\n    AVFilterLink *outlink = inlink->dst->outputs[0];\n    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(inlink->format);\n    AVFrame *out;\n    int hsub0 = desc->log2_chroma_w;\n    int vsub0 = desc->log2_chroma_h;\n    int direct = 0;\n    int plane;\n    AVRational sar;\n\n    if (av_frame_is_writable(in)) {\n        direct = 1;\n        out = in;\n    } else {\n        out = ff_get_video_buffer(outlink, outlink->w, outlink->h);\n        if (!out) {\n            av_frame_free(&in);\n            return AVERROR(ENOMEM);\n        }\n\n        av_frame_copy_props(out, in);\n    }\n\n    sar = in->sample_aspect_ratio;\n    /* Assume square pixels if SAR is unknown */\n     if (!sar.num)\n         sar.num = sar.den = 1;\n \n    for (plane = 0; plane < 4 && in->data[plane]; plane++) {\n         int hsub = plane == 1 || plane == 2 ? hsub0 : 0;\n         int vsub = plane == 1 || plane == 2 ? vsub0 : 0;\n \n        apply_delogo(out->data[plane], out->linesize[plane],\n                     in ->data[plane], in ->linesize[plane],\n                     FF_CEIL_RSHIFT(inlink->w, hsub),\n                     FF_CEIL_RSHIFT(inlink->h, vsub),\n                     sar, s->x>>hsub, s->y>>vsub,\n                     /* Up and left borders were rounded down, inject lost bits\n                      * into width and height to avoid error accumulation */\n                     FF_CEIL_RSHIFT(s->w + (s->x & ((1<<hsub)-1)), hsub),\n                     FF_CEIL_RSHIFT(s->h + (s->y & ((1<<vsub)-1)), vsub),\n                     s->band>>FFMIN(hsub, vsub),\n                     s->show, direct);\n    }\n\n    if (!direct)\n        av_frame_free(&in);\n\n    return ff_filter_frame(outlink, out);\n}\n",
    "code_after_change": "static int filter_frame(AVFilterLink *inlink, AVFrame *in)\n{\n    DelogoContext *s = inlink->dst->priv;\n    AVFilterLink *outlink = inlink->dst->outputs[0];\n    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(inlink->format);\n    AVFrame *out;\n    int hsub0 = desc->log2_chroma_w;\n    int vsub0 = desc->log2_chroma_h;\n    int direct = 0;\n    int plane;\n    AVRational sar;\n\n    if (av_frame_is_writable(in)) {\n        direct = 1;\n        out = in;\n    } else {\n        out = ff_get_video_buffer(outlink, outlink->w, outlink->h);\n        if (!out) {\n            av_frame_free(&in);\n            return AVERROR(ENOMEM);\n        }\n\n        av_frame_copy_props(out, in);\n    }\n\n    sar = in->sample_aspect_ratio;\n    /* Assume square pixels if SAR is unknown */\n     if (!sar.num)\n         sar.num = sar.den = 1;\n \n    for (plane = 0; plane < 4 && in->data[plane] && in->linesize[plane]; plane++) {\n         int hsub = plane == 1 || plane == 2 ? hsub0 : 0;\n         int vsub = plane == 1 || plane == 2 ? vsub0 : 0;\n \n        apply_delogo(out->data[plane], out->linesize[plane],\n                     in ->data[plane], in ->linesize[plane],\n                     FF_CEIL_RSHIFT(inlink->w, hsub),\n                     FF_CEIL_RSHIFT(inlink->h, vsub),\n                     sar, s->x>>hsub, s->y>>vsub,\n                     /* Up and left borders were rounded down, inject lost bits\n                      * into width and height to avoid error accumulation */\n                     FF_CEIL_RSHIFT(s->w + (s->x & ((1<<hsub)-1)), hsub),\n                     FF_CEIL_RSHIFT(s->h + (s->y & ((1<<vsub)-1)), vsub),\n                     s->band>>FFMIN(hsub, vsub),\n                     s->show, direct);\n    }\n\n    if (!direct)\n        av_frame_free(&in);\n\n    return ff_filter_frame(outlink, out);\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 769,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-2428",
    "code_before_change": "static int aacDecoder_drcExtractAndMap (\n        HANDLE_AAC_DRC  self,\n        HANDLE_FDK_BITSTREAM hBs,\n CAacDecoderStaticChannelInfo *pAacDecoderStaticChannelInfo[],\n        UCHAR  pceInstanceTag,\n        UCHAR  channelMapping[], /* Channel mapping translating drcChannel index to canonical channel index */\n int    validChannels )\n{\n CDrcPayload  threadBs[MAX_DRC_THREADS];\n CDrcPayload *validThreadBs[MAX_DRC_THREADS];\n CDrcParams *pParams;\n  UINT backupBsPosition;\n int  i, thread, validThreads = 0;\n int  numExcludedChns[MAX_DRC_THREADS];\n\n  FDK_ASSERT(self != NULL);\n  FDK_ASSERT(hBs != NULL);\n  FDK_ASSERT(pAacDecoderStaticChannelInfo != NULL);\n\n  pParams = &self->params;\n\n  self->numThreads = 0;\n  backupBsPosition = FDKgetValidBits(hBs);\n\n for (i = 0; i < self->numPayloads && self->numThreads < MAX_DRC_THREADS; i++) {\n int bitsParsed;\n\n /* Init payload data chunk. The memclear is very important because it initializes\n       the most values. Without it the module wouldn't work properly or crash. */\n FDKmemclear(&threadBs[self->numThreads], sizeof(CDrcPayload));\n    threadBs[self->numThreads].channelData.bandTop[0] = (1024 >> 2) - 1;\n\n /* Extract payload */\n    bitsParsed = aacDecoder_drcParse( hBs,\n &threadBs[self->numThreads],\n                                      self->drcPayloadPosition[i] );\n if (bitsParsed > 0) {\n      self->numThreads++;\n }\n\n   }\n   self->numPayloads = 0;\n \n   if (self->dvbAncDataAvailable)\n   { /* Append a DVB heavy compression payload thread if available. */\n     int bitsParsed;\n\n /* Init payload data chunk. The memclear is very important because it initializes\n       the most values. Without it the module wouldn't work properly or crash. */\n FDKmemclear(&threadBs[self->numThreads], sizeof(CDrcPayload));\n    threadBs[self->numThreads].channelData.bandTop[0] = (1024 >> 2) - 1;\n\n /* Extract payload */\n    bitsParsed = aacDecoder_drcReadCompression( hBs,\n &threadBs[self->numThreads],\n                                                self->dvbAncDataPosition );\n if (bitsParsed > 0) {\n      self->numThreads++;\n }\n }\n  self->dvbAncDataAvailable = 0;\n\n /* Reset the bitbufffer */\n FDKpushBiDirectional(hBs, FDKgetValidBits(hBs) - backupBsPosition);\n\n /* calculate number of valid bits in excl_chn_mask */\n\n \n   /* coupling channels not supported */\n \n   /* check for valid threads */\n   for (thread = 0; thread < self->numThreads; thread++) {\n     CDrcPayload *pThreadBs = &threadBs[thread];\n int numExclChns = 0;\n\n switch ((AACDEC_DRC_PAYLOAD_TYPE)pThreadBs->channelData.drcDataType) {\n default:\n continue;\n case MPEG_DRC_EXT_DATA:\n case DVB_DRC_ANC_DATA:\n break;\n }\n\n if (pThreadBs->pceInstanceTag >= 0) { /* if PCE tag present */\n if (pThreadBs->pceInstanceTag != pceInstanceTag) {\n continue; /* don't accept */\n }\n }\n\n /* calculate number of excluded channels */\n if (pThreadBs->excludedChnsMask > 0) {\n      INT exclMask = pThreadBs->excludedChnsMask;\n int ch;\n for (ch = 0; ch < validChannels; ch++) {\n        numExclChns += exclMask & 0x1;\n        exclMask >>= 1;\n }\n }\n if (numExclChns < validChannels) {\n      validThreadBs[validThreads] = pThreadBs;\n      numExcludedChns[validThreads] = numExclChns;\n      validThreads++;\n }\n }\n\n if (validThreads > 1) {\n int ch;\n\n /* check consistency of excl_chn_mask amongst valid DRC threads */\n for (ch = 0; ch < validChannels; ch++) {\n int present = 0;\n\n for (thread = 0; thread < validThreads; thread++) {\n CDrcPayload *pThreadBs = validThreadBs[thread];\n\n\n /* thread applies to this channel */\n if ( (pThreadBs->channelData.drcDataType == MPEG_DRC_EXT_DATA)\n && ( (numExcludedChns[thread] == 0)\n || (!(pThreadBs->excludedChnsMask & (1<<ch))) ) ) {\n          present++;\n }\n }\n\n\n if (present > 1) {\n return -1;\n }\n }\n }\n\n /* map DRC bitstream information onto DRC channel information */\n for (thread = 0; thread < validThreads; thread++)\n {\n CDrcPayload *pThreadBs = validThreadBs[thread];\n    INT exclMask = pThreadBs->excludedChnsMask;\n    AACDEC_DRC_PAYLOAD_TYPE drcPayloadType = (AACDEC_DRC_PAYLOAD_TYPE)pThreadBs->channelData.drcDataType;\n int ch;\n\n /* last progRefLevel transmitted is the one that is used\n     * (but it should really only be transmitted once per block!)\n     */\n if (pThreadBs->progRefLevel >= 0) {\n      self->progRefLevel = pThreadBs->progRefLevel;\n      self->progRefLevelPresent = 1;\n      self->prlExpiryCount = 0; /* Got a new value -> Reset counter */\n }\n\n if (drcPayloadType == DVB_DRC_ANC_DATA) {\n /* Announce the presentation mode of this valid thread. */\n      self->presMode = pThreadBs->presMode;\n }\n\n /* SCE, CPE and LFE */\n for (ch = 0; ch < validChannels; ch++) {\n int mapedChannel = channelMapping[ch];\n\n if ( ((exclMask & (1<<mapedChannel)) == 0)\n && ( (drcPayloadType == MPEG_DRC_EXT_DATA)\n || ((drcPayloadType == DVB_DRC_ANC_DATA) && self->params.applyHeavyCompression)\n ) ) {\n /* copy thread to channel */\n        pAacDecoderStaticChannelInfo[ch]->drcData = pThreadBs->channelData;\n }\n }\n /* CCEs not supported by now */\n }\n\n /* Increment and check expiry counter for the program reference level: */\n if ( (pParams->expiryFrame > 0)\n && (self->prlExpiryCount++ > pParams->expiryFrame) )\n { /* The program reference level is too old, so set it back to the target level. */\n    self->progRefLevelPresent = 0;\n    self->progRefLevel = pParams->targetRefLevel;\n    self->prlExpiryCount = 0;\n }\n\n return 0;\n}\n",
    "code_after_change": "static int aacDecoder_drcExtractAndMap (\n        HANDLE_AAC_DRC  self,\n        HANDLE_FDK_BITSTREAM hBs,\n CAacDecoderStaticChannelInfo *pAacDecoderStaticChannelInfo[],\n        UCHAR  pceInstanceTag,\n        UCHAR  channelMapping[], /* Channel mapping translating drcChannel index to canonical channel index */\n int    validChannels )\n{\n CDrcPayload  threadBs[MAX_DRC_THREADS];\n CDrcPayload *validThreadBs[MAX_DRC_THREADS];\n CDrcParams *pParams;\n  UINT backupBsPosition;\n int  i, thread, validThreads = 0;\n int  numExcludedChns[MAX_DRC_THREADS];\n\n  FDK_ASSERT(self != NULL);\n  FDK_ASSERT(hBs != NULL);\n  FDK_ASSERT(pAacDecoderStaticChannelInfo != NULL);\n\n  pParams = &self->params;\n\n  self->numThreads = 0;\n  backupBsPosition = FDKgetValidBits(hBs);\n\n for (i = 0; i < self->numPayloads && self->numThreads < MAX_DRC_THREADS; i++) {\n int bitsParsed;\n\n /* Init payload data chunk. The memclear is very important because it initializes\n       the most values. Without it the module wouldn't work properly or crash. */\n FDKmemclear(&threadBs[self->numThreads], sizeof(CDrcPayload));\n    threadBs[self->numThreads].channelData.bandTop[0] = (1024 >> 2) - 1;\n\n /* Extract payload */\n    bitsParsed = aacDecoder_drcParse( hBs,\n &threadBs[self->numThreads],\n                                      self->drcPayloadPosition[i] );\n if (bitsParsed > 0) {\n      self->numThreads++;\n }\n\n   }\n   self->numPayloads = 0;\n \n  if (self->numThreads >= MAX_DRC_THREADS) {\n      self->numThreads = MAX_DRC_THREADS - 1;\n  }\n\n   if (self->dvbAncDataAvailable)\n   { /* Append a DVB heavy compression payload thread if available. */\n     int bitsParsed;\n\n /* Init payload data chunk. The memclear is very important because it initializes\n       the most values. Without it the module wouldn't work properly or crash. */\n FDKmemclear(&threadBs[self->numThreads], sizeof(CDrcPayload));\n    threadBs[self->numThreads].channelData.bandTop[0] = (1024 >> 2) - 1;\n\n /* Extract payload */\n    bitsParsed = aacDecoder_drcReadCompression( hBs,\n &threadBs[self->numThreads],\n                                                self->dvbAncDataPosition );\n if (bitsParsed > 0) {\n      self->numThreads++;\n }\n }\n  self->dvbAncDataAvailable = 0;\n\n /* Reset the bitbufffer */\n FDKpushBiDirectional(hBs, FDKgetValidBits(hBs) - backupBsPosition);\n\n /* calculate number of valid bits in excl_chn_mask */\n\n \n   /* coupling channels not supported */\n \n  if (self->numThreads >= MAX_DRC_THREADS) {\n      self->numThreads = MAX_DRC_THREADS - 1;\n  }\n\n   /* check for valid threads */\n   for (thread = 0; thread < self->numThreads; thread++) {\n     CDrcPayload *pThreadBs = &threadBs[thread];\n int numExclChns = 0;\n\n switch ((AACDEC_DRC_PAYLOAD_TYPE)pThreadBs->channelData.drcDataType) {\n default:\n continue;\n case MPEG_DRC_EXT_DATA:\n case DVB_DRC_ANC_DATA:\n break;\n }\n\n if (pThreadBs->pceInstanceTag >= 0) { /* if PCE tag present */\n if (pThreadBs->pceInstanceTag != pceInstanceTag) {\n continue; /* don't accept */\n }\n }\n\n /* calculate number of excluded channels */\n if (pThreadBs->excludedChnsMask > 0) {\n      INT exclMask = pThreadBs->excludedChnsMask;\n int ch;\n for (ch = 0; ch < validChannels; ch++) {\n        numExclChns += exclMask & 0x1;\n        exclMask >>= 1;\n }\n }\n if (numExclChns < validChannels) {\n      validThreadBs[validThreads] = pThreadBs;\n      numExcludedChns[validThreads] = numExclChns;\n      validThreads++;\n }\n }\n\n if (validThreads > 1) {\n int ch;\n\n /* check consistency of excl_chn_mask amongst valid DRC threads */\n for (ch = 0; ch < validChannels; ch++) {\n int present = 0;\n\n for (thread = 0; thread < validThreads; thread++) {\n CDrcPayload *pThreadBs = validThreadBs[thread];\n\n\n /* thread applies to this channel */\n if ( (pThreadBs->channelData.drcDataType == MPEG_DRC_EXT_DATA)\n && ( (numExcludedChns[thread] == 0)\n || (!(pThreadBs->excludedChnsMask & (1<<ch))) ) ) {\n          present++;\n }\n }\n\n\n if (present > 1) {\n return -1;\n }\n }\n }\n\n /* map DRC bitstream information onto DRC channel information */\n for (thread = 0; thread < validThreads; thread++)\n {\n CDrcPayload *pThreadBs = validThreadBs[thread];\n    INT exclMask = pThreadBs->excludedChnsMask;\n    AACDEC_DRC_PAYLOAD_TYPE drcPayloadType = (AACDEC_DRC_PAYLOAD_TYPE)pThreadBs->channelData.drcDataType;\n int ch;\n\n /* last progRefLevel transmitted is the one that is used\n     * (but it should really only be transmitted once per block!)\n     */\n if (pThreadBs->progRefLevel >= 0) {\n      self->progRefLevel = pThreadBs->progRefLevel;\n      self->progRefLevelPresent = 1;\n      self->prlExpiryCount = 0; /* Got a new value -> Reset counter */\n }\n\n if (drcPayloadType == DVB_DRC_ANC_DATA) {\n /* Announce the presentation mode of this valid thread. */\n      self->presMode = pThreadBs->presMode;\n }\n\n /* SCE, CPE and LFE */\n for (ch = 0; ch < validChannels; ch++) {\n int mapedChannel = channelMapping[ch];\n\n if ( ((exclMask & (1<<mapedChannel)) == 0)\n && ( (drcPayloadType == MPEG_DRC_EXT_DATA)\n || ((drcPayloadType == DVB_DRC_ANC_DATA) && self->params.applyHeavyCompression)\n ) ) {\n /* copy thread to channel */\n        pAacDecoderStaticChannelInfo[ch]->drcData = pThreadBs->channelData;\n }\n }\n /* CCEs not supported by now */\n }\n\n /* Increment and check expiry counter for the program reference level: */\n if ( (pParams->expiryFrame > 0)\n && (self->prlExpiryCount++ > pParams->expiryFrame) )\n { /* The program reference level is too old, so set it back to the target level. */\n    self->progRefLevelPresent = 0;\n    self->progRefLevel = pParams->targetRefLevel;\n    self->prlExpiryCount = 0;\n }\n\n return 0;\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 772,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-1621",
    "code_before_change": "long SeekHead::Parse()\n{\n    IMkvReader* const pReader = m_pSegment->m_pReader;\n \n    long long pos = m_start;\n    const long long stop = m_start + m_size;\n \n \n    int entry_count = 0;\n    int void_element_count = 0;\n \n    while (pos < stop)\n    {\n        long long id, size;\n \n        const long status = ParseElementHeader(\n                                pReader,\n                                pos,\n                                stop,\n                                id,\n                                size);\n \n        if (status < 0)  //error\n            return status;\n \n        if (id == 0x0DBB)  //SeekEntry ID\n            ++entry_count;\n        else if (id == 0x6C)  //Void ID\n            ++void_element_count;\n \n        pos += size;  //consume payload\n        assert(pos <= stop);\n     }\n \n    assert(pos == stop);\n \n    m_entries = new (std::nothrow) Entry[entry_count];\n \n    if (m_entries == NULL)\n        return -1;\n \n    m_void_elements = new (std::nothrow) VoidElement[void_element_count];\n \n    if (m_void_elements == NULL)\n        return -1;\n \n \n    Entry* pEntry = m_entries;\n    VoidElement* pVoidElement = m_void_elements;\n \n    pos = m_start;\n \n    while (pos < stop)\n    {\n        const long long idpos = pos;\n        long long id, size;\n        const long status = ParseElementHeader(\n                                pReader,\n                                pos,\n                                stop,\n                                id,\n                                size);\n        if (status < 0)  //error\n            return status;\n        if (id == 0x0DBB)  //SeekEntry ID\n        {\n            if (ParseEntry(pReader, pos, size, pEntry))\n            {\n                Entry& e = *pEntry++;\n                e.element_start = idpos;\n                e.element_size = (pos + size) - idpos;\n            }\n        }\n        else if (id == 0x6C)  //Void ID\n        {\n            VoidElement& e = *pVoidElement++;\n            e.element_start = idpos;\n            e.element_size = (pos + size) - idpos;\n        }\n        pos += size;  //consume payload\n        assert(pos <= stop);\n    }\n    assert(pos == stop);\n    ptrdiff_t count_ = ptrdiff_t(pEntry - m_entries);\n    assert(count_ >= 0);\n    assert(count_ <= entry_count);\n    m_entry_count = static_cast<int>(count_);\n    count_ = ptrdiff_t(pVoidElement - m_void_elements);\n    assert(count_ >= 0);\n    assert(count_ <= void_element_count);\n    m_void_element_count = static_cast<int>(count_);\n     return 0;\n }\n",
    "code_after_change": "long SeekHead::Parse()\n  long long pos = m_start;\n  const long long stop = m_start + m_size;\n \n  // first count the seek head entries\n \n  int entry_count = 0;\n  int void_element_count = 0;\n \n  while (pos < stop) {\n    long long id, size;\n \n    const long status = ParseElementHeader(pReader, pos, stop, id, size);\n \n    if (status < 0)  // error\n      return status;\n \n    if (id == 0x0DBB)  // SeekEntry ID\n      ++entry_count;\n    else if (id == 0x6C)  // Void ID\n      ++void_element_count;\n \n    pos += size;  // consume payload\n    assert(pos <= stop);\n  }\n \n  assert(pos == stop);\n\n  m_entries = new (std::nothrow) Entry[entry_count];\n\n  if (m_entries == NULL)\n    return -1;\n\n  m_void_elements = new (std::nothrow) VoidElement[void_element_count];\n\n  if (m_void_elements == NULL)\n    return -1;\n\n  // now parse the entries and void elements\n\n  Entry* pEntry = m_entries;\n  VoidElement* pVoidElement = m_void_elements;\n\n  pos = m_start;\n\n  while (pos < stop) {\n    const long long idpos = pos;\n\n    long long id, size;\n\n    const long status = ParseElementHeader(pReader, pos, stop, id, size);\n\n    if (status < 0)  // error\n      return status;\n\n    if (id == 0x0DBB) {  // SeekEntry ID\n      if (ParseEntry(pReader, pos, size, pEntry)) {\n        Entry& e = *pEntry++;\n\n        e.element_start = idpos;\n        e.element_size = (pos + size) - idpos;\n      }\n    } else if (id == 0x6C) {  // Void ID\n      VoidElement& e = *pVoidElement++;\n\n      e.element_start = idpos;\n      e.element_size = (pos + size) - idpos;\n     }\n \n    pos += size;  // consume payload\n    assert(pos <= stop);\n  }\n \n  assert(pos == stop);\n \n  ptrdiff_t count_ = ptrdiff_t(pEntry - m_entries);\n  assert(count_ >= 0);\n  assert(count_ <= entry_count);\n \n  m_entry_count = static_cast<int>(count_);\n \n  count_ = ptrdiff_t(pVoidElement - m_void_elements);\n  assert(count_ >= 0);\n  assert(count_ <= void_element_count);\n \n  m_void_element_count = static_cast<int>(count_);\n \n  return 0;\n}\n \nint SeekHead::GetCount() const { return m_entry_count; }\n \nconst SeekHead::Entry* SeekHead::GetEntry(int idx) const {\n  if (idx < 0)\n     return 0;\n\n  if (idx >= m_entry_count)\n    return 0;\n\n  return m_entries + idx;\n }\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 802,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2017-5044",
    "code_before_change": "ScriptPromise Bluetooth::requestLEScan(ScriptState* script_state,\n                                       const BluetoothLEScanOptions* options,\n                                       ExceptionState& exception_state) {\n  ExecutionContext* context = ExecutionContext::From(script_state);\n  DCHECK(context);\n\n  context->AddConsoleMessage(ConsoleMessage::Create(\n      mojom::ConsoleMessageSource::kJavaScript,\n      mojom::ConsoleMessageLevel::kInfo,\n      \"Web Bluetooth Scanning is experimental on this platform. See \"\n      \"https://github.com/WebBluetoothCG/web-bluetooth/blob/gh-pages/\"\n      \"implementation-status.md\"));\n\n  CHECK(context->IsSecureContext());\n\n  auto& doc = *To<Document>(context);\n  auto* frame = doc.GetFrame();\n  if (!frame) {\n    return ScriptPromise::Reject(\n        script_state, V8ThrowException::CreateTypeError(\n                          script_state->GetIsolate(), \"Document not active\"));\n  }\n\n  if (!LocalFrame::HasTransientUserActivation(frame)) {\n    return ScriptPromise::RejectWithDOMException(\n        script_state,\n        MakeGarbageCollected<DOMException>(\n            DOMExceptionCode::kSecurityError,\n             \"Must be handling a user gesture to show a permission request.\"));\n   }\n \n  if (!service_) {\n    frame->GetInterfaceProvider().GetInterface(mojo::MakeRequest(\n        &service_, context->GetTaskRunner(TaskType::kMiscPlatformAPI)));\n  }\n \n   auto scan_options = mojom::blink::WebBluetoothRequestLEScanOptions::New();\n   ConvertRequestLEScanOptions(options, scan_options, exception_state);\n\n  if (exception_state.HadException())\n    return ScriptPromise();\n\n  Platform::Current()->RecordRapporURL(\"Bluetooth.APIUsage.Origin\", doc.Url());\n\n  auto* resolver = MakeGarbageCollected<ScriptPromiseResolver>(script_state);\n  ScriptPromise promise = resolver->Promise();\n\n  mojom::blink::WebBluetoothScanClientAssociatedPtrInfo client;\n  mojo::BindingId id = client_bindings_.AddBinding(\n      this, mojo::MakeRequest(&client),\n      context->GetTaskRunner(TaskType::kMiscPlatformAPI));\n\n  service_->RequestScanningStart(\n      std::move(client), std::move(scan_options),\n      WTF::Bind(&Bluetooth::RequestScanningCallback, WrapPersistent(this),\n                WrapPersistent(resolver), id));\n\n  return promise;\n}\n",
    "code_after_change": "ScriptPromise Bluetooth::requestLEScan(ScriptState* script_state,\n                                       const BluetoothLEScanOptions* options,\n                                       ExceptionState& exception_state) {\n  ExecutionContext* context = ExecutionContext::From(script_state);\n  DCHECK(context);\n\n  context->AddConsoleMessage(ConsoleMessage::Create(\n      mojom::ConsoleMessageSource::kJavaScript,\n      mojom::ConsoleMessageLevel::kInfo,\n      \"Web Bluetooth Scanning is experimental on this platform. See \"\n      \"https://github.com/WebBluetoothCG/web-bluetooth/blob/gh-pages/\"\n      \"implementation-status.md\"));\n\n  CHECK(context->IsSecureContext());\n\n  auto& doc = *To<Document>(context);\n  auto* frame = doc.GetFrame();\n  if (!frame) {\n    return ScriptPromise::Reject(\n        script_state, V8ThrowException::CreateTypeError(\n                          script_state->GetIsolate(), \"Document not active\"));\n  }\n\n  if (!LocalFrame::HasTransientUserActivation(frame)) {\n    return ScriptPromise::RejectWithDOMException(\n        script_state,\n        MakeGarbageCollected<DOMException>(\n            DOMExceptionCode::kSecurityError,\n             \"Must be handling a user gesture to show a permission request.\"));\n   }\n \n  EnsureServiceConnection();\n \n   auto scan_options = mojom::blink::WebBluetoothRequestLEScanOptions::New();\n   ConvertRequestLEScanOptions(options, scan_options, exception_state);\n\n  if (exception_state.HadException())\n    return ScriptPromise();\n\n  Platform::Current()->RecordRapporURL(\"Bluetooth.APIUsage.Origin\", doc.Url());\n\n  auto* resolver = MakeGarbageCollected<ScriptPromiseResolver>(script_state);\n  ScriptPromise promise = resolver->Promise();\n\n  mojom::blink::WebBluetoothScanClientAssociatedPtrInfo client;\n  mojo::BindingId id = client_bindings_.AddBinding(\n      this, mojo::MakeRequest(&client),\n      context->GetTaskRunner(TaskType::kMiscPlatformAPI));\n\n  service_->RequestScanningStart(\n      std::move(client), std::move(scan_options),\n      WTF::Bind(&Bluetooth::RequestScanningCallback, WrapPersistent(this),\n                WrapPersistent(resolver), id));\n\n  return promise;\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 805,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2011-3104",
    "code_before_change": "void NTPResourceCache::CreateNewTabHTML() {\n  DictionaryValue localized_strings;\n  localized_strings.SetString(\"bookmarkbarattached\",\n      profile_->GetPrefs()->GetBoolean(prefs::kShowBookmarkBar) ?\n      \"true\" : \"false\");\n  localized_strings.SetString(\"hasattribution\",\n      ThemeServiceFactory::GetForProfile(profile_)->HasCustomImage(\n          IDR_THEME_NTP_ATTRIBUTION) ?\n      \"true\" : \"false\");\n  localized_strings.SetString(\"title\",\n      l10n_util::GetStringUTF16(IDS_NEW_TAB_TITLE));\n  localized_strings.SetString(\"mostvisited\",\n      l10n_util::GetStringUTF16(IDS_NEW_TAB_MOST_VISITED));\n  localized_strings.SetString(\"restoreThumbnailsShort\",\n      l10n_util::GetStringUTF16(IDS_NEW_TAB_RESTORE_THUMBNAILS_SHORT_LINK));\n  localized_strings.SetString(\"recentlyclosed\",\n      l10n_util::GetStringUTF16(IDS_NEW_TAB_RECENTLY_CLOSED));\n  localized_strings.SetString(\"closedwindowsingle\",\n      l10n_util::GetStringUTF16(IDS_NEW_TAB_RECENTLY_CLOSED_WINDOW_SINGLE));\n  localized_strings.SetString(\"closedwindowmultiple\",\n      l10n_util::GetStringUTF16(IDS_NEW_TAB_RECENTLY_CLOSED_WINDOW_MULTIPLE));\n  localized_strings.SetString(\"attributionintro\",\n      l10n_util::GetStringUTF16(IDS_NEW_TAB_ATTRIBUTION_INTRO));\n  localized_strings.SetString(\"thumbnailremovednotification\",\n      l10n_util::GetStringUTF16(IDS_NEW_TAB_THUMBNAIL_REMOVED_NOTIFICATION));\n  localized_strings.SetString(\"undothumbnailremove\",\n      l10n_util::GetStringUTF16(IDS_NEW_TAB_UNDO_THUMBNAIL_REMOVE));\n   localized_strings.SetString(\"removethumbnailtooltip\",\n       l10n_util::GetStringUTF16(IDS_NEW_TAB_REMOVE_THUMBNAIL_TOOLTIP));\n   localized_strings.SetString(\"appuninstall\",\n      l10n_util::GetStringFUTF16(\n          IDS_EXTENSIONS_UNINSTALL,\n          l10n_util::GetStringUTF16(IDS_SHORT_PRODUCT_NAME)));\n   localized_strings.SetString(\"appoptions\",\n       l10n_util::GetStringUTF16(IDS_NEW_TAB_APP_OPTIONS));\n   localized_strings.SetString(\"appdisablenotifications\",\n      l10n_util::GetStringUTF16(IDS_NEW_TAB_APP_DISABLE_NOTIFICATIONS));\n  localized_strings.SetString(\"appcreateshortcut\",\n      l10n_util::GetStringUTF16(IDS_NEW_TAB_APP_CREATE_SHORTCUT));\n  localized_strings.SetString(\"appDefaultPageName\",\n      l10n_util::GetStringUTF16(IDS_APP_DEFAULT_PAGE_NAME));\n  localized_strings.SetString(\"applaunchtypepinned\",\n      l10n_util::GetStringUTF16(IDS_APP_CONTEXT_MENU_OPEN_PINNED));\n  localized_strings.SetString(\"applaunchtyperegular\",\n      l10n_util::GetStringUTF16(IDS_APP_CONTEXT_MENU_OPEN_REGULAR));\n  localized_strings.SetString(\"applaunchtypewindow\",\n      l10n_util::GetStringUTF16(IDS_APP_CONTEXT_MENU_OPEN_WINDOW));\n  localized_strings.SetString(\"applaunchtypefullscreen\",\n      l10n_util::GetStringUTF16(IDS_APP_CONTEXT_MENU_OPEN_FULLSCREEN));\n  localized_strings.SetString(\"syncpromotext\",\n      l10n_util::GetStringUTF16(IDS_SYNC_START_SYNC_BUTTON_LABEL));\n  localized_strings.SetString(\"syncLinkText\",\n      l10n_util::GetStringUTF16(IDS_SYNC_ADVANCED_OPTIONS));\n#if defined(OS_CHROMEOS)\n  localized_strings.SetString(\"expandMenu\",\n      l10n_util::GetStringUTF16(IDS_NEW_TAB_CLOSE_MENU_EXPAND));\n#endif\n\n  NewTabPageHandler::GetLocalizedValues(profile_, &localized_strings);\n  NTPLoginHandler::GetLocalizedValues(profile_, &localized_strings);\n\n  if (profile_->GetProfileSyncService())\n    localized_strings.SetString(\"syncispresent\", \"true\");\n  else\n    localized_strings.SetString(\"syncispresent\", \"false\");\n\n  ChromeURLDataManager::DataSource::SetFontAndTextDirection(&localized_strings);\n\n  std::string anim =\n      ui::Animation::ShouldRenderRichAnimation() ? \"true\" : \"false\";\n  localized_strings.SetString(\"anim\", anim);\n\n  int alignment;\n  ui::ThemeProvider* tp = ThemeServiceFactory::GetForProfile(profile_);\n  tp->GetDisplayProperty(ThemeService::NTP_BACKGROUND_ALIGNMENT, &alignment);\n  localized_strings.SetString(\"themegravity\",\n      (alignment & ThemeService::ALIGN_RIGHT) ? \"right\" : \"\");\n\n  if (profile_->GetPrefs()->FindPreference(prefs::kNTPCustomLogoStart) &&\n      profile_->GetPrefs()->FindPreference(prefs::kNTPCustomLogoEnd)) {\n    localized_strings.SetString(\"customlogo\",\n        InDateRange(profile_->GetPrefs()->GetDouble(prefs::kNTPCustomLogoStart),\n                    profile_->GetPrefs()->GetDouble(prefs::kNTPCustomLogoEnd)) ?\n        \"true\" : \"false\");\n  } else {\n    localized_strings.SetString(\"customlogo\", \"false\");\n  }\n\n  if (PromoResourceService::CanShowNotificationPromo(profile_)) {\n    localized_strings.SetString(\"serverpromo\",\n        profile_->GetPrefs()->GetString(prefs::kNTPPromoLine));\n  }\n\n  std::string full_html;\n  base::StringPiece new_tab_html(ResourceBundle::GetSharedInstance().\n      GetRawDataResource(IDR_NEW_TAB_4_HTML));\n  full_html = jstemplate_builder::GetI18nTemplateHtml(new_tab_html,\n                                                      &localized_strings);\n  new_tab_html_ = base::RefCountedString::TakeString(&full_html);\n}\n",
    "code_after_change": "void NTPResourceCache::CreateNewTabHTML() {\n  DictionaryValue localized_strings;\n  localized_strings.SetString(\"bookmarkbarattached\",\n      profile_->GetPrefs()->GetBoolean(prefs::kShowBookmarkBar) ?\n      \"true\" : \"false\");\n  localized_strings.SetString(\"hasattribution\",\n      ThemeServiceFactory::GetForProfile(profile_)->HasCustomImage(\n          IDR_THEME_NTP_ATTRIBUTION) ?\n      \"true\" : \"false\");\n  localized_strings.SetString(\"title\",\n      l10n_util::GetStringUTF16(IDS_NEW_TAB_TITLE));\n  localized_strings.SetString(\"mostvisited\",\n      l10n_util::GetStringUTF16(IDS_NEW_TAB_MOST_VISITED));\n  localized_strings.SetString(\"restoreThumbnailsShort\",\n      l10n_util::GetStringUTF16(IDS_NEW_TAB_RESTORE_THUMBNAILS_SHORT_LINK));\n  localized_strings.SetString(\"recentlyclosed\",\n      l10n_util::GetStringUTF16(IDS_NEW_TAB_RECENTLY_CLOSED));\n  localized_strings.SetString(\"closedwindowsingle\",\n      l10n_util::GetStringUTF16(IDS_NEW_TAB_RECENTLY_CLOSED_WINDOW_SINGLE));\n  localized_strings.SetString(\"closedwindowmultiple\",\n      l10n_util::GetStringUTF16(IDS_NEW_TAB_RECENTLY_CLOSED_WINDOW_MULTIPLE));\n  localized_strings.SetString(\"attributionintro\",\n      l10n_util::GetStringUTF16(IDS_NEW_TAB_ATTRIBUTION_INTRO));\n  localized_strings.SetString(\"thumbnailremovednotification\",\n      l10n_util::GetStringUTF16(IDS_NEW_TAB_THUMBNAIL_REMOVED_NOTIFICATION));\n  localized_strings.SetString(\"undothumbnailremove\",\n      l10n_util::GetStringUTF16(IDS_NEW_TAB_UNDO_THUMBNAIL_REMOVE));\n   localized_strings.SetString(\"removethumbnailtooltip\",\n       l10n_util::GetStringUTF16(IDS_NEW_TAB_REMOVE_THUMBNAIL_TOOLTIP));\n   localized_strings.SetString(\"appuninstall\",\n      l10n_util::GetStringUTF16(IDS_EXTENSIONS_UNINSTALL));\n   localized_strings.SetString(\"appoptions\",\n       l10n_util::GetStringUTF16(IDS_NEW_TAB_APP_OPTIONS));\n   localized_strings.SetString(\"appdisablenotifications\",\n      l10n_util::GetStringUTF16(IDS_NEW_TAB_APP_DISABLE_NOTIFICATIONS));\n  localized_strings.SetString(\"appcreateshortcut\",\n      l10n_util::GetStringUTF16(IDS_NEW_TAB_APP_CREATE_SHORTCUT));\n  localized_strings.SetString(\"appDefaultPageName\",\n      l10n_util::GetStringUTF16(IDS_APP_DEFAULT_PAGE_NAME));\n  localized_strings.SetString(\"applaunchtypepinned\",\n      l10n_util::GetStringUTF16(IDS_APP_CONTEXT_MENU_OPEN_PINNED));\n  localized_strings.SetString(\"applaunchtyperegular\",\n      l10n_util::GetStringUTF16(IDS_APP_CONTEXT_MENU_OPEN_REGULAR));\n  localized_strings.SetString(\"applaunchtypewindow\",\n      l10n_util::GetStringUTF16(IDS_APP_CONTEXT_MENU_OPEN_WINDOW));\n  localized_strings.SetString(\"applaunchtypefullscreen\",\n      l10n_util::GetStringUTF16(IDS_APP_CONTEXT_MENU_OPEN_FULLSCREEN));\n  localized_strings.SetString(\"syncpromotext\",\n      l10n_util::GetStringUTF16(IDS_SYNC_START_SYNC_BUTTON_LABEL));\n  localized_strings.SetString(\"syncLinkText\",\n      l10n_util::GetStringUTF16(IDS_SYNC_ADVANCED_OPTIONS));\n#if defined(OS_CHROMEOS)\n  localized_strings.SetString(\"expandMenu\",\n      l10n_util::GetStringUTF16(IDS_NEW_TAB_CLOSE_MENU_EXPAND));\n#endif\n\n  NewTabPageHandler::GetLocalizedValues(profile_, &localized_strings);\n  NTPLoginHandler::GetLocalizedValues(profile_, &localized_strings);\n\n  if (profile_->GetProfileSyncService())\n    localized_strings.SetString(\"syncispresent\", \"true\");\n  else\n    localized_strings.SetString(\"syncispresent\", \"false\");\n\n  ChromeURLDataManager::DataSource::SetFontAndTextDirection(&localized_strings);\n\n  std::string anim =\n      ui::Animation::ShouldRenderRichAnimation() ? \"true\" : \"false\";\n  localized_strings.SetString(\"anim\", anim);\n\n  int alignment;\n  ui::ThemeProvider* tp = ThemeServiceFactory::GetForProfile(profile_);\n  tp->GetDisplayProperty(ThemeService::NTP_BACKGROUND_ALIGNMENT, &alignment);\n  localized_strings.SetString(\"themegravity\",\n      (alignment & ThemeService::ALIGN_RIGHT) ? \"right\" : \"\");\n\n  if (profile_->GetPrefs()->FindPreference(prefs::kNTPCustomLogoStart) &&\n      profile_->GetPrefs()->FindPreference(prefs::kNTPCustomLogoEnd)) {\n    localized_strings.SetString(\"customlogo\",\n        InDateRange(profile_->GetPrefs()->GetDouble(prefs::kNTPCustomLogoStart),\n                    profile_->GetPrefs()->GetDouble(prefs::kNTPCustomLogoEnd)) ?\n        \"true\" : \"false\");\n  } else {\n    localized_strings.SetString(\"customlogo\", \"false\");\n  }\n\n  if (PromoResourceService::CanShowNotificationPromo(profile_)) {\n    localized_strings.SetString(\"serverpromo\",\n        profile_->GetPrefs()->GetString(prefs::kNTPPromoLine));\n  }\n\n  std::string full_html;\n  base::StringPiece new_tab_html(ResourceBundle::GetSharedInstance().\n      GetRawDataResource(IDR_NEW_TAB_4_HTML));\n  full_html = jstemplate_builder::GetI18nTemplateHtml(new_tab_html,\n                                                      &localized_strings);\n  new_tab_html_ = base::RefCountedString::TakeString(&full_html);\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 811,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-7953",
    "code_before_change": "Status XvMCGetDRInfo(Display *dpy, XvPortID port,\n\t\t     char **name, char **busID,\n\t\t     int *major, int *minor,\n\t\t     int *patchLevel,\n\t\t     int *isLocal)\n{\n    XExtDisplayInfo *info = xvmc_find_display(dpy);\n    xvmcGetDRInfoReply rep;\n    xvmcGetDRInfoReq  *req;\n    CARD32 magic;\n\n#ifdef HAVE_SHMAT\n    volatile CARD32 *shMem;\n    struct timezone here;\n    struct timeval now;\n    here.tz_minuteswest = 0;\n    here.tz_dsttime = 0;\n#endif\n\n    *name = NULL;\n    *busID = NULL;\n\n    XvMCCheckExtension (dpy, info, BadImplementation);\n\n    LockDisplay (dpy);\n    XvMCGetReq (GetDRInfo, req);\n\n    req->port = port;\n    magic = 0;\n    req->magic = 0;\n#ifdef HAVE_SHMAT\n    req->shmKey = shmget(IPC_PRIVATE, 1024, IPC_CREAT | 0600);\n\n    /*\n     * We fill a shared memory page with a repetitive pattern. If the\n     * X server can read this pattern, we probably have a local connection.\n     * Note that we can trigger the remote X server to read any shared\n     * page on the remote machine, so we shouldn't be able to guess and verify\n     * any complicated data on those pages. Thats the explanation of this\n     * otherwise stupid-looking pattern algorithm.\n     */\n\n    if (req->shmKey >= 0) {\n\tshMem = (CARD32 *) shmat(req->shmKey, NULL, 0);\n\tshmctl( req->shmKey, IPC_RMID, NULL);\n\tif ( shMem ) {\n\n\t    register volatile CARD32 *shMemC = shMem;\n\t    register int i;\n\n\t    gettimeofday( &now, &here);\n\t    magic = now.tv_usec & 0x000FFFFF;\n\t    req->magic = magic;\n\t    i = 1024 / sizeof(CARD32);\n\t    while(i--) {\n\t        *shMemC++ = magic;\n\t        magic = ~magic;\n\t    }\n\t} else {\n\t    req->shmKey = -1;\n\t}\n    }\n#else\n    req->shmKey = 0;\n#endif\n    if (!_XReply (dpy, (xReply *) &rep, 0, xFalse)) {\n        UnlockDisplay (dpy);\n        SyncHandle ();\n#ifdef HAVE_SHMAT\n\tif ( req->shmKey >= 0) {\n\t    shmdt( (const void *) shMem );\n\t}\n#endif\n        return -1;\n    }\n#ifdef HAVE_SHMAT\n    shmdt( (const void *) shMem );\n#endif\n\n    if (rep.length > 0) {\n\tunsigned long realSize = 0;\n\tchar *tmpBuf = NULL;\n\n\tif ((rep.length < (INT_MAX >> 2)) &&\n\t    /* protect against overflow in strncpy below */\n\t    (rep.nameLen + rep.busIDLen > rep.nameLen)) {\n\t    realSize = rep.length << 2;\n\t    if (realSize >= (rep.nameLen + rep.busIDLen)) {\n\t\ttmpBuf = Xmalloc(realSize);\n\t\t*name = Xmalloc(rep.nameLen);\n\t\t*busID = Xmalloc(rep.busIDLen);\n\t    }\n\t}\n\n \tif (*name && *busID && tmpBuf) {\n \t    _XRead(dpy, tmpBuf, realSize);\n \t    strncpy(*name,tmpBuf,rep.nameLen);\n\t    (*name)[rep.nameLen - 1] = '\\0';\n \t    strncpy(*busID,tmpBuf+rep.nameLen,rep.busIDLen);\n\t    (*busID)[rep.busIDLen - 1] = '\\0';\n \t    XFree(tmpBuf);\n \t} else {\n \t    XFree(*name);\n\t    *name = NULL;\n\t    XFree(*busID);\n\t    *busID = NULL;\n\t    XFree(tmpBuf);\n\n\t    _XEatDataWords(dpy, rep.length);\n\t    UnlockDisplay (dpy);\n\t    SyncHandle ();\n\t    return -1;\n\n\t}\n    }\n\n    UnlockDisplay (dpy);\n    SyncHandle ();\n    *major = rep.major;\n    *minor = rep.minor;\n    *patchLevel = rep.patchLevel;\n    *isLocal = (req->shmKey > 0) ? rep.isLocal : 1;\n    return (rep.length > 0) ? Success : BadImplementation;\n}\n",
    "code_after_change": "Status XvMCGetDRInfo(Display *dpy, XvPortID port,\n\t\t     char **name, char **busID,\n\t\t     int *major, int *minor,\n\t\t     int *patchLevel,\n\t\t     int *isLocal)\n{\n    XExtDisplayInfo *info = xvmc_find_display(dpy);\n    xvmcGetDRInfoReply rep;\n    xvmcGetDRInfoReq  *req;\n    CARD32 magic;\n\n#ifdef HAVE_SHMAT\n    volatile CARD32 *shMem;\n    struct timezone here;\n    struct timeval now;\n    here.tz_minuteswest = 0;\n    here.tz_dsttime = 0;\n#endif\n\n    *name = NULL;\n    *busID = NULL;\n\n    XvMCCheckExtension (dpy, info, BadImplementation);\n\n    LockDisplay (dpy);\n    XvMCGetReq (GetDRInfo, req);\n\n    req->port = port;\n    magic = 0;\n    req->magic = 0;\n#ifdef HAVE_SHMAT\n    req->shmKey = shmget(IPC_PRIVATE, 1024, IPC_CREAT | 0600);\n\n    /*\n     * We fill a shared memory page with a repetitive pattern. If the\n     * X server can read this pattern, we probably have a local connection.\n     * Note that we can trigger the remote X server to read any shared\n     * page on the remote machine, so we shouldn't be able to guess and verify\n     * any complicated data on those pages. Thats the explanation of this\n     * otherwise stupid-looking pattern algorithm.\n     */\n\n    if (req->shmKey >= 0) {\n\tshMem = (CARD32 *) shmat(req->shmKey, NULL, 0);\n\tshmctl( req->shmKey, IPC_RMID, NULL);\n\tif ( shMem ) {\n\n\t    register volatile CARD32 *shMemC = shMem;\n\t    register int i;\n\n\t    gettimeofday( &now, &here);\n\t    magic = now.tv_usec & 0x000FFFFF;\n\t    req->magic = magic;\n\t    i = 1024 / sizeof(CARD32);\n\t    while(i--) {\n\t        *shMemC++ = magic;\n\t        magic = ~magic;\n\t    }\n\t} else {\n\t    req->shmKey = -1;\n\t}\n    }\n#else\n    req->shmKey = 0;\n#endif\n    if (!_XReply (dpy, (xReply *) &rep, 0, xFalse)) {\n        UnlockDisplay (dpy);\n        SyncHandle ();\n#ifdef HAVE_SHMAT\n\tif ( req->shmKey >= 0) {\n\t    shmdt( (const void *) shMem );\n\t}\n#endif\n        return -1;\n    }\n#ifdef HAVE_SHMAT\n    shmdt( (const void *) shMem );\n#endif\n\n    if (rep.length > 0) {\n\tunsigned long realSize = 0;\n\tchar *tmpBuf = NULL;\n\n\tif ((rep.length < (INT_MAX >> 2)) &&\n\t    /* protect against overflow in strncpy below */\n\t    (rep.nameLen + rep.busIDLen > rep.nameLen)) {\n\t    realSize = rep.length << 2;\n\t    if (realSize >= (rep.nameLen + rep.busIDLen)) {\n\t\ttmpBuf = Xmalloc(realSize);\n\t\t*name = Xmalloc(rep.nameLen);\n\t\t*busID = Xmalloc(rep.busIDLen);\n\t    }\n\t}\n\n \tif (*name && *busID && tmpBuf) {\n \t    _XRead(dpy, tmpBuf, realSize);\n \t    strncpy(*name,tmpBuf,rep.nameLen);\n\t    (*name)[rep.nameLen == 0 ? 0 : rep.nameLen - 1] = '\\0';\n \t    strncpy(*busID,tmpBuf+rep.nameLen,rep.busIDLen);\n\t    (*busID)[rep.busIDLen == 0 ? 0 : rep.busIDLen - 1] = '\\0';\n \t    XFree(tmpBuf);\n \t} else {\n \t    XFree(*name);\n\t    *name = NULL;\n\t    XFree(*busID);\n\t    *busID = NULL;\n\t    XFree(tmpBuf);\n\n\t    _XEatDataWords(dpy, rep.length);\n\t    UnlockDisplay (dpy);\n\t    SyncHandle ();\n\t    return -1;\n\n\t}\n    }\n\n    UnlockDisplay (dpy);\n    SyncHandle ();\n    *major = rep.major;\n    *minor = rep.minor;\n    *patchLevel = rep.patchLevel;\n    *isLocal = (req->shmKey > 0) ? rep.isLocal : 1;\n    return (rep.length > 0) ? Success : BadImplementation;\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 812,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-0816",
    "code_before_change": "WORD32 ih264d_mark_err_slice_skip(dec_struct_t * ps_dec,\n                                WORD32 num_mb_skip,\n                                UWORD8 u1_is_idr_slice,\n                                UWORD16 u2_frame_num,\n pocstruct_t *ps_cur_poc,\n                                WORD32 prev_slice_err)\n{\n    WORD32 i2_cur_mb_addr;\n    UWORD32 u1_num_mbs, u1_num_mbsNby2;\n    UWORD32 u1_mb_idx = ps_dec->u1_mb_idx;\n    UWORD32 i2_mb_skip_run;\n\n    UWORD32 u1_num_mbs_next, u1_end_of_row;\n const UWORD32 i2_pic_wdin_mbs = ps_dec->u2_frm_wd_in_mbs;\n    UWORD32 u1_slice_end;\n    UWORD32 u1_tfr_n_mb;\n    UWORD32 u1_decode_nmb;\n dec_bit_stream_t * const ps_bitstrm = ps_dec->ps_bitstrm;\n dec_slice_params_t * ps_slice = ps_dec->ps_cur_slice;\n    UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;\n    UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;\n deblk_mb_t *ps_cur_deblk_mb;\n dec_mb_info_t *ps_cur_mb_info;\n parse_pmbarams_t *ps_parse_mb_data;\n    UWORD32 u1_inter_mb_type;\n    UWORD32 u1_deblk_mb_type;\n    UWORD16 u2_total_mbs_coded;\n    UWORD32 u1_mbaff = ps_slice->u1_mbaff_frame_flag;\n parse_part_params_t *ps_part_info;\n    WORD32 ret;\n\n\n if(ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC)\n {\n        ih264d_err_pic_dispbuf_mgr(ps_dec);\n return 0;\n }\n\n if(prev_slice_err == 1)\n {\n /* first slice - missing/header corruption */\n        ps_dec->ps_cur_slice->u2_frame_num = u2_frame_num;\n\n\n if(!ps_dec->u1_first_slice_in_stream)\n {\n            ih264d_end_of_pic(ps_dec, u1_is_idr_slice,\n                ps_dec->ps_cur_slice->u2_frame_num);\n            ps_dec->s_cur_pic_poc.u2_frame_num =\n                ps_dec->ps_cur_slice->u2_frame_num;\n }\n\n {\n            WORD32 i, j, poc = 0;\n\n            ps_dec->ps_cur_slice->u2_first_mb_in_slice = 0;\n\n            ps_dec->pf_mvpred = ih264d_mvpred_nonmbaff;\n            ps_dec->p_form_mb_part_info = ih264d_form_mb_part_info_bp;\n            ps_dec->p_motion_compensate = ih264d_motion_compensate_bp;\n\n if(ps_dec->ps_cur_pic != NULL)\n                poc = ps_dec->ps_cur_pic->i4_poc + 2;\n\n            j = 0;\n for(i = 0; i < MAX_NUM_PIC_PARAMS; i++)\n if(ps_dec->ps_pps[i].u1_is_valid == TRUE)\n                       j = i;\n {\n                ret = ih264d_start_of_pic(ps_dec, poc, ps_cur_poc,\n                        ps_dec->ps_cur_slice->u2_frame_num,\n &ps_dec->ps_pps[j]);\n\n if(ret != OK)\n {\n return ret;\n }\n }\n\n            ps_dec->ps_ref_pic_buf_lx[0][0]->u1_pic_buf_id = 0;\n\n            ps_dec->u4_output_present = 0;\n\n {\n                ih264d_get_next_display_field(ps_dec,\n                                              ps_dec->ps_out_buffer,\n &(ps_dec->s_disp_op));\n /* If error code is non-zero then there is no buffer available for display,\n                 hence avoid format conversion */\n\n if(0 != ps_dec->s_disp_op.u4_error_code)\n {\n                    ps_dec->u4_fmt_conv_cur_row = ps_dec->s_disp_frame_info.u4_y_ht;\n }\n else\n                    ps_dec->u4_output_present = 1;\n }\n\n if(ps_dec->u1_separate_parse == 1)\n {\n if(ps_dec->u4_dec_thread_created == 0)\n {\n                    ithread_create(ps_dec->pv_dec_thread_handle, NULL,\n (void *)ih264d_decode_picture_thread,\n (void *)ps_dec);\n\n                    ps_dec->u4_dec_thread_created = 1;\n }\n\n if((ps_dec->u4_num_cores == 3) &&\n ((ps_dec->u4_app_disable_deblk_frm == 0) || ps_dec->i1_recon_in_thread3_flag)\n && (ps_dec->u4_bs_deblk_thread_created == 0))\n {\n                    ps_dec->u4_start_recon_deblk = 0;\n                    ithread_create(ps_dec->pv_bs_deblk_thread_handle, NULL,\n (void *)ih264d_recon_deblk_thread,\n (void *)ps_dec);\n                    ps_dec->u4_bs_deblk_thread_created = 1;\n }\n }\n }\n }\n else\n {\n\n dec_slice_struct_t *ps_parse_cur_slice;\n        ps_parse_cur_slice = ps_dec->ps_dec_slice_buf + ps_dec->u2_cur_slice_num;\n\n if(ps_dec->u1_slice_header_done\n && ps_parse_cur_slice == ps_dec->ps_parse_cur_slice)\n {\n            u1_num_mbs = ps_dec->u4_num_mbs_cur_nmb;\n\n if(u1_num_mbs)\n {\n                ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs - 1;\n }\n else\n {\n if(ps_dec->u1_separate_parse)\n {\n                    ps_cur_mb_info = ps_dec->ps_nmb_info - 1;\n }\n else\n {\n                    ps_cur_mb_info = ps_dec->ps_nmb_info\n + ps_dec->u4_num_mbs_prev_nmb - 1;\n }\n }\n\n            ps_dec->u2_mby = ps_cur_mb_info->u2_mby;\n            ps_dec->u2_mbx = ps_cur_mb_info->u2_mbx;\n\n            ps_dec->u1_mb_ngbr_availablity =\n                    ps_cur_mb_info->u1_mb_ngbr_availablity;\n\n            ps_dec->pv_parse_tu_coeff_data = ps_dec->pv_prev_mb_parse_tu_coeff_data;\n            ps_dec->u2_cur_mb_addr--;\n            ps_dec->i4_submb_ofst -= SUB_BLK_SIZE;\n\n if(u1_num_mbs)\n {\n if (ps_dec->u1_pr_sl_type == P_SLICE\n || ps_dec->u1_pr_sl_type == B_SLICE)\n {\n                    ps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx,    u1_num_mbs);\n                    ps_dec->ps_part = ps_dec->ps_parse_part_params;\n }\n\n                u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;\n                u1_end_of_row = (!u1_num_mbs_next)\n && (!(u1_mbaff && (u1_num_mbs & 0x01)));\n                u1_slice_end = 1;\n                u1_tfr_n_mb = 1;\n                ps_cur_mb_info->u1_end_of_slice = u1_slice_end;\n\n if(ps_dec->u1_separate_parse)\n {\n                    ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\n                            u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);\n                    ps_dec->ps_nmb_info += u1_num_mbs;\n }\n else\n {\n\n                     ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\n                             u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);\n                 }\n                 ps_dec->u1_mb_idx = 0;\n                 ps_dec->u4_num_mbs_cur_nmb = 0;\n             }\n\n if(ps_dec->u2_total_mbs_coded\n >= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n {\n                ps_dec->u1_pic_decode_done = 1;\n return 0;\n }\n\n            ps_dec->u2_cur_slice_num++;\n             ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;\n            ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;\n            ps_dec->ps_parse_cur_slice++;\n\n }\n else\n {\n            ps_dec->ps_parse_cur_slice = ps_dec->ps_dec_slice_buf\n + ps_dec->u2_cur_slice_num;\n }\n }\n\n /******************************************************/\n /* Initializations to new slice                       */\n /******************************************************/\n {\n        WORD32 num_entries;\n        WORD32 size;\n        UWORD8 *pu1_buf;\n\n        num_entries = MIN(MAX_FRAMES, ps_dec->u4_num_ref_frames_at_init);\n        num_entries = 2 * ((2 * num_entries) + 1);\n\n        size = num_entries * sizeof(void *);\n        size += PAD_MAP_IDX_POC * sizeof(void *);\n\n        pu1_buf = (UWORD8 *)ps_dec->pv_map_ref_idx_to_poc_buf;\n        pu1_buf += size * ps_dec->u2_cur_slice_num;\n        ps_dec->ps_parse_cur_slice->ppv_map_ref_idx_to_poc = (volatile void **)pu1_buf;\n }\n\n    ps_dec->ps_cur_slice->u2_first_mb_in_slice = ps_dec->u2_total_mbs_coded << u1_mbaff;\n if(ps_dec->ps_cur_slice->u1_field_pic_flag)\n        ps_dec->u2_prv_frame_num = ps_dec->ps_cur_slice->u2_frame_num;\n\n    ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice = ps_dec->u2_total_mbs_coded << u1_mbaff;\n    ps_dec->ps_parse_cur_slice->u2_log2Y_crwd =    ps_dec->ps_cur_slice->u2_log2Y_crwd;\n\n\n if(ps_dec->u1_separate_parse)\n {\n        ps_dec->ps_parse_cur_slice->pv_tu_coeff_data_start = ps_dec->pv_parse_tu_coeff_data;\n }\n else\n {\n        ps_dec->pv_proc_tu_coeff_data = ps_dec->pv_parse_tu_coeff_data;\n }\n\n /******************************************************/\n /* Initializations specific to P slice                */\n /******************************************************/\n    u1_inter_mb_type = P_MB;\n    u1_deblk_mb_type = D_INTER_MB;\n\n    ps_dec->ps_cur_slice->u1_slice_type = P_SLICE;\n    ps_dec->ps_parse_cur_slice->slice_type = P_SLICE;\n    ps_dec->pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_pmb;\n    ps_dec->ps_part = ps_dec->ps_parse_part_params;\n\n /******************************************************/\n /* Parsing / decoding the slice                       */\n /******************************************************/\n    ps_dec->u1_slice_header_done = 2;\n    ps_dec->u1_qp = ps_slice->u1_slice_qp;\n    ih264d_update_qp(ps_dec, 0);\n    u1_mb_idx = ps_dec->u1_mb_idx;\n    ps_parse_mb_data = ps_dec->ps_parse_mb_data;\n    u1_num_mbs = u1_mb_idx;\n\n    u1_slice_end = 0;\n    u1_tfr_n_mb = 0;\n    u1_decode_nmb = 0;\n    u1_num_mbsNby2 = 0;\n    i2_cur_mb_addr = ps_dec->u2_total_mbs_coded;\n    i2_mb_skip_run = num_mb_skip;\n\n while(!u1_slice_end)\n {\n        UWORD8 u1_mb_type;\n\n if(i2_cur_mb_addr > ps_dec->ps_cur_sps->u2_max_mb_addr)\n break;\n\n        ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs;\n        ps_dec->u4_num_mbs_cur_nmb = u1_num_mbs;\n\n        ps_cur_mb_info->u1_Mux = 0;\n        ps_dec->u4_num_pmbair = (u1_num_mbs >> u1_mbaff);\n        ps_cur_deblk_mb = ps_dec->ps_deblk_mbn + u1_num_mbs;\n\n        ps_cur_mb_info->u1_end_of_slice = 0;\n\n /* Storing Default partition info */\n        ps_parse_mb_data->u1_num_part = 1;\n        ps_parse_mb_data->u1_isI_mb = 0;\n\n /**************************************************************/\n /* Get the required information for decoding of MB            */\n /**************************************************************/\n /* mb_x, mb_y, neighbor availablity, */\n if (u1_mbaff)\n            ih264d_get_mb_info_cavlc_mbaff(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, i2_mb_skip_run);\n else\n            ih264d_get_mb_info_cavlc_nonmbaff(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, i2_mb_skip_run);\n\n /* Set the deblocking parameters for this MB */\n if(ps_dec->u4_app_disable_deblk_frm == 0)\n {\n            ih264d_set_deblocking_parameters(ps_cur_deblk_mb, ps_slice,\n                                             ps_dec->u1_mb_ngbr_availablity,\n                                             ps_dec->u1_cur_mb_fld_dec_flag);\n }\n\n /* Set appropriate flags in ps_cur_mb_info and ps_dec */\n        ps_dec->i1_prev_mb_qp_delta = 0;\n        ps_dec->u1_sub_mb_num = 0;\n        ps_cur_mb_info->u1_mb_type = MB_SKIP;\n        ps_cur_mb_info->u1_mb_mc_mode = PRED_16x16;\n        ps_cur_mb_info->u1_cbp = 0;\n\n /* Storing Skip partition info */\n        ps_part_info = ps_dec->ps_part;\n        ps_part_info->u1_is_direct = PART_DIRECT_16x16;\n        ps_part_info->u1_sub_mb_num = 0;\n        ps_dec->ps_part++;\n\n /* Update Nnzs */\n        ih264d_update_nnz_for_skipmb(ps_dec, ps_cur_mb_info, CAVLC);\n\n        ps_cur_mb_info->ps_curmb->u1_mb_type = u1_inter_mb_type;\n        ps_cur_deblk_mb->u1_mb_type |= u1_deblk_mb_type;\n\n        i2_mb_skip_run--;\n\n        ps_cur_deblk_mb->u1_mb_qp = ps_dec->u1_qp;\n\n if (u1_mbaff)\n {\n            ih264d_update_mbaff_left_nnz(ps_dec, ps_cur_mb_info);\n }\n\n /**************************************************************/\n /* Get next Macroblock address                                */\n /**************************************************************/\n\n         i2_cur_mb_addr++;\n \n         u1_num_mbs++;\n        ps_dec->u2_total_mbs_coded++;\n         u1_num_mbsNby2++;\n         ps_parse_mb_data++;\n \n /****************************************************************/\n /* Check for End Of Row and other flags that determine when to  */\n /* do DMA setup for N/2-Mb, Decode for N-Mb, and Transfer for   */\n /* N-Mb                                                         */\n /****************************************************************/\n        u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;\n        u1_end_of_row = (!u1_num_mbs_next) && (!(u1_mbaff && (u1_num_mbs & 0x01)));\n        u1_slice_end = !i2_mb_skip_run;\n        u1_tfr_n_mb = (u1_num_mbs == ps_dec->u1_recon_mb_grp) || u1_end_of_row\n || u1_slice_end;\n        u1_decode_nmb = u1_tfr_n_mb || u1_slice_end;\n        ps_cur_mb_info->u1_end_of_slice = u1_slice_end;\n\n if(u1_decode_nmb)\n {\n            ps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx, u1_num_mbs);\n            u1_num_mbsNby2 = 0;\n\n            ps_parse_mb_data = ps_dec->ps_parse_mb_data;\n            ps_dec->ps_part = ps_dec->ps_parse_part_params;\n\n if(ps_dec->u1_separate_parse)\n {\n                ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\n                                     u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);\n                ps_dec->ps_nmb_info +=  u1_num_mbs;\n }\n else\n {\n\n                 ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs, u1_num_mbs_next,\n                                             u1_tfr_n_mb, u1_end_of_row);\n             }\n             if(u1_tfr_n_mb)\n                 u1_num_mbs = 0;\n             u1_mb_idx = u1_num_mbs;\n            ps_dec->u1_mb_idx = u1_num_mbs;\n }\n }\n\n    ps_dec->u4_num_mbs_cur_nmb = 0;\n    ps_dec->ps_cur_slice->u4_mbs_in_slice = i2_cur_mb_addr\n - ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice;\n\n    H264_DEC_DEBUG_PRINT(\"Mbs in slice: %d\\n\", ps_dec->ps_cur_slice->u4_mbs_in_slice);\n\n    ps_dec->u2_cur_slice_num++;\n\n /* incremented here only if first slice is inserted */\n if(ps_dec->u4_first_slice_in_pic != 0)\n        ps_dec->ps_parse_cur_slice++;\n\n    ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;\n    ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;\n\n if(ps_dec->u2_total_mbs_coded\n >= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n {\n        ps_dec->u1_pic_decode_done = 1;\n }\n\n return 0;\n\n}\n",
    "code_after_change": "WORD32 ih264d_mark_err_slice_skip(dec_struct_t * ps_dec,\n                                WORD32 num_mb_skip,\n                                UWORD8 u1_is_idr_slice,\n                                UWORD16 u2_frame_num,\n pocstruct_t *ps_cur_poc,\n                                WORD32 prev_slice_err)\n{\n    WORD32 i2_cur_mb_addr;\n    UWORD32 u1_num_mbs, u1_num_mbsNby2;\n    UWORD32 u1_mb_idx = ps_dec->u1_mb_idx;\n    UWORD32 i2_mb_skip_run;\n\n    UWORD32 u1_num_mbs_next, u1_end_of_row;\n const UWORD32 i2_pic_wdin_mbs = ps_dec->u2_frm_wd_in_mbs;\n    UWORD32 u1_slice_end;\n    UWORD32 u1_tfr_n_mb;\n    UWORD32 u1_decode_nmb;\n dec_bit_stream_t * const ps_bitstrm = ps_dec->ps_bitstrm;\n dec_slice_params_t * ps_slice = ps_dec->ps_cur_slice;\n    UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;\n    UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;\n deblk_mb_t *ps_cur_deblk_mb;\n dec_mb_info_t *ps_cur_mb_info;\n parse_pmbarams_t *ps_parse_mb_data;\n    UWORD32 u1_inter_mb_type;\n    UWORD32 u1_deblk_mb_type;\n    UWORD16 u2_total_mbs_coded;\n    UWORD32 u1_mbaff = ps_slice->u1_mbaff_frame_flag;\n parse_part_params_t *ps_part_info;\n    WORD32 ret;\n\n\n if(ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC)\n {\n        ih264d_err_pic_dispbuf_mgr(ps_dec);\n return 0;\n }\n\n if(prev_slice_err == 1)\n {\n /* first slice - missing/header corruption */\n        ps_dec->ps_cur_slice->u2_frame_num = u2_frame_num;\n\n\n if(!ps_dec->u1_first_slice_in_stream)\n {\n            ih264d_end_of_pic(ps_dec, u1_is_idr_slice,\n                ps_dec->ps_cur_slice->u2_frame_num);\n            ps_dec->s_cur_pic_poc.u2_frame_num =\n                ps_dec->ps_cur_slice->u2_frame_num;\n }\n\n {\n            WORD32 i, j, poc = 0;\n\n            ps_dec->ps_cur_slice->u2_first_mb_in_slice = 0;\n\n            ps_dec->pf_mvpred = ih264d_mvpred_nonmbaff;\n            ps_dec->p_form_mb_part_info = ih264d_form_mb_part_info_bp;\n            ps_dec->p_motion_compensate = ih264d_motion_compensate_bp;\n\n if(ps_dec->ps_cur_pic != NULL)\n                poc = ps_dec->ps_cur_pic->i4_poc + 2;\n\n            j = 0;\n for(i = 0; i < MAX_NUM_PIC_PARAMS; i++)\n if(ps_dec->ps_pps[i].u1_is_valid == TRUE)\n                       j = i;\n {\n                ret = ih264d_start_of_pic(ps_dec, poc, ps_cur_poc,\n                        ps_dec->ps_cur_slice->u2_frame_num,\n &ps_dec->ps_pps[j]);\n\n if(ret != OK)\n {\n return ret;\n }\n }\n\n            ps_dec->ps_ref_pic_buf_lx[0][0]->u1_pic_buf_id = 0;\n\n            ps_dec->u4_output_present = 0;\n\n {\n                ih264d_get_next_display_field(ps_dec,\n                                              ps_dec->ps_out_buffer,\n &(ps_dec->s_disp_op));\n /* If error code is non-zero then there is no buffer available for display,\n                 hence avoid format conversion */\n\n if(0 != ps_dec->s_disp_op.u4_error_code)\n {\n                    ps_dec->u4_fmt_conv_cur_row = ps_dec->s_disp_frame_info.u4_y_ht;\n }\n else\n                    ps_dec->u4_output_present = 1;\n }\n\n if(ps_dec->u1_separate_parse == 1)\n {\n if(ps_dec->u4_dec_thread_created == 0)\n {\n                    ithread_create(ps_dec->pv_dec_thread_handle, NULL,\n (void *)ih264d_decode_picture_thread,\n (void *)ps_dec);\n\n                    ps_dec->u4_dec_thread_created = 1;\n }\n\n if((ps_dec->u4_num_cores == 3) &&\n ((ps_dec->u4_app_disable_deblk_frm == 0) || ps_dec->i1_recon_in_thread3_flag)\n && (ps_dec->u4_bs_deblk_thread_created == 0))\n {\n                    ps_dec->u4_start_recon_deblk = 0;\n                    ithread_create(ps_dec->pv_bs_deblk_thread_handle, NULL,\n (void *)ih264d_recon_deblk_thread,\n (void *)ps_dec);\n                    ps_dec->u4_bs_deblk_thread_created = 1;\n }\n }\n }\n }\n else\n {\n\n dec_slice_struct_t *ps_parse_cur_slice;\n        ps_parse_cur_slice = ps_dec->ps_dec_slice_buf + ps_dec->u2_cur_slice_num;\n\n if(ps_dec->u1_slice_header_done\n && ps_parse_cur_slice == ps_dec->ps_parse_cur_slice)\n {\n            u1_num_mbs = ps_dec->u4_num_mbs_cur_nmb;\n\n if(u1_num_mbs)\n {\n                ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs - 1;\n }\n else\n {\n if(ps_dec->u1_separate_parse)\n {\n                    ps_cur_mb_info = ps_dec->ps_nmb_info - 1;\n }\n else\n {\n                    ps_cur_mb_info = ps_dec->ps_nmb_info\n + ps_dec->u4_num_mbs_prev_nmb - 1;\n }\n }\n\n            ps_dec->u2_mby = ps_cur_mb_info->u2_mby;\n            ps_dec->u2_mbx = ps_cur_mb_info->u2_mbx;\n\n            ps_dec->u1_mb_ngbr_availablity =\n                    ps_cur_mb_info->u1_mb_ngbr_availablity;\n\n            ps_dec->pv_parse_tu_coeff_data = ps_dec->pv_prev_mb_parse_tu_coeff_data;\n            ps_dec->u2_cur_mb_addr--;\n            ps_dec->i4_submb_ofst -= SUB_BLK_SIZE;\n\n if(u1_num_mbs)\n {\n if (ps_dec->u1_pr_sl_type == P_SLICE\n || ps_dec->u1_pr_sl_type == B_SLICE)\n {\n                    ps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx,    u1_num_mbs);\n                    ps_dec->ps_part = ps_dec->ps_parse_part_params;\n }\n\n                u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;\n                u1_end_of_row = (!u1_num_mbs_next)\n && (!(u1_mbaff && (u1_num_mbs & 0x01)));\n                u1_slice_end = 1;\n                u1_tfr_n_mb = 1;\n                ps_cur_mb_info->u1_end_of_slice = u1_slice_end;\n\n if(ps_dec->u1_separate_parse)\n {\n                    ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\n                            u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);\n                    ps_dec->ps_nmb_info += u1_num_mbs;\n }\n else\n {\n\n                     ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\n                             u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);\n                 }\n                ps_dec->u2_total_mbs_coded += u1_num_mbs;\n                 ps_dec->u1_mb_idx = 0;\n                 ps_dec->u4_num_mbs_cur_nmb = 0;\n             }\n\n if(ps_dec->u2_total_mbs_coded\n >= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n {\n                ps_dec->u1_pic_decode_done = 1;\n return 0;\n }\n\n            ps_dec->u2_cur_slice_num++;\n             ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;\n            ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;\n            ps_dec->ps_parse_cur_slice++;\n\n }\n else\n {\n            ps_dec->ps_parse_cur_slice = ps_dec->ps_dec_slice_buf\n + ps_dec->u2_cur_slice_num;\n }\n }\n\n /******************************************************/\n /* Initializations to new slice                       */\n /******************************************************/\n {\n        WORD32 num_entries;\n        WORD32 size;\n        UWORD8 *pu1_buf;\n\n        num_entries = MIN(MAX_FRAMES, ps_dec->u4_num_ref_frames_at_init);\n        num_entries = 2 * ((2 * num_entries) + 1);\n\n        size = num_entries * sizeof(void *);\n        size += PAD_MAP_IDX_POC * sizeof(void *);\n\n        pu1_buf = (UWORD8 *)ps_dec->pv_map_ref_idx_to_poc_buf;\n        pu1_buf += size * ps_dec->u2_cur_slice_num;\n        ps_dec->ps_parse_cur_slice->ppv_map_ref_idx_to_poc = (volatile void **)pu1_buf;\n }\n\n    ps_dec->ps_cur_slice->u2_first_mb_in_slice = ps_dec->u2_total_mbs_coded << u1_mbaff;\n if(ps_dec->ps_cur_slice->u1_field_pic_flag)\n        ps_dec->u2_prv_frame_num = ps_dec->ps_cur_slice->u2_frame_num;\n\n    ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice = ps_dec->u2_total_mbs_coded << u1_mbaff;\n    ps_dec->ps_parse_cur_slice->u2_log2Y_crwd =    ps_dec->ps_cur_slice->u2_log2Y_crwd;\n\n\n if(ps_dec->u1_separate_parse)\n {\n        ps_dec->ps_parse_cur_slice->pv_tu_coeff_data_start = ps_dec->pv_parse_tu_coeff_data;\n }\n else\n {\n        ps_dec->pv_proc_tu_coeff_data = ps_dec->pv_parse_tu_coeff_data;\n }\n\n /******************************************************/\n /* Initializations specific to P slice                */\n /******************************************************/\n    u1_inter_mb_type = P_MB;\n    u1_deblk_mb_type = D_INTER_MB;\n\n    ps_dec->ps_cur_slice->u1_slice_type = P_SLICE;\n    ps_dec->ps_parse_cur_slice->slice_type = P_SLICE;\n    ps_dec->pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_pmb;\n    ps_dec->ps_part = ps_dec->ps_parse_part_params;\n\n /******************************************************/\n /* Parsing / decoding the slice                       */\n /******************************************************/\n    ps_dec->u1_slice_header_done = 2;\n    ps_dec->u1_qp = ps_slice->u1_slice_qp;\n    ih264d_update_qp(ps_dec, 0);\n    u1_mb_idx = ps_dec->u1_mb_idx;\n    ps_parse_mb_data = ps_dec->ps_parse_mb_data;\n    u1_num_mbs = u1_mb_idx;\n\n    u1_slice_end = 0;\n    u1_tfr_n_mb = 0;\n    u1_decode_nmb = 0;\n    u1_num_mbsNby2 = 0;\n    i2_cur_mb_addr = ps_dec->u2_total_mbs_coded;\n    i2_mb_skip_run = num_mb_skip;\n\n while(!u1_slice_end)\n {\n        UWORD8 u1_mb_type;\n\n if(i2_cur_mb_addr > ps_dec->ps_cur_sps->u2_max_mb_addr)\n break;\n\n        ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs;\n        ps_dec->u4_num_mbs_cur_nmb = u1_num_mbs;\n\n        ps_cur_mb_info->u1_Mux = 0;\n        ps_dec->u4_num_pmbair = (u1_num_mbs >> u1_mbaff);\n        ps_cur_deblk_mb = ps_dec->ps_deblk_mbn + u1_num_mbs;\n\n        ps_cur_mb_info->u1_end_of_slice = 0;\n\n /* Storing Default partition info */\n        ps_parse_mb_data->u1_num_part = 1;\n        ps_parse_mb_data->u1_isI_mb = 0;\n\n /**************************************************************/\n /* Get the required information for decoding of MB            */\n /**************************************************************/\n /* mb_x, mb_y, neighbor availablity, */\n if (u1_mbaff)\n            ih264d_get_mb_info_cavlc_mbaff(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, i2_mb_skip_run);\n else\n            ih264d_get_mb_info_cavlc_nonmbaff(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, i2_mb_skip_run);\n\n /* Set the deblocking parameters for this MB */\n if(ps_dec->u4_app_disable_deblk_frm == 0)\n {\n            ih264d_set_deblocking_parameters(ps_cur_deblk_mb, ps_slice,\n                                             ps_dec->u1_mb_ngbr_availablity,\n                                             ps_dec->u1_cur_mb_fld_dec_flag);\n }\n\n /* Set appropriate flags in ps_cur_mb_info and ps_dec */\n        ps_dec->i1_prev_mb_qp_delta = 0;\n        ps_dec->u1_sub_mb_num = 0;\n        ps_cur_mb_info->u1_mb_type = MB_SKIP;\n        ps_cur_mb_info->u1_mb_mc_mode = PRED_16x16;\n        ps_cur_mb_info->u1_cbp = 0;\n\n /* Storing Skip partition info */\n        ps_part_info = ps_dec->ps_part;\n        ps_part_info->u1_is_direct = PART_DIRECT_16x16;\n        ps_part_info->u1_sub_mb_num = 0;\n        ps_dec->ps_part++;\n\n /* Update Nnzs */\n        ih264d_update_nnz_for_skipmb(ps_dec, ps_cur_mb_info, CAVLC);\n\n        ps_cur_mb_info->ps_curmb->u1_mb_type = u1_inter_mb_type;\n        ps_cur_deblk_mb->u1_mb_type |= u1_deblk_mb_type;\n\n        i2_mb_skip_run--;\n\n        ps_cur_deblk_mb->u1_mb_qp = ps_dec->u1_qp;\n\n if (u1_mbaff)\n {\n            ih264d_update_mbaff_left_nnz(ps_dec, ps_cur_mb_info);\n }\n\n /**************************************************************/\n /* Get next Macroblock address                                */\n /**************************************************************/\n\n         i2_cur_mb_addr++;\n \n         u1_num_mbs++;\n         u1_num_mbsNby2++;\n         ps_parse_mb_data++;\n \n /****************************************************************/\n /* Check for End Of Row and other flags that determine when to  */\n /* do DMA setup for N/2-Mb, Decode for N-Mb, and Transfer for   */\n /* N-Mb                                                         */\n /****************************************************************/\n        u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;\n        u1_end_of_row = (!u1_num_mbs_next) && (!(u1_mbaff && (u1_num_mbs & 0x01)));\n        u1_slice_end = !i2_mb_skip_run;\n        u1_tfr_n_mb = (u1_num_mbs == ps_dec->u1_recon_mb_grp) || u1_end_of_row\n || u1_slice_end;\n        u1_decode_nmb = u1_tfr_n_mb || u1_slice_end;\n        ps_cur_mb_info->u1_end_of_slice = u1_slice_end;\n\n if(u1_decode_nmb)\n {\n            ps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx, u1_num_mbs);\n            u1_num_mbsNby2 = 0;\n\n            ps_parse_mb_data = ps_dec->ps_parse_mb_data;\n            ps_dec->ps_part = ps_dec->ps_parse_part_params;\n\n if(ps_dec->u1_separate_parse)\n {\n                ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\n                                     u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);\n                ps_dec->ps_nmb_info +=  u1_num_mbs;\n }\n else\n {\n\n                 ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs, u1_num_mbs_next,\n                                             u1_tfr_n_mb, u1_end_of_row);\n             }\n            ps_dec->u2_total_mbs_coded += u1_num_mbs;\n             if(u1_tfr_n_mb)\n                 u1_num_mbs = 0;\n             u1_mb_idx = u1_num_mbs;\n            ps_dec->u1_mb_idx = u1_num_mbs;\n }\n }\n\n    ps_dec->u4_num_mbs_cur_nmb = 0;\n    ps_dec->ps_cur_slice->u4_mbs_in_slice = i2_cur_mb_addr\n - ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice;\n\n    H264_DEC_DEBUG_PRINT(\"Mbs in slice: %d\\n\", ps_dec->ps_cur_slice->u4_mbs_in_slice);\n\n    ps_dec->u2_cur_slice_num++;\n\n /* incremented here only if first slice is inserted */\n if(ps_dec->u4_first_slice_in_pic != 0)\n        ps_dec->ps_parse_cur_slice++;\n\n    ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;\n    ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;\n\n if(ps_dec->u2_total_mbs_coded\n >= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n {\n        ps_dec->u1_pic_decode_done = 1;\n }\n\n return 0;\n\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 813,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2017-6542",
    "code_before_change": "static void ssh_throttle_all(Ssh ssh, int enable, int bufsize)\n{\n    int i;\n    struct ssh_channel *c;\n\n    if (enable == ssh->throttled_all)\n\treturn;\n    ssh->throttled_all = enable;\n    ssh->overall_bufsize = bufsize;\n    if (!ssh->channels)\n\treturn;\n    for (i = 0; NULL != (c = index234(ssh->channels, i)); i++) {\n\tswitch (c->type) {\n\t  case CHAN_MAINSESSION:\n\t    /*\n\t     * This is treated separately, outside the switch.\n\t     */\n\t    break;\n            x11_override_throttle(c->u.x11.xconn, enable);\n            break;\n          case CHAN_AGENT:\n           /* Agent channels require no buffer management. */\n            break;\n          case CHAN_SOCKDATA:\n            pfd_override_throttle(c->u.pfd.pf, enable);\n\nstatic void ssh_agent_callback(void *sshv, void *reply, int replylen)\n{\n    Ssh ssh = (Ssh) sshv;\n\n    ssh->auth_agent_query = NULL;\n\n    ssh->agent_response = reply;\n    ssh->agent_response_len = replylen;\n\n    if (ssh->version == 1)\n\tdo_ssh1_login(ssh, NULL, -1, NULL);\n    else\n\tdo_ssh2_authconn(ssh, NULL, -1, NULL);\n}\n\nstatic void ssh_dialog_callback(void *sshv, int ret)\n{\n    Ssh ssh = (Ssh) sshv;\n\n    ssh->user_response = ret;\n\n    if (ssh->version == 1)\n\tdo_ssh1_login(ssh, NULL, -1, NULL);\n    else\n\tdo_ssh2_transport(ssh, NULL, -1, NULL);\n\n    /*\n     * This may have unfrozen the SSH connection, so do a\n     * queued-data run.\n     */\n    ssh_process_queued_incoming_data(ssh);\n}\n\nstatic void ssh_agentf_callback(void *cv, void *reply, int replylen)\n     ssh_process_queued_incoming_data(ssh);\n }\n \nstatic void ssh_agentf_callback(void *cv, void *reply, int replylen)\n {\n    struct ssh_channel *c = (struct ssh_channel *)cv;\n    const void *sentreply = reply;\n     c->u.a.pending = NULL;\n    c->u.a.outstanding_requests--;\n    if (!sentreply) {\n       /* Fake SSH_AGENT_FAILURE. */\n       sentreply = \"\\0\\0\\0\\1\\5\";\n        replylen = 5;\n     }\n    ssh_send_channel_data(c, sentreply, replylen);\n    if (reply)\n       sfree(reply);\n     /*\n     * If we've already seen an incoming EOF but haven't sent an\n     * outgoing one, this may be the moment to send it.\n      */\n    if (c->u.a.outstanding_requests == 0 && (c->closes & CLOSES_RCVD_EOF))\n         sshfwd_write_eof(c);\n }\n \n /*\n  * Client-initiated disconnection. Send a DISCONNECT if `wire_reason'\n  * non-NULL, otherwise just close the connection. `client_reason' == NULL\n\t\t\t struct Packet *pktin)\n{\n    int i, j, ret;\n    unsigned char cookie[8], *ptr;\n    struct MD5Context md5c;\n    struct do_ssh1_login_state {\n\tint crLine;\n\tint len;\n\tunsigned char *rsabuf;\n        const unsigned char *keystr1, *keystr2;\n\tunsigned long supported_ciphers_mask, supported_auths_mask;\n\tint tried_publickey, tried_agent;\n\tint tis_auth_refused, ccard_auth_refused;\n\tunsigned char session_id[16];\n\tint cipher_type;\n\tvoid *publickey_blob;\n\tint publickey_bloblen;\n\tchar *publickey_comment;\n\tint privatekey_available, privatekey_encrypted;\n\tprompts_t *cur_prompt;\n\tchar c;\n\tint pwpkt_type;\n\tunsigned char request[5], *response, *p;\n\tint responselen;\n\tint keyi, nkeys;\n\tint authed;\n\tstruct RSAKey key;\n\tBignum challenge;\n\tchar *commentp;\n\tint commentlen;\n        int dlgret;\n\tFilename *keyfile;\n        struct RSAKey servkey, hostkey;\n    };\n    crState(do_ssh1_login_state);\n\n    crBeginState;\n\n    if (!pktin)\n\tcrWaitUntil(pktin);\n\n    if (pktin->type != SSH1_SMSG_PUBLIC_KEY) {\n\tbombout((\"Public key packet not received\"));\n\tcrStop(0);\n    }\n\n    logevent(\"Received public keys\");\n\n    ptr = ssh_pkt_getdata(pktin, 8);\n    if (!ptr) {\n\tbombout((\"SSH-1 public key packet stopped before random cookie\"));\n\tcrStop(0);\n    }\n    memcpy(cookie, ptr, 8);\n\n    if (!ssh1_pkt_getrsakey(pktin, &s->servkey, &s->keystr1) ||\n\t!ssh1_pkt_getrsakey(pktin, &s->hostkey, &s->keystr2)) {\t\n\tbombout((\"Failed to read SSH-1 public keys from public key packet\"));\n\tcrStop(0);\n    }\n\n    /*\n     * Log the host key fingerprint.\n     */\n    {\n\tchar logmsg[80];\n\tlogevent(\"Host key fingerprint is:\");\n\tstrcpy(logmsg, \"      \");\n\ts->hostkey.comment = NULL;\n\trsa_fingerprint(logmsg + strlen(logmsg),\n\t\t\tsizeof(logmsg) - strlen(logmsg), &s->hostkey);\n\tlogevent(logmsg);\n    }\n\n    ssh->v1_remote_protoflags = ssh_pkt_getuint32(pktin);\n    s->supported_ciphers_mask = ssh_pkt_getuint32(pktin);\n    s->supported_auths_mask = ssh_pkt_getuint32(pktin);\n    if ((ssh->remote_bugs & BUG_CHOKES_ON_RSA))\n\ts->supported_auths_mask &= ~(1 << SSH1_AUTH_RSA);\n\n    ssh->v1_local_protoflags =\n\tssh->v1_remote_protoflags & SSH1_PROTOFLAGS_SUPPORTED;\n    ssh->v1_local_protoflags |= SSH1_PROTOFLAG_SCREEN_NUMBER;\n\n    MD5Init(&md5c);\n    MD5Update(&md5c, s->keystr2, s->hostkey.bytes);\n    MD5Update(&md5c, s->keystr1, s->servkey.bytes);\n    MD5Update(&md5c, cookie, 8);\n    MD5Final(s->session_id, &md5c);\n\n    for (i = 0; i < 32; i++)\n\tssh->session_key[i] = random_byte();\n\n    /*\n     * Verify that the `bits' and `bytes' parameters match.\n     */\n    if (s->hostkey.bits > s->hostkey.bytes * 8 ||\n\ts->servkey.bits > s->servkey.bytes * 8) {\n\tbombout((\"SSH-1 public keys were badly formatted\"));\n\tcrStop(0);\n    }\n\n    s->len = (s->hostkey.bytes > s->servkey.bytes ?\n              s->hostkey.bytes : s->servkey.bytes);\n\n    s->rsabuf = snewn(s->len, unsigned char);\n\n    /*\n     * Verify the host key.\n     */\n    {\n\t/*\n\t * First format the key into a string.\n\t */\n\tint len = rsastr_len(&s->hostkey);\n\tchar fingerprint[100];\n\tchar *keystr = snewn(len, char);\n\trsastr_fmt(keystr, &s->hostkey);\n\trsa_fingerprint(fingerprint, sizeof(fingerprint), &s->hostkey);\n\n        /* First check against manually configured host keys. */\n        s->dlgret = verify_ssh_manual_host_key(ssh, fingerprint, NULL, NULL);\n        if (s->dlgret == 0) {          /* did not match */\n            bombout((\"Host key did not appear in manually configured list\"));\n            sfree(keystr);\n            crStop(0);\n        } else if (s->dlgret < 0) { /* none configured; use standard handling */\n            ssh_set_frozen(ssh, 1);\n            s->dlgret = verify_ssh_host_key(ssh->frontend,\n                                            ssh->savedhost, ssh->savedport,\n                                            \"rsa\", keystr, fingerprint,\n                                            ssh_dialog_callback, ssh);\n            sfree(keystr);\n#ifdef FUZZING\n\t    s->dlgret = 1;\n#endif\n            if (s->dlgret < 0) {\n                do {\n                    crReturn(0);\n                    if (pktin) {\n                        bombout((\"Unexpected data from server while waiting\"\n                                 \" for user host key response\"));\n                        crStop(0);\n                    }\n                } while (pktin || inlen > 0);\n                s->dlgret = ssh->user_response;\n            }\n            ssh_set_frozen(ssh, 0);\n\n            if (s->dlgret == 0) {\n                ssh_disconnect(ssh, \"User aborted at host key verification\",\n                               NULL, 0, TRUE);\n                crStop(0);\n            }\n        } else {\n            sfree(keystr);\n        }\n    }\n\n    for (i = 0; i < 32; i++) {\n\ts->rsabuf[i] = ssh->session_key[i];\n\tif (i < 16)\n\t    s->rsabuf[i] ^= s->session_id[i];\n    }\n\n    if (s->hostkey.bytes > s->servkey.bytes) {\n\tret = rsaencrypt(s->rsabuf, 32, &s->servkey);\n\tif (ret)\n\t    ret = rsaencrypt(s->rsabuf, s->servkey.bytes, &s->hostkey);\n    } else {\n\tret = rsaencrypt(s->rsabuf, 32, &s->hostkey);\n\tif (ret)\n\t    ret = rsaencrypt(s->rsabuf, s->hostkey.bytes, &s->servkey);\n    }\n    if (!ret) {\n\tbombout((\"SSH-1 public key encryptions failed due to bad formatting\"));\n\tcrStop(0);\t\n    }\n\n    logevent(\"Encrypted session key\");\n\n    {\n\tint cipher_chosen = 0, warn = 0;\n\tconst char *cipher_string = NULL;\n\tint i;\n\tfor (i = 0; !cipher_chosen && i < CIPHER_MAX; i++) {\n\t    int next_cipher = conf_get_int_int(ssh->conf,\n\t\t\t\t\t       CONF_ssh_cipherlist, i);\n\t    if (next_cipher == CIPHER_WARN) {\n\t\t/* If/when we choose a cipher, warn about it */\n\t\twarn = 1;\n\t    } else if (next_cipher == CIPHER_AES) {\n\t\t/* XXX Probably don't need to mention this. */\n\t\tlogevent(\"AES not supported in SSH-1, skipping\");\n\t    } else {\n\t\tswitch (next_cipher) {\n\t\t  case CIPHER_3DES:     s->cipher_type = SSH_CIPHER_3DES;\n\t\t\t\t\tcipher_string = \"3DES\"; break;\n\t\t  case CIPHER_BLOWFISH: s->cipher_type = SSH_CIPHER_BLOWFISH;\n\t\t\t\t\tcipher_string = \"Blowfish\"; break;\n\t\t  case CIPHER_DES:\ts->cipher_type = SSH_CIPHER_DES;\n\t\t\t\t\tcipher_string = \"single-DES\"; break;\n\t\t}\n\t\tif (s->supported_ciphers_mask & (1 << s->cipher_type))\n\t\t    cipher_chosen = 1;\n\t    }\n\t}\n\tif (!cipher_chosen) {\n\t    if ((s->supported_ciphers_mask & (1 << SSH_CIPHER_3DES)) == 0)\n\t\tbombout((\"Server violates SSH-1 protocol by not \"\n\t\t\t \"supporting 3DES encryption\"));\n\t    else\n\t\t/* shouldn't happen */\n\t\tbombout((\"No supported ciphers found\"));\n\t    crStop(0);\n\t}\n\n\t/* Warn about chosen cipher if necessary. */\n\tif (warn) {\n            ssh_set_frozen(ssh, 1);\n\t    s->dlgret = askalg(ssh->frontend, \"cipher\", cipher_string,\n\t\t\t       ssh_dialog_callback, ssh);\n\t    if (s->dlgret < 0) {\n\t\tdo {\n\t\t    crReturn(0);\n\t\t    if (pktin) {\n\t\t\tbombout((\"Unexpected data from server while waiting\"\n\t\t\t\t \" for user response\"));\n\t\t\tcrStop(0);\n\t\t    }\n\t\t} while (pktin || inlen > 0);\n\t\ts->dlgret = ssh->user_response;\n\t    }\n            ssh_set_frozen(ssh, 0);\n\t    if (s->dlgret == 0) {\n\t\tssh_disconnect(ssh, \"User aborted at cipher warning\", NULL,\n\t\t\t       0, TRUE);\n\t\tcrStop(0);\n\t    }\n        }\n    }\n\n    switch (s->cipher_type) {\n      case SSH_CIPHER_3DES:\n\tlogevent(\"Using 3DES encryption\");\n\tbreak;\n      case SSH_CIPHER_DES:\n\tlogevent(\"Using single-DES encryption\");\n\tbreak;\n      case SSH_CIPHER_BLOWFISH:\n\tlogevent(\"Using Blowfish encryption\");\n\tbreak;\n    }\n\n    send_packet(ssh, SSH1_CMSG_SESSION_KEY,\n\t\tPKT_CHAR, s->cipher_type,\n\t\tPKT_DATA, cookie, 8,\n\t\tPKT_CHAR, (s->len * 8) >> 8, PKT_CHAR, (s->len * 8) & 0xFF,\n\t\tPKT_DATA, s->rsabuf, s->len,\n\t\tPKT_INT, ssh->v1_local_protoflags, PKT_END);\n\n    logevent(\"Trying to enable encryption...\");\n\n    sfree(s->rsabuf);\n\n    ssh->cipher = (s->cipher_type == SSH_CIPHER_BLOWFISH ? &ssh_blowfish_ssh1 :\n\t\t   s->cipher_type == SSH_CIPHER_DES ? &ssh_des :\n\t\t   &ssh_3des);\n    ssh->v1_cipher_ctx = ssh->cipher->make_context();\n    ssh->cipher->sesskey(ssh->v1_cipher_ctx, ssh->session_key);\n    logeventf(ssh, \"Initialised %s encryption\", ssh->cipher->text_name);\n\n    ssh->crcda_ctx = crcda_make_context();\n    logevent(\"Installing CRC compensation attack detector\");\n\n    if (s->servkey.modulus) {\n\tsfree(s->servkey.modulus);\n\ts->servkey.modulus = NULL;\n    }\n    if (s->servkey.exponent) {\n\tsfree(s->servkey.exponent);\n\ts->servkey.exponent = NULL;\n    }\n    if (s->hostkey.modulus) {\n\tsfree(s->hostkey.modulus);\n\ts->hostkey.modulus = NULL;\n    }\n    if (s->hostkey.exponent) {\n\tsfree(s->hostkey.exponent);\n\ts->hostkey.exponent = NULL;\n    }\n    crWaitUntil(pktin);\n\n    if (pktin->type != SSH1_SMSG_SUCCESS) {\n\tbombout((\"Encryption not successfully enabled\"));\n\tcrStop(0);\n    }\n\n    logevent(\"Successfully started encryption\");\n\n    fflush(stdout); /* FIXME eh? */\n    {\n\tif ((ssh->username = get_remote_username(ssh->conf)) == NULL) {\n\t    int ret; /* need not be kept over crReturn */\n\t    s->cur_prompt = new_prompts(ssh->frontend);\n\t    s->cur_prompt->to_server = TRUE;\n\t    s->cur_prompt->name = dupstr(\"SSH login name\");\n\t    add_prompt(s->cur_prompt, dupstr(\"login as: \"), TRUE);\n\t    ret = get_userpass_input(s->cur_prompt, NULL, 0);\n\t    while (ret < 0) {\n\t\tssh->send_ok = 1;\n\t\tcrWaitUntil(!pktin);\n\t\tret = get_userpass_input(s->cur_prompt, in, inlen);\n\t\tssh->send_ok = 0;\n\t    }\n\t    if (!ret) {\n\t\t/*\n\t\t * Failed to get a username. Terminate.\n\t\t */\n\t\tfree_prompts(s->cur_prompt);\n\t\tssh_disconnect(ssh, \"No username provided\", NULL, 0, TRUE);\n\t\tcrStop(0);\n\t    }\n\t    ssh->username = dupstr(s->cur_prompt->prompts[0]->result);\n\t    free_prompts(s->cur_prompt);\n\t}\n\n\tsend_packet(ssh, SSH1_CMSG_USER, PKT_STR, ssh->username, PKT_END);\n\t{\n\t    char *userlog = dupprintf(\"Sent username \\\"%s\\\"\", ssh->username);\n\t    logevent(userlog);\n\t    if (flags & FLAG_INTERACTIVE &&\n\t\t(!((flags & FLAG_STDERR) && (flags & FLAG_VERBOSE)))) {\n\t\tc_write_str(ssh, userlog);\n\t\tc_write_str(ssh, \"\\r\\n\");\n\t    }\n\t    sfree(userlog);\n\t}\n    }\n\n    crWaitUntil(pktin);\n\n    if ((s->supported_auths_mask & (1 << SSH1_AUTH_RSA)) == 0) {\n\t/* We must not attempt PK auth. Pretend we've already tried it. */\n\ts->tried_publickey = s->tried_agent = 1;\n    } else {\n\ts->tried_publickey = s->tried_agent = 0;\n    }\n    s->tis_auth_refused = s->ccard_auth_refused = 0;\n    /*\n     * Load the public half of any configured keyfile for later use.\n     */\n    s->keyfile = conf_get_filename(ssh->conf, CONF_keyfile);\n    if (!filename_is_null(s->keyfile)) {\n\tint keytype;\n\tlogeventf(ssh, \"Reading key file \\\"%.150s\\\"\",\n\t\t  filename_to_str(s->keyfile));\n\tkeytype = key_type(s->keyfile);\n\tif (keytype == SSH_KEYTYPE_SSH1 ||\n            keytype == SSH_KEYTYPE_SSH1_PUBLIC) {\n\t    const char *error;\n\t    if (rsakey_pubblob(s->keyfile,\n\t\t\t       &s->publickey_blob, &s->publickey_bloblen,\n\t\t\t       &s->publickey_comment, &error)) {\n                s->privatekey_available = (keytype == SSH_KEYTYPE_SSH1);\n                if (!s->privatekey_available)\n                    logeventf(ssh, \"Key file contains public key only\");\n\t\ts->privatekey_encrypted = rsakey_encrypted(s->keyfile,\n                                                           NULL);\n\t    } else {\n\t\tchar *msgbuf;\n\t\tlogeventf(ssh, \"Unable to load key (%s)\", error);\n\t\tmsgbuf = dupprintf(\"Unable to load key file \"\n\t\t\t\t   \"\\\"%.150s\\\" (%s)\\r\\n\",\n\t\t\t\t   filename_to_str(s->keyfile),\n\t\t\t\t   error);\n\t\tc_write_str(ssh, msgbuf);\n\t\tsfree(msgbuf);\n\t\ts->publickey_blob = NULL;\n\t    }\n\t} else {\n\t    char *msgbuf;\n\t    logeventf(ssh, \"Unable to use this key file (%s)\",\n\t\t      key_type_to_str(keytype));\n\t    msgbuf = dupprintf(\"Unable to use key file \\\"%.150s\\\"\"\n\t\t\t       \" (%s)\\r\\n\",\n\t\t\t       filename_to_str(s->keyfile),\n\t\t\t       key_type_to_str(keytype));\n\t    c_write_str(ssh, msgbuf);\n\t    sfree(msgbuf);\n\t    s->publickey_blob = NULL;\n\t}\n    } else\n\ts->publickey_blob = NULL;\n\n    while (pktin->type == SSH1_SMSG_FAILURE) {\n\ts->pwpkt_type = SSH1_CMSG_AUTH_PASSWORD;\n\n\tif (conf_get_int(ssh->conf, CONF_tryagent) && agent_exists() && !s->tried_agent) {\n\t    /*\n\t     * Attempt RSA authentication using Pageant.\n\t     */\n\t    void *r;\n\n\t    s->authed = FALSE;\n\t    s->tried_agent = 1;\n\t    logevent(\"Pageant is running. Requesting keys.\");\n\n\t    /* Request the keys held by the agent. */\n\t    PUT_32BIT(s->request, 1);\n\t    s->request[4] = SSH1_AGENTC_REQUEST_RSA_IDENTITIES;\n            ssh->auth_agent_query = agent_query(\n                s->request, 5, &r, &s->responselen, ssh_agent_callback, ssh);\n\t    if (ssh->auth_agent_query) {\n\t\tdo {\n\t\t    crReturn(0);\n\t\t    if (pktin) {\n\t\t\tbombout((\"Unexpected data from server while waiting\"\n\t\t\t\t \" for agent response\"));\n\t\t\tcrStop(0);\n\t\t    }\n\t\t} while (pktin || inlen > 0);\n\t\tr = ssh->agent_response;\n\t\ts->responselen = ssh->agent_response_len;\n\t    }\n\t    s->response = (unsigned char *) r;\n\t    if (s->response && s->responselen >= 5 &&\n\t\ts->response[4] == SSH1_AGENT_RSA_IDENTITIES_ANSWER) {\n\t\ts->p = s->response + 5;\n\t\ts->nkeys = toint(GET_32BIT(s->p));\n                if (s->nkeys < 0) {\n                    logeventf(ssh, \"Pageant reported negative key count %d\",\n                              s->nkeys);\n                    s->nkeys = 0;\n                }\n\t\ts->p += 4;\n\t\tlogeventf(ssh, \"Pageant has %d SSH-1 keys\", s->nkeys);\n\t\tfor (s->keyi = 0; s->keyi < s->nkeys; s->keyi++) {\n\t\t    unsigned char *pkblob = s->p;\n\t\t    s->p += 4;\n\t\t    {\n\t\t\tint n, ok = FALSE;\n\t\t\tdo {\t       /* do while (0) to make breaking easy */\n\t\t\t    n = ssh1_read_bignum\n\t\t\t\t(s->p, toint(s->responselen-(s->p-s->response)),\n\t\t\t\t &s->key.exponent);\n\t\t\t    if (n < 0)\n\t\t\t\tbreak;\n\t\t\t    s->p += n;\n\t\t\t    n = ssh1_read_bignum\n\t\t\t\t(s->p, toint(s->responselen-(s->p-s->response)),\n\t\t\t\t &s->key.modulus);\n\t\t\t    if (n < 0)\n                                break;\n\t\t\t    s->p += n;\n\t\t\t    if (s->responselen - (s->p-s->response) < 4)\n\t\t\t\tbreak;\n\t\t\t    s->commentlen = toint(GET_32BIT(s->p));\n\t\t\t    s->p += 4;\n\t\t\t    if (s->commentlen < 0 ||\n                                toint(s->responselen - (s->p-s->response)) <\n\t\t\t\ts->commentlen)\n\t\t\t\tbreak;\n\t\t\t    s->commentp = (char *)s->p;\n\t\t\t    s->p += s->commentlen;\n\t\t\t    ok = TRUE;\n\t\t\t} while (0);\n\t\t\tif (!ok) {\n\t\t\t    logevent(\"Pageant key list packet was truncated\");\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t    if (s->publickey_blob) {\n\t\t\tif (!memcmp(pkblob, s->publickey_blob,\n\t\t\t\t    s->publickey_bloblen)) {\n\t\t\t    logeventf(ssh, \"Pageant key #%d matches \"\n\t\t\t\t      \"configured key file\", s->keyi);\n\t\t\t    s->tried_publickey = 1;\n\t\t\t} else\n\t\t\t    /* Skip non-configured key */\n\t\t\t    continue;\n\t\t    }\n\t\t    logeventf(ssh, \"Trying Pageant key #%d\", s->keyi);\n\t\t    send_packet(ssh, SSH1_CMSG_AUTH_RSA,\n\t\t\t\tPKT_BIGNUM, s->key.modulus, PKT_END);\n\t\t    crWaitUntil(pktin);\n\t\t    if (pktin->type != SSH1_SMSG_AUTH_RSA_CHALLENGE) {\n\t\t\tlogevent(\"Key refused\");\n\t\t\tcontinue;\n\t\t    }\n\t\t    logevent(\"Received RSA challenge\");\n\t\t    if ((s->challenge = ssh1_pkt_getmp(pktin)) == NULL) {\n\t\t\tbombout((\"Server's RSA challenge was badly formatted\"));\n\t\t\tcrStop(0);\n\t\t    }\n\n\t\t    {\n\t\t\tchar *agentreq, *q, *ret;\n\t\t\tvoid *vret;\n\t\t\tint len, retlen;\n\t\t\tlen = 1 + 4;   /* message type, bit count */\n\t\t\tlen += ssh1_bignum_length(s->key.exponent);\n\t\t\tlen += ssh1_bignum_length(s->key.modulus);\n\t\t\tlen += ssh1_bignum_length(s->challenge);\n\t\t\tlen += 16;     /* session id */\n\t\t\tlen += 4;      /* response format */\n\t\t\tagentreq = snewn(4 + len, char);\n\t\t\tPUT_32BIT(agentreq, len);\n\t\t\tq = agentreq + 4;\n\t\t\t*q++ = SSH1_AGENTC_RSA_CHALLENGE;\n\t\t\tPUT_32BIT(q, bignum_bitcount(s->key.modulus));\n\t\t\tq += 4;\n\t\t\tq += ssh1_write_bignum(q, s->key.exponent);\n\t\t\tq += ssh1_write_bignum(q, s->key.modulus);\n\t\t\tq += ssh1_write_bignum(q, s->challenge);\n\t\t\tmemcpy(q, s->session_id, 16);\n\t\t\tq += 16;\n\t\t\tPUT_32BIT(q, 1);\t/* response format */\n                        ssh->auth_agent_query = agent_query(\n                            agentreq, len + 4, &vret, &retlen,\n                            ssh_agent_callback, ssh);\n\t\t\tif (ssh->auth_agent_query) {\n\t\t\t    sfree(agentreq);\n\t\t\t    do {\n\t\t\t\tcrReturn(0);\n\t\t\t\tif (pktin) {\n\t\t\t\t    bombout((\"Unexpected data from server\"\n\t\t\t\t\t     \" while waiting for agent\"\n\t\t\t\t\t     \" response\"));\n\t\t\t\t    crStop(0);\n\t\t\t\t}\n\t\t\t    } while (pktin || inlen > 0);\n\t\t\t    vret = ssh->agent_response;\n\t\t\t    retlen = ssh->agent_response_len;\n\t\t\t} else\n\t\t\t    sfree(agentreq);\n\t\t\tret = vret;\n\t\t\tif (ret) {\n\t\t\t    if (ret[4] == SSH1_AGENT_RSA_RESPONSE) {\n\t\t\t\tlogevent(\"Sending Pageant's response\");\n\t\t\t\tsend_packet(ssh, SSH1_CMSG_AUTH_RSA_RESPONSE,\n\t\t\t\t\t    PKT_DATA, ret + 5, 16,\n\t\t\t\t\t    PKT_END);\n\t\t\t\tsfree(ret);\n\t\t\t\tcrWaitUntil(pktin);\n\t\t\t\tif (pktin->type == SSH1_SMSG_SUCCESS) {\n\t\t\t\t    logevent\n\t\t\t\t\t(\"Pageant's response accepted\");\n\t\t\t\t    if (flags & FLAG_VERBOSE) {\n\t\t\t\t\tc_write_str(ssh, \"Authenticated using\"\n\t\t\t\t\t\t    \" RSA key \\\"\");\n\t\t\t\t\tc_write(ssh, s->commentp,\n\t\t\t\t\t\ts->commentlen);\n\t\t\t\t\tc_write_str(ssh, \"\\\" from agent\\r\\n\");\n\t\t\t\t    }\n\t\t\t\t    s->authed = TRUE;\n\t\t\t\t} else\n\t\t\t\t    logevent\n\t\t\t\t\t(\"Pageant's response not accepted\");\n\t\t\t    } else {\n\t\t\t\tlogevent\n\t\t\t\t    (\"Pageant failed to answer challenge\");\n\t\t\t\tsfree(ret);\n\t\t\t    }\n\t\t\t} else {\n\t\t\t    logevent(\"No reply received from Pageant\");\n\t\t\t}\n\t\t    }\n\t\t    freebn(s->key.exponent);\n\t\t    freebn(s->key.modulus);\n\t\t    freebn(s->challenge);\n\t\t    if (s->authed)\n\t\t\tbreak;\n\t\t}\n\t\tsfree(s->response);\n\t\tif (s->publickey_blob && !s->tried_publickey)\n\t\t    logevent(\"Configured key file not in Pageant\");\n\t    } else {\n                logevent(\"Failed to get reply from Pageant\");\n            }\n\t    if (s->authed)\n\t\tbreak;\n\t}\n\tif (s->publickey_blob && s->privatekey_available &&\n            !s->tried_publickey) {\n\t    /*\n\t     * Try public key authentication with the specified\n\t     * key file.\n\t     */\n\t    int got_passphrase; /* need not be kept over crReturn */\n\t    if (flags & FLAG_VERBOSE)\n\t\tc_write_str(ssh, \"Trying public key authentication.\\r\\n\");\n\t    s->keyfile = conf_get_filename(ssh->conf, CONF_keyfile);\n\t    logeventf(ssh, \"Trying public key \\\"%s\\\"\",\n\t\t      filename_to_str(s->keyfile));\n\t    s->tried_publickey = 1;\n\t    got_passphrase = FALSE;\n\t    while (!got_passphrase) {\n\t\t/*\n\t\t * Get a passphrase, if necessary.\n\t\t */\n\t\tchar *passphrase = NULL;    /* only written after crReturn */\n\t\tconst char *error;\n\t\tif (!s->privatekey_encrypted) {\n\t\t    if (flags & FLAG_VERBOSE)\n\t\t\tc_write_str(ssh, \"No passphrase required.\\r\\n\");\n\t\t    passphrase = NULL;\n\t\t} else {\n\t\t    int ret; /* need not be kept over crReturn */\n\t\t    s->cur_prompt = new_prompts(ssh->frontend);\n\t\t    s->cur_prompt->to_server = FALSE;\n\t\t    s->cur_prompt->name = dupstr(\"SSH key passphrase\");\n\t\t    add_prompt(s->cur_prompt,\n\t\t\t       dupprintf(\"Passphrase for key \\\"%.100s\\\": \",\n\t\t\t\t\t s->publickey_comment), FALSE);\n\t\t    ret = get_userpass_input(s->cur_prompt, NULL, 0);\n\t\t    while (ret < 0) {\n\t\t\tssh->send_ok = 1;\n\t\t\tcrWaitUntil(!pktin);\n\t\t\tret = get_userpass_input(s->cur_prompt, in, inlen);\n\t\t\tssh->send_ok = 0;\n\t\t    }\n\t\t    if (!ret) {\n\t\t\t/* Failed to get a passphrase. Terminate. */\n\t\t\tfree_prompts(s->cur_prompt);\n\t\t\tssh_disconnect(ssh, NULL, \"Unable to authenticate\",\n\t\t\t\t       0, TRUE);\n\t\t\tcrStop(0);\n\t\t    }\n\t\t    passphrase = dupstr(s->cur_prompt->prompts[0]->result);\n\t\t    free_prompts(s->cur_prompt);\n\t\t}\n\t\t/*\n\t\t * Try decrypting key with passphrase.\n\t\t */\n\t\ts->keyfile = conf_get_filename(ssh->conf, CONF_keyfile);\n\t\tret = loadrsakey(s->keyfile, &s->key, passphrase,\n\t\t\t\t &error);\n\t\tif (passphrase) {\n\t\t    smemclr(passphrase, strlen(passphrase));\n\t\t    sfree(passphrase);\n\t\t}\n\t\tif (ret == 1) {\n\t\t    /* Correct passphrase. */\n\t\t    got_passphrase = TRUE;\n\t\t} else if (ret == 0) {\n\t\t    c_write_str(ssh, \"Couldn't load private key from \");\n\t\t    c_write_str(ssh, filename_to_str(s->keyfile));\n\t\t    c_write_str(ssh, \" (\");\n\t\t    c_write_str(ssh, error);\n\t\t    c_write_str(ssh, \").\\r\\n\");\n\t\t    got_passphrase = FALSE;\n\t\t    break;\t       /* go and try something else */\n\t\t} else if (ret == -1) {\n\t\t    c_write_str(ssh, \"Wrong passphrase.\\r\\n\"); /* FIXME */\n\t\t    got_passphrase = FALSE;\n\t\t    /* and try again */\n\t\t} else {\n\t\t    assert(0 && \"unexpected return from loadrsakey()\");\n\t\t    got_passphrase = FALSE;   /* placate optimisers */\n\t\t}\n\t    }\n\n\t    if (got_passphrase) {\n\n\t\t/*\n\t\t * Send a public key attempt.\n\t\t */\n\t\tsend_packet(ssh, SSH1_CMSG_AUTH_RSA,\n\t\t\t    PKT_BIGNUM, s->key.modulus, PKT_END);\n\n\t\tcrWaitUntil(pktin);\n\t\tif (pktin->type == SSH1_SMSG_FAILURE) {\n\t\t    c_write_str(ssh, \"Server refused our public key.\\r\\n\");\n\t\t    continue;\t       /* go and try something else */\n\t\t}\n\t\tif (pktin->type != SSH1_SMSG_AUTH_RSA_CHALLENGE) {\n\t\t    bombout((\"Bizarre response to offer of public key\"));\n\t\t    crStop(0);\n\t\t}\n\n\t\t{\n\t\t    int i;\n\t\t    unsigned char buffer[32];\n\t\t    Bignum challenge, response;\n\n\t\t    if ((challenge = ssh1_pkt_getmp(pktin)) == NULL) {\n\t\t\tbombout((\"Server's RSA challenge was badly formatted\"));\n\t\t\tcrStop(0);\n\t\t    }\n\t\t    response = rsadecrypt(challenge, &s->key);\n\t\t    freebn(s->key.private_exponent);/* burn the evidence */\n\n\t\t    for (i = 0; i < 32; i++) {\n\t\t\tbuffer[i] = bignum_byte(response, 31 - i);\n\t\t    }\n\n\t\t    MD5Init(&md5c);\n\t\t    MD5Update(&md5c, buffer, 32);\n\t\t    MD5Update(&md5c, s->session_id, 16);\n\t\t    MD5Final(buffer, &md5c);\n\n\t\t    send_packet(ssh, SSH1_CMSG_AUTH_RSA_RESPONSE,\n\t\t\t\tPKT_DATA, buffer, 16, PKT_END);\n\n\t\t    freebn(challenge);\n\t\t    freebn(response);\n\t\t}\n\n\t\tcrWaitUntil(pktin);\n\t\tif (pktin->type == SSH1_SMSG_FAILURE) {\n\t\t    if (flags & FLAG_VERBOSE)\n\t\t\tc_write_str(ssh, \"Failed to authenticate with\"\n\t\t\t\t    \" our public key.\\r\\n\");\n\t\t    continue;\t       /* go and try something else */\n\t\t} else if (pktin->type != SSH1_SMSG_SUCCESS) {\n\t\t    bombout((\"Bizarre response to RSA authentication response\"));\n\t\t    crStop(0);\n\t\t}\n\n\t\tbreak;\t\t       /* we're through! */\n\t    }\n\n\t}\n\n\t/*\n\t * Otherwise, try various forms of password-like authentication.\n\t */\n\ts->cur_prompt = new_prompts(ssh->frontend);\n\n\tif (conf_get_int(ssh->conf, CONF_try_tis_auth) &&\n\t    (s->supported_auths_mask & (1 << SSH1_AUTH_TIS)) &&\n\t    !s->tis_auth_refused) {\n\t    s->pwpkt_type = SSH1_CMSG_AUTH_TIS_RESPONSE;\n\t    logevent(\"Requested TIS authentication\");\n\t    send_packet(ssh, SSH1_CMSG_AUTH_TIS, PKT_END);\n\t    crWaitUntil(pktin);\n\t    if (pktin->type != SSH1_SMSG_AUTH_TIS_CHALLENGE) {\n\t\tlogevent(\"TIS authentication declined\");\n\t\tif (flags & FLAG_INTERACTIVE)\n\t\t    c_write_str(ssh, \"TIS authentication refused.\\r\\n\");\n\t\ts->tis_auth_refused = 1;\n\t\tcontinue;\n\t    } else {\n\t\tchar *challenge;\n\t\tint challengelen;\n\t\tchar *instr_suf, *prompt;\n\n\t\tssh_pkt_getstring(pktin, &challenge, &challengelen);\n\t\tif (!challenge) {\n\t\t    bombout((\"TIS challenge packet was badly formed\"));\n\t\t    crStop(0);\n\t\t}\n\t\tlogevent(\"Received TIS challenge\");\n\t\ts->cur_prompt->to_server = TRUE;\n\t\ts->cur_prompt->name = dupstr(\"SSH TIS authentication\");\n\t\t/* Prompt heuristic comes from OpenSSH */\n\t\tif (memchr(challenge, '\\n', challengelen)) {\n\t\t    instr_suf = dupstr(\"\");\n\t\t    prompt = dupprintf(\"%.*s\", challengelen, challenge);\n\t\t} else {\n\t\t    instr_suf = dupprintf(\"%.*s\", challengelen, challenge);\n\t\t    prompt = dupstr(\"Response: \");\n\t\t}\n\t\ts->cur_prompt->instruction =\n\t\t    dupprintf(\"Using TIS authentication.%s%s\",\n\t\t\t      (*instr_suf) ? \"\\n\" : \"\",\n\t\t\t      instr_suf);\n\t\ts->cur_prompt->instr_reqd = TRUE;\n\t\tadd_prompt(s->cur_prompt, prompt, FALSE);\n\t\tsfree(instr_suf);\n\t    }\n\t}\n\tif (conf_get_int(ssh->conf, CONF_try_tis_auth) &&\n\t    (s->supported_auths_mask & (1 << SSH1_AUTH_CCARD)) &&\n\t    !s->ccard_auth_refused) {\n\t    s->pwpkt_type = SSH1_CMSG_AUTH_CCARD_RESPONSE;\n\t    logevent(\"Requested CryptoCard authentication\");\n\t    send_packet(ssh, SSH1_CMSG_AUTH_CCARD, PKT_END);\n\t    crWaitUntil(pktin);\n\t    if (pktin->type != SSH1_SMSG_AUTH_CCARD_CHALLENGE) {\n\t\tlogevent(\"CryptoCard authentication declined\");\n\t\tc_write_str(ssh, \"CryptoCard authentication refused.\\r\\n\");\n\t\ts->ccard_auth_refused = 1;\n\t\tcontinue;\n\t    } else {\n\t\tchar *challenge;\n\t\tint challengelen;\n\t\tchar *instr_suf, *prompt;\n\n\t\tssh_pkt_getstring(pktin, &challenge, &challengelen);\n\t\tif (!challenge) {\n\t\t    bombout((\"CryptoCard challenge packet was badly formed\"));\n\t\t    crStop(0);\n\t\t}\n\t\tlogevent(\"Received CryptoCard challenge\");\n\t\ts->cur_prompt->to_server = TRUE;\n\t\ts->cur_prompt->name = dupstr(\"SSH CryptoCard authentication\");\n\t\ts->cur_prompt->name_reqd = FALSE;\n\t\t/* Prompt heuristic comes from OpenSSH */\n\t\tif (memchr(challenge, '\\n', challengelen)) {\n\t\t    instr_suf = dupstr(\"\");\n\t\t    prompt = dupprintf(\"%.*s\", challengelen, challenge);\n\t\t} else {\n\t\t    instr_suf = dupprintf(\"%.*s\", challengelen, challenge);\n\t\t    prompt = dupstr(\"Response: \");\n\t\t}\n\t\ts->cur_prompt->instruction =\n\t\t    dupprintf(\"Using CryptoCard authentication.%s%s\",\n\t\t\t      (*instr_suf) ? \"\\n\" : \"\",\n\t\t\t      instr_suf);\n\t\ts->cur_prompt->instr_reqd = TRUE;\n\t\tadd_prompt(s->cur_prompt, prompt, FALSE);\n\t\tsfree(instr_suf);\n\t    }\n\t}\n\tif (s->pwpkt_type == SSH1_CMSG_AUTH_PASSWORD) {\n\t    if ((s->supported_auths_mask & (1 << SSH1_AUTH_PASSWORD)) == 0) {\n\t\tbombout((\"No supported authentication methods available\"));\n\t\tcrStop(0);\n\t    }\n\t    s->cur_prompt->to_server = TRUE;\n\t    s->cur_prompt->name = dupstr(\"SSH password\");\n\t    add_prompt(s->cur_prompt, dupprintf(\"%s@%s's password: \",\n\t\t\t\t\t\tssh->username, ssh->savedhost),\n\t\t       FALSE);\n\t}\n\n\t/*\n\t * Show password prompt, having first obtained it via a TIS\n\t * or CryptoCard exchange if we're doing TIS or CryptoCard\n\t * authentication.\n\t */\n\t{\n\t    int ret; /* need not be kept over crReturn */\n\t    ret = get_userpass_input(s->cur_prompt, NULL, 0);\n\t    while (ret < 0) {\n\t\tssh->send_ok = 1;\n\t\tcrWaitUntil(!pktin);\n\t\tret = get_userpass_input(s->cur_prompt, in, inlen);\n\t\tssh->send_ok = 0;\n\t    }\n\t    if (!ret) {\n\t\t/*\n\t\t * Failed to get a password (for example\n\t\t * because one was supplied on the command line\n\t\t * which has already failed to work). Terminate.\n\t\t */\n\t\tfree_prompts(s->cur_prompt);\n\t\tssh_disconnect(ssh, NULL, \"Unable to authenticate\", 0, TRUE);\n\t\tcrStop(0);\n\t    }\n\t}\n\n\tif (s->pwpkt_type == SSH1_CMSG_AUTH_PASSWORD) {\n\t    /*\n\t     * Defence against traffic analysis: we send a\n\t     * whole bunch of packets containing strings of\n\t     * different lengths. One of these strings is the\n\t     * password, in a SSH1_CMSG_AUTH_PASSWORD packet.\n\t     * The others are all random data in\n\t     * SSH1_MSG_IGNORE packets. This way a passive\n\t     * listener can't tell which is the password, and\n\t     * hence can't deduce the password length.\n\t     * \n\t     * Anybody with a password length greater than 16\n\t     * bytes is going to have enough entropy in their\n\t     * password that a listener won't find it _that_\n\t     * much help to know how long it is. So what we'll\n\t     * do is:\n\t     * \n\t     *  - if password length < 16, we send 15 packets\n\t     *    containing string lengths 1 through 15\n\t     * \n\t     *  - otherwise, we let N be the nearest multiple\n\t     *    of 8 below the password length, and send 8\n\t     *    packets containing string lengths N through\n\t     *    N+7. This won't obscure the order of\n\t     *    magnitude of the password length, but it will\n\t     *    introduce a bit of extra uncertainty.\n\t     * \n\t     * A few servers can't deal with SSH1_MSG_IGNORE, at\n\t     * least in this context. For these servers, we need\n\t     * an alternative defence. We make use of the fact\n\t     * that the password is interpreted as a C string:\n\t     * so we can append a NUL, then some random data.\n\t     * \n\t     * A few servers can deal with neither SSH1_MSG_IGNORE\n\t     * here _nor_ a padded password string.\n\t     * For these servers we are left with no defences\n\t     * against password length sniffing.\n\t     */\n\t    if (!(ssh->remote_bugs & BUG_CHOKES_ON_SSH1_IGNORE) &&\n\t        !(ssh->remote_bugs & BUG_NEEDS_SSH1_PLAIN_PASSWORD)) {\n\t\t/*\n\t\t * The server can deal with SSH1_MSG_IGNORE, so\n\t\t * we can use the primary defence.\n\t\t */\n\t\tint bottom, top, pwlen, i;\n\t\tchar *randomstr;\n\n\t\tpwlen = strlen(s->cur_prompt->prompts[0]->result);\n\t\tif (pwlen < 16) {\n\t\t    bottom = 0;    /* zero length passwords are OK! :-) */\n\t\t    top = 15;\n\t\t} else {\n\t\t    bottom = pwlen & ~7;\n\t\t    top = bottom + 7;\n\t\t}\n\n\t\tassert(pwlen >= bottom && pwlen <= top);\n\n\t\trandomstr = snewn(top + 1, char);\n\n\t\tfor (i = bottom; i <= top; i++) {\n\t\t    if (i == pwlen) {\n\t\t\tdefer_packet(ssh, s->pwpkt_type,\n                                     PKT_STR,s->cur_prompt->prompts[0]->result,\n\t\t\t\t     PKT_END);\n\t\t    } else {\n\t\t\tfor (j = 0; j < i; j++) {\n\t\t\t    do {\n\t\t\t\trandomstr[j] = random_byte();\n\t\t\t    } while (randomstr[j] == '\\0');\n\t\t\t}\n\t\t\trandomstr[i] = '\\0';\n\t\t\tdefer_packet(ssh, SSH1_MSG_IGNORE,\n\t\t\t\t     PKT_STR, randomstr, PKT_END);\n\t\t    }\n\t\t}\n\t\tlogevent(\"Sending password with camouflage packets\");\n\t\tssh_pkt_defersend(ssh);\n\t\tsfree(randomstr);\n\t    } \n\t    else if (!(ssh->remote_bugs & BUG_NEEDS_SSH1_PLAIN_PASSWORD)) {\n\t\t/*\n\t\t * The server can't deal with SSH1_MSG_IGNORE\n\t\t * but can deal with padded passwords, so we\n\t\t * can use the secondary defence.\n\t\t */\n\t\tchar string[64];\n\t\tchar *ss;\n\t\tint len;\n\n\t\tlen = strlen(s->cur_prompt->prompts[0]->result);\n\t\tif (len < sizeof(string)) {\n\t\t    ss = string;\n\t\t    strcpy(string, s->cur_prompt->prompts[0]->result);\n\t\t    len++;\t       /* cover the zero byte */\n\t\t    while (len < sizeof(string)) {\n\t\t\tstring[len++] = (char) random_byte();\n\t\t    }\n\t\t} else {\n\t\t    ss = s->cur_prompt->prompts[0]->result;\n\t\t}\n\t\tlogevent(\"Sending length-padded password\");\n\t\tsend_packet(ssh, s->pwpkt_type,\n\t\t\t    PKT_INT, len, PKT_DATA, ss, len,\n\t\t\t    PKT_END);\n\t    } else {\n\t\t/*\n\t\t * The server is believed unable to cope with\n\t\t * any of our password camouflage methods.\n\t\t */\n\t\tint len;\n\t\tlen = strlen(s->cur_prompt->prompts[0]->result);\n\t\tlogevent(\"Sending unpadded password\");\n\t\tsend_packet(ssh, s->pwpkt_type,\n                            PKT_INT, len,\n\t\t\t    PKT_DATA, s->cur_prompt->prompts[0]->result, len,\n\t\t\t    PKT_END);\n\t    }\n\t} else {\n\t    send_packet(ssh, s->pwpkt_type,\n\t\t\tPKT_STR, s->cur_prompt->prompts[0]->result,\n\t\t\tPKT_END);\n\t}\n\tlogevent(\"Sent password\");\n\tfree_prompts(s->cur_prompt);\n\tcrWaitUntil(pktin);\n\tif (pktin->type == SSH1_SMSG_FAILURE) {\n\t    if (flags & FLAG_VERBOSE)\n\t\tc_write_str(ssh, \"Access denied\\r\\n\");\n\t    logevent(\"Authentication refused\");\n\t} else if (pktin->type != SSH1_SMSG_SUCCESS) {\n\t    bombout((\"Strange packet received, type %d\", pktin->type));\n\t    crStop(0);\n\t}\n    }\n\n    /* Clear up */\n    if (s->publickey_blob) {\n\tsfree(s->publickey_blob);\n\tsfree(s->publickey_comment);\n    }\n\n    logevent(\"Authentication successful\");\n\n    crFinish(1);\n}\n\nstatic void ssh_channel_try_eof(struct ssh_channel *c)\n{\n    Ssh ssh = c->ssh;\n    assert(c->pending_eof);          /* precondition for calling us */\n    if (c->halfopen)\n        return;                 /* can't close: not even opened yet */\n    if (ssh->version == 2 && bufchain_size(&c->v.v2.outbuffer) > 0)\n        return;              /* can't send EOF: pending outgoing data */\n\n    c->pending_eof = FALSE;            /* we're about to send it */\n    if (ssh->version == 1) {\n        send_packet(ssh, SSH1_MSG_CHANNEL_CLOSE, PKT_INT, c->remoteid,\n                    PKT_END);\n        c->closes |= CLOSES_SENT_EOF;\n    } else {\n        struct Packet *pktout;\n        pktout = ssh2_pkt_init(SSH2_MSG_CHANNEL_EOF);\n        ssh2_pkt_adduint32(pktout, c->remoteid);\n        ssh2_pkt_send(ssh, pktout);\n        c->closes |= CLOSES_SENT_EOF;\n\tssh2_channel_check_close(c);\n    }\n}\n\nConf *sshfwd_get_conf(struct ssh_channel *c)\n{\n    Ssh ssh = c->ssh;\n    return ssh->conf;\n}\n\nvoid sshfwd_write_eof(struct ssh_channel *c)\n{\n    Ssh ssh = c->ssh;\n\n    if (ssh->state == SSH_STATE_CLOSED)\n\treturn;\n\n    if (c->closes & CLOSES_SENT_EOF)\n        return;\n\n    c->pending_eof = TRUE;\n    ssh_channel_try_eof(c);\n}\n\nvoid sshfwd_unclean_close(struct ssh_channel *c, const char *err)\n{\n    Ssh ssh = c->ssh;\n    char *reason;\n\n    if (ssh->state == SSH_STATE_CLOSED)\n\treturn;\n\n    reason = dupprintf(\"due to local error: %s\", err);\n    ssh_channel_close_local(c, reason);\n    sfree(reason);\n    c->pending_eof = FALSE;   /* this will confuse a zombie channel */\n\n    ssh2_channel_check_close(c);\n}\n\nint sshfwd_write(struct ssh_channel *c, char *buf, int len)\n{\n    Ssh ssh = c->ssh;\n\n    if (ssh->state == SSH_STATE_CLOSED)\n\treturn 0;\n\n    return ssh_send_channel_data(c, buf, len);\n}\n\nvoid sshfwd_unthrottle(struct ssh_channel *c, int bufsize)\n{\n    Ssh ssh = c->ssh;\n\n    if (ssh->state == SSH_STATE_CLOSED)\n\treturn;\n\n    ssh_channel_unthrottle(c, bufsize);\n}\n\nstatic void ssh_queueing_handler(Ssh ssh, struct Packet *pktin)\n{\n    struct queued_handler *qh = ssh->qhead;\n\n    assert(qh != NULL);\n\n    assert(pktin->type == qh->msg1 || pktin->type == qh->msg2);\n\n    if (qh->msg1 > 0) {\n\tassert(ssh->packet_dispatch[qh->msg1] == ssh_queueing_handler);\n\tssh->packet_dispatch[qh->msg1] = ssh->q_saved_handler1;\n    }\n    if (qh->msg2 > 0) {\n\tassert(ssh->packet_dispatch[qh->msg2] == ssh_queueing_handler);\n\tssh->packet_dispatch[qh->msg2] = ssh->q_saved_handler2;\n    }\n\n    if (qh->next) {\n\tssh->qhead = qh->next;\n\n\tif (ssh->qhead->msg1 > 0) {\n\t    ssh->q_saved_handler1 = ssh->packet_dispatch[ssh->qhead->msg1];\n\t    ssh->packet_dispatch[ssh->qhead->msg1] = ssh_queueing_handler;\n\t}\n\tif (ssh->qhead->msg2 > 0) {\n\t    ssh->q_saved_handler2 = ssh->packet_dispatch[ssh->qhead->msg2];\n\t    ssh->packet_dispatch[ssh->qhead->msg2] = ssh_queueing_handler;\n\t}\n    } else {\n\tssh->qhead = ssh->qtail = NULL;\n    }\n\n    qh->handler(ssh, pktin, qh->ctx);\n\n    sfree(qh);\n}\n\nstatic void ssh_queue_handler(Ssh ssh, int msg1, int msg2,\n\t\t\t      chandler_fn_t handler, void *ctx)\n{\n    struct queued_handler *qh;\n\n    qh = snew(struct queued_handler);\n    qh->msg1 = msg1;\n    qh->msg2 = msg2;\n    qh->handler = handler;\n    qh->ctx = ctx;\n    qh->next = NULL;\n\n    if (ssh->qtail == NULL) {\n\tssh->qhead = qh;\n\n\tif (qh->msg1 > 0) {\n\t    ssh->q_saved_handler1 = ssh->packet_dispatch[ssh->qhead->msg1];\n\t    ssh->packet_dispatch[qh->msg1] = ssh_queueing_handler;\n\t}\n\tif (qh->msg2 > 0) {\n\t    ssh->q_saved_handler2 = ssh->packet_dispatch[ssh->qhead->msg2];\n\t    ssh->packet_dispatch[qh->msg2] = ssh_queueing_handler;\n\t}\n    } else {\n\tssh->qtail->next = qh;\n    }\n    ssh->qtail = qh;\n}\n\nstatic void ssh_rportfwd_succfail(Ssh ssh, struct Packet *pktin, void *ctx)\n{\n    struct ssh_rportfwd *rpf, *pf = (struct ssh_rportfwd *)ctx;\n\n    if (pktin->type == (ssh->version == 1 ? SSH1_SMSG_SUCCESS :\n\t\t\tSSH2_MSG_REQUEST_SUCCESS)) {\n\tlogeventf(ssh, \"Remote port forwarding from %s enabled\",\n\t\t  pf->sportdesc);\n    } else {\n\tlogeventf(ssh, \"Remote port forwarding from %s refused\",\n\t\t  pf->sportdesc);\n\n\trpf = del234(ssh->rportfwds, pf);\n\tassert(rpf == pf);\n\tpf->pfrec->remote = NULL;\n\tfree_rportfwd(pf);\n    }\n}\n\nint ssh_alloc_sharing_rportfwd(Ssh ssh, const char *shost, int sport,\n                               void *share_ctx)\n{\n    struct ssh_rportfwd *pf = snew(struct ssh_rportfwd);\n    pf->dhost = NULL;\n    pf->dport = 0;\n    pf->share_ctx = share_ctx;\n    pf->shost = dupstr(shost);\n    pf->sport = sport;\n    pf->sportdesc = NULL;\n    if (!ssh->rportfwds) {\n        assert(ssh->version == 2);\n        ssh->rportfwds = newtree234(ssh_rportcmp_ssh2);\n    }\n    if (add234(ssh->rportfwds, pf) != pf) {\n        sfree(pf->shost);\n        sfree(pf);\n        return FALSE;\n    }\n    return TRUE;\n}\n\nstatic void ssh_sharing_global_request_response(Ssh ssh, struct Packet *pktin,\n                                                void *ctx)\n{\n    share_got_pkt_from_server(ctx, pktin->type,\n                              pktin->body, pktin->length);\n}\n\nvoid ssh_sharing_queue_global_request(Ssh ssh, void *share_ctx)\n{\n    ssh_queue_handler(ssh, SSH2_MSG_REQUEST_SUCCESS, SSH2_MSG_REQUEST_FAILURE,\n                      ssh_sharing_global_request_response, share_ctx);\n}\n\nstatic void ssh_setup_portfwd(Ssh ssh, Conf *conf)\n{\n    struct ssh_portfwd *epf;\n    int i;\n    char *key, *val;\n\n    if (!ssh->portfwds) {\n\tssh->portfwds = newtree234(ssh_portcmp);\n    } else {\n\t/*\n\t * Go through the existing port forwardings and tag them\n\t * with status==DESTROY. Any that we want to keep will be\n\t * re-enabled (status==KEEP) as we go through the\n\t * configuration and find out which bits are the same as\n\t * they were before.\n\t */\n\tstruct ssh_portfwd *epf;\n\tint i;\n\tfor (i = 0; (epf = index234(ssh->portfwds, i)) != NULL; i++)\n\t    epf->status = DESTROY;\n    }\n\n    for (val = conf_get_str_strs(conf, CONF_portfwd, NULL, &key);\n\t val != NULL;\n\t val = conf_get_str_strs(conf, CONF_portfwd, key, &key)) {\n\tchar *kp, *kp2, *vp, *vp2;\n\tchar address_family, type;\n\tint sport,dport,sserv,dserv;\n\tchar *sports, *dports, *saddr, *host;\n\n\tkp = key;\n\n\taddress_family = 'A';\n\ttype = 'L';\n\tif (*kp == 'A' || *kp == '4' || *kp == '6')\n\t    address_family = *kp++;\n\tif (*kp == 'L' || *kp == 'R')\n\t    type = *kp++;\n\n\tif ((kp2 = host_strchr(kp, ':')) != NULL) {\n\t    /*\n\t     * There's a colon in the middle of the source port\n\t     * string, which means that the part before it is\n\t     * actually a source address.\n\t     */\n\t    char *saddr_tmp = dupprintf(\"%.*s\", (int)(kp2 - kp), kp);\n            saddr = host_strduptrim(saddr_tmp);\n            sfree(saddr_tmp);\n\t    sports = kp2+1;\n\t} else {\n\t    saddr = NULL;\n\t    sports = kp;\n\t}\n\tsport = atoi(sports);\n\tsserv = 0;\n\tif (sport == 0) {\n\t    sserv = 1;\n\t    sport = net_service_lookup(sports);\n\t    if (!sport) {\n\t\tlogeventf(ssh, \"Service lookup failed for source\"\n\t\t\t  \" port \\\"%s\\\"\", sports);\n\t    }\n\t}\n\n\tif (type == 'L' && !strcmp(val, \"D\")) {\n            /* dynamic forwarding */\n\t    host = NULL;\n\t    dports = NULL;\n\t    dport = -1;\n\t    dserv = 0;\n            type = 'D';\n        } else {\n            /* ordinary forwarding */\n\t    vp = val;\n\t    vp2 = vp + host_strcspn(vp, \":\");\n\t    host = dupprintf(\"%.*s\", (int)(vp2 - vp), vp);\n\t    if (*vp2)\n\t\tvp2++;\n\t    dports = vp2;\n\t    dport = atoi(dports);\n\t    dserv = 0;\n\t    if (dport == 0) {\n\t\tdserv = 1;\n\t\tdport = net_service_lookup(dports);\n\t\tif (!dport) {\n\t\t    logeventf(ssh, \"Service lookup failed for destination\"\n\t\t\t      \" port \\\"%s\\\"\", dports);\n\t\t}\n\t    }\n\t}\n\n\tif (sport && dport) {\n\t    /* Set up a description of the source port. */\n\t    struct ssh_portfwd *pfrec, *epfrec;\n\n\t    pfrec = snew(struct ssh_portfwd);\n\t    pfrec->type = type;\n\t    pfrec->saddr = saddr;\n\t    pfrec->sserv = sserv ? dupstr(sports) : NULL;\n\t    pfrec->sport = sport;\n\t    pfrec->daddr = host;\n\t    pfrec->dserv = dserv ? dupstr(dports) : NULL;\n\t    pfrec->dport = dport;\n\t    pfrec->local = NULL;\n\t    pfrec->remote = NULL;\n\t    pfrec->addressfamily = (address_family == '4' ? ADDRTYPE_IPV4 :\n\t\t\t\t    address_family == '6' ? ADDRTYPE_IPV6 :\n\t\t\t\t    ADDRTYPE_UNSPEC);\n\n\t    epfrec = add234(ssh->portfwds, pfrec);\n\t    if (epfrec != pfrec) {\n\t\tif (epfrec->status == DESTROY) {\n\t\t    /*\n\t\t     * We already have a port forwarding up and running\n\t\t     * with precisely these parameters. Hence, no need\n\t\t     * to do anything; simply re-tag the existing one\n\t\t     * as KEEP.\n\t\t     */\n\t\t    epfrec->status = KEEP;\n\t\t}\n\t\t/*\n\t\t * Anything else indicates that there was a duplicate\n\t\t * in our input, which we'll silently ignore.\n\t\t */\n\t\tfree_portfwd(pfrec);\n\t    } else {\n\t\tpfrec->status = CREATE;\n\t    }\n\t} else {\n\t    sfree(saddr);\n\t    sfree(host);\n\t}\n    }\n\n    /*\n     * Now go through and destroy any port forwardings which were\n     * not re-enabled.\n     */\n    for (i = 0; (epf = index234(ssh->portfwds, i)) != NULL; i++)\n\tif (epf->status == DESTROY) {\n\t    char *message;\n\n\t    message = dupprintf(\"%s port forwarding from %s%s%d\",\n\t\t\t\tepf->type == 'L' ? \"local\" :\n\t\t\t\tepf->type == 'R' ? \"remote\" : \"dynamic\",\n\t\t\t\tepf->saddr ? epf->saddr : \"\",\n\t\t\t\tepf->saddr ? \":\" : \"\",\n\t\t\t\tepf->sport);\n\n\t    if (epf->type != 'D') {\n\t\tchar *msg2 = dupprintf(\"%s to %s:%d\", message,\n\t\t\t\t       epf->daddr, epf->dport);\n\t\tsfree(message);\n\t\tmessage = msg2;\n\t    }\n\n\t    logeventf(ssh, \"Cancelling %s\", message);\n\t    sfree(message);\n\n\t    /* epf->remote or epf->local may be NULL if setting up a\n\t     * forwarding failed. */\n\t    if (epf->remote) {\n\t\tstruct ssh_rportfwd *rpf = epf->remote;\n\t\tstruct Packet *pktout;\n\n\t\t/*\n\t\t * Cancel the port forwarding at the server\n\t\t * end.\n\t\t */\n\t\tif (ssh->version == 1) {\n\t\t    /*\n\t\t     * We cannot cancel listening ports on the\n\t\t     * server side in SSH-1! There's no message\n\t\t     * to support it. Instead, we simply remove\n\t\t     * the rportfwd record from the local end\n\t\t     * so that any connections the server tries\n\t\t     * to make on it are rejected.\n\t\t     */\n\t\t} else {\n\t\t    pktout = ssh2_pkt_init(SSH2_MSG_GLOBAL_REQUEST);\n\t\t    ssh2_pkt_addstring(pktout, \"cancel-tcpip-forward\");\n\t\t    ssh2_pkt_addbool(pktout, 0);/* _don't_ want reply */\n\t\t    if (epf->saddr) {\n\t\t\tssh2_pkt_addstring(pktout, epf->saddr);\n\t\t    } else if (conf_get_int(conf, CONF_rport_acceptall)) {\n\t\t\t/* XXX: rport_acceptall may not represent\n\t\t\t * what was used to open the original connection,\n\t\t\t * since it's reconfigurable. */\n\t\t\tssh2_pkt_addstring(pktout, \"\");\n\t\t    } else {\n\t\t\tssh2_pkt_addstring(pktout, \"localhost\");\n\t\t    }\n\t\t    ssh2_pkt_adduint32(pktout, epf->sport);\n\t\t    ssh2_pkt_send(ssh, pktout);\n\t\t}\n\n\t\tdel234(ssh->rportfwds, rpf);\n\t\tfree_rportfwd(rpf);\n\t    } else if (epf->local) {\n\t\tpfl_terminate(epf->local);\n\t    }\n\n\t    delpos234(ssh->portfwds, i);\n\t    free_portfwd(epf);\n\t    i--;\t\t       /* so we don't skip one in the list */\n\t}\n\n    /*\n     * And finally, set up any new port forwardings (status==CREATE).\n     */\n    for (i = 0; (epf = index234(ssh->portfwds, i)) != NULL; i++)\n\tif (epf->status == CREATE) {\n\t    char *sportdesc, *dportdesc;\n\t    sportdesc = dupprintf(\"%s%s%s%s%d%s\",\n\t\t\t\t  epf->saddr ? epf->saddr : \"\",\n\t\t\t\t  epf->saddr ? \":\" : \"\",\n\t\t\t\t  epf->sserv ? epf->sserv : \"\",\n\t\t\t\t  epf->sserv ? \"(\" : \"\",\n\t\t\t\t  epf->sport,\n\t\t\t\t  epf->sserv ? \")\" : \"\");\n\t    if (epf->type == 'D') {\n\t\tdportdesc = NULL;\n\t    } else {\n\t\tdportdesc = dupprintf(\"%s:%s%s%d%s\",\n\t\t\t\t      epf->daddr,\n\t\t\t\t      epf->dserv ? epf->dserv : \"\",\n\t\t\t\t      epf->dserv ? \"(\" : \"\",\n\t\t\t\t      epf->dport,\n\t\t\t\t      epf->dserv ? \")\" : \"\");\n\t    }\n\n\t    if (epf->type == 'L') {\n                char *err = pfl_listen(epf->daddr, epf->dport,\n                                       epf->saddr, epf->sport,\n                                       ssh, conf, &epf->local,\n                                       epf->addressfamily);\n\n\t\tlogeventf(ssh, \"Local %sport %s forwarding to %s%s%s\",\n\t\t\t  epf->addressfamily == ADDRTYPE_IPV4 ? \"IPv4 \" :\n\t\t\t  epf->addressfamily == ADDRTYPE_IPV6 ? \"IPv6 \" : \"\",\n\t\t\t  sportdesc, dportdesc,\n\t\t\t  err ? \" failed: \" : \"\", err ? err : \"\");\n                if (err)\n                    sfree(err);\n\t    } else if (epf->type == 'D') {\n\t\tchar *err = pfl_listen(NULL, -1, epf->saddr, epf->sport,\n                                       ssh, conf, &epf->local,\n                                       epf->addressfamily);\n\n\t\tlogeventf(ssh, \"Local %sport %s SOCKS dynamic forwarding%s%s\",\n\t\t\t  epf->addressfamily == ADDRTYPE_IPV4 ? \"IPv4 \" :\n\t\t\t  epf->addressfamily == ADDRTYPE_IPV6 ? \"IPv6 \" : \"\",\n\t\t\t  sportdesc,\n\t\t\t  err ? \" failed: \" : \"\", err ? err : \"\");\n\n                if (err)\n                    sfree(err);\n\t    } else {\n\t\tstruct ssh_rportfwd *pf;\n\n\t\t/*\n\t\t * Ensure the remote port forwardings tree exists.\n\t\t */\n\t\tif (!ssh->rportfwds) {\n\t\t    if (ssh->version == 1)\n\t\t\tssh->rportfwds = newtree234(ssh_rportcmp_ssh1);\n\t\t    else\n\t\t\tssh->rportfwds = newtree234(ssh_rportcmp_ssh2);\n\t\t}\n\n\t\tpf = snew(struct ssh_rportfwd);\n                pf->share_ctx = NULL;\n                pf->dhost = dupstr(epf->daddr);\n\t\tpf->dport = epf->dport;\n                if (epf->saddr) {\n                    pf->shost = dupstr(epf->saddr);\n                } else if (conf_get_int(conf, CONF_rport_acceptall)) {\n                    pf->shost = dupstr(\"\");\n                } else {\n                    pf->shost = dupstr(\"localhost\");\n                }\n\t\tpf->sport = epf->sport;\n\t\tif (add234(ssh->rportfwds, pf) != pf) {\n\t\t    logeventf(ssh, \"Duplicate remote port forwarding to %s:%d\",\n\t\t\t      epf->daddr, epf->dport);\n\t\t    sfree(pf);\n\t\t} else {\n\t\t    logeventf(ssh, \"Requesting remote port %s\"\n\t\t\t      \" forward to %s\", sportdesc, dportdesc);\n\n\t\t    pf->sportdesc = sportdesc;\n\t\t    sportdesc = NULL;\n\t\t    epf->remote = pf;\n\t\t    pf->pfrec = epf;\n\n\t\t    if (ssh->version == 1) {\n\t\t\tsend_packet(ssh, SSH1_CMSG_PORT_FORWARD_REQUEST,\n\t\t\t\t    PKT_INT, epf->sport,\n\t\t\t\t    PKT_STR, epf->daddr,\n\t\t\t\t    PKT_INT, epf->dport,\n\t\t\t\t    PKT_END);\n\t\t\tssh_queue_handler(ssh, SSH1_SMSG_SUCCESS,\n\t\t\t\t\t  SSH1_SMSG_FAILURE,\n\t\t\t\t\t  ssh_rportfwd_succfail, pf);\n\t\t    } else {\n\t\t\tstruct Packet *pktout;\n\t\t\tpktout = ssh2_pkt_init(SSH2_MSG_GLOBAL_REQUEST);\n\t\t\tssh2_pkt_addstring(pktout, \"tcpip-forward\");\n\t\t\tssh2_pkt_addbool(pktout, 1);/* want reply */\n\t\t\tssh2_pkt_addstring(pktout, pf->shost);\n\t\t\tssh2_pkt_adduint32(pktout, pf->sport);\n\t\t\tssh2_pkt_send(ssh, pktout);\n\n\t\t\tssh_queue_handler(ssh, SSH2_MSG_REQUEST_SUCCESS,\n\t\t\t\t\t  SSH2_MSG_REQUEST_FAILURE,\n\t\t\t\t\t  ssh_rportfwd_succfail, pf);\n\t\t    }\n\t\t}\n\t    }\n\t    sfree(sportdesc);\n\t    sfree(dportdesc);\n\t}\n}\n\nstatic void ssh1_smsg_stdout_stderr_data(Ssh ssh, struct Packet *pktin)\n{\n    char *string;\n    int stringlen, bufsize;\n\n    ssh_pkt_getstring(pktin, &string, &stringlen);\n    if (string == NULL) {\n\tbombout((\"Incoming terminal data packet was badly formed\"));\n\treturn;\n    }\n\n    bufsize = from_backend(ssh->frontend, pktin->type == SSH1_SMSG_STDERR_DATA,\n\t\t\t   string, stringlen);\n    if (!ssh->v1_stdout_throttling && bufsize > SSH1_BUFFER_LIMIT) {\n\tssh->v1_stdout_throttling = 1;\n\tssh_throttle_conn(ssh, +1);\n    }\n}\n\nstatic void ssh1_smsg_x11_open(Ssh ssh, struct Packet *pktin)\n{\n    /* Remote side is trying to open a channel to talk to our\n     * X-Server. Give them back a local channel number. */\n    struct ssh_channel *c;\n    int remoteid = ssh_pkt_getuint32(pktin);\n\n    logevent(\"Received X11 connect request\");\n    /* Refuse if X11 forwarding is disabled. */\n    if (!ssh->X11_fwd_enabled) {\n\tsend_packet(ssh, SSH1_MSG_CHANNEL_OPEN_FAILURE,\n\t\t    PKT_INT, remoteid, PKT_END);\n\tlogevent(\"Rejected X11 connect request\");\n    } else {\n\tc = snew(struct ssh_channel);\n\tc->ssh = ssh;\n\n\tssh_channel_init(c);\n\tc->u.x11.xconn = x11_init(ssh->x11authtree, c, NULL, -1);\n        c->remoteid = remoteid;\n        c->halfopen = FALSE;\n        c->type = CHAN_X11;\t/* identify channel type */\n        send_packet(ssh, SSH1_MSG_CHANNEL_OPEN_CONFIRMATION,\n                    PKT_INT, c->remoteid, PKT_INT,\n                    c->localid, PKT_END);\n        logevent(\"Opened X11 forward channel\");\n    }\n}\n\nstatic void ssh1_smsg_agent_open(Ssh ssh, struct Packet *pktin)\n{\n    /* Remote side is trying to open a channel to talk to our\n     * agent. Give them back a local channel number. */\n    struct ssh_channel *c;\n    int remoteid = ssh_pkt_getuint32(pktin);\n\n    /* Refuse if agent forwarding is disabled. */\n    if (!ssh->agentfwd_enabled) {\n\tsend_packet(ssh, SSH1_MSG_CHANNEL_OPEN_FAILURE,\n\t\t    PKT_INT, remoteid, PKT_END);\n    } else {\n\tc = snew(struct ssh_channel);\n\tc->ssh = ssh;\n\tssh_channel_init(c);\n\tc->remoteid = remoteid;\n\tc->halfopen = FALSE;\n\tc->type = CHAN_AGENT;\t/* identify channel type */\n\tc->u.a.lensofar = 0;\n\tc->u.a.message = NULL;\n\tc->u.a.pending = NULL;\n\tc->u.a.outstanding_requests = 0;\n\tsend_packet(ssh, SSH1_MSG_CHANNEL_OPEN_CONFIRMATION,\n\t\t    PKT_INT, c->remoteid, PKT_INT, c->localid,\n\t\t    PKT_END);\n    }\n}\n\nstatic void ssh1_msg_port_open(Ssh ssh, struct Packet *pktin)\n{\n    /* Remote side is trying to open a channel to talk to a\n     * forwarded port. Give them back a local channel number. */\n    struct ssh_rportfwd pf, *pfp;\n    int remoteid;\n    int hostsize, port;\n    char *host;\n    char *err;\n\n    remoteid = ssh_pkt_getuint32(pktin);\n    ssh_pkt_getstring(pktin, &host, &hostsize);\n    port = ssh_pkt_getuint32(pktin);\n\n    pf.dhost = dupprintf(\"%.*s\", hostsize, NULLTOEMPTY(host));\n    pf.dport = port;\n    pfp = find234(ssh->rportfwds, &pf, NULL);\n\n    if (pfp == NULL) {\n\tlogeventf(ssh, \"Rejected remote port open request for %s:%d\",\n\t\t  pf.dhost, port);\n\tsend_packet(ssh, SSH1_MSG_CHANNEL_OPEN_FAILURE,\n\t\t    PKT_INT, remoteid, PKT_END);\n    } else {\n        struct ssh_channel *c = snew(struct ssh_channel);\n        c->ssh = ssh;\n\n\tlogeventf(ssh, \"Received remote port open request for %s:%d\",\n\t\t  pf.dhost, port);\n\terr = pfd_connect(&c->u.pfd.pf, pf.dhost, port,\n                          c, ssh->conf, pfp->pfrec->addressfamily);\n\tif (err != NULL) {\n\t    logeventf(ssh, \"Port open failed: %s\", err);\n            sfree(err);\n\t    sfree(c);\n\t    send_packet(ssh, SSH1_MSG_CHANNEL_OPEN_FAILURE,\n\t\t\tPKT_INT, remoteid, PKT_END);\n\t} else {\n\t    ssh_channel_init(c);\n\t    c->remoteid = remoteid;\n\t    c->halfopen = FALSE;\n\t    c->type = CHAN_SOCKDATA;\t/* identify channel type */\n\t    send_packet(ssh, SSH1_MSG_CHANNEL_OPEN_CONFIRMATION,\n\t\t\tPKT_INT, c->remoteid, PKT_INT,\n\t\t\tc->localid, PKT_END);\n\t    logevent(\"Forwarded port opened successfully\");\n\t}\n    }\n\n    sfree(pf.dhost);\n}\n\nstatic void ssh1_msg_channel_open_confirmation(Ssh ssh, struct Packet *pktin)\n{\n    struct ssh_channel *c;\n\n    c = ssh_channel_msg(ssh, pktin);\n    if (c && c->type == CHAN_SOCKDATA) {\n\tc->remoteid = ssh_pkt_getuint32(pktin);\n\tc->halfopen = FALSE;\n\tc->throttling_conn = 0;\n\tpfd_confirm(c->u.pfd.pf);\n    }\n\n    if (c && c->pending_eof) {\n\t/*\n\t * We have a pending close on this channel,\n\t * which we decided on before the server acked\n\t * the channel open. So now we know the\n\t * remoteid, we can close it again.\n\t */\n        ssh_channel_try_eof(c);\n    }\n}\n\n        c->remoteid = remoteid;\n        c->halfopen = FALSE;\n        c->type = CHAN_AGENT;   /* identify channel type */\n       c->u.a.lensofar = 0;\n       c->u.a.message = NULL;\n        c->u.a.pending = NULL;\n       c->u.a.outstanding_requests = 0;\n        send_packet(ssh, SSH1_MSG_CHANNEL_OPEN_CONFIRMATION,\n                    PKT_INT, c->remoteid, PKT_INT, c->localid,\n                    PKT_END);\n\tdel234(ssh->channels, c);\n\tsfree(c);\n    }\n}\n",
    "code_after_change": "static void ssh_throttle_all(Ssh ssh, int enable, int bufsize)\n{\n    int i;\n    struct ssh_channel *c;\n\n    if (enable == ssh->throttled_all)\n\treturn;\n    ssh->throttled_all = enable;\n    ssh->overall_bufsize = bufsize;\n    if (!ssh->channels)\n\treturn;\n    for (i = 0; NULL != (c = index234(ssh->channels, i)); i++) {\n\tswitch (c->type) {\n\t  case CHAN_MAINSESSION:\n\t    /*\n\t     * This is treated separately, outside the switch.\n\t     */\n\t    break;\n            x11_override_throttle(c->u.x11.xconn, enable);\n            break;\n          case CHAN_AGENT:\n           /* Agent forwarding channels are buffer-managed by\n             * checking ssh->throttled_all in ssh_agentf_try_forward.\n             * So at the moment we _un_throttle again, we must make an\n             * attempt to do something. */\n            if (!enable)\n                ssh_agentf_try_forward(c);\n            break;\n          case CHAN_SOCKDATA:\n            pfd_override_throttle(c->u.pfd.pf, enable);\n\nstatic void ssh_agent_callback(void *sshv, void *reply, int replylen)\n{\n    Ssh ssh = (Ssh) sshv;\n\n    ssh->auth_agent_query = NULL;\n\n    ssh->agent_response = reply;\n    ssh->agent_response_len = replylen;\n\n    if (ssh->version == 1)\n\tdo_ssh1_login(ssh, NULL, -1, NULL);\n    else\n\tdo_ssh2_authconn(ssh, NULL, -1, NULL);\n}\n\nstatic void ssh_dialog_callback(void *sshv, int ret)\n{\n    Ssh ssh = (Ssh) sshv;\n\n    ssh->user_response = ret;\n\n    if (ssh->version == 1)\n\tdo_ssh1_login(ssh, NULL, -1, NULL);\n    else\n\tdo_ssh2_transport(ssh, NULL, -1, NULL);\n\n    /*\n     * This may have unfrozen the SSH connection, so do a\n     * queued-data run.\n     */\n    ssh_process_queued_incoming_data(ssh);\n}\n\nstatic void ssh_agentf_callback(void *cv, void *reply, int replylen)\n     ssh_process_queued_incoming_data(ssh);\n }\n \nstatic void ssh_agentf_got_response(struct ssh_channel *c,\n                                    void *reply, int replylen)\n {\n     c->u.a.pending = NULL;\n\n    if (!reply) {\n       /* The real agent didn't send any kind of reply at all for\n         * some reason, so fake an SSH_AGENT_FAILURE. */\n       reply = \"\\0\\0\\0\\1\\5\";\n        replylen = 5;\n     }\n\n    ssh_send_channel_data(c, reply, replylen);\n}\n\nstatic void ssh_agentf_callback(void *cv, void *reply, int replylen);\n\nstatic void ssh_agentf_try_forward(struct ssh_channel *c)\n{\n    unsigned datalen, lengthfield, messagelen;\n    unsigned char *message;\n    unsigned char msglen[4];\n    void *reply;\n    int replylen;\n\n     /*\n     * Don't try to parallelise agent requests. Wait for each one to\n     * return before attempting the next.\n      */\n    if (c->u.a.pending)\n        return;\n\n    /*\n     * If the outgoing side of the channel connection is currently\n     * throttled (for any reason, either that channel's window size or\n     * the entire SSH connection being throttled), don't submit any\n     * new forwarded requests to the real agent. This causes the input\n     * side of the agent forwarding not to be emptied, exerting the\n     * required back-pressure on the remote client, and encouraging it\n     * to read our responses before sending too many more requests.\n     */\n    if (c->ssh->throttled_all ||\n        (c->ssh->version == 2 && c->v.v2.remwindow == 0))\n        return;\n\n    while (1) {\n        /*\n         * Try to extract a complete message from the input buffer.\n         */\n        datalen = bufchain_size(&c->u.a.inbuffer);\n        if (datalen < 4)\n            break;         /* not even a length field available yet */\n\n        bufchain_fetch(&c->u.a.inbuffer, msglen, 4);\n        lengthfield = GET_32BIT(msglen);\n        if (lengthfield > datalen - 4)\n            break;          /* a whole message is not yet available */\n\n        messagelen = lengthfield + 4;\n\n        message = snewn(messagelen, unsigned char);\n        bufchain_fetch(&c->u.a.inbuffer, message, messagelen);\n        bufchain_consume(&c->u.a.inbuffer, messagelen);\n        c->u.a.pending = agent_query(\n            message, messagelen, &reply, &replylen, ssh_agentf_callback, c);\n        sfree(message);\n\n        if (c->u.a.pending)\n            return;   /* agent_query promised to reply in due course */\n\n        /*\n         * If the agent gave us an answer immediately, pass it\n         * straight on and go round this loop again.\n         */\n        ssh_agentf_got_response(c, reply, replylen);\n    }\n\n    /*\n     * If we get here (i.e. we left the above while loop via 'break'\n     * rather than 'return'), that means we've determined that the\n     * input buffer for the agent forwarding connection doesn't\n     * contain a complete request.\n     *\n     * So if there's potentially more data to come, we can return now,\n     * and wait for the remote client to send it. But if the remote\n     * has sent EOF, it would be a mistake to do that, because we'd be\n     * waiting a long time. So this is the moment to check for EOF,\n     * and respond appropriately.\n     */\n    if (c->closes & CLOSES_RCVD_EOF)\n         sshfwd_write_eof(c);\n }\n \nstatic void ssh_agentf_callback(void *cv, void *reply, int replylen)\n{\n    struct ssh_channel *c = (struct ssh_channel *)cv;\n\n    ssh_agentf_got_response(c, reply, replylen);\n    sfree(reply);\n\n    /*\n     * Now try to extract and send further messages from the channel's\n     * input-side buffer.\n     */\n    ssh_agentf_try_forward(c);\n}\n\n /*\n  * Client-initiated disconnection. Send a DISCONNECT if `wire_reason'\n  * non-NULL, otherwise just close the connection. `client_reason' == NULL\n\t\t\t struct Packet *pktin)\n{\n    int i, j, ret;\n    unsigned char cookie[8], *ptr;\n    struct MD5Context md5c;\n    struct do_ssh1_login_state {\n\tint crLine;\n\tint len;\n\tunsigned char *rsabuf;\n        const unsigned char *keystr1, *keystr2;\n\tunsigned long supported_ciphers_mask, supported_auths_mask;\n\tint tried_publickey, tried_agent;\n\tint tis_auth_refused, ccard_auth_refused;\n\tunsigned char session_id[16];\n\tint cipher_type;\n\tvoid *publickey_blob;\n\tint publickey_bloblen;\n\tchar *publickey_comment;\n\tint privatekey_available, privatekey_encrypted;\n\tprompts_t *cur_prompt;\n\tchar c;\n\tint pwpkt_type;\n\tunsigned char request[5], *response, *p;\n\tint responselen;\n\tint keyi, nkeys;\n\tint authed;\n\tstruct RSAKey key;\n\tBignum challenge;\n\tchar *commentp;\n\tint commentlen;\n        int dlgret;\n\tFilename *keyfile;\n        struct RSAKey servkey, hostkey;\n    };\n    crState(do_ssh1_login_state);\n\n    crBeginState;\n\n    if (!pktin)\n\tcrWaitUntil(pktin);\n\n    if (pktin->type != SSH1_SMSG_PUBLIC_KEY) {\n\tbombout((\"Public key packet not received\"));\n\tcrStop(0);\n    }\n\n    logevent(\"Received public keys\");\n\n    ptr = ssh_pkt_getdata(pktin, 8);\n    if (!ptr) {\n\tbombout((\"SSH-1 public key packet stopped before random cookie\"));\n\tcrStop(0);\n    }\n    memcpy(cookie, ptr, 8);\n\n    if (!ssh1_pkt_getrsakey(pktin, &s->servkey, &s->keystr1) ||\n\t!ssh1_pkt_getrsakey(pktin, &s->hostkey, &s->keystr2)) {\t\n\tbombout((\"Failed to read SSH-1 public keys from public key packet\"));\n\tcrStop(0);\n    }\n\n    /*\n     * Log the host key fingerprint.\n     */\n    {\n\tchar logmsg[80];\n\tlogevent(\"Host key fingerprint is:\");\n\tstrcpy(logmsg, \"      \");\n\ts->hostkey.comment = NULL;\n\trsa_fingerprint(logmsg + strlen(logmsg),\n\t\t\tsizeof(logmsg) - strlen(logmsg), &s->hostkey);\n\tlogevent(logmsg);\n    }\n\n    ssh->v1_remote_protoflags = ssh_pkt_getuint32(pktin);\n    s->supported_ciphers_mask = ssh_pkt_getuint32(pktin);\n    s->supported_auths_mask = ssh_pkt_getuint32(pktin);\n    if ((ssh->remote_bugs & BUG_CHOKES_ON_RSA))\n\ts->supported_auths_mask &= ~(1 << SSH1_AUTH_RSA);\n\n    ssh->v1_local_protoflags =\n\tssh->v1_remote_protoflags & SSH1_PROTOFLAGS_SUPPORTED;\n    ssh->v1_local_protoflags |= SSH1_PROTOFLAG_SCREEN_NUMBER;\n\n    MD5Init(&md5c);\n    MD5Update(&md5c, s->keystr2, s->hostkey.bytes);\n    MD5Update(&md5c, s->keystr1, s->servkey.bytes);\n    MD5Update(&md5c, cookie, 8);\n    MD5Final(s->session_id, &md5c);\n\n    for (i = 0; i < 32; i++)\n\tssh->session_key[i] = random_byte();\n\n    /*\n     * Verify that the `bits' and `bytes' parameters match.\n     */\n    if (s->hostkey.bits > s->hostkey.bytes * 8 ||\n\ts->servkey.bits > s->servkey.bytes * 8) {\n\tbombout((\"SSH-1 public keys were badly formatted\"));\n\tcrStop(0);\n    }\n\n    s->len = (s->hostkey.bytes > s->servkey.bytes ?\n              s->hostkey.bytes : s->servkey.bytes);\n\n    s->rsabuf = snewn(s->len, unsigned char);\n\n    /*\n     * Verify the host key.\n     */\n    {\n\t/*\n\t * First format the key into a string.\n\t */\n\tint len = rsastr_len(&s->hostkey);\n\tchar fingerprint[100];\n\tchar *keystr = snewn(len, char);\n\trsastr_fmt(keystr, &s->hostkey);\n\trsa_fingerprint(fingerprint, sizeof(fingerprint), &s->hostkey);\n\n        /* First check against manually configured host keys. */\n        s->dlgret = verify_ssh_manual_host_key(ssh, fingerprint, NULL, NULL);\n        if (s->dlgret == 0) {          /* did not match */\n            bombout((\"Host key did not appear in manually configured list\"));\n            sfree(keystr);\n            crStop(0);\n        } else if (s->dlgret < 0) { /* none configured; use standard handling */\n            ssh_set_frozen(ssh, 1);\n            s->dlgret = verify_ssh_host_key(ssh->frontend,\n                                            ssh->savedhost, ssh->savedport,\n                                            \"rsa\", keystr, fingerprint,\n                                            ssh_dialog_callback, ssh);\n            sfree(keystr);\n#ifdef FUZZING\n\t    s->dlgret = 1;\n#endif\n            if (s->dlgret < 0) {\n                do {\n                    crReturn(0);\n                    if (pktin) {\n                        bombout((\"Unexpected data from server while waiting\"\n                                 \" for user host key response\"));\n                        crStop(0);\n                    }\n                } while (pktin || inlen > 0);\n                s->dlgret = ssh->user_response;\n            }\n            ssh_set_frozen(ssh, 0);\n\n            if (s->dlgret == 0) {\n                ssh_disconnect(ssh, \"User aborted at host key verification\",\n                               NULL, 0, TRUE);\n                crStop(0);\n            }\n        } else {\n            sfree(keystr);\n        }\n    }\n\n    for (i = 0; i < 32; i++) {\n\ts->rsabuf[i] = ssh->session_key[i];\n\tif (i < 16)\n\t    s->rsabuf[i] ^= s->session_id[i];\n    }\n\n    if (s->hostkey.bytes > s->servkey.bytes) {\n\tret = rsaencrypt(s->rsabuf, 32, &s->servkey);\n\tif (ret)\n\t    ret = rsaencrypt(s->rsabuf, s->servkey.bytes, &s->hostkey);\n    } else {\n\tret = rsaencrypt(s->rsabuf, 32, &s->hostkey);\n\tif (ret)\n\t    ret = rsaencrypt(s->rsabuf, s->hostkey.bytes, &s->servkey);\n    }\n    if (!ret) {\n\tbombout((\"SSH-1 public key encryptions failed due to bad formatting\"));\n\tcrStop(0);\t\n    }\n\n    logevent(\"Encrypted session key\");\n\n    {\n\tint cipher_chosen = 0, warn = 0;\n\tconst char *cipher_string = NULL;\n\tint i;\n\tfor (i = 0; !cipher_chosen && i < CIPHER_MAX; i++) {\n\t    int next_cipher = conf_get_int_int(ssh->conf,\n\t\t\t\t\t       CONF_ssh_cipherlist, i);\n\t    if (next_cipher == CIPHER_WARN) {\n\t\t/* If/when we choose a cipher, warn about it */\n\t\twarn = 1;\n\t    } else if (next_cipher == CIPHER_AES) {\n\t\t/* XXX Probably don't need to mention this. */\n\t\tlogevent(\"AES not supported in SSH-1, skipping\");\n\t    } else {\n\t\tswitch (next_cipher) {\n\t\t  case CIPHER_3DES:     s->cipher_type = SSH_CIPHER_3DES;\n\t\t\t\t\tcipher_string = \"3DES\"; break;\n\t\t  case CIPHER_BLOWFISH: s->cipher_type = SSH_CIPHER_BLOWFISH;\n\t\t\t\t\tcipher_string = \"Blowfish\"; break;\n\t\t  case CIPHER_DES:\ts->cipher_type = SSH_CIPHER_DES;\n\t\t\t\t\tcipher_string = \"single-DES\"; break;\n\t\t}\n\t\tif (s->supported_ciphers_mask & (1 << s->cipher_type))\n\t\t    cipher_chosen = 1;\n\t    }\n\t}\n\tif (!cipher_chosen) {\n\t    if ((s->supported_ciphers_mask & (1 << SSH_CIPHER_3DES)) == 0)\n\t\tbombout((\"Server violates SSH-1 protocol by not \"\n\t\t\t \"supporting 3DES encryption\"));\n\t    else\n\t\t/* shouldn't happen */\n\t\tbombout((\"No supported ciphers found\"));\n\t    crStop(0);\n\t}\n\n\t/* Warn about chosen cipher if necessary. */\n\tif (warn) {\n            ssh_set_frozen(ssh, 1);\n\t    s->dlgret = askalg(ssh->frontend, \"cipher\", cipher_string,\n\t\t\t       ssh_dialog_callback, ssh);\n\t    if (s->dlgret < 0) {\n\t\tdo {\n\t\t    crReturn(0);\n\t\t    if (pktin) {\n\t\t\tbombout((\"Unexpected data from server while waiting\"\n\t\t\t\t \" for user response\"));\n\t\t\tcrStop(0);\n\t\t    }\n\t\t} while (pktin || inlen > 0);\n\t\ts->dlgret = ssh->user_response;\n\t    }\n            ssh_set_frozen(ssh, 0);\n\t    if (s->dlgret == 0) {\n\t\tssh_disconnect(ssh, \"User aborted at cipher warning\", NULL,\n\t\t\t       0, TRUE);\n\t\tcrStop(0);\n\t    }\n        }\n    }\n\n    switch (s->cipher_type) {\n      case SSH_CIPHER_3DES:\n\tlogevent(\"Using 3DES encryption\");\n\tbreak;\n      case SSH_CIPHER_DES:\n\tlogevent(\"Using single-DES encryption\");\n\tbreak;\n      case SSH_CIPHER_BLOWFISH:\n\tlogevent(\"Using Blowfish encryption\");\n\tbreak;\n    }\n\n    send_packet(ssh, SSH1_CMSG_SESSION_KEY,\n\t\tPKT_CHAR, s->cipher_type,\n\t\tPKT_DATA, cookie, 8,\n\t\tPKT_CHAR, (s->len * 8) >> 8, PKT_CHAR, (s->len * 8) & 0xFF,\n\t\tPKT_DATA, s->rsabuf, s->len,\n\t\tPKT_INT, ssh->v1_local_protoflags, PKT_END);\n\n    logevent(\"Trying to enable encryption...\");\n\n    sfree(s->rsabuf);\n\n    ssh->cipher = (s->cipher_type == SSH_CIPHER_BLOWFISH ? &ssh_blowfish_ssh1 :\n\t\t   s->cipher_type == SSH_CIPHER_DES ? &ssh_des :\n\t\t   &ssh_3des);\n    ssh->v1_cipher_ctx = ssh->cipher->make_context();\n    ssh->cipher->sesskey(ssh->v1_cipher_ctx, ssh->session_key);\n    logeventf(ssh, \"Initialised %s encryption\", ssh->cipher->text_name);\n\n    ssh->crcda_ctx = crcda_make_context();\n    logevent(\"Installing CRC compensation attack detector\");\n\n    if (s->servkey.modulus) {\n\tsfree(s->servkey.modulus);\n\ts->servkey.modulus = NULL;\n    }\n    if (s->servkey.exponent) {\n\tsfree(s->servkey.exponent);\n\ts->servkey.exponent = NULL;\n    }\n    if (s->hostkey.modulus) {\n\tsfree(s->hostkey.modulus);\n\ts->hostkey.modulus = NULL;\n    }\n    if (s->hostkey.exponent) {\n\tsfree(s->hostkey.exponent);\n\ts->hostkey.exponent = NULL;\n    }\n    crWaitUntil(pktin);\n\n    if (pktin->type != SSH1_SMSG_SUCCESS) {\n\tbombout((\"Encryption not successfully enabled\"));\n\tcrStop(0);\n    }\n\n    logevent(\"Successfully started encryption\");\n\n    fflush(stdout); /* FIXME eh? */\n    {\n\tif ((ssh->username = get_remote_username(ssh->conf)) == NULL) {\n\t    int ret; /* need not be kept over crReturn */\n\t    s->cur_prompt = new_prompts(ssh->frontend);\n\t    s->cur_prompt->to_server = TRUE;\n\t    s->cur_prompt->name = dupstr(\"SSH login name\");\n\t    add_prompt(s->cur_prompt, dupstr(\"login as: \"), TRUE);\n\t    ret = get_userpass_input(s->cur_prompt, NULL, 0);\n\t    while (ret < 0) {\n\t\tssh->send_ok = 1;\n\t\tcrWaitUntil(!pktin);\n\t\tret = get_userpass_input(s->cur_prompt, in, inlen);\n\t\tssh->send_ok = 0;\n\t    }\n\t    if (!ret) {\n\t\t/*\n\t\t * Failed to get a username. Terminate.\n\t\t */\n\t\tfree_prompts(s->cur_prompt);\n\t\tssh_disconnect(ssh, \"No username provided\", NULL, 0, TRUE);\n\t\tcrStop(0);\n\t    }\n\t    ssh->username = dupstr(s->cur_prompt->prompts[0]->result);\n\t    free_prompts(s->cur_prompt);\n\t}\n\n\tsend_packet(ssh, SSH1_CMSG_USER, PKT_STR, ssh->username, PKT_END);\n\t{\n\t    char *userlog = dupprintf(\"Sent username \\\"%s\\\"\", ssh->username);\n\t    logevent(userlog);\n\t    if (flags & FLAG_INTERACTIVE &&\n\t\t(!((flags & FLAG_STDERR) && (flags & FLAG_VERBOSE)))) {\n\t\tc_write_str(ssh, userlog);\n\t\tc_write_str(ssh, \"\\r\\n\");\n\t    }\n\t    sfree(userlog);\n\t}\n    }\n\n    crWaitUntil(pktin);\n\n    if ((s->supported_auths_mask & (1 << SSH1_AUTH_RSA)) == 0) {\n\t/* We must not attempt PK auth. Pretend we've already tried it. */\n\ts->tried_publickey = s->tried_agent = 1;\n    } else {\n\ts->tried_publickey = s->tried_agent = 0;\n    }\n    s->tis_auth_refused = s->ccard_auth_refused = 0;\n    /*\n     * Load the public half of any configured keyfile for later use.\n     */\n    s->keyfile = conf_get_filename(ssh->conf, CONF_keyfile);\n    if (!filename_is_null(s->keyfile)) {\n\tint keytype;\n\tlogeventf(ssh, \"Reading key file \\\"%.150s\\\"\",\n\t\t  filename_to_str(s->keyfile));\n\tkeytype = key_type(s->keyfile);\n\tif (keytype == SSH_KEYTYPE_SSH1 ||\n            keytype == SSH_KEYTYPE_SSH1_PUBLIC) {\n\t    const char *error;\n\t    if (rsakey_pubblob(s->keyfile,\n\t\t\t       &s->publickey_blob, &s->publickey_bloblen,\n\t\t\t       &s->publickey_comment, &error)) {\n                s->privatekey_available = (keytype == SSH_KEYTYPE_SSH1);\n                if (!s->privatekey_available)\n                    logeventf(ssh, \"Key file contains public key only\");\n\t\ts->privatekey_encrypted = rsakey_encrypted(s->keyfile,\n                                                           NULL);\n\t    } else {\n\t\tchar *msgbuf;\n\t\tlogeventf(ssh, \"Unable to load key (%s)\", error);\n\t\tmsgbuf = dupprintf(\"Unable to load key file \"\n\t\t\t\t   \"\\\"%.150s\\\" (%s)\\r\\n\",\n\t\t\t\t   filename_to_str(s->keyfile),\n\t\t\t\t   error);\n\t\tc_write_str(ssh, msgbuf);\n\t\tsfree(msgbuf);\n\t\ts->publickey_blob = NULL;\n\t    }\n\t} else {\n\t    char *msgbuf;\n\t    logeventf(ssh, \"Unable to use this key file (%s)\",\n\t\t      key_type_to_str(keytype));\n\t    msgbuf = dupprintf(\"Unable to use key file \\\"%.150s\\\"\"\n\t\t\t       \" (%s)\\r\\n\",\n\t\t\t       filename_to_str(s->keyfile),\n\t\t\t       key_type_to_str(keytype));\n\t    c_write_str(ssh, msgbuf);\n\t    sfree(msgbuf);\n\t    s->publickey_blob = NULL;\n\t}\n    } else\n\ts->publickey_blob = NULL;\n\n    while (pktin->type == SSH1_SMSG_FAILURE) {\n\ts->pwpkt_type = SSH1_CMSG_AUTH_PASSWORD;\n\n\tif (conf_get_int(ssh->conf, CONF_tryagent) && agent_exists() && !s->tried_agent) {\n\t    /*\n\t     * Attempt RSA authentication using Pageant.\n\t     */\n\t    void *r;\n\n\t    s->authed = FALSE;\n\t    s->tried_agent = 1;\n\t    logevent(\"Pageant is running. Requesting keys.\");\n\n\t    /* Request the keys held by the agent. */\n\t    PUT_32BIT(s->request, 1);\n\t    s->request[4] = SSH1_AGENTC_REQUEST_RSA_IDENTITIES;\n            ssh->auth_agent_query = agent_query(\n                s->request, 5, &r, &s->responselen, ssh_agent_callback, ssh);\n\t    if (ssh->auth_agent_query) {\n\t\tdo {\n\t\t    crReturn(0);\n\t\t    if (pktin) {\n\t\t\tbombout((\"Unexpected data from server while waiting\"\n\t\t\t\t \" for agent response\"));\n\t\t\tcrStop(0);\n\t\t    }\n\t\t} while (pktin || inlen > 0);\n\t\tr = ssh->agent_response;\n\t\ts->responselen = ssh->agent_response_len;\n\t    }\n\t    s->response = (unsigned char *) r;\n\t    if (s->response && s->responselen >= 5 &&\n\t\ts->response[4] == SSH1_AGENT_RSA_IDENTITIES_ANSWER) {\n\t\ts->p = s->response + 5;\n\t\ts->nkeys = toint(GET_32BIT(s->p));\n                if (s->nkeys < 0) {\n                    logeventf(ssh, \"Pageant reported negative key count %d\",\n                              s->nkeys);\n                    s->nkeys = 0;\n                }\n\t\ts->p += 4;\n\t\tlogeventf(ssh, \"Pageant has %d SSH-1 keys\", s->nkeys);\n\t\tfor (s->keyi = 0; s->keyi < s->nkeys; s->keyi++) {\n\t\t    unsigned char *pkblob = s->p;\n\t\t    s->p += 4;\n\t\t    {\n\t\t\tint n, ok = FALSE;\n\t\t\tdo {\t       /* do while (0) to make breaking easy */\n\t\t\t    n = ssh1_read_bignum\n\t\t\t\t(s->p, toint(s->responselen-(s->p-s->response)),\n\t\t\t\t &s->key.exponent);\n\t\t\t    if (n < 0)\n\t\t\t\tbreak;\n\t\t\t    s->p += n;\n\t\t\t    n = ssh1_read_bignum\n\t\t\t\t(s->p, toint(s->responselen-(s->p-s->response)),\n\t\t\t\t &s->key.modulus);\n\t\t\t    if (n < 0)\n                                break;\n\t\t\t    s->p += n;\n\t\t\t    if (s->responselen - (s->p-s->response) < 4)\n\t\t\t\tbreak;\n\t\t\t    s->commentlen = toint(GET_32BIT(s->p));\n\t\t\t    s->p += 4;\n\t\t\t    if (s->commentlen < 0 ||\n                                toint(s->responselen - (s->p-s->response)) <\n\t\t\t\ts->commentlen)\n\t\t\t\tbreak;\n\t\t\t    s->commentp = (char *)s->p;\n\t\t\t    s->p += s->commentlen;\n\t\t\t    ok = TRUE;\n\t\t\t} while (0);\n\t\t\tif (!ok) {\n\t\t\t    logevent(\"Pageant key list packet was truncated\");\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t    if (s->publickey_blob) {\n\t\t\tif (!memcmp(pkblob, s->publickey_blob,\n\t\t\t\t    s->publickey_bloblen)) {\n\t\t\t    logeventf(ssh, \"Pageant key #%d matches \"\n\t\t\t\t      \"configured key file\", s->keyi);\n\t\t\t    s->tried_publickey = 1;\n\t\t\t} else\n\t\t\t    /* Skip non-configured key */\n\t\t\t    continue;\n\t\t    }\n\t\t    logeventf(ssh, \"Trying Pageant key #%d\", s->keyi);\n\t\t    send_packet(ssh, SSH1_CMSG_AUTH_RSA,\n\t\t\t\tPKT_BIGNUM, s->key.modulus, PKT_END);\n\t\t    crWaitUntil(pktin);\n\t\t    if (pktin->type != SSH1_SMSG_AUTH_RSA_CHALLENGE) {\n\t\t\tlogevent(\"Key refused\");\n\t\t\tcontinue;\n\t\t    }\n\t\t    logevent(\"Received RSA challenge\");\n\t\t    if ((s->challenge = ssh1_pkt_getmp(pktin)) == NULL) {\n\t\t\tbombout((\"Server's RSA challenge was badly formatted\"));\n\t\t\tcrStop(0);\n\t\t    }\n\n\t\t    {\n\t\t\tchar *agentreq, *q, *ret;\n\t\t\tvoid *vret;\n\t\t\tint len, retlen;\n\t\t\tlen = 1 + 4;   /* message type, bit count */\n\t\t\tlen += ssh1_bignum_length(s->key.exponent);\n\t\t\tlen += ssh1_bignum_length(s->key.modulus);\n\t\t\tlen += ssh1_bignum_length(s->challenge);\n\t\t\tlen += 16;     /* session id */\n\t\t\tlen += 4;      /* response format */\n\t\t\tagentreq = snewn(4 + len, char);\n\t\t\tPUT_32BIT(agentreq, len);\n\t\t\tq = agentreq + 4;\n\t\t\t*q++ = SSH1_AGENTC_RSA_CHALLENGE;\n\t\t\tPUT_32BIT(q, bignum_bitcount(s->key.modulus));\n\t\t\tq += 4;\n\t\t\tq += ssh1_write_bignum(q, s->key.exponent);\n\t\t\tq += ssh1_write_bignum(q, s->key.modulus);\n\t\t\tq += ssh1_write_bignum(q, s->challenge);\n\t\t\tmemcpy(q, s->session_id, 16);\n\t\t\tq += 16;\n\t\t\tPUT_32BIT(q, 1);\t/* response format */\n                        ssh->auth_agent_query = agent_query(\n                            agentreq, len + 4, &vret, &retlen,\n                            ssh_agent_callback, ssh);\n\t\t\tif (ssh->auth_agent_query) {\n\t\t\t    sfree(agentreq);\n\t\t\t    do {\n\t\t\t\tcrReturn(0);\n\t\t\t\tif (pktin) {\n\t\t\t\t    bombout((\"Unexpected data from server\"\n\t\t\t\t\t     \" while waiting for agent\"\n\t\t\t\t\t     \" response\"));\n\t\t\t\t    crStop(0);\n\t\t\t\t}\n\t\t\t    } while (pktin || inlen > 0);\n\t\t\t    vret = ssh->agent_response;\n\t\t\t    retlen = ssh->agent_response_len;\n\t\t\t} else\n\t\t\t    sfree(agentreq);\n\t\t\tret = vret;\n\t\t\tif (ret) {\n\t\t\t    if (ret[4] == SSH1_AGENT_RSA_RESPONSE) {\n\t\t\t\tlogevent(\"Sending Pageant's response\");\n\t\t\t\tsend_packet(ssh, SSH1_CMSG_AUTH_RSA_RESPONSE,\n\t\t\t\t\t    PKT_DATA, ret + 5, 16,\n\t\t\t\t\t    PKT_END);\n\t\t\t\tsfree(ret);\n\t\t\t\tcrWaitUntil(pktin);\n\t\t\t\tif (pktin->type == SSH1_SMSG_SUCCESS) {\n\t\t\t\t    logevent\n\t\t\t\t\t(\"Pageant's response accepted\");\n\t\t\t\t    if (flags & FLAG_VERBOSE) {\n\t\t\t\t\tc_write_str(ssh, \"Authenticated using\"\n\t\t\t\t\t\t    \" RSA key \\\"\");\n\t\t\t\t\tc_write(ssh, s->commentp,\n\t\t\t\t\t\ts->commentlen);\n\t\t\t\t\tc_write_str(ssh, \"\\\" from agent\\r\\n\");\n\t\t\t\t    }\n\t\t\t\t    s->authed = TRUE;\n\t\t\t\t} else\n\t\t\t\t    logevent\n\t\t\t\t\t(\"Pageant's response not accepted\");\n\t\t\t    } else {\n\t\t\t\tlogevent\n\t\t\t\t    (\"Pageant failed to answer challenge\");\n\t\t\t\tsfree(ret);\n\t\t\t    }\n\t\t\t} else {\n\t\t\t    logevent(\"No reply received from Pageant\");\n\t\t\t}\n\t\t    }\n\t\t    freebn(s->key.exponent);\n\t\t    freebn(s->key.modulus);\n\t\t    freebn(s->challenge);\n\t\t    if (s->authed)\n\t\t\tbreak;\n\t\t}\n\t\tsfree(s->response);\n\t\tif (s->publickey_blob && !s->tried_publickey)\n\t\t    logevent(\"Configured key file not in Pageant\");\n\t    } else {\n                logevent(\"Failed to get reply from Pageant\");\n            }\n\t    if (s->authed)\n\t\tbreak;\n\t}\n\tif (s->publickey_blob && s->privatekey_available &&\n            !s->tried_publickey) {\n\t    /*\n\t     * Try public key authentication with the specified\n\t     * key file.\n\t     */\n\t    int got_passphrase; /* need not be kept over crReturn */\n\t    if (flags & FLAG_VERBOSE)\n\t\tc_write_str(ssh, \"Trying public key authentication.\\r\\n\");\n\t    s->keyfile = conf_get_filename(ssh->conf, CONF_keyfile);\n\t    logeventf(ssh, \"Trying public key \\\"%s\\\"\",\n\t\t      filename_to_str(s->keyfile));\n\t    s->tried_publickey = 1;\n\t    got_passphrase = FALSE;\n\t    while (!got_passphrase) {\n\t\t/*\n\t\t * Get a passphrase, if necessary.\n\t\t */\n\t\tchar *passphrase = NULL;    /* only written after crReturn */\n\t\tconst char *error;\n\t\tif (!s->privatekey_encrypted) {\n\t\t    if (flags & FLAG_VERBOSE)\n\t\t\tc_write_str(ssh, \"No passphrase required.\\r\\n\");\n\t\t    passphrase = NULL;\n\t\t} else {\n\t\t    int ret; /* need not be kept over crReturn */\n\t\t    s->cur_prompt = new_prompts(ssh->frontend);\n\t\t    s->cur_prompt->to_server = FALSE;\n\t\t    s->cur_prompt->name = dupstr(\"SSH key passphrase\");\n\t\t    add_prompt(s->cur_prompt,\n\t\t\t       dupprintf(\"Passphrase for key \\\"%.100s\\\": \",\n\t\t\t\t\t s->publickey_comment), FALSE);\n\t\t    ret = get_userpass_input(s->cur_prompt, NULL, 0);\n\t\t    while (ret < 0) {\n\t\t\tssh->send_ok = 1;\n\t\t\tcrWaitUntil(!pktin);\n\t\t\tret = get_userpass_input(s->cur_prompt, in, inlen);\n\t\t\tssh->send_ok = 0;\n\t\t    }\n\t\t    if (!ret) {\n\t\t\t/* Failed to get a passphrase. Terminate. */\n\t\t\tfree_prompts(s->cur_prompt);\n\t\t\tssh_disconnect(ssh, NULL, \"Unable to authenticate\",\n\t\t\t\t       0, TRUE);\n\t\t\tcrStop(0);\n\t\t    }\n\t\t    passphrase = dupstr(s->cur_prompt->prompts[0]->result);\n\t\t    free_prompts(s->cur_prompt);\n\t\t}\n\t\t/*\n\t\t * Try decrypting key with passphrase.\n\t\t */\n\t\ts->keyfile = conf_get_filename(ssh->conf, CONF_keyfile);\n\t\tret = loadrsakey(s->keyfile, &s->key, passphrase,\n\t\t\t\t &error);\n\t\tif (passphrase) {\n\t\t    smemclr(passphrase, strlen(passphrase));\n\t\t    sfree(passphrase);\n\t\t}\n\t\tif (ret == 1) {\n\t\t    /* Correct passphrase. */\n\t\t    got_passphrase = TRUE;\n\t\t} else if (ret == 0) {\n\t\t    c_write_str(ssh, \"Couldn't load private key from \");\n\t\t    c_write_str(ssh, filename_to_str(s->keyfile));\n\t\t    c_write_str(ssh, \" (\");\n\t\t    c_write_str(ssh, error);\n\t\t    c_write_str(ssh, \").\\r\\n\");\n\t\t    got_passphrase = FALSE;\n\t\t    break;\t       /* go and try something else */\n\t\t} else if (ret == -1) {\n\t\t    c_write_str(ssh, \"Wrong passphrase.\\r\\n\"); /* FIXME */\n\t\t    got_passphrase = FALSE;\n\t\t    /* and try again */\n\t\t} else {\n\t\t    assert(0 && \"unexpected return from loadrsakey()\");\n\t\t    got_passphrase = FALSE;   /* placate optimisers */\n\t\t}\n\t    }\n\n\t    if (got_passphrase) {\n\n\t\t/*\n\t\t * Send a public key attempt.\n\t\t */\n\t\tsend_packet(ssh, SSH1_CMSG_AUTH_RSA,\n\t\t\t    PKT_BIGNUM, s->key.modulus, PKT_END);\n\n\t\tcrWaitUntil(pktin);\n\t\tif (pktin->type == SSH1_SMSG_FAILURE) {\n\t\t    c_write_str(ssh, \"Server refused our public key.\\r\\n\");\n\t\t    continue;\t       /* go and try something else */\n\t\t}\n\t\tif (pktin->type != SSH1_SMSG_AUTH_RSA_CHALLENGE) {\n\t\t    bombout((\"Bizarre response to offer of public key\"));\n\t\t    crStop(0);\n\t\t}\n\n\t\t{\n\t\t    int i;\n\t\t    unsigned char buffer[32];\n\t\t    Bignum challenge, response;\n\n\t\t    if ((challenge = ssh1_pkt_getmp(pktin)) == NULL) {\n\t\t\tbombout((\"Server's RSA challenge was badly formatted\"));\n\t\t\tcrStop(0);\n\t\t    }\n\t\t    response = rsadecrypt(challenge, &s->key);\n\t\t    freebn(s->key.private_exponent);/* burn the evidence */\n\n\t\t    for (i = 0; i < 32; i++) {\n\t\t\tbuffer[i] = bignum_byte(response, 31 - i);\n\t\t    }\n\n\t\t    MD5Init(&md5c);\n\t\t    MD5Update(&md5c, buffer, 32);\n\t\t    MD5Update(&md5c, s->session_id, 16);\n\t\t    MD5Final(buffer, &md5c);\n\n\t\t    send_packet(ssh, SSH1_CMSG_AUTH_RSA_RESPONSE,\n\t\t\t\tPKT_DATA, buffer, 16, PKT_END);\n\n\t\t    freebn(challenge);\n\t\t    freebn(response);\n\t\t}\n\n\t\tcrWaitUntil(pktin);\n\t\tif (pktin->type == SSH1_SMSG_FAILURE) {\n\t\t    if (flags & FLAG_VERBOSE)\n\t\t\tc_write_str(ssh, \"Failed to authenticate with\"\n\t\t\t\t    \" our public key.\\r\\n\");\n\t\t    continue;\t       /* go and try something else */\n\t\t} else if (pktin->type != SSH1_SMSG_SUCCESS) {\n\t\t    bombout((\"Bizarre response to RSA authentication response\"));\n\t\t    crStop(0);\n\t\t}\n\n\t\tbreak;\t\t       /* we're through! */\n\t    }\n\n\t}\n\n\t/*\n\t * Otherwise, try various forms of password-like authentication.\n\t */\n\ts->cur_prompt = new_prompts(ssh->frontend);\n\n\tif (conf_get_int(ssh->conf, CONF_try_tis_auth) &&\n\t    (s->supported_auths_mask & (1 << SSH1_AUTH_TIS)) &&\n\t    !s->tis_auth_refused) {\n\t    s->pwpkt_type = SSH1_CMSG_AUTH_TIS_RESPONSE;\n\t    logevent(\"Requested TIS authentication\");\n\t    send_packet(ssh, SSH1_CMSG_AUTH_TIS, PKT_END);\n\t    crWaitUntil(pktin);\n\t    if (pktin->type != SSH1_SMSG_AUTH_TIS_CHALLENGE) {\n\t\tlogevent(\"TIS authentication declined\");\n\t\tif (flags & FLAG_INTERACTIVE)\n\t\t    c_write_str(ssh, \"TIS authentication refused.\\r\\n\");\n\t\ts->tis_auth_refused = 1;\n\t\tcontinue;\n\t    } else {\n\t\tchar *challenge;\n\t\tint challengelen;\n\t\tchar *instr_suf, *prompt;\n\n\t\tssh_pkt_getstring(pktin, &challenge, &challengelen);\n\t\tif (!challenge) {\n\t\t    bombout((\"TIS challenge packet was badly formed\"));\n\t\t    crStop(0);\n\t\t}\n\t\tlogevent(\"Received TIS challenge\");\n\t\ts->cur_prompt->to_server = TRUE;\n\t\ts->cur_prompt->name = dupstr(\"SSH TIS authentication\");\n\t\t/* Prompt heuristic comes from OpenSSH */\n\t\tif (memchr(challenge, '\\n', challengelen)) {\n\t\t    instr_suf = dupstr(\"\");\n\t\t    prompt = dupprintf(\"%.*s\", challengelen, challenge);\n\t\t} else {\n\t\t    instr_suf = dupprintf(\"%.*s\", challengelen, challenge);\n\t\t    prompt = dupstr(\"Response: \");\n\t\t}\n\t\ts->cur_prompt->instruction =\n\t\t    dupprintf(\"Using TIS authentication.%s%s\",\n\t\t\t      (*instr_suf) ? \"\\n\" : \"\",\n\t\t\t      instr_suf);\n\t\ts->cur_prompt->instr_reqd = TRUE;\n\t\tadd_prompt(s->cur_prompt, prompt, FALSE);\n\t\tsfree(instr_suf);\n\t    }\n\t}\n\tif (conf_get_int(ssh->conf, CONF_try_tis_auth) &&\n\t    (s->supported_auths_mask & (1 << SSH1_AUTH_CCARD)) &&\n\t    !s->ccard_auth_refused) {\n\t    s->pwpkt_type = SSH1_CMSG_AUTH_CCARD_RESPONSE;\n\t    logevent(\"Requested CryptoCard authentication\");\n\t    send_packet(ssh, SSH1_CMSG_AUTH_CCARD, PKT_END);\n\t    crWaitUntil(pktin);\n\t    if (pktin->type != SSH1_SMSG_AUTH_CCARD_CHALLENGE) {\n\t\tlogevent(\"CryptoCard authentication declined\");\n\t\tc_write_str(ssh, \"CryptoCard authentication refused.\\r\\n\");\n\t\ts->ccard_auth_refused = 1;\n\t\tcontinue;\n\t    } else {\n\t\tchar *challenge;\n\t\tint challengelen;\n\t\tchar *instr_suf, *prompt;\n\n\t\tssh_pkt_getstring(pktin, &challenge, &challengelen);\n\t\tif (!challenge) {\n\t\t    bombout((\"CryptoCard challenge packet was badly formed\"));\n\t\t    crStop(0);\n\t\t}\n\t\tlogevent(\"Received CryptoCard challenge\");\n\t\ts->cur_prompt->to_server = TRUE;\n\t\ts->cur_prompt->name = dupstr(\"SSH CryptoCard authentication\");\n\t\ts->cur_prompt->name_reqd = FALSE;\n\t\t/* Prompt heuristic comes from OpenSSH */\n\t\tif (memchr(challenge, '\\n', challengelen)) {\n\t\t    instr_suf = dupstr(\"\");\n\t\t    prompt = dupprintf(\"%.*s\", challengelen, challenge);\n\t\t} else {\n\t\t    instr_suf = dupprintf(\"%.*s\", challengelen, challenge);\n\t\t    prompt = dupstr(\"Response: \");\n\t\t}\n\t\ts->cur_prompt->instruction =\n\t\t    dupprintf(\"Using CryptoCard authentication.%s%s\",\n\t\t\t      (*instr_suf) ? \"\\n\" : \"\",\n\t\t\t      instr_suf);\n\t\ts->cur_prompt->instr_reqd = TRUE;\n\t\tadd_prompt(s->cur_prompt, prompt, FALSE);\n\t\tsfree(instr_suf);\n\t    }\n\t}\n\tif (s->pwpkt_type == SSH1_CMSG_AUTH_PASSWORD) {\n\t    if ((s->supported_auths_mask & (1 << SSH1_AUTH_PASSWORD)) == 0) {\n\t\tbombout((\"No supported authentication methods available\"));\n\t\tcrStop(0);\n\t    }\n\t    s->cur_prompt->to_server = TRUE;\n\t    s->cur_prompt->name = dupstr(\"SSH password\");\n\t    add_prompt(s->cur_prompt, dupprintf(\"%s@%s's password: \",\n\t\t\t\t\t\tssh->username, ssh->savedhost),\n\t\t       FALSE);\n\t}\n\n\t/*\n\t * Show password prompt, having first obtained it via a TIS\n\t * or CryptoCard exchange if we're doing TIS or CryptoCard\n\t * authentication.\n\t */\n\t{\n\t    int ret; /* need not be kept over crReturn */\n\t    ret = get_userpass_input(s->cur_prompt, NULL, 0);\n\t    while (ret < 0) {\n\t\tssh->send_ok = 1;\n\t\tcrWaitUntil(!pktin);\n\t\tret = get_userpass_input(s->cur_prompt, in, inlen);\n\t\tssh->send_ok = 0;\n\t    }\n\t    if (!ret) {\n\t\t/*\n\t\t * Failed to get a password (for example\n\t\t * because one was supplied on the command line\n\t\t * which has already failed to work). Terminate.\n\t\t */\n\t\tfree_prompts(s->cur_prompt);\n\t\tssh_disconnect(ssh, NULL, \"Unable to authenticate\", 0, TRUE);\n\t\tcrStop(0);\n\t    }\n\t}\n\n\tif (s->pwpkt_type == SSH1_CMSG_AUTH_PASSWORD) {\n\t    /*\n\t     * Defence against traffic analysis: we send a\n\t     * whole bunch of packets containing strings of\n\t     * different lengths. One of these strings is the\n\t     * password, in a SSH1_CMSG_AUTH_PASSWORD packet.\n\t     * The others are all random data in\n\t     * SSH1_MSG_IGNORE packets. This way a passive\n\t     * listener can't tell which is the password, and\n\t     * hence can't deduce the password length.\n\t     * \n\t     * Anybody with a password length greater than 16\n\t     * bytes is going to have enough entropy in their\n\t     * password that a listener won't find it _that_\n\t     * much help to know how long it is. So what we'll\n\t     * do is:\n\t     * \n\t     *  - if password length < 16, we send 15 packets\n\t     *    containing string lengths 1 through 15\n\t     * \n\t     *  - otherwise, we let N be the nearest multiple\n\t     *    of 8 below the password length, and send 8\n\t     *    packets containing string lengths N through\n\t     *    N+7. This won't obscure the order of\n\t     *    magnitude of the password length, but it will\n\t     *    introduce a bit of extra uncertainty.\n\t     * \n\t     * A few servers can't deal with SSH1_MSG_IGNORE, at\n\t     * least in this context. For these servers, we need\n\t     * an alternative defence. We make use of the fact\n\t     * that the password is interpreted as a C string:\n\t     * so we can append a NUL, then some random data.\n\t     * \n\t     * A few servers can deal with neither SSH1_MSG_IGNORE\n\t     * here _nor_ a padded password string.\n\t     * For these servers we are left with no defences\n\t     * against password length sniffing.\n\t     */\n\t    if (!(ssh->remote_bugs & BUG_CHOKES_ON_SSH1_IGNORE) &&\n\t        !(ssh->remote_bugs & BUG_NEEDS_SSH1_PLAIN_PASSWORD)) {\n\t\t/*\n\t\t * The server can deal with SSH1_MSG_IGNORE, so\n\t\t * we can use the primary defence.\n\t\t */\n\t\tint bottom, top, pwlen, i;\n\t\tchar *randomstr;\n\n\t\tpwlen = strlen(s->cur_prompt->prompts[0]->result);\n\t\tif (pwlen < 16) {\n\t\t    bottom = 0;    /* zero length passwords are OK! :-) */\n\t\t    top = 15;\n\t\t} else {\n\t\t    bottom = pwlen & ~7;\n\t\t    top = bottom + 7;\n\t\t}\n\n\t\tassert(pwlen >= bottom && pwlen <= top);\n\n\t\trandomstr = snewn(top + 1, char);\n\n\t\tfor (i = bottom; i <= top; i++) {\n\t\t    if (i == pwlen) {\n\t\t\tdefer_packet(ssh, s->pwpkt_type,\n                                     PKT_STR,s->cur_prompt->prompts[0]->result,\n\t\t\t\t     PKT_END);\n\t\t    } else {\n\t\t\tfor (j = 0; j < i; j++) {\n\t\t\t    do {\n\t\t\t\trandomstr[j] = random_byte();\n\t\t\t    } while (randomstr[j] == '\\0');\n\t\t\t}\n\t\t\trandomstr[i] = '\\0';\n\t\t\tdefer_packet(ssh, SSH1_MSG_IGNORE,\n\t\t\t\t     PKT_STR, randomstr, PKT_END);\n\t\t    }\n\t\t}\n\t\tlogevent(\"Sending password with camouflage packets\");\n\t\tssh_pkt_defersend(ssh);\n\t\tsfree(randomstr);\n\t    } \n\t    else if (!(ssh->remote_bugs & BUG_NEEDS_SSH1_PLAIN_PASSWORD)) {\n\t\t/*\n\t\t * The server can't deal with SSH1_MSG_IGNORE\n\t\t * but can deal with padded passwords, so we\n\t\t * can use the secondary defence.\n\t\t */\n\t\tchar string[64];\n\t\tchar *ss;\n\t\tint len;\n\n\t\tlen = strlen(s->cur_prompt->prompts[0]->result);\n\t\tif (len < sizeof(string)) {\n\t\t    ss = string;\n\t\t    strcpy(string, s->cur_prompt->prompts[0]->result);\n\t\t    len++;\t       /* cover the zero byte */\n\t\t    while (len < sizeof(string)) {\n\t\t\tstring[len++] = (char) random_byte();\n\t\t    }\n\t\t} else {\n\t\t    ss = s->cur_prompt->prompts[0]->result;\n\t\t}\n\t\tlogevent(\"Sending length-padded password\");\n\t\tsend_packet(ssh, s->pwpkt_type,\n\t\t\t    PKT_INT, len, PKT_DATA, ss, len,\n\t\t\t    PKT_END);\n\t    } else {\n\t\t/*\n\t\t * The server is believed unable to cope with\n\t\t * any of our password camouflage methods.\n\t\t */\n\t\tint len;\n\t\tlen = strlen(s->cur_prompt->prompts[0]->result);\n\t\tlogevent(\"Sending unpadded password\");\n\t\tsend_packet(ssh, s->pwpkt_type,\n                            PKT_INT, len,\n\t\t\t    PKT_DATA, s->cur_prompt->prompts[0]->result, len,\n\t\t\t    PKT_END);\n\t    }\n\t} else {\n\t    send_packet(ssh, s->pwpkt_type,\n\t\t\tPKT_STR, s->cur_prompt->prompts[0]->result,\n\t\t\tPKT_END);\n\t}\n\tlogevent(\"Sent password\");\n\tfree_prompts(s->cur_prompt);\n\tcrWaitUntil(pktin);\n\tif (pktin->type == SSH1_SMSG_FAILURE) {\n\t    if (flags & FLAG_VERBOSE)\n\t\tc_write_str(ssh, \"Access denied\\r\\n\");\n\t    logevent(\"Authentication refused\");\n\t} else if (pktin->type != SSH1_SMSG_SUCCESS) {\n\t    bombout((\"Strange packet received, type %d\", pktin->type));\n\t    crStop(0);\n\t}\n    }\n\n    /* Clear up */\n    if (s->publickey_blob) {\n\tsfree(s->publickey_blob);\n\tsfree(s->publickey_comment);\n    }\n\n    logevent(\"Authentication successful\");\n\n    crFinish(1);\n}\n\nstatic void ssh_channel_try_eof(struct ssh_channel *c)\n{\n    Ssh ssh = c->ssh;\n    assert(c->pending_eof);          /* precondition for calling us */\n    if (c->halfopen)\n        return;                 /* can't close: not even opened yet */\n    if (ssh->version == 2 && bufchain_size(&c->v.v2.outbuffer) > 0)\n        return;              /* can't send EOF: pending outgoing data */\n\n    c->pending_eof = FALSE;            /* we're about to send it */\n    if (ssh->version == 1) {\n        send_packet(ssh, SSH1_MSG_CHANNEL_CLOSE, PKT_INT, c->remoteid,\n                    PKT_END);\n        c->closes |= CLOSES_SENT_EOF;\n    } else {\n        struct Packet *pktout;\n        pktout = ssh2_pkt_init(SSH2_MSG_CHANNEL_EOF);\n        ssh2_pkt_adduint32(pktout, c->remoteid);\n        ssh2_pkt_send(ssh, pktout);\n        c->closes |= CLOSES_SENT_EOF;\n\tssh2_channel_check_close(c);\n    }\n}\n\nConf *sshfwd_get_conf(struct ssh_channel *c)\n{\n    Ssh ssh = c->ssh;\n    return ssh->conf;\n}\n\nvoid sshfwd_write_eof(struct ssh_channel *c)\n{\n    Ssh ssh = c->ssh;\n\n    if (ssh->state == SSH_STATE_CLOSED)\n\treturn;\n\n    if (c->closes & CLOSES_SENT_EOF)\n        return;\n\n    c->pending_eof = TRUE;\n    ssh_channel_try_eof(c);\n}\n\nvoid sshfwd_unclean_close(struct ssh_channel *c, const char *err)\n{\n    Ssh ssh = c->ssh;\n    char *reason;\n\n    if (ssh->state == SSH_STATE_CLOSED)\n\treturn;\n\n    reason = dupprintf(\"due to local error: %s\", err);\n    ssh_channel_close_local(c, reason);\n    sfree(reason);\n    c->pending_eof = FALSE;   /* this will confuse a zombie channel */\n\n    ssh2_channel_check_close(c);\n}\n\nint sshfwd_write(struct ssh_channel *c, char *buf, int len)\n{\n    Ssh ssh = c->ssh;\n\n    if (ssh->state == SSH_STATE_CLOSED)\n\treturn 0;\n\n    return ssh_send_channel_data(c, buf, len);\n}\n\nvoid sshfwd_unthrottle(struct ssh_channel *c, int bufsize)\n{\n    Ssh ssh = c->ssh;\n\n    if (ssh->state == SSH_STATE_CLOSED)\n\treturn;\n\n    ssh_channel_unthrottle(c, bufsize);\n}\n\nstatic void ssh_queueing_handler(Ssh ssh, struct Packet *pktin)\n{\n    struct queued_handler *qh = ssh->qhead;\n\n    assert(qh != NULL);\n\n    assert(pktin->type == qh->msg1 || pktin->type == qh->msg2);\n\n    if (qh->msg1 > 0) {\n\tassert(ssh->packet_dispatch[qh->msg1] == ssh_queueing_handler);\n\tssh->packet_dispatch[qh->msg1] = ssh->q_saved_handler1;\n    }\n    if (qh->msg2 > 0) {\n\tassert(ssh->packet_dispatch[qh->msg2] == ssh_queueing_handler);\n\tssh->packet_dispatch[qh->msg2] = ssh->q_saved_handler2;\n    }\n\n    if (qh->next) {\n\tssh->qhead = qh->next;\n\n\tif (ssh->qhead->msg1 > 0) {\n\t    ssh->q_saved_handler1 = ssh->packet_dispatch[ssh->qhead->msg1];\n\t    ssh->packet_dispatch[ssh->qhead->msg1] = ssh_queueing_handler;\n\t}\n\tif (ssh->qhead->msg2 > 0) {\n\t    ssh->q_saved_handler2 = ssh->packet_dispatch[ssh->qhead->msg2];\n\t    ssh->packet_dispatch[ssh->qhead->msg2] = ssh_queueing_handler;\n\t}\n    } else {\n\tssh->qhead = ssh->qtail = NULL;\n    }\n\n    qh->handler(ssh, pktin, qh->ctx);\n\n    sfree(qh);\n}\n\nstatic void ssh_queue_handler(Ssh ssh, int msg1, int msg2,\n\t\t\t      chandler_fn_t handler, void *ctx)\n{\n    struct queued_handler *qh;\n\n    qh = snew(struct queued_handler);\n    qh->msg1 = msg1;\n    qh->msg2 = msg2;\n    qh->handler = handler;\n    qh->ctx = ctx;\n    qh->next = NULL;\n\n    if (ssh->qtail == NULL) {\n\tssh->qhead = qh;\n\n\tif (qh->msg1 > 0) {\n\t    ssh->q_saved_handler1 = ssh->packet_dispatch[ssh->qhead->msg1];\n\t    ssh->packet_dispatch[qh->msg1] = ssh_queueing_handler;\n\t}\n\tif (qh->msg2 > 0) {\n\t    ssh->q_saved_handler2 = ssh->packet_dispatch[ssh->qhead->msg2];\n\t    ssh->packet_dispatch[qh->msg2] = ssh_queueing_handler;\n\t}\n    } else {\n\tssh->qtail->next = qh;\n    }\n    ssh->qtail = qh;\n}\n\nstatic void ssh_rportfwd_succfail(Ssh ssh, struct Packet *pktin, void *ctx)\n{\n    struct ssh_rportfwd *rpf, *pf = (struct ssh_rportfwd *)ctx;\n\n    if (pktin->type == (ssh->version == 1 ? SSH1_SMSG_SUCCESS :\n\t\t\tSSH2_MSG_REQUEST_SUCCESS)) {\n\tlogeventf(ssh, \"Remote port forwarding from %s enabled\",\n\t\t  pf->sportdesc);\n    } else {\n\tlogeventf(ssh, \"Remote port forwarding from %s refused\",\n\t\t  pf->sportdesc);\n\n\trpf = del234(ssh->rportfwds, pf);\n\tassert(rpf == pf);\n\tpf->pfrec->remote = NULL;\n\tfree_rportfwd(pf);\n    }\n}\n\nint ssh_alloc_sharing_rportfwd(Ssh ssh, const char *shost, int sport,\n                               void *share_ctx)\n{\n    struct ssh_rportfwd *pf = snew(struct ssh_rportfwd);\n    pf->dhost = NULL;\n    pf->dport = 0;\n    pf->share_ctx = share_ctx;\n    pf->shost = dupstr(shost);\n    pf->sport = sport;\n    pf->sportdesc = NULL;\n    if (!ssh->rportfwds) {\n        assert(ssh->version == 2);\n        ssh->rportfwds = newtree234(ssh_rportcmp_ssh2);\n    }\n    if (add234(ssh->rportfwds, pf) != pf) {\n        sfree(pf->shost);\n        sfree(pf);\n        return FALSE;\n    }\n    return TRUE;\n}\n\nstatic void ssh_sharing_global_request_response(Ssh ssh, struct Packet *pktin,\n                                                void *ctx)\n{\n    share_got_pkt_from_server(ctx, pktin->type,\n                              pktin->body, pktin->length);\n}\n\nvoid ssh_sharing_queue_global_request(Ssh ssh, void *share_ctx)\n{\n    ssh_queue_handler(ssh, SSH2_MSG_REQUEST_SUCCESS, SSH2_MSG_REQUEST_FAILURE,\n                      ssh_sharing_global_request_response, share_ctx);\n}\n\nstatic void ssh_setup_portfwd(Ssh ssh, Conf *conf)\n{\n    struct ssh_portfwd *epf;\n    int i;\n    char *key, *val;\n\n    if (!ssh->portfwds) {\n\tssh->portfwds = newtree234(ssh_portcmp);\n    } else {\n\t/*\n\t * Go through the existing port forwardings and tag them\n\t * with status==DESTROY. Any that we want to keep will be\n\t * re-enabled (status==KEEP) as we go through the\n\t * configuration and find out which bits are the same as\n\t * they were before.\n\t */\n\tstruct ssh_portfwd *epf;\n\tint i;\n\tfor (i = 0; (epf = index234(ssh->portfwds, i)) != NULL; i++)\n\t    epf->status = DESTROY;\n    }\n\n    for (val = conf_get_str_strs(conf, CONF_portfwd, NULL, &key);\n\t val != NULL;\n\t val = conf_get_str_strs(conf, CONF_portfwd, key, &key)) {\n\tchar *kp, *kp2, *vp, *vp2;\n\tchar address_family, type;\n\tint sport,dport,sserv,dserv;\n\tchar *sports, *dports, *saddr, *host;\n\n\tkp = key;\n\n\taddress_family = 'A';\n\ttype = 'L';\n\tif (*kp == 'A' || *kp == '4' || *kp == '6')\n\t    address_family = *kp++;\n\tif (*kp == 'L' || *kp == 'R')\n\t    type = *kp++;\n\n\tif ((kp2 = host_strchr(kp, ':')) != NULL) {\n\t    /*\n\t     * There's a colon in the middle of the source port\n\t     * string, which means that the part before it is\n\t     * actually a source address.\n\t     */\n\t    char *saddr_tmp = dupprintf(\"%.*s\", (int)(kp2 - kp), kp);\n            saddr = host_strduptrim(saddr_tmp);\n            sfree(saddr_tmp);\n\t    sports = kp2+1;\n\t} else {\n\t    saddr = NULL;\n\t    sports = kp;\n\t}\n\tsport = atoi(sports);\n\tsserv = 0;\n\tif (sport == 0) {\n\t    sserv = 1;\n\t    sport = net_service_lookup(sports);\n\t    if (!sport) {\n\t\tlogeventf(ssh, \"Service lookup failed for source\"\n\t\t\t  \" port \\\"%s\\\"\", sports);\n\t    }\n\t}\n\n\tif (type == 'L' && !strcmp(val, \"D\")) {\n            /* dynamic forwarding */\n\t    host = NULL;\n\t    dports = NULL;\n\t    dport = -1;\n\t    dserv = 0;\n            type = 'D';\n        } else {\n            /* ordinary forwarding */\n\t    vp = val;\n\t    vp2 = vp + host_strcspn(vp, \":\");\n\t    host = dupprintf(\"%.*s\", (int)(vp2 - vp), vp);\n\t    if (*vp2)\n\t\tvp2++;\n\t    dports = vp2;\n\t    dport = atoi(dports);\n\t    dserv = 0;\n\t    if (dport == 0) {\n\t\tdserv = 1;\n\t\tdport = net_service_lookup(dports);\n\t\tif (!dport) {\n\t\t    logeventf(ssh, \"Service lookup failed for destination\"\n\t\t\t      \" port \\\"%s\\\"\", dports);\n\t\t}\n\t    }\n\t}\n\n\tif (sport && dport) {\n\t    /* Set up a description of the source port. */\n\t    struct ssh_portfwd *pfrec, *epfrec;\n\n\t    pfrec = snew(struct ssh_portfwd);\n\t    pfrec->type = type;\n\t    pfrec->saddr = saddr;\n\t    pfrec->sserv = sserv ? dupstr(sports) : NULL;\n\t    pfrec->sport = sport;\n\t    pfrec->daddr = host;\n\t    pfrec->dserv = dserv ? dupstr(dports) : NULL;\n\t    pfrec->dport = dport;\n\t    pfrec->local = NULL;\n\t    pfrec->remote = NULL;\n\t    pfrec->addressfamily = (address_family == '4' ? ADDRTYPE_IPV4 :\n\t\t\t\t    address_family == '6' ? ADDRTYPE_IPV6 :\n\t\t\t\t    ADDRTYPE_UNSPEC);\n\n\t    epfrec = add234(ssh->portfwds, pfrec);\n\t    if (epfrec != pfrec) {\n\t\tif (epfrec->status == DESTROY) {\n\t\t    /*\n\t\t     * We already have a port forwarding up and running\n\t\t     * with precisely these parameters. Hence, no need\n\t\t     * to do anything; simply re-tag the existing one\n\t\t     * as KEEP.\n\t\t     */\n\t\t    epfrec->status = KEEP;\n\t\t}\n\t\t/*\n\t\t * Anything else indicates that there was a duplicate\n\t\t * in our input, which we'll silently ignore.\n\t\t */\n\t\tfree_portfwd(pfrec);\n\t    } else {\n\t\tpfrec->status = CREATE;\n\t    }\n\t} else {\n\t    sfree(saddr);\n\t    sfree(host);\n\t}\n    }\n\n    /*\n     * Now go through and destroy any port forwardings which were\n     * not re-enabled.\n     */\n    for (i = 0; (epf = index234(ssh->portfwds, i)) != NULL; i++)\n\tif (epf->status == DESTROY) {\n\t    char *message;\n\n\t    message = dupprintf(\"%s port forwarding from %s%s%d\",\n\t\t\t\tepf->type == 'L' ? \"local\" :\n\t\t\t\tepf->type == 'R' ? \"remote\" : \"dynamic\",\n\t\t\t\tepf->saddr ? epf->saddr : \"\",\n\t\t\t\tepf->saddr ? \":\" : \"\",\n\t\t\t\tepf->sport);\n\n\t    if (epf->type != 'D') {\n\t\tchar *msg2 = dupprintf(\"%s to %s:%d\", message,\n\t\t\t\t       epf->daddr, epf->dport);\n\t\tsfree(message);\n\t\tmessage = msg2;\n\t    }\n\n\t    logeventf(ssh, \"Cancelling %s\", message);\n\t    sfree(message);\n\n\t    /* epf->remote or epf->local may be NULL if setting up a\n\t     * forwarding failed. */\n\t    if (epf->remote) {\n\t\tstruct ssh_rportfwd *rpf = epf->remote;\n\t\tstruct Packet *pktout;\n\n\t\t/*\n\t\t * Cancel the port forwarding at the server\n\t\t * end.\n\t\t */\n\t\tif (ssh->version == 1) {\n\t\t    /*\n\t\t     * We cannot cancel listening ports on the\n\t\t     * server side in SSH-1! There's no message\n\t\t     * to support it. Instead, we simply remove\n\t\t     * the rportfwd record from the local end\n\t\t     * so that any connections the server tries\n\t\t     * to make on it are rejected.\n\t\t     */\n\t\t} else {\n\t\t    pktout = ssh2_pkt_init(SSH2_MSG_GLOBAL_REQUEST);\n\t\t    ssh2_pkt_addstring(pktout, \"cancel-tcpip-forward\");\n\t\t    ssh2_pkt_addbool(pktout, 0);/* _don't_ want reply */\n\t\t    if (epf->saddr) {\n\t\t\tssh2_pkt_addstring(pktout, epf->saddr);\n\t\t    } else if (conf_get_int(conf, CONF_rport_acceptall)) {\n\t\t\t/* XXX: rport_acceptall may not represent\n\t\t\t * what was used to open the original connection,\n\t\t\t * since it's reconfigurable. */\n\t\t\tssh2_pkt_addstring(pktout, \"\");\n\t\t    } else {\n\t\t\tssh2_pkt_addstring(pktout, \"localhost\");\n\t\t    }\n\t\t    ssh2_pkt_adduint32(pktout, epf->sport);\n\t\t    ssh2_pkt_send(ssh, pktout);\n\t\t}\n\n\t\tdel234(ssh->rportfwds, rpf);\n\t\tfree_rportfwd(rpf);\n\t    } else if (epf->local) {\n\t\tpfl_terminate(epf->local);\n\t    }\n\n\t    delpos234(ssh->portfwds, i);\n\t    free_portfwd(epf);\n\t    i--;\t\t       /* so we don't skip one in the list */\n\t}\n\n    /*\n     * And finally, set up any new port forwardings (status==CREATE).\n     */\n    for (i = 0; (epf = index234(ssh->portfwds, i)) != NULL; i++)\n\tif (epf->status == CREATE) {\n\t    char *sportdesc, *dportdesc;\n\t    sportdesc = dupprintf(\"%s%s%s%s%d%s\",\n\t\t\t\t  epf->saddr ? epf->saddr : \"\",\n\t\t\t\t  epf->saddr ? \":\" : \"\",\n\t\t\t\t  epf->sserv ? epf->sserv : \"\",\n\t\t\t\t  epf->sserv ? \"(\" : \"\",\n\t\t\t\t  epf->sport,\n\t\t\t\t  epf->sserv ? \")\" : \"\");\n\t    if (epf->type == 'D') {\n\t\tdportdesc = NULL;\n\t    } else {\n\t\tdportdesc = dupprintf(\"%s:%s%s%d%s\",\n\t\t\t\t      epf->daddr,\n\t\t\t\t      epf->dserv ? epf->dserv : \"\",\n\t\t\t\t      epf->dserv ? \"(\" : \"\",\n\t\t\t\t      epf->dport,\n\t\t\t\t      epf->dserv ? \")\" : \"\");\n\t    }\n\n\t    if (epf->type == 'L') {\n                char *err = pfl_listen(epf->daddr, epf->dport,\n                                       epf->saddr, epf->sport,\n                                       ssh, conf, &epf->local,\n                                       epf->addressfamily);\n\n\t\tlogeventf(ssh, \"Local %sport %s forwarding to %s%s%s\",\n\t\t\t  epf->addressfamily == ADDRTYPE_IPV4 ? \"IPv4 \" :\n\t\t\t  epf->addressfamily == ADDRTYPE_IPV6 ? \"IPv6 \" : \"\",\n\t\t\t  sportdesc, dportdesc,\n\t\t\t  err ? \" failed: \" : \"\", err ? err : \"\");\n                if (err)\n                    sfree(err);\n\t    } else if (epf->type == 'D') {\n\t\tchar *err = pfl_listen(NULL, -1, epf->saddr, epf->sport,\n                                       ssh, conf, &epf->local,\n                                       epf->addressfamily);\n\n\t\tlogeventf(ssh, \"Local %sport %s SOCKS dynamic forwarding%s%s\",\n\t\t\t  epf->addressfamily == ADDRTYPE_IPV4 ? \"IPv4 \" :\n\t\t\t  epf->addressfamily == ADDRTYPE_IPV6 ? \"IPv6 \" : \"\",\n\t\t\t  sportdesc,\n\t\t\t  err ? \" failed: \" : \"\", err ? err : \"\");\n\n                if (err)\n                    sfree(err);\n\t    } else {\n\t\tstruct ssh_rportfwd *pf;\n\n\t\t/*\n\t\t * Ensure the remote port forwardings tree exists.\n\t\t */\n\t\tif (!ssh->rportfwds) {\n\t\t    if (ssh->version == 1)\n\t\t\tssh->rportfwds = newtree234(ssh_rportcmp_ssh1);\n\t\t    else\n\t\t\tssh->rportfwds = newtree234(ssh_rportcmp_ssh2);\n\t\t}\n\n\t\tpf = snew(struct ssh_rportfwd);\n                pf->share_ctx = NULL;\n                pf->dhost = dupstr(epf->daddr);\n\t\tpf->dport = epf->dport;\n                if (epf->saddr) {\n                    pf->shost = dupstr(epf->saddr);\n                } else if (conf_get_int(conf, CONF_rport_acceptall)) {\n                    pf->shost = dupstr(\"\");\n                } else {\n                    pf->shost = dupstr(\"localhost\");\n                }\n\t\tpf->sport = epf->sport;\n\t\tif (add234(ssh->rportfwds, pf) != pf) {\n\t\t    logeventf(ssh, \"Duplicate remote port forwarding to %s:%d\",\n\t\t\t      epf->daddr, epf->dport);\n\t\t    sfree(pf);\n\t\t} else {\n\t\t    logeventf(ssh, \"Requesting remote port %s\"\n\t\t\t      \" forward to %s\", sportdesc, dportdesc);\n\n\t\t    pf->sportdesc = sportdesc;\n\t\t    sportdesc = NULL;\n\t\t    epf->remote = pf;\n\t\t    pf->pfrec = epf;\n\n\t\t    if (ssh->version == 1) {\n\t\t\tsend_packet(ssh, SSH1_CMSG_PORT_FORWARD_REQUEST,\n\t\t\t\t    PKT_INT, epf->sport,\n\t\t\t\t    PKT_STR, epf->daddr,\n\t\t\t\t    PKT_INT, epf->dport,\n\t\t\t\t    PKT_END);\n\t\t\tssh_queue_handler(ssh, SSH1_SMSG_SUCCESS,\n\t\t\t\t\t  SSH1_SMSG_FAILURE,\n\t\t\t\t\t  ssh_rportfwd_succfail, pf);\n\t\t    } else {\n\t\t\tstruct Packet *pktout;\n\t\t\tpktout = ssh2_pkt_init(SSH2_MSG_GLOBAL_REQUEST);\n\t\t\tssh2_pkt_addstring(pktout, \"tcpip-forward\");\n\t\t\tssh2_pkt_addbool(pktout, 1);/* want reply */\n\t\t\tssh2_pkt_addstring(pktout, pf->shost);\n\t\t\tssh2_pkt_adduint32(pktout, pf->sport);\n\t\t\tssh2_pkt_send(ssh, pktout);\n\n\t\t\tssh_queue_handler(ssh, SSH2_MSG_REQUEST_SUCCESS,\n\t\t\t\t\t  SSH2_MSG_REQUEST_FAILURE,\n\t\t\t\t\t  ssh_rportfwd_succfail, pf);\n\t\t    }\n\t\t}\n\t    }\n\t    sfree(sportdesc);\n\t    sfree(dportdesc);\n\t}\n}\n\nstatic void ssh1_smsg_stdout_stderr_data(Ssh ssh, struct Packet *pktin)\n{\n    char *string;\n    int stringlen, bufsize;\n\n    ssh_pkt_getstring(pktin, &string, &stringlen);\n    if (string == NULL) {\n\tbombout((\"Incoming terminal data packet was badly formed\"));\n\treturn;\n    }\n\n    bufsize = from_backend(ssh->frontend, pktin->type == SSH1_SMSG_STDERR_DATA,\n\t\t\t   string, stringlen);\n    if (!ssh->v1_stdout_throttling && bufsize > SSH1_BUFFER_LIMIT) {\n\tssh->v1_stdout_throttling = 1;\n\tssh_throttle_conn(ssh, +1);\n    }\n}\n\nstatic void ssh1_smsg_x11_open(Ssh ssh, struct Packet *pktin)\n{\n    /* Remote side is trying to open a channel to talk to our\n     * X-Server. Give them back a local channel number. */\n    struct ssh_channel *c;\n    int remoteid = ssh_pkt_getuint32(pktin);\n\n    logevent(\"Received X11 connect request\");\n    /* Refuse if X11 forwarding is disabled. */\n    if (!ssh->X11_fwd_enabled) {\n\tsend_packet(ssh, SSH1_MSG_CHANNEL_OPEN_FAILURE,\n\t\t    PKT_INT, remoteid, PKT_END);\n\tlogevent(\"Rejected X11 connect request\");\n    } else {\n\tc = snew(struct ssh_channel);\n\tc->ssh = ssh;\n\n\tssh_channel_init(c);\n\tc->u.x11.xconn = x11_init(ssh->x11authtree, c, NULL, -1);\n        c->remoteid = remoteid;\n        c->halfopen = FALSE;\n        c->type = CHAN_X11;\t/* identify channel type */\n        send_packet(ssh, SSH1_MSG_CHANNEL_OPEN_CONFIRMATION,\n                    PKT_INT, c->remoteid, PKT_INT,\n                    c->localid, PKT_END);\n        logevent(\"Opened X11 forward channel\");\n    }\n}\n\nstatic void ssh1_smsg_agent_open(Ssh ssh, struct Packet *pktin)\n{\n    /* Remote side is trying to open a channel to talk to our\n     * agent. Give them back a local channel number. */\n    struct ssh_channel *c;\n    int remoteid = ssh_pkt_getuint32(pktin);\n\n    /* Refuse if agent forwarding is disabled. */\n    if (!ssh->agentfwd_enabled) {\n\tsend_packet(ssh, SSH1_MSG_CHANNEL_OPEN_FAILURE,\n\t\t    PKT_INT, remoteid, PKT_END);\n    } else {\n\tc = snew(struct ssh_channel);\n\tc->ssh = ssh;\n\tssh_channel_init(c);\n\tc->remoteid = remoteid;\n\tc->halfopen = FALSE;\n\tc->type = CHAN_AGENT;\t/* identify channel type */\n\tc->u.a.lensofar = 0;\n\tc->u.a.message = NULL;\n\tc->u.a.pending = NULL;\n\tc->u.a.outstanding_requests = 0;\n\tsend_packet(ssh, SSH1_MSG_CHANNEL_OPEN_CONFIRMATION,\n\t\t    PKT_INT, c->remoteid, PKT_INT, c->localid,\n\t\t    PKT_END);\n    }\n}\n\nstatic void ssh1_msg_port_open(Ssh ssh, struct Packet *pktin)\n{\n    /* Remote side is trying to open a channel to talk to a\n     * forwarded port. Give them back a local channel number. */\n    struct ssh_rportfwd pf, *pfp;\n    int remoteid;\n    int hostsize, port;\n    char *host;\n    char *err;\n\n    remoteid = ssh_pkt_getuint32(pktin);\n    ssh_pkt_getstring(pktin, &host, &hostsize);\n    port = ssh_pkt_getuint32(pktin);\n\n    pf.dhost = dupprintf(\"%.*s\", hostsize, NULLTOEMPTY(host));\n    pf.dport = port;\n    pfp = find234(ssh->rportfwds, &pf, NULL);\n\n    if (pfp == NULL) {\n\tlogeventf(ssh, \"Rejected remote port open request for %s:%d\",\n\t\t  pf.dhost, port);\n\tsend_packet(ssh, SSH1_MSG_CHANNEL_OPEN_FAILURE,\n\t\t    PKT_INT, remoteid, PKT_END);\n    } else {\n        struct ssh_channel *c = snew(struct ssh_channel);\n        c->ssh = ssh;\n\n\tlogeventf(ssh, \"Received remote port open request for %s:%d\",\n\t\t  pf.dhost, port);\n\terr = pfd_connect(&c->u.pfd.pf, pf.dhost, port,\n                          c, ssh->conf, pfp->pfrec->addressfamily);\n\tif (err != NULL) {\n\t    logeventf(ssh, \"Port open failed: %s\", err);\n            sfree(err);\n\t    sfree(c);\n\t    send_packet(ssh, SSH1_MSG_CHANNEL_OPEN_FAILURE,\n\t\t\tPKT_INT, remoteid, PKT_END);\n\t} else {\n\t    ssh_channel_init(c);\n\t    c->remoteid = remoteid;\n\t    c->halfopen = FALSE;\n\t    c->type = CHAN_SOCKDATA;\t/* identify channel type */\n\t    send_packet(ssh, SSH1_MSG_CHANNEL_OPEN_CONFIRMATION,\n\t\t\tPKT_INT, c->remoteid, PKT_INT,\n\t\t\tc->localid, PKT_END);\n\t    logevent(\"Forwarded port opened successfully\");\n\t}\n    }\n\n    sfree(pf.dhost);\n}\n\nstatic void ssh1_msg_channel_open_confirmation(Ssh ssh, struct Packet *pktin)\n{\n    struct ssh_channel *c;\n\n    c = ssh_channel_msg(ssh, pktin);\n    if (c && c->type == CHAN_SOCKDATA) {\n\tc->remoteid = ssh_pkt_getuint32(pktin);\n\tc->halfopen = FALSE;\n\tc->throttling_conn = 0;\n\tpfd_confirm(c->u.pfd.pf);\n    }\n\n    if (c && c->pending_eof) {\n\t/*\n\t * We have a pending close on this channel,\n\t * which we decided on before the server acked\n\t * the channel open. So now we know the\n\t * remoteid, we can close it again.\n\t */\n        ssh_channel_try_eof(c);\n    }\n}\n\n        c->remoteid = remoteid;\n        c->halfopen = FALSE;\n        c->type = CHAN_AGENT;   /* identify channel type */\n        c->u.a.pending = NULL;\n        bufchain_init(&c->u.a.inbuffer);\n        send_packet(ssh, SSH1_MSG_CHANNEL_OPEN_CONFIRMATION,\n                    PKT_INT, c->remoteid, PKT_INT, c->localid,\n                    PKT_END);\n\tdel234(ssh->channels, c);\n\tsfree(c);\n    }\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 814,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-1621",
    "code_before_change": "  void RunInvTxfm(int16_t *out, uint8_t *dst, int stride) {\n     inv_txfm_(out, dst, stride, tx_type_);\n   }\n",
    "code_after_change": "  void RunInvTxfm(int16_t *out, uint8_t *dst, int stride) {\n  void RunInvTxfm(tran_low_t *out, uint8_t *dst, int stride) {\n     inv_txfm_(out, dst, stride, tx_type_);\n   }\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 819,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-1621",
    "code_before_change": "   int ReturnFrameBuffer(vpx_codec_frame_buffer_t *fb) {\n    EXPECT_TRUE(fb != NULL);\n     ExternalFrameBuffer *const ext_fb =\n         reinterpret_cast<ExternalFrameBuffer*>(fb->priv);\n    EXPECT_TRUE(ext_fb != NULL);\n     EXPECT_EQ(1, ext_fb->in_use);\n     ext_fb->in_use = 0;\n     return 0;\n }\n",
    "code_after_change": "   int ReturnFrameBuffer(vpx_codec_frame_buffer_t *fb) {\n    if (fb == NULL) {\n      EXPECT_TRUE(fb != NULL);\n      return -1;\n    }\n     ExternalFrameBuffer *const ext_fb =\n         reinterpret_cast<ExternalFrameBuffer*>(fb->priv);\n    if (ext_fb == NULL) {\n      EXPECT_TRUE(ext_fb != NULL);\n      return -1;\n    }\n     EXPECT_EQ(1, ext_fb->in_use);\n     ext_fb->in_use = 0;\n     return 0;\n }\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 821,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-0838",
    "code_before_change": "void WT_VoiceGain (S_WT_VOICE *pWTVoice, S_WT_INT_FRAME *pWTIntFrame)\n{\n    EAS_I32 *pMixBuffer;\n    EAS_PCM *pInputBuffer;\n    EAS_I32 gain;\n    EAS_I32 gainIncrement;\n    EAS_I32 tmp0;\n    EAS_I32 tmp1;\n    EAS_I32 tmp2;\n    EAS_I32 numSamples;\n\n#if (NUM_OUTPUT_CHANNELS == 2)\n    EAS_I32 gainLeft, gainRight;\n#endif\n\n \n     /* initialize some local variables */\n     numSamples = pWTIntFrame->numSamples;\n     pMixBuffer = pWTIntFrame->pMixBuffer;\n     pInputBuffer = pWTIntFrame->pAudioBuffer;\n \n /*lint -e{703} <avoid multiply for performance>*/\n    gainIncrement = (pWTIntFrame->frame.gainTarget - pWTIntFrame->prevGain) << (16 - SYNTH_UPDATE_PERIOD_IN_BITS);\n if (gainIncrement < 0)\n        gainIncrement++;\n /*lint -e{703} <avoid multiply for performance>*/\n    gain = pWTIntFrame->prevGain << 16;\n\n#if (NUM_OUTPUT_CHANNELS == 2)\n    gainLeft = pWTVoice->gainLeft;\n    gainRight = pWTVoice->gainRight;\n#endif\n\n while (numSamples--) {\n\n /* incremental gain step to prevent zipper noise */\n        tmp0 = *pInputBuffer++;\n        gain += gainIncrement;\n /*lint -e{704} <avoid divide>*/\n        tmp2 = gain >> 16;\n\n /* scale sample by gain */\n        tmp2 *= tmp0;\n\n\n /* stereo output */\n#if (NUM_OUTPUT_CHANNELS == 2)\n /*lint -e{704} <avoid divide>*/\n        tmp2 = tmp2 >> 14;\n\n /* get the current sample in the final mix buffer */\n        tmp1 = *pMixBuffer;\n\n /* left channel */\n        tmp0 = tmp2 * gainLeft;\n /*lint -e{704} <avoid divide>*/\n        tmp0 = tmp0 >> NUM_MIXER_GUARD_BITS;\n        tmp1 += tmp0;\n *pMixBuffer++ = tmp1;\n\n /* get the current sample in the final mix buffer */\n        tmp1 = *pMixBuffer;\n\n /* right channel */\n        tmp0 = tmp2 * gainRight;\n /*lint -e{704} <avoid divide>*/\n        tmp0 = tmp0 >> NUM_MIXER_GUARD_BITS;\n        tmp1 += tmp0;\n *pMixBuffer++ = tmp1;\n\n /* mono output */\n#else\n\n /* get the current sample in the final mix buffer */\n        tmp1 = *pMixBuffer;\n /*lint -e{704} <avoid divide>*/\n        tmp2 = tmp2 >> (NUM_MIXER_GUARD_BITS - 1);\n        tmp1 += tmp2;\n *pMixBuffer++ = tmp1;\n#endif\n\n }\n}\n",
    "code_after_change": "void WT_VoiceGain (S_WT_VOICE *pWTVoice, S_WT_INT_FRAME *pWTIntFrame)\n{\n    EAS_I32 *pMixBuffer;\n    EAS_PCM *pInputBuffer;\n    EAS_I32 gain;\n    EAS_I32 gainIncrement;\n    EAS_I32 tmp0;\n    EAS_I32 tmp1;\n    EAS_I32 tmp2;\n    EAS_I32 numSamples;\n\n#if (NUM_OUTPUT_CHANNELS == 2)\n    EAS_I32 gainLeft, gainRight;\n#endif\n\n \n     /* initialize some local variables */\n     numSamples = pWTIntFrame->numSamples;\n    if (numSamples <= 0) {\n        ALOGE(\"b/26366256\");\n        return;\n    }\n     pMixBuffer = pWTIntFrame->pMixBuffer;\n     pInputBuffer = pWTIntFrame->pAudioBuffer;\n \n /*lint -e{703} <avoid multiply for performance>*/\n    gainIncrement = (pWTIntFrame->frame.gainTarget - pWTIntFrame->prevGain) << (16 - SYNTH_UPDATE_PERIOD_IN_BITS);\n if (gainIncrement < 0)\n        gainIncrement++;\n /*lint -e{703} <avoid multiply for performance>*/\n    gain = pWTIntFrame->prevGain << 16;\n\n#if (NUM_OUTPUT_CHANNELS == 2)\n    gainLeft = pWTVoice->gainLeft;\n    gainRight = pWTVoice->gainRight;\n#endif\n\n while (numSamples--) {\n\n /* incremental gain step to prevent zipper noise */\n        tmp0 = *pInputBuffer++;\n        gain += gainIncrement;\n /*lint -e{704} <avoid divide>*/\n        tmp2 = gain >> 16;\n\n /* scale sample by gain */\n        tmp2 *= tmp0;\n\n\n /* stereo output */\n#if (NUM_OUTPUT_CHANNELS == 2)\n /*lint -e{704} <avoid divide>*/\n        tmp2 = tmp2 >> 14;\n\n /* get the current sample in the final mix buffer */\n        tmp1 = *pMixBuffer;\n\n /* left channel */\n        tmp0 = tmp2 * gainLeft;\n /*lint -e{704} <avoid divide>*/\n        tmp0 = tmp0 >> NUM_MIXER_GUARD_BITS;\n        tmp1 += tmp0;\n *pMixBuffer++ = tmp1;\n\n /* get the current sample in the final mix buffer */\n        tmp1 = *pMixBuffer;\n\n /* right channel */\n        tmp0 = tmp2 * gainRight;\n /*lint -e{704} <avoid divide>*/\n        tmp0 = tmp0 >> NUM_MIXER_GUARD_BITS;\n        tmp1 += tmp0;\n *pMixBuffer++ = tmp1;\n\n /* mono output */\n#else\n\n /* get the current sample in the final mix buffer */\n        tmp1 = *pMixBuffer;\n /*lint -e{704} <avoid divide>*/\n        tmp2 = tmp2 >> (NUM_MIXER_GUARD_BITS - 1);\n        tmp1 += tmp2;\n *pMixBuffer++ = tmp1;\n#endif\n\n }\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 830,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-10190",
    "code_before_change": "static void parse_content_range(URLContext *h, const char *p)\n{\n    HTTPContext *s = h->priv_data;\n    const char *slash;\n \n     if (!strncmp(p, \"bytes \", 6)) {\n         p     += 6;\n        s->off = strtoll(p, NULL, 10);\n         if ((slash = strchr(p, '/')) && strlen(slash) > 0)\n            s->filesize = strtoll(slash + 1, NULL, 10);\n     }\n     if (s->seekable == -1 && (!s->is_akamai || s->filesize != 2147483647))\n         h->is_streamed = 0; /* we _can_ in fact seek */\n}\n",
    "code_after_change": "static void parse_content_range(URLContext *h, const char *p)\n{\n    HTTPContext *s = h->priv_data;\n    const char *slash;\n \n     if (!strncmp(p, \"bytes \", 6)) {\n         p     += 6;\n        s->off = strtoull(p, NULL, 10);\n         if ((slash = strchr(p, '/')) && strlen(slash) > 0)\n            s->filesize = strtoull(slash + 1, NULL, 10);\n     }\n     if (s->seekable == -1 && (!s->is_akamai || s->filesize != 2147483647))\n         h->is_streamed = 0; /* we _can_ in fact seek */\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 831,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2015-3832",
    "code_before_change": "status_t MPEG4Source::fragmentedRead(\n MediaBuffer **out, const ReadOptions *options) {\n\n    ALOGV(\"MPEG4Source::fragmentedRead\");\n\n    CHECK(mStarted);\n\n *out = NULL;\n\n int64_t targetSampleTimeUs = -1;\n\n int64_t seekTimeUs;\n ReadOptions::SeekMode mode;\n if (options && options->getSeekTo(&seekTimeUs, &mode)) {\n\n int numSidxEntries = mSegments.size();\n if (numSidxEntries != 0) {\n int64_t totalTime = 0;\n off64_t totalOffset = mFirstMoofOffset;\n for (int i = 0; i < numSidxEntries; i++) {\n const SidxEntry *se = &mSegments[i];\n if (totalTime + se->mDurationUs > seekTimeUs) {\n if ((mode == ReadOptions::SEEK_NEXT_SYNC && seekTimeUs > totalTime) ||\n (mode == ReadOptions::SEEK_CLOSEST_SYNC &&\n (seekTimeUs - totalTime) > (totalTime + se->mDurationUs - seekTimeUs))) {\n                        totalTime += se->mDurationUs;\n                        totalOffset += se->mSize;\n }\n break;\n }\n                totalTime += se->mDurationUs;\n                totalOffset += se->mSize;\n }\n            mCurrentMoofOffset = totalOffset;\n            mCurrentSamples.clear();\n            mCurrentSampleIndex = 0;\n            parseChunk(&totalOffset);\n            mCurrentTime = totalTime * mTimescale / 1000000ll;\n } else {\n            mCurrentMoofOffset = mFirstMoofOffset;\n            mCurrentSamples.clear();\n            mCurrentSampleIndex = 0;\n off64_t tmp = mCurrentMoofOffset;\n            parseChunk(&tmp);\n            mCurrentTime = 0;\n }\n\n if (mBuffer != NULL) {\n            mBuffer->release();\n            mBuffer = NULL;\n }\n\n }\n\n off64_t offset = 0;\n size_t size = 0;\n uint32_t cts = 0;\n bool isSyncSample = false;\n bool newBuffer = false;\n if (mBuffer == NULL) {\n        newBuffer = true;\n\n if (mCurrentSampleIndex >= mCurrentSamples.size()) {\n if (mNextMoofOffset <= mCurrentMoofOffset) {\n return ERROR_END_OF_STREAM;\n }\n off64_t nextMoof = mNextMoofOffset;\n            mCurrentMoofOffset = nextMoof;\n            mCurrentSamples.clear();\n            mCurrentSampleIndex = 0;\n            parseChunk(&nextMoof);\n if (mCurrentSampleIndex >= mCurrentSamples.size()) {\n return ERROR_END_OF_STREAM;\n }\n }\n\n const Sample *smpl = &mCurrentSamples[mCurrentSampleIndex];\n        offset = smpl->offset;\n        size = smpl->size;\n        cts = mCurrentTime + smpl->compositionOffset;\n        mCurrentTime += smpl->duration;\n        isSyncSample = (mCurrentSampleIndex == 0); // XXX\n\n status_t err = mGroup->acquire_buffer(&mBuffer);\n\n if (err != OK) {\n            CHECK(mBuffer == NULL);\n            ALOGV(\"acquire_buffer returned %d\", err);\n return err;\n }\n }\n\n const Sample *smpl = &mCurrentSamples[mCurrentSampleIndex];\n const sp<MetaData> bufmeta = mBuffer->meta_data();\n    bufmeta->clear();\n if (smpl->encryptedsizes.size()) {\n        bufmeta->setData(kKeyPlainSizes, 0,\n                smpl->clearsizes.array(), smpl->clearsizes.size() * 4);\n        bufmeta->setData(kKeyEncryptedSizes, 0,\n                smpl->encryptedsizes.array(), smpl->encryptedsizes.size() * 4);\n        bufmeta->setData(kKeyCryptoIV, 0, smpl->iv, 16); // use 16 or the actual size?\n        bufmeta->setInt32(kKeyCryptoDefaultIVSize, mDefaultIVSize);\n        bufmeta->setInt32(kKeyCryptoMode, mCryptoMode);\n        bufmeta->setData(kKeyCryptoKey, 0, mCryptoKey, 16);\n }\n\n if ((!mIsAVC && !mIsHEVC)|| mWantsNALFragments) {\n if (newBuffer) {\n ssize_t num_bytes_read =\n                mDataSource->readAt(offset, (uint8_t *)mBuffer->data(), size);\n\n if (num_bytes_read < (ssize_t)size) {\n                mBuffer->release();\n                mBuffer = NULL;\n\n                ALOGV(\"i/o error\");\n return ERROR_IO;\n }\n\n            CHECK(mBuffer != NULL);\n            mBuffer->set_range(0, size);\n            mBuffer->meta_data()->setInt64(\n                    kKeyTime, ((int64_t)cts * 1000000) / mTimescale);\n            mBuffer->meta_data()->setInt64(\n                    kKeyDuration, ((int64_t)smpl->duration * 1000000) / mTimescale);\n\n if (targetSampleTimeUs >= 0) {\n                mBuffer->meta_data()->setInt64(\n                        kKeyTargetTime, targetSampleTimeUs);\n }\n\n if (isSyncSample) {\n                mBuffer->meta_data()->setInt32(kKeyIsSyncFrame, 1);\n }\n\n ++mCurrentSampleIndex;\n }\n\n if (!mIsAVC && !mIsHEVC) {\n *out = mBuffer;\n            mBuffer = NULL;\n\n return OK;\n }\n\n\n        CHECK(mBuffer->range_length() >= mNALLengthSize);\n\n const uint8_t *src =\n (const uint8_t *)mBuffer->data() + mBuffer->range_offset();\n\n size_t nal_size = parseNALSize(src);\n if (mBuffer->range_length() < mNALLengthSize + nal_size) {\n            ALOGE(\"incomplete NAL unit.\");\n\n            mBuffer->release();\n            mBuffer = NULL;\n\n return ERROR_MALFORMED;\n }\n\n MediaBuffer *clone = mBuffer->clone();\n        CHECK(clone != NULL);\n        clone->set_range(mBuffer->range_offset() + mNALLengthSize, nal_size);\n\n        CHECK(mBuffer != NULL);\n        mBuffer->set_range(\n                mBuffer->range_offset() + mNALLengthSize + nal_size,\n                mBuffer->range_length() - mNALLengthSize - nal_size);\n\n if (mBuffer->range_length() == 0) {\n            mBuffer->release();\n            mBuffer = NULL;\n }\n\n *out = clone;\n\n return OK;\n } else {\n        ALOGV(\"whole NAL\");\n ssize_t num_bytes_read = 0;\n int32_t drm = 0;\n bool usesDRM = (mFormat->findInt32(kKeyIsDRM, &drm) && drm != 0);\n if (usesDRM) {\n            num_bytes_read =\n                mDataSource->readAt(offset, (uint8_t*)mBuffer->data(), size);\n } else {\n            num_bytes_read = mDataSource->readAt(offset, mSrcBuffer, size);\n }\n\n if (num_bytes_read < (ssize_t)size) {\n            mBuffer->release();\n            mBuffer = NULL;\n\n            ALOGV(\"i/o error\");\n return ERROR_IO;\n }\n\n if (usesDRM) {\n            CHECK(mBuffer != NULL);\n            mBuffer->set_range(0, size);\n\n } else {\n uint8_t *dstData = (uint8_t *)mBuffer->data();\n size_t srcOffset = 0;\n\n             size_t dstOffset = 0;\n \n             while (srcOffset < size) {\n                bool isMalFormed = (srcOffset + mNALLengthSize > size);\n                 size_t nalLength = 0;\n                 if (!isMalFormed) {\n                     nalLength = parseNALSize(&mSrcBuffer[srcOffset]);\n                     srcOffset += mNALLengthSize;\n                    isMalFormed = srcOffset + nalLength > size;\n                 }\n \n                 if (isMalFormed) {\n                    ALOGE(\"Video is malformed\");\n                    mBuffer->release();\n                    mBuffer = NULL;\n return ERROR_MALFORMED;\n }\n\n if (nalLength == 0) {\n continue;\n }\n\n                CHECK(dstOffset + 4 <= mBuffer->size());\n\n                dstData[dstOffset++] = 0;\n                dstData[dstOffset++] = 0;\n                dstData[dstOffset++] = 0;\n                dstData[dstOffset++] = 1;\n                memcpy(&dstData[dstOffset], &mSrcBuffer[srcOffset], nalLength);\n                srcOffset += nalLength;\n                dstOffset += nalLength;\n }\n            CHECK_EQ(srcOffset, size);\n            CHECK(mBuffer != NULL);\n            mBuffer->set_range(0, dstOffset);\n }\n\n        mBuffer->meta_data()->setInt64(\n                kKeyTime, ((int64_t)cts * 1000000) / mTimescale);\n        mBuffer->meta_data()->setInt64(\n                kKeyDuration, ((int64_t)smpl->duration * 1000000) / mTimescale);\n\n if (targetSampleTimeUs >= 0) {\n            mBuffer->meta_data()->setInt64(\n                    kKeyTargetTime, targetSampleTimeUs);\n }\n\n if (isSyncSample) {\n            mBuffer->meta_data()->setInt32(kKeyIsSyncFrame, 1);\n }\n\n ++mCurrentSampleIndex;\n\n *out = mBuffer;\n        mBuffer = NULL;\n\n return OK;\n }\n}\n",
    "code_after_change": "status_t MPEG4Source::fragmentedRead(\n MediaBuffer **out, const ReadOptions *options) {\n\n    ALOGV(\"MPEG4Source::fragmentedRead\");\n\n    CHECK(mStarted);\n\n *out = NULL;\n\n int64_t targetSampleTimeUs = -1;\n\n int64_t seekTimeUs;\n ReadOptions::SeekMode mode;\n if (options && options->getSeekTo(&seekTimeUs, &mode)) {\n\n int numSidxEntries = mSegments.size();\n if (numSidxEntries != 0) {\n int64_t totalTime = 0;\n off64_t totalOffset = mFirstMoofOffset;\n for (int i = 0; i < numSidxEntries; i++) {\n const SidxEntry *se = &mSegments[i];\n if (totalTime + se->mDurationUs > seekTimeUs) {\n if ((mode == ReadOptions::SEEK_NEXT_SYNC && seekTimeUs > totalTime) ||\n (mode == ReadOptions::SEEK_CLOSEST_SYNC &&\n (seekTimeUs - totalTime) > (totalTime + se->mDurationUs - seekTimeUs))) {\n                        totalTime += se->mDurationUs;\n                        totalOffset += se->mSize;\n }\n break;\n }\n                totalTime += se->mDurationUs;\n                totalOffset += se->mSize;\n }\n            mCurrentMoofOffset = totalOffset;\n            mCurrentSamples.clear();\n            mCurrentSampleIndex = 0;\n            parseChunk(&totalOffset);\n            mCurrentTime = totalTime * mTimescale / 1000000ll;\n } else {\n            mCurrentMoofOffset = mFirstMoofOffset;\n            mCurrentSamples.clear();\n            mCurrentSampleIndex = 0;\n off64_t tmp = mCurrentMoofOffset;\n            parseChunk(&tmp);\n            mCurrentTime = 0;\n }\n\n if (mBuffer != NULL) {\n            mBuffer->release();\n            mBuffer = NULL;\n }\n\n }\n\n off64_t offset = 0;\n size_t size = 0;\n uint32_t cts = 0;\n bool isSyncSample = false;\n bool newBuffer = false;\n if (mBuffer == NULL) {\n        newBuffer = true;\n\n if (mCurrentSampleIndex >= mCurrentSamples.size()) {\n if (mNextMoofOffset <= mCurrentMoofOffset) {\n return ERROR_END_OF_STREAM;\n }\n off64_t nextMoof = mNextMoofOffset;\n            mCurrentMoofOffset = nextMoof;\n            mCurrentSamples.clear();\n            mCurrentSampleIndex = 0;\n            parseChunk(&nextMoof);\n if (mCurrentSampleIndex >= mCurrentSamples.size()) {\n return ERROR_END_OF_STREAM;\n }\n }\n\n const Sample *smpl = &mCurrentSamples[mCurrentSampleIndex];\n        offset = smpl->offset;\n        size = smpl->size;\n        cts = mCurrentTime + smpl->compositionOffset;\n        mCurrentTime += smpl->duration;\n        isSyncSample = (mCurrentSampleIndex == 0); // XXX\n\n status_t err = mGroup->acquire_buffer(&mBuffer);\n\n if (err != OK) {\n            CHECK(mBuffer == NULL);\n            ALOGV(\"acquire_buffer returned %d\", err);\n return err;\n }\n }\n\n const Sample *smpl = &mCurrentSamples[mCurrentSampleIndex];\n const sp<MetaData> bufmeta = mBuffer->meta_data();\n    bufmeta->clear();\n if (smpl->encryptedsizes.size()) {\n        bufmeta->setData(kKeyPlainSizes, 0,\n                smpl->clearsizes.array(), smpl->clearsizes.size() * 4);\n        bufmeta->setData(kKeyEncryptedSizes, 0,\n                smpl->encryptedsizes.array(), smpl->encryptedsizes.size() * 4);\n        bufmeta->setData(kKeyCryptoIV, 0, smpl->iv, 16); // use 16 or the actual size?\n        bufmeta->setInt32(kKeyCryptoDefaultIVSize, mDefaultIVSize);\n        bufmeta->setInt32(kKeyCryptoMode, mCryptoMode);\n        bufmeta->setData(kKeyCryptoKey, 0, mCryptoKey, 16);\n }\n\n if ((!mIsAVC && !mIsHEVC)|| mWantsNALFragments) {\n if (newBuffer) {\n ssize_t num_bytes_read =\n                mDataSource->readAt(offset, (uint8_t *)mBuffer->data(), size);\n\n if (num_bytes_read < (ssize_t)size) {\n                mBuffer->release();\n                mBuffer = NULL;\n\n                ALOGV(\"i/o error\");\n return ERROR_IO;\n }\n\n            CHECK(mBuffer != NULL);\n            mBuffer->set_range(0, size);\n            mBuffer->meta_data()->setInt64(\n                    kKeyTime, ((int64_t)cts * 1000000) / mTimescale);\n            mBuffer->meta_data()->setInt64(\n                    kKeyDuration, ((int64_t)smpl->duration * 1000000) / mTimescale);\n\n if (targetSampleTimeUs >= 0) {\n                mBuffer->meta_data()->setInt64(\n                        kKeyTargetTime, targetSampleTimeUs);\n }\n\n if (isSyncSample) {\n                mBuffer->meta_data()->setInt32(kKeyIsSyncFrame, 1);\n }\n\n ++mCurrentSampleIndex;\n }\n\n if (!mIsAVC && !mIsHEVC) {\n *out = mBuffer;\n            mBuffer = NULL;\n\n return OK;\n }\n\n\n        CHECK(mBuffer->range_length() >= mNALLengthSize);\n\n const uint8_t *src =\n (const uint8_t *)mBuffer->data() + mBuffer->range_offset();\n\n size_t nal_size = parseNALSize(src);\n if (mBuffer->range_length() < mNALLengthSize + nal_size) {\n            ALOGE(\"incomplete NAL unit.\");\n\n            mBuffer->release();\n            mBuffer = NULL;\n\n return ERROR_MALFORMED;\n }\n\n MediaBuffer *clone = mBuffer->clone();\n        CHECK(clone != NULL);\n        clone->set_range(mBuffer->range_offset() + mNALLengthSize, nal_size);\n\n        CHECK(mBuffer != NULL);\n        mBuffer->set_range(\n                mBuffer->range_offset() + mNALLengthSize + nal_size,\n                mBuffer->range_length() - mNALLengthSize - nal_size);\n\n if (mBuffer->range_length() == 0) {\n            mBuffer->release();\n            mBuffer = NULL;\n }\n\n *out = clone;\n\n return OK;\n } else {\n        ALOGV(\"whole NAL\");\n ssize_t num_bytes_read = 0;\n int32_t drm = 0;\n bool usesDRM = (mFormat->findInt32(kKeyIsDRM, &drm) && drm != 0);\n if (usesDRM) {\n            num_bytes_read =\n                mDataSource->readAt(offset, (uint8_t*)mBuffer->data(), size);\n } else {\n            num_bytes_read = mDataSource->readAt(offset, mSrcBuffer, size);\n }\n\n if (num_bytes_read < (ssize_t)size) {\n            mBuffer->release();\n            mBuffer = NULL;\n\n            ALOGV(\"i/o error\");\n return ERROR_IO;\n }\n\n if (usesDRM) {\n            CHECK(mBuffer != NULL);\n            mBuffer->set_range(0, size);\n\n } else {\n uint8_t *dstData = (uint8_t *)mBuffer->data();\n size_t srcOffset = 0;\n\n             size_t dstOffset = 0;\n \n             while (srcOffset < size) {\n                bool isMalFormed = !isInRange((size_t)0u, size, srcOffset, mNALLengthSize);\n                 size_t nalLength = 0;\n                 if (!isMalFormed) {\n                     nalLength = parseNALSize(&mSrcBuffer[srcOffset]);\n                     srcOffset += mNALLengthSize;\n                    isMalFormed = !isInRange((size_t)0u, size, srcOffset, nalLength);\n                 }\n \n                 if (isMalFormed) {\n                    ALOGE(\"Video is malformed\");\n                    mBuffer->release();\n                    mBuffer = NULL;\n return ERROR_MALFORMED;\n }\n\n if (nalLength == 0) {\n continue;\n }\n\n                CHECK(dstOffset + 4 <= mBuffer->size());\n\n                dstData[dstOffset++] = 0;\n                dstData[dstOffset++] = 0;\n                dstData[dstOffset++] = 0;\n                dstData[dstOffset++] = 1;\n                memcpy(&dstData[dstOffset], &mSrcBuffer[srcOffset], nalLength);\n                srcOffset += nalLength;\n                dstOffset += nalLength;\n }\n            CHECK_EQ(srcOffset, size);\n            CHECK(mBuffer != NULL);\n            mBuffer->set_range(0, dstOffset);\n }\n\n        mBuffer->meta_data()->setInt64(\n                kKeyTime, ((int64_t)cts * 1000000) / mTimescale);\n        mBuffer->meta_data()->setInt64(\n                kKeyDuration, ((int64_t)smpl->duration * 1000000) / mTimescale);\n\n if (targetSampleTimeUs >= 0) {\n            mBuffer->meta_data()->setInt64(\n                    kKeyTargetTime, targetSampleTimeUs);\n }\n\n if (isSyncSample) {\n            mBuffer->meta_data()->setInt32(kKeyIsSyncFrame, 1);\n }\n\n ++mCurrentSampleIndex;\n\n *out = mBuffer;\n        mBuffer = NULL;\n\n return OK;\n }\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 833,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-0838",
    "code_before_change": "void WT_VoiceFilter (S_FILTER_CONTROL *pFilter, S_WT_INT_FRAME *pWTIntFrame)\n{\n    EAS_PCM *pAudioBuffer;\n    EAS_I32 k;\n    EAS_I32 b1;\n    EAS_I32 b2;\n    EAS_I32 z1;\n    EAS_I32 z2;\n    EAS_I32 acc0;\n    EAS_I32 acc1;\n    EAS_I32 numSamples;\n\n /* initialize some local variables */\n\n     numSamples = pWTIntFrame->numSamples;\n     if (numSamples <= 0) {\n         ALOGE(\"b/26366256\");\n         return;\n     }\n     pAudioBuffer = pWTIntFrame->pAudioBuffer;\n\n    z1 = pFilter->z1;\n    z2 = pFilter->z2;\n    b1 = -pWTIntFrame->frame.b1;\n\n /*lint -e{702} <avoid divide> */\n    b2 = -pWTIntFrame->frame.b2 >> 1;\n\n /*lint -e{702} <avoid divide> */\n    k = pWTIntFrame->frame.k >> 1;\n\n while (numSamples--)\n {\n\n /* do filter calculations */\n        acc0 = *pAudioBuffer;\n        acc1 = z1 * b1;\n        acc1 += z2 * b2;\n        acc0 = acc1 + k * acc0;\n        z2 = z1;\n\n /*lint -e{702} <avoid divide> */\n        z1 = acc0 >> 14;\n *pAudioBuffer++ = (EAS_I16) z1;\n }\n\n /* save delay values     */\n    pFilter->z1 = (EAS_I16) z1;\n    pFilter->z2 = (EAS_I16) z2;\n}\n",
    "code_after_change": "void WT_VoiceFilter (S_FILTER_CONTROL *pFilter, S_WT_INT_FRAME *pWTIntFrame)\n{\n    EAS_PCM *pAudioBuffer;\n    EAS_I32 k;\n    EAS_I32 b1;\n    EAS_I32 b2;\n    EAS_I32 z1;\n    EAS_I32 z2;\n    EAS_I32 acc0;\n    EAS_I32 acc1;\n    EAS_I32 numSamples;\n\n /* initialize some local variables */\n\n     numSamples = pWTIntFrame->numSamples;\n     if (numSamples <= 0) {\n         ALOGE(\"b/26366256\");\n        android_errorWriteLog(0x534e4554, \"26366256\");\n         return;\n     }\n     pAudioBuffer = pWTIntFrame->pAudioBuffer;\n\n    z1 = pFilter->z1;\n    z2 = pFilter->z2;\n    b1 = -pWTIntFrame->frame.b1;\n\n /*lint -e{702} <avoid divide> */\n    b2 = -pWTIntFrame->frame.b2 >> 1;\n\n /*lint -e{702} <avoid divide> */\n    k = pWTIntFrame->frame.k >> 1;\n\n while (numSamples--)\n {\n\n /* do filter calculations */\n        acc0 = *pAudioBuffer;\n        acc1 = z1 * b1;\n        acc1 += z2 * b2;\n        acc0 = acc1 + k * acc0;\n        z2 = z1;\n\n /*lint -e{702} <avoid divide> */\n        z1 = acc0 >> 14;\n *pAudioBuffer++ = (EAS_I16) z1;\n }\n\n /* save delay values     */\n    pFilter->z1 = (EAS_I16) z1;\n    pFilter->z2 = (EAS_I16) z2;\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 838,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2013-4263",
    "code_before_change": "static AVFrame *get_video_buffer(AVFilterLink *inlink, int w, int h)\n{\n    PadContext *s = inlink->dst->priv;\n\n    AVFrame *frame = ff_get_video_buffer(inlink->dst->outputs[0],\n                                         w + (s->w - s->in_w),\n                                         h + (s->h - s->in_h));\n    int plane;\n\n    if (!frame)\n        return NULL;\n\n     frame->width  = w;\n     frame->height = h;\n \n    for (plane = 0; plane < 4 && frame->data[plane]; plane++) {\n         int hsub = s->draw.hsub[plane];\n         int vsub = s->draw.vsub[plane];\n         frame->data[plane] += (s->x >> hsub) * s->draw.pixelstep[plane] +\n                              (s->y >> vsub) * frame->linesize[plane];\n    }\n\n    return frame;\n}\n",
    "code_after_change": "static AVFrame *get_video_buffer(AVFilterLink *inlink, int w, int h)\n{\n    PadContext *s = inlink->dst->priv;\n\n    AVFrame *frame = ff_get_video_buffer(inlink->dst->outputs[0],\n                                         w + (s->w - s->in_w),\n                                         h + (s->h - s->in_h));\n    int plane;\n\n    if (!frame)\n        return NULL;\n\n     frame->width  = w;\n     frame->height = h;\n \n    for (plane = 0; plane < 4 && frame->data[plane] && frame->linesize[plane]; plane++) {\n         int hsub = s->draw.hsub[plane];\n         int vsub = s->draw.vsub[plane];\n         frame->data[plane] += (s->x >> hsub) * s->draw.pixelstep[plane] +\n                              (s->y >> vsub) * frame->linesize[plane];\n    }\n\n    return frame;\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 849,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2012-6711",
    "code_before_change": "report_error (const char *format, ...)\n#else\nreport_error (format, va_alist)\n     const char *format;\n     va_dcl\n#endif\n{\n  va_list args;\n\n  error_prolog (1);\n\n  SH_VA_START (args, format);\n\n  vfprintf (stderr, format, args);\n  fprintf (stderr, \"\\n\");\n \n   va_end (args);\n   if (exit_immediately_on_error)\n    exit_shell (1);\n }\n",
    "code_after_change": "report_error (const char *format, ...)\n#else\nreport_error (format, va_alist)\n     const char *format;\n     va_dcl\n#endif\n{\n  va_list args;\n\n  error_prolog (1);\n\n  SH_VA_START (args, format);\n\n  vfprintf (stderr, format, args);\n  fprintf (stderr, \"\\n\");\n \n   va_end (args);\n   if (exit_immediately_on_error)\n    {\n      if (last_command_exit_value == 0)\n\tlast_command_exit_value = 1;\n      exit_shell (last_command_exit_value);\n    }\n }\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 855,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2015-6764",
    "code_before_change": "bool GetNetworkList(NetworkInterfaceList* networks, int policy) {\n  int s = socket(AF_INET, SOCK_DGRAM, 0);\n  if (s <= 0) {\n    PLOG(ERROR) << \"socket\";\n    return false;\n   }\n  uint32_t num_ifs = 0;\n  if (ioctl_netc_get_num_ifs(s, &num_ifs) < 0) {\n    PLOG(ERROR) << \"ioctl_netc_get_num_ifs\";\n    PCHECK(close(s) == 0);\n    return false;\n   }\n \n  for (uint32_t i = 0; i < num_ifs; ++i) {\n    netc_if_info_t interface;\n \n    if (ioctl_netc_get_if_info_at(s, &i, &interface) < 0) {\n      PLOG(WARNING) << \"ioctl_netc_get_if_info_at\";\n      continue;\n    }\n \n    if (internal::IsLoopbackOrUnspecifiedAddress(\n            reinterpret_cast<sockaddr*>(&(interface.addr)))) {\n       continue;\n    }\n \n    IPEndPoint address;\n    if (!address.FromSockAddr(reinterpret_cast<sockaddr*>(&(interface.addr)),\n                              sizeof(interface.addr))) {\n      DLOG(WARNING) << \"ioctl_netc_get_if_info returned invalid address.\";\n       continue;\n    }\n \n    int prefix_length = 0;\n    IPEndPoint netmask;\n    if (netmask.FromSockAddr(reinterpret_cast<sockaddr*>(&(interface.netmask)),\n                             sizeof(interface.netmask))) {\n      prefix_length = MaskPrefixLength(netmask.address());\n    }\n \n     int attributes = 0;\n \n    networks->push_back(\n        NetworkInterface(interface.name, interface.name, interface.index,\n                         NetworkChangeNotifier::CONNECTION_UNKNOWN,\n                         address.address(), prefix_length, attributes));\n   }\n \n  PCHECK(close(s) == 0);\n   return true;\n }\n",
    "code_after_change": "bool GetNetworkList(NetworkInterfaceList* networks, int policy) {\nIPAddress NetAddressToIPAddress(const netstack::NetAddress& addr) {\n  if (addr.ipv4) {\n    return IPAddress(addr.ipv4->addr.data(), addr.ipv4->addr.count());\n   }\n  if (addr.ipv6) {\n    return IPAddress(addr.ipv6->addr.data(), addr.ipv6->addr.count());\n   }\n  return IPAddress();\n}\n \nbool GetNetworkList(NetworkInterfaceList* networks, int policy) {\n  netstack::NetstackSyncPtr netstack =\n      base::fuchsia::ComponentContext::GetDefault()\n          ->ConnectToServiceSync<netstack::Netstack>();\n \n  fidl::VectorPtr<netstack::NetInterface> interfaces;\n  if (!netstack->GetInterfaces(&interfaces))\n    return false;\n \n  for (auto& interface : interfaces.get()) {\n    // Check if the interface is up.\n    if (!(interface.flags & netstack::NetInterfaceFlagUp))\n       continue;\n \n    // Skip loopback.\n    if (interface.features & netstack::interfaceFeatureLoopback)\n       continue;\n \n    NetworkChangeNotifier::ConnectionType connection_type =\n        (interface.features & netstack::interfaceFeatureWlan)\n            ? NetworkChangeNotifier::CONNECTION_WIFI\n            : NetworkChangeNotifier::CONNECTION_UNKNOWN;\n \n    // addresses. Currently Netstack doesn't provide this information.\n     int attributes = 0;\n \n    networks->push_back(NetworkInterface(\n        *interface.name, *interface.name, interface.id, connection_type,\n        NetAddressToIPAddress(interface.addr),\n        MaskPrefixLength(NetAddressToIPAddress(interface.netmask)),\n        attributes));\n   }\n \n   return true;\n }\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 860,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-1621",
    "code_before_change": "  void RunFwdTxfm(int16_t *in, int16_t *out, int stride) {\n     fwd_txfm_(in, out, stride);\n   }\n",
    "code_after_change": "  void RunFwdTxfm(int16_t *in, int16_t *out, int stride) {\n  void RunFwdTxfm(int16_t *in, tran_low_t *out, int stride) {\n     fwd_txfm_(in, out, stride);\n   }\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 864,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2013-0917",
    "code_before_change": " DirectoryEntrySync* DirectoryEntrySync::getDirectory(const String& path, const Dictionary& options, ExceptionState& exceptionState)\n {\n     FileSystemFlags flags(options);\n    RefPtr<EntrySyncCallbackHelper> helper = EntrySyncCallbackHelper::create();\n     m_fileSystem->getDirectory(this, path, flags, helper->successCallback(), helper->errorCallback(), DOMFileSystemBase::Synchronous);\n     return static_cast<DirectoryEntrySync*>(helper->getResult(exceptionState));\n }\n",
    "code_after_change": " DirectoryEntrySync* DirectoryEntrySync::getDirectory(const String& path, const Dictionary& options, ExceptionState& exceptionState)\n {\n     FileSystemFlags flags(options);\n    EntrySyncCallbackHelper* helper = EntrySyncCallbackHelper::create();\n     m_fileSystem->getDirectory(this, path, flags, helper->successCallback(), helper->errorCallback(), DOMFileSystemBase::Synchronous);\n     return static_cast<DirectoryEntrySync*>(helper->getResult(exceptionState));\n }\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 880,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2011-3916",
    "code_before_change": "WebGLObject::WebGLObject(WebGLRenderingContext* context)\n     : m_object(0)\n     , m_attachmentCount(0)\n     , m_deleted(false)\n{\n}\n",
    "code_after_change": "WebGLObject::WebGLObject(WebGLRenderingContext* context)\nWebGLObject::WebGLObject(WebGLRenderingContext*)\n     : m_object(0)\n     , m_attachmentCount(0)\n     , m_deleted(false)\n{\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 891,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2019-5824",
    "code_before_change": "void MediaStreamDispatcherHost::DoOpenDevice(\n    int32_t page_request_id,\n    const std::string& device_id,\n    blink::MediaStreamType type,\n    OpenDeviceCallback callback,\n    MediaDeviceSaltAndOrigin salt_and_origin) {\n  DCHECK_CURRENTLY_ON(BrowserThread::IO);\n  if (!MediaStreamManager::IsOriginAllowed(render_process_id_,\n                                           salt_and_origin.origin)) {\n    std::move(callback).Run(false /* success */, std::string(),\n                            blink::MediaStreamDevice());\n    return;\n   }\n \n   media_stream_manager_->OpenDevice(\n      render_process_id_, render_frame_id_, page_request_id, requester_id_,\n       device_id, type, std::move(salt_and_origin), std::move(callback),\n       base::BindRepeating(&MediaStreamDispatcherHost::OnDeviceStopped,\n                           weak_factory_.GetWeakPtr()));\n}\n",
    "code_after_change": "void MediaStreamDispatcherHost::DoOpenDevice(\n    int32_t page_request_id,\n    const std::string& device_id,\n    blink::MediaStreamType type,\n    OpenDeviceCallback callback,\n    MediaDeviceSaltAndOrigin salt_and_origin) {\n  DCHECK_CURRENTLY_ON(BrowserThread::IO);\n  if (!MediaStreamManager::IsOriginAllowed(render_process_id_,\n                                           salt_and_origin.origin)) {\n    std::move(callback).Run(false /* success */, std::string(),\n                            blink::MediaStreamDevice());\n    return;\n   }\n \n   media_stream_manager_->OpenDevice(\n      render_process_id_, render_frame_id_, requester_id_, page_request_id,\n       device_id, type, std::move(salt_and_origin), std::move(callback),\n       base::BindRepeating(&MediaStreamDispatcherHost::OnDeviceStopped,\n                           weak_factory_.GetWeakPtr()));\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 897,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-5199",
    "code_before_change": "void DataReductionProxySettings::InitPrefMembers() {\n  DCHECK(thread_checker_.CalledOnValidThread());\n  spdy_proxy_auth_enabled_.Init(\n      prefs::kDataSaverEnabled, GetOriginalProfilePrefs(),\n      base::Bind(&DataReductionProxySettings::OnProxyEnabledPrefChange,\n                 base::Unretained(this)));\n}\n",
    "code_after_change": "void DataReductionProxySettings::InitPrefMembers() {\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 901,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2011-3963",
    "code_before_change": "void BluetoothOptionsHandler::GenerateFakeDiscoveredDevice(\n     const std::string& name,\n     const std::string& address,\n     const std::string& icon,\n     bool paired,\n    bool connected) {\n  DictionaryValue device;\n  device.SetString(\"name\", name);\n  device.SetString(\"address\", address);\n  device.SetString(\"icon\", icon);\n  device.SetBoolean(\"paired\", paired);\n  device.SetBoolean(\"connected\", connected);\n  web_ui_->CallJavascriptFunction(\n      \"options.SystemOptions.addBluetoothDevice\", device);\n}\n",
    "code_after_change": "void BluetoothOptionsHandler::GenerateFakeDiscoveredDevice(\nvoid BluetoothOptionsHandler::GenerateFakeDevice(\n     const std::string& name,\n     const std::string& address,\n     const std::string& icon,\n     bool paired,\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 908,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-4303",
    "code_before_change": "void cJSON_AddItemReferenceToObject( cJSON *object, const char *string, cJSON *item )\n{\n\tcJSON_AddItemToObject( object, string, create_reference( item ) );\n}\n",
    "code_after_change": "void cJSON_AddItemReferenceToObject( cJSON *object, const char *string, cJSON *item )\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 911,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-10713",
    "code_before_change": " pch_write_line (lin line, FILE *file)\n {\n  bool after_newline = p_line[line][p_len[line] - 1] == '\\n';\n   if (! fwrite (p_line[line], sizeof (*p_line[line]), p_len[line], file))\n     write_fatal ();\n   return after_newline;\n}\n",
    "code_after_change": " pch_write_line (lin line, FILE *file)\n {\n  bool after_newline = (p_len[line] > 0) && (p_line[line][p_len[line] - 1] == '\\n');\n   if (! fwrite (p_line[line], sizeof (*p_line[line]), p_len[line], file))\n     write_fatal ();\n   return after_newline;\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 912,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2011-3106",
    "code_before_change": "ResourceDispatcherHostImpl::ResourceDispatcherHostImpl()\n     : download_file_manager_(new DownloadFileManager(NULL)),\n       save_file_manager_(new SaveFileManager()),\n       request_id_(-1),\n      ALLOW_THIS_IN_INITIALIZER_LIST(weak_factory_(this)),\n      ALLOW_THIS_IN_INITIALIZER_LIST(ssl_delegate_weak_factory_(this)),\n       is_shutdown_(false),\n       max_outstanding_requests_cost_per_process_(\n           kMaxOutstandingRequestsCostPerProcess),\n      filter_(NULL),\n      delegate_(NULL),\n      allow_cross_origin_auth_prompt_(false) {\n  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));\n  DCHECK(!g_resource_dispatcher_host);\n  g_resource_dispatcher_host = this;\n\n  GetContentClient()->browser()->ResourceDispatcherHostCreated();\n\n  ANNOTATE_BENIGN_RACE(\n      &last_user_gesture_time_,\n      \"We don't care about the precise value, see http://crbug.com/92889\");\n\n  BrowserThread::PostTask(\n      BrowserThread::IO, FROM_HERE,\n      base::Bind(&appcache::AppCacheInterceptor::EnsureRegistered));\n\n  update_load_states_timer_.reset(\n      new base::RepeatingTimer<ResourceDispatcherHostImpl>());\n}\n",
    "code_after_change": "ResourceDispatcherHostImpl::ResourceDispatcherHostImpl()\n     : download_file_manager_(new DownloadFileManager(NULL)),\n       save_file_manager_(new SaveFileManager()),\n       request_id_(-1),\n       is_shutdown_(false),\n       max_outstanding_requests_cost_per_process_(\n           kMaxOutstandingRequestsCostPerProcess),\n      filter_(NULL),\n      delegate_(NULL),\n      allow_cross_origin_auth_prompt_(false) {\n  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));\n  DCHECK(!g_resource_dispatcher_host);\n  g_resource_dispatcher_host = this;\n\n  GetContentClient()->browser()->ResourceDispatcherHostCreated();\n\n  ANNOTATE_BENIGN_RACE(\n      &last_user_gesture_time_,\n      \"We don't care about the precise value, see http://crbug.com/92889\");\n\n  BrowserThread::PostTask(\n      BrowserThread::IO, FROM_HERE,\n      base::Bind(&appcache::AppCacheInterceptor::EnsureRegistered));\n\n  update_load_states_timer_.reset(\n      new base::RepeatingTimer<ResourceDispatcherHostImpl>());\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 915,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-10066",
    "code_before_change": "static Image *ReadMONOImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  register IndexPacket\n    *indexes;\n\n  register PixelPacket\n    *q;\n\n  register ssize_t\n    x;\n\n  size_t\n    bit,\n    byte;\n\n  ssize_t\n    y;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  if ((image->columns == 0) || (image->rows == 0))\n    ThrowReaderException(OptionError,\"MustSpecifyImageSize\");\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (DiscardBlobBytes(image,image->offset) == MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  /*\n    Initialize image colormap.\n  */\n  image->depth=1;\n  if (AcquireImageColormap(image,2) == MagickFalse)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  if (image_info->ping != MagickFalse)\n    {\n       (void) CloseBlob(image);\n       return(GetFirstImageInList(image));\n     }\n   /*\n     Convert bi-level image to pixel packets.\n   */\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      break;\n    indexes=GetAuthenticIndexQueue(image);\n    bit=0;\n    byte=0;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if (bit == 0)\n        byte=(size_t) ReadBlobByte(image);\n      if (image_info->endian == LSBEndian)\n        SetPixelIndex(indexes+x,((byte & 0x01) != 0) ? 0x00 : 0x01)\n      else\n        SetPixelIndex(indexes+x,((byte & 0x01) != 0) ? 0x01 : 0x00)\n      bit++;\n      if (bit == 8)\n        bit=0;\n      byte>>=1;\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  (void) SyncImage(image);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n",
    "code_after_change": "static Image *ReadMONOImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  register IndexPacket\n    *indexes;\n\n  register PixelPacket\n    *q;\n\n  register ssize_t\n    x;\n\n  size_t\n    bit,\n    byte;\n\n  ssize_t\n    y;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  if ((image->columns == 0) || (image->rows == 0))\n    ThrowReaderException(OptionError,\"MustSpecifyImageSize\");\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (DiscardBlobBytes(image,image->offset) == MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  /*\n    Initialize image colormap.\n  */\n  image->depth=1;\n  if (AcquireImageColormap(image,2) == MagickFalse)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  if (image_info->ping != MagickFalse)\n    {\n       (void) CloseBlob(image);\n       return(GetFirstImageInList(image));\n     }\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n   /*\n     Convert bi-level image to pixel packets.\n   */\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      break;\n    indexes=GetAuthenticIndexQueue(image);\n    bit=0;\n    byte=0;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if (bit == 0)\n        byte=(size_t) ReadBlobByte(image);\n      if (image_info->endian == LSBEndian)\n        SetPixelIndex(indexes+x,((byte & 0x01) != 0) ? 0x00 : 0x01)\n      else\n        SetPixelIndex(indexes+x,((byte & 0x01) != 0) ? 0x01 : 0x00)\n      bit++;\n      if (bit == 8)\n        bit=0;\n      byte>>=1;\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  (void) SyncImage(image);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 922,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2012-0807",
    "code_before_change": " char *suhosin_encrypt_single_cookie(char *name, int name_len, char *value, int value_len, char *key TSRMLS_DC)\n {\n\tchar buffer[4096];\n    char buffer2[4096];\n\tchar *buf = buffer, *buf2 = buffer2, *d, *d_url;\n    int l;\n\tif (name_len > sizeof(buffer)-2) {\n\t\tbuf = estrndup(name, name_len);\n\t} else {\n\t\tmemcpy(buf, name, name_len);\n\t\tbuf[name_len] = 0;\n\t}\n \t\n \tname_len = php_url_decode(buf, name_len);\n    normalize_varname(buf);\n    name_len = strlen(buf);\n \t\n \tif (SUHOSIN_G(cookie_plainlist)) {\n \t\tif (zend_hash_exists(SUHOSIN_G(cookie_plainlist), buf, name_len+1)) {\n encrypt_return_plain:\n\t\t\tif (buf != buffer) {\n\t\t\t\tefree(buf);\n\t\t\t}\n \t\t\treturn estrndup(value, value_len);\n \t\t}\n \t} else if (SUHOSIN_G(cookie_cryptlist)) {\n\t\tif (!zend_hash_exists(SUHOSIN_G(cookie_cryptlist), buf, name_len+1)) {\n\t\t\tgoto encrypt_return_plain;\n \t\t}\n \t}\n \t\n\tif (strlen(value) <= sizeof(buffer2)-2) {\n\t\tmemcpy(buf2, value, value_len);\n\t\tbuf2[value_len] = 0;\n\t} else {\n\t\tbuf2 = estrndup(value, value_len);\n\t}\n \t\n \tvalue_len = php_url_decode(buf2, value_len);\n \t\n \td = suhosin_encrypt_string(buf2, value_len, buf, name_len, key TSRMLS_CC);\n \td_url = php_url_encode(d, strlen(d), &l);\n \tefree(d);\n    if (buf != buffer) {\n\t\tefree(buf);\n\t}\n    if (buf2 != buffer2) {\n\t\tefree(buf2);\n\t}\n \treturn d_url;\n }\n",
    "code_after_change": " char *suhosin_encrypt_single_cookie(char *name, int name_len, char *value, int value_len, char *key TSRMLS_DC)\n {\n\tchar *buf, *buf2, *d, *d_url;\n\tint l;\n\n\tbuf = estrndup(name, name_len);\n\t\n \t\n \tname_len = php_url_decode(buf, name_len);\n\tnormalize_varname(buf);\n\tname_len = strlen(buf);\n \t\n \tif (SUHOSIN_G(cookie_plainlist)) {\n \t\tif (zend_hash_exists(SUHOSIN_G(cookie_plainlist), buf, name_len+1)) {\n encrypt_return_plain:\n\t\t\tefree(buf);\n \t\t\treturn estrndup(value, value_len);\n \t\t}\n \t} else if (SUHOSIN_G(cookie_cryptlist)) {\n\t\tif (!zend_hash_exists(SUHOSIN_G(cookie_cryptlist), buf, name_len+1)) {\n\t\t\tgoto encrypt_return_plain;\n \t\t}\n \t}\n \t\n\tbuf2 = estrndup(value, value_len);\n \t\n \tvalue_len = php_url_decode(buf2, value_len);\n \t\n \td = suhosin_encrypt_string(buf2, value_len, buf, name_len, key TSRMLS_CC);\n \td_url = php_url_encode(d, strlen(d), &l);\n \tefree(d);\n\tefree(buf);\n\tefree(buf2);\n \treturn d_url;\n }\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 924,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2014-3478",
    "code_before_change": "mconvert(struct magic_set *ms, struct magic *m, int flip)\n{\n\tunion VALUETYPE *p = &ms->ms_value;\n\tuint8_t type;\n\n\tswitch (type = cvt_flip(m->type, flip)) {\n\tcase FILE_BYTE:\n\t\tcvt_8(p, m);\n\t\treturn 1;\n\tcase FILE_SHORT:\n\t\tcvt_16(p, m);\n\t\treturn 1;\n\tcase FILE_LONG:\n\tcase FILE_DATE:\n\tcase FILE_LDATE:\n\t\tcvt_32(p, m);\n\t\treturn 1;\n\tcase FILE_QUAD:\n\tcase FILE_QDATE:\n\tcase FILE_QLDATE:\n\tcase FILE_QWDATE:\n\t\tcvt_64(p, m);\n\t\treturn 1;\n\tcase FILE_STRING:\n\tcase FILE_BESTRING16:\n\tcase FILE_LESTRING16: {\n\t\t/* Null terminate and eat *trailing* return */\n\t\tp->s[sizeof(p->s) - 1] = '\\0';\n \t\treturn 1;\n \t}\n \tcase FILE_PSTRING: {\n\t\tchar *ptr1 = p->s, *ptr2 = ptr1 + file_pstring_length_size(m);\n \t\tsize_t len = file_pstring_get_length(m, ptr1);\n\t\tif (len >= sizeof(p->s))\n\t\t\tlen = sizeof(p->s) - 1;\n \t\twhile (len--)\n \t\t\t*ptr1++ = *ptr2++;\n \t\t*ptr1 = '\\0';\n\t\treturn 1;\n\t}\n\tcase FILE_BESHORT:\n\t\tp->h = (short)((p->hs[0]<<8)|(p->hs[1]));\n\t\tcvt_16(p, m);\n\t\treturn 1;\n\tcase FILE_BELONG:\n\tcase FILE_BEDATE:\n\tcase FILE_BELDATE:\n\t\tp->l = (int32_t)\n\t\t    ((p->hl[0]<<24)|(p->hl[1]<<16)|(p->hl[2]<<8)|(p->hl[3]));\n\t\tif (type == FILE_BELONG)\n\t\t\tcvt_32(p, m);\n\t\treturn 1;\n\tcase FILE_BEQUAD:\n\tcase FILE_BEQDATE:\n\tcase FILE_BEQLDATE:\n\tcase FILE_BEQWDATE:\n\t\tp->q = (uint64_t)\n\t\t    (((uint64_t)p->hq[0]<<56)|((uint64_t)p->hq[1]<<48)|\n\t\t     ((uint64_t)p->hq[2]<<40)|((uint64_t)p->hq[3]<<32)|\n\t\t     ((uint64_t)p->hq[4]<<24)|((uint64_t)p->hq[5]<<16)|\n\t\t     ((uint64_t)p->hq[6]<<8)|((uint64_t)p->hq[7]));\n\t\tif (type == FILE_BEQUAD)\n\t\t\tcvt_64(p, m);\n\t\treturn 1;\n\tcase FILE_LESHORT:\n\t\tp->h = (short)((p->hs[1]<<8)|(p->hs[0]));\n\t\tcvt_16(p, m);\n\t\treturn 1;\n\tcase FILE_LELONG:\n\tcase FILE_LEDATE:\n\tcase FILE_LELDATE:\n\t\tp->l = (int32_t)\n\t\t    ((p->hl[3]<<24)|(p->hl[2]<<16)|(p->hl[1]<<8)|(p->hl[0]));\n\t\tif (type == FILE_LELONG)\n\t\t\tcvt_32(p, m);\n\t\treturn 1;\n\tcase FILE_LEQUAD:\n\tcase FILE_LEQDATE:\n\tcase FILE_LEQLDATE:\n\tcase FILE_LEQWDATE:\n\t\tp->q = (uint64_t)\n\t\t    (((uint64_t)p->hq[7]<<56)|((uint64_t)p->hq[6]<<48)|\n\t\t     ((uint64_t)p->hq[5]<<40)|((uint64_t)p->hq[4]<<32)|\n\t\t     ((uint64_t)p->hq[3]<<24)|((uint64_t)p->hq[2]<<16)|\n\t\t     ((uint64_t)p->hq[1]<<8)|((uint64_t)p->hq[0]));\n\t\tif (type == FILE_LEQUAD)\n\t\t\tcvt_64(p, m);\n\t\treturn 1;\n\tcase FILE_MELONG:\n\tcase FILE_MEDATE:\n\tcase FILE_MELDATE:\n\t\tp->l = (int32_t)\n\t\t    ((p->hl[1]<<24)|(p->hl[0]<<16)|(p->hl[3]<<8)|(p->hl[2]));\n\t\tif (type == FILE_MELONG)\n\t\t\tcvt_32(p, m);\n\t\treturn 1;\n\tcase FILE_FLOAT:\n\t\tcvt_float(p, m);\n\t\treturn 1;\n\tcase FILE_BEFLOAT:\n\t\tp->l =  ((uint32_t)p->hl[0]<<24)|((uint32_t)p->hl[1]<<16)|\n\t\t\t((uint32_t)p->hl[2]<<8) |((uint32_t)p->hl[3]);\n\t\tcvt_float(p, m);\n\t\treturn 1;\n\tcase FILE_LEFLOAT:\n\t\tp->l =  ((uint32_t)p->hl[3]<<24)|((uint32_t)p->hl[2]<<16)|\n\t\t\t((uint32_t)p->hl[1]<<8) |((uint32_t)p->hl[0]);\n\t\tcvt_float(p, m);\n\t\treturn 1;\n\tcase FILE_DOUBLE:\n\t\tcvt_double(p, m);\n\t\treturn 1;\n\tcase FILE_BEDOUBLE:\n\t\tp->q =  ((uint64_t)p->hq[0]<<56)|((uint64_t)p->hq[1]<<48)|\n\t\t\t((uint64_t)p->hq[2]<<40)|((uint64_t)p->hq[3]<<32)|\n\t\t\t((uint64_t)p->hq[4]<<24)|((uint64_t)p->hq[5]<<16)|\n\t\t\t((uint64_t)p->hq[6]<<8) |((uint64_t)p->hq[7]);\n\t\tcvt_double(p, m);\n\t\treturn 1;\n\tcase FILE_LEDOUBLE:\n\t\tp->q =  ((uint64_t)p->hq[7]<<56)|((uint64_t)p->hq[6]<<48)|\n\t\t\t((uint64_t)p->hq[5]<<40)|((uint64_t)p->hq[4]<<32)|\n\t\t\t((uint64_t)p->hq[3]<<24)|((uint64_t)p->hq[2]<<16)|\n\t\t\t((uint64_t)p->hq[1]<<8) |((uint64_t)p->hq[0]);\n\t\tcvt_double(p, m);\n\t\treturn 1;\n\tcase FILE_REGEX:\n\tcase FILE_SEARCH:\n\tcase FILE_DEFAULT:\n\tcase FILE_CLEAR:\n\tcase FILE_NAME:\n\tcase FILE_USE:\n\t\treturn 1;\n\tdefault:\n\t\tfile_magerror(ms, \"invalid type %d in mconvert()\", m->type);\n\t\treturn 0;\n\t}\n}\n",
    "code_after_change": "mconvert(struct magic_set *ms, struct magic *m, int flip)\n{\n\tunion VALUETYPE *p = &ms->ms_value;\n\tuint8_t type;\n\n\tswitch (type = cvt_flip(m->type, flip)) {\n\tcase FILE_BYTE:\n\t\tcvt_8(p, m);\n\t\treturn 1;\n\tcase FILE_SHORT:\n\t\tcvt_16(p, m);\n\t\treturn 1;\n\tcase FILE_LONG:\n\tcase FILE_DATE:\n\tcase FILE_LDATE:\n\t\tcvt_32(p, m);\n\t\treturn 1;\n\tcase FILE_QUAD:\n\tcase FILE_QDATE:\n\tcase FILE_QLDATE:\n\tcase FILE_QWDATE:\n\t\tcvt_64(p, m);\n\t\treturn 1;\n\tcase FILE_STRING:\n\tcase FILE_BESTRING16:\n\tcase FILE_LESTRING16: {\n\t\t/* Null terminate and eat *trailing* return */\n\t\tp->s[sizeof(p->s) - 1] = '\\0';\n \t\treturn 1;\n \t}\n \tcase FILE_PSTRING: {\n\t\tsize_t sz = file_pstring_length_size(m);\n\t\tchar *ptr1 = p->s, *ptr2 = ptr1 + sz;\n \t\tsize_t len = file_pstring_get_length(m, ptr1);\n\t\tif (len >= sizeof(p->s)) {\n\t\t\t/*\n\t\t\t * The size of the pascal string length (sz)\n\t\t\t * is 1, 2, or 4. We need at least 1 byte for NUL\n\t\t\t * termination, but we've already truncated the\n\t\t\t * string by p->s, so we need to deduct sz.\n\t\t\t */ \n\t\t\tlen = sizeof(p->s) - sz;\n\t\t}\n \t\twhile (len--)\n \t\t\t*ptr1++ = *ptr2++;\n \t\t*ptr1 = '\\0';\n\t\treturn 1;\n\t}\n\tcase FILE_BESHORT:\n\t\tp->h = (short)((p->hs[0]<<8)|(p->hs[1]));\n\t\tcvt_16(p, m);\n\t\treturn 1;\n\tcase FILE_BELONG:\n\tcase FILE_BEDATE:\n\tcase FILE_BELDATE:\n\t\tp->l = (int32_t)\n\t\t    ((p->hl[0]<<24)|(p->hl[1]<<16)|(p->hl[2]<<8)|(p->hl[3]));\n\t\tif (type == FILE_BELONG)\n\t\t\tcvt_32(p, m);\n\t\treturn 1;\n\tcase FILE_BEQUAD:\n\tcase FILE_BEQDATE:\n\tcase FILE_BEQLDATE:\n\tcase FILE_BEQWDATE:\n\t\tp->q = (uint64_t)\n\t\t    (((uint64_t)p->hq[0]<<56)|((uint64_t)p->hq[1]<<48)|\n\t\t     ((uint64_t)p->hq[2]<<40)|((uint64_t)p->hq[3]<<32)|\n\t\t     ((uint64_t)p->hq[4]<<24)|((uint64_t)p->hq[5]<<16)|\n\t\t     ((uint64_t)p->hq[6]<<8)|((uint64_t)p->hq[7]));\n\t\tif (type == FILE_BEQUAD)\n\t\t\tcvt_64(p, m);\n\t\treturn 1;\n\tcase FILE_LESHORT:\n\t\tp->h = (short)((p->hs[1]<<8)|(p->hs[0]));\n\t\tcvt_16(p, m);\n\t\treturn 1;\n\tcase FILE_LELONG:\n\tcase FILE_LEDATE:\n\tcase FILE_LELDATE:\n\t\tp->l = (int32_t)\n\t\t    ((p->hl[3]<<24)|(p->hl[2]<<16)|(p->hl[1]<<8)|(p->hl[0]));\n\t\tif (type == FILE_LELONG)\n\t\t\tcvt_32(p, m);\n\t\treturn 1;\n\tcase FILE_LEQUAD:\n\tcase FILE_LEQDATE:\n\tcase FILE_LEQLDATE:\n\tcase FILE_LEQWDATE:\n\t\tp->q = (uint64_t)\n\t\t    (((uint64_t)p->hq[7]<<56)|((uint64_t)p->hq[6]<<48)|\n\t\t     ((uint64_t)p->hq[5]<<40)|((uint64_t)p->hq[4]<<32)|\n\t\t     ((uint64_t)p->hq[3]<<24)|((uint64_t)p->hq[2]<<16)|\n\t\t     ((uint64_t)p->hq[1]<<8)|((uint64_t)p->hq[0]));\n\t\tif (type == FILE_LEQUAD)\n\t\t\tcvt_64(p, m);\n\t\treturn 1;\n\tcase FILE_MELONG:\n\tcase FILE_MEDATE:\n\tcase FILE_MELDATE:\n\t\tp->l = (int32_t)\n\t\t    ((p->hl[1]<<24)|(p->hl[0]<<16)|(p->hl[3]<<8)|(p->hl[2]));\n\t\tif (type == FILE_MELONG)\n\t\t\tcvt_32(p, m);\n\t\treturn 1;\n\tcase FILE_FLOAT:\n\t\tcvt_float(p, m);\n\t\treturn 1;\n\tcase FILE_BEFLOAT:\n\t\tp->l =  ((uint32_t)p->hl[0]<<24)|((uint32_t)p->hl[1]<<16)|\n\t\t\t((uint32_t)p->hl[2]<<8) |((uint32_t)p->hl[3]);\n\t\tcvt_float(p, m);\n\t\treturn 1;\n\tcase FILE_LEFLOAT:\n\t\tp->l =  ((uint32_t)p->hl[3]<<24)|((uint32_t)p->hl[2]<<16)|\n\t\t\t((uint32_t)p->hl[1]<<8) |((uint32_t)p->hl[0]);\n\t\tcvt_float(p, m);\n\t\treturn 1;\n\tcase FILE_DOUBLE:\n\t\tcvt_double(p, m);\n\t\treturn 1;\n\tcase FILE_BEDOUBLE:\n\t\tp->q =  ((uint64_t)p->hq[0]<<56)|((uint64_t)p->hq[1]<<48)|\n\t\t\t((uint64_t)p->hq[2]<<40)|((uint64_t)p->hq[3]<<32)|\n\t\t\t((uint64_t)p->hq[4]<<24)|((uint64_t)p->hq[5]<<16)|\n\t\t\t((uint64_t)p->hq[6]<<8) |((uint64_t)p->hq[7]);\n\t\tcvt_double(p, m);\n\t\treturn 1;\n\tcase FILE_LEDOUBLE:\n\t\tp->q =  ((uint64_t)p->hq[7]<<56)|((uint64_t)p->hq[6]<<48)|\n\t\t\t((uint64_t)p->hq[5]<<40)|((uint64_t)p->hq[4]<<32)|\n\t\t\t((uint64_t)p->hq[3]<<24)|((uint64_t)p->hq[2]<<16)|\n\t\t\t((uint64_t)p->hq[1]<<8) |((uint64_t)p->hq[0]);\n\t\tcvt_double(p, m);\n\t\treturn 1;\n\tcase FILE_REGEX:\n\tcase FILE_SEARCH:\n\tcase FILE_DEFAULT:\n\tcase FILE_CLEAR:\n\tcase FILE_NAME:\n\tcase FILE_USE:\n\t\treturn 1;\n\tdefault:\n\t\tfile_magerror(ms, \"invalid type %d in mconvert()\", m->type);\n\t\treturn 0;\n\t}\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 927,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2019-1010208",
    "code_before_change": "NTSTATUS ProcessMainDeviceControlIrp (PDEVICE_OBJECT DeviceObject, PEXTENSION Extension, PIRP Irp)\n{\n\tPIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (Irp);\n\tNTSTATUS ntStatus;\n\n\tswitch (irpSp->Parameters.DeviceIoControl.IoControlCode)\n\t{\n\tcase TC_IOCTL_GET_DRIVER_VERSION:\n\tcase TC_IOCTL_LEGACY_GET_DRIVER_VERSION:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (LONG), ValidateOutput))\n\t\t{\n\t\t\tLONG tmp = VERSION_NUM;\n\t\t\tmemcpy (Irp->AssociatedIrp.SystemBuffer, &tmp, 4);\n\t\t\tIrp->IoStatus.Information = sizeof (LONG);\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_DEVICE_REFCOUNT:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (int), ValidateOutput))\n\t\t{\n\t\t\t*(int *) Irp->AssociatedIrp.SystemBuffer = DeviceObject->ReferenceCount;\n\t\t\tIrp->IoStatus.Information = sizeof (int);\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_IS_DRIVER_UNLOAD_DISABLED:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (int), ValidateOutput))\n\t\t{\n\t\t\tLONG deviceObjectCount = 0;\n\n\t\t\t*(int *) Irp->AssociatedIrp.SystemBuffer = DriverUnloadDisabled;\n\n\t\t\tif (IoEnumerateDeviceObjectList (TCDriverObject, NULL, 0, &deviceObjectCount) == STATUS_BUFFER_TOO_SMALL && deviceObjectCount > 1)\n\t\t\t\t*(int *) Irp->AssociatedIrp.SystemBuffer = TRUE;\n\n\t\t\tIrp->IoStatus.Information = sizeof (int);\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_IS_ANY_VOLUME_MOUNTED:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (int), ValidateOutput))\n\t\t{\n\t\t\tint drive;\n\t\t\t*(int *) Irp->AssociatedIrp.SystemBuffer = 0;\n\n\t\t\tfor (drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER; ++drive)\n\t\t\t{\n\t\t\t\tif (GetVirtualVolumeDeviceObject (drive))\n\t\t\t\t{\n\t\t\t\t\t*(int *) Irp->AssociatedIrp.SystemBuffer = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (IsBootDriveMounted())\n\t\t\t\t*(int *) Irp->AssociatedIrp.SystemBuffer = 1;\n\n\t\t\tIrp->IoStatus.Information = sizeof (int);\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_OPEN_TEST:\n\t\t{\n\t\t\tOPEN_TEST_STRUCT *opentest = (OPEN_TEST_STRUCT *) Irp->AssociatedIrp.SystemBuffer;\n\t\t\tOBJECT_ATTRIBUTES ObjectAttributes;\n\t\t\tHANDLE NtFileHandle;\n\t\t\tUNICODE_STRING FullFileName;\n\t\t\tIO_STATUS_BLOCK IoStatus;\n\t\t\tLARGE_INTEGER offset;\n\t\t\tACCESS_MASK access = FILE_READ_ATTRIBUTES;\n\n\t\t\tif (!ValidateIOBufferSize (Irp, sizeof (OPEN_TEST_STRUCT), ValidateInputOutput))\n\t\t\t\tbreak;\n\n\t\t\tEnsureNullTerminatedString (opentest->wszFileName, sizeof (opentest->wszFileName));\n\t\t\tRtlInitUnicodeString (&FullFileName, opentest->wszFileName);\n\n\t\t\tInitializeObjectAttributes (&ObjectAttributes, &FullFileName, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);\n\n\t\t\tif (opentest->bDetectTCBootLoader || opentest->DetectFilesystem || opentest->bComputeVolumeIDs)\n\t\t\t\taccess |= FILE_READ_DATA;\n\n\t\t\tntStatus = ZwCreateFile (&NtFileHandle,\n\t\t\t\t\t\t SYNCHRONIZE | access, &ObjectAttributes, &IoStatus, NULL,\n\t\t\t\t\t\t 0, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0);\n\n\t\t\tif (NT_SUCCESS (ntStatus))\n\t\t\t{\n\t\t\t\topentest->TCBootLoaderDetected = FALSE;\n\t\t\t\topentest->FilesystemDetected = FALSE;\n\t\t\t\tmemset (opentest->VolumeIDComputed, 0, sizeof (opentest->VolumeIDComputed));\n\t\t\t\tmemset (opentest->volumeIDs, 0, sizeof (opentest->volumeIDs));\n\n\t\t\t\tif (opentest->bDetectTCBootLoader || opentest->DetectFilesystem || opentest->bComputeVolumeIDs)\n\t\t\t\t{\n\t\t\t\t\tbyte *readBuffer = TCalloc (TC_MAX_VOLUME_SECTOR_SIZE);\n\t\t\t\t\tif (!readBuffer)\n\t\t\t\t\t{\n\t\t\t\t\t\tntStatus = STATUS_INSUFFICIENT_RESOURCES;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (opentest->bDetectTCBootLoader || opentest->DetectFilesystem)\n\t\t\t\t\t\t{\n\n\t\t\t\t\t\t\toffset.QuadPart = 0;\n\n\t\t\t\t\t\t\tntStatus = ZwReadFile (NtFileHandle,\n\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\t&IoStatus,\n\t\t\t\t\t\t\t\treadBuffer,\n\t\t\t\t\t\t\t\tTC_MAX_VOLUME_SECTOR_SIZE,\n\t\t\t\t\t\t\t\t&offset,\n\t\t\t\t\t\t\t\tNULL);\n\n\t\t\t\t\t\t\tif (NT_SUCCESS (ntStatus))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tsize_t i;\n\n\t\t\t\t\t\t\t\tif (opentest->bDetectTCBootLoader && IoStatus.Information >= TC_SECTOR_SIZE_BIOS)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tfor (i = 0; i < TC_SECTOR_SIZE_BIOS - strlen (TC_APP_NAME); ++i)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tif (memcmp (readBuffer + i, TC_APP_NAME, strlen (TC_APP_NAME)) == 0)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\topentest->TCBootLoaderDetected = TRUE;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (opentest->DetectFilesystem && IoStatus.Information >= sizeof (int64))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tswitch (BE64 (*(uint64 *) readBuffer))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tcase 0xEB52904E54465320ULL: // NTFS\n\t\t\t\t\t\t\t\t\tcase 0xEB3C904D53444F53ULL: // FAT16/FAT32\n\t\t\t\t\t\t\t\t\tcase 0xEB58904D53444F53ULL: // FAT32\n\t\t\t\t\t\t\t\t\tcase 0xEB76904558464154ULL: // exFAT\n\t\t\t\t\t\t\t\t\tcase 0x0000005265465300ULL: // ReFS\n\t\t\t\t\t\t\t\t\tcase 0xEB58906D6B66732EULL: // FAT32 mkfs.fat\n\t\t\t\t\t\t\t\t\tcase 0xEB58906D6B646F73ULL: // FAT32 mkfs.vfat/mkdosfs\n\t\t\t\t\t\t\t\t\tcase 0xEB3C906D6B66732EULL: // FAT16/FAT12 mkfs.fat\n\t\t\t\t\t\t\t\t\tcase 0xEB3C906D6B646F73ULL: // FAT16/FAT12 mkfs.vfat/mkdosfs\n\t\t\t\t\t\t\t\t\t\topentest->FilesystemDetected = TRUE;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase 0x0000000000000000ULL:\n\t\t\t\t\t\t\t\t\t\tif (IsAllZeroes (readBuffer + 8, TC_VOLUME_HEADER_EFFECTIVE_SIZE - 8))\n\t\t\t\t\t\t\t\t\t\t\topentest->FilesystemDetected = TRUE;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (opentest->bComputeVolumeIDs && (!opentest->DetectFilesystem || !opentest->FilesystemDetected))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint volumeType;\n\t\t\t\t\t\t\tfor (volumeType = TC_VOLUME_TYPE_NORMAL;\n\t\t\t\t\t\t\t\tvolumeType < TC_VOLUME_TYPE_COUNT;\n\t\t\t\t\t\t\t\tvolumeType++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t/* Read the volume header */\n\t\t\t\t\t\t\t\tswitch (volumeType)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcase TC_VOLUME_TYPE_NORMAL:\n\t\t\t\t\t\t\t\t\toffset.QuadPart = TC_VOLUME_HEADER_OFFSET;\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase TC_VOLUME_TYPE_HIDDEN:\n\n\t\t\t\t\t\t\t\t\toffset.QuadPart = TC_HIDDEN_VOLUME_HEADER_OFFSET;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tntStatus = ZwReadFile (NtFileHandle,\n\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\t&IoStatus,\n\t\t\t\t\t\t\t\treadBuffer,\n\t\t\t\t\t\t\t\tTC_MAX_VOLUME_SECTOR_SIZE,\n\t\t\t\t\t\t\t\t&offset,\n\t\t\t\t\t\t\t\tNULL);\n\n\t\t\t\t\t\t\t\tif (NT_SUCCESS (ntStatus))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t/* compute the ID of this volume: SHA-256 of the effective header */\n\t\t\t\t\t\t\t\t\tsha256 (opentest->volumeIDs[volumeType], readBuffer, TC_VOLUME_HEADER_EFFECTIVE_SIZE);\n\t\t\t\t\t\t\t\t\topentest->VolumeIDComputed[volumeType] = TRUE;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tTCfree (readBuffer);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tZwClose (NtFileHandle);\n\t\t\t\tDump (\"Open test on file %ls success.\\n\", opentest->wszFileName);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n#if 0\n\t\t\t\tDump (\"Open test on file %ls failed NTSTATUS 0x%08x\\n\", opentest->wszFileName, ntStatus);\n#endif\n\t\t\t}\n\n\t\t\tIrp->IoStatus.Information = NT_SUCCESS (ntStatus) ? sizeof (OPEN_TEST_STRUCT) : 0;\n\t\t\tIrp->IoStatus.Status = ntStatus;\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_SYSTEM_DRIVE_CONFIG:\n\t\t{\n\t\t\tGetSystemDriveConfigurationRequest *request = (GetSystemDriveConfigurationRequest *) Irp->AssociatedIrp.SystemBuffer;\n\t\t\tOBJECT_ATTRIBUTES ObjectAttributes;\n\t\t\tHANDLE NtFileHandle;\n \t\t\tUNICODE_STRING FullFileName;\n \t\t\tIO_STATUS_BLOCK IoStatus;\n \t\t\tLARGE_INTEGER offset;\n\t\t\tbyte readBuffer [TC_SECTOR_SIZE_BIOS];\n \n \t\t\tif (!ValidateIOBufferSize (Irp, sizeof (GetSystemDriveConfigurationRequest), ValidateInputOutput))\n \t\t\t\tbreak;\n \n \t\t\tEnsureNullTerminatedString (request->DevicePath, sizeof (request->DevicePath));\n \t\t\tRtlInitUnicodeString (&FullFileName, request->DevicePath);\n \n\t\t\tInitializeObjectAttributes (&ObjectAttributes, &FullFileName, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);\n\n\t\t\tntStatus = ZwCreateFile (&NtFileHandle,\n\t\t\t\tSYNCHRONIZE | GENERIC_READ, &ObjectAttributes, &IoStatus, NULL,\n\t\t\t\tFILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT | FILE_RANDOM_ACCESS, NULL, 0);\n \n \t\t\tif (NT_SUCCESS (ntStatus))\n \t\t\t{\n\t\t\t\toffset.QuadPart = 0;\t// MBR\n\t\t\t\tntStatus = ZwReadFile (NtFileHandle,\n\t\t\t\t\tNULL,\n\t\t\t\t\tNULL,\n\t\t\t\t\tNULL,\n\t\t\t\t\t&IoStatus,\n\t\t\t\t\treadBuffer,\n\t\t\t\t\tsizeof(readBuffer),\n\t\t\t\t\t&offset,\n\t\t\t\t\tNULL);\n\t\t\t\tif (NT_SUCCESS (ntStatus))\n \t\t\t\t{\n\t\t\t\t\tsize_t i;\n \n\t\t\t\t\trequest->DriveIsDynamic = FALSE;\n \n\t\t\t\t\tif (readBuffer[510] == 0x55 && readBuffer[511] == 0xaa)\n \t\t\t\t\t{\n\t\t\t\t\t\tint i;\n\t\t\t\t\t\tfor (i = 0; i < 4; ++i)\n \t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (readBuffer[446 + i * 16 + 4] == PARTITION_LDM)\n \t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\trequest->DriveIsDynamic = TRUE;\n\t\t\t\t\t\t\t\tbreak;\n \t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n \n\t\t\t\t\trequest->BootLoaderVersion = 0;\n\t\t\t\t\trequest->Configuration = 0;\n\t\t\t\t\trequest->UserConfiguration = 0;\n\t\t\t\t\trequest->CustomUserMessage[0] = 0;\n \n\t\t\t\t\tfor (i = 0; i < sizeof (readBuffer) - strlen (TC_APP_NAME); ++i)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (memcmp (readBuffer + i, TC_APP_NAME, strlen (TC_APP_NAME)) == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\trequest->BootLoaderVersion = BE16 (*(uint16 *) (readBuffer + TC_BOOT_SECTOR_VERSION_OFFSET));\n\t\t\t\t\t\t\trequest->Configuration = readBuffer[TC_BOOT_SECTOR_CONFIG_OFFSET];\n\t\t\t\t\t\t\tif (request->BootLoaderVersion != 0 && request->BootLoaderVersion <= VERSION_NUM)\n \t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\trequest->UserConfiguration = readBuffer[TC_BOOT_SECTOR_USER_CONFIG_OFFSET];\n\t\t\t\t\t\t\t\tmemcpy (request->CustomUserMessage, readBuffer + TC_BOOT_SECTOR_USER_MESSAGE_OFFSET, TC_BOOT_SECTOR_USER_MESSAGE_MAX_LENGTH);\n \t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n\t\t\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\t\t\tIrp->IoStatus.Information = sizeof (*request);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tIrp->IoStatus.Status = ntStatus;\n\t\t\t\t\tIrp->IoStatus.Information = 0;\n \t\t\t\t}\n \n \t\t\t\tZwClose (NtFileHandle);\n\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tIrp->IoStatus.Status = ntStatus;\n\t\t\t\tIrp->IoStatus.Information = 0;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_WIPE_PASSWORD_CACHE:\n\t\tWipeCache ();\n\n\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\tIrp->IoStatus.Information = 0;\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_PASSWORD_CACHE_STATUS:\n\t\tIrp->IoStatus.Status = cacheEmpty ? STATUS_PIPE_EMPTY : STATUS_SUCCESS;\n\t\tIrp->IoStatus.Information = 0;\n\t\tbreak;\n\n\tcase TC_IOCTL_SET_PORTABLE_MODE_STATUS:\n\t\tif (!UserCanAccessDriveDevice())\n\t\t{\n\t\t\tIrp->IoStatus.Status = STATUS_ACCESS_DENIED;\n\t\t\tIrp->IoStatus.Information = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tPortableMode = TRUE;\n\t\t\tDump (\"Setting portable mode\\n\");\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_PORTABLE_MODE_STATUS:\n\t\tIrp->IoStatus.Status = PortableMode ? STATUS_SUCCESS : STATUS_PIPE_EMPTY;\n\t\tIrp->IoStatus.Information = 0;\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_MOUNTED_VOLUMES:\n\n\t\tif (ValidateIOBufferSize (Irp, sizeof (MOUNT_LIST_STRUCT), ValidateOutput))\n\t\t{\n\t\t\tMOUNT_LIST_STRUCT *list = (MOUNT_LIST_STRUCT *) Irp->AssociatedIrp.SystemBuffer;\n\t\t\tPDEVICE_OBJECT ListDevice;\n\t\t\tint drive;\n\n\t\t\tlist->ulMountedDrives = 0;\n\n\t\t\tfor (drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER; ++drive)\n\t\t\t{\n\t\t\t\tPEXTENSION ListExtension;\n\n\t\t\t\tListDevice = GetVirtualVolumeDeviceObject (drive);\n\t\t\t\tif (!ListDevice)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tListExtension = (PEXTENSION) ListDevice->DeviceExtension;\n\t\t\t\tif (IsVolumeAccessibleByCurrentUser (ListExtension))\n\t\t\t\t{\n\t\t\t\t\tlist->ulMountedDrives |= (1 << ListExtension->nDosDriveNo);\n\t\t\t\t\tRtlStringCbCopyW (list->wszVolume[ListExtension->nDosDriveNo], sizeof(list->wszVolume[ListExtension->nDosDriveNo]),ListExtension->wszVolume);\n\t\t\t\t\tRtlStringCbCopyW (list->wszLabel[ListExtension->nDosDriveNo], sizeof(list->wszLabel[ListExtension->nDosDriveNo]),ListExtension->wszLabel);\n\t\t\t\t\tmemcpy (list->volumeID[ListExtension->nDosDriveNo], ListExtension->volumeID, VOLUME_ID_SIZE);\n\t\t\t\t\tlist->diskLength[ListExtension->nDosDriveNo] = ListExtension->DiskLength;\n\t\t\t\t\tlist->ea[ListExtension->nDosDriveNo] = ListExtension->cryptoInfo->ea;\n\t\t\t\t\tif (ListExtension->cryptoInfo->hiddenVolume)\n\t\t\t\t\t\tlist->volumeType[ListExtension->nDosDriveNo] = PROP_VOL_TYPE_HIDDEN;\t// Hidden volume\n\t\t\t\t\telse if (ListExtension->cryptoInfo->bHiddenVolProtectionAction)\n\t\t\t\t\t\tlist->volumeType[ListExtension->nDosDriveNo] = PROP_VOL_TYPE_OUTER_VOL_WRITE_PREVENTED;\t// Normal/outer volume (hidden volume protected AND write already prevented)\n\t\t\t\t\telse if (ListExtension->cryptoInfo->bProtectHiddenVolume)\n\t\t\t\t\t\tlist->volumeType[ListExtension->nDosDriveNo] = PROP_VOL_TYPE_OUTER;\t// Normal/outer volume (hidden volume protected)\n\t\t\t\t\telse\n\t\t\t\t\t\tlist->volumeType[ListExtension->nDosDriveNo] = PROP_VOL_TYPE_NORMAL;\t// Normal volume\n\t\t\t\t\tlist->truecryptMode[ListExtension->nDosDriveNo] = ListExtension->cryptoInfo->bTrueCryptMode;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\tIrp->IoStatus.Information = sizeof (MOUNT_LIST_STRUCT);\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_LEGACY_GET_MOUNTED_VOLUMES:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (uint32), ValidateOutput))\n\t\t{\n\n\t\t\tmemset (Irp->AssociatedIrp.SystemBuffer, 0, irpSp->Parameters.DeviceIoControl.OutputBufferLength);\n\t\t\t*(uint32 *) Irp->AssociatedIrp.SystemBuffer = 0xffffFFFF;\n\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\tIrp->IoStatus.Information = irpSp->Parameters.DeviceIoControl.OutputBufferLength;\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_VOLUME_PROPERTIES:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (VOLUME_PROPERTIES_STRUCT), ValidateInputOutput))\n\t\t{\n\t\t\tVOLUME_PROPERTIES_STRUCT *prop = (VOLUME_PROPERTIES_STRUCT *) Irp->AssociatedIrp.SystemBuffer;\n\t\t\tPDEVICE_OBJECT ListDevice = GetVirtualVolumeDeviceObject (prop->driveNo);\n\n\t\t\tIrp->IoStatus.Status = STATUS_INVALID_PARAMETER;\n\t\t\tIrp->IoStatus.Information = 0;\n\n\t\t\tif (ListDevice)\n\t\t\t{\n\t\t\t\tPEXTENSION ListExtension = (PEXTENSION) ListDevice->DeviceExtension;\n\t\t\t\tif (IsVolumeAccessibleByCurrentUser (ListExtension))\n\t\t\t\t{\n\t\t\t\t\tprop->uniqueId = ListExtension->UniqueVolumeId;\n\t\t\t\t\tRtlStringCbCopyW (prop->wszVolume, sizeof(prop->wszVolume),ListExtension->wszVolume);\n\t\t\t\t\tRtlStringCbCopyW (prop->wszLabel, sizeof(prop->wszLabel),ListExtension->wszLabel);\n\t\t\t\t\tmemcpy (prop->volumeID, ListExtension->volumeID, VOLUME_ID_SIZE);\n\t\t\t\t\tprop->bDriverSetLabel = ListExtension->bDriverSetLabel;\n\t\t\t\t\tprop->diskLength = ListExtension->DiskLength;\n\t\t\t\t\tprop->ea = ListExtension->cryptoInfo->ea;\n\t\t\t\t\tprop->mode = ListExtension->cryptoInfo->mode;\n\t\t\t\t\tprop->pkcs5 = ListExtension->cryptoInfo->pkcs5;\n\t\t\t\t\tprop->pkcs5Iterations = ListExtension->cryptoInfo->noIterations;\n\t\t\t\t\tprop->volumePim = ListExtension->cryptoInfo->volumePim;\n#if 0\n\t\t\t\t\tprop->volumeCreationTime = ListExtension->cryptoInfo->volume_creation_time;\n\t\t\t\t\tprop->headerCreationTime = ListExtension->cryptoInfo->header_creation_time;\n#endif\n\t\t\t\t\tprop->volumeHeaderFlags = ListExtension->cryptoInfo->HeaderFlags;\n\t\t\t\t\tprop->readOnly = ListExtension->bReadOnly;\n\t\t\t\t\tprop->removable = ListExtension->bRemovable;\n\t\t\t\t\tprop->partitionInInactiveSysEncScope = ListExtension->PartitionInInactiveSysEncScope;\n\t\t\t\t\tprop->hiddenVolume = ListExtension->cryptoInfo->hiddenVolume;\n\n\t\t\t\t\tif (ListExtension->cryptoInfo->bProtectHiddenVolume)\n\t\t\t\t\t\tprop->hiddenVolProtection = ListExtension->cryptoInfo->bHiddenVolProtectionAction ? HIDVOL_PROT_STATUS_ACTION_TAKEN : HIDVOL_PROT_STATUS_ACTIVE;\n\t\t\t\t\telse\n\t\t\t\t\t\tprop->hiddenVolProtection = HIDVOL_PROT_STATUS_NONE;\n\n\t\t\t\t\tprop->totalBytesRead = ListExtension->Queue.TotalBytesRead;\n\t\t\t\t\tprop->totalBytesWritten = ListExtension->Queue.TotalBytesWritten;\n\n\t\t\t\t\tprop->volFormatVersion = ListExtension->cryptoInfo->LegacyVolume ? TC_VOLUME_FORMAT_VERSION_PRE_6_0 : TC_VOLUME_FORMAT_VERSION;\n\n\t\t\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\t\t\tIrp->IoStatus.Information = sizeof (VOLUME_PROPERTIES_STRUCT);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_RESOLVED_SYMLINK:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (RESOLVE_SYMLINK_STRUCT), ValidateInputOutput))\n\t\t{\n\t\t\tRESOLVE_SYMLINK_STRUCT *resolve = (RESOLVE_SYMLINK_STRUCT *) Irp->AssociatedIrp.SystemBuffer;\n\t\t\t{\n\t\t\t\tNTSTATUS ntStatus;\n\n\t\t\t\tEnsureNullTerminatedString (resolve->symLinkName, sizeof (resolve->symLinkName));\n\n\t\t\t\tntStatus = SymbolicLinkToTarget (resolve->symLinkName,\n\t\t\t\t\tresolve->targetName,\n\t\t\t\t\tsizeof (resolve->targetName));\n\n\t\t\t\tIrp->IoStatus.Information = sizeof (RESOLVE_SYMLINK_STRUCT);\n\t\t\t\tIrp->IoStatus.Status = ntStatus;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_DRIVE_PARTITION_INFO:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (DISK_PARTITION_INFO_STRUCT), ValidateInputOutput))\n\t\t{\n\t\t\tDISK_PARTITION_INFO_STRUCT *info = (DISK_PARTITION_INFO_STRUCT *) Irp->AssociatedIrp.SystemBuffer;\n\t\t\t{\n\t\t\t\tPARTITION_INFORMATION_EX pi;\n\t\t\t\tNTSTATUS ntStatus;\n\n\t\t\t\tEnsureNullTerminatedString (info->deviceName, sizeof (info->deviceName));\n\n\t\t\t\tntStatus = TCDeviceIoControl (info->deviceName, IOCTL_DISK_GET_PARTITION_INFO_EX, NULL, 0, &pi, sizeof (pi));\n\t\t\t\tif (NT_SUCCESS(ntStatus))\n\t\t\t\t{\n\t\t\t\t\tmemset (&info->partInfo, 0, sizeof (info->partInfo));\n\n\t\t\t\t\tinfo->partInfo.PartitionLength = pi.PartitionLength;\n\t\t\t\t\tinfo->partInfo.PartitionNumber = pi.PartitionNumber;\n\t\t\t\t\tinfo->partInfo.StartingOffset = pi.StartingOffset;\n\n\t\t\t\t\tif (pi.PartitionStyle == PARTITION_STYLE_MBR)\n\t\t\t\t\t{\n\t\t\t\t\t\tinfo->partInfo.PartitionType = pi.Mbr.PartitionType;\n\t\t\t\t\t\tinfo->partInfo.BootIndicator = pi.Mbr.BootIndicator;\n\t\t\t\t\t}\n\n\t\t\t\t\tinfo->IsGPT = pi.PartitionStyle == PARTITION_STYLE_GPT;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tntStatus = TCDeviceIoControl (info->deviceName, IOCTL_DISK_GET_PARTITION_INFO, NULL, 0, &info->partInfo, sizeof (info->partInfo));\n\t\t\t\t\tinfo->IsGPT = FALSE;\n\t\t\t\t}\n\n\t\t\t\tif (!NT_SUCCESS (ntStatus))\n\t\t\t\t{\n\t\t\t\t\tGET_LENGTH_INFORMATION lengthInfo;\n\t\t\t\t\tntStatus = TCDeviceIoControl (info->deviceName, IOCTL_DISK_GET_LENGTH_INFO, NULL, 0, &lengthInfo, sizeof (lengthInfo));\n\n\t\t\t\t\tif (NT_SUCCESS (ntStatus))\n\t\t\t\t\t{\n\t\t\t\t\t\tmemset (&info->partInfo, 0, sizeof (info->partInfo));\n\t\t\t\t\t\tinfo->partInfo.PartitionLength = lengthInfo.Length;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tinfo->IsDynamic = FALSE;\n\n\t\t\t\tif (NT_SUCCESS (ntStatus) && OsMajorVersion >= 6)\n\t\t\t\t{\n#\t\t\t\t\tdefine IOCTL_VOLUME_IS_DYNAMIC CTL_CODE(IOCTL_VOLUME_BASE, 18, METHOD_BUFFERED, FILE_ANY_ACCESS)\n\t\t\t\t\tif (!NT_SUCCESS (TCDeviceIoControl (info->deviceName, IOCTL_VOLUME_IS_DYNAMIC, NULL, 0, &info->IsDynamic, sizeof (info->IsDynamic))))\n\t\t\t\t\t\tinfo->IsDynamic = FALSE;\n\t\t\t\t}\n\n\t\t\t\tIrp->IoStatus.Information = sizeof (DISK_PARTITION_INFO_STRUCT);\n\t\t\t\tIrp->IoStatus.Status = ntStatus;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_DRIVE_GEOMETRY:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (DISK_GEOMETRY_STRUCT), ValidateInputOutput))\n\t\t{\n\t\t\tDISK_GEOMETRY_STRUCT *g = (DISK_GEOMETRY_STRUCT *) Irp->AssociatedIrp.SystemBuffer;\n\t\t\t{\n\t\t\t\tNTSTATUS ntStatus;\n\n\t\t\t\tEnsureNullTerminatedString (g->deviceName, sizeof (g->deviceName));\n\t\t\t\tDump (\"Calling IOCTL_DISK_GET_DRIVE_GEOMETRY on %ls\\n\", g->deviceName);\n\n\t\t\t\tntStatus = TCDeviceIoControl (g->deviceName,\n\t\t\t\t\tIOCTL_DISK_GET_DRIVE_GEOMETRY,\n\t\t\t\t\tNULL, 0, &g->diskGeometry, sizeof (g->diskGeometry));\n\n\t\t\t\tIrp->IoStatus.Information = sizeof (DISK_GEOMETRY_STRUCT);\n\t\t\t\tIrp->IoStatus.Status = ntStatus;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase VC_IOCTL_GET_DRIVE_GEOMETRY_EX:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (DISK_GEOMETRY_EX_STRUCT), ValidateInputOutput))\n\t\t{\n\t\t\tDISK_GEOMETRY_EX_STRUCT *g = (DISK_GEOMETRY_EX_STRUCT *) Irp->AssociatedIrp.SystemBuffer;\n\t\t\t{\n\t\t\t\tNTSTATUS ntStatus;\n\t\t\t\tPVOID buffer = TCalloc (256); // enough for DISK_GEOMETRY_EX and padded data\n\t\t\t\tif (buffer)\n\t\t\t\t{\n\t\t\t\t\tEnsureNullTerminatedString (g->deviceName, sizeof (g->deviceName));\n\t\t\t\t\tDump (\"Calling IOCTL_DISK_GET_DRIVE_GEOMETRY_EX on %ls\\n\", g->deviceName);\n\n\t\t\t\t\tntStatus = TCDeviceIoControl (g->deviceName,\n\t\t\t\t\t\tIOCTL_DISK_GET_DRIVE_GEOMETRY_EX,\n\t\t\t\t\t\tNULL, 0, buffer, 256);\n\n\t\t\t\t\tif (NT_SUCCESS(ntStatus))\n\t\t\t\t\t{\n\t\t\t\t\t\tPDISK_GEOMETRY_EX pGeo = (PDISK_GEOMETRY_EX) buffer;\n\t\t\t\t\t\tmemcpy (&g->diskGeometry, &pGeo->Geometry, sizeof (DISK_GEOMETRY));\n\t\t\t\t\t\tg->DiskSize.QuadPart = pGeo->DiskSize.QuadPart;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tDISK_GEOMETRY dg = {0};\n\t\t\t\t\t\tDump (\"Failed. Calling IOCTL_DISK_GET_DRIVE_GEOMETRY on %ls\\n\", g->deviceName);\n\t\t\t\t\t\tntStatus = TCDeviceIoControl (g->deviceName,\n\t\t\t\t\t\t\tIOCTL_DISK_GET_DRIVE_GEOMETRY,\n\t\t\t\t\t\t\tNULL, 0, &dg, sizeof (dg));\n\n\t\t\t\t\t\tif (NT_SUCCESS(ntStatus))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmemcpy (&g->diskGeometry, &dg, sizeof (DISK_GEOMETRY));\n\t\t\t\t\t\t\tg->DiskSize.QuadPart = dg.Cylinders.QuadPart * dg.SectorsPerTrack * dg.TracksPerCylinder * dg.BytesPerSector;\n\n\t\t\t\t\t\t\tif (OsMajorVersion >= 6)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tSTORAGE_READ_CAPACITY storage = {0};\n\t\t\t\t\t\t\t\tNTSTATUS lStatus;\n\t\t\t\t\t\t\t\tstorage.Version = sizeof (STORAGE_READ_CAPACITY);\n\t\t\t\t\t\t\t\tDump (\"Calling IOCTL_STORAGE_READ_CAPACITY on %ls\\n\", g->deviceName);\n\t\t\t\t\t\t\t\tlStatus = TCDeviceIoControl (g->deviceName,\n\t\t\t\t\t\t\t\t\tIOCTL_STORAGE_READ_CAPACITY,\n\t\t\t\t\t\t\t\t\tNULL, 0, &storage, sizeof (STORAGE_READ_CAPACITY));\n\t\t\t\t\t\t\t\tif (\tNT_SUCCESS(lStatus)\n\t\t\t\t\t\t\t\t\t&& (storage.Size == sizeof (STORAGE_READ_CAPACITY))\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tg->DiskSize.QuadPart = storage.DiskLength.QuadPart;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tTCfree (buffer);\n\n\t\t\t\t\tIrp->IoStatus.Information = sizeof (DISK_GEOMETRY_EX_STRUCT);\n\t\t\t\t\tIrp->IoStatus.Status = ntStatus;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tIrp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;\n\t\t\t\t\tIrp->IoStatus.Information = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_PROBE_REAL_DRIVE_SIZE:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (ProbeRealDriveSizeRequest), ValidateInputOutput))\n\t\t{\n\t\t\tProbeRealDriveSizeRequest *request = (ProbeRealDriveSizeRequest *) Irp->AssociatedIrp.SystemBuffer;\n\t\t\tNTSTATUS status;\n\t\t\tUNICODE_STRING name;\n\t\t\tPFILE_OBJECT fileObject;\n\t\t\tPDEVICE_OBJECT deviceObject;\n\n\t\t\tEnsureNullTerminatedString (request->DeviceName, sizeof (request->DeviceName));\n\n\t\t\tRtlInitUnicodeString (&name, request->DeviceName);\n\t\t\tstatus = IoGetDeviceObjectPointer (&name, FILE_READ_ATTRIBUTES, &fileObject, &deviceObject);\n\t\t\tif (!NT_SUCCESS (status))\n\t\t\t{\n\t\t\t\tIrp->IoStatus.Information = 0;\n\t\t\t\tIrp->IoStatus.Status = status;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tstatus = ProbeRealDriveSize (deviceObject, &request->RealDriveSize);\n\t\t\tObDereferenceObject (fileObject);\n\n\t\t\tif (status == STATUS_TIMEOUT)\n\t\t\t{\n\t\t\t\trequest->TimeOut = TRUE;\n\t\t\t\tIrp->IoStatus.Information = sizeof (ProbeRealDriveSizeRequest);\n\t\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\t}\n\t\t\telse if (!NT_SUCCESS (status))\n\t\t\t{\n\t\t\t\tIrp->IoStatus.Information = 0;\n\t\t\t\tIrp->IoStatus.Status = status;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\trequest->TimeOut = FALSE;\n\t\t\t\tIrp->IoStatus.Information = sizeof (ProbeRealDriveSizeRequest);\n\t\t\t\tIrp->IoStatus.Status = status;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_MOUNT_VOLUME:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (MOUNT_STRUCT), ValidateInputOutput))\n\t\t{\n\t\t\tMOUNT_STRUCT *mount = (MOUNT_STRUCT *) Irp->AssociatedIrp.SystemBuffer;\n\n\t\t\tif (mount->VolumePassword.Length > MAX_PASSWORD || mount->ProtectedHidVolPassword.Length > MAX_PASSWORD\n\t\t\t\t||\tmount->pkcs5_prf < 0 || mount->pkcs5_prf > LAST_PRF_ID\n\t\t\t\t||\tmount->VolumePim < -1 || mount->VolumePim == INT_MAX\n\t\t\t\t|| mount->ProtectedHidVolPkcs5Prf < 0 || mount->ProtectedHidVolPkcs5Prf > LAST_PRF_ID\n\t\t\t\t|| (mount->bTrueCryptMode != FALSE && mount->bTrueCryptMode != TRUE)\n\t\t\t\t)\n\t\t\t{\n\t\t\t\tIrp->IoStatus.Status = STATUS_INVALID_PARAMETER;\n\t\t\t\tIrp->IoStatus.Information = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tEnsureNullTerminatedString (mount->wszVolume, sizeof (mount->wszVolume));\n\t\t\tEnsureNullTerminatedString (mount->wszLabel, sizeof (mount->wszLabel));\n\n\t\t\tIrp->IoStatus.Information = sizeof (MOUNT_STRUCT);\n\t\t\tIrp->IoStatus.Status = MountDevice (DeviceObject, mount);\n\n\t\t\tburn (&mount->VolumePassword, sizeof (mount->VolumePassword));\n\t\t\tburn (&mount->ProtectedHidVolPassword, sizeof (mount->ProtectedHidVolPassword));\n\t\t\tburn (&mount->pkcs5_prf, sizeof (mount->pkcs5_prf));\n\t\t\tburn (&mount->VolumePim, sizeof (mount->VolumePim));\n\t\t\tburn (&mount->bTrueCryptMode, sizeof (mount->bTrueCryptMode));\n\t\t\tburn (&mount->ProtectedHidVolPkcs5Prf, sizeof (mount->ProtectedHidVolPkcs5Prf));\n\t\t\tburn (&mount->ProtectedHidVolPim, sizeof (mount->ProtectedHidVolPim));\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_DISMOUNT_VOLUME:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (UNMOUNT_STRUCT), ValidateInputOutput))\n\t\t{\n\t\t\tUNMOUNT_STRUCT *unmount = (UNMOUNT_STRUCT *) Irp->AssociatedIrp.SystemBuffer;\n\t\t\tPDEVICE_OBJECT ListDevice = GetVirtualVolumeDeviceObject (unmount->nDosDriveNo);\n\n\t\t\tunmount->nReturnCode = ERR_DRIVE_NOT_FOUND;\n\n\t\t\tif (ListDevice)\n\t\t\t{\n\t\t\t\tPEXTENSION ListExtension = (PEXTENSION) ListDevice->DeviceExtension;\n\n\t\t\t\tif (IsVolumeAccessibleByCurrentUser (ListExtension))\n\t\t\t\t\tunmount->nReturnCode = UnmountDevice (unmount, ListDevice, unmount->ignoreOpenFiles);\n\t\t\t}\n\n\t\t\tIrp->IoStatus.Information = sizeof (UNMOUNT_STRUCT);\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_DISMOUNT_ALL_VOLUMES:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (UNMOUNT_STRUCT), ValidateInputOutput))\n\t\t{\n\t\t\tUNMOUNT_STRUCT *unmount = (UNMOUNT_STRUCT *) Irp->AssociatedIrp.SystemBuffer;\n\n\t\t\tunmount->nReturnCode = UnmountAllDevices (unmount, unmount->ignoreOpenFiles);\n\n\t\t\tIrp->IoStatus.Information = sizeof (UNMOUNT_STRUCT);\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_BOOT_ENCRYPTION_SETUP:\n\t\tIrp->IoStatus.Status = StartBootEncryptionSetup (DeviceObject, Irp, irpSp);\n\t\tIrp->IoStatus.Information = 0;\n\t\tbreak;\n\n\tcase TC_IOCTL_ABORT_BOOT_ENCRYPTION_SETUP:\n\t\tIrp->IoStatus.Status = AbortBootEncryptionSetup();\n\t\tIrp->IoStatus.Information = 0;\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_BOOT_ENCRYPTION_STATUS:\n\t\tGetBootEncryptionStatus (Irp, irpSp);\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_BOOT_ENCRYPTION_SETUP_RESULT:\n\t\tIrp->IoStatus.Information = 0;\n\t\tIrp->IoStatus.Status = GetSetupResult();\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_BOOT_DRIVE_VOLUME_PROPERTIES:\n\t\tGetBootDriveVolumeProperties (Irp, irpSp);\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_BOOT_LOADER_VERSION:\n\t\tGetBootLoaderVersion (Irp, irpSp);\n\t\tbreak;\n\n\tcase TC_IOCTL_REOPEN_BOOT_VOLUME_HEADER:\n\t\tReopenBootVolumeHeader (Irp, irpSp);\n\t\tbreak;\n\n\tcase VC_IOCTL_GET_BOOT_LOADER_FINGERPRINT:\n\t\tGetBootLoaderFingerprint (Irp, irpSp);\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_BOOT_ENCRYPTION_ALGORITHM_NAME:\n\t\tGetBootEncryptionAlgorithmName (Irp, irpSp);\n\t\tbreak;\n\n\tcase TC_IOCTL_IS_HIDDEN_SYSTEM_RUNNING:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (int), ValidateOutput))\n\t\t{\n\t\t\t*(int *) Irp->AssociatedIrp.SystemBuffer = IsHiddenSystemRunning() ? 1 : 0;\n\t\t\tIrp->IoStatus.Information = sizeof (int);\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_START_DECOY_SYSTEM_WIPE:\n\t\tIrp->IoStatus.Status = StartDecoySystemWipe (DeviceObject, Irp, irpSp);\n\t\tIrp->IoStatus.Information = 0;\n\t\tbreak;\n\n\tcase TC_IOCTL_ABORT_DECOY_SYSTEM_WIPE:\n\t\tIrp->IoStatus.Status = AbortDecoySystemWipe();\n\t\tIrp->IoStatus.Information = 0;\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_DECOY_SYSTEM_WIPE_RESULT:\n\t\tIrp->IoStatus.Status = GetDecoySystemWipeResult();\n\t\tIrp->IoStatus.Information = 0;\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_DECOY_SYSTEM_WIPE_STATUS:\n\t\tGetDecoySystemWipeStatus (Irp, irpSp);\n\t\tbreak;\n\n\tcase TC_IOCTL_WRITE_BOOT_DRIVE_SECTOR:\n\t\tIrp->IoStatus.Status = WriteBootDriveSector (Irp, irpSp);\n\t\tIrp->IoStatus.Information = 0;\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_WARNING_FLAGS:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (GetWarningFlagsRequest), ValidateOutput))\n\t\t{\n\t\t\tGetWarningFlagsRequest *flags = (GetWarningFlagsRequest *) Irp->AssociatedIrp.SystemBuffer;\n\n\t\t\tflags->PagingFileCreationPrevented = PagingFileCreationPrevented;\n\t\t\tPagingFileCreationPrevented = FALSE;\n\t\t\tflags->SystemFavoriteVolumeDirty = SystemFavoriteVolumeDirty;\n\t\t\tSystemFavoriteVolumeDirty = FALSE;\n\n\t\t\tIrp->IoStatus.Information = sizeof (GetWarningFlagsRequest);\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_SET_SYSTEM_FAVORITE_VOLUME_DIRTY:\n\t\tif (UserCanAccessDriveDevice())\n\t\t{\n\t\t\tSystemFavoriteVolumeDirty = TRUE;\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t}\n\t\telse\n\t\t\tIrp->IoStatus.Status = STATUS_ACCESS_DENIED;\n\n\t\tIrp->IoStatus.Information = 0;\n\t\tbreak;\n\n\tcase TC_IOCTL_REREAD_DRIVER_CONFIG:\n\t\tIrp->IoStatus.Status = ReadRegistryConfigFlags (FALSE);\n\t\tIrp->IoStatus.Information = 0;\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_SYSTEM_DRIVE_DUMP_CONFIG:\n\t\tif (\t(ValidateIOBufferSize (Irp, sizeof (GetSystemDriveDumpConfigRequest), ValidateOutput))\n\t\t\t&&\t(Irp->RequestorMode == KernelMode)\n\t\t\t)\n\t\t{\n\t\t\tGetSystemDriveDumpConfigRequest *request = (GetSystemDriveDumpConfigRequest *) Irp->AssociatedIrp.SystemBuffer;\n\n\t\t\trequest->BootDriveFilterExtension = GetBootDriveFilterExtension();\n\t\t\tif (IsBootDriveMounted() && request->BootDriveFilterExtension)\n\t\t\t{\n\t\t\t\trequest->HwEncryptionEnabled = IsHwEncryptionEnabled();\n\t\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\t\tIrp->IoStatus.Information = sizeof (*request);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tIrp->IoStatus.Status = STATUS_INVALID_PARAMETER;\n\t\t\t\tIrp->IoStatus.Information = 0;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn TCCompleteIrp (Irp, STATUS_INVALID_DEVICE_REQUEST, 0);\n\t}\n\n\n#if defined(DEBUG) || defined(DEBUG_TRACE)\n\tif (!NT_SUCCESS (Irp->IoStatus.Status))\n\t{\n\t\tswitch (irpSp->Parameters.DeviceIoControl.IoControlCode)\n\t\t{\n\t\tcase TC_IOCTL_GET_MOUNTED_VOLUMES:\n\t\tcase TC_IOCTL_GET_PASSWORD_CACHE_STATUS:\n\t\tcase TC_IOCTL_GET_PORTABLE_MODE_STATUS:\n\t\tcase TC_IOCTL_SET_PORTABLE_MODE_STATUS:\n\t\tcase TC_IOCTL_OPEN_TEST:\n\t\tcase TC_IOCTL_GET_RESOLVED_SYMLINK:\n\t\tcase TC_IOCTL_GET_DRIVE_PARTITION_INFO:\n\t\tcase TC_IOCTL_GET_BOOT_DRIVE_VOLUME_PROPERTIES:\n\t\tcase TC_IOCTL_GET_BOOT_ENCRYPTION_STATUS:\n\t\tcase TC_IOCTL_IS_HIDDEN_SYSTEM_RUNNING:\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tDump (\"IOCTL error 0x%08x\\n\", Irp->IoStatus.Status);\n\t\t}\n\t}\n#endif\n\n\treturn TCCompleteIrp (Irp, Irp->IoStatus.Status, Irp->IoStatus.Information);\n}\n",
    "code_after_change": "NTSTATUS ProcessMainDeviceControlIrp (PDEVICE_OBJECT DeviceObject, PEXTENSION Extension, PIRP Irp)\n{\n\tPIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (Irp);\n\tNTSTATUS ntStatus;\n\n\tswitch (irpSp->Parameters.DeviceIoControl.IoControlCode)\n\t{\n\tcase TC_IOCTL_GET_DRIVER_VERSION:\n\tcase TC_IOCTL_LEGACY_GET_DRIVER_VERSION:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (LONG), ValidateOutput))\n\t\t{\n\t\t\tLONG tmp = VERSION_NUM;\n\t\t\tmemcpy (Irp->AssociatedIrp.SystemBuffer, &tmp, 4);\n\t\t\tIrp->IoStatus.Information = sizeof (LONG);\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_DEVICE_REFCOUNT:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (int), ValidateOutput))\n\t\t{\n\t\t\t*(int *) Irp->AssociatedIrp.SystemBuffer = DeviceObject->ReferenceCount;\n\t\t\tIrp->IoStatus.Information = sizeof (int);\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_IS_DRIVER_UNLOAD_DISABLED:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (int), ValidateOutput))\n\t\t{\n\t\t\tLONG deviceObjectCount = 0;\n\n\t\t\t*(int *) Irp->AssociatedIrp.SystemBuffer = DriverUnloadDisabled;\n\n\t\t\tif (IoEnumerateDeviceObjectList (TCDriverObject, NULL, 0, &deviceObjectCount) == STATUS_BUFFER_TOO_SMALL && deviceObjectCount > 1)\n\t\t\t\t*(int *) Irp->AssociatedIrp.SystemBuffer = TRUE;\n\n\t\t\tIrp->IoStatus.Information = sizeof (int);\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_IS_ANY_VOLUME_MOUNTED:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (int), ValidateOutput))\n\t\t{\n\t\t\tint drive;\n\t\t\t*(int *) Irp->AssociatedIrp.SystemBuffer = 0;\n\n\t\t\tfor (drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER; ++drive)\n\t\t\t{\n\t\t\t\tif (GetVirtualVolumeDeviceObject (drive))\n\t\t\t\t{\n\t\t\t\t\t*(int *) Irp->AssociatedIrp.SystemBuffer = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (IsBootDriveMounted())\n\t\t\t\t*(int *) Irp->AssociatedIrp.SystemBuffer = 1;\n\n\t\t\tIrp->IoStatus.Information = sizeof (int);\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_OPEN_TEST:\n\t\t{\n\t\t\tOPEN_TEST_STRUCT *opentest = (OPEN_TEST_STRUCT *) Irp->AssociatedIrp.SystemBuffer;\n\t\t\tOBJECT_ATTRIBUTES ObjectAttributes;\n\t\t\tHANDLE NtFileHandle;\n\t\t\tUNICODE_STRING FullFileName;\n\t\t\tIO_STATUS_BLOCK IoStatus;\n\t\t\tLARGE_INTEGER offset;\n\t\t\tACCESS_MASK access = FILE_READ_ATTRIBUTES;\n\n\t\t\tif (!ValidateIOBufferSize (Irp, sizeof (OPEN_TEST_STRUCT), ValidateInputOutput))\n\t\t\t\tbreak;\n\n\t\t\tEnsureNullTerminatedString (opentest->wszFileName, sizeof (opentest->wszFileName));\n\t\t\tRtlInitUnicodeString (&FullFileName, opentest->wszFileName);\n\n\t\t\tInitializeObjectAttributes (&ObjectAttributes, &FullFileName, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);\n\n\t\t\tif (opentest->bDetectTCBootLoader || opentest->DetectFilesystem || opentest->bComputeVolumeIDs)\n\t\t\t\taccess |= FILE_READ_DATA;\n\n\t\t\tntStatus = ZwCreateFile (&NtFileHandle,\n\t\t\t\t\t\t SYNCHRONIZE | access, &ObjectAttributes, &IoStatus, NULL,\n\t\t\t\t\t\t 0, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0);\n\n\t\t\tif (NT_SUCCESS (ntStatus))\n\t\t\t{\n\t\t\t\topentest->TCBootLoaderDetected = FALSE;\n\t\t\t\topentest->FilesystemDetected = FALSE;\n\t\t\t\tmemset (opentest->VolumeIDComputed, 0, sizeof (opentest->VolumeIDComputed));\n\t\t\t\tmemset (opentest->volumeIDs, 0, sizeof (opentest->volumeIDs));\n\n\t\t\t\tif (opentest->bDetectTCBootLoader || opentest->DetectFilesystem || opentest->bComputeVolumeIDs)\n\t\t\t\t{\n\t\t\t\t\tbyte *readBuffer = TCalloc (TC_MAX_VOLUME_SECTOR_SIZE);\n\t\t\t\t\tif (!readBuffer)\n\t\t\t\t\t{\n\t\t\t\t\t\tntStatus = STATUS_INSUFFICIENT_RESOURCES;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (opentest->bDetectTCBootLoader || opentest->DetectFilesystem)\n\t\t\t\t\t\t{\n\n\t\t\t\t\t\t\toffset.QuadPart = 0;\n\n\t\t\t\t\t\t\tntStatus = ZwReadFile (NtFileHandle,\n\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\t&IoStatus,\n\t\t\t\t\t\t\t\treadBuffer,\n\t\t\t\t\t\t\t\tTC_MAX_VOLUME_SECTOR_SIZE,\n\t\t\t\t\t\t\t\t&offset,\n\t\t\t\t\t\t\t\tNULL);\n\n\t\t\t\t\t\t\tif (NT_SUCCESS (ntStatus))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tsize_t i;\n\n\t\t\t\t\t\t\t\tif (opentest->bDetectTCBootLoader && IoStatus.Information >= TC_SECTOR_SIZE_BIOS)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tfor (i = 0; i < TC_SECTOR_SIZE_BIOS - strlen (TC_APP_NAME); ++i)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tif (memcmp (readBuffer + i, TC_APP_NAME, strlen (TC_APP_NAME)) == 0)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\topentest->TCBootLoaderDetected = TRUE;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (opentest->DetectFilesystem && IoStatus.Information >= sizeof (int64))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tswitch (BE64 (*(uint64 *) readBuffer))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tcase 0xEB52904E54465320ULL: // NTFS\n\t\t\t\t\t\t\t\t\tcase 0xEB3C904D53444F53ULL: // FAT16/FAT32\n\t\t\t\t\t\t\t\t\tcase 0xEB58904D53444F53ULL: // FAT32\n\t\t\t\t\t\t\t\t\tcase 0xEB76904558464154ULL: // exFAT\n\t\t\t\t\t\t\t\t\tcase 0x0000005265465300ULL: // ReFS\n\t\t\t\t\t\t\t\t\tcase 0xEB58906D6B66732EULL: // FAT32 mkfs.fat\n\t\t\t\t\t\t\t\t\tcase 0xEB58906D6B646F73ULL: // FAT32 mkfs.vfat/mkdosfs\n\t\t\t\t\t\t\t\t\tcase 0xEB3C906D6B66732EULL: // FAT16/FAT12 mkfs.fat\n\t\t\t\t\t\t\t\t\tcase 0xEB3C906D6B646F73ULL: // FAT16/FAT12 mkfs.vfat/mkdosfs\n\t\t\t\t\t\t\t\t\t\topentest->FilesystemDetected = TRUE;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase 0x0000000000000000ULL:\n\t\t\t\t\t\t\t\t\t\tif (IsAllZeroes (readBuffer + 8, TC_VOLUME_HEADER_EFFECTIVE_SIZE - 8))\n\t\t\t\t\t\t\t\t\t\t\topentest->FilesystemDetected = TRUE;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (opentest->bComputeVolumeIDs && (!opentest->DetectFilesystem || !opentest->FilesystemDetected))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint volumeType;\n\t\t\t\t\t\t\tfor (volumeType = TC_VOLUME_TYPE_NORMAL;\n\t\t\t\t\t\t\t\tvolumeType < TC_VOLUME_TYPE_COUNT;\n\t\t\t\t\t\t\t\tvolumeType++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t/* Read the volume header */\n\t\t\t\t\t\t\t\tswitch (volumeType)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcase TC_VOLUME_TYPE_NORMAL:\n\t\t\t\t\t\t\t\t\toffset.QuadPart = TC_VOLUME_HEADER_OFFSET;\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase TC_VOLUME_TYPE_HIDDEN:\n\n\t\t\t\t\t\t\t\t\toffset.QuadPart = TC_HIDDEN_VOLUME_HEADER_OFFSET;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tntStatus = ZwReadFile (NtFileHandle,\n\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\t&IoStatus,\n\t\t\t\t\t\t\t\treadBuffer,\n\t\t\t\t\t\t\t\tTC_MAX_VOLUME_SECTOR_SIZE,\n\t\t\t\t\t\t\t\t&offset,\n\t\t\t\t\t\t\t\tNULL);\n\n\t\t\t\t\t\t\t\tif (NT_SUCCESS (ntStatus))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t/* compute the ID of this volume: SHA-256 of the effective header */\n\t\t\t\t\t\t\t\t\tsha256 (opentest->volumeIDs[volumeType], readBuffer, TC_VOLUME_HEADER_EFFECTIVE_SIZE);\n\t\t\t\t\t\t\t\t\topentest->VolumeIDComputed[volumeType] = TRUE;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tTCfree (readBuffer);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tZwClose (NtFileHandle);\n\t\t\t\tDump (\"Open test on file %ls success.\\n\", opentest->wszFileName);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n#if 0\n\t\t\t\tDump (\"Open test on file %ls failed NTSTATUS 0x%08x\\n\", opentest->wszFileName, ntStatus);\n#endif\n\t\t\t}\n\n\t\t\tIrp->IoStatus.Information = NT_SUCCESS (ntStatus) ? sizeof (OPEN_TEST_STRUCT) : 0;\n\t\t\tIrp->IoStatus.Status = ntStatus;\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_SYSTEM_DRIVE_CONFIG:\n\t\t{\n\t\t\tGetSystemDriveConfigurationRequest *request = (GetSystemDriveConfigurationRequest *) Irp->AssociatedIrp.SystemBuffer;\n\t\t\tOBJECT_ATTRIBUTES ObjectAttributes;\n\t\t\tHANDLE NtFileHandle;\n \t\t\tUNICODE_STRING FullFileName;\n \t\t\tIO_STATUS_BLOCK IoStatus;\n \t\t\tLARGE_INTEGER offset;\n\t\t\tsize_t devicePathLen = 0;\n \n \t\t\tif (!ValidateIOBufferSize (Irp, sizeof (GetSystemDriveConfigurationRequest), ValidateInputOutput))\n \t\t\t\tbreak;\n \n\t\t\t// check that request->DevicePath has the expected format \"\\\\Device\\\\HarddiskXXX\\\\Partition0\"\n\t\t\tif (\t!NT_SUCCESS (RtlUnalignedStringCchLengthW (request->DevicePath, TC_MAX_PATH, &devicePathLen))\n\t\t\t\t||\t(devicePathLen < 28) // 28 is the length of \"\\\\Device\\\\Harddisk0\\\\Partition0\" which is the minimum\n\t\t\t\t||\t(devicePathLen > 30) // 30 is the length of \"\\\\Device\\\\Harddisk255\\\\Partition0\" which is the maximum\n\t\t\t\t||\t(memcmp (request->DevicePath, L\"\\\\Device\\\\Harddisk\", 16 * sizeof (WCHAR)))\n\t\t\t\t||\t(memcmp (&request->DevicePath[devicePathLen - 11], L\"\\\\Partition0\", 11 * sizeof (WCHAR)))\n\t\t\t\t)\n\t\t\t{\n\t\t\t\tIrp->IoStatus.Status = STATUS_INVALID_PARAMETER;\n\t\t\t\tIrp->IoStatus.Information = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n \t\t\tEnsureNullTerminatedString (request->DevicePath, sizeof (request->DevicePath));\n \t\t\tRtlInitUnicodeString (&FullFileName, request->DevicePath);\n \n\t\t\tInitializeObjectAttributes (&ObjectAttributes, &FullFileName, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);\n\n\t\t\tntStatus = ZwCreateFile (&NtFileHandle,\n\t\t\t\tSYNCHRONIZE | GENERIC_READ, &ObjectAttributes, &IoStatus, NULL,\n\t\t\t\tFILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT | FILE_RANDOM_ACCESS, NULL, 0);\n \n \t\t\tif (NT_SUCCESS (ntStatus))\n \t\t\t{\n\t\t\t\tbyte *readBuffer = TCalloc (TC_MAX_VOLUME_SECTOR_SIZE);\n\t\t\t\tif (!readBuffer)\n \t\t\t\t{\n\t\t\t\t\tIrp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;\n\t\t\t\t\tIrp->IoStatus.Information = 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Determine if the first sector contains a portion of the VeraCrypt Boot Loader\n\t\t\t\t\toffset.QuadPart = 0;\t// MBR\n \n\t\t\t\t\tntStatus = ZwReadFile (NtFileHandle,\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t&IoStatus,\n\t\t\t\t\t\treadBuffer,\n\t\t\t\t\t\tTC_MAX_VOLUME_SECTOR_SIZE,\n\t\t\t\t\t\t&offset,\n\t\t\t\t\t\tNULL);\n \n\t\t\t\t\tif (NT_SUCCESS (ntStatus))\n \t\t\t\t\t{\n\t\t\t\t\t\t// check that we could read all needed data\n\t\t\t\t\t\tif (IoStatus.Information >= TC_SECTOR_SIZE_BIOS)\n \t\t\t\t\t\t{\n\t\t\t\t\t\t\tsize_t i;\n\n\t\t\t\t\t\t\t// Check for dynamic drive\n\t\t\t\t\t\t\trequest->DriveIsDynamic = FALSE;\n\n\t\t\t\t\t\t\tif (readBuffer[510] == 0x55 && readBuffer[511] == 0xaa)\n \t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tint i;\n\t\t\t\t\t\t\t\tfor (i = 0; i < 4; ++i)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif (readBuffer[446 + i * 16 + 4] == PARTITION_LDM)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\trequest->DriveIsDynamic = TRUE;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \n\t\t\t\t\t\t\trequest->BootLoaderVersion = 0;\n\t\t\t\t\t\t\trequest->Configuration = 0;\n\t\t\t\t\t\t\trequest->UserConfiguration = 0;\n\t\t\t\t\t\t\trequest->CustomUserMessage[0] = 0;\n \n\t\t\t\t\t\t\t// Search for the string \"VeraCrypt\"\n\t\t\t\t\t\t\tfor (i = 0; i < sizeof (readBuffer) - strlen (TC_APP_NAME); ++i)\n \t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (memcmp (readBuffer + i, TC_APP_NAME, strlen (TC_APP_NAME)) == 0)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\trequest->BootLoaderVersion = BE16 (*(uint16 *) (readBuffer + TC_BOOT_SECTOR_VERSION_OFFSET));\n\t\t\t\t\t\t\t\t\trequest->Configuration = readBuffer[TC_BOOT_SECTOR_CONFIG_OFFSET];\n\n\t\t\t\t\t\t\t\t\tif (request->BootLoaderVersion != 0 && request->BootLoaderVersion <= VERSION_NUM)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\trequest->UserConfiguration = readBuffer[TC_BOOT_SECTOR_USER_CONFIG_OFFSET];\n\t\t\t\t\t\t\t\t\t\tmemcpy (request->CustomUserMessage, readBuffer + TC_BOOT_SECTOR_USER_MESSAGE_OFFSET, TC_BOOT_SECTOR_USER_MESSAGE_MAX_LENGTH);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\t\t\t\t\tIrp->IoStatus.Information = sizeof (*request);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tIrp->IoStatus.Status = STATUS_INVALID_PARAMETER;\n\t\t\t\t\t\t\tIrp->IoStatus.Information = 0;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tIrp->IoStatus.Status = ntStatus;\n\t\t\t\t\t\tIrp->IoStatus.Information = 0;\n\t\t\t\t\t}\n \n\t\t\t\t\tTCfree (readBuffer);\n \t\t\t\t}\n \n \t\t\t\tZwClose (NtFileHandle);\n\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tIrp->IoStatus.Status = ntStatus;\n\t\t\t\tIrp->IoStatus.Information = 0;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_WIPE_PASSWORD_CACHE:\n\t\tWipeCache ();\n\n\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\tIrp->IoStatus.Information = 0;\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_PASSWORD_CACHE_STATUS:\n\t\tIrp->IoStatus.Status = cacheEmpty ? STATUS_PIPE_EMPTY : STATUS_SUCCESS;\n\t\tIrp->IoStatus.Information = 0;\n\t\tbreak;\n\n\tcase TC_IOCTL_SET_PORTABLE_MODE_STATUS:\n\t\tif (!UserCanAccessDriveDevice())\n\t\t{\n\t\t\tIrp->IoStatus.Status = STATUS_ACCESS_DENIED;\n\t\t\tIrp->IoStatus.Information = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tPortableMode = TRUE;\n\t\t\tDump (\"Setting portable mode\\n\");\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_PORTABLE_MODE_STATUS:\n\t\tIrp->IoStatus.Status = PortableMode ? STATUS_SUCCESS : STATUS_PIPE_EMPTY;\n\t\tIrp->IoStatus.Information = 0;\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_MOUNTED_VOLUMES:\n\n\t\tif (ValidateIOBufferSize (Irp, sizeof (MOUNT_LIST_STRUCT), ValidateOutput))\n\t\t{\n\t\t\tMOUNT_LIST_STRUCT *list = (MOUNT_LIST_STRUCT *) Irp->AssociatedIrp.SystemBuffer;\n\t\t\tPDEVICE_OBJECT ListDevice;\n\t\t\tint drive;\n\n\t\t\tlist->ulMountedDrives = 0;\n\n\t\t\tfor (drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER; ++drive)\n\t\t\t{\n\t\t\t\tPEXTENSION ListExtension;\n\n\t\t\t\tListDevice = GetVirtualVolumeDeviceObject (drive);\n\t\t\t\tif (!ListDevice)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tListExtension = (PEXTENSION) ListDevice->DeviceExtension;\n\t\t\t\tif (IsVolumeAccessibleByCurrentUser (ListExtension))\n\t\t\t\t{\n\t\t\t\t\tlist->ulMountedDrives |= (1 << ListExtension->nDosDriveNo);\n\t\t\t\t\tRtlStringCbCopyW (list->wszVolume[ListExtension->nDosDriveNo], sizeof(list->wszVolume[ListExtension->nDosDriveNo]),ListExtension->wszVolume);\n\t\t\t\t\tRtlStringCbCopyW (list->wszLabel[ListExtension->nDosDriveNo], sizeof(list->wszLabel[ListExtension->nDosDriveNo]),ListExtension->wszLabel);\n\t\t\t\t\tmemcpy (list->volumeID[ListExtension->nDosDriveNo], ListExtension->volumeID, VOLUME_ID_SIZE);\n\t\t\t\t\tlist->diskLength[ListExtension->nDosDriveNo] = ListExtension->DiskLength;\n\t\t\t\t\tlist->ea[ListExtension->nDosDriveNo] = ListExtension->cryptoInfo->ea;\n\t\t\t\t\tif (ListExtension->cryptoInfo->hiddenVolume)\n\t\t\t\t\t\tlist->volumeType[ListExtension->nDosDriveNo] = PROP_VOL_TYPE_HIDDEN;\t// Hidden volume\n\t\t\t\t\telse if (ListExtension->cryptoInfo->bHiddenVolProtectionAction)\n\t\t\t\t\t\tlist->volumeType[ListExtension->nDosDriveNo] = PROP_VOL_TYPE_OUTER_VOL_WRITE_PREVENTED;\t// Normal/outer volume (hidden volume protected AND write already prevented)\n\t\t\t\t\telse if (ListExtension->cryptoInfo->bProtectHiddenVolume)\n\t\t\t\t\t\tlist->volumeType[ListExtension->nDosDriveNo] = PROP_VOL_TYPE_OUTER;\t// Normal/outer volume (hidden volume protected)\n\t\t\t\t\telse\n\t\t\t\t\t\tlist->volumeType[ListExtension->nDosDriveNo] = PROP_VOL_TYPE_NORMAL;\t// Normal volume\n\t\t\t\t\tlist->truecryptMode[ListExtension->nDosDriveNo] = ListExtension->cryptoInfo->bTrueCryptMode;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\tIrp->IoStatus.Information = sizeof (MOUNT_LIST_STRUCT);\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_LEGACY_GET_MOUNTED_VOLUMES:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (uint32), ValidateOutput))\n\t\t{\n\n\t\t\tmemset (Irp->AssociatedIrp.SystemBuffer, 0, irpSp->Parameters.DeviceIoControl.OutputBufferLength);\n\t\t\t*(uint32 *) Irp->AssociatedIrp.SystemBuffer = 0xffffFFFF;\n\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\tIrp->IoStatus.Information = irpSp->Parameters.DeviceIoControl.OutputBufferLength;\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_VOLUME_PROPERTIES:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (VOLUME_PROPERTIES_STRUCT), ValidateInputOutput))\n\t\t{\n\t\t\tVOLUME_PROPERTIES_STRUCT *prop = (VOLUME_PROPERTIES_STRUCT *) Irp->AssociatedIrp.SystemBuffer;\n\t\t\tPDEVICE_OBJECT ListDevice = GetVirtualVolumeDeviceObject (prop->driveNo);\n\n\t\t\tIrp->IoStatus.Status = STATUS_INVALID_PARAMETER;\n\t\t\tIrp->IoStatus.Information = 0;\n\n\t\t\tif (ListDevice)\n\t\t\t{\n\t\t\t\tPEXTENSION ListExtension = (PEXTENSION) ListDevice->DeviceExtension;\n\t\t\t\tif (IsVolumeAccessibleByCurrentUser (ListExtension))\n\t\t\t\t{\n\t\t\t\t\tprop->uniqueId = ListExtension->UniqueVolumeId;\n\t\t\t\t\tRtlStringCbCopyW (prop->wszVolume, sizeof(prop->wszVolume),ListExtension->wszVolume);\n\t\t\t\t\tRtlStringCbCopyW (prop->wszLabel, sizeof(prop->wszLabel),ListExtension->wszLabel);\n\t\t\t\t\tmemcpy (prop->volumeID, ListExtension->volumeID, VOLUME_ID_SIZE);\n\t\t\t\t\tprop->bDriverSetLabel = ListExtension->bDriverSetLabel;\n\t\t\t\t\tprop->diskLength = ListExtension->DiskLength;\n\t\t\t\t\tprop->ea = ListExtension->cryptoInfo->ea;\n\t\t\t\t\tprop->mode = ListExtension->cryptoInfo->mode;\n\t\t\t\t\tprop->pkcs5 = ListExtension->cryptoInfo->pkcs5;\n\t\t\t\t\tprop->pkcs5Iterations = ListExtension->cryptoInfo->noIterations;\n\t\t\t\t\tprop->volumePim = ListExtension->cryptoInfo->volumePim;\n#if 0\n\t\t\t\t\tprop->volumeCreationTime = ListExtension->cryptoInfo->volume_creation_time;\n\t\t\t\t\tprop->headerCreationTime = ListExtension->cryptoInfo->header_creation_time;\n#endif\n\t\t\t\t\tprop->volumeHeaderFlags = ListExtension->cryptoInfo->HeaderFlags;\n\t\t\t\t\tprop->readOnly = ListExtension->bReadOnly;\n\t\t\t\t\tprop->removable = ListExtension->bRemovable;\n\t\t\t\t\tprop->partitionInInactiveSysEncScope = ListExtension->PartitionInInactiveSysEncScope;\n\t\t\t\t\tprop->hiddenVolume = ListExtension->cryptoInfo->hiddenVolume;\n\n\t\t\t\t\tif (ListExtension->cryptoInfo->bProtectHiddenVolume)\n\t\t\t\t\t\tprop->hiddenVolProtection = ListExtension->cryptoInfo->bHiddenVolProtectionAction ? HIDVOL_PROT_STATUS_ACTION_TAKEN : HIDVOL_PROT_STATUS_ACTIVE;\n\t\t\t\t\telse\n\t\t\t\t\t\tprop->hiddenVolProtection = HIDVOL_PROT_STATUS_NONE;\n\n\t\t\t\t\tprop->totalBytesRead = ListExtension->Queue.TotalBytesRead;\n\t\t\t\t\tprop->totalBytesWritten = ListExtension->Queue.TotalBytesWritten;\n\n\t\t\t\t\tprop->volFormatVersion = ListExtension->cryptoInfo->LegacyVolume ? TC_VOLUME_FORMAT_VERSION_PRE_6_0 : TC_VOLUME_FORMAT_VERSION;\n\n\t\t\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\t\t\tIrp->IoStatus.Information = sizeof (VOLUME_PROPERTIES_STRUCT);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_RESOLVED_SYMLINK:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (RESOLVE_SYMLINK_STRUCT), ValidateInputOutput))\n\t\t{\n\t\t\tRESOLVE_SYMLINK_STRUCT *resolve = (RESOLVE_SYMLINK_STRUCT *) Irp->AssociatedIrp.SystemBuffer;\n\t\t\t{\n\t\t\t\tNTSTATUS ntStatus;\n\n\t\t\t\tEnsureNullTerminatedString (resolve->symLinkName, sizeof (resolve->symLinkName));\n\n\t\t\t\tntStatus = SymbolicLinkToTarget (resolve->symLinkName,\n\t\t\t\t\tresolve->targetName,\n\t\t\t\t\tsizeof (resolve->targetName));\n\n\t\t\t\tIrp->IoStatus.Information = sizeof (RESOLVE_SYMLINK_STRUCT);\n\t\t\t\tIrp->IoStatus.Status = ntStatus;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_DRIVE_PARTITION_INFO:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (DISK_PARTITION_INFO_STRUCT), ValidateInputOutput))\n\t\t{\n\t\t\tDISK_PARTITION_INFO_STRUCT *info = (DISK_PARTITION_INFO_STRUCT *) Irp->AssociatedIrp.SystemBuffer;\n\t\t\t{\n\t\t\t\tPARTITION_INFORMATION_EX pi;\n\t\t\t\tNTSTATUS ntStatus;\n\n\t\t\t\tEnsureNullTerminatedString (info->deviceName, sizeof (info->deviceName));\n\n\t\t\t\tntStatus = TCDeviceIoControl (info->deviceName, IOCTL_DISK_GET_PARTITION_INFO_EX, NULL, 0, &pi, sizeof (pi));\n\t\t\t\tif (NT_SUCCESS(ntStatus))\n\t\t\t\t{\n\t\t\t\t\tmemset (&info->partInfo, 0, sizeof (info->partInfo));\n\n\t\t\t\t\tinfo->partInfo.PartitionLength = pi.PartitionLength;\n\t\t\t\t\tinfo->partInfo.PartitionNumber = pi.PartitionNumber;\n\t\t\t\t\tinfo->partInfo.StartingOffset = pi.StartingOffset;\n\n\t\t\t\t\tif (pi.PartitionStyle == PARTITION_STYLE_MBR)\n\t\t\t\t\t{\n\t\t\t\t\t\tinfo->partInfo.PartitionType = pi.Mbr.PartitionType;\n\t\t\t\t\t\tinfo->partInfo.BootIndicator = pi.Mbr.BootIndicator;\n\t\t\t\t\t}\n\n\t\t\t\t\tinfo->IsGPT = pi.PartitionStyle == PARTITION_STYLE_GPT;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tntStatus = TCDeviceIoControl (info->deviceName, IOCTL_DISK_GET_PARTITION_INFO, NULL, 0, &info->partInfo, sizeof (info->partInfo));\n\t\t\t\t\tinfo->IsGPT = FALSE;\n\t\t\t\t}\n\n\t\t\t\tif (!NT_SUCCESS (ntStatus))\n\t\t\t\t{\n\t\t\t\t\tGET_LENGTH_INFORMATION lengthInfo;\n\t\t\t\t\tntStatus = TCDeviceIoControl (info->deviceName, IOCTL_DISK_GET_LENGTH_INFO, NULL, 0, &lengthInfo, sizeof (lengthInfo));\n\n\t\t\t\t\tif (NT_SUCCESS (ntStatus))\n\t\t\t\t\t{\n\t\t\t\t\t\tmemset (&info->partInfo, 0, sizeof (info->partInfo));\n\t\t\t\t\t\tinfo->partInfo.PartitionLength = lengthInfo.Length;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tinfo->IsDynamic = FALSE;\n\n\t\t\t\tif (NT_SUCCESS (ntStatus) && OsMajorVersion >= 6)\n\t\t\t\t{\n#\t\t\t\t\tdefine IOCTL_VOLUME_IS_DYNAMIC CTL_CODE(IOCTL_VOLUME_BASE, 18, METHOD_BUFFERED, FILE_ANY_ACCESS)\n\t\t\t\t\tif (!NT_SUCCESS (TCDeviceIoControl (info->deviceName, IOCTL_VOLUME_IS_DYNAMIC, NULL, 0, &info->IsDynamic, sizeof (info->IsDynamic))))\n\t\t\t\t\t\tinfo->IsDynamic = FALSE;\n\t\t\t\t}\n\n\t\t\t\tIrp->IoStatus.Information = sizeof (DISK_PARTITION_INFO_STRUCT);\n\t\t\t\tIrp->IoStatus.Status = ntStatus;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_DRIVE_GEOMETRY:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (DISK_GEOMETRY_STRUCT), ValidateInputOutput))\n\t\t{\n\t\t\tDISK_GEOMETRY_STRUCT *g = (DISK_GEOMETRY_STRUCT *) Irp->AssociatedIrp.SystemBuffer;\n\t\t\t{\n\t\t\t\tNTSTATUS ntStatus;\n\n\t\t\t\tEnsureNullTerminatedString (g->deviceName, sizeof (g->deviceName));\n\t\t\t\tDump (\"Calling IOCTL_DISK_GET_DRIVE_GEOMETRY on %ls\\n\", g->deviceName);\n\n\t\t\t\tntStatus = TCDeviceIoControl (g->deviceName,\n\t\t\t\t\tIOCTL_DISK_GET_DRIVE_GEOMETRY,\n\t\t\t\t\tNULL, 0, &g->diskGeometry, sizeof (g->diskGeometry));\n\n\t\t\t\tIrp->IoStatus.Information = sizeof (DISK_GEOMETRY_STRUCT);\n\t\t\t\tIrp->IoStatus.Status = ntStatus;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase VC_IOCTL_GET_DRIVE_GEOMETRY_EX:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (DISK_GEOMETRY_EX_STRUCT), ValidateInputOutput))\n\t\t{\n\t\t\tDISK_GEOMETRY_EX_STRUCT *g = (DISK_GEOMETRY_EX_STRUCT *) Irp->AssociatedIrp.SystemBuffer;\n\t\t\t{\n\t\t\t\tNTSTATUS ntStatus;\n\t\t\t\tPVOID buffer = TCalloc (256); // enough for DISK_GEOMETRY_EX and padded data\n\t\t\t\tif (buffer)\n\t\t\t\t{\n\t\t\t\t\tEnsureNullTerminatedString (g->deviceName, sizeof (g->deviceName));\n\t\t\t\t\tDump (\"Calling IOCTL_DISK_GET_DRIVE_GEOMETRY_EX on %ls\\n\", g->deviceName);\n\n\t\t\t\t\tntStatus = TCDeviceIoControl (g->deviceName,\n\t\t\t\t\t\tIOCTL_DISK_GET_DRIVE_GEOMETRY_EX,\n\t\t\t\t\t\tNULL, 0, buffer, 256);\n\n\t\t\t\t\tif (NT_SUCCESS(ntStatus))\n\t\t\t\t\t{\n\t\t\t\t\t\tPDISK_GEOMETRY_EX pGeo = (PDISK_GEOMETRY_EX) buffer;\n\t\t\t\t\t\tmemcpy (&g->diskGeometry, &pGeo->Geometry, sizeof (DISK_GEOMETRY));\n\t\t\t\t\t\tg->DiskSize.QuadPart = pGeo->DiskSize.QuadPart;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tDISK_GEOMETRY dg = {0};\n\t\t\t\t\t\tDump (\"Failed. Calling IOCTL_DISK_GET_DRIVE_GEOMETRY on %ls\\n\", g->deviceName);\n\t\t\t\t\t\tntStatus = TCDeviceIoControl (g->deviceName,\n\t\t\t\t\t\t\tIOCTL_DISK_GET_DRIVE_GEOMETRY,\n\t\t\t\t\t\t\tNULL, 0, &dg, sizeof (dg));\n\n\t\t\t\t\t\tif (NT_SUCCESS(ntStatus))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmemcpy (&g->diskGeometry, &dg, sizeof (DISK_GEOMETRY));\n\t\t\t\t\t\t\tg->DiskSize.QuadPart = dg.Cylinders.QuadPart * dg.SectorsPerTrack * dg.TracksPerCylinder * dg.BytesPerSector;\n\n\t\t\t\t\t\t\tif (OsMajorVersion >= 6)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tSTORAGE_READ_CAPACITY storage = {0};\n\t\t\t\t\t\t\t\tNTSTATUS lStatus;\n\t\t\t\t\t\t\t\tstorage.Version = sizeof (STORAGE_READ_CAPACITY);\n\t\t\t\t\t\t\t\tDump (\"Calling IOCTL_STORAGE_READ_CAPACITY on %ls\\n\", g->deviceName);\n\t\t\t\t\t\t\t\tlStatus = TCDeviceIoControl (g->deviceName,\n\t\t\t\t\t\t\t\t\tIOCTL_STORAGE_READ_CAPACITY,\n\t\t\t\t\t\t\t\t\tNULL, 0, &storage, sizeof (STORAGE_READ_CAPACITY));\n\t\t\t\t\t\t\t\tif (\tNT_SUCCESS(lStatus)\n\t\t\t\t\t\t\t\t\t&& (storage.Size == sizeof (STORAGE_READ_CAPACITY))\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tg->DiskSize.QuadPart = storage.DiskLength.QuadPart;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tTCfree (buffer);\n\n\t\t\t\t\tIrp->IoStatus.Information = sizeof (DISK_GEOMETRY_EX_STRUCT);\n\t\t\t\t\tIrp->IoStatus.Status = ntStatus;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tIrp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;\n\t\t\t\t\tIrp->IoStatus.Information = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_PROBE_REAL_DRIVE_SIZE:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (ProbeRealDriveSizeRequest), ValidateInputOutput))\n\t\t{\n\t\t\tProbeRealDriveSizeRequest *request = (ProbeRealDriveSizeRequest *) Irp->AssociatedIrp.SystemBuffer;\n\t\t\tNTSTATUS status;\n\t\t\tUNICODE_STRING name;\n\t\t\tPFILE_OBJECT fileObject;\n\t\t\tPDEVICE_OBJECT deviceObject;\n\n\t\t\tEnsureNullTerminatedString (request->DeviceName, sizeof (request->DeviceName));\n\n\t\t\tRtlInitUnicodeString (&name, request->DeviceName);\n\t\t\tstatus = IoGetDeviceObjectPointer (&name, FILE_READ_ATTRIBUTES, &fileObject, &deviceObject);\n\t\t\tif (!NT_SUCCESS (status))\n\t\t\t{\n\t\t\t\tIrp->IoStatus.Information = 0;\n\t\t\t\tIrp->IoStatus.Status = status;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tstatus = ProbeRealDriveSize (deviceObject, &request->RealDriveSize);\n\t\t\tObDereferenceObject (fileObject);\n\n\t\t\tif (status == STATUS_TIMEOUT)\n\t\t\t{\n\t\t\t\trequest->TimeOut = TRUE;\n\t\t\t\tIrp->IoStatus.Information = sizeof (ProbeRealDriveSizeRequest);\n\t\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\t}\n\t\t\telse if (!NT_SUCCESS (status))\n\t\t\t{\n\t\t\t\tIrp->IoStatus.Information = 0;\n\t\t\t\tIrp->IoStatus.Status = status;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\trequest->TimeOut = FALSE;\n\t\t\t\tIrp->IoStatus.Information = sizeof (ProbeRealDriveSizeRequest);\n\t\t\t\tIrp->IoStatus.Status = status;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_MOUNT_VOLUME:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (MOUNT_STRUCT), ValidateInputOutput))\n\t\t{\n\t\t\tMOUNT_STRUCT *mount = (MOUNT_STRUCT *) Irp->AssociatedIrp.SystemBuffer;\n\n\t\t\tif (mount->VolumePassword.Length > MAX_PASSWORD || mount->ProtectedHidVolPassword.Length > MAX_PASSWORD\n\t\t\t\t||\tmount->pkcs5_prf < 0 || mount->pkcs5_prf > LAST_PRF_ID\n\t\t\t\t||\tmount->VolumePim < -1 || mount->VolumePim == INT_MAX\n\t\t\t\t|| mount->ProtectedHidVolPkcs5Prf < 0 || mount->ProtectedHidVolPkcs5Prf > LAST_PRF_ID\n\t\t\t\t|| (mount->bTrueCryptMode != FALSE && mount->bTrueCryptMode != TRUE)\n\t\t\t\t)\n\t\t\t{\n\t\t\t\tIrp->IoStatus.Status = STATUS_INVALID_PARAMETER;\n\t\t\t\tIrp->IoStatus.Information = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tEnsureNullTerminatedString (mount->wszVolume, sizeof (mount->wszVolume));\n\t\t\tEnsureNullTerminatedString (mount->wszLabel, sizeof (mount->wszLabel));\n\n\t\t\tIrp->IoStatus.Information = sizeof (MOUNT_STRUCT);\n\t\t\tIrp->IoStatus.Status = MountDevice (DeviceObject, mount);\n\n\t\t\tburn (&mount->VolumePassword, sizeof (mount->VolumePassword));\n\t\t\tburn (&mount->ProtectedHidVolPassword, sizeof (mount->ProtectedHidVolPassword));\n\t\t\tburn (&mount->pkcs5_prf, sizeof (mount->pkcs5_prf));\n\t\t\tburn (&mount->VolumePim, sizeof (mount->VolumePim));\n\t\t\tburn (&mount->bTrueCryptMode, sizeof (mount->bTrueCryptMode));\n\t\t\tburn (&mount->ProtectedHidVolPkcs5Prf, sizeof (mount->ProtectedHidVolPkcs5Prf));\n\t\t\tburn (&mount->ProtectedHidVolPim, sizeof (mount->ProtectedHidVolPim));\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_DISMOUNT_VOLUME:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (UNMOUNT_STRUCT), ValidateInputOutput))\n\t\t{\n\t\t\tUNMOUNT_STRUCT *unmount = (UNMOUNT_STRUCT *) Irp->AssociatedIrp.SystemBuffer;\n\t\t\tPDEVICE_OBJECT ListDevice = GetVirtualVolumeDeviceObject (unmount->nDosDriveNo);\n\n\t\t\tunmount->nReturnCode = ERR_DRIVE_NOT_FOUND;\n\n\t\t\tif (ListDevice)\n\t\t\t{\n\t\t\t\tPEXTENSION ListExtension = (PEXTENSION) ListDevice->DeviceExtension;\n\n\t\t\t\tif (IsVolumeAccessibleByCurrentUser (ListExtension))\n\t\t\t\t\tunmount->nReturnCode = UnmountDevice (unmount, ListDevice, unmount->ignoreOpenFiles);\n\t\t\t}\n\n\t\t\tIrp->IoStatus.Information = sizeof (UNMOUNT_STRUCT);\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_DISMOUNT_ALL_VOLUMES:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (UNMOUNT_STRUCT), ValidateInputOutput))\n\t\t{\n\t\t\tUNMOUNT_STRUCT *unmount = (UNMOUNT_STRUCT *) Irp->AssociatedIrp.SystemBuffer;\n\n\t\t\tunmount->nReturnCode = UnmountAllDevices (unmount, unmount->ignoreOpenFiles);\n\n\t\t\tIrp->IoStatus.Information = sizeof (UNMOUNT_STRUCT);\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_BOOT_ENCRYPTION_SETUP:\n\t\tIrp->IoStatus.Status = StartBootEncryptionSetup (DeviceObject, Irp, irpSp);\n\t\tIrp->IoStatus.Information = 0;\n\t\tbreak;\n\n\tcase TC_IOCTL_ABORT_BOOT_ENCRYPTION_SETUP:\n\t\tIrp->IoStatus.Status = AbortBootEncryptionSetup();\n\t\tIrp->IoStatus.Information = 0;\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_BOOT_ENCRYPTION_STATUS:\n\t\tGetBootEncryptionStatus (Irp, irpSp);\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_BOOT_ENCRYPTION_SETUP_RESULT:\n\t\tIrp->IoStatus.Information = 0;\n\t\tIrp->IoStatus.Status = GetSetupResult();\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_BOOT_DRIVE_VOLUME_PROPERTIES:\n\t\tGetBootDriveVolumeProperties (Irp, irpSp);\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_BOOT_LOADER_VERSION:\n\t\tGetBootLoaderVersion (Irp, irpSp);\n\t\tbreak;\n\n\tcase TC_IOCTL_REOPEN_BOOT_VOLUME_HEADER:\n\t\tReopenBootVolumeHeader (Irp, irpSp);\n\t\tbreak;\n\n\tcase VC_IOCTL_GET_BOOT_LOADER_FINGERPRINT:\n\t\tGetBootLoaderFingerprint (Irp, irpSp);\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_BOOT_ENCRYPTION_ALGORITHM_NAME:\n\t\tGetBootEncryptionAlgorithmName (Irp, irpSp);\n\t\tbreak;\n\n\tcase TC_IOCTL_IS_HIDDEN_SYSTEM_RUNNING:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (int), ValidateOutput))\n\t\t{\n\t\t\t*(int *) Irp->AssociatedIrp.SystemBuffer = IsHiddenSystemRunning() ? 1 : 0;\n\t\t\tIrp->IoStatus.Information = sizeof (int);\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_START_DECOY_SYSTEM_WIPE:\n\t\tIrp->IoStatus.Status = StartDecoySystemWipe (DeviceObject, Irp, irpSp);\n\t\tIrp->IoStatus.Information = 0;\n\t\tbreak;\n\n\tcase TC_IOCTL_ABORT_DECOY_SYSTEM_WIPE:\n\t\tIrp->IoStatus.Status = AbortDecoySystemWipe();\n\t\tIrp->IoStatus.Information = 0;\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_DECOY_SYSTEM_WIPE_RESULT:\n\t\tIrp->IoStatus.Status = GetDecoySystemWipeResult();\n\t\tIrp->IoStatus.Information = 0;\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_DECOY_SYSTEM_WIPE_STATUS:\n\t\tGetDecoySystemWipeStatus (Irp, irpSp);\n\t\tbreak;\n\n\tcase TC_IOCTL_WRITE_BOOT_DRIVE_SECTOR:\n\t\tIrp->IoStatus.Status = WriteBootDriveSector (Irp, irpSp);\n\t\tIrp->IoStatus.Information = 0;\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_WARNING_FLAGS:\n\t\tif (ValidateIOBufferSize (Irp, sizeof (GetWarningFlagsRequest), ValidateOutput))\n\t\t{\n\t\t\tGetWarningFlagsRequest *flags = (GetWarningFlagsRequest *) Irp->AssociatedIrp.SystemBuffer;\n\n\t\t\tflags->PagingFileCreationPrevented = PagingFileCreationPrevented;\n\t\t\tPagingFileCreationPrevented = FALSE;\n\t\t\tflags->SystemFavoriteVolumeDirty = SystemFavoriteVolumeDirty;\n\t\t\tSystemFavoriteVolumeDirty = FALSE;\n\n\t\t\tIrp->IoStatus.Information = sizeof (GetWarningFlagsRequest);\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t}\n\t\tbreak;\n\n\tcase TC_IOCTL_SET_SYSTEM_FAVORITE_VOLUME_DIRTY:\n\t\tif (UserCanAccessDriveDevice())\n\t\t{\n\t\t\tSystemFavoriteVolumeDirty = TRUE;\n\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t}\n\t\telse\n\t\t\tIrp->IoStatus.Status = STATUS_ACCESS_DENIED;\n\n\t\tIrp->IoStatus.Information = 0;\n\t\tbreak;\n\n\tcase TC_IOCTL_REREAD_DRIVER_CONFIG:\n\t\tIrp->IoStatus.Status = ReadRegistryConfigFlags (FALSE);\n\t\tIrp->IoStatus.Information = 0;\n\t\tbreak;\n\n\tcase TC_IOCTL_GET_SYSTEM_DRIVE_DUMP_CONFIG:\n\t\tif (\t(ValidateIOBufferSize (Irp, sizeof (GetSystemDriveDumpConfigRequest), ValidateOutput))\n\t\t\t&&\t(Irp->RequestorMode == KernelMode)\n\t\t\t)\n\t\t{\n\t\t\tGetSystemDriveDumpConfigRequest *request = (GetSystemDriveDumpConfigRequest *) Irp->AssociatedIrp.SystemBuffer;\n\n\t\t\trequest->BootDriveFilterExtension = GetBootDriveFilterExtension();\n\t\t\tif (IsBootDriveMounted() && request->BootDriveFilterExtension)\n\t\t\t{\n\t\t\t\trequest->HwEncryptionEnabled = IsHwEncryptionEnabled();\n\t\t\t\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\t\t\t\tIrp->IoStatus.Information = sizeof (*request);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tIrp->IoStatus.Status = STATUS_INVALID_PARAMETER;\n\t\t\t\tIrp->IoStatus.Information = 0;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn TCCompleteIrp (Irp, STATUS_INVALID_DEVICE_REQUEST, 0);\n\t}\n\n\n#if defined(DEBUG) || defined(DEBUG_TRACE)\n\tif (!NT_SUCCESS (Irp->IoStatus.Status))\n\t{\n\t\tswitch (irpSp->Parameters.DeviceIoControl.IoControlCode)\n\t\t{\n\t\tcase TC_IOCTL_GET_MOUNTED_VOLUMES:\n\t\tcase TC_IOCTL_GET_PASSWORD_CACHE_STATUS:\n\t\tcase TC_IOCTL_GET_PORTABLE_MODE_STATUS:\n\t\tcase TC_IOCTL_SET_PORTABLE_MODE_STATUS:\n\t\tcase TC_IOCTL_OPEN_TEST:\n\t\tcase TC_IOCTL_GET_RESOLVED_SYMLINK:\n\t\tcase TC_IOCTL_GET_DRIVE_PARTITION_INFO:\n\t\tcase TC_IOCTL_GET_BOOT_DRIVE_VOLUME_PROPERTIES:\n\t\tcase TC_IOCTL_GET_BOOT_ENCRYPTION_STATUS:\n\t\tcase TC_IOCTL_IS_HIDDEN_SYSTEM_RUNNING:\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tDump (\"IOCTL error 0x%08x\\n\", Irp->IoStatus.Status);\n\t\t}\n\t}\n#endif\n\n\treturn TCCompleteIrp (Irp, Irp->IoStatus.Status, Irp->IoStatus.Information);\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 931,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2015-8126",
    "code_before_change": " png_get_mmx_bitdepth_threshold (png_structp png_ptr)\n {\n     /* Obsolete, to be removed from libpng-1.4.0 */\n    return (png_ptr? 0: 0);\n }\n",
    "code_after_change": " png_get_mmx_bitdepth_threshold (png_structp png_ptr)\n {\n     /* Obsolete, to be removed from libpng-1.4.0 */\n    PNG_UNUSED(png_ptr)\n    return 0L;\n }\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 936,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-1621",
    "code_before_change": "BlockEntry::Kind Track::EOSBlock::GetKind() const\n{\n    return kBlockEOS;\n}\n",
    "code_after_change": "BlockEntry::Kind Track::EOSBlock::GetKind() const\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 950,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-1621",
    "code_before_change": "   void Reset() {\n     error_nframes_ = 0;\n     droppable_nframes_ = 0;\n   }\n",
    "code_after_change": "   void Reset() {\n     error_nframes_ = 0;\n     droppable_nframes_ = 0;\n    pattern_switch_ = 0;\n   }\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 962,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-4303",
    "code_before_change": "static char *print_string( cJSON *item )\n{\n\treturn print_string_ptr( item->valuestring );\n}\n",
    "code_after_change": "static char *print_string( cJSON *item )\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 966,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2015-6773",
    "code_before_change": "void SelectionController::SetNonDirectionalSelectionIfNeeded(\n    const SelectionInFlatTree& passed_selection,\n    TextGranularity granularity,\n    EndPointsAdjustmentMode endpoints_adjustment_mode,\n    HandleVisibility handle_visibility) {\n  GetDocument().UpdateStyleAndLayoutIgnorePendingStylesheets();\n\n  const VisibleSelectionInFlatTree& new_selection =\n      CreateVisibleSelection(passed_selection);\n  const PositionInFlatTree& base_position =\n      original_base_in_flat_tree_.GetPosition();\n  const VisiblePositionInFlatTree& original_base =\n      base_position.IsConnected() ? CreateVisiblePosition(base_position)\n                                  : VisiblePositionInFlatTree();\n  const VisiblePositionInFlatTree& base =\n      original_base.IsNotNull() ? original_base\n                                : CreateVisiblePosition(new_selection.Base());\n  const VisiblePositionInFlatTree& extent =\n      CreateVisiblePosition(new_selection.Extent());\n  const SelectionInFlatTree& adjusted_selection =\n      endpoints_adjustment_mode == kAdjustEndpointsAtBidiBoundary\n          ? AdjustEndpointsAtBidiBoundary(base, extent)\n          : SelectionInFlatTree::Builder()\n                .SetBaseAndExtent(base.DeepEquivalent(),\n                                  extent.DeepEquivalent())\n                .Build();\n\n  SelectionInFlatTree::Builder builder(new_selection.AsSelection());\n  if (adjusted_selection.Base() != base.DeepEquivalent() ||\n      adjusted_selection.Extent() != extent.DeepEquivalent()) {\n    original_base_in_flat_tree_ = base.ToPositionWithAffinity();\n    SetContext(&GetDocument());\n    builder.SetBaseAndExtent(adjusted_selection.Base(),\n                             adjusted_selection.Extent());\n  } else if (original_base.IsNotNull()) {\n    if (CreateVisiblePosition(\n            Selection().ComputeVisibleSelectionInFlatTree().Base())\n            .DeepEquivalent() ==\n        CreateVisiblePosition(new_selection.Base()).DeepEquivalent()) {\n      builder.SetBaseAndExtent(original_base.DeepEquivalent(),\n                               new_selection.Extent());\n    }\n     original_base_in_flat_tree_ = PositionInFlatTreeWithAffinity();\n   }\n \n  builder.SetIsHandleVisible(handle_visibility == HandleVisibility::kVisible);\n   const SelectionInFlatTree& selection_in_flat_tree = builder.Build();\n   if (Selection().ComputeVisibleSelectionInFlatTree() ==\n           CreateVisibleSelection(selection_in_flat_tree) &&\n      Selection().IsHandleVisible() == selection_in_flat_tree.IsHandleVisible())\n     return;\n   Selection().SetSelection(\n       ConvertToSelectionInDOMTree(selection_in_flat_tree),\n      SetSelectionData::Builder()\n          .SetShouldCloseTyping(true)\n           .SetShouldClearTypingStyle(true)\n           .SetCursorAlignOnScroll(CursorAlignOnScroll::kIfNeeded)\n           .SetGranularity(granularity)\n           .Build());\n }\n",
    "code_after_change": "void SelectionController::SetNonDirectionalSelectionIfNeeded(\n    const SelectionInFlatTree& passed_selection,\n    TextGranularity granularity,\n    EndPointsAdjustmentMode endpoints_adjustment_mode,\n    HandleVisibility handle_visibility) {\n  GetDocument().UpdateStyleAndLayoutIgnorePendingStylesheets();\n\n  const VisibleSelectionInFlatTree& new_selection =\n      CreateVisibleSelection(passed_selection);\n  const PositionInFlatTree& base_position =\n      original_base_in_flat_tree_.GetPosition();\n  const VisiblePositionInFlatTree& original_base =\n      base_position.IsConnected() ? CreateVisiblePosition(base_position)\n                                  : VisiblePositionInFlatTree();\n  const VisiblePositionInFlatTree& base =\n      original_base.IsNotNull() ? original_base\n                                : CreateVisiblePosition(new_selection.Base());\n  const VisiblePositionInFlatTree& extent =\n      CreateVisiblePosition(new_selection.Extent());\n  const SelectionInFlatTree& adjusted_selection =\n      endpoints_adjustment_mode == kAdjustEndpointsAtBidiBoundary\n          ? AdjustEndpointsAtBidiBoundary(base, extent)\n          : SelectionInFlatTree::Builder()\n                .SetBaseAndExtent(base.DeepEquivalent(),\n                                  extent.DeepEquivalent())\n                .Build();\n\n  SelectionInFlatTree::Builder builder(new_selection.AsSelection());\n  if (adjusted_selection.Base() != base.DeepEquivalent() ||\n      adjusted_selection.Extent() != extent.DeepEquivalent()) {\n    original_base_in_flat_tree_ = base.ToPositionWithAffinity();\n    SetContext(&GetDocument());\n    builder.SetBaseAndExtent(adjusted_selection.Base(),\n                             adjusted_selection.Extent());\n  } else if (original_base.IsNotNull()) {\n    if (CreateVisiblePosition(\n            Selection().ComputeVisibleSelectionInFlatTree().Base())\n            .DeepEquivalent() ==\n        CreateVisiblePosition(new_selection.Base()).DeepEquivalent()) {\n      builder.SetBaseAndExtent(original_base.DeepEquivalent(),\n                               new_selection.Extent());\n    }\n     original_base_in_flat_tree_ = PositionInFlatTreeWithAffinity();\n   }\n \n   const SelectionInFlatTree& selection_in_flat_tree = builder.Build();\n  const bool should_show_handle =\n      handle_visibility == HandleVisibility::kVisible;\n   if (Selection().ComputeVisibleSelectionInFlatTree() ==\n           CreateVisibleSelection(selection_in_flat_tree) &&\n      Selection().IsHandleVisible() == should_show_handle)\n     return;\n   Selection().SetSelection(\n       ConvertToSelectionInDOMTree(selection_in_flat_tree),\n      SetSelectionData::Builder()\n          .SetShouldCloseTyping(true)\n           .SetShouldClearTypingStyle(true)\n           .SetCursorAlignOnScroll(CursorAlignOnScroll::kIfNeeded)\n           .SetGranularity(granularity)\n          .SetShouldShowHandle(should_show_handle)\n           .Build());\n }\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 968,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-0838",
    "code_before_change": "void WT_Interpolate (S_WT_VOICE *pWTVoice, S_WT_INT_FRAME *pWTIntFrame)\n{\n    EAS_PCM *pOutputBuffer;\n    EAS_I32 phaseInc;\n    EAS_I32 phaseFrac;\n    EAS_I32 acc0;\n const EAS_SAMPLE *pSamples;\n const EAS_SAMPLE *loopEnd;\n    EAS_I32 samp1;\n    EAS_I32 samp2;\n    EAS_I32 numSamples;\n\n /* initialize some local variables */\n\n     numSamples = pWTIntFrame->numSamples;\n     if (numSamples <= 0) {\n         ALOGE(\"b/26366256\");\n         return;\n     }\n     pOutputBuffer = pWTIntFrame->pAudioBuffer;\n\n    loopEnd = (const EAS_SAMPLE*) pWTVoice->loopEnd + 1;\n    pSamples = (const EAS_SAMPLE*) pWTVoice->phaseAccum;\n /*lint -e{713} truncation is OK */\n    phaseFrac = pWTVoice->phaseFrac;\n    phaseInc = pWTIntFrame->frame.phaseIncrement;\n\n /* fetch adjacent samples */\n#if defined(_8_BIT_SAMPLES)\n /*lint -e{701} <avoid multiply for performance>*/\n    samp1 = pSamples[0] << 8;\n /*lint -e{701} <avoid multiply for performance>*/\n    samp2 = pSamples[1] << 8;\n#else\n    samp1 = pSamples[0];\n    samp2 = pSamples[1];\n#endif\n\n while (numSamples--) {\n\n /* linear interpolation */\n        acc0 = samp2 - samp1;\n        acc0 = acc0 * phaseFrac;\n /*lint -e{704} <avoid divide>*/\n        acc0 = samp1 + (acc0 >> NUM_PHASE_FRAC_BITS);\n\n /* save new output sample in buffer */\n /*lint -e{704} <avoid divide>*/\n *pOutputBuffer++ = (EAS_I16)(acc0 >> 2);\n\n /* increment phase */\n        phaseFrac += phaseInc;\n /*lint -e{704} <avoid divide>*/\n        acc0 = phaseFrac >> NUM_PHASE_FRAC_BITS;\n\n /* next sample */\n if (acc0 > 0) {\n\n /* advance sample pointer */\n            pSamples += acc0;\n            phaseFrac = (EAS_I32)((EAS_U32)phaseFrac & PHASE_FRAC_MASK);\n\n /* check for loop end */\n            acc0 = (EAS_I32) (pSamples - loopEnd);\n if (acc0 >= 0)\n                pSamples = (const EAS_SAMPLE*) pWTVoice->loopStart + acc0;\n\n /* fetch new samples */\n#if defined(_8_BIT_SAMPLES)\n /*lint -e{701} <avoid multiply for performance>*/\n            samp1 = pSamples[0] << 8;\n /*lint -e{701} <avoid multiply for performance>*/\n            samp2 = pSamples[1] << 8;\n#else\n            samp1 = pSamples[0];\n            samp2 = pSamples[1];\n#endif\n }\n }\n\n /* save pointer and phase */\n    pWTVoice->phaseAccum = (EAS_U32) pSamples;\n    pWTVoice->phaseFrac = (EAS_U32) phaseFrac;\n}\n",
    "code_after_change": "void WT_Interpolate (S_WT_VOICE *pWTVoice, S_WT_INT_FRAME *pWTIntFrame)\n{\n    EAS_PCM *pOutputBuffer;\n    EAS_I32 phaseInc;\n    EAS_I32 phaseFrac;\n    EAS_I32 acc0;\n const EAS_SAMPLE *pSamples;\n const EAS_SAMPLE *loopEnd;\n    EAS_I32 samp1;\n    EAS_I32 samp2;\n    EAS_I32 numSamples;\n\n /* initialize some local variables */\n\n     numSamples = pWTIntFrame->numSamples;\n     if (numSamples <= 0) {\n         ALOGE(\"b/26366256\");\n        android_errorWriteLog(0x534e4554, \"26366256\");\n         return;\n     }\n     pOutputBuffer = pWTIntFrame->pAudioBuffer;\n\n    loopEnd = (const EAS_SAMPLE*) pWTVoice->loopEnd + 1;\n    pSamples = (const EAS_SAMPLE*) pWTVoice->phaseAccum;\n /*lint -e{713} truncation is OK */\n    phaseFrac = pWTVoice->phaseFrac;\n    phaseInc = pWTIntFrame->frame.phaseIncrement;\n\n /* fetch adjacent samples */\n#if defined(_8_BIT_SAMPLES)\n /*lint -e{701} <avoid multiply for performance>*/\n    samp1 = pSamples[0] << 8;\n /*lint -e{701} <avoid multiply for performance>*/\n    samp2 = pSamples[1] << 8;\n#else\n    samp1 = pSamples[0];\n    samp2 = pSamples[1];\n#endif\n\n while (numSamples--) {\n\n /* linear interpolation */\n        acc0 = samp2 - samp1;\n        acc0 = acc0 * phaseFrac;\n /*lint -e{704} <avoid divide>*/\n        acc0 = samp1 + (acc0 >> NUM_PHASE_FRAC_BITS);\n\n /* save new output sample in buffer */\n /*lint -e{704} <avoid divide>*/\n *pOutputBuffer++ = (EAS_I16)(acc0 >> 2);\n\n /* increment phase */\n        phaseFrac += phaseInc;\n /*lint -e{704} <avoid divide>*/\n        acc0 = phaseFrac >> NUM_PHASE_FRAC_BITS;\n\n /* next sample */\n if (acc0 > 0) {\n\n /* advance sample pointer */\n            pSamples += acc0;\n            phaseFrac = (EAS_I32)((EAS_U32)phaseFrac & PHASE_FRAC_MASK);\n\n /* check for loop end */\n            acc0 = (EAS_I32) (pSamples - loopEnd);\n if (acc0 >= 0)\n                pSamples = (const EAS_SAMPLE*) pWTVoice->loopStart + acc0;\n\n /* fetch new samples */\n#if defined(_8_BIT_SAMPLES)\n /*lint -e{701} <avoid multiply for performance>*/\n            samp1 = pSamples[0] << 8;\n /*lint -e{701} <avoid multiply for performance>*/\n            samp2 = pSamples[1] << 8;\n#else\n            samp1 = pSamples[0];\n            samp2 = pSamples[1];\n#endif\n }\n }\n\n /* save pointer and phase */\n    pWTVoice->phaseAccum = (EAS_U32) pSamples;\n    pWTVoice->phaseFrac = (EAS_U32) phaseFrac;\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 972,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2017-9995",
    "code_before_change": "static int decode_unit(SCPRContext *s, PixelModel *pixel, unsigned step, unsigned *rval)\n{\n    GetByteContext *gb = &s->gb;\n    RangeCoder *rc = &s->rc;\n    unsigned totfr = pixel->total_freq;\n    unsigned value, x = 0, cumfr = 0, cnt_x = 0;\n    int i, j, ret, c, cnt_c;\n\n    if ((ret = s->get_freq(rc, totfr, &value)) < 0)\n        return ret;\n\n    while (x < 16) {\n        cnt_x = pixel->lookup[x];\n        if (value >= cumfr + cnt_x)\n            cumfr += cnt_x;\n        else\n            break;\n        x++;\n    }\n\n    c = x * 16;\n    cnt_c = 0;\n    while (c < 256) {\n        cnt_c = pixel->freq[c];\n        if (value >= cumfr + cnt_c)\n            cumfr += cnt_c;\n        else\n             break;\n         c++;\n     }\n \n     if ((ret = s->decode(gb, rc, cumfr, cnt_c, totfr)) < 0)\n         return ret;\n\n    pixel->freq[c] = cnt_c + step;\n    pixel->lookup[x] = cnt_x + step;\n    totfr += step;\n    if (totfr > BOT) {\n        totfr = 0;\n        for (i = 0; i < 256; i++) {\n            unsigned nc = (pixel->freq[i] >> 1) + 1;\n            pixel->freq[i] = nc;\n            totfr += nc;\n        }\n        for (i = 0; i < 16; i++) {\n            unsigned sum = 0;\n            unsigned i16_17 = i << 4;\n            for (j = 0; j < 16; j++)\n                sum += pixel->freq[i16_17 + j];\n            pixel->lookup[i] = sum;\n        }\n    }\n    pixel->total_freq = totfr;\n\n    *rval = c & s->cbits;\n\n    return 0;\n}\n",
    "code_after_change": "static int decode_unit(SCPRContext *s, PixelModel *pixel, unsigned step, unsigned *rval)\n{\n    GetByteContext *gb = &s->gb;\n    RangeCoder *rc = &s->rc;\n    unsigned totfr = pixel->total_freq;\n    unsigned value, x = 0, cumfr = 0, cnt_x = 0;\n    int i, j, ret, c, cnt_c;\n\n    if ((ret = s->get_freq(rc, totfr, &value)) < 0)\n        return ret;\n\n    while (x < 16) {\n        cnt_x = pixel->lookup[x];\n        if (value >= cumfr + cnt_x)\n            cumfr += cnt_x;\n        else\n            break;\n        x++;\n    }\n\n    c = x * 16;\n    cnt_c = 0;\n    while (c < 256) {\n        cnt_c = pixel->freq[c];\n        if (value >= cumfr + cnt_c)\n            cumfr += cnt_c;\n        else\n             break;\n         c++;\n     }\n    if (x >= 16 || c >= 256) {\n        return AVERROR_INVALIDDATA;\n    }\n \n     if ((ret = s->decode(gb, rc, cumfr, cnt_c, totfr)) < 0)\n         return ret;\n\n    pixel->freq[c] = cnt_c + step;\n    pixel->lookup[x] = cnt_x + step;\n    totfr += step;\n    if (totfr > BOT) {\n        totfr = 0;\n        for (i = 0; i < 256; i++) {\n            unsigned nc = (pixel->freq[i] >> 1) + 1;\n            pixel->freq[i] = nc;\n            totfr += nc;\n        }\n        for (i = 0; i < 16; i++) {\n            unsigned sum = 0;\n            unsigned i16_17 = i << 4;\n            for (j = 0; j < 16; j++)\n                sum += pixel->freq[i16_17 + j];\n            pixel->lookup[i] = sum;\n        }\n    }\n    pixel->total_freq = totfr;\n\n    *rval = c & s->cbits;\n\n    return 0;\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 976,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-1621",
    "code_before_change": "long long Chapters::Atom::GetStopTime(const Chapters* pChapters) const\n{\n    return GetTime(pChapters, m_stop_timecode);\n}\n",
    "code_after_change": "long long Chapters::Atom::GetStopTime(const Chapters* pChapters) const\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 981,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-2324",
    "code_before_change": "static void process_blob(struct rev_info *revs,\n\t\t\t struct blob *blob,\n\t\t\t show_object_fn show,\n\t\t\t struct strbuf *path,\n\t\t\t const char *name,\n \t\t\t void *cb_data)\n {\n \tstruct object *obj = &blob->object;\n \n \tif (!revs->blob_objects)\n \t\treturn;\n\tif (!obj)\n\t\tdie(\"bad blob object\");\n \tif (obj->flags & (UNINTERESTING | SEEN))\n \t\treturn;\n \tobj->flags |= SEEN;\n\tshow(obj, path, name, cb_data);\n }\n",
    "code_after_change": "static void process_blob(struct rev_info *revs,\n\t\t\t struct blob *blob,\n\t\t\t show_object_fn show,\n\t\t\t struct strbuf *path,\n\t\t\t const char *name,\n \t\t\t void *cb_data)\n {\n \tstruct object *obj = &blob->object;\n\tsize_t pathlen;\n \n \tif (!revs->blob_objects)\n \t\treturn;\n\tif (!obj)\n\t\tdie(\"bad blob object\");\n \tif (obj->flags & (UNINTERESTING | SEEN))\n \t\treturn;\n \tobj->flags |= SEEN;\n\n\tpathlen = path->len;\n\tstrbuf_addstr(path, name);\n\tshow(obj, path->buf, cb_data);\n\tstrbuf_setlen(path, pathlen);\n }\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 989,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-1621",
    "code_before_change": "long long Block::GetTrackNumber() const\n{\n    return m_track;\n }\n",
    "code_after_change": "long long Block::GetTrackNumber() const\nbool Block::IsKey() const {\n  return ((m_flags & static_cast<unsigned char>(1 << 7)) != 0);\n }\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 998,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2013-6623",
    "code_before_change": "UserCloudPolicyManagerChromeOS::UserCloudPolicyManagerChromeOS(\n    scoped_ptr<CloudPolicyStore> store,\n    scoped_ptr<CloudExternalDataManager> external_data_manager,\n    const base::FilePath& component_policy_cache_path,\n    bool wait_for_policy_fetch,\n    base::TimeDelta initial_policy_fetch_timeout,\n    const scoped_refptr<base::SequencedTaskRunner>& task_runner,\n    const scoped_refptr<base::SequencedTaskRunner>& file_task_runner,\n    const scoped_refptr<base::SequencedTaskRunner>& io_task_runner)\n    : CloudPolicyManager(\n          PolicyNamespaceKey(dm_protocol::kChromeUserPolicyType, std::string()),\n          store.get(),\n          task_runner,\n          file_task_runner,\n          io_task_runner),\n      store_(store.Pass()),\n      external_data_manager_(external_data_manager.Pass()),\n      component_policy_cache_path_(component_policy_cache_path),\n       wait_for_policy_fetch_(wait_for_policy_fetch),\n       policy_fetch_timeout_(false, false) {\n   time_init_started_ = base::Time::Now();\n  if (wait_for_policy_fetch_) {\n     policy_fetch_timeout_.Start(\n         FROM_HERE,\n         initial_policy_fetch_timeout,\n        base::Bind(&UserCloudPolicyManagerChromeOS::OnBlockingFetchTimeout,\n                   base::Unretained(this)));\n  }\n}\n",
    "code_after_change": "UserCloudPolicyManagerChromeOS::UserCloudPolicyManagerChromeOS(\n    scoped_ptr<CloudPolicyStore> store,\n    scoped_ptr<CloudExternalDataManager> external_data_manager,\n    const base::FilePath& component_policy_cache_path,\n    bool wait_for_policy_fetch,\n    base::TimeDelta initial_policy_fetch_timeout,\n    const scoped_refptr<base::SequencedTaskRunner>& task_runner,\n    const scoped_refptr<base::SequencedTaskRunner>& file_task_runner,\n    const scoped_refptr<base::SequencedTaskRunner>& io_task_runner)\n    : CloudPolicyManager(\n          PolicyNamespaceKey(dm_protocol::kChromeUserPolicyType, std::string()),\n          store.get(),\n          task_runner,\n          file_task_runner,\n          io_task_runner),\n      store_(store.Pass()),\n      external_data_manager_(external_data_manager.Pass()),\n      component_policy_cache_path_(component_policy_cache_path),\n       wait_for_policy_fetch_(wait_for_policy_fetch),\n       policy_fetch_timeout_(false, false) {\n   time_init_started_ = base::Time::Now();\n  if (wait_for_policy_fetch_ && !initial_policy_fetch_timeout.is_max()) {\n     policy_fetch_timeout_.Start(\n         FROM_HERE,\n         initial_policy_fetch_timeout,\n        base::Bind(&UserCloudPolicyManagerChromeOS::OnBlockingFetchTimeout,\n                   base::Unretained(this)));\n  }\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 1001,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2017-5112",
    "code_before_change": "DrawingBuffer::DrawingBuffer(\n    std::unique_ptr<WebGraphicsContext3DProvider> context_provider,\n    std::unique_ptr<Extensions3DUtil> extensions_util,\n    Client* client,\n    bool discard_framebuffer_supported,\n     bool want_alpha_channel,\n     bool premultiplied_alpha,\n     PreserveDrawingBuffer preserve,\n    WebGLVersion web_gl_version,\n     bool want_depth,\n     bool want_stencil,\n     ChromiumImageUsage chromium_image_usage,\n     const CanvasColorParams& color_params)\n     : client_(client),\n       preserve_drawing_buffer_(preserve),\n      web_gl_version_(web_gl_version),\n       context_provider_(WTF::WrapUnique(new WebGraphicsContext3DProviderWrapper(\n           std::move(context_provider)))),\n       gl_(this->ContextProvider()->ContextGL()),\n      extensions_util_(std::move(extensions_util)),\n      discard_framebuffer_supported_(discard_framebuffer_supported),\n      want_alpha_channel_(want_alpha_channel),\n      premultiplied_alpha_(premultiplied_alpha),\n      software_rendering_(this->ContextProvider()->IsSoftwareRendering()),\n      want_depth_(want_depth),\n      want_stencil_(want_stencil),\n      color_space_(color_params.GetGfxColorSpace()),\n      chromium_image_usage_(chromium_image_usage) {\n  TRACE_EVENT_INSTANT0(\"test_gpu\", \"DrawingBufferCreation\",\n                       TRACE_EVENT_SCOPE_GLOBAL);\n}\n",
    "code_after_change": "DrawingBuffer::DrawingBuffer(\n    std::unique_ptr<WebGraphicsContext3DProvider> context_provider,\n    std::unique_ptr<Extensions3DUtil> extensions_util,\n    Client* client,\n    bool discard_framebuffer_supported,\n     bool want_alpha_channel,\n     bool premultiplied_alpha,\n     PreserveDrawingBuffer preserve,\n    WebGLVersion webgl_version,\n     bool want_depth,\n     bool want_stencil,\n     ChromiumImageUsage chromium_image_usage,\n     const CanvasColorParams& color_params)\n     : client_(client),\n       preserve_drawing_buffer_(preserve),\n      webgl_version_(webgl_version),\n       context_provider_(WTF::WrapUnique(new WebGraphicsContext3DProviderWrapper(\n           std::move(context_provider)))),\n       gl_(this->ContextProvider()->ContextGL()),\n      extensions_util_(std::move(extensions_util)),\n      discard_framebuffer_supported_(discard_framebuffer_supported),\n      want_alpha_channel_(want_alpha_channel),\n      premultiplied_alpha_(premultiplied_alpha),\n      software_rendering_(this->ContextProvider()->IsSoftwareRendering()),\n      want_depth_(want_depth),\n      want_stencil_(want_stencil),\n      color_space_(color_params.GetGfxColorSpace()),\n      chromium_image_usage_(chromium_image_usage) {\n  TRACE_EVENT_INSTANT0(\"test_gpu\", \"DrawingBufferCreation\",\n                       TRACE_EVENT_SCOPE_GLOBAL);\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 1002,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-1621",
    "code_before_change": "long Block::Frame::Read(IMkvReader* pReader, unsigned char* buf) const\n{\n    assert(pReader);\n    assert(buf);\n    const long status = pReader->Read(pos, len, buf);\n    return status;\n}\n",
    "code_after_change": "long Block::Frame::Read(IMkvReader* pReader, unsigned char* buf) const\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 1009,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-1621",
    "code_before_change": " static void set_roi_map(const vpx_codec_enc_cfg_t *cfg,\n                         vpx_codec_ctx_t *codec) {\n   unsigned int i;\n  vpx_roi_map_t roi = {0};\n \n   roi.rows = (cfg->g_h + 15) / 16;\n   roi.cols = (cfg->g_w + 15) / 16;\n\n  roi.delta_q[0] = 0;\n  roi.delta_q[1] = -2;\n  roi.delta_q[2] = -4;\n  roi.delta_q[3] = -6;\n\n  roi.delta_lf[0] = 0;\n  roi.delta_lf[1] = 1;\n  roi.delta_lf[2] = 2;\n  roi.delta_lf[3] = 3;\n\n  roi.static_threshold[0] = 1500;\n  roi.static_threshold[1] = 1000;\n  roi.static_threshold[2] = 500;\n  roi.static_threshold[3] = 0;\n\n  roi.roi_map = (uint8_t *)malloc(roi.rows * roi.cols);\n for (i = 0; i < roi.rows * roi.cols; ++i)\n    roi.roi_map[i] = i % 4;\n\n if (vpx_codec_control(codec, VP8E_SET_ROI_MAP, &roi))\n    die_codec(codec, \"Failed to set ROI map\");\n\n  free(roi.roi_map);\n}\n",
    "code_after_change": " static void set_roi_map(const vpx_codec_enc_cfg_t *cfg,\n                         vpx_codec_ctx_t *codec) {\n   unsigned int i;\n  vpx_roi_map_t roi;\n  memset(&roi, 0, sizeof(roi));\n \n   roi.rows = (cfg->g_h + 15) / 16;\n   roi.cols = (cfg->g_w + 15) / 16;\n\n  roi.delta_q[0] = 0;\n  roi.delta_q[1] = -2;\n  roi.delta_q[2] = -4;\n  roi.delta_q[3] = -6;\n\n  roi.delta_lf[0] = 0;\n  roi.delta_lf[1] = 1;\n  roi.delta_lf[2] = 2;\n  roi.delta_lf[3] = 3;\n\n  roi.static_threshold[0] = 1500;\n  roi.static_threshold[1] = 1000;\n  roi.static_threshold[2] = 500;\n  roi.static_threshold[3] = 0;\n\n  roi.roi_map = (uint8_t *)malloc(roi.rows * roi.cols);\n for (i = 0; i < roi.rows * roi.cols; ++i)\n    roi.roi_map[i] = i % 4;\n\n if (vpx_codec_control(codec, VP8E_SET_ROI_MAP, &roi))\n    die_codec(codec, \"Failed to set ROI map\");\n\n  free(roi.roi_map);\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 1014,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2017-0592",
    "code_before_change": "static void copyMultiCh24(short *dst, const int *const *src, unsigned nSamples, unsigned nChannels)\n {\n     for (unsigned i = 0; i < nSamples; ++i) {\n         for (unsigned c = 0; c < nChannels; ++c) {\n *dst++ = src[c][i] >> 8;\n }\n }\n}\n",
    "code_after_change": "static void copyMultiCh24(short *dst, const int *const *src, unsigned nSamples, unsigned nChannels)\nstatic void copyMultiCh24(short *dst, const int * src[FLACParser::kMaxChannels], unsigned nSamples, unsigned nChannels)\n {\n     for (unsigned i = 0; i < nSamples; ++i) {\n         for (unsigned c = 0; c < nChannels; ++c) {\n *dst++ = src[c][i] >> 8;\n }\n }\n}\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 1019,
    "_valid_cwes": [
      "CWE-119"
    ]
  },
  {
    "cve_id": "CVE-2016-1621",
    "code_before_change": "long Chapters::Atom::Parse(\n    IMkvReader* pReader,\n    long long pos,\n    long long size)\n{\n    const long long stop = pos + size;\n    while (pos < stop)\n    {\n        long long id, size;\n        long status = ParseElementHeader(\n                        pReader,\n                        pos,\n                        stop,\n                        id,\n                        size);\n        if (status < 0)  // error\n            return status;\n        if (size == 0)  // weird\n            continue;\n        if (id == 0x00)  // Display ID\n        {\n            status = ParseDisplay(pReader, pos, size);\n            if (status < 0)  // error\n                return status;\n        }\n        else if (id == 0x1654)  // StringUID ID\n        {\n            status = UnserializeString(pReader, pos, size, m_string_uid);\n            if (status < 0)  // error\n                return status;\n        }\n        else if (id == 0x33C4)  // UID ID\n        {\n            long long val;\n            status = UnserializeInt(pReader, pos, size, val);\n            if (status < 0)  // error\n                return status;\n            m_uid = val;\n        }\n        else if (id == 0x11)  // TimeStart ID\n        {\n            const long long val = UnserializeUInt(pReader, pos, size);\n            if (val < 0)  // error\n                return static_cast<long>(val);\n            m_start_timecode = val;\n        }\n        else if (id == 0x12)  // TimeEnd ID\n        {\n            const long long val = UnserializeUInt(pReader, pos, size);\n            if (val < 0)  // error\n                return static_cast<long>(val);\n            m_stop_timecode = val;\n        }\n        pos += size;\n        assert(pos <= stop);\n    }\n    assert(pos == stop);\n    return 0;\n}\n",
    "code_after_change": "long Chapters::Atom::Parse(\n",
    "cwe": [
      "CWE-119"
    ],
    "id": 1020,
    "_valid_cwes": [
      "CWE-119"
    ]
  }
]