[
  {
    "cve_id": "CVE-2016-3760",
    "code_before_change": "void bdt_enable(void)\n{\n    bdt_log(\"ENABLE BT\");\n if (bt_enabled) {\n\n         bdt_log(\"Bluetooth is already enabled\");\n         return;\n     }\n    status = sBtInterface->enable();\n \n     check_return_status(status);\n }\n",
    "code_after_change": "void bdt_enable(void)\n{\n    bdt_log(\"ENABLE BT\");\n if (bt_enabled) {\n\n         bdt_log(\"Bluetooth is already enabled\");\n         return;\n     }\n    status = sBtInterface->enable(false);\n \n     check_return_status(status);\n }\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 17,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2018-6050",
    "code_before_change": "bool IDNSpoofChecker::SafeToDisplayAsUnicode(base::StringPiece16 label,\n                                             bool is_tld_ascii) {\n  UErrorCode status = U_ZERO_ERROR;\n  int32_t result =\n      uspoof_check(checker_, label.data(),\n                   base::checked_cast<int32_t>(label.size()), nullptr, &status);\n  if (U_FAILURE(status) || (result & USPOOF_ALL_CHECKS))\n    return false;\n\n  icu::UnicodeString label_string(FALSE, label.data(),\n                                  base::checked_cast<int32_t>(label.size()));\n\n  if (deviation_characters_.containsSome(label_string))\n    return false;\n\n  result &= USPOOF_RESTRICTION_LEVEL_MASK;\n  if (result == USPOOF_ASCII)\n    return true;\n  if (result == USPOOF_SINGLE_SCRIPT_RESTRICTIVE &&\n      kana_letters_exceptions_.containsNone(label_string) &&\n      combining_diacritics_exceptions_.containsNone(label_string)) {\n    return !is_tld_ascii || !IsMadeOfLatinAlikeCyrillic(label_string);\n  }\n\n  if (non_ascii_latin_letters_.containsSome(label_string) &&\n      !lgc_letters_n_ascii_.containsAll(label_string))\n    return false;\n\n  if (!tls_index.initialized())\n    tls_index.Initialize(&OnThreadTermination);\n  icu::RegexMatcher* dangerous_pattern =\n      reinterpret_cast<icu::RegexMatcher*>(tls_index.Get());\n  if (!dangerous_pattern) {\n     dangerous_pattern = new icu::RegexMatcher(\n        icu::UnicodeString(\n            R\"([^\\p{scx=kana}\\p{scx=hira}\\p{scx=hani}])\"\n            R\"([\\u30ce\\u30f3\\u30bd\\u30be])\"\n            R\"([^\\p{scx=kana}\\p{scx=hira}\\p{scx=hani}]|)\"\n            R\"([^\\p{scx=kana}\\p{scx=hira}]\\u30fc|^\\u30fc|)\"\n            R\"([^\\p{scx=kana}][\\u30fd\\u30fe]|^[\\u30fd\\u30fe]|)\"\n            R\"(^[\\p{scx=kana}]+[\\u3078-\\u307a][\\p{scx=kana}]+$|)\"\n             R\"(^[\\p{scx=hira}]+[\\u30d8-\\u30da][\\p{scx=hira}]+$|)\"\n             R\"([a-z]\\u30fb|\\u30fb[a-z]|)\"\n             R\"([^\\p{scx=latn}\\p{scx=grek}\\p{scx=cyrl}][\\u0300-\\u0339]|)\"\n            R\"([ijl\\u0131]\\u0307)\",\n             -1, US_INV),\n         0, status);\n     tls_index.Set(dangerous_pattern);\n  }\n  dangerous_pattern->reset(label_string);\n  return !dangerous_pattern->find();\n}\n",
    "code_after_change": "bool IDNSpoofChecker::SafeToDisplayAsUnicode(base::StringPiece16 label,\n                                             bool is_tld_ascii) {\n  UErrorCode status = U_ZERO_ERROR;\n  int32_t result =\n      uspoof_check(checker_, label.data(),\n                   base::checked_cast<int32_t>(label.size()), nullptr, &status);\n  if (U_FAILURE(status) || (result & USPOOF_ALL_CHECKS))\n    return false;\n\n  icu::UnicodeString label_string(FALSE, label.data(),\n                                  base::checked_cast<int32_t>(label.size()));\n\n  if (deviation_characters_.containsSome(label_string))\n    return false;\n\n  result &= USPOOF_RESTRICTION_LEVEL_MASK;\n  if (result == USPOOF_ASCII)\n    return true;\n  if (result == USPOOF_SINGLE_SCRIPT_RESTRICTIVE &&\n      kana_letters_exceptions_.containsNone(label_string) &&\n      combining_diacritics_exceptions_.containsNone(label_string)) {\n    return !is_tld_ascii || !IsMadeOfLatinAlikeCyrillic(label_string);\n  }\n\n  if (non_ascii_latin_letters_.containsSome(label_string) &&\n      !lgc_letters_n_ascii_.containsAll(label_string))\n    return false;\n\n  if (!tls_index.initialized())\n    tls_index.Initialize(&OnThreadTermination);\n  icu::RegexMatcher* dangerous_pattern =\n      reinterpret_cast<icu::RegexMatcher*>(tls_index.Get());\n  if (!dangerous_pattern) {\n    // - Disallow dotless i (U+0131) followed by a combining mark.\n     dangerous_pattern = new icu::RegexMatcher(\n        icu::UnicodeString(\n            R\"([^\\p{scx=kana}\\p{scx=hira}\\p{scx=hani}])\"\n            R\"([\\u30ce\\u30f3\\u30bd\\u30be])\"\n            R\"([^\\p{scx=kana}\\p{scx=hira}\\p{scx=hani}]|)\"\n            R\"([^\\p{scx=kana}\\p{scx=hira}]\\u30fc|^\\u30fc|)\"\n            R\"([^\\p{scx=kana}][\\u30fd\\u30fe]|^[\\u30fd\\u30fe]|)\"\n            R\"(^[\\p{scx=kana}]+[\\u3078-\\u307a][\\p{scx=kana}]+$|)\"\n             R\"(^[\\p{scx=hira}]+[\\u30d8-\\u30da][\\p{scx=hira}]+$|)\"\n             R\"([a-z]\\u30fb|\\u30fb[a-z]|)\"\n             R\"([^\\p{scx=latn}\\p{scx=grek}\\p{scx=cyrl}][\\u0300-\\u0339]|)\"\n            R\"(\\u0131[\\u0300-\\u0339]|)\"\n            R\"([ijl]\\u0307)\",\n             -1, US_INV),\n         0, status);\n     tls_index.Set(dangerous_pattern);\n  }\n  dangerous_pattern->reset(label_string);\n  return !dangerous_pattern->find();\n}\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 30,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2017-15951",
    "code_before_change": "static noinline void key_gc_unused_keys(struct list_head *keys)\n{\n \twhile (!list_empty(keys)) {\n \t\tstruct key *key =\n \t\t\tlist_entry(keys->next, struct key, graveyard_link);\n \t\tlist_del(&key->graveyard_link);\n \n \t\tkdebug(\"- %u\", key->serial);\n \t\tkey_check(key);\n \n \t\t/* Throw away the key data if the key is instantiated */\n\t\tif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags) &&\n\t\t    !test_bit(KEY_FLAG_NEGATIVE, &key->flags) &&\n\t\t    key->type->destroy)\n \t\t\tkey->type->destroy(key);\n \n \t\tsecurity_key_free(key);\n\n\t\t/* deal with the user's key tracking and quota */\n\t\tif (test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\t\tspin_lock(&key->user->lock);\n\t\t\tkey->user->qnkeys--;\n\t\t\tkey->user->qnbytes -= key->quotalen;\n\t\t\tspin_unlock(&key->user->lock);\n \t\t}\n \n \t\tatomic_dec(&key->user->nkeys);\n\t\tif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags))\n \t\t\tatomic_dec(&key->user->nikeys);\n \n \t\tkey_user_put(key->user);\n\n\t\tkfree(key->description);\n\n\t\tmemzero_explicit(key, sizeof(*key));\n\t\tkmem_cache_free(key_jar, key);\n\t}\n}\n",
    "code_after_change": "static noinline void key_gc_unused_keys(struct list_head *keys)\n{\n \twhile (!list_empty(keys)) {\n \t\tstruct key *key =\n \t\t\tlist_entry(keys->next, struct key, graveyard_link);\n\t\tshort state = key->state;\n\n \t\tlist_del(&key->graveyard_link);\n \n \t\tkdebug(\"- %u\", key->serial);\n \t\tkey_check(key);\n \n \t\t/* Throw away the key data if the key is instantiated */\n\t\tif (state == KEY_IS_POSITIVE && key->type->destroy)\n \t\t\tkey->type->destroy(key);\n \n \t\tsecurity_key_free(key);\n\n\t\t/* deal with the user's key tracking and quota */\n\t\tif (test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\t\tspin_lock(&key->user->lock);\n\t\t\tkey->user->qnkeys--;\n\t\t\tkey->user->qnbytes -= key->quotalen;\n\t\t\tspin_unlock(&key->user->lock);\n \t\t}\n \n \t\tatomic_dec(&key->user->nkeys);\n\t\tif (state != KEY_IS_UNINSTANTIATED)\n \t\t\tatomic_dec(&key->user->nikeys);\n \n \t\tkey_user_put(key->user);\n\n\t\tkfree(key->description);\n\n\t\tmemzero_explicit(key, sizeof(*key));\n\t\tkmem_cache_free(key_jar, key);\n\t}\n}\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 31,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2016-5218",
    "code_before_change": "TabGroupData::TabGroupData() {\n  static int next_placeholder_title_number = 1;\n  title_ = base::ASCIIToUTF16(\n      \"Group \" + base::NumberToString(next_placeholder_title_number));\n   ++next_placeholder_title_number;\n \n   static SkRandom rand;\n  stroke_color_ = rand.nextU() | 0xff000000;\n }\n",
    "code_after_change": "TabGroupData::TabGroupData() {\n  static int next_placeholder_title_number = 1;\n  title_ = base::ASCIIToUTF16(\n      \"Group \" + base::NumberToString(next_placeholder_title_number));\n   ++next_placeholder_title_number;\n \n   static SkRandom rand;\n  color_ = rand.nextU() | 0xff000000;\n }\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 47,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2012-5148",
    "code_before_change": "void BrowserCommandController::TabDetachedAt(TabContents* contents, int index) {\n   RemoveInterstitialObservers(contents);\n }\n",
    "code_after_change": "void BrowserCommandController::TabDetachedAt(TabContents* contents, int index) {\nvoid BrowserCommandController::TabDetachedAt(WebContents* contents, int index) {\n   RemoveInterstitialObservers(contents);\n }\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 52,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2017-13145",
    "code_before_change": "static Image *ReadJP2Image(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  const char\n    *option;\n\n  Image\n    *image;\n\n  int\n    jp2_status;\n\n  MagickBooleanType\n    status;\n\n  opj_codec_t\n    *jp2_codec;\n\n  opj_codestream_index_t\n    *codestream_index = (opj_codestream_index_t *) NULL;\n\n  opj_dparameters_t\n    parameters;\n\n  opj_image_t\n    *jp2_image;\n\n  opj_stream_t\n    *jp2_stream;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    y;\n\n  unsigned char\n    sans[4];\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Initialize JP2 codec.\n  */\n  if (ReadBlob(image,4,sans) != 4)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) SeekBlob(image,SEEK_SET,0);\n  if (LocaleCompare(image_info->magick,\"JPT\") == 0)\n    jp2_codec=opj_create_decompress(OPJ_CODEC_JPT);\n  else\n    if (IsJ2K(sans,4) != MagickFalse)\n      jp2_codec=opj_create_decompress(OPJ_CODEC_J2K);\n    else\n      jp2_codec=opj_create_decompress(OPJ_CODEC_JP2);\n  opj_set_warning_handler(jp2_codec,JP2WarningHandler,exception);\n  opj_set_error_handler(jp2_codec,JP2ErrorHandler,exception);\n  opj_set_default_decoder_parameters(&parameters);\n  option=GetImageOption(image_info,\"jp2:reduce-factor\");\n  if (option != (const char *) NULL)\n    parameters.cp_reduce=StringToInteger(option);\n  option=GetImageOption(image_info,\"jp2:quality-layers\");\n  if (option == (const char *) NULL)\n    option=GetImageOption(image_info,\"jp2:layer-number\");\n  if (option != (const char *) NULL)\n    parameters.cp_layer=StringToInteger(option);\n  if (opj_setup_decoder(jp2_codec,&parameters) == 0)\n    {\n      opj_destroy_codec(jp2_codec);\n      ThrowReaderException(DelegateError,\"UnableToManageJP2Stream\");\n    }\n  jp2_stream=opj_stream_create(OPJ_J2K_STREAM_CHUNK_SIZE,OPJ_TRUE);\n  opj_stream_set_read_function(jp2_stream,JP2ReadHandler);\n  opj_stream_set_write_function(jp2_stream,JP2WriteHandler);\n  opj_stream_set_seek_function(jp2_stream,JP2SeekHandler);\n  opj_stream_set_skip_function(jp2_stream,JP2SkipHandler);\n  opj_stream_set_user_data(jp2_stream,image,NULL);\n  opj_stream_set_user_data_length(jp2_stream,GetBlobSize(image));\n  if (opj_read_header(jp2_stream,jp2_codec,&jp2_image) == 0)\n    {\n      opj_stream_destroy(jp2_stream);\n      opj_destroy_codec(jp2_codec);\n      ThrowReaderException(DelegateError,\"UnableToDecodeImageFile\");\n    }\n  jp2_status=1;\n  if ((image->columns != 0) && (image->rows != 0))\n    {\n      /*\n        Extract an area from the image.\n      */\n      jp2_status=opj_set_decode_area(jp2_codec,jp2_image,\n        (OPJ_INT32) image->extract_info.x,(OPJ_INT32) image->extract_info.y,\n        (OPJ_INT32) image->extract_info.x+(ssize_t) image->columns,\n        (OPJ_INT32) image->extract_info.y+(ssize_t) image->rows);\n      if (jp2_status == 0)\n        {\n          opj_stream_destroy(jp2_stream);\n          opj_destroy_codec(jp2_codec);\n          opj_image_destroy(jp2_image);\n          ThrowReaderException(DelegateError,\"UnableToDecodeImageFile\");\n        }\n    }\n  if ((image_info->number_scenes != 0) && (image_info->scene != 0))\n    jp2_status=opj_get_decoded_tile(jp2_codec,jp2_stream,jp2_image,\n      (unsigned int) image_info->scene-1);\n  else\n    if (image->ping == MagickFalse)\n      {\n        jp2_status=opj_decode(jp2_codec,jp2_stream,jp2_image);\n        if (jp2_status != 0)\n          jp2_status=opj_end_decompress(jp2_codec,jp2_stream);\n      }\n  if (jp2_status == 0)\n    {\n      opj_stream_destroy(jp2_stream);\n      opj_destroy_codec(jp2_codec);\n      opj_image_destroy(jp2_image);\n      ThrowReaderException(DelegateError,\"UnableToDecodeImageFile\");\n    }\n  opj_stream_destroy(jp2_stream);\n  for (i=0; i < (ssize_t) jp2_image->numcomps; i++)\n  {\n    if ((jp2_image->comps[0].dx == 0) || (jp2_image->comps[0].dy == 0) ||\n         (jp2_image->comps[0].dx != jp2_image->comps[i].dx) ||\n         (jp2_image->comps[0].dy != jp2_image->comps[i].dy) ||\n         (jp2_image->comps[0].prec != jp2_image->comps[i].prec) ||\n        (jp2_image->comps[0].sgnd != jp2_image->comps[i].sgnd))\n       {\n         opj_destroy_codec(jp2_codec);\n         opj_image_destroy(jp2_image);\n        ThrowReaderException(CoderError,\"IrregularChannelGeometryNotSupported\")\n      }\n  }\n  /*\n    Convert JP2 image.\n  */\n  image->columns=(size_t) jp2_image->comps[0].w;\n  image->rows=(size_t) jp2_image->comps[0].h;\n  image->depth=jp2_image->comps[0].prec;\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  image->compression=JPEG2000Compression;\n  if (jp2_image->color_space == 2)\n    {\n      SetImageColorspace(image,GRAYColorspace);\n      if (jp2_image->numcomps > 1)\n        image->matte=MagickTrue;\n    }\n  else\n    if (jp2_image->color_space == 3)\n      SetImageColorspace(image,Rec601YCbCrColorspace);\n  if (jp2_image->numcomps > 3)\n    image->matte=MagickTrue;\n  if (jp2_image->icc_profile_buf != (unsigned char *) NULL)\n    {\n      StringInfo\n        *profile;\n\n      profile=BlobToStringInfo(jp2_image->icc_profile_buf,\n        jp2_image->icc_profile_len);\n      if (profile != (StringInfo *) NULL)\n        SetImageProfile(image,\"icc\",profile);\n    }\n  if (image->ping != MagickFalse)\n    {\n      opj_destroy_codec(jp2_codec);\n      opj_image_destroy(jp2_image);\n      opj_destroy_cstr_index(&codestream_index);\n      return(GetFirstImageInList(image));\n    }\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register PixelPacket\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      for (i=0; i < (ssize_t) jp2_image->numcomps; i++)\n      {\n        double\n          pixel,\n          scale;\n\n        scale=QuantumRange/(double) ((1UL << jp2_image->comps[i].prec)-1);\n        pixel=scale*(jp2_image->comps[i].data[y/jp2_image->comps[i].dy*\n          image->columns/jp2_image->comps[i].dx+x/jp2_image->comps[i].dx]+\n          (jp2_image->comps[i].sgnd ? 1UL << (jp2_image->comps[i].prec-1) : 0));\n        switch (i)\n        {\n           case 0:\n           {\n             q->red=ClampToQuantum(pixel);\n             q->green=q->red;\n             q->blue=q->red;\n             q->opacity=OpaqueOpacity;\n             break;\n           }\n           case 1:\n           {\n             if (jp2_image->numcomps == 2)\n               {\n                 q->opacity=ClampToQuantum(QuantumRange-pixel);\n                 break;\n               }\n             q->green=ClampToQuantum(pixel);\n             break;\n           }\n           case 2:\n           {\n             q->blue=ClampToQuantum(pixel);\n             break;\n           }\n           case 3:\n           {\n             q->opacity=ClampToQuantum(QuantumRange-pixel);\n             break;\n           }\n        }\n      }\n      q++;\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  /*\n    Free resources.\n  */\n  opj_destroy_codec(jp2_codec);\n  opj_image_destroy(jp2_image);\n  opj_destroy_cstr_index(&codestream_index);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n",
    "code_after_change": "static Image *ReadJP2Image(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  const char\n    *option;\n\n  Image\n    *image;\n\n  int\n    jp2_status;\n\n  MagickBooleanType\n    status;\n\n  opj_codec_t\n    *jp2_codec;\n\n  opj_codestream_index_t\n    *codestream_index = (opj_codestream_index_t *) NULL;\n\n  opj_dparameters_t\n    parameters;\n\n  opj_image_t\n    *jp2_image;\n\n  opj_stream_t\n    *jp2_stream;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    y;\n\n  unsigned char\n    sans[4];\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Initialize JP2 codec.\n  */\n  if (ReadBlob(image,4,sans) != 4)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) SeekBlob(image,SEEK_SET,0);\n  if (LocaleCompare(image_info->magick,\"JPT\") == 0)\n    jp2_codec=opj_create_decompress(OPJ_CODEC_JPT);\n  else\n    if (IsJ2K(sans,4) != MagickFalse)\n      jp2_codec=opj_create_decompress(OPJ_CODEC_J2K);\n    else\n      jp2_codec=opj_create_decompress(OPJ_CODEC_JP2);\n  opj_set_warning_handler(jp2_codec,JP2WarningHandler,exception);\n  opj_set_error_handler(jp2_codec,JP2ErrorHandler,exception);\n  opj_set_default_decoder_parameters(&parameters);\n  option=GetImageOption(image_info,\"jp2:reduce-factor\");\n  if (option != (const char *) NULL)\n    parameters.cp_reduce=StringToInteger(option);\n  option=GetImageOption(image_info,\"jp2:quality-layers\");\n  if (option == (const char *) NULL)\n    option=GetImageOption(image_info,\"jp2:layer-number\");\n  if (option != (const char *) NULL)\n    parameters.cp_layer=StringToInteger(option);\n  if (opj_setup_decoder(jp2_codec,&parameters) == 0)\n    {\n      opj_destroy_codec(jp2_codec);\n      ThrowReaderException(DelegateError,\"UnableToManageJP2Stream\");\n    }\n  jp2_stream=opj_stream_create(OPJ_J2K_STREAM_CHUNK_SIZE,OPJ_TRUE);\n  opj_stream_set_read_function(jp2_stream,JP2ReadHandler);\n  opj_stream_set_write_function(jp2_stream,JP2WriteHandler);\n  opj_stream_set_seek_function(jp2_stream,JP2SeekHandler);\n  opj_stream_set_skip_function(jp2_stream,JP2SkipHandler);\n  opj_stream_set_user_data(jp2_stream,image,NULL);\n  opj_stream_set_user_data_length(jp2_stream,GetBlobSize(image));\n  if (opj_read_header(jp2_stream,jp2_codec,&jp2_image) == 0)\n    {\n      opj_stream_destroy(jp2_stream);\n      opj_destroy_codec(jp2_codec);\n      ThrowReaderException(DelegateError,\"UnableToDecodeImageFile\");\n    }\n  jp2_status=1;\n  if ((image->columns != 0) && (image->rows != 0))\n    {\n      /*\n        Extract an area from the image.\n      */\n      jp2_status=opj_set_decode_area(jp2_codec,jp2_image,\n        (OPJ_INT32) image->extract_info.x,(OPJ_INT32) image->extract_info.y,\n        (OPJ_INT32) image->extract_info.x+(ssize_t) image->columns,\n        (OPJ_INT32) image->extract_info.y+(ssize_t) image->rows);\n      if (jp2_status == 0)\n        {\n          opj_stream_destroy(jp2_stream);\n          opj_destroy_codec(jp2_codec);\n          opj_image_destroy(jp2_image);\n          ThrowReaderException(DelegateError,\"UnableToDecodeImageFile\");\n        }\n    }\n  if ((image_info->number_scenes != 0) && (image_info->scene != 0))\n    jp2_status=opj_get_decoded_tile(jp2_codec,jp2_stream,jp2_image,\n      (unsigned int) image_info->scene-1);\n  else\n    if (image->ping == MagickFalse)\n      {\n        jp2_status=opj_decode(jp2_codec,jp2_stream,jp2_image);\n        if (jp2_status != 0)\n          jp2_status=opj_end_decompress(jp2_codec,jp2_stream);\n      }\n  if (jp2_status == 0)\n    {\n      opj_stream_destroy(jp2_stream);\n      opj_destroy_codec(jp2_codec);\n      opj_image_destroy(jp2_image);\n      ThrowReaderException(DelegateError,\"UnableToDecodeImageFile\");\n    }\n  opj_stream_destroy(jp2_stream);\n  for (i=0; i < (ssize_t) jp2_image->numcomps; i++)\n  {\n    if ((jp2_image->comps[0].dx == 0) || (jp2_image->comps[0].dy == 0) ||\n         (jp2_image->comps[0].dx != jp2_image->comps[i].dx) ||\n         (jp2_image->comps[0].dy != jp2_image->comps[i].dy) ||\n         (jp2_image->comps[0].prec != jp2_image->comps[i].prec) ||\n        (jp2_image->comps[0].sgnd != jp2_image->comps[i].sgnd) ||\n        (jp2_image->comps[i].data == NULL))\n       {\n         opj_destroy_codec(jp2_codec);\n         opj_image_destroy(jp2_image);\n        ThrowReaderException(CoderError,\"IrregularChannelGeometryNotSupported\")\n      }\n  }\n  /*\n    Convert JP2 image.\n  */\n  image->columns=(size_t) jp2_image->comps[0].w;\n  image->rows=(size_t) jp2_image->comps[0].h;\n  image->depth=jp2_image->comps[0].prec;\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  image->compression=JPEG2000Compression;\n  if (jp2_image->color_space == 2)\n    {\n      SetImageColorspace(image,GRAYColorspace);\n      if (jp2_image->numcomps > 1)\n        image->matte=MagickTrue;\n    }\n  else\n    if (jp2_image->color_space == 3)\n      SetImageColorspace(image,Rec601YCbCrColorspace);\n  if (jp2_image->numcomps > 3)\n    image->matte=MagickTrue;\n  if (jp2_image->icc_profile_buf != (unsigned char *) NULL)\n    {\n      StringInfo\n        *profile;\n\n      profile=BlobToStringInfo(jp2_image->icc_profile_buf,\n        jp2_image->icc_profile_len);\n      if (profile != (StringInfo *) NULL)\n        SetImageProfile(image,\"icc\",profile);\n    }\n  if (image->ping != MagickFalse)\n    {\n      opj_destroy_codec(jp2_codec);\n      opj_image_destroy(jp2_image);\n      opj_destroy_cstr_index(&codestream_index);\n      return(GetFirstImageInList(image));\n    }\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register PixelPacket\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      for (i=0; i < (ssize_t) jp2_image->numcomps; i++)\n      {\n        double\n          pixel,\n          scale;\n\n        scale=QuantumRange/(double) ((1UL << jp2_image->comps[i].prec)-1);\n        pixel=scale*(jp2_image->comps[i].data[y/jp2_image->comps[i].dy*\n          image->columns/jp2_image->comps[i].dx+x/jp2_image->comps[i].dx]+\n          (jp2_image->comps[i].sgnd ? 1UL << (jp2_image->comps[i].prec-1) : 0));\n        switch (i)\n        {\n           case 0:\n           {\n             q->red=ClampToQuantum(pixel);\n             q->green=q->red;\n             q->blue=q->red;\n             q->opacity=OpaqueOpacity;\n             break;\n           }\n           case 1:\n           {\n             if (jp2_image->numcomps == 2)\n               {\n                 q->opacity=ClampToQuantum(QuantumRange-pixel);\n                 break;\n               }\n             q->green=ClampToQuantum(pixel);\n             break;\n           }\n           case 2:\n           {\n             q->blue=ClampToQuantum(pixel);\n             break;\n           }\n           case 3:\n           {\n             q->opacity=ClampToQuantum(QuantumRange-pixel);\n             break;\n           }\n        }\n      }\n      q++;\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  /*\n    Free resources.\n  */\n  opj_destroy_codec(jp2_codec);\n  opj_image_destroy(jp2_image);\n  opj_destroy_cstr_index(&codestream_index);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 60,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2017-5104",
    "code_before_change": " bool WebContentsImpl::IsLoading() const {\n   return frame_tree_.IsLoading() &&\n         !(ShowingInterstitialPage() &&\n           GetRenderManager()->interstitial_page()->pause_throbber());\n }\n",
    "code_after_change": " bool WebContentsImpl::IsLoading() const {\n   return frame_tree_.IsLoading() &&\n         !(ShowingInterstitialPage() && interstitial_page_->pause_throbber());\n }\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 77,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2018-16643",
    "code_before_change": "static Image *ReadDCMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define ThrowDCMException(exception,message) \\\n{ \\\n  if (info.scale != (Quantum *) NULL) \\\n    info.scale=(Quantum *) RelinquishMagickMemory(info.scale); \\\n  if (data != (unsigned char *) NULL) \\\n    data=(unsigned char *) RelinquishMagickMemory(data); \\\n  if (graymap != (int *) NULL) \\\n    graymap=(int *) RelinquishMagickMemory(graymap); \\\n  if (bluemap != (int *) NULL) \\\n    bluemap=(int *) RelinquishMagickMemory(bluemap); \\\n  if (greenmap != (int *) NULL) \\\n    greenmap=(int *) RelinquishMagickMemory(greenmap); \\\n  if (redmap != (int *) NULL) \\\n    redmap=(int *) RelinquishMagickMemory(redmap); \\\n  if (stream_info->offsets != (ssize_t *) NULL) \\\n    stream_info->offsets=(ssize_t *) RelinquishMagickMemory( \\\n      stream_info->offsets); \\\n  if (stream_info != (DCMStreamInfo *) NULL) \\\n    stream_info=(DCMStreamInfo *) RelinquishMagickMemory(stream_info); \\\n  ThrowReaderException((exception),(message)); \\\n}\n\n  char\n    explicit_vr[MagickPathExtent],\n    implicit_vr[MagickPathExtent],\n    magick[MagickPathExtent],\n    photometric[MagickPathExtent];\n\n  DCMInfo\n    info;\n\n  DCMStreamInfo\n    *stream_info;\n\n  Image\n    *image;\n\n  int\n    *bluemap,\n    datum,\n    *greenmap,\n    *graymap,\n    *redmap;\n\n  MagickBooleanType\n    explicit_file,\n    explicit_retry,\n    use_explicit;\n\n  MagickOffsetType\n    offset;\n\n  register unsigned char\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    colors,\n    height,\n    length,\n    number_scenes,\n    quantum,\n    status,\n    width;\n\n  ssize_t\n    count,\n    scene;\n\n  unsigned char\n    *data;\n\n  unsigned short\n    group,\n    element;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  image->depth=8UL;\n  image->endian=LSBEndian;\n  /*\n    Read DCM preamble.\n  */\n  (void) memset(&info,0,sizeof(info));\n  data=(unsigned char *) NULL;\n  graymap=(int *) NULL;\n  redmap=(int *) NULL;\n  greenmap=(int *) NULL;\n  bluemap=(int *) NULL;\n  stream_info=(DCMStreamInfo *) AcquireMagickMemory(sizeof(*stream_info));\n  if (stream_info == (DCMStreamInfo *) NULL)\n    ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n  (void) memset(stream_info,0,sizeof(*stream_info));\n  count=ReadBlob(image,128,(unsigned char *) magick);\n  if (count != 128)\n    ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n  count=ReadBlob(image,4,(unsigned char *) magick);\n  if ((count != 4) || (LocaleNCompare(magick,\"DICM\",4) != 0))\n    {\n      offset=SeekBlob(image,0L,SEEK_SET);\n      if (offset < 0)\n        ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  /*\n    Read DCM Medical image.\n  */\n  (void) CopyMagickString(photometric,\"MONOCHROME1 \",MagickPathExtent);\n  info.bits_allocated=8;\n  info.bytes_per_pixel=1;\n  info.depth=8;\n  info.mask=0xffff;\n  info.max_value=255UL;\n  info.samples_per_pixel=1;\n  info.signed_data=(~0UL);\n  info.rescale_slope=1.0;\n  data=(unsigned char *) NULL;\n  element=0;\n  explicit_vr[2]='\\0';\n  explicit_file=MagickFalse;\n  colors=0;\n  redmap=(int *) NULL;\n  greenmap=(int *) NULL;\n  bluemap=(int *) NULL;\n  graymap=(int *) NULL;\n  height=0;\n  number_scenes=1;\n  use_explicit=MagickFalse;\n  explicit_retry = MagickFalse;\n  width=0;\n  while (TellBlob(image) < (MagickOffsetType) GetBlobSize(image))\n  {\n    for (group=0; (group != 0x7FE0) || (element != 0x0010) ; )\n    {\n      /*\n        Read a group.\n      */\n      image->offset=(ssize_t) TellBlob(image);\n      group=ReadBlobLSBShort(image);\n      element=ReadBlobLSBShort(image);\n      if ((group == 0xfffc) && (element == 0xfffc))\n        break;\n      if ((group != 0x0002) && (image->endian == MSBEndian))\n        {\n          group=(unsigned short) ((group << 8) | ((group >> 8) & 0xFF));\n          element=(unsigned short) ((element << 8) | ((element >> 8) & 0xFF));\n        }\n      quantum=0;\n      /*\n        Find corresponding VR for this group and element.\n      */\n      for (i=0; dicom_info[i].group < 0xffff; i++)\n        if ((group == dicom_info[i].group) &&\n            (element == dicom_info[i].element))\n          break;\n      (void) CopyMagickString(implicit_vr,dicom_info[i].vr,MagickPathExtent);\n      count=ReadBlob(image,2,(unsigned char *) explicit_vr);\n      if (count != 2)\n        ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n      /*\n        Check for \"explicitness\", but meta-file headers always explicit.\n      */\n      if ((explicit_file == MagickFalse) && (group != 0x0002))\n        explicit_file=(isupper((unsigned char) *explicit_vr) != MagickFalse) &&\n          (isupper((unsigned char) *(explicit_vr+1)) != MagickFalse) ?\n          MagickTrue : MagickFalse;\n      use_explicit=((group == 0x0002) && (explicit_retry == MagickFalse)) ||\n        (explicit_file != MagickFalse) ? MagickTrue : MagickFalse;\n      if ((use_explicit != MagickFalse) && (strncmp(implicit_vr,\"xs\",2) == 0))\n        (void) CopyMagickString(implicit_vr,explicit_vr,MagickPathExtent);\n      if ((use_explicit == MagickFalse) || (strncmp(implicit_vr,\"!!\",2) == 0))\n        {\n          offset=SeekBlob(image,(MagickOffsetType) -2,SEEK_CUR);\n          if (offset < 0)\n            ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n          quantum=4;\n        }\n      else\n        {\n          /*\n            Assume explicit type.\n          */\n          quantum=2;\n          if ((strncmp(explicit_vr,\"OB\",2) == 0) ||\n              (strncmp(explicit_vr,\"UN\",2) == 0) ||\n              (strncmp(explicit_vr,\"OW\",2) == 0) ||\n              (strncmp(explicit_vr,\"SQ\",2) == 0))\n            {\n              (void) ReadBlobLSBShort(image);\n              quantum=4;\n            }\n        }\n      datum=0;\n      if (quantum == 4)\n        {\n          if (group == 0x0002)\n            datum=ReadBlobLSBSignedLong(image);\n          else\n            datum=ReadBlobSignedLong(image);\n        }\n      else\n        if (quantum == 2)\n          {\n            if (group == 0x0002)\n              datum=ReadBlobLSBSignedShort(image);\n            else\n              datum=ReadBlobSignedShort(image);\n          }\n      quantum=0;\n      length=1;\n      if (datum != 0)\n        {\n          if ((strncmp(implicit_vr,\"OW\",2) == 0) ||\n               (strncmp(implicit_vr,\"SS\",2) == 0) ||\n               (strncmp(implicit_vr,\"US\",2) == 0))\n             quantum=2;\n          else \n             if ((strncmp(implicit_vr,\"FL\",2) == 0) ||\n                 (strncmp(implicit_vr,\"OF\",2) == 0) ||\n                 (strncmp(implicit_vr,\"SL\",2) == 0) ||\n                 (strncmp(implicit_vr,\"UL\",2) == 0))\n               quantum=4;\n            else \n               if (strncmp(implicit_vr,\"FD\",2) == 0)\n                 quantum=8;\n               else\n                quantum=1;\n          if (datum != ~0)\n            length=(size_t) datum/quantum;\n          else\n            {\n              /*\n                Sequence and item of undefined length.\n              */\n              quantum=0;\n              length=0;\n            }\n        }\n      if (image_info->verbose != MagickFalse)\n        {\n          /*\n            Display Dicom info.\n          */\n          if (use_explicit == MagickFalse)\n            explicit_vr[0]='\\0';\n          for (i=0; dicom_info[i].description != (char *) NULL; i++)\n            if ((group == dicom_info[i].group) &&\n                (element == dicom_info[i].element))\n              break;\n          (void) FormatLocaleFile(stdout,\"0x%04lX %4ld %s-%s (0x%04lx,0x%04lx)\",\n            (unsigned long) image->offset,(long) length,implicit_vr,explicit_vr,\n            (unsigned long) group,(unsigned long) element);\n          if (dicom_info[i].description != (char *) NULL)\n            (void) FormatLocaleFile(stdout,\" %s\",dicom_info[i].description);\n          (void) FormatLocaleFile(stdout,\": \");\n        }\n      if ((group == 0x7FE0) && (element == 0x0010))\n        {\n          if (image_info->verbose != MagickFalse)\n            (void) FormatLocaleFile(stdout,\"\\n\");\n          break;\n        }\n      /*\n        Allocate space and read an array.\n      */\n      data=(unsigned char *) NULL;\n      if ((length == 1) && (quantum == 1))\n        datum=ReadBlobByte(image);\n      else\n        if ((length == 1) && (quantum == 2))\n          {\n            if (group == 0x0002)\n              datum=ReadBlobLSBSignedShort(image);\n            else\n              datum=ReadBlobSignedShort(image);\n          }\n        else\n          if ((length == 1) && (quantum == 4))\n            {\n              if (group == 0x0002)\n                datum=ReadBlobLSBSignedLong(image);\n              else\n                datum=ReadBlobSignedLong(image);\n            }\n          else\n            if ((quantum != 0) && (length != 0))\n              {\n                if (length > (size_t) GetBlobSize(image))\n                  ThrowDCMException(CorruptImageError,\n                    \"InsufficientImageDataInFile\");\n                if (~length >= 1)\n                  data=(unsigned char *) AcquireQuantumMemory(length+1,quantum*\n                    sizeof(*data));\n                if (data == (unsigned char *) NULL)\n                  ThrowDCMException(ResourceLimitError,\n                    \"MemoryAllocationFailed\");\n                count=ReadBlob(image,(size_t) quantum*length,data);\n                if (count != (ssize_t) (quantum*length))\n                  {\n                    if (image_info->verbose != MagickFalse)\n                      (void) FormatLocaleFile(stdout,\"count=%d quantum=%d \"\n                        \"length=%d group=%d\\n\",(int) count,(int) quantum,(int)\n                        length,(int) group);\n                     ThrowDCMException(CorruptImageError,\n                       \"InsufficientImageDataInFile\");\n                  }\n                data[length*quantum]='\\0';\n              }\n      if ((((unsigned int) group << 16) | element) == 0xFFFEE0DD)\n        {\n          if (data != (unsigned char *) NULL)\n            data=(unsigned char *) RelinquishMagickMemory(data);\n          continue;\n        }\n      switch (group)\n      {\n        case 0x0002:\n        {\n          switch (element)\n          {\n            case 0x0010:\n            {\n              char\n                transfer_syntax[MagickPathExtent];\n\n              /*\n                Transfer Syntax.\n              */\n              if ((datum == 0) && (explicit_retry == MagickFalse))\n                {\n                  explicit_retry=MagickTrue;\n                  (void) SeekBlob(image,(MagickOffsetType) 0,SEEK_SET);\n                  group=0;\n                  element=0;\n                  if (image_info->verbose != MagickFalse)\n                    (void) FormatLocaleFile(stdout,\n                      \"Corrupted image - trying explicit format\\n\");\n                  break;\n                }\n              *transfer_syntax='\\0';\n              if (data != (unsigned char *) NULL)\n                (void) CopyMagickString(transfer_syntax,(char *) data,\n                  MagickPathExtent);\n              if (image_info->verbose != MagickFalse)\n                (void) FormatLocaleFile(stdout,\"transfer_syntax=%s\\n\",\n                  (const char *) transfer_syntax);\n              if (strncmp(transfer_syntax,\"1.2.840.10008.1.2\",17) == 0)\n                {\n                  int\n                    subtype,\n                    type;\n\n                  type=1;\n                  subtype=0;\n                  if (strlen(transfer_syntax) > 17)\n                    {\n                      count=(ssize_t) sscanf(transfer_syntax+17,\".%d.%d\",&type,\n                        &subtype);\n                      if (count < 1)\n                        ThrowDCMException(CorruptImageError,\n                          \"ImproperImageHeader\");\n                    }\n                  switch (type)\n                  {\n                    case 1:\n                    {\n                      image->endian=LSBEndian;\n                      break;\n                    }\n                    case 2:\n                    {\n                      image->endian=MSBEndian;\n                      break;\n                    }\n                    case 4:\n                    {\n                      if ((subtype >= 80) && (subtype <= 81))\n                        image->compression=JPEGCompression;\n                      else\n                        if ((subtype >= 90) && (subtype <= 93))\n                          image->compression=JPEG2000Compression;\n                        else\n                          image->compression=JPEGCompression;\n                      break;\n                    }\n                    case 5:\n                    {\n                      image->compression=RLECompression;\n                      break;\n                    }\n                  }\n                }\n              break;\n            }\n            default:\n              break;\n          }\n          break;\n        }\n        case 0x0028:\n        {\n          switch (element)\n          {\n            case 0x0002:\n            {\n              /*\n                Samples per pixel.\n              */\n              info.samples_per_pixel=(size_t) datum;\n              if ((info.samples_per_pixel == 0) || (info.samples_per_pixel > 4))\n                ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n              break;\n            }\n            case 0x0004:\n            {\n              /*\n                Photometric interpretation.\n              */\n              if (data == (unsigned char *) NULL)\n                break;\n              for (i=0; i < (ssize_t) MagickMin(length,MagickPathExtent-1); i++)\n                photometric[i]=(char) data[i];\n              photometric[i]='\\0';\n              info.polarity=LocaleCompare(photometric,\"MONOCHROME1 \") == 0 ?\n                MagickTrue : MagickFalse;\n              break;\n            }\n            case 0x0006:\n            {\n              /*\n                Planar configuration.\n              */\n              if (datum == 1)\n                image->interlace=PlaneInterlace;\n              break;\n            }\n            case 0x0008:\n            {\n              /*\n                Number of frames.\n              */\n              if (data == (unsigned char *) NULL)\n                break;\n              number_scenes=StringToUnsignedLong((char *) data);\n              break;\n            }\n            case 0x0010:\n            {\n              /*\n                Image rows.\n              */\n              height=(size_t) datum;\n              break;\n            }\n            case 0x0011:\n            {\n              /*\n                Image columns.\n              */\n              width=(size_t) datum;\n              break;\n            }\n            case 0x0100:\n            {\n              /*\n                Bits allocated.\n              */\n              info.bits_allocated=(size_t) datum;\n              info.bytes_per_pixel=1;\n              if (datum > 8)\n                info.bytes_per_pixel=2;\n              info.depth=info.bits_allocated;\n              if ((info.depth == 0) || (info.depth > 32))\n                ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n              info.max_value=(1UL << info.bits_allocated)-1;\n              image->depth=info.depth;\n              break;\n            }\n            case 0x0101:\n            {\n              /*\n                Bits stored.\n              */\n              info.significant_bits=(size_t) datum;\n              info.bytes_per_pixel=1;\n              if (info.significant_bits > 8)\n                info.bytes_per_pixel=2;\n              info.depth=info.significant_bits;\n              if ((info.depth == 0) || (info.depth > 16))\n                ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n              info.max_value=(1UL << info.significant_bits)-1;\n              info.mask=(size_t) GetQuantumRange(info.significant_bits);\n              image->depth=info.depth;\n              break;\n            }\n            case 0x0102:\n            {\n              /*\n                High bit.\n              */\n              break;\n            }\n            case 0x0103:\n            {\n              /*\n                Pixel representation.\n              */\n              info.signed_data=(size_t) datum;\n              break;\n            }\n            case 0x1050:\n            {\n              /*\n                Visible pixel range: center.\n              */\n              if (data != (unsigned char *) NULL)\n                info.window_center=StringToDouble((char *) data,(char **) NULL);\n              break;\n            }\n            case 0x1051:\n            {\n              /*\n                Visible pixel range: width.\n              */\n              if (data != (unsigned char *) NULL)\n                info.window_width=StringToDouble((char *) data,(char **) NULL);\n              break;\n            }\n            case 0x1052:\n            {\n              /*\n                Rescale intercept\n              */\n              if (data != (unsigned char *) NULL)\n                info.rescale_intercept=StringToDouble((char *) data,\n                  (char **) NULL);\n              break;\n            }\n            case 0x1053:\n            {\n              /*\n                Rescale slope\n              */\n              if (data != (unsigned char *) NULL)\n                info.rescale_slope=StringToDouble((char *) data,(char **) NULL);\n              break;\n            }\n            case 0x1200:\n            case 0x3006:\n            {\n              /*\n                Populate graymap.\n              */\n              if (data == (unsigned char *) NULL)\n                break;\n              colors=(size_t) (length/info.bytes_per_pixel);\n              datum=(int) colors;\n              if (graymap != (int *) NULL)\n                graymap=(int *) RelinquishMagickMemory(graymap);\n              graymap=(int *) AcquireQuantumMemory(MagickMax(colors,65536),\n                sizeof(*graymap));\n              if (graymap == (int *) NULL)\n                ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n              (void) memset(graymap,0,MagickMax(colors,65536)*\n                sizeof(*graymap));\n              for (i=0; i < (ssize_t) colors; i++)\n                if (info.bytes_per_pixel == 1)\n                  graymap[i]=(int) data[i];\n                else\n                  graymap[i]=(int) ((short *) data)[i];\n              break;\n            }\n            case 0x1201:\n            {\n              unsigned short\n                index;\n\n              /*\n                Populate redmap.\n              */\n              if (data == (unsigned char *) NULL)\n                break;\n              colors=(size_t) (length/2);\n              datum=(int) colors;\n              if (redmap != (int *) NULL)\n                redmap=(int *) RelinquishMagickMemory(redmap);\n              redmap=(int *) AcquireQuantumMemory(MagickMax(colors,65536),\n                sizeof(*redmap));\n              if (redmap == (int *) NULL)\n                ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n              (void) memset(redmap,0,MagickMax(colors,65536)*\n                sizeof(*redmap));\n              p=data;\n              for (i=0; i < (ssize_t) colors; i++)\n              {\n                if (image->endian == MSBEndian)\n                  index=(unsigned short) ((*p << 8) | *(p+1));\n                else\n                  index=(unsigned short) (*p | (*(p+1) << 8));\n                redmap[i]=(int) index;\n                p+=2;\n              }\n              break;\n            }\n            case 0x1202:\n            {\n              unsigned short\n                index;\n\n              /*\n                Populate greenmap.\n              */\n              if (data == (unsigned char *) NULL)\n                break;\n              colors=(size_t) (length/2);\n              datum=(int) colors;\n              if (greenmap != (int *) NULL)\n                greenmap=(int *) RelinquishMagickMemory(greenmap);\n              greenmap=(int *) AcquireQuantumMemory(MagickMax(colors,65536),\n                sizeof(*greenmap));\n              if (greenmap == (int *) NULL)\n                ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n              (void) memset(greenmap,0,MagickMax(colors,65536)*\n                sizeof(*greenmap));\n              p=data;\n              for (i=0; i < (ssize_t) colors; i++)\n              {\n                if (image->endian == MSBEndian)\n                  index=(unsigned short) ((*p << 8) | *(p+1));\n                else\n                  index=(unsigned short) (*p | (*(p+1) << 8));\n                greenmap[i]=(int) index;\n                p+=2;\n              }\n              break;\n            }\n            case 0x1203:\n            {\n              unsigned short\n                index;\n\n              /*\n                Populate bluemap.\n              */\n              if (data == (unsigned char *) NULL)\n                break;\n              colors=(size_t) (length/2);\n              datum=(int) colors;\n              if (bluemap != (int *) NULL)\n                bluemap=(int *) RelinquishMagickMemory(bluemap);\n              bluemap=(int *) AcquireQuantumMemory(MagickMax(colors,65536),\n                sizeof(*bluemap));\n              if (bluemap == (int *) NULL)\n                ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n              (void) memset(bluemap,0,MagickMax(colors,65536)*\n                sizeof(*bluemap));\n              p=data;\n              for (i=0; i < (ssize_t) colors; i++)\n              {\n                if (image->endian == MSBEndian)\n                  index=(unsigned short) ((*p << 8) | *(p+1));\n                else\n                  index=(unsigned short) (*p | (*(p+1) << 8));\n                bluemap[i]=(int) index;\n                p+=2;\n              }\n              break;\n            }\n            default:\n              break;\n          }\n          break;\n        }\n        case 0x2050:\n        {\n          switch (element)\n          {\n            case 0x0020:\n            {\n              if ((data != (unsigned char *) NULL) &&\n                  (strncmp((char *) data,\"INVERSE\",7) == 0))\n                info.polarity=MagickTrue;\n              break;\n            }\n            default:\n              break;\n          }\n          break;\n        }\n        default:\n          break;\n      }\n      if (data != (unsigned char *) NULL)\n        {\n          char\n            *attribute;\n\n          for (i=0; dicom_info[i].description != (char *) NULL; i++)\n            if ((group == dicom_info[i].group) &&\n                (element == dicom_info[i].element))\n              break;\n          if (dicom_info[i].description != (char *) NULL)\n            {\n              attribute=AcquireString(\"dcm:\");\n              (void) ConcatenateString(&attribute,dicom_info[i].description);\n              for (i=0; i < (ssize_t) MagickMax(length,4); i++)\n                if (isprint((int) data[i]) == MagickFalse)\n                  break;\n              if ((i == (ssize_t) length) || (length > 4))\n                {\n                  (void) SubstituteString(&attribute,\" \",\"\");\n                  (void) SetImageProperty(image,attribute,(char *) data,\n                    exception);\n                }\n              attribute=DestroyString(attribute);\n            }\n        }\n      if (image_info->verbose != MagickFalse)\n        {\n          if (data == (unsigned char *) NULL)\n            (void) FormatLocaleFile(stdout,\"%d\\n\",datum);\n          else\n            {\n              /*\n                Display group data.\n              */\n              for (i=0; i < (ssize_t) MagickMax(length,4); i++)\n                if (isprint((int) data[i]) == MagickFalse)\n                  break;\n              if ((i != (ssize_t) length) && (length <= 4))\n                {\n                  ssize_t\n                    j;\n\n                  datum=0;\n                  for (j=(ssize_t) length-1; j >= 0; j--)\n                    datum=(256*datum+data[j]);\n                  (void) FormatLocaleFile(stdout,\"%d\",datum);\n                }\n              else\n                for (i=0; i < (ssize_t) length; i++)\n                  if (isprint((int) data[i]) != MagickFalse)\n                    (void) FormatLocaleFile(stdout,\"%c\",data[i]);\n                  else\n                    (void) FormatLocaleFile(stdout,\"%c\",'.');\n              (void) FormatLocaleFile(stdout,\"\\n\");\n            }\n        }\n      if (data != (unsigned char *) NULL)\n        data=(unsigned char *) RelinquishMagickMemory(data);\n      if (EOFBlob(image) != MagickFalse)\n        {\n          ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n            image->filename);\n          break;\n        }\n    }\n    if ((group == 0xfffc) && (element == 0xfffc))\n      {\n        Image\n          *last;\n\n        last=RemoveLastImageFromList(&image);\n        if (last != (Image *) NULL)\n          last=DestroyImage(last);\n        break;\n      }\n    if ((width == 0) || (height == 0))\n      ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n    image->columns=(size_t) width;\n    image->rows=(size_t) height;\n    if (info.signed_data == 0xffff)\n      info.signed_data=(size_t) (info.significant_bits == 16 ? 1 : 0);\n    if ((image->compression == JPEGCompression) ||\n        (image->compression == JPEG2000Compression))\n      {\n        Image\n          *images;\n\n        ImageInfo\n          *read_info;\n\n        int\n          c;\n\n        /*\n          Read offset table.\n        */\n        for (i=0; i < (ssize_t) stream_info->remaining; i++)\n          if (ReadBlobByte(image) == EOF)\n            break;\n        (void) (((ssize_t) ReadBlobLSBShort(image) << 16) |\n          ReadBlobLSBShort(image));\n        length=(size_t) ReadBlobLSBLong(image);\n        if (length > (size_t) GetBlobSize(image))\n          ThrowDCMException(CorruptImageError,\"InsufficientImageDataInFile\");\n        stream_info->offset_count=length >> 2;\n        if (stream_info->offset_count != 0)\n          {\n            if (stream_info->offsets != (ssize_t *) NULL)\n              stream_info->offsets=(ssize_t *) RelinquishMagickMemory(\n                stream_info->offsets);\n            stream_info->offsets=(ssize_t *) AcquireQuantumMemory(\n              stream_info->offset_count,sizeof(*stream_info->offsets));\n            if (stream_info->offsets == (ssize_t *) NULL)\n              ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n            for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n              stream_info->offsets[i]=(ssize_t) ReadBlobLSBSignedLong(image);\n            offset=TellBlob(image);\n            for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n              stream_info->offsets[i]+=offset;\n          }\n        /*\n          Handle non-native image formats.\n        */\n        read_info=CloneImageInfo(image_info);\n        SetImageInfoBlob(read_info,(void *) NULL,0);\n        images=NewImageList();\n        for (scene=0; scene < (ssize_t) number_scenes; scene++)\n        {\n          char\n            filename[MagickPathExtent];\n\n          const char\n            *property;\n\n          FILE\n            *file;\n\n          Image\n            *jpeg_image;\n\n          int\n            unique_file;\n\n          unsigned int\n            tag;\n\n          tag=((unsigned int) ReadBlobLSBShort(image) << 16) |\n            ReadBlobLSBShort(image);\n          length=(size_t) ReadBlobLSBLong(image);\n          if (tag == 0xFFFEE0DD)\n            break; /* sequence delimiter tag */\n          if (tag != 0xFFFEE000)\n            {\n              read_info=DestroyImageInfo(read_info);\n              ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n            }\n          file=(FILE *) NULL;\n          unique_file=AcquireUniqueFileResource(filename);\n          if (unique_file != -1)\n            file=fdopen(unique_file,\"wb\");\n          if (file == (FILE *) NULL)\n            {\n              (void) RelinquishUniqueFileResource(filename);\n              ThrowFileException(exception,FileOpenError,\n                \"UnableToCreateTemporaryFile\",filename);\n              break;\n            }\n          for (c=EOF; length != 0; length--)\n          {\n            c=ReadBlobByte(image);\n            if (c == EOF)\n              {\n                ThrowFileException(exception,CorruptImageError,\n                   \"UnexpectedEndOfFile\",image->filename);\n                 break;\n               }\n            (void) fputc(c,file);\n           }\n           (void) fclose(file);\n           if (c == EOF)\n            break;\n          (void) FormatLocaleString(read_info->filename,MagickPathExtent,\n            \"jpeg:%s\",filename);\n          if (image->compression == JPEG2000Compression)\n            (void) FormatLocaleString(read_info->filename,MagickPathExtent,\n              \"j2k:%s\",filename);\n          jpeg_image=ReadImage(read_info,exception);\n          if (jpeg_image != (Image *) NULL)\n            {\n              ResetImagePropertyIterator(image);\n              property=GetNextImageProperty(image);\n              while (property != (const char *) NULL)\n              {\n                (void) SetImageProperty(jpeg_image,property,\n                  GetImageProperty(image,property,exception),exception);\n                property=GetNextImageProperty(image);\n              }\n              AppendImageToList(&images,jpeg_image);\n            }\n          (void) RelinquishUniqueFileResource(filename);\n        }\n        read_info=DestroyImageInfo(read_info);\n        if (stream_info->offsets != (ssize_t *) NULL)\n          stream_info->offsets=(ssize_t *)\n            RelinquishMagickMemory(stream_info->offsets);\n        stream_info=(DCMStreamInfo *) RelinquishMagickMemory(stream_info);\n        if (info.scale != (Quantum *) NULL)\n          info.scale=(Quantum *) RelinquishMagickMemory(info.scale);\n        if (graymap != (int *) NULL)\n          graymap=(int *) RelinquishMagickMemory(graymap);\n        if (bluemap != (int *) NULL)\n          bluemap=(int *) RelinquishMagickMemory(bluemap);\n        if (greenmap != (int *) NULL)\n          greenmap=(int *) RelinquishMagickMemory(greenmap);\n        if (redmap != (int *) NULL)\n          redmap=(int *) RelinquishMagickMemory(redmap);\n        image=DestroyImageList(image);\n        return(GetFirstImageInList(images));\n      }\n    if (info.depth != (1UL*MAGICKCORE_QUANTUM_DEPTH))\n      {\n        QuantumAny\n          range;\n\n        /*\n          Compute pixel scaling table.\n        */\n         length=(size_t) (GetQuantumRange(info.depth)+1);\n         if (length > (size_t) GetBlobSize(image))\n           ThrowDCMException(CorruptImageError,\"InsufficientImageDataInFile\");\n        if (info.scale != (Quantum *) NULL) \n           info.scale=(Quantum *) RelinquishMagickMemory(info.scale);\n         info.scale=(Quantum *) AcquireQuantumMemory(MagickMax(length,256),\n           sizeof(*info.scale));\n        if (info.scale == (Quantum *) NULL)\n          ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) memset(info.scale,0,MagickMax(length,256)*\n          sizeof(*info.scale));\n        range=GetQuantumRange(info.depth);\n        for (i=0; i <= (ssize_t) GetQuantumRange(info.depth); i++)\n          info.scale[i]=ScaleAnyToQuantum((size_t) i,range);\n      }\n    if (image->compression == RLECompression)\n      {\n        unsigned int\n          tag;\n\n        /*\n          Read RLE offset table.\n        */\n        for (i=0; i < (ssize_t) stream_info->remaining; i++)\n        {\n          int\n            c;\n\n          c=ReadBlobByte(image);\n          if (c == EOF)\n            break;\n        }\n        tag=((unsigned int) ReadBlobLSBShort(image) << 16) |\n          ReadBlobLSBShort(image);\n        (void) tag;\n        length=(size_t) ReadBlobLSBLong(image);\n        if (length > (size_t) GetBlobSize(image))\n          ThrowDCMException(CorruptImageError,\"InsufficientImageDataInFile\");\n        stream_info->offset_count=length >> 2;\n        if (stream_info->offset_count != 0)\n          {\n            stream_info->offsets=(ssize_t *) AcquireQuantumMemory(\n              stream_info->offset_count,sizeof(*stream_info->offsets));\n            if (stream_info->offsets == (ssize_t *) NULL)\n              ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n            for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n            {\n              stream_info->offsets[i]=(ssize_t) ReadBlobLSBSignedLong(image);\n              if (EOFBlob(image) != MagickFalse)\n                break;\n            }\n            offset=TellBlob(image)+8;\n            for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n              stream_info->offsets[i]+=offset;\n          }\n      }\n    for (scene=0; scene < (ssize_t) number_scenes; scene++)\n    {\n      if (image_info->ping != MagickFalse)\n        break;\n      image->columns=(size_t) width;\n      image->rows=(size_t) height;\n      image->depth=info.depth;\n      status=SetImageExtent(image,image->columns,image->rows,exception);\n      if (status == MagickFalse)\n        break;\n      image->colorspace=RGBColorspace;\n      (void) SetImageBackgroundColor(image,exception);\n      if ((image->colormap == (PixelInfo *) NULL) &&\n          (info.samples_per_pixel == 1))\n        {\n          int\n            index;\n\n          size_t\n            one;\n\n          one=1;\n          if (colors == 0)\n            colors=one << info.depth;\n          if (AcquireImageColormap(image,colors,exception) == MagickFalse)\n            ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n          if (redmap != (int *) NULL)\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              index=redmap[i];\n              if ((info.scale != (Quantum *) NULL) && (index >= 0) &&\n                  (index <= (int) info.max_value))\n                index=(int) info.scale[index];\n              image->colormap[i].red=(MagickRealType) index;\n            }\n          if (greenmap != (int *) NULL)\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              index=greenmap[i];\n              if ((info.scale != (Quantum *) NULL) && (index >= 0) &&\n                  (index <= (int) info.max_value))\n                index=(int) info.scale[index];\n              image->colormap[i].green=(MagickRealType) index;\n            }\n          if (bluemap != (int *) NULL)\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              index=bluemap[i];\n              if ((info.scale != (Quantum *) NULL) && (index >= 0) &&\n                  (index <= (int) info.max_value))\n                index=(int) info.scale[index];\n              image->colormap[i].blue=(MagickRealType) index;\n            }\n          if (graymap != (int *) NULL)\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              index=graymap[i];\n              if ((info.scale != (Quantum *) NULL) && (index >= 0) &&\n                  (index <= (int) info.max_value))\n                index=(int) info.scale[index];\n              image->colormap[i].red=(MagickRealType) index;\n              image->colormap[i].green=(MagickRealType) index;\n              image->colormap[i].blue=(MagickRealType) index;\n            }\n        }\n      if (image->compression == RLECompression)\n        {\n          unsigned int\n            tag;\n\n          /*\n            Read RLE segment table.\n          */\n          for (i=0; i < (ssize_t) stream_info->remaining; i++)\n          {\n            int\n              c;\n\n            c=ReadBlobByte(image);\n            if (c == EOF)\n              break;\n          }\n          tag=((unsigned int) ReadBlobLSBShort(image) << 16) |\n            ReadBlobLSBShort(image);\n          stream_info->remaining=(size_t) ReadBlobLSBLong(image);\n          if ((tag != 0xFFFEE000) || (stream_info->remaining <= 64) ||\n              (EOFBlob(image) != MagickFalse))\n            {\n              if (stream_info->offsets != (ssize_t *) NULL)\n                stream_info->offsets=(ssize_t *)\n                  RelinquishMagickMemory(stream_info->offsets);\n              ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n            }\n          stream_info->count=0;\n          stream_info->segment_count=ReadBlobLSBLong(image);\n          for (i=0; i < 15; i++)\n            stream_info->segments[i]=(ssize_t) ReadBlobLSBSignedLong(image);\n          stream_info->remaining-=64;\n          if (stream_info->segment_count > 1)\n            {\n              info.bytes_per_pixel=1;\n              info.depth=8;\n              if (stream_info->offset_count > 0)\n                (void) SeekBlob(image,(MagickOffsetType)\n                  stream_info->offsets[0]+stream_info->segments[0],SEEK_SET);\n            }\n        }\n      if ((info.samples_per_pixel > 1) && (image->interlace == PlaneInterlace))\n        {\n          register ssize_t\n            x;\n\n          register Quantum\n            *q;\n\n          ssize_t\n            y;\n\n          /*\n            Convert Planar RGB DCM Medical image to pixel packets.\n          */\n          for (i=0; i < (ssize_t) info.samples_per_pixel; i++)\n          {\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                switch ((int) i)\n                {\n                  case 0:\n                  {\n                    SetPixelRed(image,ScaleCharToQuantum((unsigned char)\n                      ReadDCMByte(stream_info,image)),q);\n                    break;\n                  }\n                  case 1:\n                  {\n                    SetPixelGreen(image,ScaleCharToQuantum((unsigned char)\n                      ReadDCMByte(stream_info,image)),q);\n                    break;\n                  }\n                  case 2:\n                  {\n                    SetPixelBlue(image,ScaleCharToQuantum((unsigned char)\n                      ReadDCMByte(stream_info,image)),q);\n                    break;\n                  }\n                  case 3:\n                  {\n                    SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)\n                      ReadDCMByte(stream_info,image)),q);\n                    break;\n                  }\n                  default:\n                    break;\n                }\n                q+=GetPixelChannels(image);\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n          }\n        }\n      else\n        {\n          const char\n            *option;\n\n          /*\n            Convert DCM Medical image to pixel packets.\n          */\n          option=GetImageOption(image_info,\"dcm:display-range\");\n          if (option != (const char *) NULL)\n            {\n              if (LocaleCompare(option,\"reset\") == 0)\n                info.window_width=0;\n            }\n          option=GetImageOption(image_info,\"dcm:window\");\n          if (option != (char *) NULL)\n            {\n              GeometryInfo\n                geometry_info;\n\n              MagickStatusType\n                flags;\n\n              flags=ParseGeometry(option,&geometry_info);\n              if (flags & RhoValue)\n                info.window_center=geometry_info.rho;\n              if (flags & SigmaValue)\n                info.window_width=geometry_info.sigma;\n              info.rescale=MagickTrue;\n            }\n          option=GetImageOption(image_info,\"dcm:rescale\");\n          if (option != (char *) NULL)\n            info.rescale=IsStringTrue(option);\n          if ((info.window_center != 0) && (info.window_width == 0))\n            info.window_width=info.window_center;\n          status=ReadDCMPixels(image,&info,stream_info,MagickTrue,exception);\n          if ((status != MagickFalse) && (stream_info->segment_count > 1))\n            {\n              if (stream_info->offset_count > 0)\n                (void) SeekBlob(image,(MagickOffsetType)\n                  stream_info->offsets[0]+stream_info->segments[1],SEEK_SET);\n              (void) ReadDCMPixels(image,&info,stream_info,MagickFalse,\n                exception);\n            }\n        }\n      if (SetImageGray(image,exception) != MagickFalse)\n        (void) SetImageColorspace(image,GRAYColorspace,exception);\n      if (EOFBlob(image) != MagickFalse)\n        {\n          ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n            image->filename);\n          break;\n        }\n      /*\n        Proceed to next image.\n      */\n      if (image_info->number_scenes != 0)\n        if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n          break;\n      if (scene < (ssize_t) (number_scenes-1))\n        {\n          /*\n            Allocate next image structure.\n          */\n          AcquireNextImage(image_info,image,exception);\n          if (GetNextImageInList(image) == (Image *) NULL)\n            {\n              status=MagickFalse;\n              break;\n            }\n          image=SyncNextImageInList(image);\n          status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n            GetBlobSize(image));\n          if (status == MagickFalse)\n            break;\n        }\n    }\n    if (TellBlob(image) < (MagickOffsetType) GetBlobSize(image))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            status=MagickFalse;\n            break;\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n     }\n  }\n  /*\n    Free resources.\n  */\n  if (stream_info->offsets != (ssize_t *) NULL)\n    stream_info->offsets=(ssize_t *)\n      RelinquishMagickMemory(stream_info->offsets);\n  stream_info=(DCMStreamInfo *) RelinquishMagickMemory(stream_info);\n  if (info.scale != (Quantum *) NULL)\n    info.scale=(Quantum *) RelinquishMagickMemory(info.scale);\n  if (graymap != (int *) NULL)\n    graymap=(int *) RelinquishMagickMemory(graymap);\n  if (bluemap != (int *) NULL)\n    bluemap=(int *) RelinquishMagickMemory(bluemap);\n  if (greenmap != (int *) NULL)\n    greenmap=(int *) RelinquishMagickMemory(greenmap);\n  if (redmap != (int *) NULL)\n    redmap=(int *) RelinquishMagickMemory(redmap);\n  (void) CloseBlob(image);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  return(GetFirstImageInList(image));\n}\n",
    "code_after_change": "static Image *ReadDCMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define ThrowDCMException(exception,message) \\\n{ \\\n  if (info.scale != (Quantum *) NULL) \\\n    info.scale=(Quantum *) RelinquishMagickMemory(info.scale); \\\n  if (data != (unsigned char *) NULL) \\\n    data=(unsigned char *) RelinquishMagickMemory(data); \\\n  if (graymap != (int *) NULL) \\\n    graymap=(int *) RelinquishMagickMemory(graymap); \\\n  if (bluemap != (int *) NULL) \\\n    bluemap=(int *) RelinquishMagickMemory(bluemap); \\\n  if (greenmap != (int *) NULL) \\\n    greenmap=(int *) RelinquishMagickMemory(greenmap); \\\n  if (redmap != (int *) NULL) \\\n    redmap=(int *) RelinquishMagickMemory(redmap); \\\n  if (stream_info->offsets != (ssize_t *) NULL) \\\n    stream_info->offsets=(ssize_t *) RelinquishMagickMemory( \\\n      stream_info->offsets); \\\n  if (stream_info != (DCMStreamInfo *) NULL) \\\n    stream_info=(DCMStreamInfo *) RelinquishMagickMemory(stream_info); \\\n  ThrowReaderException((exception),(message)); \\\n}\n\n  char\n    explicit_vr[MagickPathExtent],\n    implicit_vr[MagickPathExtent],\n    magick[MagickPathExtent],\n    photometric[MagickPathExtent];\n\n  DCMInfo\n    info;\n\n  DCMStreamInfo\n    *stream_info;\n\n  Image\n    *image;\n\n  int\n    *bluemap,\n    datum,\n    *greenmap,\n    *graymap,\n    *redmap;\n\n  MagickBooleanType\n    explicit_file,\n    explicit_retry,\n    use_explicit;\n\n  MagickOffsetType\n    offset;\n\n  register unsigned char\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    colors,\n    height,\n    length,\n    number_scenes,\n    quantum,\n    status,\n    width;\n\n  ssize_t\n    count,\n    scene;\n\n  unsigned char\n    *data;\n\n  unsigned short\n    group,\n    element;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  image->depth=8UL;\n  image->endian=LSBEndian;\n  /*\n    Read DCM preamble.\n  */\n  (void) memset(&info,0,sizeof(info));\n  data=(unsigned char *) NULL;\n  graymap=(int *) NULL;\n  redmap=(int *) NULL;\n  greenmap=(int *) NULL;\n  bluemap=(int *) NULL;\n  stream_info=(DCMStreamInfo *) AcquireMagickMemory(sizeof(*stream_info));\n  if (stream_info == (DCMStreamInfo *) NULL)\n    ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n  (void) memset(stream_info,0,sizeof(*stream_info));\n  count=ReadBlob(image,128,(unsigned char *) magick);\n  if (count != 128)\n    ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n  count=ReadBlob(image,4,(unsigned char *) magick);\n  if ((count != 4) || (LocaleNCompare(magick,\"DICM\",4) != 0))\n    {\n      offset=SeekBlob(image,0L,SEEK_SET);\n      if (offset < 0)\n        ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  /*\n    Read DCM Medical image.\n  */\n  (void) CopyMagickString(photometric,\"MONOCHROME1 \",MagickPathExtent);\n  info.bits_allocated=8;\n  info.bytes_per_pixel=1;\n  info.depth=8;\n  info.mask=0xffff;\n  info.max_value=255UL;\n  info.samples_per_pixel=1;\n  info.signed_data=(~0UL);\n  info.rescale_slope=1.0;\n  data=(unsigned char *) NULL;\n  element=0;\n  explicit_vr[2]='\\0';\n  explicit_file=MagickFalse;\n  colors=0;\n  redmap=(int *) NULL;\n  greenmap=(int *) NULL;\n  bluemap=(int *) NULL;\n  graymap=(int *) NULL;\n  height=0;\n  number_scenes=1;\n  use_explicit=MagickFalse;\n  explicit_retry = MagickFalse;\n  width=0;\n  while (TellBlob(image) < (MagickOffsetType) GetBlobSize(image))\n  {\n    for (group=0; (group != 0x7FE0) || (element != 0x0010) ; )\n    {\n      /*\n        Read a group.\n      */\n      image->offset=(ssize_t) TellBlob(image);\n      group=ReadBlobLSBShort(image);\n      element=ReadBlobLSBShort(image);\n      if ((group == 0xfffc) && (element == 0xfffc))\n        break;\n      if ((group != 0x0002) && (image->endian == MSBEndian))\n        {\n          group=(unsigned short) ((group << 8) | ((group >> 8) & 0xFF));\n          element=(unsigned short) ((element << 8) | ((element >> 8) & 0xFF));\n        }\n      quantum=0;\n      /*\n        Find corresponding VR for this group and element.\n      */\n      for (i=0; dicom_info[i].group < 0xffff; i++)\n        if ((group == dicom_info[i].group) &&\n            (element == dicom_info[i].element))\n          break;\n      (void) CopyMagickString(implicit_vr,dicom_info[i].vr,MagickPathExtent);\n      count=ReadBlob(image,2,(unsigned char *) explicit_vr);\n      if (count != 2)\n        ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n      /*\n        Check for \"explicitness\", but meta-file headers always explicit.\n      */\n      if ((explicit_file == MagickFalse) && (group != 0x0002))\n        explicit_file=(isupper((unsigned char) *explicit_vr) != MagickFalse) &&\n          (isupper((unsigned char) *(explicit_vr+1)) != MagickFalse) ?\n          MagickTrue : MagickFalse;\n      use_explicit=((group == 0x0002) && (explicit_retry == MagickFalse)) ||\n        (explicit_file != MagickFalse) ? MagickTrue : MagickFalse;\n      if ((use_explicit != MagickFalse) && (strncmp(implicit_vr,\"xs\",2) == 0))\n        (void) CopyMagickString(implicit_vr,explicit_vr,MagickPathExtent);\n      if ((use_explicit == MagickFalse) || (strncmp(implicit_vr,\"!!\",2) == 0))\n        {\n          offset=SeekBlob(image,(MagickOffsetType) -2,SEEK_CUR);\n          if (offset < 0)\n            ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n          quantum=4;\n        }\n      else\n        {\n          /*\n            Assume explicit type.\n          */\n          quantum=2;\n          if ((strncmp(explicit_vr,\"OB\",2) == 0) ||\n              (strncmp(explicit_vr,\"UN\",2) == 0) ||\n              (strncmp(explicit_vr,\"OW\",2) == 0) ||\n              (strncmp(explicit_vr,\"SQ\",2) == 0))\n            {\n              (void) ReadBlobLSBShort(image);\n              quantum=4;\n            }\n        }\n      datum=0;\n      if (quantum == 4)\n        {\n          if (group == 0x0002)\n            datum=ReadBlobLSBSignedLong(image);\n          else\n            datum=ReadBlobSignedLong(image);\n        }\n      else\n        if (quantum == 2)\n          {\n            if (group == 0x0002)\n              datum=ReadBlobLSBSignedShort(image);\n            else\n              datum=ReadBlobSignedShort(image);\n          }\n      quantum=0;\n      length=1;\n      if (datum != 0)\n        {\n          if ((strncmp(implicit_vr,\"OW\",2) == 0) ||\n               (strncmp(implicit_vr,\"SS\",2) == 0) ||\n               (strncmp(implicit_vr,\"US\",2) == 0))\n             quantum=2;\n          else\n             if ((strncmp(implicit_vr,\"FL\",2) == 0) ||\n                 (strncmp(implicit_vr,\"OF\",2) == 0) ||\n                 (strncmp(implicit_vr,\"SL\",2) == 0) ||\n                 (strncmp(implicit_vr,\"UL\",2) == 0))\n               quantum=4;\n            else\n               if (strncmp(implicit_vr,\"FD\",2) == 0)\n                 quantum=8;\n               else\n                quantum=1;\n          if (datum != ~0)\n            length=(size_t) datum/quantum;\n          else\n            {\n              /*\n                Sequence and item of undefined length.\n              */\n              quantum=0;\n              length=0;\n            }\n        }\n      if (image_info->verbose != MagickFalse)\n        {\n          /*\n            Display Dicom info.\n          */\n          if (use_explicit == MagickFalse)\n            explicit_vr[0]='\\0';\n          for (i=0; dicom_info[i].description != (char *) NULL; i++)\n            if ((group == dicom_info[i].group) &&\n                (element == dicom_info[i].element))\n              break;\n          (void) FormatLocaleFile(stdout,\"0x%04lX %4ld %s-%s (0x%04lx,0x%04lx)\",\n            (unsigned long) image->offset,(long) length,implicit_vr,explicit_vr,\n            (unsigned long) group,(unsigned long) element);\n          if (dicom_info[i].description != (char *) NULL)\n            (void) FormatLocaleFile(stdout,\" %s\",dicom_info[i].description);\n          (void) FormatLocaleFile(stdout,\": \");\n        }\n      if ((group == 0x7FE0) && (element == 0x0010))\n        {\n          if (image_info->verbose != MagickFalse)\n            (void) FormatLocaleFile(stdout,\"\\n\");\n          break;\n        }\n      /*\n        Allocate space and read an array.\n      */\n      data=(unsigned char *) NULL;\n      if ((length == 1) && (quantum == 1))\n        datum=ReadBlobByte(image);\n      else\n        if ((length == 1) && (quantum == 2))\n          {\n            if (group == 0x0002)\n              datum=ReadBlobLSBSignedShort(image);\n            else\n              datum=ReadBlobSignedShort(image);\n          }\n        else\n          if ((length == 1) && (quantum == 4))\n            {\n              if (group == 0x0002)\n                datum=ReadBlobLSBSignedLong(image);\n              else\n                datum=ReadBlobSignedLong(image);\n            }\n          else\n            if ((quantum != 0) && (length != 0))\n              {\n                if (length > (size_t) GetBlobSize(image))\n                  ThrowDCMException(CorruptImageError,\n                    \"InsufficientImageDataInFile\");\n                if (~length >= 1)\n                  data=(unsigned char *) AcquireQuantumMemory(length+1,quantum*\n                    sizeof(*data));\n                if (data == (unsigned char *) NULL)\n                  ThrowDCMException(ResourceLimitError,\n                    \"MemoryAllocationFailed\");\n                count=ReadBlob(image,(size_t) quantum*length,data);\n                if (count != (ssize_t) (quantum*length))\n                  {\n                    if (image_info->verbose != MagickFalse)\n                      (void) FormatLocaleFile(stdout,\"count=%d quantum=%d \"\n                        \"length=%d group=%d\\n\",(int) count,(int) quantum,(int)\n                        length,(int) group);\n                     ThrowDCMException(CorruptImageError,\n                       \"InsufficientImageDataInFile\");\n                  }\n                data[length*quantum]='\\0';\n              }\n      if ((((unsigned int) group << 16) | element) == 0xFFFEE0DD)\n        {\n          if (data != (unsigned char *) NULL)\n            data=(unsigned char *) RelinquishMagickMemory(data);\n          continue;\n        }\n      switch (group)\n      {\n        case 0x0002:\n        {\n          switch (element)\n          {\n            case 0x0010:\n            {\n              char\n                transfer_syntax[MagickPathExtent];\n\n              /*\n                Transfer Syntax.\n              */\n              if ((datum == 0) && (explicit_retry == MagickFalse))\n                {\n                  explicit_retry=MagickTrue;\n                  (void) SeekBlob(image,(MagickOffsetType) 0,SEEK_SET);\n                  group=0;\n                  element=0;\n                  if (image_info->verbose != MagickFalse)\n                    (void) FormatLocaleFile(stdout,\n                      \"Corrupted image - trying explicit format\\n\");\n                  break;\n                }\n              *transfer_syntax='\\0';\n              if (data != (unsigned char *) NULL)\n                (void) CopyMagickString(transfer_syntax,(char *) data,\n                  MagickPathExtent);\n              if (image_info->verbose != MagickFalse)\n                (void) FormatLocaleFile(stdout,\"transfer_syntax=%s\\n\",\n                  (const char *) transfer_syntax);\n              if (strncmp(transfer_syntax,\"1.2.840.10008.1.2\",17) == 0)\n                {\n                  int\n                    subtype,\n                    type;\n\n                  type=1;\n                  subtype=0;\n                  if (strlen(transfer_syntax) > 17)\n                    {\n                      count=(ssize_t) sscanf(transfer_syntax+17,\".%d.%d\",&type,\n                        &subtype);\n                      if (count < 1)\n                        ThrowDCMException(CorruptImageError,\n                          \"ImproperImageHeader\");\n                    }\n                  switch (type)\n                  {\n                    case 1:\n                    {\n                      image->endian=LSBEndian;\n                      break;\n                    }\n                    case 2:\n                    {\n                      image->endian=MSBEndian;\n                      break;\n                    }\n                    case 4:\n                    {\n                      if ((subtype >= 80) && (subtype <= 81))\n                        image->compression=JPEGCompression;\n                      else\n                        if ((subtype >= 90) && (subtype <= 93))\n                          image->compression=JPEG2000Compression;\n                        else\n                          image->compression=JPEGCompression;\n                      break;\n                    }\n                    case 5:\n                    {\n                      image->compression=RLECompression;\n                      break;\n                    }\n                  }\n                }\n              break;\n            }\n            default:\n              break;\n          }\n          break;\n        }\n        case 0x0028:\n        {\n          switch (element)\n          {\n            case 0x0002:\n            {\n              /*\n                Samples per pixel.\n              */\n              info.samples_per_pixel=(size_t) datum;\n              if ((info.samples_per_pixel == 0) || (info.samples_per_pixel > 4))\n                ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n              break;\n            }\n            case 0x0004:\n            {\n              /*\n                Photometric interpretation.\n              */\n              if (data == (unsigned char *) NULL)\n                break;\n              for (i=0; i < (ssize_t) MagickMin(length,MagickPathExtent-1); i++)\n                photometric[i]=(char) data[i];\n              photometric[i]='\\0';\n              info.polarity=LocaleCompare(photometric,\"MONOCHROME1 \") == 0 ?\n                MagickTrue : MagickFalse;\n              break;\n            }\n            case 0x0006:\n            {\n              /*\n                Planar configuration.\n              */\n              if (datum == 1)\n                image->interlace=PlaneInterlace;\n              break;\n            }\n            case 0x0008:\n            {\n              /*\n                Number of frames.\n              */\n              if (data == (unsigned char *) NULL)\n                break;\n              number_scenes=StringToUnsignedLong((char *) data);\n              break;\n            }\n            case 0x0010:\n            {\n              /*\n                Image rows.\n              */\n              height=(size_t) datum;\n              break;\n            }\n            case 0x0011:\n            {\n              /*\n                Image columns.\n              */\n              width=(size_t) datum;\n              break;\n            }\n            case 0x0100:\n            {\n              /*\n                Bits allocated.\n              */\n              info.bits_allocated=(size_t) datum;\n              info.bytes_per_pixel=1;\n              if (datum > 8)\n                info.bytes_per_pixel=2;\n              info.depth=info.bits_allocated;\n              if ((info.depth == 0) || (info.depth > 32))\n                ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n              info.max_value=(1UL << info.bits_allocated)-1;\n              image->depth=info.depth;\n              break;\n            }\n            case 0x0101:\n            {\n              /*\n                Bits stored.\n              */\n              info.significant_bits=(size_t) datum;\n              info.bytes_per_pixel=1;\n              if (info.significant_bits > 8)\n                info.bytes_per_pixel=2;\n              info.depth=info.significant_bits;\n              if ((info.depth == 0) || (info.depth > 16))\n                ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n              info.max_value=(1UL << info.significant_bits)-1;\n              info.mask=(size_t) GetQuantumRange(info.significant_bits);\n              image->depth=info.depth;\n              break;\n            }\n            case 0x0102:\n            {\n              /*\n                High bit.\n              */\n              break;\n            }\n            case 0x0103:\n            {\n              /*\n                Pixel representation.\n              */\n              info.signed_data=(size_t) datum;\n              break;\n            }\n            case 0x1050:\n            {\n              /*\n                Visible pixel range: center.\n              */\n              if (data != (unsigned char *) NULL)\n                info.window_center=StringToDouble((char *) data,(char **) NULL);\n              break;\n            }\n            case 0x1051:\n            {\n              /*\n                Visible pixel range: width.\n              */\n              if (data != (unsigned char *) NULL)\n                info.window_width=StringToDouble((char *) data,(char **) NULL);\n              break;\n            }\n            case 0x1052:\n            {\n              /*\n                Rescale intercept\n              */\n              if (data != (unsigned char *) NULL)\n                info.rescale_intercept=StringToDouble((char *) data,\n                  (char **) NULL);\n              break;\n            }\n            case 0x1053:\n            {\n              /*\n                Rescale slope\n              */\n              if (data != (unsigned char *) NULL)\n                info.rescale_slope=StringToDouble((char *) data,(char **) NULL);\n              break;\n            }\n            case 0x1200:\n            case 0x3006:\n            {\n              /*\n                Populate graymap.\n              */\n              if (data == (unsigned char *) NULL)\n                break;\n              colors=(size_t) (length/info.bytes_per_pixel);\n              datum=(int) colors;\n              if (graymap != (int *) NULL)\n                graymap=(int *) RelinquishMagickMemory(graymap);\n              graymap=(int *) AcquireQuantumMemory(MagickMax(colors,65536),\n                sizeof(*graymap));\n              if (graymap == (int *) NULL)\n                ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n              (void) memset(graymap,0,MagickMax(colors,65536)*\n                sizeof(*graymap));\n              for (i=0; i < (ssize_t) colors; i++)\n                if (info.bytes_per_pixel == 1)\n                  graymap[i]=(int) data[i];\n                else\n                  graymap[i]=(int) ((short *) data)[i];\n              break;\n            }\n            case 0x1201:\n            {\n              unsigned short\n                index;\n\n              /*\n                Populate redmap.\n              */\n              if (data == (unsigned char *) NULL)\n                break;\n              colors=(size_t) (length/2);\n              datum=(int) colors;\n              if (redmap != (int *) NULL)\n                redmap=(int *) RelinquishMagickMemory(redmap);\n              redmap=(int *) AcquireQuantumMemory(MagickMax(colors,65536),\n                sizeof(*redmap));\n              if (redmap == (int *) NULL)\n                ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n              (void) memset(redmap,0,MagickMax(colors,65536)*\n                sizeof(*redmap));\n              p=data;\n              for (i=0; i < (ssize_t) colors; i++)\n              {\n                if (image->endian == MSBEndian)\n                  index=(unsigned short) ((*p << 8) | *(p+1));\n                else\n                  index=(unsigned short) (*p | (*(p+1) << 8));\n                redmap[i]=(int) index;\n                p+=2;\n              }\n              break;\n            }\n            case 0x1202:\n            {\n              unsigned short\n                index;\n\n              /*\n                Populate greenmap.\n              */\n              if (data == (unsigned char *) NULL)\n                break;\n              colors=(size_t) (length/2);\n              datum=(int) colors;\n              if (greenmap != (int *) NULL)\n                greenmap=(int *) RelinquishMagickMemory(greenmap);\n              greenmap=(int *) AcquireQuantumMemory(MagickMax(colors,65536),\n                sizeof(*greenmap));\n              if (greenmap == (int *) NULL)\n                ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n              (void) memset(greenmap,0,MagickMax(colors,65536)*\n                sizeof(*greenmap));\n              p=data;\n              for (i=0; i < (ssize_t) colors; i++)\n              {\n                if (image->endian == MSBEndian)\n                  index=(unsigned short) ((*p << 8) | *(p+1));\n                else\n                  index=(unsigned short) (*p | (*(p+1) << 8));\n                greenmap[i]=(int) index;\n                p+=2;\n              }\n              break;\n            }\n            case 0x1203:\n            {\n              unsigned short\n                index;\n\n              /*\n                Populate bluemap.\n              */\n              if (data == (unsigned char *) NULL)\n                break;\n              colors=(size_t) (length/2);\n              datum=(int) colors;\n              if (bluemap != (int *) NULL)\n                bluemap=(int *) RelinquishMagickMemory(bluemap);\n              bluemap=(int *) AcquireQuantumMemory(MagickMax(colors,65536),\n                sizeof(*bluemap));\n              if (bluemap == (int *) NULL)\n                ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n              (void) memset(bluemap,0,MagickMax(colors,65536)*\n                sizeof(*bluemap));\n              p=data;\n              for (i=0; i < (ssize_t) colors; i++)\n              {\n                if (image->endian == MSBEndian)\n                  index=(unsigned short) ((*p << 8) | *(p+1));\n                else\n                  index=(unsigned short) (*p | (*(p+1) << 8));\n                bluemap[i]=(int) index;\n                p+=2;\n              }\n              break;\n            }\n            default:\n              break;\n          }\n          break;\n        }\n        case 0x2050:\n        {\n          switch (element)\n          {\n            case 0x0020:\n            {\n              if ((data != (unsigned char *) NULL) &&\n                  (strncmp((char *) data,\"INVERSE\",7) == 0))\n                info.polarity=MagickTrue;\n              break;\n            }\n            default:\n              break;\n          }\n          break;\n        }\n        default:\n          break;\n      }\n      if (data != (unsigned char *) NULL)\n        {\n          char\n            *attribute;\n\n          for (i=0; dicom_info[i].description != (char *) NULL; i++)\n            if ((group == dicom_info[i].group) &&\n                (element == dicom_info[i].element))\n              break;\n          if (dicom_info[i].description != (char *) NULL)\n            {\n              attribute=AcquireString(\"dcm:\");\n              (void) ConcatenateString(&attribute,dicom_info[i].description);\n              for (i=0; i < (ssize_t) MagickMax(length,4); i++)\n                if (isprint((int) data[i]) == MagickFalse)\n                  break;\n              if ((i == (ssize_t) length) || (length > 4))\n                {\n                  (void) SubstituteString(&attribute,\" \",\"\");\n                  (void) SetImageProperty(image,attribute,(char *) data,\n                    exception);\n                }\n              attribute=DestroyString(attribute);\n            }\n        }\n      if (image_info->verbose != MagickFalse)\n        {\n          if (data == (unsigned char *) NULL)\n            (void) FormatLocaleFile(stdout,\"%d\\n\",datum);\n          else\n            {\n              /*\n                Display group data.\n              */\n              for (i=0; i < (ssize_t) MagickMax(length,4); i++)\n                if (isprint((int) data[i]) == MagickFalse)\n                  break;\n              if ((i != (ssize_t) length) && (length <= 4))\n                {\n                  ssize_t\n                    j;\n\n                  datum=0;\n                  for (j=(ssize_t) length-1; j >= 0; j--)\n                    datum=(256*datum+data[j]);\n                  (void) FormatLocaleFile(stdout,\"%d\",datum);\n                }\n              else\n                for (i=0; i < (ssize_t) length; i++)\n                  if (isprint((int) data[i]) != MagickFalse)\n                    (void) FormatLocaleFile(stdout,\"%c\",data[i]);\n                  else\n                    (void) FormatLocaleFile(stdout,\"%c\",'.');\n              (void) FormatLocaleFile(stdout,\"\\n\");\n            }\n        }\n      if (data != (unsigned char *) NULL)\n        data=(unsigned char *) RelinquishMagickMemory(data);\n      if (EOFBlob(image) != MagickFalse)\n        {\n          ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n            image->filename);\n          break;\n        }\n    }\n    if ((group == 0xfffc) && (element == 0xfffc))\n      {\n        Image\n          *last;\n\n        last=RemoveLastImageFromList(&image);\n        if (last != (Image *) NULL)\n          last=DestroyImage(last);\n        break;\n      }\n    if ((width == 0) || (height == 0))\n      ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n    image->columns=(size_t) width;\n    image->rows=(size_t) height;\n    if (info.signed_data == 0xffff)\n      info.signed_data=(size_t) (info.significant_bits == 16 ? 1 : 0);\n    if ((image->compression == JPEGCompression) ||\n        (image->compression == JPEG2000Compression))\n      {\n        Image\n          *images;\n\n        ImageInfo\n          *read_info;\n\n        int\n          c;\n\n        /*\n          Read offset table.\n        */\n        for (i=0; i < (ssize_t) stream_info->remaining; i++)\n          if (ReadBlobByte(image) == EOF)\n            break;\n        (void) (((ssize_t) ReadBlobLSBShort(image) << 16) |\n          ReadBlobLSBShort(image));\n        length=(size_t) ReadBlobLSBLong(image);\n        if (length > (size_t) GetBlobSize(image))\n          ThrowDCMException(CorruptImageError,\"InsufficientImageDataInFile\");\n        stream_info->offset_count=length >> 2;\n        if (stream_info->offset_count != 0)\n          {\n            if (stream_info->offsets != (ssize_t *) NULL)\n              stream_info->offsets=(ssize_t *) RelinquishMagickMemory(\n                stream_info->offsets);\n            stream_info->offsets=(ssize_t *) AcquireQuantumMemory(\n              stream_info->offset_count,sizeof(*stream_info->offsets));\n            if (stream_info->offsets == (ssize_t *) NULL)\n              ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n            for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n              stream_info->offsets[i]=(ssize_t) ReadBlobLSBSignedLong(image);\n            offset=TellBlob(image);\n            for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n              stream_info->offsets[i]+=offset;\n          }\n        /*\n          Handle non-native image formats.\n        */\n        read_info=CloneImageInfo(image_info);\n        SetImageInfoBlob(read_info,(void *) NULL,0);\n        images=NewImageList();\n        for (scene=0; scene < (ssize_t) number_scenes; scene++)\n        {\n          char\n            filename[MagickPathExtent];\n\n          const char\n            *property;\n\n          FILE\n            *file;\n\n          Image\n            *jpeg_image;\n\n          int\n            unique_file;\n\n          unsigned int\n            tag;\n\n          tag=((unsigned int) ReadBlobLSBShort(image) << 16) |\n            ReadBlobLSBShort(image);\n          length=(size_t) ReadBlobLSBLong(image);\n          if (tag == 0xFFFEE0DD)\n            break; /* sequence delimiter tag */\n          if (tag != 0xFFFEE000)\n            {\n              read_info=DestroyImageInfo(read_info);\n              ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n            }\n          file=(FILE *) NULL;\n          unique_file=AcquireUniqueFileResource(filename);\n          if (unique_file != -1)\n            file=fdopen(unique_file,\"wb\");\n          if (file == (FILE *) NULL)\n            {\n              (void) RelinquishUniqueFileResource(filename);\n              ThrowFileException(exception,FileOpenError,\n                \"UnableToCreateTemporaryFile\",filename);\n              break;\n            }\n          for (c=EOF; length != 0; length--)\n          {\n            c=ReadBlobByte(image);\n            if (c == EOF)\n              {\n                ThrowFileException(exception,CorruptImageError,\n                   \"UnexpectedEndOfFile\",image->filename);\n                 break;\n               }\n            if (fputc(c,file) != c)\n              break;\n           }\n           (void) fclose(file);\n           if (c == EOF)\n            break;\n          (void) FormatLocaleString(read_info->filename,MagickPathExtent,\n            \"jpeg:%s\",filename);\n          if (image->compression == JPEG2000Compression)\n            (void) FormatLocaleString(read_info->filename,MagickPathExtent,\n              \"j2k:%s\",filename);\n          jpeg_image=ReadImage(read_info,exception);\n          if (jpeg_image != (Image *) NULL)\n            {\n              ResetImagePropertyIterator(image);\n              property=GetNextImageProperty(image);\n              while (property != (const char *) NULL)\n              {\n                (void) SetImageProperty(jpeg_image,property,\n                  GetImageProperty(image,property,exception),exception);\n                property=GetNextImageProperty(image);\n              }\n              AppendImageToList(&images,jpeg_image);\n            }\n          (void) RelinquishUniqueFileResource(filename);\n        }\n        read_info=DestroyImageInfo(read_info);\n        if (stream_info->offsets != (ssize_t *) NULL)\n          stream_info->offsets=(ssize_t *)\n            RelinquishMagickMemory(stream_info->offsets);\n        stream_info=(DCMStreamInfo *) RelinquishMagickMemory(stream_info);\n        if (info.scale != (Quantum *) NULL)\n          info.scale=(Quantum *) RelinquishMagickMemory(info.scale);\n        if (graymap != (int *) NULL)\n          graymap=(int *) RelinquishMagickMemory(graymap);\n        if (bluemap != (int *) NULL)\n          bluemap=(int *) RelinquishMagickMemory(bluemap);\n        if (greenmap != (int *) NULL)\n          greenmap=(int *) RelinquishMagickMemory(greenmap);\n        if (redmap != (int *) NULL)\n          redmap=(int *) RelinquishMagickMemory(redmap);\n        image=DestroyImageList(image);\n        return(GetFirstImageInList(images));\n      }\n    if (info.depth != (1UL*MAGICKCORE_QUANTUM_DEPTH))\n      {\n        QuantumAny\n          range;\n\n        /*\n          Compute pixel scaling table.\n        */\n         length=(size_t) (GetQuantumRange(info.depth)+1);\n         if (length > (size_t) GetBlobSize(image))\n           ThrowDCMException(CorruptImageError,\"InsufficientImageDataInFile\");\n        if (info.scale != (Quantum *) NULL)\n           info.scale=(Quantum *) RelinquishMagickMemory(info.scale);\n         info.scale=(Quantum *) AcquireQuantumMemory(MagickMax(length,256),\n           sizeof(*info.scale));\n        if (info.scale == (Quantum *) NULL)\n          ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) memset(info.scale,0,MagickMax(length,256)*\n          sizeof(*info.scale));\n        range=GetQuantumRange(info.depth);\n        for (i=0; i <= (ssize_t) GetQuantumRange(info.depth); i++)\n          info.scale[i]=ScaleAnyToQuantum((size_t) i,range);\n      }\n    if (image->compression == RLECompression)\n      {\n        unsigned int\n          tag;\n\n        /*\n          Read RLE offset table.\n        */\n        for (i=0; i < (ssize_t) stream_info->remaining; i++)\n        {\n          int\n            c;\n\n          c=ReadBlobByte(image);\n          if (c == EOF)\n            break;\n        }\n        tag=((unsigned int) ReadBlobLSBShort(image) << 16) |\n          ReadBlobLSBShort(image);\n        (void) tag;\n        length=(size_t) ReadBlobLSBLong(image);\n        if (length > (size_t) GetBlobSize(image))\n          ThrowDCMException(CorruptImageError,\"InsufficientImageDataInFile\");\n        stream_info->offset_count=length >> 2;\n        if (stream_info->offset_count != 0)\n          {\n            stream_info->offsets=(ssize_t *) AcquireQuantumMemory(\n              stream_info->offset_count,sizeof(*stream_info->offsets));\n            if (stream_info->offsets == (ssize_t *) NULL)\n              ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n            for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n            {\n              stream_info->offsets[i]=(ssize_t) ReadBlobLSBSignedLong(image);\n              if (EOFBlob(image) != MagickFalse)\n                break;\n            }\n            offset=TellBlob(image)+8;\n            for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n              stream_info->offsets[i]+=offset;\n          }\n      }\n    for (scene=0; scene < (ssize_t) number_scenes; scene++)\n    {\n      if (image_info->ping != MagickFalse)\n        break;\n      image->columns=(size_t) width;\n      image->rows=(size_t) height;\n      image->depth=info.depth;\n      status=SetImageExtent(image,image->columns,image->rows,exception);\n      if (status == MagickFalse)\n        break;\n      image->colorspace=RGBColorspace;\n      (void) SetImageBackgroundColor(image,exception);\n      if ((image->colormap == (PixelInfo *) NULL) &&\n          (info.samples_per_pixel == 1))\n        {\n          int\n            index;\n\n          size_t\n            one;\n\n          one=1;\n          if (colors == 0)\n            colors=one << info.depth;\n          if (AcquireImageColormap(image,colors,exception) == MagickFalse)\n            ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n          if (redmap != (int *) NULL)\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              index=redmap[i];\n              if ((info.scale != (Quantum *) NULL) && (index >= 0) &&\n                  (index <= (int) info.max_value))\n                index=(int) info.scale[index];\n              image->colormap[i].red=(MagickRealType) index;\n            }\n          if (greenmap != (int *) NULL)\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              index=greenmap[i];\n              if ((info.scale != (Quantum *) NULL) && (index >= 0) &&\n                  (index <= (int) info.max_value))\n                index=(int) info.scale[index];\n              image->colormap[i].green=(MagickRealType) index;\n            }\n          if (bluemap != (int *) NULL)\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              index=bluemap[i];\n              if ((info.scale != (Quantum *) NULL) && (index >= 0) &&\n                  (index <= (int) info.max_value))\n                index=(int) info.scale[index];\n              image->colormap[i].blue=(MagickRealType) index;\n            }\n          if (graymap != (int *) NULL)\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              index=graymap[i];\n              if ((info.scale != (Quantum *) NULL) && (index >= 0) &&\n                  (index <= (int) info.max_value))\n                index=(int) info.scale[index];\n              image->colormap[i].red=(MagickRealType) index;\n              image->colormap[i].green=(MagickRealType) index;\n              image->colormap[i].blue=(MagickRealType) index;\n            }\n        }\n      if (image->compression == RLECompression)\n        {\n          unsigned int\n            tag;\n\n          /*\n            Read RLE segment table.\n          */\n          for (i=0; i < (ssize_t) stream_info->remaining; i++)\n          {\n            int\n              c;\n\n            c=ReadBlobByte(image);\n            if (c == EOF)\n              break;\n          }\n          tag=((unsigned int) ReadBlobLSBShort(image) << 16) |\n            ReadBlobLSBShort(image);\n          stream_info->remaining=(size_t) ReadBlobLSBLong(image);\n          if ((tag != 0xFFFEE000) || (stream_info->remaining <= 64) ||\n              (EOFBlob(image) != MagickFalse))\n            {\n              if (stream_info->offsets != (ssize_t *) NULL)\n                stream_info->offsets=(ssize_t *)\n                  RelinquishMagickMemory(stream_info->offsets);\n              ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n            }\n          stream_info->count=0;\n          stream_info->segment_count=ReadBlobLSBLong(image);\n          for (i=0; i < 15; i++)\n            stream_info->segments[i]=(ssize_t) ReadBlobLSBSignedLong(image);\n          stream_info->remaining-=64;\n          if (stream_info->segment_count > 1)\n            {\n              info.bytes_per_pixel=1;\n              info.depth=8;\n              if (stream_info->offset_count > 0)\n                (void) SeekBlob(image,(MagickOffsetType)\n                  stream_info->offsets[0]+stream_info->segments[0],SEEK_SET);\n            }\n        }\n      if ((info.samples_per_pixel > 1) && (image->interlace == PlaneInterlace))\n        {\n          register ssize_t\n            x;\n\n          register Quantum\n            *q;\n\n          ssize_t\n            y;\n\n          /*\n            Convert Planar RGB DCM Medical image to pixel packets.\n          */\n          for (i=0; i < (ssize_t) info.samples_per_pixel; i++)\n          {\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                switch ((int) i)\n                {\n                  case 0:\n                  {\n                    SetPixelRed(image,ScaleCharToQuantum((unsigned char)\n                      ReadDCMByte(stream_info,image)),q);\n                    break;\n                  }\n                  case 1:\n                  {\n                    SetPixelGreen(image,ScaleCharToQuantum((unsigned char)\n                      ReadDCMByte(stream_info,image)),q);\n                    break;\n                  }\n                  case 2:\n                  {\n                    SetPixelBlue(image,ScaleCharToQuantum((unsigned char)\n                      ReadDCMByte(stream_info,image)),q);\n                    break;\n                  }\n                  case 3:\n                  {\n                    SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)\n                      ReadDCMByte(stream_info,image)),q);\n                    break;\n                  }\n                  default:\n                    break;\n                }\n                q+=GetPixelChannels(image);\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n          }\n        }\n      else\n        {\n          const char\n            *option;\n\n          /*\n            Convert DCM Medical image to pixel packets.\n          */\n          option=GetImageOption(image_info,\"dcm:display-range\");\n          if (option != (const char *) NULL)\n            {\n              if (LocaleCompare(option,\"reset\") == 0)\n                info.window_width=0;\n            }\n          option=GetImageOption(image_info,\"dcm:window\");\n          if (option != (char *) NULL)\n            {\n              GeometryInfo\n                geometry_info;\n\n              MagickStatusType\n                flags;\n\n              flags=ParseGeometry(option,&geometry_info);\n              if (flags & RhoValue)\n                info.window_center=geometry_info.rho;\n              if (flags & SigmaValue)\n                info.window_width=geometry_info.sigma;\n              info.rescale=MagickTrue;\n            }\n          option=GetImageOption(image_info,\"dcm:rescale\");\n          if (option != (char *) NULL)\n            info.rescale=IsStringTrue(option);\n          if ((info.window_center != 0) && (info.window_width == 0))\n            info.window_width=info.window_center;\n          status=ReadDCMPixels(image,&info,stream_info,MagickTrue,exception);\n          if ((status != MagickFalse) && (stream_info->segment_count > 1))\n            {\n              if (stream_info->offset_count > 0)\n                (void) SeekBlob(image,(MagickOffsetType)\n                  stream_info->offsets[0]+stream_info->segments[1],SEEK_SET);\n              (void) ReadDCMPixels(image,&info,stream_info,MagickFalse,\n                exception);\n            }\n        }\n      if (SetImageGray(image,exception) != MagickFalse)\n        (void) SetImageColorspace(image,GRAYColorspace,exception);\n      if (EOFBlob(image) != MagickFalse)\n        {\n          ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n            image->filename);\n          break;\n        }\n      /*\n        Proceed to next image.\n      */\n      if (image_info->number_scenes != 0)\n        if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n          break;\n      if (scene < (ssize_t) (number_scenes-1))\n        {\n          /*\n            Allocate next image structure.\n          */\n          AcquireNextImage(image_info,image,exception);\n          if (GetNextImageInList(image) == (Image *) NULL)\n            {\n              status=MagickFalse;\n              break;\n            }\n          image=SyncNextImageInList(image);\n          status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n            GetBlobSize(image));\n          if (status == MagickFalse)\n            break;\n        }\n    }\n    if (TellBlob(image) < (MagickOffsetType) GetBlobSize(image))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            status=MagickFalse;\n            break;\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n     }\n  }\n  /*\n    Free resources.\n  */\n  if (stream_info->offsets != (ssize_t *) NULL)\n    stream_info->offsets=(ssize_t *)\n      RelinquishMagickMemory(stream_info->offsets);\n  stream_info=(DCMStreamInfo *) RelinquishMagickMemory(stream_info);\n  if (info.scale != (Quantum *) NULL)\n    info.scale=(Quantum *) RelinquishMagickMemory(info.scale);\n  if (graymap != (int *) NULL)\n    graymap=(int *) RelinquishMagickMemory(graymap);\n  if (bluemap != (int *) NULL)\n    bluemap=(int *) RelinquishMagickMemory(bluemap);\n  if (greenmap != (int *) NULL)\n    greenmap=(int *) RelinquishMagickMemory(greenmap);\n  if (redmap != (int *) NULL)\n    redmap=(int *) RelinquishMagickMemory(redmap);\n  (void) CloseBlob(image);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  return(GetFirstImageInList(image));\n}\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 93,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2018-6111",
    "code_before_change": " void ServiceWorkerDevToolsAgentHost::WorkerDestroyed() {\n  DCHECK_NE(WORKER_TERMINATED, state_);\n  state_ = WORKER_TERMINATED;\n  agent_ptr_.reset();\n   for (auto* inspector : protocol::InspectorHandler::ForAgentHost(this))\n     inspector->TargetCrashed();\n   for (DevToolsSession* session : sessions())\n    session->SetRenderer(nullptr, nullptr);\n }\n",
    "code_after_change": " void ServiceWorkerDevToolsAgentHost::WorkerDestroyed() {\n  DCHECK_NE(WORKER_TERMINATED, state_);\n  state_ = WORKER_TERMINATED;\n  agent_ptr_.reset();\n   for (auto* inspector : protocol::InspectorHandler::ForAgentHost(this))\n     inspector->TargetCrashed();\n   for (DevToolsSession* session : sessions())\n    session->SetRenderer(-1, nullptr);\n }\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 98,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2011-2350",
    "code_before_change": "EncodedJSValue JSC_HOST_CALL jsTestEventTargetPrototypeFunctionItem(ExecState* exec)\n{\n    JSValue thisValue = exec->hostThisValue();\n    if (!thisValue.inherits(&JSTestEventTarget::s_info))\n        return throwVMTypeError(exec);\n    JSTestEventTarget* castedThis = jsCast<JSTestEventTarget*>(asObject(thisValue));\n     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestEventTarget::s_info);\n     TestEventTarget* impl = static_cast<TestEventTarget*>(castedThis->impl());\n     if (exec->argumentCount() < 1)\n        return throwVMError(exec, createTypeError(exec, \"Not enough arguments\"));\n     int index(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).toUInt32(exec));\n     if (index < 0) {\n         setDOMException(exec, INDEX_SIZE_ERR);\n        return JSValue::encode(jsUndefined());\n    }\n    if (exec->hadException())\n        return JSValue::encode(jsUndefined());\n\n    JSC::JSValue result = toJS(exec, castedThis->globalObject(), WTF::getPtr(impl->item(index)));\n    return JSValue::encode(result);\n}\n",
    "code_after_change": "EncodedJSValue JSC_HOST_CALL jsTestEventTargetPrototypeFunctionItem(ExecState* exec)\n{\n    JSValue thisValue = exec->hostThisValue();\n    if (!thisValue.inherits(&JSTestEventTarget::s_info))\n        return throwVMTypeError(exec);\n    JSTestEventTarget* castedThis = jsCast<JSTestEventTarget*>(asObject(thisValue));\n     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestEventTarget::s_info);\n     TestEventTarget* impl = static_cast<TestEventTarget*>(castedThis->impl());\n     if (exec->argumentCount() < 1)\n        return throwVMError(exec, createNotEnoughArgumentsError(exec));\n     int index(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).toUInt32(exec));\n     if (index < 0) {\n         setDOMException(exec, INDEX_SIZE_ERR);\n        return JSValue::encode(jsUndefined());\n    }\n    if (exec->hadException())\n        return JSValue::encode(jsUndefined());\n\n    JSC::JSValue result = toJS(exec, castedThis->globalObject(), WTF::getPtr(impl->item(index)));\n    return JSValue::encode(result);\n}\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 100,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2011-2350",
    "code_before_change": "EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionIdbKey(ExecState* exec)\n{\n    JSValue thisValue = exec->hostThisValue();\n    if (!thisValue.inherits(&JSTestObj::s_info))\n        return throwVMTypeError(exec);\n    JSTestObj* castedThis = jsCast<JSTestObj*>(asObject(thisValue));\n     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);\n     TestObj* impl = static_cast<TestObj*>(castedThis->impl());\n     if (exec->argumentCount() < 1)\n        return throwVMError(exec, createTypeError(exec, \"Not enough arguments\"));\n     PassRefPtr<IDBKey> key(createIDBKeyFromValue(exec, MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined)));\n     if (exec->hadException())\n         return JSValue::encode(jsUndefined());\n    impl->idbKey(key);\n    return JSValue::encode(jsUndefined());\n}\n",
    "code_after_change": "EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionIdbKey(ExecState* exec)\n{\n    JSValue thisValue = exec->hostThisValue();\n    if (!thisValue.inherits(&JSTestObj::s_info))\n        return throwVMTypeError(exec);\n    JSTestObj* castedThis = jsCast<JSTestObj*>(asObject(thisValue));\n     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);\n     TestObj* impl = static_cast<TestObj*>(castedThis->impl());\n     if (exec->argumentCount() < 1)\n        return throwVMError(exec, createNotEnoughArgumentsError(exec));\n     PassRefPtr<IDBKey> key(createIDBKeyFromValue(exec, MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined)));\n     if (exec->hadException())\n         return JSValue::encode(jsUndefined());\n    impl->idbKey(key);\n    return JSValue::encode(jsUndefined());\n}\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 101,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2011-1296",
    "code_before_change": " void FindBarController::Show() {\n  FindManager* find_manager = tab_contents_->GetFindManager();\n \n  if (!find_manager->find_ui_active()) {\n     MaybeSetPrepopulateText();\n \n    find_manager->set_find_ui_active(true);\n     find_bar_->Show(true);\n   }\n   find_bar_->SetFocusAndSelection();\n}\n",
    "code_after_change": " void FindBarController::Show() {\n  FindTabHelper* find_tab_helper = tab_contents_->find_tab_helper();\n \n  if (!find_tab_helper->find_ui_active()) {\n     MaybeSetPrepopulateText();\n \n    find_tab_helper->set_find_ui_active(true);\n     find_bar_->Show(true);\n   }\n   find_bar_->SetFocusAndSelection();\n}\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 118,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2014-9907",
    "code_before_change": "static void SkipRGBMipmaps(Image *image, DDSInfo *dds_info, int pixel_size)\n {\n   MagickOffsetType\n     offset;\n\n  register ssize_t\n    i;\n\n  size_t\n    h,\n    w;\n\n  /*\n    Only skip mipmaps for textures and cube maps\n  */\n  if (dds_info->ddscaps1 & DDSCAPS_MIPMAP\n       && (dds_info->ddscaps1 & DDSCAPS_TEXTURE\n           || dds_info->ddscaps2 & DDSCAPS2_CUBEMAP))\n     {\n       w = DIV2(dds_info->width);\n       h = DIV2(dds_info->height);\n \n      /*\n        Mipmapcount includes the main image, so start from one\n      */\n      for (i=1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++)\n      {\n        offset = (MagickOffsetType) w * h * pixel_size;\n        (void) SeekBlob(image, offset, SEEK_CUR);\n\n        w = DIV2(w);\n         h = DIV2(h);\n       }\n     }\n }\n",
    "code_after_change": "static void SkipRGBMipmaps(Image *image, DDSInfo *dds_info, int pixel_size)\nstatic MagickBooleanType SkipRGBMipmaps(Image *image,DDSInfo *dds_info,\n  int pixel_size,ExceptionInfo *exception)\n {\n   MagickOffsetType\n     offset;\n\n  register ssize_t\n    i;\n\n  size_t\n    h,\n    w;\n\n  /*\n    Only skip mipmaps for textures and cube maps\n  */\n  if (dds_info->ddscaps1 & DDSCAPS_MIPMAP\n       && (dds_info->ddscaps1 & DDSCAPS_TEXTURE\n           || dds_info->ddscaps2 & DDSCAPS2_CUBEMAP))\n     {\n      if (EOFBlob(image) != MagickFalse)\n        {\n          ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n            image->filename);\n          return(MagickFalse);\n        }\n       w = DIV2(dds_info->width);\n       h = DIV2(dds_info->height);\n \n      /*\n        Mipmapcount includes the main image, so start from one\n      */\n      for (i=1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++)\n      {\n        offset = (MagickOffsetType) w * h * pixel_size;\n        (void) SeekBlob(image, offset, SEEK_CUR);\n\n        w = DIV2(w);\n         h = DIV2(h);\n       }\n     }\n  return(MagickTrue);\n }\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 130,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2018-6140",
    "code_before_change": " void DevToolsAgentHostImpl::AttachClient(DevToolsAgentHostClient* client) {\n   if (SessionByClient(client))\n     return;\n  InnerAttachClient(client);\n }\n",
    "code_after_change": " void DevToolsAgentHostImpl::AttachClient(DevToolsAgentHostClient* client) {\n   if (SessionByClient(client))\n     return;\n  InnerAttachClient(client, false /* restricted */);\n}\n\nbool DevToolsAgentHostImpl::AttachRestrictedClient(\n    DevToolsAgentHostClient* client) {\n  if (SessionByClient(client))\n    return false;\n  return InnerAttachClient(client, true /* restricted */);\n }\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 133,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2017-11450",
    "code_before_change": "ModuleExport size_t RegisterJPEGImage(void)\n{\n  char\n    version[MaxTextExtent];\n\n  MagickInfo\n    *entry;\n\n  static const char\n    description[] = \"Joint Photographic Experts Group JFIF format\";\n\n  *version='\\0';\n#if defined(JPEG_LIB_VERSION)\n  (void) FormatLocaleString(version,MaxTextExtent,\"%d\",JPEG_LIB_VERSION);\n#endif\n  entry=SetMagickInfo(\"JPE\");\n#if (JPEG_LIB_VERSION < 80) && !defined(LIBJPEG_TURBO_VERSION)\n  entry->thread_support=NoThreadSupport;\n#endif\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadJPEGImage;\n  entry->encoder=(EncodeImageHandler *) WriteJPEGImage;\n #endif\n   entry->magick=(IsImageFormatHandler *) IsJPEG;\n   entry->adjoin=MagickFalse;\n   entry->description=ConstantString(description);\n   if (*version != '\\0')\n     entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/jpeg\");\n  entry->module=ConstantString(\"JPEG\");\n  (void) RegisterMagickInfo(entry);\n  entry=SetMagickInfo(\"JPEG\");\n#if (JPEG_LIB_VERSION < 80) && !defined(LIBJPEG_TURBO_VERSION)\n  entry->thread_support=NoThreadSupport;\n#endif\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadJPEGImage;\n  entry->encoder=(EncodeImageHandler *) WriteJPEGImage;\n #endif\n   entry->magick=(IsImageFormatHandler *) IsJPEG;\n   entry->adjoin=MagickFalse;\n   entry->description=ConstantString(description);\n   if (*version != '\\0')\n     entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/jpeg\");\n  entry->module=ConstantString(\"JPEG\");\n  (void) RegisterMagickInfo(entry);\n  entry=SetMagickInfo(\"JPG\");\n#if (JPEG_LIB_VERSION < 80) && !defined(LIBJPEG_TURBO_VERSION)\n  entry->thread_support=NoThreadSupport;\n#endif\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadJPEGImage;\n   entry->encoder=(EncodeImageHandler *) WriteJPEGImage;\n #endif\n   entry->adjoin=MagickFalse;\n   entry->description=ConstantString(description);\n   if (*version != '\\0')\n     entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/jpeg\");\n  entry->module=ConstantString(\"JPEG\");\n  (void) RegisterMagickInfo(entry);\n  entry=SetMagickInfo(\"JPS\");\n#if (JPEG_LIB_VERSION < 80) && !defined(LIBJPEG_TURBO_VERSION)\n  entry->thread_support=NoThreadSupport;\n#endif\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadJPEGImage;\n   entry->encoder=(EncodeImageHandler *) WriteJPEGImage;\n #endif\n   entry->adjoin=MagickFalse;\n   entry->description=ConstantString(description);\n   if (*version != '\\0')\n     entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/jpeg\");\n  entry->module=ConstantString(\"JPEG\");\n  (void) RegisterMagickInfo(entry);\n  entry=SetMagickInfo(\"PJPEG\");\n#if (JPEG_LIB_VERSION < 80) && !defined(LIBJPEG_TURBO_VERSION)\n  entry->thread_support=NoThreadSupport;\n#endif\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadJPEGImage;\n   entry->encoder=(EncodeImageHandler *) WriteJPEGImage;\n #endif\n   entry->adjoin=MagickFalse;\n   entry->description=ConstantString(description);\n   if (*version != '\\0')\n     entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/jpeg\");\n  entry->module=ConstantString(\"JPEG\");\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n",
    "code_after_change": "ModuleExport size_t RegisterJPEGImage(void)\n{\n  char\n    version[MaxTextExtent];\n\n  MagickInfo\n    *entry;\n\n  static const char\n    description[] = \"Joint Photographic Experts Group JFIF format\";\n\n  *version='\\0';\n#if defined(JPEG_LIB_VERSION)\n  (void) FormatLocaleString(version,MaxTextExtent,\"%d\",JPEG_LIB_VERSION);\n#endif\n  entry=SetMagickInfo(\"JPE\");\n#if (JPEG_LIB_VERSION < 80) && !defined(LIBJPEG_TURBO_VERSION)\n  entry->thread_support=NoThreadSupport;\n#endif\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadJPEGImage;\n  entry->encoder=(EncodeImageHandler *) WriteJPEGImage;\n #endif\n   entry->magick=(IsImageFormatHandler *) IsJPEG;\n   entry->adjoin=MagickFalse;\n  entry->seekable_stream=MagickTrue;\n   entry->description=ConstantString(description);\n   if (*version != '\\0')\n     entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/jpeg\");\n  entry->module=ConstantString(\"JPEG\");\n  (void) RegisterMagickInfo(entry);\n  entry=SetMagickInfo(\"JPEG\");\n#if (JPEG_LIB_VERSION < 80) && !defined(LIBJPEG_TURBO_VERSION)\n  entry->thread_support=NoThreadSupport;\n#endif\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadJPEGImage;\n  entry->encoder=(EncodeImageHandler *) WriteJPEGImage;\n #endif\n   entry->magick=(IsImageFormatHandler *) IsJPEG;\n   entry->adjoin=MagickFalse;\n  entry->seekable_stream=MagickTrue;\n   entry->description=ConstantString(description);\n   if (*version != '\\0')\n     entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/jpeg\");\n  entry->module=ConstantString(\"JPEG\");\n  (void) RegisterMagickInfo(entry);\n  entry=SetMagickInfo(\"JPG\");\n#if (JPEG_LIB_VERSION < 80) && !defined(LIBJPEG_TURBO_VERSION)\n  entry->thread_support=NoThreadSupport;\n#endif\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadJPEGImage;\n   entry->encoder=(EncodeImageHandler *) WriteJPEGImage;\n #endif\n   entry->adjoin=MagickFalse;\n  entry->seekable_stream=MagickTrue;\n   entry->description=ConstantString(description);\n   if (*version != '\\0')\n     entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/jpeg\");\n  entry->module=ConstantString(\"JPEG\");\n  (void) RegisterMagickInfo(entry);\n  entry=SetMagickInfo(\"JPS\");\n#if (JPEG_LIB_VERSION < 80) && !defined(LIBJPEG_TURBO_VERSION)\n  entry->thread_support=NoThreadSupport;\n#endif\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadJPEGImage;\n   entry->encoder=(EncodeImageHandler *) WriteJPEGImage;\n #endif\n   entry->adjoin=MagickFalse;\n  entry->seekable_stream=MagickTrue;\n   entry->description=ConstantString(description);\n   if (*version != '\\0')\n     entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/jpeg\");\n  entry->module=ConstantString(\"JPEG\");\n  (void) RegisterMagickInfo(entry);\n  entry=SetMagickInfo(\"PJPEG\");\n#if (JPEG_LIB_VERSION < 80) && !defined(LIBJPEG_TURBO_VERSION)\n  entry->thread_support=NoThreadSupport;\n#endif\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadJPEGImage;\n   entry->encoder=(EncodeImageHandler *) WriteJPEGImage;\n #endif\n   entry->adjoin=MagickFalse;\n  entry->seekable_stream=MagickTrue;\n   entry->description=ConstantString(description);\n   if (*version != '\\0')\n     entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/jpeg\");\n  entry->module=ConstantString(\"JPEG\");\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 135,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2013-7271",
    "code_before_change": "static int hci_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t    struct msghdr *msg, size_t len, int flags)\n{\n\tint noblock = flags & MSG_DONTWAIT;\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tint copied, err;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\tif (flags & (MSG_OOB))\n\t\treturn -EOPNOTSUPP;\n\n\tif (sk->sk_state == BT_CLOSED)\n\t\treturn 0;\n\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n \tif (!skb)\n \t\treturn err;\n \n\tmsg->msg_namelen = 0;\n \tcopied = skb->len;\n \tif (len < copied) {\n \t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\n\tskb_reset_transport_header(skb);\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\n\tswitch (hci_pi(sk)->channel) {\n\tcase HCI_CHANNEL_RAW:\n\t\thci_sock_cmsg(sk, msg, skb);\n\t\tbreak;\n\tcase HCI_CHANNEL_USER:\n\tcase HCI_CHANNEL_CONTROL:\n\tcase HCI_CHANNEL_MONITOR:\n\t\tsock_recv_timestamp(msg, sk, skb);\n\t\tbreak;\n\t}\n\n\tskb_free_datagram(sk, skb);\n\n\treturn err ? : copied;\n}\n",
    "code_after_change": "static int hci_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t    struct msghdr *msg, size_t len, int flags)\n{\n\tint noblock = flags & MSG_DONTWAIT;\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tint copied, err;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\tif (flags & (MSG_OOB))\n\t\treturn -EOPNOTSUPP;\n\n\tif (sk->sk_state == BT_CLOSED)\n\t\treturn 0;\n\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n \tif (!skb)\n \t\treturn err;\n \n \tcopied = skb->len;\n \tif (len < copied) {\n \t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\n\tskb_reset_transport_header(skb);\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\n\tswitch (hci_pi(sk)->channel) {\n\tcase HCI_CHANNEL_RAW:\n\t\thci_sock_cmsg(sk, msg, skb);\n\t\tbreak;\n\tcase HCI_CHANNEL_USER:\n\tcase HCI_CHANNEL_CONTROL:\n\tcase HCI_CHANNEL_MONITOR:\n\t\tsock_recv_timestamp(msg, sk, skb);\n\t\tbreak;\n\t}\n\n\tskb_free_datagram(sk, skb);\n\n\treturn err ? : copied;\n}\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 139,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2016-1612",
    "code_before_change": " void TaskService::RunTask(InstanceId instance_id,\n                           RunnerId runner_id,\n                           base::OnceClosure task) {\n  base::subtle::AutoReadLock task_lock(task_lock_);\n   {\n    base::AutoLock lock(lock_);\n    if (instance_id != bound_instance_id_)\n      return;\n   }\n  std::move(task).Run();\n }\n",
    "code_after_change": " void TaskService::RunTask(InstanceId instance_id,\n                           RunnerId runner_id,\n                           base::OnceClosure task) {\n   {\n    base::AutoLock tasks_in_flight_auto_lock(tasks_in_flight_lock_);\n    ++tasks_in_flight_;\n   }\n\n  if (IsInstanceIdStillBound(instance_id))\n    std::move(task).Run();\n\n  {\n    base::AutoLock tasks_in_flight_auto_lock(tasks_in_flight_lock_);\n    --tasks_in_flight_;\n    DCHECK_GE(tasks_in_flight_, 0);\n    if (tasks_in_flight_ == 0)\n      no_tasks_in_flight_cv_.Signal();\n  }\n}\n\nbool TaskService::IsInstanceIdStillBound(InstanceId instance_id) {\n  base::AutoLock lock(lock_);\n  return instance_id == bound_instance_id_;\n }\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 145,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2017-12183",
    "code_before_change": " SProcXFixesQueryVersion(ClientPtr client)\n {\n     REQUEST(xXFixesQueryVersionReq);\n \n     swaps(&stuff->length);\n     swapl(&stuff->majorVersion);\n    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);\n}\n",
    "code_after_change": " SProcXFixesQueryVersion(ClientPtr client)\n {\n     REQUEST(xXFixesQueryVersionReq);\n    REQUEST_SIZE_MATCH(xXFixesQueryVersionReq);\n \n     swaps(&stuff->length);\n     swapl(&stuff->majorVersion);\n    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);\n}\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 146,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2016-1665",
    "code_before_change": "void DiceResponseHandler::ProcessDiceSignoutHeader(\n    const std::vector<signin::DiceResponseParams::AccountInfo>& account_infos) {\n  VLOG(1) << \"Start processing Dice signout response\";\n  if (account_consistency_ ==\n      signin::AccountConsistencyMethod::kDiceFixAuthErrors) {\n    return;\n  }\n\n  std::string primary_account = signin_manager_->GetAuthenticatedAccountId();\n  bool primary_account_signed_out = false;\n  for (const auto& account_info : account_infos) {\n    std::string signed_out_account =\n        account_tracker_service_->PickAccountIdForAccount(account_info.gaia_id,\n                                                          account_info.email);\n    if (signed_out_account == primary_account) {\n      primary_account_signed_out = true;\n      RecordDiceResponseHeader(kSignoutPrimary);\n      RecordGaiaSignoutMetrics(\n          (account_info.session_index == 0)\n              ? kChromePrimaryAccountIsFirstGaiaAccount\n              : kChromePrimaryAccountIsSecondaryGaiaAccount);\n\n      if (account_consistency_ == signin::AccountConsistencyMethod::kDice) {\n         token_service_->UpdateCredentials(\n             primary_account,\n            MutableProfileOAuth2TokenServiceDelegate::kInvalidRefreshToken);\n       } else {\n         continue;\n       }\n     } else {\n      token_service_->RevokeCredentials(signed_out_account);\n     }\n \n    for (auto it = token_fetchers_.begin(); it != token_fetchers_.end(); ++it) {\n      std::string token_fetcher_account_id =\n          account_tracker_service_->PickAccountIdForAccount(\n              it->get()->gaia_id(), it->get()->email());\n      if (token_fetcher_account_id == signed_out_account) {\n        token_fetchers_.erase(it);\n        break;\n      }\n    }\n  }\n\n  if (!primary_account_signed_out) {\n    RecordDiceResponseHeader(kSignoutSecondary);\n    RecordGaiaSignoutMetrics(primary_account.empty()\n                                 ? kNoChromePrimaryAccount\n                                 : kChromePrimaryAccountIsNotInGaiaAccounts);\n  }\n}\n",
    "code_after_change": "void DiceResponseHandler::ProcessDiceSignoutHeader(\n    const std::vector<signin::DiceResponseParams::AccountInfo>& account_infos) {\n  VLOG(1) << \"Start processing Dice signout response\";\n  if (account_consistency_ ==\n      signin::AccountConsistencyMethod::kDiceFixAuthErrors) {\n    return;\n  }\n\n  std::string primary_account = signin_manager_->GetAuthenticatedAccountId();\n  bool primary_account_signed_out = false;\n  for (const auto& account_info : account_infos) {\n    std::string signed_out_account =\n        account_tracker_service_->PickAccountIdForAccount(account_info.gaia_id,\n                                                          account_info.email);\n    if (signed_out_account == primary_account) {\n      primary_account_signed_out = true;\n      RecordDiceResponseHeader(kSignoutPrimary);\n      RecordGaiaSignoutMetrics(\n          (account_info.session_index == 0)\n              ? kChromePrimaryAccountIsFirstGaiaAccount\n              : kChromePrimaryAccountIsSecondaryGaiaAccount);\n\n      if (account_consistency_ == signin::AccountConsistencyMethod::kDice) {\n         token_service_->UpdateCredentials(\n             primary_account,\n            MutableProfileOAuth2TokenServiceDelegate::kInvalidRefreshToken,\n            signin_metrics::SourceForRefreshTokenOperation::\n                kDiceResponseHandler_Signout);\n       } else {\n         continue;\n       }\n     } else {\n      token_service_->RevokeCredentials(\n          signed_out_account, signin_metrics::SourceForRefreshTokenOperation::\n                                  kDiceResponseHandler_Signout);\n     }\n \n    for (auto it = token_fetchers_.begin(); it != token_fetchers_.end(); ++it) {\n      std::string token_fetcher_account_id =\n          account_tracker_service_->PickAccountIdForAccount(\n              it->get()->gaia_id(), it->get()->email());\n      if (token_fetcher_account_id == signed_out_account) {\n        token_fetchers_.erase(it);\n        break;\n      }\n    }\n  }\n\n  if (!primary_account_signed_out) {\n    RecordDiceResponseHeader(kSignoutSecondary);\n    RecordGaiaSignoutMetrics(primary_account.empty()\n                                 ? kNoChromePrimaryAccount\n                                 : kChromePrimaryAccountIsNotInGaiaAccounts);\n  }\n}\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 147,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2018-6085",
    "code_before_change": "void BackendIO::ExecuteBackendOperation() {\n  switch (operation_) {\n    case OP_INIT:\n      result_ = backend_->SyncInit();\n      break;\n    case OP_OPEN: {\n      scoped_refptr<EntryImpl> entry;\n      result_ = backend_->SyncOpenEntry(key_, &entry);\n      *entry_ptr_ = LeakEntryImpl(std::move(entry));\n      break;\n    }\n    case OP_CREATE: {\n      scoped_refptr<EntryImpl> entry;\n      result_ = backend_->SyncCreateEntry(key_, &entry);\n      *entry_ptr_ = LeakEntryImpl(std::move(entry));\n      break;\n    }\n    case OP_DOOM:\n      result_ = backend_->SyncDoomEntry(key_);\n      break;\n    case OP_DOOM_ALL:\n      result_ = backend_->SyncDoomAllEntries();\n      break;\n    case OP_DOOM_BETWEEN:\n      result_ = backend_->SyncDoomEntriesBetween(initial_time_, end_time_);\n      break;\n    case OP_DOOM_SINCE:\n      result_ = backend_->SyncDoomEntriesSince(initial_time_);\n      break;\n    case OP_SIZE_ALL:\n      result_ = backend_->SyncCalculateSizeOfAllEntries();\n      break;\n    case OP_OPEN_NEXT: {\n      scoped_refptr<EntryImpl> entry;\n      result_ = backend_->SyncOpenNextEntry(iterator_, &entry);\n      *entry_ptr_ = LeakEntryImpl(std::move(entry));\n      break;\n    }\n    case OP_END_ENUMERATION:\n      backend_->SyncEndEnumeration(std::move(scoped_iterator_));\n      result_ = net::OK;\n      break;\n    case OP_ON_EXTERNAL_CACHE_HIT:\n      backend_->SyncOnExternalCacheHit(key_);\n      result_ = net::OK;\n      break;\n    case OP_CLOSE_ENTRY:\n      entry_->Release();\n      result_ = net::OK;\n      break;\n    case OP_DOOM_ENTRY:\n      entry_->DoomImpl();\n      result_ = net::OK;\n      break;\n    case OP_FLUSH_QUEUE:\n      result_ = net::OK;\n      break;\n    case OP_RUN_TASK:\n      task_.Run();\n      result_ = net::OK;\n      break;\n    default:\n      NOTREACHED() << \"Invalid Operation\";\n      result_ = net::ERR_UNEXPECTED;\n   }\n   DCHECK_NE(net::ERR_IO_PENDING, result_);\n   NotifyController();\n }\n",
    "code_after_change": "void BackendIO::ExecuteBackendOperation() {\n  switch (operation_) {\n    case OP_INIT:\n      result_ = backend_->SyncInit();\n      break;\n    case OP_OPEN: {\n      scoped_refptr<EntryImpl> entry;\n      result_ = backend_->SyncOpenEntry(key_, &entry);\n      *entry_ptr_ = LeakEntryImpl(std::move(entry));\n      break;\n    }\n    case OP_CREATE: {\n      scoped_refptr<EntryImpl> entry;\n      result_ = backend_->SyncCreateEntry(key_, &entry);\n      *entry_ptr_ = LeakEntryImpl(std::move(entry));\n      break;\n    }\n    case OP_DOOM:\n      result_ = backend_->SyncDoomEntry(key_);\n      break;\n    case OP_DOOM_ALL:\n      result_ = backend_->SyncDoomAllEntries();\n      break;\n    case OP_DOOM_BETWEEN:\n      result_ = backend_->SyncDoomEntriesBetween(initial_time_, end_time_);\n      break;\n    case OP_DOOM_SINCE:\n      result_ = backend_->SyncDoomEntriesSince(initial_time_);\n      break;\n    case OP_SIZE_ALL:\n      result_ = backend_->SyncCalculateSizeOfAllEntries();\n      break;\n    case OP_OPEN_NEXT: {\n      scoped_refptr<EntryImpl> entry;\n      result_ = backend_->SyncOpenNextEntry(iterator_, &entry);\n      *entry_ptr_ = LeakEntryImpl(std::move(entry));\n      break;\n    }\n    case OP_END_ENUMERATION:\n      backend_->SyncEndEnumeration(std::move(scoped_iterator_));\n      result_ = net::OK;\n      break;\n    case OP_ON_EXTERNAL_CACHE_HIT:\n      backend_->SyncOnExternalCacheHit(key_);\n      result_ = net::OK;\n      break;\n    case OP_CLOSE_ENTRY:\n      entry_->Release();\n      result_ = net::OK;\n      break;\n    case OP_DOOM_ENTRY:\n      entry_->DoomImpl();\n      result_ = net::OK;\n      break;\n    case OP_FLUSH_QUEUE:\n      result_ = net::OK;\n      break;\n    case OP_RUN_TASK:\n      task_.Run();\n      result_ = net::OK;\n      break;\n    default:\n      NOTREACHED() << \"Invalid Operation\";\n      result_ = net::ERR_UNEXPECTED;\n   }\n   DCHECK_NE(net::ERR_IO_PENDING, result_);\n   NotifyController();\n  backend_->OnSyncBackendOpComplete();\n }\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 154,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2011-2877",
    "code_before_change": " PassOwnPtr<GraphicsContext> UpdateAtlas::beginPaintingOnAvailableBuffer(ShareableSurface::Handle& handle, const WebCore::IntSize& size, IntPoint& offset)\n {\n     buildLayoutIfNeeded();\n     IntRect rect = m_areaAllocator->allocate(size);\n \n    if (rect.isEmpty())\n        return PassOwnPtr<GraphicsContext>();\n\n    if (!m_surface->createHandle(handle))\n        return PassOwnPtr<WebCore::GraphicsContext>();\n\n    offset = rect.location();\n    OwnPtr<GraphicsContext> graphicsContext = m_surface->createGraphicsContext(rect);\n\n    if (flags() & ShareableBitmap::SupportsAlpha) {\n        graphicsContext->setCompositeOperation(CompositeCopy);\n        graphicsContext->fillRect(IntRect(IntPoint::zero(), size), Color::transparent, ColorSpaceDeviceRGB);\n        graphicsContext->setCompositeOperation(CompositeSourceOver);\n    }\n\n    return graphicsContext.release();\n}\n",
    "code_after_change": " PassOwnPtr<GraphicsContext> UpdateAtlas::beginPaintingOnAvailableBuffer(ShareableSurface::Handle& handle, const WebCore::IntSize& size, IntPoint& offset)\n {\n    m_inactivityInSeconds = 0;\n     buildLayoutIfNeeded();\n     IntRect rect = m_areaAllocator->allocate(size);\n \n    if (rect.isEmpty())\n        return PassOwnPtr<GraphicsContext>();\n\n    if (!m_surface->createHandle(handle))\n        return PassOwnPtr<WebCore::GraphicsContext>();\n\n    offset = rect.location();\n    OwnPtr<GraphicsContext> graphicsContext = m_surface->createGraphicsContext(rect);\n\n    if (flags() & ShareableBitmap::SupportsAlpha) {\n        graphicsContext->setCompositeOperation(CompositeCopy);\n        graphicsContext->fillRect(IntRect(IntPoint::zero(), size), Color::transparent, ColorSpaceDeviceRGB);\n        graphicsContext->setCompositeOperation(CompositeSourceOver);\n    }\n\n    return graphicsContext.release();\n}\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 155,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2019-15166",
    "code_before_change": "lmp_print_data_link_subobjs(netdissect_options *ndo, const u_char *obj_tptr,\n                            int total_subobj_len, int offset)\n{\n    int hexdump = FALSE;\n    int subobj_type, subobj_len;\n\n    union { /* int to float conversion buffer */\n        float f;\n        uint32_t i;\n     } bw;\n \n     while (total_subobj_len > 0 && hexdump == FALSE ) {\n \tsubobj_type = EXTRACT_8BITS(obj_tptr + offset);\n \tsubobj_len  = EXTRACT_8BITS(obj_tptr + offset + 1);\n \tND_PRINT((ndo, \"\\n\\t    Subobject, Type: %s (%u), Length: %u\",\n\t\ttok2str(lmp_data_link_subobj,\n\t\t\t\"Unknown\",\n\t\t\tsubobj_type),\n\t\t\tsubobj_type,\n\t\t\tsubobj_len));\n\tif (subobj_len < 4) {\n\t    ND_PRINT((ndo, \" (too short)\"));\n\t    break;\n\t}\n\tif ((subobj_len % 4) != 0) {\n\t    ND_PRINT((ndo, \" (not a multiple of 4)\"));\n\t    break;\n\t}\n\tif (total_subobj_len < subobj_len) {\n\t    ND_PRINT((ndo, \" (goes past the end of the object)\"));\n\t    break;\n \t}\n \tswitch(subobj_type) {\n \tcase INT_SWITCHING_TYPE_SUBOBJ:\n \t    ND_PRINT((ndo, \"\\n\\t      Switching Type: %s (%u)\",\n \t\ttok2str(gmpls_switch_cap_values,\n \t\t\t\"Unknown\",\n \t\t\tEXTRACT_8BITS(obj_tptr + offset + 2)),\n \t\t\tEXTRACT_8BITS(obj_tptr + offset + 2)));\n \t    ND_PRINT((ndo, \"\\n\\t      Encoding Type: %s (%u)\",\n \t\ttok2str(gmpls_encoding_values,\n \t\t\t\"Unknown\",\n\t\t\tEXTRACT_8BITS(obj_tptr + offset + 3)),\n\t\t\tEXTRACT_8BITS(obj_tptr + offset + 3)));\n\t    ND_TCHECK_32BITS(obj_tptr + offset + 4);\n \t    bw.i = EXTRACT_32BITS(obj_tptr+offset+4);\n \t    ND_PRINT((ndo, \"\\n\\t      Min Reservable Bandwidth: %.3f Mbps\",\n                 bw.f*8/1000000));\n \t    bw.i = EXTRACT_32BITS(obj_tptr+offset+8);\n \t    ND_PRINT((ndo, \"\\n\\t      Max Reservable Bandwidth: %.3f Mbps\",\n                 bw.f*8/1000000));\n \t    break;\n \tcase WAVELENGTH_SUBOBJ:\n \t    ND_PRINT((ndo, \"\\n\\t      Wavelength: %u\",\n \t\tEXTRACT_32BITS(obj_tptr+offset+4)));\n \t    break;\n\tdefault:\n\t    /* Any Unknown Subobject ==> Exit loop */\n\t    hexdump=TRUE;\n\t    break;\n\t}\n\ttotal_subobj_len-=subobj_len;\n\toffset+=subobj_len;\n    }\n    return (hexdump);\ntrunc:\n    return -1;\n}\n",
    "code_after_change": "lmp_print_data_link_subobjs(netdissect_options *ndo, const u_char *obj_tptr,\n                            int total_subobj_len, int offset)\n{\n    int hexdump = FALSE;\n    int subobj_type, subobj_len;\n\n    union { /* int to float conversion buffer */\n        float f;\n        uint32_t i;\n     } bw;\n \n     while (total_subobj_len > 0 && hexdump == FALSE ) {\n\tND_TCHECK_16BITS(obj_tptr + offset);\n \tsubobj_type = EXTRACT_8BITS(obj_tptr + offset);\n \tsubobj_len  = EXTRACT_8BITS(obj_tptr + offset + 1);\n \tND_PRINT((ndo, \"\\n\\t    Subobject, Type: %s (%u), Length: %u\",\n\t\ttok2str(lmp_data_link_subobj,\n\t\t\t\"Unknown\",\n\t\t\tsubobj_type),\n\t\t\tsubobj_type,\n\t\t\tsubobj_len));\n\tif (subobj_len < 4) {\n\t    ND_PRINT((ndo, \" (too short)\"));\n\t    break;\n\t}\n\tif ((subobj_len % 4) != 0) {\n\t    ND_PRINT((ndo, \" (not a multiple of 4)\"));\n\t    break;\n\t}\n\tif (total_subobj_len < subobj_len) {\n\t    ND_PRINT((ndo, \" (goes past the end of the object)\"));\n\t    break;\n \t}\n \tswitch(subobj_type) {\n \tcase INT_SWITCHING_TYPE_SUBOBJ:\n\t    ND_TCHECK_8BITS(obj_tptr + offset + 2);\n \t    ND_PRINT((ndo, \"\\n\\t      Switching Type: %s (%u)\",\n \t\ttok2str(gmpls_switch_cap_values,\n \t\t\t\"Unknown\",\n \t\t\tEXTRACT_8BITS(obj_tptr + offset + 2)),\n \t\t\tEXTRACT_8BITS(obj_tptr + offset + 2)));\n\t    ND_TCHECK_8BITS(obj_tptr + offset + 3);\n \t    ND_PRINT((ndo, \"\\n\\t      Encoding Type: %s (%u)\",\n \t\ttok2str(gmpls_encoding_values,\n \t\t\t\"Unknown\",\n\t\t\tEXTRACT_8BITS(obj_tptr + offset + 3)),\n\t\t\tEXTRACT_8BITS(obj_tptr + offset + 3)));\n\t    ND_TCHECK_32BITS(obj_tptr + offset + 4);\n \t    bw.i = EXTRACT_32BITS(obj_tptr+offset+4);\n \t    ND_PRINT((ndo, \"\\n\\t      Min Reservable Bandwidth: %.3f Mbps\",\n                 bw.f*8/1000000));\n\t    ND_TCHECK_32BITS(obj_tptr + offset + 8);\n \t    bw.i = EXTRACT_32BITS(obj_tptr+offset+8);\n \t    ND_PRINT((ndo, \"\\n\\t      Max Reservable Bandwidth: %.3f Mbps\",\n                 bw.f*8/1000000));\n \t    break;\n \tcase WAVELENGTH_SUBOBJ:\n\t    ND_TCHECK_32BITS(obj_tptr + offset + 4);\n \t    ND_PRINT((ndo, \"\\n\\t      Wavelength: %u\",\n \t\tEXTRACT_32BITS(obj_tptr+offset+4)));\n \t    break;\n\tdefault:\n\t    /* Any Unknown Subobject ==> Exit loop */\n\t    hexdump=TRUE;\n\t    break;\n\t}\n\ttotal_subobj_len-=subobj_len;\n\toffset+=subobj_len;\n    }\n    return (hexdump);\ntrunc:\n    return -1;\n}\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 157,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2015-5589",
    "code_before_change": " PHP_METHOD(Phar, buildFromDirectory)\n{\n\tchar *dir, *error, *regex = NULL;\n\tint dir_len, regex_len = 0;\n\tzend_bool apply_reg = 0;\n\tzval arg, arg2, *iter, *iteriter, *regexiter = NULL;\n\tstruct _phar_t pass;\n\n\tPHAR_ARCHIVE_OBJECT();\n\n\tif (PHAR_G(readonly) && !phar_obj->arc.archive->is_data) {\n\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC,\n\t\t\t\"Cannot write to archive - write operations restricted by INI setting\");\n\t\treturn;\n\t}\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|s\", &dir, &dir_len, &regex, &regex_len) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tMAKE_STD_ZVAL(iter);\n\n\tif (SUCCESS != object_init_ex(iter, spl_ce_RecursiveDirectoryIterator)) {\n\t\tzval_ptr_dtor(&iter);\n\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"Unable to instantiate directory iterator for %s\", phar_obj->arc.archive->fname);\n\t\tRETURN_FALSE;\n\t}\n\n\tINIT_PZVAL(&arg);\n\tZVAL_STRINGL(&arg, dir, dir_len, 0);\n\tINIT_PZVAL(&arg2);\n#if PHP_VERSION_ID < 50300\n\tZVAL_LONG(&arg2, 0);\n#else\n        ZVAL_LONG(&arg2, SPL_FILE_DIR_SKIPDOTS|SPL_FILE_DIR_UNIXPATHS);\n #endif\n \n       zend_call_method_with_2_params(&iter, spl_ce_RecursiveDirectoryIterator, \n                        &spl_ce_RecursiveDirectoryIterator->constructor, \"__construct\", NULL, &arg, &arg2);\n \n        if (EG(exception)) {\n\t\tzval_ptr_dtor(&iter);\n\t\tRETURN_FALSE;\n\t}\n\n\tMAKE_STD_ZVAL(iteriter);\n\n\tif (SUCCESS != object_init_ex(iteriter, spl_ce_RecursiveIteratorIterator)) {\n\t\tzval_ptr_dtor(&iter);\n\t\tzval_ptr_dtor(&iteriter);\n\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"Unable to instantiate directory iterator for %s\", phar_obj->arc.archive->fname);\n                RETURN_FALSE;\n        }\n \n       zend_call_method_with_1_params(&iteriter, spl_ce_RecursiveIteratorIterator, \n                        &spl_ce_RecursiveIteratorIterator->constructor, \"__construct\", NULL, iter);\n \n        if (EG(exception)) {\n\t\tzval_ptr_dtor(&iter);\n\t\tzval_ptr_dtor(&iteriter);\n\t\tRETURN_FALSE;\n\t}\n\n\tzval_ptr_dtor(&iter);\n\n\tif (regex_len > 0) {\n\t\tapply_reg = 1;\n\t\tMAKE_STD_ZVAL(regexiter);\n\n\t\tif (SUCCESS != object_init_ex(regexiter, spl_ce_RegexIterator)) {\n\t\t\tzval_ptr_dtor(&iteriter);\n\t\t\tzval_dtor(regexiter);\n\t\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"Unable to instantiate regex iterator for %s\", phar_obj->arc.archive->fname);\n\t\t\tRETURN_FALSE;\n\t\t}\n\n                INIT_PZVAL(&arg2);\n                ZVAL_STRINGL(&arg2, regex, regex_len, 0);\n \n               zend_call_method_with_2_params(&regexiter, spl_ce_RegexIterator, \n                        &spl_ce_RegexIterator->constructor, \"__construct\", NULL, iteriter, &arg2);\n        }\n \n\tarray_init(return_value);\n\n\tpass.c = apply_reg ? Z_OBJCE_P(regexiter) : Z_OBJCE_P(iteriter);\n\tpass.p = phar_obj;\n\tpass.b = dir;\n\tpass.l = dir_len;\n\tpass.count = 0;\n\tpass.ret = return_value;\n\tpass.fp = php_stream_fopen_tmpfile();\n\tif (pass.fp == NULL) {\n\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"phar \\\"%s\\\" unable to create temporary file\", phar_obj->arc.archive->fname);\n\t\treturn;\n\t}\n\n\tif (phar_obj->arc.archive->is_persistent && FAILURE == phar_copy_on_write(&(phar_obj->arc.archive) TSRMLS_CC)) {\n\t\tzval_ptr_dtor(&iteriter);\n\t\tif (apply_reg) {\n\t\t\tzval_ptr_dtor(&regexiter);\n\t\t}\n\t\tphp_stream_close(pass.fp);\n\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"phar \\\"%s\\\" is persistent, unable to copy on write\", phar_obj->arc.archive->fname);\n\t\treturn;\n\t}\n\n\tif (SUCCESS == spl_iterator_apply((apply_reg ? regexiter : iteriter), (spl_iterator_apply_func_t) phar_build, (void *) &pass TSRMLS_CC)) {\n\t\tzval_ptr_dtor(&iteriter);\n\n\t\tif (apply_reg) {\n\t\t\tzval_ptr_dtor(&regexiter);\n\t\t}\n\n\t\tphar_obj->arc.archive->ufp = pass.fp;\n\t\tphar_flush(phar_obj->arc.archive, 0, 0, 0, &error TSRMLS_CC);\n\n\t\tif (error) {\n\t\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"%s\", error);\n\t\t\tefree(error);\n\t\t}\n\n\t} else {\n\t\tzval_ptr_dtor(&iteriter);\n\t\tif (apply_reg) {\n\t\t\tzval_ptr_dtor(&regexiter);\n\t\t}\n\t\tphp_stream_close(pass.fp);\n\t}\n}\n",
    "code_after_change": " PHP_METHOD(Phar, buildFromDirectory)\n{\n\tchar *dir, *error, *regex = NULL;\n\tint dir_len, regex_len = 0;\n\tzend_bool apply_reg = 0;\n\tzval arg, arg2, *iter, *iteriter, *regexiter = NULL;\n\tstruct _phar_t pass;\n\n\tPHAR_ARCHIVE_OBJECT();\n\n\tif (PHAR_G(readonly) && !phar_obj->arc.archive->is_data) {\n\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC,\n\t\t\t\"Cannot write to archive - write operations restricted by INI setting\");\n\t\treturn;\n\t}\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|s\", &dir, &dir_len, &regex, &regex_len) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tMAKE_STD_ZVAL(iter);\n\n\tif (SUCCESS != object_init_ex(iter, spl_ce_RecursiveDirectoryIterator)) {\n\t\tzval_ptr_dtor(&iter);\n\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"Unable to instantiate directory iterator for %s\", phar_obj->arc.archive->fname);\n\t\tRETURN_FALSE;\n\t}\n\n\tINIT_PZVAL(&arg);\n\tZVAL_STRINGL(&arg, dir, dir_len, 0);\n\tINIT_PZVAL(&arg2);\n#if PHP_VERSION_ID < 50300\n\tZVAL_LONG(&arg2, 0);\n#else\n        ZVAL_LONG(&arg2, SPL_FILE_DIR_SKIPDOTS|SPL_FILE_DIR_UNIXPATHS);\n #endif\n \n       zend_call_method_with_2_params(&iter, spl_ce_RecursiveDirectoryIterator,\n                        &spl_ce_RecursiveDirectoryIterator->constructor, \"__construct\", NULL, &arg, &arg2);\n \n        if (EG(exception)) {\n\t\tzval_ptr_dtor(&iter);\n\t\tRETURN_FALSE;\n\t}\n\n\tMAKE_STD_ZVAL(iteriter);\n\n\tif (SUCCESS != object_init_ex(iteriter, spl_ce_RecursiveIteratorIterator)) {\n\t\tzval_ptr_dtor(&iter);\n\t\tzval_ptr_dtor(&iteriter);\n\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"Unable to instantiate directory iterator for %s\", phar_obj->arc.archive->fname);\n                RETURN_FALSE;\n        }\n \n       zend_call_method_with_1_params(&iteriter, spl_ce_RecursiveIteratorIterator,\n                        &spl_ce_RecursiveIteratorIterator->constructor, \"__construct\", NULL, iter);\n \n        if (EG(exception)) {\n\t\tzval_ptr_dtor(&iter);\n\t\tzval_ptr_dtor(&iteriter);\n\t\tRETURN_FALSE;\n\t}\n\n\tzval_ptr_dtor(&iter);\n\n\tif (regex_len > 0) {\n\t\tapply_reg = 1;\n\t\tMAKE_STD_ZVAL(regexiter);\n\n\t\tif (SUCCESS != object_init_ex(regexiter, spl_ce_RegexIterator)) {\n\t\t\tzval_ptr_dtor(&iteriter);\n\t\t\tzval_dtor(regexiter);\n\t\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"Unable to instantiate regex iterator for %s\", phar_obj->arc.archive->fname);\n\t\t\tRETURN_FALSE;\n\t\t}\n\n                INIT_PZVAL(&arg2);\n                ZVAL_STRINGL(&arg2, regex, regex_len, 0);\n \n               zend_call_method_with_2_params(&regexiter, spl_ce_RegexIterator,\n                        &spl_ce_RegexIterator->constructor, \"__construct\", NULL, iteriter, &arg2);\n        }\n \n\tarray_init(return_value);\n\n\tpass.c = apply_reg ? Z_OBJCE_P(regexiter) : Z_OBJCE_P(iteriter);\n\tpass.p = phar_obj;\n\tpass.b = dir;\n\tpass.l = dir_len;\n\tpass.count = 0;\n\tpass.ret = return_value;\n\tpass.fp = php_stream_fopen_tmpfile();\n\tif (pass.fp == NULL) {\n\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"phar \\\"%s\\\" unable to create temporary file\", phar_obj->arc.archive->fname);\n\t\treturn;\n\t}\n\n\tif (phar_obj->arc.archive->is_persistent && FAILURE == phar_copy_on_write(&(phar_obj->arc.archive) TSRMLS_CC)) {\n\t\tzval_ptr_dtor(&iteriter);\n\t\tif (apply_reg) {\n\t\t\tzval_ptr_dtor(&regexiter);\n\t\t}\n\t\tphp_stream_close(pass.fp);\n\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"phar \\\"%s\\\" is persistent, unable to copy on write\", phar_obj->arc.archive->fname);\n\t\treturn;\n\t}\n\n\tif (SUCCESS == spl_iterator_apply((apply_reg ? regexiter : iteriter), (spl_iterator_apply_func_t) phar_build, (void *) &pass TSRMLS_CC)) {\n\t\tzval_ptr_dtor(&iteriter);\n\n\t\tif (apply_reg) {\n\t\t\tzval_ptr_dtor(&regexiter);\n\t\t}\n\n\t\tphar_obj->arc.archive->ufp = pass.fp;\n\t\tphar_flush(phar_obj->arc.archive, 0, 0, 0, &error TSRMLS_CC);\n\n\t\tif (error) {\n\t\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"%s\", error);\n\t\t\tefree(error);\n\t\t}\n\n\t} else {\n\t\tzval_ptr_dtor(&iteriter);\n\t\tif (apply_reg) {\n\t\t\tzval_ptr_dtor(&regexiter);\n\t\t}\n\t\tphp_stream_close(pass.fp);\n\t}\n}\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 203,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2016-7417",
    "code_before_change": "static zval **spl_array_get_dimension_ptr_ptr(int check_inherited, zval *object, zval *offset, int type TSRMLS_DC) /* {{{ */\n{\n\tspl_array_object *intern = (spl_array_object*)zend_object_store_get_object(object TSRMLS_CC);\n\tzval **retval;\n\tchar *key;\n\tuint len;\n \tlong index;\n \tHashTable *ht = spl_array_get_hash_table(intern, 0 TSRMLS_CC);\n \n\tif (!offset) {\n \t\treturn &EG(uninitialized_zval_ptr);\n \t}\n \n\tif ((type == BP_VAR_W || type == BP_VAR_RW) && (ht->nApplyCount > 0)) {\n\t\tzend_error(E_WARNING, \"Modification of ArrayObject during sorting is prohibited\");\n\t\treturn &EG(error_zval_ptr);;\n\t}\n\n\tswitch (Z_TYPE_P(offset)) {\n\tcase IS_STRING:\n\t\tkey = Z_STRVAL_P(offset);\n\t\tlen = Z_STRLEN_P(offset) + 1;\nstring_offest:\n\t\tif (zend_symtable_find(ht, key, len, (void **) &retval) == FAILURE) {\n\t\t\tswitch (type) {\n\t\t\t\tcase BP_VAR_R:\n\t\t\t\t\tzend_error(E_NOTICE, \"Undefined index: %s\", key);\n\t\t\t\tcase BP_VAR_UNSET:\n\t\t\t\tcase BP_VAR_IS:\n\t\t\t\t\tretval = &EG(uninitialized_zval_ptr);\n\t\t\t\t\tbreak;\n\t\t\t\tcase BP_VAR_RW:\n\t\t\t\t\tzend_error(E_NOTICE,\"Undefined index: %s\", key);\n\t\t\t\tcase BP_VAR_W: {\n\t\t\t\t    zval *value;\n\t\t\t\t    ALLOC_INIT_ZVAL(value);\n\t\t\t\t    zend_symtable_update(ht, key, len, (void**)&value, sizeof(void*), (void **)&retval);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn retval;\n\tcase IS_NULL:\n\t\tkey = \"\";\n\t\tlen = 1;\n\t\tgoto string_offest;\n\tcase IS_RESOURCE:\n\t\tzend_error(E_STRICT, \"Resource ID#%ld used as offset, casting to integer (%ld)\", Z_LVAL_P(offset), Z_LVAL_P(offset));\n\tcase IS_DOUBLE:\n\tcase IS_BOOL:\n\tcase IS_LONG:\n\t\tif (offset->type == IS_DOUBLE) {\n\t\t\tindex = (long)Z_DVAL_P(offset);\n\t\t} else {\n\t\t\tindex = Z_LVAL_P(offset);\n\t\t}\n\t\tif (zend_hash_index_find(ht, index, (void **) &retval) == FAILURE) {\n\t\t\tswitch (type) {\n\t\t\t\tcase BP_VAR_R:\n\t\t\t\t\tzend_error(E_NOTICE, \"Undefined offset: %ld\", index);\n\t\t\t\tcase BP_VAR_UNSET:\n\t\t\t\tcase BP_VAR_IS:\n\t\t\t\t\tretval = &EG(uninitialized_zval_ptr);\n\t\t\t\t\tbreak;\n\t\t\t\tcase BP_VAR_RW:\n\t\t\t\t\tzend_error(E_NOTICE, \"Undefined offset: %ld\", index);\n\t\t\t\tcase BP_VAR_W: {\n\t\t\t\t    zval *value;\n\t\t\t\t    ALLOC_INIT_ZVAL(value);\n\t\t\t\t\tzend_hash_index_update(ht, index, (void**)&value, sizeof(void*), (void **)&retval);\n\t\t\t   }\n\t\t\t}\n\t\t}\n\t\treturn retval;\n\tdefault:\n\t\tzend_error(E_WARNING, \"Illegal offset type\");\n\t\treturn (type == BP_VAR_W || type == BP_VAR_RW) ?\n\t\t\t&EG(error_zval_ptr) : &EG(uninitialized_zval_ptr);\n\t}\n} /* }}} */\n",
    "code_after_change": "static zval **spl_array_get_dimension_ptr_ptr(int check_inherited, zval *object, zval *offset, int type TSRMLS_DC) /* {{{ */\n{\n\tspl_array_object *intern = (spl_array_object*)zend_object_store_get_object(object TSRMLS_CC);\n\tzval **retval;\n\tchar *key;\n\tuint len;\n \tlong index;\n \tHashTable *ht = spl_array_get_hash_table(intern, 0 TSRMLS_CC);\n \n\tif (!offset || !ht) {\n \t\treturn &EG(uninitialized_zval_ptr);\n \t}\n \n\tif ((type == BP_VAR_W || type == BP_VAR_RW) && (ht->nApplyCount > 0)) {\n\t\tzend_error(E_WARNING, \"Modification of ArrayObject during sorting is prohibited\");\n\t\treturn &EG(error_zval_ptr);;\n\t}\n\n\tswitch (Z_TYPE_P(offset)) {\n\tcase IS_STRING:\n\t\tkey = Z_STRVAL_P(offset);\n\t\tlen = Z_STRLEN_P(offset) + 1;\nstring_offest:\n\t\tif (zend_symtable_find(ht, key, len, (void **) &retval) == FAILURE) {\n\t\t\tswitch (type) {\n\t\t\t\tcase BP_VAR_R:\n\t\t\t\t\tzend_error(E_NOTICE, \"Undefined index: %s\", key);\n\t\t\t\tcase BP_VAR_UNSET:\n\t\t\t\tcase BP_VAR_IS:\n\t\t\t\t\tretval = &EG(uninitialized_zval_ptr);\n\t\t\t\t\tbreak;\n\t\t\t\tcase BP_VAR_RW:\n\t\t\t\t\tzend_error(E_NOTICE,\"Undefined index: %s\", key);\n\t\t\t\tcase BP_VAR_W: {\n\t\t\t\t    zval *value;\n\t\t\t\t    ALLOC_INIT_ZVAL(value);\n\t\t\t\t    zend_symtable_update(ht, key, len, (void**)&value, sizeof(void*), (void **)&retval);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn retval;\n\tcase IS_NULL:\n\t\tkey = \"\";\n\t\tlen = 1;\n\t\tgoto string_offest;\n\tcase IS_RESOURCE:\n\t\tzend_error(E_STRICT, \"Resource ID#%ld used as offset, casting to integer (%ld)\", Z_LVAL_P(offset), Z_LVAL_P(offset));\n\tcase IS_DOUBLE:\n\tcase IS_BOOL:\n\tcase IS_LONG:\n\t\tif (offset->type == IS_DOUBLE) {\n\t\t\tindex = (long)Z_DVAL_P(offset);\n\t\t} else {\n\t\t\tindex = Z_LVAL_P(offset);\n\t\t}\n\t\tif (zend_hash_index_find(ht, index, (void **) &retval) == FAILURE) {\n\t\t\tswitch (type) {\n\t\t\t\tcase BP_VAR_R:\n\t\t\t\t\tzend_error(E_NOTICE, \"Undefined offset: %ld\", index);\n\t\t\t\tcase BP_VAR_UNSET:\n\t\t\t\tcase BP_VAR_IS:\n\t\t\t\t\tretval = &EG(uninitialized_zval_ptr);\n\t\t\t\t\tbreak;\n\t\t\t\tcase BP_VAR_RW:\n\t\t\t\t\tzend_error(E_NOTICE, \"Undefined offset: %ld\", index);\n\t\t\t\tcase BP_VAR_W: {\n\t\t\t\t    zval *value;\n\t\t\t\t    ALLOC_INIT_ZVAL(value);\n\t\t\t\t\tzend_hash_index_update(ht, index, (void**)&value, sizeof(void*), (void **)&retval);\n\t\t\t   }\n\t\t\t}\n\t\t}\n\t\treturn retval;\n\tdefault:\n\t\tzend_error(E_WARNING, \"Illegal offset type\");\n\t\treturn (type == BP_VAR_W || type == BP_VAR_RW) ?\n\t\t\t&EG(error_zval_ptr) : &EG(uninitialized_zval_ptr);\n\t}\n} /* }}} */\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 217,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2016-3756",
    "code_before_change": " int res_inverse(vorbis_dsp_state *vd,vorbis_info_residue *info,\n\t\togg_int32_t **in,int *nonzero,int ch){\n \n   int i,j,k,s,used=0;\n   codec_setup_info     *ci=(codec_setup_info *)vd->vi->codec_setup;\n  codebook *phrasebook=ci->book_param+info->groupbook;\n int samples_per_partition=info->grouping;\n int partitions_per_word=phrasebook->dim;\n int pcmend=ci->blocksizes[vd->W];\n\n if(info->type<2){\n int max=pcmend>>1;\n int end=(info->end<max?info->end:max);\n int n=end-info->begin;\n\n if(n>0){\n int partvals=n/samples_per_partition;\n\n       int partwords=(partvals+partitions_per_word-1)/partitions_per_word;\n \n       for(i=0;i<ch;i++)\n\tif(nonzero[i])\n\t  in[used++]=in[i];\n       ch=used;\n \n       if(used){\n \n\tchar **partword=(char **)alloca(ch*sizeof(*partword));\n\tfor(j=0;j<ch;j++)\n\t  partword[j]=(char *)alloca(partwords*partitions_per_word*\n\t\t\t\t     sizeof(*partword[j]));\n \n\tfor(s=0;s<info->stages;s++){\n \n\t  for(i=0;i<partvals;){\n\t    if(s==0){\n\t      /* fetch the partition word for each channel */\n \n\t      partword[0][i+partitions_per_word-1]=1;\n\t      for(k=partitions_per_word-2;k>=0;k--)\n\t\tpartword[0][i+k]=partword[0][i+k+1]*info->partitions;\n \n\t      for(j=1;j<ch;j++)\n\t\tfor(k=partitions_per_word-1;k>=0;k--)\n\t\t  partword[j][i+k]=partword[j-1][i+k];\n \n\t      for(j=0;j<ch;j++){\n\t\tint temp=vorbis_book_decode(phrasebook,&vd->opb);\n\t\tif(temp==-1)goto eopbreak;\n \n\t\t/* this can be done quickly in assembly due to the quotient\n\t\t   always being at most six bits */\n\t\tfor(k=0;k<partitions_per_word;k++){\n\t\t  ogg_uint32_t div=partword[j][i+k];\n\t\t  partword[j][i+k]=temp/div;\n\t\t  temp-=partword[j][i+k]*div;\n\t\t}\n \n\t      }\n\t    }\n \n\t    /* now we decode residual values for the partitions */\n\t    for(k=0;k<partitions_per_word && i<partvals;k++,i++)\n\t      for(j=0;j<ch;j++){\n\t\tlong offset=info->begin+i*samples_per_partition;\n\t\tif(info->stagemasks[(int)partword[j][i]]&(1<<s)){\n\t\t  codebook *stagebook=ci->book_param+\n\t\t    info->stagebooks[(partword[j][i]<<3)+s];\n\t\t  if(info->type){\n\t\t    if(vorbis_book_decodev_add(stagebook,in[j]+offset,&vd->opb,\n\t\t\t\t\t       samples_per_partition,-8)==-1)\n\t\t      goto eopbreak;\n\t\t  }else{\n\t\t    if(vorbis_book_decodevs_add(stagebook,in[j]+offset,&vd->opb,\n\t\t\t\t\t\tsamples_per_partition,-8)==-1)\n\t\t      goto eopbreak;\n\t\t  }\n\t\t}\n\t      }\n\t  }\n\t}\n       }\n     }\n   }else{\n int max=(pcmend*ch)>>1;\n int end=(info->end<max?info->end:max);\n int n=end-info->begin;\n\n if(n>0){\n int partvals=n/samples_per_partition;\n\n       int partwords=(partvals+partitions_per_word-1)/partitions_per_word;\n \n       char *partword=\n\t(char *)alloca(partwords*partitions_per_word*sizeof(*partword));\n       int beginoff=info->begin/ch;\n \n       for(i=0;i<ch;i++)if(nonzero[i])break;\n if(i==ch)return(0); /* no nonzero vectors */\n\n      samples_per_partition/=ch;\n\n for(s=0;s<info->stages;s++){\n for(i=0;i<partvals;){\n\n if(s==0){\n int temp;\n\t    partword[i+partitions_per_word-1]=1;\n for(k=partitions_per_word-2;k>=0;k--)\n\t      partword[i+k]=partword[i+k+1]*info->partitions;\n\n /* fetch the partition word */\n\t    temp=vorbis_book_decode(phrasebook,&vd->opb);\n if(temp==-1)goto eopbreak;\n\n /* this can be done quickly in assembly due to the quotient\n\t       always being at most six bits */\n for(k=0;k<partitions_per_word;k++){\n ogg_uint32_t div=partword[i+k];\n\t      partword[i+k]=temp/div;\n\t      temp-=partword[i+k]*div;\n }\n }\n\n /* now we decode residual values for the partitions */\n for(k=0;k<partitions_per_word && i<partvals;k++,i++)\n if(info->stagemasks[(int)partword[i]]&(1<<s)){\n\t      codebook *stagebook=ci->book_param+\n\t\tinfo->stagebooks[(partword[i]<<3)+s];\n if(vorbis_book_decodevv_add(stagebook,in,\n\t\t\t\t\t  i*samples_per_partition+beginoff,ch,\n &vd->opb,\n\t\t\t\t\t  samples_per_partition,-8)==-1)\n goto eopbreak;\n }\n }\n }\n }\n }\n eopbreak:\n\n return 0;\n}\n",
    "code_after_change": " int res_inverse(vorbis_dsp_state *vd,vorbis_info_residue *info,\n                ogg_int32_t **in,int *nonzero,int ch){\n \n   int i,j,k,s,used=0;\n   codec_setup_info     *ci=(codec_setup_info *)vd->vi->codec_setup;\n  codebook *phrasebook=ci->book_param+info->groupbook;\n int samples_per_partition=info->grouping;\n int partitions_per_word=phrasebook->dim;\n int pcmend=ci->blocksizes[vd->W];\n\n if(info->type<2){\n int max=pcmend>>1;\n int end=(info->end<max?info->end:max);\n int n=end-info->begin;\n\n if(n>0){\n int partvals=n/samples_per_partition;\n\n       int partwords=(partvals+partitions_per_word-1)/partitions_per_word;\n \n       for(i=0;i<ch;i++)\n        if(nonzero[i])\n          in[used++]=in[i];\n       ch=used;\n \n       if(used){\n \n        char **partword=(char **)alloca(ch*sizeof(*partword));\n        for(j=0;j<ch;j++)\n          partword[j]=(char *)alloca(partwords*partitions_per_word*\n                                     sizeof(*partword[j]));\n \n        for(s=0;s<info->stages;s++){\n \n          for(i=0;i<partvals;){\n            if(s==0){\n              /* fetch the partition word for each channel */\n \n              partword[0][i+partitions_per_word-1]=1;\n              for(k=partitions_per_word-2;k>=0;k--)\n                partword[0][i+k]=partword[0][i+k+1]*info->partitions;\n \n              for(j=1;j<ch;j++)\n                for(k=partitions_per_word-1;k>=0;k--)\n                  partword[j][i+k]=partword[j-1][i+k];\n \n              for(j=0;j<ch;j++){\n                int temp=vorbis_book_decode(phrasebook,&vd->opb);\n                if(temp==-1)goto eopbreak;\n \n                /* this can be done quickly in assembly due to the quotient\n                   always being at most six bits */\n                for(k=0;k<partitions_per_word;k++){\n                  ogg_uint32_t div=partword[j][i+k];\n                  partword[j][i+k]=temp/div;\n                  temp-=partword[j][i+k]*div;\n                }\n \n              }\n            }\n \n            /* now we decode residual values for the partitions */\n            for(k=0;k<partitions_per_word && i<partvals;k++,i++)\n              for(j=0;j<ch;j++){\n                long offset=info->begin+i*samples_per_partition;\n                int idx = (int)partword[j][i];\n                if(idx < info->partitions && info->stagemasks[idx]&(1<<s)){\n                  codebook *stagebook=ci->book_param+\n                    info->stagebooks[(partword[j][i]<<3)+s];\n                  if(info->type){\n                    if(vorbis_book_decodev_add(stagebook,in[j]+offset,&vd->opb,\n                                               samples_per_partition,-8)==-1)\n                      goto eopbreak;\n                  }else{\n                    if(vorbis_book_decodevs_add(stagebook,in[j]+offset,&vd->opb,\n                                                samples_per_partition,-8)==-1)\n                      goto eopbreak;\n                  }\n                }\n              }\n          }\n        }\n       }\n     }\n   }else{\n int max=(pcmend*ch)>>1;\n int end=(info->end<max?info->end:max);\n int n=end-info->begin;\n\n if(n>0){\n int partvals=n/samples_per_partition;\n\n       int partwords=(partvals+partitions_per_word-1)/partitions_per_word;\n \n       char *partword=\n        (char *)alloca(partwords*partitions_per_word*sizeof(*partword));\n       int beginoff=info->begin/ch;\n \n       for(i=0;i<ch;i++)if(nonzero[i])break;\n if(i==ch)return(0); /* no nonzero vectors */\n\n      samples_per_partition/=ch;\n\n for(s=0;s<info->stages;s++){\n for(i=0;i<partvals;){\n\n if(s==0){\n int temp;\n\t    partword[i+partitions_per_word-1]=1;\n for(k=partitions_per_word-2;k>=0;k--)\n\t      partword[i+k]=partword[i+k+1]*info->partitions;\n\n /* fetch the partition word */\n\t    temp=vorbis_book_decode(phrasebook,&vd->opb);\n if(temp==-1)goto eopbreak;\n\n /* this can be done quickly in assembly due to the quotient\n\t       always being at most six bits */\n for(k=0;k<partitions_per_word;k++){\n ogg_uint32_t div=partword[i+k];\n\t      partword[i+k]=temp/div;\n\t      temp-=partword[i+k]*div;\n }\n }\n\n /* now we decode residual values for the partitions */\n for(k=0;k<partitions_per_word && i<partvals;k++,i++)\n if(info->stagemasks[(int)partword[i]]&(1<<s)){\n\t      codebook *stagebook=ci->book_param+\n\t\tinfo->stagebooks[(partword[i]<<3)+s];\n if(vorbis_book_decodevv_add(stagebook,in,\n\t\t\t\t\t  i*samples_per_partition+beginoff,ch,\n &vd->opb,\n\t\t\t\t\t  samples_per_partition,-8)==-1)\n goto eopbreak;\n }\n }\n }\n }\n }\n eopbreak:\n\n return 0;\n}\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 219,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2014-3513",
    "code_before_change": "int ssl_parse_clienthello_tlsext(SSL *s, unsigned char **p, unsigned char *d, int n, int *al)\n\t{\n\tunsigned short type;\n\tunsigned short size;\n\tunsigned short len;\n\tunsigned char *data = *p;\n\tint renegotiate_seen = 0;\n\tint sigalg_seen = 0;\n\n\ts->servername_done = 0;\n\ts->tlsext_status_type = -1;\n#ifndef OPENSSL_NO_NEXTPROTONEG\n\ts->s3->next_proto_neg_seen = 0;\n#endif\n\n#ifndef OPENSSL_NO_HEARTBEATS\n\ts->tlsext_heartbeat &= ~(SSL_TLSEXT_HB_ENABLED |\n\t                       SSL_TLSEXT_HB_DONT_SEND_REQUESTS);\n#endif\n\n#ifndef OPENSSL_NO_EC\n\tif (s->options & SSL_OP_SAFARI_ECDHE_ECDSA_BUG)\n\t\tssl_check_for_safari(s, data, d, n);\n#endif /* !OPENSSL_NO_EC */\n\n\tif (data >= (d+n-2))\n\t\tgoto ri_check;\n\tn2s(data,len);\n\n\tif (data > (d+n-len)) \n\t\tgoto ri_check;\n\n\twhile (data <= (d+n-4))\n\t\t{\n\t\tn2s(data,type);\n\t\tn2s(data,size);\n\n\t\tif (data+size > (d+n))\n\t   \t\tgoto ri_check;\n#if 0\n\t\tfprintf(stderr,\"Received extension type %d size %d\\n\",type,size);\n#endif\n\t\tif (s->tlsext_debug_cb)\n\t\t\ts->tlsext_debug_cb(s, 0, type, data, size,\n\t\t\t\t\t\ts->tlsext_debug_arg);\n/* The servername extension is treated as follows:\n\n   - Only the hostname type is supported with a maximum length of 255.\n   - The servername is rejected if too long or if it contains zeros,\n     in which case an fatal alert is generated.\n   - The servername field is maintained together with the session cache.\n   - When a session is resumed, the servername call back invoked in order\n     to allow the application to position itself to the right context. \n   - The servername is acknowledged if it is new for a session or when \n     it is identical to a previously used for the same session. \n     Applications can control the behaviour.  They can at any time\n     set a 'desirable' servername for a new SSL object. This can be the\n     case for example with HTTPS when a Host: header field is received and\n     a renegotiation is requested. In this case, a possible servername\n     presented in the new client hello is only acknowledged if it matches\n     the value of the Host: field. \n   - Applications must  use SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION\n     if they provide for changing an explicit servername context for the session,\n     i.e. when the session has been established with a servername extension. \n   - On session reconnect, the servername extension may be absent. \n\n*/      \n\n\t\tif (type == TLSEXT_TYPE_server_name)\n\t\t\t{\n\t\t\tunsigned char *sdata;\n\t\t\tint servname_type;\n\t\t\tint dsize; \n\t\t\n\t\t\tif (size < 2) \n\t\t\t\t{\n\t\t\t\t*al = SSL_AD_DECODE_ERROR;\n\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\tn2s(data,dsize);  \n\t\t\tsize -= 2;\n\t\t\tif (dsize > size  ) \n\t\t\t\t{\n\t\t\t\t*al = SSL_AD_DECODE_ERROR;\n\t\t\t\treturn 0;\n\t\t\t\t} \n\n\t\t\tsdata = data;\n\t\t\twhile (dsize > 3) \n\t\t\t\t{\n\t \t\t\tservname_type = *(sdata++); \n\t\t\t\tn2s(sdata,len);\n\t\t\t\tdsize -= 3;\n\n\t\t\t\tif (len > dsize) \n\t\t\t\t\t{\n\t\t\t\t\t*al = SSL_AD_DECODE_ERROR;\n\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\tif (s->servername_done == 0)\n\t\t\t\tswitch (servname_type)\n\t\t\t\t\t{\n\t\t\t\tcase TLSEXT_NAMETYPE_host_name:\n\t\t\t\t\tif (!s->hit)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tif(s->session->tlsext_hostname)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t*al = SSL_AD_DECODE_ERROR;\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tif (len > TLSEXT_MAXLEN_host_name)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t*al = TLS1_AD_UNRECOGNIZED_NAME;\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tif ((s->session->tlsext_hostname = OPENSSL_malloc(len+1)) == NULL)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t*al = TLS1_AD_INTERNAL_ERROR;\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tmemcpy(s->session->tlsext_hostname, sdata, len);\n\t\t\t\t\t\ts->session->tlsext_hostname[len]='\\0';\n\t\t\t\t\t\tif (strlen(s->session->tlsext_hostname) != len) {\n\t\t\t\t\t\t\tOPENSSL_free(s->session->tlsext_hostname);\n\t\t\t\t\t\t\ts->session->tlsext_hostname = NULL;\n\t\t\t\t\t\t\t*al = TLS1_AD_UNRECOGNIZED_NAME;\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts->servername_done = 1; \n\n\t\t\t\t\t\t}\n\t\t\t\t\telse \n\t\t\t\t\t\ts->servername_done = s->session->tlsext_hostname\n\t\t\t\t\t\t\t&& strlen(s->session->tlsext_hostname) == len \n\t\t\t\t\t\t\t&& strncmp(s->session->tlsext_hostname, (char *)sdata, len) == 0;\n\t\t\t\t\t\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t \n\t\t\t\tdsize -= len;\n\t\t\t\t}\n\t\t\tif (dsize != 0) \n\t\t\t\t{\n\t\t\t\t*al = SSL_AD_DECODE_ERROR;\n\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t}\n#ifndef OPENSSL_NO_SRP\n\t\telse if (type == TLSEXT_TYPE_srp)\n\t\t\t{\n\t\t\tif (size <= 0 || ((len = data[0])) != (size -1))\n\t\t\t\t{\n\t\t\t\t*al = SSL_AD_DECODE_ERROR;\n\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\tif (s->srp_ctx.login != NULL)\n\t\t\t\t{\n\t\t\t\t*al = SSL_AD_DECODE_ERROR;\n\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\tif ((s->srp_ctx.login = OPENSSL_malloc(len+1)) == NULL)\n\t\t\t\treturn -1;\n\t\t\tmemcpy(s->srp_ctx.login, &data[1], len);\n\t\t\ts->srp_ctx.login[len]='\\0';\n  \n\t\t\tif (strlen(s->srp_ctx.login) != len) \n\t\t\t\t{\n\t\t\t\t*al = SSL_AD_DECODE_ERROR;\n\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n#endif\n\n#ifndef OPENSSL_NO_EC\n\t\telse if (type == TLSEXT_TYPE_ec_point_formats)\n\t\t\t{\n\t\t\tunsigned char *sdata = data;\n\t\t\tint ecpointformatlist_length = *(sdata++);\n\n\t\t\tif (ecpointformatlist_length != size - 1)\n\t\t\t\t{\n\t\t\t\t*al = TLS1_AD_DECODE_ERROR;\n\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\tif (!s->hit)\n\t\t\t\t{\n\t\t\t\tif(s->session->tlsext_ecpointformatlist)\n\t\t\t\t\t{\n\t\t\t\t\tOPENSSL_free(s->session->tlsext_ecpointformatlist);\n\t\t\t\t\ts->session->tlsext_ecpointformatlist = NULL;\n\t\t\t\t\t}\n\t\t\t\ts->session->tlsext_ecpointformatlist_length = 0;\n\t\t\t\tif ((s->session->tlsext_ecpointformatlist = OPENSSL_malloc(ecpointformatlist_length)) == NULL)\n\t\t\t\t\t{\n\t\t\t\t\t*al = TLS1_AD_INTERNAL_ERROR;\n\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\ts->session->tlsext_ecpointformatlist_length = ecpointformatlist_length;\n\t\t\t\tmemcpy(s->session->tlsext_ecpointformatlist, sdata, ecpointformatlist_length);\n\t\t\t\t}\n#if 0\n\t\t\tfprintf(stderr,\"ssl_parse_clienthello_tlsext s->session->tlsext_ecpointformatlist (length=%i) \", s->session->tlsext_ecpointformatlist_length);\n\t\t\tsdata = s->session->tlsext_ecpointformatlist;\n\t\t\tfor (i = 0; i < s->session->tlsext_ecpointformatlist_length; i++)\n\t\t\t\tfprintf(stderr,\"%i \",*(sdata++));\n\t\t\tfprintf(stderr,\"\\n\");\n#endif\n\t\t\t}\n\t\telse if (type == TLSEXT_TYPE_elliptic_curves)\n\t\t\t{\n\t\t\tunsigned char *sdata = data;\n\t\t\tint ellipticcurvelist_length = (*(sdata++) << 8);\n\t\t\tellipticcurvelist_length += (*(sdata++));\n\n\t\t\tif (ellipticcurvelist_length != size - 2 ||\n\t\t\t\tellipticcurvelist_length < 1)\n\t\t\t\t{\n\t\t\t\t*al = TLS1_AD_DECODE_ERROR;\n\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\tif (!s->hit)\n\t\t\t\t{\n\t\t\t\tif(s->session->tlsext_ellipticcurvelist)\n\t\t\t\t\t{\n\t\t\t\t\t*al = TLS1_AD_DECODE_ERROR;\n\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\ts->session->tlsext_ellipticcurvelist_length = 0;\n\t\t\t\tif ((s->session->tlsext_ellipticcurvelist = OPENSSL_malloc(ellipticcurvelist_length)) == NULL)\n\t\t\t\t\t{\n\t\t\t\t\t*al = TLS1_AD_INTERNAL_ERROR;\n\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\ts->session->tlsext_ellipticcurvelist_length = ellipticcurvelist_length;\n\t\t\t\tmemcpy(s->session->tlsext_ellipticcurvelist, sdata, ellipticcurvelist_length);\n\t\t\t\t}\n#if 0\n\t\t\tfprintf(stderr,\"ssl_parse_clienthello_tlsext s->session->tlsext_ellipticcurvelist (length=%i) \", s->session->tlsext_ellipticcurvelist_length);\n\t\t\tsdata = s->session->tlsext_ellipticcurvelist;\n\t\t\tfor (i = 0; i < s->session->tlsext_ellipticcurvelist_length; i++)\n\t\t\t\tfprintf(stderr,\"%i \",*(sdata++));\n\t\t\tfprintf(stderr,\"\\n\");\n#endif\n\t\t\t}\n#endif /* OPENSSL_NO_EC */\n#ifdef TLSEXT_TYPE_opaque_prf_input\n\t\telse if (type == TLSEXT_TYPE_opaque_prf_input &&\n\t             s->version != DTLS1_VERSION)\n\t\t\t{\n\t\t\tunsigned char *sdata = data;\n\n\t\t\tif (size < 2)\n\t\t\t\t{\n\t\t\t\t*al = SSL_AD_DECODE_ERROR;\n\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\tn2s(sdata, s->s3->client_opaque_prf_input_len);\n\t\t\tif (s->s3->client_opaque_prf_input_len != size - 2)\n\t\t\t\t{\n\t\t\t\t*al = SSL_AD_DECODE_ERROR;\n\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\tif (s->s3->client_opaque_prf_input != NULL) /* shouldn't really happen */\n\t\t\t\tOPENSSL_free(s->s3->client_opaque_prf_input);\n\t\t\tif (s->s3->client_opaque_prf_input_len == 0)\n\t\t\t\ts->s3->client_opaque_prf_input = OPENSSL_malloc(1); /* dummy byte just to get non-NULL */\n\t\t\telse\n\t\t\t\ts->s3->client_opaque_prf_input = BUF_memdup(sdata, s->s3->client_opaque_prf_input_len);\n\t\t\tif (s->s3->client_opaque_prf_input == NULL)\n\t\t\t\t{\n\t\t\t\t*al = TLS1_AD_INTERNAL_ERROR;\n\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\telse if (type == TLSEXT_TYPE_session_ticket)\n\t\t\t{\n\t\t\tif (s->tls_session_ticket_ext_cb &&\n\t\t\t    !s->tls_session_ticket_ext_cb(s, data, size, s->tls_session_ticket_ext_cb_arg))\n\t\t\t\t{\n\t\t\t\t*al = TLS1_AD_INTERNAL_ERROR;\n\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\telse if (type == TLSEXT_TYPE_renegotiate)\n\t\t\t{\n\t\t\tif(!ssl_parse_clienthello_renegotiate_ext(s, data, size, al))\n\t\t\t\treturn 0;\n\t\t\trenegotiate_seen = 1;\n\t\t\t}\n\t\telse if (type == TLSEXT_TYPE_signature_algorithms)\n\t\t\t{\n\t\t\tint dsize;\n\t\t\tif (sigalg_seen || size < 2) \n\t\t\t\t{\n\t\t\t\t*al = SSL_AD_DECODE_ERROR;\n\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\tsigalg_seen = 1;\n\t\t\tn2s(data,dsize);\n\t\t\tsize -= 2;\n\t\t\tif (dsize != size || dsize & 1) \n\t\t\t\t{\n\t\t\t\t*al = SSL_AD_DECODE_ERROR;\n\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\tif (!tls1_process_sigalgs(s, data, dsize))\n\t\t\t\t{\n\t\t\t\t*al = SSL_AD_DECODE_ERROR;\n\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\telse if (type == TLSEXT_TYPE_status_request &&\n\t\t         s->version != DTLS1_VERSION)\n\t\t\t{\n\t\t\n\t\t\tif (size < 5) \n\t\t\t\t{\n\t\t\t\t*al = SSL_AD_DECODE_ERROR;\n\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\ts->tlsext_status_type = *data++;\n\t\t\tsize--;\n\t\t\tif (s->tlsext_status_type == TLSEXT_STATUSTYPE_ocsp)\n\t\t\t\t{\n\t\t\t\tconst unsigned char *sdata;\n\t\t\t\tint dsize;\n\t\t\t\t/* Read in responder_id_list */\n\t\t\t\tn2s(data,dsize);\n\t\t\t\tsize -= 2;\n\t\t\t\tif (dsize > size  ) \n\t\t\t\t\t{\n\t\t\t\t\t*al = SSL_AD_DECODE_ERROR;\n\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\twhile (dsize > 0)\n\t\t\t\t\t{\n\t\t\t\t\tOCSP_RESPID *id;\n\t\t\t\t\tint idsize;\n\t\t\t\t\tif (dsize < 4)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t*al = SSL_AD_DECODE_ERROR;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\tn2s(data, idsize);\n\t\t\t\t\tdsize -= 2 + idsize;\n\t\t\t\t\tsize -= 2 + idsize;\n\t\t\t\t\tif (dsize < 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t*al = SSL_AD_DECODE_ERROR;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\tsdata = data;\n\t\t\t\t\tdata += idsize;\n\t\t\t\t\tid = d2i_OCSP_RESPID(NULL,\n\t\t\t\t\t\t\t\t&sdata, idsize);\n\t\t\t\t\tif (!id)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t*al = SSL_AD_DECODE_ERROR;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\tif (data != sdata)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tOCSP_RESPID_free(id);\n\t\t\t\t\t\t*al = SSL_AD_DECODE_ERROR;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\tif (!s->tlsext_ocsp_ids\n\t\t\t\t\t\t&& !(s->tlsext_ocsp_ids =\n\t\t\t\t\t\tsk_OCSP_RESPID_new_null()))\n\t\t\t\t\t\t{\n\t\t\t\t\t\tOCSP_RESPID_free(id);\n\t\t\t\t\t\t*al = SSL_AD_INTERNAL_ERROR;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\tif (!sk_OCSP_RESPID_push(\n\t\t\t\t\t\t\ts->tlsext_ocsp_ids, id))\n\t\t\t\t\t\t{\n\t\t\t\t\t\tOCSP_RESPID_free(id);\n\t\t\t\t\t\t*al = SSL_AD_INTERNAL_ERROR;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t/* Read in request_extensions */\n\t\t\t\tif (size < 2)\n\t\t\t\t\t{\n\t\t\t\t\t*al = SSL_AD_DECODE_ERROR;\n\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\tn2s(data,dsize);\n\t\t\t\tsize -= 2;\n\t\t\t\tif (dsize != size)\n\t\t\t\t\t{\n\t\t\t\t\t*al = SSL_AD_DECODE_ERROR;\n\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\tsdata = data;\n\t\t\t\tif (dsize > 0)\n\t\t\t\t\t{\n\t\t\t\t\tif (s->tlsext_ocsp_exts)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tsk_X509_EXTENSION_pop_free(s->tlsext_ocsp_exts,\n\t\t\t\t\t\t\t\t\t   X509_EXTENSION_free);\n\t\t\t\t\t\t}\n\n\t\t\t\t\ts->tlsext_ocsp_exts =\n\t\t\t\t\t\td2i_X509_EXTENSIONS(NULL,\n\t\t\t\t\t\t\t&sdata, dsize);\n\t\t\t\t\tif (!s->tlsext_ocsp_exts\n\t\t\t\t\t\t|| (data + dsize != sdata))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t*al = SSL_AD_DECODE_ERROR;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* We don't know what to do with any other type\n \t\t\t \t* so ignore it.\n \t\t\t \t*/\n\t\t\t\telse\n\t\t\t\t\ts->tlsext_status_type = -1;\n\t\t\t}\n#ifndef OPENSSL_NO_HEARTBEATS\n\t\telse if (type == TLSEXT_TYPE_heartbeat)\n\t\t\t{\n\t\t\tswitch(data[0])\n\t\t\t\t{\n\t\t\t\tcase 0x01:\t/* Client allows us to send HB requests */\n\t\t\t\t\t\t\ts->tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\tcase 0x02:\t/* Client doesn't accept HB requests */\n\t\t\t\t\t\t\ts->tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED;\n\t\t\t\t\t\t\ts->tlsext_heartbeat |= SSL_TLSEXT_HB_DONT_SEND_REQUESTS;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\tdefault:\t*al = SSL_AD_ILLEGAL_PARAMETER;\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n#endif\n#ifndef OPENSSL_NO_NEXTPROTONEG\n\t\telse if (type == TLSEXT_TYPE_next_proto_neg &&\n\t\t\t s->s3->tmp.finish_md_len == 0)\n\t\t\t{\n\t\t\t/* We shouldn't accept this extension on a\n\t\t\t * renegotiation.\n\t\t\t *\n\t\t\t * s->new_session will be set on renegotiation, but we\n\t\t\t * probably shouldn't rely that it couldn't be set on\n\t\t\t * the initial renegotation too in certain cases (when\n\t\t\t * there's some other reason to disallow resuming an\n\t\t\t * earlier session -- the current code won't be doing\n\t\t\t * anything like that, but this might change).\n\n\t\t\t * A valid sign that there's been a previous handshake\n\t\t\t * in this connection is if s->s3->tmp.finish_md_len >\n\t\t\t * 0.  (We are talking about a check that will happen\n\t\t\t * in the Hello protocol round, well before a new\n\t\t\t * Finished message could have been computed.) */\n\t\t\ts->s3->next_proto_neg_seen = 1;\n\t\t\t}\n#endif\n \n                /* session ticket processed earlier */\n #ifndef OPENSSL_NO_SRTP\n               else if (type == TLSEXT_TYPE_use_srtp)\n                        {\n                        if(ssl_parse_clienthello_use_srtp_ext(s, data, size,\n                                                              al))\n\t\t\t}\n#endif\n\n\t\tdata+=size;\n\t\t}\n\t\t\t\t\n\t*p = data;\n\n\tri_check:\n\n\t/* Need RI if renegotiating */\n\n\tif (!renegotiate_seen && s->renegotiate &&\n\t\t!(s->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION))\n\t\t{\n\t\t*al = SSL_AD_HANDSHAKE_FAILURE;\n\t \tSSLerr(SSL_F_SSL_PARSE_CLIENTHELLO_TLSEXT,\n\t\t\t\tSSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED);\n\t\treturn 0;\n\t\t}\n\n\treturn 1;\n\t}\n",
    "code_after_change": "int ssl_parse_clienthello_tlsext(SSL *s, unsigned char **p, unsigned char *d, int n, int *al)\n\t{\n\tunsigned short type;\n\tunsigned short size;\n\tunsigned short len;\n\tunsigned char *data = *p;\n\tint renegotiate_seen = 0;\n\tint sigalg_seen = 0;\n\n\ts->servername_done = 0;\n\ts->tlsext_status_type = -1;\n#ifndef OPENSSL_NO_NEXTPROTONEG\n\ts->s3->next_proto_neg_seen = 0;\n#endif\n\n#ifndef OPENSSL_NO_HEARTBEATS\n\ts->tlsext_heartbeat &= ~(SSL_TLSEXT_HB_ENABLED |\n\t                       SSL_TLSEXT_HB_DONT_SEND_REQUESTS);\n#endif\n\n#ifndef OPENSSL_NO_EC\n\tif (s->options & SSL_OP_SAFARI_ECDHE_ECDSA_BUG)\n\t\tssl_check_for_safari(s, data, d, n);\n#endif /* !OPENSSL_NO_EC */\n\n\tif (data >= (d+n-2))\n\t\tgoto ri_check;\n\tn2s(data,len);\n\n\tif (data > (d+n-len)) \n\t\tgoto ri_check;\n\n\twhile (data <= (d+n-4))\n\t\t{\n\t\tn2s(data,type);\n\t\tn2s(data,size);\n\n\t\tif (data+size > (d+n))\n\t   \t\tgoto ri_check;\n#if 0\n\t\tfprintf(stderr,\"Received extension type %d size %d\\n\",type,size);\n#endif\n\t\tif (s->tlsext_debug_cb)\n\t\t\ts->tlsext_debug_cb(s, 0, type, data, size,\n\t\t\t\t\t\ts->tlsext_debug_arg);\n/* The servername extension is treated as follows:\n\n   - Only the hostname type is supported with a maximum length of 255.\n   - The servername is rejected if too long or if it contains zeros,\n     in which case an fatal alert is generated.\n   - The servername field is maintained together with the session cache.\n   - When a session is resumed, the servername call back invoked in order\n     to allow the application to position itself to the right context. \n   - The servername is acknowledged if it is new for a session or when \n     it is identical to a previously used for the same session. \n     Applications can control the behaviour.  They can at any time\n     set a 'desirable' servername for a new SSL object. This can be the\n     case for example with HTTPS when a Host: header field is received and\n     a renegotiation is requested. In this case, a possible servername\n     presented in the new client hello is only acknowledged if it matches\n     the value of the Host: field. \n   - Applications must  use SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION\n     if they provide for changing an explicit servername context for the session,\n     i.e. when the session has been established with a servername extension. \n   - On session reconnect, the servername extension may be absent. \n\n*/      \n\n\t\tif (type == TLSEXT_TYPE_server_name)\n\t\t\t{\n\t\t\tunsigned char *sdata;\n\t\t\tint servname_type;\n\t\t\tint dsize; \n\t\t\n\t\t\tif (size < 2) \n\t\t\t\t{\n\t\t\t\t*al = SSL_AD_DECODE_ERROR;\n\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\tn2s(data,dsize);  \n\t\t\tsize -= 2;\n\t\t\tif (dsize > size  ) \n\t\t\t\t{\n\t\t\t\t*al = SSL_AD_DECODE_ERROR;\n\t\t\t\treturn 0;\n\t\t\t\t} \n\n\t\t\tsdata = data;\n\t\t\twhile (dsize > 3) \n\t\t\t\t{\n\t \t\t\tservname_type = *(sdata++); \n\t\t\t\tn2s(sdata,len);\n\t\t\t\tdsize -= 3;\n\n\t\t\t\tif (len > dsize) \n\t\t\t\t\t{\n\t\t\t\t\t*al = SSL_AD_DECODE_ERROR;\n\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\tif (s->servername_done == 0)\n\t\t\t\tswitch (servname_type)\n\t\t\t\t\t{\n\t\t\t\tcase TLSEXT_NAMETYPE_host_name:\n\t\t\t\t\tif (!s->hit)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tif(s->session->tlsext_hostname)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t*al = SSL_AD_DECODE_ERROR;\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tif (len > TLSEXT_MAXLEN_host_name)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t*al = TLS1_AD_UNRECOGNIZED_NAME;\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tif ((s->session->tlsext_hostname = OPENSSL_malloc(len+1)) == NULL)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t*al = TLS1_AD_INTERNAL_ERROR;\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tmemcpy(s->session->tlsext_hostname, sdata, len);\n\t\t\t\t\t\ts->session->tlsext_hostname[len]='\\0';\n\t\t\t\t\t\tif (strlen(s->session->tlsext_hostname) != len) {\n\t\t\t\t\t\t\tOPENSSL_free(s->session->tlsext_hostname);\n\t\t\t\t\t\t\ts->session->tlsext_hostname = NULL;\n\t\t\t\t\t\t\t*al = TLS1_AD_UNRECOGNIZED_NAME;\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts->servername_done = 1; \n\n\t\t\t\t\t\t}\n\t\t\t\t\telse \n\t\t\t\t\t\ts->servername_done = s->session->tlsext_hostname\n\t\t\t\t\t\t\t&& strlen(s->session->tlsext_hostname) == len \n\t\t\t\t\t\t\t&& strncmp(s->session->tlsext_hostname, (char *)sdata, len) == 0;\n\t\t\t\t\t\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t \n\t\t\t\tdsize -= len;\n\t\t\t\t}\n\t\t\tif (dsize != 0) \n\t\t\t\t{\n\t\t\t\t*al = SSL_AD_DECODE_ERROR;\n\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t}\n#ifndef OPENSSL_NO_SRP\n\t\telse if (type == TLSEXT_TYPE_srp)\n\t\t\t{\n\t\t\tif (size <= 0 || ((len = data[0])) != (size -1))\n\t\t\t\t{\n\t\t\t\t*al = SSL_AD_DECODE_ERROR;\n\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\tif (s->srp_ctx.login != NULL)\n\t\t\t\t{\n\t\t\t\t*al = SSL_AD_DECODE_ERROR;\n\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\tif ((s->srp_ctx.login = OPENSSL_malloc(len+1)) == NULL)\n\t\t\t\treturn -1;\n\t\t\tmemcpy(s->srp_ctx.login, &data[1], len);\n\t\t\ts->srp_ctx.login[len]='\\0';\n  \n\t\t\tif (strlen(s->srp_ctx.login) != len) \n\t\t\t\t{\n\t\t\t\t*al = SSL_AD_DECODE_ERROR;\n\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n#endif\n\n#ifndef OPENSSL_NO_EC\n\t\telse if (type == TLSEXT_TYPE_ec_point_formats)\n\t\t\t{\n\t\t\tunsigned char *sdata = data;\n\t\t\tint ecpointformatlist_length = *(sdata++);\n\n\t\t\tif (ecpointformatlist_length != size - 1)\n\t\t\t\t{\n\t\t\t\t*al = TLS1_AD_DECODE_ERROR;\n\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\tif (!s->hit)\n\t\t\t\t{\n\t\t\t\tif(s->session->tlsext_ecpointformatlist)\n\t\t\t\t\t{\n\t\t\t\t\tOPENSSL_free(s->session->tlsext_ecpointformatlist);\n\t\t\t\t\ts->session->tlsext_ecpointformatlist = NULL;\n\t\t\t\t\t}\n\t\t\t\ts->session->tlsext_ecpointformatlist_length = 0;\n\t\t\t\tif ((s->session->tlsext_ecpointformatlist = OPENSSL_malloc(ecpointformatlist_length)) == NULL)\n\t\t\t\t\t{\n\t\t\t\t\t*al = TLS1_AD_INTERNAL_ERROR;\n\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\ts->session->tlsext_ecpointformatlist_length = ecpointformatlist_length;\n\t\t\t\tmemcpy(s->session->tlsext_ecpointformatlist, sdata, ecpointformatlist_length);\n\t\t\t\t}\n#if 0\n\t\t\tfprintf(stderr,\"ssl_parse_clienthello_tlsext s->session->tlsext_ecpointformatlist (length=%i) \", s->session->tlsext_ecpointformatlist_length);\n\t\t\tsdata = s->session->tlsext_ecpointformatlist;\n\t\t\tfor (i = 0; i < s->session->tlsext_ecpointformatlist_length; i++)\n\t\t\t\tfprintf(stderr,\"%i \",*(sdata++));\n\t\t\tfprintf(stderr,\"\\n\");\n#endif\n\t\t\t}\n\t\telse if (type == TLSEXT_TYPE_elliptic_curves)\n\t\t\t{\n\t\t\tunsigned char *sdata = data;\n\t\t\tint ellipticcurvelist_length = (*(sdata++) << 8);\n\t\t\tellipticcurvelist_length += (*(sdata++));\n\n\t\t\tif (ellipticcurvelist_length != size - 2 ||\n\t\t\t\tellipticcurvelist_length < 1)\n\t\t\t\t{\n\t\t\t\t*al = TLS1_AD_DECODE_ERROR;\n\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\tif (!s->hit)\n\t\t\t\t{\n\t\t\t\tif(s->session->tlsext_ellipticcurvelist)\n\t\t\t\t\t{\n\t\t\t\t\t*al = TLS1_AD_DECODE_ERROR;\n\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\ts->session->tlsext_ellipticcurvelist_length = 0;\n\t\t\t\tif ((s->session->tlsext_ellipticcurvelist = OPENSSL_malloc(ellipticcurvelist_length)) == NULL)\n\t\t\t\t\t{\n\t\t\t\t\t*al = TLS1_AD_INTERNAL_ERROR;\n\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\ts->session->tlsext_ellipticcurvelist_length = ellipticcurvelist_length;\n\t\t\t\tmemcpy(s->session->tlsext_ellipticcurvelist, sdata, ellipticcurvelist_length);\n\t\t\t\t}\n#if 0\n\t\t\tfprintf(stderr,\"ssl_parse_clienthello_tlsext s->session->tlsext_ellipticcurvelist (length=%i) \", s->session->tlsext_ellipticcurvelist_length);\n\t\t\tsdata = s->session->tlsext_ellipticcurvelist;\n\t\t\tfor (i = 0; i < s->session->tlsext_ellipticcurvelist_length; i++)\n\t\t\t\tfprintf(stderr,\"%i \",*(sdata++));\n\t\t\tfprintf(stderr,\"\\n\");\n#endif\n\t\t\t}\n#endif /* OPENSSL_NO_EC */\n#ifdef TLSEXT_TYPE_opaque_prf_input\n\t\telse if (type == TLSEXT_TYPE_opaque_prf_input &&\n\t             s->version != DTLS1_VERSION)\n\t\t\t{\n\t\t\tunsigned char *sdata = data;\n\n\t\t\tif (size < 2)\n\t\t\t\t{\n\t\t\t\t*al = SSL_AD_DECODE_ERROR;\n\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\tn2s(sdata, s->s3->client_opaque_prf_input_len);\n\t\t\tif (s->s3->client_opaque_prf_input_len != size - 2)\n\t\t\t\t{\n\t\t\t\t*al = SSL_AD_DECODE_ERROR;\n\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\tif (s->s3->client_opaque_prf_input != NULL) /* shouldn't really happen */\n\t\t\t\tOPENSSL_free(s->s3->client_opaque_prf_input);\n\t\t\tif (s->s3->client_opaque_prf_input_len == 0)\n\t\t\t\ts->s3->client_opaque_prf_input = OPENSSL_malloc(1); /* dummy byte just to get non-NULL */\n\t\t\telse\n\t\t\t\ts->s3->client_opaque_prf_input = BUF_memdup(sdata, s->s3->client_opaque_prf_input_len);\n\t\t\tif (s->s3->client_opaque_prf_input == NULL)\n\t\t\t\t{\n\t\t\t\t*al = TLS1_AD_INTERNAL_ERROR;\n\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\telse if (type == TLSEXT_TYPE_session_ticket)\n\t\t\t{\n\t\t\tif (s->tls_session_ticket_ext_cb &&\n\t\t\t    !s->tls_session_ticket_ext_cb(s, data, size, s->tls_session_ticket_ext_cb_arg))\n\t\t\t\t{\n\t\t\t\t*al = TLS1_AD_INTERNAL_ERROR;\n\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\telse if (type == TLSEXT_TYPE_renegotiate)\n\t\t\t{\n\t\t\tif(!ssl_parse_clienthello_renegotiate_ext(s, data, size, al))\n\t\t\t\treturn 0;\n\t\t\trenegotiate_seen = 1;\n\t\t\t}\n\t\telse if (type == TLSEXT_TYPE_signature_algorithms)\n\t\t\t{\n\t\t\tint dsize;\n\t\t\tif (sigalg_seen || size < 2) \n\t\t\t\t{\n\t\t\t\t*al = SSL_AD_DECODE_ERROR;\n\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\tsigalg_seen = 1;\n\t\t\tn2s(data,dsize);\n\t\t\tsize -= 2;\n\t\t\tif (dsize != size || dsize & 1) \n\t\t\t\t{\n\t\t\t\t*al = SSL_AD_DECODE_ERROR;\n\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\tif (!tls1_process_sigalgs(s, data, dsize))\n\t\t\t\t{\n\t\t\t\t*al = SSL_AD_DECODE_ERROR;\n\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\telse if (type == TLSEXT_TYPE_status_request &&\n\t\t         s->version != DTLS1_VERSION)\n\t\t\t{\n\t\t\n\t\t\tif (size < 5) \n\t\t\t\t{\n\t\t\t\t*al = SSL_AD_DECODE_ERROR;\n\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\ts->tlsext_status_type = *data++;\n\t\t\tsize--;\n\t\t\tif (s->tlsext_status_type == TLSEXT_STATUSTYPE_ocsp)\n\t\t\t\t{\n\t\t\t\tconst unsigned char *sdata;\n\t\t\t\tint dsize;\n\t\t\t\t/* Read in responder_id_list */\n\t\t\t\tn2s(data,dsize);\n\t\t\t\tsize -= 2;\n\t\t\t\tif (dsize > size  ) \n\t\t\t\t\t{\n\t\t\t\t\t*al = SSL_AD_DECODE_ERROR;\n\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\twhile (dsize > 0)\n\t\t\t\t\t{\n\t\t\t\t\tOCSP_RESPID *id;\n\t\t\t\t\tint idsize;\n\t\t\t\t\tif (dsize < 4)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t*al = SSL_AD_DECODE_ERROR;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\tn2s(data, idsize);\n\t\t\t\t\tdsize -= 2 + idsize;\n\t\t\t\t\tsize -= 2 + idsize;\n\t\t\t\t\tif (dsize < 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t*al = SSL_AD_DECODE_ERROR;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\tsdata = data;\n\t\t\t\t\tdata += idsize;\n\t\t\t\t\tid = d2i_OCSP_RESPID(NULL,\n\t\t\t\t\t\t\t\t&sdata, idsize);\n\t\t\t\t\tif (!id)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t*al = SSL_AD_DECODE_ERROR;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\tif (data != sdata)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tOCSP_RESPID_free(id);\n\t\t\t\t\t\t*al = SSL_AD_DECODE_ERROR;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\tif (!s->tlsext_ocsp_ids\n\t\t\t\t\t\t&& !(s->tlsext_ocsp_ids =\n\t\t\t\t\t\tsk_OCSP_RESPID_new_null()))\n\t\t\t\t\t\t{\n\t\t\t\t\t\tOCSP_RESPID_free(id);\n\t\t\t\t\t\t*al = SSL_AD_INTERNAL_ERROR;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\tif (!sk_OCSP_RESPID_push(\n\t\t\t\t\t\t\ts->tlsext_ocsp_ids, id))\n\t\t\t\t\t\t{\n\t\t\t\t\t\tOCSP_RESPID_free(id);\n\t\t\t\t\t\t*al = SSL_AD_INTERNAL_ERROR;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t/* Read in request_extensions */\n\t\t\t\tif (size < 2)\n\t\t\t\t\t{\n\t\t\t\t\t*al = SSL_AD_DECODE_ERROR;\n\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\tn2s(data,dsize);\n\t\t\t\tsize -= 2;\n\t\t\t\tif (dsize != size)\n\t\t\t\t\t{\n\t\t\t\t\t*al = SSL_AD_DECODE_ERROR;\n\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\tsdata = data;\n\t\t\t\tif (dsize > 0)\n\t\t\t\t\t{\n\t\t\t\t\tif (s->tlsext_ocsp_exts)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tsk_X509_EXTENSION_pop_free(s->tlsext_ocsp_exts,\n\t\t\t\t\t\t\t\t\t   X509_EXTENSION_free);\n\t\t\t\t\t\t}\n\n\t\t\t\t\ts->tlsext_ocsp_exts =\n\t\t\t\t\t\td2i_X509_EXTENSIONS(NULL,\n\t\t\t\t\t\t\t&sdata, dsize);\n\t\t\t\t\tif (!s->tlsext_ocsp_exts\n\t\t\t\t\t\t|| (data + dsize != sdata))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t*al = SSL_AD_DECODE_ERROR;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* We don't know what to do with any other type\n \t\t\t \t* so ignore it.\n \t\t\t \t*/\n\t\t\t\telse\n\t\t\t\t\ts->tlsext_status_type = -1;\n\t\t\t}\n#ifndef OPENSSL_NO_HEARTBEATS\n\t\telse if (type == TLSEXT_TYPE_heartbeat)\n\t\t\t{\n\t\t\tswitch(data[0])\n\t\t\t\t{\n\t\t\t\tcase 0x01:\t/* Client allows us to send HB requests */\n\t\t\t\t\t\t\ts->tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\tcase 0x02:\t/* Client doesn't accept HB requests */\n\t\t\t\t\t\t\ts->tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED;\n\t\t\t\t\t\t\ts->tlsext_heartbeat |= SSL_TLSEXT_HB_DONT_SEND_REQUESTS;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\tdefault:\t*al = SSL_AD_ILLEGAL_PARAMETER;\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n#endif\n#ifndef OPENSSL_NO_NEXTPROTONEG\n\t\telse if (type == TLSEXT_TYPE_next_proto_neg &&\n\t\t\t s->s3->tmp.finish_md_len == 0)\n\t\t\t{\n\t\t\t/* We shouldn't accept this extension on a\n\t\t\t * renegotiation.\n\t\t\t *\n\t\t\t * s->new_session will be set on renegotiation, but we\n\t\t\t * probably shouldn't rely that it couldn't be set on\n\t\t\t * the initial renegotation too in certain cases (when\n\t\t\t * there's some other reason to disallow resuming an\n\t\t\t * earlier session -- the current code won't be doing\n\t\t\t * anything like that, but this might change).\n\n\t\t\t * A valid sign that there's been a previous handshake\n\t\t\t * in this connection is if s->s3->tmp.finish_md_len >\n\t\t\t * 0.  (We are talking about a check that will happen\n\t\t\t * in the Hello protocol round, well before a new\n\t\t\t * Finished message could have been computed.) */\n\t\t\ts->s3->next_proto_neg_seen = 1;\n\t\t\t}\n#endif\n \n                /* session ticket processed earlier */\n #ifndef OPENSSL_NO_SRTP\n               else if (SSL_IS_DTLS(s) && SSL_get_srtp_profiles(s)\n                        && type == TLSEXT_TYPE_use_srtp)\n                        {\n                        if(ssl_parse_clienthello_use_srtp_ext(s, data, size,\n                                                              al))\n\t\t\t}\n#endif\n\n\t\tdata+=size;\n\t\t}\n\t\t\t\t\n\t*p = data;\n\n\tri_check:\n\n\t/* Need RI if renegotiating */\n\n\tif (!renegotiate_seen && s->renegotiate &&\n\t\t!(s->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION))\n\t\t{\n\t\t*al = SSL_AD_HANDSHAKE_FAILURE;\n\t \tSSLerr(SSL_F_SSL_PARSE_CLIENTHELLO_TLSEXT,\n\t\t\t\tSSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED);\n\t\treturn 0;\n\t\t}\n\n\treturn 1;\n\t}\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 220,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2015-5296",
    "code_before_change": "SMBC_server_internal(TALLOC_CTX *ctx,\n            SMBCCTX *context,\n            bool connect_if_not_found,\n            const char *server,\n            uint16_t port,\n            const char *share,\n            char **pp_workgroup,\n            char **pp_username,\n            char **pp_password,\n\t    bool *in_cache)\n{\n\tSMBCSRV *srv=NULL;\n\tchar *workgroup = NULL;\n\tstruct cli_state *c = NULL;\n\tconst char *server_n = server;\n        int is_ipc = (share != NULL && strcmp(share, \"IPC$\") == 0);\n\tuint32_t fs_attrs = 0;\n        const char *username_used;\n \tNTSTATUS status;\n        char *newserver, *newshare;\n        int flags = 0;\n        struct smbXcli_tcon *tcon = NULL;\n \n        ZERO_STRUCT(c);\n        *in_cache = false;\n\tif (server[0] == 0) {\n\t\terrno = EPERM;\n\t\treturn NULL;\n\t}\n\n        /* Look for a cached connection */\n        srv = SMBC_find_server(ctx, context, server, share,\n                               pp_workgroup, pp_username, pp_password);\n\n        /*\n         * If we found a connection and we're only allowed one share per\n         * server...\n         */\n        if (srv &&\n\t    share != NULL && *share != '\\0' &&\n            smbc_getOptionOneSharePerServer(context)) {\n\n                /*\n                 * ... then if there's no current connection to the share,\n                 * connect to it.  SMBC_find_server(), or rather the function\n                 * pointed to by context->get_cached_srv_fn which\n                 * was called by SMBC_find_server(), will have issued a tree\n                 * disconnect if the requested share is not the same as the\n                 * one that was already connected.\n                 */\n\n\t\t/*\n\t\t * Use srv->cli->desthost and srv->cli->share instead of\n\t\t * server and share below to connect to the actual share,\n\t\t * i.e., a normal share or a referred share from\n\t\t * 'msdfs proxy' share.\n\t\t */\n                if (!cli_state_has_tcon(srv->cli)) {\n                        /* Ensure we have accurate auth info */\n\t\t\tSMBC_call_auth_fn(ctx, context,\n\t\t\t\t\t  smbXcli_conn_remote_name(srv->cli->conn),\n\t\t\t\t\t  srv->cli->share,\n                                          pp_workgroup,\n                                          pp_username,\n                                          pp_password);\n\n\t\t\tif (!*pp_workgroup || !*pp_username || !*pp_password) {\n\t\t\t\terrno = ENOMEM;\n\t\t\t\tcli_shutdown(srv->cli);\n\t\t\t\tsrv->cli = NULL;\n\t\t\t\tsmbc_getFunctionRemoveCachedServer(context)(context,\n                                                                            srv);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We don't need to renegotiate encryption\n\t\t\t * here as the encryption context is not per\n\t\t\t * tid.\n\t\t\t */\n\n\t\t\tstatus = cli_tree_connect(srv->cli,\n\t\t\t\t\t\t  srv->cli->share,\n\t\t\t\t\t\t  \"?????\",\n\t\t\t\t\t\t  *pp_password,\n\t\t\t\t\t\t  strlen(*pp_password)+1);\n\t\t\tif (!NT_STATUS_IS_OK(status)) {\n                                errno = map_errno_from_nt_status(status);\n                                cli_shutdown(srv->cli);\n\t\t\t\tsrv->cli = NULL;\n                                smbc_getFunctionRemoveCachedServer(context)(context,\n                                                                            srv);\n                                srv = NULL;\n                        }\n\n                        /* Determine if this share supports case sensitivity */\n                        if (is_ipc) {\n                                DEBUG(4,\n                                      (\"IPC$ so ignore case sensitivity\\n\"));\n                                status = NT_STATUS_OK;\n                        } else {\n                                status = cli_get_fs_attr_info(c, &fs_attrs);\n                        }\n\n                        if (!NT_STATUS_IS_OK(status)) {\n                                DEBUG(4, (\"Could not retrieve \"\n                                          \"case sensitivity flag: %s.\\n\",\n                                          nt_errstr(status)));\n\n                                /*\n                                 * We can't determine the case sensitivity of\n                                 * the share. We have no choice but to use the\n                                 * user-specified case sensitivity setting.\n                                 */\n                                if (smbc_getOptionCaseSensitive(context)) {\n                                        cli_set_case_sensitive(c, True);\n                                } else {\n                                        cli_set_case_sensitive(c, False);\n                                }\n                        } else if (!is_ipc) {\n                                DEBUG(4,\n                                      (\"Case sensitive: %s\\n\",\n                                       (fs_attrs & FILE_CASE_SENSITIVE_SEARCH\n                                        ? \"True\"\n                                        : \"False\")));\n                                cli_set_case_sensitive(\n                                        c,\n                                        (fs_attrs & FILE_CASE_SENSITIVE_SEARCH\n                                         ? True\n                                         : False));\n                        }\n\n                        /*\n                         * Regenerate the dev value since it's based on both\n                         * server and share\n                         */\n                        if (srv) {\n\t\t\t\tconst char *remote_name =\n\t\t\t\t\tsmbXcli_conn_remote_name(srv->cli->conn);\n\n\t\t\t\tsrv->dev = (dev_t)(str_checksum(remote_name) ^\n                                                   str_checksum(srv->cli->share));\n                        }\n                }\n        }\n\n        /* If we have a connection... */\n        if (srv) {\n\n                /* ... then we're done here.  Give 'em what they came for. */\n\t\t*in_cache = true;\n                goto done;\n        }\n\n        /* If we're not asked to connect when a connection doesn't exist... */\n        if (! connect_if_not_found) {\n                /* ... then we're done here. */\n                return NULL;\n        }\n\n\tif (!*pp_workgroup || !*pp_username || !*pp_password) {\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\n\tDEBUG(4,(\"SMBC_server: server_n=[%s] server=[%s]\\n\", server_n, server));\n\n\tDEBUG(4,(\" -> server_n=[%s] server=[%s]\\n\", server_n, server));\n\n\tstatus = NT_STATUS_UNSUCCESSFUL;\n\n\tif (smbc_getOptionUseKerberos(context)) {\n\t\tflags |= CLI_FULL_CONNECTION_USE_KERBEROS;\n\t}\n\n\tif (smbc_getOptionFallbackAfterKerberos(context)) {\n\t\tflags |= CLI_FULL_CONNECTION_FALLBACK_AFTER_KERBEROS;\n\t}\n\n\tif (smbc_getOptionUseCCache(context)) {\n\t\tflags |= CLI_FULL_CONNECTION_USE_CCACHE;\n\t}\n\n\tif (smbc_getOptionUseNTHash(context)) {\n\t\tflags |= CLI_FULL_CONNECTION_USE_NT_HASH;\n                flags |= CLI_FULL_CONNECTION_USE_NT_HASH;\n        }\n \n        if (port == 0) {\n                if (share == NULL || *share == '\\0' || is_ipc) {\n                        /*\n\t\t}\n                         */\n                        status = cli_connect_nb(server_n, NULL, NBT_SMB_PORT, 0x20,\n                                        smbc_getNetbiosName(context),\n                                       SMB_SIGNING_DEFAULT, flags, &c);\n                }\n        }\n",
    "code_after_change": "SMBC_server_internal(TALLOC_CTX *ctx,\n            SMBCCTX *context,\n            bool connect_if_not_found,\n            const char *server,\n            uint16_t port,\n            const char *share,\n            char **pp_workgroup,\n            char **pp_username,\n            char **pp_password,\n\t    bool *in_cache)\n{\n\tSMBCSRV *srv=NULL;\n\tchar *workgroup = NULL;\n\tstruct cli_state *c = NULL;\n\tconst char *server_n = server;\n        int is_ipc = (share != NULL && strcmp(share, \"IPC$\") == 0);\n\tuint32_t fs_attrs = 0;\n        const char *username_used;\n \tNTSTATUS status;\n        char *newserver, *newshare;\n        int flags = 0;\n        struct smbXcli_tcon *tcon = NULL;\n       int signing_state = SMB_SIGNING_DEFAULT;\n \n        ZERO_STRUCT(c);\n        *in_cache = false;\n\tif (server[0] == 0) {\n\t\terrno = EPERM;\n\t\treturn NULL;\n\t}\n\n        /* Look for a cached connection */\n        srv = SMBC_find_server(ctx, context, server, share,\n                               pp_workgroup, pp_username, pp_password);\n\n        /*\n         * If we found a connection and we're only allowed one share per\n         * server...\n         */\n        if (srv &&\n\t    share != NULL && *share != '\\0' &&\n            smbc_getOptionOneSharePerServer(context)) {\n\n                /*\n                 * ... then if there's no current connection to the share,\n                 * connect to it.  SMBC_find_server(), or rather the function\n                 * pointed to by context->get_cached_srv_fn which\n                 * was called by SMBC_find_server(), will have issued a tree\n                 * disconnect if the requested share is not the same as the\n                 * one that was already connected.\n                 */\n\n\t\t/*\n\t\t * Use srv->cli->desthost and srv->cli->share instead of\n\t\t * server and share below to connect to the actual share,\n\t\t * i.e., a normal share or a referred share from\n\t\t * 'msdfs proxy' share.\n\t\t */\n                if (!cli_state_has_tcon(srv->cli)) {\n                        /* Ensure we have accurate auth info */\n\t\t\tSMBC_call_auth_fn(ctx, context,\n\t\t\t\t\t  smbXcli_conn_remote_name(srv->cli->conn),\n\t\t\t\t\t  srv->cli->share,\n                                          pp_workgroup,\n                                          pp_username,\n                                          pp_password);\n\n\t\t\tif (!*pp_workgroup || !*pp_username || !*pp_password) {\n\t\t\t\terrno = ENOMEM;\n\t\t\t\tcli_shutdown(srv->cli);\n\t\t\t\tsrv->cli = NULL;\n\t\t\t\tsmbc_getFunctionRemoveCachedServer(context)(context,\n                                                                            srv);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We don't need to renegotiate encryption\n\t\t\t * here as the encryption context is not per\n\t\t\t * tid.\n\t\t\t */\n\n\t\t\tstatus = cli_tree_connect(srv->cli,\n\t\t\t\t\t\t  srv->cli->share,\n\t\t\t\t\t\t  \"?????\",\n\t\t\t\t\t\t  *pp_password,\n\t\t\t\t\t\t  strlen(*pp_password)+1);\n\t\t\tif (!NT_STATUS_IS_OK(status)) {\n                                errno = map_errno_from_nt_status(status);\n                                cli_shutdown(srv->cli);\n\t\t\t\tsrv->cli = NULL;\n                                smbc_getFunctionRemoveCachedServer(context)(context,\n                                                                            srv);\n                                srv = NULL;\n                        }\n\n                        /* Determine if this share supports case sensitivity */\n                        if (is_ipc) {\n                                DEBUG(4,\n                                      (\"IPC$ so ignore case sensitivity\\n\"));\n                                status = NT_STATUS_OK;\n                        } else {\n                                status = cli_get_fs_attr_info(c, &fs_attrs);\n                        }\n\n                        if (!NT_STATUS_IS_OK(status)) {\n                                DEBUG(4, (\"Could not retrieve \"\n                                          \"case sensitivity flag: %s.\\n\",\n                                          nt_errstr(status)));\n\n                                /*\n                                 * We can't determine the case sensitivity of\n                                 * the share. We have no choice but to use the\n                                 * user-specified case sensitivity setting.\n                                 */\n                                if (smbc_getOptionCaseSensitive(context)) {\n                                        cli_set_case_sensitive(c, True);\n                                } else {\n                                        cli_set_case_sensitive(c, False);\n                                }\n                        } else if (!is_ipc) {\n                                DEBUG(4,\n                                      (\"Case sensitive: %s\\n\",\n                                       (fs_attrs & FILE_CASE_SENSITIVE_SEARCH\n                                        ? \"True\"\n                                        : \"False\")));\n                                cli_set_case_sensitive(\n                                        c,\n                                        (fs_attrs & FILE_CASE_SENSITIVE_SEARCH\n                                         ? True\n                                         : False));\n                        }\n\n                        /*\n                         * Regenerate the dev value since it's based on both\n                         * server and share\n                         */\n                        if (srv) {\n\t\t\t\tconst char *remote_name =\n\t\t\t\t\tsmbXcli_conn_remote_name(srv->cli->conn);\n\n\t\t\t\tsrv->dev = (dev_t)(str_checksum(remote_name) ^\n                                                   str_checksum(srv->cli->share));\n                        }\n                }\n        }\n\n        /* If we have a connection... */\n        if (srv) {\n\n                /* ... then we're done here.  Give 'em what they came for. */\n\t\t*in_cache = true;\n                goto done;\n        }\n\n        /* If we're not asked to connect when a connection doesn't exist... */\n        if (! connect_if_not_found) {\n                /* ... then we're done here. */\n                return NULL;\n        }\n\n\tif (!*pp_workgroup || !*pp_username || !*pp_password) {\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\n\tDEBUG(4,(\"SMBC_server: server_n=[%s] server=[%s]\\n\", server_n, server));\n\n\tDEBUG(4,(\" -> server_n=[%s] server=[%s]\\n\", server_n, server));\n\n\tstatus = NT_STATUS_UNSUCCESSFUL;\n\n\tif (smbc_getOptionUseKerberos(context)) {\n\t\tflags |= CLI_FULL_CONNECTION_USE_KERBEROS;\n\t}\n\n\tif (smbc_getOptionFallbackAfterKerberos(context)) {\n\t\tflags |= CLI_FULL_CONNECTION_FALLBACK_AFTER_KERBEROS;\n\t}\n\n\tif (smbc_getOptionUseCCache(context)) {\n\t\tflags |= CLI_FULL_CONNECTION_USE_CCACHE;\n\t}\n\n\tif (smbc_getOptionUseNTHash(context)) {\n\t\tflags |= CLI_FULL_CONNECTION_USE_NT_HASH;\n                flags |= CLI_FULL_CONNECTION_USE_NT_HASH;\n        }\n \n       if (context->internal->smb_encryption_level != SMBC_ENCRYPTLEVEL_NONE) {\n               signing_state = SMB_SIGNING_REQUIRED;\n       }\n\n        if (port == 0) {\n                if (share == NULL || *share == '\\0' || is_ipc) {\n                        /*\n\t\t}\n                         */\n                        status = cli_connect_nb(server_n, NULL, NBT_SMB_PORT, 0x20,\n                                        smbc_getNetbiosName(context),\n                                       signing_state, flags, &c);\n                }\n        }\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 221,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2018-17471",
    "code_before_change": " void WebContentsImpl::DidCallFocus() {\n  if (IsFullscreenForCurrentTab())\n    ExitFullscreen(true);\n }\n",
    "code_after_change": " void WebContentsImpl::DidCallFocus() {\n  ForSecurityDropFullscreen();\n }\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 237,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2017-15390",
    "code_before_change": "bool IDNSpoofChecker::SafeToDisplayAsUnicode(base::StringPiece16 label,\n                                             bool is_tld_ascii) {\n  UErrorCode status = U_ZERO_ERROR;\n  int32_t result =\n      uspoof_check(checker_, label.data(),\n                   base::checked_cast<int32_t>(label.size()), NULL, &status);\n  if (U_FAILURE(status) || (result & USPOOF_ALL_CHECKS))\n    return false;\n\n  icu::UnicodeString label_string(FALSE, label.data(),\n                                  base::checked_cast<int32_t>(label.size()));\n\n  if (deviation_characters_.containsSome(label_string))\n    return false;\n\n  result &= USPOOF_RESTRICTION_LEVEL_MASK;\n  if (result == USPOOF_ASCII)\n    return true;\n  if (result == USPOOF_SINGLE_SCRIPT_RESTRICTIVE &&\n      kana_letters_exceptions_.containsNone(label_string) &&\n      combining_diacritics_exceptions_.containsNone(label_string)) {\n    return !is_tld_ascii || !IsMadeOfLatinAlikeCyrillic(label_string);\n  }\n\n  if (non_ascii_latin_letters_.containsSome(label_string) &&\n      !lgc_letters_n_ascii_.containsAll(label_string))\n    return false;\n\n  if (!tls_index.initialized())\n    tls_index.Initialize(&OnThreadTermination);\n  icu::RegexMatcher* dangerous_pattern =\n      reinterpret_cast<icu::RegexMatcher*>(tls_index.Get());\n  if (!dangerous_pattern) {\n     dangerous_pattern = new icu::RegexMatcher(\n         icu::UnicodeString(\n             R\"([^\\p{scx=kana}\\p{scx=hira}\\p{scx=hani}])\"\n            R\"([\\u30ce\\u30f3\\u30bd\\u30be])\"\n            R\"([^\\p{scx=kana}\\p{scx=hira}\\p{scx=hani}]|)\"\n            R\"([^\\p{scx=kana}\\p{scx=hira}]\\u30fc|^\\u30fc|)\"\n            R\"([^\\p{scx=kana}][\\u30fd\\u30fe]|^[\\u30fd\\u30fe]|)\"\n            R\"(^[\\p{scx=kana}]+[\\u3078-\\u307a][\\p{scx=kana}]+$|)\"\n            R\"(^[\\p{scx=hira}]+[\\u30d8-\\u30da][\\p{scx=hira}]+$|)\"\n            R\"([a-z]\\u30fb|\\u30fb[a-z]|)\"\n            R\"(^[\\u0585\\u0581]+[a-z]|[a-z][\\u0585\\u0581]+$|)\"\n            R\"([a-z][\\u0585\\u0581]+[a-z]|)\"\n            R\"(^[og]+[\\p{scx=armn}]|[\\p{scx=armn}][og]+$|)\"\n            R\"([\\p{scx=armn}][og]+[\\p{scx=armn}]|)\"\n            R\"([\\p{sc=cans}].*[a-z]|[a-z].*[\\p{sc=cans}]|)\"\n             R\"([\\p{sc=tfng}].*[a-z]|[a-z].*[\\p{sc=tfng}]|)\"\n             R\"([^\\p{scx=latn}\\p{scx=grek}\\p{scx=cyrl}][\\u0300-\\u0339]|)\"\n             R\"([^\\p{scx=arab}][\\u064b-\\u0655\\u0670]|)\"\n            R\"([^\\p{scx=hebr}]\\u05b4)\",\n             -1, US_INV),\n         0, status);\n     tls_index.Set(dangerous_pattern);\n  }\n  dangerous_pattern->reset(label_string);\n  return !dangerous_pattern->find();\n}\n",
    "code_after_change": "bool IDNSpoofChecker::SafeToDisplayAsUnicode(base::StringPiece16 label,\n                                             bool is_tld_ascii) {\n  UErrorCode status = U_ZERO_ERROR;\n  int32_t result =\n      uspoof_check(checker_, label.data(),\n                   base::checked_cast<int32_t>(label.size()), NULL, &status);\n  if (U_FAILURE(status) || (result & USPOOF_ALL_CHECKS))\n    return false;\n\n  icu::UnicodeString label_string(FALSE, label.data(),\n                                  base::checked_cast<int32_t>(label.size()));\n\n  if (deviation_characters_.containsSome(label_string))\n    return false;\n\n  result &= USPOOF_RESTRICTION_LEVEL_MASK;\n  if (result == USPOOF_ASCII)\n    return true;\n  if (result == USPOOF_SINGLE_SCRIPT_RESTRICTIVE &&\n      kana_letters_exceptions_.containsNone(label_string) &&\n      combining_diacritics_exceptions_.containsNone(label_string)) {\n    return !is_tld_ascii || !IsMadeOfLatinAlikeCyrillic(label_string);\n  }\n\n  if (non_ascii_latin_letters_.containsSome(label_string) &&\n      !lgc_letters_n_ascii_.containsAll(label_string))\n    return false;\n\n  if (!tls_index.initialized())\n    tls_index.Initialize(&OnThreadTermination);\n  icu::RegexMatcher* dangerous_pattern =\n      reinterpret_cast<icu::RegexMatcher*>(tls_index.Get());\n  if (!dangerous_pattern) {\n    // - Disallow U+0307 (dot above) after 'i', 'j', 'l' or dotless i (U+0131).\n    //   Dotless j (U+0237) is not in the allowed set to begin with.\n     dangerous_pattern = new icu::RegexMatcher(\n         icu::UnicodeString(\n             R\"([^\\p{scx=kana}\\p{scx=hira}\\p{scx=hani}])\"\n            R\"([\\u30ce\\u30f3\\u30bd\\u30be])\"\n            R\"([^\\p{scx=kana}\\p{scx=hira}\\p{scx=hani}]|)\"\n            R\"([^\\p{scx=kana}\\p{scx=hira}]\\u30fc|^\\u30fc|)\"\n            R\"([^\\p{scx=kana}][\\u30fd\\u30fe]|^[\\u30fd\\u30fe]|)\"\n            R\"(^[\\p{scx=kana}]+[\\u3078-\\u307a][\\p{scx=kana}]+$|)\"\n            R\"(^[\\p{scx=hira}]+[\\u30d8-\\u30da][\\p{scx=hira}]+$|)\"\n            R\"([a-z]\\u30fb|\\u30fb[a-z]|)\"\n            R\"(^[\\u0585\\u0581]+[a-z]|[a-z][\\u0585\\u0581]+$|)\"\n            R\"([a-z][\\u0585\\u0581]+[a-z]|)\"\n            R\"(^[og]+[\\p{scx=armn}]|[\\p{scx=armn}][og]+$|)\"\n            R\"([\\p{scx=armn}][og]+[\\p{scx=armn}]|)\"\n            R\"([\\p{sc=cans}].*[a-z]|[a-z].*[\\p{sc=cans}]|)\"\n             R\"([\\p{sc=tfng}].*[a-z]|[a-z].*[\\p{sc=tfng}]|)\"\n             R\"([^\\p{scx=latn}\\p{scx=grek}\\p{scx=cyrl}][\\u0300-\\u0339]|)\"\n             R\"([^\\p{scx=arab}][\\u064b-\\u0655\\u0670]|)\"\n            R\"([^\\p{scx=hebr}]\\u05b4|)\"\n            R\"([ijl\\u0131]\\u0307)\",\n             -1, US_INV),\n         0, status);\n     tls_index.Set(dangerous_pattern);\n  }\n  dangerous_pattern->reset(label_string);\n  return !dangerous_pattern->find();\n}\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 251,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2011-2875",
    "code_before_change": "    RTCVoidRequestTask(MockWebRTCPeerConnectionHandler* object, const WebKit::WebRTCVoidRequest& request, bool succeeded)\n        : MethodTask<MockWebRTCPeerConnectionHandler>(object)\n        , m_request(request)\n        , m_succeeded(succeeded)\n    {\n    }\n",
    "code_after_change": "    RTCVoidRequestTask(MockWebRTCPeerConnectionHandler* object, const WebKit::WebRTCVoidRequest& request, bool succeeded)\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 281,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2018-6042",
    "code_before_change": "bool IDNSpoofChecker::SimilarToTopDomains(base::StringPiece16 hostname) {\n  size_t hostname_length = hostname.length() - (hostname.back() == '.' ? 1 : 0);\n  icu::UnicodeString ustr_host(FALSE, hostname.data(), hostname_length);\n   if (lgc_letters_n_ascii_.span(ustr_host, 0, USET_SPAN_CONTAINED) ==\n       ustr_host.length())\n    transliterator_.get()->transliterate(ustr_host);\n \n   UErrorCode status = U_ZERO_ERROR;\n   icu::UnicodeString ustr_skeleton;\n  uspoof_getSkeletonUnicodeString(checker_, 0, ustr_host, ustr_skeleton,\n                                  &status);\n   if (U_FAILURE(status))\n     return false;\n   std::string skeleton;\n  ustr_skeleton.toUTF8String(skeleton);\n  return LookupMatchInTopDomains(skeleton);\n }\n",
    "code_after_change": "bool IDNSpoofChecker::SimilarToTopDomains(base::StringPiece16 hostname) {\n  size_t hostname_length = hostname.length() - (hostname.back() == '.' ? 1 : 0);\n  icu::UnicodeString ustr_host(FALSE, hostname.data(), hostname_length);\n   if (lgc_letters_n_ascii_.span(ustr_host, 0, USET_SPAN_CONTAINED) ==\n       ustr_host.length())\n    diacritic_remover_.get()->transliterate(ustr_host);\n  extra_confusable_mapper_.get()->transliterate(ustr_host);\n \n   UErrorCode status = U_ZERO_ERROR;\n   icu::UnicodeString ustr_skeleton;\n  uspoof_getSkeletonUnicodeString(checker_, 0, ustr_host, ustr_skeleton,\n                                  &status);\n   if (U_FAILURE(status))\n     return false;\n   std::string skeleton;\n  return LookupMatchInTopDomains(ustr_skeleton.toUTF8String(skeleton));\n }\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 294,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2011-3094",
    "code_before_change": " bool GesturePoint::IsOverMinFlickSpeed() {\n  return velocity_calculator_.VelocitySquared() > kMinFlickSpeedSquared;\n }\n",
    "code_after_change": " bool GesturePoint::IsOverMinFlickSpeed() {\n  return velocity_calculator_.VelocitySquared() >\n      GestureConfiguration::min_flick_speed_squared();\n }\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 296,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2018-1000037",
    "code_before_change": "pdf_process_extgstate(fz_context *ctx, pdf_processor *proc, pdf_csi *csi, pdf_obj *dict)\n{\n\tpdf_obj *obj;\n\n\tobj = pdf_dict_get(ctx, dict, PDF_NAME_LW);\n\tif (pdf_is_number(ctx, obj) && proc->op_w)\n\t\tproc->op_w(ctx, proc, pdf_to_real(ctx, obj));\n\n\tobj = pdf_dict_get(ctx, dict, PDF_NAME_LC);\n\tif (pdf_is_int(ctx, obj) && proc->op_J)\n\t\tproc->op_J(ctx, proc, fz_clampi(pdf_to_int(ctx, obj), 0, 2));\n\n\tobj = pdf_dict_get(ctx, dict, PDF_NAME_LJ);\n\tif (pdf_is_int(ctx, obj) && proc->op_j)\n\t\tproc->op_j(ctx, proc, fz_clampi(pdf_to_int(ctx, obj), 0, 2));\n\n\tobj = pdf_dict_get(ctx, dict, PDF_NAME_ML);\n\tif (pdf_is_number(ctx, obj) && proc->op_M)\n\t\tproc->op_M(ctx, proc, pdf_to_real(ctx, obj));\n\n\tobj = pdf_dict_get(ctx, dict, PDF_NAME_D);\n\tif (pdf_is_array(ctx, obj) && proc->op_d)\n\t{\n\t\tpdf_obj *dash_array = pdf_array_get(ctx, obj, 0);\n\t\tpdf_obj *dash_phase = pdf_array_get(ctx, obj, 1);\n\t\tproc->op_d(ctx, proc, dash_array, pdf_to_real(ctx, dash_phase));\n\t}\n\n\tobj = pdf_dict_get(ctx, dict, PDF_NAME_RI);\n\tif (pdf_is_name(ctx, obj) && proc->op_ri)\n\t\tproc->op_ri(ctx, proc, pdf_to_name(ctx, obj));\n\n\tobj = pdf_dict_get(ctx, dict, PDF_NAME_FL);\n\tif (pdf_is_number(ctx, obj) && proc->op_i)\n\t\tproc->op_i(ctx, proc, pdf_to_real(ctx, obj));\n\n\tobj = pdf_dict_get(ctx, dict, PDF_NAME_Font);\n\tif (pdf_is_array(ctx, obj) && proc->op_Tf)\n\t{\n\t\tpdf_obj *font_ref = pdf_array_get(ctx, obj, 0);\n\t\tpdf_obj *font_size = pdf_array_get(ctx, obj, 1);\n\t\tpdf_font_desc *font = load_font_or_hail_mary(ctx, csi->doc, csi->rdb, font_ref, 0, csi->cookie);\n\t\tfz_try(ctx)\n\t\t\tproc->op_Tf(ctx, proc, \"ExtGState\", font, pdf_to_real(ctx, font_size));\n\t\tfz_always(ctx)\n\t\t\tpdf_drop_font(ctx, font);\n\t\tfz_catch(ctx)\n\t\t\tfz_rethrow(ctx);\n\t}\n\n\t/* overprint and color management */\n\n\tobj = pdf_dict_get(ctx, dict, PDF_NAME_OP);\n\tif (pdf_is_bool(ctx, obj) && proc->op_gs_OP)\n\t\tproc->op_gs_OP(ctx, proc, pdf_to_bool(ctx, obj));\n\n\tobj = pdf_dict_get(ctx, dict, PDF_NAME_op);\n\tif (pdf_is_bool(ctx, obj) && proc->op_gs_op)\n\t\tproc->op_gs_op(ctx, proc, pdf_to_bool(ctx, obj));\n\n\tobj = pdf_dict_get(ctx, dict, PDF_NAME_OPM);\n\tif (pdf_is_int(ctx, obj) && proc->op_gs_OPM)\n\t\tproc->op_gs_OPM(ctx, proc, pdf_to_int(ctx, obj));\n\n\tobj = pdf_dict_get(ctx, dict, PDF_NAME_UseBlackPtComp);\n\tif (pdf_is_name(ctx, obj) && proc->op_gs_UseBlackPtComp)\n\t\tproc->op_gs_UseBlackPtComp(ctx, proc, obj);\n\n\t/* transfer functions */\n\n\tobj = pdf_dict_get(ctx, dict, PDF_NAME_TR2);\n\tif (pdf_is_name(ctx, obj))\n\t\tif (!pdf_name_eq(ctx, obj, PDF_NAME_Identity) && !pdf_name_eq(ctx, obj, PDF_NAME_Default))\n\t\t\tfz_warn(ctx, \"ignoring transfer function\");\n\tif (!obj) /* TR is ignored in the presence of TR2 */\n\t{\n\t\tpdf_obj *tr = pdf_dict_get(ctx, dict, PDF_NAME_TR);\n\t\tif (pdf_is_name(ctx, tr))\n\t\t\tif (!pdf_name_eq(ctx, tr, PDF_NAME_Identity))\n\t\t\t\tfz_warn(ctx, \"ignoring transfer function\");\n\t}\n\n\t/* transparency state */\n\n\tobj = pdf_dict_get(ctx, dict, PDF_NAME_CA);\n\tif (pdf_is_number(ctx, obj) && proc->op_gs_CA)\n\t\tproc->op_gs_CA(ctx, proc, pdf_to_real(ctx, obj));\n\n\tobj = pdf_dict_get(ctx, dict, PDF_NAME_ca);\n\tif (pdf_is_number(ctx, obj) && proc->op_gs_ca)\n\t\tproc->op_gs_ca(ctx, proc, pdf_to_real(ctx, obj));\n\n\tobj = pdf_dict_get(ctx, dict, PDF_NAME_BM);\n\tif (pdf_is_array(ctx, obj))\n\t\tobj = pdf_array_get(ctx, obj, 0);\n\tif (pdf_is_name(ctx, obj) && proc->op_gs_BM)\n\t\tproc->op_gs_BM(ctx, proc, pdf_to_name(ctx, obj));\n\n\tobj = pdf_dict_get(ctx, dict, PDF_NAME_SMask);\n\tif (proc->op_gs_SMask)\n\t{\n\t\tif (pdf_is_dict(ctx, obj))\n\t\t{\n\t\t\tpdf_xobject *xobj;\n\t\t\tpdf_obj *group, *s, *bc, *tr;\n\t\t\tfloat softmask_bc[FZ_MAX_COLORS];\n\t\t\tfz_colorspace *colorspace;\n\t\t\tint colorspace_n = 1;\n\t\t\tint k, luminosity;\n\n                        fz_var(xobj);\n \n                        group = pdf_dict_get(ctx, obj, PDF_NAME_G);\n                       if (!group)\n                               fz_throw(ctx, FZ_ERROR_SYNTAX, \"cannot load softmask xobject (%d 0 R)\", pdf_to_num(ctx, obj));\n                        xobj = pdf_load_xobject(ctx, csi->doc, group);\n \n\n\t\t\tfz_try(ctx)\n\t\t\t{\n\t\t\t\tcolorspace = pdf_xobject_colorspace(ctx, xobj);\n\t\t\t\tif (colorspace)\n\t\t\t\t\tcolorspace_n = fz_colorspace_n(ctx, colorspace);\n\n\t\t\t\t/* Default background color is black. */\n\t\t\t\tfor (k = 0; k < colorspace_n; k++)\n\t\t\t\t\tsoftmask_bc[k] = 0;\n\t\t\t\t/* Which in CMYK means not all zeros! This should really be\n\t\t\t\t * a test for subtractive color spaces, but this will have\n\t\t\t\t * to do for now. */\n\t\t\t\tif (fz_colorspace_is_cmyk(ctx, colorspace))\n\t\t\t\t\tsoftmask_bc[3] = 1.0f;\n\t\t\t\tfz_drop_colorspace(ctx, colorspace);\n\n\t\t\t\tbc = pdf_dict_get(ctx, obj, PDF_NAME_BC);\n\t\t\t\tif (pdf_is_array(ctx, bc))\n\t\t\t\t{\n\t\t\t\t\tfor (k = 0; k < colorspace_n; k++)\n\t\t\t\t\t\tsoftmask_bc[k] = pdf_to_real(ctx, pdf_array_get(ctx, bc, k));\n\t\t\t\t}\n\n\t\t\t\ts = pdf_dict_get(ctx, obj, PDF_NAME_S);\n\t\t\t\tif (pdf_name_eq(ctx, s, PDF_NAME_Luminosity))\n\t\t\t\t\tluminosity = 1;\n\t\t\t\telse\n\t\t\t\t\tluminosity = 0;\n\n\t\t\t\ttr = pdf_dict_get(ctx, obj, PDF_NAME_TR);\n\t\t\t\tif (tr && !pdf_name_eq(ctx, tr, PDF_NAME_Identity))\n\t\t\t\t\tfz_warn(ctx, \"ignoring transfer function\");\n\n\t\t\t\tproc->op_gs_SMask(ctx, proc, xobj, csi->rdb, softmask_bc, luminosity);\n\t\t\t}\n\t\t\tfz_always(ctx)\n\t\t\t{\n\t\t\t\tpdf_drop_xobject(ctx, xobj);\n\t\t\t}\n\t\t\tfz_catch(ctx)\n\t\t\t{\n\t\t\t\tfz_rethrow(ctx);\n\t\t\t}\n\t\t}\n\t\telse if (pdf_is_name(ctx, obj) && pdf_name_eq(ctx, obj, PDF_NAME_None))\n\t\t{\n\t\t\tproc->op_gs_SMask(ctx, proc, NULL, NULL, NULL, 0);\n\t\t}\n\t}\n}\n",
    "code_after_change": "pdf_process_extgstate(fz_context *ctx, pdf_processor *proc, pdf_csi *csi, pdf_obj *dict)\n{\n\tpdf_obj *obj;\n\n\tobj = pdf_dict_get(ctx, dict, PDF_NAME_LW);\n\tif (pdf_is_number(ctx, obj) && proc->op_w)\n\t\tproc->op_w(ctx, proc, pdf_to_real(ctx, obj));\n\n\tobj = pdf_dict_get(ctx, dict, PDF_NAME_LC);\n\tif (pdf_is_int(ctx, obj) && proc->op_J)\n\t\tproc->op_J(ctx, proc, fz_clampi(pdf_to_int(ctx, obj), 0, 2));\n\n\tobj = pdf_dict_get(ctx, dict, PDF_NAME_LJ);\n\tif (pdf_is_int(ctx, obj) && proc->op_j)\n\t\tproc->op_j(ctx, proc, fz_clampi(pdf_to_int(ctx, obj), 0, 2));\n\n\tobj = pdf_dict_get(ctx, dict, PDF_NAME_ML);\n\tif (pdf_is_number(ctx, obj) && proc->op_M)\n\t\tproc->op_M(ctx, proc, pdf_to_real(ctx, obj));\n\n\tobj = pdf_dict_get(ctx, dict, PDF_NAME_D);\n\tif (pdf_is_array(ctx, obj) && proc->op_d)\n\t{\n\t\tpdf_obj *dash_array = pdf_array_get(ctx, obj, 0);\n\t\tpdf_obj *dash_phase = pdf_array_get(ctx, obj, 1);\n\t\tproc->op_d(ctx, proc, dash_array, pdf_to_real(ctx, dash_phase));\n\t}\n\n\tobj = pdf_dict_get(ctx, dict, PDF_NAME_RI);\n\tif (pdf_is_name(ctx, obj) && proc->op_ri)\n\t\tproc->op_ri(ctx, proc, pdf_to_name(ctx, obj));\n\n\tobj = pdf_dict_get(ctx, dict, PDF_NAME_FL);\n\tif (pdf_is_number(ctx, obj) && proc->op_i)\n\t\tproc->op_i(ctx, proc, pdf_to_real(ctx, obj));\n\n\tobj = pdf_dict_get(ctx, dict, PDF_NAME_Font);\n\tif (pdf_is_array(ctx, obj) && proc->op_Tf)\n\t{\n\t\tpdf_obj *font_ref = pdf_array_get(ctx, obj, 0);\n\t\tpdf_obj *font_size = pdf_array_get(ctx, obj, 1);\n\t\tpdf_font_desc *font = load_font_or_hail_mary(ctx, csi->doc, csi->rdb, font_ref, 0, csi->cookie);\n\t\tfz_try(ctx)\n\t\t\tproc->op_Tf(ctx, proc, \"ExtGState\", font, pdf_to_real(ctx, font_size));\n\t\tfz_always(ctx)\n\t\t\tpdf_drop_font(ctx, font);\n\t\tfz_catch(ctx)\n\t\t\tfz_rethrow(ctx);\n\t}\n\n\t/* overprint and color management */\n\n\tobj = pdf_dict_get(ctx, dict, PDF_NAME_OP);\n\tif (pdf_is_bool(ctx, obj) && proc->op_gs_OP)\n\t\tproc->op_gs_OP(ctx, proc, pdf_to_bool(ctx, obj));\n\n\tobj = pdf_dict_get(ctx, dict, PDF_NAME_op);\n\tif (pdf_is_bool(ctx, obj) && proc->op_gs_op)\n\t\tproc->op_gs_op(ctx, proc, pdf_to_bool(ctx, obj));\n\n\tobj = pdf_dict_get(ctx, dict, PDF_NAME_OPM);\n\tif (pdf_is_int(ctx, obj) && proc->op_gs_OPM)\n\t\tproc->op_gs_OPM(ctx, proc, pdf_to_int(ctx, obj));\n\n\tobj = pdf_dict_get(ctx, dict, PDF_NAME_UseBlackPtComp);\n\tif (pdf_is_name(ctx, obj) && proc->op_gs_UseBlackPtComp)\n\t\tproc->op_gs_UseBlackPtComp(ctx, proc, obj);\n\n\t/* transfer functions */\n\n\tobj = pdf_dict_get(ctx, dict, PDF_NAME_TR2);\n\tif (pdf_is_name(ctx, obj))\n\t\tif (!pdf_name_eq(ctx, obj, PDF_NAME_Identity) && !pdf_name_eq(ctx, obj, PDF_NAME_Default))\n\t\t\tfz_warn(ctx, \"ignoring transfer function\");\n\tif (!obj) /* TR is ignored in the presence of TR2 */\n\t{\n\t\tpdf_obj *tr = pdf_dict_get(ctx, dict, PDF_NAME_TR);\n\t\tif (pdf_is_name(ctx, tr))\n\t\t\tif (!pdf_name_eq(ctx, tr, PDF_NAME_Identity))\n\t\t\t\tfz_warn(ctx, \"ignoring transfer function\");\n\t}\n\n\t/* transparency state */\n\n\tobj = pdf_dict_get(ctx, dict, PDF_NAME_CA);\n\tif (pdf_is_number(ctx, obj) && proc->op_gs_CA)\n\t\tproc->op_gs_CA(ctx, proc, pdf_to_real(ctx, obj));\n\n\tobj = pdf_dict_get(ctx, dict, PDF_NAME_ca);\n\tif (pdf_is_number(ctx, obj) && proc->op_gs_ca)\n\t\tproc->op_gs_ca(ctx, proc, pdf_to_real(ctx, obj));\n\n\tobj = pdf_dict_get(ctx, dict, PDF_NAME_BM);\n\tif (pdf_is_array(ctx, obj))\n\t\tobj = pdf_array_get(ctx, obj, 0);\n\tif (pdf_is_name(ctx, obj) && proc->op_gs_BM)\n\t\tproc->op_gs_BM(ctx, proc, pdf_to_name(ctx, obj));\n\n\tobj = pdf_dict_get(ctx, dict, PDF_NAME_SMask);\n\tif (proc->op_gs_SMask)\n\t{\n\t\tif (pdf_is_dict(ctx, obj))\n\t\t{\n\t\t\tpdf_xobject *xobj;\n\t\t\tpdf_obj *group, *s, *bc, *tr;\n\t\t\tfloat softmask_bc[FZ_MAX_COLORS];\n\t\t\tfz_colorspace *colorspace;\n\t\t\tint colorspace_n = 1;\n\t\t\tint k, luminosity;\n\n                        fz_var(xobj);\n \n                        group = pdf_dict_get(ctx, obj, PDF_NAME_G);\n                        xobj = pdf_load_xobject(ctx, csi->doc, group);\n \n\n\t\t\tfz_try(ctx)\n\t\t\t{\n\t\t\t\tcolorspace = pdf_xobject_colorspace(ctx, xobj);\n\t\t\t\tif (colorspace)\n\t\t\t\t\tcolorspace_n = fz_colorspace_n(ctx, colorspace);\n\n\t\t\t\t/* Default background color is black. */\n\t\t\t\tfor (k = 0; k < colorspace_n; k++)\n\t\t\t\t\tsoftmask_bc[k] = 0;\n\t\t\t\t/* Which in CMYK means not all zeros! This should really be\n\t\t\t\t * a test for subtractive color spaces, but this will have\n\t\t\t\t * to do for now. */\n\t\t\t\tif (fz_colorspace_is_cmyk(ctx, colorspace))\n\t\t\t\t\tsoftmask_bc[3] = 1.0f;\n\t\t\t\tfz_drop_colorspace(ctx, colorspace);\n\n\t\t\t\tbc = pdf_dict_get(ctx, obj, PDF_NAME_BC);\n\t\t\t\tif (pdf_is_array(ctx, bc))\n\t\t\t\t{\n\t\t\t\t\tfor (k = 0; k < colorspace_n; k++)\n\t\t\t\t\t\tsoftmask_bc[k] = pdf_to_real(ctx, pdf_array_get(ctx, bc, k));\n\t\t\t\t}\n\n\t\t\t\ts = pdf_dict_get(ctx, obj, PDF_NAME_S);\n\t\t\t\tif (pdf_name_eq(ctx, s, PDF_NAME_Luminosity))\n\t\t\t\t\tluminosity = 1;\n\t\t\t\telse\n\t\t\t\t\tluminosity = 0;\n\n\t\t\t\ttr = pdf_dict_get(ctx, obj, PDF_NAME_TR);\n\t\t\t\tif (tr && !pdf_name_eq(ctx, tr, PDF_NAME_Identity))\n\t\t\t\t\tfz_warn(ctx, \"ignoring transfer function\");\n\n\t\t\t\tproc->op_gs_SMask(ctx, proc, xobj, csi->rdb, softmask_bc, luminosity);\n\t\t\t}\n\t\t\tfz_always(ctx)\n\t\t\t{\n\t\t\t\tpdf_drop_xobject(ctx, xobj);\n\t\t\t}\n\t\t\tfz_catch(ctx)\n\t\t\t{\n\t\t\t\tfz_rethrow(ctx);\n\t\t\t}\n\t\t}\n\t\telse if (pdf_is_name(ctx, obj) && pdf_name_eq(ctx, obj, PDF_NAME_None))\n\t\t{\n\t\t\tproc->op_gs_SMask(ctx, proc, NULL, NULL, NULL, 0);\n\t\t}\n\t}\n}\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 298,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2013-7271",
    "code_before_change": "static int llcp_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t     struct msghdr *msg, size_t len, int flags)\n{\n\tint noblock = flags & MSG_DONTWAIT;\n\tstruct sock *sk = sock->sk;\n\tunsigned int copied, rlen;\n\tstruct sk_buff *skb, *cskb;\n\tint err = 0;\n \n \tpr_debug(\"%p %zu\\n\", sk, len);\n \n\tmsg->msg_namelen = 0;\n \tlock_sock(sk);\n \n \tif (sk->sk_state == LLCP_CLOSED &&\n\t    skb_queue_empty(&sk->sk_receive_queue)) {\n\t\trelease_sock(sk);\n\t\treturn 0;\n\t}\n\n\trelease_sock(sk);\n\n\tif (flags & (MSG_OOB))\n\t\treturn -EOPNOTSUPP;\n\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb) {\n\t\tpr_err(\"Recv datagram failed state %d %d %d\",\n\t\t       sk->sk_state, err, sock_error(sk));\n\n\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\treturn 0;\n\n\t\treturn err;\n\t}\n\n\trlen = skb->len;\t\t/* real length of skb */\n\tcopied = min_t(unsigned int, rlen, len);\n\n\tcskb = skb;\n\tif (skb_copy_datagram_iovec(cskb, 0, msg->msg_iov, copied)) {\n\t\tif (!(flags & MSG_PEEK))\n\t\t\tskb_queue_head(&sk->sk_receive_queue, skb);\n\t\treturn -EFAULT;\n\t}\n\n\tsock_recv_timestamp(msg, sk, skb);\n\n\tif (sk->sk_type == SOCK_DGRAM && msg->msg_name) {\n\t\tstruct nfc_llcp_ui_cb *ui_cb = nfc_llcp_ui_skb_cb(skb);\n\t\tstruct sockaddr_nfc_llcp *sockaddr =\n\t\t\t(struct sockaddr_nfc_llcp *) msg->msg_name;\n\n\t\tmsg->msg_namelen = sizeof(struct sockaddr_nfc_llcp);\n\n\t\tpr_debug(\"Datagram socket %d %d\\n\", ui_cb->dsap, ui_cb->ssap);\n\n\t\tmemset(sockaddr, 0, sizeof(*sockaddr));\n\t\tsockaddr->sa_family = AF_NFC;\n\t\tsockaddr->nfc_protocol = NFC_PROTO_NFC_DEP;\n\t\tsockaddr->dsap = ui_cb->dsap;\n\t\tsockaddr->ssap = ui_cb->ssap;\n\t}\n\n\t/* Mark read part of skb as used */\n\tif (!(flags & MSG_PEEK)) {\n\n\t\t/* SOCK_STREAM: re-queue skb if it contains unreceived data */\n\t\tif (sk->sk_type == SOCK_STREAM ||\n\t\t    sk->sk_type == SOCK_DGRAM ||\n\t\t    sk->sk_type == SOCK_RAW) {\n\t\t\tskb_pull(skb, copied);\n\t\t\tif (skb->len) {\n\t\t\t\tskb_queue_head(&sk->sk_receive_queue, skb);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\n\t\tkfree_skb(skb);\n\t}\n\n\t/* XXX Queue backlogged skbs */\n\ndone:\n\t/* SOCK_SEQPACKET: return real length if MSG_TRUNC is set */\n\tif (sk->sk_type == SOCK_SEQPACKET && (flags & MSG_TRUNC))\n\t\tcopied = rlen;\n\n\treturn copied;\n}\n",
    "code_after_change": "static int llcp_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t     struct msghdr *msg, size_t len, int flags)\n{\n\tint noblock = flags & MSG_DONTWAIT;\n\tstruct sock *sk = sock->sk;\n\tunsigned int copied, rlen;\n\tstruct sk_buff *skb, *cskb;\n\tint err = 0;\n \n \tpr_debug(\"%p %zu\\n\", sk, len);\n \n \tlock_sock(sk);\n \n \tif (sk->sk_state == LLCP_CLOSED &&\n\t    skb_queue_empty(&sk->sk_receive_queue)) {\n\t\trelease_sock(sk);\n\t\treturn 0;\n\t}\n\n\trelease_sock(sk);\n\n\tif (flags & (MSG_OOB))\n\t\treturn -EOPNOTSUPP;\n\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb) {\n\t\tpr_err(\"Recv datagram failed state %d %d %d\",\n\t\t       sk->sk_state, err, sock_error(sk));\n\n\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\treturn 0;\n\n\t\treturn err;\n\t}\n\n\trlen = skb->len;\t\t/* real length of skb */\n\tcopied = min_t(unsigned int, rlen, len);\n\n\tcskb = skb;\n\tif (skb_copy_datagram_iovec(cskb, 0, msg->msg_iov, copied)) {\n\t\tif (!(flags & MSG_PEEK))\n\t\t\tskb_queue_head(&sk->sk_receive_queue, skb);\n\t\treturn -EFAULT;\n\t}\n\n\tsock_recv_timestamp(msg, sk, skb);\n\n\tif (sk->sk_type == SOCK_DGRAM && msg->msg_name) {\n\t\tstruct nfc_llcp_ui_cb *ui_cb = nfc_llcp_ui_skb_cb(skb);\n\t\tstruct sockaddr_nfc_llcp *sockaddr =\n\t\t\t(struct sockaddr_nfc_llcp *) msg->msg_name;\n\n\t\tmsg->msg_namelen = sizeof(struct sockaddr_nfc_llcp);\n\n\t\tpr_debug(\"Datagram socket %d %d\\n\", ui_cb->dsap, ui_cb->ssap);\n\n\t\tmemset(sockaddr, 0, sizeof(*sockaddr));\n\t\tsockaddr->sa_family = AF_NFC;\n\t\tsockaddr->nfc_protocol = NFC_PROTO_NFC_DEP;\n\t\tsockaddr->dsap = ui_cb->dsap;\n\t\tsockaddr->ssap = ui_cb->ssap;\n\t}\n\n\t/* Mark read part of skb as used */\n\tif (!(flags & MSG_PEEK)) {\n\n\t\t/* SOCK_STREAM: re-queue skb if it contains unreceived data */\n\t\tif (sk->sk_type == SOCK_STREAM ||\n\t\t    sk->sk_type == SOCK_DGRAM ||\n\t\t    sk->sk_type == SOCK_RAW) {\n\t\t\tskb_pull(skb, copied);\n\t\t\tif (skb->len) {\n\t\t\t\tskb_queue_head(&sk->sk_receive_queue, skb);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\n\t\tkfree_skb(skb);\n\t}\n\n\t/* XXX Queue backlogged skbs */\n\ndone:\n\t/* SOCK_SEQPACKET: return real length if MSG_TRUNC is set */\n\tif (sk->sk_type == SOCK_SEQPACKET && (flags & MSG_TRUNC))\n\t\tcopied = rlen;\n\n\treturn copied;\n}\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 302,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2013-3735",
    "code_before_change": "zend_op_array *compile_string(zval *source_string, char *filename TSRMLS_DC)\n{\n\tzend_lex_state original_lex_state;\n\tzend_op_array *op_array = (zend_op_array *) emalloc(sizeof(zend_op_array));\n\tzend_op_array *original_active_op_array = CG(active_op_array);\n\tzend_op_array *retval;\n\tzval tmp;\n\tint compiler_result;\n\tzend_bool original_in_compilation = CG(in_compilation);\n\n\tif (source_string->value.str.len==0) {\n\t\tefree(op_array);\n\t\treturn NULL;\n\t}\n\n\tCG(in_compilation) = 1;\n\n\ttmp = *source_string;\n\tzval_copy_ctor(&tmp);\n\tconvert_to_string(&tmp);\n\tsource_string = &tmp;\n\n\tzend_save_lexical_state(&original_lex_state TSRMLS_CC);\n\tif (zend_prepare_string_for_scanning(source_string, filename TSRMLS_CC)==FAILURE) {\n\t\tefree(op_array);\n\t\tretval = NULL;\n\t} else {\n\t\tzend_bool orig_interactive = CG(interactive);\n\n\t\tCG(interactive) = 0;\n\t\tinit_op_array(op_array, ZEND_EVAL_CODE, INITIAL_OP_ARRAY_SIZE TSRMLS_CC);\n\t\tCG(interactive) = orig_interactive;\n\t\tCG(active_op_array) = op_array;\n\t\tzend_stack_push(&CG(context_stack), (void *) &CG(context), sizeof(CG(context)));\n\t\tzend_init_compiler_context(TSRMLS_C);\n\t\tBEGIN(ST_IN_SCRIPTING);\n\t\tcompiler_result = zendparse(TSRMLS_C);\n\n\t\tif (SCNG(script_filtered)) {\n\t\t\tefree(SCNG(script_filtered));\n \t\t\tSCNG(script_filtered) = NULL;\n \t\t}\n \n\t\tif (compiler_result==1) {\n \t\t\tCG(active_op_array) = original_active_op_array;\n \t\t\tCG(unclean_shutdown)=1;\n \t\t\tdestroy_op_array(op_array TSRMLS_CC);\n\t\t\tefree(op_array);\n\t\t\tretval = NULL;\n\t\t} else {\n\t\t\tzend_do_return(NULL, 0 TSRMLS_CC);\n\t\t\tCG(active_op_array) = original_active_op_array;\n\t\t\tpass_two(op_array TSRMLS_CC);\n\t\t\tzend_release_labels(0 TSRMLS_CC);\n\t\t\tretval = op_array;\n\t\t}\n\t}\n\tzend_restore_lexical_state(&original_lex_state TSRMLS_CC);\n\tzval_dtor(&tmp);\n\tCG(in_compilation) = original_in_compilation;\n\treturn retval;\n}\n",
    "code_after_change": "zend_op_array *compile_string(zval *source_string, char *filename TSRMLS_DC)\n{\n\tzend_lex_state original_lex_state;\n\tzend_op_array *op_array = (zend_op_array *) emalloc(sizeof(zend_op_array));\n\tzend_op_array *original_active_op_array = CG(active_op_array);\n\tzend_op_array *retval;\n\tzval tmp;\n\tint compiler_result;\n\tzend_bool original_in_compilation = CG(in_compilation);\n\n\tif (source_string->value.str.len==0) {\n\t\tefree(op_array);\n\t\treturn NULL;\n\t}\n\n\tCG(in_compilation) = 1;\n\n\ttmp = *source_string;\n\tzval_copy_ctor(&tmp);\n\tconvert_to_string(&tmp);\n\tsource_string = &tmp;\n\n\tzend_save_lexical_state(&original_lex_state TSRMLS_CC);\n\tif (zend_prepare_string_for_scanning(source_string, filename TSRMLS_CC)==FAILURE) {\n\t\tefree(op_array);\n\t\tretval = NULL;\n\t} else {\n\t\tzend_bool orig_interactive = CG(interactive);\n\n\t\tCG(interactive) = 0;\n\t\tinit_op_array(op_array, ZEND_EVAL_CODE, INITIAL_OP_ARRAY_SIZE TSRMLS_CC);\n\t\tCG(interactive) = orig_interactive;\n\t\tCG(active_op_array) = op_array;\n\t\tzend_stack_push(&CG(context_stack), (void *) &CG(context), sizeof(CG(context)));\n\t\tzend_init_compiler_context(TSRMLS_C);\n\t\tBEGIN(ST_IN_SCRIPTING);\n\t\tcompiler_result = zendparse(TSRMLS_C);\n\n\t\tif (SCNG(script_filtered)) {\n\t\t\tefree(SCNG(script_filtered));\n \t\t\tSCNG(script_filtered) = NULL;\n \t\t}\n \n\t\tif (compiler_result != 0) {\n \t\t\tCG(active_op_array) = original_active_op_array;\n \t\t\tCG(unclean_shutdown)=1;\n \t\t\tdestroy_op_array(op_array TSRMLS_CC);\n\t\t\tefree(op_array);\n\t\t\tretval = NULL;\n\t\t} else {\n\t\t\tzend_do_return(NULL, 0 TSRMLS_CC);\n\t\t\tCG(active_op_array) = original_active_op_array;\n\t\t\tpass_two(op_array TSRMLS_CC);\n\t\t\tzend_release_labels(0 TSRMLS_CC);\n\t\t\tretval = op_array;\n\t\t}\n\t}\n\tzend_restore_lexical_state(&original_lex_state TSRMLS_CC);\n\tzval_dtor(&tmp);\n\tCG(in_compilation) = original_in_compilation;\n\treturn retval;\n}\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 307,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2016-2495",
    "code_before_change": " status_t SampleTable::setTimeToSampleParams(\n         off64_t data_offset, size_t data_size) {\n    if (!mTimeToSample.empty() || data_size < 8) {\n         return ERROR_MALFORMED;\n     }\n \n uint8_t header[8];\n if (mDataSource->readAt(\n                data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {\n return ERROR_IO;\n }\n\n if (U32_AT(header) != 0) {\n return ERROR_MALFORMED;\n }\n\n    mTimeToSampleCount = U32_AT(&header[4]);\n if ((uint64_t)mTimeToSampleCount >\n (uint64_t)UINT32_MAX / (2 * sizeof(uint32_t))) {\n        ALOGE(\"  Error: Time-to-sample table size too large.\");\n\n return ERROR_OUT_OF_RANGE;\n }\n\n if (!mDataSource->getVector(data_offset + 8, &mTimeToSample,\n                                mTimeToSampleCount * 2)) {\n        ALOGE(\"  Error: Incomplete data read for time-to-sample table.\");\n return ERROR_IO;\n }\n\n\n     for (size_t i = 0; i < mTimeToSample.size(); ++i) {\n         mTimeToSample.editItemAt(i) = ntohl(mTimeToSample[i]);\n     }\n     return OK;\n }\n",
    "code_after_change": " status_t SampleTable::setTimeToSampleParams(\n         off64_t data_offset, size_t data_size) {\n    if (mHasTimeToSample || data_size < 8) {\n         return ERROR_MALFORMED;\n     }\n \n uint8_t header[8];\n if (mDataSource->readAt(\n                data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {\n return ERROR_IO;\n }\n\n if (U32_AT(header) != 0) {\n return ERROR_MALFORMED;\n }\n\n    mTimeToSampleCount = U32_AT(&header[4]);\n if ((uint64_t)mTimeToSampleCount >\n (uint64_t)UINT32_MAX / (2 * sizeof(uint32_t))) {\n        ALOGE(\"  Error: Time-to-sample table size too large.\");\n\n return ERROR_OUT_OF_RANGE;\n }\n\n if (!mDataSource->getVector(data_offset + 8, &mTimeToSample,\n                                mTimeToSampleCount * 2)) {\n        ALOGE(\"  Error: Incomplete data read for time-to-sample table.\");\n return ERROR_IO;\n }\n\n\n     for (size_t i = 0; i < mTimeToSample.size(); ++i) {\n         mTimeToSample.editItemAt(i) = ntohl(mTimeToSample[i]);\n     }\n\n    mHasTimeToSample = true;\n     return OK;\n }\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 312,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2011-2839",
    "code_before_change": "bool ExtensionTtsController::IsSpeaking() const {\n  return current_utterance_ != NULL;\n}\n",
    "code_after_change": "bool ExtensionTtsController::IsSpeaking() const {\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 317,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2012-5148",
    "code_before_change": "void Browser::TabDetachedAtImpl(TabContents* contents, int index,\n                                 DetachType type) {\n   if (type == DETACH_TYPE_DETACH) {\n    if (contents == chrome::GetActiveTabContents(this)) {\n       LocationBar* location_bar = window()->GetLocationBar();\n       if (location_bar)\n        location_bar->SaveStateToContents(contents->web_contents());\n     }\n \n     if (!tab_strip_model_->closing_all())\n       SyncHistoryWithTabs(0);\n   }\n \n  SetAsDelegate(contents->web_contents(), NULL);\n  RemoveScheduledUpdatesFor(contents->web_contents());\n \n   if (find_bar_controller_.get() && index == active_index()) {\n     find_bar_controller_->ChangeWebContents(NULL);\n   }\n \n  search_delegate_->OnTabDetached(contents->web_contents());\n \n   registrar_.Remove(this, content::NOTIFICATION_INTERSTITIAL_ATTACHED,\n                    content::Source<WebContents>(contents->web_contents()));\n   registrar_.Remove(this, content::NOTIFICATION_INTERSTITIAL_DETACHED,\n                    content::Source<WebContents>(contents->web_contents()));\n }\n",
    "code_after_change": "void Browser::TabDetachedAtImpl(TabContents* contents, int index,\nvoid Browser::TabDetachedAtImpl(content::WebContents* contents,\n                                int index,\n                                 DetachType type) {\n   if (type == DETACH_TYPE_DETACH) {\n    if (contents == chrome::GetActiveWebContents(this)) {\n       LocationBar* location_bar = window()->GetLocationBar();\n       if (location_bar)\n        location_bar->SaveStateToContents(contents);\n     }\n \n     if (!tab_strip_model_->closing_all())\n       SyncHistoryWithTabs(0);\n   }\n \n  SetAsDelegate(contents, NULL);\n  RemoveScheduledUpdatesFor(contents);\n \n   if (find_bar_controller_.get() && index == active_index()) {\n     find_bar_controller_->ChangeWebContents(NULL);\n   }\n \n  search_delegate_->OnTabDetached(contents);\n \n   registrar_.Remove(this, content::NOTIFICATION_INTERSTITIAL_ATTACHED,\n                    content::Source<WebContents>(contents));\n   registrar_.Remove(this, content::NOTIFICATION_INTERSTITIAL_DETACHED,\n                    content::Source<WebContents>(contents));\n }\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 332,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2010-4818",
    "code_before_change": " int __glXDispSwap_CreateContext(__GLXclientState *cl, GLbyte *pc)\n {\n     xGLXCreateContextReq *req = (xGLXCreateContextReq *) pc;\n     __GLX_DECLARE_SWAP_VARIABLES;\n \n     __GLX_SWAP_SHORT(&req->length);\n     __GLX_SWAP_INT(&req->context);\n     __GLX_SWAP_INT(&req->visual);\n    return __glXDisp_CreateContext(cl, pc);\n}\n",
    "code_after_change": " int __glXDispSwap_CreateContext(__GLXclientState *cl, GLbyte *pc)\n {\n    ClientPtr client = cl->client;\n     xGLXCreateContextReq *req = (xGLXCreateContextReq *) pc;\n     __GLX_DECLARE_SWAP_VARIABLES;\n \n    REQUEST_SIZE_MATCH(xGLXCreateContextReq);\n\n     __GLX_SWAP_SHORT(&req->length);\n     __GLX_SWAP_INT(&req->context);\n     __GLX_SWAP_INT(&req->visual);\n    return __glXDisp_CreateContext(cl, pc);\n}\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 343,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2016-2464",
    "code_before_change": "void Cues::PreloadCuePoint(long& cue_points_size, long long pos) const {\n  assert(m_count == 0);\n \n   if (m_preload_count >= cue_points_size) {\n     const long n = (cue_points_size <= 0) ? 2048 : 2 * cue_points_size;\n \n    CuePoint** const qq = new CuePoint* [n];\n     CuePoint** q = qq;  // beginning of target\n \n     CuePoint** p = m_cue_points;  // beginning of source\n CuePoint** const pp = p + m_preload_count; // end of source\n\n while (p != pp)\n *q++ = *p++;\n\n delete[] m_cue_points;\n\n    m_cue_points = qq;\n\n     cue_points_size = n;\n   }\n \n  CuePoint* const pCP = new CuePoint(m_preload_count, pos);\n   m_cue_points[m_preload_count++] = pCP;\n }\n",
    "code_after_change": "void Cues::PreloadCuePoint(long& cue_points_size, long long pos) const {\nbool Cues::PreloadCuePoint(long& cue_points_size, long long pos) const {\n  if (m_count != 0)\n    return false;\n \n   if (m_preload_count >= cue_points_size) {\n     const long n = (cue_points_size <= 0) ? 2048 : 2 * cue_points_size;\n \n    CuePoint** const qq = new (std::nothrow) CuePoint*[n];\n    if (qq == NULL)\n      return false;\n\n     CuePoint** q = qq;  // beginning of target\n \n     CuePoint** p = m_cue_points;  // beginning of source\n CuePoint** const pp = p + m_preload_count; // end of source\n\n while (p != pp)\n *q++ = *p++;\n\n delete[] m_cue_points;\n\n    m_cue_points = qq;\n\n     cue_points_size = n;\n   }\n \n  CuePoint* const pCP = new (std::nothrow) CuePoint(m_preload_count, pos);\n  if (pCP == NULL)\n    return false;\n\n   m_cue_points[m_preload_count++] = pCP;\n  return true;\n }\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 353,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2013-7271",
    "code_before_change": "static int hash_recvmsg(struct kiocb *unused, struct socket *sock,\n\t\t\tstruct msghdr *msg, size_t len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct hash_ctx *ctx = ask->private;\n\tunsigned ds = crypto_ahash_digestsize(crypto_ahash_reqtfm(&ctx->req));\n\tint err;\n\n\tif (len > ds)\n\t\tlen = ds;\n \telse if (len < ds)\n \t\tmsg->msg_flags |= MSG_TRUNC;\n \n\tmsg->msg_namelen = 0;\n \tlock_sock(sk);\n \tif (ctx->more) {\n \t\tctx->more = 0;\n\t\tahash_request_set_crypt(&ctx->req, NULL, ctx->result, 0);\n\t\terr = af_alg_wait_for_completion(crypto_ahash_final(&ctx->req),\n\t\t\t\t\t\t &ctx->completion);\n\t\tif (err)\n\t\t\tgoto unlock;\n\t}\n\n\terr = memcpy_toiovec(msg->msg_iov, ctx->result, len);\n\nunlock:\n\trelease_sock(sk);\n\n\treturn err ?: len;\n}\n",
    "code_after_change": "static int hash_recvmsg(struct kiocb *unused, struct socket *sock,\n\t\t\tstruct msghdr *msg, size_t len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct hash_ctx *ctx = ask->private;\n\tunsigned ds = crypto_ahash_digestsize(crypto_ahash_reqtfm(&ctx->req));\n\tint err;\n\n\tif (len > ds)\n\t\tlen = ds;\n \telse if (len < ds)\n \t\tmsg->msg_flags |= MSG_TRUNC;\n \n \tlock_sock(sk);\n \tif (ctx->more) {\n \t\tctx->more = 0;\n\t\tahash_request_set_crypt(&ctx->req, NULL, ctx->result, 0);\n\t\terr = af_alg_wait_for_completion(crypto_ahash_final(&ctx->req),\n\t\t\t\t\t\t &ctx->completion);\n\t\tif (err)\n\t\t\tgoto unlock;\n\t}\n\n\terr = memcpy_toiovec(msg->msg_iov, ctx->result, len);\n\nunlock:\n\trelease_sock(sk);\n\n\treturn err ?: len;\n}\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 367,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2016-10712",
    "code_before_change": "static int php_stream_temp_close(php_stream *stream, int close_handle TSRMLS_DC)\n{\n\tphp_stream_temp_data *ts = (php_stream_temp_data*)stream->abstract;\n\tint ret;\n\n\tassert(ts != NULL);\n\n\tif (ts->innerstream) {\n\t\tret = php_stream_free_enclosed(ts->innerstream, PHP_STREAM_FREE_CLOSE | (close_handle ? 0 : PHP_STREAM_FREE_PRESERVE_HANDLE));\n        } else {\n                ret = 0;\n        }\n        if (ts->meta) {\n                zval_ptr_dtor(&ts->meta);\n        }\n\n\tefree(ts);\n\n\treturn ret;\n}\n",
    "code_after_change": "static int php_stream_temp_close(php_stream *stream, int close_handle TSRMLS_DC)\n{\n\tphp_stream_temp_data *ts = (php_stream_temp_data*)stream->abstract;\n\tint ret;\n\n\tassert(ts != NULL);\n\n\tif (ts->innerstream) {\n\t\tret = php_stream_free_enclosed(ts->innerstream, PHP_STREAM_FREE_CLOSE | (close_handle ? 0 : PHP_STREAM_FREE_PRESERVE_HANDLE));\n        } else {\n                ret = 0;\n        }\n\n        if (ts->meta) {\n                zval_ptr_dtor(&ts->meta);\n        }\n\n\tefree(ts);\n\n\treturn ret;\n}\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 372,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2014-5336",
    "code_before_change": "static inline int mk_vhost_fdt_close(struct session_request *sr)\n{\n    int id;\n    unsigned int hash;\n    struct vhost_fdt_hash_table *ht = NULL;\n    struct vhost_fdt_hash_chain *hc;\n\n    if (config->fdt == MK_FALSE) {\n        return close(sr->fd_file);\n    }\n\n    id   = sr->vhost_fdt_id;\n    hash = sr->vhost_fdt_hash;\n\n    ht = mk_vhost_fdt_table_lookup(id, sr->host_conf);\n    if (mk_unlikely(!ht)) {\n        return close(sr->fd_file);\n    }\n\n    /* We got the hash table, now look around the chains array */\n    hc = mk_vhost_fdt_chain_lookup(hash, ht);\n    if (hc) {\n        /* Increment the readers and check if we should close */\n        hc->readers--;\n        if (hc->readers == 0) {\n            hc->fd   = -1;\n            hc->hash = 0;\n            ht->av_slots++;\n            return close(sr->fd_file);\n        }\n        else {\n             return 0;\n         }\n     }\n     return close(sr->fd_file);\n }\n",
    "code_after_change": "static inline int mk_vhost_fdt_close(struct session_request *sr)\n{\n    int id;\n    unsigned int hash;\n    struct vhost_fdt_hash_table *ht = NULL;\n    struct vhost_fdt_hash_chain *hc;\n\n    if (config->fdt == MK_FALSE) {\n        return close(sr->fd_file);\n    }\n\n    id   = sr->vhost_fdt_id;\n    hash = sr->vhost_fdt_hash;\n\n    ht = mk_vhost_fdt_table_lookup(id, sr->host_conf);\n    if (mk_unlikely(!ht)) {\n        return close(sr->fd_file);\n    }\n\n    /* We got the hash table, now look around the chains array */\n    hc = mk_vhost_fdt_chain_lookup(hash, ht);\n    if (hc) {\n        /* Increment the readers and check if we should close */\n        hc->readers--;\n        if (hc->readers == 0) {\n            hc->fd   = -1;\n            hc->hash = 0;\n            ht->av_slots++;\n            return close(sr->fd_file);\n        }\n        else {\n             return 0;\n         }\n     }\n     return close(sr->fd_file);\n }\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 376,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2016-6711",
    "code_before_change": "static vpx_codec_err_t vp8_peek_si_internal(const uint8_t *data,\n unsigned int data_sz,\n vpx_codec_stream_info_t *si,\n                                            vpx_decrypt_cb decrypt_cb,\n void *decrypt_state)\n{\n vpx_codec_err_t res = VPX_CODEC_OK;\n\n if(data + data_sz <= data)\n {\n        res = VPX_CODEC_INVALID_PARAM;\n }\n else\n {\n /* Parse uncompresssed part of key frame header.\n         * 3 bytes:- including version, frame type and an offset\n         * 3 bytes:- sync code (0x9d, 0x01, 0x2a)\n         * 4 bytes:- including image width and height in the lowest 14 bits\n         *           of each 2-byte value.\n         */\n uint8_t clear_buffer[10];\n const uint8_t *clear = data;\n if (decrypt_cb)\n {\n int n = MIN(sizeof(clear_buffer), data_sz);\n            decrypt_cb(decrypt_state, data, clear_buffer, n);\n            clear = clear_buffer;\n }\n        si->is_kf = 0;\n\n if (data_sz >= 10 && !(clear[0] & 0x01)) /* I-Frame */\n {\n            si->is_kf = 1;\n\n /* vet via sync code */\n if (clear[3] != 0x9d || clear[4] != 0x01 || clear[5] != 0x2a)\n return VPX_CODEC_UNSUP_BITSTREAM;\n\n            si->w = (clear[6] | (clear[7] << 8)) & 0x3fff;\n\n             si->h = (clear[8] | (clear[9] << 8)) & 0x3fff;\n \n             /*printf(\"w=%d, h=%d\\n\", si->w, si->h);*/\n            if (!(si->h | si->w))\n                res = VPX_CODEC_UNSUP_BITSTREAM;\n         }\n         else\n         {\n            res = VPX_CODEC_UNSUP_BITSTREAM;\n }\n }\n\n return res;\n}\n",
    "code_after_change": "static vpx_codec_err_t vp8_peek_si_internal(const uint8_t *data,\n unsigned int data_sz,\n vpx_codec_stream_info_t *si,\n                                            vpx_decrypt_cb decrypt_cb,\n void *decrypt_state)\n{\n vpx_codec_err_t res = VPX_CODEC_OK;\n\n if(data + data_sz <= data)\n {\n        res = VPX_CODEC_INVALID_PARAM;\n }\n else\n {\n /* Parse uncompresssed part of key frame header.\n         * 3 bytes:- including version, frame type and an offset\n         * 3 bytes:- sync code (0x9d, 0x01, 0x2a)\n         * 4 bytes:- including image width and height in the lowest 14 bits\n         *           of each 2-byte value.\n         */\n uint8_t clear_buffer[10];\n const uint8_t *clear = data;\n if (decrypt_cb)\n {\n int n = MIN(sizeof(clear_buffer), data_sz);\n            decrypt_cb(decrypt_state, data, clear_buffer, n);\n            clear = clear_buffer;\n }\n        si->is_kf = 0;\n\n if (data_sz >= 10 && !(clear[0] & 0x01)) /* I-Frame */\n {\n            si->is_kf = 1;\n\n /* vet via sync code */\n if (clear[3] != 0x9d || clear[4] != 0x01 || clear[5] != 0x2a)\n return VPX_CODEC_UNSUP_BITSTREAM;\n\n            si->w = (clear[6] | (clear[7] << 8)) & 0x3fff;\n\n             si->h = (clear[8] | (clear[9] << 8)) & 0x3fff;\n \n             /*printf(\"w=%d, h=%d\\n\", si->w, si->h);*/\n            if (!(si->h && si->w))\n                res = VPX_CODEC_CORRUPT_FRAME;\n         }\n         else\n         {\n            res = VPX_CODEC_UNSUP_BITSTREAM;\n }\n }\n\n return res;\n}\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 383,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2018-20846",
    "code_before_change": "static opj_bool pi_next_pcrl(opj_pi_iterator_t * pi)\n{\n    opj_pi_comp_t *comp = NULL;\n    opj_pi_resolution_t *res = NULL;\n    long index = 0;\n\n    if (!pi->first) {\n        comp = &pi->comps[pi->compno];\n        goto LABEL_SKIP;\n    } else {\n        int compno, resno;\n        pi->first = 0;\n        pi->dx = 0;\n        pi->dy = 0;\n        for (compno = 0; compno < pi->numcomps; compno++) {\n            comp = &pi->comps[compno];\n            for (resno = 0; resno < comp->numresolutions; resno++) {\n                int dx, dy;\n                res = &comp->resolutions[resno];\n                dx = comp->dx * (1 << (res->pdx + comp->numresolutions - 1 - resno));\n                dy = comp->dy * (1 << (res->pdy + comp->numresolutions - 1 - resno));\n                pi->dx = !pi->dx ? dx : int_min(pi->dx, dx);\n                pi->dy = !pi->dy ? dy : int_min(pi->dy, dy);\n            }\n        }\n    }\n    if (!pi->tp_on) {\n        pi->poc.ty0 = pi->ty0;\n        pi->poc.tx0 = pi->tx0;\n        pi->poc.ty1 = pi->ty1;\n        pi->poc.tx1 = pi->tx1;\n    }\n    for (pi->y = pi->poc.ty0; pi->y < pi->poc.ty1;\n            pi->y += pi->dy - (pi->y % pi->dy)) {\n        for (pi->x = pi->poc.tx0; pi->x < pi->poc.tx1;\n                pi->x += pi->dx - (pi->x % pi->dx)) {\n            for (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {\n                comp = &pi->comps[pi->compno];\n                for (pi->resno = pi->poc.resno0;\n                        pi->resno < int_min(pi->poc.resno1, comp->numresolutions); pi->resno++) {\n                    int levelno;\n                    int trx0, try0;\n                    int trx1, try1;\n                    int rpx, rpy;\n                    int prci, prcj;\n                    res = &comp->resolutions[pi->resno];\n                    levelno = comp->numresolutions - 1 - pi->resno;\n                    trx0 = int_ceildiv(pi->tx0, comp->dx << levelno);\n                    try0 = int_ceildiv(pi->ty0, comp->dy << levelno);\n                    trx1 = int_ceildiv(pi->tx1, comp->dx << levelno);\n                    try1 = int_ceildiv(pi->ty1, comp->dy << levelno);\n                    rpx = res->pdx + levelno;\n                    rpy = res->pdy + levelno;\n\n                    /* To avoid divisions by zero / undefined behaviour on shift */\n                    if (rpx >= 31 || ((comp->dx << rpx) >> rpx) != comp->dx ||\n                            rpy >= 31 || ((comp->dy << rpy) >> rpy) != comp->dy) {\n                        continue;\n                    }\n\n                    if (!((pi->y % (comp->dy << rpy) == 0) || ((pi->y == pi->ty0) &&\n                            ((try0 << levelno) % (1 << rpy))))) {\n                        continue;\n                    }\n                    if (!((pi->x % (comp->dx << rpx) == 0) || ((pi->x == pi->tx0) &&\n                            ((trx0 << levelno) % (1 << rpx))))) {\n                        continue;\n                    }\n\n                    if ((res->pw == 0) || (res->ph == 0)) {\n                        continue;\n                    }\n\n                    if ((trx0 == trx1) || (try0 == try1)) {\n                        continue;\n                    }\n\n                    prci = int_floordivpow2(int_ceildiv(pi->x, comp->dx << levelno), res->pdx)\n                           - int_floordivpow2(trx0, res->pdx);\n                    prcj = int_floordivpow2(int_ceildiv(pi->y, comp->dy << levelno), res->pdy)\n                           - int_floordivpow2(try0, res->pdy);\n                    pi->precno = prci + prcj * res->pw;\n                     for (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {\n                         index = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno *\n                                 pi->step_c + pi->precno * pi->step_p;\n                         if (!pi->include[index]) {\n                             pi->include[index] = 1;\n                             return OPJ_TRUE;\n                        }\nLABEL_SKIP:\n                        ;\n                    }\n                }\n            }\n        }\n    }\n\n    return OPJ_FALSE;\n}\n",
    "code_after_change": "static opj_bool pi_next_pcrl(opj_pi_iterator_t * pi)\n{\n    opj_pi_comp_t *comp = NULL;\n    opj_pi_resolution_t *res = NULL;\n    long index = 0;\n\n    if (!pi->first) {\n        comp = &pi->comps[pi->compno];\n        goto LABEL_SKIP;\n    } else {\n        int compno, resno;\n        pi->first = 0;\n        pi->dx = 0;\n        pi->dy = 0;\n        for (compno = 0; compno < pi->numcomps; compno++) {\n            comp = &pi->comps[compno];\n            for (resno = 0; resno < comp->numresolutions; resno++) {\n                int dx, dy;\n                res = &comp->resolutions[resno];\n                dx = comp->dx * (1 << (res->pdx + comp->numresolutions - 1 - resno));\n                dy = comp->dy * (1 << (res->pdy + comp->numresolutions - 1 - resno));\n                pi->dx = !pi->dx ? dx : int_min(pi->dx, dx);\n                pi->dy = !pi->dy ? dy : int_min(pi->dy, dy);\n            }\n        }\n    }\n    if (!pi->tp_on) {\n        pi->poc.ty0 = pi->ty0;\n        pi->poc.tx0 = pi->tx0;\n        pi->poc.ty1 = pi->ty1;\n        pi->poc.tx1 = pi->tx1;\n    }\n    for (pi->y = pi->poc.ty0; pi->y < pi->poc.ty1;\n            pi->y += pi->dy - (pi->y % pi->dy)) {\n        for (pi->x = pi->poc.tx0; pi->x < pi->poc.tx1;\n                pi->x += pi->dx - (pi->x % pi->dx)) {\n            for (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {\n                comp = &pi->comps[pi->compno];\n                for (pi->resno = pi->poc.resno0;\n                        pi->resno < int_min(pi->poc.resno1, comp->numresolutions); pi->resno++) {\n                    int levelno;\n                    int trx0, try0;\n                    int trx1, try1;\n                    int rpx, rpy;\n                    int prci, prcj;\n                    res = &comp->resolutions[pi->resno];\n                    levelno = comp->numresolutions - 1 - pi->resno;\n                    trx0 = int_ceildiv(pi->tx0, comp->dx << levelno);\n                    try0 = int_ceildiv(pi->ty0, comp->dy << levelno);\n                    trx1 = int_ceildiv(pi->tx1, comp->dx << levelno);\n                    try1 = int_ceildiv(pi->ty1, comp->dy << levelno);\n                    rpx = res->pdx + levelno;\n                    rpy = res->pdy + levelno;\n\n                    /* To avoid divisions by zero / undefined behaviour on shift */\n                    if (rpx >= 31 || ((comp->dx << rpx) >> rpx) != comp->dx ||\n                            rpy >= 31 || ((comp->dy << rpy) >> rpy) != comp->dy) {\n                        continue;\n                    }\n\n                    if (!((pi->y % (comp->dy << rpy) == 0) || ((pi->y == pi->ty0) &&\n                            ((try0 << levelno) % (1 << rpy))))) {\n                        continue;\n                    }\n                    if (!((pi->x % (comp->dx << rpx) == 0) || ((pi->x == pi->tx0) &&\n                            ((trx0 << levelno) % (1 << rpx))))) {\n                        continue;\n                    }\n\n                    if ((res->pw == 0) || (res->ph == 0)) {\n                        continue;\n                    }\n\n                    if ((trx0 == trx1) || (try0 == try1)) {\n                        continue;\n                    }\n\n                    prci = int_floordivpow2(int_ceildiv(pi->x, comp->dx << levelno), res->pdx)\n                           - int_floordivpow2(trx0, res->pdx);\n                    prcj = int_floordivpow2(int_ceildiv(pi->y, comp->dy << levelno), res->pdy)\n                           - int_floordivpow2(try0, res->pdy);\n                    pi->precno = prci + prcj * res->pw;\n                     for (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {\n                         index = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno *\n                                 pi->step_c + pi->precno * pi->step_p;\n                        /* Avoids index out of bounds access with include*/\n                        if (index >= pi->include_size) {\n                            opj_pi_emit_error(pi, \"Invalid access to pi->include\");\n                            return OPJ_FALSE;\n                        }\n                         if (!pi->include[index]) {\n                             pi->include[index] = 1;\n                             return OPJ_TRUE;\n                        }\nLABEL_SKIP:\n                        ;\n                    }\n                }\n            }\n        }\n    }\n\n    return OPJ_FALSE;\n}\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 387,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2016-2464",
    "code_before_change": "long ContentEncoding::ParseCompressionEntry(long long start, long long size,\n IMkvReader* pReader,\n ContentCompression* compression) {\n  assert(pReader);\n  assert(compression);\n\n long long pos = start;\n const long long stop = start + size;\n\n bool valid = false;\n\n while (pos < stop) {\n long long id, size;\n const long status = ParseElementHeader(pReader, pos, stop, id, size);\n if (status < 0) // error\n return status;\n\n if (id == 0x254) {\n long long algo = UnserializeUInt(pReader, pos, size);\n if (algo < 0)\n return E_FILE_FORMAT_INVALID;\n      compression->algo = algo;\n      valid = true;\n } else if (id == 0x255) {\n if (size <= 0)\n\n         return E_FILE_FORMAT_INVALID;\n \n       const size_t buflen = static_cast<size_t>(size);\n      typedef unsigned char* buf_t;\n      const buf_t buf = new (std::nothrow) unsigned char[buflen];\n       if (buf == NULL)\n         return -1;\n \n const int read_status =\n          pReader->Read(pos, static_cast<long>(buflen), buf);\n if (read_status) {\n delete[] buf;\n return status;\n }\n\n      compression->settings = buf;\n      compression->settings_len = buflen;\n\n     }\n \n     pos += size;  // consume payload\n    assert(pos <= stop);\n   }\n \n if (!valid)\n return E_FILE_FORMAT_INVALID;\n\n return 0;\n}\n",
    "code_after_change": "long ContentEncoding::ParseCompressionEntry(long long start, long long size,\n IMkvReader* pReader,\n ContentCompression* compression) {\n  assert(pReader);\n  assert(compression);\n\n long long pos = start;\n const long long stop = start + size;\n\n bool valid = false;\n\n while (pos < stop) {\n long long id, size;\n const long status = ParseElementHeader(pReader, pos, stop, id, size);\n if (status < 0) // error\n return status;\n\n if (id == 0x254) {\n long long algo = UnserializeUInt(pReader, pos, size);\n if (algo < 0)\n return E_FILE_FORMAT_INVALID;\n      compression->algo = algo;\n      valid = true;\n } else if (id == 0x255) {\n if (size <= 0)\n\n         return E_FILE_FORMAT_INVALID;\n \n       const size_t buflen = static_cast<size_t>(size);\n      unsigned char* buf = SafeArrayAlloc<unsigned char>(1, buflen);\n       if (buf == NULL)\n         return -1;\n \n const int read_status =\n          pReader->Read(pos, static_cast<long>(buflen), buf);\n if (read_status) {\n delete[] buf;\n return status;\n }\n\n      compression->settings = buf;\n      compression->settings_len = buflen;\n\n     }\n \n     pos += size;  // consume payload\n    if (pos > stop)\n      return E_FILE_FORMAT_INVALID;\n   }\n \n if (!valid)\n return E_FILE_FORMAT_INVALID;\n\n return 0;\n}\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 389,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2016-2464",
    "code_before_change": "long VideoTrack::Seek(long long time_ns, const BlockEntry*& pResult) const {\n const long status = GetFirst(pResult);\n\n if (status < 0) // buffer underflow, etc\n return status;\n\n  assert(pResult);\n\n if (pResult->EOS())\n return 0;\n\n const Cluster* pCluster = pResult->GetCluster();\n  assert(pCluster);\n  assert(pCluster->GetIndex() >= 0);\n\n if (time_ns <= pResult->GetBlock()->GetTime(pCluster))\n return 0;\n\n Cluster** const clusters = m_pSegment->m_clusters;\n  assert(clusters);\n\n const long count = m_pSegment->GetCount(); // loaded only, not pre-loaded\n  assert(count > 0);\n\n Cluster** const i = clusters + pCluster->GetIndex();\n  assert(i);\n  assert(*i == pCluster);\n  assert(pCluster->GetTime() <= time_ns);\n\n Cluster** const j = clusters + count;\n\n Cluster** lo = i;\n Cluster** hi = j;\n\n while (lo < hi) {\n\n Cluster** const mid = lo + (hi - lo) / 2;\n    assert(mid < hi);\n\n    pCluster = *mid;\n    assert(pCluster);\n    assert(pCluster->GetIndex() >= 0);\n    assert(pCluster->GetIndex() == long(mid - m_pSegment->m_clusters));\n\n const long long t = pCluster->GetTime();\n\n if (t <= time_ns)\n      lo = mid + 1;\n else\n      hi = mid;\n\n    assert(lo <= hi);\n }\n\n  assert(lo == hi);\n  assert(lo > i);\n  assert(lo <= j);\n\n  pCluster = *--lo;\n  assert(pCluster);\n  assert(pCluster->GetTime() <= time_ns);\n\n  pResult = pCluster->GetEntry(this, time_ns);\n\n if ((pResult != 0) && !pResult->EOS()) // found a keyframe\n return 0;\n\n while (lo != i) {\n    pCluster = *--lo;\n\n     assert(pCluster);\n     assert(pCluster->GetTime() <= time_ns);\n \n#if 0\n        pResult = pCluster->GetMaxKey(this);\n#else\n     pResult = pCluster->GetEntry(this, time_ns);\n#endif\n \n     if ((pResult != 0) && !pResult->EOS())\n       return 0;\n }\n\n\n  pResult = GetEOS();\n return 0;\n}\n",
    "code_after_change": "long VideoTrack::Seek(long long time_ns, const BlockEntry*& pResult) const {\n const long status = GetFirst(pResult);\n\n if (status < 0) // buffer underflow, etc\n return status;\n\n  assert(pResult);\n\n if (pResult->EOS())\n return 0;\n\n const Cluster* pCluster = pResult->GetCluster();\n  assert(pCluster);\n  assert(pCluster->GetIndex() >= 0);\n\n if (time_ns <= pResult->GetBlock()->GetTime(pCluster))\n return 0;\n\n Cluster** const clusters = m_pSegment->m_clusters;\n  assert(clusters);\n\n const long count = m_pSegment->GetCount(); // loaded only, not pre-loaded\n  assert(count > 0);\n\n Cluster** const i = clusters + pCluster->GetIndex();\n  assert(i);\n  assert(*i == pCluster);\n  assert(pCluster->GetTime() <= time_ns);\n\n Cluster** const j = clusters + count;\n\n Cluster** lo = i;\n Cluster** hi = j;\n\n while (lo < hi) {\n\n Cluster** const mid = lo + (hi - lo) / 2;\n    assert(mid < hi);\n\n    pCluster = *mid;\n    assert(pCluster);\n    assert(pCluster->GetIndex() >= 0);\n    assert(pCluster->GetIndex() == long(mid - m_pSegment->m_clusters));\n\n const long long t = pCluster->GetTime();\n\n if (t <= time_ns)\n      lo = mid + 1;\n else\n      hi = mid;\n\n    assert(lo <= hi);\n }\n\n  assert(lo == hi);\n  assert(lo > i);\n  assert(lo <= j);\n\n  pCluster = *--lo;\n  assert(pCluster);\n  assert(pCluster->GetTime() <= time_ns);\n\n  pResult = pCluster->GetEntry(this, time_ns);\n\n if ((pResult != 0) && !pResult->EOS()) // found a keyframe\n return 0;\n\n while (lo != i) {\n    pCluster = *--lo;\n\n     assert(pCluster);\n     assert(pCluster->GetTime() <= time_ns);\n \n     pResult = pCluster->GetEntry(this, time_ns);\n \n     if ((pResult != 0) && !pResult->EOS())\n       return 0;\n }\n\n\n  pResult = GetEOS();\n return 0;\n}\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 419,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2011-2839",
    "code_before_change": "void ExtensionTtsController::SetPlatformImpl(\n    ExtensionTtsPlatformImpl* platform_impl) {\n  platform_impl_ = platform_impl;\n}\n",
    "code_after_change": "void ExtensionTtsController::SetPlatformImpl(\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 422,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2013-7294",
    "code_before_change": "stf_status ikev2parent_inI1outR1(struct msg_digest *md)\n{\n\tstruct state *st = md->st;\n\tlset_t policy = POLICY_IKEV2_ALLOW;\n\tstruct connection *c = find_host_connection(&md->iface->ip_addr,\n\t\t\t\t\t\t    md->iface->port,\n\t\t\t\t\t\t    &md->sender,\n\t\t\t\t\t\t    md->sender_port,\n\t\t\t\t\t\t    POLICY_IKEV2_ALLOW);\n\n\t/* retrieve st->st_gi */\n\n#if 0\n\tif (c == NULL) {\n\t\t/*\n\t\t * make up a policy from the thing that was proposed, and see\n\t\t * if we can find a connection with that policy.\n\t\t */\n\n\t\tpb_stream pre_sa_pbs = sa_pd->pbs;\n\t\tpolicy = preparse_isakmp_sa_body(&pre_sa_pbs);\n\t\tc = find_host_connection(&md->iface->ip_addr, pluto_port,\n\t\t\t\t\t (ip_address*)NULL, md->sender_port,\n\t\t\t\t\t policy);\n\n\t}\n#endif\n\n\tif (c == NULL) {\n\n\t\t/* See if a wildcarded connection can be found.\n\t\t * We cannot pick the right connection, so we're making a guess.\n\t\t * All Road Warrior connections are fair game:\n\t\t * we pick the first we come across (if any).\n\t\t * If we don't find any, we pick the first opportunistic\n\t\t * with the smallest subnet that includes the peer.\n\t\t * There is, of course, no necessary relationship between\n\t\t * an Initiator's address and that of its client,\n\t\t * but Food Groups kind of assumes one.\n\t\t */\n\t\t{\n\t\t\tstruct connection *d;\n\t\t\td = find_host_connection(&md->iface->ip_addr,\n\t\t\t\t\t\t pluto_port,\n\t\t\t\t\t\t (ip_address*)NULL,\n\t\t\t\t\t\t md->sender_port, policy);\n\n\t\t\tfor (; d != NULL; d = d->hp_next) {\n\t\t\t\tif (d->kind == CK_GROUP) {\n\t\t\t\t\t/* ignore */\n\t\t\t\t} else {\n\t\t\t\t\tif (d->kind == CK_TEMPLATE &&\n\t\t\t\t\t    !(d->policy & POLICY_OPPO)) {\n\t\t\t\t\t\t/* must be Road Warrior: we have a winner */\n\t\t\t\t\t\tc = d;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Opportunistic or Shunt: pick tightest match */\n\t\t\t\t\tif (addrinsubnet(&md->sender,\n\t\t\t\t\t\t\t &d->spd.that.client)\n\t\t\t\t\t    &&\n\t\t\t\t\t    (c == NULL ||\n\t\t\t\t\t     !subnetinsubnet(&c->spd.that.\n\t\t\t\t\t\t\t     client,\n\t\t\t\t\t\t\t     &d->spd.that.\n\t\t\t\t\t\t\t     client)))\n\t\t\t\t\t\tc = d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (c == NULL) {\n\t\t\tloglog(RC_LOG_SERIOUS, \"initial parent SA message received on %s:%u\"\n\t\t\t       \" but no connection has been authorized%s%s\",\n\t\t\t       ip_str(\n\t\t\t\t       &md->iface->ip_addr),\n\t\t\t       ntohs(portof(&md->iface->ip_addr)),\n\t\t\t       (policy != LEMPTY) ? \" with policy=\" : \"\",\n\t\t\t       (policy !=\n\t\t\t\tLEMPTY) ? bitnamesof(sa_policy_bit_names,\n\t\t\t\t\t\t     policy) : \"\");\n\t\t\treturn STF_FAIL + v2N_NO_PROPOSAL_CHOSEN;\n\t\t}\n\t\tif (c->kind != CK_TEMPLATE) {\n\t\t\tloglog(RC_LOG_SERIOUS, \"initial parent SA message received on %s:%u\"\n\t\t\t       \" but \\\"%s\\\" forbids connection\",\n\t\t\t       ip_str(\n\t\t\t\t       &md->iface->ip_addr), pluto_port,\n\t\t\t       c->name);\n\t\t\treturn STF_FAIL + v2N_NO_PROPOSAL_CHOSEN;\n\t\t}\n\t\tc = rw_instantiate(c, &md->sender, NULL, NULL);\n\n\t} else {\n\t\t/* we found a non-wildcard conn. double check if it needs instantiation anyway (eg vnet=) */\n\t\t/* vnet=/vhost= should have set CK_TEMPLATE on connection loading */\n\t\tif ((c->kind == CK_TEMPLATE) && c->spd.that.virt) {\n\t\t\tDBG(DBG_CONTROL,\n\t\t\t    DBG_log(\n\t\t\t\t    \"local endpoint has virt (vnet/vhost) set without wildcards - needs instantiation\"));\n\t\t\tc = rw_instantiate(c, &md->sender, NULL, NULL);\n\t\t} else if ((c->kind == CK_TEMPLATE) &&\n\t\t\t   (c->policy & POLICY_IKEV2_ALLOW_NARROWING)) {\n\t\t\tDBG(DBG_CONTROL,\n\t\t\t    DBG_log(\n\t\t\t\t    \"local endpoint has narrowing=yes - needs instantiation\"));\n\t\t\tc = rw_instantiate(c, &md->sender, NULL, NULL);\n\t\t}\n\t}\n\n\tDBG_log(\"found connection: %s\\n\", c ? c->name : \"<none>\");\n\n\tif (!st) {\n\t\tst = new_state();\n\t\t/* set up new state */\n\t\tmemcpy(st->st_icookie, md->hdr.isa_icookie, COOKIE_SIZE);\n\t\t/* initialize_new_state expects valid icookie/rcookie values, so create it now */\n\t\tget_cookie(FALSE, st->st_rcookie, COOKIE_SIZE, &md->sender);\n\t\tinitialize_new_state(st, c, policy, 0, NULL_FD,\n\t\t\t\t     pcim_stranger_crypto);\n\t\tst->st_ikev2 = TRUE;\n\t\tchange_state(st, STATE_PARENT_R1);\n\t\tst->st_msgid_lastack = INVALID_MSGID;\n\t\tst->st_msgid_nextuse = 0;\n\n\t\tmd->st = st;\n\t\tmd->from_state = STATE_IKEv2_BASE;\n\t}\n\n\t/* check,as a responder, are we under dos attack or not\n\t * if yes go to 6 message exchange mode. it is a config option for now.\n\t * TBD set force_busy dynamically\n\t * Paul: Can we check for STF_TOOMUCHCRYPTO ?\n\t */\n\tif (force_busy == TRUE) {\n\t\tu_char dcookie[SHA1_DIGEST_SIZE];\n\t\tchunk_t dc;\n\t\tikev2_get_dcookie( dcookie, st->st_ni, &md->sender,\n\t\t\t\t   st->st_icookie);\n\t\tdc.ptr = dcookie;\n\t\tdc.len = SHA1_DIGEST_SIZE;\n\n\t\t/* check if I1 packet contian KE and a v2N payload with type COOKIE */\n\t\tif ( md->chain[ISAKMP_NEXT_v2KE] &&\n\t\t     md->chain[ISAKMP_NEXT_v2N] &&\n\t\t     (md->chain[ISAKMP_NEXT_v2N]->payload.v2n.isan_type ==\n\t\t      v2N_COOKIE)) {\n\t\t\tu_int8_t spisize;\n\t\t\tconst pb_stream *dc_pbs;\n\t\t\tchunk_t blob;\n\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t    DBG_log(\"received a DOS cookie in I1 verify it\"));\n\t\t\t/* we received dcookie we send earlier verify it */\n\t\t\tspisize =\n\t\t\t\tmd->chain[ISAKMP_NEXT_v2N]->payload.v2n.\n\t\t\t\tisan_spisize;\n\t\t\tdc_pbs = &md->chain[ISAKMP_NEXT_v2N]->pbs;\n\t\t\tblob.ptr = dc_pbs->cur + spisize;\n\t\t\tblob.len = pbs_left(dc_pbs) - spisize;\n\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t    DBG_dump_chunk(\"dcookie received in I1 Packet\",\n\t\t\t\t\t   blob);\n\t\t\t    DBG_dump(\"dcookie computed\", dcookie,\n\t\t\t\t     SHA1_DIGEST_SIZE));\n\n\t\t\tif (memcmp(blob.ptr, dcookie, SHA1_DIGEST_SIZE) != 0) {\n\t\t\t\tlibreswan_log(\n\t\t\t\t\t\"mismatch in DOS v2N_COOKIE,send a new one\");\n\t\t\t\tSEND_NOTIFICATION_AA(v2N_COOKIE, &dc);\n\t\t\t\treturn STF_FAIL + v2N_INVALID_IKE_SPI;\n\t\t\t}\n\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t    DBG_log(\"dcookie received match with computed one\"));\n\t\t} else {\n\t\t\t/* we are under DOS attack I1 contains no DOS COOKIE */\n\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t    DBG_log(\n\t\t\t\t    \"busy mode on. receieved I1 without a valid dcookie\");\n\t\t\t    DBG_log(\"send a dcookie and forget this state\"));\n\t\t\tSEND_NOTIFICATION_AA(v2N_COOKIE, &dc);\n\t\t\treturn STF_FAIL;\n\t\t}\n\t} else {\n\t\tDBG(DBG_CONTROLMORE,\n\t\t    DBG_log(\"will not send/process a dcookie\"));\n\n\t}\n\n\t/*\n\t * We have to agree to the DH group before we actually know who\n\t * we are talking to.   If we support the group, we use it.\n\t *\n\t * It is really too hard here to go through all the possible policies\n\t * that might permit this group.  If we think we are being DOS'ed\n\t * then we should demand a cookie.\n \t */\n \t{\n \t\tstruct ikev2_ke *ke;\n \t\tke = &md->chain[ISAKMP_NEXT_v2KE]->payload.v2ke;\n \n \t\tst->st_oakley.group = lookup_group(ke->isak_group);\n \t\tif (st->st_oakley.group == NULL) {\n\t\t\tchar fromname[ADDRTOT_BUF];\n\t\t\taddrtot(&md->sender, 0, fromname, ADDRTOT_BUF);\n \t\t\tlibreswan_log(\n \t\t\t\t\"rejecting I1 from %s:%u, invalid DH group=%u\",\n \t\t\t\tfromname, md->sender_port,\n \t\t\t\tke->isak_group);\n\t\t\treturn v2N_INVALID_KE_PAYLOAD;\n \t\t}\n \t}\n \n\t/* now. we need to go calculate the nonce, and the KE */\n\t{\n\t\tstruct ke_continuation *ke = alloc_thing(\n\t\t\tstruct ke_continuation,\n\t\t\t\"ikev2_inI1outR1 KE\");\n\t\tstf_status e;\n\n\t\tke->md = md;\n\t\tset_suspended(st, ke->md);\n\n\t\tif (!st->st_sec_in_use) {\n\t\t\tpcrc_init(&ke->ke_pcrc);\n\t\t\tke->ke_pcrc.pcrc_func =\n\t\t\t\tikev2_parent_inI1outR1_continue;\n\t\t\te = build_ke(&ke->ke_pcrc, st, st->st_oakley.group,\n\t\t\t\t     pcim_stranger_crypto);\n\t\t\tif (e != STF_SUSPEND && e != STF_INLINE) {\n\t\t\t\tloglog(RC_CRYPTOFAILED, \"system too busy\");\n\t\t\t\tdelete_state(st);\n\t\t\t}\n\t\t} else {\n\t\t\te =\n\t\t\t\tikev2_parent_inI1outR1_tail((struct\n\t\t\t\t\t\t\t     pluto_crypto_req_cont\n\t\t\t\t\t\t\t     *)ke,\n\t\t\t\t\t\t\t    NULL);\n\t\t}\n\n\t\treset_globals();\n\n\t\treturn e;\n\t}\n}\n",
    "code_after_change": "stf_status ikev2parent_inI1outR1(struct msg_digest *md)\n{\n\tstruct state *st = md->st;\n\tlset_t policy = POLICY_IKEV2_ALLOW;\n\tstruct connection *c = find_host_connection(&md->iface->ip_addr,\n\t\t\t\t\t\t    md->iface->port,\n\t\t\t\t\t\t    &md->sender,\n\t\t\t\t\t\t    md->sender_port,\n\t\t\t\t\t\t    POLICY_IKEV2_ALLOW);\n\n\t/* retrieve st->st_gi */\n\n#if 0\n\tif (c == NULL) {\n\t\t/*\n\t\t * make up a policy from the thing that was proposed, and see\n\t\t * if we can find a connection with that policy.\n\t\t */\n\n\t\tpb_stream pre_sa_pbs = sa_pd->pbs;\n\t\tpolicy = preparse_isakmp_sa_body(&pre_sa_pbs);\n\t\tc = find_host_connection(&md->iface->ip_addr, pluto_port,\n\t\t\t\t\t (ip_address*)NULL, md->sender_port,\n\t\t\t\t\t policy);\n\n\t}\n#endif\n\n\tif (c == NULL) {\n\n\t\t/* See if a wildcarded connection can be found.\n\t\t * We cannot pick the right connection, so we're making a guess.\n\t\t * All Road Warrior connections are fair game:\n\t\t * we pick the first we come across (if any).\n\t\t * If we don't find any, we pick the first opportunistic\n\t\t * with the smallest subnet that includes the peer.\n\t\t * There is, of course, no necessary relationship between\n\t\t * an Initiator's address and that of its client,\n\t\t * but Food Groups kind of assumes one.\n\t\t */\n\t\t{\n\t\t\tstruct connection *d;\n\t\t\td = find_host_connection(&md->iface->ip_addr,\n\t\t\t\t\t\t pluto_port,\n\t\t\t\t\t\t (ip_address*)NULL,\n\t\t\t\t\t\t md->sender_port, policy);\n\n\t\t\tfor (; d != NULL; d = d->hp_next) {\n\t\t\t\tif (d->kind == CK_GROUP) {\n\t\t\t\t\t/* ignore */\n\t\t\t\t} else {\n\t\t\t\t\tif (d->kind == CK_TEMPLATE &&\n\t\t\t\t\t    !(d->policy & POLICY_OPPO)) {\n\t\t\t\t\t\t/* must be Road Warrior: we have a winner */\n\t\t\t\t\t\tc = d;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Opportunistic or Shunt: pick tightest match */\n\t\t\t\t\tif (addrinsubnet(&md->sender,\n\t\t\t\t\t\t\t &d->spd.that.client)\n\t\t\t\t\t    &&\n\t\t\t\t\t    (c == NULL ||\n\t\t\t\t\t     !subnetinsubnet(&c->spd.that.\n\t\t\t\t\t\t\t     client,\n\t\t\t\t\t\t\t     &d->spd.that.\n\t\t\t\t\t\t\t     client)))\n\t\t\t\t\t\tc = d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (c == NULL) {\n\t\t\tloglog(RC_LOG_SERIOUS, \"initial parent SA message received on %s:%u\"\n\t\t\t       \" but no connection has been authorized%s%s\",\n\t\t\t       ip_str(\n\t\t\t\t       &md->iface->ip_addr),\n\t\t\t       ntohs(portof(&md->iface->ip_addr)),\n\t\t\t       (policy != LEMPTY) ? \" with policy=\" : \"\",\n\t\t\t       (policy !=\n\t\t\t\tLEMPTY) ? bitnamesof(sa_policy_bit_names,\n\t\t\t\t\t\t     policy) : \"\");\n\t\t\treturn STF_FAIL + v2N_NO_PROPOSAL_CHOSEN;\n\t\t}\n\t\tif (c->kind != CK_TEMPLATE) {\n\t\t\tloglog(RC_LOG_SERIOUS, \"initial parent SA message received on %s:%u\"\n\t\t\t       \" but \\\"%s\\\" forbids connection\",\n\t\t\t       ip_str(\n\t\t\t\t       &md->iface->ip_addr), pluto_port,\n\t\t\t       c->name);\n\t\t\treturn STF_FAIL + v2N_NO_PROPOSAL_CHOSEN;\n\t\t}\n\t\tc = rw_instantiate(c, &md->sender, NULL, NULL);\n\n\t} else {\n\t\t/* we found a non-wildcard conn. double check if it needs instantiation anyway (eg vnet=) */\n\t\t/* vnet=/vhost= should have set CK_TEMPLATE on connection loading */\n\t\tif ((c->kind == CK_TEMPLATE) && c->spd.that.virt) {\n\t\t\tDBG(DBG_CONTROL,\n\t\t\t    DBG_log(\n\t\t\t\t    \"local endpoint has virt (vnet/vhost) set without wildcards - needs instantiation\"));\n\t\t\tc = rw_instantiate(c, &md->sender, NULL, NULL);\n\t\t} else if ((c->kind == CK_TEMPLATE) &&\n\t\t\t   (c->policy & POLICY_IKEV2_ALLOW_NARROWING)) {\n\t\t\tDBG(DBG_CONTROL,\n\t\t\t    DBG_log(\n\t\t\t\t    \"local endpoint has narrowing=yes - needs instantiation\"));\n\t\t\tc = rw_instantiate(c, &md->sender, NULL, NULL);\n\t\t}\n\t}\n\n\tDBG_log(\"found connection: %s\\n\", c ? c->name : \"<none>\");\n\n\tif (!st) {\n\t\tst = new_state();\n\t\t/* set up new state */\n\t\tmemcpy(st->st_icookie, md->hdr.isa_icookie, COOKIE_SIZE);\n\t\t/* initialize_new_state expects valid icookie/rcookie values, so create it now */\n\t\tget_cookie(FALSE, st->st_rcookie, COOKIE_SIZE, &md->sender);\n\t\tinitialize_new_state(st, c, policy, 0, NULL_FD,\n\t\t\t\t     pcim_stranger_crypto);\n\t\tst->st_ikev2 = TRUE;\n\t\tchange_state(st, STATE_PARENT_R1);\n\t\tst->st_msgid_lastack = INVALID_MSGID;\n\t\tst->st_msgid_nextuse = 0;\n\n\t\tmd->st = st;\n\t\tmd->from_state = STATE_IKEv2_BASE;\n\t}\n\n\t/* check,as a responder, are we under dos attack or not\n\t * if yes go to 6 message exchange mode. it is a config option for now.\n\t * TBD set force_busy dynamically\n\t * Paul: Can we check for STF_TOOMUCHCRYPTO ?\n\t */\n\tif (force_busy == TRUE) {\n\t\tu_char dcookie[SHA1_DIGEST_SIZE];\n\t\tchunk_t dc;\n\t\tikev2_get_dcookie( dcookie, st->st_ni, &md->sender,\n\t\t\t\t   st->st_icookie);\n\t\tdc.ptr = dcookie;\n\t\tdc.len = SHA1_DIGEST_SIZE;\n\n\t\t/* check if I1 packet contian KE and a v2N payload with type COOKIE */\n\t\tif ( md->chain[ISAKMP_NEXT_v2KE] &&\n\t\t     md->chain[ISAKMP_NEXT_v2N] &&\n\t\t     (md->chain[ISAKMP_NEXT_v2N]->payload.v2n.isan_type ==\n\t\t      v2N_COOKIE)) {\n\t\t\tu_int8_t spisize;\n\t\t\tconst pb_stream *dc_pbs;\n\t\t\tchunk_t blob;\n\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t    DBG_log(\"received a DOS cookie in I1 verify it\"));\n\t\t\t/* we received dcookie we send earlier verify it */\n\t\t\tspisize =\n\t\t\t\tmd->chain[ISAKMP_NEXT_v2N]->payload.v2n.\n\t\t\t\tisan_spisize;\n\t\t\tdc_pbs = &md->chain[ISAKMP_NEXT_v2N]->pbs;\n\t\t\tblob.ptr = dc_pbs->cur + spisize;\n\t\t\tblob.len = pbs_left(dc_pbs) - spisize;\n\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t    DBG_dump_chunk(\"dcookie received in I1 Packet\",\n\t\t\t\t\t   blob);\n\t\t\t    DBG_dump(\"dcookie computed\", dcookie,\n\t\t\t\t     SHA1_DIGEST_SIZE));\n\n\t\t\tif (memcmp(blob.ptr, dcookie, SHA1_DIGEST_SIZE) != 0) {\n\t\t\t\tlibreswan_log(\n\t\t\t\t\t\"mismatch in DOS v2N_COOKIE,send a new one\");\n\t\t\t\tSEND_NOTIFICATION_AA(v2N_COOKIE, &dc);\n\t\t\t\treturn STF_FAIL + v2N_INVALID_IKE_SPI;\n\t\t\t}\n\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t    DBG_log(\"dcookie received match with computed one\"));\n\t\t} else {\n\t\t\t/* we are under DOS attack I1 contains no DOS COOKIE */\n\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t    DBG_log(\n\t\t\t\t    \"busy mode on. receieved I1 without a valid dcookie\");\n\t\t\t    DBG_log(\"send a dcookie and forget this state\"));\n\t\t\tSEND_NOTIFICATION_AA(v2N_COOKIE, &dc);\n\t\t\treturn STF_FAIL;\n\t\t}\n\t} else {\n\t\tDBG(DBG_CONTROLMORE,\n\t\t    DBG_log(\"will not send/process a dcookie\"));\n\n\t}\n\n\t/*\n\t * We have to agree to the DH group before we actually know who\n\t * we are talking to.   If we support the group, we use it.\n\t *\n\t * It is really too hard here to go through all the possible policies\n\t * that might permit this group.  If we think we are being DOS'ed\n\t * then we should demand a cookie.\n \t */\n \t{\n \t\tstruct ikev2_ke *ke;\n\t\tchar fromname[ADDRTOT_BUF];\n\t\taddrtot(&md->sender, 0, fromname, ADDRTOT_BUF);\n\n\t\tif (!md->chain[ISAKMP_NEXT_v2KE]) {\n\t\t\t/* is this a notify? If so, log it */\n\t\t\tif(md->chain[ISAKMP_NEXT_v2N]) {\n\t\t\t\tlibreswan_log(\"Received Notify(%d): %s\",\n\t\t\t\t\tmd->chain[ISAKMP_NEXT_v2N]->payload.v2n.isan_type,\n\t\t\t\t\tenum_name(&ikev2_notify_names,\n\t\t\t\t\t\tmd->chain[ISAKMP_NEXT_v2N]->payload.v2n.isan_type));\n\t\t\t}\n\t\t\tlibreswan_log(\n\t\t\t\t\"rejecting I1 from %s:%u, no KE payload present\",\n\t\t\t\tfromname, md->sender_port);\n\t\t\treturn STF_FAIL + v2N_INVALID_KE_PAYLOAD;\n\t\t}\n \t\tke = &md->chain[ISAKMP_NEXT_v2KE]->payload.v2ke;\n \n \t\tst->st_oakley.group = lookup_group(ke->isak_group);\n \t\tif (st->st_oakley.group == NULL) {\n \t\t\tlibreswan_log(\n \t\t\t\t\"rejecting I1 from %s:%u, invalid DH group=%u\",\n \t\t\t\tfromname, md->sender_port,\n \t\t\t\tke->isak_group);\n\t\t\treturn STF_FAIL + v2N_INVALID_KE_PAYLOAD;\n \t\t}\n \t}\n \n\t/* now. we need to go calculate the nonce, and the KE */\n\t{\n\t\tstruct ke_continuation *ke = alloc_thing(\n\t\t\tstruct ke_continuation,\n\t\t\t\"ikev2_inI1outR1 KE\");\n\t\tstf_status e;\n\n\t\tke->md = md;\n\t\tset_suspended(st, ke->md);\n\n\t\tif (!st->st_sec_in_use) {\n\t\t\tpcrc_init(&ke->ke_pcrc);\n\t\t\tke->ke_pcrc.pcrc_func =\n\t\t\t\tikev2_parent_inI1outR1_continue;\n\t\t\te = build_ke(&ke->ke_pcrc, st, st->st_oakley.group,\n\t\t\t\t     pcim_stranger_crypto);\n\t\t\tif (e != STF_SUSPEND && e != STF_INLINE) {\n\t\t\t\tloglog(RC_CRYPTOFAILED, \"system too busy\");\n\t\t\t\tdelete_state(st);\n\t\t\t}\n\t\t} else {\n\t\t\te =\n\t\t\t\tikev2_parent_inI1outR1_tail((struct\n\t\t\t\t\t\t\t     pluto_crypto_req_cont\n\t\t\t\t\t\t\t     *)ke,\n\t\t\t\t\t\t\t    NULL);\n\t\t}\n\n\t\treset_globals();\n\n\t\treturn e;\n\t}\n}\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 431,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2013-7271",
    "code_before_change": "static int vmci_transport_dgram_dequeue(struct kiocb *kiocb,\n\t\t\t\t\tstruct vsock_sock *vsk,\n\t\t\t\t\tstruct msghdr *msg, size_t len,\n\t\t\t\t\tint flags)\n{\n\tint err;\n\tint noblock;\n\tstruct vmci_datagram *dg;\n\tsize_t payload_len;\n\tstruct sk_buff *skb;\n\n\tnoblock = flags & MSG_DONTWAIT;\n\n \tif (flags & MSG_OOB || flags & MSG_ERRQUEUE)\n \t\treturn -EOPNOTSUPP;\n \n\tmsg->msg_namelen = 0;\n \t/* Retrieve the head sk_buff from the socket's receive queue. */\n \terr = 0;\n \tskb = skb_recv_datagram(&vsk->sk, flags, noblock, &err);\n\tif (err)\n\t\treturn err;\n\n\tif (!skb)\n\t\treturn -EAGAIN;\n\n\tdg = (struct vmci_datagram *)skb->data;\n\tif (!dg)\n\t\t/* err is 0, meaning we read zero bytes. */\n\t\tgoto out;\n\n\tpayload_len = dg->payload_size;\n\t/* Ensure the sk_buff matches the payload size claimed in the packet. */\n\tif (payload_len != skb->len - sizeof(*dg)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (payload_len > len) {\n\t\tpayload_len = len;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\n\t/* Place the datagram payload in the user's iovec. */\n\terr = skb_copy_datagram_iovec(skb, sizeof(*dg), msg->msg_iov,\n\t\tpayload_len);\n\tif (err)\n\t\tgoto out;\n\n\tif (msg->msg_name) {\n\t\tstruct sockaddr_vm *vm_addr;\n\n\t\t/* Provide the address of the sender. */\n\t\tvm_addr = (struct sockaddr_vm *)msg->msg_name;\n\t\tvsock_addr_init(vm_addr, dg->src.context, dg->src.resource);\n\t\tmsg->msg_namelen = sizeof(*vm_addr);\n\t}\n\terr = payload_len;\n\nout:\n\tskb_free_datagram(&vsk->sk, skb);\n\treturn err;\n}\n",
    "code_after_change": "static int vmci_transport_dgram_dequeue(struct kiocb *kiocb,\n\t\t\t\t\tstruct vsock_sock *vsk,\n\t\t\t\t\tstruct msghdr *msg, size_t len,\n\t\t\t\t\tint flags)\n{\n\tint err;\n\tint noblock;\n\tstruct vmci_datagram *dg;\n\tsize_t payload_len;\n\tstruct sk_buff *skb;\n\n\tnoblock = flags & MSG_DONTWAIT;\n\n \tif (flags & MSG_OOB || flags & MSG_ERRQUEUE)\n \t\treturn -EOPNOTSUPP;\n \n \t/* Retrieve the head sk_buff from the socket's receive queue. */\n \terr = 0;\n \tskb = skb_recv_datagram(&vsk->sk, flags, noblock, &err);\n\tif (err)\n\t\treturn err;\n\n\tif (!skb)\n\t\treturn -EAGAIN;\n\n\tdg = (struct vmci_datagram *)skb->data;\n\tif (!dg)\n\t\t/* err is 0, meaning we read zero bytes. */\n\t\tgoto out;\n\n\tpayload_len = dg->payload_size;\n\t/* Ensure the sk_buff matches the payload size claimed in the packet. */\n\tif (payload_len != skb->len - sizeof(*dg)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (payload_len > len) {\n\t\tpayload_len = len;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\n\t/* Place the datagram payload in the user's iovec. */\n\terr = skb_copy_datagram_iovec(skb, sizeof(*dg), msg->msg_iov,\n\t\tpayload_len);\n\tif (err)\n\t\tgoto out;\n\n\tif (msg->msg_name) {\n\t\tstruct sockaddr_vm *vm_addr;\n\n\t\t/* Provide the address of the sender. */\n\t\tvm_addr = (struct sockaddr_vm *)msg->msg_name;\n\t\tvsock_addr_init(vm_addr, dg->src.context, dg->src.resource);\n\t\tmsg->msg_namelen = sizeof(*vm_addr);\n\t}\n\terr = payload_len;\n\nout:\n\tskb_free_datagram(&vsk->sk, skb);\n\treturn err;\n}\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 437,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2016-2487",
    "code_before_change": "void SoftOpus::onQueueFilled(OMX_U32 portIndex) {\n List<BufferInfo *> &inQueue = getPortQueue(0);\n List<BufferInfo *> &outQueue = getPortQueue(1);\n\n if (mOutputPortSettingsChange != NONE) {\n return;\n }\n\n if (portIndex == 0 && mInputBufferCount < 3) {\n BufferInfo *info = *inQueue.begin();\n        OMX_BUFFERHEADERTYPE *header = info->mHeader;\n\n const uint8_t *data = header->pBuffer + header->nOffset;\n size_t size = header->nFilledLen;\n\n if (mInputBufferCount == 0) {\n            CHECK(mHeader == NULL);\n            mHeader = new OpusHeader();\n            memset(mHeader, 0, sizeof(*mHeader));\n if (!ParseOpusHeader(data, size, mHeader)) {\n                ALOGV(\"Parsing Opus Header failed.\");\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n return;\n }\n\n uint8_t channel_mapping[kMaxChannels] = {0};\n if (mHeader->channels <= kMaxChannelsWithDefaultLayout) {\n                memcpy(&channel_mapping,\n                       kDefaultOpusChannelLayout,\n                       kMaxChannelsWithDefaultLayout);\n } else {\n                memcpy(&channel_mapping,\n                       mHeader->stream_map,\n                       mHeader->channels);\n }\n\n int status = OPUS_INVALID_STATE;\n            mDecoder = opus_multistream_decoder_create(kRate,\n                                                       mHeader->channels,\n                                                       mHeader->num_streams,\n                                                       mHeader->num_coupled,\n                                                       channel_mapping,\n &status);\n if (!mDecoder || status != OPUS_OK) {\n                ALOGV(\"opus_multistream_decoder_create failed status=%s\",\n                      opus_strerror(status));\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n return;\n }\n            status =\n                opus_multistream_decoder_ctl(mDecoder,\n                                             OPUS_SET_GAIN(mHeader->gain_db));\n if (status != OPUS_OK) {\n                ALOGV(\"Failed to set OPUS header gain; status=%s\",\n                      opus_strerror(status));\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n return;\n }\n } else if (mInputBufferCount == 1) {\n            mCodecDelay = ns_to_samples(\n *(reinterpret_cast<int64_t*>(header->pBuffer +\n                                                           header->nOffset)),\n                              kRate);\n            mSamplesToDiscard = mCodecDelay;\n } else {\n            mSeekPreRoll = ns_to_samples(\n *(reinterpret_cast<int64_t*>(header->pBuffer +\n                                                            header->nOffset)),\n                               kRate);\n            notify(OMX_EventPortSettingsChanged, 1, 0, NULL);\n            mOutputPortSettingsChange = AWAITING_DISABLED;\n }\n\n        inQueue.erase(inQueue.begin());\n        info->mOwnedByUs = false;\n        notifyEmptyBufferDone(header);\n ++mInputBufferCount;\n return;\n }\n\n while (!inQueue.empty() && !outQueue.empty()) {\n BufferInfo *inInfo = *inQueue.begin();\n        OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;\n\n if (inHeader->nFlags & OMX_BUFFERFLAG_CODECCONFIG) {\n            inQueue.erase(inQueue.begin());\n            inInfo->mOwnedByUs = false;\n            notifyEmptyBufferDone(inHeader);\n return;\n }\n\n BufferInfo *outInfo = *outQueue.begin();\n        OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;\n\n if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {\n            inQueue.erase(inQueue.begin());\n            inInfo->mOwnedByUs = false;\n            notifyEmptyBufferDone(inHeader);\n\n            outHeader->nFilledLen = 0;\n            outHeader->nFlags = OMX_BUFFERFLAG_EOS;\n\n            outQueue.erase(outQueue.begin());\n            outInfo->mOwnedByUs = false;\n            notifyFillBufferDone(outHeader);\n return;\n }\n\n if (inHeader->nOffset == 0) {\n            mAnchorTimeUs = inHeader->nTimeStamp;\n            mNumFramesOutput = 0;\n }\n\n if (inHeader->nTimeStamp == 0) {\n            mSamplesToDiscard = mCodecDelay;\n }\n\n \n         const uint8_t *data = inHeader->pBuffer + inHeader->nOffset;\n         const uint32_t size = inHeader->nFilledLen;\n \n         int numFrames = opus_multistream_decode(mDecoder,\n                                                 data,\n                                                 size,\n                                                 (int16_t *)outHeader->pBuffer,\n                                                kMaxOpusOutputPacketSizeSamples,\n                                                 0);\n         if (numFrames < 0) {\n             ALOGE(\"opus_multistream_decode returned %d\", numFrames);\n            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n return;\n }\n\n        outHeader->nOffset = 0;\n if (mSamplesToDiscard > 0) {\n if (mSamplesToDiscard > numFrames) {\n                mSamplesToDiscard -= numFrames;\n                numFrames = 0;\n } else {\n                numFrames -= mSamplesToDiscard;\n                outHeader->nOffset = mSamplesToDiscard * sizeof(int16_t) *\n                                     mHeader->channels;\n                mSamplesToDiscard = 0;\n }\n }\n\n        outHeader->nFilledLen = numFrames * sizeof(int16_t) * mHeader->channels;\n        outHeader->nFlags = 0;\n\n        outHeader->nTimeStamp = mAnchorTimeUs +\n (mNumFramesOutput * 1000000ll) /\n                                kRate;\n\n        mNumFramesOutput += numFrames;\n\n        inInfo->mOwnedByUs = false;\n        inQueue.erase(inQueue.begin());\n        inInfo = NULL;\n        notifyEmptyBufferDone(inHeader);\n        inHeader = NULL;\n\n        outInfo->mOwnedByUs = false;\n        outQueue.erase(outQueue.begin());\n        outInfo = NULL;\n        notifyFillBufferDone(outHeader);\n        outHeader = NULL;\n\n ++mInputBufferCount;\n }\n}\n",
    "code_after_change": "void SoftOpus::onQueueFilled(OMX_U32 portIndex) {\n List<BufferInfo *> &inQueue = getPortQueue(0);\n List<BufferInfo *> &outQueue = getPortQueue(1);\n\n if (mOutputPortSettingsChange != NONE) {\n return;\n }\n\n if (portIndex == 0 && mInputBufferCount < 3) {\n BufferInfo *info = *inQueue.begin();\n        OMX_BUFFERHEADERTYPE *header = info->mHeader;\n\n const uint8_t *data = header->pBuffer + header->nOffset;\n size_t size = header->nFilledLen;\n\n if (mInputBufferCount == 0) {\n            CHECK(mHeader == NULL);\n            mHeader = new OpusHeader();\n            memset(mHeader, 0, sizeof(*mHeader));\n if (!ParseOpusHeader(data, size, mHeader)) {\n                ALOGV(\"Parsing Opus Header failed.\");\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n return;\n }\n\n uint8_t channel_mapping[kMaxChannels] = {0};\n if (mHeader->channels <= kMaxChannelsWithDefaultLayout) {\n                memcpy(&channel_mapping,\n                       kDefaultOpusChannelLayout,\n                       kMaxChannelsWithDefaultLayout);\n } else {\n                memcpy(&channel_mapping,\n                       mHeader->stream_map,\n                       mHeader->channels);\n }\n\n int status = OPUS_INVALID_STATE;\n            mDecoder = opus_multistream_decoder_create(kRate,\n                                                       mHeader->channels,\n                                                       mHeader->num_streams,\n                                                       mHeader->num_coupled,\n                                                       channel_mapping,\n &status);\n if (!mDecoder || status != OPUS_OK) {\n                ALOGV(\"opus_multistream_decoder_create failed status=%s\",\n                      opus_strerror(status));\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n return;\n }\n            status =\n                opus_multistream_decoder_ctl(mDecoder,\n                                             OPUS_SET_GAIN(mHeader->gain_db));\n if (status != OPUS_OK) {\n                ALOGV(\"Failed to set OPUS header gain; status=%s\",\n                      opus_strerror(status));\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n return;\n }\n } else if (mInputBufferCount == 1) {\n            mCodecDelay = ns_to_samples(\n *(reinterpret_cast<int64_t*>(header->pBuffer +\n                                                           header->nOffset)),\n                              kRate);\n            mSamplesToDiscard = mCodecDelay;\n } else {\n            mSeekPreRoll = ns_to_samples(\n *(reinterpret_cast<int64_t*>(header->pBuffer +\n                                                            header->nOffset)),\n                               kRate);\n            notify(OMX_EventPortSettingsChanged, 1, 0, NULL);\n            mOutputPortSettingsChange = AWAITING_DISABLED;\n }\n\n        inQueue.erase(inQueue.begin());\n        info->mOwnedByUs = false;\n        notifyEmptyBufferDone(header);\n ++mInputBufferCount;\n return;\n }\n\n while (!inQueue.empty() && !outQueue.empty()) {\n BufferInfo *inInfo = *inQueue.begin();\n        OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;\n\n if (inHeader->nFlags & OMX_BUFFERFLAG_CODECCONFIG) {\n            inQueue.erase(inQueue.begin());\n            inInfo->mOwnedByUs = false;\n            notifyEmptyBufferDone(inHeader);\n return;\n }\n\n BufferInfo *outInfo = *outQueue.begin();\n        OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;\n\n if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {\n            inQueue.erase(inQueue.begin());\n            inInfo->mOwnedByUs = false;\n            notifyEmptyBufferDone(inHeader);\n\n            outHeader->nFilledLen = 0;\n            outHeader->nFlags = OMX_BUFFERFLAG_EOS;\n\n            outQueue.erase(outQueue.begin());\n            outInfo->mOwnedByUs = false;\n            notifyFillBufferDone(outHeader);\n return;\n }\n\n if (inHeader->nOffset == 0) {\n            mAnchorTimeUs = inHeader->nTimeStamp;\n            mNumFramesOutput = 0;\n }\n\n if (inHeader->nTimeStamp == 0) {\n            mSamplesToDiscard = mCodecDelay;\n }\n\n \n         const uint8_t *data = inHeader->pBuffer + inHeader->nOffset;\n         const uint32_t size = inHeader->nFilledLen;\n        size_t frameSize = kMaxOpusOutputPacketSizeSamples;\n        if (frameSize > outHeader->nAllocLen / sizeof(int16_t) / mHeader->channels) {\n            frameSize = outHeader->nAllocLen / sizeof(int16_t) / mHeader->channels;\n            android_errorWriteLog(0x534e4554, \"27833616\");\n        }\n \n         int numFrames = opus_multistream_decode(mDecoder,\n                                                 data,\n                                                 size,\n                                                 (int16_t *)outHeader->pBuffer,\n                                                frameSize,\n                                                 0);\n         if (numFrames < 0) {\n             ALOGE(\"opus_multistream_decode returned %d\", numFrames);\n            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n return;\n }\n\n        outHeader->nOffset = 0;\n if (mSamplesToDiscard > 0) {\n if (mSamplesToDiscard > numFrames) {\n                mSamplesToDiscard -= numFrames;\n                numFrames = 0;\n } else {\n                numFrames -= mSamplesToDiscard;\n                outHeader->nOffset = mSamplesToDiscard * sizeof(int16_t) *\n                                     mHeader->channels;\n                mSamplesToDiscard = 0;\n }\n }\n\n        outHeader->nFilledLen = numFrames * sizeof(int16_t) * mHeader->channels;\n        outHeader->nFlags = 0;\n\n        outHeader->nTimeStamp = mAnchorTimeUs +\n (mNumFramesOutput * 1000000ll) /\n                                kRate;\n\n        mNumFramesOutput += numFrames;\n\n        inInfo->mOwnedByUs = false;\n        inQueue.erase(inQueue.begin());\n        inInfo = NULL;\n        notifyEmptyBufferDone(inHeader);\n        inHeader = NULL;\n\n        outInfo->mOwnedByUs = false;\n        outQueue.erase(outQueue.begin());\n        outInfo = NULL;\n        notifyFillBufferDone(outHeader);\n        outHeader = NULL;\n\n ++mInputBufferCount;\n }\n}\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 455,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2016-7536",
    "code_before_change": "static void WriteTo8BimProfile(Image *image,const char *name,\n  const StringInfo *profile)\n{\n\n  const unsigned char\n    *datum,\n    *q;\n\n  register const unsigned char\n    *p;\n\n  size_t\n    length;\n\n  StringInfo\n    *profile_8bim;\n\n  ssize_t\n    count;\n\n  unsigned char\n    length_byte;\n\n  unsigned int\n    value;\n\n  unsigned short\n    id,\n    profile_id;\n\n  if (LocaleCompare(name,\"icc\") == 0)\n    profile_id=0x040f;\n  else\n    if (LocaleCompare(name,\"iptc\") == 0)\n      profile_id=0x0404;\n    else\n      if (LocaleCompare(name,\"xmp\") == 0)\n        profile_id=0x0424;\n      else\n        return;\n  profile_8bim=(StringInfo *) GetValueFromSplayTree((SplayTreeInfo *)\n    image->profiles,\"8bim\");\n  if (profile_8bim == (StringInfo *) NULL)\n    return;\n  datum=GetStringInfoDatum(profile_8bim);\n  length=GetStringInfoLength(profile_8bim);\n  for (p=datum; p < (datum+length-16); )\n  {\n    q=p;\n    if (LocaleNCompare((char *) p,\"8BIM\",4) != 0)\n      break;\n    p+=4;\n    p=ReadResourceShort(p,&id);\n    p=ReadResourceByte(p,&length_byte);\n    p+=length_byte;\n    if (((length_byte+1) & 0x01) != 0)\n      p++;\n    if (p > (datum+length-4))\n      break;\n    p=ReadResourceLong(p,&value);\n     count=(ssize_t) value;\n     if ((count & 0x01) != 0)\n       count++;\n    if ((p > (datum+length-count)) || (count > (ssize_t) length))\n       break;\n     if (id != profile_id)\n       p+=count;\n    else\n      {\n        size_t\n          extent,\n          offset;\n\n        ssize_t\n          extract_extent;\n\n        StringInfo\n          *extract_profile;\n\n        extract_extent=0;\n        extent=(datum+length)-(p+count);\n        if (profile == (StringInfo *) NULL)\n          {\n            offset=(q-datum);\n            extract_profile=AcquireStringInfo(offset+extent);\n            (void) CopyMagickMemory(extract_profile->datum,datum,offset);\n          }\n        else\n          {\n            offset=(p-datum);\n            extract_extent=profile->length;\n            if ((extract_extent & 0x01) != 0)\n              extract_extent++;\n            extract_profile=AcquireStringInfo(offset+extract_extent+extent);\n            (void) CopyMagickMemory(extract_profile->datum,datum,offset-4);\n            (void) WriteResourceLong(extract_profile->datum+offset-4,\n              (unsigned int) profile->length);\n            (void) CopyMagickMemory(extract_profile->datum+offset,\n              profile->datum,profile->length);\n          }\n        (void) CopyMagickMemory(extract_profile->datum+offset+extract_extent,\n          p+count,extent);\n        (void) AddValueToSplayTree((SplayTreeInfo *) image->profiles,\n          ConstantString(\"8bim\"),CloneStringInfo(extract_profile));\n        extract_profile=DestroyStringInfo(extract_profile);\n        break;\n      }\n  }\n}\n",
    "code_after_change": "static void WriteTo8BimProfile(Image *image,const char *name,\n  const StringInfo *profile)\n{\n\n  const unsigned char\n    *datum,\n    *q;\n\n  register const unsigned char\n    *p;\n\n  size_t\n    length;\n\n  StringInfo\n    *profile_8bim;\n\n  ssize_t\n    count;\n\n  unsigned char\n    length_byte;\n\n  unsigned int\n    value;\n\n  unsigned short\n    id,\n    profile_id;\n\n  if (LocaleCompare(name,\"icc\") == 0)\n    profile_id=0x040f;\n  else\n    if (LocaleCompare(name,\"iptc\") == 0)\n      profile_id=0x0404;\n    else\n      if (LocaleCompare(name,\"xmp\") == 0)\n        profile_id=0x0424;\n      else\n        return;\n  profile_8bim=(StringInfo *) GetValueFromSplayTree((SplayTreeInfo *)\n    image->profiles,\"8bim\");\n  if (profile_8bim == (StringInfo *) NULL)\n    return;\n  datum=GetStringInfoDatum(profile_8bim);\n  length=GetStringInfoLength(profile_8bim);\n  for (p=datum; p < (datum+length-16); )\n  {\n    q=p;\n    if (LocaleNCompare((char *) p,\"8BIM\",4) != 0)\n      break;\n    p+=4;\n    p=ReadResourceShort(p,&id);\n    p=ReadResourceByte(p,&length_byte);\n    p+=length_byte;\n    if (((length_byte+1) & 0x01) != 0)\n      p++;\n    if (p > (datum+length-4))\n      break;\n    p=ReadResourceLong(p,&value);\n     count=(ssize_t) value;\n     if ((count & 0x01) != 0)\n       count++;\n    if ((count < 0) || (p > (datum+length-count)) ||\n        (count > (ssize_t) length))\n       break;\n     if (id != profile_id)\n       p+=count;\n    else\n      {\n        size_t\n          extent,\n          offset;\n\n        ssize_t\n          extract_extent;\n\n        StringInfo\n          *extract_profile;\n\n        extract_extent=0;\n        extent=(datum+length)-(p+count);\n        if (profile == (StringInfo *) NULL)\n          {\n            offset=(q-datum);\n            extract_profile=AcquireStringInfo(offset+extent);\n            (void) CopyMagickMemory(extract_profile->datum,datum,offset);\n          }\n        else\n          {\n            offset=(p-datum);\n            extract_extent=profile->length;\n            if ((extract_extent & 0x01) != 0)\n              extract_extent++;\n            extract_profile=AcquireStringInfo(offset+extract_extent+extent);\n            (void) CopyMagickMemory(extract_profile->datum,datum,offset-4);\n            (void) WriteResourceLong(extract_profile->datum+offset-4,\n              (unsigned int) profile->length);\n            (void) CopyMagickMemory(extract_profile->datum+offset,\n              profile->datum,profile->length);\n          }\n        (void) CopyMagickMemory(extract_profile->datum+offset+extract_extent,\n          p+count,extent);\n        (void) AddValueToSplayTree((SplayTreeInfo *) image->profiles,\n          ConstantString(\"8bim\"),CloneStringInfo(extract_profile));\n        extract_profile=DestroyStringInfo(extract_profile);\n        break;\n      }\n  }\n}\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 456,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2016-5357",
    "code_before_change": "netscreen_seek_read(wtap *wth, gint64 seek_off,\n \tstruct wtap_pkthdr *phdr, Buffer *buf,\n \tint *err, gchar **err_info)\n {\n\tint\t\tpkt_len;\n \tchar\t\tline[NETSCREEN_LINE_LENGTH];\n\tchar\t\tcap_int[NETSCREEN_MAX_INT_NAME_LENGTH];\n\tgboolean\tcap_dir;\n\tchar\t\tcap_dst[13];\n \n \tif (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1) {\n \t\treturn FALSE;\n\t}\n\n\tif (file_gets(line, NETSCREEN_LINE_LENGTH, wth->random_fh) == NULL) {\n\t\t*err = file_error(wth->random_fh, err_info);\n\t\tif (*err == 0) {\n\t\t\t*err = WTAP_ERR_SHORT_READ;\n\t\t}\n \t\treturn FALSE;\n \t}\n \n\tpkt_len = parse_netscreen_rec_hdr(phdr, line, cap_int, &cap_dir,\n\t    cap_dst, err, err_info);\n\tif (pkt_len == -1)\n\t\treturn FALSE;\n\tif (!parse_netscreen_hex_dump(wth->random_fh, pkt_len, cap_int,\n\t    cap_dst, phdr, buf, err, err_info))\n\t\treturn FALSE;\n\treturn TRUE;\n }\n",
    "code_after_change": "netscreen_seek_read(wtap *wth, gint64 seek_off,\n \tstruct wtap_pkthdr *phdr, Buffer *buf,\n \tint *err, gchar **err_info)\n {\n \tchar\t\tline[NETSCREEN_LINE_LENGTH];\n \n \tif (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1) {\n \t\treturn FALSE;\n\t}\n\n\tif (file_gets(line, NETSCREEN_LINE_LENGTH, wth->random_fh) == NULL) {\n\t\t*err = file_error(wth->random_fh, err_info);\n\t\tif (*err == 0) {\n\t\t\t*err = WTAP_ERR_SHORT_READ;\n\t\t}\n \t\treturn FALSE;\n \t}\n \n\treturn parse_netscreen_packet(wth->random_fh, phdr, buf, line,\n\t    err, err_info);\n }\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 464,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2016-10061",
    "code_before_change": "static Image *ReadGROUP4Image(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent];\n\n  FILE\n    *file;\n\n  Image\n    *image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    c,\n    unique_file;\n\n  MagickBooleanType\n    status;\n\n  size_t\n    length;\n\n  ssize_t\n    offset,\n    strip_offset;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Write raw CCITT Group 4 wrapped as a TIFF image file.\n  */\n  file=(FILE *) NULL;\n  unique_file=AcquireUniqueFileResource(filename);\n  if (unique_file != -1)\n    file=fdopen(unique_file,\"wb\");\n  if ((unique_file == -1) || (file == (FILE *) NULL))\n    ThrowImageException(FileOpenError,\"UnableToCreateTemporaryFile\");\n  length=fwrite(\"\\111\\111\\052\\000\\010\\000\\000\\000\\016\\000\",1,10,file);\n  length=fwrite(\"\\376\\000\\003\\000\\001\\000\\000\\000\\000\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\000\\001\\004\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,image->columns);\n  length=fwrite(\"\\001\\001\\004\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,image->rows);\n  length=fwrite(\"\\002\\001\\003\\000\\001\\000\\000\\000\\001\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\003\\001\\003\\000\\001\\000\\000\\000\\004\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\006\\001\\003\\000\\001\\000\\000\\000\\000\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\021\\001\\003\\000\\001\\000\\000\\000\",1,8,file);\n  strip_offset=10+(12*14)+4+8;\n  length=WriteLSBLong(file,(size_t) strip_offset);\n  length=fwrite(\"\\022\\001\\003\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,(size_t) image_info->orientation);\n  length=fwrite(\"\\025\\001\\003\\000\\001\\000\\000\\000\\001\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\026\\001\\004\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,image->rows);\n  length=fwrite(\"\\027\\001\\004\\000\\001\\000\\000\\000\\000\\000\\000\\000\",1,12,file);\n  offset=(ssize_t) ftell(file)-4;\n  length=fwrite(\"\\032\\001\\005\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,(size_t) (strip_offset-8));\n  length=fwrite(\"\\033\\001\\005\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,(size_t) (strip_offset-8));\n  length=fwrite(\"\\050\\001\\003\\000\\001\\000\\000\\000\\002\\000\\000\\000\",1,12,file);\n   length=fwrite(\"\\000\\000\\000\\000\",1,4,file);\n   length=WriteLSBLong(file,(long) image->resolution.x);\n   length=WriteLSBLong(file,1);\n   for (length=0; (c=ReadBlobByte(image)) != EOF; length++)\n    (void) fputc(c,file);\n   offset=(ssize_t) fseek(file,(ssize_t) offset,SEEK_SET);\n   length=WriteLSBLong(file,(unsigned int) length);\n   (void) fclose(file);\n  (void) CloseBlob(image);\n  image=DestroyImage(image);\n  /*\n    Read TIFF image.\n  */\n  read_info=CloneImageInfo((ImageInfo *) NULL);\n  (void) FormatLocaleString(read_info->filename,MagickPathExtent,\"%s\",filename);\n  image=ReadTIFFImage(read_info,exception);\n  read_info=DestroyImageInfo(read_info);\n  if (image != (Image *) NULL)\n    {\n      (void) CopyMagickString(image->filename,image_info->filename,\n        MagickPathExtent);\n      (void) CopyMagickString(image->magick_filename,image_info->filename,\n        MagickPathExtent);\n       (void) CopyMagickString(image->magick,\"GROUP4\",MagickPathExtent);\n     }\n   (void) RelinquishUniqueFileResource(filename);\n   return(image);\n }\n",
    "code_after_change": "static Image *ReadGROUP4Image(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent];\n\n  FILE\n    *file;\n\n  Image\n    *image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    c,\n    unique_file;\n\n  MagickBooleanType\n    status;\n\n  size_t\n    length;\n\n  ssize_t\n    offset,\n    strip_offset;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Write raw CCITT Group 4 wrapped as a TIFF image file.\n  */\n  file=(FILE *) NULL;\n  unique_file=AcquireUniqueFileResource(filename);\n  if (unique_file != -1)\n    file=fdopen(unique_file,\"wb\");\n  if ((unique_file == -1) || (file == (FILE *) NULL))\n    ThrowImageException(FileOpenError,\"UnableToCreateTemporaryFile\");\n  length=fwrite(\"\\111\\111\\052\\000\\010\\000\\000\\000\\016\\000\",1,10,file);\n  length=fwrite(\"\\376\\000\\003\\000\\001\\000\\000\\000\\000\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\000\\001\\004\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,image->columns);\n  length=fwrite(\"\\001\\001\\004\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,image->rows);\n  length=fwrite(\"\\002\\001\\003\\000\\001\\000\\000\\000\\001\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\003\\001\\003\\000\\001\\000\\000\\000\\004\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\006\\001\\003\\000\\001\\000\\000\\000\\000\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\021\\001\\003\\000\\001\\000\\000\\000\",1,8,file);\n  strip_offset=10+(12*14)+4+8;\n  length=WriteLSBLong(file,(size_t) strip_offset);\n  length=fwrite(\"\\022\\001\\003\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,(size_t) image_info->orientation);\n  length=fwrite(\"\\025\\001\\003\\000\\001\\000\\000\\000\\001\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\026\\001\\004\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,image->rows);\n  length=fwrite(\"\\027\\001\\004\\000\\001\\000\\000\\000\\000\\000\\000\\000\",1,12,file);\n  offset=(ssize_t) ftell(file)-4;\n  length=fwrite(\"\\032\\001\\005\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,(size_t) (strip_offset-8));\n  length=fwrite(\"\\033\\001\\005\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,(size_t) (strip_offset-8));\n  length=fwrite(\"\\050\\001\\003\\000\\001\\000\\000\\000\\002\\000\\000\\000\",1,12,file);\n   length=fwrite(\"\\000\\000\\000\\000\",1,4,file);\n   length=WriteLSBLong(file,(long) image->resolution.x);\n   length=WriteLSBLong(file,1);\n  status=MagickTrue;\n   for (length=0; (c=ReadBlobByte(image)) != EOF; length++)\n    if (fputc(c,file) != c)\n      status=MagickFalse;\n   offset=(ssize_t) fseek(file,(ssize_t) offset,SEEK_SET);\n   length=WriteLSBLong(file,(unsigned int) length);\n   (void) fclose(file);\n  (void) CloseBlob(image);\n  image=DestroyImage(image);\n  /*\n    Read TIFF image.\n  */\n  read_info=CloneImageInfo((ImageInfo *) NULL);\n  (void) FormatLocaleString(read_info->filename,MagickPathExtent,\"%s\",filename);\n  image=ReadTIFFImage(read_info,exception);\n  read_info=DestroyImageInfo(read_info);\n  if (image != (Image *) NULL)\n    {\n      (void) CopyMagickString(image->filename,image_info->filename,\n        MagickPathExtent);\n      (void) CopyMagickString(image->magick_filename,image_info->filename,\n        MagickPathExtent);\n       (void) CopyMagickString(image->magick,\"GROUP4\",MagickPathExtent);\n     }\n   (void) RelinquishUniqueFileResource(filename);\n  if (status == MagickFalse)\n    image=DestroyImage(image);\n   return(image);\n }\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 477,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2014-9907",
    "code_before_change": " static MagickBooleanType ReadUncompressedRGBA(Image *image, DDSInfo *dds_info,\n  ExceptionInfo *exception)\n{\n  PixelPacket\n    *q;\n\n  ssize_t\n    alphaBits,\n    x,\n    y;\n\n  unsigned short\n    color;\n\n  alphaBits=0;\n  if (dds_info->pixelformat.rgb_bitcount == 16)\n    {\n      if (IsBitMask(dds_info->pixelformat,0x7c00,0x03e0,0x001f,0x8000))\n        alphaBits=1;\n      else if (IsBitMask(dds_info->pixelformat,0x00ff,0x00ff,0x00ff,0xff00))\n        {\n          alphaBits=2;\n          (void) SetImageType(image,GrayscaleMatteType);\n        }\n      else if (IsBitMask(dds_info->pixelformat,0x0f00,0x00f0,0x000f,0xf000))\n        alphaBits=4;\n      else\n        ThrowBinaryException(CorruptImageError,\"ImageTypeNotSupported\",\n          image->filename);\n    }\n\n  for (y = 0; y < (ssize_t) dds_info->height; y++)\n  {\n    q = QueueAuthenticPixels(image, 0, y, dds_info->width, 1,exception);\n\n    if (q == (PixelPacket *) NULL)\n      return MagickFalse;\n\n    for (x = 0; x < (ssize_t) dds_info->width; x++)\n    {\n      if (dds_info->pixelformat.rgb_bitcount == 16)\n        {\n           color=ReadBlobShort(image);\n           if (alphaBits == 1)\n             {\n               SetPixelAlpha(q,(color & (1 << 15)) ? QuantumRange : 0);\n               SetPixelRed(q,ScaleCharToQuantum((unsigned char)\n                 ((((unsigned short)(color << 1) >> 11)/31.0)*255)));\n               SetPixelGreen(q,ScaleCharToQuantum((unsigned char)\n                 ((((unsigned short)(color << 6) >> 11)/31.0)*255)));\n               SetPixelBlue(q,ScaleCharToQuantum((unsigned char)\n                 ((((unsigned short)(color << 11) >> 11)/31.0)*255)));\n             }\n          else if (alphaBits == 2)\n            {\n               SetPixelAlpha(q,ScaleCharToQuantum((unsigned char)\n                 (color >> 8)));\n               SetPixelGray(q,ScaleCharToQuantum((unsigned char)color));\n            }\n          else\n            {\n               SetPixelAlpha(q,ScaleCharToQuantum((unsigned char)\n                 (((color >> 12)/15.0)*255)));\n               SetPixelRed(q,ScaleCharToQuantum((unsigned char)\n                 ((((unsigned short)(color << 4) >> 12)/15.0)*255)));\n               SetPixelGreen(q,ScaleCharToQuantum((unsigned char)\n                 ((((unsigned short)(color << 8) >> 12)/15.0)*255)));\n               SetPixelBlue(q,ScaleCharToQuantum((unsigned char)\n                 ((((unsigned short)(color << 12) >> 12)/15.0)*255)));\n            }\n        }\n      else\n        {\n          SetPixelBlue(q,ScaleCharToQuantum((unsigned char)\n            ReadBlobByte(image)));\n          SetPixelGreen(q,ScaleCharToQuantum((unsigned char)\n            ReadBlobByte(image)));\n          SetPixelRed(q,ScaleCharToQuantum((unsigned char)\n            ReadBlobByte(image)));\n          SetPixelAlpha(q,ScaleCharToQuantum((unsigned char)\n            ReadBlobByte(image)));\n        }\n      q++;\n    }\n\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n       return MagickFalse;\n   }\n \n  SkipRGBMipmaps(image, dds_info, 4);\n  return MagickTrue;\n }\n",
    "code_after_change": " static MagickBooleanType ReadUncompressedRGBA(Image *image, DDSInfo *dds_info,\n  ExceptionInfo *exception)\n{\n  PixelPacket\n    *q;\n\n  ssize_t\n    alphaBits,\n    x,\n    y;\n\n  unsigned short\n    color;\n\n  alphaBits=0;\n  if (dds_info->pixelformat.rgb_bitcount == 16)\n    {\n      if (IsBitMask(dds_info->pixelformat,0x7c00,0x03e0,0x001f,0x8000))\n        alphaBits=1;\n      else if (IsBitMask(dds_info->pixelformat,0x00ff,0x00ff,0x00ff,0xff00))\n        {\n          alphaBits=2;\n          (void) SetImageType(image,GrayscaleMatteType);\n        }\n      else if (IsBitMask(dds_info->pixelformat,0x0f00,0x00f0,0x000f,0xf000))\n        alphaBits=4;\n      else\n        ThrowBinaryException(CorruptImageError,\"ImageTypeNotSupported\",\n          image->filename);\n    }\n\n  for (y = 0; y < (ssize_t) dds_info->height; y++)\n  {\n    q = QueueAuthenticPixels(image, 0, y, dds_info->width, 1,exception);\n\n    if (q == (PixelPacket *) NULL)\n      return MagickFalse;\n\n    for (x = 0; x < (ssize_t) dds_info->width; x++)\n    {\n      if (dds_info->pixelformat.rgb_bitcount == 16)\n        {\n           color=ReadBlobShort(image);\n           if (alphaBits == 1)\n             {\n               SetPixelAlpha(q,(color & (1 << 15)) ? QuantumRange : 0);\n               SetPixelRed(q,ScaleCharToQuantum((unsigned char)\n                 ((((unsigned short)(color << 1) >> 11)/31.0)*255)));\n               SetPixelGreen(q,ScaleCharToQuantum((unsigned char)\n                 ((((unsigned short)(color << 6) >> 11)/31.0)*255)));\n               SetPixelBlue(q,ScaleCharToQuantum((unsigned char)\n                 ((((unsigned short)(color << 11) >> 11)/31.0)*255)));\n             }\n          else if (alphaBits == 2)\n            {\n               SetPixelAlpha(q,ScaleCharToQuantum((unsigned char)\n                 (color >> 8)));\n               SetPixelGray(q,ScaleCharToQuantum((unsigned char)color));\n            }\n          else\n            {\n               SetPixelAlpha(q,ScaleCharToQuantum((unsigned char)\n                 (((color >> 12)/15.0)*255)));\n               SetPixelRed(q,ScaleCharToQuantum((unsigned char)\n                 ((((unsigned short)(color << 4) >> 12)/15.0)*255)));\n               SetPixelGreen(q,ScaleCharToQuantum((unsigned char)\n                 ((((unsigned short)(color << 8) >> 12)/15.0)*255)));\n               SetPixelBlue(q,ScaleCharToQuantum((unsigned char)\n                 ((((unsigned short)(color << 12) >> 12)/15.0)*255)));\n            }\n        }\n      else\n        {\n          SetPixelBlue(q,ScaleCharToQuantum((unsigned char)\n            ReadBlobByte(image)));\n          SetPixelGreen(q,ScaleCharToQuantum((unsigned char)\n            ReadBlobByte(image)));\n          SetPixelRed(q,ScaleCharToQuantum((unsigned char)\n            ReadBlobByte(image)));\n          SetPixelAlpha(q,ScaleCharToQuantum((unsigned char)\n            ReadBlobByte(image)));\n        }\n      q++;\n    }\n\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n       return MagickFalse;\n   }\n \n  return(SkipRGBMipmaps(image,dds_info,4,exception));\n }\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 484,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2018-6161",
    "code_before_change": " void MediaElementAudioSourceHandler::SetFormat(size_t number_of_channels,\n                                                float source_sample_rate) {\n   if (number_of_channels != source_number_of_channels_ ||\n       source_sample_rate != source_sample_rate_) {\n     if (!number_of_channels ||\n        number_of_channels > BaseAudioContext::MaxNumberOfChannels() ||\n        !AudioUtilities::IsValidAudioBufferSampleRate(source_sample_rate)) {\n      DLOG(ERROR) << \"setFormat(\" << number_of_channels << \", \"\n                  << source_sample_rate << \") - unhandled format change\";\n       Locker<MediaElementAudioSourceHandler> locker(*this);\n       source_number_of_channels_ = 0;\n       source_sample_rate_ = 0;\n       return;\n     }\n \n     Locker<MediaElementAudioSourceHandler> locker(*this);\n \n     source_number_of_channels_ = number_of_channels;\n     source_sample_rate_ = source_sample_rate;\n \n    if (source_sample_rate != Context()->sampleRate()) {\n      double scale_factor = source_sample_rate / Context()->sampleRate();\n      multi_channel_resampler_ = std::make_unique<MultiChannelResampler>(\n          scale_factor, number_of_channels);\n    } else {\n      multi_channel_resampler_.reset();\n    }\n\n    {\n      BaseAudioContext::GraphAutoLocker context_locker(Context());\n\n      Output(0).SetNumberOfChannels(number_of_channels);\n    }\n   }\n }\n",
    "code_after_change": " void MediaElementAudioSourceHandler::SetFormat(size_t number_of_channels,\n                                                float source_sample_rate) {\n  bool is_tainted = WouldTaintOrigin();\n\n  if (is_tainted) {\n    PrintCORSMessage(MediaElement()->currentSrc().GetString());\n  }\n\n   if (number_of_channels != source_number_of_channels_ ||\n       source_sample_rate != source_sample_rate_) {\n     if (!number_of_channels ||\n        number_of_channels > BaseAudioContext::MaxNumberOfChannels() ||\n        !AudioUtilities::IsValidAudioBufferSampleRate(source_sample_rate)) {\n      DLOG(ERROR) << \"setFormat(\" << number_of_channels << \", \"\n                  << source_sample_rate << \") - unhandled format change\";\n       Locker<MediaElementAudioSourceHandler> locker(*this);\n       source_number_of_channels_ = 0;\n       source_sample_rate_ = 0;\n      is_origin_tainted_ = is_tainted;\n       return;\n     }\n \n    // Synchronize with process() to protect |source_number_of_channels_|,\n    // |source_sample_rate_|, |multi_channel_resampler_|. and\n    // |is_origin_tainted_|.\n     Locker<MediaElementAudioSourceHandler> locker(*this);\n \n    is_origin_tainted_ = is_tainted;\n     source_number_of_channels_ = number_of_channels;\n     source_sample_rate_ = source_sample_rate;\n \n    if (source_sample_rate != Context()->sampleRate()) {\n      double scale_factor = source_sample_rate / Context()->sampleRate();\n      multi_channel_resampler_ = std::make_unique<MultiChannelResampler>(\n          scale_factor, number_of_channels);\n    } else {\n      multi_channel_resampler_.reset();\n    }\n\n    {\n      BaseAudioContext::GraphAutoLocker context_locker(Context());\n\n      Output(0).SetNumberOfChannels(number_of_channels);\n    }\n   }\n }\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 503,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2019-5799",
    "code_before_change": "bool ContentSecurityPolicy::AllowPluginTypeForDocument(\n    const Document& document,\n    const String& type,\n    const String& type_attribute,\n    const KURL& url,\n    SecurityViolationReportingPolicy reporting_policy) const {\n  if (document.GetContentSecurityPolicy() &&\n      !document.GetContentSecurityPolicy()->AllowPluginType(\n           type, type_attribute, url, reporting_policy))\n     return false;\n \n  LocalFrame* frame = document.GetFrame();\n  if (frame && frame->Tree().Parent() && document.IsPluginDocument()) {\n    ContentSecurityPolicy* parent_csp = frame->Tree()\n                                            .Parent()\n                                            ->GetSecurityContext()\n                                            ->GetContentSecurityPolicy();\n    if (parent_csp && !parent_csp->AllowPluginType(type, type_attribute, url,\n                                                   reporting_policy))\n      return false;\n  }\n   return true;\n }\n",
    "code_after_change": "bool ContentSecurityPolicy::AllowPluginTypeForDocument(\n    const Document& document,\n    const String& type,\n    const String& type_attribute,\n    const KURL& url,\n    SecurityViolationReportingPolicy reporting_policy) const {\n  if (document.GetContentSecurityPolicy() &&\n      !document.GetContentSecurityPolicy()->AllowPluginType(\n           type, type_attribute, url, reporting_policy))\n     return false;\n \n   return true;\n }\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 514,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2013-0881",
    "code_before_change": "void RenderLayerCompositor::frameViewDidScroll()\n{\n    FrameView* frameView = m_renderView->frameView();\n    IntPoint scrollPosition = frameView->scrollPosition();\n\n    if (!m_scrollLayer)\n        return;\n\n    bool scrollingCoordinatorHandlesOffset = false;\n    if (ScrollingCoordinator* scrollingCoordinator = this->scrollingCoordinator()) {\n        if (Settings* settings = m_renderView->document().settings()) {\n            if (isMainFrame() || settings->compositedScrollingForFramesEnabled())\n                scrollingCoordinatorHandlesOffset = scrollingCoordinator->scrollableAreaScrollLayerDidChange(frameView);\n        }\n    }\n\n    if (scrollingCoordinatorHandlesOffset)\n        m_scrollLayer->setPosition(-frameView->minimumScrollPosition());\n    else\n        m_scrollLayer->setPosition(-scrollPosition);\n\n\n    blink::Platform::current()->histogramEnumeration(\"Renderer.AcceleratedFixedRootBackground\",\n        ScrolledMainFrameBucket,\n        AcceleratedFixedRootBackgroundHistogramMax);\n\n     if (!m_renderView->rootBackgroundIsEntirelyFixed())\n         return;\n \n     blink::Platform::current()->histogramEnumeration(\"Renderer.AcceleratedFixedRootBackground\",\n         !!fixedRootBackgroundLayer()\n             ? ScrolledMainFrameWithAcceleratedFixedRootBackground\n            : ScrolledMainFrameWithUnacceleratedFixedRootBackground,\n        AcceleratedFixedRootBackgroundHistogramMax);\n}\n",
    "code_after_change": "void RenderLayerCompositor::frameViewDidScroll()\n{\n    FrameView* frameView = m_renderView->frameView();\n    IntPoint scrollPosition = frameView->scrollPosition();\n\n    if (!m_scrollLayer)\n        return;\n\n    bool scrollingCoordinatorHandlesOffset = false;\n    if (ScrollingCoordinator* scrollingCoordinator = this->scrollingCoordinator()) {\n        if (Settings* settings = m_renderView->document().settings()) {\n            if (isMainFrame() || settings->compositedScrollingForFramesEnabled())\n                scrollingCoordinatorHandlesOffset = scrollingCoordinator->scrollableAreaScrollLayerDidChange(frameView);\n        }\n    }\n\n    if (scrollingCoordinatorHandlesOffset)\n        m_scrollLayer->setPosition(-frameView->minimumScrollPosition());\n    else\n        m_scrollLayer->setPosition(-scrollPosition);\n\n\n    blink::Platform::current()->histogramEnumeration(\"Renderer.AcceleratedFixedRootBackground\",\n        ScrolledMainFrameBucket,\n        AcceleratedFixedRootBackgroundHistogramMax);\n\n     if (!m_renderView->rootBackgroundIsEntirelyFixed())\n         return;\n \n    // FIXME: fixedRootBackgroundLayer calls compositingState, which is not necessarily up to date here on mac.\n    // See crbug.com/343179.\n    DisableCompositingQueryAsserts disabler;\n\n     blink::Platform::current()->histogramEnumeration(\"Renderer.AcceleratedFixedRootBackground\",\n         !!fixedRootBackgroundLayer()\n             ? ScrolledMainFrameWithAcceleratedFixedRootBackground\n            : ScrolledMainFrameWithUnacceleratedFixedRootBackground,\n        AcceleratedFixedRootBackgroundHistogramMax);\n}\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 524,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2018-6111",
    "code_before_change": "void RenderFrameDevToolsAgentHost::UpdateFrameHost(\n    RenderFrameHostImpl* frame_host) {\n  if (frame_host == frame_host_) {\n    if (frame_host && !render_frame_alive_) {\n      render_frame_alive_ = true;\n      MaybeReattachToRenderFrame();\n    }\n    return;\n  }\n\n  if (frame_host && !ShouldCreateDevToolsForHost(frame_host)) {\n    DestroyOnRenderFrameGone();\n    return;\n  }\n\n  if (IsAttached())\n    RevokePolicy();\n  frame_host_ = frame_host;\n  agent_ptr_.reset();\n  render_frame_alive_ = true;\n   if (IsAttached()) {\n     GrantPolicy();\n     for (DevToolsSession* session : sessions()) {\n      session->SetRenderer(frame_host ? frame_host->GetProcess() : nullptr,\n                            frame_host);\n     }\n     MaybeReattachToRenderFrame();\n  }\n}\n",
    "code_after_change": "void RenderFrameDevToolsAgentHost::UpdateFrameHost(\n    RenderFrameHostImpl* frame_host) {\n  if (frame_host == frame_host_) {\n    if (frame_host && !render_frame_alive_) {\n      render_frame_alive_ = true;\n      MaybeReattachToRenderFrame();\n    }\n    return;\n  }\n\n  if (frame_host && !ShouldCreateDevToolsForHost(frame_host)) {\n    DestroyOnRenderFrameGone();\n    return;\n  }\n\n  if (IsAttached())\n    RevokePolicy();\n  frame_host_ = frame_host;\n  agent_ptr_.reset();\n  render_frame_alive_ = true;\n   if (IsAttached()) {\n     GrantPolicy();\n     for (DevToolsSession* session : sessions()) {\n      session->SetRenderer(frame_host ? frame_host->GetProcess()->GetID() : -1,\n                            frame_host);\n     }\n     MaybeReattachToRenderFrame();\n  }\n}\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 526,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2017-9141",
    "code_before_change": "static Image *ReadDDSImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    status,\n    cubemap = MagickFalse,\n    volume = MagickFalse,\n    matte;\n\n  CompressionType\n    compression;\n\n  DDSInfo\n    dds_info;\n\n  DDSDecoder\n    *decoder;\n\n  size_t\n    n,\n    num_images;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n\n   /*\n     Initialize image structure.\n   */\n  if (ReadDDSInfo(image, &dds_info) != MagickTrue) {\n     ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  }\n \n   if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP)\n     cubemap = MagickTrue;\n\n  if (dds_info.ddscaps2 & DDSCAPS2_VOLUME && dds_info.depth > 0)\n    volume = MagickTrue;\n\n  (void) SeekBlob(image, 128, SEEK_SET);\n\n  /*\n    Determine pixel format\n  */\n  if (dds_info.pixelformat.flags & DDPF_RGB)\n    {\n      compression = NoCompression;\n      if (dds_info.pixelformat.flags & DDPF_ALPHAPIXELS)\n        {\n          matte = MagickTrue;\n          decoder = ReadUncompressedRGBA;\n        }\n      else\n        {\n          matte = MagickTrue;\n          decoder = ReadUncompressedRGB;\n        }\n    }\n  else if (dds_info.pixelformat.flags & DDPF_LUMINANCE)\n   {\n      compression = NoCompression;\n      if (dds_info.pixelformat.flags & DDPF_ALPHAPIXELS)\n        {\n          /* Not sure how to handle this */\n          ThrowReaderException(CorruptImageError, \"ImageTypeNotSupported\");\n        }\n      else\n        {\n          matte = MagickFalse;\n          decoder = ReadUncompressedRGB;\n        }\n    }\n  else if (dds_info.pixelformat.flags & DDPF_FOURCC)\n    {\n      switch (dds_info.pixelformat.fourcc)\n      {\n        case FOURCC_DXT1:\n        {\n          matte = MagickFalse;\n          compression = DXT1Compression;\n          decoder = ReadDXT1;\n          break;\n        }\n        case FOURCC_DXT3:\n        {\n          matte = MagickTrue;\n          compression = DXT3Compression;\n          decoder = ReadDXT3;\n          break;\n        }\n        case FOURCC_DXT5:\n        {\n          matte = MagickTrue;\n          compression = DXT5Compression;\n          decoder = ReadDXT5;\n          break;\n        }\n        default:\n        {\n          /* Unknown FOURCC */\n          ThrowReaderException(CorruptImageError, \"ImageTypeNotSupported\");\n        }\n      }\n    }\n  else\n    {\n      /* Neither compressed nor uncompressed... thus unsupported */\n      ThrowReaderException(CorruptImageError, \"ImageTypeNotSupported\");\n    }\n\n  num_images = 1;\n  if (cubemap)\n    {\n      /*\n        Determine number of faces defined in the cubemap\n      */\n      num_images = 0;\n      if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEX) num_images++;\n      if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEX) num_images++;\n      if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEY) num_images++;\n      if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEY) num_images++;\n      if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEZ) num_images++;\n      if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ) num_images++;\n    }\n\n   if (volume)\n     num_images = dds_info.depth;\n \n   for (n = 0; n < num_images; n++)\n   {\n     if (n != 0)\n      {\n        if (EOFBlob(image) != MagickFalse)\n          ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n        /* Start a new image */\n        AcquireNextImage(image_info,image);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          return(DestroyImageList(image));\n        image=SyncNextImageInList(image);\n      }\n \n    image->matte = matte;\n    image->compression = compression;\n    image->columns = dds_info.width;\n    image->rows = dds_info.height;\n    image->storage_class = DirectClass;\n    image->endian = LSBEndian;\n    image->depth = 8;\n    if (image_info->ping != MagickFalse)\n      {\n        (void) CloseBlob(image);\n        return(GetFirstImageInList(image));\n      }\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n\n    if ((decoder)(image, &dds_info, exception) != MagickTrue)\n      {\n        (void) CloseBlob(image);\n        return(GetFirstImageInList(image));\n      }\n  }\n\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n",
    "code_after_change": "static Image *ReadDDSImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    status,\n    cubemap = MagickFalse,\n    volume = MagickFalse,\n    matte;\n\n  CompressionType\n    compression;\n\n  DDSInfo\n    dds_info;\n\n  DDSDecoder\n    *decoder;\n\n  size_t\n    n,\n    num_images;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n\n   /*\n     Initialize image structure.\n   */\n  if (ReadDDSInfo(image, &dds_info) != MagickTrue)\n     ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n \n   if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP)\n     cubemap = MagickTrue;\n\n  if (dds_info.ddscaps2 & DDSCAPS2_VOLUME && dds_info.depth > 0)\n    volume = MagickTrue;\n\n  (void) SeekBlob(image, 128, SEEK_SET);\n\n  /*\n    Determine pixel format\n  */\n  if (dds_info.pixelformat.flags & DDPF_RGB)\n    {\n      compression = NoCompression;\n      if (dds_info.pixelformat.flags & DDPF_ALPHAPIXELS)\n        {\n          matte = MagickTrue;\n          decoder = ReadUncompressedRGBA;\n        }\n      else\n        {\n          matte = MagickTrue;\n          decoder = ReadUncompressedRGB;\n        }\n    }\n  else if (dds_info.pixelformat.flags & DDPF_LUMINANCE)\n   {\n      compression = NoCompression;\n      if (dds_info.pixelformat.flags & DDPF_ALPHAPIXELS)\n        {\n          /* Not sure how to handle this */\n          ThrowReaderException(CorruptImageError, \"ImageTypeNotSupported\");\n        }\n      else\n        {\n          matte = MagickFalse;\n          decoder = ReadUncompressedRGB;\n        }\n    }\n  else if (dds_info.pixelformat.flags & DDPF_FOURCC)\n    {\n      switch (dds_info.pixelformat.fourcc)\n      {\n        case FOURCC_DXT1:\n        {\n          matte = MagickFalse;\n          compression = DXT1Compression;\n          decoder = ReadDXT1;\n          break;\n        }\n        case FOURCC_DXT3:\n        {\n          matte = MagickTrue;\n          compression = DXT3Compression;\n          decoder = ReadDXT3;\n          break;\n        }\n        case FOURCC_DXT5:\n        {\n          matte = MagickTrue;\n          compression = DXT5Compression;\n          decoder = ReadDXT5;\n          break;\n        }\n        default:\n        {\n          /* Unknown FOURCC */\n          ThrowReaderException(CorruptImageError, \"ImageTypeNotSupported\");\n        }\n      }\n    }\n  else\n    {\n      /* Neither compressed nor uncompressed... thus unsupported */\n      ThrowReaderException(CorruptImageError, \"ImageTypeNotSupported\");\n    }\n\n  num_images = 1;\n  if (cubemap)\n    {\n      /*\n        Determine number of faces defined in the cubemap\n      */\n      num_images = 0;\n      if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEX) num_images++;\n      if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEX) num_images++;\n      if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEY) num_images++;\n      if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEY) num_images++;\n      if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEZ) num_images++;\n      if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ) num_images++;\n    }\n\n   if (volume)\n     num_images = dds_info.depth;\n \n  if (num_images < 1)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n   for (n = 0; n < num_images; n++)\n   {\n     if (n != 0)\n      {\n        if (EOFBlob(image) != MagickFalse)\n          ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n        /* Start a new image */\n        AcquireNextImage(image_info,image);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          return(DestroyImageList(image));\n        image=SyncNextImageInList(image);\n      }\n \n    image->matte = matte;\n    image->compression = compression;\n    image->columns = dds_info.width;\n    image->rows = dds_info.height;\n    image->storage_class = DirectClass;\n    image->endian = LSBEndian;\n    image->depth = 8;\n    if (image_info->ping != MagickFalse)\n      {\n        (void) CloseBlob(image);\n        return(GetFirstImageInList(image));\n      }\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n\n    if ((decoder)(image, &dds_info, exception) != MagickTrue)\n      {\n        (void) CloseBlob(image);\n        return(GetFirstImageInList(image));\n      }\n  }\n\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 528,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2014-3487",
    "code_before_change": "cdf_read_property_info(const cdf_stream_t *sst, const cdf_header_t *h,\n    uint32_t offs, cdf_property_info_t **info, size_t *count, size_t *maxcount)\n{\n\tconst cdf_section_header_t *shp;\n\tcdf_section_header_t sh;\n\tconst uint8_t *p, *q, *e;\n\tint16_t s16;\n\tint32_t s32;\n\tuint32_t u32;\n\tint64_t s64;\n\tuint64_t u64;\n\tcdf_timestamp_t tp;\n\tsize_t i, o, o4, nelements, j;\n\tcdf_property_info_t *inp;\n\n\tif (offs > UINT32_MAX / 4) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\tshp = CAST(const cdf_section_header_t *, (const void *)\n\t    ((const char *)sst->sst_tab + offs));\n\tif (cdf_check_stream_offset(sst, h, shp, sizeof(*shp), __LINE__) == -1)\n\t\tgoto out;\n\tsh.sh_len = CDF_TOLE4(shp->sh_len);\n#define CDF_SHLEN_LIMIT (UINT32_MAX / 8)\n\tif (sh.sh_len > CDF_SHLEN_LIMIT) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\tsh.sh_properties = CDF_TOLE4(shp->sh_properties);\n#define CDF_PROP_LIMIT (UINT32_MAX / (4 * sizeof(*inp)))\n\tif (sh.sh_properties > CDF_PROP_LIMIT)\n\t\tgoto out;\n\tDPRINTF((\"section len: %u properties %u\\n\", sh.sh_len,\n\t    sh.sh_properties));\n\tif (*maxcount) {\n\t\tif (*maxcount > CDF_PROP_LIMIT)\n\t\t\tgoto out;\n\t\t*maxcount += sh.sh_properties;\n\t\tinp = CAST(cdf_property_info_t *,\n\t\t    realloc(*info, *maxcount * sizeof(*inp)));\n\t} else {\n\t\t*maxcount = sh.sh_properties;\n\t\tinp = CAST(cdf_property_info_t *,\n\t\t    malloc(*maxcount * sizeof(*inp)));\n\t}\n\tif (inp == NULL)\n\t\tgoto out;\n\t*info = inp;\n\tinp += *count;\n\t*count += sh.sh_properties;\n\tp = CAST(const uint8_t *, (const void *)\n\t    ((const char *)(const void *)sst->sst_tab +\n\t    offs + sizeof(sh)));\n\te = CAST(const uint8_t *, (const void *)\n\t    (((const char *)(const void *)shp) + sh.sh_len));\n \tif (cdf_check_stream_offset(sst, h, e, 0, __LINE__) == -1)\n \t\tgoto out;\n \tfor (i = 0; i < sh.sh_properties; i++) {\n\t\tsize_t ofs = CDF_GETUINT32(p, (i << 1) + 1);\n \t\tq = (const uint8_t *)(const void *)\n \t\t    ((const char *)(const void *)p + ofs\n \t\t    - 2 * sizeof(uint32_t));\n\t\tif (q > e) {\n\t\t\tDPRINTF((\"Ran of the end %p > %p\\n\", q, e));\n\t\t\tgoto out;\n\t\t}\n\t\tinp[i].pi_id = CDF_GETUINT32(p, i << 1);\n\t\tinp[i].pi_type = CDF_GETUINT32(q, 0);\n\t\tDPRINTF((\"%\" SIZE_T_FORMAT \"u) id=%x type=%x offs=0x%tx,0x%x\\n\",\n\t\t    i, inp[i].pi_id, inp[i].pi_type, q - p, offs));\n\t\tif (inp[i].pi_type & CDF_VECTOR) {\n\t\t\tnelements = CDF_GETUINT32(q, 1);\n\t\t\tif (nelements == 0) {\n\t\t\t\tDPRINTF((\"CDF_VECTOR with nelements == 0\\n\"));\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\to = 2;\n\t\t} else {\n\t\t\tnelements = 1;\n\t\t\to = 1;\n\t\t}\n\t\to4 = o * sizeof(uint32_t);\n\t\tif (inp[i].pi_type & (CDF_ARRAY|CDF_BYREF|CDF_RESERVED))\n\t\t\tgoto unknown;\n\t\tswitch (inp[i].pi_type & CDF_TYPEMASK) {\n\t\tcase CDF_NULL:\n\t\tcase CDF_EMPTY:\n\t\t\tbreak;\n\t\tcase CDF_SIGNED16:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s16, &q[o4], sizeof(s16));\n\t\t\tinp[i].pi_s16 = CDF_TOLE2(s16);\n\t\t\tbreak;\n\t\tcase CDF_SIGNED32:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s32, &q[o4], sizeof(s32));\n\t\t\tinp[i].pi_s32 = CDF_TOLE4((uint32_t)s32);\n\t\t\tbreak;\n\t\tcase CDF_BOOL:\n\t\tcase CDF_UNSIGNED32:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u32, &q[o4], sizeof(u32));\n\t\t\tinp[i].pi_u32 = CDF_TOLE4(u32);\n\t\t\tbreak;\n\t\tcase CDF_SIGNED64:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s64, &q[o4], sizeof(s64));\n\t\t\tinp[i].pi_s64 = CDF_TOLE8((uint64_t)s64);\n\t\t\tbreak;\n\t\tcase CDF_UNSIGNED64:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u64, &q[o4], sizeof(u64));\n\t\t\tinp[i].pi_u64 = CDF_TOLE8((uint64_t)u64);\n\t\t\tbreak;\n\t\tcase CDF_FLOAT:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u32, &q[o4], sizeof(u32));\n\t\t\tu32 = CDF_TOLE4(u32);\n\t\t\tmemcpy(&inp[i].pi_f, &u32, sizeof(inp[i].pi_f));\n\t\t\tbreak;\n\t\tcase CDF_DOUBLE:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u64, &q[o4], sizeof(u64));\n\t\t\tu64 = CDF_TOLE8((uint64_t)u64);\n\t\t\tmemcpy(&inp[i].pi_d, &u64, sizeof(inp[i].pi_d));\n\t\t\tbreak;\n\t\tcase CDF_LENGTH32_STRING:\n\t\tcase CDF_LENGTH32_WSTRING:\n\t\t\tif (nelements > 1) {\n\t\t\t\tsize_t nelem = inp - *info;\n\t\t\t\tif (*maxcount > CDF_PROP_LIMIT\n\t\t\t\t    || nelements > CDF_PROP_LIMIT)\n\t\t\t\t\tgoto out;\n\t\t\t\t*maxcount += nelements;\n\t\t\t\tinp = CAST(cdf_property_info_t *,\n\t\t\t\t    realloc(*info, *maxcount * sizeof(*inp)));\n\t\t\t\tif (inp == NULL)\n\t\t\t\t\tgoto out;\n\t\t\t\t*info = inp;\n\t\t\t\tinp = *info + nelem;\n\t\t\t}\n\t\t\tDPRINTF((\"nelements = %\" SIZE_T_FORMAT \"u\\n\",\n\t\t\t    nelements));\n\t\t\tfor (j = 0; j < nelements && i < sh.sh_properties;\n\t\t\t    j++, i++)\n\t\t\t{\n\t\t\t\tuint32_t l = CDF_GETUINT32(q, o);\n\t\t\t\tinp[i].pi_str.s_len = l;\n\t\t\t\tinp[i].pi_str.s_buf = (const char *)\n\t\t\t\t    (const void *)(&q[o4 + sizeof(l)]);\n\t\t\t\tDPRINTF((\"l = %d, r = %\" SIZE_T_FORMAT\n\t\t\t\t    \"u, s = %s\\n\", l,\n\t\t\t\t    CDF_ROUND(l, sizeof(l)),\n\t\t\t\t    inp[i].pi_str.s_buf));\n\t\t\t\tif (l & 1)\n\t\t\t\t\tl++;\n\t\t\t\to += l >> 1;\n\t\t\t\tif (q + o >= e)\n\t\t\t\t\tgoto out;\n\t\t\t\to4 = o * sizeof(uint32_t);\n\t\t\t}\n\t\t\ti--;\n\t\t\tbreak;\n\t\tcase CDF_FILETIME:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&tp, &q[o4], sizeof(tp));\n\t\t\tinp[i].pi_tp = CDF_TOLE8((uint64_t)tp);\n\t\t\tbreak;\n\t\tcase CDF_CLIPBOARD:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\tbreak;\n\t\tdefault:\n\t\tunknown:\n\t\t\tDPRINTF((\"Don't know how to deal with %x\\n\",\n\t\t\t    inp[i].pi_type));\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\nout:\n\tfree(*info);\n\treturn -1;\n}\n",
    "code_after_change": "cdf_read_property_info(const cdf_stream_t *sst, const cdf_header_t *h,\n    uint32_t offs, cdf_property_info_t **info, size_t *count, size_t *maxcount)\n{\n\tconst cdf_section_header_t *shp;\n\tcdf_section_header_t sh;\n\tconst uint8_t *p, *q, *e;\n\tint16_t s16;\n\tint32_t s32;\n\tuint32_t u32;\n\tint64_t s64;\n\tuint64_t u64;\n\tcdf_timestamp_t tp;\n\tsize_t i, o, o4, nelements, j;\n\tcdf_property_info_t *inp;\n\n\tif (offs > UINT32_MAX / 4) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\tshp = CAST(const cdf_section_header_t *, (const void *)\n\t    ((const char *)sst->sst_tab + offs));\n\tif (cdf_check_stream_offset(sst, h, shp, sizeof(*shp), __LINE__) == -1)\n\t\tgoto out;\n\tsh.sh_len = CDF_TOLE4(shp->sh_len);\n#define CDF_SHLEN_LIMIT (UINT32_MAX / 8)\n\tif (sh.sh_len > CDF_SHLEN_LIMIT) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\tsh.sh_properties = CDF_TOLE4(shp->sh_properties);\n#define CDF_PROP_LIMIT (UINT32_MAX / (4 * sizeof(*inp)))\n\tif (sh.sh_properties > CDF_PROP_LIMIT)\n\t\tgoto out;\n\tDPRINTF((\"section len: %u properties %u\\n\", sh.sh_len,\n\t    sh.sh_properties));\n\tif (*maxcount) {\n\t\tif (*maxcount > CDF_PROP_LIMIT)\n\t\t\tgoto out;\n\t\t*maxcount += sh.sh_properties;\n\t\tinp = CAST(cdf_property_info_t *,\n\t\t    realloc(*info, *maxcount * sizeof(*inp)));\n\t} else {\n\t\t*maxcount = sh.sh_properties;\n\t\tinp = CAST(cdf_property_info_t *,\n\t\t    malloc(*maxcount * sizeof(*inp)));\n\t}\n\tif (inp == NULL)\n\t\tgoto out;\n\t*info = inp;\n\tinp += *count;\n\t*count += sh.sh_properties;\n\tp = CAST(const uint8_t *, (const void *)\n\t    ((const char *)(const void *)sst->sst_tab +\n\t    offs + sizeof(sh)));\n\te = CAST(const uint8_t *, (const void *)\n\t    (((const char *)(const void *)shp) + sh.sh_len));\n \tif (cdf_check_stream_offset(sst, h, e, 0, __LINE__) == -1)\n \t\tgoto out;\n \tfor (i = 0; i < sh.sh_properties; i++) {\n\t\tsize_t tail = (i << 1) + 1;\n\t\tif (cdf_check_stream_offset(sst, h, p, tail * sizeof(uint32_t),\n\t\t    __LINE__) == -1)\n\t\t\tgoto out;\n\t\tsize_t ofs = CDF_GETUINT32(p, tail);\n \t\tq = (const uint8_t *)(const void *)\n \t\t    ((const char *)(const void *)p + ofs\n \t\t    - 2 * sizeof(uint32_t));\n\t\tif (q > e) {\n\t\t\tDPRINTF((\"Ran of the end %p > %p\\n\", q, e));\n\t\t\tgoto out;\n\t\t}\n\t\tinp[i].pi_id = CDF_GETUINT32(p, i << 1);\n\t\tinp[i].pi_type = CDF_GETUINT32(q, 0);\n\t\tDPRINTF((\"%\" SIZE_T_FORMAT \"u) id=%x type=%x offs=0x%tx,0x%x\\n\",\n\t\t    i, inp[i].pi_id, inp[i].pi_type, q - p, offs));\n\t\tif (inp[i].pi_type & CDF_VECTOR) {\n\t\t\tnelements = CDF_GETUINT32(q, 1);\n\t\t\tif (nelements == 0) {\n\t\t\t\tDPRINTF((\"CDF_VECTOR with nelements == 0\\n\"));\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\to = 2;\n\t\t} else {\n\t\t\tnelements = 1;\n\t\t\to = 1;\n\t\t}\n\t\to4 = o * sizeof(uint32_t);\n\t\tif (inp[i].pi_type & (CDF_ARRAY|CDF_BYREF|CDF_RESERVED))\n\t\t\tgoto unknown;\n\t\tswitch (inp[i].pi_type & CDF_TYPEMASK) {\n\t\tcase CDF_NULL:\n\t\tcase CDF_EMPTY:\n\t\t\tbreak;\n\t\tcase CDF_SIGNED16:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s16, &q[o4], sizeof(s16));\n\t\t\tinp[i].pi_s16 = CDF_TOLE2(s16);\n\t\t\tbreak;\n\t\tcase CDF_SIGNED32:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s32, &q[o4], sizeof(s32));\n\t\t\tinp[i].pi_s32 = CDF_TOLE4((uint32_t)s32);\n\t\t\tbreak;\n\t\tcase CDF_BOOL:\n\t\tcase CDF_UNSIGNED32:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u32, &q[o4], sizeof(u32));\n\t\t\tinp[i].pi_u32 = CDF_TOLE4(u32);\n\t\t\tbreak;\n\t\tcase CDF_SIGNED64:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s64, &q[o4], sizeof(s64));\n\t\t\tinp[i].pi_s64 = CDF_TOLE8((uint64_t)s64);\n\t\t\tbreak;\n\t\tcase CDF_UNSIGNED64:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u64, &q[o4], sizeof(u64));\n\t\t\tinp[i].pi_u64 = CDF_TOLE8((uint64_t)u64);\n\t\t\tbreak;\n\t\tcase CDF_FLOAT:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u32, &q[o4], sizeof(u32));\n\t\t\tu32 = CDF_TOLE4(u32);\n\t\t\tmemcpy(&inp[i].pi_f, &u32, sizeof(inp[i].pi_f));\n\t\t\tbreak;\n\t\tcase CDF_DOUBLE:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u64, &q[o4], sizeof(u64));\n\t\t\tu64 = CDF_TOLE8((uint64_t)u64);\n\t\t\tmemcpy(&inp[i].pi_d, &u64, sizeof(inp[i].pi_d));\n\t\t\tbreak;\n\t\tcase CDF_LENGTH32_STRING:\n\t\tcase CDF_LENGTH32_WSTRING:\n\t\t\tif (nelements > 1) {\n\t\t\t\tsize_t nelem = inp - *info;\n\t\t\t\tif (*maxcount > CDF_PROP_LIMIT\n\t\t\t\t    || nelements > CDF_PROP_LIMIT)\n\t\t\t\t\tgoto out;\n\t\t\t\t*maxcount += nelements;\n\t\t\t\tinp = CAST(cdf_property_info_t *,\n\t\t\t\t    realloc(*info, *maxcount * sizeof(*inp)));\n\t\t\t\tif (inp == NULL)\n\t\t\t\t\tgoto out;\n\t\t\t\t*info = inp;\n\t\t\t\tinp = *info + nelem;\n\t\t\t}\n\t\t\tDPRINTF((\"nelements = %\" SIZE_T_FORMAT \"u\\n\",\n\t\t\t    nelements));\n\t\t\tfor (j = 0; j < nelements && i < sh.sh_properties;\n\t\t\t    j++, i++)\n\t\t\t{\n\t\t\t\tuint32_t l = CDF_GETUINT32(q, o);\n\t\t\t\tinp[i].pi_str.s_len = l;\n\t\t\t\tinp[i].pi_str.s_buf = (const char *)\n\t\t\t\t    (const void *)(&q[o4 + sizeof(l)]);\n\t\t\t\tDPRINTF((\"l = %d, r = %\" SIZE_T_FORMAT\n\t\t\t\t    \"u, s = %s\\n\", l,\n\t\t\t\t    CDF_ROUND(l, sizeof(l)),\n\t\t\t\t    inp[i].pi_str.s_buf));\n\t\t\t\tif (l & 1)\n\t\t\t\t\tl++;\n\t\t\t\to += l >> 1;\n\t\t\t\tif (q + o >= e)\n\t\t\t\t\tgoto out;\n\t\t\t\to4 = o * sizeof(uint32_t);\n\t\t\t}\n\t\t\ti--;\n\t\t\tbreak;\n\t\tcase CDF_FILETIME:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&tp, &q[o4], sizeof(tp));\n\t\t\tinp[i].pi_tp = CDF_TOLE8((uint64_t)tp);\n\t\t\tbreak;\n\t\tcase CDF_CLIPBOARD:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\tbreak;\n\t\tdefault:\n\t\tunknown:\n\t\t\tDPRINTF((\"Don't know how to deal with %x\\n\",\n\t\t\t    inp[i].pi_type));\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\nout:\n\tfree(*info);\n\treturn -1;\n}\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 534,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2017-5076",
    "code_before_change": "void RequestSender::OnNetworkFetcherComplete(\n    const GURL& original_url,\n    std::unique_ptr<std::string> response_body,\n    int net_error,\n    const std::string& header_etag,\n    int64_t xheader_retry_after_sec) {\n  DCHECK(thread_checker_.CalledOnValidThread());\n\n   VLOG(1) << \"request completed from url: \" << original_url.spec();\n \n   int error = -1;\n  if (response_body && response_code_ == 200) {\n    DCHECK_EQ(0, net_error);\n     error = 0;\n  } else if (response_code_ != -1) {\n     error = response_code_;\n  } else {\n     error = net_error;\n  }\n \n   int retry_after_sec = -1;\n   if (original_url.SchemeIsCryptographic() && error > 0)\n    retry_after_sec = base::saturated_cast<int>(xheader_retry_after_sec);\n\n  base::ThreadTaskRunnerHandle::Get()->PostTask(\n      FROM_HERE, base::BindOnce(&RequestSender::SendInternalComplete,\n                                base::Unretained(this), error,\n                                response_body ? *response_body : std::string(),\n                                header_etag, retry_after_sec));\n}\n",
    "code_after_change": "void RequestSender::OnNetworkFetcherComplete(\n    const GURL& original_url,\n    std::unique_ptr<std::string> response_body,\n    int net_error,\n    const std::string& header_etag,\n    int64_t xheader_retry_after_sec) {\n  DCHECK(thread_checker_.CalledOnValidThread());\n\n   VLOG(1) << \"request completed from url: \" << original_url.spec();\n \n   int error = -1;\n  if (!net_error && response_code_ == 200)\n     error = 0;\n  else if (response_code_ != -1)\n     error = response_code_;\n  else\n     error = net_error;\n \n   int retry_after_sec = -1;\n   if (original_url.SchemeIsCryptographic() && error > 0)\n    retry_after_sec = base::saturated_cast<int>(xheader_retry_after_sec);\n\n  base::ThreadTaskRunnerHandle::Get()->PostTask(\n      FROM_HERE, base::BindOnce(&RequestSender::SendInternalComplete,\n                                base::Unretained(this), error,\n                                response_body ? *response_body : std::string(),\n                                header_etag, retry_after_sec));\n}\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 566,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2011-2358",
    "code_before_change": " void BeginInstallWithManifestFunction::OnParseSuccess(\n     const SkBitmap& icon, DictionaryValue* parsed_manifest) {\n  CHECK(parsed_manifest);\n  icon_ = icon;\n  parsed_manifest_.reset(parsed_manifest);\n\n  std::string init_errors;\n  dummy_extension_ = Extension::Create(\n      FilePath(),\n      Extension::INTERNAL,\n      *static_cast<DictionaryValue*>(parsed_manifest_.get()),\n      Extension::NO_FLAGS,\n      &init_errors);\n  if (!dummy_extension_.get()) {\n    OnParseFailure(MANIFEST_ERROR, std::string(kInvalidManifestError));\n    return;\n  }\n   if (icon_.empty())\n     icon_ = Extension::GetDefaultIcon(dummy_extension_->is_app());\n \n   ShowExtensionInstallDialog(profile(),\n                              this,\n                              dummy_extension_.get(),\n                             &icon_,\n                             dummy_extension_->GetPermissionMessageStrings(),\n                             ExtensionInstallUI::INSTALL_PROMPT);\n\n}\n",
    "code_after_change": " void BeginInstallWithManifestFunction::OnParseSuccess(\n     const SkBitmap& icon, DictionaryValue* parsed_manifest) {\n  CHECK(parsed_manifest);\n  icon_ = icon;\n  parsed_manifest_.reset(parsed_manifest);\n\n  std::string init_errors;\n  dummy_extension_ = Extension::Create(\n      FilePath(),\n      Extension::INTERNAL,\n      *static_cast<DictionaryValue*>(parsed_manifest_.get()),\n      Extension::NO_FLAGS,\n      &init_errors);\n  if (!dummy_extension_.get()) {\n    OnParseFailure(MANIFEST_ERROR, std::string(kInvalidManifestError));\n    return;\n  }\n   if (icon_.empty())\n     icon_ = Extension::GetDefaultIcon(dummy_extension_->is_app());\n \n  // In tests, we may have setup to proceed or abort without putting up the real\n  // confirmation dialog.\n  if (auto_confirm_for_tests != DO_NOT_SKIP) {\n    if (auto_confirm_for_tests == PROCEED)\n      this->InstallUIProceed();\n    else\n      this->InstallUIAbort();\n    return;\n  }\n\n   ShowExtensionInstallDialog(profile(),\n                              this,\n                              dummy_extension_.get(),\n                             &icon_,\n                             dummy_extension_->GetPermissionMessageStrings(),\n                             ExtensionInstallUI::INSTALL_PROMPT);\n\n}\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 569,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2011-2350",
    "code_before_change": "EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionObjMethodWithArgs(ExecState* exec)\n{\n    JSValue thisValue = exec->hostThisValue();\n    if (!thisValue.inherits(&JSTestObj::s_info))\n        return throwVMTypeError(exec);\n    JSTestObj* castedThis = jsCast<JSTestObj*>(asObject(thisValue));\n     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);\n     TestObj* impl = static_cast<TestObj*>(castedThis->impl());\n     if (exec->argumentCount() < 3)\n        return throwVMError(exec, createTypeError(exec, \"Not enough arguments\"));\n     int intArg(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).toInt32(exec));\n     if (exec->hadException())\n         return JSValue::encode(jsUndefined());\n    const String& strArg(ustringToString(MAYBE_MISSING_PARAMETER(exec, 1, DefaultIsUndefined).isEmpty() ? UString() : MAYBE_MISSING_PARAMETER(exec, 1, DefaultIsUndefined).toString(exec)->value(exec)));\n    if (exec->hadException())\n        return JSValue::encode(jsUndefined());\n    TestObj* objArg(toTestObj(MAYBE_MISSING_PARAMETER(exec, 2, DefaultIsUndefined)));\n    if (exec->hadException())\n        return JSValue::encode(jsUndefined());\n\n    JSC::JSValue result = toJS(exec, castedThis->globalObject(), WTF::getPtr(impl->objMethodWithArgs(intArg, strArg, objArg)));\n    return JSValue::encode(result);\n}\n",
    "code_after_change": "EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionObjMethodWithArgs(ExecState* exec)\n{\n    JSValue thisValue = exec->hostThisValue();\n    if (!thisValue.inherits(&JSTestObj::s_info))\n        return throwVMTypeError(exec);\n    JSTestObj* castedThis = jsCast<JSTestObj*>(asObject(thisValue));\n     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);\n     TestObj* impl = static_cast<TestObj*>(castedThis->impl());\n     if (exec->argumentCount() < 3)\n        return throwVMError(exec, createNotEnoughArgumentsError(exec));\n     int intArg(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).toInt32(exec));\n     if (exec->hadException())\n         return JSValue::encode(jsUndefined());\n    const String& strArg(ustringToString(MAYBE_MISSING_PARAMETER(exec, 1, DefaultIsUndefined).isEmpty() ? UString() : MAYBE_MISSING_PARAMETER(exec, 1, DefaultIsUndefined).toString(exec)->value(exec)));\n    if (exec->hadException())\n        return JSValue::encode(jsUndefined());\n    TestObj* objArg(toTestObj(MAYBE_MISSING_PARAMETER(exec, 2, DefaultIsUndefined)));\n    if (exec->hadException())\n        return JSValue::encode(jsUndefined());\n\n    JSC::JSValue result = toJS(exec, castedThis->globalObject(), WTF::getPtr(impl->objMethodWithArgs(intArg, strArg, objArg)));\n    return JSValue::encode(result);\n}\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 570,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2019-5838",
    "code_before_change": "  AccessType GetExtensionAccess(const Extension* extension,\n                                const GURL& url,\n                                 int tab_id) {\n     bool allowed_script = IsAllowedScript(extension, url, tab_id);\n     bool allowed_capture = extension->permissions_data()->CanCaptureVisiblePage(\n        url, tab_id, nullptr);\n \n     if (allowed_script && allowed_capture)\n       return ALLOWED_SCRIPT_AND_CAPTURE;\n    if (allowed_script)\n      return ALLOWED_SCRIPT_ONLY;\n    if (allowed_capture)\n      return ALLOWED_CAPTURE_ONLY;\n    return DISALLOWED;\n  }\n",
    "code_after_change": "  AccessType GetExtensionAccess(const Extension* extension,\n                                const GURL& url,\n                                 int tab_id) {\n     bool allowed_script = IsAllowedScript(extension, url, tab_id);\n     bool allowed_capture = extension->permissions_data()->CanCaptureVisiblePage(\n        url, tab_id, nullptr,\n        extensions::CaptureRequirement::kActiveTabOrAllUrls);\n \n     if (allowed_script && allowed_capture)\n       return ALLOWED_SCRIPT_AND_CAPTURE;\n    if (allowed_script)\n      return ALLOWED_SCRIPT_ONLY;\n    if (allowed_capture)\n      return ALLOWED_CAPTURE_ONLY;\n    return DISALLOWED;\n  }\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 612,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2016-3756",
    "code_before_change": " int res_unpack(vorbis_info_residue *info,\n\t\tvorbis_info *vi,oggpack_buffer *opb){\n   int j,k;\n   codec_setup_info     *ci=(codec_setup_info *)vi->codec_setup;\n   memset(info,0,sizeof(*info));\n\n  info->type=oggpack_read(opb,16);\n if(info->type>2 || info->type<0)goto errout;\n  info->begin=oggpack_read(opb,24);\n  info->end=oggpack_read(opb,24);\n  info->grouping=oggpack_read(opb,24)+1;\n  info->partitions=(char)(oggpack_read(opb,6)+1);\n  info->groupbook=(unsigned char)oggpack_read(opb,8);\n if(info->groupbook>=ci->books)goto errout;\n\n  info->stagemasks=_ogg_malloc(info->partitions*sizeof(*info->stagemasks));\n  info->stagebooks=_ogg_malloc(info->partitions*8*sizeof(*info->stagebooks));\n\n for(j=0;j<info->partitions;j++){\n int cascade=oggpack_read(opb,3);\n if(oggpack_read(opb,1))\n      cascade|=(oggpack_read(opb,5)<<3);\n    info->stagemasks[j]=cascade;\n }\n\n\n   for(j=0;j<info->partitions;j++){\n     for(k=0;k<8;k++){\n       if((info->stagemasks[j]>>k)&1){\n\tunsigned char book=(unsigned char)oggpack_read(opb,8);\n\tif(book>=ci->books)goto errout;\n\tinfo->stagebooks[j*8+k]=book;\n\tif(k+1>info->stages)info->stages=k+1;\n       }else\n\tinfo->stagebooks[j*8+k]=0xff;\n     }\n   }\n \n if(oggpack_eop(opb))goto errout;\n\n return 0;\n errout:\n  res_clear_info(info);\n return 1;\n\n }\n",
    "code_after_change": " int res_unpack(vorbis_info_residue *info,\n                vorbis_info *vi,oggpack_buffer *opb){\n   int j,k;\n   codec_setup_info     *ci=(codec_setup_info *)vi->codec_setup;\n   memset(info,0,sizeof(*info));\n\n  info->type=oggpack_read(opb,16);\n if(info->type>2 || info->type<0)goto errout;\n  info->begin=oggpack_read(opb,24);\n  info->end=oggpack_read(opb,24);\n  info->grouping=oggpack_read(opb,24)+1;\n  info->partitions=(char)(oggpack_read(opb,6)+1);\n  info->groupbook=(unsigned char)oggpack_read(opb,8);\n if(info->groupbook>=ci->books)goto errout;\n\n  info->stagemasks=_ogg_malloc(info->partitions*sizeof(*info->stagemasks));\n  info->stagebooks=_ogg_malloc(info->partitions*8*sizeof(*info->stagebooks));\n\n for(j=0;j<info->partitions;j++){\n int cascade=oggpack_read(opb,3);\n if(oggpack_read(opb,1))\n      cascade|=(oggpack_read(opb,5)<<3);\n    info->stagemasks[j]=cascade;\n }\n\n\n   for(j=0;j<info->partitions;j++){\n     for(k=0;k<8;k++){\n       if((info->stagemasks[j]>>k)&1){\n        unsigned char book=(unsigned char)oggpack_read(opb,8);\n        if(book>=ci->books)goto errout;\n        info->stagebooks[j*8+k]=book;\n        if(k+1>info->stages)info->stages=k+1;\n       }else\n        info->stagebooks[j*8+k]=0xff;\n     }\n   }\n \n if(oggpack_eop(opb))goto errout;\n\n return 0;\n errout:\n  res_clear_info(info);\n return 1;\n\n }\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 626,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2015-6784",
    "code_before_change": " WebString WebPageSerializer::generateBaseTagDeclaration(const WebString& baseTarget)\n {\n     if (baseTarget.isEmpty())\n         return String(\"<base href=\\\".\\\">\");\n     String baseString = \"<base href=\\\".\\\" target=\\\"\" + static_cast<const String&>(baseTarget) + \"\\\">\";\n    return baseString;\n}\n",
    "code_after_change": " WebString WebPageSerializer::generateBaseTagDeclaration(const WebString& baseTarget)\n {\n    // TODO(yosin) We should call |PageSerializer::baseTagDeclarationOf()|.\n     if (baseTarget.isEmpty())\n         return String(\"<base href=\\\".\\\">\");\n     String baseString = \"<base href=\\\".\\\" target=\\\"\" + static_cast<const String&>(baseTarget) + \"\\\">\";\n    return baseString;\n}\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 630,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2013-6636",
    "code_before_change": "void AutofillDialogViews::SectionContainer::SetActive(bool active) {\n  bool is_active = active && proxy_button_->visible();\n   if (is_active == !!background())\n     return;\n \n  set_background(is_active ?\n      views::Background::CreateSolidBackground(kShadingColor) :\n      NULL);\n   SchedulePaint();\n }\n",
    "code_after_change": "void AutofillDialogViews::SectionContainer::SetActive(bool active) {\n  bool is_active = active && proxy_button_->visible();\n   if (is_active == !!background())\n     return;\n \n  set_background(\n      is_active ? views::Background::CreateSolidBackground(kLightShadingColor)\n                : NULL);\n   SchedulePaint();\n }\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 631,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2016-7157",
    "code_before_change": "size_t mptsas_config_ioc_0(MPTSASState *s, uint8_t **data, int address)\n{\n    PCIDeviceClass *pcic = PCI_DEVICE_GET_CLASS(s);\n\n     return MPTSAS_CONFIG_PACK(0, MPI_CONFIG_PAGETYPE_IOC, 0x01,\n                               \"*l*lwwb*b*b*blww\",\n                               pcic->vendor_id, pcic->device_id, pcic->revision,\n                              pcic->subsystem_vendor_id,\n                               pcic->subsystem_id);\n }\n",
    "code_after_change": "size_t mptsas_config_ioc_0(MPTSASState *s, uint8_t **data, int address)\n{\n    PCIDeviceClass *pcic = PCI_DEVICE_GET_CLASS(s);\n\n     return MPTSAS_CONFIG_PACK(0, MPI_CONFIG_PAGETYPE_IOC, 0x01,\n                               \"*l*lwwb*b*b*blww\",\n                               pcic->vendor_id, pcic->device_id, pcic->revision,\n                              pcic->class_id, pcic->subsystem_vendor_id,\n                               pcic->subsystem_id);\n }\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 643,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2017-15951",
    "code_before_change": " static void dns_resolver_describe(const struct key *key, struct seq_file *m)\n {\n \tseq_puts(m, key->description);\n\tif (key_is_instantiated(key)) {\n \t\tint err = PTR_ERR(key->payload.data[dns_key_error]);\n \n \t\tif (err)\n\t\t\tseq_printf(m, \": %d\", err);\n\t\telse\n\t\t\tseq_printf(m, \": %u\", key->datalen);\n\t}\n}\n",
    "code_after_change": " static void dns_resolver_describe(const struct key *key, struct seq_file *m)\n {\n \tseq_puts(m, key->description);\n\tif (key_is_positive(key)) {\n \t\tint err = PTR_ERR(key->payload.data[dns_key_error]);\n \n \t\tif (err)\n\t\t\tseq_printf(m, \": %d\", err);\n\t\telse\n\t\t\tseq_printf(m, \": %u\", key->datalen);\n\t}\n}\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 650,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2016-3750",
    "code_before_change": "native_handle* Parcel::readNativeHandle() const\n{\n int numFds, numInts;\n status_t err;\n    err = readInt32(&numFds);\n if (err != NO_ERROR) return 0;\n    err = readInt32(&numInts);\n if (err != NO_ERROR) return 0;\n\n    native_handle* h = native_handle_create(numFds, numInts);\n if (!h) {\n return 0;\n }\n\n \n     for (int i=0 ; err==NO_ERROR && i<numFds ; i++) {\n         h->data[i] = dup(readFileDescriptor());\n        if (h->data[i] < 0) err = BAD_VALUE;\n     }\n     err = read(h->data + numFds, sizeof(int)*numInts);\n     if (err != NO_ERROR) {\n        native_handle_close(h);\n        native_handle_delete(h);\n        h = 0;\n }\n return h;\n}\n",
    "code_after_change": "native_handle* Parcel::readNativeHandle() const\n{\n int numFds, numInts;\n status_t err;\n    err = readInt32(&numFds);\n if (err != NO_ERROR) return 0;\n    err = readInt32(&numInts);\n if (err != NO_ERROR) return 0;\n\n    native_handle* h = native_handle_create(numFds, numInts);\n if (!h) {\n return 0;\n }\n\n \n     for (int i=0 ; err==NO_ERROR && i<numFds ; i++) {\n         h->data[i] = dup(readFileDescriptor());\n        if (h->data[i] < 0) {\n            for (int j = 0; j < i; j++) {\n                close(h->data[j]);\n            }\n            native_handle_delete(h);\n            return 0;\n        }\n     }\n     err = read(h->data + numFds, sizeof(int)*numInts);\n     if (err != NO_ERROR) {\n        native_handle_close(h);\n        native_handle_delete(h);\n        h = 0;\n }\n return h;\n}\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 653,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2018-14361",
    "code_before_change": "static int nntp_fetch_headers(struct Context *ctx, void *hc, anum_t first,\n                              anum_t last, int restore)\n{\n  struct NntpData *nntp_data = ctx->data;\n  struct FetchCtx fc;\n  struct Header *hdr = NULL;\n  char buf[HUGE_STRING];\n  int rc = 0;\n  int oldmsgcount = ctx->msgcount;\n  anum_t current;\n  anum_t first_over = first;\n#ifdef USE_HCACHE\n  void *hdata = NULL;\n#endif\n\n  /* if empty group or nothing to do */\n  if (!last || first > last)\n    return 0;\n\n  /* init fetch context */\n  fc.ctx = ctx;\n  fc.first = first;\n   fc.last = last;\n   fc.restore = restore;\n   fc.messages = mutt_mem_calloc(last - first + 1, sizeof(unsigned char));\n #ifdef USE_HCACHE\n   fc.hc = hc;\n #endif\n\n  /* fetch list of articles */\n  if (NntpListgroup && nntp_data->nserv->hasLISTGROUP && !nntp_data->deleted)\n  {\n    if (!ctx->quiet)\n      mutt_message(_(\"Fetching list of articles...\"));\n    if (nntp_data->nserv->hasLISTGROUPrange)\n      snprintf(buf, sizeof(buf), \"LISTGROUP %s %u-%u\\r\\n\", nntp_data->group, first, last);\n    else\n      snprintf(buf, sizeof(buf), \"LISTGROUP %s\\r\\n\", nntp_data->group);\n    rc = nntp_fetch_lines(nntp_data, buf, sizeof(buf), NULL, fetch_numbers, &fc);\n    if (rc > 0)\n    {\n      mutt_error(\"LISTGROUP: %s\", buf);\n    }\n    if (rc == 0)\n    {\n      for (current = first; current <= last && rc == 0; current++)\n      {\n        if (fc.messages[current - first])\n          continue;\n\n        snprintf(buf, sizeof(buf), \"%u\", current);\n        if (nntp_data->bcache)\n        {\n          mutt_debug(2, \"#1 mutt_bcache_del %s\\n\", buf);\n          mutt_bcache_del(nntp_data->bcache, buf);\n        }\n\n#ifdef USE_HCACHE\n        if (fc.hc)\n        {\n          mutt_debug(2, \"mutt_hcache_delete %s\\n\", buf);\n          mutt_hcache_delete(fc.hc, buf, strlen(buf));\n        }\n#endif\n      }\n    }\n  }\n  else\n  {\n    for (current = first; current <= last; current++)\n      fc.messages[current - first] = 1;\n  }\n\n  /* fetching header from cache or server, or fallback to fetch overview */\n  if (!ctx->quiet)\n  {\n    mutt_progress_init(&fc.progress, _(\"Fetching message headers...\"),\n                       MUTT_PROGRESS_MSG, ReadInc, last - first + 1);\n  }\n  for (current = first; current <= last && rc == 0; current++)\n  {\n    if (!ctx->quiet)\n      mutt_progress_update(&fc.progress, current - first + 1, -1);\n\n#ifdef USE_HCACHE\n    snprintf(buf, sizeof(buf), \"%u\", current);\n#endif\n\n    /* delete header from cache that does not exist on server */\n    if (!fc.messages[current - first])\n      continue;\n\n    /* allocate memory for headers */\n    if (ctx->msgcount >= ctx->hdrmax)\n      mx_alloc_memory(ctx);\n\n#ifdef USE_HCACHE\n    /* try to fetch header from cache */\n    hdata = mutt_hcache_fetch(fc.hc, buf, strlen(buf));\n    if (hdata)\n    {\n      mutt_debug(2, \"mutt_hcache_fetch %s\\n\", buf);\n      ctx->hdrs[ctx->msgcount] = hdr = mutt_hcache_restore(hdata);\n      mutt_hcache_free(fc.hc, &hdata);\n      hdr->data = 0;\n\n      /* skip header marked as deleted in cache */\n      if (hdr->deleted && !restore)\n      {\n        mutt_header_free(&hdr);\n        if (nntp_data->bcache)\n        {\n          mutt_debug(2, \"#2 mutt_bcache_del %s\\n\", buf);\n          mutt_bcache_del(nntp_data->bcache, buf);\n        }\n        continue;\n      }\n\n      hdr->read = false;\n      hdr->old = false;\n    }\n    else\n#endif\n\n        /* don't try to fetch header from removed newsgroup */\n        if (nntp_data->deleted)\n      continue;\n\n    /* fallback to fetch overview */\n    else if (nntp_data->nserv->hasOVER || nntp_data->nserv->hasXOVER)\n    {\n      if (NntpListgroup && nntp_data->nserv->hasLISTGROUP)\n        break;\n      else\n        continue;\n    }\n\n    /* fetch header from server */\n    else\n    {\n      FILE *fp = mutt_file_mkstemp();\n      if (!fp)\n      {\n        mutt_perror(\"mutt_file_mkstemp() failed!\");\n        rc = -1;\n        break;\n      }\n\n      snprintf(buf, sizeof(buf), \"HEAD %u\\r\\n\", current);\n      rc = nntp_fetch_lines(nntp_data, buf, sizeof(buf), NULL, fetch_tempfile, fp);\n      if (rc)\n      {\n        mutt_file_fclose(&fp);\n        if (rc < 0)\n          break;\n\n        /* invalid response */\n        if (mutt_str_strncmp(\"423\", buf, 3) != 0)\n        {\n          mutt_error(\"HEAD: %s\", buf);\n          break;\n        }\n\n        /* no such article */\n        if (nntp_data->bcache)\n        {\n          snprintf(buf, sizeof(buf), \"%u\", current);\n          mutt_debug(2, \"#3 mutt_bcache_del %s\\n\", buf);\n          mutt_bcache_del(nntp_data->bcache, buf);\n        }\n        rc = 0;\n        continue;\n      }\n\n      /* parse header */\n      hdr = ctx->hdrs[ctx->msgcount] = mutt_header_new();\n      hdr->env = mutt_rfc822_read_header(fp, hdr, 0, 0);\n      hdr->received = hdr->date_sent;\n      mutt_file_fclose(&fp);\n    }\n\n    /* save header in context */\n    hdr->index = ctx->msgcount++;\n    hdr->read = false;\n    hdr->old = false;\n    hdr->deleted = false;\n    hdr->data = mutt_mem_calloc(1, sizeof(struct NntpHeaderData));\n    NHDR(hdr)->article_num = current;\n    if (restore)\n      hdr->changed = true;\n    else\n    {\n      nntp_article_status(ctx, hdr, NULL, NHDR(hdr)->article_num);\n      if (!hdr->read)\n        nntp_parse_xref(ctx, hdr);\n    }\n    if (current > nntp_data->last_loaded)\n      nntp_data->last_loaded = current;\n    first_over = current + 1;\n  }\n\n  if (!NntpListgroup || !nntp_data->nserv->hasLISTGROUP)\n    current = first_over;\n\n  /* fetch overview information */\n  if (current <= last && rc == 0 && !nntp_data->deleted)\n  {\n    char *cmd = nntp_data->nserv->hasOVER ? \"OVER\" : \"XOVER\";\n    snprintf(buf, sizeof(buf), \"%s %u-%u\\r\\n\", cmd, current, last);\n    rc = nntp_fetch_lines(nntp_data, buf, sizeof(buf), NULL, parse_overview_line, &fc);\n    if (rc > 0)\n    {\n      mutt_error(\"%s: %s\", cmd, buf);\n    }\n  }\n\n  if (ctx->msgcount > oldmsgcount)\n    mx_update_context(ctx, ctx->msgcount - oldmsgcount);\n\n  FREE(&fc.messages);\n  if (rc != 0)\n    return -1;\n  mutt_clear_error();\n  return 0;\n}\n",
    "code_after_change": "static int nntp_fetch_headers(struct Context *ctx, void *hc, anum_t first,\n                              anum_t last, int restore)\n{\n  struct NntpData *nntp_data = ctx->data;\n  struct FetchCtx fc;\n  struct Header *hdr = NULL;\n  char buf[HUGE_STRING];\n  int rc = 0;\n  int oldmsgcount = ctx->msgcount;\n  anum_t current;\n  anum_t first_over = first;\n#ifdef USE_HCACHE\n  void *hdata = NULL;\n#endif\n\n  /* if empty group or nothing to do */\n  if (!last || first > last)\n    return 0;\n\n  /* init fetch context */\n  fc.ctx = ctx;\n  fc.first = first;\n   fc.last = last;\n   fc.restore = restore;\n   fc.messages = mutt_mem_calloc(last - first + 1, sizeof(unsigned char));\n  if (fc.messages == NULL)\n\t  return -1;\n #ifdef USE_HCACHE\n   fc.hc = hc;\n #endif\n\n  /* fetch list of articles */\n  if (NntpListgroup && nntp_data->nserv->hasLISTGROUP && !nntp_data->deleted)\n  {\n    if (!ctx->quiet)\n      mutt_message(_(\"Fetching list of articles...\"));\n    if (nntp_data->nserv->hasLISTGROUPrange)\n      snprintf(buf, sizeof(buf), \"LISTGROUP %s %u-%u\\r\\n\", nntp_data->group, first, last);\n    else\n      snprintf(buf, sizeof(buf), \"LISTGROUP %s\\r\\n\", nntp_data->group);\n    rc = nntp_fetch_lines(nntp_data, buf, sizeof(buf), NULL, fetch_numbers, &fc);\n    if (rc > 0)\n    {\n      mutt_error(\"LISTGROUP: %s\", buf);\n    }\n    if (rc == 0)\n    {\n      for (current = first; current <= last && rc == 0; current++)\n      {\n        if (fc.messages[current - first])\n          continue;\n\n        snprintf(buf, sizeof(buf), \"%u\", current);\n        if (nntp_data->bcache)\n        {\n          mutt_debug(2, \"#1 mutt_bcache_del %s\\n\", buf);\n          mutt_bcache_del(nntp_data->bcache, buf);\n        }\n\n#ifdef USE_HCACHE\n        if (fc.hc)\n        {\n          mutt_debug(2, \"mutt_hcache_delete %s\\n\", buf);\n          mutt_hcache_delete(fc.hc, buf, strlen(buf));\n        }\n#endif\n      }\n    }\n  }\n  else\n  {\n    for (current = first; current <= last; current++)\n      fc.messages[current - first] = 1;\n  }\n\n  /* fetching header from cache or server, or fallback to fetch overview */\n  if (!ctx->quiet)\n  {\n    mutt_progress_init(&fc.progress, _(\"Fetching message headers...\"),\n                       MUTT_PROGRESS_MSG, ReadInc, last - first + 1);\n  }\n  for (current = first; current <= last && rc == 0; current++)\n  {\n    if (!ctx->quiet)\n      mutt_progress_update(&fc.progress, current - first + 1, -1);\n\n#ifdef USE_HCACHE\n    snprintf(buf, sizeof(buf), \"%u\", current);\n#endif\n\n    /* delete header from cache that does not exist on server */\n    if (!fc.messages[current - first])\n      continue;\n\n    /* allocate memory for headers */\n    if (ctx->msgcount >= ctx->hdrmax)\n      mx_alloc_memory(ctx);\n\n#ifdef USE_HCACHE\n    /* try to fetch header from cache */\n    hdata = mutt_hcache_fetch(fc.hc, buf, strlen(buf));\n    if (hdata)\n    {\n      mutt_debug(2, \"mutt_hcache_fetch %s\\n\", buf);\n      ctx->hdrs[ctx->msgcount] = hdr = mutt_hcache_restore(hdata);\n      mutt_hcache_free(fc.hc, &hdata);\n      hdr->data = 0;\n\n      /* skip header marked as deleted in cache */\n      if (hdr->deleted && !restore)\n      {\n        mutt_header_free(&hdr);\n        if (nntp_data->bcache)\n        {\n          mutt_debug(2, \"#2 mutt_bcache_del %s\\n\", buf);\n          mutt_bcache_del(nntp_data->bcache, buf);\n        }\n        continue;\n      }\n\n      hdr->read = false;\n      hdr->old = false;\n    }\n    else\n#endif\n\n        /* don't try to fetch header from removed newsgroup */\n        if (nntp_data->deleted)\n      continue;\n\n    /* fallback to fetch overview */\n    else if (nntp_data->nserv->hasOVER || nntp_data->nserv->hasXOVER)\n    {\n      if (NntpListgroup && nntp_data->nserv->hasLISTGROUP)\n        break;\n      else\n        continue;\n    }\n\n    /* fetch header from server */\n    else\n    {\n      FILE *fp = mutt_file_mkstemp();\n      if (!fp)\n      {\n        mutt_perror(\"mutt_file_mkstemp() failed!\");\n        rc = -1;\n        break;\n      }\n\n      snprintf(buf, sizeof(buf), \"HEAD %u\\r\\n\", current);\n      rc = nntp_fetch_lines(nntp_data, buf, sizeof(buf), NULL, fetch_tempfile, fp);\n      if (rc)\n      {\n        mutt_file_fclose(&fp);\n        if (rc < 0)\n          break;\n\n        /* invalid response */\n        if (mutt_str_strncmp(\"423\", buf, 3) != 0)\n        {\n          mutt_error(\"HEAD: %s\", buf);\n          break;\n        }\n\n        /* no such article */\n        if (nntp_data->bcache)\n        {\n          snprintf(buf, sizeof(buf), \"%u\", current);\n          mutt_debug(2, \"#3 mutt_bcache_del %s\\n\", buf);\n          mutt_bcache_del(nntp_data->bcache, buf);\n        }\n        rc = 0;\n        continue;\n      }\n\n      /* parse header */\n      hdr = ctx->hdrs[ctx->msgcount] = mutt_header_new();\n      hdr->env = mutt_rfc822_read_header(fp, hdr, 0, 0);\n      hdr->received = hdr->date_sent;\n      mutt_file_fclose(&fp);\n    }\n\n    /* save header in context */\n    hdr->index = ctx->msgcount++;\n    hdr->read = false;\n    hdr->old = false;\n    hdr->deleted = false;\n    hdr->data = mutt_mem_calloc(1, sizeof(struct NntpHeaderData));\n    NHDR(hdr)->article_num = current;\n    if (restore)\n      hdr->changed = true;\n    else\n    {\n      nntp_article_status(ctx, hdr, NULL, NHDR(hdr)->article_num);\n      if (!hdr->read)\n        nntp_parse_xref(ctx, hdr);\n    }\n    if (current > nntp_data->last_loaded)\n      nntp_data->last_loaded = current;\n    first_over = current + 1;\n  }\n\n  if (!NntpListgroup || !nntp_data->nserv->hasLISTGROUP)\n    current = first_over;\n\n  /* fetch overview information */\n  if (current <= last && rc == 0 && !nntp_data->deleted)\n  {\n    char *cmd = nntp_data->nserv->hasOVER ? \"OVER\" : \"XOVER\";\n    snprintf(buf, sizeof(buf), \"%s %u-%u\\r\\n\", cmd, current, last);\n    rc = nntp_fetch_lines(nntp_data, buf, sizeof(buf), NULL, parse_overview_line, &fc);\n    if (rc > 0)\n    {\n      mutt_error(\"%s: %s\", cmd, buf);\n    }\n  }\n\n  if (ctx->msgcount > oldmsgcount)\n    mx_update_context(ctx, ctx->msgcount - oldmsgcount);\n\n  FREE(&fc.messages);\n  if (rc != 0)\n    return -1;\n  mutt_clear_error();\n  return 0;\n}\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 666,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2015-5195",
    "code_before_change": "config_monitor(\n\tconfig_tree *ptree\n\t)\n{\n\tint_node *pfilegen_token;\n\tconst char *filegen_string;\n\tconst char *filegen_file;\n\tFILEGEN *filegen;\n\tfilegen_node *my_node;\n\tattr_val *my_opts;\n\tint filegen_type;\n\tint filegen_flag;\n\n\t/* Set the statistics directory */\n\tif (ptree->stats_dir)\n\t\tstats_config(STATS_STATSDIR, ptree->stats_dir);\n\n\t/* NOTE:\n\t * Calling filegen_get is brain dead. Doing a string\n\t * comparison to find the relavant filegen structure is\n\t * expensive.\n\t *\n\t * Through the parser, we already know which filegen is\n\t * being specified. Hence, we should either store a\n\t * pointer to the specified structure in the syntax tree\n\t * or an index into a filegen array.\n\t *\n\t * Need to change the filegen code to reflect the above.\n\t */\n\n\t/* Turn on the specified statistics */\n\tpfilegen_token = HEAD_PFIFO(ptree->stats_list);\n \tfor (; pfilegen_token != NULL; pfilegen_token = pfilegen_token->link) {\n \t\tfilegen_string = keyword(pfilegen_token->i);\n \t\tfilegen = filegen_get(filegen_string);\n \t\tDPRINTF(4, (\"enabling filegen for %s statistics '%s%s'\\n\",\n \t\t\t    filegen_string, filegen->prefix, \n \t\t\t    filegen->basename));\n\t\tfilegen->flag |= FGEN_FLAG_ENABLED;\n\t}\n\n\t/* Configure the statistics with the options */\n\tmy_node = HEAD_PFIFO(ptree->filegen_opts);\n \tfor (; my_node != NULL; my_node = my_node->link) {\n \t\tfilegen_file = keyword(my_node->filegen_token);\n \t\tfilegen = filegen_get(filegen_file);\n \n \t\t/* Initialize the filegen variables to their pre-configuration states */\n \t\tfilegen_flag = filegen->flag;\n\t\tfilegen_type = filegen->type;\n\n\t\t/* \"filegen ... enabled\" is the default (when filegen is used) */\n\t\tfilegen_flag |= FGEN_FLAG_ENABLED;\n\n\t\tmy_opts = HEAD_PFIFO(my_node->options);\n\t\tfor (; my_opts != NULL; my_opts = my_opts->link) {\n\t\t\tswitch (my_opts->attr) {\n\n\t\t\tcase T_File:\n\t\t\t\tfilegen_file = my_opts->value.s;\n\t\t\t\tbreak;\n\n\t\t\tcase T_Type:\n\t\t\t\tswitch (my_opts->value.i) {\n\n\t\t\t\tdefault:\n\t\t\t\t\tNTP_INSIST(0);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase T_None:\n\t\t\t\t\tfilegen_type = FILEGEN_NONE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase T_Pid:\n\t\t\t\t\tfilegen_type = FILEGEN_PID;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase T_Day:\n\t\t\t\t\tfilegen_type = FILEGEN_DAY;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase T_Week:\n\t\t\t\t\tfilegen_type = FILEGEN_WEEK;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase T_Month:\n\t\t\t\t\tfilegen_type = FILEGEN_MONTH;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase T_Year:\n\t\t\t\t\tfilegen_type = FILEGEN_YEAR;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase T_Age:\n\t\t\t\t\tfilegen_type = FILEGEN_AGE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase T_Flag:\n\t\t\t\tswitch (my_opts->value.i) {\n\n\t\t\t\tcase T_Link:\n\t\t\t\t\tfilegen_flag |= FGEN_FLAG_LINK;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase T_Nolink:\n\t\t\t\t\tfilegen_flag &= ~FGEN_FLAG_LINK;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase T_Enable:\n\t\t\t\t\tfilegen_flag |= FGEN_FLAG_ENABLED;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase T_Disable:\n\t\t\t\t\tfilegen_flag &= ~FGEN_FLAG_ENABLED;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tmsyslog(LOG_ERR, \n\t\t\t\t\t\t\"Unknown filegen flag token %d\",\n\t\t\t\t\t\tmy_opts->value.i);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tmsyslog(LOG_ERR,\n\t\t\t\t\t\"Unknown filegen option token %d\",\n\t\t\t\t\tmy_opts->attr);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\tfilegen_config(filegen, filegen_file, filegen_type,\n\t\t\t       filegen_flag);\n\t}\n}\n",
    "code_after_change": "config_monitor(\n\tconfig_tree *ptree\n\t)\n{\n\tint_node *pfilegen_token;\n\tconst char *filegen_string;\n\tconst char *filegen_file;\n\tFILEGEN *filegen;\n\tfilegen_node *my_node;\n\tattr_val *my_opts;\n\tint filegen_type;\n\tint filegen_flag;\n\n\t/* Set the statistics directory */\n\tif (ptree->stats_dir)\n\t\tstats_config(STATS_STATSDIR, ptree->stats_dir);\n\n\t/* NOTE:\n\t * Calling filegen_get is brain dead. Doing a string\n\t * comparison to find the relavant filegen structure is\n\t * expensive.\n\t *\n\t * Through the parser, we already know which filegen is\n\t * being specified. Hence, we should either store a\n\t * pointer to the specified structure in the syntax tree\n\t * or an index into a filegen array.\n\t *\n\t * Need to change the filegen code to reflect the above.\n\t */\n\n\t/* Turn on the specified statistics */\n\tpfilegen_token = HEAD_PFIFO(ptree->stats_list);\n \tfor (; pfilegen_token != NULL; pfilegen_token = pfilegen_token->link) {\n \t\tfilegen_string = keyword(pfilegen_token->i);\n \t\tfilegen = filegen_get(filegen_string);\n\t\tif (NULL == filegen) {\n\t\t\tmsyslog(LOG_ERR,\n\t\t\t\t\"stats %s unrecognized\",\n\t\t\t\tfilegen_string);\n\t\t\tcontinue;\n\t\t}\n \t\tDPRINTF(4, (\"enabling filegen for %s statistics '%s%s'\\n\",\n \t\t\t    filegen_string, filegen->prefix, \n \t\t\t    filegen->basename));\n\t\tfilegen->flag |= FGEN_FLAG_ENABLED;\n\t}\n\n\t/* Configure the statistics with the options */\n\tmy_node = HEAD_PFIFO(ptree->filegen_opts);\n \tfor (; my_node != NULL; my_node = my_node->link) {\n \t\tfilegen_file = keyword(my_node->filegen_token);\n \t\tfilegen = filegen_get(filegen_file);\n\t\tif (NULL == filegen) {\n\t\t\tmsyslog(LOG_ERR,\n\t\t\t\t\"filegen category '%s' unrecognized\",\n\t\t\t\tfilegen_file);\n\t\t\tcontinue;\n\t\t}\n \n \t\t/* Initialize the filegen variables to their pre-configuration states */\n \t\tfilegen_flag = filegen->flag;\n\t\tfilegen_type = filegen->type;\n\n\t\t/* \"filegen ... enabled\" is the default (when filegen is used) */\n\t\tfilegen_flag |= FGEN_FLAG_ENABLED;\n\n\t\tmy_opts = HEAD_PFIFO(my_node->options);\n\t\tfor (; my_opts != NULL; my_opts = my_opts->link) {\n\t\t\tswitch (my_opts->attr) {\n\n\t\t\tcase T_File:\n\t\t\t\tfilegen_file = my_opts->value.s;\n\t\t\t\tbreak;\n\n\t\t\tcase T_Type:\n\t\t\t\tswitch (my_opts->value.i) {\n\n\t\t\t\tdefault:\n\t\t\t\t\tNTP_INSIST(0);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase T_None:\n\t\t\t\t\tfilegen_type = FILEGEN_NONE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase T_Pid:\n\t\t\t\t\tfilegen_type = FILEGEN_PID;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase T_Day:\n\t\t\t\t\tfilegen_type = FILEGEN_DAY;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase T_Week:\n\t\t\t\t\tfilegen_type = FILEGEN_WEEK;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase T_Month:\n\t\t\t\t\tfilegen_type = FILEGEN_MONTH;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase T_Year:\n\t\t\t\t\tfilegen_type = FILEGEN_YEAR;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase T_Age:\n\t\t\t\t\tfilegen_type = FILEGEN_AGE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase T_Flag:\n\t\t\t\tswitch (my_opts->value.i) {\n\n\t\t\t\tcase T_Link:\n\t\t\t\t\tfilegen_flag |= FGEN_FLAG_LINK;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase T_Nolink:\n\t\t\t\t\tfilegen_flag &= ~FGEN_FLAG_LINK;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase T_Enable:\n\t\t\t\t\tfilegen_flag |= FGEN_FLAG_ENABLED;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase T_Disable:\n\t\t\t\t\tfilegen_flag &= ~FGEN_FLAG_ENABLED;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tmsyslog(LOG_ERR, \n\t\t\t\t\t\t\"Unknown filegen flag token %d\",\n\t\t\t\t\t\tmy_opts->value.i);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tmsyslog(LOG_ERR,\n\t\t\t\t\t\"Unknown filegen option token %d\",\n\t\t\t\t\tmy_opts->attr);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\tfilegen_config(filegen, filegen_file, filegen_type,\n\t\t\t       filegen_flag);\n\t}\n}\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 690,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2018-6111",
    "code_before_change": " NetworkHandler::NetworkHandler(const std::string& host_id)\n     : DevToolsDomainHandler(Network::Metainfo::domainName),\n      process_(nullptr),\n       host_(nullptr),\n       enabled_(false),\n       host_id_(host_id),\n      bypass_service_worker_(false),\n      cache_disabled_(false),\n      weak_factory_(this) {\n  static bool have_configured_service_worker_context = false;\n  if (have_configured_service_worker_context)\n    return;\n  have_configured_service_worker_context = true;\n  BrowserThread::PostTask(BrowserThread::IO, FROM_HERE,\n                          base::BindOnce(&ConfigureServiceWorkerContextOnIO));\n}\n",
    "code_after_change": " NetworkHandler::NetworkHandler(const std::string& host_id)\n     : DevToolsDomainHandler(Network::Metainfo::domainName),\n      browser_context_(nullptr),\n      storage_partition_(nullptr),\n       host_(nullptr),\n       enabled_(false),\n       host_id_(host_id),\n      bypass_service_worker_(false),\n      cache_disabled_(false),\n      weak_factory_(this) {\n  static bool have_configured_service_worker_context = false;\n  if (have_configured_service_worker_context)\n    return;\n  have_configured_service_worker_context = true;\n  BrowserThread::PostTask(BrowserThread::IO, FROM_HERE,\n                          base::BindOnce(&ConfigureServiceWorkerContextOnIO));\n}\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 709,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2014-9907",
    "code_before_change": "static MagickBooleanType SkipDXTMipmaps(Image *image,DDSInfo *dds_info,\n  int texel_size,ExceptionInfo *exception)\n{\n  register ssize_t\n    i;\n\n  MagickOffsetType\n    offset;\n\n  size_t\n    h,\n    w;\n\n   /*\n     Only skip mipmaps for textures and cube maps\n   */\n   if (dds_info->ddscaps1 & DDSCAPS_MIPMAP\n       && (dds_info->ddscaps1 & DDSCAPS_TEXTURE\n           || dds_info->ddscaps2 & DDSCAPS2_CUBEMAP))\n     {\n      if (EOFBlob(image) != MagickFalse)\n        {\n          ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n            image->filename);\n          return(MagickFalse);\n        }\n       w = DIV2(dds_info->width);\n       h = DIV2(dds_info->height);\n \n      /*\n        Mipmapcount includes the main image, so start from one\n      */\n      for (i = 1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++)\n      {\n        offset = (MagickOffsetType) ((w + 3) / 4) * ((h + 3) / 4) * texel_size;\n        (void) SeekBlob(image, offset, SEEK_CUR);\n\n        w = DIV2(w);\n        h = DIV2(h);\n      }\n    }\n  return(MagickTrue);\n}\n",
    "code_after_change": "static MagickBooleanType SkipDXTMipmaps(Image *image,DDSInfo *dds_info,\n  int texel_size,ExceptionInfo *exception)\n{\n  register ssize_t\n    i;\n\n  MagickOffsetType\n    offset;\n\n  size_t\n    h,\n    w;\n\n   /*\n     Only skip mipmaps for textures and cube maps\n   */\n  if (EOFBlob(image) != MagickFalse)\n    {\n      ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n        image->filename);\n      return(MagickFalse);\n    }\n   if (dds_info->ddscaps1 & DDSCAPS_MIPMAP\n       && (dds_info->ddscaps1 & DDSCAPS_TEXTURE\n           || dds_info->ddscaps2 & DDSCAPS2_CUBEMAP))\n     {\n       w = DIV2(dds_info->width);\n       h = DIV2(dds_info->height);\n \n      /*\n        Mipmapcount includes the main image, so start from one\n      */\n      for (i = 1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++)\n      {\n        offset = (MagickOffsetType) ((w + 3) / 4) * ((h + 3) / 4) * texel_size;\n        (void) SeekBlob(image, offset, SEEK_CUR);\n\n        w = DIV2(w);\n        h = DIV2(h);\n      }\n    }\n  return(MagickTrue);\n}\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 711,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2016-3741",
    "code_before_change": "WORD32 ih264d_start_of_pic(dec_struct_t *ps_dec,\n                         WORD32 i4_poc,\n pocstruct_t *ps_temp_poc,\n                         UWORD16 u2_frame_num,\n dec_pic_params_t *ps_pps)\n{\n pocstruct_t *ps_prev_poc = &ps_dec->s_cur_pic_poc;\n pocstruct_t *ps_cur_poc = ps_temp_poc;\n\n pic_buffer_t *pic_buf;\n\n ivd_video_decode_op_t * ps_dec_output =\n (ivd_video_decode_op_t *)ps_dec->pv_dec_out;\n dec_slice_params_t *ps_cur_slice = ps_dec->ps_cur_slice;\n dec_seq_params_t *ps_seq = ps_pps->ps_sps;\n    UWORD8 u1_bottom_field_flag = ps_cur_slice->u1_bottom_field_flag;\n    UWORD8 u1_field_pic_flag = ps_cur_slice->u1_field_pic_flag;\n /* high profile related declarations */\n high_profile_tools_t s_high_profile;\n    WORD32 ret;\n\n    H264_MUTEX_LOCK(&ps_dec->process_disp_mutex);\n\n    ps_prev_poc->i4_pic_order_cnt_lsb = ps_cur_poc->i4_pic_order_cnt_lsb;\n    ps_prev_poc->i4_pic_order_cnt_msb = ps_cur_poc->i4_pic_order_cnt_msb;\n    ps_prev_poc->i4_delta_pic_order_cnt_bottom =\n                    ps_cur_poc->i4_delta_pic_order_cnt_bottom;\n    ps_prev_poc->i4_delta_pic_order_cnt[0] =\n                    ps_cur_poc->i4_delta_pic_order_cnt[0];\n    ps_prev_poc->i4_delta_pic_order_cnt[1] =\n                    ps_cur_poc->i4_delta_pic_order_cnt[1];\n    ps_prev_poc->u1_bot_field = ps_dec->ps_cur_slice->u1_bottom_field_flag;\n    ps_prev_poc->i4_prev_frame_num_ofst = ps_cur_poc->i4_prev_frame_num_ofst;\n    ps_prev_poc->u2_frame_num = u2_frame_num;\n    ps_dec->i1_prev_mb_qp_delta = 0;\n    ps_dec->i1_next_ctxt_idx = 0;\n\n\n    ps_dec->u4_nmb_deblk = 0;\n if(ps_dec->u4_num_cores == 1)\n       ps_dec->u4_nmb_deblk = 1;\n\n\n\n if(ps_seq->u1_mb_aff_flag == 1)\n {\n        ps_dec->u4_nmb_deblk = 0;\n if(ps_dec->u4_num_cores > 2)\n            ps_dec->u4_num_cores = 2;\n }\n\n        ps_dec->u4_use_intrapred_line_copy = 0;\n\n\n\n if (ps_seq->u1_mb_aff_flag == 0)\n {\n        ps_dec->u4_use_intrapred_line_copy = 1;\n }\n\n    ps_dec->u4_app_disable_deblk_frm = 0;\n /* If degrade is enabled, set the degrade flags appropriately */\n if(ps_dec->i4_degrade_type && ps_dec->i4_degrade_pics)\n {\n        WORD32 degrade_pic;\n        ps_dec->i4_degrade_pic_cnt++;\n        degrade_pic = 0;\n\n /* If degrade is to be done in all frames, then do not check further */\n switch(ps_dec->i4_degrade_pics)\n {\n case 4:\n {\n                degrade_pic = 1;\n break;\n }\n case 3:\n {\n if(ps_cur_slice->u1_slice_type != I_SLICE)\n                    degrade_pic = 1;\n\n break;\n }\n case 2:\n {\n\n /* If pic count hits non-degrade interval or it is an islice, then do not degrade */\n if((ps_cur_slice->u1_slice_type != I_SLICE)\n && (ps_dec->i4_degrade_pic_cnt\n != ps_dec->i4_nondegrade_interval))\n                    degrade_pic = 1;\n\n break;\n }\n case 1:\n {\n /* Check if the current picture is non-ref */\n if(0 == ps_cur_slice->u1_nal_ref_idc)\n {\n                    degrade_pic = 1;\n }\n break;\n }\n\n }\n if(degrade_pic)\n {\n if(ps_dec->i4_degrade_type & 0x2)\n                ps_dec->u4_app_disable_deblk_frm = 1;\n\n /* MC degrading is done only for non-ref pictures */\n if(0 == ps_cur_slice->u1_nal_ref_idc)\n {\n if(ps_dec->i4_degrade_type & 0x4)\n                    ps_dec->i4_mv_frac_mask = 0;\n\n if(ps_dec->i4_degrade_type & 0x8)\n                    ps_dec->i4_mv_frac_mask = 0;\n }\n }\n else\n            ps_dec->i4_degrade_pic_cnt = 0;\n }\n\n {\n dec_err_status_t * ps_err = ps_dec->ps_dec_err_status;\n if(ps_dec->u1_sl_typ_5_9\n && ((ps_cur_slice->u1_slice_type == I_SLICE)\n || (ps_cur_slice->u1_slice_type\n == SI_SLICE)))\n            ps_err->u1_cur_pic_type = PIC_TYPE_I;\n else\n            ps_err->u1_cur_pic_type = PIC_TYPE_UNKNOWN;\n\n if(ps_err->u1_pic_aud_i == PIC_TYPE_I)\n {\n            ps_err->u1_cur_pic_type = PIC_TYPE_I;\n            ps_err->u1_pic_aud_i = PIC_TYPE_UNKNOWN;\n }\n\n if(ps_cur_slice->u1_nal_unit_type == IDR_SLICE_NAL)\n {\n if(ps_err->u1_err_flag)\n                ih264d_reset_ref_bufs(ps_dec->ps_dpb_mgr);\n            ps_err->u1_err_flag = ACCEPT_ALL_PICS;\n }\n }\n\n if(ps_dec->u1_init_dec_flag && ps_dec->s_prev_seq_params.u1_eoseq_pending)\n {\n /* Reset the decoder picture buffers */\n        WORD32 j;\n for(j = 0; j < MAX_DISP_BUFS_NEW; j++)\n {\n\n            ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n                                  j,\n                                  BUF_MGR_REF);\n            ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_mv_buf_mgr,\n                                  ps_dec->au1_pic_buf_id_mv_buf_id_map[j],\n                                  BUF_MGR_REF);\n            ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n                                  j,\n                                  BUF_MGR_IO);\n }\n\n /* reset the decoder structure parameters related to buffer handling */\n        ps_dec->u1_second_field = 0;\n        ps_dec->i4_cur_display_seq = 0;\n\n /********************************************************************/\n /* indicate in the decoder output i4_status that some frames are being */\n /* dropped, so that it resets timestamp and wait for a new sequence */\n /********************************************************************/\n\n        ps_dec->s_prev_seq_params.u1_eoseq_pending = 0;\n }\n    ret = ih264d_init_pic(ps_dec, u2_frame_num, i4_poc, ps_pps);\n if(ret != OK)\n return ret;\n\n    ps_dec->pv_parse_tu_coeff_data = ps_dec->pv_pic_tu_coeff_data;\n    ps_dec->pv_proc_tu_coeff_data  = ps_dec->pv_pic_tu_coeff_data;\n    ps_dec->ps_nmb_info = ps_dec->ps_frm_mb_info;\n if(ps_dec->u1_separate_parse)\n {\n        UWORD16 pic_wd;\n        UWORD16 pic_ht;\n        UWORD32 num_mbs;\n\n        pic_wd = ps_dec->u2_pic_wd;\n        pic_ht = ps_dec->u2_pic_ht;\n        num_mbs = (pic_wd * pic_ht) >> 8;\n\n if(ps_dec->pu1_dec_mb_map)\n {\n            memset((void *)ps_dec->pu1_dec_mb_map, 0, num_mbs);\n }\n\n if(ps_dec->pu1_recon_mb_map)\n {\n\n            memset((void *)ps_dec->pu1_recon_mb_map, 0, num_mbs);\n }\n\n if(ps_dec->pu2_slice_num_map)\n {\n            memset((void *)ps_dec->pu2_slice_num_map, 0,\n (num_mbs * sizeof(UWORD16)));\n }\n\n }\n\n    ps_dec->ps_parse_cur_slice = &(ps_dec->ps_dec_slice_buf[0]);\n    ps_dec->ps_decode_cur_slice = &(ps_dec->ps_dec_slice_buf[0]);\n    ps_dec->ps_computebs_cur_slice = &(ps_dec->ps_dec_slice_buf[0]);\n\n /* Initialize all the HP toolsets to zero */\n    ps_dec->s_high_profile.u1_scaling_present = 0;\n    ps_dec->s_high_profile.u1_transform8x8_present = 0;\n\n /* Get Next Free Picture */\n if(1 == ps_dec->u4_share_disp_buf)\n {\n        UWORD32 i;\n /* Free any buffer that is in the queue to be freed */\n for(i = 0; i < MAX_DISP_BUFS_NEW; i++)\n {\n if(0 == ps_dec->u4_disp_buf_to_be_freed[i])\n continue;\n            ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr, i,\n            BUF_MGR_IO);\n            ps_dec->u4_disp_buf_to_be_freed[i] = 0;\n            ps_dec->u4_disp_buf_mapping[i] = 0;\n\n }\n }\n if(!(u1_field_pic_flag && 0 != ps_dec->u1_top_bottom_decoded)) //ps_dec->u1_second_field))\n {\n pic_buffer_t *ps_cur_pic;\n        WORD32 cur_pic_buf_id, cur_mv_buf_id;\n col_mv_buf_t *ps_col_mv;\n while(1)\n {\n            ps_cur_pic = (pic_buffer_t *)ih264_buf_mgr_get_next_free(\n (buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n &cur_pic_buf_id);\n if(ps_cur_pic == NULL)\n {\n                ps_dec->i4_error_code = ERROR_UNAVAIL_PICBUF_T;\n return ERROR_UNAVAIL_PICBUF_T;\n }\n if(0 == ps_dec->u4_disp_buf_mapping[cur_pic_buf_id])\n {\n break;\n }\n\n }\n        ps_col_mv = (col_mv_buf_t *)ih264_buf_mgr_get_next_free((buf_mgr_t *)ps_dec->pv_mv_buf_mgr,\n &cur_mv_buf_id);\n if(ps_col_mv == NULL)\n {\n            ps_dec->i4_error_code = ERROR_UNAVAIL_MVBUF_T;\n return ERROR_UNAVAIL_MVBUF_T;\n }\n\n        ps_dec->ps_cur_pic = ps_cur_pic;\n        ps_dec->u1_pic_buf_id = cur_pic_buf_id;\n        ps_cur_pic->u4_ts = ps_dec->u4_ts;\n\n\n        ps_cur_pic->u1_mv_buf_id = cur_mv_buf_id;\n        ps_dec->au1_pic_buf_id_mv_buf_id_map[cur_pic_buf_id] = cur_mv_buf_id;\n\n        ps_cur_pic->pu1_col_zero_flag = (UWORD8 *)ps_col_mv->pv_col_zero_flag;\n        ps_cur_pic->ps_mv = (mv_pred_t *)ps_col_mv->pv_mv;\n        ps_dec->au1_pic_buf_ref_flag[cur_pic_buf_id] = 0;\n if(ps_dec->u1_first_slice_in_stream)\n {\n /*make first entry of list0 point to cur pic,so that if first Islice is in error, ref pic struct will have valid entries*/\n            ps_dec->ps_ref_pic_buf_lx[0] = ps_dec->ps_dpb_mgr->ps_init_dpb[0];\n *(ps_dec->ps_dpb_mgr->ps_init_dpb[0][0]) = *ps_cur_pic;\n }\n\n if(!ps_dec->ps_cur_pic)\n {\n            WORD32 j;\n            H264_DEC_DEBUG_PRINT(\"------- Display Buffers Reset --------\\n\");\n for(j = 0; j < MAX_DISP_BUFS_NEW; j++)\n {\n\n                ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n                                      j,\n                                      BUF_MGR_REF);\n                ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_mv_buf_mgr,\n                                      ps_dec->au1_pic_buf_id_mv_buf_id_map[j],\n                                      BUF_MGR_REF);\n                ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n                                      j,\n                                      BUF_MGR_IO);\n }\n\n            ps_dec->i4_cur_display_seq = 0;\n            ps_dec->i4_prev_max_display_seq = 0;\n            ps_dec->i4_max_poc = 0;\n\n            ps_cur_pic = (pic_buffer_t *)ih264_buf_mgr_get_next_free(\n (buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n &cur_pic_buf_id);\n if(ps_cur_pic == NULL)\n {\n                ps_dec->i4_error_code = ERROR_UNAVAIL_PICBUF_T;\n return ERROR_UNAVAIL_PICBUF_T;\n }\n\n            ps_col_mv = (col_mv_buf_t *)ih264_buf_mgr_get_next_free((buf_mgr_t *)ps_dec->pv_mv_buf_mgr,\n &cur_mv_buf_id);\n if(ps_col_mv == NULL)\n {\n                ps_dec->i4_error_code = ERROR_UNAVAIL_MVBUF_T;\n return ERROR_UNAVAIL_MVBUF_T;\n }\n\n            ps_dec->ps_cur_pic = ps_cur_pic;\n            ps_dec->u1_pic_buf_id = cur_pic_buf_id;\n            ps_cur_pic->u4_ts = ps_dec->u4_ts;\n            ps_dec->apv_buf_id_pic_buf_map[cur_pic_buf_id] = (void *)ps_cur_pic;\n\n            ps_cur_pic->u1_mv_buf_id = cur_mv_buf_id;\n            ps_dec->au1_pic_buf_id_mv_buf_id_map[cur_pic_buf_id] = cur_mv_buf_id;\n\n            ps_cur_pic->pu1_col_zero_flag = (UWORD8 *)ps_col_mv->pv_col_zero_flag;\n            ps_cur_pic->ps_mv = (mv_pred_t *)ps_col_mv->pv_mv;\n            ps_dec->au1_pic_buf_ref_flag[cur_pic_buf_id] = 0;\n\n }\n\n        ps_dec->ps_cur_pic->u1_picturetype = u1_field_pic_flag;\n        ps_dec->ps_cur_pic->u4_pack_slc_typ = SKIP_NONE;\n        H264_DEC_DEBUG_PRINT(\"got a buffer\\n\");\n }\n else\n {\n        H264_DEC_DEBUG_PRINT(\"did not get a buffer\\n\");\n }\n\n    ps_dec->u4_pic_buf_got = 1;\n\n    ps_dec->ps_cur_pic->i4_poc = i4_poc;\n    ps_dec->ps_cur_pic->i4_frame_num = u2_frame_num;\n    ps_dec->ps_cur_pic->i4_pic_num = u2_frame_num;\n    ps_dec->ps_cur_pic->i4_top_field_order_cnt = ps_pps->i4_top_field_order_cnt;\n    ps_dec->ps_cur_pic->i4_bottom_field_order_cnt =\n                    ps_pps->i4_bottom_field_order_cnt;\n    ps_dec->ps_cur_pic->i4_avg_poc = ps_pps->i4_avg_poc;\n    ps_dec->ps_cur_pic->u4_time_stamp = ps_dec->u4_pts;\n\n    ps_dec->s_cur_pic = *(ps_dec->ps_cur_pic);\n if(u1_field_pic_flag && u1_bottom_field_flag)\n {\n        WORD32 i4_temp_poc;\n        WORD32 i4_top_field_order_poc, i4_bot_field_order_poc;\n /* Point to odd lines, since it's bottom field */\n        ps_dec->s_cur_pic.pu1_buf1 += ps_dec->s_cur_pic.u2_frm_wd_y;\n        ps_dec->s_cur_pic.pu1_buf2 += ps_dec->s_cur_pic.u2_frm_wd_uv;\n        ps_dec->s_cur_pic.pu1_buf3 += ps_dec->s_cur_pic.u2_frm_wd_uv;\n        ps_dec->s_cur_pic.ps_mv +=\n ((ps_dec->u2_pic_ht * ps_dec->u2_pic_wd) >> 5);\n        ps_dec->s_cur_pic.pu1_col_zero_flag += ((ps_dec->u2_pic_ht\n * ps_dec->u2_pic_wd) >> 5);\n        ps_dec->ps_cur_pic->u1_picturetype |= BOT_FLD;\n        i4_top_field_order_poc = ps_dec->ps_cur_pic->i4_top_field_order_cnt;\n        i4_bot_field_order_poc = ps_dec->ps_cur_pic->i4_bottom_field_order_cnt;\n        i4_temp_poc = MIN(i4_top_field_order_poc,\n                                 i4_bot_field_order_poc);\n        ps_dec->ps_cur_pic->i4_avg_poc = i4_temp_poc;\n }\n\n    ps_cur_slice->u1_mbaff_frame_flag = ps_seq->u1_mb_aff_flag\n && (!u1_field_pic_flag);\n\n    ps_dec->ps_cur_pic->u1_picturetype |= (ps_cur_slice->u1_mbaff_frame_flag\n << 2);\n\n    ps_dec->ps_cur_mb_row = ps_dec->ps_nbr_mb_row; //[0];\n    ps_dec->ps_cur_mb_row += 2;\n    ps_dec->ps_top_mb_row = ps_dec->ps_nbr_mb_row;\n    ps_dec->ps_top_mb_row += ((ps_dec->u2_frm_wd_in_mbs + 2) << (1 - ps_dec->ps_cur_sps->u1_frame_mbs_only_flag));\n    ps_dec->ps_top_mb_row += 2;\n\n /* CHANGED CODE */\n    ps_dec->ps_mv_cur = ps_dec->s_cur_pic.ps_mv;\n    ps_dec->ps_mv_top = ps_dec->ps_mv_top_p[0];\n /* CHANGED CODE */\n    ps_dec->u1_mv_top_p = 0;\n    ps_dec->u1_mb_idx = 0;\n /* CHANGED CODE */\n    ps_dec->ps_mv_left = ps_dec->s_cur_pic.ps_mv;\n    ps_dec->u2_total_mbs_coded = 0;\n    ps_dec->i4_submb_ofst = -(SUB_BLK_SIZE);\n    ps_dec->u4_pred_info_idx = 0;\n    ps_dec->u4_pred_info_pkd_idx = 0;\n    ps_dec->u4_dma_buf_idx = 0;\n    ps_dec->ps_mv = ps_dec->s_cur_pic.ps_mv;\n    ps_dec->ps_mv_bank_cur = ps_dec->s_cur_pic.ps_mv;\n    ps_dec->pu1_col_zero_flag = ps_dec->s_cur_pic.pu1_col_zero_flag;\n    ps_dec->ps_part = ps_dec->ps_parse_part_params;\n    ps_dec->i2_prev_slice_mbx = -1;\n    ps_dec->i2_prev_slice_mby = 0;\n    ps_dec->u2_mv_2mb[0] = 0;\n    ps_dec->u2_mv_2mb[1] = 0;\n    ps_dec->u1_last_pic_not_decoded = 0;\n\n    ps_dec->u2_cur_slice_num = 0;\n    ps_dec->u2_cur_slice_num_dec_thread = 0;\n    ps_dec->u2_cur_slice_num_bs = 0;\n    ps_dec->u4_intra_pred_line_ofst = 0;\n    ps_dec->pu1_cur_y_intra_pred_line = ps_dec->pu1_y_intra_pred_line;\n    ps_dec->pu1_cur_u_intra_pred_line = ps_dec->pu1_u_intra_pred_line;\n    ps_dec->pu1_cur_v_intra_pred_line = ps_dec->pu1_v_intra_pred_line;\n\n    ps_dec->pu1_cur_y_intra_pred_line_base = ps_dec->pu1_y_intra_pred_line;\n    ps_dec->pu1_cur_u_intra_pred_line_base = ps_dec->pu1_u_intra_pred_line;\n    ps_dec->pu1_cur_v_intra_pred_line_base = ps_dec->pu1_v_intra_pred_line;\n\n\n\n\n\n    ps_dec->pu1_prev_y_intra_pred_line = ps_dec->pu1_y_intra_pred_line\n + (ps_dec->u2_frm_wd_in_mbs * MB_SIZE);\n\n    ps_dec->pu1_prev_u_intra_pred_line = ps_dec->pu1_u_intra_pred_line\n + ps_dec->u2_frm_wd_in_mbs * BLK8x8SIZE * YUV420SP_FACTOR;\n    ps_dec->pu1_prev_v_intra_pred_line = ps_dec->pu1_v_intra_pred_line\n + ps_dec->u2_frm_wd_in_mbs * BLK8x8SIZE;\n\n    ps_dec->ps_deblk_mbn = ps_dec->ps_deblk_pic;\n /* Initialize The Function Pointer Depending Upon the Entropy and MbAff Flag */\n {\n if(ps_cur_slice->u1_mbaff_frame_flag)\n {\n            ps_dec->pf_compute_bs = ih264d_compute_bs_mbaff;\n            ps_dec->pf_mvpred = ih264d_mvpred_mbaff;\n }\n else\n {\n            ps_dec->pf_compute_bs = ih264d_compute_bs_non_mbaff;\n            ps_dec->u1_cur_mb_fld_dec_flag = ps_cur_slice->u1_field_pic_flag;\n }\n }\n /* Set up the Parameter for DMA transfer */\n {\n        UWORD8 u1_field_pic_flag = ps_dec->ps_cur_slice->u1_field_pic_flag;\n\n        UWORD8 u1_mbaff = ps_cur_slice->u1_mbaff_frame_flag;\n\n        UWORD8 uc_lastmbs = (((ps_dec->u2_pic_wd) >> 4)\n % (ps_dec->u1_recon_mb_grp >> u1_mbaff));\n        UWORD16 ui16_lastmbs_widthY =\n (uc_lastmbs ? (uc_lastmbs << 4) : ((ps_dec->u1_recon_mb_grp\n >> u1_mbaff) << 4));\n        UWORD16 ui16_lastmbs_widthUV =\n                        uc_lastmbs ? (uc_lastmbs << 3) : ((ps_dec->u1_recon_mb_grp\n >> u1_mbaff) << 3);\n\n        ps_dec->s_tran_addrecon.pu1_dest_y = ps_dec->s_cur_pic.pu1_buf1;\n        ps_dec->s_tran_addrecon.pu1_dest_u = ps_dec->s_cur_pic.pu1_buf2;\n        ps_dec->s_tran_addrecon.pu1_dest_v = ps_dec->s_cur_pic.pu1_buf3;\n\n        ps_dec->s_tran_addrecon.u2_frm_wd_y = ps_dec->u2_frm_wd_y\n << u1_field_pic_flag;\n        ps_dec->s_tran_addrecon.u2_frm_wd_uv = ps_dec->u2_frm_wd_uv\n << u1_field_pic_flag;\n\n if(u1_field_pic_flag)\n {\n            ui16_lastmbs_widthY += ps_dec->u2_frm_wd_y;\n            ui16_lastmbs_widthUV += ps_dec->u2_frm_wd_uv;\n }\n\n /* Normal Increment of Pointer */\n        ps_dec->s_tran_addrecon.u4_inc_y[0] = ((ps_dec->u1_recon_mb_grp << 4)\n >> u1_mbaff);\n        ps_dec->s_tran_addrecon.u4_inc_uv[0] = ((ps_dec->u1_recon_mb_grp << 4)\n >> u1_mbaff);\n\n /* End of Row Increment */\n        ps_dec->s_tran_addrecon.u4_inc_y[1] = (ui16_lastmbs_widthY\n + (PAD_LEN_Y_H << 1)\n + ps_dec->s_tran_addrecon.u2_frm_wd_y\n * ((15 << u1_mbaff) + u1_mbaff));\n        ps_dec->s_tran_addrecon.u4_inc_uv[1] = (ui16_lastmbs_widthUV\n + (PAD_LEN_UV_H << 2)\n + ps_dec->s_tran_addrecon.u2_frm_wd_uv\n * ((15 << u1_mbaff) + u1_mbaff));\n\n /* Assign picture numbers to each frame/field  */\n /* only once per picture.                      */\n        ih264d_assign_pic_num(ps_dec);\n        ps_dec->s_tran_addrecon.u2_mv_top_left_inc = (ps_dec->u1_recon_mb_grp\n << 2) - 1 - (u1_mbaff << 2);\n        ps_dec->s_tran_addrecon.u2_mv_left_inc = ((ps_dec->u1_recon_mb_grp\n >> u1_mbaff) - 1) << (4 + u1_mbaff);\n }\n /**********************************************************************/\n /* High profile related initialization at pictrue level               */\n /**********************************************************************/\n if(ps_seq->u1_profile_idc == HIGH_PROFILE_IDC)\n {\n if((ps_seq->i4_seq_scaling_matrix_present_flag)\n || (ps_pps->i4_pic_scaling_matrix_present_flag))\n {\n            ih264d_form_scaling_matrix_picture(ps_seq, ps_pps, ps_dec);\n            ps_dec->s_high_profile.u1_scaling_present = 1;\n }\n else\n {\n            ih264d_form_default_scaling_matrix(ps_dec);\n }\n\n if(ps_pps->i4_transform_8x8_mode_flag)\n {\n            ps_dec->s_high_profile.u1_transform8x8_present = 1;\n }\n }\n else\n {\n        ih264d_form_default_scaling_matrix(ps_dec);\n }\n\n /* required while reading the transform_size_8x8 u4_flag */\n    ps_dec->s_high_profile.u1_direct_8x8_inference_flag =\n                    ps_seq->u1_direct_8x8_inference_flag;\n    ps_dec->s_high_profile.s_cavlc_ctxt = ps_dec->s_cavlc_ctxt;\n\n    ps_dec->i1_recon_in_thread3_flag = 1;\n    ps_dec->ps_frame_buf_ip_recon = &ps_dec->s_tran_addrecon;\n if(ps_dec->u1_separate_parse)\n {\n        memcpy(&ps_dec->s_tran_addrecon_parse, &ps_dec->s_tran_addrecon,\n sizeof(tfr_ctxt_t));\n if(ps_dec->u4_num_cores >= 3 && ps_dec->i1_recon_in_thread3_flag)\n {\n            memcpy(&ps_dec->s_tran_iprecon, &ps_dec->s_tran_addrecon,\n sizeof(tfr_ctxt_t));\n            ps_dec->ps_frame_buf_ip_recon = &ps_dec->s_tran_iprecon;\n }\n }\n\n\n    ih264d_init_deblk_tfr_ctxt(ps_dec,&(ps_dec->s_pad_mgr), &(ps_dec->s_tran_addrecon),\n                               ps_dec->u2_frm_wd_in_mbs, 0);\n\n    ps_dec->ps_cur_deblk_mb = ps_dec->ps_deblk_pic;\n    ps_dec->u4_cur_deblk_mb_num = 0;\n\n \n     ps_dec->u4_deblk_mb_x = 0;\n     ps_dec->u4_deblk_mb_y = 0;\n \n     H264_MUTEX_UNLOCK(&ps_dec->process_disp_mutex);\n     return OK;\n}\n",
    "code_after_change": "WORD32 ih264d_start_of_pic(dec_struct_t *ps_dec,\n                         WORD32 i4_poc,\n pocstruct_t *ps_temp_poc,\n                         UWORD16 u2_frame_num,\n dec_pic_params_t *ps_pps)\n{\n pocstruct_t *ps_prev_poc = &ps_dec->s_cur_pic_poc;\n pocstruct_t *ps_cur_poc = ps_temp_poc;\n\n pic_buffer_t *pic_buf;\n\n ivd_video_decode_op_t * ps_dec_output =\n (ivd_video_decode_op_t *)ps_dec->pv_dec_out;\n dec_slice_params_t *ps_cur_slice = ps_dec->ps_cur_slice;\n dec_seq_params_t *ps_seq = ps_pps->ps_sps;\n    UWORD8 u1_bottom_field_flag = ps_cur_slice->u1_bottom_field_flag;\n    UWORD8 u1_field_pic_flag = ps_cur_slice->u1_field_pic_flag;\n /* high profile related declarations */\n high_profile_tools_t s_high_profile;\n    WORD32 ret;\n\n    H264_MUTEX_LOCK(&ps_dec->process_disp_mutex);\n\n    ps_prev_poc->i4_pic_order_cnt_lsb = ps_cur_poc->i4_pic_order_cnt_lsb;\n    ps_prev_poc->i4_pic_order_cnt_msb = ps_cur_poc->i4_pic_order_cnt_msb;\n    ps_prev_poc->i4_delta_pic_order_cnt_bottom =\n                    ps_cur_poc->i4_delta_pic_order_cnt_bottom;\n    ps_prev_poc->i4_delta_pic_order_cnt[0] =\n                    ps_cur_poc->i4_delta_pic_order_cnt[0];\n    ps_prev_poc->i4_delta_pic_order_cnt[1] =\n                    ps_cur_poc->i4_delta_pic_order_cnt[1];\n    ps_prev_poc->u1_bot_field = ps_dec->ps_cur_slice->u1_bottom_field_flag;\n    ps_prev_poc->i4_prev_frame_num_ofst = ps_cur_poc->i4_prev_frame_num_ofst;\n    ps_prev_poc->u2_frame_num = u2_frame_num;\n    ps_dec->i1_prev_mb_qp_delta = 0;\n    ps_dec->i1_next_ctxt_idx = 0;\n\n\n    ps_dec->u4_nmb_deblk = 0;\n if(ps_dec->u4_num_cores == 1)\n       ps_dec->u4_nmb_deblk = 1;\n\n\n\n if(ps_seq->u1_mb_aff_flag == 1)\n {\n        ps_dec->u4_nmb_deblk = 0;\n if(ps_dec->u4_num_cores > 2)\n            ps_dec->u4_num_cores = 2;\n }\n\n        ps_dec->u4_use_intrapred_line_copy = 0;\n\n\n\n if (ps_seq->u1_mb_aff_flag == 0)\n {\n        ps_dec->u4_use_intrapred_line_copy = 1;\n }\n\n    ps_dec->u4_app_disable_deblk_frm = 0;\n /* If degrade is enabled, set the degrade flags appropriately */\n if(ps_dec->i4_degrade_type && ps_dec->i4_degrade_pics)\n {\n        WORD32 degrade_pic;\n        ps_dec->i4_degrade_pic_cnt++;\n        degrade_pic = 0;\n\n /* If degrade is to be done in all frames, then do not check further */\n switch(ps_dec->i4_degrade_pics)\n {\n case 4:\n {\n                degrade_pic = 1;\n break;\n }\n case 3:\n {\n if(ps_cur_slice->u1_slice_type != I_SLICE)\n                    degrade_pic = 1;\n\n break;\n }\n case 2:\n {\n\n /* If pic count hits non-degrade interval or it is an islice, then do not degrade */\n if((ps_cur_slice->u1_slice_type != I_SLICE)\n && (ps_dec->i4_degrade_pic_cnt\n != ps_dec->i4_nondegrade_interval))\n                    degrade_pic = 1;\n\n break;\n }\n case 1:\n {\n /* Check if the current picture is non-ref */\n if(0 == ps_cur_slice->u1_nal_ref_idc)\n {\n                    degrade_pic = 1;\n }\n break;\n }\n\n }\n if(degrade_pic)\n {\n if(ps_dec->i4_degrade_type & 0x2)\n                ps_dec->u4_app_disable_deblk_frm = 1;\n\n /* MC degrading is done only for non-ref pictures */\n if(0 == ps_cur_slice->u1_nal_ref_idc)\n {\n if(ps_dec->i4_degrade_type & 0x4)\n                    ps_dec->i4_mv_frac_mask = 0;\n\n if(ps_dec->i4_degrade_type & 0x8)\n                    ps_dec->i4_mv_frac_mask = 0;\n }\n }\n else\n            ps_dec->i4_degrade_pic_cnt = 0;\n }\n\n {\n dec_err_status_t * ps_err = ps_dec->ps_dec_err_status;\n if(ps_dec->u1_sl_typ_5_9\n && ((ps_cur_slice->u1_slice_type == I_SLICE)\n || (ps_cur_slice->u1_slice_type\n == SI_SLICE)))\n            ps_err->u1_cur_pic_type = PIC_TYPE_I;\n else\n            ps_err->u1_cur_pic_type = PIC_TYPE_UNKNOWN;\n\n if(ps_err->u1_pic_aud_i == PIC_TYPE_I)\n {\n            ps_err->u1_cur_pic_type = PIC_TYPE_I;\n            ps_err->u1_pic_aud_i = PIC_TYPE_UNKNOWN;\n }\n\n if(ps_cur_slice->u1_nal_unit_type == IDR_SLICE_NAL)\n {\n if(ps_err->u1_err_flag)\n                ih264d_reset_ref_bufs(ps_dec->ps_dpb_mgr);\n            ps_err->u1_err_flag = ACCEPT_ALL_PICS;\n }\n }\n\n if(ps_dec->u1_init_dec_flag && ps_dec->s_prev_seq_params.u1_eoseq_pending)\n {\n /* Reset the decoder picture buffers */\n        WORD32 j;\n for(j = 0; j < MAX_DISP_BUFS_NEW; j++)\n {\n\n            ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n                                  j,\n                                  BUF_MGR_REF);\n            ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_mv_buf_mgr,\n                                  ps_dec->au1_pic_buf_id_mv_buf_id_map[j],\n                                  BUF_MGR_REF);\n            ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n                                  j,\n                                  BUF_MGR_IO);\n }\n\n /* reset the decoder structure parameters related to buffer handling */\n        ps_dec->u1_second_field = 0;\n        ps_dec->i4_cur_display_seq = 0;\n\n /********************************************************************/\n /* indicate in the decoder output i4_status that some frames are being */\n /* dropped, so that it resets timestamp and wait for a new sequence */\n /********************************************************************/\n\n        ps_dec->s_prev_seq_params.u1_eoseq_pending = 0;\n }\n    ret = ih264d_init_pic(ps_dec, u2_frame_num, i4_poc, ps_pps);\n if(ret != OK)\n return ret;\n\n    ps_dec->pv_parse_tu_coeff_data = ps_dec->pv_pic_tu_coeff_data;\n    ps_dec->pv_proc_tu_coeff_data  = ps_dec->pv_pic_tu_coeff_data;\n    ps_dec->ps_nmb_info = ps_dec->ps_frm_mb_info;\n if(ps_dec->u1_separate_parse)\n {\n        UWORD16 pic_wd;\n        UWORD16 pic_ht;\n        UWORD32 num_mbs;\n\n        pic_wd = ps_dec->u2_pic_wd;\n        pic_ht = ps_dec->u2_pic_ht;\n        num_mbs = (pic_wd * pic_ht) >> 8;\n\n if(ps_dec->pu1_dec_mb_map)\n {\n            memset((void *)ps_dec->pu1_dec_mb_map, 0, num_mbs);\n }\n\n if(ps_dec->pu1_recon_mb_map)\n {\n\n            memset((void *)ps_dec->pu1_recon_mb_map, 0, num_mbs);\n }\n\n if(ps_dec->pu2_slice_num_map)\n {\n            memset((void *)ps_dec->pu2_slice_num_map, 0,\n (num_mbs * sizeof(UWORD16)));\n }\n\n }\n\n    ps_dec->ps_parse_cur_slice = &(ps_dec->ps_dec_slice_buf[0]);\n    ps_dec->ps_decode_cur_slice = &(ps_dec->ps_dec_slice_buf[0]);\n    ps_dec->ps_computebs_cur_slice = &(ps_dec->ps_dec_slice_buf[0]);\n\n /* Initialize all the HP toolsets to zero */\n    ps_dec->s_high_profile.u1_scaling_present = 0;\n    ps_dec->s_high_profile.u1_transform8x8_present = 0;\n\n /* Get Next Free Picture */\n if(1 == ps_dec->u4_share_disp_buf)\n {\n        UWORD32 i;\n /* Free any buffer that is in the queue to be freed */\n for(i = 0; i < MAX_DISP_BUFS_NEW; i++)\n {\n if(0 == ps_dec->u4_disp_buf_to_be_freed[i])\n continue;\n            ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr, i,\n            BUF_MGR_IO);\n            ps_dec->u4_disp_buf_to_be_freed[i] = 0;\n            ps_dec->u4_disp_buf_mapping[i] = 0;\n\n }\n }\n if(!(u1_field_pic_flag && 0 != ps_dec->u1_top_bottom_decoded)) //ps_dec->u1_second_field))\n {\n pic_buffer_t *ps_cur_pic;\n        WORD32 cur_pic_buf_id, cur_mv_buf_id;\n col_mv_buf_t *ps_col_mv;\n while(1)\n {\n            ps_cur_pic = (pic_buffer_t *)ih264_buf_mgr_get_next_free(\n (buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n &cur_pic_buf_id);\n if(ps_cur_pic == NULL)\n {\n                ps_dec->i4_error_code = ERROR_UNAVAIL_PICBUF_T;\n return ERROR_UNAVAIL_PICBUF_T;\n }\n if(0 == ps_dec->u4_disp_buf_mapping[cur_pic_buf_id])\n {\n break;\n }\n\n }\n        ps_col_mv = (col_mv_buf_t *)ih264_buf_mgr_get_next_free((buf_mgr_t *)ps_dec->pv_mv_buf_mgr,\n &cur_mv_buf_id);\n if(ps_col_mv == NULL)\n {\n            ps_dec->i4_error_code = ERROR_UNAVAIL_MVBUF_T;\n return ERROR_UNAVAIL_MVBUF_T;\n }\n\n        ps_dec->ps_cur_pic = ps_cur_pic;\n        ps_dec->u1_pic_buf_id = cur_pic_buf_id;\n        ps_cur_pic->u4_ts = ps_dec->u4_ts;\n\n\n        ps_cur_pic->u1_mv_buf_id = cur_mv_buf_id;\n        ps_dec->au1_pic_buf_id_mv_buf_id_map[cur_pic_buf_id] = cur_mv_buf_id;\n\n        ps_cur_pic->pu1_col_zero_flag = (UWORD8 *)ps_col_mv->pv_col_zero_flag;\n        ps_cur_pic->ps_mv = (mv_pred_t *)ps_col_mv->pv_mv;\n        ps_dec->au1_pic_buf_ref_flag[cur_pic_buf_id] = 0;\n if(ps_dec->u1_first_slice_in_stream)\n {\n /*make first entry of list0 point to cur pic,so that if first Islice is in error, ref pic struct will have valid entries*/\n            ps_dec->ps_ref_pic_buf_lx[0] = ps_dec->ps_dpb_mgr->ps_init_dpb[0];\n *(ps_dec->ps_dpb_mgr->ps_init_dpb[0][0]) = *ps_cur_pic;\n }\n\n if(!ps_dec->ps_cur_pic)\n {\n            WORD32 j;\n            H264_DEC_DEBUG_PRINT(\"------- Display Buffers Reset --------\\n\");\n for(j = 0; j < MAX_DISP_BUFS_NEW; j++)\n {\n\n                ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n                                      j,\n                                      BUF_MGR_REF);\n                ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_mv_buf_mgr,\n                                      ps_dec->au1_pic_buf_id_mv_buf_id_map[j],\n                                      BUF_MGR_REF);\n                ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n                                      j,\n                                      BUF_MGR_IO);\n }\n\n            ps_dec->i4_cur_display_seq = 0;\n            ps_dec->i4_prev_max_display_seq = 0;\n            ps_dec->i4_max_poc = 0;\n\n            ps_cur_pic = (pic_buffer_t *)ih264_buf_mgr_get_next_free(\n (buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n &cur_pic_buf_id);\n if(ps_cur_pic == NULL)\n {\n                ps_dec->i4_error_code = ERROR_UNAVAIL_PICBUF_T;\n return ERROR_UNAVAIL_PICBUF_T;\n }\n\n            ps_col_mv = (col_mv_buf_t *)ih264_buf_mgr_get_next_free((buf_mgr_t *)ps_dec->pv_mv_buf_mgr,\n &cur_mv_buf_id);\n if(ps_col_mv == NULL)\n {\n                ps_dec->i4_error_code = ERROR_UNAVAIL_MVBUF_T;\n return ERROR_UNAVAIL_MVBUF_T;\n }\n\n            ps_dec->ps_cur_pic = ps_cur_pic;\n            ps_dec->u1_pic_buf_id = cur_pic_buf_id;\n            ps_cur_pic->u4_ts = ps_dec->u4_ts;\n            ps_dec->apv_buf_id_pic_buf_map[cur_pic_buf_id] = (void *)ps_cur_pic;\n\n            ps_cur_pic->u1_mv_buf_id = cur_mv_buf_id;\n            ps_dec->au1_pic_buf_id_mv_buf_id_map[cur_pic_buf_id] = cur_mv_buf_id;\n\n            ps_cur_pic->pu1_col_zero_flag = (UWORD8 *)ps_col_mv->pv_col_zero_flag;\n            ps_cur_pic->ps_mv = (mv_pred_t *)ps_col_mv->pv_mv;\n            ps_dec->au1_pic_buf_ref_flag[cur_pic_buf_id] = 0;\n\n }\n\n        ps_dec->ps_cur_pic->u1_picturetype = u1_field_pic_flag;\n        ps_dec->ps_cur_pic->u4_pack_slc_typ = SKIP_NONE;\n        H264_DEC_DEBUG_PRINT(\"got a buffer\\n\");\n }\n else\n {\n        H264_DEC_DEBUG_PRINT(\"did not get a buffer\\n\");\n }\n\n    ps_dec->u4_pic_buf_got = 1;\n\n    ps_dec->ps_cur_pic->i4_poc = i4_poc;\n    ps_dec->ps_cur_pic->i4_frame_num = u2_frame_num;\n    ps_dec->ps_cur_pic->i4_pic_num = u2_frame_num;\n    ps_dec->ps_cur_pic->i4_top_field_order_cnt = ps_pps->i4_top_field_order_cnt;\n    ps_dec->ps_cur_pic->i4_bottom_field_order_cnt =\n                    ps_pps->i4_bottom_field_order_cnt;\n    ps_dec->ps_cur_pic->i4_avg_poc = ps_pps->i4_avg_poc;\n    ps_dec->ps_cur_pic->u4_time_stamp = ps_dec->u4_pts;\n\n    ps_dec->s_cur_pic = *(ps_dec->ps_cur_pic);\n if(u1_field_pic_flag && u1_bottom_field_flag)\n {\n        WORD32 i4_temp_poc;\n        WORD32 i4_top_field_order_poc, i4_bot_field_order_poc;\n /* Point to odd lines, since it's bottom field */\n        ps_dec->s_cur_pic.pu1_buf1 += ps_dec->s_cur_pic.u2_frm_wd_y;\n        ps_dec->s_cur_pic.pu1_buf2 += ps_dec->s_cur_pic.u2_frm_wd_uv;\n        ps_dec->s_cur_pic.pu1_buf3 += ps_dec->s_cur_pic.u2_frm_wd_uv;\n        ps_dec->s_cur_pic.ps_mv +=\n ((ps_dec->u2_pic_ht * ps_dec->u2_pic_wd) >> 5);\n        ps_dec->s_cur_pic.pu1_col_zero_flag += ((ps_dec->u2_pic_ht\n * ps_dec->u2_pic_wd) >> 5);\n        ps_dec->ps_cur_pic->u1_picturetype |= BOT_FLD;\n        i4_top_field_order_poc = ps_dec->ps_cur_pic->i4_top_field_order_cnt;\n        i4_bot_field_order_poc = ps_dec->ps_cur_pic->i4_bottom_field_order_cnt;\n        i4_temp_poc = MIN(i4_top_field_order_poc,\n                                 i4_bot_field_order_poc);\n        ps_dec->ps_cur_pic->i4_avg_poc = i4_temp_poc;\n }\n\n    ps_cur_slice->u1_mbaff_frame_flag = ps_seq->u1_mb_aff_flag\n && (!u1_field_pic_flag);\n\n    ps_dec->ps_cur_pic->u1_picturetype |= (ps_cur_slice->u1_mbaff_frame_flag\n << 2);\n\n    ps_dec->ps_cur_mb_row = ps_dec->ps_nbr_mb_row; //[0];\n    ps_dec->ps_cur_mb_row += 2;\n    ps_dec->ps_top_mb_row = ps_dec->ps_nbr_mb_row;\n    ps_dec->ps_top_mb_row += ((ps_dec->u2_frm_wd_in_mbs + 2) << (1 - ps_dec->ps_cur_sps->u1_frame_mbs_only_flag));\n    ps_dec->ps_top_mb_row += 2;\n\n /* CHANGED CODE */\n    ps_dec->ps_mv_cur = ps_dec->s_cur_pic.ps_mv;\n    ps_dec->ps_mv_top = ps_dec->ps_mv_top_p[0];\n /* CHANGED CODE */\n    ps_dec->u1_mv_top_p = 0;\n    ps_dec->u1_mb_idx = 0;\n /* CHANGED CODE */\n    ps_dec->ps_mv_left = ps_dec->s_cur_pic.ps_mv;\n    ps_dec->u2_total_mbs_coded = 0;\n    ps_dec->i4_submb_ofst = -(SUB_BLK_SIZE);\n    ps_dec->u4_pred_info_idx = 0;\n    ps_dec->u4_pred_info_pkd_idx = 0;\n    ps_dec->u4_dma_buf_idx = 0;\n    ps_dec->ps_mv = ps_dec->s_cur_pic.ps_mv;\n    ps_dec->ps_mv_bank_cur = ps_dec->s_cur_pic.ps_mv;\n    ps_dec->pu1_col_zero_flag = ps_dec->s_cur_pic.pu1_col_zero_flag;\n    ps_dec->ps_part = ps_dec->ps_parse_part_params;\n    ps_dec->i2_prev_slice_mbx = -1;\n    ps_dec->i2_prev_slice_mby = 0;\n    ps_dec->u2_mv_2mb[0] = 0;\n    ps_dec->u2_mv_2mb[1] = 0;\n    ps_dec->u1_last_pic_not_decoded = 0;\n\n    ps_dec->u2_cur_slice_num = 0;\n    ps_dec->u2_cur_slice_num_dec_thread = 0;\n    ps_dec->u2_cur_slice_num_bs = 0;\n    ps_dec->u4_intra_pred_line_ofst = 0;\n    ps_dec->pu1_cur_y_intra_pred_line = ps_dec->pu1_y_intra_pred_line;\n    ps_dec->pu1_cur_u_intra_pred_line = ps_dec->pu1_u_intra_pred_line;\n    ps_dec->pu1_cur_v_intra_pred_line = ps_dec->pu1_v_intra_pred_line;\n\n    ps_dec->pu1_cur_y_intra_pred_line_base = ps_dec->pu1_y_intra_pred_line;\n    ps_dec->pu1_cur_u_intra_pred_line_base = ps_dec->pu1_u_intra_pred_line;\n    ps_dec->pu1_cur_v_intra_pred_line_base = ps_dec->pu1_v_intra_pred_line;\n\n\n\n\n\n    ps_dec->pu1_prev_y_intra_pred_line = ps_dec->pu1_y_intra_pred_line\n + (ps_dec->u2_frm_wd_in_mbs * MB_SIZE);\n\n    ps_dec->pu1_prev_u_intra_pred_line = ps_dec->pu1_u_intra_pred_line\n + ps_dec->u2_frm_wd_in_mbs * BLK8x8SIZE * YUV420SP_FACTOR;\n    ps_dec->pu1_prev_v_intra_pred_line = ps_dec->pu1_v_intra_pred_line\n + ps_dec->u2_frm_wd_in_mbs * BLK8x8SIZE;\n\n    ps_dec->ps_deblk_mbn = ps_dec->ps_deblk_pic;\n /* Initialize The Function Pointer Depending Upon the Entropy and MbAff Flag */\n {\n if(ps_cur_slice->u1_mbaff_frame_flag)\n {\n            ps_dec->pf_compute_bs = ih264d_compute_bs_mbaff;\n            ps_dec->pf_mvpred = ih264d_mvpred_mbaff;\n }\n else\n {\n            ps_dec->pf_compute_bs = ih264d_compute_bs_non_mbaff;\n            ps_dec->u1_cur_mb_fld_dec_flag = ps_cur_slice->u1_field_pic_flag;\n }\n }\n /* Set up the Parameter for DMA transfer */\n {\n        UWORD8 u1_field_pic_flag = ps_dec->ps_cur_slice->u1_field_pic_flag;\n\n        UWORD8 u1_mbaff = ps_cur_slice->u1_mbaff_frame_flag;\n\n        UWORD8 uc_lastmbs = (((ps_dec->u2_pic_wd) >> 4)\n % (ps_dec->u1_recon_mb_grp >> u1_mbaff));\n        UWORD16 ui16_lastmbs_widthY =\n (uc_lastmbs ? (uc_lastmbs << 4) : ((ps_dec->u1_recon_mb_grp\n >> u1_mbaff) << 4));\n        UWORD16 ui16_lastmbs_widthUV =\n                        uc_lastmbs ? (uc_lastmbs << 3) : ((ps_dec->u1_recon_mb_grp\n >> u1_mbaff) << 3);\n\n        ps_dec->s_tran_addrecon.pu1_dest_y = ps_dec->s_cur_pic.pu1_buf1;\n        ps_dec->s_tran_addrecon.pu1_dest_u = ps_dec->s_cur_pic.pu1_buf2;\n        ps_dec->s_tran_addrecon.pu1_dest_v = ps_dec->s_cur_pic.pu1_buf3;\n\n        ps_dec->s_tran_addrecon.u2_frm_wd_y = ps_dec->u2_frm_wd_y\n << u1_field_pic_flag;\n        ps_dec->s_tran_addrecon.u2_frm_wd_uv = ps_dec->u2_frm_wd_uv\n << u1_field_pic_flag;\n\n if(u1_field_pic_flag)\n {\n            ui16_lastmbs_widthY += ps_dec->u2_frm_wd_y;\n            ui16_lastmbs_widthUV += ps_dec->u2_frm_wd_uv;\n }\n\n /* Normal Increment of Pointer */\n        ps_dec->s_tran_addrecon.u4_inc_y[0] = ((ps_dec->u1_recon_mb_grp << 4)\n >> u1_mbaff);\n        ps_dec->s_tran_addrecon.u4_inc_uv[0] = ((ps_dec->u1_recon_mb_grp << 4)\n >> u1_mbaff);\n\n /* End of Row Increment */\n        ps_dec->s_tran_addrecon.u4_inc_y[1] = (ui16_lastmbs_widthY\n + (PAD_LEN_Y_H << 1)\n + ps_dec->s_tran_addrecon.u2_frm_wd_y\n * ((15 << u1_mbaff) + u1_mbaff));\n        ps_dec->s_tran_addrecon.u4_inc_uv[1] = (ui16_lastmbs_widthUV\n + (PAD_LEN_UV_H << 2)\n + ps_dec->s_tran_addrecon.u2_frm_wd_uv\n * ((15 << u1_mbaff) + u1_mbaff));\n\n /* Assign picture numbers to each frame/field  */\n /* only once per picture.                      */\n        ih264d_assign_pic_num(ps_dec);\n        ps_dec->s_tran_addrecon.u2_mv_top_left_inc = (ps_dec->u1_recon_mb_grp\n << 2) - 1 - (u1_mbaff << 2);\n        ps_dec->s_tran_addrecon.u2_mv_left_inc = ((ps_dec->u1_recon_mb_grp\n >> u1_mbaff) - 1) << (4 + u1_mbaff);\n }\n /**********************************************************************/\n /* High profile related initialization at pictrue level               */\n /**********************************************************************/\n if(ps_seq->u1_profile_idc == HIGH_PROFILE_IDC)\n {\n if((ps_seq->i4_seq_scaling_matrix_present_flag)\n || (ps_pps->i4_pic_scaling_matrix_present_flag))\n {\n            ih264d_form_scaling_matrix_picture(ps_seq, ps_pps, ps_dec);\n            ps_dec->s_high_profile.u1_scaling_present = 1;\n }\n else\n {\n            ih264d_form_default_scaling_matrix(ps_dec);\n }\n\n if(ps_pps->i4_transform_8x8_mode_flag)\n {\n            ps_dec->s_high_profile.u1_transform8x8_present = 1;\n }\n }\n else\n {\n        ih264d_form_default_scaling_matrix(ps_dec);\n }\n\n /* required while reading the transform_size_8x8 u4_flag */\n    ps_dec->s_high_profile.u1_direct_8x8_inference_flag =\n                    ps_seq->u1_direct_8x8_inference_flag;\n    ps_dec->s_high_profile.s_cavlc_ctxt = ps_dec->s_cavlc_ctxt;\n\n    ps_dec->i1_recon_in_thread3_flag = 1;\n    ps_dec->ps_frame_buf_ip_recon = &ps_dec->s_tran_addrecon;\n if(ps_dec->u1_separate_parse)\n {\n        memcpy(&ps_dec->s_tran_addrecon_parse, &ps_dec->s_tran_addrecon,\n sizeof(tfr_ctxt_t));\n if(ps_dec->u4_num_cores >= 3 && ps_dec->i1_recon_in_thread3_flag)\n {\n            memcpy(&ps_dec->s_tran_iprecon, &ps_dec->s_tran_addrecon,\n sizeof(tfr_ctxt_t));\n            ps_dec->ps_frame_buf_ip_recon = &ps_dec->s_tran_iprecon;\n }\n }\n\n\n    ih264d_init_deblk_tfr_ctxt(ps_dec,&(ps_dec->s_pad_mgr), &(ps_dec->s_tran_addrecon),\n                               ps_dec->u2_frm_wd_in_mbs, 0);\n\n    ps_dec->ps_cur_deblk_mb = ps_dec->ps_deblk_pic;\n    ps_dec->u4_cur_deblk_mb_num = 0;\n\n \n     ps_dec->u4_deblk_mb_x = 0;\n     ps_dec->u4_deblk_mb_y = 0;\n    ps_dec->pu4_wt_ofsts = ps_dec->pu4_wts_ofsts_mat;\n \n     H264_MUTEX_UNLOCK(&ps_dec->process_disp_mutex);\n     return OK;\n}\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 713,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2018-6114",
    "code_before_change": "void ImageLoader::DoUpdateFromElement(BypassMainWorldBehavior bypass_behavior,\n                                      UpdateFromElementBehavior update_behavior,\n                                      const KURL& url,\n                                      ReferrerPolicy referrer_policy,\n                                      UpdateType update_type) {\n  pending_task_.reset();\n  std::unique_ptr<IncrementLoadEventDelayCount> load_delay_counter;\n  load_delay_counter.swap(delay_until_do_update_from_element_);\n\n  Document& document = element_->GetDocument();\n  if (!document.IsActive())\n    return;\n\n  AtomicString image_source_url = element_->ImageSourceURL();\n  ImageResourceContent* new_image_content = nullptr;\n  if (!url.IsNull() && !url.IsEmpty()) {\n    ResourceLoaderOptions resource_loader_options;\n    resource_loader_options.initiator_info.name = GetElement()->localName();\n    ResourceRequest resource_request(url);\n    if (update_behavior == kUpdateForcedReload) {\n      resource_request.SetCacheMode(mojom::FetchCacheMode::kBypassCache);\n      resource_request.SetPreviewsState(WebURLRequest::kPreviewsNoTransform);\n    }\n\n    if (referrer_policy != kReferrerPolicyDefault) {\n      resource_request.SetHTTPReferrer(SecurityPolicy::GenerateReferrer(\n           referrer_policy, url, document.OutgoingReferrer()));\n     }\n \n     if (IsHTMLPictureElement(GetElement()->parentNode()) ||\n        !GetElement()->FastGetAttribute(HTMLNames::srcsetAttr).IsNull())\n       resource_request.SetRequestContext(\n           WebURLRequest::kRequestContextImageSet);\n \n     bool page_is_being_dismissed =\n         document.PageDismissalEventBeingDispatched() != Document::kNoDismissal;\n    if (page_is_being_dismissed) {\n      resource_request.SetHTTPHeaderField(HTTPNames::Cache_Control,\n                                          \"max-age=0\");\n      resource_request.SetKeepalive(true);\n      resource_request.SetRequestContext(WebURLRequest::kRequestContextPing);\n    }\n\n    FetchParameters params(resource_request, resource_loader_options);\n    ConfigureRequest(params, bypass_behavior, *element_,\n                     document.GetClientHintsPreferences());\n\n    if (update_behavior != kUpdateForcedReload && document.GetFrame())\n      document.GetFrame()->MaybeAllowImagePlaceholder(params);\n\n    new_image_content = ImageResourceContent::Fetch(params, document.Fetcher());\n\n    if (page_is_being_dismissed)\n      new_image_content = nullptr;\n\n    ClearFailedLoadURL();\n  } else {\n    if (!image_source_url.IsNull()) {\n      DispatchErrorEvent();\n    }\n    NoImageResourceToLoad();\n  }\n\n  ImageResourceContent* old_image_content = image_content_.Get();\n  if (old_image_content != new_image_content)\n    RejectPendingDecodes(update_type);\n\n  if (update_behavior == kUpdateSizeChanged && element_->GetLayoutObject() &&\n      element_->GetLayoutObject()->IsImage() &&\n      new_image_content == old_image_content) {\n    ToLayoutImage(element_->GetLayoutObject())->IntrinsicSizeChanged();\n  } else {\n    if (pending_load_event_.IsActive())\n      pending_load_event_.Cancel();\n\n    if (pending_error_event_.IsActive() && new_image_content)\n      pending_error_event_.Cancel();\n\n    UpdateImageState(new_image_content);\n\n    UpdateLayoutObject();\n    if (new_image_content) {\n      new_image_content->AddObserver(this);\n    }\n    if (old_image_content) {\n      old_image_content->RemoveObserver(this);\n    }\n  }\n\n  if (LayoutImageResource* image_resource = GetLayoutImageResource())\n    image_resource->ResetAnimation();\n}\n",
    "code_after_change": "void ImageLoader::DoUpdateFromElement(BypassMainWorldBehavior bypass_behavior,\n                                      UpdateFromElementBehavior update_behavior,\n                                      const KURL& url,\n                                      ReferrerPolicy referrer_policy,\n                                      UpdateType update_type) {\n  pending_task_.reset();\n  std::unique_ptr<IncrementLoadEventDelayCount> load_delay_counter;\n  load_delay_counter.swap(delay_until_do_update_from_element_);\n\n  Document& document = element_->GetDocument();\n  if (!document.IsActive())\n    return;\n\n  AtomicString image_source_url = element_->ImageSourceURL();\n  ImageResourceContent* new_image_content = nullptr;\n  if (!url.IsNull() && !url.IsEmpty()) {\n    ResourceLoaderOptions resource_loader_options;\n    resource_loader_options.initiator_info.name = GetElement()->localName();\n    ResourceRequest resource_request(url);\n    if (update_behavior == kUpdateForcedReload) {\n      resource_request.SetCacheMode(mojom::FetchCacheMode::kBypassCache);\n      resource_request.SetPreviewsState(WebURLRequest::kPreviewsNoTransform);\n    }\n\n    if (referrer_policy != kReferrerPolicyDefault) {\n      resource_request.SetHTTPReferrer(SecurityPolicy::GenerateReferrer(\n           referrer_policy, url, document.OutgoingReferrer()));\n     }\n \n    // Correct the RequestContext if necessary.\n     if (IsHTMLPictureElement(GetElement()->parentNode()) ||\n        !GetElement()->FastGetAttribute(HTMLNames::srcsetAttr).IsNull()) {\n       resource_request.SetRequestContext(\n           WebURLRequest::kRequestContextImageSet);\n    } else if (IsHTMLObjectElement(GetElement())) {\n      resource_request.SetRequestContext(WebURLRequest::kRequestContextObject);\n    } else if (IsHTMLEmbedElement(GetElement())) {\n      resource_request.SetRequestContext(WebURLRequest::kRequestContextEmbed);\n    }\n \n     bool page_is_being_dismissed =\n         document.PageDismissalEventBeingDispatched() != Document::kNoDismissal;\n    if (page_is_being_dismissed) {\n      resource_request.SetHTTPHeaderField(HTTPNames::Cache_Control,\n                                          \"max-age=0\");\n      resource_request.SetKeepalive(true);\n      resource_request.SetRequestContext(WebURLRequest::kRequestContextPing);\n    }\n\n    FetchParameters params(resource_request, resource_loader_options);\n    ConfigureRequest(params, bypass_behavior, *element_,\n                     document.GetClientHintsPreferences());\n\n    if (update_behavior != kUpdateForcedReload && document.GetFrame())\n      document.GetFrame()->MaybeAllowImagePlaceholder(params);\n\n    new_image_content = ImageResourceContent::Fetch(params, document.Fetcher());\n\n    if (page_is_being_dismissed)\n      new_image_content = nullptr;\n\n    ClearFailedLoadURL();\n  } else {\n    if (!image_source_url.IsNull()) {\n      DispatchErrorEvent();\n    }\n    NoImageResourceToLoad();\n  }\n\n  ImageResourceContent* old_image_content = image_content_.Get();\n  if (old_image_content != new_image_content)\n    RejectPendingDecodes(update_type);\n\n  if (update_behavior == kUpdateSizeChanged && element_->GetLayoutObject() &&\n      element_->GetLayoutObject()->IsImage() &&\n      new_image_content == old_image_content) {\n    ToLayoutImage(element_->GetLayoutObject())->IntrinsicSizeChanged();\n  } else {\n    if (pending_load_event_.IsActive())\n      pending_load_event_.Cancel();\n\n    if (pending_error_event_.IsActive() && new_image_content)\n      pending_error_event_.Cancel();\n\n    UpdateImageState(new_image_content);\n\n    UpdateLayoutObject();\n    if (new_image_content) {\n      new_image_content->AddObserver(this);\n    }\n    if (old_image_content) {\n      old_image_content->RemoveObserver(this);\n    }\n  }\n\n  if (LayoutImageResource* image_resource = GetLayoutImageResource())\n    image_resource->ResetAnimation();\n}\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 721,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2018-17456",
    "code_before_change": "static int fsck_gitmodules_fn(const char *var, const char *value, void *vdata)\n{\n\tstruct fsck_gitmodules_data *data = vdata;\n\tconst char *subsection, *key;\n\tint subsection_len;\n\tchar *name;\n\n\tif (parse_config_key(var, \"submodule\", &subsection, &subsection_len, &key) < 0 ||\n\t    !subsection)\n\t\treturn 0;\n\n\tname = xmemdupz(subsection, subsection_len);\n\tif (check_submodule_name(name) < 0)\n\t\tdata->ret |= report(data->options, data->obj,\n\t\t\t\t    FSCK_MSG_GITMODULES_NAME,\n\t\t\t\t    \"disallowed submodule name: %s\",\n\t\t\t\t    name);\n\tif (!strcmp(key, \"url\") && value &&\n\t    looks_like_command_line_option(value))\n\t\tdata->ret |= report(data->options, data->obj,\n \t\t\t\t    FSCK_MSG_GITMODULES_URL,\n \t\t\t\t    \"disallowed submodule url: %s\",\n \t\t\t\t    value);\n \tfree(name);\n \n \treturn 0;\n}\n",
    "code_after_change": "static int fsck_gitmodules_fn(const char *var, const char *value, void *vdata)\n{\n\tstruct fsck_gitmodules_data *data = vdata;\n\tconst char *subsection, *key;\n\tint subsection_len;\n\tchar *name;\n\n\tif (parse_config_key(var, \"submodule\", &subsection, &subsection_len, &key) < 0 ||\n\t    !subsection)\n\t\treturn 0;\n\n\tname = xmemdupz(subsection, subsection_len);\n\tif (check_submodule_name(name) < 0)\n\t\tdata->ret |= report(data->options, data->obj,\n\t\t\t\t    FSCK_MSG_GITMODULES_NAME,\n\t\t\t\t    \"disallowed submodule name: %s\",\n\t\t\t\t    name);\n\tif (!strcmp(key, \"url\") && value &&\n\t    looks_like_command_line_option(value))\n\t\tdata->ret |= report(data->options, data->obj,\n \t\t\t\t    FSCK_MSG_GITMODULES_URL,\n \t\t\t\t    \"disallowed submodule url: %s\",\n \t\t\t\t    value);\n\tif (!strcmp(key, \"path\") && value &&\n\t    looks_like_command_line_option(value))\n\t\tdata->ret |= report(data->options, data->obj,\n\t\t\t\t    FSCK_MSG_GITMODULES_PATH,\n\t\t\t\t    \"disallowed submodule path: %s\",\n\t\t\t\t    value);\n \tfree(name);\n \n \treturn 0;\n}\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 724,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2016-3764",
    "code_before_change": "sp<IMemory> MetadataRetrieverClient::getFrameAtTime(int64_t timeUs, int option)\n{\n    ALOGV(\"getFrameAtTime: time(%lld us) option(%d)\", timeUs, option);\n Mutex::Autolock lock(mLock);\n Mutex::Autolock glock(sLock);\n    mThumbnail.clear();\n if (mRetriever == NULL) {\n        ALOGE(\"retriever is not initialized\");\n return NULL;\n }\n VideoFrame *frame = mRetriever->getFrameAtTime(timeUs, option);\n if (frame == NULL) {\n        ALOGE(\"failed to capture a video frame\");\n return NULL;\n }\n size_t size = sizeof(VideoFrame) + frame->mSize;\n    sp<MemoryHeapBase> heap = new MemoryHeapBase(size, 0, \"MetadataRetrieverClient\");\n if (heap == NULL) {\n        ALOGE(\"failed to create MemoryDealer\");\n delete frame;\n return NULL;\n }\n    mThumbnail = new MemoryBase(heap, 0, size);\n if (mThumbnail == NULL) {\n        ALOGE(\"not enough memory for VideoFrame size=%u\", size);\n delete frame;\n return NULL;\n }\n VideoFrame *frameCopy = static_cast<VideoFrame *>(mThumbnail->pointer());\n    frameCopy->mWidth = frame->mWidth;\n    frameCopy->mHeight = frame->mHeight;\n    frameCopy->mDisplayWidth = frame->mDisplayWidth;\n    frameCopy->mDisplayHeight = frame->mDisplayHeight;\n    frameCopy->mSize = frame->mSize;\n    frameCopy->mRotationAngle = frame->mRotationAngle;\n\n     ALOGV(\"rotation: %d\", frameCopy->mRotationAngle);\n     frameCopy->mData = (uint8_t *)frameCopy + sizeof(VideoFrame);\n     memcpy(frameCopy->mData, frame->mData, frame->mSize);\n     delete frame;  // Fix memory leakage\n     return mThumbnail;\n }\n",
    "code_after_change": "sp<IMemory> MetadataRetrieverClient::getFrameAtTime(int64_t timeUs, int option)\n{\n    ALOGV(\"getFrameAtTime: time(%lld us) option(%d)\", timeUs, option);\n Mutex::Autolock lock(mLock);\n Mutex::Autolock glock(sLock);\n    mThumbnail.clear();\n if (mRetriever == NULL) {\n        ALOGE(\"retriever is not initialized\");\n return NULL;\n }\n VideoFrame *frame = mRetriever->getFrameAtTime(timeUs, option);\n if (frame == NULL) {\n        ALOGE(\"failed to capture a video frame\");\n return NULL;\n }\n size_t size = sizeof(VideoFrame) + frame->mSize;\n    sp<MemoryHeapBase> heap = new MemoryHeapBase(size, 0, \"MetadataRetrieverClient\");\n if (heap == NULL) {\n        ALOGE(\"failed to create MemoryDealer\");\n delete frame;\n return NULL;\n }\n    mThumbnail = new MemoryBase(heap, 0, size);\n if (mThumbnail == NULL) {\n        ALOGE(\"not enough memory for VideoFrame size=%u\", size);\n delete frame;\n return NULL;\n }\n VideoFrame *frameCopy = static_cast<VideoFrame *>(mThumbnail->pointer());\n    frameCopy->mWidth = frame->mWidth;\n    frameCopy->mHeight = frame->mHeight;\n    frameCopy->mDisplayWidth = frame->mDisplayWidth;\n    frameCopy->mDisplayHeight = frame->mDisplayHeight;\n    frameCopy->mSize = frame->mSize;\n    frameCopy->mRotationAngle = frame->mRotationAngle;\n\n     ALOGV(\"rotation: %d\", frameCopy->mRotationAngle);\n     frameCopy->mData = (uint8_t *)frameCopy + sizeof(VideoFrame);\n     memcpy(frameCopy->mData, frame->mData, frame->mSize);\n    frameCopy->mData = 0;\n     delete frame;  // Fix memory leakage\n     return mThumbnail;\n }\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 731,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2013-7271",
    "code_before_change": "static int irda_recvmsg_dgram(struct kiocb *iocb, struct socket *sock,\n\t\t\t      struct msghdr *msg, size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct irda_sock *self = irda_sk(sk);\n\tstruct sk_buff *skb;\n\tsize_t copied;\n\tint err;\n \n \tIRDA_DEBUG(4, \"%s()\\n\", __func__);\n \n\tmsg->msg_namelen = 0;\n \tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n \t\t\t\tflags & MSG_DONTWAIT, &err);\n \tif (!skb)\n\t\treturn err;\n\n\tskb_reset_transport_header(skb);\n\tcopied = skb->len;\n\n\tif (copied > size) {\n\t\tIRDA_DEBUG(2, \"%s(), Received truncated frame (%zd < %zd)!\\n\",\n\t\t\t   __func__, copied, size);\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\tskb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\n\tskb_free_datagram(sk, skb);\n\n\t/*\n\t *  Check if we have previously stopped IrTTP and we know\n\t *  have more free space in our rx_queue. If so tell IrTTP\n\t *  to start delivering frames again before our rx_queue gets\n\t *  empty\n\t */\n\tif (self->rx_flow == FLOW_STOP) {\n\t\tif ((atomic_read(&sk->sk_rmem_alloc) << 2) <= sk->sk_rcvbuf) {\n\t\t\tIRDA_DEBUG(2, \"%s(), Starting IrTTP\\n\", __func__);\n\t\t\tself->rx_flow = FLOW_START;\n\t\t\tirttp_flow_request(self->tsap, FLOW_START);\n\t\t}\n\t}\n\n\treturn copied;\n}\n",
    "code_after_change": "static int irda_recvmsg_dgram(struct kiocb *iocb, struct socket *sock,\n\t\t\t      struct msghdr *msg, size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct irda_sock *self = irda_sk(sk);\n\tstruct sk_buff *skb;\n\tsize_t copied;\n\tint err;\n \n \tIRDA_DEBUG(4, \"%s()\\n\", __func__);\n \n \tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n \t\t\t\tflags & MSG_DONTWAIT, &err);\n \tif (!skb)\n\t\treturn err;\n\n\tskb_reset_transport_header(skb);\n\tcopied = skb->len;\n\n\tif (copied > size) {\n\t\tIRDA_DEBUG(2, \"%s(), Received truncated frame (%zd < %zd)!\\n\",\n\t\t\t   __func__, copied, size);\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\tskb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\n\tskb_free_datagram(sk, skb);\n\n\t/*\n\t *  Check if we have previously stopped IrTTP and we know\n\t *  have more free space in our rx_queue. If so tell IrTTP\n\t *  to start delivering frames again before our rx_queue gets\n\t *  empty\n\t */\n\tif (self->rx_flow == FLOW_STOP) {\n\t\tif ((atomic_read(&sk->sk_rmem_alloc) << 2) <= sk->sk_rcvbuf) {\n\t\t\tIRDA_DEBUG(2, \"%s(), Starting IrTTP\\n\", __func__);\n\t\t\tself->rx_flow = FLOW_START;\n\t\t\tirttp_flow_request(self->tsap, FLOW_START);\n\t\t}\n\t}\n\n\treturn copied;\n}\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 740,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2016-4353",
    "code_before_change": " push_decoder_state (DECODER_STATE ds)\n {\n   if (ds->idx >= ds->stacksize)\n     {\n      fprintf (stderr, \"ERROR: decoder stack overflow!\\n\");\n      abort ();\n     }\n   ds->stack[ds->idx++] = ds->cur;\n }\n",
    "code_after_change": " push_decoder_state (DECODER_STATE ds)\n {\n   if (ds->idx >= ds->stacksize)\n     {\n      fprintf (stderr, \"ksba: ber-decoder: stack overflow!\\n\");\n      return gpg_error (GPG_ERR_LIMIT_REACHED);\n     }\n   ds->stack[ds->idx++] = ds->cur;\n  return 0;\n }\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 745,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2013-7271",
    "code_before_change": "static int pppoe_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t  struct msghdr *m, size_t total_len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tint error = 0;\n\n\tif (sk->sk_state & PPPOX_BOUND) {\n\t\terror = -EIO;\n\t\tgoto end;\n\t}\n\n\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\tflags & MSG_DONTWAIT, &error);\n \tif (error < 0)\n \t\tgoto end;\n \n\tm->msg_namelen = 0;\n \tif (skb) {\n \t\ttotal_len = min_t(size_t, total_len, skb->len);\n \t\terror = skb_copy_datagram_iovec(skb, 0, m->msg_iov, total_len);\n\t\tif (error == 0) {\n\t\t\tconsume_skb(skb);\n\t\t\treturn total_len;\n\t\t}\n\t}\n\n\tkfree_skb(skb);\nend:\n\treturn error;\n}\n",
    "code_after_change": "static int pppoe_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t  struct msghdr *m, size_t total_len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tint error = 0;\n\n\tif (sk->sk_state & PPPOX_BOUND) {\n\t\terror = -EIO;\n\t\tgoto end;\n\t}\n\n\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\tflags & MSG_DONTWAIT, &error);\n \tif (error < 0)\n \t\tgoto end;\n \n \tif (skb) {\n \t\ttotal_len = min_t(size_t, total_len, skb->len);\n \t\terror = skb_copy_datagram_iovec(skb, 0, m->msg_iov, total_len);\n\t\tif (error == 0) {\n\t\t\tconsume_skb(skb);\n\t\t\treturn total_len;\n\t\t}\n\t}\n\n\tkfree_skb(skb);\nend:\n\treturn error;\n}\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 746,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2012-2877",
    "code_before_change": " AppModalDialog::~AppModalDialog() {\n }\n",
    "code_after_change": " AppModalDialog::~AppModalDialog() {\n  CompleteDialog();\n }\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 747,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2017-18235",
    "code_before_change": " void VP8XChunk::width(XMP_Uns32 val)\n {\n    PutLE24(&this->data[4], val - 1);\n }\n",
    "code_after_change": " void VP8XChunk::width(XMP_Uns32 val)\n {\n    PutLE24(&this->data[4], val > 0 ? val - 1 : 0);\n }\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 750,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2013-4544",
    "code_before_change": "static int vmxnet3_post_load(void *opaque, int version_id)\n{\n    VMXNET3State *s = opaque;\n    PCIDevice *d = PCI_DEVICE(s);\n\n    vmxnet_tx_pkt_init(&s->tx_pkt, s->max_tx_frags, s->peer_has_vhdr);\n    vmxnet_rx_pkt_init(&s->rx_pkt, s->peer_has_vhdr);\n\n    if (s->msix_used) {\n        if  (!vmxnet3_use_msix_vectors(s, VMXNET3_MAX_INTRS)) {\n            VMW_WRPRN(\"Failed to re-use MSI-X vectors\");\n            msix_uninit(d, &s->msix_bar, &s->msix_bar);\n            s->msix_used = false;\n            return -1;\n         }\n     }\n \n     return 0;\n }\n",
    "code_after_change": "static int vmxnet3_post_load(void *opaque, int version_id)\n{\n    VMXNET3State *s = opaque;\n    PCIDevice *d = PCI_DEVICE(s);\n\n    vmxnet_tx_pkt_init(&s->tx_pkt, s->max_tx_frags, s->peer_has_vhdr);\n    vmxnet_rx_pkt_init(&s->rx_pkt, s->peer_has_vhdr);\n\n    if (s->msix_used) {\n        if  (!vmxnet3_use_msix_vectors(s, VMXNET3_MAX_INTRS)) {\n            VMW_WRPRN(\"Failed to re-use MSI-X vectors\");\n            msix_uninit(d, &s->msix_bar, &s->msix_bar);\n            s->msix_used = false;\n            return -1;\n         }\n     }\n \n    vmxnet3_validate_interrupts(s);\n\n     return 0;\n }\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 754,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2019-5838",
    "code_before_change": "bool PageCaptureSaveAsMHTMLFunction::RunAsync() {\n  params_ = SaveAsMHTML::Params::Create(*args_);\n  EXTENSION_FUNCTION_VALIDATE(params_.get());\n\n  AddRef();  // Balanced in ReturnFailure/ReturnSuccess()\n\n#if defined(OS_CHROMEOS)\n  if (profiles::ArePublicSessionRestrictionsEnabled()) {\n    WebContents* web_contents = GetWebContents();\n    if (!web_contents) {\n      ReturnFailure(kTabClosedError);\n      return true;\n    }\n    auto callback =\n        base::Bind(&PageCaptureSaveAsMHTMLFunction::ResolvePermissionRequest,\n                   base::Unretained(this));\n    permission_helper::HandlePermissionRequest(\n        *extension(), {APIPermission::kPageCapture}, web_contents, callback,\n        permission_helper::PromptFactory());\n    return true;\n   }\n #endif\n \n   base::PostTaskWithTraits(\n       FROM_HERE, kCreateTemporaryFileTaskTraits,\n       base::BindOnce(&PageCaptureSaveAsMHTMLFunction::CreateTemporaryFile,\n                      this));\n   return true;\n }\n",
    "code_after_change": "bool PageCaptureSaveAsMHTMLFunction::RunAsync() {\n  params_ = SaveAsMHTML::Params::Create(*args_);\n  EXTENSION_FUNCTION_VALIDATE(params_.get());\n\n  AddRef();  // Balanced in ReturnFailure/ReturnSuccess()\n\n#if defined(OS_CHROMEOS)\n  if (profiles::ArePublicSessionRestrictionsEnabled()) {\n    WebContents* web_contents = GetWebContents();\n    if (!web_contents) {\n      ReturnFailure(kTabClosedError);\n      return true;\n    }\n    auto callback =\n        base::Bind(&PageCaptureSaveAsMHTMLFunction::ResolvePermissionRequest,\n                   base::Unretained(this));\n    permission_helper::HandlePermissionRequest(\n        *extension(), {APIPermission::kPageCapture}, web_contents, callback,\n        permission_helper::PromptFactory());\n    return true;\n   }\n #endif\n \n  if (!CanCaptureCurrentPage()) {\n    return false;\n  }\n   base::PostTaskWithTraits(\n       FROM_HERE, kCreateTemporaryFileTaskTraits,\n       base::BindOnce(&PageCaptureSaveAsMHTMLFunction::CreateTemporaryFile,\n                      this));\n   return true;\n }\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 766,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2011-2861",
    "code_before_change": "RenderView::RenderView(RenderThreadBase* render_thread,\n                       gfx::NativeViewId parent_hwnd,\n                       int32 opener_id,\n                       const RendererPreferences& renderer_prefs,\n                       const WebPreferences& webkit_prefs,\n                       SharedRenderViewCounter* counter,\n                       int32 routing_id,\n                       int64 session_storage_namespace_id,\n                       const string16& frame_name)\n    : RenderWidget(render_thread, WebKit::WebPopupTypeNone),\n      webkit_preferences_(webkit_prefs),\n      send_content_state_immediately_(false),\n      enabled_bindings_(0),\n      send_preferred_size_changes_(false),\n      is_loading_(false),\n      navigation_gesture_(NavigationGestureUnknown),\n      opened_by_user_gesture_(true),\n      opener_suppressed_(false),\n      page_id_(-1),\n      last_page_id_sent_to_browser_(-1),\n      history_list_offset_(-1),\n      history_list_length_(0),\n      target_url_status_(TARGET_NONE),\n      ALLOW_THIS_IN_INITIALIZER_LIST(pepper_delegate_(this)),\n      ALLOW_THIS_IN_INITIALIZER_LIST(accessibility_method_factory_(this)),\n      ALLOW_THIS_IN_INITIALIZER_LIST(cookie_jar_(this)),\n      geolocation_dispatcher_(NULL),\n      speech_input_dispatcher_(NULL),\n      device_orientation_dispatcher_(NULL),\n      accessibility_ack_pending_(false),\n      p2p_socket_dispatcher_(NULL),\n      session_storage_namespace_id_(session_storage_namespace_id) {\n  routing_id_ = routing_id;\n  if (opener_id != MSG_ROUTING_NONE)\n    opener_id_ = opener_id;\n\n  webwidget_ = WebView::create(this);\n\n  if (counter) {\n    shared_popup_counter_ = counter;\n    shared_popup_counter_->data++;\n    decrement_shared_popup_at_destruction_ = true;\n  } else {\n    shared_popup_counter_ = new SharedRenderViewCounter(0);\n    decrement_shared_popup_at_destruction_ = false;\n  }\n\n  notification_provider_ = new NotificationProvider(this);\n\n  render_thread_->AddRoute(routing_id_, this);\n  AddRef();\n\n  if (opener_id == MSG_ROUTING_NONE) {\n    did_show_ = true;\n    CompleteInit(parent_hwnd);\n  }\n\n  g_view_map.Get().insert(std::make_pair(webview(), this));\n  webkit_preferences_.Apply(webview());\n  webview()->initializeMainFrame(this);\n  if (!frame_name.empty())\n    webview()->mainFrame()->setName(frame_name);\n  webview()->settings()->setMinimumTimerInterval(\n      is_hidden() ? webkit_glue::kBackgroundTabTimerInterval :\n          webkit_glue::kForegroundTabTimerInterval);\n\n  OnSetRendererPrefs(renderer_prefs);\n\n  host_window_ = parent_hwnd;\n\n  const CommandLine& command_line = *CommandLine::ForCurrentProcess();\n  if (command_line.HasSwitch(switches::kEnableAccessibility))\n    WebAccessibilityCache::enableAccessibility();\n\n#if defined(ENABLE_P2P_APIS)\n  p2p_socket_dispatcher_ = new P2PSocketDispatcher(this);\n#endif\n \n   new MHTMLGenerator(this);\n \n   if (command_line.HasSwitch(switches::kEnableMediaStream)) {\n     media_stream_impl_ = new MediaStreamImpl(\n         RenderThread::current()->video_capture_impl_manager());\n  }\n\n  content::GetContentClient()->renderer()->RenderViewCreated(this);\n}\n",
    "code_after_change": "RenderView::RenderView(RenderThreadBase* render_thread,\n                       gfx::NativeViewId parent_hwnd,\n                       int32 opener_id,\n                       const RendererPreferences& renderer_prefs,\n                       const WebPreferences& webkit_prefs,\n                       SharedRenderViewCounter* counter,\n                       int32 routing_id,\n                       int64 session_storage_namespace_id,\n                       const string16& frame_name)\n    : RenderWidget(render_thread, WebKit::WebPopupTypeNone),\n      webkit_preferences_(webkit_prefs),\n      send_content_state_immediately_(false),\n      enabled_bindings_(0),\n      send_preferred_size_changes_(false),\n      is_loading_(false),\n      navigation_gesture_(NavigationGestureUnknown),\n      opened_by_user_gesture_(true),\n      opener_suppressed_(false),\n      page_id_(-1),\n      last_page_id_sent_to_browser_(-1),\n      history_list_offset_(-1),\n      history_list_length_(0),\n      target_url_status_(TARGET_NONE),\n      ALLOW_THIS_IN_INITIALIZER_LIST(pepper_delegate_(this)),\n      ALLOW_THIS_IN_INITIALIZER_LIST(accessibility_method_factory_(this)),\n      ALLOW_THIS_IN_INITIALIZER_LIST(cookie_jar_(this)),\n      geolocation_dispatcher_(NULL),\n      speech_input_dispatcher_(NULL),\n      device_orientation_dispatcher_(NULL),\n      accessibility_ack_pending_(false),\n      p2p_socket_dispatcher_(NULL),\n      session_storage_namespace_id_(session_storage_namespace_id) {\n  routing_id_ = routing_id;\n  if (opener_id != MSG_ROUTING_NONE)\n    opener_id_ = opener_id;\n\n  webwidget_ = WebView::create(this);\n\n  if (counter) {\n    shared_popup_counter_ = counter;\n    shared_popup_counter_->data++;\n    decrement_shared_popup_at_destruction_ = true;\n  } else {\n    shared_popup_counter_ = new SharedRenderViewCounter(0);\n    decrement_shared_popup_at_destruction_ = false;\n  }\n\n  notification_provider_ = new NotificationProvider(this);\n\n  render_thread_->AddRoute(routing_id_, this);\n  AddRef();\n\n  if (opener_id == MSG_ROUTING_NONE) {\n    did_show_ = true;\n    CompleteInit(parent_hwnd);\n  }\n\n  g_view_map.Get().insert(std::make_pair(webview(), this));\n  webkit_preferences_.Apply(webview());\n  webview()->initializeMainFrame(this);\n  if (!frame_name.empty())\n    webview()->mainFrame()->setName(frame_name);\n  webview()->settings()->setMinimumTimerInterval(\n      is_hidden() ? webkit_glue::kBackgroundTabTimerInterval :\n          webkit_glue::kForegroundTabTimerInterval);\n\n  OnSetRendererPrefs(renderer_prefs);\n\n  host_window_ = parent_hwnd;\n\n  const CommandLine& command_line = *CommandLine::ForCurrentProcess();\n  if (command_line.HasSwitch(switches::kEnableAccessibility))\n    WebAccessibilityCache::enableAccessibility();\n\n#if defined(ENABLE_P2P_APIS)\n  p2p_socket_dispatcher_ = new P2PSocketDispatcher(this);\n#endif\n \n   new MHTMLGenerator(this);\n \n  new DevToolsAgent(this);\n\n   if (command_line.HasSwitch(switches::kEnableMediaStream)) {\n     media_stream_impl_ = new MediaStreamImpl(\n         RenderThread::current()->video_capture_impl_manager());\n  }\n\n  content::GetContentClient()->renderer()->RenderViewCreated(this);\n}\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 777,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2011-2350",
    "code_before_change": "EncodedJSValue JSC_HOST_CALL jsTestInterfacePrototypeFunctionSupplementalMethod2(ExecState* exec)\n{\n    JSValue thisValue = exec->hostThisValue();\n    if (!thisValue.inherits(&JSTestInterface::s_info))\n        return throwVMTypeError(exec);\n    JSTestInterface* castedThis = jsCast<JSTestInterface*>(asObject(thisValue));\n     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestInterface::s_info);\n     TestInterface* impl = static_cast<TestInterface*>(castedThis->impl());\n     if (exec->argumentCount() < 2)\n        return throwVMError(exec, createTypeError(exec, \"Not enough arguments\"));\n     ExceptionCode ec = 0;\n     ScriptExecutionContext* scriptContext = jsCast<JSDOMGlobalObject*>(exec->lexicalGlobalObject())->scriptExecutionContext();\n     if (!scriptContext)\n        return JSValue::encode(jsUndefined());\n    const String& strArg(ustringToString(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).isEmpty() ? UString() : MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).toString(exec)->value(exec)));\n    if (exec->hadException())\n        return JSValue::encode(jsUndefined());\n    TestObj* objArg(toTestObj(MAYBE_MISSING_PARAMETER(exec, 1, DefaultIsUndefined)));\n    if (exec->hadException())\n        return JSValue::encode(jsUndefined());\n\n    JSC::JSValue result = toJS(exec, castedThis->globalObject(), WTF::getPtr(TestSupplemental::supplementalMethod2(impl, scriptContext, strArg, objArg, ec)));\n    setDOMException(exec, ec);\n    return JSValue::encode(result);\n}\n",
    "code_after_change": "EncodedJSValue JSC_HOST_CALL jsTestInterfacePrototypeFunctionSupplementalMethod2(ExecState* exec)\n{\n    JSValue thisValue = exec->hostThisValue();\n    if (!thisValue.inherits(&JSTestInterface::s_info))\n        return throwVMTypeError(exec);\n    JSTestInterface* castedThis = jsCast<JSTestInterface*>(asObject(thisValue));\n     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestInterface::s_info);\n     TestInterface* impl = static_cast<TestInterface*>(castedThis->impl());\n     if (exec->argumentCount() < 2)\n        return throwVMError(exec, createNotEnoughArgumentsError(exec));\n     ExceptionCode ec = 0;\n     ScriptExecutionContext* scriptContext = jsCast<JSDOMGlobalObject*>(exec->lexicalGlobalObject())->scriptExecutionContext();\n     if (!scriptContext)\n        return JSValue::encode(jsUndefined());\n    const String& strArg(ustringToString(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).isEmpty() ? UString() : MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).toString(exec)->value(exec)));\n    if (exec->hadException())\n        return JSValue::encode(jsUndefined());\n    TestObj* objArg(toTestObj(MAYBE_MISSING_PARAMETER(exec, 1, DefaultIsUndefined)));\n    if (exec->hadException())\n        return JSValue::encode(jsUndefined());\n\n    JSC::JSValue result = toJS(exec, castedThis->globalObject(), WTF::getPtr(TestSupplemental::supplementalMethod2(impl, scriptContext, strArg, objArg, ec)));\n    setDOMException(exec, ec);\n    return JSValue::encode(result);\n}\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 792,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2017-5092",
    "code_before_change": " void PepperRendererConnection::OnMsgDidDeleteInProcessInstance(\n     PP_Instance instance) {\n   in_process_host_->DeleteInstance(instance);\n }\n",
    "code_after_change": " void PepperRendererConnection::OnMsgDidDeleteInProcessInstance(\n     PP_Instance instance) {\n  // 'instance' is possibly invalid. The host must be careful not to trust it.\n   in_process_host_->DeleteInstance(instance);\n }\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 793,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2018-6140",
    "code_before_change": "void RenderFrameDevToolsAgentHost::DestroyOnRenderFrameGone() {\n   scoped_refptr<RenderFrameDevToolsAgentHost> protect(this);\n   if (IsAttached())\n     RevokePolicy();\n  ForceDetachAllClients();\n   frame_host_ = nullptr;\n   agent_ptr_.reset();\n   SetFrameTreeNode(nullptr);\n  Release();\n}\n",
    "code_after_change": "void RenderFrameDevToolsAgentHost::DestroyOnRenderFrameGone() {\n   scoped_refptr<RenderFrameDevToolsAgentHost> protect(this);\n   if (IsAttached())\n     RevokePolicy();\n  ForceDetachAllSessions();\n   frame_host_ = nullptr;\n   agent_ptr_.reset();\n   SetFrameTreeNode(nullptr);\n  Release();\n}\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 815,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2016-10167",
    "code_before_change": "BGD_DECLARE(gdImagePtr) gdImageCreateFromGd2Ctx (gdIOCtxPtr in)\n{\n\tint sx, sy;\n\tint i;\n\tint ncx, ncy, nc, cs, cx, cy;\n\tint x, y, ylo, yhi, xlo, xhi;\n\tint vers, fmt;\n\tt_chunk_info *chunkIdx = NULL;\t/* So we can gdFree it with impunity. */\n\tunsigned char *chunkBuf = NULL;\t/* So we can gdFree it with impunity. */\n\tint chunkNum = 0;\n\tint chunkMax = 0;\n\tuLongf chunkLen;\n\tint chunkPos = 0;\n\tint compMax = 0;\n\tint bytesPerPixel;\n\tchar *compBuf = NULL;\t\t/* So we can gdFree it with impunity. */\n\n\tgdImagePtr im;\n\n\t/* Get the header */\n\tim =\n\t    _gd2CreateFromFile (in, &sx, &sy, &cs, &vers, &fmt, &ncx, &ncy,\n\t                        &chunkIdx);\n\tif (im == NULL) {\n\t\t/* No need to free chunkIdx as _gd2CreateFromFile does it for us. */\n\t\treturn 0;\n\t}\n\n\tbytesPerPixel = im->trueColor ? 4 : 1;\n\tnc = ncx * ncy;\n\n\tif (gd2_compressed (fmt)) {\n\t\t/* Find the maximum compressed chunk size. */\n\t\tcompMax = 0;\n\t\tfor (i = 0; (i < nc); i++) {\n\t\t\tif (chunkIdx[i].size > compMax) {\n\t\t\t\tcompMax = chunkIdx[i].size;\n\t\t\t};\n\t\t};\n\t\tcompMax++;\n\n\t\t/* Allocate buffers */\n\t\tchunkMax = cs * bytesPerPixel * cs;\n\t\tchunkBuf = gdCalloc (chunkMax, 1);\n\t\tif (!chunkBuf) {\n\t\t\tgoto fail;\n\t\t}\n\t\tcompBuf = gdCalloc (compMax, 1);\n\t\tif (!compBuf) {\n\t\t\tgoto fail;\n\t\t}\n\n\t\tGD2_DBG (printf (\"Largest compressed chunk is %d bytes\\n\", compMax));\n\t};\n\n\t/*      if ( (ncx != sx / cs) || (ncy != sy / cs)) { */\n\t/*              goto fail2; */\n\t/*      }; */\n\n\t/* Read the data... */\n\tfor (cy = 0; (cy < ncy); cy++) {\n\t\tfor (cx = 0; (cx < ncx); cx++) {\n\n\t\t\tylo = cy * cs;\n\t\t\tyhi = ylo + cs;\n\t\t\tif (yhi > im->sy) {\n\t\t\t\tyhi = im->sy;\n\t\t\t};\n\n\t\t\tGD2_DBG (printf\n\t\t\t         (\"Processing Chunk %d (%d, %d), y from %d to %d\\n\",\n\t\t\t          chunkNum, cx, cy, ylo, yhi));\n\n\t\t\tif (gd2_compressed (fmt)) {\n\n\t\t\t\tchunkLen = chunkMax;\n\n\t\t\t\tif (!_gd2ReadChunk (chunkIdx[chunkNum].offset,\n\t\t\t\t                    compBuf,\n\t\t\t\t                    chunkIdx[chunkNum].size,\n\t\t\t\t                    (char *) chunkBuf, &chunkLen, in)) {\n\t\t\t\t\tGD2_DBG (printf (\"Error reading comproessed chunk\\n\"));\n\t\t\t\t\tgoto fail;\n\t\t\t\t};\n\n\t\t\t\tchunkPos = 0;\n\t\t\t};\n\n\t\t\tfor (y = ylo; (y < yhi); y++) {\n\n\t\t\t\txlo = cx * cs;\n\t\t\t\txhi = xlo + cs;\n\t\t\t\tif (xhi > im->sx) {\n\t\t\t\t\txhi = im->sx;\n\t\t\t\t};\n\t\t\t\t/*GD2_DBG(printf(\"y=%d: \",y)); */\n\t\t\t\tif (!gd2_compressed (fmt)) {\n\t\t\t\t\tfor (x = xlo; x < xhi; x++) {\n \n \t\t\t\t\t\tif (im->trueColor) {\n \t\t\t\t\t\t\tif (!gdGetInt (&im->tpixels[y][x], in)) {\n\t\t\t\t\t\t\t\t/*printf(\"EOF while reading\\n\"); */\n\t\t\t\t\t\t\t\t/*gdImageDestroy(im); */\n\t\t\t\t\t\t\t\t/*return 0; */\n\t\t\t\t\t\t\t\tim->tpixels[y][x] = 0;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t} else {\n \t\t\t\t\t\t\tint ch;\n \t\t\t\t\t\t\tif (!gdGetByte (&ch, in)) {\n\t\t\t\t\t\t\t\t/*printf(\"EOF while reading\\n\"); */\n\t\t\t\t\t\t\t\t/*gdImageDestroy(im); */\n\t\t\t\t\t\t\t\t/*return 0; */\n\t\t\t\t\t\t\t\tch = 0;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tim->pixels[y][x] = ch;\n \t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (x = xlo; x < xhi; x++) {\n\t\t\t\t\t\tif (im->trueColor) {\n\t\t\t\t\t\t\t/* 2.0.1: work around a gcc bug by being verbose.\n\t\t\t\t\t\t\t   TBB */\n\t\t\t\t\t\t\tint a = chunkBuf[chunkPos++] << 24;\n\t\t\t\t\t\t\tint r = chunkBuf[chunkPos++] << 16;\n\t\t\t\t\t\t\tint g = chunkBuf[chunkPos++] << 8;\n\t\t\t\t\t\t\tint b = chunkBuf[chunkPos++];\n\t\t\t\t\t\t\t/* 2.0.11: tpixels */\n\t\t\t\t\t\t\tim->tpixels[y][x] = a + r + g + b;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tim->pixels[y][x] = chunkBuf[chunkPos++];\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t\t/*GD2_DBG(printf(\"\\n\")); */\n\t\t\t};\n\t\t\tchunkNum++;\n\t\t};\n\t};\n\n\tGD2_DBG (printf (\"Freeing memory\\n\"));\n\n\tgdFree (chunkBuf);\n\tgdFree (compBuf);\n\tgdFree (chunkIdx);\n\n\tGD2_DBG (printf (\"Done\\n\"));\n\n\treturn im;\n\nfail:\n\tgdImageDestroy (im);\n\tif (chunkBuf) {\n\t\tgdFree (chunkBuf);\n\t}\n\tif (compBuf) {\n\t\tgdFree (compBuf);\n\t}\n\tif (chunkIdx) {\n\t\tgdFree (chunkIdx);\n\t}\n\treturn 0;\n}\n",
    "code_after_change": "BGD_DECLARE(gdImagePtr) gdImageCreateFromGd2Ctx (gdIOCtxPtr in)\n{\n\tint sx, sy;\n\tint i;\n\tint ncx, ncy, nc, cs, cx, cy;\n\tint x, y, ylo, yhi, xlo, xhi;\n\tint vers, fmt;\n\tt_chunk_info *chunkIdx = NULL;\t/* So we can gdFree it with impunity. */\n\tunsigned char *chunkBuf = NULL;\t/* So we can gdFree it with impunity. */\n\tint chunkNum = 0;\n\tint chunkMax = 0;\n\tuLongf chunkLen;\n\tint chunkPos = 0;\n\tint compMax = 0;\n\tint bytesPerPixel;\n\tchar *compBuf = NULL;\t\t/* So we can gdFree it with impunity. */\n\n\tgdImagePtr im;\n\n\t/* Get the header */\n\tim =\n\t    _gd2CreateFromFile (in, &sx, &sy, &cs, &vers, &fmt, &ncx, &ncy,\n\t                        &chunkIdx);\n\tif (im == NULL) {\n\t\t/* No need to free chunkIdx as _gd2CreateFromFile does it for us. */\n\t\treturn 0;\n\t}\n\n\tbytesPerPixel = im->trueColor ? 4 : 1;\n\tnc = ncx * ncy;\n\n\tif (gd2_compressed (fmt)) {\n\t\t/* Find the maximum compressed chunk size. */\n\t\tcompMax = 0;\n\t\tfor (i = 0; (i < nc); i++) {\n\t\t\tif (chunkIdx[i].size > compMax) {\n\t\t\t\tcompMax = chunkIdx[i].size;\n\t\t\t};\n\t\t};\n\t\tcompMax++;\n\n\t\t/* Allocate buffers */\n\t\tchunkMax = cs * bytesPerPixel * cs;\n\t\tchunkBuf = gdCalloc (chunkMax, 1);\n\t\tif (!chunkBuf) {\n\t\t\tgoto fail;\n\t\t}\n\t\tcompBuf = gdCalloc (compMax, 1);\n\t\tif (!compBuf) {\n\t\t\tgoto fail;\n\t\t}\n\n\t\tGD2_DBG (printf (\"Largest compressed chunk is %d bytes\\n\", compMax));\n\t};\n\n\t/*      if ( (ncx != sx / cs) || (ncy != sy / cs)) { */\n\t/*              goto fail2; */\n\t/*      }; */\n\n\t/* Read the data... */\n\tfor (cy = 0; (cy < ncy); cy++) {\n\t\tfor (cx = 0; (cx < ncx); cx++) {\n\n\t\t\tylo = cy * cs;\n\t\t\tyhi = ylo + cs;\n\t\t\tif (yhi > im->sy) {\n\t\t\t\tyhi = im->sy;\n\t\t\t};\n\n\t\t\tGD2_DBG (printf\n\t\t\t         (\"Processing Chunk %d (%d, %d), y from %d to %d\\n\",\n\t\t\t          chunkNum, cx, cy, ylo, yhi));\n\n\t\t\tif (gd2_compressed (fmt)) {\n\n\t\t\t\tchunkLen = chunkMax;\n\n\t\t\t\tif (!_gd2ReadChunk (chunkIdx[chunkNum].offset,\n\t\t\t\t                    compBuf,\n\t\t\t\t                    chunkIdx[chunkNum].size,\n\t\t\t\t                    (char *) chunkBuf, &chunkLen, in)) {\n\t\t\t\t\tGD2_DBG (printf (\"Error reading comproessed chunk\\n\"));\n\t\t\t\t\tgoto fail;\n\t\t\t\t};\n\n\t\t\t\tchunkPos = 0;\n\t\t\t};\n\n\t\t\tfor (y = ylo; (y < yhi); y++) {\n\n\t\t\t\txlo = cx * cs;\n\t\t\t\txhi = xlo + cs;\n\t\t\t\tif (xhi > im->sx) {\n\t\t\t\t\txhi = im->sx;\n\t\t\t\t};\n\t\t\t\t/*GD2_DBG(printf(\"y=%d: \",y)); */\n\t\t\t\tif (!gd2_compressed (fmt)) {\n\t\t\t\t\tfor (x = xlo; x < xhi; x++) {\n \n \t\t\t\t\t\tif (im->trueColor) {\n \t\t\t\t\t\t\tif (!gdGetInt (&im->tpixels[y][x], in)) {\n\t\t\t\t\t\t\t\tgd_error(\"gd2: EOF while reading\\n\");\n\t\t\t\t\t\t\t\tgdImageDestroy(im);\n\t\t\t\t\t\t\t\treturn NULL;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t} else {\n \t\t\t\t\t\t\tint ch;\n \t\t\t\t\t\t\tif (!gdGetByte (&ch, in)) {\n\t\t\t\t\t\t\t\tgd_error(\"gd2: EOF while reading\\n\");\n\t\t\t\t\t\t\t\tgdImageDestroy(im);\n\t\t\t\t\t\t\t\treturn NULL;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tim->pixels[y][x] = ch;\n \t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (x = xlo; x < xhi; x++) {\n\t\t\t\t\t\tif (im->trueColor) {\n\t\t\t\t\t\t\t/* 2.0.1: work around a gcc bug by being verbose.\n\t\t\t\t\t\t\t   TBB */\n\t\t\t\t\t\t\tint a = chunkBuf[chunkPos++] << 24;\n\t\t\t\t\t\t\tint r = chunkBuf[chunkPos++] << 16;\n\t\t\t\t\t\t\tint g = chunkBuf[chunkPos++] << 8;\n\t\t\t\t\t\t\tint b = chunkBuf[chunkPos++];\n\t\t\t\t\t\t\t/* 2.0.11: tpixels */\n\t\t\t\t\t\t\tim->tpixels[y][x] = a + r + g + b;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tim->pixels[y][x] = chunkBuf[chunkPos++];\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t\t/*GD2_DBG(printf(\"\\n\")); */\n\t\t\t};\n\t\t\tchunkNum++;\n\t\t};\n\t};\n\n\tGD2_DBG (printf (\"Freeing memory\\n\"));\n\n\tgdFree (chunkBuf);\n\tgdFree (compBuf);\n\tgdFree (chunkIdx);\n\n\tGD2_DBG (printf (\"Done\\n\"));\n\n\treturn im;\n\nfail:\n\tgdImageDestroy (im);\n\tif (chunkBuf) {\n\t\tgdFree (chunkBuf);\n\t}\n\tif (compBuf) {\n\t\tgdFree (compBuf);\n\t}\n\tif (chunkIdx) {\n\t\tgdFree (chunkIdx);\n\t}\n\treturn 0;\n}\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 832,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2017-5104",
    "code_before_change": " RenderWidgetHostView* RenderFrameHostManager::GetRenderWidgetHostView() const {\n  if (interstitial_page_)\n    return interstitial_page_->GetView();\n   if (render_frame_host_)\n     return render_frame_host_->GetView();\n   return nullptr;\n}\n",
    "code_after_change": " RenderWidgetHostView* RenderFrameHostManager::GetRenderWidgetHostView() const {\n  if (delegate_->GetInterstitialForRenderManager())\n    return delegate_->GetInterstitialForRenderManager()->GetView();\n   if (render_frame_host_)\n     return render_frame_host_->GetView();\n   return nullptr;\n}\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 836,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2013-7294",
    "code_before_change": "static void ikev2_parent_inI1outR1_continue(struct pluto_crypto_req_cont *pcrc,\n\t\t\t\t\t    struct pluto_crypto_req *r,\n\t\t\t\t\t    err_t ugh)\n{\n\tstruct ke_continuation *ke = (struct ke_continuation *)pcrc;\n\tstruct msg_digest *md = ke->md;\n\tstruct state *const st = md->st;\n\tstf_status e;\n\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\"ikev2 parent inI1outR1: calculated ke+nonce, sending R1\"));\n\n\tif (st == NULL) {\n\t\tloglog(RC_LOG_SERIOUS,\n\t\t       \"%s: Request was disconnected from state\",\n\t\t       __FUNCTION__);\n\t\tif (ke->md)\n\t\t\trelease_md(ke->md);\n\t\treturn;\n\t}\n\n\t/* XXX should check out ugh */\n\tpassert(ugh == NULL);\n\tpassert(cur_state == NULL);\n\tpassert(st != NULL);\n\n\tpassert(st->st_suspended_md == ke->md);\n\tset_suspended(st, NULL); /* no longer connected or suspended */\n\n\tset_cur_state(st);\n\n\tst->st_calculating = FALSE;\n\n\te = ikev2_parent_inI1outR1_tail(pcrc, r);\n\n\tif (ke->md != NULL) {\n\t\tcomplete_v2_state_transition(&ke->md, e);\n\t\tif (ke->md)\n \t\t\trelease_md(ke->md);\n \t}\n \treset_globals();\n\tpassert(GLOBALS_ARE_RESET());\n }\n",
    "code_after_change": "static void ikev2_parent_inI1outR1_continue(struct pluto_crypto_req_cont *pcrc,\n\t\t\t\t\t    struct pluto_crypto_req *r,\n\t\t\t\t\t    err_t ugh)\n{\n\tstruct ke_continuation *ke = (struct ke_continuation *)pcrc;\n\tstruct msg_digest *md = ke->md;\n\tstruct state *const st = md->st;\n\tstf_status e;\n\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\"ikev2 parent inI1outR1: calculated ke+nonce, sending R1\"));\n\n\tif (st == NULL) {\n\t\tloglog(RC_LOG_SERIOUS,\n\t\t       \"%s: Request was disconnected from state\",\n\t\t       __FUNCTION__);\n\t\tif (ke->md)\n\t\t\trelease_md(ke->md);\n\t\treturn;\n\t}\n\n\t/* XXX should check out ugh */\n\tpassert(ugh == NULL);\n\tpassert(cur_state == NULL);\n\tpassert(st != NULL);\n\n\tpassert(st->st_suspended_md == ke->md);\n\tset_suspended(st, NULL); /* no longer connected or suspended */\n\n\tset_cur_state(st);\n\n\tst->st_calculating = FALSE;\n\n\te = ikev2_parent_inI1outR1_tail(pcrc, r);\n\n\tif (ke->md != NULL) {\n\t\tcomplete_v2_state_transition(&ke->md, e);\n\t\tif (ke->md)\n \t\t\trelease_md(ke->md);\n \t}\n \treset_globals();\n }\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 846,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2018-6111",
    "code_before_change": "void SecurityHandler::SetRenderer(RenderProcessHost* process_host,\n                                   RenderFrameHostImpl* frame_host) {\n   host_ = frame_host;\n   if (enabled_ && host_)\n    AttachToRenderFrameHost();\n}\n",
    "code_after_change": "void SecurityHandler::SetRenderer(RenderProcessHost* process_host,\nvoid SecurityHandler::SetRenderer(int process_host_id,\n                                   RenderFrameHostImpl* frame_host) {\n   host_ = frame_host;\n   if (enabled_ && host_)\n    AttachToRenderFrameHost();\n}\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 852,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2018-6111",
    "code_before_change": "void DOMHandler::SetRenderer(RenderProcessHost* process_host,\n                              RenderFrameHostImpl* frame_host) {\n   host_ = frame_host;\n }\n",
    "code_after_change": "void DOMHandler::SetRenderer(RenderProcessHost* process_host,\nvoid DOMHandler::SetRenderer(int process_host_id,\n                              RenderFrameHostImpl* frame_host) {\n   host_ = frame_host;\n }\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 878,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2012-5148",
    "code_before_change": "void TabContentsContainerGtk::DetachTab(TabContents* tab) {\n  gfx::NativeView widget = tab->web_contents()->GetNativeView();\n \n  if (widget) {\n    GtkWidget* parent = gtk_widget_get_parent(widget);\n    if (parent) {\n      DCHECK_EQ(parent, expanded_);\n      gtk_container_remove(GTK_CONTAINER(expanded_), widget);\n    }\n  }\n}\n",
    "code_after_change": "void TabContentsContainerGtk::DetachTab(TabContents* tab) {\nvoid TabContentsContainerGtk::DetachTab(WebContents* tab) {\n  gfx::NativeView widget = tab->GetNativeView();\n \n  if (widget) {\n    GtkWidget* parent = gtk_widget_get_parent(widget);\n    if (parent) {\n      DCHECK_EQ(parent, expanded_);\n      gtk_container_remove(GTK_CONTAINER(expanded_), widget);\n    }\n  }\n}\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 890,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2011-3936",
    "code_before_change": "static int dv_extract_audio_info(DVDemuxContext* c, uint8_t* frame)\n{\n    const uint8_t* as_pack;\n    int freq, stype, smpls, quant, i, ach;\n\n    as_pack = dv_extract_pack(frame, dv_audio_source);\n    if (!as_pack || !c->sys) {    /* No audio ? */\n        c->ach = 0;\n        return 0;\n    }\n\n    smpls =  as_pack[1] & 0x3f;       /* samples in this frame - min. samples */\n    freq  = (as_pack[4] >> 3) & 0x07; /* 0 - 48kHz, 1 - 44,1kHz, 2 - 32kHz */\n     stype = (as_pack[3] & 0x1f);      /* 0 - 2CH, 2 - 4CH, 3 - 8CH */\n     quant =  as_pack[4] & 0x07;       /* 0 - 16bit linear, 1 - 12bit nonlinear */\n \n     /* note: ach counts PAIRS of channels (i.e. stereo channels) */\n     ach = ((int[4]){  1,  0,  2,  4})[stype];\n     if (ach == 1 && quant && freq == 2)\n           if (!c->ast[i])\n               break;\n           avpriv_set_pts_info(c->ast[i], 64, 1, 30000);\n           c->ast[i]->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n           c->ast[i]->codec->codec_id   = CODEC_ID_PCM_S16LE;\n\n           av_init_packet(&c->audio_pkt[i]);\n           c->audio_pkt[i].size         = 0;\n           c->audio_pkt[i].data         = c->audio_buf[i];\n           c->audio_pkt[i].stream_index = c->ast[i]->index;\n           c->audio_pkt[i].flags       |= AV_PKT_FLAG_KEY;\n       }\n",
    "code_after_change": "static int dv_extract_audio_info(DVDemuxContext* c, uint8_t* frame)\n{\n    const uint8_t* as_pack;\n    int freq, stype, smpls, quant, i, ach;\n\n    as_pack = dv_extract_pack(frame, dv_audio_source);\n    if (!as_pack || !c->sys) {    /* No audio ? */\n        c->ach = 0;\n        return 0;\n    }\n\n    smpls =  as_pack[1] & 0x3f;       /* samples in this frame - min. samples */\n    freq  = (as_pack[4] >> 3) & 0x07; /* 0 - 48kHz, 1 - 44,1kHz, 2 - 32kHz */\n     stype = (as_pack[3] & 0x1f);      /* 0 - 2CH, 2 - 4CH, 3 - 8CH */\n     quant =  as_pack[4] & 0x07;       /* 0 - 16bit linear, 1 - 12bit nonlinear */\n \n    if (stype > 3) {\n        av_log(c->fctx, AV_LOG_ERROR, \"stype %d is invalid\\n\", stype);\n        c->ach = 0;\n        return 0;\n    }\n\n     /* note: ach counts PAIRS of channels (i.e. stereo channels) */\n     ach = ((int[4]){  1,  0,  2,  4})[stype];\n     if (ach == 1 && quant && freq == 2)\n           if (!c->ast[i])\n               break;\n           avpriv_set_pts_info(c->ast[i], 64, 1, 30000);\n           c->ast[i]->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n           c->ast[i]->codec->codec_id   = CODEC_ID_PCM_S16LE;\n\n           av_init_packet(&c->audio_pkt[i]);\n           c->audio_pkt[i].size         = 0;\n           c->audio_pkt[i].data         = c->audio_buf[i];\n           c->audio_pkt[i].stream_index = c->ast[i]->index;\n           c->audio_pkt[i].flags       |= AV_PKT_FLAG_KEY;\n       }\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 902,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2011-3907",
    "code_before_change": "NavigateParams::NavigateParams(Browser* a_browser,\n                               TabContentsWrapper* a_target_contents)\n    : target_contents(a_target_contents),\n       source_contents(NULL),\n       disposition(CURRENT_TAB),\n       transition(content::PAGE_TRANSITION_LINK),\n       tabstrip_index(-1),\n       tabstrip_add_types(TabStripModel::ADD_ACTIVE),\n       window_action(NO_ACTION),\n      user_gesture(true),\n      path_behavior(RESPECT),\n      ref_behavior(IGNORE_REF),\n      browser(a_browser),\n      profile(NULL) {\n}\n",
    "code_after_change": "NavigateParams::NavigateParams(Browser* a_browser,\n                               TabContentsWrapper* a_target_contents)\n    : target_contents(a_target_contents),\n       source_contents(NULL),\n       disposition(CURRENT_TAB),\n       transition(content::PAGE_TRANSITION_LINK),\n      is_renderer_initiated(false),\n       tabstrip_index(-1),\n       tabstrip_add_types(TabStripModel::ADD_ACTIVE),\n       window_action(NO_ACTION),\n      user_gesture(true),\n      path_behavior(RESPECT),\n      ref_behavior(IGNORE_REF),\n      browser(a_browser),\n      profile(NULL) {\n}\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 917,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2018-6111",
    "code_before_change": "void SharedWorkerDevToolsAgentHost::AttachSession(DevToolsSession* session) {\n   session->AddHandler(std::make_unique<protocol::InspectorHandler>());\n   session->AddHandler(std::make_unique<protocol::NetworkHandler>(GetId()));\n   session->AddHandler(std::make_unique<protocol::SchemaHandler>());\n  session->SetRenderer(GetProcess(), nullptr);\n   if (state_ == WORKER_READY)\n     session->AttachToAgent(EnsureAgent());\n }\n",
    "code_after_change": "void SharedWorkerDevToolsAgentHost::AttachSession(DevToolsSession* session) {\n   session->AddHandler(std::make_unique<protocol::InspectorHandler>());\n   session->AddHandler(std::make_unique<protocol::NetworkHandler>(GetId()));\n   session->AddHandler(std::make_unique<protocol::SchemaHandler>());\n  session->SetRenderer(worker_host_ ? worker_host_->process_id() : -1, nullptr);\n   if (state_ == WORKER_READY)\n     session->AttachToAgent(EnsureAgent());\n }\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 961,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2015-8900",
    "code_before_change": "static Image *ReadHDRImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    format[MaxTextExtent],\n    keyword[MaxTextExtent],\n    tag[MaxTextExtent],\n    value[MaxTextExtent];\n\n  double\n    gamma;\n\n  Image\n    *image;\n\n  int\n    c;\n\n  MagickBooleanType\n    status,\n    value_expected;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *p;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *end,\n    pixel[4],\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Decode image header.\n  */\n  image->columns=0;\n  image->rows=0;\n  *format='\\0';\n  c=ReadBlobByte(image);\n  if (c == EOF)\n    {\n      image=DestroyImage(image);\n      return((Image *) NULL);\n    }\n  while (isgraph(c) && (image->columns == 0) && (image->rows == 0))\n  {\n    if (c == (int) '#')\n      {\n        char\n          *comment;\n\n        register char\n          *p;\n\n        size_t\n          length;\n\n        /*\n          Read comment-- any text between # and end-of-line.\n        */\n        length=MaxTextExtent;\n        comment=AcquireString((char *) NULL);\n        for (p=comment; comment != (char *) NULL; p++)\n        {\n          c=ReadBlobByte(image);\n          if ((c == EOF) || (c == (int) '\\n'))\n            break;\n          if ((size_t) (p-comment+1) >= length)\n            {\n              *p='\\0';\n              length<<=1;\n              comment=(char *) ResizeQuantumMemory(comment,length+\n                MaxTextExtent,sizeof(*comment));\n              if (comment == (char *) NULL)\n                break;\n              p=comment+strlen(comment);\n            }\n          *p=(char) c;\n        }\n        if (comment == (char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        *p='\\0';\n        (void) SetImageProperty(image,\"comment\",comment,exception);\n        comment=DestroyString(comment);\n        c=ReadBlobByte(image);\n      }\n    else\n      if (isalnum(c) == MagickFalse)\n        c=ReadBlobByte(image);\n      else\n        {\n          register char\n            *p;\n\n          /*\n            Determine a keyword and its value.\n          */\n          p=keyword;\n          do\n          {\n            if ((size_t) (p-keyword) < (MaxTextExtent-1))\n              *p++=c;\n            c=ReadBlobByte(image);\n          } while (isalnum(c) || (c == '_'));\n          *p='\\0';\n          value_expected=MagickFalse;\n          while ((isspace((int) ((unsigned char) c)) != 0) || (c == '='))\n          {\n            if (c == '=')\n              value_expected=MagickTrue;\n            c=ReadBlobByte(image);\n          }\n          if (LocaleCompare(keyword,\"Y\") == 0)\n            value_expected=MagickTrue;\n           if (value_expected == MagickFalse)\n             continue;\n           p=value;\n          while ((c != '\\n') && (c != '\\0'))\n           {\n             if ((size_t) (p-value) < (MaxTextExtent-1))\n               *p++=c;\n            c=ReadBlobByte(image);\n          }\n          *p='\\0';\n          /*\n            Assign a value to the specified keyword.\n          */\n          switch (*keyword)\n          {\n            case 'F':\n            case 'f':\n            {\n              if (LocaleCompare(keyword,\"format\") == 0)\n                {\n                  (void) CopyMagickString(format,value,MaxTextExtent);\n                  break;\n                }\n              (void) FormatLocaleString(tag,MaxTextExtent,\"hdr:%s\",keyword);\n              (void) SetImageProperty(image,tag,value,exception);\n              break;\n            }\n            case 'G':\n            case 'g':\n            {\n              if (LocaleCompare(keyword,\"gamma\") == 0)\n                {\n                  image->gamma=StringToDouble(value,(char **) NULL);\n                  break;\n                }\n              (void) FormatLocaleString(tag,MaxTextExtent,\"hdr:%s\",keyword);\n              (void) SetImageProperty(image,tag,value,exception);\n              break;\n            }\n            case 'P':\n            case 'p':\n            {\n              if (LocaleCompare(keyword,\"primaries\") == 0)\n                {\n                  float\n                     chromaticity[6],\n                     white_point[2];\n \n                  (void) sscanf(value,\"%g %g %g %g %g %g %g %g\",\n                    &chromaticity[0],&chromaticity[1],&chromaticity[2],\n                    &chromaticity[3],&chromaticity[4],&chromaticity[5],\n                    &white_point[0],&white_point[1]);\n                  image->chromaticity.red_primary.x=chromaticity[0];\n                  image->chromaticity.red_primary.y=chromaticity[1];\n                  image->chromaticity.green_primary.x=chromaticity[2];\n                  image->chromaticity.green_primary.y=chromaticity[3];\n                  image->chromaticity.blue_primary.x=chromaticity[4];\n                  image->chromaticity.blue_primary.y=chromaticity[5];\n                  image->chromaticity.white_point.x=white_point[0],\n                  image->chromaticity.white_point.y=white_point[1];\n                   break;\n                 }\n               (void) FormatLocaleString(tag,MaxTextExtent,\"hdr:%s\",keyword);\n              (void) SetImageProperty(image,tag,value,exception);\n              break;\n            }\n            case 'Y':\n            case 'y':\n            {\n              char\n                target[] = \"Y\";\n\n              if (strcmp(keyword,target) == 0)\n                {\n                  int\n                     height,\n                     width;\n \n                  (void) sscanf(value,\"%d +X %d\",&height,&width);\n                  image->columns=(size_t) width;\n                  image->rows=(size_t) height;\n                   break;\n                 }\n               (void) FormatLocaleString(tag,MaxTextExtent,\"hdr:%s\",keyword);\n              (void) SetImageProperty(image,tag,value,exception);\n              break;\n            }\n            default:\n            {\n              (void) FormatLocaleString(tag,MaxTextExtent,\"hdr:%s\",keyword);\n              (void) SetImageProperty(image,tag,value,exception);\n              break;\n            }\n          }\n        }\n    if ((image->columns == 0) && (image->rows == 0))\n      while (isspace((int) ((unsigned char) c)) != 0)\n        c=ReadBlobByte(image);\n  }\n  if ((LocaleCompare(format,\"32-bit_rle_rgbe\") != 0) &&\n      (LocaleCompare(format,\"32-bit_rle_xyze\") != 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if ((image->columns == 0) || (image->rows == 0))\n    ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\");\n  (void) SetImageColorspace(image,RGBColorspace,exception);\n  if (LocaleCompare(format,\"32-bit_rle_xyze\") == 0)\n    (void) SetImageColorspace(image,XYZColorspace,exception);\n  image->compression=(image->columns < 8) || (image->columns > 0x7ffff) ?\n    NoCompression : RLECompression;\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  /*\n    Read RGBE (red+green+blue+exponent) pixels.\n  */\n  pixels=(unsigned char *) AcquireQuantumMemory(image->columns,4*\n    sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    if (image->compression != RLECompression)\n      {\n        count=ReadBlob(image,4*image->columns*sizeof(*pixels),pixels);\n        if (count != (ssize_t) (4*image->columns*sizeof(*pixels)))\n          break;\n      }\n    else\n      {\n        count=ReadBlob(image,4*sizeof(*pixel),pixel);\n        if (count != 4)\n          break;\n        if ((size_t) ((((size_t) pixel[2]) << 8) | pixel[3]) != image->columns)\n          {\n            (void) memcpy(pixels,pixel,4*sizeof(*pixel));\n            count=ReadBlob(image,4*(image->columns-1)*sizeof(*pixels),pixels+4);\n            image->compression=NoCompression;\n          }\n        else\n          {\n            p=pixels;\n            for (i=0; i < 4; i++)\n            {\n              end=&pixels[(i+1)*image->columns];\n              while (p < end)\n              {\n                count=ReadBlob(image,2*sizeof(*pixel),pixel);\n                if (count < 1)\n                  break;\n                if (pixel[0] > 128)\n                  {\n                    count=(ssize_t) pixel[0]-128;\n                    if ((count == 0) || (count > (ssize_t) (end-p)))\n                      break;\n                    while (count-- > 0)\n                      *p++=pixel[1];\n                  }\n                else\n                  {\n                    count=(ssize_t) pixel[0];\n                    if ((count == 0) || (count > (ssize_t) (end-p)))\n                      break;\n                    *p++=pixel[1];\n                    if (--count > 0)\n                      {\n                        count=ReadBlob(image,(size_t) count*sizeof(*p),p);\n                        if (count < 1)\n                          break;\n                        p+=count;\n                      }\n                  }\n              }\n            }\n          }\n      }\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    i=0;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if (image->compression == RLECompression)\n        {\n          pixel[0]=pixels[x];\n          pixel[1]=pixels[x+image->columns];\n          pixel[2]=pixels[x+2*image->columns];\n          pixel[3]=pixels[x+3*image->columns];\n        }\n      else\n        {\n          pixel[0]=pixels[i++];\n          pixel[1]=pixels[i++];\n          pixel[2]=pixels[i++];\n          pixel[3]=pixels[i++];\n        }\n      SetPixelRed(image,0,q);\n      SetPixelGreen(image,0,q);\n      SetPixelBlue(image,0,q);\n      if (pixel[3] != 0)\n        {\n          gamma=pow(2.0,pixel[3]-(128.0+8.0));\n          SetPixelRed(image,ClampToQuantum(QuantumRange*gamma*pixel[0]),q);\n          SetPixelGreen(image,ClampToQuantum(QuantumRange*gamma*pixel[1]),q);\n          SetPixelBlue(image,ClampToQuantum(QuantumRange*gamma*pixel[2]),q);\n        }\n      q+=GetPixelChannels(image);\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n",
    "code_after_change": "static Image *ReadHDRImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    format[MaxTextExtent],\n    keyword[MaxTextExtent],\n    tag[MaxTextExtent],\n    value[MaxTextExtent];\n\n  double\n    gamma;\n\n  Image\n    *image;\n\n  int\n    c;\n\n  MagickBooleanType\n    status,\n    value_expected;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *p;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *end,\n    pixel[4],\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Decode image header.\n  */\n  image->columns=0;\n  image->rows=0;\n  *format='\\0';\n  c=ReadBlobByte(image);\n  if (c == EOF)\n    {\n      image=DestroyImage(image);\n      return((Image *) NULL);\n    }\n  while (isgraph(c) && (image->columns == 0) && (image->rows == 0))\n  {\n    if (c == (int) '#')\n      {\n        char\n          *comment;\n\n        register char\n          *p;\n\n        size_t\n          length;\n\n        /*\n          Read comment-- any text between # and end-of-line.\n        */\n        length=MaxTextExtent;\n        comment=AcquireString((char *) NULL);\n        for (p=comment; comment != (char *) NULL; p++)\n        {\n          c=ReadBlobByte(image);\n          if ((c == EOF) || (c == (int) '\\n'))\n            break;\n          if ((size_t) (p-comment+1) >= length)\n            {\n              *p='\\0';\n              length<<=1;\n              comment=(char *) ResizeQuantumMemory(comment,length+\n                MaxTextExtent,sizeof(*comment));\n              if (comment == (char *) NULL)\n                break;\n              p=comment+strlen(comment);\n            }\n          *p=(char) c;\n        }\n        if (comment == (char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        *p='\\0';\n        (void) SetImageProperty(image,\"comment\",comment,exception);\n        comment=DestroyString(comment);\n        c=ReadBlobByte(image);\n      }\n    else\n      if (isalnum(c) == MagickFalse)\n        c=ReadBlobByte(image);\n      else\n        {\n          register char\n            *p;\n\n          /*\n            Determine a keyword and its value.\n          */\n          p=keyword;\n          do\n          {\n            if ((size_t) (p-keyword) < (MaxTextExtent-1))\n              *p++=c;\n            c=ReadBlobByte(image);\n          } while (isalnum(c) || (c == '_'));\n          *p='\\0';\n          value_expected=MagickFalse;\n          while ((isspace((int) ((unsigned char) c)) != 0) || (c == '='))\n          {\n            if (c == '=')\n              value_expected=MagickTrue;\n            c=ReadBlobByte(image);\n          }\n          if (LocaleCompare(keyword,\"Y\") == 0)\n            value_expected=MagickTrue;\n           if (value_expected == MagickFalse)\n             continue;\n           p=value;\n          while ((c != '\\n') && (c != '\\0') && (c != EOF))\n           {\n             if ((size_t) (p-value) < (MaxTextExtent-1))\n               *p++=c;\n            c=ReadBlobByte(image);\n          }\n          *p='\\0';\n          /*\n            Assign a value to the specified keyword.\n          */\n          switch (*keyword)\n          {\n            case 'F':\n            case 'f':\n            {\n              if (LocaleCompare(keyword,\"format\") == 0)\n                {\n                  (void) CopyMagickString(format,value,MaxTextExtent);\n                  break;\n                }\n              (void) FormatLocaleString(tag,MaxTextExtent,\"hdr:%s\",keyword);\n              (void) SetImageProperty(image,tag,value,exception);\n              break;\n            }\n            case 'G':\n            case 'g':\n            {\n              if (LocaleCompare(keyword,\"gamma\") == 0)\n                {\n                  image->gamma=StringToDouble(value,(char **) NULL);\n                  break;\n                }\n              (void) FormatLocaleString(tag,MaxTextExtent,\"hdr:%s\",keyword);\n              (void) SetImageProperty(image,tag,value,exception);\n              break;\n            }\n            case 'P':\n            case 'p':\n            {\n              if (LocaleCompare(keyword,\"primaries\") == 0)\n                {\n                  float\n                     chromaticity[6],\n                     white_point[2];\n \n                  if (sscanf(value,\"%g %g %g %g %g %g %g %g\",&chromaticity[0],\n                      &chromaticity[1],&chromaticity[2],&chromaticity[3],\n                      &chromaticity[4],&chromaticity[5],&white_point[0],\n                      &white_point[1]) == 8)\n                    {\n                      image->chromaticity.red_primary.x=chromaticity[0];\n                      image->chromaticity.red_primary.y=chromaticity[1];\n                      image->chromaticity.green_primary.x=chromaticity[2];\n                      image->chromaticity.green_primary.y=chromaticity[3];\n                      image->chromaticity.blue_primary.x=chromaticity[4];\n                      image->chromaticity.blue_primary.y=chromaticity[5];\n                      image->chromaticity.white_point.x=white_point[0],\n                      image->chromaticity.white_point.y=white_point[1];\n                    }\n                   break;\n                 }\n               (void) FormatLocaleString(tag,MaxTextExtent,\"hdr:%s\",keyword);\n              (void) SetImageProperty(image,tag,value,exception);\n              break;\n            }\n            case 'Y':\n            case 'y':\n            {\n              char\n                target[] = \"Y\";\n\n              if (strcmp(keyword,target) == 0)\n                {\n                  int\n                     height,\n                     width;\n \n                  if (sscanf(value,\"%d +X %d\",&height,&width) == 2)\n                    {\n                      image->columns=(size_t) width;\n                      image->rows=(size_t) height;\n                    }\n                   break;\n                 }\n               (void) FormatLocaleString(tag,MaxTextExtent,\"hdr:%s\",keyword);\n              (void) SetImageProperty(image,tag,value,exception);\n              break;\n            }\n            default:\n            {\n              (void) FormatLocaleString(tag,MaxTextExtent,\"hdr:%s\",keyword);\n              (void) SetImageProperty(image,tag,value,exception);\n              break;\n            }\n          }\n        }\n    if ((image->columns == 0) && (image->rows == 0))\n      while (isspace((int) ((unsigned char) c)) != 0)\n        c=ReadBlobByte(image);\n  }\n  if ((LocaleCompare(format,\"32-bit_rle_rgbe\") != 0) &&\n      (LocaleCompare(format,\"32-bit_rle_xyze\") != 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if ((image->columns == 0) || (image->rows == 0))\n    ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\");\n  (void) SetImageColorspace(image,RGBColorspace,exception);\n  if (LocaleCompare(format,\"32-bit_rle_xyze\") == 0)\n    (void) SetImageColorspace(image,XYZColorspace,exception);\n  image->compression=(image->columns < 8) || (image->columns > 0x7ffff) ?\n    NoCompression : RLECompression;\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  /*\n    Read RGBE (red+green+blue+exponent) pixels.\n  */\n  pixels=(unsigned char *) AcquireQuantumMemory(image->columns,4*\n    sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    if (image->compression != RLECompression)\n      {\n        count=ReadBlob(image,4*image->columns*sizeof(*pixels),pixels);\n        if (count != (ssize_t) (4*image->columns*sizeof(*pixels)))\n          break;\n      }\n    else\n      {\n        count=ReadBlob(image,4*sizeof(*pixel),pixel);\n        if (count != 4)\n          break;\n        if ((size_t) ((((size_t) pixel[2]) << 8) | pixel[3]) != image->columns)\n          {\n            (void) memcpy(pixels,pixel,4*sizeof(*pixel));\n            count=ReadBlob(image,4*(image->columns-1)*sizeof(*pixels),pixels+4);\n            image->compression=NoCompression;\n          }\n        else\n          {\n            p=pixels;\n            for (i=0; i < 4; i++)\n            {\n              end=&pixels[(i+1)*image->columns];\n              while (p < end)\n              {\n                count=ReadBlob(image,2*sizeof(*pixel),pixel);\n                if (count < 1)\n                  break;\n                if (pixel[0] > 128)\n                  {\n                    count=(ssize_t) pixel[0]-128;\n                    if ((count == 0) || (count > (ssize_t) (end-p)))\n                      break;\n                    while (count-- > 0)\n                      *p++=pixel[1];\n                  }\n                else\n                  {\n                    count=(ssize_t) pixel[0];\n                    if ((count == 0) || (count > (ssize_t) (end-p)))\n                      break;\n                    *p++=pixel[1];\n                    if (--count > 0)\n                      {\n                        count=ReadBlob(image,(size_t) count*sizeof(*p),p);\n                        if (count < 1)\n                          break;\n                        p+=count;\n                      }\n                  }\n              }\n            }\n          }\n      }\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    i=0;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if (image->compression == RLECompression)\n        {\n          pixel[0]=pixels[x];\n          pixel[1]=pixels[x+image->columns];\n          pixel[2]=pixels[x+2*image->columns];\n          pixel[3]=pixels[x+3*image->columns];\n        }\n      else\n        {\n          pixel[0]=pixels[i++];\n          pixel[1]=pixels[i++];\n          pixel[2]=pixels[i++];\n          pixel[3]=pixels[i++];\n        }\n      SetPixelRed(image,0,q);\n      SetPixelGreen(image,0,q);\n      SetPixelBlue(image,0,q);\n      if (pixel[3] != 0)\n        {\n          gamma=pow(2.0,pixel[3]-(128.0+8.0));\n          SetPixelRed(image,ClampToQuantum(QuantumRange*gamma*pixel[0]),q);\n          SetPixelGreen(image,ClampToQuantum(QuantumRange*gamma*pixel[1]),q);\n          SetPixelBlue(image,ClampToQuantum(QuantumRange*gamma*pixel[2]),q);\n        }\n      q+=GetPixelChannels(image);\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 963,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2016-4809",
    "code_before_change": "archive_read_format_cpio_read_header(struct archive_read *a,\n    struct archive_entry *entry)\n{\n\tstruct cpio *cpio;\n\tconst void *h;\n\tstruct archive_string_conv *sconv;\n\tsize_t namelength;\n\tsize_t name_pad;\n\tint r;\n\n\tcpio = (struct cpio *)(a->format->data);\n\tsconv = cpio->opt_sconv;\n\tif (sconv == NULL) {\n\t\tif (!cpio->init_default_conversion) {\n\t\t\tcpio->sconv_default =\n\t\t\t    archive_string_default_conversion_for_read(\n\t\t\t      &(a->archive));\n\t\t\tcpio->init_default_conversion = 1;\n\t\t}\n\t\tsconv = cpio->sconv_default;\n\t}\n\t\n\tr = (cpio->read_header(a, cpio, entry, &namelength, &name_pad));\n\n\tif (r < ARCHIVE_WARN)\n\t\treturn (r);\n\n\t/* Read name from buffer. */\n\th = __archive_read_ahead(a, namelength + name_pad, NULL);\n\tif (h == NULL)\n\t    return (ARCHIVE_FATAL);\n\tif (archive_entry_copy_pathname_l(entry,\n\t    (const char *)h, namelength, sconv) != 0) {\n\t\tif (errno == ENOMEM) {\n\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t    \"Can't allocate memory for Pathname\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Pathname can't be converted from %s to current locale.\",\n\t\t    archive_string_conversion_charset_name(sconv));\n\t\tr = ARCHIVE_WARN;\n\t}\n\tcpio->entry_offset = 0;\n\n\t__archive_read_consume(a, namelength + name_pad);\n \n \t/* If this is a symlink, read the link contents. */\n \tif (archive_entry_filetype(entry) == AE_IFLNK) {\n \t\th = __archive_read_ahead(a,\n \t\t\t(size_t)cpio->entry_bytes_remaining, NULL);\n \t\tif (h == NULL)\n\t\t\treturn (ARCHIVE_FATAL);\n\t\tif (archive_entry_copy_symlink_l(entry, (const char *)h,\n\t\t    (size_t)cpio->entry_bytes_remaining, sconv) != 0) {\n\t\t\tif (errno == ENOMEM) {\n\t\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t\t    \"Can't allocate memory for Linkname\");\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Linkname can't be converted from %s to \"\n\t\t\t    \"current locale.\",\n\t\t\t    archive_string_conversion_charset_name(sconv));\n\t\t\tr = ARCHIVE_WARN;\n\t\t}\n\t\t__archive_read_consume(a, cpio->entry_bytes_remaining);\n\t\tcpio->entry_bytes_remaining = 0;\n\t}\n\n\t/* XXX TODO: If the full mode is 0160200, then this is a Solaris\n\t * ACL description for the following entry.  Read this body\n\t * and parse it as a Solaris-style ACL, then read the next\n\t * header.  XXX */\n\n\t/* Compare name to \"TRAILER!!!\" to test for end-of-archive. */\n\tif (namelength == 11 && strcmp((const char *)h, \"TRAILER!!!\") == 0) {\n\t\t/* TODO: Store file location of start of block. */\n\t\tarchive_clear_error(&a->archive);\n\t\treturn (ARCHIVE_EOF);\n\t}\n\n\t/* Detect and record hardlinks to previously-extracted entries. */\n\tif (record_hardlink(a, cpio, entry) != ARCHIVE_OK) {\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\treturn (r);\n}\n",
    "code_after_change": "archive_read_format_cpio_read_header(struct archive_read *a,\n    struct archive_entry *entry)\n{\n\tstruct cpio *cpio;\n\tconst void *h;\n\tstruct archive_string_conv *sconv;\n\tsize_t namelength;\n\tsize_t name_pad;\n\tint r;\n\n\tcpio = (struct cpio *)(a->format->data);\n\tsconv = cpio->opt_sconv;\n\tif (sconv == NULL) {\n\t\tif (!cpio->init_default_conversion) {\n\t\t\tcpio->sconv_default =\n\t\t\t    archive_string_default_conversion_for_read(\n\t\t\t      &(a->archive));\n\t\t\tcpio->init_default_conversion = 1;\n\t\t}\n\t\tsconv = cpio->sconv_default;\n\t}\n\t\n\tr = (cpio->read_header(a, cpio, entry, &namelength, &name_pad));\n\n\tif (r < ARCHIVE_WARN)\n\t\treturn (r);\n\n\t/* Read name from buffer. */\n\th = __archive_read_ahead(a, namelength + name_pad, NULL);\n\tif (h == NULL)\n\t    return (ARCHIVE_FATAL);\n\tif (archive_entry_copy_pathname_l(entry,\n\t    (const char *)h, namelength, sconv) != 0) {\n\t\tif (errno == ENOMEM) {\n\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t    \"Can't allocate memory for Pathname\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Pathname can't be converted from %s to current locale.\",\n\t\t    archive_string_conversion_charset_name(sconv));\n\t\tr = ARCHIVE_WARN;\n\t}\n\tcpio->entry_offset = 0;\n\n\t__archive_read_consume(a, namelength + name_pad);\n \n \t/* If this is a symlink, read the link contents. */\n \tif (archive_entry_filetype(entry) == AE_IFLNK) {\n\t\tif (cpio->entry_bytes_remaining > 1024 * 1024) {\n\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t    \"Rejecting malformed cpio archive: symlink contents exceed 1 megabyte\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n \t\th = __archive_read_ahead(a,\n \t\t\t(size_t)cpio->entry_bytes_remaining, NULL);\n \t\tif (h == NULL)\n\t\t\treturn (ARCHIVE_FATAL);\n\t\tif (archive_entry_copy_symlink_l(entry, (const char *)h,\n\t\t    (size_t)cpio->entry_bytes_remaining, sconv) != 0) {\n\t\t\tif (errno == ENOMEM) {\n\t\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t\t    \"Can't allocate memory for Linkname\");\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Linkname can't be converted from %s to \"\n\t\t\t    \"current locale.\",\n\t\t\t    archive_string_conversion_charset_name(sconv));\n\t\t\tr = ARCHIVE_WARN;\n\t\t}\n\t\t__archive_read_consume(a, cpio->entry_bytes_remaining);\n\t\tcpio->entry_bytes_remaining = 0;\n\t}\n\n\t/* XXX TODO: If the full mode is 0160200, then this is a Solaris\n\t * ACL description for the following entry.  Read this body\n\t * and parse it as a Solaris-style ACL, then read the next\n\t * header.  XXX */\n\n\t/* Compare name to \"TRAILER!!!\" to test for end-of-archive. */\n\tif (namelength == 11 && strcmp((const char *)h, \"TRAILER!!!\") == 0) {\n\t\t/* TODO: Store file location of start of block. */\n\t\tarchive_clear_error(&a->archive);\n\t\treturn (ARCHIVE_EOF);\n\t}\n\n\t/* Detect and record hardlinks to previously-extracted entries. */\n\tif (record_hardlink(a, cpio, entry) != ARCHIVE_OK) {\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\treturn (r);\n}\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 970,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2017-12183",
    "code_before_change": "ProcXFixesSetCursorName(ClientPtr client)\n{\n    CursorPtr pCursor;\n    char *tchar;\n\n    REQUEST(xXFixesSetCursorNameReq);\n     REQUEST(xXFixesSetCursorNameReq);\n     Atom atom;\n \n    REQUEST_AT_LEAST_SIZE(xXFixesSetCursorNameReq);\n     VERIFY_CURSOR(pCursor, stuff->cursor, client, DixSetAttrAccess);\n     tchar = (char *) &stuff[1];\n     atom = MakeAtom(tchar, stuff->nbytes, TRUE);\n        return BadAlloc;\n\n    pCursor->name = atom;\n    return Success;\n}\n",
    "code_after_change": "ProcXFixesSetCursorName(ClientPtr client)\n{\n    CursorPtr pCursor;\n    char *tchar;\n\n    REQUEST(xXFixesSetCursorNameReq);\n     REQUEST(xXFixesSetCursorNameReq);\n     Atom atom;\n \n    REQUEST_FIXED_SIZE(xXFixesSetCursorNameReq, stuff->nbytes);\n     VERIFY_CURSOR(pCursor, stuff->cursor, client, DixSetAttrAccess);\n     tchar = (char *) &stuff[1];\n     atom = MakeAtom(tchar, stuff->nbytes, TRUE);\n        return BadAlloc;\n\n    pCursor->name = atom;\n    return Success;\n}\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 973,
    "_valid_cwes": [
      "CWE-20"
    ]
  },
  {
    "cve_id": "CVE-2016-2464",
    "code_before_change": "void Cues::Init() const {\n   if (m_cue_points)\n    return;\n \n  assert(m_count == 0);\n  assert(m_preload_count == 0);\n \n   IMkvReader* const pReader = m_pSegment->m_pReader;\n \n const long long stop = m_start + m_size;\n long long pos = m_start;\n\n long cue_points_size = 0;\n\n while (pos < stop) {\n const long long idpos = pos;\n\n \n     long len;\n \n    const long long id = ReadUInt(pReader, pos, len);\n    assert(id >= 0);  // TODO\n    assert((pos + len) <= stop);\n \n     pos += len;  // consume ID\n \n     const long long size = ReadUInt(pReader, pos, len);\n    assert(size >= 0);\n    assert((pos + len) <= stop);\n \n     pos += len;  // consume Size field\n    assert((pos + size) <= stop);\n \n    if (id == 0x3B)  // CuePoint ID\n      PreloadCuePoint(cue_points_size, idpos);\n \n    pos += size;  // consume payload\n    assert(pos <= stop);\n   }\n }\n",
    "code_after_change": "void Cues::Init() const {\nbool Cues::Init() const {\n   if (m_cue_points)\n    return true;\n \n  if (m_count != 0 || m_preload_count != 0)\n    return false;\n \n   IMkvReader* const pReader = m_pSegment->m_pReader;\n \n const long long stop = m_start + m_size;\n long long pos = m_start;\n\n long cue_points_size = 0;\n\n while (pos < stop) {\n const long long idpos = pos;\n\n \n     long len;\n \n    const long long id = ReadID(pReader, pos, len);\n    if (id < 0 || (pos + len) > stop) {\n      return false;\n    }\n \n     pos += len;  // consume ID\n \n     const long long size = ReadUInt(pReader, pos, len);\n    if (size < 0 || (pos + len > stop)) {\n      return false;\n    }\n \n     pos += len;  // consume Size field\n    if (pos + size > stop) {\n      return false;\n    }\n \n    if (id == 0x3B) {  // CuePoint ID\n      if (!PreloadCuePoint(cue_points_size, idpos))\n        return false;\n    }\n \n    pos += size;  // skip payload\n   }\n  return true;\n }\n",
    "cwe": [
      "CWE-20"
    ],
    "id": 992,
    "_valid_cwes": [
      "CWE-20"
    ]
  }
]