[
  {
    "cve_id": "CVE-2019-5796",
    "code_before_change": "void ExtensionsGuestViewMessageFilter::FrameNavigationHelper::FrameDeleted(\n    RenderFrameHost* render_frame_host) {\n  if (render_frame_host->GetFrameTreeNodeId() != frame_tree_node_id_)\n    return;\n  filter_->ResumeAttachOrDestroy(element_instance_id_,\n                                 MSG_ROUTING_NONE /* no plugin frame */);\n}\n",
    "code_after_change": "void ExtensionsGuestViewMessageFilter::FrameNavigationHelper::FrameDeleted(\n",
    "cwe": [
      "CWE-362"
    ],
    "id": 16,
    "_valid_cwes": [
      "CWE-362"
    ]
  },
  {
    "cve_id": "CVE-2017-5061",
    "code_before_change": "void LayerTreeHost::PushPropertiesTo(LayerTreeImpl* tree_impl) {\n  tree_impl->set_needs_full_tree_sync(needs_full_tree_sync_);\n  needs_full_tree_sync_ = false;\n\n  if (hud_layer_.get()) {\n    LayerImpl* hud_impl = tree_impl->LayerById(hud_layer_->id());\n    tree_impl->set_hud_layer(static_cast<HeadsUpDisplayLayerImpl*>(hud_impl));\n  } else {\n    tree_impl->set_hud_layer(nullptr);\n  }\n\n  tree_impl->set_background_color(background_color_);\n  tree_impl->set_has_transparent_background(has_transparent_background_);\n  tree_impl->set_have_scroll_event_handlers(have_scroll_event_handlers_);\n  tree_impl->set_event_listener_properties(\n      EventListenerClass::kTouchStartOrMove,\n      event_listener_properties(EventListenerClass::kTouchStartOrMove));\n  tree_impl->set_event_listener_properties(\n      EventListenerClass::kMouseWheel,\n      event_listener_properties(EventListenerClass::kMouseWheel));\n  tree_impl->set_event_listener_properties(\n      EventListenerClass::kTouchEndOrCancel,\n      event_listener_properties(EventListenerClass::kTouchEndOrCancel));\n\n  if (page_scale_layer_ && inner_viewport_scroll_layer_) {\n    tree_impl->SetViewportLayersFromIds(\n        overscroll_elasticity_layer_ ? overscroll_elasticity_layer_->id()\n                                     : Layer::INVALID_ID,\n        page_scale_layer_->id(), inner_viewport_scroll_layer_->id(),\n        outer_viewport_scroll_layer_ ? outer_viewport_scroll_layer_->id()\n                                     : Layer::INVALID_ID);\n    DCHECK(inner_viewport_scroll_layer_->IsContainerForFixedPositionLayers());\n  } else {\n    tree_impl->ClearViewportLayers();\n  }\n\n  tree_impl->RegisterSelection(selection_);\n\n  bool property_trees_changed_on_active_tree =\n      tree_impl->IsActiveTree() && tree_impl->property_trees()->changed;\n  if (root_layer_ && property_trees_changed_on_active_tree) {\n    if (property_trees_.sequence_number ==\n        tree_impl->property_trees()->sequence_number)\n      tree_impl->property_trees()->PushChangeTrackingTo(&property_trees_);\n    else\n      tree_impl->MoveChangeTrackingToLayers();\n  }\n  tree_impl->SetPropertyTrees(&property_trees_);\n\n  tree_impl->PushPageScaleFromMainThread(\n      page_scale_factor_, min_page_scale_factor_, max_page_scale_factor_);\n\n  tree_impl->set_browser_controls_shrink_blink_size(\n      browser_controls_shrink_blink_size_);\n  tree_impl->set_top_controls_height(top_controls_height_);\n  tree_impl->set_bottom_controls_height(bottom_controls_height_);\n  tree_impl->PushBrowserControlsFromMainThread(top_controls_shown_ratio_);\n  tree_impl->elastic_overscroll()->PushFromMainThread(elastic_overscroll_);\n  if (tree_impl->IsActiveTree())\n    tree_impl->elastic_overscroll()->PushPendingToActive();\n\n  tree_impl->set_painted_device_scale_factor(painted_device_scale_factor_);\n \n   tree_impl->SetDeviceColorSpace(device_color_space_);\n \n   if (pending_page_scale_animation_) {\n     tree_impl->SetPendingPageScaleAnimation(\n         std::move(pending_page_scale_animation_));\n  }\n\n  DCHECK(!tree_impl->ViewportSizeInvalid());\n\n  tree_impl->set_has_ever_been_drawn(false);\n}\n",
    "code_after_change": "void LayerTreeHost::PushPropertiesTo(LayerTreeImpl* tree_impl) {\n  tree_impl->set_needs_full_tree_sync(needs_full_tree_sync_);\n  needs_full_tree_sync_ = false;\n\n  if (hud_layer_.get()) {\n    LayerImpl* hud_impl = tree_impl->LayerById(hud_layer_->id());\n    tree_impl->set_hud_layer(static_cast<HeadsUpDisplayLayerImpl*>(hud_impl));\n  } else {\n    tree_impl->set_hud_layer(nullptr);\n  }\n\n  tree_impl->set_background_color(background_color_);\n  tree_impl->set_has_transparent_background(has_transparent_background_);\n  tree_impl->set_have_scroll_event_handlers(have_scroll_event_handlers_);\n  tree_impl->set_event_listener_properties(\n      EventListenerClass::kTouchStartOrMove,\n      event_listener_properties(EventListenerClass::kTouchStartOrMove));\n  tree_impl->set_event_listener_properties(\n      EventListenerClass::kMouseWheel,\n      event_listener_properties(EventListenerClass::kMouseWheel));\n  tree_impl->set_event_listener_properties(\n      EventListenerClass::kTouchEndOrCancel,\n      event_listener_properties(EventListenerClass::kTouchEndOrCancel));\n\n  if (page_scale_layer_ && inner_viewport_scroll_layer_) {\n    tree_impl->SetViewportLayersFromIds(\n        overscroll_elasticity_layer_ ? overscroll_elasticity_layer_->id()\n                                     : Layer::INVALID_ID,\n        page_scale_layer_->id(), inner_viewport_scroll_layer_->id(),\n        outer_viewport_scroll_layer_ ? outer_viewport_scroll_layer_->id()\n                                     : Layer::INVALID_ID);\n    DCHECK(inner_viewport_scroll_layer_->IsContainerForFixedPositionLayers());\n  } else {\n    tree_impl->ClearViewportLayers();\n  }\n\n  tree_impl->RegisterSelection(selection_);\n\n  bool property_trees_changed_on_active_tree =\n      tree_impl->IsActiveTree() && tree_impl->property_trees()->changed;\n  if (root_layer_ && property_trees_changed_on_active_tree) {\n    if (property_trees_.sequence_number ==\n        tree_impl->property_trees()->sequence_number)\n      tree_impl->property_trees()->PushChangeTrackingTo(&property_trees_);\n    else\n      tree_impl->MoveChangeTrackingToLayers();\n  }\n  tree_impl->SetPropertyTrees(&property_trees_);\n\n  tree_impl->PushPageScaleFromMainThread(\n      page_scale_factor_, min_page_scale_factor_, max_page_scale_factor_);\n\n  tree_impl->set_browser_controls_shrink_blink_size(\n      browser_controls_shrink_blink_size_);\n  tree_impl->set_top_controls_height(top_controls_height_);\n  tree_impl->set_bottom_controls_height(bottom_controls_height_);\n  tree_impl->PushBrowserControlsFromMainThread(top_controls_shown_ratio_);\n  tree_impl->elastic_overscroll()->PushFromMainThread(elastic_overscroll_);\n  if (tree_impl->IsActiveTree())\n    tree_impl->elastic_overscroll()->PushPendingToActive();\n\n  tree_impl->set_painted_device_scale_factor(painted_device_scale_factor_);\n \n   tree_impl->SetDeviceColorSpace(device_color_space_);\n \n  tree_impl->set_content_source_id(content_source_id_);\n\n   if (pending_page_scale_animation_) {\n     tree_impl->SetPendingPageScaleAnimation(\n         std::move(pending_page_scale_animation_));\n  }\n\n  DCHECK(!tree_impl->ViewportSizeInvalid());\n\n  tree_impl->set_has_ever_been_drawn(false);\n}\n",
    "cwe": [
      "CWE-362"
    ],
    "id": 326,
    "_valid_cwes": [
      "CWE-362"
    ]
  },
  {
    "cve_id": "CVE-2012-2880",
    "code_before_change": "void SyncTest::AddOptionalTypesToCommandLine(CommandLine* cl) {\n  if (!cl->HasSwitch(switches::kEnableSyncTabs))\n    cl->AppendSwitch(switches::kEnableSyncTabs);\n}\n",
    "code_after_change": "void SyncTest::AddOptionalTypesToCommandLine(CommandLine* cl) {\n",
    "cwe": [
      "CWE-362"
    ],
    "id": 655,
    "_valid_cwes": [
      "CWE-362"
    ]
  },
  {
    "cve_id": "CVE-2015-5232",
    "code_before_change": "fm_mgr_config_init\n(\n\t\t\t\t\tOUT\tp_fm_config_conx_hdlt\t\t*p_hdl,\n\t\t\t\tIN\t\tint\t\t\t\t\t\t\tinstance,\n\tOPTIONAL\tIN\t\tchar\t\t\t\t\t\t*rem_address,\n\tOPTIONAL\tIN\t\tchar\t\t\t\t\t\t*community\n)\n{\n\tfm_config_conx_hdl      *hdl;\n\tfm_mgr_config_errno_t   res = FM_CONF_OK;\n\n\n\tif ( (hdl = calloc(1,sizeof(fm_config_conx_hdl))) == NULL )\n\t{\n\t\tres = FM_CONF_NO_MEM;\n\t\tgoto cleanup;\n\t}\n\n\thdl->instance = instance;\n\n\t*p_hdl = hdl;\n\n\tif(!rem_address || (strcmp(rem_address,\"localhost\") == 0))\n\t{\n\t\tif ( fm_mgr_config_mgr_connect(hdl, FM_MGR_SM) == FM_CONF_INIT_ERR )\n\t\t{\n\t\t\tres = FM_CONF_INIT_ERR;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif ( fm_mgr_config_mgr_connect(hdl, FM_MGR_PM) == FM_CONF_INIT_ERR )\n\t\t{\n\t\t\tres = FM_CONF_INIT_ERR;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif ( fm_mgr_config_mgr_connect(hdl, FM_MGR_FE) == FM_CONF_INIT_ERR )\n\t\t{\n\t\t\tres = FM_CONF_INIT_ERR;\n\t\t\tgoto cleanup;\n \t\t}\n \t}\n \n\treturn res;\n\tcleanup:\n\tif ( hdl ) {\n\t\tfree(hdl);\n\t\thdl = NULL;\n\t}\n \treturn res;\n }\n",
    "code_after_change": "fm_mgr_config_init\n(\n\t\t\t\t\tOUT\tp_fm_config_conx_hdlt\t\t*p_hdl,\n\t\t\t\tIN\t\tint\t\t\t\t\t\t\tinstance,\n\tOPTIONAL\tIN\t\tchar\t\t\t\t\t\t*rem_address,\n\tOPTIONAL\tIN\t\tchar\t\t\t\t\t\t*community\n)\n{\n\tfm_config_conx_hdl      *hdl;\n\tfm_mgr_config_errno_t   res = FM_CONF_OK;\n\n\n\tif ( (hdl = calloc(1,sizeof(fm_config_conx_hdl))) == NULL )\n\t{\n\t\tres = FM_CONF_NO_MEM;\n\t\tgoto cleanup;\n\t}\n\n\thdl->instance = instance;\n\n\t*p_hdl = hdl;\n\n\tif(!rem_address || (strcmp(rem_address,\"localhost\") == 0))\n\t{\n\t\tif ( fm_mgr_config_mgr_connect(hdl, FM_MGR_SM) == FM_CONF_INIT_ERR )\n\t\t{\n\t\t\tres = FM_CONF_INIT_ERR;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif ( fm_mgr_config_mgr_connect(hdl, FM_MGR_PM) == FM_CONF_INIT_ERR )\n\t\t{\n\t\t\tres = FM_CONF_INIT_ERR;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif ( fm_mgr_config_mgr_connect(hdl, FM_MGR_FE) == FM_CONF_INIT_ERR )\n\t\t{\n\t\t\tres = FM_CONF_INIT_ERR;\n\t\t\tgoto cleanup;\n \t\t}\n \t}\n \ncleanup:\n \treturn res;\n }\n",
    "cwe": [
      "CWE-362"
    ],
    "id": 760,
    "_valid_cwes": [
      "CWE-362"
    ]
  },
  {
    "cve_id": "CVE-2018-6061",
    "code_before_change": "VaapiVideoDecodeAccelerator::VaapiVP8Accelerator::VaapiVP8Accelerator(\n    VaapiVideoDecodeAccelerator* vaapi_dec,\n    VaapiWrapper* vaapi_wrapper)\n     : vaapi_wrapper_(vaapi_wrapper), vaapi_dec_(vaapi_dec) {\n   DCHECK(vaapi_wrapper_);\n   DCHECK(vaapi_dec_);\n }\n",
    "code_after_change": "VaapiVideoDecodeAccelerator::VaapiVP8Accelerator::VaapiVP8Accelerator(\n    VaapiVideoDecodeAccelerator* vaapi_dec,\n    VaapiWrapper* vaapi_wrapper)\n     : vaapi_wrapper_(vaapi_wrapper), vaapi_dec_(vaapi_dec) {\n   DCHECK(vaapi_wrapper_);\n   DCHECK(vaapi_dec_);\n  DETACH_FROM_SEQUENCE(sequence_checker_);\n }\n",
    "cwe": [
      "CWE-362"
    ],
    "id": 829,
    "_valid_cwes": [
      "CWE-362"
    ]
  },
  {
    "cve_id": "CVE-2018-6061",
    "code_before_change": "bool VaapiVideoDecodeAccelerator::VaapiH264Accelerator::SubmitFrameMetadata(\n    const H264SPS* sps,\n    const H264PPS* pps,\n    const H264DPB& dpb,\n    const H264Picture::Vector& ref_pic_listp0,\n     const H264Picture::Vector& ref_pic_listb0,\n     const H264Picture::Vector& ref_pic_listb1,\n     const scoped_refptr<H264Picture>& pic) {\n   VAPictureParameterBufferH264 pic_param;\n   memset(&pic_param, 0, sizeof(pic_param));\n \n#define FROM_SPS_TO_PP(a) pic_param.a = sps->a\n#define FROM_SPS_TO_PP2(a, b) pic_param.b = sps->a\n  FROM_SPS_TO_PP2(pic_width_in_mbs_minus1, picture_width_in_mbs_minus1);\n  FROM_SPS_TO_PP2(pic_height_in_map_units_minus1, picture_height_in_mbs_minus1);\n  FROM_SPS_TO_PP(bit_depth_luma_minus8);\n  FROM_SPS_TO_PP(bit_depth_chroma_minus8);\n#undef FROM_SPS_TO_PP\n#undef FROM_SPS_TO_PP2\n\n#define FROM_SPS_TO_PP_SF(a) pic_param.seq_fields.bits.a = sps->a\n#define FROM_SPS_TO_PP_SF2(a, b) pic_param.seq_fields.bits.b = sps->a\n  FROM_SPS_TO_PP_SF(chroma_format_idc);\n  FROM_SPS_TO_PP_SF2(separate_colour_plane_flag,\n                     residual_colour_transform_flag);\n  FROM_SPS_TO_PP_SF(gaps_in_frame_num_value_allowed_flag);\n  FROM_SPS_TO_PP_SF(frame_mbs_only_flag);\n  FROM_SPS_TO_PP_SF(mb_adaptive_frame_field_flag);\n  FROM_SPS_TO_PP_SF(direct_8x8_inference_flag);\n  pic_param.seq_fields.bits.MinLumaBiPredSize8x8 = (sps->level_idc >= 31);\n  FROM_SPS_TO_PP_SF(log2_max_frame_num_minus4);\n  FROM_SPS_TO_PP_SF(pic_order_cnt_type);\n  FROM_SPS_TO_PP_SF(log2_max_pic_order_cnt_lsb_minus4);\n  FROM_SPS_TO_PP_SF(delta_pic_order_always_zero_flag);\n#undef FROM_SPS_TO_PP_SF\n#undef FROM_SPS_TO_PP_SF2\n\n#define FROM_PPS_TO_PP(a) pic_param.a = pps->a\n  FROM_PPS_TO_PP(pic_init_qp_minus26);\n  FROM_PPS_TO_PP(pic_init_qs_minus26);\n  FROM_PPS_TO_PP(chroma_qp_index_offset);\n  FROM_PPS_TO_PP(second_chroma_qp_index_offset);\n#undef FROM_PPS_TO_PP\n\n#define FROM_PPS_TO_PP_PF(a) pic_param.pic_fields.bits.a = pps->a\n#define FROM_PPS_TO_PP_PF2(a, b) pic_param.pic_fields.bits.b = pps->a\n  FROM_PPS_TO_PP_PF(entropy_coding_mode_flag);\n  FROM_PPS_TO_PP_PF(weighted_pred_flag);\n  FROM_PPS_TO_PP_PF(weighted_bipred_idc);\n  FROM_PPS_TO_PP_PF(transform_8x8_mode_flag);\n\n  pic_param.pic_fields.bits.field_pic_flag = 0;\n  FROM_PPS_TO_PP_PF(constrained_intra_pred_flag);\n  FROM_PPS_TO_PP_PF2(bottom_field_pic_order_in_frame_present_flag,\n                     pic_order_present_flag);\n  FROM_PPS_TO_PP_PF(deblocking_filter_control_present_flag);\n  FROM_PPS_TO_PP_PF(redundant_pic_cnt_present_flag);\n  pic_param.pic_fields.bits.reference_pic_flag = pic->ref;\n#undef FROM_PPS_TO_PP_PF\n#undef FROM_PPS_TO_PP_PF2\n\n  pic_param.frame_num = pic->frame_num;\n\n  InitVAPicture(&pic_param.CurrPic);\n  FillVAPicture(&pic_param.CurrPic, pic);\n\n  for (int i = 0; i < 16; ++i)\n    InitVAPicture(&pic_param.ReferenceFrames[i]);\n\n  FillVARefFramesFromDPB(dpb, pic_param.ReferenceFrames,\n                         arraysize(pic_param.ReferenceFrames));\n\n  pic_param.num_ref_frames = sps->max_num_ref_frames;\n\n  if (!vaapi_wrapper_->SubmitBuffer(VAPictureParameterBufferType,\n                                    sizeof(pic_param), &pic_param))\n    return false;\n\n  VAIQMatrixBufferH264 iq_matrix_buf;\n  memset(&iq_matrix_buf, 0, sizeof(iq_matrix_buf));\n\n  if (pps->pic_scaling_matrix_present_flag) {\n    for (int i = 0; i < 6; ++i) {\n      for (int j = 0; j < 16; ++j)\n        iq_matrix_buf.ScalingList4x4[i][kZigzagScan4x4[j]] =\n            pps->scaling_list4x4[i][j];\n    }\n\n    for (int i = 0; i < 2; ++i) {\n      for (int j = 0; j < 64; ++j)\n        iq_matrix_buf.ScalingList8x8[i][kZigzagScan8x8[j]] =\n            pps->scaling_list8x8[i][j];\n    }\n  } else {\n    for (int i = 0; i < 6; ++i) {\n      for (int j = 0; j < 16; ++j)\n        iq_matrix_buf.ScalingList4x4[i][kZigzagScan4x4[j]] =\n            sps->scaling_list4x4[i][j];\n    }\n\n    for (int i = 0; i < 2; ++i) {\n      for (int j = 0; j < 64; ++j)\n        iq_matrix_buf.ScalingList8x8[i][kZigzagScan8x8[j]] =\n            sps->scaling_list8x8[i][j];\n    }\n  }\n\n  return vaapi_wrapper_->SubmitBuffer(VAIQMatrixBufferType,\n                                      sizeof(iq_matrix_buf), &iq_matrix_buf);\n}\n",
    "code_after_change": "bool VaapiVideoDecodeAccelerator::VaapiH264Accelerator::SubmitFrameMetadata(\n    const H264SPS* sps,\n    const H264PPS* pps,\n    const H264DPB& dpb,\n    const H264Picture::Vector& ref_pic_listp0,\n     const H264Picture::Vector& ref_pic_listb0,\n     const H264Picture::Vector& ref_pic_listb1,\n     const scoped_refptr<H264Picture>& pic) {\n  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);\n   VAPictureParameterBufferH264 pic_param;\n   memset(&pic_param, 0, sizeof(pic_param));\n \n#define FROM_SPS_TO_PP(a) pic_param.a = sps->a\n#define FROM_SPS_TO_PP2(a, b) pic_param.b = sps->a\n  FROM_SPS_TO_PP2(pic_width_in_mbs_minus1, picture_width_in_mbs_minus1);\n  FROM_SPS_TO_PP2(pic_height_in_map_units_minus1, picture_height_in_mbs_minus1);\n  FROM_SPS_TO_PP(bit_depth_luma_minus8);\n  FROM_SPS_TO_PP(bit_depth_chroma_minus8);\n#undef FROM_SPS_TO_PP\n#undef FROM_SPS_TO_PP2\n\n#define FROM_SPS_TO_PP_SF(a) pic_param.seq_fields.bits.a = sps->a\n#define FROM_SPS_TO_PP_SF2(a, b) pic_param.seq_fields.bits.b = sps->a\n  FROM_SPS_TO_PP_SF(chroma_format_idc);\n  FROM_SPS_TO_PP_SF2(separate_colour_plane_flag,\n                     residual_colour_transform_flag);\n  FROM_SPS_TO_PP_SF(gaps_in_frame_num_value_allowed_flag);\n  FROM_SPS_TO_PP_SF(frame_mbs_only_flag);\n  FROM_SPS_TO_PP_SF(mb_adaptive_frame_field_flag);\n  FROM_SPS_TO_PP_SF(direct_8x8_inference_flag);\n  pic_param.seq_fields.bits.MinLumaBiPredSize8x8 = (sps->level_idc >= 31);\n  FROM_SPS_TO_PP_SF(log2_max_frame_num_minus4);\n  FROM_SPS_TO_PP_SF(pic_order_cnt_type);\n  FROM_SPS_TO_PP_SF(log2_max_pic_order_cnt_lsb_minus4);\n  FROM_SPS_TO_PP_SF(delta_pic_order_always_zero_flag);\n#undef FROM_SPS_TO_PP_SF\n#undef FROM_SPS_TO_PP_SF2\n\n#define FROM_PPS_TO_PP(a) pic_param.a = pps->a\n  FROM_PPS_TO_PP(pic_init_qp_minus26);\n  FROM_PPS_TO_PP(pic_init_qs_minus26);\n  FROM_PPS_TO_PP(chroma_qp_index_offset);\n  FROM_PPS_TO_PP(second_chroma_qp_index_offset);\n#undef FROM_PPS_TO_PP\n\n#define FROM_PPS_TO_PP_PF(a) pic_param.pic_fields.bits.a = pps->a\n#define FROM_PPS_TO_PP_PF2(a, b) pic_param.pic_fields.bits.b = pps->a\n  FROM_PPS_TO_PP_PF(entropy_coding_mode_flag);\n  FROM_PPS_TO_PP_PF(weighted_pred_flag);\n  FROM_PPS_TO_PP_PF(weighted_bipred_idc);\n  FROM_PPS_TO_PP_PF(transform_8x8_mode_flag);\n\n  pic_param.pic_fields.bits.field_pic_flag = 0;\n  FROM_PPS_TO_PP_PF(constrained_intra_pred_flag);\n  FROM_PPS_TO_PP_PF2(bottom_field_pic_order_in_frame_present_flag,\n                     pic_order_present_flag);\n  FROM_PPS_TO_PP_PF(deblocking_filter_control_present_flag);\n  FROM_PPS_TO_PP_PF(redundant_pic_cnt_present_flag);\n  pic_param.pic_fields.bits.reference_pic_flag = pic->ref;\n#undef FROM_PPS_TO_PP_PF\n#undef FROM_PPS_TO_PP_PF2\n\n  pic_param.frame_num = pic->frame_num;\n\n  InitVAPicture(&pic_param.CurrPic);\n  FillVAPicture(&pic_param.CurrPic, pic);\n\n  for (int i = 0; i < 16; ++i)\n    InitVAPicture(&pic_param.ReferenceFrames[i]);\n\n  FillVARefFramesFromDPB(dpb, pic_param.ReferenceFrames,\n                         arraysize(pic_param.ReferenceFrames));\n\n  pic_param.num_ref_frames = sps->max_num_ref_frames;\n\n  if (!vaapi_wrapper_->SubmitBuffer(VAPictureParameterBufferType,\n                                    sizeof(pic_param), &pic_param))\n    return false;\n\n  VAIQMatrixBufferH264 iq_matrix_buf;\n  memset(&iq_matrix_buf, 0, sizeof(iq_matrix_buf));\n\n  if (pps->pic_scaling_matrix_present_flag) {\n    for (int i = 0; i < 6; ++i) {\n      for (int j = 0; j < 16; ++j)\n        iq_matrix_buf.ScalingList4x4[i][kZigzagScan4x4[j]] =\n            pps->scaling_list4x4[i][j];\n    }\n\n    for (int i = 0; i < 2; ++i) {\n      for (int j = 0; j < 64; ++j)\n        iq_matrix_buf.ScalingList8x8[i][kZigzagScan8x8[j]] =\n            pps->scaling_list8x8[i][j];\n    }\n  } else {\n    for (int i = 0; i < 6; ++i) {\n      for (int j = 0; j < 16; ++j)\n        iq_matrix_buf.ScalingList4x4[i][kZigzagScan4x4[j]] =\n            sps->scaling_list4x4[i][j];\n    }\n\n    for (int i = 0; i < 2; ++i) {\n      for (int j = 0; j < 64; ++j)\n        iq_matrix_buf.ScalingList8x8[i][kZigzagScan8x8[j]] =\n            sps->scaling_list8x8[i][j];\n    }\n  }\n\n  return vaapi_wrapper_->SubmitBuffer(VAIQMatrixBufferType,\n                                      sizeof(iq_matrix_buf), &iq_matrix_buf);\n}\n",
    "cwe": [
      "CWE-362"
    ],
    "id": 869,
    "_valid_cwes": [
      "CWE-362"
    ]
  },
  {
    "cve_id": "CVE-2018-6061",
    "code_before_change": " VaapiVideoDecodeAccelerator::VaapiVP8Accelerator::CreateVP8Picture() {\n   scoped_refptr<VaapiDecodeSurface> va_surface = vaapi_dec_->CreateSurface();\n   if (!va_surface)\n     return nullptr;\n\n  return new VaapiVP8Picture(std::move(va_surface));\n}\n",
    "code_after_change": " VaapiVideoDecodeAccelerator::VaapiVP8Accelerator::CreateVP8Picture() {\n  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);\n   scoped_refptr<VaapiDecodeSurface> va_surface = vaapi_dec_->CreateSurface();\n   if (!va_surface)\n     return nullptr;\n\n  return new VaapiVP8Picture(std::move(va_surface));\n}\n",
    "cwe": [
      "CWE-362"
    ],
    "id": 942,
    "_valid_cwes": [
      "CWE-362"
    ]
  },
  {
    "cve_id": "CVE-2019-5796",
    "code_before_change": " ExtensionsGuestViewMessageFilter::~ExtensionsGuestViewMessageFilter() {\n   DCHECK_CURRENTLY_ON(BrowserThread::IO);\n  (*GetProcessIdToFilterMap())[render_process_id_] = nullptr;\n  base::PostTaskWithTraits(\n      FROM_HERE, BrowserThread::UI,\n      base::BindOnce(RemoveProcessIdFromGlobalMap, render_process_id_));\n }\n",
    "code_after_change": " ExtensionsGuestViewMessageFilter::~ExtensionsGuestViewMessageFilter() {\n   DCHECK_CURRENTLY_ON(BrowserThread::IO);\n }\n",
    "cwe": [
      "CWE-362"
    ],
    "id": 964,
    "_valid_cwes": [
      "CWE-362"
    ]
  }
]