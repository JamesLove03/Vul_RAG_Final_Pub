[
  {
    "cve_id": "CVE-2017-2633",
    "code_before_change": "tight_detect_smooth_image24(VncState *vs, int w, int h)\n{\n    int off;\n    int x, y, d, dx;\n    unsigned int c;\n    unsigned int stats[256];\n    int pixels = 0;\n    int pix, left[3];\n    unsigned int errors;\n    unsigned char *buf = vs->tight.tight.buffer;\n\n    /*\n      * If client is big-endian, color samples begin from the second\n      * byte (offset 1) of a 32-bit pixel value.\n      */\n    off = !!(vs->clientds.flags & QEMU_BIG_ENDIAN_FLAG);\n \n     memset(stats, 0, sizeof (stats));\n \n    for (y = 0, x = 0; y < h && x < w;) {\n        for (d = 0; d < h - y && d < w - x - VNC_TIGHT_DETECT_SUBROW_WIDTH;\n             d++) {\n            for (c = 0; c < 3; c++) {\n                left[c] = buf[((y+d)*w+x+d)*4+off+c] & 0xFF;\n            }\n            for (dx = 1; dx <= VNC_TIGHT_DETECT_SUBROW_WIDTH; dx++) {\n                for (c = 0; c < 3; c++) {\n                    pix = buf[((y+d)*w+x+d+dx)*4+off+c] & 0xFF;\n                    stats[abs(pix - left[c])]++;\n                    left[c] = pix;\n                }\n                pixels++;\n            }\n        }\n        if (w > h) {\n            x += h;\n            y = 0;\n        } else {\n            x = 0;\n            y += w;\n        }\n    }\n\n    /* 95% smooth or more ... */\n    if (stats[0] * 33 / pixels >= 95) {\n        return 0;\n    }\n\n    errors = 0;\n    for (c = 1; c < 8; c++) {\n        errors += stats[c] * (c * c);\n        if (stats[c] == 0 || stats[c] > stats[c-1] * 2) {\n            return 0;\n        }\n    }\n    for (; c < 256; c++) {\n        errors += stats[c] * (c * c);\n    }\n    errors /= (pixels * 3 - stats[0]);\n\n    return errors;\n}\n",
    "code_after_change": "tight_detect_smooth_image24(VncState *vs, int w, int h)\n{\n    int off;\n    int x, y, d, dx;\n    unsigned int c;\n    unsigned int stats[256];\n    int pixels = 0;\n    int pix, left[3];\n    unsigned int errors;\n    unsigned char *buf = vs->tight.tight.buffer;\n\n    /*\n      * If client is big-endian, color samples begin from the second\n      * byte (offset 1) of a 32-bit pixel value.\n      */\n    off = vs->client_be;\n \n     memset(stats, 0, sizeof (stats));\n \n    for (y = 0, x = 0; y < h && x < w;) {\n        for (d = 0; d < h - y && d < w - x - VNC_TIGHT_DETECT_SUBROW_WIDTH;\n             d++) {\n            for (c = 0; c < 3; c++) {\n                left[c] = buf[((y+d)*w+x+d)*4+off+c] & 0xFF;\n            }\n            for (dx = 1; dx <= VNC_TIGHT_DETECT_SUBROW_WIDTH; dx++) {\n                for (c = 0; c < 3; c++) {\n                    pix = buf[((y+d)*w+x+d+dx)*4+off+c] & 0xFF;\n                    stats[abs(pix - left[c])]++;\n                    left[c] = pix;\n                }\n                pixels++;\n            }\n        }\n        if (w > h) {\n            x += h;\n            y = 0;\n        } else {\n            x = 0;\n            y += w;\n        }\n    }\n\n    /* 95% smooth or more ... */\n    if (stats[0] * 33 / pixels >= 95) {\n        return 0;\n    }\n\n    errors = 0;\n    for (c = 1; c < 8; c++) {\n        errors += stats[c] * (c * c);\n        if (stats[c] == 0 || stats[c] > stats[c-1] * 2) {\n            return 0;\n        }\n    }\n    for (; c < 256; c++) {\n        errors += stats[c] * (c * c);\n    }\n    errors /= (pixels * 3 - stats[0]);\n\n    return errors;\n}\n",
    "cwe": [
      "CWE-125"
    ],
    "id": 19,
    "_valid_cwes": [
      "CWE-125"
    ]
  },
  {
    "cve_id": "CVE-2018-13006",
    "code_before_change": "static void oinf_entry_dump(GF_OperatingPointsInformation *ptr, FILE * trace)\n{\n\tu32 i, count;\n\n\tif (!ptr) {\n\t\tfprintf(trace, \"<OperatingPointsInformation scalability_mask=\\\"Multiview|Spatial scalability|Auxilary|unknown\\\" num_profile_tier_level=\\\"\\\" num_operating_points=\\\"\\\" dependency_layers=\\\"\\\">\\n\");\n\n\t\tfprintf(trace, \" <ProfileTierLevel general_profile_space=\\\"\\\" general_tier_flag=\\\"\\\" general_profile_idc=\\\"\\\" general_profile_compatibility_flags=\\\"\\\" general_constraint_indicator_flags=\\\"\\\" />\\n\");\n\n\t\tfprintf(trace, \"<OperatingPoint output_layer_set_idx=\\\"\\\" max_temporal_id=\\\"\\\" layer_count=\\\"\\\" minPicWidth=\\\"\\\" minPicHeight=\\\"\\\" maxPicWidth=\\\"\\\" maxPicHeight=\\\"\\\" maxChromaFormat=\\\"\\\" maxBitDepth=\\\"\\\" frame_rate_info_flag=\\\"\\\" bit_rate_info_flag=\\\"\\\" avgFrameRate=\\\"\\\" constantFrameRate=\\\"\\\" maxBitRate=\\\"\\\" avgBitRate=\\\"\\\"/>\\n\");\n\n\t\tfprintf(trace, \"<Layer dependent_layerID=\\\"\\\" num_layers_dependent_on=\\\"\\\" dependent_on_layerID=\\\"\\\" dimension_identifier=\\\"\\\"/>\\n\");\n\t\tfprintf(trace, \"</OperatingPointsInformation>\\n\");\n\t\treturn;\n\t}\n\n\n\tfprintf(trace, \"<OperatingPointsInformation\");\n\tfprintf(trace, \" scalability_mask=\\\"%u (\", ptr->scalability_mask);\n\tswitch (ptr->scalability_mask) {\n\tcase 2:\n\t\tfprintf(trace, \"Multiview\");\n\t\tbreak;\n\tcase 4:\n\t\tfprintf(trace, \"Spatial scalability\");\n\t\tbreak;\n\tcase 8:\n\t\tfprintf(trace, \"Auxilary\");\n\t\tbreak;\n\tdefault:\n\t\tfprintf(trace, \"unknown\");\n\t}\n\tfprintf(trace, \")\\\" num_profile_tier_level=\\\"%u\\\"\", gf_list_count(ptr->profile_tier_levels) );\n\tfprintf(trace, \" num_operating_points=\\\"%u\\\" dependency_layers=\\\"%u\\\"\", gf_list_count(ptr->operating_points), gf_list_count(ptr->dependency_layers));\n\tfprintf(trace, \">\\n\");\n\n\n\tcount=gf_list_count(ptr->profile_tier_levels);\n\tfor (i = 0; i < count; i++) {\n\t\tLHEVC_ProfileTierLevel *ptl = (LHEVC_ProfileTierLevel *)gf_list_get(ptr->profile_tier_levels, i);\n\t\tfprintf(trace, \" <ProfileTierLevel general_profile_space=\\\"%u\\\" general_tier_flag=\\\"%u\\\" general_profile_idc=\\\"%u\\\" general_profile_compatibility_flags=\\\"%X\\\" general_constraint_indicator_flags=\\\"\"LLX\"\\\" />\\n\", ptl->general_profile_space, ptl->general_tier_flag, ptl->general_profile_idc, ptl->general_profile_compatibility_flags, ptl->general_constraint_indicator_flags);\n\t}\n\n\n\tcount=gf_list_count(ptr->operating_points);\n\tfor (i = 0; i < count; i++) {\n\t\tLHEVC_OperatingPoint *op = (LHEVC_OperatingPoint *)gf_list_get(ptr->operating_points, i);\n\t\tfprintf(trace, \"<OperatingPoint output_layer_set_idx=\\\"%u\\\"\", op->output_layer_set_idx);\n\t\tfprintf(trace, \" max_temporal_id=\\\"%u\\\" layer_count=\\\"%u\\\"\", op->max_temporal_id, op->layer_count);\n\t\tfprintf(trace, \" minPicWidth=\\\"%u\\\" minPicHeight=\\\"%u\\\"\", op->minPicWidth, op->minPicHeight);\n \t\tfprintf(trace, \" maxPicWidth=\\\"%u\\\" maxPicHeight=\\\"%u\\\"\", op->maxPicWidth, op->maxPicHeight);\n \t\tfprintf(trace, \" maxChromaFormat=\\\"%u\\\" maxBitDepth=\\\"%u\\\"\", op->maxChromaFormat, op->maxBitDepth);\n \t\tfprintf(trace, \" frame_rate_info_flag=\\\"%u\\\" bit_rate_info_flag=\\\"%u\\\"\", op->frame_rate_info_flag, op->bit_rate_info_flag);\n\t\tif (op->frame_rate_info_flag) \n \t\t\tfprintf(trace, \" avgFrameRate=\\\"%u\\\" constantFrameRate=\\\"%u\\\"\", op->avgFrameRate, op->constantFrameRate);\n\t\tif (op->bit_rate_info_flag) \n \t\t\tfprintf(trace, \" maxBitRate=\\\"%u\\\" avgBitRate=\\\"%u\\\"\", op->maxBitRate, op->avgBitRate);\n \t\tfprintf(trace, \"/>\\n\");\n \t}\n\tcount=gf_list_count(ptr->dependency_layers);\n\tfor (i = 0; i < count; i++) {\n\t\tu32 j;\n\t\tLHEVC_DependentLayer *dep = (LHEVC_DependentLayer *)gf_list_get(ptr->dependency_layers, i);\n\t\tfprintf(trace, \"<Layer dependent_layerID=\\\"%u\\\" num_layers_dependent_on=\\\"%u\\\"\", dep->dependent_layerID, dep->num_layers_dependent_on);\n\t\tif (dep->num_layers_dependent_on) {\n\t\t\tfprintf(trace, \" dependent_on_layerID=\\\"\");\n\t\t\tfor (j = 0; j < dep->num_layers_dependent_on; j++)\n\t\t\t\tfprintf(trace, \"%d \", dep->dependent_on_layerID[j]);\n\t\t\tfprintf(trace, \"\\\"\");\n\t\t}\n\t\tfprintf(trace, \" dimension_identifier=\\\"\");\n\t\tfor (j = 0; j < 16; j++)\n\t\t\tif (ptr->scalability_mask & (1 << j))\n\t\t\t\tfprintf(trace, \"%d \", dep->dimension_identifier[j]);\n\t\tfprintf(trace, \"\\\"/>\\n\");\n\t}\n\tfprintf(trace, \"</OperatingPointsInformation>\\n\");\n\treturn;\n}\n",
    "code_after_change": "static void oinf_entry_dump(GF_OperatingPointsInformation *ptr, FILE * trace)\n{\n\tu32 i, count;\n\n\tif (!ptr) {\n\t\tfprintf(trace, \"<OperatingPointsInformation scalability_mask=\\\"Multiview|Spatial scalability|Auxilary|unknown\\\" num_profile_tier_level=\\\"\\\" num_operating_points=\\\"\\\" dependency_layers=\\\"\\\">\\n\");\n\n\t\tfprintf(trace, \" <ProfileTierLevel general_profile_space=\\\"\\\" general_tier_flag=\\\"\\\" general_profile_idc=\\\"\\\" general_profile_compatibility_flags=\\\"\\\" general_constraint_indicator_flags=\\\"\\\" />\\n\");\n\n\t\tfprintf(trace, \"<OperatingPoint output_layer_set_idx=\\\"\\\" max_temporal_id=\\\"\\\" layer_count=\\\"\\\" minPicWidth=\\\"\\\" minPicHeight=\\\"\\\" maxPicWidth=\\\"\\\" maxPicHeight=\\\"\\\" maxChromaFormat=\\\"\\\" maxBitDepth=\\\"\\\" frame_rate_info_flag=\\\"\\\" bit_rate_info_flag=\\\"\\\" avgFrameRate=\\\"\\\" constantFrameRate=\\\"\\\" maxBitRate=\\\"\\\" avgBitRate=\\\"\\\"/>\\n\");\n\n\t\tfprintf(trace, \"<Layer dependent_layerID=\\\"\\\" num_layers_dependent_on=\\\"\\\" dependent_on_layerID=\\\"\\\" dimension_identifier=\\\"\\\"/>\\n\");\n\t\tfprintf(trace, \"</OperatingPointsInformation>\\n\");\n\t\treturn;\n\t}\n\n\n\tfprintf(trace, \"<OperatingPointsInformation\");\n\tfprintf(trace, \" scalability_mask=\\\"%u (\", ptr->scalability_mask);\n\tswitch (ptr->scalability_mask) {\n\tcase 2:\n\t\tfprintf(trace, \"Multiview\");\n\t\tbreak;\n\tcase 4:\n\t\tfprintf(trace, \"Spatial scalability\");\n\t\tbreak;\n\tcase 8:\n\t\tfprintf(trace, \"Auxilary\");\n\t\tbreak;\n\tdefault:\n\t\tfprintf(trace, \"unknown\");\n\t}\n\tfprintf(trace, \")\\\" num_profile_tier_level=\\\"%u\\\"\", gf_list_count(ptr->profile_tier_levels) );\n\tfprintf(trace, \" num_operating_points=\\\"%u\\\" dependency_layers=\\\"%u\\\"\", gf_list_count(ptr->operating_points), gf_list_count(ptr->dependency_layers));\n\tfprintf(trace, \">\\n\");\n\n\n\tcount=gf_list_count(ptr->profile_tier_levels);\n\tfor (i = 0; i < count; i++) {\n\t\tLHEVC_ProfileTierLevel *ptl = (LHEVC_ProfileTierLevel *)gf_list_get(ptr->profile_tier_levels, i);\n\t\tfprintf(trace, \" <ProfileTierLevel general_profile_space=\\\"%u\\\" general_tier_flag=\\\"%u\\\" general_profile_idc=\\\"%u\\\" general_profile_compatibility_flags=\\\"%X\\\" general_constraint_indicator_flags=\\\"\"LLX\"\\\" />\\n\", ptl->general_profile_space, ptl->general_tier_flag, ptl->general_profile_idc, ptl->general_profile_compatibility_flags, ptl->general_constraint_indicator_flags);\n\t}\n\n\n\tcount=gf_list_count(ptr->operating_points);\n\tfor (i = 0; i < count; i++) {\n\t\tLHEVC_OperatingPoint *op = (LHEVC_OperatingPoint *)gf_list_get(ptr->operating_points, i);\n\t\tfprintf(trace, \"<OperatingPoint output_layer_set_idx=\\\"%u\\\"\", op->output_layer_set_idx);\n\t\tfprintf(trace, \" max_temporal_id=\\\"%u\\\" layer_count=\\\"%u\\\"\", op->max_temporal_id, op->layer_count);\n\t\tfprintf(trace, \" minPicWidth=\\\"%u\\\" minPicHeight=\\\"%u\\\"\", op->minPicWidth, op->minPicHeight);\n \t\tfprintf(trace, \" maxPicWidth=\\\"%u\\\" maxPicHeight=\\\"%u\\\"\", op->maxPicWidth, op->maxPicHeight);\n \t\tfprintf(trace, \" maxChromaFormat=\\\"%u\\\" maxBitDepth=\\\"%u\\\"\", op->maxChromaFormat, op->maxBitDepth);\n \t\tfprintf(trace, \" frame_rate_info_flag=\\\"%u\\\" bit_rate_info_flag=\\\"%u\\\"\", op->frame_rate_info_flag, op->bit_rate_info_flag);\n\t\tif (op->frame_rate_info_flag)\n \t\t\tfprintf(trace, \" avgFrameRate=\\\"%u\\\" constantFrameRate=\\\"%u\\\"\", op->avgFrameRate, op->constantFrameRate);\n\t\tif (op->bit_rate_info_flag)\n \t\t\tfprintf(trace, \" maxBitRate=\\\"%u\\\" avgBitRate=\\\"%u\\\"\", op->maxBitRate, op->avgBitRate);\n \t\tfprintf(trace, \"/>\\n\");\n \t}\n\tcount=gf_list_count(ptr->dependency_layers);\n\tfor (i = 0; i < count; i++) {\n\t\tu32 j;\n\t\tLHEVC_DependentLayer *dep = (LHEVC_DependentLayer *)gf_list_get(ptr->dependency_layers, i);\n\t\tfprintf(trace, \"<Layer dependent_layerID=\\\"%u\\\" num_layers_dependent_on=\\\"%u\\\"\", dep->dependent_layerID, dep->num_layers_dependent_on);\n\t\tif (dep->num_layers_dependent_on) {\n\t\t\tfprintf(trace, \" dependent_on_layerID=\\\"\");\n\t\t\tfor (j = 0; j < dep->num_layers_dependent_on; j++)\n\t\t\t\tfprintf(trace, \"%d \", dep->dependent_on_layerID[j]);\n\t\t\tfprintf(trace, \"\\\"\");\n\t\t}\n\t\tfprintf(trace, \" dimension_identifier=\\\"\");\n\t\tfor (j = 0; j < 16; j++)\n\t\t\tif (ptr->scalability_mask & (1 << j))\n\t\t\t\tfprintf(trace, \"%d \", dep->dimension_identifier[j]);\n\t\tfprintf(trace, \"\\\"/>\\n\");\n\t}\n\tfprintf(trace, \"</OperatingPointsInformation>\\n\");\n\treturn;\n}\n",
    "cwe": [
      "CWE-125"
    ],
    "id": 26,
    "_valid_cwes": [
      "CWE-125"
    ]
  },
  {
    "cve_id": "CVE-2017-13052",
    "code_before_change": " cfm_network_addr_print(netdissect_options *ndo,\n                       register const u_char *tptr)\n {\n     u_int network_addr_type;\n     u_int hexdump =  FALSE;\n\n    /*\n     * Altough AFIs are tpically 2 octects wide,\n      * 802.1ab specifies that this field width\n      * is only once octet\n      */\n     network_addr_type = *tptr;\n     ND_PRINT((ndo, \"\\n\\t  Network Address Type %s (%u)\",\n            tok2str(af_values, \"Unknown\", network_addr_type),\n           network_addr_type));\n\n    /*\n     * Resolve the passed in Address.\n      */\n     switch(network_addr_type) {\n     case AFNUM_INET:\n         ND_PRINT((ndo, \", %s\", ipaddr_string(ndo, tptr + 1)));\n         break;\n \n     case AFNUM_INET6:\n         ND_PRINT((ndo, \", %s\", ip6addr_string(ndo, tptr + 1)));\n         break;\n \n    default:\n        hexdump = TRUE;\n        break;\n    }\n\n    return hexdump;\n}\n",
    "code_after_change": " cfm_network_addr_print(netdissect_options *ndo,\n                       register const u_char *tptr, const u_int length)\n {\n     u_int network_addr_type;\n     u_int hexdump =  FALSE;\n\n    /*\n     * Altough AFIs are tpically 2 octects wide,\n      * 802.1ab specifies that this field width\n      * is only once octet\n      */\n    if (length < 1) {\n        ND_PRINT((ndo, \"\\n\\t  Network Address Type (invalid, no data\"));\n        return hexdump;\n    }\n    /* The calling function must make any due ND_TCHECK calls. */\n     network_addr_type = *tptr;\n     ND_PRINT((ndo, \"\\n\\t  Network Address Type %s (%u)\",\n            tok2str(af_values, \"Unknown\", network_addr_type),\n           network_addr_type));\n\n    /*\n     * Resolve the passed in Address.\n      */\n     switch(network_addr_type) {\n     case AFNUM_INET:\n        if (length != 1 + 4) {\n            ND_PRINT((ndo, \"(invalid IPv4 address length %u)\", length - 1));\n            hexdump = TRUE;\n            break;\n        }\n         ND_PRINT((ndo, \", %s\", ipaddr_string(ndo, tptr + 1)));\n         break;\n \n     case AFNUM_INET6:\n        if (length != 1 + 16) {\n            ND_PRINT((ndo, \"(invalid IPv6 address length %u)\", length - 1));\n            hexdump = TRUE;\n            break;\n        }\n         ND_PRINT((ndo, \", %s\", ip6addr_string(ndo, tptr + 1)));\n         break;\n \n    default:\n        hexdump = TRUE;\n        break;\n    }\n\n    return hexdump;\n}\n",
    "cwe": [
      "CWE-125"
    ],
    "id": 36,
    "_valid_cwes": [
      "CWE-125"
    ]
  },
  {
    "cve_id": "CVE-2017-5923",
    "code_before_change": "yyparse (void *yyscanner, YR_COMPILER* compiler)\n{\n/* The lookahead symbol.  */\nint yychar;\n\n\n/* The semantic value of the lookahead symbol.  */\n/* Default value used for initialization, for pacifying older GCCs\n   or non-GCC compilers.  */\nYY_INITIAL_VALUE (static YYSTYPE yyval_default;)\nYYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n\n    /* Number of syntax errors so far.  */\n    int yynerrs;\n\n    int yystate;\n    /* Number of tokens to shift before error messages enabled.  */\n    int yyerrstatus;\n\n    /* The stacks and their tools:\n       'yyss': related to states.\n       'yyvs': related to semantic values.\n\n       Refer to the stacks through separate pointers, to allow yyoverflow\n       to reallocate them elsewhere.  */\n\n    /* The state stack.  */\n    yytype_int16 yyssa[YYINITDEPTH];\n    yytype_int16 *yyss;\n    yytype_int16 *yyssp;\n\n    /* The semantic value stack.  */\n    YYSTYPE yyvsa[YYINITDEPTH];\n    YYSTYPE *yyvs;\n    YYSTYPE *yyvsp;\n\n    YYSIZE_T yystacksize;\n\n  int yyn;\n  int yyresult;\n  /* Lookahead token as an internal (translated) token number.  */\n  int yytoken = 0;\n  /* The variables used to return semantic value and location from the\n     action routines.  */\n  YYSTYPE yyval;\n\n#if YYERROR_VERBOSE\n  /* Buffer for error messages, and its allocated size.  */\n  char yymsgbuf[128];\n  char *yymsg = yymsgbuf;\n  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;\n#endif\n\n#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))\n\n  /* The number of symbols on the RHS of the reduced rule.\n     Keep to zero when no symbol should be popped.  */\n  int yylen = 0;\n\n  yyssp = yyss = yyssa;\n  yyvsp = yyvs = yyvsa;\n  yystacksize = YYINITDEPTH;\n\n  YYDPRINTF ((stderr, \"Starting parse\\n\"));\n\n  yystate = 0;\n  yyerrstatus = 0;\n  yynerrs = 0;\n  yychar = YYEMPTY; /* Cause a token to be read.  */\n  goto yysetstate;\n\n/*------------------------------------------------------------.\n| yynewstate -- Push a new state, which is found in yystate.  |\n`------------------------------------------------------------*/\n yynewstate:\n  /* In all cases, when you get here, the value and location stacks\n     have just been pushed.  So pushing a state here evens the stacks.  */\n  yyssp++;\n\n yysetstate:\n  *yyssp = yystate;\n\n  if (yyss + yystacksize - 1 <= yyssp)\n    {\n      /* Get the current used size of the three stacks, in elements.  */\n      YYSIZE_T yysize = yyssp - yyss + 1;\n\n#ifdef yyoverflow\n      {\n        /* Give user a chance to reallocate the stack.  Use copies of\n           these so that the &'s don't force the real ones into\n           memory.  */\n        YYSTYPE *yyvs1 = yyvs;\n        yytype_int16 *yyss1 = yyss;\n\n        /* Each stack pointer address is followed by the size of the\n           data in use in that stack, in bytes.  This used to be a\n           conditional around just the two extra args, but that might\n           be undefined if yyoverflow is a macro.  */\n        yyoverflow (YY_(\"memory exhausted\"),\n                    &yyss1, yysize * sizeof (*yyssp),\n                    &yyvs1, yysize * sizeof (*yyvsp),\n                    &yystacksize);\n\n        yyss = yyss1;\n        yyvs = yyvs1;\n      }\n#else /* no yyoverflow */\n# ifndef YYSTACK_RELOCATE\n      goto yyexhaustedlab;\n# else\n      /* Extend the stack our own way.  */\n      if (YYMAXDEPTH <= yystacksize)\n        goto yyexhaustedlab;\n      yystacksize *= 2;\n      if (YYMAXDEPTH < yystacksize)\n        yystacksize = YYMAXDEPTH;\n\n      {\n        yytype_int16 *yyss1 = yyss;\n        union yyalloc *yyptr =\n          (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));\n        if (! yyptr)\n          goto yyexhaustedlab;\n        YYSTACK_RELOCATE (yyss_alloc, yyss);\n        YYSTACK_RELOCATE (yyvs_alloc, yyvs);\n#  undef YYSTACK_RELOCATE\n        if (yyss1 != yyssa)\n          YYSTACK_FREE (yyss1);\n      }\n# endif\n#endif /* no yyoverflow */\n\n      yyssp = yyss + yysize - 1;\n      yyvsp = yyvs + yysize - 1;\n\n      YYDPRINTF ((stderr, \"Stack size increased to %lu\\n\",\n                  (unsigned long int) yystacksize));\n\n      if (yyss + yystacksize - 1 <= yyssp)\n        YYABORT;\n    }\n\n  YYDPRINTF ((stderr, \"Entering state %d\\n\", yystate));\n\n  if (yystate == YYFINAL)\n    YYACCEPT;\n\n  goto yybackup;\n\n/*-----------.\n| yybackup.  |\n`-----------*/\nyybackup:\n\n  /* Do appropriate processing given the current state.  Read a\n     lookahead token if we need one and don't already have one.  */\n\n  /* First try to decide what to do without reference to lookahead token.  */\n  yyn = yypact[yystate];\n  if (yypact_value_is_default (yyn))\n    goto yydefault;\n\n  /* Not known => get a lookahead token if don't already have one.  */\n\n  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */\n  if (yychar == YYEMPTY)\n    {\n      YYDPRINTF ((stderr, \"Reading a token: \"));\n      yychar = yylex (&yylval, yyscanner, compiler);\n    }\n\n  if (yychar <= YYEOF)\n    {\n      yychar = yytoken = YYEOF;\n      YYDPRINTF ((stderr, \"Now at end of input.\\n\"));\n    }\n  else\n    {\n      yytoken = YYTRANSLATE (yychar);\n      YY_SYMBOL_PRINT (\"Next token is\", yytoken, &yylval, &yylloc);\n    }\n\n  /* If the proper action on seeing token YYTOKEN is to reduce or to\n     detect an error, take that action.  */\n  yyn += yytoken;\n  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)\n    goto yydefault;\n  yyn = yytable[yyn];\n  if (yyn <= 0)\n    {\n      if (yytable_value_is_error (yyn))\n        goto yyerrlab;\n      yyn = -yyn;\n      goto yyreduce;\n    }\n\n  /* Count tokens shifted since error; after three, turn off error\n     status.  */\n  if (yyerrstatus)\n    yyerrstatus--;\n\n  /* Shift the lookahead token.  */\n  YY_SYMBOL_PRINT (\"Shifting\", yytoken, &yylval, &yylloc);\n\n  /* Discard the shifted token.  */\n  yychar = YYEMPTY;\n\n  yystate = yyn;\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  *++yyvsp = yylval;\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n\n  goto yynewstate;\n\n\n/*-----------------------------------------------------------.\n| yydefault -- do the default action for the current state.  |\n`-----------------------------------------------------------*/\nyydefault:\n  yyn = yydefact[yystate];\n  if (yyn == 0)\n    goto yyerrlab;\n  goto yyreduce;\n\n\n/*-----------------------------.\n| yyreduce -- Do a reduction.  |\n`-----------------------------*/\nyyreduce:\n  /* yyn is the number of a rule to reduce with.  */\n  yylen = yyr2[yyn];\n\n  /* If YYLEN is nonzero, implement the default value of the action:\n     '$$ = $1'.\n\n     Otherwise, the following line sets YYVAL to garbage.\n     This behavior is undocumented and Bison\n     users should not rely upon it.  Assigning to YYVAL\n     unconditionally makes the parser a bit smaller, and it avoids a\n     GCC warning that YYVAL may be used uninitialized.  */\n  yyval = yyvsp[1-yylen];\n\n\n  YY_REDUCE_PRINT (yyn);\n  switch (yyn)\n    {\n        case 8:\n#line 230 \"grammar.y\" /* yacc.c:1646  */\n    {\n        int result = yr_parser_reduce_import(yyscanner, (yyvsp[0].sized_string));\n\n        yr_free((yyvsp[0].sized_string));\n\n        ERROR_IF(result != ERROR_SUCCESS);\n      }\n#line 1661 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 9:\n#line 242 \"grammar.y\" /* yacc.c:1646  */\n    {\n        YR_RULE* rule = yr_parser_reduce_rule_declaration_phase_1(\n            yyscanner, (int32_t) (yyvsp[-2].integer), (yyvsp[0].c_string));\n\n        ERROR_IF(rule == NULL);\n\n        (yyval.rule) = rule;\n      }\n#line 1674 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 10:\n#line 251 \"grammar.y\" /* yacc.c:1646  */\n    {\n        YR_RULE* rule = (yyvsp[-4].rule); // rule created in phase 1\n\n        rule->tags = (yyvsp[-3].c_string);\n        rule->metas = (yyvsp[-1].meta);\n        rule->strings = (yyvsp[0].string);\n      }\n#line 1686 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 11:\n#line 259 \"grammar.y\" /* yacc.c:1646  */\n    {\n        YR_RULE* rule = (yyvsp[-7].rule); // rule created in phase 1\n\n        compiler->last_result = yr_parser_reduce_rule_declaration_phase_2(\n            yyscanner, rule);\n\n        yr_free((yyvsp[-8].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n      }\n#line 1701 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 12:\n#line 274 \"grammar.y\" /* yacc.c:1646  */\n    {\n        (yyval.meta) = NULL;\n      }\n#line 1709 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 13:\n#line 278 \"grammar.y\" /* yacc.c:1646  */\n    {\n\n        YR_META null_meta;\n\n        memset(&null_meta, 0xFF, sizeof(YR_META));\n        null_meta.type = META_TYPE_NULL;\n\n        compiler->last_result = yr_arena_write_data(\n            compiler->metas_arena,\n            &null_meta,\n            sizeof(YR_META),\n            NULL);\n\n        (yyval.meta) = (yyvsp[0].meta);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n      }\n#line 1736 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 14:\n#line 305 \"grammar.y\" /* yacc.c:1646  */\n    {\n        (yyval.string) = NULL;\n      }\n#line 1744 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 15:\n#line 309 \"grammar.y\" /* yacc.c:1646  */\n    {\n\n        YR_STRING null_string;\n\n        memset(&null_string, 0xFF, sizeof(YR_STRING));\n        null_string.g_flags = STRING_GFLAGS_NULL;\n\n        compiler->last_result = yr_arena_write_data(\n            compiler->strings_arena,\n            &null_string,\n            sizeof(YR_STRING),\n            NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        (yyval.string) = (yyvsp[0].string);\n      }\n#line 1771 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 17:\n#line 340 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.integer) = 0;  }\n#line 1777 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 18:\n#line 341 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }\n#line 1783 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 19:\n#line 346 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.integer) = RULE_GFLAGS_PRIVATE; }\n#line 1789 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 20:\n#line 347 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.integer) = RULE_GFLAGS_GLOBAL; }\n#line 1795 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 21:\n#line 353 \"grammar.y\" /* yacc.c:1646  */\n    {\n        (yyval.c_string) = NULL;\n      }\n#line 1803 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 22:\n#line 357 \"grammar.y\" /* yacc.c:1646  */\n    {\n\n        compiler->last_result = yr_arena_write_string(\n            yyget_extra(yyscanner)->sz_arena, \"\", NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        (yyval.c_string) = (yyvsp[0].c_string);\n      }\n#line 1821 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 23:\n#line 375 \"grammar.y\" /* yacc.c:1646  */\n    {\n        char* identifier;\n\n        compiler->last_result = yr_arena_write_string(\n            yyget_extra(yyscanner)->sz_arena, (yyvsp[0].c_string), &identifier);\n\n        yr_free((yyvsp[0].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        (yyval.c_string) = identifier;\n      }\n#line 1838 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 24:\n#line 388 \"grammar.y\" /* yacc.c:1646  */\n    {\n        char* tag_name = (yyvsp[-1].c_string);\n        size_t tag_length = tag_name != NULL ? strlen(tag_name) : 0;\n\n        while (tag_length > 0)\n        {\n          if (strcmp(tag_name, (yyvsp[0].c_string)) == 0)\n          {\n            yr_compiler_set_error_extra_info(compiler, tag_name);\n            compiler->last_result = ERROR_DUPLICATED_TAG_IDENTIFIER;\n            break;\n          }\n\n          tag_name = (char*) yr_arena_next_address(\n              yyget_extra(yyscanner)->sz_arena,\n              tag_name,\n              tag_length + 1);\n\n          tag_length = tag_name != NULL ? strlen(tag_name) : 0;\n        }\n\n        if (compiler->last_result == ERROR_SUCCESS)\n          compiler->last_result = yr_arena_write_string(\n              yyget_extra(yyscanner)->sz_arena, (yyvsp[0].c_string), NULL);\n\n        yr_free((yyvsp[0].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        (yyval.c_string) = (yyvsp[-1].c_string);\n      }\n#line 1874 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 25:\n#line 424 \"grammar.y\" /* yacc.c:1646  */\n    {  (yyval.meta) = (yyvsp[0].meta); }\n#line 1880 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 26:\n#line 425 \"grammar.y\" /* yacc.c:1646  */\n    {  (yyval.meta) = (yyvsp[-1].meta); }\n#line 1886 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 27:\n#line 431 \"grammar.y\" /* yacc.c:1646  */\n    {\n        SIZED_STRING* sized_string = (yyvsp[0].sized_string);\n\n        (yyval.meta) = yr_parser_reduce_meta_declaration(\n            yyscanner,\n            META_TYPE_STRING,\n            (yyvsp[-2].c_string),\n            sized_string->c_string,\n            0);\n\n        yr_free((yyvsp[-2].c_string));\n        yr_free((yyvsp[0].sized_string));\n\n        ERROR_IF((yyval.meta) == NULL);\n      }\n#line 1906 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 28:\n#line 447 \"grammar.y\" /* yacc.c:1646  */\n    {\n        (yyval.meta) = yr_parser_reduce_meta_declaration(\n            yyscanner,\n            META_TYPE_INTEGER,\n            (yyvsp[-2].c_string),\n            NULL,\n            (yyvsp[0].integer));\n\n        yr_free((yyvsp[-2].c_string));\n\n        ERROR_IF((yyval.meta) == NULL);\n      }\n#line 1923 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 29:\n#line 460 \"grammar.y\" /* yacc.c:1646  */\n    {\n        (yyval.meta) = yr_parser_reduce_meta_declaration(\n            yyscanner,\n            META_TYPE_INTEGER,\n            (yyvsp[-3].c_string),\n            NULL,\n            -(yyvsp[0].integer));\n\n        yr_free((yyvsp[-3].c_string));\n\n        ERROR_IF((yyval.meta) == NULL);\n      }\n#line 1940 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 30:\n#line 473 \"grammar.y\" /* yacc.c:1646  */\n    {\n        (yyval.meta) = yr_parser_reduce_meta_declaration(\n            yyscanner,\n            META_TYPE_BOOLEAN,\n            (yyvsp[-2].c_string),\n            NULL,\n            TRUE);\n\n        yr_free((yyvsp[-2].c_string));\n\n        ERROR_IF((yyval.meta) == NULL);\n      }\n#line 1957 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 31:\n#line 486 \"grammar.y\" /* yacc.c:1646  */\n    {\n        (yyval.meta) = yr_parser_reduce_meta_declaration(\n            yyscanner,\n            META_TYPE_BOOLEAN,\n            (yyvsp[-2].c_string),\n            NULL,\n            FALSE);\n\n        yr_free((yyvsp[-2].c_string));\n\n        ERROR_IF((yyval.meta) == NULL);\n      }\n#line 1974 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 32:\n#line 502 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.string) = (yyvsp[0].string); }\n#line 1980 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 33:\n#line 503 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.string) = (yyvsp[-1].string); }\n#line 1986 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 34:\n#line 509 \"grammar.y\" /* yacc.c:1646  */\n    {\n        compiler->error_line = yyget_lineno(yyscanner);\n      }\n#line 1994 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 35:\n#line 513 \"grammar.y\" /* yacc.c:1646  */\n    {\n        (yyval.string) = yr_parser_reduce_string_declaration(\n            yyscanner, (int32_t) (yyvsp[0].integer), (yyvsp[-4].c_string), (yyvsp[-1].sized_string));\n\n        yr_free((yyvsp[-4].c_string));\n        yr_free((yyvsp[-1].sized_string));\n\n        ERROR_IF((yyval.string) == NULL);\n        compiler->error_line = 0;\n      }\n#line 2009 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 36:\n#line 524 \"grammar.y\" /* yacc.c:1646  */\n    {\n        compiler->error_line = yyget_lineno(yyscanner);\n      }\n#line 2017 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 37:\n#line 528 \"grammar.y\" /* yacc.c:1646  */\n    {\n        (yyval.string) = yr_parser_reduce_string_declaration(\n            yyscanner, (int32_t) (yyvsp[0].integer) | STRING_GFLAGS_REGEXP, (yyvsp[-4].c_string), (yyvsp[-1].sized_string));\n\n        yr_free((yyvsp[-4].c_string));\n        yr_free((yyvsp[-1].sized_string));\n\n        ERROR_IF((yyval.string) == NULL);\n\n        compiler->error_line = 0;\n      }\n#line 2033 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 38:\n#line 540 \"grammar.y\" /* yacc.c:1646  */\n    {\n        (yyval.string) = yr_parser_reduce_string_declaration(\n            yyscanner, STRING_GFLAGS_HEXADECIMAL, (yyvsp[-2].c_string), (yyvsp[0].sized_string));\n\n        yr_free((yyvsp[-2].c_string));\n        yr_free((yyvsp[0].sized_string));\n\n        ERROR_IF((yyval.string) == NULL);\n      }\n#line 2047 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 39:\n#line 553 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.integer) = 0; }\n#line 2053 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 40:\n#line 554 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }\n#line 2059 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 41:\n#line 559 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.integer) = STRING_GFLAGS_WIDE; }\n#line 2065 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 42:\n#line 560 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.integer) = STRING_GFLAGS_ASCII; }\n#line 2071 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 43:\n#line 561 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.integer) = STRING_GFLAGS_NO_CASE; }\n#line 2077 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 44:\n#line 562 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.integer) = STRING_GFLAGS_FULL_WORD; }\n#line 2083 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 45:\n#line 568 \"grammar.y\" /* yacc.c:1646  */\n    {\n        int var_index = yr_parser_lookup_loop_variable(yyscanner, (yyvsp[0].c_string));\n\n        if (var_index >= 0)\n        {\n          compiler->last_result = yr_parser_emit_with_arg(\n              yyscanner,\n              OP_PUSH_M,\n              LOOP_LOCAL_VARS * var_index,\n              NULL,\n              NULL);\n\n          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n          (yyval.expression).value.integer = UNDEFINED;\n          (yyval.expression).identifier = compiler->loop_identifier[var_index];\n        }\n        else\n        {\n\n          YR_OBJECT* object = (YR_OBJECT*) yr_hash_table_lookup(\n              compiler->objects_table, (yyvsp[0].c_string), NULL);\n\n          if (object == NULL)\n          {\n            char* ns = compiler->current_namespace->name;\n\n            object = (YR_OBJECT*) yr_hash_table_lookup(\n                compiler->objects_table, (yyvsp[0].c_string), ns);\n          }\n\n          if (object != NULL)\n          {\n            char* id;\n\n            compiler->last_result = yr_arena_write_string(\n                compiler->sz_arena, (yyvsp[0].c_string), &id);\n\n            if (compiler->last_result == ERROR_SUCCESS)\n              compiler->last_result = yr_parser_emit_with_arg_reloc(\n                  yyscanner,\n                  OP_OBJ_LOAD,\n                  id,\n                  NULL,\n                  NULL);\n\n            (yyval.expression).type = EXPRESSION_TYPE_OBJECT;\n            (yyval.expression).value.object = object;\n            (yyval.expression).identifier = object->identifier;\n          }\n          else\n          {\n            YR_RULE* rule = (YR_RULE*) yr_hash_table_lookup(\n                compiler->rules_table,\n                (yyvsp[0].c_string),\n                compiler->current_namespace->name);\n\n            if (rule != NULL)\n            {\n              compiler->last_result = yr_parser_emit_with_arg_reloc(\n                  yyscanner,\n                  OP_PUSH_RULE,\n                  rule,\n                  NULL,\n                  NULL);\n\n              (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n              (yyval.expression).value.integer = UNDEFINED;\n              (yyval.expression).identifier = rule->identifier;\n            }\n            else\n            {\n              yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));\n              compiler->last_result = ERROR_UNDEFINED_IDENTIFIER;\n            }\n          }\n        }\n\n        yr_free((yyvsp[0].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n      }\n#line 2172 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 46:\n#line 653 \"grammar.y\" /* yacc.c:1646  */\n    {\n        YR_OBJECT* field = NULL;\n\n        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_OBJECT &&\n            (yyvsp[-2].expression).value.object->type == OBJECT_TYPE_STRUCTURE)\n        {\n          field = yr_object_lookup_field((yyvsp[-2].expression).value.object, (yyvsp[0].c_string));\n\n          if (field != NULL)\n          {\n            char* ident;\n\n            compiler->last_result = yr_arena_write_string(\n              compiler->sz_arena, (yyvsp[0].c_string), &ident);\n\n            if (compiler->last_result == ERROR_SUCCESS)\n              compiler->last_result = yr_parser_emit_with_arg_reloc(\n                  yyscanner,\n                  OP_OBJ_FIELD,\n                  ident,\n                  NULL,\n                  NULL);\n\n            (yyval.expression).type = EXPRESSION_TYPE_OBJECT;\n            (yyval.expression).value.object = field;\n            (yyval.expression).identifier = field->identifier;\n          }\n          else\n          {\n            yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));\n            compiler->last_result = ERROR_INVALID_FIELD_NAME;\n          }\n        }\n        else\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, (yyvsp[-2].expression).identifier);\n\n          compiler->last_result = ERROR_NOT_A_STRUCTURE;\n        }\n\n        yr_free((yyvsp[0].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n      }\n#line 2222 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 47:\n#line 699 \"grammar.y\" /* yacc.c:1646  */\n    {\n        YR_OBJECT_ARRAY* array;\n        YR_OBJECT_DICTIONARY* dict;\n\n        if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&\n            (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_ARRAY)\n        {\n          if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)\n          {\n            yr_compiler_set_error_extra_info(\n                compiler, \"array indexes must be of integer type\");\n            compiler->last_result = ERROR_WRONG_TYPE;\n          }\n\n          ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n          compiler->last_result = yr_parser_emit(\n              yyscanner, OP_INDEX_ARRAY, NULL);\n\n          array = (YR_OBJECT_ARRAY*) (yyvsp[-3].expression).value.object;\n\n          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;\n          (yyval.expression).value.object = array->prototype_item;\n          (yyval.expression).identifier = array->identifier;\n        }\n        else if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&\n                 (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_DICTIONARY)\n        {\n          if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_STRING)\n          {\n            yr_compiler_set_error_extra_info(\n                compiler, \"dictionary keys must be of string type\");\n            compiler->last_result = ERROR_WRONG_TYPE;\n          }\n\n          ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n          compiler->last_result = yr_parser_emit(\n              yyscanner, OP_LOOKUP_DICT, NULL);\n\n          dict = (YR_OBJECT_DICTIONARY*) (yyvsp[-3].expression).value.object;\n\n          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;\n          (yyval.expression).value.object = dict->prototype_item;\n          (yyval.expression).identifier = dict->identifier;\n        }\n        else\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, (yyvsp[-3].expression).identifier);\n\n          compiler->last_result = ERROR_NOT_INDEXABLE;\n        }\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n      }\n#line 2283 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 48:\n#line 757 \"grammar.y\" /* yacc.c:1646  */\n    {\n        YR_OBJECT_FUNCTION* function;\n        char* args_fmt;\n\n        if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&\n            (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_FUNCTION)\n        {\n          compiler->last_result = yr_parser_check_types(\n              compiler, (YR_OBJECT_FUNCTION*) (yyvsp[-3].expression).value.object, (yyvsp[-1].c_string));\n\n          if (compiler->last_result == ERROR_SUCCESS)\n            compiler->last_result = yr_arena_write_string(\n              compiler->sz_arena, (yyvsp[-1].c_string), &args_fmt);\n\n          if (compiler->last_result == ERROR_SUCCESS)\n            compiler->last_result = yr_parser_emit_with_arg_reloc(\n                yyscanner,\n                OP_CALL,\n                args_fmt,\n                NULL,\n                NULL);\n\n          function = (YR_OBJECT_FUNCTION*) (yyvsp[-3].expression).value.object;\n\n          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;\n          (yyval.expression).value.object = function->return_obj;\n          (yyval.expression).identifier = function->identifier;\n        }\n        else\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, (yyvsp[-3].expression).identifier);\n\n          compiler->last_result = ERROR_NOT_A_FUNCTION;\n        }\n\n        yr_free((yyvsp[-1].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n      }\n#line 2328 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 49:\n#line 801 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.c_string) = yr_strdup(\"\"); }\n#line 2334 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 50:\n#line 802 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.c_string) = (yyvsp[0].c_string); }\n#line 2340 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 51:\n#line 807 \"grammar.y\" /* yacc.c:1646  */\n    {\n        (yyval.c_string) = (char*) yr_malloc(MAX_FUNCTION_ARGS + 1);\n\n        switch((yyvsp[0].expression).type)\n        {\n          case EXPRESSION_TYPE_INTEGER:\n            strlcpy((yyval.c_string), \"i\", MAX_FUNCTION_ARGS);\n            break;\n          case EXPRESSION_TYPE_FLOAT:\n            strlcpy((yyval.c_string), \"f\", MAX_FUNCTION_ARGS);\n            break;\n          case EXPRESSION_TYPE_BOOLEAN:\n            strlcpy((yyval.c_string), \"b\", MAX_FUNCTION_ARGS);\n            break;\n          case EXPRESSION_TYPE_STRING:\n            strlcpy((yyval.c_string), \"s\", MAX_FUNCTION_ARGS);\n            break;\n           case EXPRESSION_TYPE_REGEXP:\n             strlcpy((yyval.c_string), \"r\", MAX_FUNCTION_ARGS);\n             break;\n         }\n \n         ERROR_IF((yyval.c_string) == NULL);\n       }\n#line 2369 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 52:\n#line 832 \"grammar.y\" /* yacc.c:1646  */\n     {\n         if (strlen((yyvsp[-2].c_string)) == MAX_FUNCTION_ARGS)\n         {\n          compiler->last_result = ERROR_TOO_MANY_ARGUMENTS;\n        }\n        else\n        {\n          switch((yyvsp[0].expression).type)\n          {\n            case EXPRESSION_TYPE_INTEGER:\n              strlcat((yyvsp[-2].c_string), \"i\", MAX_FUNCTION_ARGS);\n              break;\n            case EXPRESSION_TYPE_FLOAT:\n              strlcat((yyvsp[-2].c_string), \"f\", MAX_FUNCTION_ARGS);\n              break;\n            case EXPRESSION_TYPE_BOOLEAN:\n              strlcat((yyvsp[-2].c_string), \"b\", MAX_FUNCTION_ARGS);\n              break;\n            case EXPRESSION_TYPE_STRING:\n              strlcat((yyvsp[-2].c_string), \"s\", MAX_FUNCTION_ARGS);\n              break;\n             case EXPRESSION_TYPE_REGEXP:\n               strlcat((yyvsp[-2].c_string), \"r\", MAX_FUNCTION_ARGS);\n               break;\n           }\n         }\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n \n         (yyval.c_string) = (yyvsp[-2].c_string);\n       }\n#line 2405 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 53:\n#line 868 \"grammar.y\" /* yacc.c:1646  */\n     {\n         SIZED_STRING* sized_string = (yyvsp[0].sized_string);\n         RE* re;\n        RE_ERROR error;\n\n        int re_flags = 0;\n\n        if (sized_string->flags & SIZED_STRING_FLAGS_NO_CASE)\n          re_flags |= RE_FLAGS_NO_CASE;\n\n        if (sized_string->flags & SIZED_STRING_FLAGS_DOT_ALL)\n          re_flags |= RE_FLAGS_DOT_ALL;\n\n        compiler->last_result = yr_re_compile(\n            sized_string->c_string,\n            re_flags,\n            compiler->re_code_arena,\n            &re,\n            &error);\n\n        yr_free((yyvsp[0].sized_string));\n\n        if (compiler->last_result == ERROR_INVALID_REGULAR_EXPRESSION)\n          yr_compiler_set_error_extra_info(compiler, error.message);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        if (compiler->last_result == ERROR_SUCCESS)\n          compiler->last_result = yr_parser_emit_with_arg_reloc(\n              yyscanner,\n              OP_PUSH,\n              re->root_node->forward_code,\n              NULL,\n              NULL);\n\n        yr_re_destroy(re);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n \n         (yyval.expression).type = EXPRESSION_TYPE_REGEXP;\n       }\n#line 2451 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 54:\n#line 914 \"grammar.y\" /* yacc.c:1646  */\n     {\n         if ((yyvsp[0].expression).type == EXPRESSION_TYPE_STRING)\n         {\n          if ((yyvsp[0].expression).value.sized_string != NULL)\n          {\n            yywarning(yyscanner,\n              \"Using literal string \\\"%s\\\" in a boolean operation.\",\n              (yyvsp[0].expression).value.sized_string->c_string);\n          }\n\n          compiler->last_result = yr_parser_emit(\n              yyscanner, OP_STR_TO_BOOL, NULL);\n\n          ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n        }\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 2474 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 55:\n#line 936 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_emit_with_arg(\n             yyscanner, OP_PUSH, 1, NULL, NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 2487 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 56:\n#line 945 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_emit_with_arg(\n             yyscanner, OP_PUSH, 0, NULL, NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 2500 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 57:\n#line 954 \"grammar.y\" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, \"matches\");\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_REGEXP, \"matches\");\n\n        if (compiler->last_result == ERROR_SUCCESS)\n          compiler->last_result = yr_parser_emit(\n              yyscanner,\n              OP_MATCHES,\n              NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 2519 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 58:\n#line 969 \"grammar.y\" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, \"contains\");\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_STRING, \"contains\");\n\n        compiler->last_result = yr_parser_emit(\n            yyscanner, OP_CONTAINS, NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 2535 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 59:\n#line 981 \"grammar.y\" /* yacc.c:1646  */\n     {\n         int result = yr_parser_reduce_string_identifier(\n             yyscanner,\n            (yyvsp[0].c_string),\n            OP_FOUND,\n            UNDEFINED);\n\n        yr_free((yyvsp[0].c_string));\n\n        ERROR_IF(result != ERROR_SUCCESS);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 2553 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 60:\n#line 995 \"grammar.y\" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"at\");\n \n        compiler->last_result = yr_parser_reduce_string_identifier(\n            yyscanner, (yyvsp[-2].c_string), OP_FOUND_AT, (yyvsp[0].expression).value.integer);\n\n        yr_free((yyvsp[-2].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 2570 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 61:\n#line 1008 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_string_identifier(\n             yyscanner, (yyvsp[-2].c_string), OP_FOUND_IN, UNDEFINED);\n\n        yr_free((yyvsp[-2].c_string));\n\n        ERROR_IF(compiler->last_result!= ERROR_SUCCESS);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 2585 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 62:\n#line 1019 \"grammar.y\" /* yacc.c:1646  */\n     {\n         if (compiler->loop_depth > 0)\n         {\n           compiler->loop_depth--;\n           compiler->loop_identifier[compiler->loop_depth] = NULL;\n         }\n       }\n#line 2597 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 63:\n#line 1027 \"grammar.y\" /* yacc.c:1646  */\n     {\n         int var_index;\n \n        if (compiler->loop_depth == MAX_LOOP_NESTING)\n          compiler->last_result = \\\n              ERROR_LOOP_NESTING_LIMIT_EXCEEDED;\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        var_index = yr_parser_lookup_loop_variable(\n            yyscanner, (yyvsp[-1].c_string));\n\n        if (var_index >= 0)\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, (yyvsp[-1].c_string));\n\n          compiler->last_result = \\\n              ERROR_DUPLICATED_LOOP_IDENTIFIER;\n        }\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        compiler->last_result = yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n#line 2631 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 64:\n#line 1057 \"grammar.y\" /* yacc.c:1646  */\n     {\n         int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;\n         uint8_t* addr;\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);\n\n        if ((yyvsp[-1].integer) == INTEGER_SET_ENUMERATION)\n        {\n          yr_parser_emit_with_arg(\n              yyscanner, OP_POP_M, mem_offset, &addr, NULL);\n        }\n        else // INTEGER_SET_RANGE\n        {\n          yr_parser_emit_with_arg(\n              yyscanner, OP_POP_M, mem_offset + 3, &addr, NULL);\n\n          yr_parser_emit_with_arg(\n              yyscanner, OP_POP_M, mem_offset, NULL, NULL);\n        }\n\n        compiler->loop_address[compiler->loop_depth] = addr;\n         compiler->loop_identifier[compiler->loop_depth] = (yyvsp[-4].c_string);\n         compiler->loop_depth++;\n       }\n#line 2670 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 65:\n#line 1092 \"grammar.y\" /* yacc.c:1646  */\n     {\n         int mem_offset;\n \n        compiler->loop_depth--;\n        mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;\n\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);\n\n        if ((yyvsp[-5].integer) == INTEGER_SET_ENUMERATION)\n        {\n          yr_parser_emit_with_arg_reloc(\n              yyscanner,\n              OP_JNUNDEF,\n              compiler->loop_address[compiler->loop_depth],\n              NULL,\n              NULL);\n        }\n        else // INTEGER_SET_RANGE\n        {\n          yr_parser_emit_with_arg(\n              yyscanner, OP_INCR_M, mem_offset, NULL, NULL);\n\n          yr_parser_emit_with_arg(\n              yyscanner, OP_PUSH_M, mem_offset, NULL, NULL);\n\n          yr_parser_emit_with_arg(\n              yyscanner, OP_PUSH_M, mem_offset + 3, NULL, NULL);\n\n          yr_parser_emit_with_arg_reloc(\n              yyscanner,\n              OP_JLE,\n              compiler->loop_address[compiler->loop_depth],\n              NULL,\n              NULL);\n\n          yr_parser_emit(yyscanner, OP_POP, NULL);\n          yr_parser_emit(yyscanner, OP_POP, NULL);\n        }\n\n        yr_parser_emit(yyscanner, OP_POP, NULL);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);\n\n        yr_parser_emit(yyscanner, OP_INT_LE, NULL);\n\n        compiler->loop_identifier[compiler->loop_depth] = NULL;\n        yr_free((yyvsp[-8].c_string));\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 2753 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 66:\n#line 1171 \"grammar.y\" /* yacc.c:1646  */\n     {\n         int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;\n         uint8_t* addr;\n\n        if (compiler->loop_depth == MAX_LOOP_NESTING)\n          compiler->last_result = \\\n            ERROR_LOOP_NESTING_LIMIT_EXCEEDED;\n\n        if (compiler->loop_for_of_mem_offset != -1)\n          compiler->last_result = \\\n            ERROR_NESTED_FOR_OF_LOOP;\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_POP_M, mem_offset, &addr, NULL);\n\n        compiler->loop_for_of_mem_offset = mem_offset;\n        compiler->loop_address[compiler->loop_depth] = addr;\n         compiler->loop_identifier[compiler->loop_depth] = NULL;\n         compiler->loop_depth++;\n       }\n#line 2787 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 67:\n#line 1201 \"grammar.y\" /* yacc.c:1646  */\n     {\n         int mem_offset;\n \n        compiler->loop_depth--;\n        compiler->loop_for_of_mem_offset = -1;\n\n        mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;\n\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);\n\n        yr_parser_emit_with_arg_reloc(\n            yyscanner,\n            OP_JNUNDEF,\n            compiler->loop_address[compiler->loop_depth],\n            NULL,\n            NULL);\n\n        yr_parser_emit(yyscanner, OP_POP, NULL);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);\n\n        yr_parser_emit(yyscanner, OP_INT_LE, NULL);\n\n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n \n       }\n#line 2840 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 68:\n#line 1250 \"grammar.y\" /* yacc.c:1646  */\n     {\n         yr_parser_emit(yyscanner, OP_OF, NULL);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 2850 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 69:\n#line 1256 \"grammar.y\" /* yacc.c:1646  */\n     {\n         yr_parser_emit(yyscanner, OP_NOT, NULL);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 2860 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 70:\n#line 1262 \"grammar.y\" /* yacc.c:1646  */\n     {\n         YR_FIXUP* fixup;\n         void* jmp_destination_addr;\n\n        compiler->last_result = yr_parser_emit_with_arg_reloc(\n            yyscanner,\n            OP_JFALSE,\n            0,          // still don't know the jump destination\n            NULL,\n            &jmp_destination_addr);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));\n\n        if (fixup == NULL)\n          compiler->last_error = ERROR_INSUFFICIENT_MEMORY;\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        fixup->address = jmp_destination_addr;\n         fixup->next = compiler->fixup_stack_head;\n         compiler->fixup_stack_head = fixup;\n       }\n#line 2890 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 71:\n#line 1288 \"grammar.y\" /* yacc.c:1646  */\n     {\n         YR_FIXUP* fixup;\n         uint8_t* and_addr;\n\n\n        compiler->last_result = yr_arena_reserve_memory(\n            compiler->code_arena, 2);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        compiler->last_result = yr_parser_emit(yyscanner, OP_AND, &and_addr);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n\n        fixup = compiler->fixup_stack_head;\n\n\n        *(void**)(fixup->address) = (void*)(and_addr + 1);\n\n        compiler->fixup_stack_head = fixup->next;\n        yr_free(fixup);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 2930 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 72:\n#line 1324 \"grammar.y\" /* yacc.c:1646  */\n     {\n         YR_FIXUP* fixup;\n         void* jmp_destination_addr;\n\n        compiler->last_result = yr_parser_emit_with_arg_reloc(\n            yyscanner,\n            OP_JTRUE,\n            0,         // still don't know the jump destination\n            NULL,\n            &jmp_destination_addr);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));\n\n        if (fixup == NULL)\n          compiler->last_error = ERROR_INSUFFICIENT_MEMORY;\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        fixup->address = jmp_destination_addr;\n         fixup->next = compiler->fixup_stack_head;\n         compiler->fixup_stack_head = fixup;\n       }\n#line 2959 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 73:\n#line 1349 \"grammar.y\" /* yacc.c:1646  */\n     {\n         YR_FIXUP* fixup;\n         uint8_t* or_addr;\n\n\n        compiler->last_result = yr_arena_reserve_memory(\n            compiler->code_arena, 2);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        compiler->last_result = yr_parser_emit(yyscanner, OP_OR, &or_addr);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n\n        fixup = compiler->fixup_stack_head;\n\n\n        *(void**)(fixup->address) = (void*)(or_addr + 1);\n\n        compiler->fixup_stack_head = fixup->next;\n        yr_free(fixup);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 2999 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 74:\n#line 1385 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \"<\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 3012 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 75:\n#line 1394 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \">\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 3025 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 76:\n#line 1403 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \"<=\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 3038 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 77:\n#line 1412 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \">=\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 3051 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 78:\n#line 1421 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \"==\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 3064 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 79:\n#line 1430 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \"!=\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 3077 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 80:\n#line 1439 \"grammar.y\" /* yacc.c:1646  */\n     {\n         (yyval.expression) = (yyvsp[0].expression);\n       }\n#line 3085 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 81:\n#line 1443 \"grammar.y\" /* yacc.c:1646  */\n     {\n         (yyval.expression) = (yyvsp[-1].expression);\n       }\n#line 3093 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 82:\n#line 1450 \"grammar.y\" /* yacc.c:1646  */\n     { (yyval.integer) = INTEGER_SET_ENUMERATION; }\n#line 3099 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 83:\n#line 1451 \"grammar.y\" /* yacc.c:1646  */\n     { (yyval.integer) = INTEGER_SET_RANGE; }\n#line 3105 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 84:\n#line 1457 \"grammar.y\" /* yacc.c:1646  */\n     {\n         if ((yyvsp[-3].expression).type != EXPRESSION_TYPE_INTEGER)\n         {\n          yr_compiler_set_error_extra_info(\n              compiler, \"wrong type for range's lower bound\");\n          compiler->last_result = ERROR_WRONG_TYPE;\n        }\n\n        if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, \"wrong type for range's upper bound\");\n          compiler->last_result = ERROR_WRONG_TYPE;\n        }\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n#line 3127 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 85:\n#line 1479 \"grammar.y\" /* yacc.c:1646  */\n     {\n         if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)\n         {\n          yr_compiler_set_error_extra_info(\n              compiler, \"wrong type for enumeration item\");\n          compiler->last_result = ERROR_WRONG_TYPE;\n\n        }\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n#line 3143 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 86:\n#line 1491 \"grammar.y\" /* yacc.c:1646  */\n     {\n         if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)\n         {\n          yr_compiler_set_error_extra_info(\n              compiler, \"wrong type for enumeration item\");\n          compiler->last_result = ERROR_WRONG_TYPE;\n        }\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n#line 3158 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 87:\n#line 1506 \"grammar.y\" /* yacc.c:1646  */\n     {\n         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);\n       }\n#line 3167 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 89:\n#line 1512 \"grammar.y\" /* yacc.c:1646  */\n     {\n         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);\n         yr_parser_emit_pushes_for_strings(yyscanner, \"$*\");\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n#line 3178 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 92:\n#line 1529 \"grammar.y\" /* yacc.c:1646  */\n     {\n         yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));\n         yr_free((yyvsp[0].c_string));\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n#line 3189 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 93:\n#line 1536 \"grammar.y\" /* yacc.c:1646  */\n     {\n         yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));\n         yr_free((yyvsp[0].c_string));\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n#line 3200 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 95:\n#line 1548 \"grammar.y\" /* yacc.c:1646  */\n     {\n         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);\n       }\n#line 3208 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 96:\n#line 1552 \"grammar.y\" /* yacc.c:1646  */\n     {\n         yr_parser_emit_with_arg(yyscanner, OP_PUSH, 1, NULL, NULL);\n       }\n#line 3216 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 97:\n#line 1560 \"grammar.y\" /* yacc.c:1646  */\n     {\n         (yyval.expression) = (yyvsp[-1].expression);\n       }\n#line 3224 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 98:\n#line 1564 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_emit(\n             yyscanner, OP_FILESIZE, NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n#line 3238 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 99:\n#line 1574 \"grammar.y\" /* yacc.c:1646  */\n     {\n         yywarning(yyscanner,\n             \"Using deprecated \\\"entrypoint\\\" keyword. Use the \\\"entry_point\\\" \"\n            \"function from PE module instead.\");\n\n        compiler->last_result = yr_parser_emit(\n            yyscanner, OP_ENTRYPOINT, NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n#line 3256 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 100:\n#line 1588 \"grammar.y\" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[-1].expression), EXPRESSION_TYPE_INTEGER, \"intXXXX or uintXXXX\");\n \n\n        compiler->last_result = yr_parser_emit(\n            yyscanner, (uint8_t) (OP_READ_INT + (yyvsp[-3].integer)), NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n#line 3276 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 101:\n#line 1604 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_emit_with_arg(\n             yyscanner, OP_PUSH, (yyvsp[0].integer), NULL, NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = (yyvsp[0].integer);\n       }\n#line 3290 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 102:\n#line 1614 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_emit_with_arg_double(\n             yyscanner, OP_PUSH, (yyvsp[0].double_), NULL, NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n \n         (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n       }\n#line 3303 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 103:\n#line 1623 \"grammar.y\" /* yacc.c:1646  */\n     {\n         SIZED_STRING* sized_string;\n \n        compiler->last_result = yr_arena_write_data(\n            compiler->sz_arena,\n            (yyvsp[0].sized_string),\n            (yyvsp[0].sized_string)->length + sizeof(SIZED_STRING),\n            (void**) &sized_string);\n\n        yr_free((yyvsp[0].sized_string));\n\n        if (compiler->last_result == ERROR_SUCCESS)\n          compiler->last_result = yr_parser_emit_with_arg_reloc(\n              yyscanner,\n              OP_PUSH,\n              sized_string,\n              NULL,\n              NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n         (yyval.expression).type = EXPRESSION_TYPE_STRING;\n         (yyval.expression).value.sized_string = sized_string;\n       }\n#line 3332 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 104:\n#line 1648 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_string_identifier(\n             yyscanner, (yyvsp[0].c_string), OP_COUNT, UNDEFINED);\n\n        yr_free((yyvsp[0].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n#line 3348 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 105:\n#line 1660 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_string_identifier(\n             yyscanner, (yyvsp[-3].c_string), OP_OFFSET, UNDEFINED);\n\n        yr_free((yyvsp[-3].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n#line 3364 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 106:\n#line 1672 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_emit_with_arg(\n             yyscanner, OP_PUSH, 1, NULL, NULL);\n\n        if (compiler->last_result == ERROR_SUCCESS)\n          compiler->last_result = yr_parser_reduce_string_identifier(\n              yyscanner, (yyvsp[0].c_string), OP_OFFSET, UNDEFINED);\n\n        yr_free((yyvsp[0].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n#line 3384 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 107:\n#line 1688 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_string_identifier(\n             yyscanner, (yyvsp[-3].c_string), OP_LENGTH, UNDEFINED);\n\n        yr_free((yyvsp[-3].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n#line 3400 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 108:\n#line 1700 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_emit_with_arg(\n             yyscanner, OP_PUSH, 1, NULL, NULL);\n\n        if (compiler->last_result == ERROR_SUCCESS)\n          compiler->last_result = yr_parser_reduce_string_identifier(\n              yyscanner, (yyvsp[0].c_string), OP_LENGTH, UNDEFINED);\n\n        yr_free((yyvsp[0].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n#line 3420 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 109:\n#line 1716 \"grammar.y\" /* yacc.c:1646  */\n     {\n         if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)  // loop identifier\n         {\n          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n          (yyval.expression).value.integer = UNDEFINED;\n        }\n        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_BOOLEAN)  // rule identifier\n        {\n          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n          (yyval.expression).value.integer = UNDEFINED;\n        }\n        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_OBJECT)\n        {\n          compiler->last_result = yr_parser_emit(\n              yyscanner, OP_OBJ_VALUE, NULL);\n\n          switch((yyvsp[0].expression).value.object->type)\n          {\n            case OBJECT_TYPE_INTEGER:\n              (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n              (yyval.expression).value.integer = UNDEFINED;\n              break;\n            case OBJECT_TYPE_FLOAT:\n              (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n              break;\n            case OBJECT_TYPE_STRING:\n              (yyval.expression).type = EXPRESSION_TYPE_STRING;\n              (yyval.expression).value.sized_string = NULL;\n              break;\n            default:\n              yr_compiler_set_error_extra_info_fmt(\n                  compiler,\n                  \"wrong usage of identifier \\\"%s\\\"\",\n                  (yyvsp[0].expression).identifier);\n              compiler->last_result = ERROR_WRONG_TYPE;\n          }\n        }\n        else\n        {\n          assert(FALSE);\n        }\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n#line 3469 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 110:\n#line 1761 \"grammar.y\" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER | EXPRESSION_TYPE_FLOAT, \"-\");\n \n        if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)\n        {\n          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n          (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?\n              UNDEFINED : -((yyvsp[0].expression).value.integer);\n          compiler->last_result = yr_parser_emit(yyscanner, OP_INT_MINUS, NULL);\n        }\n        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_FLOAT)\n        {\n          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n          compiler->last_result = yr_parser_emit(yyscanner, OP_DBL_MINUS, NULL);\n        }\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n#line 3492 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 111:\n#line 1780 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \"+\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&\n            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)\n        {\n          (yyval.expression).value.integer = OPERATION(+, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n        }\n        else\n        {\n           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n         }\n       }\n#line 3514 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 112:\n#line 1798 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \"-\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&\n            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)\n        {\n          (yyval.expression).value.integer = OPERATION(-, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n        }\n        else\n        {\n           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n         }\n       }\n#line 3536 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 113:\n#line 1816 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \"*\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&\n            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)\n        {\n          (yyval.expression).value.integer = OPERATION(*, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n        }\n        else\n        {\n           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n         }\n       }\n#line 3558 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 114:\n#line 1834 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \"\\\\\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&\n            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)\n        {\n          if ((yyvsp[0].expression).value.integer != 0)\n          {\n            (yyval.expression).value.integer = OPERATION(/, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n            (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n          }\n          else\n          {\n            compiler->last_result = ERROR_DIVISION_BY_ZERO;\n            ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n          }\n        }\n        else\n        {\n           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n         }\n       }\n#line 3588 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 115:\n#line 1860 \"grammar.y\" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"%\");\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"%\");\n\n        yr_parser_emit(yyscanner, OP_MOD, NULL);\n\n        if ((yyvsp[0].expression).value.integer != 0)\n        {\n          (yyval.expression).value.integer = OPERATION(%, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n        }\n        else\n        {\n          compiler->last_result = ERROR_DIVISION_BY_ZERO;\n           ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n         }\n       }\n#line 3610 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 116:\n#line 1878 \"grammar.y\" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"^\");\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"^\");\n\n        yr_parser_emit(yyscanner, OP_BITWISE_XOR, NULL);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = OPERATION(^, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n       }\n#line 3624 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 117:\n#line 1888 \"grammar.y\" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"^\");\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"^\");\n\n        yr_parser_emit(yyscanner, OP_BITWISE_AND, NULL);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = OPERATION(&, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n       }\n#line 3638 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 118:\n#line 1898 \"grammar.y\" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"|\");\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"|\");\n\n        yr_parser_emit(yyscanner, OP_BITWISE_OR, NULL);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = OPERATION(|, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n       }\n#line 3652 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 119:\n#line 1908 \"grammar.y\" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"~\");\n \n        yr_parser_emit(yyscanner, OP_BITWISE_NOT, NULL);\n\n        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?\n             UNDEFINED : ~((yyvsp[0].expression).value.integer);\n       }\n#line 3666 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 120:\n#line 1918 \"grammar.y\" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"<<\");\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"<<\");\n\n        yr_parser_emit(yyscanner, OP_SHL, NULL);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = OPERATION(<<, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n       }\n#line 3680 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 121:\n#line 1928 \"grammar.y\" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \">>\");\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \">>\");\n\n        yr_parser_emit(yyscanner, OP_SHR, NULL);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = OPERATION(>>, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n       }\n#line 3694 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 122:\n#line 1938 \"grammar.y\" /* yacc.c:1646  */\n     {\n         (yyval.expression) = (yyvsp[0].expression);\n       }\n#line 3702 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n \n#line 3706 \"grammar.c\" /* yacc.c:1646  */\n       default: break;\n     }\n   /* User semantic actions sometimes alter yychar, and that requires\n     that yytoken be updated with the new translation.  We take the\n     approach of translating immediately before every use of yytoken.\n     One alternative is translating here after every semantic action,\n     but that translation would be missed if the semantic action invokes\n     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or\n     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an\n     incorrect destructor might then be invoked immediately.  In the\n     case of YYERROR or YYBACKUP, subsequent parser actions might lead\n     to an incorrect destructor call or verbose syntax error message\n     before the lookahead is translated.  */\n  YY_SYMBOL_PRINT (\"-> $$ =\", yyr1[yyn], &yyval, &yyloc);\n\n  YYPOPSTACK (yylen);\n  yylen = 0;\n  YY_STACK_PRINT (yyss, yyssp);\n\n  *++yyvsp = yyval;\n\n  /* Now 'shift' the result of the reduction.  Determine what state\n     that goes to, based on the state we popped back to and the rule\n     number reduced by.  */\n\n  yyn = yyr1[yyn];\n\n  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;\n  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)\n    yystate = yytable[yystate];\n  else\n    yystate = yydefgoto[yyn - YYNTOKENS];\n\n  goto yynewstate;\n\n\n/*--------------------------------------.\n| yyerrlab -- here on detecting error.  |\n`--------------------------------------*/\nyyerrlab:\n  /* Make sure we have latest lookahead translation.  See comments at\n     user semantic actions for why this is necessary.  */\n  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);\n\n  /* If not already recovering from an error, report this error.  */\n  if (!yyerrstatus)\n    {\n      ++yynerrs;\n#if ! YYERROR_VERBOSE\n      yyerror (yyscanner, compiler, YY_(\"syntax error\"));\n#else\n# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \\\n                                        yyssp, yytoken)\n      {\n        char const *yymsgp = YY_(\"syntax error\");\n        int yysyntax_error_status;\n        yysyntax_error_status = YYSYNTAX_ERROR;\n        if (yysyntax_error_status == 0)\n          yymsgp = yymsg;\n        else if (yysyntax_error_status == 1)\n          {\n            if (yymsg != yymsgbuf)\n              YYSTACK_FREE (yymsg);\n            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);\n            if (!yymsg)\n              {\n                yymsg = yymsgbuf;\n                yymsg_alloc = sizeof yymsgbuf;\n                yysyntax_error_status = 2;\n              }\n            else\n              {\n                yysyntax_error_status = YYSYNTAX_ERROR;\n                yymsgp = yymsg;\n              }\n          }\n        yyerror (yyscanner, compiler, yymsgp);\n        if (yysyntax_error_status == 2)\n          goto yyexhaustedlab;\n      }\n# undef YYSYNTAX_ERROR\n#endif\n    }\n\n\n\n  if (yyerrstatus == 3)\n    {\n      /* If just tried and failed to reuse lookahead token after an\n         error, discard it.  */\n\n      if (yychar <= YYEOF)\n        {\n          /* Return failure if at end of input.  */\n          if (yychar == YYEOF)\n            YYABORT;\n        }\n      else\n        {\n          yydestruct (\"Error: discarding\",\n                      yytoken, &yylval, yyscanner, compiler);\n          yychar = YYEMPTY;\n        }\n    }\n\n  /* Else will try to reuse lookahead token after shifting the error\n     token.  */\n  goto yyerrlab1;\n\n\n/*---------------------------------------------------.\n| yyerrorlab -- error raised explicitly by YYERROR.  |\n`---------------------------------------------------*/\nyyerrorlab:\n\n  /* Pacify compilers like GCC when the user code never invokes\n     YYERROR and the label yyerrorlab therefore never appears in user\n     code.  */\n  if (/*CONSTCOND*/ 0)\n     goto yyerrorlab;\n\n  /* Do not reclaim the symbols of the rule whose action triggered\n     this YYERROR.  */\n  YYPOPSTACK (yylen);\n  yylen = 0;\n  YY_STACK_PRINT (yyss, yyssp);\n  yystate = *yyssp;\n  goto yyerrlab1;\n\n\n/*-------------------------------------------------------------.\n| yyerrlab1 -- common code for both syntax error and YYERROR.  |\n`-------------------------------------------------------------*/\nyyerrlab1:\n  yyerrstatus = 3;      /* Each real token shifted decrements this.  */\n\n  for (;;)\n    {\n      yyn = yypact[yystate];\n      if (!yypact_value_is_default (yyn))\n        {\n          yyn += YYTERROR;\n          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)\n            {\n              yyn = yytable[yyn];\n              if (0 < yyn)\n                break;\n            }\n        }\n\n      /* Pop the current state because it cannot handle the error token.  */\n      if (yyssp == yyss)\n        YYABORT;\n\n\n      yydestruct (\"Error: popping\",\n                  yystos[yystate], yyvsp, yyscanner, compiler);\n      YYPOPSTACK (1);\n      yystate = *yyssp;\n      YY_STACK_PRINT (yyss, yyssp);\n    }\n\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  *++yyvsp = yylval;\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n\n\n  /* Shift the error token.  */\n  YY_SYMBOL_PRINT (\"Shifting\", yystos[yyn], yyvsp, yylsp);\n\n  yystate = yyn;\n  goto yynewstate;\n\n\n/*-------------------------------------.\n| yyacceptlab -- YYACCEPT comes here.  |\n`-------------------------------------*/\nyyacceptlab:\n  yyresult = 0;\n  goto yyreturn;\n\n/*-----------------------------------.\n| yyabortlab -- YYABORT comes here.  |\n`-----------------------------------*/\nyyabortlab:\n  yyresult = 1;\n  goto yyreturn;\n\n#if !defined yyoverflow || YYERROR_VERBOSE\n/*-------------------------------------------------.\n| yyexhaustedlab -- memory exhaustion comes here.  |\n`-------------------------------------------------*/\nyyexhaustedlab:\n  yyerror (yyscanner, compiler, YY_(\"memory exhausted\"));\n  yyresult = 2;\n  /* Fall through.  */\n#endif\n\nyyreturn:\n  if (yychar != YYEMPTY)\n    {\n      /* Make sure we have latest lookahead translation.  See comments at\n         user semantic actions for why this is necessary.  */\n      yytoken = YYTRANSLATE (yychar);\n      yydestruct (\"Cleanup: discarding lookahead\",\n                  yytoken, &yylval, yyscanner, compiler);\n    }\n  /* Do not reclaim the symbols of the rule whose action triggered\n     this YYABORT or YYACCEPT.  */\n  YYPOPSTACK (yylen);\n  YY_STACK_PRINT (yyss, yyssp);\n  while (yyssp != yyss)\n    {\n      yydestruct (\"Cleanup: popping\",\n                  yystos[*yyssp], yyvsp, yyscanner, compiler);\n      YYPOPSTACK (1);\n    }\n#ifndef yyoverflow\n  if (yyss != yyssa)\n    YYSTACK_FREE (yyss);\n#endif\n#if YYERROR_VERBOSE\n  if (yymsg != yymsgbuf)\n    YYSTACK_FREE (yymsg);\n #endif\n   return yyresult;\n }\n",
    "code_after_change": "yyparse (void *yyscanner, YR_COMPILER* compiler)\n{\n/* The lookahead symbol.  */\nint yychar;\n\n\n/* The semantic value of the lookahead symbol.  */\n/* Default value used for initialization, for pacifying older GCCs\n   or non-GCC compilers.  */\nYY_INITIAL_VALUE (static YYSTYPE yyval_default;)\nYYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n\n    /* Number of syntax errors so far.  */\n    int yynerrs;\n\n    int yystate;\n    /* Number of tokens to shift before error messages enabled.  */\n    int yyerrstatus;\n\n    /* The stacks and their tools:\n       'yyss': related to states.\n       'yyvs': related to semantic values.\n\n       Refer to the stacks through separate pointers, to allow yyoverflow\n       to reallocate them elsewhere.  */\n\n    /* The state stack.  */\n    yytype_int16 yyssa[YYINITDEPTH];\n    yytype_int16 *yyss;\n    yytype_int16 *yyssp;\n\n    /* The semantic value stack.  */\n    YYSTYPE yyvsa[YYINITDEPTH];\n    YYSTYPE *yyvs;\n    YYSTYPE *yyvsp;\n\n    YYSIZE_T yystacksize;\n\n  int yyn;\n  int yyresult;\n  /* Lookahead token as an internal (translated) token number.  */\n  int yytoken = 0;\n  /* The variables used to return semantic value and location from the\n     action routines.  */\n  YYSTYPE yyval;\n\n#if YYERROR_VERBOSE\n  /* Buffer for error messages, and its allocated size.  */\n  char yymsgbuf[128];\n  char *yymsg = yymsgbuf;\n  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;\n#endif\n\n#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))\n\n  /* The number of symbols on the RHS of the reduced rule.\n     Keep to zero when no symbol should be popped.  */\n  int yylen = 0;\n\n  yyssp = yyss = yyssa;\n  yyvsp = yyvs = yyvsa;\n  yystacksize = YYINITDEPTH;\n\n  YYDPRINTF ((stderr, \"Starting parse\\n\"));\n\n  yystate = 0;\n  yyerrstatus = 0;\n  yynerrs = 0;\n  yychar = YYEMPTY; /* Cause a token to be read.  */\n  goto yysetstate;\n\n/*------------------------------------------------------------.\n| yynewstate -- Push a new state, which is found in yystate.  |\n`------------------------------------------------------------*/\n yynewstate:\n  /* In all cases, when you get here, the value and location stacks\n     have just been pushed.  So pushing a state here evens the stacks.  */\n  yyssp++;\n\n yysetstate:\n  *yyssp = yystate;\n\n  if (yyss + yystacksize - 1 <= yyssp)\n    {\n      /* Get the current used size of the three stacks, in elements.  */\n      YYSIZE_T yysize = yyssp - yyss + 1;\n\n#ifdef yyoverflow\n      {\n        /* Give user a chance to reallocate the stack.  Use copies of\n           these so that the &'s don't force the real ones into\n           memory.  */\n        YYSTYPE *yyvs1 = yyvs;\n        yytype_int16 *yyss1 = yyss;\n\n        /* Each stack pointer address is followed by the size of the\n           data in use in that stack, in bytes.  This used to be a\n           conditional around just the two extra args, but that might\n           be undefined if yyoverflow is a macro.  */\n        yyoverflow (YY_(\"memory exhausted\"),\n                    &yyss1, yysize * sizeof (*yyssp),\n                    &yyvs1, yysize * sizeof (*yyvsp),\n                    &yystacksize);\n\n        yyss = yyss1;\n        yyvs = yyvs1;\n      }\n#else /* no yyoverflow */\n# ifndef YYSTACK_RELOCATE\n      goto yyexhaustedlab;\n# else\n      /* Extend the stack our own way.  */\n      if (YYMAXDEPTH <= yystacksize)\n        goto yyexhaustedlab;\n      yystacksize *= 2;\n      if (YYMAXDEPTH < yystacksize)\n        yystacksize = YYMAXDEPTH;\n\n      {\n        yytype_int16 *yyss1 = yyss;\n        union yyalloc *yyptr =\n          (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));\n        if (! yyptr)\n          goto yyexhaustedlab;\n        YYSTACK_RELOCATE (yyss_alloc, yyss);\n        YYSTACK_RELOCATE (yyvs_alloc, yyvs);\n#  undef YYSTACK_RELOCATE\n        if (yyss1 != yyssa)\n          YYSTACK_FREE (yyss1);\n      }\n# endif\n#endif /* no yyoverflow */\n\n      yyssp = yyss + yysize - 1;\n      yyvsp = yyvs + yysize - 1;\n\n      YYDPRINTF ((stderr, \"Stack size increased to %lu\\n\",\n                  (unsigned long int) yystacksize));\n\n      if (yyss + yystacksize - 1 <= yyssp)\n        YYABORT;\n    }\n\n  YYDPRINTF ((stderr, \"Entering state %d\\n\", yystate));\n\n  if (yystate == YYFINAL)\n    YYACCEPT;\n\n  goto yybackup;\n\n/*-----------.\n| yybackup.  |\n`-----------*/\nyybackup:\n\n  /* Do appropriate processing given the current state.  Read a\n     lookahead token if we need one and don't already have one.  */\n\n  /* First try to decide what to do without reference to lookahead token.  */\n  yyn = yypact[yystate];\n  if (yypact_value_is_default (yyn))\n    goto yydefault;\n\n  /* Not known => get a lookahead token if don't already have one.  */\n\n  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */\n  if (yychar == YYEMPTY)\n    {\n      YYDPRINTF ((stderr, \"Reading a token: \"));\n      yychar = yylex (&yylval, yyscanner, compiler);\n    }\n\n  if (yychar <= YYEOF)\n    {\n      yychar = yytoken = YYEOF;\n      YYDPRINTF ((stderr, \"Now at end of input.\\n\"));\n    }\n  else\n    {\n      yytoken = YYTRANSLATE (yychar);\n      YY_SYMBOL_PRINT (\"Next token is\", yytoken, &yylval, &yylloc);\n    }\n\n  /* If the proper action on seeing token YYTOKEN is to reduce or to\n     detect an error, take that action.  */\n  yyn += yytoken;\n  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)\n    goto yydefault;\n  yyn = yytable[yyn];\n  if (yyn <= 0)\n    {\n      if (yytable_value_is_error (yyn))\n        goto yyerrlab;\n      yyn = -yyn;\n      goto yyreduce;\n    }\n\n  /* Count tokens shifted since error; after three, turn off error\n     status.  */\n  if (yyerrstatus)\n    yyerrstatus--;\n\n  /* Shift the lookahead token.  */\n  YY_SYMBOL_PRINT (\"Shifting\", yytoken, &yylval, &yylloc);\n\n  /* Discard the shifted token.  */\n  yychar = YYEMPTY;\n\n  yystate = yyn;\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  *++yyvsp = yylval;\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n\n  goto yynewstate;\n\n\n/*-----------------------------------------------------------.\n| yydefault -- do the default action for the current state.  |\n`-----------------------------------------------------------*/\nyydefault:\n  yyn = yydefact[yystate];\n  if (yyn == 0)\n    goto yyerrlab;\n  goto yyreduce;\n\n\n/*-----------------------------.\n| yyreduce -- Do a reduction.  |\n`-----------------------------*/\nyyreduce:\n  /* yyn is the number of a rule to reduce with.  */\n  yylen = yyr2[yyn];\n\n  /* If YYLEN is nonzero, implement the default value of the action:\n     '$$ = $1'.\n\n     Otherwise, the following line sets YYVAL to garbage.\n     This behavior is undocumented and Bison\n     users should not rely upon it.  Assigning to YYVAL\n     unconditionally makes the parser a bit smaller, and it avoids a\n     GCC warning that YYVAL may be used uninitialized.  */\n  yyval = yyvsp[1-yylen];\n\n\n  YY_REDUCE_PRINT (yyn);\n  switch (yyn)\n    {\n        case 8:\n#line 230 \"grammar.y\" /* yacc.c:1646  */\n    {\n        int result = yr_parser_reduce_import(yyscanner, (yyvsp[0].sized_string));\n\n        yr_free((yyvsp[0].sized_string));\n\n        ERROR_IF(result != ERROR_SUCCESS);\n      }\n#line 1661 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 9:\n#line 242 \"grammar.y\" /* yacc.c:1646  */\n    {\n        YR_RULE* rule = yr_parser_reduce_rule_declaration_phase_1(\n            yyscanner, (int32_t) (yyvsp[-2].integer), (yyvsp[0].c_string));\n\n        ERROR_IF(rule == NULL);\n\n        (yyval.rule) = rule;\n      }\n#line 1674 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 10:\n#line 251 \"grammar.y\" /* yacc.c:1646  */\n    {\n        YR_RULE* rule = (yyvsp[-4].rule); // rule created in phase 1\n\n        rule->tags = (yyvsp[-3].c_string);\n        rule->metas = (yyvsp[-1].meta);\n        rule->strings = (yyvsp[0].string);\n      }\n#line 1686 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 11:\n#line 259 \"grammar.y\" /* yacc.c:1646  */\n    {\n        YR_RULE* rule = (yyvsp[-7].rule); // rule created in phase 1\n\n        compiler->last_result = yr_parser_reduce_rule_declaration_phase_2(\n            yyscanner, rule);\n\n        yr_free((yyvsp[-8].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n      }\n#line 1701 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 12:\n#line 274 \"grammar.y\" /* yacc.c:1646  */\n    {\n        (yyval.meta) = NULL;\n      }\n#line 1709 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 13:\n#line 278 \"grammar.y\" /* yacc.c:1646  */\n    {\n\n        YR_META null_meta;\n\n        memset(&null_meta, 0xFF, sizeof(YR_META));\n        null_meta.type = META_TYPE_NULL;\n\n        compiler->last_result = yr_arena_write_data(\n            compiler->metas_arena,\n            &null_meta,\n            sizeof(YR_META),\n            NULL);\n\n        (yyval.meta) = (yyvsp[0].meta);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n      }\n#line 1736 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 14:\n#line 305 \"grammar.y\" /* yacc.c:1646  */\n    {\n        (yyval.string) = NULL;\n      }\n#line 1744 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 15:\n#line 309 \"grammar.y\" /* yacc.c:1646  */\n    {\n\n        YR_STRING null_string;\n\n        memset(&null_string, 0xFF, sizeof(YR_STRING));\n        null_string.g_flags = STRING_GFLAGS_NULL;\n\n        compiler->last_result = yr_arena_write_data(\n            compiler->strings_arena,\n            &null_string,\n            sizeof(YR_STRING),\n            NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        (yyval.string) = (yyvsp[0].string);\n      }\n#line 1771 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 17:\n#line 340 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.integer) = 0;  }\n#line 1777 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 18:\n#line 341 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }\n#line 1783 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 19:\n#line 346 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.integer) = RULE_GFLAGS_PRIVATE; }\n#line 1789 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 20:\n#line 347 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.integer) = RULE_GFLAGS_GLOBAL; }\n#line 1795 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 21:\n#line 353 \"grammar.y\" /* yacc.c:1646  */\n    {\n        (yyval.c_string) = NULL;\n      }\n#line 1803 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 22:\n#line 357 \"grammar.y\" /* yacc.c:1646  */\n    {\n\n        compiler->last_result = yr_arena_write_string(\n            yyget_extra(yyscanner)->sz_arena, \"\", NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        (yyval.c_string) = (yyvsp[0].c_string);\n      }\n#line 1821 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 23:\n#line 375 \"grammar.y\" /* yacc.c:1646  */\n    {\n        char* identifier;\n\n        compiler->last_result = yr_arena_write_string(\n            yyget_extra(yyscanner)->sz_arena, (yyvsp[0].c_string), &identifier);\n\n        yr_free((yyvsp[0].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        (yyval.c_string) = identifier;\n      }\n#line 1838 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 24:\n#line 388 \"grammar.y\" /* yacc.c:1646  */\n    {\n        char* tag_name = (yyvsp[-1].c_string);\n        size_t tag_length = tag_name != NULL ? strlen(tag_name) : 0;\n\n        while (tag_length > 0)\n        {\n          if (strcmp(tag_name, (yyvsp[0].c_string)) == 0)\n          {\n            yr_compiler_set_error_extra_info(compiler, tag_name);\n            compiler->last_result = ERROR_DUPLICATED_TAG_IDENTIFIER;\n            break;\n          }\n\n          tag_name = (char*) yr_arena_next_address(\n              yyget_extra(yyscanner)->sz_arena,\n              tag_name,\n              tag_length + 1);\n\n          tag_length = tag_name != NULL ? strlen(tag_name) : 0;\n        }\n\n        if (compiler->last_result == ERROR_SUCCESS)\n          compiler->last_result = yr_arena_write_string(\n              yyget_extra(yyscanner)->sz_arena, (yyvsp[0].c_string), NULL);\n\n        yr_free((yyvsp[0].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        (yyval.c_string) = (yyvsp[-1].c_string);\n      }\n#line 1874 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 25:\n#line 424 \"grammar.y\" /* yacc.c:1646  */\n    {  (yyval.meta) = (yyvsp[0].meta); }\n#line 1880 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 26:\n#line 425 \"grammar.y\" /* yacc.c:1646  */\n    {  (yyval.meta) = (yyvsp[-1].meta); }\n#line 1886 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 27:\n#line 431 \"grammar.y\" /* yacc.c:1646  */\n    {\n        SIZED_STRING* sized_string = (yyvsp[0].sized_string);\n\n        (yyval.meta) = yr_parser_reduce_meta_declaration(\n            yyscanner,\n            META_TYPE_STRING,\n            (yyvsp[-2].c_string),\n            sized_string->c_string,\n            0);\n\n        yr_free((yyvsp[-2].c_string));\n        yr_free((yyvsp[0].sized_string));\n\n        ERROR_IF((yyval.meta) == NULL);\n      }\n#line 1906 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 28:\n#line 447 \"grammar.y\" /* yacc.c:1646  */\n    {\n        (yyval.meta) = yr_parser_reduce_meta_declaration(\n            yyscanner,\n            META_TYPE_INTEGER,\n            (yyvsp[-2].c_string),\n            NULL,\n            (yyvsp[0].integer));\n\n        yr_free((yyvsp[-2].c_string));\n\n        ERROR_IF((yyval.meta) == NULL);\n      }\n#line 1923 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 29:\n#line 460 \"grammar.y\" /* yacc.c:1646  */\n    {\n        (yyval.meta) = yr_parser_reduce_meta_declaration(\n            yyscanner,\n            META_TYPE_INTEGER,\n            (yyvsp[-3].c_string),\n            NULL,\n            -(yyvsp[0].integer));\n\n        yr_free((yyvsp[-3].c_string));\n\n        ERROR_IF((yyval.meta) == NULL);\n      }\n#line 1940 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 30:\n#line 473 \"grammar.y\" /* yacc.c:1646  */\n    {\n        (yyval.meta) = yr_parser_reduce_meta_declaration(\n            yyscanner,\n            META_TYPE_BOOLEAN,\n            (yyvsp[-2].c_string),\n            NULL,\n            TRUE);\n\n        yr_free((yyvsp[-2].c_string));\n\n        ERROR_IF((yyval.meta) == NULL);\n      }\n#line 1957 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 31:\n#line 486 \"grammar.y\" /* yacc.c:1646  */\n    {\n        (yyval.meta) = yr_parser_reduce_meta_declaration(\n            yyscanner,\n            META_TYPE_BOOLEAN,\n            (yyvsp[-2].c_string),\n            NULL,\n            FALSE);\n\n        yr_free((yyvsp[-2].c_string));\n\n        ERROR_IF((yyval.meta) == NULL);\n      }\n#line 1974 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 32:\n#line 502 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.string) = (yyvsp[0].string); }\n#line 1980 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 33:\n#line 503 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.string) = (yyvsp[-1].string); }\n#line 1986 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 34:\n#line 509 \"grammar.y\" /* yacc.c:1646  */\n    {\n        compiler->error_line = yyget_lineno(yyscanner);\n      }\n#line 1994 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 35:\n#line 513 \"grammar.y\" /* yacc.c:1646  */\n    {\n        (yyval.string) = yr_parser_reduce_string_declaration(\n            yyscanner, (int32_t) (yyvsp[0].integer), (yyvsp[-4].c_string), (yyvsp[-1].sized_string));\n\n        yr_free((yyvsp[-4].c_string));\n        yr_free((yyvsp[-1].sized_string));\n\n        ERROR_IF((yyval.string) == NULL);\n        compiler->error_line = 0;\n      }\n#line 2009 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 36:\n#line 524 \"grammar.y\" /* yacc.c:1646  */\n    {\n        compiler->error_line = yyget_lineno(yyscanner);\n      }\n#line 2017 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 37:\n#line 528 \"grammar.y\" /* yacc.c:1646  */\n    {\n        (yyval.string) = yr_parser_reduce_string_declaration(\n            yyscanner, (int32_t) (yyvsp[0].integer) | STRING_GFLAGS_REGEXP, (yyvsp[-4].c_string), (yyvsp[-1].sized_string));\n\n        yr_free((yyvsp[-4].c_string));\n        yr_free((yyvsp[-1].sized_string));\n\n        ERROR_IF((yyval.string) == NULL);\n\n        compiler->error_line = 0;\n      }\n#line 2033 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 38:\n#line 540 \"grammar.y\" /* yacc.c:1646  */\n    {\n        (yyval.string) = yr_parser_reduce_string_declaration(\n            yyscanner, STRING_GFLAGS_HEXADECIMAL, (yyvsp[-2].c_string), (yyvsp[0].sized_string));\n\n        yr_free((yyvsp[-2].c_string));\n        yr_free((yyvsp[0].sized_string));\n\n        ERROR_IF((yyval.string) == NULL);\n      }\n#line 2047 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 39:\n#line 553 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.integer) = 0; }\n#line 2053 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 40:\n#line 554 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }\n#line 2059 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 41:\n#line 559 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.integer) = STRING_GFLAGS_WIDE; }\n#line 2065 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 42:\n#line 560 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.integer) = STRING_GFLAGS_ASCII; }\n#line 2071 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 43:\n#line 561 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.integer) = STRING_GFLAGS_NO_CASE; }\n#line 2077 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 44:\n#line 562 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.integer) = STRING_GFLAGS_FULL_WORD; }\n#line 2083 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 45:\n#line 568 \"grammar.y\" /* yacc.c:1646  */\n    {\n        int var_index = yr_parser_lookup_loop_variable(yyscanner, (yyvsp[0].c_string));\n\n        if (var_index >= 0)\n        {\n          compiler->last_result = yr_parser_emit_with_arg(\n              yyscanner,\n              OP_PUSH_M,\n              LOOP_LOCAL_VARS * var_index,\n              NULL,\n              NULL);\n\n          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n          (yyval.expression).value.integer = UNDEFINED;\n          (yyval.expression).identifier = compiler->loop_identifier[var_index];\n        }\n        else\n        {\n\n          YR_OBJECT* object = (YR_OBJECT*) yr_hash_table_lookup(\n              compiler->objects_table, (yyvsp[0].c_string), NULL);\n\n          if (object == NULL)\n          {\n            char* ns = compiler->current_namespace->name;\n\n            object = (YR_OBJECT*) yr_hash_table_lookup(\n                compiler->objects_table, (yyvsp[0].c_string), ns);\n          }\n\n          if (object != NULL)\n          {\n            char* id;\n\n            compiler->last_result = yr_arena_write_string(\n                compiler->sz_arena, (yyvsp[0].c_string), &id);\n\n            if (compiler->last_result == ERROR_SUCCESS)\n              compiler->last_result = yr_parser_emit_with_arg_reloc(\n                  yyscanner,\n                  OP_OBJ_LOAD,\n                  id,\n                  NULL,\n                  NULL);\n\n            (yyval.expression).type = EXPRESSION_TYPE_OBJECT;\n            (yyval.expression).value.object = object;\n            (yyval.expression).identifier = object->identifier;\n          }\n          else\n          {\n            YR_RULE* rule = (YR_RULE*) yr_hash_table_lookup(\n                compiler->rules_table,\n                (yyvsp[0].c_string),\n                compiler->current_namespace->name);\n\n            if (rule != NULL)\n            {\n              compiler->last_result = yr_parser_emit_with_arg_reloc(\n                  yyscanner,\n                  OP_PUSH_RULE,\n                  rule,\n                  NULL,\n                  NULL);\n\n              (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n              (yyval.expression).value.integer = UNDEFINED;\n              (yyval.expression).identifier = rule->identifier;\n            }\n            else\n            {\n              yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));\n              compiler->last_result = ERROR_UNDEFINED_IDENTIFIER;\n            }\n          }\n        }\n\n        yr_free((yyvsp[0].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n      }\n#line 2172 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 46:\n#line 653 \"grammar.y\" /* yacc.c:1646  */\n    {\n        YR_OBJECT* field = NULL;\n\n        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_OBJECT &&\n            (yyvsp[-2].expression).value.object->type == OBJECT_TYPE_STRUCTURE)\n        {\n          field = yr_object_lookup_field((yyvsp[-2].expression).value.object, (yyvsp[0].c_string));\n\n          if (field != NULL)\n          {\n            char* ident;\n\n            compiler->last_result = yr_arena_write_string(\n              compiler->sz_arena, (yyvsp[0].c_string), &ident);\n\n            if (compiler->last_result == ERROR_SUCCESS)\n              compiler->last_result = yr_parser_emit_with_arg_reloc(\n                  yyscanner,\n                  OP_OBJ_FIELD,\n                  ident,\n                  NULL,\n                  NULL);\n\n            (yyval.expression).type = EXPRESSION_TYPE_OBJECT;\n            (yyval.expression).value.object = field;\n            (yyval.expression).identifier = field->identifier;\n          }\n          else\n          {\n            yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));\n            compiler->last_result = ERROR_INVALID_FIELD_NAME;\n          }\n        }\n        else\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, (yyvsp[-2].expression).identifier);\n\n          compiler->last_result = ERROR_NOT_A_STRUCTURE;\n        }\n\n        yr_free((yyvsp[0].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n      }\n#line 2222 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 47:\n#line 699 \"grammar.y\" /* yacc.c:1646  */\n    {\n        YR_OBJECT_ARRAY* array;\n        YR_OBJECT_DICTIONARY* dict;\n\n        if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&\n            (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_ARRAY)\n        {\n          if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)\n          {\n            yr_compiler_set_error_extra_info(\n                compiler, \"array indexes must be of integer type\");\n            compiler->last_result = ERROR_WRONG_TYPE;\n          }\n\n          ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n          compiler->last_result = yr_parser_emit(\n              yyscanner, OP_INDEX_ARRAY, NULL);\n\n          array = (YR_OBJECT_ARRAY*) (yyvsp[-3].expression).value.object;\n\n          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;\n          (yyval.expression).value.object = array->prototype_item;\n          (yyval.expression).identifier = array->identifier;\n        }\n        else if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&\n                 (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_DICTIONARY)\n        {\n          if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_STRING)\n          {\n            yr_compiler_set_error_extra_info(\n                compiler, \"dictionary keys must be of string type\");\n            compiler->last_result = ERROR_WRONG_TYPE;\n          }\n\n          ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n          compiler->last_result = yr_parser_emit(\n              yyscanner, OP_LOOKUP_DICT, NULL);\n\n          dict = (YR_OBJECT_DICTIONARY*) (yyvsp[-3].expression).value.object;\n\n          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;\n          (yyval.expression).value.object = dict->prototype_item;\n          (yyval.expression).identifier = dict->identifier;\n        }\n        else\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, (yyvsp[-3].expression).identifier);\n\n          compiler->last_result = ERROR_NOT_INDEXABLE;\n        }\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n      }\n#line 2283 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 48:\n#line 757 \"grammar.y\" /* yacc.c:1646  */\n    {\n        YR_OBJECT_FUNCTION* function;\n        char* args_fmt;\n\n        if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&\n            (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_FUNCTION)\n        {\n          compiler->last_result = yr_parser_check_types(\n              compiler, (YR_OBJECT_FUNCTION*) (yyvsp[-3].expression).value.object, (yyvsp[-1].c_string));\n\n          if (compiler->last_result == ERROR_SUCCESS)\n            compiler->last_result = yr_arena_write_string(\n              compiler->sz_arena, (yyvsp[-1].c_string), &args_fmt);\n\n          if (compiler->last_result == ERROR_SUCCESS)\n            compiler->last_result = yr_parser_emit_with_arg_reloc(\n                yyscanner,\n                OP_CALL,\n                args_fmt,\n                NULL,\n                NULL);\n\n          function = (YR_OBJECT_FUNCTION*) (yyvsp[-3].expression).value.object;\n\n          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;\n          (yyval.expression).value.object = function->return_obj;\n          (yyval.expression).identifier = function->identifier;\n        }\n        else\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, (yyvsp[-3].expression).identifier);\n\n          compiler->last_result = ERROR_NOT_A_FUNCTION;\n        }\n\n        yr_free((yyvsp[-1].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n      }\n#line 2328 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 49:\n#line 801 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.c_string) = yr_strdup(\"\"); }\n#line 2334 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 50:\n#line 802 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.c_string) = (yyvsp[0].c_string); }\n#line 2340 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 51:\n#line 807 \"grammar.y\" /* yacc.c:1646  */\n    {\n        (yyval.c_string) = (char*) yr_malloc(MAX_FUNCTION_ARGS + 1);\n\n        switch((yyvsp[0].expression).type)\n        {\n          case EXPRESSION_TYPE_INTEGER:\n            strlcpy((yyval.c_string), \"i\", MAX_FUNCTION_ARGS);\n            break;\n          case EXPRESSION_TYPE_FLOAT:\n            strlcpy((yyval.c_string), \"f\", MAX_FUNCTION_ARGS);\n            break;\n          case EXPRESSION_TYPE_BOOLEAN:\n            strlcpy((yyval.c_string), \"b\", MAX_FUNCTION_ARGS);\n            break;\n          case EXPRESSION_TYPE_STRING:\n            strlcpy((yyval.c_string), \"s\", MAX_FUNCTION_ARGS);\n            break;\n           case EXPRESSION_TYPE_REGEXP:\n             strlcpy((yyval.c_string), \"r\", MAX_FUNCTION_ARGS);\n             break;\n          default:\n            assert(FALSE);\n         }\n \n         ERROR_IF((yyval.c_string) == NULL);\n       }\n#line 2371 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 52:\n#line 834 \"grammar.y\" /* yacc.c:1646  */\n     {\n         if (strlen((yyvsp[-2].c_string)) == MAX_FUNCTION_ARGS)\n         {\n          compiler->last_result = ERROR_TOO_MANY_ARGUMENTS;\n        }\n        else\n        {\n          switch((yyvsp[0].expression).type)\n          {\n            case EXPRESSION_TYPE_INTEGER:\n              strlcat((yyvsp[-2].c_string), \"i\", MAX_FUNCTION_ARGS);\n              break;\n            case EXPRESSION_TYPE_FLOAT:\n              strlcat((yyvsp[-2].c_string), \"f\", MAX_FUNCTION_ARGS);\n              break;\n            case EXPRESSION_TYPE_BOOLEAN:\n              strlcat((yyvsp[-2].c_string), \"b\", MAX_FUNCTION_ARGS);\n              break;\n            case EXPRESSION_TYPE_STRING:\n              strlcat((yyvsp[-2].c_string), \"s\", MAX_FUNCTION_ARGS);\n              break;\n             case EXPRESSION_TYPE_REGEXP:\n               strlcat((yyvsp[-2].c_string), \"r\", MAX_FUNCTION_ARGS);\n               break;\n            default:\n              assert(FALSE);\n           }\n         }\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n \n         (yyval.c_string) = (yyvsp[-2].c_string);\n       }\n#line 2409 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 53:\n#line 872 \"grammar.y\" /* yacc.c:1646  */\n     {\n         SIZED_STRING* sized_string = (yyvsp[0].sized_string);\n         RE* re;\n        RE_ERROR error;\n\n        int re_flags = 0;\n\n        if (sized_string->flags & SIZED_STRING_FLAGS_NO_CASE)\n          re_flags |= RE_FLAGS_NO_CASE;\n\n        if (sized_string->flags & SIZED_STRING_FLAGS_DOT_ALL)\n          re_flags |= RE_FLAGS_DOT_ALL;\n\n        compiler->last_result = yr_re_compile(\n            sized_string->c_string,\n            re_flags,\n            compiler->re_code_arena,\n            &re,\n            &error);\n\n        yr_free((yyvsp[0].sized_string));\n\n        if (compiler->last_result == ERROR_INVALID_REGULAR_EXPRESSION)\n          yr_compiler_set_error_extra_info(compiler, error.message);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        if (compiler->last_result == ERROR_SUCCESS)\n          compiler->last_result = yr_parser_emit_with_arg_reloc(\n              yyscanner,\n              OP_PUSH,\n              re->root_node->forward_code,\n              NULL,\n              NULL);\n\n        yr_re_destroy(re);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n \n         (yyval.expression).type = EXPRESSION_TYPE_REGEXP;\n       }\n#line 2455 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 54:\n#line 918 \"grammar.y\" /* yacc.c:1646  */\n     {\n         if ((yyvsp[0].expression).type == EXPRESSION_TYPE_STRING)\n         {\n          if ((yyvsp[0].expression).value.sized_string != NULL)\n          {\n            yywarning(yyscanner,\n              \"Using literal string \\\"%s\\\" in a boolean operation.\",\n              (yyvsp[0].expression).value.sized_string->c_string);\n          }\n\n          compiler->last_result = yr_parser_emit(\n              yyscanner, OP_STR_TO_BOOL, NULL);\n\n          ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n        }\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 2478 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 55:\n#line 940 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_emit_with_arg(\n             yyscanner, OP_PUSH, 1, NULL, NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 2491 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 56:\n#line 949 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_emit_with_arg(\n             yyscanner, OP_PUSH, 0, NULL, NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 2504 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 57:\n#line 958 \"grammar.y\" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, \"matches\");\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_REGEXP, \"matches\");\n\n        if (compiler->last_result == ERROR_SUCCESS)\n          compiler->last_result = yr_parser_emit(\n              yyscanner,\n              OP_MATCHES,\n              NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 2523 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 58:\n#line 973 \"grammar.y\" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, \"contains\");\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_STRING, \"contains\");\n\n        compiler->last_result = yr_parser_emit(\n            yyscanner, OP_CONTAINS, NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 2539 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 59:\n#line 985 \"grammar.y\" /* yacc.c:1646  */\n     {\n         int result = yr_parser_reduce_string_identifier(\n             yyscanner,\n            (yyvsp[0].c_string),\n            OP_FOUND,\n            UNDEFINED);\n\n        yr_free((yyvsp[0].c_string));\n\n        ERROR_IF(result != ERROR_SUCCESS);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 2557 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 60:\n#line 999 \"grammar.y\" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"at\");\n \n        compiler->last_result = yr_parser_reduce_string_identifier(\n            yyscanner, (yyvsp[-2].c_string), OP_FOUND_AT, (yyvsp[0].expression).value.integer);\n\n        yr_free((yyvsp[-2].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 2574 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 61:\n#line 1012 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_string_identifier(\n             yyscanner, (yyvsp[-2].c_string), OP_FOUND_IN, UNDEFINED);\n\n        yr_free((yyvsp[-2].c_string));\n\n        ERROR_IF(compiler->last_result!= ERROR_SUCCESS);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 2589 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 62:\n#line 1023 \"grammar.y\" /* yacc.c:1646  */\n     {\n         if (compiler->loop_depth > 0)\n         {\n           compiler->loop_depth--;\n           compiler->loop_identifier[compiler->loop_depth] = NULL;\n         }\n\n        YYERROR;\n       }\n#line 2603 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 63:\n#line 1033 \"grammar.y\" /* yacc.c:1646  */\n     {\n         int var_index;\n \n        if (compiler->loop_depth == MAX_LOOP_NESTING)\n          compiler->last_result = \\\n              ERROR_LOOP_NESTING_LIMIT_EXCEEDED;\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        var_index = yr_parser_lookup_loop_variable(\n            yyscanner, (yyvsp[-1].c_string));\n\n        if (var_index >= 0)\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, (yyvsp[-1].c_string));\n\n          compiler->last_result = \\\n              ERROR_DUPLICATED_LOOP_IDENTIFIER;\n        }\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        compiler->last_result = yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n#line 2637 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 64:\n#line 1063 \"grammar.y\" /* yacc.c:1646  */\n     {\n         int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;\n         uint8_t* addr;\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);\n\n        if ((yyvsp[-1].integer) == INTEGER_SET_ENUMERATION)\n        {\n          yr_parser_emit_with_arg(\n              yyscanner, OP_POP_M, mem_offset, &addr, NULL);\n        }\n        else // INTEGER_SET_RANGE\n        {\n          yr_parser_emit_with_arg(\n              yyscanner, OP_POP_M, mem_offset + 3, &addr, NULL);\n\n          yr_parser_emit_with_arg(\n              yyscanner, OP_POP_M, mem_offset, NULL, NULL);\n        }\n\n        compiler->loop_address[compiler->loop_depth] = addr;\n         compiler->loop_identifier[compiler->loop_depth] = (yyvsp[-4].c_string);\n         compiler->loop_depth++;\n       }\n#line 2676 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 65:\n#line 1098 \"grammar.y\" /* yacc.c:1646  */\n     {\n         int mem_offset;\n \n        compiler->loop_depth--;\n        mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;\n\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);\n\n        if ((yyvsp[-5].integer) == INTEGER_SET_ENUMERATION)\n        {\n          yr_parser_emit_with_arg_reloc(\n              yyscanner,\n              OP_JNUNDEF,\n              compiler->loop_address[compiler->loop_depth],\n              NULL,\n              NULL);\n        }\n        else // INTEGER_SET_RANGE\n        {\n          yr_parser_emit_with_arg(\n              yyscanner, OP_INCR_M, mem_offset, NULL, NULL);\n\n          yr_parser_emit_with_arg(\n              yyscanner, OP_PUSH_M, mem_offset, NULL, NULL);\n\n          yr_parser_emit_with_arg(\n              yyscanner, OP_PUSH_M, mem_offset + 3, NULL, NULL);\n\n          yr_parser_emit_with_arg_reloc(\n              yyscanner,\n              OP_JLE,\n              compiler->loop_address[compiler->loop_depth],\n              NULL,\n              NULL);\n\n          yr_parser_emit(yyscanner, OP_POP, NULL);\n          yr_parser_emit(yyscanner, OP_POP, NULL);\n        }\n\n        yr_parser_emit(yyscanner, OP_POP, NULL);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);\n\n        yr_parser_emit(yyscanner, OP_INT_LE, NULL);\n\n        compiler->loop_identifier[compiler->loop_depth] = NULL;\n        yr_free((yyvsp[-8].c_string));\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 2759 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 66:\n#line 1177 \"grammar.y\" /* yacc.c:1646  */\n     {\n         int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;\n         uint8_t* addr;\n\n        if (compiler->loop_depth == MAX_LOOP_NESTING)\n          compiler->last_result = \\\n            ERROR_LOOP_NESTING_LIMIT_EXCEEDED;\n\n        if (compiler->loop_for_of_mem_offset != -1)\n          compiler->last_result = \\\n            ERROR_NESTED_FOR_OF_LOOP;\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_POP_M, mem_offset, &addr, NULL);\n\n        compiler->loop_for_of_mem_offset = mem_offset;\n        compiler->loop_address[compiler->loop_depth] = addr;\n         compiler->loop_identifier[compiler->loop_depth] = NULL;\n         compiler->loop_depth++;\n       }\n#line 2793 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 67:\n#line 1207 \"grammar.y\" /* yacc.c:1646  */\n     {\n         int mem_offset;\n \n        compiler->loop_depth--;\n        compiler->loop_for_of_mem_offset = -1;\n\n        mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;\n\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);\n\n        yr_parser_emit_with_arg_reloc(\n            yyscanner,\n            OP_JNUNDEF,\n            compiler->loop_address[compiler->loop_depth],\n            NULL,\n            NULL);\n\n        yr_parser_emit(yyscanner, OP_POP, NULL);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);\n\n        yr_parser_emit(yyscanner, OP_INT_LE, NULL);\n\n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n \n       }\n#line 2846 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 68:\n#line 1256 \"grammar.y\" /* yacc.c:1646  */\n     {\n         yr_parser_emit(yyscanner, OP_OF, NULL);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 2856 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 69:\n#line 1262 \"grammar.y\" /* yacc.c:1646  */\n     {\n         yr_parser_emit(yyscanner, OP_NOT, NULL);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 2866 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 70:\n#line 1268 \"grammar.y\" /* yacc.c:1646  */\n     {\n         YR_FIXUP* fixup;\n         void* jmp_destination_addr;\n\n        compiler->last_result = yr_parser_emit_with_arg_reloc(\n            yyscanner,\n            OP_JFALSE,\n            0,          // still don't know the jump destination\n            NULL,\n            &jmp_destination_addr);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));\n\n        if (fixup == NULL)\n          compiler->last_error = ERROR_INSUFFICIENT_MEMORY;\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        fixup->address = jmp_destination_addr;\n         fixup->next = compiler->fixup_stack_head;\n         compiler->fixup_stack_head = fixup;\n       }\n#line 2896 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 71:\n#line 1294 \"grammar.y\" /* yacc.c:1646  */\n     {\n         YR_FIXUP* fixup;\n         uint8_t* and_addr;\n\n\n        compiler->last_result = yr_arena_reserve_memory(\n            compiler->code_arena, 2);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        compiler->last_result = yr_parser_emit(yyscanner, OP_AND, &and_addr);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n\n        fixup = compiler->fixup_stack_head;\n\n\n        *(void**)(fixup->address) = (void*)(and_addr + 1);\n\n        compiler->fixup_stack_head = fixup->next;\n        yr_free(fixup);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 2936 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 72:\n#line 1330 \"grammar.y\" /* yacc.c:1646  */\n     {\n         YR_FIXUP* fixup;\n         void* jmp_destination_addr;\n\n        compiler->last_result = yr_parser_emit_with_arg_reloc(\n            yyscanner,\n            OP_JTRUE,\n            0,         // still don't know the jump destination\n            NULL,\n            &jmp_destination_addr);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));\n\n        if (fixup == NULL)\n          compiler->last_error = ERROR_INSUFFICIENT_MEMORY;\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        fixup->address = jmp_destination_addr;\n         fixup->next = compiler->fixup_stack_head;\n         compiler->fixup_stack_head = fixup;\n       }\n#line 2965 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 73:\n#line 1355 \"grammar.y\" /* yacc.c:1646  */\n     {\n         YR_FIXUP* fixup;\n         uint8_t* or_addr;\n\n\n        compiler->last_result = yr_arena_reserve_memory(\n            compiler->code_arena, 2);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        compiler->last_result = yr_parser_emit(yyscanner, OP_OR, &or_addr);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n\n        fixup = compiler->fixup_stack_head;\n\n\n        *(void**)(fixup->address) = (void*)(or_addr + 1);\n\n        compiler->fixup_stack_head = fixup->next;\n        yr_free(fixup);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 3005 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 74:\n#line 1391 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \"<\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 3018 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 75:\n#line 1400 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \">\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 3031 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 76:\n#line 1409 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \"<=\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 3044 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 77:\n#line 1418 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \">=\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 3057 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 78:\n#line 1427 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \"==\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 3070 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 79:\n#line 1436 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \"!=\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 3083 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 80:\n#line 1445 \"grammar.y\" /* yacc.c:1646  */\n     {\n         (yyval.expression) = (yyvsp[0].expression);\n       }\n#line 3091 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 81:\n#line 1449 \"grammar.y\" /* yacc.c:1646  */\n     {\n         (yyval.expression) = (yyvsp[-1].expression);\n       }\n#line 3099 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 82:\n#line 1456 \"grammar.y\" /* yacc.c:1646  */\n     { (yyval.integer) = INTEGER_SET_ENUMERATION; }\n#line 3105 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 83:\n#line 1457 \"grammar.y\" /* yacc.c:1646  */\n     { (yyval.integer) = INTEGER_SET_RANGE; }\n#line 3111 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 84:\n#line 1463 \"grammar.y\" /* yacc.c:1646  */\n     {\n         if ((yyvsp[-3].expression).type != EXPRESSION_TYPE_INTEGER)\n         {\n          yr_compiler_set_error_extra_info(\n              compiler, \"wrong type for range's lower bound\");\n          compiler->last_result = ERROR_WRONG_TYPE;\n        }\n\n        if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, \"wrong type for range's upper bound\");\n          compiler->last_result = ERROR_WRONG_TYPE;\n        }\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n#line 3133 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 85:\n#line 1485 \"grammar.y\" /* yacc.c:1646  */\n     {\n         if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)\n         {\n          yr_compiler_set_error_extra_info(\n              compiler, \"wrong type for enumeration item\");\n          compiler->last_result = ERROR_WRONG_TYPE;\n\n        }\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n#line 3149 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 86:\n#line 1497 \"grammar.y\" /* yacc.c:1646  */\n     {\n         if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)\n         {\n          yr_compiler_set_error_extra_info(\n              compiler, \"wrong type for enumeration item\");\n          compiler->last_result = ERROR_WRONG_TYPE;\n        }\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n#line 3164 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 87:\n#line 1512 \"grammar.y\" /* yacc.c:1646  */\n     {\n         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);\n       }\n#line 3173 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 89:\n#line 1518 \"grammar.y\" /* yacc.c:1646  */\n     {\n         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);\n         yr_parser_emit_pushes_for_strings(yyscanner, \"$*\");\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n#line 3184 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 92:\n#line 1535 \"grammar.y\" /* yacc.c:1646  */\n     {\n         yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));\n         yr_free((yyvsp[0].c_string));\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n#line 3195 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 93:\n#line 1542 \"grammar.y\" /* yacc.c:1646  */\n     {\n         yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));\n         yr_free((yyvsp[0].c_string));\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n#line 3206 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 95:\n#line 1554 \"grammar.y\" /* yacc.c:1646  */\n     {\n         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);\n       }\n#line 3214 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 96:\n#line 1558 \"grammar.y\" /* yacc.c:1646  */\n     {\n         yr_parser_emit_with_arg(yyscanner, OP_PUSH, 1, NULL, NULL);\n       }\n#line 3222 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 97:\n#line 1566 \"grammar.y\" /* yacc.c:1646  */\n     {\n         (yyval.expression) = (yyvsp[-1].expression);\n       }\n#line 3230 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 98:\n#line 1570 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_emit(\n             yyscanner, OP_FILESIZE, NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n#line 3244 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 99:\n#line 1580 \"grammar.y\" /* yacc.c:1646  */\n     {\n         yywarning(yyscanner,\n             \"Using deprecated \\\"entrypoint\\\" keyword. Use the \\\"entry_point\\\" \"\n            \"function from PE module instead.\");\n\n        compiler->last_result = yr_parser_emit(\n            yyscanner, OP_ENTRYPOINT, NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n#line 3262 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 100:\n#line 1594 \"grammar.y\" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[-1].expression), EXPRESSION_TYPE_INTEGER, \"intXXXX or uintXXXX\");\n \n\n        compiler->last_result = yr_parser_emit(\n            yyscanner, (uint8_t) (OP_READ_INT + (yyvsp[-3].integer)), NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n#line 3282 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 101:\n#line 1610 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_emit_with_arg(\n             yyscanner, OP_PUSH, (yyvsp[0].integer), NULL, NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = (yyvsp[0].integer);\n       }\n#line 3296 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 102:\n#line 1620 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_emit_with_arg_double(\n             yyscanner, OP_PUSH, (yyvsp[0].double_), NULL, NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n \n         (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n       }\n#line 3309 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 103:\n#line 1629 \"grammar.y\" /* yacc.c:1646  */\n     {\n         SIZED_STRING* sized_string;\n \n        compiler->last_result = yr_arena_write_data(\n            compiler->sz_arena,\n            (yyvsp[0].sized_string),\n            (yyvsp[0].sized_string)->length + sizeof(SIZED_STRING),\n            (void**) &sized_string);\n\n        yr_free((yyvsp[0].sized_string));\n\n        if (compiler->last_result == ERROR_SUCCESS)\n          compiler->last_result = yr_parser_emit_with_arg_reloc(\n              yyscanner,\n              OP_PUSH,\n              sized_string,\n              NULL,\n              NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n         (yyval.expression).type = EXPRESSION_TYPE_STRING;\n         (yyval.expression).value.sized_string = sized_string;\n       }\n#line 3338 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 104:\n#line 1654 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_string_identifier(\n             yyscanner, (yyvsp[0].c_string), OP_COUNT, UNDEFINED);\n\n        yr_free((yyvsp[0].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n#line 3354 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 105:\n#line 1666 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_string_identifier(\n             yyscanner, (yyvsp[-3].c_string), OP_OFFSET, UNDEFINED);\n\n        yr_free((yyvsp[-3].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n#line 3370 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 106:\n#line 1678 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_emit_with_arg(\n             yyscanner, OP_PUSH, 1, NULL, NULL);\n\n        if (compiler->last_result == ERROR_SUCCESS)\n          compiler->last_result = yr_parser_reduce_string_identifier(\n              yyscanner, (yyvsp[0].c_string), OP_OFFSET, UNDEFINED);\n\n        yr_free((yyvsp[0].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n#line 3390 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 107:\n#line 1694 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_string_identifier(\n             yyscanner, (yyvsp[-3].c_string), OP_LENGTH, UNDEFINED);\n\n        yr_free((yyvsp[-3].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n#line 3406 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 108:\n#line 1706 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_emit_with_arg(\n             yyscanner, OP_PUSH, 1, NULL, NULL);\n\n        if (compiler->last_result == ERROR_SUCCESS)\n          compiler->last_result = yr_parser_reduce_string_identifier(\n              yyscanner, (yyvsp[0].c_string), OP_LENGTH, UNDEFINED);\n\n        yr_free((yyvsp[0].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n#line 3426 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 109:\n#line 1722 \"grammar.y\" /* yacc.c:1646  */\n     {\n         if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)  // loop identifier\n         {\n          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n          (yyval.expression).value.integer = UNDEFINED;\n        }\n        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_BOOLEAN)  // rule identifier\n        {\n          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n          (yyval.expression).value.integer = UNDEFINED;\n        }\n        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_OBJECT)\n        {\n          compiler->last_result = yr_parser_emit(\n              yyscanner, OP_OBJ_VALUE, NULL);\n\n          switch((yyvsp[0].expression).value.object->type)\n          {\n            case OBJECT_TYPE_INTEGER:\n              (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n              (yyval.expression).value.integer = UNDEFINED;\n              break;\n            case OBJECT_TYPE_FLOAT:\n              (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n              break;\n            case OBJECT_TYPE_STRING:\n              (yyval.expression).type = EXPRESSION_TYPE_STRING;\n              (yyval.expression).value.sized_string = NULL;\n              break;\n            default:\n              yr_compiler_set_error_extra_info_fmt(\n                  compiler,\n                  \"wrong usage of identifier \\\"%s\\\"\",\n                  (yyvsp[0].expression).identifier);\n              compiler->last_result = ERROR_WRONG_TYPE;\n          }\n        }\n        else\n        {\n          assert(FALSE);\n        }\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n#line 3475 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 110:\n#line 1767 \"grammar.y\" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER | EXPRESSION_TYPE_FLOAT, \"-\");\n \n        if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)\n        {\n          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n          (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?\n              UNDEFINED : -((yyvsp[0].expression).value.integer);\n          compiler->last_result = yr_parser_emit(yyscanner, OP_INT_MINUS, NULL);\n        }\n        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_FLOAT)\n        {\n          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n          compiler->last_result = yr_parser_emit(yyscanner, OP_DBL_MINUS, NULL);\n        }\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n#line 3498 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 111:\n#line 1786 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \"+\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&\n            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)\n        {\n          (yyval.expression).value.integer = OPERATION(+, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n        }\n        else\n        {\n           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n         }\n       }\n#line 3520 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 112:\n#line 1804 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \"-\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&\n            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)\n        {\n          (yyval.expression).value.integer = OPERATION(-, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n        }\n        else\n        {\n           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n         }\n       }\n#line 3542 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 113:\n#line 1822 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \"*\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&\n            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)\n        {\n          (yyval.expression).value.integer = OPERATION(*, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n        }\n        else\n        {\n           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n         }\n       }\n#line 3564 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 114:\n#line 1840 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \"\\\\\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&\n            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)\n        {\n          if ((yyvsp[0].expression).value.integer != 0)\n          {\n            (yyval.expression).value.integer = OPERATION(/, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n            (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n          }\n          else\n          {\n            compiler->last_result = ERROR_DIVISION_BY_ZERO;\n            ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n          }\n        }\n        else\n        {\n           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n         }\n       }\n#line 3594 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 115:\n#line 1866 \"grammar.y\" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"%\");\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"%\");\n\n        yr_parser_emit(yyscanner, OP_MOD, NULL);\n\n        if ((yyvsp[0].expression).value.integer != 0)\n        {\n          (yyval.expression).value.integer = OPERATION(%, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n        }\n        else\n        {\n          compiler->last_result = ERROR_DIVISION_BY_ZERO;\n           ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n         }\n       }\n#line 3616 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 116:\n#line 1884 \"grammar.y\" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"^\");\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"^\");\n\n        yr_parser_emit(yyscanner, OP_BITWISE_XOR, NULL);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = OPERATION(^, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n       }\n#line 3630 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 117:\n#line 1894 \"grammar.y\" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"^\");\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"^\");\n\n        yr_parser_emit(yyscanner, OP_BITWISE_AND, NULL);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = OPERATION(&, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n       }\n#line 3644 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 118:\n#line 1904 \"grammar.y\" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"|\");\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"|\");\n\n        yr_parser_emit(yyscanner, OP_BITWISE_OR, NULL);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = OPERATION(|, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n       }\n#line 3658 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 119:\n#line 1914 \"grammar.y\" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"~\");\n \n        yr_parser_emit(yyscanner, OP_BITWISE_NOT, NULL);\n\n        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?\n             UNDEFINED : ~((yyvsp[0].expression).value.integer);\n       }\n#line 3672 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 120:\n#line 1924 \"grammar.y\" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"<<\");\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"<<\");\n\n        yr_parser_emit(yyscanner, OP_SHL, NULL);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = OPERATION(<<, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n       }\n#line 3686 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 121:\n#line 1934 \"grammar.y\" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \">>\");\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \">>\");\n\n        yr_parser_emit(yyscanner, OP_SHR, NULL);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = OPERATION(>>, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n       }\n#line 3700 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n   case 122:\n#line 1944 \"grammar.y\" /* yacc.c:1646  */\n     {\n         (yyval.expression) = (yyvsp[0].expression);\n       }\n#line 3708 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n \n#line 3712 \"grammar.c\" /* yacc.c:1646  */\n       default: break;\n     }\n   /* User semantic actions sometimes alter yychar, and that requires\n     that yytoken be updated with the new translation.  We take the\n     approach of translating immediately before every use of yytoken.\n     One alternative is translating here after every semantic action,\n     but that translation would be missed if the semantic action invokes\n     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or\n     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an\n     incorrect destructor might then be invoked immediately.  In the\n     case of YYERROR or YYBACKUP, subsequent parser actions might lead\n     to an incorrect destructor call or verbose syntax error message\n     before the lookahead is translated.  */\n  YY_SYMBOL_PRINT (\"-> $$ =\", yyr1[yyn], &yyval, &yyloc);\n\n  YYPOPSTACK (yylen);\n  yylen = 0;\n  YY_STACK_PRINT (yyss, yyssp);\n\n  *++yyvsp = yyval;\n\n  /* Now 'shift' the result of the reduction.  Determine what state\n     that goes to, based on the state we popped back to and the rule\n     number reduced by.  */\n\n  yyn = yyr1[yyn];\n\n  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;\n  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)\n    yystate = yytable[yystate];\n  else\n    yystate = yydefgoto[yyn - YYNTOKENS];\n\n  goto yynewstate;\n\n\n/*--------------------------------------.\n| yyerrlab -- here on detecting error.  |\n`--------------------------------------*/\nyyerrlab:\n  /* Make sure we have latest lookahead translation.  See comments at\n     user semantic actions for why this is necessary.  */\n  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);\n\n  /* If not already recovering from an error, report this error.  */\n  if (!yyerrstatus)\n    {\n      ++yynerrs;\n#if ! YYERROR_VERBOSE\n      yyerror (yyscanner, compiler, YY_(\"syntax error\"));\n#else\n# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \\\n                                        yyssp, yytoken)\n      {\n        char const *yymsgp = YY_(\"syntax error\");\n        int yysyntax_error_status;\n        yysyntax_error_status = YYSYNTAX_ERROR;\n        if (yysyntax_error_status == 0)\n          yymsgp = yymsg;\n        else if (yysyntax_error_status == 1)\n          {\n            if (yymsg != yymsgbuf)\n              YYSTACK_FREE (yymsg);\n            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);\n            if (!yymsg)\n              {\n                yymsg = yymsgbuf;\n                yymsg_alloc = sizeof yymsgbuf;\n                yysyntax_error_status = 2;\n              }\n            else\n              {\n                yysyntax_error_status = YYSYNTAX_ERROR;\n                yymsgp = yymsg;\n              }\n          }\n        yyerror (yyscanner, compiler, yymsgp);\n        if (yysyntax_error_status == 2)\n          goto yyexhaustedlab;\n      }\n# undef YYSYNTAX_ERROR\n#endif\n    }\n\n\n\n  if (yyerrstatus == 3)\n    {\n      /* If just tried and failed to reuse lookahead token after an\n         error, discard it.  */\n\n      if (yychar <= YYEOF)\n        {\n          /* Return failure if at end of input.  */\n          if (yychar == YYEOF)\n            YYABORT;\n        }\n      else\n        {\n          yydestruct (\"Error: discarding\",\n                      yytoken, &yylval, yyscanner, compiler);\n          yychar = YYEMPTY;\n        }\n    }\n\n  /* Else will try to reuse lookahead token after shifting the error\n     token.  */\n  goto yyerrlab1;\n\n\n/*---------------------------------------------------.\n| yyerrorlab -- error raised explicitly by YYERROR.  |\n`---------------------------------------------------*/\nyyerrorlab:\n\n  /* Pacify compilers like GCC when the user code never invokes\n     YYERROR and the label yyerrorlab therefore never appears in user\n     code.  */\n  if (/*CONSTCOND*/ 0)\n     goto yyerrorlab;\n\n  /* Do not reclaim the symbols of the rule whose action triggered\n     this YYERROR.  */\n  YYPOPSTACK (yylen);\n  yylen = 0;\n  YY_STACK_PRINT (yyss, yyssp);\n  yystate = *yyssp;\n  goto yyerrlab1;\n\n\n/*-------------------------------------------------------------.\n| yyerrlab1 -- common code for both syntax error and YYERROR.  |\n`-------------------------------------------------------------*/\nyyerrlab1:\n  yyerrstatus = 3;      /* Each real token shifted decrements this.  */\n\n  for (;;)\n    {\n      yyn = yypact[yystate];\n      if (!yypact_value_is_default (yyn))\n        {\n          yyn += YYTERROR;\n          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)\n            {\n              yyn = yytable[yyn];\n              if (0 < yyn)\n                break;\n            }\n        }\n\n      /* Pop the current state because it cannot handle the error token.  */\n      if (yyssp == yyss)\n        YYABORT;\n\n\n      yydestruct (\"Error: popping\",\n                  yystos[yystate], yyvsp, yyscanner, compiler);\n      YYPOPSTACK (1);\n      yystate = *yyssp;\n      YY_STACK_PRINT (yyss, yyssp);\n    }\n\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  *++yyvsp = yylval;\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n\n\n  /* Shift the error token.  */\n  YY_SYMBOL_PRINT (\"Shifting\", yystos[yyn], yyvsp, yylsp);\n\n  yystate = yyn;\n  goto yynewstate;\n\n\n/*-------------------------------------.\n| yyacceptlab -- YYACCEPT comes here.  |\n`-------------------------------------*/\nyyacceptlab:\n  yyresult = 0;\n  goto yyreturn;\n\n/*-----------------------------------.\n| yyabortlab -- YYABORT comes here.  |\n`-----------------------------------*/\nyyabortlab:\n  yyresult = 1;\n  goto yyreturn;\n\n#if !defined yyoverflow || YYERROR_VERBOSE\n/*-------------------------------------------------.\n| yyexhaustedlab -- memory exhaustion comes here.  |\n`-------------------------------------------------*/\nyyexhaustedlab:\n  yyerror (yyscanner, compiler, YY_(\"memory exhausted\"));\n  yyresult = 2;\n  /* Fall through.  */\n#endif\n\nyyreturn:\n  if (yychar != YYEMPTY)\n    {\n      /* Make sure we have latest lookahead translation.  See comments at\n         user semantic actions for why this is necessary.  */\n      yytoken = YYTRANSLATE (yychar);\n      yydestruct (\"Cleanup: discarding lookahead\",\n                  yytoken, &yylval, yyscanner, compiler);\n    }\n  /* Do not reclaim the symbols of the rule whose action triggered\n     this YYABORT or YYACCEPT.  */\n  YYPOPSTACK (yylen);\n  YY_STACK_PRINT (yyss, yyssp);\n  while (yyssp != yyss)\n    {\n      yydestruct (\"Cleanup: popping\",\n                  yystos[*yyssp], yyvsp, yyscanner, compiler);\n      YYPOPSTACK (1);\n    }\n#ifndef yyoverflow\n  if (yyss != yyssa)\n    YYSTACK_FREE (yyss);\n#endif\n#if YYERROR_VERBOSE\n  if (yymsg != yymsgbuf)\n    YYSTACK_FREE (yymsg);\n #endif\n   return yyresult;\n }\n",
    "cwe": [
      "CWE-125"
    ],
    "id": 51,
    "_valid_cwes": [
      "CWE-125"
    ]
  },
  {
    "cve_id": "CVE-2017-12897",
    "code_before_change": "isoclns_print(netdissect_options *ndo,\n              const uint8_t *p, u_int length, u_int caplen)\n {\n\tif (caplen <= 1) { /* enough bytes on the wire ? */\n \t\tND_PRINT((ndo, \"|OSI\"));\n \t\treturn;\n \t}\n\n\tif (ndo->ndo_eflag)\n\t\tND_PRINT((ndo, \"OSI NLPID %s (0x%02x): \", tok2str(nlpid_values, \"Unknown\", *p), *p));\n\n\tswitch (*p) {\n \n \tcase NLPID_CLNP:\n \t\tif (!clnp_print(ndo, p, length))\n\t\t\tprint_unknown_data(ndo, p, \"\\n\\t\", caplen);\n \t\tbreak;\n \n \tcase NLPID_ESIS:\n\t\tesis_print(ndo, p, length);\n\t\treturn;\n \n \tcase NLPID_ISIS:\n \t\tif (!isis_print(ndo, p, length))\n\t\t\tprint_unknown_data(ndo, p, \"\\n\\t\", caplen);\n \t\tbreak;\n \n \tcase NLPID_NULLNS:\n\t\tND_PRINT((ndo, \"%slength: %u\", ndo->ndo_eflag ? \"\" : \", \", length));\n\t\tbreak;\n\n\tcase NLPID_Q933:\n\t\tq933_print(ndo, p + 1, length - 1);\n\t\tbreak;\n\n\tcase NLPID_IP:\n\t\tip_print(ndo, p + 1, length - 1);\n\t\tbreak;\n\n\tcase NLPID_IP6:\n\t\tip6_print(ndo, p + 1, length - 1);\n\t\tbreak;\n\n\tcase NLPID_PPP:\n\t\tppp_print(ndo, p + 1, length - 1);\n\t\tbreak;\n\n\tdefault:\n \t\tif (!ndo->ndo_eflag)\n \t\t\tND_PRINT((ndo, \"OSI NLPID 0x%02x unknown\", *p));\n \t\tND_PRINT((ndo, \"%slength: %u\", ndo->ndo_eflag ? \"\" : \", \", length));\n\t\tif (caplen > 1)\n\t\t\tprint_unknown_data(ndo, p, \"\\n\\t\", caplen);\n \t\tbreak;\n \t}\n }\n",
    "code_after_change": "isoclns_print(netdissect_options *ndo,\nisoclns_print(netdissect_options *ndo, const uint8_t *p, u_int length)\n {\n\tif (!ND_TTEST(*p)) { /* enough bytes on the wire ? */\n \t\tND_PRINT((ndo, \"|OSI\"));\n \t\treturn;\n \t}\n\n\tif (ndo->ndo_eflag)\n\t\tND_PRINT((ndo, \"OSI NLPID %s (0x%02x): \", tok2str(nlpid_values, \"Unknown\", *p), *p));\n\n\tswitch (*p) {\n \n \tcase NLPID_CLNP:\n \t\tif (!clnp_print(ndo, p, length))\n\t\t\tprint_unknown_data(ndo, p, \"\\n\\t\", length);\n \t\tbreak;\n \n \tcase NLPID_ESIS:\n\t\tesis_print(ndo, p, length);\n\t\treturn;\n \n \tcase NLPID_ISIS:\n \t\tif (!isis_print(ndo, p, length))\n\t\t\tprint_unknown_data(ndo, p, \"\\n\\t\", length);\n \t\tbreak;\n \n \tcase NLPID_NULLNS:\n\t\tND_PRINT((ndo, \"%slength: %u\", ndo->ndo_eflag ? \"\" : \", \", length));\n\t\tbreak;\n\n\tcase NLPID_Q933:\n\t\tq933_print(ndo, p + 1, length - 1);\n\t\tbreak;\n\n\tcase NLPID_IP:\n\t\tip_print(ndo, p + 1, length - 1);\n\t\tbreak;\n\n\tcase NLPID_IP6:\n\t\tip6_print(ndo, p + 1, length - 1);\n\t\tbreak;\n\n\tcase NLPID_PPP:\n\t\tppp_print(ndo, p + 1, length - 1);\n\t\tbreak;\n\n\tdefault:\n \t\tif (!ndo->ndo_eflag)\n \t\t\tND_PRINT((ndo, \"OSI NLPID 0x%02x unknown\", *p));\n \t\tND_PRINT((ndo, \"%slength: %u\", ndo->ndo_eflag ? \"\" : \", \", length));\n\t\tif (length > 1)\n\t\t\tprint_unknown_data(ndo, p, \"\\n\\t\", length);\n \t\tbreak;\n \t}\n }\n",
    "cwe": [
      "CWE-125"
    ],
    "id": 56,
    "_valid_cwes": [
      "CWE-125"
    ]
  },
  {
    "cve_id": "CVE-2018-12248",
    "code_before_change": "fiber_switch(mrb_state *mrb, mrb_value self, mrb_int len, const mrb_value *a, mrb_bool resume, mrb_bool vmexec)\n {\n   struct mrb_context *c = fiber_check(mrb, self);\n   struct mrb_context *old_c = mrb->c;\n   mrb_value value;\n \n   fiber_check_cfunc(mrb, c);\n  if (resume && c->status == MRB_FIBER_TRANSFERRED) {\n     mrb_raise(mrb, E_FIBER_ERROR, \"resuming transferred fiber\");\n   }\n  if (c->status == MRB_FIBER_RUNNING || c->status == MRB_FIBER_RESUMED) {\n     mrb_raise(mrb, E_FIBER_ERROR, \"double resume (fib)\");\n   }\n  if (c->status == MRB_FIBER_TERMINATED) {\n     mrb_raise(mrb, E_FIBER_ERROR, \"resuming dead fiber\");\n   }\n  mrb->c->status = resume ? MRB_FIBER_RESUMED : MRB_FIBER_TRANSFERRED;\n   c->prev = resume ? mrb->c : (c->prev ? c->prev : mrb->root_c);\n  if (c->status == MRB_FIBER_CREATED) {\n     mrb_value *b, *e;\n \n    if (len >= c->stend - c->stack) {\n      mrb_raise(mrb, E_FIBER_ERROR, \"too many arguments to fiber\");\n    }\n     b = c->stack+1;\n     e = b + len;\n     while (b<e) {\n      *b++ = *a++;\n    }\n    c->cibase->argc = (int)len;\n    value = c->stack[0] = MRB_PROC_ENV(c->ci->proc)->stack[0];\n  }\n   else {\n     value = fiber_result(mrb, a, len);\n   }\n  fiber_switch_context(mrb, c);\n \n   if (vmexec) {\n     c->vmexec = TRUE;\n    value = mrb_vm_exec(mrb, c->ci[-1].proc, c->ci->pc);\n    mrb->c = old_c;\n  }\n  else {\n    MARK_CONTEXT_MODIFY(c);\n  }\n  return value;\n}\n",
    "code_after_change": "fiber_switch(mrb_state *mrb, mrb_value self, mrb_int len, const mrb_value *a, mrb_bool resume, mrb_bool vmexec)\n {\n   struct mrb_context *c = fiber_check(mrb, self);\n   struct mrb_context *old_c = mrb->c;\n  enum mrb_fiber_state status;\n   mrb_value value;\n \n   fiber_check_cfunc(mrb, c);\n  status = c->status;\n  if (resume && status == MRB_FIBER_TRANSFERRED) {\n     mrb_raise(mrb, E_FIBER_ERROR, \"resuming transferred fiber\");\n   }\n  if (status == MRB_FIBER_RUNNING || status == MRB_FIBER_RESUMED) {\n     mrb_raise(mrb, E_FIBER_ERROR, \"double resume (fib)\");\n   }\n  if (status == MRB_FIBER_TERMINATED) {\n     mrb_raise(mrb, E_FIBER_ERROR, \"resuming dead fiber\");\n   }\n  old_c->status = resume ? MRB_FIBER_RESUMED : MRB_FIBER_TRANSFERRED;\n   c->prev = resume ? mrb->c : (c->prev ? c->prev : mrb->root_c);\n  fiber_switch_context(mrb, c);\n  if (status == MRB_FIBER_CREATED) {\n     mrb_value *b, *e;\n \n    mrb_stack_extend(mrb, len+2); /* for receiver and (optional) block */\n     b = c->stack+1;\n     e = b + len;\n     while (b<e) {\n      *b++ = *a++;\n    }\n    c->cibase->argc = (int)len;\n    value = c->stack[0] = MRB_PROC_ENV(c->ci->proc)->stack[0];\n  }\n   else {\n     value = fiber_result(mrb, a, len);\n   }\n \n   if (vmexec) {\n     c->vmexec = TRUE;\n    value = mrb_vm_exec(mrb, c->ci[-1].proc, c->ci->pc);\n    mrb->c = old_c;\n  }\n  else {\n    MARK_CONTEXT_MODIFY(c);\n  }\n  return value;\n}\n",
    "cwe": [
      "CWE-125"
    ],
    "id": 67,
    "_valid_cwes": [
      "CWE-125"
    ]
  },
  {
    "cve_id": "CVE-2019-10714",
    "code_before_change": " MagickExport int LocaleLowercase(const int c)\n {\n #if defined(MAGICKCORE_LOCALE_SUPPORT)\n   if (c_locale != (locale_t) NULL)\n     return(tolower_l((int) ((unsigned char) c),c_locale));\n#endif\n  return(tolower((int) ((unsigned char) c)));\n}\n",
    "code_after_change": " MagickExport int LocaleLowercase(const int c)\n {\n  if (c < 0)\n    return(c);\n #if defined(MAGICKCORE_LOCALE_SUPPORT)\n   if (c_locale != (locale_t) NULL)\n     return(tolower_l((int) ((unsigned char) c),c_locale));\n#endif\n  return(tolower((int) ((unsigned char) c)));\n}\n",
    "cwe": [
      "CWE-125"
    ],
    "id": 78,
    "_valid_cwes": [
      "CWE-125"
    ]
  },
  {
    "cve_id": "CVE-2017-13004",
    "code_before_change": "juniper_parse_header(netdissect_options *ndo,\n                     const u_char *p, const struct pcap_pkthdr *h, struct juniper_l2info_t *l2info)\n{\n    const struct juniper_cookie_table_t *lp = juniper_cookie_table;\n    u_int idx, jnx_ext_len, jnx_header_len = 0;\n    uint8_t tlv_type,tlv_len;\n    uint32_t control_word;\n    int tlv_value;\n    const u_char *tptr;\n\n\n    l2info->header_len = 0;\n    l2info->cookie_len = 0;\n    l2info->proto = 0;\n\n\n    l2info->length = h->len;\n    l2info->caplen = h->caplen;\n    ND_TCHECK2(p[0], 4);\n    l2info->flags = p[3];\n    l2info->direction = p[3]&JUNIPER_BPF_PKT_IN;\n\n    if (EXTRACT_24BITS(p) != JUNIPER_MGC_NUMBER) { /* magic number found ? */\n        ND_PRINT((ndo, \"no magic-number found!\"));\n        return 0;\n    }\n\n    if (ndo->ndo_eflag) /* print direction */\n        ND_PRINT((ndo, \"%3s \", tok2str(juniper_direction_values, \"---\", l2info->direction)));\n\n    /* magic number + flags */\n    jnx_header_len = 4;\n\n    if (ndo->ndo_vflag > 1)\n        ND_PRINT((ndo, \"\\n\\tJuniper PCAP Flags [%s]\",\n               bittok2str(jnx_flag_values, \"none\", l2info->flags)));\n\n    /* extensions present ?  - calculate how much bytes to skip */\n    if ((l2info->flags & JUNIPER_BPF_EXT ) == JUNIPER_BPF_EXT ) {\n\n        tptr = p+jnx_header_len;\n\n        /* ok to read extension length ? */\n        ND_TCHECK2(tptr[0], 2);\n        jnx_ext_len = EXTRACT_16BITS(tptr);\n        jnx_header_len += 2;\n        tptr +=2;\n\n        /* nail up the total length -\n         * just in case something goes wrong\n         * with TLV parsing */\n        jnx_header_len += jnx_ext_len;\n\n        if (ndo->ndo_vflag > 1)\n            ND_PRINT((ndo, \", PCAP Extension(s) total length %u\", jnx_ext_len));\n\n        ND_TCHECK2(tptr[0], jnx_ext_len);\n        while (jnx_ext_len > JUNIPER_EXT_TLV_OVERHEAD) {\n            tlv_type = *(tptr++);\n            tlv_len = *(tptr++);\n            tlv_value = 0;\n\n            /* sanity checks */\n            if (tlv_type == 0 || tlv_len == 0)\n                break;\n            if (tlv_len+JUNIPER_EXT_TLV_OVERHEAD > jnx_ext_len)\n                goto trunc;\n\n            if (ndo->ndo_vflag > 1)\n                ND_PRINT((ndo, \"\\n\\t  %s Extension TLV #%u, length %u, value \",\n                       tok2str(jnx_ext_tlv_values,\"Unknown\",tlv_type),\n                       tlv_type,\n                       tlv_len));\n\n            tlv_value = juniper_read_tlv_value(tptr, tlv_type, tlv_len);\n            switch (tlv_type) {\n            case JUNIPER_EXT_TLV_IFD_NAME:\n                /* FIXME */\n                break;\n            case JUNIPER_EXT_TLV_IFD_MEDIATYPE:\n            case JUNIPER_EXT_TLV_TTP_IFD_MEDIATYPE:\n                if (tlv_value != -1) {\n                    if (ndo->ndo_vflag > 1)\n                        ND_PRINT((ndo, \"%s (%u)\",\n                               tok2str(juniper_ifmt_values, \"Unknown\", tlv_value),\n                               tlv_value));\n                }\n                break;\n            case JUNIPER_EXT_TLV_IFL_ENCAPS:\n            case JUNIPER_EXT_TLV_TTP_IFL_ENCAPS:\n                if (tlv_value != -1) {\n                    if (ndo->ndo_vflag > 1)\n                        ND_PRINT((ndo, \"%s (%u)\",\n                               tok2str(juniper_ifle_values, \"Unknown\", tlv_value),\n                               tlv_value));\n                }\n                break;\n            case JUNIPER_EXT_TLV_IFL_IDX: /* fall through */\n            case JUNIPER_EXT_TLV_IFL_UNIT:\n            case JUNIPER_EXT_TLV_IFD_IDX:\n            default:\n                if (tlv_value != -1) {\n                    if (ndo->ndo_vflag > 1)\n                        ND_PRINT((ndo, \"%u\", tlv_value));\n                }\n                break;\n            }\n\n            tptr+=tlv_len;\n            jnx_ext_len -= tlv_len+JUNIPER_EXT_TLV_OVERHEAD;\n        }\n\n        if (ndo->ndo_vflag > 1)\n            ND_PRINT((ndo, \"\\n\\t-----original packet-----\\n\\t\"));\n    }\n\n    if ((l2info->flags & JUNIPER_BPF_NO_L2 ) == JUNIPER_BPF_NO_L2 ) {\n        if (ndo->ndo_eflag)\n            ND_PRINT((ndo, \"no-L2-hdr, \"));\n\n        /* there is no link-layer present -\n         * perform the v4/v6 heuristics\n         * to figure out what it is\n         */\n        ND_TCHECK2(p[jnx_header_len + 4], 1);\n        if (ip_heuristic_guess(ndo, p + jnx_header_len + 4,\n                               l2info->length - (jnx_header_len + 4)) == 0)\n            ND_PRINT((ndo, \"no IP-hdr found!\"));\n\n        l2info->header_len=jnx_header_len+4;\n        return 0; /* stop parsing the output further */\n\n    }\n    l2info->header_len = jnx_header_len;\n    p+=l2info->header_len;\n    l2info->length -= l2info->header_len;\n    l2info->caplen -= l2info->header_len;\n\n    /* search through the cookie table and copy values matching for our PIC type */\n    ND_TCHECK(p[0]);\n    while (lp->s != NULL) {\n        if (lp->pictype == l2info->pictype) {\n\n            l2info->cookie_len += lp->cookie_len;\n\n            switch (p[0]) {\n            case LS_COOKIE_ID:\n                l2info->cookie_type = LS_COOKIE_ID;\n                l2info->cookie_len += 2;\n                break;\n            case AS_COOKIE_ID:\n                l2info->cookie_type = AS_COOKIE_ID;\n                l2info->cookie_len = 8;\n                break;\n\n            default:\n                l2info->bundle = l2info->cookie[0];\n                break;\n            }\n\n\n#ifdef DLT_JUNIPER_MFR\n            /* MFR child links don't carry cookies */\n            if (l2info->pictype == DLT_JUNIPER_MFR &&\n                (p[0] & MFR_BE_MASK) == MFR_BE_MASK) {\n                l2info->cookie_len = 0;\n            }\n#endif\n\n            l2info->header_len += l2info->cookie_len;\n            l2info->length -= l2info->cookie_len;\n            l2info->caplen -= l2info->cookie_len;\n\n            if (ndo->ndo_eflag)\n                ND_PRINT((ndo, \"%s-PIC, cookie-len %u\",\n                       lp->s,\n                       l2info->cookie_len));\n\n            if (l2info->cookie_len > 0) {\n                ND_TCHECK2(p[0], l2info->cookie_len);\n                if (ndo->ndo_eflag)\n                    ND_PRINT((ndo, \", cookie 0x\"));\n                for (idx = 0; idx < l2info->cookie_len; idx++) {\n                    l2info->cookie[idx] = p[idx]; /* copy cookie data */\n                    if (ndo->ndo_eflag) ND_PRINT((ndo, \"%02x\", p[idx]));\n                }\n            }\n\n             if (ndo->ndo_eflag) ND_PRINT((ndo, \": \")); /* print demarc b/w L2/L3*/\n \n \n             l2info->proto = EXTRACT_16BITS(p+l2info->cookie_len);\n             break;\n         }\n        ++lp;\n    }\n    p+=l2info->cookie_len;\n\n    /* DLT_ specific parsing */\n    switch(l2info->pictype) {\n#ifdef DLT_JUNIPER_MLPPP\n    case DLT_JUNIPER_MLPPP:\n        switch (l2info->cookie_type) {\n        case LS_COOKIE_ID:\n            l2info->bundle = l2info->cookie[1];\n            break;\n        case AS_COOKIE_ID:\n            l2info->bundle = (EXTRACT_16BITS(&l2info->cookie[6])>>3)&0xfff;\n            l2info->proto = (l2info->cookie[5])&JUNIPER_LSQ_L3_PROTO_MASK;\n            break;\n        default:\n            l2info->bundle = l2info->cookie[0];\n            break;\n        }\n        break;\n#endif\n#ifdef DLT_JUNIPER_MLFR\n    case DLT_JUNIPER_MLFR:\n        switch (l2info->cookie_type) {\n        case LS_COOKIE_ID:\n            ND_TCHECK2(p[0], 2);\n            l2info->bundle = l2info->cookie[1];\n            l2info->proto = EXTRACT_16BITS(p);\n            l2info->header_len += 2;\n            l2info->length -= 2;\n            l2info->caplen -= 2;\n            break;\n        case AS_COOKIE_ID:\n            l2info->bundle = (EXTRACT_16BITS(&l2info->cookie[6])>>3)&0xfff;\n            l2info->proto = (l2info->cookie[5])&JUNIPER_LSQ_L3_PROTO_MASK;\n            break;\n        default:\n            l2info->bundle = l2info->cookie[0];\n            l2info->header_len += 2;\n            l2info->length -= 2;\n            l2info->caplen -= 2;\n            break;\n        }\n        break;\n#endif\n#ifdef DLT_JUNIPER_MFR\n    case DLT_JUNIPER_MFR:\n        switch (l2info->cookie_type) {\n        case LS_COOKIE_ID:\n            ND_TCHECK2(p[0], 2);\n            l2info->bundle = l2info->cookie[1];\n            l2info->proto = EXTRACT_16BITS(p);\n            l2info->header_len += 2;\n            l2info->length -= 2;\n            l2info->caplen -= 2;\n            break;\n        case AS_COOKIE_ID:\n            l2info->bundle = (EXTRACT_16BITS(&l2info->cookie[6])>>3)&0xfff;\n            l2info->proto = (l2info->cookie[5])&JUNIPER_LSQ_L3_PROTO_MASK;\n            break;\n        default:\n            l2info->bundle = l2info->cookie[0];\n            break;\n        }\n        break;\n#endif\n#ifdef DLT_JUNIPER_ATM2\n    case DLT_JUNIPER_ATM2:\n        ND_TCHECK2(p[0], 4);\n        /* ATM cell relay control word present ? */\n        if (l2info->cookie[7] & ATM2_PKT_TYPE_MASK) {\n            control_word = EXTRACT_32BITS(p);\n            /* some control word heuristics */\n            switch(control_word) {\n            case 0: /* zero control word */\n            case 0x08000000: /* < JUNOS 7.4 control-word */\n            case 0x08380000: /* cntl word plus cell length (56) >= JUNOS 7.4*/\n                l2info->header_len += 4;\n                break;\n            default:\n                break;\n            }\n\n            if (ndo->ndo_eflag)\n                ND_PRINT((ndo, \"control-word 0x%08x \", control_word));\n        }\n        break;\n#endif\n#ifdef DLT_JUNIPER_GGSN\n    case DLT_JUNIPER_GGSN:\n        break;\n#endif\n#ifdef DLT_JUNIPER_ATM1\n    case DLT_JUNIPER_ATM1:\n        break;\n#endif\n#ifdef DLT_JUNIPER_PPP\n    case DLT_JUNIPER_PPP:\n        break;\n#endif\n#ifdef DLT_JUNIPER_CHDLC\n    case DLT_JUNIPER_CHDLC:\n        break;\n#endif\n#ifdef DLT_JUNIPER_ETHER\n    case DLT_JUNIPER_ETHER:\n        break;\n#endif\n#ifdef DLT_JUNIPER_FRELAY\n    case DLT_JUNIPER_FRELAY:\n        break;\n#endif\n\n    default:\n        ND_PRINT((ndo, \"Unknown Juniper DLT_ type %u: \", l2info->pictype));\n        break;\n    }\n\n    if (ndo->ndo_eflag > 1)\n        ND_PRINT((ndo, \"hlen %u, proto 0x%04x, \", l2info->header_len, l2info->proto));\n\n    return 1; /* everything went ok so far. continue parsing */\n trunc:\n    ND_PRINT((ndo, \"[|juniper_hdr], length %u\", h->len));\n    return 0;\n}\n",
    "code_after_change": "juniper_parse_header(netdissect_options *ndo,\n                     const u_char *p, const struct pcap_pkthdr *h, struct juniper_l2info_t *l2info)\n{\n    const struct juniper_cookie_table_t *lp = juniper_cookie_table;\n    u_int idx, jnx_ext_len, jnx_header_len = 0;\n    uint8_t tlv_type,tlv_len;\n    uint32_t control_word;\n    int tlv_value;\n    const u_char *tptr;\n\n\n    l2info->header_len = 0;\n    l2info->cookie_len = 0;\n    l2info->proto = 0;\n\n\n    l2info->length = h->len;\n    l2info->caplen = h->caplen;\n    ND_TCHECK2(p[0], 4);\n    l2info->flags = p[3];\n    l2info->direction = p[3]&JUNIPER_BPF_PKT_IN;\n\n    if (EXTRACT_24BITS(p) != JUNIPER_MGC_NUMBER) { /* magic number found ? */\n        ND_PRINT((ndo, \"no magic-number found!\"));\n        return 0;\n    }\n\n    if (ndo->ndo_eflag) /* print direction */\n        ND_PRINT((ndo, \"%3s \", tok2str(juniper_direction_values, \"---\", l2info->direction)));\n\n    /* magic number + flags */\n    jnx_header_len = 4;\n\n    if (ndo->ndo_vflag > 1)\n        ND_PRINT((ndo, \"\\n\\tJuniper PCAP Flags [%s]\",\n               bittok2str(jnx_flag_values, \"none\", l2info->flags)));\n\n    /* extensions present ?  - calculate how much bytes to skip */\n    if ((l2info->flags & JUNIPER_BPF_EXT ) == JUNIPER_BPF_EXT ) {\n\n        tptr = p+jnx_header_len;\n\n        /* ok to read extension length ? */\n        ND_TCHECK2(tptr[0], 2);\n        jnx_ext_len = EXTRACT_16BITS(tptr);\n        jnx_header_len += 2;\n        tptr +=2;\n\n        /* nail up the total length -\n         * just in case something goes wrong\n         * with TLV parsing */\n        jnx_header_len += jnx_ext_len;\n\n        if (ndo->ndo_vflag > 1)\n            ND_PRINT((ndo, \", PCAP Extension(s) total length %u\", jnx_ext_len));\n\n        ND_TCHECK2(tptr[0], jnx_ext_len);\n        while (jnx_ext_len > JUNIPER_EXT_TLV_OVERHEAD) {\n            tlv_type = *(tptr++);\n            tlv_len = *(tptr++);\n            tlv_value = 0;\n\n            /* sanity checks */\n            if (tlv_type == 0 || tlv_len == 0)\n                break;\n            if (tlv_len+JUNIPER_EXT_TLV_OVERHEAD > jnx_ext_len)\n                goto trunc;\n\n            if (ndo->ndo_vflag > 1)\n                ND_PRINT((ndo, \"\\n\\t  %s Extension TLV #%u, length %u, value \",\n                       tok2str(jnx_ext_tlv_values,\"Unknown\",tlv_type),\n                       tlv_type,\n                       tlv_len));\n\n            tlv_value = juniper_read_tlv_value(tptr, tlv_type, tlv_len);\n            switch (tlv_type) {\n            case JUNIPER_EXT_TLV_IFD_NAME:\n                /* FIXME */\n                break;\n            case JUNIPER_EXT_TLV_IFD_MEDIATYPE:\n            case JUNIPER_EXT_TLV_TTP_IFD_MEDIATYPE:\n                if (tlv_value != -1) {\n                    if (ndo->ndo_vflag > 1)\n                        ND_PRINT((ndo, \"%s (%u)\",\n                               tok2str(juniper_ifmt_values, \"Unknown\", tlv_value),\n                               tlv_value));\n                }\n                break;\n            case JUNIPER_EXT_TLV_IFL_ENCAPS:\n            case JUNIPER_EXT_TLV_TTP_IFL_ENCAPS:\n                if (tlv_value != -1) {\n                    if (ndo->ndo_vflag > 1)\n                        ND_PRINT((ndo, \"%s (%u)\",\n                               tok2str(juniper_ifle_values, \"Unknown\", tlv_value),\n                               tlv_value));\n                }\n                break;\n            case JUNIPER_EXT_TLV_IFL_IDX: /* fall through */\n            case JUNIPER_EXT_TLV_IFL_UNIT:\n            case JUNIPER_EXT_TLV_IFD_IDX:\n            default:\n                if (tlv_value != -1) {\n                    if (ndo->ndo_vflag > 1)\n                        ND_PRINT((ndo, \"%u\", tlv_value));\n                }\n                break;\n            }\n\n            tptr+=tlv_len;\n            jnx_ext_len -= tlv_len+JUNIPER_EXT_TLV_OVERHEAD;\n        }\n\n        if (ndo->ndo_vflag > 1)\n            ND_PRINT((ndo, \"\\n\\t-----original packet-----\\n\\t\"));\n    }\n\n    if ((l2info->flags & JUNIPER_BPF_NO_L2 ) == JUNIPER_BPF_NO_L2 ) {\n        if (ndo->ndo_eflag)\n            ND_PRINT((ndo, \"no-L2-hdr, \"));\n\n        /* there is no link-layer present -\n         * perform the v4/v6 heuristics\n         * to figure out what it is\n         */\n        ND_TCHECK2(p[jnx_header_len + 4], 1);\n        if (ip_heuristic_guess(ndo, p + jnx_header_len + 4,\n                               l2info->length - (jnx_header_len + 4)) == 0)\n            ND_PRINT((ndo, \"no IP-hdr found!\"));\n\n        l2info->header_len=jnx_header_len+4;\n        return 0; /* stop parsing the output further */\n\n    }\n    l2info->header_len = jnx_header_len;\n    p+=l2info->header_len;\n    l2info->length -= l2info->header_len;\n    l2info->caplen -= l2info->header_len;\n\n    /* search through the cookie table and copy values matching for our PIC type */\n    ND_TCHECK(p[0]);\n    while (lp->s != NULL) {\n        if (lp->pictype == l2info->pictype) {\n\n            l2info->cookie_len += lp->cookie_len;\n\n            switch (p[0]) {\n            case LS_COOKIE_ID:\n                l2info->cookie_type = LS_COOKIE_ID;\n                l2info->cookie_len += 2;\n                break;\n            case AS_COOKIE_ID:\n                l2info->cookie_type = AS_COOKIE_ID;\n                l2info->cookie_len = 8;\n                break;\n\n            default:\n                l2info->bundle = l2info->cookie[0];\n                break;\n            }\n\n\n#ifdef DLT_JUNIPER_MFR\n            /* MFR child links don't carry cookies */\n            if (l2info->pictype == DLT_JUNIPER_MFR &&\n                (p[0] & MFR_BE_MASK) == MFR_BE_MASK) {\n                l2info->cookie_len = 0;\n            }\n#endif\n\n            l2info->header_len += l2info->cookie_len;\n            l2info->length -= l2info->cookie_len;\n            l2info->caplen -= l2info->cookie_len;\n\n            if (ndo->ndo_eflag)\n                ND_PRINT((ndo, \"%s-PIC, cookie-len %u\",\n                       lp->s,\n                       l2info->cookie_len));\n\n            if (l2info->cookie_len > 0) {\n                ND_TCHECK2(p[0], l2info->cookie_len);\n                if (ndo->ndo_eflag)\n                    ND_PRINT((ndo, \", cookie 0x\"));\n                for (idx = 0; idx < l2info->cookie_len; idx++) {\n                    l2info->cookie[idx] = p[idx]; /* copy cookie data */\n                    if (ndo->ndo_eflag) ND_PRINT((ndo, \"%02x\", p[idx]));\n                }\n            }\n\n             if (ndo->ndo_eflag) ND_PRINT((ndo, \": \")); /* print demarc b/w L2/L3*/\n \n \n            ND_TCHECK_16BITS(p+l2info->cookie_len);\n             l2info->proto = EXTRACT_16BITS(p+l2info->cookie_len);\n             break;\n         }\n        ++lp;\n    }\n    p+=l2info->cookie_len;\n\n    /* DLT_ specific parsing */\n    switch(l2info->pictype) {\n#ifdef DLT_JUNIPER_MLPPP\n    case DLT_JUNIPER_MLPPP:\n        switch (l2info->cookie_type) {\n        case LS_COOKIE_ID:\n            l2info->bundle = l2info->cookie[1];\n            break;\n        case AS_COOKIE_ID:\n            l2info->bundle = (EXTRACT_16BITS(&l2info->cookie[6])>>3)&0xfff;\n            l2info->proto = (l2info->cookie[5])&JUNIPER_LSQ_L3_PROTO_MASK;\n            break;\n        default:\n            l2info->bundle = l2info->cookie[0];\n            break;\n        }\n        break;\n#endif\n#ifdef DLT_JUNIPER_MLFR\n    case DLT_JUNIPER_MLFR:\n        switch (l2info->cookie_type) {\n        case LS_COOKIE_ID:\n            ND_TCHECK2(p[0], 2);\n            l2info->bundle = l2info->cookie[1];\n            l2info->proto = EXTRACT_16BITS(p);\n            l2info->header_len += 2;\n            l2info->length -= 2;\n            l2info->caplen -= 2;\n            break;\n        case AS_COOKIE_ID:\n            l2info->bundle = (EXTRACT_16BITS(&l2info->cookie[6])>>3)&0xfff;\n            l2info->proto = (l2info->cookie[5])&JUNIPER_LSQ_L3_PROTO_MASK;\n            break;\n        default:\n            l2info->bundle = l2info->cookie[0];\n            l2info->header_len += 2;\n            l2info->length -= 2;\n            l2info->caplen -= 2;\n            break;\n        }\n        break;\n#endif\n#ifdef DLT_JUNIPER_MFR\n    case DLT_JUNIPER_MFR:\n        switch (l2info->cookie_type) {\n        case LS_COOKIE_ID:\n            ND_TCHECK2(p[0], 2);\n            l2info->bundle = l2info->cookie[1];\n            l2info->proto = EXTRACT_16BITS(p);\n            l2info->header_len += 2;\n            l2info->length -= 2;\n            l2info->caplen -= 2;\n            break;\n        case AS_COOKIE_ID:\n            l2info->bundle = (EXTRACT_16BITS(&l2info->cookie[6])>>3)&0xfff;\n            l2info->proto = (l2info->cookie[5])&JUNIPER_LSQ_L3_PROTO_MASK;\n            break;\n        default:\n            l2info->bundle = l2info->cookie[0];\n            break;\n        }\n        break;\n#endif\n#ifdef DLT_JUNIPER_ATM2\n    case DLT_JUNIPER_ATM2:\n        ND_TCHECK2(p[0], 4);\n        /* ATM cell relay control word present ? */\n        if (l2info->cookie[7] & ATM2_PKT_TYPE_MASK) {\n            control_word = EXTRACT_32BITS(p);\n            /* some control word heuristics */\n            switch(control_word) {\n            case 0: /* zero control word */\n            case 0x08000000: /* < JUNOS 7.4 control-word */\n            case 0x08380000: /* cntl word plus cell length (56) >= JUNOS 7.4*/\n                l2info->header_len += 4;\n                break;\n            default:\n                break;\n            }\n\n            if (ndo->ndo_eflag)\n                ND_PRINT((ndo, \"control-word 0x%08x \", control_word));\n        }\n        break;\n#endif\n#ifdef DLT_JUNIPER_GGSN\n    case DLT_JUNIPER_GGSN:\n        break;\n#endif\n#ifdef DLT_JUNIPER_ATM1\n    case DLT_JUNIPER_ATM1:\n        break;\n#endif\n#ifdef DLT_JUNIPER_PPP\n    case DLT_JUNIPER_PPP:\n        break;\n#endif\n#ifdef DLT_JUNIPER_CHDLC\n    case DLT_JUNIPER_CHDLC:\n        break;\n#endif\n#ifdef DLT_JUNIPER_ETHER\n    case DLT_JUNIPER_ETHER:\n        break;\n#endif\n#ifdef DLT_JUNIPER_FRELAY\n    case DLT_JUNIPER_FRELAY:\n        break;\n#endif\n\n    default:\n        ND_PRINT((ndo, \"Unknown Juniper DLT_ type %u: \", l2info->pictype));\n        break;\n    }\n\n    if (ndo->ndo_eflag > 1)\n        ND_PRINT((ndo, \"hlen %u, proto 0x%04x, \", l2info->header_len, l2info->proto));\n\n    return 1; /* everything went ok so far. continue parsing */\n trunc:\n    ND_PRINT((ndo, \"[|juniper_hdr], length %u\", h->len));\n    return 0;\n}\n",
    "cwe": [
      "CWE-125"
    ],
    "id": 80,
    "_valid_cwes": [
      "CWE-125"
    ]
  },
  {
    "cve_id": "CVE-2017-12992",
    "code_before_change": "ripng_print(netdissect_options *ndo, const u_char *dat, unsigned int length)\n {\n \tregister const struct rip6 *rp = (const struct rip6 *)dat;\n \tregister const struct netinfo6 *ni;\n\tregister u_int amt;\n\tregister u_int i;\n\tint j;\n\tint trunc;\n\tif (ndo->ndo_snapend < dat)\n\t\treturn;\n\tamt = ndo->ndo_snapend - dat;\n\ti = min(length, amt);\n\tif (i < (sizeof(struct rip6) - sizeof(struct netinfo6)))\n\t\treturn;\n\ti -= (sizeof(struct rip6) - sizeof(struct netinfo6));\n \n \tswitch (rp->rip6_cmd) {\n \n \tcase RIP6_REQUEST:\n\t\tj = length / sizeof(*ni);\n\t\tif (j == 1\n\t\t    &&  rp->rip6_nets->rip6_metric == HOPCNT_INFINITY6\n\t\t    &&  IN6_IS_ADDR_UNSPECIFIED(&rp->rip6_nets->rip6_dest)) {\n\t\t\tND_PRINT((ndo, \" ripng-req dump\"));\n\t\t\tbreak;\n \t\t}\n\t\tif (j * sizeof(*ni) != length - 4)\n\t\t\tND_PRINT((ndo, \" ripng-req %d[%u]:\", j, length));\n \t\telse\n\t\t\tND_PRINT((ndo, \" ripng-req %d:\", j));\n\t\ttrunc = ((i / sizeof(*ni)) * sizeof(*ni) != i);\n\t\tfor (ni = rp->rip6_nets; i >= sizeof(*ni);\n\t\t    i -= sizeof(*ni), ++ni) {\n \t\t\tif (ndo->ndo_vflag > 1)\n \t\t\t\tND_PRINT((ndo, \"\\n\\t\"));\n \t\t\telse\n \t\t\t\tND_PRINT((ndo, \" \"));\n \t\t\trip6_entry_print(ndo, ni, 0);\n \t\t}\n \t\tbreak;\n \tcase RIP6_RESPONSE:\n\t\tj = length / sizeof(*ni);\n\t\tif (j * sizeof(*ni) != length - 4)\n \t\t\tND_PRINT((ndo, \" ripng-resp %d[%u]:\", j, length));\n \t\telse\n \t\t\tND_PRINT((ndo, \" ripng-resp %d:\", j));\n\t\ttrunc = ((i / sizeof(*ni)) * sizeof(*ni) != i);\n\t\tfor (ni = rp->rip6_nets; i >= sizeof(*ni);\n\t\t    i -= sizeof(*ni), ++ni) {\n \t\t\tif (ndo->ndo_vflag > 1)\n \t\t\t\tND_PRINT((ndo, \"\\n\\t\"));\n \t\t\telse\n \t\t\t\tND_PRINT((ndo, \" \"));\n \t\t\trip6_entry_print(ndo, ni, ni->rip6_metric);\n \t\t}\n\t\tif (trunc)\n\t\t\tND_PRINT((ndo, \"[|ripng]\"));\n \t\tbreak;\n \tdefault:\n \t\tND_PRINT((ndo, \" ripng-%d ?? %u\", rp->rip6_cmd, length));\n \t\tbreak;\n \t}\n \tif (rp->rip6_vers != RIP6_VERSION)\n \t\tND_PRINT((ndo, \" [vers %d]\", rp->rip6_vers));\n }\n",
    "code_after_change": "ripng_print(netdissect_options *ndo, const u_char *dat, unsigned int length)\n {\n \tregister const struct rip6 *rp = (const struct rip6 *)dat;\n \tregister const struct netinfo6 *ni;\n\tunsigned int length_left;\n\tu_int j;\n \n\tND_TCHECK(rp->rip6_cmd);\n \tswitch (rp->rip6_cmd) {\n \n \tcase RIP6_REQUEST:\n\t\tlength_left = length;\n\t\tif (length_left < (sizeof(struct rip6) - sizeof(struct netinfo6)))\n\t\t\tgoto trunc;\n\t\tlength_left -= (sizeof(struct rip6) - sizeof(struct netinfo6));\n \t\tj = length_left / sizeof(*ni);\n\t\tif (j == 1) {\n\t\t\tND_TCHECK(rp->rip6_nets);\n\t\t\tif (rp->rip6_nets->rip6_metric == HOPCNT_INFINITY6\n\t\t\t    &&  IN6_IS_ADDR_UNSPECIFIED(&rp->rip6_nets->rip6_dest)) {\n\t\t\t\tND_PRINT((ndo, \" ripng-req dump\"));\n\t\t\t\tbreak;\n\t\t\t}\n \t\t}\n\t\tif (j * sizeof(*ni) != length_left)\n\t\t\tND_PRINT((ndo, \" ripng-req %u[%u]:\", j, length));\n \t\telse\n\t\t\tND_PRINT((ndo, \" ripng-req %u:\", j));\n\t\tfor (ni = rp->rip6_nets; length_left >= sizeof(*ni);\n\t\t    length_left -= sizeof(*ni), ++ni) {\n\t\t\tND_TCHECK(*ni);\n \t\t\tif (ndo->ndo_vflag > 1)\n \t\t\t\tND_PRINT((ndo, \"\\n\\t\"));\n \t\t\telse\n \t\t\t\tND_PRINT((ndo, \" \"));\n \t\t\trip6_entry_print(ndo, ni, 0);\n \t\t}\n\t\tif (length_left != 0)\n\t\t\tgoto trunc;\n \t\tbreak;\n \tcase RIP6_RESPONSE:\n\t\tlength_left = length;\n\t\tif (length_left < (sizeof(struct rip6) - sizeof(struct netinfo6)))\n\t\t\tgoto trunc;\n\t\tlength_left -= (sizeof(struct rip6) - sizeof(struct netinfo6));\n\t\tj = length_left / sizeof(*ni);\n\t\tif (j * sizeof(*ni) != length_left)\n \t\t\tND_PRINT((ndo, \" ripng-resp %d[%u]:\", j, length));\n \t\telse\n \t\t\tND_PRINT((ndo, \" ripng-resp %d:\", j));\n\t\tfor (ni = rp->rip6_nets; length_left >= sizeof(*ni);\n\t\t    length_left -= sizeof(*ni), ++ni) {\n\t\t\tND_TCHECK(*ni);\n \t\t\tif (ndo->ndo_vflag > 1)\n \t\t\t\tND_PRINT((ndo, \"\\n\\t\"));\n \t\t\telse\n \t\t\t\tND_PRINT((ndo, \" \"));\n \t\t\trip6_entry_print(ndo, ni, ni->rip6_metric);\n \t\t}\n\t\tif (length_left != 0)\n\t\t\tgoto trunc;\n \t\tbreak;\n \tdefault:\n \t\tND_PRINT((ndo, \" ripng-%d ?? %u\", rp->rip6_cmd, length));\n \t\tbreak;\n \t}\n\tND_TCHECK(rp->rip6_vers);\n \tif (rp->rip6_vers != RIP6_VERSION)\n \t\tND_PRINT((ndo, \" [vers %d]\", rp->rip6_vers));\n\treturn;\n\ntrunc:\n\tND_PRINT((ndo, \"[|ripng]\"));\n\treturn;\n }\n",
    "cwe": [
      "CWE-125"
    ],
    "id": 106,
    "_valid_cwes": [
      "CWE-125"
    ]
  },
  {
    "cve_id": "CVE-2018-20553",
    "code_before_change": "int _our_safe_pcap_next_ex(pcap_t *pcap, struct pcap_pkthdr **pkthdr,\n        const u_char **pktdata, const char *funcname,\n        const int line, const char *file)\n{\n    int res = pcap_next_ex(pcap, pkthdr, pktdata);\n\n    if (*pktdata && *pkthdr) {\n        if ((*pkthdr)->len > MAXPACKET) {\n            fprintf(stderr, \"safe_pcap_next_ex ERROR: Invalid packet length in %s:%s() line %d: %u is greater than maximum %u\\n\",\n                    file, funcname, line, (*pkthdr)->len, MAXPACKET);\n             exit(-1);\n         }\n \n        if ((*pkthdr)->len < (*pkthdr)->caplen) {\n            fprintf(stderr, \"safe_pcap_next_ex ERROR: Invalid packet length in %s:%s() line %d: packet length %u is less than capture length %u\\n\",\n                     file, funcname, line, (*pkthdr)->len, (*pkthdr)->caplen);\n             exit(-1);\n         }\n    }\n\n    return res;\n}\n",
    "code_after_change": "int _our_safe_pcap_next_ex(pcap_t *pcap, struct pcap_pkthdr **pkthdr,\n        const u_char **pktdata, const char *funcname,\n        const int line, const char *file)\n{\n    int res = pcap_next_ex(pcap, pkthdr, pktdata);\n\n    if (*pktdata && *pkthdr) {\n        if ((*pkthdr)->len > MAXPACKET) {\n            fprintf(stderr, \"safe_pcap_next_ex ERROR: Invalid packet length in %s:%s() line %d: %u is greater than maximum %u\\n\",\n                    file, funcname, line, (*pkthdr)->len, MAXPACKET);\n             exit(-1);\n         }\n \n        if (!(*pkthdr)->len || (*pkthdr)->len < (*pkthdr)->caplen) {\n            fprintf(stderr, \"safe_pcap_next_ex ERROR: Invalid packet length in %s:%s() line %d: packet length=%u capture length=%u\\n\",\n                     file, funcname, line, (*pkthdr)->len, (*pkthdr)->caplen);\n             exit(-1);\n         }\n    }\n\n    return res;\n}\n",
    "cwe": [
      "CWE-125"
    ],
    "id": 107,
    "_valid_cwes": [
      "CWE-125"
    ]
  },
  {
    "cve_id": "CVE-2018-13006",
    "code_before_change": "GF_Err sgpd_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i;\n\tGF_SampleGroupDescriptionBox *ptr = (GF_SampleGroupDescriptionBox*) a;\n\tif (!a) return GF_BAD_PARAM;\n\n\tgf_isom_box_dump_start(a, \"SampleGroupDescriptionBox\", trace);\n\n\tif (ptr->grouping_type)\n\t\tfprintf(trace, \"grouping_type=\\\"%s\\\"\", gf_4cc_to_str(ptr->grouping_type) );\n\tif (ptr->version==1) fprintf(trace, \" default_length=\\\"%d\\\"\", ptr->default_length);\n\tif ((ptr->version>=2) && ptr->default_description_index) fprintf(trace, \" default_group_index=\\\"%d\\\"\", ptr->default_description_index);\n\tfprintf(trace, \">\\n\");\n\tfor (i=0; i<gf_list_count(ptr->group_descriptions); i++) {\n\t\tvoid *entry = gf_list_get(ptr->group_descriptions, i);\n\t\tswitch (ptr->grouping_type) {\n\t\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\t\t\tfprintf(trace, \"<RollRecoveryEntry roll_distance=\\\"%d\\\" />\\n\", ((GF_RollRecoveryEntry*)entry)->roll_distance );\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_PROL:\n\t\t\tfprintf(trace, \"<AudioPreRollEntry roll_distance=\\\"%d\\\" />\\n\", ((GF_RollRecoveryEntry*)entry)->roll_distance );\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_TELE:\n\t\t\tfprintf(trace, \"<TemporalLevelEntry level_independently_decodable=\\\"%d\\\"/>\\n\", ((GF_TemporalLevelEntry*)entry)->level_independently_decodable);\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\t\t\tfprintf(trace, \"<VisualRandomAccessEntry num_leading_samples_known=\\\"%s\\\"\", ((GF_VisualRandomAccessEntry*)entry)->num_leading_samples_known ? \"yes\" : \"no\");\n\t\t\tif (((GF_VisualRandomAccessEntry*)entry)->num_leading_samples_known)\n\t\t\t\tfprintf(trace, \" num_leading_samples=\\\"%d\\\"\", ((GF_VisualRandomAccessEntry*)entry)->num_leading_samples);\n\t\t\tfprintf(trace, \"/>\\n\");\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\t\t\tfprintf(trace, \"<SyncSampleGroupEntry NAL_unit_type=\\\"%d\\\"/>\\n\", ((GF_SYNCEntry*)entry)->NALU_type);\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_SEIG:\n\t\t\tfprintf(trace, \"<CENCSampleEncryptionGroupEntry IsEncrypted=\\\"%d\\\" IV_size=\\\"%d\\\" KID=\\\"\", ((GF_CENCSampleEncryptionGroupEntry*)entry)->IsProtected, ((GF_CENCSampleEncryptionGroupEntry*)entry)->Per_Sample_IV_size);\n\t\t\tdump_data_hex(trace, (char *)((GF_CENCSampleEncryptionGroupEntry*)entry)->KID, 16);\n\t\t\tif ((((GF_CENCSampleEncryptionGroupEntry*)entry)->IsProtected == 1) && !((GF_CENCSampleEncryptionGroupEntry*)entry)->Per_Sample_IV_size) {\n\t\t\t\tfprintf(trace, \"\\\" constant_IV_size=\\\"%d\\\"  constant_IV=\\\"\", ((GF_CENCSampleEncryptionGroupEntry*)entry)->constant_IV_size);\n\t\t\t\tdump_data_hex(trace, (char *)((GF_CENCSampleEncryptionGroupEntry*)entry)->constant_IV, ((GF_CENCSampleEncryptionGroupEntry*)entry)->constant_IV_size);\n\t\t\t}\n\t\t\tfprintf(trace, \"\\\"/>\\n\");\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_OINF:\n\t\t\toinf_entry_dump(entry, trace);\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_LINF:\n\t\t\tlinf_dump(entry, trace);\n\t\t\tbreak;\n \t\tcase GF_ISOM_SAMPLE_GROUP_TRIF:\n \t\t\ttrif_dump(trace, (char *) ((GF_DefaultSampleGroupDescriptionEntry*)entry)->data,  ((GF_DefaultSampleGroupDescriptionEntry*)entry)->length);\n \t\t\tbreak;\n \t\tcase GF_ISOM_SAMPLE_GROUP_NALM:\n \t\t\tnalm_dump(trace, (char *) ((GF_DefaultSampleGroupDescriptionEntry*)entry)->data,  ((GF_DefaultSampleGroupDescriptionEntry*)entry)->length);\n \t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_SAP:\n\t\t\tfprintf(trace, \"<SAPEntry dependent_flag=\\\"%d\\\" SAP_type=\\\"%d\\\" />\\n\", ((GF_SAPEntry*)entry)->dependent_flag, ((GF_SAPEntry*)entry)->SAP_type);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(trace, \"<DefaultSampleGroupDescriptionEntry size=\\\"%d\\\" data=\\\"\", ((GF_DefaultSampleGroupDescriptionEntry*)entry)->length);\n\t\t\tdump_data(trace, (char *) ((GF_DefaultSampleGroupDescriptionEntry*)entry)->data,  ((GF_DefaultSampleGroupDescriptionEntry*)entry)->length);\n\t\t\tfprintf(trace, \"\\\"/>\\n\");\n\t\t}\n\t}\n\tif (!ptr->size) {\n\t\tswitch (ptr->grouping_type) {\n\t\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\t\t\tfprintf(trace, \"<RollRecoveryEntry roll_distance=\\\"\\\"/>\\n\");\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_PROL:\n\t\t\tfprintf(trace, \"<AudioPreRollEntry roll_distance=\\\"\\\"/>\\n\");\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_TELE:\n\t\t\tfprintf(trace, \"<TemporalLevelEntry level_independently_decodable=\\\"\\\"/>\\n\");\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\t\t\tfprintf(trace, \"<VisualRandomAccessEntry num_leading_samples_known=\\\"yes|no\\\" num_leading_samples=\\\"\\\" />\\n\");\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\t\t\tfprintf(trace, \"<SyncSampleGroupEntry NAL_unit_type=\\\"\\\" />\\n\");\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_SEIG:\n\t\t\tfprintf(trace, \"<CENCSampleEncryptionGroupEntry IsEncrypted=\\\"\\\" IV_size=\\\"\\\" KID=\\\"\\\" constant_IV_size=\\\"\\\"  constant_IV=\\\"\\\"/>\\n\");\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_OINF:\n\t\t\toinf_entry_dump(NULL, trace);\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_LINF:\n\t\t\tlinf_dump(NULL, trace);\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_TRIF:\n\t\t\ttrif_dump(trace, NULL, 0);\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_NALM:\n\t\t\tnalm_dump(trace, NULL, 0);\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_SAP:\n\t\t\tfprintf(trace, \"<SAPEntry dependent_flag=\\\"\\\" SAP_type=\\\"\\\" />\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(trace, \"<DefaultSampleGroupDescriptionEntry size=\\\"\\\" data=\\\"\\\"/>\\n\");\n\t\t}\n\t}\n\n\tgf_isom_box_dump_done(\"SampleGroupDescriptionBox\", a, trace);\n\treturn GF_OK;\n}\n",
    "code_after_change": "GF_Err sgpd_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i;\n\tGF_SampleGroupDescriptionBox *ptr = (GF_SampleGroupDescriptionBox*) a;\n\tif (!a) return GF_BAD_PARAM;\n\n\tgf_isom_box_dump_start(a, \"SampleGroupDescriptionBox\", trace);\n\n\tif (ptr->grouping_type)\n\t\tfprintf(trace, \"grouping_type=\\\"%s\\\"\", gf_4cc_to_str(ptr->grouping_type) );\n\tif (ptr->version==1) fprintf(trace, \" default_length=\\\"%d\\\"\", ptr->default_length);\n\tif ((ptr->version>=2) && ptr->default_description_index) fprintf(trace, \" default_group_index=\\\"%d\\\"\", ptr->default_description_index);\n\tfprintf(trace, \">\\n\");\n\tfor (i=0; i<gf_list_count(ptr->group_descriptions); i++) {\n\t\tvoid *entry = gf_list_get(ptr->group_descriptions, i);\n\t\tswitch (ptr->grouping_type) {\n\t\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\t\t\tfprintf(trace, \"<RollRecoveryEntry roll_distance=\\\"%d\\\" />\\n\", ((GF_RollRecoveryEntry*)entry)->roll_distance );\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_PROL:\n\t\t\tfprintf(trace, \"<AudioPreRollEntry roll_distance=\\\"%d\\\" />\\n\", ((GF_RollRecoveryEntry*)entry)->roll_distance );\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_TELE:\n\t\t\tfprintf(trace, \"<TemporalLevelEntry level_independently_decodable=\\\"%d\\\"/>\\n\", ((GF_TemporalLevelEntry*)entry)->level_independently_decodable);\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\t\t\tfprintf(trace, \"<VisualRandomAccessEntry num_leading_samples_known=\\\"%s\\\"\", ((GF_VisualRandomAccessEntry*)entry)->num_leading_samples_known ? \"yes\" : \"no\");\n\t\t\tif (((GF_VisualRandomAccessEntry*)entry)->num_leading_samples_known)\n\t\t\t\tfprintf(trace, \" num_leading_samples=\\\"%d\\\"\", ((GF_VisualRandomAccessEntry*)entry)->num_leading_samples);\n\t\t\tfprintf(trace, \"/>\\n\");\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\t\t\tfprintf(trace, \"<SyncSampleGroupEntry NAL_unit_type=\\\"%d\\\"/>\\n\", ((GF_SYNCEntry*)entry)->NALU_type);\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_SEIG:\n\t\t\tfprintf(trace, \"<CENCSampleEncryptionGroupEntry IsEncrypted=\\\"%d\\\" IV_size=\\\"%d\\\" KID=\\\"\", ((GF_CENCSampleEncryptionGroupEntry*)entry)->IsProtected, ((GF_CENCSampleEncryptionGroupEntry*)entry)->Per_Sample_IV_size);\n\t\t\tdump_data_hex(trace, (char *)((GF_CENCSampleEncryptionGroupEntry*)entry)->KID, 16);\n\t\t\tif ((((GF_CENCSampleEncryptionGroupEntry*)entry)->IsProtected == 1) && !((GF_CENCSampleEncryptionGroupEntry*)entry)->Per_Sample_IV_size) {\n\t\t\t\tfprintf(trace, \"\\\" constant_IV_size=\\\"%d\\\"  constant_IV=\\\"\", ((GF_CENCSampleEncryptionGroupEntry*)entry)->constant_IV_size);\n\t\t\t\tdump_data_hex(trace, (char *)((GF_CENCSampleEncryptionGroupEntry*)entry)->constant_IV, ((GF_CENCSampleEncryptionGroupEntry*)entry)->constant_IV_size);\n\t\t\t}\n\t\t\tfprintf(trace, \"\\\"/>\\n\");\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_OINF:\n\t\t\toinf_entry_dump(entry, trace);\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_LINF:\n\t\t\tlinf_dump(entry, trace);\n\t\t\tbreak;\n \t\tcase GF_ISOM_SAMPLE_GROUP_TRIF:\n \t\t\ttrif_dump(trace, (char *) ((GF_DefaultSampleGroupDescriptionEntry*)entry)->data,  ((GF_DefaultSampleGroupDescriptionEntry*)entry)->length);\n \t\t\tbreak;\n\n \t\tcase GF_ISOM_SAMPLE_GROUP_NALM:\n \t\t\tnalm_dump(trace, (char *) ((GF_DefaultSampleGroupDescriptionEntry*)entry)->data,  ((GF_DefaultSampleGroupDescriptionEntry*)entry)->length);\n \t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_SAP:\n\t\t\tfprintf(trace, \"<SAPEntry dependent_flag=\\\"%d\\\" SAP_type=\\\"%d\\\" />\\n\", ((GF_SAPEntry*)entry)->dependent_flag, ((GF_SAPEntry*)entry)->SAP_type);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(trace, \"<DefaultSampleGroupDescriptionEntry size=\\\"%d\\\" data=\\\"\", ((GF_DefaultSampleGroupDescriptionEntry*)entry)->length);\n\t\t\tdump_data(trace, (char *) ((GF_DefaultSampleGroupDescriptionEntry*)entry)->data,  ((GF_DefaultSampleGroupDescriptionEntry*)entry)->length);\n\t\t\tfprintf(trace, \"\\\"/>\\n\");\n\t\t}\n\t}\n\tif (!ptr->size) {\n\t\tswitch (ptr->grouping_type) {\n\t\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\t\t\tfprintf(trace, \"<RollRecoveryEntry roll_distance=\\\"\\\"/>\\n\");\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_PROL:\n\t\t\tfprintf(trace, \"<AudioPreRollEntry roll_distance=\\\"\\\"/>\\n\");\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_TELE:\n\t\t\tfprintf(trace, \"<TemporalLevelEntry level_independently_decodable=\\\"\\\"/>\\n\");\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\t\t\tfprintf(trace, \"<VisualRandomAccessEntry num_leading_samples_known=\\\"yes|no\\\" num_leading_samples=\\\"\\\" />\\n\");\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\t\t\tfprintf(trace, \"<SyncSampleGroupEntry NAL_unit_type=\\\"\\\" />\\n\");\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_SEIG:\n\t\t\tfprintf(trace, \"<CENCSampleEncryptionGroupEntry IsEncrypted=\\\"\\\" IV_size=\\\"\\\" KID=\\\"\\\" constant_IV_size=\\\"\\\"  constant_IV=\\\"\\\"/>\\n\");\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_OINF:\n\t\t\toinf_entry_dump(NULL, trace);\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_LINF:\n\t\t\tlinf_dump(NULL, trace);\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_TRIF:\n\t\t\ttrif_dump(trace, NULL, 0);\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_NALM:\n\t\t\tnalm_dump(trace, NULL, 0);\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_SAP:\n\t\t\tfprintf(trace, \"<SAPEntry dependent_flag=\\\"\\\" SAP_type=\\\"\\\" />\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(trace, \"<DefaultSampleGroupDescriptionEntry size=\\\"\\\" data=\\\"\\\"/>\\n\");\n\t\t}\n\t}\n\n\tgf_isom_box_dump_done(\"SampleGroupDescriptionBox\", a, trace);\n\treturn GF_OK;\n}\n",
    "cwe": [
      "CWE-125"
    ],
    "id": 166,
    "_valid_cwes": [
      "CWE-125"
    ]
  },
  {
    "cve_id": "CVE-2018-6067",
    "code_before_change": " void ParamTraits<SkBitmap>::Write(base::Pickle* m, const SkBitmap& p) {\n  size_t fixed_size = sizeof(SkBitmap_Data);\n  SkBitmap_Data bmp_data;\n  bmp_data.InitSkBitmapDataForTransfer(p);\n  m->WriteData(reinterpret_cast<const char*>(&bmp_data),\n               static_cast<int>(fixed_size));\n   size_t pixel_size = p.computeByteSize();\n   m->WriteData(reinterpret_cast<const char*>(p.getPixels()),\n                static_cast<int>(pixel_size));\n}\n",
    "code_after_change": " void ParamTraits<SkBitmap>::Write(base::Pickle* m, const SkBitmap& p) {\n  WriteParam(m, p.info());\n   size_t pixel_size = p.computeByteSize();\n   m->WriteData(reinterpret_cast<const char*>(p.getPixels()),\n                static_cast<int>(pixel_size));\n}\n",
    "cwe": [
      "CWE-125"
    ],
    "id": 173,
    "_valid_cwes": [
      "CWE-125"
    ]
  },
  {
    "cve_id": "CVE-2018-6038",
    "code_before_change": "void WebGL2RenderingContextBase::texImage3D(\n    GLenum target,\n    GLint level,\n    GLint internalformat,\n    GLsizei width,\n    GLsizei height,\n    GLsizei depth,\n    GLint border,\n    GLenum format,\n    GLenum type,\n    MaybeShared<DOMArrayBufferView> pixels,\n    GLuint src_offset) {\n  if (isContextLost())\n    return;\n  if (bound_pixel_unpack_buffer_) {\n    SynthesizeGLError(GL_INVALID_OPERATION, \"texImage3D\",\n                       \"a buffer is bound to PIXEL_UNPACK_BUFFER\");\n     return;\n   }\n   TexImageHelperDOMArrayBufferView(\n       kTexImage3D, target, level, internalformat, width, height, depth, border,\n       format, type, 0, 0, 0, pixels.View(), kNullNotReachable, src_offset);\n}\n",
    "code_after_change": "void WebGL2RenderingContextBase::texImage3D(\n    GLenum target,\n    GLint level,\n    GLint internalformat,\n    GLsizei width,\n    GLsizei height,\n    GLsizei depth,\n    GLint border,\n    GLenum format,\n    GLenum type,\n    MaybeShared<DOMArrayBufferView> pixels,\n    GLuint src_offset) {\n  if (isContextLost())\n    return;\n  if (bound_pixel_unpack_buffer_) {\n    SynthesizeGLError(GL_INVALID_OPERATION, \"texImage3D\",\n                       \"a buffer is bound to PIXEL_UNPACK_BUFFER\");\n     return;\n   }\n  if (unpack_flip_y_ || unpack_premultiply_alpha_) {\n    DCHECK(pixels);\n    SynthesizeGLError(\n        GL_INVALID_OPERATION, \"texImage3D\",\n        \"FLIP_Y or PREMULTIPLY_ALPHA isn't allowed for uploading 3D textures\");\n    return;\n  }\n   TexImageHelperDOMArrayBufferView(\n       kTexImage3D, target, level, internalformat, width, height, depth, border,\n       format, type, 0, 0, 0, pixels.View(), kNullNotReachable, src_offset);\n}\n",
    "cwe": [
      "CWE-125"
    ],
    "id": 195,
    "_valid_cwes": [
      "CWE-125"
    ]
  },
  {
    "cve_id": "CVE-2018-10887",
    "code_before_change": "int git_delta_apply(\n\tvoid **out,\n\tsize_t *out_len,\n\tconst unsigned char *base,\n\tsize_t base_len,\n\tconst unsigned char *delta,\n\tsize_t delta_len)\n{\n\tconst unsigned char *delta_end = delta + delta_len;\n\tsize_t base_sz, res_sz, alloc_sz;\n\tunsigned char *res_dp;\n\n\t*out = NULL;\n\t*out_len = 0;\n\n\t/*\n\t * Check that the base size matches the data we were given;\n\t * if not we would underflow while accessing data from the\n\t * base object, resulting in data corruption or segfault.\n\t */\n\tif ((hdr_sz(&base_sz, &delta, delta_end) < 0) || (base_sz != base_len)) {\n\t\tgiterr_set(GITERR_INVALID, \"failed to apply delta: base size does not match given data\");\n\t\treturn -1;\n\t}\n\n\tif (hdr_sz(&res_sz, &delta, delta_end) < 0) {\n\t\tgiterr_set(GITERR_INVALID, \"failed to apply delta: base size does not match given data\");\n\t\treturn -1;\n\t}\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_sz, res_sz, 1);\n\tres_dp = git__malloc(alloc_sz);\n\tGITERR_CHECK_ALLOC(res_dp);\n\n\tres_dp[res_sz] = '\\0';\n\t*out = res_dp;\n\t*out_len = res_sz;\n\n\twhile (delta < delta_end) {\n \t\tunsigned char cmd = *delta++;\n \t\tif (cmd & 0x80) {\n \t\t\t/* cmd is a copy instruction; copy from the base. */\n\t\t\tsize_t off = 0, len = 0;\n \n #define ADD_DELTA(o, shift) { if (delta < delta_end) (o) |= ((unsigned) *delta++ << shift); else goto fail; }\n \t\t\tif (cmd & 0x01) ADD_DELTA(off, 0UL);\n\t\t\tif (cmd & 0x02) ADD_DELTA(off, 8UL);\n\t\t\tif (cmd & 0x04) ADD_DELTA(off, 16UL);\n\t\t\tif (cmd & 0x08) ADD_DELTA(off, 24UL);\n\n\t\t\tif (cmd & 0x10) ADD_DELTA(len, 0UL);\n\t\t\tif (cmd & 0x20) ADD_DELTA(len, 8UL);\n\t\t\tif (cmd & 0x40) ADD_DELTA(len, 16UL);\n \t\t\tif (!len)       len = 0x10000;\n #undef ADD_DELTA\n \n\t\t\tif (base_len < off + len || res_sz < len)\n \t\t\t\tgoto fail;\n \t\t\tmemcpy(res_dp, base + off, len);\n \t\t\tres_dp += len;\n \t\t\tres_sz -= len;\n\n\t\t} else if (cmd) {\n\t\t\t/*\n\t\t\t * cmd is a literal insert instruction; copy from\n\t\t\t * the delta stream itself.\n\t\t\t */\n\t\t\tif (delta_end - delta < cmd || res_sz < cmd)\n\t\t\t\tgoto fail;\n\t\t\tmemcpy(res_dp, delta, cmd);\n\t\t\tdelta += cmd;\n\t\t\tres_dp += cmd;\n\t\t\tres_sz -= cmd;\n\n\t\t} else {\n\t\t\t/* cmd == 0 is reserved for future encodings. */\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tif (delta != delta_end || res_sz)\n\t\tgoto fail;\n\treturn 0;\n\nfail:\n\tgit__free(*out);\n\n\t*out = NULL;\n\t*out_len = 0;\n\n\tgiterr_set(GITERR_INVALID, \"failed to apply delta\");\n\treturn -1;\n}\n",
    "code_after_change": "int git_delta_apply(\n\tvoid **out,\n\tsize_t *out_len,\n\tconst unsigned char *base,\n\tsize_t base_len,\n\tconst unsigned char *delta,\n\tsize_t delta_len)\n{\n\tconst unsigned char *delta_end = delta + delta_len;\n\tsize_t base_sz, res_sz, alloc_sz;\n\tunsigned char *res_dp;\n\n\t*out = NULL;\n\t*out_len = 0;\n\n\t/*\n\t * Check that the base size matches the data we were given;\n\t * if not we would underflow while accessing data from the\n\t * base object, resulting in data corruption or segfault.\n\t */\n\tif ((hdr_sz(&base_sz, &delta, delta_end) < 0) || (base_sz != base_len)) {\n\t\tgiterr_set(GITERR_INVALID, \"failed to apply delta: base size does not match given data\");\n\t\treturn -1;\n\t}\n\n\tif (hdr_sz(&res_sz, &delta, delta_end) < 0) {\n\t\tgiterr_set(GITERR_INVALID, \"failed to apply delta: base size does not match given data\");\n\t\treturn -1;\n\t}\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_sz, res_sz, 1);\n\tres_dp = git__malloc(alloc_sz);\n\tGITERR_CHECK_ALLOC(res_dp);\n\n\tres_dp[res_sz] = '\\0';\n\t*out = res_dp;\n\t*out_len = res_sz;\n\n\twhile (delta < delta_end) {\n \t\tunsigned char cmd = *delta++;\n \t\tif (cmd & 0x80) {\n \t\t\t/* cmd is a copy instruction; copy from the base. */\n\t\t\tsize_t off = 0, len = 0, end;\n \n #define ADD_DELTA(o, shift) { if (delta < delta_end) (o) |= ((unsigned) *delta++ << shift); else goto fail; }\n \t\t\tif (cmd & 0x01) ADD_DELTA(off, 0UL);\n\t\t\tif (cmd & 0x02) ADD_DELTA(off, 8UL);\n\t\t\tif (cmd & 0x04) ADD_DELTA(off, 16UL);\n\t\t\tif (cmd & 0x08) ADD_DELTA(off, 24UL);\n\n\t\t\tif (cmd & 0x10) ADD_DELTA(len, 0UL);\n\t\t\tif (cmd & 0x20) ADD_DELTA(len, 8UL);\n\t\t\tif (cmd & 0x40) ADD_DELTA(len, 16UL);\n \t\t\tif (!len)       len = 0x10000;\n #undef ADD_DELTA\n \n\t\t\tif (GIT_ADD_SIZET_OVERFLOW(&end, off, len) ||\n\t\t\t    base_len < end || res_sz < len)\n \t\t\t\tgoto fail;\n\n \t\t\tmemcpy(res_dp, base + off, len);\n \t\t\tres_dp += len;\n \t\t\tres_sz -= len;\n\n\t\t} else if (cmd) {\n\t\t\t/*\n\t\t\t * cmd is a literal insert instruction; copy from\n\t\t\t * the delta stream itself.\n\t\t\t */\n\t\t\tif (delta_end - delta < cmd || res_sz < cmd)\n\t\t\t\tgoto fail;\n\t\t\tmemcpy(res_dp, delta, cmd);\n\t\t\tdelta += cmd;\n\t\t\tres_dp += cmd;\n\t\t\tres_sz -= cmd;\n\n\t\t} else {\n\t\t\t/* cmd == 0 is reserved for future encodings. */\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tif (delta != delta_end || res_sz)\n\t\tgoto fail;\n\treturn 0;\n\nfail:\n\tgit__free(*out);\n\n\t*out = NULL;\n\t*out_len = 0;\n\n\tgiterr_set(GITERR_INVALID, \"failed to apply delta\");\n\treturn -1;\n}\n",
    "cwe": [
      "CWE-125"
    ],
    "id": 206,
    "_valid_cwes": [
      "CWE-125"
    ]
  },
  {
    "cve_id": "CVE-2018-7729",
    "code_before_change": "void PostScript_MetaHandler::ParsePSFile()\n{\n\tbool     found = false;\n\tIOBuffer ioBuf;\n\n\tXMP_IO* fileRef = this->parent->ioRef;\n\n\tXMP_AbortProc abortProc  = this->parent->abortProc;\n\tvoid *        abortArg   = this->parent->abortArg;\n\tconst bool    checkAbort = (abortProc != 0);\n\n\tif ( ! PostScript_Support::IsValidPSFile(fileRef,this->fileformat) ) return ; \n\n\tfileRef->Rewind();\n\tif ( ! CheckFileSpace ( fileRef, &ioBuf, 4 ) ) return ;\n\tXMP_Uns32 fileheader = GetUns32BE ( ioBuf.ptr );\n\n\tif ( fileheader == 0xC5D0D3C6 ) \n\t{\n\n\t\tif ( ! CheckFileSpace ( fileRef, &ioBuf, 30 ) ) return ;\n\n\t\tXMP_Uns32 psOffset = GetUns32LE ( ioBuf.ptr+4 );\t// PostScript offset.\n\t\tXMP_Uns32 psLength = GetUns32LE ( ioBuf.ptr+8 );\t// PostScript length.\n\n\t\tsetTokenInfo(kPS_EndPostScript,psOffset+psLength,0);\n\t\tMoveToOffset ( fileRef, psOffset, &ioBuf );\n\n\t}\n\n\twhile ( true ) \n\t{\n\t\tif ( checkAbort && abortProc(abortArg) ) {\n\t\t\tXMP_Throw ( \"PostScript_MetaHandler::FindPostScriptHint - User abort\", kXMPErr_UserAbort );\n\t\t}\n\n\t\tif ( ! CheckFileSpace ( fileRef, &ioBuf, kPSContainsForString.length() ) ) return ;\n\n\t\tif ( (CheckFileSpace ( fileRef, &ioBuf, kPSEndCommentString.length() )&& \n\t\t\t\tCheckBytes ( ioBuf.ptr, Uns8Ptr(kPSEndCommentString.c_str()), kPSEndCommentString.length() )\n\t\t\t\t)|| *ioBuf.ptr!='%' || !(*(ioBuf.ptr+1)>32 && *(ioBuf.ptr+1)<=126 )) // implicit endcomment check\n\t\t{\n\t\t\tif (CheckBytes ( ioBuf.ptr, Uns8Ptr(kPSEndCommentString.c_str()), kPSEndCommentString.length() ))\n\t\t\t{\n\t\t\t\tsetTokenInfo(kPS_EndComments,ioBuf.filePos+ioBuf.ptr-ioBuf.data,kPSEndCommentString.length());\n\t\t\t\tioBuf.ptr+=kPSEndCommentString.length();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsetTokenInfo(kPS_EndComments,ioBuf.filePos+ioBuf.ptr-ioBuf.data,0);\n\t\t\t}\n\t\t\twhile(true)\n\t\t\t{\n\t\t\t\tif ( ! CheckFileSpace ( fileRef, &ioBuf, 1 ) ) return ;\n\t\t\t\tif (! IsWhitespace (*ioBuf.ptr)) break;\n\t\t\t\t++ioBuf.ptr;\n\t\t\t} \n\t\t\twhile(true)\n\t\t\t{\n\t\t\t\tif ( ! CheckFileSpace ( fileRef, &ioBuf, 5 ) ) return ;\n\t\t\t\tif (CheckBytes ( ioBuf.ptr, Uns8Ptr(\"/DOCI\"), 5 ) \n\t\t\t\t\t&& CheckFileSpace ( fileRef, &ioBuf, kPSContainsDocInfoString.length() )\n\t\t\t\t\t&&CheckBytes ( ioBuf.ptr, Uns8Ptr(kPSContainsDocInfoString.c_str()), kPSContainsDocInfoString.length() ))\n\t\t\t\t\t\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\tioBuf.ptr+=kPSContainsDocInfoString.length();\n\t\t\t\t\tExtractDocInfoDict(ioBuf);\n\t\t\t\t}// DOCINFO Not found in document\n\t\t\t\telse if(CheckBytes ( ioBuf.ptr, Uns8Ptr(\"%%Beg\"), 5 ))\n\t\t\t\t{//possibly one of %%BeginProlog %%BeginSetup %%BeginBinary %%BeginData \n\t\t\t\t\tXMP_Int64 begStartpos=ioBuf.filePos+ioBuf.ptr-ioBuf.data;\n\t\t\t\t\tioBuf.ptr+=5;\n\t\t\t\t\tif (!CheckFileSpace ( fileRef, &ioBuf, 6 )) return;\n\t\t\t\t\tif(CheckBytes ( ioBuf.ptr, Uns8Ptr(\"inProl\"), 6 ))\n\t\t\t\t\t{//%%BeginProlog\n\t\t\t\t\t\tioBuf.ptr+=6;\n\t\t\t\t\t\tif (!CheckFileSpace ( fileRef, &ioBuf, 2 ))return;\n\t\t\t\t\t\tif(CheckBytes ( ioBuf.ptr, Uns8Ptr(\"og\"), 2 ))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tioBuf.ptr+=2;\n\t\t\t\t\t\t\tsetTokenInfo(kPS_BeginProlog,begStartpos,13);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (CheckBytes ( ioBuf.ptr, Uns8Ptr(\"inSetu\"), 6 ))\n\t\t\t\t\t{//%%BeginSetup \n\t\t\t\t\t\tioBuf.ptr+=6;\n\t\t\t\t\t\tif (!CheckFileSpace ( fileRef, &ioBuf, 1 ))return;\n\t\t\t\t\t\tif(CheckBytes ( ioBuf.ptr, Uns8Ptr(\"p\"), 1 ))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tioBuf.ptr+=1;\n\t\t\t\t\t\t\tsetTokenInfo(kPS_BeginSetup,begStartpos,12);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (CheckBytes ( ioBuf.ptr, Uns8Ptr(\"inBina\"), 6 ))\n\t\t\t\t\t{//%%BeginBinary\n\t\t\t\t\t\tioBuf.ptr+=6;\n\t\t\t\t\t\tif (!CheckFileSpace ( fileRef, &ioBuf, 3 ))return;\n\t\t\t\t\t\tif(CheckBytes ( ioBuf.ptr, Uns8Ptr(\"ry\"), 3 ))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tioBuf.ptr+=3;\n\t\t\t\t\t\t\twhile(true)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (!CheckFileSpace ( fileRef, &ioBuf, 12 ))return;\n\t\t\t\t\t\t\t\tif (CheckBytes ( ioBuf.ptr, Uns8Ptr(\"%%EndBinary\"), 11 ))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tioBuf.ptr+=11;\n\t\t\t\t\t\t\t\t\tif (IsWhitespace(*ioBuf.ptr))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tioBuf.ptr++;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t++ioBuf.ptr;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (CheckBytes ( ioBuf.ptr, Uns8Ptr(\"inData\"), 6 ))\n\t\t\t\t\t{//%%BeginData\n\t\t\t\t\t\tioBuf.ptr+=6;\n\t\t\t\t\t\tif (!CheckFileSpace ( fileRef, &ioBuf, 1 ))return;\n\t\t\t\t\t\tif(CheckBytes ( ioBuf.ptr, Uns8Ptr(\":\"), 1 ))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\twhile(true)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (!CheckFileSpace ( fileRef, &ioBuf, 10 ))return;\n\t\t\t\t\t\t\t\tif (CheckBytes ( ioBuf.ptr, Uns8Ptr(\"%%EndData\"), 9 ))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tioBuf.ptr+=9;\n\t\t\t\t\t\t\t\t\tif (IsWhitespace(*ioBuf.ptr))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tioBuf.ptr++;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t++ioBuf.ptr;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (CheckBytes ( ioBuf.ptr, Uns8Ptr(\"inDocu\"), 6 ))\n\t\t\t\t\t{// %%BeginDocument\n\t\t\t\t\t\tioBuf.ptr+=6;\n\t\t\t\t\t\tif (!CheckFileSpace ( fileRef, &ioBuf, 5 ))return;\n\t\t\t\t\t\tif(CheckBytes ( ioBuf.ptr, Uns8Ptr(\"ment:\"), 5 ))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tioBuf.ptr+=5;\n\t\t\t\t\t\t\twhile(true)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (!CheckFileSpace ( fileRef, &ioBuf, 14 ))return;\n\t\t\t\t\t\t\t\tif (CheckBytes ( ioBuf.ptr, Uns8Ptr(\"%%EndDocument\"), 13 ))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tioBuf.ptr+=13;\n\t\t\t\t\t\t\t\t\tif (IsWhitespace(*ioBuf.ptr))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tioBuf.ptr++;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t++ioBuf.ptr;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (CheckBytes ( ioBuf.ptr, Uns8Ptr(\"inPage\"), 6 ))\n\t\t\t\t\t{// %%BeginPageSetup\n\t\t\t\t\t\tioBuf.ptr+=6;\n\t\t\t\t\t\tif (!CheckFileSpace ( fileRef, &ioBuf, 5 ))return;\n\t\t\t\t\t\tif(CheckBytes ( ioBuf.ptr, Uns8Ptr(\"Setup\"), 5 ))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tioBuf.ptr+=5;\n\t\t\t\t\t\t\tsetTokenInfo(kPS_BeginPageSetup,begStartpos,16);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(CheckBytes ( ioBuf.ptr, Uns8Ptr(\"%%End\"), 5 ))\n\t\t\t\t{//possibly %%EndProlog %%EndSetup %%EndPageSetup %%EndPageComments\n\t\t\t\t\tXMP_Int64 begStartpos=ioBuf.filePos+ioBuf.ptr-ioBuf.data;\n\t\t\t\t\tioBuf.ptr+=5;\n\t\t\t\t\tif ( ! CheckFileSpace ( fileRef, &ioBuf, 5 ) ) return ;\n\t\t\t\t\tif (CheckBytes ( ioBuf.ptr, Uns8Ptr(\"Prolo\"), 5 ))\n\t\t\t\t\t{// %%EndProlog\n\t\t\t\t\t\tioBuf.ptr+=5;\n\t\t\t\t\t\tif ( ! CheckFileSpace ( fileRef, &ioBuf, 1 ) ) return ;\n\t\t\t\t\t\tif (CheckBytes ( ioBuf.ptr, Uns8Ptr(\"g\"), 1 ))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tioBuf.ptr+=1;\n\t\t\t\t\t\t\tsetTokenInfo(kPS_EndProlog,begStartpos,11);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (CheckBytes ( ioBuf.ptr, Uns8Ptr(\"Setup\"), 5 ))\n\t\t\t\t\t{//%%EndSetup\n\t\t\t\t\t\tioBuf.ptr+=5;\n\t\t\t\t\t\tsetTokenInfo(kPS_EndSetup,begStartpos,10);\n\t\t\t\t\t}\n\t\t\t\t\telse if (CheckBytes ( ioBuf.ptr, Uns8Ptr(\"PageS\"), 5 ))\n\t\t\t\t\t{//%%EndPageSetup\n\t\t\t\t\t\tioBuf.ptr+=5;\n\t\t\t\t\t\tif ( ! CheckFileSpace ( fileRef, &ioBuf, 4 ) ) return ;\n\t\t\t\t\t\tif (CheckBytes ( ioBuf.ptr, Uns8Ptr(\"etup\"), 4 ))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tioBuf.ptr+=4;\n\t\t\t\t\t\t\tsetTokenInfo(kPS_EndPageSetup,begStartpos,14);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (CheckBytes ( ioBuf.ptr, Uns8Ptr(\"PageC\"), 5 ))\n\t\t\t\t\t{//%%EndPageComments\n\t\t\t\t\t\tioBuf.ptr+=5;\n\t\t\t\t\t\tif ( ! CheckFileSpace ( fileRef, &ioBuf, 7 ) ) return ;\n\t\t\t\t\t\tif (CheckBytes ( ioBuf.ptr, Uns8Ptr(\"omments\"), 7 ))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tioBuf.ptr+=7;\n\t\t\t\t\t\t\tsetTokenInfo(kPS_EndPageComments,begStartpos,17);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(CheckBytes ( ioBuf.ptr, Uns8Ptr(\"%%Pag\"), 5 ))\n\t\t\t\t{\n\t\t\t\t\tXMP_Int64 begStartpos=ioBuf.filePos+ioBuf.ptr-ioBuf.data;\n\t\t\t\t\tioBuf.ptr+=5;\n\t\t\t\t\tif ( ! CheckFileSpace ( fileRef, &ioBuf, 2 ) ) return ;\n\t\t\t\t\tif (CheckBytes ( ioBuf.ptr, Uns8Ptr(\":\"), 2 ))\n\t\t\t\t\t{\n\t\t\t\t\t\tioBuf.ptr+=2;\n\t\t\t\t\t\twhile(!IsNewline(*ioBuf.ptr))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif ( ! CheckFileSpace ( fileRef, &ioBuf, 1 ) ) return ;\n\t\t\t\t\t\t\t++ioBuf.ptr;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsetTokenInfo(kPS_Page,begStartpos,ioBuf.filePos+ioBuf.ptr-ioBuf.data-begStartpos);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\telse if(CheckBytes ( ioBuf.ptr, Uns8Ptr(\"%%Tra\"), 5 ))\n\t\t\t\t{\n\t\t\t\t\tXMP_Int64 begStartpos=ioBuf.filePos+ioBuf.ptr-ioBuf.data;\n\t\t\t\t\tioBuf.ptr+=5;\n\t\t\t\t\tif ( ! CheckFileSpace ( fileRef, &ioBuf, 4 ) ) return ;\n \t\t\t\t\tif (CheckBytes ( ioBuf.ptr, Uns8Ptr(\"iler\"), 4 ))\n \t\t\t\t\t{\n \t\t\t\t\t\tioBuf.ptr+=4;\n\t\t\t\t\t\twhile(!IsNewline(*ioBuf.ptr)) ++ioBuf.ptr;\n \t\t\t\t\t\tsetTokenInfo(kPS_Trailer,begStartpos,ioBuf.filePos+ioBuf.ptr-ioBuf.data-begStartpos);\n \t\t\t\t\t}\n \t\t\t\t}\n\t\t\t\t\tioBuf.ptr+=5;\n\t\t\t\t\tsetTokenInfo(kPS_EOF,ioBuf.filePos+ioBuf.ptr-ioBuf.data,5);\n\t\t\t\t}\n\t\t\t\tif ( ! CheckFileSpace ( fileRef, &ioBuf, 1 ) ) return ;\n\t\t\t\t++ioBuf.ptr;\n\t\t\t}\n\t\t\treturn;\n\n\t\t}else if (!(kPS_Creator & dscFlags) && \n\t\t\t CheckFileSpace ( fileRef, &ioBuf, kPSContainsForString.length() )&&\n\t\t\tCheckBytes ( ioBuf.ptr, Uns8Ptr(kPSContainsForString.c_str()), kPSContainsForString.length() ))\n\t\t{\n\t\t\tioBuf.ptr+=kPSContainsForString.length();\n\t\t\tif ( ! ExtractDSCCommentValue(ioBuf,kPS_dscFor) ) return ;\n\t\t}\n\t\telse if (!(kPS_CreatorTool & dscFlags) &&\n\t\t\t CheckFileSpace ( fileRef, &ioBuf, kPSContainsCreatorString.length() )&&\n\t\t\t CheckBytes ( ioBuf.ptr, Uns8Ptr(kPSContainsCreatorString.c_str()), kPSContainsCreatorString.length() ))\n\t\t{\n\t\t\tioBuf.ptr+=kPSContainsCreatorString.length();\n\t\t\tif ( ! ExtractDSCCommentValue(ioBuf,kPS_dscCreator) ) return ;\n\t\t}\n\t\telse if (!(kPS_CreateDate & dscFlags) &&\n\t\t\t CheckFileSpace ( fileRef, &ioBuf, kPSContainsCreateDateString.length() )&&\n\t\t\tCheckBytes ( ioBuf.ptr, Uns8Ptr(kPSContainsCreateDateString.c_str()), kPSContainsCreateDateString.length() ))\n\t\t{\n\t\t\t\n\t\t\tioBuf.ptr+=kPSContainsCreateDateString.length();\n\t\t\tif ( ! ExtractDSCCommentValue(ioBuf,kPS_dscCreateDate) ) return ;\n\t\t}\n\t\telse if (!(kPS_Title & dscFlags) &&\n\t\t\t CheckFileSpace ( fileRef, &ioBuf, kPSContainsTitleString.length() )&&\n\t\t\tCheckBytes ( ioBuf.ptr, Uns8Ptr(kPSContainsTitleString.c_str()), kPSContainsTitleString.length() ))\n\t\t{\n\t\t\t\t\t\t\n\t\t\tioBuf.ptr+=kPSContainsTitleString.length();\n\t\t\tif ( ! ExtractDSCCommentValue(ioBuf,kPS_dscTitle) ) return ;\n\t\t}\n\t\telse if( CheckFileSpace ( fileRef, &ioBuf, kPSContainsXMPString.length() )&&\n\t\t\t (  CheckBytes ( ioBuf.ptr, Uns8Ptr(kPSContainsXMPString.c_str()), kPSContainsXMPString.length()    ) )) {\n\n\t\t\t\n\t\t\tXMP_Int64 containsXMPStartpos=ioBuf.filePos+ioBuf.ptr-ioBuf.data;\n\t\t\tioBuf.ptr += kPSContainsXMPString.length();\n\t\t\tExtractContainsXMPHint(ioBuf,containsXMPStartpos);\n\n\t\t}\t// Found \"%ADO_ContainsXMP:\".\n\t\tif ( ! PostScript_Support::SkipUntilNewline(fileRef,ioBuf) ) return ;\n\n\t}\t// Outer marker loop.\n",
    "code_after_change": "void PostScript_MetaHandler::ParsePSFile()\n{\n\tbool     found = false;\n\tIOBuffer ioBuf;\n\n\tXMP_IO* fileRef = this->parent->ioRef;\n\n\tXMP_AbortProc abortProc  = this->parent->abortProc;\n\tvoid *        abortArg   = this->parent->abortArg;\n\tconst bool    checkAbort = (abortProc != 0);\n\n\tif ( ! PostScript_Support::IsValidPSFile(fileRef,this->fileformat) ) return ; \n\n\tfileRef->Rewind();\n\tif ( ! CheckFileSpace ( fileRef, &ioBuf, 4 ) ) return ;\n\tXMP_Uns32 fileheader = GetUns32BE ( ioBuf.ptr );\n\n\tif ( fileheader == 0xC5D0D3C6 ) \n\t{\n\n\t\tif ( ! CheckFileSpace ( fileRef, &ioBuf, 30 ) ) return ;\n\n\t\tXMP_Uns32 psOffset = GetUns32LE ( ioBuf.ptr+4 );\t// PostScript offset.\n\t\tXMP_Uns32 psLength = GetUns32LE ( ioBuf.ptr+8 );\t// PostScript length.\n\n\t\tsetTokenInfo(kPS_EndPostScript,psOffset+psLength,0);\n\t\tMoveToOffset ( fileRef, psOffset, &ioBuf );\n\n\t}\n\n\twhile ( true ) \n\t{\n\t\tif ( checkAbort && abortProc(abortArg) ) {\n\t\t\tXMP_Throw ( \"PostScript_MetaHandler::FindPostScriptHint - User abort\", kXMPErr_UserAbort );\n\t\t}\n\n\t\tif ( ! CheckFileSpace ( fileRef, &ioBuf, kPSContainsForString.length() ) ) return ;\n\n\t\tif ( (CheckFileSpace ( fileRef, &ioBuf, kPSEndCommentString.length() )&& \n\t\t\t\tCheckBytes ( ioBuf.ptr, Uns8Ptr(kPSEndCommentString.c_str()), kPSEndCommentString.length() )\n\t\t\t\t)|| *ioBuf.ptr!='%' || !(*(ioBuf.ptr+1)>32 && *(ioBuf.ptr+1)<=126 )) // implicit endcomment check\n\t\t{\n\t\t\tif (CheckBytes ( ioBuf.ptr, Uns8Ptr(kPSEndCommentString.c_str()), kPSEndCommentString.length() ))\n\t\t\t{\n\t\t\t\tsetTokenInfo(kPS_EndComments,ioBuf.filePos+ioBuf.ptr-ioBuf.data,kPSEndCommentString.length());\n\t\t\t\tioBuf.ptr+=kPSEndCommentString.length();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsetTokenInfo(kPS_EndComments,ioBuf.filePos+ioBuf.ptr-ioBuf.data,0);\n\t\t\t}\n\t\t\twhile(true)\n\t\t\t{\n\t\t\t\tif ( ! CheckFileSpace ( fileRef, &ioBuf, 1 ) ) return ;\n\t\t\t\tif (! IsWhitespace (*ioBuf.ptr)) break;\n\t\t\t\t++ioBuf.ptr;\n\t\t\t} \n\t\t\twhile(true)\n\t\t\t{\n\t\t\t\tif ( ! CheckFileSpace ( fileRef, &ioBuf, 5 ) ) return ;\n\t\t\t\tif (CheckBytes ( ioBuf.ptr, Uns8Ptr(\"/DOCI\"), 5 ) \n\t\t\t\t\t&& CheckFileSpace ( fileRef, &ioBuf, kPSContainsDocInfoString.length() )\n\t\t\t\t\t&&CheckBytes ( ioBuf.ptr, Uns8Ptr(kPSContainsDocInfoString.c_str()), kPSContainsDocInfoString.length() ))\n\t\t\t\t\t\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\tioBuf.ptr+=kPSContainsDocInfoString.length();\n\t\t\t\t\tExtractDocInfoDict(ioBuf);\n\t\t\t\t}// DOCINFO Not found in document\n\t\t\t\telse if(CheckBytes ( ioBuf.ptr, Uns8Ptr(\"%%Beg\"), 5 ))\n\t\t\t\t{//possibly one of %%BeginProlog %%BeginSetup %%BeginBinary %%BeginData \n\t\t\t\t\tXMP_Int64 begStartpos=ioBuf.filePos+ioBuf.ptr-ioBuf.data;\n\t\t\t\t\tioBuf.ptr+=5;\n\t\t\t\t\tif (!CheckFileSpace ( fileRef, &ioBuf, 6 )) return;\n\t\t\t\t\tif(CheckBytes ( ioBuf.ptr, Uns8Ptr(\"inProl\"), 6 ))\n\t\t\t\t\t{//%%BeginProlog\n\t\t\t\t\t\tioBuf.ptr+=6;\n\t\t\t\t\t\tif (!CheckFileSpace ( fileRef, &ioBuf, 2 ))return;\n\t\t\t\t\t\tif(CheckBytes ( ioBuf.ptr, Uns8Ptr(\"og\"), 2 ))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tioBuf.ptr+=2;\n\t\t\t\t\t\t\tsetTokenInfo(kPS_BeginProlog,begStartpos,13);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (CheckBytes ( ioBuf.ptr, Uns8Ptr(\"inSetu\"), 6 ))\n\t\t\t\t\t{//%%BeginSetup \n\t\t\t\t\t\tioBuf.ptr+=6;\n\t\t\t\t\t\tif (!CheckFileSpace ( fileRef, &ioBuf, 1 ))return;\n\t\t\t\t\t\tif(CheckBytes ( ioBuf.ptr, Uns8Ptr(\"p\"), 1 ))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tioBuf.ptr+=1;\n\t\t\t\t\t\t\tsetTokenInfo(kPS_BeginSetup,begStartpos,12);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (CheckBytes ( ioBuf.ptr, Uns8Ptr(\"inBina\"), 6 ))\n\t\t\t\t\t{//%%BeginBinary\n\t\t\t\t\t\tioBuf.ptr+=6;\n\t\t\t\t\t\tif (!CheckFileSpace ( fileRef, &ioBuf, 3 ))return;\n\t\t\t\t\t\tif(CheckBytes ( ioBuf.ptr, Uns8Ptr(\"ry\"), 3 ))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tioBuf.ptr+=3;\n\t\t\t\t\t\t\twhile(true)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (!CheckFileSpace ( fileRef, &ioBuf, 12 ))return;\n\t\t\t\t\t\t\t\tif (CheckBytes ( ioBuf.ptr, Uns8Ptr(\"%%EndBinary\"), 11 ))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tioBuf.ptr+=11;\n\t\t\t\t\t\t\t\t\tif (IsWhitespace(*ioBuf.ptr))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tioBuf.ptr++;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t++ioBuf.ptr;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (CheckBytes ( ioBuf.ptr, Uns8Ptr(\"inData\"), 6 ))\n\t\t\t\t\t{//%%BeginData\n\t\t\t\t\t\tioBuf.ptr+=6;\n\t\t\t\t\t\tif (!CheckFileSpace ( fileRef, &ioBuf, 1 ))return;\n\t\t\t\t\t\tif(CheckBytes ( ioBuf.ptr, Uns8Ptr(\":\"), 1 ))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\twhile(true)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (!CheckFileSpace ( fileRef, &ioBuf, 10 ))return;\n\t\t\t\t\t\t\t\tif (CheckBytes ( ioBuf.ptr, Uns8Ptr(\"%%EndData\"), 9 ))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tioBuf.ptr+=9;\n\t\t\t\t\t\t\t\t\tif (IsWhitespace(*ioBuf.ptr))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tioBuf.ptr++;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t++ioBuf.ptr;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (CheckBytes ( ioBuf.ptr, Uns8Ptr(\"inDocu\"), 6 ))\n\t\t\t\t\t{// %%BeginDocument\n\t\t\t\t\t\tioBuf.ptr+=6;\n\t\t\t\t\t\tif (!CheckFileSpace ( fileRef, &ioBuf, 5 ))return;\n\t\t\t\t\t\tif(CheckBytes ( ioBuf.ptr, Uns8Ptr(\"ment:\"), 5 ))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tioBuf.ptr+=5;\n\t\t\t\t\t\t\twhile(true)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (!CheckFileSpace ( fileRef, &ioBuf, 14 ))return;\n\t\t\t\t\t\t\t\tif (CheckBytes ( ioBuf.ptr, Uns8Ptr(\"%%EndDocument\"), 13 ))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tioBuf.ptr+=13;\n\t\t\t\t\t\t\t\t\tif (IsWhitespace(*ioBuf.ptr))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tioBuf.ptr++;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t++ioBuf.ptr;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (CheckBytes ( ioBuf.ptr, Uns8Ptr(\"inPage\"), 6 ))\n\t\t\t\t\t{// %%BeginPageSetup\n\t\t\t\t\t\tioBuf.ptr+=6;\n\t\t\t\t\t\tif (!CheckFileSpace ( fileRef, &ioBuf, 5 ))return;\n\t\t\t\t\t\tif(CheckBytes ( ioBuf.ptr, Uns8Ptr(\"Setup\"), 5 ))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tioBuf.ptr+=5;\n\t\t\t\t\t\t\tsetTokenInfo(kPS_BeginPageSetup,begStartpos,16);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(CheckBytes ( ioBuf.ptr, Uns8Ptr(\"%%End\"), 5 ))\n\t\t\t\t{//possibly %%EndProlog %%EndSetup %%EndPageSetup %%EndPageComments\n\t\t\t\t\tXMP_Int64 begStartpos=ioBuf.filePos+ioBuf.ptr-ioBuf.data;\n\t\t\t\t\tioBuf.ptr+=5;\n\t\t\t\t\tif ( ! CheckFileSpace ( fileRef, &ioBuf, 5 ) ) return ;\n\t\t\t\t\tif (CheckBytes ( ioBuf.ptr, Uns8Ptr(\"Prolo\"), 5 ))\n\t\t\t\t\t{// %%EndProlog\n\t\t\t\t\t\tioBuf.ptr+=5;\n\t\t\t\t\t\tif ( ! CheckFileSpace ( fileRef, &ioBuf, 1 ) ) return ;\n\t\t\t\t\t\tif (CheckBytes ( ioBuf.ptr, Uns8Ptr(\"g\"), 1 ))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tioBuf.ptr+=1;\n\t\t\t\t\t\t\tsetTokenInfo(kPS_EndProlog,begStartpos,11);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (CheckBytes ( ioBuf.ptr, Uns8Ptr(\"Setup\"), 5 ))\n\t\t\t\t\t{//%%EndSetup\n\t\t\t\t\t\tioBuf.ptr+=5;\n\t\t\t\t\t\tsetTokenInfo(kPS_EndSetup,begStartpos,10);\n\t\t\t\t\t}\n\t\t\t\t\telse if (CheckBytes ( ioBuf.ptr, Uns8Ptr(\"PageS\"), 5 ))\n\t\t\t\t\t{//%%EndPageSetup\n\t\t\t\t\t\tioBuf.ptr+=5;\n\t\t\t\t\t\tif ( ! CheckFileSpace ( fileRef, &ioBuf, 4 ) ) return ;\n\t\t\t\t\t\tif (CheckBytes ( ioBuf.ptr, Uns8Ptr(\"etup\"), 4 ))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tioBuf.ptr+=4;\n\t\t\t\t\t\t\tsetTokenInfo(kPS_EndPageSetup,begStartpos,14);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (CheckBytes ( ioBuf.ptr, Uns8Ptr(\"PageC\"), 5 ))\n\t\t\t\t\t{//%%EndPageComments\n\t\t\t\t\t\tioBuf.ptr+=5;\n\t\t\t\t\t\tif ( ! CheckFileSpace ( fileRef, &ioBuf, 7 ) ) return ;\n\t\t\t\t\t\tif (CheckBytes ( ioBuf.ptr, Uns8Ptr(\"omments\"), 7 ))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tioBuf.ptr+=7;\n\t\t\t\t\t\t\tsetTokenInfo(kPS_EndPageComments,begStartpos,17);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(CheckBytes ( ioBuf.ptr, Uns8Ptr(\"%%Pag\"), 5 ))\n\t\t\t\t{\n\t\t\t\t\tXMP_Int64 begStartpos=ioBuf.filePos+ioBuf.ptr-ioBuf.data;\n\t\t\t\t\tioBuf.ptr+=5;\n\t\t\t\t\tif ( ! CheckFileSpace ( fileRef, &ioBuf, 2 ) ) return ;\n\t\t\t\t\tif (CheckBytes ( ioBuf.ptr, Uns8Ptr(\":\"), 2 ))\n\t\t\t\t\t{\n\t\t\t\t\t\tioBuf.ptr+=2;\n\t\t\t\t\t\twhile(!IsNewline(*ioBuf.ptr))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif ( ! CheckFileSpace ( fileRef, &ioBuf, 1 ) ) return ;\n\t\t\t\t\t\t\t++ioBuf.ptr;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsetTokenInfo(kPS_Page,begStartpos,ioBuf.filePos+ioBuf.ptr-ioBuf.data-begStartpos);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\telse if(CheckBytes ( ioBuf.ptr, Uns8Ptr(\"%%Tra\"), 5 ))\n\t\t\t\t{\n\t\t\t\t\tXMP_Int64 begStartpos=ioBuf.filePos+ioBuf.ptr-ioBuf.data;\n\t\t\t\t\tioBuf.ptr+=5;\n\t\t\t\t\tif ( ! CheckFileSpace ( fileRef, &ioBuf, 4 ) ) return ;\n \t\t\t\t\tif (CheckBytes ( ioBuf.ptr, Uns8Ptr(\"iler\"), 4 ))\n \t\t\t\t\t{\n \t\t\t\t\t\tioBuf.ptr+=4;\n\t\t\t\t\t\twhile(ioBuf.ptr < ioBuf.limit &&\n                                                      !IsNewline(*ioBuf.ptr))\n                                                    ++ioBuf.ptr;\n \t\t\t\t\t\tsetTokenInfo(kPS_Trailer,begStartpos,ioBuf.filePos+ioBuf.ptr-ioBuf.data-begStartpos);\n \t\t\t\t\t}\n \t\t\t\t}\n\t\t\t\t\tioBuf.ptr+=5;\n\t\t\t\t\tsetTokenInfo(kPS_EOF,ioBuf.filePos+ioBuf.ptr-ioBuf.data,5);\n\t\t\t\t}\n\t\t\t\tif ( ! CheckFileSpace ( fileRef, &ioBuf, 1 ) ) return ;\n\t\t\t\t++ioBuf.ptr;\n\t\t\t}\n\t\t\treturn;\n\n\t\t}else if (!(kPS_Creator & dscFlags) && \n\t\t\t CheckFileSpace ( fileRef, &ioBuf, kPSContainsForString.length() )&&\n\t\t\tCheckBytes ( ioBuf.ptr, Uns8Ptr(kPSContainsForString.c_str()), kPSContainsForString.length() ))\n\t\t{\n\t\t\tioBuf.ptr+=kPSContainsForString.length();\n\t\t\tif ( ! ExtractDSCCommentValue(ioBuf,kPS_dscFor) ) return ;\n\t\t}\n\t\telse if (!(kPS_CreatorTool & dscFlags) &&\n\t\t\t CheckFileSpace ( fileRef, &ioBuf, kPSContainsCreatorString.length() )&&\n\t\t\t CheckBytes ( ioBuf.ptr, Uns8Ptr(kPSContainsCreatorString.c_str()), kPSContainsCreatorString.length() ))\n\t\t{\n\t\t\tioBuf.ptr+=kPSContainsCreatorString.length();\n\t\t\tif ( ! ExtractDSCCommentValue(ioBuf,kPS_dscCreator) ) return ;\n\t\t}\n\t\telse if (!(kPS_CreateDate & dscFlags) &&\n\t\t\t CheckFileSpace ( fileRef, &ioBuf, kPSContainsCreateDateString.length() )&&\n\t\t\tCheckBytes ( ioBuf.ptr, Uns8Ptr(kPSContainsCreateDateString.c_str()), kPSContainsCreateDateString.length() ))\n\t\t{\n\t\t\t\n\t\t\tioBuf.ptr+=kPSContainsCreateDateString.length();\n\t\t\tif ( ! ExtractDSCCommentValue(ioBuf,kPS_dscCreateDate) ) return ;\n\t\t}\n\t\telse if (!(kPS_Title & dscFlags) &&\n\t\t\t CheckFileSpace ( fileRef, &ioBuf, kPSContainsTitleString.length() )&&\n\t\t\tCheckBytes ( ioBuf.ptr, Uns8Ptr(kPSContainsTitleString.c_str()), kPSContainsTitleString.length() ))\n\t\t{\n\t\t\t\t\t\t\n\t\t\tioBuf.ptr+=kPSContainsTitleString.length();\n\t\t\tif ( ! ExtractDSCCommentValue(ioBuf,kPS_dscTitle) ) return ;\n\t\t}\n\t\telse if( CheckFileSpace ( fileRef, &ioBuf, kPSContainsXMPString.length() )&&\n\t\t\t (  CheckBytes ( ioBuf.ptr, Uns8Ptr(kPSContainsXMPString.c_str()), kPSContainsXMPString.length()    ) )) {\n\n\t\t\t\n\t\t\tXMP_Int64 containsXMPStartpos=ioBuf.filePos+ioBuf.ptr-ioBuf.data;\n\t\t\tioBuf.ptr += kPSContainsXMPString.length();\n\t\t\tExtractContainsXMPHint(ioBuf,containsXMPStartpos);\n\n\t\t}\t// Found \"%ADO_ContainsXMP:\".\n\t\tif ( ! PostScript_Support::SkipUntilNewline(fileRef,ioBuf) ) return ;\n\n\t}\t// Outer marker loop.\n",
    "cwe": [
      "CWE-125"
    ],
    "id": 213,
    "_valid_cwes": [
      "CWE-125"
    ]
  },
  {
    "cve_id": "CVE-2017-13690",
    "code_before_change": "ikev2_gen_print(netdissect_options *ndo, u_char tpay,\n\t\tconst struct isakmp_gen *ext)\n{\n\tstruct isakmp_gen e;\n\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\tikev2_pay_print(ndo, NPSTR(tpay), e.critical);\n \n \tND_PRINT((ndo,\" len=%d\", ntohs(e.len) - 4));\n \tif (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n \t\tND_PRINT((ndo,\" \"));\n \t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n \t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(e.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(tpay)));\n\treturn NULL;\n}\n",
    "code_after_change": "ikev2_gen_print(netdissect_options *ndo, u_char tpay,\n\t\tconst struct isakmp_gen *ext)\n{\n\tstruct isakmp_gen e;\n\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\tikev2_pay_print(ndo, NPSTR(tpay), e.critical);\n \n \tND_PRINT((ndo,\" len=%d\", ntohs(e.len) - 4));\n \tif (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n\t\t/* Print the entire payload in hex */\n \t\tND_PRINT((ndo,\" \"));\n \t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n \t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(e.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(tpay)));\n\treturn NULL;\n}\n",
    "cwe": [
      "CWE-125"
    ],
    "id": 216,
    "_valid_cwes": [
      "CWE-125"
    ]
  },
  {
    "cve_id": "CVE-2016-7532",
    "code_before_change": "static MagickBooleanType WritePSDImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n {\n   const char\n     *property;\n\n  const StringInfo\n    *icc_profile;\n\n  Image\n    *base_image,\n    *next_image;\n\n  MagickBooleanType\n    status;\n\n  PSDInfo\n    psd_info;\n\n  register ssize_t\n    i;\n\n  size_t\n    channel_size,\n    channelLength,\n    layer_count,\n    layer_info_size,\n    length,\n    num_channels,\n    packet_size,\n    rounded_layer_info_size;\n\n  StringInfo\n    *bim_profile;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  packet_size=(size_t) (image->depth > 8 ? 6 : 3);\n  if (image->alpha_trait != UndefinedPixelTrait)\n    packet_size+=image->depth > 8 ? 2 : 1;\n  psd_info.version=1;\n  if ((LocaleCompare(image_info->magick,\"PSB\") == 0) ||\n      (image->columns > 30000) || (image->rows > 30000))\n    psd_info.version=2;\n  (void) WriteBlob(image,4,(const unsigned char *) \"8BPS\");\n  (void) WriteBlobMSBShort(image,psd_info.version);  /* version */\n  for (i=1; i <= 6; i++)\n    (void) WriteBlobByte(image, 0);  /* 6 bytes of reserved */\n  if (SetImageGray(image,exception) != MagickFalse)\n    num_channels=(image->alpha_trait != UndefinedPixelTrait ? 2UL : 1UL);\n  else\n    if ((image_info->type != TrueColorType) && (image_info->type !=\n         TrueColorAlphaType) && (image->storage_class == PseudoClass))\n      num_channels=(image->alpha_trait != UndefinedPixelTrait ? 2UL : 1UL);\n    else\n      {\n        if (image->storage_class == PseudoClass)\n          (void) SetImageStorageClass(image,DirectClass,exception);\n        if (image->colorspace != CMYKColorspace)\n          num_channels=(image->alpha_trait != UndefinedPixelTrait ? 4UL : 3UL);\n        else\n          num_channels=(image->alpha_trait != UndefinedPixelTrait ? 5UL : 4UL);\n      }\n  (void) WriteBlobMSBShort(image,(unsigned short) num_channels);\n  (void) WriteBlobMSBLong(image,(unsigned int) image->rows);\n  (void) WriteBlobMSBLong(image,(unsigned int) image->columns);\n  if (IsImageGray(image) != MagickFalse)\n    {\n      MagickBooleanType\n        monochrome;\n\n      /*\n        Write depth & mode.\n      */\n      monochrome=IsImageMonochrome(image) && (image->depth == 1) ?\n        MagickTrue : MagickFalse;\n      (void) WriteBlobMSBShort(image,(unsigned short)\n        (monochrome != MagickFalse ? 1 : image->depth > 8 ? 16 : 8));\n      (void) WriteBlobMSBShort(image,(unsigned short)\n        (monochrome != MagickFalse ? BitmapMode : GrayscaleMode));\n    }\n  else\n    {\n      (void) WriteBlobMSBShort(image,(unsigned short) (image->storage_class ==\n        PseudoClass ? 8 : image->depth > 8 ? 16 : 8));\n\n      if (((image_info->colorspace != UndefinedColorspace) ||\n           (image->colorspace != CMYKColorspace)) &&\n          (image_info->colorspace != CMYKColorspace))\n        {\n          (void) TransformImageColorspace(image,sRGBColorspace,exception);\n          (void) WriteBlobMSBShort(image,(unsigned short)\n            (image->storage_class == PseudoClass ? IndexedMode : RGBMode));\n        }\n      else\n        {\n          if (image->colorspace != CMYKColorspace)\n            (void) TransformImageColorspace(image,CMYKColorspace,exception);\n          (void) WriteBlobMSBShort(image,CMYKMode);\n        }\n    }\n  if ((IsImageGray(image) != MagickFalse) ||\n      (image->storage_class == DirectClass) || (image->colors > 256))\n    (void) WriteBlobMSBLong(image,0);\n  else\n    {\n      /*\n        Write PSD raster colormap.\n      */\n      (void) WriteBlobMSBLong(image,768);\n      for (i=0; i < (ssize_t) image->colors; i++)\n        (void) WriteBlobByte(image,ScaleQuantumToChar(image->colormap[i].red));\n      for ( ; i < 256; i++)\n        (void) WriteBlobByte(image,0);\n      for (i=0; i < (ssize_t) image->colors; i++)\n        (void) WriteBlobByte(image,ScaleQuantumToChar(\n          image->colormap[i].green));\n      for ( ; i < 256; i++)\n        (void) WriteBlobByte(image,0);\n      for (i=0; i < (ssize_t) image->colors; i++)\n        (void) WriteBlobByte(image,ScaleQuantumToChar(image->colormap[i].blue));\n      for ( ; i < 256; i++)\n        (void) WriteBlobByte(image,0);\n    }\n  /*\n    Image resource block.\n  */\n  length=28; /* 0x03EB */\n  bim_profile=(StringInfo *) GetImageProfile(image,\"8bim\");\n  icc_profile=GetImageProfile(image,\"icc\");\n  if (bim_profile != (StringInfo *) NULL)\n    {\n      bim_profile=CloneStringInfo(bim_profile);\n      if (icc_profile != (StringInfo *) NULL)\n        RemoveICCProfileFromResourceBlock(bim_profile);\n      RemoveResolutionFromResourceBlock(bim_profile);\n      length+=PSDQuantum(GetStringInfoLength(bim_profile));\n    }\n  if (icc_profile != (const StringInfo *) NULL)\n    length+=PSDQuantum(GetStringInfoLength(icc_profile))+12;\n  (void) WriteBlobMSBLong(image,(unsigned int) length);\n  WriteResolutionResourceBlock(image);\n  if (bim_profile != (StringInfo *) NULL)\n    {\n      (void) WriteBlob(image,GetStringInfoLength(bim_profile),\n        GetStringInfoDatum(bim_profile));\n      bim_profile=DestroyStringInfo(bim_profile);\n    }\n  if (icc_profile != (StringInfo *) NULL)\n    {\n      (void) WriteBlob(image,4,(const unsigned char *) \"8BIM\");\n      (void) WriteBlobMSBShort(image,0x0000040F);\n      (void) WriteBlobMSBShort(image,0);\n      (void) WriteBlobMSBLong(image,(unsigned int) GetStringInfoLength(\n        icc_profile));\n      (void) WriteBlob(image,GetStringInfoLength(icc_profile),\n        GetStringInfoDatum(icc_profile));\n      if ((MagickOffsetType) GetStringInfoLength(icc_profile) !=\n          PSDQuantum(GetStringInfoLength(icc_profile)))\n        (void) WriteBlobByte(image,0);\n    }\n  layer_count=0;\n  layer_info_size=2;\n  base_image=GetNextImageInList(image);\n  if ((image->alpha_trait != UndefinedPixelTrait) && (base_image == (Image *) NULL))\n    base_image=image;\n  next_image=base_image;\n  while ( next_image != NULL )\n  {\n    packet_size=next_image->depth > 8 ? 2UL : 1UL;\n    if (IsImageGray(next_image) != MagickFalse)\n      num_channels=next_image->alpha_trait != UndefinedPixelTrait ? 2UL : 1UL;\n    else\n      if (next_image->storage_class == PseudoClass)\n        num_channels=next_image->alpha_trait != UndefinedPixelTrait ? 2UL : 1UL;\n      else\n        if (next_image->colorspace != CMYKColorspace)\n          num_channels=next_image->alpha_trait != UndefinedPixelTrait ? 4UL : 3UL;\n        else\n          num_channels=next_image->alpha_trait != UndefinedPixelTrait ? 5UL : 4UL;\n    channelLength=(size_t) (next_image->columns*next_image->rows*packet_size+2);\n    layer_info_size+=(size_t) (4*4+2+num_channels*6+(psd_info.version == 1 ? 8 :\n      16)+4*1+4+num_channels*channelLength);\n    property=(const char *) GetImageProperty(next_image,\"label\",exception);\n    if (property == (const char *) NULL)\n      layer_info_size+=16;\n    else\n      {\n        size_t\n          layer_length;\n\n        layer_length=strlen(property);\n        layer_info_size+=8+layer_length+(4-(layer_length % 4));\n      }\n    layer_count++;\n    next_image=GetNextImageInList(next_image);\n  }\n  if (layer_count == 0)\n    (void) SetPSDSize(&psd_info,image,0);\n  else\n    {\n      CompressionType\n        compression;\n\n      (void) SetPSDSize(&psd_info,image,layer_info_size+\n        (psd_info.version == 1 ? 8 : 16));\n      if ((layer_info_size/2) != ((layer_info_size+1)/2))\n        rounded_layer_info_size=layer_info_size+1;\n      else\n        rounded_layer_info_size=layer_info_size;\n      (void) SetPSDSize(&psd_info,image,rounded_layer_info_size);\n      if (image->alpha_trait != UndefinedPixelTrait)\n        (void) WriteBlobMSBShort(image,-(unsigned short) layer_count);\n      else\n        (void) WriteBlobMSBShort(image,(unsigned short) layer_count);\n      layer_count=1;\n      compression=base_image->compression;\n      for (next_image=base_image; next_image != NULL; )\n      {\n        next_image->compression=NoCompression;\n        (void) WriteBlobMSBLong(image,(unsigned int) next_image->page.y);\n        (void) WriteBlobMSBLong(image,(unsigned int) next_image->page.x);\n        (void) WriteBlobMSBLong(image,(unsigned int) (next_image->page.y+\n          next_image->rows));\n        (void) WriteBlobMSBLong(image,(unsigned int) (next_image->page.x+\n          next_image->columns));\n        packet_size=next_image->depth > 8 ? 2UL : 1UL;\n        channel_size=(unsigned int) ((packet_size*next_image->rows*\n          next_image->columns)+2);\n        if ((IsImageGray(next_image) != MagickFalse) ||\n            (next_image->storage_class == PseudoClass))\n          {\n             (void) WriteBlobMSBShort(image,(unsigned short)\n               (next_image->alpha_trait != UndefinedPixelTrait ? 2 : 1));\n             (void) WriteBlobMSBShort(image,0);\n             (void) SetPSDSize(&psd_info,image,channel_size);\n             if (next_image->alpha_trait != UndefinedPixelTrait)\n               {\n                 (void) WriteBlobMSBShort(image,(unsigned short) -1);\n                 (void) SetPSDSize(&psd_info,image,channel_size);\n               }\n           }\n          else\n            if (next_image->colorspace != CMYKColorspace)\n              {\n                (void) WriteBlobMSBShort(image,(unsigned short)\n                  (next_image->alpha_trait != UndefinedPixelTrait ? 4 : 3));\n               (void) WriteBlobMSBShort(image,0);\n               (void) SetPSDSize(&psd_info,image,channel_size);\n               (void) WriteBlobMSBShort(image,1);\n               (void) SetPSDSize(&psd_info,image,channel_size);\n               (void) WriteBlobMSBShort(image,2);\n               (void) SetPSDSize(&psd_info,image,channel_size);\n               if (next_image->alpha_trait != UndefinedPixelTrait)\n                 {\n                   (void) WriteBlobMSBShort(image,(unsigned short) -1);\n                   (void) SetPSDSize(&psd_info,image,channel_size);\n                 }\n             }\n           else\n             {\n               (void) WriteBlobMSBShort(image,(unsigned short)\n                 (next_image->alpha_trait ? 5 : 4));\n               (void) WriteBlobMSBShort(image,0);\n               (void) SetPSDSize(&psd_info,image,channel_size);\n               (void) WriteBlobMSBShort(image,1);\n               (void) SetPSDSize(&psd_info,image,channel_size);\n               (void) WriteBlobMSBShort(image,2);\n               (void) SetPSDSize(&psd_info,image,channel_size);\n               (void) WriteBlobMSBShort(image,3);\n               (void) SetPSDSize(&psd_info,image,channel_size);\n               if (next_image->alpha_trait)\n                 {\n                   (void) WriteBlobMSBShort(image,(unsigned short) -1);\n                   (void) SetPSDSize(&psd_info,image,channel_size);\n                 }\n             }\n        (void) WriteBlob(image,4,(const unsigned char *) \"8BIM\");\n        (void) WriteBlob(image,4,(const unsigned char *)\n          CompositeOperatorToPSDBlendMode(next_image->compose));\n        (void) WriteBlobByte(image,255); /* layer opacity */\n        (void) WriteBlobByte(image,0);\n        (void) WriteBlobByte(image,next_image->compose==NoCompositeOp ?\n          1 << 0x02 : 1); /* layer properties - visible, etc. */\n        (void) WriteBlobByte(image,0);\n        property=(const char *) GetImageProperty(next_image,\"label\",exception);\n        if (property == (const char *) NULL)\n          {\n            char\n              layer_name[MagickPathExtent];\n\n            (void) WriteBlobMSBLong(image,16);\n            (void) WriteBlobMSBLong(image,0);\n            (void) WriteBlobMSBLong(image,0);\n            (void) FormatLocaleString(layer_name,MagickPathExtent,\"L%04ld\",(long)\n              layer_count++);\n            WritePascalString(image,layer_name,4);\n          }\n        else\n          {\n            size_t\n              label_length;\n\n            label_length=strlen(property);\n            (void) WriteBlobMSBLong(image,(unsigned int) (label_length+(4-\n              (label_length % 4))+8));\n            (void) WriteBlobMSBLong(image,0);\n            (void) WriteBlobMSBLong(image,0);\n            WritePascalString(image,property,4);\n          }\n        next_image=GetNextImageInList(next_image);\n      }\n      /*\n        Now the image data!\n      */\n      next_image=base_image;\n      while (next_image != NULL)\n      {\n        status=WriteImageChannels(&psd_info,image_info,image,next_image,\n          MagickTrue,exception);\n        next_image=GetNextImageInList(next_image);\n      }\n      (void) WriteBlobMSBLong(image,0);  /* user mask data */\n      base_image->compression=compression;\n    }\n  /*\n    Write composite image.\n  */\n  if (status != MagickFalse)\n    status=WriteImageChannels(&psd_info,image_info,image,image,MagickFalse,\n      exception);\n  (void) CloseBlob(image);\n  return(status);\n}\n",
    "code_after_change": "static MagickBooleanType WritePSDImage(const ImageInfo *image_info,Image *image,\nstatic MagickBooleanType WritePSDImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n {\n   const char\n     *property;\n\n  const StringInfo\n    *icc_profile;\n\n  Image\n    *base_image,\n    *next_image;\n\n  MagickBooleanType\n    status;\n\n  PSDInfo\n    psd_info;\n\n  register ssize_t\n    i;\n\n  size_t\n    channel_size,\n    channelLength,\n    layer_count,\n    layer_info_size,\n    length,\n    num_channels,\n    packet_size,\n    rounded_layer_info_size;\n\n  StringInfo\n    *bim_profile;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  packet_size=(size_t) (image->depth > 8 ? 6 : 3);\n  if (image->alpha_trait != UndefinedPixelTrait)\n    packet_size+=image->depth > 8 ? 2 : 1;\n  psd_info.version=1;\n  if ((LocaleCompare(image_info->magick,\"PSB\") == 0) ||\n      (image->columns > 30000) || (image->rows > 30000))\n    psd_info.version=2;\n  (void) WriteBlob(image,4,(const unsigned char *) \"8BPS\");\n  (void) WriteBlobMSBShort(image,psd_info.version);  /* version */\n  for (i=1; i <= 6; i++)\n    (void) WriteBlobByte(image, 0);  /* 6 bytes of reserved */\n  if (SetImageGray(image,exception) != MagickFalse)\n    num_channels=(image->alpha_trait != UndefinedPixelTrait ? 2UL : 1UL);\n  else\n    if ((image_info->type != TrueColorType) && (image_info->type !=\n         TrueColorAlphaType) && (image->storage_class == PseudoClass))\n      num_channels=(image->alpha_trait != UndefinedPixelTrait ? 2UL : 1UL);\n    else\n      {\n        if (image->storage_class == PseudoClass)\n          (void) SetImageStorageClass(image,DirectClass,exception);\n        if (image->colorspace != CMYKColorspace)\n          num_channels=(image->alpha_trait != UndefinedPixelTrait ? 4UL : 3UL);\n        else\n          num_channels=(image->alpha_trait != UndefinedPixelTrait ? 5UL : 4UL);\n      }\n  (void) WriteBlobMSBShort(image,(unsigned short) num_channels);\n  (void) WriteBlobMSBLong(image,(unsigned int) image->rows);\n  (void) WriteBlobMSBLong(image,(unsigned int) image->columns);\n  if (IsImageGray(image) != MagickFalse)\n    {\n      MagickBooleanType\n        monochrome;\n\n      /*\n        Write depth & mode.\n      */\n      monochrome=IsImageMonochrome(image) && (image->depth == 1) ?\n        MagickTrue : MagickFalse;\n      (void) WriteBlobMSBShort(image,(unsigned short)\n        (monochrome != MagickFalse ? 1 : image->depth > 8 ? 16 : 8));\n      (void) WriteBlobMSBShort(image,(unsigned short)\n        (monochrome != MagickFalse ? BitmapMode : GrayscaleMode));\n    }\n  else\n    {\n      (void) WriteBlobMSBShort(image,(unsigned short) (image->storage_class ==\n        PseudoClass ? 8 : image->depth > 8 ? 16 : 8));\n\n      if (((image_info->colorspace != UndefinedColorspace) ||\n           (image->colorspace != CMYKColorspace)) &&\n          (image_info->colorspace != CMYKColorspace))\n        {\n          (void) TransformImageColorspace(image,sRGBColorspace,exception);\n          (void) WriteBlobMSBShort(image,(unsigned short)\n            (image->storage_class == PseudoClass ? IndexedMode : RGBMode));\n        }\n      else\n        {\n          if (image->colorspace != CMYKColorspace)\n            (void) TransformImageColorspace(image,CMYKColorspace,exception);\n          (void) WriteBlobMSBShort(image,CMYKMode);\n        }\n    }\n  if ((IsImageGray(image) != MagickFalse) ||\n      (image->storage_class == DirectClass) || (image->colors > 256))\n    (void) WriteBlobMSBLong(image,0);\n  else\n    {\n      /*\n        Write PSD raster colormap.\n      */\n      (void) WriteBlobMSBLong(image,768);\n      for (i=0; i < (ssize_t) image->colors; i++)\n        (void) WriteBlobByte(image,ScaleQuantumToChar(image->colormap[i].red));\n      for ( ; i < 256; i++)\n        (void) WriteBlobByte(image,0);\n      for (i=0; i < (ssize_t) image->colors; i++)\n        (void) WriteBlobByte(image,ScaleQuantumToChar(\n          image->colormap[i].green));\n      for ( ; i < 256; i++)\n        (void) WriteBlobByte(image,0);\n      for (i=0; i < (ssize_t) image->colors; i++)\n        (void) WriteBlobByte(image,ScaleQuantumToChar(image->colormap[i].blue));\n      for ( ; i < 256; i++)\n        (void) WriteBlobByte(image,0);\n    }\n  /*\n    Image resource block.\n  */\n  length=28; /* 0x03EB */\n  bim_profile=(StringInfo *) GetImageProfile(image,\"8bim\");\n  icc_profile=GetImageProfile(image,\"icc\");\n  if (bim_profile != (StringInfo *) NULL)\n    {\n      bim_profile=CloneStringInfo(bim_profile);\n      if (icc_profile != (StringInfo *) NULL)\n        RemoveICCProfileFromResourceBlock(bim_profile);\n      RemoveResolutionFromResourceBlock(bim_profile);\n      length+=PSDQuantum(GetStringInfoLength(bim_profile));\n    }\n  if (icc_profile != (const StringInfo *) NULL)\n    length+=PSDQuantum(GetStringInfoLength(icc_profile))+12;\n  (void) WriteBlobMSBLong(image,(unsigned int) length);\n  WriteResolutionResourceBlock(image);\n  if (bim_profile != (StringInfo *) NULL)\n    {\n      (void) WriteBlob(image,GetStringInfoLength(bim_profile),\n        GetStringInfoDatum(bim_profile));\n      bim_profile=DestroyStringInfo(bim_profile);\n    }\n  if (icc_profile != (StringInfo *) NULL)\n    {\n      (void) WriteBlob(image,4,(const unsigned char *) \"8BIM\");\n      (void) WriteBlobMSBShort(image,0x0000040F);\n      (void) WriteBlobMSBShort(image,0);\n      (void) WriteBlobMSBLong(image,(unsigned int) GetStringInfoLength(\n        icc_profile));\n      (void) WriteBlob(image,GetStringInfoLength(icc_profile),\n        GetStringInfoDatum(icc_profile));\n      if ((MagickOffsetType) GetStringInfoLength(icc_profile) !=\n          PSDQuantum(GetStringInfoLength(icc_profile)))\n        (void) WriteBlobByte(image,0);\n    }\n  layer_count=0;\n  layer_info_size=2;\n  base_image=GetNextImageInList(image);\n  if ((image->alpha_trait != UndefinedPixelTrait) && (base_image == (Image *) NULL))\n    base_image=image;\n  next_image=base_image;\n  while ( next_image != NULL )\n  {\n    packet_size=next_image->depth > 8 ? 2UL : 1UL;\n    if (IsImageGray(next_image) != MagickFalse)\n      num_channels=next_image->alpha_trait != UndefinedPixelTrait ? 2UL : 1UL;\n    else\n      if (next_image->storage_class == PseudoClass)\n        num_channels=next_image->alpha_trait != UndefinedPixelTrait ? 2UL : 1UL;\n      else\n        if (next_image->colorspace != CMYKColorspace)\n          num_channels=next_image->alpha_trait != UndefinedPixelTrait ? 4UL : 3UL;\n        else\n          num_channels=next_image->alpha_trait != UndefinedPixelTrait ? 5UL : 4UL;\n    channelLength=(size_t) (next_image->columns*next_image->rows*packet_size+2);\n    layer_info_size+=(size_t) (4*4+2+num_channels*6+(psd_info.version == 1 ? 8 :\n      16)+4*1+4+num_channels*channelLength);\n    property=(const char *) GetImageProperty(next_image,\"label\",exception);\n    if (property == (const char *) NULL)\n      layer_info_size+=16;\n    else\n      {\n        size_t\n          layer_length;\n\n        layer_length=strlen(property);\n        layer_info_size+=8+layer_length+(4-(layer_length % 4));\n      }\n    layer_count++;\n    next_image=GetNextImageInList(next_image);\n  }\n  if (layer_count == 0)\n    (void) SetPSDSize(&psd_info,image,0);\n  else\n    {\n      CompressionType\n        compression;\n\n      (void) SetPSDSize(&psd_info,image,layer_info_size+\n        (psd_info.version == 1 ? 8 : 16));\n      if ((layer_info_size/2) != ((layer_info_size+1)/2))\n        rounded_layer_info_size=layer_info_size+1;\n      else\n        rounded_layer_info_size=layer_info_size;\n      (void) SetPSDSize(&psd_info,image,rounded_layer_info_size);\n      if (image->alpha_trait != UndefinedPixelTrait)\n        (void) WriteBlobMSBShort(image,-(unsigned short) layer_count);\n      else\n        (void) WriteBlobMSBShort(image,(unsigned short) layer_count);\n      layer_count=1;\n      compression=base_image->compression;\n      for (next_image=base_image; next_image != NULL; )\n      {\n        next_image->compression=NoCompression;\n        (void) WriteBlobMSBLong(image,(unsigned int) next_image->page.y);\n        (void) WriteBlobMSBLong(image,(unsigned int) next_image->page.x);\n        (void) WriteBlobMSBLong(image,(unsigned int) (next_image->page.y+\n          next_image->rows));\n        (void) WriteBlobMSBLong(image,(unsigned int) (next_image->page.x+\n          next_image->columns));\n        packet_size=next_image->depth > 8 ? 2UL : 1UL;\n        channel_size=(unsigned int) ((packet_size*next_image->rows*\n          next_image->columns)+2);\n        if ((IsImageGray(next_image) != MagickFalse) ||\n            (next_image->storage_class == PseudoClass))\n          {\n             (void) WriteBlobMSBShort(image,(unsigned short)\n               (next_image->alpha_trait != UndefinedPixelTrait ? 2 : 1));\n             (void) WriteBlobMSBShort(image,0);\n             (void) SetPSDSize(&psd_info,image,channel_size);\n             if (next_image->alpha_trait != UndefinedPixelTrait)\n               {\n                 (void) WriteBlobMSBShort(image,(unsigned short) -1);\n                 (void) SetPSDSize(&psd_info,image,channel_size);\n               }\n           }\n          else\n            if (next_image->colorspace != CMYKColorspace)\n              {\n                (void) WriteBlobMSBShort(image,(unsigned short)\n                  (next_image->alpha_trait != UndefinedPixelTrait ? 4 : 3));\n               (void) WriteBlobMSBShort(image,0);\n               (void) SetPSDSize(&psd_info,image,channel_size);\n               (void) WriteBlobMSBShort(image,1);\n               (void) SetPSDSize(&psd_info,image,channel_size);\n               (void) WriteBlobMSBShort(image,2);\n               (void) SetPSDSize(&psd_info,image,channel_size);\n               if (next_image->alpha_trait != UndefinedPixelTrait)\n                 {\n                   (void) WriteBlobMSBShort(image,(unsigned short) -1);\n                   (void) SetPSDSize(&psd_info,image,channel_size);\n                 }\n             }\n           else\n             {\n               (void) WriteBlobMSBShort(image,(unsigned short)\n                 (next_image->alpha_trait ? 5 : 4));\n               (void) WriteBlobMSBShort(image,0);\n               (void) SetPSDSize(&psd_info,image,channel_size);\n               (void) WriteBlobMSBShort(image,1);\n               (void) SetPSDSize(&psd_info,image,channel_size);\n               (void) WriteBlobMSBShort(image,2);\n               (void) SetPSDSize(&psd_info,image,channel_size);\n               (void) WriteBlobMSBShort(image,3);\n               (void) SetPSDSize(&psd_info,image,channel_size);\n               if (next_image->alpha_trait)\n                 {\n                   (void) WriteBlobMSBShort(image,(unsigned short) -1);\n                   (void) SetPSDSize(&psd_info,image,channel_size);\n                 }\n             }\n        (void) WriteBlob(image,4,(const unsigned char *) \"8BIM\");\n        (void) WriteBlob(image,4,(const unsigned char *)\n          CompositeOperatorToPSDBlendMode(next_image->compose));\n        (void) WriteBlobByte(image,255); /* layer opacity */\n        (void) WriteBlobByte(image,0);\n        (void) WriteBlobByte(image,next_image->compose==NoCompositeOp ?\n          1 << 0x02 : 1); /* layer properties - visible, etc. */\n        (void) WriteBlobByte(image,0);\n        property=(const char *) GetImageProperty(next_image,\"label\",exception);\n        if (property == (const char *) NULL)\n          {\n            char\n              layer_name[MagickPathExtent];\n\n            (void) WriteBlobMSBLong(image,16);\n            (void) WriteBlobMSBLong(image,0);\n            (void) WriteBlobMSBLong(image,0);\n            (void) FormatLocaleString(layer_name,MagickPathExtent,\"L%04ld\",(long)\n              layer_count++);\n            WritePascalString(image,layer_name,4);\n          }\n        else\n          {\n            size_t\n              label_length;\n\n            label_length=strlen(property);\n            (void) WriteBlobMSBLong(image,(unsigned int) (label_length+(4-\n              (label_length % 4))+8));\n            (void) WriteBlobMSBLong(image,0);\n            (void) WriteBlobMSBLong(image,0);\n            WritePascalString(image,property,4);\n          }\n        next_image=GetNextImageInList(next_image);\n      }\n      /*\n        Now the image data!\n      */\n      next_image=base_image;\n      while (next_image != NULL)\n      {\n        status=WriteImageChannels(&psd_info,image_info,image,next_image,\n          MagickTrue,exception);\n        next_image=GetNextImageInList(next_image);\n      }\n      (void) WriteBlobMSBLong(image,0);  /* user mask data */\n      base_image->compression=compression;\n    }\n  /*\n    Write composite image.\n  */\n  if (status != MagickFalse)\n    status=WriteImageChannels(&psd_info,image_info,image,image,MagickFalse,\n      exception);\n  (void) CloseBlob(image);\n  return(status);\n}\n",
    "cwe": [
      "CWE-125"
    ],
    "id": 223,
    "_valid_cwes": [
      "CWE-125"
    ]
  },
  {
    "cve_id": "CVE-2017-13006",
    "code_before_change": "l2tp_accm_print(netdissect_options *ndo, const u_char *dat)\n {\n \tconst uint16_t *ptr = (const uint16_t *)dat;\n \tuint16_t val_h, val_l;\n \n \tptr++;\t\t/* skip \"Reserved\" */\n \n\tval_h = EXTRACT_16BITS(ptr); ptr++;\n\tval_l = EXTRACT_16BITS(ptr); ptr++;\n \tND_PRINT((ndo, \"send=%08x \", (val_h<<16) + val_l));\n \n \tval_h = EXTRACT_16BITS(ptr); ptr++;\n \tval_l = EXTRACT_16BITS(ptr); ptr++;\n \tND_PRINT((ndo, \"recv=%08x \", (val_h<<16) + val_l));\n}\n",
    "code_after_change": "l2tp_accm_print(netdissect_options *ndo, const u_char *dat)\nl2tp_accm_print(netdissect_options *ndo, const u_char *dat, u_int length)\n {\n \tconst uint16_t *ptr = (const uint16_t *)dat;\n \tuint16_t val_h, val_l;\n \n\tif (length < 2) {\n\t\tND_PRINT((ndo, \"AVP too short\"));\n\t\treturn;\n\t}\n \tptr++;\t\t/* skip \"Reserved\" */\n\tlength -= 2;\n \n\tif (length < 4) {\n\t\tND_PRINT((ndo, \"AVP too short\"));\n\t\treturn;\n\t}\n\tval_h = EXTRACT_16BITS(ptr); ptr++; length -= 2;\n\tval_l = EXTRACT_16BITS(ptr); ptr++; length -= 2;\n \tND_PRINT((ndo, \"send=%08x \", (val_h<<16) + val_l));\n \n\tif (length < 4) {\n\t\tND_PRINT((ndo, \"AVP too short\"));\n\t\treturn;\n\t}\n \tval_h = EXTRACT_16BITS(ptr); ptr++;\n \tval_l = EXTRACT_16BITS(ptr); ptr++;\n \tND_PRINT((ndo, \"recv=%08x \", (val_h<<16) + val_l));\n}\n",
    "cwe": [
      "CWE-125"
    ],
    "id": 225,
    "_valid_cwes": [
      "CWE-125"
    ]
  },
  {
    "cve_id": "CVE-2017-11664",
    "code_before_change": "_WM_ParseNewMidi(uint8_t *midi_data, uint32_t midi_size) {\n    struct _mdi *mdi;\n \n     uint32_t tmp_val;\n     uint32_t midi_type;\n    uint32_t track_size;\n     uint8_t **tracks;\n     uint32_t end_of_tracks = 0;\n     uint32_t no_tracks;\n     uint32_t i;\n    uint32_t divisions = 96;\n    uint32_t tempo = 500000;\n    float samples_per_delta_f = 0.0;\n\n    uint32_t sample_count = 0;\n     float sample_count_f = 0.0;\n     float sample_remainder = 0.0;\n     uint8_t *sysex_store = NULL;\n     uint32_t *track_delta;\n     uint8_t *track_end;\n     uint32_t smallest_delta = 0;\n     uint32_t subtract_delta = 0;\n     uint32_t setup_ret = 0;\n \n    if (midi_size < 14) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, \"(too short)\", 0);\n        return (NULL);\n    }\n\n    if (!memcmp(midi_data, \"RIFF\", 4)) {\n        if (midi_size < 34) {\n            _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, \"(too short)\", 0);\n            return (NULL);\n        }\n        midi_data += 20;\n        midi_size -= 20;\n    }\n\n    if (memcmp(midi_data, \"MThd\", 4)) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_MIDI, NULL, 0);\n        return (NULL);\n    }\n    midi_data += 4;\n    midi_size -= 4;\n\n    /*\n     * Get Midi Header Size - must always be 6\n     */\n    tmp_val = *midi_data++ << 24;\n    tmp_val |= *midi_data++ << 16;\n    tmp_val |= *midi_data++ << 8;\n    tmp_val |= *midi_data++;\n    midi_size -= 4;\n    if (tmp_val != 6) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, NULL, 0);\n        return (NULL);\n    }\n\n    /*\n     * Get Midi Format - we only support 0, 1 & 2\n     */\n    tmp_val = *midi_data++ << 8;\n    tmp_val |= *midi_data++;\n    midi_size -= 2;\n    if (tmp_val > 2) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID, NULL, 0);\n        return (NULL);\n    }\n    midi_type = tmp_val;\n\n    /*\n     * Get No. of Tracks\n     */\n    tmp_val = *midi_data++ << 8;\n    tmp_val |= *midi_data++;\n    midi_size -= 2;\n    if (tmp_val < 1) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, \"(no tracks)\", 0);\n        return (NULL);\n    }\n    no_tracks = tmp_val;\n\n    /*\n     * Check that type 0 midi file has only 1 track\n     */\n    if ((midi_type == 0) && (no_tracks > 1)) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID, \"(expected 1 track for type 0 midi file, found more)\", 0);\n        return (NULL);\n    }\n\n    /*\n     * Get Divisions\n     */\n    divisions = *midi_data++ << 8;\n    divisions |= *midi_data++;\n    midi_size -= 2;\n    if (divisions & 0x00008000) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID, NULL, 0);\n        return (NULL);\n    }\n\n    samples_per_delta_f = _WM_GetSamplesPerTick(divisions, tempo);\n\n    mdi = _WM_initMDI();\n     _WM_midi_setup_divisions(mdi,divisions);\n \n     tracks = malloc(sizeof(uint8_t *) * no_tracks);\n     track_delta = malloc(sizeof(uint32_t) * no_tracks);\n     track_end = malloc(sizeof(uint8_t) * no_tracks);\n     running_event = malloc(sizeof(uint8_t) * no_tracks);\n\n    smallest_delta = 0xffffffff;\n    for (i = 0; i < no_tracks; i++) {\n        if (midi_size < 8) {\n            _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, \"(too short)\", 0);\n            goto _end;\n        }\n        if (memcmp(midi_data, \"MTrk\", 4) != 0) {\n            _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, \"(missing track header)\", 0);\n            goto _end;\n        }\n         midi_data += 4;\n         midi_size -= 4;\n \n        track_size = *midi_data++ << 24;\n        track_size |= *midi_data++ << 16;\n        track_size |= *midi_data++ << 8;\n        track_size |= *midi_data++;\n         midi_size -= 4;\n        if (midi_size < track_size) {\n             _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, \"(too short)\", 0);\n             goto _end;\n         }\n        if (track_size < 3) {\n             _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, \"(bad track size)\", 0);\n             goto _end;\n         }\n        if ((midi_data[track_size - 3] != 0xFF)\n                || (midi_data[track_size - 2] != 0x2F)\n                || (midi_data[track_size - 1] != 0x00)) {\n             _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, \"(missing EOT)\", 0);\n             goto _end;\n         }\n         tracks[i] = midi_data;\n        midi_data += track_size;\n        midi_size -= track_size;\n         track_end[i] = 0;\n         running_event[i] = 0;\n         track_delta[i] = 0;\n \n         while (*tracks[i] > 0x7F) {\n             track_delta[i] = (track_delta[i] << 7) + (*tracks[i] & 0x7F);\n             tracks[i]++;\n         }\n         track_delta[i] = (track_delta[i] << 7) + (*tracks[i] & 0x7F);\n         tracks[i]++;\n \n         if (midi_type == 1 ) {\n             if (track_delta[i] < smallest_delta) {\n                smallest_delta = track_delta[i];\n            }\n        } else {\n            /*\n             * Type 0 & 2 midi only needs delta from 1st track\n             * for initial sample calculations.\n             */\n            if (i == 0) smallest_delta = track_delta[i];\n        }\n    }\n\n    subtract_delta = smallest_delta;\n    sample_count_f = (((float) smallest_delta * samples_per_delta_f) + sample_remainder);\n    sample_count = (uint32_t) sample_count_f;\n    sample_remainder = sample_count_f - (float) sample_count;\n\n    mdi->events[mdi->event_count - 1].samples_to_next += sample_count;\n    mdi->extra_info.approx_total_samples += sample_count;\n\n    /*\n     * Handle type 0 & 2 the same, but type 1 differently\n     */\n    if (midi_type == 1) {\n        /* Type 1 */\n        while (end_of_tracks != no_tracks) {\n            smallest_delta = 0;\n            for (i = 0; i < no_tracks; i++) {\n                if (track_end[i])\n                    continue;\n                if (track_delta[i]) {\n                    track_delta[i] -= subtract_delta;\n                    if (track_delta[i]) {\n                        if ((!smallest_delta)\n                             || (smallest_delta > track_delta[i])) {\n                            smallest_delta = track_delta[i];\n                        }\n                        continue;\n                     }\n                 }\n                 do {\n                    setup_ret = _WM_SetupMidiEvent(mdi, tracks[i], running_event[i]);\n                     if (setup_ret == 0) {\n                         goto _end;\n                     }\n                    if (tracks[i][0] > 0x7f) {\n                        if (tracks[i][0] < 0xf0) {\n                            /* Events 0x80 - 0xef set running event */\n                            running_event[i] = tracks[i][0];\n                        } else if ((tracks[i][0] == 0xf0) || (tracks[i][0] == 0xf7)) {\n                            /* Sysex resets running event */\n                            running_event[i] = 0;\n                        } else if ((tracks[i][0] == 0xff) && (tracks[i][1] == 0x2f) && (tracks[i][2] == 0x00)) {\n                            /* End of Track */\n                             end_of_tracks++;\n                             track_end[i] = 1;\n                             tracks[i] += 3;\n                             goto NEXT_TRACK;\n                         } else if ((tracks[i][0] == 0xff) && (tracks[i][1] == 0x51) && (tracks[i][2] == 0x03)) {\n                             /* Tempo */\n                            tempo = (tracks[i][3] << 16) + (tracks[i][4] << 8)+ tracks[i][5];\n                            if (!tempo)\n                                tempo = 500000;\n\n                            samples_per_delta_f = _WM_GetSamplesPerTick(divisions, tempo);\n                         }\n                     }\n                     tracks[i] += setup_ret;\n \n                     if (*tracks[i] > 0x7f) {\n                         do {\n                             track_delta[i] = (track_delta[i] << 7) + (*tracks[i] & 0x7F);\n                             tracks[i]++;\n                         } while (*tracks[i] > 0x7f);\n                     }\n                     track_delta[i] = (track_delta[i] << 7) + (*tracks[i] & 0x7F);\n                     tracks[i]++;\n                 } while (!track_delta[i]);\n                 if ((!smallest_delta) || (smallest_delta > track_delta[i])) {\n                     smallest_delta = track_delta[i];\n                }\n            NEXT_TRACK: continue;\n            }\n\n            subtract_delta = smallest_delta;\n            sample_count_f = (((float) smallest_delta * samples_per_delta_f)\n                              + sample_remainder);\n            sample_count = (uint32_t) sample_count_f;\n            sample_remainder = sample_count_f - (float) sample_count;\n\n            mdi->events[mdi->event_count - 1].samples_to_next += sample_count;\n            mdi->extra_info.approx_total_samples += sample_count;\n        }\n    } else {\n        /* Type 0 & 2 */\n        if (midi_type == 2) {\n            mdi->is_type2 = 1;\n        }\n        sample_remainder = 0.0;\n         for (i = 0; i < no_tracks; i++) {\n             running_event[i] = 0;\n             do {\n                setup_ret = _WM_SetupMidiEvent(mdi, tracks[i], running_event[i]);\n                 if (setup_ret == 0) {\n                     goto _end;\n                 }\n                if (tracks[i][0] > 0x7f) {\n                    if (tracks[i][0] < 0xf0) {\n                        /* Events 0x80 - 0xef set running event */\n                        running_event[i] = tracks[i][0];\n                    } else if ((tracks[i][0] == 0xf0) || (tracks[i][0] == 0xf7)) {\n                        /* Sysex resets running event */\n                        running_event[i] = 0;\n                    } else if ((tracks[i][0] == 0xff) && (tracks[i][1] == 0x2f) && (tracks[i][2] == 0x00)) {\n                        /* End of Track */\n                        track_end[i] = 1;\n                        goto NEXT_TRACK2;\n                    } else if ((tracks[i][0] == 0xff) && (tracks[i][1] == 0x51) && (tracks[i][2] == 0x03)) {\n                        /* Tempo */\n                        tempo = (tracks[i][3] << 16) + (tracks[i][4] << 8)+ tracks[i][5];\n                        if (!tempo)\n                            tempo = 500000;\n\n                        samples_per_delta_f = _WM_GetSamplesPerTick(divisions, tempo);\n                     }\n                 }\n                 tracks[i] += setup_ret;\n \n                 track_delta[i] = 0;\n                 if (*tracks[i] > 0x7f) {\n                     do {\n                         track_delta[i] = (track_delta[i] << 7) + (*tracks[i] & 0x7F);\n                         tracks[i]++;\n                     } while (*tracks[i] > 0x7f);\n                 }\n                 track_delta[i] = (track_delta[i] << 7) + (*tracks[i] & 0x7F);\n                 tracks[i]++;\n \n                 sample_count_f = (((float) track_delta[i] * samples_per_delta_f)\n                                   + sample_remainder);\n                sample_count = (uint32_t) sample_count_f;\n                sample_remainder = sample_count_f - (float) sample_count;\n                mdi->events[mdi->event_count - 1].samples_to_next += sample_count;\n                mdi->extra_info.approx_total_samples += sample_count;\n            NEXT_TRACK2:\n                smallest_delta = track_delta[i]; /* Added just to keep Xcode happy */\n                UNUSED(smallest_delta); /* Added to just keep clang happy */\n            } while (track_end[i] == 0);\n        }\n    }\n\n    if ((mdi->reverb = _WM_init_reverb(_WM_SampleRate, _WM_reverb_room_width,\n            _WM_reverb_room_length, _WM_reverb_listen_posx, _WM_reverb_listen_posy))\n          == NULL) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_MEM, \"to init reverb\", 0);\n        goto _end;\n    }\n\n    mdi->extra_info.current_sample = 0;\n    mdi->current_event = &mdi->events[0];\n    mdi->samples_to_mix = 0;\n    mdi->note = NULL;\n\n    _WM_ResetToStart(mdi);\n\n_end:   free(sysex_store);\n    free(track_end);\n     free(track_delta);\n     free(running_event);\n     free(tracks);\n     if (mdi->reverb) return (mdi);\n     _WM_freeMDI(mdi);\n     return (NULL);\n}\n",
    "code_after_change": "_WM_ParseNewMidi(uint8_t *midi_data, uint32_t midi_size) {\n    struct _mdi *mdi;\n \n     uint32_t tmp_val;\n     uint32_t midi_type;\n     uint8_t **tracks;\n    uint32_t *track_size;\n     uint32_t end_of_tracks = 0;\n     uint32_t no_tracks;\n     uint32_t i;\n    uint32_t divisions = 96;\n    uint32_t tempo = 500000;\n    float samples_per_delta_f = 0.0;\n\n    uint32_t sample_count = 0;\n     float sample_count_f = 0.0;\n     float sample_remainder = 0.0;\n     uint8_t *sysex_store = NULL;\n     uint32_t *track_delta;\n     uint8_t *track_end;\n     uint32_t smallest_delta = 0;\n     uint32_t subtract_delta = 0;\n     uint32_t setup_ret = 0;\n \n    if (midi_size < 14) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, \"(too short)\", 0);\n        return (NULL);\n    }\n\n    if (!memcmp(midi_data, \"RIFF\", 4)) {\n        if (midi_size < 34) {\n            _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, \"(too short)\", 0);\n            return (NULL);\n        }\n        midi_data += 20;\n        midi_size -= 20;\n    }\n\n    if (memcmp(midi_data, \"MThd\", 4)) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_MIDI, NULL, 0);\n        return (NULL);\n    }\n    midi_data += 4;\n    midi_size -= 4;\n\n    /*\n     * Get Midi Header Size - must always be 6\n     */\n    tmp_val = *midi_data++ << 24;\n    tmp_val |= *midi_data++ << 16;\n    tmp_val |= *midi_data++ << 8;\n    tmp_val |= *midi_data++;\n    midi_size -= 4;\n    if (tmp_val != 6) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, NULL, 0);\n        return (NULL);\n    }\n\n    /*\n     * Get Midi Format - we only support 0, 1 & 2\n     */\n    tmp_val = *midi_data++ << 8;\n    tmp_val |= *midi_data++;\n    midi_size -= 2;\n    if (tmp_val > 2) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID, NULL, 0);\n        return (NULL);\n    }\n    midi_type = tmp_val;\n\n    /*\n     * Get No. of Tracks\n     */\n    tmp_val = *midi_data++ << 8;\n    tmp_val |= *midi_data++;\n    midi_size -= 2;\n    if (tmp_val < 1) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, \"(no tracks)\", 0);\n        return (NULL);\n    }\n    no_tracks = tmp_val;\n\n    /*\n     * Check that type 0 midi file has only 1 track\n     */\n    if ((midi_type == 0) && (no_tracks > 1)) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID, \"(expected 1 track for type 0 midi file, found more)\", 0);\n        return (NULL);\n    }\n\n    /*\n     * Get Divisions\n     */\n    divisions = *midi_data++ << 8;\n    divisions |= *midi_data++;\n    midi_size -= 2;\n    if (divisions & 0x00008000) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID, NULL, 0);\n        return (NULL);\n    }\n\n    samples_per_delta_f = _WM_GetSamplesPerTick(divisions, tempo);\n\n    mdi = _WM_initMDI();\n     _WM_midi_setup_divisions(mdi,divisions);\n \n     tracks = malloc(sizeof(uint8_t *) * no_tracks);\n    track_size = malloc(sizeof(uint32_t) * no_tracks);\n     track_delta = malloc(sizeof(uint32_t) * no_tracks);\n     track_end = malloc(sizeof(uint8_t) * no_tracks);\n     running_event = malloc(sizeof(uint8_t) * no_tracks);\n\n    smallest_delta = 0xffffffff;\n    for (i = 0; i < no_tracks; i++) {\n        if (midi_size < 8) {\n            _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, \"(too short)\", 0);\n            goto _end;\n        }\n        if (memcmp(midi_data, \"MTrk\", 4) != 0) {\n            _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, \"(missing track header)\", 0);\n            goto _end;\n        }\n         midi_data += 4;\n         midi_size -= 4;\n \n        /* track size */\n        tmp_val = *midi_data++ << 24;\n        tmp_val |= *midi_data++ << 16;\n        tmp_val |= *midi_data++ << 8;\n        tmp_val |= *midi_data++;\n         midi_size -= 4;\n        if (midi_size < tmp_val) {\n             _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, \"(too short)\", 0);\n             goto _end;\n         }\n        if (tmp_val < 3) {\n             _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, \"(bad track size)\", 0);\n             goto _end;\n         }\n        if ((midi_data[tmp_val - 3] != 0xFF)\n                || (midi_data[tmp_val - 2] != 0x2F)\n                || (midi_data[tmp_val - 1] != 0x00)) {\n             _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, \"(missing EOT)\", 0);\n             goto _end;\n         }\n         tracks[i] = midi_data;\n        track_size[i] = tmp_val;\n        midi_data += tmp_val;\n        midi_size -= tmp_val;\n         track_end[i] = 0;\n         running_event[i] = 0;\n         track_delta[i] = 0;\n \n         while (*tracks[i] > 0x7F) {\n             track_delta[i] = (track_delta[i] << 7) + (*tracks[i] & 0x7F);\n             tracks[i]++;\n            track_size[i]--;\n         }\n         track_delta[i] = (track_delta[i] << 7) + (*tracks[i] & 0x7F);\n         tracks[i]++;\n        track_size[i]--;\n \n         if (midi_type == 1 ) {\n             if (track_delta[i] < smallest_delta) {\n                smallest_delta = track_delta[i];\n            }\n        } else {\n            /*\n             * Type 0 & 2 midi only needs delta from 1st track\n             * for initial sample calculations.\n             */\n            if (i == 0) smallest_delta = track_delta[i];\n        }\n    }\n\n    subtract_delta = smallest_delta;\n    sample_count_f = (((float) smallest_delta * samples_per_delta_f) + sample_remainder);\n    sample_count = (uint32_t) sample_count_f;\n    sample_remainder = sample_count_f - (float) sample_count;\n\n    mdi->events[mdi->event_count - 1].samples_to_next += sample_count;\n    mdi->extra_info.approx_total_samples += sample_count;\n\n    /*\n     * Handle type 0 & 2 the same, but type 1 differently\n     */\n    if (midi_type == 1) {\n        /* Type 1 */\n        while (end_of_tracks != no_tracks) {\n            smallest_delta = 0;\n            for (i = 0; i < no_tracks; i++) {\n                if (track_end[i])\n                    continue;\n                if (track_delta[i]) {\n                    track_delta[i] -= subtract_delta;\n                    if (track_delta[i]) {\n                        if ((!smallest_delta)\n                             || (smallest_delta > track_delta[i])) {\n                            smallest_delta = track_delta[i];\n                        }\n                        continue;\n                     }\n                 }\n                 do {\n                    setup_ret = _WM_SetupMidiEvent(mdi, tracks[i], track_size[i], running_event[i]);\n                     if (setup_ret == 0) {\n                         goto _end;\n                     }\n                    if (tracks[i][0] > 0x7f) {\n                        if (tracks[i][0] < 0xf0) {\n                            /* Events 0x80 - 0xef set running event */\n                            running_event[i] = tracks[i][0];\n                        } else if ((tracks[i][0] == 0xf0) || (tracks[i][0] == 0xf7)) {\n                            /* Sysex resets running event */\n                            running_event[i] = 0;\n                        } else if ((tracks[i][0] == 0xff) && (tracks[i][1] == 0x2f) && (tracks[i][2] == 0x00)) {\n                            /* End of Track */\n                             end_of_tracks++;\n                             track_end[i] = 1;\n                             tracks[i] += 3;\n                            track_size[i] -= 3;\n                             goto NEXT_TRACK;\n                         } else if ((tracks[i][0] == 0xff) && (tracks[i][1] == 0x51) && (tracks[i][2] == 0x03)) {\n                             /* Tempo */\n                            tempo = (tracks[i][3] << 16) + (tracks[i][4] << 8)+ tracks[i][5];\n                            if (!tempo)\n                                tempo = 500000;\n\n                            samples_per_delta_f = _WM_GetSamplesPerTick(divisions, tempo);\n                         }\n                     }\n                     tracks[i] += setup_ret;\n                    track_size[i] -= setup_ret;\n \n                     if (*tracks[i] > 0x7f) {\n                         do {\n                            if (!track_size[i]) break;\n                             track_delta[i] = (track_delta[i] << 7) + (*tracks[i] & 0x7F);\n                             tracks[i]++;\n                            track_size[i]--;\n                         } while (*tracks[i] > 0x7f);\n                     }\n                    if (!track_size[i]) {\n                        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, \"(too short)\", 0);\n                        goto _end;\n                    }\n                     track_delta[i] = (track_delta[i] << 7) + (*tracks[i] & 0x7F);\n                     tracks[i]++;\n                    track_size[i]--;\n                 } while (!track_delta[i]);\n                 if ((!smallest_delta) || (smallest_delta > track_delta[i])) {\n                     smallest_delta = track_delta[i];\n                }\n            NEXT_TRACK: continue;\n            }\n\n            subtract_delta = smallest_delta;\n            sample_count_f = (((float) smallest_delta * samples_per_delta_f)\n                              + sample_remainder);\n            sample_count = (uint32_t) sample_count_f;\n            sample_remainder = sample_count_f - (float) sample_count;\n\n            mdi->events[mdi->event_count - 1].samples_to_next += sample_count;\n            mdi->extra_info.approx_total_samples += sample_count;\n        }\n    } else {\n        /* Type 0 & 2 */\n        if (midi_type == 2) {\n            mdi->is_type2 = 1;\n        }\n        sample_remainder = 0.0;\n         for (i = 0; i < no_tracks; i++) {\n             running_event[i] = 0;\n             do {\n                setup_ret = _WM_SetupMidiEvent(mdi, tracks[i], track_size[i], running_event[i]);\n                 if (setup_ret == 0) {\n                     goto _end;\n                 }\n                if (tracks[i][0] > 0x7f) {\n                    if (tracks[i][0] < 0xf0) {\n                        /* Events 0x80 - 0xef set running event */\n                        running_event[i] = tracks[i][0];\n                    } else if ((tracks[i][0] == 0xf0) || (tracks[i][0] == 0xf7)) {\n                        /* Sysex resets running event */\n                        running_event[i] = 0;\n                    } else if ((tracks[i][0] == 0xff) && (tracks[i][1] == 0x2f) && (tracks[i][2] == 0x00)) {\n                        /* End of Track */\n                        track_end[i] = 1;\n                        goto NEXT_TRACK2;\n                    } else if ((tracks[i][0] == 0xff) && (tracks[i][1] == 0x51) && (tracks[i][2] == 0x03)) {\n                        /* Tempo */\n                        tempo = (tracks[i][3] << 16) + (tracks[i][4] << 8)+ tracks[i][5];\n                        if (!tempo)\n                            tempo = 500000;\n\n                        samples_per_delta_f = _WM_GetSamplesPerTick(divisions, tempo);\n                     }\n                 }\n                 tracks[i] += setup_ret;\n                track_size[i] -= setup_ret;\n \n                 track_delta[i] = 0;\n                 if (*tracks[i] > 0x7f) {\n                     do {\n                        if (!track_size[i]) break;\n                         track_delta[i] = (track_delta[i] << 7) + (*tracks[i] & 0x7F);\n                         tracks[i]++;\n                        track_size[i]--;\n                     } while (*tracks[i] > 0x7f);\n                 }\n                if (!track_size[i]) {\n                    _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, \"(too short)\", 0);\n                    goto _end;\n                }\n                 track_delta[i] = (track_delta[i] << 7) + (*tracks[i] & 0x7F);\n                 tracks[i]++;\n                track_size[i]--;\n \n                 sample_count_f = (((float) track_delta[i] * samples_per_delta_f)\n                                   + sample_remainder);\n                sample_count = (uint32_t) sample_count_f;\n                sample_remainder = sample_count_f - (float) sample_count;\n                mdi->events[mdi->event_count - 1].samples_to_next += sample_count;\n                mdi->extra_info.approx_total_samples += sample_count;\n            NEXT_TRACK2:\n                smallest_delta = track_delta[i]; /* Added just to keep Xcode happy */\n                UNUSED(smallest_delta); /* Added to just keep clang happy */\n            } while (track_end[i] == 0);\n        }\n    }\n\n    if ((mdi->reverb = _WM_init_reverb(_WM_SampleRate, _WM_reverb_room_width,\n            _WM_reverb_room_length, _WM_reverb_listen_posx, _WM_reverb_listen_posy))\n          == NULL) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_MEM, \"to init reverb\", 0);\n        goto _end;\n    }\n\n    mdi->extra_info.current_sample = 0;\n    mdi->current_event = &mdi->events[0];\n    mdi->samples_to_mix = 0;\n    mdi->note = NULL;\n\n    _WM_ResetToStart(mdi);\n\n_end:   free(sysex_store);\n    free(track_end);\n     free(track_delta);\n     free(running_event);\n     free(tracks);\n    free(track_size);\n     if (mdi->reverb) return (mdi);\n     _WM_freeMDI(mdi);\n     return (NULL);\n}\n",
    "cwe": [
      "CWE-125"
    ],
    "id": 268,
    "_valid_cwes": [
      "CWE-125"
    ]
  },
  {
    "cve_id": "CVE-2018-8789",
    "code_before_change": "void ntlm_print_message_fields(NTLM_MESSAGE_FIELDS* fields, const char* name)\n {\n \tWLog_DBG(TAG, \"%s (Len: %\"PRIu16\" MaxLen: %\"PRIu16\" BufferOffset: %\"PRIu32\")\",\n \t         name, fields->Len, fields->MaxLen, fields->BufferOffset);\n\n\tif (fields->Len > 0)\n\t\twinpr_HexDump(TAG, WLOG_DEBUG, fields->Buffer, fields->Len);\n}\n",
    "code_after_change": "void ntlm_print_message_fields(NTLM_MESSAGE_FIELDS* fields, const char* name)\nstatic void ntlm_print_message_fields(NTLM_MESSAGE_FIELDS* fields, const char* name)\n {\n \tWLog_DBG(TAG, \"%s (Len: %\"PRIu16\" MaxLen: %\"PRIu16\" BufferOffset: %\"PRIu32\")\",\n \t         name, fields->Len, fields->MaxLen, fields->BufferOffset);\n\n\tif (fields->Len > 0)\n\t\twinpr_HexDump(TAG, WLOG_DEBUG, fields->Buffer, fields->Len);\n}\n",
    "cwe": [
      "CWE-125"
    ],
    "id": 272,
    "_valid_cwes": [
      "CWE-125"
    ]
  },
  {
    "cve_id": "CVE-2017-13006",
    "code_before_change": " l2tp_q931_cc_print(netdissect_options *ndo, const u_char *dat, u_int length)\n {\n \tprint_16bits_val(ndo, (const uint16_t *)dat);\n \tND_PRINT((ndo, \", %02x\", dat[2]));\n\tif (length > 3) {\n \t\tND_PRINT((ndo, \" \"));\n\t\tprint_string(ndo, dat+3, length-3);\n \t}\n }\n",
    "code_after_change": " l2tp_q931_cc_print(netdissect_options *ndo, const u_char *dat, u_int length)\n {\n\tif (length < 3) {\n\t\tND_PRINT((ndo, \"AVP too short\"));\n\t\treturn;\n\t}\n \tprint_16bits_val(ndo, (const uint16_t *)dat);\n \tND_PRINT((ndo, \", %02x\", dat[2]));\n\tdat += 3;\n\tlength -= 3;\n\tif (length != 0) {\n \t\tND_PRINT((ndo, \" \"));\n\t\tprint_string(ndo, dat, length);\n \t}\n }\n",
    "cwe": [
      "CWE-125"
    ],
    "id": 278,
    "_valid_cwes": [
      "CWE-125"
    ]
  },
  {
    "cve_id": "CVE-2016-7525",
    "code_before_change": " static inline size_t GetPSDRowSize(Image *image)\n {\n   if (image->depth == 1)\n    return((image->columns+7)/8);\n   else\n     return(image->columns*GetPSDPacketSize(image));\n }\n",
    "code_after_change": " static inline size_t GetPSDRowSize(Image *image)\n {\n   if (image->depth == 1)\n    return(((image->columns+7)/8)*GetPSDPacketSize(image));\n   else\n     return(image->columns*GetPSDPacketSize(image));\n }\n",
    "cwe": [
      "CWE-125"
    ],
    "id": 301,
    "_valid_cwes": [
      "CWE-125"
    ]
  },
  {
    "cve_id": "CVE-2016-5842",
    "code_before_change": "MagickBooleanType SyncExifProfile(Image *image,StringInfo *profile)\n{\n#define MaxDirectoryStack  16\n#define EXIF_DELIMITER  \"\\n\"\n#define EXIF_NUM_FORMATS  12\n#define TAG_EXIF_OFFSET  0x8769\n#define TAG_INTEROP_OFFSET  0xa005\n\n  typedef struct _DirectoryInfo\n  {\n    unsigned char\n      *directory;\n\n    size_t\n      entry;\n  } DirectoryInfo;\n\n  DirectoryInfo\n    directory_stack[MaxDirectoryStack];\n\n  EndianType\n    endian;\n\n  size_t\n    entry,\n    length,\n    number_entries;\n\n  ssize_t\n    id,\n    level,\n    offset;\n\n  static int\n    format_bytes[] = {0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8};\n\n  unsigned char\n    *directory,\n    *exif;\n\n  /*\n    Set EXIF resolution tag.\n  */\n  length=GetStringInfoLength(profile);\n  exif=GetStringInfoDatum(profile);\n  if (length < 16)\n    return(MagickFalse);\n  id=(ssize_t) ReadProfileShort(LSBEndian,exif);\n  if ((id != 0x4949) && (id != 0x4D4D))\n    {\n      while (length != 0)\n      {\n        if (ReadProfileByte(&exif,&length) != 0x45)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x78)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x69)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x66)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x00)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x00)\n          continue;\n        break;\n      }\n      if (length < 16)\n        return(MagickFalse);\n      id=(ssize_t) ReadProfileShort(LSBEndian,exif);\n    }\n  endian=LSBEndian;\n  if (id == 0x4949)\n    endian=LSBEndian;\n  else\n    if (id == 0x4D4D)\n      endian=MSBEndian;\n    else\n      return(MagickFalse);\n  if (ReadProfileShort(endian,exif+2) != 0x002a)\n    return(MagickFalse);\n  /*\n    This the offset to the first IFD.\n  */\n  offset=(ssize_t) ReadProfileLong(endian,exif+4);\n  if ((offset < 0) || (size_t) offset >= length)\n    return(MagickFalse);\n  directory=exif+offset;\n  level=0;\n  entry=0;\n  do\n  {\n    if (level > 0)\n      {\n        level--;\n        directory=directory_stack[level].directory;\n        entry=directory_stack[level].entry;\n      }\n    if ((directory < exif) || (directory > (exif+length-2)))\n      break;\n    /*\n      Determine how many entries there are in the current IFD.\n    */\n    number_entries=ReadProfileShort(endian,directory);\n    for ( ; entry < number_entries; entry++)\n    {\n      int\n        components;\n\n      register unsigned char\n        *p,\n        *q;\n\n      size_t\n        number_bytes;\n\n      ssize_t\n        format,\n         tag_value;\n \n       q=(unsigned char *) (directory+2+(12*entry));\n       tag_value=(ssize_t) ReadProfileShort(endian,q);\n       format=(ssize_t) ReadProfileShort(endian,q+2);\n       if ((format-1) >= EXIF_NUM_FORMATS)\n         break;\n       components=(ssize_t) ReadProfileLong(endian,q+4);\n       number_bytes=(size_t) components*format_bytes[format];\n       if ((ssize_t) number_bytes < components)\n         break;  /* prevent overflow */\n      if (number_bytes <= 4)\n        p=q+8;\n      else\n        {\n          /*\n            The directory entry contains an offset.\n          */\n          offset=(ssize_t)  ReadProfileLong(endian,q+8);\n          if ((size_t) (offset+number_bytes) > length)\n            continue;\n          if (~length < number_bytes)\n            continue;  /* prevent overflow */\n          p=(unsigned char *) (exif+offset);\n        }\n      switch (tag_value)\n      {\n        case 0x011a:\n        {\n          (void) WriteProfileLong(endian,(size_t) (image->resolution.x+0.5),p);\n          (void) WriteProfileLong(endian,1UL,p+4);\n          break;\n        }\n        case 0x011b:\n        {\n          (void) WriteProfileLong(endian,(size_t) (image->resolution.y+0.5),p);\n          (void) WriteProfileLong(endian,1UL,p+4);\n          break;\n        }\n        case 0x0112:\n        {\n          if (number_bytes == 4)\n            {\n              (void) WriteProfileLong(endian,(size_t) image->orientation,p);\n              break;\n            }\n          (void) WriteProfileShort(endian,(unsigned short) image->orientation,\n            p);\n          break;\n        }\n        case 0x0128:\n        {\n          if (number_bytes == 4)\n            {\n              (void) WriteProfileLong(endian,(size_t) (image->units+1),p);\n              break;\n            }\n          (void) WriteProfileShort(endian,(unsigned short) (image->units+1),p);\n          break;\n        }\n        default:\n          break;\n      }\n      if ((tag_value == TAG_EXIF_OFFSET) || (tag_value == TAG_INTEROP_OFFSET))\n        {\n          offset=(ssize_t)  ReadProfileLong(endian,p);\n          if (((size_t) offset < length) && (level < (MaxDirectoryStack-2)))\n            {\n              directory_stack[level].directory=directory;\n              entry++;\n              directory_stack[level].entry=entry;\n              level++;\n              directory_stack[level].directory=exif+offset;\n              directory_stack[level].entry=0;\n              level++;\n              if ((directory+2+(12*number_entries)) > (exif+length))\n                break;\n              offset=(ssize_t)  ReadProfileLong(endian,directory+2+(12*\n                number_entries));\n              if ((offset != 0) && ((size_t) offset < length) &&\n                  (level < (MaxDirectoryStack-2)))\n                {\n                  directory_stack[level].directory=exif+offset;\n                  directory_stack[level].entry=0;\n                  level++;\n                }\n            }\n          break;\n        }\n    }\n  } while (level > 0);\n  return(MagickTrue);\n}\n",
    "code_after_change": "MagickBooleanType SyncExifProfile(Image *image,StringInfo *profile)\n{\n#define MaxDirectoryStack  16\n#define EXIF_DELIMITER  \"\\n\"\n#define EXIF_NUM_FORMATS  12\n#define TAG_EXIF_OFFSET  0x8769\n#define TAG_INTEROP_OFFSET  0xa005\n\n  typedef struct _DirectoryInfo\n  {\n    unsigned char\n      *directory;\n\n    size_t\n      entry;\n  } DirectoryInfo;\n\n  DirectoryInfo\n    directory_stack[MaxDirectoryStack];\n\n  EndianType\n    endian;\n\n  size_t\n    entry,\n    length,\n    number_entries;\n\n  ssize_t\n    id,\n    level,\n    offset;\n\n  static int\n    format_bytes[] = {0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8};\n\n  unsigned char\n    *directory,\n    *exif;\n\n  /*\n    Set EXIF resolution tag.\n  */\n  length=GetStringInfoLength(profile);\n  exif=GetStringInfoDatum(profile);\n  if (length < 16)\n    return(MagickFalse);\n  id=(ssize_t) ReadProfileShort(LSBEndian,exif);\n  if ((id != 0x4949) && (id != 0x4D4D))\n    {\n      while (length != 0)\n      {\n        if (ReadProfileByte(&exif,&length) != 0x45)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x78)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x69)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x66)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x00)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x00)\n          continue;\n        break;\n      }\n      if (length < 16)\n        return(MagickFalse);\n      id=(ssize_t) ReadProfileShort(LSBEndian,exif);\n    }\n  endian=LSBEndian;\n  if (id == 0x4949)\n    endian=LSBEndian;\n  else\n    if (id == 0x4D4D)\n      endian=MSBEndian;\n    else\n      return(MagickFalse);\n  if (ReadProfileShort(endian,exif+2) != 0x002a)\n    return(MagickFalse);\n  /*\n    This the offset to the first IFD.\n  */\n  offset=(ssize_t) ReadProfileLong(endian,exif+4);\n  if ((offset < 0) || (size_t) offset >= length)\n    return(MagickFalse);\n  directory=exif+offset;\n  level=0;\n  entry=0;\n  do\n  {\n    if (level > 0)\n      {\n        level--;\n        directory=directory_stack[level].directory;\n        entry=directory_stack[level].entry;\n      }\n    if ((directory < exif) || (directory > (exif+length-2)))\n      break;\n    /*\n      Determine how many entries there are in the current IFD.\n    */\n    number_entries=ReadProfileShort(endian,directory);\n    for ( ; entry < number_entries; entry++)\n    {\n      int\n        components;\n\n      register unsigned char\n        *p,\n        *q;\n\n      size_t\n        number_bytes;\n\n      ssize_t\n        format,\n         tag_value;\n \n       q=(unsigned char *) (directory+2+(12*entry));\n      if (q > (exif+length-12))\n        break;  /* corrupt EXIF */\n       tag_value=(ssize_t) ReadProfileShort(endian,q);\n       format=(ssize_t) ReadProfileShort(endian,q+2);\n       if ((format-1) >= EXIF_NUM_FORMATS)\n         break;\n       components=(ssize_t) ReadProfileLong(endian,q+4);\n      if (components < 0)\n        break;  /* corrupt EXIF */\n       number_bytes=(size_t) components*format_bytes[format];\n       if ((ssize_t) number_bytes < components)\n         break;  /* prevent overflow */\n      if (number_bytes <= 4)\n        p=q+8;\n      else\n        {\n          /*\n            The directory entry contains an offset.\n          */\n          offset=(ssize_t)  ReadProfileLong(endian,q+8);\n          if ((size_t) (offset+number_bytes) > length)\n            continue;\n          if (~length < number_bytes)\n            continue;  /* prevent overflow */\n          p=(unsigned char *) (exif+offset);\n        }\n      switch (tag_value)\n      {\n        case 0x011a:\n        {\n          (void) WriteProfileLong(endian,(size_t) (image->resolution.x+0.5),p);\n          (void) WriteProfileLong(endian,1UL,p+4);\n          break;\n        }\n        case 0x011b:\n        {\n          (void) WriteProfileLong(endian,(size_t) (image->resolution.y+0.5),p);\n          (void) WriteProfileLong(endian,1UL,p+4);\n          break;\n        }\n        case 0x0112:\n        {\n          if (number_bytes == 4)\n            {\n              (void) WriteProfileLong(endian,(size_t) image->orientation,p);\n              break;\n            }\n          (void) WriteProfileShort(endian,(unsigned short) image->orientation,\n            p);\n          break;\n        }\n        case 0x0128:\n        {\n          if (number_bytes == 4)\n            {\n              (void) WriteProfileLong(endian,(size_t) (image->units+1),p);\n              break;\n            }\n          (void) WriteProfileShort(endian,(unsigned short) (image->units+1),p);\n          break;\n        }\n        default:\n          break;\n      }\n      if ((tag_value == TAG_EXIF_OFFSET) || (tag_value == TAG_INTEROP_OFFSET))\n        {\n          offset=(ssize_t)  ReadProfileLong(endian,p);\n          if (((size_t) offset < length) && (level < (MaxDirectoryStack-2)))\n            {\n              directory_stack[level].directory=directory;\n              entry++;\n              directory_stack[level].entry=entry;\n              level++;\n              directory_stack[level].directory=exif+offset;\n              directory_stack[level].entry=0;\n              level++;\n              if ((directory+2+(12*number_entries)) > (exif+length))\n                break;\n              offset=(ssize_t)  ReadProfileLong(endian,directory+2+(12*\n                number_entries));\n              if ((offset != 0) && ((size_t) offset < length) &&\n                  (level < (MaxDirectoryStack-2)))\n                {\n                  directory_stack[level].directory=exif+offset;\n                  directory_stack[level].entry=0;\n                  level++;\n                }\n            }\n          break;\n        }\n    }\n  } while (level > 0);\n  return(MagickTrue);\n}\n",
    "cwe": [
      "CWE-125"
    ],
    "id": 321,
    "_valid_cwes": [
      "CWE-125"
    ]
  },
  {
    "cve_id": "CVE-2017-13032",
    "code_before_change": "print_attr_string(netdissect_options *ndo,\n                  register const u_char *data, u_int length, u_short attr_code)\n{\n   register u_int i;\n\n   ND_TCHECK2(data[0],length);\n\n   switch(attr_code)\n    {\n       case TUNNEL_PASS:\n            if (length < 3)\n           {\n              ND_PRINT((ndo, \"%s\", tstr));\n              return;\n           }\n            if (*data && (*data <=0x1F) )\n               ND_PRINT((ndo, \"Tag[%u] \", *data));\n            else\n              ND_PRINT((ndo, \"Tag[Unused] \"));\n           data++;\n           length--;\n           ND_PRINT((ndo, \"Salt %u \", EXTRACT_16BITS(data)));\n           data+=2;\n           length-=2;\n        break;\n      case TUNNEL_CLIENT_END:\n      case TUNNEL_SERVER_END:\n      case TUNNEL_PRIV_GROUP:\n      case TUNNEL_ASSIGN_ID:\n      case TUNNEL_CLIENT_AUTH:\n      case TUNNEL_SERVER_AUTH:\n            if (*data <= 0x1F)\n            {\n               if (length < 1)\n              {\n                 ND_PRINT((ndo, \"%s\", tstr));\n                 return;\n              }\n               if (*data)\n                 ND_PRINT((ndo, \"Tag[%u] \", *data));\n               else\n                ND_PRINT((ndo, \"Tag[Unused] \"));\n              data++;\n              length--;\n            }\n         break;\n       case EGRESS_VLAN_NAME:\n            ND_PRINT((ndo, \"%s (0x%02x) \",\n                   tok2str(rfc4675_tagged,\"Unknown tag\",*data),\n                   *data));\n           data++;\n           length--;\n         break;\n    }\n \n   for (i=0; *data && i < length ; i++, data++)\n        ND_PRINT((ndo, \"%c\", (*data < 32 || *data > 126) ? '.' : *data));\n \n    return;\n\n   trunc:\n      ND_PRINT((ndo, \"%s\", tstr));\n}\n",
    "code_after_change": "print_attr_string(netdissect_options *ndo,\n                  register const u_char *data, u_int length, u_short attr_code)\n{\n   register u_int i;\n\n   ND_TCHECK2(data[0],length);\n\n   switch(attr_code)\n    {\n       case TUNNEL_PASS:\n            if (length < 3)\n              goto trunc;\n            if (*data && (*data <=0x1F) )\n               ND_PRINT((ndo, \"Tag[%u] \", *data));\n            else\n              ND_PRINT((ndo, \"Tag[Unused] \"));\n           data++;\n           length--;\n           ND_PRINT((ndo, \"Salt %u \", EXTRACT_16BITS(data)));\n           data+=2;\n           length-=2;\n        break;\n      case TUNNEL_CLIENT_END:\n      case TUNNEL_SERVER_END:\n      case TUNNEL_PRIV_GROUP:\n      case TUNNEL_ASSIGN_ID:\n      case TUNNEL_CLIENT_AUTH:\n      case TUNNEL_SERVER_AUTH:\n            if (*data <= 0x1F)\n            {\n               if (length < 1)\n                 goto trunc;\n               if (*data)\n                 ND_PRINT((ndo, \"Tag[%u] \", *data));\n               else\n                ND_PRINT((ndo, \"Tag[Unused] \"));\n              data++;\n              length--;\n            }\n         break;\n       case EGRESS_VLAN_NAME:\n           if (length < 1)\n              goto trunc;\n            ND_PRINT((ndo, \"%s (0x%02x) \",\n                   tok2str(rfc4675_tagged,\"Unknown tag\",*data),\n                   *data));\n           data++;\n           length--;\n         break;\n    }\n \n   for (i=0; i < length && *data; i++, data++)\n        ND_PRINT((ndo, \"%c\", (*data < 32 || *data > 126) ? '.' : *data));\n \n    return;\n\n   trunc:\n      ND_PRINT((ndo, \"%s\", tstr));\n}\n",
    "cwe": [
      "CWE-125"
    ],
    "id": 331,
    "_valid_cwes": [
      "CWE-125"
    ]
  },
  {
    "cve_id": "CVE-2017-13030",
    "code_before_change": " pimv1_print(netdissect_options *ndo,\n             register const u_char *bp, register u_int len)\n {\n\tregister const u_char *ep;\n \tregister u_char type;\n \n\tep = (const u_char *)ndo->ndo_snapend;\n\tif (bp >= ep)\n\t\treturn;\n \tND_TCHECK(bp[1]);\n \ttype = bp[1];\n \n\tND_PRINT((ndo, \" %s\", tok2str(pimv1_type_str, \"[type %u]\", type)));\n\tswitch (type) {\n\tcase PIMV1_TYPE_QUERY:\n\t\tif (ND_TTEST(bp[8])) {\n\t\t\tswitch (bp[8] >> 4) {\n\t\t\tcase 0:\n\t\t\t\tND_PRINT((ndo, \" Dense-mode\"));\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tND_PRINT((ndo, \" Sparse-mode\"));\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tND_PRINT((ndo, \" Sparse-Dense-mode\"));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tND_PRINT((ndo, \" mode-%d\", bp[8] >> 4));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ndo->ndo_vflag) {\n\t\t\tND_TCHECK2(bp[10],2);\n\t\t\tND_PRINT((ndo, \" (Hold-time \"));\n\t\t\tunsigned_relts_print(ndo, EXTRACT_16BITS(&bp[10]));\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t}\n\t\tbreak;\n\n\tcase PIMV1_TYPE_REGISTER:\n\t\tND_TCHECK2(bp[8], 20);\t\t\t/* ip header */\n\t\tND_PRINT((ndo, \" for %s > %s\", ipaddr_string(ndo, &bp[20]),\n\t\t    ipaddr_string(ndo, &bp[24])));\n\t\tbreak;\n\tcase PIMV1_TYPE_REGISTER_STOP:\n\t\tND_TCHECK2(bp[12], sizeof(struct in_addr));\n\t\tND_PRINT((ndo, \" for %s > %s\", ipaddr_string(ndo, &bp[8]),\n\t\t    ipaddr_string(ndo, &bp[12])));\n\t\tbreak;\n\tcase PIMV1_TYPE_RP_REACHABILITY:\n\t\tif (ndo->ndo_vflag) {\n\t\t\tND_TCHECK2(bp[22], 2);\n\t\t\tND_PRINT((ndo, \" group %s\", ipaddr_string(ndo, &bp[8])));\n\t\t\tif (EXTRACT_32BITS(&bp[12]) != 0xffffffff)\n\t\t\t\tND_PRINT((ndo, \"/%s\", ipaddr_string(ndo, &bp[12])));\n\t\t\tND_PRINT((ndo, \" RP %s hold \", ipaddr_string(ndo, &bp[16])));\n\t\t\tunsigned_relts_print(ndo, EXTRACT_16BITS(&bp[22]));\n\t\t}\n\t\tbreak;\n\tcase PIMV1_TYPE_ASSERT:\n\t\tND_TCHECK2(bp[16], sizeof(struct in_addr));\n\t\tND_PRINT((ndo, \" for %s > %s\", ipaddr_string(ndo, &bp[16]),\n\t\t    ipaddr_string(ndo, &bp[8])));\n\t\tif (EXTRACT_32BITS(&bp[12]) != 0xffffffff)\n\t\t\tND_PRINT((ndo, \"/%s\", ipaddr_string(ndo, &bp[12])));\n\t\tND_TCHECK2(bp[24], 4);\n\t\tND_PRINT((ndo, \" %s pref %d metric %d\",\n\t\t    (bp[20] & 0x80) ? \"RP-tree\" : \"SPT\",\n\t\tEXTRACT_32BITS(&bp[20]) & 0x7fffffff,\n\t\tEXTRACT_32BITS(&bp[24])));\n\t\tbreak;\n \tcase PIMV1_TYPE_JOIN_PRUNE:\n \tcase PIMV1_TYPE_GRAFT:\n \tcase PIMV1_TYPE_GRAFT_ACK:\n\t\tif (ndo->ndo_vflag)\n \t\t\tpimv1_join_prune_print(ndo, &bp[8], len - 8);\n \t\tbreak;\n \t}\n \tND_TCHECK(bp[4]);\n\tif ((bp[4] >> 4) != 1)\n\t\tND_PRINT((ndo, \" [v%d]\", bp[4] >> 4));\n\treturn;\n\ntrunc:\n\tND_PRINT((ndo, \"[|pim]\"));\n\treturn;\n}\n",
    "code_after_change": " pimv1_print(netdissect_options *ndo,\n             register const u_char *bp, register u_int len)\n {\n \tregister u_char type;\n \n \tND_TCHECK(bp[1]);\n \ttype = bp[1];\n \n\tND_PRINT((ndo, \" %s\", tok2str(pimv1_type_str, \"[type %u]\", type)));\n\tswitch (type) {\n\tcase PIMV1_TYPE_QUERY:\n\t\tif (ND_TTEST(bp[8])) {\n\t\t\tswitch (bp[8] >> 4) {\n\t\t\tcase 0:\n\t\t\t\tND_PRINT((ndo, \" Dense-mode\"));\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tND_PRINT((ndo, \" Sparse-mode\"));\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tND_PRINT((ndo, \" Sparse-Dense-mode\"));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tND_PRINT((ndo, \" mode-%d\", bp[8] >> 4));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ndo->ndo_vflag) {\n\t\t\tND_TCHECK2(bp[10],2);\n\t\t\tND_PRINT((ndo, \" (Hold-time \"));\n\t\t\tunsigned_relts_print(ndo, EXTRACT_16BITS(&bp[10]));\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t}\n\t\tbreak;\n\n\tcase PIMV1_TYPE_REGISTER:\n\t\tND_TCHECK2(bp[8], 20);\t\t\t/* ip header */\n\t\tND_PRINT((ndo, \" for %s > %s\", ipaddr_string(ndo, &bp[20]),\n\t\t    ipaddr_string(ndo, &bp[24])));\n\t\tbreak;\n\tcase PIMV1_TYPE_REGISTER_STOP:\n\t\tND_TCHECK2(bp[12], sizeof(struct in_addr));\n\t\tND_PRINT((ndo, \" for %s > %s\", ipaddr_string(ndo, &bp[8]),\n\t\t    ipaddr_string(ndo, &bp[12])));\n\t\tbreak;\n\tcase PIMV1_TYPE_RP_REACHABILITY:\n\t\tif (ndo->ndo_vflag) {\n\t\t\tND_TCHECK2(bp[22], 2);\n\t\t\tND_PRINT((ndo, \" group %s\", ipaddr_string(ndo, &bp[8])));\n\t\t\tif (EXTRACT_32BITS(&bp[12]) != 0xffffffff)\n\t\t\t\tND_PRINT((ndo, \"/%s\", ipaddr_string(ndo, &bp[12])));\n\t\t\tND_PRINT((ndo, \" RP %s hold \", ipaddr_string(ndo, &bp[16])));\n\t\t\tunsigned_relts_print(ndo, EXTRACT_16BITS(&bp[22]));\n\t\t}\n\t\tbreak;\n\tcase PIMV1_TYPE_ASSERT:\n\t\tND_TCHECK2(bp[16], sizeof(struct in_addr));\n\t\tND_PRINT((ndo, \" for %s > %s\", ipaddr_string(ndo, &bp[16]),\n\t\t    ipaddr_string(ndo, &bp[8])));\n\t\tif (EXTRACT_32BITS(&bp[12]) != 0xffffffff)\n\t\t\tND_PRINT((ndo, \"/%s\", ipaddr_string(ndo, &bp[12])));\n\t\tND_TCHECK2(bp[24], 4);\n\t\tND_PRINT((ndo, \" %s pref %d metric %d\",\n\t\t    (bp[20] & 0x80) ? \"RP-tree\" : \"SPT\",\n\t\tEXTRACT_32BITS(&bp[20]) & 0x7fffffff,\n\t\tEXTRACT_32BITS(&bp[24])));\n\t\tbreak;\n \tcase PIMV1_TYPE_JOIN_PRUNE:\n \tcase PIMV1_TYPE_GRAFT:\n \tcase PIMV1_TYPE_GRAFT_ACK:\n\t\tif (ndo->ndo_vflag) {\n\t\t\tif (len < 8)\n\t\t\t\tgoto trunc;\n \t\t\tpimv1_join_prune_print(ndo, &bp[8], len - 8);\n\t\t}\n \t\tbreak;\n \t}\n \tND_TCHECK(bp[4]);\n\tif ((bp[4] >> 4) != 1)\n\t\tND_PRINT((ndo, \" [v%d]\", bp[4] >> 4));\n\treturn;\n\ntrunc:\n\tND_PRINT((ndo, \"[|pim]\"));\n\treturn;\n}\n",
    "cwe": [
      "CWE-125"
    ],
    "id": 348,
    "_valid_cwes": [
      "CWE-125"
    ]
  },
  {
    "cve_id": "CVE-2017-13002",
    "code_before_change": "aodv_extension(netdissect_options *ndo,\n               const struct aodv_ext *ep, u_int length)\n {\n \tconst struct aodv_hello *ah;\n \n \tswitch (ep->type) {\n \tcase AODV_EXT_HELLO:\n \t\tah = (const struct aodv_hello *)(const void *)ep;\n \t\tND_TCHECK(*ah);\n \t\tif (length < sizeof(struct aodv_hello))\n \t\t\tgoto trunc;\n \t\tND_PRINT((ndo, \"\\n\\text HELLO %ld ms\",\n \t\t    (unsigned long)EXTRACT_32BITS(&ah->interval)));\n \t\tbreak;\n\n\tdefault:\n\t\tND_PRINT((ndo, \"\\n\\text %u %u\", ep->type, ep->length));\n\t\tbreak;\n\t}\n\treturn;\n\ntrunc:\n\tND_PRINT((ndo, \" [|hello]\"));\n}\n",
    "code_after_change": "aodv_extension(netdissect_options *ndo,\n               const struct aodv_ext *ep, u_int length)\n {\n \tconst struct aodv_hello *ah;\n \n\tND_TCHECK(*ep);\n \tswitch (ep->type) {\n \tcase AODV_EXT_HELLO:\n \t\tah = (const struct aodv_hello *)(const void *)ep;\n \t\tND_TCHECK(*ah);\n \t\tif (length < sizeof(struct aodv_hello))\n \t\t\tgoto trunc;\n\t\tif (ep->length < 4) {\n\t\t\tND_PRINT((ndo, \"\\n\\text HELLO - bad length %u\", ep->length));\n\t\t\tbreak;\n\t\t}\n \t\tND_PRINT((ndo, \"\\n\\text HELLO %ld ms\",\n \t\t    (unsigned long)EXTRACT_32BITS(&ah->interval)));\n \t\tbreak;\n\n\tdefault:\n\t\tND_PRINT((ndo, \"\\n\\text %u %u\", ep->type, ep->length));\n\t\tbreak;\n\t}\n\treturn;\n\ntrunc:\n\tND_PRINT((ndo, \" [|hello]\"));\n}\n",
    "cwe": [
      "CWE-125"
    ],
    "id": 378,
    "_valid_cwes": [
      "CWE-125"
    ]
  },
  {
    "cve_id": "CVE-2017-12996",
    "code_before_change": "pimv2_print(netdissect_options *ndo,\n            register const u_char *bp, register u_int len, const u_char *bp2)\n{\n\tregister const u_char *ep;\n\tregister const struct pim *pim = (const struct pim *)bp;\n\tint advance;\n\tenum checksum_status cksum_status;\n\n\tep = (const u_char *)ndo->ndo_snapend;\n\tif (bp >= ep)\n\t\treturn;\n\tif (ep > bp + len)\n\t\tep = bp + len;\n\tND_TCHECK(pim->pim_rsv);\n\tpimv2_addr_len = pim->pim_rsv;\n\tif (pimv2_addr_len != 0)\n\t\tND_PRINT((ndo, \", RFC2117-encoding\"));\n\n\tND_PRINT((ndo, \", cksum 0x%04x \", EXTRACT_16BITS(&pim->pim_cksum)));\n\tif (EXTRACT_16BITS(&pim->pim_cksum) == 0) {\n\t\tND_PRINT((ndo, \"(unverified)\"));\n\t} else {\n\t\tif (PIM_TYPE(pim->pim_typever) == PIMV2_TYPE_REGISTER) {\n\t\t\t/*\n\t\t\t * The checksum only covers the packet header,\n\t\t\t * not the encapsulated packet.\n\t\t\t */\n\t\t\tcksum_status = pimv2_check_checksum(ndo, bp, bp2, 8);\n\t\t\tif (cksum_status == INCORRECT) {\n\t\t\t\t/*\n\t\t\t\t * To quote RFC 4601, \"For interoperability\n\t\t\t\t * reasons, a message carrying a checksum\n\t\t\t\t * calculated over the entire PIM Register\n\t\t\t\t * message should also be accepted.\"\n\t\t\t\t */\n\t\t\t\tcksum_status = pimv2_check_checksum(ndo, bp, bp2, len);\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * The checksum covers the entire packet.\n\t\t\t */\n\t\t\tcksum_status = pimv2_check_checksum(ndo, bp, bp2, len);\n\t\t}\n\t\tswitch (cksum_status) {\n\n\t\tcase CORRECT:\n\t\t\tND_PRINT((ndo, \"(correct)\"));\n\t\t\tbreak;\n\n\t\tcase INCORRECT:\n\t\t\tND_PRINT((ndo, \"(incorrect)\"));\n\t\t\tbreak;\n\n\t\tcase UNVERIFIED:\n\t\t\tND_PRINT((ndo, \"(unverified)\"));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (PIM_TYPE(pim->pim_typever)) {\n\tcase PIMV2_TYPE_HELLO:\n\t    {\n\t\tuint16_t otype, olen;\n\t\tbp += 4;\n\t\twhile (bp < ep) {\n\t\t\tND_TCHECK2(bp[0], 4);\n\t\t\totype = EXTRACT_16BITS(&bp[0]);\n\t\t\tolen = EXTRACT_16BITS(&bp[2]);\n\t\t\tND_TCHECK2(bp[0], 4 + olen);\n\t\t\tND_PRINT((ndo, \"\\n\\t  %s Option (%u), length %u, Value: \",\n\t\t\t          tok2str(pimv2_hello_option_values, \"Unknown\", otype),\n\t\t\t          otype,\n\t\t\t          olen));\n\t\t\tbp += 4;\n \n \t\t\tswitch (otype) {\n \t\t\tcase PIMV2_HELLO_OPTION_HOLDTIME:\n\t\t\t\tunsigned_relts_print(ndo, EXTRACT_16BITS(bp));\n \t\t\t\tbreak;\n \n \t\t\tcase PIMV2_HELLO_OPTION_LANPRUNEDELAY:\n\t\t\t\tif (olen != 4) {\n\t\t\t\t\tND_PRINT((ndo, \"ERROR: Option Length != 4 Bytes (%u)\", olen));\n\t\t\t\t} else {\n\t\t\t\t\tchar t_bit;\n\t\t\t\t\tuint16_t lan_delay, override_interval;\n\t\t\t\t\tlan_delay = EXTRACT_16BITS(bp);\n\t\t\t\t\toverride_interval = EXTRACT_16BITS(bp+2);\n\t\t\t\t\tt_bit = (lan_delay & 0x8000)? 1 : 0;\n\t\t\t\t\tlan_delay &= ~0x8000;\n\t\t\t\t\tND_PRINT((ndo, \"\\n\\t    T-bit=%d, LAN delay %dms, Override interval %dms\",\n\t\t\t\t\tt_bit, lan_delay, override_interval));\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase PIMV2_HELLO_OPTION_DR_PRIORITY_OLD:\n\t\t\tcase PIMV2_HELLO_OPTION_DR_PRIORITY:\n\t\t\t\tswitch (olen) {\n\t\t\t\tcase 0:\n\t\t\t\t\tND_PRINT((ndo, \"Bi-Directional Capability (Old)\"));\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tND_PRINT((ndo, \"%u\", EXTRACT_32BITS(bp)));\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tND_PRINT((ndo, \"ERROR: Option Length != 4 Bytes (%u)\", olen));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n \t\t\t\tbreak;\n \n \t\t\tcase PIMV2_HELLO_OPTION_GENID:\n\t\t\t\tND_PRINT((ndo, \"0x%08x\", EXTRACT_32BITS(bp)));\n \t\t\t\tbreak;\n \n \t\t\tcase PIMV2_HELLO_OPTION_REFRESH_CAP:\n\t\t\t\tND_PRINT((ndo, \"v%d\", *bp));\n\t\t\t\tif (*(bp+1) != 0) {\n\t\t\t\t\tND_PRINT((ndo, \", interval \"));\n\t\t\t\t\tunsigned_relts_print(ndo, *(bp+1));\n\t\t\t\t}\n\t\t\t\tif (EXTRACT_16BITS(bp+2) != 0) {\n\t\t\t\t\tND_PRINT((ndo, \" ?0x%04x?\", EXTRACT_16BITS(bp+2)));\n \t\t\t\t}\n \t\t\t\tbreak;\n \n\t\t\tcase  PIMV2_HELLO_OPTION_BIDIR_CAP:\n\t\t\t\tbreak;\n\n\t\t\tcase PIMV2_HELLO_OPTION_ADDRESS_LIST_OLD:\n\t\t\tcase PIMV2_HELLO_OPTION_ADDRESS_LIST:\n\t\t\t\tif (ndo->ndo_vflag > 1) {\n\t\t\t\t\tconst u_char *ptr = bp;\n\t\t\t\t\twhile (ptr < (bp+olen)) {\n\t\t\t\t\t\tND_PRINT((ndo, \"\\n\\t    \"));\n\t\t\t\t\t\tadvance = pimv2_addr_print(ndo, ptr, pimv2_unicast, 0);\n\t\t\t\t\t\tif (advance < 0) {\n\t\t\t\t\t\t\tND_PRINT((ndo, \"...\"));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tptr += advance;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (ndo->ndo_vflag <= 1)\n\t\t\t\t\tprint_unknown_data(ndo, bp, \"\\n\\t    \", olen);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* do we want to see an additionally hexdump ? */\n\t\t\tif (ndo->ndo_vflag> 1)\n\t\t\t\tprint_unknown_data(ndo, bp, \"\\n\\t    \", olen);\n\t\t\tbp += olen;\n\t\t}\n\t\tbreak;\n\t    }\n\n\tcase PIMV2_TYPE_REGISTER:\n\t{\n\t\tconst struct ip *ip;\n\n\t\tND_TCHECK2(*(bp + 4), PIMV2_REGISTER_FLAG_LEN);\n\n\t\tND_PRINT((ndo, \", Flags [ %s ]\\n\\t\",\n\t\t          tok2str(pimv2_register_flag_values,\n\t\t          \"none\",\n\t\t          EXTRACT_32BITS(bp+4))));\n\n\t\tbp += 8; len -= 8;\n\t\t/* encapsulated multicast packet */\n\t\tip = (const struct ip *)bp;\n\t\tswitch (IP_V(ip)) {\n                case 0: /* Null header */\n\t\t\tND_PRINT((ndo, \"IP-Null-header %s > %s\",\n\t\t\t          ipaddr_string(ndo, &ip->ip_src),\n\t\t\t          ipaddr_string(ndo, &ip->ip_dst)));\n\t\t\tbreak;\n\n\t\tcase 4:\t/* IPv4 */\n\t\t\tip_print(ndo, bp, len);\n\t\t\tbreak;\n\n\t\tcase 6:\t/* IPv6 */\n\t\t\tip6_print(ndo, bp, len);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tND_PRINT((ndo, \"IP ver %d\", IP_V(ip)));\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase PIMV2_TYPE_REGISTER_STOP:\n\t\tbp += 4; len -= 4;\n\t\tif (bp >= ep)\n\t\t\tbreak;\n\t\tND_PRINT((ndo, \" group=\"));\n\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_group, 0)) < 0) {\n\t\t\tND_PRINT((ndo, \"...\"));\n\t\t\tbreak;\n\t\t}\n\t\tbp += advance; len -= advance;\n\t\tif (bp >= ep)\n\t\t\tbreak;\n\t\tND_PRINT((ndo, \" source=\"));\n\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_unicast, 0)) < 0) {\n\t\t\tND_PRINT((ndo, \"...\"));\n\t\t\tbreak;\n\t\t}\n\t\tbp += advance; len -= advance;\n\t\tbreak;\n\n\tcase PIMV2_TYPE_JOIN_PRUNE:\n\tcase PIMV2_TYPE_GRAFT:\n\tcase PIMV2_TYPE_GRAFT_ACK:\n\n\n        /*\n         * 0                   1                   2                   3\n         *   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         *  |PIM Ver| Type  | Addr length   |           Checksum            |\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         *  |             Unicast-Upstream Neighbor Address                 |\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         *  |  Reserved     | Num groups    |          Holdtime             |\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         *  |            Encoded-Multicast Group Address-1                  |\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         *  |   Number of Joined  Sources   |   Number of Pruned Sources    |\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         *  |               Encoded-Joined Source Address-1                 |\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         *  |                             .                                 |\n         *  |                             .                                 |\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         *  |               Encoded-Joined Source Address-n                 |\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         *  |               Encoded-Pruned Source Address-1                 |\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         *  |                             .                                 |\n         *  |                             .                                 |\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         *  |               Encoded-Pruned Source Address-n                 |\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         *  |                           .                                   |\n         *  |                           .                                   |\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         *  |                Encoded-Multicast Group Address-n              |\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         */\n\n\t    {\n\t\tuint8_t ngroup;\n\t\tuint16_t holdtime;\n\t\tuint16_t njoin;\n\t\tuint16_t nprune;\n\t\tint i, j;\n\n\t\tbp += 4; len -= 4;\n\t\tif (PIM_TYPE(pim->pim_typever) != 7) {\t/*not for Graft-ACK*/\n\t\t\tif (bp >= ep)\n\t\t\t\tbreak;\n\t\t\tND_PRINT((ndo, \", upstream-neighbor: \"));\n\t\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_unicast, 0)) < 0) {\n\t\t\t\tND_PRINT((ndo, \"...\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbp += advance; len -= advance;\n\t\t}\n\t\tif (bp + 4 > ep)\n\t\t\tbreak;\n\t\tngroup = bp[1];\n\t\tholdtime = EXTRACT_16BITS(&bp[2]);\n\t\tND_PRINT((ndo, \"\\n\\t  %u group(s)\", ngroup));\n\t\tif (PIM_TYPE(pim->pim_typever) != 7) {\t/*not for Graft-ACK*/\n\t\t\tND_PRINT((ndo, \", holdtime: \"));\n\t\t\tif (holdtime == 0xffff)\n\t\t\t\tND_PRINT((ndo, \"infinite\"));\n\t\t\telse\n\t\t\t\tunsigned_relts_print(ndo, holdtime);\n\t\t}\n\t\tbp += 4; len -= 4;\n\t\tfor (i = 0; i < ngroup; i++) {\n\t\t\tif (bp >= ep)\n\t\t\t\tgoto jp_done;\n\t\t\tND_PRINT((ndo, \"\\n\\t    group #%u: \", i+1));\n\t\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_group, 0)) < 0) {\n\t\t\t\tND_PRINT((ndo, \"...)\"));\n\t\t\t\tgoto jp_done;\n\t\t\t}\n\t\t\tbp += advance; len -= advance;\n\t\t\tif (bp + 4 > ep) {\n\t\t\t\tND_PRINT((ndo, \"...)\"));\n\t\t\t\tgoto jp_done;\n\t\t\t}\n\t\t\tnjoin = EXTRACT_16BITS(&bp[0]);\n\t\t\tnprune = EXTRACT_16BITS(&bp[2]);\n\t\t\tND_PRINT((ndo, \", joined sources: %u, pruned sources: %u\", njoin, nprune));\n\t\t\tbp += 4; len -= 4;\n\t\t\tfor (j = 0; j < njoin; j++) {\n\t\t\t\tND_PRINT((ndo, \"\\n\\t      joined source #%u: \", j+1));\n\t\t\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_source, 0)) < 0) {\n\t\t\t\t\tND_PRINT((ndo, \"...)\"));\n\t\t\t\t\tgoto jp_done;\n\t\t\t\t}\n\t\t\t\tbp += advance; len -= advance;\n\t\t\t}\n\t\t\tfor (j = 0; j < nprune; j++) {\n\t\t\t\tND_PRINT((ndo, \"\\n\\t      pruned source #%u: \", j+1));\n\t\t\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_source, 0)) < 0) {\n\t\t\t\t\tND_PRINT((ndo, \"...)\"));\n\t\t\t\t\tgoto jp_done;\n\t\t\t\t}\n\t\t\t\tbp += advance; len -= advance;\n\t\t\t}\n\t\t}\n\tjp_done:\n\t\tbreak;\n\t    }\n\n\tcase PIMV2_TYPE_BOOTSTRAP:\n\t{\n\t\tint i, j, frpcnt;\n\t\tbp += 4;\n\n\t\t/* Fragment Tag, Hash Mask len, and BSR-priority */\n\t\tif (bp + sizeof(uint16_t) >= ep) break;\n\t\tND_PRINT((ndo, \" tag=%x\", EXTRACT_16BITS(bp)));\n\t\tbp += sizeof(uint16_t);\n\t\tif (bp >= ep) break;\n\t\tND_PRINT((ndo, \" hashmlen=%d\", bp[0]));\n\t\tif (bp + 1 >= ep) break;\n\t\tND_PRINT((ndo, \" BSRprio=%d\", bp[1]));\n\t\tbp += 2;\n\n\t\t/* Encoded-Unicast-BSR-Address */\n\t\tif (bp >= ep) break;\n\t\tND_PRINT((ndo, \" BSR=\"));\n\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_unicast, 0)) < 0) {\n\t\t\tND_PRINT((ndo, \"...\"));\n\t\t\tbreak;\n\t\t}\n\t\tbp += advance;\n\n\t\tfor (i = 0; bp < ep; i++) {\n\t\t\t/* Encoded-Group Address */\n\t\t\tND_PRINT((ndo, \" (group%d: \", i));\n\t\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_group, 0))\n\t\t\t    < 0) {\n\t\t\t\tND_PRINT((ndo, \"...)\"));\n\t\t\t\tgoto bs_done;\n\t\t\t}\n\t\t\tbp += advance;\n\n\t\t\t/* RP-Count, Frag RP-Cnt, and rsvd */\n\t\t\tif (bp >= ep) {\n\t\t\t\tND_PRINT((ndo, \"...)\"));\n\t\t\t\tgoto bs_done;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \" RPcnt=%d\", bp[0]));\n\t\t\tif (bp + 1 >= ep) {\n\t\t\t\tND_PRINT((ndo, \"...)\"));\n\t\t\t\tgoto bs_done;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \" FRPcnt=%d\", frpcnt = bp[1]));\n\t\t\tbp += 4;\n\n\t\t\tfor (j = 0; j < frpcnt && bp < ep; j++) {\n\t\t\t\t/* each RP info */\n\t\t\t\tND_PRINT((ndo, \" RP%d=\", j));\n\t\t\t\tif ((advance = pimv2_addr_print(ndo, bp,\n\t\t\t\t\t\t\t\tpimv2_unicast,\n\t\t\t\t\t\t\t\t0)) < 0) {\n\t\t\t\t\tND_PRINT((ndo, \"...)\"));\n\t\t\t\t\tgoto bs_done;\n\t\t\t\t}\n\t\t\t\tbp += advance;\n\n\t\t\t\tif (bp + 1 >= ep) {\n\t\t\t\t\tND_PRINT((ndo, \"...)\"));\n\t\t\t\t\tgoto bs_done;\n\t\t\t\t}\n\t\t\t\tND_PRINT((ndo, \",holdtime=\"));\n\t\t\t\tunsigned_relts_print(ndo, EXTRACT_16BITS(bp));\n\t\t\t\tif (bp + 2 >= ep) {\n\t\t\t\t\tND_PRINT((ndo, \"...)\"));\n\t\t\t\t\tgoto bs_done;\n\t\t\t\t}\n\t\t\t\tND_PRINT((ndo, \",prio=%d\", bp[2]));\n\t\t\t\tbp += 4;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t}\n\t   bs_done:\n\t\tbreak;\n\t}\n\tcase PIMV2_TYPE_ASSERT:\n\t\tbp += 4; len -= 4;\n\t\tif (bp >= ep)\n\t\t\tbreak;\n\t\tND_PRINT((ndo, \" group=\"));\n\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_group, 0)) < 0) {\n\t\t\tND_PRINT((ndo, \"...\"));\n\t\t\tbreak;\n\t\t}\n\t\tbp += advance; len -= advance;\n\t\tif (bp >= ep)\n\t\t\tbreak;\n\t\tND_PRINT((ndo, \" src=\"));\n\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_unicast, 0)) < 0) {\n\t\t\tND_PRINT((ndo, \"...\"));\n\t\t\tbreak;\n\t\t}\n\t\tbp += advance; len -= advance;\n\t\tif (bp + 8 > ep)\n\t\t\tbreak;\n\t\tif (bp[0] & 0x80)\n\t\t\tND_PRINT((ndo, \" RPT\"));\n\t\tND_PRINT((ndo, \" pref=%u\", EXTRACT_32BITS(&bp[0]) & 0x7fffffff));\n\t\tND_PRINT((ndo, \" metric=%u\", EXTRACT_32BITS(&bp[4])));\n\t\tbreak;\n\n\tcase PIMV2_TYPE_CANDIDATE_RP:\n\t{\n\t\tint i, pfxcnt;\n\t\tbp += 4;\n\n\t\t/* Prefix-Cnt, Priority, and Holdtime */\n\t\tif (bp >= ep) break;\n\t\tND_PRINT((ndo, \" prefix-cnt=%d\", bp[0]));\n\t\tpfxcnt = bp[0];\n\t\tif (bp + 1 >= ep) break;\n\t\tND_PRINT((ndo, \" prio=%d\", bp[1]));\n\t\tif (bp + 3 >= ep) break;\n\t\tND_PRINT((ndo, \" holdtime=\"));\n\t\tunsigned_relts_print(ndo, EXTRACT_16BITS(&bp[2]));\n\t\tbp += 4;\n\n\t\t/* Encoded-Unicast-RP-Address */\n\t\tif (bp >= ep) break;\n\t\tND_PRINT((ndo, \" RP=\"));\n\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_unicast, 0)) < 0) {\n\t\t\tND_PRINT((ndo, \"...\"));\n\t\t\tbreak;\n\t\t}\n\t\tbp += advance;\n\n\t\t/* Encoded-Group Addresses */\n\t\tfor (i = 0; i < pfxcnt && bp < ep; i++) {\n\t\t\tND_PRINT((ndo, \" Group%d=\", i));\n\t\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_group, 0))\n\t\t\t    < 0) {\n\t\t\t\tND_PRINT((ndo, \"...\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbp += advance;\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase PIMV2_TYPE_PRUNE_REFRESH:\n\t\tND_PRINT((ndo, \" src=\"));\n\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_unicast, 0)) < 0) {\n\t\t\tND_PRINT((ndo, \"...\"));\n\t\t\tbreak;\n\t\t}\n\t\tbp += advance;\n\t\tND_PRINT((ndo, \" grp=\"));\n\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_group, 0)) < 0) {\n\t\t\tND_PRINT((ndo, \"...\"));\n\t\t\tbreak;\n\t\t}\n\t\tbp += advance;\n\t\tND_PRINT((ndo, \" forwarder=\"));\n\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_unicast, 0)) < 0) {\n\t\t\tND_PRINT((ndo, \"...\"));\n\t\t\tbreak;\n\t\t}\n\t\tbp += advance;\n\t\tND_TCHECK2(bp[0], 2);\n\t\tND_PRINT((ndo, \" TUNR \"));\n\t\tunsigned_relts_print(ndo, EXTRACT_16BITS(bp));\n\t\tbreak;\n\n\n\t default:\n\t\tND_PRINT((ndo, \" [type %d]\", PIM_TYPE(pim->pim_typever)));\n\t\tbreak;\n\t}\n\n\treturn;\n\ntrunc:\n\tND_PRINT((ndo, \"[|pim]\"));\n}\n",
    "code_after_change": "pimv2_print(netdissect_options *ndo,\n            register const u_char *bp, register u_int len, const u_char *bp2)\n{\n\tregister const u_char *ep;\n\tregister const struct pim *pim = (const struct pim *)bp;\n\tint advance;\n\tenum checksum_status cksum_status;\n\n\tep = (const u_char *)ndo->ndo_snapend;\n\tif (bp >= ep)\n\t\treturn;\n\tif (ep > bp + len)\n\t\tep = bp + len;\n\tND_TCHECK(pim->pim_rsv);\n\tpimv2_addr_len = pim->pim_rsv;\n\tif (pimv2_addr_len != 0)\n\t\tND_PRINT((ndo, \", RFC2117-encoding\"));\n\n\tND_PRINT((ndo, \", cksum 0x%04x \", EXTRACT_16BITS(&pim->pim_cksum)));\n\tif (EXTRACT_16BITS(&pim->pim_cksum) == 0) {\n\t\tND_PRINT((ndo, \"(unverified)\"));\n\t} else {\n\t\tif (PIM_TYPE(pim->pim_typever) == PIMV2_TYPE_REGISTER) {\n\t\t\t/*\n\t\t\t * The checksum only covers the packet header,\n\t\t\t * not the encapsulated packet.\n\t\t\t */\n\t\t\tcksum_status = pimv2_check_checksum(ndo, bp, bp2, 8);\n\t\t\tif (cksum_status == INCORRECT) {\n\t\t\t\t/*\n\t\t\t\t * To quote RFC 4601, \"For interoperability\n\t\t\t\t * reasons, a message carrying a checksum\n\t\t\t\t * calculated over the entire PIM Register\n\t\t\t\t * message should also be accepted.\"\n\t\t\t\t */\n\t\t\t\tcksum_status = pimv2_check_checksum(ndo, bp, bp2, len);\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * The checksum covers the entire packet.\n\t\t\t */\n\t\t\tcksum_status = pimv2_check_checksum(ndo, bp, bp2, len);\n\t\t}\n\t\tswitch (cksum_status) {\n\n\t\tcase CORRECT:\n\t\t\tND_PRINT((ndo, \"(correct)\"));\n\t\t\tbreak;\n\n\t\tcase INCORRECT:\n\t\t\tND_PRINT((ndo, \"(incorrect)\"));\n\t\t\tbreak;\n\n\t\tcase UNVERIFIED:\n\t\t\tND_PRINT((ndo, \"(unverified)\"));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (PIM_TYPE(pim->pim_typever)) {\n\tcase PIMV2_TYPE_HELLO:\n\t    {\n\t\tuint16_t otype, olen;\n\t\tbp += 4;\n\t\twhile (bp < ep) {\n\t\t\tND_TCHECK2(bp[0], 4);\n\t\t\totype = EXTRACT_16BITS(&bp[0]);\n\t\t\tolen = EXTRACT_16BITS(&bp[2]);\n\t\t\tND_TCHECK2(bp[0], 4 + olen);\n\t\t\tND_PRINT((ndo, \"\\n\\t  %s Option (%u), length %u, Value: \",\n\t\t\t          tok2str(pimv2_hello_option_values, \"Unknown\", otype),\n\t\t\t          otype,\n\t\t\t          olen));\n\t\t\tbp += 4;\n \n \t\t\tswitch (otype) {\n \t\t\tcase PIMV2_HELLO_OPTION_HOLDTIME:\n\t\t\t\tif (olen != 2) {\n\t\t\t\t\tND_PRINT((ndo, \"ERROR: Option Length != 2 Bytes (%u)\", olen));\n\t\t\t\t} else {\n\t\t\t\t\tunsigned_relts_print(ndo, EXTRACT_16BITS(bp));\n\t\t\t\t}\n \t\t\t\tbreak;\n \n \t\t\tcase PIMV2_HELLO_OPTION_LANPRUNEDELAY:\n\t\t\t\tif (olen != 4) {\n\t\t\t\t\tND_PRINT((ndo, \"ERROR: Option Length != 4 Bytes (%u)\", olen));\n\t\t\t\t} else {\n\t\t\t\t\tchar t_bit;\n\t\t\t\t\tuint16_t lan_delay, override_interval;\n\t\t\t\t\tlan_delay = EXTRACT_16BITS(bp);\n\t\t\t\t\toverride_interval = EXTRACT_16BITS(bp+2);\n\t\t\t\t\tt_bit = (lan_delay & 0x8000)? 1 : 0;\n\t\t\t\t\tlan_delay &= ~0x8000;\n\t\t\t\t\tND_PRINT((ndo, \"\\n\\t    T-bit=%d, LAN delay %dms, Override interval %dms\",\n\t\t\t\t\tt_bit, lan_delay, override_interval));\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase PIMV2_HELLO_OPTION_DR_PRIORITY_OLD:\n\t\t\tcase PIMV2_HELLO_OPTION_DR_PRIORITY:\n\t\t\t\tswitch (olen) {\n\t\t\t\tcase 0:\n\t\t\t\t\tND_PRINT((ndo, \"Bi-Directional Capability (Old)\"));\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tND_PRINT((ndo, \"%u\", EXTRACT_32BITS(bp)));\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tND_PRINT((ndo, \"ERROR: Option Length != 4 Bytes (%u)\", olen));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n \t\t\t\tbreak;\n \n \t\t\tcase PIMV2_HELLO_OPTION_GENID:\n\t\t\t\tif (olen != 4) {\n\t\t\t\t\tND_PRINT((ndo, \"ERROR: Option Length != 4 Bytes (%u)\", olen));\n\t\t\t\t} else {\n\t\t\t\t\tND_PRINT((ndo, \"0x%08x\", EXTRACT_32BITS(bp)));\n\t\t\t\t}\n \t\t\t\tbreak;\n \n \t\t\tcase PIMV2_HELLO_OPTION_REFRESH_CAP:\n\t\t\t\tif (olen != 4) {\n\t\t\t\t\tND_PRINT((ndo, \"ERROR: Option Length != 4 Bytes (%u)\", olen));\n\t\t\t\t} else {\n\t\t\t\t\tND_PRINT((ndo, \"v%d\", *bp));\n\t\t\t\t\tif (*(bp+1) != 0) {\n\t\t\t\t\t\tND_PRINT((ndo, \", interval \"));\n\t\t\t\t\t\tunsigned_relts_print(ndo, *(bp+1));\n\t\t\t\t\t}\n\t\t\t\t\tif (EXTRACT_16BITS(bp+2) != 0) {\n\t\t\t\t\t\tND_PRINT((ndo, \" ?0x%04x?\", EXTRACT_16BITS(bp+2)));\n\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tbreak;\n \n\t\t\tcase  PIMV2_HELLO_OPTION_BIDIR_CAP:\n\t\t\t\tbreak;\n\n\t\t\tcase PIMV2_HELLO_OPTION_ADDRESS_LIST_OLD:\n\t\t\tcase PIMV2_HELLO_OPTION_ADDRESS_LIST:\n\t\t\t\tif (ndo->ndo_vflag > 1) {\n\t\t\t\t\tconst u_char *ptr = bp;\n\t\t\t\t\twhile (ptr < (bp+olen)) {\n\t\t\t\t\t\tND_PRINT((ndo, \"\\n\\t    \"));\n\t\t\t\t\t\tadvance = pimv2_addr_print(ndo, ptr, pimv2_unicast, 0);\n\t\t\t\t\t\tif (advance < 0) {\n\t\t\t\t\t\t\tND_PRINT((ndo, \"...\"));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tptr += advance;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (ndo->ndo_vflag <= 1)\n\t\t\t\t\tprint_unknown_data(ndo, bp, \"\\n\\t    \", olen);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* do we want to see an additionally hexdump ? */\n\t\t\tif (ndo->ndo_vflag> 1)\n\t\t\t\tprint_unknown_data(ndo, bp, \"\\n\\t    \", olen);\n\t\t\tbp += olen;\n\t\t}\n\t\tbreak;\n\t    }\n\n\tcase PIMV2_TYPE_REGISTER:\n\t{\n\t\tconst struct ip *ip;\n\n\t\tND_TCHECK2(*(bp + 4), PIMV2_REGISTER_FLAG_LEN);\n\n\t\tND_PRINT((ndo, \", Flags [ %s ]\\n\\t\",\n\t\t          tok2str(pimv2_register_flag_values,\n\t\t          \"none\",\n\t\t          EXTRACT_32BITS(bp+4))));\n\n\t\tbp += 8; len -= 8;\n\t\t/* encapsulated multicast packet */\n\t\tip = (const struct ip *)bp;\n\t\tswitch (IP_V(ip)) {\n                case 0: /* Null header */\n\t\t\tND_PRINT((ndo, \"IP-Null-header %s > %s\",\n\t\t\t          ipaddr_string(ndo, &ip->ip_src),\n\t\t\t          ipaddr_string(ndo, &ip->ip_dst)));\n\t\t\tbreak;\n\n\t\tcase 4:\t/* IPv4 */\n\t\t\tip_print(ndo, bp, len);\n\t\t\tbreak;\n\n\t\tcase 6:\t/* IPv6 */\n\t\t\tip6_print(ndo, bp, len);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tND_PRINT((ndo, \"IP ver %d\", IP_V(ip)));\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase PIMV2_TYPE_REGISTER_STOP:\n\t\tbp += 4; len -= 4;\n\t\tif (bp >= ep)\n\t\t\tbreak;\n\t\tND_PRINT((ndo, \" group=\"));\n\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_group, 0)) < 0) {\n\t\t\tND_PRINT((ndo, \"...\"));\n\t\t\tbreak;\n\t\t}\n\t\tbp += advance; len -= advance;\n\t\tif (bp >= ep)\n\t\t\tbreak;\n\t\tND_PRINT((ndo, \" source=\"));\n\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_unicast, 0)) < 0) {\n\t\t\tND_PRINT((ndo, \"...\"));\n\t\t\tbreak;\n\t\t}\n\t\tbp += advance; len -= advance;\n\t\tbreak;\n\n\tcase PIMV2_TYPE_JOIN_PRUNE:\n\tcase PIMV2_TYPE_GRAFT:\n\tcase PIMV2_TYPE_GRAFT_ACK:\n\n\n        /*\n         * 0                   1                   2                   3\n         *   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         *  |PIM Ver| Type  | Addr length   |           Checksum            |\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         *  |             Unicast-Upstream Neighbor Address                 |\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         *  |  Reserved     | Num groups    |          Holdtime             |\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         *  |            Encoded-Multicast Group Address-1                  |\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         *  |   Number of Joined  Sources   |   Number of Pruned Sources    |\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         *  |               Encoded-Joined Source Address-1                 |\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         *  |                             .                                 |\n         *  |                             .                                 |\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         *  |               Encoded-Joined Source Address-n                 |\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         *  |               Encoded-Pruned Source Address-1                 |\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         *  |                             .                                 |\n         *  |                             .                                 |\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         *  |               Encoded-Pruned Source Address-n                 |\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         *  |                           .                                   |\n         *  |                           .                                   |\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         *  |                Encoded-Multicast Group Address-n              |\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         */\n\n\t    {\n\t\tuint8_t ngroup;\n\t\tuint16_t holdtime;\n\t\tuint16_t njoin;\n\t\tuint16_t nprune;\n\t\tint i, j;\n\n\t\tbp += 4; len -= 4;\n\t\tif (PIM_TYPE(pim->pim_typever) != 7) {\t/*not for Graft-ACK*/\n\t\t\tif (bp >= ep)\n\t\t\t\tbreak;\n\t\t\tND_PRINT((ndo, \", upstream-neighbor: \"));\n\t\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_unicast, 0)) < 0) {\n\t\t\t\tND_PRINT((ndo, \"...\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbp += advance; len -= advance;\n\t\t}\n\t\tif (bp + 4 > ep)\n\t\t\tbreak;\n\t\tngroup = bp[1];\n\t\tholdtime = EXTRACT_16BITS(&bp[2]);\n\t\tND_PRINT((ndo, \"\\n\\t  %u group(s)\", ngroup));\n\t\tif (PIM_TYPE(pim->pim_typever) != 7) {\t/*not for Graft-ACK*/\n\t\t\tND_PRINT((ndo, \", holdtime: \"));\n\t\t\tif (holdtime == 0xffff)\n\t\t\t\tND_PRINT((ndo, \"infinite\"));\n\t\t\telse\n\t\t\t\tunsigned_relts_print(ndo, holdtime);\n\t\t}\n\t\tbp += 4; len -= 4;\n\t\tfor (i = 0; i < ngroup; i++) {\n\t\t\tif (bp >= ep)\n\t\t\t\tgoto jp_done;\n\t\t\tND_PRINT((ndo, \"\\n\\t    group #%u: \", i+1));\n\t\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_group, 0)) < 0) {\n\t\t\t\tND_PRINT((ndo, \"...)\"));\n\t\t\t\tgoto jp_done;\n\t\t\t}\n\t\t\tbp += advance; len -= advance;\n\t\t\tif (bp + 4 > ep) {\n\t\t\t\tND_PRINT((ndo, \"...)\"));\n\t\t\t\tgoto jp_done;\n\t\t\t}\n\t\t\tnjoin = EXTRACT_16BITS(&bp[0]);\n\t\t\tnprune = EXTRACT_16BITS(&bp[2]);\n\t\t\tND_PRINT((ndo, \", joined sources: %u, pruned sources: %u\", njoin, nprune));\n\t\t\tbp += 4; len -= 4;\n\t\t\tfor (j = 0; j < njoin; j++) {\n\t\t\t\tND_PRINT((ndo, \"\\n\\t      joined source #%u: \", j+1));\n\t\t\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_source, 0)) < 0) {\n\t\t\t\t\tND_PRINT((ndo, \"...)\"));\n\t\t\t\t\tgoto jp_done;\n\t\t\t\t}\n\t\t\t\tbp += advance; len -= advance;\n\t\t\t}\n\t\t\tfor (j = 0; j < nprune; j++) {\n\t\t\t\tND_PRINT((ndo, \"\\n\\t      pruned source #%u: \", j+1));\n\t\t\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_source, 0)) < 0) {\n\t\t\t\t\tND_PRINT((ndo, \"...)\"));\n\t\t\t\t\tgoto jp_done;\n\t\t\t\t}\n\t\t\t\tbp += advance; len -= advance;\n\t\t\t}\n\t\t}\n\tjp_done:\n\t\tbreak;\n\t    }\n\n\tcase PIMV2_TYPE_BOOTSTRAP:\n\t{\n\t\tint i, j, frpcnt;\n\t\tbp += 4;\n\n\t\t/* Fragment Tag, Hash Mask len, and BSR-priority */\n\t\tif (bp + sizeof(uint16_t) >= ep) break;\n\t\tND_PRINT((ndo, \" tag=%x\", EXTRACT_16BITS(bp)));\n\t\tbp += sizeof(uint16_t);\n\t\tif (bp >= ep) break;\n\t\tND_PRINT((ndo, \" hashmlen=%d\", bp[0]));\n\t\tif (bp + 1 >= ep) break;\n\t\tND_PRINT((ndo, \" BSRprio=%d\", bp[1]));\n\t\tbp += 2;\n\n\t\t/* Encoded-Unicast-BSR-Address */\n\t\tif (bp >= ep) break;\n\t\tND_PRINT((ndo, \" BSR=\"));\n\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_unicast, 0)) < 0) {\n\t\t\tND_PRINT((ndo, \"...\"));\n\t\t\tbreak;\n\t\t}\n\t\tbp += advance;\n\n\t\tfor (i = 0; bp < ep; i++) {\n\t\t\t/* Encoded-Group Address */\n\t\t\tND_PRINT((ndo, \" (group%d: \", i));\n\t\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_group, 0))\n\t\t\t    < 0) {\n\t\t\t\tND_PRINT((ndo, \"...)\"));\n\t\t\t\tgoto bs_done;\n\t\t\t}\n\t\t\tbp += advance;\n\n\t\t\t/* RP-Count, Frag RP-Cnt, and rsvd */\n\t\t\tif (bp >= ep) {\n\t\t\t\tND_PRINT((ndo, \"...)\"));\n\t\t\t\tgoto bs_done;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \" RPcnt=%d\", bp[0]));\n\t\t\tif (bp + 1 >= ep) {\n\t\t\t\tND_PRINT((ndo, \"...)\"));\n\t\t\t\tgoto bs_done;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \" FRPcnt=%d\", frpcnt = bp[1]));\n\t\t\tbp += 4;\n\n\t\t\tfor (j = 0; j < frpcnt && bp < ep; j++) {\n\t\t\t\t/* each RP info */\n\t\t\t\tND_PRINT((ndo, \" RP%d=\", j));\n\t\t\t\tif ((advance = pimv2_addr_print(ndo, bp,\n\t\t\t\t\t\t\t\tpimv2_unicast,\n\t\t\t\t\t\t\t\t0)) < 0) {\n\t\t\t\t\tND_PRINT((ndo, \"...)\"));\n\t\t\t\t\tgoto bs_done;\n\t\t\t\t}\n\t\t\t\tbp += advance;\n\n\t\t\t\tif (bp + 1 >= ep) {\n\t\t\t\t\tND_PRINT((ndo, \"...)\"));\n\t\t\t\t\tgoto bs_done;\n\t\t\t\t}\n\t\t\t\tND_PRINT((ndo, \",holdtime=\"));\n\t\t\t\tunsigned_relts_print(ndo, EXTRACT_16BITS(bp));\n\t\t\t\tif (bp + 2 >= ep) {\n\t\t\t\t\tND_PRINT((ndo, \"...)\"));\n\t\t\t\t\tgoto bs_done;\n\t\t\t\t}\n\t\t\t\tND_PRINT((ndo, \",prio=%d\", bp[2]));\n\t\t\t\tbp += 4;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t}\n\t   bs_done:\n\t\tbreak;\n\t}\n\tcase PIMV2_TYPE_ASSERT:\n\t\tbp += 4; len -= 4;\n\t\tif (bp >= ep)\n\t\t\tbreak;\n\t\tND_PRINT((ndo, \" group=\"));\n\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_group, 0)) < 0) {\n\t\t\tND_PRINT((ndo, \"...\"));\n\t\t\tbreak;\n\t\t}\n\t\tbp += advance; len -= advance;\n\t\tif (bp >= ep)\n\t\t\tbreak;\n\t\tND_PRINT((ndo, \" src=\"));\n\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_unicast, 0)) < 0) {\n\t\t\tND_PRINT((ndo, \"...\"));\n\t\t\tbreak;\n\t\t}\n\t\tbp += advance; len -= advance;\n\t\tif (bp + 8 > ep)\n\t\t\tbreak;\n\t\tif (bp[0] & 0x80)\n\t\t\tND_PRINT((ndo, \" RPT\"));\n\t\tND_PRINT((ndo, \" pref=%u\", EXTRACT_32BITS(&bp[0]) & 0x7fffffff));\n\t\tND_PRINT((ndo, \" metric=%u\", EXTRACT_32BITS(&bp[4])));\n\t\tbreak;\n\n\tcase PIMV2_TYPE_CANDIDATE_RP:\n\t{\n\t\tint i, pfxcnt;\n\t\tbp += 4;\n\n\t\t/* Prefix-Cnt, Priority, and Holdtime */\n\t\tif (bp >= ep) break;\n\t\tND_PRINT((ndo, \" prefix-cnt=%d\", bp[0]));\n\t\tpfxcnt = bp[0];\n\t\tif (bp + 1 >= ep) break;\n\t\tND_PRINT((ndo, \" prio=%d\", bp[1]));\n\t\tif (bp + 3 >= ep) break;\n\t\tND_PRINT((ndo, \" holdtime=\"));\n\t\tunsigned_relts_print(ndo, EXTRACT_16BITS(&bp[2]));\n\t\tbp += 4;\n\n\t\t/* Encoded-Unicast-RP-Address */\n\t\tif (bp >= ep) break;\n\t\tND_PRINT((ndo, \" RP=\"));\n\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_unicast, 0)) < 0) {\n\t\t\tND_PRINT((ndo, \"...\"));\n\t\t\tbreak;\n\t\t}\n\t\tbp += advance;\n\n\t\t/* Encoded-Group Addresses */\n\t\tfor (i = 0; i < pfxcnt && bp < ep; i++) {\n\t\t\tND_PRINT((ndo, \" Group%d=\", i));\n\t\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_group, 0))\n\t\t\t    < 0) {\n\t\t\t\tND_PRINT((ndo, \"...\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbp += advance;\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase PIMV2_TYPE_PRUNE_REFRESH:\n\t\tND_PRINT((ndo, \" src=\"));\n\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_unicast, 0)) < 0) {\n\t\t\tND_PRINT((ndo, \"...\"));\n\t\t\tbreak;\n\t\t}\n\t\tbp += advance;\n\t\tND_PRINT((ndo, \" grp=\"));\n\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_group, 0)) < 0) {\n\t\t\tND_PRINT((ndo, \"...\"));\n\t\t\tbreak;\n\t\t}\n\t\tbp += advance;\n\t\tND_PRINT((ndo, \" forwarder=\"));\n\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_unicast, 0)) < 0) {\n\t\t\tND_PRINT((ndo, \"...\"));\n\t\t\tbreak;\n\t\t}\n\t\tbp += advance;\n\t\tND_TCHECK2(bp[0], 2);\n\t\tND_PRINT((ndo, \" TUNR \"));\n\t\tunsigned_relts_print(ndo, EXTRACT_16BITS(bp));\n\t\tbreak;\n\n\n\t default:\n\t\tND_PRINT((ndo, \" [type %d]\", PIM_TYPE(pim->pim_typever)));\n\t\tbreak;\n\t}\n\n\treturn;\n\ntrunc:\n\tND_PRINT((ndo, \"[|pim]\"));\n}\n",
    "cwe": [
      "CWE-125"
    ],
    "id": 390,
    "_valid_cwes": [
      "CWE-125"
    ]
  },
  {
    "cve_id": "CVE-2018-1999015",
    "code_before_change": "static void read_quant_matrix_ext(MpegEncContext *s, GetBitContext *gb)\n {\n     int i, j, v;\n \n     if (get_bits1(gb)) {\n         /* intra_quantiser_matrix */\n         for (i = 0; i < 64; i++) {\n             v = get_bits(gb, 8);\n            j = s->idsp.idct_permutation[ff_zigzag_direct[i]];\n            s->intra_matrix[j]        = v;\n            s->chroma_intra_matrix[j] = v;\n        }\n     }\n \n     if (get_bits1(gb)) {\n         /* non_intra_quantiser_matrix */\n         for (i = 0; i < 64; i++) {\n             get_bits(gb, 8);\n         }\n     }\n \n     if (get_bits1(gb)) {\n         /* chroma_intra_quantiser_matrix */\n         for (i = 0; i < 64; i++) {\n             v = get_bits(gb, 8);\n            j = s->idsp.idct_permutation[ff_zigzag_direct[i]];\n            s->chroma_intra_matrix[j] = v;\n        }\n     }\n \n     if (get_bits1(gb)) {\n         /* chroma_non_intra_quantiser_matrix */\n         for (i = 0; i < 64; i++) {\n             get_bits(gb, 8);\n         }\n     }\n \n     next_start_code_studio(gb);\n }\n",
    "code_after_change": "static void read_quant_matrix_ext(MpegEncContext *s, GetBitContext *gb)\nstatic int read_quant_matrix_ext(MpegEncContext *s, GetBitContext *gb)\n {\n     int i, j, v;\n \n     if (get_bits1(gb)) {\n        if (get_bits_left(gb) < 64*8)\n            return AVERROR_INVALIDDATA;\n         /* intra_quantiser_matrix */\n         for (i = 0; i < 64; i++) {\n             v = get_bits(gb, 8);\n            j = s->idsp.idct_permutation[ff_zigzag_direct[i]];\n            s->intra_matrix[j]        = v;\n            s->chroma_intra_matrix[j] = v;\n        }\n     }\n \n     if (get_bits1(gb)) {\n        if (get_bits_left(gb) < 64*8)\n            return AVERROR_INVALIDDATA;\n         /* non_intra_quantiser_matrix */\n         for (i = 0; i < 64; i++) {\n             get_bits(gb, 8);\n         }\n     }\n \n     if (get_bits1(gb)) {\n        if (get_bits_left(gb) < 64*8)\n            return AVERROR_INVALIDDATA;\n         /* chroma_intra_quantiser_matrix */\n         for (i = 0; i < 64; i++) {\n             v = get_bits(gb, 8);\n            j = s->idsp.idct_permutation[ff_zigzag_direct[i]];\n            s->chroma_intra_matrix[j] = v;\n        }\n     }\n \n     if (get_bits1(gb)) {\n        if (get_bits_left(gb) < 64*8)\n            return AVERROR_INVALIDDATA;\n         /* chroma_non_intra_quantiser_matrix */\n         for (i = 0; i < 64; i++) {\n             get_bits(gb, 8);\n         }\n     }\n \n     next_start_code_studio(gb);\n    return 0;\n }\n",
    "cwe": [
      "CWE-125"
    ],
    "id": 399,
    "_valid_cwes": [
      "CWE-125"
    ]
  },
  {
    "cve_id": "CVE-2018-20679",
    "code_before_change": "int udhcpc_main(int argc UNUSED_PARAM, char **argv)\n{\n\tuint8_t *message;\n\tconst char *str_V, *str_h, *str_F, *str_r;\n\tIF_FEATURE_UDHCPC_ARPING(const char *str_a = \"2000\";)\n\tIF_FEATURE_UDHCP_PORT(char *str_P;)\n\tvoid *clientid_mac_ptr;\n\tllist_t *list_O = NULL;\n\tllist_t *list_x = NULL;\n\tint tryagain_timeout = 20;\n\tint discover_timeout = 3;\n\tint discover_retries = 3;\n\tuint32_t server_addr = server_addr; /* for compiler */\n\tuint32_t requested_ip = 0;\n\tuint32_t xid = xid; /* for compiler */\n\tint packet_num;\n\tint timeout; /* must be signed */\n\tunsigned already_waited_sec;\n\tunsigned opt;\n\tIF_FEATURE_UDHCPC_ARPING(unsigned arpping_ms;)\n\tint retval;\n\n\tsetup_common_bufsiz();\n\n\t/* Default options */\n\tIF_FEATURE_UDHCP_PORT(SERVER_PORT = 67;)\n\tIF_FEATURE_UDHCP_PORT(CLIENT_PORT = 68;)\n\tclient_config.interface = \"eth0\";\n\tclient_config.script = CONFIG_UDHCPC_DEFAULT_SCRIPT;\n\tstr_V = \"udhcp \"BB_VER;\n\n\t/* Parse command line */\n\topt = getopt32long(argv, \"^\"\n\t\t/* O,x: list; -T,-t,-A take numeric param */\n\t\t\"CV:H:h:F:i:np:qRr:s:T:+t:+SA:+O:*ox:*fB\"\n\t\tUSE_FOR_MMU(\"b\")\n\t\tIF_FEATURE_UDHCPC_ARPING(\"a::\")\n\t\tIF_FEATURE_UDHCP_PORT(\"P:\")\n\t\t\"v\"\n\t\t\"\\0\" IF_UDHCP_VERBOSE(\"vv\") /* -v is a counter */\n\t\t, udhcpc_longopts\n\t\t, &str_V, &str_h, &str_h, &str_F\n\t\t, &client_config.interface, &client_config.pidfile /* i,p */\n\t\t, &str_r /* r */\n\t\t, &client_config.script /* s */\n\t\t, &discover_timeout, &discover_retries, &tryagain_timeout /* T,t,A */\n\t\t, &list_O\n\t\t, &list_x\n\t\tIF_FEATURE_UDHCPC_ARPING(, &str_a)\n\t\tIF_FEATURE_UDHCP_PORT(, &str_P)\n\t\tIF_UDHCP_VERBOSE(, &dhcp_verbose)\n\t);\n\tif (opt & (OPT_h|OPT_H)) {\n\t\tbb_error_msg(\"option -h NAME is deprecated, use -x hostname:NAME\");\n\t\tclient_config.hostname = alloc_dhcp_option(DHCP_HOST_NAME, str_h, 0);\n\t}\n\tif (opt & OPT_F) {\n\t\t/* FQDN option format: [0x51][len][flags][0][0]<fqdn> */\n\t\tclient_config.fqdn = alloc_dhcp_option(DHCP_FQDN, str_F, 3);\n\t\t/* Flag bits: 0000NEOS\n\t\t * S: 1 = Client requests server to update A RR in DNS as well as PTR\n\t\t * O: 1 = Server indicates to client that DNS has been updated regardless\n\t\t * E: 1 = Name is in DNS format, i.e. <4>host<6>domain<3>com<0>,\n\t\t *    not \"host.domain.com\". Format 0 is obsolete.\n\t\t * N: 1 = Client requests server to not update DNS (S must be 0 then)\n\t\t * Two [0] bytes which follow are deprecated and must be 0.\n\t\t */\n\t\tclient_config.fqdn[OPT_DATA + 0] = 0x1;\n\t\t/*client_config.fqdn[OPT_DATA + 1] = 0; - xzalloc did it */\n\t\t/*client_config.fqdn[OPT_DATA + 2] = 0; */\n\t}\n\tif (opt & OPT_r)\n\t\trequested_ip = inet_addr(str_r);\n#if ENABLE_FEATURE_UDHCP_PORT\n\tif (opt & OPT_P) {\n\t\tCLIENT_PORT = xatou16(str_P);\n\t\tSERVER_PORT = CLIENT_PORT - 1;\n\t}\n#endif\n\tIF_FEATURE_UDHCPC_ARPING(arpping_ms = xatou(str_a);)\n\twhile (list_O) {\n\t\tchar *optstr = llist_pop(&list_O);\n\t\tunsigned n = bb_strtou(optstr, NULL, 0);\n\t\tif (errno || n > 254) {\n\t\t\tn = udhcp_option_idx(optstr, dhcp_option_strings);\n\t\t\tn = dhcp_optflags[n].code;\n\t\t}\n\t\tclient_config.opt_mask[n >> 3] |= 1 << (n & 7);\n\t}\n\tif (!(opt & OPT_o)) {\n\t\tunsigned i, n;\n\t\tfor (i = 0; (n = dhcp_optflags[i].code) != 0; i++) {\n\t\t\tif (dhcp_optflags[i].flags & OPTION_REQ) {\n\t\t\t\tclient_config.opt_mask[n >> 3] |= 1 << (n & 7);\n\t\t\t}\n\t\t}\n\t}\n\twhile (list_x) {\n\t\tchar *optstr = xstrdup(llist_pop(&list_x));\n\t\tudhcp_str2optset(optstr, &client_config.options,\n\t\t\t\tdhcp_optflags, dhcp_option_strings,\n\t\t\t\t/*dhcpv6:*/ 0\n\t\t);\n\t\tfree(optstr);\n\t}\n\n\tif (udhcp_read_interface(client_config.interface,\n\t\t\t&client_config.ifindex,\n\t\t\tNULL,\n\t\t\tclient_config.client_mac)\n\t) {\n\t\treturn 1;\n\t}\n\n\tclientid_mac_ptr = NULL;\n\tif (!(opt & OPT_C) && !udhcp_find_option(client_config.options, DHCP_CLIENT_ID)) {\n\t\t/* not suppressed and not set, set the default client ID */\n\t\tclient_config.clientid = alloc_dhcp_option(DHCP_CLIENT_ID, \"\", 7);\n\t\tclient_config.clientid[OPT_DATA] = 1; /* type: ethernet */\n\t\tclientid_mac_ptr = client_config.clientid + OPT_DATA+1;\n\t\tmemcpy(clientid_mac_ptr, client_config.client_mac, 6);\n\t}\n\tif (str_V[0] != '\\0') {\n\t\tclient_config.vendorclass = alloc_dhcp_option(DHCP_VENDOR, str_V, 0);\n\t}\n\n#if !BB_MMU\n\t/* on NOMMU reexec (i.e., background) early */\n\tif (!(opt & OPT_f)) {\n\t\tbb_daemonize_or_rexec(0 /* flags */, argv);\n\t\tlogmode = LOGMODE_NONE;\n\t}\n#endif\n\tif (opt & OPT_S) {\n\t\topenlog(applet_name, LOG_PID, LOG_DAEMON);\n\t\tlogmode |= LOGMODE_SYSLOG;\n\t}\n\n\t/* Make sure fd 0,1,2 are open */\n\tbb_sanitize_stdio();\n\t/* Create pidfile */\n\twrite_pidfile(client_config.pidfile);\n\t/* Goes to stdout (unless NOMMU) and possibly syslog */\n\tbb_error_msg(\"started, v\"BB_VER);\n\t/* Set up the signal pipe */\n\tudhcp_sp_setup();\n\t/* We want random_xid to be random... */\n\tsrand(monotonic_us());\n\n\tstate = INIT_SELECTING;\n\tudhcp_run_script(NULL, \"deconfig\");\n\tchange_listen_mode(LISTEN_RAW);\n\tpacket_num = 0;\n\ttimeout = 0;\n\talready_waited_sec = 0;\n\n\t/* Main event loop. select() waits on signal pipe and possibly\n\t * on sockfd.\n\t * \"continue\" statements in code below jump to the top of the loop.\n\t */\n\tfor (;;) {\n\t\tint tv;\n\t\tstruct pollfd pfds[2];\n\t\tstruct dhcp_packet packet;\n\t\t/* silence \"uninitialized!\" warning */\n\t\tunsigned timestamp_before_wait = timestamp_before_wait;\n\n\n\t\t/* Was opening raw or udp socket here\n\t\t * if (listen_mode != LISTEN_NONE && sockfd < 0),\n\t\t * but on fast network renew responses return faster\n\t\t * than we open sockets. Thus this code is moved\n\t\t * to change_listen_mode(). Thus we open listen socket\n\t\t * BEFORE we send renew request (see \"case BOUND:\"). */\n\n\t\tudhcp_sp_fd_set(pfds, sockfd);\n\n\t\ttv = timeout - already_waited_sec;\n\t\tretval = 0;\n\t\t/* If we already timed out, fall through with retval = 0, else... */\n\t\tif (tv > 0) {\n\t\t\tlog1(\"waiting %u seconds\", tv);\n\t\t\ttimestamp_before_wait = (unsigned)monotonic_sec();\n\t\t\tretval = poll(pfds, 2, tv < INT_MAX/1000 ? tv * 1000 : INT_MAX);\n\t\t\tif (retval < 0) {\n\t\t\t\t/* EINTR? A signal was caught, don't panic */\n\t\t\t\tif (errno == EINTR) {\n\t\t\t\t\talready_waited_sec += (unsigned)monotonic_sec() - timestamp_before_wait;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* Else: an error occurred, panic! */\n\t\t\t\tbb_perror_msg_and_die(\"poll\");\n\t\t\t}\n\t\t}\n\n\t\t/* If timeout dropped to zero, time to become active:\n\t\t * resend discover/renew/whatever\n\t\t */\n\t\tif (retval == 0) {\n\t\t\t/* When running on a bridge, the ifindex may have changed\n\t\t\t * (e.g. if member interfaces were added/removed\n\t\t\t * or if the status of the bridge changed).\n\t\t\t * Refresh ifindex and client_mac:\n\t\t\t */\n\t\t\tif (udhcp_read_interface(client_config.interface,\n\t\t\t\t\t&client_config.ifindex,\n\t\t\t\t\tNULL,\n\t\t\t\t\tclient_config.client_mac)\n\t\t\t) {\n\t\t\t\tgoto ret0; /* iface is gone? */\n\t\t\t}\n\t\t\tif (clientid_mac_ptr)\n\t\t\t\tmemcpy(clientid_mac_ptr, client_config.client_mac, 6);\n\n\t\t\t/* We will restart the wait in any case */\n\t\t\talready_waited_sec = 0;\n\n\t\t\tswitch (state) {\n\t\t\tcase INIT_SELECTING:\n\t\t\t\tif (!discover_retries || packet_num < discover_retries) {\n\t\t\t\t\tif (packet_num == 0)\n\t\t\t\t\t\txid = random_xid();\n\t\t\t\t\t/* broadcast */\n\t\t\t\t\tsend_discover(xid, requested_ip);\n\t\t\t\t\ttimeout = discover_timeout;\n\t\t\t\t\tpacket_num++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n leasefail:\n\t\t\t\tudhcp_run_script(NULL, \"leasefail\");\n#if BB_MMU /* -b is not supported on NOMMU */\n\t\t\t\tif (opt & OPT_b) { /* background if no lease */\n\t\t\t\t\tbb_error_msg(\"no lease, forking to background\");\n\t\t\t\t\tclient_background();\n\t\t\t\t\t/* do not background again! */\n\t\t\t\t\topt = ((opt & ~OPT_b) | OPT_f);\n\t\t\t\t} else\n#endif\n\t\t\t\tif (opt & OPT_n) { /* abort if no lease */\n\t\t\t\t\tbb_error_msg(\"no lease, failing\");\n\t\t\t\t\tretval = 1;\n\t\t\t\t\tgoto ret;\n\t\t\t\t}\n\t\t\t\t/* wait before trying again */\n\t\t\t\ttimeout = tryagain_timeout;\n\t\t\t\tpacket_num = 0;\n\t\t\t\tcontinue;\n\t\t\tcase REQUESTING:\n\t\t\t\tif (packet_num < 3) {\n\t\t\t\t\t/* send broadcast select packet */\n\t\t\t\t\tsend_select(xid, server_addr, requested_ip);\n\t\t\t\t\ttimeout = discover_timeout;\n\t\t\t\t\tpacket_num++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* Timed out, go back to init state.\n\t\t\t\t * \"discover...select...discover...\" loops\n\t\t\t\t * were seen in the wild. Treat them similarly\n\t\t\t\t * to \"no response to discover\" case */\n\t\t\t\tchange_listen_mode(LISTEN_RAW);\n\t\t\t\tstate = INIT_SELECTING;\n\t\t\t\tgoto leasefail;\n\t\t\tcase BOUND:\n\t\t\t\t/* 1/2 lease passed, enter renewing state */\n\t\t\t\tstate = RENEWING;\n\t\t\t\tclient_config.first_secs = 0; /* make secs field count from 0 */\n\t\t\t\tchange_listen_mode(LISTEN_KERNEL);\n\t\t\t\tlog1(\"entering renew state\");\n\t\t\t\t/* fall right through */\n\t\t\tcase RENEW_REQUESTED: /* manual (SIGUSR1) renew */\n\t\t\tcase_RENEW_REQUESTED:\n\t\t\tcase RENEWING:\n\t\t\t\tif (timeout >= 60) {\n\t\t\t\t\t/* send an unicast renew request */\n\t\t\t/* Sometimes observed to fail (EADDRNOTAVAIL) to bind\n\t\t\t * a new UDP socket for sending inside send_renew.\n\t\t\t * I hazard to guess existing listening socket\n\t\t\t * is somehow conflicting with it, but why is it\n\t\t\t * not deterministic then?! Strange.\n\t\t\t * Anyway, it does recover by eventually failing through\n\t\t\t * into INIT_SELECTING state.\n\t\t\t */\n\t\t\t\t\tif (send_renew(xid, server_addr, requested_ip) >= 0) {\n\t\t\t\t\t\ttimeout >>= 1;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t/* else: error sending.\n\t\t\t\t\t * example: ENETUNREACH seen with server\n\t\t\t\t\t * which gave us bogus server ID 1.1.1.1\n\t\t\t\t\t * which wasn't reachable (and probably did not exist).\n\t\t\t\t\t */\n\t\t\t\t}\n\t\t\t\t/* Timed out or error, enter rebinding state */\n\t\t\t\tlog1(\"entering rebinding state\");\n\t\t\t\tstate = REBINDING;\n\t\t\t\t/* fall right through */\n\t\t\tcase REBINDING:\n\t\t\t\t/* Switch to bcast receive */\n\t\t\t\tchange_listen_mode(LISTEN_RAW);\n\t\t\t\t/* Lease is *really* about to run out,\n\t\t\t\t * try to find DHCP server using broadcast */\n\t\t\t\tif (timeout > 0) {\n\t\t\t\t\t/* send a broadcast renew request */\n\t\t\t\t\tsend_renew(xid, 0 /*INADDR_ANY*/, requested_ip);\n\t\t\t\t\ttimeout >>= 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* Timed out, enter init state */\n\t\t\t\tbb_error_msg(\"lease lost, entering init state\");\n\t\t\t\tudhcp_run_script(NULL, \"deconfig\");\n\t\t\t\tstate = INIT_SELECTING;\n\t\t\t\tclient_config.first_secs = 0; /* make secs field count from 0 */\n\t\t\t\t/*timeout = 0; - already is */\n\t\t\t\tpacket_num = 0;\n\t\t\t\tcontinue;\n\t\t\t/* case RELEASED: */\n\t\t\t}\n\t\t\t/* yah, I know, *you* say it would never happen */\n\t\t\ttimeout = INT_MAX;\n\t\t\tcontinue; /* back to main loop */\n\t\t} /* if poll timed out */\n\n\t\t/* poll() didn't timeout, something happened */\n\n\t\t/* Is it a signal? */\n\t\tswitch (udhcp_sp_read()) {\n\t\tcase SIGUSR1:\n\t\t\tclient_config.first_secs = 0; /* make secs field count from 0 */\n\t\t\talready_waited_sec = 0;\n\t\t\tperform_renew();\n\t\t\tif (state == RENEW_REQUESTED) {\n\t\t\t\t/* We might be either on the same network\n\t\t\t\t * (in which case renew might work),\n\t\t\t\t * or we might be on a completely different one\n\t\t\t\t * (in which case renew won't ever succeed).\n\t\t\t\t * For the second case, must make sure timeout\n\t\t\t\t * is not too big, or else we can send\n\t\t\t\t * futile renew requests for hours.\n\t\t\t\t */\n\t\t\t\tif (timeout > 60)\n\t\t\t\t\ttimeout = 60;\n\t\t\t\tgoto case_RENEW_REQUESTED;\n\t\t\t}\n\t\t\t/* Start things over */\n\t\t\tpacket_num = 0;\n\t\t\t/* Kill any timeouts, user wants this to hurry along */\n\t\t\ttimeout = 0;\n\t\t\tcontinue;\n\t\tcase SIGUSR2:\n\t\t\tperform_release(server_addr, requested_ip);\n\t\t\ttimeout = INT_MAX;\n\t\t\tcontinue;\n\t\tcase SIGTERM:\n\t\t\tbb_error_msg(\"received %s\", \"SIGTERM\");\n\t\t\tgoto ret0;\n\t\t}\n\n\t\t/* Is it a packet? */\n\t\tif (!pfds[1].revents)\n\t\t\tcontinue; /* no */\n\n\t\t{\n\t\t\tint len;\n\n\t\t\t/* A packet is ready, read it */\n\t\t\tif (listen_mode == LISTEN_KERNEL)\n\t\t\t\tlen = udhcp_recv_kernel_packet(&packet, sockfd);\n\t\t\telse\n\t\t\t\tlen = udhcp_recv_raw_packet(&packet, sockfd);\n\t\t\tif (len == -1) {\n\t\t\t\t/* Error is severe, reopen socket */\n\t\t\t\tbb_error_msg(\"read error: \"STRERROR_FMT\", reopening socket\" STRERROR_ERRNO);\n\t\t\t\tsleep(discover_timeout); /* 3 seconds by default */\n\t\t\t\tchange_listen_mode(listen_mode); /* just close and reopen */\n\t\t\t}\n\t\t\t/* If this packet will turn out to be unrelated/bogus,\n\t\t\t * we will go back and wait for next one.\n\t\t\t * Be sure timeout is properly decreased. */\n\t\t\talready_waited_sec += (unsigned)monotonic_sec() - timestamp_before_wait;\n\t\t\tif (len < 0)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (packet.xid != xid) {\n\t\t\tlog1(\"xid %x (our is %x), ignoring packet\",\n\t\t\t\t(unsigned)packet.xid, (unsigned)xid);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Ignore packets that aren't for us */\n\t\tif (packet.hlen != 6\n\t\t || memcmp(packet.chaddr, client_config.client_mac, 6) != 0\n\t\t) {\n\t\t\tlog1(\"chaddr does not match, ignoring packet\"); // log2?\n\t\t\tcontinue;\n\t\t}\n\n\t\tmessage = udhcp_get_option(&packet, DHCP_MESSAGE_TYPE);\n\t\tif (message == NULL) {\n\t\t\tbb_error_msg(\"no message type option, ignoring packet\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (state) {\n\t\tcase INIT_SELECTING:\n\t\t\t/* Must be a DHCPOFFER */\n\t\t\tif (*message == DHCPOFFER) {\n\t\t\t\tuint8_t *temp;\n\n/* What exactly is server's IP? There are several values.\n * Example DHCP offer captured with tchdump:\n *\n * 10.34.25.254:67 > 10.34.25.202:68 // IP header's src\n * BOOTP fields:\n * Your-IP 10.34.25.202\n * Server-IP 10.34.32.125   // \"next server\" IP\n * Gateway-IP 10.34.25.254  // relay's address (if DHCP relays are in use)\n * DHCP options:\n * DHCP-Message Option 53, length 1: Offer\n * Server-ID Option 54, length 4: 10.34.255.7       // \"server ID\"\n * Default-Gateway Option 3, length 4: 10.34.25.254 // router\n *\n * We think that real server IP (one to use in renew/release)\n * is one in Server-ID option. But I am not 100% sure.\n * IP header's src and Gateway-IP (same in this example)\n * might work too.\n * \"Next server\" and router are definitely wrong ones to use, though...\n */\n/* We used to ignore pcakets without DHCP_SERVER_ID.\n * I've got user reports from people who run \"address-less\" servers.\n * They either supply DHCP_SERVER_ID of 0.0.0.0 or don't supply it at all.\n  * They say ISC DHCP client supports this case.\n  */\n \t\t\t\tserver_addr = 0;\n\t\t\t\ttemp = udhcp_get_option(&packet, DHCP_SERVER_ID);\n \t\t\t\tif (!temp) {\n \t\t\t\t\tbb_error_msg(\"no server ID, using 0.0.0.0\");\n \t\t\t\t} else {\n\t\t\t\t\t/* it IS unaligned sometimes, don't \"optimize\" */\n\t\t\t\t\tmove_from_unaligned32(server_addr, temp);\n\t\t\t\t}\n\t\t\t\t/*xid = packet.xid; - already is */\n\t\t\t\trequested_ip = packet.yiaddr;\n\n\t\t\t\t/* enter requesting state */\n\t\t\t\tstate = REQUESTING;\n\t\t\t\ttimeout = 0;\n\t\t\t\tpacket_num = 0;\n\t\t\t\talready_waited_sec = 0;\n\t\t\t}\n\t\t\tcontinue;\n\t\tcase REQUESTING:\n\t\tcase RENEWING:\n\t\tcase RENEW_REQUESTED:\n\t\tcase REBINDING:\n\t\t\tif (*message == DHCPACK) {\n\t\t\t\tunsigned start;\n\t\t\t\tuint32_t lease_seconds;\n \t\t\t\tstruct in_addr temp_addr;\n \t\t\t\tuint8_t *temp;\n \n\t\t\t\ttemp = udhcp_get_option(&packet, DHCP_LEASE_TIME);\n \t\t\t\tif (!temp) {\n \t\t\t\t\tbb_error_msg(\"no lease time with ACK, using 1 hour lease\");\n \t\t\t\t\tlease_seconds = 60 * 60;\n\t\t\t\t} else {\n\t\t\t\t\t/* it IS unaligned sometimes, don't \"optimize\" */\n\t\t\t\t\tmove_from_unaligned32(lease_seconds, temp);\n\t\t\t\t\tlease_seconds = ntohl(lease_seconds);\n\t\t\t\t\t/* paranoia: must not be too small and not prone to overflows */\n\t\t\t\t\t/* timeout > 60 - ensures at least one unicast renew attempt */\n\t\t\t\t\tif (lease_seconds < 2 * 61)\n\t\t\t\t\t\tlease_seconds = 2 * 61;\n\t\t\t\t}\n#if ENABLE_FEATURE_UDHCPC_ARPING\n\t\t\t\tif (opt & OPT_a) {\n/* RFC 2131 3.1 paragraph 5:\n * \"The client receives the DHCPACK message with configuration\n * parameters. The client SHOULD perform a final check on the\n * parameters (e.g., ARP for allocated network address), and notes\n * the duration of the lease specified in the DHCPACK message. At this\n * point, the client is configured. If the client detects that the\n * address is already in use (e.g., through the use of ARP),\n * the client MUST send a DHCPDECLINE message to the server and restarts\n * the configuration process...\" */\n\t\t\t\t\tif (!arpping(packet.yiaddr,\n\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t(uint32_t) 0,\n\t\t\t\t\t\t\tclient_config.client_mac,\n\t\t\t\t\t\t\tclient_config.interface,\n\t\t\t\t\t\t\tarpping_ms)\n\t\t\t\t\t) {\n\t\t\t\t\t\tbb_error_msg(\"offered address is in use \"\n\t\t\t\t\t\t\t\"(got ARP reply), declining\");\n\t\t\t\t\t\tsend_decline(/*xid,*/ server_addr, packet.yiaddr);\n\n\t\t\t\t\t\tif (state != REQUESTING)\n\t\t\t\t\t\t\tudhcp_run_script(NULL, \"deconfig\");\n\t\t\t\t\t\tchange_listen_mode(LISTEN_RAW);\n\t\t\t\t\t\tstate = INIT_SELECTING;\n\t\t\t\t\t\tclient_config.first_secs = 0; /* make secs field count from 0 */\n\t\t\t\t\t\trequested_ip = 0;\n\t\t\t\t\t\ttimeout = tryagain_timeout;\n\t\t\t\t\t\tpacket_num = 0;\n\t\t\t\t\t\talready_waited_sec = 0;\n\t\t\t\t\t\tcontinue; /* back to main loop */\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\t\t/* enter bound state */\n\t\t\t\ttemp_addr.s_addr = packet.yiaddr;\n\t\t\t\tbb_error_msg(\"lease of %s obtained, lease time %u\",\n\t\t\t\t\tinet_ntoa(temp_addr), (unsigned)lease_seconds);\n\t\t\t\trequested_ip = packet.yiaddr;\n\n\t\t\t\tstart = monotonic_sec();\n\t\t\t\tudhcp_run_script(&packet, state == REQUESTING ? \"bound\" : \"renew\");\n\t\t\t\talready_waited_sec = (unsigned)monotonic_sec() - start;\n\t\t\t\ttimeout = lease_seconds / 2;\n\t\t\t\tif ((unsigned)timeout < already_waited_sec) {\n\t\t\t\t\t/* Something went wrong. Back to discover state */\n\t\t\t\t\ttimeout = already_waited_sec = 0;\n\t\t\t\t}\n\n\t\t\t\tstate = BOUND;\n\t\t\t\tchange_listen_mode(LISTEN_NONE);\n\t\t\t\tif (opt & OPT_q) { /* quit after lease */\n\t\t\t\t\tgoto ret0;\n\t\t\t\t}\n\t\t\t\t/* future renew failures should not exit (JM) */\n\t\t\t\topt &= ~OPT_n;\n#if BB_MMU /* NOMMU case backgrounded earlier */\n\t\t\t\tif (!(opt & OPT_f)) {\n\t\t\t\t\tclient_background();\n\t\t\t\t\t/* do not background again! */\n\t\t\t\t\topt = ((opt & ~OPT_b) | OPT_f);\n\t\t\t\t}\n#endif\n\t\t\t\t/* make future renew packets use different xid */\n\t\t\t\t/* xid = random_xid(); ...but why bother? */\n\n\t\t\t\tcontinue; /* back to main loop */\n\t\t\t}\n\t\t\tif (*message == DHCPNAK) {\n\t\t\t\t/* If network has more than one DHCP server,\n\t\t\t\t * \"wrong\" server can reply first, with a NAK.\n\t\t\t\t * Do not interpret it as a NAK from \"our\" server.\n\t\t\t\t */\n\t\t\t\tif (server_addr != 0) {\n \t\t\t\t\tuint32_t svid;\n \t\t\t\t\tuint8_t *temp;\n \n\t\t\t\t\ttemp = udhcp_get_option(&packet, DHCP_SERVER_ID);\n \t\t\t\t\tif (!temp) {\n  non_matching_svid:\n \t\t\t\t\t\tlog1(\"received DHCP NAK with wrong\"\n\t\t\t\t\t\t\t\" server ID, ignoring packet\");\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tmove_from_unaligned32(svid, temp);\n\t\t\t\t\tif (svid != server_addr)\n\t\t\t\t\t\tgoto non_matching_svid;\n\t\t\t\t}\n\t\t\t\t/* return to init state */\n\t\t\t\tbb_error_msg(\"received %s\", \"DHCP NAK\");\n\t\t\t\tudhcp_run_script(&packet, \"nak\");\n\t\t\t\tif (state != REQUESTING)\n\t\t\t\t\tudhcp_run_script(NULL, \"deconfig\");\n\t\t\t\tchange_listen_mode(LISTEN_RAW);\n\t\t\t\tsleep(3); /* avoid excessive network traffic */\n\t\t\t\tstate = INIT_SELECTING;\n\t\t\t\tclient_config.first_secs = 0; /* make secs field count from 0 */\n\t\t\t\trequested_ip = 0;\n\t\t\t\ttimeout = 0;\n\t\t\t\tpacket_num = 0;\n\t\t\t\talready_waited_sec = 0;\n\t\t\t}\n\t\t\tcontinue;\n\t\t/* case BOUND: - ignore all packets */\n\t\t/* case RELEASED: - ignore all packets */\n\t\t}\n\t\t/* back to main loop */\n\t} /* for (;;) - main loop ends */\n\n ret0:\n\tif (opt & OPT_R) /* release on quit */\n\t\tperform_release(server_addr, requested_ip);\n\tretval = 0;\n ret:\n\t/*if (client_config.pidfile) - remove_pidfile has its own check */\n\t\tremove_pidfile(client_config.pidfile);\n\treturn retval;\n}\n",
    "code_after_change": "int udhcpc_main(int argc UNUSED_PARAM, char **argv)\n{\n\tuint8_t *message;\n\tconst char *str_V, *str_h, *str_F, *str_r;\n\tIF_FEATURE_UDHCPC_ARPING(const char *str_a = \"2000\";)\n\tIF_FEATURE_UDHCP_PORT(char *str_P;)\n\tvoid *clientid_mac_ptr;\n\tllist_t *list_O = NULL;\n\tllist_t *list_x = NULL;\n\tint tryagain_timeout = 20;\n\tint discover_timeout = 3;\n\tint discover_retries = 3;\n\tuint32_t server_addr = server_addr; /* for compiler */\n\tuint32_t requested_ip = 0;\n\tuint32_t xid = xid; /* for compiler */\n\tint packet_num;\n\tint timeout; /* must be signed */\n\tunsigned already_waited_sec;\n\tunsigned opt;\n\tIF_FEATURE_UDHCPC_ARPING(unsigned arpping_ms;)\n\tint retval;\n\n\tsetup_common_bufsiz();\n\n\t/* Default options */\n\tIF_FEATURE_UDHCP_PORT(SERVER_PORT = 67;)\n\tIF_FEATURE_UDHCP_PORT(CLIENT_PORT = 68;)\n\tclient_config.interface = \"eth0\";\n\tclient_config.script = CONFIG_UDHCPC_DEFAULT_SCRIPT;\n\tstr_V = \"udhcp \"BB_VER;\n\n\t/* Parse command line */\n\topt = getopt32long(argv, \"^\"\n\t\t/* O,x: list; -T,-t,-A take numeric param */\n\t\t\"CV:H:h:F:i:np:qRr:s:T:+t:+SA:+O:*ox:*fB\"\n\t\tUSE_FOR_MMU(\"b\")\n\t\tIF_FEATURE_UDHCPC_ARPING(\"a::\")\n\t\tIF_FEATURE_UDHCP_PORT(\"P:\")\n\t\t\"v\"\n\t\t\"\\0\" IF_UDHCP_VERBOSE(\"vv\") /* -v is a counter */\n\t\t, udhcpc_longopts\n\t\t, &str_V, &str_h, &str_h, &str_F\n\t\t, &client_config.interface, &client_config.pidfile /* i,p */\n\t\t, &str_r /* r */\n\t\t, &client_config.script /* s */\n\t\t, &discover_timeout, &discover_retries, &tryagain_timeout /* T,t,A */\n\t\t, &list_O\n\t\t, &list_x\n\t\tIF_FEATURE_UDHCPC_ARPING(, &str_a)\n\t\tIF_FEATURE_UDHCP_PORT(, &str_P)\n\t\tIF_UDHCP_VERBOSE(, &dhcp_verbose)\n\t);\n\tif (opt & (OPT_h|OPT_H)) {\n\t\tbb_error_msg(\"option -h NAME is deprecated, use -x hostname:NAME\");\n\t\tclient_config.hostname = alloc_dhcp_option(DHCP_HOST_NAME, str_h, 0);\n\t}\n\tif (opt & OPT_F) {\n\t\t/* FQDN option format: [0x51][len][flags][0][0]<fqdn> */\n\t\tclient_config.fqdn = alloc_dhcp_option(DHCP_FQDN, str_F, 3);\n\t\t/* Flag bits: 0000NEOS\n\t\t * S: 1 = Client requests server to update A RR in DNS as well as PTR\n\t\t * O: 1 = Server indicates to client that DNS has been updated regardless\n\t\t * E: 1 = Name is in DNS format, i.e. <4>host<6>domain<3>com<0>,\n\t\t *    not \"host.domain.com\". Format 0 is obsolete.\n\t\t * N: 1 = Client requests server to not update DNS (S must be 0 then)\n\t\t * Two [0] bytes which follow are deprecated and must be 0.\n\t\t */\n\t\tclient_config.fqdn[OPT_DATA + 0] = 0x1;\n\t\t/*client_config.fqdn[OPT_DATA + 1] = 0; - xzalloc did it */\n\t\t/*client_config.fqdn[OPT_DATA + 2] = 0; */\n\t}\n\tif (opt & OPT_r)\n\t\trequested_ip = inet_addr(str_r);\n#if ENABLE_FEATURE_UDHCP_PORT\n\tif (opt & OPT_P) {\n\t\tCLIENT_PORT = xatou16(str_P);\n\t\tSERVER_PORT = CLIENT_PORT - 1;\n\t}\n#endif\n\tIF_FEATURE_UDHCPC_ARPING(arpping_ms = xatou(str_a);)\n\twhile (list_O) {\n\t\tchar *optstr = llist_pop(&list_O);\n\t\tunsigned n = bb_strtou(optstr, NULL, 0);\n\t\tif (errno || n > 254) {\n\t\t\tn = udhcp_option_idx(optstr, dhcp_option_strings);\n\t\t\tn = dhcp_optflags[n].code;\n\t\t}\n\t\tclient_config.opt_mask[n >> 3] |= 1 << (n & 7);\n\t}\n\tif (!(opt & OPT_o)) {\n\t\tunsigned i, n;\n\t\tfor (i = 0; (n = dhcp_optflags[i].code) != 0; i++) {\n\t\t\tif (dhcp_optflags[i].flags & OPTION_REQ) {\n\t\t\t\tclient_config.opt_mask[n >> 3] |= 1 << (n & 7);\n\t\t\t}\n\t\t}\n\t}\n\twhile (list_x) {\n\t\tchar *optstr = xstrdup(llist_pop(&list_x));\n\t\tudhcp_str2optset(optstr, &client_config.options,\n\t\t\t\tdhcp_optflags, dhcp_option_strings,\n\t\t\t\t/*dhcpv6:*/ 0\n\t\t);\n\t\tfree(optstr);\n\t}\n\n\tif (udhcp_read_interface(client_config.interface,\n\t\t\t&client_config.ifindex,\n\t\t\tNULL,\n\t\t\tclient_config.client_mac)\n\t) {\n\t\treturn 1;\n\t}\n\n\tclientid_mac_ptr = NULL;\n\tif (!(opt & OPT_C) && !udhcp_find_option(client_config.options, DHCP_CLIENT_ID)) {\n\t\t/* not suppressed and not set, set the default client ID */\n\t\tclient_config.clientid = alloc_dhcp_option(DHCP_CLIENT_ID, \"\", 7);\n\t\tclient_config.clientid[OPT_DATA] = 1; /* type: ethernet */\n\t\tclientid_mac_ptr = client_config.clientid + OPT_DATA+1;\n\t\tmemcpy(clientid_mac_ptr, client_config.client_mac, 6);\n\t}\n\tif (str_V[0] != '\\0') {\n\t\tclient_config.vendorclass = alloc_dhcp_option(DHCP_VENDOR, str_V, 0);\n\t}\n\n#if !BB_MMU\n\t/* on NOMMU reexec (i.e., background) early */\n\tif (!(opt & OPT_f)) {\n\t\tbb_daemonize_or_rexec(0 /* flags */, argv);\n\t\tlogmode = LOGMODE_NONE;\n\t}\n#endif\n\tif (opt & OPT_S) {\n\t\topenlog(applet_name, LOG_PID, LOG_DAEMON);\n\t\tlogmode |= LOGMODE_SYSLOG;\n\t}\n\n\t/* Make sure fd 0,1,2 are open */\n\tbb_sanitize_stdio();\n\t/* Create pidfile */\n\twrite_pidfile(client_config.pidfile);\n\t/* Goes to stdout (unless NOMMU) and possibly syslog */\n\tbb_error_msg(\"started, v\"BB_VER);\n\t/* Set up the signal pipe */\n\tudhcp_sp_setup();\n\t/* We want random_xid to be random... */\n\tsrand(monotonic_us());\n\n\tstate = INIT_SELECTING;\n\tudhcp_run_script(NULL, \"deconfig\");\n\tchange_listen_mode(LISTEN_RAW);\n\tpacket_num = 0;\n\ttimeout = 0;\n\talready_waited_sec = 0;\n\n\t/* Main event loop. select() waits on signal pipe and possibly\n\t * on sockfd.\n\t * \"continue\" statements in code below jump to the top of the loop.\n\t */\n\tfor (;;) {\n\t\tint tv;\n\t\tstruct pollfd pfds[2];\n\t\tstruct dhcp_packet packet;\n\t\t/* silence \"uninitialized!\" warning */\n\t\tunsigned timestamp_before_wait = timestamp_before_wait;\n\n\n\t\t/* Was opening raw or udp socket here\n\t\t * if (listen_mode != LISTEN_NONE && sockfd < 0),\n\t\t * but on fast network renew responses return faster\n\t\t * than we open sockets. Thus this code is moved\n\t\t * to change_listen_mode(). Thus we open listen socket\n\t\t * BEFORE we send renew request (see \"case BOUND:\"). */\n\n\t\tudhcp_sp_fd_set(pfds, sockfd);\n\n\t\ttv = timeout - already_waited_sec;\n\t\tretval = 0;\n\t\t/* If we already timed out, fall through with retval = 0, else... */\n\t\tif (tv > 0) {\n\t\t\tlog1(\"waiting %u seconds\", tv);\n\t\t\ttimestamp_before_wait = (unsigned)monotonic_sec();\n\t\t\tretval = poll(pfds, 2, tv < INT_MAX/1000 ? tv * 1000 : INT_MAX);\n\t\t\tif (retval < 0) {\n\t\t\t\t/* EINTR? A signal was caught, don't panic */\n\t\t\t\tif (errno == EINTR) {\n\t\t\t\t\talready_waited_sec += (unsigned)monotonic_sec() - timestamp_before_wait;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* Else: an error occurred, panic! */\n\t\t\t\tbb_perror_msg_and_die(\"poll\");\n\t\t\t}\n\t\t}\n\n\t\t/* If timeout dropped to zero, time to become active:\n\t\t * resend discover/renew/whatever\n\t\t */\n\t\tif (retval == 0) {\n\t\t\t/* When running on a bridge, the ifindex may have changed\n\t\t\t * (e.g. if member interfaces were added/removed\n\t\t\t * or if the status of the bridge changed).\n\t\t\t * Refresh ifindex and client_mac:\n\t\t\t */\n\t\t\tif (udhcp_read_interface(client_config.interface,\n\t\t\t\t\t&client_config.ifindex,\n\t\t\t\t\tNULL,\n\t\t\t\t\tclient_config.client_mac)\n\t\t\t) {\n\t\t\t\tgoto ret0; /* iface is gone? */\n\t\t\t}\n\t\t\tif (clientid_mac_ptr)\n\t\t\t\tmemcpy(clientid_mac_ptr, client_config.client_mac, 6);\n\n\t\t\t/* We will restart the wait in any case */\n\t\t\talready_waited_sec = 0;\n\n\t\t\tswitch (state) {\n\t\t\tcase INIT_SELECTING:\n\t\t\t\tif (!discover_retries || packet_num < discover_retries) {\n\t\t\t\t\tif (packet_num == 0)\n\t\t\t\t\t\txid = random_xid();\n\t\t\t\t\t/* broadcast */\n\t\t\t\t\tsend_discover(xid, requested_ip);\n\t\t\t\t\ttimeout = discover_timeout;\n\t\t\t\t\tpacket_num++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n leasefail:\n\t\t\t\tudhcp_run_script(NULL, \"leasefail\");\n#if BB_MMU /* -b is not supported on NOMMU */\n\t\t\t\tif (opt & OPT_b) { /* background if no lease */\n\t\t\t\t\tbb_error_msg(\"no lease, forking to background\");\n\t\t\t\t\tclient_background();\n\t\t\t\t\t/* do not background again! */\n\t\t\t\t\topt = ((opt & ~OPT_b) | OPT_f);\n\t\t\t\t} else\n#endif\n\t\t\t\tif (opt & OPT_n) { /* abort if no lease */\n\t\t\t\t\tbb_error_msg(\"no lease, failing\");\n\t\t\t\t\tretval = 1;\n\t\t\t\t\tgoto ret;\n\t\t\t\t}\n\t\t\t\t/* wait before trying again */\n\t\t\t\ttimeout = tryagain_timeout;\n\t\t\t\tpacket_num = 0;\n\t\t\t\tcontinue;\n\t\t\tcase REQUESTING:\n\t\t\t\tif (packet_num < 3) {\n\t\t\t\t\t/* send broadcast select packet */\n\t\t\t\t\tsend_select(xid, server_addr, requested_ip);\n\t\t\t\t\ttimeout = discover_timeout;\n\t\t\t\t\tpacket_num++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* Timed out, go back to init state.\n\t\t\t\t * \"discover...select...discover...\" loops\n\t\t\t\t * were seen in the wild. Treat them similarly\n\t\t\t\t * to \"no response to discover\" case */\n\t\t\t\tchange_listen_mode(LISTEN_RAW);\n\t\t\t\tstate = INIT_SELECTING;\n\t\t\t\tgoto leasefail;\n\t\t\tcase BOUND:\n\t\t\t\t/* 1/2 lease passed, enter renewing state */\n\t\t\t\tstate = RENEWING;\n\t\t\t\tclient_config.first_secs = 0; /* make secs field count from 0 */\n\t\t\t\tchange_listen_mode(LISTEN_KERNEL);\n\t\t\t\tlog1(\"entering renew state\");\n\t\t\t\t/* fall right through */\n\t\t\tcase RENEW_REQUESTED: /* manual (SIGUSR1) renew */\n\t\t\tcase_RENEW_REQUESTED:\n\t\t\tcase RENEWING:\n\t\t\t\tif (timeout >= 60) {\n\t\t\t\t\t/* send an unicast renew request */\n\t\t\t/* Sometimes observed to fail (EADDRNOTAVAIL) to bind\n\t\t\t * a new UDP socket for sending inside send_renew.\n\t\t\t * I hazard to guess existing listening socket\n\t\t\t * is somehow conflicting with it, but why is it\n\t\t\t * not deterministic then?! Strange.\n\t\t\t * Anyway, it does recover by eventually failing through\n\t\t\t * into INIT_SELECTING state.\n\t\t\t */\n\t\t\t\t\tif (send_renew(xid, server_addr, requested_ip) >= 0) {\n\t\t\t\t\t\ttimeout >>= 1;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t/* else: error sending.\n\t\t\t\t\t * example: ENETUNREACH seen with server\n\t\t\t\t\t * which gave us bogus server ID 1.1.1.1\n\t\t\t\t\t * which wasn't reachable (and probably did not exist).\n\t\t\t\t\t */\n\t\t\t\t}\n\t\t\t\t/* Timed out or error, enter rebinding state */\n\t\t\t\tlog1(\"entering rebinding state\");\n\t\t\t\tstate = REBINDING;\n\t\t\t\t/* fall right through */\n\t\t\tcase REBINDING:\n\t\t\t\t/* Switch to bcast receive */\n\t\t\t\tchange_listen_mode(LISTEN_RAW);\n\t\t\t\t/* Lease is *really* about to run out,\n\t\t\t\t * try to find DHCP server using broadcast */\n\t\t\t\tif (timeout > 0) {\n\t\t\t\t\t/* send a broadcast renew request */\n\t\t\t\t\tsend_renew(xid, 0 /*INADDR_ANY*/, requested_ip);\n\t\t\t\t\ttimeout >>= 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* Timed out, enter init state */\n\t\t\t\tbb_error_msg(\"lease lost, entering init state\");\n\t\t\t\tudhcp_run_script(NULL, \"deconfig\");\n\t\t\t\tstate = INIT_SELECTING;\n\t\t\t\tclient_config.first_secs = 0; /* make secs field count from 0 */\n\t\t\t\t/*timeout = 0; - already is */\n\t\t\t\tpacket_num = 0;\n\t\t\t\tcontinue;\n\t\t\t/* case RELEASED: */\n\t\t\t}\n\t\t\t/* yah, I know, *you* say it would never happen */\n\t\t\ttimeout = INT_MAX;\n\t\t\tcontinue; /* back to main loop */\n\t\t} /* if poll timed out */\n\n\t\t/* poll() didn't timeout, something happened */\n\n\t\t/* Is it a signal? */\n\t\tswitch (udhcp_sp_read()) {\n\t\tcase SIGUSR1:\n\t\t\tclient_config.first_secs = 0; /* make secs field count from 0 */\n\t\t\talready_waited_sec = 0;\n\t\t\tperform_renew();\n\t\t\tif (state == RENEW_REQUESTED) {\n\t\t\t\t/* We might be either on the same network\n\t\t\t\t * (in which case renew might work),\n\t\t\t\t * or we might be on a completely different one\n\t\t\t\t * (in which case renew won't ever succeed).\n\t\t\t\t * For the second case, must make sure timeout\n\t\t\t\t * is not too big, or else we can send\n\t\t\t\t * futile renew requests for hours.\n\t\t\t\t */\n\t\t\t\tif (timeout > 60)\n\t\t\t\t\ttimeout = 60;\n\t\t\t\tgoto case_RENEW_REQUESTED;\n\t\t\t}\n\t\t\t/* Start things over */\n\t\t\tpacket_num = 0;\n\t\t\t/* Kill any timeouts, user wants this to hurry along */\n\t\t\ttimeout = 0;\n\t\t\tcontinue;\n\t\tcase SIGUSR2:\n\t\t\tperform_release(server_addr, requested_ip);\n\t\t\ttimeout = INT_MAX;\n\t\t\tcontinue;\n\t\tcase SIGTERM:\n\t\t\tbb_error_msg(\"received %s\", \"SIGTERM\");\n\t\t\tgoto ret0;\n\t\t}\n\n\t\t/* Is it a packet? */\n\t\tif (!pfds[1].revents)\n\t\t\tcontinue; /* no */\n\n\t\t{\n\t\t\tint len;\n\n\t\t\t/* A packet is ready, read it */\n\t\t\tif (listen_mode == LISTEN_KERNEL)\n\t\t\t\tlen = udhcp_recv_kernel_packet(&packet, sockfd);\n\t\t\telse\n\t\t\t\tlen = udhcp_recv_raw_packet(&packet, sockfd);\n\t\t\tif (len == -1) {\n\t\t\t\t/* Error is severe, reopen socket */\n\t\t\t\tbb_error_msg(\"read error: \"STRERROR_FMT\", reopening socket\" STRERROR_ERRNO);\n\t\t\t\tsleep(discover_timeout); /* 3 seconds by default */\n\t\t\t\tchange_listen_mode(listen_mode); /* just close and reopen */\n\t\t\t}\n\t\t\t/* If this packet will turn out to be unrelated/bogus,\n\t\t\t * we will go back and wait for next one.\n\t\t\t * Be sure timeout is properly decreased. */\n\t\t\talready_waited_sec += (unsigned)monotonic_sec() - timestamp_before_wait;\n\t\t\tif (len < 0)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (packet.xid != xid) {\n\t\t\tlog1(\"xid %x (our is %x), ignoring packet\",\n\t\t\t\t(unsigned)packet.xid, (unsigned)xid);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Ignore packets that aren't for us */\n\t\tif (packet.hlen != 6\n\t\t || memcmp(packet.chaddr, client_config.client_mac, 6) != 0\n\t\t) {\n\t\t\tlog1(\"chaddr does not match, ignoring packet\"); // log2?\n\t\t\tcontinue;\n\t\t}\n\n\t\tmessage = udhcp_get_option(&packet, DHCP_MESSAGE_TYPE);\n\t\tif (message == NULL) {\n\t\t\tbb_error_msg(\"no message type option, ignoring packet\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (state) {\n\t\tcase INIT_SELECTING:\n\t\t\t/* Must be a DHCPOFFER */\n\t\t\tif (*message == DHCPOFFER) {\n\t\t\t\tuint8_t *temp;\n\n/* What exactly is server's IP? There are several values.\n * Example DHCP offer captured with tchdump:\n *\n * 10.34.25.254:67 > 10.34.25.202:68 // IP header's src\n * BOOTP fields:\n * Your-IP 10.34.25.202\n * Server-IP 10.34.32.125   // \"next server\" IP\n * Gateway-IP 10.34.25.254  // relay's address (if DHCP relays are in use)\n * DHCP options:\n * DHCP-Message Option 53, length 1: Offer\n * Server-ID Option 54, length 4: 10.34.255.7       // \"server ID\"\n * Default-Gateway Option 3, length 4: 10.34.25.254 // router\n *\n * We think that real server IP (one to use in renew/release)\n * is one in Server-ID option. But I am not 100% sure.\n * IP header's src and Gateway-IP (same in this example)\n * might work too.\n * \"Next server\" and router are definitely wrong ones to use, though...\n */\n/* We used to ignore pcakets without DHCP_SERVER_ID.\n * I've got user reports from people who run \"address-less\" servers.\n * They either supply DHCP_SERVER_ID of 0.0.0.0 or don't supply it at all.\n  * They say ISC DHCP client supports this case.\n  */\n \t\t\t\tserver_addr = 0;\n\t\t\t\ttemp = udhcp_get_option32(&packet, DHCP_SERVER_ID);\n \t\t\t\tif (!temp) {\n \t\t\t\t\tbb_error_msg(\"no server ID, using 0.0.0.0\");\n \t\t\t\t} else {\n\t\t\t\t\t/* it IS unaligned sometimes, don't \"optimize\" */\n\t\t\t\t\tmove_from_unaligned32(server_addr, temp);\n\t\t\t\t}\n\t\t\t\t/*xid = packet.xid; - already is */\n\t\t\t\trequested_ip = packet.yiaddr;\n\n\t\t\t\t/* enter requesting state */\n\t\t\t\tstate = REQUESTING;\n\t\t\t\ttimeout = 0;\n\t\t\t\tpacket_num = 0;\n\t\t\t\talready_waited_sec = 0;\n\t\t\t}\n\t\t\tcontinue;\n\t\tcase REQUESTING:\n\t\tcase RENEWING:\n\t\tcase RENEW_REQUESTED:\n\t\tcase REBINDING:\n\t\t\tif (*message == DHCPACK) {\n\t\t\t\tunsigned start;\n\t\t\t\tuint32_t lease_seconds;\n \t\t\t\tstruct in_addr temp_addr;\n \t\t\t\tuint8_t *temp;\n \n\t\t\t\ttemp = udhcp_get_option32(&packet, DHCP_LEASE_TIME);\n \t\t\t\tif (!temp) {\n \t\t\t\t\tbb_error_msg(\"no lease time with ACK, using 1 hour lease\");\n \t\t\t\t\tlease_seconds = 60 * 60;\n\t\t\t\t} else {\n\t\t\t\t\t/* it IS unaligned sometimes, don't \"optimize\" */\n\t\t\t\t\tmove_from_unaligned32(lease_seconds, temp);\n\t\t\t\t\tlease_seconds = ntohl(lease_seconds);\n\t\t\t\t\t/* paranoia: must not be too small and not prone to overflows */\n\t\t\t\t\t/* timeout > 60 - ensures at least one unicast renew attempt */\n\t\t\t\t\tif (lease_seconds < 2 * 61)\n\t\t\t\t\t\tlease_seconds = 2 * 61;\n\t\t\t\t}\n#if ENABLE_FEATURE_UDHCPC_ARPING\n\t\t\t\tif (opt & OPT_a) {\n/* RFC 2131 3.1 paragraph 5:\n * \"The client receives the DHCPACK message with configuration\n * parameters. The client SHOULD perform a final check on the\n * parameters (e.g., ARP for allocated network address), and notes\n * the duration of the lease specified in the DHCPACK message. At this\n * point, the client is configured. If the client detects that the\n * address is already in use (e.g., through the use of ARP),\n * the client MUST send a DHCPDECLINE message to the server and restarts\n * the configuration process...\" */\n\t\t\t\t\tif (!arpping(packet.yiaddr,\n\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t(uint32_t) 0,\n\t\t\t\t\t\t\tclient_config.client_mac,\n\t\t\t\t\t\t\tclient_config.interface,\n\t\t\t\t\t\t\tarpping_ms)\n\t\t\t\t\t) {\n\t\t\t\t\t\tbb_error_msg(\"offered address is in use \"\n\t\t\t\t\t\t\t\"(got ARP reply), declining\");\n\t\t\t\t\t\tsend_decline(/*xid,*/ server_addr, packet.yiaddr);\n\n\t\t\t\t\t\tif (state != REQUESTING)\n\t\t\t\t\t\t\tudhcp_run_script(NULL, \"deconfig\");\n\t\t\t\t\t\tchange_listen_mode(LISTEN_RAW);\n\t\t\t\t\t\tstate = INIT_SELECTING;\n\t\t\t\t\t\tclient_config.first_secs = 0; /* make secs field count from 0 */\n\t\t\t\t\t\trequested_ip = 0;\n\t\t\t\t\t\ttimeout = tryagain_timeout;\n\t\t\t\t\t\tpacket_num = 0;\n\t\t\t\t\t\talready_waited_sec = 0;\n\t\t\t\t\t\tcontinue; /* back to main loop */\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\t\t/* enter bound state */\n\t\t\t\ttemp_addr.s_addr = packet.yiaddr;\n\t\t\t\tbb_error_msg(\"lease of %s obtained, lease time %u\",\n\t\t\t\t\tinet_ntoa(temp_addr), (unsigned)lease_seconds);\n\t\t\t\trequested_ip = packet.yiaddr;\n\n\t\t\t\tstart = monotonic_sec();\n\t\t\t\tudhcp_run_script(&packet, state == REQUESTING ? \"bound\" : \"renew\");\n\t\t\t\talready_waited_sec = (unsigned)monotonic_sec() - start;\n\t\t\t\ttimeout = lease_seconds / 2;\n\t\t\t\tif ((unsigned)timeout < already_waited_sec) {\n\t\t\t\t\t/* Something went wrong. Back to discover state */\n\t\t\t\t\ttimeout = already_waited_sec = 0;\n\t\t\t\t}\n\n\t\t\t\tstate = BOUND;\n\t\t\t\tchange_listen_mode(LISTEN_NONE);\n\t\t\t\tif (opt & OPT_q) { /* quit after lease */\n\t\t\t\t\tgoto ret0;\n\t\t\t\t}\n\t\t\t\t/* future renew failures should not exit (JM) */\n\t\t\t\topt &= ~OPT_n;\n#if BB_MMU /* NOMMU case backgrounded earlier */\n\t\t\t\tif (!(opt & OPT_f)) {\n\t\t\t\t\tclient_background();\n\t\t\t\t\t/* do not background again! */\n\t\t\t\t\topt = ((opt & ~OPT_b) | OPT_f);\n\t\t\t\t}\n#endif\n\t\t\t\t/* make future renew packets use different xid */\n\t\t\t\t/* xid = random_xid(); ...but why bother? */\n\n\t\t\t\tcontinue; /* back to main loop */\n\t\t\t}\n\t\t\tif (*message == DHCPNAK) {\n\t\t\t\t/* If network has more than one DHCP server,\n\t\t\t\t * \"wrong\" server can reply first, with a NAK.\n\t\t\t\t * Do not interpret it as a NAK from \"our\" server.\n\t\t\t\t */\n\t\t\t\tif (server_addr != 0) {\n \t\t\t\t\tuint32_t svid;\n \t\t\t\t\tuint8_t *temp;\n \n\t\t\t\t\ttemp = udhcp_get_option32(&packet, DHCP_SERVER_ID);\n \t\t\t\t\tif (!temp) {\n  non_matching_svid:\n \t\t\t\t\t\tlog1(\"received DHCP NAK with wrong\"\n\t\t\t\t\t\t\t\" server ID, ignoring packet\");\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tmove_from_unaligned32(svid, temp);\n\t\t\t\t\tif (svid != server_addr)\n\t\t\t\t\t\tgoto non_matching_svid;\n\t\t\t\t}\n\t\t\t\t/* return to init state */\n\t\t\t\tbb_error_msg(\"received %s\", \"DHCP NAK\");\n\t\t\t\tudhcp_run_script(&packet, \"nak\");\n\t\t\t\tif (state != REQUESTING)\n\t\t\t\t\tudhcp_run_script(NULL, \"deconfig\");\n\t\t\t\tchange_listen_mode(LISTEN_RAW);\n\t\t\t\tsleep(3); /* avoid excessive network traffic */\n\t\t\t\tstate = INIT_SELECTING;\n\t\t\t\tclient_config.first_secs = 0; /* make secs field count from 0 */\n\t\t\t\trequested_ip = 0;\n\t\t\t\ttimeout = 0;\n\t\t\t\tpacket_num = 0;\n\t\t\t\talready_waited_sec = 0;\n\t\t\t}\n\t\t\tcontinue;\n\t\t/* case BOUND: - ignore all packets */\n\t\t/* case RELEASED: - ignore all packets */\n\t\t}\n\t\t/* back to main loop */\n\t} /* for (;;) - main loop ends */\n\n ret0:\n\tif (opt & OPT_R) /* release on quit */\n\t\tperform_release(server_addr, requested_ip);\n\tretval = 0;\n ret:\n\t/*if (client_config.pidfile) - remove_pidfile has its own check */\n\t\tremove_pidfile(client_config.pidfile);\n\treturn retval;\n}\n",
    "cwe": [
      "CWE-125"
    ],
    "id": 417,
    "_valid_cwes": [
      "CWE-125"
    ]
  },
  {
    "cve_id": "CVE-2017-6430",
    "code_before_change": " int main(int argc, char *argv[])\n {\n    libettercap_init();\n    ef_globals_alloc();\n    select_text_interface();\n   libettercap_ui_init();\n   /* etterfilter copyright */\n   fprintf(stdout, \"\\n\" EC_COLOR_BOLD \"%s %s\" EC_COLOR_END \" copyright %s %s\\n\\n\", \n                      PROGRAM, EC_VERSION, EC_COPYRIGHT, EC_AUTHORS);\n \n   /* initialize the line number */\n   EF_GBL->lineno = 1;\n  \n   /* getopt related parsing...  */\n   parse_options(argc, argv);\n\n   /* set the input for source file */\n   if (EF_GBL_OPTIONS->source_file) {\n      yyin = fopen(EF_GBL_OPTIONS->source_file, \"r\");\n      if (yyin == NULL)\n         FATAL_ERROR(\"Input file not found !\");\n   } else {\n      FATAL_ERROR(\"No source file.\");\n   }\n\n   /* no buffering */\n   setbuf(yyin, NULL);\n   setbuf(stdout, NULL);\n   setbuf(stderr, NULL);\n\n   \n   /* load the tables in etterfilter.tbl */\n   load_tables();\n   /* load the constants in etterfilter.cnt */\n   load_constants();\n\n   /* print the message */\n   fprintf(stdout, \"\\n Parsing source file \\'%s\\' \", EF_GBL_OPTIONS->source_file);\n   fflush(stdout);\n\n   ef_debug(1, \"\\n\");\n\n   /* begin the parsing */\n   if (yyparse() == 0)\n      fprintf(stdout, \" done.\\n\\n\");\n   else\n       fprintf(stdout, \"\\n\\nThe script contains errors...\\n\\n\");\n   \n    /* write to file */\n   if (write_output() != E_SUCCESS)\n      FATAL_ERROR(\"Cannot write output file (%s)\", EF_GBL_OPTIONS->output_file);\n    ef_globals_free();\n    return 0;\n }\n",
    "code_after_change": " int main(int argc, char *argv[])\n {\n   int ret_value = 0;\n    libettercap_init();\n    ef_globals_alloc();\n    select_text_interface();\n   libettercap_ui_init();\n   /* etterfilter copyright */\n   fprintf(stdout, \"\\n\" EC_COLOR_BOLD \"%s %s\" EC_COLOR_END \" copyright %s %s\\n\\n\", \n                      PROGRAM, EC_VERSION, EC_COPYRIGHT, EC_AUTHORS);\n \n   /* initialize the line number */\n   EF_GBL->lineno = 1;\n  \n   /* getopt related parsing...  */\n   parse_options(argc, argv);\n\n   /* set the input for source file */\n   if (EF_GBL_OPTIONS->source_file) {\n      yyin = fopen(EF_GBL_OPTIONS->source_file, \"r\");\n      if (yyin == NULL)\n         FATAL_ERROR(\"Input file not found !\");\n   } else {\n      FATAL_ERROR(\"No source file.\");\n   }\n\n   /* no buffering */\n   setbuf(yyin, NULL);\n   setbuf(stdout, NULL);\n   setbuf(stderr, NULL);\n\n   \n   /* load the tables in etterfilter.tbl */\n   load_tables();\n   /* load the constants in etterfilter.cnt */\n   load_constants();\n\n   /* print the message */\n   fprintf(stdout, \"\\n Parsing source file \\'%s\\' \", EF_GBL_OPTIONS->source_file);\n   fflush(stdout);\n\n   ef_debug(1, \"\\n\");\n\n   /* begin the parsing */\n   if (yyparse() == 0)\n      fprintf(stdout, \" done.\\n\\n\");\n   else\n       fprintf(stdout, \"\\n\\nThe script contains errors...\\n\\n\");\n   \n    /* write to file */\n   ret_value = write_output();\n   if (ret_value == -E_NOTHANDLED)\n      FATAL_ERROR(\"Cannot write output file (%s): the filter is not correctly handled.\", EF_GBL_OPTIONS->output_file);\n   else if (ret_value == -E_INVALID)\n      FATAL_ERROR(\"Cannot write output file (%s): the filter format is not correct. \", EF_GBL_OPTIONS->output_file);\n\n    ef_globals_free();\n    return 0;\n }\n",
    "cwe": [
      "CWE-125"
    ],
    "id": 425,
    "_valid_cwes": [
      "CWE-125"
    ]
  },
  {
    "cve_id": "CVE-2018-11375",
    "code_before_change": " INST_HANDLER (lds) {\t// LDS Rd, k\n \tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n \tint k = (buf[3] << 8) | buf[2];\n \top->ptr = k;\n\n\t__generic_ld_st (op, \"ram\", 0, 1, 0, k, 0);\n\tESIL_A (\"r%d,=,\", d);\n}\n",
    "code_after_change": " INST_HANDLER (lds) {\t// LDS Rd, k\n\tif (len < 4) {\n\t\treturn;\n\t}\n \tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n \tint k = (buf[3] << 8) | buf[2];\n \top->ptr = k;\n\n\t__generic_ld_st (op, \"ram\", 0, 1, 0, k, 0);\n\tESIL_A (\"r%d,=,\", d);\n}\n",
    "cwe": [
      "CWE-125"
    ],
    "id": 450,
    "_valid_cwes": [
      "CWE-125"
    ]
  },
  {
    "cve_id": "CVE-2018-16842",
    "code_before_change": "static void voutf(struct GlobalConfig *config,\n                  const char *prefix,\n                  const char *fmt,\n                  va_list ap)\n{\n  size_t width = (79 - strlen(prefix));\n  if(!config->mute) {\n    size_t len;\n    char *ptr;\n    char *print_buffer;\n\n    print_buffer = curlx_mvaprintf(fmt, ap);\n    if(!print_buffer)\n      return;\n    len = strlen(print_buffer);\n\n    ptr = print_buffer;\n    while(len > 0) {\n      fputs(prefix, config->errors);\n\n      if(len > width) {\n        size_t cut = width-1;\n\n        while(!ISSPACE(ptr[cut]) && cut) {\n          cut--;\n        }\n        if(0 == cut)\n          /* not a single cutting position was found, just cut it at the\n             max text width then! */\n          cut = width-1;\n\n         (void)fwrite(ptr, cut + 1, 1, config->errors);\n         fputs(\"\\n\", config->errors);\n         ptr += cut + 1; /* skip the space too */\n        len -= cut;\n       }\n       else {\n         fputs(ptr, config->errors);\n        len = 0;\n      }\n    }\n    curl_free(print_buffer);\n  }\n}\n",
    "code_after_change": "static void voutf(struct GlobalConfig *config,\n                  const char *prefix,\n                  const char *fmt,\n                  va_list ap)\n{\n  size_t width = (79 - strlen(prefix));\n  if(!config->mute) {\n    size_t len;\n    char *ptr;\n    char *print_buffer;\n\n    print_buffer = curlx_mvaprintf(fmt, ap);\n    if(!print_buffer)\n      return;\n    len = strlen(print_buffer);\n\n    ptr = print_buffer;\n    while(len > 0) {\n      fputs(prefix, config->errors);\n\n      if(len > width) {\n        size_t cut = width-1;\n\n        while(!ISSPACE(ptr[cut]) && cut) {\n          cut--;\n        }\n        if(0 == cut)\n          /* not a single cutting position was found, just cut it at the\n             max text width then! */\n          cut = width-1;\n\n         (void)fwrite(ptr, cut + 1, 1, config->errors);\n         fputs(\"\\n\", config->errors);\n         ptr += cut + 1; /* skip the space too */\n        len -= cut + 1;\n       }\n       else {\n         fputs(ptr, config->errors);\n        len = 0;\n      }\n    }\n    curl_free(print_buffer);\n  }\n}\n",
    "cwe": [
      "CWE-125"
    ],
    "id": 452,
    "_valid_cwes": [
      "CWE-125"
    ]
  },
  {
    "cve_id": "CVE-2017-13046",
    "code_before_change": "bgp_attr_print(netdissect_options *ndo,\n               u_int atype, const u_char *pptr, u_int len)\n{\n\tint i;\n\tuint16_t af;\n\tuint8_t safi, snpa, nhlen;\n        union { /* copy buffer for bandwidth values */\n            float f;\n            uint32_t i;\n        } bw;\n\tint advance;\n\tu_int tlen;\n\tconst u_char *tptr;\n\tchar buf[MAXHOSTNAMELEN + 100];\n        int  as_size;\n\n        tptr = pptr;\n        tlen=len;\n\n\tswitch (atype) {\n\tcase BGPTYPE_ORIGIN:\n\t\tif (len != 1)\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\telse {\n\t\t\tND_TCHECK(*tptr);\n\t\t\tND_PRINT((ndo, \"%s\", tok2str(bgp_origin_values,\n\t\t\t\t\t\t\"Unknown Origin Typecode\",\n\t\t\t\t\t\ttptr[0])));\n\t\t}\n\t\tbreak;\n\n        /*\n         * Process AS4 byte path and AS2 byte path attributes here.\n         */\n\tcase BGPTYPE_AS4_PATH:\n\tcase BGPTYPE_AS_PATH:\n\t\tif (len % 2) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n                if (!len) {\n\t\t\tND_PRINT((ndo, \"empty\"));\n\t\t\tbreak;\n                }\n\n                /*\n                 * BGP updates exchanged between New speakers that support 4\n                 * byte AS, ASs are always encoded in 4 bytes. There is no\n                 * definitive way to find this, just by the packet's\n                 * contents. So, check for packet's TLV's sanity assuming\n                 * 2 bytes first, and it does not pass, assume that ASs are\n                 * encoded in 4 bytes format and move on.\n                 */\n                as_size = bgp_attr_get_as_size(ndo, atype, pptr, len);\n\n\t\twhile (tptr < pptr + len) {\n\t\t\tND_TCHECK(tptr[0]);\n                        ND_PRINT((ndo, \"%s\", tok2str(bgp_as_path_segment_open_values,\n\t\t\t\t\t\t\"?\", tptr[0])));\n\t\t\tND_TCHECK(tptr[1]);\n                        for (i = 0; i < tptr[1] * as_size; i += as_size) {\n                            ND_TCHECK2(tptr[2 + i], as_size);\n\t\t\t    ND_PRINT((ndo, \"%s \",\n\t\t\t\tas_printf(ndo, astostr, sizeof(astostr),\n\t\t\t\tas_size == 2 ?\n\t\t\t\tEXTRACT_16BITS(&tptr[2 + i]) :\n\t\t\t\tEXTRACT_32BITS(&tptr[2 + i]))));\n                        }\n\t\t\tND_TCHECK(tptr[0]);\n                        ND_PRINT((ndo, \"%s\", tok2str(bgp_as_path_segment_close_values,\n\t\t\t\t\t\t\"?\", tptr[0])));\n                        ND_TCHECK(tptr[1]);\n                        tptr += 2 + tptr[1] * as_size;\n\t\t}\n\t\tbreak;\n\tcase BGPTYPE_NEXT_HOP:\n\t\tif (len != 4)\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\telse {\n\t\t\tND_TCHECK2(tptr[0], 4);\n\t\t\tND_PRINT((ndo, \"%s\", ipaddr_string(ndo, tptr)));\n\t\t}\n\t\tbreak;\n\tcase BGPTYPE_MULTI_EXIT_DISC:\n\tcase BGPTYPE_LOCAL_PREF:\n\t\tif (len != 4)\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\telse {\n\t\t\tND_TCHECK2(tptr[0], 4);\n\t\t\tND_PRINT((ndo, \"%u\", EXTRACT_32BITS(tptr)));\n\t\t}\n\t\tbreak;\n\tcase BGPTYPE_ATOMIC_AGGREGATE:\n\t\tif (len != 0)\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\tbreak;\n        case BGPTYPE_AGGREGATOR:\n\n                /*\n                 * Depending on the AS encoded is of 2 bytes or of 4 bytes,\n                 * the length of this PA can be either 6 bytes or 8 bytes.\n                 */\n                if (len != 6 && len != 8) {\n                    ND_PRINT((ndo, \"invalid len\"));\n                    break;\n                }\n                ND_TCHECK2(tptr[0], len);\n                if (len == 6) {\n\t\t    ND_PRINT((ndo, \" AS #%s, origin %s\",\n\t\t\tas_printf(ndo, astostr, sizeof(astostr), EXTRACT_16BITS(tptr)),\n\t\t\tipaddr_string(ndo, tptr + 2)));\n                } else {\n\t\t    ND_PRINT((ndo, \" AS #%s, origin %s\",\n\t\t\tas_printf(ndo, astostr, sizeof(astostr),\n\t\t\tEXTRACT_32BITS(tptr)), ipaddr_string(ndo, tptr + 4)));\n                }\n                break;\n\tcase BGPTYPE_AGGREGATOR4:\n\t\tif (len != 8) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n\t\tND_TCHECK2(tptr[0], 8);\n\t\tND_PRINT((ndo, \" AS #%s, origin %s\",\n\t   \t    as_printf(ndo, astostr, sizeof(astostr), EXTRACT_32BITS(tptr)),\n\t\t    ipaddr_string(ndo, tptr + 4)));\n\t\tbreak;\n\tcase BGPTYPE_COMMUNITIES:\n\t\tif (len % 4) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n\t\twhile (tlen>0) {\n\t\t\tuint32_t comm;\n\t\t\tND_TCHECK2(tptr[0], 4);\n\t\t\tcomm = EXTRACT_32BITS(tptr);\n\t\t\tswitch (comm) {\n\t\t\tcase BGP_COMMUNITY_NO_EXPORT:\n\t\t\t\tND_PRINT((ndo, \" NO_EXPORT\"));\n\t\t\t\tbreak;\n\t\t\tcase BGP_COMMUNITY_NO_ADVERT:\n\t\t\t\tND_PRINT((ndo, \" NO_ADVERTISE\"));\n\t\t\t\tbreak;\n\t\t\tcase BGP_COMMUNITY_NO_EXPORT_SUBCONFED:\n\t\t\t\tND_PRINT((ndo, \" NO_EXPORT_SUBCONFED\"));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tND_PRINT((ndo, \"%u:%u%s\",\n                                       (comm >> 16) & 0xffff,\n                                       comm & 0xffff,\n                                       (tlen>4) ? \", \" : \"\"));\n\t\t\t\tbreak;\n\t\t\t}\n                        tlen -=4;\n                        tptr +=4;\n\t\t}\n\t\tbreak;\n        case BGPTYPE_ORIGINATOR_ID:\n\t\tif (len != 4) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n\t\tND_TCHECK2(tptr[0], 4);\n                ND_PRINT((ndo, \"%s\",ipaddr_string(ndo, tptr)));\n                break;\n        case BGPTYPE_CLUSTER_LIST:\n\t\tif (len % 4) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n                while (tlen>0) {\n\t\t\tND_TCHECK2(tptr[0], 4);\n                        ND_PRINT((ndo, \"%s%s\",\n                               ipaddr_string(ndo, tptr),\n                                (tlen>4) ? \", \" : \"\"));\n                        tlen -=4;\n                        tptr +=4;\n                }\n                break;\n\tcase BGPTYPE_MP_REACH_NLRI:\n\t\tND_TCHECK2(tptr[0], 3);\n\t\taf = EXTRACT_16BITS(tptr);\n\t\tsafi = tptr[2];\n\n                ND_PRINT((ndo, \"\\n\\t    AFI: %s (%u), %sSAFI: %s (%u)\",\n                       tok2str(af_values, \"Unknown AFI\", af),\n                       af,\n                       (safi>128) ? \"vendor specific \" : \"\", /* 128 is meanwhile wellknown */\n                       tok2str(bgp_safi_values, \"Unknown SAFI\", safi),\n                       safi));\n\n                switch(af<<8 | safi) {\n                case (AFNUM_INET<<8 | SAFNUM_UNICAST):\n                case (AFNUM_INET<<8 | SAFNUM_MULTICAST):\n                case (AFNUM_INET<<8 | SAFNUM_UNIMULTICAST):\n                case (AFNUM_INET<<8 | SAFNUM_LABUNICAST):\n                case (AFNUM_INET<<8 | SAFNUM_RT_ROUTING_INFO):\n                case (AFNUM_INET<<8 | SAFNUM_VPNUNICAST):\n                case (AFNUM_INET<<8 | SAFNUM_VPNMULTICAST):\n                case (AFNUM_INET<<8 | SAFNUM_VPNUNIMULTICAST):\n                case (AFNUM_INET<<8 | SAFNUM_MULTICAST_VPN):\n\t\tcase (AFNUM_INET<<8 | SAFNUM_MDT):\n                case (AFNUM_INET6<<8 | SAFNUM_UNICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_MULTICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_UNIMULTICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_LABUNICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_VPNUNICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_VPNMULTICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_VPNUNIMULTICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_UNICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_MULTICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_UNIMULTICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_VPNUNICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_VPNMULTICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_VPNUNIMULTICAST):\n                case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNICAST):\n                case (AFNUM_L2VPN<<8 | SAFNUM_VPNMULTICAST):\n                case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNIMULTICAST):\n                case (AFNUM_VPLS<<8 | SAFNUM_VPLS):\n                    break;\n                default:\n                    ND_TCHECK2(tptr[0], tlen);\n                    ND_PRINT((ndo, \"\\n\\t    no AFI %u / SAFI %u decoder\", af, safi));\n                    if (ndo->ndo_vflag <= 1)\n                        print_unknown_data(ndo, tptr, \"\\n\\t    \", tlen);\n                    goto done;\n                    break;\n                }\n\n                tptr +=3;\n\n\t\tND_TCHECK(tptr[0]);\n\t\tnhlen = tptr[0];\n                tlen = nhlen;\n                tptr++;\n\n\t\tif (tlen) {\n                    int nnh = 0;\n                    ND_PRINT((ndo, \"\\n\\t    nexthop: \"));\n                    while (tlen > 0) {\n                        if ( nnh++ > 0 ) {\n                            ND_PRINT((ndo,  \", \" ));\n                        }\n                        switch(af<<8 | safi) {\n                        case (AFNUM_INET<<8 | SAFNUM_UNICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_MULTICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_UNIMULTICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_LABUNICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_RT_ROUTING_INFO):\n                        case (AFNUM_INET<<8 | SAFNUM_MULTICAST_VPN):\n                        case (AFNUM_INET<<8 | SAFNUM_MDT):\n\t\t\t    if (tlen < (int)sizeof(struct in_addr)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in_addr));\n                                ND_PRINT((ndo, \"%s\",ipaddr_string(ndo, tptr)));\n                                tlen -= sizeof(struct in_addr);\n                                tptr += sizeof(struct in_addr);\n                            }\n                            break;\n                        case (AFNUM_INET<<8 | SAFNUM_VPNUNICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_VPNMULTICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_VPNUNIMULTICAST):\n                            if (tlen < (int)(sizeof(struct in_addr)+BGP_VPN_RD_LEN)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in_addr)+BGP_VPN_RD_LEN);\n                                ND_PRINT((ndo, \"RD: %s, %s\",\n                                       bgp_vpn_rd_print(ndo, tptr),\n                                       ipaddr_string(ndo, tptr+BGP_VPN_RD_LEN)));\n                                tlen -= (sizeof(struct in_addr)+BGP_VPN_RD_LEN);\n                                tptr += (sizeof(struct in_addr)+BGP_VPN_RD_LEN);\n                            }\n                            break;\n                        case (AFNUM_INET6<<8 | SAFNUM_UNICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_MULTICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_UNIMULTICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_LABUNICAST):\n                            if (tlen < (int)sizeof(struct in6_addr)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in6_addr));\n                                ND_PRINT((ndo, \"%s\", ip6addr_string(ndo, tptr)));\n                                tlen -= sizeof(struct in6_addr);\n                                tptr += sizeof(struct in6_addr);\n                            }\n                            break;\n                        case (AFNUM_INET6<<8 | SAFNUM_VPNUNICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_VPNMULTICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_VPNUNIMULTICAST):\n                            if (tlen < (int)(sizeof(struct in6_addr)+BGP_VPN_RD_LEN)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in6_addr)+BGP_VPN_RD_LEN);\n                                ND_PRINT((ndo, \"RD: %s, %s\",\n                                       bgp_vpn_rd_print(ndo, tptr),\n                                       ip6addr_string(ndo, tptr+BGP_VPN_RD_LEN)));\n                                tlen -= (sizeof(struct in6_addr)+BGP_VPN_RD_LEN);\n                                tptr += (sizeof(struct in6_addr)+BGP_VPN_RD_LEN);\n                            }\n                            break;\n                        case (AFNUM_VPLS<<8 | SAFNUM_VPLS):\n                        case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNICAST):\n                        case (AFNUM_L2VPN<<8 | SAFNUM_VPNMULTICAST):\n                        case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNIMULTICAST):\n                            if (tlen < (int)sizeof(struct in_addr)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in_addr));\n                                ND_PRINT((ndo, \"%s\", ipaddr_string(ndo, tptr)));\n                                tlen -= (sizeof(struct in_addr));\n                                tptr += (sizeof(struct in_addr));\n                            }\n                            break;\n                        case (AFNUM_NSAP<<8 | SAFNUM_UNICAST):\n                        case (AFNUM_NSAP<<8 | SAFNUM_MULTICAST):\n                        case (AFNUM_NSAP<<8 | SAFNUM_UNIMULTICAST):\n                            ND_TCHECK2(tptr[0], tlen);\n                            ND_PRINT((ndo, \"%s\", isonsap_string(ndo, tptr, tlen)));\n                            tptr += tlen;\n                            tlen = 0;\n                            break;\n\n                        case (AFNUM_NSAP<<8 | SAFNUM_VPNUNICAST):\n                        case (AFNUM_NSAP<<8 | SAFNUM_VPNMULTICAST):\n                        case (AFNUM_NSAP<<8 | SAFNUM_VPNUNIMULTICAST):\n                            if (tlen < BGP_VPN_RD_LEN+1) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], tlen);\n                                ND_PRINT((ndo, \"RD: %s, %s\",\n                                       bgp_vpn_rd_print(ndo, tptr),\n                                       isonsap_string(ndo, tptr+BGP_VPN_RD_LEN,tlen-BGP_VPN_RD_LEN)));\n                                /* rfc986 mapped IPv4 address ? */\n                                if (EXTRACT_32BITS(tptr+BGP_VPN_RD_LEN) ==  0x47000601)\n                                    ND_PRINT((ndo, \" = %s\", ipaddr_string(ndo, tptr+BGP_VPN_RD_LEN+4)));\n                                /* rfc1888 mapped IPv6 address ? */\n                                else if (EXTRACT_24BITS(tptr+BGP_VPN_RD_LEN) ==  0x350000)\n                                    ND_PRINT((ndo, \" = %s\", ip6addr_string(ndo, tptr+BGP_VPN_RD_LEN+3)));\n                                tptr += tlen;\n                                tlen = 0;\n                            }\n                            break;\n                        default:\n                            ND_TCHECK2(tptr[0], tlen);\n                            ND_PRINT((ndo, \"no AFI %u/SAFI %u decoder\", af, safi));\n                            if (ndo->ndo_vflag <= 1)\n                                print_unknown_data(ndo, tptr, \"\\n\\t    \", tlen);\n                            tptr += tlen;\n                            tlen = 0;\n                            goto done;\n                            break;\n                        }\n                    }\n\t\t}\n\t\tND_PRINT((ndo, \", nh-length: %u\", nhlen));\n\t\ttptr += tlen;\n\n\t\tND_TCHECK(tptr[0]);\n\t\tsnpa = tptr[0];\n\t\ttptr++;\n\n\t\tif (snpa) {\n\t\t\tND_PRINT((ndo, \"\\n\\t    %u SNPA\", snpa));\n\t\t\tfor (/*nothing*/; snpa > 0; snpa--) {\n\t\t\t\tND_TCHECK(tptr[0]);\n\t\t\t\tND_PRINT((ndo, \"\\n\\t      %d bytes\", tptr[0]));\n\t\t\t\ttptr += tptr[0] + 1;\n\t\t\t}\n\t\t} else {\n\t\t\tND_PRINT((ndo, \", no SNPA\"));\n                }\n\n\t\twhile (tptr < pptr + len) {\n                    switch (af<<8 | safi) {\n                    case (AFNUM_INET<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_prefix4(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_LABUNICAST):\n                        advance = decode_labeled_prefix4(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_prefix4(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_RT_ROUTING_INFO):\n                        advance = decode_rt_routing_info(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_MULTICAST_VPN): /* fall through */\n                    case (AFNUM_INET6<<8 | SAFNUM_MULTICAST_VPN):\n                        advance = decode_multicast_vpn(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n\n\t\t    case (AFNUM_INET<<8 | SAFNUM_MDT):\n\t\t      advance = decode_mdt_vpn_nlri(ndo, tptr, buf, sizeof(buf));\n\t\t      if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n\t\t       break;\n                    case (AFNUM_INET6<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_prefix6(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_LABUNICAST):\n                        advance = decode_labeled_prefix6(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_prefix6(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_VPLS<<8 | SAFNUM_VPLS):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_l2(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_NSAP<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_clnp_prefix(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_clnp_prefix(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    default:\n                        ND_TCHECK2(*tptr,tlen);\n                        ND_PRINT((ndo, \"\\n\\t    no AFI %u / SAFI %u decoder\", af, safi));\n                        if (ndo->ndo_vflag <= 1)\n                            print_unknown_data(ndo, tptr, \"\\n\\t    \", tlen);\n                        advance = 0;\n                        tptr = pptr + len;\n                        break;\n                    }\n                    if (advance < 0)\n                        break;\n                    tptr += advance;\n\t\t}\n        done:\n\t\tbreak;\n\n\tcase BGPTYPE_MP_UNREACH_NLRI:\n\t\tND_TCHECK2(tptr[0], BGP_MP_NLRI_MINSIZE);\n\t\taf = EXTRACT_16BITS(tptr);\n\t\tsafi = tptr[2];\n\n                ND_PRINT((ndo, \"\\n\\t    AFI: %s (%u), %sSAFI: %s (%u)\",\n                       tok2str(af_values, \"Unknown AFI\", af),\n                       af,\n                       (safi>128) ? \"vendor specific \" : \"\", /* 128 is meanwhile wellknown */\n                       tok2str(bgp_safi_values, \"Unknown SAFI\", safi),\n                       safi));\n\n                if (len == BGP_MP_NLRI_MINSIZE)\n                    ND_PRINT((ndo, \"\\n\\t      End-of-Rib Marker (empty NLRI)\"));\n\n\t\ttptr += 3;\n\n\t\twhile (tptr < pptr + len) {\n                    switch (af<<8 | safi) {\n                    case (AFNUM_INET<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_prefix4(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_LABUNICAST):\n                        advance = decode_labeled_prefix4(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_prefix4(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_prefix6(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_LABUNICAST):\n                        advance = decode_labeled_prefix6(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_prefix6(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_VPLS<<8 | SAFNUM_VPLS):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_l2(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_NSAP<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_clnp_prefix(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_clnp_prefix(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n\t\t    case (AFNUM_INET<<8 | SAFNUM_MDT):\n\t\t      advance = decode_mdt_vpn_nlri(ndo, tptr, buf, sizeof(buf));\n\t\t      if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n\t\t       break;\n                    case (AFNUM_INET<<8 | SAFNUM_MULTICAST_VPN): /* fall through */\n                    case (AFNUM_INET6<<8 | SAFNUM_MULTICAST_VPN):\n                        advance = decode_multicast_vpn(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    default:\n                        ND_TCHECK2(*(tptr-3),tlen);\n                        ND_PRINT((ndo, \"no AFI %u / SAFI %u decoder\", af, safi));\n                        if (ndo->ndo_vflag <= 1)\n                            print_unknown_data(ndo, tptr-3, \"\\n\\t    \", tlen);\n                        advance = 0;\n                        tptr = pptr + len;\n                        break;\n                    }\n                    if (advance < 0)\n                        break;\n                    tptr += advance;\n\t\t}\n\t\tbreak;\n        case BGPTYPE_EXTD_COMMUNITIES:\n\t\tif (len % 8) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n                while (tlen>0) {\n                    uint16_t extd_comm;\n\n                    ND_TCHECK2(tptr[0], 2);\n                    extd_comm=EXTRACT_16BITS(tptr);\n\n\t\t    ND_PRINT((ndo, \"\\n\\t    %s (0x%04x), Flags [%s]\",\n\t\t\t   tok2str(bgp_extd_comm_subtype_values,\n\t\t\t\t      \"unknown extd community typecode\",\n\t\t\t\t      extd_comm),\n\t\t\t   extd_comm,\n\t\t\t   bittok2str(bgp_extd_comm_flag_values, \"none\", extd_comm)));\n\n                    ND_TCHECK2(*(tptr+2), 6);\n                    switch(extd_comm) {\n                    case BGP_EXT_COM_RT_0:\n                    case BGP_EXT_COM_RO_0:\n                    case BGP_EXT_COM_L2VPN_RT_0:\n                        ND_PRINT((ndo, \": %u:%u (= %s)\",\n                               EXTRACT_16BITS(tptr+2),\n                               EXTRACT_32BITS(tptr+4),\n                               ipaddr_string(ndo, tptr+4)));\n                        break;\n                    case BGP_EXT_COM_RT_1:\n                    case BGP_EXT_COM_RO_1:\n                    case BGP_EXT_COM_L2VPN_RT_1:\n                    case BGP_EXT_COM_VRF_RT_IMP:\n                        ND_PRINT((ndo, \": %s:%u\",\n                               ipaddr_string(ndo, tptr+2),\n                               EXTRACT_16BITS(tptr+6)));\n                        break;\n                    case BGP_EXT_COM_RT_2:\n                    case BGP_EXT_COM_RO_2:\n\t\t\tND_PRINT((ndo, \": %s:%u\",\n\t\t\t    as_printf(ndo, astostr, sizeof(astostr),\n\t\t\t    EXTRACT_32BITS(tptr+2)), EXTRACT_16BITS(tptr+6)));\n\t\t\tbreak;\n                    case BGP_EXT_COM_LINKBAND:\n\t\t        bw.i = EXTRACT_32BITS(tptr+2);\n                        ND_PRINT((ndo, \": bandwidth: %.3f Mbps\",\n                               bw.f*8/1000000));\n                        break;\n                    case BGP_EXT_COM_VPN_ORIGIN:\n                    case BGP_EXT_COM_VPN_ORIGIN2:\n                    case BGP_EXT_COM_VPN_ORIGIN3:\n                    case BGP_EXT_COM_VPN_ORIGIN4:\n                    case BGP_EXT_COM_OSPF_RID:\n                    case BGP_EXT_COM_OSPF_RID2:\n                        ND_PRINT((ndo, \"%s\", ipaddr_string(ndo, tptr+2)));\n                        break;\n                    case BGP_EXT_COM_OSPF_RTYPE:\n                    case BGP_EXT_COM_OSPF_RTYPE2:\n                        ND_PRINT((ndo, \": area:%s, router-type:%s, metric-type:%s%s\",\n                               ipaddr_string(ndo, tptr+2),\n                               tok2str(bgp_extd_comm_ospf_rtype_values,\n\t\t\t\t\t  \"unknown (0x%02x)\",\n\t\t\t\t\t  *(tptr+6)),\n                               (*(tptr+7) &  BGP_OSPF_RTYPE_METRIC_TYPE) ? \"E2\" : \"\",\n                               ((*(tptr+6) == BGP_OSPF_RTYPE_EXT) || (*(tptr+6) == BGP_OSPF_RTYPE_NSSA)) ? \"E1\" : \"\"));\n                        break;\n                    case BGP_EXT_COM_L2INFO:\n                        ND_PRINT((ndo, \": %s Control Flags [0x%02x]:MTU %u\",\n                               tok2str(l2vpn_encaps_values,\n\t\t\t\t\t  \"unknown encaps\",\n\t\t\t\t\t  *(tptr+2)),\n                                       *(tptr+3),\n                               EXTRACT_16BITS(tptr+4)));\n                        break;\n                    case BGP_EXT_COM_SOURCE_AS:\n                        ND_PRINT((ndo, \": AS %u\", EXTRACT_16BITS(tptr+2)));\n                        break;\n                    default:\n                        ND_TCHECK2(*tptr,8);\n                        print_unknown_data(ndo, tptr, \"\\n\\t      \", 8);\n                        break;\n                    }\n                    tlen -=8;\n                    tptr +=8;\n                }\n                break;\n\n        case BGPTYPE_PMSI_TUNNEL:\n         {\n                 uint8_t tunnel_type, flags;\n \n                 tunnel_type = *(tptr+1);\n                 flags = *tptr;\n                 tlen = len;\n \n                ND_TCHECK2(tptr[0], 5);\n                 ND_PRINT((ndo, \"\\n\\t    Tunnel-type %s (%u), Flags [%s], MPLS Label %u\",\n                        tok2str(bgp_pmsi_tunnel_values, \"Unknown\", tunnel_type),\n                        tunnel_type,\n                       bittok2str(bgp_pmsi_flag_values, \"none\", flags),\n                       EXTRACT_24BITS(tptr+2)>>4));\n\n                tptr +=5;\n                tlen -= 5;\n\n                switch (tunnel_type) {\n                case BGP_PMSI_TUNNEL_PIM_SM: /* fall through */\n                case BGP_PMSI_TUNNEL_PIM_BIDIR:\n                    ND_TCHECK2(tptr[0], 8);\n                    ND_PRINT((ndo, \"\\n\\t      Sender %s, P-Group %s\",\n                           ipaddr_string(ndo, tptr),\n                           ipaddr_string(ndo, tptr+4)));\n                    break;\n\n                case BGP_PMSI_TUNNEL_PIM_SSM:\n                    ND_TCHECK2(tptr[0], 8);\n                    ND_PRINT((ndo, \"\\n\\t      Root-Node %s, P-Group %s\",\n                           ipaddr_string(ndo, tptr),\n                           ipaddr_string(ndo, tptr+4)));\n                    break;\n                case BGP_PMSI_TUNNEL_INGRESS:\n                    ND_TCHECK2(tptr[0], 4);\n                    ND_PRINT((ndo, \"\\n\\t      Tunnel-Endpoint %s\",\n                           ipaddr_string(ndo, tptr)));\n                    break;\n                case BGP_PMSI_TUNNEL_LDP_P2MP: /* fall through */\n                case BGP_PMSI_TUNNEL_LDP_MP2MP:\n                    ND_TCHECK2(tptr[0], 8);\n                    ND_PRINT((ndo, \"\\n\\t      Root-Node %s, LSP-ID 0x%08x\",\n                           ipaddr_string(ndo, tptr),\n                           EXTRACT_32BITS(tptr+4)));\n                    break;\n                case BGP_PMSI_TUNNEL_RSVP_P2MP:\n                    ND_TCHECK2(tptr[0], 8);\n                    ND_PRINT((ndo, \"\\n\\t      Extended-Tunnel-ID %s, P2MP-ID 0x%08x\",\n                           ipaddr_string(ndo, tptr),\n                           EXTRACT_32BITS(tptr+4)));\n                    break;\n                default:\n                    if (ndo->ndo_vflag <= 1) {\n                        print_unknown_data(ndo, tptr, \"\\n\\t      \", tlen);\n                    }\n                }\n                break;\n        }\n\tcase BGPTYPE_AIGP:\n\t{\n\t\tuint8_t type;\n\t\tuint16_t length;\n\n\t\ttlen = len;\n\n\t\twhile (tlen >= 3) {\n\n\t\t    ND_TCHECK2(tptr[0], 3);\n\n\t\t    type = *tptr;\n\t\t    length = EXTRACT_16BITS(tptr+1);\n\t\t    tptr += 3;\n\t\t    tlen -= 3;\n\n\t\t    ND_PRINT((ndo, \"\\n\\t    %s TLV (%u), length %u\",\n\t\t\t      tok2str(bgp_aigp_values, \"Unknown\", type),\n\t\t\t      type, length));\n\n\t\t    if (length < 3)\n\t\t\tgoto trunc;\n\t\t    length -= 3;\n\n\t\t    /*\n\t\t     * Check if we can read the TLV data.\n\t\t     */\n\t\t    ND_TCHECK2(tptr[3], length);\n\n\t\t    switch (type) {\n\n\t\t    case BGP_AIGP_TLV:\n\t\t        if (length < 8)\n\t\t            goto trunc;\n\t\t\tND_PRINT((ndo, \", metric %\" PRIu64,\n\t\t\t\t  EXTRACT_64BITS(tptr)));\n\t\t\tbreak;\n\n\t\t    default:\n\t\t\tif (ndo->ndo_vflag <= 1) {\n\t\t\t    print_unknown_data(ndo, tptr,\"\\n\\t      \", length);\n\t\t\t}\n\t\t    }\n\n\t\t    tptr += length;\n\t\t    tlen -= length;\n\t\t}\n\t\tbreak;\n\t}\n        case BGPTYPE_ATTR_SET:\n                ND_TCHECK2(tptr[0], 4);\n                if (len < 4)\n                \tgoto trunc;\n\t\tND_PRINT((ndo, \"\\n\\t    Origin AS: %s\",\n\t\t    as_printf(ndo, astostr, sizeof(astostr), EXTRACT_32BITS(tptr))));\n\t\ttptr+=4;\n                len -=4;\n\n                while (len) {\n                    u_int aflags, alenlen, alen;\n\n                    ND_TCHECK2(tptr[0], 2);\n                    if (len < 2)\n                        goto trunc;\n                    aflags = *tptr;\n                    atype = *(tptr + 1);\n                    tptr += 2;\n                    len -= 2;\n                    alenlen = bgp_attr_lenlen(aflags, tptr);\n                    ND_TCHECK2(tptr[0], alenlen);\n                    if (len < alenlen)\n                        goto trunc;\n                    alen = bgp_attr_len(aflags, tptr);\n                    tptr += alenlen;\n                    len -= alenlen;\n\n                    ND_PRINT((ndo, \"\\n\\t      %s (%u), length: %u\",\n                           tok2str(bgp_attr_values,\n                                      \"Unknown Attribute\", atype),\n                           atype,\n                           alen));\n\n                    if (aflags) {\n                        ND_PRINT((ndo, \", Flags [%s%s%s%s\",\n                               aflags & 0x80 ? \"O\" : \"\",\n                               aflags & 0x40 ? \"T\" : \"\",\n                               aflags & 0x20 ? \"P\" : \"\",\n                               aflags & 0x10 ? \"E\" : \"\"));\n                        if (aflags & 0xf)\n                            ND_PRINT((ndo, \"+%x\", aflags & 0xf));\n                        ND_PRINT((ndo, \"]: \"));\n                    }\n                    /* FIXME check for recursion */\n                    if (!bgp_attr_print(ndo, atype, tptr, alen))\n                        return 0;\n                    tptr += alen;\n                    len -= alen;\n\t\t}\n                break;\n\n\tcase BGPTYPE_LARGE_COMMUNITY:\n\t\tif (len == 0 || len % 12) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n\t\tND_PRINT((ndo, \"\\n\\t    \"));\n\t\twhile (len > 0) {\n\t\t\tND_TCHECK2(*tptr, 12);\n\t\t\tND_PRINT((ndo, \"%u:%u:%u%s\",\n\t\t\t\t EXTRACT_32BITS(tptr),\n\t\t\t\t EXTRACT_32BITS(tptr + 4),\n\t\t\t\t EXTRACT_32BITS(tptr + 8),\n\t\t\t\t (len > 12) ? \", \" : \"\"));\n                        tptr += 12;\n                        len -= 12;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t    ND_TCHECK2(*pptr,len);\n            ND_PRINT((ndo, \"\\n\\t    no Attribute %u decoder\", atype)); /* we have no decoder for the attribute */\n            if (ndo->ndo_vflag <= 1)\n                print_unknown_data(ndo, pptr, \"\\n\\t    \", len);\n            break;\n\t}\n        if (ndo->ndo_vflag > 1 && len) { /* omit zero length attributes*/\n            ND_TCHECK2(*pptr,len);\n            print_unknown_data(ndo, pptr, \"\\n\\t    \", len);\n        }\n        return 1;\n\ntrunc:\n        return 0;\n}\n",
    "code_after_change": "bgp_attr_print(netdissect_options *ndo,\n               u_int atype, const u_char *pptr, u_int len)\n{\n\tint i;\n\tuint16_t af;\n\tuint8_t safi, snpa, nhlen;\n        union { /* copy buffer for bandwidth values */\n            float f;\n            uint32_t i;\n        } bw;\n\tint advance;\n\tu_int tlen;\n\tconst u_char *tptr;\n\tchar buf[MAXHOSTNAMELEN + 100];\n        int  as_size;\n\n        tptr = pptr;\n        tlen=len;\n\n\tswitch (atype) {\n\tcase BGPTYPE_ORIGIN:\n\t\tif (len != 1)\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\telse {\n\t\t\tND_TCHECK(*tptr);\n\t\t\tND_PRINT((ndo, \"%s\", tok2str(bgp_origin_values,\n\t\t\t\t\t\t\"Unknown Origin Typecode\",\n\t\t\t\t\t\ttptr[0])));\n\t\t}\n\t\tbreak;\n\n        /*\n         * Process AS4 byte path and AS2 byte path attributes here.\n         */\n\tcase BGPTYPE_AS4_PATH:\n\tcase BGPTYPE_AS_PATH:\n\t\tif (len % 2) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n                if (!len) {\n\t\t\tND_PRINT((ndo, \"empty\"));\n\t\t\tbreak;\n                }\n\n                /*\n                 * BGP updates exchanged between New speakers that support 4\n                 * byte AS, ASs are always encoded in 4 bytes. There is no\n                 * definitive way to find this, just by the packet's\n                 * contents. So, check for packet's TLV's sanity assuming\n                 * 2 bytes first, and it does not pass, assume that ASs are\n                 * encoded in 4 bytes format and move on.\n                 */\n                as_size = bgp_attr_get_as_size(ndo, atype, pptr, len);\n\n\t\twhile (tptr < pptr + len) {\n\t\t\tND_TCHECK(tptr[0]);\n                        ND_PRINT((ndo, \"%s\", tok2str(bgp_as_path_segment_open_values,\n\t\t\t\t\t\t\"?\", tptr[0])));\n\t\t\tND_TCHECK(tptr[1]);\n                        for (i = 0; i < tptr[1] * as_size; i += as_size) {\n                            ND_TCHECK2(tptr[2 + i], as_size);\n\t\t\t    ND_PRINT((ndo, \"%s \",\n\t\t\t\tas_printf(ndo, astostr, sizeof(astostr),\n\t\t\t\tas_size == 2 ?\n\t\t\t\tEXTRACT_16BITS(&tptr[2 + i]) :\n\t\t\t\tEXTRACT_32BITS(&tptr[2 + i]))));\n                        }\n\t\t\tND_TCHECK(tptr[0]);\n                        ND_PRINT((ndo, \"%s\", tok2str(bgp_as_path_segment_close_values,\n\t\t\t\t\t\t\"?\", tptr[0])));\n                        ND_TCHECK(tptr[1]);\n                        tptr += 2 + tptr[1] * as_size;\n\t\t}\n\t\tbreak;\n\tcase BGPTYPE_NEXT_HOP:\n\t\tif (len != 4)\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\telse {\n\t\t\tND_TCHECK2(tptr[0], 4);\n\t\t\tND_PRINT((ndo, \"%s\", ipaddr_string(ndo, tptr)));\n\t\t}\n\t\tbreak;\n\tcase BGPTYPE_MULTI_EXIT_DISC:\n\tcase BGPTYPE_LOCAL_PREF:\n\t\tif (len != 4)\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\telse {\n\t\t\tND_TCHECK2(tptr[0], 4);\n\t\t\tND_PRINT((ndo, \"%u\", EXTRACT_32BITS(tptr)));\n\t\t}\n\t\tbreak;\n\tcase BGPTYPE_ATOMIC_AGGREGATE:\n\t\tif (len != 0)\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\tbreak;\n        case BGPTYPE_AGGREGATOR:\n\n                /*\n                 * Depending on the AS encoded is of 2 bytes or of 4 bytes,\n                 * the length of this PA can be either 6 bytes or 8 bytes.\n                 */\n                if (len != 6 && len != 8) {\n                    ND_PRINT((ndo, \"invalid len\"));\n                    break;\n                }\n                ND_TCHECK2(tptr[0], len);\n                if (len == 6) {\n\t\t    ND_PRINT((ndo, \" AS #%s, origin %s\",\n\t\t\tas_printf(ndo, astostr, sizeof(astostr), EXTRACT_16BITS(tptr)),\n\t\t\tipaddr_string(ndo, tptr + 2)));\n                } else {\n\t\t    ND_PRINT((ndo, \" AS #%s, origin %s\",\n\t\t\tas_printf(ndo, astostr, sizeof(astostr),\n\t\t\tEXTRACT_32BITS(tptr)), ipaddr_string(ndo, tptr + 4)));\n                }\n                break;\n\tcase BGPTYPE_AGGREGATOR4:\n\t\tif (len != 8) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n\t\tND_TCHECK2(tptr[0], 8);\n\t\tND_PRINT((ndo, \" AS #%s, origin %s\",\n\t   \t    as_printf(ndo, astostr, sizeof(astostr), EXTRACT_32BITS(tptr)),\n\t\t    ipaddr_string(ndo, tptr + 4)));\n\t\tbreak;\n\tcase BGPTYPE_COMMUNITIES:\n\t\tif (len % 4) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n\t\twhile (tlen>0) {\n\t\t\tuint32_t comm;\n\t\t\tND_TCHECK2(tptr[0], 4);\n\t\t\tcomm = EXTRACT_32BITS(tptr);\n\t\t\tswitch (comm) {\n\t\t\tcase BGP_COMMUNITY_NO_EXPORT:\n\t\t\t\tND_PRINT((ndo, \" NO_EXPORT\"));\n\t\t\t\tbreak;\n\t\t\tcase BGP_COMMUNITY_NO_ADVERT:\n\t\t\t\tND_PRINT((ndo, \" NO_ADVERTISE\"));\n\t\t\t\tbreak;\n\t\t\tcase BGP_COMMUNITY_NO_EXPORT_SUBCONFED:\n\t\t\t\tND_PRINT((ndo, \" NO_EXPORT_SUBCONFED\"));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tND_PRINT((ndo, \"%u:%u%s\",\n                                       (comm >> 16) & 0xffff,\n                                       comm & 0xffff,\n                                       (tlen>4) ? \", \" : \"\"));\n\t\t\t\tbreak;\n\t\t\t}\n                        tlen -=4;\n                        tptr +=4;\n\t\t}\n\t\tbreak;\n        case BGPTYPE_ORIGINATOR_ID:\n\t\tif (len != 4) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n\t\tND_TCHECK2(tptr[0], 4);\n                ND_PRINT((ndo, \"%s\",ipaddr_string(ndo, tptr)));\n                break;\n        case BGPTYPE_CLUSTER_LIST:\n\t\tif (len % 4) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n                while (tlen>0) {\n\t\t\tND_TCHECK2(tptr[0], 4);\n                        ND_PRINT((ndo, \"%s%s\",\n                               ipaddr_string(ndo, tptr),\n                                (tlen>4) ? \", \" : \"\"));\n                        tlen -=4;\n                        tptr +=4;\n                }\n                break;\n\tcase BGPTYPE_MP_REACH_NLRI:\n\t\tND_TCHECK2(tptr[0], 3);\n\t\taf = EXTRACT_16BITS(tptr);\n\t\tsafi = tptr[2];\n\n                ND_PRINT((ndo, \"\\n\\t    AFI: %s (%u), %sSAFI: %s (%u)\",\n                       tok2str(af_values, \"Unknown AFI\", af),\n                       af,\n                       (safi>128) ? \"vendor specific \" : \"\", /* 128 is meanwhile wellknown */\n                       tok2str(bgp_safi_values, \"Unknown SAFI\", safi),\n                       safi));\n\n                switch(af<<8 | safi) {\n                case (AFNUM_INET<<8 | SAFNUM_UNICAST):\n                case (AFNUM_INET<<8 | SAFNUM_MULTICAST):\n                case (AFNUM_INET<<8 | SAFNUM_UNIMULTICAST):\n                case (AFNUM_INET<<8 | SAFNUM_LABUNICAST):\n                case (AFNUM_INET<<8 | SAFNUM_RT_ROUTING_INFO):\n                case (AFNUM_INET<<8 | SAFNUM_VPNUNICAST):\n                case (AFNUM_INET<<8 | SAFNUM_VPNMULTICAST):\n                case (AFNUM_INET<<8 | SAFNUM_VPNUNIMULTICAST):\n                case (AFNUM_INET<<8 | SAFNUM_MULTICAST_VPN):\n\t\tcase (AFNUM_INET<<8 | SAFNUM_MDT):\n                case (AFNUM_INET6<<8 | SAFNUM_UNICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_MULTICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_UNIMULTICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_LABUNICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_VPNUNICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_VPNMULTICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_VPNUNIMULTICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_UNICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_MULTICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_UNIMULTICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_VPNUNICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_VPNMULTICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_VPNUNIMULTICAST):\n                case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNICAST):\n                case (AFNUM_L2VPN<<8 | SAFNUM_VPNMULTICAST):\n                case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNIMULTICAST):\n                case (AFNUM_VPLS<<8 | SAFNUM_VPLS):\n                    break;\n                default:\n                    ND_TCHECK2(tptr[0], tlen);\n                    ND_PRINT((ndo, \"\\n\\t    no AFI %u / SAFI %u decoder\", af, safi));\n                    if (ndo->ndo_vflag <= 1)\n                        print_unknown_data(ndo, tptr, \"\\n\\t    \", tlen);\n                    goto done;\n                    break;\n                }\n\n                tptr +=3;\n\n\t\tND_TCHECK(tptr[0]);\n\t\tnhlen = tptr[0];\n                tlen = nhlen;\n                tptr++;\n\n\t\tif (tlen) {\n                    int nnh = 0;\n                    ND_PRINT((ndo, \"\\n\\t    nexthop: \"));\n                    while (tlen > 0) {\n                        if ( nnh++ > 0 ) {\n                            ND_PRINT((ndo,  \", \" ));\n                        }\n                        switch(af<<8 | safi) {\n                        case (AFNUM_INET<<8 | SAFNUM_UNICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_MULTICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_UNIMULTICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_LABUNICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_RT_ROUTING_INFO):\n                        case (AFNUM_INET<<8 | SAFNUM_MULTICAST_VPN):\n                        case (AFNUM_INET<<8 | SAFNUM_MDT):\n\t\t\t    if (tlen < (int)sizeof(struct in_addr)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in_addr));\n                                ND_PRINT((ndo, \"%s\",ipaddr_string(ndo, tptr)));\n                                tlen -= sizeof(struct in_addr);\n                                tptr += sizeof(struct in_addr);\n                            }\n                            break;\n                        case (AFNUM_INET<<8 | SAFNUM_VPNUNICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_VPNMULTICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_VPNUNIMULTICAST):\n                            if (tlen < (int)(sizeof(struct in_addr)+BGP_VPN_RD_LEN)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in_addr)+BGP_VPN_RD_LEN);\n                                ND_PRINT((ndo, \"RD: %s, %s\",\n                                       bgp_vpn_rd_print(ndo, tptr),\n                                       ipaddr_string(ndo, tptr+BGP_VPN_RD_LEN)));\n                                tlen -= (sizeof(struct in_addr)+BGP_VPN_RD_LEN);\n                                tptr += (sizeof(struct in_addr)+BGP_VPN_RD_LEN);\n                            }\n                            break;\n                        case (AFNUM_INET6<<8 | SAFNUM_UNICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_MULTICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_UNIMULTICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_LABUNICAST):\n                            if (tlen < (int)sizeof(struct in6_addr)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in6_addr));\n                                ND_PRINT((ndo, \"%s\", ip6addr_string(ndo, tptr)));\n                                tlen -= sizeof(struct in6_addr);\n                                tptr += sizeof(struct in6_addr);\n                            }\n                            break;\n                        case (AFNUM_INET6<<8 | SAFNUM_VPNUNICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_VPNMULTICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_VPNUNIMULTICAST):\n                            if (tlen < (int)(sizeof(struct in6_addr)+BGP_VPN_RD_LEN)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in6_addr)+BGP_VPN_RD_LEN);\n                                ND_PRINT((ndo, \"RD: %s, %s\",\n                                       bgp_vpn_rd_print(ndo, tptr),\n                                       ip6addr_string(ndo, tptr+BGP_VPN_RD_LEN)));\n                                tlen -= (sizeof(struct in6_addr)+BGP_VPN_RD_LEN);\n                                tptr += (sizeof(struct in6_addr)+BGP_VPN_RD_LEN);\n                            }\n                            break;\n                        case (AFNUM_VPLS<<8 | SAFNUM_VPLS):\n                        case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNICAST):\n                        case (AFNUM_L2VPN<<8 | SAFNUM_VPNMULTICAST):\n                        case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNIMULTICAST):\n                            if (tlen < (int)sizeof(struct in_addr)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in_addr));\n                                ND_PRINT((ndo, \"%s\", ipaddr_string(ndo, tptr)));\n                                tlen -= (sizeof(struct in_addr));\n                                tptr += (sizeof(struct in_addr));\n                            }\n                            break;\n                        case (AFNUM_NSAP<<8 | SAFNUM_UNICAST):\n                        case (AFNUM_NSAP<<8 | SAFNUM_MULTICAST):\n                        case (AFNUM_NSAP<<8 | SAFNUM_UNIMULTICAST):\n                            ND_TCHECK2(tptr[0], tlen);\n                            ND_PRINT((ndo, \"%s\", isonsap_string(ndo, tptr, tlen)));\n                            tptr += tlen;\n                            tlen = 0;\n                            break;\n\n                        case (AFNUM_NSAP<<8 | SAFNUM_VPNUNICAST):\n                        case (AFNUM_NSAP<<8 | SAFNUM_VPNMULTICAST):\n                        case (AFNUM_NSAP<<8 | SAFNUM_VPNUNIMULTICAST):\n                            if (tlen < BGP_VPN_RD_LEN+1) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], tlen);\n                                ND_PRINT((ndo, \"RD: %s, %s\",\n                                       bgp_vpn_rd_print(ndo, tptr),\n                                       isonsap_string(ndo, tptr+BGP_VPN_RD_LEN,tlen-BGP_VPN_RD_LEN)));\n                                /* rfc986 mapped IPv4 address ? */\n                                if (EXTRACT_32BITS(tptr+BGP_VPN_RD_LEN) ==  0x47000601)\n                                    ND_PRINT((ndo, \" = %s\", ipaddr_string(ndo, tptr+BGP_VPN_RD_LEN+4)));\n                                /* rfc1888 mapped IPv6 address ? */\n                                else if (EXTRACT_24BITS(tptr+BGP_VPN_RD_LEN) ==  0x350000)\n                                    ND_PRINT((ndo, \" = %s\", ip6addr_string(ndo, tptr+BGP_VPN_RD_LEN+3)));\n                                tptr += tlen;\n                                tlen = 0;\n                            }\n                            break;\n                        default:\n                            ND_TCHECK2(tptr[0], tlen);\n                            ND_PRINT((ndo, \"no AFI %u/SAFI %u decoder\", af, safi));\n                            if (ndo->ndo_vflag <= 1)\n                                print_unknown_data(ndo, tptr, \"\\n\\t    \", tlen);\n                            tptr += tlen;\n                            tlen = 0;\n                            goto done;\n                            break;\n                        }\n                    }\n\t\t}\n\t\tND_PRINT((ndo, \", nh-length: %u\", nhlen));\n\t\ttptr += tlen;\n\n\t\tND_TCHECK(tptr[0]);\n\t\tsnpa = tptr[0];\n\t\ttptr++;\n\n\t\tif (snpa) {\n\t\t\tND_PRINT((ndo, \"\\n\\t    %u SNPA\", snpa));\n\t\t\tfor (/*nothing*/; snpa > 0; snpa--) {\n\t\t\t\tND_TCHECK(tptr[0]);\n\t\t\t\tND_PRINT((ndo, \"\\n\\t      %d bytes\", tptr[0]));\n\t\t\t\ttptr += tptr[0] + 1;\n\t\t\t}\n\t\t} else {\n\t\t\tND_PRINT((ndo, \", no SNPA\"));\n                }\n\n\t\twhile (tptr < pptr + len) {\n                    switch (af<<8 | safi) {\n                    case (AFNUM_INET<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_prefix4(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_LABUNICAST):\n                        advance = decode_labeled_prefix4(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_prefix4(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_RT_ROUTING_INFO):\n                        advance = decode_rt_routing_info(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_MULTICAST_VPN): /* fall through */\n                    case (AFNUM_INET6<<8 | SAFNUM_MULTICAST_VPN):\n                        advance = decode_multicast_vpn(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n\n\t\t    case (AFNUM_INET<<8 | SAFNUM_MDT):\n\t\t      advance = decode_mdt_vpn_nlri(ndo, tptr, buf, sizeof(buf));\n\t\t      if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n\t\t       break;\n                    case (AFNUM_INET6<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_prefix6(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_LABUNICAST):\n                        advance = decode_labeled_prefix6(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_prefix6(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_VPLS<<8 | SAFNUM_VPLS):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_l2(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_NSAP<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_clnp_prefix(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_clnp_prefix(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    default:\n                        ND_TCHECK2(*tptr,tlen);\n                        ND_PRINT((ndo, \"\\n\\t    no AFI %u / SAFI %u decoder\", af, safi));\n                        if (ndo->ndo_vflag <= 1)\n                            print_unknown_data(ndo, tptr, \"\\n\\t    \", tlen);\n                        advance = 0;\n                        tptr = pptr + len;\n                        break;\n                    }\n                    if (advance < 0)\n                        break;\n                    tptr += advance;\n\t\t}\n        done:\n\t\tbreak;\n\n\tcase BGPTYPE_MP_UNREACH_NLRI:\n\t\tND_TCHECK2(tptr[0], BGP_MP_NLRI_MINSIZE);\n\t\taf = EXTRACT_16BITS(tptr);\n\t\tsafi = tptr[2];\n\n                ND_PRINT((ndo, \"\\n\\t    AFI: %s (%u), %sSAFI: %s (%u)\",\n                       tok2str(af_values, \"Unknown AFI\", af),\n                       af,\n                       (safi>128) ? \"vendor specific \" : \"\", /* 128 is meanwhile wellknown */\n                       tok2str(bgp_safi_values, \"Unknown SAFI\", safi),\n                       safi));\n\n                if (len == BGP_MP_NLRI_MINSIZE)\n                    ND_PRINT((ndo, \"\\n\\t      End-of-Rib Marker (empty NLRI)\"));\n\n\t\ttptr += 3;\n\n\t\twhile (tptr < pptr + len) {\n                    switch (af<<8 | safi) {\n                    case (AFNUM_INET<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_prefix4(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_LABUNICAST):\n                        advance = decode_labeled_prefix4(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_prefix4(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_prefix6(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_LABUNICAST):\n                        advance = decode_labeled_prefix6(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_prefix6(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_VPLS<<8 | SAFNUM_VPLS):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_l2(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_NSAP<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_clnp_prefix(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_clnp_prefix(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n\t\t    case (AFNUM_INET<<8 | SAFNUM_MDT):\n\t\t      advance = decode_mdt_vpn_nlri(ndo, tptr, buf, sizeof(buf));\n\t\t      if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n\t\t       break;\n                    case (AFNUM_INET<<8 | SAFNUM_MULTICAST_VPN): /* fall through */\n                    case (AFNUM_INET6<<8 | SAFNUM_MULTICAST_VPN):\n                        advance = decode_multicast_vpn(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    default:\n                        ND_TCHECK2(*(tptr-3),tlen);\n                        ND_PRINT((ndo, \"no AFI %u / SAFI %u decoder\", af, safi));\n                        if (ndo->ndo_vflag <= 1)\n                            print_unknown_data(ndo, tptr-3, \"\\n\\t    \", tlen);\n                        advance = 0;\n                        tptr = pptr + len;\n                        break;\n                    }\n                    if (advance < 0)\n                        break;\n                    tptr += advance;\n\t\t}\n\t\tbreak;\n        case BGPTYPE_EXTD_COMMUNITIES:\n\t\tif (len % 8) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n                while (tlen>0) {\n                    uint16_t extd_comm;\n\n                    ND_TCHECK2(tptr[0], 2);\n                    extd_comm=EXTRACT_16BITS(tptr);\n\n\t\t    ND_PRINT((ndo, \"\\n\\t    %s (0x%04x), Flags [%s]\",\n\t\t\t   tok2str(bgp_extd_comm_subtype_values,\n\t\t\t\t      \"unknown extd community typecode\",\n\t\t\t\t      extd_comm),\n\t\t\t   extd_comm,\n\t\t\t   bittok2str(bgp_extd_comm_flag_values, \"none\", extd_comm)));\n\n                    ND_TCHECK2(*(tptr+2), 6);\n                    switch(extd_comm) {\n                    case BGP_EXT_COM_RT_0:\n                    case BGP_EXT_COM_RO_0:\n                    case BGP_EXT_COM_L2VPN_RT_0:\n                        ND_PRINT((ndo, \": %u:%u (= %s)\",\n                               EXTRACT_16BITS(tptr+2),\n                               EXTRACT_32BITS(tptr+4),\n                               ipaddr_string(ndo, tptr+4)));\n                        break;\n                    case BGP_EXT_COM_RT_1:\n                    case BGP_EXT_COM_RO_1:\n                    case BGP_EXT_COM_L2VPN_RT_1:\n                    case BGP_EXT_COM_VRF_RT_IMP:\n                        ND_PRINT((ndo, \": %s:%u\",\n                               ipaddr_string(ndo, tptr+2),\n                               EXTRACT_16BITS(tptr+6)));\n                        break;\n                    case BGP_EXT_COM_RT_2:\n                    case BGP_EXT_COM_RO_2:\n\t\t\tND_PRINT((ndo, \": %s:%u\",\n\t\t\t    as_printf(ndo, astostr, sizeof(astostr),\n\t\t\t    EXTRACT_32BITS(tptr+2)), EXTRACT_16BITS(tptr+6)));\n\t\t\tbreak;\n                    case BGP_EXT_COM_LINKBAND:\n\t\t        bw.i = EXTRACT_32BITS(tptr+2);\n                        ND_PRINT((ndo, \": bandwidth: %.3f Mbps\",\n                               bw.f*8/1000000));\n                        break;\n                    case BGP_EXT_COM_VPN_ORIGIN:\n                    case BGP_EXT_COM_VPN_ORIGIN2:\n                    case BGP_EXT_COM_VPN_ORIGIN3:\n                    case BGP_EXT_COM_VPN_ORIGIN4:\n                    case BGP_EXT_COM_OSPF_RID:\n                    case BGP_EXT_COM_OSPF_RID2:\n                        ND_PRINT((ndo, \"%s\", ipaddr_string(ndo, tptr+2)));\n                        break;\n                    case BGP_EXT_COM_OSPF_RTYPE:\n                    case BGP_EXT_COM_OSPF_RTYPE2:\n                        ND_PRINT((ndo, \": area:%s, router-type:%s, metric-type:%s%s\",\n                               ipaddr_string(ndo, tptr+2),\n                               tok2str(bgp_extd_comm_ospf_rtype_values,\n\t\t\t\t\t  \"unknown (0x%02x)\",\n\t\t\t\t\t  *(tptr+6)),\n                               (*(tptr+7) &  BGP_OSPF_RTYPE_METRIC_TYPE) ? \"E2\" : \"\",\n                               ((*(tptr+6) == BGP_OSPF_RTYPE_EXT) || (*(tptr+6) == BGP_OSPF_RTYPE_NSSA)) ? \"E1\" : \"\"));\n                        break;\n                    case BGP_EXT_COM_L2INFO:\n                        ND_PRINT((ndo, \": %s Control Flags [0x%02x]:MTU %u\",\n                               tok2str(l2vpn_encaps_values,\n\t\t\t\t\t  \"unknown encaps\",\n\t\t\t\t\t  *(tptr+2)),\n                                       *(tptr+3),\n                               EXTRACT_16BITS(tptr+4)));\n                        break;\n                    case BGP_EXT_COM_SOURCE_AS:\n                        ND_PRINT((ndo, \": AS %u\", EXTRACT_16BITS(tptr+2)));\n                        break;\n                    default:\n                        ND_TCHECK2(*tptr,8);\n                        print_unknown_data(ndo, tptr, \"\\n\\t      \", 8);\n                        break;\n                    }\n                    tlen -=8;\n                    tptr +=8;\n                }\n                break;\n\n        case BGPTYPE_PMSI_TUNNEL:\n         {\n                 uint8_t tunnel_type, flags;\n \n                ND_TCHECK2(tptr[0], 5);\n                 tunnel_type = *(tptr+1);\n                 flags = *tptr;\n                 tlen = len;\n \n                 ND_PRINT((ndo, \"\\n\\t    Tunnel-type %s (%u), Flags [%s], MPLS Label %u\",\n                        tok2str(bgp_pmsi_tunnel_values, \"Unknown\", tunnel_type),\n                        tunnel_type,\n                       bittok2str(bgp_pmsi_flag_values, \"none\", flags),\n                       EXTRACT_24BITS(tptr+2)>>4));\n\n                tptr +=5;\n                tlen -= 5;\n\n                switch (tunnel_type) {\n                case BGP_PMSI_TUNNEL_PIM_SM: /* fall through */\n                case BGP_PMSI_TUNNEL_PIM_BIDIR:\n                    ND_TCHECK2(tptr[0], 8);\n                    ND_PRINT((ndo, \"\\n\\t      Sender %s, P-Group %s\",\n                           ipaddr_string(ndo, tptr),\n                           ipaddr_string(ndo, tptr+4)));\n                    break;\n\n                case BGP_PMSI_TUNNEL_PIM_SSM:\n                    ND_TCHECK2(tptr[0], 8);\n                    ND_PRINT((ndo, \"\\n\\t      Root-Node %s, P-Group %s\",\n                           ipaddr_string(ndo, tptr),\n                           ipaddr_string(ndo, tptr+4)));\n                    break;\n                case BGP_PMSI_TUNNEL_INGRESS:\n                    ND_TCHECK2(tptr[0], 4);\n                    ND_PRINT((ndo, \"\\n\\t      Tunnel-Endpoint %s\",\n                           ipaddr_string(ndo, tptr)));\n                    break;\n                case BGP_PMSI_TUNNEL_LDP_P2MP: /* fall through */\n                case BGP_PMSI_TUNNEL_LDP_MP2MP:\n                    ND_TCHECK2(tptr[0], 8);\n                    ND_PRINT((ndo, \"\\n\\t      Root-Node %s, LSP-ID 0x%08x\",\n                           ipaddr_string(ndo, tptr),\n                           EXTRACT_32BITS(tptr+4)));\n                    break;\n                case BGP_PMSI_TUNNEL_RSVP_P2MP:\n                    ND_TCHECK2(tptr[0], 8);\n                    ND_PRINT((ndo, \"\\n\\t      Extended-Tunnel-ID %s, P2MP-ID 0x%08x\",\n                           ipaddr_string(ndo, tptr),\n                           EXTRACT_32BITS(tptr+4)));\n                    break;\n                default:\n                    if (ndo->ndo_vflag <= 1) {\n                        print_unknown_data(ndo, tptr, \"\\n\\t      \", tlen);\n                    }\n                }\n                break;\n        }\n\tcase BGPTYPE_AIGP:\n\t{\n\t\tuint8_t type;\n\t\tuint16_t length;\n\n\t\ttlen = len;\n\n\t\twhile (tlen >= 3) {\n\n\t\t    ND_TCHECK2(tptr[0], 3);\n\n\t\t    type = *tptr;\n\t\t    length = EXTRACT_16BITS(tptr+1);\n\t\t    tptr += 3;\n\t\t    tlen -= 3;\n\n\t\t    ND_PRINT((ndo, \"\\n\\t    %s TLV (%u), length %u\",\n\t\t\t      tok2str(bgp_aigp_values, \"Unknown\", type),\n\t\t\t      type, length));\n\n\t\t    if (length < 3)\n\t\t\tgoto trunc;\n\t\t    length -= 3;\n\n\t\t    /*\n\t\t     * Check if we can read the TLV data.\n\t\t     */\n\t\t    ND_TCHECK2(tptr[3], length);\n\n\t\t    switch (type) {\n\n\t\t    case BGP_AIGP_TLV:\n\t\t        if (length < 8)\n\t\t            goto trunc;\n\t\t\tND_PRINT((ndo, \", metric %\" PRIu64,\n\t\t\t\t  EXTRACT_64BITS(tptr)));\n\t\t\tbreak;\n\n\t\t    default:\n\t\t\tif (ndo->ndo_vflag <= 1) {\n\t\t\t    print_unknown_data(ndo, tptr,\"\\n\\t      \", length);\n\t\t\t}\n\t\t    }\n\n\t\t    tptr += length;\n\t\t    tlen -= length;\n\t\t}\n\t\tbreak;\n\t}\n        case BGPTYPE_ATTR_SET:\n                ND_TCHECK2(tptr[0], 4);\n                if (len < 4)\n                \tgoto trunc;\n\t\tND_PRINT((ndo, \"\\n\\t    Origin AS: %s\",\n\t\t    as_printf(ndo, astostr, sizeof(astostr), EXTRACT_32BITS(tptr))));\n\t\ttptr+=4;\n                len -=4;\n\n                while (len) {\n                    u_int aflags, alenlen, alen;\n\n                    ND_TCHECK2(tptr[0], 2);\n                    if (len < 2)\n                        goto trunc;\n                    aflags = *tptr;\n                    atype = *(tptr + 1);\n                    tptr += 2;\n                    len -= 2;\n                    alenlen = bgp_attr_lenlen(aflags, tptr);\n                    ND_TCHECK2(tptr[0], alenlen);\n                    if (len < alenlen)\n                        goto trunc;\n                    alen = bgp_attr_len(aflags, tptr);\n                    tptr += alenlen;\n                    len -= alenlen;\n\n                    ND_PRINT((ndo, \"\\n\\t      %s (%u), length: %u\",\n                           tok2str(bgp_attr_values,\n                                      \"Unknown Attribute\", atype),\n                           atype,\n                           alen));\n\n                    if (aflags) {\n                        ND_PRINT((ndo, \", Flags [%s%s%s%s\",\n                               aflags & 0x80 ? \"O\" : \"\",\n                               aflags & 0x40 ? \"T\" : \"\",\n                               aflags & 0x20 ? \"P\" : \"\",\n                               aflags & 0x10 ? \"E\" : \"\"));\n                        if (aflags & 0xf)\n                            ND_PRINT((ndo, \"+%x\", aflags & 0xf));\n                        ND_PRINT((ndo, \"]: \"));\n                    }\n                    /* FIXME check for recursion */\n                    if (!bgp_attr_print(ndo, atype, tptr, alen))\n                        return 0;\n                    tptr += alen;\n                    len -= alen;\n\t\t}\n                break;\n\n\tcase BGPTYPE_LARGE_COMMUNITY:\n\t\tif (len == 0 || len % 12) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n\t\tND_PRINT((ndo, \"\\n\\t    \"));\n\t\twhile (len > 0) {\n\t\t\tND_TCHECK2(*tptr, 12);\n\t\t\tND_PRINT((ndo, \"%u:%u:%u%s\",\n\t\t\t\t EXTRACT_32BITS(tptr),\n\t\t\t\t EXTRACT_32BITS(tptr + 4),\n\t\t\t\t EXTRACT_32BITS(tptr + 8),\n\t\t\t\t (len > 12) ? \", \" : \"\"));\n                        tptr += 12;\n                        len -= 12;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t    ND_TCHECK2(*pptr,len);\n            ND_PRINT((ndo, \"\\n\\t    no Attribute %u decoder\", atype)); /* we have no decoder for the attribute */\n            if (ndo->ndo_vflag <= 1)\n                print_unknown_data(ndo, pptr, \"\\n\\t    \", len);\n            break;\n\t}\n        if (ndo->ndo_vflag > 1 && len) { /* omit zero length attributes*/\n            ND_TCHECK2(*pptr,len);\n            print_unknown_data(ndo, pptr, \"\\n\\t    \", len);\n        }\n        return 1;\n\ntrunc:\n        return 0;\n}\n",
    "cwe": [
      "CWE-125"
    ],
    "id": 476,
    "_valid_cwes": [
      "CWE-125"
    ]
  },
  {
    "cve_id": "CVE-2018-8789",
    "code_before_change": "int ntlm_read_message_header(wStream* s, NTLM_MESSAGE_HEADER* header)\n {\n \tif (Stream_GetRemainingLength(s) < 12)\n \t\treturn -1;\n\n\tStream_Read(s, header->Signature, 8);\n\tStream_Read_UINT32(s, header->MessageType);\n\n\tif (strncmp((char*) header->Signature, NTLM_SIGNATURE, 8) != 0)\n\t\treturn -1;\n\n \treturn 1;\n }\n",
    "code_after_change": "int ntlm_read_message_header(wStream* s, NTLM_MESSAGE_HEADER* header)\nstatic int ntlm_read_message_header(wStream* s, NTLM_MESSAGE_HEADER* header)\n {\n \tif (Stream_GetRemainingLength(s) < 12)\n \t\treturn -1;\n\n\tStream_Read(s, header->Signature, 8);\n\tStream_Read_UINT32(s, header->MessageType);\n\n\tif (strncmp((char*) header->Signature, NTLM_SIGNATURE, 8) != 0)\n\t\treturn -1;\n\n \treturn 1;\n }\n",
    "cwe": [
      "CWE-125"
    ],
    "id": 479,
    "_valid_cwes": [
      "CWE-125"
    ]
  },
  {
    "cve_id": "CVE-2017-13005",
    "code_before_change": "xid_map_enter(netdissect_options *ndo,\n              const struct sunrpc_msg *rp, const u_char *bp)\n{\n\tconst struct ip *ip = NULL;\n\tconst struct ip6_hdr *ip6 = NULL;\n\tstruct xid_map_entry *xmep;\n\n\tif (!ND_TTEST(rp->rm_call.cb_vers))\n\t\treturn (0);\n\tswitch (IP_V((const struct ip *)bp)) {\n\tcase 4:\n\t\tip = (const struct ip *)bp;\n\t\tbreak;\n\tcase 6:\n\t\tip6 = (const struct ip6_hdr *)bp;\n\t\tbreak;\n\tdefault:\n\t\treturn (1);\n\t}\n\n\txmep = &xid_map[xid_map_next];\n\n\tif (++xid_map_next >= XIDMAPSIZE)\n\t\txid_map_next = 0;\n\n\tUNALIGNED_MEMCPY(&xmep->xid, &rp->rm_xid, sizeof(xmep->xid));\n\tif (ip) {\n\t\txmep->ipver = 4;\n\t\tUNALIGNED_MEMCPY(&xmep->client, &ip->ip_src, sizeof(ip->ip_src));\n\t\tUNALIGNED_MEMCPY(&xmep->server, &ip->ip_dst, sizeof(ip->ip_dst));\n\t}\n\telse if (ip6) {\n\t\txmep->ipver = 6;\n \t\tUNALIGNED_MEMCPY(&xmep->client, &ip6->ip6_src, sizeof(ip6->ip6_src));\n \t\tUNALIGNED_MEMCPY(&xmep->server, &ip6->ip6_dst, sizeof(ip6->ip6_dst));\n \t}\n \txmep->proc = EXTRACT_32BITS(&rp->rm_call.cb_proc);\n \txmep->vers = EXTRACT_32BITS(&rp->rm_call.cb_vers);\n \treturn (1);\n }\n",
    "code_after_change": "xid_map_enter(netdissect_options *ndo,\n              const struct sunrpc_msg *rp, const u_char *bp)\n{\n\tconst struct ip *ip = NULL;\n\tconst struct ip6_hdr *ip6 = NULL;\n\tstruct xid_map_entry *xmep;\n\n\tif (!ND_TTEST(rp->rm_call.cb_vers))\n\t\treturn (0);\n\tswitch (IP_V((const struct ip *)bp)) {\n\tcase 4:\n\t\tip = (const struct ip *)bp;\n\t\tbreak;\n\tcase 6:\n\t\tip6 = (const struct ip6_hdr *)bp;\n\t\tbreak;\n\tdefault:\n\t\treturn (1);\n\t}\n\n\txmep = &xid_map[xid_map_next];\n\n\tif (++xid_map_next >= XIDMAPSIZE)\n\t\txid_map_next = 0;\n\n\tUNALIGNED_MEMCPY(&xmep->xid, &rp->rm_xid, sizeof(xmep->xid));\n\tif (ip) {\n\t\txmep->ipver = 4;\n\t\tUNALIGNED_MEMCPY(&xmep->client, &ip->ip_src, sizeof(ip->ip_src));\n\t\tUNALIGNED_MEMCPY(&xmep->server, &ip->ip_dst, sizeof(ip->ip_dst));\n\t}\n\telse if (ip6) {\n\t\txmep->ipver = 6;\n \t\tUNALIGNED_MEMCPY(&xmep->client, &ip6->ip6_src, sizeof(ip6->ip6_src));\n \t\tUNALIGNED_MEMCPY(&xmep->server, &ip6->ip6_dst, sizeof(ip6->ip6_dst));\n \t}\n\tif (!ND_TTEST(rp->rm_call.cb_proc))\n\t\treturn (0);\n \txmep->proc = EXTRACT_32BITS(&rp->rm_call.cb_proc);\n\tif (!ND_TTEST(rp->rm_call.cb_vers))\n\t\treturn (0);\n \txmep->vers = EXTRACT_32BITS(&rp->rm_call.cb_vers);\n \treturn (1);\n }\n",
    "cwe": [
      "CWE-125"
    ],
    "id": 481,
    "_valid_cwes": [
      "CWE-125"
    ]
  },
  {
    "cve_id": "CVE-2017-8294",
    "code_before_change": "int _yr_scan_verify_re_match(\n    YR_SCAN_CONTEXT* context,\n    YR_AC_MATCH* ac_match,\n    uint8_t* data,\n    size_t data_size,\n    size_t data_base,\n    size_t offset)\n{\n  CALLBACK_ARGS callback_args;\n  RE_EXEC_FUNC exec;\n\n  int forward_matches = -1;\n  int backward_matches = -1;\n  int flags = 0;\n\n  if (STRING_IS_GREEDY_REGEXP(ac_match->string))\n    flags |= RE_FLAGS_GREEDY;\n\n  if (STRING_IS_NO_CASE(ac_match->string))\n    flags |= RE_FLAGS_NO_CASE;\n\n  if (STRING_IS_DOT_ALL(ac_match->string))\n    flags |= RE_FLAGS_DOT_ALL;\n\n  if (STRING_IS_FAST_REGEXP(ac_match->string))\n    exec = yr_re_fast_exec;\n  else\n    exec = yr_re_exec;\n\n  if (STRING_IS_ASCII(ac_match->string))\n  {\n    forward_matches = exec(\n         ac_match->forward_code,\n         data + offset,\n         data_size - offset,\n        offset > 0 ? flags | RE_FLAGS_NOT_AT_START : flags,\n         NULL,\n         NULL);\n   }\n\n  if (STRING_IS_WIDE(ac_match->string) && forward_matches == -1)\n  {\n    flags |= RE_FLAGS_WIDE;\n    forward_matches = exec(\n         ac_match->forward_code,\n         data + offset,\n         data_size - offset,\n        offset > 0 ? flags | RE_FLAGS_NOT_AT_START : flags,\n         NULL,\n         NULL);\n   }\n\n  switch(forward_matches)\n  {\n    case -1:\n      return ERROR_SUCCESS;\n    case -2:\n      return ERROR_INSUFFICIENT_MEMORY;\n    case -3:\n      return ERROR_TOO_MANY_MATCHES;\n    case -4:\n      return ERROR_TOO_MANY_RE_FIBERS;\n    case -5:\n      return ERROR_INTERNAL_FATAL_ERROR;\n  }\n\n  if (forward_matches == 0 && ac_match->backward_code == NULL)\n    return ERROR_SUCCESS;\n\n  callback_args.string = ac_match->string;\n  callback_args.context = context;\n  callback_args.data = data;\n  callback_args.data_size = data_size;\n  callback_args.data_base = data_base;\n  callback_args.forward_matches = forward_matches;\n  callback_args.full_word = STRING_IS_FULL_WORD(ac_match->string);\n\n  if (ac_match->backward_code != NULL)\n  {\n     backward_matches = exec(\n         ac_match->backward_code,\n         data + offset,\n         offset,\n         flags | RE_FLAGS_BACKWARDS | RE_FLAGS_EXHAUSTIVE,\n         _yr_scan_match_callback,\n        (void*) &callback_args);\n\n    switch(backward_matches)\n    {\n      case -2:\n        return ERROR_INSUFFICIENT_MEMORY;\n      case -3:\n        return ERROR_TOO_MANY_MATCHES;\n      case -4:\n        return ERROR_TOO_MANY_RE_FIBERS;\n      case -5:\n        return ERROR_INTERNAL_FATAL_ERROR;\n    }\n  }\n  else\n  {\n    FAIL_ON_ERROR(_yr_scan_match_callback(\n        data + offset, 0, flags, &callback_args));\n  }\n\n  return ERROR_SUCCESS;\n}\n",
    "code_after_change": "int _yr_scan_verify_re_match(\n    YR_SCAN_CONTEXT* context,\n    YR_AC_MATCH* ac_match,\n    uint8_t* data,\n    size_t data_size,\n    size_t data_base,\n    size_t offset)\n{\n  CALLBACK_ARGS callback_args;\n  RE_EXEC_FUNC exec;\n\n  int forward_matches = -1;\n  int backward_matches = -1;\n  int flags = 0;\n\n  if (STRING_IS_GREEDY_REGEXP(ac_match->string))\n    flags |= RE_FLAGS_GREEDY;\n\n  if (STRING_IS_NO_CASE(ac_match->string))\n    flags |= RE_FLAGS_NO_CASE;\n\n  if (STRING_IS_DOT_ALL(ac_match->string))\n    flags |= RE_FLAGS_DOT_ALL;\n\n  if (STRING_IS_FAST_REGEXP(ac_match->string))\n    exec = yr_re_fast_exec;\n  else\n    exec = yr_re_exec;\n\n  if (STRING_IS_ASCII(ac_match->string))\n  {\n    forward_matches = exec(\n         ac_match->forward_code,\n         data + offset,\n         data_size - offset,\n        offset,\n        flags,\n         NULL,\n         NULL);\n   }\n\n  if (STRING_IS_WIDE(ac_match->string) && forward_matches == -1)\n  {\n    flags |= RE_FLAGS_WIDE;\n    forward_matches = exec(\n         ac_match->forward_code,\n         data + offset,\n         data_size - offset,\n        offset,\n        flags,\n         NULL,\n         NULL);\n   }\n\n  switch(forward_matches)\n  {\n    case -1:\n      return ERROR_SUCCESS;\n    case -2:\n      return ERROR_INSUFFICIENT_MEMORY;\n    case -3:\n      return ERROR_TOO_MANY_MATCHES;\n    case -4:\n      return ERROR_TOO_MANY_RE_FIBERS;\n    case -5:\n      return ERROR_INTERNAL_FATAL_ERROR;\n  }\n\n  if (forward_matches == 0 && ac_match->backward_code == NULL)\n    return ERROR_SUCCESS;\n\n  callback_args.string = ac_match->string;\n  callback_args.context = context;\n  callback_args.data = data;\n  callback_args.data_size = data_size;\n  callback_args.data_base = data_base;\n  callback_args.forward_matches = forward_matches;\n  callback_args.full_word = STRING_IS_FULL_WORD(ac_match->string);\n\n  if (ac_match->backward_code != NULL)\n  {\n     backward_matches = exec(\n         ac_match->backward_code,\n         data + offset,\n        data_size - offset,\n         offset,\n         flags | RE_FLAGS_BACKWARDS | RE_FLAGS_EXHAUSTIVE,\n         _yr_scan_match_callback,\n        (void*) &callback_args);\n\n    switch(backward_matches)\n    {\n      case -2:\n        return ERROR_INSUFFICIENT_MEMORY;\n      case -3:\n        return ERROR_TOO_MANY_MATCHES;\n      case -4:\n        return ERROR_TOO_MANY_RE_FIBERS;\n      case -5:\n        return ERROR_INTERNAL_FATAL_ERROR;\n    }\n  }\n  else\n  {\n    FAIL_ON_ERROR(_yr_scan_match_callback(\n        data + offset, 0, flags, &callback_args));\n  }\n\n  return ERROR_SUCCESS;\n}\n",
    "cwe": [
      "CWE-125"
    ],
    "id": 494,
    "_valid_cwes": [
      "CWE-125"
    ]
  },
  {
    "cve_id": "CVE-2017-13052",
    "code_before_change": "cfm_print(netdissect_options *ndo,\n          register const u_char *pptr, register u_int length)\n{\n    const struct cfm_common_header_t *cfm_common_header;\n    const struct cfm_tlv_header_t *cfm_tlv_header;\n    const uint8_t *tptr, *tlv_ptr;\n    const uint8_t *namesp;\n    u_int names_data_remaining;\n    uint8_t md_nameformat, md_namelength;\n    const uint8_t *md_name;\n    uint8_t ma_nameformat, ma_namelength;\n    const uint8_t *ma_name;\n    u_int hexdump, tlen, cfm_tlv_len, cfm_tlv_type, ccm_interval;\n\n\n    union {\n        const struct cfm_ccm_t *cfm_ccm;\n        const struct cfm_lbm_t *cfm_lbm;\n        const struct cfm_ltm_t *cfm_ltm;\n        const struct cfm_ltr_t *cfm_ltr;\n    } msg_ptr;\n\n    tptr=pptr;\n    cfm_common_header = (const struct cfm_common_header_t *)pptr;\n    if (length < sizeof(*cfm_common_header))\n        goto tooshort;\n    ND_TCHECK(*cfm_common_header);\n\n    /*\n     * Sanity checking of the header.\n     */\n    if (CFM_EXTRACT_VERSION(cfm_common_header->mdlevel_version) != CFM_VERSION) {\n\tND_PRINT((ndo, \"CFMv%u not supported, length %u\",\n               CFM_EXTRACT_VERSION(cfm_common_header->mdlevel_version), length));\n\treturn;\n    }\n\n    ND_PRINT((ndo, \"CFMv%u %s, MD Level %u, length %u\",\n           CFM_EXTRACT_VERSION(cfm_common_header->mdlevel_version),\n           tok2str(cfm_opcode_values, \"unknown (%u)\", cfm_common_header->opcode),\n           CFM_EXTRACT_MD_LEVEL(cfm_common_header->mdlevel_version),\n           length));\n\n    /*\n     * In non-verbose mode just print the opcode and md-level.\n     */\n    if (ndo->ndo_vflag < 1) {\n        return;\n    }\n\n    ND_PRINT((ndo, \"\\n\\tFirst TLV offset %u\", cfm_common_header->first_tlv_offset));\n\n    tptr += sizeof(const struct cfm_common_header_t);\n    tlen = length - sizeof(struct cfm_common_header_t);\n\n    /*\n     * Sanity check the first TLV offset.\n     */\n    if (cfm_common_header->first_tlv_offset > tlen) {\n        ND_PRINT((ndo, \" (too large, must be <= %u)\", tlen));\n        return;\n    }\n\n    switch (cfm_common_header->opcode) {\n    case CFM_OPCODE_CCM:\n        msg_ptr.cfm_ccm = (const struct cfm_ccm_t *)tptr;\n        if (cfm_common_header->first_tlv_offset < sizeof(*msg_ptr.cfm_ccm)) {\n            ND_PRINT((ndo, \" (too small 1, must be >= %lu)\",\n                     (unsigned long) sizeof(*msg_ptr.cfm_ccm)));\n            return;\n        }\n        if (tlen < sizeof(*msg_ptr.cfm_ccm))\n            goto tooshort;\n        ND_TCHECK(*msg_ptr.cfm_ccm);\n\n        ccm_interval = CFM_EXTRACT_CCM_INTERVAL(cfm_common_header->flags);\n        ND_PRINT((ndo, \", Flags [CCM Interval %u%s]\",\n               ccm_interval,\n               cfm_common_header->flags & CFM_CCM_RDI_FLAG ?\n               \", RDI\" : \"\"));\n\n        /*\n         * Resolve the CCM interval field.\n         */\n        if (ccm_interval) {\n            ND_PRINT((ndo, \"\\n\\t  CCM Interval %.3fs\"\n                   \", min CCM Lifetime %.3fs, max CCM Lifetime %.3fs\",\n                   ccm_interval_base[ccm_interval],\n                   ccm_interval_base[ccm_interval] * CCM_INTERVAL_MIN_MULTIPLIER,\n                   ccm_interval_base[ccm_interval] * CCM_INTERVAL_MAX_MULTIPLIER));\n        }\n\n        ND_PRINT((ndo, \"\\n\\t  Sequence Number 0x%08x, MA-End-Point-ID 0x%04x\",\n               EXTRACT_32BITS(msg_ptr.cfm_ccm->sequence),\n               EXTRACT_16BITS(msg_ptr.cfm_ccm->ma_epi)));\n\n        namesp = msg_ptr.cfm_ccm->names;\n        names_data_remaining = sizeof(msg_ptr.cfm_ccm->names);\n\n        /*\n         * Resolve the MD fields.\n         */\n        md_nameformat = *namesp;\n        namesp++;\n        names_data_remaining--;  /* We know this is != 0 */\n        if (md_nameformat != CFM_CCM_MD_FORMAT_NONE) {\n            md_namelength = *namesp;\n            namesp++;\n            names_data_remaining--; /* We know this is !=0 */\n            ND_PRINT((ndo, \"\\n\\t  MD Name Format %s (%u), MD Name length %u\",\n                   tok2str(cfm_md_nameformat_values, \"Unknown\",\n                           md_nameformat),\n                   md_nameformat,\n                   md_namelength));\n\n            /*\n             * -3 for the MA short name format and length and one byte\n             * of MA short name.\n             */\n            if (md_namelength > names_data_remaining - 3) {\n                ND_PRINT((ndo, \" (too large, must be <= %u)\", names_data_remaining - 2));\n                return;\n            }\n\n            md_name = namesp;\n            ND_PRINT((ndo, \"\\n\\t  MD Name: \"));\n            switch (md_nameformat) {\n            case CFM_CCM_MD_FORMAT_DNS:\n            case CFM_CCM_MD_FORMAT_CHAR:\n                safeputs(ndo, md_name, md_namelength);\n                break;\n\n            case CFM_CCM_MD_FORMAT_MAC:\n                if (md_namelength == 6) {\n                    ND_PRINT((ndo, \"\\n\\t  MAC %s\", etheraddr_string(ndo,\n                               md_name)));\n                } else {\n                    ND_PRINT((ndo, \"\\n\\t  MAC (length invalid)\"));\n                }\n                break;\n\n                /* FIXME add printers for those MD formats - hexdump for now */\n            case CFM_CCM_MA_FORMAT_8021:\n            default:\n                print_unknown_data(ndo, md_name, \"\\n\\t    \",\n                                   md_namelength);\n            }\n            namesp += md_namelength;\n            names_data_remaining -= md_namelength;\n        } else {\n            ND_PRINT((ndo, \"\\n\\t  MD Name Format %s (%u)\",\n                   tok2str(cfm_md_nameformat_values, \"Unknown\",\n                           md_nameformat),\n                   md_nameformat));\n        }\n\n\n        /*\n         * Resolve the MA fields.\n         */\n        ma_nameformat = *namesp;\n        namesp++;\n        names_data_remaining--; /* We know this is != 0 */\n        ma_namelength = *namesp;\n        namesp++;\n        names_data_remaining--; /* We know this is != 0 */\n        ND_PRINT((ndo, \"\\n\\t  MA Name-Format %s (%u), MA name length %u\",\n               tok2str(cfm_ma_nameformat_values, \"Unknown\",\n                       ma_nameformat),\n               ma_nameformat,\n               ma_namelength));\n\n        if (ma_namelength > names_data_remaining) {\n            ND_PRINT((ndo, \" (too large, must be <= %u)\", names_data_remaining));\n            return;\n        }\n\n        ma_name = namesp;\n        ND_PRINT((ndo, \"\\n\\t  MA Name: \"));\n        switch (ma_nameformat) {\n        case CFM_CCM_MA_FORMAT_CHAR:\n            safeputs(ndo, ma_name, ma_namelength);\n            break;\n\n            /* FIXME add printers for those MA formats - hexdump for now */\n        case CFM_CCM_MA_FORMAT_8021:\n        case CFM_CCM_MA_FORMAT_VID:\n        case CFM_CCM_MA_FORMAT_INT:\n        case CFM_CCM_MA_FORMAT_VPN:\n        default:\n            print_unknown_data(ndo, ma_name, \"\\n\\t    \", ma_namelength);\n        }\n        break;\n\n    case CFM_OPCODE_LTM:\n        msg_ptr.cfm_ltm = (const struct cfm_ltm_t *)tptr;\n        if (cfm_common_header->first_tlv_offset < sizeof(*msg_ptr.cfm_ltm)) {\n            ND_PRINT((ndo, \" (too small 4, must be >= %lu)\",\n                     (unsigned long) sizeof(*msg_ptr.cfm_ltm)));\n            return;\n        }\n        if (tlen < sizeof(*msg_ptr.cfm_ltm))\n            goto tooshort;\n        ND_TCHECK(*msg_ptr.cfm_ltm);\n\n        ND_PRINT((ndo, \", Flags [%s]\",\n               bittok2str(cfm_ltm_flag_values, \"none\", cfm_common_header->flags)));\n\n        ND_PRINT((ndo, \"\\n\\t  Transaction-ID 0x%08x, ttl %u\",\n               EXTRACT_32BITS(msg_ptr.cfm_ltm->transaction_id),\n               msg_ptr.cfm_ltm->ttl));\n\n        ND_PRINT((ndo, \"\\n\\t  Original-MAC %s, Target-MAC %s\",\n               etheraddr_string(ndo, msg_ptr.cfm_ltm->original_mac),\n               etheraddr_string(ndo, msg_ptr.cfm_ltm->target_mac)));\n        break;\n\n    case CFM_OPCODE_LTR:\n        msg_ptr.cfm_ltr = (const struct cfm_ltr_t *)tptr;\n        if (cfm_common_header->first_tlv_offset < sizeof(*msg_ptr.cfm_ltr)) {\n            ND_PRINT((ndo, \" (too small 5, must be >= %lu)\",\n                     (unsigned long) sizeof(*msg_ptr.cfm_ltr)));\n            return;\n        }\n        if (tlen < sizeof(*msg_ptr.cfm_ltr))\n            goto tooshort;\n        ND_TCHECK(*msg_ptr.cfm_ltr);\n\n        ND_PRINT((ndo, \", Flags [%s]\",\n               bittok2str(cfm_ltr_flag_values, \"none\", cfm_common_header->flags)));\n\n        ND_PRINT((ndo, \"\\n\\t  Transaction-ID 0x%08x, ttl %u\",\n               EXTRACT_32BITS(msg_ptr.cfm_ltr->transaction_id),\n               msg_ptr.cfm_ltr->ttl));\n\n        ND_PRINT((ndo, \"\\n\\t  Replay-Action %s (%u)\",\n               tok2str(cfm_ltr_replay_action_values,\n                       \"Unknown\",\n                       msg_ptr.cfm_ltr->replay_action),\n               msg_ptr.cfm_ltr->replay_action));\n        break;\n\n        /*\n         * No message decoder yet.\n         * Hexdump everything up until the start of the TLVs\n         */\n    case CFM_OPCODE_LBR:\n    case CFM_OPCODE_LBM:\n    default:\n        print_unknown_data(ndo, tptr, \"\\n\\t  \",\n                           tlen -  cfm_common_header->first_tlv_offset);\n        break;\n    }\n\n    tptr += cfm_common_header->first_tlv_offset;\n    tlen -= cfm_common_header->first_tlv_offset;\n\n    while (tlen > 0) {\n        cfm_tlv_header = (const struct cfm_tlv_header_t *)tptr;\n\n        /* Enough to read the tlv type ? */\n        ND_TCHECK2(*tptr, 1);\n        cfm_tlv_type=cfm_tlv_header->type;\n\n        ND_PRINT((ndo, \"\\n\\t%s TLV (0x%02x)\",\n               tok2str(cfm_tlv_values, \"Unknown\", cfm_tlv_type),\n               cfm_tlv_type));\n\n        if (cfm_tlv_type == CFM_TLV_END) {\n            /* Length is \"Not present if the Type field is 0.\" */\n            return;\n        }\n\n        /* do we have the full tlv header ? */\n        if (tlen < sizeof(struct cfm_tlv_header_t))\n            goto tooshort;\n        ND_TCHECK2(*tptr, sizeof(struct cfm_tlv_header_t));\n        cfm_tlv_len=EXTRACT_16BITS(&cfm_tlv_header->length);\n\n        ND_PRINT((ndo, \", length %u\", cfm_tlv_len));\n\n        tptr += sizeof(struct cfm_tlv_header_t);\n        tlen -= sizeof(struct cfm_tlv_header_t);\n        tlv_ptr = tptr;\n\n        /* do we have the full tlv ? */\n        if (tlen < cfm_tlv_len)\n            goto tooshort;\n        ND_TCHECK2(*tptr, cfm_tlv_len);\n        hexdump = FALSE;\n\n        switch(cfm_tlv_type) {\n        case CFM_TLV_PORT_STATUS:\n            if (cfm_tlv_len < 1) {\n                ND_PRINT((ndo, \" (too short, must be >= 1)\"));\n                return;\n            }\n            ND_PRINT((ndo, \", Status: %s (%u)\",\n                   tok2str(cfm_tlv_port_status_values, \"Unknown\", *tptr),\n                   *tptr));\n            break;\n\n        case CFM_TLV_INTERFACE_STATUS:\n            if (cfm_tlv_len < 1) {\n                ND_PRINT((ndo, \" (too short, must be >= 1)\"));\n                return;\n            }\n            ND_PRINT((ndo, \", Status: %s (%u)\",\n                   tok2str(cfm_tlv_interface_status_values, \"Unknown\", *tptr),\n                   *tptr));\n            break;\n\n        case CFM_TLV_PRIVATE:\n            if (cfm_tlv_len < 4) {\n                ND_PRINT((ndo, \" (too short, must be >= 4)\"));\n                return;\n            }\n            ND_PRINT((ndo, \", Vendor: %s (%u), Sub-Type %u\",\n                   tok2str(oui_values,\"Unknown\", EXTRACT_24BITS(tptr)),\n                   EXTRACT_24BITS(tptr),\n                   *(tptr + 3)));\n            hexdump = TRUE;\n            break;\n\n        case CFM_TLV_SENDER_ID:\n        {\n            u_int chassis_id_type, chassis_id_length;\n            u_int mgmt_addr_length;\n \n             if (cfm_tlv_len < 1) {\n                 ND_PRINT((ndo, \" (too short, must be >= 1)\"));\n                return;\n             }\n \n             /*\n              * Get the Chassis ID length and check it.\n              */\n             chassis_id_length = *tptr;\n             tptr++;\n             tlen--;\n             cfm_tlv_len--;\n \n             if (chassis_id_length) {\n                 if (cfm_tlv_len < 1) {\n                     ND_PRINT((ndo, \"\\n\\t  (TLV too short)\"));\n                    return;\n                 }\n                 chassis_id_type = *tptr;\n                 cfm_tlv_len--;\n                ND_PRINT((ndo, \"\\n\\t  Chassis-ID Type %s (%u), Chassis-ID length %u\",\n                       tok2str(cfm_tlv_senderid_chassisid_values,\n                               \"Unknown\",\n                               chassis_id_type),\n                       chassis_id_type,\n                       chassis_id_length));\n \n                 if (cfm_tlv_len < chassis_id_length) {\n                     ND_PRINT((ndo, \"\\n\\t  (TLV too short)\"));\n                    return;\n                 }\n \n                 switch (chassis_id_type) {\n                 case CFM_CHASSIS_ID_MAC_ADDRESS:\n                     ND_PRINT((ndo, \"\\n\\t  MAC %s\", etheraddr_string(ndo, tptr + 1)));\n                     break;\n \n                 case CFM_CHASSIS_ID_NETWORK_ADDRESS:\n                    hexdump |= cfm_network_addr_print(ndo, tptr);\n                     break;\n \n                 case CFM_CHASSIS_ID_INTERFACE_NAME: /* fall through */\n                case CFM_CHASSIS_ID_INTERFACE_ALIAS:\n                case CFM_CHASSIS_ID_LOCAL:\n                case CFM_CHASSIS_ID_CHASSIS_COMPONENT:\n                case CFM_CHASSIS_ID_PORT_COMPONENT:\n                    safeputs(ndo, tptr + 1, chassis_id_length);\n                    break;\n\n                default:\n                    hexdump = TRUE;\n                    break;\n                }\n                cfm_tlv_len -= chassis_id_length;\n\n                tptr += 1 + chassis_id_length;\n                tlen -= 1 + chassis_id_length;\n            }\n \n             /*\n              * Check if there is a Management Address.\n              */\n             if (cfm_tlv_len == 0) {\n                 /* No, there isn't; we're done. */\n                return;\n             }\n \n             mgmt_addr_length = *tptr;\n             tptr++;\n             tlen--;\n             cfm_tlv_len--;\n             if (mgmt_addr_length) {\n                 if (cfm_tlv_len < mgmt_addr_length) {\n                     ND_PRINT((ndo, \"\\n\\t  (TLV too short)\"));\n                    return;\n                 }\n                 cfm_tlv_len -= mgmt_addr_length;\n                 /*\n                  * XXX - this is an OID; print it as such.\n                  */\n                 tptr += mgmt_addr_length;\n                 tlen -= mgmt_addr_length;\n \n                 if (cfm_tlv_len < 1) {\n                    ND_PRINT((ndo, \"\\n\\t  (TLV too short)\"));\n                    return;\n                 }\n \n                 mgmt_addr_length = *tptr;\n                 tptr++;\n                 tlen--;\n                 cfm_tlv_len--;\n                 if (mgmt_addr_length) {\n                     if (cfm_tlv_len < mgmt_addr_length) {\n                         ND_PRINT((ndo, \"\\n\\t  (TLV too short)\"));\n                         return;\n                    }\n                    cfm_tlv_len -= mgmt_addr_length;\n                     /*\n                      * XXX - this is a TransportDomain; print it as such.\n                      */\n                     tptr += mgmt_addr_length;\n                     tlen -= mgmt_addr_length;\n                 }\n            }\n            break;\n        }\n\n            /*\n             * FIXME those are the defined TLVs that lack a decoder\n             * you are welcome to contribute code ;-)\n             */\n\n        case CFM_TLV_DATA:\n        case CFM_TLV_REPLY_INGRESS:\n        case CFM_TLV_REPLY_EGRESS:\n        default:\n            hexdump = TRUE;\n            break;\n        }\n        /* do we want to see an additional hexdump ? */\n         if (hexdump || ndo->ndo_vflag > 1)\n             print_unknown_data(ndo, tlv_ptr, \"\\n\\t  \", cfm_tlv_len);\n \n         tptr+=cfm_tlv_len;\n         tlen-=cfm_tlv_len;\n     }\n    return;\n\ntooshort:\n    ND_PRINT((ndo, \"\\n\\t\\t packet is too short\"));\n    return;\n\ntrunc:\n    ND_PRINT((ndo, \"\\n\\t\\t packet exceeded snapshot\"));\n}\n",
    "code_after_change": "cfm_print(netdissect_options *ndo,\n          register const u_char *pptr, register u_int length)\n{\n    const struct cfm_common_header_t *cfm_common_header;\n    const struct cfm_tlv_header_t *cfm_tlv_header;\n    const uint8_t *tptr, *tlv_ptr;\n    const uint8_t *namesp;\n    u_int names_data_remaining;\n    uint8_t md_nameformat, md_namelength;\n    const uint8_t *md_name;\n    uint8_t ma_nameformat, ma_namelength;\n    const uint8_t *ma_name;\n    u_int hexdump, tlen, cfm_tlv_len, cfm_tlv_type, ccm_interval;\n\n\n    union {\n        const struct cfm_ccm_t *cfm_ccm;\n        const struct cfm_lbm_t *cfm_lbm;\n        const struct cfm_ltm_t *cfm_ltm;\n        const struct cfm_ltr_t *cfm_ltr;\n    } msg_ptr;\n\n    tptr=pptr;\n    cfm_common_header = (const struct cfm_common_header_t *)pptr;\n    if (length < sizeof(*cfm_common_header))\n        goto tooshort;\n    ND_TCHECK(*cfm_common_header);\n\n    /*\n     * Sanity checking of the header.\n     */\n    if (CFM_EXTRACT_VERSION(cfm_common_header->mdlevel_version) != CFM_VERSION) {\n\tND_PRINT((ndo, \"CFMv%u not supported, length %u\",\n               CFM_EXTRACT_VERSION(cfm_common_header->mdlevel_version), length));\n\treturn;\n    }\n\n    ND_PRINT((ndo, \"CFMv%u %s, MD Level %u, length %u\",\n           CFM_EXTRACT_VERSION(cfm_common_header->mdlevel_version),\n           tok2str(cfm_opcode_values, \"unknown (%u)\", cfm_common_header->opcode),\n           CFM_EXTRACT_MD_LEVEL(cfm_common_header->mdlevel_version),\n           length));\n\n    /*\n     * In non-verbose mode just print the opcode and md-level.\n     */\n    if (ndo->ndo_vflag < 1) {\n        return;\n    }\n\n    ND_PRINT((ndo, \"\\n\\tFirst TLV offset %u\", cfm_common_header->first_tlv_offset));\n\n    tptr += sizeof(const struct cfm_common_header_t);\n    tlen = length - sizeof(struct cfm_common_header_t);\n\n    /*\n     * Sanity check the first TLV offset.\n     */\n    if (cfm_common_header->first_tlv_offset > tlen) {\n        ND_PRINT((ndo, \" (too large, must be <= %u)\", tlen));\n        return;\n    }\n\n    switch (cfm_common_header->opcode) {\n    case CFM_OPCODE_CCM:\n        msg_ptr.cfm_ccm = (const struct cfm_ccm_t *)tptr;\n        if (cfm_common_header->first_tlv_offset < sizeof(*msg_ptr.cfm_ccm)) {\n            ND_PRINT((ndo, \" (too small 1, must be >= %lu)\",\n                     (unsigned long) sizeof(*msg_ptr.cfm_ccm)));\n            return;\n        }\n        if (tlen < sizeof(*msg_ptr.cfm_ccm))\n            goto tooshort;\n        ND_TCHECK(*msg_ptr.cfm_ccm);\n\n        ccm_interval = CFM_EXTRACT_CCM_INTERVAL(cfm_common_header->flags);\n        ND_PRINT((ndo, \", Flags [CCM Interval %u%s]\",\n               ccm_interval,\n               cfm_common_header->flags & CFM_CCM_RDI_FLAG ?\n               \", RDI\" : \"\"));\n\n        /*\n         * Resolve the CCM interval field.\n         */\n        if (ccm_interval) {\n            ND_PRINT((ndo, \"\\n\\t  CCM Interval %.3fs\"\n                   \", min CCM Lifetime %.3fs, max CCM Lifetime %.3fs\",\n                   ccm_interval_base[ccm_interval],\n                   ccm_interval_base[ccm_interval] * CCM_INTERVAL_MIN_MULTIPLIER,\n                   ccm_interval_base[ccm_interval] * CCM_INTERVAL_MAX_MULTIPLIER));\n        }\n\n        ND_PRINT((ndo, \"\\n\\t  Sequence Number 0x%08x, MA-End-Point-ID 0x%04x\",\n               EXTRACT_32BITS(msg_ptr.cfm_ccm->sequence),\n               EXTRACT_16BITS(msg_ptr.cfm_ccm->ma_epi)));\n\n        namesp = msg_ptr.cfm_ccm->names;\n        names_data_remaining = sizeof(msg_ptr.cfm_ccm->names);\n\n        /*\n         * Resolve the MD fields.\n         */\n        md_nameformat = *namesp;\n        namesp++;\n        names_data_remaining--;  /* We know this is != 0 */\n        if (md_nameformat != CFM_CCM_MD_FORMAT_NONE) {\n            md_namelength = *namesp;\n            namesp++;\n            names_data_remaining--; /* We know this is !=0 */\n            ND_PRINT((ndo, \"\\n\\t  MD Name Format %s (%u), MD Name length %u\",\n                   tok2str(cfm_md_nameformat_values, \"Unknown\",\n                           md_nameformat),\n                   md_nameformat,\n                   md_namelength));\n\n            /*\n             * -3 for the MA short name format and length and one byte\n             * of MA short name.\n             */\n            if (md_namelength > names_data_remaining - 3) {\n                ND_PRINT((ndo, \" (too large, must be <= %u)\", names_data_remaining - 2));\n                return;\n            }\n\n            md_name = namesp;\n            ND_PRINT((ndo, \"\\n\\t  MD Name: \"));\n            switch (md_nameformat) {\n            case CFM_CCM_MD_FORMAT_DNS:\n            case CFM_CCM_MD_FORMAT_CHAR:\n                safeputs(ndo, md_name, md_namelength);\n                break;\n\n            case CFM_CCM_MD_FORMAT_MAC:\n                if (md_namelength == 6) {\n                    ND_PRINT((ndo, \"\\n\\t  MAC %s\", etheraddr_string(ndo,\n                               md_name)));\n                } else {\n                    ND_PRINT((ndo, \"\\n\\t  MAC (length invalid)\"));\n                }\n                break;\n\n                /* FIXME add printers for those MD formats - hexdump for now */\n            case CFM_CCM_MA_FORMAT_8021:\n            default:\n                print_unknown_data(ndo, md_name, \"\\n\\t    \",\n                                   md_namelength);\n            }\n            namesp += md_namelength;\n            names_data_remaining -= md_namelength;\n        } else {\n            ND_PRINT((ndo, \"\\n\\t  MD Name Format %s (%u)\",\n                   tok2str(cfm_md_nameformat_values, \"Unknown\",\n                           md_nameformat),\n                   md_nameformat));\n        }\n\n\n        /*\n         * Resolve the MA fields.\n         */\n        ma_nameformat = *namesp;\n        namesp++;\n        names_data_remaining--; /* We know this is != 0 */\n        ma_namelength = *namesp;\n        namesp++;\n        names_data_remaining--; /* We know this is != 0 */\n        ND_PRINT((ndo, \"\\n\\t  MA Name-Format %s (%u), MA name length %u\",\n               tok2str(cfm_ma_nameformat_values, \"Unknown\",\n                       ma_nameformat),\n               ma_nameformat,\n               ma_namelength));\n\n        if (ma_namelength > names_data_remaining) {\n            ND_PRINT((ndo, \" (too large, must be <= %u)\", names_data_remaining));\n            return;\n        }\n\n        ma_name = namesp;\n        ND_PRINT((ndo, \"\\n\\t  MA Name: \"));\n        switch (ma_nameformat) {\n        case CFM_CCM_MA_FORMAT_CHAR:\n            safeputs(ndo, ma_name, ma_namelength);\n            break;\n\n            /* FIXME add printers for those MA formats - hexdump for now */\n        case CFM_CCM_MA_FORMAT_8021:\n        case CFM_CCM_MA_FORMAT_VID:\n        case CFM_CCM_MA_FORMAT_INT:\n        case CFM_CCM_MA_FORMAT_VPN:\n        default:\n            print_unknown_data(ndo, ma_name, \"\\n\\t    \", ma_namelength);\n        }\n        break;\n\n    case CFM_OPCODE_LTM:\n        msg_ptr.cfm_ltm = (const struct cfm_ltm_t *)tptr;\n        if (cfm_common_header->first_tlv_offset < sizeof(*msg_ptr.cfm_ltm)) {\n            ND_PRINT((ndo, \" (too small 4, must be >= %lu)\",\n                     (unsigned long) sizeof(*msg_ptr.cfm_ltm)));\n            return;\n        }\n        if (tlen < sizeof(*msg_ptr.cfm_ltm))\n            goto tooshort;\n        ND_TCHECK(*msg_ptr.cfm_ltm);\n\n        ND_PRINT((ndo, \", Flags [%s]\",\n               bittok2str(cfm_ltm_flag_values, \"none\", cfm_common_header->flags)));\n\n        ND_PRINT((ndo, \"\\n\\t  Transaction-ID 0x%08x, ttl %u\",\n               EXTRACT_32BITS(msg_ptr.cfm_ltm->transaction_id),\n               msg_ptr.cfm_ltm->ttl));\n\n        ND_PRINT((ndo, \"\\n\\t  Original-MAC %s, Target-MAC %s\",\n               etheraddr_string(ndo, msg_ptr.cfm_ltm->original_mac),\n               etheraddr_string(ndo, msg_ptr.cfm_ltm->target_mac)));\n        break;\n\n    case CFM_OPCODE_LTR:\n        msg_ptr.cfm_ltr = (const struct cfm_ltr_t *)tptr;\n        if (cfm_common_header->first_tlv_offset < sizeof(*msg_ptr.cfm_ltr)) {\n            ND_PRINT((ndo, \" (too small 5, must be >= %lu)\",\n                     (unsigned long) sizeof(*msg_ptr.cfm_ltr)));\n            return;\n        }\n        if (tlen < sizeof(*msg_ptr.cfm_ltr))\n            goto tooshort;\n        ND_TCHECK(*msg_ptr.cfm_ltr);\n\n        ND_PRINT((ndo, \", Flags [%s]\",\n               bittok2str(cfm_ltr_flag_values, \"none\", cfm_common_header->flags)));\n\n        ND_PRINT((ndo, \"\\n\\t  Transaction-ID 0x%08x, ttl %u\",\n               EXTRACT_32BITS(msg_ptr.cfm_ltr->transaction_id),\n               msg_ptr.cfm_ltr->ttl));\n\n        ND_PRINT((ndo, \"\\n\\t  Replay-Action %s (%u)\",\n               tok2str(cfm_ltr_replay_action_values,\n                       \"Unknown\",\n                       msg_ptr.cfm_ltr->replay_action),\n               msg_ptr.cfm_ltr->replay_action));\n        break;\n\n        /*\n         * No message decoder yet.\n         * Hexdump everything up until the start of the TLVs\n         */\n    case CFM_OPCODE_LBR:\n    case CFM_OPCODE_LBM:\n    default:\n        print_unknown_data(ndo, tptr, \"\\n\\t  \",\n                           tlen -  cfm_common_header->first_tlv_offset);\n        break;\n    }\n\n    tptr += cfm_common_header->first_tlv_offset;\n    tlen -= cfm_common_header->first_tlv_offset;\n\n    while (tlen > 0) {\n        cfm_tlv_header = (const struct cfm_tlv_header_t *)tptr;\n\n        /* Enough to read the tlv type ? */\n        ND_TCHECK2(*tptr, 1);\n        cfm_tlv_type=cfm_tlv_header->type;\n\n        ND_PRINT((ndo, \"\\n\\t%s TLV (0x%02x)\",\n               tok2str(cfm_tlv_values, \"Unknown\", cfm_tlv_type),\n               cfm_tlv_type));\n\n        if (cfm_tlv_type == CFM_TLV_END) {\n            /* Length is \"Not present if the Type field is 0.\" */\n            return;\n        }\n\n        /* do we have the full tlv header ? */\n        if (tlen < sizeof(struct cfm_tlv_header_t))\n            goto tooshort;\n        ND_TCHECK2(*tptr, sizeof(struct cfm_tlv_header_t));\n        cfm_tlv_len=EXTRACT_16BITS(&cfm_tlv_header->length);\n\n        ND_PRINT((ndo, \", length %u\", cfm_tlv_len));\n\n        tptr += sizeof(struct cfm_tlv_header_t);\n        tlen -= sizeof(struct cfm_tlv_header_t);\n        tlv_ptr = tptr;\n\n        /* do we have the full tlv ? */\n        if (tlen < cfm_tlv_len)\n            goto tooshort;\n        ND_TCHECK2(*tptr, cfm_tlv_len);\n        hexdump = FALSE;\n\n        switch(cfm_tlv_type) {\n        case CFM_TLV_PORT_STATUS:\n            if (cfm_tlv_len < 1) {\n                ND_PRINT((ndo, \" (too short, must be >= 1)\"));\n                return;\n            }\n            ND_PRINT((ndo, \", Status: %s (%u)\",\n                   tok2str(cfm_tlv_port_status_values, \"Unknown\", *tptr),\n                   *tptr));\n            break;\n\n        case CFM_TLV_INTERFACE_STATUS:\n            if (cfm_tlv_len < 1) {\n                ND_PRINT((ndo, \" (too short, must be >= 1)\"));\n                return;\n            }\n            ND_PRINT((ndo, \", Status: %s (%u)\",\n                   tok2str(cfm_tlv_interface_status_values, \"Unknown\", *tptr),\n                   *tptr));\n            break;\n\n        case CFM_TLV_PRIVATE:\n            if (cfm_tlv_len < 4) {\n                ND_PRINT((ndo, \" (too short, must be >= 4)\"));\n                return;\n            }\n            ND_PRINT((ndo, \", Vendor: %s (%u), Sub-Type %u\",\n                   tok2str(oui_values,\"Unknown\", EXTRACT_24BITS(tptr)),\n                   EXTRACT_24BITS(tptr),\n                   *(tptr + 3)));\n            hexdump = TRUE;\n            break;\n\n        case CFM_TLV_SENDER_ID:\n        {\n            u_int chassis_id_type, chassis_id_length;\n            u_int mgmt_addr_length;\n \n             if (cfm_tlv_len < 1) {\n                 ND_PRINT((ndo, \" (too short, must be >= 1)\"));\n                goto next_tlv;\n             }\n \n             /*\n              * Get the Chassis ID length and check it.\n             * IEEE 802.1Q-2014 Section 21.5.3.1\n              */\n             chassis_id_length = *tptr;\n             tptr++;\n             tlen--;\n             cfm_tlv_len--;\n \n             if (chassis_id_length) {\n                /*\n                 * IEEE 802.1Q-2014 Section 21.5.3.2: Chassis ID Subtype, references\n                 * IEEE 802.1AB-2005 Section 9.5.2.2, subsequently\n                 * IEEE 802.1AB-2016 Section 8.5.2.2: chassis ID subtype\n                 */\n                 if (cfm_tlv_len < 1) {\n                     ND_PRINT((ndo, \"\\n\\t  (TLV too short)\"));\n                    goto next_tlv;\n                 }\n                 chassis_id_type = *tptr;\n                 cfm_tlv_len--;\n                ND_PRINT((ndo, \"\\n\\t  Chassis-ID Type %s (%u), Chassis-ID length %u\",\n                       tok2str(cfm_tlv_senderid_chassisid_values,\n                               \"Unknown\",\n                               chassis_id_type),\n                       chassis_id_type,\n                       chassis_id_length));\n \n                 if (cfm_tlv_len < chassis_id_length) {\n                     ND_PRINT((ndo, \"\\n\\t  (TLV too short)\"));\n                    goto next_tlv;\n                 }\n \n                /* IEEE 802.1Q-2014 Section 21.5.3.3: Chassis ID */\n                 switch (chassis_id_type) {\n                 case CFM_CHASSIS_ID_MAC_ADDRESS:\n                    if (chassis_id_length != ETHER_ADDR_LEN) {\n                        ND_PRINT((ndo, \" (invalid MAC address length)\"));\n                        hexdump = TRUE;\n                        break;\n                    }\n                     ND_PRINT((ndo, \"\\n\\t  MAC %s\", etheraddr_string(ndo, tptr + 1)));\n                     break;\n \n                 case CFM_CHASSIS_ID_NETWORK_ADDRESS:\n                    hexdump |= cfm_network_addr_print(ndo, tptr + 1, chassis_id_length);\n                     break;\n \n                 case CFM_CHASSIS_ID_INTERFACE_NAME: /* fall through */\n                case CFM_CHASSIS_ID_INTERFACE_ALIAS:\n                case CFM_CHASSIS_ID_LOCAL:\n                case CFM_CHASSIS_ID_CHASSIS_COMPONENT:\n                case CFM_CHASSIS_ID_PORT_COMPONENT:\n                    safeputs(ndo, tptr + 1, chassis_id_length);\n                    break;\n\n                default:\n                    hexdump = TRUE;\n                    break;\n                }\n                cfm_tlv_len -= chassis_id_length;\n\n                tptr += 1 + chassis_id_length;\n                tlen -= 1 + chassis_id_length;\n            }\n \n             /*\n              * Check if there is a Management Address.\n             * IEEE 802.1Q-2014 Section 21.5.3.4: Management Address Domain Length\n             * This and all subsequent fields are not present if the TLV length\n             * allows only the above fields.\n              */\n             if (cfm_tlv_len == 0) {\n                 /* No, there isn't; we're done. */\n                break;\n             }\n \n            /* Here mgmt_addr_length stands for the management domain length. */\n             mgmt_addr_length = *tptr;\n             tptr++;\n             tlen--;\n             cfm_tlv_len--;\n            ND_PRINT((ndo, \"\\n\\t  Management Address Domain Length %u\", mgmt_addr_length));\n             if (mgmt_addr_length) {\n                /* IEEE 802.1Q-2014 Section 21.5.3.5: Management Address Domain */\n                 if (cfm_tlv_len < mgmt_addr_length) {\n                     ND_PRINT((ndo, \"\\n\\t  (TLV too short)\"));\n                    goto next_tlv;\n                 }\n                 cfm_tlv_len -= mgmt_addr_length;\n                 /*\n                  * XXX - this is an OID; print it as such.\n                  */\n                hex_print(ndo, \"\\n\\t  Management Address Domain: \", tptr, mgmt_addr_length);\n                 tptr += mgmt_addr_length;\n                 tlen -= mgmt_addr_length;\n \n                /*\n                 * IEEE 802.1Q-2014 Section 21.5.3.6: Management Address Length\n                 * This field is present if Management Address Domain Length is not 0.\n                 */\n                 if (cfm_tlv_len < 1) {\n                    ND_PRINT((ndo, \" (Management Address Length is missing)\"));\n                    hexdump = TRUE;\n                    break;\n                 }\n \n                /* Here mgmt_addr_length stands for the management address length. */\n                 mgmt_addr_length = *tptr;\n                 tptr++;\n                 tlen--;\n                 cfm_tlv_len--;\n                ND_PRINT((ndo, \"\\n\\t  Management Address Length %u\", mgmt_addr_length));\n                 if (mgmt_addr_length) {\n                    /* IEEE 802.1Q-2014 Section 21.5.3.7: Management Address */\n                     if (cfm_tlv_len < mgmt_addr_length) {\n                         ND_PRINT((ndo, \"\\n\\t  (TLV too short)\"));\n                         return;\n                    }\n                    cfm_tlv_len -= mgmt_addr_length;\n                     /*\n                      * XXX - this is a TransportDomain; print it as such.\n                      */\n                    hex_print(ndo, \"\\n\\t  Management Address: \", tptr, mgmt_addr_length);\n                     tptr += mgmt_addr_length;\n                     tlen -= mgmt_addr_length;\n                 }\n            }\n            break;\n        }\n\n            /*\n             * FIXME those are the defined TLVs that lack a decoder\n             * you are welcome to contribute code ;-)\n             */\n\n        case CFM_TLV_DATA:\n        case CFM_TLV_REPLY_INGRESS:\n        case CFM_TLV_REPLY_EGRESS:\n        default:\n            hexdump = TRUE;\n            break;\n        }\n        /* do we want to see an additional hexdump ? */\n         if (hexdump || ndo->ndo_vflag > 1)\n             print_unknown_data(ndo, tlv_ptr, \"\\n\\t  \", cfm_tlv_len);\n \nnext_tlv:\n         tptr+=cfm_tlv_len;\n         tlen-=cfm_tlv_len;\n     }\n    return;\n\ntooshort:\n    ND_PRINT((ndo, \"\\n\\t\\t packet is too short\"));\n    return;\n\ntrunc:\n    ND_PRINT((ndo, \"\\n\\t\\t packet exceeded snapshot\"));\n}\n",
    "cwe": [
      "CWE-125"
    ],
    "id": 498,
    "_valid_cwes": [
      "CWE-125"
    ]
  },
  {
    "cve_id": "CVE-2017-12893",
    "code_before_change": "name_len(netdissect_options *ndo,\n         const unsigned char *s, const unsigned char *maxbuf)\n{\n    const unsigned char *s0 = s;\n    unsigned char c;\n\n    if (s >= maxbuf)\n\treturn(-1);\t/* name goes past the end of the buffer */\n    ND_TCHECK2(*s, 1);\n    c = *s;\n    if ((c & 0xC0) == 0xC0)\n\treturn(2);\n    while (*s) {\n\tif (s >= maxbuf)\n \t    return(-1);\t/* name goes past the end of the buffer */\n \tND_TCHECK2(*s, 1);\n \ts += (*s) + 1;\n     }\n     return(PTR_DIFF(s, s0) + 1);\n \ntrunc:\n    return(-1);\t/* name goes past the end of the buffer */\n}\n",
    "code_after_change": "name_len(netdissect_options *ndo,\n         const unsigned char *s, const unsigned char *maxbuf)\n{\n    const unsigned char *s0 = s;\n    unsigned char c;\n\n    if (s >= maxbuf)\n\treturn(-1);\t/* name goes past the end of the buffer */\n    ND_TCHECK2(*s, 1);\n    c = *s;\n    if ((c & 0xC0) == 0xC0)\n\treturn(2);\n    while (*s) {\n\tif (s >= maxbuf)\n \t    return(-1);\t/* name goes past the end of the buffer */\n \tND_TCHECK2(*s, 1);\n \ts += (*s) + 1;\n\tND_TCHECK2(*s, 1);\n     }\n     return(PTR_DIFF(s, s0) + 1);\n \ntrunc:\n    return(-1);\t/* name goes past the end of the buffer */\n}\n",
    "cwe": [
      "CWE-125"
    ],
    "id": 500,
    "_valid_cwes": [
      "CWE-125"
    ]
  },
  {
    "cve_id": "CVE-2017-12991",
    "code_before_change": "bgp_attr_print(netdissect_options *ndo,\n               u_int atype, const u_char *pptr, u_int len)\n{\n\tint i;\n\tuint16_t af;\n\tuint8_t safi, snpa, nhlen;\n        union { /* copy buffer for bandwidth values */\n            float f;\n            uint32_t i;\n        } bw;\n\tint advance;\n\tu_int tlen;\n\tconst u_char *tptr;\n\tchar buf[MAXHOSTNAMELEN + 100];\n        int  as_size;\n\n        tptr = pptr;\n        tlen=len;\n\n\tswitch (atype) {\n\tcase BGPTYPE_ORIGIN:\n\t\tif (len != 1)\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\telse {\n\t\t\tND_TCHECK(*tptr);\n\t\t\tND_PRINT((ndo, \"%s\", tok2str(bgp_origin_values,\n\t\t\t\t\t\t\"Unknown Origin Typecode\",\n\t\t\t\t\t\ttptr[0])));\n\t\t}\n\t\tbreak;\n\n        /*\n         * Process AS4 byte path and AS2 byte path attributes here.\n         */\n\tcase BGPTYPE_AS4_PATH:\n\tcase BGPTYPE_AS_PATH:\n\t\tif (len % 2) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n                if (!len) {\n\t\t\tND_PRINT((ndo, \"empty\"));\n\t\t\tbreak;\n                }\n\n                /*\n                 * BGP updates exchanged between New speakers that support 4\n                 * byte AS, ASs are always encoded in 4 bytes. There is no\n                 * definitive way to find this, just by the packet's\n                 * contents. So, check for packet's TLV's sanity assuming\n                 * 2 bytes first, and it does not pass, assume that ASs are\n                 * encoded in 4 bytes format and move on.\n                 */\n                as_size = bgp_attr_get_as_size(ndo, atype, pptr, len);\n\n\t\twhile (tptr < pptr + len) {\n \t\t\tND_TCHECK(tptr[0]);\n                         ND_PRINT((ndo, \"%s\", tok2str(bgp_as_path_segment_open_values,\n \t\t\t\t\t\t\"?\", tptr[0])));\n                         for (i = 0; i < tptr[1] * as_size; i += as_size) {\n                             ND_TCHECK2(tptr[2 + i], as_size);\n \t\t\t    ND_PRINT((ndo, \"%s \",\n\t\t\t\tas_printf(ndo, astostr, sizeof(astostr),\n\t\t\t\tas_size == 2 ?\n\t\t\t\tEXTRACT_16BITS(&tptr[2 + i]) :\n\t\t\t\tEXTRACT_32BITS(&tptr[2 + i]))));\n                        }\n\t\t\tND_TCHECK(tptr[0]);\n                        ND_PRINT((ndo, \"%s\", tok2str(bgp_as_path_segment_close_values,\n\t\t\t\t\t\t\"?\", tptr[0])));\n                        ND_TCHECK(tptr[1]);\n                        tptr += 2 + tptr[1] * as_size;\n\t\t}\n\t\tbreak;\n\tcase BGPTYPE_NEXT_HOP:\n\t\tif (len != 4)\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\telse {\n\t\t\tND_TCHECK2(tptr[0], 4);\n\t\t\tND_PRINT((ndo, \"%s\", ipaddr_string(ndo, tptr)));\n\t\t}\n\t\tbreak;\n\tcase BGPTYPE_MULTI_EXIT_DISC:\n\tcase BGPTYPE_LOCAL_PREF:\n\t\tif (len != 4)\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\telse {\n\t\t\tND_TCHECK2(tptr[0], 4);\n\t\t\tND_PRINT((ndo, \"%u\", EXTRACT_32BITS(tptr)));\n\t\t}\n\t\tbreak;\n\tcase BGPTYPE_ATOMIC_AGGREGATE:\n\t\tif (len != 0)\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\tbreak;\n        case BGPTYPE_AGGREGATOR:\n\n                /*\n                 * Depending on the AS encoded is of 2 bytes or of 4 bytes,\n                 * the length of this PA can be either 6 bytes or 8 bytes.\n                 */\n                if (len != 6 && len != 8) {\n                    ND_PRINT((ndo, \"invalid len\"));\n                    break;\n                }\n                ND_TCHECK2(tptr[0], len);\n                if (len == 6) {\n\t\t    ND_PRINT((ndo, \" AS #%s, origin %s\",\n\t\t\tas_printf(ndo, astostr, sizeof(astostr), EXTRACT_16BITS(tptr)),\n\t\t\tipaddr_string(ndo, tptr + 2)));\n                } else {\n\t\t    ND_PRINT((ndo, \" AS #%s, origin %s\",\n\t\t\tas_printf(ndo, astostr, sizeof(astostr),\n\t\t\tEXTRACT_32BITS(tptr)), ipaddr_string(ndo, tptr + 4)));\n                }\n                break;\n\tcase BGPTYPE_AGGREGATOR4:\n\t\tif (len != 8) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n\t\tND_TCHECK2(tptr[0], 8);\n\t\tND_PRINT((ndo, \" AS #%s, origin %s\",\n\t   \t    as_printf(ndo, astostr, sizeof(astostr), EXTRACT_32BITS(tptr)),\n\t\t    ipaddr_string(ndo, tptr + 4)));\n\t\tbreak;\n\tcase BGPTYPE_COMMUNITIES:\n\t\tif (len % 4) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n\t\twhile (tlen>0) {\n\t\t\tuint32_t comm;\n\t\t\tND_TCHECK2(tptr[0], 4);\n\t\t\tcomm = EXTRACT_32BITS(tptr);\n\t\t\tswitch (comm) {\n\t\t\tcase BGP_COMMUNITY_NO_EXPORT:\n\t\t\t\tND_PRINT((ndo, \" NO_EXPORT\"));\n\t\t\t\tbreak;\n\t\t\tcase BGP_COMMUNITY_NO_ADVERT:\n\t\t\t\tND_PRINT((ndo, \" NO_ADVERTISE\"));\n\t\t\t\tbreak;\n\t\t\tcase BGP_COMMUNITY_NO_EXPORT_SUBCONFED:\n\t\t\t\tND_PRINT((ndo, \" NO_EXPORT_SUBCONFED\"));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tND_PRINT((ndo, \"%u:%u%s\",\n                                       (comm >> 16) & 0xffff,\n                                       comm & 0xffff,\n                                       (tlen>4) ? \", \" : \"\"));\n\t\t\t\tbreak;\n\t\t\t}\n                        tlen -=4;\n                        tptr +=4;\n\t\t}\n\t\tbreak;\n        case BGPTYPE_ORIGINATOR_ID:\n\t\tif (len != 4) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n\t\tND_TCHECK2(tptr[0], 4);\n                ND_PRINT((ndo, \"%s\",ipaddr_string(ndo, tptr)));\n                break;\n        case BGPTYPE_CLUSTER_LIST:\n\t\tif (len % 4) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n                while (tlen>0) {\n\t\t\tND_TCHECK2(tptr[0], 4);\n                        ND_PRINT((ndo, \"%s%s\",\n                               ipaddr_string(ndo, tptr),\n                                (tlen>4) ? \", \" : \"\"));\n                        tlen -=4;\n                        tptr +=4;\n                }\n                break;\n\tcase BGPTYPE_MP_REACH_NLRI:\n\t\tND_TCHECK2(tptr[0], 3);\n\t\taf = EXTRACT_16BITS(tptr);\n\t\tsafi = tptr[2];\n\n                ND_PRINT((ndo, \"\\n\\t    AFI: %s (%u), %sSAFI: %s (%u)\",\n                       tok2str(af_values, \"Unknown AFI\", af),\n                       af,\n                       (safi>128) ? \"vendor specific \" : \"\", /* 128 is meanwhile wellknown */\n                       tok2str(bgp_safi_values, \"Unknown SAFI\", safi),\n                       safi));\n\n                switch(af<<8 | safi) {\n                case (AFNUM_INET<<8 | SAFNUM_UNICAST):\n                case (AFNUM_INET<<8 | SAFNUM_MULTICAST):\n                case (AFNUM_INET<<8 | SAFNUM_UNIMULTICAST):\n                case (AFNUM_INET<<8 | SAFNUM_LABUNICAST):\n                case (AFNUM_INET<<8 | SAFNUM_RT_ROUTING_INFO):\n                case (AFNUM_INET<<8 | SAFNUM_VPNUNICAST):\n                case (AFNUM_INET<<8 | SAFNUM_VPNMULTICAST):\n                case (AFNUM_INET<<8 | SAFNUM_VPNUNIMULTICAST):\n                case (AFNUM_INET<<8 | SAFNUM_MULTICAST_VPN):\n\t\tcase (AFNUM_INET<<8 | SAFNUM_MDT):\n                case (AFNUM_INET6<<8 | SAFNUM_UNICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_MULTICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_UNIMULTICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_LABUNICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_VPNUNICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_VPNMULTICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_VPNUNIMULTICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_UNICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_MULTICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_UNIMULTICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_VPNUNICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_VPNMULTICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_VPNUNIMULTICAST):\n                case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNICAST):\n                case (AFNUM_L2VPN<<8 | SAFNUM_VPNMULTICAST):\n                case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNIMULTICAST):\n                case (AFNUM_VPLS<<8 | SAFNUM_VPLS):\n                    break;\n                default:\n                    ND_TCHECK2(tptr[0], tlen);\n                    ND_PRINT((ndo, \"\\n\\t    no AFI %u / SAFI %u decoder\", af, safi));\n                    if (ndo->ndo_vflag <= 1)\n                        print_unknown_data(ndo, tptr, \"\\n\\t    \", tlen);\n                    goto done;\n                    break;\n                }\n\n                tptr +=3;\n\n\t\tND_TCHECK(tptr[0]);\n\t\tnhlen = tptr[0];\n                tlen = nhlen;\n                tptr++;\n\n\t\tif (tlen) {\n                    int nnh = 0;\n                    ND_PRINT((ndo, \"\\n\\t    nexthop: \"));\n                    while (tlen > 0) {\n                        if ( nnh++ > 0 ) {\n                            ND_PRINT((ndo,  \", \" ));\n                        }\n                        switch(af<<8 | safi) {\n                        case (AFNUM_INET<<8 | SAFNUM_UNICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_MULTICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_UNIMULTICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_LABUNICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_RT_ROUTING_INFO):\n                        case (AFNUM_INET<<8 | SAFNUM_MULTICAST_VPN):\n                        case (AFNUM_INET<<8 | SAFNUM_MDT):\n\t\t\t    if (tlen < (int)sizeof(struct in_addr)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in_addr));\n                                ND_PRINT((ndo, \"%s\",ipaddr_string(ndo, tptr)));\n                                tlen -= sizeof(struct in_addr);\n                                tptr += sizeof(struct in_addr);\n                            }\n                            break;\n                        case (AFNUM_INET<<8 | SAFNUM_VPNUNICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_VPNMULTICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_VPNUNIMULTICAST):\n                            if (tlen < (int)(sizeof(struct in_addr)+BGP_VPN_RD_LEN)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in_addr)+BGP_VPN_RD_LEN);\n                                ND_PRINT((ndo, \"RD: %s, %s\",\n                                       bgp_vpn_rd_print(ndo, tptr),\n                                       ipaddr_string(ndo, tptr+BGP_VPN_RD_LEN)));\n                                tlen -= (sizeof(struct in_addr)+BGP_VPN_RD_LEN);\n                                tptr += (sizeof(struct in_addr)+BGP_VPN_RD_LEN);\n                            }\n                            break;\n                        case (AFNUM_INET6<<8 | SAFNUM_UNICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_MULTICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_UNIMULTICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_LABUNICAST):\n                            if (tlen < (int)sizeof(struct in6_addr)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in6_addr));\n                                ND_PRINT((ndo, \"%s\", ip6addr_string(ndo, tptr)));\n                                tlen -= sizeof(struct in6_addr);\n                                tptr += sizeof(struct in6_addr);\n                            }\n                            break;\n                        case (AFNUM_INET6<<8 | SAFNUM_VPNUNICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_VPNMULTICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_VPNUNIMULTICAST):\n                            if (tlen < (int)(sizeof(struct in6_addr)+BGP_VPN_RD_LEN)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in6_addr)+BGP_VPN_RD_LEN);\n                                ND_PRINT((ndo, \"RD: %s, %s\",\n                                       bgp_vpn_rd_print(ndo, tptr),\n                                       ip6addr_string(ndo, tptr+BGP_VPN_RD_LEN)));\n                                tlen -= (sizeof(struct in6_addr)+BGP_VPN_RD_LEN);\n                                tptr += (sizeof(struct in6_addr)+BGP_VPN_RD_LEN);\n                            }\n                            break;\n                        case (AFNUM_VPLS<<8 | SAFNUM_VPLS):\n                        case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNICAST):\n                        case (AFNUM_L2VPN<<8 | SAFNUM_VPNMULTICAST):\n                        case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNIMULTICAST):\n                            if (tlen < (int)sizeof(struct in_addr)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in_addr));\n                                ND_PRINT((ndo, \"%s\", ipaddr_string(ndo, tptr)));\n                                tlen -= (sizeof(struct in_addr));\n                                tptr += (sizeof(struct in_addr));\n                            }\n                            break;\n                        case (AFNUM_NSAP<<8 | SAFNUM_UNICAST):\n                        case (AFNUM_NSAP<<8 | SAFNUM_MULTICAST):\n                        case (AFNUM_NSAP<<8 | SAFNUM_UNIMULTICAST):\n                            ND_TCHECK2(tptr[0], tlen);\n                            ND_PRINT((ndo, \"%s\", isonsap_string(ndo, tptr, tlen)));\n                            tptr += tlen;\n                            tlen = 0;\n                            break;\n\n                        case (AFNUM_NSAP<<8 | SAFNUM_VPNUNICAST):\n                        case (AFNUM_NSAP<<8 | SAFNUM_VPNMULTICAST):\n                        case (AFNUM_NSAP<<8 | SAFNUM_VPNUNIMULTICAST):\n                            if (tlen < BGP_VPN_RD_LEN+1) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], tlen);\n                                ND_PRINT((ndo, \"RD: %s, %s\",\n                                       bgp_vpn_rd_print(ndo, tptr),\n                                       isonsap_string(ndo, tptr+BGP_VPN_RD_LEN,tlen-BGP_VPN_RD_LEN)));\n                                /* rfc986 mapped IPv4 address ? */\n                                if (EXTRACT_32BITS(tptr+BGP_VPN_RD_LEN) ==  0x47000601)\n                                    ND_PRINT((ndo, \" = %s\", ipaddr_string(ndo, tptr+BGP_VPN_RD_LEN+4)));\n                                /* rfc1888 mapped IPv6 address ? */\n                                else if (EXTRACT_24BITS(tptr+BGP_VPN_RD_LEN) ==  0x350000)\n                                    ND_PRINT((ndo, \" = %s\", ip6addr_string(ndo, tptr+BGP_VPN_RD_LEN+3)));\n                                tptr += tlen;\n                                tlen = 0;\n                            }\n                            break;\n                        default:\n                            ND_TCHECK2(tptr[0], tlen);\n                            ND_PRINT((ndo, \"no AFI %u/SAFI %u decoder\", af, safi));\n                            if (ndo->ndo_vflag <= 1)\n                                print_unknown_data(ndo, tptr, \"\\n\\t    \", tlen);\n                            tptr += tlen;\n                            tlen = 0;\n                            goto done;\n                            break;\n                        }\n                    }\n\t\t}\n\t\tND_PRINT((ndo, \", nh-length: %u\", nhlen));\n\t\ttptr += tlen;\n\n\t\tND_TCHECK(tptr[0]);\n\t\tsnpa = tptr[0];\n\t\ttptr++;\n\n\t\tif (snpa) {\n\t\t\tND_PRINT((ndo, \"\\n\\t    %u SNPA\", snpa));\n\t\t\tfor (/*nothing*/; snpa > 0; snpa--) {\n\t\t\t\tND_TCHECK(tptr[0]);\n\t\t\t\tND_PRINT((ndo, \"\\n\\t      %d bytes\", tptr[0]));\n\t\t\t\ttptr += tptr[0] + 1;\n\t\t\t}\n\t\t} else {\n\t\t\tND_PRINT((ndo, \", no SNPA\"));\n                }\n\n\t\twhile (len - (tptr - pptr) > 0) {\n                    switch (af<<8 | safi) {\n                    case (AFNUM_INET<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_prefix4(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_LABUNICAST):\n                        advance = decode_labeled_prefix4(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_prefix4(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_RT_ROUTING_INFO):\n                        advance = decode_rt_routing_info(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_MULTICAST_VPN): /* fall through */\n                    case (AFNUM_INET6<<8 | SAFNUM_MULTICAST_VPN):\n                        advance = decode_multicast_vpn(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n\n\t\t    case (AFNUM_INET<<8 | SAFNUM_MDT):\n\t\t      advance = decode_mdt_vpn_nlri(ndo, tptr, buf, sizeof(buf));\n\t\t      if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n\t\t       break;\n                    case (AFNUM_INET6<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_prefix6(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_LABUNICAST):\n                        advance = decode_labeled_prefix6(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_prefix6(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_VPLS<<8 | SAFNUM_VPLS):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_l2(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_NSAP<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_clnp_prefix(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_clnp_prefix(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    default:\n                        ND_TCHECK2(*tptr,tlen);\n                        ND_PRINT((ndo, \"\\n\\t    no AFI %u / SAFI %u decoder\", af, safi));\n                        if (ndo->ndo_vflag <= 1)\n                            print_unknown_data(ndo, tptr, \"\\n\\t    \", tlen);\n                        advance = 0;\n                        tptr = pptr + len;\n                        break;\n                    }\n                    if (advance < 0)\n                        break;\n                    tptr += advance;\n\t\t}\n        done:\n\t\tbreak;\n\n\tcase BGPTYPE_MP_UNREACH_NLRI:\n\t\tND_TCHECK2(tptr[0], BGP_MP_NLRI_MINSIZE);\n\t\taf = EXTRACT_16BITS(tptr);\n\t\tsafi = tptr[2];\n\n                ND_PRINT((ndo, \"\\n\\t    AFI: %s (%u), %sSAFI: %s (%u)\",\n                       tok2str(af_values, \"Unknown AFI\", af),\n                       af,\n                       (safi>128) ? \"vendor specific \" : \"\", /* 128 is meanwhile wellknown */\n                       tok2str(bgp_safi_values, \"Unknown SAFI\", safi),\n                       safi));\n\n                if (len == BGP_MP_NLRI_MINSIZE)\n                    ND_PRINT((ndo, \"\\n\\t      End-of-Rib Marker (empty NLRI)\"));\n\n\t\ttptr += 3;\n\n\t\twhile (len - (tptr - pptr) > 0) {\n                    switch (af<<8 | safi) {\n                    case (AFNUM_INET<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_prefix4(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_LABUNICAST):\n                        advance = decode_labeled_prefix4(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_prefix4(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_prefix6(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_LABUNICAST):\n                        advance = decode_labeled_prefix6(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_prefix6(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_VPLS<<8 | SAFNUM_VPLS):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_l2(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_NSAP<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_clnp_prefix(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_clnp_prefix(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n\t\t    case (AFNUM_INET<<8 | SAFNUM_MDT):\n\t\t      advance = decode_mdt_vpn_nlri(ndo, tptr, buf, sizeof(buf));\n\t\t      if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n\t\t       break;\n                    case (AFNUM_INET<<8 | SAFNUM_MULTICAST_VPN): /* fall through */\n                    case (AFNUM_INET6<<8 | SAFNUM_MULTICAST_VPN):\n                        advance = decode_multicast_vpn(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    default:\n                        ND_TCHECK2(*(tptr-3),tlen);\n                        ND_PRINT((ndo, \"no AFI %u / SAFI %u decoder\", af, safi));\n                        if (ndo->ndo_vflag <= 1)\n                            print_unknown_data(ndo, tptr-3, \"\\n\\t    \", tlen);\n                        advance = 0;\n                        tptr = pptr + len;\n                        break;\n                    }\n                    if (advance < 0)\n                        break;\n                    tptr += advance;\n\t\t}\n\t\tbreak;\n        case BGPTYPE_EXTD_COMMUNITIES:\n\t\tif (len % 8) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n                while (tlen>0) {\n                    uint16_t extd_comm;\n\n                    ND_TCHECK2(tptr[0], 2);\n                    extd_comm=EXTRACT_16BITS(tptr);\n\n\t\t    ND_PRINT((ndo, \"\\n\\t    %s (0x%04x), Flags [%s]\",\n\t\t\t   tok2str(bgp_extd_comm_subtype_values,\n\t\t\t\t      \"unknown extd community typecode\",\n\t\t\t\t      extd_comm),\n\t\t\t   extd_comm,\n\t\t\t   bittok2str(bgp_extd_comm_flag_values, \"none\", extd_comm)));\n\n                    ND_TCHECK2(*(tptr+2), 6);\n                    switch(extd_comm) {\n                    case BGP_EXT_COM_RT_0:\n                    case BGP_EXT_COM_RO_0:\n                    case BGP_EXT_COM_L2VPN_RT_0:\n                        ND_PRINT((ndo, \": %u:%u (= %s)\",\n                               EXTRACT_16BITS(tptr+2),\n                               EXTRACT_32BITS(tptr+4),\n                               ipaddr_string(ndo, tptr+4)));\n                        break;\n                    case BGP_EXT_COM_RT_1:\n                    case BGP_EXT_COM_RO_1:\n                    case BGP_EXT_COM_L2VPN_RT_1:\n                    case BGP_EXT_COM_VRF_RT_IMP:\n                        ND_PRINT((ndo, \": %s:%u\",\n                               ipaddr_string(ndo, tptr+2),\n                               EXTRACT_16BITS(tptr+6)));\n                        break;\n                    case BGP_EXT_COM_RT_2:\n                    case BGP_EXT_COM_RO_2:\n\t\t\tND_PRINT((ndo, \": %s:%u\",\n\t\t\t    as_printf(ndo, astostr, sizeof(astostr),\n\t\t\t    EXTRACT_32BITS(tptr+2)), EXTRACT_16BITS(tptr+6)));\n\t\t\tbreak;\n                    case BGP_EXT_COM_LINKBAND:\n\t\t        bw.i = EXTRACT_32BITS(tptr+2);\n                        ND_PRINT((ndo, \": bandwidth: %.3f Mbps\",\n                               bw.f*8/1000000));\n                        break;\n                    case BGP_EXT_COM_VPN_ORIGIN:\n                    case BGP_EXT_COM_VPN_ORIGIN2:\n                    case BGP_EXT_COM_VPN_ORIGIN3:\n                    case BGP_EXT_COM_VPN_ORIGIN4:\n                    case BGP_EXT_COM_OSPF_RID:\n                    case BGP_EXT_COM_OSPF_RID2:\n                        ND_PRINT((ndo, \"%s\", ipaddr_string(ndo, tptr+2)));\n                        break;\n                    case BGP_EXT_COM_OSPF_RTYPE:\n                    case BGP_EXT_COM_OSPF_RTYPE2:\n                        ND_PRINT((ndo, \": area:%s, router-type:%s, metric-type:%s%s\",\n                               ipaddr_string(ndo, tptr+2),\n                               tok2str(bgp_extd_comm_ospf_rtype_values,\n\t\t\t\t\t  \"unknown (0x%02x)\",\n\t\t\t\t\t  *(tptr+6)),\n                               (*(tptr+7) &  BGP_OSPF_RTYPE_METRIC_TYPE) ? \"E2\" : \"\",\n                               ((*(tptr+6) == BGP_OSPF_RTYPE_EXT) || (*(tptr+6) == BGP_OSPF_RTYPE_NSSA)) ? \"E1\" : \"\"));\n                        break;\n                    case BGP_EXT_COM_L2INFO:\n                        ND_PRINT((ndo, \": %s Control Flags [0x%02x]:MTU %u\",\n                               tok2str(l2vpn_encaps_values,\n\t\t\t\t\t  \"unknown encaps\",\n\t\t\t\t\t  *(tptr+2)),\n                                       *(tptr+3),\n                               EXTRACT_16BITS(tptr+4)));\n                        break;\n                    case BGP_EXT_COM_SOURCE_AS:\n                        ND_PRINT((ndo, \": AS %u\", EXTRACT_16BITS(tptr+2)));\n                        break;\n                    default:\n                        ND_TCHECK2(*tptr,8);\n                        print_unknown_data(ndo, tptr, \"\\n\\t      \", 8);\n                        break;\n                    }\n                    tlen -=8;\n                    tptr +=8;\n                }\n                break;\n\n        case BGPTYPE_PMSI_TUNNEL:\n        {\n                uint8_t tunnel_type, flags;\n\n                tunnel_type = *(tptr+1);\n                flags = *tptr;\n                tlen = len;\n\n                ND_TCHECK2(tptr[0], 5);\n                ND_PRINT((ndo, \"\\n\\t    Tunnel-type %s (%u), Flags [%s], MPLS Label %u\",\n                       tok2str(bgp_pmsi_tunnel_values, \"Unknown\", tunnel_type),\n                       tunnel_type,\n                       bittok2str(bgp_pmsi_flag_values, \"none\", flags),\n                       EXTRACT_24BITS(tptr+2)>>4));\n\n                tptr +=5;\n                tlen -= 5;\n\n                switch (tunnel_type) {\n                case BGP_PMSI_TUNNEL_PIM_SM: /* fall through */\n                case BGP_PMSI_TUNNEL_PIM_BIDIR:\n                    ND_TCHECK2(tptr[0], 8);\n                    ND_PRINT((ndo, \"\\n\\t      Sender %s, P-Group %s\",\n                           ipaddr_string(ndo, tptr),\n                           ipaddr_string(ndo, tptr+4)));\n                    break;\n\n                case BGP_PMSI_TUNNEL_PIM_SSM:\n                    ND_TCHECK2(tptr[0], 8);\n                    ND_PRINT((ndo, \"\\n\\t      Root-Node %s, P-Group %s\",\n                           ipaddr_string(ndo, tptr),\n                           ipaddr_string(ndo, tptr+4)));\n                    break;\n                case BGP_PMSI_TUNNEL_INGRESS:\n                    ND_TCHECK2(tptr[0], 4);\n                    ND_PRINT((ndo, \"\\n\\t      Tunnel-Endpoint %s\",\n                           ipaddr_string(ndo, tptr)));\n                    break;\n                case BGP_PMSI_TUNNEL_LDP_P2MP: /* fall through */\n                case BGP_PMSI_TUNNEL_LDP_MP2MP:\n                    ND_TCHECK2(tptr[0], 8);\n                    ND_PRINT((ndo, \"\\n\\t      Root-Node %s, LSP-ID 0x%08x\",\n                           ipaddr_string(ndo, tptr),\n                           EXTRACT_32BITS(tptr+4)));\n                    break;\n                case BGP_PMSI_TUNNEL_RSVP_P2MP:\n                    ND_TCHECK2(tptr[0], 8);\n                    ND_PRINT((ndo, \"\\n\\t      Extended-Tunnel-ID %s, P2MP-ID 0x%08x\",\n                           ipaddr_string(ndo, tptr),\n                           EXTRACT_32BITS(tptr+4)));\n                    break;\n                default:\n                    if (ndo->ndo_vflag <= 1) {\n                        print_unknown_data(ndo, tptr, \"\\n\\t      \", tlen);\n                    }\n                }\n                break;\n        }\n\tcase BGPTYPE_AIGP:\n\t{\n\t\tuint8_t type;\n\t\tuint16_t length;\n\n\t\tND_TCHECK2(tptr[0], 3);\n\n\t\ttlen = len;\n\n\t\twhile (tlen >= 3) {\n\n\t\t    type = *tptr;\n\t\t    length = EXTRACT_16BITS(tptr+1);\n\n\t\t    ND_PRINT((ndo, \"\\n\\t    %s TLV (%u), length %u\",\n\t\t\t      tok2str(bgp_aigp_values, \"Unknown\", type),\n\t\t\t      type, length));\n\n\t\t    /*\n\t\t     * Check if we can read the TLV data.\n\t\t     */\n\t\t    ND_TCHECK2(tptr[3], length - 3);\n\n\t\t    switch (type) {\n\n\t\t    case BGP_AIGP_TLV:\n\t\t        ND_TCHECK2(tptr[3], 8);\n\t\t\tND_PRINT((ndo, \", metric %\" PRIu64,\n\t\t\t\t  EXTRACT_64BITS(tptr+3)));\n\t\t\tbreak;\n\n\t\t    default:\n\t\t\tif (ndo->ndo_vflag <= 1) {\n\t\t\t    print_unknown_data(ndo, tptr+3,\"\\n\\t      \", length-3);\n\t\t\t}\n\t\t    }\n\n\t\t    tptr += length;\n\t\t    tlen -= length;\n\t\t}\n\t\tbreak;\n\t}\n        case BGPTYPE_ATTR_SET:\n                ND_TCHECK2(tptr[0], 4);\n                if (len < 4)\n                \tgoto trunc;\n\t\tND_PRINT((ndo, \"\\n\\t    Origin AS: %s\",\n\t\t    as_printf(ndo, astostr, sizeof(astostr), EXTRACT_32BITS(tptr))));\n\t\ttptr+=4;\n                len -=4;\n\n                while (len) {\n                    u_int aflags, alenlen, alen;\n\n                    ND_TCHECK2(tptr[0], 2);\n                    if (len < 2)\n                        goto trunc;\n                    aflags = *tptr;\n                    atype = *(tptr + 1);\n                    tptr += 2;\n                    len -= 2;\n                    alenlen = bgp_attr_lenlen(aflags, tptr);\n                    ND_TCHECK2(tptr[0], alenlen);\n                    if (len < alenlen)\n                        goto trunc;\n                    alen = bgp_attr_len(aflags, tptr);\n                    tptr += alenlen;\n                    len -= alenlen;\n\n                    ND_PRINT((ndo, \"\\n\\t      %s (%u), length: %u\",\n                           tok2str(bgp_attr_values,\n                                      \"Unknown Attribute\", atype),\n                           atype,\n                           alen));\n\n                    if (aflags) {\n                        ND_PRINT((ndo, \", Flags [%s%s%s%s\",\n                               aflags & 0x80 ? \"O\" : \"\",\n                               aflags & 0x40 ? \"T\" : \"\",\n                               aflags & 0x20 ? \"P\" : \"\",\n                               aflags & 0x10 ? \"E\" : \"\"));\n                        if (aflags & 0xf)\n                            ND_PRINT((ndo, \"+%x\", aflags & 0xf));\n                        ND_PRINT((ndo, \"]: \"));\n                    }\n                    /* FIXME check for recursion */\n                    if (!bgp_attr_print(ndo, atype, tptr, alen))\n                        return 0;\n                    tptr += alen;\n                    len -= alen;\n\t\t}\n                break;\n\n\tcase BGPTYPE_LARGE_COMMUNITY:\n\t\tif (len == 0 || len % 12) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n\t\tND_PRINT((ndo, \"\\n\\t    \"));\n\t\twhile (len > 0) {\n\t\t\tND_TCHECK2(*tptr, 12);\n\t\t\tND_PRINT((ndo, \"%u:%u:%u%s\",\n\t\t\t\t EXTRACT_32BITS(tptr),\n\t\t\t\t EXTRACT_32BITS(tptr + 4),\n\t\t\t\t EXTRACT_32BITS(tptr + 8),\n\t\t\t\t (len > 12) ? \", \" : \"\"));\n                        tptr += 12;\n                        len -= 12;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t    ND_TCHECK2(*pptr,len);\n            ND_PRINT((ndo, \"\\n\\t    no Attribute %u decoder\", atype)); /* we have no decoder for the attribute */\n            if (ndo->ndo_vflag <= 1)\n                print_unknown_data(ndo, pptr, \"\\n\\t    \", len);\n            break;\n\t}\n        if (ndo->ndo_vflag > 1 && len) { /* omit zero length attributes*/\n            ND_TCHECK2(*pptr,len);\n            print_unknown_data(ndo, pptr, \"\\n\\t    \", len);\n        }\n        return 1;\n\ntrunc:\n        return 0;\n}\n",
    "code_after_change": "bgp_attr_print(netdissect_options *ndo,\n               u_int atype, const u_char *pptr, u_int len)\n{\n\tint i;\n\tuint16_t af;\n\tuint8_t safi, snpa, nhlen;\n        union { /* copy buffer for bandwidth values */\n            float f;\n            uint32_t i;\n        } bw;\n\tint advance;\n\tu_int tlen;\n\tconst u_char *tptr;\n\tchar buf[MAXHOSTNAMELEN + 100];\n        int  as_size;\n\n        tptr = pptr;\n        tlen=len;\n\n\tswitch (atype) {\n\tcase BGPTYPE_ORIGIN:\n\t\tif (len != 1)\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\telse {\n\t\t\tND_TCHECK(*tptr);\n\t\t\tND_PRINT((ndo, \"%s\", tok2str(bgp_origin_values,\n\t\t\t\t\t\t\"Unknown Origin Typecode\",\n\t\t\t\t\t\ttptr[0])));\n\t\t}\n\t\tbreak;\n\n        /*\n         * Process AS4 byte path and AS2 byte path attributes here.\n         */\n\tcase BGPTYPE_AS4_PATH:\n\tcase BGPTYPE_AS_PATH:\n\t\tif (len % 2) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n                if (!len) {\n\t\t\tND_PRINT((ndo, \"empty\"));\n\t\t\tbreak;\n                }\n\n                /*\n                 * BGP updates exchanged between New speakers that support 4\n                 * byte AS, ASs are always encoded in 4 bytes. There is no\n                 * definitive way to find this, just by the packet's\n                 * contents. So, check for packet's TLV's sanity assuming\n                 * 2 bytes first, and it does not pass, assume that ASs are\n                 * encoded in 4 bytes format and move on.\n                 */\n                as_size = bgp_attr_get_as_size(ndo, atype, pptr, len);\n\n\t\twhile (tptr < pptr + len) {\n \t\t\tND_TCHECK(tptr[0]);\n                         ND_PRINT((ndo, \"%s\", tok2str(bgp_as_path_segment_open_values,\n \t\t\t\t\t\t\"?\", tptr[0])));\n\t\t\tND_TCHECK(tptr[1]);\n                         for (i = 0; i < tptr[1] * as_size; i += as_size) {\n                             ND_TCHECK2(tptr[2 + i], as_size);\n \t\t\t    ND_PRINT((ndo, \"%s \",\n\t\t\t\tas_printf(ndo, astostr, sizeof(astostr),\n\t\t\t\tas_size == 2 ?\n\t\t\t\tEXTRACT_16BITS(&tptr[2 + i]) :\n\t\t\t\tEXTRACT_32BITS(&tptr[2 + i]))));\n                        }\n\t\t\tND_TCHECK(tptr[0]);\n                        ND_PRINT((ndo, \"%s\", tok2str(bgp_as_path_segment_close_values,\n\t\t\t\t\t\t\"?\", tptr[0])));\n                        ND_TCHECK(tptr[1]);\n                        tptr += 2 + tptr[1] * as_size;\n\t\t}\n\t\tbreak;\n\tcase BGPTYPE_NEXT_HOP:\n\t\tif (len != 4)\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\telse {\n\t\t\tND_TCHECK2(tptr[0], 4);\n\t\t\tND_PRINT((ndo, \"%s\", ipaddr_string(ndo, tptr)));\n\t\t}\n\t\tbreak;\n\tcase BGPTYPE_MULTI_EXIT_DISC:\n\tcase BGPTYPE_LOCAL_PREF:\n\t\tif (len != 4)\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\telse {\n\t\t\tND_TCHECK2(tptr[0], 4);\n\t\t\tND_PRINT((ndo, \"%u\", EXTRACT_32BITS(tptr)));\n\t\t}\n\t\tbreak;\n\tcase BGPTYPE_ATOMIC_AGGREGATE:\n\t\tif (len != 0)\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\tbreak;\n        case BGPTYPE_AGGREGATOR:\n\n                /*\n                 * Depending on the AS encoded is of 2 bytes or of 4 bytes,\n                 * the length of this PA can be either 6 bytes or 8 bytes.\n                 */\n                if (len != 6 && len != 8) {\n                    ND_PRINT((ndo, \"invalid len\"));\n                    break;\n                }\n                ND_TCHECK2(tptr[0], len);\n                if (len == 6) {\n\t\t    ND_PRINT((ndo, \" AS #%s, origin %s\",\n\t\t\tas_printf(ndo, astostr, sizeof(astostr), EXTRACT_16BITS(tptr)),\n\t\t\tipaddr_string(ndo, tptr + 2)));\n                } else {\n\t\t    ND_PRINT((ndo, \" AS #%s, origin %s\",\n\t\t\tas_printf(ndo, astostr, sizeof(astostr),\n\t\t\tEXTRACT_32BITS(tptr)), ipaddr_string(ndo, tptr + 4)));\n                }\n                break;\n\tcase BGPTYPE_AGGREGATOR4:\n\t\tif (len != 8) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n\t\tND_TCHECK2(tptr[0], 8);\n\t\tND_PRINT((ndo, \" AS #%s, origin %s\",\n\t   \t    as_printf(ndo, astostr, sizeof(astostr), EXTRACT_32BITS(tptr)),\n\t\t    ipaddr_string(ndo, tptr + 4)));\n\t\tbreak;\n\tcase BGPTYPE_COMMUNITIES:\n\t\tif (len % 4) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n\t\twhile (tlen>0) {\n\t\t\tuint32_t comm;\n\t\t\tND_TCHECK2(tptr[0], 4);\n\t\t\tcomm = EXTRACT_32BITS(tptr);\n\t\t\tswitch (comm) {\n\t\t\tcase BGP_COMMUNITY_NO_EXPORT:\n\t\t\t\tND_PRINT((ndo, \" NO_EXPORT\"));\n\t\t\t\tbreak;\n\t\t\tcase BGP_COMMUNITY_NO_ADVERT:\n\t\t\t\tND_PRINT((ndo, \" NO_ADVERTISE\"));\n\t\t\t\tbreak;\n\t\t\tcase BGP_COMMUNITY_NO_EXPORT_SUBCONFED:\n\t\t\t\tND_PRINT((ndo, \" NO_EXPORT_SUBCONFED\"));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tND_PRINT((ndo, \"%u:%u%s\",\n                                       (comm >> 16) & 0xffff,\n                                       comm & 0xffff,\n                                       (tlen>4) ? \", \" : \"\"));\n\t\t\t\tbreak;\n\t\t\t}\n                        tlen -=4;\n                        tptr +=4;\n\t\t}\n\t\tbreak;\n        case BGPTYPE_ORIGINATOR_ID:\n\t\tif (len != 4) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n\t\tND_TCHECK2(tptr[0], 4);\n                ND_PRINT((ndo, \"%s\",ipaddr_string(ndo, tptr)));\n                break;\n        case BGPTYPE_CLUSTER_LIST:\n\t\tif (len % 4) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n                while (tlen>0) {\n\t\t\tND_TCHECK2(tptr[0], 4);\n                        ND_PRINT((ndo, \"%s%s\",\n                               ipaddr_string(ndo, tptr),\n                                (tlen>4) ? \", \" : \"\"));\n                        tlen -=4;\n                        tptr +=4;\n                }\n                break;\n\tcase BGPTYPE_MP_REACH_NLRI:\n\t\tND_TCHECK2(tptr[0], 3);\n\t\taf = EXTRACT_16BITS(tptr);\n\t\tsafi = tptr[2];\n\n                ND_PRINT((ndo, \"\\n\\t    AFI: %s (%u), %sSAFI: %s (%u)\",\n                       tok2str(af_values, \"Unknown AFI\", af),\n                       af,\n                       (safi>128) ? \"vendor specific \" : \"\", /* 128 is meanwhile wellknown */\n                       tok2str(bgp_safi_values, \"Unknown SAFI\", safi),\n                       safi));\n\n                switch(af<<8 | safi) {\n                case (AFNUM_INET<<8 | SAFNUM_UNICAST):\n                case (AFNUM_INET<<8 | SAFNUM_MULTICAST):\n                case (AFNUM_INET<<8 | SAFNUM_UNIMULTICAST):\n                case (AFNUM_INET<<8 | SAFNUM_LABUNICAST):\n                case (AFNUM_INET<<8 | SAFNUM_RT_ROUTING_INFO):\n                case (AFNUM_INET<<8 | SAFNUM_VPNUNICAST):\n                case (AFNUM_INET<<8 | SAFNUM_VPNMULTICAST):\n                case (AFNUM_INET<<8 | SAFNUM_VPNUNIMULTICAST):\n                case (AFNUM_INET<<8 | SAFNUM_MULTICAST_VPN):\n\t\tcase (AFNUM_INET<<8 | SAFNUM_MDT):\n                case (AFNUM_INET6<<8 | SAFNUM_UNICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_MULTICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_UNIMULTICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_LABUNICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_VPNUNICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_VPNMULTICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_VPNUNIMULTICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_UNICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_MULTICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_UNIMULTICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_VPNUNICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_VPNMULTICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_VPNUNIMULTICAST):\n                case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNICAST):\n                case (AFNUM_L2VPN<<8 | SAFNUM_VPNMULTICAST):\n                case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNIMULTICAST):\n                case (AFNUM_VPLS<<8 | SAFNUM_VPLS):\n                    break;\n                default:\n                    ND_TCHECK2(tptr[0], tlen);\n                    ND_PRINT((ndo, \"\\n\\t    no AFI %u / SAFI %u decoder\", af, safi));\n                    if (ndo->ndo_vflag <= 1)\n                        print_unknown_data(ndo, tptr, \"\\n\\t    \", tlen);\n                    goto done;\n                    break;\n                }\n\n                tptr +=3;\n\n\t\tND_TCHECK(tptr[0]);\n\t\tnhlen = tptr[0];\n                tlen = nhlen;\n                tptr++;\n\n\t\tif (tlen) {\n                    int nnh = 0;\n                    ND_PRINT((ndo, \"\\n\\t    nexthop: \"));\n                    while (tlen > 0) {\n                        if ( nnh++ > 0 ) {\n                            ND_PRINT((ndo,  \", \" ));\n                        }\n                        switch(af<<8 | safi) {\n                        case (AFNUM_INET<<8 | SAFNUM_UNICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_MULTICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_UNIMULTICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_LABUNICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_RT_ROUTING_INFO):\n                        case (AFNUM_INET<<8 | SAFNUM_MULTICAST_VPN):\n                        case (AFNUM_INET<<8 | SAFNUM_MDT):\n\t\t\t    if (tlen < (int)sizeof(struct in_addr)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in_addr));\n                                ND_PRINT((ndo, \"%s\",ipaddr_string(ndo, tptr)));\n                                tlen -= sizeof(struct in_addr);\n                                tptr += sizeof(struct in_addr);\n                            }\n                            break;\n                        case (AFNUM_INET<<8 | SAFNUM_VPNUNICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_VPNMULTICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_VPNUNIMULTICAST):\n                            if (tlen < (int)(sizeof(struct in_addr)+BGP_VPN_RD_LEN)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in_addr)+BGP_VPN_RD_LEN);\n                                ND_PRINT((ndo, \"RD: %s, %s\",\n                                       bgp_vpn_rd_print(ndo, tptr),\n                                       ipaddr_string(ndo, tptr+BGP_VPN_RD_LEN)));\n                                tlen -= (sizeof(struct in_addr)+BGP_VPN_RD_LEN);\n                                tptr += (sizeof(struct in_addr)+BGP_VPN_RD_LEN);\n                            }\n                            break;\n                        case (AFNUM_INET6<<8 | SAFNUM_UNICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_MULTICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_UNIMULTICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_LABUNICAST):\n                            if (tlen < (int)sizeof(struct in6_addr)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in6_addr));\n                                ND_PRINT((ndo, \"%s\", ip6addr_string(ndo, tptr)));\n                                tlen -= sizeof(struct in6_addr);\n                                tptr += sizeof(struct in6_addr);\n                            }\n                            break;\n                        case (AFNUM_INET6<<8 | SAFNUM_VPNUNICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_VPNMULTICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_VPNUNIMULTICAST):\n                            if (tlen < (int)(sizeof(struct in6_addr)+BGP_VPN_RD_LEN)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in6_addr)+BGP_VPN_RD_LEN);\n                                ND_PRINT((ndo, \"RD: %s, %s\",\n                                       bgp_vpn_rd_print(ndo, tptr),\n                                       ip6addr_string(ndo, tptr+BGP_VPN_RD_LEN)));\n                                tlen -= (sizeof(struct in6_addr)+BGP_VPN_RD_LEN);\n                                tptr += (sizeof(struct in6_addr)+BGP_VPN_RD_LEN);\n                            }\n                            break;\n                        case (AFNUM_VPLS<<8 | SAFNUM_VPLS):\n                        case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNICAST):\n                        case (AFNUM_L2VPN<<8 | SAFNUM_VPNMULTICAST):\n                        case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNIMULTICAST):\n                            if (tlen < (int)sizeof(struct in_addr)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in_addr));\n                                ND_PRINT((ndo, \"%s\", ipaddr_string(ndo, tptr)));\n                                tlen -= (sizeof(struct in_addr));\n                                tptr += (sizeof(struct in_addr));\n                            }\n                            break;\n                        case (AFNUM_NSAP<<8 | SAFNUM_UNICAST):\n                        case (AFNUM_NSAP<<8 | SAFNUM_MULTICAST):\n                        case (AFNUM_NSAP<<8 | SAFNUM_UNIMULTICAST):\n                            ND_TCHECK2(tptr[0], tlen);\n                            ND_PRINT((ndo, \"%s\", isonsap_string(ndo, tptr, tlen)));\n                            tptr += tlen;\n                            tlen = 0;\n                            break;\n\n                        case (AFNUM_NSAP<<8 | SAFNUM_VPNUNICAST):\n                        case (AFNUM_NSAP<<8 | SAFNUM_VPNMULTICAST):\n                        case (AFNUM_NSAP<<8 | SAFNUM_VPNUNIMULTICAST):\n                            if (tlen < BGP_VPN_RD_LEN+1) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], tlen);\n                                ND_PRINT((ndo, \"RD: %s, %s\",\n                                       bgp_vpn_rd_print(ndo, tptr),\n                                       isonsap_string(ndo, tptr+BGP_VPN_RD_LEN,tlen-BGP_VPN_RD_LEN)));\n                                /* rfc986 mapped IPv4 address ? */\n                                if (EXTRACT_32BITS(tptr+BGP_VPN_RD_LEN) ==  0x47000601)\n                                    ND_PRINT((ndo, \" = %s\", ipaddr_string(ndo, tptr+BGP_VPN_RD_LEN+4)));\n                                /* rfc1888 mapped IPv6 address ? */\n                                else if (EXTRACT_24BITS(tptr+BGP_VPN_RD_LEN) ==  0x350000)\n                                    ND_PRINT((ndo, \" = %s\", ip6addr_string(ndo, tptr+BGP_VPN_RD_LEN+3)));\n                                tptr += tlen;\n                                tlen = 0;\n                            }\n                            break;\n                        default:\n                            ND_TCHECK2(tptr[0], tlen);\n                            ND_PRINT((ndo, \"no AFI %u/SAFI %u decoder\", af, safi));\n                            if (ndo->ndo_vflag <= 1)\n                                print_unknown_data(ndo, tptr, \"\\n\\t    \", tlen);\n                            tptr += tlen;\n                            tlen = 0;\n                            goto done;\n                            break;\n                        }\n                    }\n\t\t}\n\t\tND_PRINT((ndo, \", nh-length: %u\", nhlen));\n\t\ttptr += tlen;\n\n\t\tND_TCHECK(tptr[0]);\n\t\tsnpa = tptr[0];\n\t\ttptr++;\n\n\t\tif (snpa) {\n\t\t\tND_PRINT((ndo, \"\\n\\t    %u SNPA\", snpa));\n\t\t\tfor (/*nothing*/; snpa > 0; snpa--) {\n\t\t\t\tND_TCHECK(tptr[0]);\n\t\t\t\tND_PRINT((ndo, \"\\n\\t      %d bytes\", tptr[0]));\n\t\t\t\ttptr += tptr[0] + 1;\n\t\t\t}\n\t\t} else {\n\t\t\tND_PRINT((ndo, \", no SNPA\"));\n                }\n\n\t\twhile (len - (tptr - pptr) > 0) {\n                    switch (af<<8 | safi) {\n                    case (AFNUM_INET<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_prefix4(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_LABUNICAST):\n                        advance = decode_labeled_prefix4(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_prefix4(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_RT_ROUTING_INFO):\n                        advance = decode_rt_routing_info(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_MULTICAST_VPN): /* fall through */\n                    case (AFNUM_INET6<<8 | SAFNUM_MULTICAST_VPN):\n                        advance = decode_multicast_vpn(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n\n\t\t    case (AFNUM_INET<<8 | SAFNUM_MDT):\n\t\t      advance = decode_mdt_vpn_nlri(ndo, tptr, buf, sizeof(buf));\n\t\t      if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n\t\t       break;\n                    case (AFNUM_INET6<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_prefix6(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_LABUNICAST):\n                        advance = decode_labeled_prefix6(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_prefix6(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_VPLS<<8 | SAFNUM_VPLS):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_l2(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_NSAP<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_clnp_prefix(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_clnp_prefix(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    default:\n                        ND_TCHECK2(*tptr,tlen);\n                        ND_PRINT((ndo, \"\\n\\t    no AFI %u / SAFI %u decoder\", af, safi));\n                        if (ndo->ndo_vflag <= 1)\n                            print_unknown_data(ndo, tptr, \"\\n\\t    \", tlen);\n                        advance = 0;\n                        tptr = pptr + len;\n                        break;\n                    }\n                    if (advance < 0)\n                        break;\n                    tptr += advance;\n\t\t}\n        done:\n\t\tbreak;\n\n\tcase BGPTYPE_MP_UNREACH_NLRI:\n\t\tND_TCHECK2(tptr[0], BGP_MP_NLRI_MINSIZE);\n\t\taf = EXTRACT_16BITS(tptr);\n\t\tsafi = tptr[2];\n\n                ND_PRINT((ndo, \"\\n\\t    AFI: %s (%u), %sSAFI: %s (%u)\",\n                       tok2str(af_values, \"Unknown AFI\", af),\n                       af,\n                       (safi>128) ? \"vendor specific \" : \"\", /* 128 is meanwhile wellknown */\n                       tok2str(bgp_safi_values, \"Unknown SAFI\", safi),\n                       safi));\n\n                if (len == BGP_MP_NLRI_MINSIZE)\n                    ND_PRINT((ndo, \"\\n\\t      End-of-Rib Marker (empty NLRI)\"));\n\n\t\ttptr += 3;\n\n\t\twhile (len - (tptr - pptr) > 0) {\n                    switch (af<<8 | safi) {\n                    case (AFNUM_INET<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_prefix4(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_LABUNICAST):\n                        advance = decode_labeled_prefix4(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_prefix4(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_prefix6(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_LABUNICAST):\n                        advance = decode_labeled_prefix6(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_prefix6(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_VPLS<<8 | SAFNUM_VPLS):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_l2(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_NSAP<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_clnp_prefix(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_clnp_prefix(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n\t\t    case (AFNUM_INET<<8 | SAFNUM_MDT):\n\t\t      advance = decode_mdt_vpn_nlri(ndo, tptr, buf, sizeof(buf));\n\t\t      if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n\t\t       break;\n                    case (AFNUM_INET<<8 | SAFNUM_MULTICAST_VPN): /* fall through */\n                    case (AFNUM_INET6<<8 | SAFNUM_MULTICAST_VPN):\n                        advance = decode_multicast_vpn(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    default:\n                        ND_TCHECK2(*(tptr-3),tlen);\n                        ND_PRINT((ndo, \"no AFI %u / SAFI %u decoder\", af, safi));\n                        if (ndo->ndo_vflag <= 1)\n                            print_unknown_data(ndo, tptr-3, \"\\n\\t    \", tlen);\n                        advance = 0;\n                        tptr = pptr + len;\n                        break;\n                    }\n                    if (advance < 0)\n                        break;\n                    tptr += advance;\n\t\t}\n\t\tbreak;\n        case BGPTYPE_EXTD_COMMUNITIES:\n\t\tif (len % 8) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n                while (tlen>0) {\n                    uint16_t extd_comm;\n\n                    ND_TCHECK2(tptr[0], 2);\n                    extd_comm=EXTRACT_16BITS(tptr);\n\n\t\t    ND_PRINT((ndo, \"\\n\\t    %s (0x%04x), Flags [%s]\",\n\t\t\t   tok2str(bgp_extd_comm_subtype_values,\n\t\t\t\t      \"unknown extd community typecode\",\n\t\t\t\t      extd_comm),\n\t\t\t   extd_comm,\n\t\t\t   bittok2str(bgp_extd_comm_flag_values, \"none\", extd_comm)));\n\n                    ND_TCHECK2(*(tptr+2), 6);\n                    switch(extd_comm) {\n                    case BGP_EXT_COM_RT_0:\n                    case BGP_EXT_COM_RO_0:\n                    case BGP_EXT_COM_L2VPN_RT_0:\n                        ND_PRINT((ndo, \": %u:%u (= %s)\",\n                               EXTRACT_16BITS(tptr+2),\n                               EXTRACT_32BITS(tptr+4),\n                               ipaddr_string(ndo, tptr+4)));\n                        break;\n                    case BGP_EXT_COM_RT_1:\n                    case BGP_EXT_COM_RO_1:\n                    case BGP_EXT_COM_L2VPN_RT_1:\n                    case BGP_EXT_COM_VRF_RT_IMP:\n                        ND_PRINT((ndo, \": %s:%u\",\n                               ipaddr_string(ndo, tptr+2),\n                               EXTRACT_16BITS(tptr+6)));\n                        break;\n                    case BGP_EXT_COM_RT_2:\n                    case BGP_EXT_COM_RO_2:\n\t\t\tND_PRINT((ndo, \": %s:%u\",\n\t\t\t    as_printf(ndo, astostr, sizeof(astostr),\n\t\t\t    EXTRACT_32BITS(tptr+2)), EXTRACT_16BITS(tptr+6)));\n\t\t\tbreak;\n                    case BGP_EXT_COM_LINKBAND:\n\t\t        bw.i = EXTRACT_32BITS(tptr+2);\n                        ND_PRINT((ndo, \": bandwidth: %.3f Mbps\",\n                               bw.f*8/1000000));\n                        break;\n                    case BGP_EXT_COM_VPN_ORIGIN:\n                    case BGP_EXT_COM_VPN_ORIGIN2:\n                    case BGP_EXT_COM_VPN_ORIGIN3:\n                    case BGP_EXT_COM_VPN_ORIGIN4:\n                    case BGP_EXT_COM_OSPF_RID:\n                    case BGP_EXT_COM_OSPF_RID2:\n                        ND_PRINT((ndo, \"%s\", ipaddr_string(ndo, tptr+2)));\n                        break;\n                    case BGP_EXT_COM_OSPF_RTYPE:\n                    case BGP_EXT_COM_OSPF_RTYPE2:\n                        ND_PRINT((ndo, \": area:%s, router-type:%s, metric-type:%s%s\",\n                               ipaddr_string(ndo, tptr+2),\n                               tok2str(bgp_extd_comm_ospf_rtype_values,\n\t\t\t\t\t  \"unknown (0x%02x)\",\n\t\t\t\t\t  *(tptr+6)),\n                               (*(tptr+7) &  BGP_OSPF_RTYPE_METRIC_TYPE) ? \"E2\" : \"\",\n                               ((*(tptr+6) == BGP_OSPF_RTYPE_EXT) || (*(tptr+6) == BGP_OSPF_RTYPE_NSSA)) ? \"E1\" : \"\"));\n                        break;\n                    case BGP_EXT_COM_L2INFO:\n                        ND_PRINT((ndo, \": %s Control Flags [0x%02x]:MTU %u\",\n                               tok2str(l2vpn_encaps_values,\n\t\t\t\t\t  \"unknown encaps\",\n\t\t\t\t\t  *(tptr+2)),\n                                       *(tptr+3),\n                               EXTRACT_16BITS(tptr+4)));\n                        break;\n                    case BGP_EXT_COM_SOURCE_AS:\n                        ND_PRINT((ndo, \": AS %u\", EXTRACT_16BITS(tptr+2)));\n                        break;\n                    default:\n                        ND_TCHECK2(*tptr,8);\n                        print_unknown_data(ndo, tptr, \"\\n\\t      \", 8);\n                        break;\n                    }\n                    tlen -=8;\n                    tptr +=8;\n                }\n                break;\n\n        case BGPTYPE_PMSI_TUNNEL:\n        {\n                uint8_t tunnel_type, flags;\n\n                tunnel_type = *(tptr+1);\n                flags = *tptr;\n                tlen = len;\n\n                ND_TCHECK2(tptr[0], 5);\n                ND_PRINT((ndo, \"\\n\\t    Tunnel-type %s (%u), Flags [%s], MPLS Label %u\",\n                       tok2str(bgp_pmsi_tunnel_values, \"Unknown\", tunnel_type),\n                       tunnel_type,\n                       bittok2str(bgp_pmsi_flag_values, \"none\", flags),\n                       EXTRACT_24BITS(tptr+2)>>4));\n\n                tptr +=5;\n                tlen -= 5;\n\n                switch (tunnel_type) {\n                case BGP_PMSI_TUNNEL_PIM_SM: /* fall through */\n                case BGP_PMSI_TUNNEL_PIM_BIDIR:\n                    ND_TCHECK2(tptr[0], 8);\n                    ND_PRINT((ndo, \"\\n\\t      Sender %s, P-Group %s\",\n                           ipaddr_string(ndo, tptr),\n                           ipaddr_string(ndo, tptr+4)));\n                    break;\n\n                case BGP_PMSI_TUNNEL_PIM_SSM:\n                    ND_TCHECK2(tptr[0], 8);\n                    ND_PRINT((ndo, \"\\n\\t      Root-Node %s, P-Group %s\",\n                           ipaddr_string(ndo, tptr),\n                           ipaddr_string(ndo, tptr+4)));\n                    break;\n                case BGP_PMSI_TUNNEL_INGRESS:\n                    ND_TCHECK2(tptr[0], 4);\n                    ND_PRINT((ndo, \"\\n\\t      Tunnel-Endpoint %s\",\n                           ipaddr_string(ndo, tptr)));\n                    break;\n                case BGP_PMSI_TUNNEL_LDP_P2MP: /* fall through */\n                case BGP_PMSI_TUNNEL_LDP_MP2MP:\n                    ND_TCHECK2(tptr[0], 8);\n                    ND_PRINT((ndo, \"\\n\\t      Root-Node %s, LSP-ID 0x%08x\",\n                           ipaddr_string(ndo, tptr),\n                           EXTRACT_32BITS(tptr+4)));\n                    break;\n                case BGP_PMSI_TUNNEL_RSVP_P2MP:\n                    ND_TCHECK2(tptr[0], 8);\n                    ND_PRINT((ndo, \"\\n\\t      Extended-Tunnel-ID %s, P2MP-ID 0x%08x\",\n                           ipaddr_string(ndo, tptr),\n                           EXTRACT_32BITS(tptr+4)));\n                    break;\n                default:\n                    if (ndo->ndo_vflag <= 1) {\n                        print_unknown_data(ndo, tptr, \"\\n\\t      \", tlen);\n                    }\n                }\n                break;\n        }\n\tcase BGPTYPE_AIGP:\n\t{\n\t\tuint8_t type;\n\t\tuint16_t length;\n\n\t\tND_TCHECK2(tptr[0], 3);\n\n\t\ttlen = len;\n\n\t\twhile (tlen >= 3) {\n\n\t\t    type = *tptr;\n\t\t    length = EXTRACT_16BITS(tptr+1);\n\n\t\t    ND_PRINT((ndo, \"\\n\\t    %s TLV (%u), length %u\",\n\t\t\t      tok2str(bgp_aigp_values, \"Unknown\", type),\n\t\t\t      type, length));\n\n\t\t    /*\n\t\t     * Check if we can read the TLV data.\n\t\t     */\n\t\t    ND_TCHECK2(tptr[3], length - 3);\n\n\t\t    switch (type) {\n\n\t\t    case BGP_AIGP_TLV:\n\t\t        ND_TCHECK2(tptr[3], 8);\n\t\t\tND_PRINT((ndo, \", metric %\" PRIu64,\n\t\t\t\t  EXTRACT_64BITS(tptr+3)));\n\t\t\tbreak;\n\n\t\t    default:\n\t\t\tif (ndo->ndo_vflag <= 1) {\n\t\t\t    print_unknown_data(ndo, tptr+3,\"\\n\\t      \", length-3);\n\t\t\t}\n\t\t    }\n\n\t\t    tptr += length;\n\t\t    tlen -= length;\n\t\t}\n\t\tbreak;\n\t}\n        case BGPTYPE_ATTR_SET:\n                ND_TCHECK2(tptr[0], 4);\n                if (len < 4)\n                \tgoto trunc;\n\t\tND_PRINT((ndo, \"\\n\\t    Origin AS: %s\",\n\t\t    as_printf(ndo, astostr, sizeof(astostr), EXTRACT_32BITS(tptr))));\n\t\ttptr+=4;\n                len -=4;\n\n                while (len) {\n                    u_int aflags, alenlen, alen;\n\n                    ND_TCHECK2(tptr[0], 2);\n                    if (len < 2)\n                        goto trunc;\n                    aflags = *tptr;\n                    atype = *(tptr + 1);\n                    tptr += 2;\n                    len -= 2;\n                    alenlen = bgp_attr_lenlen(aflags, tptr);\n                    ND_TCHECK2(tptr[0], alenlen);\n                    if (len < alenlen)\n                        goto trunc;\n                    alen = bgp_attr_len(aflags, tptr);\n                    tptr += alenlen;\n                    len -= alenlen;\n\n                    ND_PRINT((ndo, \"\\n\\t      %s (%u), length: %u\",\n                           tok2str(bgp_attr_values,\n                                      \"Unknown Attribute\", atype),\n                           atype,\n                           alen));\n\n                    if (aflags) {\n                        ND_PRINT((ndo, \", Flags [%s%s%s%s\",\n                               aflags & 0x80 ? \"O\" : \"\",\n                               aflags & 0x40 ? \"T\" : \"\",\n                               aflags & 0x20 ? \"P\" : \"\",\n                               aflags & 0x10 ? \"E\" : \"\"));\n                        if (aflags & 0xf)\n                            ND_PRINT((ndo, \"+%x\", aflags & 0xf));\n                        ND_PRINT((ndo, \"]: \"));\n                    }\n                    /* FIXME check for recursion */\n                    if (!bgp_attr_print(ndo, atype, tptr, alen))\n                        return 0;\n                    tptr += alen;\n                    len -= alen;\n\t\t}\n                break;\n\n\tcase BGPTYPE_LARGE_COMMUNITY:\n\t\tif (len == 0 || len % 12) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n\t\tND_PRINT((ndo, \"\\n\\t    \"));\n\t\twhile (len > 0) {\n\t\t\tND_TCHECK2(*tptr, 12);\n\t\t\tND_PRINT((ndo, \"%u:%u:%u%s\",\n\t\t\t\t EXTRACT_32BITS(tptr),\n\t\t\t\t EXTRACT_32BITS(tptr + 4),\n\t\t\t\t EXTRACT_32BITS(tptr + 8),\n\t\t\t\t (len > 12) ? \", \" : \"\"));\n                        tptr += 12;\n                        len -= 12;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t    ND_TCHECK2(*pptr,len);\n            ND_PRINT((ndo, \"\\n\\t    no Attribute %u decoder\", atype)); /* we have no decoder for the attribute */\n            if (ndo->ndo_vflag <= 1)\n                print_unknown_data(ndo, pptr, \"\\n\\t    \", len);\n            break;\n\t}\n        if (ndo->ndo_vflag > 1 && len) { /* omit zero length attributes*/\n            ND_TCHECK2(*pptr,len);\n            print_unknown_data(ndo, pptr, \"\\n\\t    \", len);\n        }\n        return 1;\n\ntrunc:\n        return 0;\n}\n",
    "cwe": [
      "CWE-125"
    ],
    "id": 521,
    "_valid_cwes": [
      "CWE-125"
    ]
  },
  {
    "cve_id": "CVE-2017-13039",
    "code_before_change": "ikev1_n_print(netdissect_options *ndo, u_char tpay _U_,\n\t      const struct isakmp_gen *ext, u_int item_len,\n\t      const u_char *ep, uint32_t phase _U_, uint32_t doi0 _U_,\n\t      uint32_t proto0 _U_, int depth _U_)\n{\n\tconst struct ikev1_pl_n *p;\n\tstruct ikev1_pl_n n;\n\tconst u_char *cp;\n\tconst u_char *ep2;\n\tuint32_t doi;\n\tuint32_t proto;\n\tstatic const char *notify_error_str[] = {\n\t\tNULL,\t\t\t\t\"INVALID-PAYLOAD-TYPE\",\n\t\t\"DOI-NOT-SUPPORTED\",\t\t\"SITUATION-NOT-SUPPORTED\",\n\t\t\"INVALID-COOKIE\",\t\t\"INVALID-MAJOR-VERSION\",\n\t\t\"INVALID-MINOR-VERSION\",\t\"INVALID-EXCHANGE-TYPE\",\n\t\t\"INVALID-FLAGS\",\t\t\"INVALID-MESSAGE-ID\",\n\t\t\"INVALID-PROTOCOL-ID\",\t\t\"INVALID-SPI\",\n\t\t\"INVALID-TRANSFORM-ID\",\t\t\"ATTRIBUTES-NOT-SUPPORTED\",\n\t\t\"NO-PROPOSAL-CHOSEN\",\t\t\"BAD-PROPOSAL-SYNTAX\",\n\t\t\"PAYLOAD-MALFORMED\",\t\t\"INVALID-KEY-INFORMATION\",\n\t\t\"INVALID-ID-INFORMATION\",\t\"INVALID-CERT-ENCODING\",\n\t\t\"INVALID-CERTIFICATE\",\t\t\"CERT-TYPE-UNSUPPORTED\",\n\t\t\"INVALID-CERT-AUTHORITY\",\t\"INVALID-HASH-INFORMATION\",\n\t\t\"AUTHENTICATION-FAILED\",\t\"INVALID-SIGNATURE\",\n\t\t\"ADDRESS-NOTIFICATION\",\t\t\"NOTIFY-SA-LIFETIME\",\n\t\t\"CERTIFICATE-UNAVAILABLE\",\t\"UNSUPPORTED-EXCHANGE-TYPE\",\n\t\t\"UNEQUAL-PAYLOAD-LENGTHS\",\n\t};\n\tstatic const char *ipsec_notify_error_str[] = {\n\t\t\"RESERVED\",\n\t};\n\tstatic const char *notify_status_str[] = {\n\t\t\"CONNECTED\",\n\t};\n\tstatic const char *ipsec_notify_status_str[] = {\n\t\t\"RESPONDER-LIFETIME\",\t\t\"REPLAY-STATUS\",\n\t\t\"INITIAL-CONTACT\",\n\t};\n/* NOTE: these macro must be called with x in proper range */\n\n/* 0 - 8191 */\n#define NOTIFY_ERROR_STR(x) \\\n\tSTR_OR_ID((x), notify_error_str)\n\n/* 8192 - 16383 */\n#define IPSEC_NOTIFY_ERROR_STR(x) \\\n\tSTR_OR_ID((u_int)((x) - 8192), ipsec_notify_error_str)\n\n/* 16384 - 24575 */\n#define NOTIFY_STATUS_STR(x) \\\n\tSTR_OR_ID((u_int)((x) - 16384), notify_status_str)\n\n/* 24576 - 32767 */\n#define IPSEC_NOTIFY_STATUS_STR(x) \\\n\tSTR_OR_ID((u_int)((x) - 24576), ipsec_notify_status_str)\n\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_N)));\n\n\tp = (const struct ikev1_pl_n *)ext;\n\tND_TCHECK(*p);\n\tUNALIGNED_MEMCPY(&n, ext, sizeof(n));\n\tdoi = ntohl(n.doi);\n\tproto = n.prot_id;\n\tif (doi != 1) {\n\t\tND_PRINT((ndo,\" doi=%d\", doi));\n\t\tND_PRINT((ndo,\" proto=%d\", proto));\n\t\tif (ntohs(n.type) < 8192)\n\t\t\tND_PRINT((ndo,\" type=%s\", NOTIFY_ERROR_STR(ntohs(n.type))));\n\t\telse if (ntohs(n.type) < 16384)\n\t\t\tND_PRINT((ndo,\" type=%s\", numstr(ntohs(n.type))));\n\t\telse if (ntohs(n.type) < 24576)\n\t\t\tND_PRINT((ndo,\" type=%s\", NOTIFY_STATUS_STR(ntohs(n.type))));\n\t\telse\n\t\t\tND_PRINT((ndo,\" type=%s\", numstr(ntohs(n.type))));\n\t\tif (n.spi_size) {\n\t\t\tND_PRINT((ndo,\" spi=\"));\n\t\t\tif (!rawprint(ndo, (const uint8_t *)(p + 1), n.spi_size))\n\t\t\t\tgoto trunc;\n\t\t}\n\t\treturn (const u_char *)(p + 1) + n.spi_size;\n\t}\n\n\tND_PRINT((ndo,\" doi=ipsec\"));\n\tND_PRINT((ndo,\" proto=%s\", PROTOIDSTR(proto)));\n\tif (ntohs(n.type) < 8192)\n\t\tND_PRINT((ndo,\" type=%s\", NOTIFY_ERROR_STR(ntohs(n.type))));\n\telse if (ntohs(n.type) < 16384)\n\t\tND_PRINT((ndo,\" type=%s\", IPSEC_NOTIFY_ERROR_STR(ntohs(n.type))));\n\telse if (ntohs(n.type) < 24576)\n\t\tND_PRINT((ndo,\" type=%s\", NOTIFY_STATUS_STR(ntohs(n.type))));\n\telse if (ntohs(n.type) < 32768)\n\t\tND_PRINT((ndo,\" type=%s\", IPSEC_NOTIFY_STATUS_STR(ntohs(n.type))));\n\telse\n\t\tND_PRINT((ndo,\" type=%s\", numstr(ntohs(n.type))));\n\tif (n.spi_size) {\n\t\tND_PRINT((ndo,\" spi=\"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(p + 1), n.spi_size))\n\t\t\tgoto trunc;\n\t}\n\n\tcp = (const u_char *)(p + 1) + n.spi_size;\n\tep2 = (const u_char *)p + item_len;\n\n\tif (cp < ep) {\n\t\tswitch (ntohs(n.type)) {\n\t\tcase IPSECDOI_NTYPE_RESPONDER_LIFETIME:\n\t\t    {\n\t\t\tconst struct attrmap *map = oakley_t_map;\n \t\t\tsize_t nmap = sizeof(oakley_t_map)/sizeof(oakley_t_map[0]);\n \t\t\tND_PRINT((ndo,\" attrs=(\"));\n \t\t\twhile (cp < ep && cp < ep2) {\n\t\t\t\tcp = ikev1_attrmap_print(ndo, cp,\n\t\t\t\t\t(ep < ep2) ? ep : ep2, map, nmap);\n \t\t\t}\n \t\t\tND_PRINT((ndo,\")\"));\n \t\t\tbreak;\n\t\t    }\n\t\tcase IPSECDOI_NTYPE_REPLAY_STATUS:\n\t\t\tND_PRINT((ndo,\" status=(\"));\n\t\t\tND_PRINT((ndo,\"replay detection %sabled\",\n\t\t\t\t  EXTRACT_32BITS(cp) ? \"en\" : \"dis\"));\n\t\t\tND_PRINT((ndo,\")\"));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/*\n\t\t\t * XXX - fill in more types here; see, for example,\n\t\t\t * draft-ietf-ipsec-notifymsg-04.\n\t\t\t */\n\t\t\tif (ndo->ndo_vflag > 3) {\n\t\t\t\tND_PRINT((ndo,\" data=(\"));\n\t\t\t\tif (!rawprint(ndo, (const uint8_t *)(cp), ep - cp))\n\t\t\t\t\tgoto trunc;\n\t\t\t\tND_PRINT((ndo,\")\"));\n\t\t\t} else {\n\t\t\t\tif (!ike_show_somedata(ndo, cp, ep))\n\t\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn (const u_char *)ext + item_len;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_N)));\n\treturn NULL;\n}\n",
    "code_after_change": "ikev1_n_print(netdissect_options *ndo, u_char tpay _U_,\n\t      const struct isakmp_gen *ext, u_int item_len,\n\t      const u_char *ep, uint32_t phase _U_, uint32_t doi0 _U_,\n\t      uint32_t proto0 _U_, int depth _U_)\n{\n\tconst struct ikev1_pl_n *p;\n\tstruct ikev1_pl_n n;\n\tconst u_char *cp;\n\tconst u_char *ep2;\n\tuint32_t doi;\n\tuint32_t proto;\n\tstatic const char *notify_error_str[] = {\n\t\tNULL,\t\t\t\t\"INVALID-PAYLOAD-TYPE\",\n\t\t\"DOI-NOT-SUPPORTED\",\t\t\"SITUATION-NOT-SUPPORTED\",\n\t\t\"INVALID-COOKIE\",\t\t\"INVALID-MAJOR-VERSION\",\n\t\t\"INVALID-MINOR-VERSION\",\t\"INVALID-EXCHANGE-TYPE\",\n\t\t\"INVALID-FLAGS\",\t\t\"INVALID-MESSAGE-ID\",\n\t\t\"INVALID-PROTOCOL-ID\",\t\t\"INVALID-SPI\",\n\t\t\"INVALID-TRANSFORM-ID\",\t\t\"ATTRIBUTES-NOT-SUPPORTED\",\n\t\t\"NO-PROPOSAL-CHOSEN\",\t\t\"BAD-PROPOSAL-SYNTAX\",\n\t\t\"PAYLOAD-MALFORMED\",\t\t\"INVALID-KEY-INFORMATION\",\n\t\t\"INVALID-ID-INFORMATION\",\t\"INVALID-CERT-ENCODING\",\n\t\t\"INVALID-CERTIFICATE\",\t\t\"CERT-TYPE-UNSUPPORTED\",\n\t\t\"INVALID-CERT-AUTHORITY\",\t\"INVALID-HASH-INFORMATION\",\n\t\t\"AUTHENTICATION-FAILED\",\t\"INVALID-SIGNATURE\",\n\t\t\"ADDRESS-NOTIFICATION\",\t\t\"NOTIFY-SA-LIFETIME\",\n\t\t\"CERTIFICATE-UNAVAILABLE\",\t\"UNSUPPORTED-EXCHANGE-TYPE\",\n\t\t\"UNEQUAL-PAYLOAD-LENGTHS\",\n\t};\n\tstatic const char *ipsec_notify_error_str[] = {\n\t\t\"RESERVED\",\n\t};\n\tstatic const char *notify_status_str[] = {\n\t\t\"CONNECTED\",\n\t};\n\tstatic const char *ipsec_notify_status_str[] = {\n\t\t\"RESPONDER-LIFETIME\",\t\t\"REPLAY-STATUS\",\n\t\t\"INITIAL-CONTACT\",\n\t};\n/* NOTE: these macro must be called with x in proper range */\n\n/* 0 - 8191 */\n#define NOTIFY_ERROR_STR(x) \\\n\tSTR_OR_ID((x), notify_error_str)\n\n/* 8192 - 16383 */\n#define IPSEC_NOTIFY_ERROR_STR(x) \\\n\tSTR_OR_ID((u_int)((x) - 8192), ipsec_notify_error_str)\n\n/* 16384 - 24575 */\n#define NOTIFY_STATUS_STR(x) \\\n\tSTR_OR_ID((u_int)((x) - 16384), notify_status_str)\n\n/* 24576 - 32767 */\n#define IPSEC_NOTIFY_STATUS_STR(x) \\\n\tSTR_OR_ID((u_int)((x) - 24576), ipsec_notify_status_str)\n\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_N)));\n\n\tp = (const struct ikev1_pl_n *)ext;\n\tND_TCHECK(*p);\n\tUNALIGNED_MEMCPY(&n, ext, sizeof(n));\n\tdoi = ntohl(n.doi);\n\tproto = n.prot_id;\n\tif (doi != 1) {\n\t\tND_PRINT((ndo,\" doi=%d\", doi));\n\t\tND_PRINT((ndo,\" proto=%d\", proto));\n\t\tif (ntohs(n.type) < 8192)\n\t\t\tND_PRINT((ndo,\" type=%s\", NOTIFY_ERROR_STR(ntohs(n.type))));\n\t\telse if (ntohs(n.type) < 16384)\n\t\t\tND_PRINT((ndo,\" type=%s\", numstr(ntohs(n.type))));\n\t\telse if (ntohs(n.type) < 24576)\n\t\t\tND_PRINT((ndo,\" type=%s\", NOTIFY_STATUS_STR(ntohs(n.type))));\n\t\telse\n\t\t\tND_PRINT((ndo,\" type=%s\", numstr(ntohs(n.type))));\n\t\tif (n.spi_size) {\n\t\t\tND_PRINT((ndo,\" spi=\"));\n\t\t\tif (!rawprint(ndo, (const uint8_t *)(p + 1), n.spi_size))\n\t\t\t\tgoto trunc;\n\t\t}\n\t\treturn (const u_char *)(p + 1) + n.spi_size;\n\t}\n\n\tND_PRINT((ndo,\" doi=ipsec\"));\n\tND_PRINT((ndo,\" proto=%s\", PROTOIDSTR(proto)));\n\tif (ntohs(n.type) < 8192)\n\t\tND_PRINT((ndo,\" type=%s\", NOTIFY_ERROR_STR(ntohs(n.type))));\n\telse if (ntohs(n.type) < 16384)\n\t\tND_PRINT((ndo,\" type=%s\", IPSEC_NOTIFY_ERROR_STR(ntohs(n.type))));\n\telse if (ntohs(n.type) < 24576)\n\t\tND_PRINT((ndo,\" type=%s\", NOTIFY_STATUS_STR(ntohs(n.type))));\n\telse if (ntohs(n.type) < 32768)\n\t\tND_PRINT((ndo,\" type=%s\", IPSEC_NOTIFY_STATUS_STR(ntohs(n.type))));\n\telse\n\t\tND_PRINT((ndo,\" type=%s\", numstr(ntohs(n.type))));\n\tif (n.spi_size) {\n\t\tND_PRINT((ndo,\" spi=\"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(p + 1), n.spi_size))\n\t\t\tgoto trunc;\n\t}\n\n\tcp = (const u_char *)(p + 1) + n.spi_size;\n\tep2 = (const u_char *)p + item_len;\n\n\tif (cp < ep) {\n\t\tswitch (ntohs(n.type)) {\n\t\tcase IPSECDOI_NTYPE_RESPONDER_LIFETIME:\n\t\t    {\n\t\t\tconst struct attrmap *map = oakley_t_map;\n \t\t\tsize_t nmap = sizeof(oakley_t_map)/sizeof(oakley_t_map[0]);\n \t\t\tND_PRINT((ndo,\" attrs=(\"));\n \t\t\twhile (cp < ep && cp < ep2) {\n\t\t\t\tcp = ikev1_attrmap_print(ndo, cp, ep2, map, nmap);\n\t\t\t\tif (cp == NULL) {\n\t\t\t\t\tND_PRINT((ndo,\")\"));\n\t\t\t\t\tgoto trunc;\n\t\t\t\t}\n \t\t\t}\n \t\t\tND_PRINT((ndo,\")\"));\n \t\t\tbreak;\n\t\t    }\n\t\tcase IPSECDOI_NTYPE_REPLAY_STATUS:\n\t\t\tND_PRINT((ndo,\" status=(\"));\n\t\t\tND_PRINT((ndo,\"replay detection %sabled\",\n\t\t\t\t  EXTRACT_32BITS(cp) ? \"en\" : \"dis\"));\n\t\t\tND_PRINT((ndo,\")\"));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/*\n\t\t\t * XXX - fill in more types here; see, for example,\n\t\t\t * draft-ietf-ipsec-notifymsg-04.\n\t\t\t */\n\t\t\tif (ndo->ndo_vflag > 3) {\n\t\t\t\tND_PRINT((ndo,\" data=(\"));\n\t\t\t\tif (!rawprint(ndo, (const uint8_t *)(cp), ep - cp))\n\t\t\t\t\tgoto trunc;\n\t\t\t\tND_PRINT((ndo,\")\"));\n\t\t\t} else {\n\t\t\t\tif (!ike_show_somedata(ndo, cp, ep))\n\t\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn (const u_char *)ext + item_len;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_N)));\n\treturn NULL;\n}\n",
    "cwe": [
      "CWE-125"
    ],
    "id": 527,
    "_valid_cwes": [
      "CWE-125"
    ]
  },
  {
    "cve_id": "CVE-2017-13036",
    "code_before_change": "ospf6_decode_v3(netdissect_options *ndo,\n                register const struct ospf6hdr *op,\n                register const u_char *dataend)\n{\n\tregister const rtrid_t *ap;\n\tregister const struct lsr6 *lsrp;\n\tregister const struct lsa6_hdr *lshp;\n\tregister const struct lsa6 *lsap;\n\tregister int i;\n\n\tswitch (op->ospf6_type) {\n\n \tcase OSPF_TYPE_HELLO: {\n \t\tregister const struct hello6 *hellop = (const struct hello6 *)((const uint8_t *)op + OSPF6HDR_LEN);\n \n \t\tND_PRINT((ndo, \"\\n\\tOptions [%s]\",\n \t\t          bittok2str(ospf6_option_values, \"none\",\n \t\t          EXTRACT_32BITS(&hellop->hello_options))));\n\n\t\tND_TCHECK(hellop->hello_deadint);\n\t\tND_PRINT((ndo, \"\\n\\t  Hello Timer %us, Dead Timer %us, Interface-ID %s, Priority %u\",\n\t\t          EXTRACT_16BITS(&hellop->hello_helloint),\n\t\t          EXTRACT_16BITS(&hellop->hello_deadint),\n\t\t          ipaddr_string(ndo, &hellop->hello_ifid),\n\t\t          hellop->hello_priority));\n\n\t\tND_TCHECK(hellop->hello_dr);\n\t\tif (EXTRACT_32BITS(&hellop->hello_dr) != 0)\n\t\t\tND_PRINT((ndo, \"\\n\\t  Designated Router %s\",\n\t\t\t    ipaddr_string(ndo, &hellop->hello_dr)));\n\t\tND_TCHECK(hellop->hello_bdr);\n\t\tif (EXTRACT_32BITS(&hellop->hello_bdr) != 0)\n\t\t\tND_PRINT((ndo, \", Backup Designated Router %s\",\n\t\t\t    ipaddr_string(ndo, &hellop->hello_bdr)));\n\t\tif (ndo->ndo_vflag > 1) {\n\t\t\tND_PRINT((ndo, \"\\n\\t  Neighbor List:\"));\n\t\t\tap = hellop->hello_neighbor;\n\t\t\twhile ((const u_char *)ap < dataend) {\n\t\t\t\tND_TCHECK(*ap);\n\t\t\t\tND_PRINT((ndo, \"\\n\\t    %s\", ipaddr_string(ndo, ap)));\n\t\t\t\t++ap;\n\t\t\t}\n\t\t}\n\t\tbreak;\t/* HELLO */\n\t}\n\n\tcase OSPF_TYPE_DD: {\n\t\tregister const struct dd6 *ddp = (const struct dd6 *)((const uint8_t *)op + OSPF6HDR_LEN);\n\n\t\tND_TCHECK(ddp->db_options);\n\t\tND_PRINT((ndo, \"\\n\\tOptions [%s]\",\n\t\t          bittok2str(ospf6_option_values, \"none\",\n\t\t          EXTRACT_32BITS(&ddp->db_options))));\n\t\tND_TCHECK(ddp->db_flags);\n\t\tND_PRINT((ndo, \", DD Flags [%s]\",\n\t\t          bittok2str(ospf6_dd_flag_values,\"none\",ddp->db_flags)));\n\n\t\tND_TCHECK(ddp->db_seq);\n\t\tND_PRINT((ndo, \", MTU %u, DD-Sequence 0x%08x\",\n                       EXTRACT_16BITS(&ddp->db_mtu),\n                       EXTRACT_32BITS(&ddp->db_seq)));\n\t\tif (ndo->ndo_vflag > 1) {\n\t\t\t/* Print all the LS adv's */\n\t\t\tlshp = ddp->db_lshdr;\n\t\t\twhile ((const u_char *)lshp < dataend) {\n\t\t\t\tif (ospf6_print_lshdr(ndo, lshp++, dataend))\n\t\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase OSPF_TYPE_LS_REQ:\n\t\tif (ndo->ndo_vflag > 1) {\n\t\t\tlsrp = (const struct lsr6 *)((const uint8_t *)op + OSPF6HDR_LEN);\n\t\t\twhile ((const u_char *)lsrp < dataend) {\n\t\t\t\tND_TCHECK(*lsrp);\n\t\t\t\tND_PRINT((ndo, \"\\n\\t  Advertising Router %s\",\n\t\t\t\t          ipaddr_string(ndo, &lsrp->ls_router)));\n\t\t\t\tospf6_print_ls_type(ndo, EXTRACT_16BITS(&lsrp->ls_type),\n                                                    &lsrp->ls_stateid);\n\t\t\t\t++lsrp;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase OSPF_TYPE_LS_UPDATE:\n\t\tif (ndo->ndo_vflag > 1) {\n\t\t\tregister const struct lsu6 *lsup = (const struct lsu6 *)((const uint8_t *)op + OSPF6HDR_LEN);\n\n\t\t\tND_TCHECK(lsup->lsu_count);\n\t\t\ti = EXTRACT_32BITS(&lsup->lsu_count);\n\t\t\tlsap = lsup->lsu_lsa;\n\t\t\twhile ((const u_char *)lsap < dataend && i--) {\n\t\t\t\tif (ospf6_print_lsa(ndo, lsap, dataend))\n\t\t\t\t\tgoto trunc;\n\t\t\t\tlsap = (const struct lsa6 *)((const u_char *)lsap +\n\t\t\t\t    EXTRACT_16BITS(&lsap->ls_hdr.ls_length));\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase OSPF_TYPE_LS_ACK:\n\t\tif (ndo->ndo_vflag > 1) {\n\t\t\tlshp = (const struct lsa6_hdr *)((const uint8_t *)op + OSPF6HDR_LEN);\n\t\t\twhile ((const u_char *)lshp < dataend) {\n\t\t\t\tif (ospf6_print_lshdr(ndo, lshp++, dataend))\n\t\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\treturn (0);\ntrunc:\n\treturn (1);\n}\n",
    "code_after_change": "ospf6_decode_v3(netdissect_options *ndo,\n                register const struct ospf6hdr *op,\n                register const u_char *dataend)\n{\n\tregister const rtrid_t *ap;\n\tregister const struct lsr6 *lsrp;\n\tregister const struct lsa6_hdr *lshp;\n\tregister const struct lsa6 *lsap;\n\tregister int i;\n\n\tswitch (op->ospf6_type) {\n\n \tcase OSPF_TYPE_HELLO: {\n \t\tregister const struct hello6 *hellop = (const struct hello6 *)((const uint8_t *)op + OSPF6HDR_LEN);\n \n\t\tND_TCHECK_32BITS(&hellop->hello_options);\n \t\tND_PRINT((ndo, \"\\n\\tOptions [%s]\",\n \t\t          bittok2str(ospf6_option_values, \"none\",\n \t\t          EXTRACT_32BITS(&hellop->hello_options))));\n\n\t\tND_TCHECK(hellop->hello_deadint);\n\t\tND_PRINT((ndo, \"\\n\\t  Hello Timer %us, Dead Timer %us, Interface-ID %s, Priority %u\",\n\t\t          EXTRACT_16BITS(&hellop->hello_helloint),\n\t\t          EXTRACT_16BITS(&hellop->hello_deadint),\n\t\t          ipaddr_string(ndo, &hellop->hello_ifid),\n\t\t          hellop->hello_priority));\n\n\t\tND_TCHECK(hellop->hello_dr);\n\t\tif (EXTRACT_32BITS(&hellop->hello_dr) != 0)\n\t\t\tND_PRINT((ndo, \"\\n\\t  Designated Router %s\",\n\t\t\t    ipaddr_string(ndo, &hellop->hello_dr)));\n\t\tND_TCHECK(hellop->hello_bdr);\n\t\tif (EXTRACT_32BITS(&hellop->hello_bdr) != 0)\n\t\t\tND_PRINT((ndo, \", Backup Designated Router %s\",\n\t\t\t    ipaddr_string(ndo, &hellop->hello_bdr)));\n\t\tif (ndo->ndo_vflag > 1) {\n\t\t\tND_PRINT((ndo, \"\\n\\t  Neighbor List:\"));\n\t\t\tap = hellop->hello_neighbor;\n\t\t\twhile ((const u_char *)ap < dataend) {\n\t\t\t\tND_TCHECK(*ap);\n\t\t\t\tND_PRINT((ndo, \"\\n\\t    %s\", ipaddr_string(ndo, ap)));\n\t\t\t\t++ap;\n\t\t\t}\n\t\t}\n\t\tbreak;\t/* HELLO */\n\t}\n\n\tcase OSPF_TYPE_DD: {\n\t\tregister const struct dd6 *ddp = (const struct dd6 *)((const uint8_t *)op + OSPF6HDR_LEN);\n\n\t\tND_TCHECK(ddp->db_options);\n\t\tND_PRINT((ndo, \"\\n\\tOptions [%s]\",\n\t\t          bittok2str(ospf6_option_values, \"none\",\n\t\t          EXTRACT_32BITS(&ddp->db_options))));\n\t\tND_TCHECK(ddp->db_flags);\n\t\tND_PRINT((ndo, \", DD Flags [%s]\",\n\t\t          bittok2str(ospf6_dd_flag_values,\"none\",ddp->db_flags)));\n\n\t\tND_TCHECK(ddp->db_seq);\n\t\tND_PRINT((ndo, \", MTU %u, DD-Sequence 0x%08x\",\n                       EXTRACT_16BITS(&ddp->db_mtu),\n                       EXTRACT_32BITS(&ddp->db_seq)));\n\t\tif (ndo->ndo_vflag > 1) {\n\t\t\t/* Print all the LS adv's */\n\t\t\tlshp = ddp->db_lshdr;\n\t\t\twhile ((const u_char *)lshp < dataend) {\n\t\t\t\tif (ospf6_print_lshdr(ndo, lshp++, dataend))\n\t\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase OSPF_TYPE_LS_REQ:\n\t\tif (ndo->ndo_vflag > 1) {\n\t\t\tlsrp = (const struct lsr6 *)((const uint8_t *)op + OSPF6HDR_LEN);\n\t\t\twhile ((const u_char *)lsrp < dataend) {\n\t\t\t\tND_TCHECK(*lsrp);\n\t\t\t\tND_PRINT((ndo, \"\\n\\t  Advertising Router %s\",\n\t\t\t\t          ipaddr_string(ndo, &lsrp->ls_router)));\n\t\t\t\tospf6_print_ls_type(ndo, EXTRACT_16BITS(&lsrp->ls_type),\n                                                    &lsrp->ls_stateid);\n\t\t\t\t++lsrp;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase OSPF_TYPE_LS_UPDATE:\n\t\tif (ndo->ndo_vflag > 1) {\n\t\t\tregister const struct lsu6 *lsup = (const struct lsu6 *)((const uint8_t *)op + OSPF6HDR_LEN);\n\n\t\t\tND_TCHECK(lsup->lsu_count);\n\t\t\ti = EXTRACT_32BITS(&lsup->lsu_count);\n\t\t\tlsap = lsup->lsu_lsa;\n\t\t\twhile ((const u_char *)lsap < dataend && i--) {\n\t\t\t\tif (ospf6_print_lsa(ndo, lsap, dataend))\n\t\t\t\t\tgoto trunc;\n\t\t\t\tlsap = (const struct lsa6 *)((const u_char *)lsap +\n\t\t\t\t    EXTRACT_16BITS(&lsap->ls_hdr.ls_length));\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase OSPF_TYPE_LS_ACK:\n\t\tif (ndo->ndo_vflag > 1) {\n\t\t\tlshp = (const struct lsa6_hdr *)((const uint8_t *)op + OSPF6HDR_LEN);\n\t\t\twhile ((const u_char *)lshp < dataend) {\n\t\t\t\tif (ospf6_print_lshdr(ndo, lshp++, dataend))\n\t\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\treturn (0);\ntrunc:\n\treturn (1);\n}\n",
    "cwe": [
      "CWE-125"
    ],
    "id": 535,
    "_valid_cwes": [
      "CWE-125"
    ]
  },
  {
    "cve_id": "CVE-2018-9505",
    "code_before_change": "void mca_ccb_hdl_req(tMCA_CCB* p_ccb, tMCA_CCB_EVT* p_data) {\n  BT_HDR* p_pkt = &p_data->hdr;\n uint8_t *p, *p_start;\n  tMCA_DCB* p_dcb;\n  tMCA_CTRL evt_data;\n  tMCA_CCB_MSG* p_rx_msg = NULL;\n uint8_t reject_code = MCA_RSP_NO_RESOURCE;\n bool send_rsp = false;\n bool check_req = false;\n uint8_t reject_opcode;\n\n  MCA_TRACE_DEBUG(\"mca_ccb_hdl_req status:%d\", p_ccb->status);\n\n   p_rx_msg = (tMCA_CCB_MSG*)p_pkt;\n   p = (uint8_t*)(p_pkt + 1) + p_pkt->offset;\n   evt_data.hdr.op_code = *p++;\n  BE_STREAM_TO_UINT16(evt_data.hdr.mdl_id, p);\n   reject_opcode = evt_data.hdr.op_code + 1;\n \n   MCA_TRACE_DEBUG(\"received mdl id: %d \", evt_data.hdr.mdl_id);\n   if (p_ccb->status == MCA_CCB_STAT_PENDING) {\n     MCA_TRACE_DEBUG(\"received req inpending state\");\n /* allow abort in pending state */\n if ((p_ccb->status == MCA_CCB_STAT_PENDING) &&\n (evt_data.hdr.op_code == MCA_OP_MDL_ABORT_REQ)) {\n      reject_code = MCA_RSP_SUCCESS;\n      send_rsp = true;\n /* clear the pending status */\n      p_ccb->status = MCA_CCB_STAT_NORM;\n if (p_ccb->p_tx_req &&\n ((p_dcb = mca_dcb_by_hdl(p_ccb->p_tx_req->dcb_idx)) != NULL)) {\n        mca_dcb_dealloc(p_dcb, NULL);\n        osi_free_and_reset((void**)&p_ccb->p_tx_req);\n }\n } else\n      reject_code = MCA_RSP_BAD_OP;\n } else if (p_ccb->p_rx_msg) {\n    MCA_TRACE_DEBUG(\"still handling prev req\");\n /* still holding previous message, reject this new one ?? */\n\n } else if (p_ccb->p_tx_req) {\n    MCA_TRACE_DEBUG(\"still waiting for a response ctrl_vpsm:0x%x\",\n                    p_ccb->ctrl_vpsm);\n /* sent a request; waiting for response */\n if (p_ccb->ctrl_vpsm == 0) {\n      MCA_TRACE_DEBUG(\"local is ACP. accept the cmd from INT\");\n /* local is acceptor, need to handle the request */\n      check_req = true;\n      reject_code = MCA_RSP_SUCCESS;\n /* drop the previous request */\n if ((p_ccb->p_tx_req->op_code == MCA_OP_MDL_CREATE_REQ) &&\n ((p_dcb = mca_dcb_by_hdl(p_ccb->p_tx_req->dcb_idx)) != NULL)) {\n        mca_dcb_dealloc(p_dcb, NULL);\n }\n      osi_free_and_reset((void**)&p_ccb->p_tx_req);\n      mca_stop_timer(p_ccb);\n } else {\n /*  local is initiator, ignore the req */\n      osi_free(p_pkt);\n return;\n }\n } else if (p_pkt->layer_specific != MCA_RSP_SUCCESS) {\n    reject_code = (uint8_t)p_pkt->layer_specific;\n if (((evt_data.hdr.op_code >= MCA_NUM_STANDARD_OPCODE) &&\n (evt_data.hdr.op_code < MCA_FIRST_SYNC_OP)) ||\n (evt_data.hdr.op_code > MCA_LAST_SYNC_OP)) {\n /* invalid op code */\n      reject_opcode = MCA_OP_ERROR_RSP;\n      evt_data.hdr.mdl_id = 0;\n }\n } else {\n    check_req = true;\n    reject_code = MCA_RSP_SUCCESS;\n }\n\n if (check_req) {\n if (reject_code == MCA_RSP_SUCCESS) {\n      reject_code = MCA_RSP_BAD_MDL;\n if (MCA_IS_VALID_MDL_ID(evt_data.hdr.mdl_id) ||\n ((evt_data.hdr.mdl_id == MCA_ALL_MDL_ID) &&\n (evt_data.hdr.op_code == MCA_OP_MDL_DELETE_REQ))) {\n        reject_code = MCA_RSP_SUCCESS;\n /* mdl_id is valid according to the spec */\n switch (evt_data.hdr.op_code) {\n case MCA_OP_MDL_CREATE_REQ:\n            evt_data.create_ind.dep_id = *p++;\n            evt_data.create_ind.cfg = *p++;\n            p_rx_msg->mdep_id = evt_data.create_ind.dep_id;\n if (!mca_is_valid_dep_id(p_ccb->p_rcb, p_rx_msg->mdep_id)) {\n              MCA_TRACE_ERROR(\"%s: Invalid local MDEP ID %d\", __func__,\n                              p_rx_msg->mdep_id);\n              reject_code = MCA_RSP_BAD_MDEP;\n } else if (mca_ccb_uses_mdl_id(p_ccb, evt_data.hdr.mdl_id)) {\n              MCA_TRACE_DEBUG(\"the mdl_id is currently used in the CL(create)\");\n              mca_dcb_close_by_mdl_id(p_ccb, evt_data.hdr.mdl_id);\n } else {\n /* check if this dep still have MDL available */\n if (mca_dep_free_mdl(p_ccb, evt_data.create_ind.dep_id) == 0) {\n                MCA_TRACE_ERROR(\"%s: MAX_MDL is used by MDEP %d\", __func__,\n                                evt_data.create_ind.dep_id);\n                reject_code = MCA_RSP_MDEP_BUSY;\n }\n }\n break;\n\n case MCA_OP_MDL_RECONNECT_REQ:\n if (mca_ccb_uses_mdl_id(p_ccb, evt_data.hdr.mdl_id)) {\n              MCA_TRACE_ERROR(\"%s: MDL_ID %d busy, in CL(reconn)\", __func__,\n                              evt_data.hdr.mdl_id);\n              reject_code = MCA_RSP_MDL_BUSY;\n }\n break;\n\n case MCA_OP_MDL_ABORT_REQ:\n            reject_code = MCA_RSP_BAD_OP;\n break;\n\n case MCA_OP_MDL_DELETE_REQ:\n /* delete the associated mdl */\n            mca_dcb_close_by_mdl_id(p_ccb, evt_data.hdr.mdl_id);\n            send_rsp = true;\n break;\n }\n }\n }\n }\n\n if (((reject_code != MCA_RSP_SUCCESS) &&\n (evt_data.hdr.op_code != MCA_OP_SYNC_INFO_IND)) ||\n      send_rsp) {\n    BT_HDR* p_buf = (BT_HDR*)osi_malloc(MCA_CTRL_MTU + sizeof(BT_HDR));\n    p_buf->offset = L2CAP_MIN_OFFSET;\n    p = p_start = (uint8_t*)(p_buf + 1) + L2CAP_MIN_OFFSET;\n *p++ = reject_opcode;\n *p++ = reject_code;\n bool valid_response = true;\n switch (reject_opcode) {\n case MCA_OP_ERROR_RSP:\n case MCA_OP_MDL_CREATE_RSP:\n case MCA_OP_MDL_RECONNECT_RSP:\n case MCA_OP_MDL_ABORT_RSP:\n case MCA_OP_MDL_DELETE_RSP:\n        UINT16_TO_BE_STREAM(p, evt_data.hdr.mdl_id);\n break;\n case MCA_OP_SYNC_CAP_RSP:\n        memset(p, 0, 7);\n        p += 7;\n break;\n case MCA_OP_SYNC_SET_RSP:\n        memset(p, 0, 14);\n        p += 14;\n break;\n default:\n        MCA_TRACE_ERROR(\"%s: reject_opcode 0x%02x not recognized\", __func__,\n                        reject_opcode);\n        valid_response = false;\n break;\n }\n if (valid_response) {\n      p_buf->len = p - p_start;\n      MCA_TRACE_ERROR(\"%s: reject_opcode=0x%02x, reject_code=0x%02x, length=%d\",\n                      __func__, reject_opcode, reject_code, p_buf->len);\n      L2CA_DataWrite(p_ccb->lcid, p_buf);\n } else {\n      osi_free(p_buf);\n }\n }\n\n if (reject_code == MCA_RSP_SUCCESS) {\n /* use the received GKI buffer to store information to double check response\n     * API */\n    p_rx_msg->op_code = evt_data.hdr.op_code;\n    p_rx_msg->mdl_id = evt_data.hdr.mdl_id;\n    p_ccb->p_rx_msg = p_rx_msg;\n if (send_rsp) {\n      osi_free(p_pkt);\n      p_ccb->p_rx_msg = NULL;\n }\n    mca_ccb_report_event(p_ccb, evt_data.hdr.op_code, &evt_data);\n } else\n    osi_free(p_pkt);\n}\n",
    "code_after_change": "void mca_ccb_hdl_req(tMCA_CCB* p_ccb, tMCA_CCB_EVT* p_data) {\n  BT_HDR* p_pkt = &p_data->hdr;\n uint8_t *p, *p_start;\n  tMCA_DCB* p_dcb;\n  tMCA_CTRL evt_data;\n  tMCA_CCB_MSG* p_rx_msg = NULL;\n uint8_t reject_code = MCA_RSP_NO_RESOURCE;\n bool send_rsp = false;\n bool check_req = false;\n uint8_t reject_opcode;\n\n  MCA_TRACE_DEBUG(\"mca_ccb_hdl_req status:%d\", p_ccb->status);\n\n   p_rx_msg = (tMCA_CCB_MSG*)p_pkt;\n   p = (uint8_t*)(p_pkt + 1) + p_pkt->offset;\n   evt_data.hdr.op_code = *p++;\n   reject_opcode = evt_data.hdr.op_code + 1;\n \n  if (p_pkt->len >= 3) {\n    BE_STREAM_TO_UINT16(evt_data.hdr.mdl_id, p);\n  } else {\n    android_errorWriteLog(0x534e4554, \"110791536\");\n    evt_data.hdr.mdl_id = 0;\n  }\n\n   MCA_TRACE_DEBUG(\"received mdl id: %d \", evt_data.hdr.mdl_id);\n   if (p_ccb->status == MCA_CCB_STAT_PENDING) {\n     MCA_TRACE_DEBUG(\"received req inpending state\");\n /* allow abort in pending state */\n if ((p_ccb->status == MCA_CCB_STAT_PENDING) &&\n (evt_data.hdr.op_code == MCA_OP_MDL_ABORT_REQ)) {\n      reject_code = MCA_RSP_SUCCESS;\n      send_rsp = true;\n /* clear the pending status */\n      p_ccb->status = MCA_CCB_STAT_NORM;\n if (p_ccb->p_tx_req &&\n ((p_dcb = mca_dcb_by_hdl(p_ccb->p_tx_req->dcb_idx)) != NULL)) {\n        mca_dcb_dealloc(p_dcb, NULL);\n        osi_free_and_reset((void**)&p_ccb->p_tx_req);\n }\n } else\n      reject_code = MCA_RSP_BAD_OP;\n } else if (p_ccb->p_rx_msg) {\n    MCA_TRACE_DEBUG(\"still handling prev req\");\n /* still holding previous message, reject this new one ?? */\n\n } else if (p_ccb->p_tx_req) {\n    MCA_TRACE_DEBUG(\"still waiting for a response ctrl_vpsm:0x%x\",\n                    p_ccb->ctrl_vpsm);\n /* sent a request; waiting for response */\n if (p_ccb->ctrl_vpsm == 0) {\n      MCA_TRACE_DEBUG(\"local is ACP. accept the cmd from INT\");\n /* local is acceptor, need to handle the request */\n      check_req = true;\n      reject_code = MCA_RSP_SUCCESS;\n /* drop the previous request */\n if ((p_ccb->p_tx_req->op_code == MCA_OP_MDL_CREATE_REQ) &&\n ((p_dcb = mca_dcb_by_hdl(p_ccb->p_tx_req->dcb_idx)) != NULL)) {\n        mca_dcb_dealloc(p_dcb, NULL);\n }\n      osi_free_and_reset((void**)&p_ccb->p_tx_req);\n      mca_stop_timer(p_ccb);\n } else {\n /*  local is initiator, ignore the req */\n      osi_free(p_pkt);\n return;\n }\n } else if (p_pkt->layer_specific != MCA_RSP_SUCCESS) {\n    reject_code = (uint8_t)p_pkt->layer_specific;\n if (((evt_data.hdr.op_code >= MCA_NUM_STANDARD_OPCODE) &&\n (evt_data.hdr.op_code < MCA_FIRST_SYNC_OP)) ||\n (evt_data.hdr.op_code > MCA_LAST_SYNC_OP)) {\n /* invalid op code */\n      reject_opcode = MCA_OP_ERROR_RSP;\n      evt_data.hdr.mdl_id = 0;\n }\n } else {\n    check_req = true;\n    reject_code = MCA_RSP_SUCCESS;\n }\n\n if (check_req) {\n if (reject_code == MCA_RSP_SUCCESS) {\n      reject_code = MCA_RSP_BAD_MDL;\n if (MCA_IS_VALID_MDL_ID(evt_data.hdr.mdl_id) ||\n ((evt_data.hdr.mdl_id == MCA_ALL_MDL_ID) &&\n (evt_data.hdr.op_code == MCA_OP_MDL_DELETE_REQ))) {\n        reject_code = MCA_RSP_SUCCESS;\n /* mdl_id is valid according to the spec */\n switch (evt_data.hdr.op_code) {\n case MCA_OP_MDL_CREATE_REQ:\n            evt_data.create_ind.dep_id = *p++;\n            evt_data.create_ind.cfg = *p++;\n            p_rx_msg->mdep_id = evt_data.create_ind.dep_id;\n if (!mca_is_valid_dep_id(p_ccb->p_rcb, p_rx_msg->mdep_id)) {\n              MCA_TRACE_ERROR(\"%s: Invalid local MDEP ID %d\", __func__,\n                              p_rx_msg->mdep_id);\n              reject_code = MCA_RSP_BAD_MDEP;\n } else if (mca_ccb_uses_mdl_id(p_ccb, evt_data.hdr.mdl_id)) {\n              MCA_TRACE_DEBUG(\"the mdl_id is currently used in the CL(create)\");\n              mca_dcb_close_by_mdl_id(p_ccb, evt_data.hdr.mdl_id);\n } else {\n /* check if this dep still have MDL available */\n if (mca_dep_free_mdl(p_ccb, evt_data.create_ind.dep_id) == 0) {\n                MCA_TRACE_ERROR(\"%s: MAX_MDL is used by MDEP %d\", __func__,\n                                evt_data.create_ind.dep_id);\n                reject_code = MCA_RSP_MDEP_BUSY;\n }\n }\n break;\n\n case MCA_OP_MDL_RECONNECT_REQ:\n if (mca_ccb_uses_mdl_id(p_ccb, evt_data.hdr.mdl_id)) {\n              MCA_TRACE_ERROR(\"%s: MDL_ID %d busy, in CL(reconn)\", __func__,\n                              evt_data.hdr.mdl_id);\n              reject_code = MCA_RSP_MDL_BUSY;\n }\n break;\n\n case MCA_OP_MDL_ABORT_REQ:\n            reject_code = MCA_RSP_BAD_OP;\n break;\n\n case MCA_OP_MDL_DELETE_REQ:\n /* delete the associated mdl */\n            mca_dcb_close_by_mdl_id(p_ccb, evt_data.hdr.mdl_id);\n            send_rsp = true;\n break;\n }\n }\n }\n }\n\n if (((reject_code != MCA_RSP_SUCCESS) &&\n (evt_data.hdr.op_code != MCA_OP_SYNC_INFO_IND)) ||\n      send_rsp) {\n    BT_HDR* p_buf = (BT_HDR*)osi_malloc(MCA_CTRL_MTU + sizeof(BT_HDR));\n    p_buf->offset = L2CAP_MIN_OFFSET;\n    p = p_start = (uint8_t*)(p_buf + 1) + L2CAP_MIN_OFFSET;\n *p++ = reject_opcode;\n *p++ = reject_code;\n bool valid_response = true;\n switch (reject_opcode) {\n case MCA_OP_ERROR_RSP:\n case MCA_OP_MDL_CREATE_RSP:\n case MCA_OP_MDL_RECONNECT_RSP:\n case MCA_OP_MDL_ABORT_RSP:\n case MCA_OP_MDL_DELETE_RSP:\n        UINT16_TO_BE_STREAM(p, evt_data.hdr.mdl_id);\n break;\n case MCA_OP_SYNC_CAP_RSP:\n        memset(p, 0, 7);\n        p += 7;\n break;\n case MCA_OP_SYNC_SET_RSP:\n        memset(p, 0, 14);\n        p += 14;\n break;\n default:\n        MCA_TRACE_ERROR(\"%s: reject_opcode 0x%02x not recognized\", __func__,\n                        reject_opcode);\n        valid_response = false;\n break;\n }\n if (valid_response) {\n      p_buf->len = p - p_start;\n      MCA_TRACE_ERROR(\"%s: reject_opcode=0x%02x, reject_code=0x%02x, length=%d\",\n                      __func__, reject_opcode, reject_code, p_buf->len);\n      L2CA_DataWrite(p_ccb->lcid, p_buf);\n } else {\n      osi_free(p_buf);\n }\n }\n\n if (reject_code == MCA_RSP_SUCCESS) {\n /* use the received GKI buffer to store information to double check response\n     * API */\n    p_rx_msg->op_code = evt_data.hdr.op_code;\n    p_rx_msg->mdl_id = evt_data.hdr.mdl_id;\n    p_ccb->p_rx_msg = p_rx_msg;\n if (send_rsp) {\n      osi_free(p_pkt);\n      p_ccb->p_rx_msg = NULL;\n }\n    mca_ccb_report_event(p_ccb, evt_data.hdr.op_code, &evt_data);\n } else\n    osi_free(p_pkt);\n}\n",
    "cwe": [
      "CWE-125"
    ],
    "id": 575,
    "_valid_cwes": [
      "CWE-125"
    ]
  },
  {
    "cve_id": "CVE-2017-17081",
    "code_before_change": "static void gmc_mmx(uint8_t *dst, uint8_t *src,\n                    int stride, int h, int ox, int oy,\n                    int dxx, int dxy, int dyx, int dyy,\n                    int shift, int r, int width, int height)\n{\n    const int w    = 8;\n    const int ix   = ox  >> (16 + shift);\n    const int iy   = oy  >> (16 + shift);\n    const int oxs  = ox  >> 4;\n    const int oys  = oy  >> 4;\n    const int dxxs = dxx >> 4;\n    const int dxys = dxy >> 4;\n    const int dyxs = dyx >> 4;\n    const int dyys = dyy >> 4;\n    const uint16_t r4[4]   = { r, r, r, r };\n    const uint16_t dxy4[4] = { dxys, dxys, dxys, dxys };\n    const uint16_t dyy4[4] = { dyys, dyys, dyys, dyys };\n    const uint64_t shift2  = 2 * shift;\n#define MAX_STRIDE 4096U\n#define MAX_H 8U\n    uint8_t edge_buf[(MAX_H + 1) * MAX_STRIDE];\n    int x, y;\n\n    const int dxw = (dxx - (1 << (16 + shift))) * (w - 1);\n     const int dyh = (dyy - (1 << (16 + shift))) * (h - 1);\n     const int dxh = dxy * (h - 1);\n     const int dyw = dyx * (w - 1);\n    int need_emu  =  (unsigned) ix >= width  - w ||\n                     (unsigned) iy >= height - h;\n \n     if ( // non-constant fullpel offset (3% of blocks)\n         ((ox ^ (ox + dxw)) | (ox ^ (ox + dxh)) | (ox ^ (ox + dxw + dxh)) |\n         (oy ^ (oy + dyw)) | (oy ^ (oy + dyh)) | (oy ^ (oy + dyw + dyh))) >> (16 + shift) ||\n        (dxx | dxy | dyx | dyy) & 15 ||\n        (need_emu && (h > MAX_H || stride > MAX_STRIDE))) {\n        ff_gmc_c(dst, src, stride, h, ox, oy, dxx, dxy, dyx, dyy,\n                 shift, r, width, height);\n        return;\n    }\n\n    src += ix + iy * stride;\n    if (need_emu) {\n        ff_emulated_edge_mc_8(edge_buf, src, stride, stride, w + 1, h + 1, ix, iy, width, height);\n        src = edge_buf;\n    }\n\n    __asm__ volatile (\n        \"movd         %0, %%mm6         \\n\\t\"\n        \"pxor      %%mm7, %%mm7         \\n\\t\"\n        \"punpcklwd %%mm6, %%mm6         \\n\\t\"\n        \"punpcklwd %%mm6, %%mm6         \\n\\t\"\n        :: \"r\" (1 << shift));\n\n    for (x = 0; x < w; x += 4) {\n        uint16_t dx4[4] = { oxs - dxys + dxxs * (x + 0),\n                            oxs - dxys + dxxs * (x + 1),\n                            oxs - dxys + dxxs * (x + 2),\n                            oxs - dxys + dxxs * (x + 3) };\n        uint16_t dy4[4] = { oys - dyys + dyxs * (x + 0),\n                            oys - dyys + dyxs * (x + 1),\n                            oys - dyys + dyxs * (x + 2),\n                            oys - dyys + dyxs * (x + 3) };\n\n        for (y = 0; y < h; y++) {\n            __asm__ volatile (\n                \"movq      %0, %%mm4    \\n\\t\"\n                \"movq      %1, %%mm5    \\n\\t\"\n                \"paddw     %2, %%mm4    \\n\\t\"\n                \"paddw     %3, %%mm5    \\n\\t\"\n                \"movq   %%mm4, %0       \\n\\t\"\n                \"movq   %%mm5, %1       \\n\\t\"\n                \"psrlw    $12, %%mm4    \\n\\t\"\n                \"psrlw    $12, %%mm5    \\n\\t\"\n                : \"+m\" (*dx4), \"+m\" (*dy4)\n                : \"m\" (*dxy4), \"m\" (*dyy4));\n\n            __asm__ volatile (\n                \"movq      %%mm6, %%mm2 \\n\\t\"\n                \"movq      %%mm6, %%mm1 \\n\\t\"\n                \"psubw     %%mm4, %%mm2 \\n\\t\"\n                \"psubw     %%mm5, %%mm1 \\n\\t\"\n                \"movq      %%mm2, %%mm0 \\n\\t\"\n                \"movq      %%mm4, %%mm3 \\n\\t\"\n                \"pmullw    %%mm1, %%mm0 \\n\\t\" // (s - dx) * (s - dy)\n                \"pmullw    %%mm5, %%mm3 \\n\\t\" // dx * dy\n                \"pmullw    %%mm5, %%mm2 \\n\\t\" // (s - dx) * dy\n                \"pmullw    %%mm4, %%mm1 \\n\\t\" // dx * (s - dy)\n\n                \"movd         %4, %%mm5 \\n\\t\"\n                \"movd         %3, %%mm4 \\n\\t\"\n                \"punpcklbw %%mm7, %%mm5 \\n\\t\"\n                \"punpcklbw %%mm7, %%mm4 \\n\\t\"\n                \"pmullw    %%mm5, %%mm3 \\n\\t\" // src[1, 1] * dx * dy\n                \"pmullw    %%mm4, %%mm2 \\n\\t\" // src[0, 1] * (s - dx) * dy\n\n                \"movd         %2, %%mm5 \\n\\t\"\n                \"movd         %1, %%mm4 \\n\\t\"\n                \"punpcklbw %%mm7, %%mm5 \\n\\t\"\n                \"punpcklbw %%mm7, %%mm4 \\n\\t\"\n                \"pmullw    %%mm5, %%mm1 \\n\\t\" // src[1, 0] * dx * (s - dy)\n                \"pmullw    %%mm4, %%mm0 \\n\\t\" // src[0, 0] * (s - dx) * (s - dy)\n                \"paddw        %5, %%mm1 \\n\\t\"\n                \"paddw     %%mm3, %%mm2 \\n\\t\"\n                \"paddw     %%mm1, %%mm0 \\n\\t\"\n                \"paddw     %%mm2, %%mm0 \\n\\t\"\n\n                \"psrlw        %6, %%mm0 \\n\\t\"\n                \"packuswb  %%mm0, %%mm0 \\n\\t\"\n                \"movd      %%mm0, %0    \\n\\t\"\n\n                : \"=m\" (dst[x + y * stride])\n                : \"m\" (src[0]), \"m\" (src[1]),\n                  \"m\" (src[stride]), \"m\" (src[stride + 1]),\n                  \"m\" (*r4), \"m\" (shift2));\n            src += stride;\n        }\n        src += 4 - h * stride;\n    }\n}\n",
    "code_after_change": "static void gmc_mmx(uint8_t *dst, uint8_t *src,\n                    int stride, int h, int ox, int oy,\n                    int dxx, int dxy, int dyx, int dyy,\n                    int shift, int r, int width, int height)\n{\n    const int w    = 8;\n    const int ix   = ox  >> (16 + shift);\n    const int iy   = oy  >> (16 + shift);\n    const int oxs  = ox  >> 4;\n    const int oys  = oy  >> 4;\n    const int dxxs = dxx >> 4;\n    const int dxys = dxy >> 4;\n    const int dyxs = dyx >> 4;\n    const int dyys = dyy >> 4;\n    const uint16_t r4[4]   = { r, r, r, r };\n    const uint16_t dxy4[4] = { dxys, dxys, dxys, dxys };\n    const uint16_t dyy4[4] = { dyys, dyys, dyys, dyys };\n    const uint64_t shift2  = 2 * shift;\n#define MAX_STRIDE 4096U\n#define MAX_H 8U\n    uint8_t edge_buf[(MAX_H + 1) * MAX_STRIDE];\n    int x, y;\n\n    const int dxw = (dxx - (1 << (16 + shift))) * (w - 1);\n     const int dyh = (dyy - (1 << (16 + shift))) * (h - 1);\n     const int dxh = dxy * (h - 1);\n     const int dyw = dyx * (w - 1);\n    int need_emu  =  (unsigned) ix >= width  - w || width < w ||\n                     (unsigned) iy >= height - h || height< h\n                     ;\n \n     if ( // non-constant fullpel offset (3% of blocks)\n         ((ox ^ (ox + dxw)) | (ox ^ (ox + dxh)) | (ox ^ (ox + dxw + dxh)) |\n         (oy ^ (oy + dyw)) | (oy ^ (oy + dyh)) | (oy ^ (oy + dyw + dyh))) >> (16 + shift) ||\n        (dxx | dxy | dyx | dyy) & 15 ||\n        (need_emu && (h > MAX_H || stride > MAX_STRIDE))) {\n        ff_gmc_c(dst, src, stride, h, ox, oy, dxx, dxy, dyx, dyy,\n                 shift, r, width, height);\n        return;\n    }\n\n    src += ix + iy * stride;\n    if (need_emu) {\n        ff_emulated_edge_mc_8(edge_buf, src, stride, stride, w + 1, h + 1, ix, iy, width, height);\n        src = edge_buf;\n    }\n\n    __asm__ volatile (\n        \"movd         %0, %%mm6         \\n\\t\"\n        \"pxor      %%mm7, %%mm7         \\n\\t\"\n        \"punpcklwd %%mm6, %%mm6         \\n\\t\"\n        \"punpcklwd %%mm6, %%mm6         \\n\\t\"\n        :: \"r\" (1 << shift));\n\n    for (x = 0; x < w; x += 4) {\n        uint16_t dx4[4] = { oxs - dxys + dxxs * (x + 0),\n                            oxs - dxys + dxxs * (x + 1),\n                            oxs - dxys + dxxs * (x + 2),\n                            oxs - dxys + dxxs * (x + 3) };\n        uint16_t dy4[4] = { oys - dyys + dyxs * (x + 0),\n                            oys - dyys + dyxs * (x + 1),\n                            oys - dyys + dyxs * (x + 2),\n                            oys - dyys + dyxs * (x + 3) };\n\n        for (y = 0; y < h; y++) {\n            __asm__ volatile (\n                \"movq      %0, %%mm4    \\n\\t\"\n                \"movq      %1, %%mm5    \\n\\t\"\n                \"paddw     %2, %%mm4    \\n\\t\"\n                \"paddw     %3, %%mm5    \\n\\t\"\n                \"movq   %%mm4, %0       \\n\\t\"\n                \"movq   %%mm5, %1       \\n\\t\"\n                \"psrlw    $12, %%mm4    \\n\\t\"\n                \"psrlw    $12, %%mm5    \\n\\t\"\n                : \"+m\" (*dx4), \"+m\" (*dy4)\n                : \"m\" (*dxy4), \"m\" (*dyy4));\n\n            __asm__ volatile (\n                \"movq      %%mm6, %%mm2 \\n\\t\"\n                \"movq      %%mm6, %%mm1 \\n\\t\"\n                \"psubw     %%mm4, %%mm2 \\n\\t\"\n                \"psubw     %%mm5, %%mm1 \\n\\t\"\n                \"movq      %%mm2, %%mm0 \\n\\t\"\n                \"movq      %%mm4, %%mm3 \\n\\t\"\n                \"pmullw    %%mm1, %%mm0 \\n\\t\" // (s - dx) * (s - dy)\n                \"pmullw    %%mm5, %%mm3 \\n\\t\" // dx * dy\n                \"pmullw    %%mm5, %%mm2 \\n\\t\" // (s - dx) * dy\n                \"pmullw    %%mm4, %%mm1 \\n\\t\" // dx * (s - dy)\n\n                \"movd         %4, %%mm5 \\n\\t\"\n                \"movd         %3, %%mm4 \\n\\t\"\n                \"punpcklbw %%mm7, %%mm5 \\n\\t\"\n                \"punpcklbw %%mm7, %%mm4 \\n\\t\"\n                \"pmullw    %%mm5, %%mm3 \\n\\t\" // src[1, 1] * dx * dy\n                \"pmullw    %%mm4, %%mm2 \\n\\t\" // src[0, 1] * (s - dx) * dy\n\n                \"movd         %2, %%mm5 \\n\\t\"\n                \"movd         %1, %%mm4 \\n\\t\"\n                \"punpcklbw %%mm7, %%mm5 \\n\\t\"\n                \"punpcklbw %%mm7, %%mm4 \\n\\t\"\n                \"pmullw    %%mm5, %%mm1 \\n\\t\" // src[1, 0] * dx * (s - dy)\n                \"pmullw    %%mm4, %%mm0 \\n\\t\" // src[0, 0] * (s - dx) * (s - dy)\n                \"paddw        %5, %%mm1 \\n\\t\"\n                \"paddw     %%mm3, %%mm2 \\n\\t\"\n                \"paddw     %%mm1, %%mm0 \\n\\t\"\n                \"paddw     %%mm2, %%mm0 \\n\\t\"\n\n                \"psrlw        %6, %%mm0 \\n\\t\"\n                \"packuswb  %%mm0, %%mm0 \\n\\t\"\n                \"movd      %%mm0, %0    \\n\\t\"\n\n                : \"=m\" (dst[x + y * stride])\n                : \"m\" (src[0]), \"m\" (src[1]),\n                  \"m\" (src[stride]), \"m\" (src[stride + 1]),\n                  \"m\" (*r4), \"m\" (shift2));\n            src += stride;\n        }\n        src += 4 - h * stride;\n    }\n}\n",
    "cwe": [
      "CWE-125"
    ],
    "id": 652,
    "_valid_cwes": [
      "CWE-125"
    ]
  },
  {
    "cve_id": "CVE-2016-3183",
    "code_before_change": "static void sycc444_to_rgb(opj_image_t *img)\n {\n \tint *d0, *d1, *d2, *r, *g, *b;\n \tconst int *y, *cb, *cr;\n\tunsigned int maxw, maxh, max, i;\n \tint offset, upb;\n \n \tupb = (int)img->comps[0].prec;\n \toffset = 1<<(upb - 1); upb = (1<<upb)-1;\n \n\tmaxw = (unsigned int)img->comps[0].w; maxh = (unsigned int)img->comps[0].h;\n \tmax = maxw * maxh;\n \n \ty = img->comps[0].data;\n \tcb = img->comps[1].data;\n \tcr = img->comps[2].data;\n \n\td0 = r = (int*)malloc(sizeof(int) * (size_t)max);\n\td1 = g = (int*)malloc(sizeof(int) * (size_t)max);\n\td2 = b = (int*)malloc(sizeof(int) * (size_t)max);\n \n \tif(r == NULL || g == NULL || b == NULL) goto fails;\n \n\tfor(i = 0U; i < max; ++i)\n\t{\n\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\t\t++y; ++cb; ++cr; ++r; ++g; ++b;\n\t}\n \tfree(img->comps[0].data); img->comps[0].data = d0;\n \tfree(img->comps[1].data); img->comps[1].data = d1;\n \tfree(img->comps[2].data); img->comps[2].data = d2;\n \treturn;\n \n fails:\n\tif(r) free(r);\n\tif(g) free(g);\n\tif(b) free(b);\n }/* sycc444_to_rgb() */\n",
    "code_after_change": "static void sycc444_to_rgb(opj_image_t *img)\n {\n \tint *d0, *d1, *d2, *r, *g, *b;\n \tconst int *y, *cb, *cr;\n\tsize_t maxw, maxh, max, i;\n \tint offset, upb;\n \n \tupb = (int)img->comps[0].prec;\n \toffset = 1<<(upb - 1); upb = (1<<upb)-1;\n \n\tmaxw = (size_t)img->comps[0].w; maxh = (size_t)img->comps[0].h;\n \tmax = maxw * maxh;\n \n \ty = img->comps[0].data;\n \tcb = img->comps[1].data;\n \tcr = img->comps[2].data;\n \n\td0 = r = (int*)malloc(sizeof(int) * max);\n\td1 = g = (int*)malloc(sizeof(int) * max);\n\td2 = b = (int*)malloc(sizeof(int) * max);\n \n \tif(r == NULL || g == NULL || b == NULL) goto fails;\n \n\tfor(i = 0U; i < max; ++i)\n\t{\n\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\t\t++y; ++cb; ++cr; ++r; ++g; ++b;\n\t}\n \tfree(img->comps[0].data); img->comps[0].data = d0;\n \tfree(img->comps[1].data); img->comps[1].data = d1;\n \tfree(img->comps[2].data); img->comps[2].data = d2;\n\timg->color_space = OPJ_CLRSPC_SRGB;\n \treturn;\n \n fails:\n\tfree(r);\n\tfree(g);\n\tfree(b);\n }/* sycc444_to_rgb() */\n",
    "cwe": [
      "CWE-125"
    ],
    "id": 663,
    "_valid_cwes": [
      "CWE-125"
    ]
  },
  {
    "cve_id": "CVE-2016-10269",
    "code_before_change": " PixarLogClose(TIFF* tif)\n {\n \tTIFFDirectory *td = &tif->tif_dir;\n \n \t/* In a really sneaky (and really incorrect, and untruthful, and\n \t * troublesome, and error-prone) maneuver that completely goes against\n \t * the spirit of TIFF, and breaks TIFF, on close, we covertly\n\t * modify both bitspersample and sampleformat in the directory to\n\t * indicate 8-bit linear.  This way, the decode \"just works\" even for\n \t * readers that don't know about PixarLog, or how to set\n \t * the PIXARLOGDATFMT pseudo-tag.\n \t */\n\ttd->td_bitspersample = 8;\n\ttd->td_sampleformat = SAMPLEFORMAT_UINT;\n }\n",
    "code_after_change": " PixarLogClose(TIFF* tif)\n {\n        PixarLogState* sp = (PixarLogState*) tif->tif_data;\n \tTIFFDirectory *td = &tif->tif_dir;\n \n\tassert(sp != 0);\n \t/* In a really sneaky (and really incorrect, and untruthful, and\n \t * troublesome, and error-prone) maneuver that completely goes against\n \t * the spirit of TIFF, and breaks TIFF, on close, we covertly\n\t * modify both bitspersample and sampleformat in the directory to\n\t * indicate 8-bit linear.  This way, the decode \"just works\" even for\n \t * readers that don't know about PixarLog, or how to set\n \t * the PIXARLOGDATFMT pseudo-tag.\n \t */\n\n        if (sp->state&PLSTATE_INIT) {\n            /* We test the state to avoid an issue such as in\n             * http://bugzilla.maptools.org/show_bug.cgi?id=2604\n             * What appends in that case is that the bitspersample is 1 and\n             * a TransferFunction is set. The size of the TransferFunction\n             * depends on 1<<bitspersample. So if we increase it, an access\n             * out of the buffer will happen at directory flushing.\n             * Another option would be to clear those targs. \n             */\n            td->td_bitspersample = 8;\n            td->td_sampleformat = SAMPLEFORMAT_UINT;\n        }\n }\n",
    "cwe": [
      "CWE-125"
    ],
    "id": 667,
    "_valid_cwes": [
      "CWE-125"
    ]
  },
  {
    "cve_id": "CVE-2018-20456",
    "code_before_change": "static int parseOperand(RAsm *a, const char *str, Operand *op, bool isrepop) {\n\tsize_t pos, nextpos = 0;\n\tx86newTokenType last_type;\n\tint size_token = 1;\n\tbool explicit_size = false;\n\tint reg_index = 0;\n\top->type = 0;\n\twhile (size_token) {\n\t\tpos = nextpos;\n\t\tlast_type = getToken (str, &pos, &nextpos);\n\n\t\tif (!r_str_ncasecmp (str + pos, \"ptr\", 3)) {\n\t\t\tcontinue;\n\t\t} else if (!r_str_ncasecmp (str + pos, \"byte\", 4)) {\n\t\t\top->type |= OT_MEMORY | OT_BYTE;\n\t\t\top->dest_size = OT_BYTE;\n\t\t\texplicit_size = true;\n\t\t} else if (!r_str_ncasecmp (str + pos, \"word\", 4)) {\n\t\t\top->type |= OT_MEMORY | OT_WORD;\n\t\t\top->dest_size = OT_WORD;\n\t\t\texplicit_size = true;\n\t\t} else if (!r_str_ncasecmp (str + pos, \"dword\", 5)) {\n\t\t\top->type |= OT_MEMORY | OT_DWORD;\n\t\t\top->dest_size = OT_DWORD;\n\t\t\texplicit_size = true;\n\t\t} else if (!r_str_ncasecmp (str + pos, \"qword\", 5)) {\n\t\t\top->type |= OT_MEMORY | OT_QWORD;\n\t\t\top->dest_size = OT_QWORD;\n\t\t\texplicit_size = true;\n\t\t} else if (!r_str_ncasecmp (str + pos, \"oword\", 5)) {\n\t\t\top->type |= OT_MEMORY | OT_OWORD;\n\t\t\top->dest_size = OT_OWORD;\n\t\t\texplicit_size = true;\n\t\t} else if (!r_str_ncasecmp (str + pos, \"tbyte\", 5)) {\n\t\t\top->type |= OT_MEMORY | OT_TBYTE;\n\t\t\top->dest_size = OT_TBYTE;\n\t\t\texplicit_size = true;\n\t\t} else { // the current token doesn't denote a size\n\t\t\tsize_token = 0;\n\t\t}\n\t}\n\n\tif (str[pos] == '[') {\n\t\tif (!op->type) {\n\t\t\top->type = OT_MEMORY;\n\t\t}\n\t\top->offset = op->scale[0] = op->scale[1] = 0;\n\n\t\tut64 temp = 1;\n\t\tRegister reg = X86R_UNDEFINED;\n\t\tbool first_reg = true;\n\t\twhile (str[pos] != ']') {\n\t\t\tif (pos > nextpos) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpos = nextpos;\n\t\t\tif (!str[pos]) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlast_type = getToken (str, &pos, &nextpos);\n\n \t\t\tif (last_type == TT_SPECIAL) {\n \t\t\t\tif (str[pos] == '+' || str[pos] == '-' || str[pos] == ']') {\n \t\t\t\t\tif (reg != X86R_UNDEFINED) {\n\t\t\t\t\t\top->regs[reg_index] = reg;\n\t\t\t\t\t\top->scale[reg_index] = temp;\n \t\t\t\t\t\t++reg_index;\n \t\t\t\t\t} else {\n \t\t\t\t\t\top->offset += temp;\n\t\t\t\t\t\top->regs[reg_index] = X86R_UNDEFINED;\n \t\t\t\t\t}\n \t\t\t\t\ttemp = 1;\n \t\t\t\t\treg = X86R_UNDEFINED;\n \t\t\t\t} else if (str[pos] == '*') {\n\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (last_type == TT_WORD) {\n\t\t\t\tut32 reg_type = 0;\n\n\t\t\t\tif (reg != X86R_UNDEFINED) {\n\t\t\t\t\top->type = 0;\t// Make the result invalid\n\t\t\t\t}\n\n\t\t\t\tnextpos = pos;\n\t\t\t\treg = parseReg (a, str, &nextpos, &reg_type);\n\n\t\t\t\tif (first_reg) {\n\t\t\t\t\top->extended = false;\n\t\t\t\t\tif (reg > 8) {\n\t\t\t\t\t\top->extended = true;\n\t\t\t\t\t\top->reg = reg - 9;\n\t\t\t\t\t}\n\t\t\t\t\tfirst_reg = false;\n\t\t\t\t} else if (reg > 8) {\n\t\t\t\t\top->reg = reg - 9;\n\t\t\t\t}\n\t\t\t\tif (reg_type & OT_REGTYPE & OT_SEGMENTREG) {\n\t\t\t\t\top->reg = reg;\n\t\t\t\t\top->type = reg_type;\n\t\t\t\t\tparse_segment_offset (a, str, &nextpos, op, reg_index);\n\t\t\t\t\treturn nextpos;\n\t\t\t\t}\n\n\t\t\t\tif (!explicit_size) {\n\t\t\t\t\top->type |= reg_type;\n\t\t\t\t}\n\t\t\t\top->reg_size = reg_type;\n\t\t\t\top->explicit_size = explicit_size;\n\n\t\t\t\tif (!(reg_type & OT_GPREG)) {\n\t\t\t\t\top->type = 0;\t// Make the result invalid\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tchar *p = strchr (str, '+');\n\t\t\t\top->offset_sign = 1;\n\t\t\t\tif (!p) {\n\t\t\t\t\tp = strchr (str, '-');\n\t\t\t\t\tif (p) {\n\t\t\t\t\t\top->offset_sign = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tchar * plus = strchr (str, '+');\n\t\t\t\tchar * minus = strchr (str, '-');\n\t\t\t\tchar * closeB = strchr (str, ']');\n\t\t\t\tif (plus && minus && plus < closeB && minus < closeB) {\n\t\t\t\t\top->offset_sign = -1;\n\t\t\t\t}\n\t\t\t\tchar *tmp;\n\t\t\t\ttmp = malloc (strlen (str + pos) + 1);\n\t\t\t\tstrcpy (tmp, str + pos);\n\t\t\t\tstrtok (tmp, \"+-\");\n\t\t\t\tst64 read = getnum (a, tmp);\n\t\t\t\tfree (tmp);\n\t\t\t\ttemp *= read;\n\t\t\t}\n\t\t}\n\t} else if (last_type == TT_WORD) {   // register\n\t\tnextpos = pos;\n\t\tRFlagItem *flag;\n\n\t\tif (isrepop) {\n\t\t\top->is_good_flag = false;\n\t\t\tstrncpy (op->rep_op, str, MAX_REPOP_LENGTH - 1);\n\t\t\top->rep_op[MAX_REPOP_LENGTH - 1] = '\\0';\n\t\t\treturn nextpos;\n\t\t}\n\n\t\top->reg = parseReg (a, str, &nextpos, &op->type);\n\n\t\top->extended = false;\n\t\tif (op->reg > 8) {\n\t\t\top->extended = true;\n\t\t\top->reg -= 9;\n\t\t}\n\t\tif (op->type & OT_REGTYPE & OT_SEGMENTREG) {\n\t\t\tparse_segment_offset (a, str, &nextpos, op, reg_index);\n\t\t\treturn nextpos;\n\t\t}\n\t\tif (op->reg == X86R_UNDEFINED) {\n\t\t\top->is_good_flag = false;\n\t\t\tif (a->num && a->num->value == 0) {\n\t\t\t\treturn nextpos;\n\t\t\t}\n\t\t\top->type = OT_CONSTANT;\n\t\t\tRCore *core = a->num? (RCore *)(a->num->userptr): NULL;\n\t\t\tif (core && (flag = r_flag_get (core->flags, str))) {\n\t\t\t\top->is_good_flag = true;\n\t\t\t}\n\n\t\t\tchar *p = strchr (str, '-');\n\t\t\tif (p) {\n\t\t\t\top->sign = -1;\n\t\t\t\tstr = ++p;\n\t\t\t}\n\t\t\top->immediate = getnum (a, str);\n\t\t} else if (op->reg < X86R_UNDEFINED) {\n\t\t\tstrncpy (op->rep_op, str, MAX_REPOP_LENGTH - 1);\n\t\t\top->rep_op[MAX_REPOP_LENGTH - 1] = '\\0';\n\t\t}\n\t} else {                             // immediate\n\t\top->type = OT_CONSTANT;\n\t\top->sign = 1;\n\t\tchar *p = strchr (str, '-');\n\t\tif (p) {\n\t\t\top->sign = -1;\n\t\t\tstr = ++p;\n\t\t}\n\t\top->immediate = getnum (a, str);\n\t}\n\n\treturn nextpos;\n}\n",
    "code_after_change": "static int parseOperand(RAsm *a, const char *str, Operand *op, bool isrepop) {\n\tsize_t pos, nextpos = 0;\n\tx86newTokenType last_type;\n\tint size_token = 1;\n\tbool explicit_size = false;\n\tint reg_index = 0;\n\top->type = 0;\n\twhile (size_token) {\n\t\tpos = nextpos;\n\t\tlast_type = getToken (str, &pos, &nextpos);\n\n\t\tif (!r_str_ncasecmp (str + pos, \"ptr\", 3)) {\n\t\t\tcontinue;\n\t\t} else if (!r_str_ncasecmp (str + pos, \"byte\", 4)) {\n\t\t\top->type |= OT_MEMORY | OT_BYTE;\n\t\t\top->dest_size = OT_BYTE;\n\t\t\texplicit_size = true;\n\t\t} else if (!r_str_ncasecmp (str + pos, \"word\", 4)) {\n\t\t\top->type |= OT_MEMORY | OT_WORD;\n\t\t\top->dest_size = OT_WORD;\n\t\t\texplicit_size = true;\n\t\t} else if (!r_str_ncasecmp (str + pos, \"dword\", 5)) {\n\t\t\top->type |= OT_MEMORY | OT_DWORD;\n\t\t\top->dest_size = OT_DWORD;\n\t\t\texplicit_size = true;\n\t\t} else if (!r_str_ncasecmp (str + pos, \"qword\", 5)) {\n\t\t\top->type |= OT_MEMORY | OT_QWORD;\n\t\t\top->dest_size = OT_QWORD;\n\t\t\texplicit_size = true;\n\t\t} else if (!r_str_ncasecmp (str + pos, \"oword\", 5)) {\n\t\t\top->type |= OT_MEMORY | OT_OWORD;\n\t\t\top->dest_size = OT_OWORD;\n\t\t\texplicit_size = true;\n\t\t} else if (!r_str_ncasecmp (str + pos, \"tbyte\", 5)) {\n\t\t\top->type |= OT_MEMORY | OT_TBYTE;\n\t\t\top->dest_size = OT_TBYTE;\n\t\t\texplicit_size = true;\n\t\t} else { // the current token doesn't denote a size\n\t\t\tsize_token = 0;\n\t\t}\n\t}\n\n\tif (str[pos] == '[') {\n\t\tif (!op->type) {\n\t\t\top->type = OT_MEMORY;\n\t\t}\n\t\top->offset = op->scale[0] = op->scale[1] = 0;\n\n\t\tut64 temp = 1;\n\t\tRegister reg = X86R_UNDEFINED;\n\t\tbool first_reg = true;\n\t\twhile (str[pos] != ']') {\n\t\t\tif (pos > nextpos) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpos = nextpos;\n\t\t\tif (!str[pos]) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlast_type = getToken (str, &pos, &nextpos);\n\n \t\t\tif (last_type == TT_SPECIAL) {\n \t\t\t\tif (str[pos] == '+' || str[pos] == '-' || str[pos] == ']') {\n \t\t\t\t\tif (reg != X86R_UNDEFINED) {\n\t\t\t\t\t\tif (reg_index < 2) {\n\t\t\t\t\t\t\top->regs[reg_index] = reg;\n\t\t\t\t\t\t\top->scale[reg_index] = temp;\n\t\t\t\t\t\t}\n \t\t\t\t\t\t++reg_index;\n \t\t\t\t\t} else {\n \t\t\t\t\t\top->offset += temp;\n\t\t\t\t\t\tif (reg_index < 2) {\n\t\t\t\t\t\t\top->regs[reg_index] = X86R_UNDEFINED;\n\t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\ttemp = 1;\n \t\t\t\t\treg = X86R_UNDEFINED;\n \t\t\t\t} else if (str[pos] == '*') {\n\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (last_type == TT_WORD) {\n\t\t\t\tut32 reg_type = 0;\n\n\t\t\t\tif (reg != X86R_UNDEFINED) {\n\t\t\t\t\top->type = 0;\t// Make the result invalid\n\t\t\t\t}\n\n\t\t\t\tnextpos = pos;\n\t\t\t\treg = parseReg (a, str, &nextpos, &reg_type);\n\n\t\t\t\tif (first_reg) {\n\t\t\t\t\top->extended = false;\n\t\t\t\t\tif (reg > 8) {\n\t\t\t\t\t\top->extended = true;\n\t\t\t\t\t\top->reg = reg - 9;\n\t\t\t\t\t}\n\t\t\t\t\tfirst_reg = false;\n\t\t\t\t} else if (reg > 8) {\n\t\t\t\t\top->reg = reg - 9;\n\t\t\t\t}\n\t\t\t\tif (reg_type & OT_REGTYPE & OT_SEGMENTREG) {\n\t\t\t\t\top->reg = reg;\n\t\t\t\t\top->type = reg_type;\n\t\t\t\t\tparse_segment_offset (a, str, &nextpos, op, reg_index);\n\t\t\t\t\treturn nextpos;\n\t\t\t\t}\n\n\t\t\t\tif (!explicit_size) {\n\t\t\t\t\top->type |= reg_type;\n\t\t\t\t}\n\t\t\t\top->reg_size = reg_type;\n\t\t\t\top->explicit_size = explicit_size;\n\n\t\t\t\tif (!(reg_type & OT_GPREG)) {\n\t\t\t\t\top->type = 0;\t// Make the result invalid\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tchar *p = strchr (str, '+');\n\t\t\t\top->offset_sign = 1;\n\t\t\t\tif (!p) {\n\t\t\t\t\tp = strchr (str, '-');\n\t\t\t\t\tif (p) {\n\t\t\t\t\t\top->offset_sign = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tchar * plus = strchr (str, '+');\n\t\t\t\tchar * minus = strchr (str, '-');\n\t\t\t\tchar * closeB = strchr (str, ']');\n\t\t\t\tif (plus && minus && plus < closeB && minus < closeB) {\n\t\t\t\t\top->offset_sign = -1;\n\t\t\t\t}\n\t\t\t\tchar *tmp;\n\t\t\t\ttmp = malloc (strlen (str + pos) + 1);\n\t\t\t\tstrcpy (tmp, str + pos);\n\t\t\t\tstrtok (tmp, \"+-\");\n\t\t\t\tst64 read = getnum (a, tmp);\n\t\t\t\tfree (tmp);\n\t\t\t\ttemp *= read;\n\t\t\t}\n\t\t}\n\t} else if (last_type == TT_WORD) {   // register\n\t\tnextpos = pos;\n\t\tRFlagItem *flag;\n\n\t\tif (isrepop) {\n\t\t\top->is_good_flag = false;\n\t\t\tstrncpy (op->rep_op, str, MAX_REPOP_LENGTH - 1);\n\t\t\top->rep_op[MAX_REPOP_LENGTH - 1] = '\\0';\n\t\t\treturn nextpos;\n\t\t}\n\n\t\top->reg = parseReg (a, str, &nextpos, &op->type);\n\n\t\top->extended = false;\n\t\tif (op->reg > 8) {\n\t\t\top->extended = true;\n\t\t\top->reg -= 9;\n\t\t}\n\t\tif (op->type & OT_REGTYPE & OT_SEGMENTREG) {\n\t\t\tparse_segment_offset (a, str, &nextpos, op, reg_index);\n\t\t\treturn nextpos;\n\t\t}\n\t\tif (op->reg == X86R_UNDEFINED) {\n\t\t\top->is_good_flag = false;\n\t\t\tif (a->num && a->num->value == 0) {\n\t\t\t\treturn nextpos;\n\t\t\t}\n\t\t\top->type = OT_CONSTANT;\n\t\t\tRCore *core = a->num? (RCore *)(a->num->userptr): NULL;\n\t\t\tif (core && (flag = r_flag_get (core->flags, str))) {\n\t\t\t\top->is_good_flag = true;\n\t\t\t}\n\n\t\t\tchar *p = strchr (str, '-');\n\t\t\tif (p) {\n\t\t\t\top->sign = -1;\n\t\t\t\tstr = ++p;\n\t\t\t}\n\t\t\top->immediate = getnum (a, str);\n\t\t} else if (op->reg < X86R_UNDEFINED) {\n\t\t\tstrncpy (op->rep_op, str, MAX_REPOP_LENGTH - 1);\n\t\t\top->rep_op[MAX_REPOP_LENGTH - 1] = '\\0';\n\t\t}\n\t} else {                             // immediate\n\t\top->type = OT_CONSTANT;\n\t\top->sign = 1;\n\t\tchar *p = strchr (str, '-');\n\t\tif (p) {\n\t\t\top->sign = -1;\n\t\t\tstr = ++p;\n\t\t}\n\t\top->immediate = getnum (a, str);\n\t}\n\n\treturn nextpos;\n}\n",
    "cwe": [
      "CWE-125"
    ],
    "id": 686,
    "_valid_cwes": [
      "CWE-125"
    ]
  },
  {
    "cve_id": "CVE-2016-5842",
    "code_before_change": "static inline signed int ReadPropertySignedLong(const EndianType endian,\n  const unsigned char *buffer)\n{\n  union\n  {\n    unsigned int\n      unsigned_value;\n\n    signed int\n      signed_value;\n  } quantum;\n\n  unsigned int\n    value;\n \n   if (endian == LSBEndian)\n     {\n      value=(unsigned int) ((buffer[3] << 24) | (buffer[2] << 16) |\n        (buffer[1] << 8 ) | (buffer[0]));\n      quantum.unsigned_value=(value & 0xffffffff);\n       return(quantum.signed_value);\n     }\n  value=(unsigned int) ((buffer[0] << 24) | (buffer[1] << 16) |\n    (buffer[2] << 8) | buffer[3]);\n  quantum.unsigned_value=(value & 0xffffffff);\n   return(quantum.signed_value);\n }\n",
    "code_after_change": "static inline signed int ReadPropertySignedLong(const EndianType endian,\n  const unsigned char *buffer)\n{\n  union\n  {\n    unsigned int\n      unsigned_value;\n\n    signed int\n      signed_value;\n  } quantum;\n\n  unsigned int\n    value;\n \n   if (endian == LSBEndian)\n     {\n      value=(unsigned int) buffer[3] << 24;\n      value|=(unsigned int) buffer[2] << 16;\n      value|=(unsigned int) buffer[1] << 8;\n      value|=(unsigned int) buffer[0];\n      quantum.unsigned_value=value & 0xffffffff;\n       return(quantum.signed_value);\n     }\n  value=(unsigned int) buffer[0] << 24;\n  value|=(unsigned int) buffer[1] << 16;\n  value|=(unsigned int) buffer[2] << 8;\n  value|=(unsigned int) buffer[3];\n  quantum.unsigned_value=value & 0xffffffff;\n   return(quantum.signed_value);\n }\n",
    "cwe": [
      "CWE-125"
    ],
    "id": 691,
    "_valid_cwes": [
      "CWE-125"
    ]
  },
  {
    "cve_id": "CVE-2017-12993",
    "code_before_change": "juniper_ggsn_print(netdissect_options *ndo,\n                   const struct pcap_pkthdr *h, register const u_char *p)\n{\n        struct juniper_l2info_t l2info;\n        struct juniper_ggsn_header {\n            uint8_t svc_id;\n            uint8_t flags_len;\n            uint8_t proto;\n            uint8_t flags;\n            uint8_t vlan_id[2];\n            uint8_t res[2];\n        };\n        const struct juniper_ggsn_header *gh;\n\n        l2info.pictype = DLT_JUNIPER_GGSN;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n\n         p+=l2info.header_len;\n         gh = (struct juniper_ggsn_header *)&l2info.cookie;\n \n         if (ndo->ndo_eflag) {\n             ND_PRINT((ndo, \"proto %s (%u), vlan %u: \",\n                    tok2str(juniper_protocol_values,\"Unknown\",gh->proto),\n                   gh->proto,\n                   EXTRACT_16BITS(&gh->vlan_id[0])));\n        }\n\n        switch (gh->proto) {\n        case JUNIPER_PROTO_IPV4:\n            ip_print(ndo, p, l2info.length);\n            break;\n        case JUNIPER_PROTO_IPV6:\n            ip6_print(ndo, p, l2info.length);\n            break;\n        default:\n            if (!ndo->ndo_eflag)\n                ND_PRINT((ndo, \"unknown GGSN proto (%u)\", gh->proto));\n         }\n \n         return l2info.header_len;\n }\n",
    "code_after_change": "juniper_ggsn_print(netdissect_options *ndo,\n                   const struct pcap_pkthdr *h, register const u_char *p)\n{\n        struct juniper_l2info_t l2info;\n        struct juniper_ggsn_header {\n            uint8_t svc_id;\n            uint8_t flags_len;\n            uint8_t proto;\n            uint8_t flags;\n            uint8_t vlan_id[2];\n            uint8_t res[2];\n        };\n        const struct juniper_ggsn_header *gh;\n\n        l2info.pictype = DLT_JUNIPER_GGSN;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n\n         p+=l2info.header_len;\n         gh = (struct juniper_ggsn_header *)&l2info.cookie;\n \n        ND_TCHECK(*gh);\n         if (ndo->ndo_eflag) {\n             ND_PRINT((ndo, \"proto %s (%u), vlan %u: \",\n                    tok2str(juniper_protocol_values,\"Unknown\",gh->proto),\n                   gh->proto,\n                   EXTRACT_16BITS(&gh->vlan_id[0])));\n        }\n\n        switch (gh->proto) {\n        case JUNIPER_PROTO_IPV4:\n            ip_print(ndo, p, l2info.length);\n            break;\n        case JUNIPER_PROTO_IPV6:\n            ip6_print(ndo, p, l2info.length);\n            break;\n        default:\n            if (!ndo->ndo_eflag)\n                ND_PRINT((ndo, \"unknown GGSN proto (%u)\", gh->proto));\n         }\n \n         return l2info.header_len;\n\ntrunc:\n\tND_PRINT((ndo, \"[|juniper_services]\"));\n\treturn l2info.header_len;\n }\n",
    "cwe": [
      "CWE-125"
    ],
    "id": 715,
    "_valid_cwes": [
      "CWE-125"
    ]
  },
  {
    "cve_id": "CVE-2017-12640",
    "code_before_change": "static Image *ReadOneMNGImage(MngInfo* mng_info, const ImageInfo *image_info,\n     ExceptionInfo *exception)\n{\n  char\n    page_geometry[MaxTextExtent];\n\n  Image\n    *image;\n\n  MagickBooleanType\n    logging;\n\n  volatile int\n    first_mng_object,\n    object_id,\n    term_chunk_found,\n    skip_to_iend;\n\n  volatile ssize_t\n    image_count=0;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  MngBox\n    default_fb,\n    fb,\n    previous_fb;\n\n#if defined(MNG_INSERT_LAYERS)\n  PixelPacket\n    mng_background_color;\n#endif\n\n  register unsigned char\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    count;\n\n  ssize_t\n    loop_level;\n\n  volatile short\n    skipping_loop;\n\n#if defined(MNG_INSERT_LAYERS)\n  unsigned int\n    mandatory_back=0;\n#endif\n\n  volatile unsigned int\n#ifdef MNG_OBJECT_BUFFERS\n    mng_background_object=0,\n#endif\n    mng_type=0;   /* 0: PNG or JNG; 1: MNG; 2: MNG-LC; 3: MNG-VLC */\n\n  size_t\n    default_frame_timeout,\n    frame_timeout,\n#if defined(MNG_INSERT_LAYERS)\n    image_height,\n    image_width,\n#endif\n    length;\n\n  /* These delays are all measured in image ticks_per_second,\n   * not in MNG ticks_per_second\n   */\n  volatile size_t\n    default_frame_delay,\n    final_delay,\n    final_image_delay,\n    frame_delay,\n#if defined(MNG_INSERT_LAYERS)\n    insert_layers,\n#endif\n    mng_iterations=1,\n    simplicity=0,\n    subframe_height=0,\n    subframe_width=0;\n\n  previous_fb.top=0;\n  previous_fb.bottom=0;\n  previous_fb.left=0;\n  previous_fb.right=0;\n  default_fb.top=0;\n  default_fb.bottom=0;\n  default_fb.left=0;\n  default_fb.right=0;\n\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  Enter ReadOneMNGImage()\");\n\n  image=mng_info->image;\n\n  if (LocaleCompare(image_info->magick,\"MNG\") == 0)\n    {\n      char\n        magic_number[MaxTextExtent];\n\n      /* Verify MNG signature.  */\n      count=(size_t) ReadBlob(image,8,(unsigned char *) magic_number);\n      if (memcmp(magic_number,\"\\212MNG\\r\\n\\032\\n\",8) != 0)\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n      /* Initialize some nonzero members of the MngInfo structure.  */\n      for (i=0; i < MNG_MAX_OBJECTS; i++)\n      {\n        mng_info->object_clip[i].right=(ssize_t) PNG_UINT_31_MAX;\n        mng_info->object_clip[i].bottom=(ssize_t) PNG_UINT_31_MAX;\n      }\n      mng_info->exists[0]=MagickTrue;\n    }\n\n  skipping_loop=(-1);\n  first_mng_object=MagickTrue;\n  mng_type=0;\n#if defined(MNG_INSERT_LAYERS)\n  insert_layers=MagickFalse; /* should be False when converting or mogrifying */\n#endif\n  default_frame_delay=0;\n  default_frame_timeout=0;\n  frame_delay=0;\n  final_delay=1;\n  mng_info->ticks_per_second=1UL*image->ticks_per_second;\n  object_id=0;\n  skip_to_iend=MagickFalse;\n  term_chunk_found=MagickFalse;\n  mng_info->framing_mode=1;\n#if defined(MNG_INSERT_LAYERS)\n  mandatory_back=MagickFalse;\n#endif\n#if defined(MNG_INSERT_LAYERS)\n  mng_background_color=image->background_color;\n#endif\n  default_fb=mng_info->frame;\n  previous_fb=mng_info->frame;\n  do\n  {\n    char\n      type[MaxTextExtent];\n\n    if (LocaleCompare(image_info->magick,\"MNG\") == 0)\n      {\n        unsigned char\n          *chunk;\n\n        /*\n          Read a new chunk.\n        */\n        type[0]='\\0';\n        (void) ConcatenateMagickString(type,\"errr\",MaxTextExtent);\n        length=ReadBlobMSBLong(image);\n        count=(size_t) ReadBlob(image,4,(unsigned char *) type);\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n           \"  Reading MNG chunk type %c%c%c%c, length: %.20g\",\n           type[0],type[1],type[2],type[3],(double) length);\n\n        if (length > PNG_UINT_31_MAX)\n          {\n            status=MagickFalse;\n            break;\n          }\n\n        if (count == 0)\n          ThrowReaderException(CorruptImageError,\"CorruptImage\");\n\n        p=NULL;\n        chunk=(unsigned char *) NULL;\n\n        if (length != 0)\n          {\n            chunk=(unsigned char *) AcquireQuantumMemory(length+\n              MagickPathExtent,sizeof(*chunk));\n\n            if (chunk == (unsigned char *) NULL)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n            for (i=0; i < (ssize_t) length; i++)\n            {\n              int\n                c;\n\n              c=ReadBlobByte(image);\n              if (c == EOF)\n                break;\n              chunk[i]=(unsigned char) c;\n            }\n\n            p=chunk;\n          }\n\n        (void) ReadBlobMSBLong(image);  /* read crc word */\n\n#if !defined(JNG_SUPPORTED)\n        if (memcmp(type,mng_JHDR,4) == 0)\n          {\n            skip_to_iend=MagickTrue;\n\n            if (mng_info->jhdr_warning == 0)\n              (void) ThrowMagickException(&image->exception,GetMagickModule(),\n                CoderError,\"JNGCompressNotSupported\",\"`%s'\",image->filename);\n\n            mng_info->jhdr_warning++;\n          }\n#endif\n        if (memcmp(type,mng_DHDR,4) == 0)\n          {\n            skip_to_iend=MagickTrue;\n\n            if (mng_info->dhdr_warning == 0)\n              (void) ThrowMagickException(&image->exception,GetMagickModule(),\n                CoderError,\"DeltaPNGNotSupported\",\"`%s'\",image->filename);\n\n            mng_info->dhdr_warning++;\n          }\n        if (memcmp(type,mng_MEND,4) == 0)\n          break;\n\n        if (skip_to_iend)\n          {\n            if (memcmp(type,mng_IEND,4) == 0)\n              skip_to_iend=MagickFalse;\n\n            if (length != 0)\n              chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Skip to IEND.\");\n\n            continue;\n          }\n\n        if (memcmp(type,mng_MHDR,4) == 0)\n          {\n            if (length != 28)\n              {\n                chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n                ThrowReaderException(CorruptImageError,\"CorruptImage\");\n              }\n\n            mng_info->mng_width=(size_t) ((p[0] << 24) | (p[1] << 16) |\n                (p[2] << 8) | p[3]);\n\n            mng_info->mng_height=(size_t) ((p[4] << 24) | (p[5] << 16) |\n                (p[6] << 8) | p[7]);\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  MNG width: %.20g\",(double) mng_info->mng_width);\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  MNG height: %.20g\",(double) mng_info->mng_height);\n              }\n\n            p+=8;\n            mng_info->ticks_per_second=(size_t) mng_get_long(p);\n\n            if (mng_info->ticks_per_second == 0)\n              default_frame_delay=0;\n\n            else\n              default_frame_delay=1UL*image->ticks_per_second/\n                mng_info->ticks_per_second;\n\n            frame_delay=default_frame_delay;\n            simplicity=0;\n\n            /* Skip nominal layer count, frame count, and play time */\n            p+=16;\n            simplicity=(size_t) mng_get_long(p);\n\n            mng_type=1;    /* Full MNG */\n\n            if ((simplicity != 0) && ((simplicity | 11) == 11))\n              mng_type=2; /* LC */\n\n            if ((simplicity != 0) && ((simplicity | 9) == 9))\n              mng_type=3; /* VLC */\n\n#if defined(MNG_INSERT_LAYERS)\n            if (mng_type != 3)\n              insert_layers=MagickTrue;\n#endif\n            if (GetAuthenticPixelQueue(image) != (PixelPacket *) NULL)\n              {\n                /* Allocate next image structure.  */\n                AcquireNextImage(image_info,image);\n\n                if (GetNextImageInList(image) == (Image *) NULL)\n                  return(DestroyImageList(image));\n\n                image=SyncNextImageInList(image);\n                mng_info->image=image;\n              }\n\n            if ((mng_info->mng_width > 65535L) ||\n                (mng_info->mng_height > 65535L))\n              {\n                chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n                ThrowReaderException(ImageError,\"WidthOrHeightExceedsLimit\");\n              }\n\n            (void) FormatLocaleString(page_geometry,MaxTextExtent,\n              \"%.20gx%.20g+0+0\",(double) mng_info->mng_width,(double)\n              mng_info->mng_height);\n\n            mng_info->frame.left=0;\n            mng_info->frame.right=(ssize_t) mng_info->mng_width;\n            mng_info->frame.top=0;\n            mng_info->frame.bottom=(ssize_t) mng_info->mng_height;\n            mng_info->clip=default_fb=previous_fb=mng_info->frame;\n\n            for (i=0; i < MNG_MAX_OBJECTS; i++)\n              mng_info->object_clip[i]=mng_info->frame;\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_TERM,4) == 0)\n          {\n            int\n              repeat=0;\n\n            if (length != 0)\n              repeat=p[0];\n\n            if (repeat == 3 && length > 8)\n              {\n                final_delay=(png_uint_32) mng_get_long(&p[2]);\n                mng_iterations=(png_uint_32) mng_get_long(&p[6]);\n\n                if (mng_iterations == PNG_UINT_31_MAX)\n                  mng_iterations=0;\n\n                image->iterations=mng_iterations;\n                term_chunk_found=MagickTrue;\n              }\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    repeat=%d,  final_delay=%.20g,  iterations=%.20g\",\n                  repeat,(double) final_delay, (double) image->iterations);\n              }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n        if (memcmp(type,mng_DEFI,4) == 0)\n          {\n            if (mng_type == 3)\n              (void) ThrowMagickException(&image->exception,GetMagickModule(),\n                CoderError,\"DEFI chunk found in MNG-VLC datastream\",\"`%s'\",\n                image->filename);\n\n            if (length > 1)\n              {\n                object_id=(p[0] << 8) | p[1];\n\n                if (mng_type == 2 && object_id != 0)\n                  (void) ThrowMagickException(&image->exception,\n                     GetMagickModule(),\n                     CoderError,\"Nonzero object_id in MNG-LC datastream\",\n                     \"`%s'\", image->filename);\n\n                if (object_id > MNG_MAX_OBJECTS)\n                  {\n                    /*\n                      Instead of using a warning we should allocate a larger\n                      MngInfo structure and continue.\n                    */\n                    (void) ThrowMagickException(&image->exception,\n                        GetMagickModule(), CoderError,\n                        \"object id too large\",\"`%s'\",image->filename);\n                        object_id=MNG_MAX_OBJECTS;\n                  }\n\n                if (mng_info->exists[object_id])\n                  if (mng_info->frozen[object_id])\n                    {\n                      chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n                      (void) ThrowMagickException(&image->exception,\n                        GetMagickModule(),CoderError,\n                        \"DEFI cannot redefine a frozen MNG object\",\"`%s'\",\n                        image->filename);\n                      continue;\n                    }\n\n                mng_info->exists[object_id]=MagickTrue;\n\n                if (length > 2)\n                  mng_info->invisible[object_id]=p[2];\n\n                /*\n                  Extract object offset info.\n                */\n                if (length > 11)\n                  {\n                    mng_info->x_off[object_id]=(ssize_t) ((p[4] << 24) |\n                        (p[5] << 16) | (p[6] << 8) | p[7]);\n\n                    mng_info->y_off[object_id]=(ssize_t) ((p[8] << 24) |\n                        (p[9] << 16) | (p[10] << 8) | p[11]);\n\n                    if (logging != MagickFalse)\n                      {\n                        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                          \"  x_off[%d]: %.20g,  y_off[%d]: %.20g\",\n                          object_id,(double) mng_info->x_off[object_id],\n                          object_id,(double) mng_info->y_off[object_id]);\n                      }\n                  }\n\n                /*\n                  Extract object clipping info.\n                */\n            \n                if (length > 27)\n                  mng_info->object_clip[object_id]=\n                    mng_read_box(mng_info->frame,0, &p[12]);\n            }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n        if (memcmp(type,mng_bKGD,4) == 0)\n          {\n            mng_info->have_global_bkgd=MagickFalse;\n\n            if (length > 5)\n              {\n                mng_info->mng_global_bkgd.red=\n                  ScaleShortToQuantum((unsigned short) ((p[0] << 8) | p[1]));\n\n                mng_info->mng_global_bkgd.green=\n                  ScaleShortToQuantum((unsigned short) ((p[2] << 8) | p[3]));\n\n                mng_info->mng_global_bkgd.blue=\n                  ScaleShortToQuantum((unsigned short) ((p[4] << 8) | p[5]));\n\n                mng_info->have_global_bkgd=MagickTrue;\n              }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n        if (memcmp(type,mng_BACK,4) == 0)\n          {\n#if defined(MNG_INSERT_LAYERS)\n            if (length > 6)\n              mandatory_back=p[6];\n\n            else\n              mandatory_back=0;\n\n            if (mandatory_back && length > 5)\n              {\n                mng_background_color.red=\n                    ScaleShortToQuantum((unsigned short) ((p[0] << 8) | p[1]));\n\n                mng_background_color.green=\n                    ScaleShortToQuantum((unsigned short) ((p[2] << 8) | p[3]));\n\n                mng_background_color.blue=\n                    ScaleShortToQuantum((unsigned short) ((p[4] << 8) | p[5]));\n\n                mng_background_color.opacity=OpaqueOpacity;\n              }\n\n#ifdef MNG_OBJECT_BUFFERS\n            if (length > 8)\n              mng_background_object=(p[7] << 8) | p[8];\n#endif\n#endif\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_PLTE,4) == 0)\n          {\n            /* Read global PLTE.  */\n\n            if (length && (length < 769))\n              {\n                if (mng_info->global_plte == (png_colorp) NULL)\n                  mng_info->global_plte=(png_colorp) AcquireQuantumMemory(256,\n                    sizeof(*mng_info->global_plte));\n\n                for (i=0; i < (ssize_t) (length/3); i++)\n                {\n                  mng_info->global_plte[i].red=p[3*i];\n                  mng_info->global_plte[i].green=p[3*i+1];\n                  mng_info->global_plte[i].blue=p[3*i+2];\n                }\n\n                mng_info->global_plte_length=(unsigned int) (length/3);\n              }\n#ifdef MNG_LOOSE\n            for ( ; i < 256; i++)\n            {\n              mng_info->global_plte[i].red=i;\n              mng_info->global_plte[i].green=i;\n              mng_info->global_plte[i].blue=i;\n            }\n\n            if (length != 0)\n              mng_info->global_plte_length=256;\n#endif\n            else\n              mng_info->global_plte_length=0;\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_tRNS,4) == 0)\n          {\n            /* read global tRNS */\n\n            if (length > 0 && length < 257)\n              for (i=0; i < (ssize_t) length; i++)\n                mng_info->global_trns[i]=p[i];\n\n#ifdef MNG_LOOSE\n            for ( ; i < 256; i++)\n              mng_info->global_trns[i]=255;\n#endif\n            mng_info->global_trns_length=(unsigned int) length;\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n        if (memcmp(type,mng_gAMA,4) == 0)\n          {\n            if (length == 4)\n              {\n                ssize_t\n                  igamma;\n\n                igamma=mng_get_long(p);\n                mng_info->global_gamma=((float) igamma)*0.00001;\n                mng_info->have_global_gama=MagickTrue;\n              }\n\n            else\n              mng_info->have_global_gama=MagickFalse;\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_cHRM,4) == 0)\n          {\n            /* Read global cHRM */\n\n            if (length == 32)\n              {\n                mng_info->global_chrm.white_point.x=0.00001*mng_get_long(p);\n                mng_info->global_chrm.white_point.y=0.00001*mng_get_long(&p[4]);\n                mng_info->global_chrm.red_primary.x=0.00001*mng_get_long(&p[8]);\n                mng_info->global_chrm.red_primary.y=0.00001*\n                  mng_get_long(&p[12]);\n                mng_info->global_chrm.green_primary.x=0.00001*\n                  mng_get_long(&p[16]);\n                mng_info->global_chrm.green_primary.y=0.00001*\n                  mng_get_long(&p[20]);\n                mng_info->global_chrm.blue_primary.x=0.00001*\n                  mng_get_long(&p[24]);\n                mng_info->global_chrm.blue_primary.y=0.00001*\n                  mng_get_long(&p[28]);\n                mng_info->have_global_chrm=MagickTrue;\n              }\n            else\n              mng_info->have_global_chrm=MagickFalse;\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_sRGB,4) == 0)\n          {\n            /*\n              Read global sRGB.\n            */\n            if (length != 0)\n              {\n                mng_info->global_srgb_intent=\n                  Magick_RenderingIntent_from_PNG_RenderingIntent(p[0]);\n                mng_info->have_global_srgb=MagickTrue;\n              }\n            else\n              mng_info->have_global_srgb=MagickFalse;\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_iCCP,4) == 0)\n          {\n            /* To do: */\n\n            /*\n              Read global iCCP.\n            */\n            if (length != 0)\n              chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            continue;\n          }\n\n        if (memcmp(type,mng_FRAM,4) == 0)\n          {\n            if (mng_type == 3)\n              (void) ThrowMagickException(&image->exception,GetMagickModule(),\n                CoderError,\"FRAM chunk found in MNG-VLC datastream\",\"`%s'\",\n                image->filename);\n\n            if ((mng_info->framing_mode == 2) || (mng_info->framing_mode == 4))\n              image->delay=frame_delay;\n\n            frame_delay=default_frame_delay;\n            frame_timeout=default_frame_timeout;\n            fb=default_fb;\n\n            if (length > 0)\n              if (p[0])\n                mng_info->framing_mode=p[0];\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Framing_mode=%d\",mng_info->framing_mode);\n\n            if (length > 6)\n              {\n                /* Note the delay and frame clipping boundaries.  */\n\n                p++; /* framing mode */\n\n                while (*p && ((p-chunk) < (ssize_t) length))\n                  p++;  /* frame name */\n\n                p++;  /* frame name terminator */\n\n                if ((p-chunk) < (ssize_t) (length-4))\n                  {\n                    int\n                      change_delay,\n                      change_timeout,\n                      change_clipping;\n\n                    change_delay=(*p++);\n                    change_timeout=(*p++);\n                    change_clipping=(*p++);\n                    p++; /* change_sync */\n\n                    if (change_delay && (p-chunk) < (ssize_t) (length-4))\n                      {\n                          frame_delay=1UL*image->ticks_per_second*\n                            mng_get_long(p);\n\n                        if (mng_info->ticks_per_second != 0)\n                          frame_delay/=mng_info->ticks_per_second;\n\n                        else\n                          frame_delay=PNG_UINT_31_MAX;\n\n                        if (change_delay == 2)\n                          default_frame_delay=frame_delay;\n\n                        p+=4;\n\n                        if (logging != MagickFalse)\n                          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                            \"    Framing_delay=%.20g\",(double) frame_delay);\n                      }\n\n                    if (change_timeout && (p-chunk) < (ssize_t) (length-4))\n                      {\n                        frame_timeout=1UL*image->ticks_per_second*\n                          mng_get_long(p);\n\n                        if (mng_info->ticks_per_second != 0)\n                          frame_timeout/=mng_info->ticks_per_second;\n\n                        else\n                          frame_timeout=PNG_UINT_31_MAX;\n\n                        if (change_timeout == 2)\n                          default_frame_timeout=frame_timeout;\n\n                        p+=4;\n\n                        if (logging != MagickFalse)\n                          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                            \"    Framing_timeout=%.20g\",(double) frame_timeout);\n                      }\n\n                    if (change_clipping && (p-chunk) < (ssize_t) (length-17))\n                      {\n                        fb=mng_read_box(previous_fb,(char) p[0],&p[1]);\n                        p+=17;\n                        previous_fb=fb;\n\n                        if (logging != MagickFalse)\n                          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                            \"    Frame_clip: L=%.20g R=%.20g T=%.20g B=%.20g\",\n                            (double) fb.left,(double) fb.right,(double) fb.top,\n                            (double) fb.bottom);\n\n                        if (change_clipping == 2)\n                          default_fb=fb;\n                      }\n                  }\n              }\n            mng_info->clip=fb;\n            mng_info->clip=mng_minimum_box(fb,mng_info->frame);\n\n            subframe_width=(size_t) (mng_info->clip.right\n               -mng_info->clip.left);\n\n            subframe_height=(size_t) (mng_info->clip.bottom\n               -mng_info->clip.top);\n            /*\n              Insert a background layer behind the frame if framing_mode is 4.\n            */\n#if defined(MNG_INSERT_LAYERS)\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"   subframe_width=%.20g, subframe_height=%.20g\",(double)\n                subframe_width,(double) subframe_height);\n\n            if (insert_layers && (mng_info->framing_mode == 4) &&\n                (subframe_width) && (subframe_height))\n              {\n                /* Allocate next image structure.  */\n                if (GetAuthenticPixelQueue(image) != (PixelPacket *) NULL)\n                  {\n                    AcquireNextImage(image_info,image);\n\n                    if (GetNextImageInList(image) == (Image *) NULL)\n                      return(DestroyImageList(image));\n\n                    image=SyncNextImageInList(image);\n                  }\n\n                mng_info->image=image;\n\n                if (term_chunk_found)\n                  {\n                    image->start_loop=MagickTrue;\n                    image->iterations=mng_iterations;\n                    term_chunk_found=MagickFalse;\n                  }\n\n                else\n                    image->start_loop=MagickFalse;\n\n                image->columns=subframe_width;\n                image->rows=subframe_height;\n                image->page.width=subframe_width;\n                image->page.height=subframe_height;\n                image->page.x=mng_info->clip.left;\n                image->page.y=mng_info->clip.top;\n                image->background_color=mng_background_color;\n                image->matte=MagickFalse;\n                image->delay=0;\n                (void) SetImageBackgroundColor(image);\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  Insert backgd layer, L=%.20g, R=%.20g T=%.20g, B=%.20g\",\n                    (double) mng_info->clip.left,(double) mng_info->clip.right,\n                    (double) mng_info->clip.top,(double) mng_info->clip.bottom);\n              }\n#endif\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n        if (memcmp(type,mng_CLIP,4) == 0)\n          {\n            unsigned int\n              first_object,\n              last_object;\n\n            /*\n              Read CLIP.\n            */\n            if (length > 3)\n              {\n                first_object=(p[0] << 8) | p[1];\n                last_object=(p[2] << 8) | p[3];\n                p+=4;\n\n                for (i=(int) first_object; i <= (int) last_object; i++)\n                {\n                  if (mng_info->exists[i] && !mng_info->frozen[i])\n                    {\n                      MngBox\n                        box;\n\n                      box=mng_info->object_clip[i];\n                      if ((p-chunk) < (ssize_t) (length-17))\n                        mng_info->object_clip[i]=\n                           mng_read_box(box,(char) p[0],&p[1]);\n                    }\n                }\n\n              }\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n        if (memcmp(type,mng_SAVE,4) == 0)\n          {\n            for (i=1; i < MNG_MAX_OBJECTS; i++)\n              if (mng_info->exists[i])\n                {\n                 mng_info->frozen[i]=MagickTrue;\n#ifdef MNG_OBJECT_BUFFERS\n                 if (mng_info->ob[i] != (MngBuffer *) NULL)\n                    mng_info->ob[i]->frozen=MagickTrue;\n#endif\n                }\n\n            if (length != 0)\n              chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            continue;\n          }\n\n        if ((memcmp(type,mng_DISC,4) == 0) || (memcmp(type,mng_SEEK,4) == 0))\n          {\n            /* Read DISC or SEEK.  */\n\n            if ((length == 0) || !memcmp(type,mng_SEEK,4))\n              {\n                for (i=1; i < MNG_MAX_OBJECTS; i++)\n                  MngInfoDiscardObject(mng_info,i);\n              }\n\n            else\n              {\n                register ssize_t\n                  j;\n\n                for (j=1; j < (ssize_t) length; j+=2)\n                {\n                  i=p[j-1] << 8 | p[j];\n                  MngInfoDiscardObject(mng_info,i);\n                }\n              }\n\n            if (length != 0)\n              chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            continue;\n          }\n\n        if (memcmp(type,mng_MOVE,4) == 0)\n          {\n            size_t\n              first_object,\n              last_object;\n\n            /* read MOVE */\n\n            if (length > 3)\n            {\n              first_object=(p[0] << 8) | p[1];\n              last_object=(p[2] << 8) | p[3];\n              p+=4;\n \n               for (i=(ssize_t) first_object; i <= (ssize_t) last_object; i++)\n               {\n                 if (mng_info->exists[i] && !mng_info->frozen[i] &&\n                     (p-chunk) < (ssize_t) (length-8))\n                   {\n                    MngPair\n                      new_pair;\n\n                    MngPair\n                      old_pair;\n\n                    old_pair.a=mng_info->x_off[i];\n                    old_pair.b=mng_info->y_off[i];\n                    new_pair=mng_read_pair(old_pair,(int) p[0],&p[1]);\n                    mng_info->x_off[i]=new_pair.a;\n                    mng_info->y_off[i]=new_pair.b;\n                  }\n              }\n            }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_LOOP,4) == 0)\n          {\n            ssize_t loop_iters=1;\n            if (length > 4)\n              {\n                loop_level=chunk[0];\n                mng_info->loop_active[loop_level]=1;  /* mark loop active */\n\n                /* Record starting point.  */\n                loop_iters=mng_get_long(&chunk[1]);\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  LOOP level %.20g has %.20g iterations \",\n                    (double) loop_level, (double) loop_iters);\n\n                if (loop_iters == 0)\n                  skipping_loop=loop_level;\n\n                else\n                  {\n                    mng_info->loop_jump[loop_level]=TellBlob(image);\n                    mng_info->loop_count[loop_level]=loop_iters;\n                  }\n\n                mng_info->loop_iteration[loop_level]=0;\n              }\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_ENDL,4) == 0)\n          {\n            if (length > 0)\n              {\n                loop_level=chunk[0];\n\n                if (skipping_loop > 0)\n                  {\n                    if (skipping_loop == loop_level)\n                      {\n                        /*\n                          Found end of zero-iteration loop.\n                        */\n                        skipping_loop=(-1);\n                        mng_info->loop_active[loop_level]=0;\n                      }\n                  }\n\n                else\n                  {\n                    if (mng_info->loop_active[loop_level] == 1)\n                      {\n                        mng_info->loop_count[loop_level]--;\n                        mng_info->loop_iteration[loop_level]++;\n\n                        if (logging != MagickFalse)\n                          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                          \"  ENDL: LOOP level %.20g has %.20g remaining iters \",\n                            (double) loop_level,(double)\n                            mng_info->loop_count[loop_level]);\n\n                        if (mng_info->loop_count[loop_level] != 0)\n                          {\n                            offset=SeekBlob(image,\n                              mng_info->loop_jump[loop_level], SEEK_SET);\n\n                            if (offset < 0)\n                              {\n                                chunk=(unsigned char *) RelinquishMagickMemory(\n                                  chunk);\n                                ThrowReaderException(CorruptImageError,\n                                  \"ImproperImageHeader\");\n                              }\n                          }\n\n                        else\n                          {\n                            short\n                              last_level;\n\n                            /*\n                              Finished loop.\n                            */\n                            mng_info->loop_active[loop_level]=0;\n                            last_level=(-1);\n                            for (i=0; i < loop_level; i++)\n                              if (mng_info->loop_active[i] == 1)\n                                last_level=(short) i;\n                            loop_level=last_level;\n                          }\n                      }\n                  }\n              }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_CLON,4) == 0)\n          {\n            if (mng_info->clon_warning == 0)\n              (void) ThrowMagickException(&image->exception,GetMagickModule(),\n                CoderError,\"CLON is not implemented yet\",\"`%s'\",\n                image->filename);\n\n            mng_info->clon_warning++;\n          }\n\n        if (memcmp(type,mng_MAGN,4) == 0)\n          {\n            png_uint_16\n              magn_first,\n              magn_last,\n              magn_mb,\n              magn_ml,\n              magn_mr,\n              magn_mt,\n              magn_mx,\n              magn_my,\n              magn_methx,\n              magn_methy;\n\n            if (length > 1)\n              magn_first=(p[0] << 8) | p[1];\n\n            else\n              magn_first=0;\n\n            if (length > 3)\n              magn_last=(p[2] << 8) | p[3];\n\n            else\n              magn_last=magn_first;\n#ifndef MNG_OBJECT_BUFFERS\n            if (magn_first || magn_last)\n              if (mng_info->magn_warning == 0)\n                {\n                  (void) ThrowMagickException(&image->exception,\n                     GetMagickModule(),CoderError,\n                     \"MAGN is not implemented yet for nonzero objects\",\n                     \"`%s'\",image->filename);\n\n                   mng_info->magn_warning++;\n                }\n#endif\n            if (length > 4)\n              magn_methx=p[4];\n\n            else\n              magn_methx=0;\n\n            if (length > 6)\n              magn_mx=(p[5] << 8) | p[6];\n\n            else\n              magn_mx=1;\n\n            if (magn_mx == 0)\n              magn_mx=1;\n\n            if (length > 8)\n              magn_my=(p[7] << 8) | p[8];\n\n            else\n              magn_my=magn_mx;\n\n            if (magn_my == 0)\n              magn_my=1;\n\n            if (length > 10)\n              magn_ml=(p[9] << 8) | p[10];\n\n            else\n              magn_ml=magn_mx;\n\n            if (magn_ml == 0)\n              magn_ml=1;\n\n            if (length > 12)\n              magn_mr=(p[11] << 8) | p[12];\n\n            else\n              magn_mr=magn_mx;\n\n            if (magn_mr == 0)\n              magn_mr=1;\n\n            if (length > 14)\n              magn_mt=(p[13] << 8) | p[14];\n\n            else\n              magn_mt=magn_my;\n\n            if (magn_mt == 0)\n              magn_mt=1;\n\n            if (length > 16)\n              magn_mb=(p[15] << 8) | p[16];\n\n            else\n              magn_mb=magn_my;\n\n            if (magn_mb == 0)\n              magn_mb=1;\n\n            if (length > 17)\n              magn_methy=p[17];\n\n            else\n              magn_methy=magn_methx;\n\n\n            if (magn_methx > 5 || magn_methy > 5)\n              if (mng_info->magn_warning == 0)\n                {\n                  (void) ThrowMagickException(&image->exception,\n                     GetMagickModule(),CoderError,\n                     \"Unknown MAGN method in MNG datastream\",\"`%s'\",\n                     image->filename);\n\n                   mng_info->magn_warning++;\n                }\n#ifdef MNG_OBJECT_BUFFERS\n          /* Magnify existing objects in the range magn_first to magn_last */\n#endif\n            if (magn_first == 0 || magn_last == 0)\n              {\n                /* Save the magnification factors for object 0 */\n                mng_info->magn_mb=magn_mb;\n                mng_info->magn_ml=magn_ml;\n                mng_info->magn_mr=magn_mr;\n                mng_info->magn_mt=magn_mt;\n                mng_info->magn_mx=magn_mx;\n                mng_info->magn_my=magn_my;\n                mng_info->magn_methx=magn_methx;\n                mng_info->magn_methy=magn_methy;\n              }\n          }\n\n        if (memcmp(type,mng_PAST,4) == 0)\n          {\n            if (mng_info->past_warning == 0)\n              (void) ThrowMagickException(&image->exception,GetMagickModule(),\n                CoderError,\"PAST is not implemented yet\",\"`%s'\",\n                image->filename);\n\n            mng_info->past_warning++;\n          }\n\n        if (memcmp(type,mng_SHOW,4) == 0)\n          {\n            if (mng_info->show_warning == 0)\n              (void) ThrowMagickException(&image->exception,GetMagickModule(),\n                CoderError,\"SHOW is not implemented yet\",\"`%s'\",\n                image->filename);\n\n            mng_info->show_warning++;\n          }\n\n        if (memcmp(type,mng_sBIT,4) == 0)\n          {\n            if (length < 4)\n              mng_info->have_global_sbit=MagickFalse;\n\n            else\n              {\n                mng_info->global_sbit.gray=p[0];\n                mng_info->global_sbit.red=p[0];\n                mng_info->global_sbit.green=p[1];\n                mng_info->global_sbit.blue=p[2];\n                mng_info->global_sbit.alpha=p[3];\n                mng_info->have_global_sbit=MagickTrue;\n             }\n          }\n        if (memcmp(type,mng_pHYs,4) == 0)\n          {\n            if (length > 8)\n              {\n                mng_info->global_x_pixels_per_unit=\n                    (size_t) mng_get_long(p);\n                mng_info->global_y_pixels_per_unit=\n                    (size_t) mng_get_long(&p[4]);\n                mng_info->global_phys_unit_type=p[8];\n                mng_info->have_global_phys=MagickTrue;\n              }\n\n            else\n              mng_info->have_global_phys=MagickFalse;\n          }\n        if (memcmp(type,mng_pHYg,4) == 0)\n          {\n            if (mng_info->phyg_warning == 0)\n              (void) ThrowMagickException(&image->exception,GetMagickModule(),\n                CoderError,\"pHYg is not implemented.\",\"`%s'\",image->filename);\n\n            mng_info->phyg_warning++;\n          }\n        if (memcmp(type,mng_BASI,4) == 0)\n          {\n            skip_to_iend=MagickTrue;\n\n            if (mng_info->basi_warning == 0)\n              (void) ThrowMagickException(&image->exception,GetMagickModule(),\n                CoderError,\"BASI is not implemented yet\",\"`%s'\",\n                image->filename);\n\n            mng_info->basi_warning++;\n#ifdef MNG_BASI_SUPPORTED\n            if (length > 11)\n              {\n                basi_width=(size_t) ((p[0] << 24) | (p[1] << 16) |\n                   (p[2] << 8) | p[3]);\n                basi_height=(size_t) ((p[4] << 24) | (p[5] << 16) |\n                   (p[6] << 8) | p[7]);\n                basi_color_type=p[8];\n                basi_compression_method=p[9];\n                basi_filter_type=p[10];\n                basi_interlace_method=p[11];\n              }\n            if (length > 13)\n              basi_red=(p[12] << 8) & p[13];\n\n            else\n              basi_red=0;\n\n            if (length > 15)\n              basi_green=(p[14] << 8) & p[15];\n\n            else\n              basi_green=0;\n\n            if (length > 17)\n              basi_blue=(p[16] << 8) & p[17];\n\n            else\n              basi_blue=0;\n\n            if (length > 19)\n              basi_alpha=(p[18] << 8) & p[19];\n\n            else\n              {\n                if (basi_sample_depth == 16)\n                  basi_alpha=65535L;\n                else\n                  basi_alpha=255;\n              }\n\n            if (length > 20)\n              basi_viewable=p[20];\n\n            else\n              basi_viewable=0;\n\n#endif\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_IHDR,4)\n#if defined(JNG_SUPPORTED)\n            && memcmp(type,mng_JHDR,4)\n#endif\n            )\n          {\n            /* Not an IHDR or JHDR chunk */\n            if (length != 0)\n              chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            continue;\n          }\n/* Process IHDR */\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Processing %c%c%c%c chunk\",type[0],type[1],type[2],type[3]);\n\n        mng_info->exists[object_id]=MagickTrue;\n        mng_info->viewable[object_id]=MagickTrue;\n\n        if (mng_info->invisible[object_id])\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Skipping invisible object\");\n\n            skip_to_iend=MagickTrue;\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n#if defined(MNG_INSERT_LAYERS)\n        if (length < 8)\n          {\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n          }\n\n        image_width=(size_t) mng_get_long(p);\n        image_height=(size_t) mng_get_long(&p[4]);\n#endif\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        /*\n          Insert a transparent background layer behind the entire animation\n          if it is not full screen.\n        */\n#if defined(MNG_INSERT_LAYERS)\n        if (insert_layers && mng_type && first_mng_object)\n          {\n            if ((mng_info->clip.left > 0) || (mng_info->clip.top > 0) ||\n                (image_width < mng_info->mng_width) ||\n                (mng_info->clip.right < (ssize_t) mng_info->mng_width) ||\n                (image_height < mng_info->mng_height) ||\n                (mng_info->clip.bottom < (ssize_t) mng_info->mng_height))\n              {\n                if (GetAuthenticPixelQueue(image) != (PixelPacket *) NULL)\n                  {\n                    /*\n                      Allocate next image structure.\n                    */\n                    AcquireNextImage(image_info,image);\n\n                    if (GetNextImageInList(image) == (Image *) NULL)\n                      return(DestroyImageList(image));\n\n                    image=SyncNextImageInList(image);\n                  }\n                mng_info->image=image;\n\n                if (term_chunk_found)\n                  {\n                    image->start_loop=MagickTrue;\n                    image->iterations=mng_iterations;\n                    term_chunk_found=MagickFalse;\n                  }\n\n                else\n                    image->start_loop=MagickFalse;\n\n                /* Make a background rectangle.  */\n\n                image->delay=0;\n                image->columns=mng_info->mng_width;\n                image->rows=mng_info->mng_height;\n                image->page.width=mng_info->mng_width;\n                image->page.height=mng_info->mng_height;\n                image->page.x=0;\n                image->page.y=0;\n                image->background_color=mng_background_color;\n                (void) SetImageBackgroundColor(image);\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  Inserted transparent background layer, W=%.20g, H=%.20g\",\n                    (double) mng_info->mng_width,(double) mng_info->mng_height);\n              }\n          }\n        /*\n          Insert a background layer behind the upcoming image if\n          framing_mode is 3, and we haven't already inserted one.\n        */\n        if (insert_layers && (mng_info->framing_mode == 3) &&\n                (subframe_width) && (subframe_height) && (simplicity == 0 ||\n                (simplicity & 0x08)))\n          {\n            if (GetAuthenticPixelQueue(image) != (PixelPacket *) NULL)\n            {\n              /*\n                Allocate next image structure.\n              */\n              AcquireNextImage(image_info,image);\n\n              if (GetNextImageInList(image) == (Image *) NULL)\n                return(DestroyImageList(image));\n\n              image=SyncNextImageInList(image);\n            }\n\n            mng_info->image=image;\n\n            if (term_chunk_found)\n              {\n                image->start_loop=MagickTrue;\n                image->iterations=mng_iterations;\n                term_chunk_found=MagickFalse;\n              }\n\n            else\n                image->start_loop=MagickFalse;\n\n            image->delay=0;\n            image->columns=subframe_width;\n            image->rows=subframe_height;\n            image->page.width=subframe_width;\n            image->page.height=subframe_height;\n            image->page.x=mng_info->clip.left;\n            image->page.y=mng_info->clip.top;\n            image->background_color=mng_background_color;\n            image->matte=MagickFalse;\n            (void) SetImageBackgroundColor(image);\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Insert background layer, L=%.20g, R=%.20g T=%.20g, B=%.20g\",\n                (double) mng_info->clip.left,(double) mng_info->clip.right,\n                (double) mng_info->clip.top,(double) mng_info->clip.bottom);\n          }\n#endif /* MNG_INSERT_LAYERS */\n        first_mng_object=MagickFalse;\n\n        if (GetAuthenticPixelQueue(image) != (PixelPacket *) NULL)\n          {\n            /*\n              Allocate next image structure.\n            */\n            AcquireNextImage(image_info,image);\n\n            if (GetNextImageInList(image) == (Image *) NULL)\n              return(DestroyImageList(image));\n\n            image=SyncNextImageInList(image);\n          }\n        mng_info->image=image;\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n\n        if (status == MagickFalse)\n          break;\n\n        if (term_chunk_found)\n          {\n            image->start_loop=MagickTrue;\n            term_chunk_found=MagickFalse;\n          }\n\n        else\n            image->start_loop=MagickFalse;\n\n        if (mng_info->framing_mode == 1 || mng_info->framing_mode == 3)\n          {\n            image->delay=frame_delay;\n            frame_delay=default_frame_delay;\n          }\n\n        else\n          image->delay=0;\n\n        image->page.width=mng_info->mng_width;\n        image->page.height=mng_info->mng_height;\n        image->page.x=mng_info->x_off[object_id];\n        image->page.y=mng_info->y_off[object_id];\n        image->iterations=mng_iterations;\n\n        /*\n          Seek back to the beginning of the IHDR or JHDR chunk's length field.\n        */\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Seeking back to beginning of %c%c%c%c chunk\",type[0],type[1],\n            type[2],type[3]);\n\n        offset=SeekBlob(image,-((ssize_t) length+12),SEEK_CUR);\n\n        if (offset < 0)\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n\n    mng_info->image=image;\n    mng_info->mng_type=mng_type;\n    mng_info->object_id=object_id;\n\n    if (memcmp(type,mng_IHDR,4) == 0)\n      image=ReadOnePNGImage(mng_info,image_info,exception);\n\n#if defined(JNG_SUPPORTED)\n    else\n      image=ReadOneJNGImage(mng_info,image_info,exception);\n#endif\n\n    if (image == (Image *) NULL)\n      {\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"exit ReadJNGImage() with error\");\n\n        return((Image *) NULL);\n      }\n\n    if (image->columns == 0 || image->rows == 0)\n      {\n        (void) CloseBlob(image);\n        return(DestroyImageList(image));\n      }\n\n    mng_info->image=image;\n\n    if (mng_type)\n      {\n        MngBox\n          crop_box;\n\n        if (mng_info->magn_methx || mng_info->magn_methy)\n          {\n            png_uint_32\n               magnified_height,\n               magnified_width;\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Processing MNG MAGN chunk\");\n\n            if (mng_info->magn_methx == 1)\n              {\n                magnified_width=mng_info->magn_ml;\n\n                if (image->columns > 1)\n                   magnified_width += mng_info->magn_mr;\n\n                if (image->columns > 2)\n                   magnified_width += (png_uint_32)\n                      ((image->columns-2)*(mng_info->magn_mx));\n              }\n\n            else\n              {\n                magnified_width=(png_uint_32) image->columns;\n\n                if (image->columns > 1)\n                   magnified_width += mng_info->magn_ml-1;\n\n                if (image->columns > 2)\n                   magnified_width += mng_info->magn_mr-1;\n\n                if (image->columns > 3)\n                   magnified_width += (png_uint_32)\n                      ((image->columns-3)*(mng_info->magn_mx-1));\n              }\n\n            if (mng_info->magn_methy == 1)\n              {\n                magnified_height=mng_info->magn_mt;\n\n                if (image->rows > 1)\n                   magnified_height += mng_info->magn_mb;\n\n                if (image->rows > 2)\n                   magnified_height += (png_uint_32)\n                      ((image->rows-2)*(mng_info->magn_my));\n              }\n\n            else\n              {\n                magnified_height=(png_uint_32) image->rows;\n\n                if (image->rows > 1)\n                   magnified_height += mng_info->magn_mt-1;\n\n                if (image->rows > 2)\n                   magnified_height += mng_info->magn_mb-1;\n\n                if (image->rows > 3)\n                   magnified_height += (png_uint_32)\n                      ((image->rows-3)*(mng_info->magn_my-1));\n              }\n\n            if (magnified_height > image->rows ||\n                magnified_width > image->columns)\n              {\n                Image\n                  *large_image;\n\n                int\n                  yy;\n\n                ssize_t\n                  m,\n                  y;\n\n                register ssize_t\n                  x;\n\n                register PixelPacket\n                  *n,\n                  *q;\n\n                PixelPacket\n                  *next,\n                  *prev;\n\n                png_uint_16\n                  magn_methx,\n                  magn_methy;\n\n                /* Allocate next image structure.  */\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Allocate magnified image\");\n\n                AcquireNextImage(image_info,image);\n\n                if (GetNextImageInList(image) == (Image *) NULL)\n                  return(DestroyImageList(image));\n\n                large_image=SyncNextImageInList(image);\n\n                large_image->columns=magnified_width;\n                large_image->rows=magnified_height;\n\n                magn_methx=mng_info->magn_methx;\n                magn_methy=mng_info->magn_methy;\n\n#if (MAGICKCORE_QUANTUM_DEPTH > 16)\n#define QM unsigned short\n                if (magn_methx != 1 || magn_methy != 1)\n                  {\n                  /*\n                     Scale pixels to unsigned shorts to prevent\n                     overflow of intermediate values of interpolations\n                  */\n                     for (y=0; y < (ssize_t) image->rows; y++)\n                     {\n                       q=GetAuthenticPixels(image,0,y,image->columns,1,\n                          exception);\n\n                       for (x=(ssize_t) image->columns-1; x >= 0; x--)\n                       {\n                          SetPixelRed(q,ScaleQuantumToShort(\n                            GetPixelRed(q)));\n                          SetPixelGreen(q,ScaleQuantumToShort(\n                            GetPixelGreen(q)));\n                          SetPixelBlue(q,ScaleQuantumToShort(\n                            GetPixelBlue(q)));\n                          SetPixelOpacity(q,ScaleQuantumToShort(\n                            GetPixelOpacity(q)));\n                          q++;\n                       }\n\n                       if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                         break;\n                     }\n                  }\n#else\n#define QM Quantum\n#endif\n\n                if (image->matte != MagickFalse)\n                   (void) SetImageBackgroundColor(large_image);\n\n                else\n                  {\n                    large_image->background_color.opacity=OpaqueOpacity;\n                    (void) SetImageBackgroundColor(large_image);\n\n                    if (magn_methx == 4)\n                      magn_methx=2;\n\n                    if (magn_methx == 5)\n                      magn_methx=3;\n\n                    if (magn_methy == 4)\n                      magn_methy=2;\n\n                    if (magn_methy == 5)\n                      magn_methy=3;\n                  }\n\n                /* magnify the rows into the right side of the large image */\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Magnify the rows to %.20g\",(double) large_image->rows);\n                m=(ssize_t) mng_info->magn_mt;\n                yy=0;\n                length=(size_t) image->columns;\n                next=(PixelPacket *) AcquireQuantumMemory(length,sizeof(*next));\n                prev=(PixelPacket *) AcquireQuantumMemory(length,sizeof(*prev));\n\n                if ((prev == (PixelPacket *) NULL) ||\n                    (next == (PixelPacket *) NULL))\n                  {\n                     image=DestroyImageList(image);\n                     ThrowReaderException(ResourceLimitError,\n                       \"MemoryAllocationFailed\");\n                  }\n\n                n=GetAuthenticPixels(image,0,0,image->columns,1,exception);\n                (void) CopyMagickMemory(next,n,length);\n\n                for (y=0; y < (ssize_t) image->rows; y++)\n                {\n                  if (y == 0)\n                    m=(ssize_t) mng_info->magn_mt;\n\n                  else if (magn_methy > 1 && y == (ssize_t) image->rows-2)\n                    m=(ssize_t) mng_info->magn_mb;\n\n                  else if (magn_methy <= 1 && y == (ssize_t) image->rows-1)\n                    m=(ssize_t) mng_info->magn_mb;\n\n                  else if (magn_methy > 1 && y == (ssize_t) image->rows-1)\n                    m=1;\n\n                  else\n                    m=(ssize_t) mng_info->magn_my;\n\n                  n=prev;\n                  prev=next;\n                  next=n;\n\n                  if (y < (ssize_t) image->rows-1)\n                    {\n                      n=GetAuthenticPixels(image,0,y+1,image->columns,1,\n                          exception);\n                      (void) CopyMagickMemory(next,n,length);\n                    }\n\n                  for (i=0; i < m; i++, yy++)\n                  {\n                    register PixelPacket\n                      *pixels;\n\n                    assert(yy < (ssize_t) large_image->rows);\n                    pixels=prev;\n                    n=next;\n                    q=GetAuthenticPixels(large_image,0,yy,large_image->columns,\n                      1,exception);\n                    q+=(large_image->columns-image->columns);\n\n                    for (x=(ssize_t) image->columns-1; x >= 0; x--)\n                    {\n                      /* To do: get color as function of indexes[x] */\n                      /*\n                      if (image->storage_class == PseudoClass)\n                        {\n                        }\n                      */\n\n                      if (magn_methy <= 1)\n                        {\n                          /* replicate previous */\n                          SetPixelRGBO(q,(pixels));\n                        }\n\n                      else if (magn_methy == 2 || magn_methy == 4)\n                        {\n                          if (i == 0)\n                            {\n                              SetPixelRGBO(q,(pixels));\n                            }\n\n                          else\n                            {\n                              /* Interpolate */\n                              SetPixelRed(q,\n                                 ((QM) (((ssize_t)\n                                 (2*i*(GetPixelRed(n)\n                                 -GetPixelRed(pixels)+m))/\n                                 ((ssize_t) (m*2))\n                                 +GetPixelRed(pixels)))));\n                              SetPixelGreen(q,\n                                 ((QM) (((ssize_t)\n                                 (2*i*(GetPixelGreen(n)\n                                 -GetPixelGreen(pixels)+m))/\n                                 ((ssize_t) (m*2))\n                                 +GetPixelGreen(pixels)))));\n                              SetPixelBlue(q,\n                                 ((QM) (((ssize_t)\n                                 (2*i*(GetPixelBlue(n)\n                                 -GetPixelBlue(pixels)+m))/\n                                 ((ssize_t) (m*2))\n                                 +GetPixelBlue(pixels)))));\n\n                              if (image->matte != MagickFalse)\n                                 SetPixelOpacity(q,\n                                    ((QM) (((ssize_t)\n                                    (2*i*(GetPixelOpacity(n)\n                                    -GetPixelOpacity(pixels)+m))\n                                    /((ssize_t) (m*2))+\n                                   GetPixelOpacity(pixels)))));\n                            }\n\n                          if (magn_methy == 4)\n                            {\n                              /* Replicate nearest */\n                              if (i <= ((m+1) << 1))\n                                 SetPixelOpacity(q,\n                                 (*pixels).opacity+0);\n                              else\n                                 SetPixelOpacity(q,\n                                 (*n).opacity+0);\n                            }\n                        }\n\n                      else /* if (magn_methy == 3 || magn_methy == 5) */\n                        {\n                          /* Replicate nearest */\n                          if (i <= ((m+1) << 1))\n                          {\n                             SetPixelRGBO(q,(pixels));\n                          }\n\n                          else\n                          {\n                             SetPixelRGBO(q,(n));\n                          }\n\n                          if (magn_methy == 5)\n                            {\n                              SetPixelOpacity(q,\n                                 (QM) (((ssize_t) (2*i*\n                                 (GetPixelOpacity(n)\n                                 -GetPixelOpacity(pixels))\n                                 +m))/((ssize_t) (m*2))\n                                 +GetPixelOpacity(pixels)));\n                            }\n                        }\n                      n++;\n                      q++;\n                      pixels++;\n                    } /* x */\n\n                    if (SyncAuthenticPixels(large_image,exception) == 0)\n                      break;\n\n                  } /* i */\n                } /* y */\n\n                prev=(PixelPacket *) RelinquishMagickMemory(prev);\n                next=(PixelPacket *) RelinquishMagickMemory(next);\n\n                length=image->columns;\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Delete original image\");\n\n                DeleteImageFromList(&image);\n\n                image=large_image;\n\n                mng_info->image=image;\n\n                /* magnify the columns */\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Magnify the columns to %.20g\",(double) image->columns);\n\n                for (y=0; y < (ssize_t) image->rows; y++)\n                {\n                  register PixelPacket\n                    *pixels;\n\n                  q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n                  pixels=q+(image->columns-length);\n                  n=pixels+1;\n\n                  for (x=(ssize_t) (image->columns-length);\n                    x < (ssize_t) image->columns; x++)\n                  {\n                    /* To do: Rewrite using Get/Set***PixelComponent() */\n\n                    if (x == (ssize_t) (image->columns-length))\n                      m=(ssize_t) mng_info->magn_ml;\n\n                    else if (magn_methx > 1 && x == (ssize_t) image->columns-2)\n                      m=(ssize_t) mng_info->magn_mr;\n\n                    else if (magn_methx <= 1 && x == (ssize_t) image->columns-1)\n                      m=(ssize_t) mng_info->magn_mr;\n\n                    else if (magn_methx > 1 && x == (ssize_t) image->columns-1)\n                      m=1;\n\n                    else\n                      m=(ssize_t) mng_info->magn_mx;\n\n                    for (i=0; i < m; i++)\n                    {\n                      if (magn_methx <= 1)\n                        {\n                          /* replicate previous */\n                          SetPixelRGBO(q,(pixels));\n                        }\n\n                      else if (magn_methx == 2 || magn_methx == 4)\n                        {\n                          if (i == 0)\n                          {\n                             SetPixelRGBO(q,(pixels));\n                          }\n\n                          /* To do: Rewrite using Get/Set***PixelComponent() */\n                          else\n                            {\n                              /* Interpolate */\n                              SetPixelRed(q,\n                                 (QM) ((2*i*(\n                                 GetPixelRed(n)\n                                 -GetPixelRed(pixels))+m)\n                                 /((ssize_t) (m*2))+\n                                 GetPixelRed(pixels)));\n\n                              SetPixelGreen(q,\n                                 (QM) ((2*i*(\n                                 GetPixelGreen(n)\n                                 -GetPixelGreen(pixels))+m)\n                                 /((ssize_t) (m*2))+\n                                 GetPixelGreen(pixels)));\n\n                              SetPixelBlue(q,\n                                 (QM) ((2*i*(\n                                 GetPixelBlue(n)\n                                 -GetPixelBlue(pixels))+m)\n                                 /((ssize_t) (m*2))+\n                                 GetPixelBlue(pixels)));\n                              if (image->matte != MagickFalse)\n                                 SetPixelOpacity(q,\n                                   (QM) ((2*i*(\n                                   GetPixelOpacity(n)\n                                   -GetPixelOpacity(pixels))+m)\n                                   /((ssize_t) (m*2))+\n                                   GetPixelOpacity(pixels)));\n                            }\n\n                          if (magn_methx == 4)\n                            {\n                              /* Replicate nearest */\n                              if (i <= ((m+1) << 1))\n                              {\n                                 SetPixelOpacity(q,\n                                 GetPixelOpacity(pixels)+0);\n                              }\n                              else\n                              {\n                                 SetPixelOpacity(q,\n                                 GetPixelOpacity(n)+0);\n                              }\n                            }\n                        }\n\n                      else /* if (magn_methx == 3 || magn_methx == 5) */\n                        {\n                          /* Replicate nearest */\n                          if (i <= ((m+1) << 1))\n                          {\n                             SetPixelRGBO(q,(pixels));\n                          }\n\n                          else\n                          {\n                             SetPixelRGBO(q,(n));\n                          }\n\n                          if (magn_methx == 5)\n                            {\n                              /* Interpolate */\n                              SetPixelOpacity(q,\n                                 (QM) ((2*i*( GetPixelOpacity(n)\n                                 -GetPixelOpacity(pixels))+m)/\n                                 ((ssize_t) (m*2))\n                                 +GetPixelOpacity(pixels)));\n                            }\n                        }\n                      q++;\n                    }\n                    n++;\n                  }\n\n                  if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                    break;\n                }\n#if (MAGICKCORE_QUANTUM_DEPTH > 16)\n              if (magn_methx != 1 || magn_methy != 1)\n                {\n                /*\n                   Rescale pixels to Quantum\n                */\n                   for (y=0; y < (ssize_t) image->rows; y++)\n                   {\n                     q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n                     for (x=(ssize_t) image->columns-1; x >= 0; x--)\n                     {\n                        SetPixelRed(q,ScaleShortToQuantum(\n                            GetPixelRed(q)));\n                        SetPixelGreen(q,ScaleShortToQuantum(\n                            GetPixelGreen(q)));\n                        SetPixelBlue(q,ScaleShortToQuantum(\n                            GetPixelBlue(q)));\n                        SetPixelOpacity(q,ScaleShortToQuantum(\n                            GetPixelOpacity(q)));\n                        q++;\n                     }\n\n                     if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                       break;\n                   }\n                }\n#endif\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  Finished MAGN processing\");\n              }\n          }\n\n        /*\n          Crop_box is with respect to the upper left corner of the MNG.\n        */\n        crop_box.left=mng_info->image_box.left+mng_info->x_off[object_id];\n        crop_box.right=mng_info->image_box.right+mng_info->x_off[object_id];\n        crop_box.top=mng_info->image_box.top+mng_info->y_off[object_id];\n        crop_box.bottom=mng_info->image_box.bottom+mng_info->y_off[object_id];\n        crop_box=mng_minimum_box(crop_box,mng_info->clip);\n        crop_box=mng_minimum_box(crop_box,mng_info->frame);\n        crop_box=mng_minimum_box(crop_box,mng_info->object_clip[object_id]);\n        if ((crop_box.left != (mng_info->image_box.left\n            +mng_info->x_off[object_id])) ||\n            (crop_box.right != (mng_info->image_box.right\n            +mng_info->x_off[object_id])) ||\n            (crop_box.top != (mng_info->image_box.top\n            +mng_info->y_off[object_id])) ||\n            (crop_box.bottom != (mng_info->image_box.bottom\n            +mng_info->y_off[object_id])))\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Crop the PNG image\");\n\n            if ((crop_box.left < crop_box.right) &&\n                (crop_box.top < crop_box.bottom))\n              {\n                Image\n                  *im;\n\n                RectangleInfo\n                  crop_info;\n\n                /*\n                  Crop_info is with respect to the upper left corner of\n                  the image.\n                */\n                crop_info.x=(crop_box.left-mng_info->x_off[object_id]);\n                crop_info.y=(crop_box.top-mng_info->y_off[object_id]);\n                crop_info.width=(size_t) (crop_box.right-crop_box.left);\n                crop_info.height=(size_t) (crop_box.bottom-crop_box.top);\n                image->page.width=image->columns;\n                image->page.height=image->rows;\n                image->page.x=0;\n                image->page.y=0;\n                im=CropImage(image,&crop_info,exception);\n\n                if (im != (Image *) NULL)\n                  {\n                    image->columns=im->columns;\n                    image->rows=im->rows;\n                    im=DestroyImage(im);\n                    image->page.width=image->columns;\n                    image->page.height=image->rows;\n                    image->page.x=crop_box.left;\n                    image->page.y=crop_box.top;\n                  }\n              }\n\n            else\n              {\n                /*\n                  No pixels in crop area.  The MNG spec still requires\n                  a layer, though, so make a single transparent pixel in\n                  the top left corner.\n                */\n                image->columns=1;\n                image->rows=1;\n                image->colors=2;\n                (void) SetImageBackgroundColor(image);\n                image->page.width=1;\n                image->page.height=1;\n                image->page.x=0;\n                image->page.y=0;\n              }\n          }\n#ifndef PNG_READ_EMPTY_PLTE_SUPPORTED\n        image=mng_info->image;\n#endif\n      }\n\n#if (MAGICKCORE_QUANTUM_DEPTH > 16)\n      /* PNG does not handle depths greater than 16 so reduce it even\n       * if lossy, and promote any depths > 8 to 16.\n       */\n      if (image->depth > 16)\n         image->depth=16;\n#endif\n\n#if (MAGICKCORE_QUANTUM_DEPTH > 8)\n      if (image->depth > 8)\n        {\n          /* To do: fill low byte properly */\n          image->depth=16;\n        }\n\n      if (LosslessReduceDepthOK(image) != MagickFalse)\n         image->depth = 8;\n#endif\n\n      GetImageException(image,exception);\n\n      if (image_info->number_scenes != 0)\n        {\n          if (mng_info->scenes_found >\n             (ssize_t) (image_info->first_scene+image_info->number_scenes))\n            break;\n        }\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Finished reading image datastream.\");\n\n  } while (LocaleCompare(image_info->magick,\"MNG\") == 0);\n\n  (void) CloseBlob(image);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Finished reading all image datastreams.\");\n\n#if defined(MNG_INSERT_LAYERS)\n  if (insert_layers && !mng_info->image_found && (mng_info->mng_width) &&\n       (mng_info->mng_height))\n    {\n      /*\n        Insert a background layer if nothing else was found.\n      */\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  No images found.  Inserting a background layer.\");\n\n      if (GetAuthenticPixelQueue(image) != (PixelPacket *) NULL)\n        {\n          /*\n            Allocate next image structure.\n          */\n          AcquireNextImage(image_info,image);\n          if (GetNextImageInList(image) == (Image *) NULL)\n            {\n              if (logging != MagickFalse)\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Allocation failed, returning NULL.\");\n\n              return(DestroyImageList(image));\n            }\n          image=SyncNextImageInList(image);\n        }\n      image->columns=mng_info->mng_width;\n      image->rows=mng_info->mng_height;\n      image->page.width=mng_info->mng_width;\n      image->page.height=mng_info->mng_height;\n      image->page.x=0;\n      image->page.y=0;\n      image->background_color=mng_background_color;\n      image->matte=MagickFalse;\n\n      if (image_info->ping == MagickFalse)\n        (void) SetImageBackgroundColor(image);\n\n      mng_info->image_found++;\n    }\n#endif\n  image->iterations=mng_iterations;\n\n  if (mng_iterations == 1)\n    image->start_loop=MagickTrue;\n\n  while (GetPreviousImageInList(image) != (Image *) NULL)\n  {\n    image_count++;\n    if (image_count > 10*mng_info->image_found)\n      {\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  No beginning\");\n\n        (void) ThrowMagickException(&image->exception,GetMagickModule(),\n          CoderError,\"Linked list is corrupted, beginning of list not found\",\n          \"`%s'\",image_info->filename);\n\n        return(DestroyImageList(image));\n      }\n\n    image=GetPreviousImageInList(image);\n\n    if (GetNextImageInList(image) == (Image *) NULL)\n      {\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  Corrupt list\");\n\n        (void) ThrowMagickException(&image->exception,GetMagickModule(),\n          CoderError,\"Linked list is corrupted; next_image is NULL\",\"`%s'\",\n          image_info->filename);\n      }\n  }\n\n  if (mng_info->ticks_per_second && mng_info->image_found > 1 &&\n             GetNextImageInList(image) ==\n     (Image *) NULL)\n    {\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  First image null\");\n\n      (void) ThrowMagickException(&image->exception,GetMagickModule(),\n        CoderError,\"image->next for first image is NULL but shouldn't be.\",\n        \"`%s'\",image_info->filename);\n    }\n\n  if (mng_info->image_found == 0)\n    {\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  No visible images found.\");\n\n      (void) ThrowMagickException(&image->exception,GetMagickModule(),\n        CoderError,\"No visible images in file\",\"`%s'\",image_info->filename);\n\n      return(DestroyImageList(image));\n    }\n\n  if (mng_info->ticks_per_second)\n    final_delay=1UL*MagickMax(image->ticks_per_second,1L)*\n            final_delay/mng_info->ticks_per_second;\n\n  else\n    image->start_loop=MagickTrue;\n\n  /* Find final nonzero image delay */\n  final_image_delay=0;\n\n  while (GetNextImageInList(image) != (Image *) NULL)\n    {\n      if (image->delay)\n        final_image_delay=image->delay;\n\n      image=GetNextImageInList(image);\n    }\n\n  if (final_delay < final_image_delay)\n    final_delay=final_image_delay;\n\n  image->delay=final_delay;\n\n  if (logging != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  image->delay=%.20g, final_delay=%.20g\",(double) image->delay,\n        (double) final_delay);\n\n  if (logging != MagickFalse)\n    {\n      int\n        scene;\n\n      scene=0;\n      image=GetFirstImageInList(image);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Before coalesce:\");\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    scene 0 delay=%.20g\",(double) image->delay);\n\n      while (GetNextImageInList(image) != (Image *) NULL)\n      {\n        image=GetNextImageInList(image);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    scene %.20g delay=%.20g\",(double) scene++,(double) image->delay);\n      }\n    }\n\n  image=GetFirstImageInList(image);\n#ifdef MNG_COALESCE_LAYERS\n  if (insert_layers)\n    {\n      Image\n        *next_image,\n        *next;\n\n      size_t\n        scene;\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  Coalesce Images\");\n\n      scene=image->scene;\n      next_image=CoalesceImages(image,&image->exception);\n\n      if (next_image == (Image *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n      image=DestroyImageList(image);\n      image=next_image;\n\n      for (next=image; next != (Image *) NULL; next=next_image)\n      {\n         next->page.width=mng_info->mng_width;\n         next->page.height=mng_info->mng_height;\n         next->page.x=0;\n         next->page.y=0;\n         next->scene=scene++;\n         next_image=GetNextImageInList(next);\n\n         if (next_image == (Image *) NULL)\n           break;\n\n         if (next->delay == 0)\n           {\n             scene--;\n             next_image->previous=GetPreviousImageInList(next);\n             if (GetPreviousImageInList(next) == (Image *) NULL)\n               image=next_image;\n             else\n               next->previous->next=next_image;\n             next=DestroyImage(next);\n           }\n      }\n    }\n#endif\n\n  while (GetNextImageInList(image) != (Image *) NULL)\n      image=GetNextImageInList(image);\n\n  image->dispose=BackgroundDispose;\n\n  if (logging != MagickFalse)\n    {\n      int\n        scene;\n\n      scene=0;\n      image=GetFirstImageInList(image);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  After coalesce:\");\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    scene 0 delay=%.20g dispose=%.20g\",(double) image->delay,\n        (double) image->dispose);\n\n      while (GetNextImageInList(image) != (Image *) NULL)\n      {\n        image=GetNextImageInList(image);\n\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    scene %.20g delay=%.20g dispose=%.20g\",(double) scene++,\n          (double) image->delay,(double) image->dispose);\n      }\n   }\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  exit ReadOneJNGImage();\");\n\n  return(image);\n}\n",
    "code_after_change": "static Image *ReadOneMNGImage(MngInfo* mng_info, const ImageInfo *image_info,\n     ExceptionInfo *exception)\n{\n  char\n    page_geometry[MaxTextExtent];\n\n  Image\n    *image;\n\n  MagickBooleanType\n    logging;\n\n  volatile int\n    first_mng_object,\n    object_id,\n    term_chunk_found,\n    skip_to_iend;\n\n  volatile ssize_t\n    image_count=0;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  MngBox\n    default_fb,\n    fb,\n    previous_fb;\n\n#if defined(MNG_INSERT_LAYERS)\n  PixelPacket\n    mng_background_color;\n#endif\n\n  register unsigned char\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    count;\n\n  ssize_t\n    loop_level;\n\n  volatile short\n    skipping_loop;\n\n#if defined(MNG_INSERT_LAYERS)\n  unsigned int\n    mandatory_back=0;\n#endif\n\n  volatile unsigned int\n#ifdef MNG_OBJECT_BUFFERS\n    mng_background_object=0,\n#endif\n    mng_type=0;   /* 0: PNG or JNG; 1: MNG; 2: MNG-LC; 3: MNG-VLC */\n\n  size_t\n    default_frame_timeout,\n    frame_timeout,\n#if defined(MNG_INSERT_LAYERS)\n    image_height,\n    image_width,\n#endif\n    length;\n\n  /* These delays are all measured in image ticks_per_second,\n   * not in MNG ticks_per_second\n   */\n  volatile size_t\n    default_frame_delay,\n    final_delay,\n    final_image_delay,\n    frame_delay,\n#if defined(MNG_INSERT_LAYERS)\n    insert_layers,\n#endif\n    mng_iterations=1,\n    simplicity=0,\n    subframe_height=0,\n    subframe_width=0;\n\n  previous_fb.top=0;\n  previous_fb.bottom=0;\n  previous_fb.left=0;\n  previous_fb.right=0;\n  default_fb.top=0;\n  default_fb.bottom=0;\n  default_fb.left=0;\n  default_fb.right=0;\n\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  Enter ReadOneMNGImage()\");\n\n  image=mng_info->image;\n\n  if (LocaleCompare(image_info->magick,\"MNG\") == 0)\n    {\n      char\n        magic_number[MaxTextExtent];\n\n      /* Verify MNG signature.  */\n      count=(size_t) ReadBlob(image,8,(unsigned char *) magic_number);\n      if (memcmp(magic_number,\"\\212MNG\\r\\n\\032\\n\",8) != 0)\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n      /* Initialize some nonzero members of the MngInfo structure.  */\n      for (i=0; i < MNG_MAX_OBJECTS; i++)\n      {\n        mng_info->object_clip[i].right=(ssize_t) PNG_UINT_31_MAX;\n        mng_info->object_clip[i].bottom=(ssize_t) PNG_UINT_31_MAX;\n      }\n      mng_info->exists[0]=MagickTrue;\n    }\n\n  skipping_loop=(-1);\n  first_mng_object=MagickTrue;\n  mng_type=0;\n#if defined(MNG_INSERT_LAYERS)\n  insert_layers=MagickFalse; /* should be False when converting or mogrifying */\n#endif\n  default_frame_delay=0;\n  default_frame_timeout=0;\n  frame_delay=0;\n  final_delay=1;\n  mng_info->ticks_per_second=1UL*image->ticks_per_second;\n  object_id=0;\n  skip_to_iend=MagickFalse;\n  term_chunk_found=MagickFalse;\n  mng_info->framing_mode=1;\n#if defined(MNG_INSERT_LAYERS)\n  mandatory_back=MagickFalse;\n#endif\n#if defined(MNG_INSERT_LAYERS)\n  mng_background_color=image->background_color;\n#endif\n  default_fb=mng_info->frame;\n  previous_fb=mng_info->frame;\n  do\n  {\n    char\n      type[MaxTextExtent];\n\n    if (LocaleCompare(image_info->magick,\"MNG\") == 0)\n      {\n        unsigned char\n          *chunk;\n\n        /*\n          Read a new chunk.\n        */\n        type[0]='\\0';\n        (void) ConcatenateMagickString(type,\"errr\",MaxTextExtent);\n        length=ReadBlobMSBLong(image);\n        count=(size_t) ReadBlob(image,4,(unsigned char *) type);\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n           \"  Reading MNG chunk type %c%c%c%c, length: %.20g\",\n           type[0],type[1],type[2],type[3],(double) length);\n\n        if (length > PNG_UINT_31_MAX)\n          {\n            status=MagickFalse;\n            break;\n          }\n\n        if (count == 0)\n          ThrowReaderException(CorruptImageError,\"CorruptImage\");\n\n        p=NULL;\n        chunk=(unsigned char *) NULL;\n\n        if (length != 0)\n          {\n            chunk=(unsigned char *) AcquireQuantumMemory(length+\n              MagickPathExtent,sizeof(*chunk));\n\n            if (chunk == (unsigned char *) NULL)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n            for (i=0; i < (ssize_t) length; i++)\n            {\n              int\n                c;\n\n              c=ReadBlobByte(image);\n              if (c == EOF)\n                break;\n              chunk[i]=(unsigned char) c;\n            }\n\n            p=chunk;\n          }\n\n        (void) ReadBlobMSBLong(image);  /* read crc word */\n\n#if !defined(JNG_SUPPORTED)\n        if (memcmp(type,mng_JHDR,4) == 0)\n          {\n            skip_to_iend=MagickTrue;\n\n            if (mng_info->jhdr_warning == 0)\n              (void) ThrowMagickException(&image->exception,GetMagickModule(),\n                CoderError,\"JNGCompressNotSupported\",\"`%s'\",image->filename);\n\n            mng_info->jhdr_warning++;\n          }\n#endif\n        if (memcmp(type,mng_DHDR,4) == 0)\n          {\n            skip_to_iend=MagickTrue;\n\n            if (mng_info->dhdr_warning == 0)\n              (void) ThrowMagickException(&image->exception,GetMagickModule(),\n                CoderError,\"DeltaPNGNotSupported\",\"`%s'\",image->filename);\n\n            mng_info->dhdr_warning++;\n          }\n        if (memcmp(type,mng_MEND,4) == 0)\n          break;\n\n        if (skip_to_iend)\n          {\n            if (memcmp(type,mng_IEND,4) == 0)\n              skip_to_iend=MagickFalse;\n\n            if (length != 0)\n              chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Skip to IEND.\");\n\n            continue;\n          }\n\n        if (memcmp(type,mng_MHDR,4) == 0)\n          {\n            if (length != 28)\n              {\n                chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n                ThrowReaderException(CorruptImageError,\"CorruptImage\");\n              }\n\n            mng_info->mng_width=(size_t) ((p[0] << 24) | (p[1] << 16) |\n                (p[2] << 8) | p[3]);\n\n            mng_info->mng_height=(size_t) ((p[4] << 24) | (p[5] << 16) |\n                (p[6] << 8) | p[7]);\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  MNG width: %.20g\",(double) mng_info->mng_width);\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  MNG height: %.20g\",(double) mng_info->mng_height);\n              }\n\n            p+=8;\n            mng_info->ticks_per_second=(size_t) mng_get_long(p);\n\n            if (mng_info->ticks_per_second == 0)\n              default_frame_delay=0;\n\n            else\n              default_frame_delay=1UL*image->ticks_per_second/\n                mng_info->ticks_per_second;\n\n            frame_delay=default_frame_delay;\n            simplicity=0;\n\n            /* Skip nominal layer count, frame count, and play time */\n            p+=16;\n            simplicity=(size_t) mng_get_long(p);\n\n            mng_type=1;    /* Full MNG */\n\n            if ((simplicity != 0) && ((simplicity | 11) == 11))\n              mng_type=2; /* LC */\n\n            if ((simplicity != 0) && ((simplicity | 9) == 9))\n              mng_type=3; /* VLC */\n\n#if defined(MNG_INSERT_LAYERS)\n            if (mng_type != 3)\n              insert_layers=MagickTrue;\n#endif\n            if (GetAuthenticPixelQueue(image) != (PixelPacket *) NULL)\n              {\n                /* Allocate next image structure.  */\n                AcquireNextImage(image_info,image);\n\n                if (GetNextImageInList(image) == (Image *) NULL)\n                  return(DestroyImageList(image));\n\n                image=SyncNextImageInList(image);\n                mng_info->image=image;\n              }\n\n            if ((mng_info->mng_width > 65535L) ||\n                (mng_info->mng_height > 65535L))\n              {\n                chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n                ThrowReaderException(ImageError,\"WidthOrHeightExceedsLimit\");\n              }\n\n            (void) FormatLocaleString(page_geometry,MaxTextExtent,\n              \"%.20gx%.20g+0+0\",(double) mng_info->mng_width,(double)\n              mng_info->mng_height);\n\n            mng_info->frame.left=0;\n            mng_info->frame.right=(ssize_t) mng_info->mng_width;\n            mng_info->frame.top=0;\n            mng_info->frame.bottom=(ssize_t) mng_info->mng_height;\n            mng_info->clip=default_fb=previous_fb=mng_info->frame;\n\n            for (i=0; i < MNG_MAX_OBJECTS; i++)\n              mng_info->object_clip[i]=mng_info->frame;\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_TERM,4) == 0)\n          {\n            int\n              repeat=0;\n\n            if (length != 0)\n              repeat=p[0];\n\n            if (repeat == 3 && length > 8)\n              {\n                final_delay=(png_uint_32) mng_get_long(&p[2]);\n                mng_iterations=(png_uint_32) mng_get_long(&p[6]);\n\n                if (mng_iterations == PNG_UINT_31_MAX)\n                  mng_iterations=0;\n\n                image->iterations=mng_iterations;\n                term_chunk_found=MagickTrue;\n              }\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    repeat=%d,  final_delay=%.20g,  iterations=%.20g\",\n                  repeat,(double) final_delay, (double) image->iterations);\n              }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n        if (memcmp(type,mng_DEFI,4) == 0)\n          {\n            if (mng_type == 3)\n              (void) ThrowMagickException(&image->exception,GetMagickModule(),\n                CoderError,\"DEFI chunk found in MNG-VLC datastream\",\"`%s'\",\n                image->filename);\n\n            if (length > 1)\n              {\n                object_id=(p[0] << 8) | p[1];\n\n                if (mng_type == 2 && object_id != 0)\n                  (void) ThrowMagickException(&image->exception,\n                     GetMagickModule(),\n                     CoderError,\"Nonzero object_id in MNG-LC datastream\",\n                     \"`%s'\", image->filename);\n\n                if (object_id > MNG_MAX_OBJECTS)\n                  {\n                    /*\n                      Instead of using a warning we should allocate a larger\n                      MngInfo structure and continue.\n                    */\n                    (void) ThrowMagickException(&image->exception,\n                        GetMagickModule(), CoderError,\n                        \"object id too large\",\"`%s'\",image->filename);\n                        object_id=MNG_MAX_OBJECTS;\n                  }\n\n                if (mng_info->exists[object_id])\n                  if (mng_info->frozen[object_id])\n                    {\n                      chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n                      (void) ThrowMagickException(&image->exception,\n                        GetMagickModule(),CoderError,\n                        \"DEFI cannot redefine a frozen MNG object\",\"`%s'\",\n                        image->filename);\n                      continue;\n                    }\n\n                mng_info->exists[object_id]=MagickTrue;\n\n                if (length > 2)\n                  mng_info->invisible[object_id]=p[2];\n\n                /*\n                  Extract object offset info.\n                */\n                if (length > 11)\n                  {\n                    mng_info->x_off[object_id]=(ssize_t) ((p[4] << 24) |\n                        (p[5] << 16) | (p[6] << 8) | p[7]);\n\n                    mng_info->y_off[object_id]=(ssize_t) ((p[8] << 24) |\n                        (p[9] << 16) | (p[10] << 8) | p[11]);\n\n                    if (logging != MagickFalse)\n                      {\n                        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                          \"  x_off[%d]: %.20g,  y_off[%d]: %.20g\",\n                          object_id,(double) mng_info->x_off[object_id],\n                          object_id,(double) mng_info->y_off[object_id]);\n                      }\n                  }\n\n                /*\n                  Extract object clipping info.\n                */\n            \n                if (length > 27)\n                  mng_info->object_clip[object_id]=\n                    mng_read_box(mng_info->frame,0, &p[12]);\n            }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n        if (memcmp(type,mng_bKGD,4) == 0)\n          {\n            mng_info->have_global_bkgd=MagickFalse;\n\n            if (length > 5)\n              {\n                mng_info->mng_global_bkgd.red=\n                  ScaleShortToQuantum((unsigned short) ((p[0] << 8) | p[1]));\n\n                mng_info->mng_global_bkgd.green=\n                  ScaleShortToQuantum((unsigned short) ((p[2] << 8) | p[3]));\n\n                mng_info->mng_global_bkgd.blue=\n                  ScaleShortToQuantum((unsigned short) ((p[4] << 8) | p[5]));\n\n                mng_info->have_global_bkgd=MagickTrue;\n              }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n        if (memcmp(type,mng_BACK,4) == 0)\n          {\n#if defined(MNG_INSERT_LAYERS)\n            if (length > 6)\n              mandatory_back=p[6];\n\n            else\n              mandatory_back=0;\n\n            if (mandatory_back && length > 5)\n              {\n                mng_background_color.red=\n                    ScaleShortToQuantum((unsigned short) ((p[0] << 8) | p[1]));\n\n                mng_background_color.green=\n                    ScaleShortToQuantum((unsigned short) ((p[2] << 8) | p[3]));\n\n                mng_background_color.blue=\n                    ScaleShortToQuantum((unsigned short) ((p[4] << 8) | p[5]));\n\n                mng_background_color.opacity=OpaqueOpacity;\n              }\n\n#ifdef MNG_OBJECT_BUFFERS\n            if (length > 8)\n              mng_background_object=(p[7] << 8) | p[8];\n#endif\n#endif\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_PLTE,4) == 0)\n          {\n            /* Read global PLTE.  */\n\n            if (length && (length < 769))\n              {\n                if (mng_info->global_plte == (png_colorp) NULL)\n                  mng_info->global_plte=(png_colorp) AcquireQuantumMemory(256,\n                    sizeof(*mng_info->global_plte));\n\n                for (i=0; i < (ssize_t) (length/3); i++)\n                {\n                  mng_info->global_plte[i].red=p[3*i];\n                  mng_info->global_plte[i].green=p[3*i+1];\n                  mng_info->global_plte[i].blue=p[3*i+2];\n                }\n\n                mng_info->global_plte_length=(unsigned int) (length/3);\n              }\n#ifdef MNG_LOOSE\n            for ( ; i < 256; i++)\n            {\n              mng_info->global_plte[i].red=i;\n              mng_info->global_plte[i].green=i;\n              mng_info->global_plte[i].blue=i;\n            }\n\n            if (length != 0)\n              mng_info->global_plte_length=256;\n#endif\n            else\n              mng_info->global_plte_length=0;\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_tRNS,4) == 0)\n          {\n            /* read global tRNS */\n\n            if (length > 0 && length < 257)\n              for (i=0; i < (ssize_t) length; i++)\n                mng_info->global_trns[i]=p[i];\n\n#ifdef MNG_LOOSE\n            for ( ; i < 256; i++)\n              mng_info->global_trns[i]=255;\n#endif\n            mng_info->global_trns_length=(unsigned int) length;\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n        if (memcmp(type,mng_gAMA,4) == 0)\n          {\n            if (length == 4)\n              {\n                ssize_t\n                  igamma;\n\n                igamma=mng_get_long(p);\n                mng_info->global_gamma=((float) igamma)*0.00001;\n                mng_info->have_global_gama=MagickTrue;\n              }\n\n            else\n              mng_info->have_global_gama=MagickFalse;\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_cHRM,4) == 0)\n          {\n            /* Read global cHRM */\n\n            if (length == 32)\n              {\n                mng_info->global_chrm.white_point.x=0.00001*mng_get_long(p);\n                mng_info->global_chrm.white_point.y=0.00001*mng_get_long(&p[4]);\n                mng_info->global_chrm.red_primary.x=0.00001*mng_get_long(&p[8]);\n                mng_info->global_chrm.red_primary.y=0.00001*\n                  mng_get_long(&p[12]);\n                mng_info->global_chrm.green_primary.x=0.00001*\n                  mng_get_long(&p[16]);\n                mng_info->global_chrm.green_primary.y=0.00001*\n                  mng_get_long(&p[20]);\n                mng_info->global_chrm.blue_primary.x=0.00001*\n                  mng_get_long(&p[24]);\n                mng_info->global_chrm.blue_primary.y=0.00001*\n                  mng_get_long(&p[28]);\n                mng_info->have_global_chrm=MagickTrue;\n              }\n            else\n              mng_info->have_global_chrm=MagickFalse;\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_sRGB,4) == 0)\n          {\n            /*\n              Read global sRGB.\n            */\n            if (length != 0)\n              {\n                mng_info->global_srgb_intent=\n                  Magick_RenderingIntent_from_PNG_RenderingIntent(p[0]);\n                mng_info->have_global_srgb=MagickTrue;\n              }\n            else\n              mng_info->have_global_srgb=MagickFalse;\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_iCCP,4) == 0)\n          {\n            /* To do: */\n\n            /*\n              Read global iCCP.\n            */\n            if (length != 0)\n              chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            continue;\n          }\n\n        if (memcmp(type,mng_FRAM,4) == 0)\n          {\n            if (mng_type == 3)\n              (void) ThrowMagickException(&image->exception,GetMagickModule(),\n                CoderError,\"FRAM chunk found in MNG-VLC datastream\",\"`%s'\",\n                image->filename);\n\n            if ((mng_info->framing_mode == 2) || (mng_info->framing_mode == 4))\n              image->delay=frame_delay;\n\n            frame_delay=default_frame_delay;\n            frame_timeout=default_frame_timeout;\n            fb=default_fb;\n\n            if (length > 0)\n              if (p[0])\n                mng_info->framing_mode=p[0];\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Framing_mode=%d\",mng_info->framing_mode);\n\n            if (length > 6)\n              {\n                /* Note the delay and frame clipping boundaries.  */\n\n                p++; /* framing mode */\n\n                while (*p && ((p-chunk) < (ssize_t) length))\n                  p++;  /* frame name */\n\n                p++;  /* frame name terminator */\n\n                if ((p-chunk) < (ssize_t) (length-4))\n                  {\n                    int\n                      change_delay,\n                      change_timeout,\n                      change_clipping;\n\n                    change_delay=(*p++);\n                    change_timeout=(*p++);\n                    change_clipping=(*p++);\n                    p++; /* change_sync */\n\n                    if (change_delay && (p-chunk) < (ssize_t) (length-4))\n                      {\n                          frame_delay=1UL*image->ticks_per_second*\n                            mng_get_long(p);\n\n                        if (mng_info->ticks_per_second != 0)\n                          frame_delay/=mng_info->ticks_per_second;\n\n                        else\n                          frame_delay=PNG_UINT_31_MAX;\n\n                        if (change_delay == 2)\n                          default_frame_delay=frame_delay;\n\n                        p+=4;\n\n                        if (logging != MagickFalse)\n                          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                            \"    Framing_delay=%.20g\",(double) frame_delay);\n                      }\n\n                    if (change_timeout && (p-chunk) < (ssize_t) (length-4))\n                      {\n                        frame_timeout=1UL*image->ticks_per_second*\n                          mng_get_long(p);\n\n                        if (mng_info->ticks_per_second != 0)\n                          frame_timeout/=mng_info->ticks_per_second;\n\n                        else\n                          frame_timeout=PNG_UINT_31_MAX;\n\n                        if (change_timeout == 2)\n                          default_frame_timeout=frame_timeout;\n\n                        p+=4;\n\n                        if (logging != MagickFalse)\n                          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                            \"    Framing_timeout=%.20g\",(double) frame_timeout);\n                      }\n\n                    if (change_clipping && (p-chunk) < (ssize_t) (length-17))\n                      {\n                        fb=mng_read_box(previous_fb,(char) p[0],&p[1]);\n                        p+=17;\n                        previous_fb=fb;\n\n                        if (logging != MagickFalse)\n                          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                            \"    Frame_clip: L=%.20g R=%.20g T=%.20g B=%.20g\",\n                            (double) fb.left,(double) fb.right,(double) fb.top,\n                            (double) fb.bottom);\n\n                        if (change_clipping == 2)\n                          default_fb=fb;\n                      }\n                  }\n              }\n            mng_info->clip=fb;\n            mng_info->clip=mng_minimum_box(fb,mng_info->frame);\n\n            subframe_width=(size_t) (mng_info->clip.right\n               -mng_info->clip.left);\n\n            subframe_height=(size_t) (mng_info->clip.bottom\n               -mng_info->clip.top);\n            /*\n              Insert a background layer behind the frame if framing_mode is 4.\n            */\n#if defined(MNG_INSERT_LAYERS)\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"   subframe_width=%.20g, subframe_height=%.20g\",(double)\n                subframe_width,(double) subframe_height);\n\n            if (insert_layers && (mng_info->framing_mode == 4) &&\n                (subframe_width) && (subframe_height))\n              {\n                /* Allocate next image structure.  */\n                if (GetAuthenticPixelQueue(image) != (PixelPacket *) NULL)\n                  {\n                    AcquireNextImage(image_info,image);\n\n                    if (GetNextImageInList(image) == (Image *) NULL)\n                      return(DestroyImageList(image));\n\n                    image=SyncNextImageInList(image);\n                  }\n\n                mng_info->image=image;\n\n                if (term_chunk_found)\n                  {\n                    image->start_loop=MagickTrue;\n                    image->iterations=mng_iterations;\n                    term_chunk_found=MagickFalse;\n                  }\n\n                else\n                    image->start_loop=MagickFalse;\n\n                image->columns=subframe_width;\n                image->rows=subframe_height;\n                image->page.width=subframe_width;\n                image->page.height=subframe_height;\n                image->page.x=mng_info->clip.left;\n                image->page.y=mng_info->clip.top;\n                image->background_color=mng_background_color;\n                image->matte=MagickFalse;\n                image->delay=0;\n                (void) SetImageBackgroundColor(image);\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  Insert backgd layer, L=%.20g, R=%.20g T=%.20g, B=%.20g\",\n                    (double) mng_info->clip.left,(double) mng_info->clip.right,\n                    (double) mng_info->clip.top,(double) mng_info->clip.bottom);\n              }\n#endif\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n        if (memcmp(type,mng_CLIP,4) == 0)\n          {\n            unsigned int\n              first_object,\n              last_object;\n\n            /*\n              Read CLIP.\n            */\n            if (length > 3)\n              {\n                first_object=(p[0] << 8) | p[1];\n                last_object=(p[2] << 8) | p[3];\n                p+=4;\n\n                for (i=(int) first_object; i <= (int) last_object; i++)\n                {\n                  if (mng_info->exists[i] && !mng_info->frozen[i])\n                    {\n                      MngBox\n                        box;\n\n                      box=mng_info->object_clip[i];\n                      if ((p-chunk) < (ssize_t) (length-17))\n                        mng_info->object_clip[i]=\n                           mng_read_box(box,(char) p[0],&p[1]);\n                    }\n                }\n\n              }\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n        if (memcmp(type,mng_SAVE,4) == 0)\n          {\n            for (i=1; i < MNG_MAX_OBJECTS; i++)\n              if (mng_info->exists[i])\n                {\n                 mng_info->frozen[i]=MagickTrue;\n#ifdef MNG_OBJECT_BUFFERS\n                 if (mng_info->ob[i] != (MngBuffer *) NULL)\n                    mng_info->ob[i]->frozen=MagickTrue;\n#endif\n                }\n\n            if (length != 0)\n              chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            continue;\n          }\n\n        if ((memcmp(type,mng_DISC,4) == 0) || (memcmp(type,mng_SEEK,4) == 0))\n          {\n            /* Read DISC or SEEK.  */\n\n            if ((length == 0) || !memcmp(type,mng_SEEK,4))\n              {\n                for (i=1; i < MNG_MAX_OBJECTS; i++)\n                  MngInfoDiscardObject(mng_info,i);\n              }\n\n            else\n              {\n                register ssize_t\n                  j;\n\n                for (j=1; j < (ssize_t) length; j+=2)\n                {\n                  i=p[j-1] << 8 | p[j];\n                  MngInfoDiscardObject(mng_info,i);\n                }\n              }\n\n            if (length != 0)\n              chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            continue;\n          }\n\n        if (memcmp(type,mng_MOVE,4) == 0)\n          {\n            size_t\n              first_object,\n              last_object;\n\n            /* read MOVE */\n\n            if (length > 3)\n            {\n              first_object=(p[0] << 8) | p[1];\n              last_object=(p[2] << 8) | p[3];\n              p+=4;\n \n               for (i=(ssize_t) first_object; i <= (ssize_t) last_object; i++)\n               {\n                if ((i < 0) || (i >= MNG_MAX_OBJECTS))\n                  continue;\n                 if (mng_info->exists[i] && !mng_info->frozen[i] &&\n                     (p-chunk) < (ssize_t) (length-8))\n                   {\n                    MngPair\n                      new_pair;\n\n                    MngPair\n                      old_pair;\n\n                    old_pair.a=mng_info->x_off[i];\n                    old_pair.b=mng_info->y_off[i];\n                    new_pair=mng_read_pair(old_pair,(int) p[0],&p[1]);\n                    mng_info->x_off[i]=new_pair.a;\n                    mng_info->y_off[i]=new_pair.b;\n                  }\n              }\n            }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_LOOP,4) == 0)\n          {\n            ssize_t loop_iters=1;\n            if (length > 4)\n              {\n                loop_level=chunk[0];\n                mng_info->loop_active[loop_level]=1;  /* mark loop active */\n\n                /* Record starting point.  */\n                loop_iters=mng_get_long(&chunk[1]);\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  LOOP level %.20g has %.20g iterations \",\n                    (double) loop_level, (double) loop_iters);\n\n                if (loop_iters == 0)\n                  skipping_loop=loop_level;\n\n                else\n                  {\n                    mng_info->loop_jump[loop_level]=TellBlob(image);\n                    mng_info->loop_count[loop_level]=loop_iters;\n                  }\n\n                mng_info->loop_iteration[loop_level]=0;\n              }\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_ENDL,4) == 0)\n          {\n            if (length > 0)\n              {\n                loop_level=chunk[0];\n\n                if (skipping_loop > 0)\n                  {\n                    if (skipping_loop == loop_level)\n                      {\n                        /*\n                          Found end of zero-iteration loop.\n                        */\n                        skipping_loop=(-1);\n                        mng_info->loop_active[loop_level]=0;\n                      }\n                  }\n\n                else\n                  {\n                    if (mng_info->loop_active[loop_level] == 1)\n                      {\n                        mng_info->loop_count[loop_level]--;\n                        mng_info->loop_iteration[loop_level]++;\n\n                        if (logging != MagickFalse)\n                          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                          \"  ENDL: LOOP level %.20g has %.20g remaining iters \",\n                            (double) loop_level,(double)\n                            mng_info->loop_count[loop_level]);\n\n                        if (mng_info->loop_count[loop_level] != 0)\n                          {\n                            offset=SeekBlob(image,\n                              mng_info->loop_jump[loop_level], SEEK_SET);\n\n                            if (offset < 0)\n                              {\n                                chunk=(unsigned char *) RelinquishMagickMemory(\n                                  chunk);\n                                ThrowReaderException(CorruptImageError,\n                                  \"ImproperImageHeader\");\n                              }\n                          }\n\n                        else\n                          {\n                            short\n                              last_level;\n\n                            /*\n                              Finished loop.\n                            */\n                            mng_info->loop_active[loop_level]=0;\n                            last_level=(-1);\n                            for (i=0; i < loop_level; i++)\n                              if (mng_info->loop_active[i] == 1)\n                                last_level=(short) i;\n                            loop_level=last_level;\n                          }\n                      }\n                  }\n              }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_CLON,4) == 0)\n          {\n            if (mng_info->clon_warning == 0)\n              (void) ThrowMagickException(&image->exception,GetMagickModule(),\n                CoderError,\"CLON is not implemented yet\",\"`%s'\",\n                image->filename);\n\n            mng_info->clon_warning++;\n          }\n\n        if (memcmp(type,mng_MAGN,4) == 0)\n          {\n            png_uint_16\n              magn_first,\n              magn_last,\n              magn_mb,\n              magn_ml,\n              magn_mr,\n              magn_mt,\n              magn_mx,\n              magn_my,\n              magn_methx,\n              magn_methy;\n\n            if (length > 1)\n              magn_first=(p[0] << 8) | p[1];\n\n            else\n              magn_first=0;\n\n            if (length > 3)\n              magn_last=(p[2] << 8) | p[3];\n\n            else\n              magn_last=magn_first;\n#ifndef MNG_OBJECT_BUFFERS\n            if (magn_first || magn_last)\n              if (mng_info->magn_warning == 0)\n                {\n                  (void) ThrowMagickException(&image->exception,\n                     GetMagickModule(),CoderError,\n                     \"MAGN is not implemented yet for nonzero objects\",\n                     \"`%s'\",image->filename);\n\n                   mng_info->magn_warning++;\n                }\n#endif\n            if (length > 4)\n              magn_methx=p[4];\n\n            else\n              magn_methx=0;\n\n            if (length > 6)\n              magn_mx=(p[5] << 8) | p[6];\n\n            else\n              magn_mx=1;\n\n            if (magn_mx == 0)\n              magn_mx=1;\n\n            if (length > 8)\n              magn_my=(p[7] << 8) | p[8];\n\n            else\n              magn_my=magn_mx;\n\n            if (magn_my == 0)\n              magn_my=1;\n\n            if (length > 10)\n              magn_ml=(p[9] << 8) | p[10];\n\n            else\n              magn_ml=magn_mx;\n\n            if (magn_ml == 0)\n              magn_ml=1;\n\n            if (length > 12)\n              magn_mr=(p[11] << 8) | p[12];\n\n            else\n              magn_mr=magn_mx;\n\n            if (magn_mr == 0)\n              magn_mr=1;\n\n            if (length > 14)\n              magn_mt=(p[13] << 8) | p[14];\n\n            else\n              magn_mt=magn_my;\n\n            if (magn_mt == 0)\n              magn_mt=1;\n\n            if (length > 16)\n              magn_mb=(p[15] << 8) | p[16];\n\n            else\n              magn_mb=magn_my;\n\n            if (magn_mb == 0)\n              magn_mb=1;\n\n            if (length > 17)\n              magn_methy=p[17];\n\n            else\n              magn_methy=magn_methx;\n\n\n            if (magn_methx > 5 || magn_methy > 5)\n              if (mng_info->magn_warning == 0)\n                {\n                  (void) ThrowMagickException(&image->exception,\n                     GetMagickModule(),CoderError,\n                     \"Unknown MAGN method in MNG datastream\",\"`%s'\",\n                     image->filename);\n\n                   mng_info->magn_warning++;\n                }\n#ifdef MNG_OBJECT_BUFFERS\n          /* Magnify existing objects in the range magn_first to magn_last */\n#endif\n            if (magn_first == 0 || magn_last == 0)\n              {\n                /* Save the magnification factors for object 0 */\n                mng_info->magn_mb=magn_mb;\n                mng_info->magn_ml=magn_ml;\n                mng_info->magn_mr=magn_mr;\n                mng_info->magn_mt=magn_mt;\n                mng_info->magn_mx=magn_mx;\n                mng_info->magn_my=magn_my;\n                mng_info->magn_methx=magn_methx;\n                mng_info->magn_methy=magn_methy;\n              }\n          }\n\n        if (memcmp(type,mng_PAST,4) == 0)\n          {\n            if (mng_info->past_warning == 0)\n              (void) ThrowMagickException(&image->exception,GetMagickModule(),\n                CoderError,\"PAST is not implemented yet\",\"`%s'\",\n                image->filename);\n\n            mng_info->past_warning++;\n          }\n\n        if (memcmp(type,mng_SHOW,4) == 0)\n          {\n            if (mng_info->show_warning == 0)\n              (void) ThrowMagickException(&image->exception,GetMagickModule(),\n                CoderError,\"SHOW is not implemented yet\",\"`%s'\",\n                image->filename);\n\n            mng_info->show_warning++;\n          }\n\n        if (memcmp(type,mng_sBIT,4) == 0)\n          {\n            if (length < 4)\n              mng_info->have_global_sbit=MagickFalse;\n\n            else\n              {\n                mng_info->global_sbit.gray=p[0];\n                mng_info->global_sbit.red=p[0];\n                mng_info->global_sbit.green=p[1];\n                mng_info->global_sbit.blue=p[2];\n                mng_info->global_sbit.alpha=p[3];\n                mng_info->have_global_sbit=MagickTrue;\n             }\n          }\n        if (memcmp(type,mng_pHYs,4) == 0)\n          {\n            if (length > 8)\n              {\n                mng_info->global_x_pixels_per_unit=\n                    (size_t) mng_get_long(p);\n                mng_info->global_y_pixels_per_unit=\n                    (size_t) mng_get_long(&p[4]);\n                mng_info->global_phys_unit_type=p[8];\n                mng_info->have_global_phys=MagickTrue;\n              }\n\n            else\n              mng_info->have_global_phys=MagickFalse;\n          }\n        if (memcmp(type,mng_pHYg,4) == 0)\n          {\n            if (mng_info->phyg_warning == 0)\n              (void) ThrowMagickException(&image->exception,GetMagickModule(),\n                CoderError,\"pHYg is not implemented.\",\"`%s'\",image->filename);\n\n            mng_info->phyg_warning++;\n          }\n        if (memcmp(type,mng_BASI,4) == 0)\n          {\n            skip_to_iend=MagickTrue;\n\n            if (mng_info->basi_warning == 0)\n              (void) ThrowMagickException(&image->exception,GetMagickModule(),\n                CoderError,\"BASI is not implemented yet\",\"`%s'\",\n                image->filename);\n\n            mng_info->basi_warning++;\n#ifdef MNG_BASI_SUPPORTED\n            if (length > 11)\n              {\n                basi_width=(size_t) ((p[0] << 24) | (p[1] << 16) |\n                   (p[2] << 8) | p[3]);\n                basi_height=(size_t) ((p[4] << 24) | (p[5] << 16) |\n                   (p[6] << 8) | p[7]);\n                basi_color_type=p[8];\n                basi_compression_method=p[9];\n                basi_filter_type=p[10];\n                basi_interlace_method=p[11];\n              }\n            if (length > 13)\n              basi_red=(p[12] << 8) & p[13];\n\n            else\n              basi_red=0;\n\n            if (length > 15)\n              basi_green=(p[14] << 8) & p[15];\n\n            else\n              basi_green=0;\n\n            if (length > 17)\n              basi_blue=(p[16] << 8) & p[17];\n\n            else\n              basi_blue=0;\n\n            if (length > 19)\n              basi_alpha=(p[18] << 8) & p[19];\n\n            else\n              {\n                if (basi_sample_depth == 16)\n                  basi_alpha=65535L;\n                else\n                  basi_alpha=255;\n              }\n\n            if (length > 20)\n              basi_viewable=p[20];\n\n            else\n              basi_viewable=0;\n\n#endif\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_IHDR,4)\n#if defined(JNG_SUPPORTED)\n            && memcmp(type,mng_JHDR,4)\n#endif\n            )\n          {\n            /* Not an IHDR or JHDR chunk */\n            if (length != 0)\n              chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            continue;\n          }\n/* Process IHDR */\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Processing %c%c%c%c chunk\",type[0],type[1],type[2],type[3]);\n\n        mng_info->exists[object_id]=MagickTrue;\n        mng_info->viewable[object_id]=MagickTrue;\n\n        if (mng_info->invisible[object_id])\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Skipping invisible object\");\n\n            skip_to_iend=MagickTrue;\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n#if defined(MNG_INSERT_LAYERS)\n        if (length < 8)\n          {\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n          }\n\n        image_width=(size_t) mng_get_long(p);\n        image_height=(size_t) mng_get_long(&p[4]);\n#endif\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        /*\n          Insert a transparent background layer behind the entire animation\n          if it is not full screen.\n        */\n#if defined(MNG_INSERT_LAYERS)\n        if (insert_layers && mng_type && first_mng_object)\n          {\n            if ((mng_info->clip.left > 0) || (mng_info->clip.top > 0) ||\n                (image_width < mng_info->mng_width) ||\n                (mng_info->clip.right < (ssize_t) mng_info->mng_width) ||\n                (image_height < mng_info->mng_height) ||\n                (mng_info->clip.bottom < (ssize_t) mng_info->mng_height))\n              {\n                if (GetAuthenticPixelQueue(image) != (PixelPacket *) NULL)\n                  {\n                    /*\n                      Allocate next image structure.\n                    */\n                    AcquireNextImage(image_info,image);\n\n                    if (GetNextImageInList(image) == (Image *) NULL)\n                      return(DestroyImageList(image));\n\n                    image=SyncNextImageInList(image);\n                  }\n                mng_info->image=image;\n\n                if (term_chunk_found)\n                  {\n                    image->start_loop=MagickTrue;\n                    image->iterations=mng_iterations;\n                    term_chunk_found=MagickFalse;\n                  }\n\n                else\n                    image->start_loop=MagickFalse;\n\n                /* Make a background rectangle.  */\n\n                image->delay=0;\n                image->columns=mng_info->mng_width;\n                image->rows=mng_info->mng_height;\n                image->page.width=mng_info->mng_width;\n                image->page.height=mng_info->mng_height;\n                image->page.x=0;\n                image->page.y=0;\n                image->background_color=mng_background_color;\n                (void) SetImageBackgroundColor(image);\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  Inserted transparent background layer, W=%.20g, H=%.20g\",\n                    (double) mng_info->mng_width,(double) mng_info->mng_height);\n              }\n          }\n        /*\n          Insert a background layer behind the upcoming image if\n          framing_mode is 3, and we haven't already inserted one.\n        */\n        if (insert_layers && (mng_info->framing_mode == 3) &&\n                (subframe_width) && (subframe_height) && (simplicity == 0 ||\n                (simplicity & 0x08)))\n          {\n            if (GetAuthenticPixelQueue(image) != (PixelPacket *) NULL)\n            {\n              /*\n                Allocate next image structure.\n              */\n              AcquireNextImage(image_info,image);\n\n              if (GetNextImageInList(image) == (Image *) NULL)\n                return(DestroyImageList(image));\n\n              image=SyncNextImageInList(image);\n            }\n\n            mng_info->image=image;\n\n            if (term_chunk_found)\n              {\n                image->start_loop=MagickTrue;\n                image->iterations=mng_iterations;\n                term_chunk_found=MagickFalse;\n              }\n\n            else\n                image->start_loop=MagickFalse;\n\n            image->delay=0;\n            image->columns=subframe_width;\n            image->rows=subframe_height;\n            image->page.width=subframe_width;\n            image->page.height=subframe_height;\n            image->page.x=mng_info->clip.left;\n            image->page.y=mng_info->clip.top;\n            image->background_color=mng_background_color;\n            image->matte=MagickFalse;\n            (void) SetImageBackgroundColor(image);\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Insert background layer, L=%.20g, R=%.20g T=%.20g, B=%.20g\",\n                (double) mng_info->clip.left,(double) mng_info->clip.right,\n                (double) mng_info->clip.top,(double) mng_info->clip.bottom);\n          }\n#endif /* MNG_INSERT_LAYERS */\n        first_mng_object=MagickFalse;\n\n        if (GetAuthenticPixelQueue(image) != (PixelPacket *) NULL)\n          {\n            /*\n              Allocate next image structure.\n            */\n            AcquireNextImage(image_info,image);\n\n            if (GetNextImageInList(image) == (Image *) NULL)\n              return(DestroyImageList(image));\n\n            image=SyncNextImageInList(image);\n          }\n        mng_info->image=image;\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n\n        if (status == MagickFalse)\n          break;\n\n        if (term_chunk_found)\n          {\n            image->start_loop=MagickTrue;\n            term_chunk_found=MagickFalse;\n          }\n\n        else\n            image->start_loop=MagickFalse;\n\n        if (mng_info->framing_mode == 1 || mng_info->framing_mode == 3)\n          {\n            image->delay=frame_delay;\n            frame_delay=default_frame_delay;\n          }\n\n        else\n          image->delay=0;\n\n        image->page.width=mng_info->mng_width;\n        image->page.height=mng_info->mng_height;\n        image->page.x=mng_info->x_off[object_id];\n        image->page.y=mng_info->y_off[object_id];\n        image->iterations=mng_iterations;\n\n        /*\n          Seek back to the beginning of the IHDR or JHDR chunk's length field.\n        */\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Seeking back to beginning of %c%c%c%c chunk\",type[0],type[1],\n            type[2],type[3]);\n\n        offset=SeekBlob(image,-((ssize_t) length+12),SEEK_CUR);\n\n        if (offset < 0)\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n\n    mng_info->image=image;\n    mng_info->mng_type=mng_type;\n    mng_info->object_id=object_id;\n\n    if (memcmp(type,mng_IHDR,4) == 0)\n      image=ReadOnePNGImage(mng_info,image_info,exception);\n\n#if defined(JNG_SUPPORTED)\n    else\n      image=ReadOneJNGImage(mng_info,image_info,exception);\n#endif\n\n    if (image == (Image *) NULL)\n      {\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"exit ReadJNGImage() with error\");\n\n        return((Image *) NULL);\n      }\n\n    if (image->columns == 0 || image->rows == 0)\n      {\n        (void) CloseBlob(image);\n        return(DestroyImageList(image));\n      }\n\n    mng_info->image=image;\n\n    if (mng_type)\n      {\n        MngBox\n          crop_box;\n\n        if (mng_info->magn_methx || mng_info->magn_methy)\n          {\n            png_uint_32\n               magnified_height,\n               magnified_width;\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Processing MNG MAGN chunk\");\n\n            if (mng_info->magn_methx == 1)\n              {\n                magnified_width=mng_info->magn_ml;\n\n                if (image->columns > 1)\n                   magnified_width += mng_info->magn_mr;\n\n                if (image->columns > 2)\n                   magnified_width += (png_uint_32)\n                      ((image->columns-2)*(mng_info->magn_mx));\n              }\n\n            else\n              {\n                magnified_width=(png_uint_32) image->columns;\n\n                if (image->columns > 1)\n                   magnified_width += mng_info->magn_ml-1;\n\n                if (image->columns > 2)\n                   magnified_width += mng_info->magn_mr-1;\n\n                if (image->columns > 3)\n                   magnified_width += (png_uint_32)\n                      ((image->columns-3)*(mng_info->magn_mx-1));\n              }\n\n            if (mng_info->magn_methy == 1)\n              {\n                magnified_height=mng_info->magn_mt;\n\n                if (image->rows > 1)\n                   magnified_height += mng_info->magn_mb;\n\n                if (image->rows > 2)\n                   magnified_height += (png_uint_32)\n                      ((image->rows-2)*(mng_info->magn_my));\n              }\n\n            else\n              {\n                magnified_height=(png_uint_32) image->rows;\n\n                if (image->rows > 1)\n                   magnified_height += mng_info->magn_mt-1;\n\n                if (image->rows > 2)\n                   magnified_height += mng_info->magn_mb-1;\n\n                if (image->rows > 3)\n                   magnified_height += (png_uint_32)\n                      ((image->rows-3)*(mng_info->magn_my-1));\n              }\n\n            if (magnified_height > image->rows ||\n                magnified_width > image->columns)\n              {\n                Image\n                  *large_image;\n\n                int\n                  yy;\n\n                ssize_t\n                  m,\n                  y;\n\n                register ssize_t\n                  x;\n\n                register PixelPacket\n                  *n,\n                  *q;\n\n                PixelPacket\n                  *next,\n                  *prev;\n\n                png_uint_16\n                  magn_methx,\n                  magn_methy;\n\n                /* Allocate next image structure.  */\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Allocate magnified image\");\n\n                AcquireNextImage(image_info,image);\n\n                if (GetNextImageInList(image) == (Image *) NULL)\n                  return(DestroyImageList(image));\n\n                large_image=SyncNextImageInList(image);\n\n                large_image->columns=magnified_width;\n                large_image->rows=magnified_height;\n\n                magn_methx=mng_info->magn_methx;\n                magn_methy=mng_info->magn_methy;\n\n#if (MAGICKCORE_QUANTUM_DEPTH > 16)\n#define QM unsigned short\n                if (magn_methx != 1 || magn_methy != 1)\n                  {\n                  /*\n                     Scale pixels to unsigned shorts to prevent\n                     overflow of intermediate values of interpolations\n                  */\n                     for (y=0; y < (ssize_t) image->rows; y++)\n                     {\n                       q=GetAuthenticPixels(image,0,y,image->columns,1,\n                          exception);\n\n                       for (x=(ssize_t) image->columns-1; x >= 0; x--)\n                       {\n                          SetPixelRed(q,ScaleQuantumToShort(\n                            GetPixelRed(q)));\n                          SetPixelGreen(q,ScaleQuantumToShort(\n                            GetPixelGreen(q)));\n                          SetPixelBlue(q,ScaleQuantumToShort(\n                            GetPixelBlue(q)));\n                          SetPixelOpacity(q,ScaleQuantumToShort(\n                            GetPixelOpacity(q)));\n                          q++;\n                       }\n\n                       if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                         break;\n                     }\n                  }\n#else\n#define QM Quantum\n#endif\n\n                if (image->matte != MagickFalse)\n                   (void) SetImageBackgroundColor(large_image);\n\n                else\n                  {\n                    large_image->background_color.opacity=OpaqueOpacity;\n                    (void) SetImageBackgroundColor(large_image);\n\n                    if (magn_methx == 4)\n                      magn_methx=2;\n\n                    if (magn_methx == 5)\n                      magn_methx=3;\n\n                    if (magn_methy == 4)\n                      magn_methy=2;\n\n                    if (magn_methy == 5)\n                      magn_methy=3;\n                  }\n\n                /* magnify the rows into the right side of the large image */\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Magnify the rows to %.20g\",(double) large_image->rows);\n                m=(ssize_t) mng_info->magn_mt;\n                yy=0;\n                length=(size_t) image->columns;\n                next=(PixelPacket *) AcquireQuantumMemory(length,sizeof(*next));\n                prev=(PixelPacket *) AcquireQuantumMemory(length,sizeof(*prev));\n\n                if ((prev == (PixelPacket *) NULL) ||\n                    (next == (PixelPacket *) NULL))\n                  {\n                     image=DestroyImageList(image);\n                     ThrowReaderException(ResourceLimitError,\n                       \"MemoryAllocationFailed\");\n                  }\n\n                n=GetAuthenticPixels(image,0,0,image->columns,1,exception);\n                (void) CopyMagickMemory(next,n,length);\n\n                for (y=0; y < (ssize_t) image->rows; y++)\n                {\n                  if (y == 0)\n                    m=(ssize_t) mng_info->magn_mt;\n\n                  else if (magn_methy > 1 && y == (ssize_t) image->rows-2)\n                    m=(ssize_t) mng_info->magn_mb;\n\n                  else if (magn_methy <= 1 && y == (ssize_t) image->rows-1)\n                    m=(ssize_t) mng_info->magn_mb;\n\n                  else if (magn_methy > 1 && y == (ssize_t) image->rows-1)\n                    m=1;\n\n                  else\n                    m=(ssize_t) mng_info->magn_my;\n\n                  n=prev;\n                  prev=next;\n                  next=n;\n\n                  if (y < (ssize_t) image->rows-1)\n                    {\n                      n=GetAuthenticPixels(image,0,y+1,image->columns,1,\n                          exception);\n                      (void) CopyMagickMemory(next,n,length);\n                    }\n\n                  for (i=0; i < m; i++, yy++)\n                  {\n                    register PixelPacket\n                      *pixels;\n\n                    assert(yy < (ssize_t) large_image->rows);\n                    pixels=prev;\n                    n=next;\n                    q=GetAuthenticPixels(large_image,0,yy,large_image->columns,\n                      1,exception);\n                    q+=(large_image->columns-image->columns);\n\n                    for (x=(ssize_t) image->columns-1; x >= 0; x--)\n                    {\n                      /* To do: get color as function of indexes[x] */\n                      /*\n                      if (image->storage_class == PseudoClass)\n                        {\n                        }\n                      */\n\n                      if (magn_methy <= 1)\n                        {\n                          /* replicate previous */\n                          SetPixelRGBO(q,(pixels));\n                        }\n\n                      else if (magn_methy == 2 || magn_methy == 4)\n                        {\n                          if (i == 0)\n                            {\n                              SetPixelRGBO(q,(pixels));\n                            }\n\n                          else\n                            {\n                              /* Interpolate */\n                              SetPixelRed(q,\n                                 ((QM) (((ssize_t)\n                                 (2*i*(GetPixelRed(n)\n                                 -GetPixelRed(pixels)+m))/\n                                 ((ssize_t) (m*2))\n                                 +GetPixelRed(pixels)))));\n                              SetPixelGreen(q,\n                                 ((QM) (((ssize_t)\n                                 (2*i*(GetPixelGreen(n)\n                                 -GetPixelGreen(pixels)+m))/\n                                 ((ssize_t) (m*2))\n                                 +GetPixelGreen(pixels)))));\n                              SetPixelBlue(q,\n                                 ((QM) (((ssize_t)\n                                 (2*i*(GetPixelBlue(n)\n                                 -GetPixelBlue(pixels)+m))/\n                                 ((ssize_t) (m*2))\n                                 +GetPixelBlue(pixels)))));\n\n                              if (image->matte != MagickFalse)\n                                 SetPixelOpacity(q,\n                                    ((QM) (((ssize_t)\n                                    (2*i*(GetPixelOpacity(n)\n                                    -GetPixelOpacity(pixels)+m))\n                                    /((ssize_t) (m*2))+\n                                   GetPixelOpacity(pixels)))));\n                            }\n\n                          if (magn_methy == 4)\n                            {\n                              /* Replicate nearest */\n                              if (i <= ((m+1) << 1))\n                                 SetPixelOpacity(q,\n                                 (*pixels).opacity+0);\n                              else\n                                 SetPixelOpacity(q,\n                                 (*n).opacity+0);\n                            }\n                        }\n\n                      else /* if (magn_methy == 3 || magn_methy == 5) */\n                        {\n                          /* Replicate nearest */\n                          if (i <= ((m+1) << 1))\n                          {\n                             SetPixelRGBO(q,(pixels));\n                          }\n\n                          else\n                          {\n                             SetPixelRGBO(q,(n));\n                          }\n\n                          if (magn_methy == 5)\n                            {\n                              SetPixelOpacity(q,\n                                 (QM) (((ssize_t) (2*i*\n                                 (GetPixelOpacity(n)\n                                 -GetPixelOpacity(pixels))\n                                 +m))/((ssize_t) (m*2))\n                                 +GetPixelOpacity(pixels)));\n                            }\n                        }\n                      n++;\n                      q++;\n                      pixels++;\n                    } /* x */\n\n                    if (SyncAuthenticPixels(large_image,exception) == 0)\n                      break;\n\n                  } /* i */\n                } /* y */\n\n                prev=(PixelPacket *) RelinquishMagickMemory(prev);\n                next=(PixelPacket *) RelinquishMagickMemory(next);\n\n                length=image->columns;\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Delete original image\");\n\n                DeleteImageFromList(&image);\n\n                image=large_image;\n\n                mng_info->image=image;\n\n                /* magnify the columns */\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Magnify the columns to %.20g\",(double) image->columns);\n\n                for (y=0; y < (ssize_t) image->rows; y++)\n                {\n                  register PixelPacket\n                    *pixels;\n\n                  q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n                  pixels=q+(image->columns-length);\n                  n=pixels+1;\n\n                  for (x=(ssize_t) (image->columns-length);\n                    x < (ssize_t) image->columns; x++)\n                  {\n                    /* To do: Rewrite using Get/Set***PixelComponent() */\n\n                    if (x == (ssize_t) (image->columns-length))\n                      m=(ssize_t) mng_info->magn_ml;\n\n                    else if (magn_methx > 1 && x == (ssize_t) image->columns-2)\n                      m=(ssize_t) mng_info->magn_mr;\n\n                    else if (magn_methx <= 1 && x == (ssize_t) image->columns-1)\n                      m=(ssize_t) mng_info->magn_mr;\n\n                    else if (magn_methx > 1 && x == (ssize_t) image->columns-1)\n                      m=1;\n\n                    else\n                      m=(ssize_t) mng_info->magn_mx;\n\n                    for (i=0; i < m; i++)\n                    {\n                      if (magn_methx <= 1)\n                        {\n                          /* replicate previous */\n                          SetPixelRGBO(q,(pixels));\n                        }\n\n                      else if (magn_methx == 2 || magn_methx == 4)\n                        {\n                          if (i == 0)\n                          {\n                             SetPixelRGBO(q,(pixels));\n                          }\n\n                          /* To do: Rewrite using Get/Set***PixelComponent() */\n                          else\n                            {\n                              /* Interpolate */\n                              SetPixelRed(q,\n                                 (QM) ((2*i*(\n                                 GetPixelRed(n)\n                                 -GetPixelRed(pixels))+m)\n                                 /((ssize_t) (m*2))+\n                                 GetPixelRed(pixels)));\n\n                              SetPixelGreen(q,\n                                 (QM) ((2*i*(\n                                 GetPixelGreen(n)\n                                 -GetPixelGreen(pixels))+m)\n                                 /((ssize_t) (m*2))+\n                                 GetPixelGreen(pixels)));\n\n                              SetPixelBlue(q,\n                                 (QM) ((2*i*(\n                                 GetPixelBlue(n)\n                                 -GetPixelBlue(pixels))+m)\n                                 /((ssize_t) (m*2))+\n                                 GetPixelBlue(pixels)));\n                              if (image->matte != MagickFalse)\n                                 SetPixelOpacity(q,\n                                   (QM) ((2*i*(\n                                   GetPixelOpacity(n)\n                                   -GetPixelOpacity(pixels))+m)\n                                   /((ssize_t) (m*2))+\n                                   GetPixelOpacity(pixels)));\n                            }\n\n                          if (magn_methx == 4)\n                            {\n                              /* Replicate nearest */\n                              if (i <= ((m+1) << 1))\n                              {\n                                 SetPixelOpacity(q,\n                                 GetPixelOpacity(pixels)+0);\n                              }\n                              else\n                              {\n                                 SetPixelOpacity(q,\n                                 GetPixelOpacity(n)+0);\n                              }\n                            }\n                        }\n\n                      else /* if (magn_methx == 3 || magn_methx == 5) */\n                        {\n                          /* Replicate nearest */\n                          if (i <= ((m+1) << 1))\n                          {\n                             SetPixelRGBO(q,(pixels));\n                          }\n\n                          else\n                          {\n                             SetPixelRGBO(q,(n));\n                          }\n\n                          if (magn_methx == 5)\n                            {\n                              /* Interpolate */\n                              SetPixelOpacity(q,\n                                 (QM) ((2*i*( GetPixelOpacity(n)\n                                 -GetPixelOpacity(pixels))+m)/\n                                 ((ssize_t) (m*2))\n                                 +GetPixelOpacity(pixels)));\n                            }\n                        }\n                      q++;\n                    }\n                    n++;\n                  }\n\n                  if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                    break;\n                }\n#if (MAGICKCORE_QUANTUM_DEPTH > 16)\n              if (magn_methx != 1 || magn_methy != 1)\n                {\n                /*\n                   Rescale pixels to Quantum\n                */\n                   for (y=0; y < (ssize_t) image->rows; y++)\n                   {\n                     q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n                     for (x=(ssize_t) image->columns-1; x >= 0; x--)\n                     {\n                        SetPixelRed(q,ScaleShortToQuantum(\n                            GetPixelRed(q)));\n                        SetPixelGreen(q,ScaleShortToQuantum(\n                            GetPixelGreen(q)));\n                        SetPixelBlue(q,ScaleShortToQuantum(\n                            GetPixelBlue(q)));\n                        SetPixelOpacity(q,ScaleShortToQuantum(\n                            GetPixelOpacity(q)));\n                        q++;\n                     }\n\n                     if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                       break;\n                   }\n                }\n#endif\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  Finished MAGN processing\");\n              }\n          }\n\n        /*\n          Crop_box is with respect to the upper left corner of the MNG.\n        */\n        crop_box.left=mng_info->image_box.left+mng_info->x_off[object_id];\n        crop_box.right=mng_info->image_box.right+mng_info->x_off[object_id];\n        crop_box.top=mng_info->image_box.top+mng_info->y_off[object_id];\n        crop_box.bottom=mng_info->image_box.bottom+mng_info->y_off[object_id];\n        crop_box=mng_minimum_box(crop_box,mng_info->clip);\n        crop_box=mng_minimum_box(crop_box,mng_info->frame);\n        crop_box=mng_minimum_box(crop_box,mng_info->object_clip[object_id]);\n        if ((crop_box.left != (mng_info->image_box.left\n            +mng_info->x_off[object_id])) ||\n            (crop_box.right != (mng_info->image_box.right\n            +mng_info->x_off[object_id])) ||\n            (crop_box.top != (mng_info->image_box.top\n            +mng_info->y_off[object_id])) ||\n            (crop_box.bottom != (mng_info->image_box.bottom\n            +mng_info->y_off[object_id])))\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Crop the PNG image\");\n\n            if ((crop_box.left < crop_box.right) &&\n                (crop_box.top < crop_box.bottom))\n              {\n                Image\n                  *im;\n\n                RectangleInfo\n                  crop_info;\n\n                /*\n                  Crop_info is with respect to the upper left corner of\n                  the image.\n                */\n                crop_info.x=(crop_box.left-mng_info->x_off[object_id]);\n                crop_info.y=(crop_box.top-mng_info->y_off[object_id]);\n                crop_info.width=(size_t) (crop_box.right-crop_box.left);\n                crop_info.height=(size_t) (crop_box.bottom-crop_box.top);\n                image->page.width=image->columns;\n                image->page.height=image->rows;\n                image->page.x=0;\n                image->page.y=0;\n                im=CropImage(image,&crop_info,exception);\n\n                if (im != (Image *) NULL)\n                  {\n                    image->columns=im->columns;\n                    image->rows=im->rows;\n                    im=DestroyImage(im);\n                    image->page.width=image->columns;\n                    image->page.height=image->rows;\n                    image->page.x=crop_box.left;\n                    image->page.y=crop_box.top;\n                  }\n              }\n\n            else\n              {\n                /*\n                  No pixels in crop area.  The MNG spec still requires\n                  a layer, though, so make a single transparent pixel in\n                  the top left corner.\n                */\n                image->columns=1;\n                image->rows=1;\n                image->colors=2;\n                (void) SetImageBackgroundColor(image);\n                image->page.width=1;\n                image->page.height=1;\n                image->page.x=0;\n                image->page.y=0;\n              }\n          }\n#ifndef PNG_READ_EMPTY_PLTE_SUPPORTED\n        image=mng_info->image;\n#endif\n      }\n\n#if (MAGICKCORE_QUANTUM_DEPTH > 16)\n      /* PNG does not handle depths greater than 16 so reduce it even\n       * if lossy, and promote any depths > 8 to 16.\n       */\n      if (image->depth > 16)\n         image->depth=16;\n#endif\n\n#if (MAGICKCORE_QUANTUM_DEPTH > 8)\n      if (image->depth > 8)\n        {\n          /* To do: fill low byte properly */\n          image->depth=16;\n        }\n\n      if (LosslessReduceDepthOK(image) != MagickFalse)\n         image->depth = 8;\n#endif\n\n      GetImageException(image,exception);\n\n      if (image_info->number_scenes != 0)\n        {\n          if (mng_info->scenes_found >\n             (ssize_t) (image_info->first_scene+image_info->number_scenes))\n            break;\n        }\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Finished reading image datastream.\");\n\n  } while (LocaleCompare(image_info->magick,\"MNG\") == 0);\n\n  (void) CloseBlob(image);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Finished reading all image datastreams.\");\n\n#if defined(MNG_INSERT_LAYERS)\n  if (insert_layers && !mng_info->image_found && (mng_info->mng_width) &&\n       (mng_info->mng_height))\n    {\n      /*\n        Insert a background layer if nothing else was found.\n      */\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  No images found.  Inserting a background layer.\");\n\n      if (GetAuthenticPixelQueue(image) != (PixelPacket *) NULL)\n        {\n          /*\n            Allocate next image structure.\n          */\n          AcquireNextImage(image_info,image);\n          if (GetNextImageInList(image) == (Image *) NULL)\n            {\n              if (logging != MagickFalse)\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Allocation failed, returning NULL.\");\n\n              return(DestroyImageList(image));\n            }\n          image=SyncNextImageInList(image);\n        }\n      image->columns=mng_info->mng_width;\n      image->rows=mng_info->mng_height;\n      image->page.width=mng_info->mng_width;\n      image->page.height=mng_info->mng_height;\n      image->page.x=0;\n      image->page.y=0;\n      image->background_color=mng_background_color;\n      image->matte=MagickFalse;\n\n      if (image_info->ping == MagickFalse)\n        (void) SetImageBackgroundColor(image);\n\n      mng_info->image_found++;\n    }\n#endif\n  image->iterations=mng_iterations;\n\n  if (mng_iterations == 1)\n    image->start_loop=MagickTrue;\n\n  while (GetPreviousImageInList(image) != (Image *) NULL)\n  {\n    image_count++;\n    if (image_count > 10*mng_info->image_found)\n      {\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  No beginning\");\n\n        (void) ThrowMagickException(&image->exception,GetMagickModule(),\n          CoderError,\"Linked list is corrupted, beginning of list not found\",\n          \"`%s'\",image_info->filename);\n\n        return(DestroyImageList(image));\n      }\n\n    image=GetPreviousImageInList(image);\n\n    if (GetNextImageInList(image) == (Image *) NULL)\n      {\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  Corrupt list\");\n\n        (void) ThrowMagickException(&image->exception,GetMagickModule(),\n          CoderError,\"Linked list is corrupted; next_image is NULL\",\"`%s'\",\n          image_info->filename);\n      }\n  }\n\n  if (mng_info->ticks_per_second && mng_info->image_found > 1 &&\n             GetNextImageInList(image) ==\n     (Image *) NULL)\n    {\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  First image null\");\n\n      (void) ThrowMagickException(&image->exception,GetMagickModule(),\n        CoderError,\"image->next for first image is NULL but shouldn't be.\",\n        \"`%s'\",image_info->filename);\n    }\n\n  if (mng_info->image_found == 0)\n    {\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  No visible images found.\");\n\n      (void) ThrowMagickException(&image->exception,GetMagickModule(),\n        CoderError,\"No visible images in file\",\"`%s'\",image_info->filename);\n\n      return(DestroyImageList(image));\n    }\n\n  if (mng_info->ticks_per_second)\n    final_delay=1UL*MagickMax(image->ticks_per_second,1L)*\n            final_delay/mng_info->ticks_per_second;\n\n  else\n    image->start_loop=MagickTrue;\n\n  /* Find final nonzero image delay */\n  final_image_delay=0;\n\n  while (GetNextImageInList(image) != (Image *) NULL)\n    {\n      if (image->delay)\n        final_image_delay=image->delay;\n\n      image=GetNextImageInList(image);\n    }\n\n  if (final_delay < final_image_delay)\n    final_delay=final_image_delay;\n\n  image->delay=final_delay;\n\n  if (logging != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  image->delay=%.20g, final_delay=%.20g\",(double) image->delay,\n        (double) final_delay);\n\n  if (logging != MagickFalse)\n    {\n      int\n        scene;\n\n      scene=0;\n      image=GetFirstImageInList(image);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Before coalesce:\");\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    scene 0 delay=%.20g\",(double) image->delay);\n\n      while (GetNextImageInList(image) != (Image *) NULL)\n      {\n        image=GetNextImageInList(image);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    scene %.20g delay=%.20g\",(double) scene++,(double) image->delay);\n      }\n    }\n\n  image=GetFirstImageInList(image);\n#ifdef MNG_COALESCE_LAYERS\n  if (insert_layers)\n    {\n      Image\n        *next_image,\n        *next;\n\n      size_t\n        scene;\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  Coalesce Images\");\n\n      scene=image->scene;\n      next_image=CoalesceImages(image,&image->exception);\n\n      if (next_image == (Image *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n      image=DestroyImageList(image);\n      image=next_image;\n\n      for (next=image; next != (Image *) NULL; next=next_image)\n      {\n         next->page.width=mng_info->mng_width;\n         next->page.height=mng_info->mng_height;\n         next->page.x=0;\n         next->page.y=0;\n         next->scene=scene++;\n         next_image=GetNextImageInList(next);\n\n         if (next_image == (Image *) NULL)\n           break;\n\n         if (next->delay == 0)\n           {\n             scene--;\n             next_image->previous=GetPreviousImageInList(next);\n             if (GetPreviousImageInList(next) == (Image *) NULL)\n               image=next_image;\n             else\n               next->previous->next=next_image;\n             next=DestroyImage(next);\n           }\n      }\n    }\n#endif\n\n  while (GetNextImageInList(image) != (Image *) NULL)\n      image=GetNextImageInList(image);\n\n  image->dispose=BackgroundDispose;\n\n  if (logging != MagickFalse)\n    {\n      int\n        scene;\n\n      scene=0;\n      image=GetFirstImageInList(image);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  After coalesce:\");\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    scene 0 delay=%.20g dispose=%.20g\",(double) image->delay,\n        (double) image->dispose);\n\n      while (GetNextImageInList(image) != (Image *) NULL)\n      {\n        image=GetNextImageInList(image);\n\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    scene %.20g delay=%.20g dispose=%.20g\",(double) scene++,\n          (double) image->delay,(double) image->dispose);\n      }\n   }\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  exit ReadOneJNGImage();\");\n\n  return(image);\n}\n",
    "cwe": [
      "CWE-125"
    ],
    "id": 757,
    "_valid_cwes": [
      "CWE-125"
    ]
  },
  {
    "cve_id": "CVE-2018-11380",
    "code_before_change": "struct symbol_t* MACH0_(get_symbols)(struct MACH0_(obj_t)* bin) {\n\tconst char *symstr;\n\tstruct symbol_t *symbols;\n\tint from, to, i, j, s, stridx, symbols_size, symbols_count;\n\tSdbHash *hash;\n\n\tif (!bin || !bin->symtab || !bin->symstr) {\n\t\treturn NULL;\n\t}\n\t/* parse symbol table */\n\t/* parse dynamic symbol table */\n\tsymbols_count = (bin->dysymtab.nextdefsym + \\\n\t\t\tbin->dysymtab.nlocalsym + \\\n\t\t\tbin->dysymtab.nundefsym );\n\tsymbols_count += bin->nsymtab;\n\tsymbols_size = (symbols_count + 1) * 2 * sizeof (struct symbol_t);\n\n\tif (symbols_size < 1) {\n\t\treturn NULL;\n\t}\n\tif (!(symbols = calloc (1, symbols_size))) {\n\t\treturn NULL;\n\t}\n\thash = sdb_ht_new ();\n\tj = 0; // symbol_idx\n\tfor (s = 0; s < 2; s++) {\n\t\tswitch (s) {\n\t\tcase 0:\n\t\t\tfrom = bin->dysymtab.iextdefsym;\n\t\t\tto = from + bin->dysymtab.nextdefsym;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tfrom = bin->dysymtab.ilocalsym;\n\t\t\tto = from + bin->dysymtab.nlocalsym;\n\t\t\tbreak;\n#if NOT_USED\n\t\tcase 2:\n\t\t\tfrom = bin->dysymtab.iundefsym;\n\t\t\tto = from + bin->dysymtab.nundefsym;\n\t\t\tbreak;\n#endif\n\t\t}\n\t\tif (from == to) {\n\t\t\tcontinue;\n\t\t}\n#define OLD 1\n#if OLD\n\t\tfrom = R_MIN (R_MAX (0, from), symbols_size / sizeof (struct symbol_t));\n\t\tto = R_MIN (to , symbols_size / sizeof (struct symbol_t));\n\t\tto = R_MIN (to, bin->nsymtab);\n#else\n\t\tfrom = R_MIN (R_MAX (0, from), symbols_size/sizeof (struct symbol_t));\n\t\tto = symbols_count; //symbols_size/sizeof(struct symbol_t);\n#endif\n\t\tint maxsymbols = symbols_size / sizeof (struct symbol_t);\n\t\tif (to > 0x500000) {\n\t\t\tbprintf (\"WARNING: corrupted mach0 header: symbol table is too big %d\\n\", to);\n\t\t\tfree (symbols);\n\t\t\tsdb_ht_free (hash);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (symbols_count >= maxsymbols) {\n\t\t\tsymbols_count = maxsymbols - 1;\n\t\t}\n\t\tfor (i = from; i < to && j < symbols_count; i++, j++) {\n\t\t\tsymbols[j].offset = addr_to_offset (bin, bin->symtab[i].n_value);\n\t\t\tsymbols[j].addr = bin->symtab[i].n_value;\n\t\t\tsymbols[j].size = 0; /* TODO: Is it anywhere? */\n\t\t\tif (bin->symtab[i].n_type & N_EXT) {\n\t\t\t\tsymbols[j].type = R_BIN_MACH0_SYMBOL_TYPE_EXT;\n\t\t\t} else {\n\t\t\t\tsymbols[j].type = R_BIN_MACH0_SYMBOL_TYPE_LOCAL;\n\t\t\t}\n\t\t\tstridx = bin->symtab[i].n_strx;\n\t\t\tif (stridx >= 0 && stridx < bin->symstrlen) {\n\t\t\t\tsymstr = (char*)bin->symstr + stridx;\n\t\t\t} else {\n\t\t\t\tsymstr = \"???\";\n\t\t\t}\n\t\t\t{\n\t\t\t\tint i = 0;\n\t\t\t\tint len = 0;\n\t\t\t\tlen = bin->symstrlen - stridx;\n\t\t\t\tif (len > 0) {\n\t\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\t\tif ((ut8)(symstr[i] & 0xff) == 0xff || !symstr[i]) {\n\t\t\t\t\t\t\tlen = i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tchar *symstr_dup = NULL;\n\t\t\t\t\tif (len > 0) {\n\t\t\t\t\t\tsymstr_dup = r_str_ndup (symstr, len);\n\t\t\t\t\t}\n\t\t\t\t\tif (!symstr_dup) {\n\t\t\t\t\t\tsymbols[j].name[0] = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_str_ncpy (symbols[j].name, symstr_dup, R_BIN_MACH0_STRING_LENGTH);\n\t\t\t\t\t\tr_str_filter (symbols[j].name, -1);\n\t\t\t\t\t\tsymbols[j].name[R_BIN_MACH0_STRING_LENGTH - 2] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tfree (symstr_dup);\n\t\t\t\t} else {\n\t\t\t\t\tsymbols[j].name[0] = 0;\n\t\t\t\t}\n\t\t\t\tsymbols[j].last = 0;\n\t\t\t}\n\t\t\tif (inSymtab (hash, symbols, symbols[j].name, symbols[j].addr)) {\n\t\t\t\tsymbols[j].name[0] = 0;\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\t}\n\tto = R_MIN (bin->nsymtab, bin->dysymtab.iundefsym + bin->dysymtab.nundefsym);\n\tfor (i = bin->dysymtab.iundefsym; i < to; i++) {\n\t\tif (j > symbols_count) {\n \t\t\tbprintf (\"mach0-get-symbols: error\\n\");\n \t\t\tbreak;\n \t\t}\n\t\tif (parse_import_stub(bin, &symbols[j], i))\n \t\t\tsymbols[j++].last = 0;\n \t}\n \n #if 1\n\tfor (i = 0; i < bin->nsymtab; i++) {\n\t\tstruct MACH0_(nlist) *st = &bin->symtab[i];\n#if 0\n\t\tbprintf (\"stridx %d -> section %d type %d value = %d\\n\",\n\t\t\tst->n_strx, st->n_sect, st->n_type, st->n_value);\n#endif\n\t\tstridx = st->n_strx;\n\t\tif (stridx >= 0 && stridx < bin->symstrlen) {\n\t\t\tsymstr = (char*)bin->symstr + stridx;\n\t\t} else {\n\t\t\tsymstr = \"???\";\n\t\t}\n\t\tint section = st->n_sect;\n\t\tif (section == 1 && j < symbols_count) { // text ??st->n_type == 1)\n\t\t\t/* is symbol */\n\t\t\tsymbols[j].addr = st->n_value; // + text_base;\n\t\t\tsymbols[j].offset = addr_to_offset (bin, symbols[j].addr);\n\t\t\tsymbols[j].size = 0; /* find next symbol and crop */\n\t\t\tif (st->n_type & N_EXT) {\n\t\t\t\tsymbols[j].type = R_BIN_MACH0_SYMBOL_TYPE_EXT;\n\t\t\t} else {\n\t\t\t\tsymbols[j].type = R_BIN_MACH0_SYMBOL_TYPE_LOCAL;\n\t\t\t}\n\t\t\tstrncpy (symbols[j].name, symstr, R_BIN_MACH0_STRING_LENGTH);\n\t\t\tsymbols[j].name[R_BIN_MACH0_STRING_LENGTH - 1] = 0;\n\t\t\tsymbols[j].last = 0;\n\t\t\tif (inSymtab (hash, symbols, symbols[j].name, symbols[j].addr)) {\n\t\t\t\tsymbols[j].name[0] = 0;\n\t\t\t} else {\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\tsdb_ht_free (hash);\n\tsymbols[j].last = 1;\n\treturn symbols;\n}\n",
    "code_after_change": "struct symbol_t* MACH0_(get_symbols)(struct MACH0_(obj_t)* bin) {\n\tconst char *symstr;\n\tstruct symbol_t *symbols;\n\tint from, to, i, j, s, stridx, symbols_size, symbols_count;\n\tSdbHash *hash;\n\n\tif (!bin || !bin->symtab || !bin->symstr) {\n\t\treturn NULL;\n\t}\n\t/* parse symbol table */\n\t/* parse dynamic symbol table */\n\tsymbols_count = (bin->dysymtab.nextdefsym + \\\n\t\t\tbin->dysymtab.nlocalsym + \\\n\t\t\tbin->dysymtab.nundefsym );\n\tsymbols_count += bin->nsymtab;\n\tsymbols_size = (symbols_count + 1) * 2 * sizeof (struct symbol_t);\n\n\tif (symbols_size < 1) {\n\t\treturn NULL;\n\t}\n\tif (!(symbols = calloc (1, symbols_size))) {\n\t\treturn NULL;\n\t}\n\thash = sdb_ht_new ();\n\tj = 0; // symbol_idx\n\tfor (s = 0; s < 2; s++) {\n\t\tswitch (s) {\n\t\tcase 0:\n\t\t\tfrom = bin->dysymtab.iextdefsym;\n\t\t\tto = from + bin->dysymtab.nextdefsym;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tfrom = bin->dysymtab.ilocalsym;\n\t\t\tto = from + bin->dysymtab.nlocalsym;\n\t\t\tbreak;\n#if NOT_USED\n\t\tcase 2:\n\t\t\tfrom = bin->dysymtab.iundefsym;\n\t\t\tto = from + bin->dysymtab.nundefsym;\n\t\t\tbreak;\n#endif\n\t\t}\n\t\tif (from == to) {\n\t\t\tcontinue;\n\t\t}\n#define OLD 1\n#if OLD\n\t\tfrom = R_MIN (R_MAX (0, from), symbols_size / sizeof (struct symbol_t));\n\t\tto = R_MIN (to , symbols_size / sizeof (struct symbol_t));\n\t\tto = R_MIN (to, bin->nsymtab);\n#else\n\t\tfrom = R_MIN (R_MAX (0, from), symbols_size/sizeof (struct symbol_t));\n\t\tto = symbols_count; //symbols_size/sizeof(struct symbol_t);\n#endif\n\t\tint maxsymbols = symbols_size / sizeof (struct symbol_t);\n\t\tif (to > 0x500000) {\n\t\t\tbprintf (\"WARNING: corrupted mach0 header: symbol table is too big %d\\n\", to);\n\t\t\tfree (symbols);\n\t\t\tsdb_ht_free (hash);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (symbols_count >= maxsymbols) {\n\t\t\tsymbols_count = maxsymbols - 1;\n\t\t}\n\t\tfor (i = from; i < to && j < symbols_count; i++, j++) {\n\t\t\tsymbols[j].offset = addr_to_offset (bin, bin->symtab[i].n_value);\n\t\t\tsymbols[j].addr = bin->symtab[i].n_value;\n\t\t\tsymbols[j].size = 0; /* TODO: Is it anywhere? */\n\t\t\tif (bin->symtab[i].n_type & N_EXT) {\n\t\t\t\tsymbols[j].type = R_BIN_MACH0_SYMBOL_TYPE_EXT;\n\t\t\t} else {\n\t\t\t\tsymbols[j].type = R_BIN_MACH0_SYMBOL_TYPE_LOCAL;\n\t\t\t}\n\t\t\tstridx = bin->symtab[i].n_strx;\n\t\t\tif (stridx >= 0 && stridx < bin->symstrlen) {\n\t\t\t\tsymstr = (char*)bin->symstr + stridx;\n\t\t\t} else {\n\t\t\t\tsymstr = \"???\";\n\t\t\t}\n\t\t\t{\n\t\t\t\tint i = 0;\n\t\t\t\tint len = 0;\n\t\t\t\tlen = bin->symstrlen - stridx;\n\t\t\t\tif (len > 0) {\n\t\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\t\tif ((ut8)(symstr[i] & 0xff) == 0xff || !symstr[i]) {\n\t\t\t\t\t\t\tlen = i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tchar *symstr_dup = NULL;\n\t\t\t\t\tif (len > 0) {\n\t\t\t\t\t\tsymstr_dup = r_str_ndup (symstr, len);\n\t\t\t\t\t}\n\t\t\t\t\tif (!symstr_dup) {\n\t\t\t\t\t\tsymbols[j].name[0] = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_str_ncpy (symbols[j].name, symstr_dup, R_BIN_MACH0_STRING_LENGTH);\n\t\t\t\t\t\tr_str_filter (symbols[j].name, -1);\n\t\t\t\t\t\tsymbols[j].name[R_BIN_MACH0_STRING_LENGTH - 2] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tfree (symstr_dup);\n\t\t\t\t} else {\n\t\t\t\t\tsymbols[j].name[0] = 0;\n\t\t\t\t}\n\t\t\t\tsymbols[j].last = 0;\n\t\t\t}\n\t\t\tif (inSymtab (hash, symbols, symbols[j].name, symbols[j].addr)) {\n\t\t\t\tsymbols[j].name[0] = 0;\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\t}\n\tto = R_MIN (bin->nsymtab, bin->dysymtab.iundefsym + bin->dysymtab.nundefsym);\n\tfor (i = bin->dysymtab.iundefsym; i < to; i++) {\n\t\tif (j > symbols_count) {\n \t\t\tbprintf (\"mach0-get-symbols: error\\n\");\n \t\t\tbreak;\n \t\t}\n\t\tif (parse_import_stub(bin, &symbols[j], i)) {\n \t\t\tsymbols[j++].last = 0;\n\t\t}\n \t}\n \n #if 1\n\tfor (i = 0; i < bin->nsymtab; i++) {\n\t\tstruct MACH0_(nlist) *st = &bin->symtab[i];\n#if 0\n\t\tbprintf (\"stridx %d -> section %d type %d value = %d\\n\",\n\t\t\tst->n_strx, st->n_sect, st->n_type, st->n_value);\n#endif\n\t\tstridx = st->n_strx;\n\t\tif (stridx >= 0 && stridx < bin->symstrlen) {\n\t\t\tsymstr = (char*)bin->symstr + stridx;\n\t\t} else {\n\t\t\tsymstr = \"???\";\n\t\t}\n\t\tint section = st->n_sect;\n\t\tif (section == 1 && j < symbols_count) { // text ??st->n_type == 1)\n\t\t\t/* is symbol */\n\t\t\tsymbols[j].addr = st->n_value; // + text_base;\n\t\t\tsymbols[j].offset = addr_to_offset (bin, symbols[j].addr);\n\t\t\tsymbols[j].size = 0; /* find next symbol and crop */\n\t\t\tif (st->n_type & N_EXT) {\n\t\t\t\tsymbols[j].type = R_BIN_MACH0_SYMBOL_TYPE_EXT;\n\t\t\t} else {\n\t\t\t\tsymbols[j].type = R_BIN_MACH0_SYMBOL_TYPE_LOCAL;\n\t\t\t}\n\t\t\tstrncpy (symbols[j].name, symstr, R_BIN_MACH0_STRING_LENGTH);\n\t\t\tsymbols[j].name[R_BIN_MACH0_STRING_LENGTH - 1] = 0;\n\t\t\tsymbols[j].last = 0;\n\t\t\tif (inSymtab (hash, symbols, symbols[j].name, symbols[j].addr)) {\n\t\t\t\tsymbols[j].name[0] = 0;\n\t\t\t} else {\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\tsdb_ht_free (hash);\n\tsymbols[j].last = 1;\n\treturn symbols;\n}\n",
    "cwe": [
      "CWE-125"
    ],
    "id": 771,
    "_valid_cwes": [
      "CWE-125"
    ]
  },
  {
    "cve_id": "CVE-2018-14882",
    "code_before_change": "rpl_daoack_print(netdissect_options *ndo,\n                 const u_char *bp, u_int length)\n{\n        const struct nd_rpl_daoack *daoack = (const struct nd_rpl_daoack *)bp;\n        const char *dagid_str = \"<elided>\";\n\n        ND_TCHECK2(*daoack, ND_RPL_DAOACK_MIN_LEN);\n        if (length < ND_RPL_DAOACK_MIN_LEN)\n        \tgoto tooshort;\n\n        bp += ND_RPL_DAOACK_MIN_LEN;\n        length -= ND_RPL_DAOACK_MIN_LEN;\n        if(RPL_DAOACK_D(daoack->rpl_flags)) {\n                ND_TCHECK2(daoack->rpl_dagid, DAGID_LEN);\n                if (length < DAGID_LEN)\n                \tgoto tooshort;\n                dagid_str = ip6addr_string (ndo, daoack->rpl_dagid);\n                bp += DAGID_LEN;\n                length -= DAGID_LEN;\n        }\n\n        ND_PRINT((ndo, \" [dagid:%s,seq:%u,instance:%u,status:%u]\",\n                  dagid_str,\n                  daoack->rpl_daoseq,\n                  daoack->rpl_instanceid,\n                  daoack->rpl_status));\n\n        /* no officially defined options for DAOACK, but print any we find */\n        if(ndo->ndo_vflag > 1) {\n                const struct rpl_dio_genoption *opt = (const struct rpl_dio_genoption *)bp;\n                rpl_dio_printopt(ndo, opt, length);\n        }\n \treturn;\n \n trunc:\n\tND_PRINT((ndo,\" [|dao-truncated]\"));\n \treturn;\n \n tooshort:\n\tND_PRINT((ndo,\" [|dao-length too short]\"));\n\treturn;\n}\n",
    "code_after_change": "rpl_daoack_print(netdissect_options *ndo,\n                 const u_char *bp, u_int length)\n{\n        const struct nd_rpl_daoack *daoack = (const struct nd_rpl_daoack *)bp;\n        const char *dagid_str = \"<elided>\";\n\n        ND_TCHECK2(*daoack, ND_RPL_DAOACK_MIN_LEN);\n        if (length < ND_RPL_DAOACK_MIN_LEN)\n        \tgoto tooshort;\n\n        bp += ND_RPL_DAOACK_MIN_LEN;\n        length -= ND_RPL_DAOACK_MIN_LEN;\n        if(RPL_DAOACK_D(daoack->rpl_flags)) {\n                ND_TCHECK2(daoack->rpl_dagid, DAGID_LEN);\n                if (length < DAGID_LEN)\n                \tgoto tooshort;\n                dagid_str = ip6addr_string (ndo, daoack->rpl_dagid);\n                bp += DAGID_LEN;\n                length -= DAGID_LEN;\n        }\n\n        ND_PRINT((ndo, \" [dagid:%s,seq:%u,instance:%u,status:%u]\",\n                  dagid_str,\n                  daoack->rpl_daoseq,\n                  daoack->rpl_instanceid,\n                  daoack->rpl_status));\n\n        /* no officially defined options for DAOACK, but print any we find */\n        if(ndo->ndo_vflag > 1) {\n                const struct rpl_dio_genoption *opt = (const struct rpl_dio_genoption *)bp;\n                rpl_dio_printopt(ndo, opt, length);\n        }\n \treturn;\n \n trunc:\n\tND_PRINT((ndo, \"%s\", rpl_tstr));\n \treturn;\n \n tooshort:\n\tND_PRINT((ndo,\" [|dao-length too short]\"));\n\treturn;\n}\n",
    "cwe": [
      "CWE-125"
    ],
    "id": 775,
    "_valid_cwes": [
      "CWE-125"
    ]
  },
  {
    "cve_id": "CVE-2019-15139",
    "code_before_change": "static Image *ReadXWDImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define CheckOverflowException(length,width,height) \\\n  (((height) != 0) && ((length)/((size_t) height) != ((size_t) width)))\n\n  char\n    *comment;\n\n  Image\n    *image;\n\n  int\n    x_status;\n\n  MagickBooleanType\n    authentic_colormap;\n\n  MagickStatusType\n    status;\n\n  Quantum\n    index;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i;\n\n  register size_t\n    pixel;\n\n  size_t\n    length;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned long\n    lsb_first;\n\n  XColor\n    *colors;\n\n  XImage\n    *ximage;\n\n  XWDFileHeader\n    header;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read in header information.\n  */\n  count=ReadBlob(image,sz_XWDheader,(unsigned char *) &header);\n  if (count != sz_XWDheader)\n    ThrowReaderException(CorruptImageError,\"UnableToReadImageHeader\");\n  /*\n    Ensure the header byte-order is most-significant byte first.\n  */\n  lsb_first=1;\n  if ((int) (*(char *) &lsb_first) != 0)\n    MSBOrderLong((unsigned char *) &header,sz_XWDheader);\n  /*\n    Check to see if the dump file is in the proper format.\n  */\n  if (header.file_version != XWD_FILE_VERSION)\n     ThrowReaderException(CorruptImageError,\"FileFormatVersionMismatch\");\n   if (header.header_size < sz_XWDheader)\n     ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n   switch (header.visual_class)\n   {\n     case StaticGray:\n    case GrayScale:\n    {\n      if (header.bits_per_pixel != 1)\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      break;\n    }\n    case StaticColor:\n     case PseudoColor:\n     {\n       if ((header.bits_per_pixel < 1) || (header.bits_per_pixel > 15) ||\n          (header.ncolors == 0))\n         ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n       break;\n     }\n    case TrueColor:\n    case DirectColor:\n    {\n      if ((header.bits_per_pixel != 16) && (header.bits_per_pixel != 24) &&\n          (header.bits_per_pixel != 32))\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      break;\n    }\n    default:\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  }\n  switch (header.pixmap_format)\n  {\n    case XYBitmap:\n    {\n      if (header.pixmap_depth != 1)\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      break;\n    }\n    case XYPixmap:\n    case ZPixmap:\n    {\n      if ((header.pixmap_depth < 1) || (header.pixmap_depth > 32))\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      switch (header.bitmap_pad)\n      {\n        case 8:\n        case 16:\n        case 32:\n          break;\n        default:\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n      break;\n    }\n    default:\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  }\n  switch (header.bitmap_unit)\n  {\n    case 8:\n    case 16:\n    case 32:\n      break;\n    default:\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  }\n  switch (header.byte_order)\n  {\n    case LSBFirst:\n    case MSBFirst:\n      break;\n    default:\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  }\n  switch (header.bitmap_bit_order)\n  {\n    case LSBFirst:\n    case MSBFirst:\n      break;\n     default:\n       ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n   }\n  if (header.ncolors > 65535)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n   if (((header.bitmap_pad % 8) != 0) || (header.bitmap_pad > 32))\n     ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n   length=(size_t) (header.header_size-sz_XWDheader);\n  comment=(char *) AcquireQuantumMemory(length+1,sizeof(*comment));\n  if (comment == (char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  count=ReadBlob(image,length,(unsigned char *) comment);\n  comment[length]='\\0';\n  (void) SetImageProperty(image,\"comment\",comment,exception);\n  comment=DestroyString(comment);\n  if (count != (ssize_t) length)\n    ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n  /*\n    Initialize the X image.\n  */\n  ximage=(XImage *) AcquireMagickMemory(sizeof(*ximage));\n  if (ximage == (XImage *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  ximage->depth=(int) header.pixmap_depth;\n  ximage->format=(int) header.pixmap_format;\n  ximage->xoffset=(int) header.xoffset;\n  ximage->data=(char *) NULL;\n  ximage->width=(int) header.pixmap_width;\n  ximage->height=(int) header.pixmap_height;\n  ximage->bitmap_pad=(int) header.bitmap_pad;\n  ximage->bytes_per_line=(int) header.bytes_per_line;\n  ximage->byte_order=(int) header.byte_order;\n  ximage->bitmap_unit=(int) header.bitmap_unit;\n  ximage->bitmap_bit_order=(int) header.bitmap_bit_order;\n  ximage->bits_per_pixel=(int) header.bits_per_pixel;\n  ximage->red_mask=header.red_mask;\n  ximage->green_mask=header.green_mask;\n  ximage->blue_mask=header.blue_mask;\n  if ((ximage->width < 0) || (ximage->height < 0) || (ximage->depth < 0) ||\n      (ximage->format < 0) || (ximage->byte_order < 0) ||\n      (ximage->bitmap_bit_order < 0) || (ximage->bitmap_pad < 0) ||\n      (ximage->bytes_per_line < 0))\n    {\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  if ((ximage->width > 65535) || (ximage->height > 65535))\n    {\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  if ((ximage->bits_per_pixel > 32) || (ximage->bitmap_unit > 32))\n    {\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  x_status=XInitImage(ximage);\n  if (x_status == 0)\n    {\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n    }\n  /*\n    Read colormap.\n  */\n  authentic_colormap=MagickFalse;\n  colors=(XColor *) NULL;\n  if (header.ncolors != 0)\n    {\n       XWDColor\n         color;\n \n      colors=(XColor *) AcquireQuantumMemory((size_t) header.ncolors,\n        sizeof(*colors));\n       if (colors == (XColor *) NULL)\n         {\n           ximage=(XImage *) RelinquishMagickMemory(ximage);\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        }\n      for (i=0; i < (ssize_t) header.ncolors; i++)\n      {\n        count=ReadBlob(image,sz_XWDColor,(unsigned char *) &color);\n        if (count != sz_XWDColor)\n          {\n            colors=(XColor *) RelinquishMagickMemory(colors);\n            ximage=(XImage *) RelinquishMagickMemory(ximage);\n            ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n          }\n        colors[i].pixel=color.pixel;\n        colors[i].red=color.red;\n        colors[i].green=color.green;\n        colors[i].blue=color.blue;\n        colors[i].flags=(char) color.flags;\n        if (color.flags != 0)\n          authentic_colormap=MagickTrue;\n      }\n      /*\n        Ensure the header byte-order is most-significant byte first.\n      */\n      lsb_first=1;\n      if ((int) (*(char *) &lsb_first) != 0)\n        for (i=0; i < (ssize_t) header.ncolors; i++)\n        {\n          MSBOrderLong((unsigned char *) &colors[i].pixel,\n            sizeof(colors[i].pixel));\n          MSBOrderShort((unsigned char *) &colors[i].red,3*\n            sizeof(colors[i].red));\n        }\n    }\n  /*\n    Allocate the pixel buffer.\n  */\n  length=(size_t) ximage->bytes_per_line*ximage->height;\n  if (CheckOverflowException(length,ximage->bytes_per_line,ximage->height))\n    {\n      if (header.ncolors != 0)\n        colors=(XColor *) RelinquishMagickMemory(colors);\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  if (ximage->format != ZPixmap)\n    {\n      size_t\n        extent;\n\n      extent=length;\n      length*=ximage->depth;\n      if (CheckOverflowException(length,extent,ximage->depth))\n        {\n          if (header.ncolors != 0)\n            colors=(XColor *) RelinquishMagickMemory(colors);\n          ximage=(XImage *) RelinquishMagickMemory(ximage);\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        }\n    }\n  ximage->data=(char *) AcquireQuantumMemory(length,sizeof(*ximage->data));\n  if (ximage->data == (char *) NULL)\n    {\n      if (header.ncolors != 0)\n        colors=(XColor *) RelinquishMagickMemory(colors);\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  count=ReadBlob(image,length,(unsigned char *) ximage->data);\n  if (count != (ssize_t) length)\n    {\n      if (header.ncolors != 0)\n        colors=(XColor *) RelinquishMagickMemory(colors);\n      ximage->data=DestroyString(ximage->data);\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n    }\n  /*\n    Convert image to MIFF format.\n  */\n  image->columns=(size_t) ximage->width;\n  image->rows=(size_t) ximage->height;\n  image->depth=8;\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    {\n      if (header.ncolors != 0)\n        colors=(XColor *) RelinquishMagickMemory(colors);\n      ximage->data=DestroyString(ximage->data);\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      return(DestroyImageList(image));\n    }\n  if ((header.ncolors == 0U) || (ximage->red_mask != 0) ||\n      (ximage->green_mask != 0) || (ximage->blue_mask != 0))\n    image->storage_class=DirectClass;\n  else\n    image->storage_class=PseudoClass;\n  image->colors=header.ncolors;\n  if (image_info->ping == MagickFalse)\n    switch (image->storage_class)\n    {\n      case DirectClass:\n      default:\n      {\n        register size_t\n          color;\n\n        size_t\n          blue_mask,\n          blue_shift,\n          green_mask,\n          green_shift,\n          red_mask,\n          red_shift;\n\n        /*\n          Determine shift and mask for red, green, and blue.\n        */\n        red_mask=ximage->red_mask;\n        red_shift=0;\n        while ((red_mask != 0) && ((red_mask & 0x01) == 0))\n        {\n          red_mask>>=1;\n          red_shift++;\n        }\n        green_mask=ximage->green_mask;\n        green_shift=0;\n        while ((green_mask != 0) && ((green_mask & 0x01) == 0))\n        {\n          green_mask>>=1;\n          green_shift++;\n        }\n        blue_mask=ximage->blue_mask;\n        blue_shift=0;\n        while ((blue_mask != 0) && ((blue_mask & 0x01) == 0))\n        {\n          blue_mask>>=1;\n          blue_shift++;\n        }\n        /*\n          Convert X image to DirectClass packets.\n        */\n        if ((image->colors != 0) && (authentic_colormap != MagickFalse))\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              pixel=XGetPixel(ximage,(int) x,(int) y);\n              index=(Quantum) ConstrainColormapIndex(image,(ssize_t) (pixel >>\n                red_shift) & red_mask,exception);\n              SetPixelRed(image,ScaleShortToQuantum(\n                colors[(ssize_t) index].red),q);\n              index=(Quantum) ConstrainColormapIndex(image,(ssize_t) (pixel >>\n                green_shift) & green_mask,exception);\n              SetPixelGreen(image,ScaleShortToQuantum(\n                colors[(ssize_t) index].green),q);\n              index=(Quantum) ConstrainColormapIndex(image,(ssize_t) (pixel >>\n                blue_shift) & blue_mask,exception);\n              SetPixelBlue(image,ScaleShortToQuantum(\n                colors[(ssize_t) index].blue),q);\n              q+=GetPixelChannels(image);\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n          }\n        else\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              pixel=XGetPixel(ximage,(int) x,(int) y);\n              color=(pixel >> red_shift) & red_mask;\n              if (red_mask != 0)\n                color=(color*65535UL)/red_mask;\n              SetPixelRed(image,ScaleShortToQuantum((unsigned short) color),q);\n              color=(pixel >> green_shift) & green_mask;\n              if (green_mask != 0)\n                color=(color*65535UL)/green_mask;\n              SetPixelGreen(image,ScaleShortToQuantum((unsigned short) color),\n                q);\n              color=(pixel >> blue_shift) & blue_mask;\n              if (blue_mask != 0)\n                color=(color*65535UL)/blue_mask;\n              SetPixelBlue(image,ScaleShortToQuantum((unsigned short) color),q);\n              q+=GetPixelChannels(image);\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n          }\n        break;\n      }\n      case PseudoClass:\n      {\n        /*\n          Convert X image to PseudoClass packets.\n        */\n        if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n          {\n            if (header.ncolors != 0)\n              colors=(XColor *) RelinquishMagickMemory(colors);\n            ximage->data=DestroyString(ximage->data);\n            ximage=(XImage *) RelinquishMagickMemory(ximage);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          image->colormap[i].red=(MagickRealType) ScaleShortToQuantum(\n            colors[i].red);\n          image->colormap[i].green=(MagickRealType) ScaleShortToQuantum(\n            colors[i].green);\n          image->colormap[i].blue=(MagickRealType) ScaleShortToQuantum(\n            colors[i].blue);\n        }\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            index=(Quantum) ConstrainColormapIndex(image,(ssize_t)\n              XGetPixel(ximage,(int) x,(int) y),exception);\n            SetPixelIndex(image,index,q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n        break;\n      }\n    }\n  /*\n    Free image and colormap.\n  */\n  if (header.ncolors != 0)\n    colors=(XColor *) RelinquishMagickMemory(colors);\n  ximage->data=DestroyString(ximage->data);\n  ximage=(XImage *) RelinquishMagickMemory(ximage);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n",
    "code_after_change": "static Image *ReadXWDImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define CheckOverflowException(length,width,height) \\\n  (((height) != 0) && ((length)/((size_t) height) != ((size_t) width)))\n\n  char\n    *comment;\n\n  Image\n    *image;\n\n  int\n    x_status;\n\n  MagickBooleanType\n    authentic_colormap;\n\n  MagickStatusType\n    status;\n\n  Quantum\n    index;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i;\n\n  register size_t\n    pixel;\n\n  size_t\n    length;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned long\n    lsb_first;\n\n  XColor\n    *colors;\n\n  XImage\n    *ximage;\n\n  XWDFileHeader\n    header;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read in header information.\n  */\n  count=ReadBlob(image,sz_XWDheader,(unsigned char *) &header);\n  if (count != sz_XWDheader)\n    ThrowReaderException(CorruptImageError,\"UnableToReadImageHeader\");\n  /*\n    Ensure the header byte-order is most-significant byte first.\n  */\n  lsb_first=1;\n  if ((int) (*(char *) &lsb_first) != 0)\n    MSBOrderLong((unsigned char *) &header,sz_XWDheader);\n  /*\n    Check to see if the dump file is in the proper format.\n  */\n  if (header.file_version != XWD_FILE_VERSION)\n     ThrowReaderException(CorruptImageError,\"FileFormatVersionMismatch\");\n   if (header.header_size < sz_XWDheader)\n     ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if ((MagickSizeType) header.xoffset >= GetBlobSize(image))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n   switch (header.visual_class)\n   {\n     case StaticGray:\n    case GrayScale:\n    {\n      if (header.bits_per_pixel != 1)\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      break;\n    }\n    case StaticColor:\n     case PseudoColor:\n     {\n       if ((header.bits_per_pixel < 1) || (header.bits_per_pixel > 15) ||\n          (header.colormap_entries == 0))\n         ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n       break;\n     }\n    case TrueColor:\n    case DirectColor:\n    {\n      if ((header.bits_per_pixel != 16) && (header.bits_per_pixel != 24) &&\n          (header.bits_per_pixel != 32))\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      break;\n    }\n    default:\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  }\n  switch (header.pixmap_format)\n  {\n    case XYBitmap:\n    {\n      if (header.pixmap_depth != 1)\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      break;\n    }\n    case XYPixmap:\n    case ZPixmap:\n    {\n      if ((header.pixmap_depth < 1) || (header.pixmap_depth > 32))\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      switch (header.bitmap_pad)\n      {\n        case 8:\n        case 16:\n        case 32:\n          break;\n        default:\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n      break;\n    }\n    default:\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  }\n  switch (header.bitmap_unit)\n  {\n    case 8:\n    case 16:\n    case 32:\n      break;\n    default:\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  }\n  switch (header.byte_order)\n  {\n    case LSBFirst:\n    case MSBFirst:\n      break;\n    default:\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  }\n  switch (header.bitmap_bit_order)\n  {\n    case LSBFirst:\n    case MSBFirst:\n      break;\n     default:\n       ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n   }\n   if (((header.bitmap_pad % 8) != 0) || (header.bitmap_pad > 32))\n     ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n   length=(size_t) (header.header_size-sz_XWDheader);\n  comment=(char *) AcquireQuantumMemory(length+1,sizeof(*comment));\n  if (comment == (char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  count=ReadBlob(image,length,(unsigned char *) comment);\n  comment[length]='\\0';\n  (void) SetImageProperty(image,\"comment\",comment,exception);\n  comment=DestroyString(comment);\n  if (count != (ssize_t) length)\n    ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n  /*\n    Initialize the X image.\n  */\n  ximage=(XImage *) AcquireMagickMemory(sizeof(*ximage));\n  if (ximage == (XImage *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  ximage->depth=(int) header.pixmap_depth;\n  ximage->format=(int) header.pixmap_format;\n  ximage->xoffset=(int) header.xoffset;\n  ximage->data=(char *) NULL;\n  ximage->width=(int) header.pixmap_width;\n  ximage->height=(int) header.pixmap_height;\n  ximage->bitmap_pad=(int) header.bitmap_pad;\n  ximage->bytes_per_line=(int) header.bytes_per_line;\n  ximage->byte_order=(int) header.byte_order;\n  ximage->bitmap_unit=(int) header.bitmap_unit;\n  ximage->bitmap_bit_order=(int) header.bitmap_bit_order;\n  ximage->bits_per_pixel=(int) header.bits_per_pixel;\n  ximage->red_mask=header.red_mask;\n  ximage->green_mask=header.green_mask;\n  ximage->blue_mask=header.blue_mask;\n  if ((ximage->width < 0) || (ximage->height < 0) || (ximage->depth < 0) ||\n      (ximage->format < 0) || (ximage->byte_order < 0) ||\n      (ximage->bitmap_bit_order < 0) || (ximage->bitmap_pad < 0) ||\n      (ximage->bytes_per_line < 0))\n    {\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  if ((ximage->width > 65535) || (ximage->height > 65535))\n    {\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  if ((ximage->bits_per_pixel > 32) || (ximage->bitmap_unit > 32))\n    {\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  x_status=XInitImage(ximage);\n  if (x_status == 0)\n    {\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n    }\n  /*\n    Read colormap.\n  */\n  authentic_colormap=MagickFalse;\n  colors=(XColor *) NULL;\n  if (header.ncolors != 0)\n    {\n       XWDColor\n         color;\n \n      length=(size_t) header.ncolors;\n      if (length > ((~0UL)/sizeof(*colors)))\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      colors=(XColor *) AcquireQuantumMemory(length,sizeof(*colors));\n       if (colors == (XColor *) NULL)\n         {\n           ximage=(XImage *) RelinquishMagickMemory(ximage);\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        }\n      for (i=0; i < (ssize_t) header.ncolors; i++)\n      {\n        count=ReadBlob(image,sz_XWDColor,(unsigned char *) &color);\n        if (count != sz_XWDColor)\n          {\n            colors=(XColor *) RelinquishMagickMemory(colors);\n            ximage=(XImage *) RelinquishMagickMemory(ximage);\n            ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n          }\n        colors[i].pixel=color.pixel;\n        colors[i].red=color.red;\n        colors[i].green=color.green;\n        colors[i].blue=color.blue;\n        colors[i].flags=(char) color.flags;\n        if (color.flags != 0)\n          authentic_colormap=MagickTrue;\n      }\n      /*\n        Ensure the header byte-order is most-significant byte first.\n      */\n      lsb_first=1;\n      if ((int) (*(char *) &lsb_first) != 0)\n        for (i=0; i < (ssize_t) header.ncolors; i++)\n        {\n          MSBOrderLong((unsigned char *) &colors[i].pixel,\n            sizeof(colors[i].pixel));\n          MSBOrderShort((unsigned char *) &colors[i].red,3*\n            sizeof(colors[i].red));\n        }\n    }\n  /*\n    Allocate the pixel buffer.\n  */\n  length=(size_t) ximage->bytes_per_line*ximage->height;\n  if (CheckOverflowException(length,ximage->bytes_per_line,ximage->height))\n    {\n      if (header.ncolors != 0)\n        colors=(XColor *) RelinquishMagickMemory(colors);\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  if (ximage->format != ZPixmap)\n    {\n      size_t\n        extent;\n\n      extent=length;\n      length*=ximage->depth;\n      if (CheckOverflowException(length,extent,ximage->depth))\n        {\n          if (header.ncolors != 0)\n            colors=(XColor *) RelinquishMagickMemory(colors);\n          ximage=(XImage *) RelinquishMagickMemory(ximage);\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        }\n    }\n  ximage->data=(char *) AcquireQuantumMemory(length,sizeof(*ximage->data));\n  if (ximage->data == (char *) NULL)\n    {\n      if (header.ncolors != 0)\n        colors=(XColor *) RelinquishMagickMemory(colors);\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  count=ReadBlob(image,length,(unsigned char *) ximage->data);\n  if (count != (ssize_t) length)\n    {\n      if (header.ncolors != 0)\n        colors=(XColor *) RelinquishMagickMemory(colors);\n      ximage->data=DestroyString(ximage->data);\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n    }\n  /*\n    Convert image to MIFF format.\n  */\n  image->columns=(size_t) ximage->width;\n  image->rows=(size_t) ximage->height;\n  image->depth=8;\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    {\n      if (header.ncolors != 0)\n        colors=(XColor *) RelinquishMagickMemory(colors);\n      ximage->data=DestroyString(ximage->data);\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      return(DestroyImageList(image));\n    }\n  if ((header.ncolors == 0U) || (ximage->red_mask != 0) ||\n      (ximage->green_mask != 0) || (ximage->blue_mask != 0))\n    image->storage_class=DirectClass;\n  else\n    image->storage_class=PseudoClass;\n  image->colors=header.ncolors;\n  if (image_info->ping == MagickFalse)\n    switch (image->storage_class)\n    {\n      case DirectClass:\n      default:\n      {\n        register size_t\n          color;\n\n        size_t\n          blue_mask,\n          blue_shift,\n          green_mask,\n          green_shift,\n          red_mask,\n          red_shift;\n\n        /*\n          Determine shift and mask for red, green, and blue.\n        */\n        red_mask=ximage->red_mask;\n        red_shift=0;\n        while ((red_mask != 0) && ((red_mask & 0x01) == 0))\n        {\n          red_mask>>=1;\n          red_shift++;\n        }\n        green_mask=ximage->green_mask;\n        green_shift=0;\n        while ((green_mask != 0) && ((green_mask & 0x01) == 0))\n        {\n          green_mask>>=1;\n          green_shift++;\n        }\n        blue_mask=ximage->blue_mask;\n        blue_shift=0;\n        while ((blue_mask != 0) && ((blue_mask & 0x01) == 0))\n        {\n          blue_mask>>=1;\n          blue_shift++;\n        }\n        /*\n          Convert X image to DirectClass packets.\n        */\n        if ((image->colors != 0) && (authentic_colormap != MagickFalse))\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              pixel=XGetPixel(ximage,(int) x,(int) y);\n              index=(Quantum) ConstrainColormapIndex(image,(ssize_t) (pixel >>\n                red_shift) & red_mask,exception);\n              SetPixelRed(image,ScaleShortToQuantum(\n                colors[(ssize_t) index].red),q);\n              index=(Quantum) ConstrainColormapIndex(image,(ssize_t) (pixel >>\n                green_shift) & green_mask,exception);\n              SetPixelGreen(image,ScaleShortToQuantum(\n                colors[(ssize_t) index].green),q);\n              index=(Quantum) ConstrainColormapIndex(image,(ssize_t) (pixel >>\n                blue_shift) & blue_mask,exception);\n              SetPixelBlue(image,ScaleShortToQuantum(\n                colors[(ssize_t) index].blue),q);\n              q+=GetPixelChannels(image);\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n          }\n        else\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              pixel=XGetPixel(ximage,(int) x,(int) y);\n              color=(pixel >> red_shift) & red_mask;\n              if (red_mask != 0)\n                color=(color*65535UL)/red_mask;\n              SetPixelRed(image,ScaleShortToQuantum((unsigned short) color),q);\n              color=(pixel >> green_shift) & green_mask;\n              if (green_mask != 0)\n                color=(color*65535UL)/green_mask;\n              SetPixelGreen(image,ScaleShortToQuantum((unsigned short) color),\n                q);\n              color=(pixel >> blue_shift) & blue_mask;\n              if (blue_mask != 0)\n                color=(color*65535UL)/blue_mask;\n              SetPixelBlue(image,ScaleShortToQuantum((unsigned short) color),q);\n              q+=GetPixelChannels(image);\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n          }\n        break;\n      }\n      case PseudoClass:\n      {\n        /*\n          Convert X image to PseudoClass packets.\n        */\n        if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n          {\n            if (header.ncolors != 0)\n              colors=(XColor *) RelinquishMagickMemory(colors);\n            ximage->data=DestroyString(ximage->data);\n            ximage=(XImage *) RelinquishMagickMemory(ximage);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          image->colormap[i].red=(MagickRealType) ScaleShortToQuantum(\n            colors[i].red);\n          image->colormap[i].green=(MagickRealType) ScaleShortToQuantum(\n            colors[i].green);\n          image->colormap[i].blue=(MagickRealType) ScaleShortToQuantum(\n            colors[i].blue);\n        }\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            index=(Quantum) ConstrainColormapIndex(image,(ssize_t)\n              XGetPixel(ximage,(int) x,(int) y),exception);\n            SetPixelIndex(image,index,q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n        break;\n      }\n    }\n  /*\n    Free image and colormap.\n  */\n  if (header.ncolors != 0)\n    colors=(XColor *) RelinquishMagickMemory(colors);\n  ximage->data=DestroyString(ximage->data);\n  ximage=(XImage *) RelinquishMagickMemory(ximage);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n",
    "cwe": [
      "CWE-125"
    ],
    "id": 780,
    "_valid_cwes": [
      "CWE-125"
    ]
  },
  {
    "cve_id": "CVE-2018-14466",
    "code_before_change": "rx_cache_find(const struct rx_header *rxh, const struct ip *ip, int sport,\n\t      int32_t *opcode)\n{\n\tint i;\n\tstruct rx_cache_entry *rxent;\n\tuint32_t clip;\n\tuint32_t sip;\n\n\tUNALIGNED_MEMCPY(&clip, &ip->ip_dst, sizeof(uint32_t));\n\tUNALIGNED_MEMCPY(&sip, &ip->ip_src, sizeof(uint32_t));\n\n\t/* Start the search where we last left off */\n\n\ti = rx_cache_hint;\n\tdo {\n\t\trxent = &rx_cache[i];\n \t\tif (rxent->callnum == EXTRACT_32BITS(&rxh->callNumber) &&\n \t\t    rxent->client.s_addr == clip &&\n \t\t    rxent->server.s_addr == sip &&\n\t\t    rxent->serviceId == EXTRACT_32BITS(&rxh->serviceId) &&\n \t\t    rxent->dport == sport) {\n \n \t\t\t/* We got a match! */\n\n\t\t\trx_cache_hint = i;\n\t\t\t*opcode = rxent->opcode;\n\t\t\treturn(1);\n\t\t}\n\t\tif (++i >= RX_CACHE_SIZE)\n\t\t\ti = 0;\n\t} while (i != rx_cache_hint);\n\n\t/* Our search failed */\n\treturn(0);\n}\n",
    "code_after_change": "rx_cache_find(const struct rx_header *rxh, const struct ip *ip, int sport,\n\t      int32_t *opcode)\n{\n\tint i;\n\tstruct rx_cache_entry *rxent;\n\tuint32_t clip;\n\tuint32_t sip;\n\n\tUNALIGNED_MEMCPY(&clip, &ip->ip_dst, sizeof(uint32_t));\n\tUNALIGNED_MEMCPY(&sip, &ip->ip_src, sizeof(uint32_t));\n\n\t/* Start the search where we last left off */\n\n\ti = rx_cache_hint;\n\tdo {\n\t\trxent = &rx_cache[i];\n \t\tif (rxent->callnum == EXTRACT_32BITS(&rxh->callNumber) &&\n \t\t    rxent->client.s_addr == clip &&\n \t\t    rxent->server.s_addr == sip &&\n\t\t    rxent->serviceId == EXTRACT_16BITS(&rxh->serviceId) &&\n \t\t    rxent->dport == sport) {\n \n \t\t\t/* We got a match! */\n\n\t\t\trx_cache_hint = i;\n\t\t\t*opcode = rxent->opcode;\n\t\t\treturn(1);\n\t\t}\n\t\tif (++i >= RX_CACHE_SIZE)\n\t\t\ti = 0;\n\t} while (i != rx_cache_hint);\n\n\t/* Our search failed */\n\treturn(0);\n}\n",
    "cwe": [
      "CWE-125"
    ],
    "id": 795,
    "_valid_cwes": [
      "CWE-125"
    ]
  },
  {
    "cve_id": "CVE-2018-6038",
    "code_before_change": "void WebGL2RenderingContextBase::texImage3D(GLenum target,\n                                            GLint level,\n                                            GLint internalformat,\n                                            GLsizei width,\n                                            GLsizei height,\n                                            GLsizei depth,\n                                            GLint border,\n                                            GLenum format,\n                                            GLenum type,\n                                            GLintptr offset) {\n  if (isContextLost())\n    return;\n  if (!ValidateTexture3DBinding(\"texImage3D\", target))\n    return;\n  if (!bound_pixel_unpack_buffer_) {\n    SynthesizeGLError(GL_INVALID_OPERATION, \"texImage3D\",\n                       \"no bound PIXEL_UNPACK_BUFFER\");\n     return;\n   }\n   if (!ValidateTexFunc(\"texImage3D\", kTexImage, kSourceUnpackBuffer, target,\n                        level, internalformat, width, height, depth, border,\n                        format, type, 0, 0, 0))\n    return;\n  if (!ValidateValueFitNonNegInt32(\"texImage3D\", \"offset\", offset))\n    return;\n\n  ContextGL()->TexImage3D(target, level,\n                          ConvertTexInternalFormat(internalformat, type), width,\n                          height, depth, border, format, type,\n                          reinterpret_cast<const void*>(offset));\n}\n",
    "code_after_change": "void WebGL2RenderingContextBase::texImage3D(GLenum target,\n                                            GLint level,\n                                            GLint internalformat,\n                                            GLsizei width,\n                                            GLsizei height,\n                                            GLsizei depth,\n                                            GLint border,\n                                            GLenum format,\n                                            GLenum type,\n                                            GLintptr offset) {\n  if (isContextLost())\n    return;\n  if (!ValidateTexture3DBinding(\"texImage3D\", target))\n    return;\n  if (!bound_pixel_unpack_buffer_) {\n    SynthesizeGLError(GL_INVALID_OPERATION, \"texImage3D\",\n                       \"no bound PIXEL_UNPACK_BUFFER\");\n     return;\n   }\n  if (unpack_flip_y_ || unpack_premultiply_alpha_) {\n    SynthesizeGLError(\n        GL_INVALID_OPERATION, \"texImage3D\",\n        \"FLIP_Y or PREMULTIPLY_ALPHA isn't allowed for uploading 3D textures\");\n    return;\n  }\n   if (!ValidateTexFunc(\"texImage3D\", kTexImage, kSourceUnpackBuffer, target,\n                        level, internalformat, width, height, depth, border,\n                        format, type, 0, 0, 0))\n    return;\n  if (!ValidateValueFitNonNegInt32(\"texImage3D\", \"offset\", offset))\n    return;\n\n  ContextGL()->TexImage3D(target, level,\n                          ConvertTexInternalFormat(internalformat, type), width,\n                          height, depth, border, format, type,\n                          reinterpret_cast<const void*>(offset));\n}\n",
    "cwe": [
      "CWE-125"
    ],
    "id": 803,
    "_valid_cwes": [
      "CWE-125"
    ]
  },
  {
    "cve_id": "CVE-2017-14166",
    "code_before_change": "atol8(const char *p, size_t char_cnt)\n {\n \tint64_t l;\n \tint digit;\n \tl = 0;\n \twhile (char_cnt-- > 0) {\n \t\tif (*p >= '0' && *p <= '7')\n\t\t\tdigit = *p - '0';\n\t\telse\n\t\t\tbreak;\n\t\tp++;\n\t\tl <<= 3;\n\t\tl |= digit;\n\t}\n\treturn (l);\n}\n",
    "code_after_change": "atol8(const char *p, size_t char_cnt)\n {\n \tint64_t l;\n \tint digit;\n\n\tif (char_cnt == 0)\n\t\treturn (0);\n\n \tl = 0;\n \twhile (char_cnt-- > 0) {\n \t\tif (*p >= '0' && *p <= '7')\n\t\t\tdigit = *p - '0';\n\t\telse\n\t\t\tbreak;\n\t\tp++;\n\t\tl <<= 3;\n\t\tl |= digit;\n\t}\n\treturn (l);\n}\n",
    "cwe": [
      "CWE-125"
    ],
    "id": 809,
    "_valid_cwes": [
      "CWE-125"
    ]
  },
  {
    "cve_id": "CVE-2015-8958",
    "code_before_change": "static Image *ReadSUNImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define RMT_EQUAL_RGB  1\n#define RMT_NONE  0\n#define RMT_RAW  2\n#define RT_STANDARD  1\n#define RT_ENCODED  2\n#define RT_FORMAT_RGB  3\n\n  typedef struct _SUNInfo\n  {\n    unsigned int\n      magic,\n      width,\n      height,\n      depth,\n      length,\n      type,\n      maptype,\n      maplength;\n  } SUNInfo;\n\n  Image\n    *image;\n\n  int\n    bit;\n\n  MagickBooleanType\n    status;\n\n  MagickSizeType\n    number_pixels;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bytes_per_line,\n    extent,\n    length;\n\n  ssize_t\n    count,\n    y;\n\n  SUNInfo\n    sun_info;\n\n  unsigned char\n    *sun_data,\n    *sun_pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read SUN raster header.\n  */\n  (void) ResetMagickMemory(&sun_info,0,sizeof(sun_info));\n  sun_info.magic=ReadBlobMSBLong(image);\n  do\n  {\n    /*\n      Verify SUN identifier.\n    */\n    if (sun_info.magic != 0x59a66a95)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    sun_info.width=ReadBlobMSBLong(image);\n    sun_info.height=ReadBlobMSBLong(image);\n    sun_info.depth=ReadBlobMSBLong(image);\n    sun_info.length=ReadBlobMSBLong(image);\n    sun_info.type=ReadBlobMSBLong(image);\n    sun_info.maptype=ReadBlobMSBLong(image);\n    sun_info.maplength=ReadBlobMSBLong(image);\n    extent=sun_info.height*sun_info.width;\n    if ((sun_info.height != 0) && (sun_info.width != extent/sun_info.height))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((sun_info.type != RT_STANDARD) && (sun_info.type != RT_ENCODED) &&\n        (sun_info.type != RT_FORMAT_RGB))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((sun_info.maptype == RMT_NONE) && (sun_info.maplength != 0))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((sun_info.depth == 0) || (sun_info.depth > 32))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((sun_info.maptype != RMT_NONE) && (sun_info.maptype != RMT_EQUAL_RGB) &&\n        (sun_info.maptype != RMT_RAW))\n      ThrowReaderException(CoderError,\"ColormapTypeNotSupported\");\n    image->columns=sun_info.width;\n    image->rows=sun_info.height;\n    image->depth=sun_info.depth <= 8 ? sun_info.depth :\n      MAGICKCORE_QUANTUM_DEPTH;\n    if (sun_info.depth < 24)\n      {\n        size_t\n          one;\n\n        image->colors=sun_info.maplength;\n        one=1;\n        if (sun_info.maptype == RMT_NONE)\n          image->colors=one << sun_info.depth;\n        if (sun_info.maptype == RMT_EQUAL_RGB)\n          image->colors=sun_info.maplength/3;\n        if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    switch (sun_info.maptype)\n    {\n      case RMT_NONE:\n        break;\n      case RMT_EQUAL_RGB:\n      {\n        unsigned char\n          *sun_colormap;\n\n        /*\n          Read SUN raster colormap.\n        */\n        sun_colormap=(unsigned char *) AcquireQuantumMemory(image->colors,\n          sizeof(*sun_colormap));\n        if (sun_colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        count=ReadBlob(image,image->colors,sun_colormap);\n        if (count != (ssize_t) image->colors)\n          ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n        for (i=0; i < (ssize_t) image->colors; i++)\n          image->colormap[i].red=(MagickRealType) ScaleCharToQuantum(\n            sun_colormap[i]);\n        count=ReadBlob(image,image->colors,sun_colormap);\n        if (count != (ssize_t) image->colors)\n          ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n        for (i=0; i < (ssize_t) image->colors; i++)\n          image->colormap[i].green=(MagickRealType) ScaleCharToQuantum(\n            sun_colormap[i]);\n        count=ReadBlob(image,image->colors,sun_colormap);\n        if (count != (ssize_t) image->colors)\n          ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n        for (i=0; i < (ssize_t) image->colors; i++)\n          image->colormap[i].blue=(MagickRealType) ScaleCharToQuantum(\n            sun_colormap[i]);\n        sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);\n        break;\n      }\n      case RMT_RAW:\n      {\n        unsigned char\n          *sun_colormap;\n\n        /*\n          Read SUN raster colormap.\n        */\n        sun_colormap=(unsigned char *) AcquireQuantumMemory(sun_info.maplength,\n          sizeof(*sun_colormap));\n        if (sun_colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        count=ReadBlob(image,sun_info.maplength,sun_colormap);\n        if (count != (ssize_t) sun_info.maplength)\n          ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n        sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);\n        break;\n      }\n      default:\n        ThrowReaderException(CoderError,\"ColormapTypeNotSupported\");\n    }\n    image->alpha_trait=sun_info.depth == 32 ? BlendPixelTrait :\n      UndefinedPixelTrait;\n    image->columns=sun_info.width;\n    image->rows=sun_info.height;\n    if (image_info->ping != MagickFalse)\n      {\n        (void) CloseBlob(image);\n        return(GetFirstImageInList(image));\n      }\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    if ((sun_info.length*sizeof(*sun_data))/sizeof(*sun_data) !=\n         sun_info.length || !sun_info.length)\n       ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n     number_pixels=(MagickSizeType) image->columns*image->rows;\n    if ((sun_info.type != RT_ENCODED) && (sun_info.depth >= 8) &&\n        ((number_pixels*((sun_info.depth+7)/8)) > sun_info.length))\n       ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n     bytes_per_line=sun_info.width*sun_info.depth;\n     sun_data=(unsigned char *) AcquireQuantumMemory((size_t) MagickMax(\n      sun_info.length,bytes_per_line*sun_info.width),sizeof(*sun_data));\n    if (sun_data == (unsigned char *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    count=(ssize_t) ReadBlob(image,sun_info.length,sun_data);\n    if (count != (ssize_t) sun_info.length)\n      ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n    sun_pixels=sun_data;\n    bytes_per_line=0;\n    if (sun_info.type == RT_ENCODED)\n      {\n        size_t\n          height;\n\n        /*\n          Read run-length encoded raster pixels.\n        */\n        height=sun_info.height;\n        if ((height == 0) || (sun_info.width == 0) || (sun_info.depth == 0) ||\n            ((bytes_per_line/sun_info.depth) != sun_info.width))\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        bytes_per_line+=15;\n        bytes_per_line<<=1;\n        if ((bytes_per_line >> 1) != (sun_info.width*sun_info.depth+15))\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        bytes_per_line>>=4;\n        sun_pixels=(unsigned char *) AcquireQuantumMemory(height,\n          bytes_per_line*sizeof(*sun_pixels));\n        if (sun_pixels == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) DecodeImage(sun_data,sun_info.length,sun_pixels,bytes_per_line*\n          height);\n        sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n      }\n    /*\n      Convert SUN raster image to pixel packets.\n    */\n    p=sun_pixels;\n    if (sun_info.depth == 1)\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n        {\n          for (bit=7; bit >= 0; bit--)\n          {\n            SetPixelIndex(image,(Quantum) ((*p) & (0x01 << bit) ? 0x00 : 0x01),\n              q);\n            q+=GetPixelChannels(image);\n          }\n          p++;\n        }\n        if ((image->columns % 8) != 0)\n          {\n            for (bit=7; bit >= (int) (8-(image->columns % 8)); bit--)\n            {\n              SetPixelIndex(image,(Quantum) ((*p) & (0x01 << bit) ? 0x00 :\n                0x01),q);\n              q+=GetPixelChannels(image);\n            }\n            p++;\n          }\n        if ((((image->columns/8)+(image->columns % 8 ? 1 : 0)) % 2) != 0)\n          p++;\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n          }\n      }\n    else\n      if (image->storage_class == PseudoClass)\n        {\n          if (bytes_per_line == 0)\n            bytes_per_line=image->columns;\n          length=image->rows*(image->columns+image->columns % 2);\n          if (((sun_info.type == RT_ENCODED) &&\n               (length > (bytes_per_line*image->rows))) ||\n              ((sun_info.type != RT_ENCODED) && (length > sun_info.length)))\n            ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelIndex(image,*p++,q);\n              q+=GetPixelChannels(image);\n            }\n            if ((image->columns % 2) != 0)\n              p++;\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n      else\n        {\n          size_t\n            bytes_per_pixel;\n\n          bytes_per_pixel=3;\n          if (image->alpha_trait != UndefinedPixelTrait)\n             bytes_per_pixel++;\n           if (bytes_per_line == 0)\n             bytes_per_line=bytes_per_pixel*image->columns;\n          length=image->rows*(bytes_per_line+image->columns % 2);\n           if (((sun_info.type == RT_ENCODED) &&\n                (length > (bytes_per_line*image->rows))) ||\n               ((sun_info.type != RT_ENCODED) && (length > sun_info.length)))\n            ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              if (image->alpha_trait != UndefinedPixelTrait)\n                SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);\n              if (sun_info.type == RT_STANDARD)\n                {\n                  SetPixelBlue(image,ScaleCharToQuantum(*p++),q);\n                  SetPixelGreen(image,ScaleCharToQuantum(*p++),q);\n                  SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n                }\n              else\n                {\n                  SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n                  SetPixelGreen(image,ScaleCharToQuantum(*p++),q);\n                  SetPixelBlue(image,ScaleCharToQuantum(*p++),q);\n                }\n              if (image->colors != 0)\n                {\n                  SetPixelRed(image,ClampToQuantum(image->colormap[(ssize_t)\n                    GetPixelRed(image,q)].red),q);\n                  SetPixelGreen(image,ClampToQuantum(image->colormap[(ssize_t)\n                    GetPixelGreen(image,q)].green),q);\n                  SetPixelBlue(image,ClampToQuantum(image->colormap[(ssize_t)\n                    GetPixelBlue(image,q)].blue),q);\n                }\n              q+=GetPixelChannels(image);\n            }\n            if (((bytes_per_pixel*image->columns) % 2) != 0)\n              p++;\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n    if (image->storage_class == PseudoClass)\n      (void) SyncImage(image,exception);\n    sun_pixels=(unsigned char *) RelinquishMagickMemory(sun_pixels);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    sun_info.magic=ReadBlobMSBLong(image);\n    if (sun_info.magic == 0x59a66a95)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (sun_info.magic == 0x59a66a95);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n",
    "code_after_change": "static Image *ReadSUNImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define RMT_EQUAL_RGB  1\n#define RMT_NONE  0\n#define RMT_RAW  2\n#define RT_STANDARD  1\n#define RT_ENCODED  2\n#define RT_FORMAT_RGB  3\n\n  typedef struct _SUNInfo\n  {\n    unsigned int\n      magic,\n      width,\n      height,\n      depth,\n      length,\n      type,\n      maptype,\n      maplength;\n  } SUNInfo;\n\n  Image\n    *image;\n\n  int\n    bit;\n\n  MagickBooleanType\n    status;\n\n  MagickSizeType\n    number_pixels;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bytes_per_line,\n    extent,\n    length;\n\n  ssize_t\n    count,\n    y;\n\n  SUNInfo\n    sun_info;\n\n  unsigned char\n    *sun_data,\n    *sun_pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read SUN raster header.\n  */\n  (void) ResetMagickMemory(&sun_info,0,sizeof(sun_info));\n  sun_info.magic=ReadBlobMSBLong(image);\n  do\n  {\n    /*\n      Verify SUN identifier.\n    */\n    if (sun_info.magic != 0x59a66a95)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    sun_info.width=ReadBlobMSBLong(image);\n    sun_info.height=ReadBlobMSBLong(image);\n    sun_info.depth=ReadBlobMSBLong(image);\n    sun_info.length=ReadBlobMSBLong(image);\n    sun_info.type=ReadBlobMSBLong(image);\n    sun_info.maptype=ReadBlobMSBLong(image);\n    sun_info.maplength=ReadBlobMSBLong(image);\n    extent=sun_info.height*sun_info.width;\n    if ((sun_info.height != 0) && (sun_info.width != extent/sun_info.height))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((sun_info.type != RT_STANDARD) && (sun_info.type != RT_ENCODED) &&\n        (sun_info.type != RT_FORMAT_RGB))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((sun_info.maptype == RMT_NONE) && (sun_info.maplength != 0))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((sun_info.depth == 0) || (sun_info.depth > 32))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((sun_info.maptype != RMT_NONE) && (sun_info.maptype != RMT_EQUAL_RGB) &&\n        (sun_info.maptype != RMT_RAW))\n      ThrowReaderException(CoderError,\"ColormapTypeNotSupported\");\n    image->columns=sun_info.width;\n    image->rows=sun_info.height;\n    image->depth=sun_info.depth <= 8 ? sun_info.depth :\n      MAGICKCORE_QUANTUM_DEPTH;\n    if (sun_info.depth < 24)\n      {\n        size_t\n          one;\n\n        image->colors=sun_info.maplength;\n        one=1;\n        if (sun_info.maptype == RMT_NONE)\n          image->colors=one << sun_info.depth;\n        if (sun_info.maptype == RMT_EQUAL_RGB)\n          image->colors=sun_info.maplength/3;\n        if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    switch (sun_info.maptype)\n    {\n      case RMT_NONE:\n        break;\n      case RMT_EQUAL_RGB:\n      {\n        unsigned char\n          *sun_colormap;\n\n        /*\n          Read SUN raster colormap.\n        */\n        sun_colormap=(unsigned char *) AcquireQuantumMemory(image->colors,\n          sizeof(*sun_colormap));\n        if (sun_colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        count=ReadBlob(image,image->colors,sun_colormap);\n        if (count != (ssize_t) image->colors)\n          ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n        for (i=0; i < (ssize_t) image->colors; i++)\n          image->colormap[i].red=(MagickRealType) ScaleCharToQuantum(\n            sun_colormap[i]);\n        count=ReadBlob(image,image->colors,sun_colormap);\n        if (count != (ssize_t) image->colors)\n          ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n        for (i=0; i < (ssize_t) image->colors; i++)\n          image->colormap[i].green=(MagickRealType) ScaleCharToQuantum(\n            sun_colormap[i]);\n        count=ReadBlob(image,image->colors,sun_colormap);\n        if (count != (ssize_t) image->colors)\n          ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n        for (i=0; i < (ssize_t) image->colors; i++)\n          image->colormap[i].blue=(MagickRealType) ScaleCharToQuantum(\n            sun_colormap[i]);\n        sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);\n        break;\n      }\n      case RMT_RAW:\n      {\n        unsigned char\n          *sun_colormap;\n\n        /*\n          Read SUN raster colormap.\n        */\n        sun_colormap=(unsigned char *) AcquireQuantumMemory(sun_info.maplength,\n          sizeof(*sun_colormap));\n        if (sun_colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        count=ReadBlob(image,sun_info.maplength,sun_colormap);\n        if (count != (ssize_t) sun_info.maplength)\n          ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n        sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);\n        break;\n      }\n      default:\n        ThrowReaderException(CoderError,\"ColormapTypeNotSupported\");\n    }\n    image->alpha_trait=sun_info.depth == 32 ? BlendPixelTrait :\n      UndefinedPixelTrait;\n    image->columns=sun_info.width;\n    image->rows=sun_info.height;\n    if (image_info->ping != MagickFalse)\n      {\n        (void) CloseBlob(image);\n        return(GetFirstImageInList(image));\n      }\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    if ((sun_info.length*sizeof(*sun_data))/sizeof(*sun_data) !=\n         sun_info.length || !sun_info.length)\n       ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n     number_pixels=(MagickSizeType) image->columns*image->rows;\n    if ((sun_info.type != RT_ENCODED) && \n        ((number_pixels*sun_info.depth) > (8*sun_info.length)))\n       ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n     bytes_per_line=sun_info.width*sun_info.depth;\n     sun_data=(unsigned char *) AcquireQuantumMemory((size_t) MagickMax(\n      sun_info.length,bytes_per_line*sun_info.width),sizeof(*sun_data));\n    if (sun_data == (unsigned char *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    count=(ssize_t) ReadBlob(image,sun_info.length,sun_data);\n    if (count != (ssize_t) sun_info.length)\n      ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n    sun_pixels=sun_data;\n    bytes_per_line=0;\n    if (sun_info.type == RT_ENCODED)\n      {\n        size_t\n          height;\n\n        /*\n          Read run-length encoded raster pixels.\n        */\n        height=sun_info.height;\n        if ((height == 0) || (sun_info.width == 0) || (sun_info.depth == 0) ||\n            ((bytes_per_line/sun_info.depth) != sun_info.width))\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        bytes_per_line+=15;\n        bytes_per_line<<=1;\n        if ((bytes_per_line >> 1) != (sun_info.width*sun_info.depth+15))\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        bytes_per_line>>=4;\n        sun_pixels=(unsigned char *) AcquireQuantumMemory(height,\n          bytes_per_line*sizeof(*sun_pixels));\n        if (sun_pixels == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) DecodeImage(sun_data,sun_info.length,sun_pixels,bytes_per_line*\n          height);\n        sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n      }\n    /*\n      Convert SUN raster image to pixel packets.\n    */\n    p=sun_pixels;\n    if (sun_info.depth == 1)\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n        {\n          for (bit=7; bit >= 0; bit--)\n          {\n            SetPixelIndex(image,(Quantum) ((*p) & (0x01 << bit) ? 0x00 : 0x01),\n              q);\n            q+=GetPixelChannels(image);\n          }\n          p++;\n        }\n        if ((image->columns % 8) != 0)\n          {\n            for (bit=7; bit >= (int) (8-(image->columns % 8)); bit--)\n            {\n              SetPixelIndex(image,(Quantum) ((*p) & (0x01 << bit) ? 0x00 :\n                0x01),q);\n              q+=GetPixelChannels(image);\n            }\n            p++;\n          }\n        if ((((image->columns/8)+(image->columns % 8 ? 1 : 0)) % 2) != 0)\n          p++;\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n          }\n      }\n    else\n      if (image->storage_class == PseudoClass)\n        {\n          if (bytes_per_line == 0)\n            bytes_per_line=image->columns;\n          length=image->rows*(image->columns+image->columns % 2);\n          if (((sun_info.type == RT_ENCODED) &&\n               (length > (bytes_per_line*image->rows))) ||\n              ((sun_info.type != RT_ENCODED) && (length > sun_info.length)))\n            ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelIndex(image,*p++,q);\n              q+=GetPixelChannels(image);\n            }\n            if ((image->columns % 2) != 0)\n              p++;\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n      else\n        {\n          size_t\n            bytes_per_pixel;\n\n          bytes_per_pixel=3;\n          if (image->alpha_trait != UndefinedPixelTrait)\n             bytes_per_pixel++;\n           if (bytes_per_line == 0)\n             bytes_per_line=bytes_per_pixel*image->columns;\n          length=image->rows*(bytes_per_line+bytes_per_line % 2);\n           if (((sun_info.type == RT_ENCODED) &&\n                (length > (bytes_per_line*image->rows))) ||\n               ((sun_info.type != RT_ENCODED) && (length > sun_info.length)))\n            ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              if (image->alpha_trait != UndefinedPixelTrait)\n                SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);\n              if (sun_info.type == RT_STANDARD)\n                {\n                  SetPixelBlue(image,ScaleCharToQuantum(*p++),q);\n                  SetPixelGreen(image,ScaleCharToQuantum(*p++),q);\n                  SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n                }\n              else\n                {\n                  SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n                  SetPixelGreen(image,ScaleCharToQuantum(*p++),q);\n                  SetPixelBlue(image,ScaleCharToQuantum(*p++),q);\n                }\n              if (image->colors != 0)\n                {\n                  SetPixelRed(image,ClampToQuantum(image->colormap[(ssize_t)\n                    GetPixelRed(image,q)].red),q);\n                  SetPixelGreen(image,ClampToQuantum(image->colormap[(ssize_t)\n                    GetPixelGreen(image,q)].green),q);\n                  SetPixelBlue(image,ClampToQuantum(image->colormap[(ssize_t)\n                    GetPixelBlue(image,q)].blue),q);\n                }\n              q+=GetPixelChannels(image);\n            }\n            if (((bytes_per_pixel*image->columns) % 2) != 0)\n              p++;\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n    if (image->storage_class == PseudoClass)\n      (void) SyncImage(image,exception);\n    sun_pixels=(unsigned char *) RelinquishMagickMemory(sun_pixels);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    sun_info.magic=ReadBlobMSBLong(image);\n    if (sun_info.magic == 0x59a66a95)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (sun_info.magic == 0x59a66a95);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n",
    "cwe": [
      "CWE-125"
    ],
    "id": 840,
    "_valid_cwes": [
      "CWE-125"
    ]
  },
  {
    "cve_id": "CVE-2016-5093",
    "code_before_change": "static char* get_icu_value_internal( const char* loc_name , char* tag_name, int* result , int fromParseLocale)\n{\n\tchar*\t\ttag_value\t= NULL;\n\tint32_t     \ttag_value_len   = 512;\n\n\tint\t\tsingletonPos   \t= 0;\n\tchar*       \tmod_loc_name\t= NULL;\n\tint \t\tgrOffset\t= 0;\n\n\tint32_t     \tbuflen          = 512;\n\tUErrorCode  \tstatus          = U_ZERO_ERROR;\n\n\n\tif( strcmp(tag_name, LOC_CANONICALIZE_TAG) != 0 ){\n\t\t/* Handle  grandfathered languages */\n\t\tgrOffset =  findOffset( LOC_GRANDFATHERED , loc_name );\n\t\tif( grOffset >= 0 ){\n\t\t\tif( strcmp(tag_name , LOC_LANG_TAG)==0 ){\n\t\t\t\treturn estrdup(loc_name);\n\t\t\t} else {\n\t\t\t\t/* Since Grandfathered , no value , do nothing , retutn NULL */\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\n\tif( fromParseLocale==1 ){\n\t\t/* Handle singletons */\n\t\tif( strcmp(tag_name , LOC_LANG_TAG)==0 ){\n\t\t\tif( strlen(loc_name)>1 && (isIDPrefix(loc_name) == 1) ){\n\t\t\t\treturn estrdup(loc_name);\n \t\t\t}\n \t\t}\n \n\t\tsingletonPos = getSingletonPos( loc_name );\t\n \t\tif( singletonPos == 0){\n \t\t\t/* singleton at start of script, region , variant etc.\n \t\t\t * or invalid singleton at start of language */\n\t\t\treturn NULL;\n\t\t} else if( singletonPos > 0 ){\n\t\t\t/* singleton at some position except at start\n\t\t\t * strip off the singleton and rest of the loc_name */\n\t\t\tmod_loc_name = estrndup ( loc_name , singletonPos-1);\n\t\t}\n\t} /* end of if fromParse */\n\n \t} /* end of if != LOC_CANONICAL_TAG */\n \n \tif( mod_loc_name == NULL){\n\t\tmod_loc_name = estrdup(loc_name );\t\n \t}\n \n \t/* Proceed to ICU */\n    do{\n\t\ttag_value = erealloc( tag_value , buflen  );\n\t\ttag_value_len = buflen;\n\n\t\tif( strcmp(tag_name , LOC_SCRIPT_TAG)==0 ){\n\t\t\tbuflen = uloc_getScript ( mod_loc_name ,tag_value , tag_value_len , &status);\n\t\t}\n\t\tif( strcmp(tag_name , LOC_LANG_TAG )==0 ){\n\t\t\tbuflen = uloc_getLanguage ( mod_loc_name ,tag_value , tag_value_len , &status);\n\t\t}\n\t\tif( strcmp(tag_name , LOC_REGION_TAG)==0 ){\n\t\t\tbuflen = uloc_getCountry ( mod_loc_name ,tag_value , tag_value_len , &status);\n\t\t}\n\t\tif( strcmp(tag_name , LOC_VARIANT_TAG)==0 ){\n\t\t\tbuflen = uloc_getVariant ( mod_loc_name ,tag_value , tag_value_len , &status);\n\t\t}\n\t\tif( strcmp(tag_name , LOC_CANONICALIZE_TAG)==0 ){\n\t\t\tbuflen = uloc_canonicalize ( mod_loc_name ,tag_value , tag_value_len , &status);\n\t\t}\n\n \t\tif( U_FAILURE( status ) ) {\n \t\t\tif( status == U_BUFFER_OVERFLOW_ERROR ) {\n \t\t\t\tstatus = U_ZERO_ERROR;\n \t\t\t\tcontinue;\n \t\t\t}\n \n\t\t\t/* Error in retriving data */\n\t\t\t*result = 0;\n\t\t\tif( tag_value ){\n\t\t\t\tefree( tag_value );\n\t\t\t}\n\t\t\tif( mod_loc_name ){\n\t\t\t\tefree( mod_loc_name);\n\t\t\t}\n\t\t\treturn NULL;\n\t\t}\n\t} while( buflen > tag_value_len );\n\n\tif(  buflen ==0 ){\n\t\t/* No value found */\n\t\t*result = -1;\n\t\tif( tag_value ){\n\t\t\tefree( tag_value );\n\t\t}\n\t\tif( mod_loc_name ){\n\t\t\tefree( mod_loc_name);\n\t\t}\n\t\treturn NULL;\n\t} else {\n\t\t*result = 1;\n\t}\n\n\tif( mod_loc_name ){\n\t\tefree( mod_loc_name);\n\t}\n\treturn tag_value;\n}\n",
    "code_after_change": "static char* get_icu_value_internal( const char* loc_name , char* tag_name, int* result , int fromParseLocale)\n{\n\tchar*\t\ttag_value\t= NULL;\n\tint32_t     \ttag_value_len   = 512;\n\n\tint\t\tsingletonPos   \t= 0;\n\tchar*       \tmod_loc_name\t= NULL;\n\tint \t\tgrOffset\t= 0;\n\n\tint32_t     \tbuflen          = 512;\n\tUErrorCode  \tstatus          = U_ZERO_ERROR;\n\n\n\tif( strcmp(tag_name, LOC_CANONICALIZE_TAG) != 0 ){\n\t\t/* Handle  grandfathered languages */\n\t\tgrOffset =  findOffset( LOC_GRANDFATHERED , loc_name );\n\t\tif( grOffset >= 0 ){\n\t\t\tif( strcmp(tag_name , LOC_LANG_TAG)==0 ){\n\t\t\t\treturn estrdup(loc_name);\n\t\t\t} else {\n\t\t\t\t/* Since Grandfathered , no value , do nothing , retutn NULL */\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\n\tif( fromParseLocale==1 ){\n\t\t/* Handle singletons */\n\t\tif( strcmp(tag_name , LOC_LANG_TAG)==0 ){\n\t\t\tif( strlen(loc_name)>1 && (isIDPrefix(loc_name) == 1) ){\n\t\t\t\treturn estrdup(loc_name);\n \t\t\t}\n \t\t}\n \n\t\tsingletonPos = getSingletonPos( loc_name );\n \t\tif( singletonPos == 0){\n \t\t\t/* singleton at start of script, region , variant etc.\n \t\t\t * or invalid singleton at start of language */\n\t\t\treturn NULL;\n\t\t} else if( singletonPos > 0 ){\n\t\t\t/* singleton at some position except at start\n\t\t\t * strip off the singleton and rest of the loc_name */\n\t\t\tmod_loc_name = estrndup ( loc_name , singletonPos-1);\n\t\t}\n\t} /* end of if fromParse */\n\n \t} /* end of if != LOC_CANONICAL_TAG */\n \n \tif( mod_loc_name == NULL){\n\t\tmod_loc_name = estrdup(loc_name );\n \t}\n \n \t/* Proceed to ICU */\n    do{\n\t\ttag_value = erealloc( tag_value , buflen  );\n\t\ttag_value_len = buflen;\n\n\t\tif( strcmp(tag_name , LOC_SCRIPT_TAG)==0 ){\n\t\t\tbuflen = uloc_getScript ( mod_loc_name ,tag_value , tag_value_len , &status);\n\t\t}\n\t\tif( strcmp(tag_name , LOC_LANG_TAG )==0 ){\n\t\t\tbuflen = uloc_getLanguage ( mod_loc_name ,tag_value , tag_value_len , &status);\n\t\t}\n\t\tif( strcmp(tag_name , LOC_REGION_TAG)==0 ){\n\t\t\tbuflen = uloc_getCountry ( mod_loc_name ,tag_value , tag_value_len , &status);\n\t\t}\n\t\tif( strcmp(tag_name , LOC_VARIANT_TAG)==0 ){\n\t\t\tbuflen = uloc_getVariant ( mod_loc_name ,tag_value , tag_value_len , &status);\n\t\t}\n\t\tif( strcmp(tag_name , LOC_CANONICALIZE_TAG)==0 ){\n\t\t\tbuflen = uloc_canonicalize ( mod_loc_name ,tag_value , tag_value_len , &status);\n\t\t}\n\n \t\tif( U_FAILURE( status ) ) {\n \t\t\tif( status == U_BUFFER_OVERFLOW_ERROR ) {\n \t\t\t\tstatus = U_ZERO_ERROR;\n\t\t\t\tbuflen++; /* add space for \\0 */\n \t\t\t\tcontinue;\n \t\t\t}\n \n\t\t\t/* Error in retriving data */\n\t\t\t*result = 0;\n\t\t\tif( tag_value ){\n\t\t\t\tefree( tag_value );\n\t\t\t}\n\t\t\tif( mod_loc_name ){\n\t\t\t\tefree( mod_loc_name);\n\t\t\t}\n\t\t\treturn NULL;\n\t\t}\n\t} while( buflen > tag_value_len );\n\n\tif(  buflen ==0 ){\n\t\t/* No value found */\n\t\t*result = -1;\n\t\tif( tag_value ){\n\t\t\tefree( tag_value );\n\t\t}\n\t\tif( mod_loc_name ){\n\t\t\tefree( mod_loc_name);\n\t\t}\n\t\treturn NULL;\n\t} else {\n\t\t*result = 1;\n\t}\n\n\tif( mod_loc_name ){\n\t\tefree( mod_loc_name);\n\t}\n\treturn tag_value;\n}\n",
    "cwe": [
      "CWE-125"
    ],
    "id": 842,
    "_valid_cwes": [
      "CWE-125"
    ]
  },
  {
    "cve_id": "CVE-2018-14016",
    "code_before_change": "static bool r_bin_mdmp_init_directory_entry(struct r_bin_mdmp_obj *obj, struct minidump_directory *entry) {\n\tint i;\n\n\tstruct minidump_handle_operation_list *handle_operation_list;\n\tstruct minidump_memory_list *memory_list;\n\tstruct minidump_memory64_list *memory64_list;\n\tstruct minidump_memory_info_list *memory_info_list;\n\tstruct minidump_module_list *module_list;\n\tstruct minidump_thread_list *thread_list;\n\tstruct minidump_thread_ex_list *thread_ex_list;\n\tstruct minidump_thread_info_list *thread_info_list;\n\tstruct minidump_unloaded_module_list *unloaded_module_list;\n\n\tstruct avrf_handle_operation *handle_operations;\n\tstruct minidump_memory_descriptor *memories;\n\tstruct minidump_memory_descriptor64 *memories64;\n\tstruct minidump_memory_info *memory_infos;\n\tstruct minidump_module *modules;\n\tstruct minidump_thread *threads;\n\tstruct minidump_thread_ex *ex_threads;\n\tstruct minidump_thread_info *thread_infos;\n\tstruct minidump_unloaded_module *unloaded_modules;\n\n \t/* We could confirm data sizes but a malcious MDMP will always get around\n \t** this! But we can ensure that the data is not outside of the file */\n \tif (entry->location.rva + entry->location.data_size > obj->b->length) {\n\t\teprintf(\"[ERROR] Size Mismatch - Stream data is larger than file size!\\n\");\n \t\treturn false;\n \t}\n \n\tswitch (entry->stream_type) {\n\tcase THREAD_LIST_STREAM:\n\t\tthread_list = (struct minidump_thread_list *)(obj->b->buf + entry->location.rva);\n\n\t\tsdb_set (obj->kv, \"mdmp_thread.format\", \"ddddq?? \"\n\t\t\t\"ThreadId SuspendCount PriorityClass Priority \"\n\t\t\t\"Teb (mdmp_memory_descriptor)Stack \"\n\t\t\t\"(mdmp_location_descriptor)ThreadContext\", 0);\n\t\tsdb_num_set (obj->kv, \"mdmp_thread_list.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_thread_list.format\",\n\t\t\tsdb_fmt (\"d[%i]? \"\n\t\t\t\t\"NumberOfThreads (mdmp_thread)Threads\",\n\t\t\t\tthread_list->number_of_threads),\n\t\t\t0);\n\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tfor (i = 0; i < thread_list->number_of_threads; i++) {\n\t\t\tthreads = (struct minidump_thread *)(&(thread_list->threads));\n\t\t\tr_list_append (obj->streams.threads, &(threads[i]));\n\t\t}\n\t\tbreak;\n\tcase MODULE_LIST_STREAM:\n\t\tmodule_list = (struct minidump_module_list *)(obj->b->buf + entry->location.rva);\n\n\t\tsdb_set (obj->kv, \"mdmp_module.format\", \"qddtd???qq \"\n\t\t\t\"BaseOfImage SizeOfImage CheckSum \"\n\t\t\t\"TimeDateStamp ModuleNameRVA \"\n\t\t\t\"(mdmp_vs_fixedfileinfo)VersionInfo \"\n\t\t\t\"(mdmp_location_descriptor)CvRecord \"\n\t\t\t\"(mdmp_location_descriptor)MiscRecord \"\n\t\t\t\"Reserved0 Reserved1\", 0);\n\t\tsdb_num_set (obj->kv, \"mdmp_module_list.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_module_list.format\",\n\t\t\tsdb_fmt (\"d[%i]? \"\n\t\t\t\t\"NumberOfModule (mdmp_module)Modules\",\n\t\t\t\tmodule_list->number_of_modules,\n\t\t\t\t0),\n\t\t\t0);\n\n\t\tfor (i = 0; i < module_list->number_of_modules; i++) {\n\t\t\tmodules = (struct minidump_module *)(&(module_list->modules));\n\t\t\tr_list_append(obj->streams.modules, &(modules[i]));\n\t\t}\n\t\tbreak;\n\tcase MEMORY_LIST_STREAM:\n\t\tmemory_list = (struct minidump_memory_list *)(obj->b->buf + entry->location.rva);\n\n\t\tsdb_num_set (obj->kv, \"mdmp_memory_list.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_memory_list.format\",\n\t\t\tsdb_fmt (\"d[%i]? \"\n\t\t\t\t\"NumberOfMemoryRanges \"\n\t\t\t\t\"(mdmp_memory_descriptor)MemoryRanges \",\n\t\t\t\tmemory_list->number_of_memory_ranges,\n\t\t\t\t0),\n\t\t\t0);\n\n\t\tfor (i = 0; i < memory_list->number_of_memory_ranges; i++) {\n\t\t\tmemories = (struct minidump_memory_descriptor *)(&(memory_list->memory_ranges));\n\t\t\tr_list_append (obj->streams.memories, &(memories[i]));\n\t\t}\n\t\tbreak;\n\tcase EXCEPTION_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tobj->streams.exception = (struct minidump_exception_stream *)(obj->b->buf + entry->location.rva);\n\n\t\tsdb_set (obj->kv, \"mdmp_exception.format\", \"[4]E[4]Eqqdd[15]q \"\n\t\t\t\"(mdmp_exception_code)ExceptionCode \"\n\t\t\t\"(mdmp_exception_flags)ExceptionFlags \"\n\t\t\t\"ExceptionRecord ExceptionAddress \"\n\t\t\t\"NumberParameters __UnusedAlignment \"\n\t\t\t\"ExceptionInformation\", 0);\n\t\tsdb_num_set (obj->kv, \"mdmp_exception_stream.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_exception_stream.format\", \"dd?? \"\n\t\t\t\"ThreadId __Alignment \"\n\t\t\t\"(mdmp_exception)ExceptionRecord \"\n\t\t\t\"(mdmp_location_descriptor)ThreadContext\", 0);\n\n\t\tbreak;\n\tcase SYSTEM_INFO_STREAM:\n\t\tobj->streams.system_info = (struct minidump_system_info *)(obj->b->buf + entry->location.rva);\n\n\t\tsdb_num_set (obj->kv, \"mdmp_system_info.offset\",\n\t\t\tentry->location.rva, 0);\n\t\t/* TODO: We need E as a byte! */\n\t\tsdb_set (obj->kv, \"mdmp_system_info.format\", \"[2]EwwbBddd[4]Ed[2]Ew[2]q \"\n\t\t\t\"(mdmp_processor_architecture)ProcessorArchitecture \"\n\t\t\t\"ProcessorLevel ProcessorRevision NumberOfProcessors \"\n\t\t\t\"(mdmp_product_type)ProductType \"\n\t\t\t\"MajorVersion MinorVersion BuildNumber (mdmp_platform_id)PlatformId \"\n\t\t\t\"CsdVersionRva (mdmp_suite_mask)SuiteMask Reserved2 ProcessorFeatures\", 0);\n\n\t\tbreak;\n\tcase THREAD_EX_LIST_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tthread_ex_list = (struct minidump_thread_ex_list *)(obj->b->buf + entry->location.rva);\n\n\t\tsdb_set (obj->kv, \"mdmp_thread_ex.format\", \"ddddq??? \"\n\t\t\t\"ThreadId SuspendCount PriorityClass Priority \"\n\t\t\t\"Teb (mdmp_memory_descriptor)Stack \"\n\t\t\t\"(mdmp_location_descriptor)ThreadContext \"\n\t\t\t\"(mdmp_memory_descriptor)BackingStore\", 0);\n\t\tsdb_num_set (obj->kv, \"mdmp_thread_ex_list.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_thread_ex_list.format\",\n\t\t\tsdb_fmt (\"d[%i]? NumberOfThreads \"\n\t\t\t\t\"(mdmp_thread_ex)Threads\",\n\t\t\t\tthread_ex_list->number_of_threads, 0),\n\t\t\t0);\n\n\t\tfor (i = 0; i < thread_ex_list->number_of_threads; i++) {\n\t\t\tex_threads = (struct minidump_thread_ex *)(&(thread_ex_list->threads));\n\t\t\tr_list_append (obj->streams.ex_threads, &(ex_threads[i]));\n\t\t}\n\t\tbreak;\n\tcase MEMORY_64_LIST_STREAM:\n\t\tmemory64_list = (struct minidump_memory64_list *)(obj->b->buf + entry->location.rva);\n\n\t\tsdb_num_set (obj->kv, \"mdmp_memory64_list.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_memory64_list.format\",\n\t\t\tsdb_fmt (\"qq[%i]? NumberOfMemoryRanges \"\n\t\t\t\t\"BaseRva \"\n\t\t\t\t\"(mdmp_memory_descriptor64)MemoryRanges\",\n\t\t\t\tmemory64_list->number_of_memory_ranges),\n\t\t\t0);\n\n\t\tobj->streams.memories64.base_rva = memory64_list->base_rva;\n\t\tfor (i = 0; i < memory64_list->number_of_memory_ranges; i++) {\n\t\t\tmemories64 = (struct minidump_memory_descriptor64 *)(&(memory64_list->memory_ranges));\n\t\t\tr_list_append (obj->streams.memories64.memories, &(memories64[i]));\n\t\t}\n\t\tbreak;\n\tcase COMMENT_STREAM_A:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tobj->streams.comments_a = obj->b->buf + entry->location.rva;\n\n\t\tsdb_num_set (obj->kv, \"mdmp_comment_stream_a.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_comment_stream_a.format\",\n\t\t\t\"s CommentA\", 0);\n\n\t\tbreak;\n\tcase COMMENT_STREAM_W:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tobj->streams.comments_w = obj->b->buf + entry->location.rva;\n\n\t\tsdb_num_set (obj->kv, \"mdmp_comment_stream_w.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_comment_stream_w.format\",\n\t\t\t\t\"s CommentW\", 0);\n\n\t\tbreak;\n\tcase HANDLE_DATA_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tobj->streams.handle_data = (struct minidump_handle_data_stream *)(obj->b->buf + entry->location.rva);\n\n\t\tsdb_num_set (obj->kv, \"mdmp_handle_data_stream.offset\",\n\t\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_handle_data_stream.format\", \"dddd \"\n\t\t\t\t\"SizeOfHeader SizeOfDescriptor \"\n\t\t\t\t\"NumberOfDescriptors Reserved\", 0);\n\t\tbreak;\n\tcase FUNCTION_TABLE_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tobj->streams.function_table = (struct minidump_function_table_stream *)(obj->b->buf + entry->location.rva);\n\n\t\tsdb_num_set (obj->kv, \"mdmp_function_table_stream.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_function_table_stream.format\", \"dddddd \"\n\t\t\t\"SizeOfHeader SizeOfDescriptor SizeOfNativeDescriptor \"\n\t\t\t\"SizeOfFunctionEntry NumberOfDescriptors SizeOfAlignPad\",\n\t\t\t0);\n\t\tbreak;\n\tcase UNLOADED_MODULE_LIST_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tunloaded_module_list = (struct minidump_unloaded_module_list *)(obj->b->buf + entry->location.rva);\n\n\t\tsdb_set (obj->kv, \"mdmp_unloaded_module.format\", \"qddtd \"\n\t\t\t\"BaseOfImage SizeOfImage CheckSum TimeDateStamp \"\n\t\t\t\"ModuleNameRva\", 0);\n\t\tsdb_num_set (obj->kv, \"mdmp_unloaded_module_list.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_unloaded_module_list.format\", \"ddd \"\n\t\t\t\"SizeOfHeader SizeOfEntry NumberOfEntries\", 0);\n\n\t\tfor (i = 0; i < unloaded_module_list->number_of_entries; i++) {\n\t\t\tunloaded_modules = (struct minidump_unloaded_module *)((ut8 *)&unloaded_module_list + sizeof (struct minidump_unloaded_module_list));\n\t\t\tr_list_append (obj->streams.unloaded_modules, &(unloaded_modules[i]));\n\t\t}\n\t\tbreak;\n\tcase MISC_INFO_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tobj->streams.misc_info.misc_info_1 = (struct minidump_misc_info *)(obj->b->buf + entry->location.rva);\n\n\t\t/* TODO: Handle different sizes */\n\t\tsdb_num_set (obj->kv, \"mdmp_misc_info.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_misc_info.format\", \"d[4]Bdtttddddd \"\n\t\t\t\"SizeOfInfo (mdmp_misc1_flags)Flags1 ProcessId \"\n\t\t\t\"ProcessCreateTime ProcessUserTime ProcessKernelTime \"\n\t\t\t\"ProcessorMaxMhz ProcessorCurrentMhz \"\n\t\t\t\"ProcessorMhzLimit ProcessorMaxIdleState \"\n\t\t\t\"ProcessorCurrentIdleState\", 0);\n\n\t\tbreak;\n\tcase MEMORY_INFO_LIST_STREAM:\n\t\tmemory_info_list = (struct minidump_memory_info_list *)(obj->b->buf + entry->location.rva);\n\n\t\tsdb_set (obj->kv, \"mdmp_memory_info.format\",\n\t\t\t\"qq[4]Edq[4]E[4]E[4]Ed BaseAddress AllocationBase \"\n\t\t\t\"(mdmp_page_protect)AllocationProtect __Alignment1 RegionSize \"\n\t\t\t\"(mdmp_mem_state)State (mdmp_page_protect)Protect \"\n\t\t\t\"(mdmp_mem_type)Type __Alignment2\", 0);\n\t\tsdb_num_set (obj->kv, \"mdmp_memory_info_list.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_memory_info_list.format\",\n\t\t\tsdb_fmt (\"ddq[%i]? SizeOfHeader SizeOfEntry \"\n\t\t\t\t\"NumberOfEntries (mdmp_memory_info)MemoryInfo\",\n\t\t\t\tmemory_info_list->number_of_entries),\n\t\t\t0);\n\n\t\tfor (i = 0; i < memory_info_list->number_of_entries; i++) {\n\t\t\tmemory_infos = (struct minidump_memory_info *)((ut8 *)memory_info_list + sizeof (struct minidump_memory_info_list));\n\t\t\tr_list_append (obj->streams.memory_infos, &(memory_infos[i]));\n\t\t}\n\t\tbreak;\n\tcase THREAD_INFO_LIST_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tthread_info_list = (struct minidump_thread_info_list *)(obj->b->buf + entry->location.rva);\n\n\t\tsdb_set (obj->kv, \"mdmp_thread_info.format\", \"ddddttttqq \"\n\t\t\t\"ThreadId DumpFlags DumpError ExitStatus CreateTime \"\n\t\t\t\"ExitTime KernelTime UserTime StartAddress Affinity\",\n\t\t\t0);\n\t\tsdb_num_set (obj->kv, \"mdmp_thread_info_list.offset\",\n\t\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_thread_info_list.format\", \"ddd \"\n\t\t\t\"SizeOfHeader SizeOfEntry NumberOfEntries\", 0);\n\n\t\tfor (i = 0; i < thread_info_list->number_of_entries; i++) {\n\t\t\tthread_infos = (struct minidump_thread_info *)((ut8 *)thread_info_list + sizeof (struct minidump_thread_info_list));\n\t\t\tr_list_append (obj->streams.thread_infos, &(thread_infos[i]));\n\t\t}\n\t\tbreak;\n\tcase HANDLE_OPERATION_LIST_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\thandle_operation_list = (struct minidump_handle_operation_list *)(obj->b->buf + entry->location.rva);\n\n\t\tsdb_num_set (obj->kv, \"mdmp_handle_operation_list.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_handle_operation_list.format\", \"dddd \"\n\t\t\t\"SizeOfHeader SizeOfEntry NumberOfEntries Reserved\", 0);\n\n\t\tfor (i = 0; i < handle_operation_list->number_of_entries; i++) {\n\t\t\thandle_operations = (struct avrf_handle_operation *)((ut8 *)handle_operation_list + sizeof (struct minidump_handle_operation_list));\n\t\t\tr_list_append (obj->streams.operations, &(handle_operations[i]));\n\t\t}\n\n\t\tbreak;\n\tcase LAST_RESERVED_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tbreak;\n\tcase UNUSED_STREAM:\n\tcase RESERVED_STREAM_0:\n\tcase RESERVED_STREAM_1:\n\t\t/* Silently ignore reserved streams */\n\t\tbreak;\n\tdefault:\n\t\teprintf (\"[WARN] Invalid or unsupported enumeration encountered %i\\n\", entry->stream_type);\n\t\treturn false;\n\t}\n\treturn true;\n}\n",
    "code_after_change": "static bool r_bin_mdmp_init_directory_entry(struct r_bin_mdmp_obj *obj, struct minidump_directory *entry) {\n\tint i;\n\n\tstruct minidump_handle_operation_list *handle_operation_list;\n\tstruct minidump_memory_list *memory_list;\n\tstruct minidump_memory64_list *memory64_list;\n\tstruct minidump_memory_info_list *memory_info_list;\n\tstruct minidump_module_list *module_list;\n\tstruct minidump_thread_list *thread_list;\n\tstruct minidump_thread_ex_list *thread_ex_list;\n\tstruct minidump_thread_info_list *thread_info_list;\n\tstruct minidump_unloaded_module_list *unloaded_module_list;\n\n\tstruct avrf_handle_operation *handle_operations;\n\tstruct minidump_memory_descriptor *memories;\n\tstruct minidump_memory_descriptor64 *memories64;\n\tstruct minidump_memory_info *memory_infos;\n\tstruct minidump_module *modules;\n\tstruct minidump_thread *threads;\n\tstruct minidump_thread_ex *ex_threads;\n\tstruct minidump_thread_info *thread_infos;\n\tstruct minidump_unloaded_module *unloaded_modules;\n\n \t/* We could confirm data sizes but a malcious MDMP will always get around\n \t** this! But we can ensure that the data is not outside of the file */\n \tif (entry->location.rva + entry->location.data_size > obj->b->length) {\n\t\teprintf (\"[ERROR] Size Mismatch - Stream data is larger than file size!\\n\");\n \t\treturn false;\n \t}\n \n\tswitch (entry->stream_type) {\n\tcase THREAD_LIST_STREAM:\n\t\tthread_list = (struct minidump_thread_list *)(obj->b->buf + entry->location.rva);\n\n\t\tsdb_set (obj->kv, \"mdmp_thread.format\", \"ddddq?? \"\n\t\t\t\"ThreadId SuspendCount PriorityClass Priority \"\n\t\t\t\"Teb (mdmp_memory_descriptor)Stack \"\n\t\t\t\"(mdmp_location_descriptor)ThreadContext\", 0);\n\t\tsdb_num_set (obj->kv, \"mdmp_thread_list.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_thread_list.format\",\n\t\t\tsdb_fmt (\"d[%i]? \"\n\t\t\t\t\"NumberOfThreads (mdmp_thread)Threads\",\n\t\t\t\tthread_list->number_of_threads),\n\t\t\t0);\n\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tfor (i = 0; i < thread_list->number_of_threads; i++) {\n\t\t\tthreads = (struct minidump_thread *)(&(thread_list->threads));\n\t\t\tr_list_append (obj->streams.threads, &(threads[i]));\n\t\t}\n\t\tbreak;\n\tcase MODULE_LIST_STREAM:\n\t\tmodule_list = (struct minidump_module_list *)(obj->b->buf + entry->location.rva);\n\n\t\tsdb_set (obj->kv, \"mdmp_module.format\", \"qddtd???qq \"\n\t\t\t\"BaseOfImage SizeOfImage CheckSum \"\n\t\t\t\"TimeDateStamp ModuleNameRVA \"\n\t\t\t\"(mdmp_vs_fixedfileinfo)VersionInfo \"\n\t\t\t\"(mdmp_location_descriptor)CvRecord \"\n\t\t\t\"(mdmp_location_descriptor)MiscRecord \"\n\t\t\t\"Reserved0 Reserved1\", 0);\n\t\tsdb_num_set (obj->kv, \"mdmp_module_list.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_module_list.format\",\n\t\t\tsdb_fmt (\"d[%i]? \"\n\t\t\t\t\"NumberOfModule (mdmp_module)Modules\",\n\t\t\t\tmodule_list->number_of_modules,\n\t\t\t\t0),\n\t\t\t0);\n\n\t\tfor (i = 0; i < module_list->number_of_modules; i++) {\n\t\t\tmodules = (struct minidump_module *)(&(module_list->modules));\n\t\t\tr_list_append(obj->streams.modules, &(modules[i]));\n\t\t}\n\t\tbreak;\n\tcase MEMORY_LIST_STREAM:\n\t\tmemory_list = (struct minidump_memory_list *)(obj->b->buf + entry->location.rva);\n\n\t\tsdb_num_set (obj->kv, \"mdmp_memory_list.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_memory_list.format\",\n\t\t\tsdb_fmt (\"d[%i]? \"\n\t\t\t\t\"NumberOfMemoryRanges \"\n\t\t\t\t\"(mdmp_memory_descriptor)MemoryRanges \",\n\t\t\t\tmemory_list->number_of_memory_ranges,\n\t\t\t\t0),\n\t\t\t0);\n\n\t\tfor (i = 0; i < memory_list->number_of_memory_ranges; i++) {\n\t\t\tmemories = (struct minidump_memory_descriptor *)(&(memory_list->memory_ranges));\n\t\t\tr_list_append (obj->streams.memories, &(memories[i]));\n\t\t}\n\t\tbreak;\n\tcase EXCEPTION_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tobj->streams.exception = (struct minidump_exception_stream *)(obj->b->buf + entry->location.rva);\n\n\t\tsdb_set (obj->kv, \"mdmp_exception.format\", \"[4]E[4]Eqqdd[15]q \"\n\t\t\t\"(mdmp_exception_code)ExceptionCode \"\n\t\t\t\"(mdmp_exception_flags)ExceptionFlags \"\n\t\t\t\"ExceptionRecord ExceptionAddress \"\n\t\t\t\"NumberParameters __UnusedAlignment \"\n\t\t\t\"ExceptionInformation\", 0);\n\t\tsdb_num_set (obj->kv, \"mdmp_exception_stream.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_exception_stream.format\", \"dd?? \"\n\t\t\t\"ThreadId __Alignment \"\n\t\t\t\"(mdmp_exception)ExceptionRecord \"\n\t\t\t\"(mdmp_location_descriptor)ThreadContext\", 0);\n\n\t\tbreak;\n\tcase SYSTEM_INFO_STREAM:\n\t\tobj->streams.system_info = (struct minidump_system_info *)(obj->b->buf + entry->location.rva);\n\n\t\tsdb_num_set (obj->kv, \"mdmp_system_info.offset\",\n\t\t\tentry->location.rva, 0);\n\t\t/* TODO: We need E as a byte! */\n\t\tsdb_set (obj->kv, \"mdmp_system_info.format\", \"[2]EwwbBddd[4]Ed[2]Ew[2]q \"\n\t\t\t\"(mdmp_processor_architecture)ProcessorArchitecture \"\n\t\t\t\"ProcessorLevel ProcessorRevision NumberOfProcessors \"\n\t\t\t\"(mdmp_product_type)ProductType \"\n\t\t\t\"MajorVersion MinorVersion BuildNumber (mdmp_platform_id)PlatformId \"\n\t\t\t\"CsdVersionRva (mdmp_suite_mask)SuiteMask Reserved2 ProcessorFeatures\", 0);\n\n\t\tbreak;\n\tcase THREAD_EX_LIST_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tthread_ex_list = (struct minidump_thread_ex_list *)(obj->b->buf + entry->location.rva);\n\n\t\tsdb_set (obj->kv, \"mdmp_thread_ex.format\", \"ddddq??? \"\n\t\t\t\"ThreadId SuspendCount PriorityClass Priority \"\n\t\t\t\"Teb (mdmp_memory_descriptor)Stack \"\n\t\t\t\"(mdmp_location_descriptor)ThreadContext \"\n\t\t\t\"(mdmp_memory_descriptor)BackingStore\", 0);\n\t\tsdb_num_set (obj->kv, \"mdmp_thread_ex_list.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_thread_ex_list.format\",\n\t\t\tsdb_fmt (\"d[%i]? NumberOfThreads \"\n\t\t\t\t\"(mdmp_thread_ex)Threads\",\n\t\t\t\tthread_ex_list->number_of_threads, 0),\n\t\t\t0);\n\n\t\tfor (i = 0; i < thread_ex_list->number_of_threads; i++) {\n\t\t\tex_threads = (struct minidump_thread_ex *)(&(thread_ex_list->threads));\n\t\t\tr_list_append (obj->streams.ex_threads, &(ex_threads[i]));\n\t\t}\n\t\tbreak;\n\tcase MEMORY_64_LIST_STREAM:\n\t\tmemory64_list = (struct minidump_memory64_list *)(obj->b->buf + entry->location.rva);\n\n\t\tsdb_num_set (obj->kv, \"mdmp_memory64_list.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_memory64_list.format\",\n\t\t\tsdb_fmt (\"qq[%i]? NumberOfMemoryRanges \"\n\t\t\t\t\"BaseRva \"\n\t\t\t\t\"(mdmp_memory_descriptor64)MemoryRanges\",\n\t\t\t\tmemory64_list->number_of_memory_ranges),\n\t\t\t0);\n\n\t\tobj->streams.memories64.base_rva = memory64_list->base_rva;\n\t\tfor (i = 0; i < memory64_list->number_of_memory_ranges; i++) {\n\t\t\tmemories64 = (struct minidump_memory_descriptor64 *)(&(memory64_list->memory_ranges));\n\t\t\tr_list_append (obj->streams.memories64.memories, &(memories64[i]));\n\t\t}\n\t\tbreak;\n\tcase COMMENT_STREAM_A:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tobj->streams.comments_a = obj->b->buf + entry->location.rva;\n\n\t\tsdb_num_set (obj->kv, \"mdmp_comment_stream_a.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_comment_stream_a.format\",\n\t\t\t\"s CommentA\", 0);\n\n\t\tbreak;\n\tcase COMMENT_STREAM_W:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tobj->streams.comments_w = obj->b->buf + entry->location.rva;\n\n\t\tsdb_num_set (obj->kv, \"mdmp_comment_stream_w.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_comment_stream_w.format\",\n\t\t\t\t\"s CommentW\", 0);\n\n\t\tbreak;\n\tcase HANDLE_DATA_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tobj->streams.handle_data = (struct minidump_handle_data_stream *)(obj->b->buf + entry->location.rva);\n\n\t\tsdb_num_set (obj->kv, \"mdmp_handle_data_stream.offset\",\n\t\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_handle_data_stream.format\", \"dddd \"\n\t\t\t\t\"SizeOfHeader SizeOfDescriptor \"\n\t\t\t\t\"NumberOfDescriptors Reserved\", 0);\n\t\tbreak;\n\tcase FUNCTION_TABLE_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tobj->streams.function_table = (struct minidump_function_table_stream *)(obj->b->buf + entry->location.rva);\n\n\t\tsdb_num_set (obj->kv, \"mdmp_function_table_stream.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_function_table_stream.format\", \"dddddd \"\n\t\t\t\"SizeOfHeader SizeOfDescriptor SizeOfNativeDescriptor \"\n\t\t\t\"SizeOfFunctionEntry NumberOfDescriptors SizeOfAlignPad\",\n\t\t\t0);\n\t\tbreak;\n\tcase UNLOADED_MODULE_LIST_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tunloaded_module_list = (struct minidump_unloaded_module_list *)(obj->b->buf + entry->location.rva);\n\n\t\tsdb_set (obj->kv, \"mdmp_unloaded_module.format\", \"qddtd \"\n\t\t\t\"BaseOfImage SizeOfImage CheckSum TimeDateStamp \"\n\t\t\t\"ModuleNameRva\", 0);\n\t\tsdb_num_set (obj->kv, \"mdmp_unloaded_module_list.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_unloaded_module_list.format\", \"ddd \"\n\t\t\t\"SizeOfHeader SizeOfEntry NumberOfEntries\", 0);\n\n\t\tfor (i = 0; i < unloaded_module_list->number_of_entries; i++) {\n\t\t\tunloaded_modules = (struct minidump_unloaded_module *)((ut8 *)&unloaded_module_list + sizeof (struct minidump_unloaded_module_list));\n\t\t\tr_list_append (obj->streams.unloaded_modules, &(unloaded_modules[i]));\n\t\t}\n\t\tbreak;\n\tcase MISC_INFO_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tobj->streams.misc_info.misc_info_1 = (struct minidump_misc_info *)(obj->b->buf + entry->location.rva);\n\n\t\t/* TODO: Handle different sizes */\n\t\tsdb_num_set (obj->kv, \"mdmp_misc_info.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_misc_info.format\", \"d[4]Bdtttddddd \"\n\t\t\t\"SizeOfInfo (mdmp_misc1_flags)Flags1 ProcessId \"\n\t\t\t\"ProcessCreateTime ProcessUserTime ProcessKernelTime \"\n\t\t\t\"ProcessorMaxMhz ProcessorCurrentMhz \"\n\t\t\t\"ProcessorMhzLimit ProcessorMaxIdleState \"\n\t\t\t\"ProcessorCurrentIdleState\", 0);\n\n\t\tbreak;\n\tcase MEMORY_INFO_LIST_STREAM:\n\t\tmemory_info_list = (struct minidump_memory_info_list *)(obj->b->buf + entry->location.rva);\n\n\t\tsdb_set (obj->kv, \"mdmp_memory_info.format\",\n\t\t\t\"qq[4]Edq[4]E[4]E[4]Ed BaseAddress AllocationBase \"\n\t\t\t\"(mdmp_page_protect)AllocationProtect __Alignment1 RegionSize \"\n\t\t\t\"(mdmp_mem_state)State (mdmp_page_protect)Protect \"\n\t\t\t\"(mdmp_mem_type)Type __Alignment2\", 0);\n\t\tsdb_num_set (obj->kv, \"mdmp_memory_info_list.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_memory_info_list.format\",\n\t\t\tsdb_fmt (\"ddq[%i]? SizeOfHeader SizeOfEntry \"\n\t\t\t\t\"NumberOfEntries (mdmp_memory_info)MemoryInfo\",\n\t\t\t\tmemory_info_list->number_of_entries),\n\t\t\t0);\n\n\t\tfor (i = 0; i < memory_info_list->number_of_entries; i++) {\n\t\t\tmemory_infos = (struct minidump_memory_info *)((ut8 *)memory_info_list + sizeof (struct minidump_memory_info_list));\n\t\t\tr_list_append (obj->streams.memory_infos, &(memory_infos[i]));\n\t\t}\n\t\tbreak;\n\tcase THREAD_INFO_LIST_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tthread_info_list = (struct minidump_thread_info_list *)(obj->b->buf + entry->location.rva);\n\n\t\tsdb_set (obj->kv, \"mdmp_thread_info.format\", \"ddddttttqq \"\n\t\t\t\"ThreadId DumpFlags DumpError ExitStatus CreateTime \"\n\t\t\t\"ExitTime KernelTime UserTime StartAddress Affinity\",\n\t\t\t0);\n\t\tsdb_num_set (obj->kv, \"mdmp_thread_info_list.offset\",\n\t\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_thread_info_list.format\", \"ddd \"\n\t\t\t\"SizeOfHeader SizeOfEntry NumberOfEntries\", 0);\n\n\t\tfor (i = 0; i < thread_info_list->number_of_entries; i++) {\n\t\t\tthread_infos = (struct minidump_thread_info *)((ut8 *)thread_info_list + sizeof (struct minidump_thread_info_list));\n\t\t\tr_list_append (obj->streams.thread_infos, &(thread_infos[i]));\n\t\t}\n\t\tbreak;\n\tcase HANDLE_OPERATION_LIST_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\thandle_operation_list = (struct minidump_handle_operation_list *)(obj->b->buf + entry->location.rva);\n\n\t\tsdb_num_set (obj->kv, \"mdmp_handle_operation_list.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_handle_operation_list.format\", \"dddd \"\n\t\t\t\"SizeOfHeader SizeOfEntry NumberOfEntries Reserved\", 0);\n\n\t\tfor (i = 0; i < handle_operation_list->number_of_entries; i++) {\n\t\t\thandle_operations = (struct avrf_handle_operation *)((ut8 *)handle_operation_list + sizeof (struct minidump_handle_operation_list));\n\t\t\tr_list_append (obj->streams.operations, &(handle_operations[i]));\n\t\t}\n\n\t\tbreak;\n\tcase LAST_RESERVED_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tbreak;\n\tcase UNUSED_STREAM:\n\tcase RESERVED_STREAM_0:\n\tcase RESERVED_STREAM_1:\n\t\t/* Silently ignore reserved streams */\n\t\tbreak;\n\tdefault:\n\t\teprintf (\"[WARN] Invalid or unsupported enumeration encountered %i\\n\", entry->stream_type);\n\t\treturn false;\n\t}\n\treturn true;\n}\n",
    "cwe": [
      "CWE-125"
    ],
    "id": 874,
    "_valid_cwes": [
      "CWE-125"
    ]
  },
  {
    "cve_id": "CVE-2018-16427",
    "code_before_change": "gpk_parse_fileinfo(sc_card_t *card,\n\t\tconst u8 *buf, size_t buflen,\n\t\tsc_file_t *file)\n{\n\tconst u8\t*sp, *end, *next;\n\tint\t\ti, rc;\n\n\tmemset(file, 0, sizeof(*file));\n\tfor (i = 0; i < SC_MAX_AC_OPS; i++)\n\t\tsc_file_add_acl_entry(file, i, SC_AC_UNKNOWN, SC_AC_KEY_REF_NONE);\n\n\tend = buf + buflen;\n\tfor (sp = buf; sp + 2 < end; sp = next) {\n\t\tnext = sp + 2 + sp[1];\n\t\tif (next > end)\n\t\t\tbreak;\n\t\tif (sp[0] == 0x84) {\n\t\t\t/* ignore if name is longer than what it should be */\n\t\t\tif (sp[1] > sizeof(file->name))\n\t\t\t\tcontinue;\n\t\t\tmemset(file->name, 0, sizeof(file->name));\n\t\t\tmemcpy(file->name, sp+2, sp[1]);\n\t\t} else\n \t\tif (sp[0] == 0x85) {\n \t\t\tunsigned int\tac[3], n;\n \n \t\t\tfile->id = (sp[4] << 8) | sp[5];\n \t\t\tfile->size = (sp[8] << 8) | sp[9];\n \t\t\tfile->record_length = sp[7];\n\n\t\t\t/* Map ACLs. Note the third AC byte is\n\t\t\t * valid of EFs only */\n\t\t\tfor (n = 0; n < 3; n++)\n\t\t\t\tac[n] = (sp[10+2*n] << 8) | sp[11+2*n];\n\n\t\t\t/* Examine file type */\n\t\t\tswitch (sp[6] & 7) {\n\t\t\tcase 0x01: case 0x02: case 0x03: case 0x04:\n\t\t\tcase 0x05: case 0x06: case 0x07:\n\t\t\t\tfile->type = SC_FILE_TYPE_WORKING_EF;\n\t\t\t\tfile->ef_structure = sp[6] & 7;\n\t\t\t\tac_to_acl(ac[0], file, SC_AC_OP_UPDATE);\n\t\t\t\tac_to_acl(ac[1], file, SC_AC_OP_WRITE);\n\t\t\t\tac_to_acl(ac[2], file, SC_AC_OP_READ);\n\t\t\t\tbreak;\n\t\t\tcase 0x00: /* 0x38 is DF */\n\t\t\t\tfile->type = SC_FILE_TYPE_DF;\n\t\t\t\t/* Icky: the GPK uses different ACLs\n\t\t\t\t * for creating data files and\n\t\t\t\t * 'sensitive' i.e. key files */\n\t\t\t\tac_to_acl(ac[0], file, SC_AC_OP_LOCK);\n\t\t\t\tac_to_acl(ac[1], file, SC_AC_OP_CREATE);\n\t\t\t\tsc_file_add_acl_entry(file, SC_AC_OP_SELECT,\n\t\t\t\t\tSC_AC_NONE, SC_AC_KEY_REF_NONE);\n\t\t\t\tsc_file_add_acl_entry(file, SC_AC_OP_DELETE,\n\t\t\t\t\tSC_AC_NEVER, SC_AC_KEY_REF_NONE);\n\t\t\t\tsc_file_add_acl_entry(file, SC_AC_OP_REHABILITATE,\n\t\t\t\t\tSC_AC_NEVER, SC_AC_KEY_REF_NONE);\n\t\t\t\tsc_file_add_acl_entry(file, SC_AC_OP_INVALIDATE,\n\t\t\t\t\tSC_AC_NEVER, SC_AC_KEY_REF_NONE);\n\t\t\t\tsc_file_add_acl_entry(file, SC_AC_OP_LIST_FILES,\n\t\t\t\t\tSC_AC_NEVER, SC_AC_KEY_REF_NONE);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\tif (sp[0] == 0x6f) {\n\t\t\t/* oops - this is a directory with an IADF.\n\t\t\t * This happens with the personalized GemSafe cards\n\t\t\t * for instance. */\n\t\t\tfile->type = SC_FILE_TYPE_DF;\n\t\t\trc = gpk_parse_fci(card, sp + 2, sp[1], file);\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\t\t}\n\t}\n\n\tif (file->record_length)\n\t\tfile->record_count = file->size / file->record_length;\n\tfile->magic = SC_FILE_MAGIC;\n\n\treturn 0;\n}\n",
    "code_after_change": "gpk_parse_fileinfo(sc_card_t *card,\n\t\tconst u8 *buf, size_t buflen,\n\t\tsc_file_t *file)\n{\n\tconst u8\t*sp, *end, *next;\n\tint\t\ti, rc;\n\n\tmemset(file, 0, sizeof(*file));\n\tfor (i = 0; i < SC_MAX_AC_OPS; i++)\n\t\tsc_file_add_acl_entry(file, i, SC_AC_UNKNOWN, SC_AC_KEY_REF_NONE);\n\n\tend = buf + buflen;\n\tfor (sp = buf; sp + 2 < end; sp = next) {\n\t\tnext = sp + 2 + sp[1];\n\t\tif (next > end)\n\t\t\tbreak;\n\t\tif (sp[0] == 0x84) {\n\t\t\t/* ignore if name is longer than what it should be */\n\t\t\tif (sp[1] > sizeof(file->name))\n\t\t\t\tcontinue;\n\t\t\tmemset(file->name, 0, sizeof(file->name));\n\t\t\tmemcpy(file->name, sp+2, sp[1]);\n\t\t} else\n \t\tif (sp[0] == 0x85) {\n \t\t\tunsigned int\tac[3], n;\n \n\t\t\tif (sp + 11 + 2*3 >= end)\n\t\t\t\tbreak;\n\n \t\t\tfile->id = (sp[4] << 8) | sp[5];\n \t\t\tfile->size = (sp[8] << 8) | sp[9];\n \t\t\tfile->record_length = sp[7];\n\n\t\t\t/* Map ACLs. Note the third AC byte is\n\t\t\t * valid of EFs only */\n\t\t\tfor (n = 0; n < 3; n++)\n\t\t\t\tac[n] = (sp[10+2*n] << 8) | sp[11+2*n];\n\n\t\t\t/* Examine file type */\n\t\t\tswitch (sp[6] & 7) {\n\t\t\tcase 0x01: case 0x02: case 0x03: case 0x04:\n\t\t\tcase 0x05: case 0x06: case 0x07:\n\t\t\t\tfile->type = SC_FILE_TYPE_WORKING_EF;\n\t\t\t\tfile->ef_structure = sp[6] & 7;\n\t\t\t\tac_to_acl(ac[0], file, SC_AC_OP_UPDATE);\n\t\t\t\tac_to_acl(ac[1], file, SC_AC_OP_WRITE);\n\t\t\t\tac_to_acl(ac[2], file, SC_AC_OP_READ);\n\t\t\t\tbreak;\n\t\t\tcase 0x00: /* 0x38 is DF */\n\t\t\t\tfile->type = SC_FILE_TYPE_DF;\n\t\t\t\t/* Icky: the GPK uses different ACLs\n\t\t\t\t * for creating data files and\n\t\t\t\t * 'sensitive' i.e. key files */\n\t\t\t\tac_to_acl(ac[0], file, SC_AC_OP_LOCK);\n\t\t\t\tac_to_acl(ac[1], file, SC_AC_OP_CREATE);\n\t\t\t\tsc_file_add_acl_entry(file, SC_AC_OP_SELECT,\n\t\t\t\t\tSC_AC_NONE, SC_AC_KEY_REF_NONE);\n\t\t\t\tsc_file_add_acl_entry(file, SC_AC_OP_DELETE,\n\t\t\t\t\tSC_AC_NEVER, SC_AC_KEY_REF_NONE);\n\t\t\t\tsc_file_add_acl_entry(file, SC_AC_OP_REHABILITATE,\n\t\t\t\t\tSC_AC_NEVER, SC_AC_KEY_REF_NONE);\n\t\t\t\tsc_file_add_acl_entry(file, SC_AC_OP_INVALIDATE,\n\t\t\t\t\tSC_AC_NEVER, SC_AC_KEY_REF_NONE);\n\t\t\t\tsc_file_add_acl_entry(file, SC_AC_OP_LIST_FILES,\n\t\t\t\t\tSC_AC_NEVER, SC_AC_KEY_REF_NONE);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\tif (sp[0] == 0x6f) {\n\t\t\t/* oops - this is a directory with an IADF.\n\t\t\t * This happens with the personalized GemSafe cards\n\t\t\t * for instance. */\n\t\t\tfile->type = SC_FILE_TYPE_DF;\n\t\t\trc = gpk_parse_fci(card, sp + 2, sp[1], file);\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\t\t}\n\t}\n\n\tif (file->record_length)\n\t\tfile->record_count = file->size / file->record_length;\n\tfile->magic = SC_FILE_MAGIC;\n\n\treturn 0;\n}\n",
    "cwe": [
      "CWE-125"
    ],
    "id": 907,
    "_valid_cwes": [
      "CWE-125"
    ]
  },
  {
    "cve_id": "CVE-2017-13006",
    "code_before_change": "l2tp_proxy_auth_id_print(netdissect_options *ndo, const u_char *dat)\n {\n \tconst uint16_t *ptr = (const uint16_t *)dat;\n \n \tND_PRINT((ndo, \"%u\", EXTRACT_16BITS(ptr) & L2TP_PROXY_AUTH_ID_MASK));\n }\n",
    "code_after_change": "l2tp_proxy_auth_id_print(netdissect_options *ndo, const u_char *dat)\nl2tp_proxy_auth_id_print(netdissect_options *ndo, const u_char *dat, u_int length)\n {\n \tconst uint16_t *ptr = (const uint16_t *)dat;\n \n\tif (length < 2) {\n\t\tND_PRINT((ndo, \"AVP too short\"));\n\t\treturn;\n\t}\n \tND_PRINT((ndo, \"%u\", EXTRACT_16BITS(ptr) & L2TP_PROXY_AUTH_ID_MASK));\n }\n",
    "cwe": [
      "CWE-125"
    ],
    "id": 948,
    "_valid_cwes": [
      "CWE-125"
    ]
  },
  {
    "cve_id": "CVE-2013-7456",
    "code_before_change": "int gdTransformAffineGetImage(gdImagePtr *dst,\n\t\t  const gdImagePtr src,\n\t\t  gdRectPtr src_area,\n\t\t  const double affine[6])\n{\n\tint res;\n\tdouble m[6];\n\tgdRect bbox;\n\tgdRect area_full;\n\n\tif (src_area == NULL) {\n\t\tarea_full.x = 0;\n\t\tarea_full.y = 0;\n\t\tarea_full.width  = gdImageSX(src);\n\t\tarea_full.height = gdImageSY(src);\n\t\tsrc_area = &area_full;\n\t}\n\n\tgdTransformAffineBoundingBox(src_area, affine, &bbox);\n\n\t*dst = gdImageCreateTrueColor(bbox.width, bbox.height);\n\tif (*dst == NULL) {\n\t\treturn GD_FALSE;\n\t}\n\t(*dst)->saveAlphaFlag = 1;\n\n \tif (!src->trueColor) {\n \t\tgdImagePaletteToTrueColor(src);\n \t}\n \t/* Translate to dst origin (0,0) */\n \tgdAffineTranslate(m, -bbox.x, -bbox.y);\n \tgdAffineConcat(m, affine, m);\n\n\tgdImageAlphaBlending(*dst, 0);\n\n\tres = gdTransformAffineCopy(*dst,\n\t\t  0,0,\n\t\t  src,\n\t\t  src_area,\n\t\t  m);\n\n\tif (res != GD_TRUE) {\n\t\tgdImageDestroy(*dst);\n\t\tdst = NULL;\n\t\treturn GD_FALSE;\n\t} else {\n\t\treturn GD_TRUE;\n\t}\n}\n",
    "code_after_change": "int gdTransformAffineGetImage(gdImagePtr *dst,\n\t\t  const gdImagePtr src,\n\t\t  gdRectPtr src_area,\n\t\t  const double affine[6])\n{\n\tint res;\n\tdouble m[6];\n\tgdRect bbox;\n\tgdRect area_full;\n\n\tif (src_area == NULL) {\n\t\tarea_full.x = 0;\n\t\tarea_full.y = 0;\n\t\tarea_full.width  = gdImageSX(src);\n\t\tarea_full.height = gdImageSY(src);\n\t\tsrc_area = &area_full;\n\t}\n\n\tgdTransformAffineBoundingBox(src_area, affine, &bbox);\n\n\t*dst = gdImageCreateTrueColor(bbox.width, bbox.height);\n\tif (*dst == NULL) {\n\t\treturn GD_FALSE;\n\t}\n\t(*dst)->saveAlphaFlag = 1;\n\n \tif (!src->trueColor) {\n \t\tgdImagePaletteToTrueColor(src);\n \t}\n\n \t/* Translate to dst origin (0,0) */\n \tgdAffineTranslate(m, -bbox.x, -bbox.y);\n \tgdAffineConcat(m, affine, m);\n\n\tgdImageAlphaBlending(*dst, 0);\n\n\tres = gdTransformAffineCopy(*dst,\n\t\t  0,0,\n\t\t  src,\n\t\t  src_area,\n\t\t  m);\n\n\tif (res != GD_TRUE) {\n\t\tgdImageDestroy(*dst);\n\t\tdst = NULL;\n\t\treturn GD_FALSE;\n\t} else {\n\t\treturn GD_TRUE;\n\t}\n}\n",
    "cwe": [
      "CWE-125"
    ],
    "id": 953,
    "_valid_cwes": [
      "CWE-125"
    ]
  },
  {
    "cve_id": "CVE-2017-13039",
    "code_before_change": "ikev2_t_print(netdissect_options *ndo, int tcount,\n\t      const struct isakmp_gen *ext, u_int item_len,\n\t      const u_char *ep)\n{\n\tconst struct ikev2_t *p;\n\tstruct ikev2_t t;\n\tuint16_t  t_id;\n\tconst u_char *cp;\n\tconst char *idstr;\n\tconst struct attrmap *map;\n\tsize_t nmap;\n\tconst u_char *ep2;\n\n\tp = (const struct ikev2_t *)ext;\n\tND_TCHECK(*p);\n\tUNALIGNED_MEMCPY(&t, ext, sizeof(t));\n\tikev2_pay_print(ndo, NPSTR(ISAKMP_NPTYPE_T), t.h.critical);\n\n\tt_id = ntohs(t.t_id);\n\n\tmap = NULL;\n\tnmap = 0;\n\n\tswitch (t.t_type) {\n\tcase IV2_T_ENCR:\n\t\tidstr = STR_OR_ID(t_id, esp_p_map);\n\t\tmap = encr_t_map;\n\t\tnmap = sizeof(encr_t_map)/sizeof(encr_t_map[0]);\n\t\tbreak;\n\n\tcase IV2_T_PRF:\n\t\tidstr = STR_OR_ID(t_id, prf_p_map);\n\t\tbreak;\n\n\tcase IV2_T_INTEG:\n\t\tidstr = STR_OR_ID(t_id, integ_p_map);\n\t\tbreak;\n\n\tcase IV2_T_DH:\n\t\tidstr = STR_OR_ID(t_id, dh_p_map);\n\t\tbreak;\n\n\tcase IV2_T_ESN:\n\t\tidstr = STR_OR_ID(t_id, esn_p_map);\n\t\tbreak;\n\n\tdefault:\n\t\tidstr = NULL;\n\t\tbreak;\n\t}\n\n\tif (idstr)\n\t\tND_PRINT((ndo,\" #%u type=%s id=%s \", tcount,\n\t\t\t  STR_OR_ID(t.t_type, ikev2_t_type_map),\n\t\t\t  idstr));\n\telse\n\t\tND_PRINT((ndo,\" #%u type=%s id=%u \", tcount,\n\t\t\t  STR_OR_ID(t.t_type, ikev2_t_type_map),\n\t\t\t  t.t_id));\n\tcp = (const u_char *)(p + 1);\n \tep2 = (const u_char *)p + item_len;\n \twhile (cp < ep && cp < ep2) {\n \t\tif (map && nmap) {\n\t\t\tcp = ikev1_attrmap_print(ndo, cp, (ep < ep2) ? ep : ep2,\n\t\t\t\tmap, nmap);\n \t\t} else\n\t\t\tcp = ikev1_attr_print(ndo, cp, (ep < ep2) ? ep : ep2);\n \t}\n \tif (ep < ep2)\n \t\tND_PRINT((ndo,\"...\"));\n\treturn cp;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_T)));\n\treturn NULL;\n}\n",
    "code_after_change": "ikev2_t_print(netdissect_options *ndo, int tcount,\n\t      const struct isakmp_gen *ext, u_int item_len,\n\t      const u_char *ep)\n{\n\tconst struct ikev2_t *p;\n\tstruct ikev2_t t;\n\tuint16_t  t_id;\n\tconst u_char *cp;\n\tconst char *idstr;\n\tconst struct attrmap *map;\n\tsize_t nmap;\n\tconst u_char *ep2;\n\n\tp = (const struct ikev2_t *)ext;\n\tND_TCHECK(*p);\n\tUNALIGNED_MEMCPY(&t, ext, sizeof(t));\n\tikev2_pay_print(ndo, NPSTR(ISAKMP_NPTYPE_T), t.h.critical);\n\n\tt_id = ntohs(t.t_id);\n\n\tmap = NULL;\n\tnmap = 0;\n\n\tswitch (t.t_type) {\n\tcase IV2_T_ENCR:\n\t\tidstr = STR_OR_ID(t_id, esp_p_map);\n\t\tmap = encr_t_map;\n\t\tnmap = sizeof(encr_t_map)/sizeof(encr_t_map[0]);\n\t\tbreak;\n\n\tcase IV2_T_PRF:\n\t\tidstr = STR_OR_ID(t_id, prf_p_map);\n\t\tbreak;\n\n\tcase IV2_T_INTEG:\n\t\tidstr = STR_OR_ID(t_id, integ_p_map);\n\t\tbreak;\n\n\tcase IV2_T_DH:\n\t\tidstr = STR_OR_ID(t_id, dh_p_map);\n\t\tbreak;\n\n\tcase IV2_T_ESN:\n\t\tidstr = STR_OR_ID(t_id, esn_p_map);\n\t\tbreak;\n\n\tdefault:\n\t\tidstr = NULL;\n\t\tbreak;\n\t}\n\n\tif (idstr)\n\t\tND_PRINT((ndo,\" #%u type=%s id=%s \", tcount,\n\t\t\t  STR_OR_ID(t.t_type, ikev2_t_type_map),\n\t\t\t  idstr));\n\telse\n\t\tND_PRINT((ndo,\" #%u type=%s id=%u \", tcount,\n\t\t\t  STR_OR_ID(t.t_type, ikev2_t_type_map),\n\t\t\t  t.t_id));\n\tcp = (const u_char *)(p + 1);\n \tep2 = (const u_char *)p + item_len;\n \twhile (cp < ep && cp < ep2) {\n \t\tif (map && nmap) {\n\t\t\tcp = ikev1_attrmap_print(ndo, cp, ep2, map, nmap);\n \t\t} else\n\t\t\tcp = ikev1_attr_print(ndo, cp, ep2);\n\t\tif (cp == NULL)\n\t\t\tgoto trunc;\n \t}\n \tif (ep < ep2)\n \t\tND_PRINT((ndo,\"...\"));\n\treturn cp;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_T)));\n\treturn NULL;\n}\n",
    "cwe": [
      "CWE-125"
    ],
    "id": 958,
    "_valid_cwes": [
      "CWE-125"
    ]
  },
  {
    "cve_id": "CVE-2017-13045",
    "code_before_change": "vqp_print(netdissect_options *ndo, register const u_char *pptr, register u_int len)\n{\n    const struct vqp_common_header_t *vqp_common_header;\n    const struct vqp_obj_tlv_t *vqp_obj_tlv;\n\n     const u_char *tptr;\n     uint16_t vqp_obj_len;\n     uint32_t vqp_obj_type;\n    int tlen;\n     uint8_t nitems;\n \n     tptr=pptr;\n     tlen = len;\n     vqp_common_header = (const struct vqp_common_header_t *)pptr;\n     ND_TCHECK(*vqp_common_header);\n \n     /*\n      * Sanity checking of the header.\n     */\n    if (VQP_EXTRACT_VERSION(vqp_common_header->version) != VQP_VERSION) {\n\tND_PRINT((ndo, \"VQP version %u packet not supported\",\n               VQP_EXTRACT_VERSION(vqp_common_header->version)));\n\treturn;\n    }\n\n    /* in non-verbose mode just lets print the basic Message Type */\n    if (ndo->ndo_vflag < 1) {\n        ND_PRINT((ndo, \"VQPv%u %s Message, error-code %s (%u), length %u\",\n               VQP_EXTRACT_VERSION(vqp_common_header->version),\n               tok2str(vqp_msg_type_values, \"unknown (%u)\",vqp_common_header->msg_type),\n               tok2str(vqp_error_code_values, \"unknown (%u)\",vqp_common_header->error_code),\n\t       vqp_common_header->error_code,\n               len));\n        return;\n    }\n\n    /* ok they seem to want to know everything - lets fully decode it */\n    nitems = vqp_common_header->nitems;\n    ND_PRINT((ndo, \"\\n\\tVQPv%u, %s Message, error-code %s (%u), seq 0x%08x, items %u, length %u\",\n           VQP_EXTRACT_VERSION(vqp_common_header->version),\n\t   tok2str(vqp_msg_type_values, \"unknown (%u)\",vqp_common_header->msg_type),\n\t   tok2str(vqp_error_code_values, \"unknown (%u)\",vqp_common_header->error_code),\n\t   vqp_common_header->error_code,\n           EXTRACT_32BITS(&vqp_common_header->sequence),\n           nitems,\n           len));\n\n    /* skip VQP Common header */\n    tptr+=sizeof(const struct vqp_common_header_t);\n    tlen-=sizeof(const struct vqp_common_header_t);\n\n     while (nitems > 0 && tlen > 0) {\n \n         vqp_obj_tlv = (const struct vqp_obj_tlv_t *)tptr;\n         vqp_obj_type = EXTRACT_32BITS(vqp_obj_tlv->obj_type);\n         vqp_obj_len = EXTRACT_16BITS(vqp_obj_tlv->obj_length);\n         tptr+=sizeof(struct vqp_obj_tlv_t);\n        tlen-=sizeof(struct vqp_obj_tlv_t);\n\n        ND_PRINT((ndo, \"\\n\\t  %s Object (0x%08x), length %u, value: \",\n               tok2str(vqp_obj_values, \"Unknown\", vqp_obj_type),\n               vqp_obj_type, vqp_obj_len));\n\n        /* basic sanity check */\n        if (vqp_obj_type == 0 || vqp_obj_len ==0) {\n            return;\n        }\n \n         /* did we capture enough for fully decoding the object ? */\n         ND_TCHECK2(*tptr, vqp_obj_len);\n \n         switch(vqp_obj_type) {\n \tcase VQP_OBJ_IP_ADDRESS:\n             ND_PRINT((ndo, \"%s (0x%08x)\", ipaddr_string(ndo, tptr), EXTRACT_32BITS(tptr)));\n             break;\n             /* those objects have similar semantics - fall through */\n        case VQP_OBJ_PORT_NAME:\n\tcase VQP_OBJ_VLAN_NAME:\n\tcase VQP_OBJ_VTP_DOMAIN:\n\tcase VQP_OBJ_ETHERNET_PKT:\n            safeputs(ndo, tptr, vqp_obj_len);\n            break;\n             /* those objects have similar semantics - fall through */\n \tcase VQP_OBJ_MAC_ADDRESS:\n \tcase VQP_OBJ_MAC_NULL:\n \t      ND_PRINT((ndo, \"%s\", etheraddr_string(ndo, tptr)));\n               break;\n         default:\n            if (ndo->ndo_vflag <= 1)\n                print_unknown_data(ndo,tptr, \"\\n\\t    \", vqp_obj_len);\n            break;\n        }\n\ttptr += vqp_obj_len;\n\ttlen -= vqp_obj_len;\n\tnitems--;\n    }\n    return;\ntrunc:\n    ND_PRINT((ndo, \"\\n\\t[|VQP]\"));\n}\n",
    "code_after_change": "vqp_print(netdissect_options *ndo, register const u_char *pptr, register u_int len)\n{\n    const struct vqp_common_header_t *vqp_common_header;\n    const struct vqp_obj_tlv_t *vqp_obj_tlv;\n\n     const u_char *tptr;\n     uint16_t vqp_obj_len;\n     uint32_t vqp_obj_type;\n    u_int tlen;\n     uint8_t nitems;\n \n     tptr=pptr;\n     tlen = len;\n     vqp_common_header = (const struct vqp_common_header_t *)pptr;\n     ND_TCHECK(*vqp_common_header);\n    if (sizeof(struct vqp_common_header_t) > tlen)\n        goto trunc;\n \n     /*\n      * Sanity checking of the header.\n     */\n    if (VQP_EXTRACT_VERSION(vqp_common_header->version) != VQP_VERSION) {\n\tND_PRINT((ndo, \"VQP version %u packet not supported\",\n               VQP_EXTRACT_VERSION(vqp_common_header->version)));\n\treturn;\n    }\n\n    /* in non-verbose mode just lets print the basic Message Type */\n    if (ndo->ndo_vflag < 1) {\n        ND_PRINT((ndo, \"VQPv%u %s Message, error-code %s (%u), length %u\",\n               VQP_EXTRACT_VERSION(vqp_common_header->version),\n               tok2str(vqp_msg_type_values, \"unknown (%u)\",vqp_common_header->msg_type),\n               tok2str(vqp_error_code_values, \"unknown (%u)\",vqp_common_header->error_code),\n\t       vqp_common_header->error_code,\n               len));\n        return;\n    }\n\n    /* ok they seem to want to know everything - lets fully decode it */\n    nitems = vqp_common_header->nitems;\n    ND_PRINT((ndo, \"\\n\\tVQPv%u, %s Message, error-code %s (%u), seq 0x%08x, items %u, length %u\",\n           VQP_EXTRACT_VERSION(vqp_common_header->version),\n\t   tok2str(vqp_msg_type_values, \"unknown (%u)\",vqp_common_header->msg_type),\n\t   tok2str(vqp_error_code_values, \"unknown (%u)\",vqp_common_header->error_code),\n\t   vqp_common_header->error_code,\n           EXTRACT_32BITS(&vqp_common_header->sequence),\n           nitems,\n           len));\n\n    /* skip VQP Common header */\n    tptr+=sizeof(const struct vqp_common_header_t);\n    tlen-=sizeof(const struct vqp_common_header_t);\n\n     while (nitems > 0 && tlen > 0) {\n \n         vqp_obj_tlv = (const struct vqp_obj_tlv_t *)tptr;\n        ND_TCHECK(*vqp_obj_tlv);\n        if (sizeof(struct vqp_obj_tlv_t) > tlen)\n            goto trunc;\n         vqp_obj_type = EXTRACT_32BITS(vqp_obj_tlv->obj_type);\n         vqp_obj_len = EXTRACT_16BITS(vqp_obj_tlv->obj_length);\n         tptr+=sizeof(struct vqp_obj_tlv_t);\n        tlen-=sizeof(struct vqp_obj_tlv_t);\n\n        ND_PRINT((ndo, \"\\n\\t  %s Object (0x%08x), length %u, value: \",\n               tok2str(vqp_obj_values, \"Unknown\", vqp_obj_type),\n               vqp_obj_type, vqp_obj_len));\n\n        /* basic sanity check */\n        if (vqp_obj_type == 0 || vqp_obj_len ==0) {\n            return;\n        }\n \n         /* did we capture enough for fully decoding the object ? */\n         ND_TCHECK2(*tptr, vqp_obj_len);\n        if (vqp_obj_len > tlen)\n            goto trunc;\n \n         switch(vqp_obj_type) {\n \tcase VQP_OBJ_IP_ADDRESS:\n            if (vqp_obj_len != 4)\n                goto trunc;\n             ND_PRINT((ndo, \"%s (0x%08x)\", ipaddr_string(ndo, tptr), EXTRACT_32BITS(tptr)));\n             break;\n             /* those objects have similar semantics - fall through */\n        case VQP_OBJ_PORT_NAME:\n\tcase VQP_OBJ_VLAN_NAME:\n\tcase VQP_OBJ_VTP_DOMAIN:\n\tcase VQP_OBJ_ETHERNET_PKT:\n            safeputs(ndo, tptr, vqp_obj_len);\n            break;\n             /* those objects have similar semantics - fall through */\n \tcase VQP_OBJ_MAC_ADDRESS:\n \tcase VQP_OBJ_MAC_NULL:\n            if (vqp_obj_len != ETHER_ADDR_LEN)\n                goto trunc;\n \t      ND_PRINT((ndo, \"%s\", etheraddr_string(ndo, tptr)));\n               break;\n         default:\n            if (ndo->ndo_vflag <= 1)\n                print_unknown_data(ndo,tptr, \"\\n\\t    \", vqp_obj_len);\n            break;\n        }\n\ttptr += vqp_obj_len;\n\ttlen -= vqp_obj_len;\n\tnitems--;\n    }\n    return;\ntrunc:\n    ND_PRINT((ndo, \"\\n\\t[|VQP]\"));\n}\n",
    "cwe": [
      "CWE-125"
    ],
    "id": 971,
    "_valid_cwes": [
      "CWE-125"
    ]
  },
  {
    "cve_id": "CVE-2018-7254",
    "code_before_change": "int ParseCaffHeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)\n{\n    uint32_t chan_chunk = 0, channel_layout = 0, bcount;\n    unsigned char *channel_identities = NULL;\n    unsigned char *channel_reorder = NULL;\n    int64_t total_samples = 0, infilesize;\n    CAFFileHeader caf_file_header;\n    CAFChunkHeader caf_chunk_header;\n    CAFAudioFormat caf_audio_format;\n    int i;\n\n    infilesize = DoGetFileSize (infile);\n    memcpy (&caf_file_header, fourcc, 4);\n\n    if ((!DoReadFile (infile, ((char *) &caf_file_header) + 4, sizeof (CAFFileHeader) - 4, &bcount) ||\n        bcount != sizeof (CAFFileHeader) - 4)) {\n            error_line (\"%s is not a valid .CAF file!\", infilename);\n            return WAVPACK_SOFT_ERROR;\n    }\n    else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n        !WavpackAddWrapper (wpc, &caf_file_header, sizeof (CAFFileHeader))) {\n            error_line (\"%s\", WavpackGetErrorMessage (wpc));\n            return WAVPACK_SOFT_ERROR;\n    }\n\n    WavpackBigEndianToNative (&caf_file_header, CAFFileHeaderFormat);\n\n    if (caf_file_header.mFileVersion != 1) {\n        error_line (\"%s: can't handle version %d .CAF files!\", infilename, caf_file_header.mFileVersion);\n        return WAVPACK_SOFT_ERROR;\n    }\n\n\n    while (1) {\n        if (!DoReadFile (infile, &caf_chunk_header, sizeof (CAFChunkHeader), &bcount) ||\n            bcount != sizeof (CAFChunkHeader)) {\n                error_line (\"%s is not a valid .CAF file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n        }\n        else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n            !WavpackAddWrapper (wpc, &caf_chunk_header, sizeof (CAFChunkHeader))) {\n                error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                return WAVPACK_SOFT_ERROR;\n        }\n\n        WavpackBigEndianToNative (&caf_chunk_header, CAFChunkHeaderFormat);\n\n\n        if (!strncmp (caf_chunk_header.mChunkType, \"desc\", 4)) {\n            int supported = TRUE;\n\n            if (caf_chunk_header.mChunkSize != sizeof (CAFAudioFormat) ||\n                !DoReadFile (infile, &caf_audio_format, (uint32_t) caf_chunk_header.mChunkSize, &bcount) ||\n                bcount != caf_chunk_header.mChunkSize) {\n                    error_line (\"%s is not a valid .CAF file!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n            }\n            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, &caf_audio_format, (uint32_t) caf_chunk_header.mChunkSize)) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            WavpackBigEndianToNative (&caf_audio_format, CAFAudioFormatFormat);\n\n            if (debug_logging_mode) {\n                char formatstr [5];\n\n                memcpy (formatstr, caf_audio_format.mFormatID, 4);\n                formatstr [4] = 0;\n                error_line (\"format = %s, flags = %x, sampling rate = %g\",\n                    formatstr, caf_audio_format.mFormatFlags, caf_audio_format.mSampleRate);\n                error_line (\"packet = %d bytes and %d frames\",\n                    caf_audio_format.mBytesPerPacket, caf_audio_format.mFramesPerPacket);\n                error_line (\"channels per frame = %d, bits per channel = %d\",\n                    caf_audio_format.mChannelsPerFrame, caf_audio_format.mBitsPerChannel);\n            }\n\n            if (strncmp (caf_audio_format.mFormatID, \"lpcm\", 4) || (caf_audio_format.mFormatFlags & ~3))\n                supported = FALSE;\n            else if (caf_audio_format.mSampleRate < 1.0 || caf_audio_format.mSampleRate > 16777215.0 ||\n                caf_audio_format.mSampleRate != floor (caf_audio_format.mSampleRate))\n                    supported = FALSE;\n            else if (!caf_audio_format.mChannelsPerFrame || caf_audio_format.mChannelsPerFrame > 256)\n                supported = FALSE;\n            else if (caf_audio_format.mBitsPerChannel < 1 || caf_audio_format.mBitsPerChannel > 32 ||\n                ((caf_audio_format.mFormatFlags & CAF_FORMAT_FLOAT) && caf_audio_format.mBitsPerChannel != 32))\n                    supported = FALSE;\n            else if (caf_audio_format.mFramesPerPacket != 1 ||\n                caf_audio_format.mBytesPerPacket / caf_audio_format.mChannelsPerFrame < (caf_audio_format.mBitsPerChannel + 7) / 8 ||\n                caf_audio_format.mBytesPerPacket / caf_audio_format.mChannelsPerFrame > 4 ||\n                caf_audio_format.mBytesPerPacket % caf_audio_format.mChannelsPerFrame)\n                    supported = FALSE;\n\n            if (!supported) {\n                error_line (\"%s is an unsupported .CAF format!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            config->bytes_per_sample = caf_audio_format.mBytesPerPacket / caf_audio_format.mChannelsPerFrame;\n            config->float_norm_exp = (caf_audio_format.mFormatFlags & CAF_FORMAT_FLOAT) ? 127 : 0;\n            config->bits_per_sample = caf_audio_format.mBitsPerChannel;\n            config->num_channels = caf_audio_format.mChannelsPerFrame;\n            config->sample_rate = (int) caf_audio_format.mSampleRate;\n\n            if (!(caf_audio_format.mFormatFlags & CAF_FORMAT_LITTLE_ENDIAN) && config->bytes_per_sample > 1)\n                config->qmode |= QMODE_BIG_ENDIAN;\n\n            if (config->bytes_per_sample == 1)\n                config->qmode |= QMODE_SIGNED_BYTES;\n\n            if (debug_logging_mode) {\n                if (config->float_norm_exp == 127)\n                    error_line (\"data format: 32-bit %s-endian floating point\", (config->qmode & QMODE_BIG_ENDIAN) ? \"big\" : \"little\");\n                else\n                    error_line (\"data format: %d-bit %s-endian integers stored in %d byte(s)\",\n                        config->bits_per_sample, (config->qmode & QMODE_BIG_ENDIAN) ? \"big\" : \"little\", config->bytes_per_sample);\n             }\n         }\n         else if (!strncmp (caf_chunk_header.mChunkType, \"chan\", 4)) {\n            CAFChannelLayout *caf_channel_layout = malloc ((size_t) caf_chunk_header.mChunkSize);\n \n            if (caf_chunk_header.mChunkSize < sizeof (CAFChannelLayout) ||\n                !DoReadFile (infile, caf_channel_layout, (uint32_t) caf_chunk_header.mChunkSize, &bcount) ||\n                 bcount != caf_chunk_header.mChunkSize) {\n                     error_line (\"%s is not a valid .CAF file!\", infilename);\n                     free (caf_channel_layout);\n                    return WAVPACK_SOFT_ERROR;\n            }\n            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, caf_channel_layout, (uint32_t) caf_chunk_header.mChunkSize)) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    free (caf_channel_layout);\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            WavpackBigEndianToNative (caf_channel_layout, CAFChannelLayoutFormat);\n            chan_chunk = 1;\n\n            if (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED)) {\n                error_line (\"this CAF file already has channel order information!\");\n                free (caf_channel_layout);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            switch (caf_channel_layout->mChannelLayoutTag) {\n                case kCAFChannelLayoutTag_UseChannelDescriptions:\n                    {\n                        CAFChannelDescription *descriptions = (CAFChannelDescription *) (caf_channel_layout + 1);\n                        int num_descriptions = caf_channel_layout->mNumberChannelDescriptions;\n                        int label, cindex = 0, idents = 0;\n\n                        if (caf_chunk_header.mChunkSize != sizeof (CAFChannelLayout) + sizeof (CAFChannelDescription) * num_descriptions ||\n                            num_descriptions != config->num_channels) {\n                                error_line (\"channel descriptions in 'chan' chunk are the wrong size!\");\n                                free (caf_channel_layout);\n                                return WAVPACK_SOFT_ERROR;\n                        }\n\n                        if (num_descriptions >= 256) {\n                            error_line (\"%d channel descriptions is more than we can handle...ignoring!\");\n                            break;\n                        }\n\n\n                        channel_reorder = malloc (num_descriptions);\n                        memset (channel_reorder, -1, num_descriptions);\n                        channel_identities = malloc (num_descriptions+1);\n\n\n                        for (i = 0; i < num_descriptions; ++i) {\n                            WavpackBigEndianToNative (descriptions + i, CAFChannelDescriptionFormat);\n\n                            if (debug_logging_mode)\n                                error_line (\"chan %d --> %d\", i + 1, descriptions [i].mChannelLabel);\n                        }\n\n\n                        for (label = 1; label <= 18; ++label)\n                            for (i = 0; i < num_descriptions; ++i)\n                                if (descriptions [i].mChannelLabel == label) {\n                                    config->channel_mask |= 1 << (label - 1);\n                                    channel_reorder [i] = cindex++;\n                                    break;\n                                }\n\n\n                        for (i = 0; i < num_descriptions; ++i)\n                            if (channel_reorder [i] == (unsigned char) -1) {\n                                uint32_t clabel = descriptions [i].mChannelLabel;\n\n                                if (clabel == 0 || clabel == 0xffffffff || clabel == 100)\n                                    channel_identities [idents++] = 0xff;\n                                else if ((clabel >= 33 && clabel <= 44) || (clabel >= 200 && clabel <= 207) || (clabel >= 301 && clabel <= 305))\n                                    channel_identities [idents++] = clabel >= 301 ? clabel - 80 : clabel;\n                                else {\n                                    error_line (\"warning: unknown channel descriptions label: %d\", clabel);\n                                    channel_identities [idents++] = 0xff;\n                                }\n\n                                channel_reorder [i] = cindex++;\n                            }\n\n\n                        for (i = 0; i < num_descriptions; ++i)\n                            if (channel_reorder [i] != i)\n                                break;\n\n                        if (i == num_descriptions) {\n                            free (channel_reorder);                 // no reordering required, so don't\n                            channel_reorder = NULL;\n                        }\n                        else {\n                            config->qmode |= QMODE_REORDERED_CHANS; // reordering required, put channel count into layout\n                            channel_layout = num_descriptions;\n                        }\n\n                        if (!idents) {                              // if no non-MS channels, free the identities string\n                            free (channel_identities);\n                            channel_identities = NULL;\n                        }\n                        else\n                            channel_identities [idents] = 0;        // otherwise NULL terminate it\n\n                        if (debug_logging_mode) {\n                            error_line (\"layout_tag = 0x%08x, so generated bitmap of 0x%08x from %d descriptions, %d non-MS\",\n                                caf_channel_layout->mChannelLayoutTag, config->channel_mask,\n                                caf_channel_layout->mNumberChannelDescriptions, idents);\n\n\n                            if (channel_reorder && num_descriptions <= 8) {\n                                char reorder_string [] = \"12345678\";\n\n                                for (i = 0; i < num_descriptions; ++i)\n                                    reorder_string [i] = channel_reorder [i] + '1';\n\n                                reorder_string [i] = 0;\n                                error_line (\"reordering string = \\\"%s\\\"\\n\", reorder_string);\n                            }\n                        }\n                    }\n\n                    break;\n\n                case kCAFChannelLayoutTag_UseChannelBitmap:\n                    config->channel_mask = caf_channel_layout->mChannelBitmap;\n\n                    if (debug_logging_mode)\n                        error_line (\"layout_tag = 0x%08x, so using supplied bitmap of 0x%08x\",\n                            caf_channel_layout->mChannelLayoutTag, caf_channel_layout->mChannelBitmap);\n\n                    break;\n\n                default:\n                    for (i = 0; i < NUM_LAYOUTS; ++i)\n                        if (caf_channel_layout->mChannelLayoutTag == layouts [i].mChannelLayoutTag) {\n                            config->channel_mask = layouts [i].mChannelBitmap;\n                            channel_layout = layouts [i].mChannelLayoutTag;\n\n                            if (layouts [i].mChannelReorder) {\n                                channel_reorder = (unsigned char *) strdup (layouts [i].mChannelReorder);\n                                config->qmode |= QMODE_REORDERED_CHANS;\n                            }\n\n                            if (layouts [i].mChannelIdentities)\n                                channel_identities = (unsigned char *) strdup (layouts [i].mChannelIdentities);\n\n                            if (debug_logging_mode)\n                                error_line (\"layout_tag 0x%08x found in table, bitmap = 0x%08x, reorder = %s, identities = %s\",\n                                    channel_layout, config->channel_mask, channel_reorder ? \"yes\" : \"no\", channel_identities ? \"yes\" : \"no\");\n\n                            break;\n                        }\n\n                    if (i == NUM_LAYOUTS && debug_logging_mode)\n                        error_line (\"layout_tag 0x%08x not found in table...all channels unassigned\",\n                            caf_channel_layout->mChannelLayoutTag);\n\n                    break;\n            }\n\n            free (caf_channel_layout);\n        }\n        else if (!strncmp (caf_chunk_header.mChunkType, \"data\", 4)) {     // on the data chunk, get size and exit loop\n            uint32_t mEditCount;\n\n            if (!DoReadFile (infile, &mEditCount, sizeof (mEditCount), &bcount) ||\n                bcount != sizeof (mEditCount)) {\n                    error_line (\"%s is not a valid .CAF file!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n            }\n            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, &mEditCount, sizeof (mEditCount))) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            if ((config->qmode & QMODE_IGNORE_LENGTH) || caf_chunk_header.mChunkSize == -1) {\n                config->qmode |= QMODE_IGNORE_LENGTH;\n\n                if (infilesize && DoGetFilePosition (infile) != -1)\n                    total_samples = (infilesize - DoGetFilePosition (infile)) / caf_audio_format.mBytesPerPacket;\n                else\n                    total_samples = -1;\n            }\n            else {\n                if (infilesize && infilesize - caf_chunk_header.mChunkSize > 16777216) {\n                    error_line (\".CAF file %s has over 16 MB of extra CAFF data, probably is corrupt!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n                }\n\n                if ((caf_chunk_header.mChunkSize - 4) % caf_audio_format.mBytesPerPacket) {\n                    error_line (\".CAF file %s has an invalid data chunk size, probably is corrupt!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n                }\n\n                total_samples = (caf_chunk_header.mChunkSize - 4) / caf_audio_format.mBytesPerPacket;\n\n                if (!total_samples) {\n                    error_line (\"this .CAF file has no audio samples, probably is corrupt!\");\n                    return WAVPACK_SOFT_ERROR;\n                }\n\n                if (total_samples > MAX_WAVPACK_SAMPLES) {\n                    error_line (\"%s has too many samples for WavPack!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n                }\n            }\n\n            break;\n         }\n         else {          // just copy unknown chunks to output file\n \n            int bytes_to_copy = (uint32_t) caf_chunk_header.mChunkSize;\n            char *buff = malloc (bytes_to_copy);\n \n             if (debug_logging_mode)\n                 error_line (\"extra unknown chunk \\\"%c%c%c%c\\\" of %d bytes\",\n                    caf_chunk_header.mChunkType [0], caf_chunk_header.mChunkType [1], caf_chunk_header.mChunkType [2],\n                    caf_chunk_header.mChunkType [3], caf_chunk_header.mChunkSize);\n\n            if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||\n                bcount != bytes_to_copy ||\n                (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, buff, bytes_to_copy))) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    free (buff);\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            free (buff);\n        }\n    }\n\n    if (!chan_chunk && !config->channel_mask && config->num_channels <= 2 && !(config->qmode & QMODE_CHANS_UNASSIGNED))\n        config->channel_mask = 0x5 - config->num_channels;\n\n    if (!WavpackSetConfiguration64 (wpc, config, total_samples, channel_identities)) {\n        error_line (\"%s\", WavpackGetErrorMessage (wpc));\n        return WAVPACK_SOFT_ERROR;\n    }\n\n    if (channel_identities)\n        free (channel_identities);\n\n    if (channel_layout || channel_reorder) {\n        if (!WavpackSetChannelLayout (wpc, channel_layout, channel_reorder)) {\n            error_line (\"problem with setting channel layout (should not happen)\");\n            return WAVPACK_SOFT_ERROR;\n        }\n\n        if (channel_reorder)\n            free (channel_reorder);\n    }\n\n    return WAVPACK_NO_ERROR;\n}\n",
    "code_after_change": "int ParseCaffHeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)\n{\n    uint32_t chan_chunk = 0, channel_layout = 0, bcount;\n    unsigned char *channel_identities = NULL;\n    unsigned char *channel_reorder = NULL;\n    int64_t total_samples = 0, infilesize;\n    CAFFileHeader caf_file_header;\n    CAFChunkHeader caf_chunk_header;\n    CAFAudioFormat caf_audio_format;\n    int i;\n\n    infilesize = DoGetFileSize (infile);\n    memcpy (&caf_file_header, fourcc, 4);\n\n    if ((!DoReadFile (infile, ((char *) &caf_file_header) + 4, sizeof (CAFFileHeader) - 4, &bcount) ||\n        bcount != sizeof (CAFFileHeader) - 4)) {\n            error_line (\"%s is not a valid .CAF file!\", infilename);\n            return WAVPACK_SOFT_ERROR;\n    }\n    else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n        !WavpackAddWrapper (wpc, &caf_file_header, sizeof (CAFFileHeader))) {\n            error_line (\"%s\", WavpackGetErrorMessage (wpc));\n            return WAVPACK_SOFT_ERROR;\n    }\n\n    WavpackBigEndianToNative (&caf_file_header, CAFFileHeaderFormat);\n\n    if (caf_file_header.mFileVersion != 1) {\n        error_line (\"%s: can't handle version %d .CAF files!\", infilename, caf_file_header.mFileVersion);\n        return WAVPACK_SOFT_ERROR;\n    }\n\n\n    while (1) {\n        if (!DoReadFile (infile, &caf_chunk_header, sizeof (CAFChunkHeader), &bcount) ||\n            bcount != sizeof (CAFChunkHeader)) {\n                error_line (\"%s is not a valid .CAF file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n        }\n        else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n            !WavpackAddWrapper (wpc, &caf_chunk_header, sizeof (CAFChunkHeader))) {\n                error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                return WAVPACK_SOFT_ERROR;\n        }\n\n        WavpackBigEndianToNative (&caf_chunk_header, CAFChunkHeaderFormat);\n\n\n        if (!strncmp (caf_chunk_header.mChunkType, \"desc\", 4)) {\n            int supported = TRUE;\n\n            if (caf_chunk_header.mChunkSize != sizeof (CAFAudioFormat) ||\n                !DoReadFile (infile, &caf_audio_format, (uint32_t) caf_chunk_header.mChunkSize, &bcount) ||\n                bcount != caf_chunk_header.mChunkSize) {\n                    error_line (\"%s is not a valid .CAF file!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n            }\n            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, &caf_audio_format, (uint32_t) caf_chunk_header.mChunkSize)) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            WavpackBigEndianToNative (&caf_audio_format, CAFAudioFormatFormat);\n\n            if (debug_logging_mode) {\n                char formatstr [5];\n\n                memcpy (formatstr, caf_audio_format.mFormatID, 4);\n                formatstr [4] = 0;\n                error_line (\"format = %s, flags = %x, sampling rate = %g\",\n                    formatstr, caf_audio_format.mFormatFlags, caf_audio_format.mSampleRate);\n                error_line (\"packet = %d bytes and %d frames\",\n                    caf_audio_format.mBytesPerPacket, caf_audio_format.mFramesPerPacket);\n                error_line (\"channels per frame = %d, bits per channel = %d\",\n                    caf_audio_format.mChannelsPerFrame, caf_audio_format.mBitsPerChannel);\n            }\n\n            if (strncmp (caf_audio_format.mFormatID, \"lpcm\", 4) || (caf_audio_format.mFormatFlags & ~3))\n                supported = FALSE;\n            else if (caf_audio_format.mSampleRate < 1.0 || caf_audio_format.mSampleRate > 16777215.0 ||\n                caf_audio_format.mSampleRate != floor (caf_audio_format.mSampleRate))\n                    supported = FALSE;\n            else if (!caf_audio_format.mChannelsPerFrame || caf_audio_format.mChannelsPerFrame > 256)\n                supported = FALSE;\n            else if (caf_audio_format.mBitsPerChannel < 1 || caf_audio_format.mBitsPerChannel > 32 ||\n                ((caf_audio_format.mFormatFlags & CAF_FORMAT_FLOAT) && caf_audio_format.mBitsPerChannel != 32))\n                    supported = FALSE;\n            else if (caf_audio_format.mFramesPerPacket != 1 ||\n                caf_audio_format.mBytesPerPacket / caf_audio_format.mChannelsPerFrame < (caf_audio_format.mBitsPerChannel + 7) / 8 ||\n                caf_audio_format.mBytesPerPacket / caf_audio_format.mChannelsPerFrame > 4 ||\n                caf_audio_format.mBytesPerPacket % caf_audio_format.mChannelsPerFrame)\n                    supported = FALSE;\n\n            if (!supported) {\n                error_line (\"%s is an unsupported .CAF format!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            config->bytes_per_sample = caf_audio_format.mBytesPerPacket / caf_audio_format.mChannelsPerFrame;\n            config->float_norm_exp = (caf_audio_format.mFormatFlags & CAF_FORMAT_FLOAT) ? 127 : 0;\n            config->bits_per_sample = caf_audio_format.mBitsPerChannel;\n            config->num_channels = caf_audio_format.mChannelsPerFrame;\n            config->sample_rate = (int) caf_audio_format.mSampleRate;\n\n            if (!(caf_audio_format.mFormatFlags & CAF_FORMAT_LITTLE_ENDIAN) && config->bytes_per_sample > 1)\n                config->qmode |= QMODE_BIG_ENDIAN;\n\n            if (config->bytes_per_sample == 1)\n                config->qmode |= QMODE_SIGNED_BYTES;\n\n            if (debug_logging_mode) {\n                if (config->float_norm_exp == 127)\n                    error_line (\"data format: 32-bit %s-endian floating point\", (config->qmode & QMODE_BIG_ENDIAN) ? \"big\" : \"little\");\n                else\n                    error_line (\"data format: %d-bit %s-endian integers stored in %d byte(s)\",\n                        config->bits_per_sample, (config->qmode & QMODE_BIG_ENDIAN) ? \"big\" : \"little\", config->bytes_per_sample);\n             }\n         }\n         else if (!strncmp (caf_chunk_header.mChunkType, \"chan\", 4)) {\n            CAFChannelLayout *caf_channel_layout;\n \n            if (caf_chunk_header.mChunkSize < sizeof (CAFChannelLayout) || caf_chunk_header.mChunkSize > 1024) {\n                error_line (\"this .CAF file has an invalid 'chan' chunk!\");\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            if (debug_logging_mode)\n                error_line (\"'chan' chunk is %d bytes\", (int) caf_chunk_header.mChunkSize);\n\n            caf_channel_layout = malloc ((size_t) caf_chunk_header.mChunkSize);\n\n            if (!DoReadFile (infile, caf_channel_layout, (uint32_t) caf_chunk_header.mChunkSize, &bcount) ||\n                 bcount != caf_chunk_header.mChunkSize) {\n                     error_line (\"%s is not a valid .CAF file!\", infilename);\n                     free (caf_channel_layout);\n                    return WAVPACK_SOFT_ERROR;\n            }\n            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, caf_channel_layout, (uint32_t) caf_chunk_header.mChunkSize)) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    free (caf_channel_layout);\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            WavpackBigEndianToNative (caf_channel_layout, CAFChannelLayoutFormat);\n            chan_chunk = 1;\n\n            if (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED)) {\n                error_line (\"this CAF file already has channel order information!\");\n                free (caf_channel_layout);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            switch (caf_channel_layout->mChannelLayoutTag) {\n                case kCAFChannelLayoutTag_UseChannelDescriptions:\n                    {\n                        CAFChannelDescription *descriptions = (CAFChannelDescription *) (caf_channel_layout + 1);\n                        int num_descriptions = caf_channel_layout->mNumberChannelDescriptions;\n                        int label, cindex = 0, idents = 0;\n\n                        if (caf_chunk_header.mChunkSize != sizeof (CAFChannelLayout) + sizeof (CAFChannelDescription) * num_descriptions ||\n                            num_descriptions != config->num_channels) {\n                                error_line (\"channel descriptions in 'chan' chunk are the wrong size!\");\n                                free (caf_channel_layout);\n                                return WAVPACK_SOFT_ERROR;\n                        }\n\n                        if (num_descriptions >= 256) {\n                            error_line (\"%d channel descriptions is more than we can handle...ignoring!\");\n                            break;\n                        }\n\n\n                        channel_reorder = malloc (num_descriptions);\n                        memset (channel_reorder, -1, num_descriptions);\n                        channel_identities = malloc (num_descriptions+1);\n\n\n                        for (i = 0; i < num_descriptions; ++i) {\n                            WavpackBigEndianToNative (descriptions + i, CAFChannelDescriptionFormat);\n\n                            if (debug_logging_mode)\n                                error_line (\"chan %d --> %d\", i + 1, descriptions [i].mChannelLabel);\n                        }\n\n\n                        for (label = 1; label <= 18; ++label)\n                            for (i = 0; i < num_descriptions; ++i)\n                                if (descriptions [i].mChannelLabel == label) {\n                                    config->channel_mask |= 1 << (label - 1);\n                                    channel_reorder [i] = cindex++;\n                                    break;\n                                }\n\n\n                        for (i = 0; i < num_descriptions; ++i)\n                            if (channel_reorder [i] == (unsigned char) -1) {\n                                uint32_t clabel = descriptions [i].mChannelLabel;\n\n                                if (clabel == 0 || clabel == 0xffffffff || clabel == 100)\n                                    channel_identities [idents++] = 0xff;\n                                else if ((clabel >= 33 && clabel <= 44) || (clabel >= 200 && clabel <= 207) || (clabel >= 301 && clabel <= 305))\n                                    channel_identities [idents++] = clabel >= 301 ? clabel - 80 : clabel;\n                                else {\n                                    error_line (\"warning: unknown channel descriptions label: %d\", clabel);\n                                    channel_identities [idents++] = 0xff;\n                                }\n\n                                channel_reorder [i] = cindex++;\n                            }\n\n\n                        for (i = 0; i < num_descriptions; ++i)\n                            if (channel_reorder [i] != i)\n                                break;\n\n                        if (i == num_descriptions) {\n                            free (channel_reorder);                 // no reordering required, so don't\n                            channel_reorder = NULL;\n                        }\n                        else {\n                            config->qmode |= QMODE_REORDERED_CHANS; // reordering required, put channel count into layout\n                            channel_layout = num_descriptions;\n                        }\n\n                        if (!idents) {                              // if no non-MS channels, free the identities string\n                            free (channel_identities);\n                            channel_identities = NULL;\n                        }\n                        else\n                            channel_identities [idents] = 0;        // otherwise NULL terminate it\n\n                        if (debug_logging_mode) {\n                            error_line (\"layout_tag = 0x%08x, so generated bitmap of 0x%08x from %d descriptions, %d non-MS\",\n                                caf_channel_layout->mChannelLayoutTag, config->channel_mask,\n                                caf_channel_layout->mNumberChannelDescriptions, idents);\n\n\n                            if (channel_reorder && num_descriptions <= 8) {\n                                char reorder_string [] = \"12345678\";\n\n                                for (i = 0; i < num_descriptions; ++i)\n                                    reorder_string [i] = channel_reorder [i] + '1';\n\n                                reorder_string [i] = 0;\n                                error_line (\"reordering string = \\\"%s\\\"\\n\", reorder_string);\n                            }\n                        }\n                    }\n\n                    break;\n\n                case kCAFChannelLayoutTag_UseChannelBitmap:\n                    config->channel_mask = caf_channel_layout->mChannelBitmap;\n\n                    if (debug_logging_mode)\n                        error_line (\"layout_tag = 0x%08x, so using supplied bitmap of 0x%08x\",\n                            caf_channel_layout->mChannelLayoutTag, caf_channel_layout->mChannelBitmap);\n\n                    break;\n\n                default:\n                    for (i = 0; i < NUM_LAYOUTS; ++i)\n                        if (caf_channel_layout->mChannelLayoutTag == layouts [i].mChannelLayoutTag) {\n                            config->channel_mask = layouts [i].mChannelBitmap;\n                            channel_layout = layouts [i].mChannelLayoutTag;\n\n                            if (layouts [i].mChannelReorder) {\n                                channel_reorder = (unsigned char *) strdup (layouts [i].mChannelReorder);\n                                config->qmode |= QMODE_REORDERED_CHANS;\n                            }\n\n                            if (layouts [i].mChannelIdentities)\n                                channel_identities = (unsigned char *) strdup (layouts [i].mChannelIdentities);\n\n                            if (debug_logging_mode)\n                                error_line (\"layout_tag 0x%08x found in table, bitmap = 0x%08x, reorder = %s, identities = %s\",\n                                    channel_layout, config->channel_mask, channel_reorder ? \"yes\" : \"no\", channel_identities ? \"yes\" : \"no\");\n\n                            break;\n                        }\n\n                    if (i == NUM_LAYOUTS && debug_logging_mode)\n                        error_line (\"layout_tag 0x%08x not found in table...all channels unassigned\",\n                            caf_channel_layout->mChannelLayoutTag);\n\n                    break;\n            }\n\n            free (caf_channel_layout);\n        }\n        else if (!strncmp (caf_chunk_header.mChunkType, \"data\", 4)) {     // on the data chunk, get size and exit loop\n            uint32_t mEditCount;\n\n            if (!DoReadFile (infile, &mEditCount, sizeof (mEditCount), &bcount) ||\n                bcount != sizeof (mEditCount)) {\n                    error_line (\"%s is not a valid .CAF file!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n            }\n            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, &mEditCount, sizeof (mEditCount))) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            if ((config->qmode & QMODE_IGNORE_LENGTH) || caf_chunk_header.mChunkSize == -1) {\n                config->qmode |= QMODE_IGNORE_LENGTH;\n\n                if (infilesize && DoGetFilePosition (infile) != -1)\n                    total_samples = (infilesize - DoGetFilePosition (infile)) / caf_audio_format.mBytesPerPacket;\n                else\n                    total_samples = -1;\n            }\n            else {\n                if (infilesize && infilesize - caf_chunk_header.mChunkSize > 16777216) {\n                    error_line (\".CAF file %s has over 16 MB of extra CAFF data, probably is corrupt!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n                }\n\n                if ((caf_chunk_header.mChunkSize - 4) % caf_audio_format.mBytesPerPacket) {\n                    error_line (\".CAF file %s has an invalid data chunk size, probably is corrupt!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n                }\n\n                total_samples = (caf_chunk_header.mChunkSize - 4) / caf_audio_format.mBytesPerPacket;\n\n                if (!total_samples) {\n                    error_line (\"this .CAF file has no audio samples, probably is corrupt!\");\n                    return WAVPACK_SOFT_ERROR;\n                }\n\n                if (total_samples > MAX_WAVPACK_SAMPLES) {\n                    error_line (\"%s has too many samples for WavPack!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n                }\n            }\n\n            break;\n         }\n         else {          // just copy unknown chunks to output file\n \n            uint32_t bytes_to_copy = (uint32_t) caf_chunk_header.mChunkSize;\n            char *buff;\n\n            if (caf_chunk_header.mChunkSize < 0 || caf_chunk_header.mChunkSize > 1048576) {\n                error_line (\"%s is not a valid .CAF file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            buff = malloc (bytes_to_copy);\n \n             if (debug_logging_mode)\n                 error_line (\"extra unknown chunk \\\"%c%c%c%c\\\" of %d bytes\",\n                    caf_chunk_header.mChunkType [0], caf_chunk_header.mChunkType [1], caf_chunk_header.mChunkType [2],\n                    caf_chunk_header.mChunkType [3], caf_chunk_header.mChunkSize);\n\n            if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||\n                bcount != bytes_to_copy ||\n                (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, buff, bytes_to_copy))) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    free (buff);\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            free (buff);\n        }\n    }\n\n    if (!chan_chunk && !config->channel_mask && config->num_channels <= 2 && !(config->qmode & QMODE_CHANS_UNASSIGNED))\n        config->channel_mask = 0x5 - config->num_channels;\n\n    if (!WavpackSetConfiguration64 (wpc, config, total_samples, channel_identities)) {\n        error_line (\"%s\", WavpackGetErrorMessage (wpc));\n        return WAVPACK_SOFT_ERROR;\n    }\n\n    if (channel_identities)\n        free (channel_identities);\n\n    if (channel_layout || channel_reorder) {\n        if (!WavpackSetChannelLayout (wpc, channel_layout, channel_reorder)) {\n            error_line (\"problem with setting channel layout (should not happen)\");\n            return WAVPACK_SOFT_ERROR;\n        }\n\n        if (channel_reorder)\n            free (channel_reorder);\n    }\n\n    return WAVPACK_NO_ERROR;\n}\n",
    "cwe": [
      "CWE-125"
    ],
    "id": 980,
    "_valid_cwes": [
      "CWE-125"
    ]
  },
  {
    "cve_id": "CVE-2016-7514",
    "code_before_change": "static Image *ReadPSDImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    has_merged_image,\n    skip_layers;\n\n  MagickOffsetType\n    offset;\n\n  MagickSizeType\n    length;\n\n  MagickBooleanType\n    status;\n\n  PSDInfo\n    psd_info;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count;\n\n  unsigned char\n    *data;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read image header.\n  */\n  image->endian=MSBEndian;\n  count=ReadBlob(image,4,(unsigned char *) psd_info.signature);\n  psd_info.version=ReadBlobMSBShort(image);\n  if ((count == 0) || (LocaleNCompare(psd_info.signature,\"8BPS\",4) != 0) ||\n      ((psd_info.version != 1) && (psd_info.version != 2)))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  (void) ReadBlob(image,6,psd_info.reserved);\n  psd_info.channels=ReadBlobMSBShort(image);\n  if (psd_info.channels > MaxPSDChannels)\n    ThrowReaderException(CorruptImageError,\"MaximumChannelsExceeded\");\n  psd_info.rows=ReadBlobMSBLong(image);\n  psd_info.columns=ReadBlobMSBLong(image);\n  if ((psd_info.version == 1) && ((psd_info.rows > 30000) ||\n      (psd_info.columns > 30000)))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  psd_info.depth=ReadBlobMSBShort(image);\n  if ((psd_info.depth != 1) && (psd_info.depth != 8) && (psd_info.depth != 16))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  psd_info.mode=ReadBlobMSBShort(image);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Image is %.20g x %.20g with channels=%.20g, depth=%.20g, mode=%s\",\n      (double) psd_info.columns,(double) psd_info.rows,(double)\n      psd_info.channels,(double) psd_info.depth,ModeToString((PSDImageType)\n      psd_info.mode));\n  /*\n    Initialize image.\n  */\n  image->depth=psd_info.depth;\n  image->columns=psd_info.columns;\n  image->rows=psd_info.rows;\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  if (SetImageBackgroundColor(image,exception) == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (psd_info.mode == LabMode)\n    SetImageColorspace(image,LabColorspace,exception);\n  if (psd_info.mode == CMYKMode)\n    {\n      SetImageColorspace(image,CMYKColorspace,exception);\n      image->alpha_trait=psd_info.channels > 4 ? BlendPixelTrait :\n        UndefinedPixelTrait;\n    }\n  else if ((psd_info.mode == BitmapMode) || (psd_info.mode == GrayscaleMode) ||\n      (psd_info.mode == DuotoneMode))\n    {\n      status=AcquireImageColormap(image,psd_info.depth != 16 ? 256 : 65536,\n        exception);\n      if (status == MagickFalse)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Image colormap allocated\");\n      SetImageColorspace(image,GRAYColorspace,exception);\n      image->alpha_trait=psd_info.channels > 1 ? BlendPixelTrait :\n        UndefinedPixelTrait;\n    }\n  else\n    image->alpha_trait=psd_info.channels > 3 ? BlendPixelTrait :\n      UndefinedPixelTrait;\n  /*\n    Read PSD raster colormap only present for indexed and duotone images.\n  */\n  length=ReadBlobMSBLong(image);\n  if (length != 0)\n    {\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  reading colormap\");\n      if (psd_info.mode == DuotoneMode)\n        {\n          /*\n            Duotone image data;  the format of this data is undocumented.\n          */\n          data=(unsigned char *) AcquireQuantumMemory((size_t) length,\n            sizeof(*data));\n          if (data == (unsigned char *) NULL)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          (void) ReadBlob(image,(size_t) length,data);\n          data=(unsigned char *) RelinquishMagickMemory(data);\n        }\n      else\n        {\n          size_t\n            number_colors;\n\n          /*\n            Read PSD raster colormap.\n          */\n          number_colors=length/3;\n          if (number_colors > 65536)\n            ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n          if (AcquireImageColormap(image,number_colors,exception) == MagickFalse)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          for (i=0; i < (ssize_t) image->colors; i++)\n            image->colormap[i].red=ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n          for (i=0; i < (ssize_t) image->colors; i++)\n            image->colormap[i].green=ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n          for (i=0; i < (ssize_t) image->colors; i++)\n            image->colormap[i].blue=ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n           image->alpha_trait=UndefinedPixelTrait;\n         }\n     }\n   has_merged_image=MagickTrue;\n   length=ReadBlobMSBLong(image);\n   if (length != 0)\n    {\n      unsigned char\n        *blocks;\n\n      /*\n        Image resources block.\n      */\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  reading image resource blocks - %.20g bytes\",(double)\n          ((MagickOffsetType) length));\n      blocks=(unsigned char *) AcquireQuantumMemory((size_t) length,\n        sizeof(*blocks));\n      if (blocks == (unsigned char *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      count=ReadBlob(image,(size_t) length,blocks);\n      if ((count != (ssize_t) length) ||\n          (LocaleNCompare((char *) blocks,\"8BIM\",4) != 0))\n        {\n          blocks=(unsigned char *) RelinquishMagickMemory(blocks);\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        }\n      ParseImageResourceBlocks(image,blocks,(size_t) length,&has_merged_image,\n        exception);\n      blocks=(unsigned char *) RelinquishMagickMemory(blocks);\n    }\n  /*\n    Layer and mask block.\n  */\n  length=GetPSDSize(&psd_info,image);\n  if (length == 8)\n    {\n      length=ReadBlobMSBLong(image);\n      length=ReadBlobMSBLong(image);\n    }\n  offset=TellBlob(image);\n  skip_layers=MagickFalse;\n  if ((image_info->number_scenes == 1) && (image_info->scene == 0) &&\n      (has_merged_image != MagickFalse))\n    {\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  read composite only\");\n      skip_layers=MagickTrue;\n    }\n  if (length == 0)\n    {\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  image has no layers\");\n    }\n  else\n    {\n      if (ReadPSDLayers(image,image_info,&psd_info,skip_layers,exception) !=\n          MagickTrue)\n        {\n          (void) CloseBlob(image);\n          image=DestroyImageList(image);\n          return((Image *) NULL);\n        }\n\n      /*\n         Skip the rest of the layer and mask information.\n      */\n      SeekBlob(image,offset+length,SEEK_SET);\n    }\n  /*\n    If we are only \"pinging\" the image, then we're done - so return.\n  */\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  /*\n    Read the precombined layer, present for PSD < 4 compatibility.\n  */\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  reading the precombined layer\");\n  if ((has_merged_image != MagickFalse) || (GetImageListLength(image) == 1))\n    has_merged_image=(MagickBooleanType) ReadPSDMergedImage(image_info,image,\n      &psd_info,exception);\n  if ((has_merged_image == MagickFalse) && (GetImageListLength(image) == 1) &&\n      (length != 0))\n    {\n      SeekBlob(image,offset,SEEK_SET);\n      status=ReadPSDLayers(image,image_info,&psd_info,MagickFalse,exception);\n      if (status != MagickTrue)\n        {\n          (void) CloseBlob(image);\n          image=DestroyImageList(image);\n          return((Image *) NULL);\n        }\n    }\n  if ((has_merged_image == MagickFalse) && (GetImageListLength(image) > 1))\n    {\n      Image\n        *merged;\n\n      SetImageAlphaChannel(image,TransparentAlphaChannel,exception);\n      image->background_color.alpha=TransparentAlpha;\n      image->background_color.alpha_trait=BlendPixelTrait;\n      merged=MergeImageLayers(image,FlattenLayer,exception);\n      ReplaceImageInList(&image,merged);\n    }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n",
    "code_after_change": "static Image *ReadPSDImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    has_merged_image,\n    skip_layers;\n\n  MagickOffsetType\n    offset;\n\n  MagickSizeType\n    length;\n\n  MagickBooleanType\n    status;\n\n  PSDInfo\n    psd_info;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count;\n\n  unsigned char\n    *data;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read image header.\n  */\n  image->endian=MSBEndian;\n  count=ReadBlob(image,4,(unsigned char *) psd_info.signature);\n  psd_info.version=ReadBlobMSBShort(image);\n  if ((count == 0) || (LocaleNCompare(psd_info.signature,\"8BPS\",4) != 0) ||\n      ((psd_info.version != 1) && (psd_info.version != 2)))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  (void) ReadBlob(image,6,psd_info.reserved);\n  psd_info.channels=ReadBlobMSBShort(image);\n  if (psd_info.channels > MaxPSDChannels)\n    ThrowReaderException(CorruptImageError,\"MaximumChannelsExceeded\");\n  psd_info.rows=ReadBlobMSBLong(image);\n  psd_info.columns=ReadBlobMSBLong(image);\n  if ((psd_info.version == 1) && ((psd_info.rows > 30000) ||\n      (psd_info.columns > 30000)))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  psd_info.depth=ReadBlobMSBShort(image);\n  if ((psd_info.depth != 1) && (psd_info.depth != 8) && (psd_info.depth != 16))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  psd_info.mode=ReadBlobMSBShort(image);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Image is %.20g x %.20g with channels=%.20g, depth=%.20g, mode=%s\",\n      (double) psd_info.columns,(double) psd_info.rows,(double)\n      psd_info.channels,(double) psd_info.depth,ModeToString((PSDImageType)\n      psd_info.mode));\n  /*\n    Initialize image.\n  */\n  image->depth=psd_info.depth;\n  image->columns=psd_info.columns;\n  image->rows=psd_info.rows;\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  if (SetImageBackgroundColor(image,exception) == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (psd_info.mode == LabMode)\n    SetImageColorspace(image,LabColorspace,exception);\n  if (psd_info.mode == CMYKMode)\n    {\n      SetImageColorspace(image,CMYKColorspace,exception);\n      image->alpha_trait=psd_info.channels > 4 ? BlendPixelTrait :\n        UndefinedPixelTrait;\n    }\n  else if ((psd_info.mode == BitmapMode) || (psd_info.mode == GrayscaleMode) ||\n      (psd_info.mode == DuotoneMode))\n    {\n      status=AcquireImageColormap(image,psd_info.depth != 16 ? 256 : 65536,\n        exception);\n      if (status == MagickFalse)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Image colormap allocated\");\n      SetImageColorspace(image,GRAYColorspace,exception);\n      image->alpha_trait=psd_info.channels > 1 ? BlendPixelTrait :\n        UndefinedPixelTrait;\n    }\n  else\n    image->alpha_trait=psd_info.channels > 3 ? BlendPixelTrait :\n      UndefinedPixelTrait;\n  /*\n    Read PSD raster colormap only present for indexed and duotone images.\n  */\n  length=ReadBlobMSBLong(image);\n  if (length != 0)\n    {\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  reading colormap\");\n      if (psd_info.mode == DuotoneMode)\n        {\n          /*\n            Duotone image data;  the format of this data is undocumented.\n          */\n          data=(unsigned char *) AcquireQuantumMemory((size_t) length,\n            sizeof(*data));\n          if (data == (unsigned char *) NULL)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          (void) ReadBlob(image,(size_t) length,data);\n          data=(unsigned char *) RelinquishMagickMemory(data);\n        }\n      else\n        {\n          size_t\n            number_colors;\n\n          /*\n            Read PSD raster colormap.\n          */\n          number_colors=length/3;\n          if (number_colors > 65536)\n            ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n          if (AcquireImageColormap(image,number_colors,exception) == MagickFalse)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          for (i=0; i < (ssize_t) image->colors; i++)\n            image->colormap[i].red=ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n          for (i=0; i < (ssize_t) image->colors; i++)\n            image->colormap[i].green=ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n          for (i=0; i < (ssize_t) image->colors; i++)\n            image->colormap[i].blue=ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n           image->alpha_trait=UndefinedPixelTrait;\n         }\n     }\n  if ((image->depth == 1) && (image->storage_class != PseudoClass))\n    ThrowReaderException(CorruptImageError, \"ImproperImageHeader\");\n   has_merged_image=MagickTrue;\n   length=ReadBlobMSBLong(image);\n   if (length != 0)\n    {\n      unsigned char\n        *blocks;\n\n      /*\n        Image resources block.\n      */\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  reading image resource blocks - %.20g bytes\",(double)\n          ((MagickOffsetType) length));\n      blocks=(unsigned char *) AcquireQuantumMemory((size_t) length,\n        sizeof(*blocks));\n      if (blocks == (unsigned char *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      count=ReadBlob(image,(size_t) length,blocks);\n      if ((count != (ssize_t) length) ||\n          (LocaleNCompare((char *) blocks,\"8BIM\",4) != 0))\n        {\n          blocks=(unsigned char *) RelinquishMagickMemory(blocks);\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        }\n      ParseImageResourceBlocks(image,blocks,(size_t) length,&has_merged_image,\n        exception);\n      blocks=(unsigned char *) RelinquishMagickMemory(blocks);\n    }\n  /*\n    Layer and mask block.\n  */\n  length=GetPSDSize(&psd_info,image);\n  if (length == 8)\n    {\n      length=ReadBlobMSBLong(image);\n      length=ReadBlobMSBLong(image);\n    }\n  offset=TellBlob(image);\n  skip_layers=MagickFalse;\n  if ((image_info->number_scenes == 1) && (image_info->scene == 0) &&\n      (has_merged_image != MagickFalse))\n    {\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  read composite only\");\n      skip_layers=MagickTrue;\n    }\n  if (length == 0)\n    {\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  image has no layers\");\n    }\n  else\n    {\n      if (ReadPSDLayers(image,image_info,&psd_info,skip_layers,exception) !=\n          MagickTrue)\n        {\n          (void) CloseBlob(image);\n          image=DestroyImageList(image);\n          return((Image *) NULL);\n        }\n\n      /*\n         Skip the rest of the layer and mask information.\n      */\n      SeekBlob(image,offset+length,SEEK_SET);\n    }\n  /*\n    If we are only \"pinging\" the image, then we're done - so return.\n  */\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  /*\n    Read the precombined layer, present for PSD < 4 compatibility.\n  */\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  reading the precombined layer\");\n  if ((has_merged_image != MagickFalse) || (GetImageListLength(image) == 1))\n    has_merged_image=(MagickBooleanType) ReadPSDMergedImage(image_info,image,\n      &psd_info,exception);\n  if ((has_merged_image == MagickFalse) && (GetImageListLength(image) == 1) &&\n      (length != 0))\n    {\n      SeekBlob(image,offset,SEEK_SET);\n      status=ReadPSDLayers(image,image_info,&psd_info,MagickFalse,exception);\n      if (status != MagickTrue)\n        {\n          (void) CloseBlob(image);\n          image=DestroyImageList(image);\n          return((Image *) NULL);\n        }\n    }\n  if ((has_merged_image == MagickFalse) && (GetImageListLength(image) > 1))\n    {\n      Image\n        *merged;\n\n      SetImageAlphaChannel(image,TransparentAlphaChannel,exception);\n      image->background_color.alpha=TransparentAlpha;\n      image->background_color.alpha_trait=BlendPixelTrait;\n      merged=MergeImageLayers(image,FlattenLayer,exception);\n      ReplaceImageInList(&image,merged);\n    }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n",
    "cwe": [
      "CWE-125"
    ],
    "id": 985,
    "_valid_cwes": [
      "CWE-125"
    ]
  },
  {
    "cve_id": "CVE-2017-13012",
    "code_before_change": "icmp_print(netdissect_options *ndo, const u_char *bp, u_int plen, const u_char *bp2,\n           int fragmented)\n{\n\tchar *cp;\n\tconst struct icmp *dp;\n        const struct icmp_ext_t *ext_dp;\n\tconst struct ip *ip;\n\tconst char *str, *fmt;\n\tconst struct ip *oip;\n\tconst struct udphdr *ouh;\n        const uint8_t *obj_tptr;\n        uint32_t raw_label;\n        const u_char *snapend_save;\n\tconst struct icmp_mpls_ext_object_header_t *icmp_mpls_ext_object_header;\n\tu_int hlen, dport, mtu, obj_tlen, obj_class_num, obj_ctype;\n\tchar buf[MAXHOSTNAMELEN + 100];\n\tstruct cksum_vec vec[1];\n\n\tdp = (const struct icmp *)bp;\n        ext_dp = (const struct icmp_ext_t *)bp;\n\tip = (const struct ip *)bp2;\n\tstr = buf;\n\n\tND_TCHECK(dp->icmp_code);\n\tswitch (dp->icmp_type) {\n\n\tcase ICMP_ECHO:\n\tcase ICMP_ECHOREPLY:\n\t\tND_TCHECK(dp->icmp_seq);\n\t\t(void)snprintf(buf, sizeof(buf), \"echo %s, id %u, seq %u\",\n                               dp->icmp_type == ICMP_ECHO ?\n                               \"request\" : \"reply\",\n                               EXTRACT_16BITS(&dp->icmp_id),\n                               EXTRACT_16BITS(&dp->icmp_seq));\n\t\tbreak;\n\n\tcase ICMP_UNREACH:\n\t\tND_TCHECK(dp->icmp_ip.ip_dst);\n\t\tswitch (dp->icmp_code) {\n\n\t\tcase ICMP_UNREACH_PROTOCOL:\n\t\t\tND_TCHECK(dp->icmp_ip.ip_p);\n\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t    \"%s protocol %d unreachable\",\n\t\t\t    ipaddr_string(ndo, &dp->icmp_ip.ip_dst),\n\t\t\t    dp->icmp_ip.ip_p);\n\t\t\tbreak;\n\n\t\tcase ICMP_UNREACH_PORT:\n\t\t\tND_TCHECK(dp->icmp_ip.ip_p);\n\t\t\toip = &dp->icmp_ip;\n\t\t\thlen = IP_HL(oip) * 4;\n\t\t\touh = (const struct udphdr *)(((const u_char *)oip) + hlen);\n\t\t\tND_TCHECK(ouh->uh_dport);\n\t\t\tdport = EXTRACT_16BITS(&ouh->uh_dport);\n\t\t\tswitch (oip->ip_p) {\n\n\t\t\tcase IPPROTO_TCP:\n\t\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t\t\t\"%s tcp port %s unreachable\",\n\t\t\t\t\tipaddr_string(ndo, &oip->ip_dst),\n\t\t\t\t\ttcpport_string(ndo, dport));\n\t\t\t\tbreak;\n\n\t\t\tcase IPPROTO_UDP:\n\t\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t\t\t\"%s udp port %s unreachable\",\n\t\t\t\t\tipaddr_string(ndo, &oip->ip_dst),\n\t\t\t\t\tudpport_string(ndo, dport));\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t\t\t\"%s protocol %d port %d unreachable\",\n\t\t\t\t\tipaddr_string(ndo, &oip->ip_dst),\n\t\t\t\t\toip->ip_p, dport);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase ICMP_UNREACH_NEEDFRAG:\n\t\t    {\n\t\t\tregister const struct mtu_discovery *mp;\n\t\t\tmp = (const struct mtu_discovery *)(const u_char *)&dp->icmp_void;\n\t\t\tmtu = EXTRACT_16BITS(&mp->nexthopmtu);\n\t\t\tif (mtu) {\n\t\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t\t    \"%s unreachable - need to frag (mtu %d)\",\n\t\t\t\t    ipaddr_string(ndo, &dp->icmp_ip.ip_dst), mtu);\n\t\t\t} else {\n\t\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t\t    \"%s unreachable - need to frag\",\n\t\t\t\t    ipaddr_string(ndo, &dp->icmp_ip.ip_dst));\n\t\t\t}\n\t\t    }\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfmt = tok2str(unreach2str, \"#%d %%s unreachable\",\n\t\t\t    dp->icmp_code);\n\t\t\t(void)snprintf(buf, sizeof(buf), fmt,\n\t\t\t    ipaddr_string(ndo, &dp->icmp_ip.ip_dst));\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase ICMP_REDIRECT:\n\t\tND_TCHECK(dp->icmp_ip.ip_dst);\n\t\tfmt = tok2str(type2str, \"redirect-#%d %%s to net %%s\",\n\t\t    dp->icmp_code);\n\t\t(void)snprintf(buf, sizeof(buf), fmt,\n\t\t    ipaddr_string(ndo, &dp->icmp_ip.ip_dst),\n\t\t    ipaddr_string(ndo, &dp->icmp_gwaddr));\n\t\tbreak;\n\n\tcase ICMP_ROUTERADVERT:\n\t    {\n\t\tregister const struct ih_rdiscovery *ihp;\n\t\tregister const struct id_rdiscovery *idp;\n\t\tu_int lifetime, num, size;\n\n\t\t(void)snprintf(buf, sizeof(buf), \"router advertisement\");\n\t\tcp = buf + strlen(buf);\n\n\t\tihp = (const struct ih_rdiscovery *)&dp->icmp_void;\n\t\tND_TCHECK(*ihp);\n\t\t(void)strncpy(cp, \" lifetime \", sizeof(buf) - (cp - buf));\n\t\tcp = buf + strlen(buf);\n\t\tlifetime = EXTRACT_16BITS(&ihp->ird_lifetime);\n\t\tif (lifetime < 60) {\n\t\t\t(void)snprintf(cp, sizeof(buf) - (cp - buf), \"%u\",\n\t\t\t    lifetime);\n\t\t} else if (lifetime < 60 * 60) {\n\t\t\t(void)snprintf(cp, sizeof(buf) - (cp - buf), \"%u:%02u\",\n\t\t\t    lifetime / 60, lifetime % 60);\n\t\t} else {\n\t\t\t(void)snprintf(cp, sizeof(buf) - (cp - buf),\n\t\t\t    \"%u:%02u:%02u\",\n\t\t\t    lifetime / 3600,\n\t\t\t    (lifetime % 3600) / 60,\n\t\t\t    lifetime % 60);\n\t\t}\n\t\tcp = buf + strlen(buf);\n\n\t\tnum = ihp->ird_addrnum;\n\t\t(void)snprintf(cp, sizeof(buf) - (cp - buf), \" %d:\", num);\n\t\tcp = buf + strlen(buf);\n\n\t\tsize = ihp->ird_addrsiz;\n\t\tif (size != 2) {\n\t\t\t(void)snprintf(cp, sizeof(buf) - (cp - buf),\n\t\t\t    \" [size %d]\", size);\n\t\t\tbreak;\n\t\t}\n\t\tidp = (const struct id_rdiscovery *)&dp->icmp_data;\n\t\twhile (num-- > 0) {\n\t\t\tND_TCHECK(*idp);\n\t\t\t(void)snprintf(cp, sizeof(buf) - (cp - buf), \" {%s %u}\",\n\t\t\t    ipaddr_string(ndo, &idp->ird_addr),\n\t\t\t    EXTRACT_32BITS(&idp->ird_pref));\n\t\t\tcp = buf + strlen(buf);\n\t\t\t++idp;\n\t\t}\n\t    }\n\t\tbreak;\n\n\tcase ICMP_TIMXCEED:\n\t\tND_TCHECK(dp->icmp_ip.ip_dst);\n\t\tswitch (dp->icmp_code) {\n\n\t\tcase ICMP_TIMXCEED_INTRANS:\n\t\t\tstr = \"time exceeded in-transit\";\n\t\t\tbreak;\n\n\t\tcase ICMP_TIMXCEED_REASS:\n\t\t\tstr = \"ip reassembly time exceeded\";\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t(void)snprintf(buf, sizeof(buf), \"time exceeded-#%d\",\n\t\t\t    dp->icmp_code);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase ICMP_PARAMPROB:\n\t\tif (dp->icmp_code)\n\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t    \"parameter problem - code %d\", dp->icmp_code);\n\t\telse {\n\t\t\tND_TCHECK(dp->icmp_pptr);\n\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t    \"parameter problem - octet %d\", dp->icmp_pptr);\n\t\t}\n\t\tbreak;\n\n\tcase ICMP_MASKREPLY:\n\t\tND_TCHECK(dp->icmp_mask);\n\t\t(void)snprintf(buf, sizeof(buf), \"address mask is 0x%08x\",\n\t\t    EXTRACT_32BITS(&dp->icmp_mask));\n\t\tbreak;\n\n\tcase ICMP_TSTAMP:\n\t\tND_TCHECK(dp->icmp_seq);\n\t\t(void)snprintf(buf, sizeof(buf),\n\t\t    \"time stamp query id %u seq %u\",\n\t\t    EXTRACT_16BITS(&dp->icmp_id),\n\t\t    EXTRACT_16BITS(&dp->icmp_seq));\n\t\tbreak;\n\n\tcase ICMP_TSTAMPREPLY:\n\t\tND_TCHECK(dp->icmp_ttime);\n\t\t(void)snprintf(buf, sizeof(buf),\n\t\t    \"time stamp reply id %u seq %u: org %s\",\n                               EXTRACT_16BITS(&dp->icmp_id),\n                               EXTRACT_16BITS(&dp->icmp_seq),\n                               icmp_tstamp_print(EXTRACT_32BITS(&dp->icmp_otime)));\n\n                (void)snprintf(buf+strlen(buf),sizeof(buf)-strlen(buf),\", recv %s\",\n                         icmp_tstamp_print(EXTRACT_32BITS(&dp->icmp_rtime)));\n                (void)snprintf(buf+strlen(buf),sizeof(buf)-strlen(buf),\", xmit %s\",\n                         icmp_tstamp_print(EXTRACT_32BITS(&dp->icmp_ttime)));\n                break;\n\n\tdefault:\n\t\tstr = tok2str(icmp2str, \"type-#%d\", dp->icmp_type);\n\t\tbreak;\n\t}\n\tND_PRINT((ndo, \"ICMP %s, length %u\", str, plen));\n\tif (ndo->ndo_vflag && !fragmented) { /* don't attempt checksumming if this is a frag */\n\t\tuint16_t sum, icmp_sum;\n\n\t\tif (ND_TTEST2(*bp, plen)) {\n\t\t\tvec[0].ptr = (const uint8_t *)(const void *)dp;\n\t\t\tvec[0].len = plen;\n\t\t\tsum = in_cksum(vec, 1);\n\t\t\tif (sum != 0) {\n\t\t\t\ticmp_sum = EXTRACT_16BITS(&dp->icmp_cksum);\n\t\t\t\tND_PRINT((ndo, \" (wrong icmp cksum %x (->%x)!)\",\n\t\t\t\t\t     icmp_sum,\n\t\t\t\t\t     in_cksum_shouldbe(icmp_sum, sum)));\n\t\t\t}\n\t\t}\n\t}\n\n        /*\n         * print the remnants of the IP packet.\n         * save the snaplength as this may get overidden in the IP printer.\n         */\n\tif (ndo->ndo_vflag >= 1 && ICMP_ERRTYPE(dp->icmp_type)) {\n\t\tbp += 8;\n \t\tND_PRINT((ndo, \"\\n\\t\"));\n \t\tip = (const struct ip *)bp;\n                 snapend_save = ndo->ndo_snapend;\n \t\tip_print(ndo, bp, EXTRACT_16BITS(&ip->ip_len));\n                 ndo->ndo_snapend = snapend_save;\n \t}\n\n        /*\n         * Attempt to decode the MPLS extensions only for some ICMP types.\n         */\n        if (ndo->ndo_vflag >= 1 && plen > ICMP_EXTD_MINLEN && ICMP_MPLS_EXT_TYPE(dp->icmp_type)) {\n\n            ND_TCHECK(*ext_dp);\n\n            /*\n             * Check first if the mpls extension header shows a non-zero length.\n             * If the length field is not set then silently verify the checksum\n             * to check if an extension header is present. This is expedient,\n             * however not all implementations set the length field proper.\n             */\n            if (!ext_dp->icmp_length &&\n                ND_TTEST2(ext_dp->icmp_ext_version_res, plen - ICMP_EXTD_MINLEN)) {\n                vec[0].ptr = (const uint8_t *)(const void *)&ext_dp->icmp_ext_version_res;\n                vec[0].len = plen - ICMP_EXTD_MINLEN;\n                if (in_cksum(vec, 1)) {\n                    return;\n                }\n            }\n\n            ND_PRINT((ndo, \"\\n\\tMPLS extension v%u\",\n                   ICMP_MPLS_EXT_EXTRACT_VERSION(*(ext_dp->icmp_ext_version_res))));\n\n            /*\n             * Sanity checking of the header.\n             */\n            if (ICMP_MPLS_EXT_EXTRACT_VERSION(*(ext_dp->icmp_ext_version_res)) !=\n                ICMP_MPLS_EXT_VERSION) {\n                ND_PRINT((ndo, \" packet not supported\"));\n                return;\n            }\n\n            hlen = plen - ICMP_EXTD_MINLEN;\n            if (ND_TTEST2(ext_dp->icmp_ext_version_res, hlen)) {\n                vec[0].ptr = (const uint8_t *)(const void *)&ext_dp->icmp_ext_version_res;\n                vec[0].len = hlen;\n                ND_PRINT((ndo, \", checksum 0x%04x (%scorrect), length %u\",\n                       EXTRACT_16BITS(ext_dp->icmp_ext_checksum),\n                       in_cksum(vec, 1) ? \"in\" : \"\",\n                       hlen));\n            }\n\n            hlen -= 4; /* subtract common header size */\n            obj_tptr = (const uint8_t *)ext_dp->icmp_ext_data;\n\n            while (hlen > sizeof(struct icmp_mpls_ext_object_header_t)) {\n\n                icmp_mpls_ext_object_header = (const struct icmp_mpls_ext_object_header_t *)obj_tptr;\n                ND_TCHECK(*icmp_mpls_ext_object_header);\n                obj_tlen = EXTRACT_16BITS(icmp_mpls_ext_object_header->length);\n                obj_class_num = icmp_mpls_ext_object_header->class_num;\n                obj_ctype = icmp_mpls_ext_object_header->ctype;\n                obj_tptr += sizeof(struct icmp_mpls_ext_object_header_t);\n\n                ND_PRINT((ndo, \"\\n\\t  %s Object (%u), Class-Type: %u, length %u\",\n                       tok2str(icmp_mpls_ext_obj_values,\"unknown\",obj_class_num),\n                       obj_class_num,\n                       obj_ctype,\n                       obj_tlen));\n\n                hlen-=sizeof(struct icmp_mpls_ext_object_header_t); /* length field includes tlv header */\n\n                /* infinite loop protection */\n                if ((obj_class_num == 0) ||\n                    (obj_tlen < sizeof(struct icmp_mpls_ext_object_header_t))) {\n                    return;\n                }\n                obj_tlen-=sizeof(struct icmp_mpls_ext_object_header_t);\n\n                switch (obj_class_num) {\n                case 1:\n                    switch(obj_ctype) {\n                    case 1:\n                        ND_TCHECK2(*obj_tptr, 4);\n                        raw_label = EXTRACT_32BITS(obj_tptr);\n                        ND_PRINT((ndo, \"\\n\\t    label %u, exp %u\", MPLS_LABEL(raw_label), MPLS_EXP(raw_label)));\n                        if (MPLS_STACK(raw_label))\n                            ND_PRINT((ndo, \", [S]\"));\n                        ND_PRINT((ndo, \", ttl %u\", MPLS_TTL(raw_label)));\n                        break;\n                    default:\n                        print_unknown_data(ndo, obj_tptr, \"\\n\\t    \", obj_tlen);\n                    }\n                    break;\n\n               /*\n                *  FIXME those are the defined objects that lack a decoder\n                *  you are welcome to contribute code ;-)\n                */\n                case 2:\n                default:\n                    print_unknown_data(ndo, obj_tptr, \"\\n\\t    \", obj_tlen);\n                    break;\n                }\n                if (hlen < obj_tlen)\n                    break;\n                hlen -= obj_tlen;\n                obj_tptr += obj_tlen;\n            }\n        }\n\n\treturn;\ntrunc:\n\tND_PRINT((ndo, \"[|icmp]\"));\n}\n",
    "code_after_change": "icmp_print(netdissect_options *ndo, const u_char *bp, u_int plen, const u_char *bp2,\n           int fragmented)\n{\n\tchar *cp;\n\tconst struct icmp *dp;\n        const struct icmp_ext_t *ext_dp;\n\tconst struct ip *ip;\n\tconst char *str, *fmt;\n\tconst struct ip *oip;\n\tconst struct udphdr *ouh;\n        const uint8_t *obj_tptr;\n        uint32_t raw_label;\n        const u_char *snapend_save;\n\tconst struct icmp_mpls_ext_object_header_t *icmp_mpls_ext_object_header;\n\tu_int hlen, dport, mtu, obj_tlen, obj_class_num, obj_ctype;\n\tchar buf[MAXHOSTNAMELEN + 100];\n\tstruct cksum_vec vec[1];\n\n\tdp = (const struct icmp *)bp;\n        ext_dp = (const struct icmp_ext_t *)bp;\n\tip = (const struct ip *)bp2;\n\tstr = buf;\n\n\tND_TCHECK(dp->icmp_code);\n\tswitch (dp->icmp_type) {\n\n\tcase ICMP_ECHO:\n\tcase ICMP_ECHOREPLY:\n\t\tND_TCHECK(dp->icmp_seq);\n\t\t(void)snprintf(buf, sizeof(buf), \"echo %s, id %u, seq %u\",\n                               dp->icmp_type == ICMP_ECHO ?\n                               \"request\" : \"reply\",\n                               EXTRACT_16BITS(&dp->icmp_id),\n                               EXTRACT_16BITS(&dp->icmp_seq));\n\t\tbreak;\n\n\tcase ICMP_UNREACH:\n\t\tND_TCHECK(dp->icmp_ip.ip_dst);\n\t\tswitch (dp->icmp_code) {\n\n\t\tcase ICMP_UNREACH_PROTOCOL:\n\t\t\tND_TCHECK(dp->icmp_ip.ip_p);\n\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t    \"%s protocol %d unreachable\",\n\t\t\t    ipaddr_string(ndo, &dp->icmp_ip.ip_dst),\n\t\t\t    dp->icmp_ip.ip_p);\n\t\t\tbreak;\n\n\t\tcase ICMP_UNREACH_PORT:\n\t\t\tND_TCHECK(dp->icmp_ip.ip_p);\n\t\t\toip = &dp->icmp_ip;\n\t\t\thlen = IP_HL(oip) * 4;\n\t\t\touh = (const struct udphdr *)(((const u_char *)oip) + hlen);\n\t\t\tND_TCHECK(ouh->uh_dport);\n\t\t\tdport = EXTRACT_16BITS(&ouh->uh_dport);\n\t\t\tswitch (oip->ip_p) {\n\n\t\t\tcase IPPROTO_TCP:\n\t\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t\t\t\"%s tcp port %s unreachable\",\n\t\t\t\t\tipaddr_string(ndo, &oip->ip_dst),\n\t\t\t\t\ttcpport_string(ndo, dport));\n\t\t\t\tbreak;\n\n\t\t\tcase IPPROTO_UDP:\n\t\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t\t\t\"%s udp port %s unreachable\",\n\t\t\t\t\tipaddr_string(ndo, &oip->ip_dst),\n\t\t\t\t\tudpport_string(ndo, dport));\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t\t\t\"%s protocol %d port %d unreachable\",\n\t\t\t\t\tipaddr_string(ndo, &oip->ip_dst),\n\t\t\t\t\toip->ip_p, dport);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase ICMP_UNREACH_NEEDFRAG:\n\t\t    {\n\t\t\tregister const struct mtu_discovery *mp;\n\t\t\tmp = (const struct mtu_discovery *)(const u_char *)&dp->icmp_void;\n\t\t\tmtu = EXTRACT_16BITS(&mp->nexthopmtu);\n\t\t\tif (mtu) {\n\t\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t\t    \"%s unreachable - need to frag (mtu %d)\",\n\t\t\t\t    ipaddr_string(ndo, &dp->icmp_ip.ip_dst), mtu);\n\t\t\t} else {\n\t\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t\t    \"%s unreachable - need to frag\",\n\t\t\t\t    ipaddr_string(ndo, &dp->icmp_ip.ip_dst));\n\t\t\t}\n\t\t    }\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfmt = tok2str(unreach2str, \"#%d %%s unreachable\",\n\t\t\t    dp->icmp_code);\n\t\t\t(void)snprintf(buf, sizeof(buf), fmt,\n\t\t\t    ipaddr_string(ndo, &dp->icmp_ip.ip_dst));\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase ICMP_REDIRECT:\n\t\tND_TCHECK(dp->icmp_ip.ip_dst);\n\t\tfmt = tok2str(type2str, \"redirect-#%d %%s to net %%s\",\n\t\t    dp->icmp_code);\n\t\t(void)snprintf(buf, sizeof(buf), fmt,\n\t\t    ipaddr_string(ndo, &dp->icmp_ip.ip_dst),\n\t\t    ipaddr_string(ndo, &dp->icmp_gwaddr));\n\t\tbreak;\n\n\tcase ICMP_ROUTERADVERT:\n\t    {\n\t\tregister const struct ih_rdiscovery *ihp;\n\t\tregister const struct id_rdiscovery *idp;\n\t\tu_int lifetime, num, size;\n\n\t\t(void)snprintf(buf, sizeof(buf), \"router advertisement\");\n\t\tcp = buf + strlen(buf);\n\n\t\tihp = (const struct ih_rdiscovery *)&dp->icmp_void;\n\t\tND_TCHECK(*ihp);\n\t\t(void)strncpy(cp, \" lifetime \", sizeof(buf) - (cp - buf));\n\t\tcp = buf + strlen(buf);\n\t\tlifetime = EXTRACT_16BITS(&ihp->ird_lifetime);\n\t\tif (lifetime < 60) {\n\t\t\t(void)snprintf(cp, sizeof(buf) - (cp - buf), \"%u\",\n\t\t\t    lifetime);\n\t\t} else if (lifetime < 60 * 60) {\n\t\t\t(void)snprintf(cp, sizeof(buf) - (cp - buf), \"%u:%02u\",\n\t\t\t    lifetime / 60, lifetime % 60);\n\t\t} else {\n\t\t\t(void)snprintf(cp, sizeof(buf) - (cp - buf),\n\t\t\t    \"%u:%02u:%02u\",\n\t\t\t    lifetime / 3600,\n\t\t\t    (lifetime % 3600) / 60,\n\t\t\t    lifetime % 60);\n\t\t}\n\t\tcp = buf + strlen(buf);\n\n\t\tnum = ihp->ird_addrnum;\n\t\t(void)snprintf(cp, sizeof(buf) - (cp - buf), \" %d:\", num);\n\t\tcp = buf + strlen(buf);\n\n\t\tsize = ihp->ird_addrsiz;\n\t\tif (size != 2) {\n\t\t\t(void)snprintf(cp, sizeof(buf) - (cp - buf),\n\t\t\t    \" [size %d]\", size);\n\t\t\tbreak;\n\t\t}\n\t\tidp = (const struct id_rdiscovery *)&dp->icmp_data;\n\t\twhile (num-- > 0) {\n\t\t\tND_TCHECK(*idp);\n\t\t\t(void)snprintf(cp, sizeof(buf) - (cp - buf), \" {%s %u}\",\n\t\t\t    ipaddr_string(ndo, &idp->ird_addr),\n\t\t\t    EXTRACT_32BITS(&idp->ird_pref));\n\t\t\tcp = buf + strlen(buf);\n\t\t\t++idp;\n\t\t}\n\t    }\n\t\tbreak;\n\n\tcase ICMP_TIMXCEED:\n\t\tND_TCHECK(dp->icmp_ip.ip_dst);\n\t\tswitch (dp->icmp_code) {\n\n\t\tcase ICMP_TIMXCEED_INTRANS:\n\t\t\tstr = \"time exceeded in-transit\";\n\t\t\tbreak;\n\n\t\tcase ICMP_TIMXCEED_REASS:\n\t\t\tstr = \"ip reassembly time exceeded\";\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t(void)snprintf(buf, sizeof(buf), \"time exceeded-#%d\",\n\t\t\t    dp->icmp_code);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase ICMP_PARAMPROB:\n\t\tif (dp->icmp_code)\n\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t    \"parameter problem - code %d\", dp->icmp_code);\n\t\telse {\n\t\t\tND_TCHECK(dp->icmp_pptr);\n\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t    \"parameter problem - octet %d\", dp->icmp_pptr);\n\t\t}\n\t\tbreak;\n\n\tcase ICMP_MASKREPLY:\n\t\tND_TCHECK(dp->icmp_mask);\n\t\t(void)snprintf(buf, sizeof(buf), \"address mask is 0x%08x\",\n\t\t    EXTRACT_32BITS(&dp->icmp_mask));\n\t\tbreak;\n\n\tcase ICMP_TSTAMP:\n\t\tND_TCHECK(dp->icmp_seq);\n\t\t(void)snprintf(buf, sizeof(buf),\n\t\t    \"time stamp query id %u seq %u\",\n\t\t    EXTRACT_16BITS(&dp->icmp_id),\n\t\t    EXTRACT_16BITS(&dp->icmp_seq));\n\t\tbreak;\n\n\tcase ICMP_TSTAMPREPLY:\n\t\tND_TCHECK(dp->icmp_ttime);\n\t\t(void)snprintf(buf, sizeof(buf),\n\t\t    \"time stamp reply id %u seq %u: org %s\",\n                               EXTRACT_16BITS(&dp->icmp_id),\n                               EXTRACT_16BITS(&dp->icmp_seq),\n                               icmp_tstamp_print(EXTRACT_32BITS(&dp->icmp_otime)));\n\n                (void)snprintf(buf+strlen(buf),sizeof(buf)-strlen(buf),\", recv %s\",\n                         icmp_tstamp_print(EXTRACT_32BITS(&dp->icmp_rtime)));\n                (void)snprintf(buf+strlen(buf),sizeof(buf)-strlen(buf),\", xmit %s\",\n                         icmp_tstamp_print(EXTRACT_32BITS(&dp->icmp_ttime)));\n                break;\n\n\tdefault:\n\t\tstr = tok2str(icmp2str, \"type-#%d\", dp->icmp_type);\n\t\tbreak;\n\t}\n\tND_PRINT((ndo, \"ICMP %s, length %u\", str, plen));\n\tif (ndo->ndo_vflag && !fragmented) { /* don't attempt checksumming if this is a frag */\n\t\tuint16_t sum, icmp_sum;\n\n\t\tif (ND_TTEST2(*bp, plen)) {\n\t\t\tvec[0].ptr = (const uint8_t *)(const void *)dp;\n\t\t\tvec[0].len = plen;\n\t\t\tsum = in_cksum(vec, 1);\n\t\t\tif (sum != 0) {\n\t\t\t\ticmp_sum = EXTRACT_16BITS(&dp->icmp_cksum);\n\t\t\t\tND_PRINT((ndo, \" (wrong icmp cksum %x (->%x)!)\",\n\t\t\t\t\t     icmp_sum,\n\t\t\t\t\t     in_cksum_shouldbe(icmp_sum, sum)));\n\t\t\t}\n\t\t}\n\t}\n\n        /*\n         * print the remnants of the IP packet.\n         * save the snaplength as this may get overidden in the IP printer.\n         */\n\tif (ndo->ndo_vflag >= 1 && ICMP_ERRTYPE(dp->icmp_type)) {\n\t\tbp += 8;\n \t\tND_PRINT((ndo, \"\\n\\t\"));\n \t\tip = (const struct ip *)bp;\n                 snapend_save = ndo->ndo_snapend;\n\t\tND_TCHECK_16BITS(&ip->ip_len);\n \t\tip_print(ndo, bp, EXTRACT_16BITS(&ip->ip_len));\n                 ndo->ndo_snapend = snapend_save;\n \t}\n\n        /*\n         * Attempt to decode the MPLS extensions only for some ICMP types.\n         */\n        if (ndo->ndo_vflag >= 1 && plen > ICMP_EXTD_MINLEN && ICMP_MPLS_EXT_TYPE(dp->icmp_type)) {\n\n            ND_TCHECK(*ext_dp);\n\n            /*\n             * Check first if the mpls extension header shows a non-zero length.\n             * If the length field is not set then silently verify the checksum\n             * to check if an extension header is present. This is expedient,\n             * however not all implementations set the length field proper.\n             */\n            if (!ext_dp->icmp_length &&\n                ND_TTEST2(ext_dp->icmp_ext_version_res, plen - ICMP_EXTD_MINLEN)) {\n                vec[0].ptr = (const uint8_t *)(const void *)&ext_dp->icmp_ext_version_res;\n                vec[0].len = plen - ICMP_EXTD_MINLEN;\n                if (in_cksum(vec, 1)) {\n                    return;\n                }\n            }\n\n            ND_PRINT((ndo, \"\\n\\tMPLS extension v%u\",\n                   ICMP_MPLS_EXT_EXTRACT_VERSION(*(ext_dp->icmp_ext_version_res))));\n\n            /*\n             * Sanity checking of the header.\n             */\n            if (ICMP_MPLS_EXT_EXTRACT_VERSION(*(ext_dp->icmp_ext_version_res)) !=\n                ICMP_MPLS_EXT_VERSION) {\n                ND_PRINT((ndo, \" packet not supported\"));\n                return;\n            }\n\n            hlen = plen - ICMP_EXTD_MINLEN;\n            if (ND_TTEST2(ext_dp->icmp_ext_version_res, hlen)) {\n                vec[0].ptr = (const uint8_t *)(const void *)&ext_dp->icmp_ext_version_res;\n                vec[0].len = hlen;\n                ND_PRINT((ndo, \", checksum 0x%04x (%scorrect), length %u\",\n                       EXTRACT_16BITS(ext_dp->icmp_ext_checksum),\n                       in_cksum(vec, 1) ? \"in\" : \"\",\n                       hlen));\n            }\n\n            hlen -= 4; /* subtract common header size */\n            obj_tptr = (const uint8_t *)ext_dp->icmp_ext_data;\n\n            while (hlen > sizeof(struct icmp_mpls_ext_object_header_t)) {\n\n                icmp_mpls_ext_object_header = (const struct icmp_mpls_ext_object_header_t *)obj_tptr;\n                ND_TCHECK(*icmp_mpls_ext_object_header);\n                obj_tlen = EXTRACT_16BITS(icmp_mpls_ext_object_header->length);\n                obj_class_num = icmp_mpls_ext_object_header->class_num;\n                obj_ctype = icmp_mpls_ext_object_header->ctype;\n                obj_tptr += sizeof(struct icmp_mpls_ext_object_header_t);\n\n                ND_PRINT((ndo, \"\\n\\t  %s Object (%u), Class-Type: %u, length %u\",\n                       tok2str(icmp_mpls_ext_obj_values,\"unknown\",obj_class_num),\n                       obj_class_num,\n                       obj_ctype,\n                       obj_tlen));\n\n                hlen-=sizeof(struct icmp_mpls_ext_object_header_t); /* length field includes tlv header */\n\n                /* infinite loop protection */\n                if ((obj_class_num == 0) ||\n                    (obj_tlen < sizeof(struct icmp_mpls_ext_object_header_t))) {\n                    return;\n                }\n                obj_tlen-=sizeof(struct icmp_mpls_ext_object_header_t);\n\n                switch (obj_class_num) {\n                case 1:\n                    switch(obj_ctype) {\n                    case 1:\n                        ND_TCHECK2(*obj_tptr, 4);\n                        raw_label = EXTRACT_32BITS(obj_tptr);\n                        ND_PRINT((ndo, \"\\n\\t    label %u, exp %u\", MPLS_LABEL(raw_label), MPLS_EXP(raw_label)));\n                        if (MPLS_STACK(raw_label))\n                            ND_PRINT((ndo, \", [S]\"));\n                        ND_PRINT((ndo, \", ttl %u\", MPLS_TTL(raw_label)));\n                        break;\n                    default:\n                        print_unknown_data(ndo, obj_tptr, \"\\n\\t    \", obj_tlen);\n                    }\n                    break;\n\n               /*\n                *  FIXME those are the defined objects that lack a decoder\n                *  you are welcome to contribute code ;-)\n                */\n                case 2:\n                default:\n                    print_unknown_data(ndo, obj_tptr, \"\\n\\t    \", obj_tlen);\n                    break;\n                }\n                if (hlen < obj_tlen)\n                    break;\n                hlen -= obj_tlen;\n                obj_tptr += obj_tlen;\n            }\n        }\n\n\treturn;\ntrunc:\n\tND_PRINT((ndo, \"[|icmp]\"));\n}\n",
    "cwe": [
      "CWE-125"
    ],
    "id": 1022,
    "_valid_cwes": [
      "CWE-125"
    ]
  }
]