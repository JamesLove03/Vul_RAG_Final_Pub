[
  {
    "cve_id": "CVE-2013-1643",
    "code_before_change": "static PHP_GINIT_FUNCTION(libxml)\n{\n        libxml_globals->stream_context = NULL;\n        libxml_globals->error_buffer.c = NULL;\n        libxml_globals->error_list = NULL;\n }\n",
    "code_after_change": "static PHP_GINIT_FUNCTION(libxml)\n{\n        libxml_globals->stream_context = NULL;\n        libxml_globals->error_buffer.c = NULL;\n        libxml_globals->error_list = NULL;\n       libxml_globals->entity_loader_disabled = 0;\n }\n",
    "cwe": [
      "CWE-200"
    ],
    "id": 4,
    "_valid_cwes": [
      "CWE-200"
    ]
  },
  {
    "cve_id": "CVE-2017-5011",
    "code_before_change": "GURL SanitizeFrontendURL(\n    const GURL& url,\n    const std::string& scheme,\n    const std::string& host,\n    const std::string& path,\n    bool allow_query) {\n  std::vector<std::string> query_parts;\n  if (allow_query) {\n    for (net::QueryIterator it(url); !it.IsAtEnd(); it.Advance()) {\n      std::string value = SanitizeFrontendQueryParam(it.GetKey(),\n          it.GetValue());\n      if (!value.empty()) {\n        query_parts.push_back(\n            base::StringPrintf(\"%s=%s\", it.GetKey().c_str(), value.c_str()));\n      }\n    }\n  }\n  std::string query =\n      query_parts.empty() ? \"\" : \"?\" + base::JoinString(query_parts, \"&\");\n  std::string constructed = base::StringPrintf(\"%s://%s%s%s\",\n      scheme.c_str(), host.c_str(), path.c_str(), query.c_str());\n  GURL result = GURL(constructed);\n  if (!result.is_valid())\n    return GURL();\n  return result;\n}\n",
    "code_after_change": "GURL SanitizeFrontendURL(\n",
    "cwe": [
      "CWE-200"
    ],
    "id": 46,
    "_valid_cwes": [
      "CWE-200"
    ]
  },
  {
    "cve_id": "CVE-2017-5107",
    "code_before_change": " void LockScreenMediaControlsView::ButtonPressed(views::Button* sender,\n                                                 const ui::Event& event) {\n  if (sender == close_button_) {\n    Dismiss();\n    return;\n  }\n   if (!base::Contains(enabled_actions_,\n                       media_message_center::GetActionFromButtonTag(*sender)) ||\n       !media_session_id_.has_value()) {\n    return;\n  }\n\n  media_session::PerformMediaSessionAction(\n      media_message_center::GetActionFromButtonTag(*sender),\n      media_controller_remote_);\n}\n",
    "code_after_change": " void LockScreenMediaControlsView::ButtonPressed(views::Button* sender,\n                                                 const ui::Event& event) {\n   if (!base::Contains(enabled_actions_,\n                       media_message_center::GetActionFromButtonTag(*sender)) ||\n       !media_session_id_.has_value()) {\n    return;\n  }\n\n  media_session::PerformMediaSessionAction(\n      media_message_center::GetActionFromButtonTag(*sender),\n      media_controller_remote_);\n}\n",
    "cwe": [
      "CWE-200"
    ],
    "id": 90,
    "_valid_cwes": [
      "CWE-200"
    ]
  },
  {
    "cve_id": "CVE-2019-5837",
    "code_before_change": " void AppCacheDatabase::ReadEntryRecord(\n    const sql::Statement& statement, EntryRecord* record) {\n  record->cache_id = statement.ColumnInt64(0);\n  record->url = GURL(statement.ColumnString(1));\n   record->flags = statement.ColumnInt(2);\n   record->response_id = statement.ColumnInt64(3);\n   record->response_size = statement.ColumnInt64(4);\n }\n",
    "code_after_change": " void AppCacheDatabase::ReadEntryRecord(\n    const sql::Statement& statement, EntryRecord* record) {\n  record->cache_id = statement.ColumnInt64(0);\n  record->url = GURL(statement.ColumnString(1));\n   record->flags = statement.ColumnInt(2);\n   record->response_id = statement.ColumnInt64(3);\n   record->response_size = statement.ColumnInt64(4);\n  record->padding_size = statement.ColumnInt64(5);\n }\n",
    "cwe": [
      "CWE-200"
    ],
    "id": 99,
    "_valid_cwes": [
      "CWE-200"
    ]
  },
  {
    "cve_id": "CVE-2017-0816",
    "code_before_change": "int Reverb_command(effect_handle_t  self,\n uint32_t            cmdCode,\n uint32_t            cmdSize,\n void *pCmdData,\n uint32_t *replySize,\n void *pReplyData){\n    android::ReverbContext * pContext = (android::ReverbContext *) self;\n    LVREV_ControlParams_st    ActiveParams; /* Current control Parameters */\n    LVREV_ReturnStatus_en     LvmStatus=LVREV_SUCCESS; /* Function call status */\n\n\n if (pContext == NULL){\n        ALOGV(\"\\tLVM_ERROR : Reverb_command ERROR pContext == NULL\");\n return -EINVAL;\n }\n\n\n switch (cmdCode){\n case EFFECT_CMD_INIT:\n\n if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)){\n                ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_INIT: ERROR\");\n return -EINVAL;\n }\n *(int *) pReplyData = 0;\n break;\n\n case EFFECT_CMD_SET_CONFIG:\n if (pCmdData == NULL || cmdSize != sizeof(effect_config_t) ||\n                    pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {\n                ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_SET_CONFIG: ERROR\");\n return -EINVAL;\n }\n *(int *) pReplyData = android::Reverb_setConfig(pContext,\n (effect_config_t *) pCmdData);\n break;\n\n case EFFECT_CMD_GET_CONFIG:\n if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(effect_config_t)) {\n                ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_GET_CONFIG: ERROR\");\n return -EINVAL;\n }\n\n            android::Reverb_getConfig(pContext, (effect_config_t *)pReplyData);\n break;\n\n case EFFECT_CMD_RESET:\n Reverb_setConfig(pContext, &pContext->config);\n break;\n\n case EFFECT_CMD_GET_PARAM:{\n effect_param_t *p = (effect_param_t *)pCmdData;\n if (SIZE_MAX - sizeof(effect_param_t) < (size_t)p->psize) {\n                android_errorWriteLog(0x534e4554, \"26347509\");\n return -EINVAL;\n }\n if (pCmdData == NULL || cmdSize < sizeof(effect_param_t) ||\n                    cmdSize < (sizeof(effect_param_t) + p->psize) ||\n                    pReplyData == NULL || replySize == NULL ||\n *replySize < (sizeof(effect_param_t) + p->psize)) {\n                ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_GET_PARAM: ERROR\");\n return -EINVAL;\n }\n\n            memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + p->psize);\n\n            p = (effect_param_t *)pReplyData;\n\n int voffset = ((p->psize - 1) / sizeof(int32_t) + 1) * sizeof(int32_t);\n\n            p->status = android::Reverb_getParameter(pContext,\n (void *)p->data,\n &p->vsize,\n                                                          p->data + voffset);\n\n *replySize = sizeof(effect_param_t) + voffset + p->vsize;\n\n\n } break;\n case EFFECT_CMD_SET_PARAM:{\n\n\n if (pCmdData == NULL || (cmdSize < (sizeof(effect_param_t) + sizeof(int32_t))) ||\n                    pReplyData == NULL ||  replySize == NULL || *replySize != sizeof(int32_t)) {\n                ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_SET_PARAM: ERROR\");\n return -EINVAL;\n }\n\n effect_param_t *p = (effect_param_t *) pCmdData;\n\n if (p->psize != sizeof(int32_t)){\n                ALOGV(\"\\t4LVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_SET_PARAM: ERROR, psize is not sizeof(int32_t)\");\n return -EINVAL;\n }\n\n\n \n             *(int *)pReplyData = android::Reverb_setParameter(pContext,\n                                                              (void *)p->data,\n                                                              p->data + p->psize);\n         } break;\n \n         case EFFECT_CMD_ENABLE:\n\n if (pReplyData == NULL || *replySize != sizeof(int)){\n                ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_ENABLE: ERROR\");\n return -EINVAL;\n }\n if(pContext->bEnabled == LVM_TRUE){\n                 ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_ENABLE: ERROR-Effect is already enabled\");\n return -EINVAL;\n }\n *(int *)pReplyData = 0;\n            pContext->bEnabled = LVM_TRUE;\n /* Get the current settings */\n LvmStatus = LVREV_GetControlParameters(pContext->hInstance, &ActiveParams);\n            LVM_ERROR_CHECK(LvmStatus, \"LVREV_GetControlParameters\", \"EFFECT_CMD_ENABLE\")\n            pContext->SamplesToExitCount =\n (ActiveParams.T60 * pContext->config.inputCfg.samplingRate)/1000;\n            pContext->volumeMode = android::REVERB_VOLUME_FLAT;\n break;\n case EFFECT_CMD_DISABLE:\n\n if (pReplyData == NULL || *replySize != sizeof(int)){\n                ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_DISABLE: ERROR\");\n return -EINVAL;\n }\n if(pContext->bEnabled == LVM_FALSE){\n                 ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_DISABLE: ERROR-Effect is not yet enabled\");\n return -EINVAL;\n }\n *(int *)pReplyData = 0;\n            pContext->bEnabled = LVM_FALSE;\n break;\n\n case EFFECT_CMD_SET_VOLUME:\n if (pCmdData == NULL ||\n                cmdSize != 2 * sizeof(uint32_t)) {\n                ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_SET_VOLUME: ERROR\");\n return -EINVAL;\n }\n\n\n if (pReplyData != NULL) { // we have volume control\n                pContext->leftVolume = (LVM_INT16)((*(uint32_t *)pCmdData + (1 << 11)) >> 12);\n                pContext->rightVolume = (LVM_INT16)((*((uint32_t *)pCmdData + 1) + (1 << 11)) >> 12);\n *(uint32_t *)pReplyData = (1 << 24);\n *((uint32_t *)pReplyData + 1) = (1 << 24);\n if (pContext->volumeMode == android::REVERB_VOLUME_OFF) {\n                    pContext->volumeMode = android::REVERB_VOLUME_FLAT;\n }\n } else { // we don't have volume control\n                pContext->leftVolume = REVERB_UNIT_VOLUME;\n                pContext->rightVolume = REVERB_UNIT_VOLUME;\n                pContext->volumeMode = android::REVERB_VOLUME_OFF;\n }\n            ALOGV(\"EFFECT_CMD_SET_VOLUME left %d, right %d mode %d\",\n                    pContext->leftVolume, pContext->rightVolume,  pContext->volumeMode);\n break;\n\n case EFFECT_CMD_SET_DEVICE:\n case EFFECT_CMD_SET_AUDIO_MODE:\n break;\n\n default:\n            ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"DEFAULT start %d ERROR\",cmdCode);\n return -EINVAL;\n }\n\n return 0;\n} /* end Reverb_command */\n",
    "code_after_change": "int Reverb_command(effect_handle_t  self,\n uint32_t            cmdCode,\n uint32_t            cmdSize,\n void *pCmdData,\n uint32_t *replySize,\n void *pReplyData){\n    android::ReverbContext * pContext = (android::ReverbContext *) self;\n    LVREV_ControlParams_st    ActiveParams; /* Current control Parameters */\n    LVREV_ReturnStatus_en     LvmStatus=LVREV_SUCCESS; /* Function call status */\n\n\n if (pContext == NULL){\n        ALOGV(\"\\tLVM_ERROR : Reverb_command ERROR pContext == NULL\");\n return -EINVAL;\n }\n\n\n switch (cmdCode){\n case EFFECT_CMD_INIT:\n\n if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)){\n                ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_INIT: ERROR\");\n return -EINVAL;\n }\n *(int *) pReplyData = 0;\n break;\n\n case EFFECT_CMD_SET_CONFIG:\n if (pCmdData == NULL || cmdSize != sizeof(effect_config_t) ||\n                    pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {\n                ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_SET_CONFIG: ERROR\");\n return -EINVAL;\n }\n *(int *) pReplyData = android::Reverb_setConfig(pContext,\n (effect_config_t *) pCmdData);\n break;\n\n case EFFECT_CMD_GET_CONFIG:\n if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(effect_config_t)) {\n                ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_GET_CONFIG: ERROR\");\n return -EINVAL;\n }\n\n            android::Reverb_getConfig(pContext, (effect_config_t *)pReplyData);\n break;\n\n case EFFECT_CMD_RESET:\n Reverb_setConfig(pContext, &pContext->config);\n break;\n\n case EFFECT_CMD_GET_PARAM:{\n effect_param_t *p = (effect_param_t *)pCmdData;\n if (SIZE_MAX - sizeof(effect_param_t) < (size_t)p->psize) {\n                android_errorWriteLog(0x534e4554, \"26347509\");\n return -EINVAL;\n }\n if (pCmdData == NULL || cmdSize < sizeof(effect_param_t) ||\n                    cmdSize < (sizeof(effect_param_t) + p->psize) ||\n                    pReplyData == NULL || replySize == NULL ||\n *replySize < (sizeof(effect_param_t) + p->psize)) {\n                ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_GET_PARAM: ERROR\");\n return -EINVAL;\n }\n\n            memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + p->psize);\n\n            p = (effect_param_t *)pReplyData;\n\n int voffset = ((p->psize - 1) / sizeof(int32_t) + 1) * sizeof(int32_t);\n\n            p->status = android::Reverb_getParameter(pContext,\n (void *)p->data,\n &p->vsize,\n                                                          p->data + voffset);\n\n *replySize = sizeof(effect_param_t) + voffset + p->vsize;\n\n\n } break;\n case EFFECT_CMD_SET_PARAM:{\n\n\n if (pCmdData == NULL || (cmdSize < (sizeof(effect_param_t) + sizeof(int32_t))) ||\n                    pReplyData == NULL ||  replySize == NULL || *replySize != sizeof(int32_t)) {\n                ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_SET_PARAM: ERROR\");\n return -EINVAL;\n }\n\n effect_param_t *p = (effect_param_t *) pCmdData;\n\n if (p->psize != sizeof(int32_t)){\n                ALOGV(\"\\t4LVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_SET_PARAM: ERROR, psize is not sizeof(int32_t)\");\n return -EINVAL;\n }\n\n\n \n             *(int *)pReplyData = android::Reverb_setParameter(pContext,\n                                                              (void *)p->data,\n                                                              p->data + p->psize,\n                                                              p->vsize);\n         } break;\n \n         case EFFECT_CMD_ENABLE:\n\n if (pReplyData == NULL || *replySize != sizeof(int)){\n                ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_ENABLE: ERROR\");\n return -EINVAL;\n }\n if(pContext->bEnabled == LVM_TRUE){\n                 ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_ENABLE: ERROR-Effect is already enabled\");\n return -EINVAL;\n }\n *(int *)pReplyData = 0;\n            pContext->bEnabled = LVM_TRUE;\n /* Get the current settings */\n LvmStatus = LVREV_GetControlParameters(pContext->hInstance, &ActiveParams);\n            LVM_ERROR_CHECK(LvmStatus, \"LVREV_GetControlParameters\", \"EFFECT_CMD_ENABLE\")\n            pContext->SamplesToExitCount =\n (ActiveParams.T60 * pContext->config.inputCfg.samplingRate)/1000;\n            pContext->volumeMode = android::REVERB_VOLUME_FLAT;\n break;\n case EFFECT_CMD_DISABLE:\n\n if (pReplyData == NULL || *replySize != sizeof(int)){\n                ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_DISABLE: ERROR\");\n return -EINVAL;\n }\n if(pContext->bEnabled == LVM_FALSE){\n                 ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_DISABLE: ERROR-Effect is not yet enabled\");\n return -EINVAL;\n }\n *(int *)pReplyData = 0;\n            pContext->bEnabled = LVM_FALSE;\n break;\n\n case EFFECT_CMD_SET_VOLUME:\n if (pCmdData == NULL ||\n                cmdSize != 2 * sizeof(uint32_t)) {\n                ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_SET_VOLUME: ERROR\");\n return -EINVAL;\n }\n\n\n if (pReplyData != NULL) { // we have volume control\n                pContext->leftVolume = (LVM_INT16)((*(uint32_t *)pCmdData + (1 << 11)) >> 12);\n                pContext->rightVolume = (LVM_INT16)((*((uint32_t *)pCmdData + 1) + (1 << 11)) >> 12);\n *(uint32_t *)pReplyData = (1 << 24);\n *((uint32_t *)pReplyData + 1) = (1 << 24);\n if (pContext->volumeMode == android::REVERB_VOLUME_OFF) {\n                    pContext->volumeMode = android::REVERB_VOLUME_FLAT;\n }\n } else { // we don't have volume control\n                pContext->leftVolume = REVERB_UNIT_VOLUME;\n                pContext->rightVolume = REVERB_UNIT_VOLUME;\n                pContext->volumeMode = android::REVERB_VOLUME_OFF;\n }\n            ALOGV(\"EFFECT_CMD_SET_VOLUME left %d, right %d mode %d\",\n                    pContext->leftVolume, pContext->rightVolume,  pContext->volumeMode);\n break;\n\n case EFFECT_CMD_SET_DEVICE:\n case EFFECT_CMD_SET_AUDIO_MODE:\n break;\n\n default:\n            ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"DEFAULT start %d ERROR\",cmdCode);\n return -EINVAL;\n }\n\n return 0;\n} /* end Reverb_command */\n",
    "cwe": [
      "CWE-200"
    ],
    "id": 162,
    "_valid_cwes": [
      "CWE-200"
    ]
  },
  {
    "cve_id": "CVE-2015-1285",
    "code_before_change": " void WallpaperManager::OnDefaultWallpaperDecoded(\n     const base::FilePath& path,\n     const wallpaper::WallpaperLayout layout,\n     std::unique_ptr<user_manager::UserImage>* result_out,\n     MovableOnDestroyCallbackHolder on_finish,\n     std::unique_ptr<user_manager::UserImage> user_image) {\n  if (user_image->image().isNull()) {\n    LOG(ERROR) << \"Failed to decode default wallpaper. \";\n    return;\n   }\n \n   *result_out = std::move(user_image);\n  WallpaperInfo info(path.value(), layout, wallpaper::DEFAULT,\n                     base::Time::Now().LocalMidnight());\n  SetWallpaper((*result_out)->image(), info);\n }\n",
    "code_after_change": " void WallpaperManager::OnDefaultWallpaperDecoded(\n     const base::FilePath& path,\n     const wallpaper::WallpaperLayout layout,\n    bool update_wallpaper,\n     std::unique_ptr<user_manager::UserImage>* result_out,\n     MovableOnDestroyCallbackHolder on_finish,\n     std::unique_ptr<user_manager::UserImage> user_image) {\n  if (user_image->image().isNull()) {\n    LOG(ERROR) << \"Failed to decode default wallpaper. \";\n    return;\n   }\n \n   *result_out = std::move(user_image);\n  if (update_wallpaper) {\n    WallpaperInfo info(path.value(), layout, wallpaper::DEFAULT,\n                       base::Time::Now().LocalMidnight());\n    SetWallpaper((*result_out)->image(), info);\n  }\n }\n",
    "cwe": [
      "CWE-200"
    ],
    "id": 177,
    "_valid_cwes": [
      "CWE-200"
    ]
  },
  {
    "cve_id": "CVE-2019-5837",
    "code_before_change": "void AppCache::AddEntry(const GURL& url, const AppCacheEntry& entry) {\n   DCHECK(entries_.find(url) == entries_.end());\n   entries_.insert(EntryMap::value_type(url, entry));\n   cache_size_ += entry.response_size();\n }\n",
    "code_after_change": "void AppCache::AddEntry(const GURL& url, const AppCacheEntry& entry) {\n   DCHECK(entries_.find(url) == entries_.end());\n   entries_.insert(EntryMap::value_type(url, entry));\n   cache_size_ += entry.response_size();\n  padding_size_ += entry.padding_size();\n }\n",
    "cwe": [
      "CWE-200"
    ],
    "id": 201,
    "_valid_cwes": [
      "CWE-200"
    ]
  },
  {
    "cve_id": "CVE-2012-2891",
    "code_before_change": "void PrintingMessageFilter::OnCheckForCancel(const std::string& preview_ui_addr,\n                                              int preview_request_id,\n                                              bool* cancel) {\n  PrintPreviewUI::GetCurrentPrintPreviewStatus(preview_ui_addr,\n                                                preview_request_id,\n                                                cancel);\n }\n",
    "code_after_change": "void PrintingMessageFilter::OnCheckForCancel(const std::string& preview_ui_addr,\nvoid PrintingMessageFilter::OnCheckForCancel(int32 preview_ui_id,\n                                              int preview_request_id,\n                                              bool* cancel) {\n  PrintPreviewUI::GetCurrentPrintPreviewStatus(preview_ui_id,\n                                                preview_request_id,\n                                                cancel);\n }\n",
    "cwe": [
      "CWE-200"
    ],
    "id": 262,
    "_valid_cwes": [
      "CWE-200"
    ]
  },
  {
    "cve_id": "CVE-2018-6066",
    "code_before_change": "void DocumentModuleScriptFetcher::NotifyFinished(Resource* resource) {\n  ClearResource();\n\n  ScriptResource* script_resource = ToScriptResource(resource);\n\n  HeapVector<Member<ConsoleMessage>> error_messages;\n  if (!WasModuleLoadSuccessful(script_resource, &error_messages)) {\n    Finalize(WTF::nullopt, error_messages);\n    return;\n  }\n\n   ModuleScriptCreationParams params(\n       script_resource->GetResponse().Url(), script_resource->SourceText(),\n       script_resource->GetResourceRequest().GetFetchCredentialsMode(),\n      script_resource->CalculateAccessControlStatus());\n   Finalize(params, error_messages);\n }\n",
    "code_after_change": "void DocumentModuleScriptFetcher::NotifyFinished(Resource* resource) {\n  ClearResource();\n\n  ScriptResource* script_resource = ToScriptResource(resource);\n\n  HeapVector<Member<ConsoleMessage>> error_messages;\n  if (!WasModuleLoadSuccessful(script_resource, &error_messages)) {\n    Finalize(WTF::nullopt, error_messages);\n    return;\n  }\n\n   ModuleScriptCreationParams params(\n       script_resource->GetResponse().Url(), script_resource->SourceText(),\n       script_resource->GetResourceRequest().GetFetchCredentialsMode(),\n      script_resource->CalculateAccessControlStatus(\n          fetcher_->Context().GetSecurityOrigin()));\n   Finalize(params, error_messages);\n }\n",
    "cwe": [
      "CWE-200"
    ],
    "id": 266,
    "_valid_cwes": [
      "CWE-200"
    ]
  },
  {
    "cve_id": "CVE-2013-1944",
    "code_before_change": "static bool tailmatch(const char *little, const char *bigone)\n {\n  size_t littlelen = strlen(little);\n  size_t biglen = strlen(bigone);\n \n  if(littlelen > biglen)\n     return FALSE;\n \n  return Curl_raw_equal(little, bigone+biglen-littlelen) ? TRUE : FALSE;\n }\n",
    "code_after_change": "static bool tailmatch(const char *little, const char *bigone)\nstatic bool tailmatch(const char *cooke_domain, const char *hostname)\n {\n  size_t cookie_domain_len = strlen(cooke_domain);\n  size_t hostname_len = strlen(hostname);\n \n  if(hostname_len < cookie_domain_len)\n     return FALSE;\n \n  if(!Curl_raw_equal(cooke_domain, hostname+hostname_len-cookie_domain_len))\n    return FALSE;\n\n  /* A lead char of cookie_domain is not '.'.\n     RFC6265 4.1.2.3. The Domain Attribute says:\n       For example, if the value of the Domain attribute is\n       \"example.com\", the user agent will include the cookie in the Cookie\n       header when making HTTP requests to example.com, www.example.com, and\n       www.corp.example.com.\n   */\n  if(hostname_len == cookie_domain_len)\n    return TRUE;\n  if('.' == *(hostname + hostname_len - cookie_domain_len - 1))\n    return TRUE;\n  return FALSE;\n }\n",
    "cwe": [
      "CWE-200"
    ],
    "id": 282,
    "_valid_cwes": [
      "CWE-200"
    ]
  },
  {
    "cve_id": "CVE-2016-3837",
    "code_before_change": " static byte parseHexByte(const char * &str) {\n     byte b = parseHexChar(str[0]);\n    if (str[1] == ':' || str[1] == '\\0') {\n        str += 2;\n        return b;\n     } else {\n         b = b << 4 | parseHexChar(str[1]);\n        str += 3;\n        return b;\n     }\n }\n",
    "code_after_change": " static byte parseHexByte(const char * &str) {\n    if (str[0] == '\\0') {\n        ALOGE(\"Passed an empty string\");\n        return 0;\n    }\n     byte b = parseHexChar(str[0]);\n    if (str[1] == '\\0' || str[1] == ':') {\n        str ++;\n     } else {\n         b = b << 4 | parseHexChar(str[1]);\n        str += 2;\n     }\n\n    // Skip trailing delimiter if not at the end of the string.\n    if (str[0] != '\\0') {\n        str++;\n    }\n    return b;\n }\n",
    "cwe": [
      "CWE-200"
    ],
    "id": 283,
    "_valid_cwes": [
      "CWE-200"
    ]
  },
  {
    "cve_id": "CVE-2018-6077",
    "code_before_change": "void BaseRenderingContext2D::Reset() {\n  ValidateStateStack();\n  UnwindStateStack();\n  state_stack_.resize(1);\n  state_stack_.front() = CanvasRenderingContext2DState::Create();\n  path_.Clear();\n  if (PaintCanvas* c = ExistingDrawingCanvas()) {\n    DCHECK_EQ(c->getSaveCount(), 2);\n    c->restore();\n    c->save();\n    DCHECK(c->getTotalMatrix().isIdentity());\n#if DCHECK_IS_ON()\n    SkIRect clip_bounds;\n    DCHECK(c->getDeviceClipBounds(&clip_bounds));\n    DCHECK(clip_bounds == c->imageInfo().bounds());\n #endif\n   }\n   ValidateStateStack();\n }\n",
    "code_after_change": "void BaseRenderingContext2D::Reset() {\n  ValidateStateStack();\n  UnwindStateStack();\n  state_stack_.resize(1);\n  state_stack_.front() = CanvasRenderingContext2DState::Create();\n  path_.Clear();\n  if (PaintCanvas* c = ExistingDrawingCanvas()) {\n    DCHECK_EQ(c->getSaveCount(), 2);\n    c->restore();\n    c->save();\n    DCHECK(c->getTotalMatrix().isIdentity());\n#if DCHECK_IS_ON()\n    SkIRect clip_bounds;\n    DCHECK(c->getDeviceClipBounds(&clip_bounds));\n    DCHECK(clip_bounds == c->imageInfo().bounds());\n #endif\n   }\n   ValidateStateStack();\n  origin_tainted_by_content_ = false;\n }\n",
    "cwe": [
      "CWE-200"
    ],
    "id": 288,
    "_valid_cwes": [
      "CWE-200"
    ]
  },
  {
    "cve_id": "CVE-2013-1824",
    "code_before_change": "xmlDocPtr soap_xmlParseFile(const char *filename TSRMLS_DC)\n{\n\txmlParserCtxtPtr ctxt = NULL;\n\txmlDocPtr ret;\n\tzend_bool old_allow_url_fopen;\n\n/*\n\txmlInitParser();\n*/\n\n\told_allow_url_fopen = PG(allow_url_fopen);\n\tPG(allow_url_fopen) = 1;\n\tctxt = xmlCreateFileParserCtxt(filename);\n        PG(allow_url_fopen) = old_allow_url_fopen;\n        if (ctxt) {\n                ctxt->keepBlanks = 0;\n               ctxt->options -= XML_PARSE_DTDLOAD;\n                ctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;\n                ctxt->sax->comment = soap_Comment;\n                ctxt->sax->warning = NULL;\n\t\tctxt->sax->error = NULL;\n\t\t/*ctxt->sax->fatalError = NULL;*/\n\t\txmlParseDocument(ctxt);\n\t\tif (ctxt->wellFormed) {\n\t\t\tret = ctxt->myDoc;\n\t\t\tif (ret->URL == NULL && ctxt->directory != NULL) {\n\t\t\t\tret->URL = xmlCharStrdup(ctxt->directory);\n\t\t\t}\n\t\t} else {\n\t\t\tret = NULL;\n\t\t\txmlFreeDoc(ctxt->myDoc);\n\t\t\tctxt->myDoc = NULL;\n\t\t}\n\t\txmlFreeParserCtxt(ctxt);\n\t} else {\n\t\tret = NULL;\n\t}\n\n/*\n\txmlCleanupParser();\n*/\n\n\tif (ret) {\n\t\tcleanup_xml_node((xmlNodePtr)ret);\n\t}\n\treturn ret;\n}\n",
    "code_after_change": "xmlDocPtr soap_xmlParseFile(const char *filename TSRMLS_DC)\n{\n\txmlParserCtxtPtr ctxt = NULL;\n\txmlDocPtr ret;\n\tzend_bool old_allow_url_fopen;\n\n/*\n\txmlInitParser();\n*/\n\n\told_allow_url_fopen = PG(allow_url_fopen);\n\tPG(allow_url_fopen) = 1;\n\tctxt = xmlCreateFileParserCtxt(filename);\n        PG(allow_url_fopen) = old_allow_url_fopen;\n        if (ctxt) {\n                ctxt->keepBlanks = 0;\n               ctxt->options &= ~XML_PARSE_DTDLOAD;\n                ctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;\n                ctxt->sax->comment = soap_Comment;\n                ctxt->sax->warning = NULL;\n\t\tctxt->sax->error = NULL;\n\t\t/*ctxt->sax->fatalError = NULL;*/\n\t\txmlParseDocument(ctxt);\n\t\tif (ctxt->wellFormed) {\n\t\t\tret = ctxt->myDoc;\n\t\t\tif (ret->URL == NULL && ctxt->directory != NULL) {\n\t\t\t\tret->URL = xmlCharStrdup(ctxt->directory);\n\t\t\t}\n\t\t} else {\n\t\t\tret = NULL;\n\t\t\txmlFreeDoc(ctxt->myDoc);\n\t\t\tctxt->myDoc = NULL;\n\t\t}\n\t\txmlFreeParserCtxt(ctxt);\n\t} else {\n\t\tret = NULL;\n\t}\n\n/*\n\txmlCleanupParser();\n*/\n\n\tif (ret) {\n\t\tcleanup_xml_node((xmlNodePtr)ret);\n\t}\n\treturn ret;\n}\n",
    "cwe": [
      "CWE-200"
    ],
    "id": 311,
    "_valid_cwes": [
      "CWE-200"
    ]
  },
  {
    "cve_id": "CVE-2018-6066",
    "code_before_change": "ClassicScript* ClassicPendingScript::GetSource(const KURL& document_url,\n                                               bool& error_occurred) const {\n  CheckState();\n  DCHECK(IsReady());\n\n  error_occurred = ErrorOccurred();\n  if (!is_external_) {\n    ScriptSourceCode source_code(\n        GetElement()->TextFromChildren(), source_location_type_,\n        nullptr /* cache_handler */, document_url, StartingPosition());\n    return ClassicScript::Create(source_code, base_url_for_inline_script_,\n                                 options_, kSharableCrossOrigin);\n  }\n\n  DCHECK(GetResource()->IsLoaded());\n  ScriptResource* resource = ToScriptResource(GetResource());\n  bool streamer_ready = (ready_state_ == kReady) && streamer_ &&\n                        !streamer_->StreamingSuppressed();\n  ScriptSourceCode source_code(streamer_ready ? streamer_ : nullptr, resource);\n   const KURL& base_url = source_code.Url();\n  return ClassicScript::Create(source_code, base_url, options_,\n                               resource->CalculateAccessControlStatus());\n }\n",
    "code_after_change": "ClassicScript* ClassicPendingScript::GetSource(const KURL& document_url,\n                                               bool& error_occurred) const {\n  CheckState();\n  DCHECK(IsReady());\n\n  error_occurred = ErrorOccurred();\n  if (!is_external_) {\n    ScriptSourceCode source_code(\n        GetElement()->TextFromChildren(), source_location_type_,\n        nullptr /* cache_handler */, document_url, StartingPosition());\n    return ClassicScript::Create(source_code, base_url_for_inline_script_,\n                                 options_, kSharableCrossOrigin);\n  }\n\n  DCHECK(GetResource()->IsLoaded());\n  ScriptResource* resource = ToScriptResource(GetResource());\n  bool streamer_ready = (ready_state_ == kReady) && streamer_ &&\n                        !streamer_->StreamingSuppressed();\n  ScriptSourceCode source_code(streamer_ready ? streamer_ : nullptr, resource);\n   const KURL& base_url = source_code.Url();\n  return ClassicScript::Create(\n      source_code, base_url, options_,\n      resource->CalculateAccessControlStatus(\n          GetElement()->GetDocument().GetSecurityOrigin()));\n }\n",
    "cwe": [
      "CWE-200"
    ],
    "id": 320,
    "_valid_cwes": [
      "CWE-200"
    ]
  },
  {
    "cve_id": "CVE-2016-6720",
    "code_before_change": "     void CopyToOMX(const OMX_BUFFERHEADERTYPE *header) {\n        if (!mIsBackup) {\n             return;\n         }\n \n        memcpy(header->pBuffer + header->nOffset,\n (const OMX_U8 *)mMem->pointer() + header->nOffset,\n                header->nFilledLen);\n }\n",
    "code_after_change": "     void CopyToOMX(const OMX_BUFFERHEADERTYPE *header) {\n        if (!mCopyToOmx) {\n             return;\n         }\n \n        memcpy(header->pBuffer + header->nOffset,\n (const OMX_U8 *)mMem->pointer() + header->nOffset,\n                header->nFilledLen);\n }\n",
    "cwe": [
      "CWE-200"
    ],
    "id": 371,
    "_valid_cwes": [
      "CWE-200"
    ]
  },
  {
    "cve_id": "CVE-2019-5837",
    "code_before_change": "void AppCacheUpdateJob::HandleUrlFetchCompleted(URLFetcher* fetcher,\n                                                int net_error) {\n  DCHECK(internal_state_ == DOWNLOADING);\n\n  UpdateURLLoaderRequest* request = fetcher->request();\n  const GURL& url = request->GetURL();\n  pending_url_fetches_.erase(url);\n  NotifyAllProgress(url);\n  ++url_fetches_completed_;\n\n  int response_code = net_error == net::OK ? request->GetResponseCode()\n                                           : fetcher->redirect_response_code();\n\n  AppCacheEntry& entry = url_file_list_.find(url)->second;\n\n  if (response_code / 100 == 2) {\n     DCHECK(fetcher->response_writer());\n     entry.set_response_id(fetcher->response_writer()->response_id());\n    entry.set_response_size(fetcher->response_writer()->amount_written());\n     if (!inprogress_cache_->AddOrModifyEntry(url, entry))\n       duplicate_response_ids_.push_back(entry.response_id());\n \n\n  } else {\n    VLOG(1) << \"Request error: \" << net_error\n            << \" response code: \" << response_code;\n    if (entry.IsExplicit() || entry.IsFallback() || entry.IsIntercept()) {\n       if (response_code == 304 && fetcher->existing_entry().has_response_id()) {\n         entry.set_response_id(fetcher->existing_entry().response_id());\n        entry.set_response_size(fetcher->existing_entry().response_size());\n         inprogress_cache_->AddOrModifyEntry(url, entry);\n       } else {\n         const char kFormatString[] = \"Resource fetch failed (%d) %s\";\n        std::string message = FormatUrlErrorMessage(\n            kFormatString, url, fetcher->result(), response_code);\n        ResultType result = fetcher->result();\n        bool is_cross_origin = url.GetOrigin() != manifest_url_.GetOrigin();\n        switch (result) {\n          case DISKCACHE_ERROR:\n            HandleCacheFailure(\n                blink::mojom::AppCacheErrorDetails(\n                    message,\n                    blink::mojom::AppCacheErrorReason::APPCACHE_UNKNOWN_ERROR,\n                    GURL(), 0, is_cross_origin),\n                result, url);\n            break;\n          case NETWORK_ERROR:\n            HandleCacheFailure(\n                blink::mojom::AppCacheErrorDetails(\n                    message,\n                    blink::mojom::AppCacheErrorReason::APPCACHE_RESOURCE_ERROR,\n                    url, 0, is_cross_origin),\n                result, url);\n            break;\n          default:\n            HandleCacheFailure(\n                blink::mojom::AppCacheErrorDetails(\n                    message,\n                    blink::mojom::AppCacheErrorReason::APPCACHE_RESOURCE_ERROR,\n                    url, response_code, is_cross_origin),\n                result, url);\n            break;\n        }\n        return;\n      }\n    } else if (response_code == 404 || response_code == 410) {\n    } else if (update_type_ == UPGRADE_ATTEMPT &&\n               fetcher->existing_entry().has_response_id()) {\n       entry.set_response_id(fetcher->existing_entry().response_id());\n      entry.set_response_size(fetcher->existing_entry().response_size());\n       inprogress_cache_->AddOrModifyEntry(url, entry);\n     }\n   }\n\n  DCHECK(internal_state_ != CACHE_FAILURE);\n  FetchUrls();\n  MaybeCompleteUpdate();\n}\n",
    "code_after_change": "void AppCacheUpdateJob::HandleUrlFetchCompleted(URLFetcher* fetcher,\n                                                int net_error) {\n  DCHECK(internal_state_ == DOWNLOADING);\n\n  UpdateURLLoaderRequest* request = fetcher->request();\n  const GURL& url = request->GetURL();\n  pending_url_fetches_.erase(url);\n  NotifyAllProgress(url);\n  ++url_fetches_completed_;\n\n  int response_code = net_error == net::OK ? request->GetResponseCode()\n                                           : fetcher->redirect_response_code();\n\n  AppCacheEntry& entry = url_file_list_.find(url)->second;\n\n  if (response_code / 100 == 2) {\n     DCHECK(fetcher->response_writer());\n     entry.set_response_id(fetcher->response_writer()->response_id());\n    entry.SetResponseAndPaddingSizes(\n        fetcher->response_writer()->amount_written(),\n        ComputeAppCacheResponsePadding(url, manifest_url_));\n     if (!inprogress_cache_->AddOrModifyEntry(url, entry))\n       duplicate_response_ids_.push_back(entry.response_id());\n \n\n  } else {\n    VLOG(1) << \"Request error: \" << net_error\n            << \" response code: \" << response_code;\n    if (entry.IsExplicit() || entry.IsFallback() || entry.IsIntercept()) {\n       if (response_code == 304 && fetcher->existing_entry().has_response_id()) {\n         entry.set_response_id(fetcher->existing_entry().response_id());\n        entry.SetResponseAndPaddingSizes(\n            fetcher->existing_entry().response_size(),\n            fetcher->existing_entry().padding_size());\n         inprogress_cache_->AddOrModifyEntry(url, entry);\n       } else {\n         const char kFormatString[] = \"Resource fetch failed (%d) %s\";\n        std::string message = FormatUrlErrorMessage(\n            kFormatString, url, fetcher->result(), response_code);\n        ResultType result = fetcher->result();\n        bool is_cross_origin = url.GetOrigin() != manifest_url_.GetOrigin();\n        switch (result) {\n          case DISKCACHE_ERROR:\n            HandleCacheFailure(\n                blink::mojom::AppCacheErrorDetails(\n                    message,\n                    blink::mojom::AppCacheErrorReason::APPCACHE_UNKNOWN_ERROR,\n                    GURL(), 0, is_cross_origin),\n                result, url);\n            break;\n          case NETWORK_ERROR:\n            HandleCacheFailure(\n                blink::mojom::AppCacheErrorDetails(\n                    message,\n                    blink::mojom::AppCacheErrorReason::APPCACHE_RESOURCE_ERROR,\n                    url, 0, is_cross_origin),\n                result, url);\n            break;\n          default:\n            HandleCacheFailure(\n                blink::mojom::AppCacheErrorDetails(\n                    message,\n                    blink::mojom::AppCacheErrorReason::APPCACHE_RESOURCE_ERROR,\n                    url, response_code, is_cross_origin),\n                result, url);\n            break;\n        }\n        return;\n      }\n    } else if (response_code == 404 || response_code == 410) {\n    } else if (update_type_ == UPGRADE_ATTEMPT &&\n               fetcher->existing_entry().has_response_id()) {\n       entry.set_response_id(fetcher->existing_entry().response_id());\n      entry.SetResponseAndPaddingSizes(\n          fetcher->existing_entry().response_size(),\n          fetcher->existing_entry().padding_size());\n       inprogress_cache_->AddOrModifyEntry(url, entry);\n     }\n   }\n\n  DCHECK(internal_state_ != CACHE_FAILURE);\n  FetchUrls();\n  MaybeCompleteUpdate();\n}\n",
    "cwe": [
      "CWE-200"
    ],
    "id": 436,
    "_valid_cwes": [
      "CWE-200"
    ]
  },
  {
    "cve_id": "CVE-2019-5837",
    "code_before_change": "bool AppCacheDatabase::FindEntriesForUrl(\n    const GURL& url, std::vector<EntryRecord>* records) {\n  DCHECK(records && records->empty());\n  if (!LazyOpen(kDontCreate))\n     return false;\n \n   static const char kSql[] =\n      \"SELECT cache_id, url, flags, response_id, response_size FROM Entries\"\n       \"  WHERE url = ?\";\n \n   sql::Statement statement(db_->GetCachedStatement(SQL_FROM_HERE, kSql));\n  statement.BindString(0, url.spec());\n\n  while (statement.Step()) {\n    records->push_back(EntryRecord());\n    ReadEntryRecord(statement, &records->back());\n    DCHECK(records->back().url == url);\n  }\n\n  return statement.Succeeded();\n}\n",
    "code_after_change": "bool AppCacheDatabase::FindEntriesForUrl(\n    const GURL& url, std::vector<EntryRecord>* records) {\n  DCHECK(records && records->empty());\n  if (!LazyOpen(kDontCreate))\n     return false;\n \n   static const char kSql[] =\n      \"SELECT cache_id, url, flags, response_id, response_size, padding_size \"\n      \"FROM Entries\"\n       \"  WHERE url = ?\";\n \n   sql::Statement statement(db_->GetCachedStatement(SQL_FROM_HERE, kSql));\n  statement.BindString(0, url.spec());\n\n  while (statement.Step()) {\n    records->push_back(EntryRecord());\n    ReadEntryRecord(statement, &records->back());\n    DCHECK(records->back().url == url);\n  }\n\n  return statement.Succeeded();\n}\n",
    "cwe": [
      "CWE-200"
    ],
    "id": 440,
    "_valid_cwes": [
      "CWE-200"
    ]
  },
  {
    "cve_id": "CVE-2018-4117",
    "code_before_change": "void FetchManager::Loader::Start() {\n\n\n\n\n\n  if (!ContentSecurityPolicy::ShouldBypassMainWorld(execution_context_) &&\n      !execution_context_->GetContentSecurityPolicy()->AllowConnectToSource(\n          fetch_request_data_->Url())) {\n    PerformNetworkError(\n        \"Refused to connect to '\" + fetch_request_data_->Url().ElidedString() +\n        \"' because it violates the document's Content Security Policy.\");\n    return;\n  }\n\n  if ((SecurityOrigin::Create(fetch_request_data_->Url())\n           ->IsSameSchemeHostPort(fetch_request_data_->Origin().get())) ||\n      (fetch_request_data_->Url().ProtocolIsData() &&\n       fetch_request_data_->SameOriginDataURLFlag()) ||\n      (fetch_request_data_->Mode() == FetchRequestMode::kNavigate)) {\n    PerformSchemeFetch();\n    return;\n  }\n\n  if (fetch_request_data_->Mode() == FetchRequestMode::kSameOrigin) {\n    PerformNetworkError(\"Fetch API cannot load \" +\n                        fetch_request_data_->Url().GetString() +\n                        \". Request mode is \\\"same-origin\\\" but the URL\\'s \"\n                        \"origin is not same as the request origin \" +\n                        fetch_request_data_->Origin()->ToString() + \".\");\n    return;\n  }\n \n   if (fetch_request_data_->Mode() == FetchRequestMode::kNoCORS) {\n     fetch_request_data_->SetResponseTainting(FetchRequestData::kOpaqueTainting);\n    PerformSchemeFetch();\n    return;\n  }\n\n  if (!SchemeRegistry::ShouldTreatURLSchemeAsSupportingFetchAPI(\n          fetch_request_data_->Url().Protocol())) {\n    PerformNetworkError(\n        \"Fetch API cannot load \" + fetch_request_data_->Url().GetString() +\n        \". URL scheme must be \\\"http\\\" or \\\"https\\\" for CORS request.\");\n    return;\n  }\n\n  fetch_request_data_->SetResponseTainting(FetchRequestData::kCORSTainting);\n\n  PerformHTTPFetch();\n}\n",
    "code_after_change": "void FetchManager::Loader::Start() {\n\n\n\n\n\n  if (!ContentSecurityPolicy::ShouldBypassMainWorld(execution_context_) &&\n      !execution_context_->GetContentSecurityPolicy()->AllowConnectToSource(\n          fetch_request_data_->Url())) {\n    PerformNetworkError(\n        \"Refused to connect to '\" + fetch_request_data_->Url().ElidedString() +\n        \"' because it violates the document's Content Security Policy.\");\n    return;\n  }\n\n  if ((SecurityOrigin::Create(fetch_request_data_->Url())\n           ->IsSameSchemeHostPort(fetch_request_data_->Origin().get())) ||\n      (fetch_request_data_->Url().ProtocolIsData() &&\n       fetch_request_data_->SameOriginDataURLFlag()) ||\n      (fetch_request_data_->Mode() == FetchRequestMode::kNavigate)) {\n    PerformSchemeFetch();\n    return;\n  }\n\n  if (fetch_request_data_->Mode() == FetchRequestMode::kSameOrigin) {\n    PerformNetworkError(\"Fetch API cannot load \" +\n                        fetch_request_data_->Url().GetString() +\n                        \". Request mode is \\\"same-origin\\\" but the URL\\'s \"\n                        \"origin is not same as the request origin \" +\n                        fetch_request_data_->Origin()->ToString() + \".\");\n    return;\n  }\n \n   if (fetch_request_data_->Mode() == FetchRequestMode::kNoCORS) {\n    // \"If |request|'s redirect mode is not |follow|, then return a network\n    // error.\n    if (fetch_request_data_->Redirect() != FetchRedirectMode::kFollow) {\n      PerformNetworkError(\"Fetch API cannot load \" +\n                          fetch_request_data_->Url().GetString() +\n                          \". Request mode is \\\"no-cors\\\" but the redirect mode \"\n                          \" is not \\\"follow\\\".\");\n      return;\n    }\n\n     fetch_request_data_->SetResponseTainting(FetchRequestData::kOpaqueTainting);\n    PerformSchemeFetch();\n    return;\n  }\n\n  if (!SchemeRegistry::ShouldTreatURLSchemeAsSupportingFetchAPI(\n          fetch_request_data_->Url().Protocol())) {\n    PerformNetworkError(\n        \"Fetch API cannot load \" + fetch_request_data_->Url().GetString() +\n        \". URL scheme must be \\\"http\\\" or \\\"https\\\" for CORS request.\");\n    return;\n  }\n\n  fetch_request_data_->SetResponseTainting(FetchRequestData::kCORSTainting);\n\n  PerformHTTPFetch();\n}\n",
    "cwe": [
      "CWE-200"
    ],
    "id": 459,
    "_valid_cwes": [
      "CWE-200"
    ]
  },
  {
    "cve_id": "CVE-2017-0555",
    "code_before_change": "WORD32 ih264d_mark_err_slice_skip(dec_struct_t * ps_dec,\n                                WORD32 num_mb_skip,\n                                UWORD8 u1_is_idr_slice,\n                                UWORD16 u2_frame_num,\n pocstruct_t *ps_cur_poc,\n                                WORD32 prev_slice_err)\n{\n    WORD32 i2_cur_mb_addr;\n    UWORD32 u1_num_mbs, u1_num_mbsNby2;\n    UWORD32 u1_mb_idx = ps_dec->u1_mb_idx;\n    UWORD32 i2_mb_skip_run;\n\n    UWORD32 u1_num_mbs_next, u1_end_of_row;\n const UWORD32 i2_pic_wdin_mbs = ps_dec->u2_frm_wd_in_mbs;\n    UWORD32 u1_slice_end;\n    UWORD32 u1_tfr_n_mb;\n    UWORD32 u1_decode_nmb;\n dec_bit_stream_t * const ps_bitstrm = ps_dec->ps_bitstrm;\n dec_slice_params_t * ps_slice = ps_dec->ps_cur_slice;\n    UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;\n    UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;\n deblk_mb_t *ps_cur_deblk_mb;\n dec_mb_info_t *ps_cur_mb_info;\n parse_pmbarams_t *ps_parse_mb_data;\n    UWORD32 u1_inter_mb_type;\n    UWORD32 u1_deblk_mb_type;\n    UWORD16 u2_total_mbs_coded;\n    UWORD32 u1_mbaff = ps_slice->u1_mbaff_frame_flag;\n parse_part_params_t *ps_part_info;\n    WORD32 ret;\n    UNUSED(u1_is_idr_slice);\n\n if(ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC)\n {\n        ih264d_err_pic_dispbuf_mgr(ps_dec);\n return 0;\n }\n\n if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag && (num_mb_skip & 1))\n {\n        num_mb_skip++;\n }\n    ps_dec->ps_dpb_cmds->u1_long_term_reference_flag = 0;\n if(prev_slice_err == 1)\n {\n /* first slice - missing/header corruption */\n        ps_dec->ps_cur_slice->u2_frame_num = u2_frame_num;\n {\n            WORD32 i, j, poc = 0;\n\n            ps_dec->ps_cur_slice->u2_first_mb_in_slice = 0;\n\n            ps_dec->pf_mvpred = ih264d_mvpred_nonmbaff;\n            ps_dec->p_form_mb_part_info = ih264d_form_mb_part_info_bp;\n            ps_dec->p_motion_compensate = ih264d_motion_compensate_bp;\n\n if(ps_dec->ps_cur_pic != NULL)\n                poc = ps_dec->ps_cur_pic->i4_poc + 2;\n\n            j = -1;\n for(i = 0; i < MAX_NUM_PIC_PARAMS; i++)\n {\n if(ps_dec->ps_pps[i].u1_is_valid == TRUE)\n {\n if(ps_dec->ps_pps[i].ps_sps->u1_is_valid == TRUE)\n {\n                           j = i;\n break;\n }\n }\n }\n\n if(j == -1)\n {\n return ERROR_INV_SLICE_HDR_T;\n }\n\n /* call ih264d_start_of_pic only if it was not called earlier*/\n if(ps_dec->u4_pic_buf_got == 0)\n {\n                ps_dec->ps_cur_slice->u1_slice_type = P_SLICE;\n                ps_dec->ps_cur_slice->u1_nal_ref_idc = 1;\n                ps_dec->ps_cur_slice->u1_nal_unit_type = 1;\n                ret = ih264d_start_of_pic(ps_dec, poc, ps_cur_poc,\n                        ps_dec->ps_cur_slice->u2_frame_num,\n &ps_dec->ps_pps[j]);\n\n if(ret != OK)\n {\n return ret;\n }\n }\n\n            ps_dec->ps_ref_pic_buf_lx[0][0]->u1_pic_buf_id = 0;\n\n            ps_dec->u4_output_present = 0;\n\n {\n                ih264d_get_next_display_field(ps_dec,\n                                              ps_dec->ps_out_buffer,\n &(ps_dec->s_disp_op));\n /* If error code is non-zero then there is no buffer available for display,\n                 hence avoid format conversion */\n\n if(0 != ps_dec->s_disp_op.u4_error_code)\n {\n                    ps_dec->u4_fmt_conv_cur_row = ps_dec->s_disp_frame_info.u4_y_ht;\n }\n else\n                    ps_dec->u4_output_present = 1;\n }\n\n if(ps_dec->u1_separate_parse == 1)\n {\n if(ps_dec->u4_dec_thread_created == 0)\n {\n                    ithread_create(ps_dec->pv_dec_thread_handle, NULL,\n (void *)ih264d_decode_picture_thread,\n (void *)ps_dec);\n\n                    ps_dec->u4_dec_thread_created = 1;\n }\n\n if((ps_dec->u4_num_cores == 3) &&\n ((ps_dec->u4_app_disable_deblk_frm == 0) || ps_dec->i1_recon_in_thread3_flag)\n && (ps_dec->u4_bs_deblk_thread_created == 0))\n {\n                    ps_dec->u4_start_recon_deblk = 0;\n                    ithread_create(ps_dec->pv_bs_deblk_thread_handle, NULL,\n (void *)ih264d_recon_deblk_thread,\n (void *)ps_dec);\n                    ps_dec->u4_bs_deblk_thread_created = 1;\n\n                 }\n             }\n         }\n        ps_dec->u4_first_slice_in_pic = 0;\n     }\n     else\n     {\n\n dec_slice_struct_t *ps_parse_cur_slice;\n        ps_parse_cur_slice = ps_dec->ps_dec_slice_buf + ps_dec->u2_cur_slice_num;\n\n if(ps_dec->u1_slice_header_done\n && ps_parse_cur_slice == ps_dec->ps_parse_cur_slice)\n {\n if((u1_mbaff) && (ps_dec->u4_num_mbs_cur_nmb & 1))\n {\n                ps_dec->u4_num_mbs_cur_nmb = ps_dec->u4_num_mbs_cur_nmb - 1;\n                ps_dec->u2_cur_mb_addr--;\n }\n\n            u1_num_mbs = ps_dec->u4_num_mbs_cur_nmb;\n if(u1_num_mbs)\n {\n                ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs - 1;\n }\n else\n {\n if(ps_dec->u1_separate_parse)\n {\n                    ps_cur_mb_info = ps_dec->ps_nmb_info;\n }\n else\n {\n                    ps_cur_mb_info = ps_dec->ps_nmb_info\n + ps_dec->u4_num_mbs_prev_nmb - 1;\n }\n }\n\n            ps_dec->u2_mby = ps_cur_mb_info->u2_mby;\n            ps_dec->u2_mbx = ps_cur_mb_info->u2_mbx;\n\n            ps_dec->u1_mb_ngbr_availablity =\n                    ps_cur_mb_info->u1_mb_ngbr_availablity;\n\n if(u1_num_mbs)\n {\n                ps_dec->pv_parse_tu_coeff_data = ps_dec->pv_prev_mb_parse_tu_coeff_data;\n                ps_dec->u2_cur_mb_addr--;\n                ps_dec->i4_submb_ofst -= SUB_BLK_SIZE;\n\n if (ps_dec->u1_pr_sl_type == P_SLICE\n || ps_dec->u1_pr_sl_type == B_SLICE)\n {\n                    ps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx,    u1_num_mbs);\n                    ps_dec->ps_part = ps_dec->ps_parse_part_params;\n }\n\n                u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;\n                u1_end_of_row = (!u1_num_mbs_next)\n && (!(u1_mbaff && (u1_num_mbs & 0x01)));\n                u1_slice_end = 1;\n                u1_tfr_n_mb = 1;\n                ps_cur_mb_info->u1_end_of_slice = u1_slice_end;\n\n if(ps_dec->u1_separate_parse)\n {\n                    ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\n                            u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);\n                    ps_dec->ps_nmb_info += u1_num_mbs;\n }\n else\n {\n                    ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\n                            u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);\n }\n                ps_dec->u2_total_mbs_coded += u1_num_mbs;\n                ps_dec->u1_mb_idx = 0;\n                ps_dec->u4_num_mbs_cur_nmb = 0;\n }\n\n if(ps_dec->u2_total_mbs_coded\n >= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n {\n                ps_dec->u1_pic_decode_done = 1;\n return 0;\n }\n\n /* Inserting new slice only if the current slice has atleast 1 MB*/\n if(ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice <\n (UWORD32)(ps_dec->u2_total_mbs_coded >> ps_slice->u1_mbaff_frame_flag))\n {\n                ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;\n                ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;\n                ps_dec->u2_cur_slice_num++;\n                ps_dec->ps_parse_cur_slice++;\n }\n\n }\n else\n {\n            ps_dec->ps_parse_cur_slice = ps_dec->ps_dec_slice_buf\n + ps_dec->u2_cur_slice_num;\n }\n }\n\n /******************************************************/\n /* Initializations to new slice                       */\n /******************************************************/\n {\n        WORD32 num_entries;\n        WORD32 size;\n        UWORD8 *pu1_buf;\n\n        num_entries = MIN(MAX_FRAMES, ps_dec->u4_num_ref_frames_at_init);\n        num_entries = 2 * ((2 * num_entries) + 1);\n\n        size = num_entries * sizeof(void *);\n        size += PAD_MAP_IDX_POC * sizeof(void *);\n\n        pu1_buf = (UWORD8 *)ps_dec->pv_map_ref_idx_to_poc_buf;\n        pu1_buf += size * ps_dec->u2_cur_slice_num;\n        ps_dec->ps_parse_cur_slice->ppv_map_ref_idx_to_poc = (volatile void **)pu1_buf;\n }\n\n    ps_dec->ps_cur_slice->u2_first_mb_in_slice = ps_dec->u2_total_mbs_coded >> u1_mbaff;\n    ps_dec->ps_cur_slice->i1_slice_alpha_c0_offset = 0;\n    ps_dec->ps_cur_slice->i1_slice_beta_offset = 0;\n\n if(ps_dec->ps_cur_slice->u1_field_pic_flag)\n        ps_dec->u2_prv_frame_num = ps_dec->ps_cur_slice->u2_frame_num;\n\n    ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice = ps_dec->u2_total_mbs_coded >> u1_mbaff;\n    ps_dec->ps_parse_cur_slice->u2_log2Y_crwd =    ps_dec->ps_cur_slice->u2_log2Y_crwd;\n\n\n if(ps_dec->u1_separate_parse)\n {\n        ps_dec->ps_parse_cur_slice->pv_tu_coeff_data_start = ps_dec->pv_parse_tu_coeff_data;\n }\n else\n {\n        ps_dec->pv_proc_tu_coeff_data = ps_dec->pv_parse_tu_coeff_data;\n }\n\n /******************************************************/\n /* Initializations specific to P slice                */\n /******************************************************/\n    u1_inter_mb_type = P_MB;\n    u1_deblk_mb_type = D_INTER_MB;\n\n    ps_dec->ps_cur_slice->u1_slice_type = P_SLICE;\n    ps_dec->ps_parse_cur_slice->slice_type = P_SLICE;\n    ps_dec->pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_pmb;\n    ps_dec->ps_part = ps_dec->ps_parse_part_params;\n    ps_dec->u2_mbx =\n (MOD(ps_dec->ps_cur_slice->u2_first_mb_in_slice - 1, ps_dec->u2_frm_wd_in_mbs));\n    ps_dec->u2_mby =\n (DIV(ps_dec->ps_cur_slice->u2_first_mb_in_slice - 1, ps_dec->u2_frm_wd_in_mbs));\n    ps_dec->u2_mby <<= u1_mbaff;\n\n /******************************************************/\n /* Parsing / decoding the slice                       */\n /******************************************************/\n    ps_dec->u1_slice_header_done = 2;\n    ps_dec->u1_qp = ps_slice->u1_slice_qp;\n    ih264d_update_qp(ps_dec, 0);\n    u1_mb_idx = ps_dec->u1_mb_idx;\n    ps_parse_mb_data = ps_dec->ps_parse_mb_data;\n    u1_num_mbs = u1_mb_idx;\n\n    u1_slice_end = 0;\n    u1_tfr_n_mb = 0;\n    u1_decode_nmb = 0;\n    u1_num_mbsNby2 = 0;\n    i2_cur_mb_addr = ps_dec->u2_total_mbs_coded;\n    i2_mb_skip_run = num_mb_skip;\n\n while(!u1_slice_end)\n {\n        UWORD8 u1_mb_type;\n\n if(i2_cur_mb_addr > ps_dec->ps_cur_sps->u2_max_mb_addr)\n break;\n\n        ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs;\n        ps_dec->u4_num_mbs_cur_nmb = u1_num_mbs;\n\n        ps_cur_mb_info->u1_Mux = 0;\n        ps_dec->u4_num_pmbair = (u1_num_mbs >> u1_mbaff);\n        ps_cur_deblk_mb = ps_dec->ps_deblk_mbn + u1_num_mbs;\n\n        ps_cur_mb_info->u1_end_of_slice = 0;\n\n /* Storing Default partition info */\n        ps_parse_mb_data->u1_num_part = 1;\n        ps_parse_mb_data->u1_isI_mb = 0;\n\n /**************************************************************/\n /* Get the required information for decoding of MB            */\n /**************************************************************/\n /* mb_x, mb_y, neighbor availablity, */\n if (u1_mbaff)\n            ih264d_get_mb_info_cavlc_mbaff(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, i2_mb_skip_run);\n else\n            ih264d_get_mb_info_cavlc_nonmbaff(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, i2_mb_skip_run);\n\n /* Set the deblocking parameters for this MB */\n if(ps_dec->u4_app_disable_deblk_frm == 0)\n {\n            ih264d_set_deblocking_parameters(ps_cur_deblk_mb, ps_slice,\n                                             ps_dec->u1_mb_ngbr_availablity,\n                                             ps_dec->u1_cur_mb_fld_dec_flag);\n }\n\n /* Set appropriate flags in ps_cur_mb_info and ps_dec */\n        ps_dec->i1_prev_mb_qp_delta = 0;\n        ps_dec->u1_sub_mb_num = 0;\n        ps_cur_mb_info->u1_mb_type = MB_SKIP;\n        ps_cur_mb_info->u1_mb_mc_mode = PRED_16x16;\n        ps_cur_mb_info->u1_cbp = 0;\n\n /* Storing Skip partition info */\n        ps_part_info = ps_dec->ps_part;\n        ps_part_info->u1_is_direct = PART_DIRECT_16x16;\n        ps_part_info->u1_sub_mb_num = 0;\n        ps_dec->ps_part++;\n\n /* Update Nnzs */\n        ih264d_update_nnz_for_skipmb(ps_dec, ps_cur_mb_info, CAVLC);\n\n        ps_cur_mb_info->ps_curmb->u1_mb_type = u1_inter_mb_type;\n        ps_cur_deblk_mb->u1_mb_type |= u1_deblk_mb_type;\n\n        i2_mb_skip_run--;\n\n        ps_cur_deblk_mb->u1_mb_qp = ps_dec->u1_qp;\n\n if (u1_mbaff)\n {\n            ih264d_update_mbaff_left_nnz(ps_dec, ps_cur_mb_info);\n }\n\n /**************************************************************/\n /* Get next Macroblock address                                */\n /**************************************************************/\n        i2_cur_mb_addr++;\n\n        u1_num_mbs++;\n        u1_num_mbsNby2++;\n        ps_parse_mb_data++;\n\n /****************************************************************/\n /* Check for End Of Row and other flags that determine when to  */\n /* do DMA setup for N/2-Mb, Decode for N-Mb, and Transfer for   */\n /* N-Mb                                                         */\n /****************************************************************/\n        u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;\n        u1_end_of_row = (!u1_num_mbs_next) && (!(u1_mbaff && (u1_num_mbs & 0x01)));\n        u1_slice_end = !i2_mb_skip_run;\n        u1_tfr_n_mb = (u1_num_mbs == ps_dec->u1_recon_mb_grp) || u1_end_of_row\n || u1_slice_end;\n        u1_decode_nmb = u1_tfr_n_mb || u1_slice_end;\n        ps_cur_mb_info->u1_end_of_slice = u1_slice_end;\n\n if(u1_decode_nmb)\n {\n            ps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx, u1_num_mbs);\n            u1_num_mbsNby2 = 0;\n\n            ps_parse_mb_data = ps_dec->ps_parse_mb_data;\n            ps_dec->ps_part = ps_dec->ps_parse_part_params;\n\n if(ps_dec->u1_separate_parse)\n {\n                ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\n                                     u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);\n                ps_dec->ps_nmb_info +=  u1_num_mbs;\n }\n else\n {\n                ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs, u1_num_mbs_next,\n                                            u1_tfr_n_mb, u1_end_of_row);\n }\n            ps_dec->u2_total_mbs_coded += u1_num_mbs;\n if(u1_tfr_n_mb)\n                u1_num_mbs = 0;\n            u1_mb_idx = u1_num_mbs;\n            ps_dec->u1_mb_idx = u1_num_mbs;\n }\n }\n\n    ps_dec->u4_num_mbs_cur_nmb = 0;\n    ps_dec->ps_cur_slice->u4_mbs_in_slice = i2_cur_mb_addr\n - ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice;\n\n    H264_DEC_DEBUG_PRINT(\"Mbs in slice: %d\\n\", ps_dec->ps_cur_slice->u4_mbs_in_slice);\n\n\n /* incremented here only if first slice is inserted */\n if(ps_dec->u4_first_slice_in_pic != 0)\n {\n        ps_dec->ps_parse_cur_slice++;\n        ps_dec->u2_cur_slice_num++;\n }\n\n    ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;\n    ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;\n\n if(ps_dec->u2_total_mbs_coded\n >= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n {\n        ps_dec->u1_pic_decode_done = 1;\n }\n\n return 0;\n\n}\n",
    "code_after_change": "WORD32 ih264d_mark_err_slice_skip(dec_struct_t * ps_dec,\n                                WORD32 num_mb_skip,\n                                UWORD8 u1_is_idr_slice,\n                                UWORD16 u2_frame_num,\n pocstruct_t *ps_cur_poc,\n                                WORD32 prev_slice_err)\n{\n    WORD32 i2_cur_mb_addr;\n    UWORD32 u1_num_mbs, u1_num_mbsNby2;\n    UWORD32 u1_mb_idx = ps_dec->u1_mb_idx;\n    UWORD32 i2_mb_skip_run;\n\n    UWORD32 u1_num_mbs_next, u1_end_of_row;\n const UWORD32 i2_pic_wdin_mbs = ps_dec->u2_frm_wd_in_mbs;\n    UWORD32 u1_slice_end;\n    UWORD32 u1_tfr_n_mb;\n    UWORD32 u1_decode_nmb;\n dec_bit_stream_t * const ps_bitstrm = ps_dec->ps_bitstrm;\n dec_slice_params_t * ps_slice = ps_dec->ps_cur_slice;\n    UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;\n    UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;\n deblk_mb_t *ps_cur_deblk_mb;\n dec_mb_info_t *ps_cur_mb_info;\n parse_pmbarams_t *ps_parse_mb_data;\n    UWORD32 u1_inter_mb_type;\n    UWORD32 u1_deblk_mb_type;\n    UWORD16 u2_total_mbs_coded;\n    UWORD32 u1_mbaff = ps_slice->u1_mbaff_frame_flag;\n parse_part_params_t *ps_part_info;\n    WORD32 ret;\n    UNUSED(u1_is_idr_slice);\n\n if(ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC)\n {\n        ih264d_err_pic_dispbuf_mgr(ps_dec);\n return 0;\n }\n\n if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag && (num_mb_skip & 1))\n {\n        num_mb_skip++;\n }\n    ps_dec->ps_dpb_cmds->u1_long_term_reference_flag = 0;\n if(prev_slice_err == 1)\n {\n /* first slice - missing/header corruption */\n        ps_dec->ps_cur_slice->u2_frame_num = u2_frame_num;\n {\n            WORD32 i, j, poc = 0;\n\n            ps_dec->ps_cur_slice->u2_first_mb_in_slice = 0;\n\n            ps_dec->pf_mvpred = ih264d_mvpred_nonmbaff;\n            ps_dec->p_form_mb_part_info = ih264d_form_mb_part_info_bp;\n            ps_dec->p_motion_compensate = ih264d_motion_compensate_bp;\n\n if(ps_dec->ps_cur_pic != NULL)\n                poc = ps_dec->ps_cur_pic->i4_poc + 2;\n\n            j = -1;\n for(i = 0; i < MAX_NUM_PIC_PARAMS; i++)\n {\n if(ps_dec->ps_pps[i].u1_is_valid == TRUE)\n {\n if(ps_dec->ps_pps[i].ps_sps->u1_is_valid == TRUE)\n {\n                           j = i;\n break;\n }\n }\n }\n\n if(j == -1)\n {\n return ERROR_INV_SLICE_HDR_T;\n }\n\n /* call ih264d_start_of_pic only if it was not called earlier*/\n if(ps_dec->u4_pic_buf_got == 0)\n {\n                ps_dec->ps_cur_slice->u1_slice_type = P_SLICE;\n                ps_dec->ps_cur_slice->u1_nal_ref_idc = 1;\n                ps_dec->ps_cur_slice->u1_nal_unit_type = 1;\n                ret = ih264d_start_of_pic(ps_dec, poc, ps_cur_poc,\n                        ps_dec->ps_cur_slice->u2_frame_num,\n &ps_dec->ps_pps[j]);\n\n if(ret != OK)\n {\n return ret;\n }\n }\n\n            ps_dec->ps_ref_pic_buf_lx[0][0]->u1_pic_buf_id = 0;\n\n            ps_dec->u4_output_present = 0;\n\n {\n                ih264d_get_next_display_field(ps_dec,\n                                              ps_dec->ps_out_buffer,\n &(ps_dec->s_disp_op));\n /* If error code is non-zero then there is no buffer available for display,\n                 hence avoid format conversion */\n\n if(0 != ps_dec->s_disp_op.u4_error_code)\n {\n                    ps_dec->u4_fmt_conv_cur_row = ps_dec->s_disp_frame_info.u4_y_ht;\n }\n else\n                    ps_dec->u4_output_present = 1;\n }\n\n if(ps_dec->u1_separate_parse == 1)\n {\n if(ps_dec->u4_dec_thread_created == 0)\n {\n                    ithread_create(ps_dec->pv_dec_thread_handle, NULL,\n (void *)ih264d_decode_picture_thread,\n (void *)ps_dec);\n\n                    ps_dec->u4_dec_thread_created = 1;\n }\n\n if((ps_dec->u4_num_cores == 3) &&\n ((ps_dec->u4_app_disable_deblk_frm == 0) || ps_dec->i1_recon_in_thread3_flag)\n && (ps_dec->u4_bs_deblk_thread_created == 0))\n {\n                    ps_dec->u4_start_recon_deblk = 0;\n                    ithread_create(ps_dec->pv_bs_deblk_thread_handle, NULL,\n (void *)ih264d_recon_deblk_thread,\n (void *)ps_dec);\n                    ps_dec->u4_bs_deblk_thread_created = 1;\n\n                 }\n             }\n         }\n     }\n     else\n     {\n\n dec_slice_struct_t *ps_parse_cur_slice;\n        ps_parse_cur_slice = ps_dec->ps_dec_slice_buf + ps_dec->u2_cur_slice_num;\n\n if(ps_dec->u1_slice_header_done\n && ps_parse_cur_slice == ps_dec->ps_parse_cur_slice)\n {\n if((u1_mbaff) && (ps_dec->u4_num_mbs_cur_nmb & 1))\n {\n                ps_dec->u4_num_mbs_cur_nmb = ps_dec->u4_num_mbs_cur_nmb - 1;\n                ps_dec->u2_cur_mb_addr--;\n }\n\n            u1_num_mbs = ps_dec->u4_num_mbs_cur_nmb;\n if(u1_num_mbs)\n {\n                ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs - 1;\n }\n else\n {\n if(ps_dec->u1_separate_parse)\n {\n                    ps_cur_mb_info = ps_dec->ps_nmb_info;\n }\n else\n {\n                    ps_cur_mb_info = ps_dec->ps_nmb_info\n + ps_dec->u4_num_mbs_prev_nmb - 1;\n }\n }\n\n            ps_dec->u2_mby = ps_cur_mb_info->u2_mby;\n            ps_dec->u2_mbx = ps_cur_mb_info->u2_mbx;\n\n            ps_dec->u1_mb_ngbr_availablity =\n                    ps_cur_mb_info->u1_mb_ngbr_availablity;\n\n if(u1_num_mbs)\n {\n                ps_dec->pv_parse_tu_coeff_data = ps_dec->pv_prev_mb_parse_tu_coeff_data;\n                ps_dec->u2_cur_mb_addr--;\n                ps_dec->i4_submb_ofst -= SUB_BLK_SIZE;\n\n if (ps_dec->u1_pr_sl_type == P_SLICE\n || ps_dec->u1_pr_sl_type == B_SLICE)\n {\n                    ps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx,    u1_num_mbs);\n                    ps_dec->ps_part = ps_dec->ps_parse_part_params;\n }\n\n                u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;\n                u1_end_of_row = (!u1_num_mbs_next)\n && (!(u1_mbaff && (u1_num_mbs & 0x01)));\n                u1_slice_end = 1;\n                u1_tfr_n_mb = 1;\n                ps_cur_mb_info->u1_end_of_slice = u1_slice_end;\n\n if(ps_dec->u1_separate_parse)\n {\n                    ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\n                            u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);\n                    ps_dec->ps_nmb_info += u1_num_mbs;\n }\n else\n {\n                    ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\n                            u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);\n }\n                ps_dec->u2_total_mbs_coded += u1_num_mbs;\n                ps_dec->u1_mb_idx = 0;\n                ps_dec->u4_num_mbs_cur_nmb = 0;\n }\n\n if(ps_dec->u2_total_mbs_coded\n >= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n {\n                ps_dec->u1_pic_decode_done = 1;\n return 0;\n }\n\n /* Inserting new slice only if the current slice has atleast 1 MB*/\n if(ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice <\n (UWORD32)(ps_dec->u2_total_mbs_coded >> ps_slice->u1_mbaff_frame_flag))\n {\n                ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;\n                ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;\n                ps_dec->u2_cur_slice_num++;\n                ps_dec->ps_parse_cur_slice++;\n }\n\n }\n else\n {\n            ps_dec->ps_parse_cur_slice = ps_dec->ps_dec_slice_buf\n + ps_dec->u2_cur_slice_num;\n }\n }\n\n /******************************************************/\n /* Initializations to new slice                       */\n /******************************************************/\n {\n        WORD32 num_entries;\n        WORD32 size;\n        UWORD8 *pu1_buf;\n\n        num_entries = MIN(MAX_FRAMES, ps_dec->u4_num_ref_frames_at_init);\n        num_entries = 2 * ((2 * num_entries) + 1);\n\n        size = num_entries * sizeof(void *);\n        size += PAD_MAP_IDX_POC * sizeof(void *);\n\n        pu1_buf = (UWORD8 *)ps_dec->pv_map_ref_idx_to_poc_buf;\n        pu1_buf += size * ps_dec->u2_cur_slice_num;\n        ps_dec->ps_parse_cur_slice->ppv_map_ref_idx_to_poc = (volatile void **)pu1_buf;\n }\n\n    ps_dec->ps_cur_slice->u2_first_mb_in_slice = ps_dec->u2_total_mbs_coded >> u1_mbaff;\n    ps_dec->ps_cur_slice->i1_slice_alpha_c0_offset = 0;\n    ps_dec->ps_cur_slice->i1_slice_beta_offset = 0;\n\n if(ps_dec->ps_cur_slice->u1_field_pic_flag)\n        ps_dec->u2_prv_frame_num = ps_dec->ps_cur_slice->u2_frame_num;\n\n    ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice = ps_dec->u2_total_mbs_coded >> u1_mbaff;\n    ps_dec->ps_parse_cur_slice->u2_log2Y_crwd =    ps_dec->ps_cur_slice->u2_log2Y_crwd;\n\n\n if(ps_dec->u1_separate_parse)\n {\n        ps_dec->ps_parse_cur_slice->pv_tu_coeff_data_start = ps_dec->pv_parse_tu_coeff_data;\n }\n else\n {\n        ps_dec->pv_proc_tu_coeff_data = ps_dec->pv_parse_tu_coeff_data;\n }\n\n /******************************************************/\n /* Initializations specific to P slice                */\n /******************************************************/\n    u1_inter_mb_type = P_MB;\n    u1_deblk_mb_type = D_INTER_MB;\n\n    ps_dec->ps_cur_slice->u1_slice_type = P_SLICE;\n    ps_dec->ps_parse_cur_slice->slice_type = P_SLICE;\n    ps_dec->pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_pmb;\n    ps_dec->ps_part = ps_dec->ps_parse_part_params;\n    ps_dec->u2_mbx =\n (MOD(ps_dec->ps_cur_slice->u2_first_mb_in_slice - 1, ps_dec->u2_frm_wd_in_mbs));\n    ps_dec->u2_mby =\n (DIV(ps_dec->ps_cur_slice->u2_first_mb_in_slice - 1, ps_dec->u2_frm_wd_in_mbs));\n    ps_dec->u2_mby <<= u1_mbaff;\n\n /******************************************************/\n /* Parsing / decoding the slice                       */\n /******************************************************/\n    ps_dec->u1_slice_header_done = 2;\n    ps_dec->u1_qp = ps_slice->u1_slice_qp;\n    ih264d_update_qp(ps_dec, 0);\n    u1_mb_idx = ps_dec->u1_mb_idx;\n    ps_parse_mb_data = ps_dec->ps_parse_mb_data;\n    u1_num_mbs = u1_mb_idx;\n\n    u1_slice_end = 0;\n    u1_tfr_n_mb = 0;\n    u1_decode_nmb = 0;\n    u1_num_mbsNby2 = 0;\n    i2_cur_mb_addr = ps_dec->u2_total_mbs_coded;\n    i2_mb_skip_run = num_mb_skip;\n\n while(!u1_slice_end)\n {\n        UWORD8 u1_mb_type;\n\n if(i2_cur_mb_addr > ps_dec->ps_cur_sps->u2_max_mb_addr)\n break;\n\n        ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs;\n        ps_dec->u4_num_mbs_cur_nmb = u1_num_mbs;\n\n        ps_cur_mb_info->u1_Mux = 0;\n        ps_dec->u4_num_pmbair = (u1_num_mbs >> u1_mbaff);\n        ps_cur_deblk_mb = ps_dec->ps_deblk_mbn + u1_num_mbs;\n\n        ps_cur_mb_info->u1_end_of_slice = 0;\n\n /* Storing Default partition info */\n        ps_parse_mb_data->u1_num_part = 1;\n        ps_parse_mb_data->u1_isI_mb = 0;\n\n /**************************************************************/\n /* Get the required information for decoding of MB            */\n /**************************************************************/\n /* mb_x, mb_y, neighbor availablity, */\n if (u1_mbaff)\n            ih264d_get_mb_info_cavlc_mbaff(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, i2_mb_skip_run);\n else\n            ih264d_get_mb_info_cavlc_nonmbaff(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, i2_mb_skip_run);\n\n /* Set the deblocking parameters for this MB */\n if(ps_dec->u4_app_disable_deblk_frm == 0)\n {\n            ih264d_set_deblocking_parameters(ps_cur_deblk_mb, ps_slice,\n                                             ps_dec->u1_mb_ngbr_availablity,\n                                             ps_dec->u1_cur_mb_fld_dec_flag);\n }\n\n /* Set appropriate flags in ps_cur_mb_info and ps_dec */\n        ps_dec->i1_prev_mb_qp_delta = 0;\n        ps_dec->u1_sub_mb_num = 0;\n        ps_cur_mb_info->u1_mb_type = MB_SKIP;\n        ps_cur_mb_info->u1_mb_mc_mode = PRED_16x16;\n        ps_cur_mb_info->u1_cbp = 0;\n\n /* Storing Skip partition info */\n        ps_part_info = ps_dec->ps_part;\n        ps_part_info->u1_is_direct = PART_DIRECT_16x16;\n        ps_part_info->u1_sub_mb_num = 0;\n        ps_dec->ps_part++;\n\n /* Update Nnzs */\n        ih264d_update_nnz_for_skipmb(ps_dec, ps_cur_mb_info, CAVLC);\n\n        ps_cur_mb_info->ps_curmb->u1_mb_type = u1_inter_mb_type;\n        ps_cur_deblk_mb->u1_mb_type |= u1_deblk_mb_type;\n\n        i2_mb_skip_run--;\n\n        ps_cur_deblk_mb->u1_mb_qp = ps_dec->u1_qp;\n\n if (u1_mbaff)\n {\n            ih264d_update_mbaff_left_nnz(ps_dec, ps_cur_mb_info);\n }\n\n /**************************************************************/\n /* Get next Macroblock address                                */\n /**************************************************************/\n        i2_cur_mb_addr++;\n\n        u1_num_mbs++;\n        u1_num_mbsNby2++;\n        ps_parse_mb_data++;\n\n /****************************************************************/\n /* Check for End Of Row and other flags that determine when to  */\n /* do DMA setup for N/2-Mb, Decode for N-Mb, and Transfer for   */\n /* N-Mb                                                         */\n /****************************************************************/\n        u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;\n        u1_end_of_row = (!u1_num_mbs_next) && (!(u1_mbaff && (u1_num_mbs & 0x01)));\n        u1_slice_end = !i2_mb_skip_run;\n        u1_tfr_n_mb = (u1_num_mbs == ps_dec->u1_recon_mb_grp) || u1_end_of_row\n || u1_slice_end;\n        u1_decode_nmb = u1_tfr_n_mb || u1_slice_end;\n        ps_cur_mb_info->u1_end_of_slice = u1_slice_end;\n\n if(u1_decode_nmb)\n {\n            ps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx, u1_num_mbs);\n            u1_num_mbsNby2 = 0;\n\n            ps_parse_mb_data = ps_dec->ps_parse_mb_data;\n            ps_dec->ps_part = ps_dec->ps_parse_part_params;\n\n if(ps_dec->u1_separate_parse)\n {\n                ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\n                                     u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);\n                ps_dec->ps_nmb_info +=  u1_num_mbs;\n }\n else\n {\n                ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs, u1_num_mbs_next,\n                                            u1_tfr_n_mb, u1_end_of_row);\n }\n            ps_dec->u2_total_mbs_coded += u1_num_mbs;\n if(u1_tfr_n_mb)\n                u1_num_mbs = 0;\n            u1_mb_idx = u1_num_mbs;\n            ps_dec->u1_mb_idx = u1_num_mbs;\n }\n }\n\n    ps_dec->u4_num_mbs_cur_nmb = 0;\n    ps_dec->ps_cur_slice->u4_mbs_in_slice = i2_cur_mb_addr\n - ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice;\n\n    H264_DEC_DEBUG_PRINT(\"Mbs in slice: %d\\n\", ps_dec->ps_cur_slice->u4_mbs_in_slice);\n\n\n /* incremented here only if first slice is inserted */\n if(ps_dec->u4_first_slice_in_pic != 0)\n {\n        ps_dec->ps_parse_cur_slice++;\n        ps_dec->u2_cur_slice_num++;\n }\n\n    ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;\n    ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;\n\n if(ps_dec->u2_total_mbs_coded\n >= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n {\n        ps_dec->u1_pic_decode_done = 1;\n }\n\n return 0;\n\n}\n",
    "cwe": [
      "CWE-200"
    ],
    "id": 468,
    "_valid_cwes": [
      "CWE-200"
    ]
  },
  {
    "cve_id": "CVE-2016-2460",
    "code_before_change": "status_t BnGraphicBufferProducer::onTransact(\n uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags)\n{\n switch(code) {\n case REQUEST_BUFFER: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n int bufferIdx   = data.readInt32();\n            sp<GraphicBuffer> buffer;\n int result = requestBuffer(bufferIdx, &buffer);\n            reply->writeInt32(buffer != 0);\n if (buffer != 0) {\n                reply->write(*buffer);\n }\n            reply->writeInt32(result);\n return NO_ERROR;\n }\n case SET_BUFFER_COUNT: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n int bufferCount = data.readInt32();\n int result = setBufferCount(bufferCount);\n            reply->writeInt32(result);\n return NO_ERROR;\n }\n case DEQUEUE_BUFFER: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n bool async = static_cast<bool>(data.readInt32());\n uint32_t width = data.readUint32();\n uint32_t height = data.readUint32();\n PixelFormat format = static_cast<PixelFormat>(data.readInt32());\n uint32_t usage = data.readUint32();\n int buf = 0;\n            sp<Fence> fence;\n int result = dequeueBuffer(&buf, &fence, async, width, height,\n                    format, usage);\n            reply->writeInt32(buf);\n            reply->writeInt32(fence != NULL);\n if (fence != NULL) {\n                reply->write(*fence);\n }\n            reply->writeInt32(result);\n return NO_ERROR;\n }\n case DETACH_BUFFER: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n int slot = data.readInt32();\n int result = detachBuffer(slot);\n            reply->writeInt32(result);\n return NO_ERROR;\n }\n case DETACH_NEXT_BUFFER: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n            sp<GraphicBuffer> buffer;\n            sp<Fence> fence;\n int32_t result = detachNextBuffer(&buffer, &fence);\n            reply->writeInt32(result);\n if (result == NO_ERROR) {\n                reply->writeInt32(buffer != NULL);\n if (buffer != NULL) {\n                    reply->write(*buffer);\n }\n                reply->writeInt32(fence != NULL);\n if (fence != NULL) {\n                    reply->write(*fence);\n }\n }\n return NO_ERROR;\n }\n case ATTACH_BUFFER: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n            sp<GraphicBuffer> buffer = new GraphicBuffer();\n            data.read(*buffer.get());\n int slot = 0;\n int result = attachBuffer(&slot, buffer);\n            reply->writeInt32(slot);\n            reply->writeInt32(result);\n return NO_ERROR;\n }\n case QUEUE_BUFFER: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n int buf = data.readInt32();\n QueueBufferInput input(data);\n QueueBufferOutput* const output =\n reinterpret_cast<QueueBufferOutput *>(\n                            reply->writeInplace(sizeof(QueueBufferOutput)));\n            memset(output, 0, sizeof(QueueBufferOutput));\n status_t result = queueBuffer(buf, input, output);\n            reply->writeInt32(result);\n return NO_ERROR;\n }\n case CANCEL_BUFFER: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n int buf = data.readInt32();\n            sp<Fence> fence = new Fence();\n            data.read(*fence.get());\n            cancelBuffer(buf, fence);\n return NO_ERROR;\n }\n case QUERY: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n int value = 0;\n int what = data.readInt32();\n int res = query(what, &value);\n            reply->writeInt32(value);\n            reply->writeInt32(res);\n return NO_ERROR;\n }\n case CONNECT: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n            sp<IProducerListener> listener;\n if (data.readInt32() == 1) {\n                listener = IProducerListener::asInterface(data.readStrongBinder());\n }\n int api = data.readInt32();\n bool producerControlledByApp = data.readInt32();\n\n             QueueBufferOutput* const output =\n                     reinterpret_cast<QueueBufferOutput *>(\n                             reply->writeInplace(sizeof(QueueBufferOutput)));\n             status_t res = connect(listener, api, producerControlledByApp, output);\n             reply->writeInt32(res);\n             return NO_ERROR;\n }\n case DISCONNECT: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n int api = data.readInt32();\n status_t res = disconnect(api);\n            reply->writeInt32(res);\n return NO_ERROR;\n }\n case SET_SIDEBAND_STREAM: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n            sp<NativeHandle> stream;\n if (data.readInt32()) {\n                stream = NativeHandle::create(data.readNativeHandle(), true);\n }\n status_t result = setSidebandStream(stream);\n            reply->writeInt32(result);\n return NO_ERROR;\n }\n case ALLOCATE_BUFFERS: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n bool async = static_cast<bool>(data.readInt32());\n uint32_t width = data.readUint32();\n uint32_t height = data.readUint32();\n PixelFormat format = static_cast<PixelFormat>(data.readInt32());\n uint32_t usage = data.readUint32();\n            allocateBuffers(async, width, height, format, usage);\n return NO_ERROR;\n }\n case ALLOW_ALLOCATION: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n bool allow = static_cast<bool>(data.readInt32());\n status_t result = allowAllocation(allow);\n            reply->writeInt32(result);\n return NO_ERROR;\n }\n case SET_GENERATION_NUMBER: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n uint32_t generationNumber = data.readUint32();\n status_t result = setGenerationNumber(generationNumber);\n            reply->writeInt32(result);\n return NO_ERROR;\n }\n case GET_CONSUMER_NAME: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n            reply->writeString8(getConsumerName());\n return NO_ERROR;\n }\n }\n return BBinder::onTransact(code, data, reply, flags);\n}\n",
    "code_after_change": "status_t BnGraphicBufferProducer::onTransact(\n uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags)\n{\n switch(code) {\n case REQUEST_BUFFER: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n int bufferIdx   = data.readInt32();\n            sp<GraphicBuffer> buffer;\n int result = requestBuffer(bufferIdx, &buffer);\n            reply->writeInt32(buffer != 0);\n if (buffer != 0) {\n                reply->write(*buffer);\n }\n            reply->writeInt32(result);\n return NO_ERROR;\n }\n case SET_BUFFER_COUNT: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n int bufferCount = data.readInt32();\n int result = setBufferCount(bufferCount);\n            reply->writeInt32(result);\n return NO_ERROR;\n }\n case DEQUEUE_BUFFER: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n bool async = static_cast<bool>(data.readInt32());\n uint32_t width = data.readUint32();\n uint32_t height = data.readUint32();\n PixelFormat format = static_cast<PixelFormat>(data.readInt32());\n uint32_t usage = data.readUint32();\n int buf = 0;\n            sp<Fence> fence;\n int result = dequeueBuffer(&buf, &fence, async, width, height,\n                    format, usage);\n            reply->writeInt32(buf);\n            reply->writeInt32(fence != NULL);\n if (fence != NULL) {\n                reply->write(*fence);\n }\n            reply->writeInt32(result);\n return NO_ERROR;\n }\n case DETACH_BUFFER: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n int slot = data.readInt32();\n int result = detachBuffer(slot);\n            reply->writeInt32(result);\n return NO_ERROR;\n }\n case DETACH_NEXT_BUFFER: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n            sp<GraphicBuffer> buffer;\n            sp<Fence> fence;\n int32_t result = detachNextBuffer(&buffer, &fence);\n            reply->writeInt32(result);\n if (result == NO_ERROR) {\n                reply->writeInt32(buffer != NULL);\n if (buffer != NULL) {\n                    reply->write(*buffer);\n }\n                reply->writeInt32(fence != NULL);\n if (fence != NULL) {\n                    reply->write(*fence);\n }\n }\n return NO_ERROR;\n }\n case ATTACH_BUFFER: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n            sp<GraphicBuffer> buffer = new GraphicBuffer();\n            data.read(*buffer.get());\n int slot = 0;\n int result = attachBuffer(&slot, buffer);\n            reply->writeInt32(slot);\n            reply->writeInt32(result);\n return NO_ERROR;\n }\n case QUEUE_BUFFER: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n int buf = data.readInt32();\n QueueBufferInput input(data);\n QueueBufferOutput* const output =\n reinterpret_cast<QueueBufferOutput *>(\n                            reply->writeInplace(sizeof(QueueBufferOutput)));\n            memset(output, 0, sizeof(QueueBufferOutput));\n status_t result = queueBuffer(buf, input, output);\n            reply->writeInt32(result);\n return NO_ERROR;\n }\n case CANCEL_BUFFER: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n int buf = data.readInt32();\n            sp<Fence> fence = new Fence();\n            data.read(*fence.get());\n            cancelBuffer(buf, fence);\n return NO_ERROR;\n }\n case QUERY: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n int value = 0;\n int what = data.readInt32();\n int res = query(what, &value);\n            reply->writeInt32(value);\n            reply->writeInt32(res);\n return NO_ERROR;\n }\n case CONNECT: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n            sp<IProducerListener> listener;\n if (data.readInt32() == 1) {\n                listener = IProducerListener::asInterface(data.readStrongBinder());\n }\n int api = data.readInt32();\n bool producerControlledByApp = data.readInt32();\n\n             QueueBufferOutput* const output =\n                     reinterpret_cast<QueueBufferOutput *>(\n                             reply->writeInplace(sizeof(QueueBufferOutput)));\n            memset(output, 0, sizeof(QueueBufferOutput));\n             status_t res = connect(listener, api, producerControlledByApp, output);\n             reply->writeInt32(res);\n             return NO_ERROR;\n }\n case DISCONNECT: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n int api = data.readInt32();\n status_t res = disconnect(api);\n            reply->writeInt32(res);\n return NO_ERROR;\n }\n case SET_SIDEBAND_STREAM: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n            sp<NativeHandle> stream;\n if (data.readInt32()) {\n                stream = NativeHandle::create(data.readNativeHandle(), true);\n }\n status_t result = setSidebandStream(stream);\n            reply->writeInt32(result);\n return NO_ERROR;\n }\n case ALLOCATE_BUFFERS: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n bool async = static_cast<bool>(data.readInt32());\n uint32_t width = data.readUint32();\n uint32_t height = data.readUint32();\n PixelFormat format = static_cast<PixelFormat>(data.readInt32());\n uint32_t usage = data.readUint32();\n            allocateBuffers(async, width, height, format, usage);\n return NO_ERROR;\n }\n case ALLOW_ALLOCATION: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n bool allow = static_cast<bool>(data.readInt32());\n status_t result = allowAllocation(allow);\n            reply->writeInt32(result);\n return NO_ERROR;\n }\n case SET_GENERATION_NUMBER: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n uint32_t generationNumber = data.readUint32();\n status_t result = setGenerationNumber(generationNumber);\n            reply->writeInt32(result);\n return NO_ERROR;\n }\n case GET_CONSUMER_NAME: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n            reply->writeString8(getConsumerName());\n return NO_ERROR;\n }\n }\n return BBinder::onTransact(code, data, reply, flags);\n}\n",
    "cwe": [
      "CWE-200"
    ],
    "id": 470,
    "_valid_cwes": [
      "CWE-200"
    ]
  },
  {
    "cve_id": "CVE-2013-2061",
    "code_before_change": "openvpn_decrypt (struct buffer *buf, struct buffer work,\n\t\t const struct crypto_options *opt,\n\t\t const struct frame* frame)\n{\n  static const char error_prefix[] = \"Authenticate/Decrypt packet error\";\n  struct gc_arena gc;\n  gc_init (&gc);\n\n  if (buf->len > 0 && opt->key_ctx_bi)\n    {\n      struct key_ctx *ctx = &opt->key_ctx_bi->decrypt;\n      struct packet_id_net pin;\n      bool have_pin = false;\n\n      /* Verify the HMAC */\n      if (ctx->hmac)\n\t{\n\t  int hmac_len;\n\t  uint8_t local_hmac[MAX_HMAC_KEY_LENGTH]; /* HMAC of ciphertext computed locally */\n\n\t  hmac_ctx_reset(ctx->hmac);\n\n\t  /* Assume the length of the input HMAC */\n\t  hmac_len = hmac_ctx_size (ctx->hmac);\n\n\t  /* Authentication fails if insufficient data in packet for HMAC */\n\t  if (buf->len < hmac_len)\n\t    CRYPT_ERROR (\"missing authentication info\");\n\n\t  hmac_ctx_update (ctx->hmac, BPTR (buf) + hmac_len, BLEN (buf) - hmac_len);\n \t  hmac_ctx_final (ctx->hmac, local_hmac);\n \n \t  /* Compare locally computed HMAC with packet HMAC */\n\t  if (memcmp (local_hmac, BPTR (buf), hmac_len))\n \t    CRYPT_ERROR (\"packet HMAC authentication failed\");\n \n \t  ASSERT (buf_advance (buf, hmac_len));\n\t}\n\n      /* Decrypt packet ID + payload */\n\n      if (ctx->cipher)\n\t{\n\t  const unsigned int mode = cipher_ctx_mode (ctx->cipher);\n\t  const int iv_size = cipher_ctx_iv_length (ctx->cipher);\n\t  uint8_t iv_buf[OPENVPN_MAX_IV_LENGTH];\n\t  int outlen;\n\n\t  /* initialize work buffer with FRAME_HEADROOM bytes of prepend capacity */\n\t  ASSERT (buf_init (&work, FRAME_HEADROOM_ADJ (frame, FRAME_HEADROOM_MARKER_DECRYPT)));\n\n\t  /* use IV if user requested it */\n\t  CLEAR (iv_buf);\n\t  if (opt->flags & CO_USE_IV)\n\t    {\n\t      if (buf->len < iv_size)\n\t\tCRYPT_ERROR (\"missing IV info\");\n\t      memcpy (iv_buf, BPTR (buf), iv_size);\n\t      ASSERT (buf_advance (buf, iv_size));\n\t    }\n\n\t  /* show the IV's initial state */\n\t  if (opt->flags & CO_USE_IV)\n\t    dmsg (D_PACKET_CONTENT, \"DECRYPT IV: %s\", format_hex (iv_buf, iv_size, 0, &gc));\n\n\t  if (buf->len < 1)\n\t    CRYPT_ERROR (\"missing payload\");\n\n\t  /* ctx->cipher was already initialized with key & keylen */\n\t  if (!cipher_ctx_reset (ctx->cipher, iv_buf))\n\t    CRYPT_ERROR (\"cipher init failed\");\n\n\t  /* Buffer overflow check (should never happen) */\n\t  if (!buf_safe (&work, buf->len))\n\t    CRYPT_ERROR (\"buffer overflow\");\n\n\t  /* Decrypt packet ID, payload */\n\t  if (!cipher_ctx_update (ctx->cipher, BPTR (&work), &outlen, BPTR (buf), BLEN (buf)))\n\t    CRYPT_ERROR (\"cipher update failed\");\n\t  work.len += outlen;\n\n\t  /* Flush the decryption buffer */\n\t  if (!cipher_ctx_final (ctx->cipher, BPTR (&work) + outlen, &outlen))\n\t    CRYPT_ERROR (\"cipher final failed\");\n\t  work.len += outlen;\n\n\t  dmsg (D_PACKET_CONTENT, \"DECRYPT TO: %s\",\n\t       format_hex (BPTR (&work), BLEN (&work), 80, &gc));\n\n\t  /* Get packet ID from plaintext buffer or IV, depending on cipher mode */\n\t  {\n\t    if (mode == OPENVPN_MODE_CBC)\n\t      {\n\t\tif (opt->packet_id)\n\t\t  {\n\t\t    if (!packet_id_read (&pin, &work, BOOL_CAST (opt->flags & CO_PACKET_ID_LONG_FORM)))\n\t\t      CRYPT_ERROR (\"error reading CBC packet-id\");\n\t\t    have_pin = true;\n\t\t  }\n\t      }\n\t    else if (mode == OPENVPN_MODE_CFB || mode == OPENVPN_MODE_OFB)\n\t      {\n\t\tstruct buffer b;\n\n\t\tASSERT (opt->flags & CO_USE_IV);    /* IV and packet-ID required */\n\t\tASSERT (opt->packet_id); /*  for this mode. */\n\n\t\tbuf_set_read (&b, iv_buf, iv_size);\n\t\tif (!packet_id_read (&pin, &b, true))\n\t\t  CRYPT_ERROR (\"error reading CFB/OFB packet-id\");\n\t\thave_pin = true;\n\t      }\n\t    else /* We only support CBC, CFB, or OFB modes right now */\n\t      {\n\t\tASSERT (0);\n\t      }\n\t  }\n\t}\n      else\n\t{\n\t  work = *buf;\n\t  if (opt->packet_id)\n\t    {\n\t      if (!packet_id_read (&pin, &work, BOOL_CAST (opt->flags & CO_PACKET_ID_LONG_FORM)))\n\t\tCRYPT_ERROR (\"error reading packet-id\");\n\t      have_pin = !BOOL_CAST (opt->flags & CO_IGNORE_PACKET_ID);\n\t    }\n\t}\n      \n      if (have_pin)\n\t{\n\t  packet_id_reap_test (&opt->packet_id->rec);\n\t  if (packet_id_test (&opt->packet_id->rec, &pin))\n\t    {\n\t      packet_id_add (&opt->packet_id->rec, &pin);\n\t      if (opt->pid_persist && (opt->flags & CO_PACKET_ID_LONG_FORM))\n\t\tpacket_id_persist_save_obj (opt->pid_persist, opt->packet_id);\n\t    }\n\t  else\n\t    {\n\t      if (!(opt->flags & CO_MUTE_REPLAY_WARNINGS))\n\t      msg (D_REPLAY_ERRORS, \"%s: bad packet ID (may be a replay): %s -- see the man page entry for --no-replay and --replay-window for more info or silence this warning with --mute-replay-warnings\",\n\t\t   error_prefix, packet_id_net_print (&pin, true, &gc));\n\t      goto error_exit;\n\t    }\n\t}\n      *buf = work;\n    }\n\n  gc_free (&gc);\n  return true;\n\n error_exit:\n  crypto_clear_error();\n  buf->len = 0;\n  gc_free (&gc);\n  return false;\n}\n",
    "code_after_change": "openvpn_decrypt (struct buffer *buf, struct buffer work,\n\t\t const struct crypto_options *opt,\n\t\t const struct frame* frame)\n{\n  static const char error_prefix[] = \"Authenticate/Decrypt packet error\";\n  struct gc_arena gc;\n  gc_init (&gc);\n\n  if (buf->len > 0 && opt->key_ctx_bi)\n    {\n      struct key_ctx *ctx = &opt->key_ctx_bi->decrypt;\n      struct packet_id_net pin;\n      bool have_pin = false;\n\n      /* Verify the HMAC */\n      if (ctx->hmac)\n\t{\n\t  int hmac_len;\n\t  uint8_t local_hmac[MAX_HMAC_KEY_LENGTH]; /* HMAC of ciphertext computed locally */\n\n\t  hmac_ctx_reset(ctx->hmac);\n\n\t  /* Assume the length of the input HMAC */\n\t  hmac_len = hmac_ctx_size (ctx->hmac);\n\n\t  /* Authentication fails if insufficient data in packet for HMAC */\n\t  if (buf->len < hmac_len)\n\t    CRYPT_ERROR (\"missing authentication info\");\n\n\t  hmac_ctx_update (ctx->hmac, BPTR (buf) + hmac_len, BLEN (buf) - hmac_len);\n \t  hmac_ctx_final (ctx->hmac, local_hmac);\n \n \t  /* Compare locally computed HMAC with packet HMAC */\n\t  if (memcmp_constant_time (local_hmac, BPTR (buf), hmac_len))\n \t    CRYPT_ERROR (\"packet HMAC authentication failed\");\n \n \t  ASSERT (buf_advance (buf, hmac_len));\n\t}\n\n      /* Decrypt packet ID + payload */\n\n      if (ctx->cipher)\n\t{\n\t  const unsigned int mode = cipher_ctx_mode (ctx->cipher);\n\t  const int iv_size = cipher_ctx_iv_length (ctx->cipher);\n\t  uint8_t iv_buf[OPENVPN_MAX_IV_LENGTH];\n\t  int outlen;\n\n\t  /* initialize work buffer with FRAME_HEADROOM bytes of prepend capacity */\n\t  ASSERT (buf_init (&work, FRAME_HEADROOM_ADJ (frame, FRAME_HEADROOM_MARKER_DECRYPT)));\n\n\t  /* use IV if user requested it */\n\t  CLEAR (iv_buf);\n\t  if (opt->flags & CO_USE_IV)\n\t    {\n\t      if (buf->len < iv_size)\n\t\tCRYPT_ERROR (\"missing IV info\");\n\t      memcpy (iv_buf, BPTR (buf), iv_size);\n\t      ASSERT (buf_advance (buf, iv_size));\n\t    }\n\n\t  /* show the IV's initial state */\n\t  if (opt->flags & CO_USE_IV)\n\t    dmsg (D_PACKET_CONTENT, \"DECRYPT IV: %s\", format_hex (iv_buf, iv_size, 0, &gc));\n\n\t  if (buf->len < 1)\n\t    CRYPT_ERROR (\"missing payload\");\n\n\t  /* ctx->cipher was already initialized with key & keylen */\n\t  if (!cipher_ctx_reset (ctx->cipher, iv_buf))\n\t    CRYPT_ERROR (\"cipher init failed\");\n\n\t  /* Buffer overflow check (should never happen) */\n\t  if (!buf_safe (&work, buf->len))\n\t    CRYPT_ERROR (\"buffer overflow\");\n\n\t  /* Decrypt packet ID, payload */\n\t  if (!cipher_ctx_update (ctx->cipher, BPTR (&work), &outlen, BPTR (buf), BLEN (buf)))\n\t    CRYPT_ERROR (\"cipher update failed\");\n\t  work.len += outlen;\n\n\t  /* Flush the decryption buffer */\n\t  if (!cipher_ctx_final (ctx->cipher, BPTR (&work) + outlen, &outlen))\n\t    CRYPT_ERROR (\"cipher final failed\");\n\t  work.len += outlen;\n\n\t  dmsg (D_PACKET_CONTENT, \"DECRYPT TO: %s\",\n\t       format_hex (BPTR (&work), BLEN (&work), 80, &gc));\n\n\t  /* Get packet ID from plaintext buffer or IV, depending on cipher mode */\n\t  {\n\t    if (mode == OPENVPN_MODE_CBC)\n\t      {\n\t\tif (opt->packet_id)\n\t\t  {\n\t\t    if (!packet_id_read (&pin, &work, BOOL_CAST (opt->flags & CO_PACKET_ID_LONG_FORM)))\n\t\t      CRYPT_ERROR (\"error reading CBC packet-id\");\n\t\t    have_pin = true;\n\t\t  }\n\t      }\n\t    else if (mode == OPENVPN_MODE_CFB || mode == OPENVPN_MODE_OFB)\n\t      {\n\t\tstruct buffer b;\n\n\t\tASSERT (opt->flags & CO_USE_IV);    /* IV and packet-ID required */\n\t\tASSERT (opt->packet_id); /*  for this mode. */\n\n\t\tbuf_set_read (&b, iv_buf, iv_size);\n\t\tif (!packet_id_read (&pin, &b, true))\n\t\t  CRYPT_ERROR (\"error reading CFB/OFB packet-id\");\n\t\thave_pin = true;\n\t      }\n\t    else /* We only support CBC, CFB, or OFB modes right now */\n\t      {\n\t\tASSERT (0);\n\t      }\n\t  }\n\t}\n      else\n\t{\n\t  work = *buf;\n\t  if (opt->packet_id)\n\t    {\n\t      if (!packet_id_read (&pin, &work, BOOL_CAST (opt->flags & CO_PACKET_ID_LONG_FORM)))\n\t\tCRYPT_ERROR (\"error reading packet-id\");\n\t      have_pin = !BOOL_CAST (opt->flags & CO_IGNORE_PACKET_ID);\n\t    }\n\t}\n      \n      if (have_pin)\n\t{\n\t  packet_id_reap_test (&opt->packet_id->rec);\n\t  if (packet_id_test (&opt->packet_id->rec, &pin))\n\t    {\n\t      packet_id_add (&opt->packet_id->rec, &pin);\n\t      if (opt->pid_persist && (opt->flags & CO_PACKET_ID_LONG_FORM))\n\t\tpacket_id_persist_save_obj (opt->pid_persist, opt->packet_id);\n\t    }\n\t  else\n\t    {\n\t      if (!(opt->flags & CO_MUTE_REPLAY_WARNINGS))\n\t      msg (D_REPLAY_ERRORS, \"%s: bad packet ID (may be a replay): %s -- see the man page entry for --no-replay and --replay-window for more info or silence this warning with --mute-replay-warnings\",\n\t\t   error_prefix, packet_id_net_print (&pin, true, &gc));\n\t      goto error_exit;\n\t    }\n\t}\n      *buf = work;\n    }\n\n  gc_free (&gc);\n  return true;\n\n error_exit:\n  crypto_clear_error();\n  buf->len = 0;\n  gc_free (&gc);\n  return false;\n}\n",
    "cwe": [
      "CWE-200"
    ],
    "id": 507,
    "_valid_cwes": [
      "CWE-200"
    ]
  },
  {
    "cve_id": "CVE-2017-0816",
    "code_before_change": "int Reverb_setParameter (ReverbContext *pContext, void *pParam, void *pValue){\n     int status = 0;\n     int16_t level;\n     int16_t ratio;\n uint32_t time;\n    t_reverb_settings *pProperties;\n int32_t *pParamTemp = (int32_t *)pParam;\n int32_t param = *pParamTemp++;\n\n if (pContext->preset) {\n if (param != REVERB_PARAM_PRESET) {\n return -EINVAL;\n }\n\n uint16_t preset = *(uint16_t *)pValue;\n        ALOGV(\"set REVERB_PARAM_PRESET, preset %d\", preset);\n if (preset > REVERB_PRESET_LAST) {\n return -EINVAL;\n }\n        pContext->nextPreset = preset;\n\n         return 0;\n     }\n \n     switch (param){\n         case REVERB_PARAM_PROPERTIES:\n             ALOGV(\"\\tReverb_setParameter() REVERB_PARAM_PROPERTIES\");\n            pProperties = (t_reverb_settings *) pValue;\n ReverbSetRoomLevel(pContext, pProperties->roomLevel);\n ReverbSetRoomHfLevel(pContext, pProperties->roomHFLevel);\n ReverbSetDecayTime(pContext, pProperties->decayTime);\n ReverbSetDecayHfRatio(pContext, pProperties->decayHFRatio);\n ReverbSetReverbLevel(pContext, pProperties->reverbLevel);\n ReverbSetDiffusion(pContext, pProperties->diffusion);\n ReverbSetDensity(pContext, pProperties->density);\n break;\n case REVERB_PARAM_ROOM_LEVEL:\n            level = *(int16_t *)pValue;\n ReverbSetRoomLevel(pContext, level);\n break;\n case REVERB_PARAM_ROOM_HF_LEVEL:\n            level = *(int16_t *)pValue;\n ReverbSetRoomHfLevel(pContext, level);\n break;\n case REVERB_PARAM_DECAY_TIME:\n            time = *(uint32_t *)pValue;\n ReverbSetDecayTime(pContext, time);\n break;\n case REVERB_PARAM_DECAY_HF_RATIO:\n            ratio = *(int16_t *)pValue;\n ReverbSetDecayHfRatio(pContext, ratio);\n break;\n case REVERB_PARAM_REVERB_LEVEL:\n            level = *(int16_t *)pValue;\n ReverbSetReverbLevel(pContext, level);\n break;\n case REVERB_PARAM_DIFFUSION:\n            ratio = *(int16_t *)pValue;\n ReverbSetDiffusion(pContext, ratio);\n break;\n case REVERB_PARAM_DENSITY:\n            ratio = *(int16_t *)pValue;\n ReverbSetDensity(pContext, ratio);\n break;\n break;\n case REVERB_PARAM_REFLECTIONS_LEVEL:\n case REVERB_PARAM_REFLECTIONS_DELAY:\n case REVERB_PARAM_REVERB_DELAY:\n break;\n default:\n            ALOGV(\"\\tLVM_ERROR : Reverb_setParameter() invalid param %d\", param);\n break;\n }\n\n\n     return status;\n } /* end Reverb_setParameter */\n",
    "code_after_change": "int Reverb_setParameter (ReverbContext *pContext, void *pParam, void *pValue){\nint Reverb_setParameter (ReverbContext *pContext, void *pParam, void *pValue, int vsize){\n     int status = 0;\n     int16_t level;\n     int16_t ratio;\n uint32_t time;\n    t_reverb_settings *pProperties;\n int32_t *pParamTemp = (int32_t *)pParam;\n int32_t param = *pParamTemp++;\n\n if (pContext->preset) {\n if (param != REVERB_PARAM_PRESET) {\n return -EINVAL;\n }\n\n uint16_t preset = *(uint16_t *)pValue;\n        ALOGV(\"set REVERB_PARAM_PRESET, preset %d\", preset);\n if (preset > REVERB_PRESET_LAST) {\n return -EINVAL;\n }\n        pContext->nextPreset = preset;\n\n         return 0;\n     }\n \n    if (vsize < Reverb_paramValueSize(param)) {\n        android_errorWriteLog(0x534e4554, \"63526567\");\n        return -EINVAL;\n    }\n\n     switch (param){\n         case REVERB_PARAM_PROPERTIES:\n             ALOGV(\"\\tReverb_setParameter() REVERB_PARAM_PROPERTIES\");\n            pProperties = (t_reverb_settings *) pValue;\n ReverbSetRoomLevel(pContext, pProperties->roomLevel);\n ReverbSetRoomHfLevel(pContext, pProperties->roomHFLevel);\n ReverbSetDecayTime(pContext, pProperties->decayTime);\n ReverbSetDecayHfRatio(pContext, pProperties->decayHFRatio);\n ReverbSetReverbLevel(pContext, pProperties->reverbLevel);\n ReverbSetDiffusion(pContext, pProperties->diffusion);\n ReverbSetDensity(pContext, pProperties->density);\n break;\n case REVERB_PARAM_ROOM_LEVEL:\n            level = *(int16_t *)pValue;\n ReverbSetRoomLevel(pContext, level);\n break;\n case REVERB_PARAM_ROOM_HF_LEVEL:\n            level = *(int16_t *)pValue;\n ReverbSetRoomHfLevel(pContext, level);\n break;\n case REVERB_PARAM_DECAY_TIME:\n            time = *(uint32_t *)pValue;\n ReverbSetDecayTime(pContext, time);\n break;\n case REVERB_PARAM_DECAY_HF_RATIO:\n            ratio = *(int16_t *)pValue;\n ReverbSetDecayHfRatio(pContext, ratio);\n break;\n case REVERB_PARAM_REVERB_LEVEL:\n            level = *(int16_t *)pValue;\n ReverbSetReverbLevel(pContext, level);\n break;\n case REVERB_PARAM_DIFFUSION:\n            ratio = *(int16_t *)pValue;\n ReverbSetDiffusion(pContext, ratio);\n break;\n case REVERB_PARAM_DENSITY:\n            ratio = *(int16_t *)pValue;\n ReverbSetDensity(pContext, ratio);\n break;\n break;\n case REVERB_PARAM_REFLECTIONS_LEVEL:\n case REVERB_PARAM_REFLECTIONS_DELAY:\n case REVERB_PARAM_REVERB_DELAY:\n break;\n default:\n            ALOGV(\"\\tLVM_ERROR : Reverb_setParameter() invalid param %d\", param);\n break;\n }\n\n\n     return status;\n } /* end Reverb_setParameter */\n",
    "cwe": [
      "CWE-200"
    ],
    "id": 557,
    "_valid_cwes": [
      "CWE-200"
    ]
  },
  {
    "cve_id": "CVE-2019-5837",
    "code_before_change": " int64_t AppCacheDatabase::GetOriginUsage(const url::Origin& origin) {\n  std::vector<CacheRecord> records;\n  if (!FindCachesForOrigin(origin, &records))\n     return 0;\n \n   int64_t origin_usage = 0;\n  for (const auto& record : records)\n    origin_usage += record.cache_size;\n   return origin_usage;\n }\n",
    "code_after_change": " int64_t AppCacheDatabase::GetOriginUsage(const url::Origin& origin) {\n  std::vector<CacheRecord> caches;\n  if (!FindCachesForOrigin(origin, &caches))\n     return 0;\n \n   int64_t origin_usage = 0;\n  for (const auto& cache : caches)\n    origin_usage += cache.cache_size + cache.padding_size;\n   return origin_usage;\n }\n",
    "cwe": [
      "CWE-200"
    ],
    "id": 596,
    "_valid_cwes": [
      "CWE-200"
    ]
  },
  {
    "cve_id": "CVE-2017-5107",
    "code_before_change": " void LockScreenMediaControlsView::OnMouseExited(const ui::MouseEvent& event) {\n   if (is_in_drag_ || contents_view_->layer()->GetAnimator()->is_animating())\n     return;\n \n  close_button_->SetVisible(false);\n }\n",
    "code_after_change": " void LockScreenMediaControlsView::OnMouseExited(const ui::MouseEvent& event) {\n   if (is_in_drag_ || contents_view_->layer()->GetAnimator()->is_animating())\n     return;\n \n  header_row_->SetCloseButtonVisibility(false);\n }\n",
    "cwe": [
      "CWE-200"
    ],
    "id": 614,
    "_valid_cwes": [
      "CWE-200"
    ]
  },
  {
    "cve_id": "CVE-2019-5837",
    "code_before_change": "void AppCache::InitializeWithDatabaseRecords(\n    const AppCacheDatabase::CacheRecord& cache_record,\n    const std::vector<AppCacheDatabase::EntryRecord>& entries,\n     const std::vector<AppCacheDatabase::NamespaceRecord>& intercepts,\n     const std::vector<AppCacheDatabase::NamespaceRecord>& fallbacks,\n     const std::vector<AppCacheDatabase::OnlineWhiteListRecord>& whitelists) {\n  DCHECK(cache_id_ == cache_record.cache_id);\n   online_whitelist_all_ = cache_record.online_wildcard;\n   update_time_ = cache_record.update_time;\n \n   for (size_t i = 0; i < entries.size(); ++i) {\n     const AppCacheDatabase::EntryRecord& entry = entries.at(i);\n     AddEntry(entry.url, AppCacheEntry(entry.flags, entry.response_id,\n                                      entry.response_size));\n   }\n  DCHECK(cache_size_ == cache_record.cache_size);\n \n   for (size_t i = 0; i < intercepts.size(); ++i)\n     intercept_namespaces_.push_back(intercepts.at(i).namespace_);\n\n  for (size_t i = 0; i < fallbacks.size(); ++i)\n    fallback_namespaces_.push_back(fallbacks.at(i).namespace_);\n\n  std::sort(intercept_namespaces_.begin(), intercept_namespaces_.end(),\n            SortNamespacesByLength);\n  std::sort(fallback_namespaces_.begin(), fallback_namespaces_.end(),\n            SortNamespacesByLength);\n\n  for (size_t i = 0; i < whitelists.size(); ++i) {\n    const AppCacheDatabase::OnlineWhiteListRecord& record = whitelists.at(i);\n    online_whitelist_namespaces_.push_back(\n        AppCacheNamespace(APPCACHE_NETWORK_NAMESPACE,\n                  record.namespace_url,\n                  GURL(),\n                  record.is_pattern));\n  }\n}\n",
    "code_after_change": "void AppCache::InitializeWithDatabaseRecords(\n    const AppCacheDatabase::CacheRecord& cache_record,\n    const std::vector<AppCacheDatabase::EntryRecord>& entries,\n     const std::vector<AppCacheDatabase::NamespaceRecord>& intercepts,\n     const std::vector<AppCacheDatabase::NamespaceRecord>& fallbacks,\n     const std::vector<AppCacheDatabase::OnlineWhiteListRecord>& whitelists) {\n  DCHECK_EQ(cache_id_, cache_record.cache_id);\n   online_whitelist_all_ = cache_record.online_wildcard;\n   update_time_ = cache_record.update_time;\n \n   for (size_t i = 0; i < entries.size(); ++i) {\n     const AppCacheDatabase::EntryRecord& entry = entries.at(i);\n     AddEntry(entry.url, AppCacheEntry(entry.flags, entry.response_id,\n                                      entry.response_size, entry.padding_size));\n   }\n  DCHECK_EQ(cache_size_, cache_record.cache_size);\n  DCHECK_EQ(padding_size_, cache_record.padding_size);\n \n   for (size_t i = 0; i < intercepts.size(); ++i)\n     intercept_namespaces_.push_back(intercepts.at(i).namespace_);\n\n  for (size_t i = 0; i < fallbacks.size(); ++i)\n    fallback_namespaces_.push_back(fallbacks.at(i).namespace_);\n\n  std::sort(intercept_namespaces_.begin(), intercept_namespaces_.end(),\n            SortNamespacesByLength);\n  std::sort(fallback_namespaces_.begin(), fallback_namespaces_.end(),\n            SortNamespacesByLength);\n\n  for (size_t i = 0; i < whitelists.size(); ++i) {\n    const AppCacheDatabase::OnlineWhiteListRecord& record = whitelists.at(i);\n    online_whitelist_namespaces_.push_back(\n        AppCacheNamespace(APPCACHE_NETWORK_NAMESPACE,\n                  record.namespace_url,\n                  GURL(),\n                  record.is_pattern));\n  }\n}\n",
    "cwe": [
      "CWE-200"
    ],
    "id": 659,
    "_valid_cwes": [
      "CWE-200"
    ]
  },
  {
    "cve_id": "CVE-2012-2891",
    "code_before_change": "void CreatePrintSettingsDictionary(DictionaryValue* dict) {\n  dict->SetBoolean(printing::kSettingLandscape, false);\n  dict->SetBoolean(printing::kSettingCollate, false);\n  dict->SetInteger(printing::kSettingColor, printing::GRAY);\n  dict->SetBoolean(printing::kSettingPrintToPDF, true);\n   dict->SetInteger(printing::kSettingDuplexMode, printing::SIMPLEX);\n   dict->SetInteger(printing::kSettingCopies, 1);\n   dict->SetString(printing::kSettingDeviceName, \"dummy\");\n  dict->SetString(printing::kPreviewUIAddr, \"0xb33fbeef\");\n   dict->SetInteger(printing::kPreviewRequestID, 12345);\n   dict->SetBoolean(printing::kIsFirstRequest, true);\n   dict->SetInteger(printing::kSettingMarginsType, printing::DEFAULT_MARGINS);\n  dict->SetBoolean(printing::kSettingPreviewModifiable, false);\n  dict->SetBoolean(printing::kSettingHeaderFooterEnabled, false);\n  dict->SetBoolean(printing::kSettingGenerateDraftData, true);\n}\n",
    "code_after_change": "void CreatePrintSettingsDictionary(DictionaryValue* dict) {\n  dict->SetBoolean(printing::kSettingLandscape, false);\n  dict->SetBoolean(printing::kSettingCollate, false);\n  dict->SetInteger(printing::kSettingColor, printing::GRAY);\n  dict->SetBoolean(printing::kSettingPrintToPDF, true);\n   dict->SetInteger(printing::kSettingDuplexMode, printing::SIMPLEX);\n   dict->SetInteger(printing::kSettingCopies, 1);\n   dict->SetString(printing::kSettingDeviceName, \"dummy\");\n  dict->SetInteger(printing::kPreviewUIID, 4);\n   dict->SetInteger(printing::kPreviewRequestID, 12345);\n   dict->SetBoolean(printing::kIsFirstRequest, true);\n   dict->SetInteger(printing::kSettingMarginsType, printing::DEFAULT_MARGINS);\n  dict->SetBoolean(printing::kSettingPreviewModifiable, false);\n  dict->SetBoolean(printing::kSettingHeaderFooterEnabled, false);\n  dict->SetBoolean(printing::kSettingGenerateDraftData, true);\n}\n",
    "cwe": [
      "CWE-200"
    ],
    "id": 705,
    "_valid_cwes": [
      "CWE-200"
    ]
  },
  {
    "cve_id": "CVE-2016-6720",
    "code_before_change": "    BufferMeta(const sp<IMemory> &mem, OMX_U32 portIndex, bool is_backup = false)\n         : mMem(mem),\n          mIsBackup(is_backup),\n          mPortIndex(portIndex) {\n     }\n",
    "code_after_change": "    BufferMeta(const sp<IMemory> &mem, OMX_U32 portIndex, bool is_backup = false)\n    BufferMeta(\n            const sp<IMemory> &mem, OMX_U32 portIndex, bool copyToOmx,\n            bool copyFromOmx, OMX_U8 *backup)\n         : mMem(mem),\n          mCopyFromOmx(copyFromOmx),\n          mCopyToOmx(copyToOmx),\n          mPortIndex(portIndex),\n          mBackup(backup) {\n     }\n",
    "cwe": [
      "CWE-200"
    ],
    "id": 751,
    "_valid_cwes": [
      "CWE-200"
    ]
  },
  {
    "cve_id": "CVE-2019-10638",
    "code_before_change": " static void ipv6_select_ident(struct frag_hdr *fhdr, struct rt6_info *rt)\n {\n \tstatic u32 ip6_idents_hashrnd __read_mostly;\n \tu32 hash, id;\n \n \tnet_get_random_once(&ip6_idents_hashrnd, sizeof(ip6_idents_hashrnd));\n \n \thash = __ipv6_addr_jhash(&rt->rt6i_dst.addr, ip6_idents_hashrnd);\n \thash = __ipv6_addr_jhash(&rt->rt6i_src.addr, hash);\n \n \tid = ip_idents_reserve(hash, 1);\n \tfhdr->identification = htonl(id);\n}\n",
    "code_after_change": " static void ipv6_select_ident(struct frag_hdr *fhdr, struct rt6_info *rt)\n {\n \tstatic u32 ip6_idents_hashrnd __read_mostly;\n\tstatic u32 ip6_idents_hashrnd_extra __read_mostly;\n \tu32 hash, id;\n \n \tnet_get_random_once(&ip6_idents_hashrnd, sizeof(ip6_idents_hashrnd));\n\tnet_get_random_once(&ip6_idents_hashrnd_extra, sizeof(ip6_idents_hashrnd_extra));\n \n \thash = __ipv6_addr_jhash(&rt->rt6i_dst.addr, ip6_idents_hashrnd);\n \thash = __ipv6_addr_jhash(&rt->rt6i_src.addr, hash);\n\thash = jhash_1word(hash, ip6_idents_hashrnd_extra);\n \n \tid = ip_idents_reserve(hash, 1);\n \tfhdr->identification = htonl(id);\n}\n",
    "cwe": [
      "CWE-200"
    ],
    "id": 776,
    "_valid_cwes": [
      "CWE-200"
    ]
  },
  {
    "cve_id": "CVE-2015-1285",
    "code_before_change": "void WallpaperManagerBase::LoadWallpaper(\n    const AccountId& account_id,\n    const WallpaperInfo& info,\n    bool update_wallpaper,\n    MovableOnDestroyCallbackHolder on_finish) {\n  base::FilePath wallpaper_dir;\n  base::FilePath wallpaper_path;\n\n  if (info.type == ONLINE || info.type == DEFAULT) {\n    if (info.location.empty()) {\n      if (base::SysInfo::IsRunningOnChromeOS()) {\n        NOTREACHED() << \"User wallpaper info appears to be broken: \"\n                     << account_id.Serialize();\n      } else {\n        LOG(WARNING) << \"User wallpaper info is empty: \"\n                     << account_id.Serialize();\n\n        return;\n      }\n    }\n  }\n\n  if (info.type == ONLINE) {\n    std::string file_name = GURL(info.location).ExtractFileName();\n    WallpaperResolution resolution = GetAppropriateResolution();\n    if (info.layout != WALLPAPER_LAYOUT_STRETCH &&\n        resolution == WALLPAPER_RESOLUTION_SMALL) {\n      file_name = base::FilePath(file_name)\n                      .InsertBeforeExtension(kSmallWallpaperSuffix)\n                      .value();\n    }\n    DCHECK(dir_chromeos_wallpapers_path_id != -1);\n    CHECK(PathService::Get(dir_chromeos_wallpapers_path_id,\n                           &wallpaper_dir));\n    wallpaper_path = wallpaper_dir.Append(file_name);\n\n    CustomWallpaperMap::iterator it = wallpaper_cache_.find(account_id);\n    if (it != wallpaper_cache_.end() &&\n        it->second.first == wallpaper_path &&\n        !it->second.second.isNull())\n      return;\n\n    loaded_wallpapers_for_test_++;\n    StartLoad(account_id, info, update_wallpaper, wallpaper_path,\n              std::move(on_finish));\n  } else if (info.type == DEFAULT) {\n    base::FilePath user_data_dir;\n    DCHECK(dir_user_data_path_id != -1);\n    PathService::Get(dir_user_data_path_id, &user_data_dir);\n    wallpaper_path = user_data_dir.Append(info.location);\n    StartLoad(account_id, info, update_wallpaper, wallpaper_path,\n              std::move(on_finish));\n  } else {\n     LOG(ERROR) << \"Wallpaper reverts to default unexpected.\";\n    DoSetDefaultWallpaper(account_id, std::move(on_finish));\n   }\n }\n",
    "code_after_change": "void WallpaperManagerBase::LoadWallpaper(\n    const AccountId& account_id,\n    const WallpaperInfo& info,\n    bool update_wallpaper,\n    MovableOnDestroyCallbackHolder on_finish) {\n  base::FilePath wallpaper_dir;\n  base::FilePath wallpaper_path;\n\n  if (info.type == ONLINE || info.type == DEFAULT) {\n    if (info.location.empty()) {\n      if (base::SysInfo::IsRunningOnChromeOS()) {\n        NOTREACHED() << \"User wallpaper info appears to be broken: \"\n                     << account_id.Serialize();\n      } else {\n        LOG(WARNING) << \"User wallpaper info is empty: \"\n                     << account_id.Serialize();\n\n        return;\n      }\n    }\n  }\n\n  if (info.type == ONLINE) {\n    std::string file_name = GURL(info.location).ExtractFileName();\n    WallpaperResolution resolution = GetAppropriateResolution();\n    if (info.layout != WALLPAPER_LAYOUT_STRETCH &&\n        resolution == WALLPAPER_RESOLUTION_SMALL) {\n      file_name = base::FilePath(file_name)\n                      .InsertBeforeExtension(kSmallWallpaperSuffix)\n                      .value();\n    }\n    DCHECK(dir_chromeos_wallpapers_path_id != -1);\n    CHECK(PathService::Get(dir_chromeos_wallpapers_path_id,\n                           &wallpaper_dir));\n    wallpaper_path = wallpaper_dir.Append(file_name);\n\n    CustomWallpaperMap::iterator it = wallpaper_cache_.find(account_id);\n    if (it != wallpaper_cache_.end() &&\n        it->second.first == wallpaper_path &&\n        !it->second.second.isNull())\n      return;\n\n    loaded_wallpapers_for_test_++;\n    StartLoad(account_id, info, update_wallpaper, wallpaper_path,\n              std::move(on_finish));\n  } else if (info.type == DEFAULT) {\n    base::FilePath user_data_dir;\n    DCHECK(dir_user_data_path_id != -1);\n    PathService::Get(dir_user_data_path_id, &user_data_dir);\n    wallpaper_path = user_data_dir.Append(info.location);\n    StartLoad(account_id, info, update_wallpaper, wallpaper_path,\n              std::move(on_finish));\n  } else {\n     LOG(ERROR) << \"Wallpaper reverts to default unexpected.\";\n    DoSetDefaultWallpaper(account_id, update_wallpaper, std::move(on_finish));\n   }\n }\n",
    "cwe": [
      "CWE-200"
    ],
    "id": 790,
    "_valid_cwes": [
      "CWE-200"
    ]
  },
  {
    "cve_id": "CVE-2016-3834",
    "code_before_change": "void CameraSource::releaseQueuedFrames() {\n\n     List<sp<IMemory> >::iterator it;\n     while (!mFramesReceived.empty()) {\n         it = mFramesReceived.begin();\n         releaseRecordingFrame(*it);\n         mFramesReceived.erase(it);\n         ++mNumFramesDropped;\n }\n}\n",
    "code_after_change": "void CameraSource::releaseQueuedFrames() {\n\n     List<sp<IMemory> >::iterator it;\n     while (!mFramesReceived.empty()) {\n         it = mFramesReceived.begin();\n        // b/28466701\n        adjustOutgoingANWBuffer(it->get());\n         releaseRecordingFrame(*it);\n         mFramesReceived.erase(it);\n         ++mNumFramesDropped;\n }\n}\n",
    "cwe": [
      "CWE-200"
    ],
    "id": 858,
    "_valid_cwes": [
      "CWE-200"
    ]
  },
  {
    "cve_id": "CVE-2017-5011",
    "code_before_change": "std::string SanitizeRemoteFrontendURL(const std::string& value) {\n  GURL url(net::UnescapeURLComponent(value,\n      net::UnescapeRule::SPACES | net::UnescapeRule::PATH_SEPARATORS |\n      net::UnescapeRule::URL_SPECIAL_CHARS_EXCEPT_PATH_SEPARATORS |\n      net::UnescapeRule::REPLACE_PLUS_WITH_SPACE));\n  std::string path = url.path();\n  std::vector<std::string> parts = base::SplitString(\n      path, \"/\", base::KEEP_WHITESPACE, base::SPLIT_WANT_ALL);\n  std::string revision = parts.size() > 2 ? parts[2] : \"\";\n  revision = SanitizeRevision(revision);\n  std::string filename = parts.size() ? parts[parts.size() - 1] : \"\";\n  if (filename != \"devtools.html\")\n    filename = \"inspector.html\";\n  path = base::StringPrintf(\"/serve_rev/%s/%s\",\n                            revision.c_str(), filename.c_str());\n  std::string sanitized = SanitizeFrontendURL(url, url::kHttpsScheme,\n      kRemoteFrontendDomain, path, true).spec();\n  return net::EscapeQueryParamValue(sanitized, false);\n}\n",
    "code_after_change": "std::string SanitizeRemoteFrontendURL(const std::string& value) {\n",
    "cwe": [
      "CWE-200"
    ],
    "id": 873,
    "_valid_cwes": [
      "CWE-200"
    ]
  },
  {
    "cve_id": "CVE-2016-0702",
    "code_before_change": " static int MOD_EXP_CTIME_COPY_TO_PREBUF(const BIGNUM *b, int top,\n                                         unsigned char *buf, int idx,\n                                        int width)\n {\n    size_t i, j;\n \n     if (top > b->top)\n         top = b->top;           /* this works because 'buf' is explicitly\n                                  * zeroed */\n    for (i = 0, j = idx; i < top * sizeof b->d[0]; i++, j += width) {\n        buf[j] = ((unsigned char *)b->d)[i];\n     }\n \n     return 1;\n                                          unsigned char *buf, int idx,\n \n static int MOD_EXP_CTIME_COPY_FROM_PREBUF(BIGNUM *b, int top,\n                                           unsigned char *buf, int idx,\n                                          int width)\n {\n    size_t i, j;\n \n     if (bn_wexpand(b, top) == NULL)\n         return 0;\n \n    for (i = 0, j = idx; i < top * sizeof b->d[0]; i++, j += width) {\n        ((unsigned char *)b->d)[i] = buf[j];\n     }\n \n     b->top = top;\n    if (!BN_is_odd(m)) {\n        BNerr(BN_F_BN_MOD_EXP_MONT_CONSTTIME, BN_R_CALLED_WITH_EVEN_MODULUS);\n        return (0);\n    }\n\n    top = m->top;\n\n    bits = BN_num_bits(p);\n    if (bits == 0) {\n        /* x**0 mod 1 is still zero. */\n        if (BN_is_one(m)) {\n            ret = 1;\n            BN_zero(rr);\n        } else {\n            ret = BN_one(rr);\n        }\n        return ret;\n    }\n\n    BN_CTX_start(ctx);\n\n    /*\n     * Allocate a montgomery context if it was not supplied by the caller. If\n     * this is not done, things will break in the montgomery part.\n     */\n    if (in_mont != NULL)\n        mont = in_mont;\n    else {\n        if ((mont = BN_MONT_CTX_new()) == NULL)\n            goto err;\n        if (!BN_MONT_CTX_set(mont, m, ctx))\n            goto err;\n    }\n\n#ifdef RSAZ_ENABLED\n    /*\n     * If the size of the operands allow it, perform the optimized\n     * RSAZ exponentiation. For further information see\n     * crypto/bn/rsaz_exp.c and accompanying assembly modules.\n     */\n    if ((16 == a->top) && (16 == p->top) && (BN_num_bits(m) == 1024)\n        && rsaz_avx2_eligible()) {\n        if (NULL == bn_wexpand(rr, 16))\n            goto err;\n        RSAZ_1024_mod_exp_avx2(rr->d, a->d, p->d, m->d, mont->RR.d,\n                               mont->n0[0]);\n        rr->top = 16;\n        rr->neg = 0;\n        bn_correct_top(rr);\n        ret = 1;\n        goto err;\n    } else if ((8 == a->top) && (8 == p->top) && (BN_num_bits(m) == 512)) {\n        if (NULL == bn_wexpand(rr, 8))\n            goto err;\n        RSAZ_512_mod_exp(rr->d, a->d, p->d, m->d, mont->n0[0], mont->RR.d);\n        rr->top = 8;\n        rr->neg = 0;\n        bn_correct_top(rr);\n        ret = 1;\n        goto err;\n    }\n#endif\n\n    /* Get the window size to use with size of p. */\n    window = BN_window_bits_for_ctime_exponent_size(bits);\n#if defined(SPARC_T4_MONT)\n    if (window >= 5 && (top & 15) == 0 && top <= 64 &&\n        (OPENSSL_sparcv9cap_P[1] & (CFR_MONTMUL | CFR_MONTSQR)) ==\n        (CFR_MONTMUL | CFR_MONTSQR) && (t4 = OPENSSL_sparcv9cap_P[0]))\n        window = 5;\n    else\n#endif\n#if defined(OPENSSL_BN_ASM_MONT5)\n    if (window >= 5) {\n        window = 5;             /* ~5% improvement for RSA2048 sign, and even\n                                 * for RSA4096 */\n        if ((top & 7) == 0)\n            powerbufLen += 2 * top * sizeof(m->d[0]);\n    }\n#endif\n    (void)0;\n\n    /*\n     * Allocate a buffer large enough to hold all of the pre-computed powers\n     * of am, am itself and tmp.\n     */\n    numPowers = 1 << window;\n    powerbufLen += sizeof(m->d[0]) * (top * numPowers +\n                                      ((2 * top) >\n                                       numPowers ? (2 * top) : numPowers));\n#ifdef alloca\n    if (powerbufLen < 3072)\n        powerbufFree =\n            alloca(powerbufLen + MOD_EXP_CTIME_MIN_CACHE_LINE_WIDTH);\n    else\n#endif\n        if ((powerbufFree =\n             (unsigned char *)OPENSSL_malloc(powerbufLen +\n                                             MOD_EXP_CTIME_MIN_CACHE_LINE_WIDTH))\n            == NULL)\n        goto err;\n\n    powerbuf = MOD_EXP_CTIME_ALIGN(powerbufFree);\n    memset(powerbuf, 0, powerbufLen);\n\n#ifdef alloca\n    if (powerbufLen < 3072)\n        powerbufFree = NULL;\n#endif\n\n    /* lay down tmp and am right after powers table */\n    tmp.d = (BN_ULONG *)(powerbuf + sizeof(m->d[0]) * top * numPowers);\n    am.d = tmp.d + top;\n    tmp.top = am.top = 0;\n    tmp.dmax = am.dmax = top;\n    tmp.neg = am.neg = 0;\n    tmp.flags = am.flags = BN_FLG_STATIC_DATA;\n\n    /* prepare a^0 in Montgomery domain */\n#if 1                           /* by Shay Gueron's suggestion */\n    if (m->d[top - 1] & (((BN_ULONG)1) << (BN_BITS2 - 1))) {\n        /* 2^(top*BN_BITS2) - m */\n        tmp.d[0] = (0 - m->d[0]) & BN_MASK2;\n        for (i = 1; i < top; i++)\n            tmp.d[i] = (~m->d[i]) & BN_MASK2;\n        tmp.top = top;\n    } else\n#endif\n    if (!BN_to_montgomery(&tmp, BN_value_one(), mont, ctx))\n        goto err;\n\n    /* prepare a^1 in Montgomery domain */\n    if (a->neg || BN_ucmp(a, m) >= 0) {\n        if (!BN_mod(&am, a, m, ctx))\n            goto err;\n        if (!BN_to_montgomery(&am, &am, mont, ctx))\n            goto err;\n    } else if (!BN_to_montgomery(&am, a, mont, ctx))\n        goto err;\n\n#if defined(SPARC_T4_MONT)\n    if (t4) {\n        typedef int (*bn_pwr5_mont_f) (BN_ULONG *tp, const BN_ULONG *np,\n                                       const BN_ULONG *n0, const void *table,\n                                       int power, int bits);\n        int bn_pwr5_mont_t4_8(BN_ULONG *tp, const BN_ULONG *np,\n                              const BN_ULONG *n0, const void *table,\n                              int power, int bits);\n        int bn_pwr5_mont_t4_16(BN_ULONG *tp, const BN_ULONG *np,\n                               const BN_ULONG *n0, const void *table,\n                               int power, int bits);\n        int bn_pwr5_mont_t4_24(BN_ULONG *tp, const BN_ULONG *np,\n                               const BN_ULONG *n0, const void *table,\n                               int power, int bits);\n        int bn_pwr5_mont_t4_32(BN_ULONG *tp, const BN_ULONG *np,\n                               const BN_ULONG *n0, const void *table,\n                               int power, int bits);\n        static const bn_pwr5_mont_f pwr5_funcs[4] = {\n            bn_pwr5_mont_t4_8, bn_pwr5_mont_t4_16,\n            bn_pwr5_mont_t4_24, bn_pwr5_mont_t4_32\n        };\n        bn_pwr5_mont_f pwr5_worker = pwr5_funcs[top / 16 - 1];\n\n        typedef int (*bn_mul_mont_f) (BN_ULONG *rp, const BN_ULONG *ap,\n                                      const void *bp, const BN_ULONG *np,\n                                      const BN_ULONG *n0);\n        int bn_mul_mont_t4_8(BN_ULONG *rp, const BN_ULONG *ap, const void *bp,\n                             const BN_ULONG *np, const BN_ULONG *n0);\n        int bn_mul_mont_t4_16(BN_ULONG *rp, const BN_ULONG *ap,\n                              const void *bp, const BN_ULONG *np,\n                              const BN_ULONG *n0);\n        int bn_mul_mont_t4_24(BN_ULONG *rp, const BN_ULONG *ap,\n                              const void *bp, const BN_ULONG *np,\n                              const BN_ULONG *n0);\n        int bn_mul_mont_t4_32(BN_ULONG *rp, const BN_ULONG *ap,\n                              const void *bp, const BN_ULONG *np,\n                              const BN_ULONG *n0);\n        static const bn_mul_mont_f mul_funcs[4] = {\n            bn_mul_mont_t4_8, bn_mul_mont_t4_16,\n            bn_mul_mont_t4_24, bn_mul_mont_t4_32\n        };\n        bn_mul_mont_f mul_worker = mul_funcs[top / 16 - 1];\n\n        void bn_mul_mont_vis3(BN_ULONG *rp, const BN_ULONG *ap,\n                              const void *bp, const BN_ULONG *np,\n                              const BN_ULONG *n0, int num);\n        void bn_mul_mont_t4(BN_ULONG *rp, const BN_ULONG *ap,\n                            const void *bp, const BN_ULONG *np,\n                            const BN_ULONG *n0, int num);\n        void bn_mul_mont_gather5_t4(BN_ULONG *rp, const BN_ULONG *ap,\n                                    const void *table, const BN_ULONG *np,\n                                    const BN_ULONG *n0, int num, int power);\n        void bn_flip_n_scatter5_t4(const BN_ULONG *inp, size_t num,\n                                   void *table, size_t power);\n        void bn_gather5_t4(BN_ULONG *out, size_t num,\n                           void *table, size_t power);\n        void bn_flip_t4(BN_ULONG *dst, BN_ULONG *src, size_t num);\n\n        BN_ULONG *np = mont->N.d, *n0 = mont->n0;\n        int stride = 5 * (6 - (top / 16 - 1)); /* multiple of 5, but less\n                                                * than 32 */\n\n        /*\n         * BN_to_montgomery can contaminate words above .top [in\n         * BN_DEBUG[_DEBUG] build]...\n         */\n        for (i = am.top; i < top; i++)\n            am.d[i] = 0;\n        for (i = tmp.top; i < top; i++)\n            tmp.d[i] = 0;\n\n        bn_flip_n_scatter5_t4(tmp.d, top, powerbuf, 0);\n        bn_flip_n_scatter5_t4(am.d, top, powerbuf, 1);\n        if (!(*mul_worker) (tmp.d, am.d, am.d, np, n0) &&\n            !(*mul_worker) (tmp.d, am.d, am.d, np, n0))\n            bn_mul_mont_vis3(tmp.d, am.d, am.d, np, n0, top);\n        bn_flip_n_scatter5_t4(tmp.d, top, powerbuf, 2);\n\n        for (i = 3; i < 32; i++) {\n            /* Calculate a^i = a^(i-1) * a */\n            if (!(*mul_worker) (tmp.d, tmp.d, am.d, np, n0) &&\n                !(*mul_worker) (tmp.d, tmp.d, am.d, np, n0))\n                bn_mul_mont_vis3(tmp.d, tmp.d, am.d, np, n0, top);\n            bn_flip_n_scatter5_t4(tmp.d, top, powerbuf, i);\n        }\n\n        /* switch to 64-bit domain */\n        np = alloca(top * sizeof(BN_ULONG));\n        top /= 2;\n        bn_flip_t4(np, mont->N.d, top);\n\n        bits--;\n        for (wvalue = 0, i = bits % 5; i >= 0; i--, bits--)\n            wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);\n        bn_gather5_t4(tmp.d, top, powerbuf, wvalue);\n\n        /*\n         * Scan the exponent one window at a time starting from the most\n         * significant bits.\n         */\n        while (bits >= 0) {\n            if (bits < stride)\n                stride = bits + 1;\n            bits -= stride;\n            wvalue = bn_get_bits(p, bits + 1);\n\n            if ((*pwr5_worker) (tmp.d, np, n0, powerbuf, wvalue, stride))\n                continue;\n            /* retry once and fall back */\n            if ((*pwr5_worker) (tmp.d, np, n0, powerbuf, wvalue, stride))\n                continue;\n\n            bits += stride - 5;\n            wvalue >>= stride - 5;\n            wvalue &= 31;\n            bn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);\n            bn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);\n            bn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);\n            bn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);\n            bn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);\n            bn_mul_mont_gather5_t4(tmp.d, tmp.d, powerbuf, np, n0, top,\n                                   wvalue);\n        }\n\n        bn_flip_t4(tmp.d, tmp.d, top);\n        top *= 2;\n        /* back to 32-bit domain */\n        tmp.top = top;\n        bn_correct_top(&tmp);\n        OPENSSL_cleanse(np, top * sizeof(BN_ULONG));\n    } else\n#endif\n#if defined(OPENSSL_BN_ASM_MONT5)\n    if (window == 5 && top > 1) {\n        /*\n         * This optimization uses ideas from http://eprint.iacr.org/2011/239,\n         * specifically optimization of cache-timing attack countermeasures\n         * and pre-computation optimization.\n         */\n\n        /*\n         * Dedicated window==4 case improves 512-bit RSA sign by ~15%, but as\n         * 512-bit RSA is hardly relevant, we omit it to spare size...\n         */\n        void bn_mul_mont_gather5(BN_ULONG *rp, const BN_ULONG *ap,\n                                 const void *table, const BN_ULONG *np,\n                                 const BN_ULONG *n0, int num, int power);\n        void bn_scatter5(const BN_ULONG *inp, size_t num,\n                         void *table, size_t power);\n        void bn_gather5(BN_ULONG *out, size_t num, void *table, size_t power);\n        void bn_power5(BN_ULONG *rp, const BN_ULONG *ap,\n                       const void *table, const BN_ULONG *np,\n                       const BN_ULONG *n0, int num, int power);\n        int bn_get_bits5(const BN_ULONG *ap, int off);\n        int bn_from_montgomery(BN_ULONG *rp, const BN_ULONG *ap,\n                               const BN_ULONG *not_used, const BN_ULONG *np,\n                               const BN_ULONG *n0, int num);\n\n        BN_ULONG *np = mont->N.d, *n0 = mont->n0, *np2;\n\n        /*\n         * BN_to_montgomery can contaminate words above .top [in\n         * BN_DEBUG[_DEBUG] build]...\n         */\n        for (i = am.top; i < top; i++)\n            am.d[i] = 0;\n        for (i = tmp.top; i < top; i++)\n            tmp.d[i] = 0;\n\n        if (top & 7)\n            np2 = np;\n        else\n            for (np2 = am.d + top, i = 0; i < top; i++)\n                np2[2 * i] = np[i];\n\n        bn_scatter5(tmp.d, top, powerbuf, 0);\n        bn_scatter5(am.d, am.top, powerbuf, 1);\n        bn_mul_mont(tmp.d, am.d, am.d, np, n0, top);\n        bn_scatter5(tmp.d, top, powerbuf, 2);\n\n# if 0\n        for (i = 3; i < 32; i++) {\n            /* Calculate a^i = a^(i-1) * a */\n            bn_mul_mont_gather5(tmp.d, am.d, powerbuf, np2, n0, top, i - 1);\n            bn_scatter5(tmp.d, top, powerbuf, i);\n        }\n# else\n        /* same as above, but uses squaring for 1/2 of operations */\n        for (i = 4; i < 32; i *= 2) {\n            bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\n            bn_scatter5(tmp.d, top, powerbuf, i);\n        }\n        for (i = 3; i < 8; i += 2) {\n            int j;\n            bn_mul_mont_gather5(tmp.d, am.d, powerbuf, np2, n0, top, i - 1);\n            bn_scatter5(tmp.d, top, powerbuf, i);\n            for (j = 2 * i; j < 32; j *= 2) {\n                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\n                bn_scatter5(tmp.d, top, powerbuf, j);\n            }\n        }\n        for (; i < 16; i += 2) {\n            bn_mul_mont_gather5(tmp.d, am.d, powerbuf, np2, n0, top, i - 1);\n            bn_scatter5(tmp.d, top, powerbuf, i);\n            bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\n            bn_scatter5(tmp.d, top, powerbuf, 2 * i);\n        }\n        for (; i < 32; i += 2) {\n            bn_mul_mont_gather5(tmp.d, am.d, powerbuf, np2, n0, top, i - 1);\n            bn_scatter5(tmp.d, top, powerbuf, i);\n        }\n# endif\n        bits--;\n        for (wvalue = 0, i = bits % 5; i >= 0; i--, bits--)\n            wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);\n        bn_gather5(tmp.d, top, powerbuf, wvalue);\n\n        /*\n         * Scan the exponent one window at a time starting from the most\n         * significant bits.\n         */\n        if (top & 7)\n            while (bits >= 0) {\n                for (wvalue = 0, i = 0; i < 5; i++, bits--)\n                    wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);\n\n                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\n                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\n                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\n                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\n                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\n                bn_mul_mont_gather5(tmp.d, tmp.d, powerbuf, np, n0, top,\n                                    wvalue);\n        } else {\n            while (bits >= 0) {\n                wvalue = bn_get_bits5(p->d, bits - 4);\n                bits -= 5;\n                bn_power5(tmp.d, tmp.d, powerbuf, np2, n0, top, wvalue);\n            }\n        }\n\n        ret = bn_from_montgomery(tmp.d, tmp.d, NULL, np2, n0, top);\n        tmp.top = top;\n        bn_correct_top(&tmp);\n        if (ret) {\n            if (!BN_copy(rr, &tmp))\n                ret = 0;\n            goto err;           /* non-zero ret means it's not error */\n        }\n    } else\n#endif\n    {\n        if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&tmp, top, powerbuf, 0, numPowers))\n            goto err;\n        if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&am, top, powerbuf, 1, numPowers))\n            goto err;\n\n        /*\n         * If the window size is greater than 1, then calculate\n         * val[i=2..2^winsize-1]. Powers are computed as a*a^(i-1) (even\n         * powers could instead be computed as (a^(i/2))^2 to use the slight\n         * performance advantage of sqr over mul).\n         */\n        if (window > 1) {\n            if (!BN_mod_mul_montgomery(&tmp, &am, &am, mont, ctx))\n                goto err;\n            if (!MOD_EXP_CTIME_COPY_TO_PREBUF\n                (&tmp, top, powerbuf, 2, numPowers))\n                goto err;\n            for (i = 3; i < numPowers; i++) {\n                /* Calculate a^i = a^(i-1) * a */\n                if (!BN_mod_mul_montgomery(&tmp, &am, &tmp, mont, ctx))\n                    goto err;\n                if (!MOD_EXP_CTIME_COPY_TO_PREBUF\n                    (&tmp, top, powerbuf, i, numPowers))\n                    goto err;\n            }\n        }\n\n        bits--;\n        for (wvalue = 0, i = bits % window; i >= 0; i--, bits--)\n            wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);\n        if (!MOD_EXP_CTIME_COPY_FROM_PREBUF\n            (&tmp, top, powerbuf, wvalue, numPowers))\n            goto err;\n\n        /*\n         * Scan the exponent one window at a time starting from the most\n     } else\n #endif\n     {\n        if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&tmp, top, powerbuf, 0, numPowers))\n             goto err;\n        if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&am, top, powerbuf, 1, numPowers))\n             goto err;\n \n         /*\n                wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);\n            }\n\n            /*\n             * Fetch the appropriate pre-computed value from the pre-buf\n         if (window > 1) {\n             if (!BN_mod_mul_montgomery(&tmp, &am, &am, mont, ctx))\n                 goto err;\n            if (!MOD_EXP_CTIME_COPY_TO_PREBUF\n                (&tmp, top, powerbuf, 2, numPowers))\n                 goto err;\n             for (i = 3; i < numPowers; i++) {\n                 /* Calculate a^i = a^(i-1) * a */\n                 if (!BN_mod_mul_montgomery(&tmp, &am, &tmp, mont, ctx))\n                     goto err;\n                if (!MOD_EXP_CTIME_COPY_TO_PREBUF\n                    (&tmp, top, powerbuf, i, numPowers))\n                     goto err;\n             }\n         }\n        for (i = 1; i < top; i++)\n         bits--;\n         for (wvalue = 0, i = bits % window; i >= 0; i--, bits--)\n             wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);\n        if (!MOD_EXP_CTIME_COPY_FROM_PREBUF\n            (&tmp, top, powerbuf, wvalue, numPowers))\n             goto err;\n \n         /*\n err:\n    if ((in_mont == NULL) && (mont != NULL))\n        BN_MONT_CTX_free(mont);\n    if (powerbuf != NULL) {\n        OPENSSL_cleanse(powerbuf, powerbufLen);\n        if (powerbufFree)\n            OPENSSL_free(powerbufFree);\n    }\n    BN_CTX_end(ctx);\n    return (ret);\n}\n\nint BN_mod_exp_mont_word(BIGNUM *rr, BN_ULONG a, const BIGNUM *p,\n             /*\n              * Fetch the appropriate pre-computed value from the pre-buf\n              */\n            if (!MOD_EXP_CTIME_COPY_FROM_PREBUF\n                (&am, top, powerbuf, wvalue, numPowers))\n                 goto err;\n \n             /* Multiply the result into the intermediate result */\n#define BN_MOD_MUL_WORD(r, w, m) \\\n                (BN_mul_word(r, (w)) && \\\n                (/* BN_ucmp(r, (m)) < 0 ? 1 :*/  \\\n                        (BN_mod(t, r, m, ctx) && (swap_tmp = r, r = t, t = swap_tmp, 1))))\n    /*\n     * BN_MOD_MUL_WORD is only used with 'w' large, so the BN_ucmp test is\n     * probably more overhead than always using BN_mod (which uses BN_copy if\n     * a similar test returns true).\n     */\n    /*\n     * We can use BN_mod and do not need BN_nnmod because our accumulator is\n     * never negative (the result of BN_mod does not depend on the sign of\n     * the modulus).\n     */\n#define BN_TO_MONTGOMERY_WORD(r, w, mont) \\\n                (BN_set_word(r, (w)) && BN_to_montgomery(r, r, (mont), ctx))\n\n    if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0) {\n        /* BN_FLG_CONSTTIME only supported by BN_mod_exp_mont() */\n        BNerr(BN_F_BN_MOD_EXP_MONT_WORD, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n        return -1;\n    }\n\n    bn_check_top(p);\n    bn_check_top(m);\n\n    if (!BN_is_odd(m)) {\n        BNerr(BN_F_BN_MOD_EXP_MONT_WORD, BN_R_CALLED_WITH_EVEN_MODULUS);\n        return (0);\n    }\n    if (m->top == 1)\n        a %= m->d[0];           /* make sure that 'a' is reduced */\n\n    bits = BN_num_bits(p);\n    if (bits == 0) {\n        /* x**0 mod 1 is still zero. */\n        if (BN_is_one(m)) {\n            ret = 1;\n            BN_zero(rr);\n        } else {\n            ret = BN_one(rr);\n        }\n        return ret;\n    }\n    if (a == 0) {\n        BN_zero(rr);\n        ret = 1;\n        return ret;\n    }\n\n    BN_CTX_start(ctx);\n    d = BN_CTX_get(ctx);\n    r = BN_CTX_get(ctx);\n    t = BN_CTX_get(ctx);\n    if (d == NULL || r == NULL || t == NULL)\n        goto err;\n\n    if (in_mont != NULL)\n        mont = in_mont;\n    else {\n        if ((mont = BN_MONT_CTX_new()) == NULL)\n            goto err;\n        if (!BN_MONT_CTX_set(mont, m, ctx))\n            goto err;\n    }\n\n    r_is_one = 1;               /* except for Montgomery factor */\n\n    /* bits-1 >= 0 */\n\n    /* The result is accumulated in the product r*w. */\n    w = a;                      /* bit 'bits-1' of 'p' is always set */\n    for (b = bits - 2; b >= 0; b--) {\n        /* First, square r*w. */\n        next_w = w * w;\n        if ((next_w / w) != w) { /* overflow */\n            if (r_is_one) {\n                if (!BN_TO_MONTGOMERY_WORD(r, w, mont))\n                    goto err;\n                r_is_one = 0;\n            } else {\n                if (!BN_MOD_MUL_WORD(r, w, m))\n                    goto err;\n            }\n            next_w = 1;\n        }\n        w = next_w;\n        if (!r_is_one) {\n            if (!BN_mod_mul_montgomery(r, r, r, mont, ctx))\n                goto err;\n        }\n\n        /* Second, multiply r*w by 'a' if exponent bit is set. */\n        if (BN_is_bit_set(p, b)) {\n            next_w = w * a;\n            if ((next_w / a) != w) { /* overflow */\n                if (r_is_one) {\n                    if (!BN_TO_MONTGOMERY_WORD(r, w, mont))\n                        goto err;\n                    r_is_one = 0;\n                } else {\n                    if (!BN_MOD_MUL_WORD(r, w, m))\n                        goto err;\n                }\n                next_w = a;\n            }\n            w = next_w;\n        }\n    }\n\n    /* Finally, set r:=r*w. */\n    if (w != 1) {\n        if (r_is_one) {\n            if (!BN_TO_MONTGOMERY_WORD(r, w, mont))\n                goto err;\n            r_is_one = 0;\n        } else {\n            if (!BN_MOD_MUL_WORD(r, w, m))\n                goto err;\n        }\n    }\n\n    if (r_is_one) {             /* can happen only if a == 1 */\n        if (!BN_one(rr))\n            goto err;\n    } else {\n        if (!BN_from_montgomery(rr, r, mont, ctx))\n            goto err;\n    }\n    ret = 1;\n err:\n    if ((in_mont == NULL) && (mont != NULL))\n        BN_MONT_CTX_free(mont);\n    BN_CTX_end(ctx);\n    bn_check_top(rr);\n    return (ret);\n}\n",
    "code_after_change": " static int MOD_EXP_CTIME_COPY_TO_PREBUF(const BIGNUM *b, int top,\n                                         unsigned char *buf, int idx,\n                                        int window)\n {\n    int i, j;\n    int width = 1 << window;\n    BN_ULONG *table = (BN_ULONG *)buf;\n \n     if (top > b->top)\n         top = b->top;           /* this works because 'buf' is explicitly\n                                  * zeroed */\n    for (i = 0, j = idx; i < top; i++, j += width) {\n        table[j] = b->d[i];\n     }\n \n     return 1;\n                                          unsigned char *buf, int idx,\n \n static int MOD_EXP_CTIME_COPY_FROM_PREBUF(BIGNUM *b, int top,\n                                           unsigned char *buf, int idx,\n                                          int window)\n {\n    int i, j;\n    int width = 1 << window;\n    volatile BN_ULONG *table = (volatile BN_ULONG *)buf;\n \n     if (bn_wexpand(b, top) == NULL)\n         return 0;\n \n    if (window <= 3) {\n        for (i = 0; i < top; i++, table += width) {\n            BN_ULONG acc = 0;\n\n            for (j = 0; j < width; j++) {\n                acc |= table[j] &\n                       ((BN_ULONG)0 - (constant_time_eq_int(j,idx)&1));\n            }\n\n            b->d[i] = acc;\n        }\n    } else {\n        int xstride = 1 << (window - 2);\n        BN_ULONG y0, y1, y2, y3;\n\n        i = idx >> (window - 2);        /* equivalent of idx / xstride */\n        idx &= xstride - 1;             /* equivalent of idx % xstride */\n\n        y0 = (BN_ULONG)0 - (constant_time_eq_int(i,0)&1);\n        y1 = (BN_ULONG)0 - (constant_time_eq_int(i,1)&1);\n        y2 = (BN_ULONG)0 - (constant_time_eq_int(i,2)&1);\n        y3 = (BN_ULONG)0 - (constant_time_eq_int(i,3)&1);\n\n        for (i = 0; i < top; i++, table += width) {\n            BN_ULONG acc = 0;\n\n            for (j = 0; j < xstride; j++) {\n                acc |= ( (table[j + 0 * xstride] & y0) |\n                         (table[j + 1 * xstride] & y1) |\n                         (table[j + 2 * xstride] & y2) |\n                         (table[j + 3 * xstride] & y3) )\n                       & ((BN_ULONG)0 - (constant_time_eq_int(j,idx)&1));\n            }\n\n            b->d[i] = acc;\n        }\n     }\n \n     b->top = top;\n    if (!BN_is_odd(m)) {\n        BNerr(BN_F_BN_MOD_EXP_MONT_CONSTTIME, BN_R_CALLED_WITH_EVEN_MODULUS);\n        return (0);\n    }\n\n    top = m->top;\n\n    bits = BN_num_bits(p);\n    if (bits == 0) {\n        /* x**0 mod 1 is still zero. */\n        if (BN_is_one(m)) {\n            ret = 1;\n            BN_zero(rr);\n        } else {\n            ret = BN_one(rr);\n        }\n        return ret;\n    }\n\n    BN_CTX_start(ctx);\n\n    /*\n     * Allocate a montgomery context if it was not supplied by the caller. If\n     * this is not done, things will break in the montgomery part.\n     */\n    if (in_mont != NULL)\n        mont = in_mont;\n    else {\n        if ((mont = BN_MONT_CTX_new()) == NULL)\n            goto err;\n        if (!BN_MONT_CTX_set(mont, m, ctx))\n            goto err;\n    }\n\n#ifdef RSAZ_ENABLED\n    /*\n     * If the size of the operands allow it, perform the optimized\n     * RSAZ exponentiation. For further information see\n     * crypto/bn/rsaz_exp.c and accompanying assembly modules.\n     */\n    if ((16 == a->top) && (16 == p->top) && (BN_num_bits(m) == 1024)\n        && rsaz_avx2_eligible()) {\n        if (NULL == bn_wexpand(rr, 16))\n            goto err;\n        RSAZ_1024_mod_exp_avx2(rr->d, a->d, p->d, m->d, mont->RR.d,\n                               mont->n0[0]);\n        rr->top = 16;\n        rr->neg = 0;\n        bn_correct_top(rr);\n        ret = 1;\n        goto err;\n    } else if ((8 == a->top) && (8 == p->top) && (BN_num_bits(m) == 512)) {\n        if (NULL == bn_wexpand(rr, 8))\n            goto err;\n        RSAZ_512_mod_exp(rr->d, a->d, p->d, m->d, mont->n0[0], mont->RR.d);\n        rr->top = 8;\n        rr->neg = 0;\n        bn_correct_top(rr);\n        ret = 1;\n        goto err;\n    }\n#endif\n\n    /* Get the window size to use with size of p. */\n    window = BN_window_bits_for_ctime_exponent_size(bits);\n#if defined(SPARC_T4_MONT)\n    if (window >= 5 && (top & 15) == 0 && top <= 64 &&\n        (OPENSSL_sparcv9cap_P[1] & (CFR_MONTMUL | CFR_MONTSQR)) ==\n        (CFR_MONTMUL | CFR_MONTSQR) && (t4 = OPENSSL_sparcv9cap_P[0]))\n        window = 5;\n    else\n#endif\n#if defined(OPENSSL_BN_ASM_MONT5)\n    if (window >= 5) {\n        window = 5;             /* ~5% improvement for RSA2048 sign, and even\n                                 * for RSA4096 */\n        if ((top & 7) == 0)\n            powerbufLen += 2 * top * sizeof(m->d[0]);\n    }\n#endif\n    (void)0;\n\n    /*\n     * Allocate a buffer large enough to hold all of the pre-computed powers\n     * of am, am itself and tmp.\n     */\n    numPowers = 1 << window;\n    powerbufLen += sizeof(m->d[0]) * (top * numPowers +\n                                      ((2 * top) >\n                                       numPowers ? (2 * top) : numPowers));\n#ifdef alloca\n    if (powerbufLen < 3072)\n        powerbufFree =\n            alloca(powerbufLen + MOD_EXP_CTIME_MIN_CACHE_LINE_WIDTH);\n    else\n#endif\n        if ((powerbufFree =\n             (unsigned char *)OPENSSL_malloc(powerbufLen +\n                                             MOD_EXP_CTIME_MIN_CACHE_LINE_WIDTH))\n            == NULL)\n        goto err;\n\n    powerbuf = MOD_EXP_CTIME_ALIGN(powerbufFree);\n    memset(powerbuf, 0, powerbufLen);\n\n#ifdef alloca\n    if (powerbufLen < 3072)\n        powerbufFree = NULL;\n#endif\n\n    /* lay down tmp and am right after powers table */\n    tmp.d = (BN_ULONG *)(powerbuf + sizeof(m->d[0]) * top * numPowers);\n    am.d = tmp.d + top;\n    tmp.top = am.top = 0;\n    tmp.dmax = am.dmax = top;\n    tmp.neg = am.neg = 0;\n    tmp.flags = am.flags = BN_FLG_STATIC_DATA;\n\n    /* prepare a^0 in Montgomery domain */\n#if 1                           /* by Shay Gueron's suggestion */\n    if (m->d[top - 1] & (((BN_ULONG)1) << (BN_BITS2 - 1))) {\n        /* 2^(top*BN_BITS2) - m */\n        tmp.d[0] = (0 - m->d[0]) & BN_MASK2;\n        for (i = 1; i < top; i++)\n            tmp.d[i] = (~m->d[i]) & BN_MASK2;\n        tmp.top = top;\n    } else\n#endif\n    if (!BN_to_montgomery(&tmp, BN_value_one(), mont, ctx))\n        goto err;\n\n    /* prepare a^1 in Montgomery domain */\n    if (a->neg || BN_ucmp(a, m) >= 0) {\n        if (!BN_mod(&am, a, m, ctx))\n            goto err;\n        if (!BN_to_montgomery(&am, &am, mont, ctx))\n            goto err;\n    } else if (!BN_to_montgomery(&am, a, mont, ctx))\n        goto err;\n\n#if defined(SPARC_T4_MONT)\n    if (t4) {\n        typedef int (*bn_pwr5_mont_f) (BN_ULONG *tp, const BN_ULONG *np,\n                                       const BN_ULONG *n0, const void *table,\n                                       int power, int bits);\n        int bn_pwr5_mont_t4_8(BN_ULONG *tp, const BN_ULONG *np,\n                              const BN_ULONG *n0, const void *table,\n                              int power, int bits);\n        int bn_pwr5_mont_t4_16(BN_ULONG *tp, const BN_ULONG *np,\n                               const BN_ULONG *n0, const void *table,\n                               int power, int bits);\n        int bn_pwr5_mont_t4_24(BN_ULONG *tp, const BN_ULONG *np,\n                               const BN_ULONG *n0, const void *table,\n                               int power, int bits);\n        int bn_pwr5_mont_t4_32(BN_ULONG *tp, const BN_ULONG *np,\n                               const BN_ULONG *n0, const void *table,\n                               int power, int bits);\n        static const bn_pwr5_mont_f pwr5_funcs[4] = {\n            bn_pwr5_mont_t4_8, bn_pwr5_mont_t4_16,\n            bn_pwr5_mont_t4_24, bn_pwr5_mont_t4_32\n        };\n        bn_pwr5_mont_f pwr5_worker = pwr5_funcs[top / 16 - 1];\n\n        typedef int (*bn_mul_mont_f) (BN_ULONG *rp, const BN_ULONG *ap,\n                                      const void *bp, const BN_ULONG *np,\n                                      const BN_ULONG *n0);\n        int bn_mul_mont_t4_8(BN_ULONG *rp, const BN_ULONG *ap, const void *bp,\n                             const BN_ULONG *np, const BN_ULONG *n0);\n        int bn_mul_mont_t4_16(BN_ULONG *rp, const BN_ULONG *ap,\n                              const void *bp, const BN_ULONG *np,\n                              const BN_ULONG *n0);\n        int bn_mul_mont_t4_24(BN_ULONG *rp, const BN_ULONG *ap,\n                              const void *bp, const BN_ULONG *np,\n                              const BN_ULONG *n0);\n        int bn_mul_mont_t4_32(BN_ULONG *rp, const BN_ULONG *ap,\n                              const void *bp, const BN_ULONG *np,\n                              const BN_ULONG *n0);\n        static const bn_mul_mont_f mul_funcs[4] = {\n            bn_mul_mont_t4_8, bn_mul_mont_t4_16,\n            bn_mul_mont_t4_24, bn_mul_mont_t4_32\n        };\n        bn_mul_mont_f mul_worker = mul_funcs[top / 16 - 1];\n\n        void bn_mul_mont_vis3(BN_ULONG *rp, const BN_ULONG *ap,\n                              const void *bp, const BN_ULONG *np,\n                              const BN_ULONG *n0, int num);\n        void bn_mul_mont_t4(BN_ULONG *rp, const BN_ULONG *ap,\n                            const void *bp, const BN_ULONG *np,\n                            const BN_ULONG *n0, int num);\n        void bn_mul_mont_gather5_t4(BN_ULONG *rp, const BN_ULONG *ap,\n                                    const void *table, const BN_ULONG *np,\n                                    const BN_ULONG *n0, int num, int power);\n        void bn_flip_n_scatter5_t4(const BN_ULONG *inp, size_t num,\n                                   void *table, size_t power);\n        void bn_gather5_t4(BN_ULONG *out, size_t num,\n                           void *table, size_t power);\n        void bn_flip_t4(BN_ULONG *dst, BN_ULONG *src, size_t num);\n\n        BN_ULONG *np = mont->N.d, *n0 = mont->n0;\n        int stride = 5 * (6 - (top / 16 - 1)); /* multiple of 5, but less\n                                                * than 32 */\n\n        /*\n         * BN_to_montgomery can contaminate words above .top [in\n         * BN_DEBUG[_DEBUG] build]...\n         */\n        for (i = am.top; i < top; i++)\n            am.d[i] = 0;\n        for (i = tmp.top; i < top; i++)\n            tmp.d[i] = 0;\n\n        bn_flip_n_scatter5_t4(tmp.d, top, powerbuf, 0);\n        bn_flip_n_scatter5_t4(am.d, top, powerbuf, 1);\n        if (!(*mul_worker) (tmp.d, am.d, am.d, np, n0) &&\n            !(*mul_worker) (tmp.d, am.d, am.d, np, n0))\n            bn_mul_mont_vis3(tmp.d, am.d, am.d, np, n0, top);\n        bn_flip_n_scatter5_t4(tmp.d, top, powerbuf, 2);\n\n        for (i = 3; i < 32; i++) {\n            /* Calculate a^i = a^(i-1) * a */\n            if (!(*mul_worker) (tmp.d, tmp.d, am.d, np, n0) &&\n                !(*mul_worker) (tmp.d, tmp.d, am.d, np, n0))\n                bn_mul_mont_vis3(tmp.d, tmp.d, am.d, np, n0, top);\n            bn_flip_n_scatter5_t4(tmp.d, top, powerbuf, i);\n        }\n\n        /* switch to 64-bit domain */\n        np = alloca(top * sizeof(BN_ULONG));\n        top /= 2;\n        bn_flip_t4(np, mont->N.d, top);\n\n        bits--;\n        for (wvalue = 0, i = bits % 5; i >= 0; i--, bits--)\n            wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);\n        bn_gather5_t4(tmp.d, top, powerbuf, wvalue);\n\n        /*\n         * Scan the exponent one window at a time starting from the most\n         * significant bits.\n         */\n        while (bits >= 0) {\n            if (bits < stride)\n                stride = bits + 1;\n            bits -= stride;\n            wvalue = bn_get_bits(p, bits + 1);\n\n            if ((*pwr5_worker) (tmp.d, np, n0, powerbuf, wvalue, stride))\n                continue;\n            /* retry once and fall back */\n            if ((*pwr5_worker) (tmp.d, np, n0, powerbuf, wvalue, stride))\n                continue;\n\n            bits += stride - 5;\n            wvalue >>= stride - 5;\n            wvalue &= 31;\n            bn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);\n            bn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);\n            bn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);\n            bn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);\n            bn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);\n            bn_mul_mont_gather5_t4(tmp.d, tmp.d, powerbuf, np, n0, top,\n                                   wvalue);\n        }\n\n        bn_flip_t4(tmp.d, tmp.d, top);\n        top *= 2;\n        /* back to 32-bit domain */\n        tmp.top = top;\n        bn_correct_top(&tmp);\n        OPENSSL_cleanse(np, top * sizeof(BN_ULONG));\n    } else\n#endif\n#if defined(OPENSSL_BN_ASM_MONT5)\n    if (window == 5 && top > 1) {\n        /*\n         * This optimization uses ideas from http://eprint.iacr.org/2011/239,\n         * specifically optimization of cache-timing attack countermeasures\n         * and pre-computation optimization.\n         */\n\n        /*\n         * Dedicated window==4 case improves 512-bit RSA sign by ~15%, but as\n         * 512-bit RSA is hardly relevant, we omit it to spare size...\n         */\n        void bn_mul_mont_gather5(BN_ULONG *rp, const BN_ULONG *ap,\n                                 const void *table, const BN_ULONG *np,\n                                 const BN_ULONG *n0, int num, int power);\n        void bn_scatter5(const BN_ULONG *inp, size_t num,\n                         void *table, size_t power);\n        void bn_gather5(BN_ULONG *out, size_t num, void *table, size_t power);\n        void bn_power5(BN_ULONG *rp, const BN_ULONG *ap,\n                       const void *table, const BN_ULONG *np,\n                       const BN_ULONG *n0, int num, int power);\n        int bn_get_bits5(const BN_ULONG *ap, int off);\n        int bn_from_montgomery(BN_ULONG *rp, const BN_ULONG *ap,\n                               const BN_ULONG *not_used, const BN_ULONG *np,\n                               const BN_ULONG *n0, int num);\n\n        BN_ULONG *np = mont->N.d, *n0 = mont->n0, *np2;\n\n        /*\n         * BN_to_montgomery can contaminate words above .top [in\n         * BN_DEBUG[_DEBUG] build]...\n         */\n        for (i = am.top; i < top; i++)\n            am.d[i] = 0;\n        for (i = tmp.top; i < top; i++)\n            tmp.d[i] = 0;\n\n        if (top & 7)\n            np2 = np;\n        else\n            for (np2 = am.d + top, i = 0; i < top; i++)\n                np2[2 * i] = np[i];\n\n        bn_scatter5(tmp.d, top, powerbuf, 0);\n        bn_scatter5(am.d, am.top, powerbuf, 1);\n        bn_mul_mont(tmp.d, am.d, am.d, np, n0, top);\n        bn_scatter5(tmp.d, top, powerbuf, 2);\n\n# if 0\n        for (i = 3; i < 32; i++) {\n            /* Calculate a^i = a^(i-1) * a */\n            bn_mul_mont_gather5(tmp.d, am.d, powerbuf, np2, n0, top, i - 1);\n            bn_scatter5(tmp.d, top, powerbuf, i);\n        }\n# else\n        /* same as above, but uses squaring for 1/2 of operations */\n        for (i = 4; i < 32; i *= 2) {\n            bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\n            bn_scatter5(tmp.d, top, powerbuf, i);\n        }\n        for (i = 3; i < 8; i += 2) {\n            int j;\n            bn_mul_mont_gather5(tmp.d, am.d, powerbuf, np2, n0, top, i - 1);\n            bn_scatter5(tmp.d, top, powerbuf, i);\n            for (j = 2 * i; j < 32; j *= 2) {\n                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\n                bn_scatter5(tmp.d, top, powerbuf, j);\n            }\n        }\n        for (; i < 16; i += 2) {\n            bn_mul_mont_gather5(tmp.d, am.d, powerbuf, np2, n0, top, i - 1);\n            bn_scatter5(tmp.d, top, powerbuf, i);\n            bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\n            bn_scatter5(tmp.d, top, powerbuf, 2 * i);\n        }\n        for (; i < 32; i += 2) {\n            bn_mul_mont_gather5(tmp.d, am.d, powerbuf, np2, n0, top, i - 1);\n            bn_scatter5(tmp.d, top, powerbuf, i);\n        }\n# endif\n        bits--;\n        for (wvalue = 0, i = bits % 5; i >= 0; i--, bits--)\n            wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);\n        bn_gather5(tmp.d, top, powerbuf, wvalue);\n\n        /*\n         * Scan the exponent one window at a time starting from the most\n         * significant bits.\n         */\n        if (top & 7)\n            while (bits >= 0) {\n                for (wvalue = 0, i = 0; i < 5; i++, bits--)\n                    wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);\n\n                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\n                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\n                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\n                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\n                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\n                bn_mul_mont_gather5(tmp.d, tmp.d, powerbuf, np, n0, top,\n                                    wvalue);\n        } else {\n            while (bits >= 0) {\n                wvalue = bn_get_bits5(p->d, bits - 4);\n                bits -= 5;\n                bn_power5(tmp.d, tmp.d, powerbuf, np2, n0, top, wvalue);\n            }\n        }\n\n        ret = bn_from_montgomery(tmp.d, tmp.d, NULL, np2, n0, top);\n        tmp.top = top;\n        bn_correct_top(&tmp);\n        if (ret) {\n            if (!BN_copy(rr, &tmp))\n                ret = 0;\n            goto err;           /* non-zero ret means it's not error */\n        }\n    } else\n#endif\n    {\n        if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&tmp, top, powerbuf, 0, numPowers))\n            goto err;\n        if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&am, top, powerbuf, 1, numPowers))\n            goto err;\n\n        /*\n         * If the window size is greater than 1, then calculate\n         * val[i=2..2^winsize-1]. Powers are computed as a*a^(i-1) (even\n         * powers could instead be computed as (a^(i/2))^2 to use the slight\n         * performance advantage of sqr over mul).\n         */\n        if (window > 1) {\n            if (!BN_mod_mul_montgomery(&tmp, &am, &am, mont, ctx))\n                goto err;\n            if (!MOD_EXP_CTIME_COPY_TO_PREBUF\n                (&tmp, top, powerbuf, 2, numPowers))\n                goto err;\n            for (i = 3; i < numPowers; i++) {\n                /* Calculate a^i = a^(i-1) * a */\n                if (!BN_mod_mul_montgomery(&tmp, &am, &tmp, mont, ctx))\n                    goto err;\n                if (!MOD_EXP_CTIME_COPY_TO_PREBUF\n                    (&tmp, top, powerbuf, i, numPowers))\n                    goto err;\n            }\n        }\n\n        bits--;\n        for (wvalue = 0, i = bits % window; i >= 0; i--, bits--)\n            wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);\n        if (!MOD_EXP_CTIME_COPY_FROM_PREBUF\n            (&tmp, top, powerbuf, wvalue, numPowers))\n            goto err;\n\n        /*\n         * Scan the exponent one window at a time starting from the most\n     } else\n #endif\n     {\n        if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&tmp, top, powerbuf, 0, window))\n             goto err;\n        if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&am, top, powerbuf, 1, window))\n             goto err;\n \n         /*\n                wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);\n            }\n\n            /*\n             * Fetch the appropriate pre-computed value from the pre-buf\n         if (window > 1) {\n             if (!BN_mod_mul_montgomery(&tmp, &am, &am, mont, ctx))\n                 goto err;\n            if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&tmp, top, powerbuf, 2,\n                                              window))\n                 goto err;\n             for (i = 3; i < numPowers; i++) {\n                 /* Calculate a^i = a^(i-1) * a */\n                 if (!BN_mod_mul_montgomery(&tmp, &am, &tmp, mont, ctx))\n                     goto err;\n                if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&tmp, top, powerbuf, i,\n                                                  window))\n                     goto err;\n             }\n         }\n        for (i = 1; i < top; i++)\n         bits--;\n         for (wvalue = 0, i = bits % window; i >= 0; i--, bits--)\n             wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);\n        if (!MOD_EXP_CTIME_COPY_FROM_PREBUF(&tmp, top, powerbuf, wvalue,\n                                            window))\n             goto err;\n \n         /*\n err:\n    if ((in_mont == NULL) && (mont != NULL))\n        BN_MONT_CTX_free(mont);\n    if (powerbuf != NULL) {\n        OPENSSL_cleanse(powerbuf, powerbufLen);\n        if (powerbufFree)\n            OPENSSL_free(powerbufFree);\n    }\n    BN_CTX_end(ctx);\n    return (ret);\n}\n\nint BN_mod_exp_mont_word(BIGNUM *rr, BN_ULONG a, const BIGNUM *p,\n             /*\n              * Fetch the appropriate pre-computed value from the pre-buf\n              */\n            if (!MOD_EXP_CTIME_COPY_FROM_PREBUF(&am, top, powerbuf, wvalue,\n                                                window))\n                 goto err;\n \n             /* Multiply the result into the intermediate result */\n#define BN_MOD_MUL_WORD(r, w, m) \\\n                (BN_mul_word(r, (w)) && \\\n                (/* BN_ucmp(r, (m)) < 0 ? 1 :*/  \\\n                        (BN_mod(t, r, m, ctx) && (swap_tmp = r, r = t, t = swap_tmp, 1))))\n    /*\n     * BN_MOD_MUL_WORD is only used with 'w' large, so the BN_ucmp test is\n     * probably more overhead than always using BN_mod (which uses BN_copy if\n     * a similar test returns true).\n     */\n    /*\n     * We can use BN_mod and do not need BN_nnmod because our accumulator is\n     * never negative (the result of BN_mod does not depend on the sign of\n     * the modulus).\n     */\n#define BN_TO_MONTGOMERY_WORD(r, w, mont) \\\n                (BN_set_word(r, (w)) && BN_to_montgomery(r, r, (mont), ctx))\n\n    if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0) {\n        /* BN_FLG_CONSTTIME only supported by BN_mod_exp_mont() */\n        BNerr(BN_F_BN_MOD_EXP_MONT_WORD, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n        return -1;\n    }\n\n    bn_check_top(p);\n    bn_check_top(m);\n\n    if (!BN_is_odd(m)) {\n        BNerr(BN_F_BN_MOD_EXP_MONT_WORD, BN_R_CALLED_WITH_EVEN_MODULUS);\n        return (0);\n    }\n    if (m->top == 1)\n        a %= m->d[0];           /* make sure that 'a' is reduced */\n\n    bits = BN_num_bits(p);\n    if (bits == 0) {\n        /* x**0 mod 1 is still zero. */\n        if (BN_is_one(m)) {\n            ret = 1;\n            BN_zero(rr);\n        } else {\n            ret = BN_one(rr);\n        }\n        return ret;\n    }\n    if (a == 0) {\n        BN_zero(rr);\n        ret = 1;\n        return ret;\n    }\n\n    BN_CTX_start(ctx);\n    d = BN_CTX_get(ctx);\n    r = BN_CTX_get(ctx);\n    t = BN_CTX_get(ctx);\n    if (d == NULL || r == NULL || t == NULL)\n        goto err;\n\n    if (in_mont != NULL)\n        mont = in_mont;\n    else {\n        if ((mont = BN_MONT_CTX_new()) == NULL)\n            goto err;\n        if (!BN_MONT_CTX_set(mont, m, ctx))\n            goto err;\n    }\n\n    r_is_one = 1;               /* except for Montgomery factor */\n\n    /* bits-1 >= 0 */\n\n    /* The result is accumulated in the product r*w. */\n    w = a;                      /* bit 'bits-1' of 'p' is always set */\n    for (b = bits - 2; b >= 0; b--) {\n        /* First, square r*w. */\n        next_w = w * w;\n        if ((next_w / w) != w) { /* overflow */\n            if (r_is_one) {\n                if (!BN_TO_MONTGOMERY_WORD(r, w, mont))\n                    goto err;\n                r_is_one = 0;\n            } else {\n                if (!BN_MOD_MUL_WORD(r, w, m))\n                    goto err;\n            }\n            next_w = 1;\n        }\n        w = next_w;\n        if (!r_is_one) {\n            if (!BN_mod_mul_montgomery(r, r, r, mont, ctx))\n                goto err;\n        }\n\n        /* Second, multiply r*w by 'a' if exponent bit is set. */\n        if (BN_is_bit_set(p, b)) {\n            next_w = w * a;\n            if ((next_w / a) != w) { /* overflow */\n                if (r_is_one) {\n                    if (!BN_TO_MONTGOMERY_WORD(r, w, mont))\n                        goto err;\n                    r_is_one = 0;\n                } else {\n                    if (!BN_MOD_MUL_WORD(r, w, m))\n                        goto err;\n                }\n                next_w = a;\n            }\n            w = next_w;\n        }\n    }\n\n    /* Finally, set r:=r*w. */\n    if (w != 1) {\n        if (r_is_one) {\n            if (!BN_TO_MONTGOMERY_WORD(r, w, mont))\n                goto err;\n            r_is_one = 0;\n        } else {\n            if (!BN_MOD_MUL_WORD(r, w, m))\n                goto err;\n        }\n    }\n\n    if (r_is_one) {             /* can happen only if a == 1 */\n        if (!BN_one(rr))\n            goto err;\n    } else {\n        if (!BN_from_montgomery(rr, r, mont, ctx))\n            goto err;\n    }\n    ret = 1;\n err:\n    if ((in_mont == NULL) && (mont != NULL))\n        BN_MONT_CTX_free(mont);\n    BN_CTX_end(ctx);\n    bn_check_top(rr);\n    return (ret);\n}\n",
    "cwe": [
      "CWE-200"
    ],
    "id": 875,
    "_valid_cwes": [
      "CWE-200"
    ]
  },
  {
    "cve_id": "CVE-2012-0037",
    "code_before_change": "raptor_libxml_getEntity(void* user_data, const xmlChar *name) {\n   raptor_sax2* sax2 = (raptor_sax2*)user_data;\n  return libxml2_getEntity(sax2->xc, name);\n }\n",
    "code_after_change": "raptor_libxml_getEntity(void* user_data, const xmlChar *name) {\nraptor_libxml_getEntity(void* user_data, const xmlChar *name)\n{\n   raptor_sax2* sax2 = (raptor_sax2*)user_data;\n  xmlParserCtxtPtr xc = sax2->xc;\n  xmlEntityPtr ret = NULL;\n\n  if(!xc)\n    return NULL;\n\n  if(!xc->inSubset) {\n    /* looks for hardcoded set of entity names - lt, gt etc. */\n    ret = xmlGetPredefinedEntity(name);\n    if(ret) {\n      RAPTOR_DEBUG2(\"Entity '%s' found in predefined set\\n\", name);\n      return ret;\n    }\n  }\n\n  /* This section uses xmlGetDocEntity which looks for entities in\n   * memory only, never from a file or URI \n   */\n  if(xc->myDoc && (xc->myDoc->standalone == 1)) {\n    RAPTOR_DEBUG2(\"Entity '%s' document is standalone\\n\", name);\n    /* Document is standalone: no entities are required to interpret doc */\n    if(xc->inSubset == 2) {\n      xc->myDoc->standalone = 0;\n      ret = xmlGetDocEntity(xc->myDoc, name);\n      xc->myDoc->standalone = 1;\n    } else {\n      ret = xmlGetDocEntity(xc->myDoc, name);\n      if(!ret) {\n        xc->myDoc->standalone = 0;\n        ret = xmlGetDocEntity(xc->myDoc, name);\n        xc->myDoc->standalone = 1;\n      }\n    }\n  } else {\n    ret = xmlGetDocEntity(xc->myDoc, name);\n  }\n\n  if(ret && !ret->children &&\n    (ret->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)) {\n    /* Entity is an external general parsed entity. It may be in a\n     * catalog file, user file or user URI\n     */\n    int val = 0;\n    xmlNodePtr children;\n    int load_entity = 0;\n\n    load_entity = RAPTOR_OPTIONS_GET_NUMERIC(sax2, RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES);\n    if(load_entity)\n      load_entity = raptor_sax2_check_load_uri_string(sax2, ret->URI);\n\n    if(!load_entity) {\n      RAPTOR_DEBUG2(\"Not getting entity URI %s by policy\\n\", ret->URI);\n      children = xmlNewText((const xmlChar*)\"\");\n    } else {\n      /* Disable SAX2 handlers so that the SAX2 events do not all get\n       * sent to callbacks during dealing with the entity parsing.\n       */\n      sax2->enabled = 0;\n      val = xmlParseCtxtExternalEntity(xc, ret->URI, ret->ExternalID, &children);\n      sax2->enabled = 1;\n    }\n    \n    if(!val) {\n      xmlAddChildList((xmlNodePtr)ret, children);\n    } else {\n      xc->validate = 0;\n      return NULL;\n    }\n    \n    ret->owner = 1;\n\n    /* Mark this entity as having been checked - never do this again */\n    if(!ret->checked)\n      ret->checked = 1;\n  }\n\n  return ret;\n }\n",
    "cwe": [
      "CWE-200"
    ],
    "id": 899,
    "_valid_cwes": [
      "CWE-200"
    ]
  },
  {
    "cve_id": "CVE-2018-6077",
    "code_before_change": "void BaseRenderingContext2D::setFillStyle(\n    const StringOrCanvasGradientOrCanvasPattern& style) {\n  DCHECK(!style.IsNull());\n  ValidateStateStack();\n  String color_string;\n  CanvasStyle* canvas_style = nullptr;\n  if (style.IsString()) {\n    color_string = style.GetAsString();\n    if (color_string == GetState().UnparsedFillColor())\n      return;\n    Color parsed_color = 0;\n    if (!ParseColorOrCurrentColor(parsed_color, color_string))\n      return;\n    if (GetState().FillStyle()->IsEquivalentRGBA(parsed_color.Rgb())) {\n      ModifiableState().SetUnparsedFillColor(color_string);\n      return;\n    }\n    canvas_style = CanvasStyle::CreateFromRGBA(parsed_color.Rgb());\n  } else if (style.IsCanvasGradient()) {\n    canvas_style = CanvasStyle::CreateFromGradient(style.GetAsCanvasGradient());\n   } else if (style.IsCanvasPattern()) {\n     CanvasPattern* canvas_pattern = style.GetAsCanvasPattern();\n \n    if (OriginClean() && !canvas_pattern->OriginClean()) {\n      SetOriginTainted();\n      ClearResolvedFilters();\n     }\n     if (canvas_pattern->GetPattern()->IsTextureBacked())\n       DisableDeferral(kDisableDeferralReasonUsingTextureBackedPattern);\n    canvas_style = CanvasStyle::CreateFromPattern(canvas_pattern);\n  }\n\n  DCHECK(canvas_style);\n  ModifiableState().SetFillStyle(canvas_style);\n  ModifiableState().SetUnparsedFillColor(color_string);\n  ModifiableState().ClearResolvedFilter();\n}\n",
    "code_after_change": "void BaseRenderingContext2D::setFillStyle(\n    const StringOrCanvasGradientOrCanvasPattern& style) {\n  DCHECK(!style.IsNull());\n  ValidateStateStack();\n  String color_string;\n  CanvasStyle* canvas_style = nullptr;\n  if (style.IsString()) {\n    color_string = style.GetAsString();\n    if (color_string == GetState().UnparsedFillColor())\n      return;\n    Color parsed_color = 0;\n    if (!ParseColorOrCurrentColor(parsed_color, color_string))\n      return;\n    if (GetState().FillStyle()->IsEquivalentRGBA(parsed_color.Rgb())) {\n      ModifiableState().SetUnparsedFillColor(color_string);\n      return;\n    }\n    canvas_style = CanvasStyle::CreateFromRGBA(parsed_color.Rgb());\n  } else if (style.IsCanvasGradient()) {\n    canvas_style = CanvasStyle::CreateFromGradient(style.GetAsCanvasGradient());\n   } else if (style.IsCanvasPattern()) {\n     CanvasPattern* canvas_pattern = style.GetAsCanvasPattern();\n \n    if (!origin_tainted_by_content_ && !canvas_pattern->OriginClean()) {\n      SetOriginTaintedByContent();\n     }\n     if (canvas_pattern->GetPattern()->IsTextureBacked())\n       DisableDeferral(kDisableDeferralReasonUsingTextureBackedPattern);\n    canvas_style = CanvasStyle::CreateFromPattern(canvas_pattern);\n  }\n\n  DCHECK(canvas_style);\n  ModifiableState().SetFillStyle(canvas_style);\n  ModifiableState().SetUnparsedFillColor(color_string);\n  ModifiableState().ClearResolvedFilter();\n}\n",
    "cwe": [
      "CWE-200"
    ],
    "id": 919,
    "_valid_cwes": [
      "CWE-200"
    ]
  },
  {
    "cve_id": "CVE-2017-5011",
    "code_before_change": "void DevToolsUIBindings::CallClientFunction(const std::string& function_name,\n                                            const base::Value* arg1,\n                                            const base::Value* arg2,\n                                             const base::Value* arg3) {\n   if (!web_contents_->GetURL().SchemeIs(content::kChromeDevToolsScheme))\n     return;\n   std::string javascript = function_name + \"(\";\n   if (arg1) {\n     std::string json;\n    base::JSONWriter::Write(*arg1, &json);\n    javascript.append(json);\n    if (arg2) {\n      base::JSONWriter::Write(*arg2, &json);\n      javascript.append(\", \").append(json);\n      if (arg3) {\n        base::JSONWriter::Write(*arg3, &json);\n        javascript.append(\", \").append(json);\n      }\n    }\n  }\n  javascript.append(\");\");\n  web_contents_->GetMainFrame()->ExecuteJavaScript(\n      base::UTF8ToUTF16(javascript));\n}\n",
    "code_after_change": "void DevToolsUIBindings::CallClientFunction(const std::string& function_name,\n                                            const base::Value* arg1,\n                                            const base::Value* arg2,\n                                             const base::Value* arg3) {\n   if (!web_contents_->GetURL().SchemeIs(content::kChromeDevToolsScheme))\n     return;\n  // If we're not exposing bindings, we shouldn't call functions either.\n  if (!frontend_host_)\n    return;\n   std::string javascript = function_name + \"(\";\n   if (arg1) {\n     std::string json;\n    base::JSONWriter::Write(*arg1, &json);\n    javascript.append(json);\n    if (arg2) {\n      base::JSONWriter::Write(*arg2, &json);\n      javascript.append(\", \").append(json);\n      if (arg3) {\n        base::JSONWriter::Write(*arg3, &json);\n        javascript.append(\", \").append(json);\n      }\n    }\n  }\n  javascript.append(\");\");\n  web_contents_->GetMainFrame()->ExecuteJavaScript(\n      base::UTF8ToUTF16(javascript));\n}\n",
    "cwe": [
      "CWE-200"
    ],
    "id": 979,
    "_valid_cwes": [
      "CWE-200"
    ]
  },
  {
    "cve_id": "CVE-2016-6720",
    "code_before_change": " status_t OMXNodeInstance::storeMetaDataInBuffers_l(\n         OMX_U32 portIndex, OMX_BOOL enable, MetadataBufferType *type) {\n     if (portIndex != kPortIndexInput && portIndex != kPortIndexOutput) {\n         android_errorWriteLog(0x534e4554, \"26324358\");\n         if (type != NULL) {\n *type = kMetadataBufferTypeInvalid;\n }\n return BAD_VALUE;\n }\n\n    OMX_INDEXTYPE index;\n    OMX_STRING name = const_cast<OMX_STRING>(\n \"OMX.google.android.index.storeMetaDataInBuffers\");\n\n    OMX_STRING nativeBufferName = const_cast<OMX_STRING>(\n \"OMX.google.android.index.storeANWBufferInMetadata\");\n MetadataBufferType negotiatedType;\n MetadataBufferType requestedType = type != NULL ? *type : kMetadataBufferTypeANWBuffer;\n\n StoreMetaDataInBuffersParams params;\n InitOMXParams(&params);\n    params.nPortIndex = portIndex;\n    params.bStoreMetaData = enable;\n\n    OMX_ERRORTYPE err =\n        requestedType == kMetadataBufferTypeANWBuffer\n ? OMX_GetExtensionIndex(mHandle, nativeBufferName, &index)\n : OMX_ErrorUnsupportedIndex;\n    OMX_ERRORTYPE xerr = err;\n if (err == OMX_ErrorNone) {\n        err = OMX_SetParameter(mHandle, index, &params);\n if (err == OMX_ErrorNone) {\n            name = nativeBufferName; // set name for debugging\n            negotiatedType = requestedType;\n }\n }\n if (err != OMX_ErrorNone) {\n        err = OMX_GetExtensionIndex(mHandle, name, &index);\n        xerr = err;\n if (err == OMX_ErrorNone) {\n            negotiatedType =\n                requestedType == kMetadataBufferTypeANWBuffer\n ? kMetadataBufferTypeGrallocSource : requestedType;\n            err = OMX_SetParameter(mHandle, index, &params);\n }\n }\n\n if (err != OMX_ErrorNone) {\n if (err == OMX_ErrorUnsupportedIndex && portIndex == kPortIndexOutput) {\n            CLOGW(\"component does not support metadata mode; using fallback\");\n } else if (xerr != OMX_ErrorNone) {\n            CLOG_ERROR(getExtensionIndex, xerr, \"%s\", name);\n } else {\n            CLOG_ERROR(setParameter, err, \"%s(%#x): %s:%u en=%d type=%d\", name, index,\n                    portString(portIndex), portIndex, enable, negotiatedType);\n }\n        negotiatedType = mMetadataType[portIndex];\n } else {\n if (!enable) {\n            negotiatedType = kMetadataBufferTypeInvalid;\n }\n        mMetadataType[portIndex] = negotiatedType;\n }\n    CLOG_CONFIG(storeMetaDataInBuffers, \"%s:%u %srequested %s:%d negotiated %s:%d\",\n            portString(portIndex), portIndex, enable ? \"\" : \"UN\",\n            asString(requestedType), requestedType, asString(negotiatedType), negotiatedType);\n\n if (type != NULL) {\n *type = negotiatedType;\n }\n\n return StatusFromOMXError(err);\n}\n",
    "code_after_change": " status_t OMXNodeInstance::storeMetaDataInBuffers_l(\n         OMX_U32 portIndex, OMX_BOOL enable, MetadataBufferType *type) {\n    if (mSailed) {\n        android_errorWriteLog(0x534e4554, \"29422020\");\n        return INVALID_OPERATION;\n    }\n     if (portIndex != kPortIndexInput && portIndex != kPortIndexOutput) {\n         android_errorWriteLog(0x534e4554, \"26324358\");\n         if (type != NULL) {\n *type = kMetadataBufferTypeInvalid;\n }\n return BAD_VALUE;\n }\n\n    OMX_INDEXTYPE index;\n    OMX_STRING name = const_cast<OMX_STRING>(\n \"OMX.google.android.index.storeMetaDataInBuffers\");\n\n    OMX_STRING nativeBufferName = const_cast<OMX_STRING>(\n \"OMX.google.android.index.storeANWBufferInMetadata\");\n MetadataBufferType negotiatedType;\n MetadataBufferType requestedType = type != NULL ? *type : kMetadataBufferTypeANWBuffer;\n\n StoreMetaDataInBuffersParams params;\n InitOMXParams(&params);\n    params.nPortIndex = portIndex;\n    params.bStoreMetaData = enable;\n\n    OMX_ERRORTYPE err =\n        requestedType == kMetadataBufferTypeANWBuffer\n ? OMX_GetExtensionIndex(mHandle, nativeBufferName, &index)\n : OMX_ErrorUnsupportedIndex;\n    OMX_ERRORTYPE xerr = err;\n if (err == OMX_ErrorNone) {\n        err = OMX_SetParameter(mHandle, index, &params);\n if (err == OMX_ErrorNone) {\n            name = nativeBufferName; // set name for debugging\n            negotiatedType = requestedType;\n }\n }\n if (err != OMX_ErrorNone) {\n        err = OMX_GetExtensionIndex(mHandle, name, &index);\n        xerr = err;\n if (err == OMX_ErrorNone) {\n            negotiatedType =\n                requestedType == kMetadataBufferTypeANWBuffer\n ? kMetadataBufferTypeGrallocSource : requestedType;\n            err = OMX_SetParameter(mHandle, index, &params);\n }\n }\n\n if (err != OMX_ErrorNone) {\n if (err == OMX_ErrorUnsupportedIndex && portIndex == kPortIndexOutput) {\n            CLOGW(\"component does not support metadata mode; using fallback\");\n } else if (xerr != OMX_ErrorNone) {\n            CLOG_ERROR(getExtensionIndex, xerr, \"%s\", name);\n } else {\n            CLOG_ERROR(setParameter, err, \"%s(%#x): %s:%u en=%d type=%d\", name, index,\n                    portString(portIndex), portIndex, enable, negotiatedType);\n }\n        negotiatedType = mMetadataType[portIndex];\n } else {\n if (!enable) {\n            negotiatedType = kMetadataBufferTypeInvalid;\n }\n        mMetadataType[portIndex] = negotiatedType;\n }\n    CLOG_CONFIG(storeMetaDataInBuffers, \"%s:%u %srequested %s:%d negotiated %s:%d\",\n            portString(portIndex), portIndex, enable ? \"\" : \"UN\",\n            asString(requestedType), requestedType, asString(negotiatedType), negotiatedType);\n\n if (type != NULL) {\n *type = negotiatedType;\n }\n\n return StatusFromOMXError(err);\n}\n",
    "cwe": [
      "CWE-200"
    ],
    "id": 1016,
    "_valid_cwes": [
      "CWE-200"
    ]
  }
]