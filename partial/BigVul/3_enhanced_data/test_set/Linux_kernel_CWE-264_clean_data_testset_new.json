[
  {
    "cve_id": "CVE-2016-2494",
    "code_before_change": "static ssize_t get_node_path_locked(struct node* node, char* buf, size_t bufsize) {\n const char* name;\n size_t namelen;\n if (node->graft_path) {\n        name = node->graft_path;\n        namelen = node->graft_pathlen;\n } else if (node->actual_name) {\n        name = node->actual_name;\n        namelen = node->namelen;\n } else {\n        name = node->name;\n        namelen = node->namelen;\n }\n\n if (bufsize < namelen + 1) {\n return -1;\n }\n\n \n     ssize_t pathlen = 0;\n     if (node->parent && node->graft_path == NULL) {\n        pathlen = get_node_path_locked(node->parent, buf, bufsize - namelen - 2);\n         if (pathlen < 0) {\n             return -1;\n         }\n        buf[pathlen++] = '/';\n }\n\n    memcpy(buf + pathlen, name, namelen + 1); /* include trailing \\0 */\n return pathlen + namelen;\n}\n",
    "code_after_change": "static ssize_t get_node_path_locked(struct node* node, char* buf, size_t bufsize) {\n const char* name;\n size_t namelen;\n if (node->graft_path) {\n        name = node->graft_path;\n        namelen = node->graft_pathlen;\n } else if (node->actual_name) {\n        name = node->actual_name;\n        namelen = node->namelen;\n } else {\n        name = node->name;\n        namelen = node->namelen;\n }\n\n if (bufsize < namelen + 1) {\n return -1;\n }\n\n \n     ssize_t pathlen = 0;\n     if (node->parent && node->graft_path == NULL) {\n        pathlen = get_node_path_locked(node->parent, buf, bufsize - namelen - 1);\n         if (pathlen < 0) {\n             return -1;\n         }\n        buf[pathlen++] = '/';\n }\n\n    memcpy(buf + pathlen, name, namelen + 1); /* include trailing \\0 */\n return pathlen + namelen;\n}\n",
    "cwe": [
      "CWE-264"
    ],
    "id": 28,
    "_valid_cwes": [
      "CWE-264"
    ]
  },
  {
    "cve_id": "CVE-2013-0924",
    "code_before_change": " bool PermissionsRequestFunction::RunImpl() {\n   if (!user_gesture() && !ignore_user_gesture_for_tests) {\n     error_ = kUserGestureRequiredError;\n     return false;\n  }\n\n   scoped_ptr<Request::Params> params(Request::Params::Create(*args_));\n   EXTENSION_FUNCTION_VALIDATE(params.get());\n \n   requested_permissions_ =\n      helpers::UnpackPermissionSet(params->permissions, &error_);\n   if (!requested_permissions_.get())\n     return false;\n \n  extensions::ExtensionPrefs* prefs =\n      profile()->GetExtensionService()->extension_prefs();\n   APIPermissionSet apis = requested_permissions_->apis();\n   for (APIPermissionSet::const_iterator i = apis.begin();\n       i != apis.end(); ++i) {\n    if (!i->info()->supports_optional()) {\n      error_ = ErrorUtils::FormatErrorMessage(\n          kNotWhitelistedError, i->name());\n      return false;\n    }\n  }\n\n  scoped_refptr<extensions::PermissionSet>\n      manifest_required_requested_permissions =\n          PermissionSet::ExcludeNotInManifestPermissions(\n              requested_permissions_.get());\n\n  if (!GetExtension()->optional_permission_set()->Contains(\n          *manifest_required_requested_permissions)) {\n    error_ = kNotInOptionalPermissionsError;\n    results_ = Request::Results::Create(false);\n    return false;\n  }\n\n  scoped_refptr<const PermissionSet> granted =\n      prefs->GetGrantedPermissions(GetExtension()->id());\n  if (granted.get() && granted->Contains(*requested_permissions_)) {\n    PermissionsUpdater perms_updater(profile());\n    perms_updater.AddPermissions(GetExtension(), requested_permissions_.get());\n    results_ = Request::Results::Create(true);\n    SendResponse(true);\n    return true;\n  }\n\n  requested_permissions_ = PermissionSet::CreateDifference(\n      requested_permissions_.get(), granted.get());\n\n  AddRef();  // Balanced in InstallUIProceed() / InstallUIAbort().\n\n  bool has_no_warnings = requested_permissions_->GetWarningMessages(\n      GetExtension()->GetType()).empty();\n  if (auto_confirm_for_tests == PROCEED || has_no_warnings) {\n    InstallUIProceed();\n  } else if (auto_confirm_for_tests == ABORT) {\n    InstallUIAbort(true);\n  } else {\n    CHECK_EQ(DO_NOT_SKIP, auto_confirm_for_tests);\n    install_ui_.reset(new ExtensionInstallPrompt(GetAssociatedWebContents()));\n    install_ui_->ConfirmPermissions(\n        this, GetExtension(), requested_permissions_.get());\n  }\n\n  return true;\n}\n",
    "code_after_change": " bool PermissionsRequestFunction::RunImpl() {\n  results_ = Request::Results::Create(false);\n\n   if (!user_gesture() && !ignore_user_gesture_for_tests) {\n     error_ = kUserGestureRequiredError;\n     return false;\n  }\n\n   scoped_ptr<Request::Params> params(Request::Params::Create(*args_));\n   EXTENSION_FUNCTION_VALIDATE(params.get());\n \n  ExtensionPrefs* prefs = ExtensionSystem::Get(profile_)->extension_prefs();\n\n   requested_permissions_ =\n      helpers::UnpackPermissionSet(params->permissions,\n                                   prefs->AllowFileAccess(extension_->id()),\n                                   &error_);\n   if (!requested_permissions_.get())\n     return false;\n \n   APIPermissionSet apis = requested_permissions_->apis();\n   for (APIPermissionSet::const_iterator i = apis.begin();\n       i != apis.end(); ++i) {\n    if (!i->info()->supports_optional()) {\n      error_ = ErrorUtils::FormatErrorMessage(\n          kNotWhitelistedError, i->name());\n      return false;\n    }\n  }\n\n  scoped_refptr<extensions::PermissionSet>\n      manifest_required_requested_permissions =\n          PermissionSet::ExcludeNotInManifestPermissions(\n              requested_permissions_.get());\n\n  if (!GetExtension()->optional_permission_set()->Contains(\n          *manifest_required_requested_permissions)) {\n    error_ = kNotInOptionalPermissionsError;\n    results_ = Request::Results::Create(false);\n    return false;\n  }\n\n  scoped_refptr<const PermissionSet> granted =\n      prefs->GetGrantedPermissions(GetExtension()->id());\n  if (granted.get() && granted->Contains(*requested_permissions_)) {\n    PermissionsUpdater perms_updater(profile());\n    perms_updater.AddPermissions(GetExtension(), requested_permissions_.get());\n    results_ = Request::Results::Create(true);\n    SendResponse(true);\n    return true;\n  }\n\n  requested_permissions_ = PermissionSet::CreateDifference(\n      requested_permissions_.get(), granted.get());\n\n  AddRef();  // Balanced in InstallUIProceed() / InstallUIAbort().\n\n  bool has_no_warnings = requested_permissions_->GetWarningMessages(\n      GetExtension()->GetType()).empty();\n  if (auto_confirm_for_tests == PROCEED || has_no_warnings) {\n    InstallUIProceed();\n  } else if (auto_confirm_for_tests == ABORT) {\n    InstallUIAbort(true);\n  } else {\n    CHECK_EQ(DO_NOT_SKIP, auto_confirm_for_tests);\n    install_ui_.reset(new ExtensionInstallPrompt(GetAssociatedWebContents()));\n    install_ui_->ConfirmPermissions(\n        this, GetExtension(), requested_permissions_.get());\n  }\n\n  return true;\n}\n",
    "cwe": [
      "CWE-264"
    ],
    "id": 33,
    "_valid_cwes": [
      "CWE-264"
    ]
  },
  {
    "cve_id": "CVE-2011-4112",
    "code_before_change": " static void l2tp_eth_dev_setup(struct net_device *dev)\n {\n \tether_setup(dev);\n \tdev->netdev_ops\t\t= &l2tp_eth_netdev_ops;\n \tdev->destructor\t\t= free_netdev;\n }\n",
    "code_after_change": " static void l2tp_eth_dev_setup(struct net_device *dev)\n {\n \tether_setup(dev);\n\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n \tdev->netdev_ops\t\t= &l2tp_eth_netdev_ops;\n \tdev->destructor\t\t= free_netdev;\n }\n",
    "cwe": [
      "CWE-264"
    ],
    "id": 55,
    "_valid_cwes": [
      "CWE-264"
    ]
  },
  {
    "cve_id": "CVE-2013-0838",
    "code_before_change": "static SharedMemorySupport DoQuerySharedMemorySupport(Display* dpy) {\n  int dummy;\n  Bool pixmaps_supported;\n  if (!XShmQueryVersion(dpy, &dummy, &dummy, &pixmaps_supported))\n    return SHARED_MEMORY_NONE;\n\n#if defined(OS_FREEBSD)\n  int allow_removed;\n  size_t length = sizeof(allow_removed);\n\n  if ((sysctlbyname(\"kern.ipc.shm_allow_removed\", &allow_removed, &length,\n      NULL, 0) < 0) || allow_removed < 1) {\n    return SHARED_MEMORY_NONE;\n  }\n #endif\n \n  int shmkey = shmget(IPC_PRIVATE, 1, 0666);\n  if (shmkey == -1)\n     return SHARED_MEMORY_NONE;\n   void* address = shmat(shmkey, NULL, 0);\n   shmctl(shmkey, IPC_RMID, NULL);\n\n  XShmSegmentInfo shminfo;\n  memset(&shminfo, 0, sizeof(shminfo));\n  shminfo.shmid = shmkey;\n \n   gdk_error_trap_push();\n   bool result = XShmAttach(dpy, &shminfo);\n   XSync(dpy, False);\n   if (gdk_error_trap_pop())\n     result = false;\n   shmdt(address);\n  if (!result)\n     return SHARED_MEMORY_NONE;\n \n   XShmDetach(dpy, &shminfo);\n   return pixmaps_supported ? SHARED_MEMORY_PIXMAP : SHARED_MEMORY_PUTIMAGE;\n}\n",
    "code_after_change": "static SharedMemorySupport DoQuerySharedMemorySupport(Display* dpy) {\n  int dummy;\n  Bool pixmaps_supported;\n  if (!XShmQueryVersion(dpy, &dummy, &dummy, &pixmaps_supported))\n    return SHARED_MEMORY_NONE;\n\n#if defined(OS_FREEBSD)\n  int allow_removed;\n  size_t length = sizeof(allow_removed);\n\n  if ((sysctlbyname(\"kern.ipc.shm_allow_removed\", &allow_removed, &length,\n      NULL, 0) < 0) || allow_removed < 1) {\n    return SHARED_MEMORY_NONE;\n  }\n #endif\n \n  int shmkey = shmget(IPC_PRIVATE, 1, 0600);\n  if (shmkey == -1) {\n    LOG(WARNING) << \"Failed to get shared memory segment.\";\n     return SHARED_MEMORY_NONE;\n  } else {\n    VLOG(1) << \"Got shared memory segment \" << shmkey;\n  }\n\n   void* address = shmat(shmkey, NULL, 0);\n   shmctl(shmkey, IPC_RMID, NULL);\n\n  XShmSegmentInfo shminfo;\n  memset(&shminfo, 0, sizeof(shminfo));\n  shminfo.shmid = shmkey;\n \n   gdk_error_trap_push();\n   bool result = XShmAttach(dpy, &shminfo);\n  if (result)\n    VLOG(1) << \"X got shared memory segment \" << shmkey;\n  else\n    LOG(WARNING) << \"X failed to attach to shared memory segment \" << shmkey;\n   XSync(dpy, False);\n   if (gdk_error_trap_pop())\n     result = false;\n   shmdt(address);\n  if (!result) {\n    LOG(WARNING) << \"X failed to attach to shared memory segment \" << shmkey;\n     return SHARED_MEMORY_NONE;\n  }\n\n  VLOG(1) << \"X attached to shared memory segment \" << shmkey;\n \n   XShmDetach(dpy, &shminfo);\n   return pixmaps_supported ? SHARED_MEMORY_PIXMAP : SHARED_MEMORY_PUTIMAGE;\n}\n",
    "cwe": [
      "CWE-264"
    ],
    "id": 64,
    "_valid_cwes": [
      "CWE-264"
    ]
  },
  {
    "cve_id": "CVE-2011-4127",
    "code_before_change": " int scsi_cmd_blk_ioctl(struct block_device *bd, fmode_t mode,\n \t\t       unsigned int cmd, void __user *arg)\n {\n \treturn scsi_cmd_ioctl(bd->bd_disk->queue, bd->bd_disk, mode, cmd, arg);\n }\n",
    "code_after_change": " int scsi_cmd_blk_ioctl(struct block_device *bd, fmode_t mode,\n \t\t       unsigned int cmd, void __user *arg)\n {\n\tint ret;\n\n\tret = scsi_verify_blk_ioctl(bd, cmd);\n\tif (ret < 0)\n\t\treturn ret;\n\n \treturn scsi_cmd_ioctl(bd->bd_disk->queue, bd->bd_disk, mode, cmd, arg);\n }\n",
    "cwe": [
      "CWE-264"
    ],
    "id": 79,
    "_valid_cwes": [
      "CWE-264"
    ]
  },
  {
    "cve_id": "CVE-2016-1636",
    "code_before_change": "void WebRunnerBrowserMainParts::PreMainMessageLoopRun() {\n  DCHECK(!screen_);\n\n  auto platform_screen = ui::OzonePlatform::GetInstance()->CreateScreen();\n  if (platform_screen) {\n    screen_ = std::make_unique<aura::ScreenOzone>(std::move(platform_screen));\n  } else {\n    screen_ = std::make_unique<WebRunnerScreen>();\n  }\n\n  display::Screen::SetScreenInstance(screen_.get());\n\n  DCHECK(!browser_context_);\n   browser_context_ =\n       std::make_unique<WebRunnerBrowserContext>(GetWebContextDataDir());\n \n  fidl::InterfaceRequest<chromium::web::Context> context_request(\n      std::move(context_channel_));\n \n  context_impl_ = std::make_unique<ContextImpl>(browser_context_.get());\n   context_binding_ = std::make_unique<fidl::Binding<chromium::web::Context>>(\n      context_impl_.get(), std::move(context_request));\n \n  context_binding_->set_error_handler(\n      [this]() { std::move(quit_closure_).Run(); });\n }\n",
    "code_after_change": "void WebRunnerBrowserMainParts::PreMainMessageLoopRun() {\n  DCHECK(!screen_);\n\n  auto platform_screen = ui::OzonePlatform::GetInstance()->CreateScreen();\n  if (platform_screen) {\n    screen_ = std::make_unique<aura::ScreenOzone>(std::move(platform_screen));\n  } else {\n    screen_ = std::make_unique<WebRunnerScreen>();\n  }\n\n  display::Screen::SetScreenInstance(screen_.get());\n\n  DCHECK(!browser_context_);\n   browser_context_ =\n       std::make_unique<WebRunnerBrowserContext>(GetWebContextDataDir());\n \n  context_service_ = std::make_unique<ContextImpl>(browser_context_.get());\n \n   context_binding_ = std::make_unique<fidl::Binding<chromium::web::Context>>(\n      context_service_.get(), fidl::InterfaceRequest<chromium::web::Context>(\n                                  std::move(context_channel_)));\n \n  // Quit the browser main loop when the Context connection is dropped.\n  context_binding_->set_error_handler([this]() {\n    DLOG(WARNING) << \"Client connection to Context service dropped.\";\n    context_service_.reset();\n    std::move(quit_closure_).Run();\n  });\n }\n",
    "cwe": [
      "CWE-264"
    ],
    "id": 88,
    "_valid_cwes": [
      "CWE-264"
    ]
  },
  {
    "cve_id": "CVE-2014-1846",
    "code_before_change": "main(int argc,\n     char **argv)\n{\n   int i, gn;\n   int test = 0;\n   char *action = NULL, *cmd;\n   char *output = NULL;\n#ifdef HAVE_EEZE_MOUNT\n   Eina_Bool mnt = EINA_FALSE;\n   const char *act;\n#endif\n   gid_t gid, gl[65536], egid;\n   int pid = 0;\n\n   for (i = 1; i < argc; i++)\n    const char *act;\n #endif\n    gid_t gid, gl[65536], egid;\n   int pid = 0;\n \n    for (i = 1; i < argc; i++)\n      {\n               \"This is an internal tool for Enlightenment.\\n\"\n               \"do not use it.\\n\"\n               );\n             exit(0);\n          }\n     }\n",
    "code_after_change": "main(int argc,\n     char **argv)\n{\n   int i, gn;\n   int test = 0;\n   char *action = NULL, *cmd;\n   char *output = NULL;\n#ifdef HAVE_EEZE_MOUNT\n   Eina_Bool mnt = EINA_FALSE;\n   const char *act;\n#endif\n   gid_t gid, gl[65536], egid;\n   int pid = 0;\n\n   for (i = 1; i < argc; i++)\n    const char *act;\n #endif\n    gid_t gid, gl[65536], egid;\n \n    for (i = 1; i < argc; i++)\n      {\n               \"This is an internal tool for Enlightenment.\\n\"\n               \"do not use it.\\n\"\n               );\n             exit(0);\n          }\n     }\n",
    "cwe": [
      "CWE-264"
    ],
    "id": 97,
    "_valid_cwes": [
      "CWE-264"
    ]
  },
  {
    "cve_id": "CVE-2015-1342",
    "code_before_change": " static int cg_rmdir(const char *path)\n {\n \tstruct fuse_context *fc = fuse_get_context();\n\tchar *fpath = NULL, *cgdir = NULL, *controller;\n \tconst char *cgroup;\n \tint ret;\n \n\tif (!fc)\n\t\treturn -EIO;\n\n\tcontroller = pick_controller_from_path(fc, path);\n\tif (!controller)\n\t\treturn -EINVAL;\n\n\tcgroup = find_cgroup_in_path(path);\n\tif (!cgroup)\n\t\treturn -EINVAL;\n\n\tget_cgdir_and_path(cgroup, &cgdir, &fpath);\n\tif (!fpath) {\n\t\tret = -EINVAL;\n \t\tgoto out;\n \t}\n \n\tfprintf(stderr, \"rmdir: verifying access to %s:%s (req path %s)\\n\",\n\t\t\tcontroller, cgdir, path);\n \tif (!fc_may_access(fc, controller, cgdir, NULL, O_WRONLY)) {\n \t\tret = -EACCES;\n \t\tgoto out;\n\t}\n\tif (!caller_is_in_ancestor(fc->pid, controller, cgroup, NULL)) {\n\t\tret = -EACCES;\n\t\tgoto out;\n\t}\n\n\tif (!cgfs_remove(controller, cgroup)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = 0;\n \n out:\n \tfree(cgdir);\n \treturn ret;\n }\n",
    "code_after_change": " static int cg_rmdir(const char *path)\n {\n \tstruct fuse_context *fc = fuse_get_context();\n\tchar *fpath = NULL, *cgdir = NULL, *controller, *next = NULL;\n \tconst char *cgroup;\n \tint ret;\n \n\tif (!fc)\n\t\treturn -EIO;\n\n\tcontroller = pick_controller_from_path(fc, path);\n\tif (!controller)\n\t\treturn -EINVAL;\n\n\tcgroup = find_cgroup_in_path(path);\n\tif (!cgroup)\n\t\treturn -EINVAL;\n\n\tget_cgdir_and_path(cgroup, &cgdir, &fpath);\n\tif (!fpath) {\n\t\tret = -EINVAL;\n \t\tgoto out;\n \t}\n \n\tif (!caller_is_in_ancestor(fc->pid, controller, cgroup, &next)) {\n\t\tif (!fpath || strcmp(next, fpath) == 0)\n\t\t\tret = -EBUSY;\n\t\telse\n\t\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n \tif (!fc_may_access(fc, controller, cgdir, NULL, O_WRONLY)) {\n \t\tret = -EACCES;\n \t\tgoto out;\n\t}\n\tif (!caller_is_in_ancestor(fc->pid, controller, cgroup, NULL)) {\n\t\tret = -EACCES;\n\t\tgoto out;\n\t}\n\n\tif (!cgfs_remove(controller, cgroup)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = 0;\n \n out:\n \tfree(cgdir);\n\tfree(next);\n \treturn ret;\n }\n",
    "cwe": [
      "CWE-264"
    ],
    "id": 103,
    "_valid_cwes": [
      "CWE-264"
    ]
  },
  {
    "cve_id": "CVE-2016-3890",
    "code_before_change": "static void local_socket_close(asocket* s) {\n    adb_mutex_lock(&socket_list_lock);\n    local_socket_close_locked(s);\n    adb_mutex_unlock(&socket_list_lock);\n}\n",
    "code_after_change": "static void local_socket_close(asocket* s) {\n",
    "cwe": [
      "CWE-264"
    ],
    "id": 123,
    "_valid_cwes": [
      "CWE-264"
    ]
  },
  {
    "cve_id": "CVE-2014-0185",
    "code_before_change": "int fpm_unix_resolve_socket_premissions(struct fpm_worker_pool_s *wp) /* {{{ */\n{\n\tstruct fpm_worker_pool_config_s *c = wp->config;\n\n \t/* uninitialized */\n \twp->socket_uid = -1;\n \twp->socket_gid = -1;\n\twp->socket_mode = 0666;\n \n \tif (!c) {\n \t\treturn 0;\n\t}\n\n\tif (c->listen_owner && *c->listen_owner) {\n\t\tstruct passwd *pwd;\n\n\t\tpwd = getpwnam(c->listen_owner);\n\t\tif (!pwd) {\n\t\t\tzlog(ZLOG_SYSERROR, \"[pool %s] cannot get uid for user '%s'\", wp->config->name, c->listen_owner);\n\t\t\treturn -1;\n\t\t}\n\n\t\twp->socket_uid = pwd->pw_uid;\n\t\twp->socket_gid = pwd->pw_gid;\n\t}\n\n\tif (c->listen_group && *c->listen_group) {\n\t\tstruct group *grp;\n\n\t\tgrp = getgrnam(c->listen_group);\n\t\tif (!grp) {\n\t\t\tzlog(ZLOG_SYSERROR, \"[pool %s] cannot get gid for group '%s'\", wp->config->name, c->listen_group);\n\t\t\treturn -1;\n\t\t}\n\t\twp->socket_gid = grp->gr_gid;\n\t}\n\n\tif (c->listen_mode && *c->listen_mode) {\n\t\twp->socket_mode = strtoul(c->listen_mode, 0, 8);\n\t}\n\treturn 0;\n}\n/* }}} */\n",
    "code_after_change": "int fpm_unix_resolve_socket_premissions(struct fpm_worker_pool_s *wp) /* {{{ */\n{\n\tstruct fpm_worker_pool_config_s *c = wp->config;\n\n \t/* uninitialized */\n \twp->socket_uid = -1;\n \twp->socket_gid = -1;\n\twp->socket_mode = 0660;\n \n \tif (!c) {\n \t\treturn 0;\n\t}\n\n\tif (c->listen_owner && *c->listen_owner) {\n\t\tstruct passwd *pwd;\n\n\t\tpwd = getpwnam(c->listen_owner);\n\t\tif (!pwd) {\n\t\t\tzlog(ZLOG_SYSERROR, \"[pool %s] cannot get uid for user '%s'\", wp->config->name, c->listen_owner);\n\t\t\treturn -1;\n\t\t}\n\n\t\twp->socket_uid = pwd->pw_uid;\n\t\twp->socket_gid = pwd->pw_gid;\n\t}\n\n\tif (c->listen_group && *c->listen_group) {\n\t\tstruct group *grp;\n\n\t\tgrp = getgrnam(c->listen_group);\n\t\tif (!grp) {\n\t\t\tzlog(ZLOG_SYSERROR, \"[pool %s] cannot get gid for group '%s'\", wp->config->name, c->listen_group);\n\t\t\treturn -1;\n\t\t}\n\t\twp->socket_gid = grp->gr_gid;\n\t}\n\n\tif (c->listen_mode && *c->listen_mode) {\n\t\twp->socket_mode = strtoul(c->listen_mode, 0, 8);\n\t}\n\treturn 0;\n}\n/* }}} */\n",
    "cwe": [
      "CWE-264"
    ],
    "id": 160,
    "_valid_cwes": [
      "CWE-264"
    ]
  },
  {
    "cve_id": "CVE-2014-3646",
    "code_before_change": "static bool nested_vmx_exit_handled(struct kvm_vcpu *vcpu)\n{\n\tu32 intr_info = vmcs_read32(VM_EXIT_INTR_INFO);\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\tu32 exit_reason = vmx->exit_reason;\n\n\ttrace_kvm_nested_vmexit(kvm_rip_read(vcpu), exit_reason,\n\t\t\t\tvmcs_readl(EXIT_QUALIFICATION),\n\t\t\t\tvmx->idt_vectoring_info,\n\t\t\t\tintr_info,\n\t\t\t\tvmcs_read32(VM_EXIT_INTR_ERROR_CODE),\n\t\t\t\tKVM_ISA_VMX);\n\n\tif (vmx->nested.nested_run_pending)\n\t\treturn 0;\n\n\tif (unlikely(vmx->fail)) {\n\t\tpr_info_ratelimited(\"%s failed vm entry %x\\n\", __func__,\n\t\t\t\t    vmcs_read32(VM_INSTRUCTION_ERROR));\n\t\treturn 1;\n\t}\n\n\tswitch (exit_reason) {\n\tcase EXIT_REASON_EXCEPTION_NMI:\n\t\tif (!is_exception(intr_info))\n\t\t\treturn 0;\n\t\telse if (is_page_fault(intr_info))\n\t\t\treturn enable_ept;\n\t\telse if (is_no_device(intr_info) &&\n\t\t\t !(vmcs12->guest_cr0 & X86_CR0_TS))\n\t\t\treturn 0;\n\t\treturn vmcs12->exception_bitmap &\n\t\t\t\t(1u << (intr_info & INTR_INFO_VECTOR_MASK));\n\tcase EXIT_REASON_EXTERNAL_INTERRUPT:\n\t\treturn 0;\n\tcase EXIT_REASON_TRIPLE_FAULT:\n\t\treturn 1;\n\tcase EXIT_REASON_PENDING_INTERRUPT:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_VIRTUAL_INTR_PENDING);\n\tcase EXIT_REASON_NMI_WINDOW:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_VIRTUAL_NMI_PENDING);\n\tcase EXIT_REASON_TASK_SWITCH:\n\t\treturn 1;\n\tcase EXIT_REASON_CPUID:\n\t\tif (kvm_register_read(vcpu, VCPU_REGS_RAX) == 0xa)\n\t\t\treturn 0;\n\t\treturn 1;\n\tcase EXIT_REASON_HLT:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_HLT_EXITING);\n\tcase EXIT_REASON_INVD:\n\t\treturn 1;\n\tcase EXIT_REASON_INVLPG:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_INVLPG_EXITING);\n\tcase EXIT_REASON_RDPMC:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_RDPMC_EXITING);\n\tcase EXIT_REASON_RDTSC:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_RDTSC_EXITING);\n\tcase EXIT_REASON_VMCALL: case EXIT_REASON_VMCLEAR:\n\tcase EXIT_REASON_VMLAUNCH: case EXIT_REASON_VMPTRLD:\n \tcase EXIT_REASON_VMPTRST: case EXIT_REASON_VMREAD:\n \tcase EXIT_REASON_VMRESUME: case EXIT_REASON_VMWRITE:\n \tcase EXIT_REASON_VMOFF: case EXIT_REASON_VMON:\n\tcase EXIT_REASON_INVEPT:\n \t\t/*\n \t\t * VMX instructions trap unconditionally. This allows L1 to\n \t\t * emulate them for its L2 guest, i.e., allows 3-level nesting!\n\t\t */\n\t\treturn 1;\n\tcase EXIT_REASON_CR_ACCESS:\n\t\treturn nested_vmx_exit_handled_cr(vcpu, vmcs12);\n\tcase EXIT_REASON_DR_ACCESS:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_MOV_DR_EXITING);\n\tcase EXIT_REASON_IO_INSTRUCTION:\n\t\treturn nested_vmx_exit_handled_io(vcpu, vmcs12);\n\tcase EXIT_REASON_MSR_READ:\n\tcase EXIT_REASON_MSR_WRITE:\n\t\treturn nested_vmx_exit_handled_msr(vcpu, vmcs12, exit_reason);\n\tcase EXIT_REASON_INVALID_STATE:\n\t\treturn 1;\n\tcase EXIT_REASON_MWAIT_INSTRUCTION:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_MWAIT_EXITING);\n\tcase EXIT_REASON_MONITOR_INSTRUCTION:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_MONITOR_EXITING);\n\tcase EXIT_REASON_PAUSE_INSTRUCTION:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_PAUSE_EXITING) ||\n\t\t\tnested_cpu_has2(vmcs12,\n\t\t\t\tSECONDARY_EXEC_PAUSE_LOOP_EXITING);\n\tcase EXIT_REASON_MCE_DURING_VMENTRY:\n\t\treturn 0;\n\tcase EXIT_REASON_TPR_BELOW_THRESHOLD:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_TPR_SHADOW);\n\tcase EXIT_REASON_APIC_ACCESS:\n\t\treturn nested_cpu_has2(vmcs12,\n\t\t\tSECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES);\n\tcase EXIT_REASON_EPT_VIOLATION:\n\t\t/*\n\t\t * L0 always deals with the EPT violation. If nested EPT is\n\t\t * used, and the nested mmu code discovers that the address is\n\t\t * missing in the guest EPT table (EPT12), the EPT violation\n\t\t * will be injected with nested_ept_inject_page_fault()\n\t\t */\n\t\treturn 0;\n\tcase EXIT_REASON_EPT_MISCONFIG:\n\t\t/*\n\t\t * L2 never uses directly L1's EPT, but rather L0's own EPT\n\t\t * table (shadow on EPT) or a merged EPT table that L0 built\n\t\t * (EPT on EPT). So any problems with the structure of the\n\t\t * table is L0's fault.\n\t\t */\n\t\treturn 0;\n\tcase EXIT_REASON_WBINVD:\n\t\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_WBINVD_EXITING);\n\tcase EXIT_REASON_XSETBV:\n\t\treturn 1;\n\tdefault:\n\t\treturn 1;\n\t}\n}\n",
    "code_after_change": "static bool nested_vmx_exit_handled(struct kvm_vcpu *vcpu)\n{\n\tu32 intr_info = vmcs_read32(VM_EXIT_INTR_INFO);\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\tu32 exit_reason = vmx->exit_reason;\n\n\ttrace_kvm_nested_vmexit(kvm_rip_read(vcpu), exit_reason,\n\t\t\t\tvmcs_readl(EXIT_QUALIFICATION),\n\t\t\t\tvmx->idt_vectoring_info,\n\t\t\t\tintr_info,\n\t\t\t\tvmcs_read32(VM_EXIT_INTR_ERROR_CODE),\n\t\t\t\tKVM_ISA_VMX);\n\n\tif (vmx->nested.nested_run_pending)\n\t\treturn 0;\n\n\tif (unlikely(vmx->fail)) {\n\t\tpr_info_ratelimited(\"%s failed vm entry %x\\n\", __func__,\n\t\t\t\t    vmcs_read32(VM_INSTRUCTION_ERROR));\n\t\treturn 1;\n\t}\n\n\tswitch (exit_reason) {\n\tcase EXIT_REASON_EXCEPTION_NMI:\n\t\tif (!is_exception(intr_info))\n\t\t\treturn 0;\n\t\telse if (is_page_fault(intr_info))\n\t\t\treturn enable_ept;\n\t\telse if (is_no_device(intr_info) &&\n\t\t\t !(vmcs12->guest_cr0 & X86_CR0_TS))\n\t\t\treturn 0;\n\t\treturn vmcs12->exception_bitmap &\n\t\t\t\t(1u << (intr_info & INTR_INFO_VECTOR_MASK));\n\tcase EXIT_REASON_EXTERNAL_INTERRUPT:\n\t\treturn 0;\n\tcase EXIT_REASON_TRIPLE_FAULT:\n\t\treturn 1;\n\tcase EXIT_REASON_PENDING_INTERRUPT:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_VIRTUAL_INTR_PENDING);\n\tcase EXIT_REASON_NMI_WINDOW:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_VIRTUAL_NMI_PENDING);\n\tcase EXIT_REASON_TASK_SWITCH:\n\t\treturn 1;\n\tcase EXIT_REASON_CPUID:\n\t\tif (kvm_register_read(vcpu, VCPU_REGS_RAX) == 0xa)\n\t\t\treturn 0;\n\t\treturn 1;\n\tcase EXIT_REASON_HLT:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_HLT_EXITING);\n\tcase EXIT_REASON_INVD:\n\t\treturn 1;\n\tcase EXIT_REASON_INVLPG:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_INVLPG_EXITING);\n\tcase EXIT_REASON_RDPMC:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_RDPMC_EXITING);\n\tcase EXIT_REASON_RDTSC:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_RDTSC_EXITING);\n\tcase EXIT_REASON_VMCALL: case EXIT_REASON_VMCLEAR:\n\tcase EXIT_REASON_VMLAUNCH: case EXIT_REASON_VMPTRLD:\n \tcase EXIT_REASON_VMPTRST: case EXIT_REASON_VMREAD:\n \tcase EXIT_REASON_VMRESUME: case EXIT_REASON_VMWRITE:\n \tcase EXIT_REASON_VMOFF: case EXIT_REASON_VMON:\n\tcase EXIT_REASON_INVEPT: case EXIT_REASON_INVVPID:\n \t\t/*\n \t\t * VMX instructions trap unconditionally. This allows L1 to\n \t\t * emulate them for its L2 guest, i.e., allows 3-level nesting!\n\t\t */\n\t\treturn 1;\n\tcase EXIT_REASON_CR_ACCESS:\n\t\treturn nested_vmx_exit_handled_cr(vcpu, vmcs12);\n\tcase EXIT_REASON_DR_ACCESS:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_MOV_DR_EXITING);\n\tcase EXIT_REASON_IO_INSTRUCTION:\n\t\treturn nested_vmx_exit_handled_io(vcpu, vmcs12);\n\tcase EXIT_REASON_MSR_READ:\n\tcase EXIT_REASON_MSR_WRITE:\n\t\treturn nested_vmx_exit_handled_msr(vcpu, vmcs12, exit_reason);\n\tcase EXIT_REASON_INVALID_STATE:\n\t\treturn 1;\n\tcase EXIT_REASON_MWAIT_INSTRUCTION:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_MWAIT_EXITING);\n\tcase EXIT_REASON_MONITOR_INSTRUCTION:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_MONITOR_EXITING);\n\tcase EXIT_REASON_PAUSE_INSTRUCTION:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_PAUSE_EXITING) ||\n\t\t\tnested_cpu_has2(vmcs12,\n\t\t\t\tSECONDARY_EXEC_PAUSE_LOOP_EXITING);\n\tcase EXIT_REASON_MCE_DURING_VMENTRY:\n\t\treturn 0;\n\tcase EXIT_REASON_TPR_BELOW_THRESHOLD:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_TPR_SHADOW);\n\tcase EXIT_REASON_APIC_ACCESS:\n\t\treturn nested_cpu_has2(vmcs12,\n\t\t\tSECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES);\n\tcase EXIT_REASON_EPT_VIOLATION:\n\t\t/*\n\t\t * L0 always deals with the EPT violation. If nested EPT is\n\t\t * used, and the nested mmu code discovers that the address is\n\t\t * missing in the guest EPT table (EPT12), the EPT violation\n\t\t * will be injected with nested_ept_inject_page_fault()\n\t\t */\n\t\treturn 0;\n\tcase EXIT_REASON_EPT_MISCONFIG:\n\t\t/*\n\t\t * L2 never uses directly L1's EPT, but rather L0's own EPT\n\t\t * table (shadow on EPT) or a merged EPT table that L0 built\n\t\t * (EPT on EPT). So any problems with the structure of the\n\t\t * table is L0's fault.\n\t\t */\n\t\treturn 0;\n\tcase EXIT_REASON_WBINVD:\n\t\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_WBINVD_EXITING);\n\tcase EXIT_REASON_XSETBV:\n\t\treturn 1;\n\tdefault:\n\t\treturn 1;\n\t}\n}\n",
    "cwe": [
      "CWE-264"
    ],
    "id": 167,
    "_valid_cwes": [
      "CWE-264"
    ]
  },
  {
    "cve_id": "CVE-2014-8109",
    "code_before_change": "static const char *lua_authz_parse(cmd_parms *cmd, const char *require_line,\n                                   const void **parsed_require_line)\n {\n     const char *provider_name;\n     lua_authz_provider_spec *spec;\n \n     apr_pool_userdata_get((void**)&provider_name, AUTHZ_PROVIDER_NAME_NOTE,\n                           cmd->temp_pool);\n     ap_assert(provider_name != NULL);\n \n     spec = apr_hash_get(lua_authz_providers, provider_name, APR_HASH_KEY_STRING);\n     ap_assert(spec != NULL);\n \n     if (require_line && *require_line) {\n         const char *arg;\n        spec->args = apr_array_make(cmd->pool, 2, sizeof(const char *));\n         while ((arg = ap_getword_conf(cmd->pool, &require_line)) && *arg) {\n            APR_ARRAY_PUSH(spec->args, const char *) = arg;\n         }\n     }\n \n    *parsed_require_line = spec;\n     return NULL;\n }\n",
    "code_after_change": "static const char *lua_authz_parse(cmd_parms *cmd, const char *require_line,\n                                   const void **parsed_require_line)\n {\n     const char *provider_name;\n     lua_authz_provider_spec *spec;\n    lua_authz_provider_func *func = apr_pcalloc(cmd->pool, sizeof(lua_authz_provider_func));\n \n     apr_pool_userdata_get((void**)&provider_name, AUTHZ_PROVIDER_NAME_NOTE,\n                           cmd->temp_pool);\n     ap_assert(provider_name != NULL);\n \n     spec = apr_hash_get(lua_authz_providers, provider_name, APR_HASH_KEY_STRING);\n     ap_assert(spec != NULL);\n    func->spec = spec;\n \n     if (require_line && *require_line) {\n         const char *arg;\n        func->args = apr_array_make(cmd->pool, 2, sizeof(const char *));\n         while ((arg = ap_getword_conf(cmd->pool, &require_line)) && *arg) {\n            APR_ARRAY_PUSH(func->args, const char *) = arg;\n         }\n     }\n \n    *parsed_require_line = func;\n     return NULL;\n }\n",
    "cwe": [
      "CWE-264"
    ],
    "id": 178,
    "_valid_cwes": [
      "CWE-264"
    ]
  },
  {
    "cve_id": "CVE-2014-3610",
    "code_before_change": "static int wrmsr_interception(struct vcpu_svm *svm)\n{\n\tstruct msr_data msr;\n\tu32 ecx = svm->vcpu.arch.regs[VCPU_REGS_RCX];\n\tu64 data = (svm->vcpu.arch.regs[VCPU_REGS_RAX] & -1u)\n\t\t| ((u64)(svm->vcpu.arch.regs[VCPU_REGS_RDX] & -1u) << 32);\n\n\tmsr.data = data;\n\tmsr.index = ecx;\n \tmsr.host_initiated = false;\n \n \tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 2;\n\tif (svm_set_msr(&svm->vcpu, &msr)) {\n \t\ttrace_kvm_msr_write_ex(ecx, data);\n \t\tkvm_inject_gp(&svm->vcpu, 0);\n \t} else {\n\t\ttrace_kvm_msr_write(ecx, data);\n\t\tskip_emulated_instruction(&svm->vcpu);\n\t}\n\treturn 1;\n}\n",
    "code_after_change": "static int wrmsr_interception(struct vcpu_svm *svm)\n{\n\tstruct msr_data msr;\n\tu32 ecx = svm->vcpu.arch.regs[VCPU_REGS_RCX];\n\tu64 data = (svm->vcpu.arch.regs[VCPU_REGS_RAX] & -1u)\n\t\t| ((u64)(svm->vcpu.arch.regs[VCPU_REGS_RDX] & -1u) << 32);\n\n\tmsr.data = data;\n\tmsr.index = ecx;\n \tmsr.host_initiated = false;\n \n \tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 2;\n\tif (kvm_set_msr(&svm->vcpu, &msr)) {\n \t\ttrace_kvm_msr_write_ex(ecx, data);\n \t\tkvm_inject_gp(&svm->vcpu, 0);\n \t} else {\n\t\ttrace_kvm_msr_write(ecx, data);\n\t\tskip_emulated_instruction(&svm->vcpu);\n\t}\n\treturn 1;\n}\n",
    "cwe": [
      "CWE-264"
    ],
    "id": 181,
    "_valid_cwes": [
      "CWE-264"
    ]
  },
  {
    "cve_id": "CVE-2015-6520",
    "code_before_change": "struct tcp_sock_t *tcp_open(uint16_t port)\n {\n \tstruct tcp_sock_t *this = calloc(1, sizeof *this);\n \tif (this == NULL) {\n\t\tERR(\"callocing this failed\");\n \t\tgoto error;\n \t}\n \n \tthis->sd = -1;\n \tthis->sd = socket(AF_INET6, SOCK_STREAM, 0);\n \tif (this->sd < 0) {\n\t\tERR(\"sockect open failed\");\n \t\tgoto error;\n \t}\n \n\tstruct sockaddr_in6 addr;\n \tmemset(&addr, 0, sizeof addr);\n \taddr.sin6_family = AF_INET6;\n \taddr.sin6_port = htons(port);\n\taddr.sin6_addr = in6addr_any;\n \n \tif (bind(this->sd,\n \t        (struct sockaddr *)&addr,\n \t        sizeof addr) < 0) {\n \t\tif (g_options.only_desired_port == 1)\n\t\t\tERR(\"Bind on port failed. \"\n \t\t\t    \"Requested port may be taken or require root permissions.\");\n \t\tgoto error;\n \t}\n \n \tif (listen(this->sd, HTTP_MAX_PENDING_CONNS) < 0) {\n\t\tERR(\"listen failed on socket\");\n \t\tgoto error;\n \t}\n \n\treturn this;\n\nerror:\n\tif (this != NULL) {\n\t\tif (this->sd != -1) {\n\t\t\tclose(this->sd);\n\t\t}\n\t\tfree(this);\n\t}\n\treturn NULL;\n}\n",
    "code_after_change": "struct tcp_sock_t *tcp_open(uint16_t port)\n {\n \tstruct tcp_sock_t *this = calloc(1, sizeof *this);\n \tif (this == NULL) {\n\t\tERR(\"IPv4: callocing this failed\");\n\t\tgoto error;\n\t}\n\n\t// Open [S]ocket [D]escriptor\n\tthis->sd = -1;\n\tthis->sd = socket(AF_INET, SOCK_STREAM, 0);\n\tif (this->sd < 0) {\n\t\tERR(\"IPv4 socket open failed\");\n\t\tgoto error;\n\t}\n\n\t// Configure socket params\n\tstruct sockaddr_in addr;\n\tmemset(&addr, 0, sizeof addr);\n\taddr.sin_family = AF_INET;\n\taddr.sin_port = htons(port);\n\taddr.sin_addr.s_addr = htonl(0x7F000001);\n\n\t// Bind to localhost\n\tif (bind(this->sd,\n\t        (struct sockaddr *)&addr,\n\t        sizeof addr) < 0) {\n\t\tif (g_options.only_desired_port == 1)\n\t\t\tERR(\"IPv4 bind on port failed. \"\n\t\t\t    \"Requested port may be taken or require root permissions.\");\n\t\tgoto error;\n\t}\n\n\t// Let kernel over-accept max number of connections\n\tif (listen(this->sd, HTTP_MAX_PENDING_CONNS) < 0) {\n\t\tERR(\"IPv4 listen failed on socket\");\n\t\tgoto error;\n\t}\n\n\treturn this;\n\nerror:\n\tif (this != NULL) {\n\t\tif (this->sd != -1) {\n\t\t\tclose(this->sd);\n\t\t}\n\t\tfree(this);\n\t}\n\treturn NULL;\n}\n\nstruct tcp_sock_t *tcp6_open(uint16_t port)\n{\n\tstruct tcp_sock_t *this = calloc(1, sizeof *this);\n\tif (this == NULL) {\n\t\tERR(\"IPv6: callocing this failed\");\n \t\tgoto error;\n \t}\n \n \tthis->sd = -1;\n \tthis->sd = socket(AF_INET6, SOCK_STREAM, 0);\n \tif (this->sd < 0) {\n\t\tERR(\"Ipv6 socket open failed\");\n \t\tgoto error;\n \t}\n \n\tstruct sockaddr_in6 addr;\n \tmemset(&addr, 0, sizeof addr);\n \taddr.sin6_family = AF_INET6;\n \taddr.sin6_port = htons(port);\n\taddr.sin6_addr = in6addr_loopback;\n \n \tif (bind(this->sd,\n \t        (struct sockaddr *)&addr,\n \t        sizeof addr) < 0) {\n \t\tif (g_options.only_desired_port == 1)\n\t\t\tERR(\"IPv6 bind on port failed. \"\n \t\t\t    \"Requested port may be taken or require root permissions.\");\n \t\tgoto error;\n \t}\n \n \tif (listen(this->sd, HTTP_MAX_PENDING_CONNS) < 0) {\n\t\tERR(\"IPv6 listen failed on socket\");\n \t\tgoto error;\n \t}\n \n\treturn this;\n\nerror:\n\tif (this != NULL) {\n\t\tif (this->sd != -1) {\n\t\t\tclose(this->sd);\n\t\t}\n\t\tfree(this);\n\t}\n\treturn NULL;\n}\n",
    "cwe": [
      "CWE-264"
    ],
    "id": 197,
    "_valid_cwes": [
      "CWE-264"
    ]
  },
  {
    "cve_id": "CVE-2016-0810",
    "code_before_change": "int SoundPool::play(int sampleID, float leftVolume, float rightVolume,\n int priority, int loop, float rate)\n\n {\n     ALOGV(\"play sampleID=%d, leftVolume=%f, rightVolume=%f, priority=%d, loop=%d, rate=%f\",\n             sampleID, leftVolume, rightVolume, priority, loop, rate);\n    sp<Sample> sample;\n     SoundChannel* channel;\n     int channelID;\n \n Mutex::Autolock lock(&mLock);\n\n if (mQuit) {\n\n         return 0;\n     }\n    sample = findSample(sampleID);\n     if ((sample == 0) || (sample->state() != Sample::READY)) {\n         ALOGW(\"  sample %d not READY\", sampleID);\n         return 0;\n }\n\n    dump();\n\n    channel = allocateChannel_l(priority);\n\n if (!channel) {\n        ALOGV(\"No channel allocated\");\n return 0;\n }\n\n    channelID = ++mNextChannelID;\n\n    ALOGV(\"play channel %p state = %d\", channel, channel->state());\n    channel->play(sample, channelID, leftVolume, rightVolume, priority, loop, rate);\n return channelID;\n}\n",
    "code_after_change": "int SoundPool::play(int sampleID, float leftVolume, float rightVolume,\n int priority, int loop, float rate)\n\n {\n     ALOGV(\"play sampleID=%d, leftVolume=%f, rightVolume=%f, priority=%d, loop=%d, rate=%f\",\n             sampleID, leftVolume, rightVolume, priority, loop, rate);\n     SoundChannel* channel;\n     int channelID;\n \n Mutex::Autolock lock(&mLock);\n\n if (mQuit) {\n\n         return 0;\n     }\n    sp<Sample> sample(findSample_l(sampleID));\n     if ((sample == 0) || (sample->state() != Sample::READY)) {\n         ALOGW(\"  sample %d not READY\", sampleID);\n         return 0;\n }\n\n    dump();\n\n    channel = allocateChannel_l(priority);\n\n if (!channel) {\n        ALOGV(\"No channel allocated\");\n return 0;\n }\n\n    channelID = ++mNextChannelID;\n\n    ALOGV(\"play channel %p state = %d\", channel, channel->state());\n    channel->play(sample, channelID, leftVolume, rightVolume, priority, loop, rate);\n return channelID;\n}\n",
    "cwe": [
      "CWE-264"
    ],
    "id": 255,
    "_valid_cwes": [
      "CWE-264"
    ]
  },
  {
    "cve_id": "CVE-2016-3910",
    "code_before_change": "status_t SoundTriggerHwService::Module::loadSoundModel(const sp<IMemory>& modelMemory,\n sound_model_handle_t *handle)\n{\n    ALOGV(\"loadSoundModel() handle\");\n if (!captureHotwordAllowed()) {\n return PERMISSION_DENIED;\n }\n\n if (modelMemory == 0 || modelMemory->pointer() == NULL) {\n        ALOGE(\"loadSoundModel() modelMemory is 0 or has NULL pointer()\");\n return BAD_VALUE;\n }\n\n     struct sound_trigger_sound_model *sound_model =\n             (struct sound_trigger_sound_model *)modelMemory->pointer();\n \n     AutoMutex lock(mLock);\n \n     if (mModels.size() >= mDescriptor.properties.max_sound_models) {\n        ALOGW(\"loadSoundModel(): Not loading, max number of models (%d) would be exceeded\",\n              mDescriptor.properties.max_sound_models);\n return INVALID_OPERATION;\n }\n\n status_t status = mHwDevice->load_sound_model(mHwDevice, sound_model,\n SoundTriggerHwService::soundModelCallback,\n this, handle);\n\n if (status != NO_ERROR) {\n return status;\n }\n audio_session_t session;\n audio_io_handle_t ioHandle;\n audio_devices_t device;\n\n    status = AudioSystem::acquireSoundTriggerSession(&session, &ioHandle, &device);\n if (status != NO_ERROR) {\n return status;\n }\n\n    sp<Model> model = new Model(*handle, session, ioHandle, device, sound_model->type);\n    mModels.replaceValueFor(*handle, model);\n\n return status;\n}\n",
    "code_after_change": "status_t SoundTriggerHwService::Module::loadSoundModel(const sp<IMemory>& modelMemory,\n sound_model_handle_t *handle)\n{\n    ALOGV(\"loadSoundModel() handle\");\n if (!captureHotwordAllowed()) {\n return PERMISSION_DENIED;\n }\n\n if (modelMemory == 0 || modelMemory->pointer() == NULL) {\n        ALOGE(\"loadSoundModel() modelMemory is 0 or has NULL pointer()\");\n return BAD_VALUE;\n }\n\n     struct sound_trigger_sound_model *sound_model =\n             (struct sound_trigger_sound_model *)modelMemory->pointer();\n \n    size_t structSize;\n    if (sound_model->type == SOUND_MODEL_TYPE_KEYPHRASE) {\n        structSize = sizeof(struct sound_trigger_phrase_sound_model);\n    } else {\n        structSize = sizeof(struct sound_trigger_sound_model);\n    }\n\n    if (sound_model->data_offset < structSize ||\n           sound_model->data_size > (UINT_MAX - sound_model->data_offset) ||\n           modelMemory->size() < sound_model->data_offset ||\n           sound_model->data_size > (modelMemory->size() - sound_model->data_offset)) {\n        android_errorWriteLog(0x534e4554, \"30148546\");\n        ALOGE(\"loadSoundModel() data_size is too big\");\n        return BAD_VALUE;\n    }\n\n     AutoMutex lock(mLock);\n \n     if (mModels.size() >= mDescriptor.properties.max_sound_models) {\n        ALOGW(\"loadSoundModel(): Not loading, max number of models (%d) would be exceeded\",\n              mDescriptor.properties.max_sound_models);\n return INVALID_OPERATION;\n }\n\n status_t status = mHwDevice->load_sound_model(mHwDevice, sound_model,\n SoundTriggerHwService::soundModelCallback,\n this, handle);\n\n if (status != NO_ERROR) {\n return status;\n }\n audio_session_t session;\n audio_io_handle_t ioHandle;\n audio_devices_t device;\n\n    status = AudioSystem::acquireSoundTriggerSession(&session, &ioHandle, &device);\n if (status != NO_ERROR) {\n return status;\n }\n\n    sp<Model> model = new Model(*handle, session, ioHandle, device, sound_model->type);\n    mModels.replaceValueFor(*handle, model);\n\n return status;\n}\n",
    "cwe": [
      "CWE-264"
    ],
    "id": 257,
    "_valid_cwes": [
      "CWE-264"
    ]
  },
  {
    "cve_id": "CVE-2016-3871",
    "code_before_change": "void SoftMP3::onQueueFilled(OMX_U32 /* portIndex */) {\n if (mSignalledError || mOutputPortSettingsChange != NONE) {\n return;\n }\n\n List<BufferInfo *> &inQueue = getPortQueue(0);\n List<BufferInfo *> &outQueue = getPortQueue(1);\n\n while ((!inQueue.empty() || (mSawInputEos && !mSignalledOutputEos)) && !outQueue.empty()) {\n BufferInfo *inInfo = NULL;\n        OMX_BUFFERHEADERTYPE *inHeader = NULL;\n if (!inQueue.empty()) {\n            inInfo = *inQueue.begin();\n            inHeader = inInfo->mHeader;\n }\n\n BufferInfo *outInfo = *outQueue.begin();\n        OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;\n        outHeader->nFlags = 0;\n\n if (inHeader) {\n if (inHeader->nOffset == 0 && inHeader->nFilledLen) {\n                mAnchorTimeUs = inHeader->nTimeStamp;\n                mNumFramesOutput = 0;\n }\n\n if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {\n                mSawInputEos = true;\n }\n\n            mConfig->pInputBuffer =\n                inHeader->pBuffer + inHeader->nOffset;\n\n            mConfig->inputBufferCurrentLength = inHeader->nFilledLen;\n } else {\n            mConfig->pInputBuffer = NULL;\n            mConfig->inputBufferCurrentLength = 0;\n }\n        mConfig->inputBufferMaxLength = 0;\n        mConfig->inputBufferUsedLength = 0;\n\n        mConfig->outputFrameSize = kOutputBufferSize / sizeof(int16_t);\n if ((int32)outHeader->nAllocLen < mConfig->outputFrameSize) {\n            ALOGE(\"input buffer too small: got %u, expected %u\",\n                outHeader->nAllocLen, mConfig->outputFrameSize);\n            android_errorWriteLog(0x534e4554, \"27793371\");\n            notify(OMX_EventError, OMX_ErrorUndefined, OUTPUT_BUFFER_TOO_SMALL, NULL);\n            mSignalledError = true;\n return;\n }\n\n        mConfig->pOutputBuffer =\n reinterpret_cast<int16_t *>(outHeader->pBuffer);\n\n        ERROR_CODE decoderErr;\n if ((decoderErr = pvmp3_framedecoder(mConfig, mDecoderBuf))\n != NO_DECODING_ERROR) {\n            ALOGV(\"mp3 decoder returned error %d\", decoderErr);\n\n if (decoderErr != NO_ENOUGH_MAIN_DATA_ERROR\n && decoderErr != SIDE_INFO_ERROR) {\n                ALOGE(\"mp3 decoder returned error %d\", decoderErr);\n\n                notify(OMX_EventError, OMX_ErrorUndefined, decoderErr, NULL);\n                mSignalledError = true;\n return;\n }\n\n if (mConfig->outputFrameSize == 0) {\n                mConfig->outputFrameSize = kOutputBufferSize / sizeof(int16_t);\n }\n\n if (decoderErr == NO_ENOUGH_MAIN_DATA_ERROR && mSawInputEos) {\n if (!mIsFirst) {\n\n                     outHeader->nOffset = 0;\n                     outHeader->nFilledLen = kPVMP3DecoderDelay * mNumChannels * sizeof(int16_t);\n \n                    memset(outHeader->pBuffer, 0, outHeader->nFilledLen);\n                 }\n                 outHeader->nFlags = OMX_BUFFERFLAG_EOS;\n                 mSignalledOutputEos = true;\n } else {\n\n\n                 ALOGV_IF(mIsFirst, \"insufficient data for first frame, sending silence\");\n                memset(outHeader->pBuffer,\n                       0,\n                       mConfig->outputFrameSize * sizeof(int16_t));\n \n                 if (inHeader) {\n                     mConfig->inputBufferUsedLength = inHeader->nFilledLen;\n }\n }\n } else if (mConfig->samplingRate != mSamplingRate\n || mConfig->num_channels != mNumChannels) {\n            mSamplingRate = mConfig->samplingRate;\n            mNumChannels = mConfig->num_channels;\n\n            notify(OMX_EventPortSettingsChanged, 1, 0, NULL);\n            mOutputPortSettingsChange = AWAITING_DISABLED;\n return;\n }\n\n if (mIsFirst) {\n            mIsFirst = false;\n            outHeader->nOffset =\n                kPVMP3DecoderDelay * mNumChannels * sizeof(int16_t);\n\n            outHeader->nFilledLen =\n                mConfig->outputFrameSize * sizeof(int16_t) - outHeader->nOffset;\n } else if (!mSignalledOutputEos) {\n            outHeader->nOffset = 0;\n            outHeader->nFilledLen = mConfig->outputFrameSize * sizeof(int16_t);\n }\n\n        outHeader->nTimeStamp =\n            mAnchorTimeUs + (mNumFramesOutput * 1000000ll) / mSamplingRate;\n\n if (inHeader) {\n            CHECK_GE(inHeader->nFilledLen, mConfig->inputBufferUsedLength);\n\n            inHeader->nOffset += mConfig->inputBufferUsedLength;\n            inHeader->nFilledLen -= mConfig->inputBufferUsedLength;\n\n\n if (inHeader->nFilledLen == 0) {\n                inInfo->mOwnedByUs = false;\n                inQueue.erase(inQueue.begin());\n                inInfo = NULL;\n                notifyEmptyBufferDone(inHeader);\n                inHeader = NULL;\n }\n }\n\n        mNumFramesOutput += mConfig->outputFrameSize / mNumChannels;\n\n        outInfo->mOwnedByUs = false;\n        outQueue.erase(outQueue.begin());\n        outInfo = NULL;\n        notifyFillBufferDone(outHeader);\n        outHeader = NULL;\n }\n}\n",
    "code_after_change": "void SoftMP3::onQueueFilled(OMX_U32 /* portIndex */) {\n if (mSignalledError || mOutputPortSettingsChange != NONE) {\n return;\n }\n\n List<BufferInfo *> &inQueue = getPortQueue(0);\n List<BufferInfo *> &outQueue = getPortQueue(1);\n\n while ((!inQueue.empty() || (mSawInputEos && !mSignalledOutputEos)) && !outQueue.empty()) {\n BufferInfo *inInfo = NULL;\n        OMX_BUFFERHEADERTYPE *inHeader = NULL;\n if (!inQueue.empty()) {\n            inInfo = *inQueue.begin();\n            inHeader = inInfo->mHeader;\n }\n\n BufferInfo *outInfo = *outQueue.begin();\n        OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;\n        outHeader->nFlags = 0;\n\n if (inHeader) {\n if (inHeader->nOffset == 0 && inHeader->nFilledLen) {\n                mAnchorTimeUs = inHeader->nTimeStamp;\n                mNumFramesOutput = 0;\n }\n\n if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {\n                mSawInputEos = true;\n }\n\n            mConfig->pInputBuffer =\n                inHeader->pBuffer + inHeader->nOffset;\n\n            mConfig->inputBufferCurrentLength = inHeader->nFilledLen;\n } else {\n            mConfig->pInputBuffer = NULL;\n            mConfig->inputBufferCurrentLength = 0;\n }\n        mConfig->inputBufferMaxLength = 0;\n        mConfig->inputBufferUsedLength = 0;\n\n        mConfig->outputFrameSize = kOutputBufferSize / sizeof(int16_t);\n if ((int32)outHeader->nAllocLen < mConfig->outputFrameSize) {\n            ALOGE(\"input buffer too small: got %u, expected %u\",\n                outHeader->nAllocLen, mConfig->outputFrameSize);\n            android_errorWriteLog(0x534e4554, \"27793371\");\n            notify(OMX_EventError, OMX_ErrorUndefined, OUTPUT_BUFFER_TOO_SMALL, NULL);\n            mSignalledError = true;\n return;\n }\n\n        mConfig->pOutputBuffer =\n reinterpret_cast<int16_t *>(outHeader->pBuffer);\n\n        ERROR_CODE decoderErr;\n if ((decoderErr = pvmp3_framedecoder(mConfig, mDecoderBuf))\n != NO_DECODING_ERROR) {\n            ALOGV(\"mp3 decoder returned error %d\", decoderErr);\n\n if (decoderErr != NO_ENOUGH_MAIN_DATA_ERROR\n && decoderErr != SIDE_INFO_ERROR) {\n                ALOGE(\"mp3 decoder returned error %d\", decoderErr);\n\n                notify(OMX_EventError, OMX_ErrorUndefined, decoderErr, NULL);\n                mSignalledError = true;\n return;\n }\n\n if (mConfig->outputFrameSize == 0) {\n                mConfig->outputFrameSize = kOutputBufferSize / sizeof(int16_t);\n }\n\n if (decoderErr == NO_ENOUGH_MAIN_DATA_ERROR && mSawInputEos) {\n if (!mIsFirst) {\n\n                     outHeader->nOffset = 0;\n                     outHeader->nFilledLen = kPVMP3DecoderDelay * mNumChannels * sizeof(int16_t);\n \n                    if (!memsetSafe(outHeader, 0, outHeader->nFilledLen)) {\n                        return;\n                    }\n\n                 }\n                 outHeader->nFlags = OMX_BUFFERFLAG_EOS;\n                 mSignalledOutputEos = true;\n } else {\n\n\n                 ALOGV_IF(mIsFirst, \"insufficient data for first frame, sending silence\");\n                if (!memsetSafe(outHeader, 0, mConfig->outputFrameSize * sizeof(int16_t))) {\n                    return;\n                }\n \n                 if (inHeader) {\n                     mConfig->inputBufferUsedLength = inHeader->nFilledLen;\n }\n }\n } else if (mConfig->samplingRate != mSamplingRate\n || mConfig->num_channels != mNumChannels) {\n            mSamplingRate = mConfig->samplingRate;\n            mNumChannels = mConfig->num_channels;\n\n            notify(OMX_EventPortSettingsChanged, 1, 0, NULL);\n            mOutputPortSettingsChange = AWAITING_DISABLED;\n return;\n }\n\n if (mIsFirst) {\n            mIsFirst = false;\n            outHeader->nOffset =\n                kPVMP3DecoderDelay * mNumChannels * sizeof(int16_t);\n\n            outHeader->nFilledLen =\n                mConfig->outputFrameSize * sizeof(int16_t) - outHeader->nOffset;\n } else if (!mSignalledOutputEos) {\n            outHeader->nOffset = 0;\n            outHeader->nFilledLen = mConfig->outputFrameSize * sizeof(int16_t);\n }\n\n        outHeader->nTimeStamp =\n            mAnchorTimeUs + (mNumFramesOutput * 1000000ll) / mSamplingRate;\n\n if (inHeader) {\n            CHECK_GE(inHeader->nFilledLen, mConfig->inputBufferUsedLength);\n\n            inHeader->nOffset += mConfig->inputBufferUsedLength;\n            inHeader->nFilledLen -= mConfig->inputBufferUsedLength;\n\n\n if (inHeader->nFilledLen == 0) {\n                inInfo->mOwnedByUs = false;\n                inQueue.erase(inQueue.begin());\n                inInfo = NULL;\n                notifyEmptyBufferDone(inHeader);\n                inHeader = NULL;\n }\n }\n\n        mNumFramesOutput += mConfig->outputFrameSize / mNumChannels;\n\n        outInfo->mOwnedByUs = false;\n        outQueue.erase(outQueue.begin());\n        outInfo = NULL;\n        notifyFillBufferDone(outHeader);\n        outHeader = NULL;\n }\n}\n",
    "cwe": [
      "CWE-264"
    ],
    "id": 261,
    "_valid_cwes": [
      "CWE-264"
    ]
  },
  {
    "cve_id": "CVE-2015-1342",
    "code_before_change": "static int cg_getattr(const char *path, struct stat *sb)\n{\n\tstruct timespec now;\n\tstruct fuse_context *fc = fuse_get_context();\n\tchar * cgdir = NULL;\n\tchar *fpath = NULL, *path1, *path2;\n\tstruct cgfs_files *k = NULL;\n\tconst char *cgroup;\n\tconst char *controller = NULL;\n\tint ret = -ENOENT;\n\n\n\tif (!fc)\n\t\treturn -EIO;\n\n\tmemset(sb, 0, sizeof(struct stat));\n\n\tif (clock_gettime(CLOCK_REALTIME, &now) < 0)\n\t\treturn -EINVAL;\n\n\tsb->st_uid = sb->st_gid = 0;\n\tsb->st_atim = sb->st_mtim = sb->st_ctim = now;\n\tsb->st_size = 0;\n\n\tif (strcmp(path, \"/cgroup\") == 0) {\n\t\tsb->st_mode = S_IFDIR | 00755;\n\t\tsb->st_nlink = 2;\n\t\treturn 0;\n\t}\n\n\tcontroller = pick_controller_from_path(fc, path);\n\tif (!controller)\n\t\treturn -EIO;\n\tcgroup = find_cgroup_in_path(path);\n\tif (!cgroup) {\n\t\t/* this is just /cgroup/controller, return it as a dir */\n\t\tsb->st_mode = S_IFDIR | 00755;\n\t\tsb->st_nlink = 2;\n\t\treturn 0;\n\t}\n\n\tget_cgdir_and_path(cgroup, &cgdir, &fpath);\n\n\tif (!fpath) {\n\t\tpath1 = \"/\";\n\t\tpath2 = cgdir;\n\t} else {\n\t\tpath1 = cgdir;\n\t\tpath2 = fpath;\n\t}\n\n\t/* check that cgcopy is either a child cgroup of cgdir, or listed in its keys.\n\t * Then check that caller's cgroup is under path if fpath is a child\n \t * cgroup, or cgdir if fpath is a file */\n \n \tif (is_child_cgroup(controller, path1, path2)) {\n \t\tif (!caller_is_in_ancestor(fc->pid, controller, cgroup, NULL)) {\n \t\t\t/* this is just /cgroup/controller, return it as a dir */\n \t\t\tsb->st_mode = S_IFDIR | 00555;\n\t\t\tsb->st_nlink = 2;\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!fc_may_access(fc, controller, cgroup, NULL, O_RDONLY)) {\n\t\t\tret = -EACCES;\n\t\t\tgoto out;\n\t\t}\n\n\t\tsb->st_mode = S_IFDIR | 00755;\n\t\tk = cgfs_get_key(controller, cgroup, \"tasks\");\n\t\tif (!k) {\n\t\t\tsb->st_uid = sb->st_gid = 0;\n\t\t} else {\n\t\t\tsb->st_uid = k->uid;\n\t\t\tsb->st_gid = k->gid;\n\t\t}\n\t\tfree_key(k);\n\t\tsb->st_nlink = 2;\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tif ((k = cgfs_get_key(controller, path1, path2)) != NULL) {\n\t\tsb->st_mode = S_IFREG | k->mode;\n\t\tsb->st_nlink = 1;\n\t\tsb->st_uid = k->uid;\n\t\tsb->st_gid = k->gid;\n\t\tsb->st_size = 0;\n\t\tfree_key(k);\n\t\tif (!caller_is_in_ancestor(fc->pid, controller, path1, NULL)) {\n\t\t\tret = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!fc_may_access(fc, controller, path1, path2, O_RDONLY)) {\n\t\t\tret = -EACCES;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = 0;\n\t}\n\nout:\n\tfree(cgdir);\n\treturn ret;\n}\n",
    "code_after_change": "static int cg_getattr(const char *path, struct stat *sb)\n{\n\tstruct timespec now;\n\tstruct fuse_context *fc = fuse_get_context();\n\tchar * cgdir = NULL;\n\tchar *fpath = NULL, *path1, *path2;\n\tstruct cgfs_files *k = NULL;\n\tconst char *cgroup;\n\tconst char *controller = NULL;\n\tint ret = -ENOENT;\n\n\n\tif (!fc)\n\t\treturn -EIO;\n\n\tmemset(sb, 0, sizeof(struct stat));\n\n\tif (clock_gettime(CLOCK_REALTIME, &now) < 0)\n\t\treturn -EINVAL;\n\n\tsb->st_uid = sb->st_gid = 0;\n\tsb->st_atim = sb->st_mtim = sb->st_ctim = now;\n\tsb->st_size = 0;\n\n\tif (strcmp(path, \"/cgroup\") == 0) {\n\t\tsb->st_mode = S_IFDIR | 00755;\n\t\tsb->st_nlink = 2;\n\t\treturn 0;\n\t}\n\n\tcontroller = pick_controller_from_path(fc, path);\n\tif (!controller)\n\t\treturn -EIO;\n\tcgroup = find_cgroup_in_path(path);\n\tif (!cgroup) {\n\t\t/* this is just /cgroup/controller, return it as a dir */\n\t\tsb->st_mode = S_IFDIR | 00755;\n\t\tsb->st_nlink = 2;\n\t\treturn 0;\n\t}\n\n\tget_cgdir_and_path(cgroup, &cgdir, &fpath);\n\n\tif (!fpath) {\n\t\tpath1 = \"/\";\n\t\tpath2 = cgdir;\n\t} else {\n\t\tpath1 = cgdir;\n\t\tpath2 = fpath;\n\t}\n\n\t/* check that cgcopy is either a child cgroup of cgdir, or listed in its keys.\n\t * Then check that caller's cgroup is under path if fpath is a child\n \t * cgroup, or cgdir if fpath is a file */\n \n \tif (is_child_cgroup(controller, path1, path2)) {\n\t\tif (!caller_may_see_dir(fc->pid, controller, cgroup)) {\n\t\t\tret = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n \t\tif (!caller_is_in_ancestor(fc->pid, controller, cgroup, NULL)) {\n \t\t\t/* this is just /cgroup/controller, return it as a dir */\n \t\t\tsb->st_mode = S_IFDIR | 00555;\n\t\t\tsb->st_nlink = 2;\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!fc_may_access(fc, controller, cgroup, NULL, O_RDONLY)) {\n\t\t\tret = -EACCES;\n\t\t\tgoto out;\n\t\t}\n\n\t\tsb->st_mode = S_IFDIR | 00755;\n\t\tk = cgfs_get_key(controller, cgroup, \"tasks\");\n\t\tif (!k) {\n\t\t\tsb->st_uid = sb->st_gid = 0;\n\t\t} else {\n\t\t\tsb->st_uid = k->uid;\n\t\t\tsb->st_gid = k->gid;\n\t\t}\n\t\tfree_key(k);\n\t\tsb->st_nlink = 2;\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tif ((k = cgfs_get_key(controller, path1, path2)) != NULL) {\n\t\tsb->st_mode = S_IFREG | k->mode;\n\t\tsb->st_nlink = 1;\n\t\tsb->st_uid = k->uid;\n\t\tsb->st_gid = k->gid;\n\t\tsb->st_size = 0;\n\t\tfree_key(k);\n\t\tif (!caller_is_in_ancestor(fc->pid, controller, path1, NULL)) {\n\t\t\tret = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!fc_may_access(fc, controller, path1, path2, O_RDONLY)) {\n\t\t\tret = -EACCES;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = 0;\n\t}\n\nout:\n\tfree(cgdir);\n\treturn ret;\n}\n",
    "cwe": [
      "CWE-264"
    ],
    "id": 315,
    "_valid_cwes": [
      "CWE-264"
    ]
  },
  {
    "cve_id": "CVE-2011-3084",
    "code_before_change": "   virtual void SetUp() {\n     old_browser_client_ = content::GetContentClient()->browser();\n     content::GetContentClient()->set_browser(&browser_client_);\n     url_util::AddStandardScheme(kPrivilegedScheme);\n    url_util::AddStandardScheme(chrome::kChromeUIScheme);\n  }\n",
    "code_after_change": "   virtual void SetUp() {\n    old_client_ = content::GetContentClient();\n    content::SetContentClient(&client_);\n     old_browser_client_ = content::GetContentClient()->browser();\n     content::GetContentClient()->set_browser(&browser_client_);\n     url_util::AddStandardScheme(kPrivilegedScheme);\n    url_util::AddStandardScheme(chrome::kChromeUIScheme);\n  }\n",
    "cwe": [
      "CWE-264"
    ],
    "id": 345,
    "_valid_cwes": [
      "CWE-264"
    ]
  },
  {
    "cve_id": "CVE-2016-3900",
    "code_before_change": "static int svc_can_register(const uint16_t *name, size_t name_len, pid_t spid, uid_t uid)\n\n {\n     const char *perm = \"add\";\n \n    if (uid >= AID_APP) {\n         return 0; /* Don't allow apps to register services */\n     }\n \n return check_mac_perms_from_lookup(spid, uid, perm, str8(name, name_len)) ? 1 : 0;\n}\n",
    "code_after_change": "static int svc_can_register(const uint16_t *name, size_t name_len, pid_t spid, uid_t uid)\n\n {\n     const char *perm = \"add\";\n \n    if (multiuser_get_app_id(uid) >= AID_APP) {\n         return 0; /* Don't allow apps to register services */\n     }\n \n return check_mac_perms_from_lookup(spid, uid, perm, str8(name, name_len)) ? 1 : 0;\n}\n",
    "cwe": [
      "CWE-264"
    ],
    "id": 346,
    "_valid_cwes": [
      "CWE-264"
    ]
  },
  {
    "cve_id": "CVE-2011-4112",
    "code_before_change": "void macvlan_common_setup(struct net_device *dev)\n {\n \tether_setup(dev);\n \n\tdev->priv_flags\t       &= ~IFF_XMIT_DST_RELEASE;\n \tdev->netdev_ops\t\t= &macvlan_netdev_ops;\n \tdev->destructor\t\t= free_netdev;\n \tdev->header_ops\t\t= &macvlan_hard_header_ops,\n\tdev->ethtool_ops\t= &macvlan_ethtool_ops;\n}\n",
    "code_after_change": "void macvlan_common_setup(struct net_device *dev)\n {\n \tether_setup(dev);\n \n\tdev->priv_flags\t       &= ~(IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING);\n \tdev->netdev_ops\t\t= &macvlan_netdev_ops;\n \tdev->destructor\t\t= free_netdev;\n \tdev->header_ops\t\t= &macvlan_hard_header_ops,\n\tdev->ethtool_ops\t= &macvlan_ethtool_ops;\n}\n",
    "cwe": [
      "CWE-264"
    ],
    "id": 352,
    "_valid_cwes": [
      "CWE-264"
    ]
  },
  {
    "cve_id": "CVE-2013-0925",
    "code_before_change": "void MessageService::OpenChannelToExtension(\n    int source_process_id, int source_routing_id, int receiver_port_id,\n    const std::string& source_extension_id,\n    const std::string& target_extension_id,\n    const std::string& channel_name) {\n  content::RenderProcessHost* source =\n      content::RenderProcessHost::FromID(source_process_id);\n  if (!source)\n    return;\n  Profile* profile = Profile::FromBrowserContext(source->GetBrowserContext());\n\n  MessagePort* receiver = new ExtensionMessagePort(\n      GetExtensionProcess(profile, target_extension_id), MSG_ROUTING_CONTROL,\n      target_extension_id);\n  WebContents* source_contents = tab_util::GetWebContentsByID(\n      source_process_id, source_routing_id);\n\n   std::string tab_json = \"null\";\n   if (source_contents) {\n     scoped_ptr<DictionaryValue> tab_value(ExtensionTabUtil::CreateTabValue(\n        source_contents, ExtensionTabUtil::INCLUDE_PRIVACY_SENSITIVE_FIELDS));\n     base::JSONWriter::Write(tab_value.get(), &tab_json);\n   }\n \n  OpenChannelParams* params = new OpenChannelParams(source, tab_json, receiver,\n                                                    receiver_port_id,\n                                                    source_extension_id,\n                                                    target_extension_id,\n                                                    channel_name);\n\n  if (MaybeAddPendingOpenChannelTask(profile, params)) {\n    return;\n  }\n\n  OpenChannelImpl(scoped_ptr<OpenChannelParams>(params));\n}\n",
    "code_after_change": "void MessageService::OpenChannelToExtension(\n    int source_process_id, int source_routing_id, int receiver_port_id,\n    const std::string& source_extension_id,\n    const std::string& target_extension_id,\n    const std::string& channel_name) {\n  content::RenderProcessHost* source =\n      content::RenderProcessHost::FromID(source_process_id);\n  if (!source)\n    return;\n  Profile* profile = Profile::FromBrowserContext(source->GetBrowserContext());\n\n  MessagePort* receiver = new ExtensionMessagePort(\n      GetExtensionProcess(profile, target_extension_id), MSG_ROUTING_CONTROL,\n      target_extension_id);\n  WebContents* source_contents = tab_util::GetWebContentsByID(\n      source_process_id, source_routing_id);\n\n   std::string tab_json = \"null\";\n   if (source_contents) {\n     scoped_ptr<DictionaryValue> tab_value(ExtensionTabUtil::CreateTabValue(\n        source_contents));\n     base::JSONWriter::Write(tab_value.get(), &tab_json);\n   }\n \n  OpenChannelParams* params = new OpenChannelParams(source, tab_json, receiver,\n                                                    receiver_port_id,\n                                                    source_extension_id,\n                                                    target_extension_id,\n                                                    channel_name);\n\n  if (MaybeAddPendingOpenChannelTask(profile, params)) {\n    return;\n  }\n\n  OpenChannelImpl(scoped_ptr<OpenChannelParams>(params));\n}\n",
    "cwe": [
      "CWE-264"
    ],
    "id": 375,
    "_valid_cwes": [
      "CWE-264"
    ]
  },
  {
    "cve_id": "CVE-2014-1737",
    "code_before_change": "static int raw_cmd_copyin(int cmd, void __user *param,\n\t\t\t\t struct floppy_raw_cmd **rcmd)\n{\n\tstruct floppy_raw_cmd *ptr;\n\tint ret;\n\tint i;\n\n\t*rcmd = NULL;\n\nloop:\n\tptr = kmalloc(sizeof(struct floppy_raw_cmd), GFP_USER);\n\tif (!ptr)\n \t\treturn -ENOMEM;\n \t*rcmd = ptr;\n \tret = copy_from_user(ptr, param, sizeof(*ptr));\n\tif (ret)\n\t\treturn -EFAULT;\n \tptr->next = NULL;\n \tptr->buffer_length = 0;\n \tparam += sizeof(struct floppy_raw_cmd);\n \tif (ptr->cmd_count > 33)\n \t\t\t/* the command may now also take up the space\n\t\t\t * initially intended for the reply & the\n\t\t\t * reply count. Needed for long 82078 commands\n\t\t\t * such as RESTORE, which takes ... 17 command\n\t\t\t * bytes. Murphy's law #137: When you reserve\n\t\t\t * 16 bytes for a structure, you'll one day\n\t\t\t * discover that you really need 17...\n\t\t\t */\n\t\treturn -EINVAL;\n\n \tfor (i = 0; i < 16; i++)\n \t\tptr->reply[i] = 0;\n \tptr->resultcode = 0;\n\tptr->kernel_data = NULL;\n \n \tif (ptr->flags & (FD_RAW_READ | FD_RAW_WRITE)) {\n \t\tif (ptr->length <= 0)\n\t\t\treturn -EINVAL;\n\t\tptr->kernel_data = (char *)fd_dma_mem_alloc(ptr->length);\n\t\tfallback_on_nodma_alloc(&ptr->kernel_data, ptr->length);\n\t\tif (!ptr->kernel_data)\n\t\t\treturn -ENOMEM;\n\t\tptr->buffer_length = ptr->length;\n\t}\n\tif (ptr->flags & FD_RAW_WRITE) {\n\t\tret = fd_copyin(ptr->data, ptr->kernel_data, ptr->length);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (ptr->flags & FD_RAW_MORE) {\n\t\trcmd = &(ptr->next);\n\t\tptr->rate &= 0x43;\n\t\tgoto loop;\n\t}\n\n\treturn 0;\n}\n",
    "code_after_change": "static int raw_cmd_copyin(int cmd, void __user *param,\n\t\t\t\t struct floppy_raw_cmd **rcmd)\n{\n\tstruct floppy_raw_cmd *ptr;\n\tint ret;\n\tint i;\n\n\t*rcmd = NULL;\n\nloop:\n\tptr = kmalloc(sizeof(struct floppy_raw_cmd), GFP_USER);\n\tif (!ptr)\n \t\treturn -ENOMEM;\n \t*rcmd = ptr;\n \tret = copy_from_user(ptr, param, sizeof(*ptr));\n \tptr->next = NULL;\n \tptr->buffer_length = 0;\n\tptr->kernel_data = NULL;\n\tif (ret)\n\t\treturn -EFAULT;\n \tparam += sizeof(struct floppy_raw_cmd);\n \tif (ptr->cmd_count > 33)\n \t\t\t/* the command may now also take up the space\n\t\t\t * initially intended for the reply & the\n\t\t\t * reply count. Needed for long 82078 commands\n\t\t\t * such as RESTORE, which takes ... 17 command\n\t\t\t * bytes. Murphy's law #137: When you reserve\n\t\t\t * 16 bytes for a structure, you'll one day\n\t\t\t * discover that you really need 17...\n\t\t\t */\n\t\treturn -EINVAL;\n\n \tfor (i = 0; i < 16; i++)\n \t\tptr->reply[i] = 0;\n \tptr->resultcode = 0;\n \n \tif (ptr->flags & (FD_RAW_READ | FD_RAW_WRITE)) {\n \t\tif (ptr->length <= 0)\n\t\t\treturn -EINVAL;\n\t\tptr->kernel_data = (char *)fd_dma_mem_alloc(ptr->length);\n\t\tfallback_on_nodma_alloc(&ptr->kernel_data, ptr->length);\n\t\tif (!ptr->kernel_data)\n\t\t\treturn -ENOMEM;\n\t\tptr->buffer_length = ptr->length;\n\t}\n\tif (ptr->flags & FD_RAW_WRITE) {\n\t\tret = fd_copyin(ptr->data, ptr->kernel_data, ptr->length);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (ptr->flags & FD_RAW_MORE) {\n\t\trcmd = &(ptr->next);\n\t\tptr->rate &= 0x43;\n\t\tgoto loop;\n\t}\n\n\treturn 0;\n}\n",
    "cwe": [
      "CWE-264"
    ],
    "id": 381,
    "_valid_cwes": [
      "CWE-264"
    ]
  },
  {
    "cve_id": "CVE-2014-3122",
    "code_before_change": "static int try_to_unmap_cluster(unsigned long cursor, unsigned int *mapcount,\n\t\tstruct vm_area_struct *vma, struct page *check_page)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tpmd_t *pmd;\n\tpte_t *pte;\n\tpte_t pteval;\n\tspinlock_t *ptl;\n\tstruct page *page;\n\tunsigned long address;\n\tunsigned long mmun_start;\t/* For mmu_notifiers */\n\tunsigned long mmun_end;\t\t/* For mmu_notifiers */\n\tunsigned long end;\n\tint ret = SWAP_AGAIN;\n\tint locked_vma = 0;\n\n\taddress = (vma->vm_start + cursor) & CLUSTER_MASK;\n\tend = address + CLUSTER_SIZE;\n\tif (address < vma->vm_start)\n\t\taddress = vma->vm_start;\n\tif (end > vma->vm_end)\n\t\tend = vma->vm_end;\n\n\tpmd = mm_find_pmd(mm, address);\n\tif (!pmd)\n\t\treturn ret;\n\n\tmmun_start = address;\n\tmmun_end   = end;\n\tmmu_notifier_invalidate_range_start(mm, mmun_start, mmun_end);\n\n\t/*\n\t * If we can acquire the mmap_sem for read, and vma is VM_LOCKED,\n\t * keep the sem while scanning the cluster for mlocking pages.\n\t */\n\tif (down_read_trylock(&vma->vm_mm->mmap_sem)) {\n\t\tlocked_vma = (vma->vm_flags & VM_LOCKED);\n\t\tif (!locked_vma)\n\t\t\tup_read(&vma->vm_mm->mmap_sem); /* don't need it */\n\t}\n\n\tpte = pte_offset_map_lock(mm, pmd, address, &ptl);\n\n\t/* Update high watermark before we lower rss */\n\tupdate_hiwater_rss(mm);\n\n\tfor (; address < end; pte++, address += PAGE_SIZE) {\n\t\tif (!pte_present(*pte))\n\t\t\tcontinue;\n\t\tpage = vm_normal_page(vma, address, *pte);\n \t\tBUG_ON(!page || PageAnon(page));\n \n \t\tif (locked_vma) {\n\t\t\tmlock_vma_page(page);   /* no-op if already mlocked */\n\t\t\tif (page == check_page)\n \t\t\t\tret = SWAP_MLOCK;\n \t\t\tcontinue;\t/* don't unmap */\n \t\t}\n \n\t\tif (ptep_clear_flush_young_notify(vma, address, pte))\n\t\t\tcontinue;\n\n\t\t/* Nuke the page table entry. */\n\t\tflush_cache_page(vma, address, pte_pfn(*pte));\n\t\tpteval = ptep_clear_flush(vma, address, pte);\n\n\t\t/* If nonlinear, store the file page offset in the pte. */\n\t\tif (page->index != linear_page_index(vma, address)) {\n\t\t\tpte_t ptfile = pgoff_to_pte(page->index);\n\t\t\tif (pte_soft_dirty(pteval))\n\t\t\t\tpte_file_mksoft_dirty(ptfile);\n\t\t\tset_pte_at(mm, address, pte, ptfile);\n\t\t}\n\n\t\t/* Move the dirty bit to the physical page now the pte is gone. */\n\t\tif (pte_dirty(pteval))\n\t\t\tset_page_dirty(page);\n\n\t\tpage_remove_rmap(page);\n\t\tpage_cache_release(page);\n\t\tdec_mm_counter(mm, MM_FILEPAGES);\n\t\t(*mapcount)--;\n\t}\n\tpte_unmap_unlock(pte - 1, ptl);\n\tmmu_notifier_invalidate_range_end(mm, mmun_start, mmun_end);\n\tif (locked_vma)\n\t\tup_read(&vma->vm_mm->mmap_sem);\n\treturn ret;\n}\n",
    "code_after_change": "static int try_to_unmap_cluster(unsigned long cursor, unsigned int *mapcount,\n\t\tstruct vm_area_struct *vma, struct page *check_page)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tpmd_t *pmd;\n\tpte_t *pte;\n\tpte_t pteval;\n\tspinlock_t *ptl;\n\tstruct page *page;\n\tunsigned long address;\n\tunsigned long mmun_start;\t/* For mmu_notifiers */\n\tunsigned long mmun_end;\t\t/* For mmu_notifiers */\n\tunsigned long end;\n\tint ret = SWAP_AGAIN;\n\tint locked_vma = 0;\n\n\taddress = (vma->vm_start + cursor) & CLUSTER_MASK;\n\tend = address + CLUSTER_SIZE;\n\tif (address < vma->vm_start)\n\t\taddress = vma->vm_start;\n\tif (end > vma->vm_end)\n\t\tend = vma->vm_end;\n\n\tpmd = mm_find_pmd(mm, address);\n\tif (!pmd)\n\t\treturn ret;\n\n\tmmun_start = address;\n\tmmun_end   = end;\n\tmmu_notifier_invalidate_range_start(mm, mmun_start, mmun_end);\n\n\t/*\n\t * If we can acquire the mmap_sem for read, and vma is VM_LOCKED,\n\t * keep the sem while scanning the cluster for mlocking pages.\n\t */\n\tif (down_read_trylock(&vma->vm_mm->mmap_sem)) {\n\t\tlocked_vma = (vma->vm_flags & VM_LOCKED);\n\t\tif (!locked_vma)\n\t\t\tup_read(&vma->vm_mm->mmap_sem); /* don't need it */\n\t}\n\n\tpte = pte_offset_map_lock(mm, pmd, address, &ptl);\n\n\t/* Update high watermark before we lower rss */\n\tupdate_hiwater_rss(mm);\n\n\tfor (; address < end; pte++, address += PAGE_SIZE) {\n\t\tif (!pte_present(*pte))\n\t\t\tcontinue;\n\t\tpage = vm_normal_page(vma, address, *pte);\n \t\tBUG_ON(!page || PageAnon(page));\n \n \t\tif (locked_vma) {\n\t\t\tif (page == check_page) {\n\t\t\t\t/* we know we have check_page locked */\n\t\t\t\tmlock_vma_page(page);\n \t\t\t\tret = SWAP_MLOCK;\n\t\t\t} else if (trylock_page(page)) {\n\t\t\t\t/*\n\t\t\t\t * If we can lock the page, perform mlock.\n\t\t\t\t * Otherwise leave the page alone, it will be\n\t\t\t\t * eventually encountered again later.\n\t\t\t\t */\n\t\t\t\tmlock_vma_page(page);\n\t\t\t\tunlock_page(page);\n\t\t\t}\n \t\t\tcontinue;\t/* don't unmap */\n \t\t}\n \n\t\tif (ptep_clear_flush_young_notify(vma, address, pte))\n\t\t\tcontinue;\n\n\t\t/* Nuke the page table entry. */\n\t\tflush_cache_page(vma, address, pte_pfn(*pte));\n\t\tpteval = ptep_clear_flush(vma, address, pte);\n\n\t\t/* If nonlinear, store the file page offset in the pte. */\n\t\tif (page->index != linear_page_index(vma, address)) {\n\t\t\tpte_t ptfile = pgoff_to_pte(page->index);\n\t\t\tif (pte_soft_dirty(pteval))\n\t\t\t\tpte_file_mksoft_dirty(ptfile);\n\t\t\tset_pte_at(mm, address, pte, ptfile);\n\t\t}\n\n\t\t/* Move the dirty bit to the physical page now the pte is gone. */\n\t\tif (pte_dirty(pteval))\n\t\t\tset_page_dirty(page);\n\n\t\tpage_remove_rmap(page);\n\t\tpage_cache_release(page);\n\t\tdec_mm_counter(mm, MM_FILEPAGES);\n\t\t(*mapcount)--;\n\t}\n\tpte_unmap_unlock(pte - 1, ptl);\n\tmmu_notifier_invalidate_range_end(mm, mmun_start, mmun_end);\n\tif (locked_vma)\n\t\tup_read(&vma->vm_mm->mmap_sem);\n\treturn ret;\n}\n",
    "cwe": [
      "CWE-264"
    ],
    "id": 406,
    "_valid_cwes": [
      "CWE-264"
    ]
  },
  {
    "cve_id": "CVE-2010-1172",
    "code_before_change": "my_object_many_uppercase (MyObject *obj, const char * const *in, char ***out, GError **error)\n{\n  int len;\n  int i;\n  len = g_strv_length ((char**) in);\n  *out = g_new0 (char *, len + 1);\n  for (i = 0; i < len; i++)\n    {\n      (*out)[i] = g_ascii_strup (in[i], -1);\n    }\n  (*out)[i] = NULL;\n  return TRUE;\n}\n",
    "code_after_change": "my_object_many_uppercase (MyObject *obj, const char * const *in, char ***out, GError **error)\n",
    "cwe": [
      "CWE-264"
    ],
    "id": 413,
    "_valid_cwes": [
      "CWE-264"
    ]
  },
  {
    "cve_id": "CVE-2012-2121",
    "code_before_change": " static int kvm_iommu_unmap_memslots(struct kvm *kvm)\n {\n \tint idx;\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *memslot;\n\n\tidx = srcu_read_lock(&kvm->srcu);\n \tslots = kvm_memslots(kvm);\n \n \tkvm_for_each_memslot(memslot, slots)\n\t\tkvm_iommu_put_pages(kvm, memslot->base_gfn, memslot->npages);\n \n \tsrcu_read_unlock(&kvm->srcu, idx);\n \n\treturn 0;\n}\n",
    "code_after_change": " static int kvm_iommu_unmap_memslots(struct kvm *kvm)\n {\n \tint idx;\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *memslot;\n\n\tidx = srcu_read_lock(&kvm->srcu);\n \tslots = kvm_memslots(kvm);\n \n \tkvm_for_each_memslot(memslot, slots)\n\t\tkvm_iommu_unmap_pages(kvm, memslot);\n \n \tsrcu_read_unlock(&kvm->srcu, idx);\n \n\treturn 0;\n}\n",
    "cwe": [
      "CWE-264"
    ],
    "id": 445,
    "_valid_cwes": [
      "CWE-264"
    ]
  },
  {
    "cve_id": "CVE-2016-2450",
    "code_before_change": "void SoftVPXEncoder::onQueueFilled(OMX_U32 /* portIndex */) {\n if (mCodecContext == NULL) {\n if (OK != initEncoder()) {\n            ALOGE(\"Failed to initialize encoder\");\n            notify(OMX_EventError,\n                   OMX_ErrorUndefined,\n 0, // Extra notification data\n                   NULL); // Notification data pointer\n return;\n }\n }\n\n vpx_codec_err_t codec_return;\n List<BufferInfo *> &inputBufferInfoQueue = getPortQueue(kInputPortIndex);\n List<BufferInfo *> &outputBufferInfoQueue = getPortQueue(kOutputPortIndex);\n\n while (!inputBufferInfoQueue.empty() && !outputBufferInfoQueue.empty()) {\n BufferInfo *inputBufferInfo = *inputBufferInfoQueue.begin();\n        OMX_BUFFERHEADERTYPE *inputBufferHeader = inputBufferInfo->mHeader;\n\n BufferInfo *outputBufferInfo = *outputBufferInfoQueue.begin();\n        OMX_BUFFERHEADERTYPE *outputBufferHeader = outputBufferInfo->mHeader;\n\n if ((inputBufferHeader->nFlags & OMX_BUFFERFLAG_EOS) &&\n                inputBufferHeader->nFilledLen == 0) {\n            inputBufferInfoQueue.erase(inputBufferInfoQueue.begin());\n            inputBufferInfo->mOwnedByUs = false;\n            notifyEmptyBufferDone(inputBufferHeader);\n\n            outputBufferHeader->nFilledLen = 0;\n            outputBufferHeader->nFlags = OMX_BUFFERFLAG_EOS;\n\n            outputBufferInfoQueue.erase(outputBufferInfoQueue.begin());\n            outputBufferInfo->mOwnedByUs = false;\n            notifyFillBufferDone(outputBufferHeader);\n return;\n }\n\n\n         const uint8_t *source =\n             inputBufferHeader->pBuffer + inputBufferHeader->nOffset;\n \n         if (mInputDataIsMeta) {\n             source = extractGraphicBuffer(\n                    mConversionBuffer, mWidth * mHeight * 3 / 2,\n                     source, inputBufferHeader->nFilledLen,\n                     mWidth, mHeight);\n             if (source == NULL) {\n                ALOGE(\"Unable to extract gralloc buffer in metadata mode\");\n\n                 notify(OMX_EventError, OMX_ErrorUndefined, 0, 0);\n                 return;\n             }\n        } else if (mColorFormat == OMX_COLOR_FormatYUV420SemiPlanar) {\n            ConvertYUV420SemiPlanarToYUV420Planar(\n                    source, mConversionBuffer, mWidth, mHeight);\n \n            source = mConversionBuffer;\n         }\n         vpx_image_t raw_frame;\n         vpx_img_wrap(&raw_frame, VPX_IMG_FMT_I420, mWidth, mHeight,\n                     kInputBufferAlignment, (uint8_t *)source);\n\n vpx_enc_frame_flags_t flags = 0;\n if (mTemporalPatternLength > 0) {\n            flags = getEncodeFlags();\n }\n if (mKeyFrameRequested) {\n            flags |= VPX_EFLAG_FORCE_KF;\n            mKeyFrameRequested = false;\n }\n\n if (mBitrateUpdated) {\n            mCodecConfiguration->rc_target_bitrate = mBitrate/1000;\n vpx_codec_err_t res = vpx_codec_enc_config_set(mCodecContext,\n                                                           mCodecConfiguration);\n if (res != VPX_CODEC_OK) {\n                ALOGE(\"vp8 encoder failed to update bitrate: %s\",\n                      vpx_codec_err_to_string(res));\n                notify(OMX_EventError,\n                       OMX_ErrorUndefined,\n 0, // Extra notification data\n                       NULL); // Notification data pointer\n }\n            mBitrateUpdated = false;\n }\n\n uint32_t frameDuration;\n if (inputBufferHeader->nTimeStamp > mLastTimestamp) {\n            frameDuration = (uint32_t)(inputBufferHeader->nTimeStamp - mLastTimestamp);\n } else {\n            frameDuration = (uint32_t)(((uint64_t)1000000 << 16) / mFramerate);\n }\n        mLastTimestamp = inputBufferHeader->nTimeStamp;\n        codec_return = vpx_codec_encode(\n                mCodecContext,\n &raw_frame,\n                inputBufferHeader->nTimeStamp, // in timebase units\n                frameDuration, // frame duration in timebase units\n                flags, // frame flags\n                VPX_DL_REALTIME); // encoding deadline\n if (codec_return != VPX_CODEC_OK) {\n            ALOGE(\"vpx encoder failed to encode frame\");\n            notify(OMX_EventError,\n                   OMX_ErrorUndefined,\n 0, // Extra notification data\n                   NULL); // Notification data pointer\n return;\n }\n\n vpx_codec_iter_t encoded_packet_iterator = NULL;\n const vpx_codec_cx_pkt_t* encoded_packet;\n\n while ((encoded_packet = vpx_codec_get_cx_data(\n                        mCodecContext, &encoded_packet_iterator))) {\n if (encoded_packet->kind == VPX_CODEC_CX_FRAME_PKT) {\n\n                 outputBufferHeader->nTimeStamp = encoded_packet->data.frame.pts;\n                 outputBufferHeader->nFlags = 0;\n                 if (encoded_packet->data.frame.flags & VPX_FRAME_IS_KEY)\n                  outputBufferHeader->nFlags |= OMX_BUFFERFLAG_SYNCFRAME;\n                 outputBufferHeader->nOffset = 0;\n                 outputBufferHeader->nFilledLen = encoded_packet->data.frame.sz;\n                 memcpy(outputBufferHeader->pBuffer,\n                        encoded_packet->data.frame.buf,\n                        encoded_packet->data.frame.sz);\n                outputBufferInfo->mOwnedByUs = false;\n                outputBufferInfoQueue.erase(outputBufferInfoQueue.begin());\n if (inputBufferHeader->nFlags & OMX_BUFFERFLAG_EOS) {\n                    outputBufferHeader->nFlags |= OMX_BUFFERFLAG_EOS;\n }\n                notifyFillBufferDone(outputBufferHeader);\n }\n }\n\n        inputBufferInfo->mOwnedByUs = false;\n        inputBufferInfoQueue.erase(inputBufferInfoQueue.begin());\n        notifyEmptyBufferDone(inputBufferHeader);\n }\n}\n",
    "code_after_change": "void SoftVPXEncoder::onQueueFilled(OMX_U32 /* portIndex */) {\n if (mCodecContext == NULL) {\n if (OK != initEncoder()) {\n            ALOGE(\"Failed to initialize encoder\");\n            notify(OMX_EventError,\n                   OMX_ErrorUndefined,\n 0, // Extra notification data\n                   NULL); // Notification data pointer\n return;\n }\n }\n\n vpx_codec_err_t codec_return;\n List<BufferInfo *> &inputBufferInfoQueue = getPortQueue(kInputPortIndex);\n List<BufferInfo *> &outputBufferInfoQueue = getPortQueue(kOutputPortIndex);\n\n while (!inputBufferInfoQueue.empty() && !outputBufferInfoQueue.empty()) {\n BufferInfo *inputBufferInfo = *inputBufferInfoQueue.begin();\n        OMX_BUFFERHEADERTYPE *inputBufferHeader = inputBufferInfo->mHeader;\n\n BufferInfo *outputBufferInfo = *outputBufferInfoQueue.begin();\n        OMX_BUFFERHEADERTYPE *outputBufferHeader = outputBufferInfo->mHeader;\n\n if ((inputBufferHeader->nFlags & OMX_BUFFERFLAG_EOS) &&\n                inputBufferHeader->nFilledLen == 0) {\n            inputBufferInfoQueue.erase(inputBufferInfoQueue.begin());\n            inputBufferInfo->mOwnedByUs = false;\n            notifyEmptyBufferDone(inputBufferHeader);\n\n            outputBufferHeader->nFilledLen = 0;\n            outputBufferHeader->nFlags = OMX_BUFFERFLAG_EOS;\n\n            outputBufferInfoQueue.erase(outputBufferInfoQueue.begin());\n            outputBufferInfo->mOwnedByUs = false;\n            notifyFillBufferDone(outputBufferHeader);\n return;\n }\n\n\n         const uint8_t *source =\n             inputBufferHeader->pBuffer + inputBufferHeader->nOffset;\n \n        size_t frameSize = mWidth * mHeight * 3 / 2;\n         if (mInputDataIsMeta) {\n             source = extractGraphicBuffer(\n                    mConversionBuffer, frameSize,\n                     source, inputBufferHeader->nFilledLen,\n                     mWidth, mHeight);\n             if (source == NULL) {\n                ALOGE(\"Unable to extract gralloc buffer in metadata mode\");\n\n                 notify(OMX_EventError, OMX_ErrorUndefined, 0, 0);\n                 return;\n             }\n        } else {\n            if (inputBufferHeader->nFilledLen < frameSize) {\n                android_errorWriteLog(0x534e4554, \"27569635\");\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, 0);\n                return;\n            } else if (inputBufferHeader->nFilledLen > frameSize) {\n                ALOGW(\"Input buffer contains too many pixels\");\n            }\n \n            if (mColorFormat == OMX_COLOR_FormatYUV420SemiPlanar) {\n                ConvertYUV420SemiPlanarToYUV420Planar(\n                        source, mConversionBuffer, mWidth, mHeight);\n\n                source = mConversionBuffer;\n            }\n         }\n         vpx_image_t raw_frame;\n         vpx_img_wrap(&raw_frame, VPX_IMG_FMT_I420, mWidth, mHeight,\n                     kInputBufferAlignment, (uint8_t *)source);\n\n vpx_enc_frame_flags_t flags = 0;\n if (mTemporalPatternLength > 0) {\n            flags = getEncodeFlags();\n }\n if (mKeyFrameRequested) {\n            flags |= VPX_EFLAG_FORCE_KF;\n            mKeyFrameRequested = false;\n }\n\n if (mBitrateUpdated) {\n            mCodecConfiguration->rc_target_bitrate = mBitrate/1000;\n vpx_codec_err_t res = vpx_codec_enc_config_set(mCodecContext,\n                                                           mCodecConfiguration);\n if (res != VPX_CODEC_OK) {\n                ALOGE(\"vp8 encoder failed to update bitrate: %s\",\n                      vpx_codec_err_to_string(res));\n                notify(OMX_EventError,\n                       OMX_ErrorUndefined,\n 0, // Extra notification data\n                       NULL); // Notification data pointer\n }\n            mBitrateUpdated = false;\n }\n\n uint32_t frameDuration;\n if (inputBufferHeader->nTimeStamp > mLastTimestamp) {\n            frameDuration = (uint32_t)(inputBufferHeader->nTimeStamp - mLastTimestamp);\n } else {\n            frameDuration = (uint32_t)(((uint64_t)1000000 << 16) / mFramerate);\n }\n        mLastTimestamp = inputBufferHeader->nTimeStamp;\n        codec_return = vpx_codec_encode(\n                mCodecContext,\n &raw_frame,\n                inputBufferHeader->nTimeStamp, // in timebase units\n                frameDuration, // frame duration in timebase units\n                flags, // frame flags\n                VPX_DL_REALTIME); // encoding deadline\n if (codec_return != VPX_CODEC_OK) {\n            ALOGE(\"vpx encoder failed to encode frame\");\n            notify(OMX_EventError,\n                   OMX_ErrorUndefined,\n 0, // Extra notification data\n                   NULL); // Notification data pointer\n return;\n }\n\n vpx_codec_iter_t encoded_packet_iterator = NULL;\n const vpx_codec_cx_pkt_t* encoded_packet;\n\n while ((encoded_packet = vpx_codec_get_cx_data(\n                        mCodecContext, &encoded_packet_iterator))) {\n if (encoded_packet->kind == VPX_CODEC_CX_FRAME_PKT) {\n\n                 outputBufferHeader->nTimeStamp = encoded_packet->data.frame.pts;\n                 outputBufferHeader->nFlags = 0;\n                 if (encoded_packet->data.frame.flags & VPX_FRAME_IS_KEY)\n                    outputBufferHeader->nFlags |= OMX_BUFFERFLAG_SYNCFRAME;\n                 outputBufferHeader->nOffset = 0;\n                 outputBufferHeader->nFilledLen = encoded_packet->data.frame.sz;\n                if (outputBufferHeader->nFilledLen > outputBufferHeader->nAllocLen) {\n                    android_errorWriteLog(0x534e4554, \"27569635\");\n                    notify(OMX_EventError, OMX_ErrorUndefined, 0, 0);\n                    return;\n                }\n                 memcpy(outputBufferHeader->pBuffer,\n                        encoded_packet->data.frame.buf,\n                        encoded_packet->data.frame.sz);\n                outputBufferInfo->mOwnedByUs = false;\n                outputBufferInfoQueue.erase(outputBufferInfoQueue.begin());\n if (inputBufferHeader->nFlags & OMX_BUFFERFLAG_EOS) {\n                    outputBufferHeader->nFlags |= OMX_BUFFERFLAG_EOS;\n }\n                notifyFillBufferDone(outputBufferHeader);\n }\n }\n\n        inputBufferInfo->mOwnedByUs = false;\n        inputBufferInfoQueue.erase(inputBufferInfoQueue.begin());\n        notifyEmptyBufferDone(inputBufferHeader);\n }\n}\n",
    "cwe": [
      "CWE-264"
    ],
    "id": 472,
    "_valid_cwes": [
      "CWE-264"
    ]
  },
  {
    "cve_id": "CVE-2011-4112",
    "code_before_change": "void vlan_setup(struct net_device *dev)\n{\n \tether_setup(dev);\n \n \tdev->priv_flags\t\t|= IFF_802_1Q_VLAN;\n\tdev->priv_flags\t\t&= ~IFF_XMIT_DST_RELEASE;\n \tdev->tx_queue_len\t= 0;\n \n \tdev->netdev_ops\t\t= &vlan_netdev_ops;\n\tdev->destructor\t\t= free_netdev;\n\tdev->ethtool_ops\t= &vlan_ethtool_ops;\n\n\tmemset(dev->broadcast, 0, ETH_ALEN);\n}\n",
    "code_after_change": "void vlan_setup(struct net_device *dev)\n{\n \tether_setup(dev);\n \n \tdev->priv_flags\t\t|= IFF_802_1Q_VLAN;\n\tdev->priv_flags\t\t&= ~(IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING);\n \tdev->tx_queue_len\t= 0;\n \n \tdev->netdev_ops\t\t= &vlan_netdev_ops;\n\tdev->destructor\t\t= free_netdev;\n\tdev->ethtool_ops\t= &vlan_ethtool_ops;\n\n\tmemset(dev->broadcast, 0, ETH_ALEN);\n}\n",
    "cwe": [
      "CWE-264"
    ],
    "id": 496,
    "_valid_cwes": [
      "CWE-264"
    ]
  },
  {
    "cve_id": "CVE-2011-2486",
    "code_before_change": "int rpc_type_of_NPNVariable(int variable)\n{\n  int type;\n  switch (variable) {\n  case NPNVjavascriptEnabledBool:\n  case NPNVasdEnabledBool:\n   case NPNVisOfflineBool:\n   case NPNVSupportsXEmbedBool:\n   case NPNVSupportsWindowless:\n \ttype = RPC_TYPE_BOOLEAN;\n \tbreak;\n   case NPNVToolkit:\n  case NPNVnetscapeWindow:\n\ttype = RPC_TYPE_UINT32;\n\tbreak;\n  case NPNVWindowNPObject:\n  case NPNVPluginElementNPObject:\n\ttype = RPC_TYPE_NP_OBJECT;\n\tbreak;\n  default:\n\ttype = RPC_ERROR_GENERIC;\n\tbreak;\n  }\n  return type;\n}\n",
    "code_after_change": "int rpc_type_of_NPNVariable(int variable)\n{\n  int type;\n  switch (variable) {\n  case NPNVjavascriptEnabledBool:\n  case NPNVasdEnabledBool:\n   case NPNVisOfflineBool:\n   case NPNVSupportsXEmbedBool:\n   case NPNVSupportsWindowless:\n  case NPNVprivateModeBool:\n  case NPNVsupportsAdvancedKeyHandling:\n \ttype = RPC_TYPE_BOOLEAN;\n \tbreak;\n   case NPNVToolkit:\n  case NPNVnetscapeWindow:\n\ttype = RPC_TYPE_UINT32;\n\tbreak;\n  case NPNVWindowNPObject:\n  case NPNVPluginElementNPObject:\n\ttype = RPC_TYPE_NP_OBJECT;\n\tbreak;\n  default:\n\ttype = RPC_ERROR_GENERIC;\n\tbreak;\n  }\n  return type;\n}\n",
    "cwe": [
      "CWE-264"
    ],
    "id": 510,
    "_valid_cwes": [
      "CWE-264"
    ]
  },
  {
    "cve_id": "CVE-2016-2419",
    "code_before_change": "status_t BnDrm::onTransact(\n uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {\n switch (code) {\n case INIT_CHECK:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n            reply->writeInt32(initCheck());\n return OK;\n }\n\n case IS_CRYPTO_SUPPORTED:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n uint8_t uuid[16];\n            data.read(uuid, sizeof(uuid));\n String8 mimeType = data.readString8();\n            reply->writeInt32(isCryptoSchemeSupported(uuid, mimeType));\n\n return OK;\n }\n\n case CREATE_PLUGIN:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n uint8_t uuid[16];\n            data.read(uuid, sizeof(uuid));\n            reply->writeInt32(createPlugin(uuid));\n return OK;\n }\n\n case DESTROY_PLUGIN:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n            reply->writeInt32(destroyPlugin());\n return OK;\n }\n\n case OPEN_SESSION:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n Vector<uint8_t> sessionId;\n status_t result = openSession(sessionId);\n            writeVector(reply, sessionId);\n            reply->writeInt32(result);\n return OK;\n }\n\n case CLOSE_SESSION:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n Vector<uint8_t> sessionId;\n            readVector(data, sessionId);\n            reply->writeInt32(closeSession(sessionId));\n return OK;\n }\n\n case GET_KEY_REQUEST:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n Vector<uint8_t> sessionId, initData;\n\n            readVector(data, sessionId);\n            readVector(data, initData);\n String8 mimeType = data.readString8();\n DrmPlugin::KeyType keyType = (DrmPlugin::KeyType)data.readInt32();\n\n KeyedVector<String8, String8> optionalParameters;\n uint32_t count = data.readInt32();\n for (size_t i = 0; i < count; ++i) {\n String8 key, value;\n                key = data.readString8();\n                value = data.readString8();\n                optionalParameters.add(key, value);\n }\n\n \n             Vector<uint8_t> request;\n             String8 defaultUrl;\n            DrmPlugin::KeyRequestType keyRequestType;\n \n             status_t result = getKeyRequest(sessionId, initData, mimeType,\n                     keyType, optionalParameters, request, defaultUrl,\n &keyRequestType);\n\n            writeVector(reply, request);\n            reply->writeString8(defaultUrl);\n            reply->writeInt32(static_cast<int32_t>(keyRequestType));\n            reply->writeInt32(result);\n return OK;\n }\n\n case PROVIDE_KEY_RESPONSE:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n Vector<uint8_t> sessionId, response, keySetId;\n            readVector(data, sessionId);\n            readVector(data, response);\n uint32_t result = provideKeyResponse(sessionId, response, keySetId);\n            writeVector(reply, keySetId);\n            reply->writeInt32(result);\n return OK;\n }\n\n case REMOVE_KEYS:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n Vector<uint8_t> keySetId;\n            readVector(data, keySetId);\n            reply->writeInt32(removeKeys(keySetId));\n return OK;\n }\n\n case RESTORE_KEYS:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n Vector<uint8_t> sessionId, keySetId;\n            readVector(data, sessionId);\n            readVector(data, keySetId);\n            reply->writeInt32(restoreKeys(sessionId, keySetId));\n return OK;\n }\n\n case QUERY_KEY_STATUS:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n Vector<uint8_t> sessionId;\n            readVector(data, sessionId);\n KeyedVector<String8, String8> infoMap;\n status_t result = queryKeyStatus(sessionId, infoMap);\n size_t count = infoMap.size();\n            reply->writeInt32(count);\n for (size_t i = 0; i < count; ++i) {\n                reply->writeString8(infoMap.keyAt(i));\n                reply->writeString8(infoMap.valueAt(i));\n }\n            reply->writeInt32(result);\n return OK;\n }\n\n case GET_PROVISION_REQUEST:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n String8 certType = data.readString8();\n String8 certAuthority = data.readString8();\n\n Vector<uint8_t> request;\n String8 defaultUrl;\n status_t result = getProvisionRequest(certType, certAuthority,\n                                                  request, defaultUrl);\n            writeVector(reply, request);\n            reply->writeString8(defaultUrl);\n            reply->writeInt32(result);\n return OK;\n }\n\n case PROVIDE_PROVISION_RESPONSE:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n Vector<uint8_t> response;\n Vector<uint8_t> certificate;\n Vector<uint8_t> wrappedKey;\n            readVector(data, response);\n status_t result = provideProvisionResponse(response, certificate, wrappedKey);\n            writeVector(reply, certificate);\n            writeVector(reply, wrappedKey);\n            reply->writeInt32(result);\n return OK;\n }\n\n case UNPROVISION_DEVICE:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n status_t result = unprovisionDevice();\n            reply->writeInt32(result);\n return OK;\n }\n\n case GET_SECURE_STOPS:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n List<Vector<uint8_t> > secureStops;\n status_t result = getSecureStops(secureStops);\n size_t count = secureStops.size();\n            reply->writeInt32(count);\n List<Vector<uint8_t> >::iterator iter = secureStops.begin();\n while(iter != secureStops.end()) {\n size_t size = iter->size();\n                reply->writeInt32(size);\n                reply->write(iter->array(), iter->size());\n                iter++;\n }\n            reply->writeInt32(result);\n return OK;\n }\n\n case GET_SECURE_STOP:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n Vector<uint8_t> ssid, secureStop;\n            readVector(data, ssid);\n status_t result = getSecureStop(ssid, secureStop);\n            writeVector(reply, secureStop);\n            reply->writeInt32(result);\n return OK;\n }\n\n case RELEASE_SECURE_STOPS:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n Vector<uint8_t> ssRelease;\n            readVector(data, ssRelease);\n            reply->writeInt32(releaseSecureStops(ssRelease));\n return OK;\n }\n\n case RELEASE_ALL_SECURE_STOPS:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n            reply->writeInt32(releaseAllSecureStops());\n return OK;\n }\n\n case GET_PROPERTY_STRING:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n String8 name = data.readString8();\n String8 value;\n status_t result = getPropertyString(name, value);\n            reply->writeString8(value);\n            reply->writeInt32(result);\n return OK;\n }\n\n case GET_PROPERTY_BYTE_ARRAY:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n String8 name = data.readString8();\n Vector<uint8_t> value;\n status_t result = getPropertyByteArray(name, value);\n            writeVector(reply, value);\n            reply->writeInt32(result);\n return OK;\n }\n\n case SET_PROPERTY_STRING:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n String8 name = data.readString8();\n String8 value = data.readString8();\n            reply->writeInt32(setPropertyString(name, value));\n return OK;\n }\n\n case SET_PROPERTY_BYTE_ARRAY:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n String8 name = data.readString8();\n Vector<uint8_t> value;\n            readVector(data, value);\n            reply->writeInt32(setPropertyByteArray(name, value));\n return OK;\n }\n\n case SET_CIPHER_ALGORITHM:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n Vector<uint8_t> sessionId;\n            readVector(data, sessionId);\n String8 algorithm = data.readString8();\n            reply->writeInt32(setCipherAlgorithm(sessionId, algorithm));\n return OK;\n }\n\n case SET_MAC_ALGORITHM:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n Vector<uint8_t> sessionId;\n            readVector(data, sessionId);\n String8 algorithm = data.readString8();\n            reply->writeInt32(setMacAlgorithm(sessionId, algorithm));\n return OK;\n }\n\n case ENCRYPT:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n Vector<uint8_t> sessionId, keyId, input, iv, output;\n            readVector(data, sessionId);\n            readVector(data, keyId);\n            readVector(data, input);\n            readVector(data, iv);\n uint32_t result = encrypt(sessionId, keyId, input, iv, output);\n            writeVector(reply, output);\n            reply->writeInt32(result);\n return OK;\n }\n\n case DECRYPT:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n Vector<uint8_t> sessionId, keyId, input, iv, output;\n            readVector(data, sessionId);\n            readVector(data, keyId);\n            readVector(data, input);\n            readVector(data, iv);\n uint32_t result = decrypt(sessionId, keyId, input, iv, output);\n            writeVector(reply, output);\n            reply->writeInt32(result);\n return OK;\n }\n\n case SIGN:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n Vector<uint8_t> sessionId, keyId, message, signature;\n            readVector(data, sessionId);\n            readVector(data, keyId);\n            readVector(data, message);\n uint32_t result = sign(sessionId, keyId, message, signature);\n            writeVector(reply, signature);\n            reply->writeInt32(result);\n return OK;\n }\n\n case VERIFY:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n Vector<uint8_t> sessionId, keyId, message, signature;\n            readVector(data, sessionId);\n            readVector(data, keyId);\n            readVector(data, message);\n            readVector(data, signature);\n bool match;\n uint32_t result = verify(sessionId, keyId, message, signature, match);\n            reply->writeInt32(match);\n            reply->writeInt32(result);\n return OK;\n }\n\n case SIGN_RSA:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n Vector<uint8_t> sessionId, message, wrappedKey, signature;\n            readVector(data, sessionId);\n String8 algorithm = data.readString8();\n            readVector(data, message);\n            readVector(data, wrappedKey);\n uint32_t result = signRSA(sessionId, algorithm, message, wrappedKey, signature);\n            writeVector(reply, signature);\n            reply->writeInt32(result);\n return OK;\n }\n\n case SET_LISTENER: {\n        CHECK_INTERFACE(IDrm, data, reply);\n        sp<IDrmClient> listener =\n            interface_cast<IDrmClient>(data.readStrongBinder());\n        reply->writeInt32(setListener(listener));\n return NO_ERROR;\n } break;\n\n default:\n return BBinder::onTransact(code, data, reply, flags);\n }\n}\n",
    "code_after_change": "status_t BnDrm::onTransact(\n uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {\n switch (code) {\n case INIT_CHECK:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n            reply->writeInt32(initCheck());\n return OK;\n }\n\n case IS_CRYPTO_SUPPORTED:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n uint8_t uuid[16];\n            data.read(uuid, sizeof(uuid));\n String8 mimeType = data.readString8();\n            reply->writeInt32(isCryptoSchemeSupported(uuid, mimeType));\n\n return OK;\n }\n\n case CREATE_PLUGIN:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n uint8_t uuid[16];\n            data.read(uuid, sizeof(uuid));\n            reply->writeInt32(createPlugin(uuid));\n return OK;\n }\n\n case DESTROY_PLUGIN:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n            reply->writeInt32(destroyPlugin());\n return OK;\n }\n\n case OPEN_SESSION:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n Vector<uint8_t> sessionId;\n status_t result = openSession(sessionId);\n            writeVector(reply, sessionId);\n            reply->writeInt32(result);\n return OK;\n }\n\n case CLOSE_SESSION:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n Vector<uint8_t> sessionId;\n            readVector(data, sessionId);\n            reply->writeInt32(closeSession(sessionId));\n return OK;\n }\n\n case GET_KEY_REQUEST:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n Vector<uint8_t> sessionId, initData;\n\n            readVector(data, sessionId);\n            readVector(data, initData);\n String8 mimeType = data.readString8();\n DrmPlugin::KeyType keyType = (DrmPlugin::KeyType)data.readInt32();\n\n KeyedVector<String8, String8> optionalParameters;\n uint32_t count = data.readInt32();\n for (size_t i = 0; i < count; ++i) {\n String8 key, value;\n                key = data.readString8();\n                value = data.readString8();\n                optionalParameters.add(key, value);\n }\n\n \n             Vector<uint8_t> request;\n             String8 defaultUrl;\n            DrmPlugin::KeyRequestType keyRequestType = DrmPlugin::kKeyRequestType_Unknown;\n \n             status_t result = getKeyRequest(sessionId, initData, mimeType,\n                     keyType, optionalParameters, request, defaultUrl,\n &keyRequestType);\n\n            writeVector(reply, request);\n            reply->writeString8(defaultUrl);\n            reply->writeInt32(static_cast<int32_t>(keyRequestType));\n            reply->writeInt32(result);\n return OK;\n }\n\n case PROVIDE_KEY_RESPONSE:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n Vector<uint8_t> sessionId, response, keySetId;\n            readVector(data, sessionId);\n            readVector(data, response);\n uint32_t result = provideKeyResponse(sessionId, response, keySetId);\n            writeVector(reply, keySetId);\n            reply->writeInt32(result);\n return OK;\n }\n\n case REMOVE_KEYS:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n Vector<uint8_t> keySetId;\n            readVector(data, keySetId);\n            reply->writeInt32(removeKeys(keySetId));\n return OK;\n }\n\n case RESTORE_KEYS:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n Vector<uint8_t> sessionId, keySetId;\n            readVector(data, sessionId);\n            readVector(data, keySetId);\n            reply->writeInt32(restoreKeys(sessionId, keySetId));\n return OK;\n }\n\n case QUERY_KEY_STATUS:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n Vector<uint8_t> sessionId;\n            readVector(data, sessionId);\n KeyedVector<String8, String8> infoMap;\n status_t result = queryKeyStatus(sessionId, infoMap);\n size_t count = infoMap.size();\n            reply->writeInt32(count);\n for (size_t i = 0; i < count; ++i) {\n                reply->writeString8(infoMap.keyAt(i));\n                reply->writeString8(infoMap.valueAt(i));\n }\n            reply->writeInt32(result);\n return OK;\n }\n\n case GET_PROVISION_REQUEST:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n String8 certType = data.readString8();\n String8 certAuthority = data.readString8();\n\n Vector<uint8_t> request;\n String8 defaultUrl;\n status_t result = getProvisionRequest(certType, certAuthority,\n                                                  request, defaultUrl);\n            writeVector(reply, request);\n            reply->writeString8(defaultUrl);\n            reply->writeInt32(result);\n return OK;\n }\n\n case PROVIDE_PROVISION_RESPONSE:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n Vector<uint8_t> response;\n Vector<uint8_t> certificate;\n Vector<uint8_t> wrappedKey;\n            readVector(data, response);\n status_t result = provideProvisionResponse(response, certificate, wrappedKey);\n            writeVector(reply, certificate);\n            writeVector(reply, wrappedKey);\n            reply->writeInt32(result);\n return OK;\n }\n\n case UNPROVISION_DEVICE:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n status_t result = unprovisionDevice();\n            reply->writeInt32(result);\n return OK;\n }\n\n case GET_SECURE_STOPS:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n List<Vector<uint8_t> > secureStops;\n status_t result = getSecureStops(secureStops);\n size_t count = secureStops.size();\n            reply->writeInt32(count);\n List<Vector<uint8_t> >::iterator iter = secureStops.begin();\n while(iter != secureStops.end()) {\n size_t size = iter->size();\n                reply->writeInt32(size);\n                reply->write(iter->array(), iter->size());\n                iter++;\n }\n            reply->writeInt32(result);\n return OK;\n }\n\n case GET_SECURE_STOP:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n Vector<uint8_t> ssid, secureStop;\n            readVector(data, ssid);\n status_t result = getSecureStop(ssid, secureStop);\n            writeVector(reply, secureStop);\n            reply->writeInt32(result);\n return OK;\n }\n\n case RELEASE_SECURE_STOPS:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n Vector<uint8_t> ssRelease;\n            readVector(data, ssRelease);\n            reply->writeInt32(releaseSecureStops(ssRelease));\n return OK;\n }\n\n case RELEASE_ALL_SECURE_STOPS:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n            reply->writeInt32(releaseAllSecureStops());\n return OK;\n }\n\n case GET_PROPERTY_STRING:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n String8 name = data.readString8();\n String8 value;\n status_t result = getPropertyString(name, value);\n            reply->writeString8(value);\n            reply->writeInt32(result);\n return OK;\n }\n\n case GET_PROPERTY_BYTE_ARRAY:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n String8 name = data.readString8();\n Vector<uint8_t> value;\n status_t result = getPropertyByteArray(name, value);\n            writeVector(reply, value);\n            reply->writeInt32(result);\n return OK;\n }\n\n case SET_PROPERTY_STRING:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n String8 name = data.readString8();\n String8 value = data.readString8();\n            reply->writeInt32(setPropertyString(name, value));\n return OK;\n }\n\n case SET_PROPERTY_BYTE_ARRAY:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n String8 name = data.readString8();\n Vector<uint8_t> value;\n            readVector(data, value);\n            reply->writeInt32(setPropertyByteArray(name, value));\n return OK;\n }\n\n case SET_CIPHER_ALGORITHM:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n Vector<uint8_t> sessionId;\n            readVector(data, sessionId);\n String8 algorithm = data.readString8();\n            reply->writeInt32(setCipherAlgorithm(sessionId, algorithm));\n return OK;\n }\n\n case SET_MAC_ALGORITHM:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n Vector<uint8_t> sessionId;\n            readVector(data, sessionId);\n String8 algorithm = data.readString8();\n            reply->writeInt32(setMacAlgorithm(sessionId, algorithm));\n return OK;\n }\n\n case ENCRYPT:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n Vector<uint8_t> sessionId, keyId, input, iv, output;\n            readVector(data, sessionId);\n            readVector(data, keyId);\n            readVector(data, input);\n            readVector(data, iv);\n uint32_t result = encrypt(sessionId, keyId, input, iv, output);\n            writeVector(reply, output);\n            reply->writeInt32(result);\n return OK;\n }\n\n case DECRYPT:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n Vector<uint8_t> sessionId, keyId, input, iv, output;\n            readVector(data, sessionId);\n            readVector(data, keyId);\n            readVector(data, input);\n            readVector(data, iv);\n uint32_t result = decrypt(sessionId, keyId, input, iv, output);\n            writeVector(reply, output);\n            reply->writeInt32(result);\n return OK;\n }\n\n case SIGN:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n Vector<uint8_t> sessionId, keyId, message, signature;\n            readVector(data, sessionId);\n            readVector(data, keyId);\n            readVector(data, message);\n uint32_t result = sign(sessionId, keyId, message, signature);\n            writeVector(reply, signature);\n            reply->writeInt32(result);\n return OK;\n }\n\n case VERIFY:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n Vector<uint8_t> sessionId, keyId, message, signature;\n            readVector(data, sessionId);\n            readVector(data, keyId);\n            readVector(data, message);\n            readVector(data, signature);\n bool match;\n uint32_t result = verify(sessionId, keyId, message, signature, match);\n            reply->writeInt32(match);\n            reply->writeInt32(result);\n return OK;\n }\n\n case SIGN_RSA:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n Vector<uint8_t> sessionId, message, wrappedKey, signature;\n            readVector(data, sessionId);\n String8 algorithm = data.readString8();\n            readVector(data, message);\n            readVector(data, wrappedKey);\n uint32_t result = signRSA(sessionId, algorithm, message, wrappedKey, signature);\n            writeVector(reply, signature);\n            reply->writeInt32(result);\n return OK;\n }\n\n case SET_LISTENER: {\n        CHECK_INTERFACE(IDrm, data, reply);\n        sp<IDrmClient> listener =\n            interface_cast<IDrmClient>(data.readStrongBinder());\n        reply->writeInt32(setListener(listener));\n return NO_ERROR;\n } break;\n\n default:\n return BBinder::onTransact(code, data, reply, flags);\n }\n}\n",
    "cwe": [
      "CWE-264"
    ],
    "id": 518,
    "_valid_cwes": [
      "CWE-264"
    ]
  },
  {
    "cve_id": "CVE-2010-1172",
    "code_before_change": "my_object_many_args (MyObject *obj, guint32 x, const char *str, double trouble, double *d_ret, char **str_ret, GError **error)\n{\n  *d_ret = trouble + (x * 2);\n  *str_ret = g_ascii_strup (str, -1);\n  return TRUE;\n}\n",
    "code_after_change": "my_object_many_args (MyObject *obj, guint32 x, const char *str, double trouble, double *d_ret, char **str_ret, GError **error)\n",
    "cwe": [
      "CWE-264"
    ],
    "id": 564,
    "_valid_cwes": [
      "CWE-264"
    ]
  },
  {
    "cve_id": "CVE-2016-3890",
    "code_before_change": "void close_all_sockets(atransport* t) {\n    asocket* s;\n\n\n     /* this is a little gross, but since s->close() *will* modify\n     ** the list out from under you, your options are limited.\n     */\n    adb_mutex_lock(&socket_list_lock);\n restart:\n     for (s = local_socket_list.next; s != &local_socket_list; s = s->next) {\n         if (s->transport == t || (s->peer && s->peer->transport == t)) {\n            local_socket_close_locked(s);\n             goto restart;\n         }\n     }\n    adb_mutex_unlock(&socket_list_lock);\n }\n",
    "code_after_change": "void close_all_sockets(atransport* t) {\n    asocket* s;\n\n\n     /* this is a little gross, but since s->close() *will* modify\n     ** the list out from under you, your options are limited.\n     */\n    std::lock_guard<std::recursive_mutex> lock(local_socket_list_lock);\n restart:\n     for (s = local_socket_list.next; s != &local_socket_list; s = s->next) {\n         if (s->transport == t || (s->peer && s->peer->transport == t)) {\n            local_socket_close(s);\n             goto restart;\n         }\n     }\n }\n",
    "cwe": [
      "CWE-264"
    ],
    "id": 573,
    "_valid_cwes": [
      "CWE-264"
    ]
  },
  {
    "cve_id": "CVE-2010-1172",
    "code_before_change": "my_object_terminate (MyObject *obj, GError **error)\n{\n  g_main_loop_quit (loop);\n  return TRUE;\n}\n",
    "code_after_change": "my_object_terminate (MyObject *obj, GError **error)\n",
    "cwe": [
      "CWE-264"
    ],
    "id": 579,
    "_valid_cwes": [
      "CWE-264"
    ]
  },
  {
    "cve_id": "CVE-2016-1632",
    "code_before_change": "std::unique_ptr<HistogramBase> PersistentHistogramAllocator::GetHistogram(\n    Reference ref) {\n  PersistentHistogramData* data =\n      memory_allocator_->GetAsObject<PersistentHistogramData>(ref);\n  const size_t length = memory_allocator_->GetAllocSize(ref);\n\n  if (!data || data->name[0] == '\\0' ||\n      reinterpret_cast<char*>(data)[length - 1] != '\\0' ||\n      data->samples_metadata.id == 0 || data->logged_metadata.id == 0 ||\n      (data->logged_metadata.id != data->samples_metadata.id &&\n       data->logged_metadata.id != data->samples_metadata.id + 1) ||\n       HashMetricName(data->name) != data->samples_metadata.id) {\n    RecordCreateHistogramResult(CREATE_HISTOGRAM_INVALID_METADATA);\n     NOTREACHED();\n     return nullptr;\n   }\n  return CreateHistogram(data);\n}\n",
    "code_after_change": "std::unique_ptr<HistogramBase> PersistentHistogramAllocator::GetHistogram(\n    Reference ref) {\n  PersistentHistogramData* data =\n      memory_allocator_->GetAsObject<PersistentHistogramData>(ref);\n  const size_t length = memory_allocator_->GetAllocSize(ref);\n\n  if (!data || data->name[0] == '\\0' ||\n      reinterpret_cast<char*>(data)[length - 1] != '\\0' ||\n      data->samples_metadata.id == 0 || data->logged_metadata.id == 0 ||\n      (data->logged_metadata.id != data->samples_metadata.id &&\n       data->logged_metadata.id != data->samples_metadata.id + 1) ||\n       HashMetricName(data->name) != data->samples_metadata.id) {\n     NOTREACHED();\n     return nullptr;\n   }\n  return CreateHistogram(data);\n}\n",
    "cwe": [
      "CWE-264"
    ],
    "id": 593,
    "_valid_cwes": [
      "CWE-264"
    ]
  },
  {
    "cve_id": "CVE-2013-1959",
    "code_before_change": "static ssize_t map_write(struct file *file, const char __user *buf,\n\t\t\t size_t count, loff_t *ppos,\n\t\t\t int cap_setid,\n\t\t\t struct uid_gid_map *map,\n\t\t\t struct uid_gid_map *parent_map)\n{\n\tstruct seq_file *seq = file->private_data;\n\tstruct user_namespace *ns = seq->private;\n\tstruct uid_gid_map new_map;\n\tunsigned idx;\n\tstruct uid_gid_extent *extent = NULL;\n\tunsigned long page = 0;\n\tchar *kbuf, *pos, *next_line;\n\tssize_t ret = -EINVAL;\n\n\t/*\n\t * The id_map_mutex serializes all writes to any given map.\n\t *\n\t * Any map is only ever written once.\n\t *\n\t * An id map fits within 1 cache line on most architectures.\n\t *\n\t * On read nothing needs to be done unless you are on an\n\t * architecture with a crazy cache coherency model like alpha.\n\t *\n\t * There is a one time data dependency between reading the\n\t * count of the extents and the values of the extents.  The\n\t * desired behavior is to see the values of the extents that\n\t * were written before the count of the extents.\n\t *\n\t * To achieve this smp_wmb() is used on guarantee the write\n\t * order and smp_read_barrier_depends() is guaranteed that we\n\t * don't have crazy architectures returning stale data.\n\t *\n\t */\n\tmutex_lock(&id_map_mutex);\n\n\tret = -EPERM;\n\t/* Only allow one successful write to the map */\n\tif (map->nr_extents != 0)\n\t\tgoto out;\n\n\t/* Require the appropriate privilege CAP_SETUID or CAP_SETGID\n\t * over the user namespace in order to set the id mapping.\n\t */\n\tif (cap_valid(cap_setid) && !ns_capable(ns, cap_setid))\n\t\tgoto out;\n\n\t/* Get a buffer */\n\tret = -ENOMEM;\n\tpage = __get_free_page(GFP_TEMPORARY);\n\tkbuf = (char *) page;\n\tif (!page)\n\t\tgoto out;\n\n\t/* Only allow <= page size writes at the beginning of the file */\n\tret = -EINVAL;\n\tif ((*ppos != 0) || (count >= PAGE_SIZE))\n\t\tgoto out;\n\n\t/* Slurp in the user data */\n\tret = -EFAULT;\n\tif (copy_from_user(kbuf, buf, count))\n\t\tgoto out;\n\tkbuf[count] = '\\0';\n\n\t/* Parse the user data */\n\tret = -EINVAL;\n\tpos = kbuf;\n\tnew_map.nr_extents = 0;\n\tfor (;pos; pos = next_line) {\n\t\textent = &new_map.extent[new_map.nr_extents];\n\n\t\t/* Find the end of line and ensure I don't look past it */\n\t\tnext_line = strchr(pos, '\\n');\n\t\tif (next_line) {\n\t\t\t*next_line = '\\0';\n\t\t\tnext_line++;\n\t\t\tif (*next_line == '\\0')\n\t\t\t\tnext_line = NULL;\n\t\t}\n\n\t\tpos = skip_spaces(pos);\n\t\textent->first = simple_strtoul(pos, &pos, 10);\n\t\tif (!isspace(*pos))\n\t\t\tgoto out;\n\n\t\tpos = skip_spaces(pos);\n\t\textent->lower_first = simple_strtoul(pos, &pos, 10);\n\t\tif (!isspace(*pos))\n\t\t\tgoto out;\n\n\t\tpos = skip_spaces(pos);\n\t\textent->count = simple_strtoul(pos, &pos, 10);\n\t\tif (*pos && !isspace(*pos))\n\t\t\tgoto out;\n\n\t\t/* Verify there is not trailing junk on the line */\n\t\tpos = skip_spaces(pos);\n\t\tif (*pos != '\\0')\n\t\t\tgoto out;\n\n\t\t/* Verify we have been given valid starting values */\n\t\tif ((extent->first == (u32) -1) ||\n\t\t    (extent->lower_first == (u32) -1 ))\n\t\t\tgoto out;\n\n\t\t/* Verify count is not zero and does not cause the extent to wrap */\n\t\tif ((extent->first + extent->count) <= extent->first)\n\t\t\tgoto out;\n\t\tif ((extent->lower_first + extent->count) <= extent->lower_first)\n\t\t\tgoto out;\n\n\t\t/* Do the ranges in extent overlap any previous extents? */\n\t\tif (mappings_overlap(&new_map, extent))\n\t\t\tgoto out;\n\n\t\tnew_map.nr_extents++;\n\n\t\t/* Fail if the file contains too many extents */\n\t\tif ((new_map.nr_extents == UID_GID_MAP_MAX_EXTENTS) &&\n\t\t    (next_line != NULL))\n\t\t\tgoto out;\n\t}\n\t/* Be very certaint the new map actually exists */\n\tif (new_map.nr_extents == 0)\n\t\tgoto out;\n \n \tret = -EPERM;\n \t/* Validate the user is allowed to use user id's mapped to. */\n\tif (!new_idmap_permitted(ns, cap_setid, &new_map))\n \t\tgoto out;\n \n \t/* Map the lower ids from the parent user namespace to the\n\t * kernel global id space.\n\t */\n\tfor (idx = 0; idx < new_map.nr_extents; idx++) {\n\t\tu32 lower_first;\n\t\textent = &new_map.extent[idx];\n\n\t\tlower_first = map_id_range_down(parent_map,\n\t\t\t\t\t\textent->lower_first,\n\t\t\t\t\t\textent->count);\n\n\t\t/* Fail if we can not map the specified extent to\n\t\t * the kernel global id space.\n\t\t */\n\t\tif (lower_first == (u32) -1)\n\t\t\tgoto out;\n\n\t\textent->lower_first = lower_first;\n\t}\n\n\t/* Install the map */\n\tmemcpy(map->extent, new_map.extent,\n\t\tnew_map.nr_extents*sizeof(new_map.extent[0]));\n\tsmp_wmb();\n\tmap->nr_extents = new_map.nr_extents;\n\n\t*ppos = count;\n\tret = count;\nout:\n\tmutex_unlock(&id_map_mutex);\n\tif (page)\n\t\tfree_page(page);\n\treturn ret;\n}\n",
    "code_after_change": "static ssize_t map_write(struct file *file, const char __user *buf,\n\t\t\t size_t count, loff_t *ppos,\n\t\t\t int cap_setid,\n\t\t\t struct uid_gid_map *map,\n\t\t\t struct uid_gid_map *parent_map)\n{\n\tstruct seq_file *seq = file->private_data;\n\tstruct user_namespace *ns = seq->private;\n\tstruct uid_gid_map new_map;\n\tunsigned idx;\n\tstruct uid_gid_extent *extent = NULL;\n\tunsigned long page = 0;\n\tchar *kbuf, *pos, *next_line;\n\tssize_t ret = -EINVAL;\n\n\t/*\n\t * The id_map_mutex serializes all writes to any given map.\n\t *\n\t * Any map is only ever written once.\n\t *\n\t * An id map fits within 1 cache line on most architectures.\n\t *\n\t * On read nothing needs to be done unless you are on an\n\t * architecture with a crazy cache coherency model like alpha.\n\t *\n\t * There is a one time data dependency between reading the\n\t * count of the extents and the values of the extents.  The\n\t * desired behavior is to see the values of the extents that\n\t * were written before the count of the extents.\n\t *\n\t * To achieve this smp_wmb() is used on guarantee the write\n\t * order and smp_read_barrier_depends() is guaranteed that we\n\t * don't have crazy architectures returning stale data.\n\t *\n\t */\n\tmutex_lock(&id_map_mutex);\n\n\tret = -EPERM;\n\t/* Only allow one successful write to the map */\n\tif (map->nr_extents != 0)\n\t\tgoto out;\n\n\t/* Require the appropriate privilege CAP_SETUID or CAP_SETGID\n\t * over the user namespace in order to set the id mapping.\n\t */\n\tif (cap_valid(cap_setid) && !ns_capable(ns, cap_setid))\n\t\tgoto out;\n\n\t/* Get a buffer */\n\tret = -ENOMEM;\n\tpage = __get_free_page(GFP_TEMPORARY);\n\tkbuf = (char *) page;\n\tif (!page)\n\t\tgoto out;\n\n\t/* Only allow <= page size writes at the beginning of the file */\n\tret = -EINVAL;\n\tif ((*ppos != 0) || (count >= PAGE_SIZE))\n\t\tgoto out;\n\n\t/* Slurp in the user data */\n\tret = -EFAULT;\n\tif (copy_from_user(kbuf, buf, count))\n\t\tgoto out;\n\tkbuf[count] = '\\0';\n\n\t/* Parse the user data */\n\tret = -EINVAL;\n\tpos = kbuf;\n\tnew_map.nr_extents = 0;\n\tfor (;pos; pos = next_line) {\n\t\textent = &new_map.extent[new_map.nr_extents];\n\n\t\t/* Find the end of line and ensure I don't look past it */\n\t\tnext_line = strchr(pos, '\\n');\n\t\tif (next_line) {\n\t\t\t*next_line = '\\0';\n\t\t\tnext_line++;\n\t\t\tif (*next_line == '\\0')\n\t\t\t\tnext_line = NULL;\n\t\t}\n\n\t\tpos = skip_spaces(pos);\n\t\textent->first = simple_strtoul(pos, &pos, 10);\n\t\tif (!isspace(*pos))\n\t\t\tgoto out;\n\n\t\tpos = skip_spaces(pos);\n\t\textent->lower_first = simple_strtoul(pos, &pos, 10);\n\t\tif (!isspace(*pos))\n\t\t\tgoto out;\n\n\t\tpos = skip_spaces(pos);\n\t\textent->count = simple_strtoul(pos, &pos, 10);\n\t\tif (*pos && !isspace(*pos))\n\t\t\tgoto out;\n\n\t\t/* Verify there is not trailing junk on the line */\n\t\tpos = skip_spaces(pos);\n\t\tif (*pos != '\\0')\n\t\t\tgoto out;\n\n\t\t/* Verify we have been given valid starting values */\n\t\tif ((extent->first == (u32) -1) ||\n\t\t    (extent->lower_first == (u32) -1 ))\n\t\t\tgoto out;\n\n\t\t/* Verify count is not zero and does not cause the extent to wrap */\n\t\tif ((extent->first + extent->count) <= extent->first)\n\t\t\tgoto out;\n\t\tif ((extent->lower_first + extent->count) <= extent->lower_first)\n\t\t\tgoto out;\n\n\t\t/* Do the ranges in extent overlap any previous extents? */\n\t\tif (mappings_overlap(&new_map, extent))\n\t\t\tgoto out;\n\n\t\tnew_map.nr_extents++;\n\n\t\t/* Fail if the file contains too many extents */\n\t\tif ((new_map.nr_extents == UID_GID_MAP_MAX_EXTENTS) &&\n\t\t    (next_line != NULL))\n\t\t\tgoto out;\n\t}\n\t/* Be very certaint the new map actually exists */\n\tif (new_map.nr_extents == 0)\n\t\tgoto out;\n \n \tret = -EPERM;\n \t/* Validate the user is allowed to use user id's mapped to. */\n\tif (!new_idmap_permitted(file, ns, cap_setid, &new_map))\n \t\tgoto out;\n \n \t/* Map the lower ids from the parent user namespace to the\n\t * kernel global id space.\n\t */\n\tfor (idx = 0; idx < new_map.nr_extents; idx++) {\n\t\tu32 lower_first;\n\t\textent = &new_map.extent[idx];\n\n\t\tlower_first = map_id_range_down(parent_map,\n\t\t\t\t\t\textent->lower_first,\n\t\t\t\t\t\textent->count);\n\n\t\t/* Fail if we can not map the specified extent to\n\t\t * the kernel global id space.\n\t\t */\n\t\tif (lower_first == (u32) -1)\n\t\t\tgoto out;\n\n\t\textent->lower_first = lower_first;\n\t}\n\n\t/* Install the map */\n\tmemcpy(map->extent, new_map.extent,\n\t\tnew_map.nr_extents*sizeof(new_map.extent[0]));\n\tsmp_wmb();\n\tmap->nr_extents = new_map.nr_extents;\n\n\t*ppos = count;\n\tret = count;\nout:\n\tmutex_unlock(&id_map_mutex);\n\tif (page)\n\t\tfree_page(page);\n\treturn ret;\n}\n",
    "cwe": [
      "CWE-264"
    ],
    "id": 605,
    "_valid_cwes": [
      "CWE-264"
    ]
  },
  {
    "cve_id": "CVE-2011-4127",
    "code_before_change": " static int flakey_ioctl(struct dm_target *ti, unsigned int cmd, unsigned long arg)\n {\n \tstruct flakey_c *fc = ti->private;\n \n\treturn __blkdev_driver_ioctl(fc->dev->bdev, fc->dev->mode, cmd, arg);\n }\n",
    "code_after_change": " static int flakey_ioctl(struct dm_target *ti, unsigned int cmd, unsigned long arg)\n {\n \tstruct flakey_c *fc = ti->private;\n\tstruct dm_dev *dev = fc->dev;\n\tint r = 0;\n \n\t/*\n\t * Only pass ioctls through if the device sizes match exactly.\n\t */\n\tif (fc->start ||\n\t    ti->len != i_size_read(dev->bdev->bd_inode) >> SECTOR_SHIFT)\n\t\tr = scsi_verify_blk_ioctl(NULL, cmd);\n\n\treturn r ? : __blkdev_driver_ioctl(dev->bdev, dev->mode, cmd, arg);\n }\n",
    "cwe": [
      "CWE-264"
    ],
    "id": 625,
    "_valid_cwes": [
      "CWE-264"
    ]
  },
  {
    "cve_id": "CVE-2011-2795",
    "code_before_change": " void ShadowRoot::setInnerHTML(const String& markup, ExceptionCode& ec)\n {\n    RefPtr<DocumentFragment> fragment = createFragmentFromSource(markup, host(), ec);\n    if (fragment)\n         replaceChildrenWithFragment(this, fragment.release(), ec);\n }\n",
    "code_after_change": " void ShadowRoot::setInnerHTML(const String& markup, ExceptionCode& ec)\n {\n    if (RefPtr<DocumentFragment> fragment = createFragmentForInnerOuterHTML(markup, host(), ec))\n         replaceChildrenWithFragment(this, fragment.release(), ec);\n }\n",
    "cwe": [
      "CWE-264"
    ],
    "id": 633,
    "_valid_cwes": [
      "CWE-264"
    ]
  },
  {
    "cve_id": "CVE-2011-3084",
    "code_before_change": "bool DebuggerFunction::InitTabContents() {\n  Value* debuggee;\n  EXTENSION_FUNCTION_VALIDATE(args_->Get(0, &debuggee));\n\n  DictionaryValue* dict = static_cast<DictionaryValue*>(debuggee);\n  EXTENSION_FUNCTION_VALIDATE(dict->GetInteger(keys::kTabIdKey, &tab_id_));\n\n  contents_ = NULL;\n  TabContentsWrapper* wrapper = NULL;\n  bool result = ExtensionTabUtil::GetTabById(\n      tab_id_, profile(), include_incognito(), NULL, NULL, &wrapper, NULL);\n  if (!result || !wrapper) {\n    error_ = ExtensionErrorUtils::FormatErrorMessage(\n        keys::kNoTabError,\n        base::IntToString(tab_id_));\n    return false;\n   }\n   contents_ = wrapper->web_contents();\n \n  if (ChromeWebUIControllerFactory::GetInstance()->HasWebUIScheme(\n           contents_->GetURL())) {\n     error_ = ExtensionErrorUtils::FormatErrorMessage(\n         keys::kAttachToWebUIError,\n        contents_->GetURL().scheme());\n    return false;\n  }\n\n  return true;\n}\n",
    "code_after_change": "bool DebuggerFunction::InitTabContents() {\n  Value* debuggee;\n  EXTENSION_FUNCTION_VALIDATE(args_->Get(0, &debuggee));\n\n  DictionaryValue* dict = static_cast<DictionaryValue*>(debuggee);\n  EXTENSION_FUNCTION_VALIDATE(dict->GetInteger(keys::kTabIdKey, &tab_id_));\n\n  contents_ = NULL;\n  TabContentsWrapper* wrapper = NULL;\n  bool result = ExtensionTabUtil::GetTabById(\n      tab_id_, profile(), include_incognito(), NULL, NULL, &wrapper, NULL);\n  if (!result || !wrapper) {\n    error_ = ExtensionErrorUtils::FormatErrorMessage(\n        keys::kNoTabError,\n        base::IntToString(tab_id_));\n    return false;\n   }\n   contents_ = wrapper->web_contents();\n \n  if (content::GetContentClient()->HasWebUIScheme(\n           contents_->GetURL())) {\n     error_ = ExtensionErrorUtils::FormatErrorMessage(\n         keys::kAttachToWebUIError,\n        contents_->GetURL().scheme());\n    return false;\n  }\n\n  return true;\n}\n",
    "cwe": [
      "CWE-264"
    ],
    "id": 683,
    "_valid_cwes": [
      "CWE-264"
    ]
  },
  {
    "cve_id": "CVE-2016-1631",
    "code_before_change": " TestFlashMessageLoop::~TestFlashMessageLoop() {\n   PP_DCHECK(!message_loop_);\n }\n",
    "code_after_change": " TestFlashMessageLoop::~TestFlashMessageLoop() {\n   PP_DCHECK(!message_loop_);\n\n  ResetTestObject();\n  if (instance_so_)\n    instance_so_->clear_owner();\n }\n",
    "cwe": [
      "CWE-264"
    ],
    "id": 807,
    "_valid_cwes": [
      "CWE-264"
    ]
  },
  {
    "cve_id": "CVE-2016-1630",
    "code_before_change": "ShellMainDelegate::ShellMainDelegate() {\n}\n",
    "code_after_change": "ShellMainDelegate::ShellMainDelegate() {\n",
    "cwe": [
      "CWE-264"
    ],
    "id": 827,
    "_valid_cwes": [
      "CWE-264"
    ]
  },
  {
    "cve_id": "CVE-2015-6520",
    "code_before_change": "static void start_daemon()\n{\n\tstruct usb_sock_t *usb_sock;\n\tif (g_options.noprinter_mode == 0) {\n\t\tusb_sock = usb_open();\n\t\tif (usb_sock == NULL)\n\t\t\tgoto cleanup_usb;\n\t} else\n\t\tusb_sock = NULL;\n \n \tuint16_t desired_port = g_options.desired_port;\n\tstruct tcp_sock_t *tcp_socket;\n\twhile ((tcp_socket = tcp_open(desired_port)) == NULL &&\n\t       g_options.only_desired_port == 0) {\n \t\tdesired_port ++;\n\t\tif (desired_port == 1 || desired_port == 0)\n \t\t\tdesired_port = 49152;\n \t}\n\tif (tcp_socket == NULL)\n \t\tgoto cleanup_tcp;\n \n\tuint16_t real_port = tcp_port_number_get(tcp_socket);\n \tif (desired_port != 0 && g_options.only_desired_port == 1 &&\n \t    desired_port != real_port) {\n \t\tERR(\"Received port number did not match requested port number.\"\n\t\t    \" The requested port number may be too high.\");\n\t\tgoto cleanup_tcp;\n\t}\n \tprintf(\"%u|\", real_port);\n \tfflush(stdout);\n \n \tuint16_t pid;\n \tif (!g_options.nofork_mode && (pid = fork()) > 0) {\n\t\tprintf(\"%u|\", pid);\n\t\texit(0);\n\t}\n\n\tif (usb_can_callback(usb_sock))\n\t\tusb_register_callback(usb_sock);\n\n\tfor (;;) {\n\t\tstruct service_thread_param *args = calloc(1, sizeof(*args));\n\t\tif (args == NULL) {\n\t\t\tERR(\"Failed to alloc space for thread args\");\n\t\t\tgoto cleanup_thread;\n \t\t}\n \n \t\targs->usb_sock = usb_sock;\n\t\targs->tcp = tcp_conn_accept(tcp_socket);\n \t\tif (args->tcp == NULL) {\n \t\t\tERR(\"Failed to open tcp connection\");\n \t\t\tgoto cleanup_thread;\n\t\t}\n\n\t\tint status = pthread_create(&args->thread_handle, NULL,\n\t\t                            &service_connection, args);\n\t\tif (status) {\n\t\t\tERR(\"Failed to spawn thread, error %d\", status);\n\t\t\tgoto cleanup_thread;\n\t\t}\n\n\t\tcontinue;\n\n\tcleanup_thread:\n\t\tif (args != NULL) {\n\t\t\tif (args->tcp != NULL)\n\t\t\t\ttcp_conn_close(args->tcp);\n\t\t\tfree(args);\n\t\t}\n\t\tbreak;\n\t}\n\n cleanup_tcp:\n \tif (tcp_socket!= NULL)\n \t\ttcp_close(tcp_socket);\n cleanup_usb:\n \tif (usb_sock != NULL)\n \t\tusb_close(usb_sock);\n\treturn;\n}\n",
    "code_after_change": "static void start_daemon()\n{\n\tstruct usb_sock_t *usb_sock;\n\tif (g_options.noprinter_mode == 0) {\n\t\tusb_sock = usb_open();\n\t\tif (usb_sock == NULL)\n\t\t\tgoto cleanup_usb;\n\t} else\n\t\tusb_sock = NULL;\n \n \tuint16_t desired_port = g_options.desired_port;\n\tstruct tcp_sock_t *tcp_socket = NULL, *tcp6_socket = NULL;\n\tfor (;;) {\n\t\ttcp_socket = tcp_open(desired_port);\n\t\ttcp6_socket = tcp6_open(desired_port);\n\t\tif (tcp_socket || tcp6_socket || g_options.only_desired_port)\n\t\t\tbreak;\n \t\tdesired_port ++;\n\t\tif (desired_port == 1 || desired_port == 0)\n \t\t\tdesired_port = 49152;\n\t\tNOTE(\"Access to desired port failed, trying alternative port %d\", desired_port);\n \t}\n\tif (tcp_socket == NULL && tcp6_socket == NULL)\n \t\tgoto cleanup_tcp;\n \n\tuint16_t real_port;\n\tif (tcp_socket)\n\t  real_port = tcp_port_number_get(tcp_socket);\n\telse\n\t  real_port = tcp_port_number_get(tcp6_socket);\n \tif (desired_port != 0 && g_options.only_desired_port == 1 &&\n \t    desired_port != real_port) {\n \t\tERR(\"Received port number did not match requested port number.\"\n\t\t    \" The requested port number may be too high.\");\n\t\tgoto cleanup_tcp;\n\t}\n \tprintf(\"%u|\", real_port);\n \tfflush(stdout);\n \n\tNOTE(\"Port: %d, IPv4 %savailable, IPv6 %savailable\",\n\t     real_port, tcp_socket ? \"\" : \"not \", tcp6_socket ? \"\" : \"not \");\n\n \tuint16_t pid;\n \tif (!g_options.nofork_mode && (pid = fork()) > 0) {\n\t\tprintf(\"%u|\", pid);\n\t\texit(0);\n\t}\n\n\tif (usb_can_callback(usb_sock))\n\t\tusb_register_callback(usb_sock);\n\n\tfor (;;) {\n\t\tstruct service_thread_param *args = calloc(1, sizeof(*args));\n\t\tif (args == NULL) {\n\t\t\tERR(\"Failed to alloc space for thread args\");\n\t\t\tgoto cleanup_thread;\n \t\t}\n \n \t\targs->usb_sock = usb_sock;\n\n\t\t// For each request/response round we use the socket (IPv4 or\n\t\t// IPv6) which receives data first\n\t\targs->tcp = tcp_conn_select(tcp_socket, tcp6_socket);\n \t\tif (args->tcp == NULL) {\n \t\t\tERR(\"Failed to open tcp connection\");\n \t\t\tgoto cleanup_thread;\n\t\t}\n\n\t\tint status = pthread_create(&args->thread_handle, NULL,\n\t\t                            &service_connection, args);\n\t\tif (status) {\n\t\t\tERR(\"Failed to spawn thread, error %d\", status);\n\t\t\tgoto cleanup_thread;\n\t\t}\n\n\t\tcontinue;\n\n\tcleanup_thread:\n\t\tif (args != NULL) {\n\t\t\tif (args->tcp != NULL)\n\t\t\t\ttcp_conn_close(args->tcp);\n\t\t\tfree(args);\n\t\t}\n\t\tbreak;\n\t}\n\n cleanup_tcp:\n \tif (tcp_socket!= NULL)\n \t\ttcp_close(tcp_socket);\n\tif (tcp6_socket!= NULL)\n\t\ttcp_close(tcp6_socket);\n cleanup_usb:\n \tif (usb_sock != NULL)\n \t\tusb_close(usb_sock);\n\treturn;\n}\n",
    "cwe": [
      "CWE-264"
    ],
    "id": 828,
    "_valid_cwes": [
      "CWE-264"
    ]
  },
  {
    "cve_id": "CVE-2014-3980",
    "code_before_change": "_fep_open_control_socket (Fep *fep)\n{\n  struct sockaddr_un sun;\n  char *path;\n  int fd;\n  ssize_t sun_len;\n\n  fd = socket (AF_UNIX, SOCK_STREAM, 0);\n  if (fd < 0)\n    {\n      perror (\"socket\");\n      return -1;\n    }\n\n  path = create_socket_name (\"fep-XXXXXX/control\");\n  if (strlen (path) + 1 >= sizeof(sun.sun_path))\n    {\n      fep_log (FEP_LOG_LEVEL_WARNING,\n\t       \"unix domain socket path too long: %d + 1 >= %d\",\n\t       strlen (path),\n\t       sizeof (sun.sun_path));\n      free (path);\n      return -1;\n    }\n\n   memset (&sun, 0, sizeof(sun));\n   sun.sun_family = AF_UNIX;\n \n#ifdef __linux__\n  sun.sun_path[0] = '\\0';\n  memcpy (sun.sun_path + 1, path, strlen (path));\n  sun_len = offsetof (struct sockaddr_un, sun_path) + strlen (path) + 1;\n  remove_control_socket (path);\n#else\n   memcpy (sun.sun_path, path, strlen (path));\n   sun_len = sizeof (struct sockaddr_un);\n#endif\n \n   if (bind (fd, (const struct sockaddr *) &sun, sun_len) < 0)\n     {\n      perror (\"bind\");\n      free (path);\n      close (fd);\n      return -1;\n    }\n\n  if (listen (fd, 5) < 0)\n    {\n      perror (\"listen\");\n      free (path);\n      close (fd);\n      return -1;\n    }\n\n  fep->server = fd;\n  fep->control_socket_path = path;\n  return 0;\n}\n",
    "code_after_change": "_fep_open_control_socket (Fep *fep)\n{\n  struct sockaddr_un sun;\n  char *path;\n  int fd;\n  ssize_t sun_len;\n\n  fd = socket (AF_UNIX, SOCK_STREAM, 0);\n  if (fd < 0)\n    {\n      perror (\"socket\");\n      return -1;\n    }\n\n  path = create_socket_name (\"fep-XXXXXX/control\");\n  if (strlen (path) + 1 >= sizeof(sun.sun_path))\n    {\n      fep_log (FEP_LOG_LEVEL_WARNING,\n\t       \"unix domain socket path too long: %d + 1 >= %d\",\n\t       strlen (path),\n\t       sizeof (sun.sun_path));\n      free (path);\n      return -1;\n    }\n\n   memset (&sun, 0, sizeof(sun));\n   sun.sun_family = AF_UNIX;\n \n   memcpy (sun.sun_path, path, strlen (path));\n   sun_len = sizeof (struct sockaddr_un);\n \n   if (bind (fd, (const struct sockaddr *) &sun, sun_len) < 0)\n     {\n      perror (\"bind\");\n      free (path);\n      close (fd);\n      return -1;\n    }\n\n  if (listen (fd, 5) < 0)\n    {\n      perror (\"listen\");\n      free (path);\n      close (fd);\n      return -1;\n    }\n\n  fep->server = fd;\n  fep->control_socket_path = path;\n  return 0;\n}\n",
    "cwe": [
      "CWE-264"
    ],
    "id": 843,
    "_valid_cwes": [
      "CWE-264"
    ]
  },
  {
    "cve_id": "CVE-2012-1179",
    "code_before_change": "static inline int unuse_pmd_range(struct vm_area_struct *vma, pud_t *pud,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tswp_entry_t entry, struct page *page)\n{\n\tpmd_t *pmd;\n\tunsigned long next;\n\tint ret;\n\n \tpmd = pmd_offset(pud, addr);\n \tdo {\n \t\tnext = pmd_addr_end(addr, end);\n\t\tif (unlikely(pmd_trans_huge(*pmd)))\n\t\t\tcontinue;\n\t\tif (pmd_none_or_clear_bad(pmd))\n \t\t\tcontinue;\n \t\tret = unuse_pte_range(vma, pmd, addr, next, entry, page);\n \t\tif (ret)\n\t\t\treturn ret;\n\t} while (pmd++, addr = next, addr != end);\n\treturn 0;\n}\n",
    "code_after_change": "static inline int unuse_pmd_range(struct vm_area_struct *vma, pud_t *pud,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tswp_entry_t entry, struct page *page)\n{\n\tpmd_t *pmd;\n\tunsigned long next;\n\tint ret;\n\n \tpmd = pmd_offset(pud, addr);\n \tdo {\n \t\tnext = pmd_addr_end(addr, end);\n\t\tif (pmd_none_or_trans_huge_or_clear_bad(pmd))\n \t\t\tcontinue;\n \t\tret = unuse_pte_range(vma, pmd, addr, next, entry, page);\n \t\tif (ret)\n\t\t\treturn ret;\n\t} while (pmd++, addr = next, addr != end);\n\treturn 0;\n}\n",
    "cwe": [
      "CWE-264"
    ],
    "id": 884,
    "_valid_cwes": [
      "CWE-264"
    ]
  },
  {
    "cve_id": "CVE-2013-0925",
    "code_before_change": " void BrowserEventRouter::DispatchTabUpdatedEvent(\n    WebContents* contents, DictionaryValue* changed_properties) {\n   DCHECK(changed_properties);\n   DCHECK(contents);\n \n  scoped_ptr<ListValue> args_base(new ListValue());\n\n   args_base->AppendInteger(ExtensionTabUtil::GetTabId(contents));\n \n  args_base->Append(changed_properties);\n \n  Profile* profile = Profile::FromBrowserContext(contents->GetBrowserContext());\n\n  scoped_ptr<Event> event(new Event(events::kOnTabUpdated, args_base.Pass()));\n   event->restrict_to_profile = profile;\n   event->user_gesture = EventRouter::USER_GESTURE_NOT_ENABLED;\n   event->will_dispatch_callback =\n      base::Bind(&WillDispatchTabUpdatedEvent, contents);\n   ExtensionSystem::Get(profile)->event_router()->BroadcastEvent(event.Pass());\n }\n",
    "code_after_change": " void BrowserEventRouter::DispatchTabUpdatedEvent(\n    WebContents* contents, scoped_ptr<DictionaryValue> changed_properties) {\n   DCHECK(changed_properties);\n   DCHECK(contents);\n \n  scoped_ptr<ListValue> args_base(new ListValue());\n\n   args_base->AppendInteger(ExtensionTabUtil::GetTabId(contents));\n \n  // Second arg: An object containing the changes to the tab state.  Filled in\n  // by WillDispatchTabUpdatedEvent as a copy of changed_properties, if the\n  // extension has the tabs permission.\n \n  Profile* profile = Profile::FromBrowserContext(contents->GetBrowserContext());\n\n  scoped_ptr<Event> event(new Event(events::kOnTabUpdated, args_base.Pass()));\n   event->restrict_to_profile = profile;\n   event->user_gesture = EventRouter::USER_GESTURE_NOT_ENABLED;\n   event->will_dispatch_callback =\n      base::Bind(&WillDispatchTabUpdatedEvent,\n                 contents, changed_properties.get());\n   ExtensionSystem::Get(profile)->event_router()->BroadcastEvent(event.Pass());\n }\n",
    "cwe": [
      "CWE-264"
    ],
    "id": 898,
    "_valid_cwes": [
      "CWE-264"
    ]
  },
  {
    "cve_id": "CVE-2013-0838",
    "code_before_change": "bool BackingStoreGtk::CopyFromBackingStore(const gfx::Rect& rect,\n                                           skia::PlatformCanvas* output) {\n  base::TimeTicks begin_time = base::TimeTicks::Now();\n\n  if (visual_depth_ < 24) {\n    return false;\n  }\n\n  const int width = std::min(size().width(), rect.width());\n  const int height = std::min(size().height(), rect.height());\n\n  XImage* image;\n  XShmSegmentInfo shminfo;  // Used only when shared memory is enabled.\n  if (shared_memory_support_ != ui::SHARED_MEMORY_NONE) {\n    Visual* visual = static_cast<Visual*>(visual_);\n    memset(&shminfo, 0, sizeof(shminfo));\n    image = XShmCreateImage(display_, visual, 32,\n                            ZPixmap, NULL, &shminfo, width, height);\n    if (!image) {\n      return false;\n    }\n    if (image->bytes_per_line == 0 || image->height == 0 ||\n        static_cast<size_t>(image->height) >\n        (std::numeric_limits<size_t>::max() / image->bytes_per_line)) {\n      XDestroyImage(image);\n       return false;\n     }\n     shminfo.shmid = shmget(IPC_PRIVATE, image->bytes_per_line * image->height,\n                           IPC_CREAT|0666);\n     if (shminfo.shmid == -1) {\n       XDestroyImage(image);\n       return false;\n     }\n \n     void* mapped_memory = shmat(shminfo.shmid, NULL, SHM_RDONLY);\n    shmctl(shminfo.shmid, IPC_RMID, 0);\n    if (mapped_memory == (void*)-1) {\n      XDestroyImage(image);\n      return false;\n    }\n    shminfo.shmaddr = image->data = static_cast<char*>(mapped_memory);\n\n    if (!XShmAttach(display_, &shminfo) ||\n         !XShmGetImage(display_, pixmap_, image, rect.x(), rect.y(),\n                       AllPlanes)) {\n       DestroySharedImage(display_, image, &shminfo);\n       return false;\n     }\n   } else {\n     image = XGetImage(display_, pixmap_,\n                       rect.x(), rect.y(), width, height,\n                      AllPlanes, ZPixmap);\n  }\n\n  if (!output->initialize(width, height, true) ||\n      image->bits_per_pixel != 32) {\n    if (shared_memory_support_ != ui::SHARED_MEMORY_NONE)\n      DestroySharedImage(display_, image, &shminfo);\n    else\n      XDestroyImage(image);\n    return false;\n  }\n\n  SkBitmap bitmap = skia::GetTopDevice(*output)->accessBitmap(true);\n  SkAutoLockPixels alp(bitmap);\n\n  for (int y = 0; y < height; y++) {\n    const uint32* src_row = reinterpret_cast<uint32*>(\n        &image->data[image->bytes_per_line * y]);\n    uint32* dest_row = bitmap.getAddr32(0, y);\n    for (int x = 0; x < width; ++x, ++dest_row) {\n      *dest_row = src_row[x] | 0xff000000;\n    }\n  }\n\n  if (shared_memory_support_ != ui::SHARED_MEMORY_NONE)\n    DestroySharedImage(display_, image, &shminfo);\n  else\n    XDestroyImage(image);\n\n  HISTOGRAM_TIMES(\"BackingStore.RetrievalFromX\",\n                  base::TimeTicks::Now() - begin_time);\n  return true;\n}\n",
    "code_after_change": "bool BackingStoreGtk::CopyFromBackingStore(const gfx::Rect& rect,\n                                           skia::PlatformCanvas* output) {\n  base::TimeTicks begin_time = base::TimeTicks::Now();\n\n  if (visual_depth_ < 24) {\n    return false;\n  }\n\n  const int width = std::min(size().width(), rect.width());\n  const int height = std::min(size().height(), rect.height());\n\n  XImage* image;\n  XShmSegmentInfo shminfo;  // Used only when shared memory is enabled.\n  if (shared_memory_support_ != ui::SHARED_MEMORY_NONE) {\n    Visual* visual = static_cast<Visual*>(visual_);\n    memset(&shminfo, 0, sizeof(shminfo));\n    image = XShmCreateImage(display_, visual, 32,\n                            ZPixmap, NULL, &shminfo, width, height);\n    if (!image) {\n      return false;\n    }\n    if (image->bytes_per_line == 0 || image->height == 0 ||\n        static_cast<size_t>(image->height) >\n        (std::numeric_limits<size_t>::max() / image->bytes_per_line)) {\n      XDestroyImage(image);\n       return false;\n     }\n     shminfo.shmid = shmget(IPC_PRIVATE, image->bytes_per_line * image->height,\n                           IPC_CREAT|0600);\n     if (shminfo.shmid == -1) {\n       XDestroyImage(image);\n      LOG(WARNING) << \"Failed to get shared memory segment. \"\n                      \"Performance may be degraded.\";\n       return false;\n    } else {\n      VLOG(1) << \"Got shared memory segment \" << shminfo.shmid;\n     }\n \n     void* mapped_memory = shmat(shminfo.shmid, NULL, SHM_RDONLY);\n    shmctl(shminfo.shmid, IPC_RMID, 0);\n    if (mapped_memory == (void*)-1) {\n      XDestroyImage(image);\n      return false;\n    }\n    shminfo.shmaddr = image->data = static_cast<char*>(mapped_memory);\n\n    if (!XShmAttach(display_, &shminfo) ||\n         !XShmGetImage(display_, pixmap_, image, rect.x(), rect.y(),\n                       AllPlanes)) {\n       DestroySharedImage(display_, image, &shminfo);\n      LOG(WARNING) << \"X failed to get shared memory segment. \"\n                      \"Performance may be degraded.\";\n       return false;\n     }\n\n    VLOG(1) << \"Using X shared memory segment \" << shminfo.shmid;\n   } else {\n    LOG(WARNING) << \"Not using X shared memory.\";\n     image = XGetImage(display_, pixmap_,\n                       rect.x(), rect.y(), width, height,\n                      AllPlanes, ZPixmap);\n  }\n\n  if (!output->initialize(width, height, true) ||\n      image->bits_per_pixel != 32) {\n    if (shared_memory_support_ != ui::SHARED_MEMORY_NONE)\n      DestroySharedImage(display_, image, &shminfo);\n    else\n      XDestroyImage(image);\n    return false;\n  }\n\n  SkBitmap bitmap = skia::GetTopDevice(*output)->accessBitmap(true);\n  SkAutoLockPixels alp(bitmap);\n\n  for (int y = 0; y < height; y++) {\n    const uint32* src_row = reinterpret_cast<uint32*>(\n        &image->data[image->bytes_per_line * y]);\n    uint32* dest_row = bitmap.getAddr32(0, y);\n    for (int x = 0; x < width; ++x, ++dest_row) {\n      *dest_row = src_row[x] | 0xff000000;\n    }\n  }\n\n  if (shared_memory_support_ != ui::SHARED_MEMORY_NONE)\n    DestroySharedImage(display_, image, &shminfo);\n  else\n    XDestroyImage(image);\n\n  HISTOGRAM_TIMES(\"BackingStore.RetrievalFromX\",\n                  base::TimeTicks::Now() - begin_time);\n  return true;\n}\n",
    "cwe": [
      "CWE-264"
    ],
    "id": 906,
    "_valid_cwes": [
      "CWE-264"
    ]
  },
  {
    "cve_id": "CVE-2016-2440",
    "code_before_change": "status_t IPCThreadState::executeCommand(int32_t cmd)\n{\n BBinder* obj;\n RefBase::weakref_type* refs;\n status_t result = NO_ERROR;\n \n switch ((uint32_t)cmd) {\n case BR_ERROR:\n        result = mIn.readInt32();\n break;\n \n case BR_OK:\n break;\n \n case BR_ACQUIRE:\n        refs = (RefBase::weakref_type*)mIn.readPointer();\n        obj = (BBinder*)mIn.readPointer();\n        ALOG_ASSERT(refs->refBase() == obj,\n \"BR_ACQUIRE: object %p does not match cookie %p (expected %p)\",\n                   refs, obj, refs->refBase());\n        obj->incStrong(mProcess.get());\n        IF_LOG_REMOTEREFS() {\n            LOG_REMOTEREFS(\"BR_ACQUIRE from driver on %p\", obj);\n            obj->printRefs();\n }\n        mOut.writeInt32(BC_ACQUIRE_DONE);\n        mOut.writePointer((uintptr_t)refs);\n        mOut.writePointer((uintptr_t)obj);\n break;\n \n case BR_RELEASE:\n        refs = (RefBase::weakref_type*)mIn.readPointer();\n        obj = (BBinder*)mIn.readPointer();\n        ALOG_ASSERT(refs->refBase() == obj,\n \"BR_RELEASE: object %p does not match cookie %p (expected %p)\",\n                   refs, obj, refs->refBase());\n        IF_LOG_REMOTEREFS() {\n            LOG_REMOTEREFS(\"BR_RELEASE from driver on %p\", obj);\n            obj->printRefs();\n }\n        mPendingStrongDerefs.push(obj);\n break;\n \n case BR_INCREFS:\n        refs = (RefBase::weakref_type*)mIn.readPointer();\n        obj = (BBinder*)mIn.readPointer();\n        refs->incWeak(mProcess.get());\n        mOut.writeInt32(BC_INCREFS_DONE);\n        mOut.writePointer((uintptr_t)refs);\n        mOut.writePointer((uintptr_t)obj);\n break;\n \n case BR_DECREFS:\n        refs = (RefBase::weakref_type*)mIn.readPointer();\n        obj = (BBinder*)mIn.readPointer();\n        mPendingWeakDerefs.push(refs);\n break;\n \n case BR_ATTEMPT_ACQUIRE:\n        refs = (RefBase::weakref_type*)mIn.readPointer();\n        obj = (BBinder*)mIn.readPointer();\n \n {\n const bool success = refs->attemptIncStrong(mProcess.get());\n            ALOG_ASSERT(success && refs->refBase() == obj,\n \"BR_ATTEMPT_ACQUIRE: object %p does not match cookie %p (expected %p)\",\n                       refs, obj, refs->refBase());\n \n            mOut.writeInt32(BC_ACQUIRE_RESULT);\n            mOut.writeInt32((int32_t)success);\n }\n break;\n \n case BR_TRANSACTION:\n {\n            binder_transaction_data tr;\n            result = mIn.read(&tr, sizeof(tr));\n            ALOG_ASSERT(result == NO_ERROR,\n \"Not enough command data for brTRANSACTION\");\n if (result != NO_ERROR) break;\n \n Parcel buffer;\n            buffer.ipcSetDataReference(\n reinterpret_cast<const uint8_t*>(tr.data.ptr.buffer),\n                tr.data_size,\n reinterpret_cast<const binder_size_t*>(tr.data.ptr.offsets),\n                tr.offsets_size/sizeof(binder_size_t), freeBuffer, this);\n \n const pid_t origPid = mCallingPid;\n const uid_t origUid = mCallingUid;\n const int32_t origStrictModePolicy = mStrictModePolicy;\n const int32_t origTransactionBinderFlags = mLastTransactionBinderFlags;\n\n            mCallingPid = tr.sender_pid;\n            mCallingUid = tr.sender_euid;\n            mLastTransactionBinderFlags = tr.flags;\n\n int curPrio = getpriority(PRIO_PROCESS, mMyThreadId);\n if (gDisableBackgroundScheduling) {\n if (curPrio > ANDROID_PRIORITY_NORMAL) {\n                    setpriority(PRIO_PROCESS, mMyThreadId, ANDROID_PRIORITY_NORMAL);\n }\n } else {\n if (curPrio >= ANDROID_PRIORITY_BACKGROUND) {\n                    set_sched_policy(mMyThreadId, SP_BACKGROUND);\n }\n }\n\n\n Parcel reply;\n status_t error;\n            IF_LOG_TRANSACTIONS() {\n TextOutput::Bundle _b(alog);\n                alog << \"BR_TRANSACTION thr \" << (void*)pthread_self()\n << \" / obj \" << tr.target.ptr << \" / code \"\n << TypeCode(tr.code) << \": \" << indent << buffer\n << dedent << endl\n << \"Data addr = \"\n << reinterpret_cast<const uint8_t*>(tr.data.ptr.buffer)\n << \", offsets addr=\"\n\n                     << reinterpret_cast<const size_t*>(tr.data.ptr.offsets) << endl;\n             }\n             if (tr.target.ptr) {\n                sp<BBinder> b((BBinder*)tr.cookie);\n                error = b->transact(tr.code, buffer, &reply, tr.flags);\n \n             } else {\n                 error = the_context_object->transact(tr.code, buffer, &reply, tr.flags);\n }\n\n \n if ((tr.flags & TF_ONE_WAY) == 0) {\n                LOG_ONEWAY(\"Sending reply to %d!\", mCallingPid);\n if (error < NO_ERROR) reply.setError(error);\n                sendReply(reply, 0);\n } else {\n                LOG_ONEWAY(\"NOT sending reply to %d!\", mCallingPid);\n }\n \n            mCallingPid = origPid;\n            mCallingUid = origUid;\n            mStrictModePolicy = origStrictModePolicy;\n            mLastTransactionBinderFlags = origTransactionBinderFlags;\n\n            IF_LOG_TRANSACTIONS() {\n TextOutput::Bundle _b(alog);\n                alog << \"BC_REPLY thr \" << (void*)pthread_self() << \" / obj \"\n << tr.target.ptr << \": \" << indent << reply << dedent << endl;\n }\n \n }\n break;\n \n case BR_DEAD_BINDER:\n {\n BpBinder *proxy = (BpBinder*)mIn.readPointer();\n            proxy->sendObituary();\n            mOut.writeInt32(BC_DEAD_BINDER_DONE);\n            mOut.writePointer((uintptr_t)proxy);\n } break;\n \n case BR_CLEAR_DEATH_NOTIFICATION_DONE:\n {\n BpBinder *proxy = (BpBinder*)mIn.readPointer();\n            proxy->getWeakRefs()->decWeak(proxy);\n } break;\n \n case BR_FINISHED:\n        result = TIMED_OUT;\n break;\n \n case BR_NOOP:\n break;\n \n case BR_SPAWN_LOOPER:\n        mProcess->spawnPooledThread(false);\n break;\n \n default:\n        printf(\"*** BAD COMMAND %d received from Binder driver\\n\", cmd);\n        result = UNKNOWN_ERROR;\n break;\n }\n\n if (result != NO_ERROR) {\n        mLastError = result;\n }\n \n return result;\n}\n",
    "code_after_change": "status_t IPCThreadState::executeCommand(int32_t cmd)\n{\n BBinder* obj;\n RefBase::weakref_type* refs;\n status_t result = NO_ERROR;\n \n switch ((uint32_t)cmd) {\n case BR_ERROR:\n        result = mIn.readInt32();\n break;\n \n case BR_OK:\n break;\n \n case BR_ACQUIRE:\n        refs = (RefBase::weakref_type*)mIn.readPointer();\n        obj = (BBinder*)mIn.readPointer();\n        ALOG_ASSERT(refs->refBase() == obj,\n \"BR_ACQUIRE: object %p does not match cookie %p (expected %p)\",\n                   refs, obj, refs->refBase());\n        obj->incStrong(mProcess.get());\n        IF_LOG_REMOTEREFS() {\n            LOG_REMOTEREFS(\"BR_ACQUIRE from driver on %p\", obj);\n            obj->printRefs();\n }\n        mOut.writeInt32(BC_ACQUIRE_DONE);\n        mOut.writePointer((uintptr_t)refs);\n        mOut.writePointer((uintptr_t)obj);\n break;\n \n case BR_RELEASE:\n        refs = (RefBase::weakref_type*)mIn.readPointer();\n        obj = (BBinder*)mIn.readPointer();\n        ALOG_ASSERT(refs->refBase() == obj,\n \"BR_RELEASE: object %p does not match cookie %p (expected %p)\",\n                   refs, obj, refs->refBase());\n        IF_LOG_REMOTEREFS() {\n            LOG_REMOTEREFS(\"BR_RELEASE from driver on %p\", obj);\n            obj->printRefs();\n }\n        mPendingStrongDerefs.push(obj);\n break;\n \n case BR_INCREFS:\n        refs = (RefBase::weakref_type*)mIn.readPointer();\n        obj = (BBinder*)mIn.readPointer();\n        refs->incWeak(mProcess.get());\n        mOut.writeInt32(BC_INCREFS_DONE);\n        mOut.writePointer((uintptr_t)refs);\n        mOut.writePointer((uintptr_t)obj);\n break;\n \n case BR_DECREFS:\n        refs = (RefBase::weakref_type*)mIn.readPointer();\n        obj = (BBinder*)mIn.readPointer();\n        mPendingWeakDerefs.push(refs);\n break;\n \n case BR_ATTEMPT_ACQUIRE:\n        refs = (RefBase::weakref_type*)mIn.readPointer();\n        obj = (BBinder*)mIn.readPointer();\n \n {\n const bool success = refs->attemptIncStrong(mProcess.get());\n            ALOG_ASSERT(success && refs->refBase() == obj,\n \"BR_ATTEMPT_ACQUIRE: object %p does not match cookie %p (expected %p)\",\n                       refs, obj, refs->refBase());\n \n            mOut.writeInt32(BC_ACQUIRE_RESULT);\n            mOut.writeInt32((int32_t)success);\n }\n break;\n \n case BR_TRANSACTION:\n {\n            binder_transaction_data tr;\n            result = mIn.read(&tr, sizeof(tr));\n            ALOG_ASSERT(result == NO_ERROR,\n \"Not enough command data for brTRANSACTION\");\n if (result != NO_ERROR) break;\n \n Parcel buffer;\n            buffer.ipcSetDataReference(\n reinterpret_cast<const uint8_t*>(tr.data.ptr.buffer),\n                tr.data_size,\n reinterpret_cast<const binder_size_t*>(tr.data.ptr.offsets),\n                tr.offsets_size/sizeof(binder_size_t), freeBuffer, this);\n \n const pid_t origPid = mCallingPid;\n const uid_t origUid = mCallingUid;\n const int32_t origStrictModePolicy = mStrictModePolicy;\n const int32_t origTransactionBinderFlags = mLastTransactionBinderFlags;\n\n            mCallingPid = tr.sender_pid;\n            mCallingUid = tr.sender_euid;\n            mLastTransactionBinderFlags = tr.flags;\n\n int curPrio = getpriority(PRIO_PROCESS, mMyThreadId);\n if (gDisableBackgroundScheduling) {\n if (curPrio > ANDROID_PRIORITY_NORMAL) {\n                    setpriority(PRIO_PROCESS, mMyThreadId, ANDROID_PRIORITY_NORMAL);\n }\n } else {\n if (curPrio >= ANDROID_PRIORITY_BACKGROUND) {\n                    set_sched_policy(mMyThreadId, SP_BACKGROUND);\n }\n }\n\n\n Parcel reply;\n status_t error;\n            IF_LOG_TRANSACTIONS() {\n TextOutput::Bundle _b(alog);\n                alog << \"BR_TRANSACTION thr \" << (void*)pthread_self()\n << \" / obj \" << tr.target.ptr << \" / code \"\n << TypeCode(tr.code) << \": \" << indent << buffer\n << dedent << endl\n << \"Data addr = \"\n << reinterpret_cast<const uint8_t*>(tr.data.ptr.buffer)\n << \", offsets addr=\"\n\n                     << reinterpret_cast<const size_t*>(tr.data.ptr.offsets) << endl;\n             }\n             if (tr.target.ptr) {\n                // We only have a weak reference on the target object, so we must first try to\n                // safely acquire a strong reference before doing anything else with it.\n                if (reinterpret_cast<RefBase::weakref_type*>(\n                        tr.target.ptr)->attemptIncStrong(this)) {\n                    error = reinterpret_cast<BBinder*>(tr.cookie)->transact(tr.code, buffer,\n                            &reply, tr.flags);\n                    reinterpret_cast<BBinder*>(tr.cookie)->decStrong(this);\n                } else {\n                    error = UNKNOWN_TRANSACTION;\n                }\n \n             } else {\n                 error = the_context_object->transact(tr.code, buffer, &reply, tr.flags);\n }\n\n \n if ((tr.flags & TF_ONE_WAY) == 0) {\n                LOG_ONEWAY(\"Sending reply to %d!\", mCallingPid);\n if (error < NO_ERROR) reply.setError(error);\n                sendReply(reply, 0);\n } else {\n                LOG_ONEWAY(\"NOT sending reply to %d!\", mCallingPid);\n }\n \n            mCallingPid = origPid;\n            mCallingUid = origUid;\n            mStrictModePolicy = origStrictModePolicy;\n            mLastTransactionBinderFlags = origTransactionBinderFlags;\n\n            IF_LOG_TRANSACTIONS() {\n TextOutput::Bundle _b(alog);\n                alog << \"BC_REPLY thr \" << (void*)pthread_self() << \" / obj \"\n << tr.target.ptr << \": \" << indent << reply << dedent << endl;\n }\n \n }\n break;\n \n case BR_DEAD_BINDER:\n {\n BpBinder *proxy = (BpBinder*)mIn.readPointer();\n            proxy->sendObituary();\n            mOut.writeInt32(BC_DEAD_BINDER_DONE);\n            mOut.writePointer((uintptr_t)proxy);\n } break;\n \n case BR_CLEAR_DEATH_NOTIFICATION_DONE:\n {\n BpBinder *proxy = (BpBinder*)mIn.readPointer();\n            proxy->getWeakRefs()->decWeak(proxy);\n } break;\n \n case BR_FINISHED:\n        result = TIMED_OUT;\n break;\n \n case BR_NOOP:\n break;\n \n case BR_SPAWN_LOOPER:\n        mProcess->spawnPooledThread(false);\n break;\n \n default:\n        printf(\"*** BAD COMMAND %d received from Binder driver\\n\", cmd);\n        result = UNKNOWN_ERROR;\n break;\n }\n\n if (result != NO_ERROR) {\n        mLastError = result;\n }\n \n return result;\n}\n",
    "cwe": [
      "CWE-264"
    ],
    "id": 930,
    "_valid_cwes": [
      "CWE-264"
    ]
  },
  {
    "cve_id": "CVE-2014-7815",
    "code_before_change": "static void set_pixel_format(VncState *vs,\n                             int bits_per_pixel, int depth,\n                             int big_endian_flag, int true_color_flag,\n                             int red_max, int green_max, int blue_max,\n                             int red_shift, int green_shift, int blue_shift)\n{\n    if (!true_color_flag) {\n        vnc_client_error(vs);\n         return;\n     }\n \n     vs->client_pf.rmax = red_max;\n     vs->client_pf.rbits = hweight_long(red_max);\n     vs->client_pf.rshift = red_shift;\n    vs->client_pf.bytes_per_pixel = bits_per_pixel / 8;\n    vs->client_pf.depth = bits_per_pixel == 32 ? 24 : bits_per_pixel;\n    vs->client_be = big_endian_flag;\n\n    set_pixel_conversion(vs);\n\n    graphic_hw_invalidate(NULL);\n    graphic_hw_update(NULL);\n}\n",
    "code_after_change": "static void set_pixel_format(VncState *vs,\n                             int bits_per_pixel, int depth,\n                             int big_endian_flag, int true_color_flag,\n                             int red_max, int green_max, int blue_max,\n                             int red_shift, int green_shift, int blue_shift)\n{\n    if (!true_color_flag) {\n        vnc_client_error(vs);\n         return;\n     }\n \n    switch (bits_per_pixel) {\n    case 8:\n    case 16:\n    case 32:\n        break;\n    default:\n        vnc_client_error(vs);\n        return;\n    }\n\n     vs->client_pf.rmax = red_max;\n     vs->client_pf.rbits = hweight_long(red_max);\n     vs->client_pf.rshift = red_shift;\n    vs->client_pf.bytes_per_pixel = bits_per_pixel / 8;\n    vs->client_pf.depth = bits_per_pixel == 32 ? 24 : bits_per_pixel;\n    vs->client_be = big_endian_flag;\n\n    set_pixel_conversion(vs);\n\n    graphic_hw_invalidate(NULL);\n    graphic_hw_update(NULL);\n}\n",
    "cwe": [
      "CWE-264"
    ],
    "id": 933,
    "_valid_cwes": [
      "CWE-264"
    ]
  },
  {
    "cve_id": "CVE-2011-4112",
    "code_before_change": "static void ifb_setup(struct net_device *dev)\n{\n\t/* Initialize the device structure. */\n\tdev->destructor = free_netdev;\n\tdev->netdev_ops = &ifb_netdev_ops;\n\n\t/* Fill in device structure with ethernet-generic values. */\n\tether_setup(dev);\n\tdev->tx_queue_len = TX_Q_LIMIT;\n\n\tdev->features |= IFB_FEATURES;\n\tdev->vlan_features |= IFB_FEATURES;\n \n \tdev->flags |= IFF_NOARP;\n \tdev->flags &= ~IFF_MULTICAST;\n\tdev->priv_flags &= ~IFF_XMIT_DST_RELEASE;\n \trandom_ether_addr(dev->dev_addr);\n }\n",
    "code_after_change": "static void ifb_setup(struct net_device *dev)\n{\n\t/* Initialize the device structure. */\n\tdev->destructor = free_netdev;\n\tdev->netdev_ops = &ifb_netdev_ops;\n\n\t/* Fill in device structure with ethernet-generic values. */\n\tether_setup(dev);\n\tdev->tx_queue_len = TX_Q_LIMIT;\n\n\tdev->features |= IFB_FEATURES;\n\tdev->vlan_features |= IFB_FEATURES;\n \n \tdev->flags |= IFF_NOARP;\n \tdev->flags &= ~IFF_MULTICAST;\n\tdev->priv_flags &= ~(IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING);\n \trandom_ether_addr(dev->dev_addr);\n }\n",
    "cwe": [
      "CWE-264"
    ],
    "id": 934,
    "_valid_cwes": [
      "CWE-264"
    ]
  },
  {
    "cve_id": "CVE-2016-3909",
    "code_before_change": "void SoftMPEG4::onQueueFilled(OMX_U32 /* portIndex */) {\n if (mSignalledError || mOutputPortSettingsChange != NONE) {\n return;\n }\n\n List<BufferInfo *> &inQueue = getPortQueue(0);\n List<BufferInfo *> &outQueue = getPortQueue(1);\n\n while (!inQueue.empty() && outQueue.size() == kNumOutputBuffers) {\n BufferInfo *inInfo = *inQueue.begin();\n        OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;\n if (inHeader == NULL) {\n            inQueue.erase(inQueue.begin());\n            inInfo->mOwnedByUs = false;\n continue;\n }\n\n PortInfo *port = editPortInfo(1);\n\n        OMX_BUFFERHEADERTYPE *outHeader =\n            port->mBuffers.editItemAt(mNumSamplesOutput & 1).mHeader;\n\n if (inHeader->nFilledLen == 0) {\n            inQueue.erase(inQueue.begin());\n            inInfo->mOwnedByUs = false;\n            notifyEmptyBufferDone(inHeader);\n\n ++mInputBufferCount;\n\n if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {\n                outHeader->nFilledLen = 0;\n                outHeader->nFlags = OMX_BUFFERFLAG_EOS;\n\n List<BufferInfo *>::iterator it = outQueue.begin();\n while ((*it)->mHeader != outHeader) {\n ++it;\n }\n\n BufferInfo *outInfo = *it;\n                outInfo->mOwnedByUs = false;\n                outQueue.erase(it);\n                outInfo = NULL;\n\n                notifyFillBufferDone(outHeader);\n                outHeader = NULL;\n }\n return;\n }\n\n uint8_t *bitstream = inHeader->pBuffer + inHeader->nOffset;\n uint32_t *start_code = (uint32_t *)bitstream;\n bool volHeader = *start_code == 0xB0010000;\n if (volHeader) {\n PVCleanUpVideoDecoder(mHandle);\n            mInitialized = false;\n }\n\n if (!mInitialized) {\n uint8_t *vol_data[1];\n int32_t vol_size = 0;\n\n            vol_data[0] = NULL;\n\n if ((inHeader->nFlags & OMX_BUFFERFLAG_CODECCONFIG) || volHeader) {\n                vol_data[0] = bitstream;\n                vol_size = inHeader->nFilledLen;\n }\n\n            MP4DecodingMode mode =\n (mMode == MODE_MPEG4) ? MPEG4_MODE : H263_MODE;\n\n Bool success = PVInitVideoDecoder(\n                    mHandle, vol_data, &vol_size, 1,\n                    outputBufferWidth(), outputBufferHeight(), mode);\n\n if (!success) {\n                ALOGW(\"PVInitVideoDecoder failed. Unsupported content?\");\n\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n                mSignalledError = true;\n return;\n }\n\n            MP4DecodingMode actualMode = PVGetDecBitstreamMode(mHandle);\n if (mode != actualMode) {\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n                mSignalledError = true;\n return;\n }\n\n PVSetPostProcType((VideoDecControls *) mHandle, 0);\n\n bool hasFrameData = false;\n if (inHeader->nFlags & OMX_BUFFERFLAG_CODECCONFIG) {\n                inInfo->mOwnedByUs = false;\n                inQueue.erase(inQueue.begin());\n                inInfo = NULL;\n                notifyEmptyBufferDone(inHeader);\n                inHeader = NULL;\n } else if (volHeader) {\n                hasFrameData = true;\n }\n\n            mInitialized = true;\n\n if (mode == MPEG4_MODE && handlePortSettingsChange()) {\n return;\n }\n\n if (!hasFrameData) {\n continue;\n }\n }\n\n if (!mFramesConfigured) {\n\n             PortInfo *port = editPortInfo(1);\n             OMX_BUFFERHEADERTYPE *outHeader = port->mBuffers.editItemAt(1).mHeader;\n \n             PVSetReferenceYUV(mHandle, outHeader->pBuffer);\n             mFramesConfigured = true;\n         }\n \n uint32_t useExtTimestamp = (inHeader->nOffset == 0);\n\n uint32_t timestamp = 0xFFFFFFFF;\n if (useExtTimestamp) {\n            mPvToOmxTimeMap.add(mPvTime, inHeader->nTimeStamp);\n            timestamp = mPvTime;\n            mPvTime++;\n }\n\n\n         int32_t bufferSize = inHeader->nFilledLen;\n         int32_t tmp = bufferSize;\n \n        OMX_U32 frameSize = (mWidth * mHeight * 3) / 2;\n         if (outHeader->nAllocLen < frameSize) {\n             android_errorWriteLog(0x534e4554, \"27833616\");\n             ALOGE(\"Insufficient output buffer size\");\n            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n            mSignalledError = true;\n return;\n }\n if (PVDecodeVideoFrame(\n                    mHandle, &bitstream, &timestamp, &tmp,\n &useExtTimestamp,\n                    outHeader->pBuffer) != PV_TRUE) {\n            ALOGE(\"failed to decode video frame.\");\n\n            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n            mSignalledError = true;\n return;\n }\n\n if (handlePortSettingsChange()) {\n return;\n }\n\n        outHeader->nTimeStamp = mPvToOmxTimeMap.valueFor(timestamp);\n        mPvToOmxTimeMap.removeItem(timestamp);\n\n        inHeader->nOffset += bufferSize;\n        inHeader->nFilledLen = 0;\n if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {\n            outHeader->nFlags = OMX_BUFFERFLAG_EOS;\n } else {\n            outHeader->nFlags = 0;\n }\n\n if (inHeader->nFilledLen == 0) {\n            inInfo->mOwnedByUs = false;\n            inQueue.erase(inQueue.begin());\n            inInfo = NULL;\n            notifyEmptyBufferDone(inHeader);\n            inHeader = NULL;\n }\n\n ++mInputBufferCount;\n\n        outHeader->nOffset = 0;\n        outHeader->nFilledLen = frameSize;\n\n List<BufferInfo *>::iterator it = outQueue.begin();\n while ((*it)->mHeader != outHeader) {\n ++it;\n }\n\n BufferInfo *outInfo = *it;\n        outInfo->mOwnedByUs = false;\n        outQueue.erase(it);\n        outInfo = NULL;\n\n        notifyFillBufferDone(outHeader);\n        outHeader = NULL;\n\n ++mNumSamplesOutput;\n }\n}\n",
    "code_after_change": "void SoftMPEG4::onQueueFilled(OMX_U32 /* portIndex */) {\n if (mSignalledError || mOutputPortSettingsChange != NONE) {\n return;\n }\n\n List<BufferInfo *> &inQueue = getPortQueue(0);\n List<BufferInfo *> &outQueue = getPortQueue(1);\n\n while (!inQueue.empty() && outQueue.size() == kNumOutputBuffers) {\n BufferInfo *inInfo = *inQueue.begin();\n        OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;\n if (inHeader == NULL) {\n            inQueue.erase(inQueue.begin());\n            inInfo->mOwnedByUs = false;\n continue;\n }\n\n PortInfo *port = editPortInfo(1);\n\n        OMX_BUFFERHEADERTYPE *outHeader =\n            port->mBuffers.editItemAt(mNumSamplesOutput & 1).mHeader;\n\n if (inHeader->nFilledLen == 0) {\n            inQueue.erase(inQueue.begin());\n            inInfo->mOwnedByUs = false;\n            notifyEmptyBufferDone(inHeader);\n\n ++mInputBufferCount;\n\n if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {\n                outHeader->nFilledLen = 0;\n                outHeader->nFlags = OMX_BUFFERFLAG_EOS;\n\n List<BufferInfo *>::iterator it = outQueue.begin();\n while ((*it)->mHeader != outHeader) {\n ++it;\n }\n\n BufferInfo *outInfo = *it;\n                outInfo->mOwnedByUs = false;\n                outQueue.erase(it);\n                outInfo = NULL;\n\n                notifyFillBufferDone(outHeader);\n                outHeader = NULL;\n }\n return;\n }\n\n uint8_t *bitstream = inHeader->pBuffer + inHeader->nOffset;\n uint32_t *start_code = (uint32_t *)bitstream;\n bool volHeader = *start_code == 0xB0010000;\n if (volHeader) {\n PVCleanUpVideoDecoder(mHandle);\n            mInitialized = false;\n }\n\n if (!mInitialized) {\n uint8_t *vol_data[1];\n int32_t vol_size = 0;\n\n            vol_data[0] = NULL;\n\n if ((inHeader->nFlags & OMX_BUFFERFLAG_CODECCONFIG) || volHeader) {\n                vol_data[0] = bitstream;\n                vol_size = inHeader->nFilledLen;\n }\n\n            MP4DecodingMode mode =\n (mMode == MODE_MPEG4) ? MPEG4_MODE : H263_MODE;\n\n Bool success = PVInitVideoDecoder(\n                    mHandle, vol_data, &vol_size, 1,\n                    outputBufferWidth(), outputBufferHeight(), mode);\n\n if (!success) {\n                ALOGW(\"PVInitVideoDecoder failed. Unsupported content?\");\n\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n                mSignalledError = true;\n return;\n }\n\n            MP4DecodingMode actualMode = PVGetDecBitstreamMode(mHandle);\n if (mode != actualMode) {\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n                mSignalledError = true;\n return;\n }\n\n PVSetPostProcType((VideoDecControls *) mHandle, 0);\n\n bool hasFrameData = false;\n if (inHeader->nFlags & OMX_BUFFERFLAG_CODECCONFIG) {\n                inInfo->mOwnedByUs = false;\n                inQueue.erase(inQueue.begin());\n                inInfo = NULL;\n                notifyEmptyBufferDone(inHeader);\n                inHeader = NULL;\n } else if (volHeader) {\n                hasFrameData = true;\n }\n\n            mInitialized = true;\n\n if (mode == MPEG4_MODE && handlePortSettingsChange()) {\n return;\n }\n\n if (!hasFrameData) {\n continue;\n }\n }\n\n if (!mFramesConfigured) {\n\n             PortInfo *port = editPortInfo(1);\n             OMX_BUFFERHEADERTYPE *outHeader = port->mBuffers.editItemAt(1).mHeader;\n \n            OMX_U32 yFrameSize = sizeof(uint8) * mHandle->size;\n            if ((outHeader->nAllocLen < yFrameSize) ||\n                    (outHeader->nAllocLen - yFrameSize < yFrameSize / 2)) {\n                ALOGE(\"Too small output buffer for reference frame: %zu bytes\",\n                        outHeader->nAllocLen);\n                android_errorWriteLog(0x534e4554, \"30033990\");\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n                mSignalledError = true;\n                return;\n            }\n             PVSetReferenceYUV(mHandle, outHeader->pBuffer);\n             mFramesConfigured = true;\n         }\n \n uint32_t useExtTimestamp = (inHeader->nOffset == 0);\n\n uint32_t timestamp = 0xFFFFFFFF;\n if (useExtTimestamp) {\n            mPvToOmxTimeMap.add(mPvTime, inHeader->nTimeStamp);\n            timestamp = mPvTime;\n            mPvTime++;\n }\n\n\n         int32_t bufferSize = inHeader->nFilledLen;\n         int32_t tmp = bufferSize;\n \n        OMX_U32 frameSize;\n        OMX_U64 yFrameSize = (OMX_U64)mWidth * (OMX_U64)mHeight;\n        if (yFrameSize > ((OMX_U64)UINT32_MAX / 3) * 2) {\n            ALOGE(\"Frame size too large\");\n            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n            mSignalledError = true;\n            return;\n        }\n        frameSize = (OMX_U32)(yFrameSize + (yFrameSize / 2));\n\n         if (outHeader->nAllocLen < frameSize) {\n             android_errorWriteLog(0x534e4554, \"27833616\");\n             ALOGE(\"Insufficient output buffer size\");\n            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n            mSignalledError = true;\n return;\n }\n if (PVDecodeVideoFrame(\n                    mHandle, &bitstream, &timestamp, &tmp,\n &useExtTimestamp,\n                    outHeader->pBuffer) != PV_TRUE) {\n            ALOGE(\"failed to decode video frame.\");\n\n            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n            mSignalledError = true;\n return;\n }\n\n if (handlePortSettingsChange()) {\n return;\n }\n\n        outHeader->nTimeStamp = mPvToOmxTimeMap.valueFor(timestamp);\n        mPvToOmxTimeMap.removeItem(timestamp);\n\n        inHeader->nOffset += bufferSize;\n        inHeader->nFilledLen = 0;\n if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {\n            outHeader->nFlags = OMX_BUFFERFLAG_EOS;\n } else {\n            outHeader->nFlags = 0;\n }\n\n if (inHeader->nFilledLen == 0) {\n            inInfo->mOwnedByUs = false;\n            inQueue.erase(inQueue.begin());\n            inInfo = NULL;\n            notifyEmptyBufferDone(inHeader);\n            inHeader = NULL;\n }\n\n ++mInputBufferCount;\n\n        outHeader->nOffset = 0;\n        outHeader->nFilledLen = frameSize;\n\n List<BufferInfo *>::iterator it = outQueue.begin();\n while ((*it)->mHeader != outHeader) {\n ++it;\n }\n\n BufferInfo *outInfo = *it;\n        outInfo->mOwnedByUs = false;\n        outQueue.erase(it);\n        outInfo = NULL;\n\n        notifyFillBufferDone(outHeader);\n        outHeader = NULL;\n\n ++mNumSamplesOutput;\n }\n}\n",
    "cwe": [
      "CWE-264"
    ],
    "id": 938,
    "_valid_cwes": [
      "CWE-264"
    ]
  },
  {
    "cve_id": "CVE-2011-2211",
    "code_before_change": "SYSCALL_DEFINE2(osf_getdomainname, char __user *, name, int, namelen)\n{\n\tunsigned len;\n\tint i;\n\n\tif (!access_ok(VERIFY_WRITE, name, namelen))\n \t\treturn -EFAULT;\n \n \tlen = namelen;\n\tif (namelen > 32)\n \t\tlen = 32;\n \n \tdown_read(&uts_sem);\n\tfor (i = 0; i < len; ++i) {\n\t\t__put_user(utsname()->domainname[i], name + i);\n\t\tif (utsname()->domainname[i] == '\\0')\n\t\t\tbreak;\n\t}\n\tup_read(&uts_sem);\n\n\treturn 0;\n}\n",
    "code_after_change": "SYSCALL_DEFINE2(osf_getdomainname, char __user *, name, int, namelen)\n{\n\tunsigned len;\n\tint i;\n\n\tif (!access_ok(VERIFY_WRITE, name, namelen))\n \t\treturn -EFAULT;\n \n \tlen = namelen;\n\tif (len > 32)\n \t\tlen = 32;\n \n \tdown_read(&uts_sem);\n\tfor (i = 0; i < len; ++i) {\n\t\t__put_user(utsname()->domainname[i], name + i);\n\t\tif (utsname()->domainname[i] == '\\0')\n\t\t\tbreak;\n\t}\n\tup_read(&uts_sem);\n\n\treturn 0;\n}\n",
    "cwe": [
      "CWE-264"
    ],
    "id": 943,
    "_valid_cwes": [
      "CWE-264"
    ]
  },
  {
    "cve_id": "CVE-2010-1172",
    "code_before_change": "my_object_increment (MyObject *obj, gint32 x, gint32 *ret, GError **error)\n{\n  *ret = x +1;\n  return TRUE;\n}\n",
    "code_after_change": "my_object_increment (MyObject *obj, gint32 x, gint32 *ret, GError **error)\n",
    "cwe": [
      "CWE-264"
    ],
    "id": 983,
    "_valid_cwes": [
      "CWE-264"
    ]
  },
  {
    "cve_id": "CVE-2010-1172",
    "code_before_change": "my_object_unstringify (MyObject *obj, const char *str, GValue *value, GError **error)\n{\n  if (str[0] == '\\0' || !g_ascii_isdigit (str[0])) {\n    g_value_init (value, G_TYPE_STRING);\n    g_value_set_string (value, str);\n  } else {\n    g_value_init (value, G_TYPE_INT);\n    g_value_set_int (value, (int) g_ascii_strtoull (str, NULL, 10));\n  } \n  return TRUE;\n}\n",
    "code_after_change": "my_object_unstringify (MyObject *obj, const char *str, GValue *value, GError **error)\n",
    "cwe": [
      "CWE-264"
    ],
    "id": 995,
    "_valid_cwes": [
      "CWE-264"
    ]
  },
  {
    "cve_id": "CVE-2013-0829",
    "code_before_change": "void FileAPIMessageFilter::OnCreateSnapshotFile(\n    int request_id, const GURL& blob_url, const GURL& path) {\n  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));\n   FileSystemURL url(path);\n   base::Callback<void(const FilePath&)> register_file_callback =\n       base::Bind(&FileAPIMessageFilter::RegisterFileAsBlob,\n                 this, blob_url, url.path());\n \n   FileSystemOperation* operation = GetNewOperation(url, request_id);\n   if (!operation)\n    return;\n  operation->CreateSnapshotFile(\n      url,\n      base::Bind(&FileAPIMessageFilter::DidCreateSnapshot,\n                 this, request_id, register_file_callback));\n}\n",
    "code_after_change": "void FileAPIMessageFilter::OnCreateSnapshotFile(\n    int request_id, const GURL& blob_url, const GURL& path) {\n  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));\n   FileSystemURL url(path);\n   base::Callback<void(const FilePath&)> register_file_callback =\n       base::Bind(&FileAPIMessageFilter::RegisterFileAsBlob,\n                 this, blob_url, url);\n\n  // Make sure if this file can be read by the renderer as this is\n  // called when the renderer is about to create a new File object\n  // (for reading the file).\n  base::PlatformFileError error;\n  if (!HasPermissionsForFile(url, kReadFilePermissions, &error)) {\n    Send(new FileSystemMsg_DidFail(request_id, error));\n    return;\n  }\n \n   FileSystemOperation* operation = GetNewOperation(url, request_id);\n   if (!operation)\n    return;\n  operation->CreateSnapshotFile(\n      url,\n      base::Bind(&FileAPIMessageFilter::DidCreateSnapshot,\n                 this, request_id, register_file_callback));\n}\n",
    "cwe": [
      "CWE-264"
    ],
    "id": 996,
    "_valid_cwes": [
      "CWE-264"
    ]
  }
]