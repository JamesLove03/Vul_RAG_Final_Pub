[
  {
    "cve_id": "CVE-2016-9559",
    "code_before_change": "MagickExport MagickBooleanType SetImageProperty(Image *image,\n  const char *property,const char *value,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  MagickStatusType\n    flags;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->properties == (void *) NULL)\n    image->properties=NewSplayTree(CompareSplayTreeString,\n      RelinquishMagickMemory,RelinquishMagickMemory);  /* create splay-tree */\n  if (value == (const char *) NULL)\n    return(DeleteImageProperty(image,property));  /* delete if NULL */\n  status=MagickTrue;\n  if (strlen(property) <= 1)\n     {\n       /*\n         Do not 'set' single letter properties - read only shorthand.\n       */\n       (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n         \"SetReadOnlyProperty\",\"`%s'\",property);\n       return(MagickFalse);\n    }\n\n  /* FUTURE: binary chars or quotes in key should produce a error */\n  /* Set attributes with known names or special prefixes\n     return result is found, or break to set a free form properity\n  */\n  switch (*property)\n  {\n#if 0  /* Percent escape's sets values with this prefix: for later use\n          Throwing an exception causes this setting to fail */\n    case '8':\n    {\n      if (LocaleNCompare(\"8bim:\",property,5) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break;\n    }\n#endif\n    case 'B':\n    case 'b':\n    {\n      if (LocaleCompare(\"background\",property) == 0)\n        {\n          (void) QueryColorCompliance(value,AllCompliance,\n               &image->background_color,exception);\n          /* check for FUTURE: value exception?? */\n          /* also add user input to splay tree */\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'C':\n    case 'c':\n    {\n      if (LocaleCompare(\"channels\",property) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      if (LocaleCompare(\"colorspace\",property) == 0)\n        {\n          ssize_t\n            colorspace;\n\n          colorspace=ParseCommandOption(MagickColorspaceOptions,MagickFalse,\n            value);\n          if (colorspace < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          return(SetImageColorspace(image,(ColorspaceType) colorspace,exception));\n        }\n      if (LocaleCompare(\"compose\",property) == 0)\n        {\n          ssize_t\n            compose;\n\n          compose=ParseCommandOption(MagickComposeOptions,MagickFalse,value);\n          if (compose < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->compose=(CompositeOperator) compose;\n          return(MagickTrue);\n        }\n      if (LocaleCompare(\"compress\",property) == 0)\n        {\n          ssize_t\n            compression;\n\n          compression=ParseCommandOption(MagickCompressOptions,MagickFalse,\n            value);\n          if (compression < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->compression=(CompressionType) compression;\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'D':\n    case 'd':\n    {\n      if (LocaleCompare(\"delay\",property) == 0)\n        {\n          GeometryInfo\n            geometry_info;\n\n          flags=ParseGeometry(value,&geometry_info);\n          if ((flags & GreaterValue) != 0)\n            {\n              if (image->delay > (size_t) floor(geometry_info.rho+0.5))\n                image->delay=(size_t) floor(geometry_info.rho+0.5);\n            }\n          else\n            if ((flags & LessValue) != 0)\n              {\n                if (image->delay < (size_t) floor(geometry_info.rho+0.5))\n                  image->delay=(ssize_t)\n                    floor(geometry_info.sigma+0.5);\n              }\n            else\n              image->delay=(size_t) floor(geometry_info.rho+0.5);\n          if ((flags & SigmaValue) != 0)\n            image->ticks_per_second=(ssize_t) floor(geometry_info.sigma+0.5);\n          return(MagickTrue);\n        }\n      if (LocaleCompare(\"delay_units\",property) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      if (LocaleCompare(\"density\",property) == 0)\n        {\n          GeometryInfo\n            geometry_info;\n\n          flags=ParseGeometry(value,&geometry_info);\n          image->resolution.x=geometry_info.rho;\n          image->resolution.y=geometry_info.sigma;\n          if ((flags & SigmaValue) == 0)\n            image->resolution.y=image->resolution.x;\n          return(MagickTrue);\n        }\n      if (LocaleCompare(\"depth\",property) == 0)\n        {\n          image->depth=StringToUnsignedLong(value);\n          return(MagickTrue);\n        }\n      if (LocaleCompare(\"dispose\",property) == 0)\n        {\n          ssize_t\n            dispose;\n\n          dispose=ParseCommandOption(MagickDisposeOptions,MagickFalse,value);\n          if (dispose < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->dispose=(DisposeType) dispose;\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n#if 0  /* Percent escape's sets values with this prefix: for later use\n          Throwing an exception causes this setting to fail */\n    case 'E':\n    case 'e':\n    {\n      if (LocaleNCompare(\"exif:\",property,5) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'F':\n    case 'f':\n    {\n      if (LocaleNCompare(\"fx:\",property,3) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    }\n#endif\n    case 'G':\n    case 'g':\n    {\n      if (LocaleCompare(\"gamma\",property) == 0)\n        {\n          image->gamma=StringToDouble(value,(char **) NULL);\n          return(MagickTrue);\n        }\n      if (LocaleCompare(\"gravity\",property) == 0)\n        {\n          ssize_t\n            gravity;\n\n          gravity=ParseCommandOption(MagickGravityOptions,MagickFalse,value);\n          if (gravity < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->gravity=(GravityType) gravity;\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'H':\n    case 'h':\n    {\n      if (LocaleCompare(\"height\",property) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'I':\n    case 'i':\n    {\n      if (LocaleCompare(\"intensity\",property) == 0)\n        {\n          ssize_t\n            intensity;\n\n          intensity=ParseCommandOption(MagickIntentOptions,MagickFalse,value);\n          if (intensity < 0)\n            return(MagickFalse);\n          image->intensity=(PixelIntensityMethod) intensity;\n          return(MagickTrue);\n        }\n      if (LocaleCompare(\"intent\",property) == 0)\n        {\n          ssize_t\n            rendering_intent;\n\n          rendering_intent=ParseCommandOption(MagickIntentOptions,MagickFalse,\n            value);\n          if (rendering_intent < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->rendering_intent=(RenderingIntent) rendering_intent;\n          return(MagickTrue);\n        }\n      if (LocaleCompare(\"interpolate\",property) == 0)\n        {\n          ssize_t\n            interpolate;\n\n          interpolate=ParseCommandOption(MagickInterpolateOptions,MagickFalse,\n            value);\n          if (interpolate < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->interpolate=(PixelInterpolateMethod) interpolate;\n          return(MagickTrue);\n        }\n#if 0  /* Percent escape's sets values with this prefix: for later use\n          Throwing an exception causes this setting to fail */\n      if (LocaleNCompare(\"iptc:\",property,5) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n#endif\n      break; /* not an attribute, add as a property */\n    }\n    case 'K':\n    case 'k':\n      if (LocaleCompare(\"kurtosis\",property) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    case 'L':\n    case 'l':\n    {\n      if (LocaleCompare(\"loop\",property) == 0)\n        {\n          image->iterations=StringToUnsignedLong(value);\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'M':\n    case 'm':\n      if ((LocaleCompare(\"magick\",property) == 0) ||\n          (LocaleCompare(\"max\",property) == 0) ||\n          (LocaleCompare(\"mean\",property) == 0) ||\n          (LocaleCompare(\"min\",property) == 0) ||\n          (LocaleCompare(\"min\",property) == 0))\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n             \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    case 'O':\n    case 'o':\n      if (LocaleCompare(\"opaque\",property) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    case 'P':\n    case 'p':\n    {\n      if (LocaleCompare(\"page\",property) == 0)\n        {\n          char\n            *geometry;\n\n          geometry=GetPageGeometry(value);\n          flags=ParseAbsoluteGeometry(geometry,&image->page);\n          geometry=DestroyString(geometry);\n          return(MagickTrue);\n        }\n#if 0  /* Percent escape's sets values with this prefix: for later use\n          Throwing an exception causes this setting to fail */\n      if (LocaleNCompare(\"pixel:\",property,6) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n#endif\n      if (LocaleCompare(\"profile\",property) == 0)\n        {\n          ImageInfo\n            *image_info;\n\n          StringInfo\n            *profile;\n\n          image_info=AcquireImageInfo();\n          (void) CopyMagickString(image_info->filename,value,MagickPathExtent);\n          (void) SetImageInfo(image_info,1,exception);\n          profile=FileToStringInfo(image_info->filename,~0UL,exception);\n          if (profile != (StringInfo *) NULL)\n            status=SetImageProfile(image,image_info->magick,profile,exception);\n          image_info=DestroyImageInfo(image_info);\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'R':\n    case 'r':\n    {\n      if (LocaleCompare(\"rendering-intent\",property) == 0)\n        {\n          ssize_t\n            rendering_intent;\n\n          rendering_intent=ParseCommandOption(MagickIntentOptions,MagickFalse,\n            value);\n          if (rendering_intent < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->rendering_intent=(RenderingIntent) rendering_intent;\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'S':\n    case 's':\n      if ((LocaleCompare(\"size\",property) == 0) ||\n          (LocaleCompare(\"skewness\",property) == 0) ||\n          (LocaleCompare(\"scenes\",property) == 0) ||\n          (LocaleCompare(\"standard-deviation\",property) == 0))\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    case 'T':\n    case 't':\n    {\n      if (LocaleCompare(\"tile-offset\",property) == 0)\n        {\n          char\n            *geometry;\n\n          geometry=GetPageGeometry(value);\n          flags=ParseAbsoluteGeometry(geometry,&image->tile_offset);\n          geometry=DestroyString(geometry);\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'U':\n    case 'u':\n    {\n      if (LocaleCompare(\"units\",property) == 0)\n        {\n          ssize_t\n            units;\n\n          units=ParseCommandOption(MagickResolutionOptions,MagickFalse,value);\n          if (units < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->units=(ResolutionType) units;\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'V':\n    case 'v':\n    {\n      if (LocaleCompare(\"version\",property) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'W':\n    case 'w':\n    {\n      if (LocaleCompare(\"width\",property) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    }\n#if 0  /* Percent escape's sets values with this prefix: for later use\n          Throwing an exception causes this setting to fail */\n    case 'X':\n    case 'x':\n    {\n      if (LocaleNCompare(\"xmp:\",property,4) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    }\n#endif\n  }\n  /* Default: not an attribute, add as a property */\n  status=AddValueToSplayTree((SplayTreeInfo *) image->properties,\n    ConstantString(property),ConstantString(value));\n  /* FUTURE: error if status is bad? */\n  return(status);\n}\n",
    "code_after_change": "MagickExport MagickBooleanType SetImageProperty(Image *image,\n  const char *property,const char *value,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  MagickStatusType\n    flags;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->properties == (void *) NULL)\n    image->properties=NewSplayTree(CompareSplayTreeString,\n      RelinquishMagickMemory,RelinquishMagickMemory);  /* create splay-tree */\n  if (value == (const char *) NULL)\n    return(DeleteImageProperty(image,property));  /* delete if NULL */\n  status=MagickTrue;\n  if (strlen(property) <= 1)\n     {\n       /*\n         Do not 'set' single letter properties - read only shorthand.\n      */\n       (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n         \"SetReadOnlyProperty\",\"`%s'\",property);\n       return(MagickFalse);\n    }\n\n  /* FUTURE: binary chars or quotes in key should produce a error */\n  /* Set attributes with known names or special prefixes\n     return result is found, or break to set a free form properity\n  */\n  switch (*property)\n  {\n#if 0  /* Percent escape's sets values with this prefix: for later use\n          Throwing an exception causes this setting to fail */\n    case '8':\n    {\n      if (LocaleNCompare(\"8bim:\",property,5) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break;\n    }\n#endif\n    case 'B':\n    case 'b':\n    {\n      if (LocaleCompare(\"background\",property) == 0)\n        {\n          (void) QueryColorCompliance(value,AllCompliance,\n               &image->background_color,exception);\n          /* check for FUTURE: value exception?? */\n          /* also add user input to splay tree */\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'C':\n    case 'c':\n    {\n      if (LocaleCompare(\"channels\",property) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      if (LocaleCompare(\"colorspace\",property) == 0)\n        {\n          ssize_t\n            colorspace;\n\n          colorspace=ParseCommandOption(MagickColorspaceOptions,MagickFalse,\n            value);\n          if (colorspace < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          return(SetImageColorspace(image,(ColorspaceType) colorspace,exception));\n        }\n      if (LocaleCompare(\"compose\",property) == 0)\n        {\n          ssize_t\n            compose;\n\n          compose=ParseCommandOption(MagickComposeOptions,MagickFalse,value);\n          if (compose < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->compose=(CompositeOperator) compose;\n          return(MagickTrue);\n        }\n      if (LocaleCompare(\"compress\",property) == 0)\n        {\n          ssize_t\n            compression;\n\n          compression=ParseCommandOption(MagickCompressOptions,MagickFalse,\n            value);\n          if (compression < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->compression=(CompressionType) compression;\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'D':\n    case 'd':\n    {\n      if (LocaleCompare(\"delay\",property) == 0)\n        {\n          GeometryInfo\n            geometry_info;\n\n          flags=ParseGeometry(value,&geometry_info);\n          if ((flags & GreaterValue) != 0)\n            {\n              if (image->delay > (size_t) floor(geometry_info.rho+0.5))\n                image->delay=(size_t) floor(geometry_info.rho+0.5);\n            }\n          else\n            if ((flags & LessValue) != 0)\n              {\n                if (image->delay < (size_t) floor(geometry_info.rho+0.5))\n                  image->delay=(ssize_t)\n                    floor(geometry_info.sigma+0.5);\n              }\n            else\n              image->delay=(size_t) floor(geometry_info.rho+0.5);\n          if ((flags & SigmaValue) != 0)\n            image->ticks_per_second=(ssize_t) floor(geometry_info.sigma+0.5);\n          return(MagickTrue);\n        }\n      if (LocaleCompare(\"delay_units\",property) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      if (LocaleCompare(\"density\",property) == 0)\n        {\n          GeometryInfo\n            geometry_info;\n\n          flags=ParseGeometry(value,&geometry_info);\n          image->resolution.x=geometry_info.rho;\n          image->resolution.y=geometry_info.sigma;\n          if ((flags & SigmaValue) == 0)\n            image->resolution.y=image->resolution.x;\n          return(MagickTrue);\n        }\n      if (LocaleCompare(\"depth\",property) == 0)\n        {\n          image->depth=StringToUnsignedLong(value);\n          return(MagickTrue);\n        }\n      if (LocaleCompare(\"dispose\",property) == 0)\n        {\n          ssize_t\n            dispose;\n\n          dispose=ParseCommandOption(MagickDisposeOptions,MagickFalse,value);\n          if (dispose < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->dispose=(DisposeType) dispose;\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n#if 0  /* Percent escape's sets values with this prefix: for later use\n          Throwing an exception causes this setting to fail */\n    case 'E':\n    case 'e':\n    {\n      if (LocaleNCompare(\"exif:\",property,5) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'F':\n    case 'f':\n    {\n      if (LocaleNCompare(\"fx:\",property,3) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    }\n#endif\n    case 'G':\n    case 'g':\n    {\n      if (LocaleCompare(\"gamma\",property) == 0)\n        {\n          image->gamma=StringToDouble(value,(char **) NULL);\n          return(MagickTrue);\n        }\n      if (LocaleCompare(\"gravity\",property) == 0)\n        {\n          ssize_t\n            gravity;\n\n          gravity=ParseCommandOption(MagickGravityOptions,MagickFalse,value);\n          if (gravity < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->gravity=(GravityType) gravity;\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'H':\n    case 'h':\n    {\n      if (LocaleCompare(\"height\",property) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'I':\n    case 'i':\n    {\n      if (LocaleCompare(\"intensity\",property) == 0)\n        {\n          ssize_t\n            intensity;\n\n          intensity=ParseCommandOption(MagickIntentOptions,MagickFalse,value);\n          if (intensity < 0)\n            return(MagickFalse);\n          image->intensity=(PixelIntensityMethod) intensity;\n          return(MagickTrue);\n        }\n      if (LocaleCompare(\"intent\",property) == 0)\n        {\n          ssize_t\n            rendering_intent;\n\n          rendering_intent=ParseCommandOption(MagickIntentOptions,MagickFalse,\n            value);\n          if (rendering_intent < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->rendering_intent=(RenderingIntent) rendering_intent;\n          return(MagickTrue);\n        }\n      if (LocaleCompare(\"interpolate\",property) == 0)\n        {\n          ssize_t\n            interpolate;\n\n          interpolate=ParseCommandOption(MagickInterpolateOptions,MagickFalse,\n            value);\n          if (interpolate < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->interpolate=(PixelInterpolateMethod) interpolate;\n          return(MagickTrue);\n        }\n#if 0  /* Percent escape's sets values with this prefix: for later use\n          Throwing an exception causes this setting to fail */\n      if (LocaleNCompare(\"iptc:\",property,5) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n#endif\n      break; /* not an attribute, add as a property */\n    }\n    case 'K':\n    case 'k':\n      if (LocaleCompare(\"kurtosis\",property) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    case 'L':\n    case 'l':\n    {\n      if (LocaleCompare(\"loop\",property) == 0)\n        {\n          image->iterations=StringToUnsignedLong(value);\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'M':\n    case 'm':\n      if ((LocaleCompare(\"magick\",property) == 0) ||\n          (LocaleCompare(\"max\",property) == 0) ||\n          (LocaleCompare(\"mean\",property) == 0) ||\n          (LocaleCompare(\"min\",property) == 0) ||\n          (LocaleCompare(\"min\",property) == 0))\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n             \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    case 'O':\n    case 'o':\n      if (LocaleCompare(\"opaque\",property) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    case 'P':\n    case 'p':\n    {\n      if (LocaleCompare(\"page\",property) == 0)\n        {\n          char\n            *geometry;\n\n          geometry=GetPageGeometry(value);\n          flags=ParseAbsoluteGeometry(geometry,&image->page);\n          geometry=DestroyString(geometry);\n          return(MagickTrue);\n        }\n#if 0  /* Percent escape's sets values with this prefix: for later use\n          Throwing an exception causes this setting to fail */\n      if (LocaleNCompare(\"pixel:\",property,6) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n#endif\n      if (LocaleCompare(\"profile\",property) == 0)\n        {\n          ImageInfo\n            *image_info;\n\n          StringInfo\n            *profile;\n\n          image_info=AcquireImageInfo();\n          (void) CopyMagickString(image_info->filename,value,MagickPathExtent);\n          (void) SetImageInfo(image_info,1,exception);\n          profile=FileToStringInfo(image_info->filename,~0UL,exception);\n          if (profile != (StringInfo *) NULL)\n            status=SetImageProfile(image,image_info->magick,profile,exception);\n          image_info=DestroyImageInfo(image_info);\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'R':\n    case 'r':\n    {\n      if (LocaleCompare(\"rendering-intent\",property) == 0)\n        {\n          ssize_t\n            rendering_intent;\n\n          rendering_intent=ParseCommandOption(MagickIntentOptions,MagickFalse,\n            value);\n          if (rendering_intent < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->rendering_intent=(RenderingIntent) rendering_intent;\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'S':\n    case 's':\n      if ((LocaleCompare(\"size\",property) == 0) ||\n          (LocaleCompare(\"skewness\",property) == 0) ||\n          (LocaleCompare(\"scenes\",property) == 0) ||\n          (LocaleCompare(\"standard-deviation\",property) == 0))\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    case 'T':\n    case 't':\n    {\n      if (LocaleCompare(\"tile-offset\",property) == 0)\n        {\n          char\n            *geometry;\n\n          geometry=GetPageGeometry(value);\n          flags=ParseAbsoluteGeometry(geometry,&image->tile_offset);\n          geometry=DestroyString(geometry);\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'U':\n    case 'u':\n    {\n      if (LocaleCompare(\"units\",property) == 0)\n        {\n          ssize_t\n            units;\n\n          units=ParseCommandOption(MagickResolutionOptions,MagickFalse,value);\n          if (units < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->units=(ResolutionType) units;\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'V':\n    case 'v':\n    {\n      if (LocaleCompare(\"version\",property) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'W':\n    case 'w':\n    {\n      if (LocaleCompare(\"width\",property) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    }\n#if 0  /* Percent escape's sets values with this prefix: for later use\n          Throwing an exception causes this setting to fail */\n    case 'X':\n    case 'x':\n    {\n      if (LocaleNCompare(\"xmp:\",property,4) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    }\n#endif\n  }\n  /* Default: not an attribute, add as a property */\n  status=AddValueToSplayTree((SplayTreeInfo *) image->properties,\n    ConstantString(property),ConstantString(value));\n  /* FUTURE: error if status is bad? */\n  return(status);\n}\n",
    "cwe": [
      "CWE-476"
    ],
    "id": 29,
    "_valid_cwes": [
      "CWE-476"
    ]
  },
  {
    "cve_id": "CVE-2016-10210",
    "code_before_change": " int re_yyget_lineno  (yyscan_t yyscanner)\n {\n     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n         if (! YY_CURRENT_BUFFER)\n             return 0;\n     \n    return yylineno;\n}\n",
    "code_after_change": " int re_yyget_lineno  (yyscan_t yyscanner)\n {\n     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\n         if (! YY_CURRENT_BUFFER)\n             return 0;\n     \n    return yylineno;\n}\n",
    "cwe": [
      "CWE-476"
    ],
    "id": 85,
    "_valid_cwes": [
      "CWE-476"
    ]
  },
  {
    "cve_id": "CVE-2019-12110",
    "code_before_change": "upnp_redirect(const char * rhost, unsigned short eport,\n              const char * iaddr, unsigned short iport,\n              const char * protocol, const char * desc,\n              unsigned int leaseduration)\n{\n\tint proto, r;\n\tchar iaddr_old[32];\n\tchar rhost_old[32];\n\tunsigned short iport_old;\n\tstruct in_addr address;\n\tunsigned int timestamp;\n\n\tproto = proto_atoi(protocol);\n\tif(inet_aton(iaddr, &address) <= 0) {\n\t\tsyslog(LOG_ERR, \"inet_aton(%s) FAILED\", iaddr);\n\t\treturn -1;\n\t}\n\n\tif(!check_upnp_rule_against_permissions(upnppermlist, num_upnpperm,\n\t                                        eport, address, iport)) {\n\t\tsyslog(LOG_INFO, \"redirection permission check failed for \"\n \t\t                 \"%hu->%s:%hu %s\", eport, iaddr, iport, protocol);\n \t\treturn -3;\n \t}\n \t/* IGDv1 (WANIPConnection:1 Service Template Version 1.01 / Nov 12, 2001)\n \t * - 2.2.20.PortMappingDescription :\n \t *  Overwriting Previous / Existing Port Mappings:\n\t * If the RemoteHost, ExternalPort, PortMappingProtocol and InternalClient\n\t * are exactly the same as an existing mapping, the existing mapping values\n\t * for InternalPort, PortMappingDescription, PortMappingEnabled and\n\t * PortMappingLeaseDuration are overwritten.\n\t *  Rejecting a New Port Mapping:\n\t * In cases where the RemoteHost, ExternalPort and PortMappingProtocol\n\t * are the same as an existing mapping, but the InternalClient is\n\t * different, the action is rejected with an appropriate error.\n\t *  Add or Reject New Port Mapping behavior based on vendor implementation:\n\t * In cases where the ExternalPort, PortMappingProtocol and InternalClient\n\t * are the same, but RemoteHost is different, the vendor can choose to\n\t * support both mappings simultaneously, or reject the second mapping\n\t * with an appropriate error.\n\t *\n\t * - 2.4.16.AddPortMapping\n\t * This action creates a new port mapping or overwrites an existing\n\t * mapping with the same internal client. If the ExternalPort and\n\t * PortMappingProtocol pair is already mapped to another internal client,\n\t * an error is returned.\n\t *\n\t * IGDv2 (WANIPConnection:2 Service Standardized DCP (SDCP) Sep 10, 2010)\n\t * Protocol ExternalPort RemoteHost InternalClient Result\n\t *     =         =           \u2260           \u2260         Failure\n\t *     =         =           \u2260           =         Failure or success\n\t *                                                 (vendor specific)\n\t *     =         =           =           \u2260         Failure\n\t *     =         =           =           =         Success (overwrite)\n\t */\n\trhost_old[0] = '\\0';\n\tr = get_redirect_rule(ext_if_name, eport, proto,\n\t                      iaddr_old, sizeof(iaddr_old), &iport_old, 0, 0,\n\t                      rhost_old, sizeof(rhost_old),\n\t                      &timestamp, 0, 0);\n\tif(r == 0) {\n\t\tif(strcmp(iaddr, iaddr_old)==0 &&\n\t\t   ((rhost == NULL && rhost_old[0]=='\\0') ||\n\t\t    (rhost && (strcmp(rhost, \"*\") == 0) && rhost_old[0]=='\\0') ||\n\t\t    (rhost && (strcmp(rhost, rhost_old) == 0)))) {\n\t\t\tsyslog(LOG_INFO, \"updating existing port mapping %hu %s (rhost '%s') => %s:%hu\",\n\t\t\t\teport, protocol, rhost_old, iaddr_old, iport_old);\n\t\t\ttimestamp = (leaseduration > 0) ? upnp_time() + leaseduration : 0;\n\t\t\tif(iport != iport_old) {\n\t\t\t\tr = update_portmapping(ext_if_name, eport, proto, iport, desc, timestamp);\n\t\t\t} else {\n\t\t\t\tr = update_portmapping_desc_timestamp(ext_if_name, eport, proto, desc, timestamp);\n\t\t\t}\n#ifdef ENABLE_LEASEFILE\n\t\t\tif(r == 0) {\n\t\t\t\tlease_file_remove(eport, proto);\n\t\t\t\tlease_file_add(eport, iaddr, iport, proto, desc, timestamp);\n\t\t\t}\n#endif /* ENABLE_LEASEFILE */\n\t\t\treturn r;\n\t\t} else {\n\t\t\tsyslog(LOG_INFO, \"port %hu %s (rhost '%s') already redirected to %s:%hu\",\n\t\t\t\teport, protocol, rhost_old, iaddr_old, iport_old);\n\t\t\treturn -2;\n\t\t}\n#ifdef CHECK_PORTINUSE\n\t} else if (port_in_use(ext_if_name, eport, proto, iaddr, iport) > 0) {\n\t\tsyslog(LOG_INFO, \"port %hu protocol %s already in use\",\n\t\t       eport, protocol);\n\t\treturn -4;\n#endif /* CHECK_PORTINUSE */\n\t} else {\n\t\ttimestamp = (leaseduration > 0) ? upnp_time() + leaseduration : 0;\n\t\tsyslog(LOG_INFO, \"redirecting port %hu to %s:%hu protocol %s for: %s\",\n\t\t\teport, iaddr, iport, protocol, desc);\n\t\treturn upnp_redirect_internal(rhost, eport, iaddr, iport, proto,\n\t\t                              desc, timestamp);\n\t}\n}\n",
    "code_after_change": "upnp_redirect(const char * rhost, unsigned short eport,\n              const char * iaddr, unsigned short iport,\n              const char * protocol, const char * desc,\n              unsigned int leaseduration)\n{\n\tint proto, r;\n\tchar iaddr_old[32];\n\tchar rhost_old[32];\n\tunsigned short iport_old;\n\tstruct in_addr address;\n\tunsigned int timestamp;\n\n\tproto = proto_atoi(protocol);\n\tif(inet_aton(iaddr, &address) <= 0) {\n\t\tsyslog(LOG_ERR, \"inet_aton(%s) FAILED\", iaddr);\n\t\treturn -1;\n\t}\n\n\tif(!check_upnp_rule_against_permissions(upnppermlist, num_upnpperm,\n\t                                        eport, address, iport)) {\n\t\tsyslog(LOG_INFO, \"redirection permission check failed for \"\n \t\t                 \"%hu->%s:%hu %s\", eport, iaddr, iport, protocol);\n \t\treturn -3;\n \t}\n\n\tif (desc == NULL)\n\t\tdesc = \"\";\t/* assume empty description */\n\n \t/* IGDv1 (WANIPConnection:1 Service Template Version 1.01 / Nov 12, 2001)\n \t * - 2.2.20.PortMappingDescription :\n \t *  Overwriting Previous / Existing Port Mappings:\n\t * If the RemoteHost, ExternalPort, PortMappingProtocol and InternalClient\n\t * are exactly the same as an existing mapping, the existing mapping values\n\t * for InternalPort, PortMappingDescription, PortMappingEnabled and\n\t * PortMappingLeaseDuration are overwritten.\n\t *  Rejecting a New Port Mapping:\n\t * In cases where the RemoteHost, ExternalPort and PortMappingProtocol\n\t * are the same as an existing mapping, but the InternalClient is\n\t * different, the action is rejected with an appropriate error.\n\t *  Add or Reject New Port Mapping behavior based on vendor implementation:\n\t * In cases where the ExternalPort, PortMappingProtocol and InternalClient\n\t * are the same, but RemoteHost is different, the vendor can choose to\n\t * support both mappings simultaneously, or reject the second mapping\n\t * with an appropriate error.\n\t *\n\t * - 2.4.16.AddPortMapping\n\t * This action creates a new port mapping or overwrites an existing\n\t * mapping with the same internal client. If the ExternalPort and\n\t * PortMappingProtocol pair is already mapped to another internal client,\n\t * an error is returned.\n\t *\n\t * IGDv2 (WANIPConnection:2 Service Standardized DCP (SDCP) Sep 10, 2010)\n\t * Protocol ExternalPort RemoteHost InternalClient Result\n\t *     =         =           \u2260           \u2260         Failure\n\t *     =         =           \u2260           =         Failure or success\n\t *                                                 (vendor specific)\n\t *     =         =           =           \u2260         Failure\n\t *     =         =           =           =         Success (overwrite)\n\t */\n\trhost_old[0] = '\\0';\n\tr = get_redirect_rule(ext_if_name, eport, proto,\n\t                      iaddr_old, sizeof(iaddr_old), &iport_old, 0, 0,\n\t                      rhost_old, sizeof(rhost_old),\n\t                      &timestamp, 0, 0);\n\tif(r == 0) {\n\t\tif(strcmp(iaddr, iaddr_old)==0 &&\n\t\t   ((rhost == NULL && rhost_old[0]=='\\0') ||\n\t\t    (rhost && (strcmp(rhost, \"*\") == 0) && rhost_old[0]=='\\0') ||\n\t\t    (rhost && (strcmp(rhost, rhost_old) == 0)))) {\n\t\t\tsyslog(LOG_INFO, \"updating existing port mapping %hu %s (rhost '%s') => %s:%hu\",\n\t\t\t\teport, protocol, rhost_old, iaddr_old, iport_old);\n\t\t\ttimestamp = (leaseduration > 0) ? upnp_time() + leaseduration : 0;\n\t\t\tif(iport != iport_old) {\n\t\t\t\tr = update_portmapping(ext_if_name, eport, proto, iport, desc, timestamp);\n\t\t\t} else {\n\t\t\t\tr = update_portmapping_desc_timestamp(ext_if_name, eport, proto, desc, timestamp);\n\t\t\t}\n#ifdef ENABLE_LEASEFILE\n\t\t\tif(r == 0) {\n\t\t\t\tlease_file_remove(eport, proto);\n\t\t\t\tlease_file_add(eport, iaddr, iport, proto, desc, timestamp);\n\t\t\t}\n#endif /* ENABLE_LEASEFILE */\n\t\t\treturn r;\n\t\t} else {\n\t\t\tsyslog(LOG_INFO, \"port %hu %s (rhost '%s') already redirected to %s:%hu\",\n\t\t\t\teport, protocol, rhost_old, iaddr_old, iport_old);\n\t\t\treturn -2;\n\t\t}\n#ifdef CHECK_PORTINUSE\n\t} else if (port_in_use(ext_if_name, eport, proto, iaddr, iport) > 0) {\n\t\tsyslog(LOG_INFO, \"port %hu protocol %s already in use\",\n\t\t       eport, protocol);\n\t\treturn -4;\n#endif /* CHECK_PORTINUSE */\n\t} else {\n\t\ttimestamp = (leaseduration > 0) ? upnp_time() + leaseduration : 0;\n\t\tsyslog(LOG_INFO, \"redirecting port %hu to %s:%hu protocol %s for: %s\",\n\t\t\teport, iaddr, iport, protocol, desc);\n\t\treturn upnp_redirect_internal(rhost, eport, iaddr, iport, proto,\n\t\t                              desc, timestamp);\n\t}\n}\n",
    "cwe": [
      "CWE-476"
    ],
    "id": 273,
    "_valid_cwes": [
      "CWE-476"
    ]
  },
  {
    "cve_id": "CVE-2013-4119",
    "code_before_change": "void* sspi_SecureHandleGetUpperPointer(SecHandle* handle)\n {\n \tvoid* pointer;\n \n\tif (!handle)\n \t\treturn NULL;\n \n \tpointer = (void*) ~((size_t) handle->dwUpper);\n\n\treturn pointer;\n}\n",
    "code_after_change": "void* sspi_SecureHandleGetUpperPointer(SecHandle* handle)\n {\n \tvoid* pointer;\n \n\tif (!handle || !SecIsValidHandle(handle))\n \t\treturn NULL;\n \n \tpointer = (void*) ~((size_t) handle->dwUpper);\n\n\treturn pointer;\n}\n",
    "cwe": [
      "CWE-476"
    ],
    "id": 339,
    "_valid_cwes": [
      "CWE-476"
    ]
  },
  {
    "cve_id": "CVE-2016-5354",
    "code_before_change": "dissect_ac_if_hdr_body(tvbuff_t *tvb, gint offset, packet_info *pinfo _U_,\n        proto_tree *tree, usb_conv_info_t *usb_conv_info)\n{\n    gint     offset_start;\n    guint16  bcdADC;\n    guint8   ver_major;\n    double   ver;\n    guint8   if_in_collection, i;\n    audio_conv_info_t *audio_conv_info;\n\n\n    offset_start = offset;\n\n    bcdADC = tvb_get_letohs(tvb, offset);\n    ver_major = USB_AUDIO_BCD44_TO_DEC(bcdADC>>8);\n    ver = ver_major + USB_AUDIO_BCD44_TO_DEC(bcdADC&0xFF) / 100.0;\n\n    proto_tree_add_double_format_value(tree, hf_ac_if_hdr_ver,\n            tvb, offset, 2, ver, \"%2.2f\", ver);\n    audio_conv_info = (audio_conv_info_t *)usb_conv_info->class_data;\n     if(!audio_conv_info) {\n         audio_conv_info = wmem_new(wmem_file_scope(), audio_conv_info_t);\n         usb_conv_info->class_data = audio_conv_info;\n         /* XXX - set reasonable default values for all components\n            that are not filled in by this function */\n     }\n     audio_conv_info->ver_major = ver_major;\n     offset += 2;\n\n    /* version 1 refers to the Basic Audio Device specification,\n       version 2 is the Audio Device class specification, see above */\n    if (ver_major==1) {\n        proto_tree_add_item(tree, hf_ac_if_hdr_total_len,\n                tvb, offset, 2, ENC_LITTLE_ENDIAN);\n        offset += 2;\n        if_in_collection = tvb_get_guint8(tvb, offset);\n        proto_tree_add_item(tree, hf_ac_if_hdr_bInCollection,\n                tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        offset++;\n\n        for (i=0; i<if_in_collection; i++) {\n            proto_tree_add_item(tree, hf_ac_if_hdr_if_num,\n                    tvb, offset, 1, ENC_LITTLE_ENDIAN);\n            offset++;\n        }\n    }\n\n    return offset-offset_start;\n}\n",
    "code_after_change": "dissect_ac_if_hdr_body(tvbuff_t *tvb, gint offset, packet_info *pinfo _U_,\n        proto_tree *tree, usb_conv_info_t *usb_conv_info)\n{\n    gint     offset_start;\n    guint16  bcdADC;\n    guint8   ver_major;\n    double   ver;\n    guint8   if_in_collection, i;\n    audio_conv_info_t *audio_conv_info;\n\n\n    offset_start = offset;\n\n    bcdADC = tvb_get_letohs(tvb, offset);\n    ver_major = USB_AUDIO_BCD44_TO_DEC(bcdADC>>8);\n    ver = ver_major + USB_AUDIO_BCD44_TO_DEC(bcdADC&0xFF) / 100.0;\n\n    proto_tree_add_double_format_value(tree, hf_ac_if_hdr_ver,\n            tvb, offset, 2, ver, \"%2.2f\", ver);\n    audio_conv_info = (audio_conv_info_t *)usb_conv_info->class_data;\n     if(!audio_conv_info) {\n         audio_conv_info = wmem_new(wmem_file_scope(), audio_conv_info_t);\n         usb_conv_info->class_data = audio_conv_info;\n        usb_conv_info->class_data_type = USB_CONV_AUDIO;\n         /* XXX - set reasonable default values for all components\n            that are not filled in by this function */\n    } else if (usb_conv_info->class_data_type != USB_CONV_AUDIO) {\n        /* Don't dissect if another USB type is in the conversation */\n        return 0;\n     }\n     audio_conv_info->ver_major = ver_major;\n     offset += 2;\n\n    /* version 1 refers to the Basic Audio Device specification,\n       version 2 is the Audio Device class specification, see above */\n    if (ver_major==1) {\n        proto_tree_add_item(tree, hf_ac_if_hdr_total_len,\n                tvb, offset, 2, ENC_LITTLE_ENDIAN);\n        offset += 2;\n        if_in_collection = tvb_get_guint8(tvb, offset);\n        proto_tree_add_item(tree, hf_ac_if_hdr_bInCollection,\n                tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        offset++;\n\n        for (i=0; i<if_in_collection; i++) {\n            proto_tree_add_item(tree, hf_ac_if_hdr_if_num,\n                    tvb, offset, 1, ENC_LITTLE_ENDIAN);\n            offset++;\n        }\n    }\n\n    return offset-offset_start;\n}\n",
    "cwe": [
      "CWE-476"
    ],
    "id": 382,
    "_valid_cwes": [
      "CWE-476"
    ]
  },
  {
    "cve_id": "CVE-2013-4119",
    "code_before_change": "BOOL transport_accept_nla(rdpTransport* transport)\n{\n\tfreerdp* instance;\n\trdpSettings* settings;\n\n\tif (transport->TlsIn == NULL)\n\t\ttransport->TlsIn = tls_new(transport->settings);\n\n\tif (transport->TlsOut == NULL)\n\t\ttransport->TlsOut = transport->TlsIn;\n\n\ttransport->layer = TRANSPORT_LAYER_TLS;\n\ttransport->TlsIn->sockfd = transport->TcpIn->sockfd;\n\n\tif (tls_accept(transport->TlsIn, transport->settings->CertificateFile, transport->settings->PrivateKeyFile) != TRUE)\n\t\treturn FALSE;\n\n\t/* Network Level Authentication */\n\n\tif (transport->settings->Authentication != TRUE)\n\t\treturn TRUE;\n\n\tsettings = transport->settings;\n\tinstance = (freerdp*) settings->instance;\n\n\tif (transport->credssp == NULL)\n\t\ttransport->credssp = credssp_new(instance, transport, settings);\n\n\tif (credssp_authenticate(transport->credssp) < 0)\n \t{\n \t\tfprintf(stderr, \"client authentication failure\\n\");\n \t\tcredssp_free(transport->credssp);\n \t\treturn FALSE;\n \t}\n \n\t/* don't free credssp module yet, we need to copy the credentials from it first */\n\n\treturn TRUE;\n}\n",
    "code_after_change": "BOOL transport_accept_nla(rdpTransport* transport)\n{\n\tfreerdp* instance;\n\trdpSettings* settings;\n\n\tif (transport->TlsIn == NULL)\n\t\ttransport->TlsIn = tls_new(transport->settings);\n\n\tif (transport->TlsOut == NULL)\n\t\ttransport->TlsOut = transport->TlsIn;\n\n\ttransport->layer = TRANSPORT_LAYER_TLS;\n\ttransport->TlsIn->sockfd = transport->TcpIn->sockfd;\n\n\tif (tls_accept(transport->TlsIn, transport->settings->CertificateFile, transport->settings->PrivateKeyFile) != TRUE)\n\t\treturn FALSE;\n\n\t/* Network Level Authentication */\n\n\tif (transport->settings->Authentication != TRUE)\n\t\treturn TRUE;\n\n\tsettings = transport->settings;\n\tinstance = (freerdp*) settings->instance;\n\n\tif (transport->credssp == NULL)\n\t\ttransport->credssp = credssp_new(instance, transport, settings);\n\n\tif (credssp_authenticate(transport->credssp) < 0)\n \t{\n \t\tfprintf(stderr, \"client authentication failure\\n\");\n \t\tcredssp_free(transport->credssp);\n\t\ttransport->credssp = NULL;\n \t\treturn FALSE;\n \t}\n \n\t/* don't free credssp module yet, we need to copy the credentials from it first */\n\n\treturn TRUE;\n}\n",
    "cwe": [
      "CWE-476"
    ],
    "id": 388,
    "_valid_cwes": [
      "CWE-476"
    ]
  },
  {
    "cve_id": "CVE-2016-3821",
    "code_before_change": "status_t MediaPlayer::setDataSource(const sp<IStreamSource> &source)\n\n {\n     ALOGV(\"setDataSource\");\n     status_t err = UNKNOWN_ERROR;\n    const sp<IMediaPlayerService>& service(getMediaPlayerService());\n     if (service != 0) {\n         sp<IMediaPlayer> player(service->create(this, mAudioSessionId));\n         if ((NO_ERROR != doSetRetransmitEndpoint(player)) ||\n (NO_ERROR != player->setDataSource(source))) {\n            player.clear();\n }\n        err = attachNewPlayer(player);\n }\n return err;\n}\n",
    "code_after_change": "status_t MediaPlayer::setDataSource(const sp<IStreamSource> &source)\n\n {\n     ALOGV(\"setDataSource\");\n     status_t err = UNKNOWN_ERROR;\n    const sp<IMediaPlayerService> service(getMediaPlayerService());\n     if (service != 0) {\n         sp<IMediaPlayer> player(service->create(this, mAudioSessionId));\n         if ((NO_ERROR != doSetRetransmitEndpoint(player)) ||\n (NO_ERROR != player->setDataSource(source))) {\n            player.clear();\n }\n        err = attachNewPlayer(player);\n }\n return err;\n}\n",
    "cwe": [
      "CWE-476"
    ],
    "id": 523,
    "_valid_cwes": [
      "CWE-476"
    ]
  },
  {
    "cve_id": "CVE-2018-15859",
    "code_before_change": "ExprResolveLhs(struct xkb_context *ctx, const ExprDef *expr,\n               const char **elem_rtrn, const char **field_rtrn,\n               ExprDef **index_rtrn)\n{\n    switch (expr->expr.op) {\n    case EXPR_IDENT:\n        *elem_rtrn = NULL;\n        *field_rtrn = xkb_atom_text(ctx, expr->ident.ident);\n        *index_rtrn = NULL;\n        return (*field_rtrn != NULL);\n    case EXPR_FIELD_REF:\n         *elem_rtrn = xkb_atom_text(ctx, expr->field_ref.element);\n         *field_rtrn = xkb_atom_text(ctx, expr->field_ref.field);\n         *index_rtrn = NULL;\n        return true;\n     case EXPR_ARRAY_REF:\n         *elem_rtrn = xkb_atom_text(ctx, expr->array_ref.element);\n         *field_rtrn = xkb_atom_text(ctx, expr->array_ref.field);\n         *index_rtrn = expr->array_ref.entry;\n         return true;\n     default:\n         break;\n    }\n    log_wsgo(ctx, \"Unexpected operator %d in ResolveLhs\\n\", expr->expr.op);\n    return false;\n}\n",
    "code_after_change": "ExprResolveLhs(struct xkb_context *ctx, const ExprDef *expr,\n               const char **elem_rtrn, const char **field_rtrn,\n               ExprDef **index_rtrn)\n{\n    switch (expr->expr.op) {\n    case EXPR_IDENT:\n        *elem_rtrn = NULL;\n        *field_rtrn = xkb_atom_text(ctx, expr->ident.ident);\n        *index_rtrn = NULL;\n        return (*field_rtrn != NULL);\n    case EXPR_FIELD_REF:\n         *elem_rtrn = xkb_atom_text(ctx, expr->field_ref.element);\n         *field_rtrn = xkb_atom_text(ctx, expr->field_ref.field);\n         *index_rtrn = NULL;\n        return (*elem_rtrn != NULL && *field_rtrn != NULL);\n     case EXPR_ARRAY_REF:\n         *elem_rtrn = xkb_atom_text(ctx, expr->array_ref.element);\n         *field_rtrn = xkb_atom_text(ctx, expr->array_ref.field);\n         *index_rtrn = expr->array_ref.entry;\n\tif (expr->array_ref.element != XKB_ATOM_NONE && *elem_rtrn == NULL)\n\t\treturn false;\n\tif (*field_rtrn == NULL)\n\t\treturn false;\n         return true;\n     default:\n         break;\n    }\n    log_wsgo(ctx, \"Unexpected operator %d in ResolveLhs\\n\", expr->expr.op);\n    return false;\n}\n",
    "cwe": [
      "CWE-476"
    ],
    "id": 549,
    "_valid_cwes": [
      "CWE-476"
    ]
  },
  {
    "cve_id": "CVE-2016-9934",
    "code_before_change": "static void php_wddx_serialize_object(wddx_packet *packet, zval *obj)\n{\n/* OBJECTS_FIXME */\n\tzval **ent, *fname, **varname;\n\tzval *retval = NULL;\n\tconst char *key;\n \tulong idx;\n \tchar tmp_buf[WDDX_BUF_LEN];\n \tHashTable *objhash, *sleephash;\n \tTSRMLS_FETCH();\n \n \tMAKE_STD_ZVAL(fname);\n \tZVAL_STRING(fname, \"__sleep\", 1);\n \t/*\n \t * We try to call __sleep() method on object. It's supposed to return an\n \t * array of property names to be serialized.\n \t */\n \tif (call_user_function_ex(CG(function_table), &obj, fname, &retval, 0, 0, 1, NULL TSRMLS_CC) == SUCCESS) {\n \t\tif (retval && (sleephash = HASH_OF(retval))) {\n\t\t\tPHP_CLASS_ATTRIBUTES;\n\t\t\tPHP_SET_CLASS_ATTRIBUTES(obj);\n \t\t\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_S);\n \t\t\tsnprintf(tmp_buf, WDDX_BUF_LEN, WDDX_VAR_S, PHP_CLASS_NAME_VAR);\n \t\t\tphp_wddx_add_chunk(packet, tmp_buf);\n\t\t\tphp_wddx_add_chunk_static(packet, WDDX_STRING_S);\n\t\t\tphp_wddx_add_chunk_ex(packet, class_name, name_len);\n \t\t\tphp_wddx_add_chunk_static(packet, WDDX_STRING_E);\n \t\t\tphp_wddx_add_chunk_static(packet, WDDX_VAR_E);\n \n\t\t\tPHP_CLEANUP_CLASS_ATTRIBUTES();\n \t\t\tobjhash = HASH_OF(obj);\n \n \t\t\tfor (zend_hash_internal_pointer_reset(sleephash);\n\t\t\t\t zend_hash_get_current_data(sleephash, (void **)&varname) == SUCCESS;\n\t\t\t\t zend_hash_move_forward(sleephash)) {\n\t\t\t\tif (Z_TYPE_PP(varname) != IS_STRING) {\n\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"__sleep should return an array only containing the names of instance-variables to serialize.\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (zend_hash_find(objhash, Z_STRVAL_PP(varname), Z_STRLEN_PP(varname)+1, (void **)&ent) == SUCCESS) {\n\t\t\t\t\tphp_wddx_serialize_var(packet, *ent, Z_STRVAL_PP(varname), Z_STRLEN_PP(varname) TSRMLS_CC);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_E);\n\t\t}\n \t} else {\n \t\tuint key_len;\n \n\t\tPHP_CLASS_ATTRIBUTES;\n\t\tPHP_SET_CLASS_ATTRIBUTES(obj);\n \t\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_S);\n \t\tsnprintf(tmp_buf, WDDX_BUF_LEN, WDDX_VAR_S, PHP_CLASS_NAME_VAR);\n \t\tphp_wddx_add_chunk(packet, tmp_buf);\n\t\tphp_wddx_add_chunk_static(packet, WDDX_STRING_S);\n\t\tphp_wddx_add_chunk_ex(packet, class_name, name_len);\n \t\tphp_wddx_add_chunk_static(packet, WDDX_STRING_E);\n \t\tphp_wddx_add_chunk_static(packet, WDDX_VAR_E);\n \n\t\tPHP_CLEANUP_CLASS_ATTRIBUTES();\n \t\tobjhash = HASH_OF(obj);\n \t\tfor (zend_hash_internal_pointer_reset(objhash);\n \t\t\t zend_hash_get_current_data(objhash, (void**)&ent) == SUCCESS;\n\t\t\t zend_hash_move_forward(objhash)) {\n\t\t\tif (*ent == obj) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (zend_hash_get_current_key_ex(objhash, &key, &key_len, &idx, 0, NULL) == HASH_KEY_IS_STRING) {\n\t\t\t\tconst char *class_name, *prop_name;\n\n\t\t\t\tzend_unmangle_property_name(key, key_len-1, &class_name, &prop_name);\n\t\t\t\tphp_wddx_serialize_var(packet, *ent, prop_name, strlen(prop_name)+1 TSRMLS_CC);\n\t\t\t} else {\n\t\t\t\tkey_len = slprintf(tmp_buf, sizeof(tmp_buf), \"%ld\", idx);\n\t\t\t\tphp_wddx_serialize_var(packet, *ent, tmp_buf, key_len TSRMLS_CC);\n\t\t\t}\n\t\t}\n \t\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_E);\n \t}\n \n \tzval_dtor(fname);\n \tFREE_ZVAL(fname);\n \n\tif (retval) {\n\t\tzval_ptr_dtor(&retval);\n\t}\n}\n",
    "code_after_change": "static void php_wddx_serialize_object(wddx_packet *packet, zval *obj)\n{\n/* OBJECTS_FIXME */\n\tzval **ent, *fname, **varname;\n\tzval *retval = NULL;\n\tconst char *key;\n \tulong idx;\n \tchar tmp_buf[WDDX_BUF_LEN];\n \tHashTable *objhash, *sleephash;\n\tzend_class_entry *ce;\n\tPHP_CLASS_ATTRIBUTES;\n \tTSRMLS_FETCH();\n \n\tPHP_SET_CLASS_ATTRIBUTES(obj);\n\tce = Z_OBJCE_P(obj);\n\tif (!ce || ce->serialize || ce->unserialize) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Class %s can not be serialized\", class_name);\n\t\tPHP_CLEANUP_CLASS_ATTRIBUTES();\n\t\treturn;\n\t}\n\n \tMAKE_STD_ZVAL(fname);\n \tZVAL_STRING(fname, \"__sleep\", 1);\n \t/*\n \t * We try to call __sleep() method on object. It's supposed to return an\n \t * array of property names to be serialized.\n \t */\n \tif (call_user_function_ex(CG(function_table), &obj, fname, &retval, 0, 0, 1, NULL TSRMLS_CC) == SUCCESS) {\n \t\tif (retval && (sleephash = HASH_OF(retval))) {\n \t\t\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_S);\n \t\t\tsnprintf(tmp_buf, WDDX_BUF_LEN, WDDX_VAR_S, PHP_CLASS_NAME_VAR);\n \t\t\tphp_wddx_add_chunk(packet, tmp_buf);\n\t\t\tphp_wddx_add_chunk_static(packet, WDDX_STRING_S);\n\t\t\tphp_wddx_add_chunk_ex(packet, class_name, name_len);\n \t\t\tphp_wddx_add_chunk_static(packet, WDDX_STRING_E);\n \t\t\tphp_wddx_add_chunk_static(packet, WDDX_VAR_E);\n \n \t\t\tobjhash = HASH_OF(obj);\n \n \t\t\tfor (zend_hash_internal_pointer_reset(sleephash);\n\t\t\t\t zend_hash_get_current_data(sleephash, (void **)&varname) == SUCCESS;\n\t\t\t\t zend_hash_move_forward(sleephash)) {\n\t\t\t\tif (Z_TYPE_PP(varname) != IS_STRING) {\n\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"__sleep should return an array only containing the names of instance-variables to serialize.\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (zend_hash_find(objhash, Z_STRVAL_PP(varname), Z_STRLEN_PP(varname)+1, (void **)&ent) == SUCCESS) {\n\t\t\t\t\tphp_wddx_serialize_var(packet, *ent, Z_STRVAL_PP(varname), Z_STRLEN_PP(varname) TSRMLS_CC);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_E);\n\t\t}\n \t} else {\n \t\tuint key_len;\n \n \t\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_S);\n \t\tsnprintf(tmp_buf, WDDX_BUF_LEN, WDDX_VAR_S, PHP_CLASS_NAME_VAR);\n \t\tphp_wddx_add_chunk(packet, tmp_buf);\n\t\tphp_wddx_add_chunk_static(packet, WDDX_STRING_S);\n\t\tphp_wddx_add_chunk_ex(packet, class_name, name_len);\n \t\tphp_wddx_add_chunk_static(packet, WDDX_STRING_E);\n \t\tphp_wddx_add_chunk_static(packet, WDDX_VAR_E);\n \n \t\tobjhash = HASH_OF(obj);\n \t\tfor (zend_hash_internal_pointer_reset(objhash);\n \t\t\t zend_hash_get_current_data(objhash, (void**)&ent) == SUCCESS;\n\t\t\t zend_hash_move_forward(objhash)) {\n\t\t\tif (*ent == obj) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (zend_hash_get_current_key_ex(objhash, &key, &key_len, &idx, 0, NULL) == HASH_KEY_IS_STRING) {\n\t\t\t\tconst char *class_name, *prop_name;\n\n\t\t\t\tzend_unmangle_property_name(key, key_len-1, &class_name, &prop_name);\n\t\t\t\tphp_wddx_serialize_var(packet, *ent, prop_name, strlen(prop_name)+1 TSRMLS_CC);\n\t\t\t} else {\n\t\t\t\tkey_len = slprintf(tmp_buf, sizeof(tmp_buf), \"%ld\", idx);\n\t\t\t\tphp_wddx_serialize_var(packet, *ent, tmp_buf, key_len TSRMLS_CC);\n\t\t\t}\n\t\t}\n \t\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_E);\n \t}\n \n\tPHP_CLEANUP_CLASS_ATTRIBUTES();\n\n \tzval_dtor(fname);\n \tFREE_ZVAL(fname);\n \n\tif (retval) {\n\t\tzval_ptr_dtor(&retval);\n\t}\n}\n",
    "cwe": [
      "CWE-476"
    ],
    "id": 559,
    "_valid_cwes": [
      "CWE-476"
    ]
  },
  {
    "cve_id": "CVE-2019-13225",
    "code_before_change": "compile_bag_node(BagNode* node, regex_t* reg, ScanEnv* env)\n{\n  int r, len;\n\n  switch (node->type) {\n  case BAG_MEMORY:\n    r = compile_bag_memory_node(node, reg, env);\n    break;\n\n  case BAG_OPTION:\n    r = compile_option_node(node, reg, env);\n    break;\n\n  case BAG_STOP_BACKTRACK:\n    if (NODE_IS_STOP_BT_SIMPLE_REPEAT(node)) {\n      QuantNode* qn = QUANT_(NODE_BAG_BODY(node));\n      r = compile_tree_n_times(NODE_QUANT_BODY(qn), qn->lower, reg, env);\n      if (r != 0) return r;\n\n      len = compile_length_tree(NODE_QUANT_BODY(qn), reg);\n      if (len < 0) return len;\n\n      r = add_op(reg, OP_PUSH);\n      if (r != 0) return r;\n      COP(reg)->push.addr = SIZE_INC_OP + len + SIZE_OP_POP_OUT + SIZE_OP_JUMP;\n\n      r = compile_tree(NODE_QUANT_BODY(qn), reg, env);\n      if (r != 0) return r;\n      r = add_op(reg, OP_POP_OUT);\n      if (r != 0) return r;\n\n      r = add_op(reg, OP_JUMP);\n      if (r != 0) return r;\n      COP(reg)->jump.addr = -((int )SIZE_OP_PUSH + len + (int )SIZE_OP_POP_OUT);\n    }\n    else {\n      r = add_op(reg, OP_ATOMIC_START);\n      if (r != 0) return r;\n      r = compile_tree(NODE_BAG_BODY(node), reg, env);\n      if (r != 0) return r;\n      r = add_op(reg, OP_ATOMIC_END);\n    }\n    break;\n \n   case BAG_IF_ELSE:\n     {\n      int cond_len, then_len, jump_len;\n       Node* cond = NODE_BAG_BODY(node);\n       Node* Then = node->te.Then;\n       Node* Else = node->te.Else;\n\n      r = add_op(reg, OP_ATOMIC_START);\n      if (r != 0) return r;\n\n      cond_len = compile_length_tree(cond, reg);\n      if (cond_len < 0) return cond_len;\n      if (IS_NOT_NULL(Then)) {\n        then_len = compile_length_tree(Then, reg);\n        if (then_len < 0) return then_len;\n      }\n       else\n         then_len = 0;\n \n      jump_len = cond_len + then_len + SIZE_OP_ATOMIC_END;\n      if (IS_NOT_NULL(Else)) jump_len += SIZE_OP_JUMP;\n \n       r = add_op(reg, OP_PUSH);\n       if (r != 0) return r;\n      COP(reg)->push.addr = SIZE_INC_OP + jump_len;\n\n      r = compile_tree(cond, reg, env);\n      if (r != 0) return r;\n      r = add_op(reg, OP_ATOMIC_END);\n      if (r != 0) return r;\n\n      if (IS_NOT_NULL(Then)) {\n        r = compile_tree(Then, reg, env);\n        if (r != 0) return r;\n       }\n \n       if (IS_NOT_NULL(Else)) {\n        int else_len = compile_length_tree(Else, reg);\n        r = add_op(reg, OP_JUMP);\n        if (r != 0) return r;\n        COP(reg)->jump.addr = else_len + SIZE_INC_OP;\n \n         r = compile_tree(Else, reg, env);\n       }\n     }\n    break;\n  }\n\n  return r;\n}\n",
    "code_after_change": "compile_bag_node(BagNode* node, regex_t* reg, ScanEnv* env)\n{\n  int r, len;\n\n  switch (node->type) {\n  case BAG_MEMORY:\n    r = compile_bag_memory_node(node, reg, env);\n    break;\n\n  case BAG_OPTION:\n    r = compile_option_node(node, reg, env);\n    break;\n\n  case BAG_STOP_BACKTRACK:\n    if (NODE_IS_STOP_BT_SIMPLE_REPEAT(node)) {\n      QuantNode* qn = QUANT_(NODE_BAG_BODY(node));\n      r = compile_tree_n_times(NODE_QUANT_BODY(qn), qn->lower, reg, env);\n      if (r != 0) return r;\n\n      len = compile_length_tree(NODE_QUANT_BODY(qn), reg);\n      if (len < 0) return len;\n\n      r = add_op(reg, OP_PUSH);\n      if (r != 0) return r;\n      COP(reg)->push.addr = SIZE_INC_OP + len + SIZE_OP_POP_OUT + SIZE_OP_JUMP;\n\n      r = compile_tree(NODE_QUANT_BODY(qn), reg, env);\n      if (r != 0) return r;\n      r = add_op(reg, OP_POP_OUT);\n      if (r != 0) return r;\n\n      r = add_op(reg, OP_JUMP);\n      if (r != 0) return r;\n      COP(reg)->jump.addr = -((int )SIZE_OP_PUSH + len + (int )SIZE_OP_POP_OUT);\n    }\n    else {\n      r = add_op(reg, OP_ATOMIC_START);\n      if (r != 0) return r;\n      r = compile_tree(NODE_BAG_BODY(node), reg, env);\n      if (r != 0) return r;\n      r = add_op(reg, OP_ATOMIC_END);\n    }\n    break;\n \n   case BAG_IF_ELSE:\n     {\n      int cond_len, then_len, else_len, jump_len;\n       Node* cond = NODE_BAG_BODY(node);\n       Node* Then = node->te.Then;\n       Node* Else = node->te.Else;\n\n      r = add_op(reg, OP_ATOMIC_START);\n      if (r != 0) return r;\n\n      cond_len = compile_length_tree(cond, reg);\n      if (cond_len < 0) return cond_len;\n      if (IS_NOT_NULL(Then)) {\n        then_len = compile_length_tree(Then, reg);\n        if (then_len < 0) return then_len;\n      }\n       else\n         then_len = 0;\n \n      jump_len = cond_len + then_len + SIZE_OP_ATOMIC_END + SIZE_OP_JUMP;\n \n       r = add_op(reg, OP_PUSH);\n       if (r != 0) return r;\n      COP(reg)->push.addr = SIZE_INC_OP + jump_len;\n\n      r = compile_tree(cond, reg, env);\n      if (r != 0) return r;\n      r = add_op(reg, OP_ATOMIC_END);\n      if (r != 0) return r;\n\n      if (IS_NOT_NULL(Then)) {\n        r = compile_tree(Then, reg, env);\n        if (r != 0) return r;\n       }\n \n       if (IS_NOT_NULL(Else)) {\n        else_len = compile_length_tree(Else, reg);\n        if (else_len < 0) return else_len;\n      }\n      else\n        else_len = 0;\n \n      r = add_op(reg, OP_JUMP);\n      if (r != 0) return r;\n      COP(reg)->jump.addr = SIZE_OP_ATOMIC_END + else_len + SIZE_INC_OP;\n\n      r = add_op(reg, OP_ATOMIC_END);\n      if (r != 0) return r;\n\n      if (IS_NOT_NULL(Else)) {\n         r = compile_tree(Else, reg, env);\n       }\n     }\n    break;\n  }\n\n  return r;\n}\n",
    "cwe": [
      "CWE-476"
    ],
    "id": 582,
    "_valid_cwes": [
      "CWE-476"
    ]
  },
  {
    "cve_id": "CVE-2017-6850",
    "code_before_change": "static int jp2_cdef_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n \tjp2_cdef_t *cdef = &box->data.cdef;\n \tjp2_cdefchan_t *chan;\n \tunsigned int channo;\n \tif (jp2_getuint16(in, &cdef->numchans)) {\n \t\treturn -1;\n \t}\n\tif (!(cdef->ents = jas_alloc2(cdef->numchans, sizeof(jp2_cdefchan_t)))) {\n\t\treturn -1;\n\t}\n\tfor (channo = 0; channo < cdef->numchans; ++channo) {\n\t\tchan = &cdef->ents[channo];\n\t\tif (jp2_getuint16(in, &chan->channo) || jp2_getuint16(in, &chan->type) ||\n\t\t  jp2_getuint16(in, &chan->assoc)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n",
    "code_after_change": "static int jp2_cdef_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n \tjp2_cdef_t *cdef = &box->data.cdef;\n \tjp2_cdefchan_t *chan;\n \tunsigned int channo;\n\tcdef->ents = 0;\n \tif (jp2_getuint16(in, &cdef->numchans)) {\n \t\treturn -1;\n \t}\n\tif (!(cdef->ents = jas_alloc2(cdef->numchans, sizeof(jp2_cdefchan_t)))) {\n\t\treturn -1;\n\t}\n\tfor (channo = 0; channo < cdef->numchans; ++channo) {\n\t\tchan = &cdef->ents[channo];\n\t\tif (jp2_getuint16(in, &chan->channo) || jp2_getuint16(in, &chan->type) ||\n\t\t  jp2_getuint16(in, &chan->assoc)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n",
    "cwe": [
      "CWE-476"
    ],
    "id": 742,
    "_valid_cwes": [
      "CWE-476"
    ]
  },
  {
    "cve_id": "CVE-2018-15858",
    "code_before_change": "CopyKeyAliasesToKeymap(struct xkb_keymap *keymap, KeyNamesInfo *info)\n{\n    AliasInfo *alias;\n    unsigned i, num_key_aliases;\n    struct xkb_key_alias *key_aliases;\n\n    /*\n     * Do some sanity checking on the aliases. We can't do it before\n     * because keys and their aliases may be added out-of-order.\n     */\n    num_key_aliases = 0;\n    darray_foreach(alias, info->aliases) {\n        /* Check that ->real is a key. */\n        if (!XkbKeyByName(keymap, alias->real, false)) {\n            log_vrb(info->ctx, 5,\n                    \"Attempt to alias %s to non-existent key %s; Ignored\\n\",\n                    KeyNameText(info->ctx, alias->alias),\n                    KeyNameText(info->ctx, alias->real));\n            alias->real = XKB_ATOM_NONE;\n            continue;\n        }\n\n        /* Check that ->alias is not a key. */\n        if (XkbKeyByName(keymap, alias->alias, false)) {\n            log_vrb(info->ctx, 5,\n                    \"Attempt to create alias with the name of a real key; \"\n                    \"Alias \\\"%s = %s\\\" ignored\\n\",\n                    KeyNameText(info->ctx, alias->alias),\n                    KeyNameText(info->ctx, alias->real));\n            alias->real = XKB_ATOM_NONE;\n            continue;\n        }\n\n        num_key_aliases++;\n    }\n\n    /* Copy key aliases. */\n    key_aliases = NULL;\n    if (num_key_aliases > 0) {\n         key_aliases = calloc(num_key_aliases, sizeof(*key_aliases));\n         if (!key_aliases)\n             return false;\n    }\n \n    i = 0;\n    darray_foreach(alias, info->aliases) {\n        if (alias->real != XKB_ATOM_NONE) {\n            key_aliases[i].alias = alias->alias;\n            key_aliases[i].real = alias->real;\n            i++;\n         }\n     }\n \n    keymap->num_key_aliases = num_key_aliases;\n    keymap->key_aliases = key_aliases;\n    return true;\n}\n",
    "code_after_change": "CopyKeyAliasesToKeymap(struct xkb_keymap *keymap, KeyNamesInfo *info)\n{\n    AliasInfo *alias;\n    unsigned i, num_key_aliases;\n    struct xkb_key_alias *key_aliases;\n\n    /*\n     * Do some sanity checking on the aliases. We can't do it before\n     * because keys and their aliases may be added out-of-order.\n     */\n    num_key_aliases = 0;\n    darray_foreach(alias, info->aliases) {\n        /* Check that ->real is a key. */\n        if (!XkbKeyByName(keymap, alias->real, false)) {\n            log_vrb(info->ctx, 5,\n                    \"Attempt to alias %s to non-existent key %s; Ignored\\n\",\n                    KeyNameText(info->ctx, alias->alias),\n                    KeyNameText(info->ctx, alias->real));\n            alias->real = XKB_ATOM_NONE;\n            continue;\n        }\n\n        /* Check that ->alias is not a key. */\n        if (XkbKeyByName(keymap, alias->alias, false)) {\n            log_vrb(info->ctx, 5,\n                    \"Attempt to create alias with the name of a real key; \"\n                    \"Alias \\\"%s = %s\\\" ignored\\n\",\n                    KeyNameText(info->ctx, alias->alias),\n                    KeyNameText(info->ctx, alias->real));\n            alias->real = XKB_ATOM_NONE;\n            continue;\n        }\n\n        num_key_aliases++;\n    }\n\n    /* Copy key aliases. */\n    key_aliases = NULL;\n    if (num_key_aliases > 0) {\n         key_aliases = calloc(num_key_aliases, sizeof(*key_aliases));\n         if (!key_aliases)\n             return false;\n \n        i = 0;\n        darray_foreach(alias, info->aliases) {\n            if (alias->real != XKB_ATOM_NONE) {\n                key_aliases[i].alias = alias->alias;\n                key_aliases[i].real = alias->real;\n                i++;\n            }\n         }\n     }\n \n    keymap->num_key_aliases = num_key_aliases;\n    keymap->key_aliases = key_aliases;\n    return true;\n}\n",
    "cwe": [
      "CWE-476"
    ],
    "id": 789,
    "_valid_cwes": [
      "CWE-476"
    ]
  },
  {
    "cve_id": "CVE-2016-6561",
    "code_before_change": "smb_com_flush(smb_request_t *sr)\n{\n\tsmb_ofile_t\t*file;\n\tsmb_llist_t\t*flist;\n\tint\t\trc;\n\n\tif (smb_flush_required == 0) {\n\t\trc = smbsr_encode_empty_result(sr);\n\t\treturn ((rc == 0) ? SDRC_SUCCESS : SDRC_ERROR);\n\t}\n\n\tif (sr->smb_fid != 0xffff) {\n\t\tsmbsr_lookup_file(sr);\n\t\tif (sr->fid_ofile == NULL) {\n\t\t\tsmbsr_error(sr, NT_STATUS_INVALID_HANDLE,\n \t\t\t    ERRDOS, ERRbadfid);\n \t\t\treturn (SDRC_ERROR);\n \t\t}\n\t\tsmb_flush_file(sr, sr->fid_ofile);\n \t} else {\n \t\tflist = &sr->tid_tree->t_ofile_list;\n \t\tsmb_llist_enter(flist, RW_READER);\n \t\tfile = smb_llist_head(flist);\n \t\twhile (file) {\n \t\t\tmutex_enter(&file->f_mutex);\n\t\t\tsmb_flush_file(sr, file);\n \t\t\tmutex_exit(&file->f_mutex);\n \t\t\tfile = smb_llist_next(flist, file);\n \t\t}\n\t\tsmb_llist_exit(flist);\n\t}\n\n \trc = smbsr_encode_empty_result(sr);\n \treturn ((rc == 0) ? SDRC_SUCCESS : SDRC_ERROR);\n }\n",
    "code_after_change": "smb_com_flush(smb_request_t *sr)\n{\n\tsmb_ofile_t\t*file;\n\tsmb_llist_t\t*flist;\n\tint\t\trc;\n\n\tif (smb_flush_required == 0) {\n\t\trc = smbsr_encode_empty_result(sr);\n\t\treturn ((rc == 0) ? SDRC_SUCCESS : SDRC_ERROR);\n\t}\n\n\tif (sr->smb_fid != 0xffff) {\n\t\tsmbsr_lookup_file(sr);\n\t\tif (sr->fid_ofile == NULL) {\n\t\t\tsmbsr_error(sr, NT_STATUS_INVALID_HANDLE,\n \t\t\t    ERRDOS, ERRbadfid);\n \t\t\treturn (SDRC_ERROR);\n \t\t}\n\t\tsmb_ofile_flush(sr, sr->fid_ofile);\n \t} else {\n \t\tflist = &sr->tid_tree->t_ofile_list;\n \t\tsmb_llist_enter(flist, RW_READER);\n \t\tfile = smb_llist_head(flist);\n \t\twhile (file) {\n \t\t\tmutex_enter(&file->f_mutex);\n\t\t\tsmb_ofile_flush(sr, file);\n \t\t\tmutex_exit(&file->f_mutex);\n \t\t\tfile = smb_llist_next(flist, file);\n \t\t}\n\t\tsmb_llist_exit(flist);\n\t}\n\n \trc = smbsr_encode_empty_result(sr);\n \treturn ((rc == 0) ? SDRC_SUCCESS : SDRC_ERROR);\n }\n",
    "cwe": [
      "CWE-476"
    ],
    "id": 810,
    "_valid_cwes": [
      "CWE-476"
    ]
  },
  {
    "cve_id": "CVE-2017-6497",
    "code_before_change": "static MagickBooleanType ReadPSDChannel(Image *image,\n  const ImageInfo *image_info,const PSDInfo *psd_info,LayerInfo* layer_info,\n  const size_t channel,const PSDCompressionType compression,\n  ExceptionInfo *exception)\n{\n  Image\n    *channel_image,\n    *mask;\n\n  MagickOffsetType\n    offset;\n\n  MagickBooleanType\n    status;\n\n  channel_image=image;\n  mask=(Image *) NULL;\n  if (layer_info->channel_info[channel].type < -1)\n    {\n      const char\n        *option;\n      /*\n        Ignore mask that is not a user supplied layer mask, if the mask is\n        disabled or if the flags have unsupported values.\n      */\n      option=GetImageOption(image_info,\"psd:preserve-opacity-mask\");\n      if ((layer_info->channel_info[channel].type != -2) ||\n          (layer_info->mask.flags > 2) || ((layer_info->mask.flags & 0x02) &&\n           (IsStringTrue(option) == MagickFalse)))\n      {\n        SeekBlob(image,layer_info->channel_info[channel].size-2,SEEK_CUR);\n        return(MagickTrue);\n       }\n       mask=CloneImage(image,layer_info->mask.page.width,\n         layer_info->mask.page.height,MagickFalse,exception);\n      mask->matte=MagickFalse;\n      channel_image=mask;\n     }\n \n   offset=TellBlob(image);\n  status=MagickTrue;\n  switch(compression)\n  {\n    case Raw:\n      status=ReadPSDChannelRaw(channel_image,psd_info->channels,\n        layer_info->channel_info[channel].type,exception);\n      break;\n    case RLE:\n      {\n        MagickOffsetType\n          *sizes;\n\n        sizes=ReadPSDRLESizes(channel_image,psd_info,channel_image->rows);\n        if (sizes == (MagickOffsetType *) NULL)\n          ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n            image->filename);\n        status=ReadPSDChannelRLE(channel_image,psd_info,\n          layer_info->channel_info[channel].type,sizes,exception);\n        sizes=(MagickOffsetType *) RelinquishMagickMemory(sizes);\n      }\n      break;\n    case ZipWithPrediction:\n    case ZipWithoutPrediction:\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n      status=ReadPSDChannelZip(channel_image,layer_info->channels,\n        layer_info->channel_info[channel].type,compression,\n        layer_info->channel_info[channel].size-2,exception);\n#else\n      (void) ThrowMagickException(exception,GetMagickModule(),\n          MissingDelegateWarning,\"DelegateLibrarySupportNotBuiltIn\",\n            \"'%s' (ZLIB)\",image->filename);\n#endif\n      break;\n    default:\n      (void) ThrowMagickException(exception,GetMagickModule(),TypeWarning,\n        \"CompressionNotSupported\",\"'%.20g'\",(double) compression);\n      break;\n  }\n\n  SeekBlob(image,offset+layer_info->channel_info[channel].size-2,SEEK_SET);\n  if (status == MagickFalse)\n    {\n      if (mask != (Image *) NULL)\n        DestroyImage(mask);\n      ThrowBinaryException(CoderError,\"UnableToDecompressImage\",\n        image->filename);\n    }\n  layer_info->mask.image=mask;\n  return(status);\n}\n",
    "code_after_change": "static MagickBooleanType ReadPSDChannel(Image *image,\n  const ImageInfo *image_info,const PSDInfo *psd_info,LayerInfo* layer_info,\n  const size_t channel,const PSDCompressionType compression,\n  ExceptionInfo *exception)\n{\n  Image\n    *channel_image,\n    *mask;\n\n  MagickOffsetType\n    offset;\n\n  MagickBooleanType\n    status;\n\n  channel_image=image;\n  mask=(Image *) NULL;\n  if (layer_info->channel_info[channel].type < -1)\n    {\n      const char\n        *option;\n      /*\n        Ignore mask that is not a user supplied layer mask, if the mask is\n        disabled or if the flags have unsupported values.\n      */\n      option=GetImageOption(image_info,\"psd:preserve-opacity-mask\");\n      if ((layer_info->channel_info[channel].type != -2) ||\n          (layer_info->mask.flags > 2) || ((layer_info->mask.flags & 0x02) &&\n           (IsStringTrue(option) == MagickFalse)))\n      {\n        SeekBlob(image,layer_info->channel_info[channel].size-2,SEEK_CUR);\n        return(MagickTrue);\n       }\n       mask=CloneImage(image,layer_info->mask.page.width,\n         layer_info->mask.page.height,MagickFalse,exception);\n      if (mask != (Image *) NULL)\n        {\n          mask->matte=MagickFalse;\n          channel_image=mask;\n        }\n     }\n \n   offset=TellBlob(image);\n  status=MagickTrue;\n  switch(compression)\n  {\n    case Raw:\n      status=ReadPSDChannelRaw(channel_image,psd_info->channels,\n        layer_info->channel_info[channel].type,exception);\n      break;\n    case RLE:\n      {\n        MagickOffsetType\n          *sizes;\n\n        sizes=ReadPSDRLESizes(channel_image,psd_info,channel_image->rows);\n        if (sizes == (MagickOffsetType *) NULL)\n          ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n            image->filename);\n        status=ReadPSDChannelRLE(channel_image,psd_info,\n          layer_info->channel_info[channel].type,sizes,exception);\n        sizes=(MagickOffsetType *) RelinquishMagickMemory(sizes);\n      }\n      break;\n    case ZipWithPrediction:\n    case ZipWithoutPrediction:\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n      status=ReadPSDChannelZip(channel_image,layer_info->channels,\n        layer_info->channel_info[channel].type,compression,\n        layer_info->channel_info[channel].size-2,exception);\n#else\n      (void) ThrowMagickException(exception,GetMagickModule(),\n          MissingDelegateWarning,\"DelegateLibrarySupportNotBuiltIn\",\n            \"'%s' (ZLIB)\",image->filename);\n#endif\n      break;\n    default:\n      (void) ThrowMagickException(exception,GetMagickModule(),TypeWarning,\n        \"CompressionNotSupported\",\"'%.20g'\",(double) compression);\n      break;\n  }\n\n  SeekBlob(image,offset+layer_info->channel_info[channel].size-2,SEEK_SET);\n  if (status == MagickFalse)\n    {\n      if (mask != (Image *) NULL)\n        DestroyImage(mask);\n      ThrowBinaryException(CoderError,\"UnableToDecompressImage\",\n        image->filename);\n    }\n  layer_info->mask.image=mask;\n  return(status);\n}\n",
    "cwe": [
      "CWE-476"
    ],
    "id": 955,
    "_valid_cwes": [
      "CWE-476"
    ]
  },
  {
    "cve_id": "CVE-2016-10250",
    "code_before_change": "jp2_box_t *jp2_box_get(jas_stream_t *in)\n{\n\tjp2_box_t *box;\n\tjp2_boxinfo_t *boxinfo;\n\tjas_stream_t *tmpstream;\n\tuint_fast32_t len;\n\tuint_fast64_t extlen;\n\tbool dataflag;\n\n\tbox = 0;\n\ttmpstream = 0;\n\n \tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n \t\tgoto error;\n \t}\n \tbox->ops = &jp2_boxinfo_unk.ops;\n \tif (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {\n \t\tgoto error;\n \t}\n \tboxinfo = jp2_boxinfolookup(box->type);\n \tbox->info = boxinfo;\n\tbox->ops = &boxinfo->ops;\n \tbox->len = len;\n \tJAS_DBGLOG(10, (\n \t  \"preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\\n\",\n\t  '\"', boxinfo->name, '\"', box->type, box->len\n\t  ));\n\tif (box->len == 1) {\n\t\tif (jp2_getuint64(in, &extlen)) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (extlen > 0xffffffffUL) {\n\t\t\tjas_eprintf(\"warning: cannot handle large 64-bit box length\\n\");\n\t\t\textlen = 0xffffffffUL;\n\t\t}\n\t\tbox->len = extlen;\n\t\tbox->datalen = extlen - JP2_BOX_HDRLEN(true);\n\t} else {\n\t\tbox->datalen = box->len - JP2_BOX_HDRLEN(false);\n\t}\n\tif (box->len != 0 && box->len < 8) {\n\t\tgoto error;\n\t}\n\n\tdataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));\n\n\tif (dataflag) {\n\t\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n \t\t\tgoto error;\n \t\t}\n \t\tif (jas_stream_copy(tmpstream, in, box->datalen)) {\n\t\t\tbox->ops = &jp2_boxinfo_unk.ops;\n \t\t\tjas_eprintf(\"cannot copy box data\\n\");\n \t\t\tgoto error;\n \t\t}\n \t\tjas_stream_rewind(tmpstream);\n \n \t\tif (box->ops->getdata) {\n \t\t\tif ((*box->ops->getdata)(box, tmpstream)) {\n \t\t\t\tjas_eprintf(\"cannot parse box data\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tjas_stream_close(tmpstream);\n\t}\n\n\tif (jas_getdbglevel() >= 1) {\n\t\tjp2_box_dump(box, stderr);\n\t}\n\n\treturn box;\n\nerror:\n\tif (box) {\n\t\tjp2_box_destroy(box);\n\t}\n\tif (tmpstream) {\n\t\tjas_stream_close(tmpstream);\n\t}\n\treturn 0;\n}\n",
    "code_after_change": "jp2_box_t *jp2_box_get(jas_stream_t *in)\n{\n\tjp2_box_t *box;\n\tjp2_boxinfo_t *boxinfo;\n\tjas_stream_t *tmpstream;\n\tuint_fast32_t len;\n\tuint_fast64_t extlen;\n\tbool dataflag;\n\n\tbox = 0;\n\ttmpstream = 0;\n\n \tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n \t\tgoto error;\n \t}\n\n\t// Mark the box data as never having been constructed\n\t// so that we will not errantly attempt to destroy it later.\n \tbox->ops = &jp2_boxinfo_unk.ops;\n\n \tif (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {\n \t\tgoto error;\n \t}\n \tboxinfo = jp2_boxinfolookup(box->type);\n \tbox->info = boxinfo;\n \tbox->len = len;\n \tJAS_DBGLOG(10, (\n \t  \"preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\\n\",\n\t  '\"', boxinfo->name, '\"', box->type, box->len\n\t  ));\n\tif (box->len == 1) {\n\t\tif (jp2_getuint64(in, &extlen)) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (extlen > 0xffffffffUL) {\n\t\t\tjas_eprintf(\"warning: cannot handle large 64-bit box length\\n\");\n\t\t\textlen = 0xffffffffUL;\n\t\t}\n\t\tbox->len = extlen;\n\t\tbox->datalen = extlen - JP2_BOX_HDRLEN(true);\n\t} else {\n\t\tbox->datalen = box->len - JP2_BOX_HDRLEN(false);\n\t}\n\tif (box->len != 0 && box->len < 8) {\n\t\tgoto error;\n\t}\n\n\tdataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));\n\n\tif (dataflag) {\n\t\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n \t\t\tgoto error;\n \t\t}\n \t\tif (jas_stream_copy(tmpstream, in, box->datalen)) {\n \t\t\tjas_eprintf(\"cannot copy box data\\n\");\n \t\t\tgoto error;\n \t\t}\n \t\tjas_stream_rewind(tmpstream);\n \n\t\t// From here onwards, the box data will need to be destroyed.\n\t\t// So, initialize the box operations.\n\t\tbox->ops = &boxinfo->ops;\n\n \t\tif (box->ops->getdata) {\n \t\t\tif ((*box->ops->getdata)(box, tmpstream)) {\n \t\t\t\tjas_eprintf(\"cannot parse box data\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tjas_stream_close(tmpstream);\n\t}\n\n\tif (jas_getdbglevel() >= 1) {\n\t\tjp2_box_dump(box, stderr);\n\t}\n\n\treturn box;\n\nerror:\n\tif (box) {\n\t\tjp2_box_destroy(box);\n\t}\n\tif (tmpstream) {\n\t\tjas_stream_close(tmpstream);\n\t}\n\treturn 0;\n}\n",
    "cwe": [
      "CWE-476"
    ],
    "id": 967,
    "_valid_cwes": [
      "CWE-476"
    ]
  }
]