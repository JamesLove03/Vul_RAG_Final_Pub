[
  {
    "cve_id": "CVE-2017-9949",
    "code_before_change": "grub_ext2_read_block (grub_fshelp_node_t node, grub_disk_addr_t fileblock)\n{\n  struct grub_ext2_data *data = node->data;\n  struct grub_ext2_inode *inode = &node->inode;\n  int blknr = -1;\n  unsigned int blksz = EXT2_BLOCK_SIZE (data);\n  int log2_blksz = LOG2_EXT2_BLOCK_SIZE (data);\n\n  if (grub_le_to_cpu32(inode->flags) & EXT4_EXTENTS_FLAG)\n    {\n#ifndef _MSC_VER\n\t  char buf[EXT2_BLOCK_SIZE (data)];\n#else\n\t  char * buf = grub_malloc (EXT2_BLOCK_SIZE(data));\n#endif\n      struct grub_ext4_extent_header *leaf;\n      struct grub_ext4_extent *ext;\n      int i;\n\n      leaf = grub_ext4_find_leaf (data, buf,\n\t\t  (struct grub_ext4_extent_header *) inode->blocks.dir_blocks,\n\t\t  fileblock);\n      if (! leaf)\n        {\n          grub_error (GRUB_ERR_BAD_FS, \"invalid extent\");\n          return -1;\n        }\n\n      ext = (struct grub_ext4_extent *) (leaf + 1);\n      for (i = 0; i < grub_le_to_cpu16 (leaf->entries); i++)\n        {\n          if (fileblock < grub_le_to_cpu32 (ext[i].block))\n            break;\n        }\n\n      if (--i >= 0)\n        {\n          fileblock -= grub_le_to_cpu32 (ext[i].block);\n          if (fileblock >= grub_le_to_cpu16 (ext[i].len))\n            return 0;\n          else\n            {\n              grub_disk_addr_t start;\n\n              start = grub_le_to_cpu16 (ext[i].start_hi);\n              start = (start << 32) + grub_le_to_cpu32 (ext[i].start);\n\n              return fileblock + start;\n            }\n        }\n      else\n        {\n          grub_error (GRUB_ERR_BAD_FS, \"something wrong with extent\");\n          return -1;\n         }\n     }\n   /* Direct blocks.  */\n  if (fileblock < INDIRECT_BLOCKS)\n     blknr = grub_le_to_cpu32 (inode->blocks.dir_blocks[fileblock]);\n   /* Indirect.  */\n  else if (fileblock < INDIRECT_BLOCKS + blksz / 4)\n     {\n       grub_uint32_t *indir;\n \n      indir = grub_malloc (blksz);\n      if (! indir)\n\treturn grub_errno;\n\n      if (grub_disk_read (data->disk,\n\t\t\t  ((grub_disk_addr_t)\n\t\t\t   grub_le_to_cpu32 (inode->blocks.indir_block))\n\t\t\t  << log2_blksz,\n\t\t\t  0, blksz, indir))\n\treturn grub_errno;\n\n      blknr = grub_le_to_cpu32 (indir[fileblock - INDIRECT_BLOCKS]);\n      grub_free (indir);\n    }\n  /* Double indirect.  */\n  else if (fileblock < (grub_disk_addr_t)(INDIRECT_BLOCKS + blksz / 4) \\\n\t\t  * (grub_disk_addr_t)(blksz / 4 + 1))\n    {\n      unsigned int perblock = blksz / 4;\n      unsigned int rblock = fileblock - (INDIRECT_BLOCKS\n\t\t\t\t\t + blksz / 4);\n      grub_uint32_t *indir;\n\n      indir = grub_malloc (blksz);\n      if (! indir)\n\treturn grub_errno;\n\n      if (grub_disk_read (data->disk,\n\t\t\t  ((grub_disk_addr_t)\n\t\t\t   grub_le_to_cpu32 (inode->blocks.double_indir_block))\n\t\t\t  << log2_blksz,\n\t\t\t  0, blksz, indir))\n\treturn grub_errno;\n\n      if (grub_disk_read (data->disk,\n\t\t\t  ((grub_disk_addr_t)\n\t\t\t   grub_le_to_cpu32 (indir[rblock / perblock]))\n\t\t\t  << log2_blksz,\n\t\t\t  0, blksz, indir))\n\treturn grub_errno;\n\n      blknr = grub_le_to_cpu32 (indir[rblock % perblock]);\n            grub_free (indir);\n    }\n  /* triple indirect.  */\n  else\n    {\n      grub_error (GRUB_ERR_NOT_IMPLEMENTED_YET,\n\t\t  \"ext2fs doesn't support triple indirect blocks\");\n    }\n\n  return blknr;\n}\n",
    "code_after_change": "grub_ext2_read_block (grub_fshelp_node_t node, grub_disk_addr_t fileblock)\n{\n  struct grub_ext2_data *data = node->data;\n  struct grub_ext2_inode *inode = &node->inode;\n  int blknr = -1;\n  unsigned int blksz = EXT2_BLOCK_SIZE (data);\n  int log2_blksz = LOG2_EXT2_BLOCK_SIZE (data);\n\n  if (grub_le_to_cpu32(inode->flags) & EXT4_EXTENTS_FLAG)\n    {\n#ifndef _MSC_VER\n\t  char buf[EXT2_BLOCK_SIZE (data)];\n#else\n\t  char * buf = grub_malloc (EXT2_BLOCK_SIZE(data));\n#endif\n      struct grub_ext4_extent_header *leaf;\n      struct grub_ext4_extent *ext;\n      int i;\n\n      leaf = grub_ext4_find_leaf (data, buf,\n\t\t  (struct grub_ext4_extent_header *) inode->blocks.dir_blocks,\n\t\t  fileblock);\n      if (! leaf)\n        {\n          grub_error (GRUB_ERR_BAD_FS, \"invalid extent\");\n          return -1;\n        }\n\n      ext = (struct grub_ext4_extent *) (leaf + 1);\n      for (i = 0; i < grub_le_to_cpu16 (leaf->entries); i++)\n        {\n          if (fileblock < grub_le_to_cpu32 (ext[i].block))\n            break;\n        }\n\n      if (--i >= 0)\n        {\n          fileblock -= grub_le_to_cpu32 (ext[i].block);\n          if (fileblock >= grub_le_to_cpu16 (ext[i].len))\n            return 0;\n          else\n            {\n              grub_disk_addr_t start;\n\n              start = grub_le_to_cpu16 (ext[i].start_hi);\n              start = (start << 32) + grub_le_to_cpu32 (ext[i].start);\n\n              return fileblock + start;\n            }\n        }\n      else\n        {\n          grub_error (GRUB_ERR_BAD_FS, \"something wrong with extent\");\n          return -1;\n         }\n     }\n   /* Direct blocks.  */\n  if (fileblock < INDIRECT_BLOCKS) {\n     blknr = grub_le_to_cpu32 (inode->blocks.dir_blocks[fileblock]);\n   /* Indirect.  */\n  } else if (fileblock < INDIRECT_BLOCKS + blksz / 4)\n     {\n       grub_uint32_t *indir;\n \n      indir = grub_malloc (blksz);\n      if (! indir)\n\treturn grub_errno;\n\n      if (grub_disk_read (data->disk,\n\t\t\t  ((grub_disk_addr_t)\n\t\t\t   grub_le_to_cpu32 (inode->blocks.indir_block))\n\t\t\t  << log2_blksz,\n\t\t\t  0, blksz, indir))\n\treturn grub_errno;\n\n      blknr = grub_le_to_cpu32 (indir[fileblock - INDIRECT_BLOCKS]);\n      grub_free (indir);\n    }\n  /* Double indirect.  */\n  else if (fileblock < (grub_disk_addr_t)(INDIRECT_BLOCKS + blksz / 4) \\\n\t\t  * (grub_disk_addr_t)(blksz / 4 + 1))\n    {\n      unsigned int perblock = blksz / 4;\n      unsigned int rblock = fileblock - (INDIRECT_BLOCKS\n\t\t\t\t\t + blksz / 4);\n      grub_uint32_t *indir;\n\n      indir = grub_malloc (blksz);\n      if (! indir)\n\treturn grub_errno;\n\n      if (grub_disk_read (data->disk,\n\t\t\t  ((grub_disk_addr_t)\n\t\t\t   grub_le_to_cpu32 (inode->blocks.double_indir_block))\n\t\t\t  << log2_blksz,\n\t\t\t  0, blksz, indir))\n\treturn grub_errno;\n\n      if (grub_disk_read (data->disk,\n\t\t\t  ((grub_disk_addr_t)\n\t\t\t   grub_le_to_cpu32 (indir[rblock / perblock]))\n\t\t\t  << log2_blksz,\n\t\t\t  0, blksz, indir))\n\treturn grub_errno;\n\n      blknr = grub_le_to_cpu32 (indir[rblock % perblock]);\n            grub_free (indir);\n    }\n  /* triple indirect.  */\n  else\n    {\n      grub_error (GRUB_ERR_NOT_IMPLEMENTED_YET,\n\t\t  \"ext2fs doesn't support triple indirect blocks\");\n    }\n\n  return blknr;\n}\n",
    "cwe": [
      "CWE-787"
    ],
    "id": 244,
    "_valid_cwes": [
      "CWE-787"
    ]
  },
  {
    "cve_id": "CVE-2016-9537",
    "code_before_change": "loadImage(TIFF* in, struct image_data *image, struct dump_opts *dump, unsigned char **read_ptr)\n   {\n   uint32   i;\n   float    xres = 0.0, yres = 0.0;\n  uint16   nstrips = 0, ntiles = 0, planar = 0;\n   uint16   bps = 0, spp = 0, res_unit = 0;\n   uint16   orientation = 0;\n   uint16   input_compression = 0, input_photometric = 0;\n  uint16   subsampling_horiz, subsampling_vert;\n  uint32   width = 0, length = 0;\n  uint32   stsize = 0, tlsize = 0, buffsize = 0, scanlinesize = 0;\n  uint32   tw = 0, tl = 0;       /* Tile width and length */\n  uint32   tile_rowsize = 0;\n  unsigned char *read_buff = NULL;\n  unsigned char *new_buff  = NULL;\n  int      readunit = 0;\n  static   uint32  prev_readsize = 0;\n\n  TIFFGetFieldDefaulted(in, TIFFTAG_BITSPERSAMPLE, &bps);\n  TIFFGetFieldDefaulted(in, TIFFTAG_SAMPLESPERPIXEL, &spp);\n  TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &planar);\n  TIFFGetFieldDefaulted(in, TIFFTAG_ORIENTATION, &orientation);\n  if (! TIFFGetFieldDefaulted(in, TIFFTAG_PHOTOMETRIC, &input_photometric))\n    TIFFError(\"loadImage\",\"Image lacks Photometric interpreation tag\");\n  if (! TIFFGetField(in, TIFFTAG_IMAGEWIDTH,  &width))\n    TIFFError(\"loadimage\",\"Image lacks image width tag\");\n  if(! TIFFGetField(in, TIFFTAG_IMAGELENGTH, &length))\n    TIFFError(\"loadimage\",\"Image lacks image length tag\");\n  TIFFGetFieldDefaulted(in, TIFFTAG_XRESOLUTION, &xres);\n  TIFFGetFieldDefaulted(in, TIFFTAG_YRESOLUTION, &yres);\n  if (!TIFFGetFieldDefaulted(in, TIFFTAG_RESOLUTIONUNIT, &res_unit))\n    res_unit = RESUNIT_INCH;\n  if (!TIFFGetField(in, TIFFTAG_COMPRESSION, &input_compression))\n    input_compression = COMPRESSION_NONE;\n\n#ifdef DEBUG2\n  char compressionid[16];\n\n  switch (input_compression)\n    {\n    case COMPRESSION_NONE:\t/* 1  dump mode */\n\t strcpy (compressionid, \"None/dump\");\n         break;         \n    case COMPRESSION_CCITTRLE:\t  /* 2 CCITT modified Huffman RLE */\n\t strcpy (compressionid, \"Huffman RLE\");\n         break;         \n    case COMPRESSION_CCITTFAX3:\t  /* 3 CCITT Group 3 fax encoding */\n\t strcpy (compressionid, \"Group3 Fax\");\n         break;         \n    case COMPRESSION_CCITTFAX4:\t  /* 4 CCITT Group 4 fax encoding */\n\t strcpy (compressionid, \"Group4 Fax\");\n         break;         \n    case COMPRESSION_LZW:\t  /* 5 Lempel-Ziv  & Welch */\n\t strcpy (compressionid, \"LZW\");\n         break;         \n    case COMPRESSION_OJPEG:\t  /* 6 !6.0 JPEG */\n\t strcpy (compressionid, \"Old Jpeg\");\n         break;         \n    case COMPRESSION_JPEG:\t  /* 7 %JPEG DCT compression */\n\t strcpy (compressionid, \"New Jpeg\");\n         break;         \n    case COMPRESSION_NEXT:\t  /* 32766 NeXT 2-bit RLE */\n\t strcpy (compressionid, \"Next RLE\");\n         break;         \n    case COMPRESSION_CCITTRLEW:   /* 32771 #1 w/ word alignment */\n\t strcpy (compressionid, \"CITTRLEW\");\n         break;         \n    case COMPRESSION_PACKBITS:\t  /* 32773 Macintosh RLE */\n\t strcpy (compressionid, \"Mac Packbits\");\n         break;         \n    case COMPRESSION_THUNDERSCAN: /* 32809 ThunderScan RLE */\n\t strcpy (compressionid, \"Thunderscan\");\n         break;         \n    case COMPRESSION_IT8CTPAD:\t  /* 32895 IT8 CT w/padding */\n\t strcpy (compressionid, \"IT8 padded\");\n         break;         \n    case COMPRESSION_IT8LW:\t  /* 32896 IT8 Linework RLE */\n\t strcpy (compressionid, \"IT8 RLE\");\n         break;         \n    case COMPRESSION_IT8MP:\t  /* 32897 IT8 Monochrome picture */\n\t strcpy (compressionid, \"IT8 mono\");\n         break;         \n    case COMPRESSION_IT8BL:\t  /* 32898 IT8 Binary line art */\n\t strcpy (compressionid, \"IT8 lineart\");\n         break;         \n    case COMPRESSION_PIXARFILM:\t  /* 32908 Pixar companded 10bit LZW */\n\t strcpy (compressionid, \"Pixar 10 bit\");\n         break;         \n    case COMPRESSION_PIXARLOG:\t  /* 32909 Pixar companded 11bit ZIP */\n\t strcpy (compressionid, \"Pixar 11bit\");\n         break;         \n    case COMPRESSION_DEFLATE:\t  /* 32946 Deflate compression */\n\t strcpy (compressionid, \"Deflate\");\n         break;         \n    case COMPRESSION_ADOBE_DEFLATE: /* 8 Deflate compression */\n\t strcpy (compressionid, \"Adobe deflate\");\n         break;         \n    default:\n\t strcpy (compressionid, \"None/unknown\");\n         break;         \n    }\n  TIFFError(\"loadImage\", \"Input compression %s\", compressionid);\n#endif\n\n  scanlinesize = TIFFScanlineSize(in);\n  image->bps = bps;\n  image->spp = spp;\n  image->planar = planar;\n  image->width = width;\n  image->length = length;\n  image->xres = xres;\n  image->yres = yres;\n  image->res_unit = res_unit;\n  image->compression = input_compression;\n  image->photometric = input_photometric;\n#ifdef DEBUG2\n  char photometricid[12];\n\n  switch (input_photometric)\n    {\n    case PHOTOMETRIC_MINISWHITE:\n         strcpy (photometricid, \"MinIsWhite\");\n         break;\n    case PHOTOMETRIC_MINISBLACK:\n         strcpy (photometricid, \"MinIsBlack\");\n         break;\n    case PHOTOMETRIC_RGB:\n         strcpy (photometricid, \"RGB\");\n         break;\n    case PHOTOMETRIC_PALETTE:\n         strcpy (photometricid, \"Palette\");\n         break;\n    case PHOTOMETRIC_MASK:\n         strcpy (photometricid, \"Mask\");\n         break;\n    case PHOTOMETRIC_SEPARATED:\n         strcpy (photometricid, \"Separated\");\n         break;\n    case PHOTOMETRIC_YCBCR:\n         strcpy (photometricid, \"YCBCR\");\n         break;\n    case PHOTOMETRIC_CIELAB:\n         strcpy (photometricid, \"CIELab\");\n         break;\n    case PHOTOMETRIC_ICCLAB:\n         strcpy (photometricid, \"ICCLab\");\n         break;\n    case PHOTOMETRIC_ITULAB:\n         strcpy (photometricid, \"ITULab\");\n         break;\n    case PHOTOMETRIC_LOGL:\n         strcpy (photometricid, \"LogL\");\n         break;\n    case PHOTOMETRIC_LOGLUV:\n         strcpy (photometricid, \"LOGLuv\");\n         break;\n    default:\n         strcpy (photometricid, \"Unknown\");\n         break;\n    }\n  TIFFError(\"loadImage\", \"Input photometric interpretation %s\", photometricid);\n\n#endif\n  image->orientation = orientation;\n  switch (orientation)\n    {\n    case 0:\n    case ORIENTATION_TOPLEFT:\n         image->adjustments = 0;\n\t break;\n    case ORIENTATION_TOPRIGHT:\n         image->adjustments = MIRROR_HORIZ;\n\t break;\n    case ORIENTATION_BOTRIGHT:\n         image->adjustments = ROTATECW_180;\n\t break;\n    case ORIENTATION_BOTLEFT:\n         image->adjustments = MIRROR_VERT; \n\t break;\n    case ORIENTATION_LEFTTOP:\n         image->adjustments = MIRROR_VERT | ROTATECW_90;\n\t break;\n    case ORIENTATION_RIGHTTOP:\n         image->adjustments = ROTATECW_90;\n\t break;\n    case ORIENTATION_RIGHTBOT:\n         image->adjustments = MIRROR_VERT | ROTATECW_270;\n\t break; \n    case ORIENTATION_LEFTBOT:\n         image->adjustments = ROTATECW_270;\n\t break;\n    default:\n         image->adjustments = 0;\n         image->orientation = ORIENTATION_TOPLEFT;\n   }\n\n  if ((bps == 0) || (spp == 0))\n    {\n    TIFFError(\"loadImage\", \"Invalid samples per pixel (%d) or bits per sample (%d)\",\n\t       spp, bps);\n    return (-1);\n    }\n\n  if (TIFFIsTiled(in))\n    {\n    readunit = TILE;\n    tlsize = TIFFTileSize(in);\n    ntiles = TIFFNumberOfTiles(in);\n    TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);\n    TIFFGetField(in, TIFFTAG_TILELENGTH, &tl);\n\n    tile_rowsize  = TIFFTileRowSize(in);      \n    if (ntiles == 0 || tlsize == 0 || tile_rowsize == 0)\n    {\n\tTIFFError(\"loadImage\", \"File appears to be tiled, but the number of tiles, tile size, or tile rowsize is zero.\");\n\texit(-1);\n    }\n    buffsize = tlsize * ntiles;\n    if (tlsize != (buffsize / ntiles))\n    {\n\tTIFFError(\"loadImage\", \"Integer overflow when calculating buffer size\");\n\texit(-1);\n    }\n\n    if (buffsize < (uint32)(ntiles * tl * tile_rowsize))\n      {\n      buffsize = ntiles * tl * tile_rowsize;\n      if (ntiles != (buffsize / tl / tile_rowsize))\n      {\n\tTIFFError(\"loadImage\", \"Integer overflow when calculating buffer size\");\n\texit(-1);\n      }\n      \n#ifdef DEBUG2\n      TIFFError(\"loadImage\",\n\t        \"Tilesize %u is too small, using ntiles * tilelength * tilerowsize %lu\",\n                tlsize, (unsigned long)buffsize);\n#endif\n      }\n    \n    if (dump->infile != NULL)\n      dump_info (dump->infile, dump->format, \"\", \n                 \"Tilesize: %u, Number of Tiles: %u, Tile row size: %u\",\n                 tlsize, ntiles, tile_rowsize);\n    }\n  else\n    {\n    uint32 buffsize_check;\n    readunit = STRIP;\n    TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    stsize = TIFFStripSize(in);\n    nstrips = TIFFNumberOfStrips(in);\n    if (nstrips == 0 || stsize == 0)\n    {\n\tTIFFError(\"loadImage\", \"File appears to be striped, but the number of stipes or stripe size is zero.\");\n\texit(-1);\n    }\n\n    buffsize = stsize * nstrips;\n    if (stsize != (buffsize / nstrips))\n    {\n\tTIFFError(\"loadImage\", \"Integer overflow when calculating buffer size\");\n\texit(-1);\n    }\n    buffsize_check = ((length * width * spp * bps) + 7);\n    if (length != ((buffsize_check - 7) / width / spp / bps))\n    {\n\tTIFFError(\"loadImage\", \"Integer overflow detected.\");\n\texit(-1);\n    }\n    if (buffsize < (uint32) (((length * width * spp * bps) + 7) / 8))\n      {\n      buffsize =  ((length * width * spp * bps) + 7) / 8;\n#ifdef DEBUG2\n      TIFFError(\"loadImage\",\n\t        \"Stripsize %u is too small, using imagelength * width * spp * bps / 8 = %lu\",\n                stsize, (unsigned long)buffsize);\n#endif\n      }\n    \n    if (dump->infile != NULL)\n      dump_info (dump->infile, dump->format, \"\",\n                 \"Stripsize: %u, Number of Strips: %u, Rows per Strip: %u, Scanline size: %u\",\n\t\t stsize, nstrips, rowsperstrip, scanlinesize);\n    }\n  \n  if (input_compression == COMPRESSION_JPEG)\n    {  /* Force conversion to RGB */\n    jpegcolormode = JPEGCOLORMODE_RGB;\n    TIFFSetField(in, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n    }\n  /* The clause up to the read statement is taken from Tom Lane's tiffcp patch */\n  else \n    {   /* Otherwise, can't handle subsampled input */\n    if (input_photometric == PHOTOMETRIC_YCBCR)\n      {\n      TIFFGetFieldDefaulted(in, TIFFTAG_YCBCRSUBSAMPLING,\n \t\t           &subsampling_horiz, &subsampling_vert);\n      if (subsampling_horiz != 1 || subsampling_vert != 1)\n        {\n\tTIFFError(\"loadImage\", \n\t\t\"Can't copy/convert subsampled image with subsampling %d horiz %d vert\",\n                subsampling_horiz, subsampling_vert);\n        return (-1);\n        }\n\t}\n    }\n \n  read_buff = *read_ptr;\n   /* +3 : add a few guard bytes since reverseSamples16bits() can read a bit */\n   /* outside buffer */\n   if (!read_buff)\n     read_buff = (unsigned char *)_TIFFmalloc(buffsize+3);\n   else\n     {\n     if (prev_readsize < buffsize)\n       {\n       new_buff = _TIFFrealloc(read_buff, buffsize+3);\n       if (!new_buff)\n         {\n\tfree (read_buff);\n        read_buff = (unsigned char *)_TIFFmalloc(buffsize+3);\n        }\n      else\n        read_buff = new_buff;\n      }\n    }\n  if (!read_buff)\n    {\n    TIFFError(\"loadImage\", \"Unable to allocate/reallocate read buffer\");\n    return (-1);\n    }\n\n  read_buff[buffsize] = 0;\n  read_buff[buffsize+1] = 0;\n  read_buff[buffsize+2] = 0;\n\n  prev_readsize = buffsize;\n  *read_ptr = read_buff;\n\n  /* N.B. The read functions used copy separate plane data into a buffer as interleaved\n   * samples rather than separate planes so the same logic works to extract regions\n   * regardless of the way the data are organized in the input file.\n   */\n  switch (readunit) {\n    case STRIP:\n         if (planar == PLANARCONFIG_CONTIG)\n           {\n\t     if (!(readContigStripsIntoBuffer(in, read_buff)))\n\t     {\n\t     TIFFError(\"loadImage\", \"Unable to read contiguous strips into buffer\");\n\t     return (-1);\n             }\n           }\n         else\n           {\n\t   if (!(readSeparateStripsIntoBuffer(in, read_buff, length, width, spp, dump)))\n\t     {\n\t     TIFFError(\"loadImage\", \"Unable to read separate strips into buffer\");\n\t     return (-1);\n             }\n           }\n         break;\n\n    case TILE:\n         if (planar == PLANARCONFIG_CONTIG)\n           {\n\t   if (!(readContigTilesIntoBuffer(in, read_buff, length, width, tw, tl, spp, bps)))\n\t     {\n\t     TIFFError(\"loadImage\", \"Unable to read contiguous tiles into buffer\");\n\t     return (-1);\n             }\n           }\n         else\n           {\n\t   if (!(readSeparateTilesIntoBuffer(in, read_buff, length, width, tw, tl, spp, bps)))\n\t     {\n\t     TIFFError(\"loadImage\", \"Unable to read separate tiles into buffer\");\n\t     return (-1);\n             }\n           }\n         break;\n    default: TIFFError(\"loadImage\", \"Unsupported image file format\");\n          return (-1);\n          break;\n    }\n  if ((dump->infile != NULL) && (dump->level == 2))\n    {\n    dump_info  (dump->infile, dump->format, \"loadImage\", \n                \"Image width %d, length %d, Raw image data, %4d bytes\",\n                width, length,  buffsize);\n    dump_info  (dump->infile, dump->format, \"\", \n                \"Bits per sample %d, Samples per pixel %d\", bps, spp);\n\n    for (i = 0; i < length; i++)\n      dump_buffer(dump->infile, dump->format, 1, scanlinesize, \n                  i, read_buff + (i * scanlinesize));\n    }\n  return (0);\n  }   /* end loadImage */\n",
    "code_after_change": "loadImage(TIFF* in, struct image_data *image, struct dump_opts *dump, unsigned char **read_ptr)\n   {\n   uint32   i;\n   float    xres = 0.0, yres = 0.0;\n  uint32   nstrips = 0, ntiles = 0;\n  uint16   planar = 0;\n   uint16   bps = 0, spp = 0, res_unit = 0;\n   uint16   orientation = 0;\n   uint16   input_compression = 0, input_photometric = 0;\n  uint16   subsampling_horiz, subsampling_vert;\n  uint32   width = 0, length = 0;\n  uint32   stsize = 0, tlsize = 0, buffsize = 0, scanlinesize = 0;\n  uint32   tw = 0, tl = 0;       /* Tile width and length */\n  uint32   tile_rowsize = 0;\n  unsigned char *read_buff = NULL;\n  unsigned char *new_buff  = NULL;\n  int      readunit = 0;\n  static   uint32  prev_readsize = 0;\n\n  TIFFGetFieldDefaulted(in, TIFFTAG_BITSPERSAMPLE, &bps);\n  TIFFGetFieldDefaulted(in, TIFFTAG_SAMPLESPERPIXEL, &spp);\n  TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &planar);\n  TIFFGetFieldDefaulted(in, TIFFTAG_ORIENTATION, &orientation);\n  if (! TIFFGetFieldDefaulted(in, TIFFTAG_PHOTOMETRIC, &input_photometric))\n    TIFFError(\"loadImage\",\"Image lacks Photometric interpreation tag\");\n  if (! TIFFGetField(in, TIFFTAG_IMAGEWIDTH,  &width))\n    TIFFError(\"loadimage\",\"Image lacks image width tag\");\n  if(! TIFFGetField(in, TIFFTAG_IMAGELENGTH, &length))\n    TIFFError(\"loadimage\",\"Image lacks image length tag\");\n  TIFFGetFieldDefaulted(in, TIFFTAG_XRESOLUTION, &xres);\n  TIFFGetFieldDefaulted(in, TIFFTAG_YRESOLUTION, &yres);\n  if (!TIFFGetFieldDefaulted(in, TIFFTAG_RESOLUTIONUNIT, &res_unit))\n    res_unit = RESUNIT_INCH;\n  if (!TIFFGetField(in, TIFFTAG_COMPRESSION, &input_compression))\n    input_compression = COMPRESSION_NONE;\n\n#ifdef DEBUG2\n  char compressionid[16];\n\n  switch (input_compression)\n    {\n    case COMPRESSION_NONE:\t/* 1  dump mode */\n\t strcpy (compressionid, \"None/dump\");\n         break;         \n    case COMPRESSION_CCITTRLE:\t  /* 2 CCITT modified Huffman RLE */\n\t strcpy (compressionid, \"Huffman RLE\");\n         break;         \n    case COMPRESSION_CCITTFAX3:\t  /* 3 CCITT Group 3 fax encoding */\n\t strcpy (compressionid, \"Group3 Fax\");\n         break;         \n    case COMPRESSION_CCITTFAX4:\t  /* 4 CCITT Group 4 fax encoding */\n\t strcpy (compressionid, \"Group4 Fax\");\n         break;         \n    case COMPRESSION_LZW:\t  /* 5 Lempel-Ziv  & Welch */\n\t strcpy (compressionid, \"LZW\");\n         break;         \n    case COMPRESSION_OJPEG:\t  /* 6 !6.0 JPEG */\n\t strcpy (compressionid, \"Old Jpeg\");\n         break;         \n    case COMPRESSION_JPEG:\t  /* 7 %JPEG DCT compression */\n\t strcpy (compressionid, \"New Jpeg\");\n         break;         \n    case COMPRESSION_NEXT:\t  /* 32766 NeXT 2-bit RLE */\n\t strcpy (compressionid, \"Next RLE\");\n         break;         \n    case COMPRESSION_CCITTRLEW:   /* 32771 #1 w/ word alignment */\n\t strcpy (compressionid, \"CITTRLEW\");\n         break;         \n    case COMPRESSION_PACKBITS:\t  /* 32773 Macintosh RLE */\n\t strcpy (compressionid, \"Mac Packbits\");\n         break;         \n    case COMPRESSION_THUNDERSCAN: /* 32809 ThunderScan RLE */\n\t strcpy (compressionid, \"Thunderscan\");\n         break;         \n    case COMPRESSION_IT8CTPAD:\t  /* 32895 IT8 CT w/padding */\n\t strcpy (compressionid, \"IT8 padded\");\n         break;         \n    case COMPRESSION_IT8LW:\t  /* 32896 IT8 Linework RLE */\n\t strcpy (compressionid, \"IT8 RLE\");\n         break;         \n    case COMPRESSION_IT8MP:\t  /* 32897 IT8 Monochrome picture */\n\t strcpy (compressionid, \"IT8 mono\");\n         break;         \n    case COMPRESSION_IT8BL:\t  /* 32898 IT8 Binary line art */\n\t strcpy (compressionid, \"IT8 lineart\");\n         break;         \n    case COMPRESSION_PIXARFILM:\t  /* 32908 Pixar companded 10bit LZW */\n\t strcpy (compressionid, \"Pixar 10 bit\");\n         break;         \n    case COMPRESSION_PIXARLOG:\t  /* 32909 Pixar companded 11bit ZIP */\n\t strcpy (compressionid, \"Pixar 11bit\");\n         break;         \n    case COMPRESSION_DEFLATE:\t  /* 32946 Deflate compression */\n\t strcpy (compressionid, \"Deflate\");\n         break;         \n    case COMPRESSION_ADOBE_DEFLATE: /* 8 Deflate compression */\n\t strcpy (compressionid, \"Adobe deflate\");\n         break;         \n    default:\n\t strcpy (compressionid, \"None/unknown\");\n         break;         \n    }\n  TIFFError(\"loadImage\", \"Input compression %s\", compressionid);\n#endif\n\n  scanlinesize = TIFFScanlineSize(in);\n  image->bps = bps;\n  image->spp = spp;\n  image->planar = planar;\n  image->width = width;\n  image->length = length;\n  image->xres = xres;\n  image->yres = yres;\n  image->res_unit = res_unit;\n  image->compression = input_compression;\n  image->photometric = input_photometric;\n#ifdef DEBUG2\n  char photometricid[12];\n\n  switch (input_photometric)\n    {\n    case PHOTOMETRIC_MINISWHITE:\n         strcpy (photometricid, \"MinIsWhite\");\n         break;\n    case PHOTOMETRIC_MINISBLACK:\n         strcpy (photometricid, \"MinIsBlack\");\n         break;\n    case PHOTOMETRIC_RGB:\n         strcpy (photometricid, \"RGB\");\n         break;\n    case PHOTOMETRIC_PALETTE:\n         strcpy (photometricid, \"Palette\");\n         break;\n    case PHOTOMETRIC_MASK:\n         strcpy (photometricid, \"Mask\");\n         break;\n    case PHOTOMETRIC_SEPARATED:\n         strcpy (photometricid, \"Separated\");\n         break;\n    case PHOTOMETRIC_YCBCR:\n         strcpy (photometricid, \"YCBCR\");\n         break;\n    case PHOTOMETRIC_CIELAB:\n         strcpy (photometricid, \"CIELab\");\n         break;\n    case PHOTOMETRIC_ICCLAB:\n         strcpy (photometricid, \"ICCLab\");\n         break;\n    case PHOTOMETRIC_ITULAB:\n         strcpy (photometricid, \"ITULab\");\n         break;\n    case PHOTOMETRIC_LOGL:\n         strcpy (photometricid, \"LogL\");\n         break;\n    case PHOTOMETRIC_LOGLUV:\n         strcpy (photometricid, \"LOGLuv\");\n         break;\n    default:\n         strcpy (photometricid, \"Unknown\");\n         break;\n    }\n  TIFFError(\"loadImage\", \"Input photometric interpretation %s\", photometricid);\n\n#endif\n  image->orientation = orientation;\n  switch (orientation)\n    {\n    case 0:\n    case ORIENTATION_TOPLEFT:\n         image->adjustments = 0;\n\t break;\n    case ORIENTATION_TOPRIGHT:\n         image->adjustments = MIRROR_HORIZ;\n\t break;\n    case ORIENTATION_BOTRIGHT:\n         image->adjustments = ROTATECW_180;\n\t break;\n    case ORIENTATION_BOTLEFT:\n         image->adjustments = MIRROR_VERT; \n\t break;\n    case ORIENTATION_LEFTTOP:\n         image->adjustments = MIRROR_VERT | ROTATECW_90;\n\t break;\n    case ORIENTATION_RIGHTTOP:\n         image->adjustments = ROTATECW_90;\n\t break;\n    case ORIENTATION_RIGHTBOT:\n         image->adjustments = MIRROR_VERT | ROTATECW_270;\n\t break; \n    case ORIENTATION_LEFTBOT:\n         image->adjustments = ROTATECW_270;\n\t break;\n    default:\n         image->adjustments = 0;\n         image->orientation = ORIENTATION_TOPLEFT;\n   }\n\n  if ((bps == 0) || (spp == 0))\n    {\n    TIFFError(\"loadImage\", \"Invalid samples per pixel (%d) or bits per sample (%d)\",\n\t       spp, bps);\n    return (-1);\n    }\n\n  if (TIFFIsTiled(in))\n    {\n    readunit = TILE;\n    tlsize = TIFFTileSize(in);\n    ntiles = TIFFNumberOfTiles(in);\n    TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);\n    TIFFGetField(in, TIFFTAG_TILELENGTH, &tl);\n\n    tile_rowsize  = TIFFTileRowSize(in);      \n    if (ntiles == 0 || tlsize == 0 || tile_rowsize == 0)\n    {\n\tTIFFError(\"loadImage\", \"File appears to be tiled, but the number of tiles, tile size, or tile rowsize is zero.\");\n\texit(-1);\n    }\n    buffsize = tlsize * ntiles;\n    if (tlsize != (buffsize / ntiles))\n    {\n\tTIFFError(\"loadImage\", \"Integer overflow when calculating buffer size\");\n\texit(-1);\n    }\n\n    if (buffsize < (uint32)(ntiles * tl * tile_rowsize))\n      {\n      buffsize = ntiles * tl * tile_rowsize;\n      if (ntiles != (buffsize / tl / tile_rowsize))\n      {\n\tTIFFError(\"loadImage\", \"Integer overflow when calculating buffer size\");\n\texit(-1);\n      }\n      \n#ifdef DEBUG2\n      TIFFError(\"loadImage\",\n\t        \"Tilesize %u is too small, using ntiles * tilelength * tilerowsize %lu\",\n                tlsize, (unsigned long)buffsize);\n#endif\n      }\n    \n    if (dump->infile != NULL)\n      dump_info (dump->infile, dump->format, \"\", \n                 \"Tilesize: %u, Number of Tiles: %u, Tile row size: %u\",\n                 tlsize, ntiles, tile_rowsize);\n    }\n  else\n    {\n    uint32 buffsize_check;\n    readunit = STRIP;\n    TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    stsize = TIFFStripSize(in);\n    nstrips = TIFFNumberOfStrips(in);\n    if (nstrips == 0 || stsize == 0)\n    {\n\tTIFFError(\"loadImage\", \"File appears to be striped, but the number of stipes or stripe size is zero.\");\n\texit(-1);\n    }\n\n    buffsize = stsize * nstrips;\n    if (stsize != (buffsize / nstrips))\n    {\n\tTIFFError(\"loadImage\", \"Integer overflow when calculating buffer size\");\n\texit(-1);\n    }\n    buffsize_check = ((length * width * spp * bps) + 7);\n    if (length != ((buffsize_check - 7) / width / spp / bps))\n    {\n\tTIFFError(\"loadImage\", \"Integer overflow detected.\");\n\texit(-1);\n    }\n    if (buffsize < (uint32) (((length * width * spp * bps) + 7) / 8))\n      {\n      buffsize =  ((length * width * spp * bps) + 7) / 8;\n#ifdef DEBUG2\n      TIFFError(\"loadImage\",\n\t        \"Stripsize %u is too small, using imagelength * width * spp * bps / 8 = %lu\",\n                stsize, (unsigned long)buffsize);\n#endif\n      }\n    \n    if (dump->infile != NULL)\n      dump_info (dump->infile, dump->format, \"\",\n                 \"Stripsize: %u, Number of Strips: %u, Rows per Strip: %u, Scanline size: %u\",\n\t\t stsize, nstrips, rowsperstrip, scanlinesize);\n    }\n  \n  if (input_compression == COMPRESSION_JPEG)\n    {  /* Force conversion to RGB */\n    jpegcolormode = JPEGCOLORMODE_RGB;\n    TIFFSetField(in, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n    }\n  /* The clause up to the read statement is taken from Tom Lane's tiffcp patch */\n  else \n    {   /* Otherwise, can't handle subsampled input */\n    if (input_photometric == PHOTOMETRIC_YCBCR)\n      {\n      TIFFGetFieldDefaulted(in, TIFFTAG_YCBCRSUBSAMPLING,\n \t\t           &subsampling_horiz, &subsampling_vert);\n      if (subsampling_horiz != 1 || subsampling_vert != 1)\n        {\n\tTIFFError(\"loadImage\", \n\t\t\"Can't copy/convert subsampled image with subsampling %d horiz %d vert\",\n                subsampling_horiz, subsampling_vert);\n        return (-1);\n        }\n\t}\n    }\n \n  read_buff = *read_ptr;\n   /* +3 : add a few guard bytes since reverseSamples16bits() can read a bit */\n   /* outside buffer */\n   if (!read_buff)\n  {\n    if( buffsize > 0xFFFFFFFFU - 3 )\n    {\n        TIFFError(\"loadImage\", \"Unable to allocate/reallocate read buffer\");\n        return (-1);\n    }\n     read_buff = (unsigned char *)_TIFFmalloc(buffsize+3);\n  }\n   else\n     {\n     if (prev_readsize < buffsize)\n    {\n      if( buffsize > 0xFFFFFFFFU - 3 )\n       {\n          TIFFError(\"loadImage\", \"Unable to allocate/reallocate read buffer\");\n          return (-1);\n      }\n       new_buff = _TIFFrealloc(read_buff, buffsize+3);\n       if (!new_buff)\n         {\n\tfree (read_buff);\n        read_buff = (unsigned char *)_TIFFmalloc(buffsize+3);\n        }\n      else\n        read_buff = new_buff;\n      }\n    }\n  if (!read_buff)\n    {\n    TIFFError(\"loadImage\", \"Unable to allocate/reallocate read buffer\");\n    return (-1);\n    }\n\n  read_buff[buffsize] = 0;\n  read_buff[buffsize+1] = 0;\n  read_buff[buffsize+2] = 0;\n\n  prev_readsize = buffsize;\n  *read_ptr = read_buff;\n\n  /* N.B. The read functions used copy separate plane data into a buffer as interleaved\n   * samples rather than separate planes so the same logic works to extract regions\n   * regardless of the way the data are organized in the input file.\n   */\n  switch (readunit) {\n    case STRIP:\n         if (planar == PLANARCONFIG_CONTIG)\n           {\n\t     if (!(readContigStripsIntoBuffer(in, read_buff)))\n\t     {\n\t     TIFFError(\"loadImage\", \"Unable to read contiguous strips into buffer\");\n\t     return (-1);\n             }\n           }\n         else\n           {\n\t   if (!(readSeparateStripsIntoBuffer(in, read_buff, length, width, spp, dump)))\n\t     {\n\t     TIFFError(\"loadImage\", \"Unable to read separate strips into buffer\");\n\t     return (-1);\n             }\n           }\n         break;\n\n    case TILE:\n         if (planar == PLANARCONFIG_CONTIG)\n           {\n\t   if (!(readContigTilesIntoBuffer(in, read_buff, length, width, tw, tl, spp, bps)))\n\t     {\n\t     TIFFError(\"loadImage\", \"Unable to read contiguous tiles into buffer\");\n\t     return (-1);\n             }\n           }\n         else\n           {\n\t   if (!(readSeparateTilesIntoBuffer(in, read_buff, length, width, tw, tl, spp, bps)))\n\t     {\n\t     TIFFError(\"loadImage\", \"Unable to read separate tiles into buffer\");\n\t     return (-1);\n             }\n           }\n         break;\n    default: TIFFError(\"loadImage\", \"Unsupported image file format\");\n          return (-1);\n          break;\n    }\n  if ((dump->infile != NULL) && (dump->level == 2))\n    {\n    dump_info  (dump->infile, dump->format, \"loadImage\", \n                \"Image width %d, length %d, Raw image data, %4d bytes\",\n                width, length,  buffsize);\n    dump_info  (dump->infile, dump->format, \"\", \n                \"Bits per sample %d, Samples per pixel %d\", bps, spp);\n\n    for (i = 0; i < length; i++)\n      dump_buffer(dump->infile, dump->format, 1, scanlinesize, \n                  i, read_buff + (i * scanlinesize));\n    }\n  return (0);\n  }   /* end loadImage */\n",
    "cwe": [
      "CWE-787"
    ],
    "id": 286,
    "_valid_cwes": [
      "CWE-787"
    ]
  },
  {
    "cve_id": "CVE-2017-5130",
    "code_before_change": " bool XmlReader::Load(const std::string& input) {\n   const int kParseOptions = XML_PARSE_RECOVER |  // recover on errors\n                            XML_PARSE_NONET |    // forbid network access\n                            XML_PARSE_NOXXE;     // no external entities\n   reader_ = xmlReaderForMemory(input.data(), static_cast<int>(input.size()),\n                               NULL, NULL, kParseOptions);\n  return reader_ != NULL;\n}\n",
    "code_after_change": " bool XmlReader::Load(const std::string& input) {\n   const int kParseOptions = XML_PARSE_RECOVER |  // recover on errors\n                             XML_PARSE_NONET;    // forbid network access\n   reader_ = xmlReaderForMemory(input.data(), static_cast<int>(input.size()),\n                               NULL, NULL, kParseOptions);\n  return reader_ != NULL;\n}\n",
    "cwe": [
      "CWE-787"
    ],
    "id": 305,
    "_valid_cwes": [
      "CWE-787"
    ]
  },
  {
    "cve_id": "CVE-2016-7126",
    "code_before_change": "PHP_MINIT_FUNCTION(gd)\n{\n\tle_gd = zend_register_list_destructors_ex(php_free_gd_image, NULL, \"gd\", module_number);\n\tle_gd_font = zend_register_list_destructors_ex(php_free_gd_font, NULL, \"gd font\", module_number);\n\n#if HAVE_GD_BUNDLED && HAVE_LIBFREETYPE\n\tgdFontCacheMutexSetup();\n#endif\n#if HAVE_LIBT1\n\tT1_SetBitmapPad(8);\n\tT1_InitLib(NO_LOGFILE | IGNORE_CONFIGFILE | IGNORE_FONTDATABASE);\n\tT1_SetLogLevel(T1LOG_DEBUG);\n\tle_ps_font = zend_register_list_destructors_ex(php_free_ps_font, NULL, \"gd PS font\", module_number);\n\tle_ps_enc = zend_register_list_destructors_ex(php_free_ps_enc, NULL, \"gd PS encoding\", module_number);\n#endif\n#ifndef HAVE_GD_BUNDLED\n\tgdSetErrorMethod(php_gd_error_method);\n#endif\n\tREGISTER_INI_ENTRIES();\n\n\tREGISTER_LONG_CONSTANT(\"IMG_GIF\", 1, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_JPG\", 2, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_JPEG\", 2, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_PNG\", 4, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_WBMP\", 8, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_XPM\", 16, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_WEBP\", 32, CONST_CS | CONST_PERSISTENT);\n\n\t/* special colours for gd */\n\tREGISTER_LONG_CONSTANT(\"IMG_COLOR_TILED\", gdTiled, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_COLOR_STYLED\", gdStyled, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_COLOR_BRUSHED\", gdBrushed, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_COLOR_STYLEDBRUSHED\", gdStyledBrushed, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_COLOR_TRANSPARENT\", gdTransparent, CONST_CS | CONST_PERSISTENT);\n\n\t/* for imagefilledarc */\n\tREGISTER_LONG_CONSTANT(\"IMG_ARC_ROUNDED\", gdArc, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_ARC_PIE\", gdPie, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_ARC_CHORD\", gdChord, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_ARC_NOFILL\", gdNoFill, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_ARC_EDGED\", gdEdged, CONST_CS | CONST_PERSISTENT);\n\n    /* GD2 image format types */\n\tREGISTER_LONG_CONSTANT(\"IMG_GD2_RAW\", GD2_FMT_RAW, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_GD2_COMPRESSED\", GD2_FMT_COMPRESSED, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_FLIP_HORIZONTAL\", GD_FLIP_HORINZONTAL, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_FLIP_VERTICAL\", GD_FLIP_VERTICAL, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_FLIP_BOTH\", GD_FLIP_BOTH, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_EFFECT_REPLACE\", gdEffectReplace, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_EFFECT_ALPHABLEND\", gdEffectAlphaBlend, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_EFFECT_NORMAL\", gdEffectNormal, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_EFFECT_OVERLAY\", gdEffectOverlay, CONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"IMG_CROP_DEFAULT\", GD_CROP_DEFAULT, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_CROP_TRANSPARENT\", GD_CROP_TRANSPARENT, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_CROP_BLACK\", GD_CROP_BLACK, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_CROP_WHITE\", GD_CROP_WHITE, CONST_CS | CONST_PERSISTENT);\n \tREGISTER_LONG_CONSTANT(\"IMG_CROP_SIDES\", GD_CROP_SIDES, CONST_CS | CONST_PERSISTENT);\n \tREGISTER_LONG_CONSTANT(\"IMG_CROP_THRESHOLD\", GD_CROP_THRESHOLD, CONST_CS | CONST_PERSISTENT);\n \n \tREGISTER_LONG_CONSTANT(\"IMG_BELL\", GD_BELL, CONST_CS | CONST_PERSISTENT);\n \tREGISTER_LONG_CONSTANT(\"IMG_BESSEL\", GD_BESSEL, CONST_CS | CONST_PERSISTENT);\n \tREGISTER_LONG_CONSTANT(\"IMG_BILINEAR_FIXED\", GD_BILINEAR_FIXED, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_BICUBIC\", GD_BICUBIC, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_BICUBIC_FIXED\", GD_BICUBIC_FIXED, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_BLACKMAN\", GD_BLACKMAN, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_BOX\", GD_BOX, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_BSPLINE\", GD_BSPLINE, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_CATMULLROM\", GD_CATMULLROM, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_GAUSSIAN\", GD_GAUSSIAN, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_GENERALIZED_CUBIC\", GD_GENERALIZED_CUBIC, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_HERMITE\", GD_HERMITE, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_HAMMING\", GD_HAMMING, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_HANNING\", GD_HANNING, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_MITCHELL\", GD_MITCHELL, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_POWER\", GD_POWER, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_QUADRATIC\", GD_QUADRATIC, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_SINC\", GD_SINC, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_NEAREST_NEIGHBOUR\", GD_NEAREST_NEIGHBOUR, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_WEIGHTED4\", GD_WEIGHTED4, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_TRIANGLE\", GD_TRIANGLE, CONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"IMG_AFFINE_TRANSLATE\", GD_AFFINE_TRANSLATE, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_AFFINE_SCALE\", GD_AFFINE_SCALE, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_AFFINE_ROTATE\", GD_AFFINE_ROTATE, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_AFFINE_SHEAR_HORIZONTAL\", GD_AFFINE_SHEAR_HORIZONTAL, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_AFFINE_SHEAR_VERTICAL\", GD_AFFINE_SHEAR_VERTICAL, CONST_CS | CONST_PERSISTENT);\n\n#if defined(HAVE_GD_BUNDLED)\n\tREGISTER_LONG_CONSTANT(\"GD_BUNDLED\", 1, CONST_CS | CONST_PERSISTENT);\n#else\n\tREGISTER_LONG_CONSTANT(\"GD_BUNDLED\", 0, CONST_CS | CONST_PERSISTENT);\n#endif\n\n\t/* Section Filters */\n\tREGISTER_LONG_CONSTANT(\"IMG_FILTER_NEGATE\", IMAGE_FILTER_NEGATE, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_FILTER_GRAYSCALE\", IMAGE_FILTER_GRAYSCALE, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_FILTER_BRIGHTNESS\", IMAGE_FILTER_BRIGHTNESS, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_FILTER_CONTRAST\", IMAGE_FILTER_CONTRAST, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_FILTER_COLORIZE\", IMAGE_FILTER_COLORIZE, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_FILTER_EDGEDETECT\", IMAGE_FILTER_EDGEDETECT, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_FILTER_GAUSSIAN_BLUR\", IMAGE_FILTER_GAUSSIAN_BLUR, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_FILTER_SELECTIVE_BLUR\", IMAGE_FILTER_SELECTIVE_BLUR, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_FILTER_EMBOSS\", IMAGE_FILTER_EMBOSS, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_FILTER_MEAN_REMOVAL\", IMAGE_FILTER_MEAN_REMOVAL, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_FILTER_SMOOTH\", IMAGE_FILTER_SMOOTH, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_FILTER_PIXELATE\", IMAGE_FILTER_PIXELATE, CONST_CS | CONST_PERSISTENT);\n\t/* End Section Filters */\n\n#ifdef GD_VERSION_STRING\n\tREGISTER_STRING_CONSTANT(\"GD_VERSION\", GD_VERSION_STRING, CONST_CS | CONST_PERSISTENT);\n#endif\n\n#if defined(GD_MAJOR_VERSION) && defined(GD_MINOR_VERSION) && defined(GD_RELEASE_VERSION) && defined(GD_EXTRA_VERSION)\n\tREGISTER_LONG_CONSTANT(\"GD_MAJOR_VERSION\", GD_MAJOR_VERSION, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"GD_MINOR_VERSION\", GD_MINOR_VERSION, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"GD_RELEASE_VERSION\", GD_RELEASE_VERSION, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_STRING_CONSTANT(\"GD_EXTRA_VERSION\", GD_EXTRA_VERSION, CONST_CS | CONST_PERSISTENT);\n#endif\n\n\n#ifdef HAVE_GD_PNG\n\n\t/*\n\t * cannot include #include \"png.h\"\n\t * /usr/include/pngconf.h:310:2: error: #error png.h already includes setjmp.h with some additional fixup.\n\t * as error, use the values for now...\n\t */\n\tREGISTER_LONG_CONSTANT(\"PNG_NO_FILTER\",\t    0x00, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"PNG_FILTER_NONE\",   0x08, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"PNG_FILTER_SUB\",    0x10, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"PNG_FILTER_UP\",     0x20, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"PNG_FILTER_AVG\",    0x40, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"PNG_FILTER_PAETH\",  0x80, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"PNG_ALL_FILTERS\",   0x08 | 0x10 | 0x20 | 0x40 | 0x80, CONST_CS | CONST_PERSISTENT);\n#endif\n\n\treturn SUCCESS;\n}\n",
    "code_after_change": "PHP_MINIT_FUNCTION(gd)\n{\n\tle_gd = zend_register_list_destructors_ex(php_free_gd_image, NULL, \"gd\", module_number);\n\tle_gd_font = zend_register_list_destructors_ex(php_free_gd_font, NULL, \"gd font\", module_number);\n\n#if HAVE_GD_BUNDLED && HAVE_LIBFREETYPE\n\tgdFontCacheMutexSetup();\n#endif\n#if HAVE_LIBT1\n\tT1_SetBitmapPad(8);\n\tT1_InitLib(NO_LOGFILE | IGNORE_CONFIGFILE | IGNORE_FONTDATABASE);\n\tT1_SetLogLevel(T1LOG_DEBUG);\n\tle_ps_font = zend_register_list_destructors_ex(php_free_ps_font, NULL, \"gd PS font\", module_number);\n\tle_ps_enc = zend_register_list_destructors_ex(php_free_ps_enc, NULL, \"gd PS encoding\", module_number);\n#endif\n#ifndef HAVE_GD_BUNDLED\n\tgdSetErrorMethod(php_gd_error_method);\n#endif\n\tREGISTER_INI_ENTRIES();\n\n\tREGISTER_LONG_CONSTANT(\"IMG_GIF\", 1, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_JPG\", 2, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_JPEG\", 2, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_PNG\", 4, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_WBMP\", 8, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_XPM\", 16, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_WEBP\", 32, CONST_CS | CONST_PERSISTENT);\n\n\t/* special colours for gd */\n\tREGISTER_LONG_CONSTANT(\"IMG_COLOR_TILED\", gdTiled, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_COLOR_STYLED\", gdStyled, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_COLOR_BRUSHED\", gdBrushed, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_COLOR_STYLEDBRUSHED\", gdStyledBrushed, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_COLOR_TRANSPARENT\", gdTransparent, CONST_CS | CONST_PERSISTENT);\n\n\t/* for imagefilledarc */\n\tREGISTER_LONG_CONSTANT(\"IMG_ARC_ROUNDED\", gdArc, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_ARC_PIE\", gdPie, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_ARC_CHORD\", gdChord, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_ARC_NOFILL\", gdNoFill, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_ARC_EDGED\", gdEdged, CONST_CS | CONST_PERSISTENT);\n\n    /* GD2 image format types */\n\tREGISTER_LONG_CONSTANT(\"IMG_GD2_RAW\", GD2_FMT_RAW, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_GD2_COMPRESSED\", GD2_FMT_COMPRESSED, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_FLIP_HORIZONTAL\", GD_FLIP_HORINZONTAL, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_FLIP_VERTICAL\", GD_FLIP_VERTICAL, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_FLIP_BOTH\", GD_FLIP_BOTH, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_EFFECT_REPLACE\", gdEffectReplace, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_EFFECT_ALPHABLEND\", gdEffectAlphaBlend, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_EFFECT_NORMAL\", gdEffectNormal, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_EFFECT_OVERLAY\", gdEffectOverlay, CONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"IMG_CROP_DEFAULT\", GD_CROP_DEFAULT, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_CROP_TRANSPARENT\", GD_CROP_TRANSPARENT, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_CROP_BLACK\", GD_CROP_BLACK, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_CROP_WHITE\", GD_CROP_WHITE, CONST_CS | CONST_PERSISTENT);\n \tREGISTER_LONG_CONSTANT(\"IMG_CROP_SIDES\", GD_CROP_SIDES, CONST_CS | CONST_PERSISTENT);\n \tREGISTER_LONG_CONSTANT(\"IMG_CROP_THRESHOLD\", GD_CROP_THRESHOLD, CONST_CS | CONST_PERSISTENT);\n \n\n \tREGISTER_LONG_CONSTANT(\"IMG_BELL\", GD_BELL, CONST_CS | CONST_PERSISTENT);\n \tREGISTER_LONG_CONSTANT(\"IMG_BESSEL\", GD_BESSEL, CONST_CS | CONST_PERSISTENT);\n \tREGISTER_LONG_CONSTANT(\"IMG_BILINEAR_FIXED\", GD_BILINEAR_FIXED, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_BICUBIC\", GD_BICUBIC, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_BICUBIC_FIXED\", GD_BICUBIC_FIXED, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_BLACKMAN\", GD_BLACKMAN, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_BOX\", GD_BOX, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_BSPLINE\", GD_BSPLINE, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_CATMULLROM\", GD_CATMULLROM, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_GAUSSIAN\", GD_GAUSSIAN, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_GENERALIZED_CUBIC\", GD_GENERALIZED_CUBIC, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_HERMITE\", GD_HERMITE, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_HAMMING\", GD_HAMMING, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_HANNING\", GD_HANNING, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_MITCHELL\", GD_MITCHELL, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_POWER\", GD_POWER, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_QUADRATIC\", GD_QUADRATIC, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_SINC\", GD_SINC, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_NEAREST_NEIGHBOUR\", GD_NEAREST_NEIGHBOUR, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_WEIGHTED4\", GD_WEIGHTED4, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_TRIANGLE\", GD_TRIANGLE, CONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"IMG_AFFINE_TRANSLATE\", GD_AFFINE_TRANSLATE, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_AFFINE_SCALE\", GD_AFFINE_SCALE, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_AFFINE_ROTATE\", GD_AFFINE_ROTATE, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_AFFINE_SHEAR_HORIZONTAL\", GD_AFFINE_SHEAR_HORIZONTAL, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_AFFINE_SHEAR_VERTICAL\", GD_AFFINE_SHEAR_VERTICAL, CONST_CS | CONST_PERSISTENT);\n\n#if defined(HAVE_GD_BUNDLED)\n\tREGISTER_LONG_CONSTANT(\"GD_BUNDLED\", 1, CONST_CS | CONST_PERSISTENT);\n#else\n\tREGISTER_LONG_CONSTANT(\"GD_BUNDLED\", 0, CONST_CS | CONST_PERSISTENT);\n#endif\n\n\t/* Section Filters */\n\tREGISTER_LONG_CONSTANT(\"IMG_FILTER_NEGATE\", IMAGE_FILTER_NEGATE, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_FILTER_GRAYSCALE\", IMAGE_FILTER_GRAYSCALE, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_FILTER_BRIGHTNESS\", IMAGE_FILTER_BRIGHTNESS, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_FILTER_CONTRAST\", IMAGE_FILTER_CONTRAST, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_FILTER_COLORIZE\", IMAGE_FILTER_COLORIZE, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_FILTER_EDGEDETECT\", IMAGE_FILTER_EDGEDETECT, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_FILTER_GAUSSIAN_BLUR\", IMAGE_FILTER_GAUSSIAN_BLUR, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_FILTER_SELECTIVE_BLUR\", IMAGE_FILTER_SELECTIVE_BLUR, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_FILTER_EMBOSS\", IMAGE_FILTER_EMBOSS, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_FILTER_MEAN_REMOVAL\", IMAGE_FILTER_MEAN_REMOVAL, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_FILTER_SMOOTH\", IMAGE_FILTER_SMOOTH, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"IMG_FILTER_PIXELATE\", IMAGE_FILTER_PIXELATE, CONST_CS | CONST_PERSISTENT);\n\t/* End Section Filters */\n\n#ifdef GD_VERSION_STRING\n\tREGISTER_STRING_CONSTANT(\"GD_VERSION\", GD_VERSION_STRING, CONST_CS | CONST_PERSISTENT);\n#endif\n\n#if defined(GD_MAJOR_VERSION) && defined(GD_MINOR_VERSION) && defined(GD_RELEASE_VERSION) && defined(GD_EXTRA_VERSION)\n\tREGISTER_LONG_CONSTANT(\"GD_MAJOR_VERSION\", GD_MAJOR_VERSION, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"GD_MINOR_VERSION\", GD_MINOR_VERSION, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"GD_RELEASE_VERSION\", GD_RELEASE_VERSION, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_STRING_CONSTANT(\"GD_EXTRA_VERSION\", GD_EXTRA_VERSION, CONST_CS | CONST_PERSISTENT);\n#endif\n\n\n#ifdef HAVE_GD_PNG\n\n\t/*\n\t * cannot include #include \"png.h\"\n\t * /usr/include/pngconf.h:310:2: error: #error png.h already includes setjmp.h with some additional fixup.\n\t * as error, use the values for now...\n\t */\n\tREGISTER_LONG_CONSTANT(\"PNG_NO_FILTER\",\t    0x00, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"PNG_FILTER_NONE\",   0x08, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"PNG_FILTER_SUB\",    0x10, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"PNG_FILTER_UP\",     0x20, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"PNG_FILTER_AVG\",    0x40, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"PNG_FILTER_PAETH\",  0x80, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"PNG_ALL_FILTERS\",   0x08 | 0x10 | 0x20 | 0x40 | 0x80, CONST_CS | CONST_PERSISTENT);\n#endif\n\n\treturn SUCCESS;\n}\n",
    "cwe": [
      "CWE-787"
    ],
    "id": 374,
    "_valid_cwes": [
      "CWE-787"
    ]
  },
  {
    "cve_id": "CVE-2018-6063",
    "code_before_change": "   void CallCompositorWithSuccess(mojom::PdfCompositorPtr ptr) {\n     auto handle = CreateMSKPInSharedMemory();\n     ASSERT_TRUE(handle.IsValid());\n    mojo::ScopedSharedBufferHandle buffer_handle =\n        mojo::WrapSharedMemoryHandle(handle, handle.GetSize(), true);\n     ASSERT_TRUE(buffer_handle->is_valid());\n     EXPECT_CALL(*this, CallbackOnSuccess(testing::_)).Times(1);\n     ptr->CompositePdf(std::move(buffer_handle),\n                      base::BindOnce(&PdfCompositorServiceTest::OnCallback,\n                                     base::Unretained(this)));\n    run_loop_->Run();\n  }\n",
    "code_after_change": "   void CallCompositorWithSuccess(mojom::PdfCompositorPtr ptr) {\n     auto handle = CreateMSKPInSharedMemory();\n     ASSERT_TRUE(handle.IsValid());\n    mojo::ScopedSharedBufferHandle buffer_handle = mojo::WrapSharedMemoryHandle(\n        handle, handle.GetSize(),\n        mojo::UnwrappedSharedMemoryHandleProtection::kReadOnly);\n     ASSERT_TRUE(buffer_handle->is_valid());\n     EXPECT_CALL(*this, CallbackOnSuccess(testing::_)).Times(1);\n     ptr->CompositePdf(std::move(buffer_handle),\n                      base::BindOnce(&PdfCompositorServiceTest::OnCallback,\n                                     base::Unretained(this)));\n    run_loop_->Run();\n  }\n",
    "cwe": [
      "CWE-787"
    ],
    "id": 391,
    "_valid_cwes": [
      "CWE-787"
    ]
  },
  {
    "cve_id": "CVE-2016-5209",
    "code_before_change": " static void swizzleImageData(unsigned char* srcAddr,\n                             size_t height,\n                             size_t bytesPerRow,\n                              bool flipY) {\n   if (flipY) {\n    for (size_t i = 0; i < height / 2; i++) {\n      size_t topRowStartPosition = i * bytesPerRow;\n      size_t bottomRowStartPosition = (height - 1 - i) * bytesPerRow;\n       if (kN32_SkColorType == kBGRA_8888_SkColorType) {  // needs to swizzle\n        for (size_t j = 0; j < bytesPerRow; j += 4) {\n           std::swap(srcAddr[topRowStartPosition + j],\n                     srcAddr[bottomRowStartPosition + j + 2]);\n           std::swap(srcAddr[topRowStartPosition + j + 1],\n                    srcAddr[bottomRowStartPosition + j + 1]);\n          std::swap(srcAddr[topRowStartPosition + j + 2],\n                    srcAddr[bottomRowStartPosition + j]);\n          std::swap(srcAddr[topRowStartPosition + j + 3],\n                    srcAddr[bottomRowStartPosition + j + 3]);\n        }\n      } else {\n        std::swap_ranges(srcAddr + topRowStartPosition,\n                         srcAddr + topRowStartPosition + bytesPerRow,\n                         srcAddr + bottomRowStartPosition);\n      }\n     }\n   } else {\n     if (kN32_SkColorType == kBGRA_8888_SkColorType)  // needs to swizzle\n      for (size_t i = 0; i < height * bytesPerRow; i += 4)\n         std::swap(srcAddr[i], srcAddr[i + 2]);\n   }\n }\n",
    "code_after_change": " static void swizzleImageData(unsigned char* srcAddr,\n                             unsigned height,\n                             unsigned bytesPerRow,\n                              bool flipY) {\n   if (flipY) {\n    for (unsigned i = 0; i < height / 2; i++) {\n      unsigned topRowStartPosition = i * bytesPerRow;\n      unsigned bottomRowStartPosition = (height - 1 - i) * bytesPerRow;\n       if (kN32_SkColorType == kBGRA_8888_SkColorType) {  // needs to swizzle\n        for (unsigned j = 0; j < bytesPerRow; j += 4) {\n           std::swap(srcAddr[topRowStartPosition + j],\n                     srcAddr[bottomRowStartPosition + j + 2]);\n           std::swap(srcAddr[topRowStartPosition + j + 1],\n                    srcAddr[bottomRowStartPosition + j + 1]);\n          std::swap(srcAddr[topRowStartPosition + j + 2],\n                    srcAddr[bottomRowStartPosition + j]);\n          std::swap(srcAddr[topRowStartPosition + j + 3],\n                    srcAddr[bottomRowStartPosition + j + 3]);\n        }\n      } else {\n        std::swap_ranges(srcAddr + topRowStartPosition,\n                         srcAddr + topRowStartPosition + bytesPerRow,\n                         srcAddr + bottomRowStartPosition);\n      }\n     }\n   } else {\n     if (kN32_SkColorType == kBGRA_8888_SkColorType)  // needs to swizzle\n      for (unsigned i = 0; i < height * bytesPerRow; i += 4)\n         std::swap(srcAddr[i], srcAddr[i + 2]);\n   }\n }\n",
    "cwe": [
      "CWE-787"
    ],
    "id": 414,
    "_valid_cwes": [
      "CWE-787"
    ]
  },
  {
    "cve_id": "CVE-2018-20763",
    "code_before_change": "int mp4client_main(int argc, char **argv)\n{\n\tchar c;\n\tconst char *str;\n\tint ret_val = 0;\n\tu32 i, times[100], nb_times, dump_mode;\n\tu32 simulation_time_in_ms = 0;\n\tu32 initial_service_id = 0;\n\tBool auto_exit = GF_FALSE;\n\tBool logs_set = GF_FALSE;\n\tBool start_fs = GF_FALSE;\n\tBool use_rtix = GF_FALSE;\n\tBool pause_at_first = GF_FALSE;\n\tBool no_cfg_save = GF_FALSE;\n\tBool is_cfg_only = GF_FALSE;\n\n\tDouble play_from = 0;\n#ifdef GPAC_MEMORY_TRACKING\n    GF_MemTrackerType mem_track = GF_MemTrackerNone;\n#endif\n\tDouble fps = GF_IMPORT_DEFAULT_FPS;\n\tBool fill_ar, visible, do_uncache, has_command;\n\tchar *url_arg, *out_arg, *the_cfg, *rti_file, *views, *mosaic;\n\tFILE *logfile = NULL;\n\tFloat scale = 1;\n#ifndef WIN32\n\tdlopen(NULL, RTLD_NOW|RTLD_GLOBAL);\n#endif\n\n\t/*by default use current dir*/\n\tstrcpy(the_url, \".\");\n\n\tmemset(&user, 0, sizeof(GF_User));\n\n\tdump_mode = DUMP_NONE;\n\tfill_ar = visible = do_uncache = has_command = GF_FALSE;\n\turl_arg = out_arg = the_cfg = rti_file = views = mosaic = NULL;\n\tnb_times = 0;\n\ttimes[0] = 0;\n\n\t/*first locate config file if specified*/\n\tfor (i=1; i<(u32) argc; i++) {\n\t\tchar *arg = argv[i];\n\t\tif (!strcmp(arg, \"-c\") || !strcmp(arg, \"-cfg\")) {\n\t\t\tthe_cfg = argv[i+1];\n\t\t\ti++;\n\t\t}\n\t\telse if (!strcmp(arg, \"-mem-track\") || !strcmp(arg, \"-mem-track-stack\")) {\n#ifdef GPAC_MEMORY_TRACKING\n            mem_track = !strcmp(arg, \"-mem-track-stack\") ? GF_MemTrackerBackTrace : GF_MemTrackerSimple;\n#else\n\t\t\tfprintf(stderr, \"WARNING - GPAC not compiled with Memory Tracker - ignoring \\\"%s\\\"\\n\", arg);\n#endif\n\t\t} else if (!strcmp(arg, \"-gui\")) {\n\t\t\tgui_mode = 1;\n\t\t} else if (!strcmp(arg, \"-guid\")) {\n\t\t\tgui_mode = 2;\n\t\t} else if (!strcmp(arg, \"-h\") || !strcmp(arg, \"-help\")) {\n\t\t\tPrintUsage();\n\t\t\treturn 0;\n\t\t}\n\t}\n\n#ifdef GPAC_MEMORY_TRACKING\n\tgf_sys_init(mem_track);\n#else\n\tgf_sys_init(GF_MemTrackerNone);\n#endif\n\tgf_sys_set_args(argc, (const char **) argv);\n\n\tcfg_file = gf_cfg_init(the_cfg, NULL);\n\tif (!cfg_file) {\n\t\tfprintf(stderr, \"Error: Configuration File not found\\n\");\n\t\treturn 1;\n\t}\n\t/*if logs are specified, use them*/\n\tif (gf_log_set_tools_levels( gf_cfg_get_key(cfg_file, \"General\", \"Logs\") ) != GF_OK) {\n\t\treturn 1;\n\t}\n\n\tif( gf_cfg_get_key(cfg_file, \"General\", \"Logs\") != NULL ) {\n\t\tlogs_set = GF_TRUE;\n\t}\n\n\tif (!gui_mode) {\n\t\tstr = gf_cfg_get_key(cfg_file, \"General\", \"ForceGUI\");\n\t\tif (str && !strcmp(str, \"yes\")) gui_mode = 1;\n\t}\n\n\tfor (i=1; i<(u32) argc; i++) {\n\t\tchar *arg = argv[i];\n\n\t\tif (!strcmp(arg, \"-rti\")) {\n\t\t\trti_file = argv[i+1];\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, \"-rtix\")) {\n\t\t\trti_file = argv[i+1];\n\t\t\ti++;\n\t\t\tuse_rtix = GF_TRUE;\n\t\t} else if (!stricmp(arg, \"-size\")) {\n\t\t\t/*usage of %ud breaks sscanf on MSVC*/\n\t\t\tif (sscanf(argv[i+1], \"%dx%d\", &forced_width, &forced_height) != 2) {\n\t\t\t\tforced_width = forced_height = 0;\n\t\t\t}\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, \"-quiet\")) {\n\t\t\tbe_quiet = 1;\n\t\t} else if (!strcmp(arg, \"-strict-error\")) {\n\t\t\tgf_log_set_strict_error(1);\n\t\t} else if (!strcmp(arg, \"-log-file\") || !strcmp(arg, \"-lf\")) {\n\t\t\tlogfile = gf_fopen(argv[i+1], \"wt\");\n\t\t\tgf_log_set_callback(logfile, on_gpac_log);\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, \"-logs\") ) {\n\t\t\tif (gf_log_set_tools_levels(argv[i+1]) != GF_OK) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tlogs_set = GF_TRUE;\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, \"-log-clock\") || !strcmp(arg, \"-lc\")) {\n\t\t\tlog_time_start = 1;\n\t\t} else if (!strcmp(arg, \"-log-utc\") || !strcmp(arg, \"-lu\")) {\n\t\t\tlog_utc_time = 1;\n\t\t}\n#if defined(__DARWIN__) || defined(__APPLE__)\n\t\telse if (!strcmp(arg, \"-thread\")) threading_flags = 0;\n#else\n\t\telse if (!strcmp(arg, \"-no-thread\")) threading_flags = GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_WINDOW_NO_THREAD;\n#endif\n\t\telse if (!strcmp(arg, \"-no-cthread\") || !strcmp(arg, \"-no-compositor-thread\")) threading_flags |= GF_TERM_NO_COMPOSITOR_THREAD;\n\t\telse if (!strcmp(arg, \"-no-audio\")) no_audio = 1;\n\t\telse if (!strcmp(arg, \"-no-regulation\")) no_regulation = 1;\n\t\telse if (!strcmp(arg, \"-fs\")) start_fs = 1;\n\n\t\telse if (!strcmp(arg, \"-opt\")) {\n\t\t\tset_cfg_option(argv[i+1]);\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, \"-conf\")) {\n\t\t\tset_cfg_option(argv[i+1]);\n\t\t\tis_cfg_only=GF_TRUE;\n\t\t\ti++;\n\t\t}\n\t\telse if (!strcmp(arg, \"-ifce\")) {\n\t\t\tgf_cfg_set_key(cfg_file, \"Network\", \"DefaultMCastInterface\", argv[i+1]);\n\t\t\ti++;\n\t\t}\n\t\telse if (!stricmp(arg, \"-help\")) {\n\t\t\tPrintUsage();\n\t\t\treturn 1;\n\t\t}\n\t\telse if (!stricmp(arg, \"-noprog\")) {\n\t\t\tno_prog=1;\n\t\t\tgf_set_progress_callback(NULL, progress_quiet);\n\t\t}\n\t\telse if (!stricmp(arg, \"-no-save\") || !stricmp(arg, \"--no-save\") /*old versions used --n-save ...*/) {\n\t\t\tno_cfg_save=1;\n\t\t}\n\t\telse if (!stricmp(arg, \"-ntp-shift\")) {\n\t\t\ts32 shift = atoi(argv[i+1]);\n\t\t\ti++;\n\t\t\tgf_net_set_ntp_shift(shift);\n\t\t}\n\t\telse if (!stricmp(arg, \"-run-for\")) {\n\t\t\tsimulation_time_in_ms = atoi(argv[i+1]) * 1000;\n\t\t\tif (!simulation_time_in_ms)\n\t\t\t\tsimulation_time_in_ms = 1; /*1ms*/\n\t\t\ti++;\n\t\t}\n\n\t\telse if (!strcmp(arg, \"-out\")) {\n\t\t\tout_arg = argv[i+1];\n\t\t\ti++;\n\t\t}\n\t\telse if (!stricmp(arg, \"-fps\")) {\n\t\t\tfps = atof(argv[i+1]);\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, \"-avi\") || !strcmp(arg, \"-sha\")) {\n\t\t\tdump_mode &= 0xFFFF0000;\n\n\t\t\tif (!strcmp(arg, \"-sha\")) dump_mode |= DUMP_SHA1;\n\t\t\telse dump_mode |= DUMP_AVI;\n\n\t\t\tif ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) {\n\t\t\t\tif (!strcmp(arg, \"-avi\") && (nb_times!=2) ) {\n\t\t\t\t\tfprintf(stderr, \"Only one time arg found for -avi - check usage\\n\");\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t} else if (!strcmp(arg, \"-rgbds\")) { /*get dump in rgbds pixel format*/\n\t\t\t\tdump_mode |= DUMP_RGB_DEPTH_SHAPE;\n\t\t} else if (!strcmp(arg, \"-rgbd\")) { /*get dump in rgbd pixel format*/\n\t\t\t\tdump_mode |= DUMP_RGB_DEPTH;\n\t\t} else if (!strcmp(arg, \"-depth\")) {\n\t\t\t\tdump_mode |= DUMP_DEPTH_ONLY;\n\t\t} else if (!strcmp(arg, \"-bmp\")) {\n\t\t\tdump_mode &= 0xFFFF0000;\n\t\t\tdump_mode |= DUMP_BMP;\n\t\t\tif ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) i++;\n\t\t} else if (!strcmp(arg, \"-png\")) {\n\t\t\tdump_mode &= 0xFFFF0000;\n\t\t\tdump_mode |= DUMP_PNG;\n\t\t\tif ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) i++;\n\t\t} else if (!strcmp(arg, \"-raw\")) {\n\t\t\tdump_mode &= 0xFFFF0000;\n\t\t\tdump_mode |= DUMP_RAW;\n\t\t\tif ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) i++;\n\t\t} else if (!stricmp(arg, \"-scale\")) {\n\t\t\tsscanf(argv[i+1], \"%f\", &scale);\n\t\t\ti++;\n\t\t}\n\t\telse if (!strcmp(arg, \"-c\") || !strcmp(arg, \"-cfg\")) {\n\t\t\t/* already parsed */\n\t\t\ti++;\n\t\t}\n\n\t\t/*arguments only used in non-gui mode*/\n\t\tif (!gui_mode) {\n\t\t\tif (arg[0] != '-') {\n\t\t\t\tif (url_arg) {\n\t\t\t\t\tfprintf(stderr, \"Several input URLs provided (\\\"%s\\\", \\\"%s\\\"). Check your command-line.\\n\", url_arg, arg);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\turl_arg = arg;\n\t\t\t}\n\t\t\telse if (!strcmp(arg, \"-loop\")) loop_at_end = 1;\n\t\t\telse if (!strcmp(arg, \"-bench\")) bench_mode = 1;\n\t\t\telse if (!strcmp(arg, \"-vbench\")) bench_mode = 2;\n\t\t\telse if (!strcmp(arg, \"-sbench\")) bench_mode = 3;\n\t\t\telse if (!strcmp(arg, \"-no-addon\")) enable_add_ons = GF_FALSE;\n\n\t\t\telse if (!strcmp(arg, \"-pause\")) pause_at_first = 1;\n\t\t\telse if (!strcmp(arg, \"-play-from\")) {\n\t\t\t\tplay_from = atof((const char *) argv[i+1]);\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (!strcmp(arg, \"-speed\")) {\n\t\t\t\tplayback_speed = FLT2FIX( atof((const char *) argv[i+1]) );\n\t\t\t\tif (playback_speed <= 0) playback_speed = FIX_ONE;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (!strcmp(arg, \"-no-wnd\")) user.init_flags |= GF_TERM_WINDOWLESS;\n\t\t\telse if (!strcmp(arg, \"-no-back\")) user.init_flags |= GF_TERM_WINDOW_TRANSPARENT;\n\t\t\telse if (!strcmp(arg, \"-align\")) {\n\t\t\t\tif (argv[i+1][0]=='m') align_mode = 1;\n\t\t\t\telse if (argv[i+1][0]=='b') align_mode = 2;\n\t\t\t\talign_mode <<= 8;\n\t\t\t\tif (argv[i+1][1]=='m') align_mode |= 1;\n\t\t\t\telse if (argv[i+1][1]=='r') align_mode |= 2;\n\t\t\t\ti++;\n\t\t\t} else if (!strcmp(arg, \"-fill\")) {\n\t\t\t\tfill_ar = GF_TRUE;\n\t\t\t} else if (!strcmp(arg, \"-show\")) {\n\t\t\t\tvisible = 1;\n\t\t\t} else if (!strcmp(arg, \"-uncache\")) {\n\t\t\t\tdo_uncache = GF_TRUE;\n\t\t\t}\n\t\t\telse if (!strcmp(arg, \"-exit\")) auto_exit = GF_TRUE;\n\t\t\telse if (!stricmp(arg, \"-views\")) {\n\t\t\t\tviews = argv[i+1];\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (!stricmp(arg, \"-mosaic\")) {\n\t\t\t\tmosaic = argv[i+1];\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (!stricmp(arg, \"-com\")) {\n\t\t\t\thas_command = GF_TRUE;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (!stricmp(arg, \"-service\")) {\n\t\t\t\tinitial_service_id = atoi(argv[i+1]);\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\tif (is_cfg_only) {\n\t\tgf_cfg_del(cfg_file);\n\t\tfprintf(stderr, \"GPAC Config updated\\n\");\n\t\treturn 0;\n\t}\n\tif (do_uncache) {\n\t\tconst char *cache_dir = gf_cfg_get_key(cfg_file, \"General\", \"CacheDirectory\");\n\t\tdo_flatten_cache(cache_dir);\n\t\tfprintf(stderr, \"GPAC Cache dir %s flattened\\n\", cache_dir);\n\t\tgf_cfg_del(cfg_file);\n\t\treturn 0;\n\t}\n\n\tif (dump_mode && !url_arg ) {\n\t\tFILE *test;\n\t\turl_arg = (char *)gf_cfg_get_key(cfg_file, \"General\", \"StartupFile\");\n\t\ttest = url_arg ? gf_fopen(url_arg, \"rt\") : NULL;\n\t\tif (!test) url_arg = NULL;\n\t\telse gf_fclose(test);\n\t\t\n\t\tif (!url_arg) {\n\t\t\tfprintf(stderr, \"Missing argument for dump\\n\");\n\t\t\tPrintUsage();\n\t\t\tif (logfile) gf_fclose(logfile);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (!gui_mode && !url_arg && (gf_cfg_get_key(cfg_file, \"General\", \"StartupFile\") != NULL)) {\n\t\tgui_mode=1;\n\t}\n\n#ifdef WIN32\n\tif (gui_mode==1) {\n\t\tconst char *opt;\n\t\tTCHAR buffer[1024];\n\t\tDWORD res = GetCurrentDirectory(1024, buffer);\n\t\tbuffer[res] = 0;\n\t\topt = gf_cfg_get_key(cfg_file, \"General\", \"ModulesDirectory\");\n\t\tif (strstr(opt, buffer)) {\n\t\t\tgui_mode=1;\n\t\t} else {\n\t\t\tgui_mode=2;\n\t\t}\n\t}\n#endif\n\n\tif (gui_mode==1) {\n\t\thide_shell(1);\n\t}\n\tif (gui_mode) {\n\t\tno_prog=1;\n\t\tgf_set_progress_callback(NULL, progress_quiet);\n\t}\n\n\tif (!url_arg && simulation_time_in_ms)\n\t\tsimulation_time_in_ms += gf_sys_clock();\n\n#if defined(__DARWIN__) || defined(__APPLE__)\n\tcarbon_init();\n#endif\n\n\n\tif (dump_mode) rti_file = NULL;\n\n\tif (!logs_set) {\n\t\tgf_log_set_tool_level(GF_LOG_ALL, GF_LOG_WARNING);\n\t}\n\tif (rti_file || logfile || log_utc_time || log_time_start)\n\t\tgf_log_set_callback(NULL, on_gpac_log);\n\n\tif (rti_file) init_rti_logs(rti_file, url_arg, use_rtix);\n\n\t{\n\t\tGF_SystemRTInfo rti;\n\t\tif (gf_sys_get_rti(0, &rti, 0))\n\t\t\tfprintf(stderr, \"System info: %d MB RAM - %d cores\\n\", (u32) (rti.physical_memory/1024/1024), rti.nb_cores);\n\t}\n\n\n\t/*setup dumping options*/\n\tif (dump_mode) {\n\t\tuser.init_flags |= GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_NO_REGULATION;\n\t\tif (!visible)\n\t\t\tuser.init_flags |= GF_TERM_INIT_HIDE;\n\n\t\tgf_cfg_set_key(cfg_file, \"Audio\", \"DriverName\", \"Raw Audio Output\");\n\t\tno_cfg_save=GF_TRUE;\n\t} else {\n\t\tinit_w = forced_width;\n\t\tinit_h = forced_height;\n\t}\n\n\tuser.modules = gf_modules_new(NULL, cfg_file);\n\tif (user.modules) i = gf_modules_get_count(user.modules);\n\tif (!i || !user.modules) {\n\t\tfprintf(stderr, \"Error: no modules found - exiting\\n\");\n\t\tif (user.modules) gf_modules_del(user.modules);\n\t\tgf_cfg_del(cfg_file);\n\t\tgf_sys_close();\n\t\tif (logfile) gf_fclose(logfile);\n\t\treturn 1;\n\t}\n\tfprintf(stderr, \"Modules Found : %d \\n\", i);\n\n\tstr = gf_cfg_get_key(cfg_file, \"General\", \"GPACVersion\");\n\tif (!str || strcmp(str, GPAC_FULL_VERSION)) {\n\t\tgf_cfg_del_section(cfg_file, \"PluginsCache\");\n\t\tgf_cfg_set_key(cfg_file, \"General\", \"GPACVersion\", GPAC_FULL_VERSION);\n\t}\n\n\tuser.config = cfg_file;\n\tuser.EventProc = GPAC_EventProc;\n\t/*dummy in this case (global vars) but MUST be non-NULL*/\n\tuser.opaque = user.modules;\n\tif (threading_flags) user.init_flags |= threading_flags;\n\tif (no_audio) user.init_flags |= GF_TERM_NO_AUDIO;\n\tif (no_regulation) user.init_flags |= GF_TERM_NO_REGULATION;\n\n\tif (threading_flags & (GF_TERM_NO_DECODER_THREAD|GF_TERM_NO_COMPOSITOR_THREAD) ) term_step = GF_TRUE;\n\n\tif (dump_mode) user.init_flags |= GF_TERM_USE_AUDIO_HW_CLOCK;\n\n\tif (bench_mode) {\n\t\tgf_cfg_discard_changes(user.config);\n\t\tauto_exit = GF_TRUE;\n\t\tgf_cfg_set_key(user.config, \"Audio\", \"DriverName\", \"Raw Audio Output\");\n\t\tif (bench_mode!=2) {\n\t\t\tgf_cfg_set_key(user.config, \"Video\", \"DriverName\", \"Raw Video Output\");\n\t\t\tgf_cfg_set_key(user.config, \"RAWVideo\", \"RawOutput\", \"null\");\n\t\t\tgf_cfg_set_key(user.config, \"Compositor\", \"OpenGLMode\", \"disable\");\n\t\t} else {\n\t\t\tgf_cfg_set_key(user.config, \"Video\", \"DisableVSync\", \"yes\");\n\t\t}\n\t}\n\n\t{\n\t\tchar dim[50];\n\t\tsprintf(dim, \"%d\", forced_width);\n\t\tgf_cfg_set_key(user.config, \"Compositor\", \"DefaultWidth\", forced_width ? dim : NULL);\n\t\tsprintf(dim, \"%d\", forced_height);\n\t\tgf_cfg_set_key(user.config, \"Compositor\", \"DefaultHeight\", forced_height ? dim : NULL);\n\t}\n\n\tfprintf(stderr, \"Loading GPAC Terminal\\n\");\n\ti = gf_sys_clock();\n\tterm = gf_term_new(&user);\n\tif (!term) {\n\t\tfprintf(stderr, \"\\nInit error - check you have at least one video out and one rasterizer...\\nFound modules:\\n\");\n\t\tlist_modules(user.modules);\n\t\tgf_modules_del(user.modules);\n\t\tgf_cfg_discard_changes(cfg_file);\n\t\tgf_cfg_del(cfg_file);\n\t\tgf_sys_close();\n\t\tif (logfile) gf_fclose(logfile);\n\t\treturn 1;\n\t}\n\tfprintf(stderr, \"Terminal Loaded in %d ms\\n\", gf_sys_clock()-i);\n\n\tif (bench_mode) {\n\t\tdisplay_rti = 2;\n\t\tgf_term_set_option(term, GF_OPT_VIDEO_BENCH, (bench_mode==3) ? 2 : 1);\n\t\tif (bench_mode==1) bench_mode=2;\n\t}\n\n\tif (dump_mode) {\n\t\tif (fill_ar) gf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_FILL_SCREEN);\n\t} else {\n\t\t/*check video output*/\n\t\tstr = gf_cfg_get_key(cfg_file, \"Video\", \"DriverName\");\n\t\tif (!bench_mode && !strcmp(str, \"Raw Video Output\")) fprintf(stderr, \"WARNING: using raw output video (memory only) - no display used\\n\");\n\t\t/*check audio output*/\n\t\tstr = gf_cfg_get_key(cfg_file, \"Audio\", \"DriverName\");\n\t\tif (!str || !strcmp(str, \"No Audio Output Available\")) fprintf(stderr, \"WARNING: no audio output available - make sure no other program is locking the sound card\\n\");\n\n\t\tstr = gf_cfg_get_key(cfg_file, \"General\", \"NoMIMETypeFetch\");\n\t\tno_mime_check = (str && !stricmp(str, \"yes\")) ? 1 : 0;\n\t}\n\n\tstr = gf_cfg_get_key(cfg_file, \"HTTPProxy\", \"Enabled\");\n\tif (str && !strcmp(str, \"yes\")) {\n\t\tstr = gf_cfg_get_key(cfg_file, \"HTTPProxy\", \"Name\");\n\t\tif (str) fprintf(stderr, \"HTTP Proxy %s enabled\\n\", str);\n\t}\n\n\tif (rti_file) {\n\t\tstr = gf_cfg_get_key(cfg_file, \"General\", \"RTIRefreshPeriod\");\n\t\tif (str) {\n\t\t\trti_update_time_ms = atoi(str);\n\t\t} else {\n\t\t\tgf_cfg_set_key(cfg_file, \"General\", \"RTIRefreshPeriod\", \"200\");\n\t\t}\n\t\tUpdateRTInfo(\"At GPAC load time\\n\");\n\t}\n\n\tRun = 1;\n\n\tif (dump_mode) {\n\t\tif (!nb_times) {\n\t\t\ttimes[0] = 0;\n\t\t\tnb_times++;\n\t\t}\n\t\tret_val = dump_file(url_arg, out_arg, dump_mode, fps, forced_width, forced_height, scale, times, nb_times);\n\t\tRun = 0;\n\t}\n\telse if (views) {\n\t}\n\t/*connect if requested*/\n\telse if (!gui_mode && url_arg) {\n\t\tchar *ext;\n\n\t\tif (strlen(url_arg) >= sizeof(the_url)) {\n\t\t\tfprintf(stderr, \"Input url %s is too long, truncating to %d chars.\\n\", url_arg, (int)(sizeof(the_url) - 1));\n\t\t\tstrncpy(the_url, url_arg, sizeof(the_url)-1);\n\t\t\tthe_url[sizeof(the_url) - 1] = 0;\n\t\t}\n\t\telse {\n\t\t\tstrcpy(the_url, url_arg);\n\t\t}\n\t\text = strrchr(the_url, '.');\n\t\tif (ext && (!stricmp(ext, \".m3u\") || !stricmp(ext, \".pls\"))) {\n\t\t\tGF_Err e = GF_OK;\n\t\t\tfprintf(stderr, \"Opening Playlist %s\\n\", the_url);\n\n\t\t\tstrcpy(pl_path, the_url);\n\t\t\t/*this is not clean, we need to have a plugin handle playlist for ourselves*/\n\t\t\tif (!strncmp(\"http:\", the_url, 5)) {\n\t\t\t\tGF_DownloadSession *sess = gf_dm_sess_new(term->downloader, the_url, GF_NETIO_SESSION_NOT_THREADED, NULL, NULL, &e);\n\t\t\t\tif (sess) {\n \t\t\t\t\te = gf_dm_sess_process(sess);\n \t\t\t\t\tif (!e) {\n \t\t\t\t\t\tstrncpy(the_url, gf_dm_sess_get_cache_name(sess), sizeof(the_url) - 1);\n\t\t\t\t\t\tthe_url[sizeof(the_cfg) - 1] = 0;\n \t\t\t\t\t}\n \t\t\t\t\tgf_dm_sess_del(sess);\n \t\t\t\t}\n\t\t\t}\n\n\t\t\tplaylist = e ? NULL : gf_fopen(the_url, \"rt\");\n\t\t\treadonly_playlist = 1;\n\t\t\tif (playlist) {\n\t\t\t\trequest_next_playlist_item = GF_TRUE;\n\t\t\t} else {\n\t\t\t\tif (e)\n\t\t\t\t\tfprintf(stderr, \"Failed to open playlist %s: %s\\n\", the_url, gf_error_to_string(e) );\n\t\t\t\tfprintf(stderr, \"Hit 'h' for help\\n\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tfprintf(stderr, \"Opening URL %s\\n\", the_url);\n\t\t\tif (pause_at_first) fprintf(stderr, \"[Status: Paused]\\n\");\n\t\t\tgf_term_connect_from_time(term, the_url, (u64) (play_from*1000), pause_at_first);\n\t\t}\n\t} else {\n\t\tfprintf(stderr, \"Hit 'h' for help\\n\\n\");\n\t\tstr = gf_cfg_get_key(cfg_file, \"General\", \"StartupFile\");\n\t\tif (str) {\n\t\t\tstrncpy(the_url, \"MP4Client \"GPAC_FULL_VERSION , sizeof(the_url)-1);\n\t\t\tthe_url[sizeof(the_url) - 1] = 0;\n\t\t\tgf_term_connect(term, str);\n\t\t\tstartup_file = 1;\n\t\t\tis_connected = 1;\n\t\t}\n\t}\n\tif (gui_mode==2) gui_mode=0;\n\n\tif (start_fs) gf_term_set_option(term, GF_OPT_FULLSCREEN, 1);\n\n\tif (views) {\n\t\tchar szTemp[4046];\n\t\tsprintf(szTemp, \"views://%s\", views);\n\t\tgf_term_connect(term, szTemp);\n\t}\n\tif (mosaic) {\n\t\tchar szTemp[4046];\n\t\tsprintf(szTemp, \"mosaic://%s\", mosaic);\n\t\tgf_term_connect(term, szTemp);\n\t}\n\tif (bench_mode) {\n\t\trti_update_time_ms = 500;\n\t\tbench_mode_start = gf_sys_clock();\n\t}\n\n\n\twhile (Run) {\n\n\t\t/*we don't want getchar to block*/\n\t\tif ((gui_mode==1) || !gf_prompt_has_input()) {\n\t\t\tif (reload) {\n\t\t\t\treload = 0;\n\t\t\t\tgf_term_disconnect(term);\n\t\t\t\tgf_term_connect(term, startup_file ? gf_cfg_get_key(cfg_file, \"General\", \"StartupFile\") : the_url);\n\t\t\t}\n\t\t\tif (restart && gf_term_get_option(term, GF_OPT_IS_OVER)) {\n\t\t\t\trestart = 0;\n\t\t\t\tgf_term_play_from_time(term, 0, 0);\n\t\t\t}\n\t\t\tif (request_next_playlist_item) {\n\t\t\t\tc = '\\n';\n\t\t\t\trequest_next_playlist_item = 0;\n\t\t\t\tgoto force_input;\n\t\t\t}\n\n\t\t\tif (has_command && is_connected) {\n\t\t\t\thas_command = GF_FALSE;\n\t\t\t\tfor (i=0; i<(u32)argc; i++) {\n\t\t\t\t\tif (!strcmp(argv[i], \"-com\")) {\n\t\t\t\t\t\tgf_term_scene_update(term, NULL, argv[i+1]);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (initial_service_id && is_connected) {\n\t\t\t\tGF_ObjectManager *root_od = gf_term_get_root_object(term);\n\t\t\t\tif (root_od) {\n\t\t\t\t\tgf_term_select_service(term, root_od, initial_service_id);\n\t\t\t\t\tinitial_service_id = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!use_rtix || display_rti) UpdateRTInfo(NULL);\n\t\t\tif (term_step) {\n\t\t\t\tgf_term_process_step(term);\n\t\t\t} else {\n\t\t\t\tgf_sleep(rti_update_time_ms);\n\t\t\t}\n\t\t\tif (auto_exit && eos_seen && gf_term_get_option(term, GF_OPT_IS_OVER)) {\n\t\t\t\tRun = GF_FALSE;\n\t\t\t}\n\n\t\t\t/*sim time*/\n\t\t\tif (simulation_time_in_ms\n\t\t\t        && ( (gf_term_get_elapsed_time_in_ms(term)>simulation_time_in_ms) || (!url_arg && gf_sys_clock()>simulation_time_in_ms))\n\t\t\t   ) {\n\t\t\t\tRun = GF_FALSE;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tc = gf_prompt_get_char();\n\nforce_input:\n\t\tswitch (c) {\n\t\tcase 'q':\n\t\t{\n\t\t\tGF_Event evt;\n\t\t\tmemset(&evt, 0, sizeof(GF_Event));\n\t\t\tevt.type = GF_EVENT_QUIT;\n\t\t\tgf_term_send_event(term, &evt);\n\t\t}\n\t\tbreak;\n\t\tcase 'X':\n\t\t\texit(0);\n\t\t\tbreak;\n\t\tcase 'Q':\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tstartup_file = 0;\n\t\t\tgf_term_disconnect(term);\n\t\t\tfprintf(stderr, \"Enter the absolute URL\\n\");\n\t\t\tif (1 > scanf(\"%s\", the_url)) {\n\t\t\t\tfprintf(stderr, \"Cannot read absolute URL, aborting\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (rti_file) init_rti_logs(rti_file, the_url, use_rtix);\n\t\t\tgf_term_connect(term, the_url);\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tgf_term_disconnect(term);\n\t\t\tfprintf(stderr, \"Enter the absolute URL to the playlist\\n\");\n\t\t\tif (1 > scanf(\"%s\", the_url)) {\n\t\t\t\tfprintf(stderr, \"Cannot read the absolute URL, aborting.\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tplaylist = gf_fopen(the_url, \"rt\");\n\t\t\tif (playlist) {\n\t\t\t\tif (1 >\tfscanf(playlist, \"%s\", the_url)) {\n\t\t\t\t\tfprintf(stderr, \"Cannot read any URL from playlist, aborting.\\n\");\n\t\t\t\t\tgf_fclose( playlist);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"Opening URL %s\\n\", the_url);\n\t\t\t\tgf_term_connect(term, the_url);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '\\n':\n\t\tcase 'N':\n\t\t\tif (playlist) {\n\t\t\t\tint res;\n\t\t\t\tgf_term_disconnect(term);\n\n\t\t\t\tres = fscanf(playlist, \"%s\", the_url);\n\t\t\t\tif ((res == EOF) && loop_at_end) {\n\t\t\t\t\tfseek(playlist, 0, SEEK_SET);\n\t\t\t\t\tres = fscanf(playlist, \"%s\", the_url);\n\t\t\t\t}\n\t\t\t\tif (res == EOF) {\n\t\t\t\t\tfprintf(stderr, \"No more items - exiting\\n\");\n\t\t\t\t\tRun = 0;\n\t\t\t\t} else if (the_url[0] == '#') {\n\t\t\t\t\trequest_next_playlist_item = GF_TRUE;\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"Opening URL %s\\n\", the_url);\n\t\t\t\t\tgf_term_connect_with_path(term, the_url, pl_path);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tif (playlist) {\n\t\t\t\tu32 count;\n\t\t\t\tgf_term_disconnect(term);\n\t\t\t\tif (1 > scanf(\"%u\", &count)) {\n\t\t\t\t\tfprintf(stderr, \"Cannot read number, aborting.\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\twhile (count) {\n\t\t\t\t\tif (fscanf(playlist, \"%s\", the_url)) {\n\t\t\t\t\t\tfprintf(stderr, \"Failed to read line, aborting\\n\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcount--;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"Opening URL %s\\n\", the_url);\n\t\t\t\tgf_term_connect(term, the_url);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tif (is_connected)\n\t\t\t\treload = 1;\n\t\t\tbreak;\n\n\t\tcase 'D':\n\t\t\tif (is_connected) gf_term_disconnect(term);\n\t\t\tbreak;\n\n\t\tcase 'p':\n\t\t\tif (is_connected) {\n\t\t\t\tBool is_pause = gf_term_get_option(term, GF_OPT_PLAY_STATE);\n\t\t\t\tfprintf(stderr, \"[Status: %s]\\n\", is_pause ? \"Playing\" : \"Paused\");\n\t\t\t\tgf_term_set_option(term, GF_OPT_PLAY_STATE, is_pause ? GF_STATE_PLAYING : GF_STATE_PAUSED);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tif (is_connected) {\n\t\t\t\tgf_term_set_option(term, GF_OPT_PLAY_STATE, GF_STATE_STEP_PAUSE);\n\t\t\t\tfprintf(stderr, \"Step time: \");\n\t\t\t\tPrintTime(gf_term_get_time_in_ms(term));\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'z':\n\t\tcase 'T':\n\t\t\tif (!CanSeek || (Duration<=2000)) {\n\t\t\t\tfprintf(stderr, \"scene not seekable\\n\");\n\t\t\t} else {\n\t\t\t\tDouble res;\n\t\t\t\ts32 seekTo;\n\t\t\t\tfprintf(stderr, \"Duration: \");\n\t\t\t\tPrintTime(Duration);\n\t\t\t\tres = gf_term_get_time_in_ms(term);\n\t\t\t\tif (c=='z') {\n\t\t\t\t\tres *= 100;\n\t\t\t\t\tres /= (s64)Duration;\n\t\t\t\t\tfprintf(stderr, \" (current %.2f %%)\\nEnter Seek percentage:\\n\", res);\n\t\t\t\t\tif (scanf(\"%d\", &seekTo) == 1) {\n\t\t\t\t\t\tif (seekTo > 100) seekTo = 100;\n\t\t\t\t\t\tres = (Double)(s64)Duration;\n\t\t\t\t\t\tres /= 100;\n\t\t\t\t\t\tres *= seekTo;\n\t\t\t\t\t\tgf_term_play_from_time(term, (u64) (s64) res, 0);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tu32 r, h, m, s;\n\t\t\t\t\tfprintf(stderr, \" - Current Time: \");\n\t\t\t\t\tPrintTime((u64) res);\n\t\t\t\t\tfprintf(stderr, \"\\nEnter seek time (Format: s, m:s or h:m:s):\\n\");\n\t\t\t\t\th = m = s = 0;\n\t\t\t\t\tr =scanf(\"%d:%d:%d\", &h, &m, &s);\n\t\t\t\t\tif (r==2) {\n\t\t\t\t\t\ts = m;\n\t\t\t\t\t\tm = h;\n\t\t\t\t\t\th = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse if (r==1) {\n\t\t\t\t\t\ts = h;\n\t\t\t\t\t\tm = h = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (r && (r<=3)) {\n\t\t\t\t\t\tu64 time = h*3600 + m*60 + s;\n\t\t\t\t\t\tgf_term_play_from_time(term, time*1000, 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 't':\n\t\t{\n\t\t\tif (is_connected) {\n\t\t\t\tfprintf(stderr, \"Current Time: \");\n\t\t\t\tPrintTime(gf_term_get_time_in_ms(term));\n\t\t\t\tfprintf(stderr, \" - Duration: \");\n\t\t\t\tPrintTime(Duration);\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase 'w':\n\t\t\tif (is_connected) PrintWorldInfo(term);\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tif (is_connected) PrintODList(term, NULL, 0, 0, \"Root\");\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tif (is_connected) {\n\t\t\t\tu32 ID;\n\t\t\t\tfprintf(stderr, \"Enter OD ID (0 for main OD): \");\n\t\t\t\tfflush(stderr);\n\t\t\t\tif (scanf(\"%ud\", &ID) == 1) {\n\t\t\t\t\tViewOD(term, ID, (u32)-1, NULL);\n\t\t\t\t} else {\n\t\t\t\t\tchar str_url[GF_MAX_PATH];\n\t\t\t\t\tif (scanf(\"%s\", str_url) == 1)\n\t\t\t\t\t\tViewOD(term, 0, (u32)-1, str_url);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'j':\n\t\t\tif (is_connected) {\n\t\t\t\tu32 num;\n\t\t\t\tdo {\n\t\t\t\t\tfprintf(stderr, \"Enter OD number (0 for main OD): \");\n\t\t\t\t\tfflush(stderr);\n\t\t\t\t} while( 1 > scanf(\"%ud\", &num));\n\t\t\t\tViewOD(term, (u32)-1, num, NULL);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tif (is_connected) ViewODs(term, 1);\n\t\t\tbreak;\n\n\t\tcase 'm':\n\t\t\tif (is_connected) ViewODs(term, 0);\n\t\t\tbreak;\n\n\t\tcase 'l':\n\t\t\tlist_modules(user.modules);\n\t\t\tbreak;\n\n\t\tcase 'n':\n\t\t\tif (is_connected) set_navigation();\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\tif (is_connected) gf_term_set_option(term, GF_OPT_NAVIGATION_TYPE, 0);\n\t\t\tbreak;\n\n\t\tcase 'd':\n\t\t\tif (is_connected) {\n\t\t\t\tGF_ObjectManager *odm = NULL;\n\t\t\t\tchar radname[GF_MAX_PATH], *sExt;\n\t\t\t\tGF_Err e;\n\t\t\t\tu32 i, count, odid;\n\t\t\t\tBool xml_dump, std_out;\n\t\t\t\tradname[0] = 0;\n\t\t\t\tdo {\n\t\t\t\t\tfprintf(stderr, \"Enter Inline OD ID if any or 0 : \");\n\t\t\t\t\tfflush(stderr);\n\t\t\t\t} while( 1 >  scanf(\"%ud\", &odid));\n\t\t\t\tif (odid) {\n\t\t\t\t\tGF_ObjectManager *root_odm = gf_term_get_root_object(term);\n\t\t\t\t\tif (!root_odm) break;\n\t\t\t\t\tcount = gf_term_get_object_count(term, root_odm);\n\t\t\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\t\t\tGF_MediaInfo info;\n\t\t\t\t\t\todm = gf_term_get_object(term, root_odm, i);\n\t\t\t\t\t\tif (gf_term_get_object_info(term, odm, &info) == GF_OK) {\n\t\t\t\t\t\t\tif (info.od->objectDescriptorID==odid) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\todm = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdo {\n\t\t\t\t\tfprintf(stderr, \"Enter file radical name (+\\'.x\\' for XML dumping) - \\\"std\\\" for stderr: \");\n\t\t\t\t\tfflush(stderr);\n\t\t\t\t} while( 1 > scanf(\"%s\", radname));\n\t\t\t\tsExt = strrchr(radname, '.');\n\t\t\t\txml_dump = 0;\n\t\t\t\tif (sExt) {\n\t\t\t\t\tif (!stricmp(sExt, \".x\")) xml_dump = 1;\n\t\t\t\t\tsExt[0] = 0;\n\t\t\t\t}\n\t\t\t\tstd_out = strnicmp(radname, \"std\", 3) ? 0 : 1;\n\t\t\t\te = gf_term_dump_scene(term, std_out ? NULL : radname, NULL, xml_dump, 0, odm);\n\t\t\t\tfprintf(stderr, \"Dump done (%s)\\n\", gf_error_to_string(e));\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'c':\n\t\t\tPrintGPACConfig();\n\t\t\tbreak;\n\t\tcase '3':\n\t\t{\n\t\t\tBool use_3d = !gf_term_get_option(term, GF_OPT_USE_OPENGL);\n\t\t\tif (gf_term_set_option(term, GF_OPT_USE_OPENGL, use_3d)==GF_OK) {\n\t\t\t\tfprintf(stderr, \"Using %s for 2D drawing\\n\", use_3d ? \"OpenGL\" : \"2D rasterizer\");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase 'k':\n\t\t{\n\t\t\tBool opt = gf_term_get_option(term, GF_OPT_STRESS_MODE);\n\t\t\topt = !opt;\n\t\t\tfprintf(stderr, \"Turning stress mode %s\\n\", opt ? \"on\" : \"off\");\n\t\t\tgf_term_set_option(term, GF_OPT_STRESS_MODE, opt);\n\t\t}\n\t\tbreak;\n\t\tcase '4':\n\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_4_3);\n\t\t\tbreak;\n\t\tcase '5':\n\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_16_9);\n\t\t\tbreak;\n\t\tcase '6':\n\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_FILL_SCREEN);\n\t\t\tbreak;\n\t\tcase '7':\n\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_KEEP);\n\t\t\tbreak;\n\n\t\tcase 'C':\n\t\t\tswitch (gf_term_get_option(term, GF_OPT_MEDIA_CACHE)) {\n\t\t\tcase GF_MEDIA_CACHE_DISABLED:\n\t\t\t\tgf_term_set_option(term, GF_OPT_MEDIA_CACHE, GF_MEDIA_CACHE_ENABLED);\n\t\t\t\tbreak;\n\t\t\tcase GF_MEDIA_CACHE_ENABLED:\n\t\t\t\tgf_term_set_option(term, GF_OPT_MEDIA_CACHE, GF_MEDIA_CACHE_DISABLED);\n\t\t\t\tbreak;\n\t\t\tcase GF_MEDIA_CACHE_RUNNING:\n\t\t\t\tfprintf(stderr, \"Streaming Cache is running - please stop it first\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tswitch (gf_term_get_option(term, GF_OPT_MEDIA_CACHE)) {\n\t\t\tcase GF_MEDIA_CACHE_ENABLED:\n\t\t\t\tfprintf(stderr, \"Streaming Cache Enabled\\n\");\n\t\t\t\tbreak;\n\t\t\tcase GF_MEDIA_CACHE_DISABLED:\n\t\t\t\tfprintf(stderr, \"Streaming Cache Disabled\\n\");\n\t\t\t\tbreak;\n\t\t\tcase GF_MEDIA_CACHE_RUNNING:\n\t\t\t\tfprintf(stderr, \"Streaming Cache Running\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'S':\n\t\tcase 'A':\n\t\t\tif (gf_term_get_option(term, GF_OPT_MEDIA_CACHE)==GF_MEDIA_CACHE_RUNNING) {\n\t\t\t\tgf_term_set_option(term, GF_OPT_MEDIA_CACHE, (c=='S') ? GF_MEDIA_CACHE_DISABLED : GF_MEDIA_CACHE_DISCARD);\n\t\t\t\tfprintf(stderr, \"Streaming Cache stopped\\n\");\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"Streaming Cache not running\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tdisplay_rti = !display_rti;\n\t\t\tResetCaption();\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tif (display_rti) display_rti = 0;\n\t\t\telse display_rti = 2;\n\t\t\tResetCaption();\n\t\t\tbreak;\n\n\t\tcase 'u':\n\t\t{\n\t\t\tGF_Err e;\n\t\t\tchar szCom[8192];\n\t\t\tfprintf(stderr, \"Enter command to send:\\n\");\n\t\t\tfflush(stdin);\n\t\t\tszCom[0] = 0;\n\t\t\tif (1 > scanf(\"%[^\\t\\n]\", szCom)) {\n\t\t\t\tfprintf(stderr, \"Cannot read command to send, aborting.\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\te = gf_term_scene_update(term, NULL, szCom);\n\t\t\tif (e) fprintf(stderr, \"Processing command failed: %s\\n\", gf_error_to_string(e));\n\t\t}\n\t\tbreak;\n\t\tcase 'e':\n\t\t{\n\t\t\tGF_Err e;\n\t\t\tchar jsCode[8192];\n\t\t\tfprintf(stderr, \"Enter JavaScript code to evaluate:\\n\");\n\t\t\tfflush(stdin);\n\t\t\tjsCode[0] = 0;\n\t\t\tif (1 > scanf(\"%[^\\t\\n]\", jsCode)) {\n\t\t\t\tfprintf(stderr, \"Cannot read code to evaluate, aborting.\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\te = gf_term_scene_update(term, \"application/ecmascript\", jsCode);\n\t\t\tif (e) fprintf(stderr, \"Processing JS code failed: %s\\n\", gf_error_to_string(e));\n\t\t}\n\t\tbreak;\n\n\t\tcase 'L':\n\t\t{\n\t\t\tchar szLog[1024], *cur_logs;\n\t\t\tcur_logs = gf_log_get_tools_levels();\n\t\t\tfprintf(stderr, \"Enter new log level (current tools %s):\\n\", cur_logs);\n\t\t\tgf_free(cur_logs);\n\t\t\tif (scanf(\"%s\", szLog) < 1) {\n\t\t\t\tfprintf(stderr, \"Cannot read new log level, aborting.\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgf_log_modify_tools_levels(szLog);\n\t\t}\n\t\tbreak;\n\n\t\tcase 'g':\n\t\t{\n\t\t\tGF_SystemRTInfo rti;\n\t\t\tgf_sys_get_rti(rti_update_time_ms, &rti, 0);\n\t\t\tfprintf(stderr, \"GPAC allocated memory \"LLD\"\\n\", rti.gpac_memory);\n\t\t}\n\t\tbreak;\n\t\tcase 'M':\n\t\t{\n\t\t\tu32 size;\n\t\t\tdo {\n\t\t\t\tfprintf(stderr, \"Enter new video cache memory in kBytes (current %ud):\\n\", gf_term_get_option(term, GF_OPT_VIDEO_CACHE_SIZE));\n\t\t\t} while (1 > scanf(\"%ud\", &size));\n\t\t\tgf_term_set_option(term, GF_OPT_VIDEO_CACHE_SIZE, size);\n\t\t}\n\t\tbreak;\n\n\t\tcase 'H':\n\t\t{\n\t\t\tu32 http_bitrate = gf_term_get_option(term, GF_OPT_HTTP_MAX_RATE);\n\t\t\tdo {\n\t\t\t\tfprintf(stderr, \"Enter new http bitrate in bps (0 for none) - current limit: %d\\n\", http_bitrate);\n\t\t\t} while (1 > scanf(\"%ud\", &http_bitrate));\n\n\t\t\tgf_term_set_option(term, GF_OPT_HTTP_MAX_RATE, http_bitrate);\n\t\t}\n\t\tbreak;\n\n\t\tcase 'E':\n\t\t\tgf_term_set_option(term, GF_OPT_RELOAD_CONFIG, 1);\n\t\t\tbreak;\n\n\t\tcase 'B':\n\t\t\tswitch_bench(!bench_mode);\n\t\t\tbreak;\n\n\t\tcase 'Y':\n\t\t{\n\t\t\tchar szOpt[8192];\n\t\t\tfprintf(stderr, \"Enter option to set (Section:Name=Value):\\n\");\n\t\t\tfflush(stdin);\n\t\t\tszOpt[0] = 0;\n\t\t\tif (1 > scanf(\"%[^\\t\\n]\", szOpt)) {\n\t\t\t\tfprintf(stderr, \"Cannot read option\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tset_cfg_option(szOpt);\n\t\t}\n\t\tbreak;\n\n\t\t/*extract to PNG*/\n\t\tcase 'Z':\n\t\t{\n\t\t\tchar szFileName[100];\n\t\t\tu32 nb_pass, nb_views, offscreen_view = 0;\n\t\t\tGF_VideoSurface fb;\n\t\t\tGF_Err e;\n\t\t\tnb_pass = 1;\n\t\t\tnb_views = gf_term_get_option(term, GF_OPT_NUM_STEREO_VIEWS);\n\t\t\tif (nb_views>1) {\n\t\t\t\tfprintf(stderr, \"Auto-stereo mode detected - type number of view to dump (0 is main output, 1 to %d offscreen view, %d for all offscreen, %d for all offscreen and main)\\n\", nb_views, nb_views+1, nb_views+2);\n\t\t\t\tif (scanf(\"%d\", &offscreen_view) != 1) {\n\t\t\t\t\toffscreen_view = 0;\n\t\t\t\t}\n\t\t\t\tif (offscreen_view==nb_views+1) {\n\t\t\t\t\toffscreen_view = 1;\n\t\t\t\t\tnb_pass = nb_views;\n\t\t\t\t}\n\t\t\t\telse if (offscreen_view==nb_views+2) {\n\t\t\t\t\toffscreen_view = 0;\n\t\t\t\t\tnb_pass = nb_views+1;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (nb_pass) {\n\t\t\t\tnb_pass--;\n\t\t\t\tif (offscreen_view) {\n\t\t\t\t\tsprintf(szFileName, \"view%d_dump.png\", offscreen_view);\n\t\t\t\t\te = gf_term_get_offscreen_buffer(term, &fb, offscreen_view-1, 0);\n\t\t\t\t} else {\n\t\t\t\t\tsprintf(szFileName, \"gpac_video_dump_\"LLU\".png\", gf_net_get_utc() );\n\t\t\t\t\te = gf_term_get_screen_buffer(term, &fb);\n\t\t\t\t}\n\t\t\t\toffscreen_view++;\n\t\t\t\tif (e) {\n\t\t\t\t\tfprintf(stderr, \"Error dumping screen buffer %s\\n\", gf_error_to_string(e) );\n\t\t\t\t\tnb_pass = 0;\n\t\t\t\t} else {\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\t\tu32 dst_size = fb.width*fb.height*4;\n\t\t\t\t\tchar *dst = (char*)gf_malloc(sizeof(char)*dst_size);\n\n\t\t\t\t\te = gf_img_png_enc(fb.video_buffer, fb.width, fb.height, fb.pitch_y, fb.pixel_format, dst, &dst_size);\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\tfprintf(stderr, \"Error encoding PNG %s\\n\", gf_error_to_string(e) );\n\t\t\t\t\t\tnb_pass = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tFILE *png = gf_fopen(szFileName, \"wb\");\n\t\t\t\t\t\tif (!png) {\n\t\t\t\t\t\t\tfprintf(stderr, \"Error writing file %s\\n\", szFileName);\n\t\t\t\t\t\t\tnb_pass = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgf_fwrite(dst, dst_size, 1, png);\n\t\t\t\t\t\t\tgf_fclose(png);\n\t\t\t\t\t\t\tfprintf(stderr, \"Dump to %s\\n\", szFileName);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (dst) gf_free(dst);\n\t\t\t\t\tgf_term_release_screen_buffer(term, &fb);\n#endif //GPAC_DISABLE_AV_PARSERS\n\t\t\t\t}\n\t\t\t}\n\t\t\tfprintf(stderr, \"Done: %s\\n\", szFileName);\n\t\t}\n\t\tbreak;\n\n\t\tcase 'G':\n\t\t{\n\t\t\tGF_ObjectManager *root_od, *odm;\n\t\t\tu32 index;\n\t\t\tchar szOpt[8192];\n\t\t\tfprintf(stderr, \"Enter 0-based index of object to select or service ID:\\n\");\n\t\t\tfflush(stdin);\n\t\t\tszOpt[0] = 0;\n\t\t\tif (1 > scanf(\"%[^\\t\\n]\", szOpt)) {\n\t\t\t\tfprintf(stderr, \"Cannot read OD ID\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tindex = atoi(szOpt);\n\t\t\todm = NULL;\n\t\t\troot_od = gf_term_get_root_object(term);\n\t\t\tif (root_od) {\n\t\t\t\tif ( gf_term_find_service(term, root_od, index)) {\n\t\t\t\t\tgf_term_select_service(term, root_od, index);\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"Cannot find service %d - trying with object index\\n\", index);\n\t\t\t\t\todm = gf_term_get_object(term, root_od, index);\n\t\t\t\t\tif (odm) {\n\t\t\t\t\t\tgf_term_select_object(term, odm);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfprintf(stderr, \"Cannot find object at index %d\\n\", index);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase 'h':\n\t\t\tPrintHelp();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (bench_mode) {\n\t\tPrintAVInfo(GF_TRUE);\n\t}\n\n\t/*FIXME: we have an issue in cleaning up after playing in bench mode and run-for 0 (buildbot tests). We for now disable error checks after run-for is done*/\n\tif (simulation_time_in_ms) {\n\t\tgf_log_set_strict_error(0);\n\t}\n\n\n\ti = gf_sys_clock();\n\tgf_term_disconnect(term);\n\tif (rti_file) UpdateRTInfo(\"Disconnected\\n\");\n\n\tfprintf(stderr, \"Deleting terminal... \");\n\tif (playlist) gf_fclose(playlist);\n\n#if defined(__DARWIN__) || defined(__APPLE__)\n\tcarbon_uninit();\n#endif\n\n\tgf_term_del(term);\n\tfprintf(stderr, \"done (in %d ms) - ran for %d ms\\n\", gf_sys_clock() - i, gf_sys_clock());\n\n\tfprintf(stderr, \"GPAC cleanup ...\\n\");\n\tgf_modules_del(user.modules);\n\n\tif (no_cfg_save)\n\t\tgf_cfg_discard_changes(cfg_file);\n\n\tgf_cfg_del(cfg_file);\n\n\tgf_sys_close();\n\n\tif (rti_logs) gf_fclose(rti_logs);\n\tif (logfile) gf_fclose(logfile);\n\n\tif (gui_mode) {\n\t\thide_shell(2);\n\t}\n\n#ifdef GPAC_MEMORY_TRACKING\n\tif (mem_track && (gf_memory_size() || gf_file_handles_count() )) {\n\t        gf_log_set_tool_level(GF_LOG_MEMORY, GF_LOG_INFO);\n\t\tgf_memory_print();\n\t\treturn 2;\n\t}\n#endif\n\n\treturn ret_val;\n}\n",
    "code_after_change": "int mp4client_main(int argc, char **argv)\n{\n\tchar c;\n\tconst char *str;\n\tint ret_val = 0;\n\tu32 i, times[100], nb_times, dump_mode;\n\tu32 simulation_time_in_ms = 0;\n\tu32 initial_service_id = 0;\n\tBool auto_exit = GF_FALSE;\n\tBool logs_set = GF_FALSE;\n\tBool start_fs = GF_FALSE;\n\tBool use_rtix = GF_FALSE;\n\tBool pause_at_first = GF_FALSE;\n\tBool no_cfg_save = GF_FALSE;\n\tBool is_cfg_only = GF_FALSE;\n\n\tDouble play_from = 0;\n#ifdef GPAC_MEMORY_TRACKING\n    GF_MemTrackerType mem_track = GF_MemTrackerNone;\n#endif\n\tDouble fps = GF_IMPORT_DEFAULT_FPS;\n\tBool fill_ar, visible, do_uncache, has_command;\n\tchar *url_arg, *out_arg, *the_cfg, *rti_file, *views, *mosaic;\n\tFILE *logfile = NULL;\n\tFloat scale = 1;\n#ifndef WIN32\n\tdlopen(NULL, RTLD_NOW|RTLD_GLOBAL);\n#endif\n\n\t/*by default use current dir*/\n\tstrcpy(the_url, \".\");\n\n\tmemset(&user, 0, sizeof(GF_User));\n\n\tdump_mode = DUMP_NONE;\n\tfill_ar = visible = do_uncache = has_command = GF_FALSE;\n\turl_arg = out_arg = the_cfg = rti_file = views = mosaic = NULL;\n\tnb_times = 0;\n\ttimes[0] = 0;\n\n\t/*first locate config file if specified*/\n\tfor (i=1; i<(u32) argc; i++) {\n\t\tchar *arg = argv[i];\n\t\tif (!strcmp(arg, \"-c\") || !strcmp(arg, \"-cfg\")) {\n\t\t\tthe_cfg = argv[i+1];\n\t\t\ti++;\n\t\t}\n\t\telse if (!strcmp(arg, \"-mem-track\") || !strcmp(arg, \"-mem-track-stack\")) {\n#ifdef GPAC_MEMORY_TRACKING\n            mem_track = !strcmp(arg, \"-mem-track-stack\") ? GF_MemTrackerBackTrace : GF_MemTrackerSimple;\n#else\n\t\t\tfprintf(stderr, \"WARNING - GPAC not compiled with Memory Tracker - ignoring \\\"%s\\\"\\n\", arg);\n#endif\n\t\t} else if (!strcmp(arg, \"-gui\")) {\n\t\t\tgui_mode = 1;\n\t\t} else if (!strcmp(arg, \"-guid\")) {\n\t\t\tgui_mode = 2;\n\t\t} else if (!strcmp(arg, \"-h\") || !strcmp(arg, \"-help\")) {\n\t\t\tPrintUsage();\n\t\t\treturn 0;\n\t\t}\n\t}\n\n#ifdef GPAC_MEMORY_TRACKING\n\tgf_sys_init(mem_track);\n#else\n\tgf_sys_init(GF_MemTrackerNone);\n#endif\n\tgf_sys_set_args(argc, (const char **) argv);\n\n\tcfg_file = gf_cfg_init(the_cfg, NULL);\n\tif (!cfg_file) {\n\t\tfprintf(stderr, \"Error: Configuration File not found\\n\");\n\t\treturn 1;\n\t}\n\t/*if logs are specified, use them*/\n\tif (gf_log_set_tools_levels( gf_cfg_get_key(cfg_file, \"General\", \"Logs\") ) != GF_OK) {\n\t\treturn 1;\n\t}\n\n\tif( gf_cfg_get_key(cfg_file, \"General\", \"Logs\") != NULL ) {\n\t\tlogs_set = GF_TRUE;\n\t}\n\n\tif (!gui_mode) {\n\t\tstr = gf_cfg_get_key(cfg_file, \"General\", \"ForceGUI\");\n\t\tif (str && !strcmp(str, \"yes\")) gui_mode = 1;\n\t}\n\n\tfor (i=1; i<(u32) argc; i++) {\n\t\tchar *arg = argv[i];\n\n\t\tif (!strcmp(arg, \"-rti\")) {\n\t\t\trti_file = argv[i+1];\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, \"-rtix\")) {\n\t\t\trti_file = argv[i+1];\n\t\t\ti++;\n\t\t\tuse_rtix = GF_TRUE;\n\t\t} else if (!stricmp(arg, \"-size\")) {\n\t\t\t/*usage of %ud breaks sscanf on MSVC*/\n\t\t\tif (sscanf(argv[i+1], \"%dx%d\", &forced_width, &forced_height) != 2) {\n\t\t\t\tforced_width = forced_height = 0;\n\t\t\t}\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, \"-quiet\")) {\n\t\t\tbe_quiet = 1;\n\t\t} else if (!strcmp(arg, \"-strict-error\")) {\n\t\t\tgf_log_set_strict_error(1);\n\t\t} else if (!strcmp(arg, \"-log-file\") || !strcmp(arg, \"-lf\")) {\n\t\t\tlogfile = gf_fopen(argv[i+1], \"wt\");\n\t\t\tgf_log_set_callback(logfile, on_gpac_log);\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, \"-logs\") ) {\n\t\t\tif (gf_log_set_tools_levels(argv[i+1]) != GF_OK) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tlogs_set = GF_TRUE;\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, \"-log-clock\") || !strcmp(arg, \"-lc\")) {\n\t\t\tlog_time_start = 1;\n\t\t} else if (!strcmp(arg, \"-log-utc\") || !strcmp(arg, \"-lu\")) {\n\t\t\tlog_utc_time = 1;\n\t\t}\n#if defined(__DARWIN__) || defined(__APPLE__)\n\t\telse if (!strcmp(arg, \"-thread\")) threading_flags = 0;\n#else\n\t\telse if (!strcmp(arg, \"-no-thread\")) threading_flags = GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_WINDOW_NO_THREAD;\n#endif\n\t\telse if (!strcmp(arg, \"-no-cthread\") || !strcmp(arg, \"-no-compositor-thread\")) threading_flags |= GF_TERM_NO_COMPOSITOR_THREAD;\n\t\telse if (!strcmp(arg, \"-no-audio\")) no_audio = 1;\n\t\telse if (!strcmp(arg, \"-no-regulation\")) no_regulation = 1;\n\t\telse if (!strcmp(arg, \"-fs\")) start_fs = 1;\n\n\t\telse if (!strcmp(arg, \"-opt\")) {\n\t\t\tset_cfg_option(argv[i+1]);\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, \"-conf\")) {\n\t\t\tset_cfg_option(argv[i+1]);\n\t\t\tis_cfg_only=GF_TRUE;\n\t\t\ti++;\n\t\t}\n\t\telse if (!strcmp(arg, \"-ifce\")) {\n\t\t\tgf_cfg_set_key(cfg_file, \"Network\", \"DefaultMCastInterface\", argv[i+1]);\n\t\t\ti++;\n\t\t}\n\t\telse if (!stricmp(arg, \"-help\")) {\n\t\t\tPrintUsage();\n\t\t\treturn 1;\n\t\t}\n\t\telse if (!stricmp(arg, \"-noprog\")) {\n\t\t\tno_prog=1;\n\t\t\tgf_set_progress_callback(NULL, progress_quiet);\n\t\t}\n\t\telse if (!stricmp(arg, \"-no-save\") || !stricmp(arg, \"--no-save\") /*old versions used --n-save ...*/) {\n\t\t\tno_cfg_save=1;\n\t\t}\n\t\telse if (!stricmp(arg, \"-ntp-shift\")) {\n\t\t\ts32 shift = atoi(argv[i+1]);\n\t\t\ti++;\n\t\t\tgf_net_set_ntp_shift(shift);\n\t\t}\n\t\telse if (!stricmp(arg, \"-run-for\")) {\n\t\t\tsimulation_time_in_ms = atoi(argv[i+1]) * 1000;\n\t\t\tif (!simulation_time_in_ms)\n\t\t\t\tsimulation_time_in_ms = 1; /*1ms*/\n\t\t\ti++;\n\t\t}\n\n\t\telse if (!strcmp(arg, \"-out\")) {\n\t\t\tout_arg = argv[i+1];\n\t\t\ti++;\n\t\t}\n\t\telse if (!stricmp(arg, \"-fps\")) {\n\t\t\tfps = atof(argv[i+1]);\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, \"-avi\") || !strcmp(arg, \"-sha\")) {\n\t\t\tdump_mode &= 0xFFFF0000;\n\n\t\t\tif (!strcmp(arg, \"-sha\")) dump_mode |= DUMP_SHA1;\n\t\t\telse dump_mode |= DUMP_AVI;\n\n\t\t\tif ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) {\n\t\t\t\tif (!strcmp(arg, \"-avi\") && (nb_times!=2) ) {\n\t\t\t\t\tfprintf(stderr, \"Only one time arg found for -avi - check usage\\n\");\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t} else if (!strcmp(arg, \"-rgbds\")) { /*get dump in rgbds pixel format*/\n\t\t\t\tdump_mode |= DUMP_RGB_DEPTH_SHAPE;\n\t\t} else if (!strcmp(arg, \"-rgbd\")) { /*get dump in rgbd pixel format*/\n\t\t\t\tdump_mode |= DUMP_RGB_DEPTH;\n\t\t} else if (!strcmp(arg, \"-depth\")) {\n\t\t\t\tdump_mode |= DUMP_DEPTH_ONLY;\n\t\t} else if (!strcmp(arg, \"-bmp\")) {\n\t\t\tdump_mode &= 0xFFFF0000;\n\t\t\tdump_mode |= DUMP_BMP;\n\t\t\tif ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) i++;\n\t\t} else if (!strcmp(arg, \"-png\")) {\n\t\t\tdump_mode &= 0xFFFF0000;\n\t\t\tdump_mode |= DUMP_PNG;\n\t\t\tif ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) i++;\n\t\t} else if (!strcmp(arg, \"-raw\")) {\n\t\t\tdump_mode &= 0xFFFF0000;\n\t\t\tdump_mode |= DUMP_RAW;\n\t\t\tif ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) i++;\n\t\t} else if (!stricmp(arg, \"-scale\")) {\n\t\t\tsscanf(argv[i+1], \"%f\", &scale);\n\t\t\ti++;\n\t\t}\n\t\telse if (!strcmp(arg, \"-c\") || !strcmp(arg, \"-cfg\")) {\n\t\t\t/* already parsed */\n\t\t\ti++;\n\t\t}\n\n\t\t/*arguments only used in non-gui mode*/\n\t\tif (!gui_mode) {\n\t\t\tif (arg[0] != '-') {\n\t\t\t\tif (url_arg) {\n\t\t\t\t\tfprintf(stderr, \"Several input URLs provided (\\\"%s\\\", \\\"%s\\\"). Check your command-line.\\n\", url_arg, arg);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\turl_arg = arg;\n\t\t\t}\n\t\t\telse if (!strcmp(arg, \"-loop\")) loop_at_end = 1;\n\t\t\telse if (!strcmp(arg, \"-bench\")) bench_mode = 1;\n\t\t\telse if (!strcmp(arg, \"-vbench\")) bench_mode = 2;\n\t\t\telse if (!strcmp(arg, \"-sbench\")) bench_mode = 3;\n\t\t\telse if (!strcmp(arg, \"-no-addon\")) enable_add_ons = GF_FALSE;\n\n\t\t\telse if (!strcmp(arg, \"-pause\")) pause_at_first = 1;\n\t\t\telse if (!strcmp(arg, \"-play-from\")) {\n\t\t\t\tplay_from = atof((const char *) argv[i+1]);\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (!strcmp(arg, \"-speed\")) {\n\t\t\t\tplayback_speed = FLT2FIX( atof((const char *) argv[i+1]) );\n\t\t\t\tif (playback_speed <= 0) playback_speed = FIX_ONE;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (!strcmp(arg, \"-no-wnd\")) user.init_flags |= GF_TERM_WINDOWLESS;\n\t\t\telse if (!strcmp(arg, \"-no-back\")) user.init_flags |= GF_TERM_WINDOW_TRANSPARENT;\n\t\t\telse if (!strcmp(arg, \"-align\")) {\n\t\t\t\tif (argv[i+1][0]=='m') align_mode = 1;\n\t\t\t\telse if (argv[i+1][0]=='b') align_mode = 2;\n\t\t\t\talign_mode <<= 8;\n\t\t\t\tif (argv[i+1][1]=='m') align_mode |= 1;\n\t\t\t\telse if (argv[i+1][1]=='r') align_mode |= 2;\n\t\t\t\ti++;\n\t\t\t} else if (!strcmp(arg, \"-fill\")) {\n\t\t\t\tfill_ar = GF_TRUE;\n\t\t\t} else if (!strcmp(arg, \"-show\")) {\n\t\t\t\tvisible = 1;\n\t\t\t} else if (!strcmp(arg, \"-uncache\")) {\n\t\t\t\tdo_uncache = GF_TRUE;\n\t\t\t}\n\t\t\telse if (!strcmp(arg, \"-exit\")) auto_exit = GF_TRUE;\n\t\t\telse if (!stricmp(arg, \"-views\")) {\n\t\t\t\tviews = argv[i+1];\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (!stricmp(arg, \"-mosaic\")) {\n\t\t\t\tmosaic = argv[i+1];\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (!stricmp(arg, \"-com\")) {\n\t\t\t\thas_command = GF_TRUE;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (!stricmp(arg, \"-service\")) {\n\t\t\t\tinitial_service_id = atoi(argv[i+1]);\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\tif (is_cfg_only) {\n\t\tgf_cfg_del(cfg_file);\n\t\tfprintf(stderr, \"GPAC Config updated\\n\");\n\t\treturn 0;\n\t}\n\tif (do_uncache) {\n\t\tconst char *cache_dir = gf_cfg_get_key(cfg_file, \"General\", \"CacheDirectory\");\n\t\tdo_flatten_cache(cache_dir);\n\t\tfprintf(stderr, \"GPAC Cache dir %s flattened\\n\", cache_dir);\n\t\tgf_cfg_del(cfg_file);\n\t\treturn 0;\n\t}\n\n\tif (dump_mode && !url_arg ) {\n\t\tFILE *test;\n\t\turl_arg = (char *)gf_cfg_get_key(cfg_file, \"General\", \"StartupFile\");\n\t\ttest = url_arg ? gf_fopen(url_arg, \"rt\") : NULL;\n\t\tif (!test) url_arg = NULL;\n\t\telse gf_fclose(test);\n\t\t\n\t\tif (!url_arg) {\n\t\t\tfprintf(stderr, \"Missing argument for dump\\n\");\n\t\t\tPrintUsage();\n\t\t\tif (logfile) gf_fclose(logfile);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (!gui_mode && !url_arg && (gf_cfg_get_key(cfg_file, \"General\", \"StartupFile\") != NULL)) {\n\t\tgui_mode=1;\n\t}\n\n#ifdef WIN32\n\tif (gui_mode==1) {\n\t\tconst char *opt;\n\t\tTCHAR buffer[1024];\n\t\tDWORD res = GetCurrentDirectory(1024, buffer);\n\t\tbuffer[res] = 0;\n\t\topt = gf_cfg_get_key(cfg_file, \"General\", \"ModulesDirectory\");\n\t\tif (strstr(opt, buffer)) {\n\t\t\tgui_mode=1;\n\t\t} else {\n\t\t\tgui_mode=2;\n\t\t}\n\t}\n#endif\n\n\tif (gui_mode==1) {\n\t\thide_shell(1);\n\t}\n\tif (gui_mode) {\n\t\tno_prog=1;\n\t\tgf_set_progress_callback(NULL, progress_quiet);\n\t}\n\n\tif (!url_arg && simulation_time_in_ms)\n\t\tsimulation_time_in_ms += gf_sys_clock();\n\n#if defined(__DARWIN__) || defined(__APPLE__)\n\tcarbon_init();\n#endif\n\n\n\tif (dump_mode) rti_file = NULL;\n\n\tif (!logs_set) {\n\t\tgf_log_set_tool_level(GF_LOG_ALL, GF_LOG_WARNING);\n\t}\n\tif (rti_file || logfile || log_utc_time || log_time_start)\n\t\tgf_log_set_callback(NULL, on_gpac_log);\n\n\tif (rti_file) init_rti_logs(rti_file, url_arg, use_rtix);\n\n\t{\n\t\tGF_SystemRTInfo rti;\n\t\tif (gf_sys_get_rti(0, &rti, 0))\n\t\t\tfprintf(stderr, \"System info: %d MB RAM - %d cores\\n\", (u32) (rti.physical_memory/1024/1024), rti.nb_cores);\n\t}\n\n\n\t/*setup dumping options*/\n\tif (dump_mode) {\n\t\tuser.init_flags |= GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_NO_REGULATION;\n\t\tif (!visible)\n\t\t\tuser.init_flags |= GF_TERM_INIT_HIDE;\n\n\t\tgf_cfg_set_key(cfg_file, \"Audio\", \"DriverName\", \"Raw Audio Output\");\n\t\tno_cfg_save=GF_TRUE;\n\t} else {\n\t\tinit_w = forced_width;\n\t\tinit_h = forced_height;\n\t}\n\n\tuser.modules = gf_modules_new(NULL, cfg_file);\n\tif (user.modules) i = gf_modules_get_count(user.modules);\n\tif (!i || !user.modules) {\n\t\tfprintf(stderr, \"Error: no modules found - exiting\\n\");\n\t\tif (user.modules) gf_modules_del(user.modules);\n\t\tgf_cfg_del(cfg_file);\n\t\tgf_sys_close();\n\t\tif (logfile) gf_fclose(logfile);\n\t\treturn 1;\n\t}\n\tfprintf(stderr, \"Modules Found : %d \\n\", i);\n\n\tstr = gf_cfg_get_key(cfg_file, \"General\", \"GPACVersion\");\n\tif (!str || strcmp(str, GPAC_FULL_VERSION)) {\n\t\tgf_cfg_del_section(cfg_file, \"PluginsCache\");\n\t\tgf_cfg_set_key(cfg_file, \"General\", \"GPACVersion\", GPAC_FULL_VERSION);\n\t}\n\n\tuser.config = cfg_file;\n\tuser.EventProc = GPAC_EventProc;\n\t/*dummy in this case (global vars) but MUST be non-NULL*/\n\tuser.opaque = user.modules;\n\tif (threading_flags) user.init_flags |= threading_flags;\n\tif (no_audio) user.init_flags |= GF_TERM_NO_AUDIO;\n\tif (no_regulation) user.init_flags |= GF_TERM_NO_REGULATION;\n\n\tif (threading_flags & (GF_TERM_NO_DECODER_THREAD|GF_TERM_NO_COMPOSITOR_THREAD) ) term_step = GF_TRUE;\n\n\tif (dump_mode) user.init_flags |= GF_TERM_USE_AUDIO_HW_CLOCK;\n\n\tif (bench_mode) {\n\t\tgf_cfg_discard_changes(user.config);\n\t\tauto_exit = GF_TRUE;\n\t\tgf_cfg_set_key(user.config, \"Audio\", \"DriverName\", \"Raw Audio Output\");\n\t\tif (bench_mode!=2) {\n\t\t\tgf_cfg_set_key(user.config, \"Video\", \"DriverName\", \"Raw Video Output\");\n\t\t\tgf_cfg_set_key(user.config, \"RAWVideo\", \"RawOutput\", \"null\");\n\t\t\tgf_cfg_set_key(user.config, \"Compositor\", \"OpenGLMode\", \"disable\");\n\t\t} else {\n\t\t\tgf_cfg_set_key(user.config, \"Video\", \"DisableVSync\", \"yes\");\n\t\t}\n\t}\n\n\t{\n\t\tchar dim[50];\n\t\tsprintf(dim, \"%d\", forced_width);\n\t\tgf_cfg_set_key(user.config, \"Compositor\", \"DefaultWidth\", forced_width ? dim : NULL);\n\t\tsprintf(dim, \"%d\", forced_height);\n\t\tgf_cfg_set_key(user.config, \"Compositor\", \"DefaultHeight\", forced_height ? dim : NULL);\n\t}\n\n\tfprintf(stderr, \"Loading GPAC Terminal\\n\");\n\ti = gf_sys_clock();\n\tterm = gf_term_new(&user);\n\tif (!term) {\n\t\tfprintf(stderr, \"\\nInit error - check you have at least one video out and one rasterizer...\\nFound modules:\\n\");\n\t\tlist_modules(user.modules);\n\t\tgf_modules_del(user.modules);\n\t\tgf_cfg_discard_changes(cfg_file);\n\t\tgf_cfg_del(cfg_file);\n\t\tgf_sys_close();\n\t\tif (logfile) gf_fclose(logfile);\n\t\treturn 1;\n\t}\n\tfprintf(stderr, \"Terminal Loaded in %d ms\\n\", gf_sys_clock()-i);\n\n\tif (bench_mode) {\n\t\tdisplay_rti = 2;\n\t\tgf_term_set_option(term, GF_OPT_VIDEO_BENCH, (bench_mode==3) ? 2 : 1);\n\t\tif (bench_mode==1) bench_mode=2;\n\t}\n\n\tif (dump_mode) {\n\t\tif (fill_ar) gf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_FILL_SCREEN);\n\t} else {\n\t\t/*check video output*/\n\t\tstr = gf_cfg_get_key(cfg_file, \"Video\", \"DriverName\");\n\t\tif (!bench_mode && !strcmp(str, \"Raw Video Output\")) fprintf(stderr, \"WARNING: using raw output video (memory only) - no display used\\n\");\n\t\t/*check audio output*/\n\t\tstr = gf_cfg_get_key(cfg_file, \"Audio\", \"DriverName\");\n\t\tif (!str || !strcmp(str, \"No Audio Output Available\")) fprintf(stderr, \"WARNING: no audio output available - make sure no other program is locking the sound card\\n\");\n\n\t\tstr = gf_cfg_get_key(cfg_file, \"General\", \"NoMIMETypeFetch\");\n\t\tno_mime_check = (str && !stricmp(str, \"yes\")) ? 1 : 0;\n\t}\n\n\tstr = gf_cfg_get_key(cfg_file, \"HTTPProxy\", \"Enabled\");\n\tif (str && !strcmp(str, \"yes\")) {\n\t\tstr = gf_cfg_get_key(cfg_file, \"HTTPProxy\", \"Name\");\n\t\tif (str) fprintf(stderr, \"HTTP Proxy %s enabled\\n\", str);\n\t}\n\n\tif (rti_file) {\n\t\tstr = gf_cfg_get_key(cfg_file, \"General\", \"RTIRefreshPeriod\");\n\t\tif (str) {\n\t\t\trti_update_time_ms = atoi(str);\n\t\t} else {\n\t\t\tgf_cfg_set_key(cfg_file, \"General\", \"RTIRefreshPeriod\", \"200\");\n\t\t}\n\t\tUpdateRTInfo(\"At GPAC load time\\n\");\n\t}\n\n\tRun = 1;\n\n\tif (dump_mode) {\n\t\tif (!nb_times) {\n\t\t\ttimes[0] = 0;\n\t\t\tnb_times++;\n\t\t}\n\t\tret_val = dump_file(url_arg, out_arg, dump_mode, fps, forced_width, forced_height, scale, times, nb_times);\n\t\tRun = 0;\n\t}\n\telse if (views) {\n\t}\n\t/*connect if requested*/\n\telse if (!gui_mode && url_arg) {\n\t\tchar *ext;\n\n\t\tif (strlen(url_arg) >= sizeof(the_url)) {\n\t\t\tfprintf(stderr, \"Input url %s is too long, truncating to %d chars.\\n\", url_arg, (int)(sizeof(the_url) - 1));\n\t\t\tstrncpy(the_url, url_arg, sizeof(the_url)-1);\n\t\t\tthe_url[sizeof(the_url) - 1] = 0;\n\t\t}\n\t\telse {\n\t\t\tstrcpy(the_url, url_arg);\n\t\t}\n\t\text = strrchr(the_url, '.');\n\t\tif (ext && (!stricmp(ext, \".m3u\") || !stricmp(ext, \".pls\"))) {\n\t\t\tGF_Err e = GF_OK;\n\t\t\tfprintf(stderr, \"Opening Playlist %s\\n\", the_url);\n\n\t\t\tstrcpy(pl_path, the_url);\n\t\t\t/*this is not clean, we need to have a plugin handle playlist for ourselves*/\n\t\t\tif (!strncmp(\"http:\", the_url, 5)) {\n\t\t\t\tGF_DownloadSession *sess = gf_dm_sess_new(term->downloader, the_url, GF_NETIO_SESSION_NOT_THREADED, NULL, NULL, &e);\n\t\t\t\tif (sess) {\n \t\t\t\t\te = gf_dm_sess_process(sess);\n \t\t\t\t\tif (!e) {\n \t\t\t\t\t\tstrncpy(the_url, gf_dm_sess_get_cache_name(sess), sizeof(the_url) - 1);\n\t\t\t\t\t\tthe_url[sizeof(the_url) - 1] = 0;\n \t\t\t\t\t}\n \t\t\t\t\tgf_dm_sess_del(sess);\n \t\t\t\t}\n\t\t\t}\n\n\t\t\tplaylist = e ? NULL : gf_fopen(the_url, \"rt\");\n\t\t\treadonly_playlist = 1;\n\t\t\tif (playlist) {\n\t\t\t\trequest_next_playlist_item = GF_TRUE;\n\t\t\t} else {\n\t\t\t\tif (e)\n\t\t\t\t\tfprintf(stderr, \"Failed to open playlist %s: %s\\n\", the_url, gf_error_to_string(e) );\n\t\t\t\tfprintf(stderr, \"Hit 'h' for help\\n\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tfprintf(stderr, \"Opening URL %s\\n\", the_url);\n\t\t\tif (pause_at_first) fprintf(stderr, \"[Status: Paused]\\n\");\n\t\t\tgf_term_connect_from_time(term, the_url, (u64) (play_from*1000), pause_at_first);\n\t\t}\n\t} else {\n\t\tfprintf(stderr, \"Hit 'h' for help\\n\\n\");\n\t\tstr = gf_cfg_get_key(cfg_file, \"General\", \"StartupFile\");\n\t\tif (str) {\n\t\t\tstrncpy(the_url, \"MP4Client \"GPAC_FULL_VERSION , sizeof(the_url)-1);\n\t\t\tthe_url[sizeof(the_url) - 1] = 0;\n\t\t\tgf_term_connect(term, str);\n\t\t\tstartup_file = 1;\n\t\t\tis_connected = 1;\n\t\t}\n\t}\n\tif (gui_mode==2) gui_mode=0;\n\n\tif (start_fs) gf_term_set_option(term, GF_OPT_FULLSCREEN, 1);\n\n\tif (views) {\n\t\tchar szTemp[4046];\n\t\tsprintf(szTemp, \"views://%s\", views);\n\t\tgf_term_connect(term, szTemp);\n\t}\n\tif (mosaic) {\n\t\tchar szTemp[4046];\n\t\tsprintf(szTemp, \"mosaic://%s\", mosaic);\n\t\tgf_term_connect(term, szTemp);\n\t}\n\tif (bench_mode) {\n\t\trti_update_time_ms = 500;\n\t\tbench_mode_start = gf_sys_clock();\n\t}\n\n\n\twhile (Run) {\n\n\t\t/*we don't want getchar to block*/\n\t\tif ((gui_mode==1) || !gf_prompt_has_input()) {\n\t\t\tif (reload) {\n\t\t\t\treload = 0;\n\t\t\t\tgf_term_disconnect(term);\n\t\t\t\tgf_term_connect(term, startup_file ? gf_cfg_get_key(cfg_file, \"General\", \"StartupFile\") : the_url);\n\t\t\t}\n\t\t\tif (restart && gf_term_get_option(term, GF_OPT_IS_OVER)) {\n\t\t\t\trestart = 0;\n\t\t\t\tgf_term_play_from_time(term, 0, 0);\n\t\t\t}\n\t\t\tif (request_next_playlist_item) {\n\t\t\t\tc = '\\n';\n\t\t\t\trequest_next_playlist_item = 0;\n\t\t\t\tgoto force_input;\n\t\t\t}\n\n\t\t\tif (has_command && is_connected) {\n\t\t\t\thas_command = GF_FALSE;\n\t\t\t\tfor (i=0; i<(u32)argc; i++) {\n\t\t\t\t\tif (!strcmp(argv[i], \"-com\")) {\n\t\t\t\t\t\tgf_term_scene_update(term, NULL, argv[i+1]);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (initial_service_id && is_connected) {\n\t\t\t\tGF_ObjectManager *root_od = gf_term_get_root_object(term);\n\t\t\t\tif (root_od) {\n\t\t\t\t\tgf_term_select_service(term, root_od, initial_service_id);\n\t\t\t\t\tinitial_service_id = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!use_rtix || display_rti) UpdateRTInfo(NULL);\n\t\t\tif (term_step) {\n\t\t\t\tgf_term_process_step(term);\n\t\t\t} else {\n\t\t\t\tgf_sleep(rti_update_time_ms);\n\t\t\t}\n\t\t\tif (auto_exit && eos_seen && gf_term_get_option(term, GF_OPT_IS_OVER)) {\n\t\t\t\tRun = GF_FALSE;\n\t\t\t}\n\n\t\t\t/*sim time*/\n\t\t\tif (simulation_time_in_ms\n\t\t\t        && ( (gf_term_get_elapsed_time_in_ms(term)>simulation_time_in_ms) || (!url_arg && gf_sys_clock()>simulation_time_in_ms))\n\t\t\t   ) {\n\t\t\t\tRun = GF_FALSE;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tc = gf_prompt_get_char();\n\nforce_input:\n\t\tswitch (c) {\n\t\tcase 'q':\n\t\t{\n\t\t\tGF_Event evt;\n\t\t\tmemset(&evt, 0, sizeof(GF_Event));\n\t\t\tevt.type = GF_EVENT_QUIT;\n\t\t\tgf_term_send_event(term, &evt);\n\t\t}\n\t\tbreak;\n\t\tcase 'X':\n\t\t\texit(0);\n\t\t\tbreak;\n\t\tcase 'Q':\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tstartup_file = 0;\n\t\t\tgf_term_disconnect(term);\n\t\t\tfprintf(stderr, \"Enter the absolute URL\\n\");\n\t\t\tif (1 > scanf(\"%s\", the_url)) {\n\t\t\t\tfprintf(stderr, \"Cannot read absolute URL, aborting\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (rti_file) init_rti_logs(rti_file, the_url, use_rtix);\n\t\t\tgf_term_connect(term, the_url);\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tgf_term_disconnect(term);\n\t\t\tfprintf(stderr, \"Enter the absolute URL to the playlist\\n\");\n\t\t\tif (1 > scanf(\"%s\", the_url)) {\n\t\t\t\tfprintf(stderr, \"Cannot read the absolute URL, aborting.\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tplaylist = gf_fopen(the_url, \"rt\");\n\t\t\tif (playlist) {\n\t\t\t\tif (1 >\tfscanf(playlist, \"%s\", the_url)) {\n\t\t\t\t\tfprintf(stderr, \"Cannot read any URL from playlist, aborting.\\n\");\n\t\t\t\t\tgf_fclose( playlist);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"Opening URL %s\\n\", the_url);\n\t\t\t\tgf_term_connect(term, the_url);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '\\n':\n\t\tcase 'N':\n\t\t\tif (playlist) {\n\t\t\t\tint res;\n\t\t\t\tgf_term_disconnect(term);\n\n\t\t\t\tres = fscanf(playlist, \"%s\", the_url);\n\t\t\t\tif ((res == EOF) && loop_at_end) {\n\t\t\t\t\tfseek(playlist, 0, SEEK_SET);\n\t\t\t\t\tres = fscanf(playlist, \"%s\", the_url);\n\t\t\t\t}\n\t\t\t\tif (res == EOF) {\n\t\t\t\t\tfprintf(stderr, \"No more items - exiting\\n\");\n\t\t\t\t\tRun = 0;\n\t\t\t\t} else if (the_url[0] == '#') {\n\t\t\t\t\trequest_next_playlist_item = GF_TRUE;\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"Opening URL %s\\n\", the_url);\n\t\t\t\t\tgf_term_connect_with_path(term, the_url, pl_path);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tif (playlist) {\n\t\t\t\tu32 count;\n\t\t\t\tgf_term_disconnect(term);\n\t\t\t\tif (1 > scanf(\"%u\", &count)) {\n\t\t\t\t\tfprintf(stderr, \"Cannot read number, aborting.\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\twhile (count) {\n\t\t\t\t\tif (fscanf(playlist, \"%s\", the_url)) {\n\t\t\t\t\t\tfprintf(stderr, \"Failed to read line, aborting\\n\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcount--;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"Opening URL %s\\n\", the_url);\n\t\t\t\tgf_term_connect(term, the_url);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tif (is_connected)\n\t\t\t\treload = 1;\n\t\t\tbreak;\n\n\t\tcase 'D':\n\t\t\tif (is_connected) gf_term_disconnect(term);\n\t\t\tbreak;\n\n\t\tcase 'p':\n\t\t\tif (is_connected) {\n\t\t\t\tBool is_pause = gf_term_get_option(term, GF_OPT_PLAY_STATE);\n\t\t\t\tfprintf(stderr, \"[Status: %s]\\n\", is_pause ? \"Playing\" : \"Paused\");\n\t\t\t\tgf_term_set_option(term, GF_OPT_PLAY_STATE, is_pause ? GF_STATE_PLAYING : GF_STATE_PAUSED);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tif (is_connected) {\n\t\t\t\tgf_term_set_option(term, GF_OPT_PLAY_STATE, GF_STATE_STEP_PAUSE);\n\t\t\t\tfprintf(stderr, \"Step time: \");\n\t\t\t\tPrintTime(gf_term_get_time_in_ms(term));\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'z':\n\t\tcase 'T':\n\t\t\tif (!CanSeek || (Duration<=2000)) {\n\t\t\t\tfprintf(stderr, \"scene not seekable\\n\");\n\t\t\t} else {\n\t\t\t\tDouble res;\n\t\t\t\ts32 seekTo;\n\t\t\t\tfprintf(stderr, \"Duration: \");\n\t\t\t\tPrintTime(Duration);\n\t\t\t\tres = gf_term_get_time_in_ms(term);\n\t\t\t\tif (c=='z') {\n\t\t\t\t\tres *= 100;\n\t\t\t\t\tres /= (s64)Duration;\n\t\t\t\t\tfprintf(stderr, \" (current %.2f %%)\\nEnter Seek percentage:\\n\", res);\n\t\t\t\t\tif (scanf(\"%d\", &seekTo) == 1) {\n\t\t\t\t\t\tif (seekTo > 100) seekTo = 100;\n\t\t\t\t\t\tres = (Double)(s64)Duration;\n\t\t\t\t\t\tres /= 100;\n\t\t\t\t\t\tres *= seekTo;\n\t\t\t\t\t\tgf_term_play_from_time(term, (u64) (s64) res, 0);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tu32 r, h, m, s;\n\t\t\t\t\tfprintf(stderr, \" - Current Time: \");\n\t\t\t\t\tPrintTime((u64) res);\n\t\t\t\t\tfprintf(stderr, \"\\nEnter seek time (Format: s, m:s or h:m:s):\\n\");\n\t\t\t\t\th = m = s = 0;\n\t\t\t\t\tr =scanf(\"%d:%d:%d\", &h, &m, &s);\n\t\t\t\t\tif (r==2) {\n\t\t\t\t\t\ts = m;\n\t\t\t\t\t\tm = h;\n\t\t\t\t\t\th = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse if (r==1) {\n\t\t\t\t\t\ts = h;\n\t\t\t\t\t\tm = h = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (r && (r<=3)) {\n\t\t\t\t\t\tu64 time = h*3600 + m*60 + s;\n\t\t\t\t\t\tgf_term_play_from_time(term, time*1000, 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 't':\n\t\t{\n\t\t\tif (is_connected) {\n\t\t\t\tfprintf(stderr, \"Current Time: \");\n\t\t\t\tPrintTime(gf_term_get_time_in_ms(term));\n\t\t\t\tfprintf(stderr, \" - Duration: \");\n\t\t\t\tPrintTime(Duration);\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase 'w':\n\t\t\tif (is_connected) PrintWorldInfo(term);\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tif (is_connected) PrintODList(term, NULL, 0, 0, \"Root\");\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tif (is_connected) {\n\t\t\t\tu32 ID;\n\t\t\t\tfprintf(stderr, \"Enter OD ID (0 for main OD): \");\n\t\t\t\tfflush(stderr);\n\t\t\t\tif (scanf(\"%ud\", &ID) == 1) {\n\t\t\t\t\tViewOD(term, ID, (u32)-1, NULL);\n\t\t\t\t} else {\n\t\t\t\t\tchar str_url[GF_MAX_PATH];\n\t\t\t\t\tif (scanf(\"%s\", str_url) == 1)\n\t\t\t\t\t\tViewOD(term, 0, (u32)-1, str_url);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'j':\n\t\t\tif (is_connected) {\n\t\t\t\tu32 num;\n\t\t\t\tdo {\n\t\t\t\t\tfprintf(stderr, \"Enter OD number (0 for main OD): \");\n\t\t\t\t\tfflush(stderr);\n\t\t\t\t} while( 1 > scanf(\"%ud\", &num));\n\t\t\t\tViewOD(term, (u32)-1, num, NULL);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tif (is_connected) ViewODs(term, 1);\n\t\t\tbreak;\n\n\t\tcase 'm':\n\t\t\tif (is_connected) ViewODs(term, 0);\n\t\t\tbreak;\n\n\t\tcase 'l':\n\t\t\tlist_modules(user.modules);\n\t\t\tbreak;\n\n\t\tcase 'n':\n\t\t\tif (is_connected) set_navigation();\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\tif (is_connected) gf_term_set_option(term, GF_OPT_NAVIGATION_TYPE, 0);\n\t\t\tbreak;\n\n\t\tcase 'd':\n\t\t\tif (is_connected) {\n\t\t\t\tGF_ObjectManager *odm = NULL;\n\t\t\t\tchar radname[GF_MAX_PATH], *sExt;\n\t\t\t\tGF_Err e;\n\t\t\t\tu32 i, count, odid;\n\t\t\t\tBool xml_dump, std_out;\n\t\t\t\tradname[0] = 0;\n\t\t\t\tdo {\n\t\t\t\t\tfprintf(stderr, \"Enter Inline OD ID if any or 0 : \");\n\t\t\t\t\tfflush(stderr);\n\t\t\t\t} while( 1 >  scanf(\"%ud\", &odid));\n\t\t\t\tif (odid) {\n\t\t\t\t\tGF_ObjectManager *root_odm = gf_term_get_root_object(term);\n\t\t\t\t\tif (!root_odm) break;\n\t\t\t\t\tcount = gf_term_get_object_count(term, root_odm);\n\t\t\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\t\t\tGF_MediaInfo info;\n\t\t\t\t\t\todm = gf_term_get_object(term, root_odm, i);\n\t\t\t\t\t\tif (gf_term_get_object_info(term, odm, &info) == GF_OK) {\n\t\t\t\t\t\t\tif (info.od->objectDescriptorID==odid) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\todm = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdo {\n\t\t\t\t\tfprintf(stderr, \"Enter file radical name (+\\'.x\\' for XML dumping) - \\\"std\\\" for stderr: \");\n\t\t\t\t\tfflush(stderr);\n\t\t\t\t} while( 1 > scanf(\"%s\", radname));\n\t\t\t\tsExt = strrchr(radname, '.');\n\t\t\t\txml_dump = 0;\n\t\t\t\tif (sExt) {\n\t\t\t\t\tif (!stricmp(sExt, \".x\")) xml_dump = 1;\n\t\t\t\t\tsExt[0] = 0;\n\t\t\t\t}\n\t\t\t\tstd_out = strnicmp(radname, \"std\", 3) ? 0 : 1;\n\t\t\t\te = gf_term_dump_scene(term, std_out ? NULL : radname, NULL, xml_dump, 0, odm);\n\t\t\t\tfprintf(stderr, \"Dump done (%s)\\n\", gf_error_to_string(e));\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'c':\n\t\t\tPrintGPACConfig();\n\t\t\tbreak;\n\t\tcase '3':\n\t\t{\n\t\t\tBool use_3d = !gf_term_get_option(term, GF_OPT_USE_OPENGL);\n\t\t\tif (gf_term_set_option(term, GF_OPT_USE_OPENGL, use_3d)==GF_OK) {\n\t\t\t\tfprintf(stderr, \"Using %s for 2D drawing\\n\", use_3d ? \"OpenGL\" : \"2D rasterizer\");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase 'k':\n\t\t{\n\t\t\tBool opt = gf_term_get_option(term, GF_OPT_STRESS_MODE);\n\t\t\topt = !opt;\n\t\t\tfprintf(stderr, \"Turning stress mode %s\\n\", opt ? \"on\" : \"off\");\n\t\t\tgf_term_set_option(term, GF_OPT_STRESS_MODE, opt);\n\t\t}\n\t\tbreak;\n\t\tcase '4':\n\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_4_3);\n\t\t\tbreak;\n\t\tcase '5':\n\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_16_9);\n\t\t\tbreak;\n\t\tcase '6':\n\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_FILL_SCREEN);\n\t\t\tbreak;\n\t\tcase '7':\n\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_KEEP);\n\t\t\tbreak;\n\n\t\tcase 'C':\n\t\t\tswitch (gf_term_get_option(term, GF_OPT_MEDIA_CACHE)) {\n\t\t\tcase GF_MEDIA_CACHE_DISABLED:\n\t\t\t\tgf_term_set_option(term, GF_OPT_MEDIA_CACHE, GF_MEDIA_CACHE_ENABLED);\n\t\t\t\tbreak;\n\t\t\tcase GF_MEDIA_CACHE_ENABLED:\n\t\t\t\tgf_term_set_option(term, GF_OPT_MEDIA_CACHE, GF_MEDIA_CACHE_DISABLED);\n\t\t\t\tbreak;\n\t\t\tcase GF_MEDIA_CACHE_RUNNING:\n\t\t\t\tfprintf(stderr, \"Streaming Cache is running - please stop it first\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tswitch (gf_term_get_option(term, GF_OPT_MEDIA_CACHE)) {\n\t\t\tcase GF_MEDIA_CACHE_ENABLED:\n\t\t\t\tfprintf(stderr, \"Streaming Cache Enabled\\n\");\n\t\t\t\tbreak;\n\t\t\tcase GF_MEDIA_CACHE_DISABLED:\n\t\t\t\tfprintf(stderr, \"Streaming Cache Disabled\\n\");\n\t\t\t\tbreak;\n\t\t\tcase GF_MEDIA_CACHE_RUNNING:\n\t\t\t\tfprintf(stderr, \"Streaming Cache Running\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'S':\n\t\tcase 'A':\n\t\t\tif (gf_term_get_option(term, GF_OPT_MEDIA_CACHE)==GF_MEDIA_CACHE_RUNNING) {\n\t\t\t\tgf_term_set_option(term, GF_OPT_MEDIA_CACHE, (c=='S') ? GF_MEDIA_CACHE_DISABLED : GF_MEDIA_CACHE_DISCARD);\n\t\t\t\tfprintf(stderr, \"Streaming Cache stopped\\n\");\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"Streaming Cache not running\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tdisplay_rti = !display_rti;\n\t\t\tResetCaption();\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tif (display_rti) display_rti = 0;\n\t\t\telse display_rti = 2;\n\t\t\tResetCaption();\n\t\t\tbreak;\n\n\t\tcase 'u':\n\t\t{\n\t\t\tGF_Err e;\n\t\t\tchar szCom[8192];\n\t\t\tfprintf(stderr, \"Enter command to send:\\n\");\n\t\t\tfflush(stdin);\n\t\t\tszCom[0] = 0;\n\t\t\tif (1 > scanf(\"%[^\\t\\n]\", szCom)) {\n\t\t\t\tfprintf(stderr, \"Cannot read command to send, aborting.\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\te = gf_term_scene_update(term, NULL, szCom);\n\t\t\tif (e) fprintf(stderr, \"Processing command failed: %s\\n\", gf_error_to_string(e));\n\t\t}\n\t\tbreak;\n\t\tcase 'e':\n\t\t{\n\t\t\tGF_Err e;\n\t\t\tchar jsCode[8192];\n\t\t\tfprintf(stderr, \"Enter JavaScript code to evaluate:\\n\");\n\t\t\tfflush(stdin);\n\t\t\tjsCode[0] = 0;\n\t\t\tif (1 > scanf(\"%[^\\t\\n]\", jsCode)) {\n\t\t\t\tfprintf(stderr, \"Cannot read code to evaluate, aborting.\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\te = gf_term_scene_update(term, \"application/ecmascript\", jsCode);\n\t\t\tif (e) fprintf(stderr, \"Processing JS code failed: %s\\n\", gf_error_to_string(e));\n\t\t}\n\t\tbreak;\n\n\t\tcase 'L':\n\t\t{\n\t\t\tchar szLog[1024], *cur_logs;\n\t\t\tcur_logs = gf_log_get_tools_levels();\n\t\t\tfprintf(stderr, \"Enter new log level (current tools %s):\\n\", cur_logs);\n\t\t\tgf_free(cur_logs);\n\t\t\tif (scanf(\"%s\", szLog) < 1) {\n\t\t\t\tfprintf(stderr, \"Cannot read new log level, aborting.\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgf_log_modify_tools_levels(szLog);\n\t\t}\n\t\tbreak;\n\n\t\tcase 'g':\n\t\t{\n\t\t\tGF_SystemRTInfo rti;\n\t\t\tgf_sys_get_rti(rti_update_time_ms, &rti, 0);\n\t\t\tfprintf(stderr, \"GPAC allocated memory \"LLD\"\\n\", rti.gpac_memory);\n\t\t}\n\t\tbreak;\n\t\tcase 'M':\n\t\t{\n\t\t\tu32 size;\n\t\t\tdo {\n\t\t\t\tfprintf(stderr, \"Enter new video cache memory in kBytes (current %ud):\\n\", gf_term_get_option(term, GF_OPT_VIDEO_CACHE_SIZE));\n\t\t\t} while (1 > scanf(\"%ud\", &size));\n\t\t\tgf_term_set_option(term, GF_OPT_VIDEO_CACHE_SIZE, size);\n\t\t}\n\t\tbreak;\n\n\t\tcase 'H':\n\t\t{\n\t\t\tu32 http_bitrate = gf_term_get_option(term, GF_OPT_HTTP_MAX_RATE);\n\t\t\tdo {\n\t\t\t\tfprintf(stderr, \"Enter new http bitrate in bps (0 for none) - current limit: %d\\n\", http_bitrate);\n\t\t\t} while (1 > scanf(\"%ud\", &http_bitrate));\n\n\t\t\tgf_term_set_option(term, GF_OPT_HTTP_MAX_RATE, http_bitrate);\n\t\t}\n\t\tbreak;\n\n\t\tcase 'E':\n\t\t\tgf_term_set_option(term, GF_OPT_RELOAD_CONFIG, 1);\n\t\t\tbreak;\n\n\t\tcase 'B':\n\t\t\tswitch_bench(!bench_mode);\n\t\t\tbreak;\n\n\t\tcase 'Y':\n\t\t{\n\t\t\tchar szOpt[8192];\n\t\t\tfprintf(stderr, \"Enter option to set (Section:Name=Value):\\n\");\n\t\t\tfflush(stdin);\n\t\t\tszOpt[0] = 0;\n\t\t\tif (1 > scanf(\"%[^\\t\\n]\", szOpt)) {\n\t\t\t\tfprintf(stderr, \"Cannot read option\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tset_cfg_option(szOpt);\n\t\t}\n\t\tbreak;\n\n\t\t/*extract to PNG*/\n\t\tcase 'Z':\n\t\t{\n\t\t\tchar szFileName[100];\n\t\t\tu32 nb_pass, nb_views, offscreen_view = 0;\n\t\t\tGF_VideoSurface fb;\n\t\t\tGF_Err e;\n\t\t\tnb_pass = 1;\n\t\t\tnb_views = gf_term_get_option(term, GF_OPT_NUM_STEREO_VIEWS);\n\t\t\tif (nb_views>1) {\n\t\t\t\tfprintf(stderr, \"Auto-stereo mode detected - type number of view to dump (0 is main output, 1 to %d offscreen view, %d for all offscreen, %d for all offscreen and main)\\n\", nb_views, nb_views+1, nb_views+2);\n\t\t\t\tif (scanf(\"%d\", &offscreen_view) != 1) {\n\t\t\t\t\toffscreen_view = 0;\n\t\t\t\t}\n\t\t\t\tif (offscreen_view==nb_views+1) {\n\t\t\t\t\toffscreen_view = 1;\n\t\t\t\t\tnb_pass = nb_views;\n\t\t\t\t}\n\t\t\t\telse if (offscreen_view==nb_views+2) {\n\t\t\t\t\toffscreen_view = 0;\n\t\t\t\t\tnb_pass = nb_views+1;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (nb_pass) {\n\t\t\t\tnb_pass--;\n\t\t\t\tif (offscreen_view) {\n\t\t\t\t\tsprintf(szFileName, \"view%d_dump.png\", offscreen_view);\n\t\t\t\t\te = gf_term_get_offscreen_buffer(term, &fb, offscreen_view-1, 0);\n\t\t\t\t} else {\n\t\t\t\t\tsprintf(szFileName, \"gpac_video_dump_\"LLU\".png\", gf_net_get_utc() );\n\t\t\t\t\te = gf_term_get_screen_buffer(term, &fb);\n\t\t\t\t}\n\t\t\t\toffscreen_view++;\n\t\t\t\tif (e) {\n\t\t\t\t\tfprintf(stderr, \"Error dumping screen buffer %s\\n\", gf_error_to_string(e) );\n\t\t\t\t\tnb_pass = 0;\n\t\t\t\t} else {\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\t\tu32 dst_size = fb.width*fb.height*4;\n\t\t\t\t\tchar *dst = (char*)gf_malloc(sizeof(char)*dst_size);\n\n\t\t\t\t\te = gf_img_png_enc(fb.video_buffer, fb.width, fb.height, fb.pitch_y, fb.pixel_format, dst, &dst_size);\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\tfprintf(stderr, \"Error encoding PNG %s\\n\", gf_error_to_string(e) );\n\t\t\t\t\t\tnb_pass = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tFILE *png = gf_fopen(szFileName, \"wb\");\n\t\t\t\t\t\tif (!png) {\n\t\t\t\t\t\t\tfprintf(stderr, \"Error writing file %s\\n\", szFileName);\n\t\t\t\t\t\t\tnb_pass = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgf_fwrite(dst, dst_size, 1, png);\n\t\t\t\t\t\t\tgf_fclose(png);\n\t\t\t\t\t\t\tfprintf(stderr, \"Dump to %s\\n\", szFileName);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (dst) gf_free(dst);\n\t\t\t\t\tgf_term_release_screen_buffer(term, &fb);\n#endif //GPAC_DISABLE_AV_PARSERS\n\t\t\t\t}\n\t\t\t}\n\t\t\tfprintf(stderr, \"Done: %s\\n\", szFileName);\n\t\t}\n\t\tbreak;\n\n\t\tcase 'G':\n\t\t{\n\t\t\tGF_ObjectManager *root_od, *odm;\n\t\t\tu32 index;\n\t\t\tchar szOpt[8192];\n\t\t\tfprintf(stderr, \"Enter 0-based index of object to select or service ID:\\n\");\n\t\t\tfflush(stdin);\n\t\t\tszOpt[0] = 0;\n\t\t\tif (1 > scanf(\"%[^\\t\\n]\", szOpt)) {\n\t\t\t\tfprintf(stderr, \"Cannot read OD ID\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tindex = atoi(szOpt);\n\t\t\todm = NULL;\n\t\t\troot_od = gf_term_get_root_object(term);\n\t\t\tif (root_od) {\n\t\t\t\tif ( gf_term_find_service(term, root_od, index)) {\n\t\t\t\t\tgf_term_select_service(term, root_od, index);\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"Cannot find service %d - trying with object index\\n\", index);\n\t\t\t\t\todm = gf_term_get_object(term, root_od, index);\n\t\t\t\t\tif (odm) {\n\t\t\t\t\t\tgf_term_select_object(term, odm);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfprintf(stderr, \"Cannot find object at index %d\\n\", index);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase 'h':\n\t\t\tPrintHelp();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (bench_mode) {\n\t\tPrintAVInfo(GF_TRUE);\n\t}\n\n\t/*FIXME: we have an issue in cleaning up after playing in bench mode and run-for 0 (buildbot tests). We for now disable error checks after run-for is done*/\n\tif (simulation_time_in_ms) {\n\t\tgf_log_set_strict_error(0);\n\t}\n\n\n\ti = gf_sys_clock();\n\tgf_term_disconnect(term);\n\tif (rti_file) UpdateRTInfo(\"Disconnected\\n\");\n\n\tfprintf(stderr, \"Deleting terminal... \");\n\tif (playlist) gf_fclose(playlist);\n\n#if defined(__DARWIN__) || defined(__APPLE__)\n\tcarbon_uninit();\n#endif\n\n\tgf_term_del(term);\n\tfprintf(stderr, \"done (in %d ms) - ran for %d ms\\n\", gf_sys_clock() - i, gf_sys_clock());\n\n\tfprintf(stderr, \"GPAC cleanup ...\\n\");\n\tgf_modules_del(user.modules);\n\n\tif (no_cfg_save)\n\t\tgf_cfg_discard_changes(cfg_file);\n\n\tgf_cfg_del(cfg_file);\n\n\tgf_sys_close();\n\n\tif (rti_logs) gf_fclose(rti_logs);\n\tif (logfile) gf_fclose(logfile);\n\n\tif (gui_mode) {\n\t\thide_shell(2);\n\t}\n\n#ifdef GPAC_MEMORY_TRACKING\n\tif (mem_track && (gf_memory_size() || gf_file_handles_count() )) {\n\t        gf_log_set_tool_level(GF_LOG_MEMORY, GF_LOG_INFO);\n\t\tgf_memory_print();\n\t\treturn 2;\n\t}\n#endif\n\n\treturn ret_val;\n}\n",
    "cwe": [
      "CWE-787"
    ],
    "id": 428,
    "_valid_cwes": [
      "CWE-787"
    ]
  },
  {
    "cve_id": "CVE-2018-6063",
    "code_before_change": "   void SimulateOnBufferCreated(int buffer_id, const base::SharedMemory& shm) {\n    auto handle = base::SharedMemory::DuplicateHandle(shm.handle());\n     video_capture_impl_->OnBufferCreated(\n        buffer_id, mojo::WrapSharedMemoryHandle(handle, shm.mapped_size(),\n                                                true /* read_only */));\n   }\n",
    "code_after_change": "   void SimulateOnBufferCreated(int buffer_id, const base::SharedMemory& shm) {\n     video_capture_impl_->OnBufferCreated(\n        buffer_id, mojo::WrapSharedMemoryHandle(\n                       shm.GetReadOnlyHandle(), shm.mapped_size(),\n                       mojo::UnwrappedSharedMemoryHandleProtection::kReadOnly));\n   }\n",
    "cwe": [
      "CWE-787"
    ],
    "id": 473,
    "_valid_cwes": [
      "CWE-787"
    ]
  },
  {
    "cve_id": "CVE-2016-9537",
    "code_before_change": "tsize_t t2p_readwrite_pdf_image(T2P* t2p, TIFF* input, TIFF* output){\n\n\ttsize_t written=0;\n\tunsigned char* buffer=NULL;\n\tunsigned char* samplebuffer=NULL;\n\ttsize_t bufferoffset=0;\n\ttsize_t samplebufferoffset=0;\n\ttsize_t read=0;\n\ttstrip_t i=0;\n\ttstrip_t j=0;\n\ttstrip_t stripcount=0;\n\ttsize_t stripsize=0;\n\ttsize_t sepstripcount=0;\n\ttsize_t sepstripsize=0;\n#ifdef OJPEG_SUPPORT\n\ttoff_t inputoffset=0;\n\tuint16 h_samp=1;\n\tuint16 v_samp=1;\n\tuint16 ri=1;\n\tuint32 rows=0;\n#endif /* ifdef OJPEG_SUPPORT */\n#ifdef JPEG_SUPPORT\n\tunsigned char* jpt;\n\tfloat* xfloatp;\n\tuint64* sbc;\n\tunsigned char* stripbuffer;\n\ttsize_t striplength=0;\n\tuint32 max_striplength=0;\n#endif /* ifdef JPEG_SUPPORT */\n\n\t/* Fail if prior error (in particular, can't trust tiff_datasize) */\n\tif (t2p->t2p_error != T2P_ERR_OK)\n\t\treturn(0);\n\n\tif(t2p->pdf_transcode == T2P_TRANSCODE_RAW){\n#ifdef CCITT_SUPPORT\n\t\tif(t2p->pdf_compression == T2P_COMPRESS_G4){\n\t\t\tbuffer = (unsigned char*)\n\t\t\t\t_TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif (buffer == NULL) {\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n                                          \"Can't allocate %lu bytes of memory for \"\n                                          \"t2p_readwrite_pdf_image, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tTIFFReadRawStrip(input, 0, (tdata_t) buffer,\n\t\t\t\t\t t2p->tiff_datasize);\n\t\t\tif (t2p->tiff_fillorder==FILLORDER_LSB2MSB){\n\t\t\t\t\t/*\n\t\t\t\t\t * make sure is lsb-to-msb\n\t\t\t\t\t * bit-endianness fill order\n\t\t\t\t\t */\n\t\t\t\t\tTIFFReverseBits(buffer,\n\t\t\t\t\t\t\tt2p->tiff_datasize);\n\t\t\t}\n\t\t\tt2pWriteFile(output, (tdata_t) buffer,\n\t\t\t\t      t2p->tiff_datasize);\n\t\t\t_TIFFfree(buffer);\n\t\t\treturn(t2p->tiff_datasize);\n\t\t}\n#endif /* ifdef CCITT_SUPPORT */\n#ifdef ZIP_SUPPORT\n\t\tif (t2p->pdf_compression == T2P_COMPRESS_ZIP) {\n\t\t\tbuffer = (unsigned char*)\n\t\t\t\t_TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer == NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n                        memset(buffer, 0, t2p->tiff_datasize);\n\t\t\tTIFFReadRawStrip(input, 0, (tdata_t) buffer,\n\t\t\t\t\t t2p->tiff_datasize);\n\t\t\tif (t2p->tiff_fillorder==FILLORDER_LSB2MSB) {\n\t\t\t\t\tTIFFReverseBits(buffer,\n\t\t\t\t\t\t\tt2p->tiff_datasize);\n\t\t\t}\n\t\t\tt2pWriteFile(output, (tdata_t) buffer,\n\t\t\t\t      t2p->tiff_datasize);\n\t\t\t_TIFFfree(buffer);\n\t\t\treturn(t2p->tiff_datasize);\n\t\t}\n#endif /* ifdef ZIP_SUPPORT */\n#ifdef OJPEG_SUPPORT\n\t\tif(t2p->tiff_compression == COMPRESSION_OJPEG) {\n\n\t\t\tif(t2p->tiff_dataoffset != 0) {\n\t\t\t\tbuffer = (unsigned char*)\n\t\t\t\t\t_TIFFmalloc(t2p->tiff_datasize);\n\t\t\t\tif(buffer == NULL) {\n\t\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s\", \n\t\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\t\tTIFFFileName(input));\n\t\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\t\treturn(0);\n\t\t\t\t}\n                                memset(buffer, 0, t2p->tiff_datasize);\n\t\t\t\tif(t2p->pdf_ojpegiflength==0){\n\t\t\t\t\tinputoffset=t2pSeekFile(input, 0,\n\t\t\t\t\t\t\t\t SEEK_CUR);\n\t\t\t\t\tt2pSeekFile(input,\n\t\t\t\t\t\t     t2p->tiff_dataoffset,\n\t\t\t\t\t\t     SEEK_SET);\n\t\t\t\t\tt2pReadFile(input, (tdata_t) buffer,\n\t\t\t\t\t\t     t2p->tiff_datasize);\n\t\t\t\t\tt2pSeekFile(input, inputoffset,\n\t\t\t\t\t\t     SEEK_SET);\n\t\t\t\t\tt2pWriteFile(output, (tdata_t) buffer,\n\t\t\t\t\t\t      t2p->tiff_datasize);\n\t\t\t\t\t_TIFFfree(buffer);\n\t\t\t\t\treturn(t2p->tiff_datasize);\n\t\t\t\t} else {\n\t\t\t\t\tinputoffset=t2pSeekFile(input, 0,\n\t\t\t\t\t\t\t\t SEEK_CUR);\n\t\t\t\t\tt2pSeekFile(input,\n\t\t\t\t\t\t     t2p->tiff_dataoffset,\n\t\t\t\t\t\t     SEEK_SET);\n\t\t\t\t\tbufferoffset = t2pReadFile(input,\n\t\t\t\t\t\t(tdata_t) buffer,\n\t\t\t\t\t\tt2p->pdf_ojpegiflength);\n\t\t\t\t\tt2p->pdf_ojpegiflength = 0;\n\t\t\t\t\tt2pSeekFile(input, inputoffset,\n\t\t\t\t\t\t     SEEK_SET);\n\t\t\t\t\tTIFFGetField(input,\n\t\t\t\t\t\t     TIFFTAG_YCBCRSUBSAMPLING,\n\t\t\t\t\t\t     &h_samp, &v_samp);\n\t\t\t\t\tbuffer[bufferoffset++]= 0xff;\n\t\t\t\t\tbuffer[bufferoffset++]= 0xdd;\n\t\t\t\t\tbuffer[bufferoffset++]= 0x00;\n\t\t\t\t\tbuffer[bufferoffset++]= 0x04;\n\t\t\t\t\th_samp*=8;\n\t\t\t\t\tv_samp*=8;\n\t\t\t\t\tri=(t2p->tiff_width+h_samp-1) / h_samp;\n\t\t\t\t\tTIFFGetField(input,\n\t\t\t\t\t\t     TIFFTAG_ROWSPERSTRIP,\n\t\t\t\t\t\t     &rows);\n\t\t\t\t\tri*=(rows+v_samp-1)/v_samp;\n\t\t\t\t\tbuffer[bufferoffset++]= (ri>>8) & 0xff;\n\t\t\t\t\tbuffer[bufferoffset++]= ri & 0xff;\n\t\t\t\t\tstripcount=TIFFNumberOfStrips(input);\n\t\t\t\t\tfor(i=0;i<stripcount;i++){\n\t\t\t\t\t\tif(i != 0 ){ \n\t\t\t\t\t\t\tbuffer[bufferoffset++]=0xff;\n\t\t\t\t\t\t\tbuffer[bufferoffset++]=(0xd0 | ((i-1)%8));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbufferoffset+=TIFFReadRawStrip(input, \n\t\t\t\t\t\t\ti, \n\t\t\t\t\t\t\t(tdata_t) &(((unsigned char*)buffer)[bufferoffset]), \n\t\t\t\t\t\t\t-1);\n\t\t\t\t\t}\n\t\t\t\t\tt2pWriteFile(output, (tdata_t) buffer, bufferoffset);\n\t\t\t\t\t_TIFFfree(buffer);\n\t\t\t\t\treturn(bufferoffset);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif(! t2p->pdf_ojpegdata){\n\t\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\"No support for OJPEG image %s with bad tables\", \n\t\t\t\t\t\tTIFFFileName(input));\n\t\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t\tbuffer = (unsigned char*)\n\t\t\t\t\t_TIFFmalloc(t2p->tiff_datasize);\n\t\t\t\tif(buffer==NULL){\n\t\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s\", \n\t\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\t\tTIFFFileName(input));\n\t\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\t\treturn(0);\n\t\t\t\t}\n                                memset(buffer, 0, t2p->tiff_datasize);\n\t\t\t\t_TIFFmemcpy(buffer, t2p->pdf_ojpegdata, t2p->pdf_ojpegdatalength);\n\t\t\t\tbufferoffset=t2p->pdf_ojpegdatalength;\n\t\t\t\tstripcount=TIFFNumberOfStrips(input);\n\t\t\t\tfor(i=0;i<stripcount;i++){\n\t\t\t\t\tif(i != 0){\n\t\t\t\t\t\tbuffer[bufferoffset++]=0xff;\n\t\t\t\t\t\tbuffer[bufferoffset++]=(0xd0 | ((i-1)%8));\n\t\t\t\t\t}\n\t\t\t\t\tbufferoffset+=TIFFReadRawStrip(input, \n\t\t\t\t\t\ti, \n\t\t\t\t\t\t(tdata_t) &(((unsigned char*)buffer)[bufferoffset]), \n\t\t\t\t\t\t-1);\n\t\t\t\t}\n\t\t\t\tif( ! ( (buffer[bufferoffset-1]==0xd9) && (buffer[bufferoffset-2]==0xff) ) ){\n\t\t\t\t\t\tbuffer[bufferoffset++]=0xff;\n\t\t\t\t\t\tbuffer[bufferoffset++]=0xd9;\n\t\t\t\t}\n\t\t\t\tt2pWriteFile(output, (tdata_t) buffer, bufferoffset);\n\t\t\t\t_TIFFfree(buffer);\n\t\t\t\treturn(bufferoffset);\n#if 0\n                                /*\n                                  This hunk of code removed code is clearly\n                                  mis-placed and we are not sure where it\n                                  should be (if anywhere)\n                                */\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\"No support for OJPEG image %s with no JPEG File Interchange offset\", \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n#endif\n\t\t\t}\n\t\t}\n#endif /* ifdef OJPEG_SUPPORT */\n#ifdef JPEG_SUPPORT\n\t\tif(t2p->tiff_compression == COMPRESSION_JPEG) {\n\t\t\tuint32 count = 0;\n\t\t\tbuffer = (unsigned char*)\n\t\t\t\t_TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n                        memset(buffer, 0, t2p->tiff_datasize);\n\t\t\tif (TIFFGetField(input, TIFFTAG_JPEGTABLES, &count, &jpt) != 0) {\n\t\t\t\tif(count > 4) {\n\t\t\t\t\t_TIFFmemcpy(buffer, jpt, count);\n\t\t\t\t\tbufferoffset += count - 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstripcount=TIFFNumberOfStrips(input);\n\t\t\tTIFFGetField(input, TIFFTAG_STRIPBYTECOUNTS, &sbc);\n\t\t\tfor(i=0;i<stripcount;i++){\n\t\t\t\tif(sbc[i]>max_striplength) max_striplength=sbc[i];\n\t\t\t}\n\t\t\tstripbuffer = (unsigned char*)\n\t\t\t\t_TIFFmalloc(max_striplength);\n\t\t\tif(stripbuffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\"Can't allocate %u bytes of memory for t2p_readwrite_pdf_image, %s\", \n\t\t\t\t\tmax_striplength, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\t_TIFFfree(buffer);\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tfor(i=0;i<stripcount;i++){\n\t\t\t\tstriplength=TIFFReadRawStrip(input, i, (tdata_t) stripbuffer, -1);\n \t\t\t\tif(!t2p_process_jpeg_strip(\n \t\t\t\t\tstripbuffer, \n \t\t\t\t\t&striplength, \n\t\t\t\t\tbuffer, \n \t\t\t\t\t&bufferoffset, \n \t\t\t\t\ti, \n \t\t\t\t\tt2p->tiff_length)){\n\t\t\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\"Can't process JPEG data in input file %s\", \n\t\t\t\t\t\t\tTIFFFileName(input));\n\t\t\t\t\t\t_TIFFfree(samplebuffer);\n\t\t\t\t\t\t_TIFFfree(buffer);\n\t\t\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbuffer[bufferoffset++]=0xff; \n\t\t\tbuffer[bufferoffset++]=0xd9;\n\t\t\tt2pWriteFile(output, (tdata_t) buffer, bufferoffset);\n\t\t\t_TIFFfree(stripbuffer);\n\t\t\t_TIFFfree(buffer);\n\t\t\treturn(bufferoffset);\n\t\t}\n#endif /* ifdef JPEG_SUPPORT */\n\t\t(void)0;\n\t}\n\n\tif(t2p->pdf_sample==T2P_SAMPLE_NOTHING){\n\t\tbuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\tif(buffer==NULL){\n\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s\", \n\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\tTIFFFileName(input));\n\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\treturn(0);\n\t\t}\n                memset(buffer, 0, t2p->tiff_datasize);\n\t\tstripsize=TIFFStripSize(input);\n\t\tstripcount=TIFFNumberOfStrips(input);\n\t\tfor(i=0;i<stripcount;i++){\n\t\t\tread = \n\t\t\t\tTIFFReadEncodedStrip(input, \n\t\t\t\ti, \n\t\t\t\t(tdata_t) &buffer[bufferoffset], \n\t\t\t\tTIFFmin(stripsize, t2p->tiff_datasize - bufferoffset));\n\t\t\tif(read==-1){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Error on decoding strip %u of %s\", \n\t\t\t\t\ti, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\t_TIFFfree(buffer);\n\t\t\t\tt2p->t2p_error=T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tbufferoffset+=read;\n\t\t}\n\t} else {\n\t\tif(t2p->pdf_sample & T2P_SAMPLE_PLANAR_SEPARATE_TO_CONTIG){\n\t\t\n\t\t\tsepstripsize=TIFFStripSize(input);\n\t\t\tsepstripcount=TIFFNumberOfStrips(input);\n\t\t\n\t\t\tstripsize=sepstripsize*t2p->tiff_samplesperpixel;\n\t\t\tstripcount=sepstripcount/t2p->tiff_samplesperpixel;\n\t\t\t\n\t\t\tbuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n                        memset(buffer, 0, t2p->tiff_datasize);\n\t\t\tsamplebuffer = (unsigned char*) _TIFFmalloc(stripsize);\n\t\t\tif(samplebuffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n                                _TIFFfree(buffer);\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tfor(i=0;i<stripcount;i++){\n\t\t\t\tsamplebufferoffset=0;\n\t\t\t\tfor(j=0;j<t2p->tiff_samplesperpixel;j++){\n\t\t\t\t\tread = \n\t\t\t\t\t\tTIFFReadEncodedStrip(input, \n\t\t\t\t\t\t\ti + j*stripcount, \n\t\t\t\t\t\t\t(tdata_t) &(samplebuffer[samplebufferoffset]), \n\t\t\t\t\t\t\tTIFFmin(sepstripsize, stripsize - samplebufferoffset));\n\t\t\t\t\tif(read==-1){\n\t\t\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Error on decoding strip %u of %s\", \n\t\t\t\t\t\t\ti + j*stripcount, \n\t\t\t\t\t\t\tTIFFFileName(input));\n\t\t\t\t\t\t\t_TIFFfree(buffer);\n\t\t\t\t\t\tt2p->t2p_error=T2P_ERR_ERROR;\n\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t\tsamplebufferoffset+=read;\n\t\t\t\t}\n\t\t\t\tt2p_sample_planar_separate_to_contig(\n\t\t\t\t\tt2p,\n\t\t\t\t\t&(buffer[bufferoffset]),\n\t\t\t\t\tsamplebuffer, \n\t\t\t\t\tsamplebufferoffset); \n\t\t\t\tbufferoffset+=samplebufferoffset;\n\t\t\t}\n\t\t\t_TIFFfree(samplebuffer);\n\t\t\tgoto dataready;\n\t\t}\n\n\t\tbuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\tif(buffer==NULL){\n\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s\", \n\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\tTIFFFileName(input));\n\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\treturn(0);\n\t\t}\n                memset(buffer, 0, t2p->tiff_datasize);\n\t\tstripsize=TIFFStripSize(input);\n\t\tstripcount=TIFFNumberOfStrips(input);\n\t\tfor(i=0;i<stripcount;i++){\n\t\t\tread = \n\t\t\t\tTIFFReadEncodedStrip(input, \n\t\t\t\ti, \n\t\t\t\t(tdata_t) &buffer[bufferoffset], \n\t\t\t\tTIFFmin(stripsize, t2p->tiff_datasize - bufferoffset));\n\t\t\tif(read==-1){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Error on decoding strip %u of %s\", \n\t\t\t\t\ti, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\t_TIFFfree(samplebuffer);\n\t\t\t\t_TIFFfree(buffer);\n\t\t\t\tt2p->t2p_error=T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tbufferoffset+=read;\n\t\t}\n\n\t\tif(t2p->pdf_sample & T2P_SAMPLE_REALIZE_PALETTE){\n\t\t\tsamplebuffer=(unsigned char*)_TIFFrealloc( \n\t\t\t\t(tdata_t) buffer, \n\t\t\t\tt2p->tiff_datasize * t2p->tiff_samplesperpixel);\n\t\t\tif(samplebuffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\t_TIFFfree(buffer);\n\t\t\t\treturn(0);\n\t\t\t} else {\n\t\t\t\tbuffer=samplebuffer;\n\t\t\t\tt2p->tiff_datasize *= t2p->tiff_samplesperpixel;\n\t\t\t}\n\t\t\tt2p_sample_realize_palette(t2p, buffer);\n\t\t}\n\n\t\tif(t2p->pdf_sample & T2P_SAMPLE_RGBA_TO_RGB){\n\t\t\tt2p->tiff_datasize=t2p_sample_rgba_to_rgb(\n\t\t\t\t(tdata_t)buffer, \n\t\t\t\tt2p->tiff_width*t2p->tiff_length);\n\t\t}\n\n\t\tif(t2p->pdf_sample & T2P_SAMPLE_RGBAA_TO_RGB){\n\t\t\tt2p->tiff_datasize=t2p_sample_rgbaa_to_rgb(\n\t\t\t\t(tdata_t)buffer, \n\t\t\t\tt2p->tiff_width*t2p->tiff_length);\n\t\t}\n\n\t\tif(t2p->pdf_sample & T2P_SAMPLE_YCBCR_TO_RGB){\n\t\t\tsamplebuffer=(unsigned char*)_TIFFrealloc(\n\t\t\t\t(tdata_t)buffer, \n\t\t\t\tt2p->tiff_width*t2p->tiff_length*4);\n\t\t\tif(samplebuffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\t_TIFFfree(buffer);\n\t\t\t\treturn(0);\n\t\t\t} else {\n\t\t\t\tbuffer=samplebuffer;\n\t\t\t}\n\t\t\tif(!TIFFReadRGBAImageOriented(\n\t\t\t\tinput, \n\t\t\t\tt2p->tiff_width, \n\t\t\t\tt2p->tiff_length, \n\t\t\t\t(uint32*)buffer, \n\t\t\t\tORIENTATION_TOPLEFT,\n\t\t\t\t0)){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\"Can't use TIFFReadRGBAImageOriented to extract RGB image from %s\", \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tt2p->tiff_datasize=t2p_sample_abgr_to_rgb(\n\t\t\t\t(tdata_t) buffer, \n\t\t\t\tt2p->tiff_width*t2p->tiff_length);\n\n\t\t}\n\n\t\tif(t2p->pdf_sample & T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED){\n\t\t\tt2p->tiff_datasize=t2p_sample_lab_signed_to_unsigned(\n\t\t\t\t(tdata_t)buffer, \n\t\t\t\tt2p->tiff_width*t2p->tiff_length);\n\t\t}\n\t}\n\ndataready:\n\n\tt2p_disable(output);\n\tTIFFSetField(output, TIFFTAG_PHOTOMETRIC, t2p->tiff_photometric);\n\tTIFFSetField(output, TIFFTAG_BITSPERSAMPLE, t2p->tiff_bitspersample);\n\tTIFFSetField(output, TIFFTAG_SAMPLESPERPIXEL, t2p->tiff_samplesperpixel);\n\tTIFFSetField(output, TIFFTAG_IMAGEWIDTH, t2p->tiff_width);\n\tTIFFSetField(output, TIFFTAG_IMAGELENGTH, t2p->tiff_length);\n\tTIFFSetField(output, TIFFTAG_ROWSPERSTRIP, t2p->tiff_length);\n\tTIFFSetField(output, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\tTIFFSetField(output, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);\n\n\tswitch(t2p->pdf_compression){\n\tcase T2P_COMPRESS_NONE:\n\t\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n\t\tbreak;\n#ifdef CCITT_SUPPORT\n\tcase T2P_COMPRESS_G4:\n\t\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_CCITTFAX4);\n\t\tbreak;\n#endif /* ifdef CCITT_SUPPORT */\n#ifdef JPEG_SUPPORT\n\tcase T2P_COMPRESS_JPEG:\n\t\tif(t2p->tiff_photometric==PHOTOMETRIC_YCBCR) {\n\t\t\tuint16 hor = 0, ver = 0;\n\t\t\tif (TIFFGetField(input, TIFFTAG_YCBCRSUBSAMPLING, &hor, &ver) !=0 ) {\n\t\t\t\tif(hor != 0 && ver != 0){\n\t\t\t\t\tTIFFSetField(output, TIFFTAG_YCBCRSUBSAMPLING, hor, ver);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(TIFFGetField(input, TIFFTAG_REFERENCEBLACKWHITE, &xfloatp)!=0){\n\t\t\t\tTIFFSetField(output, TIFFTAG_REFERENCEBLACKWHITE, xfloatp);\n\t\t\t}\n\t\t}\n\t\tif(TIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_JPEG)==0){\n\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\"Unable to use JPEG compression for input %s and output %s\", \n\t\t\t\tTIFFFileName(input),\n\t\t\t\tTIFFFileName(output));\n\t\t\t_TIFFfree(buffer);\n\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\treturn(0);\n\t\t}\n\t\tTIFFSetField(output, TIFFTAG_JPEGTABLESMODE, 0);\n\n\t\tif(t2p->pdf_colorspace & (T2P_CS_RGB | T2P_CS_LAB)){\n\t\t\tTIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);\n\t\t\tif(t2p->tiff_photometric != PHOTOMETRIC_YCBCR){\n\t\t\t\tTIFFSetField(output, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n\t\t\t} else {\n\t\t\t\tTIFFSetField(output, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RAW);\n\t\t\t}\n\t\t}\n\t\tif(t2p->pdf_colorspace & T2P_CS_GRAY){\n\t\t\t(void)0;\n\t\t}\n\t\tif(t2p->pdf_colorspace & T2P_CS_CMYK){\n\t\t\t(void)0;\n\t\t}\n\t\tif(t2p->pdf_defaultcompressionquality != 0){\n\t\t\tTIFFSetField(output, \n\t\t\t\tTIFFTAG_JPEGQUALITY, \n\t\t\t\tt2p->pdf_defaultcompressionquality);\n\t\t}\n\t\n\t\tbreak;\n#endif /* ifdef JPEG_SUPPORT */\n#ifdef ZIP_SUPPORT\n\tcase T2P_COMPRESS_ZIP:\n\t\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);\n\t\tif(t2p->pdf_defaultcompressionquality%100 != 0){\n\t\t\tTIFFSetField(output, \n\t\t\t\tTIFFTAG_PREDICTOR, \n\t\t\t\tt2p->pdf_defaultcompressionquality % 100);\n\t\t}\n\t\tif(t2p->pdf_defaultcompressionquality/100 != 0){\n\t\t\tTIFFSetField(output, \n\t\t\t\tTIFFTAG_ZIPQUALITY, \n\t\t\t\t(t2p->pdf_defaultcompressionquality / 100));\n\t\t}\n\t\tbreak;\n#endif /* ifdef ZIP_SUPPORT */\n\tdefault:\n\t\tbreak;\n\t}\n\n\tt2p_enable(output);\n\tt2p->outputwritten = 0;\n#ifdef JPEG_SUPPORT\n\tif(t2p->pdf_compression == T2P_COMPRESS_JPEG\n\t   && t2p->tiff_photometric == PHOTOMETRIC_YCBCR){\n\t\tbufferoffset = TIFFWriteEncodedStrip(output, (tstrip_t)0,\n\t\t\t\t\t\t     buffer,\n\t\t\t\t\t\t     stripsize * stripcount); \n\t} else\n#endif /* ifdef JPEG_SUPPORT */\n        {\n\t\tbufferoffset = TIFFWriteEncodedStrip(output, (tstrip_t)0,\n\t\t\t\t\t\t     buffer,\n\t\t\t\t\t\t     t2p->tiff_datasize); \n\t}\n\tif (buffer != NULL) {\n\t\t_TIFFfree(buffer);\n\t\tbuffer=NULL;\n\t}\n\n\tif (bufferoffset == (tsize_t)-1) {\n\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t  \"Error writing encoded strip to output PDF %s\", \n\t\t\t  TIFFFileName(output));\n\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\treturn(0);\n\t}\n\t\n\twritten = t2p->outputwritten;\n\treturn(written);\n}\n",
    "code_after_change": "tsize_t t2p_readwrite_pdf_image(T2P* t2p, TIFF* input, TIFF* output){\n\n\ttsize_t written=0;\n\tunsigned char* buffer=NULL;\n\tunsigned char* samplebuffer=NULL;\n\ttsize_t bufferoffset=0;\n\ttsize_t samplebufferoffset=0;\n\ttsize_t read=0;\n\ttstrip_t i=0;\n\ttstrip_t j=0;\n\ttstrip_t stripcount=0;\n\ttsize_t stripsize=0;\n\ttsize_t sepstripcount=0;\n\ttsize_t sepstripsize=0;\n#ifdef OJPEG_SUPPORT\n\ttoff_t inputoffset=0;\n\tuint16 h_samp=1;\n\tuint16 v_samp=1;\n\tuint16 ri=1;\n\tuint32 rows=0;\n#endif /* ifdef OJPEG_SUPPORT */\n#ifdef JPEG_SUPPORT\n\tunsigned char* jpt;\n\tfloat* xfloatp;\n\tuint64* sbc;\n\tunsigned char* stripbuffer;\n\ttsize_t striplength=0;\n\tuint32 max_striplength=0;\n#endif /* ifdef JPEG_SUPPORT */\n\n\t/* Fail if prior error (in particular, can't trust tiff_datasize) */\n\tif (t2p->t2p_error != T2P_ERR_OK)\n\t\treturn(0);\n\n\tif(t2p->pdf_transcode == T2P_TRANSCODE_RAW){\n#ifdef CCITT_SUPPORT\n\t\tif(t2p->pdf_compression == T2P_COMPRESS_G4){\n\t\t\tbuffer = (unsigned char*)\n\t\t\t\t_TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif (buffer == NULL) {\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n                                          \"Can't allocate %lu bytes of memory for \"\n                                          \"t2p_readwrite_pdf_image, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tTIFFReadRawStrip(input, 0, (tdata_t) buffer,\n\t\t\t\t\t t2p->tiff_datasize);\n\t\t\tif (t2p->tiff_fillorder==FILLORDER_LSB2MSB){\n\t\t\t\t\t/*\n\t\t\t\t\t * make sure is lsb-to-msb\n\t\t\t\t\t * bit-endianness fill order\n\t\t\t\t\t */\n\t\t\t\t\tTIFFReverseBits(buffer,\n\t\t\t\t\t\t\tt2p->tiff_datasize);\n\t\t\t}\n\t\t\tt2pWriteFile(output, (tdata_t) buffer,\n\t\t\t\t      t2p->tiff_datasize);\n\t\t\t_TIFFfree(buffer);\n\t\t\treturn(t2p->tiff_datasize);\n\t\t}\n#endif /* ifdef CCITT_SUPPORT */\n#ifdef ZIP_SUPPORT\n\t\tif (t2p->pdf_compression == T2P_COMPRESS_ZIP) {\n\t\t\tbuffer = (unsigned char*)\n\t\t\t\t_TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer == NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n                        memset(buffer, 0, t2p->tiff_datasize);\n\t\t\tTIFFReadRawStrip(input, 0, (tdata_t) buffer,\n\t\t\t\t\t t2p->tiff_datasize);\n\t\t\tif (t2p->tiff_fillorder==FILLORDER_LSB2MSB) {\n\t\t\t\t\tTIFFReverseBits(buffer,\n\t\t\t\t\t\t\tt2p->tiff_datasize);\n\t\t\t}\n\t\t\tt2pWriteFile(output, (tdata_t) buffer,\n\t\t\t\t      t2p->tiff_datasize);\n\t\t\t_TIFFfree(buffer);\n\t\t\treturn(t2p->tiff_datasize);\n\t\t}\n#endif /* ifdef ZIP_SUPPORT */\n#ifdef OJPEG_SUPPORT\n\t\tif(t2p->tiff_compression == COMPRESSION_OJPEG) {\n\n\t\t\tif(t2p->tiff_dataoffset != 0) {\n\t\t\t\tbuffer = (unsigned char*)\n\t\t\t\t\t_TIFFmalloc(t2p->tiff_datasize);\n\t\t\t\tif(buffer == NULL) {\n\t\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s\", \n\t\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\t\tTIFFFileName(input));\n\t\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\t\treturn(0);\n\t\t\t\t}\n                                memset(buffer, 0, t2p->tiff_datasize);\n\t\t\t\tif(t2p->pdf_ojpegiflength==0){\n\t\t\t\t\tinputoffset=t2pSeekFile(input, 0,\n\t\t\t\t\t\t\t\t SEEK_CUR);\n\t\t\t\t\tt2pSeekFile(input,\n\t\t\t\t\t\t     t2p->tiff_dataoffset,\n\t\t\t\t\t\t     SEEK_SET);\n\t\t\t\t\tt2pReadFile(input, (tdata_t) buffer,\n\t\t\t\t\t\t     t2p->tiff_datasize);\n\t\t\t\t\tt2pSeekFile(input, inputoffset,\n\t\t\t\t\t\t     SEEK_SET);\n\t\t\t\t\tt2pWriteFile(output, (tdata_t) buffer,\n\t\t\t\t\t\t      t2p->tiff_datasize);\n\t\t\t\t\t_TIFFfree(buffer);\n\t\t\t\t\treturn(t2p->tiff_datasize);\n\t\t\t\t} else {\n\t\t\t\t\tinputoffset=t2pSeekFile(input, 0,\n\t\t\t\t\t\t\t\t SEEK_CUR);\n\t\t\t\t\tt2pSeekFile(input,\n\t\t\t\t\t\t     t2p->tiff_dataoffset,\n\t\t\t\t\t\t     SEEK_SET);\n\t\t\t\t\tbufferoffset = t2pReadFile(input,\n\t\t\t\t\t\t(tdata_t) buffer,\n\t\t\t\t\t\tt2p->pdf_ojpegiflength);\n\t\t\t\t\tt2p->pdf_ojpegiflength = 0;\n\t\t\t\t\tt2pSeekFile(input, inputoffset,\n\t\t\t\t\t\t     SEEK_SET);\n\t\t\t\t\tTIFFGetField(input,\n\t\t\t\t\t\t     TIFFTAG_YCBCRSUBSAMPLING,\n\t\t\t\t\t\t     &h_samp, &v_samp);\n\t\t\t\t\tbuffer[bufferoffset++]= 0xff;\n\t\t\t\t\tbuffer[bufferoffset++]= 0xdd;\n\t\t\t\t\tbuffer[bufferoffset++]= 0x00;\n\t\t\t\t\tbuffer[bufferoffset++]= 0x04;\n\t\t\t\t\th_samp*=8;\n\t\t\t\t\tv_samp*=8;\n\t\t\t\t\tri=(t2p->tiff_width+h_samp-1) / h_samp;\n\t\t\t\t\tTIFFGetField(input,\n\t\t\t\t\t\t     TIFFTAG_ROWSPERSTRIP,\n\t\t\t\t\t\t     &rows);\n\t\t\t\t\tri*=(rows+v_samp-1)/v_samp;\n\t\t\t\t\tbuffer[bufferoffset++]= (ri>>8) & 0xff;\n\t\t\t\t\tbuffer[bufferoffset++]= ri & 0xff;\n\t\t\t\t\tstripcount=TIFFNumberOfStrips(input);\n\t\t\t\t\tfor(i=0;i<stripcount;i++){\n\t\t\t\t\t\tif(i != 0 ){ \n\t\t\t\t\t\t\tbuffer[bufferoffset++]=0xff;\n\t\t\t\t\t\t\tbuffer[bufferoffset++]=(0xd0 | ((i-1)%8));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbufferoffset+=TIFFReadRawStrip(input, \n\t\t\t\t\t\t\ti, \n\t\t\t\t\t\t\t(tdata_t) &(((unsigned char*)buffer)[bufferoffset]), \n\t\t\t\t\t\t\t-1);\n\t\t\t\t\t}\n\t\t\t\t\tt2pWriteFile(output, (tdata_t) buffer, bufferoffset);\n\t\t\t\t\t_TIFFfree(buffer);\n\t\t\t\t\treturn(bufferoffset);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif(! t2p->pdf_ojpegdata){\n\t\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\"No support for OJPEG image %s with bad tables\", \n\t\t\t\t\t\tTIFFFileName(input));\n\t\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t\tbuffer = (unsigned char*)\n\t\t\t\t\t_TIFFmalloc(t2p->tiff_datasize);\n\t\t\t\tif(buffer==NULL){\n\t\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s\", \n\t\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\t\tTIFFFileName(input));\n\t\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\t\treturn(0);\n\t\t\t\t}\n                                memset(buffer, 0, t2p->tiff_datasize);\n\t\t\t\t_TIFFmemcpy(buffer, t2p->pdf_ojpegdata, t2p->pdf_ojpegdatalength);\n\t\t\t\tbufferoffset=t2p->pdf_ojpegdatalength;\n\t\t\t\tstripcount=TIFFNumberOfStrips(input);\n\t\t\t\tfor(i=0;i<stripcount;i++){\n\t\t\t\t\tif(i != 0){\n\t\t\t\t\t\tbuffer[bufferoffset++]=0xff;\n\t\t\t\t\t\tbuffer[bufferoffset++]=(0xd0 | ((i-1)%8));\n\t\t\t\t\t}\n\t\t\t\t\tbufferoffset+=TIFFReadRawStrip(input, \n\t\t\t\t\t\ti, \n\t\t\t\t\t\t(tdata_t) &(((unsigned char*)buffer)[bufferoffset]), \n\t\t\t\t\t\t-1);\n\t\t\t\t}\n\t\t\t\tif( ! ( (buffer[bufferoffset-1]==0xd9) && (buffer[bufferoffset-2]==0xff) ) ){\n\t\t\t\t\t\tbuffer[bufferoffset++]=0xff;\n\t\t\t\t\t\tbuffer[bufferoffset++]=0xd9;\n\t\t\t\t}\n\t\t\t\tt2pWriteFile(output, (tdata_t) buffer, bufferoffset);\n\t\t\t\t_TIFFfree(buffer);\n\t\t\t\treturn(bufferoffset);\n#if 0\n                                /*\n                                  This hunk of code removed code is clearly\n                                  mis-placed and we are not sure where it\n                                  should be (if anywhere)\n                                */\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\"No support for OJPEG image %s with no JPEG File Interchange offset\", \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n#endif\n\t\t\t}\n\t\t}\n#endif /* ifdef OJPEG_SUPPORT */\n#ifdef JPEG_SUPPORT\n\t\tif(t2p->tiff_compression == COMPRESSION_JPEG) {\n\t\t\tuint32 count = 0;\n\t\t\tbuffer = (unsigned char*)\n\t\t\t\t_TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n                        memset(buffer, 0, t2p->tiff_datasize);\n\t\t\tif (TIFFGetField(input, TIFFTAG_JPEGTABLES, &count, &jpt) != 0) {\n\t\t\t\tif(count > 4) {\n\t\t\t\t\t_TIFFmemcpy(buffer, jpt, count);\n\t\t\t\t\tbufferoffset += count - 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstripcount=TIFFNumberOfStrips(input);\n\t\t\tTIFFGetField(input, TIFFTAG_STRIPBYTECOUNTS, &sbc);\n\t\t\tfor(i=0;i<stripcount;i++){\n\t\t\t\tif(sbc[i]>max_striplength) max_striplength=sbc[i];\n\t\t\t}\n\t\t\tstripbuffer = (unsigned char*)\n\t\t\t\t_TIFFmalloc(max_striplength);\n\t\t\tif(stripbuffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\"Can't allocate %u bytes of memory for t2p_readwrite_pdf_image, %s\", \n\t\t\t\t\tmax_striplength, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\t_TIFFfree(buffer);\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tfor(i=0;i<stripcount;i++){\n\t\t\t\tstriplength=TIFFReadRawStrip(input, i, (tdata_t) stripbuffer, -1);\n \t\t\t\tif(!t2p_process_jpeg_strip(\n \t\t\t\t\tstripbuffer, \n \t\t\t\t\t&striplength, \n\t\t\t\t\tbuffer,\n                    t2p->tiff_datasize,\n \t\t\t\t\t&bufferoffset, \n \t\t\t\t\ti, \n \t\t\t\t\tt2p->tiff_length)){\n\t\t\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\"Can't process JPEG data in input file %s\", \n\t\t\t\t\t\t\tTIFFFileName(input));\n\t\t\t\t\t\t_TIFFfree(samplebuffer);\n\t\t\t\t\t\t_TIFFfree(buffer);\n\t\t\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbuffer[bufferoffset++]=0xff; \n\t\t\tbuffer[bufferoffset++]=0xd9;\n\t\t\tt2pWriteFile(output, (tdata_t) buffer, bufferoffset);\n\t\t\t_TIFFfree(stripbuffer);\n\t\t\t_TIFFfree(buffer);\n\t\t\treturn(bufferoffset);\n\t\t}\n#endif /* ifdef JPEG_SUPPORT */\n\t\t(void)0;\n\t}\n\n\tif(t2p->pdf_sample==T2P_SAMPLE_NOTHING){\n\t\tbuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\tif(buffer==NULL){\n\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s\", \n\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\tTIFFFileName(input));\n\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\treturn(0);\n\t\t}\n                memset(buffer, 0, t2p->tiff_datasize);\n\t\tstripsize=TIFFStripSize(input);\n\t\tstripcount=TIFFNumberOfStrips(input);\n\t\tfor(i=0;i<stripcount;i++){\n\t\t\tread = \n\t\t\t\tTIFFReadEncodedStrip(input, \n\t\t\t\ti, \n\t\t\t\t(tdata_t) &buffer[bufferoffset], \n\t\t\t\tTIFFmin(stripsize, t2p->tiff_datasize - bufferoffset));\n\t\t\tif(read==-1){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Error on decoding strip %u of %s\", \n\t\t\t\t\ti, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\t_TIFFfree(buffer);\n\t\t\t\tt2p->t2p_error=T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tbufferoffset+=read;\n\t\t}\n\t} else {\n\t\tif(t2p->pdf_sample & T2P_SAMPLE_PLANAR_SEPARATE_TO_CONTIG){\n\t\t\n\t\t\tsepstripsize=TIFFStripSize(input);\n\t\t\tsepstripcount=TIFFNumberOfStrips(input);\n\t\t\n\t\t\tstripsize=sepstripsize*t2p->tiff_samplesperpixel;\n\t\t\tstripcount=sepstripcount/t2p->tiff_samplesperpixel;\n\t\t\t\n\t\t\tbuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n                        memset(buffer, 0, t2p->tiff_datasize);\n\t\t\tsamplebuffer = (unsigned char*) _TIFFmalloc(stripsize);\n\t\t\tif(samplebuffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n                                _TIFFfree(buffer);\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tfor(i=0;i<stripcount;i++){\n\t\t\t\tsamplebufferoffset=0;\n\t\t\t\tfor(j=0;j<t2p->tiff_samplesperpixel;j++){\n\t\t\t\t\tread = \n\t\t\t\t\t\tTIFFReadEncodedStrip(input, \n\t\t\t\t\t\t\ti + j*stripcount, \n\t\t\t\t\t\t\t(tdata_t) &(samplebuffer[samplebufferoffset]), \n\t\t\t\t\t\t\tTIFFmin(sepstripsize, stripsize - samplebufferoffset));\n\t\t\t\t\tif(read==-1){\n\t\t\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Error on decoding strip %u of %s\", \n\t\t\t\t\t\t\ti + j*stripcount, \n\t\t\t\t\t\t\tTIFFFileName(input));\n\t\t\t\t\t\t\t_TIFFfree(buffer);\n\t\t\t\t\t\tt2p->t2p_error=T2P_ERR_ERROR;\n\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t\tsamplebufferoffset+=read;\n\t\t\t\t}\n\t\t\t\tt2p_sample_planar_separate_to_contig(\n\t\t\t\t\tt2p,\n\t\t\t\t\t&(buffer[bufferoffset]),\n\t\t\t\t\tsamplebuffer, \n\t\t\t\t\tsamplebufferoffset); \n\t\t\t\tbufferoffset+=samplebufferoffset;\n\t\t\t}\n\t\t\t_TIFFfree(samplebuffer);\n\t\t\tgoto dataready;\n\t\t}\n\n\t\tbuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\tif(buffer==NULL){\n\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s\", \n\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\tTIFFFileName(input));\n\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\treturn(0);\n\t\t}\n                memset(buffer, 0, t2p->tiff_datasize);\n\t\tstripsize=TIFFStripSize(input);\n\t\tstripcount=TIFFNumberOfStrips(input);\n\t\tfor(i=0;i<stripcount;i++){\n\t\t\tread = \n\t\t\t\tTIFFReadEncodedStrip(input, \n\t\t\t\ti, \n\t\t\t\t(tdata_t) &buffer[bufferoffset], \n\t\t\t\tTIFFmin(stripsize, t2p->tiff_datasize - bufferoffset));\n\t\t\tif(read==-1){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Error on decoding strip %u of %s\", \n\t\t\t\t\ti, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\t_TIFFfree(samplebuffer);\n\t\t\t\t_TIFFfree(buffer);\n\t\t\t\tt2p->t2p_error=T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tbufferoffset+=read;\n\t\t}\n\n\t\tif(t2p->pdf_sample & T2P_SAMPLE_REALIZE_PALETTE){\n\t\t\tsamplebuffer=(unsigned char*)_TIFFrealloc( \n\t\t\t\t(tdata_t) buffer, \n\t\t\t\tt2p->tiff_datasize * t2p->tiff_samplesperpixel);\n\t\t\tif(samplebuffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\t_TIFFfree(buffer);\n\t\t\t\treturn(0);\n\t\t\t} else {\n\t\t\t\tbuffer=samplebuffer;\n\t\t\t\tt2p->tiff_datasize *= t2p->tiff_samplesperpixel;\n\t\t\t}\n\t\t\tt2p_sample_realize_palette(t2p, buffer);\n\t\t}\n\n\t\tif(t2p->pdf_sample & T2P_SAMPLE_RGBA_TO_RGB){\n\t\t\tt2p->tiff_datasize=t2p_sample_rgba_to_rgb(\n\t\t\t\t(tdata_t)buffer, \n\t\t\t\tt2p->tiff_width*t2p->tiff_length);\n\t\t}\n\n\t\tif(t2p->pdf_sample & T2P_SAMPLE_RGBAA_TO_RGB){\n\t\t\tt2p->tiff_datasize=t2p_sample_rgbaa_to_rgb(\n\t\t\t\t(tdata_t)buffer, \n\t\t\t\tt2p->tiff_width*t2p->tiff_length);\n\t\t}\n\n\t\tif(t2p->pdf_sample & T2P_SAMPLE_YCBCR_TO_RGB){\n\t\t\tsamplebuffer=(unsigned char*)_TIFFrealloc(\n\t\t\t\t(tdata_t)buffer, \n\t\t\t\tt2p->tiff_width*t2p->tiff_length*4);\n\t\t\tif(samplebuffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\t_TIFFfree(buffer);\n\t\t\t\treturn(0);\n\t\t\t} else {\n\t\t\t\tbuffer=samplebuffer;\n\t\t\t}\n\t\t\tif(!TIFFReadRGBAImageOriented(\n\t\t\t\tinput, \n\t\t\t\tt2p->tiff_width, \n\t\t\t\tt2p->tiff_length, \n\t\t\t\t(uint32*)buffer, \n\t\t\t\tORIENTATION_TOPLEFT,\n\t\t\t\t0)){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\"Can't use TIFFReadRGBAImageOriented to extract RGB image from %s\", \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tt2p->tiff_datasize=t2p_sample_abgr_to_rgb(\n\t\t\t\t(tdata_t) buffer, \n\t\t\t\tt2p->tiff_width*t2p->tiff_length);\n\n\t\t}\n\n\t\tif(t2p->pdf_sample & T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED){\n\t\t\tt2p->tiff_datasize=t2p_sample_lab_signed_to_unsigned(\n\t\t\t\t(tdata_t)buffer, \n\t\t\t\tt2p->tiff_width*t2p->tiff_length);\n\t\t}\n\t}\n\ndataready:\n\n\tt2p_disable(output);\n\tTIFFSetField(output, TIFFTAG_PHOTOMETRIC, t2p->tiff_photometric);\n\tTIFFSetField(output, TIFFTAG_BITSPERSAMPLE, t2p->tiff_bitspersample);\n\tTIFFSetField(output, TIFFTAG_SAMPLESPERPIXEL, t2p->tiff_samplesperpixel);\n\tTIFFSetField(output, TIFFTAG_IMAGEWIDTH, t2p->tiff_width);\n\tTIFFSetField(output, TIFFTAG_IMAGELENGTH, t2p->tiff_length);\n\tTIFFSetField(output, TIFFTAG_ROWSPERSTRIP, t2p->tiff_length);\n\tTIFFSetField(output, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\tTIFFSetField(output, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);\n\n\tswitch(t2p->pdf_compression){\n\tcase T2P_COMPRESS_NONE:\n\t\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n\t\tbreak;\n#ifdef CCITT_SUPPORT\n\tcase T2P_COMPRESS_G4:\n\t\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_CCITTFAX4);\n\t\tbreak;\n#endif /* ifdef CCITT_SUPPORT */\n#ifdef JPEG_SUPPORT\n\tcase T2P_COMPRESS_JPEG:\n\t\tif(t2p->tiff_photometric==PHOTOMETRIC_YCBCR) {\n\t\t\tuint16 hor = 0, ver = 0;\n\t\t\tif (TIFFGetField(input, TIFFTAG_YCBCRSUBSAMPLING, &hor, &ver) !=0 ) {\n\t\t\t\tif(hor != 0 && ver != 0){\n\t\t\t\t\tTIFFSetField(output, TIFFTAG_YCBCRSUBSAMPLING, hor, ver);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(TIFFGetField(input, TIFFTAG_REFERENCEBLACKWHITE, &xfloatp)!=0){\n\t\t\t\tTIFFSetField(output, TIFFTAG_REFERENCEBLACKWHITE, xfloatp);\n\t\t\t}\n\t\t}\n\t\tif(TIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_JPEG)==0){\n\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\"Unable to use JPEG compression for input %s and output %s\", \n\t\t\t\tTIFFFileName(input),\n\t\t\t\tTIFFFileName(output));\n\t\t\t_TIFFfree(buffer);\n\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\treturn(0);\n\t\t}\n\t\tTIFFSetField(output, TIFFTAG_JPEGTABLESMODE, 0);\n\n\t\tif(t2p->pdf_colorspace & (T2P_CS_RGB | T2P_CS_LAB)){\n\t\t\tTIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);\n\t\t\tif(t2p->tiff_photometric != PHOTOMETRIC_YCBCR){\n\t\t\t\tTIFFSetField(output, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n\t\t\t} else {\n\t\t\t\tTIFFSetField(output, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RAW);\n\t\t\t}\n\t\t}\n\t\tif(t2p->pdf_colorspace & T2P_CS_GRAY){\n\t\t\t(void)0;\n\t\t}\n\t\tif(t2p->pdf_colorspace & T2P_CS_CMYK){\n\t\t\t(void)0;\n\t\t}\n\t\tif(t2p->pdf_defaultcompressionquality != 0){\n\t\t\tTIFFSetField(output, \n\t\t\t\tTIFFTAG_JPEGQUALITY, \n\t\t\t\tt2p->pdf_defaultcompressionquality);\n\t\t}\n\t\n\t\tbreak;\n#endif /* ifdef JPEG_SUPPORT */\n#ifdef ZIP_SUPPORT\n\tcase T2P_COMPRESS_ZIP:\n\t\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);\n\t\tif(t2p->pdf_defaultcompressionquality%100 != 0){\n\t\t\tTIFFSetField(output, \n\t\t\t\tTIFFTAG_PREDICTOR, \n\t\t\t\tt2p->pdf_defaultcompressionquality % 100);\n\t\t}\n\t\tif(t2p->pdf_defaultcompressionquality/100 != 0){\n\t\t\tTIFFSetField(output, \n\t\t\t\tTIFFTAG_ZIPQUALITY, \n\t\t\t\t(t2p->pdf_defaultcompressionquality / 100));\n\t\t}\n\t\tbreak;\n#endif /* ifdef ZIP_SUPPORT */\n\tdefault:\n\t\tbreak;\n\t}\n\n\tt2p_enable(output);\n\tt2p->outputwritten = 0;\n#ifdef JPEG_SUPPORT\n\tif(t2p->pdf_compression == T2P_COMPRESS_JPEG\n\t   && t2p->tiff_photometric == PHOTOMETRIC_YCBCR){\n\t\tbufferoffset = TIFFWriteEncodedStrip(output, (tstrip_t)0,\n\t\t\t\t\t\t     buffer,\n\t\t\t\t\t\t     stripsize * stripcount); \n\t} else\n#endif /* ifdef JPEG_SUPPORT */\n        {\n\t\tbufferoffset = TIFFWriteEncodedStrip(output, (tstrip_t)0,\n\t\t\t\t\t\t     buffer,\n\t\t\t\t\t\t     t2p->tiff_datasize); \n\t}\n\tif (buffer != NULL) {\n\t\t_TIFFfree(buffer);\n\t\tbuffer=NULL;\n\t}\n\n\tif (bufferoffset == (tsize_t)-1) {\n\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t  \"Error writing encoded strip to output PDF %s\", \n\t\t\t  TIFFFileName(output));\n\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\treturn(0);\n\t}\n\t\n\twritten = t2p->outputwritten;\n\treturn(written);\n}\n",
    "cwe": [
      "CWE-787"
    ],
    "id": 609,
    "_valid_cwes": [
      "CWE-787"
    ]
  },
  {
    "cve_id": "CVE-2017-9949",
    "code_before_change": "static int _server_handle_vCont(libgdbr_t *g, int (*cmd_cb) (void*, const char*, char*, size_t), void *core_ptr) {\n\tchar *action = NULL;\n\tif (send_ack (g) < 0) {\n\t\treturn -1;\n\t}\n\tg->data[g->data_len] = '\\0';\n\tif (g->data[5] == '?') {\n\t\treturn send_msg (g, \"vCont;c;s\");\n\t}\n\tif (!(action = strtok (g->data, \";\"))) {\n\t\treturn send_msg (g, \"E01\");\n\t}\n\twhile (action = strtok (NULL, \";\")) {\n\t\teprintf (\"action: %s\\n\", action);\n\t\tswitch (action[0]) {\n\t\tcase 's':\n\t\t\tif (cmd_cb (core_ptr, \"ds\", NULL, 0) < 0) {\n\t\t\t\tsend_msg (g, \"E01\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn send_msg (g, \"OK\");\n\t\tcase 'c':\n\t\t\tif (cmd_cb (core_ptr, \"dc\", NULL, 0) < 0) {\n\t\t\t\tsend_msg (g, \"E01\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn send_msg (g, \"OK\");\n\t\tdefault:\n \t\t\treturn send_msg (g, \"E01\");\n \t\t}\n \t}\n }\n",
    "code_after_change": "static int _server_handle_vCont(libgdbr_t *g, int (*cmd_cb) (void*, const char*, char*, size_t), void *core_ptr) {\n\tchar *action = NULL;\n\tif (send_ack (g) < 0) {\n\t\treturn -1;\n\t}\n\tg->data[g->data_len] = '\\0';\n\tif (g->data[5] == '?') {\n\t\treturn send_msg (g, \"vCont;c;s\");\n\t}\n\tif (!(action = strtok (g->data, \";\"))) {\n\t\treturn send_msg (g, \"E01\");\n\t}\n\twhile (action = strtok (NULL, \";\")) {\n\t\teprintf (\"action: %s\\n\", action);\n\t\tswitch (action[0]) {\n\t\tcase 's':\n\t\t\tif (cmd_cb (core_ptr, \"ds\", NULL, 0) < 0) {\n\t\t\t\tsend_msg (g, \"E01\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn send_msg (g, \"OK\");\n\t\tcase 'c':\n\t\t\tif (cmd_cb (core_ptr, \"dc\", NULL, 0) < 0) {\n\t\t\t\tsend_msg (g, \"E01\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn send_msg (g, \"OK\");\n\t\tdefault:\n \t\t\treturn send_msg (g, \"E01\");\n \t\t}\n \t}\n\treturn -1;\n }\n",
    "cwe": [
      "CWE-787"
    ],
    "id": 619,
    "_valid_cwes": [
      "CWE-787"
    ]
  },
  {
    "cve_id": "CVE-2018-6063",
    "code_before_change": " mojo::ScopedSharedBufferHandle GamepadProvider::GetSharedBufferHandle() {\n  base::SharedMemoryHandle handle = base::SharedMemory::DuplicateHandle(\n      gamepad_shared_buffer_->shared_memory()->handle());\n  return mojo::WrapSharedMemoryHandle(handle, sizeof(GamepadHardwareBuffer),\n                                      true /* read_only */);\n }\n",
    "code_after_change": " mojo::ScopedSharedBufferHandle GamepadProvider::GetSharedBufferHandle() {\n  return mojo::WrapSharedMemoryHandle(\n      gamepad_shared_buffer_->shared_memory()->GetReadOnlyHandle(),\n      sizeof(GamepadHardwareBuffer),\n      mojo::UnwrappedSharedMemoryHandleProtection::kReadOnly);\n }\n",
    "cwe": [
      "CWE-787"
    ],
    "id": 703,
    "_valid_cwes": [
      "CWE-787"
    ]
  },
  {
    "cve_id": "CVE-2019-13106",
    "code_before_change": "int trigger_fpga_config(void)\n{\n\tint ret = 0, init_l;\n\t/* approx 10ms */\n\tu32 timeout = 10000;\n\n\t/* make sure the FPGA_can access the EEPROM */\n \ttoggle_fpga_eeprom_bus(false);\n \n \t/* assert CONF_SEL_L to be able to drive FPGA_PROG_L */\n\tqrio_gpio_direction_output(GPIO_A, CONF_SEL_L, 0);\n \n \t/* trigger the config start */\n\tqrio_gpio_direction_output(GPIO_A, FPGA_PROG_L, 0);\n \n \t/* small delay for INIT_L line */\n \tudelay(10);\n \n \t/* wait for FPGA_INIT to be asserted */\n \tdo {\n\t\tinit_l = qrio_get_gpio(GPIO_A, FPGA_INIT_L);\n \t\tif (timeout-- == 0) {\n \t\t\tprintf(\"FPGA_INIT timeout\\n\");\n \t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tudelay(10);\n \t} while (init_l);\n \n \t/* deassert FPGA_PROG, config should start */\n\tqrio_set_gpio(GPIO_A, FPGA_PROG_L, 1);\n \n \treturn ret;\n }\n",
    "code_after_change": "int trigger_fpga_config(void)\n{\n\tint ret = 0, init_l;\n\t/* approx 10ms */\n\tu32 timeout = 10000;\n\n\t/* make sure the FPGA_can access the EEPROM */\n \ttoggle_fpga_eeprom_bus(false);\n \n \t/* assert CONF_SEL_L to be able to drive FPGA_PROG_L */\n\tqrio_gpio_direction_output(QRIO_GPIO_A, CONF_SEL_L, 0);\n \n \t/* trigger the config start */\n\tqrio_gpio_direction_output(QRIO_GPIO_A, FPGA_PROG_L, 0);\n \n \t/* small delay for INIT_L line */\n \tudelay(10);\n \n \t/* wait for FPGA_INIT to be asserted */\n \tdo {\n\t\tinit_l = qrio_get_gpio(QRIO_GPIO_A, FPGA_INIT_L);\n \t\tif (timeout-- == 0) {\n \t\t\tprintf(\"FPGA_INIT timeout\\n\");\n \t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tudelay(10);\n \t} while (init_l);\n \n \t/* deassert FPGA_PROG, config should start */\n\tqrio_set_gpio(QRIO_GPIO_A, FPGA_PROG_L, 1);\n \n \treturn ret;\n }\n",
    "cwe": [
      "CWE-787"
    ],
    "id": 719,
    "_valid_cwes": [
      "CWE-787"
    ]
  },
  {
    "cve_id": "CVE-2018-19198",
    "code_before_change": "int URI_FUNC(ComposeQueryEngine)(URI_CHAR * dest,\n\t\tconst URI_TYPE(QueryList) * queryList,\n\t\tint maxChars, int * charsWritten, int * charsRequired,\n\t\tUriBool spaceToPlus, UriBool normalizeBreaks) {\n\tUriBool firstItem = URI_TRUE;\n\tint ampersandLen = 0;  /* increased to 1 from second item on */\n\tURI_CHAR * write = dest;\n\n\t/* Subtract terminator */\n\tif (dest == NULL) {\n\t\t*charsRequired = 0;\n\t} else {\n\t\tmaxChars--;\n\t}\n\t\t\t\n\twhile (queryList != NULL) {\n\t\tconst URI_CHAR * const key = queryList->key;\n\t\tconst URI_CHAR * const value = queryList->value;\n\t\tconst int worstCase = (normalizeBreaks == URI_TRUE ? 6 : 3);\n\t\tconst int keyLen = (key == NULL) ? 0 : (int)URI_STRLEN(key);\n\t\tconst int keyRequiredChars = worstCase * keyLen;\n\t\tconst int valueLen = (value == NULL) ? 0 : (int)URI_STRLEN(value);\n\t\tconst int valueRequiredChars = worstCase * valueLen;\n\n\t\tif (dest == NULL) {\n\t\t\tif (firstItem == URI_TRUE) {\n\t\t\t\tampersandLen = 1;\n\t\t\t\tfirstItem = URI_FALSE;\n\t\t\t}\n\n\t\t\t(*charsRequired) += ampersandLen + keyRequiredChars + ((value == NULL)\n\t\t\t\t\t\t? 0\n\t\t\t\t\t\t: 1 + valueRequiredChars);\n\t\t} else {\n\t\t\tURI_CHAR * afterKey;\n\n\t\t\tif ((write - dest) + ampersandLen + keyRequiredChars > maxChars) {\n\t\t\t\treturn URI_ERROR_OUTPUT_TOO_LARGE;\n\t\t\t}\n \n \t\t\t/* Copy key */\n \t\t\tif (firstItem == URI_TRUE) {\n \t\t\t\tfirstItem = URI_FALSE;\n \t\t\t} else {\n \t\t\t\twrite[0] = _UT('&');\n\t\t\t\twrite++;\n\t\t\t}\n\t\t\tafterKey = URI_FUNC(EscapeEx)(key, key + keyLen,\n\t\t\t\t\twrite, spaceToPlus, normalizeBreaks);\n\t\t\twrite += (afterKey - write);\n\n\t\t\tif (value != NULL) {\n\t\t\t\tURI_CHAR * afterValue;\n\n\t\t\t\tif ((write - dest) + 1 + valueRequiredChars > maxChars) {\n\t\t\t\t\treturn URI_ERROR_OUTPUT_TOO_LARGE;\n\t\t\t\t}\n\n\t\t\t\t/* Copy value */\n\t\t\t\twrite[0] = _UT('=');\n\t\t\t\twrite++;\n\t\t\t\tafterValue = URI_FUNC(EscapeEx)(value, value + valueLen,\n\t\t\t\t\t\twrite, spaceToPlus, normalizeBreaks);\n\t\t\t\twrite += (afterValue - write);\n\t\t\t}\n\t\t}\n\n\t\tqueryList = queryList->next;\n\t}\n\n\tif (dest != NULL) {\n\t\twrite[0] = _UT('\\0');\n\t\tif (charsWritten != NULL) {\n\t\t\t*charsWritten = (int)(write - dest) + 1; /* .. for terminator */\n\t\t}\n\t}\n\n\treturn URI_SUCCESS;\n}\n",
    "code_after_change": "int URI_FUNC(ComposeQueryEngine)(URI_CHAR * dest,\n\t\tconst URI_TYPE(QueryList) * queryList,\n\t\tint maxChars, int * charsWritten, int * charsRequired,\n\t\tUriBool spaceToPlus, UriBool normalizeBreaks) {\n\tUriBool firstItem = URI_TRUE;\n\tint ampersandLen = 0;  /* increased to 1 from second item on */\n\tURI_CHAR * write = dest;\n\n\t/* Subtract terminator */\n\tif (dest == NULL) {\n\t\t*charsRequired = 0;\n\t} else {\n\t\tmaxChars--;\n\t}\n\t\t\t\n\twhile (queryList != NULL) {\n\t\tconst URI_CHAR * const key = queryList->key;\n\t\tconst URI_CHAR * const value = queryList->value;\n\t\tconst int worstCase = (normalizeBreaks == URI_TRUE ? 6 : 3);\n\t\tconst int keyLen = (key == NULL) ? 0 : (int)URI_STRLEN(key);\n\t\tconst int keyRequiredChars = worstCase * keyLen;\n\t\tconst int valueLen = (value == NULL) ? 0 : (int)URI_STRLEN(value);\n\t\tconst int valueRequiredChars = worstCase * valueLen;\n\n\t\tif (dest == NULL) {\n\t\t\tif (firstItem == URI_TRUE) {\n\t\t\t\tampersandLen = 1;\n\t\t\t\tfirstItem = URI_FALSE;\n\t\t\t}\n\n\t\t\t(*charsRequired) += ampersandLen + keyRequiredChars + ((value == NULL)\n\t\t\t\t\t\t? 0\n\t\t\t\t\t\t: 1 + valueRequiredChars);\n\t\t} else {\n\t\t\tURI_CHAR * afterKey;\n\n\t\t\tif ((write - dest) + ampersandLen + keyRequiredChars > maxChars) {\n\t\t\t\treturn URI_ERROR_OUTPUT_TOO_LARGE;\n\t\t\t}\n \n \t\t\t/* Copy key */\n \t\t\tif (firstItem == URI_TRUE) {\n\t\t\t\tampersandLen = 1;\n \t\t\t\tfirstItem = URI_FALSE;\n \t\t\t} else {\n \t\t\t\twrite[0] = _UT('&');\n\t\t\t\twrite++;\n\t\t\t}\n\t\t\tafterKey = URI_FUNC(EscapeEx)(key, key + keyLen,\n\t\t\t\t\twrite, spaceToPlus, normalizeBreaks);\n\t\t\twrite += (afterKey - write);\n\n\t\t\tif (value != NULL) {\n\t\t\t\tURI_CHAR * afterValue;\n\n\t\t\t\tif ((write - dest) + 1 + valueRequiredChars > maxChars) {\n\t\t\t\t\treturn URI_ERROR_OUTPUT_TOO_LARGE;\n\t\t\t\t}\n\n\t\t\t\t/* Copy value */\n\t\t\t\twrite[0] = _UT('=');\n\t\t\t\twrite++;\n\t\t\t\tafterValue = URI_FUNC(EscapeEx)(value, value + valueLen,\n\t\t\t\t\t\twrite, spaceToPlus, normalizeBreaks);\n\t\t\t\twrite += (afterValue - write);\n\t\t\t}\n\t\t}\n\n\t\tqueryList = queryList->next;\n\t}\n\n\tif (dest != NULL) {\n\t\twrite[0] = _UT('\\0');\n\t\tif (charsWritten != NULL) {\n\t\t\t*charsWritten = (int)(write - dest) + 1; /* .. for terminator */\n\t\t}\n\t}\n\n\treturn URI_SUCCESS;\n}\n",
    "cwe": [
      "CWE-787"
    ],
    "id": 796,
    "_valid_cwes": [
      "CWE-787"
    ]
  },
  {
    "cve_id": "CVE-2017-5130",
    "code_before_change": " bool XmlReader::LoadFile(const std::string& file_path) {\n   const int kParseOptions = XML_PARSE_RECOVER |  // recover on errors\n                            XML_PARSE_NONET |    // forbid network access\n                            XML_PARSE_NOXXE;     // no external entities\n   reader_ = xmlReaderForFile(file_path.c_str(), NULL, kParseOptions);\n   return reader_ != NULL;\n }\n",
    "code_after_change": " bool XmlReader::LoadFile(const std::string& file_path) {\n   const int kParseOptions = XML_PARSE_RECOVER |  // recover on errors\n                            XML_PARSE_NONET;     // forbid network access\n   reader_ = xmlReaderForFile(file_path.c_str(), NULL, kParseOptions);\n   return reader_ != NULL;\n }\n",
    "cwe": [
      "CWE-787"
    ],
    "id": 904,
    "_valid_cwes": [
      "CWE-787"
    ]
  },
  {
    "cve_id": "CVE-2018-6063",
    "code_before_change": "void MojoAudioInputStream::OnStreamCreated(\n    int stream_id,\n    const base::SharedMemory* shared_memory,\n    std::unique_ptr<base::CancelableSyncSocket> foreign_socket,\n    bool initially_muted) {\n  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);\n  DCHECK(stream_created_callback_);\n  DCHECK(shared_memory);\n  DCHECK(foreign_socket);\n\n  base::SharedMemoryHandle foreign_memory_handle =\n      shared_memory->GetReadOnlyHandle();\n  if (!base::SharedMemory::IsHandleValid(foreign_memory_handle)) {\n    OnStreamError(/*not used*/ 0);\n    return;\n  }\n \n   mojo::ScopedSharedBufferHandle buffer_handle = mojo::WrapSharedMemoryHandle(\n       foreign_memory_handle, shared_memory->requested_size(),\n      /*read_only*/ true);\n   mojo::ScopedHandle socket_handle =\n       mojo::WrapPlatformFile(foreign_socket->Release());\n \n  DCHECK(buffer_handle.is_valid());\n  DCHECK(socket_handle.is_valid());\n\n  base::ResetAndReturn(&stream_created_callback_)\n      .Run(std::move(buffer_handle), std::move(socket_handle), initially_muted);\n}\n",
    "code_after_change": "void MojoAudioInputStream::OnStreamCreated(\n    int stream_id,\n    const base::SharedMemory* shared_memory,\n    std::unique_ptr<base::CancelableSyncSocket> foreign_socket,\n    bool initially_muted) {\n  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);\n  DCHECK(stream_created_callback_);\n  DCHECK(shared_memory);\n  DCHECK(foreign_socket);\n\n  base::SharedMemoryHandle foreign_memory_handle =\n      shared_memory->GetReadOnlyHandle();\n  if (!base::SharedMemory::IsHandleValid(foreign_memory_handle)) {\n    OnStreamError(/*not used*/ 0);\n    return;\n  }\n \n   mojo::ScopedSharedBufferHandle buffer_handle = mojo::WrapSharedMemoryHandle(\n       foreign_memory_handle, shared_memory->requested_size(),\n      mojo::UnwrappedSharedMemoryHandleProtection::kReadOnly);\n   mojo::ScopedHandle socket_handle =\n       mojo::WrapPlatformFile(foreign_socket->Release());\n \n  DCHECK(buffer_handle.is_valid());\n  DCHECK(socket_handle.is_valid());\n\n  base::ResetAndReturn(&stream_created_callback_)\n      .Run(std::move(buffer_handle), std::move(socket_handle), initially_muted);\n}\n",
    "cwe": [
      "CWE-787"
    ],
    "id": 944,
    "_valid_cwes": [
      "CWE-787"
    ]
  },
  {
    "cve_id": "CVE-2018-6063",
    "code_before_change": "MojoResult UnwrapSharedMemoryHandle(ScopedSharedBufferHandle handle,\n                                    base::SharedMemoryHandle* memory_handle,\n                                    size_t* size,\n                                    bool* read_only) {\n   if (!handle.is_valid())\n     return MOJO_RESULT_INVALID_ARGUMENT;\n   MojoPlatformHandle platform_handle;\n  platform_handle.struct_size = sizeof(MojoPlatformHandle);\n\n  MojoPlatformSharedBufferHandleFlags flags;\n  size_t num_bytes;\n  MojoSharedBufferGuid mojo_guid;\n  MojoResult result = MojoUnwrapPlatformSharedBufferHandle(\n      handle.release().value(), &platform_handle, &num_bytes, &mojo_guid,\n      &flags);\n  if (result != MOJO_RESULT_OK)\n    return result;\n\n   if (size)\n     *size = num_bytes;\n \n  if (read_only)\n    *read_only = flags & MOJO_PLATFORM_SHARED_BUFFER_HANDLE_FLAG_READ_ONLY;\n \n   base::UnguessableToken guid =\n       base::UnguessableToken::Deserialize(mojo_guid.high, mojo_guid.low);\n#if defined(OS_MACOSX) && !defined(OS_IOS)\n  DCHECK_EQ(platform_handle.type, MOJO_PLATFORM_HANDLE_TYPE_MACH_PORT);\n  *memory_handle = base::SharedMemoryHandle(\n      static_cast<mach_port_t>(platform_handle.value), num_bytes, guid);\n#elif defined(OS_FUCHSIA)\n  DCHECK_EQ(platform_handle.type, MOJO_PLATFORM_HANDLE_TYPE_FUCHSIA_HANDLE);\n  *memory_handle = base::SharedMemoryHandle(\n      static_cast<zx_handle_t>(platform_handle.value), num_bytes, guid);\n#elif defined(OS_POSIX)\n  DCHECK_EQ(platform_handle.type, MOJO_PLATFORM_HANDLE_TYPE_FILE_DESCRIPTOR);\n  *memory_handle = base::SharedMemoryHandle(\n      base::FileDescriptor(static_cast<int>(platform_handle.value), false),\n      num_bytes, guid);\n#elif defined(OS_WIN)\n  DCHECK_EQ(platform_handle.type, MOJO_PLATFORM_HANDLE_TYPE_WINDOWS_HANDLE);\n  *memory_handle = base::SharedMemoryHandle(\n      reinterpret_cast<HANDLE>(platform_handle.value), num_bytes, guid);\n#endif\n\n  return MOJO_RESULT_OK;\n}\n",
    "code_after_change": "MojoResult UnwrapSharedMemoryHandle(ScopedSharedBufferHandle handle,\nMojoResult UnwrapSharedMemoryHandle(\n    ScopedSharedBufferHandle handle,\n    base::SharedMemoryHandle* memory_handle,\n    size_t* size,\n    UnwrappedSharedMemoryHandleProtection* protection) {\n   if (!handle.is_valid())\n     return MOJO_RESULT_INVALID_ARGUMENT;\n   MojoPlatformHandle platform_handle;\n  platform_handle.struct_size = sizeof(MojoPlatformHandle);\n\n  MojoPlatformSharedBufferHandleFlags flags;\n  size_t num_bytes;\n  MojoSharedBufferGuid mojo_guid;\n  MojoResult result = MojoUnwrapPlatformSharedBufferHandle(\n      handle.release().value(), &platform_handle, &num_bytes, &mojo_guid,\n      &flags);\n  if (result != MOJO_RESULT_OK)\n    return result;\n\n   if (size)\n     *size = num_bytes;\n \n  if (protection) {\n    *protection =\n        flags & MOJO_PLATFORM_SHARED_BUFFER_HANDLE_FLAG_HANDLE_IS_READ_ONLY\n            ? UnwrappedSharedMemoryHandleProtection::kReadOnly\n            : UnwrappedSharedMemoryHandleProtection::kReadWrite;\n  }\n \n   base::UnguessableToken guid =\n       base::UnguessableToken::Deserialize(mojo_guid.high, mojo_guid.low);\n#if defined(OS_MACOSX) && !defined(OS_IOS)\n  DCHECK_EQ(platform_handle.type, MOJO_PLATFORM_HANDLE_TYPE_MACH_PORT);\n  *memory_handle = base::SharedMemoryHandle(\n      static_cast<mach_port_t>(platform_handle.value), num_bytes, guid);\n#elif defined(OS_FUCHSIA)\n  DCHECK_EQ(platform_handle.type, MOJO_PLATFORM_HANDLE_TYPE_FUCHSIA_HANDLE);\n  *memory_handle = base::SharedMemoryHandle(\n      static_cast<zx_handle_t>(platform_handle.value), num_bytes, guid);\n#elif defined(OS_POSIX)\n  DCHECK_EQ(platform_handle.type, MOJO_PLATFORM_HANDLE_TYPE_FILE_DESCRIPTOR);\n  *memory_handle = base::SharedMemoryHandle(\n      base::FileDescriptor(static_cast<int>(platform_handle.value), false),\n      num_bytes, guid);\n#elif defined(OS_WIN)\n  DCHECK_EQ(platform_handle.type, MOJO_PLATFORM_HANDLE_TYPE_WINDOWS_HANDLE);\n  *memory_handle = base::SharedMemoryHandle(\n      reinterpret_cast<HANDLE>(platform_handle.value), num_bytes, guid);\n#endif\n\n  return MOJO_RESULT_OK;\n}\n",
    "cwe": [
      "CWE-787"
    ],
    "id": 1015,
    "_valid_cwes": [
      "CWE-787"
    ]
  }
]